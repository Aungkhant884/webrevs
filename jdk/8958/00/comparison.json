{"files":[{"patch":"@@ -1467,1 +1467,0 @@\n-    Node* init_raw_mem = raw_mem;\n@@ -1475,1 +1474,0 @@\n-    Node* phi = PhiNode::make(region, raw_mem, Type::MEMORY, TypeRawPtr::BOTTOM);\n@@ -1479,1 +1477,0 @@\n-    Node* phi2 = PhiNode::make(region2, raw_mem, Type::MEMORY, TypeRawPtr::BOTTOM);\n@@ -1484,1 +1481,0 @@\n-    phi->init_req(_heap_stable, raw_mem);\n@@ -1492,1 +1488,0 @@\n-      phi2->init_req(_null_path, raw_mem);\n@@ -1495,1 +1490,0 @@\n-      phi2->del_req(_null_path);\n@@ -1541,1 +1535,0 @@\n-    phi2->init_req(_fast_path, index_update);\n@@ -1545,6 +1538,0 @@\n-    Node* base = find_bottom_mem(ctrl, phase);\n-\n-    MergeMemNode* mm = MergeMemNode::make(base);\n-    mm->set_memory_at(Compile::AliasIdxRaw, raw_mem);\n-    phase->register_new_node(mm, ctrl);\n-\n@@ -1554,1 +1541,1 @@\n-    call->init_req(TypeFunc::Memory, mm);\n+    call->init_req(TypeFunc::Memory, phase->C->top());\n@@ -1563,2 +1550,0 @@\n-    Node* mem_proj = new ProjNode(call, TypeFunc::Memory);\n-    phase->register_new_node(mem_proj, call);\n@@ -1568,1 +1553,0 @@\n-    phi2->init_req(_slow_path, mem_proj);\n@@ -1571,1 +1555,0 @@\n-    phase->register_new_node(phi2, region2);\n@@ -1574,1 +1557,0 @@\n-    phi->init_req(_heap_unstable, phi2);\n@@ -1577,1 +1559,0 @@\n-    phase->register_new_node(phi, region);\n@@ -1583,1 +1564,1 @@\n-      assert(n != init_raw_mem, \"should leave input raw mem above the barrier\");\n+      assert(n != raw_mem, \"should leave input raw mem above the barrier\");\n@@ -1587,1 +1568,0 @@\n-    fixer.fix_mem(init_ctrl, region, init_raw_mem, raw_mem_for_ctrl, phi, uses);\n@@ -2408,266 +2388,0 @@\n-bool MemoryGraphFixer::has_mem_phi(Node* region) const {\n-  for (DUIterator_Fast imax, i = region->fast_outs(imax); i < imax; i++) {\n-    Node* use = region->fast_out(i);\n-    if (use->is_Phi() && use->bottom_type() == Type::MEMORY &&\n-        (_phase->C->get_alias_index(use->adr_type()) == _alias)) {\n-      return true;\n-    }\n-  }\n-  return false;\n-}\n-\n-void MemoryGraphFixer::fix_mem(Node* ctrl, Node* new_ctrl, Node* mem, Node* mem_for_ctrl, Node* new_mem, Unique_Node_List& uses) {\n-  assert(_phase->ctrl_or_self(new_mem) == new_ctrl, \"\");\n-  const bool trace = false;\n-  DEBUG_ONLY(if (trace) { tty->print(\"ZZZ control is\"); ctrl->dump(); });\n-  DEBUG_ONLY(if (trace) { tty->print(\"ZZZ mem is\"); mem->dump(); });\n-  GrowableArray<Node*> phis;\n-  if (mem_for_ctrl != mem) {\n-    Node* old = mem_for_ctrl;\n-    Node* prev = NULL;\n-    while (old != mem) {\n-      prev = old;\n-      if (old->is_Store() || old->is_ClearArray() || old->is_LoadStore()) {\n-        assert(_alias == Compile::AliasIdxRaw, \"\");\n-        old = old->in(MemNode::Memory);\n-      } else if (old->Opcode() == Op_SCMemProj) {\n-        assert(_alias == Compile::AliasIdxRaw, \"\");\n-        old = old->in(0);\n-      } else {\n-        ShouldNotReachHere();\n-      }\n-    }\n-    assert(prev != NULL, \"\");\n-    if (new_ctrl != ctrl) {\n-      _memory_nodes.map(ctrl->_idx, mem);\n-      _memory_nodes.map(new_ctrl->_idx, mem_for_ctrl);\n-    }\n-    uint input = (uint)MemNode::Memory;\n-    _phase->igvn().replace_input_of(prev, input, new_mem);\n-  } else {\n-    uses.clear();\n-    _memory_nodes.map(new_ctrl->_idx, new_mem);\n-    uses.push(new_ctrl);\n-    for(uint next = 0; next < uses.size(); next++ ) {\n-      Node *n = uses.at(next);\n-      assert(n->is_CFG(), \"\");\n-      DEBUG_ONLY(if (trace) { tty->print(\"ZZZ ctrl\"); n->dump(); });\n-      for (DUIterator_Fast imax, i = n->fast_outs(imax); i < imax; i++) {\n-        Node* u = n->fast_out(i);\n-        if (!u->is_Root() && u->is_CFG() && u != n) {\n-          Node* m = _memory_nodes[u->_idx];\n-          if (u->is_Region() && (!u->is_OuterStripMinedLoop() || _include_lsm) &&\n-              !has_mem_phi(u) &&\n-              u->unique_ctrl_out()->Opcode() != Op_Halt) {\n-            DEBUG_ONLY(if (trace) { tty->print(\"ZZZ region\"); u->dump(); });\n-            DEBUG_ONLY(if (trace && m != NULL) { tty->print(\"ZZZ mem\"); m->dump(); });\n-\n-            if (!mem_is_valid(m, u) || !m->is_Phi()) {\n-              bool push = true;\n-              bool create_phi = true;\n-              if (_phase->is_dominator(new_ctrl, u)) {\n-                create_phi = false;\n-              }\n-              if (create_phi) {\n-                Node* phi = new PhiNode(u, Type::MEMORY, _phase->C->get_adr_type(_alias));\n-                _phase->register_new_node(phi, u);\n-                phis.push(phi);\n-                DEBUG_ONLY(if (trace) { tty->print(\"ZZZ new phi\"); phi->dump(); });\n-                if (!mem_is_valid(m, u)) {\n-                  DEBUG_ONLY(if (trace) { tty->print(\"ZZZ setting mem\"); phi->dump(); });\n-                  _memory_nodes.map(u->_idx, phi);\n-                } else {\n-                  DEBUG_ONLY(if (trace) { tty->print(\"ZZZ NOT setting mem\"); m->dump(); });\n-                  for (;;) {\n-                    assert(m->is_Mem() || m->is_LoadStore() || m->is_Proj(), \"\");\n-                    Node* next = NULL;\n-                    if (m->is_Proj()) {\n-                      next = m->in(0);\n-                    } else {\n-                      assert(m->is_Mem() || m->is_LoadStore(), \"\");\n-                      assert(_alias == Compile::AliasIdxRaw, \"\");\n-                      next = m->in(MemNode::Memory);\n-                    }\n-                    if (_phase->get_ctrl(next) != u) {\n-                      break;\n-                    }\n-                    if (next->is_MergeMem()) {\n-                      assert(_phase->get_ctrl(next->as_MergeMem()->memory_at(_alias)) != u, \"\");\n-                      break;\n-                    }\n-                    if (next->is_Phi()) {\n-                      assert(next->adr_type() == TypePtr::BOTTOM && next->in(0) == u, \"\");\n-                      break;\n-                    }\n-                    m = next;\n-                  }\n-\n-                  DEBUG_ONLY(if (trace) { tty->print(\"ZZZ setting to phi\"); m->dump(); });\n-                  assert(m->is_Mem() || m->is_LoadStore(), \"\");\n-                  uint input = (uint)MemNode::Memory;\n-                  _phase->igvn().replace_input_of(m, input, phi);\n-                  push = false;\n-                }\n-              } else {\n-                DEBUG_ONLY(if (trace) { tty->print(\"ZZZ skipping region\"); u->dump(); });\n-              }\n-              if (push) {\n-                uses.push(u);\n-              }\n-            }\n-          } else if (!mem_is_valid(m, u) &&\n-                     !(u->Opcode() == Op_CProj && u->in(0)->Opcode() == Op_NeverBranch && u->as_Proj()->_con == 1)) {\n-            uses.push(u);\n-          }\n-        }\n-      }\n-    }\n-    for (int i = 0; i < phis.length(); i++) {\n-      Node* n = phis.at(i);\n-      Node* r = n->in(0);\n-      DEBUG_ONLY(if (trace) { tty->print(\"ZZZ fixing new phi\"); n->dump(); });\n-      for (uint j = 1; j < n->req(); j++) {\n-        Node* m = find_mem(r->in(j), NULL);\n-        _phase->igvn().replace_input_of(n, j, m);\n-        DEBUG_ONLY(if (trace) { tty->print(\"ZZZ fixing new phi: %d\", j); m->dump(); });\n-      }\n-    }\n-  }\n-  uint last = _phase->C->unique();\n-  MergeMemNode* mm = NULL;\n-  int alias = _alias;\n-  DEBUG_ONLY(if (trace) { tty->print(\"ZZZ raw mem is\"); mem->dump(); });\n-  \/\/ Process loads first to not miss an anti-dependency: if the memory\n-  \/\/ edge of a store is updated before a load is processed then an\n-  \/\/ anti-dependency may be missed.\n-  for (DUIterator i = mem->outs(); mem->has_out(i); i++) {\n-    Node* u = mem->out(i);\n-    if (u->_idx < last && u->is_Load() && _phase->C->get_alias_index(u->adr_type()) == alias) {\n-      Node* m = find_mem(_phase->get_ctrl(u), u);\n-      if (m != mem) {\n-        DEBUG_ONLY(if (trace) { tty->print(\"ZZZ setting memory of use\"); u->dump(); });\n-        _phase->igvn().replace_input_of(u, MemNode::Memory, m);\n-        --i;\n-      }\n-    }\n-  }\n-  for (DUIterator i = mem->outs(); mem->has_out(i); i++) {\n-    Node* u = mem->out(i);\n-    if (u->_idx < last) {\n-      if (u->is_Mem()) {\n-        if (_phase->C->get_alias_index(u->adr_type()) == alias) {\n-          Node* m = find_mem(_phase->get_ctrl(u), u);\n-          if (m != mem) {\n-            DEBUG_ONLY(if (trace) { tty->print(\"ZZZ setting memory of use\"); u->dump(); });\n-            _phase->igvn().replace_input_of(u, MemNode::Memory, m);\n-            --i;\n-          }\n-        }\n-      } else if (u->is_MergeMem()) {\n-        MergeMemNode* u_mm = u->as_MergeMem();\n-        if (u_mm->memory_at(alias) == mem) {\n-          MergeMemNode* newmm = NULL;\n-          for (DUIterator_Fast jmax, j = u->fast_outs(jmax); j < jmax; j++) {\n-            Node* uu = u->fast_out(j);\n-            assert(!uu->is_MergeMem(), \"chain of MergeMems?\");\n-            if (uu->is_Phi()) {\n-              assert(uu->adr_type() == TypePtr::BOTTOM, \"\");\n-              Node* region = uu->in(0);\n-              int nb = 0;\n-              for (uint k = 1; k < uu->req(); k++) {\n-                if (uu->in(k) == u) {\n-                  Node* m = find_mem(region->in(k), NULL);\n-                  if (m != mem) {\n-                    DEBUG_ONLY(if (trace) { tty->print(\"ZZZ setting memory of phi %d\", k); uu->dump(); });\n-                    newmm = clone_merge_mem(u, mem, m, _phase->ctrl_or_self(m), i);\n-                    if (newmm != u) {\n-                      _phase->igvn().replace_input_of(uu, k, newmm);\n-                      nb++;\n-                      --jmax;\n-                    }\n-                  }\n-                }\n-              }\n-              if (nb > 0) {\n-                --j;\n-              }\n-            } else {\n-              Node* m = find_mem(_phase->ctrl_or_self(uu), uu);\n-              if (m != mem) {\n-                DEBUG_ONLY(if (trace) { tty->print(\"ZZZ setting memory of use\"); uu->dump(); });\n-                newmm = clone_merge_mem(u, mem, m, _phase->ctrl_or_self(m), i);\n-                if (newmm != u) {\n-                  _phase->igvn().replace_input_of(uu, uu->find_edge(u), newmm);\n-                  --j, --jmax;\n-                }\n-              }\n-            }\n-          }\n-        }\n-      } else if (u->is_Phi()) {\n-        assert(u->bottom_type() == Type::MEMORY, \"what else?\");\n-        if (_phase->C->get_alias_index(u->adr_type()) == alias || u->adr_type() == TypePtr::BOTTOM) {\n-          Node* region = u->in(0);\n-          bool replaced = false;\n-          for (uint j = 1; j < u->req(); j++) {\n-            if (u->in(j) == mem) {\n-              Node* m = find_mem(region->in(j), NULL);\n-              Node* nnew = m;\n-              if (m != mem) {\n-                if (u->adr_type() == TypePtr::BOTTOM) {\n-                  mm = allocate_merge_mem(mem, m, _phase->ctrl_or_self(m));\n-                  nnew = mm;\n-                }\n-                DEBUG_ONLY(if (trace) { tty->print(\"ZZZ setting memory of phi %d\", j); u->dump(); });\n-                _phase->igvn().replace_input_of(u, j, nnew);\n-                replaced = true;\n-              }\n-            }\n-          }\n-          if (replaced) {\n-            --i;\n-          }\n-        }\n-      } else if ((u->adr_type() == TypePtr::BOTTOM && u->Opcode() != Op_StrInflatedCopy) ||\n-                 u->adr_type() == NULL) {\n-        assert(u->adr_type() != NULL ||\n-               u->Opcode() == Op_Rethrow ||\n-               u->Opcode() == Op_Return ||\n-               u->Opcode() == Op_SafePoint ||\n-               (u->is_CallStaticJava() && u->as_CallStaticJava()->uncommon_trap_request() != 0) ||\n-               (u->is_CallStaticJava() && u->as_CallStaticJava()->_entry_point == OptoRuntime::rethrow_stub()) ||\n-               u->Opcode() == Op_CallLeaf, \"\");\n-        Node* m = find_mem(_phase->ctrl_or_self(u), u);\n-        if (m != mem) {\n-          mm = allocate_merge_mem(mem, m, _phase->get_ctrl(m));\n-          _phase->igvn().replace_input_of(u, u->find_edge(mem), mm);\n-          --i;\n-        }\n-      } else if (_phase->C->get_alias_index(u->adr_type()) == alias) {\n-        Node* m = find_mem(_phase->ctrl_or_self(u), u);\n-        if (m != mem) {\n-          DEBUG_ONLY(if (trace) { tty->print(\"ZZZ setting memory of use\"); u->dump(); });\n-          _phase->igvn().replace_input_of(u, u->find_edge(mem), m);\n-          --i;\n-        }\n-      } else if (u->adr_type() != TypePtr::BOTTOM &&\n-                 _memory_nodes[_phase->ctrl_or_self(u)->_idx] == u) {\n-        Node* m = find_mem(_phase->ctrl_or_self(u), u);\n-        assert(m != mem, \"\");\n-        \/\/ u is on the wrong slice...\n-        assert(u->is_ClearArray(), \"\");\n-        DEBUG_ONLY(if (trace) { tty->print(\"ZZZ setting memory of use\"); u->dump(); });\n-        _phase->igvn().replace_input_of(u, u->find_edge(mem), m);\n-        --i;\n-      }\n-    }\n-  }\n-#ifdef ASSERT\n-  assert(new_mem->outcnt() > 0, \"\");\n-  for (int i = 0; i < phis.length(); i++) {\n-    Node* n = phis.at(i);\n-    assert(n->outcnt() > 0, \"new phi must have uses now\");\n-  }\n-#endif\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahSupport.cpp","additions":2,"deletions":288,"binary":false,"changes":290,"status":"modified"},{"patch":"@@ -121,1 +121,0 @@\n-  bool has_mem_phi(Node* region) const;\n@@ -131,1 +130,1 @@\n-  void fix_mem(Node* ctrl, Node* region, Node* mem, Node* mem_for_ctrl, Node* mem_phi, Unique_Node_List& uses);\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahSupport.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"}]}