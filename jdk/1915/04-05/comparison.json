{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import java.nio.CharBuffer;\n+\n@@ -148,0 +150,17 @@\n+    @Override\n+    public int read(CharBuffer target) throws IOException {\n+        synchronized (lock) {\n+            ensureOpen();\n+\n+            if (pos >= count) {\n+                return -1;\n+            }\n+\n+            int avail = count - pos;\n+            int len = Math.min(avail, target.remaining());\n+            target.put(buf, pos, len);\n+            pos += len;\n+            return avail;\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/io\/CharArrayReader.java","additions":20,"deletions":1,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -190,3 +190,6 @@\n-            int off = target.arrayOffset() + target.position();\n-            int len = target.remaining();\n-            nread = this.read(cbuf, off, len);\n+            int pos = target.position();\n+            int rem = target.limit() - pos;\n+            if (rem <= 0)\n+                return -1;\n+            int off = target.arrayOffset() + pos;\n+            nread = this.read(cbuf, off, rem);\n@@ -194,1 +197,1 @@\n-                target.position(target.position() + nread);\n+                target.position(pos + nread);\n","filename":"src\/java.base\/share\/classes\/java\/io\/Reader.java","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -192,24 +192,0 @@\n-    public int read(CharBuffer target) throws IOException {\n-        int len = target.remaining();\n-        synchronized (lock) {\n-            ensureOpen();\n-            if (len == 0)\n-                return 0;\n-\n-            int n = 0;\n-\n-            if (haveLeftoverChar) {\n-                \/\/ Copy the leftover char into the buffer\n-                target.put(leftoverChar);\n-                len--;\n-                haveLeftoverChar = false;\n-                n = 1;\n-                if ((len == 0) || !implReady())\n-                    \/\/ Return now if this is all we can produce w\/o blocking\n-                    return n;\n-            }\n-\n-            return n + implRead(target);\n-        }\n-    }\n-\n@@ -349,10 +325,3 @@\n-\n-        return implRead(cb);\n-    }\n-\n-    int implRead(CharBuffer cb) throws IOException {\n-\n-        \/\/ In order to handle surrogate pairs, this method requires that\n-        \/\/ the invoker attempt to read at least two characters.  Saving the\n-        \/\/ extra character, if any, at a higher level is easier than trying\n-        \/\/ to deal with it here.\n+        if (cb.position() != 0)\n+        \/\/ Ensure that cb[0] == cbuf[off]\n+        cb = cb.slice();\n@@ -361,2 +330,0 @@\n-        int initialPosition = cb.position();\n-        int nread;\n@@ -364,20 +331,3 @@\n-            CoderResult cr = decoder.decode(bb, cb, eof);\n-            nread = cb.position() - initialPosition;\n-            if (cr.isUnderflow()) {\n-                if (eof)\n-                    break;\n-                if (!cb.hasRemaining())\n-                    break;\n-                if ((nread > 0) && !inReady())\n-                    break;          \/\/ Block at most once\n-                int n = readBytes();\n-                if (n < 0) {\n-                    eof = true;\n-                    if ((nread == 0) && (!bb.hasRemaining()))\n-                        break;\n-                    decoder.reset();\n-                }\n-                continue;\n-            }\n-            if (cr.isOverflow()) {\n-                assert nread > 0;\n+        CoderResult cr = decoder.decode(bb, cb, eof);\n+        if (cr.isUnderflow()) {\n+            if (eof)\n@@ -385,0 +335,10 @@\n+            if (!cb.hasRemaining())\n+                break;\n+            if ((cb.position() > 0) && !inReady())\n+                break;          \/\/ Block at most once\n+            int n = readBytes();\n+            if (n < 0) {\n+                eof = true;\n+                if ((cb.position() == 0) && (!bb.hasRemaining()))\n+                    break;\n+                decoder.reset();\n@@ -386,1 +346,7 @@\n-            cr.throwException();\n+            continue;\n+        }\n+        if (cr.isOverflow()) {\n+            assert cb.position() > 0;\n+            break;\n+        }\n+        cr.throwException();\n@@ -390,2 +356,2 @@\n-            \/\/ ## Need to flush decoder\n-            decoder.reset();\n+        \/\/ ## Need to flush decoder\n+        decoder.reset();\n@@ -394,1 +360,1 @@\n-        if (nread == 0) {\n+        if (cb.position() == 0) {\n@@ -399,1 +365,1 @@\n-        return nread;\n+        return cb.position();\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/cs\/StreamDecoder.java","additions":28,"deletions":62,"binary":false,"changes":90,"status":"modified"}]}