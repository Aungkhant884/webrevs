{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import java.nio.CharBuffer;\n@@ -152,0 +153,4 @@\n+    public int read(CharBuffer target) throws IOException {\n+        return sd.read(target);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/io\/InputStreamReader.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -187,6 +187,27 @@\n-        int len = target.remaining();\n-        char[] cbuf = new char[len];\n-        int n = read(cbuf, 0, len);\n-        if (n > 0)\n-            target.put(cbuf, 0, n);\n-        return n;\n+        int nread;\n+        if (target.hasArray()) {\n+            char cbuf[] = target.array();\n+            int off = target.arrayOffset() + target.position();\n+            int len = target.remaining();\n+            nread = this.read(cbuf, off, len);\n+            if (nread > 0)\n+                target.position(target.position() + nread);\n+        } else {\n+            int remaining = target.remaining();\n+            char cbuf[] = new char[Math.min(remaining, TRANSFER_BUFFER_SIZE)];\n+            nread = 0;\n+            synchronized (lock) {\n+                int n;\n+                do {\n+                    \/\/ read to EOF which may read more or less than buffer size\n+                    if ((n = read(cbuf, 0, Math.min(remaining, cbuf.length))) > 0) {\n+                        target.put(cbuf, 0, n);\n+                        nread += n;\n+                        remaining -= n;\n+                    }\n+                    \/\/ if the last call to read returned -1 or the number of bytes\n+                    \/\/ requested have been read then break\n+                } while (n >= 0 && remaining > 0);\n+            }\n+        }\n+        return nread;\n","filename":"src\/java.base\/share\/classes\/java\/io\/Reader.java","additions":28,"deletions":7,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -192,0 +192,24 @@\n+    public int read(CharBuffer target) throws IOException {\n+        int len = target.remaining();\n+        synchronized (lock) {\n+            ensureOpen();\n+            if (len == 0)\n+                return 0;\n+\n+            int n = 0;\n+\n+            if (haveLeftoverChar) {\n+                \/\/ Copy the leftover char into the buffer\n+                target.put(leftoverChar);\n+                len--;\n+                haveLeftoverChar = false;\n+                n = 1;\n+                if ((len == 0) || !implReady())\n+                    \/\/ Return now if this is all we can produce w\/o blocking\n+                    return n;\n+            }\n+\n+            return n + implRead(target);\n+        }\n+    }\n+\n@@ -325,3 +349,10 @@\n-        if (cb.position() != 0)\n-        \/\/ Ensure that cb[0] == cbuf[off]\n-        cb = cb.slice();\n+\n+        return implRead(cb);\n+    }\n+\n+    int implRead(CharBuffer cb) throws IOException {\n+\n+        \/\/ In order to handle surrogate pairs, this method requires that\n+        \/\/ the invoker attempt to read at least two characters.  Saving the\n+        \/\/ extra character, if any, at a higher level is easier than trying\n+        \/\/ to deal with it here.\n@@ -330,0 +361,2 @@\n+        int initialPosition = cb.position();\n+        int nread;\n@@ -331,12 +364,6 @@\n-        CoderResult cr = decoder.decode(bb, cb, eof);\n-        if (cr.isUnderflow()) {\n-            if (eof)\n-                break;\n-            if (!cb.hasRemaining())\n-                break;\n-            if ((cb.position() > 0) && !inReady())\n-                break;          \/\/ Block at most once\n-            int n = readBytes();\n-            if (n < 0) {\n-                eof = true;\n-                if ((cb.position() == 0) && (!bb.hasRemaining()))\n+            CoderResult cr = decoder.decode(bb, cb, eof);\n+            nread = cb.position() - initialPosition;\n+            if (cr.isUnderflow()) {\n+                if (eof)\n+                    break;\n+                if (!cb.hasRemaining())\n@@ -344,1 +371,10 @@\n-                decoder.reset();\n+                if ((nread > 0) && !inReady())\n+                    break;          \/\/ Block at most once\n+                int n = readBytes();\n+                if (n < 0) {\n+                    eof = true;\n+                    if ((nread == 0) && (!bb.hasRemaining()))\n+                        break;\n+                    decoder.reset();\n+                }\n+                continue;\n@@ -346,7 +382,5 @@\n-            continue;\n-        }\n-        if (cr.isOverflow()) {\n-            assert cb.position() > 0;\n-            break;\n-        }\n-        cr.throwException();\n+            if (cr.isOverflow()) {\n+                assert nread > 0;\n+                break;\n+            }\n+            cr.throwException();\n@@ -356,2 +390,2 @@\n-        \/\/ ## Need to flush decoder\n-        decoder.reset();\n+            \/\/ ## Need to flush decoder\n+            decoder.reset();\n@@ -360,1 +394,1 @@\n-        if (cb.position() == 0) {\n+        if (nread == 0) {\n@@ -365,1 +399,1 @@\n-        return cb.position();\n+        return nread;\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/cs\/StreamDecoder.java","additions":62,"deletions":28,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -0,0 +1,84 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4926314\n+ * @summary Test for InputStreamReader#read(CharBuffer).\n+ * @run testng ReadCharBuffer\n+ *\/\n+\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.io.*;\n+import java.nio.ByteBuffer;\n+import java.nio.CharBuffer;\n+import java.util.Arrays;\n+\n+import static java.nio.charset.StandardCharsets.US_ASCII;\n+import static org.testng.Assert.assertEquals;\n+\n+public class ReadCharBuffer {\n+\n+    private static final int BUFFER_SIZE = 24;\n+\n+    @DataProvider(name = \"buffers\")\n+    public Object[][] createBuffers() {\n+        \/\/ test both on-heap and off-heap buffers has they make use different code paths\n+        return new Object[][]{\n+                new Object[]{CharBuffer.allocate(BUFFER_SIZE)},\n+                new Object[]{ByteBuffer.allocateDirect(BUFFER_SIZE * 2).asCharBuffer()}\n+        };\n+    }\n+\n+    @Test(dataProvider = \"buffers\")\n+    public void read(CharBuffer buffer) throws IOException {\n+        fillBuffer(buffer);\n+\n+        try (Reader reader = new InputStreamReader(new ByteArrayInputStream(\"ABCDEFGHIJKLMNOPQRTUVWXYZ\".getBytes(US_ASCII)), US_ASCII)) {\n+            buffer.limit(7);\n+            buffer.position(1);\n+            assertEquals(reader.read(buffer), 6);\n+            assertEquals(buffer.position(), 7);\n+            assertEquals(buffer.limit(), 7);\n+\n+            buffer.limit(16);\n+            buffer.position(8);\n+            assertEquals(reader.read(buffer), 8);\n+            assertEquals(buffer.position(), 16);\n+            assertEquals(buffer.limit(), 16);\n+        }\n+\n+        buffer.clear();\n+        assertEquals(buffer.toString(), \"xABCDEFxGHIJKLMNxxxxxxxx\");\n+    }\n+\n+    private void fillBuffer(CharBuffer buffer) {\n+        char[] filler = new char[BUFFER_SIZE];\n+        Arrays.fill(filler, 'x');\n+        buffer.put(filler);\n+        buffer.clear();\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/io\/InputStreamReader\/ReadCharBuffer.java","additions":84,"deletions":0,"binary":false,"changes":84,"status":"added"},{"patch":"@@ -0,0 +1,147 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4926314\n+ * @summary Test for Reader#read(CharBuffer).\n+ * @run testng ReadCharBuffer\n+ *\/\n+\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.io.*;\n+import java.nio.ByteBuffer;\n+import java.nio.CharBuffer;\n+import java.util.Arrays;\n+import java.util.Objects;\n+\n+import static org.testng.Assert.assertEquals;\n+\n+@Test(groups = \"unit\")\n+public class ReadCharBuffer {\n+\n+    private static final int BUFFER_SIZE = 8 + 8192 + 2;\n+\n+    @DataProvider(name = \"buffers\")\n+    public Object[][] createBuffers() {\n+        \/\/ test both on-heap and off-heap buffers has they make use different code paths\n+        return new Object[][]{\n+                new Object[]{CharBuffer.allocate(BUFFER_SIZE)},\n+                new Object[]{ByteBuffer.allocateDirect(BUFFER_SIZE * 2).asCharBuffer()}\n+        };\n+    }\n+\n+    @Test(dataProvider = \"buffers\")\n+    public void read(CharBuffer buffer) throws IOException {\n+        fillBuffer(buffer);\n+\n+        StringBuilder input = new StringBuilder(BUFFER_SIZE - 2 + 1);\n+        input.append(\"ABCDEF\");\n+        for (int i = 0; i < 8192; i++) {\n+            input.append('y');\n+        }\n+        input.append(\"GH\");\n+\n+        try (Reader reader = new UnoptimizedStringReader(input.toString())) {\n+            \/\/ put only between position and limit in the target buffer\n+            int limit = 1 + 6;\n+            buffer.limit(limit);\n+            buffer.position(1);\n+            assertEquals(reader.read(buffer), 6);\n+            assertEquals(buffer.position(), limit);\n+            assertEquals(buffer.limit(), limit);\n+\n+            \/\/ read the full temporary buffer\n+            \/\/ and then accurately reduce the next #read call\n+            limit = 8 + 8192 + 1;\n+            buffer.limit(8 + 8192 + 1);\n+            buffer.position(8);\n+            assertEquals(reader.read(buffer), 8192 + 1);\n+            assertEquals(buffer.position(), limit);\n+            assertEquals(buffer.limit(), limit);\n+\n+            assertEquals(reader.read(), 'H');\n+            assertEquals(reader.read(), -1);\n+        }\n+\n+        buffer.clear();\n+        StringBuilder expected = new StringBuilder(BUFFER_SIZE);\n+        expected.append(\"xABCDEFx\");\n+        for (int i = 0; i < 8192; i++) {\n+            expected.append('y');\n+        }\n+        expected.append(\"Gx\");\n+        assertEquals(buffer.toString(), expected.toString());\n+    }\n+\n+    private void fillBuffer(CharBuffer buffer) {\n+        char[] filler = new char[buffer.remaining()];\n+        Arrays.fill(filler, 'x');\n+        buffer.put(filler);\n+        buffer.clear();\n+    }\n+\n+    \/**\n+     * Unoptimized version of StringReader in case StringReader overrides\n+     * #read(CharBuffer)\n+     *\/\n+    static final class UnoptimizedStringReader extends Reader {\n+\n+        private String str;\n+        private int next = 0;\n+\n+        UnoptimizedStringReader(String s) {\n+            this.str = s;\n+        }\n+\n+        @Override\n+        public int read() throws IOException {\n+            synchronized (lock) {\n+                if (next >= str.length())\n+                    return -1;\n+                return str.charAt(next++);\n+            }\n+        }\n+\n+        @Override\n+        public int read(char cbuf[], int off, int len) throws IOException {\n+            synchronized (lock) {\n+                Objects.checkFromIndexSize(off, len, cbuf.length);\n+                if (next >= str.length())\n+                    return -1;\n+                int n = Math.min(str.length() - next, len);\n+                str.getChars(next, next + n, cbuf, off);\n+                next += n;\n+                return n;\n+            }\n+        }\n+\n+        @Override\n+        public void close() throws IOException {\n+\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/io\/Reader\/ReadCharBuffer.java","additions":147,"deletions":0,"binary":false,"changes":147,"status":"added"}]}