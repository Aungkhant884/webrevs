{"files":[{"patch":"@@ -163,1 +163,1 @@\n-            return avail;\n+            return len;\n","filename":"src\/java.base\/share\/classes\/java\/io\/CharArrayReader.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-    private static final int WORK_BUFFER_SIZE = 8192;\n+    private static final int TRANSFER_BUFFER_SIZE = 8192;\n@@ -151,6 +151,0 @@\n-    \/**\n-     * Work buffer, null until allocated, guarded by #lock,\n-     * may grow up to WORK_BUFFER_SIZE.\n-     *\/\n-    private char[] workBuffer = null;\n-\n@@ -205,18 +199,5 @@\n-            int remaining = target.remaining();\n-            int bufferSize = Math.min(remaining, WORK_BUFFER_SIZE);\n-            nread = 0;\n-            synchronized (lock) {\n-                if ((workBuffer == null) || (workBuffer.length < bufferSize))\n-                    workBuffer = new char[bufferSize];\n-                int n;\n-                do {\n-                    \/\/ read to EOF which may read more or less than buffer size\n-                    if ((n = read(workBuffer, 0, Math.min(remaining, bufferSize))) > 0) {\n-                        target.put(workBuffer, 0, n);\n-                        nread += n;\n-                        remaining -= n;\n-                    }\n-                    \/\/ if the last call to read returned -1 or the number of bytes\n-                    \/\/ requested have been read then break\n-                } while (n >= 0 && remaining > 0);\n-            }\n+            int len = target.remaining();\n+            char[] cbuf = new char[len];\n+            nread = read(cbuf, 0, len);\n+            if (nread > 0)\n+                target.put(cbuf, 0, nread);\n@@ -295,0 +276,6 @@\n+    \/** Maximum skip-buffer size *\/\n+    private static final int maxSkipBufferSize = 8192;\n+\n+    \/** Skip buffer, null until allocated *\/\n+    private char[] skipBuffer = null;\n+\n@@ -309,1 +296,1 @@\n-        int nn = (int) Math.min(n, WORK_BUFFER_SIZE);\n+        int nn = (int) Math.min(n, maxSkipBufferSize);\n@@ -311,2 +298,2 @@\n-            if ((workBuffer == null) || (workBuffer.length < nn))\n-                workBuffer = new char[nn];\n+            if ((skipBuffer == null) || (skipBuffer.length < nn))\n+                skipBuffer = new char[nn];\n@@ -315,1 +302,1 @@\n-                int nc = read(workBuffer, 0, (int)Math.min(r, nn));\n+                int nc = read(skipBuffer, 0, (int)Math.min(r, nn));\n@@ -420,1 +407,1 @@\n-        char[] buffer = new char[WORK_BUFFER_SIZE];\n+        char[] buffer = new char[TRANSFER_BUFFER_SIZE];\n@@ -422,1 +409,1 @@\n-        while ((nRead = read(buffer, 0, WORK_BUFFER_SIZE)) >= 0) {\n+        while ((nRead = read(buffer, 0, TRANSFER_BUFFER_SIZE)) >= 0) {\n","filename":"src\/java.base\/share\/classes\/java\/io\/Reader.java","additions":18,"deletions":31,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -0,0 +1,88 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4926314\n+ * @summary Test for CharArrayReader#read(CharBuffer).\n+ * @run testng ReadCharBuffer\n+ *\/\n+\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+\n+import java.io.CharArrayReader;\n+import java.io.IOException;\n+import java.io.Reader;\n+import java.nio.ByteBuffer;\n+import java.nio.CharBuffer;\n+import java.util.Arrays;\n+\n+import static org.testng.Assert.assertEquals;\n+\n+public class ReadCharBuffer {\n+\n+    private static final int BUFFER_SIZE = 7;\n+\n+    @DataProvider(name = \"buffers\")\n+    public Object[][] createBuffers() {\n+        \/\/ test both on-heap and off-heap buffers has they may use different code paths\n+        return new Object[][]{\n+                new Object[]{CharBuffer.allocate(BUFFER_SIZE)},\n+                new Object[]{ByteBuffer.allocateDirect(BUFFER_SIZE * 2).asCharBuffer()}\n+        };\n+    }\n+\n+    @Test(dataProvider = \"buffers\")\n+    public void read(CharBuffer buffer) throws IOException {\n+        fillBuffer(buffer);\n+\n+        try (Reader reader = new CharArrayReader(\"ABCD\".toCharArray())) {\n+            buffer.limit(3);\n+            buffer.position(1);\n+            assertEquals(reader.read(buffer), 2);\n+            assertEquals(buffer.position(), 3);\n+            assertEquals(buffer.limit(), 3);\n+\n+            buffer.limit(7);\n+            buffer.position(4);\n+            assertEquals(reader.read(buffer), 2);\n+            assertEquals(buffer.position(), 6);\n+            assertEquals(buffer.limit(), 7);\n+\n+            assertEquals(reader.read(buffer), -1);\n+        }\n+\n+        buffer.clear();\n+        assertEquals(buffer.toString(), \"xABxCDx\");\n+    }\n+\n+    private void fillBuffer(CharBuffer buffer) {\n+        char[] filler = new char[BUFFER_SIZE];\n+        Arrays.fill(filler, 'x');\n+        buffer.put(filler);\n+        buffer.clear();\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/io\/CharArrayReader\/ReadCharBuffer.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"added"},{"patch":"@@ -34,1 +34,5 @@\n-import java.io.*;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.Reader;\n","filename":"test\/jdk\/java\/io\/InputStreamReader\/ReadCharBuffer.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -34,1 +34,3 @@\n-import java.io.*;\n+\n+import java.io.IOException;\n+import java.io.Reader;\n","filename":"test\/jdk\/java\/io\/Reader\/ReadCharBuffer.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"}]}