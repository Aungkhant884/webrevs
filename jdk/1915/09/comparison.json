{"files":[{"patch":"@@ -28,0 +28,1 @@\n+import java.nio.CharBuffer;\n@@ -155,0 +156,17 @@\n+    @Override\n+    public int read(CharBuffer target) throws IOException {\n+        synchronized (lock) {\n+            ensureOpen();\n+\n+            if (pos >= count) {\n+                return -1;\n+            }\n+\n+            int avail = count - pos;\n+            int len = Math.min(avail, target.remaining());\n+            target.put(buf, pos, len);\n+            pos += len;\n+            return len;\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/io\/CharArrayReader.java","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.nio.CharBuffer;\n@@ -152,0 +153,4 @@\n+    public int read(CharBuffer target) throws IOException {\n+        return sd.read(target);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/io\/InputStreamReader.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -187,6 +187,19 @@\n-        int len = target.remaining();\n-        char[] cbuf = new char[len];\n-        int n = read(cbuf, 0, len);\n-        if (n > 0)\n-            target.put(cbuf, 0, n);\n-        return n;\n+        int nread;\n+        if (target.hasArray()) {\n+            char[] cbuf = target.array();\n+            int pos = target.position();\n+            int rem = target.limit() - pos;\n+            if (rem <= 0)\n+                return -1;\n+            int off = target.arrayOffset() + pos;\n+            nread = this.read(cbuf, off, rem);\n+            if (nread > 0)\n+                target.position(pos + nread);\n+        } else {\n+            int len = target.remaining();\n+            char[] cbuf = new char[len];\n+            nread = read(cbuf, 0, len);\n+            if (nread > 0)\n+                target.put(cbuf, 0, nread);\n+        }\n+        return nread;\n@@ -209,1 +222,1 @@\n-        char cb[] = new char[1];\n+        char[] cb = new char[1];\n@@ -234,1 +247,1 @@\n-    public int read(char cbuf[]) throws IOException {\n+    public int read(char[] cbuf) throws IOException {\n@@ -261,1 +274,1 @@\n-    public abstract int read(char cbuf[], int off, int len) throws IOException;\n+    public abstract int read(char[] cbuf, int off, int len) throws IOException;\n@@ -267,1 +280,1 @@\n-    private char skipBuffer[] = null;\n+    private char[] skipBuffer = null;\n","filename":"src\/java.base\/share\/classes\/java\/io\/Reader.java","additions":23,"deletions":10,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -0,0 +1,88 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4926314\n+ * @summary Test for CharArrayReader#read(CharBuffer).\n+ * @run testng ReadCharBuffer\n+ *\/\n+\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+\n+import java.io.CharArrayReader;\n+import java.io.IOException;\n+import java.io.Reader;\n+import java.nio.ByteBuffer;\n+import java.nio.CharBuffer;\n+import java.util.Arrays;\n+\n+import static org.testng.Assert.assertEquals;\n+\n+public class ReadCharBuffer {\n+\n+    private static final int BUFFER_SIZE = 7;\n+\n+    @DataProvider(name = \"buffers\")\n+    public Object[][] createBuffers() {\n+        \/\/ test both on-heap and off-heap buffers as they may use different code paths\n+        return new Object[][]{\n+                new Object[]{CharBuffer.allocate(BUFFER_SIZE)},\n+                new Object[]{ByteBuffer.allocateDirect(BUFFER_SIZE * 2).asCharBuffer()}\n+        };\n+    }\n+\n+    @Test(dataProvider = \"buffers\")\n+    public void read(CharBuffer buffer) throws IOException {\n+        fillBuffer(buffer);\n+\n+        try (Reader reader = new CharArrayReader(\"ABCD\".toCharArray())) {\n+            buffer.limit(3);\n+            buffer.position(1);\n+            assertEquals(reader.read(buffer), 2);\n+            assertEquals(buffer.position(), 3);\n+            assertEquals(buffer.limit(), 3);\n+\n+            buffer.limit(7);\n+            buffer.position(4);\n+            assertEquals(reader.read(buffer), 2);\n+            assertEquals(buffer.position(), 6);\n+            assertEquals(buffer.limit(), 7);\n+\n+            assertEquals(reader.read(buffer), -1);\n+        }\n+\n+        buffer.clear();\n+        assertEquals(buffer.toString(), \"xABxCDx\");\n+    }\n+\n+    private void fillBuffer(CharBuffer buffer) {\n+        char[] filler = new char[BUFFER_SIZE];\n+        Arrays.fill(filler, 'x');\n+        buffer.put(filler);\n+        buffer.clear();\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/io\/CharArrayReader\/ReadCharBuffer.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"added"},{"patch":"@@ -0,0 +1,88 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4926314\n+ * @summary Test for InputStreamReader#read(CharBuffer).\n+ * @run testng ReadCharBuffer\n+ *\/\n+\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.Reader;\n+import java.nio.ByteBuffer;\n+import java.nio.CharBuffer;\n+import java.util.Arrays;\n+\n+import static java.nio.charset.StandardCharsets.US_ASCII;\n+import static org.testng.Assert.assertEquals;\n+\n+public class ReadCharBuffer {\n+\n+    private static final int BUFFER_SIZE = 24;\n+\n+    @DataProvider(name = \"buffers\")\n+    public Object[][] createBuffers() {\n+        \/\/ test both on-heap and off-heap buffers as they make use different code paths\n+        return new Object[][]{\n+                new Object[]{CharBuffer.allocate(BUFFER_SIZE)},\n+                new Object[]{ByteBuffer.allocateDirect(BUFFER_SIZE * 2).asCharBuffer()}\n+        };\n+    }\n+\n+    @Test(dataProvider = \"buffers\")\n+    public void read(CharBuffer buffer) throws IOException {\n+        fillBuffer(buffer);\n+\n+        try (Reader reader = new InputStreamReader(new ByteArrayInputStream(\"ABCDEFGHIJKLMNOPQRTUVWXYZ\".getBytes(US_ASCII)), US_ASCII)) {\n+            buffer.limit(7);\n+            buffer.position(1);\n+            assertEquals(reader.read(buffer), 6);\n+            assertEquals(buffer.position(), 7);\n+            assertEquals(buffer.limit(), 7);\n+\n+            buffer.limit(16);\n+            buffer.position(8);\n+            assertEquals(reader.read(buffer), 8);\n+            assertEquals(buffer.position(), 16);\n+            assertEquals(buffer.limit(), 16);\n+        }\n+\n+        buffer.clear();\n+        assertEquals(buffer.toString(), \"xABCDEFxGHIJKLMNxxxxxxxx\");\n+    }\n+\n+    private void fillBuffer(CharBuffer buffer) {\n+        char[] filler = new char[BUFFER_SIZE];\n+        Arrays.fill(filler, 'x');\n+        buffer.put(filler);\n+        buffer.clear();\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/io\/InputStreamReader\/ReadCharBuffer.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"added"},{"patch":"@@ -0,0 +1,149 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4926314\n+ * @summary Test for Reader#read(CharBuffer).\n+ * @run testng ReadCharBuffer\n+ *\/\n+\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+\n+import java.io.IOException;\n+import java.io.Reader;\n+import java.nio.ByteBuffer;\n+import java.nio.CharBuffer;\n+import java.util.Arrays;\n+import java.util.Objects;\n+\n+import static org.testng.Assert.assertEquals;\n+\n+@Test(groups = \"unit\")\n+public class ReadCharBuffer {\n+\n+    private static final int BUFFER_SIZE = 8 + 8192 + 2;\n+\n+    @DataProvider(name = \"buffers\")\n+    public Object[][] createBuffers() {\n+        \/\/ test both on-heap and off-heap buffers as they make use different code paths\n+        return new Object[][]{\n+                new Object[]{CharBuffer.allocate(BUFFER_SIZE)},\n+                new Object[]{ByteBuffer.allocateDirect(BUFFER_SIZE * 2).asCharBuffer()}\n+        };\n+    }\n+\n+    @Test(dataProvider = \"buffers\")\n+    public void read(CharBuffer buffer) throws IOException {\n+        fillBuffer(buffer);\n+\n+        StringBuilder input = new StringBuilder(BUFFER_SIZE - 2 + 1);\n+        input.append(\"ABCDEF\");\n+        for (int i = 0; i < 8192; i++) {\n+            input.append('y');\n+        }\n+        input.append(\"GH\");\n+\n+        try (Reader reader = new UnoptimizedStringReader(input.toString())) {\n+            \/\/ put only between position and limit in the target buffer\n+            int limit = 1 + 6;\n+            buffer.limit(limit);\n+            buffer.position(1);\n+            assertEquals(reader.read(buffer), 6);\n+            assertEquals(buffer.position(), limit);\n+            assertEquals(buffer.limit(), limit);\n+\n+            \/\/ read the full temporary buffer\n+            \/\/ and then accurately reduce the next #read call\n+            limit = 8 + 8192 + 1;\n+            buffer.limit(8 + 8192 + 1);\n+            buffer.position(8);\n+            assertEquals(reader.read(buffer), 8192 + 1);\n+            assertEquals(buffer.position(), limit);\n+            assertEquals(buffer.limit(), limit);\n+\n+            assertEquals(reader.read(), 'H');\n+            assertEquals(reader.read(), -1);\n+        }\n+\n+        buffer.clear();\n+        StringBuilder expected = new StringBuilder(BUFFER_SIZE);\n+        expected.append(\"xABCDEFx\");\n+        for (int i = 0; i < 8192; i++) {\n+            expected.append('y');\n+        }\n+        expected.append(\"Gx\");\n+        assertEquals(buffer.toString(), expected.toString());\n+    }\n+\n+    private void fillBuffer(CharBuffer buffer) {\n+        char[] filler = new char[buffer.remaining()];\n+        Arrays.fill(filler, 'x');\n+        buffer.put(filler);\n+        buffer.clear();\n+    }\n+\n+    \/**\n+     * Unoptimized version of StringReader in case StringReader overrides\n+     * #read(CharBuffer)\n+     *\/\n+    static final class UnoptimizedStringReader extends Reader {\n+\n+        private String str;\n+        private int next = 0;\n+\n+        UnoptimizedStringReader(String s) {\n+            this.str = s;\n+        }\n+\n+        @Override\n+        public int read() throws IOException {\n+            synchronized (lock) {\n+                if (next >= str.length())\n+                    return -1;\n+                return str.charAt(next++);\n+            }\n+        }\n+\n+        @Override\n+        public int read(char cbuf[], int off, int len) throws IOException {\n+            synchronized (lock) {\n+                Objects.checkFromIndexSize(off, len, cbuf.length);\n+                if (next >= str.length())\n+                    return -1;\n+                int n = Math.min(str.length() - next, len);\n+                str.getChars(next, next + n, cbuf, off);\n+                next += n;\n+                return n;\n+            }\n+        }\n+\n+        @Override\n+        public void close() throws IOException {\n+\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/io\/Reader\/ReadCharBuffer.java","additions":149,"deletions":0,"binary":false,"changes":149,"status":"added"}]}