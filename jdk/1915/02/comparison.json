{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import java.nio.CharBuffer;\n@@ -152,0 +153,4 @@\n+    public int read(CharBuffer target) throws IOException {\n+        return sd.read(target);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/io\/InputStreamReader.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -187,6 +187,28 @@\n-        int len = target.remaining();\n-        char[] cbuf = new char[len];\n-        int n = read(cbuf, 0, len);\n-        if (n > 0)\n-            target.put(cbuf, 0, n);\n-        return n;\n+        int nread;\n+        if (target.hasArray()) {\n+            char cbuf[] = target.array();\n+            int off = target.arrayOffset() + target.position();\n+            int len = target.remaining();\n+            nread = this.read(cbuf, off, len);\n+            if (nread > 0) {\n+                target.position(target.position() + nread);\n+            }\n+        } else {\n+            int remaining = target.remaining();\n+            char cbuf[] = new char[Math.min(remaining, TRANSFER_BUFFER_SIZE)];\n+            nread = 0;\n+            synchronized (lock) {\n+                int n = 0;\n+                do {\n+                    \/\/ read to EOF which may read more or less than buffer size\n+                    if ((n = read(cbuf)) > 0) {\n+                        target.put(cbuf, 0, n);\n+                        nread += n;\n+                        remaining -= n;\n+                    }\n+                    \/\/ if the last call to read returned -1 or the number of bytes\n+                    \/\/ requested have been read then break\n+                } while (n >= 0 && remaining > 0);\n+            }\n+        }\n+        return nread;\n","filename":"src\/java.base\/share\/classes\/java\/io\/Reader.java","additions":29,"deletions":7,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -192,0 +192,24 @@\n+    public int read(CharBuffer target) throws IOException {\n+        int len = target.remaining();\n+        synchronized (lock) {\n+            ensureOpen();\n+            if (len == 0)\n+                return 0;\n+\n+            int n = 0;\n+\n+            if (haveLeftoverChar) {\n+                \/\/ Copy the leftover char into the buffer\n+                target.put(leftoverChar);\n+                len--;\n+                haveLeftoverChar = false;\n+                n = 1;\n+                if ((len == 0) || !implReady())\n+                    \/\/ Return now if this is all we can produce w\/o blocking\n+                    return n;\n+            }\n+\n+            return n + implRead(target);\n+        }\n+    }\n+\n@@ -325,3 +349,10 @@\n-        if (cb.position() != 0)\n-        \/\/ Ensure that cb[0] == cbuf[off]\n-        cb = cb.slice();\n+\n+        return implRead(cb);\n+    }\n+\n+    int implRead(CharBuffer cb) throws IOException {\n+\n+        \/\/ In order to handle surrogate pairs, this method requires that\n+        \/\/ the invoker attempt to read at least two characters.  Saving the\n+        \/\/ extra character, if any, at a higher level is easier than trying\n+        \/\/ to deal with it here.\n@@ -330,0 +361,2 @@\n+        int initialPosition = cb.position();\n+        int nread;\n@@ -331,12 +364,6 @@\n-        CoderResult cr = decoder.decode(bb, cb, eof);\n-        if (cr.isUnderflow()) {\n-            if (eof)\n-                break;\n-            if (!cb.hasRemaining())\n-                break;\n-            if ((cb.position() > 0) && !inReady())\n-                break;          \/\/ Block at most once\n-            int n = readBytes();\n-            if (n < 0) {\n-                eof = true;\n-                if ((cb.position() == 0) && (!bb.hasRemaining()))\n+            CoderResult cr = decoder.decode(bb, cb, eof);\n+            nread = cb.position() - initialPosition;\n+            if (cr.isUnderflow()) {\n+                if (eof)\n+                    break;\n+                if (!cb.hasRemaining())\n@@ -344,1 +371,10 @@\n-                decoder.reset();\n+                if ((nread > 0) && !inReady())\n+                    break;          \/\/ Block at most once\n+                int n = readBytes();\n+                if (n < 0) {\n+                    eof = true;\n+                    if ((nread == 0) && (!bb.hasRemaining()))\n+                        break;\n+                    decoder.reset();\n+                }\n+                continue;\n@@ -346,7 +382,5 @@\n-            continue;\n-        }\n-        if (cr.isOverflow()) {\n-            assert cb.position() > 0;\n-            break;\n-        }\n-        cr.throwException();\n+            if (cr.isOverflow()) {\n+                assert nread > 0;\n+                break;\n+            }\n+            cr.throwException();\n@@ -356,2 +390,2 @@\n-        \/\/ ## Need to flush decoder\n-        decoder.reset();\n+            \/\/ ## Need to flush decoder\n+            decoder.reset();\n@@ -360,1 +394,1 @@\n-        if (cb.position() == 0) {\n+        if (nread == 0) {\n@@ -365,1 +399,1 @@\n-        return cb.position();\n+        return nread;\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/cs\/StreamDecoder.java","additions":62,"deletions":28,"binary":false,"changes":90,"status":"modified"}]}