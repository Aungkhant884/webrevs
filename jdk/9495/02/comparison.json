{"files":[{"patch":"@@ -484,83 +484,0 @@\n-oop SymbolPropertyEntry::method_type() const {\n-  return _method_type.resolve();\n-}\n-\n-void SymbolPropertyEntry::set_method_type(oop p) {\n-  _method_type = OopHandle(Universe::vm_global(), p);\n-}\n-\n-void SymbolPropertyEntry::free_entry() {\n-  \/\/ decrement Symbol refcount here because hashtable doesn't.\n-  literal()->decrement_refcount();\n-  \/\/ Free OopHandle\n-  _method_type.release(Universe::vm_global());\n-}\n-\n-void SymbolPropertyEntry::print_entry(outputStream* st) const {\n-  symbol()->print_value_on(st);\n-  st->print(\"\/mode=\" INTX_FORMAT, symbol_mode());\n-  st->print(\" -> \");\n-  bool printed = false;\n-  if (method() != NULL) {\n-    method()->print_value_on(st);\n-    printed = true;\n-  }\n-  if (method_type() != NULL) {\n-    if (printed)  st->print(\" and \");\n-    st->print(INTPTR_FORMAT, p2i((void *)method_type()));\n-    printed = true;\n-  }\n-  st->print_cr(printed ? \"\" : \"(empty)\");\n-}\n-\n-SymbolPropertyTable::SymbolPropertyTable(int table_size)\n-  : Hashtable<Symbol*, mtSymbol>(table_size, sizeof(SymbolPropertyEntry))\n-{\n-}\n-SymbolPropertyTable::SymbolPropertyTable(int table_size, HashtableBucket<mtSymbol>* t,\n-                                         int number_of_entries)\n-  : Hashtable<Symbol*, mtSymbol>(table_size, sizeof(SymbolPropertyEntry), t, number_of_entries)\n-{\n-}\n-\n-\n-SymbolPropertyEntry* SymbolPropertyTable::find_entry(int index, unsigned int hash,\n-                                                     Symbol* sym,\n-                                                     intptr_t sym_mode) {\n-  assert(index == index_for(sym, sym_mode), \"incorrect index?\");\n-  for (SymbolPropertyEntry* p = bucket(index); p != NULL; p = p->next()) {\n-    if (p->hash() == hash && p->symbol() == sym && p->symbol_mode() == sym_mode) {\n-      return p;\n-    }\n-  }\n-  return NULL;\n-}\n-\n-\n-SymbolPropertyEntry* SymbolPropertyTable::add_entry(int index, unsigned int hash,\n-                                                    Symbol* sym, intptr_t sym_mode) {\n-  assert_locked_or_safepoint(SystemDictionary_lock);\n-  assert(index == index_for(sym, sym_mode), \"incorrect index?\");\n-  assert(find_entry(index, hash, sym, sym_mode) == NULL, \"no double entry\");\n-\n-  SymbolPropertyEntry* p = new_entry(hash, sym, sym_mode);\n-  Hashtable<Symbol*, mtSymbol>::add_entry(index, p);\n-  return p;\n-}\n-\n-void SymbolPropertyTable::methods_do(void f(Method*)) {\n-  for (int index = 0; index < table_size(); index++) {\n-    for (SymbolPropertyEntry* p = bucket(index); p != NULL; p = p->next()) {\n-      Method* prop = p->method();\n-      if (prop != NULL) {\n-        f((Method*)prop);\n-      }\n-    }\n-  }\n-}\n-\n-void SymbolPropertyTable::free_entry(SymbolPropertyEntry* entry) {\n-  entry->free_entry();\n-  BasicHashtable<mtSymbol>::free_entry(entry);\n-}\n-\n","filename":"src\/hotspot\/share\/classfile\/dictionary.cpp","additions":0,"deletions":83,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -155,94 +155,0 @@\n-\/\/ Entry in a SymbolPropertyTable, mapping a single Symbol*\n-\/\/ to a managed and an unmanaged pointer.\n-class SymbolPropertyEntry : public HashtableEntry<Symbol*, mtSymbol> {\n-  friend class VMStructs;\n- private:\n-  intptr_t _symbol_mode;  \/\/ secondary key\n-  Method*   _method;\n-  OopHandle _method_type;\n-\n- public:\n-  Symbol* symbol() const            { return literal(); }\n-\n-  intptr_t symbol_mode() const      { return _symbol_mode; }\n-  void set_symbol_mode(intptr_t m)  { _symbol_mode = m; }\n-\n-  Method*        method() const     { return _method; }\n-  void set_method(Method* p)        { _method = p; }\n-\n-  oop      method_type() const;\n-  void set_method_type(oop p);\n-\n-  \/\/ We need to clear the OopHandle because these hashtable entries are not constructed properly.\n-  void clear_method_type() { _method_type = OopHandle(); }\n-\n-  void free_entry();\n-\n-  SymbolPropertyEntry* next() const {\n-    return (SymbolPropertyEntry*)HashtableEntry<Symbol*, mtSymbol>::next();\n-  }\n-\n-  SymbolPropertyEntry** next_addr() {\n-    return (SymbolPropertyEntry**)HashtableEntry<Symbol*, mtSymbol>::next_addr();\n-  }\n-\n-  void print_entry(outputStream* st) const;\n-};\n-\n-\/\/ A system-internal mapping of symbols to pointers, both managed\n-\/\/ and unmanaged.  Used to record the auto-generation of each method\n-\/\/ MethodHandle.invoke(S)T, for all signatures (S)T.\n-class SymbolPropertyTable : public Hashtable<Symbol*, mtSymbol> {\n-  friend class VMStructs;\n-private:\n-  \/\/ The following method is not MT-safe and must be done under lock.\n-  SymbolPropertyEntry** bucket_addr(int i) {\n-    return (SymbolPropertyEntry**) Hashtable<Symbol*, mtSymbol>::bucket_addr(i);\n-  }\n-\n-  void add_entry(int index, SymbolPropertyEntry* new_entry) {\n-    ShouldNotReachHere();\n-  }\n-  void set_entry(int index, SymbolPropertyEntry* new_entry) {\n-    ShouldNotReachHere();\n-  }\n-\n-  SymbolPropertyEntry* new_entry(unsigned int hash, Symbol* symbol, intptr_t symbol_mode) {\n-    SymbolPropertyEntry* entry = (SymbolPropertyEntry*) Hashtable<Symbol*, mtSymbol>::new_entry(hash, symbol);\n-    \/\/ Hashtable with Symbol* literal must increment and decrement refcount.\n-    symbol->increment_refcount();\n-    entry->set_symbol_mode(symbol_mode);\n-    entry->set_method(NULL);\n-    entry->clear_method_type();\n-    return entry;\n-  }\n-\n-public:\n-  SymbolPropertyTable(int table_size);\n-  SymbolPropertyTable(int table_size, HashtableBucket<mtSymbol>* t, int number_of_entries);\n-\n-  void free_entry(SymbolPropertyEntry* entry);\n-\n-  unsigned int compute_hash(Symbol* sym, intptr_t symbol_mode) {\n-    \/\/ Use the regular identity_hash.\n-    return Hashtable<Symbol*, mtSymbol>::compute_hash(sym) ^ symbol_mode;\n-  }\n-\n-  int index_for(Symbol* name, intptr_t symbol_mode) {\n-    return hash_to_index(compute_hash(name, symbol_mode));\n-  }\n-\n-  \/\/ need not be locked; no state change\n-  SymbolPropertyEntry* find_entry(int index, unsigned int hash, Symbol* name, intptr_t name_mode);\n-\n-  \/\/ must be done under SystemDictionary_lock\n-  SymbolPropertyEntry* add_entry(int index, unsigned int hash, Symbol* name, intptr_t name_mode);\n-\n-  void methods_do(void f(Method*));\n-\n-  void verify();\n-\n-  SymbolPropertyEntry* bucket(int i) {\n-    return (SymbolPropertyEntry*) Hashtable<Symbol*, mtSymbol>::bucket(i);\n-  }\n-};\n","filename":"src\/hotspot\/share\/classfile\/dictionary.hpp","additions":0,"deletions":94,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -65,0 +65,2 @@\n+#include \"oops\/oop.hpp\"\n+#include \"oops\/oopHandle.hpp\"\n@@ -90,1 +92,26 @@\n-SymbolPropertyTable*   SystemDictionary::_invoke_method_table = NULL;\n+class InvokeMethodKey : public StackObj {\n+  private:\n+    Symbol* _symbol;\n+    intptr_t _iid;\n+\n+  public:\n+    InvokeMethodKey(Symbol* symbol, intptr_t iid) :\n+        _symbol(symbol),\n+        _iid(iid) {}\n+\n+    static bool key_comparison(InvokeMethodKey const &k1, InvokeMethodKey const &k2){\n+        return k1._symbol == k2._symbol && k1._iid == k2._iid;\n+    }\n+\n+    static unsigned int compute_hash(const InvokeMethodKey &k) {\n+        Symbol* sym = k._symbol;\n+        intptr_t iid = k._iid;\n+        unsigned int hash = (unsigned int) sym -> identity_hash();\n+        return (unsigned int) (hash ^ iid);\n+    }\n+\n+};\n+\n+ResourceHashtable<InvokeMethodKey, Method*, 139, ResourceObj::C_HEAP, mtClass,\n+                  InvokeMethodKey::compute_hash, InvokeMethodKey::key_comparison> _invoke_method_intrinsic_table;\n+ResourceHashtable<Symbol*, OopHandle, 139, ResourceObj::C_HEAP, mtClass> _invoke_method_type_table;\n@@ -1638,2 +1665,5 @@\n-  \/\/ Walk method handle intrinsics\n-  invoke_method_table()->methods_do(f);\n+\n+  auto doit = [&] (InvokeMethodKey key, Method* method) {\n+    f(method);\n+  };\n+  _invoke_method_intrinsic_table.iterate_all(doit);\n@@ -1649,1 +1679,0 @@\n-  _invoke_method_table = new SymbolPropertyTable(_invoke_method_size);\n@@ -1993,0 +2022,2 @@\n+\n+  MutexLocker ml(THREAD, InvokeMethodTable_lock);\n@@ -2000,10 +2031,11 @@\n-  unsigned int hash  = invoke_method_table()->compute_hash(signature, iid_as_int);\n-  int          index = invoke_method_table()->hash_to_index(hash);\n-  SymbolPropertyEntry* spe = invoke_method_table()->find_entry(index, hash, signature, iid_as_int);\n-  methodHandle m;\n-  if (spe == NULL || spe->method() == NULL) {\n-    spe = NULL;\n-    \/\/ Must create lots of stuff here, but outside of the SystemDictionary lock.\n-    m = Method::make_method_handle_intrinsic(iid, signature, CHECK_NULL);\n-    if (!Arguments::is_interpreter_only() || iid == vmIntrinsics::_linkToNative) {\n-      \/\/ Generate a compiled form of the MH intrinsic.\n+  Method** met;\n+  InvokeMethodKey key(signature, iid_as_int);\n+  met = _invoke_method_intrinsic_table.get(key);\n+\n+  if (met != nullptr) {\n+      return *met;\n+  }\n+\n+  methodHandle m = Method::make_method_handle_intrinsic(iid, signature, CHECK_NULL);\n+  if (!Arguments::is_interpreter_only() || iid == vmIntrinsics::_linkToNative) {\n+      \/\/ Generate a compiled form of the MH intrinsic\n@@ -2017,11 +2049,0 @@\n-    }\n-    \/\/ Now grab the lock.  We might have to throw away the new method,\n-    \/\/ if a racing thread has managed to install one at the same time.\n-    {\n-      MutexLocker ml(THREAD, SystemDictionary_lock);\n-      spe = invoke_method_table()->find_entry(index, hash, signature, iid_as_int);\n-      if (spe == NULL)\n-        spe = invoke_method_table()->add_entry(index, hash, signature, iid_as_int);\n-      if (spe->method() == NULL)\n-        spe->set_method(m());\n-    }\n@@ -2029,4 +2050,7 @@\n-\n-  assert(spe != NULL && spe->method() != NULL, \"\");\n-  assert(Arguments::is_interpreter_only() || (spe->method()->has_compiled_code() &&\n-         spe->method()->code()->entry_point() == spe->method()->from_compiled_entry()),\n+  \/\/ Now grab the lock.  We might have to throw away the new method,\n+  \/\/ if a racing thread has managed to install one at the same time.\n+  signature->make_permanent(); \/\/ The signature is never unloaded.\n+  _invoke_method_intrinsic_table.put(key, m());\n+  assert(m() != NULL, \"\");\n+  assert(Arguments::is_interpreter_only() || (m->has_compiled_code() &&\n+         m->code()->entry_point() == m->from_compiled_entry()),\n@@ -2034,1 +2058,1 @@\n-  return spe->method();\n+  return m();\n@@ -2175,7 +2199,10 @@\n-  int null_iid = vmIntrinsics::as_int(vmIntrinsics::_none);  \/\/ distinct from all method handle invoker intrinsics\n-  unsigned int hash  = invoke_method_table()->compute_hash(signature, null_iid);\n-  int          index = invoke_method_table()->hash_to_index(hash);\n-  SymbolPropertyEntry* spe = invoke_method_table()->find_entry(index, hash, signature, null_iid);\n-  if (spe != NULL && spe->method_type() != NULL) {\n-    assert(java_lang_invoke_MethodType::is_instance(spe->method_type()), \"\");\n-    return Handle(THREAD, spe->method_type());\n+  OopHandle* o;\n+  {\n+    MutexLocker ml(THREAD, InvokeMethodTable_lock);\n+    o = _invoke_method_type_table.get(signature);\n+  }\n+\n+  if (o != nullptr) {\n+    oop mt = o->resolve();\n+    assert(java_lang_invoke_MethodType::is_instance(mt), \"\");\n+    return Handle(THREAD, mt);\n@@ -2243,6 +2270,9 @@\n-    MutexLocker ml(THREAD, SystemDictionary_lock);\n-    spe = invoke_method_table()->find_entry(index, hash, signature, null_iid);\n-    if (spe == NULL)\n-      spe = invoke_method_table()->add_entry(index, hash, signature, null_iid);\n-    if (spe->method_type() == NULL) {\n-      spe->set_method_type(method_type());\n+    MutexLocker ml(THREAD, InvokeMethodTable_lock);\n+    bool created = false;\n+    assert(method_type != NULL, \"unexpected null\");\n+    OopHandle* h = _invoke_method_type_table.get(signature);\n+    if (h == nullptr) {\n+      signature->make_permanent(); \/\/ The signature is never unloaded.\n+      OopHandle elem = OopHandle(Universe::vm_global(), method_type());\n+      bool created = _invoke_method_type_table.put(signature, elem);\n+      assert(created, \"better be created\");\n@@ -2251,1 +2281,0 @@\n-\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":73,"deletions":44,"binary":false,"changes":117,"status":"modified"},{"patch":"@@ -117,1 +117,1 @@\n-  if (ProfileInterpreter COMPILER1_PRESENT(|| C1UpdateMethodData) &&\n+  if ((ProfileInterpreter COMPILER1_PRESENT(|| C1UpdateMethodData)) &&\n","filename":"src\/hotspot\/share\/runtime\/java.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+Mutex*   InvokeMethodTable_lock       = NULL;\n@@ -264,1 +265,1 @@\n-\n+  def(InvokeMethodTable_lock       , PaddedMutex  , safepoint);\n@@ -282,1 +283,0 @@\n-  def(AdapterHandlerLibrary_lock   , PaddedMutex  , safepoint);\n@@ -323,1 +323,0 @@\n-\n@@ -358,1 +357,2 @@\n-  defl(Compile_lock                , PaddedMutex ,  MethodCompileQueue_lock);\n+  defl(Compile_lock                , PaddedMutex  , MethodCompileQueue_lock);\n+  defl(AdapterHandlerLibrary_lock  , PaddedMutex  , InvokeMethodTable_lock);\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+extern Mutex*   InvokeMethodTable_lock;\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}