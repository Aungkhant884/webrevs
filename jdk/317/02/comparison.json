{"files":[{"patch":"@@ -213,2 +213,1 @@\n-ProjNode* PhaseIdealLoop::clone_predicate_to_unswitched_loop(ProjNode* predicate_proj, Node* new_entry, Deoptimization::DeoptReason reason,\n-                                               bool is_slow_loop, uint idx_before_clone, Node_List &old_new) {\n+ProjNode* PhaseIdealLoop::clone_predicate_to_unswitched_loop(ProjNode* predicate_proj, Node* new_entry, Deoptimization::DeoptReason reason) {\n@@ -228,1 +227,0 @@\n-  clone_skeleton_predicates_to_unswitched_loop(reason, predicate_proj, new_predicate_proj, is_slow_loop, idx_before_clone, old_new);\n@@ -235,4 +233,2 @@\n-void PhaseIdealLoop::clone_skeleton_predicates_to_unswitched_loop(Deoptimization::DeoptReason reason, ProjNode* old_predicate_proj,\n-                                                    ProjNode* new_predicate_proj, bool is_slow_loop, uint idx_before_clone,\n-                                                    Node_List &old_new) {\n-  assert(old_predicate_proj->is_Proj(), \"must be projection\");\n+void PhaseIdealLoop::clone_skeleton_predicates_to_unswitched_loop(IdealLoopTree* loop, const Node_List& old_new, Deoptimization::DeoptReason reason,\n+                                                                  ProjNode* old_predicate_proj, ProjNode* iffast, ProjNode* ifslow) {\n@@ -258,11 +254,0 @@\n-#ifdef ASSERT\n-    } else {\n-      \/\/ All other If predicates should not have a control input to nodes belonging to the original loop\n-      for (DUIterator i = predicate->outs(); predicate->has_out(i); i++) {\n-        Node* old_node = predicate->out(i);\n-        Node* new_node = old_new[old_node->_idx];\n-        if (!old_node->is_CFG() && new_node != NULL && old_node->_idx >= idx_before_clone) {\n-          assert(false, \"should not be part of the original loop\");\n-        }\n-      }\n-#endif\n@@ -273,0 +258,1 @@\n+  Node_List to_process;\n@@ -282,1 +268,2 @@\n-    ProjNode* cloned_proj = create_new_if_for_predicate(new_predicate_proj, NULL, reason, iff->Opcode(), predicate_proj->is_IfTrue());\n+    ProjNode* fast_proj = create_new_if_for_predicate(iffast, NULL, reason, iff->Opcode(), predicate_proj->is_IfTrue());\n+    ProjNode* slow_proj = create_new_if_for_predicate(ifslow, NULL, reason, iff->Opcode(), predicate_proj->is_IfTrue());\n@@ -285,1 +272,2 @@\n-    _igvn.replace_input_of(cloned_proj->in(0), 1, iff->in(1));\n+    _igvn.replace_input_of(fast_proj->in(0), 1, iff->in(1));\n+    _igvn.replace_input_of(slow_proj->in(0), 1, iff->in(1));\n@@ -287,18 +275,4 @@\n-    if (is_slow_loop) {\n-      for (DUIterator i = predicate->outs(); predicate->has_out(i); i++) {\n-        Node* slow_node = predicate->out(i);\n-        Node* fast_node = old_new[slow_node->_idx];\n-        if (!slow_node->is_CFG() && fast_node != NULL && slow_node->_idx > idx_before_clone) {\n-          \/\/ 'slow_node' is a data node and part of the slow loop. This is a clone of the fast loop node\n-          \/\/ which was temporarily added below in order to verify that 'slow_node' is a clone of 'fast_node'.\n-          \/\/ Update the control input and reset the mapping for 'slow_node' back to NULL.\n-          _igvn.replace_input_of(slow_node, 0, cloned_proj);\n-          old_new.map(slow_node->_idx, NULL);\n-          --i;\n-        }\n-        assert(slow_node->_idx <= idx_before_clone || old_new[slow_node->_idx] == NULL, \"mapping of cloned nodes must be null\");\n-      }\n-    } else {\n-      \/\/ Fast loop\n-      for (DUIterator i = predicate->outs(); predicate->has_out(i); i++) {\n-        Node* fast_node = predicate->out(i);\n+    for (DUIterator i = predicate->outs(); predicate->has_out(i); i++) {\n+      Node* fast_node = predicate->out(i);\n+      if (loop->is_member(get_loop(ctrl_or_self(fast_node)))) {\n+        assert(fast_node->in(0) == predicate, \"only control edge\");\n@@ -306,9 +280,4 @@\n-        if (!fast_node->is_CFG() && slow_node != NULL && slow_node->_idx > idx_before_clone) {\n-          \/\/ 'fast_node' is a data node and part of the fast loop. Add the clone of the fast loop node\n-          \/\/ to the 'old_new' mapping in order to verify later when cloning the predicates for the slow loop\n-          \/\/ that 'slow_node' is a clone of 'fast_node'. Update the control input for 'fast_node'.\n-          _igvn.replace_input_of(fast_node, 0, cloned_proj);\n-          assert(old_new[slow_node->_idx] == NULL, \"mapping must be null for cloned nodes\");\n-          old_new.map(slow_node->_idx, fast_node);\n-          --i;\n-        }\n+        assert(slow_node->in(0) == predicate, \"only control edge\");\n+        _igvn.replace_input_of(fast_node, 0, fast_proj);\n+        to_process.push(slow_node);\n+        --i;\n@@ -317,0 +286,6 @@\n+    \/\/ Have to delay updates to the slow loop so uses of predicate are\n+    \/\/ not modified while we iterate on them.\n+    while (to_process.size() > 0) {\n+      Node* slow_node = to_process.pop();\n+      _igvn.replace_input_of(slow_node, 0, slow_proj);\n+    }\n@@ -322,10 +297,5 @@\n-Node* PhaseIdealLoop::clone_predicates_to_unswitched_loop(Node* old_entry, Node* new_entry, bool clone_limit_check,\n-                                            bool is_slow_loop, uint idx_before_clone, Node_List &old_new) {\n-#ifdef ASSERT\n-  assert(LoopUnswitching, \"sanity - only called when unswitching a loop\");\n-  if (new_entry == NULL || !(new_entry->is_Proj() || new_entry->is_Region() || new_entry->is_SafePoint())) {\n-    if (new_entry != NULL)\n-      new_entry->dump();\n-    assert(false, \"not IfTrue, IfFalse, Region or SafePoint\");\n-  }\n-#endif\n+void PhaseIdealLoop::clone_predicates_to_unswitched_loop(IdealLoopTree* loop, const Node_List& old_new, ProjNode*& iffast, ProjNode*& ifslow) {\n+  LoopNode* head = loop->_head->as_Loop();\n+  bool clone_limit_check = !head->is_CountedLoop();\n+  Node* entry = head->skip_strip_mined()->in(LoopNode::EntryControl);\n+\n@@ -333,1 +303,0 @@\n-  Node* entry = old_entry;\n@@ -352,7 +321,6 @@\n-    new_entry = clone_predicate_to_unswitched_loop(predicate_proj, new_entry, Deoptimization::Reason_predicate, is_slow_loop,\n-                                     idx_before_clone, old_new);\n-    assert(new_entry != NULL && new_entry->is_Proj(), \"IfTrue or IfFalse after clone predicate\");\n-    if (TraceLoopPredicate) {\n-      tty->print(\"Loop Predicate cloned: \");\n-      debug_only( new_entry->in(0)->dump(); );\n-    }\n+    iffast = clone_predicate_to_unswitched_loop(predicate_proj, iffast, Deoptimization::Reason_predicate);\n+    ifslow = clone_predicate_to_unswitched_loop(predicate_proj, ifslow, Deoptimization::Reason_predicate);\n+    clone_skeleton_predicates_to_unswitched_loop(loop, old_new, Deoptimization::Reason_predicate, predicate_proj, iffast, ifslow);\n+\n+    check_created_predicate_for_unswitching(iffast);\n+    check_created_predicate_for_unswitching(ifslow);\n@@ -362,7 +330,6 @@\n-    new_entry = clone_predicate_to_unswitched_loop(profile_predicate_proj, new_entry,Deoptimization::Reason_profile_predicate,\n-                                     is_slow_loop, idx_before_clone, old_new);\n-    assert(new_entry != NULL && new_entry->is_Proj(), \"IfTrue or IfFalse after clone predicate\");\n-    if (TraceLoopPredicate) {\n-      tty->print(\"Loop Predicate cloned: \");\n-      debug_only( new_entry->in(0)->dump(); );\n-    }\n+    iffast = clone_predicate_to_unswitched_loop(profile_predicate_proj, iffast, Deoptimization::Reason_profile_predicate);\n+    ifslow = clone_predicate_to_unswitched_loop(profile_predicate_proj, ifslow, Deoptimization::Reason_profile_predicate);\n+    clone_skeleton_predicates_to_unswitched_loop(loop, old_new, Deoptimization::Reason_profile_predicate, profile_predicate_proj, iffast, ifslow);\n+\n+    check_created_predicate_for_unswitching(iffast);\n+    check_created_predicate_for_unswitching(ifslow);\n@@ -374,7 +341,5 @@\n-    new_entry = clone_predicate_to_unswitched_loop(limit_check_proj, new_entry, Deoptimization::Reason_loop_limit_check,\n-                                     is_slow_loop, idx_before_clone, old_new);\n-    assert(new_entry != NULL && new_entry->is_Proj(), \"IfTrue or IfFalse after clone limit check\");\n-    if (TraceLoopLimitCheck) {\n-      tty->print(\"Loop Limit Check cloned: \");\n-      debug_only( new_entry->in(0)->dump(); )\n-    }\n+    iffast = clone_predicate_to_unswitched_loop(limit_check_proj, iffast, Deoptimization::Reason_loop_limit_check);\n+    ifslow = clone_predicate_to_unswitched_loop(limit_check_proj, ifslow, Deoptimization::Reason_loop_limit_check);\n+\n+    check_created_predicate_for_unswitching(iffast);\n+    check_created_predicate_for_unswitching(ifslow);\n@@ -382,1 +347,0 @@\n-  return new_entry;\n@@ -385,0 +349,11 @@\n+#ifndef PRODUCT\n+void PhaseIdealLoop::check_created_predicate_for_unswitching(const Node* new_entry) const {\n+  assert(new_entry != NULL, \"IfTrue or IfFalse after clone predicate\");\n+  if (TraceLoopPredicate) {\n+    tty->print(\"Loop Predicate cloned: \");\n+    debug_only(new_entry->in(0)->dump(););\n+  }\n+}\n+#endif\n+\n+\n","filename":"src\/hotspot\/share\/opto\/loopPredicate.cpp","additions":55,"deletions":80,"binary":false,"changes":135,"status":"modified"},{"patch":"@@ -278,1 +278,0 @@\n-  uint idx_before_clone = Compile::current()->unique();\n@@ -286,5 +285,4 @@\n-  \/\/ Fast (true) control\n-  Node* iffast_pred = clone_predicates_to_unswitched_loop(entry, iffast, !counted_loop, false, idx_before_clone, old_new);\n-\n-  \/\/ Slow (false) control\n-  Node* ifslow_pred = clone_predicates_to_unswitched_loop(entry, ifslow, !counted_loop, true, idx_before_clone, old_new);\n+  \/\/ Fast (true) and Slow (false) control\n+  ProjNode* iffast_pred = iffast;\n+  ProjNode* ifslow_pred = ifslow;\n+  clone_predicates_to_unswitched_loop(loop, old_new, iffast_pred, ifslow_pred);\n","filename":"src\/hotspot\/share\/opto\/loopUnswitch.cpp","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1434,7 +1434,5 @@\n-  Node* clone_predicates_to_unswitched_loop(Node* old_entry, Node* new_entry, bool clone_limit_check, bool is_slow_loop,\n-                              uint idx_before_clone, Node_List &old_new);\n-  ProjNode* clone_predicate_to_unswitched_loop(ProjNode* predicate_proj, Node* new_entry, Deoptimization::DeoptReason reason,\n-                                 bool is_slow_loop, uint idx_before_clone, Node_List &old_new);\n-  void clone_skeleton_predicates_to_unswitched_loop(Deoptimization::DeoptReason reason, ProjNode* old_predicate_proj,\n-                                      ProjNode* new_predicate_proj, bool is_slow_loop,\n-                                      uint idx_before_clone, Node_List &old_new);\n+  void clone_predicates_to_unswitched_loop(IdealLoopTree* loop, const Node_List& old_new, ProjNode*& iffast, ProjNode*& ifslow);\n+  ProjNode* clone_predicate_to_unswitched_loop(ProjNode* predicate_proj, Node* new_entry, Deoptimization::DeoptReason reason);\n+  void clone_skeleton_predicates_to_unswitched_loop(IdealLoopTree* loop, const Node_List& old_new, Deoptimization::DeoptReason reason,\n+                                      ProjNode* old_predicate_proj, ProjNode* iffast, ProjNode* ifslow);\n+  void check_created_predicate_for_unswitching(const Node* new_entry) const PRODUCT_RETURN;\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":5,"deletions":7,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -257,1 +257,1 @@\n-  return IdealHelper<OverflowLNode>::Ideal(this, phase, can_reshape);\n+   IdealHelper<OverflowLNode>::Ideal(this, phase, can_reshape);\n@@ -267,1 +267,0 @@\n-\n","filename":"src\/hotspot\/share\/opto\/mathexactnode.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"}]}