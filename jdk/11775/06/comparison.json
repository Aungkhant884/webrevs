{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -621,3 +621,6 @@\n-  develop(bool, VerifyIterativeGVN, false,                                  \\\n-          \"Verify Def-Use modifications during sparse Iterative Global \"    \\\n-          \"Value Numbering\")                                                \\\n+  develop(uint, VerifyIterativeGVN, 0,                                      \\\n+          \"Verify Iterative Global Value Numbering\"                         \\\n+          \"=XY, with Y: verify Def-Use modifications during IGVN\"           \\\n+          \"          X: verify that type(n) == n->Value() after IGVN\"       \\\n+          \"X and Y in 0=off; 1=on\")                                         \\\n+          constraint(VerifyIterativeGVNConstraintFunc, AtParse)             \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,1 +53,15 @@\n-  const Type* ft = phase->type(in(1))->filter_speculative(_type);\n+\n+  const Type* in_type = phase->type(in(1));\n+  const Type* ft = in_type->filter_speculative(_type);\n+\n+  \/\/ Check if both _type and in_type had a speculative type, but for the just\n+  \/\/ computed ft the speculative type was dropped.\n+  if (ft->speculative() == nullptr &&\n+      _type->speculative() != nullptr &&\n+      in_type->speculative() != nullptr) {\n+    \/\/ Speculative type may have disagreed between cast and input, and was\n+    \/\/ dropped in filtering. Recompute so that ft can take speculative type\n+    \/\/ of in_type. If we did not do it now, a subsequent ::Value call would\n+    \/\/ do it, and violate idempotence of ::Value.\n+    ft = in_type->filter_speculative(ft);\n+  }\n@@ -61,4 +75,7 @@\n-      const Type* t1 = phase->type(in(1));\n-      if( t1 == Type::TOP )  assert(ft == Type::TOP, \"special case #1\");\n-      const Type* rt = t1->join_speculative(_type);\n-      if (rt->empty())       assert(ft == Type::TOP, \"special case #2\");\n+      if (in_type == Type::TOP) {\n+        assert(ft == Type::TOP, \"special case #1\");\n+      }\n+      const Type* rt = in_type->join_speculative(_type);\n+      if (rt->empty()) {\n+        assert(ft == Type::TOP, \"special case #2\");\n+      }\n@@ -68,4 +85,5 @@\n-    if (phase->type(in(1)) == TypePtr::NULL_PTR &&\n-        _type->isa_ptr() && _type->is_ptr()->_ptr == TypePtr::NotNull)\n-    assert(ft == Type::TOP, \"special case #3\");\n-    break;\n+    if (in_type == TypePtr::NULL_PTR &&\n+        _type->isa_ptr() && _type->is_ptr()->_ptr == TypePtr::NotNull) {\n+      assert(ft == Type::TOP, \"special case #3\");\n+      break;\n+    }\n@@ -213,3 +231,17 @@\n-  \/\/ Try to improve the type of the CastII if we recognize a CmpI\/If\n-  \/\/ pattern.\n-  if (_dependency != RegularDependency) {\n+  \/\/ Try to improve the type of the CastII if we recognize a CmpI\/If pattern.\n+  \/\/\n+  \/\/ in1  in2\n+  \/\/  |    |\n+  \/\/  +--- | --+\n+  \/\/  |    |   |\n+  \/\/ CmpINode  |\n+  \/\/    |      |\n+  \/\/ BoolNode  |\n+  \/\/    |      |\n+  \/\/  IfNode   |\n+  \/\/    |      |\n+  \/\/  IfProj   |\n+  \/\/    |      |\n+  \/\/   CastIINode\n+  \/\/\n+  if (carry_dependency()) {\n@@ -347,1 +379,1 @@\n-  if (can_reshape && !phase->C->post_loop_opts_phase()) {\n+  if (!phase->C->post_loop_opts_phase()) {\n","filename":"src\/hotspot\/share\/opto\/castnode.cpp","additions":46,"deletions":14,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -1274,2 +1274,1 @@\n-  ft = phase->saturate(ft, phase->type_or_null(this), _type);\n-\n+  ft = phase->saturate_and_maybe_push_to_igvn_worklist(this, ft);\n","filename":"src\/hotspot\/share\/opto\/cfgnode.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -759,0 +759,3 @@\n+\n+    gvn.set_type(root(), root()->bottom_type());\n+\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,0 +42,1 @@\n+    init_class_id(Class_Con);\n@@ -56,1 +57,3 @@\n-  ConINode( const TypeInt *t ) : ConNode(t) {}\n+  ConINode(const TypeInt* t) : ConNode(t) {\n+    init_class_id(Class_ConI);\n+  }\n","filename":"src\/hotspot\/share\/opto\/connode.hpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -951,2 +951,1 @@\n-      _gvn.set_type(ex_klass_node, TypeInstKlassPtr::OBJECT);\n-\n+      ex_klass_node = _gvn.transform(ex_klass_node);\n","filename":"src\/hotspot\/share\/opto\/doCall.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2153,0 +2153,4 @@\n+      assert(use->in(idx) == old, \"old is still input of use\");\n+      \/\/ We notify all uses of old, including use, and the indirect uses,\n+      \/\/ that may now be optimized because we have replaced old with phi.\n+      _igvn.add_users_to_worklist(old);\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -740,0 +740,4 @@\n+bool Node::is_not_dead(const Node* n) {\n+  return n == nullptr || !PhaseIterGVN::is_verify_def_use() || !(n->is_dead());\n+}\n+\n@@ -1147,1 +1151,1 @@\n-\/\/ these Ideal calls need to hold.  Running with '+VerifyIterativeGVN' checks\n+\/\/ these Ideal calls need to hold.  Running with '-XX:VerifyIterativeGVN=1' checks\n@@ -1149,1 +1153,1 @@\n-\/\/ hacking an Ideal call, be sure to test with +VerifyIterativeGVN!\n+\/\/ hacking an Ideal call, be sure to test with '-XX:VerifyIterativeGVN=1'\n@@ -1382,0 +1386,1 @@\n+  VectorSet dead_set; \/\/ notify uses only once\n@@ -1389,0 +1394,4 @@\n+    if (!dead_set.test_set(dead->_idx)) {\n+      \/\/ If dead has any live uses, those are now still attached. Notify them before we lose them.\n+      igvn->add_users_to_worklist(dead);\n+    }\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":12,"deletions":3,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -72,0 +72,1 @@\n+class ConINode;\n@@ -414,1 +415,1 @@\n-#define is_not_dead(n) ((n) == NULL || !VerifyIterativeGVN || !((n)->is_dead()))\n+  static bool is_not_dead(const Node* n);\n@@ -714,0 +715,3 @@\n+      DEFINE_CLASS_ID(Con, Type, 8)\n+          DEFINE_CLASS_ID(ConI, Con, 0)\n+\n@@ -865,0 +869,1 @@\n+  DEFINE_CLASS_QUERY(ConI)\n@@ -1040,1 +1045,1 @@\n-  \/\/ +VerifyIterativeGVN!\n+  \/\/ -XX:VerifyIterativeGVN=1\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -547,1 +547,0 @@\n-  gvn().set_type(root(), root()->bottom_type());\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1021,1 +1021,1 @@\n-  if (VerifyIterativeGVN) {\n+  if (is_verify_def_use()) {\n@@ -1132,1 +1132,1 @@\n-  if (VerifyIterativeGVN && PrintOpto) {\n+  if (is_verify_def_use() && PrintOpto) {\n@@ -1150,0 +1150,2 @@\n+\n+  verify_optimize();\n@@ -1213,0 +1215,91 @@\n+#ifdef ASSERT\n+void PhaseIterGVN::verify_optimize() {\n+  if (is_verify_Value()) {\n+    ResourceMark rm;\n+    Unique_Node_List worklist;\n+    bool failure = false;\n+    \/\/ BFS all nodes, starting at root\n+    worklist.push(C->root());\n+    for (uint j = 0; j < worklist.size(); ++j) {\n+      Node* n = worklist.at(j);\n+      failure |= verify_node_value(n);\n+      \/\/ traverse all inputs and outputs\n+      for (uint i = 0; i < n->req(); i++) {\n+        if (n->in(i) != nullptr) {\n+          worklist.push(n->in(i));\n+        }\n+      }\n+      for (DUIterator_Fast imax, i = n->fast_outs(imax); i < imax; i++) {\n+        worklist.push(n->fast_out(i));\n+      }\n+    }\n+    \/\/ If we get this assert, check why the reported nodes were not processed again in IGVN.\n+    \/\/ We should either make sure that these nodes are properly added back to the IGVN worklist\n+    \/\/ in PhaseIterGVN::add_users_to_worklist to update them again or add an exception\n+    \/\/ in the verification code above if that is not possible for some reason (like Load nodes).\n+    assert(!failure, \"Missed optimization opportunity in PhaseIterGVN\");\n+  }\n+}\n+\n+\/\/ Check that type(n) == n->Value(), return true if we have a failure.\n+\/\/ We have a list of exceptions, see detailed comments in code.\n+\/\/ (1) Integer \"widen\" changes, but the range is the same.\n+\/\/ (2) LoadNode performs deep traversals. Load is not notified for changes far away.\n+\/\/ (3) CmpPNode performs deep traversals if it compares oopptr. CmpP is not notified for changes far away.\n+bool PhaseIterGVN::verify_node_value(Node* n) {\n+  \/\/ If we assert inside type(n), because the type is still a nullptr, then maybe\n+  \/\/ the node never went through gvn.transform, which would be a bug.\n+  const Type* told = type(n);\n+  const Type* tnew = n->Value(this);\n+  if (told == tnew) {\n+    return false;\n+  }\n+  \/\/ Exception (1)\n+  \/\/ Integer \"widen\" changes, but range is the same.\n+  if (told->isa_integer(tnew->basic_type()) != nullptr) { \/\/ both either int or long\n+    const TypeInteger* t0 = told->is_integer(tnew->basic_type());\n+    const TypeInteger* t1 = tnew->is_integer(tnew->basic_type());\n+    if (t0->lo_as_long() == t1->lo_as_long() &&\n+        t0->hi_as_long() == t1->hi_as_long()) {\n+      return false; \/\/ ignore integer widen\n+    }\n+  }\n+  \/\/ Exception (2)\n+  \/\/ LoadNode performs deep traversals. Load is not notified for changes far away.\n+  if (n->is_Load() && !told->singleton()) {\n+    \/\/ MemNode::can_see_stored_value looks up through many memory nodes,\n+    \/\/ which means we would need to notify modifications from far up in\n+    \/\/ the inputs all the way down to the LoadNode. We don't do that.\n+    return false;\n+  }\n+  \/\/ Exception (3)\n+  \/\/ CmpPNode performs deep traversals if it compares oopptr. CmpP is not notified for changes far away.\n+  if (n->Opcode() == Op_CmpP && type(n->in(1))->isa_oopptr() && type(n->in(2))->isa_oopptr()) {\n+    \/\/ SubNode::Value\n+    \/\/ CmpPNode::sub\n+    \/\/ MemNode::detect_ptr_independence\n+    \/\/ MemNode::all_controls_dominate\n+    \/\/ We find all controls of a pointer load, and see if they dominate the control of\n+    \/\/ an allocation. If they all dominate, we know the allocation is after (independent)\n+    \/\/ of the pointer load, and we can say the pointers are different. For this we call\n+    \/\/ n->dominates(sub, nlist) to check if controls n of the pointer load dominate the\n+    \/\/ control sub of the allocation. The problems is that sometimes dominates answers\n+    \/\/ false conservatively, and later it can determine that it is indeed true. Loops with\n+    \/\/ Region heads can lead to giving up, whereas LoopNodes can be skipped easier, and\n+    \/\/ so the traversal becomes more powerful. This is difficult to remidy, we would have\n+    \/\/ to notify the CmpP of CFG updates. Luckily, we recompute CmpP::Value during CCP\n+    \/\/ after loop-opts, so that should take care of many of these cases.\n+    return false;\n+  }\n+  tty->cr();\n+  tty->print_cr(\"Missed Value optimization:\");\n+  n->dump_bfs(1, 0, \"\");\n+  tty->print_cr(\"Current type:\");\n+  told->dump_on(tty);\n+  tty->cr();\n+  tty->print_cr(\"Optimized type:\");\n+  tnew->dump_on(tty);\n+  tty->cr();\n+  return true;\n+}\n+#endif\n@@ -1247,1 +1340,2 @@\n-  if (VerifyIterativeGVN) {\n+#ifdef ASSERT\n+  if (is_verify_def_use()) {\n@@ -1250,0 +1344,1 @@\n+#endif\n@@ -1497,1 +1592,1 @@\n-  if( VerifyIterativeGVN ) {\n+  if (is_verify_def_use()) {\n@@ -1578,2 +1673,2 @@\n-      if (use_op == Op_CmpI) {\n-        Node* phi = countedloop_phi_from_cmp((CmpINode*)use, n);\n+      if (use_op == Op_CmpI || use_op == Op_CmpL) {\n+        Node* phi = countedloop_phi_from_cmp(use->as_Cmp(), n);\n@@ -1581,5 +1676,3 @@\n-          \/\/ If an opaque node feeds into the limit condition of a\n-          \/\/ CountedLoop, we need to process the Phi node for the\n-          \/\/ induction variable when the opaque node is removed:\n-          \/\/ the range of values taken by the Phi is now known and\n-          \/\/ so its type is also known.\n+          \/\/ Input to the cmp of a loop exit check has changed, thus\n+          \/\/ the loop limit may have changed, which can then change the\n+          \/\/ range values of the trip-count Phi.\n@@ -1588,12 +1681,61 @@\n-        Node* in1 = use->in(1);\n-        for (uint i = 0; i < in1->outcnt(); i++) {\n-          if (in1->raw_out(i)->Opcode() == Op_CastII) {\n-            Node* castii = in1->raw_out(i);\n-            if (castii->in(0) != NULL && castii->in(0)->in(0) != NULL && castii->in(0)->in(0)->is_If()) {\n-              Node* ifnode = castii->in(0)->in(0);\n-              if (ifnode->in(1) != NULL && ifnode->in(1)->is_Bool() && ifnode->in(1)->in(1) == use) {\n-                \/\/ Reprocess a CastII node that may depend on an\n-                \/\/ opaque node value when the opaque node is\n-                \/\/ removed. In case it carries a dependency we can do\n-                \/\/ a better job of computing its type.\n-                _worklist.push(castii);\n+      }\n+      if (use_op == Op_CmpI) {\n+        Node* cmp = use;\n+        Node* in1 = cmp->in(1);\n+        Node* in2 = cmp->in(2);\n+        \/\/ Notify CmpI \/ If pattern from CastIINode::Value (left pattern).\n+        \/\/ Must also notify if in1 is modified and possibly turns into X (right pattern).\n+        \/\/\n+        \/\/ in1  in2                   in1  in2\n+        \/\/  |    |                     |    |\n+        \/\/  +--- | --+                 |    |\n+        \/\/  |    |   |                 |    |\n+        \/\/ CmpINode  |                CmpINode\n+        \/\/    |      |                   |\n+        \/\/ BoolNode  |                BoolNode\n+        \/\/    |      |        OR         |\n+        \/\/  IfNode   |                 IfNode\n+        \/\/    |      |                   |\n+        \/\/  IfProj   |                 IfProj   X\n+        \/\/    |      |                   |      |\n+        \/\/   CastIINode                 CastIINode\n+        \/\/\n+        if (in1 != in2) { \/\/ if they are equal, the CmpI can fold them away\n+          if (in1 == n) {\n+            \/\/ in1 modified -> could turn into X -> do traversal based on right pattern.\n+            for (DUIterator_Fast i2max, i2 = cmp->fast_outs(i2max); i2 < i2max; i2++) {\n+              Node* bol = cmp->fast_out(i2); \/\/ For each Bool\n+              if (bol->is_Bool()) {\n+                for (DUIterator_Fast i3max, i3 = bol->fast_outs(i3max); i3 < i3max; i3++) {\n+                  Node* iff = bol->fast_out(i3); \/\/ For each If\n+                  if (iff->is_If()) {\n+                    for (DUIterator_Fast i4max, i4 = iff->fast_outs(i4max); i4 < i4max; i4++) {\n+                      Node* if_proj = iff->fast_out(i4); \/\/ For each IfProj\n+                      assert(if_proj->is_IfProj(), \"If only has IfTrue and IfFalse as outputs\");\n+                      for (DUIterator_Fast i5max, i5 = if_proj->fast_outs(i5max); i5 < i5max; i5++) {\n+                        Node* castii = if_proj->fast_out(i5); \/\/ For each CastII\n+                        if (castii->is_CastII() &&\n+                            castii->as_CastII()->carry_dependency()) {\n+                          _worklist.push(castii);\n+                        }\n+                      }\n+                    }\n+                  }\n+                }\n+              }\n+            }\n+          } else {\n+            \/\/ Only in2 modified -> can assume X == in2 (left pattern).\n+            assert(n == in2, \"only in2 modified\");\n+            \/\/ Find all CastII with input in1.\n+            for (DUIterator_Fast jmax, j = in1->fast_outs(jmax); j < jmax; j++) {\n+              Node* castii = in1->fast_out(j);\n+              if (castii->is_CastII() && castii->as_CastII()->carry_dependency()) {\n+                \/\/ Find If.\n+                if (castii->in(0) != nullptr && castii->in(0)->in(0) != nullptr && castii->in(0)->in(0)->is_If()) {\n+                  Node* ifnode = castii->in(0)->in(0);\n+                  \/\/ Check that if connects to the cmp\n+                  if (ifnode->in(1) != nullptr && ifnode->in(1)->is_Bool() && ifnode->in(1)->in(1) == cmp) {\n+                    _worklist.push(castii);\n+                  }\n+                }\n@@ -1607,1 +1749,1 @@\n-    \/\/ If changed Cast input, check Phi users for simple cycles\n+    \/\/ If changed Cast input, notify down for Phi and Sub - both do \"uncast\"\n@@ -1611,1 +1753,2 @@\n-        if (u->is_Phi())\n+        if (u->is_Phi() || u->is_Sub()) {\n+          \/\/ Phi (.., CastII, ..) or Sub(Cast(x), x)\n@@ -1613,0 +1756,18 @@\n+        } else if (u->is_ConstraintCast()) {\n+          \/\/ Follow cast-chains down to Sub: Sub( CastII(CastII(x)), x)\n+          \/\/ This case is quite rare. Let's BFS-traverse casts, to find Subs:\n+          ResourceMark rm;\n+          Unique_Node_List casts;\n+          casts.push(u); \/\/ start traversal\n+          for (uint j = 0; j < casts.size(); ++j) {\n+            Node* cast = casts.at(j); \/\/ for every cast\n+            for (DUIterator_Fast kmax, k = cast->fast_outs(kmax); k < kmax; k++) {\n+              Node* cast_use = cast->fast_out(k);\n+              if (cast_use->is_ConstraintCast()) {\n+                casts.push(cast_use); \/\/ traverse this cast also\n+              } else if (cast_use->is_Sub()) {\n+                _worklist.push(cast_use); \/\/ found Sub\n+              }\n+            }\n+          }\n+        }\n@@ -1623,0 +1784,9 @@\n+    \/\/ If changed LShift inputs, check And users for shift and mask (And) operation\n+    if (use_op == Op_LShiftI || use_op == Op_LShiftL) {\n+      for (DUIterator_Fast i2max, i2 = use->fast_outs(i2max); i2 < i2max; i2++) {\n+        Node* u = use->fast_out(i2);\n+        if (u->Opcode() == Op_AndI || u->Opcode() == Op_AndL) {\n+          _worklist.push(u);\n+        }\n+      }\n+    }\n@@ -1816,1 +1986,1 @@\n-\/\/ We have a list of exceptions, see comments in code.\n+\/\/ We have a list of exceptions, see comments in verify_node_value.\n@@ -1821,30 +1991,1 @@\n-    const Type* told = type(n);\n-    const Type* tnew = n->Value(this);\n-    if (told != tnew) {\n-      \/\/ Check special cases that are ok\n-      if (told->isa_integer(tnew->basic_type()) != nullptr) { \/\/ both either int or long\n-        const TypeInteger* t0 = told->is_integer(tnew->basic_type());\n-        const TypeInteger* t1 = tnew->is_integer(tnew->basic_type());\n-        if (t0->lo_as_long() == t1->lo_as_long() &&\n-            t0->hi_as_long() == t1->hi_as_long()) {\n-          continue; \/\/ ignore integer widen\n-        }\n-      }\n-      if (n->is_Load() && !told->singleton()) {\n-        \/\/ MemNode::can_see_stored_value looks up through many memory nodes,\n-        \/\/ which means we would need to notify modifications from far up in\n-        \/\/ the inputs all the way down to the LoadNode. We don't do that.\n-        continue;\n-      }\n-      verify_type(n, tnew, told);\n-      tty->cr();\n-      tty->print_cr(\"Missed optimization (PhaseCCP):\");\n-      n->dump_bfs(1, 0, \"\");\n-      tty->print_cr(\"Current type:\");\n-      told->dump_on(tty);\n-      tty->cr();\n-      tty->print_cr(\"Optimized type:\");\n-      tnew->dump_on(tty);\n-      tty->cr();\n-      failure = true;\n-    }\n+    failure |= verify_node_value(n);\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":197,"deletions":56,"binary":false,"changes":253,"status":"modified"},{"patch":"@@ -338,0 +338,3 @@\n+  virtual const Type* saturate_and_maybe_push_to_igvn_worklist(const TypeNode* n, const Type* new_type) {\n+    return saturate(new_type, type_or_null(n), n->type());\n+  }\n@@ -479,0 +482,4 @@\n+#ifdef ASSERT\n+  void verify_optimize();\n+  bool verify_node_value(Node* n);\n+#endif\n@@ -567,0 +574,8 @@\n+  static bool is_verify_def_use() {\n+    \/\/ '-XX:VerifyIterativeGVN=1'\n+    return (VerifyIterativeGVN % 10) == 1;\n+  }\n+  static bool is_verify_Value() {\n+    \/\/ '-XX:VerifyIterativeGVN=10'\n+    return ((VerifyIterativeGVN % 100) \/ 10) == 1;\n+  }\n@@ -568,1 +583,1 @@\n-  \/\/ Sub-quadratic implementation of VerifyIterativeGVN.\n+  \/\/ Sub-quadratic implementation of '-XX:VerifyIterativeGVN=1' (Use-Def verification).\n@@ -622,0 +637,8 @@\n+  virtual const Type* saturate_and_maybe_push_to_igvn_worklist(const TypeNode* n, const Type* new_type) {\n+    const Type* t = saturate(new_type, type_or_null(n), n->type());\n+    if (t != new_type) {\n+      \/\/ Type was widened in CCP, but IGVN may be able to make it narrower.\n+      _worklist.push((Node*)n);\n+    }\n+    return t;\n+  }\n","filename":"src\/hotspot\/share\/opto\/phaseX.hpp","additions":24,"deletions":1,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -1194,1 +1194,1 @@\n-  this->set_req(1,ldk2);\n+  this->set_req_X(1, ldk2, phase);\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -3041,0 +3041,1 @@\n+          _igvn.register_new_node_with_optimizer(cnt);\n@@ -3173,1 +3174,2 @@\n-    Node* ex = ExtractNode::make(def, def_pos, velt_basic_type(def));\n+    ConINode* def_pos_con = _igvn.intcon(def_pos)->as_ConI();\n+    Node* ex = ExtractNode::make(def, def_pos_con, velt_basic_type(def));\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2732,1 +2732,2 @@\n-  Node* operation = gvn().transform(ExtractNode::make(opd, idx->get_con(), elem_bt));\n+  ConINode* idx_con = gvn().intcon(idx->get_con())->as_ConI();\n+  Node* operation = gvn().transform(ExtractNode::make(opd, idx_con, elem_bt));\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -1088,3 +1088,2 @@\n-Node* ExtractNode::make(Node* v, uint position, BasicType bt) {\n-  assert((int)position < Matcher::max_vector_size(bt), \"pos in range\");\n-  ConINode* pos = ConINode::make((int)position);\n+Node* ExtractNode::make(Node* v, ConINode* pos, BasicType bt) {\n+  assert(pos->get_int() < Matcher::max_vector_size(bt), \"pos in range\");\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -1279,1 +1279,1 @@\n-  static Node* make(Node* v, uint position, BasicType bt);\n+  static Node* make(Node* v, ConINode* pos, BasicType bt);\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -294,1 +294,2 @@\n-JVMFlag::Error TypeProfileLevelConstraintFunc(uintx value, bool verbose) {\n+JVMFlag::Error TypeProfileLevelConstraintFunc(uint value, bool verbose) {\n+  uint original_value = value;\n@@ -298,1 +299,1 @@\n-                          \"Invalid value (\" UINTX_FORMAT \") \"\n+                          \"Invalid value (\" UINT32_FORMAT \") \"\n@@ -304,0 +305,8 @@\n+  if (value != 0) {\n+    JVMFlag::printError(verbose,\n+                        \"Invalid value (\" UINT32_FORMAT \") \"\n+                        \"for TypeProfileLevel: maximal 3 digits\\n\", original_value);\n+    return JVMFlag::VIOLATES_CONSTRAINT;\n+  }\n+  return JVMFlag::SUCCESS;\n+}\n@@ -305,0 +314,17 @@\n+JVMFlag::Error VerifyIterativeGVNConstraintFunc(uint value, bool verbose) {\n+  uint original_value = value;\n+  for (int i = 0; i < 2; i++) {\n+    if (value % 10 > 1) {\n+      JVMFlag::printError(verbose,\n+                          \"Invalid value (\" UINT32_FORMAT \") \"\n+                          \"in VerifyIterativeGVN at position %d\\n\", value, i);\n+      return JVMFlag::VIOLATES_CONSTRAINT;\n+    }\n+    value = value \/ 10;\n+  }\n+  if (value != 0) {\n+    JVMFlag::printError(verbose,\n+                        \"Invalid value (\" UINT32_FORMAT \") \"\n+                        \"for VerifyIterativeGVN: maximal 2 digits\\n\", original_value);\n+    return JVMFlag::VIOLATES_CONSTRAINT;\n+  }\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlagConstraintsCompiler.cpp","additions":29,"deletions":3,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,1 +50,2 @@\n-  f(uintx, TypeProfileLevelConstraintFunc)              \\\n+  f(uint,  TypeProfileLevelConstraintFunc)              \\\n+  f(uint,  VerifyIterativeGVNConstraintFunc)            \\\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlagConstraintsCompiler.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1112,1 +1112,1 @@\n-  product_pd(uintx, TypeProfileLevel,                                       \\\n+  product_pd(uint, TypeProfileLevel,                                        \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -127,1 +127,1 @@\n-            if (WHITE_BOX.getUintxVMFlag(\"TypeProfileLevel\") == 20) {\n+            if (WHITE_BOX.getUintVMFlag(\"TypeProfileLevel\") == 20) {\n","filename":"test\/hotspot\/jtreg\/compiler\/arraycopy\/TestArrayCopyNoInitDeopt.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @summary Run with -Xcomp to test -XX:+VerifyIterativeGVN in debug builds.\n+ * @summary Run with -Xcomp to test -XX:VerifyIterativeGVN=11 in debug builds.\n@@ -30,1 +30,1 @@\n- * @run main\/othervm\/timeout=300 -Xbatch -Xcomp -XX:+VerifyIterativeGVN compiler.c2.TestVerifyIterativeGVN\n+ * @run main\/othervm\/timeout=300 -Xbatch -Xcomp -XX:VerifyIterativeGVN=11 compiler.c2.TestVerifyIterativeGVN\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestVerifyIterativeGVN.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @summary Test which causes a stack overflow segmentation fault with -XX:+VerifyIterativeGVN due to a too deep recursion in Node::verify_recur().\n+ * @summary Test which causes a stack overflow segmentation fault with -XX:VerifyIterativeGVN=1 due to a too deep recursion in Node::verify_recur().\n@@ -30,1 +30,1 @@\n- * @run main\/othervm\/timeout=600 -Xcomp -XX:+VerifyIterativeGVN -XX:CompileCommand=compileonly,compiler.loopopts.TestDeepGraphVerifyIterativeGVN::*\n+ * @run main\/othervm\/timeout=600 -Xcomp -XX:VerifyIterativeGVN=1 -XX:CompileCommand=compileonly,compiler.loopopts.TestDeepGraphVerifyIterativeGVN::*\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TestDeepGraphVerifyIterativeGVN.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @summary Test which triggers assertion in PhaseIdealLoop::try_move_store_after_loop with -XX:+VerifyIterativeGVN due to dead hook.\n+ * @summary Test which triggers assertion in PhaseIdealLoop::try_move_store_after_loop with -XX:VerifyIterativeGVN=1 due to dead hook.\n@@ -30,1 +30,1 @@\n- * @run main\/othervm -Xbatch -XX:+VerifyIterativeGVN compiler.loopopts.TestMoveStoreAfterLoopVerifyIterativeGVN\n+ * @run main\/othervm -Xbatch -XX:VerifyIterativeGVN=1 compiler.loopopts.TestMoveStoreAfterLoopVerifyIterativeGVN\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TestMoveStoreAfterLoopVerifyIterativeGVN.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -105,1 +105,1 @@\n-        if (WHITE_BOX.getUintxVMFlag(\"TypeProfileLevel\") == 20) {\n+        if (WHITE_BOX.getUintVMFlag(\"TypeProfileLevel\") == 20) {\n@@ -108,1 +108,1 @@\n-        if (WHITE_BOX.getUintxVMFlag(\"TypeProfileLevel\") == 200) {\n+        if (WHITE_BOX.getUintVMFlag(\"TypeProfileLevel\") == 200) {\n","filename":"test\/hotspot\/jtreg\/compiler\/profiling\/TestTypeProfiling.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"}]}