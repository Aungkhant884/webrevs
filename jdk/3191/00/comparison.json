{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -443,4 +443,0 @@\n-  thread->set_suspend_equivalent();\n-  \/\/ cleared by handle_special_suspend_equivalent_condition() or\n-  \/\/ java_suspend_self() via check_and_wait_while_suspended()\n-\n@@ -462,3 +458,0 @@\n-  \/\/ were we externally suspended while we were waiting?\n-  thread->check_and_wait_while_suspended();\n-\n@@ -475,4 +468,0 @@\n-  thread->set_suspend_equivalent();\n-  \/\/ cleared by handle_special_suspend_equivalent_condition() or\n-  \/\/ java_suspend_self() via check_and_wait_while_suspended()\n-\n@@ -481,3 +470,0 @@\n-  \/\/ were we externally suspended while we were waiting?\n-  thread->check_and_wait_while_suspended();\n-\n@@ -514,4 +500,0 @@\n-  thread->set_suspend_equivalent();\n-  \/\/ cleared by handle_special_suspend_equivalent_condition() or\n-  \/\/ java_suspend_self() via check_and_wait_while_suspended()\n-\n@@ -520,3 +502,0 @@\n-  \/\/ were we externally suspended while we were waiting?\n-  thread->check_and_wait_while_suspended();\n-\n","filename":"src\/hotspot\/os\/aix\/attachListener_aix.cpp","additions":1,"deletions":22,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -412,4 +412,0 @@\n-  thread->set_suspend_equivalent();\n-  \/\/ cleared by handle_special_suspend_equivalent_condition() or\n-  \/\/ java_suspend_self() via check_and_wait_while_suspended()\n-\n@@ -430,3 +426,0 @@\n-  \/\/ were we externally suspended while we were waiting?\n-  thread->check_and_wait_while_suspended();\n-\n@@ -443,4 +436,0 @@\n-  thread->set_suspend_equivalent();\n-  \/\/ cleared by handle_special_suspend_equivalent_condition() or\n-  \/\/ java_suspend_self() via check_and_wait_while_suspended()\n-\n@@ -449,3 +438,0 @@\n-  \/\/ were we externally suspended while we were waiting?\n-  thread->check_and_wait_while_suspended();\n-\n@@ -482,4 +468,0 @@\n-  thread->set_suspend_equivalent();\n-  \/\/ cleared by handle_special_suspend_equivalent_condition() or\n-  \/\/ java_suspend_self() via check_and_wait_while_suspended()\n-\n@@ -488,3 +470,0 @@\n-  \/\/ were we externally suspended while we were waiting?\n-  thread->check_and_wait_while_suspended();\n-\n","filename":"src\/hotspot\/os\/bsd\/attachListener_bsd.cpp","additions":1,"deletions":22,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -412,4 +412,0 @@\n-  thread->set_suspend_equivalent();\n-  \/\/ cleared by handle_special_suspend_equivalent_condition() or\n-  \/\/ java_suspend_self() via check_and_wait_while_suspended()\n-\n@@ -430,3 +426,0 @@\n-  \/\/ were we externally suspended while we were waiting?\n-  thread->check_and_wait_while_suspended();\n-\n@@ -443,4 +436,0 @@\n-  thread->set_suspend_equivalent();\n-  \/\/ cleared by handle_special_suspend_equivalent_condition() or\n-  \/\/ java_suspend_self() via check_and_wait_while_suspended()\n-\n@@ -449,3 +438,0 @@\n-  \/\/ were we externally suspended while we were waiting?\n-  thread->check_and_wait_while_suspended();\n-\n@@ -482,4 +468,0 @@\n-  thread->set_suspend_equivalent();\n-  \/\/ cleared by handle_special_suspend_equivalent_condition() or\n-  \/\/ java_suspend_self() via check_and_wait_while_suspended()\n-\n@@ -488,3 +470,0 @@\n-  \/\/ were we externally suspended while we were waiting?\n-  thread->check_and_wait_while_suspended();\n-\n","filename":"src\/hotspot\/os\/linux\/attachListener_linux.cpp","additions":1,"deletions":22,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -1586,2 +1586,0 @@\n-  jt->set_suspend_equivalent();\n-  \/\/ cleared by handle_special_suspend_equivalent_condition() or java_suspend_self()\n@@ -1610,5 +1608,0 @@\n-\n-  \/\/ If externally suspended while waiting, re-suspend\n-  if (jt->handle_special_suspend_equivalent_condition()) {\n-    jt->java_suspend_self();\n-  }\n","filename":"src\/hotspot\/os\/posix\/os_posix.cpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,1 @@\n+#include \"runtime\/semaphore.inline.hpp\"\n@@ -372,21 +373,1 @@\n-    JavaThread *thread = JavaThread::current();\n-    ThreadBlockInVM tbivm(thread);\n-\n-    bool threadIsSuspended;\n-    do {\n-      thread->set_suspend_equivalent();\n-      \/\/ cleared by handle_special_suspend_equivalent_condition() or java_suspend_self()\n-      sig_semaphore->wait();\n-\n-      \/\/ were we externally suspended while we were waiting?\n-      threadIsSuspended = thread->handle_special_suspend_equivalent_condition();\n-      if (threadIsSuspended) {\n-        \/\/ The semaphore has been incremented, but while we were waiting\n-        \/\/ another thread suspended us. We don't want to continue running\n-        \/\/ while suspended because that would surprise the thread that\n-        \/\/ suspended us.\n-        sig_semaphore->signal();\n-\n-        thread->java_suspend_self();\n-      }\n-    } while (threadIsSuspended);\n+    sig_semaphore->wait_with_safepoint_check(JavaThread::current());\n@@ -1561,4 +1542,0 @@\n-\/\/  Note that the SR_lock plays no role in this suspend\/resume protocol,\n-\/\/  but is checked for NULL in SR_handler as a thread termination indicator.\n-\/\/  The SR_lock is, however, used by JavaThread::java_suspend()\/java_resume() APIs.\n-\/\/\n@@ -1609,1 +1586,1 @@\n-  \/\/ has not already terminated (via SR_lock()) - else the following assertion\n+  \/\/ has not already terminated - else the following assertion\n@@ -1613,1 +1590,1 @@\n-  if (thread->SR_lock() == NULL) {\n+  if (thread->is_Java_thread() && thread->as_Java_thread()->is_terminated()) {\n","filename":"src\/hotspot\/os\/posix\/signals_posix.cpp","additions":5,"deletions":28,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -313,4 +313,0 @@\n-  thread->set_suspend_equivalent();\n-  \/\/ cleared by handle_special_suspend_equivalent_condition() or\n-  \/\/ java_suspend_self() via check_and_wait_while_suspended()\n-\n@@ -354,3 +350,0 @@\n-\n-  \/\/ were we externally suspended while we were waiting?\n-  thread->check_and_wait_while_suspended();\n@@ -366,4 +359,0 @@\n-  thread->set_suspend_equivalent();\n-  \/\/ cleared by handle_special_suspend_equivalent_condition() or\n-  \/\/ java_suspend_self() via check_and_wait_while_suspended()\n-\n@@ -372,3 +361,0 @@\n-  \/\/ were we externally suspended while we were waiting?\n-  thread->check_and_wait_while_suspended();\n-\n","filename":"src\/hotspot\/os\/windows\/attachListener_windows.cpp","additions":1,"deletions":15,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2210,22 +2210,1 @@\n-    JavaThread *thread = JavaThread::current();\n-\n-    ThreadBlockInVM tbivm(thread);\n-\n-    bool threadIsSuspended;\n-    do {\n-      thread->set_suspend_equivalent();\n-      \/\/ cleared by handle_special_suspend_equivalent_condition() or java_suspend_self()\n-      sig_sem->wait();\n-\n-      \/\/ were we externally suspended while we were waiting?\n-      threadIsSuspended = thread->handle_special_suspend_equivalent_condition();\n-      if (threadIsSuspended) {\n-        \/\/ The semaphore has been incremented, but while we were waiting\n-        \/\/ another thread suspended us. We don't want to continue running\n-        \/\/ while suspended because that would surprise the thread that\n-        \/\/ suspended us.\n-        sig_sem->signal();\n-\n-        thread->java_suspend_self();\n-      }\n-    } while (threadIsSuspended);\n+    sig_sem->wait_with_safepoint_check(JavaThread::current());\n@@ -5478,1 +5457,0 @@\n-    thread->set_suspend_equivalent();\n@@ -5482,5 +5460,0 @@\n-\n-    \/\/ If externally suspended while waiting, re-suspend\n-    if (thread->handle_special_suspend_equivalent_condition()) {\n-      thread->java_suspend_self();\n-    }\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":1,"deletions":28,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -176,0 +176,1 @@\n+  LOG_TAG(suspend) \\\n","filename":"src\/hotspot\/share\/logging\/logTag.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2984,16 +2984,2 @@\n-    \/\/ jthread refers to a live JavaThread.\n-    {\n-      MutexLocker ml(receiver->SR_lock(), Mutex::_no_safepoint_check_flag);\n-      if (receiver->is_external_suspend()) {\n-        \/\/ Don't allow nested external suspend requests. We can't return\n-        \/\/ an error from this interface so just ignore the problem.\n-        return;\n-      }\n-      if (receiver->is_exiting()) { \/\/ thread is in the process of exiting\n-        return;\n-      }\n-      receiver->set_external_suspend();\n-    }\n-\n-    \/\/ java_suspend() will catch threads in the process of exiting\n-    \/\/ and will ignore them.\n+    \/\/ jthread refers to a live JavaThread, but java_suspend() will\n+    \/\/ detect a thread that has started to exit and will ignore it.\n@@ -3001,9 +2987,0 @@\n-\n-    \/\/ It would be nice to have the following assertion in all the\n-    \/\/ time, but it is possible for a racing resume request to have\n-    \/\/ resumed this thread right after we suspended it. Temporarily\n-    \/\/ enable this assertion if you are chasing a different kind of\n-    \/\/ bug.\n-    \/\/\n-    \/\/ assert(java_lang_Thread::thread(receiver->threadObj()) == NULL ||\n-    \/\/   receiver->is_being_ext_suspended(), \"thread is not suspended\");\n@@ -3020,16 +2997,0 @@\n-\n-    \/\/ This is the original comment for this Threads_lock grab:\n-    \/\/   We need to *always* get the threads lock here, since this operation cannot be allowed during\n-    \/\/   a safepoint. The safepoint code relies on suspending a thread to examine its state. If other\n-    \/\/   threads randomly resumes threads, then a thread might not be suspended when the safepoint code\n-    \/\/   looks at it.\n-    \/\/\n-    \/\/ The above comment dates back to when we had both internal and\n-    \/\/ external suspend APIs that shared a common underlying mechanism.\n-    \/\/ External suspend is now entirely cooperative and doesn't share\n-    \/\/ anything with internal suspend. That said, there are some\n-    \/\/ assumptions in the VM that an external resume grabs the\n-    \/\/ Threads_lock. We can't drop the Threads_lock grab here until we\n-    \/\/ resolve the assumptions that exist elsewhere.\n-    \/\/\n-    MutexLocker ml(Threads_lock);\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":2,"deletions":41,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -882,1 +882,1 @@\n-    if (java_thread->is_being_ext_suspended()) {\n+    if (java_thread->is_suspended()) {\n@@ -948,1 +948,1 @@\n-    return (JVMTI_ERROR_NONE);\n+    return JVMTI_ERROR_NONE;\n@@ -950,11 +950,2 @@\n-\n-  {\n-    MutexLocker ml(java_thread->SR_lock(), Mutex::_no_safepoint_check_flag);\n-    if (java_thread->is_external_suspend()) {\n-      \/\/ don't allow nested external suspend requests.\n-      return (JVMTI_ERROR_THREAD_SUSPENDED);\n-    }\n-    if (java_thread->is_exiting()) { \/\/ thread is in the process of exiting\n-      return (JVMTI_ERROR_THREAD_NOT_ALIVE);\n-    }\n-    java_thread->set_external_suspend();\n+  if (java_thread->is_suspended()) {\n+    return JVMTI_ERROR_THREAD_SUSPENDED;\n@@ -962,1 +953,0 @@\n-\n@@ -964,2 +954,6 @@\n-    \/\/ the thread was in the process of exiting\n-    return (JVMTI_ERROR_THREAD_NOT_ALIVE);\n+    \/\/ Either the thread is already suspended or\n+    \/\/ the thread was in the process of exiting:\n+    if (java_thread->is_exiting()) {\n+      return JVMTI_ERROR_THREAD_NOT_ALIVE;\n+    }\n+    return JVMTI_ERROR_THREAD_SUSPENDED;\n@@ -976,0 +970,1 @@\n+  int self_index = -1;\n@@ -977,1 +972,2 @@\n-  ThreadsListHandle tlh;\n+  JavaThread* current = JavaThread::current();\n+  ThreadsListHandle tlh(current);\n@@ -990,13 +986,7 @@\n-\n-    {\n-      MutexLocker ml(java_thread->SR_lock(), Mutex::_no_safepoint_check_flag);\n-      if (java_thread->is_external_suspend()) {\n-        \/\/ don't allow nested external suspend requests.\n-        results[i] = JVMTI_ERROR_THREAD_SUSPENDED;\n-        continue;\n-      }\n-      if (java_thread->is_exiting()) { \/\/ thread is in the process of exiting\n-        results[i] = JVMTI_ERROR_THREAD_NOT_ALIVE;\n-        continue;\n-      }\n-      java_thread->set_external_suspend();\n+    if (java_thread->is_suspended()) {\n+      results[i] = JVMTI_ERROR_THREAD_SUSPENDED;\n+      continue;\n+    }\n+    if (java_thread == current) {\n+      self_index = i;\n+      continue;\n@@ -1004,7 +994,4 @@\n-    if (java_thread->thread_state() == _thread_in_native) {\n-      \/\/ We need to try and suspend native threads here. Threads in\n-      \/\/ other states will self-suspend on their next transition.\n-      if (!JvmtiSuspendControl::suspend(java_thread)) {\n-        \/\/ The thread was in the process of exiting. Force another\n-        \/\/ safepoint to make sure that this thread transitions.\n-        needSafepoint++;\n+    if (!JvmtiSuspendControl::suspend(java_thread)) {\n+      \/\/ Either the thread is already suspended or\n+      \/\/ the thread was in the process of exiting:\n+      if (java_thread->is_exiting()) {\n@@ -1014,2 +1001,2 @@\n-    } else {\n-      needSafepoint++;\n+      results[i] =  JVMTI_ERROR_THREAD_SUSPENDED;\n+      continue;\n@@ -1019,3 +1006,6 @@\n-  if (needSafepoint > 0) {\n-    VM_ThreadsSuspendJVMTI tsj;\n-    VMThread::execute(&tsj);\n+  if (self_index >= 0) {\n+    if (!JvmtiSuspendControl::suspend(current)) {\n+      results[self_index] = JVMTI_ERROR_THREAD_NOT_ALIVE;\n+    } else {\n+      results[self_index] = JVMTI_ERROR_NONE;  \/\/ indicate successful suspend\n+    }\n@@ -1036,2 +1026,1 @@\n-\n-  if (!java_thread->is_being_ext_suspended()) {\n+  if (!java_thread->is_suspended()) {\n@@ -1040,1 +1029,0 @@\n-\n@@ -1066,1 +1054,1 @@\n-    if (!java_thread->is_being_ext_suspended()) {\n+    if (!java_thread->is_suspended()) {\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnv.cpp","additions":34,"deletions":46,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -1184,2 +1184,1 @@\n-    \/\/ same as is_being_ext_suspended() but without locking\n-    if (thr->is_ext_suspended() || thr->is_external_suspend()) {\n+    if (thr->is_suspended()) {\n@@ -1403,1 +1402,1 @@\n-    if (!java_thread->is_external_suspend()) {\n+    if (!java_thread->is_suspended()) {\n@@ -1536,1 +1535,1 @@\n-  if (!self && !java_thread->is_external_suspend()) {\n+  if (!self && !java_thread->is_suspended()) {\n@@ -1627,1 +1626,1 @@\n-  if (!self && !java_thread->is_external_suspend()) {\n+  if (!self && !java_thread->is_suspended()) {\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.cpp","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -768,24 +768,1 @@\n-  \/\/ external suspend should have caught suspending a thread twice\n-\n-  \/\/ Immediate suspension required for JPDA back-end so JVMTI agent threads do\n-  \/\/ not deadlock due to later suspension on transitions while holding\n-  \/\/ raw monitors.  Passing true causes the immediate suspension.\n-  \/\/ java_suspend() will catch threads in the process of exiting\n-  \/\/ and will ignore them.\n-  java_thread->java_suspend();\n-\n-  \/\/ It would be nice to have the following assertion in all the time,\n-  \/\/ but it is possible for a racing resume request to have resumed\n-  \/\/ this thread right after we suspended it. Temporarily enable this\n-  \/\/ assertion if you are chasing a different kind of bug.\n-  \/\/\n-  \/\/ assert(java_lang_Thread::thread(java_thread->threadObj()) == NULL ||\n-  \/\/   java_thread->is_being_ext_suspended(), \"thread is not suspended\");\n-\n-  if (java_lang_Thread::thread(java_thread->threadObj()) == NULL) {\n-    \/\/ check again because we can get delayed in java_suspend():\n-    \/\/ the thread is in process of exiting.\n-    return false;\n-  }\n-\n-  return true;\n+  return java_thread->java_suspend();\n@@ -795,11 +772,1 @@\n-  \/\/ external suspend should have caught resuming a thread twice\n-  assert(java_thread->is_being_ext_suspended(), \"thread should be suspended\");\n-\n-  \/\/ resume thread\n-  {\n-    \/\/ must always grab Threads_lock, see JVM_SuspendThread\n-    MutexLocker ml(Threads_lock);\n-    java_thread->java_resume();\n-  }\n-\n-  return true;\n+  return java_thread->java_resume();\n@@ -808,1 +775,0 @@\n-\n@@ -820,1 +786,1 @@\n-    log_stream.print(\"%s(%c \", name, thread->is_being_ext_suspended() ? 'S' : '_');\n+    log_stream.print(\"%s(%c \", name, thread->is_suspended() ? 'S' : '_');\n","filename":"src\/hotspot\/share\/prims\/jvmtiImpl.cpp","additions":3,"deletions":37,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -244,1 +244,0 @@\n-      jt->set_suspend_equivalent();\n@@ -310,1 +309,2 @@\n-\/\/ Any JavaThread will enter here with state _thread_blocked\n+\/\/ Any JavaThread will enter here with state _thread_blocked unless we\n+\/\/ are in single-threaded mode during startup.\n@@ -318,5 +318,21 @@\n-    jt->SR_lock()->lock_without_safepoint_check();\n-    while (jt->is_external_suspend()) {\n-      jt->SR_lock()->unlock();\n-      jt->java_suspend_self();\n-      jt->SR_lock()->lock_without_safepoint_check();\n+    while (true) {\n+      \/\/ To pause suspend requests while in native we must block handshakes.\n+      jt->handshake_state()->lock();\n+      \/\/ Suspend request flag can only be set in handshakes.\n+      \/\/ By blocking handshakes, suspend request flag cannot change its value.\n+      if (!jt->handshake_state()->is_suspend_requested()) {\n+        contended = Atomic::cmpxchg(&_owner, (Thread*)NULL, jt);\n+        jt->handshake_state()->unlock();\n+        break;\n+      }\n+      jt->handshake_state()->unlock();\n+\n+      \/\/ We may only be in states other than _thread_blocked when we are\n+      \/\/ in single-threaded mode during startup.\n+      guarantee(jt->thread_state() == _thread_blocked, \"invariant\");\n+\n+      jt->set_thread_state_fence(_thread_blocked_trans);\n+      SafepointMechanism::process_if_requested(jt);\n+      \/\/ We should transition to thread_in_vm and then to thread_in_vm_trans,\n+      \/\/ but those are always treated the same as _thread_blocked_trans.\n+      jt->set_thread_state(_thread_blocked);\n@@ -324,3 +340,0 @@\n-    \/\/ guarded by SR_lock to avoid racing with new external suspend requests.\n-    contended = Atomic::cmpxchg(&_owner, (Thread*)NULL, jt);\n-    jt->SR_lock()->unlock();\n@@ -347,0 +360,1 @@\n+    \/\/ In multi-threaded mode, we must enter this method blocked.\n@@ -349,3 +363,0 @@\n-      jt->set_suspend_equivalent();\n-      \/\/ cleared by handle_special_suspend_equivalent_condition() or\n-      \/\/ java_suspend_self()\n@@ -353,3 +364,2 @@\n-\n-      \/\/ were we externally suspended while we were waiting?\n-      if (!jt->handle_special_suspend_equivalent_condition()) {\n+      if (!SafepointMechanism::should_process(jt)) {\n+        \/\/ Not suspended so we're done here:\n@@ -358,8 +368,0 @@\n-\n-      \/\/ This thread was externally suspended\n-      \/\/ We have reentered the contended monitor, but while we were\n-      \/\/ waiting another thread suspended us. We don't want to reenter\n-      \/\/ the monitor while suspended because that would surprise the\n-      \/\/ thread that suspended us.\n-      \/\/\n-      \/\/ Drop the lock\n@@ -367,2 +369,5 @@\n-\n-      jt->java_suspend_self();\n+      jt->set_thread_state_fence(_thread_blocked_trans);\n+      SafepointMechanism::process_if_requested(jt);\n+      \/\/ We should transition to thread_in_vm and then to thread_in_vm_trans,\n+      \/\/ but those are always treated the same as _thread_blocked_trans.\n+      jt->set_thread_state(_thread_blocked);\n@@ -414,0 +419,1 @@\n+    guarantee(jt->thread_state() == _thread_in_native, \"invariant\");\n@@ -415,2 +421,2 @@\n-      jt->set_suspend_equivalent();\n-      if (!jt->handle_special_suspend_equivalent_condition()) {\n+      if (!SafepointMechanism::should_process(jt)) {\n+        \/\/ Not suspended so we're done here:\n@@ -418,18 +424,0 @@\n-      } else {\n-        \/\/ We've been suspended whilst waiting and so we have to\n-        \/\/ relinquish the raw monitor until we are resumed. Of course\n-        \/\/ after reacquiring we have to re-check for suspension again.\n-        \/\/ Suspension requires we are _thread_blocked, and we also have to\n-        \/\/ recheck for being interrupted.\n-        simple_exit(jt);\n-        {\n-          ThreadInVMfromNative tivm(jt);\n-          {\n-            ThreadBlockInVM tbivm(jt);\n-            jt->java_suspend_self();\n-          }\n-          if (jt->is_interrupted(true)) {\n-            ret = M_INTERRUPTED;\n-          }\n-        }\n-        simple_enter(jt);\n@@ -437,0 +425,10 @@\n+      simple_exit(jt);\n+      jt->set_thread_state_fence(_thread_in_native_trans);\n+      SafepointMechanism::process_if_requested(jt);\n+      if (jt->is_interrupted(true)) {\n+        ret = M_INTERRUPTED;\n+      }\n+      \/\/ We should transition to thread_in_vm and then to thread_in_vm_trans,\n+      \/\/ but those are always treated the same as _thread_in_native_trans.\n+      jt->set_thread_state(_thread_in_native);\n+      simple_enter(jt);\n","filename":"src\/hotspot\/share\/prims\/jvmtiRawMonitor.cpp","additions":45,"deletions":47,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -297,5 +297,0 @@\n-bool JvmtiThreadState::may_be_walked() {\n-  return (get_thread()->is_being_ext_suspended() || (JavaThread::current() == get_thread()));\n-}\n-\n-\n","filename":"src\/hotspot\/share\/prims\/jvmtiThreadState.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -315,2 +315,0 @@\n-  bool may_be_walked();\n-\n","filename":"src\/hotspot\/share\/prims\/jvmtiThreadState.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -408,1 +408,3 @@\n-  _active_handshaker()\n+  _active_handshaker(),\n+  _suspended(false),\n+  _suspend_requested(false)\n@@ -414,2 +416,0 @@\n-  \/\/ Calling this method with lock held is considered an error.\n-  assert(!_lock.owned_by_self(), \"Lock should not be held\");\n@@ -456,1 +456,1 @@\n-void HandshakeState::process_by_self() {\n+bool HandshakeState::process_by_self() {\n@@ -463,0 +463,1 @@\n+    ttyLocker::break_tty_lock_for_safepoint(os::current_thread_id());\n@@ -464,1 +465,1 @@\n-    process_self_inner();\n+    return process_self_inner();\n@@ -468,1 +469,1 @@\n-void HandshakeState::process_self_inner() {\n+bool HandshakeState::process_self_inner() {\n@@ -470,2 +471,0 @@\n-    HandleMark hm(_handshakee);\n-    PreserveExceptionMark pem(_handshakee);\n@@ -480,2 +479,8 @@\n-      op->do_handshake(_handshakee);\n-      if (async) {\n+      if (!async) {\n+        HandleMark hm(_handshakee);\n+        PreserveExceptionMark pem(_handshakee);\n+        op->do_handshake(_handshakee);\n+      } else {\n+        \/\/ Asynchronous may block so they may not execute ~PreserveExceptionMark before safepointing\n+        \/\/ in outer loop.\n+        op->do_handshake(_handshakee);\n@@ -484,0 +489,1 @@\n+        return false; \/\/ Must check for safepoints\n@@ -485,0 +491,2 @@\n+    } else {\n+      return true;\n@@ -487,0 +495,1 @@\n+  return true;\n@@ -590,0 +599,130 @@\n+\n+void HandshakeState::lock() {\n+  _lock.lock_without_safepoint_check();\n+}\n+\n+void HandshakeState::unlock() {\n+  _lock.unlock();\n+}\n+\n+\/\/ The careful dance between thread suspension and exit is handled here.\n+\/\/ The caller has notified the agents that we are exiting, before we go\n+\/\/ on, we must check for a pending external suspend request and honor it\n+\/\/ in order to not surprise the thread that made the suspend request.\n+void HandshakeState::thread_exit() {\n+  guarantee(JavaThread::current() == _handshakee, \"Must be\");\n+  while (true) {\n+    {\n+      MutexLocker ml(&_lock, Mutex::_no_safepoint_check_flag);\n+      if (!is_suspend_requested()) {\n+        _handshakee->set_exiting();\n+        \/\/ No more external suspends are allowed at this point.\n+        return;\n+      }\n+    }\n+    ThreadBlockInVM tbivm(_handshakee);\n+    \/\/ We're done with this suspend request, but we have to loop around\n+    \/\/ and check again. Eventually we will get the lock without a pending\n+    \/\/ external suspend request and will be able to mark ourselves as\n+    \/\/ exiting.\n+  }\n+}\n+\n+bool HandshakeState::suspend_request_pending() {\n+  assert(JavaThread::current()->thread_state() != _thread_blocked, \"should not be in a blocked state\");\n+  assert(JavaThread::current()->thread_state() != _thread_in_native, \"should not be in native\");\n+  MutexLocker ml(&_lock, Mutex::_no_safepoint_check_flag);\n+  return is_suspend_requested();\n+}\n+\n+void HandshakeState::suspend_in_handshake() {\n+  assert(Thread::current() == _handshakee, \"should call from _handshakee\");\n+  assert(_lock.owned_by_self(), \"Lock must be held\");\n+  assert(!_handshakee->has_last_Java_frame() || _handshakee->frame_anchor()->walkable(), \"should have walkable stack\");\n+  JavaThreadState jts = _handshakee->thread_state();\n+  while (is_suspended()) {\n+    _handshakee->set_thread_state(_thread_blocked);\n+    log_trace(thread, suspend)(\"JavaThread:\" INTPTR_FORMAT \" suspended\", p2i(_handshakee));\n+    _lock.wait_without_safepoint_check();\n+  }\n+  _handshakee->set_thread_state(jts);\n+  set_suspend_requested(false);\n+  log_trace(thread, suspend)(\"JavaThread:\" INTPTR_FORMAT \" resumed\", p2i(_handshakee));\n+}\n+\n+\/\/ This is the closure that prevents a suspended JavaThread from\n+\/\/ escaping the suspend request.\n+class ThreadSuspensionHandshake : public AsyncHandshakeClosure {\n+ public:\n+  ThreadSuspensionHandshake() : AsyncHandshakeClosure(\"ThreadSuspension\") {}\n+  void do_thread(Thread* thr) {\n+    JavaThread* target = thr->as_Java_thread();\n+    target->handshake_state()->suspend_in_handshake();\n+  }\n+};\n+\n+bool HandshakeState::handshake_suspend() {\n+  if (_handshakee->is_exiting() ||\n+     _handshakee->threadObj() == NULL) {\n+    log_trace(thread, suspend)(\"JavaThread:\" INTPTR_FORMAT \" exiting\", p2i(_handshakee));\n+    return false;\n+  }\n+  if (is_suspend_requested()) {\n+    if (is_suspended()) {\n+      \/\/ Target is already suspended.\n+      log_trace(thread, suspend)(\"JavaThread:\" INTPTR_FORMAT \" already suspended\", p2i(_handshakee));\n+      return false;\n+    } else {\n+      \/\/ Target is going to wake up and leave suspension.\n+      \/\/ Let's just stop the thread from doing that.\n+      log_trace(thread, suspend)(\"JavaThread:\" INTPTR_FORMAT \" re-suspended\", p2i(_handshakee));\n+      set_suspend(true);\n+      return true;\n+    }\n+  }\n+  \/\/ no suspend request\n+  assert(!is_suspended(), \"cannot be suspended without a suspend request\");\n+  \/\/ Thread is safe, so it must execute the request, thus we can count it as suspended\n+  \/\/ from this point.\n+  set_suspend(true);\n+  set_suspend_requested(true);\n+  log_trace(thread, suspend)(\"JavaThread:\" INTPTR_FORMAT \" suspended, arming ThreadSuspension\", p2i(_handshakee));\n+  ThreadSuspensionHandshake* ts = new ThreadSuspensionHandshake();\n+  Handshake::execute(ts, _handshakee);\n+  return true;\n+}\n+\n+\/\/ This is the closure that synchronously honors the suspend request.\n+class SuspendThreadHandshake : public HandshakeClosure {\n+  bool _did_suspend;\n+public:\n+  SuspendThreadHandshake() : HandshakeClosure(\"SuspendThread\"), _did_suspend(false) {}\n+  void do_thread(Thread* thr) {\n+    JavaThread* target = thr->as_Java_thread();\n+    _did_suspend = target->handshake_state()->handshake_suspend();\n+  }\n+  bool did_suspend() { return _did_suspend; }\n+};\n+\n+bool HandshakeState::suspend() {\n+  SuspendThreadHandshake st;\n+  Handshake::execute(&st, _handshakee);\n+  return st.did_suspend();\n+}\n+\n+bool HandshakeState::resume() {\n+  \/\/ Can't be suspended if there is no suspend request.\n+  if (!is_suspend_requested()) {\n+    return false;\n+  }\n+  MutexLocker ml(&_lock, Mutex::_no_safepoint_check_flag);\n+  \/\/ Can't be suspended if there is no suspend request.\n+  if (!is_suspend_requested()) {\n+    assert(!_handshakee->is_suspended(), \"cannot be suspended without a suspend request\");\n+    return false;\n+  }\n+  \/\/ Resume the thread.\n+  set_suspend(false);\n+  _lock.notify();\n+  return true;\n+}\n","filename":"src\/hotspot\/share\/runtime\/handshake.cpp","additions":149,"deletions":10,"binary":false,"changes":159,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,2 @@\n+class ThreadSuspensionHandshake;\n+class SuspendThreadHandshake;\n@@ -46,3 +48,3 @@\n-  virtual ~HandshakeClosure() {}\n-  const char* name() const    { return _name; }\n-  virtual bool is_async()     { return false; }\n+  virtual ~HandshakeClosure()                      {}\n+  const char* name() const                         { return _name; }\n+  virtual bool is_async()                          { return false; }\n@@ -64,1 +66,1 @@\n-  static void execute(AsyncHandshakeClosure* hs_cl, JavaThread* target);\n+  static void execute(AsyncHandshakeClosure*  hs_cl, JavaThread* target);\n@@ -67,0 +69,2 @@\n+class JvmtiRawMonitor;\n+\n@@ -72,0 +76,4 @@\n+  friend JvmtiRawMonitor;\n+  friend ThreadSuspensionHandshake;\n+  friend SuspendThreadHandshake;\n+  friend JavaThread;\n@@ -77,2 +85,3 @@\n-  \/\/ Provides mutual exclusion to this state and queue.\n-  Mutex   _lock;\n+  \/\/ Provides mutual exclusion to this state and queue. Also used for\n+  \/\/ JavaThread suspend\/resume operations.\n+  Monitor _lock;\n@@ -85,1 +94,1 @@\n-  void process_self_inner();\n+  bool process_self_inner();\n@@ -91,0 +100,3 @@\n+  void lock();\n+  void unlock();\n+\n@@ -113,1 +125,1 @@\n-  void process_by_self();\n+  bool process_by_self();\n@@ -126,0 +138,21 @@\n+\n+  \/\/ Suspend\/resume support\n+ private:\n+  volatile bool _suspended;\n+  volatile bool _suspend_requested;\n+\n+  \/\/ Called from the suspend handshake.\n+  bool handshake_suspend();\n+  \/\/ Called from the async handshake (the trap)\n+  \/\/ to stop a thread from continuing executing when suspended.\n+  void suspend_in_handshake();\n+\n+  bool is_suspended()                 { return Atomic::load(&_suspended); }\n+  void set_suspend(bool to)           { return Atomic::store(&_suspended, to); }\n+  bool is_suspend_requested()         { return Atomic::load(&_suspend_requested); }\n+  void set_suspend_requested(bool to) { return Atomic::store(&_suspend_requested, to); }\n+\n+  bool suspend();\n+  bool resume();\n+  void thread_exit();\n+  bool suspend_request_pending();\n","filename":"src\/hotspot\/share\/runtime\/handshake.hpp","additions":42,"deletions":9,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -218,1 +218,1 @@\n-bool Monitor::wait(int64_t timeout, bool as_suspend_equivalent) {\n+bool Monitor::wait(int64_t timeout) {\n@@ -241,5 +241,0 @@\n-    if (as_suspend_equivalent) {\n-      self->set_suspend_equivalent();\n-      \/\/ cleared by handle_special_suspend_equivalent_condition() or\n-      \/\/ java_suspend_self()\n-    }\n@@ -250,10 +245,0 @@\n-    \/\/ were we externally suspended while we were waiting?\n-    if (as_suspend_equivalent && self->handle_special_suspend_equivalent_condition()) {\n-      \/\/ Our event wait has finished and we own the lock, but\n-      \/\/ while we were waiting another thread suspended us. We don't\n-      \/\/ want to hold the lock while suspended because that\n-      \/\/ would surprise the thread that suspended us.\n-      _lock.unlock();\n-      self->java_suspend_self();\n-      _lock.lock();\n-    }\n@@ -278,1 +263,1 @@\n-\/\/ Only Threads_lock, Heap_lock and SR_lock may be safepoint_check_sometimes.\n+\/\/ Only Threads_lock and Heap_lock may be safepoint_check_sometimes.\n@@ -280,1 +265,1 @@\n-  return (strcmp(name, \"Threads_lock\") == 0 || strcmp(name, \"Heap_lock\") == 0 || strcmp(name, \"SR_lock\") == 0);\n+  return (strcmp(name, \"Threads_lock\") == 0 || strcmp(name, \"Heap_lock\") == 0);\n","filename":"src\/hotspot\/share\/runtime\/mutex.cpp","additions":3,"deletions":18,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -230,4 +230,2 @@\n-  \/\/ zero), and not a suspend-equivalent condition. Returns true if wait\n-  \/\/ times out; otherwise returns false.\n-  bool wait(int64_t timeout = 0,\n-            bool as_suspend_equivalent = !_as_suspend_equivalent_flag);\n+  \/\/ zero). Returns true if wait times out; otherwise returns false.\n+  bool wait(int64_t timeout = 0);\n","filename":"src\/hotspot\/share\/runtime\/mutex.hpp","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -259,2 +259,1 @@\n-  bool wait(int64_t timeout = 0,\n-            bool as_suspend_equivalent = !Mutex::_as_suspend_equivalent_flag) {\n+  bool wait(int64_t timeout = 0) {\n@@ -262,1 +261,1 @@\n-      return _monitor->wait(timeout, as_suspend_equivalent);\n+      return _monitor->wait(timeout);\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -326,3 +326,2 @@\n-    \/\/ This wait should make safepoint checks, wait without a timeout,\n-    \/\/ and wait as a suspend-equivalent condition.\n-    mu.wait(0, Mutex::_as_suspend_equivalent_flag);\n+    \/\/ This wait should make safepoint checks, wait without a timeout.\n+    mu.wait(0);\n","filename":"src\/hotspot\/share\/runtime\/nonJavaThread.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -110,2 +110,2 @@\n-        \/\/ Wait as a suspend equalent until notified that there is some work to do.\n-        ml.wait(0, true);\n+        \/\/ Wait until notified that there is some work to do.\n+        ml.wait(0);\n","filename":"src\/hotspot\/share\/runtime\/notificationThread.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -405,1 +405,0 @@\n-    ThreadBlockInVM tbivm(current);\n@@ -407,5 +406,1 @@\n-    \/\/ TODO-FIXME: change the following for(;;) loop to straight-line code.\n-    for (;;) {\n-      current->set_suspend_equivalent();\n-      \/\/ cleared by handle_special_suspend_equivalent_condition()\n-      \/\/ or java_suspend_self()\n+    assert(current->thread_state() == _thread_in_vm, \"invariant\");\n@@ -413,0 +408,4 @@\n+    current->frame_anchor()->make_walkable(current);\n+    OrderAccess::storestore();\n+    for (;;) {\n+      current->set_thread_state(_thread_blocked);\n@@ -414,13 +413,18 @@\n-\n-      if (!current->handle_special_suspend_equivalent_condition()) break;\n-\n-      \/\/ We have acquired the contended monitor, but while we were\n-      \/\/ waiting another thread suspended us. We don't want to enter\n-      \/\/ the monitor while suspended because that would surprise the\n-      \/\/ thread that suspended us.\n-      \/\/\n-      _recursions = 0;\n-      _succ = NULL;\n-      exit(false, current);\n-\n-      current->java_suspend_self();\n+      current->set_thread_state_fence(_thread_blocked_trans);\n+      if (SafepointMechanism::should_process(current) &&\n+        current->suspend_request_pending()) {\n+        \/\/ We have acquired the contended monitor, but while we were\n+        \/\/ waiting another thread suspended us. We don't want to enter\n+        \/\/ the monitor while suspended because that would surprise the\n+        \/\/ thread that suspended us.\n+        _recursions = 0;\n+        _succ = NULL;\n+        exit(false, current);\n+        SafepointMechanism::process_if_requested(current);\n+        \/\/ Since we are going to _thread_blocked we skip setting _thread_in_vm here.\n+      } else {\n+        \/\/ Only exit path from for loop\n+        SafepointMechanism::process_if_requested(current);\n+        current->set_thread_state(_thread_in_vm);\n+        break;\n+      }\n@@ -428,0 +432,1 @@\n+\n@@ -956,3 +961,0 @@\n-    \/\/ State transition wrappers around park() ...\n-    \/\/ ReenterI() wisely defers state transitions until\n-    \/\/ it's clear we must park the thread.\n@@ -961,1 +963,0 @@\n-      ThreadBlockInVM tbivm(current);\n@@ -963,4 +964,1 @@\n-      \/\/ cleared by handle_special_suspend_equivalent_condition()\n-      \/\/ or java_suspend_self()\n-      current->set_suspend_equivalent();\n-      current->_ParkEvent->park();\n+      assert(current->thread_state() == _thread_in_vm, \"invariant\");\n@@ -968,6 +966,11 @@\n-      \/\/ were we externally suspended while we were waiting?\n-      for (;;) {\n-        if (!current->handle_special_suspend_equivalent_condition()) break;\n-        if (_succ == current) { _succ = NULL; OrderAccess::fence(); }\n-        current->java_suspend_self();\n-        current->set_suspend_equivalent();\n+      current->frame_anchor()->make_walkable(current);\n+      OrderAccess::storestore();\n+      current->set_thread_state(_thread_blocked);\n+      current->_ParkEvent->park();\n+      current->set_thread_state_fence(_thread_blocked_trans);\n+      if (SafepointMechanism::should_process(current)) {\n+        if (_succ == current) {\n+            _succ = NULL;\n+            OrderAccess::fence();\n+        }\n+        SafepointMechanism::process_if_requested(current);\n@@ -975,0 +978,1 @@\n+      current->set_thread_state(_thread_in_vm);\n@@ -1528,4 +1532,0 @@\n-    {\n-      ThreadBlockInVM tbivm(current);\n-      \/\/ Thread is in thread_blocked state and oop access is unsafe.\n-      current->set_suspend_equivalent();\n@@ -1533,0 +1533,6 @@\n+    assert(current->thread_state() == _thread_in_vm, \"invariant\");\n+\n+    {\n+      current->frame_anchor()->make_walkable(current);\n+      OrderAccess::storestore();\n+      current->set_thread_state(_thread_blocked);\n@@ -1542,5 +1548,7 @@\n-\n-      \/\/ were we externally suspended while we were waiting?\n-      if (current->handle_special_suspend_equivalent_condition()) {\n-        \/\/ TODO-FIXME: add -- if succ == current then succ = null.\n-        current->java_suspend_self();\n+      current->set_thread_state_fence(_thread_blocked_trans);\n+      if (SafepointMechanism::should_process(current)) {\n+        if (_succ == current) {\n+            _succ = NULL;\n+            OrderAccess::fence();\n+        }\n+        SafepointMechanism::process_if_requested(current);\n@@ -1548,2 +1556,2 @@\n-\n-    } \/\/ Exit thread safepoint: transition _thread_blocked -> _thread_in_vm\n+      current->set_thread_state(_thread_in_vm);\n+    }\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.cpp","additions":52,"deletions":44,"binary":false,"changes":96,"status":"modified"},{"patch":"@@ -874,5 +874,10 @@\n-  \/\/ guard suspend\/resume\n-  MutexLocker ml(thread->SR_lock(), Mutex::_no_safepoint_check_flag);\n-  OSThread* osthread = thread->osthread();\n-  osthread->set_state(RUNNABLE);\n-  pd_start_thread(thread);\n+  if (thread->is_Java_thread()) {\n+    JavaThread* jt = thread->as_Java_thread();\n+    OSThread* osthread = jt->osthread();\n+    osthread->set_state(RUNNABLE);\n+    pd_start_thread(jt);\n+  } else {\n+    OSThread* osthread = thread->osthread();\n+    osthread->set_state(RUNNABLE);\n+    pd_start_thread(thread);\n+  }\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":10,"deletions":5,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -80,6 +80,9 @@\n-  if (global_poll()) {\n-    \/\/ Any load in ::block must not pass the global poll load.\n-    \/\/ Otherwise we might load an old safepoint counter (for example).\n-    OrderAccess::loadload();\n-    SafepointSynchronize::block(thread);\n-  }\n+  bool need_rechecking;\n+  do {\n+    need_rechecking = false;\n+    if (global_poll()) {\n+      \/\/ Any load in ::block() must not pass the global poll load.\n+      \/\/ Otherwise we might load an old safepoint counter (for example).\n+      OrderAccess::loadload();\n+      SafepointSynchronize::block(thread);\n+    }\n@@ -87,7 +90,7 @@\n-  \/\/ The call to on_safepoint fixes the thread's oops and the first few frames.\n-  \/\/\n-  \/\/ The call has been carefully placed here to cater for a few situations:\n-  \/\/ 1) After we exit from block after a global poll\n-  \/\/ 2) After a thread races with the disarming of the global poll and transitions from native\/blocked\n-  \/\/ 3) Before the handshake code is run\n-  StackWatermarkSet::on_safepoint(thread);\n+    \/\/ The call to on_safepoint fixes the thread's oops and the first few frames.\n+    \/\/\n+    \/\/ The call has been carefully placed here to cater to a few situations:\n+    \/\/ 1) After we exit from block after a global poll\n+    \/\/ 2) After a thread races with the disarming of the global poll and transitions from native\/blocked\n+    \/\/ 3) Before the handshake code is run\n+    StackWatermarkSet::on_safepoint(thread);\n@@ -95,3 +98,5 @@\n-  if (thread->handshake_state()->should_process()) {\n-    thread->handshake_state()->process_by_self();\n-  }\n+    if (thread->handshake_state()->should_process() &&\n+        !thread->handshake_state()->process_by_self()) {\n+      need_rechecking = true;\n+    }\n+  } while (need_rechecking);\n@@ -114,0 +119,2 @@\n+  assert(thread->thread_state() != _thread_blocked, \"Must not be\");\n+  assert(thread->thread_state() != _thread_in_native, \"Must not be\");\n","filename":"src\/hotspot\/share\/runtime\/safepointMechanism.cpp","additions":23,"deletions":16,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -269,8 +269,5 @@\n-  if (SafepointMechanism::should_process(thread)) {\n-    if (PrintMethodFlushing && Verbose) {\n-      tty->print_cr(\"### Sweep at %d out of %d, yielding to safepoint\", _seen, CodeCache::nmethod_count());\n-    }\n-    MutexUnlocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);\n-\n-    ThreadBlockInVM tbivm(thread);\n-    thread->java_suspend_self();\n+  if (!SafepointMechanism::should_process(thread)) {\n+    return; \/\/ Avoid unlocking and keep processing.\n+  }\n+  if (PrintMethodFlushing && Verbose) {\n+    tty->print_cr(\"### Sweep at %d out of %d, yielding to safepoint\", _seen, CodeCache::nmethod_count());\n@@ -278,0 +275,2 @@\n+  MutexUnlocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);\n+  ThreadBlockInVM tbiv(JavaThread::current());\n","filename":"src\/hotspot\/share\/runtime\/sweeper.cpp","additions":8,"deletions":9,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -275,2 +275,0 @@\n-  _SR_lock = new Monitor(Mutex::suspend_resume, \"SR_lock\", true,\n-                         Monitor::_safepoint_check_sometimes);\n@@ -454,5 +452,0 @@\n-  \/\/ SR_handler uses this as a termination indicator -\n-  \/\/ needs to happen before os::free_thread()\n-  delete _SR_lock;\n-  _SR_lock = NULL;\n-\n@@ -579,113 +572,0 @@\n-\n-\/\/ Check if an external suspend request has completed (or has been\n-\/\/ cancelled). Returns true if the thread is externally suspended and\n-\/\/ false otherwise.\n-bool JavaThread::is_ext_suspend_completed() {\n-  bool did_trans_retry = false;  \/\/ only do thread_in_native_trans retry once\n-  bool do_trans_retry;           \/\/ flag to force the retry\n-\n-  do {\n-    do_trans_retry = false;\n-\n-    if (is_exiting()) {\n-      \/\/ Thread is in the process of exiting. This is always checked\n-      \/\/ first to reduce the risk of dereferencing a freed JavaThread.\n-      return false;\n-    }\n-\n-    if (!is_external_suspend()) {\n-      \/\/ Suspend request is cancelled. This is always checked before\n-      \/\/ is_ext_suspended() to reduce the risk of a rogue resume\n-      \/\/ confusing the thread that made the suspend request.\n-      return false;\n-    }\n-\n-    if (is_ext_suspended()) {\n-      \/\/ thread is suspended\n-      return true;\n-    }\n-\n-    \/\/ Now that we no longer do hard suspends of threads running\n-    \/\/ native code, the target thread can be changing thread state\n-    \/\/ while we are in this routine:\n-    \/\/\n-    \/\/   _thread_in_native -> _thread_in_native_trans -> _thread_blocked\n-    \/\/\n-    \/\/ We save a copy of the thread state as observed at this moment\n-    \/\/ and make our decision about suspend completeness based on the\n-    \/\/ copy. This closes the race where the thread state is seen as\n-    \/\/ _thread_in_native_trans in the if-thread_blocked check, but is\n-    \/\/ seen as _thread_blocked in if-thread_in_native_trans check.\n-    JavaThreadState save_state = thread_state();\n-\n-    if (save_state == _thread_blocked && is_suspend_equivalent()) {\n-      \/\/ If the thread's state is _thread_blocked and this blocking\n-      \/\/ condition is known to be equivalent to a suspend, then we can\n-      \/\/ consider the thread to be externally suspended. This means that\n-      \/\/ the code that sets _thread_blocked has been modified to do\n-      \/\/ self-suspension if the blocking condition releases. We also\n-      \/\/ used to check for CONDVAR_WAIT here, but that is now covered by\n-      \/\/ the _thread_blocked with self-suspension check.\n-      \/\/\n-      \/\/ Return true since we wouldn't be here unless there was still an\n-      \/\/ external suspend request.\n-      return true;\n-    } else if (save_state == _thread_in_native && frame_anchor()->walkable()) {\n-      \/\/ Threads running native code will self-suspend on native==>VM\/Java\n-      \/\/ transitions. If its stack is walkable (should always be the case\n-      \/\/ unless this function is called before the actual java_suspend()\n-      \/\/ call), then the wait is done.\n-      return true;\n-    } else if (!did_trans_retry &&\n-               save_state == _thread_in_native_trans &&\n-               frame_anchor()->walkable()) {\n-      \/\/ The thread is transitioning from thread_in_native to another\n-      \/\/ thread state. check_safepoint_and_suspend_for_native_trans()\n-      \/\/ will force the thread to self-suspend. If it hasn't gotten\n-      \/\/ there yet we may have caught the thread in-between the native\n-      \/\/ code check above and the self-suspend.\n-      \/\/\n-      \/\/ Since we use the saved thread state in the if-statement above,\n-      \/\/ there is a chance that the thread has already transitioned to\n-      \/\/ _thread_blocked by the time we get here. In that case, we will\n-      \/\/ make a single unnecessary pass through the logic below. This\n-      \/\/ doesn't hurt anything since we still do the trans retry.\n-\n-      \/\/ Once the thread leaves thread_in_native_trans for another\n-      \/\/ thread state, we break out of this retry loop. We shouldn't\n-      \/\/ need this flag to prevent us from getting back here, but\n-      \/\/ sometimes paranoia is good.\n-      did_trans_retry = true;\n-\n-      \/\/ We wait for the thread to transition to a more usable state.\n-      for (int i = 1; i <= SuspendRetryCount; i++) {\n-        \/\/ We used to do an \"os::yield_all(i)\" call here with the intention\n-        \/\/ that yielding would increase on each retry. However, the parameter\n-        \/\/ is ignored on Linux which means the yield didn't scale up. Waiting\n-        \/\/ on the SR_lock below provides a much more predictable scale up for\n-        \/\/ the delay. It also provides a simple\/direct point to check for any\n-        \/\/ safepoint requests from the VMThread\n-\n-        \/\/ temporarily drops SR_lock while doing wait with safepoint check\n-        \/\/ (if we're a JavaThread - the WatcherThread can also call this)\n-        \/\/ and increase delay with each retry\n-        if (Thread::current()->is_Java_thread()) {\n-          SR_lock()->wait(i * SuspendRetryDelay);\n-        } else {\n-          SR_lock()->wait_without_safepoint_check(i * SuspendRetryDelay);\n-        }\n-\n-        \/\/ check the actual thread state instead of what we saved above\n-        if (thread_state() != _thread_in_native_trans) {\n-          \/\/ the thread has transitioned to another thread state so\n-          \/\/ try all the checks (except this one) one more time.\n-          do_trans_retry = true;\n-          break;\n-        }\n-      } \/\/ end retry loop\n-    }\n-  } while (do_trans_retry);\n-\n-  return false;\n-}\n-\n@@ -1186,1 +1066,0 @@\n-  _suspend_equivalent(false),\n@@ -1231,1 +1110,0 @@\n-\n@@ -1557,20 +1435,3 @@\n-    \/\/ We have notified the agents that we are exiting, before we go on,\n-    \/\/ we must check for a pending external suspend request and honor it\n-    \/\/ in order to not surprise the thread that made the suspend request.\n-    while (true) {\n-      {\n-        MutexLocker ml(SR_lock(), Mutex::_no_safepoint_check_flag);\n-        if (!is_external_suspend()) {\n-          set_terminated(_thread_exiting);\n-          ThreadService::current_thread_exiting(this, is_daemon(threadObj()));\n-          break;\n-        }\n-        \/\/ Implied else:\n-        \/\/ Things get a little tricky here. We have a pending external\n-        \/\/ suspend request, but we are holding the SR_lock so we\n-        \/\/ can't just self-suspend. So we temporarily drop the lock\n-        \/\/ and then self-suspend.\n-      }\n-\n-      ThreadBlockInVM tbivm(this);\n-      java_suspend_self();\n+    \/\/ The careful dance between thread suspension and exit is handled here:\n+    _handshake.thread_exit();\n+    ThreadService::current_thread_exiting(this, is_daemon(threadObj()));\n@@ -1578,6 +1439,0 @@\n-      \/\/ We're done with this suspend request, but we have to loop around\n-      \/\/ and check again. Eventually we will get SR_lock without a pending\n-      \/\/ external suspend request and will be able to mark ourselves as\n-      \/\/ exiting.\n-    }\n-    \/\/ no more external suspends are allowed at this point\n@@ -1857,6 +1712,0 @@\n-  \/\/ Check for pending external suspend.\n-  if (is_external_suspend_with_lock()) {\n-    frame_anchor()->make_walkable(this);\n-    java_suspend_self_with_safepoint_check();\n-  }\n-\n@@ -1924,0 +1773,1 @@\n+\n@@ -1926,4 +1776,3 @@\n-\/\/ Tell the VM to suspend a thread when ever it knows that it does not hold on\n-\/\/ to any VM_locks and it is at a transition\n-\/\/ Self-suspension will happen on the transition out of the vm.\n-\/\/ Catch \"this\" coming in from JNIEnv pointers when the thread has been freed\n+\/\/ Guarantees on return (for a valid target thread):\n+\/\/   - Target thread will not execute any new bytecode.\n+\/\/   - Target thread will not enter any new monitors.\n@@ -1931,6 +1780,1 @@\n-\/\/ Guarantees on return:\n-\/\/   + Target thread will not execute any new bytecode (that's why we need to\n-\/\/     force a safepoint)\n-\/\/   + Target thread will not enter any new monitors\n-\/\/\n-void JavaThread::java_suspend() {\n+bool JavaThread::java_suspend() {\n@@ -1938,32 +1782,3 @@\n-  if (!tlh.includes(this) || threadObj() == NULL || is_exiting()) {\n-    return;\n-  }\n-\n-  { MutexLocker ml(SR_lock(), Mutex::_no_safepoint_check_flag);\n-    if (!is_external_suspend()) {\n-      \/\/ a racing resume has cancelled us; bail out now\n-      return;\n-    }\n-\n-    \/\/ suspend is done\n-\n-    \/\/ Warning: is_ext_suspend_completed() may temporarily drop the\n-    \/\/ SR_lock to allow the thread to reach a stable thread state if\n-    \/\/ it is currently in a transient thread state.\n-    if (is_ext_suspend_completed()) {\n-      return;\n-    }\n-  }\n-\n-  if (Thread::current() == this) {\n-    \/\/ Safely self-suspend.\n-    \/\/ If we don't do this explicitly it will implicitly happen\n-    \/\/ before we transition back to Java, and on some other thread-state\n-    \/\/ transition paths, but not as we exit a JVM TI SuspendThread call.\n-    \/\/ As SuspendThread(current) must not return (until resumed) we must\n-    \/\/ self-suspend here.\n-    ThreadBlockInVM tbivm(this);\n-    java_suspend_self();\n-  } else {\n-    VM_ThreadSuspend vm_suspend;\n-    VMThread::execute(&vm_suspend);\n+  if (!tlh.includes(this)) {\n+    log_trace(thread, suspend)(\"JavaThread:\" INTPTR_FORMAT \" not on ThreadsList, no suspension\", p2i(this));\n+    return false;\n@@ -1971,0 +1786,1 @@\n+  return this->handshake_state()->suspend();\n@@ -1973,21 +1789,5 @@\n-\/\/ Part II of external suspension.\n-\/\/ A JavaThread self suspends when it detects a pending external suspend\n-\/\/ request. This is usually on transitions. It is also done in places\n-\/\/ where continuing to the next transition would surprise the caller,\n-\/\/ e.g., monitor entry.\n-\/\/\n-\/\/ Returns the number of times that the thread self-suspended.\n-\/\/\n-\/\/ Note: DO NOT call java_suspend_self() when you just want to block current\n-\/\/       thread. java_suspend_self() is the second stage of cooperative\n-\/\/       suspension for external suspend requests and should only be used\n-\/\/       to complete an external suspend request.\n-\/\/\n-int JavaThread::java_suspend_self() {\n-  assert(thread_state() == _thread_blocked, \"wrong state for java_suspend_self()\");\n-  int ret = 0;\n-\n-  \/\/ we are in the process of exiting so don't suspend\n-  if (is_exiting()) {\n-    clear_external_suspend();\n-    return ret;\n+bool JavaThread::java_resume() {\n+  ThreadsListHandle tlh;\n+  if (!tlh.includes(this)) {\n+    log_trace(thread, suspend)(\"JavaThread:\" INTPTR_FORMAT \" not on ThreadsList, nothing to resume\", p2i(this));\n+    return false;\n@@ -1995,73 +1795,1 @@\n-\n-  assert(_anchor.walkable() || !has_last_Java_frame(),\n-         \"must have walkable stack\");\n-\n-  MonitorLocker ml(SR_lock(), Mutex::_no_safepoint_check_flag);\n-\n-  assert(!this->is_ext_suspended(),\n-         \"a thread trying to self-suspend should not already be suspended\");\n-\n-  if (this->is_suspend_equivalent()) {\n-    \/\/ If we are self-suspending as a result of the lifting of a\n-    \/\/ suspend equivalent condition, then the suspend_equivalent\n-    \/\/ flag is not cleared until we set the ext_suspended flag.\n-    this->clear_suspend_equivalent();\n-  }\n-\n-  \/\/ A racing resume may have cancelled us before we grabbed SR_lock\n-  \/\/ above. Or another external suspend request could be waiting for us\n-  \/\/ by the time we return from SR_lock()->wait(). The thread\n-  \/\/ that requested the suspension may already be trying to walk our\n-  \/\/ stack and if we return now, we can change the stack out from under\n-  \/\/ it. This would be a \"bad thing (TM)\" and cause the stack walker\n-  \/\/ to crash. We stay self-suspended until there are no more pending\n-  \/\/ external suspend requests.\n-  while (is_external_suspend()) {\n-    ret++;\n-    this->set_ext_suspended();\n-\n-    \/\/ _ext_suspended flag is cleared by java_resume()\n-    while (is_ext_suspended()) {\n-      ml.wait();\n-    }\n-  }\n-  return ret;\n-}\n-\n-\/\/ Helper routine to set up the correct thread state before calling java_suspend_self.\n-\/\/ This is called when regular thread-state transition helpers can't be used because\n-\/\/ we can be in various states, in particular _thread_in_native_trans.\n-\/\/ We have to set the thread state directly to _thread_blocked so that it will\n-\/\/ be seen to be safepoint\/handshake safe whilst suspended. This is also\n-\/\/ necessary to allow a thread in is_ext_suspend_completed, that observed the\n-\/\/ _thread_in_native_trans state, to proceed.\n-\/\/ The problem with setting thread state directly is that a\n-\/\/ safepoint could happen just after java_suspend_self() returns after being resumed,\n-\/\/ and the VM thread will see the _thread_blocked state. So we must check for a safepoint\n-\/\/ after restoring the state to make sure we won't leave while a safepoint is in progress.\n-\/\/ However, not all initial-states are allowed when performing a safepoint check, as we\n-\/\/ should never be blocking at a safepoint whilst in those states(*). Of these 'bad' states\n-\/\/ only _thread_in_native is possible when executing this code (based on our two callers).\n-\/\/ A thread that is _thread_in_native is already safepoint-safe and so it doesn't matter\n-\/\/ whether the VMThread sees the _thread_blocked state, or the _thread_in_native state,\n-\/\/ and so we don't need the explicit safepoint check.\n-\/\/ (*) See switch statement in SafepointSynchronize::block() for thread states that are\n-\/\/ allowed when performing a safepoint check.\n-\n-void JavaThread::java_suspend_self_with_safepoint_check() {\n-  assert(this == Thread::current(), \"invariant\");\n-  JavaThreadState state = thread_state();\n-\n-  do {\n-    set_thread_state(_thread_blocked);\n-    java_suspend_self();\n-    \/\/ The current thread could have been suspended again. We have to check for\n-    \/\/ suspend after restoring the saved state. Without this the current thread\n-    \/\/ might return to _thread_in_Java and execute bytecodes for an arbitrary\n-    \/\/ long time.\n-    set_thread_state_fence(state);\n-\n-    if (state != _thread_in_native) {\n-      SafepointMechanism::process_if_requested(this);\n-    }\n-  } while (is_external_suspend());\n+  return this->handshake_state()->resume();\n@@ -2093,4 +1821,0 @@\n-    \/\/ Check if _external_suspend was set in the previous loop iteration.\n-    if (is_external_suspend()) {\n-      java_suspend_self();\n-    }\n@@ -2124,1 +1848,1 @@\n-  } while (is_obj_deopt_suspend() || is_external_suspend());\n+  } while (is_obj_deopt_suspend());\n@@ -2174,23 +1898,0 @@\n-\/\/ We need to guarantee the Threads_lock here, since resumes are not\n-\/\/ allowed during safepoint synchronization\n-\/\/ Can only resume from an external suspension\n-void JavaThread::java_resume() {\n-  assert_locked_or_safepoint(Threads_lock);\n-\n-  \/\/ Sanity check: thread is gone, has started exiting or the thread\n-  \/\/ was not externally suspended.\n-  ThreadsListHandle tlh;\n-  if (!tlh.includes(this) || is_exiting() || !is_external_suspend()) {\n-    return;\n-  }\n-\n-  MutexLocker ml(SR_lock(), Mutex::_no_safepoint_check_flag);\n-\n-  clear_external_suspend();\n-\n-  if (is_ext_suspended()) {\n-    clear_ext_suspended();\n-    SR_lock()->notify_all();\n-  }\n-}\n-\n@@ -2762,5 +2463,0 @@\n-\n-      this->set_suspend_equivalent();\n-      \/\/ cleared by handle_special_suspend_equivalent_condition() or\n-      \/\/ java_suspend_self() via check_and_wait_while_suspended()\n-\n@@ -2768,3 +2464,0 @@\n-\n-      \/\/ were we externally suspended while we were waiting?\n-      this->check_and_wait_while_suspended();\n@@ -3692,1 +3385,2 @@\n-  { MonitorLocker nu(Threads_lock);\n+  {\n+    MonitorLocker nu(Threads_lock);\n@@ -3694,3 +3388,2 @@\n-      \/\/ This wait should make safepoint checks, wait without a timeout,\n-      \/\/ and wait as a suspend-equivalent condition.\n-      nu.wait(0, Mutex::_as_suspend_equivalent_flag);\n+      \/\/ This wait should make safepoint checks, wait without a timeout.\n+      nu.wait(0);\n@@ -3867,1 +3560,1 @@\n-    p->set_terminated_value();\n+    p->set_terminated();\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":24,"deletions":331,"binary":false,"changes":355,"status":"modified"},{"patch":"@@ -215,65 +215,0 @@\n- private:\n-\n-  \/\/ ***************************************************************\n-  \/\/ Suspend and resume support\n-  \/\/ ***************************************************************\n-  \/\/\n-  \/\/ VM suspend\/resume no longer exists - it was once used for various\n-  \/\/ things including safepoints but was deprecated and finally removed\n-  \/\/ in Java 7. Because VM suspension was considered \"internal\" Java-level\n-  \/\/ suspension was considered \"external\", and this legacy naming scheme\n-  \/\/ remains.\n-  \/\/\n-  \/\/ External suspend\/resume requests come from JVM_SuspendThread,\n-  \/\/ JVM_ResumeThread, JVMTI SuspendThread, and finally JVMTI\n-  \/\/ ResumeThread. External\n-  \/\/ suspend requests cause _external_suspend to be set and external\n-  \/\/ resume requests cause _external_suspend to be cleared.\n-  \/\/ External suspend requests do not nest on top of other external\n-  \/\/ suspend requests. The higher level APIs reject suspend requests\n-  \/\/ for already suspended threads.\n-  \/\/\n-  \/\/ The external_suspend\n-  \/\/ flag is checked by has_special_runtime_exit_condition() and java thread\n-  \/\/ will self-suspend when handle_special_runtime_exit_condition() is\n-  \/\/ called. Most uses of the _thread_blocked state in JavaThreads are\n-  \/\/ considered the same as being externally suspended; if the blocking\n-  \/\/ condition lifts, the JavaThread will self-suspend. Other places\n-  \/\/ where VM checks for external_suspend include:\n-  \/\/   + mutex granting (do not enter monitors when thread is suspended)\n-  \/\/   + state transitions from _thread_in_native\n-  \/\/\n-  \/\/ In general, java_suspend() does not wait for an external suspend\n-  \/\/ request to complete. When it returns, the only guarantee is that\n-  \/\/ the _external_suspend field is true.\n-  \/\/\n-  \/\/ wait_for_ext_suspend_completion() is used to wait for an external\n-  \/\/ suspend request to complete. External suspend requests are usually\n-  \/\/ followed by some other interface call that requires the thread to\n-  \/\/ be quiescent, e.g., GetCallTrace(). By moving the \"wait time\" into\n-  \/\/ the interface that requires quiescence, we give the JavaThread a\n-  \/\/ chance to self-suspend before we need it to be quiescent. This\n-  \/\/ improves overall suspend\/query performance.\n-  \/\/\n-  \/\/ _suspend_flags controls the behavior of java_ suspend\/resume.\n-  \/\/ It must be set under the protection of SR_lock. Read from the flag is\n-  \/\/ OK without SR_lock as long as the value is only used as a hint.\n-  \/\/ (e.g., check _external_suspend first without lock and then recheck\n-  \/\/ inside SR_lock and finish the suspension)\n-  \/\/\n-  \/\/ _suspend_flags is also overloaded for other \"special conditions\" so\n-  \/\/ that a single check indicates whether any special action is needed\n-  \/\/ eg. for async exceptions.\n-  \/\/ -------------------------------------------------------------------\n-  \/\/ Notes:\n-  \/\/ 1. The suspend\/resume logic no longer uses ThreadState in OSThread\n-  \/\/ but we still update its value to keep other part of the system (mainly\n-  \/\/ JVMTI) happy. ThreadState is legacy code (see notes in\n-  \/\/ osThread.hpp).\n-  \/\/\n-  \/\/ 2. It would be more natural if set_external_suspend() is private and\n-  \/\/ part of java_suspend(), but that probably would affect the suspend\/query\n-  \/\/ performance. Need more investigation on this.\n-\n-  \/\/ suspend\/resume lock: used for self-suspend\n-  Monitor* _SR_lock;\n@@ -281,1 +216,0 @@\n- protected:\n@@ -286,3 +220,0 @@\n-    _external_suspend       = 0x20000000U, \/\/ thread is asked to self suspend\n-    _ext_suspended          = 0x40000000U, \/\/ thread has self-suspended\n-\n@@ -514,2 +445,0 @@\n-  Monitor* SR_lock() const                       { return _SR_lock; }\n-\n@@ -861,0 +790,1 @@\n+  friend class HandshakeState;\n@@ -960,2 +890,1 @@\n-  \/\/ suspend\/resume support\n-  volatile bool         _suspend_equivalent;     \/\/ Suspend equivalent condition\n+\n@@ -1166,1 +1095,2 @@\n-  void set_terminated(TerminatedTypes t);\n+  void set_exiting();\n+  void set_vm_exited();\n@@ -1168,1 +1098,1 @@\n-  void set_terminated_value();\n+  void set_terminated();\n@@ -1194,17 +1124,4 @@\n- private:\n-  inline void set_ext_suspended();\n-  inline void clear_ext_suspended();\n-\n- public:\n-  void java_suspend(); \/\/ higher-level suspension logic called by the public APIs\n-  void java_resume();  \/\/ higher-level resume logic called by the public APIs\n-  int  java_suspend_self(); \/\/ low-level self-suspension mechanics\n-\n-  \/\/ Synchronize with another thread that is deoptimizing objects of the\n-  \/\/ current thread, i.e. reverts optimizations based on escape analysis.\n-  void wait_for_object_deoptimization();\n-\n- private:\n-  \/\/ mid-level wrapper around java_suspend_self to set up correct state and\n-  \/\/ check for a pending safepoint at the end\n-  void java_suspend_self_with_safepoint_check();\n+  bool java_suspend(); \/\/ higher-level suspension logic called by the public APIs\n+  bool java_resume();  \/\/ higher-level resume logic called by the public APIs\n+  bool is_suspended()                 { return _handshake.is_suspended(); }\n+  bool suspend_request_pending()      { return _handshake.suspend_request_pending(); }\n@@ -1212,15 +1129,0 @@\n- public:\n-  void check_and_wait_while_suspended() {\n-    assert(JavaThread::current() == this, \"sanity check\");\n-\n-    bool do_self_suspend;\n-    do {\n-      \/\/ were we externally suspended while we were waiting?\n-      do_self_suspend = handle_special_suspend_equivalent_condition();\n-      if (do_self_suspend) {\n-        \/\/ don't surprise the thread that suspended us by returning\n-        java_suspend_self();\n-        set_suspend_equivalent();\n-      }\n-    } while (do_self_suspend);\n-  }\n@@ -1231,8 +1133,0 @@\n-  bool is_ext_suspend_completed();\n-\n-  inline void set_external_suspend();\n-  inline void clear_external_suspend();\n-\n-  bool is_external_suspend() const {\n-    return (_suspend_flags & _external_suspend) != 0;\n-  }\n@@ -1242,1 +1136,1 @@\n-    return (_suspend_flags & (_external_suspend | _obj_deopt JFR_ONLY(| _trace_flag))) != 0;\n+    return (_suspend_flags & (_obj_deopt JFR_ONLY(| _trace_flag))) != 0;\n@@ -1245,40 +1139,3 @@\n-  \/\/ external suspend request is completed\n-  bool is_ext_suspended() const {\n-    return (_suspend_flags & _ext_suspended) != 0;\n-  }\n-\n-  bool is_external_suspend_with_lock() const {\n-    MutexLocker ml(SR_lock(), Mutex::_no_safepoint_check_flag);\n-    return is_external_suspend();\n-  }\n-\n-  \/\/ Special method to handle a pending external suspend request\n-  \/\/ when a suspend equivalent condition lifts.\n-  bool handle_special_suspend_equivalent_condition() {\n-    assert(is_suspend_equivalent(),\n-           \"should only be called in a suspend equivalence condition\");\n-    MutexLocker ml(SR_lock(), Mutex::_no_safepoint_check_flag);\n-    bool ret = is_external_suspend();\n-    if (!ret) {\n-      \/\/ not about to self-suspend so clear suspend equivalence\n-      clear_suspend_equivalent();\n-    }\n-    \/\/ implied else:\n-    \/\/ We have a pending external suspend request so we leave the\n-    \/\/ suspend_equivalent flag set until java_suspend_self() sets\n-    \/\/ the ext_suspended flag and clears the suspend_equivalent\n-    \/\/ flag. This insures that wait_for_ext_suspend_completion()\n-    \/\/ will return consistent values.\n-    return ret;\n-  }\n-\n-  \/\/ utility methods to see if we are doing some kind of suspension\n-  bool is_being_ext_suspended() const            {\n-    MutexLocker ml(SR_lock(), Mutex::_no_safepoint_check_flag);\n-    return is_ext_suspended() || is_external_suspend();\n-  }\n-\n-  bool is_suspend_equivalent() const             { return _suspend_equivalent; }\n-\n-  void set_suspend_equivalent()                  { _suspend_equivalent = true; }\n-  void clear_suspend_equivalent()                { _suspend_equivalent = false; }\n+  \/\/ Synchronize with another thread that is deoptimizing objects of the\n+  \/\/ current thread, i.e. reverts optimizations based on escape analysis.\n+  void wait_for_object_deoptimization();\n@@ -1305,11 +1162,1 @@\n-    \/\/ Because we don't use is_external_suspend_with_lock\n-    \/\/ it is possible that we won't see an asynchronous external suspend\n-    \/\/ request that has just gotten started, i.e., SR_lock grabbed but\n-    \/\/ _external_suspend field change either not made yet or not visible\n-    \/\/ yet. However, this is okay because the request is asynchronous and\n-    \/\/ we will see the new flag value the next time through. It's also\n-    \/\/ possible that the external suspend request is dropped after\n-    \/\/ we have checked is_external_suspend(), we will recheck its value\n-    \/\/ under SR_lock in java_suspend_self().\n-    return (_special_runtime_exit_condition != _no_async_condition) ||\n-            is_external_suspend() || is_trace_suspend() || is_obj_deopt_suspend();\n+    return (_special_runtime_exit_condition != _no_async_condition) || is_trace_suspend() || is_obj_deopt_suspend();\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":14,"deletions":167,"binary":false,"changes":181,"status":"modified"},{"patch":"@@ -97,14 +97,0 @@\n-inline void JavaThread::set_ext_suspended() {\n-  set_suspend_flag (_ext_suspended);\n-}\n-inline void JavaThread::clear_ext_suspended() {\n-  clear_suspend_flag(_ext_suspended);\n-}\n-\n-inline void JavaThread::set_external_suspend() {\n-  set_suspend_flag(_external_suspend);\n-}\n-inline void JavaThread::clear_external_suspend() {\n-  clear_suspend_flag(_external_suspend);\n-}\n-\n@@ -185,1 +171,6 @@\n-inline void JavaThread::set_terminated(TerminatedTypes t) {\n+inline void JavaThread::set_exiting() {\n+  \/\/ use release-store so the setting of _terminated is seen more quickly\n+  Atomic::release_store((volatile jint *) &_terminated, (jint) _thread_exiting);\n+}\n+\n+inline void JavaThread::set_vm_exited() {\n@@ -187,1 +178,1 @@\n-  Atomic::release_store((volatile jint *) &_terminated, (jint) t);\n+  Atomic::release_store((volatile jint *) &_terminated, (jint) _vm_exited);\n@@ -191,1 +182,1 @@\n-inline void JavaThread::set_terminated_value() {\n+inline void JavaThread::set_terminated() {\n","filename":"src\/hotspot\/share\/runtime\/thread.inline.hpp","additions":8,"deletions":17,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -358,1 +358,1 @@\n-      thr->set_terminated(JavaThread::_vm_exited);  \/\/ per-thread flag\n+      thr->set_vm_exited();  \/\/ per-thread flag\n","filename":"src\/hotspot\/share\/runtime\/vmOperations.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -763,0 +763,4 @@\n+  \/*********************************\/                                                                                                \\\n+  \/* JavaThread (NOTE: incomplete) *\/                                                                                                \\\n+  \/*********************************\/                                                                                                \\\n+                                                                                                                                     \\\n@@ -2146,2 +2150,0 @@\n-  declare_constant(Thread::_external_suspend)                             \\\n-  declare_constant(Thread::_ext_suspended)                                \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -313,1 +313,1 @@\n-  if (snapshot->is_ext_suspended()) {\n+  if (snapshot->is_suspended()) {\n","filename":"src\/hotspot\/share\/services\/management.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -881,1 +881,1 @@\n-  _is_ext_suspended = thread->is_being_ext_suspended();\n+  _is_suspended = thread->is_suspended();\n","filename":"src\/hotspot\/share\/services\/threadService.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -199,1 +199,1 @@\n-  bool    _is_ext_suspended;\n+  bool    _is_suspended;\n@@ -232,1 +232,1 @@\n-  bool        is_ext_suspended()          { return _is_ext_suspended; }\n+  bool        is_suspended()              { return _is_suspended; }\n","filename":"src\/hotspot\/share\/services\/threadService.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,2 +38,0 @@\n-  private static int EXTERNAL_SUSPEND;\n-  private static int EXT_SUSPENDED;\n@@ -60,2 +58,0 @@\n-    EXTERNAL_SUSPEND = db.lookupIntConstant(\"Thread::_external_suspend\").intValue();\n-    EXT_SUSPENDED = db.lookupIntConstant(\"Thread::_ext_suspended\").intValue();\n@@ -79,17 +75,0 @@\n-  public boolean isExternalSuspend() {\n-    return (suspendFlags() & EXTERNAL_SUSPEND) != 0;\n-  }\n-\n-  public boolean isExtSuspended() {\n-    return (suspendFlags() & EXT_SUSPENDED) != 0;\n-  }\n-\n-  public boolean isBeingExtSuspended() {\n-    return isExtSuspended() || isExternalSuspend();\n-  }\n-\n-  \/\/ historical usage: checked for VM or external suspension\n-  public boolean isAnySuspended() {\n-    return isExtSuspended();\n-  }\n-\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/Thread.java","additions":1,"deletions":22,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -106,3 +106,0 @@\n-    {\n-      MutexLocker ml(SR_lock(), Mutex::_no_safepoint_check_flag);\n-    }\n","filename":"test\/hotspot\/gtest\/threadHelper.inline.hpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -132,2 +132,2 @@\n-            if (!checkSuspendedStatus()) {\n-                throw new RuntimeException(\"Main: FAILED status returned from checkTestedThreadsSuspended\");\n+            while (!checkSuspendedStatus()) {\n+                Thread.sleep(10);\n@@ -169,1 +169,0 @@\n-    private static native void init();\n@@ -190,4 +189,0 @@\n-\n-        if (isSuspender) {\n-            init();\n-        }\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/SuspendWithCurrentThread\/SuspendWithCurrentThread.java","additions":3,"deletions":8,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,0 @@\n-static jrawMonitorID agent_monitor = NULL;\n@@ -49,12 +48,0 @@\n-static void\n-agent_lock(JNIEnv* jni) {\n-  jvmtiError err = jvmti->RawMonitorEnter(agent_monitor);\n-  check_jvmti_status(jni, err, \"monitor_enter: error in JVMTI RawMonitorEnter\");\n-}\n-\n-static void\n-agent_unlock(JNIEnv* jni) {\n-  jvmtiError err = jvmti->RawMonitorExit(agent_monitor);\n-  check_jvmti_status(jni, err, \"monitor_exit: error in JVMTI RawMonitorExit\");\n-}\n-\n@@ -77,10 +64,0 @@\n-\/* This function is executed on the suspender thread, not the Main thread *\/\n-JNIEXPORT void JNICALL\n-Java_ThreadToSuspend_init(JNIEnv *jni, jclass cls) {\n-  jvmtiError err = jvmti->CreateRawMonitor(\"Agent monitor\", &agent_monitor);\n-  check_jvmti_status(jni, err, \"Java_ThreadToSuspend_init: error in JVMTI CreateRawMonitor\");\n-\n-  \/\/ Main thread has to wait for the suspender thread to complete tested threads suspension\n-  agent_lock(jni);\n-}\n-\n@@ -109,3 +86,0 @@\n-  \/\/ Allow the Main thread to inspect the result of tested threads suspension\n-  agent_unlock(jni);\n-\n@@ -120,4 +94,0 @@\n-  \/\/ Block until the suspender thread competes the tested threads suspension\n-  agent_lock(jni);\n-  agent_unlock(jni);\n-\n@@ -132,1 +102,1 @@\n-      jni->FatalError(\"checkTestedThreadsSuspended: error: expected all tested threads suspended\");\n+      return JNI_FALSE;\n@@ -170,2 +140,0 @@\n-  err = jvmti->DestroyRawMonitor(agent_monitor);\n-  check_jvmti_status(jni, err, \"releaseTestedThreadsInfo: error in JVMTI DestroyRawMonitor\");\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/SuspendWithCurrentThread\/libSuspendWithCurrentThread.cpp","additions":2,"deletions":34,"binary":false,"changes":36,"status":"modified"}]}