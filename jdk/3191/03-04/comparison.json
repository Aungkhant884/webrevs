{"files":[{"patch":"@@ -463,0 +463,4 @@\n+    \/\/ Handshakes cannot safely safepoint.\n+    \/\/ The exception to this rule is the asynchronous suspension handshake.\n+    \/\/ It by-passes the NSV by manully doing the transition.\n+    \/\/ Since we can have safepoints while suspeneded we need to release the tty locker if it is held.\n@@ -609,24 +613,1 @@\n-\/\/ The careful dance between thread suspension and exit is handled here.\n-\/\/ The caller has notified the agents that we are exiting, before we go\n-\/\/ on, we must check for a pending external suspend request and honor it\n-\/\/ in order to not surprise the thread that made the suspend request.\n-void HandshakeState::thread_exit() {\n-  guarantee(JavaThread::current() == _handshakee, \"Must be\");\n-  while (true) {\n-    {\n-      MutexLocker ml(&_lock, Mutex::_no_safepoint_check_flag);\n-      \/\/ If we have any safepoint or handshake pending deal with it else set exit.\n-      if (!SafepointMechanism::should_process(_handshakee)) {\n-        _handshakee->set_exiting();\n-        return;\n-      }\n-    }\n-    ThreadBlockInVM tbivm(_handshakee);\n-    \/\/ We're done with this suspend request, but we have to loop around\n-    \/\/ and check again. Eventually we will get the lock without a pending\n-    \/\/ external suspend request and will be able to mark ourselves as\n-    \/\/ exiting.\n-  }\n-}\n-\n-void HandshakeState::self_suspened() {\n+void HandshakeState::do_self_suspend() {\n@@ -654,1 +635,1 @@\n-    target->handshake_state()->self_suspened();\n+    target->handshake_state()->do_self_suspend();\n","filename":"src\/hotspot\/share\/runtime\/handshake.cpp","additions":6,"deletions":25,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -128,0 +128,7 @@\n+    \/\/ When doing thread suspension the holder of the _lock\n+    \/\/ can add an asynchronous handshake to queue.\n+    \/\/ To make sure it is seen by the handshakee, the handshakee must first\n+    \/\/ check the _lock, if held go to slow path.\n+    \/\/ Since the handshakee is unsafe if _lock gets lock after this check\n+    \/\/ we know another threads cannot process any handshakes.\n+    \/\/ Now we can check queue if there is anything we should process.\n@@ -131,0 +138,1 @@\n+    \/\/ Lock check must be done before queue check, force ordering.\n@@ -156,2 +164,2 @@\n-  \/\/ thread thread gets suspended again (after a resume)\n-  \/\/ and have not yet processed it.\n+  \/\/ thread gets suspended again (after a resume)\n+  \/\/ and we have not yet processed it.\n@@ -164,1 +172,1 @@\n-  void self_suspened();\n+  void do_self_suspend();\n@@ -173,1 +181,0 @@\n-  void thread_exit();\n","filename":"src\/hotspot\/share\/runtime\/handshake.hpp","additions":11,"deletions":4,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -410,0 +410,2 @@\n+    \/\/ Thread must be walkable before it is blocked.\n+    \/\/ Read in reverse order.\n@@ -977,1 +979,1 @@\n-            OrderAccess::fence();\n+            OrderAccess::fence(); \/\/ always do a full fence when successor is cleared\n@@ -1540,0 +1542,2 @@\n+      \/\/ Thread must be walkable before it is blocked.\n+      \/\/ Read in reverse order.\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1446,3 +1446,4 @@\n-    \/\/ The careful dance between thread suspension and exit is handled here:\n-    _handshake.thread_exit();\n-    ThreadService::current_thread_exiting(this, is_daemon(threadObj()));\n+    \/\/ The careful dance between thread suspension and exit is handled here.\n+    \/\/ Since we are in vm and suspension is done with handshakes,\n+    \/\/ we can just put in the exiting state and it will be corrcetly handled.\n+    set_exiting();\n@@ -1450,0 +1451,1 @@\n+    ThreadService::current_thread_exiting(this, is_daemon(threadObj()));\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"}]}