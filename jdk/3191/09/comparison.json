{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -443,4 +443,0 @@\n-  thread->set_suspend_equivalent();\n-  \/\/ cleared by handle_special_suspend_equivalent_condition() or\n-  \/\/ java_suspend_self() via check_and_wait_while_suspended()\n-\n@@ -462,3 +458,0 @@\n-  \/\/ were we externally suspended while we were waiting?\n-  thread->check_and_wait_while_suspended();\n-\n@@ -475,4 +468,0 @@\n-  thread->set_suspend_equivalent();\n-  \/\/ cleared by handle_special_suspend_equivalent_condition() or\n-  \/\/ java_suspend_self() via check_and_wait_while_suspended()\n-\n@@ -481,3 +470,0 @@\n-  \/\/ were we externally suspended while we were waiting?\n-  thread->check_and_wait_while_suspended();\n-\n@@ -514,4 +500,0 @@\n-  thread->set_suspend_equivalent();\n-  \/\/ cleared by handle_special_suspend_equivalent_condition() or\n-  \/\/ java_suspend_self() via check_and_wait_while_suspended()\n-\n@@ -520,3 +502,0 @@\n-  \/\/ were we externally suspended while we were waiting?\n-  thread->check_and_wait_while_suspended();\n-\n","filename":"src\/hotspot\/os\/aix\/attachListener_aix.cpp","additions":1,"deletions":22,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -412,4 +412,0 @@\n-  thread->set_suspend_equivalent();\n-  \/\/ cleared by handle_special_suspend_equivalent_condition() or\n-  \/\/ java_suspend_self() via check_and_wait_while_suspended()\n-\n@@ -430,3 +426,0 @@\n-  \/\/ were we externally suspended while we were waiting?\n-  thread->check_and_wait_while_suspended();\n-\n@@ -443,4 +436,0 @@\n-  thread->set_suspend_equivalent();\n-  \/\/ cleared by handle_special_suspend_equivalent_condition() or\n-  \/\/ java_suspend_self() via check_and_wait_while_suspended()\n-\n@@ -449,3 +438,0 @@\n-  \/\/ were we externally suspended while we were waiting?\n-  thread->check_and_wait_while_suspended();\n-\n@@ -482,4 +468,0 @@\n-  thread->set_suspend_equivalent();\n-  \/\/ cleared by handle_special_suspend_equivalent_condition() or\n-  \/\/ java_suspend_self() via check_and_wait_while_suspended()\n-\n@@ -488,3 +470,0 @@\n-  \/\/ were we externally suspended while we were waiting?\n-  thread->check_and_wait_while_suspended();\n-\n","filename":"src\/hotspot\/os\/bsd\/attachListener_bsd.cpp","additions":1,"deletions":22,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -412,4 +412,0 @@\n-  thread->set_suspend_equivalent();\n-  \/\/ cleared by handle_special_suspend_equivalent_condition() or\n-  \/\/ java_suspend_self() via check_and_wait_while_suspended()\n-\n@@ -430,3 +426,0 @@\n-  \/\/ were we externally suspended while we were waiting?\n-  thread->check_and_wait_while_suspended();\n-\n@@ -443,4 +436,0 @@\n-  thread->set_suspend_equivalent();\n-  \/\/ cleared by handle_special_suspend_equivalent_condition() or\n-  \/\/ java_suspend_self() via check_and_wait_while_suspended()\n-\n@@ -449,3 +438,0 @@\n-  \/\/ were we externally suspended while we were waiting?\n-  thread->check_and_wait_while_suspended();\n-\n@@ -482,4 +468,0 @@\n-  thread->set_suspend_equivalent();\n-  \/\/ cleared by handle_special_suspend_equivalent_condition() or\n-  \/\/ java_suspend_self() via check_and_wait_while_suspended()\n-\n@@ -488,3 +470,0 @@\n-  \/\/ were we externally suspended while we were waiting?\n-  thread->check_and_wait_while_suspended();\n-\n","filename":"src\/hotspot\/os\/linux\/attachListener_linux.cpp","additions":1,"deletions":22,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -1607,2 +1607,0 @@\n-  jt->set_suspend_equivalent();\n-  \/\/ cleared by handle_special_suspend_equivalent_condition() or java_suspend_self()\n@@ -1631,5 +1629,0 @@\n-\n-  \/\/ If externally suspended while waiting, re-suspend\n-  if (jt->handle_special_suspend_equivalent_condition()) {\n-    jt->java_suspend_self();\n-  }\n","filename":"src\/hotspot\/os\/posix\/os_posix.cpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"runtime\/semaphore.inline.hpp\"\n@@ -372,21 +373,1 @@\n-    JavaThread *thread = JavaThread::current();\n-    ThreadBlockInVM tbivm(thread);\n-\n-    bool threadIsSuspended;\n-    do {\n-      thread->set_suspend_equivalent();\n-      \/\/ cleared by handle_special_suspend_equivalent_condition() or java_suspend_self()\n-      sig_semaphore->wait();\n-\n-      \/\/ were we externally suspended while we were waiting?\n-      threadIsSuspended = thread->handle_special_suspend_equivalent_condition();\n-      if (threadIsSuspended) {\n-        \/\/ The semaphore has been incremented, but while we were waiting\n-        \/\/ another thread suspended us. We don't want to continue running\n-        \/\/ while suspended because that would surprise the thread that\n-        \/\/ suspended us.\n-        sig_semaphore->signal();\n-\n-        thread->java_suspend_self();\n-      }\n-    } while (threadIsSuspended);\n+    sig_semaphore->wait_with_safepoint_check(JavaThread::current());\n@@ -1558,4 +1539,0 @@\n-\/\/  Note that the SR_lock plays no role in this suspend\/resume protocol,\n-\/\/  but is checked for NULL in SR_handler as a thread termination indicator.\n-\/\/  The SR_lock is, however, used by JavaThread::java_suspend()\/java_resume() APIs.\n-\/\/\n@@ -1606,1 +1583,1 @@\n-  \/\/ has not already terminated (via SR_lock()) - else the following assertion\n+  \/\/ has not already terminated - else the following assertion\n@@ -1610,1 +1587,1 @@\n-  if (thread->SR_lock() == NULL) {\n+  if (thread->has_terminated()) {\n","filename":"src\/hotspot\/os\/posix\/signals_posix.cpp","additions":4,"deletions":27,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -313,4 +313,0 @@\n-  thread->set_suspend_equivalent();\n-  \/\/ cleared by handle_special_suspend_equivalent_condition() or\n-  \/\/ java_suspend_self() via check_and_wait_while_suspended()\n-\n@@ -354,3 +350,0 @@\n-\n-  \/\/ were we externally suspended while we were waiting?\n-  thread->check_and_wait_while_suspended();\n@@ -366,4 +359,0 @@\n-  thread->set_suspend_equivalent();\n-  \/\/ cleared by handle_special_suspend_equivalent_condition() or\n-  \/\/ java_suspend_self() via check_and_wait_while_suspended()\n-\n@@ -372,3 +361,0 @@\n-  \/\/ were we externally suspended while we were waiting?\n-  thread->check_and_wait_while_suspended();\n-\n","filename":"src\/hotspot\/os\/windows\/attachListener_windows.cpp","additions":1,"deletions":15,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2210,22 +2210,1 @@\n-    JavaThread *thread = JavaThread::current();\n-\n-    ThreadBlockInVM tbivm(thread);\n-\n-    bool threadIsSuspended;\n-    do {\n-      thread->set_suspend_equivalent();\n-      \/\/ cleared by handle_special_suspend_equivalent_condition() or java_suspend_self()\n-      sig_sem->wait();\n-\n-      \/\/ were we externally suspended while we were waiting?\n-      threadIsSuspended = thread->handle_special_suspend_equivalent_condition();\n-      if (threadIsSuspended) {\n-        \/\/ The semaphore has been incremented, but while we were waiting\n-        \/\/ another thread suspended us. We don't want to continue running\n-        \/\/ while suspended because that would surprise the thread that\n-        \/\/ suspended us.\n-        sig_sem->signal();\n-\n-        thread->java_suspend_self();\n-      }\n-    } while (threadIsSuspended);\n+    sig_sem->wait_with_safepoint_check(JavaThread::current());\n@@ -5478,1 +5457,0 @@\n-    thread->set_suspend_equivalent();\n@@ -5482,5 +5460,0 @@\n-\n-    \/\/ If externally suspended while waiting, re-suspend\n-    if (thread->handle_special_suspend_equivalent_condition()) {\n-      thread->java_suspend_self();\n-    }\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":1,"deletions":28,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -176,0 +176,1 @@\n+  LOG_TAG(suspend) \\\n","filename":"src\/hotspot\/share\/logging\/logTag.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2983,16 +2983,2 @@\n-    \/\/ jthread refers to a live JavaThread.\n-    {\n-      MutexLocker ml(receiver->SR_lock(), Mutex::_no_safepoint_check_flag);\n-      if (receiver->is_external_suspend()) {\n-        \/\/ Don't allow nested external suspend requests. We can't return\n-        \/\/ an error from this interface so just ignore the problem.\n-        return;\n-      }\n-      if (receiver->is_exiting()) { \/\/ thread is in the process of exiting\n-        return;\n-      }\n-      receiver->set_external_suspend();\n-    }\n-\n-    \/\/ java_suspend() will catch threads in the process of exiting\n-    \/\/ and will ignore them.\n+    \/\/ jthread refers to a live JavaThread, but java_suspend() will\n+    \/\/ detect a thread that has started to exit and will ignore it.\n@@ -3000,9 +2986,0 @@\n-\n-    \/\/ It would be nice to have the following assertion in all the\n-    \/\/ time, but it is possible for a racing resume request to have\n-    \/\/ resumed this thread right after we suspended it. Temporarily\n-    \/\/ enable this assertion if you are chasing a different kind of\n-    \/\/ bug.\n-    \/\/\n-    \/\/ assert(java_lang_Thread::thread(receiver->threadObj()) == NULL ||\n-    \/\/   receiver->is_being_ext_suspended(), \"thread is not suspended\");\n@@ -3019,16 +2996,0 @@\n-\n-    \/\/ This is the original comment for this Threads_lock grab:\n-    \/\/   We need to *always* get the threads lock here, since this operation cannot be allowed during\n-    \/\/   a safepoint. The safepoint code relies on suspending a thread to examine its state. If other\n-    \/\/   threads randomly resumes threads, then a thread might not be suspended when the safepoint code\n-    \/\/   looks at it.\n-    \/\/\n-    \/\/ The above comment dates back to when we had both internal and\n-    \/\/ external suspend APIs that shared a common underlying mechanism.\n-    \/\/ External suspend is now entirely cooperative and doesn't share\n-    \/\/ anything with internal suspend. That said, there are some\n-    \/\/ assumptions in the VM that an external resume grabs the\n-    \/\/ Threads_lock. We can't drop the Threads_lock grab here until we\n-    \/\/ resolve the assumptions that exist elsewhere.\n-    \/\/\n-    MutexLocker ml(Threads_lock);\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":2,"deletions":41,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -879,1 +879,1 @@\n-    if (java_thread->is_being_ext_suspended()) {\n+    if (java_thread->is_suspended()) {\n@@ -945,1 +945,1 @@\n-    return (JVMTI_ERROR_NONE);\n+    return JVMTI_ERROR_NONE;\n@@ -947,11 +947,2 @@\n-\n-  {\n-    MutexLocker ml(java_thread->SR_lock(), Mutex::_no_safepoint_check_flag);\n-    if (java_thread->is_external_suspend()) {\n-      \/\/ don't allow nested external suspend requests.\n-      return (JVMTI_ERROR_THREAD_SUSPENDED);\n-    }\n-    if (java_thread->is_exiting()) { \/\/ thread is in the process of exiting\n-      return (JVMTI_ERROR_THREAD_NOT_ALIVE);\n-    }\n-    java_thread->set_external_suspend();\n+  if (java_thread->is_suspended()) {\n+    return JVMTI_ERROR_THREAD_SUSPENDED;\n@@ -959,1 +950,0 @@\n-\n@@ -961,2 +951,6 @@\n-    \/\/ the thread was in the process of exiting\n-    return (JVMTI_ERROR_THREAD_NOT_ALIVE);\n+    \/\/ Either the thread is already suspended or\n+    \/\/ it was in the process of exiting.\n+    if (java_thread->is_exiting()) {\n+      return JVMTI_ERROR_THREAD_NOT_ALIVE;\n+    }\n+    return JVMTI_ERROR_THREAD_SUSPENDED;\n@@ -973,0 +967,1 @@\n+  int self_index = -1;\n@@ -974,1 +969,2 @@\n-  ThreadsListHandle tlh;\n+  JavaThread* current = JavaThread::current();\n+  ThreadsListHandle tlh(current);\n@@ -987,13 +983,3 @@\n-\n-    {\n-      MutexLocker ml(java_thread->SR_lock(), Mutex::_no_safepoint_check_flag);\n-      if (java_thread->is_external_suspend()) {\n-        \/\/ don't allow nested external suspend requests.\n-        results[i] = JVMTI_ERROR_THREAD_SUSPENDED;\n-        continue;\n-      }\n-      if (java_thread->is_exiting()) { \/\/ thread is in the process of exiting\n-        results[i] = JVMTI_ERROR_THREAD_NOT_ALIVE;\n-        continue;\n-      }\n-      java_thread->set_external_suspend();\n+    if (java_thread->is_suspended()) {\n+      results[i] = JVMTI_ERROR_THREAD_SUSPENDED;\n+      continue;\n@@ -1001,7 +987,8 @@\n-    if (java_thread->thread_state() == _thread_in_native) {\n-      \/\/ We need to try and suspend native threads here. Threads in\n-      \/\/ other states will self-suspend on their next transition.\n-      if (!JvmtiSuspendControl::suspend(java_thread)) {\n-        \/\/ The thread was in the process of exiting. Force another\n-        \/\/ safepoint to make sure that this thread transitions.\n-        needSafepoint++;\n+    if (java_thread == current) {\n+      self_index = i;\n+      continue;\n+    }\n+    if (!JvmtiSuspendControl::suspend(java_thread)) {\n+      \/\/ Either the thread is already suspended or\n+      \/\/ it was in the process of exiting.\n+      if (java_thread->is_exiting()) {\n@@ -1011,2 +998,2 @@\n-    } else {\n-      needSafepoint++;\n+      results[i] = JVMTI_ERROR_THREAD_SUSPENDED;\n+      continue;\n@@ -1016,3 +1003,12 @@\n-  if (needSafepoint > 0) {\n-    VM_ThreadsSuspendJVMTI tsj;\n-    VMThread::execute(&tsj);\n+  if (self_index >= 0) {\n+    if (!JvmtiSuspendControl::suspend(current)) {\n+      \/\/ Either the thread is already suspended or\n+      \/\/ it was in the process of exiting.\n+      if (current->is_exiting()) {\n+        results[self_index] = JVMTI_ERROR_THREAD_NOT_ALIVE;\n+      } else {\n+        results[self_index] = JVMTI_ERROR_THREAD_SUSPENDED;\n+      }\n+    } else {\n+      results[self_index] = JVMTI_ERROR_NONE;  \/\/ indicate successful suspend\n+    }\n@@ -1033,2 +1029,1 @@\n-\n-  if (!java_thread->is_being_ext_suspended()) {\n+  if (!java_thread->is_suspended()) {\n@@ -1037,1 +1032,0 @@\n-\n@@ -1063,1 +1057,1 @@\n-    if (!java_thread->is_being_ext_suspended()) {\n+    if (!java_thread->is_suspended()) {\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnv.cpp","additions":40,"deletions":46,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -1184,2 +1184,1 @@\n-    \/\/ same as is_being_ext_suspended() but without locking\n-    if (thr->is_ext_suspended() || thr->is_external_suspend()) {\n+    if (thr->is_suspended()) {\n@@ -1403,1 +1402,1 @@\n-    if (!java_thread->is_external_suspend()) {\n+    if (!java_thread->is_suspended()) {\n@@ -1536,1 +1535,1 @@\n-  if (!self && !java_thread->is_external_suspend()) {\n+  if (!self && !java_thread->is_suspended()) {\n@@ -1627,1 +1626,1 @@\n-  if (!self && !java_thread->is_external_suspend()) {\n+  if (!self && !java_thread->is_suspended()) {\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.cpp","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -768,24 +768,1 @@\n-  \/\/ external suspend should have caught suspending a thread twice\n-\n-  \/\/ Immediate suspension required for JPDA back-end so JVMTI agent threads do\n-  \/\/ not deadlock due to later suspension on transitions while holding\n-  \/\/ raw monitors.  Passing true causes the immediate suspension.\n-  \/\/ java_suspend() will catch threads in the process of exiting\n-  \/\/ and will ignore them.\n-  java_thread->java_suspend();\n-\n-  \/\/ It would be nice to have the following assertion in all the time,\n-  \/\/ but it is possible for a racing resume request to have resumed\n-  \/\/ this thread right after we suspended it. Temporarily enable this\n-  \/\/ assertion if you are chasing a different kind of bug.\n-  \/\/\n-  \/\/ assert(java_lang_Thread::thread(java_thread->threadObj()) == NULL ||\n-  \/\/   java_thread->is_being_ext_suspended(), \"thread is not suspended\");\n-\n-  if (java_lang_Thread::thread(java_thread->threadObj()) == NULL) {\n-    \/\/ check again because we can get delayed in java_suspend():\n-    \/\/ the thread is in process of exiting.\n-    return false;\n-  }\n-\n-  return true;\n+  return java_thread->java_suspend();\n@@ -795,11 +772,1 @@\n-  \/\/ external suspend should have caught resuming a thread twice\n-  assert(java_thread->is_being_ext_suspended(), \"thread should be suspended\");\n-\n-  \/\/ resume thread\n-  {\n-    \/\/ must always grab Threads_lock, see JVM_SuspendThread\n-    MutexLocker ml(Threads_lock);\n-    java_thread->java_resume();\n-  }\n-\n-  return true;\n+  return java_thread->java_resume();\n@@ -808,1 +775,0 @@\n-\n@@ -820,1 +786,1 @@\n-    log_stream.print(\"%s(%c \", name, thread->is_being_ext_suspended() ? 'S' : '_');\n+    log_stream.print(\"%s(%c \", name, thread->is_suspended() ? 'S' : '_');\n","filename":"src\/hotspot\/share\/prims\/jvmtiImpl.cpp","additions":3,"deletions":37,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -244,1 +244,0 @@\n-      jt->set_suspend_equivalent();\n@@ -310,1 +309,2 @@\n-\/\/ Any JavaThread will enter here with state _thread_blocked\n+\/\/ Any JavaThread will enter here with state _thread_blocked unless we\n+\/\/ are in single-threaded mode during startup.\n@@ -318,5 +318,21 @@\n-    jt->SR_lock()->lock_without_safepoint_check();\n-    while (jt->is_external_suspend()) {\n-      jt->SR_lock()->unlock();\n-      jt->java_suspend_self();\n-      jt->SR_lock()->lock_without_safepoint_check();\n+    while (true) {\n+      \/\/ To pause suspend requests while in blocked we must block handshakes.\n+      jt->handshake_state()->lock();\n+      \/\/ Suspend request flag can only be set in handshakes.\n+      \/\/ By blocking handshakes, suspend request flag cannot change its value.\n+      if (!jt->handshake_state()->is_suspended()) {\n+        contended = Atomic::cmpxchg(&_owner, (Thread*)NULL, jt);\n+        jt->handshake_state()->unlock();\n+        break;\n+      }\n+      jt->handshake_state()->unlock();\n+\n+      \/\/ We may only be in states other than _thread_blocked when we are\n+      \/\/ in single-threaded mode during startup.\n+      guarantee(jt->thread_state() == _thread_blocked, \"invariant\");\n+\n+      jt->set_thread_state_fence(_thread_blocked_trans);\n+      SafepointMechanism::process_if_requested(jt);\n+      \/\/ We should transition to thread_in_vm and then to thread_in_vm_trans,\n+      \/\/ but those are always treated the same as _thread_blocked_trans.\n+      jt->set_thread_state(_thread_blocked);\n@@ -324,3 +340,0 @@\n-    \/\/ guarded by SR_lock to avoid racing with new external suspend requests.\n-    contended = Atomic::cmpxchg(&_owner, (Thread*)NULL, jt);\n-    jt->SR_lock()->unlock();\n@@ -347,0 +360,1 @@\n+    \/\/ In multi-threaded mode, we must enter this method blocked.\n@@ -349,3 +363,0 @@\n-      jt->set_suspend_equivalent();\n-      \/\/ cleared by handle_special_suspend_equivalent_condition() or\n-      \/\/ java_suspend_self()\n@@ -353,3 +364,6 @@\n-\n-      \/\/ were we externally suspended while we were waiting?\n-      if (!jt->handle_special_suspend_equivalent_condition()) {\n+      if (!SafepointMechanism::should_process(jt)) {\n+        \/\/ Not suspended so we're done here.\n+        break;\n+      }\n+      if (!jt->is_suspended()) {\n+        \/\/ Not suspended so we're done here.\n@@ -358,8 +372,0 @@\n-\n-      \/\/ This thread was externally suspended\n-      \/\/ We have reentered the contended monitor, but while we were\n-      \/\/ waiting another thread suspended us. We don't want to reenter\n-      \/\/ the monitor while suspended because that would surprise the\n-      \/\/ thread that suspended us.\n-      \/\/\n-      \/\/ Drop the lock\n@@ -367,2 +373,5 @@\n-\n-      jt->java_suspend_self();\n+      jt->set_thread_state_fence(_thread_blocked_trans);\n+      SafepointMechanism::process_if_requested(jt);\n+      \/\/ We should transition to thread_in_vm and then to thread_in_vm_trans,\n+      \/\/ but those are always treated the same as _thread_blocked_trans.\n+      jt->set_thread_state(_thread_blocked);\n@@ -414,0 +423,1 @@\n+    guarantee(jt->thread_state() == _thread_in_native, \"invariant\");\n@@ -415,2 +425,2 @@\n-      jt->set_suspend_equivalent();\n-      if (!jt->handle_special_suspend_equivalent_condition()) {\n+      if (!SafepointMechanism::should_process(jt)) {\n+        \/\/ Not suspended so we're done here:\n@@ -418,18 +428,0 @@\n-      } else {\n-        \/\/ We've been suspended whilst waiting and so we have to\n-        \/\/ relinquish the raw monitor until we are resumed. Of course\n-        \/\/ after reacquiring we have to re-check for suspension again.\n-        \/\/ Suspension requires we are _thread_blocked, and we also have to\n-        \/\/ recheck for being interrupted.\n-        simple_exit(jt);\n-        {\n-          ThreadInVMfromNative tivm(jt);\n-          {\n-            ThreadBlockInVM tbivm(jt);\n-            jt->java_suspend_self();\n-          }\n-          if (jt->is_interrupted(true)) {\n-            ret = M_INTERRUPTED;\n-          }\n-        }\n-        simple_enter(jt);\n@@ -437,0 +429,10 @@\n+      simple_exit(jt);\n+      jt->set_thread_state_fence(_thread_in_native_trans);\n+      SafepointMechanism::process_if_requested(jt);\n+      if (jt->is_interrupted(true)) {\n+        ret = M_INTERRUPTED;\n+      }\n+      \/\/ We should transition to thread_in_vm and then to thread_in_vm_trans,\n+      \/\/ but those are always treated the same as _thread_in_native_trans.\n+      jt->set_thread_state(_thread_in_native);\n+      simple_enter(jt);\n","filename":"src\/hotspot\/share\/prims\/jvmtiRawMonitor.cpp","additions":49,"deletions":47,"binary":false,"changes":96,"status":"modified"},{"patch":"@@ -297,5 +297,0 @@\n-bool JvmtiThreadState::may_be_walked() {\n-  return (get_thread()->is_being_ext_suspended() || (JavaThread::current() == get_thread()));\n-}\n-\n-\n","filename":"src\/hotspot\/share\/prims\/jvmtiThreadState.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -315,2 +315,0 @@\n-  bool may_be_walked();\n-\n","filename":"src\/hotspot\/share\/prims\/jvmtiThreadState.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -524,0 +524,2 @@\n+  { \"SuspendRetryCount\",            JDK_Version::undefined(), JDK_Version::jdk(17), JDK_Version::jdk(18) },\n+  { \"SuspendRetryDelay\",            JDK_Version::undefined(), JDK_Version::jdk(17), JDK_Version::jdk(18) },\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -427,10 +427,0 @@\n-          range(0, max_intx)                                                \\\n-                                                                            \\\n-  \/* 50 retries * (5 * current_retry_count) millis = ~6.375 seconds *\/      \\\n-  \/* typically, at most a few retries are needed                    *\/      \\\n-  product(intx, SuspendRetryCount, 50,                                      \\\n-          \"Maximum retry count for an external suspend request\")            \\\n-          range(0, max_intx)                                                \\\n-                                                                            \\\n-  product(intx, SuspendRetryDelay, 5,                                       \\\n-          \"Milliseconds to delay per retry (* current_retry_count)\")        \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -408,1 +408,3 @@\n-  _active_handshaker()\n+  _active_handshaker(),\n+  _suspended(false),\n+  _async_suspend_handshake(false)\n@@ -414,2 +416,0 @@\n-  \/\/ Calling this method with lock held is considered an error.\n-  assert(!_lock.owned_by_self(), \"Lock should not be held\");\n@@ -456,1 +456,1 @@\n-void HandshakeState::process_by_self() {\n+bool HandshakeState::process_by_self() {\n@@ -463,0 +463,5 @@\n+    \/\/ Handshakes cannot safely safepoint.\n+    \/\/ The exception to this rule is the asynchronous suspension handshake.\n+    \/\/ It by-passes the NSV by manually doing the transition.\n+    \/\/ Since we can have safepoints while suspended we need to release the tty locker if it is held.\n+    ttyLocker::break_tty_lock_for_safepoint(os::current_thread_id());\n@@ -464,1 +469,1 @@\n-    process_self_inner();\n+    return process_self_inner();\n@@ -468,1 +473,1 @@\n-void HandshakeState::process_self_inner() {\n+bool HandshakeState::process_self_inner() {\n@@ -470,2 +475,0 @@\n-    HandleMark hm(_handshakee);\n-    PreserveExceptionMark pem(_handshakee);\n@@ -480,2 +483,9 @@\n-      op->do_handshake(_handshakee);\n-      if (async) {\n+      if (!async) {\n+        HandleMark hm(_handshakee);\n+        PreserveExceptionMark pem(_handshakee);\n+        op->do_handshake(_handshakee);\n+      } else {\n+        \/\/ An asynchronous handshake may put the JavaThread in blocked state (safepoint safe).\n+        \/\/ The destructor ~PreserveExceptionMark touches the exception oop so it must not be executed,\n+        \/\/ since a safepoint may be in-progress when returning from the async handshake.\n+        op->do_handshake(_handshakee);\n@@ -484,0 +494,1 @@\n+        return true; \/\/ Must check for safepoints\n@@ -485,0 +496,2 @@\n+    } else {\n+      return false;\n@@ -487,0 +500,1 @@\n+  return false;\n@@ -590,0 +604,98 @@\n+\n+void HandshakeState::lock() {\n+  _lock.lock_without_safepoint_check();\n+}\n+\n+void HandshakeState::unlock() {\n+  _lock.unlock();\n+}\n+\n+void HandshakeState::do_self_suspend() {\n+  assert(Thread::current() == _handshakee, \"should call from _handshakee\");\n+  assert(_lock.owned_by_self(), \"Lock must be held\");\n+  assert(!_handshakee->has_last_Java_frame() || _handshakee->frame_anchor()->walkable(), \"should have walkable stack\");\n+  JavaThreadState jts = _handshakee->thread_state();\n+  while (is_suspended()) {\n+    _handshakee->set_thread_state(_thread_blocked);\n+    log_trace(thread, suspend)(\"JavaThread:\" INTPTR_FORMAT \" suspended\", p2i(_handshakee));\n+    _lock.wait_without_safepoint_check();\n+  }\n+  _handshakee->set_thread_state(jts);\n+  set_async_suspend_handshake(false);\n+  log_trace(thread, suspend)(\"JavaThread:\" INTPTR_FORMAT \" resumed\", p2i(_handshakee));\n+}\n+\n+\/\/ This is the closure that prevents a suspended JavaThread from\n+\/\/ escaping the suspend request.\n+class ThreadSuspensionHandshake : public AsyncHandshakeClosure {\n+ public:\n+  ThreadSuspensionHandshake() : AsyncHandshakeClosure(\"ThreadSuspension\") {}\n+  void do_thread(Thread* thr) {\n+    JavaThread* target = thr->as_Java_thread();\n+    target->handshake_state()->do_self_suspend();\n+  }\n+};\n+\n+bool HandshakeState::suspend_with_handshake() {\n+  if (_handshakee->is_exiting() ||\n+     _handshakee->threadObj() == NULL) {\n+    log_trace(thread, suspend)(\"JavaThread:\" INTPTR_FORMAT \" exiting\", p2i(_handshakee));\n+    return false;\n+  }\n+  if (has_async_suspend_handshake()) {\n+    if (is_suspended()) {\n+      \/\/ Target is already suspended.\n+      log_trace(thread, suspend)(\"JavaThread:\" INTPTR_FORMAT \" already suspended\", p2i(_handshakee));\n+      return false;\n+    } else {\n+      \/\/ Target is going to wake up and leave suspension.\n+      \/\/ Let's just stop the thread from doing that.\n+      log_trace(thread, suspend)(\"JavaThread:\" INTPTR_FORMAT \" re-suspended\", p2i(_handshakee));\n+      set_suspended(true);\n+      return true;\n+    }\n+  }\n+  \/\/ no suspend request\n+  assert(!is_suspended(), \"cannot be suspended without a suspend request\");\n+  \/\/ Thread is safe, so it must execute the request, thus we can count it as suspended\n+  \/\/ from this point.\n+  set_suspended(true);\n+  set_async_suspend_handshake(true);\n+  log_trace(thread, suspend)(\"JavaThread:\" INTPTR_FORMAT \" suspended, arming ThreadSuspension\", p2i(_handshakee));\n+  ThreadSuspensionHandshake* ts = new ThreadSuspensionHandshake();\n+  Handshake::execute(ts, _handshakee);\n+  return true;\n+}\n+\n+\/\/ This is the closure that synchronously honors the suspend request.\n+class SuspendThreadHandshake : public HandshakeClosure {\n+  bool _did_suspend;\n+public:\n+  SuspendThreadHandshake() : HandshakeClosure(\"SuspendThread\"), _did_suspend(false) {}\n+  void do_thread(Thread* thr) {\n+    JavaThread* target = thr->as_Java_thread();\n+    _did_suspend = target->handshake_state()->suspend_with_handshake();\n+  }\n+  bool did_suspend() { return _did_suspend; }\n+};\n+\n+bool HandshakeState::suspend() {\n+  SuspendThreadHandshake st;\n+  Handshake::execute(&st, _handshakee);\n+  return st.did_suspend();\n+}\n+\n+bool HandshakeState::resume() {\n+  if (!is_suspended()) {\n+    return false;\n+  }\n+  MutexLocker ml(&_lock, Mutex::_no_safepoint_check_flag);\n+  if (!is_suspended()) {\n+    assert(!_handshakee->is_suspended(), \"cannot be suspended without a suspend request\");\n+    return false;\n+  }\n+  \/\/ Resume the thread.\n+  set_suspended(false);\n+  _lock.notify();\n+  return true;\n+}\n","filename":"src\/hotspot\/share\/runtime\/handshake.cpp","additions":122,"deletions":10,"binary":false,"changes":132,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,2 @@\n+class SuspendThreadHandshake;\n+class ThreadSuspensionHandshake;\n@@ -46,3 +48,3 @@\n-  virtual ~HandshakeClosure() {}\n-  const char* name() const    { return _name; }\n-  virtual bool is_async()     { return false; }\n+  virtual ~HandshakeClosure()                      {}\n+  const char* name() const                         { return _name; }\n+  virtual bool is_async()                          { return false; }\n@@ -64,1 +66,1 @@\n-  static void execute(AsyncHandshakeClosure* hs_cl, JavaThread* target);\n+  static void execute(AsyncHandshakeClosure*  hs_cl, JavaThread* target);\n@@ -67,0 +69,2 @@\n+class JvmtiRawMonitor;\n+\n@@ -72,0 +76,4 @@\n+  friend JvmtiRawMonitor;\n+  friend ThreadSuspensionHandshake;\n+  friend SuspendThreadHandshake;\n+  friend JavaThread;\n@@ -77,2 +85,3 @@\n-  \/\/ Provides mutual exclusion to this state and queue.\n-  Mutex   _lock;\n+  \/\/ Provides mutual exclusion to this state and queue. Also used for\n+  \/\/ JavaThread suspend\/resume operations.\n+  Monitor _lock;\n@@ -85,1 +94,7 @@\n-  void process_self_inner();\n+\n+  \/\/ Returns false if the JavaThread finished all its handshake operations.\n+  \/\/ If the method returns true there is still potential work to be done,\n+  \/\/ but we need to check for a safepoint before.\n+  \/\/ (This is due to a suspension handshake which put the JavaThread in blocked\n+  \/\/ state so a safepoint may be in-progress.)\n+  bool process_self_inner();\n@@ -91,0 +106,3 @@\n+  void lock();\n+  void unlock();\n+\n@@ -110,1 +128,13 @@\n-    return !_queue.is_empty() || _lock.is_locked();\n+    \/\/ When doing thread suspension the holder of the _lock\n+    \/\/ can add an asynchronous handshake to queue.\n+    \/\/ To make sure it is seen by the handshakee, the handshakee must first\n+    \/\/ check the _lock, if held go to slow path.\n+    \/\/ Since the handshakee is unsafe if _lock gets locked after this check\n+    \/\/ we know another thread cannot process any handshakes.\n+    \/\/ Now we can check queue if there is anything we should process.\n+    if (_lock.is_locked()) {\n+      return true;\n+    }\n+    \/\/ Lock check must be done before queue check, force ordering.\n+    OrderAccess::loadload();\n+    return !_queue.is_empty();\n@@ -113,1 +143,1 @@\n-  void process_by_self();\n+  bool process_by_self();\n@@ -126,0 +156,25 @@\n+\n+  \/\/ Suspend\/resume support\n+ private:\n+  \/\/ This flag is true when the thread owning this\n+  \/\/ HandshakeState (the _handshakee) is suspended.\n+  volatile bool _suspended;\n+  \/\/ This flag is true while there is async handshake (trap)\n+  \/\/ on queue. Since we do only need one, we can reuse it if\n+  \/\/ thread gets suspended again (after a resume)\n+  \/\/ and we have not yet processed it.\n+  bool _async_suspend_handshake;\n+\n+  \/\/ Called from the suspend handshake.\n+  bool suspend_with_handshake();\n+  \/\/ Called from the async handshake (the trap)\n+  \/\/ to stop a thread from continuing execution when suspended.\n+  void do_self_suspend();\n+\n+  bool is_suspended()                       { return Atomic::load(&_suspended); }\n+  void set_suspended(bool to)               { return Atomic::store(&_suspended, to); }\n+  bool has_async_suspend_handshake()        { return _async_suspend_handshake; }\n+  void set_async_suspend_handshake(bool to) { _async_suspend_handshake = to; }\n+\n+  bool suspend();\n+  bool resume();\n","filename":"src\/hotspot\/share\/runtime\/handshake.hpp","additions":65,"deletions":10,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -84,4 +84,0 @@\n-      \/\/ This ThreadBlockInVM object is not also considered to be\n-      \/\/ suspend-equivalent because MonitorDeflationThread is not\n-      \/\/ visible to external suspension.\n-\n","filename":"src\/hotspot\/share\/runtime\/monitorDeflationThread.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -218,1 +218,1 @@\n-bool Monitor::wait(int64_t timeout, bool as_suspend_equivalent) {\n+bool Monitor::wait(int64_t timeout) {\n@@ -241,5 +241,0 @@\n-    if (as_suspend_equivalent) {\n-      self->set_suspend_equivalent();\n-      \/\/ cleared by handle_special_suspend_equivalent_condition() or\n-      \/\/ java_suspend_self()\n-    }\n@@ -249,11 +244,0 @@\n-\n-    \/\/ were we externally suspended while we were waiting?\n-    if (as_suspend_equivalent && self->handle_special_suspend_equivalent_condition()) {\n-      \/\/ Our event wait has finished and we own the lock, but\n-      \/\/ while we were waiting another thread suspended us. We don't\n-      \/\/ want to hold the lock while suspended because that\n-      \/\/ would surprise the thread that suspended us.\n-      _lock.unlock();\n-      self->java_suspend_self();\n-      _lock.lock();\n-    }\n@@ -278,1 +262,1 @@\n-\/\/ Only Threads_lock, Heap_lock and SR_lock may be safepoint_check_sometimes.\n+\/\/ Only Threads_lock and Heap_lock may be safepoint_check_sometimes.\n@@ -280,1 +264,1 @@\n-  return (strcmp(name, \"Threads_lock\") == 0 || strcmp(name, \"Heap_lock\") == 0 || strcmp(name, \"SR_lock\") == 0);\n+  return (strcmp(name, \"Threads_lock\") == 0 || strcmp(name, \"Heap_lock\") == 0);\n@@ -390,1 +374,1 @@\n-  \/\/ Locks with rank native or suspend_resume are an exception and are not\n+  \/\/ Locks with rank native are an exception and are not\n@@ -392,2 +376,1 @@\n-  bool check_can_be_skipped = this->rank() == Mutex::native || this->rank() == Mutex::suspend_resume\n-                              || SafepointSynchronize::is_at_safepoint();\n+  bool check_can_be_skipped = this->rank() == Mutex::native || SafepointSynchronize::is_at_safepoint();\n","filename":"src\/hotspot\/share\/runtime\/mutex.cpp","additions":5,"deletions":22,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -70,2 +70,1 @@\n-       suspend_resume = special        +   1,\n-       oopstorage     = suspend_resume +   2,\n+       oopstorage     = special        +   3,\n@@ -126,1 +125,0 @@\n-  static const bool _as_suspend_equivalent_flag = true;\n@@ -225,4 +223,2 @@\n-  \/\/ zero), and not a suspend-equivalent condition. Returns true if wait\n-  \/\/ times out; otherwise returns false.\n-  bool wait(int64_t timeout = 0,\n-            bool as_suspend_equivalent = !_as_suspend_equivalent_flag);\n+  \/\/ zero). Returns true if wait times out; otherwise returns false.\n+  bool wait(int64_t timeout = 0);\n","filename":"src\/hotspot\/share\/runtime\/mutex.hpp","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -262,2 +262,1 @@\n-  bool wait(int64_t timeout = 0,\n-            bool as_suspend_equivalent = !Mutex::_as_suspend_equivalent_flag) {\n+  bool wait(int64_t timeout = 0) {\n@@ -265,1 +264,1 @@\n-      return as_monitor()->wait(timeout, as_suspend_equivalent);\n+      return as_monitor()->wait(timeout);\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -326,3 +326,2 @@\n-    \/\/ This wait should make safepoint checks, wait without a timeout,\n-    \/\/ and wait as a suspend-equivalent condition.\n-    mu.wait(0, Mutex::_as_suspend_equivalent_flag);\n+    \/\/ This wait should make safepoint checks and wait without a timeout.\n+    mu.wait(0);\n","filename":"src\/hotspot\/share\/runtime\/nonJavaThread.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -111,2 +111,2 @@\n-        \/\/ Wait as a suspend equalent until notified that there is some work to do.\n-        ml.wait(0, true);\n+        \/\/ Wait until notified that there is some work to do.\n+        ml.wait(0);\n","filename":"src\/hotspot\/share\/runtime\/notificationThread.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -406,1 +406,0 @@\n-    ThreadBlockInVM tbivm(current);\n@@ -408,5 +407,1 @@\n-    \/\/ TODO-FIXME: change the following for(;;) loop to straight-line code.\n-    for (;;) {\n-      current->set_suspend_equivalent();\n-      \/\/ cleared by handle_special_suspend_equivalent_condition()\n-      \/\/ or java_suspend_self()\n+    assert(current->thread_state() == _thread_in_vm, \"invariant\");\n@@ -414,0 +409,6 @@\n+    current->frame_anchor()->make_walkable(current);\n+    \/\/ Thread must be walkable before it is blocked.\n+    \/\/ Read in reverse order.\n+    OrderAccess::storestore();\n+    for (;;) {\n+      current->set_thread_state(_thread_blocked);\n@@ -415,13 +416,17 @@\n-\n-      if (!current->handle_special_suspend_equivalent_condition()) break;\n-\n-      \/\/ We have acquired the contended monitor, but while we were\n-      \/\/ waiting another thread suspended us. We don't want to enter\n-      \/\/ the monitor while suspended because that would surprise the\n-      \/\/ thread that suspended us.\n-      \/\/\n-      _recursions = 0;\n-      _succ = NULL;\n-      exit(current, false \/* not_suspended *\/);\n-\n-      current->java_suspend_self();\n+      current->set_thread_state_fence(_thread_blocked_trans);\n+      if (SafepointMechanism::should_process(current) &&\n+        current->is_suspended()) {\n+        \/\/ We have acquired the contended monitor, but while we were\n+        \/\/ waiting another thread suspended us. We don't want to enter\n+        \/\/ the monitor while suspended because that would surprise the\n+        \/\/ thread that suspended us.\n+        _recursions = 0;\n+        _succ = NULL;\n+        \/\/ Don't need a full fence after clearing successor here because of the call to exit().\n+        exit(current, false \/* not_suspended *\/);\n+        SafepointMechanism::process_if_requested(current);\n+        \/\/ Since we are going to _thread_blocked we skip setting _thread_in_vm here.\n+      } else {\n+        \/\/ Only exit path from for loop\n+        break;\n+      }\n@@ -429,0 +434,1 @@\n+\n@@ -433,2 +439,2 @@\n-    \/\/ and clear, i.e., it is no longer pending. The ThreadBlockInVM\n-    \/\/ destructor can go to a safepoint at the end of this block. If we\n+    \/\/ and clear, i.e., it is no longer pending.\n+    \/\/ We can go to a safepoint at the end of this block. If we\n@@ -439,0 +445,4 @@\n+\n+    \/\/ Completed the tranisition.\n+    SafepointMechanism::process_if_requested(current);\n+    current->set_thread_state(_thread_in_vm);\n@@ -957,3 +967,0 @@\n-    \/\/ State transition wrappers around park() ...\n-    \/\/ ReenterI() wisely defers state transitions until\n-    \/\/ it's clear we must park the thread.\n@@ -962,1 +969,0 @@\n-      ThreadBlockInVM tbivm(current);\n@@ -964,4 +970,1 @@\n-      \/\/ cleared by handle_special_suspend_equivalent_condition()\n-      \/\/ or java_suspend_self()\n-      current->set_suspend_equivalent();\n-      current->_ParkEvent->park();\n+      assert(current->thread_state() == _thread_in_vm, \"invariant\");\n@@ -969,6 +972,13 @@\n-      \/\/ were we externally suspended while we were waiting?\n-      for (;;) {\n-        if (!current->handle_special_suspend_equivalent_condition()) break;\n-        if (_succ == current) { _succ = NULL; OrderAccess::fence(); }\n-        current->java_suspend_self();\n-        current->set_suspend_equivalent();\n+      current->frame_anchor()->make_walkable(current);\n+      \/\/ Thread must be walkable before it is blocked.\n+      \/\/ Read in reverse order.\n+      OrderAccess::storestore();\n+      current->set_thread_state(_thread_blocked);\n+      current->_ParkEvent->park();\n+      current->set_thread_state_fence(_thread_blocked_trans);\n+      if (SafepointMechanism::should_process(current)) {\n+        if (_succ == current) {\n+            _succ = NULL;\n+            OrderAccess::fence(); \/\/ always do a full fence when successor is cleared\n+        }\n+        SafepointMechanism::process_if_requested(current);\n@@ -976,0 +986,1 @@\n+      current->set_thread_state(_thread_in_vm);\n@@ -1529,4 +1540,0 @@\n-    {\n-      ThreadBlockInVM tbivm(current);\n-      \/\/ Thread is in thread_blocked state and oop access is unsafe.\n-      current->set_suspend_equivalent();\n@@ -1534,0 +1541,8 @@\n+    assert(current->thread_state() == _thread_in_vm, \"invariant\");\n+\n+    {\n+      current->frame_anchor()->make_walkable(current);\n+      \/\/ Thread must be walkable before it is blocked.\n+      \/\/ Read in reverse order.\n+      OrderAccess::storestore();\n+      current->set_thread_state(_thread_blocked);\n@@ -1543,5 +1558,7 @@\n-\n-      \/\/ were we externally suspended while we were waiting?\n-      if (current->handle_special_suspend_equivalent_condition()) {\n-        \/\/ TODO-FIXME: add -- if succ == current then succ = null.\n-        current->java_suspend_self();\n+      current->set_thread_state_fence(_thread_blocked_trans);\n+      if (SafepointMechanism::should_process(current)) {\n+        if (_succ == current) {\n+            _succ = NULL;\n+            OrderAccess::fence(); \/\/ always do a full fence when successor is cleared\n+        }\n+        SafepointMechanism::process_if_requested(current);\n@@ -1549,2 +1566,2 @@\n-\n-    } \/\/ Exit thread safepoint: transition _thread_blocked -> _thread_in_vm\n+      current->set_thread_state(_thread_in_vm);\n+    }\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.cpp","additions":63,"deletions":46,"binary":false,"changes":109,"status":"modified"},{"patch":"@@ -874,2 +874,0 @@\n-  \/\/ guard suspend\/resume\n-  MutexLocker ml(thread->SR_lock(), Mutex::_no_safepoint_check_flag);\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -80,6 +80,8 @@\n-  if (global_poll()) {\n-    \/\/ Any load in ::block must not pass the global poll load.\n-    \/\/ Otherwise we might load an old safepoint counter (for example).\n-    OrderAccess::loadload();\n-    SafepointSynchronize::block(thread);\n-  }\n+  bool need_rechecking;\n+  do {\n+    if (global_poll()) {\n+      \/\/ Any load in ::block() must not pass the global poll load.\n+      \/\/ Otherwise we might load an old safepoint counter (for example).\n+      OrderAccess::loadload();\n+      SafepointSynchronize::block(thread);\n+    }\n@@ -87,7 +89,7 @@\n-  \/\/ The call to on_safepoint fixes the thread's oops and the first few frames.\n-  \/\/\n-  \/\/ The call has been carefully placed here to cater for a few situations:\n-  \/\/ 1) After we exit from block after a global poll\n-  \/\/ 2) After a thread races with the disarming of the global poll and transitions from native\/blocked\n-  \/\/ 3) Before the handshake code is run\n-  StackWatermarkSet::on_safepoint(thread);\n+    \/\/ The call to on_safepoint fixes the thread's oops and the first few frames.\n+    \/\/\n+    \/\/ The call has been carefully placed here to cater to a few situations:\n+    \/\/ 1) After we exit from block after a global poll\n+    \/\/ 2) After a thread races with the disarming of the global poll and transitions from native\/blocked\n+    \/\/ 3) Before the handshake code is run\n+    StackWatermarkSet::on_safepoint(thread);\n@@ -95,3 +97,3 @@\n-  if (thread->handshake_state()->should_process()) {\n-    thread->handshake_state()->process_by_self();\n-  }\n+    need_rechecking = thread->handshake_state()->should_process() && thread->handshake_state()->process_by_self();\n+\n+  } while (need_rechecking);\n@@ -114,0 +116,2 @@\n+  assert(thread->thread_state() != _thread_blocked, \"Must not be\");\n+  assert(thread->thread_state() != _thread_in_native, \"Must not be\");\n","filename":"src\/hotspot\/share\/runtime\/safepointMechanism.cpp","additions":20,"deletions":16,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -276,1 +276,0 @@\n-    thread->java_suspend_self();\n","filename":"src\/hotspot\/share\/runtime\/sweeper.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -277,2 +277,0 @@\n-  _SR_lock = new Monitor(Mutex::suspend_resume, \"SR_lock\", true,\n-                         Monitor::_safepoint_check_sometimes);\n@@ -453,3 +451,3 @@\n-  \/\/ It's possible we can encounter a null _ParkEvent, etc., in stillborn threads.\n-  \/\/ We NULL out the fields for good hygiene.\n-  ParkEvent::Release(_ParkEvent); _ParkEvent   = NULL;\n+  ParkEvent::Release(_ParkEvent);\n+  \/\/ Set to NULL as a termination indicator for has_terminated().\n+  Atomic::store(&_ParkEvent, (ParkEvent*)NULL);\n@@ -460,5 +458,0 @@\n-  \/\/ SR_handler uses this as a termination indicator -\n-  \/\/ needs to happen before os::free_thread()\n-  delete _SR_lock;\n-  _SR_lock = NULL;\n-\n@@ -585,113 +578,0 @@\n-\n-\/\/ Check if an external suspend request has completed (or has been\n-\/\/ cancelled). Returns true if the thread is externally suspended and\n-\/\/ false otherwise.\n-bool JavaThread::is_ext_suspend_completed() {\n-  bool did_trans_retry = false;  \/\/ only do thread_in_native_trans retry once\n-  bool do_trans_retry;           \/\/ flag to force the retry\n-\n-  do {\n-    do_trans_retry = false;\n-\n-    if (is_exiting()) {\n-      \/\/ Thread is in the process of exiting. This is always checked\n-      \/\/ first to reduce the risk of dereferencing a freed JavaThread.\n-      return false;\n-    }\n-\n-    if (!is_external_suspend()) {\n-      \/\/ Suspend request is cancelled. This is always checked before\n-      \/\/ is_ext_suspended() to reduce the risk of a rogue resume\n-      \/\/ confusing the thread that made the suspend request.\n-      return false;\n-    }\n-\n-    if (is_ext_suspended()) {\n-      \/\/ thread is suspended\n-      return true;\n-    }\n-\n-    \/\/ Now that we no longer do hard suspends of threads running\n-    \/\/ native code, the target thread can be changing thread state\n-    \/\/ while we are in this routine:\n-    \/\/\n-    \/\/   _thread_in_native -> _thread_in_native_trans -> _thread_blocked\n-    \/\/\n-    \/\/ We save a copy of the thread state as observed at this moment\n-    \/\/ and make our decision about suspend completeness based on the\n-    \/\/ copy. This closes the race where the thread state is seen as\n-    \/\/ _thread_in_native_trans in the if-thread_blocked check, but is\n-    \/\/ seen as _thread_blocked in if-thread_in_native_trans check.\n-    JavaThreadState save_state = thread_state();\n-\n-    if (save_state == _thread_blocked && is_suspend_equivalent()) {\n-      \/\/ If the thread's state is _thread_blocked and this blocking\n-      \/\/ condition is known to be equivalent to a suspend, then we can\n-      \/\/ consider the thread to be externally suspended. This means that\n-      \/\/ the code that sets _thread_blocked has been modified to do\n-      \/\/ self-suspension if the blocking condition releases. We also\n-      \/\/ used to check for CONDVAR_WAIT here, but that is now covered by\n-      \/\/ the _thread_blocked with self-suspension check.\n-      \/\/\n-      \/\/ Return true since we wouldn't be here unless there was still an\n-      \/\/ external suspend request.\n-      return true;\n-    } else if (save_state == _thread_in_native && frame_anchor()->walkable()) {\n-      \/\/ Threads running native code will self-suspend on native==>VM\/Java\n-      \/\/ transitions. If its stack is walkable (should always be the case\n-      \/\/ unless this function is called before the actual java_suspend()\n-      \/\/ call), then the wait is done.\n-      return true;\n-    } else if (!did_trans_retry &&\n-               save_state == _thread_in_native_trans &&\n-               frame_anchor()->walkable()) {\n-      \/\/ The thread is transitioning from thread_in_native to another\n-      \/\/ thread state. check_safepoint_and_suspend_for_native_trans()\n-      \/\/ will force the thread to self-suspend. If it hasn't gotten\n-      \/\/ there yet we may have caught the thread in-between the native\n-      \/\/ code check above and the self-suspend.\n-      \/\/\n-      \/\/ Since we use the saved thread state in the if-statement above,\n-      \/\/ there is a chance that the thread has already transitioned to\n-      \/\/ _thread_blocked by the time we get here. In that case, we will\n-      \/\/ make a single unnecessary pass through the logic below. This\n-      \/\/ doesn't hurt anything since we still do the trans retry.\n-\n-      \/\/ Once the thread leaves thread_in_native_trans for another\n-      \/\/ thread state, we break out of this retry loop. We shouldn't\n-      \/\/ need this flag to prevent us from getting back here, but\n-      \/\/ sometimes paranoia is good.\n-      did_trans_retry = true;\n-\n-      \/\/ We wait for the thread to transition to a more usable state.\n-      for (int i = 1; i <= SuspendRetryCount; i++) {\n-        \/\/ We used to do an \"os::yield_all(i)\" call here with the intention\n-        \/\/ that yielding would increase on each retry. However, the parameter\n-        \/\/ is ignored on Linux which means the yield didn't scale up. Waiting\n-        \/\/ on the SR_lock below provides a much more predictable scale up for\n-        \/\/ the delay. It also provides a simple\/direct point to check for any\n-        \/\/ safepoint requests from the VMThread\n-\n-        \/\/ temporarily drops SR_lock while doing wait with safepoint check\n-        \/\/ (if we're a JavaThread - the WatcherThread can also call this)\n-        \/\/ and increase delay with each retry\n-        if (Thread::current()->is_Java_thread()) {\n-          SR_lock()->wait(i * SuspendRetryDelay);\n-        } else {\n-          SR_lock()->wait_without_safepoint_check(i * SuspendRetryDelay);\n-        }\n-\n-        \/\/ check the actual thread state instead of what we saved above\n-        if (thread_state() != _thread_in_native_trans) {\n-          \/\/ the thread has transitioned to another thread state so\n-          \/\/ try all the checks (except this one) one more time.\n-          do_trans_retry = true;\n-          break;\n-        }\n-      } \/\/ end retry loop\n-    }\n-  } while (do_trans_retry);\n-\n-  return false;\n-}\n-\n@@ -1192,1 +1072,0 @@\n-  _suspend_equivalent(false),\n@@ -1240,1 +1119,0 @@\n-\n@@ -1566,20 +1444,4 @@\n-    \/\/ We have notified the agents that we are exiting, before we go on,\n-    \/\/ we must check for a pending external suspend request and honor it\n-    \/\/ in order to not surprise the thread that made the suspend request.\n-    while (true) {\n-      {\n-        MutexLocker ml(SR_lock(), Mutex::_no_safepoint_check_flag);\n-        if (!is_external_suspend()) {\n-          set_terminated(_thread_exiting);\n-          ThreadService::current_thread_exiting(this, is_daemon(threadObj()));\n-          break;\n-        }\n-        \/\/ Implied else:\n-        \/\/ Things get a little tricky here. We have a pending external\n-        \/\/ suspend request, but we are holding the SR_lock so we\n-        \/\/ can't just self-suspend. So we temporarily drop the lock\n-        \/\/ and then self-suspend.\n-      }\n-\n-      ThreadBlockInVM tbivm(this);\n-      java_suspend_self();\n+    \/\/ The careful dance between thread suspension and exit is handled here.\n+    \/\/ Since we are in thread_in_vm state and suspension is done with handshakes,\n+    \/\/ we can just put in the exiting state and it will be correctly handled.\n+    set_terminated(_thread_exiting);\n@@ -1587,6 +1449,1 @@\n-      \/\/ We're done with this suspend request, but we have to loop around\n-      \/\/ and check again. Eventually we will get SR_lock without a pending\n-      \/\/ external suspend request and will be able to mark ourselves as\n-      \/\/ exiting.\n-    }\n-    \/\/ no more external suspends are allowed at this point\n+    ThreadService::current_thread_exiting(this, is_daemon(threadObj()));\n@@ -1866,6 +1723,0 @@\n-  \/\/ Check for pending external suspend.\n-  if (is_external_suspend_with_lock()) {\n-    frame_anchor()->make_walkable(this);\n-    java_suspend_self_with_safepoint_check();\n-  }\n-\n@@ -1933,0 +1784,1 @@\n+\n@@ -1935,4 +1787,3 @@\n-\/\/ Tell the VM to suspend a thread when ever it knows that it does not hold on\n-\/\/ to any VM_locks and it is at a transition\n-\/\/ Self-suspension will happen on the transition out of the vm.\n-\/\/ Catch \"this\" coming in from JNIEnv pointers when the thread has been freed\n+\/\/ Guarantees on return (for a valid target thread):\n+\/\/   - Target thread will not execute any new bytecode.\n+\/\/   - Target thread will not enter any new monitors.\n@@ -1940,6 +1791,1 @@\n-\/\/ Guarantees on return:\n-\/\/   + Target thread will not execute any new bytecode (that's why we need to\n-\/\/     force a safepoint)\n-\/\/   + Target thread will not enter any new monitors\n-\/\/\n-void JavaThread::java_suspend() {\n+bool JavaThread::java_suspend() {\n@@ -1947,32 +1793,3 @@\n-  if (!tlh.includes(this) || threadObj() == NULL || is_exiting()) {\n-    return;\n-  }\n-\n-  { MutexLocker ml(SR_lock(), Mutex::_no_safepoint_check_flag);\n-    if (!is_external_suspend()) {\n-      \/\/ a racing resume has cancelled us; bail out now\n-      return;\n-    }\n-\n-    \/\/ suspend is done\n-\n-    \/\/ Warning: is_ext_suspend_completed() may temporarily drop the\n-    \/\/ SR_lock to allow the thread to reach a stable thread state if\n-    \/\/ it is currently in a transient thread state.\n-    if (is_ext_suspend_completed()) {\n-      return;\n-    }\n-  }\n-\n-  if (Thread::current() == this) {\n-    \/\/ Safely self-suspend.\n-    \/\/ If we don't do this explicitly it will implicitly happen\n-    \/\/ before we transition back to Java, and on some other thread-state\n-    \/\/ transition paths, but not as we exit a JVM TI SuspendThread call.\n-    \/\/ As SuspendThread(current) must not return (until resumed) we must\n-    \/\/ self-suspend here.\n-    ThreadBlockInVM tbivm(this);\n-    java_suspend_self();\n-  } else {\n-    VM_ThreadSuspend vm_suspend;\n-    VMThread::execute(&vm_suspend);\n+  if (!tlh.includes(this)) {\n+    log_trace(thread, suspend)(\"JavaThread:\" INTPTR_FORMAT \" not on ThreadsList, no suspension\", p2i(this));\n+    return false;\n@@ -1980,0 +1797,1 @@\n+  return this->handshake_state()->suspend();\n@@ -1982,21 +1800,5 @@\n-\/\/ Part II of external suspension.\n-\/\/ A JavaThread self suspends when it detects a pending external suspend\n-\/\/ request. This is usually on transitions. It is also done in places\n-\/\/ where continuing to the next transition would surprise the caller,\n-\/\/ e.g., monitor entry.\n-\/\/\n-\/\/ Returns the number of times that the thread self-suspended.\n-\/\/\n-\/\/ Note: DO NOT call java_suspend_self() when you just want to block current\n-\/\/       thread. java_suspend_self() is the second stage of cooperative\n-\/\/       suspension for external suspend requests and should only be used\n-\/\/       to complete an external suspend request.\n-\/\/\n-int JavaThread::java_suspend_self() {\n-  assert(thread_state() == _thread_blocked, \"wrong state for java_suspend_self()\");\n-  int ret = 0;\n-\n-  \/\/ we are in the process of exiting so don't suspend\n-  if (is_exiting()) {\n-    clear_external_suspend();\n-    return ret;\n+bool JavaThread::java_resume() {\n+  ThreadsListHandle tlh;\n+  if (!tlh.includes(this)) {\n+    log_trace(thread, suspend)(\"JavaThread:\" INTPTR_FORMAT \" not on ThreadsList, nothing to resume\", p2i(this));\n+    return false;\n@@ -2004,73 +1806,1 @@\n-\n-  assert(_anchor.walkable() || !has_last_Java_frame(),\n-         \"must have walkable stack\");\n-\n-  MonitorLocker ml(SR_lock(), Mutex::_no_safepoint_check_flag);\n-\n-  assert(!this->is_ext_suspended(),\n-         \"a thread trying to self-suspend should not already be suspended\");\n-\n-  if (this->is_suspend_equivalent()) {\n-    \/\/ If we are self-suspending as a result of the lifting of a\n-    \/\/ suspend equivalent condition, then the suspend_equivalent\n-    \/\/ flag is not cleared until we set the ext_suspended flag.\n-    this->clear_suspend_equivalent();\n-  }\n-\n-  \/\/ A racing resume may have cancelled us before we grabbed SR_lock\n-  \/\/ above. Or another external suspend request could be waiting for us\n-  \/\/ by the time we return from SR_lock()->wait(). The thread\n-  \/\/ that requested the suspension may already be trying to walk our\n-  \/\/ stack and if we return now, we can change the stack out from under\n-  \/\/ it. This would be a \"bad thing (TM)\" and cause the stack walker\n-  \/\/ to crash. We stay self-suspended until there are no more pending\n-  \/\/ external suspend requests.\n-  while (is_external_suspend()) {\n-    ret++;\n-    this->set_ext_suspended();\n-\n-    \/\/ _ext_suspended flag is cleared by java_resume()\n-    while (is_ext_suspended()) {\n-      ml.wait();\n-    }\n-  }\n-  return ret;\n-}\n-\n-\/\/ Helper routine to set up the correct thread state before calling java_suspend_self.\n-\/\/ This is called when regular thread-state transition helpers can't be used because\n-\/\/ we can be in various states, in particular _thread_in_native_trans.\n-\/\/ We have to set the thread state directly to _thread_blocked so that it will\n-\/\/ be seen to be safepoint\/handshake safe whilst suspended. This is also\n-\/\/ necessary to allow a thread in is_ext_suspend_completed, that observed the\n-\/\/ _thread_in_native_trans state, to proceed.\n-\/\/ The problem with setting thread state directly is that a\n-\/\/ safepoint could happen just after java_suspend_self() returns after being resumed,\n-\/\/ and the VM thread will see the _thread_blocked state. So we must check for a safepoint\n-\/\/ after restoring the state to make sure we won't leave while a safepoint is in progress.\n-\/\/ However, not all initial-states are allowed when performing a safepoint check, as we\n-\/\/ should never be blocking at a safepoint whilst in those states(*). Of these 'bad' states\n-\/\/ only _thread_in_native is possible when executing this code (based on our two callers).\n-\/\/ A thread that is _thread_in_native is already safepoint-safe and so it doesn't matter\n-\/\/ whether the VMThread sees the _thread_blocked state, or the _thread_in_native state,\n-\/\/ and so we don't need the explicit safepoint check.\n-\/\/ (*) See switch statement in SafepointSynchronize::block() for thread states that are\n-\/\/ allowed when performing a safepoint check.\n-\n-void JavaThread::java_suspend_self_with_safepoint_check() {\n-  assert(this == Thread::current(), \"invariant\");\n-  JavaThreadState state = thread_state();\n-\n-  do {\n-    set_thread_state(_thread_blocked);\n-    java_suspend_self();\n-    \/\/ The current thread could have been suspended again. We have to check for\n-    \/\/ suspend after restoring the saved state. Without this the current thread\n-    \/\/ might return to _thread_in_Java and execute bytecodes for an arbitrary\n-    \/\/ long time.\n-    set_thread_state_fence(state);\n-\n-    if (state != _thread_in_native) {\n-      SafepointMechanism::process_if_requested(this);\n-    }\n-  } while (is_external_suspend());\n+  return this->handshake_state()->resume();\n@@ -2081,10 +1811,9 @@\n-\/\/ This method is very similar to JavaThread::java_suspend_self_with_safepoint_check()\n-\/\/ and has the same callers. It also performs a raw thread state transition to\n-\/\/ _thread_blocked and back again to the original state before returning. The current\n-\/\/ thread is required to change to _thread_blocked in order to be seen to be\n-\/\/ safepoint\/handshake safe whilst suspended and only after becoming handshake safe,\n-\/\/ the other thread can complete the handshake used to synchronize with this thread\n-\/\/ and then perform the reallocation and relocking. We cannot use the thread state\n-\/\/ transition helpers because we arrive here in various states and also because the\n-\/\/ helpers indirectly call this method.  After leaving _thread_blocked we have to\n-\/\/ check for safepoint\/handshake, except if _thread_in_native. The thread is safe\n+\/\/ Raw thread state transition to _thread_blocked and back again to the original\n+\/\/ state before returning are performed. The current thread is required to\n+\/\/ change to _thread_blocked in order to be seen to be safepoint\/handshake safe\n+\/\/ whilst suspended and only after becoming handshake safe, the other thread can\n+\/\/ complete the handshake used to synchronize with this thread and then perform\n+\/\/ the reallocation and relocking. We cannot use the thread state transition\n+\/\/ helpers because we arrive here in various states and also because the helpers\n+\/\/ indirectly call this method.  After leaving _thread_blocked we have to check\n+\/\/ for safepoint\/handshake, except if _thread_in_native. The thread is safe\n@@ -2102,4 +1831,0 @@\n-    \/\/ Check if _external_suspend was set in the previous loop iteration.\n-    if (is_external_suspend()) {\n-      java_suspend_self();\n-    }\n@@ -2133,1 +1858,1 @@\n-  } while (is_obj_deopt_suspend() || is_external_suspend());\n+  } while (is_obj_deopt_suspend());\n@@ -2186,23 +1911,0 @@\n-\/\/ We need to guarantee the Threads_lock here, since resumes are not\n-\/\/ allowed during safepoint synchronization\n-\/\/ Can only resume from an external suspension\n-void JavaThread::java_resume() {\n-  assert_locked_or_safepoint(Threads_lock);\n-\n-  \/\/ Sanity check: thread is gone, has started exiting or the thread\n-  \/\/ was not externally suspended.\n-  ThreadsListHandle tlh;\n-  if (!tlh.includes(this) || is_exiting() || !is_external_suspend()) {\n-    return;\n-  }\n-\n-  MutexLocker ml(SR_lock(), Mutex::_no_safepoint_check_flag);\n-\n-  clear_external_suspend();\n-\n-  if (is_ext_suspended()) {\n-    clear_ext_suspended();\n-    SR_lock()->notify_all();\n-  }\n-}\n-\n@@ -2777,5 +2479,0 @@\n-\n-      this->set_suspend_equivalent();\n-      \/\/ cleared by handle_special_suspend_equivalent_condition() or\n-      \/\/ java_suspend_self() via check_and_wait_while_suspended()\n-\n@@ -2783,3 +2480,0 @@\n-\n-      \/\/ were we externally suspended while we were waiting?\n-      this->check_and_wait_while_suspended();\n@@ -3709,1 +3403,2 @@\n-  { MonitorLocker nu(Threads_lock);\n+  {\n+    MonitorLocker nu(Threads_lock);\n@@ -3711,3 +3406,2 @@\n-      \/\/ This wait should make safepoint checks, wait without a timeout,\n-      \/\/ and wait as a suspend-equivalent condition.\n-      nu.wait(0, Mutex::_as_suspend_equivalent_flag);\n+      \/\/ This wait should make safepoint checks, wait without a timeout.\n+      nu.wait(0);\n@@ -3884,1 +3578,1 @@\n-    p->set_terminated_value();\n+    p->set_terminated(JavaThread::_thread_terminated);\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":38,"deletions":344,"binary":false,"changes":382,"status":"modified"},{"patch":"@@ -217,65 +217,0 @@\n- private:\n-\n-  \/\/ ***************************************************************\n-  \/\/ Suspend and resume support\n-  \/\/ ***************************************************************\n-  \/\/\n-  \/\/ VM suspend\/resume no longer exists - it was once used for various\n-  \/\/ things including safepoints but was deprecated and finally removed\n-  \/\/ in Java 7. Because VM suspension was considered \"internal\" Java-level\n-  \/\/ suspension was considered \"external\", and this legacy naming scheme\n-  \/\/ remains.\n-  \/\/\n-  \/\/ External suspend\/resume requests come from JVM_SuspendThread,\n-  \/\/ JVM_ResumeThread, JVMTI SuspendThread, and finally JVMTI\n-  \/\/ ResumeThread. External\n-  \/\/ suspend requests cause _external_suspend to be set and external\n-  \/\/ resume requests cause _external_suspend to be cleared.\n-  \/\/ External suspend requests do not nest on top of other external\n-  \/\/ suspend requests. The higher level APIs reject suspend requests\n-  \/\/ for already suspended threads.\n-  \/\/\n-  \/\/ The external_suspend\n-  \/\/ flag is checked by has_special_runtime_exit_condition() and java thread\n-  \/\/ will self-suspend when handle_special_runtime_exit_condition() is\n-  \/\/ called. Most uses of the _thread_blocked state in JavaThreads are\n-  \/\/ considered the same as being externally suspended; if the blocking\n-  \/\/ condition lifts, the JavaThread will self-suspend. Other places\n-  \/\/ where VM checks for external_suspend include:\n-  \/\/   + mutex granting (do not enter monitors when thread is suspended)\n-  \/\/   + state transitions from _thread_in_native\n-  \/\/\n-  \/\/ In general, java_suspend() does not wait for an external suspend\n-  \/\/ request to complete. When it returns, the only guarantee is that\n-  \/\/ the _external_suspend field is true.\n-  \/\/\n-  \/\/ wait_for_ext_suspend_completion() is used to wait for an external\n-  \/\/ suspend request to complete. External suspend requests are usually\n-  \/\/ followed by some other interface call that requires the thread to\n-  \/\/ be quiescent, e.g., GetCallTrace(). By moving the \"wait time\" into\n-  \/\/ the interface that requires quiescence, we give the JavaThread a\n-  \/\/ chance to self-suspend before we need it to be quiescent. This\n-  \/\/ improves overall suspend\/query performance.\n-  \/\/\n-  \/\/ _suspend_flags controls the behavior of java_ suspend\/resume.\n-  \/\/ It must be set under the protection of SR_lock. Read from the flag is\n-  \/\/ OK without SR_lock as long as the value is only used as a hint.\n-  \/\/ (e.g., check _external_suspend first without lock and then recheck\n-  \/\/ inside SR_lock and finish the suspension)\n-  \/\/\n-  \/\/ _suspend_flags is also overloaded for other \"special conditions\" so\n-  \/\/ that a single check indicates whether any special action is needed\n-  \/\/ eg. for async exceptions.\n-  \/\/ -------------------------------------------------------------------\n-  \/\/ Notes:\n-  \/\/ 1. The suspend\/resume logic no longer uses ThreadState in OSThread\n-  \/\/ but we still update its value to keep other part of the system (mainly\n-  \/\/ JVMTI) happy. ThreadState is legacy code (see notes in\n-  \/\/ osThread.hpp).\n-  \/\/\n-  \/\/ 2. It would be more natural if set_external_suspend() is private and\n-  \/\/ part of java_suspend(), but that probably would affect the suspend\/query\n-  \/\/ performance. Need more investigation on this.\n-\n-  \/\/ suspend\/resume lock: used for self-suspend\n-  Monitor* _SR_lock;\n@@ -283,1 +218,0 @@\n- protected:\n@@ -288,3 +222,0 @@\n-    _external_suspend       = 0x20000000U, \/\/ thread is asked to self suspend\n-    _ext_suspended          = 0x40000000U, \/\/ thread has self-suspended\n-\n@@ -516,2 +447,0 @@\n-  Monitor* SR_lock() const                       { return _SR_lock; }\n-\n@@ -813,1 +742,1 @@\n-  ParkEvent * _ParkEvent;                     \/\/ for Object monitors, JVMTI raw monitors,\n+  ParkEvent * volatile _ParkEvent;            \/\/ for Object monitors, JVMTI raw monitors,\n@@ -815,1 +744,5 @@\n-  int NativeSyncRecursion;                    \/\/ diagnostic\n+\n+  \/\/ Termination indicator used by the signal handler.\n+  \/\/ _ParkEvent is just a convenient field we can NULL out after setting the JavaThread termination state\n+  \/\/ (which can't itself be read from the signal handler if a signal hits during the Thread destructor).\n+  bool has_terminated()                       { return Atomic::load(&_ParkEvent) == NULL; };\n@@ -872,0 +805,1 @@\n+  friend class HandshakeState;\n@@ -956,0 +890,1 @@\n+ public:\n@@ -964,0 +899,1 @@\n+ private:\n@@ -971,2 +907,1 @@\n-  \/\/ suspend\/resume support\n-  volatile bool         _suspend_equivalent;     \/\/ Suspend equivalent condition\n+\n@@ -1183,2 +1118,1 @@\n-  \/\/ special for Threads::remove() which is static:\n-  void set_terminated_value();\n+\n@@ -1210,12 +1144,3 @@\n- private:\n-  inline void set_ext_suspended();\n-  inline void clear_ext_suspended();\n-\n- public:\n-  void java_suspend(); \/\/ higher-level suspension logic called by the public APIs\n-  void java_resume();  \/\/ higher-level resume logic called by the public APIs\n-  int  java_suspend_self(); \/\/ low-level self-suspension mechanics\n-\n-  \/\/ Synchronize with another thread that is deoptimizing objects of the\n-  \/\/ current thread, i.e. reverts optimizations based on escape analysis.\n-  void wait_for_object_deoptimization();\n+  bool java_suspend(); \/\/ higher-level suspension logic called by the public APIs\n+  bool java_resume();  \/\/ higher-level resume logic called by the public APIs\n+  bool is_suspended()     { return _handshake.is_suspended(); }\n@@ -1223,20 +1148,0 @@\n- private:\n-  \/\/ mid-level wrapper around java_suspend_self to set up correct state and\n-  \/\/ check for a pending safepoint at the end\n-  void java_suspend_self_with_safepoint_check();\n-\n- public:\n-  void check_and_wait_while_suspended() {\n-    assert(JavaThread::current() == this, \"sanity check\");\n-\n-    bool do_self_suspend;\n-    do {\n-      \/\/ were we externally suspended while we were waiting?\n-      do_self_suspend = handle_special_suspend_equivalent_condition();\n-      if (do_self_suspend) {\n-        \/\/ don't surprise the thread that suspended us by returning\n-        java_suspend_self();\n-        set_suspend_equivalent();\n-      }\n-    } while (do_self_suspend);\n-  }\n@@ -1244,1 +1149,1 @@\n-  \/\/ Check for async exception in addition to safepoint and suspend request.\n+  \/\/ Check for async exception in addition to safepoint.\n@@ -1247,8 +1152,0 @@\n-  bool is_ext_suspend_completed();\n-\n-  inline void set_external_suspend();\n-  inline void clear_external_suspend();\n-\n-  bool is_external_suspend() const {\n-    return (_suspend_flags & _external_suspend) != 0;\n-  }\n@@ -1256,1 +1153,1 @@\n-  \/\/ if external|deopt suspend is present.\n+  \/\/ if deopt suspend is present.\n@@ -1258,6 +1155,1 @@\n-    return (_suspend_flags & (_external_suspend | _obj_deopt JFR_ONLY(| _trace_flag))) != 0;\n-  }\n-\n-  \/\/ external suspend request is completed\n-  bool is_ext_suspended() const {\n-    return (_suspend_flags & _ext_suspended) != 0;\n+    return (_suspend_flags & (_obj_deopt JFR_ONLY(| _trace_flag))) != 0;\n@@ -1266,35 +1158,3 @@\n-  bool is_external_suspend_with_lock() const {\n-    MutexLocker ml(SR_lock(), Mutex::_no_safepoint_check_flag);\n-    return is_external_suspend();\n-  }\n-\n-  \/\/ Special method to handle a pending external suspend request\n-  \/\/ when a suspend equivalent condition lifts.\n-  bool handle_special_suspend_equivalent_condition() {\n-    assert(is_suspend_equivalent(),\n-           \"should only be called in a suspend equivalence condition\");\n-    MutexLocker ml(SR_lock(), Mutex::_no_safepoint_check_flag);\n-    bool ret = is_external_suspend();\n-    if (!ret) {\n-      \/\/ not about to self-suspend so clear suspend equivalence\n-      clear_suspend_equivalent();\n-    }\n-    \/\/ implied else:\n-    \/\/ We have a pending external suspend request so we leave the\n-    \/\/ suspend_equivalent flag set until java_suspend_self() sets\n-    \/\/ the ext_suspended flag and clears the suspend_equivalent\n-    \/\/ flag. This insures that wait_for_ext_suspend_completion()\n-    \/\/ will return consistent values.\n-    return ret;\n-  }\n-\n-  \/\/ utility methods to see if we are doing some kind of suspension\n-  bool is_being_ext_suspended() const            {\n-    MutexLocker ml(SR_lock(), Mutex::_no_safepoint_check_flag);\n-    return is_ext_suspended() || is_external_suspend();\n-  }\n-\n-  bool is_suspend_equivalent() const             { return _suspend_equivalent; }\n-\n-  void set_suspend_equivalent()                  { _suspend_equivalent = true; }\n-  void clear_suspend_equivalent()                { _suspend_equivalent = false; }\n+  \/\/ Synchronize with another thread that is deoptimizing objects of the\n+  \/\/ current thread, i.e. reverts optimizations based on escape analysis.\n+  void wait_for_object_deoptimization();\n@@ -1321,11 +1181,1 @@\n-    \/\/ Because we don't use is_external_suspend_with_lock\n-    \/\/ it is possible that we won't see an asynchronous external suspend\n-    \/\/ request that has just gotten started, i.e., SR_lock grabbed but\n-    \/\/ _external_suspend field change either not made yet or not visible\n-    \/\/ yet. However, this is okay because the request is asynchronous and\n-    \/\/ we will see the new flag value the next time through. It's also\n-    \/\/ possible that the external suspend request is dropped after\n-    \/\/ we have checked is_external_suspend(), we will recheck its value\n-    \/\/ under SR_lock in java_suspend_self().\n-    return (_special_runtime_exit_condition != _no_async_condition) ||\n-            is_external_suspend() || is_trace_suspend() || is_obj_deopt_suspend();\n+    return (_special_runtime_exit_condition != _no_async_condition) || is_trace_suspend() || is_obj_deopt_suspend();\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":21,"deletions":171,"binary":false,"changes":192,"status":"modified"},{"patch":"@@ -119,14 +119,0 @@\n-inline void JavaThread::set_ext_suspended() {\n-  set_suspend_flag (_ext_suspended);\n-}\n-inline void JavaThread::clear_ext_suspended() {\n-  clear_suspend_flag(_ext_suspended);\n-}\n-\n-inline void JavaThread::set_external_suspend() {\n-  set_suspend_flag(_external_suspend);\n-}\n-inline void JavaThread::clear_external_suspend() {\n-  clear_suspend_flag(_external_suspend);\n-}\n-\n@@ -194,2 +180,1 @@\n-  TerminatedTypes l_terminated = (TerminatedTypes)\n-      Atomic::load_acquire((volatile jint *) &_terminated);\n+  TerminatedTypes l_terminated = Atomic::load_acquire(&_terminated);\n@@ -202,2 +187,1 @@\n-  TerminatedTypes l_terminated = (TerminatedTypes)\n-      Atomic::load_acquire((volatile jint *) &_terminated);\n+  TerminatedTypes l_terminated = Atomic::load_acquire(&_terminated);\n@@ -209,7 +193,1 @@\n-  Atomic::release_store((volatile jint *) &_terminated, (jint) t);\n-}\n-\n-\/\/ special for Threads::remove() which is static:\n-inline void JavaThread::set_terminated_value() {\n-  \/\/ use release-store so the setting of _terminated is seen more quickly\n-  Atomic::release_store((volatile jint *) &_terminated, (jint) _thread_terminated);\n+  Atomic::release_store(&_terminated, t);\n","filename":"src\/hotspot\/share\/runtime\/thread.inline.hpp","additions":3,"deletions":25,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2147,2 +2147,0 @@\n-  declare_constant(Thread::_external_suspend)                             \\\n-  declare_constant(Thread::_ext_suspended)                                \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -312,1 +312,1 @@\n-  if (snapshot->is_ext_suspended()) {\n+  if (snapshot->is_suspended()) {\n","filename":"src\/hotspot\/share\/services\/management.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -882,1 +882,1 @@\n-  _is_ext_suspended = thread->is_being_ext_suspended();\n+  _is_suspended = thread->is_suspended();\n","filename":"src\/hotspot\/share\/services\/threadService.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -199,1 +199,1 @@\n-  bool    _is_ext_suspended;\n+  bool    _is_suspended;\n@@ -232,1 +232,1 @@\n-  bool        is_ext_suspended()          { return _is_ext_suspended; }\n+  bool        is_suspended()              { return _is_suspended; }\n","filename":"src\/hotspot\/share\/services\/threadService.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,2 +38,0 @@\n-  private static int EXTERNAL_SUSPEND;\n-  private static int EXT_SUSPENDED;\n@@ -60,2 +58,0 @@\n-    EXTERNAL_SUSPEND = db.lookupIntConstant(\"Thread::_external_suspend\").intValue();\n-    EXT_SUSPENDED = db.lookupIntConstant(\"Thread::_ext_suspended\").intValue();\n@@ -79,17 +75,0 @@\n-  public boolean isExternalSuspend() {\n-    return (suspendFlags() & EXTERNAL_SUSPEND) != 0;\n-  }\n-\n-  public boolean isExtSuspended() {\n-    return (suspendFlags() & EXT_SUSPENDED) != 0;\n-  }\n-\n-  public boolean isBeingExtSuspended() {\n-    return isExtSuspended() || isExternalSuspend();\n-  }\n-\n-  \/\/ historical usage: checked for VM or external suspension\n-  public boolean isAnySuspended() {\n-    return isExtSuspended();\n-  }\n-\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/Thread.java","additions":1,"deletions":22,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -106,3 +106,0 @@\n-    {\n-      MutexLocker ml(SR_lock(), Mutex::_no_safepoint_check_flag);\n-    }\n","filename":"test\/hotspot\/gtest\/threadHelper.inline.hpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -132,2 +132,2 @@\n-            if (!checkSuspendedStatus()) {\n-                throw new RuntimeException(\"Main: FAILED status returned from checkTestedThreadsSuspended\");\n+            while (!checkSuspendedStatus()) {\n+                Thread.sleep(10);\n@@ -169,1 +169,0 @@\n-    private static native void init();\n@@ -190,4 +189,0 @@\n-\n-        if (isSuspender) {\n-            init();\n-        }\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/SuspendWithCurrentThread\/SuspendWithCurrentThread.java","additions":3,"deletions":8,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,0 @@\n-static jrawMonitorID agent_monitor = NULL;\n@@ -49,12 +48,0 @@\n-static void\n-agent_lock(JNIEnv* jni) {\n-  jvmtiError err = jvmti->RawMonitorEnter(agent_monitor);\n-  check_jvmti_status(jni, err, \"monitor_enter: error in JVMTI RawMonitorEnter\");\n-}\n-\n-static void\n-agent_unlock(JNIEnv* jni) {\n-  jvmtiError err = jvmti->RawMonitorExit(agent_monitor);\n-  check_jvmti_status(jni, err, \"monitor_exit: error in JVMTI RawMonitorExit\");\n-}\n-\n@@ -77,10 +64,0 @@\n-\/* This function is executed on the suspender thread, not the Main thread *\/\n-JNIEXPORT void JNICALL\n-Java_ThreadToSuspend_init(JNIEnv *jni, jclass cls) {\n-  jvmtiError err = jvmti->CreateRawMonitor(\"Agent monitor\", &agent_monitor);\n-  check_jvmti_status(jni, err, \"Java_ThreadToSuspend_init: error in JVMTI CreateRawMonitor\");\n-\n-  \/\/ Main thread has to wait for the suspender thread to complete tested threads suspension\n-  agent_lock(jni);\n-}\n-\n@@ -109,3 +86,0 @@\n-  \/\/ Allow the Main thread to inspect the result of tested threads suspension\n-  agent_unlock(jni);\n-\n@@ -120,4 +94,0 @@\n-  \/\/ Block until the suspender thread competes the tested threads suspension\n-  agent_lock(jni);\n-  agent_unlock(jni);\n-\n@@ -132,1 +102,1 @@\n-      jni->FatalError(\"checkTestedThreadsSuspended: error: expected all tested threads suspended\");\n+      return JNI_FALSE;\n@@ -170,2 +140,0 @@\n-  err = jvmti->DestroyRawMonitor(agent_monitor);\n-  check_jvmti_status(jni, err, \"releaseTestedThreadsInfo: error in JVMTI DestroyRawMonitor\");\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/SuspendWithCurrentThread\/libSuspendWithCurrentThread.cpp","additions":2,"deletions":34,"binary":false,"changes":36,"status":"modified"}]}