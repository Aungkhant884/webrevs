{"files":[{"patch":"@@ -432,1 +432,0 @@\n-      jt->set_thread_state(_thread_in_vm);\n","filename":"src\/hotspot\/share\/prims\/jvmtiRawMonitor.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -524,0 +524,2 @@\n+  { \"SuspendRetryCount\",            JDK_Version::jdk(16), JDK_Version::jdk(17), JDK_Version::jdk(18) },\n+  { \"SuspendRetryDelay\",            JDK_Version::jdk(16), JDK_Version::jdk(17), JDK_Version::jdk(18) },\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -429,10 +429,0 @@\n-  \/* 50 retries * (5 * current_retry_count) millis = ~6.375 seconds *\/      \\\n-  \/* typically, at most a few retries are needed                    *\/      \\\n-  product(intx, SuspendRetryCount, 50,                                      \\\n-          \"Maximum retry count for an external suspend request\")            \\\n-          range(0, max_intx)                                                \\\n-                                                                            \\\n-  product(intx, SuspendRetryDelay, 5,                                       \\\n-          \"Milliseconds to delay per retry (* current_retry_count)\")        \\\n-          range(0, max_intx)                                                \\\n-                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -465,2 +465,2 @@\n-    \/\/ It by-passes the NSV by manully doing the transition.\n-    \/\/ Since we can have safepoints while suspeneded we need to release the tty locker if it is held.\n+    \/\/ It by-passes the NSV by manually doing the transition.\n+    \/\/ Since we can have safepoints while suspended we need to release the tty locker if it is held.\n","filename":"src\/hotspot\/share\/runtime\/handshake.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -132,2 +132,2 @@\n-    \/\/ Since the handshakee is unsafe if _lock gets lock after this check\n-    \/\/ we know another threads cannot process any handshakes.\n+    \/\/ Since the handshakee is unsafe if _lock gets locked after this check\n+    \/\/ we know another thread cannot process any handshakes.\n","filename":"src\/hotspot\/share\/runtime\/handshake.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -451,2 +451,0 @@\n-  \/\/ It's possible we can encounter a null _ParkEvent, etc., in stillborn threads.\n-  \/\/ We NULL out the fields for good hygiene.\n@@ -454,1 +452,1 @@\n-  \/\/ Can be racingly loaded in signal handler via has_terminated()\n+  \/\/ Set to NULL as a termination indicator for has_terminated().\n@@ -1447,1 +1445,1 @@\n-    \/\/ Since we are in vm and suspension is done with handshakes,\n+    \/\/ Since we are in thread_in_vm state and suspension is done with handshakes,\n@@ -1449,1 +1447,1 @@\n-    set_exiting();\n+    set_terminated(_thread_exiting);\n@@ -3580,1 +3578,1 @@\n-    p->set_terminated();\n+    p->set_terminated(JavaThread::_thread_terminated);\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -745,1 +745,3 @@\n-                                              \/\/ _ParkEvent is cleared\n+  \/\/ Termination indicator used by the signal handler.\n+  \/\/ _ParkEvent is just a convenient field we can NULL out after setting the JavaThread termination state\n+  \/\/ (which can't itself be read from the signal handler if a signal hits during the Thread destructor).\n@@ -888,0 +890,1 @@\n+ public:\n@@ -896,0 +899,1 @@\n+ private:\n@@ -1113,4 +1117,2 @@\n-  void set_exiting();\n-  void set_vm_exited();\n-  \/\/ special for Threads::remove() which is static:\n-  void set_terminated();\n+  void set_terminated(TerminatedTypes t);\n+\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -180,2 +180,1 @@\n-  TerminatedTypes l_terminated = (TerminatedTypes)\n-      Atomic::load_acquire((volatile jint *) &_terminated);\n+  TerminatedTypes l_terminated = Atomic::load_acquire(&_terminated);\n@@ -188,2 +187,1 @@\n-  TerminatedTypes l_terminated = (TerminatedTypes)\n-      Atomic::load_acquire((volatile jint *) &_terminated);\n+  TerminatedTypes l_terminated = Atomic::load_acquire(&_terminated);\n@@ -193,1 +191,1 @@\n-inline void JavaThread::set_exiting() {\n+inline void JavaThread::set_terminated(TerminatedTypes t) {\n@@ -195,12 +193,1 @@\n-  Atomic::release_store((volatile jint *) &_terminated, (jint) _thread_exiting);\n-}\n-\n-inline void JavaThread::set_vm_exited() {\n-  \/\/ use release-store so the setting of _terminated is seen more quickly\n-  Atomic::release_store((volatile jint *) &_terminated, (jint) _vm_exited);\n-}\n-\n-\/\/ special for Threads::remove() which is static:\n-inline void JavaThread::set_terminated() {\n-  \/\/ use release-store so the setting of _terminated is seen more quickly\n-  Atomic::release_store((volatile jint *) &_terminated, (jint) _thread_terminated);\n+  Atomic::release_store(&_terminated, t);\n","filename":"src\/hotspot\/share\/runtime\/thread.inline.hpp","additions":4,"deletions":17,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -359,1 +359,1 @@\n-      thr->set_vm_exited();  \/\/ per-thread flag\n+      thr->set_terminated(JavaThread::_vm_exited);  \/\/ per-thread flag\n","filename":"src\/hotspot\/share\/runtime\/vmOperations.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}