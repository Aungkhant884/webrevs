{"files":[{"patch":"@@ -61,1 +61,1 @@\n-    static class ModifierSettings extends EventSettings {\n+    static class DelegatedEventSettings extends EventSettings {\n@@ -64,1 +64,1 @@\n-        ModifierSettings(EventSettingsModifier modifier) {\n+        DelegatedEventSettings(EventSettingsModifier modifier) {\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/EventSettings.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -204,1 +204,1 @@\n-            return new EventSettings.ModifierSettings(esm);\n+            return new EventSettings.DelegatedEventSettings(esm);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/FlightRecorderPermission.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -144,6 +144,0 @@\n-            @Override\n-            public void setOnChunkCompleteHandler(EventStream stream, Consumer<Long> consumer) {\n-                EventDirectoryStream es = (EventDirectoryStream)stream;\n-                es.setChunkCompleteHandler(consumer);\n-            }\n-\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/consumer\/RecordedObject.java","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -61,2 +61,2 @@\n-    private final StreamConfiguration configuration = new StreamConfiguration();\n-    private final PlatformRecording recording;\n+    private final StreamConfiguration streamConfiguration = new StreamConfiguration();\n+    protected final PlatformRecording recording;\n@@ -86,4 +86,4 @@\n-        if (configuration.hasChanged()) { \/\/ quick check\n-            synchronized (configuration) {\n-                dispatcher = new Dispatcher(configuration);\n-                configuration.setChanged(false);\n+        if (streamConfiguration.hasChanged()) { \/\/ quick check\n+            synchronized (streamConfiguration) {\n+                dispatcher = new Dispatcher(streamConfiguration);\n+                streamConfiguration.setChanged(false);\n@@ -97,1 +97,1 @@\n-        configuration.setOrdered(ordered);\n+        streamConfiguration.setOrdered(ordered);\n@@ -102,1 +102,1 @@\n-        configuration.setReuse(reuse);\n+        streamConfiguration.setReuse(reuse);\n@@ -108,2 +108,2 @@\n-        synchronized (configuration) {\n-            if (configuration.started) {\n+        synchronized (streamConfiguration) {\n+            if (streamConfiguration.started) {\n@@ -115,1 +115,1 @@\n-            configuration.setStartTime(startTime);\n+            streamConfiguration.setStartTime(startTime);\n@@ -122,2 +122,2 @@\n-        synchronized (configuration) {\n-            if (configuration.started) {\n+        synchronized (streamConfiguration) {\n+            if (streamConfiguration.started) {\n@@ -126,1 +126,1 @@\n-            configuration.setEndTime(endTime);\n+            streamConfiguration.setEndTime(endTime);\n@@ -133,1 +133,1 @@\n-        configuration.addEventAction(action);\n+        streamConfiguration.addEventAction(action);\n@@ -140,1 +140,1 @@\n-        configuration.addEventAction(eventName, action);\n+        streamConfiguration.addEventAction(eventName, action);\n@@ -146,1 +146,1 @@\n-        configuration.addFlushAction(action);\n+        streamConfiguration.addFlushAction(action);\n@@ -152,1 +152,1 @@\n-        configuration.addCloseAction(action);\n+        streamConfiguration.addCloseAction(action);\n@@ -158,1 +158,1 @@\n-        configuration.addErrorAction(action);\n+        streamConfiguration.addErrorAction(action);\n@@ -164,1 +164,1 @@\n-        return configuration.remove(action);\n+        return streamConfiguration.remove(action);\n@@ -237,2 +237,2 @@\n-        synchronized (configuration) {\n-            if (configuration.started) {\n+        synchronized (streamConfiguration) {\n+            if (streamConfiguration.started) {\n@@ -241,2 +241,2 @@\n-            if (recording != null && configuration.startTime == null) {\n-                configuration.setStartNanos(startNanos);\n+            if (recording != null && streamConfiguration.startTime == null) {\n+                streamConfiguration.setStartNanos(startNanos);\n@@ -244,1 +244,1 @@\n-            configuration.setStarted(true);\n+            streamConfiguration.setStarted(true);\n@@ -286,2 +286,2 @@\n-        synchronized (configuration) {\n-            if (configuration.started) {\n+        synchronized (streamConfiguration) {\n+            if (streamConfiguration.started) {\n@@ -291,1 +291,1 @@\n-        configuration.addMetadataAction(action);\n+        streamConfiguration.addMetadataAction(action);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/AbstractEventStream.java","additions":28,"deletions":28,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -56,1 +56,0 @@\n-    private final PlatformRecording recording;\n@@ -71,1 +70,0 @@\n-        this.recording = recording;\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/EventDirectoryStream.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -108,2 +108,0 @@\n-    public abstract void setOnChunkCompleteHandler(EventStream stream, Consumer<Long> consumer);\n-\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/JdkJfrConsumer.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -84,4 +84,3 @@\n-        while (true) {\n-            if (recording.getState() == RecordingState.NEW) {\n-                return EMPTY_ARRAY;\n-            }\n+        if (recording.getState() == RecordingState.NEW) {\n+           return EMPTY_ARRAY;\n+        }\n@@ -89,3 +88,3 @@\n-            if (recording.getState() == RecordingState.DELAYED) {\n-                return EMPTY_ARRAY;\n-            }\n+        if (recording.getState() == RecordingState.DELAYED) {\n+            return EMPTY_ARRAY;\n+        }\n@@ -93,6 +92,6 @@\n-            if (first) {\n-                \/\/ In case stream starts before recording\n-                long s = ManagementSupport.getStartTimeNanos(recording);\n-                startTimeNanos = Math.max(s, startTimeNanos);\n-                first = false;\n-            }\n+        if (first) {\n+            \/\/ In case stream starts before recording\n+            long s = ManagementSupport.getStartTimeNanos(recording);\n+            startTimeNanos = Math.max(s, startTimeNanos);\n+            first = false;\n+        }\n@@ -100,0 +99,1 @@\n+        while (true) {\n@@ -174,2 +174,2 @@\n-            if (headerBytes[HEADER_FILE_STATE_POSITION] != MODIFYING_STATE) {\n-                if (equalBytes(bytes, headerBytes, HEADER_SIZE)) {\n+            if (bytes[HEADER_FILE_STATE_POSITION] != MODIFYING_STATE) {\n+                if (bytes[HEADER_FILE_STATE_POSITION] == headerBytes[HEADER_FILE_STATE_POSITION]) {\n@@ -213,9 +213,0 @@\n-    private boolean equalBytes(byte[] a, byte[] b, int size) {\n-        for (int i = 0; i < size; i++) {\n-            if (a[i] != b[i]) {\n-                return false;\n-            }\n-        }\n-        return true;\n-    }\n-\n@@ -235,5 +226,1 @@\n-            if (first) {\n-                path = repositoryFiles.firstPath(startTimeNanos, false);\n-            } else {\n-                path = repositoryFiles.nextPath(startTimeNanos, false);\n-            }\n+            path = repositoryFiles.nextPath(startTimeNanos, false);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/OngoingStream.java","additions":16,"deletions":29,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n@@ -125,1 +125,1 @@\n-    \/\/ Need to check if destination can be set, so FlightRecorderMXBean::setRecordingOption\n+    \/\/ Needed to check if destination can be set, so FlightRecorderMXBean::setRecordingOption\n@@ -135,1 +135,1 @@\n-    \/\/ Need to modify setting using fluent API.\n+    \/\/ Needed to modify setting using fluent API.\n@@ -147,1 +147,1 @@\n-    \/\/ Need callback to detect when a chunk has been parsed.\n+    \/\/ Needed callback to detect when a chunk has been parsed.\n@@ -149,1 +149,2 @@\n-        JdkJfrConsumer.instance().setOnChunkCompleteHandler(stream, consumer);\n+        EventDirectoryStream eds = (EventDirectoryStream) stream;\n+        eds.setChunkCompleteHandler(consumer);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/management\/ManagementSupport.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -286,1 +286,0 @@\n-        raf.seek(position);\n@@ -474,1 +473,1 @@\n-    public void complete() {\n+    public synchronized void complete() {\n","filename":"src\/jdk.management.jfr\/share\/classes\/jdk\/management\/jfr\/DiskRepository.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -108,2 +108,2 @@\n-            \/\/ Should we rely on that Map is created new in the\n-            \/\/ FlightRecorderMXBean implementation?\n+            \/\/ FlightRecorderMXBean implementation always returns\n+            \/\/ new instance of Map so no need to create new here.\n@@ -149,1 +149,1 @@\n-    final Object lock = new Object();\n+    final Instant creationTime;\n@@ -205,1 +205,1 @@\n-        \/\/ Make sure user can't implement malicious version of a Path object.\n+        \/\/ Make sure users can't implement malicious version of a Path object.\n@@ -215,0 +215,1 @@\n+        creationTime = Instant.now();\n@@ -277,1 +278,1 @@\n-            options.put(\"name\", EventByteStream.NAME + \": \" + Instant.now());\n+            options.put(\"name\", EventByteStream.NAME + \": \" + creationTime);\n@@ -555,0 +556,1 @@\n+        downLoadThread.setName(\"JFR: Download Thread \" + creationTime);\n","filename":"src\/jdk.management.jfr\/share\/classes\/jdk\/management\/jfr\/RemoteRecordingStream.java","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -850,0 +850,1 @@\n+jdk\/jfr\/jmx\/streaming\/TestRotate.java                           8257215 generic-all\n","filename":"test\/jdk\/ProblemList.txt","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n- * @summary Tests RecordingStream::close()\n+ * @summary Tests RecordingStream::onMetadata(...)\n","filename":"test\/jdk\/jdk\/jfr\/api\/consumer\/recordingstream\/TestOnMetadata.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n- * @summary Sanity test methods that delegates to an ordinary steam\n+ * @summary Sanity test methods that delegates to an ordinary stream\n","filename":"test\/jdk\/jdk\/jfr\/jmx\/streaming\/TestDelegated.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n- * @summary Tests that a RemoteRecordingStream can be closed\n+ * @summary Tests that event settings for a RemoteRecordingStream can be changed\n","filename":"test\/jdk\/jdk\/jfr\/jmx\/streaming\/TestEnableDisable.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n- * @summary Tests that a RemoteRecordingStream can be closed\n+ * @summary Tests that max size can be set for a RemoteRecordingStream\n","filename":"test\/jdk\/jdk\/jfr\/jmx\/streaming\/TestMaxSize.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n- * @summary Tests that a RemoteRecordingStream can be closed\n+ * @summary Tests that a RemoteRecordingStream can stream over multiple chunks\n","filename":"test\/jdk\/jdk\/jfr\/jmx\/streaming\/TestMultipleChunks.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,48 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.jfr.jmx.streaming;\n-\n-import java.io.IOException;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n-\n-\/**\n- * @test\n- * @key jfr\n- * @summary Tests that directory created by RemoteRecordingStream is removed\n- * @requires vm.hasJFR\n- * @library \/test\/lib \/test\/jdk\n- * @run main\/othervm -Djava.io.tmpdir=. jdk.jfr.jmx.streaming.TestClose\n- *\/\n-public class TestRemoveTempDirectory {\n-\n-    public static void main(String... args) throws IOException {\n-        System.out.println(System.getProperty(\"java.io.tmpdir\"));\n-        Path faked = Files.createTempDirectory(\"jfr-streaming\").toAbsolutePath();\n-        faked = faked.toRealPath();\n-        System.out.println(faked.toString());\n-    }\n-}\n","filename":"test\/jdk\/jdk\/jfr\/jmx\/streaming\/TestRemoveTempDirectory.java","additions":0,"deletions":48,"binary":false,"changes":48,"status":"deleted"}]}