{"files":[{"patch":"@@ -106,2 +106,2 @@\n-  void write_next_generation() {\n-    _writer->be_write(_chunk->next_generation());\n+  void write_next_generation(bool finalize) {\n+    _writer->be_write(finalize ? COMPLETE : _chunk->next_generation());\n@@ -202,1 +202,1 @@\n-  head.write_time(false);\n+  head.write_time(!flushpoint);\n@@ -204,1 +204,1 @@\n-  head.write_next_generation();\n+  head.write_next_generation(!flushpoint);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/repository\/jfrChunkWriter.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,2 @@\n+import jdk.jfr.internal.management.EventSettingsModifier;\n+\n@@ -58,0 +60,20 @@\n+    \/\/ Used to provide EventSettings for jdk.management.jfr module\n+    static class ModifierSettings extends EventSettings {\n+        private final EventSettingsModifier delegate;\n+\n+        ModifierSettings(EventSettingsModifier modifier) {\n+            this.delegate = modifier;\n+        }\n+\n+        @Override\n+        public EventSettings with(String name, String value) {\n+             delegate.with(name, value);\n+             return this;\n+        }\n+\n+        @Override\n+        Map<String, String> toMap() {\n+            return delegate.toMap();\n+        }\n+    }\n+\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/EventSettings.java","additions":23,"deletions":1,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import jdk.jfr.internal.management.EventSettingsModifier;\n@@ -200,0 +201,5 @@\n+\n+        @Override\n+        public EventSettings newEventSettings(EventSettingsModifier esm) {\n+            return new EventSettings.ModifierSettings(esm);\n+        }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/FlightRecorderPermission.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import java.util.Collections;\n@@ -140,1 +141,1 @@\n-        return new EventDirectoryStream(AccessController.getContext(), null, SecuritySupport.PRIVILEGED, null);\n+        return new EventDirectoryStream(AccessController.getContext(), null, SecuritySupport.PRIVILEGED, null, Collections.emptyList());\n@@ -163,1 +164,1 @@\n-        return new EventDirectoryStream(acc, directory, FileAccess.UNPRIVILEGED, null);\n+        return new EventDirectoryStream(acc, directory, FileAccess.UNPRIVILEGED, null, Collections.emptyList());\n@@ -185,0 +186,16 @@\n+    \/**\n+     * Registers an action to perform when new metadata arrives in the stream.\n+     *\n+     * The event type of an event always arrives sometime before the actual event.\n+     * The action must be registered before the stream is started.\n+     *\n+     * @implSpec The default implementation of this method is empty.\n+     *\n+     * @param action to perform, not {@code null}\n+     *\n+     * @throws IllegalStateException if an action is added after the stream has\n+     *                               started\n+     *\/\n+     default void onMetadata(Consumer<MetadataEvent> action) {\n+     }\n+\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/consumer\/EventStream.java","additions":19,"deletions":2,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -0,0 +1,118 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.consumer;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import jdk.jfr.Configuration;\n+import jdk.jfr.EventType;\n+\n+\/**\n+ * Event that contains information about event types and configurations.\n+ *\n+ * @since 16\n+ *\/\n+public final class MetadataEvent {\n+    private final List<EventType> current;\n+    private final List<EventType> previous;\n+    private final List<Configuration> configurations;\n+    private List<EventType> added;\n+    private List<EventType> removed;\n+\n+    \/* package private *\/\n+    MetadataEvent(List<EventType> previous, List<EventType> current, List<Configuration> configs) {\n+        this.previous = previous;\n+        this.current = current;\n+        this.configurations = configs;\n+    }\n+\n+    \/**\n+     * Returns a list of the current event types being used.\n+     *\n+     * @return an immutable list of event types, not {@code null}\n+     *\/\n+    public final List<EventType> getEventTypes() {\n+        return Collections.unmodifiableList(current);\n+    }\n+\n+    \/**\n+     * Returns a list of added event types since the last metadata event.\n+     * <p>\n+     * The delta will be from the last metadata event. If no metadata event has been\n+     * emitted earlier, all known event types will be in the list.\n+     *\n+     * @return an immutable list of added event types, not {@code null}\n+     *\/\n+    public final List<EventType> getAddedEventTypes() {\n+        if (added == null) {\n+            calculateDelta();\n+        }\n+        return added;\n+    }\n+\n+    \/**\n+     * Returns a list of removed event types since the last metadata event.\n+     * <p>\n+     * The delta will be from the last metadata event. If no metadata event has been\n+     * emitted earlier, the list will be empty.\n+     *\n+     * @return an immutable list of added event types, not {@code null}\n+     *\/\n+    public final List<EventType> getRemovedEventTypes() {\n+        if (removed == null) {\n+            calculateDelta();\n+        }\n+        return removed;\n+    }\n+\n+    \/**\n+     * Returns a list of configurations.\n+     *\n+     * @return an immutable list of configurations, not {@code null}\n+     *\/\n+    public List<Configuration> getConfigurations() {\n+        return configurations;\n+    }\n+\n+    private void calculateDelta() {\n+        List<EventType> added = new ArrayList<>();\n+        Map<Long, EventType> previousSet = new HashMap<>(previous.size());\n+        for (EventType eventType : previous) {\n+            previousSet.put(eventType.getId(), eventType);\n+        }\n+        for (EventType eventType : current) {\n+            EventType t = previousSet.remove(eventType.getId());\n+            if (t == null) {\n+                added.add(eventType);\n+            }\n+        }\n+        this.removed = Collections.unmodifiableList(new ArrayList<>(previousSet.values()));\n+        this.added = Collections.unmodifiableList(added);\n+    }\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/consumer\/MetadataEvent.java","additions":118,"deletions":0,"binary":false,"changes":118,"status":"added"},{"patch":"@@ -37,0 +37,1 @@\n+import java.util.function.Consumer;\n@@ -38,0 +39,2 @@\n+import jdk.jfr.Configuration;\n+import jdk.jfr.EventType;\n@@ -41,2 +44,0 @@\n-import jdk.jfr.internal.consumer.JdkJfrConsumer;\n-import jdk.jfr.internal.consumer.ObjectFactory;\n@@ -45,0 +46,2 @@\n+import jdk.jfr.internal.consumer.EventDirectoryStream;\n+import jdk.jfr.internal.consumer.JdkJfrConsumer;\n@@ -46,0 +49,1 @@\n+import jdk.jfr.internal.consumer.ObjectFactory;\n@@ -139,0 +143,12 @@\n+\n+            @Override\n+            public void setOnChunkCompleteHandler(EventStream stream, Consumer<Long> consumer) {\n+                EventDirectoryStream es = (EventDirectoryStream)stream;\n+                es.setChunkCompleteHandler(consumer);\n+            }\n+\n+            @Override\n+            public MetadataEvent newMetadataEvent(List<EventType> previous, List<EventType> current,\n+                    List<Configuration> configurations) {\n+                return new MetadataEvent(previous, current, configurations);\n+            }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/consumer\/RecordedObject.java","additions":18,"deletions":2,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -33,0 +33,2 @@\n+import java.util.Collections;\n+import java.util.List;\n@@ -46,0 +48,1 @@\n+import jdk.jfr.internal.consumer.JdkJfrConsumer;\n@@ -88,1 +91,1 @@\n-            this.directoryStream = new EventDirectoryStream(acc, null, SecuritySupport.PRIVILEGED, pr);\n+            this.directoryStream = new EventDirectoryStream(acc, null, SecuritySupport.PRIVILEGED, pr, configurations());\n@@ -95,0 +98,8 @@\n+    private List<Configuration> configurations() {\n+        try {\n+            return Configuration.getConfigurations();\n+        } catch (Exception e) {\n+            return Collections.emptyList();\n+        }\n+    }\n+\n@@ -364,0 +375,5 @@\n+\n+    @Override\n+    public void onMetadata(Consumer<MetadataEvent> action) {\n+        directoryStream.onMetadata(action);\n+    }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/consumer\/RecordingStream.java","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -89,0 +89,1 @@\n+    private long startNanos = -1;\n@@ -106,1 +107,0 @@\n-        long startNanos = -1;\n@@ -829,0 +829,4 @@\n+    public long getStartNanos() {\n+        return startNanos;\n+    }\n+\n@@ -836,0 +840,14 @@\n+\n+    public void removeBefore(Instant timestamp) {\n+        synchronized (recorder) {\n+            while (!chunks.isEmpty()) {\n+                RepositoryChunk oldestChunk = chunks.peek();\n+                if (!oldestChunk.getEndTime().isBefore(timestamp)) {\n+                    return;\n+                }\n+                chunks.removeFirst();\n+                removed(oldestChunk);\n+            }\n+        }\n+\n+    }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/PlatformRecording.java","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import jdk.jfr.EventSettings;\n@@ -40,0 +41,1 @@\n+import jdk.jfr.internal.management.EventSettingsModifier;\n@@ -101,0 +103,2 @@\n+\n+    public abstract EventSettings newEventSettings(EventSettingsModifier esm);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/PrivateAccess.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -745,0 +745,6 @@\n+    public static Instant epochNanosToInstant(long epochNanos) {\n+        long epochSeconds = epochNanos \/ 1_000_000_000L;\n+        long nanoAdjustment = epochNanos - 1_000_000_000L * epochSeconds;\n+        return Instant.ofEpochSecond(epochSeconds, nanoAdjustment);\n+    }\n+\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/Utils.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,2 @@\n+import java.util.Collections;\n+import java.util.List;\n@@ -38,0 +40,2 @@\n+import jdk.jfr.Configuration;\n+import jdk.jfr.EventType;\n@@ -39,0 +43,1 @@\n+import jdk.jfr.consumer.MetadataEvent;\n@@ -50,1 +55,1 @@\n-abstract class AbstractEventStream implements EventStream {\n+public abstract class AbstractEventStream implements EventStream {\n@@ -58,0 +63,1 @@\n+    private final List<Configuration> configurations;\n@@ -64,1 +70,1 @@\n-    AbstractEventStream(AccessControlContext acc, PlatformRecording recording) throws IOException {\n+    AbstractEventStream(AccessControlContext acc, PlatformRecording recording, List<Configuration> configurations) throws IOException {\n@@ -67,0 +73,1 @@\n+        this.configurations = configurations;\n@@ -275,0 +282,25 @@\n+\n+    @Override\n+    public void onMetadata(Consumer<MetadataEvent> action) {\n+        Objects.requireNonNull(action);\n+        synchronized (configuration) {\n+            if (configuration.started) {\n+                throw new IllegalStateException(\"Stream is already started\");\n+            }\n+        }\n+        configuration.addMetadataAction(action);\n+    }\n+\n+    protected final void emitMetadataEvent(ChunkParser parser) {\n+        if (parser.hasStaleMetadata()) {\n+            if (dispatcher.hasMetadataHandler()) {\n+                List<EventType> ce = parser.getEventTypes();\n+                List<EventType> pe = parser.getPreviousEventTypes();\n+                if (ce != pe) {\n+                    MetadataEvent me = JdkJfrConsumer.instance().newMetadataEvent(pe, ce, configurations);\n+                    dispatcher.runMetadataActions(me);\n+                }\n+                parser.setStaleMetadata(false);\n+            }\n+        }\n+    }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/AbstractEventStream.java","additions":35,"deletions":3,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,9 +37,9 @@\n-    private static final long HEADER_SIZE = 68;\n-    private static final byte UPDATING_CHUNK_HEADER = (byte) 255;\n-    private static final long CHUNK_SIZE_POSITION = 8;\n-    private static final long DURATION_NANOS_POSITION = 40;\n-    private static final long FILE_STATE_POSITION = 64;\n-    private static final long FLAG_BYTE_POSITION = 67;\n-    private static final long METADATA_TYPE_ID = 0;\n-    private static final byte[] FILE_MAGIC = { 'F', 'L', 'R', '\\0' };\n-    private static final int MASK_FINAL_CHUNK = 1 << 1;\n+    static final long HEADER_SIZE = 68;\n+    static final byte UPDATING_CHUNK_HEADER = (byte) 255;\n+    static final long CHUNK_SIZE_POSITION = 8;\n+    static final long DURATION_NANOS_POSITION = 40;\n+    static final long FILE_STATE_POSITION = 64;\n+    static final long FLAG_BYTE_POSITION = 67;\n+    static final long METADATA_TYPE_ID = 0;\n+    static final byte[] FILE_MAGIC = { 'F', 'L', 'R', '\\0' };\n+    static final int MASK_FINAL_CHUNK = 1 << 1;\n@@ -93,2 +93,2 @@\n-        input.readRawLong(); \/\/ chunk size\n-        Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.INFO, \"Chunk: chunkSize=\" + chunkSize);\n+        long c = input.readRawLong(); \/\/ chunk size\n+        Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.INFO, \"Chunk: chunkSize=\" + c);\n@@ -112,1 +112,1 @@\n-    void refresh() throws IOException {\n+    public void refresh() throws IOException {\n@@ -166,0 +166,8 @@\n+    public boolean readHeader(byte[] bytes, int count) throws IOException {\n+        input.position(absoluteChunkStart);\n+        for (int i = 0; i< count; i++) {\n+            bytes[i] = input.readPhysicalByte();\n+        }\n+        return bytes[(int)FILE_STATE_POSITION] != UPDATING_CHUNK_HEADER;\n+    }\n+\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/ChunkHeader.java","additions":21,"deletions":13,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import java.util.Collections;\n@@ -98,1 +99,0 @@\n-    private final MetadataDescriptor metadata;\n@@ -100,1 +100,1 @@\n-    private final MetadataDescriptor previousMetadata;\n+\n@@ -110,0 +110,3 @@\n+    private MetadataDescriptor previousMetadata;\n+    private MetadataDescriptor metadata;\n+    private boolean staleMetadata = true;\n@@ -209,1 +212,2 @@\n-            MetadataDescriptor metadata = chunkHeader.readMetadata(previousMetadata);\n+            this.previousMetadata = this.metadata;\n+            this.metadata = chunkHeader.readMetadata(previousMetadata);\n@@ -214,0 +218,1 @@\n+            setStaleMetadata(true);\n@@ -429,0 +434,8 @@\n+    public List<EventType> getPreviousEventTypes() {\n+        if (previousMetadata == null) {\n+            return Collections.emptyList();\n+        } else {\n+            return previousMetadata.getEventTypes();\n+        }\n+    }\n+\n@@ -459,0 +472,5 @@\n+        try {\n+            input.close();\n+        } catch(IOException e) {\n+           \/\/ ignore\n+        }\n@@ -462,0 +480,11 @@\n+    public long getEndNanos() {\n+        return getStartNanos() + getChunkDuration();\n+    }\n+\n+    public void setStaleMetadata(boolean stale) {\n+        this.staleMetadata = stale;\n+    }\n+\n+    public boolean hasStaleMetadata() {\n+        return staleMetadata;\n+    }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/ChunkParser.java","additions":32,"deletions":3,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,1 @@\n+import jdk.jfr.consumer.MetadataEvent;\n@@ -40,0 +41,2 @@\n+    public final static RecordedEvent FLUSH_MARKER = JdkJfrConsumer.instance().newRecordedEvent(null, null, 0L, 0L);\n+\n@@ -65,0 +68,1 @@\n+    private final Consumer<MetadataEvent>[] metadataActions;\n@@ -84,0 +88,1 @@\n+        this.metadataActions = c.metadataActions.toArray(new Consumer[0]);\n@@ -90,0 +95,5 @@\n+        EventDispatcher[] ed = new EventDispatcher[1];\n+        ed[0] = new EventDispatcher(null, e -> {\n+                runFlushActions();\n+        });\n+        dispatcherLookup.put(1L, ed);\n@@ -92,3 +102,3 @@\n-    public void runFlushActions() {\n-        Runnable[] flushActions = this.flushActions;\n-        for (int i = 0; i < flushActions.length; i++) {\n+    public void runMetadataActions(MetadataEvent event) {\n+        Consumer<MetadataEvent>[] metadataActions = this.metadataActions;\n+        for (int i = 0; i < metadataActions.length; i++) {\n@@ -96,1 +106,1 @@\n-                flushActions[i].run();\n+                metadataActions[i].accept(event);\n@@ -103,0 +113,11 @@\n+    public void runFlushActions() {\n+         Runnable[] flushActions = this.flushActions;\n+         for (int i = 0; i < flushActions.length; i++) {\n+             try {\n+                 flushActions[i].run();\n+             } catch (Exception e) {\n+                 handleError(e);\n+             }\n+         }\n+    }\n+\n@@ -188,0 +209,4 @@\n+\n+    public boolean hasMetadataHandler() {\n+        return metadataActions.length > 0;\n+    }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/Dispatcher.java","additions":30,"deletions":5,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+import java.time.Duration;\n@@ -34,0 +35,1 @@\n+import java.util.List;\n@@ -35,0 +37,1 @@\n+import java.util.function.Consumer;\n@@ -36,0 +39,1 @@\n+import jdk.jfr.Configuration;\n@@ -59,0 +63,2 @@\n+    protected volatile long maxSize;\n+    protected volatile Duration maxAge;\n@@ -60,2 +66,4 @@\n-    public EventDirectoryStream(AccessControlContext acc, Path p, FileAccess fileAccess, PlatformRecording recording) throws IOException {\n-        super(acc, recording);\n+    private volatile Consumer<Long> onCompleteHandler;\n+\n+    public EventDirectoryStream(AccessControlContext acc, Path p, FileAccess fileAccess, PlatformRecording recording, List<Configuration> configurations) throws IOException {\n+        super(acc, recording, configurations);\n@@ -74,0 +82,12 @@\n+            onComplete(currentParser.getEndNanos());\n+        }\n+    }\n+\n+    public void setChunkCompleteHandler(Consumer<Long> handler) {\n+        onCompleteHandler = handler;\n+    }\n+\n+    private void onComplete(long epochNanos) {\n+        Consumer<Long> handler = onCompleteHandler;\n+        if (handler != null) {\n+            handler.accept(epochNanos);\n@@ -113,1 +133,1 @@\n-            path = repositoryFiles.firstPath(disp.startNanos);\n+            path = repositoryFiles.firstPath(disp.startNanos, true);\n@@ -115,1 +135,1 @@\n-            path = repositoryFiles.lastPath();\n+            path = repositoryFiles.lastPath(true);\n@@ -125,1 +145,1 @@\n-            long filterEnd = disp.endTime != null ? disp.endNanos: Long.MAX_VALUE;\n+            long filterEnd = disp.endTime != null ? disp.endNanos : Long.MAX_VALUE;\n@@ -128,0 +148,1 @@\n+                emitMetadataEvent(currentParser);\n@@ -162,0 +183,1 @@\n+                long endChunkNanos = currentParser.getEndNanos();\n@@ -167,1 +189,1 @@\n-                path = repositoryFiles.nextPath(currentChunkStartNanos + durationNanos);\n+                path = repositoryFiles.nextPath(currentChunkStartNanos + durationNanos, true);\n@@ -173,0 +195,1 @@\n+                onComplete(endChunkNanos);\n@@ -202,0 +225,1 @@\n+        emitMetadataEvent(currentParser);\n@@ -220,0 +244,1 @@\n+                emitMetadataEvent(currentParser);\n@@ -227,0 +252,7 @@\n+    public void setMaxSize(long maxSize)  {\n+        this.maxSize = maxSize;\n+    }\n+\n+    public void setMaxAge(Duration maxAge)  {\n+        this.maxAge = maxAge;\n+    }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/EventDirectoryStream.java","additions":39,"deletions":7,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import java.util.Collections;\n@@ -34,1 +35,0 @@\n-\n@@ -50,1 +50,1 @@\n-        super(acc, null);\n+        super(acc, null, Collections.emptyList());\n@@ -90,0 +90,1 @@\n+            emitMetadataEvent(currentParser);\n@@ -119,0 +120,7 @@\n+            if (event == Dispatcher.FLUSH_MARKER) {\n+                emitMetadataEvent(currentParser);\n+                dispatchOrdered(c, index);\n+                index = 0;\n+                continue;\n+            }\n+\n@@ -120,4 +128,2 @@\n-                Arrays.sort(cacheSorted, 0, index, EVENT_COMPARATOR);\n-                for (int i = 0; i < index; i++) {\n-                    c.dispatch(cacheSorted[i]);\n-                }\n+                emitMetadataEvent(currentParser);\n+                dispatchOrdered(c, index);\n@@ -135,0 +141,7 @@\n+    private void dispatchOrdered(Dispatcher c, int index) {\n+        Arrays.sort(cacheSorted, 0, index, EVENT_COMPARATOR);\n+        for (int i = 0; i < index; i++) {\n+            c.dispatch(cacheSorted[i]);\n+        }\n+    }\n+\n@@ -139,0 +152,1 @@\n+                emitMetadataEvent(currentParser);\n@@ -141,1 +155,3 @@\n-            c.dispatch(event);\n+            if (event != Dispatcher.FLUSH_MARKER) {\n+                c.dispatch(event);\n+            }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/EventFileStream.java","additions":23,"deletions":7,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -0,0 +1,66 @@\n+\/*\n+ * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.internal.consumer;\n+\n+import java.io.BufferedInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+\n+import jdk.jfr.internal.management.EventByteStream;\n+\n+public final class FinishedStream extends EventByteStream {\n+    private final BufferedInputStream inputStream;\n+    private final byte[] buffer;\n+\n+    public FinishedStream(InputStream is, int blockSize) {\n+        super();\n+        this.inputStream = new BufferedInputStream(is, 50000);\n+        this.buffer = new byte[blockSize];\n+    }\n+\n+    public synchronized byte[] read() throws IOException {\n+        \/\/ OK to reuse buffer since this\n+        \/\/ is only used for serialization\n+        touch();\n+        int read = inputStream.read(buffer);\n+        if (read == -1) {\n+            \/\/ null indicate no more data\n+            return null;\n+        }\n+        if (read != buffer.length) {\n+            byte[] smallerBuffer = new byte[read];\n+            System.arraycopy(buffer, 0, smallerBuffer, 0, read);\n+            return smallerBuffer;\n+        }\n+\n+        return buffer;\n+    }\n+\n+    @Override\n+    public synchronized void close() throws IOException {\n+        inputStream.close();\n+    }\n+\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/FinishedStream.java","additions":66,"deletions":0,"binary":false,"changes":66,"status":"added"},{"patch":"@@ -31,0 +31,1 @@\n+import java.util.function.Consumer;\n@@ -32,0 +33,4 @@\n+import jdk.jfr.Configuration;\n+import jdk.jfr.EventType;\n+import jdk.jfr.consumer.EventStream;\n+import jdk.jfr.consumer.MetadataEvent;\n@@ -43,0 +48,1 @@\n+\n@@ -101,0 +107,5 @@\n+\n+    public abstract void setOnChunkCompleteHandler(EventStream stream, Consumer<Long> consumer);\n+\n+    public abstract MetadataEvent newMetadataEvent(List<EventType> previous, List<EventType> current, List<Configuration> configuration);\n+\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/JdkJfrConsumer.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,252 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.internal.consumer;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Path;\n+import java.time.Instant;\n+\n+import jdk.jfr.Recording;\n+import jdk.jfr.RecordingState;\n+import jdk.jfr.internal.Utils;\n+import jdk.jfr.internal.SecuritySupport;\n+import jdk.jfr.internal.SecuritySupport.SafePath;\n+import jdk.jfr.internal.management.EventByteStream;\n+import jdk.jfr.internal.management.ManagementSupport;\n+\n+public final class OngoingStream extends EventByteStream {\n+\n+    private static final byte[] EMPTY_ARRAY = new byte[0];\n+    private static final int HEADER_SIZE = (int)ChunkHeader.HEADER_SIZE;\n+    private static final int HEADER_FILE_STATE_POSITION = (int)ChunkHeader.FILE_STATE_POSITION;\n+    private static final byte MODIFYING_STATE = ChunkHeader.UPDATING_CHUNK_HEADER;\n+\n+    private final RepositoryFiles repositoryFiles;\n+    private final Recording recording;\n+    private final int blockSize;\n+    private final long endTimeNanos;\n+    private final byte[] headerBytes = new byte[HEADER_SIZE];\n+\n+    private RecordingInput input;\n+    private ChunkHeader header;\n+    private long position;\n+    private long startTimeNanos;\n+    private Path path;\n+    private boolean first = true;\n+\n+    public OngoingStream(Recording recording, int blockSize, long startTimeNanos, long endTimeNanos) {\n+        super();\n+        this.recording = recording;\n+        this.blockSize = blockSize;\n+        this.startTimeNanos = startTimeNanos;\n+        this.endTimeNanos = endTimeNanos;\n+        this.repositoryFiles = new RepositoryFiles(SecuritySupport.PRIVILEGED, null);\n+    }\n+\n+    public synchronized byte[] read() throws IOException {\n+        try {\n+            return readBytes();\n+        } catch (IOException ioe) {\n+            if (recording.getState() == RecordingState.CLOSED) {\n+                \/\/ Recording closed, return null;\n+                return null;\n+            }\n+            \/\/ Something unexpected has happened.\n+            throw ioe;\n+        }\n+    }\n+\n+    private byte[] readBytes() throws IOException {\n+        touch();\n+        while (true) {\n+            if (recording.getState() == RecordingState.NEW) {\n+                return EMPTY_ARRAY;\n+            }\n+\n+            if (recording.getState() == RecordingState.DELAYED) {\n+                return EMPTY_ARRAY;\n+            }\n+\n+            if (first) {\n+                \/\/ In case stream starts before recording\n+                long s = ManagementSupport.getStartTimeNanos(recording);\n+                startTimeNanos = Math.max(s, startTimeNanos);\n+                first = false;\n+            }\n+\n+            if (startTimeNanos > endTimeNanos) {\n+                return null;\n+            }\n+            if (isRecordingClosed()) {\n+                closeInput();\n+                return null;\n+            }\n+            if (!ensurePath()) {\n+                return EMPTY_ARRAY;\n+            }\n+            if (!ensureInput()) {\n+                return EMPTY_ARRAY;\n+            }\n+            if (position < header.getChunkSize()) {\n+                long size = Math.min(header.getChunkSize() - position, blockSize);\n+                return readBytes((int) size);\n+            }\n+            if (header.isFinished()) {\n+                if (header.getDurationNanos() < 1) {\n+                    throw new IOException(\"No progress\");\n+                }\n+                startTimeNanos += header.getDurationNanos();\n+                Instant timestamp = Utils.epochNanosToInstant(startTimeNanos);\n+                ManagementSupport.removeBefore(recording, timestamp);\n+                closeInput();\n+            } else {\n+                header.refresh();\n+                if (position >= header.getChunkSize()) {\n+                    return EMPTY_ARRAY;\n+                }\n+            }\n+        }\n+    }\n+\n+    private boolean isRecordingClosed() {\n+        return recording != null && recording.getState() == RecordingState.CLOSED;\n+    }\n+\n+    private void closeInput() {\n+        if (input != null) {\n+            try {\n+                input.close();\n+            } catch (IOException ioe) {\n+                \/\/ ignore\n+            }\n+            input = null;\n+            position = 0;\n+            path = null;\n+        }\n+    }\n+\n+    private byte[] readBytes(int size) throws IOException {\n+        if (position == 0) {\n+            return readWithHeader(size);\n+        } else {\n+            return readNonHeader(size);\n+        }\n+    }\n+\n+    private byte[] readNonHeader(int size) throws IOException {\n+        byte[] result = new byte[size];\n+        input.readFully(result);\n+        position += size;\n+        return result;\n+    }\n+\n+    private byte[] readWithHeader(int size) throws IOException {\n+        byte[] bytes = new byte[Math.max(HEADER_SIZE, size)];\n+        for (int attempts = 0; attempts < 25; attempts++) {\n+            \/\/ read twice and check files state to avoid simultaneous change by JVM\n+            input.position(0);\n+            input.readFully(bytes, 0, HEADER_SIZE);\n+            input.position(0);\n+            input.readFully(headerBytes);\n+            if (headerBytes[HEADER_FILE_STATE_POSITION] != MODIFYING_STATE) {\n+                if (equalBytes(bytes, headerBytes, HEADER_SIZE)) {\n+                    ByteBuffer buffer = ByteBuffer.wrap(bytes);\n+                    \/\/ 0-3: magic\n+                    \/\/ 4-5: major\n+                    \/\/ 6-7: minor\n+                    \/\/ 8-15: chunk size\n+                    buffer.putLong(8, HEADER_SIZE);\n+                    \/\/ 16-23: constant pool offset\n+                    buffer.putLong(16, 0);\n+                    \/\/ 24-31: metadata offset\n+                    buffer.putLong(24, 0);\n+                    \/\/ 32-39: chunk start nanos\n+                    \/\/ 40-47 duration\n+                    buffer.putLong(40, 0);\n+                    \/\/ 48-55: chunk start ticks\n+                    \/\/ 56-63: ticks per second\n+                    \/\/ 64: file state\n+                    buffer.put(64, (byte) 1);\n+                    \/\/ 65-67: extension bit\n+                    int left = bytes.length - HEADER_SIZE;\n+                    input.readFully(bytes, HEADER_SIZE, left);\n+                    position += bytes.length;\n+                    return bytes;\n+                }\n+            }\n+            takeNap();\n+        }\n+        return EMPTY_ARRAY;\n+    }\n+\n+    private void takeNap() throws IOException {\n+        try {\n+            Thread.sleep(10);\n+        } catch (InterruptedException ie) {\n+            throw new IOException(\"Read operation interrupted\", ie);\n+        }\n+    }\n+\n+    private boolean equalBytes(byte[] a, byte[] b, int size) {\n+        for (int i = 0; i < size; i++) {\n+            if (a[i] != b[i]) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    private boolean ensureInput() throws IOException {\n+        if (input == null) {\n+            if (SecuritySupport.getFileSize(new SafePath(path)) < HEADER_SIZE) {\n+                return false;\n+            }\n+            input = new RecordingInput(path.toFile(), SecuritySupport.PRIVILEGED);\n+            header = new ChunkHeader(input);\n+        }\n+        return true;\n+    }\n+\n+    private boolean ensurePath() {\n+        if (path == null) {\n+            if (first) {\n+                path = repositoryFiles.firstPath(startTimeNanos, false);\n+            } else {\n+                path = repositoryFiles.nextPath(startTimeNanos, false);\n+            }\n+        }\n+        return path != null;\n+    }\n+\n+    @Override\n+    public synchronized void close() throws IOException {\n+        closeInput();\n+        \/\/ Close recording if stream times out.\n+        if (recording.getName().startsWith(EventByteStream.NAME)) {\n+            recording.close();\n+        }\n+    }\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/OngoingStream.java","additions":252,"deletions":0,"binary":false,"changes":252,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -221,1 +221,4 @@\n-        file.close();\n+        RandomAccessFile ra = file;\n+        if (ra != null) {\n+            ra.close();\n+        }\n@@ -429,4 +432,0 @@\n-\/*\n-\n-\n-\n@@ -434,4 +433,0 @@\n-\n- *\n- *\n- *\/\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/RecordingInput.java","additions":5,"deletions":10,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -64,1 +64,1 @@\n-    RepositoryFiles(FileAccess fileAccess, Path repository) {\n+    public RepositoryFiles(FileAccess fileAccess, Path repository) {\n@@ -74,2 +74,2 @@\n-    Path lastPath() {\n-        if (waitForPaths()) {\n+    public Path lastPath(boolean wait) {\n+        if (updatePaths(wait)) {\n@@ -81,2 +81,2 @@\n-    Path firstPath(long startTimeNanos) {\n-        if (waitForPaths()) {\n+    public Path firstPath(long startTimeNanos, boolean wait) {\n+        if (updatePaths(wait)) {\n@@ -88,1 +88,1 @@\n-            return path(startTimeNanos);\n+            return path(startTimeNanos, wait);\n@@ -93,1 +93,2 @@\n-    private boolean waitForPaths() {\n+    private boolean updatePaths(boolean wait) {\n+        int beforeSize = pathLookup.size();\n@@ -106,1 +107,5 @@\n-            nap();\n+            if (wait) {\n+                nap();\n+            } else {\n+                return pathLookup.size() > beforeSize;\n+            }\n@@ -111,1 +116,1 @@\n-    Path nextPath(long startTimeNanos) {\n+    public Path nextPath(long startTimeNanos, boolean wait) {\n@@ -130,1 +135,1 @@\n-        return path(startTimeNanos);\n+        return path(startTimeNanos, wait);\n@@ -133,1 +138,1 @@\n-    private Path path(long timestamp) {\n+    private Path path(long timestamp, boolean wait) {\n@@ -146,1 +151,1 @@\n-            if (!waitForPaths()) {\n+            if (!updatePaths(wait)) {\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/RepositoryFiles.java","additions":18,"deletions":13,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+import jdk.jfr.consumer.MetadataEvent;\n@@ -42,0 +43,1 @@\n+    final List<Consumer<MetadataEvent>> metadataActions = new ArrayList<>();\n@@ -59,0 +61,1 @@\n+        removed |= metadataActions.removeIf(e -> e == action);\n@@ -87,0 +90,5 @@\n+    }\n+\n+    public synchronized void addMetadataAction(Consumer<MetadataEvent> action) {\n+        metadataActions.add(action);\n+        changed = true;\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/StreamConfiguration.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,71 @@\n+\/*\n+ * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.internal.management;\n+\n+import java.io.Closeable;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+import jdk.jfr.Recording;\n+import jdk.jfr.internal.consumer.FinishedStream;\n+import jdk.jfr.internal.consumer.OngoingStream;\n+\n+\/\/ abstract class that hides if a recording is ongoing or finished.\n+public abstract class EventByteStream implements Closeable {\n+    public static final String NAME = \"Remote Recording Stream\";\n+    private static AtomicLong idCounter = new AtomicLong();\n+\n+    private final long identifier;\n+    private volatile long time;\n+\n+    public EventByteStream() {\n+        this.identifier = idCounter.incrementAndGet();\n+    }\n+\n+    public static EventByteStream newOngoingStream(Recording recording, int blockSize, long  startTimeNanos,long endTimeNanos) {\n+        return new OngoingStream(recording, blockSize, startTimeNanos, endTimeNanos);\n+    }\n+\n+    public static EventByteStream newFinishedStream(InputStream is, int blockSize) {\n+        return new FinishedStream(is, blockSize);\n+    }\n+\n+    final protected void touch() {\n+        time = System.currentTimeMillis();\n+    }\n+\n+    final public long getLastTouched() {\n+        return time;\n+    }\n+\n+    abstract public byte[] read() throws IOException;\n+\n+    final public long getId() {\n+        return identifier;\n+    }\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/management\/EventByteStream.java","additions":71,"deletions":0,"binary":false,"changes":71,"status":"added"},{"patch":"@@ -0,0 +1,40 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.internal.management;\n+\n+import java.util.Map;\n+\n+\/**\n+ * Purpose of the interface is to be able to provide an implementation of\n+ * EventSettings in the jdk.management.jfr module.\n+ *\n+ *\/\n+public interface EventSettingsModifier {\n+\n+    void with(String name, String value);\n+\n+    Map<String, String> toMap();\n+\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/management\/EventSettingsModifier.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"added"},{"patch":"@@ -29,0 +29,1 @@\n+import java.nio.file.Path;\n@@ -31,0 +32,1 @@\n+import java.time.Instant;\n@@ -34,0 +36,3 @@\n+import java.util.Map;\n+import java.util.function.Consumer;\n+import java.security.AccessControlContext;\n@@ -35,0 +40,2 @@\n+import jdk.jfr.Configuration;\n+import jdk.jfr.EventSettings;\n@@ -37,0 +44,1 @@\n+import jdk.jfr.consumer.EventStream;\n@@ -46,0 +54,3 @@\n+import jdk.jfr.internal.consumer.EventDirectoryStream;\n+import jdk.jfr.internal.consumer.FileAccess;\n+import jdk.jfr.internal.consumer.JdkJfrConsumer;\n@@ -86,0 +97,5 @@\n+    \/\/ Reuse internal code for converting nanoseconds since epoch to Instant\n+    public static Instant epochNanosToInstant(long epochNanos) {\n+      return Utils.epochNanosToInstant(epochNanos);\n+    }\n+\n@@ -96,0 +112,5 @@\n+    \/\/ Reuse internal logging mechanism\n+    public static void logDebug(String message) {\n+        Logger.log(LogTag.JFR, LogLevel.DEBUG, message);\n+    }\n+\n@@ -104,0 +125,2 @@\n+    \/\/ Need to check if destination can be set, so FlightRecorderMXBean::setRecordingOption\n+    \/\/ can abort if not all data is valid\n@@ -111,0 +134,40 @@\n+\n+    \/\/ Need to modify setting using fluent API.\n+    public static EventSettings newEventSettings(EventSettingsModifier esm) {\n+        return PrivateAccess.getInstance().newEventSettings(esm);\n+    }\n+\n+    \/\/ When streaming an ongoing recording, consumed chunks should be removed\n+    public static void removeBefore(Recording recording, Instant timestamp) {\n+        PlatformRecording pr = PrivateAccess.getInstance().getPlatformRecording(recording);\n+        pr.removeBefore(timestamp);\n+\n+    }\n+\n+    \/\/ Need callback to detect when a chunk has been parsed.\n+    public static void setOnChunkCompleteHandler(EventStream stream, Consumer<Long> consumer) {\n+        JdkJfrConsumer.instance().setOnChunkCompleteHandler(stream, consumer);\n+    }\n+\n+    \/\/ Needed to start an ongoing stream at the right chunk, which\n+    \/\/ can be identified by the start time with nanosecond precision.\n+    public static long getStartTimeNanos(Recording recording) {\n+        PlatformRecording pr = PrivateAccess.getInstance().getPlatformRecording(recording);\n+        return pr.getStartNanos();\n+    }\n+\n+    \/\/ Needed to produce Configuration objects for MetadataEvent\n+    public static Configuration newConfiguration(String name, String label, String description, String provider,\n+          Map<String, String> settings, String contents) {\n+        return PrivateAccess.getInstance().newConfiguration(name, label, description, provider, settings, contents);\n+    }\n+\n+    \/\/ Can't use EventStream.openRepository(...) because\n+    \/\/ EventStream::onMetadataData need to supply MetadataEvent\n+    \/\/ with configuration objects\n+    public static EventStream newEventDirectoryStream(\n+            AccessControlContext acc,\n+            Path directory,\n+            List<Configuration> confs) throws IOException {\n+        return new EventDirectoryStream(acc, directory, FileAccess.UNPRIVILEGED, null, confs);\n+    }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/management\/ManagementSupport.java","additions":63,"deletions":0,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -0,0 +1,51 @@\n+\/*\n+ * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.internal.management;\n+\n+import java.util.TimerTask;\n+\n+\/\/ Helper class to StreamManager\n+final class StreamCleanupTask extends TimerTask {\n+\n+    private final EventByteStream stream;\n+    private final StreamManager manager;\n+\n+    StreamCleanupTask(StreamManager streamManager, EventByteStream stream) {\n+        this.stream = stream;\n+        this.manager = streamManager;\n+    }\n+\n+    @Override\n+    public void run() {\n+        long lastTouched = stream.getLastTouched();\n+        long now = System.currentTimeMillis();\n+        if (now - lastTouched >= StreamManager.TIME_OUT) {\n+            manager.destroy(stream);\n+        } else {\n+            manager.scheduleAbort(stream, lastTouched + StreamManager.TIME_OUT);\n+        }\n+    }\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/management\/StreamCleanupTask.java","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -0,0 +1,102 @@\n+\/*\n+ * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.internal.management;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.time.Instant;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Timer;\n+import java.util.concurrent.TimeUnit;\n+\n+import jdk.jfr.Recording;\n+import jdk.jfr.internal.consumer.FinishedStream;\n+import jdk.jfr.internal.consumer.OngoingStream;\n+\n+\/\/ Exposes EventByteStreams to the FlightRecorderMXBean\n+public final class StreamManager {\n+\n+    public static final long TIME_OUT = TimeUnit.MINUTES.toMillis(200);\n+    public static final int DEFAULT_BLOCK_SIZE = 50000;\n+\n+    private final Map<Long, EventByteStream> streams = new HashMap<>();\n+    private Timer timer;\n+\n+    public synchronized EventByteStream getStream(long streamIdentifer) {\n+        EventByteStream stream = streams.get(streamIdentifer);\n+        if (stream == null) {\n+            throw new IllegalArgumentException(\"Unknown stream identifier \" + streamIdentifer);\n+        }\n+        return stream;\n+    }\n+\n+    public synchronized EventByteStream createOngoing(Recording recording, int blockSize, Instant startTime, Instant endTime) {\n+        long startTimeNanos = 0;\n+        long endTimeNanos = Long.MAX_VALUE;\n+        if (!startTime.equals(Instant.MIN)) {\n+           startTimeNanos = startTime.getEpochSecond() * 1_000_000_000L;\n+           startTimeNanos += startTime.getNano();\n+        }\n+        if (!endTime.equals(Instant.MAX)) {\n+            endTimeNanos =  endTime.getEpochSecond() * 1_000_000_000L;\n+            endTimeNanos+= endTime.getNano();\n+        }\n+        EventByteStream stream = EventByteStream.newOngoingStream(recording, blockSize, startTimeNanos, endTimeNanos);\n+        streams.put(stream.getId(), stream);\n+        scheduleAbort(stream, System.currentTimeMillis() + TIME_OUT);\n+        return stream;\n+    }\n+\n+    public synchronized EventByteStream create(InputStream is, int blockSize) {\n+        EventByteStream stream = EventByteStream.newFinishedStream(is, blockSize);\n+        streams.put(stream.getId(), stream);\n+\n+        scheduleAbort(stream, System.currentTimeMillis() + TIME_OUT);\n+        return stream;\n+    }\n+\n+    public synchronized void destroy(EventByteStream stream) {\n+        try {\n+            stream.close();\n+        } catch (IOException e) {\n+            \/\/ OK\n+        }\n+        streams.remove(stream.getId());\n+        if (streams.isEmpty()) {\n+            timer.cancel();\n+            timer = null;\n+        }\n+    }\n+\n+    public synchronized void scheduleAbort(EventByteStream s, long when) {\n+        if (timer == null) {\n+            timer = new Timer(true);\n+        }\n+        timer.schedule(new StreamCleanupTask(this, s), new Date(when + TIME_OUT));\n+    }\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/management\/StreamManager.java","additions":102,"deletions":0,"binary":false,"changes":102,"status":"added"},{"patch":"@@ -0,0 +1,483 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.management.jfr;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.io.RandomAccessFile;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.time.LocalDateTime;\n+import java.time.OffsetDateTime;\n+import java.time.ZoneOffset;\n+import java.util.ArrayDeque;\n+import java.util.Deque;\n+import java.util.Iterator;\n+import java.util.Objects;\n+\n+import jdk.jfr.internal.management.ManagementSupport;\n+\n+final class DiskRepository implements Closeable {\n+\n+    final static class DiskChunk {\n+        final Path path;\n+        final Instant startTime;\n+        Instant endTime;\n+        long size;\n+\n+        DiskChunk(Path path, long startNanos) {\n+            this.path = path;\n+            this.startTime = ManagementSupport.epochNanosToInstant(startNanos);\n+        }\n+    }\n+\n+    enum State {\n+        HEADER, EVENT_SIZE, EVENT_TYPE, CHECKPOINT_EVENT_TIMESTAMP, CHECKPOINT_EVENT_DURATION, CHECKPOINT_EVENT_DELTA,\n+        CHECKPOINT_EVENT_FLUSH_TYPE, CHECKPOINT_EVENT_POOL_COUNT, CHECKPOINT_EVENT_HEADER_TYPE,\n+        CHECKPOINT_EVENT_HEADER_ITEM_COUNT, CHECKPOINT_EVENT_HEADER_KEY, CHECKPOINT_EVENT_HEADER_BYTE_ARRAY_LENGTH,\n+        CHECKPOINT_EVENT_HEADER_BYTE_ARRAY_CONTENT, EVENT_PAYLOAD;\n+\n+        public State next() {\n+            return State.values()[ordinal() + 1];\n+        }\n+    }\n+\n+    static final byte CHECKPOINT_WITH_HEADER = (byte) 2;\n+    static final byte MODIFYING_STATE = (byte) 255;\n+    static final byte COMPLETE_STATE = (byte) 0;\n+    static final int HEADER_FILE_STATE_POSITION = 64;\n+    static final int HEADER_START_NANOS_POSITION = 32;\n+    static final int HEADER_SIZE = 68;\n+    static final int HEADER_FILE_DURATION = 40;\n+\n+    private final Deque<DiskChunk> activeChunks = new ArrayDeque<>();\n+    private final Deque<DiskChunk> deadChunks = new ArrayDeque<>();\n+    private final boolean deleteDirectory;\n+    private final ByteBuffer buffer = ByteBuffer.allocate(256);\n+    private final Path directory;\n+\n+    private RandomAccessFile raf;\n+    private RandomAccessFile previousRAF;\n+    private byte previousRAFstate;\n+    private int index;\n+    private int bufferIndex;\n+    private State state = State.HEADER;\n+    private byte[] currentByteArray;\n+    private int typeId;\n+    private int typeIdshift;\n+    private int sizeShift;\n+    private int payLoadSize;\n+    private int longValueshift;\n+    private int eventFieldSize;\n+    private int lastFlush;\n+    private DiskChunk currentChunk;\n+    private Duration maxAge;\n+    private long maxSize;\n+    private long size;\n+\n+    public DiskRepository(Path path, boolean deleteDirectory) throws IOException {\n+        this.directory = path;\n+        this.deleteDirectory = deleteDirectory;\n+    }\n+\n+    public synchronized void write(byte[] bytes) throws IOException {\n+        index = 0;\n+        lastFlush = 0;\n+        currentByteArray = bytes;\n+        while (index < bytes.length) {\n+            switch (state) {\n+            case HEADER:\n+                processInitialHeader();\n+                break;\n+            case EVENT_SIZE:\n+                processEventSize();\n+                break;\n+            case EVENT_TYPE:\n+                processEventTypeId();\n+                break;\n+            case CHECKPOINT_EVENT_TIMESTAMP:\n+            case CHECKPOINT_EVENT_DURATION:\n+            case CHECKPOINT_EVENT_DELTA:\n+            case CHECKPOINT_EVENT_POOL_COUNT:\n+            case CHECKPOINT_EVENT_HEADER_TYPE:\n+            case CHECKPOINT_EVENT_HEADER_ITEM_COUNT:\n+            case CHECKPOINT_EVENT_HEADER_KEY:\n+            case CHECKPOINT_EVENT_HEADER_BYTE_ARRAY_LENGTH:\n+                processNumericValueInEvent();\n+                bufferIndex = 0;\n+                break;\n+            case CHECKPOINT_EVENT_HEADER_BYTE_ARRAY_CONTENT:\n+                processCheckPointHeader();\n+                break;\n+            case CHECKPOINT_EVENT_FLUSH_TYPE:\n+                processFlush();\n+                break;\n+            case EVENT_PAYLOAD:\n+                processEvent();\n+                break;\n+            default:\n+                break;\n+            }\n+        }\n+        \/\/ Don't write before header\/file is complete\n+        if (raf == null) {\n+            return;\n+        }\n+        flush();\n+    }\n+\n+    private void processFlush() throws IOException {\n+        byte b = nextByte(true);\n+        if ((b & CHECKPOINT_WITH_HEADER) != 0) {\n+            state = State.CHECKPOINT_EVENT_POOL_COUNT;\n+        } else {\n+            state = State.EVENT_PAYLOAD;\n+        }\n+    }\n+\n+    private void processNumericValueInEvent() {\n+        int b = nextByte(true);\n+        \/\/ longValue += (((long) (b & 0x7FL)) << longValueshift);\n+        if (b >= 0 || longValueshift == 56) {\n+            state = state.next();\n+            \/\/ longValue = 0;\n+            longValueshift = 0;\n+        } else {\n+            longValueshift += 7;\n+        }\n+    }\n+\n+    private void processEvent() {\n+        int left = currentByteArray.length - index;\n+        if (left >= payLoadSize) {\n+            index += payLoadSize;\n+            payLoadSize = 0;\n+            state = State.EVENT_SIZE;\n+        } else {\n+            index += left;\n+            payLoadSize -= left;\n+        }\n+    }\n+\n+    private void processEventTypeId() {\n+        byte b = nextByte(true);\n+        long v = (b & 0x7FL);\n+        typeId += (v << typeIdshift);\n+        if (b >= 0) {\n+            if (typeId == 1) {\n+                state = State.CHECKPOINT_EVENT_TIMESTAMP;\n+            } else {\n+                state = State.EVENT_PAYLOAD;\n+            }\n+            typeIdshift = 0;\n+            typeId = 0;\n+        } else {\n+            typeIdshift += 7;\n+        }\n+    }\n+\n+    private void processEventSize() throws IOException {\n+        \/\/ End of chunk\n+        if (previousRAF != null) {\n+            flush();\n+            state = State.HEADER;\n+            return;\n+        }\n+\n+        eventFieldSize++;\n+        byte b = nextByte(false);\n+        long v = (b & 0x7FL);\n+        payLoadSize += (v << sizeShift);\n+        if (b >= 0) {\n+            if (payLoadSize == 0) {\n+                throw new IOException(\"Event size can't be null.\" + index);\n+            }\n+            state = State.EVENT_TYPE;\n+            sizeShift = 0;\n+            payLoadSize -= eventFieldSize;\n+            eventFieldSize = 0;\n+        } else {\n+            sizeShift += 7;\n+        }\n+    }\n+\n+    private void processInitialHeader() throws IOException {\n+        buffer.put(bufferIndex, nextByte(false));\n+        if (bufferIndex == HEADER_SIZE) {\n+            writeInitialHeader();\n+            state = State.EVENT_SIZE;\n+            bufferIndex = 0;\n+            if (index != lastFlush + HEADER_SIZE) {\n+                throw new IOException(\"Expected data before header to be flushed\");\n+            }\n+            lastFlush = index;\n+        }\n+    }\n+\n+    private void processCheckPointHeader() throws IOException {\n+        buffer.put(bufferIndex, nextByte(true));\n+        if (bufferIndex == HEADER_SIZE) {\n+            writeCheckPointHeader();\n+            state = State.EVENT_PAYLOAD;\n+            bufferIndex = 0;\n+        }\n+    }\n+\n+    private void writeInitialHeader() throws IOException {\n+        DiskChunk previous = currentChunk;\n+        currentChunk = nextChunk();\n+        raf = new RandomAccessFile(currentChunk.path.toFile(), \"rw\");\n+        byte fileState = buffer.get(HEADER_FILE_STATE_POSITION);\n+        buffer.put(HEADER_FILE_STATE_POSITION, MODIFYING_STATE);\n+        raf.write(buffer.array(), 0, HEADER_SIZE);\n+        \/\/ Complete previous chunk\n+        completePrevious(previous);\n+\n+        raf.seek(HEADER_FILE_STATE_POSITION);\n+        raf.writeByte(fileState);\n+        raf.seek(HEADER_SIZE);\n+    }\n+\n+    private void completePrevious(DiskChunk previous) throws IOException {\n+        if (previousRAF != null) {\n+            previousRAF.seek(HEADER_FILE_STATE_POSITION);\n+            previousRAF.writeByte(previousRAFstate);\n+            previousRAF.close();\n+            addChunk(previous);\n+            previousRAF = null;\n+            previousRAFstate = (byte) 0;\n+        }\n+    }\n+\n+    private void writeCheckPointHeader() throws IOException {\n+        Objects.requireNonNull(raf);\n+        byte state = buffer.get(HEADER_FILE_STATE_POSITION);\n+        boolean complete = state == COMPLETE_STATE;\n+        buffer.put(HEADER_FILE_STATE_POSITION, MODIFYING_STATE);\n+        flush();\n+        long position = raf.getFilePointer();\n+        raf.seek(HEADER_FILE_STATE_POSITION);\n+        raf.writeByte(MODIFYING_STATE);\n+        raf.seek(position);\n+        raf.seek(0);\n+        raf.write(buffer.array(), 0, HEADER_SIZE);\n+        if (!complete) {\n+            raf.seek(HEADER_FILE_STATE_POSITION);\n+            raf.writeByte(state);\n+        } else {\n+            \/\/ will set state to complete when\n+            \/\/ header of next file is created.\n+            previousRAF = raf;\n+            previousRAFstate = state;\n+            currentChunk.size = Files.size(currentChunk.path);\n+            long durationNanos = buffer.getLong(HEADER_FILE_DURATION);\n+            Duration d = Duration.ofNanos(durationNanos);\n+            currentChunk.endTime = currentChunk.startTime.plus(d);\n+        }\n+        raf.seek(position);\n+    }\n+\n+    private void flush() throws IOException {\n+        int length = index - lastFlush;\n+        if (length != 0) {\n+            raf.write(currentByteArray, lastFlush, length);\n+            lastFlush = index;\n+        }\n+    }\n+\n+    private byte nextByte(boolean inEvent) {\n+        byte b = currentByteArray[index];\n+        index++;\n+        bufferIndex++;\n+        if (inEvent) {\n+            payLoadSize--;\n+        }\n+        return b;\n+    }\n+\n+    private DiskChunk nextChunk() throws IOException {\n+        long nanos = buffer.getLong(HEADER_START_NANOS_POSITION);\n+        long epochSecond = nanos \/ 1_000_000_000;\n+        int nanoOfSecond = (int) (nanos % 1_000_000_000);\n+        ZoneOffset z = OffsetDateTime.now().getOffset();\n+        LocalDateTime d = LocalDateTime.ofEpochSecond(epochSecond, nanoOfSecond, z);\n+        String filename = formatDateTime(d);\n+        Path p1 = directory.resolve(filename + \".jfr\");\n+        if (!Files.exists(p1)) {\n+            return new DiskChunk(p1, nanos);\n+        }\n+        for (int i = 1; i < 100; i++) {\n+            String s = Integer.toString(i);\n+            if (i < 10) {\n+                s = \"0\" + s;\n+            }\n+            Path p2 = directory.resolve(filename + \"_\" + s + \".jfr\");\n+            if (!Files.exists(p2)) {\n+                return new DiskChunk(p2, nanos);\n+            }\n+        }\n+        throw new IOException(\"Could not create chunk for path \" + p1);\n+    }\n+\n+    static String formatDateTime(LocalDateTime time) {\n+        StringBuilder sb = new StringBuilder(19);\n+        sb.append(time.getYear() \/ 100);\n+        appendPadded(sb, time.getYear() % 100, true);\n+        appendPadded(sb, time.getMonth().getValue(), true);\n+        appendPadded(sb, time.getDayOfMonth(), true);\n+        appendPadded(sb, time.getHour(), true);\n+        appendPadded(sb, time.getMinute(), true);\n+        appendPadded(sb, time.getSecond(), false);\n+        return sb.toString();\n+    }\n+\n+    private static void appendPadded(StringBuilder text, int number, boolean separator) {\n+        if (number < 10) {\n+            text.append('0');\n+        }\n+        text.append(number);\n+        if (separator) {\n+            text.append('_');\n+        }\n+    }\n+\n+    @Override\n+    public synchronized void close() throws IOException {\n+        completePrevious(currentChunk);\n+        if (raf != null) {\n+            raf.close();\n+        }\n+        deadChunks.addAll(activeChunks);\n+        if (currentChunk != null) {\n+            deadChunks.add(currentChunk);\n+        }\n+        cleanUpDeadChunk(Integer.MAX_VALUE);\n+        if (deleteDirectory) {\n+            try {\n+                Files.delete(directory);\n+            } catch (IOException ioe) {\n+                ManagementSupport.logDebug(\"Could not delete temp stream repository: \" + ioe.getMessage());\n+            }\n+        }\n+    }\n+\n+    public synchronized void setMaxAge(Duration maxAge) {\n+        this.maxAge = maxAge;\n+        trimToAge(Instant.now().minus(maxAge));\n+    }\n+\n+    public synchronized void setMaxSize(long maxSize) {\n+        this.maxSize = maxSize;\n+        trimToSize();\n+    }\n+\n+    private void trimToSize() {\n+        if (maxSize == 0) {\n+            return;\n+        }\n+        int count = 0;\n+        while (size > maxSize && activeChunks.size() > 1) {\n+            removeOldestChunk();\n+            count++;\n+        }\n+        cleanUpDeadChunk(count + 10);\n+    }\n+\n+    private void trimToAge(Instant oldest) {\n+        if (maxAge == null) {\n+            return;\n+        }\n+        int count = 0;\n+        while (activeChunks.size() > 1) {\n+            DiskChunk oldestChunk = activeChunks.getLast();\n+            if (oldestChunk.endTime.isAfter(oldest)) {\n+                return;\n+            }\n+            removeOldestChunk();\n+            count++;\n+        }\n+        cleanUpDeadChunk(count + 10);\n+    }\n+\n+    public synchronized void onChunkComplete(Instant timestamp) {\n+        int count = 0;\n+        while (!activeChunks.isEmpty()) {\n+            DiskChunk oldestChunk = activeChunks.peek();\n+            if (oldestChunk.startTime.isBefore(timestamp)) {\n+                removeOldestChunk();\n+                count++;\n+            } else {\n+                break;\n+            }\n+        }\n+        cleanUpDeadChunk(count + 10);\n+    }\n+\n+    private void addChunk(DiskChunk chunk) {\n+        if (maxAge != null) {\n+            trimToAge(chunk.endTime.minus(maxAge));\n+        }\n+        activeChunks.push(chunk);\n+        size += chunk.size;\n+        trimToSize();\n+    }\n+\n+    private void removeOldestChunk() {\n+        DiskChunk chunk = activeChunks.poll();\n+        deadChunks.add(chunk);\n+        size -= chunk.size;\n+    }\n+\n+    private void cleanUpDeadChunk(int maxCount) {\n+        int count = 0;\n+        Iterator<DiskChunk> iterator = deadChunks.iterator();\n+        while (iterator.hasNext()) {\n+            DiskChunk chunk = iterator.next();\n+            try {\n+                Files.delete(chunk.path);\n+                iterator.remove();\n+            } catch (IOException e) {\n+                \/\/ ignore\n+            }\n+            count++;\n+            if (count == maxCount) {\n+                return;\n+            }\n+        }\n+    }\n+\n+    public void complete() {\n+        if (currentChunk != null) {\n+            try {\n+                completePrevious(currentChunk);\n+            } catch (IOException ioe) {\n+                ManagementSupport.logDebug(\"Could not complete chunk \" + currentChunk.path + \" : \" + ioe.getMessage());\n+            }\n+        }\n+    }\n+}\n","filename":"src\/jdk.management.jfr\/share\/classes\/jdk\/management\/jfr\/DiskRepository.java","additions":483,"deletions":0,"binary":false,"changes":483,"status":"added"},{"patch":"@@ -0,0 +1,81 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.management.jfr;\n+\n+import java.io.IOException;\n+import java.time.Instant;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+final class DownLoadThread extends Thread {\n+    private final RemoteRecordingStream stream;\n+    private final Instant startTime;\n+    private final Instant endTime;\n+    private final DiskRepository diskRepository;\n+\n+    DownLoadThread(RemoteRecordingStream stream) {\n+        this.stream = stream;\n+        this.startTime = stream.startTime;\n+        this.endTime = stream.endTime;\n+        this.diskRepository = stream.repository;\n+    }\n+\n+    public void run() {\n+        try {\n+            Map<String, String> options = new HashMap<>();\n+            if (startTime != null) {\n+                options.put(\"startTime\", startTime.toString());\n+            }\n+            if (endTime != null) {\n+                options.put(\"endTime\", endTime.toString());\n+            }\n+            options.put(\"streamVersion\", \"1.0\");\n+            long streamId = this.stream.mbean.openStream(stream.recordingId, options);\n+            while (!stream.isClosed()) {\n+                byte[] bytes = stream.mbean.readStream(streamId);\n+                if (bytes == null) {\n+                    return;\n+                }\n+                if (bytes.length != 0) {\n+                    diskRepository.write(bytes);\n+                } else {\n+                    takeNap();\n+                }\n+            }\n+        } catch (IOException ioe) {\n+           \/\/ ignore\n+        } finally {\n+           diskRepository.complete();\n+        }\n+    }\n+\n+    private void takeNap() {\n+        try {\n+            Thread.sleep(1000);\n+        } catch (InterruptedException ie) {\n+            \/\/ ignore\n+        }\n+    }\n+}\n","filename":"src\/jdk.management.jfr\/share\/classes\/jdk\/management\/jfr\/DownLoadThread.java","additions":81,"deletions":0,"binary":false,"changes":81,"status":"added"},{"patch":"@@ -349,0 +349,10 @@\n+     * <tr>\n+     * <th scope=\"row\">{@code streamVersion}<\/th>\n+     * <td>Specifies format to use when reading data from a running recording\n+     * <\/td>\n+     * <td>{@code \"1.0\"}<\/td>\n+     * <td>A version number with a major and minor.<br>\n+     * <br>\n+     * To be able to read from a running recording the value must be set<\/td>\n+     * <td>{@code \"1.0\"}\n+     * <\/tr>\n@@ -354,1 +364,1 @@\n-     * be opened. This restriction might be lifted in future releases.\n+     * be opened, unless the option {@code \"streamVersion\"} is specified.\n","filename":"src\/jdk.management.jfr\/share\/classes\/jdk\/management\/jfr\/FlightRecorderMXBean.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -74,0 +74,1 @@\n+import jdk.jfr.internal.management.StreamManager;\n@@ -150,0 +151,9 @@\n+        String version = s.get(\"streamVersion\");\n+        if (version != null) {\n+            if (\"1.0\".equals(version)) {\n+                Recording r = getRecording(id);\n+                return streamHandler.createOngoing(r, blockSize, starttime, endtime).getId();\n+            }\n+            throw new IllegalArgumentException(\"Unsupported stream version \" + version);\n+        }\n+\n","filename":"src\/jdk.management.jfr\/share\/classes\/jdk\/management\/jfr\/FlightRecorderMXBeanImpl.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -143,1 +143,0 @@\n-\n","filename":"src\/jdk.management.jfr\/share\/classes\/jdk\/management\/jfr\/MBeanUtils.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,561 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.management.jfr;\n+\n+import java.io.IOException;\n+import java.io.RandomAccessFile;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.security.AccessControlContext;\n+import java.security.AccessController;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.function.Consumer;\n+import java.security.AccessControlException;\n+import javax.management.JMX;\n+import javax.management.MBeanServerConnection;\n+import javax.management.ObjectName;\n+\n+import jdk.jfr.Configuration;\n+import jdk.jfr.EventSettings;\n+import jdk.jfr.EventType;\n+import jdk.jfr.Recording;\n+import jdk.jfr.consumer.EventStream;\n+import jdk.jfr.consumer.MetadataEvent;\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.jfr.internal.management.EventSettingsModifier;\n+import jdk.jfr.internal.management.ManagementSupport;\n+import jdk.jfr.internal.management.EventByteStream;\n+\n+\/**\n+ * An implementation of an {@link EventStream} that can serialize events over\n+ * the network using an {@link MBeanServerConnection}.\n+ * <p>\n+ * The following example shows how to record garbage collection pauses and CPU\n+ * usage on a remote host and print the events to standard out.\n+ *\n+ * <pre>\n+ * {\n+ *     {@literal\n+ *     String host = \"com.example\";\n+ *     int port = 4711;\n+ *\n+ *     String url = \"service:jmx:rmi:\/\/\/jndi\/rmi:\/\/\" + host + \":\" + port + \"\/jmxrmi\";\n+ *\n+ *     JMXServiceURL u = new JMXServiceURL(url);\n+ *     JMXConnector c = JMXConnectorFactory.connect(u);\n+ *     MBeanServerConnection conn = c.getMBeanServerConnection();\n+ *\n+ *     try (var rs = new RemoteRecordingStream(conn)) {\n+ *         rs.enable(\"jdk.GCPhasePause\").withoutThreshold();\n+ *         rs.enable(\"jdk.CPULoad\").withPeriod(Duration.ofSeconds(1));\n+ *         rs.onEvent(\"jdk.CPULoad\", System.out::println);\n+ *         rs.onEvent(\"jdk.GCPhasePause\", System.out::println);\n+ *         rs.start();\n+ *     }\n+ * }\n+ * <\/pre>\n+ *\n+ * @since 16\n+ *\/\n+public final class RemoteRecordingStream implements EventStream {\n+    private static final String ENABLED = \"enabled\";\n+\n+    static final class RemoteSettings implements EventSettingsModifier {\n+\n+        private final FlightRecorderMXBean mbean;\n+        private final long recordingId;\n+\n+        RemoteSettings(FlightRecorderMXBean mbean, long recordingId) {\n+            this.mbean = mbean;\n+            this.recordingId = recordingId;\n+        }\n+\n+        @Override\n+        public void with(String name, String value) {\n+            Objects.requireNonNull(name);\n+            Objects.requireNonNull(value);\n+            \/\/ Should we rely on that Map is created new in the\n+            \/\/ FlightRecorderMXBean implementation?\n+            Map<String, String> newSettings = getEventSettings();\n+            newSettings.put(name, value);\n+            mbean.setRecordingSettings(recordingId, newSettings);\n+        }\n+\n+        @Override\n+        public Map<String, String> toMap() {\n+            return getEventSettings();\n+        }\n+\n+        private Map<String, String> getEventSettings() {\n+            return mbean.getRecordingSettings(recordingId);\n+        }\n+    }\n+\n+    \/\/ Reference to stream is released when EventStream::close is called\n+    final static class ChunkConsumer implements Consumer<Long> {\n+\n+        private final DiskRepository repository;\n+\n+        ChunkConsumer(DiskRepository repository) {\n+            this.repository = repository;\n+        }\n+\n+        @Override\n+        public void accept(Long endNanos) {\n+            Instant t = ManagementSupport.epochNanosToInstant(endNanos);\n+            repository.onChunkComplete(t);\n+        }\n+    }\n+\n+    private static final ObjectName OBJECT_NAME = MBeanUtils.createObjectName();\n+\n+    final Path path;\n+    final FlightRecorderMXBean mbean;\n+    final long recordingId;\n+    final EventStream stream;\n+    final AccessControlContext accessControllerContext;\n+    final DiskRepository repository;\n+    final Object lock = new Object();\n+    volatile Instant startTime;\n+    volatile Instant endTime;\n+    volatile boolean closed;\n+\n+    \/**\n+     * Creates an event stream that operates against a {@link MBeanServerConnection}\n+     * that has a registered {@link FlightRecorderMXBean}.\n+     * <p>\n+     * To configure event settings, use {@link #setSettings(Map)}.\n+     *\n+     * @param connection the {@code MBeanServerConnection} where the\n+     *                   {@code FlightRecorderMXBean} is registered, not\n+     *                   {@code null}\n+     *\n+     * @throws IOException       if a stream can't be opened, an I\/O error occurs\n+     *                           when trying to access the repository or the\n+     *                           {@code FlightRecorderMXBean}\n+     *\n+     * @throws SecurityException if a security manager exists and its\n+     *                           {@code checkRead} method denies read access to the\n+     *                           directory, or files in the directory.\n+     *\/\n+    public RemoteRecordingStream(MBeanServerConnection connection) throws IOException {\n+        this(connection, makeTempDirectory(), true);\n+    }\n+\n+    \/**\n+     * Creates an event stream that operates against a {@link MBeanServerConnection}\n+     * that has a registered {@link FlightRecorderMXBean}.\n+     * <p>\n+     * To configure event settings, use {@link #setSettings(Map)}.\n+     *\n+     * @param connection the {@code MBeanServerConnection} where the\n+     *                   {@code FlightRecorderMXBean} is registered, not\n+     *                   {@code null}\n+     *\n+     * @param directory  the directory to store event data that is downloaded, not\n+     *                   {@code null}\n+     *\n+     * @throws IOException       if a stream can't be opened, an I\/O error occurs\n+     *                           when trying to access the repository or the\n+     *                           {@code FlightRecorderMXBean}\n+     *\n+     * @throws SecurityException if a security manager exists and its\n+     *                           {@code checkRead} method denies read access to the\n+     *                           directory, or files in the directory.\n+     *\/\n+    public RemoteRecordingStream(MBeanServerConnection connection, Path directory) throws IOException {\n+        this(connection, directory, false);\n+    }\n+\n+    private RemoteRecordingStream(MBeanServerConnection connection, Path dir, boolean delete) throws IOException {\n+        Objects.requireNonNull(connection);\n+        Objects.requireNonNull(dir);\n+        accessControllerContext = AccessController.getContext();\n+        \/\/ Make sure user can't implement malicious version of a Path object.\n+        path = Paths.get(dir.toString());\n+        if (!Files.exists(path)) {\n+            throw new IOException(\"Download directory doesn't exist\");\n+        }\n+\n+        if (!Files.isDirectory(path)) {\n+            throw new IOException(\"Download location must be a directory\");\n+        }\n+        checkFileAccess(path);\n+        mbean = createProxy(connection);\n+        recordingId = createRecording();\n+        stream = ManagementSupport.newEventDirectoryStream(accessControllerContext, path, configurations(mbean));\n+        stream.setStartTime(Instant.MIN);\n+        repository = new DiskRepository(path, delete);\n+        ManagementSupport.setOnChunkCompleteHandler(stream, new ChunkConsumer(repository));\n+    }\n+\n+    private List<Configuration> configurations(FlightRecorderMXBean mbean) {\n+        List<ConfigurationInfo> cis = mbean.getConfigurations();\n+        List<Configuration> confs = new ArrayList<>(cis.size());\n+        for (ConfigurationInfo ci : cis) {\n+            confs.add(ManagementSupport.newConfiguration(ci.getName(), ci.getLabel(), ci.getDescription(),\n+                    ci.getProvider(), ci.getSettings(), ci.getContents()));\n+        }\n+        return Collections.unmodifiableList(confs);\n+    }\n+\n+    @Override\n+    public void onMetadata(Consumer<MetadataEvent> action) {\n+        stream.onMetadata(action);\n+    }\n+\n+    private static void checkFileAccess(Path directory) throws IOException {\n+        RandomAccessFile f = null;\n+        try {\n+            Path testFile = directory.resolve(\"test-access\");\n+            f = new RandomAccessFile(testFile.toFile(), \"rw\");\n+            f.write(0);\n+            f.seek(0);\n+            f.read();\n+            f.close();\n+            Files.delete(testFile);\n+        } catch (Exception e) {\n+            closeSilently(f);\n+            throw new IOException(\"Could not read\/write\/delete in directory\" + directory + \" :\" + e.getMessage());\n+        }\n+    }\n+\n+    private static void closeSilently(RandomAccessFile f) {\n+        if (f == null) {\n+            return;\n+        }\n+        try {\n+            f.close();\n+        } catch (IOException ioe) {\n+            \/\/ ignore\n+        }\n+    }\n+\n+    private static FlightRecorderMXBean createProxy(MBeanServerConnection connection) throws IOException {\n+        try {\n+            return JMX.newMXBeanProxy(connection, OBJECT_NAME, FlightRecorderMXBean.class);\n+        } catch (Exception e) {\n+            throw new IOException(\"Could not create proxy for FlightRecorderMXBean: \" + e.getMessage(), e);\n+        }\n+    }\n+\n+    private long createRecording() throws IOException {\n+        try {\n+            long id = mbean.newRecording();\n+            Map<String, String> options = new HashMap<>();\n+            options.put(\"name\", EventByteStream.NAME + \": \" + Instant.now());\n+            mbean.setRecordingOptions(id, options);\n+            return id;\n+        } catch (Exception e) {\n+            throw new IOException(\"Could not create new recording: \" + e.getMessage(), e);\n+        }\n+    }\n+\n+    private Map<String, String> getRecordingOptions() throws IOException {\n+        try {\n+            return mbean.getRecordingOptions(recordingId);\n+        } catch (Exception e) {\n+            throw new IOException(\"Could not get recording options: \" + e.getMessage(), e);\n+        }\n+    }\n+\n+    \/**\n+     * Replaces all settings for this recording stream.\n+     * <p>\n+     * The following example connects to a remote host and stream events using\n+     * settings from the \"default\" configuration.\n+     *\n+     * <pre>\n+     * {\n+     *     {@literal\n+     *\n+     *     String host = \"com.example\";\n+     *     int port = 4711;\n+     *\n+     *     String url = \"service:jmx:rmi:\/\/\/jndi\/rmi:\/\/\" + host + \":\" + port + \"\/jmxrmi\";\n+     *\n+     *     JMXServiceURL u = new JMXServiceURL(url);\n+     *     JMXConnector c = JMXConnectorFactory.connect(u);\n+     *     MBeanServerConnection conn = c.getMBeanServerConnection();\n+     *\n+     *     try (final var rs = new RemoteRecordingStream(conn)) {\n+     *         rs.onMetadata(e -> {\n+     *             for (Configuration c : e.getConfigurations()) {\n+     *                 if (c.getName().equals(\"default\")) {\n+     *                     rs.setSettings(c.getSettings());\n+     *                 }\n+     *             }\n+     *         });\n+     *         rs.onEvent(System.out::println);\n+     *         rs.start();\n+     *     }\n+     *\n+     * }\n+     * <\/pre>\n+     *\n+     * @param settings the settings to set, not {@code null}\n+     *\n+     * @see Recording#setSettings(Map)\n+     *\/\n+    public void setSettings(Map<String, String> settings) {\n+        Objects.requireNonNull(settings);\n+        try {\n+            mbean.setRecordingSettings(recordingId, settings);\n+        } catch (Exception e) {\n+            ManagementSupport.logDebug(e.getMessage());\n+            close();\n+        }\n+    };\n+\n+    \/**\n+     * Disables event with the specified name.\n+     * <p>\n+     * If multiple events with same name (for example, the same class is loaded in\n+     * different class loaders), then all events that match the name are disabled.\n+     *\n+     * @param name the settings for the event, not {@code null}\n+     *\n+     * @return an event setting for further configuration, not {@code null}\n+     *\n+     *\/\n+    public EventSettings disable(String name) {\n+        Objects.requireNonNull(name);\n+        EventSettings s = ManagementSupport.newEventSettings(new RemoteSettings(mbean, recordingId));\n+        try {\n+            return s.with(name + \"#\" + ENABLED, \"false\");\n+        } catch (Exception e) {\n+            ManagementSupport.logDebug(e.getMessage());\n+            close();\n+            return s;\n+        }\n+    }\n+\n+    \/**\n+     * Enables the event with the specified name.\n+     * <p>\n+     * If multiple events have the same name (for example, the same class is loaded\n+     * in different class loaders), then all events that match the name are enabled.\n+     *\n+     * @param name the settings for the event, not {@code null}\n+     *\n+     * @return an event setting for further configuration, not {@code null}\n+     *\n+     * @see EventType\n+     *\/\n+    public EventSettings enable(String name) {\n+        Objects.requireNonNull(name);\n+        EventSettings s = ManagementSupport.newEventSettings(new RemoteSettings(mbean, recordingId));\n+        try {\n+            return s.with(name + \"#\" + ENABLED, \"true\");\n+        } catch (Exception e) {\n+            ManagementSupport.logDebug(e.getMessage());\n+            close();\n+            return s;\n+        }\n+    }\n+\n+    \/**\n+     * Determines how far back data is kept for the stream.\n+     * <p>\n+     * To control the amount of recording data stored on disk, the maximum length of\n+     * time to retain the data can be specified. Data stored on disk that is older\n+     * than the specified length of time is removed by the Java Virtual Machine\n+     * (JVM).\n+     * <p>\n+     * If neither maximum limit or the maximum age is set, the size of the recording\n+     * may grow indefinitely if events are not consumed.\n+     *\n+     * @param maxAge the length of time that data is kept, or {@code null} if\n+     *               infinite\n+     *\n+     * @throws IllegalArgumentException if {@code maxAge} is negative\n+     *\n+     * @throws IllegalStateException    if the recording is in the {@code CLOSED}\n+     *                                  state\n+     *\/\n+    public void setMaxAge(Duration maxAge) {\n+        Objects.requireNonNull(maxAge);\n+        repository.setMaxAge(maxAge);\n+    }\n+\n+    \/**\n+     * Determines how much data is kept for the stream.\n+     * <p>\n+     * To control the amount of recording data that is stored on disk, the maximum\n+     * amount of data to retain can be specified. When the maximum limit is\n+     * exceeded, the Java Virtual Machine (JVM) removes the oldest chunk to make\n+     * room for a more recent chunk.\n+     * <p>\n+     * If neither maximum limit or the maximum age is set, the size of the recording\n+     * may grow indefinitely if events are not consumed.\n+     * <p>\n+     * The size is measured in bytes.\n+     *\n+     * @param maxSize the amount of data to retain, {@code 0} if infinite\n+     *\n+     * @throws IllegalArgumentException if {@code maxSize} is negative\n+     *\n+     * @throws IllegalStateException    if the recording is in {@code CLOSED} state\n+     *\/\n+    public void setMaxSize(long maxSize) {\n+        if (maxSize < 0) {\n+            throw new IllegalArgumentException(\"Max size of recording can't be negative\");\n+        }\n+        repository.setMaxSize(maxSize);\n+    }\n+\n+    @Override\n+    public void onEvent(Consumer<RecordedEvent> action) {\n+        stream.onEvent(action);\n+    }\n+\n+    @Override\n+    public void onEvent(String eventName, Consumer<RecordedEvent> action) {\n+        stream.onEvent(eventName, action);\n+    }\n+\n+    @Override\n+    public void onFlush(Runnable action) {\n+        stream.onFlush(action);\n+    }\n+\n+    @Override\n+    public void onError(Consumer<Throwable> action) {\n+        stream.onError(action);\n+    }\n+\n+    @Override\n+    public void onClose(Runnable action) {\n+        stream.onClose(action);\n+    }\n+\n+    @Override\n+    public void close() {\n+        if (closed) {\n+            return;\n+        }\n+        closed = true;\n+        ManagementSupport.setOnChunkCompleteHandler(stream, null);\n+        stream.close();\n+        try {\n+            mbean.closeRecording(recordingId);\n+        } catch (IOException e) {\n+            ManagementSupport.logDebug(e.getMessage());\n+        }\n+        try {\n+            repository.close();\n+        } catch (IOException e) {\n+            ManagementSupport.logDebug(e.getMessage());\n+        }\n+    }\n+\n+    @Override\n+    public boolean remove(Object action) {\n+        return stream.remove(action);\n+    }\n+\n+    @Override\n+    public void setReuse(boolean reuse) {\n+        stream.setReuse(reuse);\n+    }\n+\n+    @Override\n+    public void setOrdered(boolean ordered) {\n+        stream.setOrdered(ordered);\n+    }\n+\n+    @Override\n+    public void setStartTime(Instant startTime) {\n+        stream.setStartTime(startTime);\n+        this.startTime = startTime;\n+    }\n+\n+    @Override\n+    public void setEndTime(Instant endTime) {\n+        stream.setEndTime(endTime);\n+        this.endTime = endTime;\n+    }\n+\n+    @Override\n+    public void start() {\n+        try {\n+            try {\n+                mbean.startRecording(recordingId);\n+            } catch (IllegalStateException ise) {\n+                throw ise;\n+            }\n+            startDownload();\n+        } catch (Exception e) {\n+            ManagementSupport.logDebug(e.getMessage());\n+            close();\n+            return;\n+        }\n+        stream.start();\n+    }\n+\n+    @Override\n+    public void startAsync() {\n+        stream.startAsync();\n+        try {\n+            mbean.startRecording(recordingId);\n+            startDownload();\n+        } catch (Exception e) {\n+            ManagementSupport.logDebug(e.getMessage());\n+            close();\n+        }\n+    }\n+\n+    @Override\n+    public void awaitTermination(Duration timeout) throws InterruptedException {\n+        stream.awaitTermination(timeout);\n+    }\n+\n+    @Override\n+    public void awaitTermination() throws InterruptedException {\n+        stream.awaitTermination();\n+    }\n+\n+    private static Path makeTempDirectory() throws IOException {\n+        return Files.createTempDirectory(\"jfr-streaming\");\n+    }\n+\n+    private void startDownload() {\n+        Thread downLoadThread = new DownLoadThread(this);\n+        downLoadThread.start();\n+    }\n+\n+    boolean isClosed() {\n+        return closed;\n+    }\n+}\n","filename":"src\/jdk.management.jfr\/share\/classes\/jdk\/management\/jfr\/RemoteRecordingStream.java","additions":561,"deletions":0,"binary":false,"changes":561,"status":"added"},{"patch":"@@ -1,81 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.management.jfr;\n-\n-import java.io.BufferedInputStream;\n-import java.io.Closeable;\n-import java.io.IOException;\n-import java.io.InputStream;\n-\n-final class Stream implements Closeable {\n-\n-    private final long identifier;\n-    private final BufferedInputStream inputStream;\n-    private final byte[] buffer;\n-\n-    private volatile long time;\n-\n-    Stream(InputStream is, long identifier, int blockSize) {\n-        this.inputStream = new BufferedInputStream(is, 50000);\n-        this.identifier = identifier;\n-        this.buffer = new byte[blockSize];\n-    }\n-\n-    private void touch() {\n-        time = System.currentTimeMillis();\n-    }\n-\n-    public long getLastTouched() {\n-        return time;\n-    }\n-\n-    public byte[] read() throws IOException {\n-        \/\/ OK to reuse buffer since this\n-        \/\/ is only used for serialization\n-        touch();\n-        int read = inputStream.read(buffer);\n-        if (read == -1) {\n-            \/\/ null indicate no more data\n-            return null;\n-        }\n-        if (read != buffer.length) {\n-            byte[] smallerBuffer = new byte[read];\n-            System.arraycopy(buffer, 0, smallerBuffer, 0, read);\n-            return smallerBuffer;\n-        }\n-\n-        return buffer;\n-    }\n-\n-    @Override\n-    public void close() throws IOException {\n-        inputStream.close();\n-    }\n-\n-    public long getId() {\n-        return identifier;\n-    }\n-}\n","filename":"src\/jdk.management.jfr\/share\/classes\/jdk\/management\/jfr\/Stream.java","additions":0,"deletions":81,"binary":false,"changes":81,"status":"deleted"},{"patch":"@@ -1,50 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.management.jfr;\n-\n-import java.util.TimerTask;\n-\n-final class StreamCleanupTask extends TimerTask {\n-\n-    private final Stream stream;\n-    private final StreamManager manager;\n-\n-    StreamCleanupTask(StreamManager streamManager, Stream stream) {\n-        this.stream = stream;\n-        this.manager = streamManager;\n-    }\n-\n-    @Override\n-    public void run() {\n-        long lastTouched = stream.getLastTouched();\n-        long now = System.currentTimeMillis();\n-        if (now - lastTouched >= StreamManager.TIME_OUT) {\n-            manager.destroy(stream);\n-        } else {\n-            manager.scheduleAbort(stream, lastTouched + StreamManager.TIME_OUT);\n-        }\n-    }\n-}\n","filename":"src\/jdk.management.jfr\/share\/classes\/jdk\/management\/jfr\/StreamCleanupTask.java","additions":0,"deletions":50,"binary":false,"changes":50,"status":"deleted"},{"patch":"@@ -1,82 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.management.jfr;\n-\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.util.Date;\n-import java.util.HashMap;\n-import java.util.Map;\n-import java.util.Timer;\n-import java.util.concurrent.TimeUnit;\n-\n-final class StreamManager {\n-\n-    public static final long TIME_OUT = TimeUnit.MINUTES.toMillis(2);\n-    public static final int DEFAULT_BLOCK_SIZE = 50000;\n-\n-    private static long idCounter = 0;\n-\n-    private final Map<Long, Stream> streams = new HashMap<>();\n-    private Timer timer;\n-\n-    public synchronized Stream getStream(long streamIdentifer) {\n-        Stream stream = streams.get(streamIdentifer);\n-        if (stream == null) {\n-            throw new IllegalArgumentException(\"Unknown stream identifier \" + streamIdentifer);\n-        }\n-        return stream;\n-    }\n-\n-    public synchronized Stream create(InputStream is, int blockSize) {\n-        idCounter++;\n-        Stream stream = new Stream(is, idCounter, blockSize);\n-        streams.put(stream.getId(), stream);\n-\n-        scheduleAbort(stream, System.currentTimeMillis() + TIME_OUT);\n-        return stream;\n-    }\n-\n-    public synchronized void destroy(Stream stream) {\n-        try {\n-            stream.close();\n-        } catch (IOException e) {\n-            \/\/ OK\n-        }\n-        streams.remove(stream.getId());\n-        if (streams.isEmpty()) {\n-            timer.cancel();\n-            timer = null;\n-        }\n-    }\n-\n-    public synchronized void scheduleAbort(Stream s, long when) {\n-        if (timer == null) {\n-            timer = new Timer(true);\n-        }\n-        timer.schedule(new StreamCleanupTask(this, s), new Date(when + TIME_OUT));\n-    }\n-}\n","filename":"src\/jdk.management.jfr\/share\/classes\/jdk\/management\/jfr\/StreamManager.java","additions":0,"deletions":82,"binary":false,"changes":82,"status":"deleted"},{"patch":"@@ -33,1 +33,1 @@\n-    requires jdk.jfr;\n+    requires transitive jdk.jfr;\n","filename":"src\/jdk.management.jfr\/share\/classes\/module-info.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,314 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.api.consumer.recordingstream;\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.Semaphore;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Consumer;\n+\n+import jdk.jfr.Event;\n+import jdk.jfr.EventType;\n+import jdk.jfr.FlightRecorder;\n+import jdk.jfr.Recording;\n+import jdk.jfr.Registered;\n+import jdk.jfr.consumer.EventStream;\n+import jdk.jfr.consumer.MetadataEvent;\n+import jdk.jfr.consumer.RecordingStream;\n+\n+\/**\n+ * @test\n+ * @summary Tests RecordingStream::close()\n+ * @key jfr\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib \/test\/jdk\n+ * @run main\/othervm jdk.jfr.api.consumer.recordingstream.TestOnMetadata\n+ *\/\n+public class TestOnMetadata {\n+\n+    public static void main(String... args) throws Throwable {\n+        testDirectoryStream(true, false);\n+        testFileStream(true, false);\n+\n+        testAddAfterStart();\n+        testRemove();\n+        testNull();\n+        testUnmodifiable();\n+    }\n+\n+    private static void testUnmodifiable() throws Exception {\n+        AtomicBoolean fail = new AtomicBoolean();\n+        try (RecordingStream r = new RecordingStream()) {\n+            r.onMetadata(m -> {\n+                EventType t = FlightRecorder.getFlightRecorder().getEventTypes().get(0);\n+                try {\n+                    m.getEventTypes().add(t);\n+                    System.out.println(\"Should not be able to modify getEventTypes()\");\n+                    fail.set(true);\n+                } catch (UnsupportedOperationException uoe) {\n+                    \/\/ as expected;\n+                }\n+                try {\n+                    m.getRemovedEventTypes().add(t);\n+                    System.out.println(\"Should not be able to modify getRemovedEventTypes()\");\n+                    fail.set(true);\n+                } catch (UnsupportedOperationException uoe) {\n+                    \/\/ as expected;\n+                }\n+                try {\n+                    m.getAddedEventTypes().add(t);\n+                    System.out.println(\"Should not be able to modify getAddedEventTypes()\");\n+                    fail.set(true);\n+                } catch (UnsupportedOperationException uoe) {\n+                    \/\/ as expected;\n+                }\n+                r.close();\n+            });\n+            r.start();\n+            r.awaitTermination();\n+            if (fail.get()) {\n+                throw new Exception(\"Metadata event could be mofified\");\n+            }\n+        }\n+    }\n+\n+    private static void testNull() throws Exception {\n+        try (RecordingStream r = new RecordingStream()) {\n+            try {\n+                r.onMetadata(null);\n+                throw new Exception(\"Expected NullPointerException\");\n+            } catch (NullPointerException e) {\n+                \/\/ as expected;\n+            }\n+        }\n+    }\n+\n+    private static void testRemove() throws Exception {\n+        class RemoveEvent extends Event {\n+        }\n+        AtomicBoolean receviedMetadata = new AtomicBoolean();\n+        try (RecordingStream r = new RecordingStream()) {\n+            Consumer<MetadataEvent> m = e -> {\n+                receviedMetadata.set(true);\n+            };\n+            r.onMetadata(m);\n+            r.remove(m);\n+            r.onEvent(e -> {\n+                r.close();\n+            });\n+            r.remove(m);\n+            r.startAsync();\n+            RemoveEvent t = new RemoveEvent();\n+            t.commit();\n+            r.awaitTermination();\n+            if (receviedMetadata.get()) {\n+                throw new Exception(\"Unexpected MetadataEvent!\");\n+            }\n+        }\n+    }\n+\n+    private static void testAddAfterStart() throws Exception {\n+        try (RecordingStream rs = new RecordingStream()) {\n+            rs.startAsync();\n+            rs.onMetadata(m -> {\n+            });\n+            throw new Exception(\"Expected exception if handler is added after start\");\n+        } catch (IllegalStateException ise) {\n+            \/\/ as expected\n+        }\n+    }\n+\n+    private static void testFileStream(boolean ordered, boolean reuse) throws Exception {\n+        class Spider extends Event {\n+\n+        }\n+        AtomicInteger counter = new AtomicInteger();\n+        try (Recording rs = new Recording()) {\n+            rs.start(); \/\/ event 1\n+            rotateChunk();\n+            FlightRecorder.register(Spider.class);\n+            final EventType spiderType = EventType.getEventType(Spider.class);\n+            \/\/ event 2\n+            rotateChunk();\n+            FlightRecorder.unregister(Spider.class);\n+            \/\/ event 3\n+            rs.stop();\n+            Path p = Paths.get(\"test-file-stream-jfr\");\n+            rs.dump(p);\n+            try (EventStream s = EventStream.openFile(p)) {\n+                System.out.println(\"Testing file: ordered=\" + ordered + \" reuse=\" + reuse);\n+\n+                s.setOrdered(ordered);\n+                s.setReuse(reuse);\n+                s.onMetadata(e -> {\n+                    int count = counter.get();\n+                    if (count == 1) {\n+                        assertinitialEventypes(e);\n+                    }\n+                    if (count == 2) {\n+                        assertAddedEventType(e, spiderType);\n+                    }\n+                    if (count == 3) {\n+                        assertRemovedEventType(e, spiderType);\n+                    }\n+                });\n+                s.start();\n+                if (counter.get() > 3) {\n+                    throw new Exception(\"Unexpected number of Metadata events\");\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void testDirectoryStream(boolean ordered, boolean reuse) throws Throwable {\n+        @Registered(false)\n+        class Turtle extends Event {\n+        }\n+\n+        class AssertEventTypes implements Consumer<MetadataEvent> {\n+            private final Semaphore semaphore = new Semaphore(0);\n+            private volatile Throwable exception;\n+            private volatile Consumer<MetadataEvent> assertMethod;\n+\n+            @Override\n+            public void accept(MetadataEvent t) {\n+                try {\n+                    assertMethod.accept(t);\n+                } catch (Throwable e) {\n+                    this.exception = e;\n+                    e.printStackTrace();\n+                }\n+                semaphore.release();\n+            }\n+\n+            public void await() throws Throwable {\n+                semaphore.acquire();\n+                if (exception != null) {\n+                    throw exception;\n+                }\n+            }\n+        }\n+\n+        try (RecordingStream rs = new RecordingStream()) {\n+            System.out.println(\"Testing directory: ordered=\" + ordered + \" reuse=\" + reuse);\n+            rs.setOrdered(ordered);\n+            rs.setReuse(reuse);\n+\n+            AssertEventTypes assertion = new AssertEventTypes();\n+\n+            \/\/ Check initial event types\n+            assertion.assertMethod = e -> assertinitialEventypes(e);\n+            rs.onMetadata(assertion);\n+            rs.startAsync();\n+            assertion.await();\n+\n+            \/\/ Check added event type\n+            assertion.assertMethod = e -> assertAddedEventType(e, EventType.getEventType(Turtle.class));\n+            FlightRecorder.register(Turtle.class);\n+            final EventType turtleType = EventType.getEventType(Turtle.class);\n+            assertion.await();\n+\n+            \/\/ Check removal of turtle event\n+            assertion.assertMethod = e -> assertRemovedEventType(e, turtleType);\n+            FlightRecorder.unregister(Turtle.class);\n+            rotateChunk();\n+            assertion.await();\n+        }\n+    }\n+\n+    private static void assertRemovedEventType(MetadataEvent m, EventType removedType) {\n+        List<EventType> eventTypes = FlightRecorder.getFlightRecorder().getEventTypes();\n+        List<EventType> added = m.getAddedEventTypes();\n+        List<EventType> all = m.getEventTypes();\n+        List<EventType> removed = m.getRemovedEventTypes();\n+\n+        assertEventTypes(all, eventTypes);\n+        assertEventTypes(added, Collections.emptyList());\n+        assertEventTypes(removed, List.of(removedType));\n+    }\n+\n+    private static void assertAddedEventType(MetadataEvent m, EventType addedType) {\n+        List<EventType> eventTypes = FlightRecorder.getFlightRecorder().getEventTypes();\n+        List<EventType> added = m.getAddedEventTypes();\n+        List<EventType> all = m.getEventTypes();\n+        List<EventType> removed = m.getRemovedEventTypes();\n+\n+        assertEventTypes(all, eventTypes);\n+        assertEventTypes(added, List.of(addedType));\n+        assertEventTypes(removed, Collections.emptyList());\n+    }\n+\n+    private static void assertinitialEventypes(MetadataEvent m) {\n+        List<EventType> added = m.getAddedEventTypes();\n+        List<EventType> all = m.getEventTypes();\n+        List<EventType> removed = m.getRemovedEventTypes();\n+        List<EventType> eventTypes = FlightRecorder.getFlightRecorder().getEventTypes();\n+\n+        assertEventTypes(all, eventTypes);\n+        assertEventTypes(added, eventTypes);\n+        assertEventTypes(removed, Collections.emptyList());\n+    }\n+\n+    private static void assertEventTypes(List<EventType> eventTypes, List<EventType> expected) {\n+        if (eventTypes.size() != expected.size()) {\n+            fail(eventTypes, expected);\n+        }\n+        Set<Long> set = new HashSet<>();\n+        for (EventType eb : expected) {\n+            set.add(eb.getId());\n+        }\n+        for (EventType ea : eventTypes) {\n+            if (!set.contains(ea.getId())) {\n+                fail(eventTypes, expected);\n+            }\n+        }\n+    }\n+\n+    private static void fail(List<EventType> evenTypes, List<EventType> expected) {\n+        System.out.println(\"Event types don't match\");\n+        System.out.println(\"Expected:\");\n+        for (EventType t : expected) {\n+            System.out.println(t.getName());\n+        }\n+        System.out.println(\"Got:\");\n+        for (EventType t : expected) {\n+            System.out.println(t.getName());\n+        }\n+        throw new RuntimeException(\"EventTypes don't match!\");\n+    }\n+\n+    private static void rotateChunk() {\n+        try (Recording r = new Recording()) {\n+            r.start();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/api\/consumer\/recordingstream\/TestOnMetadata.java","additions":314,"deletions":0,"binary":false,"changes":314,"status":"added"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.jmx.streaming;\n+\n+import java.lang.management.ManagementFactory;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+\n+import javax.management.MBeanServerConnection;\n+\n+import jdk.jfr.Event;\n+import jdk.management.jfr.RemoteRecordingStream;\n+\n+\/**\n+ * @test\n+ * @key jfr\n+ * @summary Tests that a RemoteRecordingStream can be closed\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib \/test\/jdk\n+ * @run main\/othervm jdk.jfr.jmx.streaming.TestClose\n+ *\/\n+public class TestClose {\n+\n+    static class TestCloseEvent extends Event {\n+    }\n+\n+    public static void main(String... args) throws Exception {\n+        MBeanServerConnection conn = ManagementFactory.getPlatformMBeanServer();\n+        Path p = Files.createDirectory(Paths.get(\"test-close-\" + System.currentTimeMillis()));\n+\n+        RemoteRecordingStream e = new RemoteRecordingStream(conn, p);\n+        e.startAsync();\n+        \/\/ Produce enough to generate multiple chunks\n+        for (int i = 0; i < 200_000; i++) {\n+            TestCloseEvent event = new TestCloseEvent();\n+            event.commit();\n+        }\n+        e.onFlush(() -> {\n+            e.close(); \/\/ <- should clean up files.\n+        });\n+        e.awaitTermination();\n+        int count = 0;\n+        for (Object path : Files.list(p).toArray()) {\n+            System.out.println(path);\n+            count++;\n+        }\n+        if (count > 0) {\n+            throw new Exception(\"Expected repository to be empty\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/jmx\/streaming\/TestClose.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"},{"patch":"@@ -0,0 +1,203 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.jmx.streaming;\n+\n+import java.lang.management.ManagementFactory;\n+import java.time.Duration;\n+import java.util.concurrent.CountDownLatch;\n+\n+import javax.management.MBeanServerConnection;\n+\n+import jdk.jfr.Event;\n+import jdk.management.jfr.RemoteRecordingStream;\n+\n+\/**\n+ * @test\n+ * @key jfr\n+ * @summary Sanity test methods that delegates to an ordinary steam\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib \/test\/jdk\n+ * @run main\/othervm jdk.jfr.jmx.streaming.TestDelegated\n+ *\/\n+public class TestDelegated {\n+\n+    private static MBeanServerConnection CONNECTION = ManagementFactory.getPlatformMBeanServer();\n+\n+    static class TestDelegatedEvent extends Event {\n+    }\n+\n+    \/\/ The assumption here is that the following methods don't\n+    \/\/ need t be tested fully since they all delegate to the\n+    \/\/ same implementation class that is tested elsewhere.\n+\n+    public static void main(String[] args) throws Exception {\n+        testRemove();\n+        testReuse();\n+        testOrdered();\n+        testOnEvent();\n+        testOnEventName();\n+        testOnFlush();\n+        testOnError();\n+        testOnClose();\n+        testSetMaxAge();\n+        testAwaitTermination();\n+        testAwaitTerminationWithDuration();\n+    }\n+\n+    private static void testSetMaxAge() throws Exception {\n+        try (RemoteRecordingStream stream = new RemoteRecordingStream(CONNECTION)) {\n+            try {\n+                stream.setMaxAge(null);\n+                throw new Exception(\"Expected NullPointerException\");\n+            } catch (NullPointerException npe) {\n+                \/\/ As expected\n+            }\n+        }\n+    }\n+\n+    private static void testAwaitTerminationWithDuration() throws Exception {\n+        try (RemoteRecordingStream rs = new RemoteRecordingStream(CONNECTION)) {\n+            rs.onEvent(e -> {\n+                rs.close();\n+            });\n+            rs.startAsync();\n+            TestDelegatedEvent e = new TestDelegatedEvent();\n+            e.commit();\n+            rs.awaitTermination(Duration.ofDays(1));\n+        }\n+    }\n+\n+    private static void testAwaitTermination() throws Exception {\n+        try (RemoteRecordingStream rs = new RemoteRecordingStream(CONNECTION)) {\n+            rs.onEvent(e -> {\n+                rs.close();\n+            });\n+            rs.startAsync();\n+            TestDelegatedEvent e = new TestDelegatedEvent();\n+            e.commit();\n+            rs.awaitTermination();\n+        }\n+    }\n+\n+    private static void testOnClose() throws Exception {\n+        CountDownLatch latch = new CountDownLatch(1);\n+        try (RemoteRecordingStream rs = new RemoteRecordingStream(CONNECTION)) {\n+            rs.onClose(() -> {\n+                latch.countDown();\n+            });\n+            rs.startAsync();\n+            rs.close();\n+            latch.await();\n+        }\n+    }\n+\n+    private static void testOnError() throws Exception {\n+        CountDownLatch latch = new CountDownLatch(1);\n+        try (RemoteRecordingStream rs = new RemoteRecordingStream(CONNECTION)) {\n+            rs.onEvent(TestDelegatedEvent.class.getName(), e -> {\n+                throw new RuntimeException(\"Testing\");\n+            });\n+            rs.onError(t -> {\n+                latch.countDown();\n+            });\n+            rs.startAsync();\n+            TestDelegatedEvent e = new TestDelegatedEvent();\n+            e.commit();\n+            latch.await();\n+        }\n+    }\n+\n+    private static void testOnFlush() throws Exception {\n+        CountDownLatch latch = new CountDownLatch(1);\n+        try (RemoteRecordingStream rs = new RemoteRecordingStream(CONNECTION)) {\n+            rs.onFlush(() -> {\n+                latch.countDown();\n+            });\n+            rs.startAsync();\n+            TestDelegatedEvent e = new TestDelegatedEvent();\n+            e.commit();\n+            latch.await();\n+        }\n+    }\n+\n+    private static void testOnEventName() throws Exception {\n+        CountDownLatch latch = new CountDownLatch(1);\n+        try (RemoteRecordingStream rs = new RemoteRecordingStream(CONNECTION)) {\n+            rs.onEvent(TestDelegatedEvent.class.getName(), e -> {\n+                latch.countDown();\n+            });\n+            rs.startAsync();\n+            TestDelegatedEvent e = new TestDelegatedEvent();\n+            e.commit();\n+            latch.await();\n+        }\n+    }\n+\n+    private static void testOnEvent() throws Exception {\n+        CountDownLatch latch = new CountDownLatch(1);\n+        try (RemoteRecordingStream rs = new RemoteRecordingStream(CONNECTION)) {\n+            rs.onEvent(e -> {\n+                System.out.println(e);\n+                latch.countDown();\n+            });\n+            rs.startAsync();\n+            TestDelegatedEvent e = new TestDelegatedEvent();\n+            e.commit();\n+            latch.await();\n+        }\n+\n+    }\n+\n+    private static void testOrdered() throws Exception {\n+        try (RemoteRecordingStream rs = new RemoteRecordingStream(CONNECTION)) {\n+            rs.setOrdered(true);\n+            rs.setOrdered(false);\n+        }\n+    }\n+\n+    private static void testReuse() throws Exception {\n+        try (RemoteRecordingStream rs = new RemoteRecordingStream(CONNECTION)) {\n+            rs.setReuse(true);\n+            rs.setReuse(false);\n+        }\n+    }\n+\n+    private static void testRemove() throws Exception {\n+        try (RemoteRecordingStream rs = new RemoteRecordingStream(CONNECTION)) {\n+            Runnable r1 = () -> {\n+            };\n+            Runnable r2 = () -> {\n+            };\n+            rs.onFlush(r1);\n+            if (!rs.remove(r1)) {\n+                throw new Exception(\"Expected remove to return true\");\n+            }\n+            if (rs.remove(r2)) {\n+                throw new Exception(\"Expected remove to return false\");\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/jmx\/streaming\/TestDelegated.java","additions":203,"deletions":0,"binary":false,"changes":203,"status":"added"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.jmx.streaming;\n+\n+import java.lang.management.ManagementFactory;\n+import java.util.concurrent.CountDownLatch;\n+\n+import javax.management.MBeanServerConnection;\n+\n+import jdk.jfr.Enabled;\n+import jdk.jfr.Event;\n+import jdk.jfr.Name;\n+\n+import jdk.management.jfr.RemoteRecordingStream;\n+\n+\/**\n+ * @test\n+ * @key jfr\n+ * @summary Tests that a RemoteRecordingStream can be closed\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib \/test\/jdk\n+ * @run main\/othervm jdk.jfr.jmx.streaming.TestEnableDisable\n+ *\/\n+public class TestEnableDisable {\n+    @Name(\"Zebra\")\n+    @Enabled(false)\n+    static class Zebra extends Event {\n+    }\n+\n+    @Name(\"Tiger\")\n+    @Enabled(true)\n+    static class Tiger extends Event {\n+    }\n+\n+    public static void main(String... args) throws Exception {\n+        CountDownLatch zebraLatch = new CountDownLatch(1);\n+        MBeanServerConnection conn = ManagementFactory.getPlatformMBeanServer();\n+        try (RemoteRecordingStream stream = new RemoteRecordingStream(conn)) {\n+            stream.enable(\"Zebra\");\n+            stream.disable(\"Tiger\");\n+\n+            stream.onEvent(\"Zebra\", e -> {\n+                System.out.println(e);\n+                zebraLatch.countDown();\n+            });\n+            stream.onEvent(\"Tiger\", e -> {\n+                System.out.println(e);\n+                throw new RuntimeException(\"Unexpected Tiger\"); \/\/ will close stream\n+            });\n+\n+            stream.startAsync();\n+\n+            Tiger t = new Tiger();\n+            t.commit();\n+\n+            Zebra z = new Zebra();\n+            z.commit();\n+\n+            zebraLatch.await();\n+        }\n+\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/jmx\/streaming\/TestEnableDisable.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"@@ -0,0 +1,116 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.jmx.streaming;\n+\n+import java.io.IOException;\n+import java.lang.management.ManagementFactory;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import javax.management.MBeanServerConnection;\n+\n+import jdk.jfr.Event;\n+import jdk.management.jfr.RemoteRecordingStream;\n+\n+\/**\n+ * @test\n+ * @key jfr\n+ * @summary Tests that a RemoteRecordingStream can be closed\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib \/test\/jdk\n+ * @run main\/othervm jdk.jfr.jmx.streaming.TestMaxSize\n+ *\/\n+public class TestMaxSize {\n+\n+    static class Monkey extends Event {\n+    }\n+\n+    public static void main(String... args) throws Exception {\n+        MBeanServerConnection conn = ManagementFactory.getPlatformMBeanServer();\n+        Path dir = Files.createDirectories(Paths.get(\"max-size-\" + System.currentTimeMillis()));\n+        System.out.println(dir);\n+        AtomicBoolean finished = new AtomicBoolean();\n+        try (RemoteRecordingStream e = new RemoteRecordingStream(conn, dir)) {\n+            e.startAsync();\n+            e.onEvent(ev -> {\n+                if (finished.get()) {\n+                    return;\n+                }\n+                \/\/ Consume some events, but give back control\n+                \/\/ to stream so it can be closed.\n+                try {\n+                    Thread.sleep(10);\n+                } catch (InterruptedException e1) {\n+                    \/\/ ignore\n+                }\n+            });\n+            while (directorySize(dir) < 50_000_000) {\n+                emitEvents(500_000);\n+            }\n+            e.setMaxSize(1_000_000);\n+            long count = fileCount(dir);\n+            if (count > 2) {\n+                \/\/ Two chunks can happen when header of new chunk is written and previous\n+                \/\/ chunk is not finalized.\n+                throw new Exception(\"Expected only one or two chunks with setMaxSize(1_000_000). Found \" + count);\n+            }\n+            finished.set(true);\n+        }\n+    }\n+\n+    private static void emitEvents(int count) throws InterruptedException {\n+        for (int i = 0; i < count; i++) {\n+            Monkey m = new Monkey();\n+            m.commit();\n+        }\n+        System.out.println(\"Emitted \" + count + \" events\");\n+        Thread.sleep(1000);\n+    }\n+\n+    private static int fileCount(Path dir) throws IOException {\n+        System.out.println(\"Files:\");\n+        AtomicInteger count = new AtomicInteger();\n+        Files.list(dir).forEach(p -> {\n+            System.out.println(p);\n+            count.incrementAndGet();\n+        });\n+        return count.get();\n+    }\n+\n+    private static long directorySize(Path dir) throws IOException {\n+        long p = Files.list(dir).mapToLong(f -> {\n+            try {\n+                return Files.size(f);\n+            } catch (IOException e) {\n+                return 0;\n+            }\n+        }).sum();\n+        System.out.println(\"Directory size: \" + p);\n+        return p;\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/jmx\/streaming\/TestMaxSize.java","additions":116,"deletions":0,"binary":false,"changes":116,"status":"added"},{"patch":"@@ -0,0 +1,69 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.jmx.streaming;\n+\n+import java.lang.management.ManagementFactory;\n+import java.util.concurrent.CountDownLatch;\n+\n+import javax.management.MBeanServerConnection;\n+\n+import jdk.jfr.Event;\n+import jdk.jfr.Recording;\n+import jdk.management.jfr.RemoteRecordingStream;\n+\n+\/**\n+ * @test\n+ * @key jfr\n+ * @summary Tests that a RemoteRecordingStream can be closed\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib \/test\/jdk\n+ * @run main\/othervm jdk.jfr.jmx.streaming.TestMultipleChunks\n+ *\/\n+public class TestMultipleChunks {\n+\n+    static class Snake extends Event {\n+    }\n+\n+    public static void main(String... args) throws Exception {\n+        CountDownLatch latch = new CountDownLatch(5);\n+        MBeanServerConnection conn = ManagementFactory.getPlatformMBeanServer();\n+        try (RemoteRecordingStream s = new RemoteRecordingStream(conn)) {\n+            s.onEvent(e -> latch.countDown());\n+            s.startAsync();\n+            for (int i = 0; i < 5; i++) {\n+                Snake snake = new Snake();\n+                snake.commit();\n+                rotate();\n+            }\n+        }\n+    }\n+\n+    private static void rotate() {\n+        try (Recording r = new Recording()) {\n+            r.start();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/jmx\/streaming\/TestMultipleChunks.java","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"},{"patch":"@@ -0,0 +1,137 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.jmx.streaming;\n+\n+import java.io.IOException;\n+import java.io.RandomAccessFile;\n+import java.lang.management.ManagementFactory;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+\n+import javax.management.MBeanServerConnection;\n+import javax.management.ObjectName;\n+\n+import jdk.management.jfr.FlightRecorderMXBean;\n+import jdk.management.jfr.RemoteRecordingStream;\n+\n+\/**\n+ * @test\n+ * @key jfr\n+ * @summary Test constructors of RemoteRecordingStream\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib \/test\/jdk\n+ * @run main\/othervm jdk.jfr.jmx.streaming.TestNew\n+ *\/\n+public class TestNew {\n+\n+    private final static ObjectName MXBEAN = createObjectName();\n+\n+    public static void main(String... args) throws Exception {\n+        testNullArguments();\n+        testMissingDirectory();\n+        testNotDirectory();\n+        testDefaultDIrectory();\n+        TestUserDefinedDirectory();\n+\n+        testMissingFlightRecorderMXBean();\n+    }\n+\n+    private static void TestUserDefinedDirectory() throws IOException {\n+        Path p = Paths.get(\"user-repository-\" + System.currentTimeMillis());\n+        Files.createDirectory(p);\n+        MBeanServerConnection conn = ManagementFactory.getPlatformMBeanServer();\n+        try (RemoteRecordingStream s = new RemoteRecordingStream(conn, p)) {\n+            \/\/ success\n+        }\n+    }\n+\n+    private static void testDefaultDIrectory() throws IOException {\n+        MBeanServerConnection conn = ManagementFactory.getPlatformMBeanServer();\n+        try (RemoteRecordingStream s = new RemoteRecordingStream(conn)) {\n+            \/\/ success\n+        }\n+    }\n+\n+    private static void testNotDirectory() throws Exception {\n+        Path p = Paths.get(\"file.txt\");\n+        RandomAccessFile raf = new RandomAccessFile(p.toFile(), \"rw\");\n+        raf.close();\n+        MBeanServerConnection conn = ManagementFactory.getPlatformMBeanServer();\n+        try (var s = new RemoteRecordingStream(conn, p)) {\n+            throw new Exception(\"Expected IOException\");\n+        } catch (IOException ioe) {\n+            if (!ioe.getMessage().contains(\"Download location must be a directory\")) {\n+                throw new Exception(\"Unexpected message \" + ioe.getMessage());\n+            }\n+        }\n+    }\n+\n+    private static void testMissingDirectory() throws Exception {\n+        Path p = Paths.get(\"\/missing\");\n+        MBeanServerConnection conn = ManagementFactory.getPlatformMBeanServer();\n+        try (var s = new RemoteRecordingStream(conn, p)) {\n+            throw new Exception(\"Expected IOException\");\n+        } catch (IOException ioe) {\n+            if (!ioe.getMessage().contains(\"Download directory doesn't exist\")) {\n+                throw new Exception(\"Unexpected message \" + ioe.getMessage());\n+            }\n+        }\n+    }\n+\n+    private static void testNullArguments() throws Exception {\n+        try (var s = new RemoteRecordingStream(null)) {\n+            throw new Exception(\"Expected NullPointerException\");\n+        } catch (NullPointerException npe) {\n+            \/\/ as expected\n+        }\n+        MBeanServerConnection conn = ManagementFactory.getPlatformMBeanServer();\n+        try (var s = new RemoteRecordingStream(conn, null)) {\n+            throw new Exception(\"Expected NullPointerException\");\n+        } catch (NullPointerException npe) {\n+            \/\/ as expected\n+        }\n+    }\n+\n+    private static void testMissingFlightRecorderMXBean() throws Exception {\n+\n+        MBeanServerConnection conn = ManagementFactory.getPlatformMBeanServer();\n+        conn.unregisterMBean(MXBEAN);\n+        try (var s = new RemoteRecordingStream(conn)) {\n+            throw new Exception(\"Expected IOException\");\n+        } catch (IOException npe) {\n+            \/\/ as expected\n+        }\n+    }\n+\n+    private static ObjectName createObjectName() {\n+        try {\n+            return new ObjectName(FlightRecorderMXBean.MXBEAN_NAME);\n+        } catch (Exception e) {\n+            throw new InternalError(\"Unexpected exception\", e);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/jmx\/streaming\/TestNew.java","additions":137,"deletions":0,"binary":false,"changes":137,"status":"added"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.jmx.streaming;\n+\n+import java.lang.management.ManagementFactory;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.concurrent.CountDownLatch;\n+\n+import javax.management.MBeanServerConnection;\n+\n+import jdk.jfr.Event;\n+import jdk.jfr.Recording;\n+import jdk.jfr.StackTrace;\n+import jdk.management.jfr.RemoteRecordingStream;\n+\n+\/**\n+ * @test\n+ * @key jfr\n+ * @summary Tests that streaming can work over chunk rotations\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib \/test\/jdk\n+ * @run main\/othervm jdk.jfr.jmx.streaming.TestRotate\n+ *\/\n+public class TestRotate {\n+\n+    @StackTrace(false)\n+    static class TestRotateEvent extends Event {\n+        int value;\n+    }\n+\n+    public static void main(String... args) throws Exception {\n+        MBeanServerConnection conn = ManagementFactory.getPlatformMBeanServer();\n+        Path p = Files.createDirectory(Paths.get(\"test-stream-rotate-\" + System.currentTimeMillis()));\n+        CountDownLatch latch = new CountDownLatch(100);\n+        try (RemoteRecordingStream r = new RemoteRecordingStream(conn, p)) {\n+            r.onEvent(e -> {\n+                System.out.println(e);\n+                latch.countDown();\n+            });\n+            r.startAsync();\n+            for (int i = 1; i <= 100; i++) {\n+                TestRotateEvent e = new TestRotateEvent();\n+                e.value = i;\n+                e.commit();\n+                if (i % 30 == 0) {\n+                    rotate();\n+                }\n+                Thread.sleep(10);\n+            }\n+            System.out.println(\"Events generated. Awaiting consumption\");\n+            latch.await();\n+        }\n+    }\n+\n+    private static void rotate() {\n+        try (Recording r = new Recording()) {\n+            r.start();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/jmx\/streaming\/TestRotate.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"@@ -0,0 +1,109 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.jmx.streaming;\n+\n+import java.lang.management.ManagementFactory;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.CountDownLatch;\n+\n+import javax.management.MBeanServerConnection;\n+\n+import jdk.jfr.Enabled;\n+import jdk.jfr.Event;\n+import jdk.jfr.Name;\n+import jdk.jfr.StackTrace;\n+import jdk.management.jfr.RemoteRecordingStream;\n+\n+\/**\n+ * @test\n+ * @key jfr\n+ * @summary Tests that a RemoteRecordingStream can be configured using\n+ *          setSettings\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib \/test\/jdk\n+ * @run main\/othervm jdk.jfr.jmx.streaming.TestSetSettings\n+ *\/\n+public class TestSetSettings {\n+\n+    @Enabled(false)\n+    @StackTrace(false)\n+    @Name(\"Event1\")\n+    static class Event1 extends Event {\n+    }\n+\n+    @Enabled(false)\n+    @StackTrace(false)\n+    @Name(\"Event2\")\n+    static class Event2 extends Event {\n+    }\n+\n+    public static void main(String... args) throws Exception {\n+        CountDownLatch latch1 = new CountDownLatch(1);\n+        CountDownLatch latch2 = new CountDownLatch(1);\n+\n+        MBeanServerConnection conn = ManagementFactory.getPlatformMBeanServer();\n+        try (RemoteRecordingStream r = new RemoteRecordingStream(conn)) {\n+            r.onEvent(\"Event1\", e -> {\n+                System.out.println(\"Found event: \" + e.getEventType().getName());\n+                if (e.getStackTrace() == null) {\n+                    System.out.println(\"Missing strack trace\");\n+                    return;\n+                }\n+                latch1.countDown();\n+            });\n+            r.onEvent(\"Event2\", e -> {\n+                System.out.println(\"Found event: \" + e.getEventType().getName());\n+                if (e.getStackTrace() == null) {\n+                    System.out.println(\"Missing strack trace\");\n+                    return;\n+                }\n+                latch2.countDown();\n+            });\n+            \/\/ Set settings before start\n+            Map<String, String> settings = new HashMap<>();\n+            settings.put(\"Event1#enabled\", \"true\");\n+            settings.put(\"Event1#stackTrace\", \"true\");\n+            r.setSettings(settings);\n+\n+            r.startAsync();\n+\n+            Event1 e1 = new Event1();\n+            e1.commit();\n+            System.out.println(\"Awaiting latch 1\");\n+            latch1.await();\n+\n+            \/\/ Set settings when running\n+            settings = new HashMap<>();\n+            settings.put(\"Event2#enabled\", \"true\");\n+            settings.put(\"Event2#stackTrace\", \"true\");\n+            r.setSettings(settings);\n+            Event2 e2 = new Event2();\n+            e2.commit();\n+            System.out.println(\"Awaiting latch 2\");\n+            latch2.await();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/jmx\/streaming\/TestSetSettings.java","additions":109,"deletions":0,"binary":false,"changes":109,"status":"added"}]}