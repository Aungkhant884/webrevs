{"files":[{"patch":"@@ -427,1 +427,1 @@\n-        throw new ConstantPoolException(\"Not a module entry at pos: \" + pos);\n+        throw new ConstantPoolException(\"Not a module entry at index: \" + readU2(pos));\n@@ -433,1 +433,1 @@\n-        throw new ConstantPoolException(\"Not a package entry at pos: \" + pos);\n+        throw new ConstantPoolException(\"Not a package entry at index: \" + readU2(pos));\n@@ -439,1 +439,1 @@\n-        throw new ConstantPoolException(\"Not a class entry at pos: \" + pos);\n+        throw new ConstantPoolException(\"Not a class entry at index: \" + readU2(pos));\n@@ -445,1 +445,1 @@\n-        throw new ConstantPoolException(\"Not a name and type entry at pos: \" + pos);\n+        throw new ConstantPoolException(\"Not a name and type entry at index: \" + readU2(pos));\n@@ -451,1 +451,1 @@\n-        throw new ConstantPoolException(\"Not a method handle entry at pos: \" + pos);\n+        throw new ConstantPoolException(\"Not a method handle entry at index: \" + readU2(pos));\n@@ -457,1 +457,1 @@\n-        throw new ConstantPoolException(\"Not a constant value entry at pos: \" + pos);\n+        throw new ConstantPoolException(\"Not a constant value entry at index: \" + readU2(pos));\n@@ -463,1 +463,1 @@\n-        throw new ConstantPoolException(\"Not an integer entry at pos: \" + pos);\n+        throw new ConstantPoolException(\"Not an integer entry at index: \" + readU2(pos));\n@@ -469,1 +469,1 @@\n-        throw new ConstantPoolException(\"Not a double entry at pos: \" + pos);\n+        throw new ConstantPoolException(\"Not a double entry at index: \" + readU2(pos));\n@@ -475,1 +475,1 @@\n-        throw new ConstantPoolException(\"Not a long entry at pos: \" + pos);\n+        throw new ConstantPoolException(\"Not a long entry at index: \" + readU2(pos));\n@@ -481,1 +481,1 @@\n-        throw new ConstantPoolException(\"Not a float entry at pos: \" + pos);\n+        throw new ConstantPoolException(\"Not a float entry at index: \" + readU2(pos));\n@@ -487,1 +487,1 @@\n-        throw new ConstantPoolException(\"Not a field ref entry at pos: \" + pos);\n+        throw new ConstantPoolException(\"Not a field ref entry at index: \" + readU2(pos));\n@@ -493,1 +493,1 @@\n-        throw new ConstantPoolException(\"Not a member ref entry at pos: \" + pos);\n+        throw new ConstantPoolException(\"Not a member ref entry at index: \" + readU2(pos));\n@@ -499,1 +499,1 @@\n-        throw new ConstantPoolException(\"Not an interface method ref entry at pos: \" + pos);\n+        throw new ConstantPoolException(\"Not an interface method ref entry at index: \" + readU2(pos));\n@@ -505,1 +505,1 @@\n-        throw new ConstantPoolException(\"Not an invoke dynamic entry at pos: \" + pos);\n+        throw new ConstantPoolException(\"Not an invoke dynamic entry at index: \" + readU2(pos));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ClassReaderImpl.java","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -115,55 +115,60 @@\n-        \/\/ compute the number of indentations for the body of multi-line instructions\n-        \/\/ This is 6 (the width of \"%4d: \"), divided by the width of each indentation level,\n-        \/\/ and rounded up to the next integer.\n-        int indentWidth = options.indentWidth;\n-        int indent = (6 + indentWidth - 1) \/ indentWidth;\n-        switch (ins) {\n-            case BranchInstruction instr ->\n-                print(lr.labelToBci(instr.target()));\n-            case ConstantInstruction.ArgumentConstantInstruction instr ->\n-                print(instr.constantValue());\n-            case ConstantInstruction.LoadConstantInstruction instr ->\n-                printConstantPoolRef(instr.constantEntry());\n-            case FieldInstruction instr ->\n-                printConstantPoolRef(instr.field());\n-            case InvokeDynamicInstruction instr ->\n-                printConstantPoolRefAndValue(instr.invokedynamic(), 0);\n-            case InvokeInstruction instr -> {\n-                if (instr.isInterface() && instr.opcode() != Opcode.INVOKESTATIC)\n-                    printConstantPoolRefAndValue(instr.method(), instr.count());\n-                else printConstantPoolRef(instr.method());\n-            }\n-            case LoadInstruction instr ->\n-                print(instr.sizeInBytes() > 1 ? instr.slot() : \"\");\n-            case StoreInstruction instr ->\n-                print(instr.sizeInBytes() > 1 ? instr.slot() : \"\");\n-            case IncrementInstruction instr ->\n-                print(instr.slot() + \", \" + instr.constant());\n-            case LookupSwitchInstruction instr -> {\n-                var cases = instr.cases();\n-                print(\"{ \/\/ \" + cases.size());\n-                indent(indent);\n-                for (var c : cases)\n-                    print(String.format(\"%n%12d: %d\", c.caseValue(),\n-                            lr.labelToBci(c.target())));\n-                print(\"\\n     default: \" + lr.labelToBci(instr.defaultTarget()) + \"\\n}\");\n-                indent(-indent);\n-            }\n-            case NewMultiArrayInstruction instr ->\n-                printConstantPoolRefAndValue(instr.arrayType(), instr.dimensions());\n-            case NewObjectInstruction instr ->\n-                printConstantPoolRef(instr.className());\n-            case NewPrimitiveArrayInstruction instr ->\n-                print(\" \" + instr.typeKind().typeName());\n-            case NewReferenceArrayInstruction instr ->\n-                printConstantPoolRef(instr.componentType());\n-            case TableSwitchInstruction instr -> {\n-                print(\"{ \/\/ \" + instr.lowValue() + \" to \" + instr.highValue());\n-                indent(indent);\n-                var caseMap = instr.cases().stream().collect(\n-                        Collectors.toMap(SwitchCase::caseValue, SwitchCase::target));\n-                for (int i = instr.lowValue(); i <= instr.highValue(); i++)\n-                    print(String.format(\"%n%12d: %d\", i,\n-                            lr.labelToBci(caseMap.getOrDefault(i, instr.defaultTarget()))));\n-                print(\"\\n     default: \" + lr.labelToBci(instr.defaultTarget()) + \"\\n}\");\n-                indent(-indent);\n+        try {\n+            \/\/ compute the number of indentations for the body of multi-line instructions\n+            \/\/ This is 6 (the width of \"%4d: \"), divided by the width of each indentation level,\n+            \/\/ and rounded up to the next integer.\n+            int indentWidth = options.indentWidth;\n+            int indent = (6 + indentWidth - 1) \/ indentWidth;\n+            switch (ins) {\n+                case BranchInstruction instr ->\n+                    print(lr.labelToBci(instr.target()));\n+                case ConstantInstruction.ArgumentConstantInstruction instr ->\n+                    print(instr.constantValue());\n+                case ConstantInstruction.LoadConstantInstruction instr ->\n+                    printConstantPoolRef(instr.constantEntry());\n+                case FieldInstruction instr ->\n+                    printConstantPoolRef(instr.field());\n+                case InvokeDynamicInstruction instr ->\n+                    printConstantPoolRefAndValue(instr.invokedynamic(), 0);\n+                case InvokeInstruction instr -> {\n+                    if (instr.isInterface() && instr.opcode() != Opcode.INVOKESTATIC)\n+                        printConstantPoolRefAndValue(instr.method(), instr.count());\n+                    else printConstantPoolRef(instr.method());\n+                }\n+                case LoadInstruction instr ->\n+                    print(instr.sizeInBytes() > 1 ? instr.slot() : \"\");\n+                case StoreInstruction instr ->\n+                    print(instr.sizeInBytes() > 1 ? instr.slot() : \"\");\n+                case IncrementInstruction instr ->\n+                    print(instr.slot() + \", \" + instr.constant());\n+                case LookupSwitchInstruction instr -> {\n+                    var cases = instr.cases();\n+                    print(\"{ \/\/ \" + cases.size());\n+                    indent(indent);\n+                    for (var c : cases)\n+                        print(String.format(\"%n%12d: %d\", c.caseValue(),\n+                                lr.labelToBci(c.target())));\n+                    print(\"\\n     default: \" + lr.labelToBci(instr.defaultTarget()) + \"\\n}\");\n+                    indent(-indent);\n+                }\n+                case NewMultiArrayInstruction instr ->\n+                    printConstantPoolRefAndValue(instr.arrayType(), instr.dimensions());\n+                case NewObjectInstruction instr ->\n+                    printConstantPoolRef(instr.className());\n+                case NewPrimitiveArrayInstruction instr ->\n+                    print(\" \" + instr.typeKind().typeName());\n+                case NewReferenceArrayInstruction instr ->\n+                    printConstantPoolRef(instr.componentType());\n+                case TableSwitchInstruction instr -> {\n+                    print(\"{ \/\/ \" + instr.lowValue() + \" to \" + instr.highValue());\n+                    indent(indent);\n+                    var caseMap = instr.cases().stream().collect(\n+                            Collectors.toMap(SwitchCase::caseValue, SwitchCase::target));\n+                    for (int i = instr.lowValue(); i <= instr.highValue(); i++)\n+                        print(String.format(\"%n%12d: %d\", i,\n+                                lr.labelToBci(caseMap.getOrDefault(i, instr.defaultTarget()))));\n+                    print(\"\\n     default: \" + lr.labelToBci(instr.defaultTarget()) + \"\\n}\");\n+                    indent(-indent);\n+                }\n+                case TypeCheckInstruction instr ->\n+                    printConstantPoolRef(instr.type());\n+                default -> {}\n@@ -171,3 +176,3 @@\n-            case TypeCheckInstruction instr ->\n-                printConstantPoolRef(instr.type());\n-            default -> {}\n+            println();\n+        } catch (IllegalArgumentException e) {\n+            println(report(e));\n@@ -175,1 +180,0 @@\n-        println();\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/javap\/CodeWriter.java","additions":63,"deletions":59,"binary":false,"changes":122,"status":"modified"}]}