{"files":[{"patch":"@@ -110,2 +110,7 @@\n-        static final ConcurrentMap<WeakClassKey,Reference<?>> localDescs =\n-            new ConcurrentHashMap<>();\n+        static final ClassValue<ObjectStreamClass> localDescs =\n+            new ClassValue<>() {\n+                @Override\n+                protected ObjectStreamClass computeValue(Class<?> type) {\n+                    return new ObjectStreamClass(type);\n+                }\n+            };\n@@ -114,9 +119,7 @@\n-        static final ConcurrentMap<FieldReflectorKey,Reference<?>> reflectors =\n-            new ConcurrentHashMap<>();\n-\n-        \/** queue for WeakReferences to local classes *\/\n-        private static final ReferenceQueue<Class<?>> localDescsQueue =\n-            new ReferenceQueue<>();\n-        \/** queue for WeakReferences to field reflectors keys *\/\n-        private static final ReferenceQueue<Class<?>> reflectorsQueue =\n-            new ReferenceQueue<>();\n+        static final ClassValue<Map<FieldReflectorKey, FieldReflector>> reflectors =\n+            new ClassValue<>() {\n+                @Override\n+                protected Map<FieldReflectorKey, FieldReflector> computeValue(Class<?> type) {\n+                    return new ConcurrentHashMap<>();\n+                }\n+            };\n@@ -364,65 +367,1 @@\n-        processQueue(Caches.localDescsQueue, Caches.localDescs);\n-        WeakClassKey key = new WeakClassKey(cl, Caches.localDescsQueue);\n-        Reference<?> ref = Caches.localDescs.get(key);\n-        Object entry = null;\n-        if (ref != null) {\n-            entry = ref.get();\n-        }\n-        EntryFuture future = null;\n-        if (entry == null) {\n-            EntryFuture newEntry = new EntryFuture();\n-            Reference<?> newRef = new WeakReference<>(newEntry);\n-            do {\n-                if (ref != null) {\n-                    Caches.localDescs.remove(key, ref);\n-                }\n-                ref = Caches.localDescs.putIfAbsent(key, newRef);\n-                if (ref != null) {\n-                    entry = ref.get();\n-                }\n-            } while (ref != null && entry == null);\n-            if (entry == null) {\n-                future = newEntry;\n-            }\n-        }\n-\n-        if (entry instanceof ObjectStreamClass) {  \/\/ check common case first\n-            return (ObjectStreamClass) entry;\n-        }\n-        if (entry instanceof EntryFuture) {\n-            future = (EntryFuture) entry;\n-            if (future.getOwner() == Thread.currentThread()) {\n-                \/*\n-                 * Handle nested call situation described by 4803747: waiting\n-                 * for future value to be set by a lookup() call further up the\n-                 * stack will result in deadlock, so calculate and set the\n-                 * future value here instead.\n-                 *\/\n-                entry = null;\n-            } else {\n-                entry = future.get();\n-            }\n-        }\n-        if (entry == null) {\n-            try {\n-                entry = new ObjectStreamClass(cl);\n-            } catch (Throwable th) {\n-                entry = th;\n-            }\n-            if (future.set(entry)) {\n-                Caches.localDescs.put(key, new WeakReference<>(entry));\n-            } else {\n-                \/\/ nested lookup call already set future\n-                entry = future.get();\n-            }\n-        }\n-\n-        if (entry instanceof ObjectStreamClass) {\n-            return (ObjectStreamClass) entry;\n-        } else if (entry instanceof RuntimeException) {\n-            throw (RuntimeException) entry;\n-        } else if (entry instanceof Error) {\n-            throw (Error) entry;\n-        } else {\n-            throw new InternalError(\"unexpected entry: \" + entry);\n-        }\n+        return Caches.localDescs.get(cl);\n@@ -2250,24 +2189,9 @@\n-            localDesc.cl : null;\n-        processQueue(Caches.reflectorsQueue, Caches.reflectors);\n-        FieldReflectorKey key = new FieldReflectorKey(cl, fields,\n-                                                      Caches.reflectorsQueue);\n-        Reference<?> ref = Caches.reflectors.get(key);\n-        Object entry = null;\n-        if (ref != null) {\n-            entry = ref.get();\n-        }\n-        EntryFuture future = null;\n-        if (entry == null) {\n-            EntryFuture newEntry = new EntryFuture();\n-            Reference<?> newRef = new WeakReference<>(newEntry);\n-            do {\n-                if (ref != null) {\n-                    Caches.reflectors.remove(key, ref);\n-                }\n-                ref = Caches.reflectors.putIfAbsent(key, newRef);\n-                if (ref != null) {\n-                    entry = ref.get();\n-                }\n-            } while (ref != null && entry == null);\n-            if (entry == null) {\n-                future = newEntry;\n+            localDesc.cl : Void.class;\n+        var clReflectors = Caches.reflectors.get(cl);\n+        var key = new FieldReflectorKey(fields);\n+        var reflector = clReflectors.get(key);\n+        if (reflector == null) {\n+            reflector = new FieldReflector(matchFields(fields, localDesc));\n+            var oldReflector = clReflectors.putIfAbsent(key, reflector);\n+            if (oldReflector != null) {\n+                reflector = oldReflector;\n@@ -2276,26 +2200,1 @@\n-\n-        if (entry instanceof FieldReflector) {  \/\/ check common case first\n-            return (FieldReflector) entry;\n-        } else if (entry instanceof EntryFuture) {\n-            entry = ((EntryFuture) entry).get();\n-        } else if (entry == null) {\n-            try {\n-                entry = new FieldReflector(matchFields(fields, localDesc));\n-            } catch (Throwable th) {\n-                entry = th;\n-            }\n-            future.set(entry);\n-            Caches.reflectors.put(key, new WeakReference<>(entry));\n-        }\n-\n-        if (entry instanceof FieldReflector) {\n-            return (FieldReflector) entry;\n-        } else if (entry instanceof InvalidClassException) {\n-            throw (InvalidClassException) entry;\n-        } else if (entry instanceof RuntimeException) {\n-            throw (RuntimeException) entry;\n-        } else if (entry instanceof Error) {\n-            throw (Error) entry;\n-        } else {\n-            throw new InternalError(\"unexpected entry: \" + entry);\n-        }\n+        return reflector;\n@@ -2306,1 +2205,1 @@\n-     * refer to the same class and equivalent field formats.\n+     * refer to equivalent field formats.\n@@ -2308,1 +2207,1 @@\n-    private static class FieldReflectorKey extends WeakReference<Class<?>> {\n+    private static class FieldReflectorKey {\n@@ -2312,1 +2211,0 @@\n-        private final boolean nullClass;\n@@ -2314,2 +2212,1 @@\n-        FieldReflectorKey(Class<?> cl, ObjectStreamField[] fields,\n-                          ReferenceQueue<Class<?>> queue)\n+        FieldReflectorKey(ObjectStreamField[] fields)\n@@ -2317,2 +2214,0 @@\n-            super(cl, queue);\n-            nullClass = (cl == null);\n@@ -2325,1 +2220,1 @@\n-            hash = System.identityHashCode(cl) + Arrays.hashCode(sigs);\n+            hash = Arrays.hashCode(sigs);\n@@ -2333,13 +2228,3 @@\n-            if (obj == this) {\n-                return true;\n-            }\n-\n-            if (obj instanceof FieldReflectorKey other) {\n-                Class<?> referent;\n-                return (nullClass ? other.nullClass\n-                                  : ((referent = get()) != null) &&\n-                                    (other.refersTo(referent))) &&\n-                        Arrays.equals(sigs, other.sigs);\n-            } else {\n-                return false;\n-            }\n+            return obj == this ||\n+                   obj instanceof FieldReflectorKey other &&\n+                   Arrays.equals(sigs, other.sigs);\n","filename":"src\/java.base\/share\/classes\/java\/io\/ObjectStreamClass.java","additions":32,"deletions":147,"binary":false,"changes":179,"status":"modified"}]}