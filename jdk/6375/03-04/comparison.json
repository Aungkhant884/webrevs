{"files":[{"patch":"@@ -0,0 +1,87 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.io;\n+\n+import java.lang.ref.Reference;\n+import java.lang.ref.ReferenceQueue;\n+import java.lang.ref.SoftReference;\n+\n+\/\/ Maps Class instances to values of type T. Under memory pressure, the\n+\/\/ mapping is released (under soft references GC policy) and would be\n+\/\/ recomputed the next time it is queried. The mapping is bound to the\n+\/\/ lifetime of the class: when the class is unloaded, the mapping is\n+\/\/ removed too.\n+abstract class ClassCache<T> {\n+\n+    private static class CacheRef<T> extends SoftReference<T> {\n+        private Class<?> type;\n+\n+        CacheRef(T referent, ReferenceQueue<T> queue, Class<?> type) {\n+            super(referent, queue);\n+            this.type = type;\n+        }\n+\n+        Class<?> getType() {\n+            return type;\n+        }\n+    }\n+\n+    private final ReferenceQueue<T> queue;\n+    private final ClassValue<SoftReference<T>> map;\n+\n+    protected abstract T computeValue(Class<?> cl);\n+\n+    protected ClassCache() {\n+        queue = new ReferenceQueue<>();\n+        map = new ClassValue<>() {\n+            @Override\n+            protected SoftReference<T> computeValue(Class<?> type) {\n+                return new SoftReference<>(ClassCache.this.computeValue(type), queue);\n+            }\n+        };\n+    }\n+\n+    T get(Class<?> cl) {\n+        processQueue();\n+        T val;\n+        do {\n+            SoftReference<T> ref = map.get(cl);\n+            val = ref.get();\n+            if (val == null) {\n+                map.remove(cl);\n+            }\n+        } while (val == null);\n+        return val;\n+    }\n+\n+    private void processQueue() {\n+        Reference<? extends T> ref;\n+        while((ref = queue.poll()) != null) {\n+            CacheRef<? extends T> cacheRef = (CacheRef<? extends T>)ref;\n+            map.remove(cacheRef.getType());\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/io\/ClassCache.java","additions":87,"deletions":0,"binary":false,"changes":87,"status":"added"},{"patch":"@@ -33,0 +33,1 @@\n+import java.lang.ref.SoftReference;\n@@ -110,2 +111,2 @@\n-        static final ClassValue<ObjectStreamClass> localDescs =\n-            new ClassValue<>() {\n+        static final ClassCache<ObjectStreamClass> localDescs =\n+            new ClassCache<>() {\n@@ -119,2 +120,2 @@\n-        static final ClassValue<Map<FieldReflectorKey, FieldReflector>> reflectors =\n-            new ClassValue<>() {\n+        static final ClassCache<Map<FieldReflectorKey, FieldReflector>> reflectors =\n+            new ClassCache<>() {\n@@ -2125,0 +2126,1 @@\n+\n","filename":"src\/java.base\/share\/classes\/java\/io\/ObjectStreamClass.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"}]}