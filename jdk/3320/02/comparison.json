{"files":[{"patch":"@@ -532,2 +532,0 @@\n-static GrowableArray<ClassLoaderData*>* _loaded_cld = NULL;\n-\n@@ -535,3 +533,7 @@\n-  void do_cld(ClassLoaderData* cld) {\n-    if (_loaded_cld == NULL) {\n-      _loaded_cld = new (ResourceObj::C_HEAP, mtClassShared)GrowableArray<ClassLoaderData*>(10, mtClassShared);\n+  GrowableArray<ClassLoaderData*> _loaded_cld;\n+public:\n+  CollectCLDClosure() {}\n+  ~CollectCLDClosure() {\n+    for (int i = 0; i < _loaded_cld.length(); i++) {\n+      ClassLoaderData* cld = _loaded_cld.at(i);\n+      cld->dec_keep_alive();\n@@ -539,0 +541,2 @@\n+  }\n+  void do_cld(ClassLoaderData* cld) {\n@@ -541,1 +545,1 @@\n-      _loaded_cld->append(cld);\n+      _loaded_cld.append(cld);\n@@ -544,0 +548,3 @@\n+\n+  int nof_cld() const                { return _loaded_cld.length(); }\n+  ClassLoaderData* cld_at(int index) { return _loaded_cld.at(index); }\n@@ -568,0 +575,1 @@\n+  ResourceMark rm;\n@@ -570,0 +578,4 @@\n+    \/\/ ClassLoaderDataGraph::loaded_cld_do requires ClassLoaderDataGraph_lock.\n+    \/\/ We cannot link the classes while holding this lock (or else we may run into deadlock).\n+    \/\/ Therefore, we need to first collect all the CLDs, and then link their classes after\n+    \/\/ releasing the lock.\n@@ -576,2 +588,2 @@\n-    for (int i = 0; i < _loaded_cld->length(); i++) {\n-      ClassLoaderData* cld = _loaded_cld->at(i);\n+    for (int i = 0; i < collect_cld.nof_cld(); i++) {\n+      ClassLoaderData* cld = collect_cld.cld_at(i);\n@@ -594,5 +606,0 @@\n-\n-  for (int i = 0; i < _loaded_cld->length(); i++) {\n-    ClassLoaderData* cld = _loaded_cld->at(i);\n-    cld->dec_keep_alive();\n-  }\n","filename":"src\/hotspot\/share\/memory\/metaspaceShared.cpp","additions":20,"deletions":13,"binary":false,"changes":33,"status":"modified"}]}