{"files":[{"patch":"@@ -69,0 +69,1 @@\n+#include \"runtime\/deoptimization.hpp\"\n@@ -372,0 +373,35 @@\n+\/\/ ------------------------------------------------------------------\n+\/\/ helper for -XX:+OptimizeImplicitExceptions\n+ciInstanceKlass* ciEnv::exception_instanceKlass_for_reason(Deoptimization::DeoptReason reason) {\n+  Symbol* ex_symbol = NULL;\n+  switch (reason) {\n+  case Deoptimization::Reason_null_check:\n+    ex_symbol = vmSymbols::java_lang_NullPointerException();\n+    break;\n+  case Deoptimization::Reason_div0_check:\n+    ex_symbol = vmSymbols::java_lang_ArithmeticException();\n+    break;\n+  case Deoptimization::Reason_range_check:\n+    ex_symbol = vmSymbols::java_lang_ArrayIndexOutOfBoundsException();\n+    break;\n+  case Deoptimization::Reason_class_check:\n+    ex_symbol = vmSymbols::java_lang_ClassCastException();\n+    break;\n+  case Deoptimization::Reason_array_check:\n+    ex_symbol = vmSymbols::java_lang_ArrayStoreException();\n+    break;\n+  default:\n+    break;\n+  }\n+  ciInstanceKlass* ex_ciInstKlass = NULL;\n+  if (ex_symbol != NULL) {\n+    VM_ENTRY_MARK;\n+    InstanceKlass* ex_instKlass = SystemDictionary::find_instance_klass(ex_symbol, Handle(), Handle());\n+    if (ex_instKlass != NULL) {\n+      ex_ciInstKlass = get_instance_klass(ex_instKlass);\n+    }\n+  }\n+  return ex_ciInstKlass;\n+}\n+\n+\n","filename":"src\/hotspot\/share\/ci\/ciEnv.cpp","additions":36,"deletions":0,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+#include \"runtime\/deoptimization.hpp\"\n@@ -404,0 +405,2 @@\n+  ciInstanceKlass* exception_instanceKlass_for_reason(Deoptimization::DeoptReason reason);\n+\n","filename":"src\/hotspot\/share\/ci\/ciEnv.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1035,2 +1035,2 @@\n-  if (method() == NULL) {\n-    return true; \/\/ call into runtime or uncommon trap\n+  if (method() == NULL || _implicit_exception_init) {\n+    return true; \/\/ call into runtime or uncommon trap or implicit exception <init>\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -680,0 +680,3 @@\n+  bool    _implicit_exception_init;\/\/ <init> call for an implicitly created exception\n+                                   \/\/ if -XX:+OptimizeImplicitExceptions. This also\n+                                   \/\/ overrides the symbolic call site info from bytecode.\n@@ -688,0 +691,1 @@\n+      _implicit_exception_init(false),\n@@ -703,0 +707,2 @@\n+  void  set_implicit_exception_init(bool f){ _implicit_exception_init = f; }\n+  bool  implicit_exception_init() const    { return _implicit_exception_init; }\n","filename":"src\/hotspot\/share\/opto\/callnode.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -622,0 +622,34 @@\n+  if (treat_throw_as_hot && OptimizeImplicitExceptions) {\n+    ciInstanceKlass* ex_ciInstKlass = env()->exception_instanceKlass_for_reason(reason);\n+    if (ex_ciInstKlass != NULL) {\n+      const TypeKlassPtr *ex_type = TypeKlassPtr::make(ex_ciInstKlass);\n+      kill_dead_locals();\n+      Node* ex_node = new_instance(makecon(ex_type), NULL, NULL, true);\n+      set_argument(0, ex_node);\n+      ciMethod* init = ex_ciInstKlass->find_method(ciSymbol::make(\"<init>\"), ciSymbol::make(\"()V\"));\n+\n+      \/\/ The following code is modeled after:\n+      \/\/ DirectCallGenerator* cg = CallGenerator::for_direct_call(init);\n+      \/\/ JVMState *new_jvms = cg->generate(sync_jvms());\n+      \/\/ We can't use that code directly because it assumes at various places that we're\n+      \/\/ at an invoke bytecode which is in genaral not the case for implicit exceptions.\n+\n+      GraphKit kit(sync_jvms());\n+      address target = SharedRuntime::get_resolve_opt_virtual_call_stub();\n+\n+      CallStaticJavaNode *call = new CallStaticJavaNode(kit.C, TypeFunc::make(init), target, init);\n+      call->set_optimized_virtual(true);\n+      call->set_implicit_exception_init(true);\n+      kit.set_arguments_for_java_call(call);\n+      kit.set_edges_for_java_call(call, false, false);\n+      Node *ret = kit.set_results_for_java_call(call, false);\n+      kit.push_node(init->return_type()->basic_type(), ret);\n+      JVMState *new_jvms = kit.transfer_exceptions_into_jvms();\n+\n+      add_exception_states_from(new_jvms);\n+      set_jvms(new_jvms);\n+      add_exception_state(make_exception_state(ex_node));\n+      return;\n+    }\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":34,"deletions":0,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -937,0 +937,3 @@\n+  bool      _implicit_exception_init;\/\/ <init> call for an implicitly created exception\n+                                     \/\/ if -XX:+OptimizeImplicitExceptions. This also\n+                                     \/\/ overrides the symbolic call site info from bytecode.\n@@ -940,1 +943,1 @@\n-  MachCallJavaNode() : MachCallNode(), _override_symbolic_info(false) {\n+  MachCallJavaNode() : MachCallNode(), _override_symbolic_info(false), _implicit_exception_init(false) {\n@@ -947,1 +950,1 @@\n-    if (_override_symbolic_info) {\n+    if (_override_symbolic_info || _implicit_exception_init) {\n","filename":"src\/hotspot\/share\/opto\/machnode.hpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1293,0 +1293,1 @@\n+      mcall_java->_implicit_exception_init = call_java->implicit_exception_init();\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -642,0 +642,4 @@\n+  product(bool, OptimizeImplicitExceptions, true, DIAGNOSTIC,               \\\n+          \"Create implicit, 'non-hot' exceptions right in compiled code \"   \\\n+          \"rather than deoptimizing and resorting back to the interpreter\") \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1093,3 +1093,14 @@\n-  Bytecode_invoke bytecode(caller, bci);\n-  int bytecode_index = bytecode.index();\n-  bc = bytecode.invoke_code();\n+  Bytecode_invoke bytecode = Bytecode_invoke_check(caller, bci);\n+  int bytecode_index = -1;\n+  if (bytecode.is_valid()) {\n+    \/\/ This is the normal case for invoke* bytecodes\n+    bytecode_index = bytecode.index();\n+    bc = bytecode.invoke_code();\n+  } else {\n+    \/\/ This is for implicit exceptions with -XX:+OptimizeImplicitExceptions\n+    \/\/ where we create an artificial call to *Exception::<init>().\n+    \/\/ Notice that we don't catch the case here where we've created an\n+    \/\/ implcit exception (e.g. NPE) for a regular invoke* bytecode.\n+    \/\/ This special case is handled further down.\n+    bc = Bytecodes::_invokespecial;\n+  }\n@@ -1098,1 +1109,1 @@\n-  if (attached_method.not_null()) {\n+  if (attached_method.not_null() && bytecode.is_valid()) {\n@@ -1130,0 +1141,8 @@\n+  if (attached_method.not_null() &&\n+      attached_method->name() == vmSymbols::object_initializer_name()) {\n+    \/\/ If we've created an implicit NPE for an invoke* bytecode due to\n+    \/\/ -XX:+OptimizeImplicitExceptions we have to adjust the bytecode to\n+    \/\/ invokespecial here because we're actually invoking the exceptions\n+    \/\/ constructor.\n+    bc = Bytecodes::_invokespecial;\n+  }\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":23,"deletions":4,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8275908\n+ * @bug 8275908 8273563\n@@ -28,0 +28,1 @@\n+ *          Test -XX:+\/-OmitStackTraceInFastThrow and -XX:+\/-OptimizeImplicitExceptions\n@@ -68,2 +69,2 @@\n-    \/\/ TestMode represents a specific combination of the OmitStackTraceInFastThrow command line options.\n-    \/\/ They will be set up in 'setFlags(TestMode testMode)' before a new test run starts.\n+    \/\/ TestMode represents a specific combination of the OmitStackTraceInFastThrow\/OptimizeImplicitExceptions\n+    \/\/ command line options. They will be set up in 'setFlags(TestMode testMode)' before a new test run starts.\n@@ -72,1 +73,2 @@\n-        STACKTRACES_IN_FASTTHROW\n+        STACKTRACES_IN_FASTTHROW,\n+        STACKTRACES_IN_FASTTHROW_OPTIMIZED\n@@ -132,0 +134,5 @@\n+        if (testMode == TestMode.STACKTRACES_IN_FASTTHROW_OPTIMIZED) {\n+            WB.setBooleanVMFlag(\"OptimizeImplicitExceptions\", true);\n+        } else {\n+            WB.setBooleanVMFlag(\"OptimizeImplicitExceptions\", false);\n+        }\n@@ -135,1 +142,2 @@\n-                           \" OmitStackTraceInFastThrow=\" + WB.getBooleanVMFlag(\"OmitStackTraceInFastThrow\"));\n+                           \" OmitStackTraceInFastThrow=\" + WB.getBooleanVMFlag(\"OmitStackTraceInFastThrow\") +\n+                           \" OptimizeImplicitExceptions=\" + WB.getBooleanVMFlag(\"OptimizeImplicitExceptions\"));\n@@ -173,2 +181,2 @@\n-        if (testMode == TestMode.OMIT_STACKTRACES_IN_FASTTHROW) {\n-            \/\/ No deoptimizations for '-XX:+OmitStackTraceInFastThrow'\n+        if (testMode == TestMode.OMIT_STACKTRACES_IN_FASTTHROW || testMode == TestMode.STACKTRACES_IN_FASTTHROW_OPTIMIZED) {\n+            \/\/ No deoptimizations for '-XX:+OmitStackTraceInFastThrow' and '-XX:-OmitStackTraceInFastThrow -XX:+OptimizeImplicitExceptions'\n@@ -178,1 +186,8 @@\n-            Asserts.assertNull(ex.getMessage(), \"Optimized exceptions have no message.\");\n+            \/\/ '-XX:-OmitStackTraceInFastThrow -XX:+OptimizeImplicitExceptions' has no message except for\n+            \/\/ NullPointerExceptions which are handled differently due to \"JEP 358: Helpful NullPointerExceptions\".\n+            if (testMode == TestMode.STACKTRACES_IN_FASTTHROW_OPTIMIZED &&\n+                (impExcp == ImplicitException.NULL_POINTER_EXCEPTION || impExcp == ImplicitException.INVOKE_NULL_POINTER_EXCEPTION)) {\n+                Asserts.assertNotNull(ex.getMessage(), \"NullPointerExceptions always have a message.\");\n+            } else {\n+                Asserts.assertNull(ex.getMessage(), \"Optimized exceptions have no message.\");\n+            }\n@@ -180,1 +195,1 @@\n-            \/\/ We always deoptimize for '-XX:-OmitStackTraceInFastThrow\n+            \/\/ We always deoptimize for '-XX:-OmitStackTraceInFastThrow -XX:-OptimizeImplicitExceptions'\n","filename":"test\/hotspot\/jtreg\/compiler\/exceptions\/OptimizeImplicitExceptions.java","additions":24,"deletions":9,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -191,1 +191,1 @@\n-                 BadFailOnConstraint.create(Traps.class, \"classCheck()\", 2, \"CallStaticJava\", \"uncommon_trap\", \"class_check\"),\n+                 BadFailOnConstraint.create(Traps.class, \"classCheck()\", 2, \"CallStaticJava\", \"uncommon_trap\", \"unhandled\"),\n@@ -1122,1 +1122,1 @@\n-    @IR(failOn = IRNode.CLASS_CHECK_TRAP) \/\/ fails\n+    @IR(failOn = IRNode.UNHANDLED_TRAP) \/\/ fails (slow-path allocation of implicit ClassCastException)\n@@ -1130,1 +1130,1 @@\n-                  IRNode.UNHANDLED_TRAP})\n+                  IRNode.CLASS_CHECK_TRAP})\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/ir_framework\/tests\/TestIRMatching.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -33,2 +33,2 @@\n- * @run main\/othervm -XX:-OmitStackTraceInFastThrow jit.t.t105.t105\n- * @run main\/othervm -XX:-OmitStackTraceInFastThrow -Xbatch -XX:Tier0BackedgeNotifyFreqLog=0 -XX:Tier2BackedgeNotifyFreqLog=0 -XX:Tier3BackedgeNotifyFreqLog=0 -XX:Tier2BackEdgeThreshold=1 -XX:Tier3BackEdgeThreshold=1 -XX:Tier4BackEdgeThreshold=1 jit.t.t105.t105\n+ * @run main\/othervm -XX:-OmitStackTraceInFastThrow -XX:-OptimizeImplicitExceptions jit.t.t105.t105\n+ * @run main\/othervm -XX:-OmitStackTraceInFastThrow -XX:-OptimizeImplicitExceptions -Xbatch -XX:Tier0BackedgeNotifyFreqLog=0 -XX:Tier2BackedgeNotifyFreqLog=0 -XX:Tier3BackedgeNotifyFreqLog=0 -XX:Tier2BackEdgeThreshold=1 -XX:Tier3BackEdgeThreshold=1 -XX:Tier4BackEdgeThreshold=1 jit.t.t105.t105\n@@ -36,2 +36,3 @@\n- * This test must be run with OmitStackTraceInFastThrow disabled to avoid preallocated\n- * exceptions. They don't have the detailed message that this test relies on.\n+ * This test must be run with OmitStackTraceInFastThrow and OptimizeImplicitExceptions\n+ * disabled to avoid preallocated exceptions. They don't have the detailed message\n+ * that this test relies on.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/jit\/t\/t105\/t105.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,92 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.vm.lang;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Warmup(iterations = 5, time = 5, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 5, time = 5, timeUnit = TimeUnit.SECONDS)\n+@Fork(1)\n+@State(Scope.Benchmark)\n+public class ImplicitExceptions {\n+    static final int ASCII_SIZE = 128;\n+    static final boolean[] ASCII_ALPHA = new boolean[ASCII_SIZE];\n+    static final int testStringLengthLog = 7;\n+    static final int TestStringLenghtMask = (1 << testStringLengthLog) - 1;\n+    static final char[] testString = new char[1 << testStringLengthLog];\n+    int iterator = 0;\n+\n+    @Param({\"0.0\", \"0.33\", \"0.66\", \"1.00\"})\n+    public double exceptionProbability;\n+\n+    @Setup\n+    public void init() {\n+        for (int i = 0; i < ASCII_SIZE; i++) {\n+            if (i >= 'a' && i <= 'z' || i >= 'A' && i <= 'Z') {\n+              ASCII_ALPHA[i] = true;\n+            }\n+        }\n+        Random rnd = new Random();\n+        rnd.setSeed(Long.getLong(\"random.seed\", 42L));\n+        for (int i = 0; i < testString.length; i++) {\n+            if (rnd.nextDouble() < exceptionProbability) {\n+              testString[i] = 0xbad; \/\/ Something bigger than ASCII_SIZE\n+            }\n+            else {\n+              testString[i] = (char)rnd.nextInt(ASCII_SIZE);\n+            }\n+        }\n+    }\n+\n+    public boolean isAlphaWithExceptions(int c) {\n+        try {\n+            return ASCII_ALPHA[c];\n+        } catch (ArrayIndexOutOfBoundsException ex) {\n+            return false;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void bench() {\n+        isAlphaWithExceptions(testString[iterator++ & TestStringLenghtMask]);\n+        \/\/if (++iterator == Long.MAX_VALUE) {\n+        \/\/    iterator = 0;\n+        \/\/}\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/lang\/ImplicitExceptions.java","additions":92,"deletions":0,"binary":false,"changes":92,"status":"added"}]}