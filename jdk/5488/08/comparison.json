{"files":[{"patch":"@@ -69,0 +69,1 @@\n+#include \"runtime\/deoptimization.hpp\"\n@@ -372,0 +373,36 @@\n+\/\/ ------------------------------------------------------------------\n+\/\/ helper for -XX:+OptimizeImplicitExceptions\n+ciInstanceKlass* ciEnv::exception_instanceKlass_for_reason(Deoptimization::DeoptReason reason, bool is_aastore) {\n+  Symbol* ex_symbol = NULL;\n+  switch (reason) {\n+  case Deoptimization::Reason_null_check:\n+    ex_symbol = vmSymbols::java_lang_NullPointerException();\n+    break;\n+  case Deoptimization::Reason_div0_check:\n+    ex_symbol = vmSymbols::java_lang_ArithmeticException();\n+    break;\n+  case Deoptimization::Reason_range_check:\n+    ex_symbol = vmSymbols::java_lang_ArrayIndexOutOfBoundsException();\n+    break;\n+  case Deoptimization::Reason_class_check:\n+    if (is_aastore) {\n+      ex_symbol = vmSymbols::java_lang_ArrayStoreException();\n+    } else {\n+      ex_symbol = vmSymbols::java_lang_ClassCastException();\n+    }\n+    break;\n+  default:\n+    break;\n+  }\n+  ciInstanceKlass* ex_ciInstKlass = NULL;\n+  if (ex_symbol != NULL) {\n+    VM_ENTRY_MARK;\n+    InstanceKlass* ex_instKlass = SystemDictionary::find_instance_klass(ex_symbol, Handle(), Handle());\n+    if (ex_instKlass != NULL) {\n+      ex_ciInstKlass = get_instance_klass(ex_instKlass);\n+    }\n+  }\n+  return ex_ciInstKlass;\n+}\n+\n+\n","filename":"src\/hotspot\/share\/ci\/ciEnv.cpp","additions":37,"deletions":0,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+#include \"runtime\/deoptimization.hpp\"\n@@ -404,0 +405,2 @@\n+  ciInstanceKlass* exception_instanceKlass_for_reason(Deoptimization::DeoptReason reason, bool is_aastore);\n+\n","filename":"src\/hotspot\/share\/ci\/ciEnv.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1035,2 +1035,2 @@\n-  if (method() == NULL) {\n-    return true; \/\/ call into runtime or uncommon trap\n+  if (method() == NULL || _implicit_exception_init) {\n+    return true; \/\/ call into runtime or uncommon trap or implicit exception <init>\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -680,0 +680,3 @@\n+  bool    _implicit_exception_init;\/\/ <init> call for an implicitly created exception\n+                                   \/\/ if -XX:+OptimizeImplicitExceptions. This also\n+                                   \/\/ overrides the symbolic call site info from bytecode.\n@@ -688,0 +691,1 @@\n+      _implicit_exception_init(false),\n@@ -703,0 +707,2 @@\n+  void  set_implicit_exception_init(bool f){ _implicit_exception_init = f; }\n+  bool  implicit_exception_init() const    { return _implicit_exception_init; }\n","filename":"src\/hotspot\/share\/opto\/callnode.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -619,0 +619,35 @@\n+      return;\n+    }\n+  }\n+\n+  if (treat_throw_as_hot && OptimizeImplicitExceptions) {\n+    ciInstanceKlass* ex_ciInstKlass =\n+      env()->exception_instanceKlass_for_reason(reason, java_bc() == Bytecodes::_aastore);\n+    if (ex_ciInstKlass != NULL) {\n+      const TypeKlassPtr *ex_type = TypeKlassPtr::make(ex_ciInstKlass);\n+      kill_dead_locals();\n+      Node* ex_node = new_instance(makecon(ex_type), NULL, NULL, true);\n+      set_argument(0, ex_node);\n+      ciMethod* init = ex_ciInstKlass->find_method(ciSymbol::make(\"<init>\"), ciSymbol::make(\"()V\"));\n+\n+      \/\/ The following code is modeled after:\n+      \/\/ DirectCallGenerator* cg = CallGenerator::for_direct_call(init);\n+      \/\/ JVMState *new_jvms = cg->generate(sync_jvms());\n+      \/\/ We can't use that code directly because it assumes at various places that we're\n+      \/\/ at an invoke bytecode which is in genaral not the case for implicit exceptions.\n+\n+      GraphKit kit(sync_jvms());\n+      address target = SharedRuntime::get_resolve_opt_virtual_call_stub();\n+\n+      CallStaticJavaNode *call = new CallStaticJavaNode(kit.C, TypeFunc::make(init), target, init);\n+      call->set_optimized_virtual(true);\n+      call->set_implicit_exception_init(true);\n+      kit.set_arguments_for_java_call(call);\n+      kit.set_edges_for_java_call(call, false, false);\n+      Node *ret = kit.set_results_for_java_call(call, false);\n+      kit.push_node(init->return_type()->basic_type(), ret);\n+      JVMState *new_jvms = kit.transfer_exceptions_into_jvms();\n+\n+      add_exception_states_from(new_jvms);\n+      set_jvms(new_jvms);\n+      add_exception_state(make_exception_state(ex_node));\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":35,"deletions":0,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -937,0 +937,3 @@\n+  bool      _implicit_exception_init;\/\/ <init> call for an implicitly created exception\n+                                     \/\/ if -XX:+OptimizeImplicitExceptions. This also\n+                                     \/\/ overrides the symbolic call site info from bytecode.\n@@ -940,1 +943,1 @@\n-  MachCallJavaNode() : MachCallNode(), _override_symbolic_info(false) {\n+  MachCallJavaNode() : MachCallNode(), _override_symbolic_info(false), _implicit_exception_init(false) {\n@@ -947,1 +950,1 @@\n-    if (_override_symbolic_info) {\n+    if (_override_symbolic_info || _implicit_exception_init) {\n","filename":"src\/hotspot\/share\/opto\/machnode.hpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1258,0 +1258,1 @@\n+      mcall_java->_implicit_exception_init = call_java->implicit_exception_init();\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -958,0 +958,66 @@\n+WB_ENTRY(jint, WB_GetMethodDecompileCount(JNIEnv* env, jobject o, jobject method))\n+  jmethodID jmid = reflected_method_to_jmid(thread, env, method);\n+  CHECK_JNI_EXCEPTION_(env, 0);\n+  methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));\n+  uint cnt = 0;\n+  MethodData* mdo = mh->method_data();\n+  if (mdo != NULL) {\n+    cnt = mdo->decompile_count();\n+  }\n+  return cnt;\n+WB_END\n+\n+\/\/ Get the trap count of a method for a specific reason. If the trap count for\n+\/\/ that reason did overflow, this includes the overflow trap count of the method.\n+\/\/ If 'reason' is NULL, the sum of the traps for all reasons will be returned.\n+\/\/ This number includes the overflow trap count if the trap count for any reason\n+\/\/ did overflow.\n+WB_ENTRY(jint, WB_GetMethodTrapCount(JNIEnv* env, jobject o, jobject method, jstring reason_obj))\n+  jmethodID jmid = reflected_method_to_jmid(thread, env, method);\n+  CHECK_JNI_EXCEPTION_(env, 0);\n+  methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));\n+  uint cnt = 0;\n+  MethodData* mdo = mh->method_data();\n+  if (mdo != NULL) {\n+    ResourceMark rm(THREAD);\n+    char* reason_str = (reason_obj == NULL) ?\n+      NULL : java_lang_String::as_utf8_string(JNIHandles::resolve_non_null(reason_obj));\n+    bool overflow = false;\n+    for (uint reason = 0; reason < mdo->trap_reason_limit(); reason++) {\n+      if (reason_str != NULL && !strcmp(reason_str, Deoptimization::trap_reason_name(reason))) {\n+        cnt = mdo->trap_count(reason);\n+        \/\/ Count in the overflow trap count on overflow\n+        if (cnt == (uint)-1) {\n+          cnt = mdo->trap_count_limit() + mdo->overflow_trap_count();\n+        }\n+        break;\n+      } else if (reason_str == NULL) {\n+        uint c = mdo->trap_count(reason);\n+        if (c == (uint)-1) {\n+          c = mdo->trap_count_limit();\n+          if (!overflow) {\n+            \/\/ Count overflow trap count just once\n+            overflow = true;\n+            c += mdo->overflow_trap_count();\n+          }\n+        }\n+        cnt += c;\n+      }\n+    }\n+  }\n+  return cnt;\n+WB_END\n+\n+WB_ENTRY(jint, WB_GetDeoptCount(JNIEnv* env, jobject o, jstring reason_obj, jstring action_obj))\n+  if (reason_obj == NULL && action_obj == NULL) {\n+    return Deoptimization::total_deoptimization_count();\n+  }\n+  ResourceMark rm(THREAD);\n+  const char *reason_str = (reason_obj == NULL) ?\n+    NULL : java_lang_String::as_utf8_string(JNIHandles::resolve_non_null(reason_obj));\n+  const char *action_str = (action_obj == NULL) ?\n+    NULL : java_lang_String::as_utf8_string(JNIHandles::resolve_non_null(action_obj));\n+\n+  return Deoptimization::deoptimization_count(reason_str, action_str);\n+WB_END\n+\n@@ -2523,0 +2589,7 @@\n+  {CC\"getMethodDecompileCount0\",\n+      CC\"(Ljava\/lang\/reflect\/Executable;)I\",          (void*)&WB_GetMethodDecompileCount},\n+  {CC\"getMethodTrapCount0\",\n+      CC\"(Ljava\/lang\/reflect\/Executable;Ljava\/lang\/String;)I\",\n+                                                      (void*)&WB_GetMethodTrapCount},\n+  {CC\"getDeoptCount0\",\n+      CC\"(Ljava\/lang\/String;Ljava\/lang\/String;)I\",    (void*)&WB_GetDeoptCount},\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":73,"deletions":0,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -2611,0 +2611,24 @@\n+\/\/ Get the deopt count for a specific reason and a specific action. If either\n+\/\/ one of 'reason' or 'action' is null, the method returns the sum of all\n+\/\/ deoptimizations with the specific 'action' or 'reason' respectively.\n+\/\/ If both arguments are null, the method returns the total deopt count.\n+jint Deoptimization::deoptimization_count(const char *reason_str, const char *action_str) {\n+  if (reason_str == NULL && action_str == NULL) {\n+    return total_deoptimization_count();\n+  }\n+  juint counter = 0;\n+  for (int reason = 0; reason < Reason_LIMIT; reason++) {\n+    if (reason_str == NULL || !strcmp(reason_str, trap_reason_name(reason))) {\n+      for (int action = 0; action < Action_LIMIT; action++) {\n+        if (action_str == NULL || !strcmp(action_str, trap_action_name(action))) {\n+          juint* cases = _deoptimization_hist[reason][1+action];\n+          for (int bc_case = 0; bc_case < BC_CASE_LIMIT; bc_case++) {\n+            counter += cases[bc_case] >> LSB_BITS;\n+          }\n+        }\n+      }\n+    }\n+  }\n+  return counter;\n+}\n+\n@@ -2664,0 +2688,8 @@\n+jint Deoptimization::total_deoptimization_count() {\n+  return 0;\n+}\n+\n+jint Deoptimization::deoptimization_count(const char *reason_str, const char *action_str) {\n+  return 0;\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":32,"deletions":0,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -436,0 +436,1 @@\n+  static jint deoptimization_count(const char *reason_str, const char *action_str);\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -645,0 +645,4 @@\n+  product(bool, OptimizeImplicitExceptions, true, DIAGNOSTIC,               \\\n+          \"Create implicit, 'non-hot' exceptions right in compiled code \"   \\\n+          \"rather than deoptimizing and resorting back to the interpreter\") \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1089,3 +1089,14 @@\n-  Bytecode_invoke bytecode(caller, bci);\n-  int bytecode_index = bytecode.index();\n-  bc = bytecode.invoke_code();\n+  Bytecode_invoke bytecode = Bytecode_invoke_check(caller, bci);\n+  int bytecode_index = -1;\n+  if (bytecode.is_valid()) {\n+    \/\/ This is the normal case for invoke* bytecodes\n+    bytecode_index = bytecode.index();\n+    bc = bytecode.invoke_code();\n+  } else {\n+    \/\/ This is for implicit exceptions with -XX:+OptimizeImplicitExceptions\n+    \/\/ where we create an artificial call to *Exception::<init>().\n+    \/\/ Notice that we don't catch the case here where we've created an\n+    \/\/ implcit exception (e.g. NPE) for a regular invoke* bytecode.\n+    \/\/ This special case is handled further down.\n+    bc = Bytecodes::_invokespecial;\n+  }\n@@ -1094,1 +1105,1 @@\n-  if (attached_method.not_null()) {\n+  if (attached_method.not_null() && bytecode.is_valid()) {\n@@ -1126,0 +1137,8 @@\n+  if (attached_method.not_null() &&\n+      attached_method->name() == vmSymbols::object_initializer_name()) {\n+    \/\/ If we've created an implicit NPE for an invoke* bytecode due to\n+    \/\/ -XX:+OptimizeImplicitExceptions we have to adjust the bytecode to\n+    \/\/ invokespecial here because we're actually invoking the exceptions\n+    \/\/ constructor.\n+    bc = Bytecodes::_invokespecial;\n+  }\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":23,"deletions":4,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -0,0 +1,411 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+ \/*\n+ * @test\n+ * @bug 8273563 8275908\n+ * @summary Test -XX:+\/-OmitStackTraceInFastThrow and -XX:+\/-OptimizeImplicitExceptions\n+ *\n+ * @requires vm.compiler2.enabled & vm.compMode != \"Xcomp\"\n+ *\n+ * @library \/test\/lib\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -XX:+UseSerialGC -Xbatch -XX:-UseOnStackReplacement -XX:-TieredCompilation\n+ *                   -XX:CompileCommand=compileonly,compiler.exceptions.OptimizeImplicitExceptions::throwImplicitException\n+ *                   compiler.exceptions.OptimizeImplicitExceptions\n+ *\/\n+\n+package compiler.exceptions;\n+\n+import java.lang.reflect.Method;\n+import java.util.HashMap;\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.whitebox.WhiteBox;\n+\n+public class OptimizeImplicitExceptions {\n+    \/\/ ImplicitException represents the various implicit (aka. 'built-in') exceptions\n+    \/\/ which can be thrown implicitely by the JVM when executing bytecodes.\n+    public enum ImplicitException {\n+        \/\/ NullPointerException during field access\n+        NULL_POINTER_EXCEPTION(\"null_check\"),\n+        \/\/ NullPointerException during invoke\n+        INVOKE_NULL_POINTER_EXCEPTION(\"null_check\"),\n+        ARITHMETIC_EXCEPTION(\"div0_check\"),\n+        ARRAY_INDEX_OUT_OF_BOUNDS_EXCEPTION(\"range_check\"),\n+        ARRAY_STORE_EXCEPTION(\"array_check\"),\n+        CLASS_CAST_EXCEPTION(\"class_check\");\n+        private final String reason;\n+        ImplicitException(String reason) {\n+            this.reason = reason;\n+        }\n+        public String getReason() {\n+            return reason;\n+        }\n+    }\n+    \/\/ TestMode represents a specific combination of the OmitStackTraceInFastThrow\/OptimizeImplicitExceptions\n+    \/\/ command line options. They will be set up in 'setFlags(TestMode testMode)' before a new test run starts.\n+    public enum TestMode {\n+        OMIT_STACKTRACES_IN_FASTTHROW,\n+        STACKTRACES_IN_FASTTHROW,\n+        STACKTRACES_IN_FASTTHROW_OPTIMIZED\n+    }\n+\n+    private static final WhiteBox WB = WhiteBox.getWhiteBox();\n+    \/\/ Until JDK-8275908 is not fixed, null-pointer traps for invokes and array-store traps are not profiled in the interpreter.\n+    private static final boolean JDK8275908_fixed = false;\n+    \/\/ The number of deoptimizations after which a method will be made not-entrant\n+    private static final int PerBytecodeTrapLimit = WB.getIntxVMFlag(\"PerBytecodeTrapLimit\").intValue();\n+    \/\/ The number of interpreter invocations after which a decompiled method will be re-compiled.\n+    private static final int Tier0InvokeNotifyFreq = (int)Math.pow(2, WB.getIntxVMFlag(\"Tier0InvokeNotifyFreqLog\"));\n+    \/\/ The following variables are used to track the value of the global deopt counters between the various test phases.\n+    private static int oldDeoptCount = 0;\n+    private static HashMap<String, Integer> oldDeoptCountReason = new HashMap<String, Integer>(ImplicitException.values().length);\n+    \/\/ The following two objects are declared statically to simplify the test method.\n+    private static String[] string_a = new String[1];\n+    private static final Object o = new Object();\n+\n+    \/\/ This is the main test method. It will repeatedly called with the same ImplicitException 'type' to\n+    \/\/ JIT-compile it, deoptimized it, re-compile it again and do various checks on the way.\n+    \/\/ This process will be repeated then for each kind of ImplicitException 'type'.\n+    public static Object throwImplicitException(ImplicitException type, Object[] object_a) {\n+        switch (type) {\n+            case NULL_POINTER_EXCEPTION: {\n+                return object_a.length;\n+            }\n+            case INVOKE_NULL_POINTER_EXCEPTION: {\n+                return object_a.hashCode();\n+            }\n+            case ARITHMETIC_EXCEPTION: {\n+                return ((42 \/ (object_a.length - 1)) > 2) ? null : object_a[0];\n+            }\n+            case ARRAY_INDEX_OUT_OF_BOUNDS_EXCEPTION: {\n+                return object_a[5];\n+            }\n+            case ARRAY_STORE_EXCEPTION: {\n+                return (object_a[0] = o);\n+            }\n+            case CLASS_CAST_EXCEPTION: {\n+                return (ImplicitException[])object_a;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    \/\/ Completely unload (i.e. make \"not-entrant\"->\"zombie\"->\"unload\/free\") a JIT-compiled\n+    \/\/ version of a method and clear the method's profiling counters.\n+    private static void unloadAndClean(Method m) {\n+        WB.deoptimizeMethod(m);  \/\/ Makes the nmethod \"not entrant\".\n+        WB.forceNMethodSweep();  \/\/ Makes all \"not entrant\" nmethods \"zombie\". This requires\n+        WB.forceNMethodSweep();  \/\/ two sweeps, see 'nmethod::can_convert_to_zombie()' for why.\n+        WB.forceNMethodSweep();  \/\/ Need third sweep to actually unload\/free all \"zombie\" nmethods.\n+        System.gc();\n+        WB.clearMethodState(m);\n+    }\n+\n+    \/\/ Set '-XX' flags according to 'TestMode'\n+    private static void setFlags(TestMode testMode) {\n+        if (testMode == TestMode.OMIT_STACKTRACES_IN_FASTTHROW) {\n+            WB.setBooleanVMFlag(\"OmitStackTraceInFastThrow\", true);\n+        } else {\n+            WB.setBooleanVMFlag(\"OmitStackTraceInFastThrow\", false);\n+        }\n+        if (testMode == TestMode.STACKTRACES_IN_FASTTHROW_OPTIMIZED) {\n+            WB.setBooleanVMFlag(\"OptimizeImplicitExceptions\", true);\n+        } else {\n+            WB.setBooleanVMFlag(\"OptimizeImplicitExceptions\", false);\n+        }\n+\n+        System.out.println(\"==========================================================\");\n+        System.out.println(\"testMode=\" + testMode +\n+                           \" OmitStackTraceInFastThrow=\" + WB.getBooleanVMFlag(\"OmitStackTraceInFastThrow\") +\n+                           \" OptimizeImplicitExceptions=\" + WB.getBooleanVMFlag(\"OptimizeImplicitExceptions\"));\n+        System.out.println(\"==========================================================\");\n+    }\n+\n+    private static void printCounters(TestMode testMode, ImplicitException impExcp, Method throwImplicitException_m, int invocations) {\n+        System.out.println(\"testMode=\" + testMode + \" exception=\" + impExcp + \" invocations=\" + invocations + \"\\n\" +\n+                           \"decompilecount=\" + WB.getMethodDecompileCount(throwImplicitException_m) + \" \" +\n+                           \"trapCount=\" + WB.getMethodTrapCount(throwImplicitException_m) + \" \" +\n+                           \"trapCount(\" + impExcp.getReason() + \")=\" +\n+                           WB.getMethodTrapCount(throwImplicitException_m, impExcp.getReason()) + \" \" +\n+                           \"globalDeoptCount=\" + WB.getDeoptCount() + \" \" +\n+                           \"globalDeoptCount(\" + impExcp.getReason() + \")=\" + WB.getDeoptCount(impExcp.getReason(), null));\n+        System.out.println(\"method compiled=\" + WB.isMethodCompiled(throwImplicitException_m));\n+    }\n+\n+    \/\/ Checks after the test method has been JIT-compiled but before the compiled version has been invoked.\n+    private static void checkOne(TestMode testMode, ImplicitException impExcp, Exception ex, Method throwImplicitException_m, int invocations) {\n+\n+        printCounters(testMode, impExcp, throwImplicitException_m, invocations);\n+        \/\/ At this point, throwImplicitException() has been compiled but the compiled version has not been invoked yet.\n+        Asserts.assertEQ(WB.getMethodCompilationLevel(throwImplicitException_m), 4, \"Method should be compiled at level 4.\");\n+\n+        int trapCount = WB.getMethodTrapCount(throwImplicitException_m);\n+        int trapCountSpecific = WB.getMethodTrapCount(throwImplicitException_m, impExcp.getReason());\n+        if (impExcp == ImplicitException.INVOKE_NULL_POINTER_EXCEPTION && !JDK8275908_fixed) {\n+            Asserts.assertEQ(trapCount, 0, \"No profiling in the interpreter until JDK-8275908 is fixed.\");\n+            Asserts.assertEQ(trapCountSpecific, 0, \"No profiling in the interpreter until JDK-8275908 is fixed.\");\n+        } else if (impExcp == ImplicitException.ARRAY_STORE_EXCEPTION && !JDK8275908_fixed) {\n+            Asserts.assertEQ(trapCount, invocations, \"Trap count should be the same like the invocation count.\");\n+            Asserts.assertEQ(trapCountSpecific, 0, \"Interpreter records 'class_check' traps for 'array_check'.\");\n+            \/\/ The interpreter records 'class_check' traps for 'array_check' so verify them as well.\n+            trapCountSpecific = WB.getMethodTrapCount(throwImplicitException_m, ImplicitException.CLASS_CAST_EXCEPTION.getReason());\n+            Asserts.assertEQ(trapCountSpecific, invocations, \"Trap count should be the same like the invocation count.\");\n+        } else {\n+            Asserts.assertEQ(trapCount, invocations, \"Trap count must much invocation count.\");\n+            if (impExcp == ImplicitException.ARRAY_STORE_EXCEPTION) {\n+                \/\/ ArrayStoreExceptions are recorded as ClassCastExceptions in the interpreter.\n+                trapCountSpecific = WB.getMethodTrapCount(throwImplicitException_m, \"class_check\");\n+            }\n+            Asserts.assertEQ(trapCountSpecific, invocations, \"Trap count must much invocation count.\");\n+        }\n+        Asserts.assertNotNull(ex.getMessage(), \"Exceptions thrown in the interpreter should have a message.\");\n+    }\n+\n+    \/\/ Checks after the JIT-compiled test method has been invoked 'PerBytecodeTrapLimit' times.\n+    private static void checkTwo(TestMode testMode, ImplicitException impExcp, Exception ex, Method throwImplicitException_m, int invocations) {\n+\n+        printCounters(testMode, impExcp, throwImplicitException_m, invocations);\n+        \/\/ At this point, the compiled version of 'throwImplicitException()' has been invoked 'PerBytecodeTrapLimit' times.\n+        \/\/ The method should still be compiled except for INVOKE_NULL_POINTER_EXCEPTION and ARRAY_STORE_EXCEPTION unless\n+        \/\/ JDK-8275908 is fixed.\n+        if (!JDK8275908_fixed && (impExcp == ImplicitException.INVOKE_NULL_POINTER_EXCEPTION ||\n+                                  impExcp == ImplicitException.ARRAY_STORE_EXCEPTION)) {\n+            Asserts.assertFalse(WB.isMethodCompiled(throwImplicitException_m), \"Method shouldn't be compiled.\");\n+            int decompileCount = WB.getMethodDecompileCount(throwImplicitException_m);\n+            Asserts.assertEQ(decompileCount, 1, \"Method should be decompiled.\");\n+        } else {\n+            Asserts.assertEQ(WB.getMethodCompilationLevel(throwImplicitException_m), 4, \"Method should be compiled at level 4.\");\n+        }\n+        int deoptCount = WB.getDeoptCount();\n+        int deoptCountReason = WB.getDeoptCount(impExcp.getReason(), null\/*action*\/);\n+        if (testMode == TestMode.OMIT_STACKTRACES_IN_FASTTHROW || testMode == TestMode.STACKTRACES_IN_FASTTHROW_OPTIMIZED) {\n+            if (!JDK8275908_fixed && (impExcp == ImplicitException.INVOKE_NULL_POINTER_EXCEPTION ||\n+                                      impExcp == ImplicitException.ARRAY_STORE_EXCEPTION)) {\n+                \/\/ Unless JDK-8275908 will be fixed we'll get 'PerBytecodeTrapLimit' deoptimizations and the same\n+                \/\/ number of traps will be recorded in the method data of 'throwImplicitException()'.\n+                Asserts.assertEQ(oldDeoptCount + PerBytecodeTrapLimit, deoptCount, \"Wrong number of deoptimizations.\");\n+                Asserts.assertEQ(oldDeoptCountReason.get(impExcp.getReason()) + PerBytecodeTrapLimit, deoptCountReason, \"Wrong number of deoptimizations.\");\n+                int trapCountSpecific = WB.getMethodTrapCount(throwImplicitException_m, impExcp.getReason());\n+                Asserts.assertEQ(trapCountSpecific, PerBytecodeTrapLimit, \"Deoptimizations should be recorded as traps.\");\n+                \/\/ If we're bailing out to the interpreter, we always have a message.\n+                Asserts.assertNotNull(ex.getMessage(), \"Exceptions thrown in the interpreter should have a message.\");\n+            } else {\n+                \/\/ No deoptimizations for '-XX:+OmitStackTraceInFastThrow' and '-XX:-OmitStackTraceInFastThrow -XX:+OptimizeImplicitExceptions'\n+                Asserts.assertEQ(oldDeoptCount, deoptCount, \"Wrong number of deoptimizations.\");\n+                Asserts.assertEQ(oldDeoptCountReason.get(impExcp.getReason()), deoptCountReason, \"Wrong number of deoptimizations.\");\n+                \/\/ '-XX:+OmitStackTraceInFastThrow' never has message because it is using a global singleton exception.\n+                \/\/ '-XX:-OmitStackTraceInFastThrow -XX:+OptimizeImplicitExceptions' has no message except for\n+                \/\/ NullPointerExceptions which are handled differently due to \"JEP 358: Helpful NullPointerExceptions\".\n+                if (testMode == TestMode.STACKTRACES_IN_FASTTHROW_OPTIMIZED &&\n+                    (impExcp == ImplicitException.NULL_POINTER_EXCEPTION || impExcp == ImplicitException.INVOKE_NULL_POINTER_EXCEPTION)) {\n+                    Asserts.assertNotNull(ex.getMessage(), \"NullPointerExceptions always have a message.\");\n+                } else {\n+                    Asserts.assertNull(ex.getMessage(), \"Optimized exceptions have no message.\");\n+                }\n+            }\n+        } else if (testMode == TestMode.STACKTRACES_IN_FASTTHROW) {\n+            \/\/ We always deoptimize for '-XX:-OmitStackTraceInFastThrow -XX:-OptimizeImplicitExceptions\n+            Asserts.assertEQ(oldDeoptCount + PerBytecodeTrapLimit, deoptCount, \"Wrong number of deoptimizations.\");\n+            Asserts.assertEQ(oldDeoptCountReason.get(impExcp.getReason()) + PerBytecodeTrapLimit, deoptCountReason, \"Wrong number of deoptimizations.\");\n+            Asserts.assertNotNull(ex.getMessage(), \"Exceptions thrown in the interpreter should have a message.\");\n+        } else {\n+            Asserts.fail(\"Unknown test mode.\");\n+        }\n+        oldDeoptCount = deoptCount;\n+        oldDeoptCountReason.put(impExcp.getReason(), deoptCountReason);\n+    }\n+\n+    \/\/ Checks after the test method has been invoked 'Tier0InvokeNotifyFreq' more times.\n+    private static void checkThree(TestMode testMode, ImplicitException impExcp, Exception ex, Method throwImplicitException_m, int invocations) {\n+\n+        printCounters(testMode, impExcp, throwImplicitException_m, invocations);\n+        \/\/ At this point, throwImplicitException() has been invoked 'Tier0InvokeNotifyFreq' more times.\n+        \/\/ The method should still be compiled or recompiled (but not invoked) for INVOKE_NULL_POINTER_EXCEPTION and\n+        \/\/ ARRAY_STORE_EXCEPTION if JDK-8275908 is not fixed.\n+        Asserts.assertEQ(WB.getMethodCompilationLevel(throwImplicitException_m), 4, \"Method should be compiled at level 4.\");\n+        if (!JDK8275908_fixed && (impExcp == ImplicitException.INVOKE_NULL_POINTER_EXCEPTION ||\n+                                  impExcp == ImplicitException.ARRAY_STORE_EXCEPTION)) {\n+            int decompileCount = WB.getMethodDecompileCount(throwImplicitException_m);\n+            Asserts.assertEQ(decompileCount, 1, \"Method should not be decompiled again.\");\n+        }\n+        int deoptCount = WB.getDeoptCount();\n+        int deoptCountReason = WB.getDeoptCount(impExcp.getReason(), null\/*action*\/);\n+        if (testMode == TestMode.OMIT_STACKTRACES_IN_FASTTHROW || testMode == TestMode.STACKTRACES_IN_FASTTHROW_OPTIMIZED) {\n+            \/\/ No deoptimizations for '-XX:+OmitStackTraceInFastThrow' and '-XX:-OmitStackTraceInFastThrow -XX:+OptimizeImplicitExceptions'\n+            \/\/ For INVOKE_NULL_POINTER_EXCEPTION and ARRAY_STORE_EXCEPTION we don't deoptimize because we're running in the interpreter\n+            \/\/ unless JDK-8275908 will be fixed.\n+            Asserts.assertEQ(oldDeoptCount, deoptCount, \"Wrong number of deoptimizations.\");\n+            Asserts.assertEQ(oldDeoptCountReason.get(impExcp.getReason()), deoptCountReason, \"Wrong number of deoptimizations.\");\n+        } else if (testMode == TestMode.STACKTRACES_IN_FASTTHROW) {\n+            \/\/ We always deoptimize for '-XX:-OmitStackTraceInFastThrow' unless for INVOKE_NULL_POINTER_EXCEPTION and ARRAY_STORE_EXCEPTION\n+            \/\/ if JDK-8275908 is not fixed because we're in the interpreter then.\n+            if (!JDK8275908_fixed && (impExcp == ImplicitException.INVOKE_NULL_POINTER_EXCEPTION ||\n+                                      impExcp == ImplicitException.ARRAY_STORE_EXCEPTION)) {\n+                Asserts.assertEQ(oldDeoptCount, deoptCount, \"Wrong number of deoptimizations.\");\n+                Asserts.assertEQ(oldDeoptCountReason.get(impExcp.getReason()), deoptCountReason, \"Wrong number of deoptimizations.\");\n+            } else {\n+                Asserts.assertEQ(oldDeoptCount + Tier0InvokeNotifyFreq, deoptCount, \"Wrong number of deoptimizations.\");\n+                Asserts.assertEQ(oldDeoptCountReason.get(impExcp.getReason()) + Tier0InvokeNotifyFreq, deoptCountReason, \"Wrong number of deoptimizations.\");\n+            }\n+            Asserts.assertNotNull(ex.getMessage(), \"Exceptions thrown in the interpreter should have a message.\");\n+        } else {\n+            Asserts.fail(\"Unknown test mode.\");\n+        }\n+        oldDeoptCount = deoptCount;\n+        oldDeoptCountReason.put(impExcp.getReason(), deoptCountReason);\n+    }\n+\n+    \/\/ Checks after the test method has been invoked 'PerBytecodeTrapLimit' more times.\n+    private static void checkFour(TestMode testMode, ImplicitException impExcp, Exception ex, Method throwImplicitException_m, int invocations) {\n+\n+        printCounters(testMode, impExcp, throwImplicitException_m, invocations);\n+        \/\/ At this point, the compiled (or re-compiled) version of throwImplicitException() has been invoked 'PerBytecodeTrapLimit' more times.\n+        Asserts.assertEQ(WB.getMethodCompilationLevel(throwImplicitException_m), 4, \"Method should be compiled at level 4.\");\n+        if (!JDK8275908_fixed && (impExcp == ImplicitException.INVOKE_NULL_POINTER_EXCEPTION ||\n+                                  impExcp == ImplicitException.ARRAY_STORE_EXCEPTION)) {\n+            int decompileCount = WB.getMethodDecompileCount(throwImplicitException_m);\n+            Asserts.assertEQ(decompileCount, 1, \"Method should not be decompiled one more time.\");\n+        }\n+        int deoptCount = WB.getDeoptCount();\n+        int deoptCountReason = WB.getDeoptCount(impExcp.getReason(), null\/*action*\/);\n+        if (testMode == TestMode.OMIT_STACKTRACES_IN_FASTTHROW || testMode == TestMode.STACKTRACES_IN_FASTTHROW_OPTIMIZED) {\n+            \/\/ No deoptimizations for '-XX:+OmitStackTraceInFastThrow' and '-XX:-OmitStackTraceInFastThrow -XX:+OptimizeImplicitExceptions'\n+            Asserts.assertEQ(oldDeoptCount, deoptCount, \"Wrong number of deoptimizations.\");\n+            Asserts.assertEQ(oldDeoptCountReason.get(impExcp.getReason()), deoptCountReason, \"Wrong number of deoptimizations.\");\n+            \/\/ '-XX:+OmitStackTraceInFastThrow' never has message because it is using a global singleton exception.\n+            \/\/ '-XX:-OmitStackTraceInFastThrow -XX:+OptimizeImplicitExceptions' has no message except for\n+            \/\/ NullPointerExceptions which are handled differently due to \"JEP 358: Helpful NullPointerExceptions\".\n+            if (testMode == TestMode.STACKTRACES_IN_FASTTHROW_OPTIMIZED &&\n+                (impExcp == ImplicitException.NULL_POINTER_EXCEPTION || impExcp == ImplicitException.INVOKE_NULL_POINTER_EXCEPTION)) {\n+                Asserts.assertNotNull(ex.getMessage(), \"NullPointerExceptions always have a message.\");\n+            } else {\n+                Asserts.assertNull(ex.getMessage(), \"Optimized exceptions have no message.\");\n+            }\n+        } else if (testMode == TestMode.STACKTRACES_IN_FASTTHROW) {\n+            \/\/ We always deoptimize for '-XX:-OmitStackTraceInFastThrow'\n+            Asserts.assertEQ(oldDeoptCount + PerBytecodeTrapLimit, deoptCount, \"Wrong number of deoptimizations.\");\n+            if (impExcp == ImplicitException.ARRAY_STORE_EXCEPTION) {\n+                \/\/ ArrayStoreExceptions trap with reason \"class_check\" in compiled code\n+                String reason = ImplicitException.CLASS_CAST_EXCEPTION.getReason();\n+                int deoptCountClassCastExcp = WB.getDeoptCount(reason, null\/*action*\/);\n+                Asserts.assertEQ(oldDeoptCountReason.get(reason) + PerBytecodeTrapLimit, deoptCountClassCastExcp, \"Wrong number of deoptimizations.\");\n+                oldDeoptCountReason.put(reason, deoptCountClassCastExcp);\n+            } else {\n+                Asserts.assertEQ(oldDeoptCountReason.get(impExcp.getReason()) + PerBytecodeTrapLimit, deoptCountReason, \"Wrong number of deoptimizations.\");\n+            }\n+        } else {\n+            Asserts.fail(\"Unknown test mode.\");\n+        }\n+        oldDeoptCount = deoptCount;\n+        oldDeoptCountReason.put(impExcp.getReason(), deoptCountReason);\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        if (!WB.getBooleanVMFlag(\"ProfileTraps\")) {\n+            \/\/ The fast-throw optimzation only works if we're running with -XX:+ProfileTraps\n+            return;\n+        }\n+\n+        \/\/ Initialize global deopt counts to zero.\n+        for (ImplicitException impExcp : ImplicitException.values()) {\n+            oldDeoptCountReason.put(impExcp.getReason(), 0);\n+        }\n+        \/\/ Get a handle of the test method for usage with the WhiteBox API.\n+        Method throwImplicitException_m = OptimizeImplicitExceptions.class\n+            .getDeclaredMethod(\"throwImplicitException\", new Class[] { ImplicitException.class, Object[].class});\n+\n+        for (TestMode testMode : TestMode.values()) {\n+            setFlags(testMode);\n+            for (ImplicitException impExcp : ImplicitException.values()) {\n+                int invocations = 0;\n+                Exception lastException = null;\n+\n+                \/\/ Warmup and compile, but don't invoke compiled code.\n+                while(!WB.isMethodCompiled(throwImplicitException_m)) {\n+                    invocations++;\n+                    try {\n+                        throwImplicitException(impExcp, impExcp.getReason().equals(\"null_check\") ? null : string_a);\n+                    } catch (Exception catchedExcp) {\n+                        lastException = catchedExcp;\n+                        continue;\n+                    }\n+                    throw new Exception(\"Should not happen\");\n+                }\n+\n+                checkOne(testMode, impExcp, lastException, throwImplicitException_m, invocations);\n+\n+                \/\/ Invoke compiled code 'PerBytecodeTrapLimit' times.\n+                for (int i = 0; i < PerBytecodeTrapLimit; i++) {\n+                    invocations++;\n+                    try {\n+                        throwImplicitException(impExcp, impExcp.getReason().equals(\"null_check\") ? null : string_a);\n+                    } catch (Exception catchedExcp) {\n+                        lastException = catchedExcp;\n+                        continue;\n+                    }\n+                    throw new Exception(\"Should not happen\");\n+                }\n+\n+                checkTwo(testMode, impExcp, lastException, throwImplicitException_m, invocations);\n+\n+                \/\/ Invoke compiled (or interpreted if JDK-8275908 isn't fixed) code 'Tier0InvokeNotifyFreq' times.\n+                \/\/ If the method was de-compiled before, this will re-compile it again.\n+                for (int i = 0; i < Tier0InvokeNotifyFreq; i++) {\n+                    invocations++;\n+                    try {\n+                        throwImplicitException(impExcp, impExcp.getReason().equals(\"null_check\") ? null : string_a);\n+                    } catch (Exception catchedExcp) {\n+                        lastException = catchedExcp;\n+                        continue;\n+                    }\n+                    throw new Exception(\"Should not happen\");\n+                }\n+\n+                checkThree(testMode, impExcp, lastException, throwImplicitException_m, invocations);\n+\n+                \/\/ Invoke compiled code 'PerBytecodeTrapLimit' times.\n+                for (int i = 0; i < PerBytecodeTrapLimit; i++) {\n+                    invocations++;\n+                    try {\n+                        throwImplicitException(impExcp, impExcp.getReason().equals(\"null_check\") ? null : string_a);\n+                    } catch (Exception catchedExcp) {\n+                        lastException = catchedExcp;\n+                        continue;\n+                    }\n+                    throw new Exception(\"Should not happen\");\n+                }\n+\n+                checkFour(testMode, impExcp, lastException, throwImplicitException_m, invocations);\n+\n+                System.out.println(\"------------------------------------------------------------------\");\n+\n+                unloadAndClean(throwImplicitException_m);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/exceptions\/OptimizeImplicitExceptions.java","additions":411,"deletions":0,"binary":false,"changes":411,"status":"added"},{"patch":"@@ -191,1 +191,1 @@\n-                 BadFailOnConstraint.create(Traps.class, \"classCheck()\", 2, \"CallStaticJava\", \"uncommon_trap\", \"class_check\"),\n+                 BadFailOnConstraint.create(Traps.class, \"classCheck()\", 2, \"CallStaticJava\", \"uncommon_trap\", \"unhandled\"),\n@@ -1122,1 +1122,1 @@\n-    @IR(failOn = IRNode.CLASS_CHECK_TRAP) \/\/ fails\n+    @IR(failOn = IRNode.UNHANDLED_TRAP) \/\/ fails (slow-path allocation of implicit ClassCastException)\n@@ -1130,1 +1130,1 @@\n-                  IRNode.UNHANDLED_TRAP})\n+                  IRNode.CLASS_CHECK_TRAP})\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/ir_framework\/tests\/TestIRMatching.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -320,0 +320,30 @@\n+  public         int     getMethodDecompileCount(Executable method) {\n+    Objects.requireNonNull(method);\n+    return getMethodDecompileCount0(method);\n+  }\n+  private native int     getMethodDecompileCount0(Executable method);\n+  \/\/ Get the total trap count of a method. If the trap count for a specific reason\n+  \/\/ did overflow, this includes the overflow trap count of the method.\n+  public         int     getMethodTrapCount(Executable method) {\n+    Objects.requireNonNull(method);\n+    return getMethodTrapCount0(method, null);\n+  }\n+  \/\/ Get the trap count of a method for a specific reason. If the trap count for\n+  \/\/ that reason did overflow, this includes the overflow trap count of the method.\n+  public         int     getMethodTrapCount(Executable method, String reason) {\n+    Objects.requireNonNull(method);\n+    return getMethodTrapCount0(method, reason);\n+  }\n+  private native int     getMethodTrapCount0(Executable method, String reason);\n+  \/\/ Get the total deopt count.\n+  public         int     getDeoptCount() {\n+    return getDeoptCount0(null, null);\n+  }\n+  \/\/ Get the deopt count for a specific reason and a specific action. If either\n+  \/\/ one of 'reason' or 'action' is null, the method returns the sum of all\n+  \/\/ deoptimizations with the specific 'action' or 'reason' respectively.\n+  \/\/ If both arguments are null, the method returns the total deopt count.\n+  public         int     getDeoptCount(String reason, String action) {\n+    return getDeoptCount0(reason, action);\n+  }\n+  private native int     getDeoptCount0(String reason, String action);\n","filename":"test\/lib\/jdk\/test\/whitebox\/WhiteBox.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -321,0 +321,30 @@\n+  public         int     getMethodDecompileCount(Executable method) {\n+    Objects.requireNonNull(method);\n+    return getMethodDecompileCount0(method);\n+  }\n+  private native int     getMethodDecompileCount0(Executable method);\n+  \/\/ Get the total trap count of a method. If the trap count for a specific reason\n+  \/\/ did overflow, this includes the overflow trap count of the method.\n+  public         int     getMethodTrapCount(Executable method) {\n+    Objects.requireNonNull(method);\n+    return getMethodTrapCount0(method, null);\n+  }\n+  \/\/ Get the trap count of a method for a specific reason. If the trap count for\n+  \/\/ that reason did overflow, this includes the overflow trap count of the method.\n+  public         int     getMethodTrapCount(Executable method, String reason) {\n+    Objects.requireNonNull(method);\n+    return getMethodTrapCount0(method, reason);\n+  }\n+  private native int     getMethodTrapCount0(Executable method, String reason);\n+  \/\/ Get the total deopt count.\n+  public         int     getDeoptCount() {\n+    return getDeoptCount0(null, null);\n+  }\n+  \/\/ Get the deopt count for a specific reason and a specific action. If either\n+  \/\/ one of 'reason' or 'action' is null, the method returns the sum of all\n+  \/\/ deoptimizations with the specific 'action' or 'reason' respectively.\n+  \/\/ If both arguments are null, the method returns the total deopt count.\n+  public         int     getDeoptCount(String reason, String action) {\n+    return getDeoptCount0(reason, action);\n+  }\n+  private native int     getDeoptCount0(String reason, String action);\n","filename":"test\/lib\/sun\/hotspot\/WhiteBox.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -0,0 +1,92 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.vm.lang;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Warmup(iterations = 5, time = 5, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 5, time = 5, timeUnit = TimeUnit.SECONDS)\n+@Fork(1)\n+@State(Scope.Benchmark)\n+public class ImplicitExceptions {\n+    static final int ASCII_SIZE = 128;\n+    static final boolean[] ASCII_ALPHA = new boolean[ASCII_SIZE];\n+    static final int testStringLengthLog = 7;\n+    static final int TestStringLenghtMask = (1 << testStringLengthLog) - 1;\n+    static final char[] testString = new char[1 << testStringLengthLog];\n+    int iterator = 0;\n+\n+    @Param({\"0.0\", \"0.33\", \"0.66\", \"1.00\"})\n+    public double exceptionProbability;\n+\n+    @Setup\n+    public void init() {\n+        for (int i = 0; i < ASCII_SIZE; i++) {\n+            if (i >= 'a' && i <= 'z' || i >= 'A' && i <= 'Z') {\n+              ASCII_ALPHA[i] = true;\n+            }\n+        }\n+        Random rnd = new Random();\n+        rnd.setSeed(Long.getLong(\"random.seed\", 42L));\n+        for (int i = 0; i < testString.length; i++) {\n+            if (rnd.nextDouble() < exceptionProbability) {\n+              testString[i] = 0xbad; \/\/ Something bigger than ASCII_SIZE\n+            }\n+            else {\n+              testString[i] = (char)rnd.nextInt(ASCII_SIZE);\n+            }\n+        }\n+    }\n+\n+    public boolean isAlphaWithExceptions(int c) {\n+        try {\n+            return ASCII_ALPHA[c];\n+        } catch (ArrayIndexOutOfBoundsException ex) {\n+            return false;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void bench() {\n+        isAlphaWithExceptions(testString[iterator++ & TestStringLenghtMask]);\n+        \/\/if (++iterator == Long.MAX_VALUE) {\n+        \/\/    iterator = 0;\n+        \/\/}\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/lang\/ImplicitExceptions.java","additions":92,"deletions":0,"binary":false,"changes":92,"status":"added"}]}