{"files":[{"patch":"@@ -112,1 +112,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.util.VisibleMemberTable;\n@@ -293,5 +292,22 @@\n-        var enclosing = (TypeElement) method.getEnclosingElement();\n-        var overrideInfo = utils.overriddenMethod(method);\n-        var enclosingVmt = configuration.getVisibleMemberTable(enclosing);\n-        var implementedMethods = enclosingVmt.getImplementedMethods(method);\n-        if ((!enclosing.getInterfaces().isEmpty()\n+        assert getCurrentPageElement() != null;\n+        var site = getCurrentPageElement();\n+        var siteVmt = configuration.getVisibleMemberTable(site);\n+        \/\/ separating \"overrides\" from \"implements\" can also be accomplished\n+        \/\/ using Collectors.partitioningBy, but it has non-obvious ordering\n+        \/\/ semantics and require too much ceremony\n+        var mixed = siteVmt.overrideAt(method).descending()\n+                .skip(1) \/\/ skip the method itself\n+                .filter(i -> !i.isSimpleOverride()\n+                        && !utils.isUndocumentedEnclosure((TypeElement) i.getMethod().getEnclosingElement())\n+                        && (utils.isPublic(i.getMethod()) || utils.isLinkable((TypeElement) i.getMethod().getEnclosingElement())))\n+                .toList();\n+        var implementedMethods = mixed.stream()\n+                .filter(i -> {\n+                    var k = i.getEnclosingType().asElement().getKind();\n+                    assert k.isClass() || k.isInterface() : k;\n+                    return k.isInterface();\n+                }).toList();\n+        var overriddenMethod = mixed.stream()\n+                .filter(i -> i.getEnclosingType().asElement().getKind().isClass())\n+                .findFirst();\n+        if ((!site.getInterfaces().isEmpty()\n@@ -299,1 +315,1 @@\n-                || overrideInfo != null) {\n+                || overriddenMethod.isPresent()) {\n@@ -301,1 +317,1 @@\n-            \/\/   hierarchy, !enclosingVmt.getImplementedMethods(method).isEmpty(), their information\n+            \/\/   hierarchy, !siteVmt.getImplementedMethods(method).isEmpty(), their information\n@@ -303,2 +319,2 @@\n-            \/\/     * the enclosing has _directly_ implemented interfaces\n-            \/\/     * the overridden method is not null\n+            \/\/     * the contextual type element has _directly_ implemented interfaces\n+            \/\/     * the overridden method is present\n@@ -310,1 +326,1 @@\n-            MethodWriterImpl.addImplementsInfo(this, method, implementedMethods, dl);\n+            MethodWriterImpl.addImplementsInfo(this, implementedMethods, dl);\n@@ -312,5 +328,2 @@\n-        if (overrideInfo != null) {\n-            MethodWriterImpl.addOverridden(this,\n-                    overrideInfo.overriddenMethodOwner(),\n-                    overrideInfo.overriddenMethod(),\n-                    dl);\n+        if (overriddenMethod.isPresent()) {\n+            MethodWriterImpl.addOverridden(this, overriddenMethod.get(), dl);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlDocletWriter.java","additions":29,"deletions":16,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import java.util.Comparator;\n@@ -234,1 +235,1 @@\n-     * Adds \"overrides\" or \"specified by\" information about a method (if appropriate)\n+     * Adds \"Overrides\" or \"Specified by\" information about a method (if appropriate)\n@@ -237,4 +238,3 @@\n-     * @param writer         the writer for the element\n-     * @param overriddenType the superclass\n-     * @param method         the method\n-     * @param dl             the list in which to add the information.\n+     * @param writer  the writer for the element\n+     * @param s       the override\n+     * @param dl      the list in which to add the information.\n@@ -243,2 +243,1 @@\n-                                        TypeMirror overriddenType,\n-                                        ExecutableElement method,\n+                                        VisibleMemberTable.OverrideSequence s,\n@@ -250,1 +249,1 @@\n-        TypeElement holder = utils.getEnclosingTypeElement(method);\n+        TypeElement holder = utils.getEnclosingTypeElement(s.getMethod());\n@@ -255,1 +254,1 @@\n-        if (utils.isIncluded(holder) && !utils.isIncluded(method)) {\n+        if (utils.isIncluded(holder) && !utils.isIncluded(s.getMethod())) {\n@@ -260,1 +259,1 @@\n-        if (utils.hasHiddenTag(holder) || utils.hasHiddenTag(method)) {\n+        if (utils.hasHiddenTag(holder) || utils.hasHiddenTag(s.getMethod())) {\n@@ -267,1 +266,1 @@\n-        if (utils.isAbstract(holder) && utils.isAbstract(method)) {\n+        if (utils.isAbstract(holder) && utils.isAbstract(s.getMethod())) {\n@@ -278,1 +277,1 @@\n-                writer.getLink(new HtmlLinkInfo(writer.configuration, context, overriddenType));\n+                writer.getLink(new HtmlLinkInfo(writer.configuration, context, s.getEnclosingType()));\n@@ -282,2 +281,2 @@\n-                        .fragment(writer.htmlIds.forMember(method).name())\n-                        .label(method.getSimpleName()));\n+                        .fragment(writer.htmlIds.forMember(s.getMethod()).name())\n+                        .label(s.getMethod().getSimpleName()));\n@@ -298,2 +297,1 @@\n-     * @param method  the method\n-     * @param methods implemented methods\n+     * @param methods the implementations\n@@ -303,2 +301,1 @@\n-                                            ExecutableElement method,\n-                                            Collection<ExecutableElement> methods,\n+                                            Collection<VisibleMemberTable.OverrideSequence> methods,\n@@ -311,4 +308,3 @@\n-        var enclosing = (TypeElement) method.getEnclosingElement();\n-        VisibleMemberTable vmt = writer.configuration.getVisibleMemberTable(enclosing);\n-        SortedSet<ExecutableElement> implementedMethods =\n-                new TreeSet<>(utils.comparators.makeOverrideUseComparator());\n+        SortedSet<VisibleMemberTable.OverrideSequence> implementedMethods =\n+                new TreeSet<>(Comparator.comparing(VisibleMemberTable.OverrideSequence::getMethod,\n+                        utils.comparators.makeOverrideUseComparator()));\n@@ -316,3 +312,1 @@\n-        for (ExecutableElement implementedMeth : implementedMethods) {\n-            TypeMirror intfac = vmt.getImplementedMethodHolder(method, implementedMeth);\n-            intfac = utils.getDeclaredType(enclosing, intfac);\n+        for (VisibleMemberTable.OverrideSequence s : implementedMethods) {\n@@ -320,1 +314,1 @@\n-                    writer.configuration, HtmlLinkInfo.Kind.LINK_TYPE_PARAMS_AND_BOUNDS, intfac));\n+                    writer.configuration, HtmlLinkInfo.Kind.LINK_TYPE_PARAMS_AND_BOUNDS, s.getEnclosingType()));\n@@ -323,3 +317,2 @@\n-            Content methlink = writer.getDocLink(\n-                    HtmlLinkInfo.Kind.PLAIN, implementedMeth,\n-                    implementedMeth.getSimpleName());\n+            Content methlink = writer.getDocLink(HtmlLinkInfo.Kind.PLAIN, s.getMethod(),\n+                    s.getMethod().getSimpleName());\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/MethodWriterImpl.java","additions":22,"deletions":29,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -563,3 +563,1 @@\n-            \/\/ Find the enclosing type where the method is actually visible\n-            \/\/ in the inheritance hierarchy.\n-            ExecutableElement overriddenMethod = null;\n+            var overriddenMethod = Optional.<VisibleMemberTable.OverrideSequence>empty();\n@@ -568,1 +566,30 @@\n-                overriddenMethod = vmt.getOverriddenMethod((ExecutableElement)refMem);\n+                \/\/ Find the type whose page documents the method in the\n+                \/\/ \"Method Details\" section, to build the link to the method.\n+                var sequence = vmt.overrideAt((ExecutableElement) refMem);\n+                \/\/ 1. Let's find the most specific non-simple override: this is\n+                \/\/    the type element whose comment text is going to be used on\n+                \/\/    in \"Method Details\" for the method.\n+                \/\/\n+                \/\/    For that, while override is simple, decrease the specificity.\n+                while (sequence.isSimpleOverride()\n+                        && sequence.hasLessSpecific()) {\n+                    sequence = sequence.lessSpecific();\n+                }\n+                \/\/ there's always a non-simple override in a sequence: the least\n+                \/\/ specific method, which could also be the most specific, if\n+                \/\/ the sequence is trivial\n+                assert !sequence.isSimpleOverride() : sequence;\n+                \/\/ 2. The method we've just found might not be documentable in its\n+                \/\/    enclosing type element, so we need to find the first MORE specific\n+                \/\/    method which is going to \"inherit\" that found method documentation\n+                \/\/    and host\/display it on its enclosing type element page.\n+                \/\/\n+                \/\/    For that, go back: while override is non-documentable,\n+                \/\/    increase the specificity.\n+                while (utils.isUndocumentedEnclosure((TypeElement) sequence.getEnclosingType().asElement())\n+                        && sequence.hasMoreSpecific()) {\n+                    sequence = sequence.moreSpecific();\n+                }\n+                \/\/ 3. Have we been able to find such a method?\n+                if (!utils.isUndocumentedEnclosure((TypeElement) sequence.getEnclosingType().asElement()))\n+                    overriddenMethod = Optional.of(sequence);\n@@ -570,2 +597,2 @@\n-                if (overriddenMethod != null) {\n-                    containing = utils.getEnclosingTypeElement(overriddenMethod);\n+                if (overriddenMethod.isPresent()) {\n+                    containing = utils.getEnclosingTypeElement(overriddenMethod.get().getMethod());\n@@ -602,1 +629,1 @@\n-                if (overriddenMethod != null) {\n+                if (overriddenMethod.isPresent()) {\n@@ -604,1 +631,1 @@\n-                    refMem = overriddenMethod;\n+                    refMem = overriddenMethod.get().getMethod();\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/TagletWriterImpl.java","additions":35,"deletions":8,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -267,1 +267,1 @@\n-                    Optional<List<? extends DocTree>> r = docFinder.search((ExecutableElement) member, (m -> {\n+                    Optional<List<? extends DocTree>> r = docFinder.search(typeElement, (ExecutableElement) member, (m -> {\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/builders\/MemberSummaryBuilder.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -171,1 +171,1 @@\n-            Optional<ExecutableElement> r = docFinder.search(currentMethod,\n+            Optional<ExecutableElement> r = docFinder.search(typeElement, currentMethod,\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/builders\/MethodBuilder.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -85,1 +85,1 @@\n-                Optional<Documentation> r = docFinder.trySearch(method,\n+                Optional<Documentation> r = docFinder.trySearch(writer.getCurrentPageElement(), method,\n@@ -106,1 +106,1 @@\n-        InheritableTaglet.Output inheritedDoc = ((InheritableTaglet) taglet).inherit(method, holderTag, isFirstSentence, configuration);\n+        InheritableTaglet.Output inheritedDoc = ((InheritableTaglet) taglet).inherit(writer.getCurrentPageElement(), method, holderTag, isFirstSentence, configuration);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/InheritDocTaglet.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+import javax.lang.model.element.TypeElement;\n@@ -55,1 +56,1 @@\n-    Output inherit(Element owner, DocTree tag, boolean isFirstSentence, BaseConfiguration configuration);\n+    Output inherit(TypeElement site, Element owner, DocTree tag, boolean isFirstSentence, BaseConfiguration configuration);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/InheritableTaglet.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -67,1 +67,1 @@\n-    public Output inherit(Element owner, DocTree tag, boolean isFirstSentence, BaseConfiguration configuration) {\n+    public Output inherit(TypeElement site, Element owner, DocTree tag, boolean isFirstSentence, BaseConfiguration configuration) {\n@@ -88,1 +88,1 @@\n-            var r = docFinder.trySearch(method,\n+            var r = docFinder.trySearch(site, method,\n@@ -201,1 +201,1 @@\n-                result.add(getInheritedTagletOutput(kind, e, writer,\n+                result.add(getInheritedTagletOutput(writer.getCurrentPageElement(), kind, e, writer,\n@@ -222,1 +222,2 @@\n-    private Content getInheritedTagletOutput(ParamKind kind,\n+    private Content getInheritedTagletOutput(TypeElement site,\n+                                             ParamKind kind,\n@@ -230,1 +231,1 @@\n-        var r = utils.docFinder().search((ExecutableElement) holder,\n+        var r = utils.docFinder().search(site, (ExecutableElement) holder,\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/ParamTaglet.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,1 @@\n+import javax.lang.model.element.TypeElement;\n@@ -63,1 +64,1 @@\n-    public Output inherit(Element owner, DocTree tag, boolean isFirstSentence, BaseConfiguration configuration) {\n+    public Output inherit(TypeElement site, Element owner, DocTree tag, boolean isFirstSentence, BaseConfiguration configuration) {\n@@ -66,1 +67,1 @@\n-            var r = docFinder.trySearch((ExecutableElement) owner, m -> Result.fromOptional(extract(configuration.utils, m))).toOptional();\n+            var r = docFinder.trySearch(site, (ExecutableElement) owner, m -> Result.fromOptional(extract(configuration.utils, m))).toOptional();\n@@ -101,1 +102,1 @@\n-        return docFinder.search(method, m -> Result.fromOptional(extract(utils, m))).toOptional()\n+        return docFinder.search(writer.getCurrentPageElement(), method, m -> Result.fromOptional(extract(utils, m))).toOptional()\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/ReturnTaglet.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import javax.lang.model.element.TypeElement;\n@@ -54,1 +55,1 @@\n-    public Output inherit(Element owner, DocTree tag, boolean isFirstSentence, BaseConfiguration configuration) {\n+    public Output inherit(TypeElement site, Element owner, DocTree tag, boolean isFirstSentence, BaseConfiguration configuration) {\n@@ -68,1 +69,1 @@\n-            Optional<Documentation> result = docFinder.search((ExecutableElement) holder,\n+            Optional<Documentation> result = docFinder.search(writer.getCurrentPageElement(), (ExecutableElement) holder,\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/SeeTaglet.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,1 @@\n+import javax.lang.model.element.TypeElement;\n@@ -166,1 +167,1 @@\n-    public Output inherit(Element owner, DocTree tag, boolean isFirstSentence, BaseConfiguration configuration) {\n+    public Output inherit(TypeElement site, Element owner, DocTree tag, boolean isFirstSentence, BaseConfiguration configuration) {\n@@ -171,1 +172,1 @@\n-            var r = docFinder.trySearch((ExecutableElement) owner,\n+            var r = docFinder.trySearch(site, (ExecutableElement) owner,\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/SimpleTaglet.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import javax.lang.model.element.TypeElement;\n@@ -53,1 +54,1 @@\n-    public Output inherit(Element owner, DocTree tag, boolean isFirstSentence, BaseConfiguration configuration) {\n+    public Output inherit(TypeElement site, Element owner, DocTree tag, boolean isFirstSentence, BaseConfiguration configuration) {\n@@ -67,1 +68,1 @@\n-            Optional<Documentation> result = docFinder.search((ExecutableElement) holder,\n+            Optional<Documentation> result = docFinder.search(writer.getCurrentPageElement(), (ExecutableElement) holder,\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/SpecTaglet.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -168,1 +168,1 @@\n-    public Output inherit(Element owner, DocTree tag, boolean isFirstSentence, BaseConfiguration configuration) {\n+    public Output inherit(TypeElement site, Element owner, DocTree tag, boolean isFirstSentence, BaseConfiguration configuration) {\n@@ -256,1 +256,1 @@\n-                    r = expandShallowly(exceptionElement, executable);\n+                    r = expandShallowly(writer.getCurrentPageElement(), exceptionElement, executable);\n@@ -373,1 +373,1 @@\n-                tags = expandShallowly(originalExceptionElement, holder);\n+                tags = expandShallowly(writer.getCurrentPageElement(), originalExceptionElement, holder);\n@@ -528,1 +528,2 @@\n-    private Map<ThrowsTree, ExecutableElement> expandShallowly(Element exceptionType,\n+    private Map<ThrowsTree, ExecutableElement> expandShallowly(TypeElement site,\n+                                                               Element exceptionType,\n@@ -565,1 +566,1 @@\n-            result = utils.docFinder().trySearch(holder, criterion);\n+            result = utils.docFinder().trySearch(site, holder, criterion);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/ThrowsTaglet.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -507,1 +507,1 @@\n-        Optional<ExecutableElement> inheritedDoc = docFinder.search(ee,\n+        Optional<ExecutableElement> inheritedDoc = docFinder.search(null, ee,\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/CommentHelper.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import java.util.ArrayList;\n@@ -33,1 +32,0 @@\n-import java.util.function.Function;\n@@ -36,0 +34,1 @@\n+import javax.lang.model.element.TypeElement;\n@@ -50,2 +49,1 @@\n-    private final Function<ExecutableElement, ExecutableElement> overriddenMethodLookup;\n-    private final BiFunction<ExecutableElement, ExecutableElement, Iterable<ExecutableElement>> implementedMethodsLookup;\n+    private final BiFunction<TypeElement, ExecutableElement, Iterator<ExecutableElement>> overriddenMethodLookup;\n@@ -53,4 +51,2 @@\n-    DocFinder(Function<ExecutableElement, ExecutableElement> overriddenMethodLookup,\n-              BiFunction<ExecutableElement, ExecutableElement, Iterable<ExecutableElement>> implementedMethodsLookup) {\n-        this.overriddenMethodLookup = overriddenMethodLookup;\n-        this.implementedMethodsLookup = implementedMethodsLookup;\n+    DocFinder(BiFunction<TypeElement, ExecutableElement, Iterator<ExecutableElement>> overriddenMethodLookup) {\n+        this.overriddenMethodLookup = Objects.requireNonNull(overriddenMethodLookup);\n@@ -66,1 +62,2 @@\n-    public <T, X extends Throwable> Result<T> search(ExecutableElement method,\n+    public <T, X extends Throwable> Result<T> search(TypeElement site,\n+                                                     ExecutableElement method,\n@@ -70,1 +67,1 @@\n-        return search(method, true, criterion);\n+        return search(site, method, true, criterion);\n@@ -73,1 +70,2 @@\n-    public <T, X extends Throwable> Result<T> search(ExecutableElement method,\n+    public <T, X extends Throwable> Result<T> search(TypeElement site,\n+                                                     ExecutableElement method,\n@@ -79,1 +77,1 @@\n-            return search0(method, includeMethod, false, criterion);\n+            return search0(site, method, includeMethod, false, criterion);\n@@ -86,1 +84,2 @@\n-    public <T, X extends Throwable> Result<T> trySearch(ExecutableElement method,\n+    public <T, X extends Throwable> Result<T> trySearch(TypeElement site,\n+                                                        ExecutableElement method,\n@@ -90,1 +89,1 @@\n-        return search0(method, false, true, criterion);\n+        return search0(site, method, false, true, criterion);\n@@ -94,1 +93,2 @@\n-     * Searches through the overridden methods hierarchy of the provided method.\n+     * Searches through the hierarchy of methods overridden by the the provided\n+     * method as a member the provided class or interface.\n@@ -113,1 +113,2 @@\n-    private <T, X extends Throwable> Result<T> search0(ExecutableElement method,\n+    private <T, X extends Throwable> Result<T> search0(TypeElement site,\n+                                                       ExecutableElement method,\n@@ -119,0 +120,5 @@\n+        \/\/ <hack>\n+        if (site == null)\n+            site = (TypeElement) method.getEnclosingElement();\n+        \/\/ <\/hack>\n+\n@@ -121,1 +127,1 @@\n-        Iterator<ExecutableElement> methods = methodsOverriddenBy(method);\n+        Iterator<ExecutableElement> methods = overriddenMethodLookup.apply(site, method);\n@@ -131,1 +137,1 @@\n-            r = search0(m, true, false \/* don't check for overrides *\/, criterion);\n+            r = search0(site, m, true, false \/* don't check for overrides *\/, criterion);\n@@ -139,13 +145,0 @@\n-    \/\/ We see both overridden and implemented methods as overridden\n-    \/\/ (see JLS 8.4.8.1. Overriding (by Instance Methods))\n-    private Iterator<ExecutableElement> methodsOverriddenBy(ExecutableElement method) {\n-        \/\/ TODO: create a lazy iterator if required\n-        var list = new ArrayList<ExecutableElement>();\n-        ExecutableElement overridden = overriddenMethodLookup.apply(method);\n-        if (overridden != null) {\n-            list.add(overridden);\n-        }\n-        implementedMethodsLookup.apply(method, method).forEach(list::add);\n-        return list.iterator();\n-    }\n-\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/DocFinder.java","additions":25,"deletions":32,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -95,1 +95,0 @@\n-import com.sun.source.doctree.DocTree.Kind;\n@@ -121,1 +120,0 @@\n-import jdk.javadoc.internal.tool.DocEnvImpl;\n@@ -612,46 +610,0 @@\n-    \/*\n-     * The record is used to pass the method along with the type where that method is visible.\n-     * Passing the type explicitly allows to preserve a complete type information, including\n-     * parameterization.\n-     *\/\n-    public record OverrideInfo(ExecutableElement overriddenMethod,\n-                               DeclaredType overriddenMethodOwner) { }\n-\n-    \/*\n-     * Returns the closest superclass (not the superinterface) that contains\n-     * a method that is both:\n-     *\n-     *   - overridden by the specified method, and\n-     *   - is not itself a *simple* override\n-     *\n-     * If no such class can be found, returns null.\n-     *\n-     * If the specified method belongs to an interface, the only considered\n-     * superclass is java.lang.Object no matter how many other interfaces\n-     * that interface extends.\n-     *\/\n-    public OverrideInfo overriddenMethod(ExecutableElement method) {\n-        var t = method.getEnclosingElement().asType();\n-        \/\/ in this context, consider java.lang.Object to be the superclass of an interface\n-        while (true) {\n-            var supertypes = typeUtils.directSupertypes(t);\n-            if (supertypes.isEmpty()) {\n-                \/\/ reached the top of the hierarchy\n-                assert typeUtils.isSameType(getObjectType(), t);\n-                return null;\n-            }\n-            t = supertypes.get(0);\n-            \/\/ if non-empty, the first element is always the superclass\n-            var te = (TypeElement) ((DeclaredType) t).asElement();\n-            assert te.getKind().isClass();\n-            VisibleMemberTable vmt = configuration.getVisibleMemberTable(te);\n-            for (Element e : vmt.getMembers(VisibleMemberTable.Kind.METHODS)) {\n-                var ee = (ExecutableElement) e;\n-                if (elementUtils.overrides(method, ee, (TypeElement) method.getEnclosingElement()) &&\n-                        !isSimpleOverride(ee)) {\n-                    return new OverrideInfo(ee, (DeclaredType) t);\n-                }\n-            }\n-        }\n-    }\n-\n@@ -672,51 +624,0 @@\n-    public TypeMirror getDeclaredType(TypeElement enclosing, TypeMirror target) {\n-        return getDeclaredType(List.of(), enclosing, target);\n-    }\n-\n-    \/**\n-     * Finds the declaration of the enclosing's type parameter.\n-     *\n-     * @param values\n-     * @param enclosing a TypeElement whose type arguments  we desire\n-     * @param target the TypeMirror of the type as described by the enclosing\n-     * @return\n-     *\/\n-    public TypeMirror getDeclaredType(Collection<TypeMirror> values,\n-                                      TypeElement enclosing, TypeMirror target) {\n-        TypeElement targetElement = asTypeElement(target);\n-        List<? extends TypeParameterElement> targetTypeArgs = targetElement.getTypeParameters();\n-        if (targetTypeArgs.isEmpty()) {\n-            return target;\n-        }\n-\n-        List<? extends TypeParameterElement> enclosingTypeArgs = enclosing.getTypeParameters();\n-        List<TypeMirror> targetTypeArgTypes = new ArrayList<>(targetTypeArgs.size());\n-\n-        if (enclosingTypeArgs.isEmpty()) {\n-            for (TypeMirror te : values) {\n-                List<? extends TypeMirror> typeArguments = ((DeclaredType)te).getTypeArguments();\n-                if (typeArguments.size() >= targetTypeArgs.size()) {\n-                    for (int i = 0 ; i < targetTypeArgs.size(); i++) {\n-                        targetTypeArgTypes.add(typeArguments.get(i));\n-                    }\n-                    break;\n-                }\n-            }\n-            \/\/ we found no matches in the hierarchy\n-            if (targetTypeArgTypes.isEmpty()) {\n-                return target;\n-            }\n-        } else {\n-            if (targetTypeArgs.size() > enclosingTypeArgs.size()) {\n-                return target;\n-            }\n-            for (int i = 0; i < targetTypeArgs.size(); i++) {\n-                TypeParameterElement tpe = enclosingTypeArgs.get(i);\n-                targetTypeArgTypes.add(tpe.asType());\n-            }\n-        }\n-        TypeMirror dt = typeUtils.getDeclaredType(targetElement,\n-                targetTypeArgTypes.toArray(new TypeMirror[targetTypeArgTypes.size()]));\n-        return dt;\n-    }\n-\n@@ -1282,22 +1183,0 @@\n-    \/*\n-     * Returns true if the passed method does not change the specification it\n-     * inherited.\n-     *\n-     * If the passed method is not deprecated and has either no comment or a\n-     * comment consisting of single {@inheritDoc} tag, the inherited\n-     * specification is deemed unchanged and this method returns true;\n-     * otherwise this method returns false.\n-     *\/\n-    public boolean isSimpleOverride(ExecutableElement m) {\n-        if (!options.summarizeOverriddenMethods() || !isIncluded(m)) {\n-            return false;\n-        }\n-\n-        if (!getBlockTags(m).isEmpty() || isDeprecated(m))\n-            return false;\n-\n-        List<? extends DocTree> fullBody = getFullBody(m);\n-        return fullBody.isEmpty() ||\n-                (fullBody.size() == 1 && fullBody.get(0).getKind().equals(Kind.INHERIT_DOC));\n-    }\n-\n@@ -2745,9 +2624,5 @@\n-        return new DocFinder(e -> {\n-            var i = overriddenMethod(e);\n-            return i == null ? null : i.overriddenMethod();\n-        }, this::implementedMethods);\n-    }\n-\n-    private Iterable<ExecutableElement> implementedMethods(ExecutableElement originalMethod, ExecutableElement m) {\n-        var type = configuration.utils.getEnclosingTypeElement(m);\n-        return configuration.getVisibleMemberTable(type).getImplementedMethods(originalMethod);\n+        return new DocFinder((t, e) -> configuration.getVisibleMemberTable(t).overrideAt(e).descending()\n+                .skip(1) \/\/ skip the first element (i.e. passed method)\n+                .filter(i -> !i.isSimpleOverride())\n+                .map(VisibleMemberTable.OverrideSequence::getMethod)\n+                .iterator());\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/Utils.java","additions":5,"deletions":130,"binary":false,"changes":135,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import javax.lang.model.element.QualifiedNameable;\n@@ -35,0 +36,1 @@\n+import javax.lang.model.element.TypeParameterElement;\n@@ -42,0 +44,1 @@\n+import javax.lang.model.util.ElementFilter;\n@@ -44,1 +47,1 @@\n-import java.lang.ref.SoftReference;\n+import javax.lang.model.util.Types;\n@@ -52,1 +55,0 @@\n-import java.util.LinkedHashMap;\n@@ -56,0 +58,1 @@\n+import java.util.NoSuchElementException;\n@@ -57,0 +60,1 @@\n+import java.util.RandomAccess;\n@@ -60,0 +64,1 @@\n+import java.util.stream.IntStream;\n@@ -62,0 +67,1 @@\n+import com.sun.source.doctree.DocTree;\n@@ -66,0 +72,2 @@\n+import static javax.lang.model.element.ElementKind.ANNOTATION_TYPE;\n+\n@@ -182,7 +190,2 @@\n-    \/\/  FIXME: Figure out why it is one-one and not one-to-many.\n-    \/**\n-     * Maps a method m declared in {@code te} to a visible method m' in a\n-     * {@code te}'s supertype such that m overrides m'.\n-     *\/\n-    private final Map<ExecutableElement, OverrideInfo> overriddenMethodTable\n-            = new LinkedHashMap<>();\n+    private final Map<ExecutableElement, OverrideSequence> overriddenMethods = new HashMap<>();\n+    private Set<ExecutableElement> methodMembers;\n@@ -194,0 +197,1 @@\n+        JAVA_LANG_OBJECT = utils.elementUtils.getTypeElement(\"java.lang.Object\");\n@@ -289,2 +293,21 @@\n-    \/**\n-     * Returns the method overridden by the provided method, or {@code null}.\n+    \/*\n+     * Returns an override sequence element that corresponds to the given method.\n+     *\n+     * An override sequence is an ordered set of one or more methods, each of\n+     * which, starting from the second, are overridden by the first, from this\n+     * class or interface. The order of methods in the sequence is the\n+     * following order of members discovery in supertypes: depth-first,\n+     * preferring classes to interfaces.\n+     *\n+     * The assumption is that there's a unique override sequence for each\n+     * method. If a method does not override anything, the sequence trivially\n+     * consists of just that method.\n+     *\n+     * Example 1\n+     * =========\n+     *\n+     *     public class A implements X { }\n+     *     public class B extends A implements Y { }\n+     *\n+     * Example 2\n+     * =========\n@@ -292,5 +315,2 @@\n-     * Sometimes it's not possible to link to a method that a link, linkplain,\n-     * or see tag mentions. This is because the method is a \"simple override\"\n-     * and, thus, has no useful documentation, or because the method is\n-     * declared in a type that has package access and, thus, has no visible\n-     * documentation.\n+     *     public interface X { }\n+     *     public interface Y extends X { }\n@@ -298,3 +318,2 @@\n-     * Call this method to determine if any of the above is the case. If the\n-     * call returns a method element, link to that method element instead of\n-     * the provided method.\n+     * API\n+     * ===\n@@ -302,2 +321,9 @@\n-     * @param e the method to check\n-     * @return the method found or {@code null}\n+     *   - If the method is not a member of this class or interface, an empty\n+     *     sequence is returned (this saves us from using an optional or\n+     *     throwing an exception, yet allows to conveniently check if a method\n+     *     participates in an override sequence).\n+     *\n+     *   - The overrider method (that is, the first method) is a part of the\n+     *     sequence because it's sometimes useful to view all the methods of\n+     *     the subsequence uniformly. The cursor is positioned at the given\n+     *     method for the same reason.\n@@ -305,8 +331,13 @@\n-    public ExecutableElement getOverriddenMethod(ExecutableElement e) {\n-        \/\/ TODO: consider possible ambiguities: multiple overridden methods\n-        ensureInitialized();\n-        assert !overriddenMethodTable.containsKey(null);\n-        OverrideInfo found = overriddenMethodTable.get(e);\n-        if (found != null\n-                && (found.simpleOverride || utils.isUndocumentedEnclosure(utils.getEnclosingTypeElement(e)))) {\n-            return found.overriddenMethod;\n+    public OverrideSequence overrideAt(ExecutableElement method) {\n+        if (method.getKind() != ElementKind.METHOD)\n+            throw new IllegalArgumentException(diagnosticDescriptionOf(method));\n+        var result = overriddenMethods.get(method);\n+        if (result != null)\n+            return result;\n+        for (ExecutableElement m : getMethodMembers()) {\n+            \/\/ Is `method` a member of this class or interface or is `method`\n+            \/\/ overridden by a member of this class or interface?\n+            if (method.equals(m) || utils.elementUtils.overrides(m, method, te)) {\n+                sequence(m); \/\/ sequence overrides starting from that member\n+                return overriddenMethods.get(method);\n+            }\n@@ -314,1 +345,1 @@\n-        return null;\n+        return new OverrideSequence();\n@@ -317,3 +348,16 @@\n-    \/**\n-     * {@return true if the specified method is NOT a simple override of some\n-     * other method, otherwise false}\n+    \/*\n+     * An element that provides access to its adjacent elements and describes\n+     * the override.\n+     *\n+     * API\n+     * ===\n+     *\n+     *  - OverrideData is not leaked to the client of this class for robustness:\n+     *    parts of data (e.g. isSimpleOverride) is sensitive to the order of\n+     *    elements, which if accessed through the element is fixed.\n+     *\n+     *  - Both type mirror and executable element are required to accurately\n+     *    and fully preserve information:\n+     *\n+     *     - the _type_ of a class or interface that declares the method is\n+     *       not available from method.getEnclosingElement()\n@@ -321,1 +365,19 @@\n-     * @param e the method to check\n+     *     - javax.lang.model.type.ExecutableType cannot be translated to\n+     *       ExecutableElement: javax.lang.model.util.Types.asElement()\n+     *       returns null if passed such a type\n+     *\n+     *  - Compared to alternatives, such as general-purpose java.util.ListIterator\n+     *    or a pair consisting of a list and an index in that list, this class\n+     *    has some benefits; for example:\n+     *\n+     *     - it has methods with domain-specific names (no need to remember the\n+     *       order in a list)\n+     *\n+     *     - it does not have useless methods\n+     *\n+     *     - its objects are immutable (moreover, the class behaves as if it\n+     *       were annotated with @jdk.internal.ValueBased), which allows them,\n+     *       for example, to be used as keys in maps\n+     *\n+     *  - Sadly, cannot call this Override, as it will clash with\n+     *    java.lang.Override.\n@@ -323,2 +385,605 @@\n-    private boolean isNotSimpleOverride(ExecutableElement e) {\n-        ensureInitialized();\n+    public static final class OverrideSequence {\n+\n+        private final List<OverrideData> seq;\n+        private final int idx;\n+\n+        private OverrideSequence(List<OverrideData> seq, int idx) {\n+            this.seq = List.copyOf(seq);\n+            \/\/ Unmodifiable lists are random-access: the lists and their\n+            \/\/ subList views implement the RandomAccess interface.\n+            \/\/\n+            \/\/ If that weren't guaranteed we would need to make a local\n+            \/\/ reference to the respective list element, as sometimes\n+            \/\/ we access it\n+            assert this.isEmpty() || this.seq instanceof RandomAccess;\n+            this.idx = Objects.checkIndex(idx, seq.size());\n+        }\n+\n+        \/\/ Creates an empty sequence\n+        private OverrideSequence() {\n+            this.seq = List.of();\n+            this.idx = 0;\n+        }\n+\n+        public boolean isEmpty() {\n+            return seq.isEmpty();\n+        }\n+\n+        public boolean hasMoreSpecific() {\n+            return idx > 0;\n+        }\n+\n+        public OverrideSequence moreSpecific() {\n+            if (!hasMoreSpecific())\n+                throw new NoSuchElementException();\n+            return new OverrideSequence(seq, idx - 1);\n+        }\n+\n+        public boolean hasLessSpecific() {\n+            return idx < seq.size() - 1;\n+        }\n+\n+        public OverrideSequence lessSpecific() {\n+            if (!hasLessSpecific())\n+                throw new NoSuchElementException();\n+            return new OverrideSequence(seq, idx + 1);\n+        }\n+\n+        \/*\n+         * Elements are streamed starting from this (inclusive) towards the\n+         * least specific, i.e. \"order by specificity desc\". Returns an empty\n+         * stream if called on an empty element.\n+         *\/\n+        public Stream<OverrideSequence> descending() {\n+            return IntStream.range(idx, seq.size())\n+                    .mapToObj(i -> new OverrideSequence(seq, i));\n+            \/\/ Outside this class, the same is achievable through:\n+            \/\/\n+            \/\/ return Stream.iterate(this, OverrideSequence::hasLessSpecific,\n+            \/\/        OverrideSequence::lessSpecific);\n+        }\n+\n+        private OverrideData data() {\n+            if (isEmpty())\n+                throw new NoSuchElementException();\n+            return seq.get(idx);\n+        }\n+\n+        public boolean isSimpleOverride() {\n+            return data().simpleOverride;\n+        }\n+\n+        public DeclaredType getEnclosingType() {\n+            return data().enclosing;\n+        }\n+\n+        public ExecutableElement getMethod() {\n+            return data().method;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return isEmpty() ? 0 : Objects.hash(idx, seq);\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            if (obj == this)\n+                return true;\n+            if (!(obj instanceof OverrideSequence that))\n+                return false;\n+            if (this.isEmpty()) {\n+                return that.isEmpty();\n+            } else {\n+                return !that.isEmpty() && ( this.idx == that.idx && this.seq.equals(that.seq) );\n+            }\n+        }\n+\n+        \/*\n+         * For debugging purposes.\n+         *\/\n+        @Override\n+        public String toString() {\n+            if (seq.isEmpty())\n+                return \"(empty)\";\n+            var res = new StringBuilder();\n+            \/\/ list elements in the order of decreasing specificity:\n+            \/\/ leftmost is the most specific while the rightmost\n+            \/\/ is the least specific\n+            var iterator = seq.listIterator();\n+            while (iterator.hasNext()) {\n+                \/\/ mark this element by enclosing it in square brackets\n+                var thisElement = idx == iterator.nextIndex();\n+                if (thisElement)\n+                    res.append(\"[\");\n+                res.append(toString(iterator.next().method()));\n+                if (thisElement)\n+                    res.append(\"]\");\n+                if (iterator.hasNext()) {\n+                    res.append(\"  \");\n+                }\n+            }\n+            return res.toString();\n+        }\n+\n+        private String toString(ExecutableElement m) {\n+            \/\/ parameterization can change mid sequence, which might be\n+            \/\/ important to spot: add type parameters to description\n+            List<? extends TypeParameterElement> tp = m.getTypeParameters();\n+            \/\/ sadly, Collectors.joining adds prefix and suffix regardless of\n+            \/\/ whether or not the stream is empty: work around it by using\n+            \/\/ emptiness pre-check\n+            var typeParametersDesc = tp.isEmpty() ? \"\" : tp.stream()\n+                    .map(p -> p.asType().toString())\n+                    .collect(Collectors.joining(\",\", \"<\", \">\"));\n+            return m.getEnclosingElement().getSimpleName() + \".\"\n+                    + typeParametersDesc + m.getSimpleName()\n+                    + \"(\" + m.getParameters().stream()\n+                    .map(p -> p.asType().toString())\n+                    .collect(Collectors.joining(\",\")) + \")\";\n+        }\n+    }\n+\n+    \/*\n+     * Computes all method members of this class or interface.\n+     *\/\n+    private Set<ExecutableElement> getMethodMembers() {\n+        if (methodMembers == null) {\n+            \/\/ Elements.getAllMembers has bugs which preclude us from using it.\n+            \/\/ Once they have been fixed, consider using it instead of ad-hoc\n+            \/\/ computation of a set of method members:\n+            \/\/\n+            \/\/ methodMembers = new LinkedHashSet<>(\n+            \/\/        ElementFilter.methodsIn(elements().getAllMembers(te)));\n+            methodMembers = getMethodMembers0(te);\n+        }\n+        return methodMembers;\n+    }\n+\n+    \/*\n+     * This algorithm of computation of method members is jdk.javadoc's\n+     * interpretation of \"The Java Language Specification, Java SE 20 Edition\".\n+     *\n+     * Corresponds to 8. Classes, 8.2. Class Members, and 9.2. Interface Members.\n+     *\n+     * 8. Classes\n+     *\n+     *     The body of a class declares members (fields, methods, classes, and\n+     *     interfaces)...\n+     *\n+     * 8.2. Class Members:\n+     *\n+     *     The members of a class are all of the following:\n+     *\n+     *       - Members inherited from its direct superclass type (8.1.4),\n+     *         except in the class Object, which has no direct superclass type\n+     *\n+     *       - Members inherited from any direct superinterface types (8.1.5)\n+     *\n+     *       - Members declared in the body of the class (8.1.7)\n+     *\n+     *      Members of a class that are declared private are not inherited by\n+     *      subclasses of that class.\n+     *\n+     *      Only members of a class that are declared protected or public are\n+     *      inherited by subclasses declared in a package other than the one\n+     *      in which the class is declared.\n+     *\n+     * 9.2. Interface Members:\n+     *\n+     *     The members of an interface are:\n+     *\n+     *       - Members declared in the body of the interface declaration (9.1.5).\n+     *\n+     *       - Members inherited from any direct superinterface types (9.1.3).\n+     *\n+     *       - If an interface has no direct superinterface types, then the\n+     *         interface implicitly declares a public abstract member method m\n+     *         with signature s, return type r, and throws clause t\n+     *         corresponding to each public instance method m with signature s,\n+     *         return type r, and throws clause t declared in Object (4.3.2),\n+     *         unless an abstract method with the same signature, same return\n+     *         type, and a compatible throws clause is explicitly declared by\n+     *         the interface.\n+     *\/\n+    private Set<ExecutableElement> getMethodMembers0(TypeElement t) {\n+        var declaredMethods = Collections.unmodifiableList(ElementFilter.methodsIn(t.getEnclosedElements()));\n+        var result = new ArrayList<ExecutableElement>();\n+        result.addAll(declaredMethods);\n+        if (t.getKind().isClass()) {\n+            var concreteSuperclassMethods = new ArrayList<ExecutableElement>();\n+            classInheritConcreteMethods(t, declaredMethods, concreteSuperclassMethods, result);\n+            classInheritAbstractAndDefaultMethods(t, declaredMethods, concreteSuperclassMethods, result);\n+        } else if (t.getKind().isInterface()) {\n+            interfaceInheritMethods(t, declaredMethods, result);\n+        } else {\n+            throw new AssertionError(diagnosticDescriptionOf(t));\n+        }\n+        return new LinkedHashSet<>(result); \/\/ return a set, but preserve the order\n+    }\n+\n+    \/*\n+     * Corresponds to 8.4.8 Inheritance, Overriding, and Hiding:\n+     *\n+     *     A class C inherits from its direct superclass type D all concrete\n+     *     methods m (both static and instance) for which all of the following\n+     *     are true:\n+     *\n+     *       - m is a member of D.\n+     *\n+     *       - m is public, protected, or declared with package access in\n+     *         the same package as C.\n+     *\n+     *       - No method declared in C has a signature that is a subsignature\n+     *         (8.4.2) of the signature of m as a member of D.\n+     *\/\n+    private void classInheritConcreteMethods(TypeElement t,\n+                                             Iterable<? extends ExecutableElement> declaredMethods,\n+                                             Collection<? super ExecutableElement> concreteSuperclassMethods,\n+                                             Collection<? super ExecutableElement> result) {\n+        var superclassType = t.getSuperclass();\n+        if (superclassType.getKind() == TypeKind.NONE) {\n+            \/\/ comment out because it interferes with the IgnoreSourceErrors test:\n+            \/\/ assert JAVA_LANG_OBJECT.equals(t) : diagnosticDescriptionOf(t);\n+        } else {\n+            var superclassMethods = mcache.getVisibleMemberTable(asTypeElement(superclassType)).getMethodMembers();\n+            for (var sm : superclassMethods) {\n+                var m = sm.getModifiers();\n+                if (m.contains(Modifier.ABSTRACT))\n+                    continue;\n+                if (m.contains(Modifier.PRIVATE))\n+                    continue;\n+                if (!m.contains(Modifier.PUBLIC) && !m.contains(Modifier.PROTECTED)\n+                        && isInTheSamePackage(sm, t))\n+                    continue;\n+                if (isSubsignatured(declaredMethods, (DeclaredType) t.asType(), (DeclaredType) superclassType, sm))\n+                    continue;\n+                concreteSuperclassMethods.add(sm);\n+                result.add(sm);\n+            }\n+        }\n+    }\n+\n+    private final TypeElement JAVA_LANG_OBJECT;\n+\n+    \/*\n+     * Corresponds to 8.4.8 Inheritance, Overriding, and Hiding:\n+     *\n+     *     A class C inherits from its direct superclass type and direct\n+     *     superinterface types all abstract and default (9.4) methods m\n+     *     for which all of the following are true:\n+     *\n+     *       - m is a member of the direct superclass type or a direct\n+     *         superinterface type of C, known in either case as D.\n+     *\n+     *       - m is public, protected, or declared with package access\n+     *         in the same package as C.\n+     *\n+     *       - No method declared in C has a signature that is a subsignature\n+     *         (8.4.2) of the signature of m as a member of D.\n+     *\n+     *       - No concrete method inherited by C from its direct superclass\n+     *         type has a signature that is a subsignature of the signature\n+     *         of m as a member of D.\n+     *\n+     *       - There exists no method m' that is a member of the direct\n+     *         superclass type or a direct superinterface type of C, D'\n+     *         (m distinct from m', D distinct from D'), such that m'\n+     *         overrides from the class or interface of D' the declaration\n+     *         of the method m (8.4.8.1, 9.4.1.1).\n+     *\/\n+    private void classInheritAbstractAndDefaultMethods(TypeElement t,\n+                                                       Iterable<? extends ExecutableElement> declaredMethods,\n+                                                       Iterable<? extends ExecutableElement> concreteSuperclassMethods,\n+                                                       Collection<? super ExecutableElement> inheritedMethods) {\n+        var directSupertypes = directSupertypes(t.asType());\n+        for (var s : directSupertypes) {\n+            var supertypeElement = asTypeElement(s);\n+            \/\/ FIXME: parameterization information is lost:\n+            var supertypeMethods = mcache.getVisibleMemberTable(supertypeElement).getMethodMembers();\n+            for (var sm : supertypeMethods) {\n+                var m = sm.getModifiers();\n+                if (!m.contains(Modifier.ABSTRACT) && !m.contains(Modifier.DEFAULT))\n+                    continue;\n+                if (m.contains(Modifier.PRIVATE))\n+                    continue;\n+                if (!m.contains(Modifier.PUBLIC) && !m.contains(Modifier.PROTECTED)\n+                        && !isInTheSamePackage(sm, t))\n+                    continue;\n+                if (isSubsignatured(declaredMethods, (DeclaredType) t.asType(), s, sm))\n+                    continue;\n+                if (isSubsignatured(concreteSuperclassMethods, (DeclaredType) t.asType(), s, sm))\n+                    continue;\n+                if (isOverridden(sm, directSupertypes))\n+                    continue;\n+                \/\/ while 8.4.8 mentions such methods explicitly, by now\n+                \/\/ they should have been already filtered out\n+                assert !(supertypeElement.getKind().isInterface()\n+                        && (m.contains(Modifier.PRIVATE) || m.contains(Modifier.STATIC)));\n+                inheritedMethods.add(sm);\n+            }\n+        }\n+    }\n+\n+    \/*\n+     * Corresponds to 9.4.1 Inheritance and Overriding:\n+     *\n+     *     An interface I inherits from its direct superinterface types all\n+     *     abstract and default methods m for which all of the following\n+     *     are true:\n+     *\n+     *       - m is a member of a direct superinterface type of I, J.\n+     *\n+     *       - No method declared in I has a signature that is a subsignature\n+     *         (8.4.2) of the signature of m as a member of J.\n+     *\n+     *       - There exists no method m' that is a member of a direct\n+     *         superinterface of I, J' (m distinct from m', J distinct from J'),\n+     *         such that m' overrides from the interface of J' the declaration\n+     *         of the method m (9.4.1.1).\n+     *\n+     *      An interface does not inherit private or static methods from\n+     *      its superinterfaces.\n+     *\/\n+    private void interfaceInheritMethods(TypeElement i,\n+                                         Iterable<? extends ExecutableElement> declaredMethods,\n+                                         Collection<? super ExecutableElement> inheritedMethods) {\n+        var directSuperinterfaces = i.getInterfaces();\n+        for (var j : directSuperinterfaces) {\n+            var superinterfaceMethods = mcache.getVisibleMemberTable(asTypeElement(j)).getMethodMembers();\n+            for (var m : superinterfaceMethods) {\n+                var access = m.getModifiers();\n+                if (!access.contains(Modifier.ABSTRACT) && !access.contains(Modifier.DEFAULT))\n+                    continue;\n+                \/\/ don't need to check for static because of 8.4.3. Method Modifiers:\n+                \/\/\n+                \/\/     It is a compile-time error if a method declaration that\n+                \/\/     contains the keyword abstract also contains any one of\n+                \/\/     the keywords private, static, final, native, strictfp,\n+                \/\/     or synchronized.\n+                assert !access.contains(Modifier.STATIC) : diagnosticDescriptionOf(m);\n+                if (access.contains(Modifier.PRIVATE))\n+                    continue;\n+                if (isSubsignatured(declaredMethods, (DeclaredType) i.asType(), (DeclaredType) j, m))\n+                    continue;\n+                if (isOverridden(m, directSuperinterfaces))\n+                    continue;\n+                inheritedMethods.add(m);\n+            }\n+        }\n+        if (!directSuperinterfaces.isEmpty())\n+            return;\n+        \/\/ comment out because our model does not currently require it:\n+        \/\/ that is, the Object-like methods are not tracked as members of\n+        \/\/ interfaces (getMethodMembers), they are only tracked as overrides\n+        \/\/ (overrideAt):\n+        \/\/ interfaceProvideObjectLikeMethods(declaredMethods, (DeclaredType) i.asType(), inheritedMethods);\n+    }\n+\n+    \/*\n+     * Corresponds to 9.2. Interface Members:\n+     *\n+     *     If an interface has no direct superinterface types, then the\n+     *     interface implicitly declares a public abstract member method m with\n+     *     signature s, return type r, and throws clause t corresponding to\n+     *     each public instance method m with signature s, return type r, and\n+     *     throws clause t declared in Object (4.3.2), unless an abstract\n+     *     method with the same signature, same return type, and a compatible\n+     *     throws clause is explicitly declared by the interface.\n+     *\/\n+    private void interfaceProvideObjectLikeMethods(Iterable<? extends ExecutableElement> declaredMethods,\n+                                                   DeclaredType type,\n+                                                   Collection<? super ExecutableElement> inheritedMethods) {\n+        \/\/ We currently inherit from Object similarly to how javax.lang.model.element.Elements.getAllMembers FIXME reword\n+        \/\/ does it. Later, we might revisit to consider re-declaring abstract\n+        \/\/ methods as per 9.2. Interface Members\n+        for (var m : mcache.getVisibleMemberTable(JAVA_LANG_OBJECT).getMethodMembers()) {\n+            var access = m.getModifiers();\n+            if (access.contains(Modifier.STATIC))\n+                continue;\n+            if (!access.contains(Modifier.PUBLIC))\n+                continue;\n+            if (isSubsignatured(declaredMethods, type, (DeclaredType) JAVA_LANG_OBJECT.asType(), m))\n+                continue; \/\/ actually, it should be the _same_ signature (not a subsignature)\n+            inheritedMethods.add(m);\n+        }\n+    }\n+\n+    private boolean isSubsignatured(Iterable<? extends ExecutableElement> candidateSubsignatures,\n+                                    DeclaredType candidateSubsignaturesType,\n+                                    DeclaredType s,\n+                                    ExecutableElement sm) {\n+        var mAsMemberOfS = (ExecutableType) types().asMemberOf(s, sm);\n+        for (var c : candidateSubsignatures) {\n+            if (sm.getSimpleName().equals(c.getSimpleName())\n+                    && types().isSubsignature((ExecutableType) types().asMemberOf(candidateSubsignaturesType, c), mAsMemberOfS))\n+                return true;\n+        }\n+        return false;\n+    }\n+\n+    private boolean isInTheSamePackage(ExecutableElement m, TypeElement t) {\n+        return !Objects.equals(elements().getPackageOf(m), elements().getPackageOf(t));\n+    }\n+\n+    \/*\n+     * This method is equivalent to javax.lang.model.util.Types.directSupertypes(t)\n+     * except when t is an interface type that has (direct) superinterface types:\n+     * in that case, the returned collection does not contain java.lang.Object.\n+     *\n+     * The behavior of this method is better aligned with 4.10.2. Subtyping among\n+     * Class and Interface Types:\n+     *\n+     *     Given ... interface C, the direct supertypes of the type of C\n+     *     are all of the following:\n+     *\n+     *         ...\n+     *\n+     *       - The type Object, if C is an interface with no direct\n+     *         superinterface types (9.1.3).\n+     *\n+     * This method could be revisited once JDK-8299917 has been resolved.\n+     *\/\n+    @SuppressWarnings(\"unchecked\")\n+    private List<DeclaredType> directSupertypes(TypeMirror t) {\n+        Collection<? extends TypeMirror> result;\n+        var e = asTypeElement(t);\n+        if (e.getKind().isInterface() && !e.getInterfaces().isEmpty()) {\n+            result = types().directSupertypes(t).stream()\n+\/\/                    .dropWhile(m -> types().asElement(m).equals(JAVA_LANG_OBJECT))\n+                    .toList();\n+\/\/            assert result.stream()\n+\/\/                    .allMatch(i -> types().asElement(i).getKind().isInterface());\n+        } else {\n+            result = types().directSupertypes(t);\n+        }\n+        \/\/ comment out because it interferes with the IgnoreSourceErrors test:\n+        \/\/ assert result.stream().allMatch(r -> r.getKind() == TypeKind.DECLARED) : diagnosticDescriptionOf(t);\n+        return List.copyOf((Collection<DeclaredType>) result);\n+    }\n+\n+    \/*\n+     * Is m overridden from any of the classes or interfaces (which correspond\n+     * to provided types)?\n+     *\/\n+    private boolean isOverridden(ExecutableElement m, Iterable<? extends TypeMirror> from) {\n+        var r1 = isOverridden1(m, from);\n+        \/\/ cross-check the main implementation an alternative one\n+        assert r1 == isOverridden2(m, from) : diagnosticDescriptionOf(m)\n+                + \"; \" + diagnosticDescriptionOf(te);\n+        return r1;\n+    }\n+\n+    private boolean isOverridden1(ExecutableElement m, Iterable<? extends TypeMirror> from) {\n+        for (var s : from) {\n+            \/\/ piggyback on override sequences in the hope of better performance\n+            var r = mcache.getVisibleMemberTable(asTypeElement(s))\n+                    .overrideAt(m).hasMoreSpecific();\n+            if (r)\n+                return true;\n+        }\n+        return false;\n+    }\n+\n+    private boolean isOverridden2(ExecutableElement m, Iterable<? extends TypeMirror> from) {\n+        for (var s : from)\n+            for (var m_ : mcache.getVisibleMemberTable(asTypeElement(s)).getMethodMembers())\n+                if (elements().overrides(m_, m, asTypeElement(s)))\n+                    return true;\n+        return false;\n+    }\n+\n+    private TypeElement asTypeElement(TypeMirror m) {\n+        return (TypeElement) types().asElement(m);\n+    }\n+\n+    private static String diagnosticDescriptionOf(Element e) {\n+        if (e == null) \/\/ shouldn't NPE if passed null\n+            return \"null\";\n+        return e + \", \" + (e instanceof QualifiedNameable q ? q.getQualifiedName() : e.getSimpleName())\n+                + \", \" + e.getKind() + \", \" + Objects.toIdentityString(e);\n+    }\n+\n+    private Elements elements() { return utils.elementUtils; }\n+\n+    private Types types() { return utils.typeUtils; }\n+\n+    private void sequence(ExecutableElement m) {\n+        var rawSequence = findOverriddenBy(m);\n+        \/\/ Prepend the member from which the exploration started, unconditionally\n+        rawSequence = rawSequence.prepend(new OverrideData(\n+                (DeclaredType) m.getEnclosingElement().asType(), m, false \/* this flag's value is immaterial *\/));\n+\n+\/\/        \/\/ impose an order\n+\/\/        var order = createSupertypeOrderMap(te);\n+\/\/        var copyList = new ArrayList<>(rawSequence);\n+\/\/        copyList.sort(Comparator.comparingInt(o -> order.get(o.enclosing.asElement())));\n+\/\/        rawSequence = com.sun.tools.javac.util.List.from(copyList);\n+\n+        \/\/ Fix the sequence by computing isSimpleOverride for all the sequence\n+        \/\/ members and hashing those members.\n+        \/\/\n+        \/\/ Start from the least specific member, which by convention is not\n+        \/\/ a simple override (even if it has no documentation), and work our\n+        \/\/ way _backwards_ to the most specific\n+        \/\/ member. Enter each member into a hash map as an entry point for\n+        \/\/ a subsequence starring from that member.\n+        \/\/ FIXME: what if we have initial method enclosed in an undocumented class or interface?\n+        \/\/  i.e. what if we cannot guarantee that at least one member is not a simple override?\n+        var fixedSequence = com.sun.tools.javac.util.List.<OverrideData>nil();\n+        rawSequence = rawSequence.reverse();\n+        boolean simpleOverride = false;\n+        while (!rawSequence.isEmpty()) {\n+            var f = new OverrideData(rawSequence.head.enclosing, rawSequence.head.method(), simpleOverride);\n+            fixedSequence = fixedSequence.prepend(f);\n+            rawSequence = rawSequence.tail;\n+            if (!rawSequence.isEmpty()) {\n+                \/\/ Even with --override-methods=summary we want to include details of\n+                \/\/ overriding method if something noteworthy has been added or changed\n+                \/\/ in the local overriding method\n+                var enclosing = (TypeElement) rawSequence.head.method.getEnclosingElement();\n+                simpleOverride = isSimpleOverride(rawSequence.head.method)\n+                        && !utils.isUndocumentedEnclosure(enclosing)\n+                        && !overridingSignatureChanged(rawSequence.head.method, f.method);\n+            }\n+        }\n+        \/\/ hash sequences as entry points\n+        var t = new OverrideSequence(fixedSequence, 0);\n+        while (true) {\n+            overriddenMethods.put(t.getMethod(), t);\n+            if (!t.hasLessSpecific()) {\n+                break;\n+            } else {\n+                t = t.lessSpecific();\n+            }\n+        }\n+    }\n+\n+    private com.sun.tools.javac.util.List<OverrideData> findOverriddenBy(ExecutableElement m) {\n+        return findOverriddenBy(m, (DeclaredType) te.asType(), com.sun.tools.javac.util.List.nil(), new HashSet<>());\n+    }\n+\n+    private com.sun.tools.javac.util.List<OverrideData> findOverriddenBy(ExecutableElement m,\n+                                                                         DeclaredType declaredType,\n+                                                                         com.sun.tools.javac.util.List<OverrideData> result,\n+                                                                         Set<ExecutableElement> foundOverriddenSoFar) {\n+        for (var s : directSupertypes(declaredType)) {\n+            var supertypeElement = (TypeElement) s.asElement();\n+            for (var m1 : mcache.getVisibleMemberTable(supertypeElement).getMethodMembers())\n+                if (utils.elementUtils.overrides(m, m1, te) && foundOverriddenSoFar.add(m1)) {\n+                    \/\/ use any value for `simpleOverride` for now: the actual value\n+                    \/\/ will be computed once the complete sequence is available\n+                    var simpleOverride = false;\n+                    result = result.append(new OverrideData(toDeclaringType(s,\n+                            (TypeElement) m1.getEnclosingElement()), m1, simpleOverride));\n+                }\n+            result = findOverriddenBy(m, s, result, foundOverriddenSoFar);\n+        }\n+        return result;\n+    }\n+\n+    \/*\n+     * Translates the provided class or interface to a type given its subtype.\n+     *\n+     * The correctness relies of no more than 1 parameterization from JLS. (TODO link the correct section)\n+     *\n+     * There's probably a better way of doing it using javax.lang.model.util.Types.getDeclaredType(),\n+     * but for now this will do.\n+     *\/\n+    private DeclaredType toDeclaringType(DeclaredType subtype, TypeElement element) {\n+        var r = toDeclaringType0(subtype, element);\n+        if (r == null)\n+            throw new IllegalArgumentException(); \/\/ not a subtype\n+        return r;\n+    }\n+\n+    private DeclaredType toDeclaringType0(DeclaredType subtype, TypeElement element) {\n+        if (subtype.asElement().equals(element))\n+            return subtype;\n+        for (var s : utils.typeUtils.directSupertypes(subtype)) {\n+            var r = toDeclaringType0((DeclaredType) s, element);\n+            if (r != null)\n+                return r;\n+        }\n+        return null;\n+    }\n@@ -326,2 +991,8 @@\n-        var info = overriddenMethodTable.get(e);\n-        return info == null || !info.simpleOverride;\n+    private record OverrideData(DeclaredType enclosing,\n+                                ExecutableElement method,\n+                                boolean simpleOverride) {\n+        private OverrideData {\n+            if (!enclosing.asElement().equals(method.getEnclosingElement())) {\n+                throw new IllegalArgumentException();\n+            }\n+        }\n@@ -568,60 +1239,12 @@\n-    private void computeVisibleMethods(LocalMemberTable lmt) {\n-        \/\/ parentMethods is a union of visible methods from all parents.\n-        \/\/ It is used to figure out which methods this type should inherit.\n-        \/\/ Inherited methods are those parent methods that remain after all\n-        \/\/ methods that cannot be inherited are eliminated.\n-        Set<Element> parentMethods = new LinkedHashSet<>();\n-        for (var p : parents) {\n-            \/\/ Lists of visible methods from different parents may share some\n-            \/\/ methods. These are the methods that the parents inherited from\n-            \/\/ their common ancestor.\n-            \/\/\n-            \/\/ Such methods won't result in duplicates in parentMethods as we\n-            \/\/ purposefully don't track duplicates.\n-            \/\/ FIXME: add a test to assert the order (LinkedHashSet)\n-            parentMethods.addAll(p.getAllVisibleMembers(Kind.METHODS));\n-        }\n-\n-        \/\/ overriddenByTable maps an ancestor (grandparent and above) method\n-        \/\/ to parent methods that override it:\n-        \/\/\n-        \/\/ key\n-        \/\/ : a method overridden by one or more parent methods\n-        \/\/ value\n-        \/\/ : a list of parent methods that override the key\n-        Map<ExecutableElement, List<ExecutableElement>> overriddenByTable = new HashMap<>();\n-        for (var p : parents) {\n-            \/\/ Merge the lineage overrides into local table\n-            p.overriddenMethodTable.forEach((method, methodInfo) -> {\n-                if (!methodInfo.simpleOverride) { \/\/ consider only real overrides\n-                    var list = overriddenByTable.computeIfAbsent(methodInfo.overriddenMethod,\n-                            k -> new ArrayList<>());\n-                    list.add(method);\n-                }\n-            });\n-        }\n-\n-        \/\/ filter out methods that aren't inherited\n-        \/\/\n-        \/\/ nb. This statement has side effects that can initialize\n-        \/\/ members of the overriddenMethodTable field, so it must be\n-        \/\/ evaluated eagerly with toList().\n-        List<Element> inheritedMethods = parentMethods.stream()\n-                .filter(e -> allowInheritedMethod((ExecutableElement) e, overriddenByTable, lmt))\n-                .toList();\n-\n-        \/\/ filter out \"simple overrides\" from local methods\n-        Predicate<ExecutableElement> nonSimpleOverride = m -> {\n-            OverrideInfo i = overriddenMethodTable.get(m);\n-            return i == null || !i.simpleOverride;\n-        };\n-\n-        Stream<ExecutableElement> localStream = lmt.getOrderedMembers(Kind.METHODS)\n-                .stream()\n-                .map(m -> (ExecutableElement)m)\n-                .filter(nonSimpleOverride);\n-\n-        \/\/ Merge the above list and stream, making sure the local methods precede the others\n-        \/\/ Final filtration of elements\n-        \/\/ FIXME add a test to assert the order or remove that part of the comment above ^\n-        List<Element> list = Stream.concat(localStream, inheritedMethods.stream())\n+    private void computeVisibleMethods(LocalMemberTable ignored) {\n+        \/\/ dark tunnel (consisting of undocumented enclosures):\n+        \/\/   for every candidate method let's find the most specific non-simple\n+        \/\/   override included\n+        List<Element> list = getMethodMembers().stream()\n+                .filter(m -> te.getKind() != ANNOTATION_TYPE) \/\/ if te is annotation, ignore its methods altogether\n+                .filter(m -> !options.noDeprecated() || !utils.isDeprecated(m)) \/\/ exclude deprecated if requested\n+                .flatMap(m -> overrideAt(m).descending() \/\/ find the most specific non-simple override\n+                        .dropWhile(OverrideSequence::isSimpleOverride)\n+                        .map(OverrideSequence::getMethod)\n+                        .findFirst()\n+                        .stream())\n@@ -629,0 +1252,1 @@\n+                .map(m -> (Element) m)\n@@ -632,12 +1256,0 @@\n-\n-        \/\/ copy over overridden tables from the lineage\n-        for (VisibleMemberTable pvmt : parents) {\n-            \/\/ a key in overriddenMethodTable is a method _declared_ in the respective parent;\n-            \/\/ no two _different_ parents can share a declared method, by definition;\n-            \/\/ if parents in the list are different (i.e. the list of parents doesn't contain duplicates),\n-            \/\/   then no keys are equal and thus no replace happens\n-            \/\/ if the list of parents contains duplicates, values for the equal keys are equal,\n-            \/\/   so no harm if they are replaced in the map\n-            assert putAllIsNonReplacing(overriddenMethodTable, pvmt.overriddenMethodTable);\n-            overriddenMethodTable.putAll(pvmt.overriddenMethodTable);\n-        }\n@@ -646,33 +1258,11 @@\n-    private static <K, V> boolean putAllIsNonReplacing(Map<K, V> dst, Map<K, V> src) {\n-        for (var e : src.entrySet()) {\n-            if (dst.containsKey(e.getKey())\n-                    && !Objects.equals(dst.get(e.getKey()), e.getValue())) {\n-                return false;\n-            }\n-        }\n-        return true;\n-    }\n-\n-    private boolean allowInheritedMethod(ExecutableElement inheritedMethod,\n-                                         Map<ExecutableElement, List<ExecutableElement>> overriddenByTable,\n-                                         LocalMemberTable lmt) {\n-        \/\/ JLS 8.4.8: A class does not inherit private or static methods from\n-        \/\/ its superinterface types.\n-        \/\/\n-        \/\/ JLS 9.4.1: An interface does not inherit private or static methods\n-        \/\/ from its superinterfaces.\n-        \/\/\n-        \/\/ JLS 8.4.8: m is public, protected, or declared with package access\n-        \/\/ in the same package as C\n-        \/\/\n-        \/\/ JLS 9.4: A method in the body of an interface declaration may be\n-        \/\/ declared public or private. If no access modifier is given, the\n-        \/\/ method is implicitly public.\n-        if (!isAccessible(inheritedMethod))\n-            return false;\n-\n-        final boolean haveStatic = utils.isStatic(inheritedMethod);\n-        final boolean inInterface = isDeclaredInInterface(inheritedMethod);\n-\n-        \/\/ Static interface methods are never inherited (JLS 8.4.8 and 9.1.3)\n-        if (haveStatic && inInterface) {\n+    \/*\n+     * Returns true if the passed method does not change the specification it\n+     * inherited.\n+     *\n+     * If the passed method is not deprecated and has either no comment or a\n+     * comment consisting of single {@inheritDoc} tag, the inherited\n+     * specification is deemed unchanged and this method returns true;\n+     * otherwise this method returns false.\n+     *\/\n+    private boolean isSimpleOverride(ExecutableElement m) {\n+        if (!options.summarizeOverriddenMethods() || !utils.isIncluded(m)) {\n@@ -682,67 +1272,2 @@\n-        \/\/ Multiple-Inheritance: remove the interface method that may have\n-        \/\/ been overridden by another interface method in the hierarchy\n-        \/\/\n-        \/\/ Note: The following approach is very simplistic and is compatible\n-        \/\/ with old VMM. A future enhancement, may include a contention breaker,\n-        \/\/ to correctly eliminate those methods that are merely definitions\n-        \/\/ in favor of concrete overriding methods, for instance those that have\n-        \/\/ API documentation and are not abstract OR default methods.\n-        if (inInterface) {\n-            List<ExecutableElement> list = overriddenByTable.get(inheritedMethod);\n-            if (list != null) {\n-                boolean found = list.stream()\n-                        .anyMatch(this::isDeclaredInInterface);\n-                if (found)\n-                    return false;\n-            }\n-        }\n-\n-        Elements elementUtils = config.docEnv.getElementUtils();\n-\n-        \/\/ Check the local methods in this type.\n-        \/\/ List contains overloads and probably something else, but one match is enough, hence short-circuiting\n-        List<Element> lMethods = lmt.getMembers(inheritedMethod.getSimpleName(), Kind.METHODS);\n-        for (Element le : lMethods) {\n-            ExecutableElement lMethod = (ExecutableElement) le;\n-            \/\/ Ignore private methods or those methods marked with\n-            \/\/ a \"hidden\" tag. \/\/ FIXME I cannot see where @hidden is ignored\n-            if (utils.isPrivate(lMethod))\n-                continue;\n-\n-            \/\/ Remove methods that are \"hidden\", in JLS terms.\n-            if (haveStatic && utils.isStatic(lMethod) &&\n-                    elementUtils.hides(lMethod, inheritedMethod)) {\n-                return false;\n-            }\n-\n-            \/\/ Check for overriding methods.\n-            if (elementUtils.overrides(lMethod, inheritedMethod,\n-                    utils.getEnclosingTypeElement(lMethod))) {\n-\n-                assert utils.getEnclosingTypeElement(lMethod).equals(te);\n-\n-                \/\/ Disallow package-private super methods to leak in\n-                TypeElement encl = utils.getEnclosingTypeElement(inheritedMethod);\n-                if (utils.isUndocumentedEnclosure(encl)) {\n-                    \/\/ FIXME\n-                    \/\/  is simpleOverride=false here to force to be used because\n-                    \/\/  it cannot be linked to, because package-private?\n-                    overriddenMethodTable.computeIfAbsent(lMethod,\n-                            l -> new OverrideInfo(inheritedMethod, false));\n-                    return false;\n-                }\n-\n-                \/\/ Even with --override-methods=summary we want to include details of\n-                \/\/ overriding method if something noteworthy has been added or changed\n-                \/\/ either in the local overriding method or an in-between overriding method\n-                \/\/ (as evidenced by an entry in overriddenByTable).\n-                boolean simpleOverride = utils.isSimpleOverride(lMethod)\n-                        && !overridingSignatureChanged(lMethod, inheritedMethod)\n-                        && !overriddenByTable.containsKey(inheritedMethod);\n-                overriddenMethodTable.computeIfAbsent(lMethod,\n-                        l -> new OverrideInfo(inheritedMethod, simpleOverride));\n-                return simpleOverride;\n-            }\n-        }\n-        return true;\n-    }\n+        if (!utils.getBlockTags(m).isEmpty() || utils.isDeprecated(m))\n+            return false;\n@@ -750,2 +1275,3 @@\n-    private boolean isDeclaredInInterface(ExecutableElement e) {\n-        return e.getEnclosingElement().getKind() == ElementKind.INTERFACE;\n+        List<? extends DocTree> fullBody = utils.getFullBody(m);\n+        return fullBody.isEmpty() ||\n+                (fullBody.size() == 1 && fullBody.get(0).getKind().equals(DocTree.Kind.INHERIT_DOC));\n@@ -754,0 +1280,1 @@\n+    \/\/ fixme: consider comparing type parameters?\n@@ -766,0 +1293,2 @@\n+        \/\/ TODO: should we consider changes to synchronized as a significant change\n+        \/\/  (e.g. consider StringBuffer.length(), which is otherwise a simple override)?\n@@ -778,2 +1307,9 @@\n-        \/\/ Documented annotations added anywhere in the method signature\n-        return !getDocumentedAnnotations(method).equals(getDocumentedAnnotations(overriddenMethod));\n+        \/\/ Documented annotations, other than java.lang.Override, added anywhere in the method signature\n+        var JAVA_LANG_OVERRIDE = elements().getTypeElement(\"java.lang.Override\");\n+        var overriderAnnotations = getDocumentedAnnotations(method).stream()\n+                .filter(am -> !am.getAnnotationType().asElement().equals(JAVA_LANG_OVERRIDE))\n+                .collect(Collectors.toSet());\n+        var overriddenAnnotations = getDocumentedAnnotations(overriddenMethod).stream()\n+                .filter(am -> !am.getAnnotationType().asElement().equals(JAVA_LANG_OVERRIDE))\n+                .collect(Collectors.toSet());\n+        return !overriderAnnotations.equals(overriddenAnnotations);\n@@ -1028,103 +1564,0 @@\n-\n-    \/\/ Future cleanups\n-\n-    private final Map<ExecutableElement, SoftReference<ImplementedMethods>>\n-            implementMethodsFinders = new HashMap<>();\n-\n-    private ImplementedMethods getImplementedMethodsFinder(ExecutableElement method) {\n-        SoftReference<ImplementedMethods> ref = implementMethodsFinders.get(method);\n-        ImplementedMethods imf = ref == null ? null : ref.get();\n-        \/\/ imf does not exist or was gc'ed away?\n-        if (imf == null) {\n-            imf = new ImplementedMethods(method);\n-            implementMethodsFinders.put(method, new SoftReference<>(imf));\n-        }\n-        return imf;\n-    }\n-\n-    public List<ExecutableElement> getImplementedMethods(ExecutableElement method) {\n-        ImplementedMethods imf = getImplementedMethodsFinder(method);\n-        return imf.getImplementedMethods().stream()\n-                .filter(this::isNotSimpleOverride)\n-                .toList();\n-    }\n-\n-    public TypeMirror getImplementedMethodHolder(ExecutableElement method,\n-                                                 ExecutableElement implementedMethod) {\n-        ImplementedMethods imf = getImplementedMethodsFinder(method);\n-        return imf.getMethodHolder(implementedMethod);\n-    }\n-\n-    private class ImplementedMethods {\n-\n-        private final Map<ExecutableElement, TypeMirror> interfaces = new LinkedHashMap<>();\n-\n-        public ImplementedMethods(ExecutableElement implementer) {\n-            var typeElement = (TypeElement) implementer.getEnclosingElement();\n-            for (TypeMirror i : utils.getAllInterfaces(typeElement)) {\n-                TypeElement dst = utils.asTypeElement(i); \/\/ a type element to look an implemented method in\n-                ExecutableElement implemented = findImplementedMethod(dst, implementer);\n-                if (implemented == null) {\n-                    continue;\n-                }\n-                var prev = interfaces.put(implemented, i);\n-                \/\/ no two type elements declare the same method\n-                assert prev == null;\n-                \/\/ dst can be generic, while i might be parameterized; but they\n-                \/\/ must the same type element. For example, if dst is Set<T>,\n-                \/\/ then i is Set<String>\n-                assert Objects.equals(((DeclaredType) i).asElement(), dst);\n-            }\n-        }\n-\n-        private ExecutableElement findImplementedMethod(TypeElement te, ExecutableElement implementer) {\n-            var typeElement = (TypeElement) implementer.getEnclosingElement();\n-            for (var m : utils.getMethods(te)) {\n-                if (utils.elementUtils.overrides(implementer, m, typeElement)) {\n-                    return m;\n-                }\n-            }\n-            return null;\n-        }\n-\n-        \/**\n-         * Returns a collection of interface methods which the method passed in the\n-         * constructor is implementing. The search\/build order is as follows:\n-         * <pre>\n-         * 1. Search in all the immediate interfaces which this method's class is\n-         *    implementing. Do it recursively for the superinterfaces as well.\n-         * 2. Traverse all the superclasses and search recursively in the\n-         *    interfaces which those superclasses implement.\n-         * <\/pre>\n-         *\n-         * @return a collection of implemented methods\n-         *\/\n-        Collection<ExecutableElement> getImplementedMethods() {\n-            return interfaces.keySet();\n-        }\n-\n-        TypeMirror getMethodHolder(ExecutableElement ee) {\n-            return interfaces.get(ee);\n-        }\n-    }\n-\n-    \/*\n-     * (Here \"override\" used as a noun, not a verb, for a short and descriptive\n-     * name. Sadly, we cannot use \"Override\" as a complete name because a clash\n-     * with @java.lang.Override would make it inconvenient.)\n-     *\n-     * Used to provide additional attributes to the otherwise boolean\n-     * \"overrides(a, b)\" relationship.\n-     *\n-     * Overriding method could be a key in a map and an instance of this\n-     * record could be the value.\n-     *\/\n-    private record OverrideInfo(ExecutableElement overriddenMethod,\n-                                boolean simpleOverride) {\n-        @Override \/\/ for debugging\n-        public String toString() {\n-            return overriddenMethod.getEnclosingElement()\n-                    + \"::\" + overriddenMethod + \", simple=\" + simpleOverride;\n-        }\n-    }\n-\n@@ -1142,0 +1575,7 @@\n+\n+    @Override\n+    public String toString() {\n+        \/\/ output the simple name, not the fully qualified name, which is needlessly long\n+        return getClass().getSimpleName() + \"@\" + Integer.toHexString(super.hashCode())\n+                + \"[\" + te.getQualifiedName().toString() + \"]\";\n+    }\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/VisibleMemberTable.java","additions":757,"deletions":317,"binary":false,"changes":1074,"status":"modified"},{"patch":"@@ -0,0 +1,366 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Path;\n+\n+import javadoc.tester.JavadocTester;\n+import toolbox.ToolBox;\n+\n+\/*\n+ * @test\n+ * @bug 8304135\n+ * @library \/tools\/lib ..\/..\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ *          jdk.javadoc\/jdk.javadoc.internal.tool\n+ * @build toolbox.ToolBox javadoc.tester.*\n+ * @run main TestMethodMembers\n+ *\/\n+public class TestMethodMembers extends JavadocTester {\n+\n+    private final ToolBox tb = new ToolBox();\n+\n+    \/\/ The numbered sections below are from the Java Language Specification,\n+    \/\/ Java SE 20 Edition\n+\n+    public static void main(String... args) throws Exception {\n+        new TestMethodMembers().runTests();\n+    }\n+\n+    \/*\n+     * Example 8.4.8-1. Inheritance\n+     *\/\n+    @Test\n+    public void inheritOverrideEquivalent1(Path base) throws Exception {\n+        var src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src, \"\"\"\n+                interface I1 {\n+                    int foo();\n+                }\"\"\", \"\"\"\n+                interface I2 {\n+                    int foo();\n+                }\"\"\", \"\"\"\n+                abstract class Test implements I1, I2 {}\n+                \"\"\");\n+        javadoc(\"-d\", base.resolve(\"out\").toString(),\n+                \"-sourcepath\", src.toString(),\n+                \"--no-platform-links\",\n+                \"-package\",\n+                src.resolve(\"I1.java\").toString(),\n+                src.resolve(\"I2.java\").toString(),\n+                src.resolve(\"Test.java\").toString());\n+        checkExit(Exit.OK);\n+        checkOutput(\"Test.html\", true, \"\"\"\n+                <div class=\"inherited-list\">\n+                <h3 id=\"methods-inherited-from-class-I1\">Methods inherited from interface&nbsp;\\\n+                <a href=\"I1.html\" title=\"interface in Unnamed Package\">I1<\/a><\/h3>\n+                <code><a href=\"I1.html#foo()\">foo<\/a><\/code><\/div>\n+                <div class=\"inherited-list\">\n+                <h3 id=\"methods-inherited-from-class-I2\">Methods inherited from interface&nbsp;\\\n+                <a href=\"I2.html\" title=\"interface in Unnamed Package\">I2<\/a><\/h3>\n+                <code><a href=\"I2.html#foo()\">foo<\/a><\/code><\/div>\n+                <\/section>\"\"\");\n+    }\n+\n+    \/*\n+     * Similar to the previous test, but the methods are inherited by an interface.\n+     * See 9.4.1.3. Inheriting Methods with Override-Equivalent Signatures\n+     *\/\n+    @Test\n+    public void inheritOverrideEquivalent2(Path base) throws Exception {\n+        var src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src, \"\"\"\n+                interface I1 {\n+                    int foo();\n+                }\"\"\", \"\"\"\n+                interface I2 {\n+                    int foo();\n+                }\"\"\", \"\"\"\n+                interface I3 extends I1, I2 {}\n+                \"\"\");\n+        javadoc(\"-d\", base.resolve(\"out\").toString(),\n+                \"-sourcepath\", src.toString(),\n+                \"--no-platform-links\",\n+                \"-package\",\n+                src.resolve(\"I1.java\").toString(),\n+                src.resolve(\"I2.java\").toString(),\n+                src.resolve(\"I3.java\").toString());\n+        checkExit(Exit.OK);\n+        checkOutput(\"I3.html\", true, \"\"\"\n+                <div class=\"inherited-list\">\n+                <h3 id=\"methods-inherited-from-class-I1\">Methods inherited from interface&nbsp;\\\n+                <a href=\"I1.html\" title=\"interface in Unnamed Package\">I1<\/a><\/h3>\n+                <code><a href=\"I1.html#foo()\">foo<\/a><\/code><\/div>\n+                <div class=\"inherited-list\">\n+                <h3 id=\"methods-inherited-from-class-I2\">Methods inherited from interface&nbsp;\\\n+                <a href=\"I2.html\" title=\"interface in Unnamed Package\">I2<\/a><\/h3>\n+                <code><a href=\"I2.html#foo()\">foo<\/a><\/code><\/div>\n+                <\/section>\"\"\");\n+    }\n+\n+    \/*\n+     * A (more interesting) case from javax.lang.model.util.Elements.overrides.\n+     *\/\n+    @Test\n+    public void overrideByInheriting(Path base) throws Exception {\n+        var src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src,\n+                \"class A { public void m() {} }\",\n+                \"interface B { void m(); }\",\n+                \"class C extends A implements B {}\");\n+        javadoc(\"-d\", base.resolve(\"out\").toString(),\n+                \"-sourcepath\", src.toString(),\n+                \"--no-platform-links\",\n+                \"-package\",\n+                src.resolve(\"A.java\").toString(),\n+                src.resolve(\"B.java\").toString(),\n+                src.resolve(\"C.java\").toString());\n+        checkExit(Exit.OK);\n+        \/\/ C must not inherit B.m: doing so would violate 8.4.8:\n+        \/\/     No concrete method inherited by C from its direct superclass type\n+        \/\/     has a signature that is a subsignature of the signature of m as\n+        \/\/     a member of D.\n+        checkOutput(\"C.html\", false, \"\"\"\n+                <div class=\"inherited-list\">\n+                <h3 id=\"methods-inherited-from-class-B\">Methods inherited from interface&nbsp;\\\n+                <a href=\"B.html\" title=\"interface in Unnamed Package\">B<\/a><\/h3>\n+                <code><a href=\"B.html#m()\">m<\/a><\/code><\/div>\"\"\");\n+        \/\/ TODO: A.m should be mentioned as a non-simple override, I guess\n+    }\n+\n+    \/*\n+     * Overriding is complicated by package access sufficiently enough for\n+     * it NOT to be a transitive binary relation on methods even in a\n+     * consistently-compiled program.\n+     *\n+     * An example which the below two tests are based on is provided by\n+     * Daniel Smith, one of the JLS authors. In this example, B.m()\n+     * overrides A.m() and C.m() overrides B.m(); however, C.m()\n+     * does NOT override A.m().\n+     *\/\n+    @Test\n+    public void packageAccessOverride1(Path base) throws Exception {\n+        var src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src,\n+                \"package p1; public class A { void m() {} }\",\n+                \"package p1; public class B extends A { public void m() {} }\",\n+                \"package p2; public class C extends p1.B { public void m() {} }\");\n+        javadoc(\"-d\", base.resolve(\"out\").toString(),\n+                \"-sourcepath\", src.toString(),\n+                \"-package\",\n+                \"--no-platform-links\",\n+                \"p1\",\n+                \"p2\");\n+        checkExit(Exit.OK);\n+        checkOutput(\"p1\/B.html\", true, \"\"\"\n+                <section class=\"detail\" id=\"m()\">\n+                <h3>m<\/h3>\n+                <div class=\"member-signature\"><span class=\"modifiers\">public<\/span>&nbsp;\\\n+                <span class=\"return-type\">void<\/span>&nbsp;<span class=\"element-name\">m<\/span>()<\/div>\n+                <dl class=\"notes\">\n+                <dt>Overrides:<\/dt>\n+                <dd><code><a href=\"A.html#m()\">m<\/a><\/code>&nbsp;in class&nbsp;\\\n+                <code><a href=\"A.html\" title=\"class in p1\">A<\/a><\/code><\/dd>\n+                <\/dl>\n+                <\/section>\"\"\");\n+        checkOutput(\"p2\/C.html\", true, \"\"\"\n+                <section class=\"detail\" id=\"m()\">\n+                <h3>m<\/h3>\n+                <div class=\"member-signature\"><span class=\"modifiers\">public<\/span>&nbsp;\\\n+                <span class=\"return-type\">void<\/span>&nbsp;<span class=\"element-name\">m<\/span>()<\/div>\n+                <dl class=\"notes\">\n+                <dt>Overrides:<\/dt>\n+                <dd><code><a href=\"..\/p1\/B.html#m()\">m<\/a><\/code>&nbsp;in class&nbsp;\\\n+                <code><a href=\"..\/p1\/B.html\" title=\"class in p1\">B<\/a><\/code><\/dd>\n+                <\/dl>\n+                <\/section>\"\"\");\n+    }\n+\n+    @Test\n+    public void packageAccessOverride2(Path base) throws Exception {\n+        var src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src,\n+                \"package p1; public class A { void m() {} }\",\n+                \"package p1; public class B extends A { }\",\n+                \"package p2; public class C extends p1.B { public void m() {} }\");\n+        javadoc(\"-d\", base.resolve(\"out\").toString(),\n+                \"-sourcepath\", src.toString(),\n+                \"-package\",\n+                \"--no-platform-links\",\n+                \"p1\",\n+                \"p2\");\n+        checkExit(Exit.OK);\n+        checkOutput(\"p2\/C.html\", false, \"<dt>Overrides:<\/dt>\");\n+    }\n+\n+    \/*\n+     * A curious case from 8.4.8.1 which shows that it is possible for the\n+     * overridee and the overrider to be declared in the _same class_:\n+     *\n+     *     A concrete method in a generic superclass can, under certain\n+     *     parameterizations, have the same signature as an abstract method\n+     *     in that class. In this case, the concrete method is inherited and\n+     *     the abstract method is not (as described above). The inherited\n+     *     method should then be considered to override its abstract peer\n+     *     from C.\n+     *\/\n+    @Test\n+    public void peerOverride(Path base) throws Exception {\n+        var src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src, \"\"\"\n+                public abstract class A<T> {\n+                    public abstract void m(String arg);\n+                    public void m(T arg) { }\n+                }\"\"\", \"\"\"\n+                public class B extends A<String> {}\n+                \"\"\");\n+        javadoc(\"-d\", base.resolve(\"out\").toString(),\n+                \"-sourcepath\", src.toString(),\n+                \"--no-platform-links\",\n+                src.resolve(\"A.java\").toString(),\n+                src.resolve(\"B.java\").toString());\n+        checkExit(Exit.OK);\n+        checkOutput(\"B.html\", false, \"<dt>Overrides:<\/dt>\");\n+        checkOutput(\"B.html\", true, \"\"\"\n+                <div class=\"inherited-list\">\n+                <h3 id=\"methods-inherited-from-class-A\">Methods inherited from class&nbsp;\\\n+                <a href=\"A.html\" title=\"class in Unnamed Package\">A<\/a><\/h3>\n+                <code><a href=\"A.html#m(T)\">m<\/a><\/code><\/div>\"\"\");\n+    }\n+\n+    \/**\n+     * Complementary to the above: it shouldn't matter which one of these\n+     * methods in abstract and which one is concrete.\n+     *\/\n+    @Test\n+    public void peerOverride2(Path base) throws Exception {\n+        var src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src, \"\"\"\n+                public abstract class A<T> {\n+                    public void m(String arg);\n+                    public abstract void m(T arg) { }\n+                }\"\"\", \"\"\"\n+                public class B extends A<String> {}\n+                \"\"\");\n+        javadoc(\"-d\", base.resolve(\"out\").toString(),\n+                \"-sourcepath\", src.toString(),\n+                \"--no-platform-links\",\n+                src.resolve(\"A.java\").toString(),\n+                src.resolve(\"B.java\").toString());\n+        checkExit(Exit.OK);\n+        checkOutput(\"B.html\", false, \"<dt>Overrides:<\/dt>\");\n+        checkOutput(\"B.html\", true, \"\"\"\n+                <div class=\"inherited-list\">\n+                <h3 id=\"methods-inherited-from-class-A\">Methods inherited from class&nbsp;\\\n+                <a href=\"A.html\" title=\"class in Unnamed Package\">A<\/a><\/h3>\n+                <code><a href=\"A.html#m(java.lang.String)\">m<\/a><\/code><\/div>\"\"\");\n+    }\n+\n+    \/*\n+     * Example 8.4.3.1-1. Abstract\/Abstract Method Overriding\n+     *\/\n+    @Test\n+    public void abstractOverridesAbstract(Path base) throws Exception {\n+\n+        var src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src, \"\"\"\n+                class BufferEmpty extends Exception {\n+                    BufferEmpty() { super(); }\n+                    BufferEmpty(String s) { super(s); }\n+                }\"\"\", \"\"\"\n+                class BufferError extends Exception {\n+                    BufferError() { super(); }\n+                    BufferError(String s) { super(s); }\n+                }\"\"\", \"\"\"\n+                interface Buffer {\n+                    char get() throws BufferEmpty, BufferError;\n+                }\"\"\", \"\"\"\n+                abstract class InfiniteBuffer implements Buffer {\n+                    public abstract char get() throws BufferError;\n+                }\"\"\");\n+        javadoc(\"-d\", base.resolve(\"out\").toString(),\n+                \"-sourcepath\", src.toString(),\n+                \"-package\",\n+                \"--no-platform-links\",\n+                src.resolve(\"BufferEmpty.java\").toString(),\n+                src.resolve(\"BufferError.java\").toString(),\n+                src.resolve(\"Buffer.java\").toString(),\n+                src.resolve(\"InfiniteBuffer.java\").toString());\n+        checkExit(Exit.OK);\n+    }\n+\n+    \/*\n+     * 8.4.3.1. abstract Methods\n+     *\/\n+    @Test\n+    public void abstractOverridesConcrete(Path base) throws Exception {\n+        var src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src,\n+                \"public class A { public void m() {} }\",\n+                \"public abstract class B extends A { public abstract void m(); }\");\n+        javadoc(\"-d\", base.resolve(\"out\").toString(),\n+                \"-sourcepath\", src.toString(),\n+                \"-package\",\n+                \"--no-platform-links\",\n+                src.resolve(\"A.java\").toString(),\n+                src.resolve(\"B.java\").toString());\n+        checkExit(Exit.OK);\n+    }\n+\n+    \/*\n+     * 9.4.1. Inheritance and Overriding\n+     *\/\n+    @Test\n+    public void inheritOverridden(Path base) throws Exception {\n+        var src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src, \"\"\"\n+                interface Top {\n+                    default String name() { return \"unnamed\"; }\n+                }\"\"\", \"\"\"\n+                interface Left extends Top {\n+                    default String name() { return getClass().getName(); }\n+                }\"\"\", \"\"\"\n+                interface Right extends Top {}\n+                \"\"\", \"\"\"\n+                interface Bottom extends Left, Right {}\n+                \"\"\");\n+        javadoc(\"-d\", base.resolve(\"out\").toString(),\n+                \"-sourcepath\", src.toString(),\n+                \"-package\",\n+                \"--no-platform-links\",\n+                src.resolve(\"Top.java\").toString(),\n+                src.resolve(\"Left.java\").toString(),\n+                src.resolve(\"Right.java\").toString(),\n+                src.resolve(\"Bottom.java\").toString());\n+        checkExit(Exit.OK);\n+        checkOutput(\"Bottom.html\", true, \"\"\"\n+                <div class=\"inherited-list\">\n+                <h3 id=\"methods-inherited-from-class-Left\">Methods inherited from interface&nbsp;\\\n+                <a href=\"Left.html\" title=\"interface in Unnamed Package\">Left<\/a><\/h3>\n+                <code><a href=\"Left.html#name()\">name<\/a><\/code><\/div>\n+                \"\"\");\n+    }\n+\n+    \/\/ TODO: add a test signature-by-signature basis\n+    \/\/ TODO: add a test for an abstract class to inherit from an interface and an abstract superclass\n+}\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testMethodMembers\/TestMethodMembers.java","additions":366,"deletions":0,"binary":false,"changes":366,"status":"added"},{"patch":"@@ -134,2 +134,2 @@\n-        checkOutput(\"pkg2\/C.html\", false,\n-                \/\/Generic interface method test.\n+        checkOutput(\"pkg2\/C.html\", true,\n+                \/\/Inherit a comment.\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testPrivateClasses\/TestPrivateClasses.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8025091 8198890\n+ * @bug 8025091 8198890 8304135\n@@ -312,2 +312,2 @@\n-                \"public\", \"void\", \"method\", \"See Also:\", \"sub()\", \"sub1()\",\n-                \"public\", \"void\", \"m\", \"Method in C. See\", \"I.length()\"\n+                \"public\", \"void\", \"method\", \"See Also:\", \"href=\\\"#sub()\", \"href=\\\"#sub1()\",\n+                \"public\", \"void\", \"m\", \"Method in C. See\", \"href=\\\"#length()\"\n@@ -421,3 +421,5 @@\n-        checkOutput(\"p\/C.html\", false,\n-                \"Overrides\",\n-                \"Methods declared in class p\");\n+        checkOutput(\"p\/C.html\", false, \"\"\"\n+                <dl class=\"notes\">\n+                <dt>Overrides:<\/dt>\n+                <dd><code><a href=\"B.html\"\"\", \"\"\"\n+                Methods declared in class p\"\"\");\n@@ -434,3 +436,6 @@\n-                \"Description copied from class:\",\n-                \"Overrides\",\n-                \"Methods declared in class p\");\n+                \"\"\"\n+                Description copied from class:\"\"\", \"\"\"\n+                <dl class=\"notes\">\n+                <dt>Overrides:<\/dt>\n+                <dd><code><a href=\"B.html\"\"\", \"\"\"\n+                Methods declared in class p\"\"\");\n@@ -447,3 +452,6 @@\n-                \"Description copied from class:\",\n-                \"Overrides\",\n-                \"Methods declared in class p\");\n+                \"\"\"\n+                Description copied from class:\"\"\", \"\"\"\n+                <dl class=\"notes\">\n+                <dt>Overrides:<\/dt>\n+                <dd><code><a href=\"B.html\"\"\", \"\"\"\n+                Methods declared in class p\"\"\");\n@@ -481,3 +489,5 @@\n-        checkOutput(\"p\/C.html\", false,\n-                \"Overrides\",\n-                \"Methods declared in class p\");\n+        checkOutput(\"p\/C.html\", false, \"\"\"\n+                <dl class=\"notes\">\n+                <dt>Overrides:<\/dt>\n+                <dd><code><a href=\"B.html\"\"\", \"\"\"\n+                Methods declared in class p\"\"\");\n@@ -493,4 +503,6 @@\n-        checkOutput(\"p\/D.html\", false,\n-                \"Description copied from class:\",\n-                \"Overrides\",\n-                \"Methods declared in class p\");\n+        checkOutput(\"p\/D.html\", false, \"\"\"\n+                Description copied from class:\"\"\", \"\"\"\n+                <dl class=\"notes\">\n+                <dt>Overrides:<\/dt>\n+                <dd><code><a href=\"B.html\"\"\", \"\"\"\n+                Methods declared in class p\"\"\");\n@@ -506,4 +518,7 @@\n-        checkOutput(\"p\/E.html\", false,\n-                \"Description copied from class:\",\n-                \"Overrides\",\n-                \"Methods declared in class p\");\n+        checkOutput(\"p\/E.html\", false, \"\"\"\n+                <span class=\"description-from-type-label\">Description copied from class:&nbsp;\\\n+                <code><a href=\"B.html\"\"\", \"\"\"\n+                <dl class=\"notes\">\n+                <dt>Overrides:<\/dt>\n+                <dd><code><a href=\"B.html\"\"\", \"\"\"\n+                Methods declared in class p\"\"\");\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testVisibleMembers\/TestVisibleMembers.java","additions":39,"deletions":24,"binary":false,"changes":63,"status":"modified"}]}