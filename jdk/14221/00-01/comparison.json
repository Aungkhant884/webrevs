{"files":[{"patch":"@@ -90,1 +90,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.util.VisibleMemberTable;\n@@ -563,1 +562,1 @@\n-            var overriddenMethod = Optional.<VisibleMemberTable.OverrideSequence>empty();\n+            var overriddenMethod = Optional.<ExecutableElement>empty();\n@@ -565,32 +564,1 @@\n-                VisibleMemberTable vmt = configuration.getVisibleMemberTable(containing);\n-                \/\/ Find the type whose page documents the method in the\n-                \/\/ \"Method Details\" section, to build the link to the method.\n-                var sequence = vmt.overrideAt((ExecutableElement) refMem);\n-                \/\/ 1. Let's find the most specific non-simple override: this is\n-                \/\/    the type element whose comment text is going to be used on\n-                \/\/    in \"Method Details\" for the method.\n-                \/\/\n-                \/\/    For that, while override is simple, decrease the specificity.\n-                while (sequence.isSimpleOverride()\n-                        && sequence.hasLessSpecific()) {\n-                    sequence = sequence.lessSpecific();\n-                }\n-                \/\/ there's always a non-simple override in a sequence: the least\n-                \/\/ specific method, which could also be the most specific, if\n-                \/\/ the sequence is trivial\n-                assert !sequence.isSimpleOverride() : sequence;\n-                \/\/ 2. The method we've just found might not be documentable in its\n-                \/\/    enclosing type element, so we need to find the first MORE specific\n-                \/\/    method which is going to \"inherit\" that found method documentation\n-                \/\/    and host\/display it on its enclosing type element page.\n-                \/\/\n-                \/\/    For that, go back: while override is non-documentable,\n-                \/\/    increase the specificity.\n-                while (utils.isUndocumentedEnclosure((TypeElement) sequence.getEnclosingType().asElement())\n-                        && sequence.hasMoreSpecific()) {\n-                    sequence = sequence.moreSpecific();\n-                }\n-                \/\/ 3. Have we been able to find such a method?\n-                if (!utils.isUndocumentedEnclosure((TypeElement) sequence.getEnclosingType().asElement()))\n-                    overriddenMethod = Optional.of(sequence);\n-\n+                overriddenMethod = getActualMethod((ExecutableElement) refMem);\n@@ -598,1 +566,1 @@\n-                    containing = utils.getEnclosingTypeElement(overriddenMethod.get().getMethod());\n+                    containing = utils.getEnclosingTypeElement(overriddenMethod.get());\n@@ -631,1 +599,1 @@\n-                    refMem = overriddenMethod.get().getMethod();\n+                    refMem = overriddenMethod.get();\n@@ -642,0 +610,47 @@\n+    \/*\n+     * Given a method, returns the actual method to hyperlink to; might return\n+     * the same method if that method can be hyperlinked to directly or an\n+     * empty optional if that method is not documented anywhere and thus cannot\n+     * be hyperlinked to.\n+     *\n+     * Why is this needed? Depending on configuration, a declared method does\n+     * not always result in a corresponding \"Method Details\" entry, which we\n+     * could link to. To not produce broken links (i.e. links that lead\n+     * nowhere), we need to find the method that is a substitute for the\n+     * given method.\n+     *\/\n+    public Optional<ExecutableElement> getActualMethod(ExecutableElement method) {\n+        if (method.getKind() != ElementKind.METHOD)\n+            throw new IllegalArgumentException(String.valueOf(method.getKind()));\n+\n+        var sequence = configuration.getVisibleMemberTable((TypeElement) method.getEnclosingElement())\n+                .overrideAt(method);\n+        \/\/ 1. Let's find the most specific non-simple override: this is\n+        \/\/    the type element whose comment text is going to be used on\n+        \/\/    in \"Method Details\" for the method.\n+        \/\/\n+        \/\/    For that, while override is simple, decrease the specificity.\n+        while (sequence.isSimpleOverride()\n+                && sequence.hasLessSpecific()) {\n+            sequence = sequence.lessSpecific();\n+        }\n+        \/\/ Note: there's always a non-simple override in a sequence: the least\n+        \/\/ specific method (which could also be the most specific, if the\n+        \/\/ sequence trivially consists of a single method).\n+        assert !sequence.isSimpleOverride() : sequence;\n+        \/\/ 2. The method we've just found might not be documentable in its\n+        \/\/    enclosing type element, so we need to find the first MORE specific\n+        \/\/    method which is going to \"inherit\" that found method documentation\n+        \/\/    and host\/display it on its enclosing type element page.\n+        \/\/\n+        \/\/    For that, go back: while override is non-documentable,\n+        \/\/    increase the specificity.\n+        while (utils.isUndocumentedEnclosure((TypeElement) sequence.getEnclosingType().asElement())\n+                && sequence.hasMoreSpecific()) {\n+            sequence = sequence.moreSpecific();\n+        }\n+        \/\/ 3. Have we been able to find such a method?\n+        return utils.isUndocumentedEnclosure((TypeElement) sequence.getEnclosingType().asElement())\n+                ? Optional.empty() : Optional.of(sequence.getMethod());\n+    }\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/TagletWriterImpl.java","additions":51,"deletions":36,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -51,0 +51,1 @@\n+import java.util.Comparator;\n@@ -298,3 +299,2 @@\n-     * class or interface. The order of methods in the sequence is the\n-     * following order of members discovery in supertypes: depth-first,\n-     * preferring classes to interfaces.\n+     * class or interface. The order of methods in the sequence is that of\n+     * the comment search algorithm.\n@@ -306,12 +306,0 @@\n-     * Example 1\n-     * =========\n-     *\n-     *     public class A implements X { }\n-     *     public class B extends A implements Y { }\n-     *\n-     * Example 2\n-     * =========\n-     *\n-     *     public interface X { }\n-     *     public interface Y extends X { }\n-     *\n@@ -893,0 +881,11 @@\n+\n+        \/\/ impose an order\n+        var order = createSupertypeOrderMap(te);\n+        var copyList = new ArrayList<>(rawSequence);\n+        copyList.sort(Comparator.comparingInt(o -> {\n+            assert order.containsKey(o.enclosing.asElement()) :\n+                    diagnosticDescriptionOf(o.enclosing.asElement()) + \"in: \"\n+                            + order.keySet().stream().map(VisibleMemberTable::diagnosticDescriptionOf);\n+            return order.get(o.enclosing.asElement());\n+        }));\n+        rawSequence = com.sun.tools.javac.util.List.from(copyList);\n@@ -897,5 +896,0 @@\n-\/\/        \/\/ impose an order\n-\/\/        var order = createSupertypeOrderMap(te);\n-\/\/        var copyList = new ArrayList<>(rawSequence);\n-\/\/        copyList.sort(Comparator.comparingInt(o -> order.get(o.enclosing.asElement())));\n-\/\/        rawSequence = com.sun.tools.javac.util.List.from(copyList);\n@@ -942,0 +936,64 @@\n+    private Map<TypeElement, Integer> createSupertypeOrderMap(TypeElement e) {\n+        \/\/ replicate legacy order\n+        var m = new HashMap<TypeElement, Integer>();\n+        if (e.getKind().isClass()) {\n+            \/\/ ascend by superclasses\n+            var c = e;\n+            while (true) {\n+                m.put(c, m.size());\n+                if (c.getSuperclass().getKind() == TypeKind.NONE)\n+                    break;\n+                c = (TypeElement) ((DeclaredType) c.getSuperclass()).asElement();\n+            }\n+        }\n+        if (e.getKind().isInterface()) {\n+            m.put(e, m.size());\n+        }\n+        var superinterfaces = getAllInterfaces(e);\n+        for (var s : superinterfaces) {\n+            TypeElement e1 = (TypeElement) ((DeclaredType) s).asElement();\n+            assert !m.containsKey(e1);\n+            m.put(e1, m.size());\n+        }\n+        \/\/ patch for interfaces\n+        if (e.getKind().isInterface()) {\n+            \/\/ java.lang.Object is the last supertype in a graph of supertypes\n+            \/\/ for an interface\n+            var prev = m.put(elements().getTypeElement(\"java.lang.Object\"), m.size());\n+            assert prev == null;\n+        }\n+        return m;\n+    }\n+\n+    public Set<TypeMirror> getAllInterfaces(TypeElement te) {\n+        Set<TypeMirror> results = new LinkedHashSet<>();\n+        addSuperInterfaces(te.asType(), results, new HashSet<>());\n+        return results;\n+    }\n+\n+    private void addSuperInterfaces(TypeMirror type, Set<TypeMirror> results, Set<Element> visited) {\n+        TypeMirror superType = null;\n+        for (TypeMirror t : types().directSupertypes(type)) {\n+            if (types().isSameType(t, utils.getObjectType()))\n+                continue;\n+            TypeElement e = asTypeElement(t);\n+            if (utils.isPlainInterface(e)) {\n+                if (!visited.add(e)) {\n+                    continue; \/\/ seen it before\n+                }\n+                results.add(t);\n+                addSuperInterfaces(t, results, visited);\n+            } else {\n+                \/\/ there can be at most one superclass and it is not null\n+                assert superType == null && t != null : superType;\n+                \/\/ Save the supertype for later.\n+                superType = t;\n+            }\n+        }\n+        \/\/ Collect the super-interfaces of the supertype.\n+        if (superType != null)\n+            addSuperInterfaces(superType, results, visited);\n+    }\n+\n+\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/VisibleMemberTable.java","additions":78,"deletions":20,"binary":false,"changes":98,"status":"modified"}]}