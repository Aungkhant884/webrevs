{"files":[{"patch":"@@ -622,1 +622,1 @@\n-    public Optional<ExecutableElement> getActualMethod(ExecutableElement method) {\n+    private Optional<ExecutableElement> getActualMethod(ExecutableElement method) {\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/TagletWriterImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -57,0 +57,1 @@\n+import java.util.LinkedList;\n@@ -884,2 +885,1 @@\n-        var copyList = new ArrayList<>(rawSequence);\n-        copyList.sort(Comparator.comparingInt(o -> {\n+        rawSequence.sort(Comparator.comparingInt(o -> {\n@@ -891,3 +891,2 @@\n-        rawSequence = com.sun.tools.javac.util.List.from(copyList);\n-        \/\/ Prepend the member from which the exploration started, unconditionally\n-        rawSequence = rawSequence.prepend(new OverrideData(\n+        \/\/ prepend the member from which the sequencing started, unconditionally\n+        rawSequence.add(0, new OverrideData(\n@@ -902,2 +901,3 @@\n-        \/\/ way _backwards_ to the most specific\n-        \/\/ member. Enter each member into a hash map as an entry point for\n+        \/\/ way _backwards_ to the most specific member.\n+        \/\/\n+        \/\/ Enter each member into a hash map as an entry point for\n@@ -905,0 +905,1 @@\n+        \/\/\n@@ -907,16 +908,17 @@\n-        var fixedSequence = com.sun.tools.javac.util.List.<OverrideData>nil();\n-        rawSequence = rawSequence.reverse();\n-        boolean simpleOverride = false;\n-        while (!rawSequence.isEmpty()) {\n-            var f = new OverrideData(rawSequence.head.enclosing, rawSequence.head.method(), simpleOverride);\n-            fixedSequence = fixedSequence.prepend(f);\n-            rawSequence = rawSequence.tail;\n-            if (!rawSequence.isEmpty()) {\n-                \/\/ Even with --override-methods=summary we want to include details of\n-                \/\/ overriding method if something noteworthy has been added or changed\n-                \/\/ in the local overriding method\n-                var enclosing = (TypeElement) rawSequence.head.method.getEnclosingElement();\n-                simpleOverride = isSimpleOverride(rawSequence.head.method)\n-                        && !utils.isUndocumentedEnclosure(enclosing)\n-                        && !overridingSignatureChanged(rawSequence.head.method, f.method);\n-            }\n+        var fixedSequence = new LinkedList<OverrideData>();\n+        \/\/ accessing that element through iterator.next() would be awkward\n+        \/\/ as it would move the iterator\n+        OverrideData next = null;\n+        for (var iterator = rawSequence.listIterator(rawSequence.size()); iterator.hasPrevious(); ) {\n+            var e = iterator.previous();\n+            \/\/ Even with --override-methods=summary we want to include details of\n+            \/\/ overriding method if something noteworthy has been added or changed\n+            \/\/ in the local overriding method\n+            var simpleOverride = next != null \/* the least significant element,\n+                                                 for which next == null, is always\n+                                                 a non-simple override *\/\n+                    && isSimpleOverride(e.method)\n+                    && !utils.isUndocumentedEnclosure((TypeElement) e.method.getEnclosingElement())\n+                    && !overridingSignatureChanged(e.method, next.method);\n+            fixedSequence.add(0, new OverrideData(e.enclosing, e.method(), simpleOverride));\n+            next = e;\n@@ -925,1 +927,1 @@\n-        var t = new OverrideSequence(fixedSequence, 0);\n+        var t = new OverrideSequence(List.copyOf(fixedSequence), 0);\n@@ -1000,2 +1002,2 @@\n-    private com.sun.tools.javac.util.List<OverrideData> findOverriddenBy(ExecutableElement m) {\n-        return findOverriddenBy(m, (DeclaredType) te.asType(), com.sun.tools.javac.util.List.nil(), new HashSet<>());\n+    private List<OverrideData> findOverriddenBy(ExecutableElement m) {\n+        return findOverriddenBy(m, (DeclaredType) te.asType(), new LinkedList<>(), new HashSet<>());\n@@ -1004,4 +1006,4 @@\n-    private com.sun.tools.javac.util.List<OverrideData> findOverriddenBy(ExecutableElement m,\n-                                                                         DeclaredType declaredType,\n-                                                                         com.sun.tools.javac.util.List<OverrideData> result,\n-                                                                         Set<ExecutableElement> foundOverriddenSoFar) {\n+    private List<OverrideData> findOverriddenBy(ExecutableElement m,\n+                                                DeclaredType declaredType,\n+                                                List<OverrideData> result,\n+                                                Set<ExecutableElement> foundOverriddenSoFar) {\n@@ -1015,1 +1017,1 @@\n-                    result = result.append(new OverrideData(toDeclaringType(s,\n+                    result.add(new OverrideData(toDeclaringType(s,\n@@ -1018,1 +1020,1 @@\n-            result = findOverriddenBy(m, s, result, foundOverriddenSoFar);\n+            findOverriddenBy(m, s, result, foundOverriddenSoFar);\n@@ -1026,1 +1028,23 @@\n-     * The correctness relies of no more than 1 parameterization from JLS. (TODO link the correct section)\n+     * Walks the supertype DAG searching for a declared type whose\n+     * corresponding type element is equal to the given type element.\n+     *\n+     * The correctness of this simple algorithm relies on the fact that\n+     * there's at most one parameterization of any given interface (this is not\n+     * an issue for classes given there's no multiple inheritance for them).\n+     *\n+     * 8.1.5. Superinterfaces:\n+     *\n+     *     A class may not declare a direct superclass type and a direct\n+     *     superinterface type, or two direct superinterface types, which are,\n+     *     or which have supertypes (4.10.2) which are, different\n+     *     parameterizations of the same generic interface (9.1.2), or a\n+     *     parameterization of a generic interface and a raw type naming that\n+     *     same generic interface. In the case of such a conflict,\n+     *     a compile-time error occurs.\n+     *\n+     * Put differently, type elements corresponding to the provided declared\n+     * supertype type mirrors are unique.\n+     *\n+     * If we understand that correctly, it means, for example, that among\n+     * supertypes there cannot be Set<Integer> and Set<Object>; there can\n+     * be at most at most one of those.\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/VisibleMemberTable.java","additions":57,"deletions":33,"binary":false,"changes":90,"status":"modified"}]}