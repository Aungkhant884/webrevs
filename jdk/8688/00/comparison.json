{"files":[{"patch":"@@ -544,1 +544,1 @@\n-    \/\/ set this to true if we find out later that it doesn't\n+    \/\/ set this to false if we find out later that it doesn't\n@@ -546,1 +546,1 @@\n-    private static volatile boolean transferToNotSupported;\n+    private static volatile boolean transferSupported = true;\n@@ -590,1 +590,1 @@\n-                transferToNotSupported = true;\n+                transferSupported = false;\n@@ -604,1 +604,1 @@\n-        if (transferToNotSupported)\n+        if (!transferSupported)\n@@ -649,3 +649,2 @@\n-    \/\/ transferToArbitraryChannel() and transferFromArbitraryChannel()\n-    \/\/ are faster for smaller transfers\n-    private static final long MAPPED_TRANSFER_THRESHOLD = 16L*1024L;\n+    \/\/ transferToArbitraryChannel() is faster for smaller transfers\n+    private static final long TRUSTED_TRANSFER_THRESHOLD = 16L*1024L;\n@@ -660,1 +659,1 @@\n-        if (count < MAPPED_TRANSFER_THRESHOLD)\n+        if (count < TRUSTED_TRANSFER_THRESHOLD)\n@@ -785,51 +784,0 @@\n-    \/\/ Assume at first that the underlying kernel supports copy_file_range();\n-    \/\/ set this to true if we find out later that it doesn't\n-    \/\/\n-    private static volatile boolean transferFromNotSupported;\n-\n-    private long transferFromDirectlyInternal(FileDescriptor srcFD,\n-                                              long position, long count)\n-        throws IOException\n-    {\n-        long n = -1;\n-        int ti = -1;\n-        try {\n-            beginBlocking();\n-            ti = threads.add();\n-            if (!isOpen())\n-                return -1;\n-            do {\n-                long comp = Blocker.begin();\n-                try {\n-                    n = transferFrom0(srcFD, fd, position, count);\n-                } finally {\n-                    Blocker.end(comp);\n-                }\n-            } while ((n == IOStatus.INTERRUPTED) && isOpen());\n-            if (n == IOStatus.UNSUPPORTED) {\n-                \/\/ Don't bother trying again\n-                transferFromNotSupported = true;\n-                return IOStatus.UNSUPPORTED;\n-            }\n-            return IOStatus.normalize(n);\n-        } finally {\n-            threads.remove(ti);\n-            end (n > -1);\n-        }\n-    }\n-\n-    private long transferFromDirectly(FileChannelImpl src,\n-                                      long position, long count)\n-        throws IOException\n-    {\n-        if (!src.readable)\n-            throw new NonReadableChannelException();\n-        if (transferFromNotSupported)\n-            return IOStatus.UNSUPPORTED;\n-        FileDescriptor srcFD = src.fd;\n-        if (srcFD == null)\n-            return IOStatus.UNSUPPORTED_CASE;\n-\n-        return transferFromDirectlyInternal(srcFD, position, count);\n-    }\n-\n@@ -842,3 +790,0 @@\n-        if (count < MAPPED_TRANSFER_THRESHOLD)\n-            return IOStatus.UNSUPPORTED_CASE;\n-\n@@ -934,4 +879,2 @@\n-            long n;\n-            if ((n = transferFromDirectly(fci, position, count)) >= 0)\n-                return n;\n-            if ((n = transferFromFileChannel(fci, position, count)) >= 0)\n+            long n = transferFromFileChannel(fci, position, count);\n+            if (n >= 0)\n@@ -1571,4 +1514,0 @@\n-    private static native long transferFrom0(FileDescriptor src,\n-                                             FileDescriptor dst,\n-                                             long position, long count);\n-\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/FileChannelImpl.java","additions":9,"deletions":70,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-#include <dlfcn.h>\n@@ -56,6 +55,0 @@\n-#if defined(__linux__)\n-typedef ssize_t copy_file_range_func(int, loff_t*, int, loff_t*, size_t,\n-                                     unsigned int);\n-static copy_file_range_func* my_copy_file_range_func = NULL;\n-#endif\n-\n@@ -67,4 +60,0 @@\n-#if defined(__linux__)\n-    my_copy_file_range_func =\n-        (copy_file_range_func*) dlsym(RTLD_DEFAULT, \"copy_file_range\");\n-#endif\n@@ -266,32 +255,0 @@\n-JNIEXPORT jlong JNICALL\n-Java_sun_nio_ch_FileChannelImpl_transferFrom0(JNIEnv *env, jobject this,\n-                                              jobject srcFDO, jobject dstFDO,\n-                                              jlong position, jlong count)\n-{\n-#if defined(__linux__)\n-    if (my_copy_file_range_func == NULL)\n-        return IOS_UNSUPPORTED;\n-\n-    jint srcFD = fdval(env, srcFDO);\n-    jint dstFD = fdval(env, dstFDO);\n-\n-    off64_t offset = (off64_t)position;\n-    jlong n = my_copy_file_range_func(srcFD, NULL, dstFD, &offset, count, 0);\n-    if (n < 0) {\n-        if (errno == EAGAIN)\n-            return IOS_UNAVAILABLE;\n-        if ((errno == EINVAL || errno == EXDEV) && ((ssize_t)count >= 0))\n-            return IOS_UNSUPPORTED_CASE;\n-        if (errno == EINTR) {\n-            return IOS_INTERRUPTED;\n-        }\n-        JNU_ThrowIOExceptionWithLastError(env, \"Transfer failed\");\n-        return IOS_THROWN;\n-    }\n-    return n;\n-#else\n-    return IOS_UNSUPPORTED;\n-#endif\n-}\n-\n-\n","filename":"src\/java.base\/unix\/native\/libnio\/ch\/FileChannelImpl.c","additions":0,"deletions":43,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -196,7 +196,0 @@\n-JNIEXPORT jlong JNICALL\n-Java_sun_nio_ch_FileChannelImpl_transferFrom0(JNIEnv *env, jobject this,\n-                                              jobject srcFDO, jobject dstFDO,\n-                                              jlong position, jlong count)\n-{\n-    return IOS_UNSUPPORTED;\n-}\n","filename":"src\/java.base\/windows\/native\/libnio\/ch\/FileChannelImpl.c","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 4708120 8274113\n+ * @bug 4708120\n@@ -471,10 +471,4 @@\n-        long position = off;\n-        long count = len;\n-        while (count > 0) {\n-            int n = (int)fc.transferFrom(src.channel(), position, count);\n-            if (n < 0 || n > count)\n-                throw new Failure(\"Incorrect transfer length n = : \" + n\n-                                  + \" (expected 0 <= n <= \" + len + \")\");\n-            position += n;\n-            count -= n;\n-        }\n+        int n = (int)fc.transferFrom(src.channel(), off, len);\n+        if (n != len)\n+            throw new Failure(\"Incorrect transfer length: \" + n\n+                              + \" (expected \" + len + \")\");\n","filename":"test\/jdk\/java\/nio\/channels\/FileChannel\/Transfers.java","additions":5,"deletions":11,"binary":false,"changes":16,"status":"modified"}]}