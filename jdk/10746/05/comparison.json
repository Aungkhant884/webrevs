{"files":[{"patch":"@@ -801,2 +801,2 @@\n-    @Override\n-    public Content throwsTagOutput(Element element, ThrowsTree throwsTag, TypeMirror substituteType) {\n+    @Deprecated(forRemoval = true)\n+    private Content throwsTagOutput(Element element, ThrowsTree throwsTag, TypeMirror substituteType) {\n@@ -808,1 +808,1 @@\n-           excName = htmlWriter.getLink(new HtmlLinkInfo(configuration, HtmlLinkInfo.Kind.MEMBER,\n+            excName = htmlWriter.getLink(new HtmlLinkInfo(configuration, HtmlLinkInfo.Kind.MEMBER,\n@@ -811,1 +811,1 @@\n-            excName = RawHtml.of(throwsTag.getExceptionName().toString());\n+            excName = Text.of(throwsTag.getExceptionName().toString());\n@@ -831,3 +831,10 @@\n-    public Content throwsTagOutput(TypeMirror throwsType) {\n-        return HtmlTree.DD(HtmlTree.CODE(htmlWriter.getLink(\n-                new HtmlLinkInfo(configuration, HtmlLinkInfo.Kind.MEMBER, throwsType))));\n+    public Content throwsTagOutput(TypeMirror throwsType, Optional<Content> content) {\n+        var linkInfo = new HtmlLinkInfo(configuration, HtmlLinkInfo.Kind.MEMBER, throwsType);\n+        linkInfo.excludeTypeBounds = true;\n+        var link = htmlWriter.getLink(linkInfo);\n+        var concat = new ContentBuilder(HtmlTree.CODE(link));\n+        if (content.isPresent()) {\n+            concat.add(\" - \");\n+            concat.add(content.get());\n+        }\n+        return HtmlTree.DD(concat);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/TagletWriterImpl.java","additions":14,"deletions":7,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -109,0 +109,2 @@\n+doclet.throws.reference_not_found=cannot find exception type by name\n+doclet.throws.reference_bad_type=type found is not of exception type: {0}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/resources\/standard.properties","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import java.util.Optional;\n@@ -53,0 +54,1 @@\n+import jdk.javadoc.internal.doclets.toolkit.util.DocFinder.Result;\n@@ -263,11 +265,11 @@\n-                List<? extends DocTree> firstSentenceTags = utils.getFirstSentenceTrees(member);\n-                if (utils.isMethod(member) && firstSentenceTags.isEmpty()) {\n-                    \/\/Inherit comments from overridden or implemented method if\n-                    \/\/necessary.\n-                    DocFinder.Output inheritedDoc =\n-                            DocFinder.search(configuration,\n-                                    new DocFinder.Input(utils, member));\n-                    if (inheritedDoc.holder != null\n-                            && !utils.getFirstSentenceTrees(inheritedDoc.holder).isEmpty()) {\n-                        firstSentenceTags = utils.getFirstSentenceTrees(inheritedDoc.holder);\n-                    }\n+                if (utils.isMethod(member)) {\n+                    var docFinder = utils.docFinder();\n+                    Optional<List<? extends DocTree>> r = docFinder.search((ExecutableElement) member, (m -> {\n+                        var firstSentenceTrees = utils.getFirstSentenceTrees(m);\n+                        Optional<List<? extends DocTree>> optional = firstSentenceTrees.isEmpty() ? Optional.empty() : Optional.of(firstSentenceTrees);\n+                        return Result.fromOptional(optional);\n+                    })).toOptional();\n+                    \/\/ The fact that we use `member` for possibly unrelated tags is suspicious\n+                    writer.addMemberSummary(typeElement, member, r.orElse(List.of()));\n+                } else {\n+                    writer.addMemberSummary(typeElement, member, utils.getFirstSentenceTrees(member));\n@@ -275,1 +277,0 @@\n-                writer.addMemberSummary(typeElement, member, firstSentenceTags);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/builders\/MemberSummaryBuilder.java","additions":13,"deletions":12,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import com.sun.source.doctree.DocTree;\n@@ -40,0 +41,1 @@\n+import jdk.javadoc.internal.doclets.toolkit.util.DocFinder.Result;\n@@ -168,7 +170,4 @@\n-            ExecutableElement method = currentMethod;\n-            if (utils.getFullBody(currentMethod).isEmpty()) {\n-                DocFinder.Output docs = DocFinder.search(configuration,\n-                        new DocFinder.Input(utils, currentMethod));\n-                if (!docs.inlineTags.isEmpty())\n-                    method = (ExecutableElement) docs.holder;\n-            }\n+            var docFinder = utils.docFinder();\n+            Optional<ExecutableElement> r = docFinder.search(currentMethod,\n+                    m -> Result.fromOptional(utils.getFullBody(m).isEmpty() ? Optional.empty() : Optional.of(m))).toOptional();\n+            ExecutableElement method = r.orElse(currentMethod);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/builders\/MethodBuilder.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -121,0 +121,3 @@\n+doclet.inheritDocNoDoc=overridden methods do not document exception type {0}\n+doclet.throwsInheritDocUnsupported=@inheritDoc for exception-type type parameters not declared by a method is unsupported; \\\n+  document such exception types directly\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/resources\/doclets.properties","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+import java.util.List;\n+import java.util.Optional;\n@@ -41,0 +43,1 @@\n+import jdk.javadoc.internal.doclets.toolkit.util.DocFinder.Result;\n@@ -64,1 +67,1 @@\n-     * @param e the {@link Element} that we are documenting.\n+     * @param method the method that we are documenting.\n@@ -69,1 +72,1 @@\n-                                                   Element e,\n+                                                   ExecutableElement method,\n@@ -76,1 +79,1 @@\n-        CommentHelper ch = utils.getCommentHelper(e);\n+        CommentHelper ch = utils.getCommentHelper(method);\n@@ -79,3 +82,18 @@\n-        Taglet taglet = holderTag.getKind() == DocTree.Kind.DOC_COMMENT\n-                ? null\n-                : configuration.tagletManager.getTaglet(ch.getTagName(holderTag));\n+        if (holderTag.getKind() == DocTree.Kind.DOC_COMMENT) {\n+            try {\n+                var docFinder = utils.docFinder();\n+                Optional<Documentation> r = docFinder.trySearch(method,\n+                        m -> Result.fromOptional(extractMainDescription(m, isFirstSentence, utils))).toOptional();\n+                if (r.isPresent()) {\n+                    replacement = writer.commentTagsToOutput(r.get().method, null,\n+                            r.get().mainDescription, isFirstSentence);\n+                }\n+            } catch (DocFinder.NoOverriddenMethodsFound e) {\n+                String signature = utils.getSimpleName(method)\n+                        + utils.flatSignature(method, writer.getCurrentPageElement());\n+                messages.warning(method, \"doclet.noInheritedDoc\", signature);\n+            }\n+            return replacement;\n+        }\n+\n+        Taglet taglet = configuration.tagletManager.getTaglet(ch.getTagName(holderTag));\n@@ -87,7 +105,6 @@\n-        var input = new DocFinder.Input(utils, e, (InheritableTaglet) taglet,\n-                new DocFinder.DocTreeInfo(holderTag, e), isFirstSentence, true);\n-        DocFinder.Output inheritedDoc = DocFinder.search(configuration, input);\n-        if (inheritedDoc.isValidInheritDocTag) {\n-            if (!inheritedDoc.inlineTags.isEmpty()) {\n-                replacement = writer.commentTagsToOutput(inheritedDoc.holder, inheritedDoc.holderTag,\n-                        inheritedDoc.inlineTags, isFirstSentence);\n+\n+        InheritableTaglet.Output inheritedDoc = ((InheritableTaglet) taglet).inherit(method, holderTag, isFirstSentence, configuration);\n+        if (inheritedDoc.isValidInheritDocTag()) {\n+            if (!inheritedDoc.inlineTags().isEmpty()) {\n+                replacement = writer.commentTagsToOutput(inheritedDoc.holder(), inheritedDoc.holderTag(),\n+                        inheritedDoc.inlineTags(), isFirstSentence);\n@@ -96,5 +113,3 @@\n-            String signature = utils.getSimpleName(e) +\n-                    ((utils.isExecutableElement(e))\n-                            ? utils.flatSignature((ExecutableElement) e, writer.getCurrentPageElement())\n-                            : e.toString());\n-            messages.warning(e, \"doclet.noInheritedDoc\", signature);\n+            String signature = utils.getSimpleName(method)\n+                    + utils.flatSignature(method, writer.getCurrentPageElement());\n+            messages.warning(method, \"doclet.noInheritedDoc\", signature);\n@@ -105,0 +120,11 @@\n+    private record Documentation(List<? extends DocTree> mainDescription, ExecutableElement method) { }\n+\n+    private static Optional<Documentation> extractMainDescription(ExecutableElement m,\n+                                                                boolean extractFirstSentenceOnly,\n+                                                                Utils utils) {\n+        List<? extends DocTree> docTrees = extractFirstSentenceOnly\n+                ? utils.getFirstSentenceTrees(m)\n+                : utils.getFullBody(m);\n+        return docTrees.isEmpty() ? Optional.empty() : Optional.of(new Documentation(docTrees, m));\n+    }\n+\n@@ -110,1 +136,1 @@\n-        return retrieveInheritedDocumentation(tagletWriter, e, inheritDoc, tagletWriter.isFirstSentence);\n+        return retrieveInheritedDocumentation(tagletWriter, (ExecutableElement) e, inheritDoc, tagletWriter.isFirstSentence);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/InheritDocTaglet.java","additions":45,"deletions":19,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -28,1 +28,7 @@\n-import jdk.javadoc.internal.doclets.toolkit.util.DocFinder;\n+\n+import java.util.List;\n+\n+import javax.lang.model.element.Element;\n+\n+import com.sun.source.doctree.DocTree;\n+import jdk.javadoc.internal.doclets.toolkit.BaseConfiguration;\n@@ -36,9 +42,7 @@\n-    \/**\n-     * Given an {@link jdk.javadoc.internal.doclets.toolkit.util.DocFinder.Output}\n-     * object, set its values with the appropriate information to inherit\n-     * documentation.\n-     *\n-     * @param input  the input for documentation search\n-     * @param output the output for documentation search\n-     *\/\n-    void inherit(DocFinder.Input input, DocFinder.Output output);\n+    Output inherit(Element owner, DocTree tag, boolean isFirstSentence, BaseConfiguration configuration);\n+\n+    record Output(DocTree holderTag,\n+                  Element holder,\n+                  List<? extends DocTree> inlineTags,\n+                  boolean isValidInheritDocTag) {\n+    }\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/InheritableTaglet.java","additions":14,"deletions":10,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import javax.lang.model.element.ElementKind;\n@@ -37,0 +38,1 @@\n+import jdk.javadoc.internal.doclets.toolkit.BaseConfiguration;\n@@ -41,1 +43,1 @@\n-import jdk.javadoc.internal.doclets.toolkit.util.DocFinder.Input;\n+import jdk.javadoc.internal.doclets.toolkit.util.DocFinder.Result;\n@@ -65,21 +67,11 @@\n-    public void inherit(DocFinder.Input input, DocFinder.Output output) {\n-        Utils utils = input.utils;\n-        if (input.tagId == null) {\n-            var tag = (ParamTree) input.docTreeInfo.docTree();\n-            input.isTypeVariableParamTag = tag.isTypeParameter();\n-            ExecutableElement ee = (ExecutableElement) input.docTreeInfo.element();\n-            CommentHelper ch = utils.getCommentHelper(ee);\n-            List<? extends Element> parameters = input.isTypeVariableParamTag\n-                    ? ee.getTypeParameters()\n-                    : ee.getParameters();\n-            String target = ch.getParameterName(tag);\n-            for (int i = 0; i < parameters.size(); i++) {\n-                Element e = parameters.get(i);\n-                String candidate = input.isTypeVariableParamTag\n-                        ? utils.getTypeName(e.asType(), false)\n-                        : utils.getSimpleName(e);\n-                if (candidate.equals(target)) {\n-                    input.tagId = Integer.toString(i);\n-                    break;\n-                }\n-            }\n+    public Output inherit(Element owner, DocTree tag, boolean isFirstSentence, BaseConfiguration configuration) {\n+        assert owner.getKind() == ElementKind.METHOD;\n+        assert tag.getKind() == DocTree.Kind.PARAM;\n+        var method = (ExecutableElement) owner;\n+        var param = (ParamTree) tag;\n+        \/\/ find the position of an owner parameter described by the given tag\n+        List<? extends Element> parameterElements;\n+        if (param.isTypeParameter()) {\n+            parameterElements = method.getTypeParameters();\n+        } else {\n+            parameterElements = method.getParameters();\n@@ -87,20 +79,15 @@\n-        if (input.tagId == null)\n-            return;\n-        int position = Integer.parseInt(input.tagId);\n-        ExecutableElement ee = (ExecutableElement) input.element;\n-        CommentHelper ch = utils.getCommentHelper(ee);\n-        List<ParamTree> tags = input.isTypeVariableParamTag\n-                ? utils.getTypeParamTrees(ee)\n-                : utils.getParamTrees(ee);\n-        List<? extends Element> parameters = input.isTypeVariableParamTag\n-                ? ee.getTypeParameters()\n-                : ee.getParameters();\n-        Map<String, Integer> positionOfName = mapNameToPosition(utils, parameters);\n-        for (ParamTree tag : tags) {\n-            String paramName = ch.getParameterName(tag);\n-            if (positionOfName.containsKey(paramName) && positionOfName.get(paramName).equals(position)) {\n-                output.holder = input.element;\n-                output.holderTag = tag;\n-                output.inlineTags = ch.getBody(tag);\n-                return;\n-            }\n+        Map<String, Integer> stringIntegerMap = mapNameToPosition(configuration.utils, parameterElements);\n+        CommentHelper ch = configuration.utils.getCommentHelper(owner);\n+        Integer position = stringIntegerMap.get(ch.getParameterName(param));\n+        if (position == null) {\n+            return new Output(null, null, List.of(), true); \/\/ remodel, because it's an error\n+        }\n+        \/\/ try to inherit description of the respective parameter in an overridden method\n+        try {\n+            var docFinder = configuration.utils.docFinder();\n+            var r = docFinder.trySearch(method, m -> Result.fromOptional(extract(configuration.utils, m, position, param.isTypeParameter())))\n+                    .toOptional();\n+            return r.map(result -> new Output(result.paramTree, result.method, result.paramTree.getDescription(), true))\n+                    .orElseGet(() -> new Output(null, null, List.of(), true));\n+        } catch (DocFinder.NoOverriddenMethodsFound e) {\n+            return new Output(null, null, List.of(), false);\n@@ -242,4 +229,3 @@\n-        Input input = new DocFinder.Input(writer.configuration().utils, holder, this,\n-                Integer.toString(position), kind == ParamKind.TYPE_PARAMETER);\n-        DocFinder.Output inheritedDoc = DocFinder.search(writer.configuration(), input);\n-        if (!inheritedDoc.inlineTags.isEmpty()) {\n+        var r = utils.docFinder().search((ExecutableElement) holder, m -> Result.fromOptional(extract(utils, m, position, kind == ParamKind.TYPE_PARAMETER)))\n+                .toOptional();\n+        if (r.isPresent()) {\n@@ -249,3 +235,2 @@\n-            Content content = convertParam(inheritedDoc.holder, kind, writer,\n-                    (ParamTree) inheritedDoc.holderTag,\n-                    name, isFirst);\n+            Content content = convertParam(r.get().method, kind, writer,\n+                    r.get().paramTree, name, isFirst);\n@@ -257,0 +242,15 @@\n+    private record Documentation(ParamTree paramTree, ExecutableElement method) { }\n+\n+    private static Optional<Documentation> extract(Utils utils, ExecutableElement method, Integer position, boolean typeParam) {\n+        var ch = utils.getCommentHelper(method);\n+        List<ParamTree> tags = typeParam\n+                ? utils.getTypeParamTrees(method)\n+                : utils.getParamTrees(method);\n+        List<? extends Element> parameters = typeParam\n+                ? method.getTypeParameters()\n+                : method.getParameters();\n+        var positionOfName = mapNameToPosition(utils, parameters);\n+        return tags.stream().filter(t -> position.equals(positionOfName.get(ch.getParameterName(t))))\n+                .map(t -> new Documentation(t, method)).findAny();\n+    }\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/ParamTaglet.java","additions":49,"deletions":49,"binary":false,"changes":98,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import java.util.ArrayList;\n@@ -31,0 +30,2 @@\n+import java.util.Optional;\n+import java.util.stream.Stream;\n@@ -33,0 +34,1 @@\n+import javax.lang.model.element.ElementKind;\n@@ -39,0 +41,1 @@\n+import jdk.javadoc.internal.doclets.toolkit.BaseConfiguration;\n@@ -41,1 +44,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.util.CommentHelper;\n@@ -43,1 +45,1 @@\n-import jdk.javadoc.internal.doclets.toolkit.util.DocFinder.Input;\n+import jdk.javadoc.internal.doclets.toolkit.util.DocFinder.Result;\n@@ -61,21 +63,8 @@\n-    public void inherit(DocFinder.Input input, DocFinder.Output output) {\n-        Utils utils = input.utils;\n-        CommentHelper ch = utils.getCommentHelper(input.element);\n-\n-        ReturnTree tag = null;\n-        List<? extends ReturnTree> tags = utils.getReturnTrees(input.element);\n-        if (!tags.isEmpty()) {\n-            tag = tags.get(0);\n-        } else {\n-            List<? extends DocTree> firstSentence = utils.getFirstSentenceTrees(input.element);\n-            if (firstSentence.size() == 1 && firstSentence.get(0).getKind() == DocTree.Kind.RETURN) {\n-                tag = (ReturnTree) firstSentence.get(0);\n-            }\n-        }\n-\n-        if (tag != null) {\n-            output.holder = input.element;\n-            output.holderTag = tag;\n-            output.inlineTags = input.isFirstSentence\n-                    ? ch.getFirstSentenceTrees(output.holderTag)\n-                    : ch.getDescription(output.holderTag);\n+    public Output inherit(Element owner, DocTree tag, boolean isFirstSentence, BaseConfiguration configuration) {\n+        try {\n+            var docFinder = configuration.utils.docFinder();\n+            var r = docFinder.trySearch((ExecutableElement) owner, m -> Result.fromOptional(extract(configuration.utils, m))).toOptional();\n+            return r.map(result -> new Output(result.returnTree, result.method, result.returnTree.getDescription(), true))\n+                    .orElseGet(() -> new Output(null, null, List.of(), true));\n+        } catch (DocFinder.NoOverriddenMethodsFound e) {\n+            return new Output(null, null, List.of(), false);\n@@ -92,0 +81,2 @@\n+        assert holder.getKind() == ElementKind.METHOD : holder.getKind();\n+        var method = (ExecutableElement) holder;\n@@ -96,2 +87,2 @@\n-        \/\/ Make sure we are not using @return tag on method with void return type.\n-        TypeMirror returnType = utils.getReturnType(writer.getCurrentPageElement(), (ExecutableElement) holder);\n+        \/\/ make sure we are not using @return on a method with the void return type\n+        TypeMirror returnType = utils.getReturnType(writer.getCurrentPageElement(), method);\n@@ -105,3 +96,1 @@\n-        if (!tags.isEmpty()) {\n-            return writer.returnTagOutput(holder, tags.get(0), false);\n-        }\n+        \/\/ TODO check for more than one @return\n@@ -109,5 +98,5 @@\n-        \/\/ Check for inline tag in first sentence.\n-        List<? extends DocTree> firstSentence = utils.getFirstSentenceTrees(holder);\n-        if (firstSentence.size() == 1 && firstSentence.get(0).getKind() == DocTree.Kind.RETURN) {\n-            return writer.returnTagOutput(holder, (ReturnTree) firstSentence.get(0), false);\n-        }\n+        var docFinder = utils.docFinder();\n+        return docFinder.search(method, m -> Result.fromOptional(extract(utils, m))).toOptional()\n+                .map(r -> writer.returnTagOutput(r.method, r.returnTree, false))\n+                .orElse(null);\n+    }\n@@ -115,7 +104,15 @@\n-        \/\/ Inherit @return tag if necessary.\n-        Input input = new DocFinder.Input(utils, holder, this);\n-        DocFinder.Output inheritedDoc = DocFinder.search(writer.configuration(), input);\n-        if (inheritedDoc.holderTag != null) {\n-            return writer.returnTagOutput(inheritedDoc.holder, (ReturnTree) inheritedDoc.holderTag, false);\n-        }\n-        return null;\n+    private record Documentation(ReturnTree returnTree, ExecutableElement method) { }\n+\n+    private static Optional<Documentation> extract(Utils utils, ExecutableElement method) {\n+        \/\/ TODO\n+        \/\/  Using getBlockTags(..., Kind.RETURN) for clarity. Since @return has become a bimodal tag,\n+        \/\/  Utils.getReturnTrees is now a misnomer: it returns only block returns, not all returns.\n+        \/\/  We could revisit this later.\n+        Stream<? extends ReturnTree> blockTags = utils.getBlockTags(method, DocTree.Kind.RETURN, ReturnTree.class).stream();\n+        Stream<? extends ReturnTree> mainDescriptionTags = utils.getFirstSentenceTrees(method).stream()\n+                .mapMulti((t, c) -> {\n+                    if (t.getKind() == DocTree.Kind.RETURN) c.accept((ReturnTree) t);\n+                });\n+        \/\/ this method should not check validity of @return tags, hence findAny and not findFirst or what have you\n+        return Stream.concat(blockTags, mainDescriptionTags)\n+                .map(t -> new Documentation(t, method)).findAny();\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/ReturnTaglet.java","additions":38,"deletions":41,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import java.util.Optional;\n@@ -32,0 +33,1 @@\n+import javax.lang.model.element.ExecutableElement;\n@@ -36,0 +38,1 @@\n+import jdk.javadoc.internal.doclets.toolkit.BaseConfiguration;\n@@ -37,3 +40,1 @@\n-import jdk.javadoc.internal.doclets.toolkit.util.CommentHelper;\n-import jdk.javadoc.internal.doclets.toolkit.util.DocFinder;\n-import jdk.javadoc.internal.doclets.toolkit.util.DocFinder.Input;\n+import jdk.javadoc.internal.doclets.toolkit.util.DocFinder.Result;\n@@ -52,10 +53,2 @@\n-    public void inherit(DocFinder.Input input, DocFinder.Output output) {\n-        List<? extends SeeTree> tags = input.utils.getSeeTrees(input.element);\n-        if (!tags.isEmpty()) {\n-            CommentHelper ch = input.utils.getCommentHelper(input.element);\n-            output.holder = input.element;\n-            output.holderTag = tags.get(0);\n-            output.inlineTags = input.isFirstSentence\n-                    ? ch.getFirstSentenceTrees(output.holderTag)\n-                    : ch.getReference(output.holderTag);\n-        }\n+    public Output inherit(Element owner, DocTree tag, boolean isFirstSentence, BaseConfiguration configuration) {\n+        throw new UnsupportedOperationException(\"Not yet implemented\");\n@@ -69,6 +62,8 @@\n-        if (tags.isEmpty() && utils.isMethod(holder)) {\n-            Input input = new DocFinder.Input(utils, holder, this);\n-            DocFinder.Output inheritedDoc = DocFinder.search(writer.configuration(), input);\n-            if (inheritedDoc.holder != null) {\n-                tags = utils.getSeeTrees(inheritedDoc.holder);\n-                e = inheritedDoc.holder;\n+        if (utils.isMethod(holder)) {\n+            var docFinder = utils.docFinder();\n+            Optional<Documentation> result = docFinder.search((ExecutableElement) holder,\n+                    m -> Result.fromOptional(extract(utils, m))).toOptional();\n+            if (result.isPresent()) {\n+                ExecutableElement m = result.get().method();\n+                tags = utils.getSeeTrees(m);\n+                e = m;\n@@ -79,0 +74,7 @@\n+\n+    private record Documentation(List<? extends SeeTree> seeTrees, ExecutableElement method) { }\n+\n+    private static Optional<Documentation> extract(Utils utils, ExecutableElement method) {\n+        List<? extends SeeTree> tags = utils.getSeeTrees(method);\n+        return tags.isEmpty() ? Optional.empty() : Optional.of(new Documentation(tags, method));\n+    }\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/SeeTaglet.java","additions":21,"deletions":19,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import java.util.Optional;\n@@ -33,0 +34,2 @@\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.ExecutableElement;\n@@ -37,0 +40,1 @@\n+import jdk.javadoc.internal.doclets.toolkit.BaseConfiguration;\n@@ -38,1 +42,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.util.CommentHelper;\n@@ -40,0 +43,1 @@\n+import jdk.javadoc.internal.doclets.toolkit.util.DocFinder.Result;\n@@ -162,9 +166,11 @@\n-    public void inherit(DocFinder.Input input, DocFinder.Output output) {\n-        List<? extends DocTree> tags = input.utils.getBlockTags(input.element, this);\n-        if (!tags.isEmpty()) {\n-            output.holder = input.element;\n-            output.holderTag = tags.get(0);\n-            CommentHelper ch = input.utils.getCommentHelper(output.holder);\n-            output.inlineTags = input.isFirstSentence\n-                    ? ch.getFirstSentenceTrees(output.holderTag)\n-                    : ch.getTags(output.holderTag);\n+    public Output inherit(Element owner, DocTree tag, boolean isFirstSentence, BaseConfiguration configuration) {\n+        assert owner.getKind() == ElementKind.METHOD;\n+        assert !isFirstSentence;\n+        try {\n+            var docFinder = configuration.utils.docFinder();\n+            var r = docFinder.trySearch((ExecutableElement) owner,\n+                    m -> Result.fromOptional(extractFirst(m, configuration.utils))).toOptional();\n+            return r.map(result -> new Output(result.tag, result.method, result.description, true))\n+                    .orElseGet(()->new Output(null, null, List.of(), true));\n+        } catch (DocFinder.NoOverriddenMethodsFound e) {\n+            return new Output(null, null, List.of(), false);\n@@ -174,0 +180,11 @@\n+    record Documentation(DocTree tag, List<? extends DocTree> description, ExecutableElement method) { }\n+\n+    private Optional<Documentation> extractFirst(ExecutableElement m, Utils utils) {\n+        List<? extends DocTree> tags = utils.getBlockTags(m, this);\n+        if (tags.isEmpty()) {\n+            return Optional.empty();\n+        }\n+        DocTree t = tags.get(0);\n+        return Optional.of(new Documentation(t, utils.getCommentHelper(m).getDescription(t), m));\n+    }\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/SimpleTaglet.java","additions":27,"deletions":10,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import java.util.Optional;\n@@ -31,0 +32,1 @@\n+import javax.lang.model.element.ExecutableElement;\n@@ -35,0 +37,1 @@\n+import jdk.javadoc.internal.doclets.toolkit.BaseConfiguration;\n@@ -36,3 +39,1 @@\n-import jdk.javadoc.internal.doclets.toolkit.util.CommentHelper;\n-import jdk.javadoc.internal.doclets.toolkit.util.DocFinder;\n-import jdk.javadoc.internal.doclets.toolkit.util.DocFinder.Input;\n+import jdk.javadoc.internal.doclets.toolkit.util.DocFinder.Result;\n@@ -51,10 +52,2 @@\n-    public void inherit(Input input, DocFinder.Output output) {\n-        List<? extends SpecTree> tags = input.utils.getSpecTrees(input.element);\n-        if (!tags.isEmpty()) {\n-            CommentHelper ch =  input.utils.getCommentHelper(input.element);\n-            output.holder = input.element;\n-            output.holderTag = tags.get(0);\n-            output.inlineTags = input.isFirstSentence\n-                    ? ch.getFirstSentenceTrees(output.holderTag)\n-                    : ch.getTags(output.holderTag);\n-        }\n+    public Output inherit(Element owner, DocTree tag, boolean isFirstSentence, BaseConfiguration configuration) {\n+        throw new UnsupportedOperationException(\"Not yet implemented\");\n@@ -68,6 +61,8 @@\n-        if (tags.isEmpty() && utils.isExecutableElement(holder)) {\n-            Input input = new Input(utils, holder, this);\n-            DocFinder.Output inheritedDoc = DocFinder.search(writer.configuration(), input);\n-            if (inheritedDoc.holder != null) {\n-                tags = utils.getSpecTrees(inheritedDoc.holder);\n-                e = inheritedDoc.holder;\n+        if (utils.isMethod(holder)) {\n+            var docFinder = utils.docFinder();\n+            Optional<Documentation> result = docFinder.search((ExecutableElement) holder,\n+                    m -> Result.fromOptional(extract(utils, m))).toOptional();\n+            if (result.isPresent()) {\n+                ExecutableElement m = result.get().method();\n+                tags = utils.getSpecTrees(m);\n+                e = m;\n@@ -78,0 +73,7 @@\n+\n+    private record Documentation(List<? extends SpecTree> seeTrees, ExecutableElement method) { }\n+\n+    private static Optional<Documentation> extract(Utils utils, ExecutableElement method) {\n+        List<? extends SpecTree> tags = utils.getSpecTrees(method);\n+        return tags.isEmpty() ? Optional.empty() : Optional.of(new Documentation(tags, method));\n+    }\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/SpecTaglet.java","additions":21,"deletions":19,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -601,1 +601,1 @@\n-        addStandardTaglet(new ThrowsTaglet(), EXCEPTION);\n+        addStandardTaglet(new ThrowsTaglet(configuration), EXCEPTION);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/TagletManager.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -226,11 +226,0 @@\n-    \/**\n-     * Returns the output for a {@code @throws} tag.\n-     *\n-     * @param element        The element that owns the doc comment\n-     * @param throwsTag      the throws tag\n-     * @param substituteType instantiated type of a generic type-variable, or null\n-     *\n-     * @return the output\n-     *\/\n-    protected abstract Content throwsTagOutput(Element element, ThrowsTree throwsTag, TypeMirror substituteType);\n-\n@@ -241,0 +230,1 @@\n+     * @param content    the optional content to add as a description\n@@ -244,1 +234,1 @@\n-    protected abstract Content throwsTagOutput(TypeMirror throwsType);\n+    protected abstract Content throwsTagOutput(TypeMirror throwsType, Optional<Content> content);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/TagletWriter.java","additions":2,"deletions":12,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import java.util.Collections;\n+import java.util.Arrays;\n@@ -32,1 +32,0 @@\n-import java.util.Iterator;\n@@ -34,0 +33,1 @@\n+import java.util.LinkedList;\n@@ -36,0 +36,1 @@\n+import java.util.Optional;\n@@ -41,0 +42,3 @@\n+import javax.lang.model.element.ModuleElement;\n+import javax.lang.model.element.PackageElement;\n+import javax.lang.model.element.QualifiedNameable;\n@@ -42,0 +46,1 @@\n+import javax.lang.model.element.TypeParameterElement;\n@@ -50,0 +55,2 @@\n+import jdk.javadoc.internal.doclets.formats.html.markup.ContentBuilder;\n+import jdk.javadoc.internal.doclets.toolkit.BaseConfiguration;\n@@ -52,0 +59,2 @@\n+import jdk.javadoc.internal.doclets.toolkit.util.DocFinder.Result;\n+import jdk.javadoc.internal.doclets.toolkit.util.Utils;\n@@ -54,2 +63,2 @@\n- * A taglet that processes {@link ThrowsTree}, which represents\n- * {@code @throws} and {@code @exception} tags.\n+ * A taglet that processes {@link ThrowsTree}, which represents {@code @throws}\n+ * and {@code @exception} tags, collectively referred to as exception tags.\n@@ -59,1 +68,90 @@\n-    public ThrowsTaglet() {\n+    \/*\n+     * Relevant bits from JLS\n+     * ======================\n+     *\n+     * This list is _incomplete_ because some parts cannot be summarized here\n+     * and require careful reading of JLS.\n+     *\n+     * 11.1.1 The Kinds of Exceptions\n+     *\n+     *   Throwable and all its subclasses are, collectively, the exception\n+     *   classes.\n+     *\n+     * 8.4.6 Method Throws\n+     *\n+     *   Throws:\n+     *     throws ExceptionTypeList\n+     *\n+     *   ExceptionTypeList:\n+     *     ExceptionType {, ExceptionType}\n+     *\n+     *   ExceptionType:\n+     *     ClassType\n+     *     TypeVariable\n+     *\n+     *   It is a compile-time error if an ExceptionType mentioned in a throws\n+     *   clause is not a subtype (4.10) of Throwable.\n+     *\n+     *   Type variables are allowed in a throws clause even though they are\n+     *   not allowed in a catch clause (14.20).\n+     *\n+     *   It is permitted but not required to mention unchecked exception\n+     *   classes (11.1.1) in a throws clause.\n+     *\n+     * 8.1.2 Generic Classes and Type Parameters\n+     *\n+     *   It is a compile-time error if a generic class is a direct or indirect\n+     *   subclass of Throwable.\n+     *\n+     * 8.8.5. Constructor Throws\n+     *\n+     *   The throws clause for a constructor is identical in structure and\n+     *   behavior to the throws clause for a method (8.4.6).\n+     *\n+     * 8.8. Constructor Declarations\n+     *\n+     *   Constructor declarations are ... never inherited and therefore are not\n+     *   subject to hiding or overriding.\n+     *\n+     * 8.4.4. Generic Methods\n+     *\n+     *   A method is generic if it declares one or more type variables (4.4).\n+     *   These type variables are known as the type parameters of the method.\n+     *\n+     *   ...\n+     *\n+     *   Two methods or constructors M and N have the same type parameters if\n+     *   both of the following are true:\n+     *\n+     *      - M and N have same number of type parameters (possibly zero).\n+     *      ...\n+     *\n+     * 8.4.2. Method Signature\n+     *\n+     *   Two methods or constructors, M and N, have the same signature if they\n+     *   have ... the same type parameters (if any) (8.4.4) ...\n+     *   ...\n+     *   The signature of a method m1 is a subsignature of the signature of\n+     *   a method m2 if either:\n+     *\n+     *     - m2 has the same signature as m1, or\n+     *     - the signature of m1 is the same as the erasure (4.6) of the\n+     *       signature of m2.\n+     *\n+     *   Two method signatures m1 and m2 are override-equivalent iff either\n+     *   m1 is a subsignature of m2 or m2 is a subsignature of m1.\n+     *\n+     * 8.4.8.1. Overriding (by Instance Methods)\n+     *\n+     *   An instance method mC declared in or inherited by class C, overrides\n+     *   from C another method mA declared in class A, iff all of the following\n+     *   are true:\n+     *\n+     *     ...\n+     *     - The signature of mC is a subsignature (8.4.2) of the signature of\n+     *       mA as a member of the supertype of C that names A.\n+     *\/\n+\n+    public ThrowsTaglet(BaseConfiguration configuration) {\n+        \/\/ of all language elements only constructors and methods can declare\n+        \/\/ thrown exceptions and, hence, document them\n@@ -61,0 +159,2 @@\n+        this.configuration = configuration;\n+        this.utils = this.configuration.utils;\n@@ -63,0 +163,3 @@\n+    private final BaseConfiguration configuration;\n+    private final Utils utils;\n+\n@@ -64,13 +167,7 @@\n-    public void inherit(DocFinder.Input input, DocFinder.Output output) {\n-        var utils = input.utils;\n-        Element target;\n-        var ch = utils.getCommentHelper(input.element);\n-        if (input.tagId == null) {\n-            var tag = (ThrowsTree) input.docTreeInfo.docTree();\n-            target = ch.getException(tag);\n-            input.tagId = target == null\n-                    ? tag.getExceptionName().getSignature()\n-                    : utils.getFullyQualifiedName(target);\n-        } else {\n-            target = input.utils.findClass(input.element, input.tagId);\n-        }\n+    public Output inherit(Element owner, DocTree tag, boolean isFirstSentence, BaseConfiguration configuration) {\n+        \/\/ This method shouldn't be called because {@inheritDoc} tags inside\n+        \/\/ exception tags aren't dealt with individually. {@inheritDoc} tags\n+        \/\/ inside exception tags are collectively dealt with in\n+        \/\/ getAllBlockTagOutput.\n+        throw newAssertionError(owner, tag, isFirstSentence);\n+    }\n@@ -78,14 +175,26 @@\n-        \/\/ TODO warn if target == null as we cannot guarantee type-match, but at most FQN-match.\n-\n-        for (ThrowsTree tag : input.utils.getThrowsTrees(input.element)) {\n-            Element candidate = ch.getException(tag);\n-            if (candidate != null && (input.tagId.equals(utils.getSimpleName(candidate)) ||\n-                    (input.tagId.equals(utils.getFullyQualifiedName(candidate))))) {\n-                output.holder = input.element;\n-                output.holderTag = tag;\n-                output.inlineTags = ch.getBody(output.holderTag);\n-                output.tagList.add(tag);\n-            } else if (target != null && candidate != null &&\n-                    utils.isTypeElement(candidate) && utils.isTypeElement(target) &&\n-                    utils.isSubclassOf((TypeElement) candidate, (TypeElement) target)) {\n-                output.tagList.add(tag);\n+    @Override\n+    public Content getAllBlockTagOutput(Element holder, TagletWriter writer) {\n+        try {\n+            return getAllBlockTagOutput0(holder, writer);\n+        } catch (Failure f) {\n+            \/\/ note that `f.holder()` is not necessarily the same as `holder`\n+            var ch = utils.getCommentHelper(f.holder());\n+            var messages = configuration.getMessages();\n+            if (f instanceof Failure.ExceptionTypeNotFound e) {\n+                var path = ch.getDocTreePath(e.tag().getExceptionName());\n+                messages.warning(path, \"doclet.throws.reference_not_found\");\n+            } else if (f instanceof Failure.NotExceptionType e) {\n+                var path = ch.getDocTreePath(e.tag().getExceptionName());\n+                \/\/ output the type we found to help the user diagnose the issue\n+                messages.warning(path, \"doclet.throws.reference_bad_type\", diagnosticDescriptionOf(e.type()));\n+            } else if (f instanceof Failure.Invalid e) {\n+                messages.error(ch.getDocTreePath(e.tag()), \"doclet.inheritDocWithinInappropriateTag\");\n+            } else if (f instanceof Failure.UnsupportedTypeParameter e) {\n+                var path = ch.getDocTreePath(e.tag().getExceptionName());\n+                messages.warning(path, \"doclet.throwsInheritDocUnsupported\");\n+            } else if (f instanceof Failure.Undocumented e) {\n+                messages.warning(ch.getDocTreePath(e.tag()), \"doclet.inheritDocNoDoc\", diagnosticDescriptionOf(e.exceptionElement));\n+            } else {\n+                \/\/ TODO: instead of if-else, use pattern matching for switch for both\n+                \/\/  readability and exhaustiveness when it's available\n+                throw newAssertionError(f);\n@@ -93,0 +202,6 @@\n+        } catch (DocFinder.NoOverriddenMethodsFound e) {\n+            \/\/ since {@inheritDoc} in @throws is processed by ThrowsTaglet (this taglet) rather than\n+            \/\/ InheritDocTaglet, we have to duplicate some of the behavior of the latter taglet\n+            String signature = utils.getSimpleName(holder)\n+                    + utils.flatSignature((ExecutableElement) holder, writer.getCurrentPageElement());\n+            configuration.getMessages().warning(holder, \"doclet.noInheritedDoc\", signature);\n@@ -94,0 +209,1 @@\n+        return writer.getOutputInstance(); \/\/ TODO: consider invalid rather than empty output\n@@ -96,3 +212,16 @@\n-    @Override\n-    public Content getAllBlockTagOutput(Element holder, TagletWriter writer) {\n-        var utils = writer.configuration().utils;\n+    private Content getAllBlockTagOutput0(Element holder,\n+                                          TagletWriter writer)\n+            throws Failure.ExceptionTypeNotFound,\n+                   Failure.NotExceptionType,\n+                   Failure.Invalid,\n+                   Failure.Undocumented,\n+                   Failure.UnsupportedTypeParameter,\n+                   DocFinder.NoOverriddenMethodsFound\n+    {\n+        ElementKind kind = holder.getKind();\n+        if (kind != ElementKind.METHOD && kind != ElementKind.CONSTRUCTOR) {\n+            \/\/ Elements are processed by applicable taglets only. This taglet\n+            \/\/ is only applicable to executable elements such as methods\n+            \/\/ and constructors.\n+            throw newAssertionError(holder, kind);\n+        }\n@@ -102,2 +231,3 @@\n-        List<? extends TypeMirror> thrownTypes = instantiatedType.getThrownTypes();\n-        Map<String, TypeMirror> typeSubstitutions = getSubstitutedThrownTypes(\n+        List<? extends TypeMirror> substitutedExceptionTypes = instantiatedType.getThrownTypes();\n+        List<? extends TypeMirror> originalExceptionTypes = executable.getThrownTypes();\n+        Map<TypeMirror, TypeMirror> typeSubstitutions = getSubstitutedThrownTypes(\n@@ -105,10 +235,57 @@\n-                executable.getThrownTypes(),\n-                thrownTypes);\n-        Map<ThrowsTree, ExecutableElement> tagsMap = new LinkedHashMap<>();\n-        utils.getThrowsTrees(executable).forEach(t -> tagsMap.put(t, executable));\n-        Content result = writer.getOutputInstance();\n-        Set<String> alreadyDocumented = new HashSet<>();\n-        result.add(throwsTagsOutput(tagsMap, alreadyDocumented, typeSubstitutions, writer));\n-        result.add(inheritThrowsDocumentation(executable, thrownTypes, alreadyDocumented, typeSubstitutions, writer));\n-        result.add(linkToUndocumentedDeclaredExceptions(thrownTypes, alreadyDocumented, writer));\n-        return result;\n+                originalExceptionTypes,\n+                substitutedExceptionTypes);\n+        var exceptionSection = new ExceptionSectionBuilder(writer);\n+        \/\/ Step 1: Document exception tags\n+        Set<TypeMirror> alreadyDocumentedExceptions = new HashSet<>();\n+        List<ThrowsTree> exceptionTags = utils.getThrowsTrees(executable);\n+        for (ThrowsTree t : exceptionTags) {\n+            Element exceptionElement = getExceptionType(t, executable);\n+            outputAnExceptionTagDeeply(exceptionSection, exceptionElement, t, executable, alreadyDocumentedExceptions, typeSubstitutions, writer);\n+        }\n+        \/\/ Step 2: Document exception types from the `throws` clause (of a method)\n+        \/\/\n+        \/\/ While methods can be inherited and overridden, constructors can be neither of those (JLS 8.8).\n+        \/\/ Therefore, it's only methods that participate in Step 2, which is about inheriting exception\n+        \/\/ documentation from ancestors.\n+        if (executable.getKind() == ElementKind.METHOD) {\n+            for (TypeMirror exceptionType : substitutedExceptionTypes) {\n+                Element exceptionElement = utils.typeUtils.asElement(exceptionType);\n+                Map<ThrowsTree, ExecutableElement> r;\n+                try {\n+                    r = expandShallowly(exceptionElement, executable);\n+                } catch (Failure | DocFinder.NoOverriddenMethodsFound e) {\n+                    \/\/ Ignore errors here because unlike @throws tags, the `throws` clause is implicit\n+                    \/\/ documentation inheritance. It triggers a best-effort attempt to inherit\n+                    \/\/ documentation. If there are errors in ancestors, they will likely be caught\n+                    \/\/ once those ancestors are documented.\n+                    continue;\n+                }\n+                if (r.isEmpty()) {\n+                    \/\/ `exceptionType` is not documented by any tags from ancestors, skip it till Step 3\n+                    continue;\n+                }\n+                if (!alreadyDocumentedExceptions.add(exceptionType)) {\n+                    \/\/ it expands to something that has to have been documented on Step 1, skip\n+                    continue;\n+                }\n+                for (Map.Entry<ThrowsTree, ExecutableElement> e : r.entrySet()) {\n+                    outputAnExceptionTagDeeply(exceptionSection, exceptionElement, e.getKey(), e.getValue(), alreadyDocumentedExceptions, typeSubstitutions, writer);\n+                }\n+            }\n+        }\n+        \/\/ Step 3: List those exceptions from the `throws` clause for which no documentation was found on Step 2\n+        for (TypeMirror e : substitutedExceptionTypes) {\n+            if (!alreadyDocumentedExceptions.add(e)) {\n+                continue;\n+            }\n+            exceptionSection.beginEntry(e);\n+            \/\/ this JavaDoc warning is similar to but different from that of DocLint:\n+            \/\/     dc.missing.throws = no @throws for {0}\n+            \/\/ TODO: comment out for now and revisit later;\n+            \/\/  commented out because of the generated noise for readObject\/writeObject for serialized-form.html:\n+            \/\/    exceptionSection.continueEntry(writer.invalidTagOutput(configuration.getDocResources().getText(\"doclet.throws.undocumented\", e), Optional.empty()));\n+            \/\/    configuration.getMessages().warning(holder, \"doclet.throws.undocumented\", e);\n+            exceptionSection.endEntry();\n+        }\n+        assert alreadyDocumentedExceptions.containsAll(substitutedExceptionTypes);\n+        return exceptionSection.build();\n@@ -117,20 +294,106 @@\n-    \/**\n-     * Returns a map of substitutions for a list of thrown types with the original type-variable\n-     * name as a key and the instantiated type as a value. If no types need to be substituted\n-     * an empty map is returned.\n-     * @param declaredThrownTypes the originally declared thrown types.\n-     * @param instantiatedThrownTypes the thrown types in the context of the current type.\n-     * @return map of declared to instantiated thrown types or an empty map.\n-     *\/\n-    private Map<String, TypeMirror> getSubstitutedThrownTypes(Types types,\n-                                                              List<? extends TypeMirror> declaredThrownTypes,\n-                                                              List<? extends TypeMirror> instantiatedThrownTypes) {\n-        if (!declaredThrownTypes.equals(instantiatedThrownTypes)) {\n-            Map<String, TypeMirror> map = new HashMap<>();\n-            Iterator<? extends TypeMirror> i1 = declaredThrownTypes.iterator();\n-            Iterator<? extends TypeMirror> i2 = instantiatedThrownTypes.iterator();\n-            while (i1.hasNext() && i2.hasNext()) {\n-                TypeMirror t1 = i1.next();\n-                TypeMirror t2 = i2.next();\n-                if (!types.isSameType(t1, t2))\n-                    map.put(t1.toString(), t2);\n+    private void outputAnExceptionTagDeeply(ExceptionSectionBuilder exceptionSection,\n+                                            Element originalExceptionElement,\n+                                            ThrowsTree tag,\n+                                            ExecutableElement holder,\n+                                            Set<TypeMirror> alreadyDocumentedExceptions,\n+                                            Map<TypeMirror, TypeMirror> typeSubstitutions,\n+                                            TagletWriter writer)\n+            throws Failure.ExceptionTypeNotFound,\n+                   Failure.NotExceptionType,\n+                   Failure.Invalid,\n+                   Failure.Undocumented,\n+                   Failure.UnsupportedTypeParameter,\n+                   DocFinder.NoOverriddenMethodsFound\n+    {\n+        outputAnExceptionTagDeeply(exceptionSection, originalExceptionElement, tag, holder, true, alreadyDocumentedExceptions, typeSubstitutions, writer);\n+    }\n+\n+    private void outputAnExceptionTagDeeply(ExceptionSectionBuilder exceptionSection,\n+                                            Element originalExceptionElement,\n+                                            ThrowsTree tag,\n+                                            ExecutableElement holder,\n+                                            boolean beginNewEntry,\n+                                            Set<TypeMirror> alreadyDocumentedExceptions,\n+                                            Map<TypeMirror, TypeMirror> typeSubstitutions,\n+                                            TagletWriter writer)\n+            throws Failure.ExceptionTypeNotFound,\n+                   Failure.NotExceptionType,\n+                   Failure.Invalid,\n+                   Failure.Undocumented,\n+                   Failure.UnsupportedTypeParameter,\n+                   DocFinder.NoOverriddenMethodsFound\n+    {\n+        var originalExceptionType = originalExceptionElement.asType();\n+        var exceptionType = typeSubstitutions.getOrDefault(originalExceptionType, originalExceptionType); \/\/ FIXME: ugh..........\n+        alreadyDocumentedExceptions.add(exceptionType);\n+        var description = tag.getDescription();\n+        int i = indexOfInheritDoc(tag, holder);\n+        if (i == -1) {\n+            \/\/ Since the description does not contain {@inheritDoc}, we either add a new entry, or\n+            \/\/ append to the current one. Here's an example of when we add a new entry:\n+            \/\/\n+            \/\/     ... -> {@inheritDoc} -> <text>\n+            \/\/\n+            \/\/ And here's an example of when we append to the current entry:\n+            \/\/\n+            \/\/     ... -> <text> {@inheritDoc} <text> -> <text>\n+\n+            \/\/ if we don't need to add a new entry, assume it has been added before\n+            assert exceptionSection.debugEntryBegun() || beginNewEntry;\n+            if (beginNewEntry) { \/\/ add a new entry?\n+                \/\/ originalExceptionElement might be different from that that triggers this entry: for example, a\n+                \/\/ renamed exception-type type parameter\n+                exceptionSection.beginEntry(exceptionType);\n+            }\n+            \/\/ append to the current entry\n+            exceptionSection.continueEntry(writer.commentTagsToOutput(holder, description));\n+            if (beginNewEntry) { \/\/ if added a new entry, end it\n+                exceptionSection.endEntry();\n+            }\n+        } else { \/\/ expand a single {@inheritDoc}\n+            assert holder.getKind() == ElementKind.METHOD : holder.getKind(); \/\/ only methods can use {@inheritDoc}\n+            \/\/ Is the {@inheritDoc} that we found standalone (i.e. without preceding and following text)?\n+            boolean loneInheritDoc = description.size() == 1;\n+            assert !loneInheritDoc || i == 0 : i;\n+            boolean add = !loneInheritDoc && beginNewEntry;\n+            \/\/ we add a new entry if the {@inheritDoc} that we found has something else around\n+            \/\/ it and we can add a new entry (as instructed by the parent call)\n+            if (add) {\n+                exceptionSection.beginEntry(exceptionType);\n+            }\n+            if (i > 0) {\n+                \/\/ if there's anything preceding {@inheritDoc}, assume an entry has been added before\n+                assert exceptionSection.debugEntryBegun();\n+                Content beforeInheritDoc = writer.commentTagsToOutput(holder, description.subList(0, i));\n+                exceptionSection.continueEntry(beforeInheritDoc);\n+            }\n+            Map<ThrowsTree, ExecutableElement> tags;\n+            try {\n+                tags = expandShallowly(originalExceptionElement, holder);\n+            } catch (Failure.UnsupportedTypeParameter e) {\n+                \/\/ repack to fill in missing tag information\n+                throw new Failure.UnsupportedTypeParameter(e.element, tag, holder);\n+            }\n+            if (tags.isEmpty()) {\n+                throw new Failure.Undocumented(tag, holder, originalExceptionElement);\n+            }\n+            \/\/ if {@inheritDoc} is the only tag in the @throws description and\n+            \/\/ this call can add new entries to the exception section,\n+            \/\/ so can the recursive call\n+            boolean addNewEntryRecursively = beginNewEntry && !add;\n+            if (!addNewEntryRecursively && tags.size() > 1) {\n+                \/\/ current tag has more to description than just {@inheritDoc}\n+                \/\/ and thus cannot expand to multiple tags;\n+                \/\/ it's likely a documentation error\n+                throw new Failure.Invalid(tag, holder);\n+            }\n+            for (Map.Entry<ThrowsTree, ExecutableElement> e : tags.entrySet()) {\n+                outputAnExceptionTagDeeply(exceptionSection, originalExceptionElement, e.getKey(), e.getValue(), addNewEntryRecursively, alreadyDocumentedExceptions, typeSubstitutions, writer);\n+            }\n+            \/\/ this might be an empty list, which is fine\n+            if (!loneInheritDoc) {\n+                Content afterInheritDoc = writer.commentTagsToOutput(holder, description.subList(i + 1, description.size()));\n+                exceptionSection.continueEntry(afterInheritDoc);\n+            }\n+            if (add) {\n+                exceptionSection.endEntry();\n@@ -138,1 +401,0 @@\n-            return map;\n@@ -140,1 +402,0 @@\n-        return Map.of();\n@@ -143,30 +404,14 @@\n-    \/**\n-     * Returns the generated content for a collection of {@code @throws} tags.\n-     *\n-     * @param throwsTags        the tags to be converted; each tag is mapped to\n-     *                          a method it appears on\n-     * @param alreadyDocumented the set of exceptions that have already been\n-     *                          documented and thus must not be documented by\n-     *                          this method. All exceptions documented by this\n-     *                          method will be added to this set upon the\n-     *                          method's return.\n-     * @param writer            the taglet-writer used by the doclet\n-     * @return the generated content for the tags\n-     *\/\n-    private Content throwsTagsOutput(Map<ThrowsTree, ExecutableElement> throwsTags,\n-                                     Set<String> alreadyDocumented,\n-                                     Map<String, TypeMirror> typeSubstitutions,\n-                                     TagletWriter writer) {\n-        var utils = writer.configuration().utils;\n-        Content result = writer.getOutputInstance();\n-        var documentedInThisCall = new HashSet<String>();\n-        Map<ThrowsTree, ExecutableElement> flattenedExceptions = flatten(throwsTags, writer);\n-        flattenedExceptions.forEach((ThrowsTree t, ExecutableElement e) -> {\n-            var ch = utils.getCommentHelper(e);\n-            Element te = ch.getException(t);\n-            String excName = t.getExceptionName().toString();\n-            TypeMirror substituteType = typeSubstitutions.get(excName);\n-            if (alreadyDocumented.contains(excName)\n-                    || (te != null && alreadyDocumented.contains(utils.getFullyQualifiedName(te, false)))\n-                    || (substituteType != null && alreadyDocumented.contains(substituteType.toString()))) {\n-                return;\n+    private static int indexOfInheritDoc(ThrowsTree tag, ExecutableElement holder)\n+            throws Failure.Invalid\n+    {\n+        var description = tag.getDescription();\n+        int i = -1;\n+        for (var iterator = description.listIterator(); iterator.hasNext(); ) {\n+            DocTree t = iterator.next();\n+            if (t.getKind() == DocTree.Kind.INHERIT_DOC) {\n+                if (i != -1) {\n+                    \/\/ an exception tag description contains more than one {@inheritDoc};\n+                    \/\/ we consider it nonsensical and, hence, a documentation error\n+                    throw new Failure.Invalid(t, holder);\n+                }\n+                i = iterator.previousIndex();\n@@ -174,2 +419,51 @@\n-            if (alreadyDocumented.isEmpty() && documentedInThisCall.isEmpty()) {\n-                result.add(writer.getThrowsHeader());\n+        }\n+        return i;\n+    }\n+\n+    private Element getExceptionType(ThrowsTree tag, ExecutableElement holder)\n+            throws Failure.ExceptionTypeNotFound, Failure.NotExceptionType\n+    {\n+        Element e = utils.getCommentHelper(holder).getException(tag);\n+        if (e == null) {\n+            throw new Failure.ExceptionTypeNotFound(tag, holder);\n+        }\n+        \/\/ translate to a type mirror to perform a subtype test, which covers not only\n+        \/\/ classes (e.g. class X extends Exception) but also type variables\n+        \/\/ (e.g. <X extends Exception>)\n+        var t = e.asType();\n+        var subtypeTestInapplicable = switch (t.getKind()) {\n+            case EXECUTABLE, PACKAGE, MODULE -> true;\n+            default -> false;\n+        };\n+        if (subtypeTestInapplicable || !utils.typeUtils.isSubtype(t, utils.getThrowableType())) {\n+            \/\/ Aside from documentation errors, this condition might arise if the\n+            \/\/ source cannot be compiled or element we found is not what the\n+            \/\/ documentation author intended. Whatever the reason is (e.g.\n+            \/\/ see 8295543), we should not process such an element.\n+            throw new Failure.NotExceptionType(tag, holder, e);\n+        }\n+        var k = e.getKind();\n+        assert k == ElementKind.CLASS || k == ElementKind.TYPE_PARAMETER : k; \/\/ JLS 8.4.6\n+        return e;\n+    }\n+\n+    @SuppressWarnings(\"serial\")\n+    private static sealed class Failure extends Exception {\n+\n+        private final DocTree tag;\n+        private final ExecutableElement holder;\n+\n+        Failure(DocTree tag, ExecutableElement holder) {\n+            super();\n+            this.tag = tag;\n+            this.holder = holder;\n+        }\n+\n+        DocTree tag() { return tag; }\n+\n+        ExecutableElement holder() { return holder; }\n+\n+        static final class ExceptionTypeNotFound extends Failure {\n+\n+            ExceptionTypeNotFound(ThrowsTree tag, ExecutableElement holder) {\n+                super(tag, holder);\n@@ -177,7 +471,11 @@\n-            result.add(writer.throwsTagOutput(e, t, substituteType));\n-            if (substituteType != null) {\n-                documentedInThisCall.add(substituteType.toString());\n-            } else {\n-                documentedInThisCall.add(te != null\n-                        ? utils.getFullyQualifiedName(te, false)\n-                        : excName);\n+\n+            @Override ThrowsTree tag() { return (ThrowsTree) super.tag(); }\n+        }\n+\n+        static final class NotExceptionType extends Failure {\n+\n+            private final Element type;\n+\n+            public NotExceptionType(ThrowsTree tag, ExecutableElement holder, Element type) {\n+                super(tag, holder);\n+                this.type = type;\n@@ -185,3 +483,117 @@\n-        });\n-        alreadyDocumented.addAll(documentedInThisCall);\n-        return result;\n+\n+            Element type() { return type; }\n+\n+            @Override ThrowsTree tag() { return (ThrowsTree) super.tag(); }\n+        }\n+\n+        static final class Invalid extends Failure {\n+\n+            public Invalid(DocTree tag, ExecutableElement holder) {\n+                super(tag, holder);\n+            }\n+        }\n+\n+        static final class Undocumented extends Failure {\n+\n+            private final Element exceptionElement;\n+\n+            public Undocumented(DocTree tag, ExecutableElement holder, Element exceptionElement) {\n+                super(tag, holder);\n+                this.exceptionElement = exceptionElement;\n+            }\n+        }\n+\n+        static final class UnsupportedTypeParameter extends Failure {\n+\n+            private final Element element;\n+\n+            \/\/ careful: tag might be null\n+            public UnsupportedTypeParameter(Element element, ThrowsTree tag, ExecutableElement holder) {\n+                super(tag, holder);\n+                this.element = element;\n+            }\n+\n+            @Override ThrowsTree tag() { return (ThrowsTree) super.tag(); }\n+        }\n+    }\n+\n+    \/*\n+     * Returns immediately inherited tags that document the provided exception type.\n+     *\n+     * A map associates a doc tree with its holder element externally. Such maps\n+     * have defined iteration order of entries, whose keys and values\n+     * are non-null.\n+     *\/\n+    private Map<ThrowsTree, ExecutableElement> expandShallowly(Element exceptionType,\n+                                                               ExecutableElement holder)\n+            throws Failure.ExceptionTypeNotFound,\n+                   Failure.NotExceptionType,\n+                   Failure.Invalid,\n+                   Failure.UnsupportedTypeParameter,\n+                   DocFinder.NoOverriddenMethodsFound\n+    {\n+        ElementKind kind = exceptionType.getKind();\n+        DocFinder.Criterion<Map<ThrowsTree, ExecutableElement>, Failure> criterion;\n+        if (kind == ElementKind.CLASS) {\n+            criterion = method -> {\n+                var tags = findByTypeElement(exceptionType, method);\n+                return toResult(exceptionType, method, tags);\n+            };\n+        } else {\n+            \/\/ Type parameters declared by a method are matched by position; the basis for\n+            \/\/ such position matching is JLS sections 8.4.2 and 8.4.4. We don't match\n+            \/\/ type parameters not declared by a method (e.g. declared by the\n+            \/\/ enclosing class or interface) because\n+            criterion = method -> {\n+                \/\/ TODO: add a test for the throws clause mentioning\n+                \/\/  a type parameter which is not declared by holder\n+                int i = holder.getTypeParameters().indexOf((TypeParameterElement) exceptionType);\n+                if (i == -1) { \/\/ the type parameter is not declared by `holder`\n+                    throw new Failure.UnsupportedTypeParameter(exceptionType, null \/* don't know if tag-related *\/, holder);\n+                }\n+                \/\/ if one method overrides the other, then those methods must\n+                \/\/ have the same number of type parameters (JLS 8.4.2)\n+                assert utils.elementUtils.overrides(holder, method, (TypeElement) holder.getEnclosingElement());\n+                var typeParameterElement = method.getTypeParameters().get(i);\n+                var tags = findByTypeElement(typeParameterElement, method);\n+                return toResult(exceptionType, method, tags);\n+            };\n+        }\n+        Result<Map<ThrowsTree, ExecutableElement>> result;\n+        try {\n+            result = utils.docFinder().trySearch(holder, criterion);\n+        } catch (Failure.NotExceptionType\n+                 | Failure.ExceptionTypeNotFound\n+                 | Failure.UnsupportedTypeParameter x) {\n+            \/\/ Here's why we do this ugly exception processing: the language does not allow us to\n+            \/\/ instantiate the exception type parameter in criterion with a union of specific\n+            \/\/ exceptions (i.e. Failure.ExceptionTypeNotFound | Failure.NotExceptionType),\n+            \/\/ so we instantiate it with a general Failure. We then refine the specific\n+            \/\/ exception being thrown, from the general exception we caught.\n+            throw x;\n+        } catch (Failure f) {\n+            throw newAssertionError(f);\n+        }\n+        if (result instanceof Result.Conclude<Map<ThrowsTree, ExecutableElement>> c) {\n+            return c.value();\n+        }\n+        return Map.of(); \/\/ an empty map is effectively ordered\n+    }\n+\n+    private static Result<Map<ThrowsTree, ExecutableElement>> toResult(Element target,\n+                                                                       ExecutableElement holder,\n+                                                                       List<ThrowsTree> tags) {\n+        if (!tags.isEmpty()) {\n+            \/\/ if there are tags for the target exception type, conclude search successfully\n+            return Result.CONCLUDE(toExceptionTags(holder, tags));\n+        }\n+        if (holder.getThrownTypes().contains(target.asType())) {\n+            \/\/ if there are no tags for the target exception type, BUT that type is\n+            \/\/ mentioned in the `throws` clause, continue search\n+            return Result.CONTINUE();\n+        }\n+        \/\/ there are no tags for the target exception type AND that type is not\n+        \/\/ mentioned in the `throws` clause, skip search on the remaining part\n+        \/\/ of the current branch of the hierarchy\n+        \/\/ TODO: add a text for this; both checked and unchecked\n+        return Result.SKIP();\n@@ -191,2 +603,3 @@\n-     * A single @throws tag from an overriding method can correspond to multiple\n-     * @throws tags from an overridden method.\n+     * Associates exception tags with their holder.\n+     *\n+     * Such a map is used as a data structure to pass around methods that output tags to content.\n@@ -194,9 +607,10 @@\n-    private Map<ThrowsTree, ExecutableElement> flatten(Map<ThrowsTree, ExecutableElement> throwsTags,\n-                                                       TagletWriter writer) {\n-        Map<ThrowsTree, ExecutableElement> result = new LinkedHashMap<>();\n-        throwsTags.forEach((tag, taggedElement) -> {\n-            var expandedTags = expand(tag, taggedElement, writer);\n-            assert Collections.disjoint(result.entrySet(), expandedTags.entrySet());\n-            result.putAll(expandedTags);\n-        });\n-        return result;\n+    private static Map<ThrowsTree, ExecutableElement> toExceptionTags(ExecutableElement holder,\n+                                                                      List<ThrowsTree> tags)\n+    {\n+        \/\/ preserve the tag order using the linked hash map\n+        var map = new LinkedHashMap<ThrowsTree, ExecutableElement>();\n+        for (var t : tags) {\n+            var prev = map.put(t, holder);\n+            assert prev == null; \/\/ there should be no equal exception tags\n+        }\n+        return map;\n@@ -205,3 +619,14 @@\n-    private Map<ThrowsTree, ExecutableElement> expand(ThrowsTree tag,\n-                                                      ExecutableElement e,\n-                                                      TagletWriter writer) {\n+    private List<ThrowsTree> findByTypeElement(Element targetExceptionType,\n+                                               ExecutableElement executable)\n+            throws Failure.ExceptionTypeNotFound,\n+                   Failure.NotExceptionType\n+    {\n+        var result = new LinkedList<ThrowsTree>();\n+        for (ThrowsTree t : utils.getThrowsTrees(executable)) {\n+            Element candidate = getExceptionType(t, executable);\n+            if (targetExceptionType.equals(candidate)) {\n+                result.add(t);\n+            }\n+        }\n+        return List.copyOf(result);\n+    }\n@@ -209,3 +634,9 @@\n-        \/\/ This method uses Map.of() to create maps of size zero and one.\n-        \/\/ While such maps are effectively ordered, the syntax is more\n-        \/\/ compact than that of LinkedHashMap.\n+    \/*\n+     * An exception section (that is, the \"Throws:\" section in the Method\n+     * or Constructor Details section) builder.\n+     *\n+     * The section is being built sequentially from top to bottom.\n+     *\n+     * Adapts one-off methods of writer to continuous building.\n+     *\/\n+    private static class ExceptionSectionBuilder {\n@@ -213,4 +644,10 @@\n-        \/\/ peek into @throws description\n-        if (tag.getDescription().stream().noneMatch(d -> d.getKind() == DocTree.Kind.INHERIT_DOC)) {\n-            \/\/ nothing to inherit\n-            return Map.of(tag, e);\n+        private final TagletWriter writer;\n+        private final Content result;\n+        private ContentBuilder current;\n+        private boolean began;\n+        private boolean headerAdded;\n+        private TypeMirror exceptionType;\n+\n+        ExceptionSectionBuilder(TagletWriter writer) {\n+            this.writer = writer;\n+            this.result = writer.getOutputInstance();\n@@ -218,5 +655,15 @@\n-        var input = new DocFinder.Input(writer.configuration().utils, e, this, new DocFinder.DocTreeInfo(tag, e), false, true);\n-        var output = DocFinder.search(writer.configuration(), input);\n-        if (output.tagList.size() <= 1) {\n-            \/\/ outer code will handle this trivial case of inheritance\n-            return Map.of(tag, e);\n+\n+        void beginEntry(TypeMirror exceptionType) {\n+            if (began) {\n+                throw new IllegalStateException();\n+            }\n+            began = true;\n+            current = new ContentBuilder();\n+            this.exceptionType = exceptionType;\n+        }\n+\n+        void continueEntry(Content c) {\n+            if (!began) {\n+                throw new IllegalStateException();\n+            }\n+            current.add(c);\n@@ -224,6 +671,21 @@\n-        if (tag.getDescription().size() > 1) {\n-            \/\/ there's more to description than just {@inheritDoc}\n-            \/\/ it's likely a documentation error\n-            var ch = writer.configuration().utils.getCommentHelper(e);\n-            writer.configuration().getMessages().error(ch.getDocTreePath(tag), \"doclet.inheritDocWithinInappropriateTag\");\n-            return Map.of();\n+\n+        public void endEntry() {\n+            if (!began) {\n+                throw new IllegalStateException();\n+            }\n+            began = false;\n+            if (!headerAdded) {\n+                headerAdded = true;\n+                result.add(writer.getThrowsHeader());\n+            }\n+            result.add(writer.throwsTagOutput(exceptionType, current.isEmpty() ? Optional.empty() : Optional.of(current)));\n+            current = null;\n+        }\n+\n+        Content build() {\n+            return result;\n+        }\n+\n+        \/\/ for debugging purposes only\n+        boolean debugEntryBegun() {\n+            return began;\n@@ -231,3 +693,0 @@\n-        Map<ThrowsTree, ExecutableElement> tags = new LinkedHashMap<>();\n-        output.tagList.forEach(t -> tags.put((ThrowsTree) t, (ExecutableElement) output.holder));\n-        return tags;\n@@ -237,2 +696,6 @@\n-     * Inherit throws documentation for exceptions that were declared but not\n-     * documented.\n+     * Returns a map of substitutions for a list of thrown types with the original type-variable\n+     * as a key and the instantiated type as a value. If no types need to be substituted\n+     * an empty map is returned.\n+     * @param declaredThrownTypes the originally declared thrown types.\n+     * @param instantiatedThrownTypes the thrown types in the context of the current type.\n+     * @return map of declared to instantiated thrown types or an empty map.\n@@ -240,31 +703,11 @@\n-    private Content inheritThrowsDocumentation(ExecutableElement holder,\n-                                               List<? extends TypeMirror> declaredExceptionTypes,\n-                                               Set<String> alreadyDocumented,\n-                                               Map<String, TypeMirror> typeSubstitutions,\n-                                               TagletWriter writer) {\n-        Content result = writer.getOutputInstance();\n-        if (holder.getKind() != ElementKind.METHOD) {\n-            \/\/ (Optimization.)\n-            \/\/ Of all executable elements, only methods and constructors are documented.\n-            \/\/ Of these two, only methods inherit documentation.\n-            \/\/ Don't waste time on constructors.\n-            assert holder.getKind() == ElementKind.CONSTRUCTOR : holder.getKind();\n-            return result;\n-        }\n-        var utils = writer.configuration().utils;\n-        Map<ThrowsTree, ExecutableElement> declaredExceptionTags = new LinkedHashMap<>();\n-        for (TypeMirror declaredExceptionType : declaredExceptionTypes) {\n-            var input = new DocFinder.Input(utils, holder, this,\n-                    utils.getTypeName(declaredExceptionType, false));\n-            DocFinder.Output inheritedDoc = DocFinder.search(writer.configuration(), input);\n-            if (inheritedDoc.tagList.isEmpty()) {\n-                input = new DocFinder.Input(utils, holder, this,\n-                        utils.getTypeName(declaredExceptionType, true));\n-                inheritedDoc = DocFinder.search(writer.configuration(), input);\n-            }\n-            if (!inheritedDoc.tagList.isEmpty()) {\n-                if (inheritedDoc.holder == null) {\n-                    inheritedDoc.holder = holder;\n-                }\n-                var h = (ExecutableElement) inheritedDoc.holder;\n-                inheritedDoc.tagList.forEach(t -> declaredExceptionTags.put((ThrowsTree) t, h));\n+    private Map<TypeMirror, TypeMirror> getSubstitutedThrownTypes(Types types,\n+                                                                  List<? extends TypeMirror> declaredThrownTypes,\n+                                                                  List<? extends TypeMirror> instantiatedThrownTypes) {\n+        Map<TypeMirror, TypeMirror> map = new HashMap<>();\n+        var i1 = declaredThrownTypes.iterator();\n+        var i2 = instantiatedThrownTypes.iterator();\n+        while (i1.hasNext() && i2.hasNext()) {\n+            TypeMirror t1 = i1.next();\n+            TypeMirror t2 = i2.next();\n+            if (!types.isSameType(t1, t2)) {\n+                map.put(t1, t2);\n@@ -273,3 +716,8 @@\n-        result.add(throwsTagsOutput(declaredExceptionTags, alreadyDocumented, typeSubstitutions,\n-                writer));\n-        return result;\n+        \/\/ correspondence between types is established positionally, i.e.\n+        \/\/ pairwise, which means that the lists must have the same\n+        \/\/ number of elements; if they don't, this algorithm is\n+        \/\/ broken\n+        assert !i1.hasNext() && !i2.hasNext();\n+        \/\/ copyOf is unordered and this is fine: this map is for queries;\n+        \/\/ it doesn't control rendering order\n+        return Map.copyOf(map);\n@@ -278,16 +726,32 @@\n-    private Content linkToUndocumentedDeclaredExceptions(List<? extends TypeMirror> declaredExceptionTypes,\n-                                                         Set<String> alreadyDocumented,\n-                                                         TagletWriter writer) {\n-        \/\/ TODO: assert declaredExceptionTypes are instantiated\n-        var utils = writer.configuration().utils;\n-        Content result = writer.getOutputInstance();\n-        for (TypeMirror declaredExceptionType : declaredExceptionTypes) {\n-            TypeElement te = utils.asTypeElement(declaredExceptionType);\n-            if (te != null &&\n-                    !alreadyDocumented.contains(declaredExceptionType.toString()) &&\n-                    !alreadyDocumented.contains(utils.getFullyQualifiedName(te, false))) {\n-                if (alreadyDocumented.isEmpty()) {\n-                    result.add(writer.getThrowsHeader());\n-                }\n-                result.add(writer.throwsTagOutput(declaredExceptionType));\n-                alreadyDocumented.add(utils.getSimpleName(te));\n+    private static AssertionError newAssertionError(Object... objects) {\n+        return new AssertionError(Arrays.toString(objects));\n+    }\n+\n+    private static String diagnosticDescriptionOf(Element e) {\n+        var name = e instanceof QualifiedNameable q ? q.getQualifiedName() : e.getSimpleName();\n+        return name + \" (\" + detailedDescriptionOf(e) + \")\";\n+    }\n+\n+    private static String detailedDescriptionOf(Element e) {\n+        \/\/ It might be important to describe the element in detail. Sometimes\n+        \/\/ elements share the same simple and\/or qualified name. Outputting\n+        \/\/ individual components of that name as well as their kinds helps\n+        \/\/ the user disambiguate such elements.\n+        \/\/ TODO: is it feasible to use javax.lang.model.util.Elements.getBinaryName(TypeElement)\n+        \/\/  to augment\/replace detailed information for _type elements_?\n+        \/\/  (binary names don't work for _type variables_)\n+        var thisElementDescription = e.getKind() + \" \" + switch (e.getKind()) {\n+            \/\/ A package is never enclosed in a package and a module is\n+            \/\/ never never enclosed in a module, no matter what their\n+            \/\/ qualified name might suggest. Get their qualified\n+            \/\/ name directly. Also, unnamed packages and\n+            \/\/ modules require special treatment.\n+            case PACKAGE -> {\n+                var p = (PackageElement) e;\n+                \/\/ TODO: i18n\n+                yield p.isUnnamed() ? \"<unnamed package>\" : p.getQualifiedName();\n+            }\n+            case MODULE -> {\n+                var m = (ModuleElement) e;\n+                \/\/ TODO: i18n + is there any value is displaying unnamed module?\n+                yield m.isUnnamed() ? \"<unnamed module>\" : m.getQualifiedName();\n@@ -295,0 +759,4 @@\n+            default -> e.getSimpleName();\n+        };\n+        if (e.getEnclosingElement() == null) {\n+            return thisElementDescription;\n@@ -296,1 +764,2 @@\n-        return result;\n+        var enclosingElementDescription = detailedDescriptionOf(e.getEnclosingElement());\n+        return enclosingElementDescription + \" \" + thisElementDescription;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/ThrowsTaglet.java","additions":668,"deletions":199,"binary":false,"changes":867,"status":"modified"},{"patch":"@@ -59,0 +59,1 @@\n+import jdk.javadoc.internal.doclets.toolkit.util.DocFinder.Result;\n@@ -69,0 +70,1 @@\n+import java.util.Optional;\n@@ -128,0 +130,1 @@\n+        \/\/ We need to lookup type variables and other types\n@@ -536,4 +539,7 @@\n-        DocFinder.Output inheritedDoc =\n-                DocFinder.search(configuration,\n-                        new DocFinder.Input(utils, ee));\n-        return inheritedDoc.holder == ee\n+        var docFinder = utils.docFinder();\n+        Optional<ExecutableElement> inheritedDoc = docFinder.search(ee,\n+                (m -> {\n+                    Optional<ExecutableElement> optional = utils.getFullBody(m).isEmpty() ? Optional.empty() : Optional.of(m);\n+                    return Result.fromOptional(optional);\n+                })).toOptional();\n+        return inheritedDoc.isEmpty() || inheritedDoc.get().equals(ee)\n@@ -541,1 +547,1 @@\n-                : utils.getCommentHelper(inheritedDoc.holder).getDocTreePath(dtree);\n+                : utils.getCommentHelper(inheritedDoc.get()).getDocTreePath(dtree);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/CommentHelper.java","additions":11,"deletions":5,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -28,1 +28,6 @@\n-import java.util.*;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n@@ -30,1 +35,0 @@\n-import javax.lang.model.element.Element;\n@@ -32,1 +36,0 @@\n-import javax.lang.model.element.TypeElement;\n@@ -34,7 +37,0 @@\n-import com.sun.source.doctree.DocTree;\n-import jdk.javadoc.internal.doclets.toolkit.BaseConfiguration;\n-import jdk.javadoc.internal.doclets.toolkit.taglets.InheritableTaglet;\n-\n-\/**\n- * Search for the requested documentation.  Inherit documentation if necessary.\n- *\/\n@@ -43,4 +39,5 @@\n-    public record DocTreeInfo(DocTree docTree, Element element) { }\n-\n-    \/**\n-     * The class that encapsulates the input.\n+    \/*\n+     * A specialized, possibly stateful, function that accepts a method in the\n+     * hierarchy and returns a value that controls the search or throws an\n+     * exception, which terminates the search and transparently bubbles\n+     * up the stack.\n@@ -48,23 +45,4 @@\n-    public static class Input {\n-\n-        \/**\n-         * The element to search documentation from.\n-         *\/\n-        public Element element;\n-\n-        \/**\n-         * The taglet to search for documentation on behalf of. Null if we want\n-         * to search for overall documentation.\n-         *\/\n-        public InheritableTaglet taglet;\n-\n-        \/**\n-         * The id of the tag to retrieve documentation for.\n-         *\/\n-        public String tagId;\n-\n-        \/**\n-         * The tag to retrieve documentation for.  This is only used for the\n-         * {@code {@inheritDoc}} tag.\n-         *\/\n-        public final DocTreeInfo docTreeInfo;\n+    @FunctionalInterface\n+    public interface Criterion<T, X extends Throwable> {\n+        Result<T> apply(ExecutableElement method) throws X;\n+    }\n@@ -72,4 +50,2 @@\n-        \/**\n-         * True if we only want to search for the first sentence.\n-         *\/\n-        public boolean isFirstSentence;\n+    private final Function<ExecutableElement, ExecutableElement> overriddenMethodLookup;\n+    private final BiFunction<ExecutableElement, ExecutableElement, Iterable<ExecutableElement>> implementedMethodsLookup;\n@@ -77,4 +53,5 @@\n-        \/**\n-         * True if we are looking for documentation to replace the {@code {@inheritDoc}} tag.\n-         *\/\n-        public boolean isInheritDocTag;\n+    DocFinder(Function<ExecutableElement, ExecutableElement> overriddenMethodLookup,\n+              BiFunction<ExecutableElement, ExecutableElement, Iterable<ExecutableElement>> implementedMethodsLookup) {\n+        this.overriddenMethodLookup = overriddenMethodLookup;\n+        this.implementedMethodsLookup = implementedMethodsLookup;\n+    }\n@@ -82,5 +59,2 @@\n-        \/**\n-         * Used to distinguish between type variable param tags and regular\n-         * param tags.\n-         *\/\n-        public boolean isTypeVariableParamTag;\n+    @SuppressWarnings(\"serial\")\n+    public static final class NoOverriddenMethodsFound extends Exception {\n@@ -88,1 +62,3 @@\n-        public final Utils utils;\n+        \/\/ only DocFinder should instantiate this exception\n+        private NoOverriddenMethodsFound() { }\n+    }\n@@ -90,8 +66,6 @@\n-        public Input(Utils utils,\n-                     Element element,\n-                     InheritableTaglet taglet,\n-                     String tagId) {\n-            this(utils, element);\n-            this.taglet = taglet;\n-            this.tagId = tagId;\n-        }\n+    public <T, X extends Throwable> Result<T> search(ExecutableElement method,\n+                                                     Criterion<T, X> criterion)\n+            throws X\n+    {\n+        return search(method, true, criterion);\n+    }\n@@ -99,9 +73,10 @@\n-        public Input(Utils utils,\n-                     Element element,\n-                     InheritableTaglet taglet,\n-                     String tagId,\n-                     boolean isTypeVariableParamTag) {\n-            this(utils, element);\n-            this.taglet = taglet;\n-            this.tagId = tagId;\n-            this.isTypeVariableParamTag = isTypeVariableParamTag;\n+    public <T, X extends Throwable> Result<T> search(ExecutableElement method,\n+                                                     boolean includeMethod,\n+                                                     Criterion<T, X> criterion)\n+            throws X\n+    {\n+        try {\n+            return search0(method, includeMethod, false, criterion);\n+        } catch (NoOverriddenMethodsFound e) {\n+            \/\/ should not happen because the exception flag is unset\n+            throw new AssertionError(e);\n@@ -109,0 +84,1 @@\n+    }\n@@ -110,4 +86,6 @@\n-        public Input(Utils utils, Element element, InheritableTaglet taglet) {\n-            this(utils, element);\n-            this.taglet = taglet;\n-        }\n+    public <T, X extends Throwable> Result<T> trySearch(ExecutableElement method,\n+                                                        Criterion<T, X> criterion)\n+            throws NoOverriddenMethodsFound, X\n+    {\n+        return search0(method, false, true, criterion);\n+    }\n@@ -115,4 +93,31 @@\n-        public Input(Utils utils, Element element) {\n-            this.element = Objects.requireNonNull(element);\n-            this.utils = utils;\n-            this.docTreeInfo = new DocTreeInfo(null, null);\n+    \/*\n+     * Searches through the overridden methods hierarchy of the provided method.\n+     *\n+     * Depending on how it is instructed, the search begins from either the given\n+     * method or the first method that the given method overrides. The search\n+     * then applies the given criterion to methods it encounters, in the\n+     * hierarchy order, until either of the following happens:\n+     *\n+     *  - the criterion concludes the search\n+     *  - the criterion throws an exception\n+     *  - the hierarchy is exhausted\n+     *\n+     * If the search succeeds, the returned result is of type Conclude.\n+     * Otherwise, the returned result is generally that of the most\n+     * recent call to Criterion::apply.\n+     *\n+     * If the given method overrides no methods (i.e. hierarchy consists of the\n+     * given method only) and the search is instructed to detect that, the\n+     * search terminates with an exception.\n+     *\/\n+    private <T, X extends Throwable> Result<T> search0(ExecutableElement method,\n+                                                       boolean includeMethodInSearch,\n+                                                       boolean throwExceptionIfDoesNotOverride,\n+                                                       Criterion<T, X> criterion)\n+            throws NoOverriddenMethodsFound, X\n+    {\n+        \/\/ if the \"overrides\" check is requested and does not pass, throw the exception\n+        \/\/ first so that it trumps the result that the search would otherwise had\n+        Iterator<ExecutableElement> methods = methodsOverriddenBy(method);\n+        if (throwExceptionIfDoesNotOverride && !methods.hasNext() ) {\n+            throw new NoOverriddenMethodsFound();\n@@ -120,13 +125,3 @@\n-\n-        public Input(Utils utils,\n-                     Element element,\n-                     InheritableTaglet taglet,\n-                     DocTreeInfo dtInfo,\n-                     boolean isFirstSentence,\n-                     boolean isInheritDocTag) {\n-            this.utils = utils;\n-            this.element = Objects.requireNonNull(element);\n-            this.taglet = taglet;\n-            this.isFirstSentence = isFirstSentence;\n-            this.isInheritDocTag = isInheritDocTag;\n-            this.docTreeInfo = dtInfo;\n+        Result<T> r = includeMethodInSearch ? criterion.apply(method) : Result.CONTINUE();\n+        if (!(r instanceof Result.Continue<T>)) {\n+            return r;\n@@ -134,7 +129,6 @@\n-\n-        private Input copy() {\n-            var copy = new Input(utils, element, taglet, docTreeInfo,\n-                    isFirstSentence, isInheritDocTag);\n-            copy.tagId = tagId;\n-            copy.isTypeVariableParamTag = isTypeVariableParamTag;\n-            return copy;\n+        while (methods.hasNext()) {\n+            ExecutableElement m = methods.next();\n+            r = search0(m, true, false \/* don't check for overrides *\/, criterion);\n+            if (r instanceof Result.Conclude<T>) {\n+                return r;\n+            }\n@@ -142,0 +136,2 @@\n+        return r;\n+    }\n@@ -143,13 +139,8 @@\n-        \/**\n-         * For debugging purposes.\n-         *\/\n-        @Override\n-        public String toString() {\n-            String encl = element == null ? \"\" : element.getEnclosingElement().toString() + \"::\";\n-            return \"Input{\" + \"element=\" + encl + element\n-                    + \", taglet=\" + taglet\n-                    + \", tagId=\" + tagId + \", tag=\" + docTreeInfo\n-                    + \", isFirstSentence=\" + isFirstSentence\n-                    + \", isInheritDocTag=\" + isInheritDocTag\n-                    + \", isTypeVariableParamTag=\" + isTypeVariableParamTag\n-                    + \", utils=\" + utils + '}';\n+    \/\/ We see both overridden and implemented methods as overridden\n+    \/\/ (see JLS 8.4.8.1. Overriding (by Instance Methods))\n+    private Iterator<ExecutableElement> methodsOverriddenBy(ExecutableElement method) {\n+        \/\/ TODO: create a lazy iterator if required\n+        var list = new ArrayList<ExecutableElement>();\n+        ExecutableElement overridden = overriddenMethodLookup.apply(method);\n+        if (overridden != null) {\n+            list.add(overridden);\n@@ -157,0 +148,2 @@\n+        implementedMethodsLookup.apply(method, method).forEach(list::add);\n+        return list.iterator();\n@@ -159,2 +152,9 @@\n-    \/**\n-     * The class that encapsulates the output.\n+    private static final Result<?> SKIP = new Skipped<>();\n+    private static final Result<?> CONTINUE = new Continued<>();\n+\n+    \/*\n+     * Use static factory methods to get the desired result to return from\n+     * Criterion. Use instanceof to check for a result type returned from\n+     * a search. If a use case permits and you prefer Optional API, use\n+     * the fromOptional\/toOptional convenience methods to get and\n+     * check for the result respectively.\n@@ -162,1 +162,1 @@\n-    public static class Output {\n+    public sealed interface Result<T> {\n@@ -164,5 +164,1 @@\n-        \/**\n-         * The tag that holds the documentation.  Null if documentation\n-         * is not held by a tag.\n-         *\/\n-        public DocTree holderTag;\n+        sealed interface Skip<T> extends Result<T> permits Skipped { }\n@@ -170,2 +166,11 @@\n-        \/**\n-         * The element that holds the documentation.\n+        sealed interface Continue<T> extends Result<T> permits Continued { }\n+\n+        sealed interface Conclude<T> extends Result<T> permits Concluded {\n+\n+            T value();\n+        }\n+\n+        \/*\n+         * Skips the search on the part of the hierarchy above the method for\n+         * which this result is returned and continues the search from that\n+         * method sibling, if any.\n@@ -173,1 +178,4 @@\n-        public Element holder;\n+        @SuppressWarnings(\"unchecked\")\n+        static <T> Result<T> SKIP() {\n+            return (Result<T>) SKIP;\n+        }\n@@ -175,2 +183,2 @@\n-        \/**\n-         * The inherited documentation.\n+        \/*\n+         * Continues the search.\n@@ -178,1 +186,4 @@\n-        public List<? extends DocTree> inlineTags = List.of();\n+        @SuppressWarnings(\"unchecked\")\n+        static <T> Result<T> CONTINUE() {\n+            return (Result<T>) CONTINUE;\n+        }\n@@ -180,2 +191,2 @@\n-        \/**\n-         * False if documentation could not be inherited.\n+        \/*\n+         * Concludes the search with the given result.\n@@ -183,1 +194,3 @@\n-        public boolean isValidInheritDocTag = true;\n+        static <T> Result<T> CONCLUDE(T value) {\n+            return new Concluded<>(value);\n+        }\n@@ -185,6 +198,6 @@\n-        \/**\n-         * When automatically inheriting throws tags, you sometimes must inherit\n-         * more than one tag.  For example, if a method declares that it throws\n-         * IOException and the overridden method has {@code @throws} tags for IOException and\n-         * ZipException, both tags would be inherited because ZipException is a\n-         * subclass of IOException.  This allows multiple tag inheritance.\n+        \/*\n+         * Translates this Result into Optional.\n+         *\n+         * Convenience method. Call on the result of a search if you are only\n+         * interested in whether the search succeeded or failed and you\n+         * prefer the Optional API.\n@@ -192,1 +205,3 @@\n-        public final List<DocTree> tagList = new ArrayList<>();\n+        default Optional<T> toOptional() {\n+            return Optional.empty();\n+        }\n@@ -194,2 +209,6 @@\n-        \/**\n-         * For debugging purposes.\n+        \/*\n+         * Translates the given Optional into a binary decision whether to\n+         * conclude the search or continue it.\n+         *\n+         * Convenience method. Use in Criterion that can easily provide\n+         * suitable Optional. Don't use if Criterion needs to skip.\n@@ -197,8 +216,2 @@\n-        @Override\n-        public String toString() {\n-            String encl = holder == null ? \"\" : holder.getEnclosingElement().toString() + \"::\";\n-            return \"Output{\" + \"holderTag=\" + holderTag\n-                    + \", holder=\" + encl + holder\n-                    + \", inlineTags=\" + inlineTags\n-                    + \", isValidInheritDocTag=\" + isValidInheritDocTag\n-                    + \", tagList=\" + tagList + '}';\n+        static <T> Result<T> fromOptional(Optional<T> optional) {\n+            return optional.map(Result::CONCLUDE).orElseGet(Result::CONTINUE);\n@@ -208,23 +221,7 @@\n-    \/**\n-     * Search for the requested comments in the given element.  If it does not\n-     * have comments, return the inherited comments if possible.\n-     *\n-     * @param input the input object used to perform the search.\n-     *\n-     * @return an Output object representing the documentation that was found.\n-     *\/\n-    public static Output search(BaseConfiguration configuration, Input input) {\n-        Output output = new Output();\n-        Utils utils = configuration.utils;\n-        if (input.isInheritDocTag) {\n-            \/\/Do nothing because \"element\" does not have any documentation.\n-            \/\/All it has is {@inheritDoc}.\n-        } else if (input.taglet == null) {\n-            \/\/We want overall documentation.\n-            output.inlineTags = input.isFirstSentence\n-                    ? utils.getFirstSentenceTrees(input.element)\n-                    : utils.getFullBody(input.element);\n-            output.holder = input.element;\n-        } else {\n-            input.taglet.inherit(input, output);\n-        }\n+    \/\/ Note: we hide records behind interfaces, as implementation detail.\n+    \/\/ We don't directly implement Result with these records because it\n+    \/\/ would require more exposure and commitment than is desired. For\n+    \/\/ example, there would need to be public constructors, which\n+    \/\/ would circumvent static factory methods.\n+\n+    private record Skipped<T>() implements DocFinder.Result.Skip<T> { }\n@@ -232,2 +229,6 @@\n-        if (!output.inlineTags.isEmpty()) {\n-            return output;\n+    private record Continued<T>() implements DocFinder.Result.Continue<T> { }\n+\n+    private record Concluded<T>(T value) implements DocFinder.Result.Conclude<T> {\n+\n+        Concluded {\n+            Objects.requireNonNull(value);\n@@ -235,25 +236,4 @@\n-        output.isValidInheritDocTag = false;\n-        Input inheritedSearchInput = input.copy();\n-        inheritedSearchInput.isInheritDocTag = false;\n-        if (utils.isMethod(input.element)) {\n-            ExecutableElement m = (ExecutableElement) input.element;\n-            ExecutableElement overriddenMethod = utils.overriddenMethod(m);\n-            if (overriddenMethod != null) {\n-                inheritedSearchInput.element = overriddenMethod;\n-                output = search(configuration, inheritedSearchInput);\n-                output.isValidInheritDocTag = true;\n-                if (!output.inlineTags.isEmpty()) {\n-                    return output;\n-                }\n-            }\n-            TypeElement encl = utils.getEnclosingTypeElement(input.element);\n-            VisibleMemberTable vmt = configuration.getVisibleMemberTable(encl);\n-            List<ExecutableElement> implementedMethods = vmt.getImplementedMethods(m);\n-            for (ExecutableElement implementedMethod : implementedMethods) {\n-                inheritedSearchInput.element = implementedMethod;\n-                output = search(configuration, inheritedSearchInput);\n-                output.isValidInheritDocTag = true;\n-                if (!output.inlineTags.isEmpty()) {\n-                    return output;\n-                }\n-            }\n+\n+        @Override\n+        public Optional<T> toOptional() {\n+            return Optional.of(value);\n@@ -261,1 +241,0 @@\n-        return output;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/DocFinder.java","additions":173,"deletions":194,"binary":false,"changes":367,"status":"modified"},{"patch":"@@ -141,0 +141,1 @@\n+    private final DocFinder docFinder = newDocFinder();\n@@ -1917,0 +1918,3 @@\n+    \/\/ If `e` is a static nested class, this method will return e's simple name\n+    \/\/ preceded by `.` and an outer type; this is not how JLS defines \"simple\n+    \/\/ name\". See \"Simple Name\", \"Qualified Name\", \"Fully Qualified Name\".\n@@ -1930,1 +1934,1 @@\n-                            && (enclosed.getKind().isClass() || enclosed.getKind().isInterface())) {\n+                            && (enclosed.getKind().isDeclaredType())) {\n@@ -2799,0 +2803,12 @@\n+    public DocFinder docFinder() {\n+        return docFinder;\n+    }\n+\n+    private DocFinder newDocFinder() {\n+        return new DocFinder(this::overriddenMethod, this::implementedMethods);\n+    }\n+\n+    private Iterable<ExecutableElement> implementedMethods(ExecutableElement originalMethod, ExecutableElement m) {\n+        var type = configuration.utils.getEnclosingTypeElement(m);\n+        return configuration.getVisibleMemberTable(type).getImplementedMethods(originalMethod);\n+    }\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/Utils.java","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -188,1 +188,1 @@\n-                    <dd><code>HeadlessException<\/code><\/dd>\n+                    <dd><code>java.awt.HeadlessException<\/code><\/dd>\n@@ -307,1 +307,1 @@\n-                    <dd><code>HeadlessException<\/code><\/dd>\n+                    <dd><code>java.awt.HeadlessException<\/code><\/dd>\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testHtmlDefinitionListTag\/TestHtmlDefinitionListTag.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -77,1 +77,1 @@\n-     * @exception HeadlessException\n+     * @exception java.awt.HeadlessException\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testHtmlDefinitionListTag\/pkg1\/C1.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-        for (int i = 1; i < 40; i++) {\n+        for (int i = 1; i < 38; i++) {\n@@ -62,0 +62,6 @@\n+        \/\/Test valid usage of inheritDoc tag.\n+        for (int i = 100; i < 101; i++) { \/\/ bad\n+            checkOutput(\"pkg\/TestTagInheritance.html\", false,\n+                    \"Test \" + i + \" fails\");\n+        }\n+\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testTagInheritance\/TestTagInheritance.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2003, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -69,1 +69,0 @@\n-     * @throws java.util.zip.ZipException Test 39 passes.\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testTagInheritance\/pkg\/TestAbstractClass.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,1 @@\n-     * @throws java.lang.NullPointerException Test 38 passes.\n+     * @throws java.lang.NullPointerException Test 101 fails.\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testTagInheritance\/pkg\/TestSuperSuperClass.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,18 @@\n+    \/\/ NOTE: Not sure why this test suggests that IndexOutOfBoundsException\n+    \/\/ should not appear due to compatibility with some buggy behavior.\n+    \/\/\n+    \/\/ Here's the expected behavior: documentation for an exception X is never\n+    \/\/ inherited by an overrider unless it \"pulls\" it by either (or both)\n+    \/\/ of these:\n+    \/\/\n+    \/\/   * tag:\n+    \/\/       @throws X {@inheritDoc}\n+    \/\/   * clause:\n+    \/\/       throws ..., X,...\n+    \/\/\n+    \/\/ Neither of those are applicable here. Even taking into account\n+    \/\/ mechanisms such as the one introduced in 4947455, neither of\n+    \/\/ NullPointerException and IndexOutOfBoundsException is a subclass\n+    \/\/ of the other.\n+    \/\/\n+    \/\/ So, IndexOutOfBoundsException should not appear in Extender.\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testThrowsInheritance\/pkg\/Abstract.java","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -0,0 +1,489 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8291869\n+ * @library \/tools\/lib ..\/..\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ *          jdk.javadoc\/jdk.javadoc.internal.tool\n+ * @build toolbox.ToolBox javadoc.tester.*\n+ * @run main TestExceptionTypeMatching\n+ *\/\n+\n+import javadoc.tester.JavadocTester;\n+import toolbox.ToolBox;\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+\n+\/*\n+ * The goal of the tests in this suite is two-fold:\n+ *\n+ * 1. Provoke javadoc into treating like-named but different elements as\n+ *    the same element\n+ * 2. Provoke javadoc into treating differently named but semantically\n+ *    same elements as different elements\n+ *\/\n+public class TestExceptionTypeMatching extends JavadocTester {\n+\n+    public static void main(String... args) throws Exception {\n+        var tester = new TestExceptionTypeMatching();\n+        tester.runTests(m -> new Object[]{Paths.get(m.getName())});\n+    }\n+\n+    private final ToolBox tb = new ToolBox();\n+\n+    \/*\n+     * In Child, MyException is c.MyException, whereas in Parent, MyException\n+     * is p.MyException. Those are different exceptions which happen to\n+     * share the simple name.\n+     *\/\n+    @Test\n+    public void testDifferentPackages(Path base) throws Exception {\n+        var src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src, \"\"\"\n+                package c;\n+\n+                import p.Parent;\n+\n+                public class Child extends Parent {\n+\n+                    \/** @throws MyException {@inheritDoc} *\/\n+                    @Override\n+                    public void m() { }\n+                }\n+                \"\"\", \"\"\"\n+                package c;\n+\n+                public class MyException extends RuntimeException { }\n+\n+                \"\"\", \"\"\"\n+                package p;\n+\n+                public class Parent {\n+\n+                    \/** @throws MyException sometimes *\/\n+                    public void m() { }\n+                }\n+                \"\"\", \"\"\"\n+                package p;\n+\n+                public class MyException extends RuntimeException { }\n+                \"\"\");\n+        javadoc(\"-d\", base.resolve(\"out\").toString(), \"-sourcepath\", src.toString(), \"c\", \"p\");\n+        checkExit(Exit.OK);\n+        checkOutput(Output.OUT, true, \"\"\"\n+                Child.java:7: warning: overridden methods do not document exception type c.MyException \\\n+                (MODULE <unnamed module> PACKAGE c CLASS MyException)\n+                    \/** @throws MyException {@inheritDoc} *\/\n+                        ^\n+                \"\"\");\n+    }\n+\n+    \/*\n+     * Type parameters declared by methods where one of the methods overrides\n+     * the other, are matched by position, not by name. In this example, <P>\n+     * and <R> are semantically the same.\n+     *\/\n+    @Test\n+    public void testDifferentTypeVariables1(Path base) throws Exception {\n+        var src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src, \"\"\"\n+                package x;\n+\n+                public class Parent {\n+\n+                    \/** @throws P sometimes *\/\n+                    public <P extends RuntimeException> void m() { }\n+                }\n+                \"\"\", \"\"\"\n+                package x;\n+\n+                public class Child extends Parent {\n+\n+                    \/** @throws R {@inheritDoc} *\/\n+                    @Override\n+                    public <R extends RuntimeException> void m() { }\n+                }\n+                \"\"\");\n+        javadoc(\"-d\", base.resolve(\"out\").toString(), \"-sourcepath\", src.toString(), \"x\");\n+        checkExit(Exit.OK);\n+        checkOutput(\"x\/Child.html\", true, \"\"\"\n+                <dl class=\"notes\">\n+                <dt>Overrides:<\/dt>\n+                <dd><code><a href=\"Parent.html#m()\">m<\/a><\/code>&nbsp;in class&nbsp;<code>\\\n+                <a href=\"Parent.html\" title=\"class in x\">Parent<\/a><\/code><\/dd>\n+                <dt>Throws:<\/dt>\n+                <dd><code>R<\/code> - sometimes<\/dd>\n+                <\/dl>\n+                \"\"\");\n+    }\n+\n+    \/*\n+     * Type parameters declared by methods where one of the methods overrides\n+     * the other, are matched by position, not by name.\n+     *\n+     * Here the match is criss-cross:\n+     *\n+     *   - Child.m's <K> corresponds to Parent.m's <V>\n+     *   - Child.m's <V> corresponds to Parent.m's <K>\n+     *\/\n+    @Test\n+    public void testDifferentTypeVariables2(Path base) throws Exception {\n+        var src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src, \"\"\"\n+                package x;\n+\n+                public class Parent {\n+\n+                    \/**\n+                     * @throws K some of the times\n+                     * @throws V other times\n+                     *\/\n+                    public <K extends RuntimeException, V extends RuntimeException> void m() { }\n+                }\n+                \"\"\", \"\"\"\n+                package x;\n+\n+                public class Child extends Parent {\n+\n+                    \/**\n+                     * @throws K {@inheritDoc}\n+                     * @throws V {@inheritDoc}\n+                     *\/\n+                    @Override\n+                    public <V extends RuntimeException, K extends RuntimeException> void m() { }\n+                }\n+                \"\"\");\n+        javadoc(\"-d\", base.resolve(\"out\").toString(), \"-sourcepath\", src.toString(), \"x\");\n+        checkExit(Exit.OK);\n+        checkOutput(\"x\/Child.html\", true, \"\"\"\n+                <dl class=\"notes\">\n+                <dt>Overrides:<\/dt>\n+                <dd><code><a href=\"Parent.html#m()\">m<\/a><\/code>&nbsp;in class&nbsp;<code>\\\n+                <a href=\"Parent.html\" title=\"class in x\">Parent<\/a><\/code><\/dd>\n+                <dt>Throws:<\/dt>\n+                <dd><code>K<\/code> - other times<\/dd>\n+                <dd><code>V<\/code> - some of the times<\/dd>\n+                <\/dl>\n+                \"\"\");\n+    }\n+\n+    \/*\n+     * X is unknown to Child.m as it isn't defined by Child.m and\n+     * type parameters declared by methods are not inherited.\n+     *\/\n+    @Test\n+    public void testUndefinedTypeParameter(Path base) throws Exception {\n+        var src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src, \"\"\"\n+                package x;\n+\n+                public class Parent {\n+\n+                    \/** @throws T sometimes *\/\n+                    public <T extends RuntimeException> void m() { }\n+                }\n+                \"\"\", \"\"\"\n+                package x;\n+\n+                public class Child extends Parent {\n+\n+                    \/** @throws T {@inheritDoc} *\/\n+                    @Override\n+                    public void m() { }\n+                }\n+                \"\"\");\n+        \/\/ turn off DocLint so that it does not interfere with diagnostics\n+        \/\/ by raising an error for the condition we are testing:\n+        \/\/\n+        \/\/ Child.java:5: error: reference not found\n+        \/\/    \/** @throws T {@inheritDoc} *\/\n+        \/\/        ^\n+        javadoc(\"-d\", base.resolve(\"out\").toString(), \"-sourcepath\", src.toString(), \"x\", \"-Xdoclint:none\");\n+        checkExit(Exit.OK);\n+        checkOutput(Output.OUT, true, \"\"\"\n+                Child.java:5: warning: cannot find exception type by name\n+                    \/** @throws T {@inheritDoc} *\/\n+                                ^\n+                \"\"\");\n+    }\n+\n+    \/\/ A related (but separate from this test suite) test. This test is\n+    \/\/ introduced here because it tests for the error condition that is\n+    \/\/ detected by JDK-8291869, which is tested by tests in this test\n+    \/\/ suite.\n+    \/\/ TODO: consider moving this test to a more suitable test suite.\n+    @Test\n+    public void testWrongType(Path base) throws Exception {\n+        var src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src, \"\"\"\n+                package x;\n+\n+                public class MyClass {\n+\n+                    \/** @throws OtherClass description *\/\n+                    public void m() { }\n+                }\n+                \"\"\", \"\"\"\n+                package x;\n+\n+                public class OtherClass { }\n+                \"\"\");\n+        \/\/ turn off DocLint so that it does not interfere with diagnostics\n+        \/\/ by raising an error for the condition we are testing\n+        javadoc(\"-d\", base.resolve(\"out\").toString(), \"-sourcepath\", src.toString(), \"x\", \"-Xdoclint:none\");\n+        checkExit(Exit.OK);\n+        checkOutput(Output.OUT, true, \"\"\"\n+                MyClass.java:5: warning: type found is not of exception type: \\\n+                x.OtherClass (MODULE <unnamed module> PACKAGE x CLASS OtherClass)\n+                    \/** @throws OtherClass description *\/\n+                                ^\n+                \"\"\");\n+        checkOutput(\"x\/MyClass.html\", false, \"\"\"\n+                <dl class=\"notes\">\n+                <dt>Throws:<\/dt>\n+                <dd><code><a href=\"OtherClass.html\" title=\"class in x\">OtherClass<\/a><\/code> - description<\/dd>\n+                <\/dl>\n+                \"\"\");\n+    }\n+\n+    \/\/ A related (but separate from this test suite) test. This test is\n+    \/\/ introduced here because it tests for the error condition that is\n+    \/\/ detected by JDK-8291869, which is tested by tests in this test\n+    \/\/ suite.\n+    \/\/ TODO: consider moving this test to a more suitable test suite.\n+    @Test\n+    public void testExceptionTypeNotFound(Path base) throws Exception {\n+        var src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src, \"\"\"\n+                package x;\n+\n+                public class MyClass {\n+\n+                    \/** @throws un1queEn0ughS0asT0N0tBeF0und description *\/\n+                    public void m() { }\n+                }\n+                \"\"\");\n+        \/\/ turn off DocLint so that it does not interfere with diagnostics\n+        \/\/ by raising an error for the condition we are testing\n+        javadoc(\"-d\", base.resolve(\"out\").toString(), \"-sourcepath\", src.toString(), \"x\", \"-Xdoclint:none\");\n+        checkExit(Exit.OK);\n+        checkOutput(Output.OUT, true, \"\"\"\n+                MyClass.java:5: warning: cannot find exception type by name\n+                    \/** @throws un1queEn0ughS0asT0N0tBeF0und description *\/\n+                                ^\n+                \"\"\");\n+    }\n+\n+    \/*\n+     * In Child, R is a class residing in an unnamed package, whereas\n+     * in Parent, R is a type variable.\n+     *\/\n+    @Test\n+    public void testTypeAndTypeParameter(Path base) throws Exception {\n+        var src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src, \"\"\"\n+                public class Parent {\n+\n+                    \/** @throws R sometimes *\/\n+                    public <R extends RuntimeException> void m() { }\n+                }\n+                \"\"\", \"\"\"\n+                public class Child extends Parent {\n+\n+                    \/** @throws R {@inheritDoc} *\/\n+                    @Override public void m() { }\n+                }\n+                \"\"\", \"\"\"\n+                public class R extends RuntimeException { }\n+                \"\"\");\n+        javadoc(\"-d\", base.resolve(\"out\").toString(), src.resolve(\"Parent.java\").toString(),\n+                src.resolve(\"Child.java\").toString(), src.resolve(\"R.java\").toString());\n+        checkExit(Exit.OK);\n+        checkOutput(Output.OUT, true, \"\"\"\n+                Child.java:3: warning: overridden methods do not document exception type R \\\n+                (MODULE <unnamed module> PACKAGE <unnamed package> CLASS R)\n+                    \/** @throws R {@inheritDoc} *\/\n+                        ^\n+                \"\"\");\n+        checkOutput(\"Child.html\", false, \"\"\"\n+                <dl class=\"notes\">\n+                <dt>Overrides:<\/dt>\n+                <dd><code><a href=\"Parent.html#m()\">m<\/a><\/code>&nbsp;in class&nbsp;<code>\\\n+                <a href=\"Parent.html\" title=\"class in Unnamed Package\">Parent<\/a><\/code><\/dd>\n+                <dt>Throws:<\/dt>\n+                <dd><code><a href=\"R.html\" title=\"class in Unnamed Package\">R<\/a><\/code> - sometimes<\/dd>\n+                <\/dl>\"\"\");\n+        checkOutput(\"Child.html\", false, \"\"\"\n+                <dl class=\"notes\">\n+                <dt>Overrides:<\/dt>\n+                <dd><code><a href=\"Parent.html#m()\">m<\/a><\/code>&nbsp;in class&nbsp;<code>\\\n+                <a href=\"Parent.html\" title=\"class in Unnamed Package\">Parent<\/a><\/code><\/dd>\n+                <dt>Throws:<\/dt>\n+                <dd><code>R<\/code> - sometimes<\/dd>\n+                <\/dl>\"\"\");\n+    }\n+\n+    \/*\n+     * There are two different exceptions that share the same simple name:\n+     *\n+     *   1. P.MyException (a nested static class in an unnamed package)\n+     *   2. P.MyException (a public class in the P package)\n+     *\n+     * Although unconventional, it is not prohibited for a package name to\n+     * start with an upper case letter. This test disregards that\n+     * convention for the setup to work: the package and the\n+     * class should have the same FQN to be confusing.\n+     *\n+     * A permissible but equally unconventional alternative would be to\n+     * keep the package lower-case but give the class a lower-case name p.\n+     *\n+     * This setup works likely because of JLS 6.3. Scope of a Declaration:\n+     *\n+     *     The scope of a top level class or interface (7.6) is all class\n+     *     and interface declarations in the package in which the top\n+     *     level class or interface is declared.\n+     *\/\n+    @Test\n+    public void testOuterClassAndPackage(Path base) throws Exception {\n+        var src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src, \"\"\"\n+                package P;\n+\n+                public class MyException extends RuntimeException { }\n+                \"\"\", \"\"\"\n+                package pkg;\n+\n+                public class Parent {\n+\n+                    \/** @throws P.MyException sometimes *\/\n+                    public void m() { }\n+                }\n+                \"\"\", \"\"\"\n+                public class Child extends pkg.Parent {\n+\n+                    \/** @throws P.MyException {@inheritDoc} *\/\n+                    @Override\n+                    public void m() { }\n+                }\n+                \"\"\", \"\"\"\n+                public class P {\n+                    public static class MyException extends RuntimeException { }\n+                }\n+                \"\"\");\n+        setAutomaticCheckLinks(false); \/\/ otherwise the link checker reports that P.MyException is defined twice\n+        javadoc(\"-d\",\n+                base.resolve(\"out\").toString(),\n+                src.resolve(\"P\").resolve(\"MyException.java\").toString(),\n+                src.resolve(\"pkg\").resolve(\"Parent.java\").toString(),\n+                src.resolve(\"Child.java\").toString(),\n+                src.resolve(\"P.java\").toString());\n+        checkExit(Exit.OK);\n+        checkOutput(Output.OUT, true, \"\"\"\n+                Child.java:3: warning: overridden methods do not document exception type P.MyException \\\n+                (MODULE <unnamed module> PACKAGE <unnamed package> CLASS P CLASS MyException)\n+                    \/** @throws P.MyException {@inheritDoc} *\/\n+                        ^\n+                \"\"\");\n+        checkOutput(\"Child.html\", false, \"\"\"\n+                <dl class=\"notes\">\n+                <dt>Overrides:<\/dt>\n+                <dd><code><a href=\"pkg\/Parent.html#m()\">m<\/a><\/code>&nbsp;in class&nbsp;<code>\\\n+                <a href=\"pkg\/Parent.html\" title=\"class in pkg\">Parent<\/a><\/code><\/dd>\n+                <dt>Throws:<\/dt>\n+                <dd><code><a href=\"P.MyException.html\" title=\"class in Unnamed Package\">P.MyException<\/a><\/code> - sometimes<\/dd>\n+                <\/dl>\"\"\");\n+        checkOutput(\"Child.html\", false, \"P\/MyException.html\");\n+    }\n+\n+    \/*\n+     * It's unclear how to match type parameters that aren't declared by\n+     * a method. For example, consider that for B to be a subtype of A,\n+     * it is not necessary for A and B to have the same number or\n+     * types of type parameters.\n+     *\n+     * For that reason, exception documentation inheritance involving\n+     * such parameters is currently unsupported. This test simply\n+     * checks that we produce helpful warnings.\n+     *\/\n+    @Test\n+    public void testGenericTypes(Path base) throws Exception {\n+        var src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src, \"\"\"\n+                package x;\n+\n+                public class Parent<T extends RuntimeException> {\n+\n+                    \/** @throws T description *\/\n+                    public void m() { }\n+                }\n+                \"\"\", \"\"\"\n+                package x;\n+\n+                public class Child1<T extends RuntimeException> extends Parent<T> {\n+\n+                    \/** @throws T {@inheritDoc} *\/\n+                    @Override public void m() { }\n+                }\n+                \"\"\", \"\"\"\n+                package x;\n+\n+                public class Child2<T extends IllegalArgumentException> extends Parent<T> {\n+\n+                    \/** @throws T {@inheritDoc} *\/\n+                    @Override public void m() { }\n+                }\n+                \"\"\", \"\"\"\n+                package x;\n+\n+                public class Child3 extends Parent<NullPointerException> {\n+\n+                    \/** @throws NullPointerException {@inheritDoc} *\/\n+                    @Override public void m() { }\n+                }\n+                \"\"\");\n+        javadoc(\"-d\", base.resolve(\"out\").toString(), \"-sourcepath\", src.toString(), \"x\");\n+        checkExit(Exit.OK);\n+        checkOutput(Output.OUT, true, \"\"\"\n+                Child1.java:5: warning: @inheritDoc for exception-type type parameters not declared by a method is unsupported; \\\n+                document such exception types directly\n+                    \/** @throws T {@inheritDoc} *\/\n+                                ^\n+                \"\"\");\n+        checkOutput(Output.OUT, true, \"\"\"\n+                Child2.java:5: warning: @inheritDoc for exception-type type parameters not declared by a method is unsupported; \\\n+                document such exception types directly\n+                    \/** @throws T {@inheritDoc} *\/\n+                                ^\n+                \"\"\");\n+        checkOutput(Output.OUT, true, \"\"\"\n+                Child3.java:5: warning: overridden methods do not document exception type java.lang.NullPointerException \\\n+                (MODULE java.base PACKAGE java.lang CLASS NullPointerException)\n+                    \/** @throws NullPointerException {@inheritDoc} *\/\n+                        ^\n+                    \"\"\");\n+    }\n+}\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testThrowsInheritanceMatching\/TestExceptionTypeMatching.java","additions":489,"deletions":0,"binary":false,"changes":489,"status":"added"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8067757 6509045\n+ * @bug 8067757 6509045 8295277\n@@ -567,0 +567,174 @@\n+\n+    @Test\n+    public void testDeeperError(Path base) throws Exception {\n+        var src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src, \"\"\"\n+                package x;\n+\n+                public class MyRuntimeException extends RuntimeException { }\n+                \"\"\", \"\"\"\n+                package x;\n+\n+                public interface I {\n+\n+                    \/**\n+                     * @throws MyRuntimeException sometimes\n+                     * @throws MyRuntimeException rarely\n+                     *\/\n+                    void m();\n+                }\n+                \"\"\", \"\"\"\n+                package x;\n+\n+                public interface I1 extends I {\n+\n+                    \/**\n+                     * @throws MyRuntimeException \"{@inheritDoc}\"\n+                     *\/\n+                    @Override\n+                    void m();\n+                }\n+                \"\"\", \"\"\"\n+                package x;\n+\n+                public interface I2 extends I1 {\n+\n+                    \/**\n+                     * @throws MyRuntimeException '{@inheritDoc}'\n+                     *\/\n+                    @Override\n+                    void m();\n+                }\n+                \"\"\");\n+        javadoc(\"-d\", base.resolve(\"out\").toString(),\n+                \"-sourcepath\", src.toString(),\n+                \"x\");\n+        checkExit(Exit.ERROR);\n+        new OutputChecker(Output.OUT)\n+                .setExpectFound(true)\n+                .checkAnyOf(\n+                        \"\"\"\n+                        I2.java:6: error: @inheritDoc cannot be used within this tag\n+                             * @throws MyRuntimeException '{@inheritDoc}'\n+                               ^\"\"\",\n+                        \"\"\"\n+                        I1.java:6: error: @inheritDoc cannot be used within this tag\n+                             * @throws MyRuntimeException \"{@inheritDoc}\"\n+                               ^\"\"\");\n+    }\n+\n+    @Test\n+    public void testFullExpansion(Path base) throws Exception {\n+        var src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src, \"\"\"\n+                package x;\n+\n+                public class MyRuntimeException extends RuntimeException { }\n+                \"\"\", \"\"\"\n+                package x;\n+\n+                public interface Child extends Parent {\n+\n+                    \/**\n+                     * @throws MyRuntimeException child 1\n+                     * @throws MyRuntimeException {@inheritDoc}\n+                     *\/\n+                    @Override void m();\n+                }\n+                \"\"\", \"\"\"\n+                package x;\n+\n+                public interface Parent extends GrandParent {\n+\n+                    \/**\n+                     * @throws MyRuntimeException parent 1\n+                     * @throws MyRuntimeException {@inheritDoc}\n+                     *\/\n+                    @Override void m();\n+                }\n+                \"\"\", \"\"\"\n+                package x;\n+\n+                public interface GrandParent {\n+\n+                    \/**\n+                     * @throws MyRuntimeException grandparent 1\n+                     * @throws MyRuntimeException grandparent 2\n+                     *\/\n+                    void m();\n+                }\n+                \"\"\");\n+        javadoc(\"-d\", base.resolve(\"out\").toString(),\n+                \"-sourcepath\", src.toString(),\n+                \"x\");\n+        checkExit(Exit.OK);\n+        checkOutput(\"x\/Child.html\", true, \"\"\"\n+                <dl class=\"notes\">\n+                <dt>Specified by:<\/dt>\n+                <dd><code><a href=\"GrandParent.html#m()\">m<\/a><\/code>&nbsp;in interface&nbsp;<code><a href=\"GrandParent.html\" title=\"interface in x\">GrandParent<\/a><\/code><\/dd>\n+                <dt>Specified by:<\/dt>\n+                <dd><code><a href=\"Parent.html#m()\">m<\/a><\/code>&nbsp;in interface&nbsp;<code><a href=\"Parent.html\" title=\"interface in x\">Parent<\/a><\/code><\/dd>\n+                <dt>Throws:<\/dt>\n+                <dd><code><a href=\"MyRuntimeException.html\" title=\"class in x\">MyRuntimeException<\/a><\/code> - child 1<\/dd>\n+                <dd><code><a href=\"MyRuntimeException.html\" title=\"class in x\">MyRuntimeException<\/a><\/code> - parent 1<\/dd>\n+                <dd><code><a href=\"MyRuntimeException.html\" title=\"class in x\">MyRuntimeException<\/a><\/code> - grandparent 1<\/dd>\n+                <dd><code><a href=\"MyRuntimeException.html\" title=\"class in x\">MyRuntimeException<\/a><\/code> - grandparent 2<\/dd>\n+                <\/dl>\n+                <\/section>\n+                \"\"\");\n+    }\n+\n+    @Test\n+    public void testChainEmbeddedInheritDoc(Path base) throws Exception {\n+        var src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src, \"\"\"\n+                package x;\n+\n+                public class MyRuntimeException extends RuntimeException { }\n+                \"\"\", \"\"\"\n+                package x;\n+\n+                public interface Child extends Parent {\n+\n+                    \/**\n+                     * @throws MyRuntimeException \"{@inheritDoc}\"\n+                     *\/\n+                    @Override void m();\n+                }\n+                \"\"\", \"\"\"\n+                package x;\n+\n+                public interface Parent extends GrandParent {\n+\n+                    \/**\n+                     * @throws MyRuntimeException '{@inheritDoc}'\n+                     *\/\n+                    @Override void m();\n+                }\n+                \"\"\", \"\"\"\n+                package x;\n+\n+                public interface GrandParent {\n+\n+                    \/**\n+                     * @throws MyRuntimeException grandparent\n+                     *\/\n+                    void m();\n+                }\n+                \"\"\");\n+        javadoc(\"-d\", base.resolve(\"out\").toString(),\n+                \"-sourcepath\", src.toString(),\n+                \"x\");\n+        checkExit(Exit.OK);\n+        checkOutput(\"x\/Child.html\", true, \"\"\"\n+                <dl class=\"notes\">\n+                <dt>Specified by:<\/dt>\n+                <dd><code><a href=\"GrandParent.html#m()\">m<\/a><\/code>&nbsp;in interface&nbsp;<code><a href=\"GrandParent.html\" title=\"interface in x\">GrandParent<\/a><\/code><\/dd>\n+                <dt>Specified by:<\/dt>\n+                <dd><code><a href=\"Parent.html#m()\">m<\/a><\/code>&nbsp;in interface&nbsp;<code><a href=\"Parent.html\" title=\"interface in x\">Parent<\/a><\/code><\/dd>\n+                <dt>Throws:<\/dt>\n+                <dd><code><a href=\"MyRuntimeException.html\" title=\"class in x\">MyRuntimeException<\/a><\/code> - \"'grandparent'\"<\/dd>\n+                <\/dl>\n+                <\/section>\n+                \"\"\");\n+    }\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testThrowsInheritanceMultiple\/TestOneToMany.java","additions":175,"deletions":1,"binary":false,"changes":176,"status":"modified"},{"patch":"@@ -45,1 +45,0 @@\n-     * @throws DoesNotExist   oops, javadoc does not see this\n","filename":"test\/langtools\/jdk\/javadoc\/tool\/6964914\/TestStdDoclet.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}