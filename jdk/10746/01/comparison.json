{"files":[{"patch":"@@ -801,2 +801,2 @@\n-    @Override\n-    public Content throwsTagOutput(Element element, ThrowsTree throwsTag, TypeMirror substituteType) {\n+    @Deprecated(forRemoval = true)\n+    private Content throwsTagOutput(Element element, ThrowsTree throwsTag, TypeMirror substituteType) {\n@@ -808,1 +808,1 @@\n-           excName = htmlWriter.getLink(new HtmlLinkInfo(configuration, HtmlLinkInfo.Kind.MEMBER,\n+            excName = htmlWriter.getLink(new HtmlLinkInfo(configuration, HtmlLinkInfo.Kind.MEMBER,\n@@ -811,1 +811,1 @@\n-            excName = RawHtml.of(throwsTag.getExceptionName().toString());\n+            excName = Text.of(throwsTag.getExceptionName().toString());\n@@ -831,3 +831,10 @@\n-    public Content throwsTagOutput(TypeMirror throwsType) {\n-        return HtmlTree.DD(HtmlTree.CODE(htmlWriter.getLink(\n-                new HtmlLinkInfo(configuration, HtmlLinkInfo.Kind.MEMBER, throwsType))));\n+    public Content throwsTagOutput(TypeMirror throwsType, Optional<Content> content) {\n+        var linkInfo = new HtmlLinkInfo(configuration, HtmlLinkInfo.Kind.MEMBER, throwsType);\n+        linkInfo.excludeTypeBounds = true;\n+        var link = htmlWriter.getLink(linkInfo);\n+        var concat = new ContentBuilder(HtmlTree.CODE(link));\n+        if (content.isPresent()) {\n+            concat.add(\" - \");\n+            concat.add(content.get());\n+        }\n+        return HtmlTree.DD(concat);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/TagletWriterImpl.java","additions":14,"deletions":7,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -109,0 +109,2 @@\n+doclet.throws.reference_not_found=cannot find exception type by name\n+doclet.throws.reference_bad_type=type found is not of exception type: {0}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/resources\/standard.properties","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import java.util.Optional;\n@@ -263,11 +264,9 @@\n-                List<? extends DocTree> firstSentenceTags = utils.getFirstSentenceTrees(member);\n-                if (utils.isMethod(member) && firstSentenceTags.isEmpty()) {\n-                    \/\/Inherit comments from overridden or implemented method if\n-                    \/\/necessary.\n-                    DocFinder.Output inheritedDoc =\n-                            DocFinder.search(configuration,\n-                                    new DocFinder.Input(utils, member));\n-                    if (inheritedDoc.holder != null\n-                            && !utils.getFirstSentenceTrees(inheritedDoc.holder).isEmpty()) {\n-                        firstSentenceTags = utils.getFirstSentenceTrees(inheritedDoc.holder);\n-                    }\n+                if (utils.isMethod(member)) {\n+                    var docFinder = utils.docFinder();\n+                    Optional<List<? extends DocTree>> r = docFinder.search((ExecutableElement) member, (m -> {\n+                        var firstSentenceTrees = utils.getFirstSentenceTrees(m);\n+                        return firstSentenceTrees.isEmpty() ? Optional.empty() : Optional.of(firstSentenceTrees);\n+                    }));\n+                    writer.addMemberSummary(typeElement, member, r.orElse(List.of()));\n+                } else {\n+                    writer.addMemberSummary(typeElement, member, utils.getFirstSentenceTrees(member));\n@@ -275,1 +274,0 @@\n-                writer.addMemberSummary(typeElement, member, firstSentenceTags);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/builders\/MemberSummaryBuilder.java","additions":10,"deletions":12,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import com.sun.source.doctree.DocTree;\n@@ -168,7 +169,4 @@\n-            ExecutableElement method = currentMethod;\n-            if (utils.getFullBody(currentMethod).isEmpty()) {\n-                DocFinder.Output docs = DocFinder.search(configuration,\n-                        new DocFinder.Input(utils, currentMethod));\n-                if (!docs.inlineTags.isEmpty())\n-                    method = (ExecutableElement) docs.holder;\n-            }\n+            var docFinder = utils.docFinder();\n+            Optional<ExecutableElement> r = docFinder.search(currentMethod,\n+                    m -> utils.getFullBody(m).isEmpty() ? Optional.empty() : Optional.of(m));\n+            ExecutableElement method = r.orElse(currentMethod);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/builders\/MethodBuilder.java","additions":5,"deletions":7,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -121,0 +121,3 @@\n+doclet.inheritDocNoDoc=overridden methods do not document exception type {0}\n+doclet.throwsInheritDocUnsupported=@inheritDoc for exception-type type parameters not declared by a method is unsupported; \\\n+  document such exception types directly without inheritance\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/resources\/doclets.properties","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+import java.util.List;\n+import java.util.Optional;\n@@ -64,1 +66,1 @@\n-     * @param e the {@link Element} that we are documenting.\n+     * @param method the method that we are documenting.\n@@ -69,1 +71,1 @@\n-                                                   Element e,\n+                                                   ExecutableElement method,\n@@ -76,1 +78,1 @@\n-        CommentHelper ch = utils.getCommentHelper(e);\n+        CommentHelper ch = utils.getCommentHelper(method);\n@@ -79,3 +81,18 @@\n-        Taglet taglet = holderTag.getKind() == DocTree.Kind.DOC_COMMENT\n-                ? null\n-                : configuration.tagletManager.getTaglet(ch.getTagName(holderTag));\n+        if (holderTag.getKind() == DocTree.Kind.DOC_COMMENT) {\n+            try {\n+                var docFinder = utils.docFinder();\n+                Optional<Result> r = docFinder.trySearch(method,\n+                        m -> extractMainDescription(m, isFirstSentence, utils));\n+                if (r.isPresent()) {\n+                    replacement = writer.commentTagsToOutput(r.get().method, null,\n+                            r.get().mainDescription, isFirstSentence);\n+                }\n+            } catch (DocFinder.NoOverriddenMethodsFound e) {\n+                String signature = utils.getSimpleName(method)\n+                        + utils.flatSignature(method, writer.getCurrentPageElement());\n+                messages.warning(method, \"doclet.noInheritedDoc\", signature);\n+            }\n+            return replacement;\n+        }\n+\n+        Taglet taglet = configuration.tagletManager.getTaglet(ch.getTagName(holderTag));\n@@ -87,7 +104,6 @@\n-        var input = new DocFinder.Input(utils, e, (InheritableTaglet) taglet,\n-                new DocFinder.DocTreeInfo(holderTag, e), isFirstSentence, true);\n-        DocFinder.Output inheritedDoc = DocFinder.search(configuration, input);\n-        if (inheritedDoc.isValidInheritDocTag) {\n-            if (!inheritedDoc.inlineTags.isEmpty()) {\n-                replacement = writer.commentTagsToOutput(inheritedDoc.holder, inheritedDoc.holderTag,\n-                        inheritedDoc.inlineTags, isFirstSentence);\n+\n+        InheritableTaglet.Output inheritedDoc = ((InheritableTaglet) taglet).inherit(method, holderTag, isFirstSentence, configuration);\n+        if (inheritedDoc.isValidInheritDocTag()) {\n+            if (!inheritedDoc.inlineTags().isEmpty()) {\n+                replacement = writer.commentTagsToOutput(inheritedDoc.holder(), inheritedDoc.holderTag(),\n+                        inheritedDoc.inlineTags(), isFirstSentence);\n@@ -96,5 +112,3 @@\n-            String signature = utils.getSimpleName(e) +\n-                    ((utils.isExecutableElement(e))\n-                            ? utils.flatSignature((ExecutableElement) e, writer.getCurrentPageElement())\n-                            : e.toString());\n-            messages.warning(e, \"doclet.noInheritedDoc\", signature);\n+            String signature = utils.getSimpleName(method)\n+                    + utils.flatSignature(method, writer.getCurrentPageElement());\n+            messages.warning(method, \"doclet.noInheritedDoc\", signature);\n@@ -105,0 +119,11 @@\n+    private record Result(List<? extends DocTree> mainDescription, ExecutableElement method) { }\n+\n+    private static Optional<Result> extractMainDescription(ExecutableElement m,\n+                                                           boolean extractFirstSentenceOnly,\n+                                                           Utils utils) {\n+        List<? extends DocTree> docTrees = extractFirstSentenceOnly\n+                ? utils.getFirstSentenceTrees(m)\n+                : utils.getFullBody(m);\n+        return docTrees.isEmpty() ? Optional.empty() : Optional.of(new Result(docTrees, m));\n+    }\n+\n@@ -110,1 +135,1 @@\n-        return retrieveInheritedDocumentation(tagletWriter, e, inheritDoc, tagletWriter.isFirstSentence);\n+        return retrieveInheritedDocumentation(tagletWriter, (ExecutableElement) e, inheritDoc, tagletWriter.isFirstSentence);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/InheritDocTaglet.java","additions":44,"deletions":19,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -28,1 +28,5 @@\n-import jdk.javadoc.internal.doclets.toolkit.util.DocFinder;\n+import com.sun.source.doctree.DocTree;\n+import jdk.javadoc.internal.doclets.toolkit.BaseConfiguration;\n+\n+import javax.lang.model.element.Element;\n+import java.util.List;\n@@ -36,9 +40,7 @@\n-    \/**\n-     * Given an {@link jdk.javadoc.internal.doclets.toolkit.util.DocFinder.Output}\n-     * object, set its values with the appropriate information to inherit\n-     * documentation.\n-     *\n-     * @param input  the input for documentation search\n-     * @param output the output for documentation search\n-     *\/\n-    void inherit(DocFinder.Input input, DocFinder.Output output);\n+    Output inherit(Element owner, DocTree tag, boolean isFirstSentence, BaseConfiguration configuration);\n+\n+    record Output(DocTree holderTag,\n+                  Element holder,\n+                  List<? extends DocTree> inlineTags,\n+                  boolean isValidInheritDocTag) {\n+    }\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/InheritableTaglet.java","additions":12,"deletions":10,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import javax.lang.model.element.ElementKind;\n@@ -37,0 +38,1 @@\n+import jdk.javadoc.internal.doclets.toolkit.BaseConfiguration;\n@@ -41,1 +43,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.util.DocFinder.Input;\n@@ -65,21 +66,11 @@\n-    public void inherit(DocFinder.Input input, DocFinder.Output output) {\n-        Utils utils = input.utils;\n-        if (input.tagId == null) {\n-            var tag = (ParamTree) input.docTreeInfo.docTree();\n-            input.isTypeVariableParamTag = tag.isTypeParameter();\n-            ExecutableElement ee = (ExecutableElement) input.docTreeInfo.element();\n-            CommentHelper ch = utils.getCommentHelper(ee);\n-            List<? extends Element> parameters = input.isTypeVariableParamTag\n-                    ? ee.getTypeParameters()\n-                    : ee.getParameters();\n-            String target = ch.getParameterName(tag);\n-            for (int i = 0; i < parameters.size(); i++) {\n-                Element e = parameters.get(i);\n-                String candidate = input.isTypeVariableParamTag\n-                        ? utils.getTypeName(e.asType(), false)\n-                        : utils.getSimpleName(e);\n-                if (candidate.equals(target)) {\n-                    input.tagId = Integer.toString(i);\n-                    break;\n-                }\n-            }\n+    public Output inherit(Element owner, DocTree tag, boolean isFirstSentence, BaseConfiguration configuration) {\n+        assert owner.getKind() == ElementKind.METHOD;\n+        assert tag.getKind() == DocTree.Kind.PARAM;\n+        var method = (ExecutableElement) owner;\n+        var param = (ParamTree) tag;\n+        \/\/ find the position of an owner parameter described by the given tag\n+        List<? extends Element> parameterElements;\n+        if (param.isTypeParameter()) {\n+            parameterElements = method.getTypeParameters();\n+        } else {\n+            parameterElements = method.getParameters();\n@@ -87,20 +78,14 @@\n-        if (input.tagId == null)\n-            return;\n-        int position = Integer.parseInt(input.tagId);\n-        ExecutableElement ee = (ExecutableElement) input.element;\n-        CommentHelper ch = utils.getCommentHelper(ee);\n-        List<ParamTree> tags = input.isTypeVariableParamTag\n-                ? utils.getTypeParamTrees(ee)\n-                : utils.getParamTrees(ee);\n-        List<? extends Element> parameters = input.isTypeVariableParamTag\n-                ? ee.getTypeParameters()\n-                : ee.getParameters();\n-        Map<String, Integer> positionOfName = mapNameToPosition(utils, parameters);\n-        for (ParamTree tag : tags) {\n-            String paramName = ch.getParameterName(tag);\n-            if (positionOfName.containsKey(paramName) && positionOfName.get(paramName).equals(position)) {\n-                output.holder = input.element;\n-                output.holderTag = tag;\n-                output.inlineTags = ch.getBody(tag);\n-                return;\n-            }\n+        Map<String, Integer> stringIntegerMap = mapNameToPosition(configuration.utils, parameterElements);\n+        CommentHelper ch = configuration.utils.getCommentHelper(owner);\n+        Integer position = stringIntegerMap.get(ch.getParameterName(param));\n+        if (position == null) {\n+            return new Output(null, null, List.of(), true); \/\/ remodel, because it's an error\n+        }\n+        \/\/ try to inherit description of the respective parameter in an overridden method\n+        try {\n+            var docFinder = configuration.utils.docFinder();\n+            var r = docFinder.trySearch(method, m -> extract(configuration.utils, m, position, param.isTypeParameter()));\n+            return r.map(result -> new Output(result.paramTree, result.method, result.paramTree.getDescription(), true))\n+                    .orElseGet(() -> new Output(null, null, List.of(), true));\n+        } catch (DocFinder.NoOverriddenMethodsFound e) {\n+            return new Output(null, null, List.of(), false);\n@@ -242,4 +227,3 @@\n-        Input input = new DocFinder.Input(writer.configuration().utils, holder, this,\n-                Integer.toString(position), kind == ParamKind.TYPE_PARAMETER);\n-        DocFinder.Output inheritedDoc = DocFinder.search(writer.configuration(), input);\n-        if (!inheritedDoc.inlineTags.isEmpty()) {\n+        var r = utils.docFinder().search((ExecutableElement) holder,\n+                m -> extract(utils, m, position, kind == ParamKind.TYPE_PARAMETER));\n+        if (r.isPresent()) {\n@@ -249,3 +233,2 @@\n-            Content content = convertParam(inheritedDoc.holder, kind, writer,\n-                    (ParamTree) inheritedDoc.holderTag,\n-                    name, isFirst);\n+            Content content = convertParam(r.get().method, kind, writer,\n+                    r.get().paramTree, name, isFirst);\n@@ -257,0 +240,15 @@\n+    private record Result(ParamTree paramTree, ExecutableElement method) { }\n+\n+    private static Optional<Result> extract(Utils utils, ExecutableElement method, Integer position, boolean typeParam) {\n+        var ch = utils.getCommentHelper(method);\n+        List<ParamTree> tags = typeParam\n+                ? utils.getTypeParamTrees(method)\n+                : utils.getParamTrees(method);\n+        List<? extends Element> parameters = typeParam\n+                ? method.getTypeParameters()\n+                : method.getParameters();\n+        var positionOfName = mapNameToPosition(utils, parameters);\n+        return tags.stream().filter(t -> position.equals(positionOfName.get(ch.getParameterName(t))))\n+                .map(t -> new Result(t, method)).findAny();\n+    }\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/ParamTaglet.java","additions":47,"deletions":49,"binary":false,"changes":96,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import java.util.ArrayList;\n@@ -31,0 +30,2 @@\n+import java.util.Optional;\n+import java.util.stream.Stream;\n@@ -33,0 +34,1 @@\n+import javax.lang.model.element.ElementKind;\n@@ -39,0 +41,1 @@\n+import jdk.javadoc.internal.doclets.toolkit.BaseConfiguration;\n@@ -41,1 +44,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.util.CommentHelper;\n@@ -43,1 +45,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.util.DocFinder.Input;\n@@ -61,21 +62,8 @@\n-    public void inherit(DocFinder.Input input, DocFinder.Output output) {\n-        Utils utils = input.utils;\n-        CommentHelper ch = utils.getCommentHelper(input.element);\n-\n-        ReturnTree tag = null;\n-        List<? extends ReturnTree> tags = utils.getReturnTrees(input.element);\n-        if (!tags.isEmpty()) {\n-            tag = tags.get(0);\n-        } else {\n-            List<? extends DocTree> firstSentence = utils.getFirstSentenceTrees(input.element);\n-            if (firstSentence.size() == 1 && firstSentence.get(0).getKind() == DocTree.Kind.RETURN) {\n-                tag = (ReturnTree) firstSentence.get(0);\n-            }\n-        }\n-\n-        if (tag != null) {\n-            output.holder = input.element;\n-            output.holderTag = tag;\n-            output.inlineTags = input.isFirstSentence\n-                    ? ch.getFirstSentenceTrees(output.holderTag)\n-                    : ch.getDescription(output.holderTag);\n+    public Output inherit(Element owner, DocTree tag, boolean isFirstSentence, BaseConfiguration configuration) {\n+        try {\n+            var docFinder = configuration.utils.docFinder();\n+            var r = docFinder.trySearch((ExecutableElement) owner, m -> extract(configuration.utils, m));\n+            return r.map(result -> new Output(result.returnTree, result.method, result.returnTree.getDescription(), true))\n+                    .orElseGet(() -> new Output(null, null, List.of(), true));\n+        } catch (DocFinder.NoOverriddenMethodsFound e) {\n+            return new Output(null, null, List.of(), false);\n@@ -92,0 +80,2 @@\n+        assert holder.getKind() == ElementKind.METHOD : holder.getKind();\n+        var method = (ExecutableElement) holder;\n@@ -96,2 +86,2 @@\n-        \/\/ Make sure we are not using @return tag on method with void return type.\n-        TypeMirror returnType = utils.getReturnType(writer.getCurrentPageElement(), (ExecutableElement) holder);\n+        \/\/ make sure we are not using @return on a method with the void return type\n+        TypeMirror returnType = utils.getReturnType(writer.getCurrentPageElement(), method);\n@@ -105,3 +95,1 @@\n-        if (!tags.isEmpty()) {\n-            return writer.returnTagOutput(holder, tags.get(0), false);\n-        }\n+        \/\/ TODO check for more than one @return\n@@ -109,5 +97,5 @@\n-        \/\/ Check for inline tag in first sentence.\n-        List<? extends DocTree> firstSentence = utils.getFirstSentenceTrees(holder);\n-        if (firstSentence.size() == 1 && firstSentence.get(0).getKind() == DocTree.Kind.RETURN) {\n-            return writer.returnTagOutput(holder, (ReturnTree) firstSentence.get(0), false);\n-        }\n+        var docFinder = utils.docFinder();\n+        return docFinder.search(method, m -> extract(utils, m))\n+                .map(r -> writer.returnTagOutput(r.method, r.returnTree, false))\n+                .orElse(null);\n+    }\n@@ -115,7 +103,15 @@\n-        \/\/ Inherit @return tag if necessary.\n-        Input input = new DocFinder.Input(utils, holder, this);\n-        DocFinder.Output inheritedDoc = DocFinder.search(writer.configuration(), input);\n-        if (inheritedDoc.holderTag != null) {\n-            return writer.returnTagOutput(inheritedDoc.holder, (ReturnTree) inheritedDoc.holderTag, false);\n-        }\n-        return null;\n+    private record Result(ReturnTree returnTree, ExecutableElement method) { }\n+\n+    private static Optional<Result> extract(Utils utils, ExecutableElement method) {\n+        \/\/ TODO\n+        \/\/  Using getBlockTags(..., Kind.RETURN) for clarity. Since @return has become a bimodal tag,\n+        \/\/  Utils.getReturnTrees is now a misnomer: it returns only block returns, not all returns.\n+        \/\/  We could revisit this later.\n+        Stream<? extends ReturnTree> blockTags = utils.getBlockTags(method, DocTree.Kind.RETURN, ReturnTree.class).stream();\n+        Stream<? extends ReturnTree> mainDescriptionTags = utils.getFirstSentenceTrees(method).stream()\n+                .mapMulti((t, c) -> {\n+                    if (t.getKind() == DocTree.Kind.RETURN) c.accept((ReturnTree) t);\n+                });\n+        \/\/ this method should not check validity of @return tags, hence findAny and not findFirst or what have you\n+        return Stream.concat(blockTags, mainDescriptionTags)\n+                .map(t -> new Result(t, method)).findAny();\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/ReturnTaglet.java","additions":37,"deletions":41,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import java.util.Optional;\n@@ -32,0 +33,1 @@\n+import javax.lang.model.element.ExecutableElement;\n@@ -36,0 +38,1 @@\n+import jdk.javadoc.internal.doclets.toolkit.BaseConfiguration;\n@@ -37,3 +40,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.util.CommentHelper;\n-import jdk.javadoc.internal.doclets.toolkit.util.DocFinder;\n-import jdk.javadoc.internal.doclets.toolkit.util.DocFinder.Input;\n@@ -52,10 +52,2 @@\n-    public void inherit(DocFinder.Input input, DocFinder.Output output) {\n-        List<? extends SeeTree> tags = input.utils.getSeeTrees(input.element);\n-        if (!tags.isEmpty()) {\n-            CommentHelper ch = input.utils.getCommentHelper(input.element);\n-            output.holder = input.element;\n-            output.holderTag = tags.get(0);\n-            output.inlineTags = input.isFirstSentence\n-                    ? ch.getFirstSentenceTrees(output.holderTag)\n-                    : ch.getReference(output.holderTag);\n-        }\n+    public Output inherit(Element owner, DocTree tag, boolean isFirstSentence, BaseConfiguration configuration) {\n+        throw new UnsupportedOperationException(\"Not yet implemented\");\n@@ -69,6 +61,8 @@\n-        if (tags.isEmpty() && utils.isMethod(holder)) {\n-            Input input = new DocFinder.Input(utils, holder, this);\n-            DocFinder.Output inheritedDoc = DocFinder.search(writer.configuration(), input);\n-            if (inheritedDoc.holder != null) {\n-                tags = utils.getSeeTrees(inheritedDoc.holder);\n-                e = inheritedDoc.holder;\n+        if (utils.isMethod(holder)) {\n+            var docFinder = utils.docFinder();\n+            Optional<Result> result = docFinder.search((ExecutableElement) holder,\n+                    m -> extract(utils, m));\n+            if (result.isPresent()) {\n+                ExecutableElement m = result.get().method();\n+                tags = utils.getSeeTrees(m);\n+                e = m;\n@@ -79,0 +73,7 @@\n+\n+    private record Result(List<? extends SeeTree> seeTrees, ExecutableElement method) { }\n+\n+    private static Optional<Result> extract(Utils utils, ExecutableElement method) {\n+        List<? extends SeeTree> tags = utils.getSeeTrees(method);\n+        return tags.isEmpty() ? Optional.empty() : Optional.of(new Result(tags, method));\n+    }\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/SeeTaglet.java","additions":20,"deletions":19,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import java.util.Optional;\n@@ -33,0 +34,2 @@\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.ExecutableElement;\n@@ -37,0 +40,1 @@\n+import jdk.javadoc.internal.doclets.toolkit.BaseConfiguration;\n@@ -38,1 +42,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.util.CommentHelper;\n@@ -162,9 +165,11 @@\n-    public void inherit(DocFinder.Input input, DocFinder.Output output) {\n-        List<? extends DocTree> tags = input.utils.getBlockTags(input.element, this);\n-        if (!tags.isEmpty()) {\n-            output.holder = input.element;\n-            output.holderTag = tags.get(0);\n-            CommentHelper ch = input.utils.getCommentHelper(output.holder);\n-            output.inlineTags = input.isFirstSentence\n-                    ? ch.getFirstSentenceTrees(output.holderTag)\n-                    : ch.getTags(output.holderTag);\n+    public Output inherit(Element owner, DocTree tag, boolean isFirstSentence, BaseConfiguration configuration) {\n+        assert owner.getKind() == ElementKind.METHOD;\n+        assert !isFirstSentence;\n+        try {\n+            var docFinder = configuration.utils.docFinder();\n+            var r = docFinder.trySearch((ExecutableElement) owner,\n+                    m -> extractFirst(m, configuration.utils));\n+            return r.map(result -> new Output(result.tag, result.method, result.description, true))\n+                    .orElseGet(()->new Output(null, null, List.of(), true));\n+        } catch (DocFinder.NoOverriddenMethodsFound e) {\n+            return new Output(null, null, List.of(), false);\n@@ -174,0 +179,11 @@\n+    record Result(DocTree tag, List<? extends DocTree> description, ExecutableElement method) { }\n+\n+    private Optional<Result> extractFirst(ExecutableElement m, Utils utils) {\n+        List<? extends DocTree> tags = utils.getBlockTags(m, this);\n+        if (tags.isEmpty()) {\n+            return Optional.empty();\n+        }\n+        DocTree t = tags.get(0);\n+        return Optional.of(new Result(t, utils.getCommentHelper(m).getDescription(t), m));\n+    }\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/SimpleTaglet.java","additions":26,"deletions":10,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import java.util.Optional;\n@@ -31,0 +32,1 @@\n+import javax.lang.model.element.ExecutableElement;\n@@ -35,0 +37,1 @@\n+import jdk.javadoc.internal.doclets.toolkit.BaseConfiguration;\n@@ -36,3 +39,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.util.CommentHelper;\n-import jdk.javadoc.internal.doclets.toolkit.util.DocFinder;\n-import jdk.javadoc.internal.doclets.toolkit.util.DocFinder.Input;\n@@ -51,10 +51,2 @@\n-    public void inherit(Input input, DocFinder.Output output) {\n-        List<? extends SpecTree> tags = input.utils.getSpecTrees(input.element);\n-        if (!tags.isEmpty()) {\n-            CommentHelper ch =  input.utils.getCommentHelper(input.element);\n-            output.holder = input.element;\n-            output.holderTag = tags.get(0);\n-            output.inlineTags = input.isFirstSentence\n-                    ? ch.getFirstSentenceTrees(output.holderTag)\n-                    : ch.getTags(output.holderTag);\n-        }\n+    public Output inherit(Element owner, DocTree tag, boolean isFirstSentence, BaseConfiguration configuration) {\n+        throw new UnsupportedOperationException(\"Not yet implemented\");\n@@ -68,6 +60,8 @@\n-        if (tags.isEmpty() && utils.isExecutableElement(holder)) {\n-            Input input = new Input(utils, holder, this);\n-            DocFinder.Output inheritedDoc = DocFinder.search(writer.configuration(), input);\n-            if (inheritedDoc.holder != null) {\n-                tags = utils.getSpecTrees(inheritedDoc.holder);\n-                e = inheritedDoc.holder;\n+        if (utils.isMethod(holder)) {\n+            var docFinder = utils.docFinder();\n+            Optional<Result> result = docFinder.search((ExecutableElement) holder,\n+                    m -> extract(utils, m));\n+            if (result.isPresent()) {\n+                ExecutableElement m = result.get().method();\n+                tags = utils.getSpecTrees(m);\n+                e = m;\n@@ -78,0 +72,7 @@\n+\n+    private record Result(List<? extends SpecTree> seeTrees, ExecutableElement method) { }\n+\n+    private static Optional<Result> extract(Utils utils, ExecutableElement method) {\n+        List<? extends SpecTree> tags = utils.getSpecTrees(method);\n+        return tags.isEmpty() ? Optional.empty() : Optional.of(new Result(tags, method));\n+    }\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/SpecTaglet.java","additions":20,"deletions":19,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -226,11 +226,0 @@\n-    \/**\n-     * Returns the output for a {@code @throws} tag.\n-     *\n-     * @param element        The element that owns the doc comment\n-     * @param throwsTag      the throws tag\n-     * @param substituteType instantiated type of a generic type-variable, or null\n-     *\n-     * @return the output\n-     *\/\n-    protected abstract Content throwsTagOutput(Element element, ThrowsTree throwsTag, TypeMirror substituteType);\n-\n@@ -241,0 +230,1 @@\n+     * @param content    the optional content to add as a description\n@@ -244,1 +234,1 @@\n-    protected abstract Content throwsTagOutput(TypeMirror throwsType);\n+    protected abstract Content throwsTagOutput(TypeMirror throwsType, Optional<Content> content);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/TagletWriter.java","additions":2,"deletions":12,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import java.util.Collections;\n+import java.util.Arrays;\n@@ -34,0 +34,1 @@\n+import java.util.LinkedList;\n@@ -36,0 +37,1 @@\n+import java.util.Optional;\n@@ -37,0 +39,2 @@\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n@@ -41,0 +45,3 @@\n+import javax.lang.model.element.ModuleElement;\n+import javax.lang.model.element.PackageElement;\n+import javax.lang.model.element.QualifiedNameable;\n@@ -43,0 +50,1 @@\n+import javax.lang.model.type.TypeKind;\n@@ -50,0 +58,2 @@\n+import jdk.javadoc.internal.doclets.formats.html.markup.ContentBuilder;\n+import jdk.javadoc.internal.doclets.toolkit.BaseConfiguration;\n@@ -51,0 +61,2 @@\n+import jdk.javadoc.internal.doclets.toolkit.Resources;\n+import jdk.javadoc.internal.doclets.toolkit.util.CommentHelper;\n@@ -52,0 +64,3 @@\n+import jdk.javadoc.internal.doclets.toolkit.util.Utils;\n+\n+import static java.util.stream.Collectors.joining;\n@@ -55,1 +70,2 @@\n- * {@code @throws} and {@code @exception} tags.\n+ * {@code @throws} and {@code @exception} tags, collectively\n+ * referred to as exception tags.\n@@ -59,0 +75,50 @@\n+    \/*\n+     * Relevant bits from JLS\n+     * ======================\n+     *\n+     * 11.1.1 The Kinds of Exceptions\n+     *\n+     *   Throwable and all its subclasses are, collectively,\n+     *   the exception classes.\n+     *\n+     * 8.4.6 Method Throws\n+     *\n+     *   Throws:\n+     *     throws ExceptionTypeList\n+     *\n+     *   ExceptionTypeList:\n+     *     ExceptionType {, ExceptionType}\n+     *\n+     *   ExceptionType:\n+     *     ClassType\n+     *     TypeVariable\n+     *\n+     *   It is a compile-time error if an ExceptionType mentioned in\n+     *   a throws clause is not a subtype (4.10) of Throwable.\n+     *\n+     *   Type variables are allowed in a throws clause even though\n+     *   they are not allowed in a catch clause (14.20).\n+     *\n+     *   It is permitted but not required to mention unchecked\n+     *   exception classes (11.1.1) in a throws clause.\n+     *\n+     * 8.1.2 Generic Classes and Type Parameters\n+     *\n+     *   It is a compile-time error if a generic class is a direct\n+     *   or indirect subclass of Throwable.\n+     *\n+     * 8.8.5. Constructor Throws\n+     *\n+     *   The throws clause for a constructor is identical in structure\n+     *   and behavior to the throws clause for a method (8.4.6).\n+     *\n+     * General Comments\n+     * ================\n+     *\n+     * Map<ThrowsTree, ExecutableElement> associates a doc tree with its holder\n+     * element externally. Such maps are ordered, have non-null keys and values.\n+     *\n+     * Of all language elements only constructors and methods can declare\n+     * thrown exceptions and, hence, document them.\n+     *\/\n+\n@@ -64,30 +130,6 @@\n-    public void inherit(DocFinder.Input input, DocFinder.Output output) {\n-        var utils = input.utils;\n-        Element target;\n-        var ch = utils.getCommentHelper(input.element);\n-        if (input.tagId == null) {\n-            var tag = (ThrowsTree) input.docTreeInfo.docTree();\n-            target = ch.getException(tag);\n-            input.tagId = target == null\n-                    ? tag.getExceptionName().getSignature()\n-                    : utils.getFullyQualifiedName(target);\n-        } else {\n-            target = input.utils.findClass(input.element, input.tagId);\n-        }\n-\n-        \/\/ TODO warn if target == null as we cannot guarantee type-match, but at most FQN-match.\n-\n-        for (ThrowsTree tag : input.utils.getThrowsTrees(input.element)) {\n-            Element candidate = ch.getException(tag);\n-            if (candidate != null && (input.tagId.equals(utils.getSimpleName(candidate)) ||\n-                    (input.tagId.equals(utils.getFullyQualifiedName(candidate))))) {\n-                output.holder = input.element;\n-                output.holderTag = tag;\n-                output.inlineTags = ch.getBody(output.holderTag);\n-                output.tagList.add(tag);\n-            } else if (target != null && candidate != null &&\n-                    utils.isTypeElement(candidate) && utils.isTypeElement(target) &&\n-                    utils.isSubclassOf((TypeElement) candidate, (TypeElement) target)) {\n-                output.tagList.add(tag);\n-            }\n-        }\n+    public Output inherit(Element owner, DocTree tag, boolean isFirstSentence, BaseConfiguration configuration) {\n+        \/\/ This method shouldn't be called because {@inheritDoc} tags inside\n+        \/\/ exception tags aren't dealt with individually. {@inheritDoc} tags\n+        \/\/ inside exception tags are collectively dealt with in\n+        \/\/ getAllBlockTagOutput.\n+        throw newAssertionError(owner, tag, isFirstSentence);\n@@ -98,1 +140,6 @@\n-        var utils = writer.configuration().utils;\n+        ElementKind kind = holder.getKind();\n+        if (kind != ElementKind.METHOD && kind != ElementKind.CONSTRUCTOR) {\n+            \/\/ Elements are processed by applicable taglets only. This taglet\n+            \/\/ is only applicable to methods and constructors.\n+            throw newAssertionError(holder, kind);\n+        }\n@@ -100,0 +147,1 @@\n+        var utils = writer.configuration().utils;\n@@ -102,2 +150,3 @@\n-        List<? extends TypeMirror> thrownTypes = instantiatedType.getThrownTypes();\n-        Map<String, TypeMirror> typeSubstitutions = getSubstitutedThrownTypes(\n+        List<? extends TypeMirror> substitutedExceptionTypes = instantiatedType.getThrownTypes();\n+        List<? extends TypeMirror> originalExceptionTypes = executable.getThrownTypes();\n+        Map<TypeMirror, TypeMirror> typeSubstitutions = getSubstitutedThrownTypes(\n@@ -105,9 +154,339 @@\n-                executable.getThrownTypes(),\n-                thrownTypes);\n-        Map<ThrowsTree, ExecutableElement> tagsMap = new LinkedHashMap<>();\n-        utils.getThrowsTrees(executable).forEach(t -> tagsMap.put(t, executable));\n-        Content result = writer.getOutputInstance();\n-        Set<String> alreadyDocumented = new HashSet<>();\n-        result.add(throwsTagsOutput(tagsMap, alreadyDocumented, typeSubstitutions, writer));\n-        result.add(inheritThrowsDocumentation(executable, thrownTypes, alreadyDocumented, typeSubstitutions, writer));\n-        result.add(linkToUndocumentedDeclaredExceptions(thrownTypes, alreadyDocumented, writer));\n+                originalExceptionTypes,\n+                substitutedExceptionTypes);\n+        var exceptionSection = new ExceptionSectionBuilder(writer);\n+        try {\n+            \/\/ Step 1. Document exception tags\n+            Set<TypeMirror> alreadyDocumentedExceptions = new HashSet<>();\n+            List<ThrowsTree> exceptionTags = utils.getThrowsTrees(executable);\n+            for (ThrowsTree t : exceptionTags) {\n+                outputAnExceptionTagDeeply(exceptionSection, t, executable, alreadyDocumentedExceptions, typeSubstitutions, writer, utils);\n+            }\n+            \/\/ Step 2. Document exception types from the `throws` clause.\n+            \/\/\n+            \/\/ Only methods can inherit documentation, so if `executable`\n+            \/\/ is a constructor, skip this step.\n+            if (executable.getKind() == ElementKind.METHOD) {\n+                var docFinder = utils.docFinder();\n+                for (TypeMirror exceptionType : substitutedExceptionTypes) {\n+                    var r = docFinder.search(executable,\n+                            false, \/\/ false: do not look for documentation in `executable`;\n+                            \/\/ if documentation were there, we would find it on step 1\n+                            m -> extract(m, exceptionType, utils));\n+                    if (r.isEmpty()) {\n+                        \/\/ if the result is empty, `exceptionType` will be\n+                        \/\/ documented on Step 3; skip it for now\n+                        continue;\n+                    }\n+                    if (!alreadyDocumentedExceptions.add(exceptionType)) {\n+                        continue;\n+                    }\n+                    for (ThrowsTree t : r.get().throwsTrees()) {\n+                        outputAnExceptionTagDeeply(exceptionSection, t, r.get().method(), alreadyDocumentedExceptions, typeSubstitutions, writer, utils);\n+                    }\n+                }\n+            }\n+            \/\/ Step 3. List those exceptions from the `throws` clause for which\n+            \/\/         no documentation was found on Step 2.\n+            for (TypeMirror e : substitutedExceptionTypes) {\n+                if (!alreadyDocumentedExceptions.add(e)) {\n+                    continue;\n+                }\n+                exceptionSection.beginEntry(e);\n+                exceptionSection.endEntry();\n+            }\n+            assert alreadyDocumentedExceptions.containsAll(substitutedExceptionTypes);\n+        } catch (Failure.ExceptionTypeNotFound f) {\n+            var ch = utils.getCommentHelper(f.holder());\n+            utils.configuration.getMessages().warning(ch.getDocTreePath(f.tag().getExceptionName()),\n+                    \"doclet.throws.reference_not_found\");\n+            \/\/ add bad entry to section\n+        } catch (Failure.NotExceptionType f) {\n+            var ch = utils.getCommentHelper(f.holder());\n+            var name = diagnosticDescriptionOf(f.type());\n+            utils.configuration.getMessages().warning(ch.getDocTreePath(f.tag().getExceptionName()),\n+                    \"doclet.throws.reference_bad_type\", name);\n+            \/\/ add bad entry to section\n+        } catch (Failure.InvalidMarkup f) {\n+\n+        } catch (Failure.Unsupported f) {\n+            var ch = utils.getCommentHelper(f.holder());\n+            utils.configuration.getMessages().warning(ch.getDocTreePath(f.tag().getExceptionName()),\n+                    \"doclet.throwsInheritDocUnsupported\");\n+        }\n+        return exceptionSection.build();\n+    }\n+\n+    private static Map<ThrowsTree, ExecutableElement> toExceptionTags(ExecutableElement e, List<ThrowsTree> tags) {\n+        return tags.stream()\n+                .collect(Collectors.toMap(Function.identity(), t -> e, (e1, e2) -> {\n+                    \/\/ there should be no equal exception tags, hence no merging is expected\n+                    throw newAssertionError(e1, e2);\n+                }, LinkedHashMap::new));\n+    }\n+\n+    \/\/ - we need to hijack tag processing just for the \"@throws + @inheritDoc\"\n+    \/\/   combination (because one-to-many we need access to exception section\n+    \/\/   being written rather than individual exception description)\n+    \/\/ - populates exception section, depth-first\n+    \/\/ - content elements are composable, tags are not (because of the DocTreePath,\n+    \/\/   one cannot practically use a list of tags cherry-picked from different doc comments)\n+\n+    \/\/ This adds entries late; who starts an entry also ends it\n+\n+    private void outputAnExceptionTagDeeply(ExceptionSectionBuilder exceptionSection,\n+                                            ThrowsTree tag,\n+                                            ExecutableElement holder,\n+                                            Set<TypeMirror> alreadyDocumentedExceptions,\n+                                            Map<TypeMirror, TypeMirror> typeSubstitutions,\n+                                            TagletWriter writer,\n+                                            Utils utils)\n+            throws Failure.ExceptionTypeNotFound,\n+                   Failure.NotExceptionType,\n+                   Failure.InvalidMarkup,\n+                   Failure.Unsupported\n+    {\n+        var exceptionType = getExceptionType(tag, holder, utils);\n+        outputAnExceptionTagDeeply(exceptionSection, exceptionType, tag, holder, true, alreadyDocumentedExceptions, typeSubstitutions, writer, utils);\n+    }\n+\n+    private void outputAnExceptionTagDeeply(ExceptionSectionBuilder exceptionSection,\n+                                            Element originalExceptionType,\n+                                            ThrowsTree tag,\n+                                            ExecutableElement holder,\n+                                            boolean addNewEntry,\n+                                            Set<TypeMirror> alreadyDocumentedExceptions,\n+                                            Map<TypeMirror, TypeMirror> typeSubstitutions,\n+                                            TagletWriter writer,\n+                                            Utils utils)\n+            throws Failure.InvalidMarkup,\n+                   Failure.ExceptionTypeNotFound,\n+                   Failure.NotExceptionType,\n+                   Failure.Unsupported\n+    {\n+        var ch = utils.getCommentHelper(holder);\n+        var t = originalExceptionType.asType();\n+        var exceptionType = typeSubstitutions.getOrDefault(t, t);\n+        alreadyDocumentedExceptions.add(exceptionType);\n+        var description = tag.getDescription();\n+        int i = indexOfInheritDoc(tag, holder);\n+\n+        if (i == -1) {\n+            \/\/ appending to an existing entry or adding a new one?\n+            if (addNewEntry) {\n+                exceptionSection.beginEntry(exceptionType);\n+            }\n+            exceptionSection.continueEntry(writer.commentTagsToOutput(holder, description));\n+            if (addNewEntry) {\n+                exceptionSection.endEntry();\n+            }\n+        } else {\n+            boolean loneInheritDoc = description.size() == 1;\n+            assert !loneInheritDoc || i == 0 : i;\n+            boolean add = !loneInheritDoc && addNewEntry;\n+            if (add) {\n+                exceptionSection.beginEntry(exceptionType);\n+            }\n+            if (i > 0) { \/\/ if there's anything preceding {@inheritDoc}, assume the entry has been started before\n+                Content beforeInheritDoc = writer.commentTagsToOutput(holder, description.subList(0, i));\n+                exceptionSection.continueEntry(beforeInheritDoc);\n+            }\n+            Optional<Map<ThrowsTree, ExecutableElement>> expansion = expandShallowly(tag, holder, utils);\n+            if (expansion.isEmpty()) {\n+                if (!add) {\n+                    exceptionSection.beginEntry(exceptionType);\n+                }\n+                Resources resources = utils.configuration.getDocResources();\n+                String text = resources.getText(\"doclet.tag.invalid_input\", tag.toString());\n+                exceptionSection.continueEntry(writer.invalidTagOutput(text, Optional.empty()));\n+                \/\/ it might be helpful to output the type we found for the user to diagnose the issue\n+                String n = diagnosticDescriptionOf(utils.typeUtils.asElement(exceptionType));\n+                utils.configuration.getMessages().warning(ch.getDocTreePath(tag), \"doclet.inheritDocNoDoc\", n);\n+                if (!add) {\n+                    exceptionSection.endEntry();\n+                }\n+                return;\n+            }\n+            \/\/ if {@inheritDoc} is the only tag in the @throws description and\n+            \/\/ this call can add new entries to the exception section,\n+            \/\/ so can the recursive call\n+            boolean addNewEntryRecursively = addNewEntry && !add;\n+            var tags = expansion.get();\n+            if (!addNewEntryRecursively && tags.size() > 1) {\n+                \/\/ current tag has more to description than just {@inheritDoc}\n+                \/\/ and thus cannot expand to multiple tags;\n+                \/\/ it's likely a documentation error\n+                utils.configuration.getMessages().error(utils.getCommentHelper(holder).getDocTreePath(tag), \"doclet.inheritDocWithinInappropriateTag\");\n+                return;\n+            }\n+            for (Map.Entry<ThrowsTree, ExecutableElement> e : tags.entrySet()) {\n+                outputAnExceptionTagDeeply(exceptionSection, originalExceptionType, e.getKey(), e.getValue(), addNewEntryRecursively, alreadyDocumentedExceptions, typeSubstitutions, writer, utils);\n+            }\n+            \/\/ this might be an empty list, which is fine\n+            if (!loneInheritDoc) {\n+                Content afterInheritDoc = writer.commentTagsToOutput(holder, description.subList(i + 1, description.size()));\n+                exceptionSection.continueEntry(afterInheritDoc);\n+            }\n+            if (add) {\n+                exceptionSection.endEntry();\n+            }\n+        }\n+    }\n+\n+    private static int indexOfInheritDoc(ThrowsTree tag, ExecutableElement holder)\n+            throws Failure.InvalidMarkup\n+    {\n+        var tags = tag.getDescription();\n+        int i = -1;\n+        for (var iterator = tags.listIterator(); iterator.hasNext(); ) {\n+            DocTree t = iterator.next();\n+            if (t.getKind() == DocTree.Kind.INHERIT_DOC) {\n+                if (i != -1) {\n+                    throw new Failure.InvalidMarkup(t, holder);\n+                }\n+                i = iterator.previousIndex();\n+            }\n+        }\n+        return i;\n+    }\n+\n+    private static Element getExceptionType(ThrowsTree tag,\n+                                            ExecutableElement holder,\n+                                            Utils utils)\n+            throws Failure.ExceptionTypeNotFound,\n+                   Failure.NotExceptionType\n+    {\n+        Element e = utils.getCommentHelper(holder).getException(tag);\n+        if (e == null) {\n+            throw new Failure.ExceptionTypeNotFound(tag, holder);\n+        }\n+        var t = e.asType();\n+        var subtypeTestInapplicable = t.getKind() == TypeKind.EXECUTABLE\n+                || t.getKind() == TypeKind.PACKAGE\n+                || t.getKind() == TypeKind.MODULE;\n+        if (subtypeTestInapplicable || !utils.typeUtils.isSubtype(t, utils.getThrowableType())) {\n+            \/\/ aside from trivial documentation errors, this condition\n+            \/\/ might arise when we found something which is not what\n+            \/\/ the documentation author intended\n+            \/\/ TODO: add a link to the JBS issue\n+            throw new Failure.NotExceptionType(tag, holder, e);\n+        }\n+        var k = e.getKind();\n+        assert k.isClass() || k == ElementKind.TYPE_PARAMETER : k; \/\/ JLS 8.4.6\n+        return e;\n+    }\n+\n+    private static sealed class Failure extends Exception {\n+\n+        @java.io.Serial private static final long serialVersionUID = 1L;\n+\n+        private final transient DocTree tag;\n+        private final transient ExecutableElement holder;\n+\n+        Failure(DocTree tag, ExecutableElement holder) {\n+            super();\n+            this.tag = tag;\n+            this.holder = holder;\n+        }\n+\n+        DocTree tag() { return tag; }\n+\n+        ExecutableElement holder() { return holder; }\n+\n+        static final class ExceptionTypeNotFound extends Failure {\n+\n+            @java.io.Serial private static final long serialVersionUID = 1L;\n+\n+            ExceptionTypeNotFound(ThrowsTree tag, ExecutableElement holder) {\n+                super(tag, holder);\n+            }\n+\n+            @Override ThrowsTree tag() { return (ThrowsTree) super.tag(); }\n+        }\n+\n+        static final class NotExceptionType extends Failure {\n+\n+            @java.io.Serial private static final long serialVersionUID = 1L;\n+\n+            private final transient Element type;\n+\n+            public NotExceptionType(ThrowsTree tag, ExecutableElement holder, Element type) {\n+                super(tag, holder);\n+                this.type = type;\n+            }\n+\n+            Element type() { return type; }\n+\n+            @Override ThrowsTree tag() { return (ThrowsTree) super.tag(); }\n+        }\n+\n+        static final class InvalidMarkup extends Failure {\n+\n+            @java.io.Serial private static final long serialVersionUID = 1L;\n+\n+            public InvalidMarkup(DocTree tag, ExecutableElement holder) {\n+                super(tag, holder);\n+            }\n+        }\n+\n+        static final class Unsupported extends Failure {\n+\n+            @java.io.Serial private static final long serialVersionUID = 1L;\n+\n+            Unsupported(ThrowsTree tag, ExecutableElement holder) {\n+                super(tag, holder);\n+            }\n+\n+            @Override ThrowsTree tag() { return (ThrowsTree) super.tag(); }\n+        }\n+    }\n+\n+    \/*\n+     * Returns tags immediately inherited by the provided tag.\n+     *\n+     * This method provides shallow expansion. If required, deep expansion may\n+     * be obtained by calling this method recursively for tags returned from\n+     * this method.\n+     *\/\n+    private static Optional<Map<ThrowsTree, ExecutableElement>> expandShallowly(ThrowsTree tag,\n+                                                                                ExecutableElement holder,\n+                                                                                Utils utils)\n+            throws Failure.ExceptionTypeNotFound,\n+                   Failure.NotExceptionType,\n+                   Failure.Unsupported {\n+        \/\/ TODO\n+        \/\/  Consider this:\n+        \/\/  Searching tags up the hierarchy without regard to @throws {@inheritDoc}\n+        \/\/  and the `throws` clause is wrong. Some hierarchies might stop\n+        \/\/  documenting an unchecked exception and then restart it down\n+        \/\/  the hierarchy; we should probably not inherit that\n+        \/\/  exception jumping over methods that didn't\n+        \/\/  document that exception to those methods\n+        \/\/  that did. A method cannot \"undocument\"\n+        \/\/  @param or @return, but it can\n+        \/\/  undocument @throws.\n+\n+        Element target = getExceptionType(tag, holder, utils);\n+        ElementKind kind = target.getKind();\n+\n+        DocFinder.Criterion<Map<ThrowsTree, ExecutableElement>, RuntimeException> c;\n+        if (kind.isClass()) {\n+            c = method -> {\n+                var tags = findByExceptionType(target, method, utils);\n+                return !tags.isEmpty() ? Optional.of(toExceptionTags(method, tags)) : Optional.empty();\n+            };\n+        } else {\n+            \/\/ the basis of parameter position matching is JLS sections 8.4.2 and 8.4.4;\n+            int i = holder.getTypeParameters().indexOf(target);\n+            if (i == -1) {\n+                throw new Failure.Unsupported(tag, holder);\n+            }\n+            c = method -> {\n+                assert utils.elementUtils.overrides(holder, method, (TypeElement) holder.getEnclosingElement());\n+                \/\/ those lists must have the same number of elements\n+                var typeParameterElement = method.getTypeParameters().get(i);\n+                var tags = findByExceptionType(typeParameterElement, method, utils);\n+                return !tags.isEmpty() ? Optional.of(toExceptionTags(method, tags)) : Optional.empty();\n+            };\n+        }\n+        var result = utils.docFinder().search(holder, false, c);\n+        assert !(result.isPresent() && result.get().isEmpty());\n@@ -117,0 +496,70 @@\n+    private static List<ThrowsTree> findByExceptionType(Element exceptionType,\n+                                                        ExecutableElement executable,\n+                                                        Utils utils) {\n+        var result = new LinkedList<ThrowsTree>();\n+        for (ThrowsTree t : utils.getThrowsTrees(executable)) {\n+            CommentHelper ch = utils.getCommentHelper(executable);\n+            Element candidate = ch.getException(t);\n+            if (exceptionType.equals(candidate)) { \/\/ candidate may be null\n+                result.add(t);\n+            }\n+        }\n+        return result;\n+    }\n+\n+    \/*\n+     * An exception section (that is, the \"Throws:\" section in the Method\n+     * or Constructor Details section) builder.\n+     *\n+     * The section is being built sequentially from top to bottom.\n+     *\n+     * Adapts one off methods of writer to continuous building.\n+     *\/\n+    private static class ExceptionSectionBuilder {\n+\n+        private final TagletWriter writer;\n+        private final Content result;\n+        private ContentBuilder current;\n+        private boolean began;\n+        private boolean headerAdded;\n+        private TypeMirror exceptionType;\n+\n+        ExceptionSectionBuilder(TagletWriter writer) {\n+            this.writer = writer;\n+            this.result = writer.getOutputInstance();\n+        }\n+\n+        void beginEntry(TypeMirror exceptionType) {\n+            if (began) {\n+                throw new IllegalStateException();\n+            }\n+            began = true;\n+            current = new ContentBuilder();\n+            this.exceptionType = exceptionType;\n+        }\n+\n+        void continueEntry(Content c) {\n+            if (!began) {\n+                throw new IllegalStateException();\n+            }\n+            current.add(c);\n+        }\n+\n+        public void endEntry() {\n+            if (!began) {\n+                throw new IllegalStateException();\n+            }\n+            began = false;\n+            if (!headerAdded) {\n+                headerAdded = true;\n+                result.add(writer.getThrowsHeader());\n+            }\n+            result.add(writer.throwsTagOutput(exceptionType, current.isEmpty() ? Optional.empty() : Optional.of(current)));\n+            current = null;\n+        }\n+\n+        Content build() {\n+            return result;\n+        }\n+    }\n+\n@@ -119,1 +568,1 @@\n-     * name as a key and the instantiated type as a value. If no types need to be substituted\n+     * as a key and the instantiated type as a value. If no types need to be substituted\n@@ -125,3 +574,3 @@\n-    private Map<String, TypeMirror> getSubstitutedThrownTypes(Types types,\n-                                                              List<? extends TypeMirror> declaredThrownTypes,\n-                                                              List<? extends TypeMirror> instantiatedThrownTypes) {\n+    private Map<TypeMirror, TypeMirror> getSubstitutedThrownTypes(Types types,\n+                                                                  List<? extends TypeMirror> declaredThrownTypes,\n+                                                                  List<? extends TypeMirror> instantiatedThrownTypes) {\n@@ -129,1 +578,1 @@\n-            Map<String, TypeMirror> map = new HashMap<>();\n+            Map<TypeMirror, TypeMirror> map = new HashMap<>();\n@@ -136,1 +585,1 @@\n-                    map.put(t1.toString(), t2);\n+                    map.put(t1, t2);\n@@ -143,33 +592,11 @@\n-    \/**\n-     * Returns the generated content for a collection of {@code @throws} tags.\n-     *\n-     * @param throwsTags        the tags to be converted; each tag is mapped to\n-     *                          a method it appears on\n-     * @param alreadyDocumented the set of exceptions that have already been\n-     *                          documented and thus must not be documented by\n-     *                          this method. All exceptions documented by this\n-     *                          method will be added to this set upon the\n-     *                          method's return.\n-     * @param writer            the taglet-writer used by the doclet\n-     * @return the generated content for the tags\n-     *\/\n-    private Content throwsTagsOutput(Map<ThrowsTree, ExecutableElement> throwsTags,\n-                                     Set<String> alreadyDocumented,\n-                                     Map<String, TypeMirror> typeSubstitutions,\n-                                     TagletWriter writer) {\n-        var utils = writer.configuration().utils;\n-        Content result = writer.getOutputInstance();\n-        var documentedInThisCall = new HashSet<String>();\n-        Map<ThrowsTree, ExecutableElement> flattenedExceptions = flatten(throwsTags, writer);\n-        flattenedExceptions.forEach((ThrowsTree t, ExecutableElement e) -> {\n-            var ch = utils.getCommentHelper(e);\n-            Element te = ch.getException(t);\n-            String excName = t.getExceptionName().toString();\n-            TypeMirror substituteType = typeSubstitutions.get(excName);\n-            if (alreadyDocumented.contains(excName)\n-                    || (te != null && alreadyDocumented.contains(utils.getFullyQualifiedName(te, false)))\n-                    || (substituteType != null && alreadyDocumented.contains(substituteType.toString()))) {\n-                return;\n-            }\n-            if (alreadyDocumented.isEmpty() && documentedInThisCall.isEmpty()) {\n-                result.add(writer.getThrowsHeader());\n+    private record Result(List<? extends ThrowsTree> throwsTrees, ExecutableElement method) { }\n+\n+    private static Optional<Result> extract(ExecutableElement method, TypeMirror targetExceptionType, Utils utils) {\n+        \/\/ FIXME: find substitutions?\n+        var ch = utils.getCommentHelper(method);\n+        List<ThrowsTree> tags = new LinkedList<>();\n+        for (ThrowsTree tag : utils.getThrowsTrees(method)) {\n+            Element candidate = ch.getException(tag);\n+            if (candidate == null) {\n+                errorUnknownException(utils.configuration, ch, tag);\n+                continue;\n@@ -177,7 +604,2 @@\n-            result.add(writer.throwsTagOutput(e, t, substituteType));\n-            if (substituteType != null) {\n-                documentedInThisCall.add(substituteType.toString());\n-            } else {\n-                documentedInThisCall.add(te != null\n-                        ? utils.getFullyQualifiedName(te, false)\n-                        : excName);\n+            if (utils.typeUtils.isSameType(candidate.asType(), targetExceptionType)) {\n+                tags.add(tag);\n@@ -185,3 +607,2 @@\n-        });\n-        alreadyDocumented.addAll(documentedInThisCall);\n-        return result;\n+        }\n+        return tags.isEmpty() ? Optional.empty() : Optional.of(new Result(tags, method));\n@@ -190,13 +611,5 @@\n-    \/*\n-     * A single @throws tag from an overriding method can correspond to multiple\n-     * @throws tags from an overridden method.\n-     *\/\n-    private Map<ThrowsTree, ExecutableElement> flatten(Map<ThrowsTree, ExecutableElement> throwsTags,\n-                                                       TagletWriter writer) {\n-        Map<ThrowsTree, ExecutableElement> result = new LinkedHashMap<>();\n-        throwsTags.forEach((tag, taggedElement) -> {\n-            var expandedTags = expand(tag, taggedElement, writer);\n-            assert Collections.disjoint(result.entrySet(), expandedTags.entrySet());\n-            result.putAll(expandedTags);\n-        });\n-        return result;\n+    private static void errorUnknownException(BaseConfiguration configuration,\n+                                              CommentHelper ch,\n+                                              ThrowsTree tag) {\n+        configuration.getMessages().error(ch.getDocTreePath(tag),\n+                \"doclet.throws.reference_not_found\", tag.getExceptionName());\n@@ -205,29 +618,2 @@\n-    private Map<ThrowsTree, ExecutableElement> expand(ThrowsTree tag,\n-                                                      ExecutableElement e,\n-                                                      TagletWriter writer) {\n-\n-        \/\/ This method uses Map.of() to create maps of size zero and one.\n-        \/\/ While such maps are effectively ordered, the syntax is more\n-        \/\/ compact than that of LinkedHashMap.\n-\n-        \/\/ peek into @throws description\n-        if (tag.getDescription().stream().noneMatch(d -> d.getKind() == DocTree.Kind.INHERIT_DOC)) {\n-            \/\/ nothing to inherit\n-            return Map.of(tag, e);\n-        }\n-        var input = new DocFinder.Input(writer.configuration().utils, e, this, new DocFinder.DocTreeInfo(tag, e), false, true);\n-        var output = DocFinder.search(writer.configuration(), input);\n-        if (output.tagList.size() <= 1) {\n-            \/\/ outer code will handle this trivial case of inheritance\n-            return Map.of(tag, e);\n-        }\n-        if (tag.getDescription().size() > 1) {\n-            \/\/ there's more to description than just {@inheritDoc}\n-            \/\/ it's likely a documentation error\n-            var ch = writer.configuration().utils.getCommentHelper(e);\n-            writer.configuration().getMessages().error(ch.getDocTreePath(tag), \"doclet.inheritDocWithinInappropriateTag\");\n-            return Map.of();\n-        }\n-        Map<ThrowsTree, ExecutableElement> tags = new LinkedHashMap<>();\n-        output.tagList.forEach(t -> tags.put((ThrowsTree) t, (ExecutableElement) output.holder));\n-        return tags;\n+    private static AssertionError newAssertionError(Object... objects) {\n+        return new AssertionError(Arrays.toString(objects));\n@@ -236,40 +622,3 @@\n-    \/**\n-     * Inherit throws documentation for exceptions that were declared but not\n-     * documented.\n-     *\/\n-    private Content inheritThrowsDocumentation(ExecutableElement holder,\n-                                               List<? extends TypeMirror> declaredExceptionTypes,\n-                                               Set<String> alreadyDocumented,\n-                                               Map<String, TypeMirror> typeSubstitutions,\n-                                               TagletWriter writer) {\n-        Content result = writer.getOutputInstance();\n-        if (holder.getKind() != ElementKind.METHOD) {\n-            \/\/ (Optimization.)\n-            \/\/ Of all executable elements, only methods and constructors are documented.\n-            \/\/ Of these two, only methods inherit documentation.\n-            \/\/ Don't waste time on constructors.\n-            assert holder.getKind() == ElementKind.CONSTRUCTOR : holder.getKind();\n-            return result;\n-        }\n-        var utils = writer.configuration().utils;\n-        Map<ThrowsTree, ExecutableElement> declaredExceptionTags = new LinkedHashMap<>();\n-        for (TypeMirror declaredExceptionType : declaredExceptionTypes) {\n-            var input = new DocFinder.Input(utils, holder, this,\n-                    utils.getTypeName(declaredExceptionType, false));\n-            DocFinder.Output inheritedDoc = DocFinder.search(writer.configuration(), input);\n-            if (inheritedDoc.tagList.isEmpty()) {\n-                input = new DocFinder.Input(utils, holder, this,\n-                        utils.getTypeName(declaredExceptionType, true));\n-                inheritedDoc = DocFinder.search(writer.configuration(), input);\n-            }\n-            if (!inheritedDoc.tagList.isEmpty()) {\n-                if (inheritedDoc.holder == null) {\n-                    inheritedDoc.holder = holder;\n-                }\n-                var h = (ExecutableElement) inheritedDoc.holder;\n-                inheritedDoc.tagList.forEach(t -> declaredExceptionTags.put((ThrowsTree) t, h));\n-            }\n-        }\n-        result.add(throwsTagsOutput(declaredExceptionTags, alreadyDocumented, typeSubstitutions,\n-                writer));\n-        return result;\n+    private static String diagnosticDescriptionOf(Element e) {\n+        var name = e instanceof QualifiedNameable q ? q.getQualifiedName() : e.getSimpleName();\n+        return name + \" (\" + detailedDescriptionOf(e) + \")\";\n@@ -278,16 +627,18 @@\n-    private Content linkToUndocumentedDeclaredExceptions(List<? extends TypeMirror> declaredExceptionTypes,\n-                                                         Set<String> alreadyDocumented,\n-                                                         TagletWriter writer) {\n-        \/\/ TODO: assert declaredExceptionTypes are instantiated\n-        var utils = writer.configuration().utils;\n-        Content result = writer.getOutputInstance();\n-        for (TypeMirror declaredExceptionType : declaredExceptionTypes) {\n-            TypeElement te = utils.asTypeElement(declaredExceptionType);\n-            if (te != null &&\n-                    !alreadyDocumented.contains(declaredExceptionType.toString()) &&\n-                    !alreadyDocumented.contains(utils.getFullyQualifiedName(te, false))) {\n-                if (alreadyDocumented.isEmpty()) {\n-                    result.add(writer.getThrowsHeader());\n-                }\n-                result.add(writer.throwsTagOutput(declaredExceptionType));\n-                alreadyDocumented.add(utils.getSimpleName(te));\n+    private static String detailedDescriptionOf(Element e) {\n+        \/\/ It might be important to describe the element in detail. Sometimes\n+        \/\/ elements share the same simple and\/or qualified name. Outputting\n+        \/\/ individual components of that name as well as their kinds helps\n+        \/\/ the user disambiguate such elements.\n+        \/\/ TODO: is it feasible to use javax.lang.model.util.Elements.getBinaryName(TypeElement)\n+        \/\/  to augment\/replace detailed information for _type elements_?\n+        \/\/  (binary names don't work for _type variables_)\n+        var thisElementDescription = e.getKind() + \" \" + switch (e.getKind()) {\n+            \/\/ A package is never enclosed in a package and a module is\n+            \/\/ never never enclosed in a module, no matter what their\n+            \/\/ qualified name might suggest. Get their qualified\n+            \/\/ name directly. Also, unnamed packages and\n+            \/\/ modules require special treatment.\n+            case PACKAGE -> {\n+                var p = (PackageElement) e;\n+                \/\/ TODO: i18n\n+                yield p.isUnnamed() ? \"<unnamed package>\" : p.getQualifiedName();\n@@ -295,0 +646,9 @@\n+            case MODULE -> {\n+                var m = (ModuleElement) e;\n+                \/\/ TODO: i18n + is there any value is displaying unnamed module?\n+                yield m.isUnnamed() ? \"<unnamed module>\" : m.getQualifiedName();\n+            }\n+            default -> e.getSimpleName();\n+        };\n+        if (e.getEnclosingElement() == null) {\n+            return thisElementDescription;\n@@ -296,1 +656,2 @@\n-        return result;\n+        var enclosingElementDescription = detailedDescriptionOf(e.getEnclosingElement());\n+        return enclosingElementDescription + \" \" + thisElementDescription;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/ThrowsTaglet.java","additions":553,"deletions":192,"binary":false,"changes":745,"status":"modified"},{"patch":"@@ -69,0 +69,1 @@\n+import java.util.Optional;\n@@ -128,0 +129,1 @@\n+        \/\/ We need to lookup type variables and other types\n@@ -536,4 +538,4 @@\n-        DocFinder.Output inheritedDoc =\n-                DocFinder.search(configuration,\n-                        new DocFinder.Input(utils, ee));\n-        return inheritedDoc.holder == ee\n+        var docFinder = utils.docFinder();\n+        Optional<ExecutableElement> inheritedDoc = docFinder.search(ee,\n+                (m -> utils.getFullBody(m).isEmpty() ? Optional.empty() : Optional.of(m)));\n+        return inheritedDoc.isEmpty() || inheritedDoc.get().equals(ee)\n@@ -541,1 +543,1 @@\n-                : utils.getCommentHelper(inheritedDoc.holder).getDocTreePath(dtree);\n+                : utils.getCommentHelper(inheritedDoc.get()).getDocTreePath(dtree);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/CommentHelper.java","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -28,1 +28,7 @@\n-import java.util.*;\n+import java.util.Deque;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.NoSuchElementException;\n+import java.util.Optional;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n@@ -30,1 +36,1 @@\n-import javax.lang.model.element.Element;\n+import javax.lang.model.element.ElementKind;\n@@ -32,1 +38,0 @@\n-import javax.lang.model.element.TypeElement;\n@@ -34,7 +39,0 @@\n-import com.sun.source.doctree.DocTree;\n-import jdk.javadoc.internal.doclets.toolkit.BaseConfiguration;\n-import jdk.javadoc.internal.doclets.toolkit.taglets.InheritableTaglet;\n-\n-\/**\n- * Search for the requested documentation.  Inherit documentation if necessary.\n- *\/\n@@ -43,4 +41,39 @@\n-    public record DocTreeInfo(DocTree docTree, Element element) { }\n-\n-    \/**\n-     * The class that encapsulates the input.\n+    \/*\n+     * A specialized function that accepts a method and either returns an\n+     * optional result or throws a possibly checked exception, which\n+     * terminates the search and transparently bubbles up the stack.\n+     *\n+     * If a method does not meet the criterion, returns an empty optional.\n+     *\n+     * In a rare case, if a criterion performs inner searches and the search\n+     * client needs to disambiguate between the outer search exceptions and\n+     * any inner search exceptions, the criterion needs to provide extra code\n+     * (to wrap and\/or unwrap exceptions). For example:\n+     *\n+     *     try {\n+     *         r = finder.trySearch(method, m -> {\n+     *             ...\n+     *             try {\n+     *                 r1 = finder.trySearch(...);\n+     *             } catch (NoOverriddenMethodsFound e) {\n+     *                 throw new MyInnerSearchException(e);\n+     *             }\n+     *             ...\n+     *         });\n+     *     } catch (NoOverriddenMethodsFound e) {\n+     *         ...\n+     *     } catch (MyInnerSearchException e) {\n+     *         ...\n+     *     }\n+     *\n+     * Since such a use case should be rare, this API does not account for it.\n+     * This allows to reduce bloat and streamline a typical use case.\n+     *\n+     * Here are some examples of the API bloat avoided:\n+     *\n+     *   - unconditional unwrapping of a dedicated exception thrown by\n+     *     a search method\n+     *   - either unconditional handling of a dedicated exception thrown by\n+     *     a search method, or having multiple (overloaded?) search methods\n+     *     and types of criterion: a criterion that can throw and a criterion\n+     *     that cannot throw an exception\n@@ -48,6 +81,4 @@\n-    public static class Input {\n-\n-        \/**\n-         * The element to search documentation from.\n-         *\/\n-        public Element element;\n+    @FunctionalInterface\n+    public interface Criterion<T, X extends Throwable> {\n+        Optional<T> apply(ExecutableElement method) throws X;\n+    }\n@@ -55,5 +86,2 @@\n-        \/**\n-         * The taglet to search for documentation on behalf of. Null if we want\n-         * to search for overall documentation.\n-         *\/\n-        public InheritableTaglet taglet;\n+    private final Function<ExecutableElement, ExecutableElement> overriddenMethodLookup;\n+    private final BiFunction<ExecutableElement, ExecutableElement, Iterable<ExecutableElement>> implementedMethodsLookup;\n@@ -61,4 +89,5 @@\n-        \/**\n-         * The id of the tag to retrieve documentation for.\n-         *\/\n-        public String tagId;\n+    DocFinder(Function<ExecutableElement, ExecutableElement> overriddenMethodLookup,\n+              BiFunction<ExecutableElement, ExecutableElement, Iterable<ExecutableElement>> implementedMethodsLookup) {\n+        this.overriddenMethodLookup = overriddenMethodLookup;\n+        this.implementedMethodsLookup = implementedMethodsLookup;\n+    }\n@@ -66,5 +95,3 @@\n-        \/**\n-         * The tag to retrieve documentation for.  This is only used for the\n-         * {@code {@inheritDoc}} tag.\n-         *\/\n-        public final DocTreeInfo docTreeInfo;\n+    public static final class NoOverriddenMethodsFound extends Exception {\n+        @java.io.Serial\n+        private static final long serialVersionUID = 1L;\n@@ -72,4 +99,3 @@\n-        \/**\n-         * True if we only want to search for the first sentence.\n-         *\/\n-        public boolean isFirstSentence;\n+        \/\/ only DocFinder should instantiate this exception\n+        private NoOverriddenMethodsFound() { }\n+    }\n@@ -77,4 +103,6 @@\n-        \/**\n-         * True if we are looking for documentation to replace the {@code {@inheritDoc}} tag.\n-         *\/\n-        public boolean isInheritDocTag;\n+    public <T, X extends Throwable> Optional<T> search(ExecutableElement method,\n+                                                       Criterion<T, X> criterion)\n+            throws X\n+    {\n+        return search(method, true, criterion);\n+    }\n@@ -82,5 +110,12 @@\n-        \/**\n-         * Used to distinguish between type variable param tags and regular\n-         * param tags.\n-         *\/\n-        public boolean isTypeVariableParamTag;\n+    public <T, X extends Throwable> Optional<T> search(ExecutableElement method,\n+                                                       boolean includeMethod,\n+                                                       Criterion<T, X> criterion)\n+            throws X\n+    {\n+        try {\n+            return search0(method, includeMethod, false, criterion);\n+        } catch (NoOverriddenMethodsFound e) {\n+            \/\/ should not happen because the exception flag is unset\n+            throw new AssertionError(e);\n+        }\n+    }\n@@ -88,1 +123,6 @@\n-        public final Utils utils;\n+    public <T, X extends Throwable> Optional<T> trySearch(ExecutableElement method,\n+                                                          Criterion<T, X> criterion)\n+            throws NoOverriddenMethodsFound, X\n+    {\n+        return search0(method, false, true, criterion);\n+    }\n@@ -90,7 +130,26 @@\n-        public Input(Utils utils,\n-                     Element element,\n-                     InheritableTaglet taglet,\n-                     String tagId) {\n-            this(utils, element);\n-            this.taglet = taglet;\n-            this.tagId = tagId;\n+    \/*\n+     * Overridden methods hierarchy search.\n+     *\n+     * Depending on how it is instructed, search starts either from the given\n+     * method or the first method it overrides. The search then applies the\n+     * given criterion to that method and methods up the hierarchy, in order,\n+     * until either of the following happens:\n+     *\n+     *  - the criterion returns a non-empty optional\n+     *  - the criterion throws an exception\n+     *  - the hierarchy is exhausted\n+     *  - the given method overrides no methods and\n+     *    the search is instructed to detect that\n+     *\/\n+    private <T, X extends Throwable> Optional<T> search0(ExecutableElement method,\n+                                                         boolean includeMethodInSearch,\n+                                                         boolean throwExceptionIfDoesNotOverride,\n+                                                         Criterion<T, X> criterion)\n+            throws NoOverriddenMethodsFound, X\n+    {\n+        \/\/ if required, first check if the method overrides anything, so that\n+        \/\/ the result would not depend on whether the method itself is included\n+        \/\/ in the search\n+        Iterator<ExecutableElement> overriddenMethods = new OverriddenMethodsHierarchy(method);\n+        if (throwExceptionIfDoesNotOverride && !overriddenMethods.hasNext()) {\n+            throw new NoOverriddenMethodsFound();\n@@ -98,10 +157,4 @@\n-\n-        public Input(Utils utils,\n-                     Element element,\n-                     InheritableTaglet taglet,\n-                     String tagId,\n-                     boolean isTypeVariableParamTag) {\n-            this(utils, element);\n-            this.taglet = taglet;\n-            this.tagId = tagId;\n-            this.isTypeVariableParamTag = isTypeVariableParamTag;\n+        if (includeMethodInSearch) {\n+            Optional<T> r = criterion.apply(method);\n+            if (r.isPresent())\n+                return r;\n@@ -109,4 +162,5 @@\n-\n-        public Input(Utils utils, Element element, InheritableTaglet taglet) {\n-            this(utils, element);\n-            this.taglet = taglet;\n+        while (overriddenMethods.hasNext()) {\n+            ExecutableElement m = overriddenMethods.next();\n+            Optional<T> r = criterion.apply(m);\n+            if (r.isPresent())\n+                return r;\n@@ -114,0 +168,2 @@\n+        return Optional.empty();\n+    }\n@@ -115,5 +171,14 @@\n-        public Input(Utils utils, Element element) {\n-            this.element = Objects.requireNonNull(element);\n-            this.utils = utils;\n-            this.docTreeInfo = new DocTreeInfo(null, null);\n-        }\n+    \/*\n+     * An iterator over methods overridden by some method.\n+     *\n+     * The iteration order is as defined in the Documentation Comment\n+     * Specification for the Standard Doclet.\n+     *\n+     * This iterator can be used to create a stream; for example:\n+     *\n+     *     var spliterator = Spliterators.spliteratorUnknownSize(iterator,\n+     *             Spliterator.ORDERED | Spliterator.NONNULL\n+     *                     | Spliterator.IMMUTABLE | Spliterator.DISTINCT);\n+     *     var stream = StreamSupport.stream(spliterator, false);\n+     *\/\n+    private class OverriddenMethodsHierarchy implements Iterator<ExecutableElement> {\n@@ -121,13 +186,2 @@\n-        public Input(Utils utils,\n-                     Element element,\n-                     InheritableTaglet taglet,\n-                     DocTreeInfo dtInfo,\n-                     boolean isFirstSentence,\n-                     boolean isInheritDocTag) {\n-            this.utils = utils;\n-            this.element = Objects.requireNonNull(element);\n-            this.taglet = taglet;\n-            this.isFirstSentence = isFirstSentence;\n-            this.isInheritDocTag = isInheritDocTag;\n-            this.docTreeInfo = dtInfo;\n-        }\n+        final Deque<LazilyAccessedImplementedMethods> path = new LinkedList<>();\n+        ExecutableElement next;\n@@ -135,6 +189,4 @@\n-        private Input copy() {\n-            var copy = new Input(utils, element, taglet, docTreeInfo,\n-                    isFirstSentence, isInheritDocTag);\n-            copy.tagId = tagId;\n-            copy.isTypeVariableParamTag = isTypeVariableParamTag;\n-            return copy;\n+        public OverriddenMethodsHierarchy(ExecutableElement method) {\n+            assert method.getKind() == ElementKind.METHOD : method.getKind();\n+            next = method;\n+            updateNext();\n@@ -143,3 +195,0 @@\n-        \/**\n-         * For debugging purposes.\n-         *\/\n@@ -147,9 +196,2 @@\n-        public String toString() {\n-            String encl = element == null ? \"\" : element.getEnclosingElement().toString() + \"::\";\n-            return \"Input{\" + \"element=\" + encl + element\n-                    + \", taglet=\" + taglet\n-                    + \", tagId=\" + tagId + \", tag=\" + docTreeInfo\n-                    + \", isFirstSentence=\" + isFirstSentence\n-                    + \", isInheritDocTag=\" + isInheritDocTag\n-                    + \", isTypeVariableParamTag=\" + isTypeVariableParamTag\n-                    + \", utils=\" + utils + '}';\n+        public boolean hasNext() {\n+            return next != null;\n@@ -157,12 +199,0 @@\n-    }\n-\n-    \/**\n-     * The class that encapsulates the output.\n-     *\/\n-    public static class Output {\n-\n-        \/**\n-         * The tag that holds the documentation.  Null if documentation\n-         * is not held by a tag.\n-         *\/\n-        public DocTree holderTag;\n@@ -170,4 +200,9 @@\n-        \/**\n-         * The element that holds the documentation.\n-         *\/\n-        public Element holder;\n+        @Override\n+        public ExecutableElement next() {\n+            if (next == null) {\n+                throw new NoSuchElementException();\n+            }\n+            var r = next;\n+            updateNext();\n+            return r;\n+        }\n@@ -175,4 +210,19 @@\n-        \/**\n-         * The inherited documentation.\n-         *\/\n-        public List<? extends DocTree> inlineTags = List.of();\n+        private void updateNext() {\n+            assert next != null;\n+            var superClassMethod = overriddenMethodLookup.apply(next);\n+            path.push(new LazilyAccessedImplementedMethods(next));\n+            if (superClassMethod != null) {\n+                next = superClassMethod;\n+                return;\n+            }\n+            while (!path.isEmpty()) {\n+                var superInterfaceMethods = path.peek();\n+                if (superInterfaceMethods.hasNext()) {\n+                    next = superInterfaceMethods.next();\n+                    return;\n+                } else {\n+                    path.pop();\n+                }\n+            }\n+            next = null; \/\/ end-of-hierarchy\n+        }\n@@ -180,4 +230,1 @@\n-        \/**\n-         * False if documentation could not be inherited.\n-         *\/\n-        public boolean isValidInheritDocTag = true;\n+        class LazilyAccessedImplementedMethods implements Iterator<ExecutableElement> {\n@@ -185,8 +232,2 @@\n-        \/**\n-         * When automatically inheriting throws tags, you sometimes must inherit\n-         * more than one tag.  For example, if a method declares that it throws\n-         * IOException and the overridden method has {@code @throws} tags for IOException and\n-         * ZipException, both tags would be inherited because ZipException is a\n-         * subclass of IOException.  This allows multiple tag inheritance.\n-         *\/\n-        public final List<DocTree> tagList = new ArrayList<>();\n+            final ExecutableElement method;\n+            Iterator<ExecutableElement> iterator;\n@@ -194,13 +235,3 @@\n-        \/**\n-         * For debugging purposes.\n-         *\/\n-        @Override\n-        public String toString() {\n-            String encl = holder == null ? \"\" : holder.getEnclosingElement().toString() + \"::\";\n-            return \"Output{\" + \"holderTag=\" + holderTag\n-                    + \", holder=\" + encl + holder\n-                    + \", inlineTags=\" + inlineTags\n-                    + \", isValidInheritDocTag=\" + isValidInheritDocTag\n-                    + \", tagList=\" + tagList + '}';\n-        }\n-    }\n+            public LazilyAccessedImplementedMethods(ExecutableElement method) {\n+                this.method = method;\n+            }\n@@ -208,23 +239,4 @@\n-    \/**\n-     * Search for the requested comments in the given element.  If it does not\n-     * have comments, return the inherited comments if possible.\n-     *\n-     * @param input the input object used to perform the search.\n-     *\n-     * @return an Output object representing the documentation that was found.\n-     *\/\n-    public static Output search(BaseConfiguration configuration, Input input) {\n-        Output output = new Output();\n-        Utils utils = configuration.utils;\n-        if (input.isInheritDocTag) {\n-            \/\/Do nothing because \"element\" does not have any documentation.\n-            \/\/All it has is {@inheritDoc}.\n-        } else if (input.taglet == null) {\n-            \/\/We want overall documentation.\n-            output.inlineTags = input.isFirstSentence\n-                    ? utils.getFirstSentenceTrees(input.element)\n-                    : utils.getFullBody(input.element);\n-            output.holder = input.element;\n-        } else {\n-            input.taglet.inherit(input, output);\n-        }\n+            @Override\n+            public boolean hasNext() {\n+                return getIterator().hasNext();\n+            }\n@@ -232,16 +244,3 @@\n-        if (!output.inlineTags.isEmpty()) {\n-            return output;\n-        }\n-        output.isValidInheritDocTag = false;\n-        Input inheritedSearchInput = input.copy();\n-        inheritedSearchInput.isInheritDocTag = false;\n-        if (utils.isMethod(input.element)) {\n-            ExecutableElement m = (ExecutableElement) input.element;\n-            ExecutableElement overriddenMethod = utils.overriddenMethod(m);\n-            if (overriddenMethod != null) {\n-                inheritedSearchInput.element = overriddenMethod;\n-                output = search(configuration, inheritedSearchInput);\n-                output.isValidInheritDocTag = true;\n-                if (!output.inlineTags.isEmpty()) {\n-                    return output;\n-                }\n+            @Override\n+            public ExecutableElement next() {\n+                return getIterator().next();\n@@ -249,9 +248,4 @@\n-            TypeElement encl = utils.getEnclosingTypeElement(input.element);\n-            VisibleMemberTable vmt = configuration.getVisibleMemberTable(encl);\n-            List<ExecutableElement> implementedMethods = vmt.getImplementedMethods(m);\n-            for (ExecutableElement implementedMethod : implementedMethods) {\n-                inheritedSearchInput.element = implementedMethod;\n-                output = search(configuration, inheritedSearchInput);\n-                output.isValidInheritDocTag = true;\n-                if (!output.inlineTags.isEmpty()) {\n-                    return output;\n+\n+            Iterator<ExecutableElement> getIterator() {\n+                if (iterator != null) {\n+                    return iterator;\n@@ -259,0 +253,1 @@\n+                return iterator = implementedMethodsLookup.apply(method, next).iterator();\n@@ -261,1 +256,0 @@\n-        return output;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/DocFinder.java","additions":193,"deletions":199,"binary":false,"changes":392,"status":"modified"},{"patch":"@@ -141,0 +141,1 @@\n+    private final DocFinder docFinder = newDocFinder();\n@@ -1917,0 +1918,3 @@\n+    \/\/ If `e` is a static nested class, this method will return e's simple name\n+    \/\/ preceded by `.` and an outer type; this is not how JLS defines \"simple\n+    \/\/ name\". See \"Simple Name\", \"Qualified Name\", \"Fully Qualified Name\".\n@@ -1930,1 +1934,1 @@\n-                            && (enclosed.getKind().isClass() || enclosed.getKind().isInterface())) {\n+                            && (enclosed.getKind().isDeclaredType())) {\n@@ -2799,0 +2803,12 @@\n+    public DocFinder docFinder() {\n+        return docFinder;\n+    }\n+\n+    private DocFinder newDocFinder() {\n+        return new DocFinder(this::overriddenMethod, this::implementedMethods);\n+    }\n+\n+    private Iterable<ExecutableElement> implementedMethods(ExecutableElement originalMethod, ExecutableElement m) {\n+        var type = configuration.utils.getEnclosingTypeElement(m);\n+        return configuration.getVisibleMemberTable(type).getImplementedMethods(originalMethod);\n+    }\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/Utils.java","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -188,1 +188,1 @@\n-                    <dd><code>HeadlessException<\/code><\/dd>\n+                    <dd><code>java.awt.HeadlessException<\/code><\/dd>\n@@ -307,1 +307,1 @@\n-                    <dd><code>HeadlessException<\/code><\/dd>\n+                    <dd><code>java.awt.HeadlessException<\/code><\/dd>\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testHtmlDefinitionListTag\/TestHtmlDefinitionListTag.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -77,1 +77,1 @@\n-     * @exception HeadlessException\n+     * @exception java.awt.HeadlessException\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testHtmlDefinitionListTag\/pkg1\/C1.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-        for (int i = 1; i < 40; i++) {\n+        for (int i = 1; i < 39; i++) {\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testTagInheritance\/TestTagInheritance.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2003, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -69,1 +69,0 @@\n-     * @throws java.util.zip.ZipException Test 39 passes.\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testTagInheritance\/pkg\/TestAbstractClass.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,18 @@\n+    \/\/ NOTE: Not sure why this test suggests that IndexOutOfBoundsException\n+    \/\/ should not appear due to compatibility with some buggy behavior.\n+    \/\/\n+    \/\/ Here's the expected behavior: documentation for an exception X is never\n+    \/\/ inherited by an overrider unless it \"pulls\" it by either (or both)\n+    \/\/ of these:\n+    \/\/\n+    \/\/   * tag:\n+    \/\/       @throws X {@inheritDoc}\n+    \/\/   * clause:\n+    \/\/       throws ..., X,...\n+    \/\/\n+    \/\/ Neither of those are applicable here. Even taking into account\n+    \/\/ mechanisms such as the one introduced in 4947455, neither of\n+    \/\/ NullPointerException and IndexOutOfBoundsException is a subclass\n+    \/\/ of the other.\n+    \/\/\n+    \/\/ So, IndexOutOfBoundsException should not appear in Extender.\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testThrowsInheritance\/pkg\/Abstract.java","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -0,0 +1,491 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8291869\n+ * @library \/tools\/lib ..\/..\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ *          jdk.javadoc\/jdk.javadoc.internal.tool\n+ * @build toolbox.ToolBox javadoc.tester.*\n+ * @run main TestExceptionTypeMatching\n+ *\/\n+\n+import javadoc.tester.JavadocTester;\n+import toolbox.ToolBox;\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+\n+\/*\n+ * The goal of the tests in this suite is two-fold:\n+ *\n+ * 1. Provoke javadoc into treating like-named but different elements as\n+ *    the same element\n+ * 2. Provoke javadoc into treating differently named but semantically\n+ *    same elements as different elements\n+ *\/\n+public class TestExceptionTypeMatching extends JavadocTester {\n+\n+    public static void main(String... args) throws Exception {\n+        var tester = new TestExceptionTypeMatching();\n+        tester.runTests(m -> new Object[]{Paths.get(m.getName())});\n+    }\n+\n+    private final ToolBox tb = new ToolBox();\n+\n+    \/*\n+     * In Child, MyException is c.MyException, whereas in Parent, MyException\n+     * is p.MyException. Those are different exceptions which happen two\n+     * share a simple name.\n+     *\/\n+    @Test\n+    public void testDifferentPackages(Path base) throws Exception {\n+        var src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src, \"\"\"\n+                package c;\n+\n+                import p.Parent;\n+\n+                public class Child extends Parent {\n+\n+                    \/** @throws MyException {@inheritDoc} *\/\n+                    @Override\n+                    public void m() { }\n+                }\n+                \"\"\", \"\"\"\n+                package c;\n+\n+                public class MyException extends RuntimeException { }\n+\n+                \"\"\", \"\"\"\n+                package p;\n+\n+                public class Parent {\n+\n+                    \/** @throws MyException sometimes *\/\n+                    public void m() { }\n+                }\n+                \"\"\", \"\"\"\n+                package p;\n+\n+                public class MyException extends RuntimeException { }\n+                \"\"\");\n+        javadoc(\"-d\", base.resolve(\"out\").toString(), \"-sourcepath\", src.toString(), \"c\", \"p\");\n+        checkExit(Exit.OK);\n+        checkOutput(Output.OUT, true, \"\"\"\n+                Child.java:7: warning: overridden methods do not document exception type c.MyException \\\n+                (MODULE <unnamed module> PACKAGE c CLASS MyException)\n+                    \/** @throws MyException {@inheritDoc} *\/\n+                        ^\n+                \"\"\");\n+    }\n+\n+    \/*\n+     * Type parameters declared by methods where one of the methods overrides\n+     * the other, are matched by position, not by name. In this example, <P>\n+     * and <R> are semantically the same.\n+     *\/\n+    @Test\n+    public void testDifferentTypeVariables1(Path base) throws Exception {\n+        var src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src, \"\"\"\n+                package x;\n+\n+                public class Parent {\n+\n+                    \/** @throws P sometimes *\/\n+                    public <P extends RuntimeException> void m() { }\n+                }\n+                \"\"\", \"\"\"\n+                package x;\n+\n+                public class Child extends Parent {\n+\n+                    \/** @throws R {@inheritDoc} *\/\n+                    @Override\n+                    public <R extends RuntimeException> void m() { }\n+                }\n+                \"\"\");\n+        javadoc(\"-d\", base.resolve(\"out\").toString(), \"-sourcepath\", src.toString(), \"x\");\n+        checkExit(Exit.OK);\n+        checkOutput(\"x\/Child.html\", true, \"\"\"\n+                <dl class=\"notes\">\n+                <dt>Overrides:<\/dt>\n+                <dd><code><a href=\"Parent.html#m()\">m<\/a><\/code>&nbsp;in class&nbsp;<code>\\\n+                <a href=\"Parent.html\" title=\"class in x\">Parent<\/a><\/code><\/dd>\n+                <dt>Throws:<\/dt>\n+                <dd><code>R<\/code> - sometimes<\/dd>\n+                <\/dl>\n+                \"\"\");\n+    }\n+\n+    \/*\n+     * Type parameters declared by methods where one of the methods overrides\n+     * the other, are matched by position, not by name.\n+     *\n+     * Here the match is cris-cross:\n+     *\n+     *   - Child.m's <K> corresponds to Parent.m's <V>\n+     *   - Child.m's <V> corresponds to Parent.m's <K>\n+     *\/\n+    @Test\n+    public void testDifferentTypeVariables2(Path base) throws Exception {\n+        var src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src, \"\"\"\n+                package x;\n+\n+                public class Parent {\n+\n+                    \/**\n+                     * @throws K some of the times\n+                     * @throws V other times\n+                     *\/\n+                    public <K extends RuntimeException, V extends RuntimeException> void m() { }\n+                }\n+                \"\"\", \"\"\"\n+                package x;\n+\n+                public class Child extends Parent {\n+\n+                    \/**\n+                     * @throws K {@inheritDoc}\n+                     * @throws V {@inheritDoc}\n+                     *\/\n+                    @Override\n+                    public <V extends RuntimeException, K extends RuntimeException> void m() { }\n+                }\n+                \"\"\");\n+        javadoc(\"-d\", base.resolve(\"out\").toString(), \"-sourcepath\", src.toString(), \"x\");\n+        checkExit(Exit.OK);\n+        checkOutput(\"x\/Child.html\", true, \"\"\"\n+                <dl class=\"notes\">\n+                <dt>Overrides:<\/dt>\n+                <dd><code><a href=\"Parent.html#m()\">m<\/a><\/code>&nbsp;in class&nbsp;<code>\\\n+                <a href=\"Parent.html\" title=\"class in x\">Parent<\/a><\/code><\/dd>\n+                <dt>Throws:<\/dt>\n+                <dd><code>K<\/code> - other times<\/dd>\n+                <dd><code>V<\/code> - some of the times<\/dd>\n+                <\/dl>\n+                \"\"\");\n+    }\n+\n+    \/*\n+     * X is unknown to Child.m as it isn't defined by Child.m and\n+     * type parameters declared by methods are not inherited.\n+     *\/\n+    @Test\n+    public void testUndefinedTypeParameter(Path base) throws Exception {\n+        var src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src, \"\"\"\n+                package x;\n+\n+                public class Parent {\n+\n+                    \/** @throws X sometimes *\/\n+                    public <X extends Throwable> void m() throws X { }\n+                }\n+                \"\"\", \"\"\"\n+                package x;\n+\n+                public class Child extends Parent {\n+\n+                    \/** @throws X {@inheritDoc} *\/\n+                    @Override\n+                    public void m() { }\n+                }\n+                \"\"\");\n+        \/\/ turn off DocLint so that it does not interfere with diagnostics\n+        \/\/ by raising an error for the condition we are testing:\n+        \/\/\n+        \/\/ Child.java:5: error: invalid use of @throws\n+        \/\/    \/** @throws X {@inheritDoc} *\/\n+        \/\/        ^\n+        javadoc(\"-d\", base.resolve(\"out\").toString(), \"-sourcepath\", src.toString(), \"x\", \"-Xdoclint:none\");\n+        checkExit(Exit.OK);\n+        \/\/ It just happens so that X is resolved to a package.\n+        \/\/ This should probably be fixed eventually. \/\/ TODO: add a link to the JBS issue\n+        checkOutput(Output.OUT, true, \"\"\"\n+                Child.java:5: warning: type found is not of exception type: X (MODULE <unnamed module> PACKAGE X)\n+                    \/** @throws X {@inheritDoc} *\/\n+                                ^\n+                \"\"\");\n+    }\n+\n+    \/\/ A related (but separate from this test suite) test. This test is\n+    \/\/ introduced here because it tests for the error condition that is\n+    \/\/ detected by JDK-8291869, which is tested by tests in this test\n+    \/\/ suite.\n+    \/\/ TODO: consider moving this test to a more suitable test suit.\n+    @Test\n+    public void testWrongType(Path base) throws Exception {\n+        var src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src, \"\"\"\n+                package x;\n+\n+                public class MyClass {\n+\n+                    \/** @throws OtherClass description *\/\n+                    public void m() { }\n+                }\n+                \"\"\", \"\"\"\n+                package x;\n+\n+                public class OtherClass { }\n+                \"\"\");\n+        \/\/ turn off DocLint so that it does not interfere with diagnostics\n+        \/\/ by raising an error for the condition we are testing\n+        javadoc(\"-d\", base.resolve(\"out\").toString(), \"-sourcepath\", src.toString(), \"x\", \"-Xdoclint:none\");\n+        checkExit(Exit.OK);\n+        checkOutput(Output.OUT, true, \"\"\"\n+                MyClass.java:5: warning: type found is not of exception type: \\\n+                x.OtherClass (MODULE <unnamed module> PACKAGE x CLASS OtherClass)\n+                    \/** @throws OtherClass description *\/\n+                                ^\n+                \"\"\");\n+        checkOutput(\"x\/MyClass.html\", false, \"\"\"\n+                <dl class=\"notes\">\n+                <dt>Throws:<\/dt>\n+                <dd><code><a href=\"OtherClass.html\" title=\"class in x\">OtherClass<\/a><\/code> - description<\/dd>\n+                <\/dl>\n+                \"\"\");\n+    }\n+\n+    \/\/ A related (but separate from this test suite) test. This test is\n+    \/\/ introduced here because it tests for the error condition that is\n+    \/\/ detected by JDK-8291869, which is tested by tests in this test\n+    \/\/ suite.\n+    \/\/ TODO: consider moving this test to a more suitable test suit.\n+    @Test\n+    public void testExceptionTypeNotFound(Path base) throws Exception {\n+        var src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src, \"\"\"\n+                package x;\n+\n+                public class MyClass {\n+\n+                    \/** @throws un1queEn0ughS0asT0N0tBeF0und description *\/\n+                    public void m() { }\n+                }\n+                \"\"\");\n+        \/\/ turn off DocLint so that it does not interfere with diagnostics\n+        \/\/ by raising an error for the condition we are testing\n+        javadoc(\"-d\", base.resolve(\"out\").toString(), \"-sourcepath\", src.toString(), \"x\", \"-Xdoclint:none\");\n+        checkExit(Exit.OK);\n+        checkOutput(Output.OUT, true, \"\"\"\n+                MyClass.java:5: warning: cannot find exception type by name\n+                    \/** @throws un1queEn0ughS0asT0N0tBeF0und description *\/\n+                                ^\n+                \"\"\");\n+    }\n+\n+    \/*\n+     * In Child, R is a class residing in an unnamed package, whereas\n+     * in Parent, R is a type variable.\n+     *\/\n+    @Test\n+    public void testTypeAndTypeParameter(Path base) throws Exception {\n+        var src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src, \"\"\"\n+                public class Parent {\n+\n+                    \/** @throws R sometimes *\/\n+                    public <R extends RuntimeException> void m() { }\n+                }\n+                \"\"\", \"\"\"\n+                public class Child extends Parent {\n+\n+                    \/** @throws R {@inheritDoc} *\/\n+                    @Override public void m() { }\n+                }\n+                \"\"\", \"\"\"\n+                public class R extends RuntimeException { }\n+                \"\"\");\n+        javadoc(\"-d\", base.resolve(\"out\").toString(), src.resolve(\"Parent.java\").toString(),\n+                src.resolve(\"Child.java\").toString(), src.resolve(\"R.java\").toString());\n+        checkExit(Exit.OK);\n+        checkOutput(Output.OUT, true, \"\"\"\n+                Child.java:3: warning: overridden methods do not document exception type R \\\n+                (MODULE <unnamed module> PACKAGE <unnamed package> CLASS R)\n+                    \/** @throws R {@inheritDoc} *\/\n+                        ^\n+                \"\"\");\n+        checkOutput(\"Child.html\", false, \"\"\"\n+                <dl class=\"notes\">\n+                <dt>Overrides:<\/dt>\n+                <dd><code><a href=\"Parent.html#m()\">m<\/a><\/code>&nbsp;in class&nbsp;<code>\\\n+                <a href=\"Parent.html\" title=\"class in Unnamed Package\">Parent<\/a><\/code><\/dd>\n+                <dt>Throws:<\/dt>\n+                <dd><code><a href=\"R.html\" title=\"class in Unnamed Package\">R<\/a><\/code> - sometimes<\/dd>\n+                <\/dl>\"\"\");\n+        checkOutput(\"Child.html\", false, \"\"\"\n+                <dl class=\"notes\">\n+                <dt>Overrides:<\/dt>\n+                <dd><code><a href=\"Parent.html#m()\">m<\/a><\/code>&nbsp;in class&nbsp;<code>\\\n+                <a href=\"Parent.html\" title=\"class in Unnamed Package\">Parent<\/a><\/code><\/dd>\n+                <dt>Throws:<\/dt>\n+                <dd><code>R<\/code> - sometimes<\/dd>\n+                <\/dl>\"\"\");\n+    }\n+\n+    \/*\n+     * There are two different exceptions that share the same simple name:\n+     *\n+     *   1. P.MyException (a nested static class in an unnamed package)\n+     *   2. P.MyException (a public class in the P package)\n+     *\n+     * Although unconventional, it is not prohibited for a package name to\n+     * start with an upper case letter. This test disregards that\n+     * convention for the setup to work: the package and the\n+     * class should have the same FQN to be confusing.\n+     *\n+     * A permissible but equally unconventional alternative would be to\n+     * keep the package lower-case but give the class a lower-case name p.\n+     *\n+     * This setup works likely because of JLS 6.3. Scope of a Declaration:\n+     *\n+     *     The scope of a top level class or interface (7.6) is all class\n+     *     and interface declarations in the package in which the top\n+     *     level class or interface is declared.\n+     *\/\n+    @Test\n+    public void testOuterClassAndPackage(Path base) throws Exception {\n+        var src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src, \"\"\"\n+                package P;\n+\n+                public class MyException extends RuntimeException { }\n+                \"\"\", \"\"\"\n+                package pkg;\n+\n+                public class Parent {\n+\n+                    \/** @throws P.MyException sometimes *\/\n+                    public void m() { }\n+                }\n+                \"\"\", \"\"\"\n+                public class Child extends pkg.Parent {\n+\n+                    \/** @throws P.MyException {@inheritDoc} *\/\n+                    @Override\n+                    public void m() { }\n+                }\n+                \"\"\", \"\"\"\n+                public class P {\n+                    public static class MyException extends RuntimeException { }\n+                }\n+                \"\"\");\n+        setAutomaticCheckLinks(false); \/\/ otherwise the link checker reports that P.MyException is defined twice\n+        javadoc(\"-d\",\n+                base.resolve(\"out\").toString(),\n+                src.resolve(\"P\").resolve(\"MyException.java\").toString(),\n+                src.resolve(\"pkg\").resolve(\"Parent.java\").toString(),\n+                src.resolve(\"Child.java\").toString(),\n+                src.resolve(\"P.java\").toString());\n+        checkExit(Exit.OK);\n+        checkOutput(Output.OUT, true, \"\"\"\n+                Child.java:3: warning: overridden methods do not document exception type P.MyException \\\n+                (MODULE <unnamed module> PACKAGE <unnamed package> CLASS P CLASS MyException)\n+                    \/** @throws P.MyException {@inheritDoc} *\/\n+                        ^\n+                \"\"\");\n+        checkOutput(\"Child.html\", false, \"\"\"\n+                <dl class=\"notes\">\n+                <dt>Overrides:<\/dt>\n+                <dd><code><a href=\"pkg\/Parent.html#m()\">m<\/a><\/code>&nbsp;in class&nbsp;<code>\\\n+                <a href=\"pkg\/Parent.html\" title=\"class in pkg\">Parent<\/a><\/code><\/dd>\n+                <dt>Throws:<\/dt>\n+                <dd><code><a href=\"P.MyException.html\" title=\"class in Unnamed Package\">P.MyException<\/a><\/code> - sometimes<\/dd>\n+                <\/dl>\"\"\");\n+        checkOutput(\"Child.html\", false, \"P\/MyException.html\");\n+    }\n+\n+    \/*\n+     * It's unclear how to match type parameters that aren't declared by\n+     * a method. For example, consider that for B to be a subtype of A,\n+     * it is not necessary for A and B to have the same number or\n+     * types of type parameters.\n+     *\n+     * For that reason, exception documentation inheritance involving\n+     * such parameters is currently unsupported. This test simply\n+     * checks that we produce helpful warnings.\n+     *\/\n+    @Test\n+    public void testGenericTypes(Path base) throws Exception {\n+        var src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src, \"\"\"\n+                package x;\n+\n+                public class Parent<T extends RuntimeException> {\n+\n+                    \/** @throws T description *\/\n+                    public void m() { }\n+                }\n+                \"\"\", \"\"\"\n+                package x;\n+\n+                public class Child1<T extends RuntimeException> extends Parent<T> {\n+\n+                    \/** @throws T {@inheritDoc} *\/\n+                    @Override public void m() { }\n+                }\n+                \"\"\", \"\"\"\n+                package x;\n+\n+                public class Child2<T extends IllegalArgumentException> extends Parent<T> {\n+\n+                    \/** @throws T {@inheritDoc} *\/\n+                    @Override public void m() { }\n+                }\n+                \"\"\", \"\"\"\n+                package x;\n+\n+                public class Child3 extends Parent<NullPointerException> {\n+\n+                    \/** @throws NullPointerException {@inheritDoc} *\/\n+                    @Override public void m() { }\n+                }\n+                \"\"\");\n+        javadoc(\"-d\", base.resolve(\"out\").toString(), \"-sourcepath\", src.toString(), \"x\");\n+        checkExit(Exit.OK);\n+        checkOutput(Output.OUT, true, \"\"\"\n+                Child1.java:5: warning: @inheritDoc for exception-type type parameters not declared by a method is unsupported; \\\n+                document such exception types directly without inheritance\n+                    \/** @throws T {@inheritDoc} *\/\n+                                ^\n+                \"\"\");\n+        checkOutput(Output.OUT, true, \"\"\"\n+                Child2.java:5: warning: @inheritDoc for exception-type type parameters not declared by a method is unsupported; \\\n+                document such exception types directly without inheritance\n+                    \/** @throws T {@inheritDoc} *\/\n+                                ^\n+                \"\"\");\n+        checkOutput(Output.OUT, true, \"\"\"\n+                Child3.java:5: warning: overridden methods do not document exception type java.lang.NullPointerException \\\n+                (MODULE java.base PACKAGE java.lang CLASS NullPointerException)\n+                    \/** @throws NullPointerException {@inheritDoc} *\/\n+                        ^\n+                    \"\"\");\n+    }\n+}\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testThrowsInheritanceMatching\/TestExceptionTypeMatching.java","additions":491,"deletions":0,"binary":false,"changes":491,"status":"added"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8067757 6509045\n+ * @bug 8067757 6509045 8295277\n@@ -567,0 +567,168 @@\n+\n+\/\/    @Test\n+    public void testDeeperError(Path base) throws Exception {\n+        var src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src, \"\"\"\n+                package x;\n+\n+                public class MyRuntimeException extends RuntimeException { }\n+                \"\"\", \"\"\"\n+                package x;\n+\n+                public interface I {\n+\n+                    \/**\n+                     * @throws MyRuntimeException sometimes\n+                     * @throws MyRuntimeException rarely\n+                     *\/\n+                    void m();\n+                }\n+                \"\"\", \"\"\"\n+                package x;\n+\n+                public interface I1 extends I {\n+\n+                    \/**\n+                     * @throws MyRuntimeException \"{@inheritDoc}\"\n+                     *\/\n+                    @Override\n+                    void m();\n+                }\n+                \"\"\", \"\"\"\n+                package x;\n+\n+                public interface I2 extends I1 {\n+\n+                    \/**\n+                     * @throws MyRuntimeException '{@inheritDoc}'\n+                     *\/\n+                    @Override\n+                    void m();\n+                }\n+                \"\"\");\n+        javadoc(\"-d\", base.resolve(\"out\").toString(),\n+                \"-sourcepath\", src.toString(),\n+                \"x\");\n+        checkExit(Exit.ERROR);\n+        checkOutput(Output.OUT, true, \"\"\"\n+                I2.java:6: error: @inheritDoc cannot be used within this tag\n+                     * @throws MyRuntimeException \"{@inheritDoc}\"\n+                       ^\n+                       \"\"\");\n+    }\n+\n+    @Test\n+    public void testFullExpansion(Path base) throws Exception {\n+        var src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src, \"\"\"\n+                package x;\n+\n+                public class MyRuntimeException extends RuntimeException { }\n+                \"\"\", \"\"\"\n+                package x;\n+\n+                public interface Child extends Parent {\n+\n+                    \/**\n+                     * @throws MyRuntimeException child 1\n+                     * @throws MyRuntimeException {@inheritDoc}\n+                     *\/\n+                    @Override void m();\n+                }\n+                \"\"\", \"\"\"\n+                package x;\n+\n+                public interface Parent extends GrandParent {\n+\n+                    \/**\n+                     * @throws MyRuntimeException parent 1\n+                     * @throws MyRuntimeException {@inheritDoc}\n+                     *\/\n+                    @Override void m();\n+                }\n+                \"\"\", \"\"\"\n+                package x;\n+\n+                public interface GrandParent {\n+\n+                    \/**\n+                     * @throws MyRuntimeException grandparent 1\n+                     * @throws MyRuntimeException grandparent 2\n+                     *\/\n+                    void m();\n+                }\n+                \"\"\");\n+        javadoc(\"-d\", base.resolve(\"out\").toString(),\n+                \"-sourcepath\", src.toString(),\n+                \"x\");\n+        checkExit(Exit.OK);\n+        checkOutput(\"x\/Child.html\", true, \"\"\"\n+                <dl class=\"notes\">\n+                <dt>Specified by:<\/dt>\n+                <dd><code><a href=\"GrandParent.html#m()\">m<\/a><\/code>&nbsp;in interface&nbsp;<code><a href=\"GrandParent.html\" title=\"interface in x\">GrandParent<\/a><\/code><\/dd>\n+                <dt>Specified by:<\/dt>\n+                <dd><code><a href=\"Parent.html#m()\">m<\/a><\/code>&nbsp;in interface&nbsp;<code><a href=\"Parent.html\" title=\"interface in x\">Parent<\/a><\/code><\/dd>\n+                <dt>Throws:<\/dt>\n+                <dd><code><a href=\"MyRuntimeException.html\" title=\"class in x\">MyRuntimeException<\/a><\/code> - child 1<\/dd>\n+                <dd><code><a href=\"MyRuntimeException.html\" title=\"class in x\">MyRuntimeException<\/a><\/code> - parent 1<\/dd>\n+                <dd><code><a href=\"MyRuntimeException.html\" title=\"class in x\">MyRuntimeException<\/a><\/code> - grandparent 1<\/dd>\n+                <dd><code><a href=\"MyRuntimeException.html\" title=\"class in x\">MyRuntimeException<\/a><\/code> - grandparent 2<\/dd>\n+                <\/dl>\n+                <\/section>\n+                \"\"\");\n+    }\n+\n+    @Test\n+    public void testChainEmbeddedInheritDoc(Path base) throws Exception {\n+        var src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src, \"\"\"\n+                package x;\n+\n+                public class MyRuntimeException extends RuntimeException { }\n+                \"\"\", \"\"\"\n+                package x;\n+\n+                public interface Child extends Parent {\n+\n+                    \/**\n+                     * @throws MyRuntimeException \"{@inheritDoc}\"\n+                     *\/\n+                    @Override void m();\n+                }\n+                \"\"\", \"\"\"\n+                package x;\n+\n+                public interface Parent extends GrandParent {\n+\n+                    \/**\n+                     * @throws MyRuntimeException '{@inheritDoc}'\n+                     *\/\n+                    @Override void m();\n+                }\n+                \"\"\", \"\"\"\n+                package x;\n+\n+                public interface GrandParent {\n+\n+                    \/**\n+                     * @throws MyRuntimeException grandparent\n+                     *\/\n+                    void m();\n+                }\n+                \"\"\");\n+        javadoc(\"-d\", base.resolve(\"out\").toString(),\n+                \"-sourcepath\", src.toString(),\n+                \"x\");\n+        checkExit(Exit.OK);\n+        checkOutput(\"x\/Child.html\", true, \"\"\"\n+                <dl class=\"notes\">\n+                <dt>Specified by:<\/dt>\n+                <dd><code><a href=\"GrandParent.html#m()\">m<\/a><\/code>&nbsp;in interface&nbsp;<code><a href=\"GrandParent.html\" title=\"interface in x\">GrandParent<\/a><\/code><\/dd>\n+                <dt>Specified by:<\/dt>\n+                <dd><code><a href=\"Parent.html#m()\">m<\/a><\/code>&nbsp;in interface&nbsp;<code><a href=\"Parent.html\" title=\"interface in x\">Parent<\/a><\/code><\/dd>\n+                <dt>Throws:<\/dt>\n+                <dd><code><a href=\"MyRuntimeException.html\" title=\"class in x\">MyRuntimeException<\/a><\/code> - \"'grandparent'\"<\/dd>\n+                <\/dl>\n+                <\/section>\n+                \"\"\");\n+    }\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testThrowsInheritanceMultiple\/TestOneToMany.java","additions":169,"deletions":1,"binary":false,"changes":170,"status":"modified"},{"patch":"@@ -45,1 +45,0 @@\n-     * @throws DoesNotExist   oops, javadoc does not see this\n","filename":"test\/langtools\/jdk\/javadoc\/tool\/6964914\/TestStdDoclet.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}