{"files":[{"patch":"@@ -869,1 +869,1 @@\n-  BUILD_HOTSPOT_JTREG_EXCLUDE += libtest-rw.c libtest-rwx.c \\\n+    BUILD_HOTSPOT_JTREG_EXCLUDE += libtest-rw.c libtest-rwx.c \\\n@@ -879,0 +879,1 @@\n+    BUILD_HOTSPOT_JTREG_EXECUTABLES_LIBS_exedaemonDestroy := jvm.lib\n@@ -880,0 +881,1 @@\n+    BUILD_HOTSPOT_JTREG_EXECUTABLES_LIBS_exedaemonDestroy := -ljvm\n","filename":"make\/test\/JtregNativeHotspot.gmk","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1046,1 +1046,5 @@\n-  \/\/ Wait until we are the last non-daemon thread to execute\n+  \/\/ Wait until we are the last non-daemon thread to execute, or\n+  \/\/ if we are a daemon then wait until the last non-daemon thread has\n+  \/\/ executed.\n+  bool daemon = java_lang_Thread::is_daemon(thread->threadObj());\n+  int expected = daemon ? 0 : 1;\n@@ -1049,1 +1053,1 @@\n-    while (Threads::number_of_non_daemon_threads() > 1)\n+    while (Threads::number_of_non_daemon_threads() > expected)\n@@ -1226,3 +1230,5 @@\n-      \/\/ Only one thread left, do a notify on the Threads_lock so a thread waiting\n-      \/\/ on destroy_vm will wake up.\n-      if (number_of_non_daemon_threads() == 1) {\n+      \/\/ If this is the last non-daemon thread then we need to do\n+      \/\/ a notify on the Threads_lock so a thread waiting\n+      \/\/ on destroy_vm will wake up. But that thread could be a daemon\n+      \/\/ or non-daemon, so we notify for both the 0 and 1 case.\n+      if (number_of_non_daemon_threads() <= 1) {\n","filename":"src\/hotspot\/share\/runtime\/threads.cpp","additions":11,"deletions":5,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/**\n+ * Simple application that checks that shutdown does not commence until\n+ * after the last non-daemon thread has terminated. Reporting failure is\n+ * tricky because we can't uses exceptions (as they are ignored from Shutdown\n+ * hooks) and we can't call System.exit. So we rely on System.out being checked\n+ * in the TestDaemonDestroy application.\n+ *\/\n+public class Main {\n+\n+    static volatile Thread t1;\n+\n+    public static void main() {\n+        t1 = new Thread(() -> {\n+                System.out.println(\"T1 started\");\n+                try {\n+                    Thread.sleep(5000);\n+                } catch (InterruptedException ignore) { }\n+                System.out.println(\"T1 finished\");\n+            }, \"T1\");\n+\n+        t1.setDaemon(false);\n+\n+        Thread hook = new Thread(() -> {\n+                System.out.println(\"HOOK started\");\n+                if (t1.isAlive()) {\n+                    System.out.println(\"Error: T1 isAlive\");\n+                }\n+            }, \"HOOK\");\n+        Runtime.getRuntime().addShutdownHook(hook);\n+        t1.start();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/jni\/daemonDestroy\/Main.java","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -0,0 +1,80 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8290732\n+ * @comment Test uses custom launcher that attempts to destroy the VM on both\n+ *          a daemon and non-daemon thread. The result should be the same in\n+ *          both cases.\n+ * @requires vm.flagless\n+ * @library \/test\/lib\n+ * @build Main\n+ * @run main\/native TestDaemonDestroy\n+ * @run main\/native TestDaemonDestroy daemon\n+ *\/\n+\n+\/\/ Logic copied from SigTestDriver\n+\n+import jdk.test.lib.Platform;\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+public class TestDaemonDestroy {\n+\n+    public static void main(String[] args) throws IOException {\n+        Path launcher = Paths.get(Utils.TEST_NATIVE_PATH)\n+            .resolve(\"daemonDestroy\" + (Platform.isWindows() ? \".exe\" : \"\"))\n+            .toAbsolutePath();\n+\n+        System.out.println(\"Launcher = \" + launcher +\n+                           (Files.exists(launcher) ? \" (exists)\" : \" (missing)\"));\n+\n+        List<String> cmd = new ArrayList<>();\n+        cmd.add(launcher.toString());\n+        cmd.add(\"-Djava.class.path=\" + Utils.TEST_CLASS_PATH);\n+        if (args.length > 0) {\n+            cmd.add(\"daemon\");\n+        }\n+        ProcessBuilder pb = new ProcessBuilder(cmd);\n+\n+        \/\/ Need to add libjvm location to LD_LIBRARY_PATH\n+        String envVar = Platform.sharedLibraryPathVariableName();\n+        pb.environment().merge(envVar, Platform.jvmLibDir().toString(),\n+                               (x, y) -> y + File.pathSeparator + x);\n+\n+        OutputAnalyzer oa = new OutputAnalyzer(pb.start());\n+        oa.shouldHaveExitValue(0);\n+        oa.shouldNotContain(\"Error: T1 isAlive\");\n+        oa.reportDiagnosticSummary();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/jni\/daemonDestroy\/TestDaemonDestroy.java","additions":80,"deletions":0,"binary":false,"changes":80,"status":"added"},{"patch":"@@ -0,0 +1,105 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <jni.h>\n+#include <stdlib.h>\n+\n+static JavaVMOption options[] = {\n+  { \"-Djava.class.path=.\", NULL }, \/\/ gets overwritten with real value\n+};\n+\n+static JavaVMInitArgs vm_args = {\n+  JNI_VERSION_19,\n+  sizeof(options) \/ sizeof(JavaVMOption),\n+  options,\n+  JNI_FALSE\n+};\n+\n+int main(int argc, char *argv[]) {\n+  JavaVM *jvm;\n+  JNIEnv *env;\n+\n+  if (argc < 2) {\n+    fprintf(stderr, \"Usage: main <classpath property> [daemon]\\n\");\n+    exit(1);\n+  }\n+\n+  char* cp = argv[1];\n+\n+  printf(\"Test using classpath: %s\\n\", cp);\n+\n+  options[0].optionString = cp;\n+\n+  jint res = JNI_CreateJavaVM(&jvm, (void**)&env, &vm_args);\n+  if (res != JNI_OK) {\n+    fprintf(stderr, \"Test Error: JNI_CreateJavaVM failed: %d\\n\", res);\n+    exit(1);\n+  }\n+\n+  jclass cls = (*env)->FindClass(env, \"Main\");\n+  if (cls == NULL) {\n+    fprintf(stderr, \"Test Error. Can't load class Main\\n\");\n+    (*env)->ExceptionDescribe(env);\n+    exit(1);\n+  }\n+\n+  jmethodID mid = (*env)->GetStaticMethodID(env, cls, \"main\", \"()V\");\n+  if (mid == NULL) {\n+    fprintf(stderr, \"Test Error. Can't find method main\\n\");\n+    (*env)->ExceptionDescribe(env);\n+    exit(1);\n+  }\n+\n+  (*env)->CallStaticVoidMethod(env, cls, mid);\n+\n+  res = (*jvm)->DetachCurrentThread(jvm);\n+  if (res != JNI_OK) {\n+    fprintf(stderr, \"Test Error: DetachCurrentThread failed: %d\\n\", res);\n+    exit(1);\n+  }\n+\n+  \/\/ Any additional arg implies to use a daemon thread.\n+  if (argc > 2) {\n+    res = (*jvm)->AttachCurrentThreadAsDaemon(jvm, (void **)&env, NULL);\n+    if (res != JNI_OK) {\n+      fprintf(stderr, \"Test Error: AttachCurrentThreadAsDaemon failed: %d\\n\", res);\n+      exit(1);\n+    }\n+    puts(\"Test: attached as daemon\");\n+  } else {\n+    res = (*jvm)->AttachCurrentThread(jvm, (void **)&env, NULL);\n+    if (res != JNI_OK) {\n+      fprintf(stderr, \"Test Error: AttachCurrentThread failed: %d\\n\", res);\n+      exit(1);\n+    }\n+    puts(\"Test: attached as non-daemon\");\n+  }\n+\n+  puts(\"Test: calling DestroyJavaVM\");\n+  res = (*jvm)->DestroyJavaVM(jvm);\n+  if (res != JNI_OK) {\n+    fprintf(stderr, \"Test Error: DestroyJavaVM failed: %d\\n\", res);\n+    exit(1);\n+  }\n+  puts(\"Test: DestroyJavaVM returned\");\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/jni\/daemonDestroy\/exedaemonDestroy.c","additions":105,"deletions":0,"binary":false,"changes":105,"status":"added"}]}