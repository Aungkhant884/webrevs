{"files":[{"patch":"@@ -67,3 +67,6 @@\n- * {@code java.math.BigDecimal}, whose natural ordering equates\n- * {@code BigDecimal} objects with equal values and different precisions\n- * (such as 4.0 and 4.00).<p>\n+ * {@link java.math.BigDecimal}, whose {@linkplain java.math.BigDecimal#compareTo natural ordering} equates\n+ * {@code BigDecimal} objects with equal numerical values and different representations\n+ * (such as 4.0 and 4.00). For {@link java.math.BigDecimal#equals\n+ * BigDecimal.equals()} to return true, the representation and\n+ * numerical value of the two {@code BigDecimal} objects must be the\n+ * same.<p>\n@@ -86,1 +89,6 @@\n- * This interface is a member of the\n+ * In other words, when a class's natural ordering is consistent with\n+ * equals, the equivalence classes defined by the equivalence relation\n+ * of the {@code equals} method and the equivalence classes defined by\n+ * the quotient of the {@code compareTo} method are the same.\n+ *\n+ * <p>This interface is a member of the\n@@ -103,1 +111,1 @@\n-     * {@code sgn(x.compareTo(y)) == -sgn(y.compareTo(x))}\n+     * {@link Integer#signum signum}{@code (x.compareTo(y)) == -signum(y.compareTo(x))}\n@@ -105,1 +113,1 @@\n-     * implies that {@code x.compareTo(y)} must throw an exception iff\n+     * implies that {@code x.compareTo(y)} must throw an exception if and only if\n@@ -113,1 +121,1 @@\n-     * implies that {@code sgn(x.compareTo(z)) == sgn(y.compareTo(z))}, for\n+     * implies that {@code signum(x.compareTo(z)) == signum(y.compareTo(z))}, for\n@@ -116,1 +124,2 @@\n-     * <p>It is strongly recommended, but <i>not<\/i> strictly required that\n+     * @apiNote\n+     * It is strongly recommended, but <i>not<\/i> strictly required that\n@@ -123,6 +132,0 @@\n-     * <p>In the foregoing description, the notation\n-     * {@code sgn(}<i>expression<\/i>{@code )} designates the mathematical\n-     * <i>signum<\/i> function, which is defined to return one of {@code -1},\n-     * {@code 0}, or {@code 1} according to whether the value of\n-     * <i>expression<\/i> is negative, zero, or positive, respectively.\n-     *\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Comparable.java","additions":17,"deletions":14,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -81,1 +81,1 @@\n-     * <li>If two objects are equal according to the {@code equals(Object)}\n+     * <li>If two objects are equal according to the {@link equals(Object) equals}\n@@ -85,1 +85,1 @@\n-     *     according to the {@link java.lang.Object#equals(java.lang.Object)}\n+     *     according to the {@link equals(Object) equals}\n@@ -130,0 +130,1 @@\n+     *\n@@ -131,0 +132,6 @@\n+     * An equivalence relation partitions the elements it operates on\n+     * into <i>equivalence classes<\/i>; all the members of an\n+     * equivalence class are equal to each other. Members of an equivalence class\n+     * are substitutable for each other, at least for some purposes.\n+     *\n+     * @implSpec\n@@ -137,2 +144,6 @@\n-     * <p>\n-     * Note that it is generally necessary to override the {@code hashCode}\n+     *\n+     * In other words, under the reference equality equivalence\n+     * relation, each equivalence class only has a single element.\n+     *\n+     * @apiNote\n+     * It is generally necessary to override the {@link hashCode hashCode}\n@@ -186,1 +197,2 @@\n-     * <p>\n+     *\n+     * @implSpec\n@@ -217,1 +229,3 @@\n-     * Returns a string representation of the object. In general, the\n+     * Returns a string representation of the object.\n+     * @apiNote\n+     * In general, the\n@@ -223,1 +237,2 @@\n-     * <p>\n+     * The string output is not necessarily stable over time or across JVM invocations.\n+     * @implSpec\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Object.java","additions":22,"deletions":7,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -66,2 +66,1 @@\n- * which take no {@code MathContext} object.  (This is the only\n- * behavior that was supported in releases prior to 5.)  As a\n+ * which take no {@code MathContext} object. As a\n@@ -82,3 +81,2 @@\n- * standards, {@code BigDecimal} includes many rounding modes, which\n- * were mandatory for division in {@code BigDecimal} releases prior\n- * to 5.  Any conflicts between these ANSI standards and the\n+ * standards, {@code BigDecimal} includes many rounding modes.\n+ * Any conflicts between these ANSI standards and the\n@@ -93,0 +91,9 @@\n+ * The different representations of the same numerical value are\n+ * called members of the same <i>cohort<\/i>. The {@linkplain\n+ * compareTo(BigDecimal) natural order} of {@code BigDecimal}\n+ * considers members of the same cohort to be equal to each other. In\n+ * contrast, the {@link equals equals} method requires both the\n+ * numerical value and representation to be the same for equality to\n+ * hold. The results of methods like {@link scale} and {@link\n+ * unscaledValue} will differ for numerically equal values with\n+ * different representations.\n@@ -3043,1 +3050,1 @@\n-     * Compares this {@code BigDecimal} with the specified\n+     * Compares this {@code BigDecimal} numerically with the specified\n@@ -3046,1 +3053,3 @@\n-     * are considered equal by this method.  This method is provided\n+     * are considered equal by this method. Such values are in the same <i>cohort<\/i>.\n+     *\n+     * This method is provided\n@@ -3053,0 +3062,3 @@\n+\n+     * @apiNote\n+     * Note: this class has a natural ordering that is inconsistent with equals.\n@@ -3132,2 +3144,2 @@\n-     * value and scale (thus 2.0 is not equal to 2.00 when compared by\n-     * this method).\n+     * value and scale. Therefore 2.0 is not equal to 2.00 when compared by\n+     * this method.\n","filename":"src\/java.base\/share\/classes\/java\/math\/BigDecimal.java","additions":21,"deletions":9,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n- * certain data structures (such as {@link SortedSet sorted sets} or {@link\n+ * certain data structures (such as {@linkplain SortedSet sorted sets} or {@linkplain\n@@ -43,1 +43,1 @@\n- * objects that don't have a {@link Comparable natural ordering}.<p>\n+ * objects that don't have a {@linkplain Comparable natural ordering}.<p>\n@@ -92,0 +92,5 @@\n+ * In other words, when the imposed ordering is consistent with\n+ * equals, the equivalence classes defined by the equivalence relation\n+ * of the {@code equals} method and the equivalence classes defined by\n+ * the quotient of the {@code compare} method are the same.\n+\n@@ -115,2 +120,2 @@\n-     * The implementor must ensure that {@code sgn(compare(x, y)) ==\n-     * -sgn(compare(y, x))} for all {@code x} and {@code y}.  (This\n+     * The implementor must ensure that {@link Integer#signum signum}{@code (compare(x, y)) ==\n+     * -signum(compare(y, x))} for all {@code x} and {@code y}.  (This\n@@ -125,1 +130,1 @@\n-     * implies that {@code sgn(compare(x, z))==sgn(compare(y, z))} for all\n+     * implies that {@code signum(compare(x, z))==signum(compare(y, z))} for all\n@@ -128,0 +133,1 @@\n+     * @apiNote\n@@ -134,6 +140,0 @@\n-     * In the foregoing description, the notation\n-     * {@code sgn(}<i>expression<\/i>{@code )} designates the mathematical\n-     * <i>signum<\/i> function, which is defined to return one of {@code -1},\n-     * {@code 0}, or {@code 1} according to whether the value of\n-     * <i>expression<\/i> is negative, zero, or positive, respectively.\n-     *\n@@ -158,2 +158,2 @@\n-     * {@code comp1.equals(comp2)} implies that {@code sgn(comp1.compare(o1,\n-     * o2))==sgn(comp2.compare(o1, o2))} for every object reference\n+     * {@code comp1.equals(comp2)} implies that {@link Integer#signum signum}{@code (comp1.compare(o1,\n+     * o2))==signum(comp2.compare(o1, o2))} for every object reference\n","filename":"src\/java.base\/share\/classes\/java\/util\/Comparator.java","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"}]}