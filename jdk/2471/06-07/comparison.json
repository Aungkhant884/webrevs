{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -65,8 +65,9 @@\n- * Virtually all Java core classes that implement {@code Comparable} have natural\n- * orderings that are consistent with equals.  One exception is\n- * {@link java.math.BigDecimal}, whose {@linkplain java.math.BigDecimal#compareTo natural ordering} equates\n- * {@code BigDecimal} objects with equal numerical values and different representations\n- * (such as 4.0 and 4.00). For {@link java.math.BigDecimal#equals\n- * BigDecimal.equals()} to return true, the representation and\n- * numerical value of the two {@code BigDecimal} objects must be the\n- * same.<p>\n+ * Virtually all Java core classes that implement {@code Comparable}\n+ * have natural orderings that are consistent with equals.  One\n+ * exception is {@link java.math.BigDecimal}, whose {@linkplain\n+ * java.math.BigDecimal#compareTo natural ordering} equates {@code\n+ * BigDecimal} objects with equal numerical values and different\n+ * representations (such as 4.0 and 4.00). For {@link\n+ * java.math.BigDecimal#equals BigDecimal.equals()} to return true,\n+ * the representation and numerical value of the two {@code\n+ * BigDecimal} objects must be the same.<p>\n@@ -110,5 +111,5 @@\n-     * <p>The implementor must ensure\n-     * {@link Integer#signum signum}{@code (x.compareTo(y)) == -signum(y.compareTo(x))}\n-     * for all {@code x} and {@code y}.  (This\n-     * implies that {@code x.compareTo(y)} must throw an exception if and only if\n-     * {@code y.compareTo(x)} throws an exception.)\n+     * <p>The implementor must ensure {@link Integer#signum\n+     * signum}{@code (x.compareTo(y)) == -signum(y.compareTo(x))} for\n+     * all {@code x} and {@code y}.  (This implies that {@code\n+     * x.compareTo(y)} must throw an exception if and only if {@code\n+     * y.compareTo(x)} throws an exception.)\n@@ -120,3 +121,3 @@\n-     * <p>Finally, the implementor must ensure that {@code x.compareTo(y)==0}\n-     * implies that {@code signum(x.compareTo(z)) == signum(y.compareTo(z))}, for\n-     * all {@code z}.\n+     * <p>Finally, the implementor must ensure that {@code\n+     * x.compareTo(y)==0} implies that {@code signum(x.compareTo(z))\n+     * == signum(y.compareTo(z))}, for all {@code z}.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Comparable.java","additions":18,"deletions":17,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -81,3 +81,4 @@\n-     * <li>If two objects are equal according to the {@link equals(Object) equals}\n-     *     method, then calling the {@code hashCode} method on each of\n-     *     the two objects must produce the same integer result.\n+     * <li>If two objects are equal according to the {@link\n+     *     equals(Object) equals} method, then calling the {@code\n+     *     hashCode} method on each of the two objects must produce the\n+     *     same integer result.\n@@ -85,5 +86,5 @@\n-     *     according to the {@link equals(Object) equals}\n-     *     method, then calling the {@code hashCode} method on each of the\n-     *     two objects must produce distinct integer results.  However, the\n-     *     programmer should be aware that producing distinct integer results\n-     *     for unequal objects may improve the performance of hash tables.\n+     *     according to the {@link equals(Object) equals} method, then\n+     *     calling the {@code hashCode} method on each of the two objects\n+     *     must produce distinct integer results.  However, the programmer\n+     *     should be aware that producing distinct integer results for\n+     *     unequal objects may improve the performance of hash tables.\n@@ -134,2 +135,3 @@\n-     * equivalence class are equal to each other. Members of an equivalence class\n-     * are substitutable for each other, at least for some purposes.\n+     * equivalence class are equal to each other. Members of an\n+     * equivalence class are substitutable for each other, at least\n+     * for some purposes.\n@@ -237,1 +239,2 @@\n-     * The string output is not necessarily stable over time or across JVM invocations.\n+     * The string output is not necessarily stable over time or across\n+     * JVM invocations.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Object.java","additions":15,"deletions":12,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,10 +66,9 @@\n- * which take no {@code MathContext} object. As a\n- * corollary of computing the exact result, the rounding mode setting\n- * of a {@code MathContext} object with a precision setting of 0 is\n- * not used and thus irrelevant.  In the case of divide, the exact\n- * quotient could have an infinitely long decimal expansion; for\n- * example, 1 divided by 3.  If the quotient has a nonterminating\n- * decimal expansion and the operation is specified to return an exact\n- * result, an {@code ArithmeticException} is thrown.  Otherwise, the\n- * exact result of the division is returned, as done for other\n- * operations.\n+ * which take no {@code MathContext} object. As a corollary of\n+ * computing the exact result, the rounding mode setting of a {@code\n+ * MathContext} object with a precision setting of 0 is not used and\n+ * thus irrelevant.  In the case of divide, the exact quotient could\n+ * have an infinitely long decimal expansion; for example, 1 divided\n+ * by 3.  If the quotient has a nonterminating decimal expansion and\n+ * the operation is specified to return an exact result, an {@code\n+ * ArithmeticException} is thrown.  Otherwise, the exact result of the\n+ * division is returned, as done for other operations.\n@@ -77,8 +76,7 @@\n- * <p>When the precision setting is not 0, the rules of\n- * {@code BigDecimal} arithmetic are broadly compatible with selected\n- * modes of operation of the arithmetic defined in ANSI X3.274-1996\n- * and ANSI X3.274-1996\/AM 1-2000 (section 7.4).  Unlike those\n- * standards, {@code BigDecimal} includes many rounding modes.\n- * Any conflicts between these ANSI standards and the\n- * {@code BigDecimal} specification are resolved in favor of\n- * {@code BigDecimal}.\n+ * <p>When the precision setting is not 0, the rules of {@code\n+ * BigDecimal} arithmetic are broadly compatible with selected modes\n+ * of operation of the arithmetic defined in ANSI X3.274-1996 and ANSI\n+ * X3.274-1996\/AM 1-2000 (section 7.4).  Unlike those standards,\n+ * {@code BigDecimal} includes many rounding modes.  Any conflicts\n+ * between these ANSI standards and the {@code BigDecimal}\n+ * specification are resolved in favor of {@code BigDecimal}.\n@@ -3053,8 +3051,8 @@\n-     * are considered equal by this method. Such values are in the same <i>cohort<\/i>.\n-     *\n-     * This method is provided\n-     * in preference to individual methods for each of the six boolean\n-     * comparison operators ({@literal <}, ==,\n-     * {@literal >}, {@literal >=}, !=, {@literal <=}).  The\n-     * suggested idiom for performing these comparisons is:\n-     * {@code (x.compareTo(y)} &lt;<i>op<\/i>&gt; {@code 0)}, where\n+     * are considered equal by this method. Such values are in the\n+     * same <i>cohort<\/i>.\n+     *\n+     * This method is provided in preference to individual methods for\n+     * each of the six boolean comparison operators ({@literal <}, ==,\n+     * {@literal >}, {@literal >=}, !=, {@literal <=}).  The suggested\n+     * idiom for performing these comparisons is: {@code\n+     * (x.compareTo(y)} &lt;<i>op<\/i>&gt; {@code 0)}, where\n@@ -3140,6 +3138,6 @@\n-     * Compares this {@code BigDecimal} with the specified\n-     * {@code Object} for equality.  Unlike {@link\n-     * #compareTo(BigDecimal) compareTo}, this method considers two\n-     * {@code BigDecimal} objects equal only if they are equal in\n-     * value and scale. Therefore 2.0 is not equal to 2.00 when compared by\n-     * this method.\n+     * Compares this {@code BigDecimal} with the specified {@code\n+     * Object} for equality.  Unlike {@link #compareTo(BigDecimal)\n+     * compareTo}, this method considers two {@code BigDecimal}\n+     * objects equal only if they are equal in value and\n+     * scale. Therefore 2.0 is not equal to 2.00 when compared by this\n+     * method.\n","filename":"src\/java.base\/share\/classes\/java\/math\/BigDecimal.java","additions":31,"deletions":33,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,8 +36,10 @@\n- * A comparison function, which imposes a <i>total ordering<\/i> on some\n- * collection of objects.  Comparators can be passed to a sort method (such\n- * as {@link Collections#sort(List,Comparator) Collections.sort} or {@link\n- * Arrays#sort(Object[],Comparator) Arrays.sort}) to allow precise control\n- * over the sort order.  Comparators can also be used to control the order of\n- * certain data structures (such as {@linkplain SortedSet sorted sets} or {@linkplain\n- * SortedMap sorted maps}), or to provide an ordering for collections of\n- * objects that don't have a {@linkplain Comparable natural ordering}.<p>\n+ * A comparison function, which imposes a <i>total ordering<\/i> on\n+ * some collection of objects.  Comparators can be passed to a sort\n+ * method (such as {@link Collections#sort(List,Comparator)\n+ * Collections.sort} or {@link Arrays#sort(Object[],Comparator)\n+ * Arrays.sort}) to allow precise control over the sort order.\n+ * Comparators can also be used to control the order of certain data\n+ * structures (such as {@linkplain SortedSet sorted sets} or\n+ * {@linkplain SortedMap sorted maps}), or to provide an ordering for\n+ * collections of objects that don't have a {@linkplain Comparable\n+ * natural ordering}.<p>\n@@ -120,4 +122,5 @@\n-     * The implementor must ensure that {@link Integer#signum signum}{@code (compare(x, y)) ==\n-     * -signum(compare(y, x))} for all {@code x} and {@code y}.  (This\n-     * implies that {@code compare(x, y)} must throw an exception if and only\n-     * if {@code compare(y, x)} throws an exception.)<p>\n+     * The implementor must ensure that {@link Integer#signum\n+     * signum}{@code (compare(x, y)) == -signum(compare(y, x))} for\n+     * all {@code x} and {@code y}.  (This implies that {@code\n+     * compare(x, y)} must throw an exception if and only if {@code\n+     * compare(y, x)} throws an exception.)<p>\n@@ -129,3 +132,3 @@\n-     * Finally, the implementor must ensure that {@code compare(x, y)==0}\n-     * implies that {@code signum(compare(x, z))==signum(compare(y, z))} for all\n-     * {@code z}.<p>\n+     * Finally, the implementor must ensure that {@code compare(x,\n+     * y)==0} implies that {@code signum(compare(x,\n+     * z))==signum(compare(y, z))} for all {@code z}.<p>\n@@ -153,6 +156,7 @@\n-     * Indicates whether some other object is &quot;equal to&quot; this\n-     * comparator.  This method must obey the general contract of\n-     * {@link Object#equals(Object)}.  Additionally, this method can return\n-     * {@code true} <i>only<\/i> if the specified object is also a comparator\n-     * and it imposes the same ordering as this comparator.  Thus,\n-     * {@code comp1.equals(comp2)} implies that {@link Integer#signum signum}{@code (comp1.compare(o1,\n+     * Indicates whether some other object is &quot;equal to&quot;\n+     * this comparator.  This method must obey the general contract of\n+     * {@link Object#equals(Object)}.  Additionally, this method can\n+     * return {@code true} <i>only<\/i> if the specified object is also\n+     * a comparator and it imposes the same ordering as this\n+     * comparator.  Thus, {@code comp1.equals(comp2)} implies that\n+     * {@link Integer#signum signum}{@code (comp1.compare(o1,\n","filename":"src\/java.base\/share\/classes\/java\/util\/Comparator.java","additions":26,"deletions":22,"binary":false,"changes":48,"status":"modified"}]}