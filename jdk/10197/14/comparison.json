{"files":[{"patch":"@@ -62,3 +62,1 @@\n-            for (InputNode n : nodeList) {\n-                nodes.add(n);\n-            }\n+            nodes.addAll(nodeList);\n@@ -91,1 +89,1 @@\n-        return new Action[]{(Action) SelectBytecodesAction.findObject(SelectBytecodesAction.class, true)};\n+        return new Action[]{SelectBytecodesAction.findObject(SelectBytecodesAction.class, true)};\n@@ -96,1 +94,1 @@\n-        return (Action) SelectBytecodesAction.findObject(SelectBytecodesAction.class, true);\n+        return SelectBytecodesAction.findObject(SelectBytecodesAction.class, true);\n","filename":"src\/utils\/IdealGraphVisualizer\/Bytecodes\/src\/main\/java\/com\/sun\/hotspot\/igv\/bytecodes\/BytecodeNode.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import java.io.Serializable;\n@@ -37,1 +36,1 @@\n-import org.openide.util.*;\n+import org.openide.util.NbBundle;\n@@ -65,1 +64,1 @@\n-        this.add(BorderLayout.CENTER, treeView);\n+        add(BorderLayout.CENTER, treeView);\n@@ -112,5 +111,0 @@\n-    @Override\n-    public Object writeReplace() {\n-        return new ResolvableHelper();\n-    }\n-\n@@ -159,9 +153,0 @@\n-    static final class ResolvableHelper implements Serializable {\n-\n-        private static final long serialVersionUID = 1L;\n-\n-        public Object readResolve() {\n-            return BytecodeViewTopComponent.getDefault();\n-        }\n-    }\n-\n","filename":"src\/utils\/IdealGraphVisualizer\/Bytecodes\/src\/main\/java\/com\/sun\/hotspot\/igv\/bytecodes\/BytecodeViewTopComponent.java","additions":2,"deletions":17,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-        private String bciString;\n+        private final String bciString;\n","filename":"src\/utils\/IdealGraphVisualizer\/Bytecodes\/src\/main\/java\/com\/sun\/hotspot\/igv\/bytecodes\/MethodNode.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-    private Set<InputNode> nodes;\n+    private final Set<InputNode> nodes;\n","filename":"src\/utils\/IdealGraphVisualizer\/Bytecodes\/src\/main\/java\/com\/sun\/hotspot\/igv\/bytecodes\/SelectBytecodesCookie.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -16,0 +16,1 @@\n+                <attr name=\"position\" intvalue=\"1\"\/>\n","filename":"src\/utils\/IdealGraphVisualizer\/Bytecodes\/src\/main\/resources\/com\/sun\/hotspot\/igv\/bytecodes\/layer.xml","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -11,1 +11,1 @@\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License\n@@ -27,0 +27,1 @@\n+import com.sun.hotspot.igv.layout.Cluster;\n@@ -29,1 +30,0 @@\n-import com.sun.hotspot.igv.layout.Cluster;\n@@ -48,4 +48,4 @@\n-    private BlockWidget from;\n-    private BlockWidget to;\n-    private Port inputSlot;\n-    private Port outputSlot;\n+    private final BlockWidget from;\n+    private final BlockWidget to;\n+    private final Port inputSlot;\n+    private final Port outputSlot;\n@@ -53,1 +53,0 @@\n-    private InputBlockEdge edge;\n@@ -60,1 +59,0 @@\n-        this.edge = edge;\n@@ -65,5 +63,1 @@\n-        points = new ArrayList<Point>();\n-    }\n-\n-    public InputBlockEdge getEdge() {\n-        return edge;\n+        points = new ArrayList<>();\n","filename":"src\/utils\/IdealGraphVisualizer\/ControlFlow\/src\/main\/java\/com\/sun\/hotspot\/igv\/controlflow\/BlockConnectionWidget.java","additions":7,"deletions":13,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -11,1 +11,1 @@\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License\n@@ -30,5 +30,1 @@\n-import java.awt.Color;\n-import java.awt.Dimension;\n-import java.awt.Font;\n-import java.awt.Point;\n-import java.awt.Rectangle;\n+import java.awt.*;\n@@ -46,3 +42,3 @@\n-    private InputBlock block;\n-    private Port inputSlot;\n-    private Port outputSlot;\n+    private final InputBlock block;\n+    private final Port inputSlot;\n+    private final Port outputSlot;\n@@ -50,1 +46,0 @@\n-    private boolean root;\n@@ -126,9 +121,1 @@\n-        return root;\n-    }\n-\n-    public void setCluster(Cluster c) {\n-        cluster = c;\n-    }\n-\n-    public void setRoot(boolean b) {\n-        root = b;\n+        return false;\n","filename":"src\/utils\/IdealGraphVisualizer\/ControlFlow\/src\/main\/java\/com\/sun\/hotspot\/igv\/controlflow\/BlockWidget.java","additions":6,"deletions":19,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -11,1 +11,1 @@\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License\n","filename":"src\/utils\/IdealGraphVisualizer\/ControlFlow\/src\/main\/java\/com\/sun\/hotspot\/igv\/controlflow\/ControlFlowAction.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -11,1 +11,1 @@\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License\n@@ -26,1 +26,0 @@\n-import com.sun.hotspot.igv.data.InputBlockEdge;\n@@ -28,0 +27,1 @@\n+import com.sun.hotspot.igv.data.InputBlockEdge;\n@@ -29,1 +29,0 @@\n-import com.sun.hotspot.igv.data.services.InputGraphProvider;\n@@ -31,0 +30,1 @@\n+import com.sun.hotspot.igv.data.services.InputGraphProvider;\n@@ -39,6 +39,1 @@\n-import org.netbeans.api.visual.action.ActionFactory;\n-import org.netbeans.api.visual.action.MoveProvider;\n-import org.netbeans.api.visual.action.RectangularSelectDecorator;\n-import org.netbeans.api.visual.action.RectangularSelectProvider;\n-import org.netbeans.api.visual.action.SelectProvider;\n-import org.netbeans.api.visual.action.WidgetAction;\n+import org.netbeans.api.visual.action.*;\n@@ -47,3 +42,0 @@\n-import org.netbeans.api.visual.router.RouterFactory;\n-import org.netbeans.api.visual.widget.LayerWidget;\n-import org.netbeans.api.visual.widget.Widget;\n@@ -54,0 +46,1 @@\n+import org.netbeans.api.visual.router.RouterFactory;\n@@ -55,0 +48,2 @@\n+import org.netbeans.api.visual.widget.LayerWidget;\n+import org.netbeans.api.visual.widget.Widget;\n@@ -62,1 +57,1 @@\n-    private HashSet<BlockWidget> selection;\n+    private final HashSet<BlockWidget> selection;\n@@ -64,6 +59,5 @@\n-    private LayerWidget edgeLayer;\n-    private LayerWidget mainLayer;\n-    private LayerWidget selectLayer;\n-    private WidgetAction hoverAction = this.createWidgetHoverAction();\n-    private WidgetAction selectAction = new DoubleClickSelectAction(this);\n-    private WidgetAction moveAction = ActionFactory.createMoveAction(null, this);\n+    private final LayerWidget edgeLayer;\n+    private final LayerWidget mainLayer;\n+    private final WidgetAction hoverAction = createWidgetHoverAction();\n+    private final WidgetAction selectAction = new DoubleClickSelectAction(this);\n+    private final WidgetAction moveAction = ActionFactory.createMoveAction(null, this);\n@@ -72,1 +66,1 @@\n-        selection = new HashSet<BlockWidget>();\n+        selection = new HashSet<>();\n@@ -74,2 +68,2 @@\n-        this.getInputBindings().setZoomActionModifiers(0);\n-        this.setLayout(LayoutFactory.createAbsoluteLayout());\n+        getInputBindings().setZoomActionModifiers(0);\n+        setLayout(LayoutFactory.createAbsoluteLayout());\n@@ -78,1 +72,1 @@\n-        this.addChild(mainLayer);\n+        addChild(mainLayer);\n@@ -81,1 +75,1 @@\n-        this.addChild(edgeLayer);\n+        addChild(edgeLayer);\n@@ -83,2 +77,2 @@\n-        selectLayer = new LayerWidget(this);\n-        this.addChild(selectLayer);\n+        LayerWidget selectLayer = new LayerWidget(this);\n+        addChild(selectLayer);\n@@ -86,4 +80,4 @@\n-        this.getActions().addAction(hoverAction);\n-        this.getActions().addAction(selectAction);\n-        this.getActions().addAction(ActionFactory.createRectangularSelectAction(this, selectLayer, this));\n-        this.getActions().addAction(ActionFactory.createMouseCenteredZoomAction(1.1));\n+        getActions().addAction(hoverAction);\n+        getActions().addAction(selectAction);\n+        getActions().addAction(ActionFactory.createRectangularSelectAction(this, selectLayer, this));\n+        getActions().addAction(ActionFactory.createMouseCenteredZoomAction(1.1));\n@@ -98,1 +92,1 @@\n-        ArrayList<InputBlock> blocks = new ArrayList<InputBlock>(this.getNodes());\n+        ArrayList<InputBlock> blocks = new ArrayList<>(getNodes());\n@@ -103,1 +97,1 @@\n-        ArrayList<InputBlockEdge> edges = new ArrayList<InputBlockEdge>(this.getEdges());\n+        ArrayList<InputBlockEdge> edges = new ArrayList<>(getEdges());\n@@ -116,2 +110,2 @@\n-            this.setEdgeSource(e, e.getFrom());\n-            this.setEdgeTarget(e, e.getTo());\n+            setEdgeSource(e, e.getFrom());\n+            setEdgeTarget(e, e.getTo());\n@@ -120,1 +114,1 @@\n-        GraphLayout<InputBlock, InputBlockEdge> layout = new HierarchicalGraphLayout<InputBlock, InputBlockEdge>();\/\/GridGraphLayout();\n+        GraphLayout<InputBlock, InputBlockEdge> layout = new HierarchicalGraphLayout<>();\n@@ -124,1 +118,1 @@\n-        this.validate();\n+        validate();\n@@ -138,1 +132,1 @@\n-            Set<InputNode> inputNodes = new HashSet<InputNode>();\n+            Set<InputNode> inputNodes = new HashSet<>();\n@@ -158,0 +152,1 @@\n+    @Override\n@@ -162,0 +157,1 @@\n+    @Override\n@@ -166,0 +162,1 @@\n+    @Override\n@@ -188,2 +185,2 @@\n-    public void movementStarted(Widget widget) {\n-    }\n+    @Override\n+    public void movementStarted(Widget widget) {}\n@@ -191,2 +188,3 @@\n-    public void movementFinished(Widget widget) {\n-    }\n+    @Override\n+\n+    public void movementFinished(Widget widget) {}\n@@ -194,0 +192,1 @@\n+    @Override\n@@ -198,0 +197,1 @@\n+    @Override\n@@ -199,1 +199,2 @@\n-        if (selection.contains(widget)) {\n+        assert widget instanceof BlockWidget;\n+        if (selection.contains((BlockWidget) widget)) {\n@@ -214,0 +215,1 @@\n+    @Override\n@@ -222,0 +224,1 @@\n+    @Override\n@@ -235,1 +238,1 @@\n-        for (InputBlock b : this.getNodes()) {\n+        for (InputBlock b : getNodes()) {\n@@ -237,0 +240,1 @@\n+            assert w.getBounds() != null;\n@@ -260,0 +264,1 @@\n+    @Override\n@@ -269,0 +274,1 @@\n+    @Override\n@@ -285,0 +291,1 @@\n+    @Override\n@@ -286,1 +293,1 @@\n-        Widget w = this.findWidget(edge);\n+        Widget w = findWidget(edge);\n@@ -293,0 +300,1 @@\n+    @Override\n@@ -294,1 +302,1 @@\n-        Widget w = this.findWidget(edge);\n+        Widget w = findWidget(edge);\n","filename":"src\/utils\/IdealGraphVisualizer\/ControlFlow\/src\/main\/java\/com\/sun\/hotspot\/igv\/controlflow\/ControlFlowScene.java","additions":53,"deletions":45,"binary":false,"changes":98,"status":"modified"},{"patch":"@@ -11,1 +11,1 @@\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License\n@@ -31,1 +31,0 @@\n-import java.io.Serializable;\n@@ -54,3 +53,2 @@\n-        this.setLayout(new BorderLayout());\n-        this.associateLookup(scene.getLookup());\n-\n+        setLayout(new BorderLayout());\n+        associateLookup(scene.getLookup());\n@@ -59,1 +57,1 @@\n-        this.add(panel, BorderLayout.CENTER);\n+        add(panel, BorderLayout.CENTER);\n@@ -117,5 +115,0 @@\n-    @Override\n-    public Object writeReplace() {\n-        return new ResolvableHelper();\n-    }\n-\n@@ -133,9 +126,0 @@\n-    static final class ResolvableHelper implements Serializable {\n-\n-        private static final long serialVersionUID = 1L;\n-\n-        public Object readResolve() {\n-            return ControlFlowTopComponent.getDefault();\n-        }\n-    }\n-\n","filename":"src\/utils\/IdealGraphVisualizer\/ControlFlow\/src\/main\/java\/com\/sun\/hotspot\/igv\/controlflow\/ControlFlowTopComponent.java","additions":4,"deletions":20,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -11,1 +11,1 @@\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License\n","filename":"src\/utils\/IdealGraphVisualizer\/ControlFlow\/src\/main\/java\/com\/sun\/hotspot\/igv\/controlflow\/DoubleClickSelectAction.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -11,1 +11,1 @@\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License\n@@ -27,5 +27,1 @@\n-import com.sun.hotspot.igv.layout.Cluster;\n-import com.sun.hotspot.igv.layout.LayoutGraph;\n-import com.sun.hotspot.igv.layout.Link;\n-import com.sun.hotspot.igv.layout.Port;\n-import com.sun.hotspot.igv.layout.Vertex;\n+import com.sun.hotspot.igv.layout.*;\n@@ -34,7 +30,1 @@\n-import java.util.ArrayList;\n-import java.util.Collection;\n-import java.util.HashMap;\n-import java.util.LinkedHashSet;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n+import java.util.*;\n@@ -51,2 +41,1 @@\n-    public HierarchicalGraphLayout() {\n-    }\n+    public HierarchicalGraphLayout() {}\n@@ -56,2 +45,2 @@\n-        private VertexWrapper from;\n-        private VertexWrapper to;\n+        private final VertexWrapper from;\n+        private final VertexWrapper to;\n@@ -81,1 +70,1 @@\n-            return new ArrayList<Point>();\n+            return new ArrayList<>();\n@@ -95,3 +84,3 @@\n-        private N node;\n-        private UniversalGraph<N, E> graph;\n-        private Port slot;\n+        private final N node;\n+        private final UniversalGraph<N, E> graph;\n+        private final Port slot;\n@@ -125,0 +114,1 @@\n+            assert w.getBounds() != null;\n@@ -154,3 +144,3 @@\n-        Set<LinkWrapper> links = new LinkedHashSet<LinkWrapper>();\n-        Set<VertexWrapper> vertices = new LinkedHashSet<VertexWrapper>();\n-        Map<N, VertexWrapper> vertexMap = new HashMap<N, VertexWrapper>();\n+        Set<LinkWrapper> links = new LinkedHashSet<>();\n+        Set<VertexWrapper> vertices = new LinkedHashSet<>();\n+        Map<N, VertexWrapper> vertexMap = new HashMap<>();\n","filename":"src\/utils\/IdealGraphVisualizer\/ControlFlow\/src\/main\/java\/com\/sun\/hotspot\/igv\/controlflow\/HierarchicalGraphLayout.java","additions":14,"deletions":24,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -13,0 +13,1 @@\n+                <attr name=\"position\" intvalue=\"2\"\/>\n","filename":"src\/utils\/IdealGraphVisualizer\/ControlFlow\/src\/main\/resources\/com\/sun\/hotspot\/igv\/controlflow\/layer.xml","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import java.util.List;\n@@ -33,0 +32,1 @@\n+import java.util.List;\n@@ -48,2 +48,2 @@\n-    private InstanceContent content;\n-    private FolderChildren children;\n+    private final InstanceContent content;\n+    private final FolderChildren children;\n@@ -52,1 +52,1 @@\n-    private static Map<InputGraph, GraphNode> graphNode = new HashMap<>();\n+    private static final Map<InputGraph, GraphNode> graphNode = new HashMap<>();\n@@ -131,6 +131,3 @@\n-            content.add(new RemoveCookie() {\n-                @Override\n-                public void remove() {\n-                    children.destroyNodes(children.getNodes());\n-                    folderElement.getParent().removeElement(folderElement);\n-                }\n+            content.add((RemoveCookie) () -> {\n+                children.destroyNodes(children.getNodes());\n+                folderElement.getParent().removeElement(folderElement);\n@@ -166,1 +163,1 @@\n-        return (folder != null && folder instanceof GraphDocument);\n+        return (folder instanceof GraphDocument);\n","filename":"src\/utils\/IdealGraphVisualizer\/Coordinator\/src\/main\/java\/com\/sun\/hotspot\/igv\/coordinator\/FolderNode.java","additions":8,"deletions":11,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -26,6 +26,1 @@\n-import com.sun.hotspot.igv.coordinator.actions.CloneGraphAction;\n-import com.sun.hotspot.igv.coordinator.actions.DiffGraphAction;\n-import com.sun.hotspot.igv.coordinator.actions.DiffGraphCookie;\n-import com.sun.hotspot.igv.coordinator.actions.GraphCloneCookie;\n-import com.sun.hotspot.igv.coordinator.actions.GraphOpenCookie;\n-import com.sun.hotspot.igv.coordinator.actions.GraphRemoveCookie;\n+import com.sun.hotspot.igv.coordinator.actions.*;\n@@ -40,6 +35,1 @@\n-import org.openide.nodes.AbstractNode;\n-import org.openide.nodes.Children;\n-import org.openide.nodes.NodeAdapter;\n-import org.openide.nodes.NodeEvent;\n-import org.openide.nodes.NodeMemberEvent;\n-import org.openide.nodes.Sheet;\n+import org.openide.nodes.*;\n@@ -135,1 +125,1 @@\n-        return new Action[]{(Action) DiffGraphAction.findObject(DiffGraphAction.class, true), (Action) CloneGraphAction.findObject(CloneGraphAction.class, true), (Action) OpenAction.findObject(OpenAction.class, true)};\n+        return new Action[]{DiffGraphAction.findObject(DiffGraphAction.class, true), CloneGraphAction.findObject(CloneGraphAction.class, true), OpenAction.findObject(OpenAction.class, true)};\n@@ -140,1 +130,1 @@\n-        return (Action) OpenAction.findObject(OpenAction.class, true);\n+        return OpenAction.findObject(OpenAction.class, true);\n","filename":"src\/utils\/IdealGraphVisualizer\/Coordinator\/src\/main\/java\/com\/sun\/hotspot\/igv\/coordinator\/GraphNode.java","additions":4,"deletions":14,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -40,1 +40,0 @@\n-import java.io.Serializable;\n@@ -69,2 +68,0 @@\n-    private Server server;\n-    private Server binaryServer;\n@@ -106,1 +103,0 @@\n-\n@@ -110,1 +106,0 @@\n-\n@@ -112,1 +107,0 @@\n-\n@@ -116,1 +110,0 @@\n-\n@@ -141,2 +134,1 @@\n-        server = new Server(getDocument(), callback, false);\n-        binaryServer = new Server(getDocument(), callback, true);\n+        new Server(callback);\n@@ -289,9 +281,0 @@\n-    static final class ResolvableHelper implements Serializable {\n-\n-        private static final long serialVersionUID = 1L;\n-\n-        public Object readResolve() {\n-            return OutlineTopComponent.getDefault();\n-        }\n-    }\n-\n","filename":"src\/utils\/IdealGraphVisualizer\/Coordinator\/src\/main\/java\/com\/sun\/hotspot\/igv\/coordinator\/OutlineTopComponent.java","additions":1,"deletions":18,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import com.sun.hotspot.igv.data.serialization.BinaryParser;\n@@ -34,1 +33,0 @@\n-import java.awt.event.ActionEvent;\n@@ -36,1 +34,0 @@\n-import java.io.FileNotFoundException;\n@@ -42,0 +39,1 @@\n+import javax.swing.Action;\n@@ -45,1 +43,0 @@\n-import javax.swing.Action;\n@@ -48,4 +45,1 @@\n-import org.openide.util.Exceptions;\n-import org.openide.util.RequestProcessor;\n-import org.openide.util.HelpCtx;\n-import org.openide.util.NbBundle;\n+import org.openide.util.*;\n@@ -53,1 +47,0 @@\n-import org.openide.util.Utilities;\n@@ -68,1 +61,1 @@\n-                return f.getName().toLowerCase().endsWith(\".xml\") || f.getName().toLowerCase().endsWith(\".bgv\") || f.isDirectory();\n+                return f.getName().toLowerCase().endsWith(\".xml\") || f.isDirectory();\n@@ -73,1 +66,1 @@\n-                return \"Graph files (*.xml, *.bgv)\";\n+                return \"Graph files (*.xml)\";\n@@ -105,2 +98,1 @@\n-                                } catch (IOException ex) {\n-                                }\n+                                } catch (IOException ignored) {}\n@@ -118,2 +110,0 @@\n-                    } else if (file.getName().endsWith(\".bgv\")) {\n-                        parser = new BinaryParser(channel, monitor, component.getDocument(), null);\n@@ -129,7 +119,4 @@\n-                                        SwingUtilities.invokeLater(new Runnable(){\n-                                                @Override\n-                                                public void run() {\n-                                                    component.requestActive();\n-                                                    component.getDocument().addGraphDocument(document);\n-                                                }\n-                                            });\n+                                        SwingUtilities.invokeLater(() -> {\n+                                            component.requestActive();\n+                                            component.getDocument().addGraphDocument(document);\n+                                        });\n@@ -145,2 +132,0 @@\n-                } catch (FileNotFoundException ex) {\n-                    Exceptions.printStackTrace(ex);\n","filename":"src\/utils\/IdealGraphVisualizer\/Coordinator\/src\/main\/java\/com\/sun\/hotspot\/igv\/coordinator\/actions\/ImportAction.java","additions":9,"deletions":24,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-import java.awt.event.InputEvent;\n-import java.awt.event.KeyEvent;\n@@ -31,1 +29,0 @@\n-import javax.swing.KeyStroke;\n","filename":"src\/utils\/IdealGraphVisualizer\/Coordinator\/src\/main\/java\/com\/sun\/hotspot\/igv\/coordinator\/actions\/RemoveAllAction.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-import java.awt.event.InputEvent;\n-import java.awt.event.KeyEvent;\n@@ -31,1 +29,0 @@\n-import javax.swing.KeyStroke;\n@@ -34,2 +31,0 @@\n-import org.openide.util.NbBundle.Messages;\n-import org.openide.util.actions.CallableSystemAction;\n@@ -37,0 +32,1 @@\n+import org.openide.util.actions.CallableSystemAction;\n","filename":"src\/utils\/IdealGraphVisualizer\/Coordinator\/src\/main\/java\/com\/sun\/hotspot\/igv\/coordinator\/actions\/SaveAllAction.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import com.sun.hotspot.igv.coordinator.OutlineTopComponent;\n@@ -34,1 +33,5 @@\n-import java.io.*;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.OutputStreamWriter;\n+import java.io.Writer;\n+import java.nio.file.Files;\n@@ -40,1 +43,0 @@\n-import org.openide.util.actions.CookieAction;\n@@ -55,1 +57,0 @@\n-        final OutlineTopComponent component = OutlineTopComponent.findInstance();\n@@ -87,1 +88,1 @@\n-                try (Writer writer = new OutputStreamWriter(new FileOutputStream(file))) {\n+                try (Writer writer = new OutputStreamWriter(Files.newOutputStream(file.toPath()))) {\n@@ -91,2 +92,0 @@\n-            } catch (FileNotFoundException e) {\n-                e.printStackTrace();\n@@ -95,1 +94,0 @@\n-\n@@ -100,4 +98,0 @@\n-    protected int mode() {\n-        return CookieAction.MODE_SOME;\n-    }\n-\n","filename":"src\/utils\/IdealGraphVisualizer\/Coordinator\/src\/main\/java\/com\/sun\/hotspot\/igv\/coordinator\/actions\/SaveAsAction.java","additions":6,"deletions":12,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-    \n+\n@@ -49,0 +49,1 @@\n+            <attr name=\"position\" intvalue=\"50\"\/>\n@@ -99,1 +100,1 @@\n-        \n+\n@@ -101,0 +102,1 @@\n+            <attr name=\"position\" intvalue=\"100\"\/>\n@@ -133,1 +135,1 @@\n-        \n+\n@@ -135,0 +137,1 @@\n+            <attr name=\"position\" intvalue=\"150\"\/>\n@@ -151,1 +154,1 @@\n-        \n+\n@@ -162,0 +165,1 @@\n+            <attr name=\"position\" intvalue=\"200\"\/>\n@@ -164,0 +168,1 @@\n+                <attr name=\"position\" intvalue=\"1\"\/>\n@@ -168,0 +173,1 @@\n+            <attr name=\"position\" intvalue=\"250\"\/>\n@@ -170,0 +176,1 @@\n+                <attr name=\"position\" intvalue=\"4\"\/>\n@@ -191,0 +198,1 @@\n+            <attr name=\"position\" intvalue=\"300\"\/>\n@@ -217,1 +225,1 @@\n-    \n+\n@@ -222,1 +230,1 @@\n-        <folder name=\"Modes\">  \n+        <folder name=\"Modes\">\n","filename":"src\/utils\/IdealGraphVisualizer\/Coordinator\/src\/main\/resources\/com\/sun\/hotspot\/igv\/coordinator\/layer.xml","additions":14,"deletions":6,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-    private T object;\n+    private final T object;\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/main\/java\/com\/sun\/hotspot\/igv\/data\/ChangedEvent.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-    private List<L> listener;\n+    private final List<L> listener;\n@@ -48,4 +48,0 @@\n-    \/**\n-     * Remove listener\n-     * @param l\n-     *\/\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/main\/java\/com\/sun\/hotspot\/igv\/data\/Event.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -35,2 +35,2 @@\n-    private List<FolderElement> elements;\n-    private ChangedEvent<GraphDocument> changedEvent;\n+    private final List<FolderElement> elements;\n+    private final ChangedEvent<GraphDocument> changedEvent;\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/main\/java\/com\/sun\/hotspot\/igv\/data\/GraphDocument.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-    private final List<FolderElement> elements;\n@@ -36,1 +35,0 @@\n-\n@@ -38,1 +36,1 @@\n-    private transient ChangedEvent<Group> changedEvent;\n+    private final transient ChangedEvent<Group> changedEvent;\n@@ -42,1 +40,0 @@\n-        elements = new ArrayList<>();\n@@ -47,1 +44,1 @@\n-        \/\/ Ensure that name and type are never null\n+        \/\/ Ensure that name is never null\n@@ -49,5 +46,0 @@\n-        getProperties().setProperty(\"type\", \"\");\n-    }\n-\n-    public void fireChangedEvent() {\n-        changedEvent.fire();\n@@ -70,2 +62,5 @@\n-    public List<FolderElement> getElements() {\n-        return Collections.unmodifiableList(elements);\n+    public void addElement(FolderElement element) {\n+        assert element instanceof InputGraph;\n+        graphs.add((InputGraph) element);\n+        element.setParent(this);\n+        getChangedEvent().fire();\n@@ -74,2 +69,6 @@\n-    public int getGraphsCount() {\n-        return elements.size();\n+    @Override\n+    public void removeElement(FolderElement element) {\n+        assert element instanceof InputGraph;\n+        if (graphs.remove((InputGraph) element)) {\n+            getChangedEvent().fire();\n+        }\n@@ -79,5 +78,3 @@\n-    public void addElement(FolderElement element) {\n-        elements.add(element);\n-        if (element instanceof InputGraph) {\n-            graphs.add((InputGraph) element);\n-        } else {\n+    public List<FolderElement> getElements() {\n+        return Collections.unmodifiableList(graphs);\n+    }\n@@ -85,3 +82,2 @@\n-        }\n-        element.setParent(this);\n-        changedEvent.fire();\n+    public List<InputGraph> getGraphs() {\n+        return Collections.unmodifiableList(graphs);\n@@ -92,5 +88,2 @@\n-        for (FolderElement e : elements) {\n-            if (e instanceof InputGraph) {\n-                InputGraph g = (InputGraph) e;\n-                result.addAll(g.getNodesAsSet());\n-            }\n+        for (InputGraph g : graphs) {\n+            result.addAll(g.getNodesAsSet());\n@@ -105,1 +98,1 @@\n-        for (FolderElement g : elements) {\n+        for (FolderElement g : getElements()) {\n@@ -117,40 +110,0 @@\n-    public String getType() {\n-        return getProperties().get(\"type\");\n-\n-    }\n-\n-    InputGraph getPrev(InputGraph graph) {\n-        InputGraph lastGraph = null;\n-        for (FolderElement e : elements) {\n-            if (e == graph) {\n-                return lastGraph;\n-            }\n-            if (e instanceof InputGraph) {\n-                lastGraph = (InputGraph) e;\n-            }\n-        }\n-        return null;\n-    }\n-\n-    InputGraph getNext(InputGraph graph) {\n-        boolean found = false;\n-        for (FolderElement e : elements) {\n-            if (e == graph) {\n-                found = true;\n-            } else if (found && e instanceof InputGraph) {\n-                return (InputGraph) e;\n-            }\n-        }\n-        return null;\n-    }\n-\n-    public InputGraph getLastGraph() {\n-        InputGraph lastGraph = null;\n-        for (FolderElement e : elements) {\n-            if (e instanceof InputGraph) {\n-                lastGraph = (InputGraph) e;\n-            }\n-        }\n-        return lastGraph;\n-    }\n-\n@@ -161,15 +114,0 @@\n-\n-    @Override\n-    public void removeElement(FolderElement element) {\n-        if (elements.remove(element)) {\n-            if (element instanceof InputGraph) {\n-                graphs.remove((InputGraph) element);\n-            }\n-            changedEvent.fire();\n-        }\n-    }\n-\n-    public List<InputGraph> getGraphs() {\n-        return graphs;\n-    }\n-\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/main\/java\/com\/sun\/hotspot\/igv\/data\/Group.java","additions":21,"deletions":83,"binary":false,"changes":104,"status":"modified"},{"patch":"@@ -35,3 +35,3 @@\n-    private String name;\n-    private InputGraph graph;\n-    private Set<InputBlock> successors;\n+    private final String name;\n+    private final InputGraph graph;\n+    private final Set<InputBlock> successors;\n@@ -52,1 +52,1 @@\n-        if (o == null || (!(o instanceof InputBlock))) {\n+        if ((!(o instanceof InputBlock))) {\n@@ -116,3 +116,1 @@\n-        if (!successors.contains(b)) {\n-            successors.add(b);\n-        }\n+        successors.add(b);\n@@ -121,2 +119,2 @@\n-    void setArtificial(boolean artificial) {\n-        this.artificial = artificial;\n+    void setArtificial() {\n+        this.artificial = true;\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/main\/java\/com\/sun\/hotspot\/igv\/data\/InputBlock.java","additions":7,"deletions":9,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -38,2 +38,2 @@\n-    private InputBlock from;\n-    private InputBlock to;\n+    private final InputBlock from;\n+    private final InputBlock to;\n@@ -41,1 +41,1 @@\n-    private String label;\n+    private final String label;\n@@ -73,1 +73,1 @@\n-        if (obj != null && obj instanceof InputBlockEdge) {\n+        if (obj instanceof InputBlockEdge) {\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/main\/java\/com\/sun\/hotspot\/igv\/data\/InputBlockEdge.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -32,4 +32,4 @@\n-    private int bci;\n-    private String name;\n-    private String operands;\n-    private String comment;\n+    private final int bci;\n+    private final String name;\n+    private final String operands;\n+    private final String comment;\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/main\/java\/com\/sun\/hotspot\/igv\/data\/InputBytecode.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n-import java.util.Comparator;\n-import java.util.WeakHashMap;\n@@ -29,0 +27,2 @@\n+import java.util.Objects;\n+import java.util.WeakHashMap;\n@@ -43,22 +43,0 @@\n-    public static final Comparator<InputEdge> OUTGOING_COMPARATOR = new Comparator<InputEdge>(){\n-\n-        @Override\n-            public int compare(InputEdge o1, InputEdge o2) {\n-                if(o1.getFromIndex() == o2.getFromIndex()) {\n-                    return o1.getTo() - o2.getTo();\n-                }\n-                return o1.getFromIndex() - o2.getFromIndex();\n-            }\n-    };\n-\n-    public static final Comparator<InputEdge> INGOING_COMPARATOR = new Comparator<InputEdge>(){\n-\n-        @Override\n-            public int compare(InputEdge o1, InputEdge o2) {\n-                if(o1.getToIndex() == o2.getToIndex()) {\n-                    return o1.getFrom() - o2.getFrom();\n-                }\n-                return o1.getToIndex() - o2.getToIndex();\n-            }\n-    };\n-\n@@ -73,8 +51,0 @@\n-    public InputEdge(char toIndex, int from, int to) {\n-        this((char) 0, toIndex, from, to, null, null);\n-    }\n-\n-    public InputEdge(char fromIndex, char toIndex, int from, int to) {\n-        this(fromIndex, toIndex, from, to, null, null);\n-    }\n-\n@@ -157,1 +127,1 @@\n-        if (o == null || !(o instanceof InputEdge)) {\n+        if (!(o instanceof InputEdge)) {\n@@ -164,1 +134,1 @@\n-            return conn2.label == label && conn2.state == state;\n+            return Objects.equals(conn2.label, label) && conn2.state == state;\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/main\/java\/com\/sun\/hotspot\/igv\/data\/InputEdge.java","additions":4,"deletions":34,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -34,2 +34,2 @@\n-    private Map<Integer, InputNode> nodes;\n-    private List<InputEdge> edges;\n+    private final Map<Integer, InputNode> nodes;\n+    private final List<InputEdge> edges;\n@@ -38,3 +38,3 @@\n-    private Map<String, InputBlock> blocks;\n-    private List<InputBlockEdge> blockEdges;\n-    private Map<Integer, InputBlock> nodeToBlock;\n+    private final Map<String, InputBlock> blocks;\n+    private final List<InputBlockEdge> blockEdges;\n+    private final Map<Integer, InputBlock> nodeToBlock;\n@@ -67,1 +67,1 @@\n-        return this.isDiffGraph;\n+        return isDiffGraph;\n@@ -98,74 +98,0 @@\n-    public List<InputNode> findRootNodes() {\n-        List<InputNode> result = new ArrayList<>();\n-        Set<Integer> nonRoot = new HashSet<>();\n-        for(InputEdge curEdges : getEdges()) {\n-            nonRoot.add(curEdges.getTo());\n-        }\n-\n-        for(InputNode node : getNodes()) {\n-            if(!nonRoot.contains(node.getId())) {\n-                result.add(node);\n-            }\n-        }\n-\n-        return result;\n-    }\n-\n-    public Map<InputNode, List<InputEdge>> findAllOutgoingEdges() {\n-        Map<InputNode, List<InputEdge>> result = new HashMap<>(getNodes().size());\n-        for(InputNode n : this.getNodes()) {\n-            result.put(n, new ArrayList<InputEdge>());\n-        }\n-\n-        for(InputEdge e : this.edges) {\n-            int from = e.getFrom();\n-            InputNode fromNode = this.getNode(from);\n-            List<InputEdge> fromList = result.get(fromNode);\n-            assert fromList != null;\n-            fromList.add(e);\n-        }\n-\n-        for(InputNode n : this.getNodes()) {\n-            List<InputEdge> list = result.get(n);\n-            list.sort(InputEdge.OUTGOING_COMPARATOR);\n-        }\n-\n-        return result;\n-    }\n-\n-    public Map<InputNode, List<InputEdge>> findAllIngoingEdges() {\n-        Map<InputNode, List<InputEdge>> result = new HashMap<>(getNodes().size());\n-        for(InputNode n : this.getNodes()) {\n-            result.put(n, new ArrayList<InputEdge>());\n-        }\n-\n-        for(InputEdge e : this.edges) {\n-            int to = e.getTo();\n-            InputNode toNode = this.getNode(to);\n-            List<InputEdge> toList = result.get(toNode);\n-            assert toList != null;\n-            toList.add(e);\n-        }\n-\n-        for(InputNode n : this.getNodes()) {\n-            List<InputEdge> list = result.get(n);\n-            list.sort(InputEdge.INGOING_COMPARATOR);\n-        }\n-\n-        return result;\n-    }\n-\n-    public List<InputEdge> findOutgoingEdges(InputNode n) {\n-        List<InputEdge> result = new ArrayList<>();\n-\n-        for(InputEdge e : this.edges) {\n-            if(e.getFrom() == n.getId()) {\n-                result.add(e);\n-            }\n-        }\n-\n-        result.sort(InputEdge.OUTGOING_COMPARATOR);\n-\n-        return result;\n-    }\n-\n@@ -178,10 +104,0 @@\n-    public void setEdge(int fromIndex, int toIndex, int from, int to) {\n-        assert fromIndex == ((char)fromIndex) : \"Downcast must be safe\";\n-        assert toIndex == ((char)toIndex) : \"Downcast must be safe\";\n-\n-        InputEdge edge = new InputEdge((char)fromIndex, (char)toIndex, from, to);\n-        if(!this.getEdges().contains(edge)) {\n-            this.addEdge(edge);\n-        }\n-    }\n-\n@@ -225,8 +141,0 @@\n-    public InputGraph getNext() {\n-        return parentGroup.getNext(this);\n-    }\n-\n-    public InputGraph getPrev() {\n-        return parentGroup.getPrev(this);\n-    }\n-\n@@ -307,1 +215,1 @@\n-        b.setArtificial(true);\n+        b.setArtificial();\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/main\/java\/com\/sun\/hotspot\/igv\/data\/InputGraph.java","additions":7,"deletions":99,"binary":false,"changes":106,"status":"modified"},{"patch":"@@ -38,4 +38,4 @@\n-    private String name;\n-    private int bci;\n-    private String shortName;\n-    private List<InputMethod> inlined;\n+    private final String name;\n+    private final int bci;\n+    private final String shortName;\n+    private final List<InputMethod> inlined;\n@@ -43,2 +43,2 @@\n-    private Group group;\n-    private List<InputBytecode> bytecodes;\n+    private final Group group;\n+    private final List<InputBytecode> bytecodes;\n@@ -58,1 +58,1 @@\n-        if (o == null || (!(o instanceof InputMethod))) {\n+        if ((!(o instanceof InputMethod))) {\n@@ -61,2 +61,1 @@\n-\n-        final InputMethod im = (InputMethod)o;\n+        final InputMethod im = (InputMethod) o;\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/main\/java\/com\/sun\/hotspot\/igv\/data\/InputMethod.java","additions":8,"deletions":9,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -26,4 +26,0 @@\n-import java.util.ArrayList;\n-import java.util.Comparator;\n-import java.util.List;\n-\n@@ -37,31 +33,0 @@\n-    private List<InputGraph> subgraphs;\n-\n-    public static final Comparator<InputNode> COMPARATOR = new Comparator<InputNode>() {\n-        @Override\n-        public int compare(InputNode o1, InputNode o2) {\n-            return o1.getId() - o2.getId();\n-        }\n-    };\n-\n-    public static Comparator<InputNode> getPropertyComparator(final String propertyName) {\n-        return new Comparator<InputNode>() {\n-\n-            @Override\n-            public int compare(InputNode o1, InputNode o2) {\n-\n-                int i1 = 0;\n-                try {\n-                    i1 = Integer.parseInt(o1.getProperties().get(propertyName));\n-                } catch(NumberFormatException e) {\n-                }\n-\n-                int i2 = 0;\n-                try {\n-                    i2 = Integer.parseInt(o2.getProperties().get(propertyName));\n-                } catch(NumberFormatException e) {\n-                }\n-\n-                return i1 - i2;\n-            }\n-        };\n-    }\n@@ -86,11 +51,0 @@\n-    public void addSubgraph(InputGraph graph) {\n-        if (subgraphs == null) {\n-            subgraphs = new ArrayList<>();\n-        }\n-        subgraphs.add(graph);\n-    }\n-\n-    public List<InputGraph> getSubgraphs() {\n-        return subgraphs;\n-    }\n-\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/main\/java\/com\/sun\/hotspot\/igv\/data\/InputNode.java","additions":0,"deletions":46,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -61,1 +61,1 @@\n-        if (o == null || !(o instanceof Pair)) {\n+        if (!(o instanceof Pair<?, ?>)) {\n@@ -64,1 +64,1 @@\n-        Pair<?,?> obj = (Pair<?,?>) o;\n+        Pair<?, ?> obj = (Pair<?, ?>) o;\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/main\/java\/com\/sun\/hotspot\/igv\/data\/Pair.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import java.util.Map.Entry;\n@@ -191,1 +190,1 @@\n-        private PropertyMatcher matcher;\n+        private final PropertyMatcher matcher;\n@@ -213,2 +212,2 @@\n-        private String name;\n-        private String value;\n+        private final String name;\n+        private final String value;\n@@ -243,2 +242,2 @@\n-        private String name;\n-        private Pattern valuePattern;\n+        private final String name;\n+        private final Pattern valuePattern;\n@@ -315,7 +314,4 @@\n-        pairs.sort(new Comparator<String[]>() {\n-            @Override\n-            public int compare(String[] o1, String[] o2) {\n-                assert o1.length == 2;\n-                assert o2.length == 2;\n-                return o1[0].compareTo(o2[0]);\n-            }\n+        pairs.sort((o1, o2) -> {\n+            assert o1.length == 2;\n+            assert o2.length == 2;\n+            return o1[0].compareTo(o2[0]);\n@@ -340,1 +336,1 @@\n-        private Collection<T> objects;\n+        private final Collection<T> objects;\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/main\/java\/com\/sun\/hotspot\/igv\/data\/Properties.java","additions":10,"deletions":14,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -35,2 +35,2 @@\n-    private String name;\n-    private String value;\n+    private final String name;\n+    private final String value;\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/main\/java\/com\/sun\/hotspot\/igv\/data\/Property.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -34,2 +34,2 @@\n-    private List<InputNode> sourceNodes;\n-    private Set<Integer> set;\n+    private final List<InputNode> sourceNodes;\n+    private final Set<Integer> set;\n@@ -59,1 +59,1 @@\n-        public Source getSource();\n+        Source getSource();\n@@ -62,5 +62,0 @@\n-    public void addSourceNodes(Source s) {\n-        for (InputNode n : s.getSourceNodes()) {\n-            addSourceNode(n);\n-        }\n-    }\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/main\/java\/com\/sun\/hotspot\/igv\/data\/Source.java","additions":3,"deletions":8,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1,937 +0,0 @@\n-\/*\n- * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package com.sun.hotspot.igv.data.serialization;\n-\n-import com.sun.hotspot.igv.data.*;\n-import com.sun.hotspot.igv.data.Properties;\n-import com.sun.hotspot.igv.data.services.GroupCallback;\n-import java.io.EOFException;\n-import java.io.IOException;\n-import java.nio.ByteBuffer;\n-import java.nio.channels.ReadableByteChannel;\n-import java.util.*;\n-import java.util.regex.Matcher;\n-import java.util.regex.Pattern;\n-import javax.swing.SwingUtilities;\n-import java.security.MessageDigest;\n-import java.security.NoSuchAlgorithmException;\n-\n-import static java.nio.charset.StandardCharsets.UTF_8;\n-\n-public class BinaryParser implements GraphParser {\n-    private static final int BEGIN_GROUP = 0x00;\n-    private static final int BEGIN_GRAPH = 0x01;\n-    private static final int CLOSE_GROUP = 0x02;\n-\n-    private static final int POOL_NEW = 0x00;\n-    private static final int POOL_STRING = 0x01;\n-    private static final int POOL_ENUM = 0x02;\n-    private static final int POOL_CLASS = 0x03;\n-    private static final int POOL_METHOD = 0x04;\n-    private static final int POOL_NULL = 0x05;\n-    private static final int POOL_NODE_CLASS = 0x06;\n-    private static final int POOL_FIELD = 0x07;\n-    private static final int POOL_SIGNATURE = 0x08;\n-\n-    private static final int KLASS = 0x00;\n-    private static final int ENUM_KLASS = 0x01;\n-\n-    private static final int PROPERTY_POOL = 0x00;\n-    private static final int PROPERTY_INT = 0x01;\n-    private static final int PROPERTY_LONG = 0x02;\n-    private static final int PROPERTY_DOUBLE = 0x03;\n-    private static final int PROPERTY_FLOAT = 0x04;\n-    private static final int PROPERTY_TRUE = 0x05;\n-    private static final int PROPERTY_FALSE = 0x06;\n-    private static final int PROPERTY_ARRAY = 0x07;\n-    private static final int PROPERTY_SUBGRAPH = 0x08;\n-\n-    private static final String NO_BLOCK = \"noBlock\";\n-\n-    private final GroupCallback callback;\n-    private final List<Object> constantPool;\n-    private final ByteBuffer buffer;\n-    private final ReadableByteChannel channel;\n-    private final GraphDocument rootDocument;\n-    private final Deque<Folder> folderStack;\n-    private final Deque<byte[]> hashStack;\n-    private final ParseMonitor monitor;\n-\n-    private MessageDigest digest;\n-\n-    private enum Length {\n-        S,\n-        M,\n-        L\n-    }\n-\n-    private interface LengthToString {\n-        String toString(Length l);\n-    }\n-\n-    private abstract static class Member implements LengthToString {\n-        public final Klass holder;\n-        public final int accessFlags;\n-        public final String name;\n-        public Member(Klass holder, String name, int accessFlags) {\n-            this.holder = holder;\n-            this.accessFlags = accessFlags;\n-            this.name = name;\n-        }\n-    }\n-\n-    private static class Method extends Member {\n-        public final Signature signature;\n-        public final byte[] code;\n-        public Method(String name, Signature signature, byte[] code, Klass holder, int accessFlags) {\n-            super(holder, name, accessFlags);\n-            this.signature = signature;\n-            this.code = code;\n-        }\n-        @Override\n-        public String toString() {\n-            StringBuilder sb = new StringBuilder();\n-            sb.append(holder).append('.').append(name).append('(');\n-            for (int i = 0; i < signature.argTypes.length; i++) {\n-                if (i > 0) {\n-                    sb.append(\", \");\n-                }\n-                sb.append(signature.argTypes[i]);\n-            }\n-            sb.append(')');\n-            return sb.toString();\n-        }\n-        @Override\n-        public String toString(Length l) {\n-            switch(l) {\n-                case M:\n-                    return holder.toString(Length.L) + \".\" + name;\n-                case S:\n-                    return holder.toString(Length.S) + \".\" + name;\n-                default:\n-                case L:\n-                    return toString();\n-            }\n-        }\n-    }\n-\n-    private static class Signature {\n-        public final String returnType;\n-        public final String[] argTypes;\n-        public Signature(String returnType, String[] argTypes) {\n-            this.returnType = returnType;\n-            this.argTypes = argTypes;\n-        }\n-    }\n-\n-    private static class Field extends Member {\n-        public final String type;\n-        public Field(String type, Klass holder, String name, int accessFlags) {\n-            super(holder, name, accessFlags);\n-            this.type = type;\n-        }\n-        @Override\n-        public String toString() {\n-            return holder + \".\" + name;\n-        }\n-        @Override\n-        public String toString(Length l) {\n-            switch(l) {\n-                case M:\n-                    return holder.toString(Length.L) + \".\" + name;\n-                case S:\n-                    return holder.toString(Length.S) + \".\" + name;\n-                default:\n-                case L:\n-                    return toString();\n-            }\n-        }\n-    }\n-\n-    private static class Klass implements LengthToString {\n-        public final String name;\n-        public final String simpleName;\n-        public Klass(String name) {\n-            this.name = name;\n-            String simple;\n-            try {\n-                simple = name.substring(name.lastIndexOf('.') + 1);\n-            } catch (IndexOutOfBoundsException ioobe) {\n-                simple = name;\n-            }\n-            this.simpleName = simple;\n-        }\n-        @Override\n-        public String toString() {\n-            return name;\n-        }\n-        @Override\n-        public String toString(Length l) {\n-            switch(l) {\n-                case S:\n-                    return simpleName;\n-                default:\n-                case L:\n-                case M:\n-                    return toString();\n-            }\n-        }\n-    }\n-\n-    private static class EnumKlass extends Klass {\n-        public final String[] values;\n-        public EnumKlass(String name, String[] values) {\n-            super(name);\n-            this.values = values;\n-        }\n-    }\n-\n-    private static class Port {\n-        public final boolean isList;\n-        public final String name;\n-        private Port(boolean isList, String name) {\n-            this.isList = isList;\n-            this.name = name;\n-        }\n-    }\n-\n-    private static class TypedPort extends Port {\n-        public final EnumValue type;\n-        private TypedPort(boolean isList, String name, EnumValue type) {\n-            super(isList, name);\n-            this.type = type;\n-        }\n-    }\n-\n-    private static class NodeClass {\n-        public final String className;\n-        public final String nameTemplate;\n-        public final List<TypedPort> inputs;\n-        public final List<Port> sux;\n-        private NodeClass(String className, String nameTemplate, List<TypedPort> inputs, List<Port> sux) {\n-            this.className = className;\n-            this.nameTemplate = nameTemplate;\n-            this.inputs = inputs;\n-            this.sux = sux;\n-        }\n-        @Override\n-        public String toString() {\n-            return className;\n-        }\n-    }\n-\n-    private static class EnumValue implements LengthToString {\n-        public EnumKlass enumKlass;\n-        public int ordinal;\n-        public EnumValue(EnumKlass enumKlass, int ordinal) {\n-            this.enumKlass = enumKlass;\n-            this.ordinal = ordinal;\n-        }\n-        @Override\n-        public String toString() {\n-            return enumKlass.simpleName + \".\" + enumKlass.values[ordinal];\n-        }\n-        @Override\n-        public String toString(Length l) {\n-            switch(l) {\n-                case S:\n-                    return enumKlass.values[ordinal];\n-                default:\n-                case M:\n-                case L:\n-                    return toString();\n-            }\n-        }\n-    }\n-\n-    public BinaryParser(ReadableByteChannel channel, ParseMonitor monitor, GraphDocument rootDocument, GroupCallback callback) {\n-        this.callback = callback;\n-        constantPool = new ArrayList<>();\n-        buffer = ByteBuffer.allocateDirect(256 * 1024);\n-        buffer.flip();\n-        this.channel = channel;\n-        this.rootDocument = rootDocument;\n-        folderStack = new LinkedList<>();\n-        hashStack = new LinkedList<>();\n-        this.monitor = monitor;\n-        try {\n-            this.digest = MessageDigest.getInstance(\"SHA-1\");\n-        } catch (NoSuchAlgorithmException e) {\n-        }\n-    }\n-\n-    private void fill() throws IOException {\n-        \/\/ All the data between lastPosition and position has been\n-        \/\/ used so add it to the digest.\n-        int position = buffer.position();\n-        buffer.position(lastPosition);\n-        byte[] remaining = new byte[position - buffer.position()];\n-        buffer.get(remaining);\n-        digest.update(remaining);\n-        assert position == buffer.position();\n-\n-        buffer.compact();\n-        if (channel.read(buffer) < 0) {\n-            throw new EOFException();\n-        }\n-        buffer.flip();\n-        lastPosition = buffer.position();\n-    }\n-\n-    private void ensureAvailable(int i) throws IOException {\n-        if (i > buffer.capacity()) {\n-            throw new IllegalArgumentException(String.format(\"Can not request %d bytes: buffer capacity is %d\", i, buffer.capacity()));\n-        }\n-        while (buffer.remaining() < i) {\n-            fill();\n-        }\n-    }\n-\n-    private int readByte() throws IOException {\n-        ensureAvailable(1);\n-        return ((int)buffer.get()) & 0xff;\n-    }\n-\n-    private int readInt() throws IOException {\n-        ensureAvailable(4);\n-        return buffer.getInt();\n-    }\n-\n-    private char readShort() throws IOException {\n-        ensureAvailable(2);\n-        return buffer.getChar();\n-    }\n-\n-    private long readLong() throws IOException {\n-        ensureAvailable(8);\n-        return buffer.getLong();\n-    }\n-\n-    private double readDouble() throws IOException {\n-        ensureAvailable(8);\n-        return buffer.getDouble();\n-    }\n-\n-    private float readFloat() throws IOException {\n-        ensureAvailable(4);\n-        return buffer.getFloat();\n-    }\n-\n-    private String readString() throws IOException {\n-        return new String(readBytes(), UTF_8).intern();\n-    }\n-\n-    private byte[] readBytes() throws IOException {\n-        int len = readInt();\n-        if (len < 0) {\n-            return null;\n-        }\n-        byte[] b = new byte[len];\n-        int bytesRead = 0;\n-        while (bytesRead < b.length) {\n-            int toRead = Math.min(b.length - bytesRead, buffer.capacity());\n-            ensureAvailable(toRead);\n-            buffer.get(b, bytesRead, toRead);\n-            bytesRead += toRead;\n-        }\n-        return b;\n-    }\n-\n-    private String readIntsToString() throws IOException {\n-        int len = readInt();\n-        if (len < 0) {\n-            return \"null\";\n-        }\n-        ensureAvailable(len * 4);\n-        StringBuilder sb = new StringBuilder().append('[');\n-        for (int i = 0; i < len; i++) {\n-            sb.append(buffer.getInt());\n-            if (i < len - 1) {\n-                sb.append(\", \");\n-            }\n-        }\n-        sb.append(']');\n-        return sb.toString().intern();\n-    }\n-\n-    private String readDoublesToString() throws IOException {\n-        int len = readInt();\n-        if (len < 0) {\n-            return \"null\";\n-        }\n-        ensureAvailable(len * 8);\n-        StringBuilder sb = new StringBuilder().append('[');\n-        for (int i = 0; i < len; i++) {\n-            sb.append(buffer.getDouble());\n-            if (i < len - 1) {\n-                sb.append(\", \");\n-            }\n-        }\n-        sb.append(']');\n-        return sb.toString().intern();\n-    }\n-\n-    private String readPoolObjectsToString() throws IOException {\n-        int len = readInt();\n-        if (len < 0) {\n-            return \"null\";\n-        }\n-        StringBuilder sb = new StringBuilder().append('[');\n-        for (int i = 0; i < len; i++) {\n-            sb.append(readPoolObject(Object.class));\n-            if (i < len - 1) {\n-                sb.append(\", \");\n-            }\n-        }\n-        sb.append(']');\n-        return sb.toString().intern();\n-    }\n-\n-    private <T> T readPoolObject(Class<T> klass) throws IOException {\n-        int type = readByte();\n-        if (type == POOL_NULL) {\n-            return null;\n-        }\n-        if (type == POOL_NEW) {\n-            return (T) addPoolEntry(klass);\n-        }\n-        assert assertObjectType(klass, type);\n-        char index = readShort();\n-        if (index < 0 || index >= constantPool.size()) {\n-            throw new IOException(\"Invalid constant pool index : \" + index);\n-        }\n-        Object obj = constantPool.get(index);\n-        return (T) obj;\n-    }\n-\n-    private boolean assertObjectType(Class<?> klass, int type) {\n-        switch(type) {\n-            case POOL_CLASS:\n-                return klass.isAssignableFrom(EnumKlass.class);\n-            case POOL_ENUM:\n-                return klass.isAssignableFrom(EnumValue.class);\n-            case POOL_METHOD:\n-                return klass.isAssignableFrom(Method.class);\n-            case POOL_STRING:\n-                return klass.isAssignableFrom(String.class);\n-            case POOL_NODE_CLASS:\n-                return klass.isAssignableFrom(NodeClass.class);\n-            case POOL_FIELD:\n-                return klass.isAssignableFrom(Field.class);\n-            case POOL_SIGNATURE:\n-                return klass.isAssignableFrom(Signature.class);\n-            case POOL_NULL:\n-                return true;\n-            default:\n-                return false;\n-        }\n-    }\n-\n-    private Object addPoolEntry(Class<?> klass) throws IOException {\n-        char index = readShort();\n-        int type = readByte();\n-        assert assertObjectType(klass, type) : \"Wrong object type : \" + klass + \" != \" + type;\n-        Object obj;\n-        switch(type) {\n-            case POOL_CLASS: {\n-                String name = readString();\n-                int klasstype = readByte();\n-                if (klasstype == ENUM_KLASS) {\n-                    int len = readInt();\n-                    String[] values = new String[len];\n-                    for (int i = 0; i < len; i++) {\n-                        values[i] = readPoolObject(String.class);\n-                    }\n-                    obj = new EnumKlass(name, values);\n-                } else if (klasstype == KLASS) {\n-                    obj = new Klass(name);\n-                } else {\n-                    throw new IOException(\"unknown klass type : \" + klasstype);\n-                }\n-                break;\n-            }\n-            case POOL_ENUM: {\n-                EnumKlass enumClass = readPoolObject(EnumKlass.class);\n-                int ordinal = readInt();\n-                obj = new EnumValue(enumClass, ordinal);\n-                break;\n-            }\n-            case POOL_NODE_CLASS: {\n-                String className = readString();\n-                String nameTemplate = readString();\n-                int inputCount = readShort();\n-                List<TypedPort> inputs = new ArrayList<>(inputCount);\n-                for (int i = 0; i < inputCount; i++) {\n-                    boolean isList = readByte() != 0;\n-                    String name = readPoolObject(String.class);\n-                    EnumValue inputType = readPoolObject(EnumValue.class);\n-                    inputs.add(new TypedPort(isList, name, inputType));\n-                }\n-                int suxCount = readShort();\n-                List<Port> sux = new ArrayList<>(suxCount);\n-                for (int i = 0; i < suxCount; i++) {\n-                    boolean isList = readByte() != 0;\n-                    String name = readPoolObject(String.class);\n-                    sux.add(new Port(isList, name));\n-                }\n-                obj = new NodeClass(className, nameTemplate, inputs, sux);\n-                break;\n-            }\n-            case POOL_METHOD: {\n-                Klass holder = readPoolObject(Klass.class);\n-                String name = readPoolObject(String.class);\n-                Signature sign = readPoolObject(Signature.class);\n-                int flags = readInt();\n-                byte[] code = readBytes();\n-                obj = new Method(name, sign, code, holder, flags);\n-                break;\n-            }\n-            case POOL_FIELD: {\n-                Klass holder = readPoolObject(Klass.class);\n-                String name = readPoolObject(String.class);\n-                String fType = readPoolObject(String.class);\n-                int flags = readInt();\n-                obj = new Field(fType, holder, name, flags);\n-                break;\n-            }\n-            case POOL_SIGNATURE: {\n-                int argc = readShort();\n-                String[] args = new String[argc];\n-                for (int i = 0; i < argc; i++) {\n-                    args[i] = readPoolObject(String.class);\n-                }\n-                String returnType = readPoolObject(String.class);\n-                obj = new Signature(returnType, args);\n-                break;\n-            }\n-            case POOL_STRING: {\n-                obj = readString();\n-                break;\n-            }\n-            default:\n-                throw new IOException(\"unknown pool type\");\n-        }\n-        while (constantPool.size() <= index) {\n-            constantPool.add(null);\n-        }\n-        constantPool.set(index, obj);\n-        return obj;\n-    }\n-\n-    private Object readPropertyObject() throws IOException {\n-        int type = readByte();\n-        switch (type) {\n-            case PROPERTY_INT:\n-                return readInt();\n-            case PROPERTY_LONG:\n-                return readLong();\n-            case PROPERTY_FLOAT:\n-                return readFloat();\n-            case PROPERTY_DOUBLE:\n-                return readDouble();\n-            case PROPERTY_TRUE:\n-                return Boolean.TRUE;\n-            case PROPERTY_FALSE:\n-                return Boolean.FALSE;\n-            case PROPERTY_POOL:\n-                return readPoolObject(Object.class);\n-            case PROPERTY_ARRAY:\n-                int subType = readByte();\n-                switch(subType) {\n-                    case PROPERTY_INT:\n-                        return readIntsToString();\n-                    case PROPERTY_DOUBLE:\n-                        return readDoublesToString();\n-                    case PROPERTY_POOL:\n-                        return readPoolObjectsToString();\n-                    default:\n-                        throw new IOException(\"Unknown type\");\n-                }\n-            case PROPERTY_SUBGRAPH:\n-                InputGraph graph = parseGraph(\"\");\n-                new Group(null).addElement(graph);\n-                return graph;\n-            default:\n-                throw new IOException(\"Unknown type\");\n-        }\n-    }\n-\n-    @Override\n-    public GraphDocument parse() throws IOException {\n-        folderStack.push(rootDocument);\n-        hashStack.push(null);\n-        if (monitor != null) {\n-            monitor.setState(\"Starting parsing\");\n-        }\n-        try {\n-            while(true) {\n-                parseRoot();\n-            }\n-        } catch (EOFException e) {\n-\n-        }\n-        if (monitor != null) {\n-            monitor.setState(\"Finished parsing\");\n-        }\n-        return rootDocument;\n-    }\n-\n-    private void parseRoot() throws IOException {\n-        int type = readByte();\n-        switch(type) {\n-            case BEGIN_GRAPH: {\n-                final Folder parent = folderStack.peek();\n-                final InputGraph graph = parseGraph();\n-                SwingUtilities.invokeLater(new Runnable(){\n-                    @Override\n-                    public void run() {\n-                        parent.addElement(graph);\n-                    }\n-                });\n-                break;\n-            }\n-            case BEGIN_GROUP: {\n-                final Folder parent = folderStack.peek();\n-                final Group group = parseGroup(parent);\n-                if (callback == null || parent instanceof Group) {\n-                    SwingUtilities.invokeLater(new Runnable(){\n-                        @Override\n-                        public void run() {\n-                            parent.addElement(group);\n-                        }\n-                    });\n-                }\n-                folderStack.push(group);\n-                hashStack.push(null);\n-                if (callback != null && parent instanceof GraphDocument) {\n-                    callback.started(group);\n-                }\n-                break;\n-            }\n-            case CLOSE_GROUP: {\n-                if (folderStack.isEmpty()) {\n-                    throw new IOException(\"Unbalanced groups\");\n-                }\n-                folderStack.pop();\n-                hashStack.pop();\n-                break;\n-            }\n-            default:\n-                throw new IOException(\"unknown root : \" + type);\n-        }\n-    }\n-\n-    private Group parseGroup(Folder parent) throws IOException {\n-        String name = readPoolObject(String.class);\n-        String shortName = readPoolObject(String.class);\n-        if (monitor != null) {\n-            monitor.setState(shortName);\n-        }\n-        Method method = readPoolObject(Method.class);\n-        int bci = readInt();\n-        Group group = new Group(parent);\n-        group.getProperties().setProperty(\"name\", name);\n-        parseProperties(group.getProperties());\n-        if (method != null) {\n-            InputMethod inMethod = new InputMethod(group, method.name, shortName, bci);\n-            inMethod.setBytecodes(\"TODO\");\n-            group.setMethod(inMethod);\n-        }\n-        return group;\n-    }\n-\n-    int lastPosition = 0;\n-\n-    private InputGraph parseGraph() throws IOException {\n-        if (monitor != null) {\n-            monitor.updateProgress();\n-        }\n-        String title = readPoolObject(String.class);\n-        digest.reset();\n-        lastPosition = buffer.position();\n-        InputGraph graph = parseGraph(title);\n-\n-        int position = buffer.position();\n-        buffer.position(lastPosition);\n-        byte[] remaining = new byte[position - buffer.position()];\n-        buffer.get(remaining);\n-        digest.update(remaining);\n-        assert position == buffer.position();\n-        lastPosition = buffer.position();\n-\n-        byte[] d = digest.digest();\n-        byte[] hash = hashStack.peek();\n-        if (hash != null && Arrays.equals(hash, d)) {\n-            graph.getProperties().setProperty(\"_isDuplicate\", \"true\");\n-        } else {\n-            hashStack.pop();\n-            hashStack.push(d);\n-        }\n-        return graph;\n-    }\n-\n-    private void parseProperties(Properties properties) throws IOException {\n-        int propCount = readShort();\n-        for (int j = 0; j < propCount; j++) {\n-            String key = readPoolObject(String.class);\n-            Object value = readPropertyObject();\n-            properties.setProperty(key, value != null ? value.toString() : \"null\");\n-        }\n-    }\n-\n-    private InputGraph parseGraph(String title) throws IOException {\n-        InputGraph graph = new InputGraph(title);\n-        parseProperties(graph.getProperties());\n-        parseNodes(graph);\n-        parseBlocks(graph);\n-        graph.ensureNodesInBlocks();\n-        for (InputNode node : graph.getNodes()) {\n-            node.internProperties();\n-        }\n-        return graph;\n-    }\n-\n-    private void parseBlocks(InputGraph graph) throws IOException {\n-        int blockCount = readInt();\n-        List<Edge> edges = new LinkedList<>();\n-        for (int i = 0; i < blockCount; i++) {\n-            int id = readInt();\n-            String name = id >= 0 ? Integer.toString(id) : NO_BLOCK;\n-            InputBlock block = graph.addBlock(name);\n-            int nodeCount = readInt();\n-            for (int j = 0; j < nodeCount; j++) {\n-                int nodeId = readInt();\n-                if (nodeId < 0) {\n-                    continue;\n-                }\n-                final Properties properties = graph.getNode(nodeId).getProperties();\n-                final String oldBlock = properties.get(\"block\");\n-                if(oldBlock != null) {\n-                    properties.setProperty(\"block\", oldBlock + \", \" + name);\n-                } else {\n-                    block.addNode(nodeId);\n-                    properties.setProperty(\"block\", name);\n-                }\n-            }\n-            int edgeCount = readInt();\n-            for (int j = 0; j < edgeCount; j++) {\n-                int to = readInt();\n-                edges.add(new Edge(id, to));\n-            }\n-        }\n-        for (Edge e : edges) {\n-            String fromName = e.from >= 0 ? Integer.toString(e.from) : NO_BLOCK;\n-            String toName = e.to >= 0 ? Integer.toString(e.to) : NO_BLOCK;\n-            graph.addBlockEdge(graph.getBlock(fromName), graph.getBlock(toName));\n-        }\n-    }\n-\n-    private void parseNodes(InputGraph graph) throws IOException {\n-        int count = readInt();\n-        Map<String, Object> props = new HashMap<>();\n-        List<Edge> inputEdges = new ArrayList<>(count);\n-        List<Edge> succEdges = new ArrayList<>(count);\n-        for (int i = 0; i < count; i++) {\n-            int id = readInt();\n-            InputNode node = new InputNode(id);\n-            final Properties properties = node.getProperties();\n-            NodeClass nodeClass = readPoolObject(NodeClass.class);\n-            int preds = readByte();\n-            if (preds > 0) {\n-                properties.setProperty(\"hasPredecessor\", \"true\");\n-            }\n-            properties.setProperty(\"idx\", Integer.toString(id));\n-            int propCount = readShort();\n-            for (int j = 0; j < propCount; j++) {\n-                String key = readPoolObject(String.class);\n-                if (key.equals(\"hasPredecessor\") || key.equals(\"name\") || key.equals(\"class\") || key.equals(\"id\") || key.equals(\"idx\")) {\n-                    key = \"!data.\" + key;\n-                }\n-                Object value = readPropertyObject();\n-                if (value instanceof InputGraph) {\n-                    InputGraph subgraph = (InputGraph) value;\n-                    subgraph.getProperties().setProperty(\"name\", node.getId() + \":\" + key);\n-                    node.addSubgraph((InputGraph) value);\n-                } else {\n-                    properties.setProperty(key, value != null ? value.toString() : \"null\");\n-                    props.put(key, value);\n-                }\n-            }\n-            ArrayList<Edge> currentEdges = new ArrayList<>();\n-            int portNum = 0;\n-            for (TypedPort p : nodeClass.inputs) {\n-                if (p.isList) {\n-                    int size = readShort();\n-                    for (int j = 0; j < size; j++) {\n-                        int in = readInt();\n-                        if (in >= 0) {\n-                            Edge e = new Edge(in, id, (char) (preds + portNum), p.name + \"[\" + j + \"]\", p.type.toString(Length.S), true);\n-                            currentEdges.add(e);\n-                            inputEdges.add(e);\n-                            portNum++;\n-                        }\n-                    }\n-                } else {\n-                    int in = readInt();\n-                    if (in >= 0) {\n-                        Edge e = new Edge(in, id, (char) (preds + portNum), p.name, p.type.toString(Length.S), true);\n-                        currentEdges.add(e);\n-                        inputEdges.add(e);\n-                        portNum++;\n-                    }\n-                }\n-\n-            }\n-            portNum = 0;\n-            for (Port p : nodeClass.sux) {\n-                if (p.isList) {\n-                    int size = readShort();\n-                    for (int j = 0; j < size; j++) {\n-                        int sux = readInt();\n-                        if (sux >= 0) {\n-                            Edge e = new Edge(id, sux, (char) portNum, p.name + \"[\" + j + \"]\", \"Successor\", false);\n-                            currentEdges.add(e);\n-                            succEdges.add(e);\n-                            portNum++;\n-                        }\n-                    }\n-                } else {\n-                    int sux = readInt();\n-                    if (sux >= 0) {\n-                        Edge e = new Edge(id, sux, (char) portNum, p.name, \"Successor\", false);\n-                        currentEdges.add(e);\n-                        succEdges.add(e);\n-                        portNum++;\n-                    }\n-                }\n-            }\n-            properties.setProperty(\"name\", createName(currentEdges, props, nodeClass.nameTemplate));\n-            properties.setProperty(\"class\", nodeClass.className);\n-            switch (nodeClass.className) {\n-                case \"BeginNode\":\n-                    properties.setProperty(\"shortName\", \"B\");\n-                    break;\n-                case \"EndNode\":\n-                    properties.setProperty(\"shortName\", \"E\");\n-                    break;\n-            }\n-            graph.addNode(node);\n-            props.clear();\n-        }\n-\n-        Set<InputNode> nodesWithSuccessor = new HashSet<>();\n-\n-        for (Edge e : succEdges) {\n-            assert !e.input;\n-            char fromIndex = e.num;\n-            nodesWithSuccessor.add(graph.getNode(e.from));\n-            char toIndex = 0;\n-            graph.addEdge(InputEdge.createImmutable(fromIndex, toIndex, e.from, e.to, e.label, e.type));\n-        }\n-        for (Edge e : inputEdges) {\n-            assert e.input;\n-            char fromIndex = (char) (nodesWithSuccessor.contains(graph.getNode(e.from)) ? 1 : 0);\n-            char toIndex = e.num;\n-            graph.addEdge(InputEdge.createImmutable(fromIndex, toIndex, e.from, e.to, e.label, e.type));\n-        }\n-    }\n-\n-    static final Pattern templatePattern = Pattern.compile(\"\\\\{(p|i)#([a-zA-Z0-9$_]+)(\/(l|m|s))?\\\\}\");\n-\n-    private String createName(List<Edge> edges, Map<String, Object> properties, String template) {\n-        Matcher m = templatePattern.matcher(template);\n-        StringBuffer sb = new StringBuffer();\n-        while (m.find()) {\n-            String name = m.group(2);\n-            String type = m.group(1);\n-            String result;\n-            switch (type) {\n-                case \"i\":\n-                    StringBuilder inputString = new StringBuilder();\n-                    for(Edge edge : edges) {\n-                        if (edge.label.startsWith(name) && (name.length() == edge.label.length() || edge.label.charAt(name.length()) == '[')) {\n-                            if (inputString.length() > 0) {\n-                                inputString.append(\", \");\n-                            }\n-                            inputString.append(edge.from);\n-                        }\n-                    }\n-                    result = inputString.toString();\n-                    break;\n-                case \"p\":\n-                    Object prop = properties.get(name);\n-                    String length = m.group(4);\n-                    if (prop == null) {\n-                        result = \"?\";\n-                    } else if (length != null && prop instanceof LengthToString) {\n-                        LengthToString lengthProp = (LengthToString) prop;\n-                        switch(length) {\n-                            default:\n-                            case \"l\":\n-                                result = lengthProp.toString(Length.L);\n-                                break;\n-                            case \"m\":\n-                                result = lengthProp.toString(Length.M);\n-                                break;\n-                            case \"s\":\n-                                result = lengthProp.toString(Length.S);\n-                                break;\n-                        }\n-                    } else {\n-                        result = prop.toString();\n-                    }\n-                    break;\n-                default:\n-                    result = \"#?#\";\n-                    break;\n-            }\n-            result = result.replace(\"\\\\\", \"\\\\\\\\\");\n-            result = result.replace(\"$\", \"\\\\$\");\n-            m.appendReplacement(sb, result);\n-        }\n-        m.appendTail(sb);\n-        return sb.toString().intern();\n-    }\n-\n-    private static class Edge {\n-        final int from;\n-        final int to;\n-        final char num;\n-        final String label;\n-        final String type;\n-        final boolean input;\n-        public Edge(int from, int to) {\n-            this(from, to, (char) 0, null, null, false);\n-        }\n-        public Edge(int from, int to, char num, String label, String type, boolean input) {\n-            this.from = from;\n-            this.to = to;\n-            this.label = label != null ? label.intern() : label;\n-            this.type = type != null ? type.intern() : type;\n-            this.num = num;\n-            this.input = input;\n-        }\n-    }\n-}\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/main\/java\/com\/sun\/hotspot\/igv\/data\/serialization\/BinaryParser.java","additions":0,"deletions":937,"binary":false,"changes":937,"status":"deleted"},{"patch":"@@ -31,1 +31,1 @@\n-    public GraphDocument parse() throws IOException;\n+    GraphDocument parse() throws IOException;\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/main\/java\/com\/sun\/hotspot\/igv\/data\/serialization\/GraphParser.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-    public void updateProgress();\n+    void updateProgress();\n@@ -31,1 +31,1 @@\n-    public void setState(String state);\n+    void setState(String state);\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/main\/java\/com\/sun\/hotspot\/igv\/data\/serialization\/ParseMonitor.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import java.io.InputStream;\n@@ -42,3 +41,0 @@\n-import javax.xml.transform.Source;\n-import javax.xml.transform.stream.StreamSource;\n-import javax.xml.validation.SchemaFactory;\n@@ -56,1 +52,0 @@\n-    public static final String INDENT = \"  \";\n@@ -70,6 +65,0 @@\n-    public static final String GROUP_NAME_PROPERTY = \"name\";\n-    public static final String METHOD_IS_PUBLIC_PROPERTY = \"public\";\n-    public static final String METHOD_IS_STATIC_PROPERTY = \"static\";\n-    public static final String TRUE_VALUE = \"true\";\n-    public static final String NODE_NAME_PROPERTY = \"name\";\n-    public static final String EDGE_NAME_PROPERTY = \"name\";\n@@ -96,1 +85,0 @@\n-    public static final String ASSEMBLY_ELEMENT = \"assembly\";\n@@ -98,6 +86,6 @@\n-    private TopElementHandler<GraphDocument> xmlDocument = new TopElementHandler<>();\n-    private Map<Group, Boolean> differenceEncoding = new HashMap<>();\n-    private Map<Group, InputGraph> lastParsedGraph = new HashMap<>();\n-    private GroupCallback groupCallback;\n-    private HashMap<String, Integer> idCache = new HashMap<>();\n-    private ArrayList<Pair<String, String>> blockConnections = new ArrayList<>();\n+    private final TopElementHandler<GraphDocument> xmlDocument = new TopElementHandler<>();\n+    private final Map<Group, Boolean> differenceEncoding = new HashMap<>();\n+    private final Map<Group, InputGraph> lastParsedGraph = new HashMap<>();\n+    private final GroupCallback groupCallback;\n+    private final HashMap<String, Integer> idCache = new HashMap<>();\n+    private final ArrayList<Pair<String, String>> blockConnections = new ArrayList<>();\n@@ -121,1 +109,1 @@\n-        return id.intValue();\n+        return id;\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/main\/java\/com\/sun\/hotspot\/igv\/data\/serialization\/Parser.java","additions":7,"deletions":19,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-    private InputStream in;\n+    private final InputStream in;\n@@ -55,2 +55,1 @@\n-        } catch (IOException ex) {\n-        }\n+        } catch (IOException ignored) {}\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/main\/java\/com\/sun\/hotspot\/igv\/data\/serialization\/Printer.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-import com.sun.hotspot.igv.data.Properties;\n@@ -42,2 +41,0 @@\n-        private String name;\n-\n@@ -46,1 +43,0 @@\n-            this.name = name;\n@@ -49,3 +45,0 @@\n-        public String getAttributeName() {\n-            return this.getMessage();\n-        }\n@@ -79,2 +72,2 @@\n-        private String name;\n-        private Stack<T> object = new Stack<>();\n+        private final String name;\n+        private final Stack<T> object = new Stack<>();\n@@ -84,4 +77,4 @@\n-        private HashMap<String, ElementHandler<?, ? super T>> hashtable;\n-        private boolean needsText;\n-        private Stack<ElementHandler<P, ?>> parentElement = new Stack<>();\n-        private Stack<P> parentObject = new Stack<>();\n+        private final HashMap<String, ElementHandler<?, ? super T>> hashtable;\n+        private final boolean needsText;\n+        private final Stack<ElementHandler<P, ?>> parentElement = new Stack<>();\n+        private final Stack<P> parentObject = new Stack<>();\n@@ -93,4 +86,0 @@\n-        public ElementHandler<P, ?> getParentElement() {\n-            return parentElement.peek();\n-        }\n-\n@@ -144,9 +133,0 @@\n-        public void processAttributesAsProperties(Properties p) {\n-            int length = attr.getLength();\n-            for (int i = 0; i < length; i++) {\n-                String val = attr.getValue(i);\n-                String localName = attr.getLocalName(i);\n-                p.setProperty(val, localName);\n-            }\n-        }\n-\n@@ -182,2 +162,2 @@\n-    private Stack<ElementHandler> stack;\n-    private ParseMonitor monitor;\n+    private final Stack<ElementHandler> stack;\n+    private final ParseMonitor monitor;\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/main\/java\/com\/sun\/hotspot\/igv\/data\/serialization\/XMLParser.java","additions":8,"deletions":28,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -39,2 +39,2 @@\n-    private Writer inner;\n-    private Stack<String> elementStack;\n+    private final Writer inner;\n+    private final Stack<String> elementStack;\n@@ -117,1 +117,1 @@\n-        if (props.iterator().hasNext() == false) {\n+        if (!props.iterator().hasNext()) {\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/main\/java\/com\/sun\/hotspot\/igv\/data\/serialization\/XMLWriter.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import static org.junit.Assert.assertEquals;\n@@ -29,0 +28,1 @@\n+import static org.junit.Assert.assertEquals;\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/test\/java\/com\/sun\/hotspot\/igv\/data\/ChangedEventTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import static org.junit.Assert.*;\n@@ -29,0 +28,1 @@\n+import static org.junit.Assert.*;\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/test\/java\/com\/sun\/hotspot\/igv\/data\/ControllableChangedListenerTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import static org.junit.Assert.assertEquals;\n@@ -31,0 +30,1 @@\n+import static org.junit.Assert.assertEquals;\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/test\/java\/com\/sun\/hotspot\/igv\/data\/GroupTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,5 +27,0 @@\n-import java.util.Arrays;\n-import java.util.List;\n-import java.util.Map;\n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertTrue;\n@@ -126,85 +121,0 @@\n-\n-    \/**\n-     * Test of findRootNodes method, of class InputGraph.\n-     *\/\n-    @Test\n-    public void testFindRootNodes() {\n-        assertTrue(emptyGraph.findRootNodes().isEmpty());\n-\n-        List<InputNode> result = referenceGraph.findRootNodes();\n-        assertTrue(result.size() == 2);\n-        assertTrue(result.contains(N1));\n-        assertTrue(result.contains(N5));\n-    }\n-\n-    \/**\n-     * Test of findAllOutgoingEdges method, of class InputGraph.\n-     *\/\n-    @Test\n-    public void testFindAllOutgoingEdges() {\n-        assertTrue(emptyGraph.findAllOutgoingEdges().isEmpty());\n-\n-        Map<InputNode, List<InputEdge>> result = referenceGraph.findAllOutgoingEdges();\n-        assertTrue(result.size() == 5);\n-        assertEquals(result.get(N1), Arrays.asList(E12, E13));\n-        assertEquals(result.get(N2), Arrays.asList(E24));\n-        assertEquals(result.get(N3), Arrays.asList(E34));\n-        assertEquals(result.get(N4), Arrays.asList());\n-        assertEquals(result.get(N5), Arrays.asList(E54));\n-    }\n-\n-    \/**\n-     * Test of findAllIngoingEdges method, of class InputGraph.\n-     *\/\n-    @Test\n-    public void testFindAllIngoingEdges() {\n-        assertTrue(emptyGraph.findAllIngoingEdges().isEmpty());\n-\n-        Map<InputNode, List<InputEdge>> result = referenceGraph.findAllIngoingEdges();\n-        assertTrue(result.size() == 5);\n-        assertEquals(result.get(N1), Arrays.asList());\n-        assertEquals(result.get(N2), Arrays.asList(E12));\n-        assertEquals(result.get(N3), Arrays.asList(E13));\n-        assertEquals(result.get(N4), Arrays.asList(E24, E34, E54));\n-        assertEquals(result.get(N5), Arrays.asList());\n-    }\n-\n-    \/**\n-     * Test of findOutgoingEdges method, of class InputGraph.\n-     *\/\n-    @Test\n-    public void testFindOutgoingEdges() {\n-        assertTrue(emptyGraph.findOutgoingEdges(new InputNode(1)).isEmpty());\n-\n-        assertEquals(referenceGraph.findOutgoingEdges(N1), Arrays.asList(E12, E13));\n-        assertEquals(referenceGraph.findOutgoingEdges(N2), Arrays.asList(E24));\n-        assertEquals(referenceGraph.findOutgoingEdges(N3), Arrays.asList(E34));\n-        assertEquals(referenceGraph.findOutgoingEdges(N4), Arrays.asList());\n-        assertEquals(referenceGraph.findOutgoingEdges(N5), Arrays.asList(E54));\n-    }\n-\n-    \/**\n-     * Test of getNext method, of class InputGraph.\n-     *\/\n-    @Test\n-    public void testGetNextPrev() {\n-        final Group group = new Group(null);\n-\n-        final InputGraph a = new InputGraph(\"a\");\n-\n-        final InputGraph b = new InputGraph(\"b\");\n-\n-        final InputGraph c = new InputGraph(\"c\");\n-        group.addElement(a);\n-        group.addElement(b);\n-        group.addElement(c);\n-\n-        assertEquals(null, a.getPrev());\n-        assertEquals(b, a.getNext());\n-\n-        assertEquals(a, b.getPrev());\n-        assertEquals(c, b.getNext());\n-\n-        assertEquals(b, c.getPrev());\n-        assertEquals(null, c.getNext());\n-    }\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/test\/java\/com\/sun\/hotspot\/igv\/data\/InputGraphTest.java","additions":0,"deletions":90,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import static org.junit.Assert.assertThat;\n@@ -31,0 +30,1 @@\n+import static org.junit.Assert.assertThat;\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/test\/java\/com\/sun\/hotspot\/igv\/data\/InputMethodTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import static org.junit.Assert.*;\n@@ -30,0 +29,1 @@\n+import static org.junit.Assert.*;\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/test\/java\/com\/sun\/hotspot\/igv\/data\/PairTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,5 +28,1 @@\n-import com.sun.hotspot.igv.data.Properties.InvertPropertyMatcher;\n-import com.sun.hotspot.igv.data.Properties.PropertyMatcher;\n-import com.sun.hotspot.igv.data.Properties.PropertySelector;\n-import com.sun.hotspot.igv.data.Properties.RegexpPropertyMatcher;\n-import com.sun.hotspot.igv.data.Properties.StringPropertyMatcher;\n+import com.sun.hotspot.igv.data.Properties.*;\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/test\/java\/com\/sun\/hotspot\/igv\/data\/PropertiesTest.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import static org.junit.Assert.*;\n@@ -30,0 +29,1 @@\n+import static org.junit.Assert.*;\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/test\/java\/com\/sun\/hotspot\/igv\/data\/PropertyTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import static org.junit.Assert.assertEquals;\n@@ -31,0 +30,1 @@\n+import static org.junit.Assert.assertEquals;\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/test\/java\/com\/sun\/hotspot\/igv\/data\/SourceTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,2 @@\n-import static org.junit.Assert.*;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.fail;\n@@ -36,10 +37,0 @@\n-    public static void assertGraphDocumentNotEquals(GraphDocument a, GraphDocument b) {\n-        try {\n-            assertGraphDocumentEquals(a, b);\n-        } catch(AssertionError e) {\n-            return;\n-        }\n-\n-        fail(\"Graphs documents are equal!\");\n-    }\n-\n@@ -64,10 +55,0 @@\n-    public static void assertGroupNotEquals(Group a, Group b) {\n-        try {\n-            assertGroupEquals(a, b);\n-        } catch(AssertionError e) {\n-            return;\n-        }\n-\n-        fail(\"Groups are equal!\");\n-    }\n-\n@@ -76,1 +57,1 @@\n-        if (a.getGraphsCount() != b.getGraphsCount()) {\n+        if (a.getGraphs().size() != b.getGraphs().size()) {\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/test\/java\/com\/sun\/hotspot\/igv\/data\/Util.java","additions":3,"deletions":22,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -29,1 +29,4 @@\n-import java.io.*;\n+import java.io.ByteArrayInputStream;\n+import java.io.CharArrayWriter;\n+import java.io.IOException;\n+import java.io.InputStream;\n@@ -31,1 +34,0 @@\n-\n@@ -33,0 +35,1 @@\n+import org.junit.*;\n@@ -35,3 +38,0 @@\n-import org.junit.*;\n-import org.openide.util.Exceptions;\n-import org.xml.sax.InputSource;\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/test\/java\/com\/sun\/hotspot\/igv\/data\/serialization\/ParserTest.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -290,3 +290,0 @@\n-\n-        Set<InputNode> matched = new HashSet<>();\n-\n","filename":"src\/utils\/IdealGraphVisualizer\/Difference\/src\/main\/java\/com\/sun\/hotspot\/igv\/difference\/Difference.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-        changedEvent = new ChangedEvent<Filter>(this);\n+        changedEvent = new ChangedEvent<>(this);\n","filename":"src\/utils\/IdealGraphVisualizer\/Filter\/src\/main\/java\/com\/sun\/hotspot\/igv\/filter\/AbstractFilter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import com.sun.hotspot.igv.graph.Connection.ConnectionStyle;\n@@ -29,0 +28,1 @@\n+import com.sun.hotspot.igv.graph.Connection.ConnectionStyle;\n","filename":"src\/utils\/IdealGraphVisualizer\/Filter\/src\/main\/java\/com\/sun\/hotspot\/igv\/filter\/ColorFilter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -77,1 +77,1 @@\n-                        slot.getSource().addSourceNodes(f.getSource());\n+                        slot.getSource().addSourceNode(f.getInputNode());\n@@ -133,1 +133,1 @@\n-                                slot.getSource().addSourceNodes(succ.getSource());\n+                                slot.getSource().addSourceNode(succ.getInputNode());\n","filename":"src\/utils\/IdealGraphVisualizer\/Filter\/src\/main\/java\/com\/sun\/hotspot\/igv\/filter\/CombineFilter.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,1 +28,4 @@\n-import javax.script.*;\n+import javax.script.Bindings;\n+import javax.script.ScriptContext;\n+import javax.script.ScriptEngine;\n+import javax.script.ScriptException;\n","filename":"src\/utils\/IdealGraphVisualizer\/Filter\/src\/main\/java\/com\/sun\/hotspot\/igv\/filter\/CustomFilter.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-import com.sun.hotspot.igv.graph.Diagram;\n@@ -29,0 +28,1 @@\n+import com.sun.hotspot.igv.graph.Diagram;\n","filename":"src\/utils\/IdealGraphVisualizer\/Filter\/src\/main\/java\/com\/sun\/hotspot\/igv\/filter\/RemoveBlockFilter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -59,3 +59,3 @@\n-                    if (f.getSource().getSourceNodes().size() > 0) {\n-                        os.getSource().addSourceNodes(f.getSource());\n-                        os.setAssociatedNode(f.getSource().getSourceNodes().get(0));\n+                    if (f.getInputNode() != null) {\n+                        os.getSource().addSourceNode(f.getInputNode());\n+                        os.setAssociatedNode(f.getInputNode());\n@@ -76,3 +76,3 @@\n-                    if (f.getSource().getSourceNodes().size() > 0) {\n-                        is.getSource().addSourceNodes(f.getSource());\n-                        is.setAssociatedNode(f.getSource().getSourceNodes().get(0));\n+                    if (f.getInputNode() != null) {\n+                        is.getSource().addSourceNode(f.getInputNode());\n+                        is.setAssociatedNode(f.getInputNode());\n","filename":"src\/utils\/IdealGraphVisualizer\/Filter\/src\/main\/java\/com\/sun\/hotspot\/igv\/filter\/SplitFilter.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -27,1 +27,3 @@\n-import com.sun.hotspot.igv.graph.*;\n+import com.sun.hotspot.igv.graph.Diagram;\n+import com.sun.hotspot.igv.graph.Figure;\n+import com.sun.hotspot.igv.graph.Selector;\n","filename":"src\/utils\/IdealGraphVisualizer\/Filter\/src\/main\/java\/com\/sun\/hotspot\/igv\/filter\/WarningFilter.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -63,7 +63,1 @@\n-        filter.getChangedEvent().addListener(new ChangedListener<Filter>() {\n-\n-            @Override\n-            public void changed(Filter source) {\n-                update();\n-            }\n-        });\n+        filter.getChangedEvent().addListener(source -> update());\n","filename":"src\/utils\/IdealGraphVisualizer\/FilterWindow\/src\/main\/java\/com\/sun\/hotspot\/igv\/filterwindow\/FilterNode.java","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -187,7 +187,1 @@\n-            filterSettings.sort(new Comparator<FilterSetting>() {\n-\n-                @Override\n-                public int compare(FilterSetting o1, FilterSetting o2) {\n-                    return o1.getName().compareTo(o2.getName());\n-                }\n-            });\n+            filterSettings.sort(Comparator.comparing(FilterSetting::getName));\n@@ -271,7 +265,1 @@\n-            sequence.getChangedEvent().addListener(new ChangedListener<FilterChain>() {\n-\n-                @Override\n-                public void changed(FilterChain source) {\n-                    addNotify();\n-                }\n-            });\n+            sequence.getChangedEvent().addListener(source -> addNotify());\n@@ -709,9 +697,0 @@\n-\n-    static final class ResolvableHelper implements Serializable {\n-\n-        private static final long serialVersionUID = 1L;\n-\n-        public Object readResolve() {\n-            return FilterTopComponent.getDefault();\n-        }\n-    }\n","filename":"src\/utils\/IdealGraphVisualizer\/FilterWindow\/src\/main\/java\/com\/sun\/hotspot\/igv\/filterwindow\/FilterTopComponent.java","additions":2,"deletions":23,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -11,1 +11,1 @@\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License\n","filename":"src\/utils\/IdealGraphVisualizer\/FilterWindow\/src\/main\/java\/com\/sun\/hotspot\/igv\/filterwindow\/actions\/FilterAction.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -21,1 +21,1 @@\n-    \n+\n@@ -31,0 +31,1 @@\n+                <attr name=\"position\" intvalue=\"3\"\/>\n","filename":"src\/utils\/IdealGraphVisualizer\/FilterWindow\/src\/main\/resources\/com\/sun\/hotspot\/igv\/filterwindow\/layer.xml","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-import java.util.List;\n@@ -28,0 +27,1 @@\n+import java.util.List;\n@@ -42,1 +42,1 @@\n-            l.add(d.getBlock(f.getBlock()));\n+            l.add(f.getBlock());\n","filename":"src\/utils\/IdealGraphVisualizer\/Graph\/src\/main\/java\/com\/sun\/hotspot\/igv\/graph\/AnySelector.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-import java.awt.Dimension;\n@@ -29,0 +28,1 @@\n+import java.awt.Dimension;\n@@ -48,4 +48,0 @@\n-    public Cluster getOuter() {\n-        return null;\n-    }\n-\n","filename":"src\/utils\/IdealGraphVisualizer\/Graph\/src\/main\/java\/com\/sun\/hotspot\/igv\/graph\/Block.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -26,7 +26,1 @@\n-import com.sun.hotspot.igv.data.InputBlock;\n-import com.sun.hotspot.igv.data.InputBlockEdge;\n-import com.sun.hotspot.igv.data.InputEdge;\n-import com.sun.hotspot.igv.data.InputGraph;\n-import com.sun.hotspot.igv.data.InputNode;\n-import com.sun.hotspot.igv.data.Properties;\n-import com.sun.hotspot.igv.data.Properties.StringPropertyMatcher;\n+import com.sun.hotspot.igv.data.*;\n@@ -34,1 +28,0 @@\n-import java.awt.Color;\n@@ -44,9 +37,8 @@\n-    private Map<InputBlock, Block> blocks;\n-    private InputGraph graph;\n-    private int curId;\n-    private String nodeText;\n-    private String shortNodeText;\n-    private String tinyNodeText;\n-    private final Font font;\n-    private final Font slotFont;\n-    private final Font boldFont;\n+    private final Map<InputBlock, Block> blocks;\n+    private final String nodeText;\n+    private final String shortNodeText;\n+    private final String tinyNodeText;\n+    public static final Font FONT = new Font(\"Arial\", Font.PLAIN, 12);\n+    public static final Font SLOT_FONT = new Font(\"Arial\", Font.PLAIN, 10);\n+    public static final Font BOLD_FONT = FONT.deriveFont(Font.BOLD);\n+\n@@ -58,12 +50,0 @@\n-    public Font getFont() {\n-        return font;\n-    }\n-\n-    public Font getSlotFont() {\n-        return slotFont;\n-    }\n-\n-    public Font getBoldFont() {\n-        return boldFont;\n-    }\n-\n@@ -78,12 +58,4 @@\n-    private Diagram(InputGraph graph, String nodeText, String shortNodeText,\n-                    String tinyNodeText) {\n-        figures = new ArrayList<>();\n-        blocks = new LinkedHashMap<>(8);\n-        this.nodeText = \"\";\n-        this.shortNodeText = \"\";\n-        this.font = new Font(\"Arial\", Font.PLAIN, 12);\n-        this.slotFont = new Font(\"Arial\", Font.PLAIN, 10);\n-        this.boldFont = this.font.deriveFont(Font.BOLD);\n-        this.cfg = false;\n-        this.blockConnections = new HashSet<>();\n-        this.graph = graph;\n+    public Diagram(InputGraph graph, String nodeText, String shortNodeText,\n+                   String tinyNodeText) {\n+        assert graph != null;\n+\n@@ -93,22 +65,5 @@\n-    }\n-\n-    public Block getBlock(InputBlock b) {\n-        assert blocks.containsKey(b);\n-        return blocks.get(b);\n-    }\n-\n-    public boolean hasBlock(InputBlock b) {\n-        return blocks.containsKey(b);\n-    }\n-\n-    public String getNodeText() {\n-        return nodeText;\n-    }\n-\n-    public String getShortNodeText() {\n-        return shortNodeText;\n-    }\n-\n-    public String getTinyNodeText() {\n-        return tinyNodeText;\n-    }\n+        this.figures = new ArrayList<>();\n+        this.blocks = new LinkedHashMap<>(8);\n+        this.blockConnections = new HashSet<>();\n+        this.cfg = false;\n+        int curId = 0;\n@@ -116,2 +71,0 @@\n-    public void updateBlocks() {\n-        blocks.clear();\n@@ -119,2 +72,1 @@\n-            Block curBlock = new Block(b, this);\n-            blocks.put(b, curBlock);\n+            blocks.put(b,  new Block(b, this));\n@@ -122,48 +74,0 @@\n-    }\n-\n-    public Collection<Block> getBlocks() {\n-        return Collections.unmodifiableCollection(blocks.values());\n-    }\n-\n-    public List<Figure> getFigures() {\n-        return Collections.unmodifiableList(figures);\n-    }\n-\n-    public Figure createFigure() {\n-        Figure f = new Figure(this, curId);\n-        curId++;\n-        this.figures.add(f);\n-        return f;\n-    }\n-\n-    public FigureConnection createConnection(InputSlot inputSlot, OutputSlot outputSlot, String label) {\n-        assert inputSlot.getFigure().getDiagram() == this;\n-        assert outputSlot.getFigure().getDiagram() == this;\n-        return new FigureConnection(inputSlot, outputSlot, label);\n-    }\n-\n-    public Map<InputNode, Set<Figure>> calcSourceToFigureRelation() {\n-        Map<InputNode, Set<Figure>> map = new HashMap<>();\n-\n-        for(InputNode node : this.getGraph().getNodes()) {\n-            map.put(node, new HashSet<Figure>());\n-        }\n-\n-        for(Figure f : this.getFigures()) {\n-            for(InputNode node : f.getSource().getSourceNodes()) {\n-                map.get(node).add(f);\n-            }\n-        }\n-\n-        return map;\n-    }\n-\n-    public static Diagram createDiagram(InputGraph graph, String nodeText,\n-                                        String shortNodeText,\n-                                        String tinyNodeText) {\n-        if (graph == null) {\n-            return null;\n-        }\n-\n-        Diagram d = new Diagram(graph, nodeText, shortNodeText, tinyNodeText);\n-        d.updateBlocks();\n@@ -174,2 +78,2 @@\n-            Figure f = d.createFigure();\n-            f.getSource().addSourceNode(n);\n+            Figure f = new Figure(this, curId, n);\n+            curId++;\n@@ -177,2 +81,1 @@\n-            f.setSubgraphs(n.getSubgraphs());\n-            f.setBlock(graph.getBlock(n));\n+            f.setBlock(blocks.get(graph.getBlock(n)));\n@@ -180,0 +83,1 @@\n+            this.figures.add(f);\n@@ -183,1 +87,0 @@\n-\n@@ -190,1 +93,0 @@\n-            assert fromFigure != null && toFigure != null;\n@@ -204,1 +106,1 @@\n-            FigureConnection c = d.createConnection(inputSlot, outputSlot, e.getLabel());\n+            FigureConnection c = createConnection(inputSlot, outputSlot, e.getLabel());\n@@ -214,3 +116,3 @@\n-            Block p = d.getBlock(e.getFrom());\n-            Block s = d.getBlock(e.getTo());\n-            d.blockConnections.add(new BlockConnection(p, s, e.getLabel()));\n+            Block p = getBlock(e.getFrom());\n+            Block s = getBlock(e.getTo());\n+            blockConnections.add(new BlockConnection(p, s, e.getLabel()));\n@@ -218,0 +120,30 @@\n+    }\n+\n+    public Block getBlock(InputBlock b) {\n+        assert blocks.containsKey(b);\n+        return blocks.get(b);\n+    }\n+\n+    public boolean hasBlock(InputBlock b) {\n+        return blocks.containsKey(b);\n+    }\n+\n+    public String getNodeText() {\n+        return nodeText;\n+    }\n+\n+    public String getShortNodeText() {\n+        return shortNodeText;\n+    }\n+\n+    public String getTinyNodeText() {\n+        return tinyNodeText;\n+    }\n+\n+    public Collection<Block> getBlocks() {\n+        return Collections.unmodifiableCollection(blocks.values());\n+    }\n+\n+    public Collection<InputBlock> getInputBlocks() {\n+        return Collections.unmodifiableCollection(blocks.keySet());\n+    }\n@@ -219,1 +151,8 @@\n-        return d;\n+    public List<Figure> getFigures() {\n+        return Collections.unmodifiableList(figures);\n+    }\n+\n+    public FigureConnection createConnection(InputSlot inputSlot, OutputSlot outputSlot, String label) {\n+        assert inputSlot.getFigure().getDiagram() == this;\n+        assert outputSlot.getFigure().getDiagram() == this;\n+        return new FigureConnection(inputSlot, outputSlot, label);\n@@ -226,1 +165,1 @@\n-                if (f.getBlock() == b.getInputBlock()) {\n+                if (f.getBlock() == b) {\n@@ -276,8 +215,0 @@\n-    public String getName() {\n-        return graph.getName();\n-    }\n-\n-    public InputGraph getGraph() {\n-        return graph;\n-    }\n-\n@@ -305,62 +236,0 @@\n-    public Figure getRootFigure() {\n-        Properties.PropertySelector<Figure> selector = new Properties.PropertySelector<>(figures);\n-        Figure root = selector.selectSingle(new StringPropertyMatcher(\"name\", \"Root\"));\n-        if (root == null) {\n-            root = selector.selectSingle(new StringPropertyMatcher(\"name\", \"Start\"));\n-        }\n-        if (root == null) {\n-            List<Figure> rootFigures = getRootFigures();\n-            if (rootFigures.size() > 0) {\n-                root = rootFigures.get(0);\n-            } else if (figures.size() > 0) {\n-                root = figures.get(0);\n-            }\n-        }\n-\n-        return root;\n-    }\n-\n-    public void printStatistics() {\n-        System.out.println(\"=============================================================\");\n-        System.out.println(\"Diagram statistics\");\n-\n-        List<Figure> tmpFigures = getFigures();\n-        Set<FigureConnection> connections = getConnections();\n-\n-        System.out.println(\"Number of figures: \" + tmpFigures.size());\n-        System.out.println(\"Number of connections: \" + connections.size());\n-\n-        List<Figure> figuresSorted = new ArrayList<>(tmpFigures);\n-        figuresSorted.sort(new Comparator<Figure>() {\n-\n-            @Override\n-            public int compare(Figure a, Figure b) {\n-                return b.getPredecessors().size() + b.getSuccessors().size() - a.getPredecessors().size() - a.getSuccessors().size();\n-            }\n-        });\n-\n-        final int COUNT = 10;\n-        int z = 0;\n-        for (Figure f : figuresSorted) {\n-\n-            z++;\n-            int sum = f.getPredecessors().size() + f.getSuccessors().size();\n-            System.out.println(\"#\" + z + \": \" + f + \", predCount=\" + f.getPredecessors().size() + \" succCount=\" + f.getSuccessors().size());\n-            if (sum < COUNT) {\n-                break;\n-            }\n-\n-        }\n-\n-        System.out.println(\"=============================================================\");\n-    }\n-\n-    public List<Figure> getRootFigures() {\n-        ArrayList<Figure> rootFigures = new ArrayList<>();\n-        for (Figure f : figures) {\n-            if (f.getPredecessors().size() == 0) {\n-                rootFigures.add(f);\n-            }\n-        }\n-        return rootFigures;\n-    }\n","filename":"src\/utils\/IdealGraphVisualizer\/Graph\/src\/main\/java\/com\/sun\/hotspot\/igv\/graph\/Diagram.java","additions":66,"deletions":197,"binary":false,"changes":263,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n-import com.sun.hotspot.igv.data.InputBlock;\n-import com.sun.hotspot.igv.data.InputGraph;\n@@ -30,1 +28,0 @@\n-import com.sun.hotspot.igv.data.Source;\n@@ -37,1 +34,1 @@\n-public class Figure extends Properties.Entity implements Source.Provider, Vertex {\n+public class Figure extends Properties.Entity implements Vertex {\n@@ -49,2 +46,2 @@\n-    private Source source;\n-    private Diagram diagram;\n+    private final InputNode inputNode;\n+    private final Diagram diagram;\n@@ -52,3 +49,2 @@\n-    private List<Figure> predecessors;\n-    private List<Figure> successors;\n-    private List<InputGraph> subgraphs;\n+    private final List<Figure> predecessors;\n+    private final List<Figure> successors;\n@@ -57,2 +53,2 @@\n-    private int id;\n-    private String idString;\n+    private final int id;\n+    private final String idString;\n@@ -62,1 +58,1 @@\n-    private InputBlock block;\n+    private Block block;\n@@ -135,1 +131,1 @@\n-    protected Figure(Diagram diagram, int id) {\n+    protected Figure(Diagram diagram, int id, InputNode node) {\n@@ -137,5 +133,5 @@\n-        this.source = new Source();\n-        inputSlots = new ArrayList<>(5);\n-        outputSlots = new ArrayList<>(1);\n-        predecessors = new ArrayList<>(6);\n-        successors = new ArrayList<>(6);\n+        this.inputNode = node;\n+        this.inputSlots = new ArrayList<>(5);\n+        this.outputSlots = new ArrayList<>(1);\n+        this.predecessors = new ArrayList<>(6);\n+        this.successors = new ArrayList<>(6);\n@@ -143,2 +139,1 @@\n-        idString = Integer.toString(id);\n-\n+        this.idString = Integer.toString(id);\n@@ -148,1 +143,1 @@\n-        metrics = canvas.getFontMetrics(diagram.getFont().deriveFont(Font.BOLD));\n+        this.metrics = canvas.getFontMetrics(Diagram.FONT.deriveFont(Font.BOLD));\n@@ -175,1 +170,1 @@\n-    public void setBlock(InputBlock block) {\n+    public void setBlock(Block block) {\n@@ -179,1 +174,1 @@\n-    public InputBlock getBlock() {\n+    public Block getBlock() {\n@@ -188,5 +183,1 @@\n-        Set<Figure> result = new HashSet<>();\n-        for (Figure f : getPredecessors()) {\n-            result.add(f);\n-        }\n-        return Collections.unmodifiableSet(result);\n+        return Collections.unmodifiableSet(new HashSet<>(getPredecessors()));\n@@ -196,5 +187,1 @@\n-        Set<Figure> result = new HashSet<>();\n-        for (Figure f : getSuccessors()) {\n-            result.add(f);\n-        }\n-        return Collections.unmodifiableSet(result);\n+        return Collections.unmodifiableSet(new HashSet<>(getSuccessors()));\n@@ -225,8 +212,0 @@\n-    public List<InputGraph> getSubgraphs() {\n-        return subgraphs;\n-    }\n-\n-    public void setSubgraphs(List<InputGraph> subgraphs) {\n-        this.subgraphs = subgraphs;\n-    }\n-\n@@ -247,3 +226,2 @@\n-    @Override\n-    public Source getSource() {\n-        return source;\n+    public InputNode getInputNode() {\n+        return inputNode;\n@@ -258,7 +236,0 @@\n-    public InputSlot createInputSlot(int index) {\n-        InputSlot slot = new InputSlot(this, index);\n-        inputSlots.add(slot);\n-        inputSlots.sort(Slot.slotIndexComparator);\n-        return slot;\n-    }\n-\n@@ -276,3 +247,1 @@\n-        } else if (outputSlots.contains(s)) {\n-            outputSlots.remove(s);\n-        }\n+        } else outputSlots.remove(s);\n@@ -281,1 +250,1 @@\n-    public OutputSlot createOutputSlot() {\n+    public void createOutputSlot() {\n@@ -284,1 +253,0 @@\n-        return slot;\n@@ -348,2 +316,2 @@\n-        for (int i = 0; i < strings.length; i++) {\n-            result.add(getProperties().resolveString(strings[i]));\n+        for (String string : strings) {\n+            result.add(getProperties().resolveString(string));\n@@ -354,1 +322,1 @@\n-            List<String> inputs = new ArrayList<String>(getPredecessors().size());\n+            List<String> inputs = new ArrayList<>(getPredecessors().size());\n@@ -369,1 +337,1 @@\n-        \/\/ Set the \"label\" property of each input node, so that by default\n+        \/\/ Set the \"label\" property of the input node, so that by default\n@@ -372,4 +340,3 @@\n-        for (InputNode n : getSource().getSourceNodes()) {\n-            String label = n.getProperties().resolveString(diagram.getNodeText());\n-            n.getProperties().setProperty(\"label\", label.replaceAll(\"\\\\R\", \" \"));\n-        }\n+        String label = inputNode.getProperties().resolveString(diagram.getNodeText());\n+        inputNode.getProperties().setProperty(\"label\", label.replaceAll(\"\\\\R\", \" \"));\n+\n@@ -393,4 +360,0 @@\n-    public InputNode getFirstSourceNode() {\n-        return getSource().getSourceNodes().get(0);\n-    }\n-\n@@ -402,10 +365,1 @@\n-        if (getSource().getSourceNodes().size() == 0) {\n-            assert false : \"Should never reach here, every figure must have at least one source node!\";\n-            return null;\n-        } else {\n-            final InputBlock inputBlock = diagram.getGraph().getBlock(getFirstSourceNode());\n-            assert inputBlock != null;\n-            Cluster result = diagram.getBlock(inputBlock);\n-            assert result != null;\n-            return result;\n-        }\n+        return block;\n@@ -416,4 +370,2 @@\n-\n-        List<InputNode> sourceNodes = source.getSourceNodes();\n-        if (sourceNodes.size() > 0 && getFirstSourceNode().getProperties().get(\"name\") != null) {\n-            return getFirstSourceNode().getProperties().get(\"name\").equals(\"Root\");\n+        if (inputNode != null && inputNode.getProperties().get(\"name\") != null) {\n+            return inputNode.getProperties().get(\"name\").equals(\"Root\");\n@@ -429,4 +381,0 @@\n-\n-    public Rectangle getBounds() {\n-        return new Rectangle(this.getPosition(), new Dimension(this.getWidth(), this.getHeight()));\n-    }\n","filename":"src\/utils\/IdealGraphVisualizer\/Graph\/src\/main\/java\/com\/sun\/hotspot\/igv\/graph\/Figure.java","additions":34,"deletions":86,"binary":false,"changes":120,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-import com.sun.hotspot.igv.layout.Port;\n@@ -28,0 +27,1 @@\n+import com.sun.hotspot.igv.layout.Port;\n","filename":"src\/utils\/IdealGraphVisualizer\/Graph\/src\/main\/java\/com\/sun\/hotspot\/igv\/graph\/FigureConnection.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -81,18 +81,1 @@\n-    public static final Comparator<Slot> slotIndexComparator = new Comparator<Slot>() {\n-\n-        @Override\n-        public int compare(Slot o1, Slot o2) {\n-            return o1.wantedIndex - o2.wantedIndex;\n-        }\n-    };\n-    public static final Comparator<Slot> slotFigureComparator = new Comparator<Slot>() {\n-\n-        @Override\n-        public int compare(Slot o1, Slot o2) {\n-            return o1.figure.getId() - o2.figure.getId();\n-        }\n-    };\n-\n-    public InputNode getAssociatedNode() {\n-        return associatedNode;\n-    }\n+    public static final Comparator<Slot> slotIndexComparator = Comparator.comparingInt(o -> o.wantedIndex);\n@@ -110,1 +93,1 @@\n-            g.setFont(figure.getDiagram().getSlotFont().deriveFont(Font.BOLD));\n+            g.setFont(Diagram.SLOT_FONT.deriveFont(Font.BOLD));\n","filename":"src\/utils\/IdealGraphVisualizer\/Graph\/src\/main\/java\/com\/sun\/hotspot\/igv\/graph\/Slot.java","additions":2,"deletions":19,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+import com.sun.hotspot.igv.layout.Cluster;\n@@ -28,1 +29,0 @@\n-import com.sun.hotspot.igv.layout.Cluster;\n@@ -38,2 +38,2 @@\n-    private ClusterNode from;\n-    private ClusterNode to;\n+    private final ClusterNode from;\n+    private final ClusterNode to;\n","filename":"src\/utils\/IdealGraphVisualizer\/HierarchicalLayout\/src\/main\/java\/com\/sun\/hotspot\/igv\/hierarchicallayout\/ClusterEdge.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+import com.sun.hotspot.igv.layout.Cluster;\n@@ -28,1 +29,0 @@\n-import com.sun.hotspot.igv.layout.Cluster;\n@@ -40,4 +40,2 @@\n-    private ClusterInputSlotNode inputSlotNode;\n-    private Link connection;\n-    private Port inputSlot;\n-    private Port outputSlot;\n+    private final Port inputSlot;\n+    private final Port outputSlot;\n@@ -46,3 +44,1 @@\n-        this.inputSlotNode = inputSlotNode;\n-        this.connection = c;\n-        this.controlPoints = new ArrayList<Point>();\n+        this.controlPoints = new ArrayList<>();\n@@ -54,8 +50,0 @@\n-    public Link getConnection() {\n-        return connection;\n-    }\n-\n-    public ClusterInputSlotNode getInputSlotNode() {\n-        return inputSlotNode;\n-    }\n-\n","filename":"src\/utils\/IdealGraphVisualizer\/HierarchicalLayout\/src\/main\/java\/com\/sun\/hotspot\/igv\/hierarchicallayout\/ClusterIngoingConnection.java","additions":4,"deletions":16,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n-    private final int SIZE = 0;\n@@ -40,10 +39,3 @@\n-    private Port inputSlot;\n-    private Port outputSlot;\n-    private ClusterNode blockNode;\n-    private InterClusterConnection interBlockConnection;\n-    private Cluster cluster;\n-    private ClusterIngoingConnection conn;\n-\n-    public void setIngoingConnection(ClusterIngoingConnection c) {\n-        conn = c;\n-    }\n+    private final Port inputSlot;\n+    private final Port outputSlot;\n+    private final ClusterNode blockNode;\n@@ -51,4 +43,1 @@\n-    public ClusterIngoingConnection getIngoingConnection() {\n-        return conn;\n-    }\n-    private String id;\n+    private final String id;\n@@ -82,1 +71,1 @@\n-                return \"OutPort of \" + thisNode.toString();\n+                return \"OutPort of \" + thisNode;\n@@ -101,1 +90,1 @@\n-                return \"InPort of \" + thisNode.toString();\n+                return \"InPort of \" + thisNode;\n@@ -110,4 +99,0 @@\n-    public InterClusterConnection getInterBlockConnection() {\n-        return interBlockConnection;\n-    }\n-\n@@ -119,0 +104,1 @@\n+        int SIZE = 0;\n@@ -130,4 +116,0 @@\n-    public void setInterBlockConnection(InterClusterConnection interBlockConnection) {\n-        this.interBlockConnection = interBlockConnection;\n-    }\n-\n@@ -135,1 +117,1 @@\n-        return cluster;\n+        return null;\n","filename":"src\/utils\/IdealGraphVisualizer\/HierarchicalLayout\/src\/main\/java\/com\/sun\/hotspot\/igv\/hierarchicallayout\/ClusterInputSlotNode.java","additions":8,"deletions":26,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -32,5 +32,1 @@\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.HashSet;\n-import java.util.List;\n-import java.util.Set;\n+import java.util.*;\n@@ -46,2 +42,1 @@\n-    private Port outputSlot;\n-    private Set<Vertex> subNodes;\n+    private final Set<Vertex> subNodes;\n@@ -50,2 +45,1 @@\n-    private Set<Link> subEdges;\n-    private boolean dirty;\n+    private final Set<Link> subEdges;\n@@ -53,1 +47,1 @@\n-    private String name;\n+    private final String name;\n@@ -62,2 +56,2 @@\n-        this.subNodes = new HashSet<Vertex>();\n-        this.subEdges = new HashSet<Link>();\n+        this.subNodes = new HashSet<>();\n+        this.subEdges = new HashSet<>();\n@@ -65,1 +59,1 @@\n-        position = new Point(0, 0);\n+        this.position = new Point(0, 0);\n@@ -97,2 +91,0 @@\n-\n-\n@@ -117,16 +109,0 @@\n-\n-        outputSlot = new Port() {\n-\n-            public Point getRelativePosition() {\n-                return new Point(size.width \/ 2, 0);\/\/size.height);\n-            }\n-\n-            public Vertex getVertex() {\n-                return widget;\n-            }\n-\n-            @Override\n-            public String toString() {\n-                return \"ClusterOutput(\" + name + \")\";\n-            }\n-        };\n@@ -177,1 +153,1 @@\n-            List<Point> points = new ArrayList<Point>(l.getControlPoints());\n+            List<Point> points = new ArrayList<>(l.getControlPoints());\n@@ -195,4 +171,0 @@\n-    public Port getOutputSlot() {\n-        return outputSlot;\n-    }\n-\n@@ -218,1 +190,1 @@\n-            ArrayList<Point> newArr = new ArrayList<Point>(arr.size());\n+            ArrayList<Point> newArr = new ArrayList<>(arr.size());\n@@ -241,4 +213,0 @@\n-    public void setDirty(boolean b) {\n-        dirty = b;\n-    }\n-\n","filename":"src\/utils\/IdealGraphVisualizer\/HierarchicalLayout\/src\/main\/java\/com\/sun\/hotspot\/igv\/hierarchicallayout\/ClusterNode.java","additions":9,"deletions":41,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+import com.sun.hotspot.igv.layout.Cluster;\n@@ -28,1 +29,0 @@\n-import com.sun.hotspot.igv.layout.Cluster;\n@@ -40,4 +40,2 @@\n-    private ClusterOutputSlotNode outputSlotNode;\n-    private Link connection;\n-    private Port inputSlot;\n-    private Port outputSlot;\n+    private final Port inputSlot;\n+    private final Port outputSlot;\n@@ -46,6 +44,3 @@\n-        this.outputSlotNode = outputSlotNode;\n-        this.connection = c;\n-        this.intermediatePoints = new ArrayList<Point>();\n-\n-        outputSlot = c.getFrom();\n-        inputSlot = outputSlotNode.getInputSlot();\n+        this.intermediatePoints = new ArrayList<>();\n+        this.outputSlot = c.getFrom();\n+        this.inputSlot = outputSlotNode.getInputSlot();\n","filename":"src\/utils\/IdealGraphVisualizer\/HierarchicalLayout\/src\/main\/java\/com\/sun\/hotspot\/igv\/hierarchicallayout\/ClusterOutgoingConnection.java","additions":6,"deletions":11,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n-    private final int SIZE = 0;\n@@ -40,4 +39,3 @@\n-    private Port inputSlot;\n-    private Port outputSlot;\n-    private ClusterNode blockNode;\n-    private boolean root;\n+    private final Port inputSlot;\n+    private final Port outputSlot;\n+    private final ClusterNode blockNode;\n@@ -46,1 +44,1 @@\n-    private String id;\n+    private final String id;\n@@ -82,1 +80,1 @@\n-                return \"InPort of \" + thisNode.toString();\n+                return \"InPort of \" + thisNode;\n@@ -91,1 +89,1 @@\n-                p.y = 0;\/\/thisBlockNode.getSize().height;\n+                p.y = 0;\n@@ -101,1 +99,1 @@\n-                return \"OutPort of \" + thisNode.toString();\n+                return \"OutPort of \" + thisNode;\n@@ -107,0 +105,1 @@\n+        int SIZE = 0;\n@@ -130,4 +129,0 @@\n-    public void setRoot(boolean b) {\n-        root = b;\n-    }\n-\n@@ -139,1 +134,1 @@\n-        return root;\n+        return false;\n","filename":"src\/utils\/IdealGraphVisualizer\/HierarchicalLayout\/src\/main\/java\/com\/sun\/hotspot\/igv\/hierarchicallayout\/ClusterOutputSlotNode.java","additions":9,"deletions":14,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -1,90 +0,0 @@\n-\/*\n- * Copyright (c) 2008, 2015, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-package com.sun.hotspot.igv.hierarchicallayout;\n-\n-\/**\n- *\n- * @author Thomas Wuerthinger\n- *\/\n-public class Edge<N, E> {\n-\n-    private E data;\n-    private Node<N, E> source;\n-    private Node<N, E> dest;\n-\n-    protected Edge(Graph<N, E> graph, Node<N, E> source, Node<N, E> dest, E data) {\n-        setData(data);\n-        this.source = source;\n-        this.dest = dest;\n-        assert source != null;\n-        assert dest != null;\n-        assert source.getGraph() == dest.getGraph();\n-        assert source.getGraph() != null;\n-        assert dest.getGraph() != null;\n-    }\n-\n-    public Node<N, E> getSource() {\n-        return source;\n-    }\n-\n-    public Node<N, E> getDest() {\n-        return dest;\n-    }\n-\n-    public E getData() {\n-        return data;\n-    }\n-\n-    public void setData(E e) {\n-        data = e;\n-    }\n-\n-    public void remove() {\n-        source.getGraph().removeEdge(this, null);\n-    }\n-\n-    public boolean isSelfLoop() {\n-        return source == dest;\n-    }\n-\n-    public void reverse() {\n-\n-        \/\/ Remove from current source \/ dest\n-        source.removeOutEdge(this);\n-        dest.removeInEdge(this);\n-\n-        Node<N, E> tmp = source;\n-        source = dest;\n-        dest = tmp;\n-\n-        \/\/ Add to new source \/ dest\n-        source.addOutEdge(this);\n-        dest.addInEdge(this);\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return \"Edge (\" + source + \" -- \" + dest + \"): \" + data;\n-    }\n-}\n","filename":"src\/utils\/IdealGraphVisualizer\/HierarchicalLayout\/src\/main\/java\/com\/sun\/hotspot\/igv\/hierarchicallayout\/Edge.java","additions":0,"deletions":90,"binary":false,"changes":90,"status":"deleted"},{"patch":"@@ -1,292 +0,0 @@\n-\/*\n- * Copyright (c) 2008, 2015, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-package com.sun.hotspot.igv.hierarchicallayout;\n-\n-import java.util.*;\n-\n-\/**\n- *\n- * @author Thomas Wuerthinger\n- *\/\n-public class Graph<N, E> {\n-\n-    private HashMap<Object, Node<N, E>> nodes;\n-    private HashMap<Object, Edge<N, E>> edges;\n-    private List<Node<N, E>> nodeList;\n-\n-    public Graph() {\n-        nodes = new HashMap<>();\n-        edges = new HashMap<>();\n-        nodeList = new ArrayList<>();\n-    }\n-\n-    public Node<N, E> createNode(N data, Object key) {\n-        Node<N, E> n = new Node<>(this, data);\n-        assert key == null || !nodes.containsKey(key);\n-        if (key != null) {\n-            nodes.put(key, n);\n-        }\n-        nodeList.add(n);\n-        return n;\n-    }\n-\n-    public Edge<N, E> createEdge(Node<N, E> source, Node<N, E> dest, E data, Object key) {\n-        Edge<N, E> e = new Edge<>(this, source, dest, data);\n-        source.addOutEdge(e);\n-        dest.addInEdge(e);\n-        if (key != null) {\n-            edges.put(key, e);\n-        }\n-        return e;\n-    }\n-\n-    public Node<N, E> getNode(Object key) {\n-        return nodes.get(key);\n-    }\n-\n-    public Edge<N, E> getEdge(Object key) {\n-        return edges.get(key);\n-    }\n-\n-    public Collection<Edge<N, E>> getEdges() {\n-        return Collections.unmodifiableCollection(edges.values());\n-    }\n-\n-    public Collection<Node<N, E>> getNodes() {\n-        return Collections.unmodifiableList(nodeList);\n-    }\n-\n-    public void removeEdge(Edge<N, E> e, Object key) {\n-        assert key == null || edges.containsKey(key);\n-        if (key != null) {\n-            edges.remove(key);\n-        }\n-        e.getSource().removeOutEdge(e);\n-        e.getDest().removeInEdge(e);\n-    }\n-\n-    public class DFSTraversalVisitor {\n-\n-        public void visitNode(Node<N, E> n) {\n-        }\n-\n-        public boolean visitEdge(Edge<N, E> e, boolean backEdge) {\n-            return true;\n-        }\n-    }\n-\n-    public class BFSTraversalVisitor {\n-\n-        public void visitNode(Node<N, E> n, int depth) {\n-        }\n-    }\n-\n-    public List<Node<N, E>> getNodesWithInDegree(int x) {\n-        return getNodesWithInDegree(x, true);\n-    }\n-\n-    public List<Node<N, E>> getNodesWithInDegree(int x, boolean countSelfLoops) {\n-\n-        List<Node<N, E>> result = new ArrayList<>();\n-        for (Node<N, E> n : getNodes()) {\n-            if (n.getInDegree(countSelfLoops) == x) {\n-                result.add(n);\n-            }\n-        }\n-\n-        return result;\n-\n-    }\n-\n-    private void markReachable(Node<N, E> startingNode) {\n-        ArrayList<Node<N, E>> arr = new ArrayList<>();\n-        arr.add(startingNode);\n-        for (Node<N, E> n : getNodes()) {\n-            n.setReachable(false);\n-        }\n-        traverseDFS(arr, new DFSTraversalVisitor() {\n-\n-            @Override\n-            public void visitNode(Node<N, E> n) {\n-                n.setReachable(true);\n-            }\n-        });\n-    }\n-\n-    public void traverseBFS(Node<N, E> startingNode, BFSTraversalVisitor tv, boolean longestPath) {\n-\n-        if (longestPath) {\n-            markReachable(startingNode);\n-        }\n-\n-        for (Node<N, E> n : getNodes()) {\n-            n.setVisited(false);\n-            n.setActive(false);\n-        }\n-\n-        Queue<Node<N, E>> queue = new LinkedList<>();\n-        queue.add(startingNode);\n-        startingNode.setVisited(true);\n-        int layer = 0;\n-        Node<N, E> lastOfLayer = startingNode;\n-        Node<N, E> lastAdded = null;\n-\n-        while (!queue.isEmpty()) {\n-\n-            Node<N, E> current = queue.poll();\n-            tv.visitNode(current, layer);\n-            current.setActive(false);\n-\n-\n-            for (Edge<N, E> e : current.getOutEdges()) {\n-                if (!e.getDest().isVisited()) {\n-\n-                    boolean allow = true;\n-                    if (longestPath) {\n-                        for (Node<N, E> pred : e.getDest().getPredecessors()) {\n-                            if ((!pred.isVisited() || pred.isActive()) && pred.isReachable()) {\n-                                allow = false;\n-                                break;\n-                            }\n-                        }\n-                    }\n-\n-                    if (allow) {\n-                        queue.offer(e.getDest());\n-                        lastAdded = e.getDest();\n-                        e.getDest().setVisited(true);\n-                        e.getDest().setActive(true);\n-                    }\n-                }\n-            }\n-\n-            if (current == lastOfLayer && !queue.isEmpty()) {\n-                lastOfLayer = lastAdded;\n-                layer++;\n-            }\n-        }\n-    }\n-\n-    public void traverseDFS(DFSTraversalVisitor tv) {\n-        traverseDFS(getNodes(), tv);\n-    }\n-\n-    public void traverseDFS(Collection<Node<N, E>> startingNodes, DFSTraversalVisitor tv) {\n-\n-        for (Node<N, E> n : getNodes()) {\n-            n.setVisited(false);\n-            n.setActive(false);\n-        }\n-\n-        boolean result = false;\n-        for (Node<N, E> n : startingNodes) {\n-            traverse(tv, n);\n-        }\n-    }\n-\n-    private void traverse(DFSTraversalVisitor tv, Node<N, E> n) {\n-\n-        if (!n.isVisited()) {\n-            n.setVisited(true);\n-            n.setActive(true);\n-            tv.visitNode(n);\n-\n-            for (Edge<N, E> e : n.getOutEdges()) {\n-\n-                Node<N, E> next = e.getDest();\n-                if (next.isActive()) {\n-                    tv.visitEdge(e, true);\n-                } else {\n-                    if (tv.visitEdge(e, false)) {\n-                        traverse(tv, next);\n-                    }\n-                }\n-            }\n-\n-            n.setActive(false);\n-        }\n-\n-    }\n-\n-    public boolean hasCycles() {\n-\n-        for (Node<N, E> n : getNodes()) {\n-            n.setVisited(false);\n-            n.setActive(false);\n-        }\n-\n-        boolean result = false;\n-        for (Node<N, E> n : getNodes()) {\n-            result |= checkCycles(n);\n-            if (result) {\n-                break;\n-            }\n-        }\n-        return result;\n-    }\n-\n-    private boolean checkCycles(Node<N, E> n) {\n-\n-        if (n.isActive()) {\n-            return true;\n-        }\n-\n-        if (!n.isVisited()) {\n-\n-            n.setVisited(true);\n-            n.setActive(true);\n-\n-            for (Node<N, E> succ : n.getSuccessors()) {\n-                if (checkCycles(succ)) {\n-                    return true;\n-                }\n-            }\n-\n-            n.setActive(false);\n-\n-        }\n-\n-        return false;\n-    }\n-\n-    @Override\n-    public String toString() {\n-\n-        StringBuilder s = new StringBuilder();\n-        s.append(\"Nodes: \");\n-        for (Node<N, E> n : getNodes()) {\n-            s.append(n.toString());\n-            s.append(\"\\n\");\n-        }\n-\n-        s.append(\"Edges: \");\n-\n-        for (Edge<N, E> e : getEdges()) {\n-            s.append(e.toString());\n-            s.append(\"\\n\");\n-        }\n-\n-        return s.toString();\n-    }\n-}\n","filename":"src\/utils\/IdealGraphVisualizer\/HierarchicalLayout\/src\/main\/java\/com\/sun\/hotspot\/igv\/hierarchicallayout\/Graph.java","additions":0,"deletions":292,"binary":false,"changes":292,"status":"deleted"},{"patch":"@@ -26,8 +26,0 @@\n-import java.awt.Dimension;\n-import java.awt.Rectangle;\n-import java.awt.Canvas;\n-import java.awt.Font;\n-import java.awt.FontMetrics;\n-import java.util.*;\n-import com.sun.hotspot.igv.layout.Cluster;\n-import com.sun.hotspot.igv.layout.LayoutGraph;\n@@ -35,2 +27,3 @@\n-import com.sun.hotspot.igv.layout.Link;\n-import com.sun.hotspot.igv.layout.Vertex;\n+import com.sun.hotspot.igv.layout.*;\n+import java.awt.*;\n+import java.util.*;\n@@ -41,1 +34,1 @@\n-    private FontMetrics fontMetrics;\n+    private final FontMetrics fontMetrics;\n@@ -81,1 +74,1 @@\n-            subManager.doLayout(new LayoutGraph(n.getSubEdges(), n.getSubNodes()), new HashSet<Link>());\n+            subManager.doLayout(new LayoutGraph(n.getSubEdges(), n.getSubNodes()), new HashSet<>());\n@@ -86,2 +79,1 @@\n-        manager.doLayout(new LayoutGraph(clusterEdges, new HashSet<>(clusterNode.values())),\n-                         new HashSet<Link>());\n+        manager.doLayout(new LayoutGraph(clusterEdges, new HashSet<>(clusterNode.values())), new HashSet<>());\n@@ -147,1 +139,1 @@\n-            inputLink.put(new AbstractMap.SimpleEntry<Cluster, Cluster>(l.getFromCluster(), l.getToCluster()), l);\n+            inputLink.put(new AbstractMap.SimpleEntry<>(l.getFromCluster(), l.getToCluster()), l);\n@@ -151,1 +143,1 @@\n-            Link l = inputLink.get(new AbstractMap.SimpleEntry<Cluster, Cluster>(ce.getFromCluster(), ce.getToCluster()));\n+            Link l = inputLink.get(new AbstractMap.SimpleEntry<>(ce.getFromCluster(), ce.getToCluster()));\n","filename":"src\/utils\/IdealGraphVisualizer\/HierarchicalLayout\/src\/main\/java\/com\/sun\/hotspot\/igv\/hierarchicallayout\/HierarchicalCFGLayoutManager.java","additions":8,"deletions":16,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+import com.sun.hotspot.igv.layout.*;\n@@ -28,12 +29,1 @@\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Set;\n-import java.util.ArrayList;\n-import java.util.HashSet;\n-import java.util.TreeSet;\n-import com.sun.hotspot.igv.layout.Cluster;\n-import com.sun.hotspot.igv.layout.LayoutGraph;\n-import com.sun.hotspot.igv.layout.LayoutManager;\n-import com.sun.hotspot.igv.layout.Link;\n-import com.sun.hotspot.igv.layout.Port;\n-import com.sun.hotspot.igv.layout.Vertex;\n+import java.util.*;\n@@ -56,4 +46,0 @@\n-    public void doLayout(LayoutGraph graph) {\n-        doLayout(graph, new HashSet<Vertex>(), new HashSet<Vertex>(), new HashSet<Link>());\n-    }\n-\n@@ -72,1 +58,1 @@\n-    public void doLayout(LayoutGraph graph, Set<? extends Vertex> firstLayerHint, Set<? extends Vertex> lastLayerHint, Set<? extends Link> importantLinks) {\n+    public void doLayout(LayoutGraph graph) {\n@@ -76,14 +62,13 @@\n-        HashMap<Cluster, List<Vertex>> lists = new HashMap<Cluster, List<Vertex>>();\n-        HashMap<Cluster, List<Link>> listsConnection = new HashMap<Cluster, List<Link>>();\n-        HashMap<Cluster, HashMap<Port, ClusterInputSlotNode>> clusterInputSlotHash = new HashMap<Cluster, HashMap<Port, ClusterInputSlotNode>>();\n-        HashMap<Cluster, HashMap<Port, ClusterOutputSlotNode>> clusterOutputSlotHash = new HashMap<Cluster, HashMap<Port, ClusterOutputSlotNode>>();\n-\n-        HashMap<Cluster, ClusterNode> clusterNodes = new HashMap<Cluster, ClusterNode>();\n-        HashMap<Cluster, Set<ClusterInputSlotNode>> clusterInputSlotSet = new HashMap<Cluster, Set<ClusterInputSlotNode>>();\n-        HashMap<Cluster, Set<ClusterOutputSlotNode>> clusterOutputSlotSet = new HashMap<Cluster, Set<ClusterOutputSlotNode>>();\n-        Set<Link> clusterEdges = new HashSet<Link>();\n-        Set<Link> interClusterEdges = new HashSet<Link>();\n-        HashMap<Link, ClusterOutgoingConnection> linkClusterOutgoingConnection = new HashMap<Link, ClusterOutgoingConnection>();\n-        HashMap<Link, InterClusterConnection> linkInterClusterConnection = new HashMap<Link, InterClusterConnection>();\n-        HashMap<Link, ClusterIngoingConnection> linkClusterIngoingConnection = new HashMap<Link, ClusterIngoingConnection>();\n-        Set<ClusterNode> clusterNodeSet = new HashSet<ClusterNode>();\n+        HashMap<Cluster, List<Link>> listsConnection = new HashMap<>();\n+        HashMap<Cluster, HashMap<Port, ClusterInputSlotNode>> clusterInputSlotHash = new HashMap<>();\n+        HashMap<Cluster, HashMap<Port, ClusterOutputSlotNode>> clusterOutputSlotHash = new HashMap<>();\n+\n+        HashMap<Cluster, ClusterNode> clusterNodes = new HashMap<>();\n+        HashMap<Cluster, Set<ClusterInputSlotNode>> clusterInputSlotSet = new HashMap<>();\n+        HashMap<Cluster, Set<ClusterOutputSlotNode>> clusterOutputSlotSet = new HashMap<>();\n+        Set<Link> clusterEdges = new HashSet<>();\n+        Set<Link> interClusterEdges = new HashSet<>();\n+        HashMap<Link, ClusterOutgoingConnection> linkClusterOutgoingConnection = new HashMap<>();\n+        HashMap<Link, InterClusterConnection> linkInterClusterConnection = new HashMap<>();\n+        HashMap<Link, ClusterIngoingConnection> linkClusterIngoingConnection = new HashMap<>();\n+        Set<ClusterNode> clusterNodeSet = new HashSet<>();\n@@ -94,6 +79,5 @@\n-            lists.put(c, new ArrayList<Vertex>());\n-            listsConnection.put(c, new ArrayList<Link>());\n-            clusterInputSlotHash.put(c, new HashMap<Port, ClusterInputSlotNode>());\n-            clusterOutputSlotHash.put(c, new HashMap<Port, ClusterOutputSlotNode>());\n-            clusterOutputSlotSet.put(c, new TreeSet<ClusterOutputSlotNode>());\n-            clusterInputSlotSet.put(c, new TreeSet<ClusterInputSlotNode>());\n+            listsConnection.put(c, new ArrayList<>());\n+            clusterInputSlotHash.put(c, new HashMap<>());\n+            clusterOutputSlotHash.put(c, new HashMap<>());\n+            clusterOutputSlotSet.put(c, new TreeSet<>());\n+            clusterInputSlotSet.put(c, new TreeSet<>());\n@@ -159,1 +143,1 @@\n-                    outputSlotNode = new ClusterOutputSlotNode(clusterNodes.get(fromCluster), \"Out \" + fromCluster.toString() + \" \" + samePort.toString());\n+                    outputSlotNode = new ClusterOutputSlotNode(clusterNodes.get(fromCluster), \"Out \" + fromCluster.toString() + \" \" + samePort);\n@@ -174,1 +158,1 @@\n-                    inputSlotNode = new ClusterInputSlotNode(clusterNodes.get(toCluster), \"In \" + toCluster.toString() + \" \" + samePort.toString());\n+                    inputSlotNode = new ClusterInputSlotNode(clusterNodes.get(toCluster), \"In \" + toCluster.toString() + \" \" + samePort);\n@@ -179,1 +163,0 @@\n-                inputSlotNode.setIngoingConnection(conn);\n@@ -181,3 +164,1 @@\n-                if (samePort != null) {\n-                    clusterInputSlotHash.get(toCluster).put(samePort, inputSlotNode);\n-                }\n+                clusterInputSlotHash.get(toCluster).put(samePort, inputSlotNode);\n@@ -197,1 +178,1 @@\n-            new Timing(\"Child timing\");\n+            t = new Timing(\"Child timing\");\n@@ -203,1 +184,1 @@\n-            subManager.doLayout(new LayoutGraph(n.getSubEdges(), n.getSubNodes()), new HashSet<Link>());\n+            subManager.doLayout(new LayoutGraph(n.getSubEdges(), n.getSubNodes()), new HashSet<>());\n@@ -238,1 +219,1 @@\n-                List<Point> points = new ArrayList<Point>();\n+                List<Point> points = new ArrayList<>();\n","filename":"src\/utils\/IdealGraphVisualizer\/HierarchicalLayout\/src\/main\/java\/com\/sun\/hotspot\/igv\/hierarchicallayout\/HierarchicalClusterLayoutManager.java","additions":27,"deletions":46,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -59,3 +59,3 @@\n-    private Combine combine;\n-    private int dummyWidth;\n-    private int dummyHeight;\n+    private final Combine combine;\n+    private final int dummyWidth;\n+    private final int dummyHeight;\n@@ -74,1 +74,0 @@\n-    private HashMap<LayoutEdge, LayoutEdge> bottomEdgeHash;\n@@ -81,1 +80,1 @@\n-    private Set<Link> linksToFollow;\n+    private final Set<Link> linksToFollow;\n@@ -126,1 +125,1 @@\n-    private abstract class AlgorithmPart {\n+    private abstract static class AlgorithmPart {\n@@ -162,4 +161,0 @@\n-    public HierarchicalLayoutManager() {\n-        this(Combine.NONE);\n-    }\n-\n@@ -186,4 +181,0 @@\n-    public int getMaxLayerLength() {\n-        return maxLayerLength;\n-    }\n-\n@@ -219,1 +210,1 @@\n-        doLayout(graph, new HashSet<Link>());\n+        doLayout(graph, new HashSet<>());\n@@ -234,1 +225,0 @@\n-        bottomEdgeHash = new HashMap<>();\n@@ -455,1 +445,0 @@\n-                                \/\/checkPoints(points);\n@@ -479,1 +468,0 @@\n-                            \/\/checkPoints(points);\n@@ -541,14 +529,7 @@\n-    private static class Segment {\n-\n-        public float d;\n-        public int orderNumber = -1;\n-        public ArrayList<LayoutNode> nodes = new ArrayList<>();\n-        public HashSet<Segment> succs = new HashSet<>();\n-        public HashSet<Segment> preds = new HashSet<>();\n-        public Region region;\n-    }\n-    private static final Comparator<Segment> segmentComparator = new Comparator<Segment>() {\n-\n-        @Override\n-        public int compare(Segment s1, Segment s2) {\n-            return s1.orderNumber - s2.orderNumber;\n+    private static final Comparator<LayoutNode> nodePositionComparator = Comparator.comparingInt(n -> n.pos);\n+    private static final Comparator<LayoutNode> nodeProcessingDownComparator = (n1, n2) -> {\n+        int n1VIP = 0;\n+        for (LayoutEdge e : n1.preds) {\n+            if (e.vip) {\n+                n1VIP++;\n+            }\n@@ -556,15 +537,5 @@\n-    };\n-\n-    private static class Region {\n-\n-        public float d;\n-        public int minOrderNumber;\n-        public SortedSet<Segment> segments = new TreeSet<>(segmentComparator);\n-        public HashSet<Region> succs = new HashSet<>(4);\n-        public HashSet<Region> preds = new HashSet<>(4);\n-    }\n-    private static final Comparator<Region> regionComparator = new Comparator<Region>() {\n-\n-        @Override\n-        public int compare(Region r1, Region r2) {\n-            return r1.minOrderNumber - r2.minOrderNumber;\n+        int n2VIP = 0;\n+        for (LayoutEdge e : n2.preds) {\n+            if (e.vip) {\n+                n2VIP++;\n+            }\n@@ -572,6 +543,2 @@\n-    };\n-    private static final Comparator<LayoutNode> nodePositionComparator = new Comparator<LayoutNode>() {\n-\n-        @Override\n-        public int compare(LayoutNode n1, LayoutNode n2) {\n-            return n1.pos - n2.pos;\n+        if (n1VIP != n2VIP) {\n+            return n2VIP - n1VIP;\n@@ -579,25 +546,1 @@\n-    };\n-    private static final Comparator<LayoutNode> nodeProcessingDownComparator = new Comparator<LayoutNode>() {\n-        @Override\n-        public int compare(LayoutNode n1, LayoutNode n2) {\n-            int n1VIP = 0;\n-            for (LayoutEdge e : n1.preds) {\n-                if (e.vip) {\n-                    n1VIP++;\n-                }\n-            }\n-            int n2VIP = 0;\n-            for (LayoutEdge e : n2.preds) {\n-                if (e.vip) {\n-                    n2VIP++;\n-                }\n-            }\n-            if (n1VIP != n2VIP) {\n-                return n2VIP - n1VIP;\n-            }\n-            if (n1.vertex == null) {\n-                if (n2.vertex == null) {\n-                    return 0;\n-                }\n-                return -1;\n-            }\n+        if (n1.vertex == null) {\n@@ -605,1 +548,1 @@\n-                return 1;\n+                return 0;\n@@ -607,1 +550,1 @@\n-            return n1.preds.size() - n2.preds.size();\n+            return -1;\n@@ -609,0 +552,4 @@\n+        if (n2.vertex == null) {\n+            return 1;\n+        }\n+        return n1.preds.size() - n2.preds.size();\n@@ -610,15 +557,5 @@\n-    private static final Comparator<LayoutNode> nodeProcessingUpComparator = new Comparator<LayoutNode>() {\n-\n-        @Override\n-        public int compare(LayoutNode n1, LayoutNode n2) {\n-            int n1VIP = 0;\n-            for (LayoutEdge e : n1.succs) {\n-                if (e.vip) {\n-                    n1VIP++;\n-                }\n-            }\n-            int n2VIP = 0;\n-            for (LayoutEdge e : n2.succs) {\n-                if (e.vip) {\n-                    n2VIP++;\n-                }\n+    private static final Comparator<LayoutNode> nodeProcessingUpComparator = (n1, n2) -> {\n+        int n1VIP = 0;\n+        for (LayoutEdge e : n1.succs) {\n+            if (e.vip) {\n+                n1VIP++;\n@@ -626,8 +563,5 @@\n-            if (n1VIP != n2VIP) {\n-                return n2VIP - n1VIP;\n-            }\n-            if (n1.vertex == null) {\n-                if (n2.vertex == null) {\n-                    return 0;\n-                }\n-                return -1;\n+        }\n+        int n2VIP = 0;\n+        for (LayoutEdge e : n2.succs) {\n+            if (e.vip) {\n+                n2VIP++;\n@@ -635,0 +569,5 @@\n+        }\n+        if (n1VIP != n2VIP) {\n+            return n2VIP - n1VIP;\n+        }\n+        if (n1.vertex == null) {\n@@ -636,1 +575,1 @@\n-                return 1;\n+                return 0;\n@@ -638,1 +577,1 @@\n-            return n1.succs.size() - n2.succs.size();\n+            return -1;\n@@ -640,0 +579,4 @@\n+        if (n2.vertex == null) {\n+            return 1;\n+        }\n+        return n1.succs.size() - n2.succs.size();\n@@ -686,1 +629,1 @@\n-                sweepUp(false);\n+                sweepUp();\n@@ -692,1 +635,1 @@\n-            sweepUp(true);\n+            sweepUp();\n@@ -697,2 +640,0 @@\n-                \/\/               space[i] = new ArrayList<>();\n-                int curX = 0;\n@@ -701,1 +642,0 @@\n-\/\/                    curX += n.width + xOffset;\n@@ -784,1 +724,1 @@\n-        private void sweepUp(boolean onlyDummies) {\n+        private void sweepUp() {\n@@ -794,10 +734,0 @@\n-        private void doubleSweep() {\n-            for (int i = layers.length - 2; i >= 0; i--) {\n-                NodeRow r = new NodeRow(space[i]);\n-                for (LayoutNode n : upProcessingOrder[i]) {\n-                    int optimal = calculateOptimalBoth(n);\n-                    r.insert(n, optimal);\n-                }\n-            }\n-        }\n-\n@@ -817,2 +747,2 @@\n-        private TreeSet<LayoutNode> treeSet;\n-        private ArrayList<Integer> space;\n+        private final TreeSet<LayoutNode> treeSet;\n+        private final ArrayList<Integer> space;\n@@ -835,1 +765,1 @@\n-            LayoutNode leftNeighbor = null;\n+            LayoutNode leftNeighbor;\n@@ -846,1 +776,1 @@\n-                LayoutNode rightNeighbor = null;\n+                LayoutNode rightNeighbor;\n@@ -854,5 +784,1 @@\n-                if (pos > maxX) {\n-                    n.x = maxX;\n-                } else {\n-                    n.x = pos;\n-                }\n+                n.x = Math.min(pos, maxX);\n@@ -866,7 +792,1 @@\n-    private static Comparator<LayoutNode> crossingNodeComparator = new Comparator<LayoutNode>() {\n-\n-        @Override\n-        public int compare(LayoutNode n1, LayoutNode n2) {\n-            return n1.crossingNumber - n2.crossingNumber;\n-        }\n-    };\n+    private static final Comparator<LayoutNode> crossingNodeComparator = Comparator.comparingInt(n -> n.crossingNumber);\n@@ -948,2 +868,1 @@\n-\n-            for (int i = 0; i < layers.length; i++) {\n+            for (List<LayoutNode> layer : layers) {\n@@ -951,1 +870,1 @@\n-                for (LayoutNode n : layers[i]) {\n+                for (LayoutNode n : layer) {\n@@ -1091,1 +1010,1 @@\n-            for (int i = 0; i < layers.length; i++) {\n+            for (List<LayoutNode> layer : layers) {\n@@ -1095,1 +1014,1 @@\n-                for (LayoutNode n : layers[i]) {\n+                for (LayoutNode n : layer) {\n@@ -1102,1 +1021,1 @@\n-                for (LayoutNode n : layers[i]) {\n+                for (LayoutNode n : layer) {\n@@ -1150,7 +1069,1 @@\n-                Comparator<LayoutEdge> comparator = new Comparator<LayoutEdge>() {\n-\n-                    @Override\n-                    public int compare(LayoutEdge e1, LayoutEdge e2) {\n-                        return e1.to.layer - e2.to.layer;\n-                    }\n-                };\n+                Comparator<LayoutEdge> comparator = Comparator.comparingInt(e -> e.to.layer);\n@@ -1168,1 +1081,1 @@\n-                            if (maxLayerLength != -1 && e.to.layer - e.from.layer > maxLayerLength\/* && e.to.preds.size() > 1 && e.from.succs.size() > 1*\/) {\n+                            if (maxLayerLength != -1 && e.to.layer - e.from.layer > maxLayerLength) {\n@@ -1173,1 +1086,1 @@\n-                                LayoutEdge topEdge = null;\n+                                LayoutEdge topEdge;\n@@ -1196,1 +1109,1 @@\n-                                    topEdge.relativeTo = topNode.width \/ 2;\n+                                    topEdge.relativeTo = 0;\n@@ -1203,1 +1116,1 @@\n-                                    bottomNodeHash.put(e.relativeFrom, new HashMap<Integer, LayoutNode>());\n+                                    bottomNodeHash.put(e.relativeFrom, new HashMap<>());\n@@ -1208,1 +1121,1 @@\n-                                LayoutNode bottomNode = null;\n+                                LayoutNode bottomNode;\n@@ -1229,1 +1142,0 @@\n-                                bottomEdgeHash.put(topEdge, bottomEdge);\n@@ -1235,1 +1147,1 @@\n-                                    portHash.put(i, new ArrayList<LayoutEdge>());\n+                                    portHash.put(i, new ArrayList<>());\n@@ -1568,1 +1480,1 @@\n-                int curX = 0;\n+                int curY = 0;\n@@ -1580,2 +1492,2 @@\n-                    startPoints.add(new Point(curWidth, curX));\n-                    startPoints.add(new Point(pos, curX));\n+                    startPoints.add(new Point(curWidth, curY));\n+                    startPoints.add(new Point(pos, curY));\n@@ -1587,2 +1499,2 @@\n-                    node.inOffsets.put(pos, -curX);\n-                    curX += offset;\n+                    node.inOffsets.put(pos, -curY);\n+                    curY += offset;\n@@ -1600,7 +1512,1 @@\n-                if (hasReversedDown) {\n-                    curX = -offset;\n-                } else {\n-                    curX = offset;\n-                }\n-\n-                curX = 0;\n+                int curX = 0;\n@@ -1764,7 +1670,4 @@\n-    private Comparator<Link> linkComparator = new Comparator<Link>() {\n-\n-        @Override\n-        public int compare(Link l1, Link l2) {\n-            if (l1.isVIP() && !l2.isVIP()) {\n-                return -1;\n-            }\n+    private final Comparator<Link> linkComparator = (l1, l2) -> {\n+        if (l1.isVIP() && !l2.isVIP()) {\n+            return -1;\n+        }\n@@ -1772,3 +1675,3 @@\n-            if (!l1.isVIP() && l2.isVIP()) {\n-                return 1;\n-            }\n+        if (!l1.isVIP() && l2.isVIP()) {\n+            return 1;\n+        }\n@@ -1776,13 +1679,10 @@\n-            int result = l1.getFrom().getVertex().compareTo(l2.getFrom().getVertex());\n-            if (result != 0) {\n-                return result;\n-            }\n-            result = l1.getTo().getVertex().compareTo(l2.getTo().getVertex());\n-            if (result != 0) {\n-                return result;\n-            }\n-            result = l1.getFrom().getRelativePosition().x - l2.getFrom().getRelativePosition().x;\n-            if (result != 0) {\n-                return result;\n-            }\n-            result = l1.getTo().getRelativePosition().x - l2.getTo().getRelativePosition().x;\n+        int result = l1.getFrom().getVertex().compareTo(l2.getFrom().getVertex());\n+        if (result != 0) {\n+            return result;\n+        }\n+        result = l1.getTo().getVertex().compareTo(l2.getTo().getVertex());\n+        if (result != 0) {\n+            return result;\n+        }\n+        result = l1.getFrom().getRelativePosition().x - l2.getFrom().getRelativePosition().x;\n+        if (result != 0) {\n@@ -1791,0 +1691,2 @@\n+        result = l1.getTo().getRelativePosition().x - l2.getTo().getRelativePosition().x;\n+        return result;\n@@ -1800,5 +1702,2 @@\n-            Collections.sort(vertices,\n-                             (Vertex a, Vertex b) ->\n-                             a.isRoot() == b.isRoot() ?\n-                             a.compareTo(b) :\n-                             Boolean.compare(b.isRoot(), a.isRoot()));\n+            vertices.sort((Vertex a, Vertex b) ->\n+                    a.isRoot() == b.isRoot() ? a.compareTo(b) : Boolean.compare(b.isRoot(), a.isRoot()));\n","filename":"src\/utils\/IdealGraphVisualizer\/HierarchicalLayout\/src\/main\/java\/com\/sun\/hotspot\/igv\/hierarchicallayout\/HierarchicalLayoutManager.java","additions":96,"deletions":197,"binary":false,"changes":293,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+import com.sun.hotspot.igv.layout.Cluster;\n@@ -28,1 +29,0 @@\n-import com.sun.hotspot.igv.layout.Cluster;\n@@ -39,2 +39,2 @@\n-    private Port inputSlot;\n-    private Port outputSlot;\n+    private final Port inputSlot;\n+    private final Port outputSlot;\n@@ -42,2 +42,0 @@\n-    private ClusterInputSlotNode inputSlotNode;\n-    private ClusterOutputSlotNode outputSlotNode;\n@@ -46,2 +44,0 @@\n-        this.outputSlotNode = outputSlotNode;\n-        this.inputSlotNode = inputSlotNode;\n@@ -50,5 +46,1 @@\n-        intermediatePoints = new ArrayList<Point>();\n-    }\n-\n-    public ClusterOutputSlotNode getOutputSlotNode() {\n-        return outputSlotNode;\n+        this.intermediatePoints = new ArrayList<>();\n","filename":"src\/utils\/IdealGraphVisualizer\/HierarchicalLayout\/src\/main\/java\/com\/sun\/hotspot\/igv\/hierarchicallayout\/InterClusterConnection.java","additions":4,"deletions":12,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-        doLayout(graph, new HashSet<Link>());\n+        doLayout(graph, new HashSet<>());\n","filename":"src\/utils\/IdealGraphVisualizer\/HierarchicalLayout\/src\/main\/java\/com\/sun\/hotspot\/igv\/hierarchicallayout\/LinearLayoutManager.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,161 +0,0 @@\n-\/*\n- * Copyright (c) 2008, 2015, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-package com.sun.hotspot.igv.hierarchicallayout;\n-\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.List;\n-\n-\/**\n- *\n- * @author Thomas Wuerthinger\n- *\/\n-public class Node<N, E> {\n-\n-    private N data;\n-    private List<Edge<N, E>> inEdges;\n-    private List<Edge<N, E>> outEdges;\n-    private boolean visited;\n-    private boolean active;\n-    private boolean reachable;\n-    private Graph<N, E> graph;\n-\n-    protected boolean isVisited() {\n-        return visited;\n-    }\n-\n-    protected void setVisited(boolean b) {\n-        visited = b;\n-    }\n-\n-    protected boolean isReachable() {\n-        return reachable;\n-    }\n-\n-    protected void setReachable(boolean b) {\n-        reachable = b;\n-    }\n-\n-    protected boolean isActive() {\n-        return active;\n-    }\n-\n-    protected void setActive(boolean b) {\n-        active = b;\n-    }\n-\n-    public int getInDegree() {\n-        return getInDegree(true);\n-    }\n-\n-    public int getInDegree(boolean countSelfLoops) {\n-        if (countSelfLoops) {\n-            return inEdges.size();\n-        } else {\n-            int cnt = 0;\n-            for (Edge<N, E> e : inEdges) {\n-                if (e.getSource() != this) {\n-                    cnt++;\n-                }\n-            }\n-            return cnt;\n-        }\n-    }\n-\n-    public int getOutDegree() {\n-        return outEdges.size();\n-    }\n-\n-    protected Node(Graph<N, E> graph, N data) {\n-        setData(data);\n-        this.graph = graph;\n-        inEdges = new ArrayList<>();\n-        outEdges = new ArrayList<>();\n-    }\n-\n-    protected void addInEdge(Edge<N, E> e) {\n-        inEdges.add(e);\n-    }\n-\n-    public Graph<N, E> getGraph() {\n-        return graph;\n-    }\n-\n-    protected void addOutEdge(Edge<N, E> e) {\n-        outEdges.add(e);\n-    }\n-\n-    protected void removeInEdge(Edge<N, E> e) {\n-        \/\/assert inEdges.contains(e);\n-        inEdges.remove(e);\n-    }\n-\n-    protected void removeOutEdge(Edge<N, E> e) {\n-        \/\/assert outEdges.contains(e);\n-        outEdges.remove(e);\n-    }\n-\n-    public List<Edge<N, E>> getInEdges() {\n-        return Collections.unmodifiableList(inEdges);\n-    }\n-\n-    public List<Edge<N, E>> getOutEdges() {\n-        return Collections.unmodifiableList(outEdges);\n-    }\n-\n-    public List<Node<N, E>> getSuccessors() {\n-        ArrayList<Node<N, E>> succ = new ArrayList<>();\n-        for (Edge<N, E> e : getOutEdges()) {\n-            Node<N, E> n = e.getDest();\n-            if (!succ.contains(n)) {\n-                succ.add(n);\n-            }\n-        }\n-        return succ;\n-    }\n-\n-    public List<Node<N, E>> getPredecessors() {\n-        ArrayList<Node<N, E>> pred = new ArrayList<>();\n-        for (Edge<N, E> e : getInEdges()) {\n-            Node<N, E> n = e.getSource();\n-            if (!pred.contains(n)) {\n-                pred.add(n);\n-            }\n-        }\n-        return pred;\n-    }\n-\n-    public N getData() {\n-        return data;\n-    }\n-\n-    public void setData(N d) {\n-        data = d;\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return \"Node: \" + data;\n-    }\n-}\n","filename":"src\/utils\/IdealGraphVisualizer\/HierarchicalLayout\/src\/main\/java\/com\/sun\/hotspot\/igv\/hierarchicallayout\/Node.java","additions":0,"deletions":161,"binary":false,"changes":161,"status":"deleted"},{"patch":"@@ -34,1 +34,1 @@\n-    private String name;\n+    private final String name;\n@@ -52,1 +52,1 @@\n-        System.out.println(toString());\n+        System.out.println();\n","filename":"src\/utils\/IdealGraphVisualizer\/HierarchicalLayout\/src\/main\/java\/com\/sun\/hotspot\/igv\/hierarchicallayout\/Timing.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-    public Cluster getOuter();\n+    void setBounds(Rectangle r);\n@@ -38,1 +38,1 @@\n-    public void setBounds(Rectangle r);\n+    Set<? extends Cluster> getSuccessors();\n@@ -40,3 +40,1 @@\n-    public Set<? extends Cluster> getSuccessors();\n-\n-    public Dimension getNodeOffset();\n+    Dimension getNodeOffset();\n","filename":"src\/utils\/IdealGraphVisualizer\/Layout\/src\/main\/java\/com\/sun\/hotspot\/igv\/layout\/Cluster.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -34,5 +34,5 @@\n-    private Set<? extends Link> links;\n-    private SortedSet<Vertex> vertices;\n-    private HashMap<Vertex, Set<Port>> inputPorts;\n-    private HashMap<Vertex, Set<Port>> outputPorts;\n-    private HashMap<Port, Set<Link>> portLinks;\n+    private final Set<? extends Link> links;\n+    private final SortedSet<Vertex> vertices;\n+    private final HashMap<Vertex, Set<Port>> inputPorts;\n+    private final HashMap<Vertex, Set<Port>> outputPorts;\n+    private final HashMap<Port, Set<Link>> portLinks;\n@@ -41,1 +41,1 @@\n-        this(links, new HashSet<Vertex>());\n+        this(links, new HashSet<>());\n@@ -64,2 +64,2 @@\n-                outputPorts.put(v1, new HashSet<Port>(1));\n-                inputPorts.put(v1, new HashSet<Port>(3));\n+                outputPorts.put(v1, new HashSet<>(1));\n+                inputPorts.put(v1, new HashSet<>(3));\n@@ -73,2 +73,2 @@\n-                outputPorts.put(v2, new HashSet<Port>(1));\n-                inputPorts.put(v2, new HashSet<Port>(3));\n+                outputPorts.put(v2, new HashSet<>(1));\n+                inputPorts.put(v2, new HashSet<>(3));\n@@ -83,1 +83,1 @@\n-                portLinks.put(p2, new HashSet<Link>(3));\n+                portLinks.put(p2, new HashSet<>(3));\n@@ -95,2 +95,2 @@\n-                outputPorts.put(v, new HashSet<Port>(1));\n-                inputPorts.put(v, new HashSet<Port>(3));\n+                outputPorts.put(v, new HashSet<>(1));\n+                inputPorts.put(v, new HashSet<>(3));\n@@ -98,1 +98,0 @@\n-                vertices.contains(v);\n@@ -187,1 +186,1 @@\n-        return findRootVertices(new HashSet<Vertex>());\n+        return findRootVertices(new HashSet<>());\n@@ -192,1 +191,1 @@\n-        SortedSet<Cluster> clusters = new TreeSet<Cluster>();\n+        SortedSet<Cluster> clusters = new TreeSet<>();\n","filename":"src\/utils\/IdealGraphVisualizer\/Layout\/src\/main\/java\/com\/sun\/hotspot\/igv\/layout\/LayoutGraph.java","additions":15,"deletions":16,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-    public void doLayout(LayoutGraph graph);\n+    void doLayout(LayoutGraph graph);\n@@ -36,1 +36,1 @@\n-    public void doLayout(LayoutGraph graph, Set<? extends Link> importantLinks);\n+    void doLayout(LayoutGraph graph, Set<? extends Link> importantLinks);\n","filename":"src\/utils\/IdealGraphVisualizer\/Layout\/src\/main\/java\/com\/sun\/hotspot\/igv\/layout\/LayoutManager.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-    public Port getFrom();\n+    Port getFrom();\n@@ -37,1 +37,1 @@\n-    public Cluster getFromCluster();\n+    Cluster getFromCluster();\n@@ -39,1 +39,1 @@\n-    public Port getTo();\n+    Port getTo();\n@@ -41,1 +41,1 @@\n-    public Cluster getToCluster();\n+    Cluster getToCluster();\n@@ -43,1 +43,1 @@\n-    public boolean isVIP();\n+    boolean isVIP();\n@@ -45,1 +45,1 @@\n-    public List<Point> getControlPoints();\n+    List<Point> getControlPoints();\n@@ -47,1 +47,1 @@\n-    public void setControlPoints(List<Point> list);\n+    void setControlPoints(List<Point> list);\n","filename":"src\/utils\/IdealGraphVisualizer\/Layout\/src\/main\/java\/com\/sun\/hotspot\/igv\/layout\/Link.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-    public Vertex getVertex();\n+    Vertex getVertex();\n@@ -36,1 +36,1 @@\n-    public Point getRelativePosition();\n+    Point getRelativePosition();\n","filename":"src\/utils\/IdealGraphVisualizer\/Layout\/src\/main\/java\/com\/sun\/hotspot\/igv\/layout\/Port.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-    public Dimension getSize();\n+    Dimension getSize();\n@@ -37,1 +37,1 @@\n-    public Point getPosition();\n+    Point getPosition();\n@@ -39,1 +39,1 @@\n-    public void setPosition(Point p);\n+    void setPosition(Point p);\n@@ -41,1 +41,1 @@\n-    public boolean isRoot();\n+    boolean isRoot();\n@@ -43,1 +43,1 @@\n-    public Cluster getCluster();\n+    Cluster getCluster();\n","filename":"src\/utils\/IdealGraphVisualizer\/Layout\/src\/main\/java\/com\/sun\/hotspot\/igv\/layout\/Vertex.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -27,2 +27,0 @@\n-import com.sun.hotspot.igv.data.GraphDocument;\n-import com.sun.hotspot.igv.data.serialization.BinaryParser;\n@@ -36,1 +34,0 @@\n-    private final boolean binary;\n@@ -38,1 +35,0 @@\n-    private final GraphDocument rootDocument;\n@@ -41,1 +37,1 @@\n-    public Client(SocketChannel socket, GraphDocument rootDocument, GroupCallback callback, boolean  binary) {\n+    public Client(SocketChannel socket, GroupCallback callback) {\n@@ -44,2 +40,0 @@\n-        this.binary = binary;\n-        this.rootDocument = rootDocument;\n@@ -54,7 +48,2 @@\n-            if (binary) {\n-                new BinaryParser(channel, null, rootDocument, callback).parse();\n-            } else {\n-                \/\/ signal readiness to client VM (old protocol)\n-                channel.socket().getOutputStream().write('y');\n-                new Parser(channel, null, callback).parse();\n-            }\n+            channel.socket().getOutputStream().write('y');\n+            new Parser(channel, null, callback).parse();\n","filename":"src\/utils\/IdealGraphVisualizer\/NetworkConnection\/src\/main\/java\/com\/sun\/hotspot\/igv\/connection\/Client.java","additions":3,"deletions":14,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import com.sun.hotspot.igv.data.GraphDocument;\n@@ -45,1 +44,0 @@\n-    private final boolean binary;\n@@ -47,1 +45,0 @@\n-    private final GraphDocument rootDocument;\n@@ -52,3 +49,1 @@\n-    public Server(GraphDocument rootDocument, GroupCallback callback, boolean binary) {\n-        this.binary = binary;\n-        this.rootDocument = rootDocument;\n+    public Server(GroupCallback callback) {\n@@ -62,2 +57,1 @@\n-\n-        int curPort = Integer.parseInt(Settings.get().get(binary ? Settings.PORT_BINARY : Settings.PORT, binary ? Settings.PORT_BINARY_DEFAULT : Settings.PORT_DEFAULT));\n+        int curPort = Integer.parseInt(Settings.get().get(Settings.PORT, Settings.PORT_DEFAULT));\n@@ -70,2 +64,1 @@\n-\n-        int curPort = Integer.parseInt(Settings.get().get(binary ? Settings.PORT_BINARY : Settings.PORT, binary ? Settings.PORT_BINARY_DEFAULT : Settings.PORT_DEFAULT));\n+        int curPort = Integer.parseInt(Settings.get().get(Settings.PORT, Settings.PORT_DEFAULT));\n@@ -77,1 +70,1 @@\n-            NotifyDescriptor message = new NotifyDescriptor.Message(\"Could not create server. Listening for incoming binary data is disabled.\", NotifyDescriptor.ERROR_MESSAGE);\n+            NotifyDescriptor message = new NotifyDescriptor.Message(\"Could not create server. Listening for incoming data is disabled.\", NotifyDescriptor.ERROR_MESSAGE);\n@@ -93,1 +86,1 @@\n-                        RequestProcessor.getDefault().post(new Client(clientSocket, rootDocument, callback, binary), 0, Thread.MAX_PRIORITY);\n+                        RequestProcessor.getDefault().post(new Client(clientSocket, callback), 0, Thread.MAX_PRIORITY);\n@@ -96,1 +89,1 @@\n-                        NotifyDescriptor message = new NotifyDescriptor.Message(\"Error during listening for incoming connections. Listening for incoming binary data is disabled.\", NotifyDescriptor.ERROR_MESSAGE);\n+                        NotifyDescriptor message = new NotifyDescriptor.Message(\"Error during listening for incoming connections. Listening for incoming data is disabled.\", NotifyDescriptor.ERROR_MESSAGE);\n","filename":"src\/utils\/IdealGraphVisualizer\/NetworkConnection\/src\/main\/java\/com\/sun\/hotspot\/igv\/connection\/Server.java","additions":6,"deletions":13,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -38,5 +38,5 @@\n-    private static SelectionCoordinator singleInstance = new SelectionCoordinator();\n-    private Set<Object> selectedObjects;\n-    private Set<Object> highlightedObjects;\n-    private ChangedEvent<SelectionCoordinator> selectedChangedEvent;\n-    private ChangedEvent<SelectionCoordinator> highlightedChangedEvent;\n+    private static final SelectionCoordinator singleInstance = new SelectionCoordinator();\n+    private final Set<Integer> selectedObjects;\n+    private final Set<Integer> highlightedObjects;\n+    private final ChangedEvent<SelectionCoordinator> selectedChangedEvent;\n+    private final ChangedEvent<SelectionCoordinator> highlightedChangedEvent;\n@@ -55,1 +55,1 @@\n-    public Set<Object> getSelectedObjects() {\n+    public Set<Integer> getSelectedObjects() {\n@@ -59,1 +59,1 @@\n-    public Set<Object> getHighlightedObjects() {\n+    public Set<Integer> getHighlightedObjects() {\n@@ -71,29 +71,0 @@\n-    public void addHighlighted(Object o) {\n-        if (!highlightedObjects.contains(o)) {\n-            highlightedObjects.add(o);\n-            highlightedObjectsChanged();\n-        }\n-    }\n-\n-    public void removeHighlighted(Object o) {\n-        if (highlightedObjects.contains(o)) {\n-            highlightedObjects.remove(o);\n-            highlightedObjectsChanged();\n-        }\n-    }\n-\n-    public void addAllHighlighted(Set<? extends Object> s) {\n-        int oldSize = highlightedObjects.size();\n-        highlightedObjects.addAll(s);\n-        if (oldSize != highlightedObjects.size()) {\n-            highlightedObjectsChanged();\n-        }\n-    }\n-\n-    public void removeAllHighlighted(Set<? extends Object> s) {\n-        int oldSize = highlightedObjects.size();\n-        highlightedObjects.removeAll(s);\n-        if (oldSize != highlightedObjects.size()) {\n-            highlightedObjectsChanged();\n-        }\n-    }\n@@ -101,22 +72,1 @@\n-    private void highlightedObjectsChanged() {\n-        highlightedChangedEvent.fire();\n-\n-    }\n-\n-    public void addAllSelected(Set<? extends Object> s) {\n-        int oldSize = selectedObjects.size();\n-        selectedObjects.addAll(s);\n-        if (oldSize != selectedObjects.size()) {\n-            selectedObjectsChanged();\n-        }\n-    }\n-\n-    public void removeAllSelected(Set<? extends Object> s) {\n-        int oldSize = selectedObjects.size();\n-        selectedObjects.removeAll(s);\n-        if (oldSize != selectedObjects.size()) {\n-            selectedObjectsChanged();\n-        }\n-    }\n-\n-    public void setSelectedObjects(Set<? extends Object> s) {\n+    public void setSelectedObjects(Set<Integer> s) {\n@@ -126,5 +76,1 @@\n-        selectedObjectsChanged();\n-    }\n-\n-    private void selectedObjectsChanged() {\n-        selectedChangedEvent.fire();\n+        getSelectedChangedEvent().fire();\n@@ -133,1 +79,1 @@\n-    public void setHighlightedObjects(Set<? extends Object> s) {\n+    public void setHighlightedObjects(Set<Integer> s) {\n@@ -135,3 +81,3 @@\n-        this.highlightedObjects.clear();\n-        this.highlightedObjects.addAll(s);\n-        highlightedObjectsChanged();\n+        highlightedObjects.clear();\n+        highlightedObjects.addAll(s);\n+        getHighlightedChangedEvent().fire();\n","filename":"src\/utils\/IdealGraphVisualizer\/SelectionCoordinator\/src\/main\/java\/com\/sun\/hotspot\/igv\/selectioncoordinator\/SelectionCoordinator.java","additions":13,"deletions":67,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * published by the Free Software Foundation.  Oracle designates this\n+ * published by the Free Software Foundation. Oracle designates this\n@@ -13,1 +13,1 @@\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License\n@@ -27,0 +27,3 @@\n+import com.ibm.wala.util.graph.Graph;\n+import com.ibm.wala.util.graph.dominators.Dominators;\n+import com.ibm.wala.util.graph.impl.SlowSparseNumberedGraph;\n@@ -36,3 +39,0 @@\n-import com.ibm.wala.util.graph.Graph;\n-import com.ibm.wala.util.graph.impl.SlowSparseNumberedGraph;\n-import com.ibm.wala.util.graph.dominators.Dominators;\n@@ -125,7 +125,1 @@\n-    private static final Comparator<InputEdge> edgeComparator = new Comparator<InputEdge>() {\n-\n-        @Override\n-        public int compare(InputEdge o1, InputEdge o2) {\n-            return o1.getToIndex() - o2.getToIndex();\n-        }\n-    };\n+    private static final Comparator<InputEdge> edgeComparator = Comparator.comparingInt(InputEdge::getToIndex);\n@@ -176,1 +170,1 @@\n-            Set<Node> blockTerminators = new HashSet<Node>();\n+            Set<Node> blockTerminators = new HashSet<>();\n@@ -286,1 +280,1 @@\n-        controlSuccs.put(n, Arrays.asList(s));\n+        controlSuccs.put(n, Collections.singletonList(s));\n@@ -291,1 +285,1 @@\n-        controlSuccs.put(p, Arrays.asList(n));\n+        controlSuccs.put(p, Collections.singletonList(n));\n@@ -376,16 +370,13 @@\n-    private static final Comparator<Node> schedulePriority = new Comparator<Node>(){\n-            @Override\n-            public int compare(Node n1, Node n2) {\n-                \/\/ Order by rank, then idx.\n-                int r1 = n1.rank, r2 = n2.rank;\n-                int o1, o2;\n-                if (r1 != r2) { \/\/ Different rank.\n-                    o1 = r1;\n-                    o2 = r2;\n-                } else { \/\/ Same rank, order by idx.\n-                    o1 = Integer.parseInt(n1.inputNode.getProperties().get(\"idx\"));\n-                    o2 = Integer.parseInt(n2.inputNode.getProperties().get(\"idx\"));\n-                }\n-                return Integer.compare(o1, o2);\n-            };\n-        };\n+    private static final Comparator<Node> schedulePriority = (n1, n2) -> {\n+        \/\/ Order by rank, then idx.\n+        int r1 = n1.rank, r2 = n2.rank;\n+        int o1, o2;\n+        if (r1 != r2) { \/\/ Different rank.\n+            o1 = r1;\n+            o2 = r2;\n+        } else { \/\/ Same rank, order by idx.\n+            o1 = Integer.parseInt(n1.inputNode.getProperties().get(\"idx\"));\n+            o2 = Integer.parseInt(n2.inputNode.getProperties().get(\"idx\"));\n+        }\n+        return Integer.compare(o1, o2);\n+    };\n@@ -394,1 +385,1 @@\n-        List<InputNode> schedule = new ArrayList<InputNode>();\n+        List<InputNode> schedule = new ArrayList<>();\n@@ -397,1 +388,1 @@\n-        Queue<Node> ready = new PriorityQueue<Node>(schedulePriority);\n+        Queue<Node> ready = new PriorityQueue<>(schedulePriority);\n@@ -399,1 +390,1 @@\n-        Set<Node> visited = new HashSet<Node>(nodes.size());\n+        Set<Node> visited = new HashSet<>(nodes.size());\n@@ -715,3 +706,1 @@\n-        if (root == null) {\n-            assert false : \"No root found!\";\n-        }\n+        assert root != null : \"No root found!\";\n@@ -756,1 +745,1 @@\n-                edgeMap.put(to, new ArrayList<InputEdge>());\n+                edgeMap.put(to, new ArrayList<>());\n@@ -865,1 +854,1 @@\n-                    nodesPerWarning.put(warning, new HashSet<Node>());\n+                    nodesPerWarning.put(warning, new HashSet<>());\n","filename":"src\/utils\/IdealGraphVisualizer\/ServerCompiler\/src\/main\/java\/com\/sun\/hotspot\/igv\/servercompiler\/ServerCompilerScheduler.java","additions":28,"deletions":39,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -50,1 +50,0 @@\n-    public static final String PORT_BINARY = \"portBinary\";\n@@ -52,1 +51,0 @@\n-    public static final String PORT_BINARY_DEFAULT = \"4445\";\n","filename":"src\/utils\/IdealGraphVisualizer\/Settings\/src\/main\/java\/com\/sun\/hotspot\/igv\/settings\/Settings.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-    private DoubleClickHandler handler;\n+    private final DoubleClickHandler handler;\n","filename":"src\/utils\/IdealGraphVisualizer\/Util\/src\/main\/java\/com\/sun\/hotspot\/igv\/util\/DoubleClickAction.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-    public void handleDoubleClick(Widget w, WidgetMouseEvent e);\n+    void handleDoubleClick(Widget w, WidgetMouseEvent e);\n","filename":"src\/utils\/IdealGraphVisualizer\/Util\/src\/main\/java\/com\/sun\/hotspot\/igv\/util\/DoubleClickHandler.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,208 +0,0 @@\n-\/*\n- * Copyright (c) 2008, 2015, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-package com.sun.hotspot.igv.util;\n-\n-import java.awt.*;\n-import java.awt.event.*;\n-import javax.swing.JComponent;\n-import org.netbeans.api.visual.widget.Scene;\n-\n-\/**\n- * @author David Kaspar\n- * @author Thomas Wuerthinger\n- *\/\n-public class ExtendedSatelliteComponent extends JComponent implements MouseListener, MouseMotionListener, Scene.SceneListener, ComponentListener {\n-\n-    private Scene scene;\n-    private Image image;\n-    private int imageWidth;\n-    private int imageHeight;\n-\n-    public ExtendedSatelliteComponent(Scene scene) {\n-        this.scene = scene;\n-        setDoubleBuffered(true);\n-        setPreferredSize(new Dimension(128, 128));\n-        addMouseListener(this);\n-        addMouseMotionListener(this);\n-    }\n-\n-    @Override\n-    public void addNotify() {\n-        super.addNotify();\n-        scene.addSceneListener(this);\n-        JComponent viewComponent = scene.getView();\n-        if (viewComponent == null) {\n-            viewComponent = scene.createView();\n-        }\n-        viewComponent.addComponentListener(this);\n-        repaint();\n-    }\n-\n-    @Override\n-    public void removeNotify() {\n-        scene.getView().removeComponentListener(this);\n-        scene.removeSceneListener(this);\n-        super.removeNotify();\n-    }\n-\n-    public void update() {\n-        this.image = null;\n-        repaint();\n-    }\n-\n-    @Override\n-    public void paint(Graphics g) {\n-        Graphics2D gr = (Graphics2D) g;\n-        super.paint(g);\n-        Rectangle bounds = scene.getBounds();\n-        Dimension size = getSize();\n-\n-        double sx = bounds.width > 0 ? (double) size.width \/ bounds.width : 0.0;\n-        double sy = bounds.width > 0 ? (double) size.height \/ bounds.height : 0.0;\n-        double scale = Math.min(sx, sy);\n-\n-        int vw = (int) (scale * bounds.width);\n-        int vh = (int) (scale * bounds.height);\n-        int vx = (size.width - vw) \/ 2;\n-        int vy = (size.height - vh) \/ 2;\n-\n-\n-        if (image == null || vw != imageWidth || vh != imageHeight) {\n-\n-            imageWidth = vw;\n-            imageHeight = vh;\n-            image = this.createImage(imageWidth, imageHeight);\n-            Graphics2D ig = (Graphics2D) image.getGraphics();\n-            ig.scale(scale, scale);\n-            scene.paint(ig);\n-        }\n-\n-        gr.drawImage(image, vx, vy, this);\n-\n-        JComponent component = scene.getView();\n-        double zoomFactor = scene.getZoomFactor();\n-        Rectangle viewRectangle = component != null ? component.getVisibleRect() : null;\n-        if (viewRectangle != null) {\n-            Rectangle window = new Rectangle(\n-                    (int) ((double) viewRectangle.x * scale \/ zoomFactor),\n-                    (int) ((double) viewRectangle.y * scale \/ zoomFactor),\n-                    (int) ((double) viewRectangle.width * scale \/ zoomFactor),\n-                    (int) ((double) viewRectangle.height * scale \/ zoomFactor));\n-            window.translate(vx, vy);\n-            gr.setColor(new Color(200, 200, 200, 128));\n-            gr.fill(window);\n-            gr.setColor(Color.BLACK);\n-            gr.drawRect(window.x, window.y, window.width - 1, window.height - 1);\n-        }\n-    }\n-\n-    @Override\n-    public void mouseClicked(MouseEvent e) {\n-    }\n-\n-    @Override\n-    public void mousePressed(MouseEvent e) {\n-        moveVisibleRect(e.getPoint());\n-    }\n-\n-    @Override\n-    public void mouseReleased(MouseEvent e) {\n-        moveVisibleRect(e.getPoint());\n-    }\n-\n-    @Override\n-    public void mouseEntered(MouseEvent e) {\n-    }\n-\n-    @Override\n-    public void mouseExited(MouseEvent e) {\n-    }\n-\n-    @Override\n-    public void mouseDragged(MouseEvent e) {\n-        moveVisibleRect(e.getPoint());\n-    }\n-\n-    @Override\n-    public void mouseMoved(MouseEvent e) {\n-    }\n-\n-    private void moveVisibleRect(Point center) {\n-        JComponent component = scene.getView();\n-        if (component == null) {\n-            return;\n-        }\n-        double zoomFactor = scene.getZoomFactor();\n-        Rectangle bounds = scene.getBounds();\n-        Dimension size = getSize();\n-\n-        double sx = bounds.width > 0 ? (double) size.width \/ bounds.width : 0.0;\n-        double sy = bounds.width > 0 ? (double) size.height \/ bounds.height : 0.0;\n-        double scale = Math.min(sx, sy);\n-\n-        int vw = (int) (scale * bounds.width);\n-        int vh = (int) (scale * bounds.height);\n-        int vx = (size.width - vw) \/ 2;\n-        int vy = (size.height - vh) \/ 2;\n-\n-        int cx = (int) ((double) (center.x - vx) \/ scale * zoomFactor);\n-        int cy = (int) ((double) (center.y - vy) \/ scale * zoomFactor);\n-\n-        Rectangle visibleRect = component.getVisibleRect();\n-        visibleRect.x = cx - visibleRect.width \/ 2;\n-        visibleRect.y = cy - visibleRect.height \/ 2;\n-        component.scrollRectToVisible(visibleRect);\n-\n-    }\n-\n-    @Override\n-    public void sceneRepaint() {\n-    }\n-\n-    @Override\n-    public void sceneValidating() {\n-    }\n-\n-    @Override\n-    public void sceneValidated() {\n-    }\n-\n-    @Override\n-    public void componentResized(ComponentEvent e) {\n-        repaint();\n-    }\n-\n-    @Override\n-    public void componentMoved(ComponentEvent e) {\n-        repaint();\n-    }\n-\n-    @Override\n-    public void componentShown(ComponentEvent e) {\n-    }\n-\n-    @Override\n-    public void componentHidden(ComponentEvent e) {\n-    }\n-}\n","filename":"src\/utils\/IdealGraphVisualizer\/Util\/src\/main\/java\/com\/sun\/hotspot\/igv\/util\/ExtendedSatelliteComponent.java","additions":0,"deletions":208,"binary":false,"changes":208,"status":"deleted"},{"patch":"@@ -41,1 +41,1 @@\n-    private static Map<Class, LookupHistoryImpl> cache = new HashMap<>();\n+    private static final Map<Class, LookupHistoryImpl> cache = new HashMap<>();\n@@ -45,2 +45,2 @@\n-        private Class<T> klass;\n-        private Result<T> result;\n+        private final Class<T> klass;\n+        private final Result<T> result;\n","filename":"src\/utils\/IdealGraphVisualizer\/Util\/src\/main\/java\/com\/sun\/hotspot\/igv\/util\/LookupHistory.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import com.sun.hotspot.igv.util.StringUtils;\n@@ -48,1 +47,1 @@\n-}\n\\ No newline at end of file\n+}\n","filename":"src\/utils\/IdealGraphVisualizer\/Util\/src\/main\/java\/com\/sun\/hotspot\/igv\/util\/PropertiesConverter.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import java.lang.reflect.InvocationTargetException;\n@@ -52,1 +51,1 @@\n-                public String getValue() throws IllegalAccessException, InvocationTargetException {\n+                public String getValue() {\n@@ -62,1 +61,1 @@\n-                public void setValue(String arg0) throws IllegalAccessException, IllegalArgumentException, InvocationTargetException {\n+                public void setValue(String arg0) throws IllegalArgumentException {\n","filename":"src\/utils\/IdealGraphVisualizer\/Util\/src\/main\/java\/com\/sun\/hotspot\/igv\/util\/PropertiesSheet.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import java.awt.geom.*;\n@@ -33,0 +32,2 @@\n+import java.awt.geom.Ellipse2D;\n+import java.awt.geom.Rectangle2D;\n@@ -34,1 +35,4 @@\n-import javax.swing.*;\n+import javax.swing.JComponent;\n+import javax.swing.JViewport;\n+import javax.swing.Scrollable;\n+import javax.swing.SwingConstants;\n@@ -55,1 +59,1 @@\n-    private RangeSliderModel model;\n+    private final RangeSliderModel model;\n@@ -58,1 +62,4 @@\n-    private RangeSliderModel tempModel;\n+    private boolean tempModel = false;\n+    private int tempFirstPos;\n+    private int tempSecondPos;\n+\n@@ -69,1 +76,1 @@\n-    public RangeSlider() {\n+    public RangeSlider(RangeSliderModel newModel) {\n@@ -73,7 +80,0 @@\n-    }\n-\n-    public void setModel(RangeSliderModel newModel) {\n-        if (model != null) {\n-            model.getChangedEvent().removeListener(this);\n-            model.getColorChangedEvent().removeListener(this);\n-        }\n@@ -88,3 +88,3 @@\n-    private RangeSliderModel getPaintingModel() {\n-        if (tempModel != null) {\n-            return tempModel;\n+    private int getFirstPos() {\n+        if (tempModel) {\n+            return tempFirstPos;\n@@ -92,1 +92,8 @@\n-        return model;\n+        return model.getFirstPosition();\n+    }\n+\n+    private int getSecondPos() {\n+        if (tempModel) {\n+            return tempSecondPos;\n+        }\n+        return model.getSecondPosition();\n@@ -136,1 +143,1 @@\n-        d.width = Math.max(d.width, (int)(2 * BAR_CIRCLE_CONNECTOR_SIZE + getPaintingModel().getPositions().size() * (BAR_CIRCLE_SIZE + BAR_CIRCLE_CONNECTOR_SIZE)));\n+        d.width = Math.max(d.width, (int)(2 * BAR_CIRCLE_CONNECTOR_SIZE + model.getPositions().size() * (BAR_CIRCLE_SIZE + BAR_CIRCLE_CONNECTOR_SIZE)));\n@@ -143,1 +150,0 @@\n-\n@@ -158,1 +164,1 @@\n-        assert index >= 0 && index < getPaintingModel().getPositions().size();\n+        assert index >= 0 && index < model.getPositions().size();\n@@ -163,1 +169,1 @@\n-        int size = getPaintingModel().getPositions().size();\n+        int size = model.getPositions().size();\n@@ -189,1 +195,1 @@\n-        if (getPaintingModel() == null || getPaintingModel().getPositions().size() == 0) {\n+        if (model == null || model.getPositions().size() == 0) {\n@@ -193,2 +199,2 @@\n-        int firstPos = getPaintingModel().getFirstPosition();\n-        int secondPos = getPaintingModel().getSecondPosition();\n+        int firstPos = getFirstPos();\n+        int secondPos = getSecondPos();\n@@ -202,1 +208,1 @@\n-        return getHeight() \/ 2 - BAR_HEIGHT \/ 2;\n+        return getHeight() \/ 2.0f - BAR_HEIGHT \/ 2.0f;\n@@ -206,1 +212,1 @@\n-        List<String> list = getPaintingModel().getPositions();\n+        List<String> list = model.getPositions();\n@@ -215,1 +221,1 @@\n-            g.setColor(getPaintingModel().getColors().get(i));\n+            g.setColor(model.getColors().get(i));\n@@ -229,1 +235,1 @@\n-                    g.drawString(curS, startX + (endX - startX) \/ 2 - bounds.width \/ 2, barStartY \/ 2 + bounds.height \/ 2);\n+                    g.drawString(curS, (startX + (endX - startX) \/ 2.0f - bounds.width \/ 2.0f), barStartY \/ 2.0f + bounds.height \/ 2.0f);\n@@ -261,1 +267,1 @@\n-            float destX = getEndXPosition(getPaintingModel().getSecondPosition());\n+            float destX = getEndXPosition(getSecondPos());\n@@ -270,1 +276,1 @@\n-            float destX = getStartXPosition(getPaintingModel().getFirstPosition());\n+            float destX = getStartXPosition(getFirstPos());\n@@ -279,1 +285,1 @@\n-            return p.x > getStartXPosition(getPaintingModel().getFirstPosition()) && p.x < getEndXPosition(getPaintingModel().getSecondPosition());\n+            return p.x > getStartXPosition(getFirstPos()) && p.x < getEndXPosition(getSecondPos());\n@@ -292,3 +298,3 @@\n-            int newIndex = getIndexFromPosition(newFirstX) + 1;\n-            if (newIndex + model.getSecondPosition() - model.getFirstPosition() >= model.getPositions().size()) {\n-                newIndex = model.getPositions().size() - (model.getSecondPosition() - model.getFirstPosition()) - 1;\n+            tempFirstPos = getIndexFromPosition(newFirstX) + 1;\n+            if (tempFirstPos + model.getSecondPosition() - model.getFirstPosition() >= model.getPositions().size()) {\n+                tempFirstPos = model.getPositions().size() - (model.getSecondPosition() - model.getFirstPosition()) - 1;\n@@ -296,2 +302,1 @@\n-            int secondPosition = newIndex + model.getSecondPosition() - model.getFirstPosition();\n-            tempModel.setPositions(newIndex, secondPosition);\n+            tempSecondPos = tempFirstPos + model.getSecondPosition() - model.getFirstPosition();\n@@ -300,4 +305,4 @@\n-            int firstPosition = getIndexFromPosition(e.getPoint().x) + 1;\n-            int secondPosition = model.getSecondPosition();\n-            if (firstPosition > secondPosition) {\n-                firstPosition--;\n+            tempFirstPos = getIndexFromPosition(e.getPoint().x) + 1;\n+            tempSecondPos = model.getSecondPosition();\n+            if (tempFirstPos > tempSecondPos) {\n+                tempFirstPos--;\n@@ -305,1 +310,0 @@\n-            tempModel.setPositions(firstPosition, secondPosition);\n@@ -308,4 +312,4 @@\n-            int firstPosition = model.getFirstPosition();\n-            int secondPosition = getIndexFromPosition(e.getPoint().x);\n-            if (secondPosition < firstPosition) {\n-                secondPosition++;\n+            tempFirstPos = model.getFirstPosition();\n+            tempSecondPos = getIndexFromPosition(e.getPoint().x);\n+            if (tempSecondPos < tempFirstPos) {\n+                tempSecondPos++;\n@@ -313,1 +317,0 @@\n-            tempModel.setPositions(firstPosition, secondPosition);\n@@ -322,1 +325,1 @@\n-        for (int i = 0; i < getPaintingModel().getPositions().size() - 1; i++) {\n+        for (int i = 0; i < model.getPositions().size() - 1; i++) {\n@@ -329,1 +332,1 @@\n-        return getPaintingModel().getPositions().size() - 1;\n+        return model.getPositions().size() - 1;\n@@ -334,1 +337,1 @@\n-        for (int i = 1; i < getPaintingModel().getPositions().size(); i++) {\n+        for (int i = 1; i < model.getPositions().size(); i++) {\n@@ -348,2 +351,0 @@\n-\n-\n@@ -389,1 +390,1 @@\n-        tempModel = model.copy();\n+        tempModel = true;\n@@ -394,1 +395,1 @@\n-        if (model == null || tempModel == null) {\n+        if (model == null || !tempModel) {\n@@ -398,2 +399,2 @@\n-        model.setPositions(tempModel.getFirstPosition(), tempModel.getSecondPosition());\n-        tempModel = null;\n+        model.setPositions(tempFirstPos, tempSecondPos);\n+        tempModel = false;\n@@ -403,2 +404,1 @@\n-    public void mouseEntered(MouseEvent e) {\n-    }\n+    public void mouseEntered(MouseEvent e) { }\n","filename":"src\/utils\/IdealGraphVisualizer\/Util\/src\/main\/java\/com\/sun\/hotspot\/igv\/util\/RangeSlider.java","additions":56,"deletions":56,"binary":false,"changes":112,"status":"modified"},{"patch":"@@ -41,2 +41,2 @@\n-    private ChangedEvent<RangeSliderModel> changedEvent;\n-    private ChangedEvent<RangeSliderModel> colorChangedEvent;\n+    private final ChangedEvent<RangeSliderModel> changedEvent;\n+    private final ChangedEvent<RangeSliderModel> colorChangedEvent;\n@@ -49,2 +49,1 @@\n-        boolean changed = false;\n-        changed |= (positions != model.positions);\n+        boolean changed = (positions != model.positions);\n","filename":"src\/utils\/IdealGraphVisualizer\/Util\/src\/main\/java\/com\/sun\/hotspot\/igv\/util\/RangeSliderModel.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -120,1 +120,1 @@\n-     *\n+     * <p>\n","filename":"src\/utils\/IdealGraphVisualizer\/Util\/src\/main\/java\/com\/sun\/hotspot\/igv\/util\/StringUtils.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-import com.sun.hotspot.igv.data.InputGraph;\n@@ -28,0 +27,1 @@\n+import com.sun.hotspot.igv.data.InputGraph;\n@@ -32,1 +32,0 @@\n-import java.util.List;\n@@ -34,0 +33,1 @@\n+import java.util.List;\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/BlockQuickSearch.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -43,1 +43,3 @@\n-import java.awt.event.*;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.MouseEvent;\n+import java.awt.event.MouseWheelListener;\n@@ -73,9 +75,9 @@\n-    private CustomizablePanAction panAction;\n-    private WidgetAction hoverAction;\n-    private WidgetAction selectAction;\n-    private Lookup lookup;\n-    private InstanceContent content;\n-    private Action[] actions;\n-    private Action[] actionsWithSelection;\n-    private LayerWidget connectionLayer;\n-    private JScrollPane scrollPane;\n+    private final CustomizablePanAction panAction;\n+    private final WidgetAction hoverAction;\n+    private final WidgetAction selectAction;\n+    private final Lookup lookup;\n+    private final InstanceContent content;\n+    private final Action[] actions;\n+    private final Action[] actionsWithSelection;\n+    private final LayerWidget connectionLayer;\n+    private final JScrollPane scrollPane;\n@@ -107,19 +109,0 @@\n-    private PopupMenuProvider popupMenuProvider = new PopupMenuProvider() {\n-\n-        @Override\n-        public JPopupMenu getPopupMenu(Widget widget, Point localLocation) {\n-            return DiagramScene.this.createPopupMenu();\n-        }\n-    };\n-\n-    private RectangularSelectDecorator rectangularSelectDecorator = new RectangularSelectDecorator() {\n-\n-        @Override\n-        public Widget createSelectionWidget() {\n-            Widget widget = new Widget(DiagramScene.this);\n-            widget.setBorder(BorderFactory.createLineBorder(Color.black, 2));\n-            widget.setForeground(Color.red);\n-            return widget;\n-        }\n-    };\n-\n@@ -128,1 +111,1 @@\n-        Widget w = this.findWidget(o);\n+        Widget w = findWidget(o);\n@@ -134,1 +117,1 @@\n-        Widget w = this.findWidget(o);\n+        Widget w = findWidget(o);\n@@ -216,1 +199,0 @@\n-\n@@ -223,16 +205,1 @@\n-    private Set<Object> getObjectsFromIdSet(Set<Object> set) {\n-        Set<Object> selectedObjects = new HashSet<>();\n-        for (Figure f : getModel().getDiagramToView().getFigures()) {\n-            if (intersects(f.getSource().getSourceNodesAsSet(), set)) {\n-                selectedObjects.add(f);\n-            }\n-\n-            for (Slot s : f.getSlots()) {\n-                if (intersects(s.getSource().getSourceNodesAsSet(), set)) {\n-                    selectedObjects.add(s);\n-                }\n-            }\n-        }\n-        return selectedObjects;\n-    }\n-    private ControllableChangedListener<SelectionCoordinator> highlightedCoordinatorListener = new ControllableChangedListener<SelectionCoordinator>() {\n+    private final ControllableChangedListener<SelectionCoordinator> highlightedCoordinatorListener = new ControllableChangedListener<SelectionCoordinator>() {\n@@ -242,2 +209,2 @@\n-            DiagramScene.this.setHighlightedObjects(getObjectsFromIdSet(source.getHighlightedObjects()));\n-            DiagramScene.this.validate();\n+            setHighlightedObjects(idSetToObjectSet(source.getHighlightedObjects()));\n+            validate();\n@@ -246,1 +213,1 @@\n-    private ControllableChangedListener<SelectionCoordinator> selectedCoordinatorListener = new ControllableChangedListener<SelectionCoordinator>() {\n+    private final ControllableChangedListener<SelectionCoordinator> selectedCoordinatorListener = new ControllableChangedListener<SelectionCoordinator>() {\n@@ -250,2 +217,2 @@\n-            DiagramScene.this.gotoSelection(source.getSelectedObjects());\n-            DiagramScene.this.validate();\n+            gotoSelection(source.getSelectedObjects());\n+            validate();\n@@ -255,44 +222,1 @@\n-    private RectangularSelectProvider rectangularSelectProvider = new RectangularSelectProvider() {\n-\n-        @Override\n-        public void performSelection(Rectangle rectangle) {\n-            if (rectangle.width < 0) {\n-                rectangle.x += rectangle.width;\n-                rectangle.width *= -1;\n-            }\n-\n-            if (rectangle.height < 0) {\n-                rectangle.y += rectangle.height;\n-                rectangle.height *= -1;\n-            }\n-\n-            Set<Object> selectedObjects = new HashSet<>();\n-            for (Figure f : getModel().getDiagramToView().getFigures()) {\n-                FigureWidget w = getWidget(f);\n-                if (w != null) {\n-                    Rectangle r = new Rectangle(w.getBounds());\n-                    r.setLocation(w.getLocation());\n-\n-                    if (r.intersects(rectangle)) {\n-                        selectedObjects.add(f);\n-                    }\n-\n-                    for (Slot s : f.getSlots()) {\n-                        SlotWidget sw = getWidget(s);\n-                        Rectangle r2 = new Rectangle(sw.getBounds());\n-                        r2.setLocation(sw.convertLocalToScene(new Point(0, 0)));\n-\n-                        if (r2.intersects(rectangle)) {\n-                            selectedObjects.add(s);\n-                        }\n-                    }\n-                } else {\n-                    assert false : \"w should not be null here!\";\n-                }\n-            }\n-\n-            setSelectedObjects(selectedObjects);\n-        }\n-    };\n-\n-    public Point getScrollPosition() {\n+    private Point getScrollPosition() {\n@@ -302,1 +226,1 @@\n-    public void setScrollPosition(Point p) {\n+    private void setScrollPosition(Point p) {\n@@ -337,88 +261,0 @@\n-    private ObjectSceneListener selectionChangedListener = new ObjectSceneListener() {\n-\n-        @Override\n-        public void objectAdded(ObjectSceneEvent arg0, Object arg1) {\n-        }\n-\n-        @Override\n-        public void objectRemoved(ObjectSceneEvent arg0, Object arg1) {\n-        }\n-\n-        @Override\n-        public void objectStateChanged(ObjectSceneEvent e, Object o, ObjectState oldState, ObjectState newState) {\n-        }\n-\n-        @Override\n-        public void selectionChanged(ObjectSceneEvent e, Set<Object> oldSet, Set<Object> newSet) {\n-            DiagramScene scene = (DiagramScene) e.getObjectScene();\n-            if (scene.isRebuilding()) {\n-                return;\n-            }\n-\n-            content.set(newSet, null);\n-\n-            Set<Integer> nodeSelection = new HashSet<>();\n-            for (Object o : newSet) {\n-                if (o instanceof Properties.Provider) {\n-                    final Properties.Provider provider = (Properties.Provider) o;\n-                    AbstractNode node = new AbstractNode(Children.LEAF) {\n-\n-                        @Override\n-                        protected Sheet createSheet() {\n-                            Sheet s = super.createSheet();\n-                            PropertiesSheet.initializeSheet(provider.getProperties(), s);\n-                            return s;\n-                        }\n-                    };\n-                    node.setDisplayName(provider.getProperties().get(\"name\"));\n-                    content.add(node);\n-                }\n-\n-\n-                if (o instanceof Figure) {\n-                    nodeSelection.addAll(((Figure) o).getSource().getSourceNodesAsSet());\n-                } else if (o instanceof Slot) {\n-                    nodeSelection.addAll(((Slot) o).getSource().getSourceNodesAsSet());\n-                }\n-            }\n-            getModel().setSelectedNodes(nodeSelection);\n-\n-            boolean b = selectedCoordinatorListener.isEnabled();\n-            selectedCoordinatorListener.setEnabled(false);\n-            SelectionCoordinator.getInstance().setSelectedObjects(nodeSelection);\n-            selectedCoordinatorListener.setEnabled(b);\n-\n-        }\n-\n-        @Override\n-        public void highlightingChanged(ObjectSceneEvent e, Set<Object> oldSet, Set<Object> newSet) {\n-            Set<Integer> nodeHighlighting = new HashSet<>();\n-            for (Object o : newSet) {\n-                if (o instanceof Figure) {\n-                    nodeHighlighting.addAll(((Figure) o).getSource().getSourceNodesAsSet());\n-                } else if (o instanceof Slot) {\n-                    nodeHighlighting.addAll(((Slot) o).getSource().getSourceNodesAsSet());\n-                }\n-            }\n-            boolean b = highlightedCoordinatorListener.isEnabled();\n-            highlightedCoordinatorListener.setEnabled(false);\n-            SelectionCoordinator.getInstance().setHighlightedObjects(nodeHighlighting);\n-            highlightedCoordinatorListener.setEnabled(true);\n-        }\n-\n-        @Override\n-        public void hoverChanged(ObjectSceneEvent e, Object oldObject, Object newObject) {\n-            Set<Object> newHighlightedObjects = new HashSet<>(DiagramScene.this.getHighlightedObjects());\n-            if (oldObject != null) {\n-                newHighlightedObjects.remove(oldObject);\n-            }\n-            if (newObject != null) {\n-                newHighlightedObjects.add(newObject);\n-            }\n-            DiagramScene.this.setHighlightedObjects(newHighlightedObjects);\n-        }\n-\n-        @Override\n-        public void focusChanged(ObjectSceneEvent arg0, Object arg1, Object arg2) {\n-        }\n-    };\n@@ -427,1 +263,0 @@\n-\n@@ -434,1 +269,1 @@\n-        this.setCheckClipping(true);\n+        setCheckClipping(true);\n@@ -445,1 +280,1 @@\n-        this.getActions().addAction(panAction);\n+        getActions().addAction(panAction);\n@@ -474,1 +309,1 @@\n-        this.getActions().addAction(selectAction);\n+        getActions().addAction(selectAction);\n@@ -477,1 +312,1 @@\n-        this.addChild(blockLayer);\n+        addChild(blockLayer);\n@@ -480,1 +315,1 @@\n-        this.addChild(connectionLayer);\n+        addChild(connectionLayer);\n@@ -483,1 +318,1 @@\n-        this.addChild(mainLayer);\n+        addChild(mainLayer);\n@@ -485,4 +320,4 @@\n-        this.setBorder(BorderFactory.createLineBorder(Color.white, BORDER_SIZE));\n-        this.setLayout(LayoutFactory.createAbsoluteLayout());\n-        this.getActions().addAction(mouseZoomAction);\n-        this.getActions().addAction(ActionFactory.createPopupMenuAction(popupMenuProvider));\n+        setBorder(BorderFactory.createLineBorder(Color.white, BORDER_SIZE));\n+        setLayout(LayoutFactory.createAbsoluteLayout());\n+        getActions().addAction(mouseZoomAction);\n+        getActions().addAction(ActionFactory.createPopupMenuAction((widget, localLocation) -> createPopupMenu()));\n@@ -491,8 +326,141 @@\n-        this.addChild(selectLayer);\n-        this.getActions().addAction(ActionFactory.createRectangularSelectAction(rectangularSelectDecorator, selectLayer, rectangularSelectProvider));\n-\n-        boolean b = this.getUndoRedoEnabled();\n-        this.setUndoRedoEnabled(false);\n-        this.setNewModel(model);\n-        this.setUndoRedoEnabled(b);\n-        this.addObjectSceneListener(selectionChangedListener, ObjectSceneEventType.OBJECT_SELECTION_CHANGED, ObjectSceneEventType.OBJECT_HIGHLIGHTING_CHANGED, ObjectSceneEventType.OBJECT_HOVER_CHANGED);\n+        addChild(selectLayer);\n+        RectangularSelectDecorator rectangularSelectDecorator = () -> {\n+            Widget widget = new Widget(DiagramScene.this);\n+            widget.setBorder(BorderFactory.createLineBorder(Color.black, 2));\n+            widget.setForeground(Color.red);\n+            return widget;\n+        };\n+        RectangularSelectProvider rectangularSelectProvider = rectangle -> {\n+            if (rectangle.width < 0) {\n+                rectangle.x += rectangle.width;\n+                rectangle.width *= -1;\n+            }\n+\n+            if (rectangle.height < 0) {\n+                rectangle.y += rectangle.height;\n+                rectangle.height *= -1;\n+            }\n+\n+            Set<Object> selectedObjects = new HashSet<>();\n+            for (Figure f : getModel().getDiagram().getFigures()) {\n+                FigureWidget w = getWidget(f);\n+                if (w != null) {\n+                    assert w.getBounds() != null;\n+                    Rectangle r = new Rectangle(w.getBounds());\n+                    r.setLocation(w.getLocation());\n+\n+                    if (r.intersects(rectangle)) {\n+                        selectedObjects.add(f);\n+                    }\n+\n+                    for (Slot s : f.getSlots()) {\n+                        SlotWidget sw = getWidget(s);\n+                        assert sw.getBounds() != null;\n+                        Rectangle r2 = new Rectangle(sw.getBounds());\n+                        r2.setLocation(sw.convertLocalToScene(new Point(0, 0)));\n+\n+                        if (r2.intersects(rectangle)) {\n+                            selectedObjects.add(s);\n+                        }\n+                    }\n+                } else {\n+                    assert false : \"w should not be null here!\";\n+                }\n+            }\n+\n+            setSelectedObjects(selectedObjects);\n+        };\n+        getActions().addAction(ActionFactory.createRectangularSelectAction(rectangularSelectDecorator, selectLayer, rectangularSelectProvider));\n+\n+        boolean b = getUndoRedoEnabled();\n+        setUndoRedoEnabled(false);\n+        setNewModel(model);\n+        setUndoRedoEnabled(b);\n+        ObjectSceneListener selectionChangedListener = new ObjectSceneListener() {\n+\n+            @Override\n+            public void objectAdded(ObjectSceneEvent arg0, Object arg1) {\n+            }\n+\n+            @Override\n+            public void objectRemoved(ObjectSceneEvent arg0, Object arg1) {\n+            }\n+\n+            @Override\n+            public void objectStateChanged(ObjectSceneEvent e, Object o, ObjectState oldState, ObjectState newState) {\n+            }\n+\n+            @Override\n+            public void selectionChanged(ObjectSceneEvent e, Set<Object> oldSet, Set<Object> newSet) {\n+                DiagramScene scene = (DiagramScene) e.getObjectScene();\n+                if (scene.isRebuilding()) {\n+                    return;\n+                }\n+\n+                content.set(newSet, null);\n+\n+                Set<Integer> nodeSelection = new HashSet<>();\n+                for (Object o : newSet) {\n+                    if (o instanceof Properties.Provider) {\n+                        final Properties.Provider provider = (Properties.Provider) o;\n+                        AbstractNode node = new AbstractNode(Children.LEAF) {\n+\n+                            @Override\n+                            protected Sheet createSheet() {\n+                                Sheet s = super.createSheet();\n+                                PropertiesSheet.initializeSheet(provider.getProperties(), s);\n+                                return s;\n+                            }\n+                        };\n+                        node.setDisplayName(provider.getProperties().get(\"name\"));\n+                        content.add(node);\n+                    }\n+\n+\n+                    if (o instanceof Figure) {\n+                        nodeSelection.add(((Figure) o).getInputNode().getId());\n+                    } else if (o instanceof Slot) {\n+                        nodeSelection.addAll(((Slot) o).getSource().getSourceNodesAsSet());\n+                    }\n+                }\n+                getModel().setSelectedNodes(nodeSelection);\n+\n+                boolean b = selectedCoordinatorListener.isEnabled();\n+                selectedCoordinatorListener.setEnabled(false);\n+                SelectionCoordinator.getInstance().setSelectedObjects(nodeSelection);\n+                selectedCoordinatorListener.setEnabled(b);\n+\n+            }\n+\n+            @Override\n+            public void highlightingChanged(ObjectSceneEvent e, Set<Object> oldSet, Set<Object> newSet) {\n+                Set<Integer> nodeHighlighting = new HashSet<>();\n+                for (Object o : newSet) {\n+                    if (o instanceof Figure) {\n+                        nodeHighlighting.add(((Figure) o).getInputNode().getId());\n+                    } else if (o instanceof Slot) {\n+                        nodeHighlighting.addAll(((Slot) o).getSource().getSourceNodesAsSet());\n+                    }\n+                }\n+                highlightedCoordinatorListener.setEnabled(false);\n+                SelectionCoordinator.getInstance().setHighlightedObjects(nodeHighlighting);\n+                highlightedCoordinatorListener.setEnabled(true);\n+            }\n+\n+            @Override\n+            public void hoverChanged(ObjectSceneEvent e, Object oldObject, Object newObject) {\n+                Set<Object> newHighlightedObjects = new HashSet<>(getHighlightedObjects());\n+                if (oldObject != null) {\n+                    newHighlightedObjects.remove(oldObject);\n+                }\n+                if (newObject != null) {\n+                    newHighlightedObjects.add(newObject);\n+                }\n+                setHighlightedObjects(newHighlightedObjects);\n+            }\n+\n+            @Override\n+            public void focusChanged(ObjectSceneEvent arg0, Object arg1, Object arg2) {\n+            }\n+        };\n+        addObjectSceneListener(selectionChangedListener, ObjectSceneEventType.OBJECT_SELECTION_CHANGED, ObjectSceneEventType.OBJECT_HIGHLIGHTING_CHANGED, ObjectSceneEventType.OBJECT_HOVER_CHANGED);\n@@ -505,1 +473,1 @@\n-    public JScrollPane getScrollPane() {\n+    private JScrollPane getScrollPane() {\n@@ -527,1 +495,1 @@\n-        final boolean hidden = !this.getWidget(f, FigureWidget.class).isVisible();\n+        final boolean hidden = !getWidget(f, FigureWidget.class).isVisible();\n@@ -560,1 +528,1 @@\n-    public void setNewModel(DiagramViewModel model) {\n+    private void setNewModel(DiagramViewModel model) {\n@@ -578,1 +546,1 @@\n-        Collection<Object> objects = new ArrayList<>(this.getObjects());\n+        Collection<Object> objects = new ArrayList<>(getObjects());\n@@ -580,1 +548,1 @@\n-            this.removeObject(o);\n+            removeObject(o);\n@@ -583,1 +551,1 @@\n-        Diagram d = getModel().getDiagramToView();\n+        Diagram d = getModel().getDiagram();\n@@ -586,1 +554,1 @@\n-        for (InputBlock b : d.getGraph().getBlocks()) {\n+        for (InputBlock b : d.getInputBlocks()) {\n@@ -593,2 +561,2 @@\n-            if (f.getWidth() > maxWidth.get(f.getBlock())) {\n-                maxWidth.put(f.getBlock(), f.getWidth());\n+            if (f.getWidth() > maxWidth.get(f.getBlock().getInputBlock())) {\n+                maxWidth.put(f.getBlock().getInputBlock(), f.getWidth());\n@@ -599,1 +567,0 @@\n-\n@@ -602,1 +569,1 @@\n-                f.setWidth(maxWidth.get(f.getBlock()));\n+                f.setWidth(maxWidth.get(f.getBlock().getInputBlock()));\n@@ -611,1 +578,1 @@\n-            this.addObject(f, w);\n+            addObject(f, w);\n@@ -631,1 +598,1 @@\n-            for (InputBlock bn : d.getGraph().getBlocks()) {\n+            for (InputBlock bn : d.getInputBlocks()) {\n@@ -634,1 +601,1 @@\n-                this.addObject(bn, w);\n+                addObject(bn, w);\n@@ -640,1 +607,1 @@\n-        this.smallUpdate(true);\n+        smallUpdate(true);\n@@ -643,1 +610,1 @@\n-    public boolean isRebuilding() {\n+    protected boolean isRebuilding() {\n@@ -648,5 +615,5 @@\n-        this.updateHiddenNodes(model.getHiddenNodes(), relayout);\n-        boolean b = this.getUndoRedoEnabled();\n-        this.setUndoRedoEnabled(false);\n-        this.setUndoRedoEnabled(b);\n-        this.validate();\n+        updateHiddenNodes(model.getHiddenNodes(), relayout);\n+        boolean b = getUndoRedoEnabled();\n+        setUndoRedoEnabled(false);\n+        setUndoRedoEnabled(b);\n+        validate();\n@@ -675,1 +642,1 @@\n-        Diagram diagram = getModel().getDiagramToView();\n+        Diagram diagram = getModel().getDiagram();\n@@ -697,1 +664,1 @@\n-            doClusteredLayout(figures, edges);\n+            doClusteredLayout(edges);\n@@ -711,1 +678,1 @@\n-    private void doClusteredLayout(HashSet<Figure> figures, HashSet<Connection> edges) {\n+    private void doClusteredLayout(HashSet<Connection> edges) {\n@@ -718,1 +685,1 @@\n-        m.doLayout(new LayoutGraph(edges, figures));\n+        m.doLayout(new LayoutGraph(edges));\n@@ -722,1 +689,1 @@\n-        Diagram diagram = getModel().getDiagramToView();\n+        Diagram diagram = getModel().getDiagram();\n@@ -731,1 +698,1 @@\n-        Map<InputNode, Figure> nodeFig = new HashMap<InputNode, Figure>();\n+        Map<InputNode, Figure> nodeFig = new HashMap<>();\n@@ -733,1 +700,1 @@\n-            InputNode n = f.getFirstSourceNode();\n+            InputNode n = f.getInputNode();\n@@ -741,2 +708,1 @@\n-        Map<Figure, Integer> figureRank =\n-            new HashMap<Figure, Integer>(figures.size());\n+        Map<Figure, Integer> figureRank = new HashMap<>(figures.size());\n@@ -744,1 +710,1 @@\n-        for (InputBlock b : getModel().getGraphToView().getBlocks()) {\n+        for (InputBlock b : diagram.getInputBlocks()) {\n@@ -775,1 +741,1 @@\n-        Diagram diagram = getModel().getDiagramToView();\n+        Diagram diagram = getModel().getDiagram();\n@@ -777,1 +743,1 @@\n-        SceneAnimator animator = this.getSceneAnimator();\n+        SceneAnimator animator = getSceneAnimator();\n@@ -842,1 +808,1 @@\n-        this.validate();\n+        validate();\n@@ -905,3 +871,1 @@\n-            if (p == specialNullPoint) {\n-            } else if (lastPoint == specialNullPoint) {\n-            } else if (lastPoint != null) {\n+            if (p != specialNullPoint && lastPoint != specialNullPoint && lastPoint != null) {\n@@ -922,1 +886,0 @@\n-                this.addObject(new ConnectionSet(connectionList), w);\n@@ -937,13 +900,0 @@\n-    private class ConnectionSet {\n-\n-        private Set<Connection> connections;\n-\n-        public ConnectionSet(Collection<Connection> connections) {\n-            connections = new HashSet<>(connections);\n-        }\n-\n-        public Set<Connection> getConnectionSet() {\n-            return Collections.unmodifiableSet(connections);\n-        }\n-    }\n-\n@@ -955,1 +905,1 @@\n-    public void gotoFigures(final List<Figure> figures) {\n+    private void gotoFigures(final List<Figure> figures) {\n@@ -964,0 +914,1 @@\n+                assert r != null;\n@@ -978,1 +929,1 @@\n-    public void gotoBlock(final Block block) {\n+    private void gotoBlock(final Block block) {\n@@ -985,2 +936,1 @@\n-    private Set<Object> idSetToObjectSet(Set<Object> ids) {\n-\n+    private Set<Object> idSetToObjectSet(Set<Integer> ids) {\n@@ -988,2 +938,2 @@\n-        for (Figure f : getModel().getDiagramToView().getFigures()) {\n-            if (DiagramScene.doesIntersect(f.getSource().getSourceNodesAsSet(), ids)) {\n+        for (Figure f : getModel().getDiagram().getFigures()) {\n+            if (ids.contains(f.getInputNode().getId())) {\n@@ -994,1 +944,1 @@\n-                if (DiagramScene.doesIntersect(s.getSource().getSourceNodesAsSet(), ids)) {\n+                if (!Collections.disjoint(s.getSource().getSourceNodesAsSet(), ids)) {\n@@ -1002,1 +952,1 @@\n-    public void gotoSelection(Set<Object> ids) {\n+    private void gotoSelection(Set<Integer> ids) {\n@@ -1005,1 +955,1 @@\n-        Set<Integer> hiddenNodes = new HashSet<>(this.getModel().getHiddenNodes());\n+        Set<Integer> hiddenNodes = new HashSet<>(getModel().getHiddenNodes());\n@@ -1007,1 +957,1 @@\n-        this.getModel().showNot(hiddenNodes);\n+        getModel().setHiddenNodes(hiddenNodes);\n@@ -1017,0 +967,1 @@\n+                assert r != null;\n@@ -1052,1 +1003,0 @@\n-\n@@ -1075,22 +1025,1 @@\n-        for (Integer n : f.getSource().getSourceNodesAsSet()) {\n-            if (getModel().getHiddenNodes().contains(n)) {\n-                return false;\n-            }\n-        }\n-        return true;\n-    }\n-\n-    public static boolean doesIntersect(Set<?> s1, Set<?> s2) {\n-        if (s1.size() > s2.size()) {\n-            Set<?> tmp = s1;\n-            s1 = s2;\n-            s2 = tmp;\n-        }\n-\n-        for (Object o : s1) {\n-            if (s2.contains(o)) {\n-                return true;\n-            }\n-        }\n-\n-        return false;\n+        return !getModel().getHiddenNodes().contains(f.getInputNode().getId());\n@@ -1113,1 +1042,1 @@\n-        Diagram diagram = getModel().getDiagramToView();\n+        Diagram diagram = getModel().getDiagram();\n@@ -1116,1 +1045,1 @@\n-        Set<InputBlock> visibleBlocks = new HashSet<InputBlock>();\n+        Set<InputBlock> visibleBlocks = new HashSet<>();\n@@ -1127,1 +1056,1 @@\n-            for (InputBlock b : diagram.getGraph().getBlocks()) {\n+            for (InputBlock b : diagram.getInputBlocks()) {\n@@ -1136,2 +1065,0 @@\n-            boolean hiddenAfter = doesIntersect(f.getSource().getSourceNodesAsSet(), newHiddenNodes);\n-\n@@ -1140,7 +1067,1 @@\n-            if (!hiddenAfter) {\n-                \/\/ Figure is shown\n-                w.setVisible(true);\n-                for (InputNode n : f.getSource().getSourceNodes()) {\n-                    visibleBlocks.add(diagram.getGraph().getBlock(n));\n-                }\n-            } else {\n+            if (newHiddenNodes.contains(f.getInputNode().getId())) {\n@@ -1149,0 +1070,4 @@\n+            } else {\n+                \/\/ Figure is shown\n+                w.setVisible(true);\n+                visibleBlocks.add(f.getBlock().getInputBlock());\n@@ -1171,3 +1096,1 @@\n-                        for (InputNode n : f.getSource().getSourceNodes()) {\n-                            visibleBlocks.add(diagram.getGraph().getBlock(n));\n-                        }\n+                        visibleBlocks.add(f.getBlock().getInputBlock());\n@@ -1189,1 +1112,1 @@\n-                if (f.getBlock().isArtificial()) {\n+                if (f.getBlock().getInputBlock().isArtificial()) {\n@@ -1196,1 +1119,1 @@\n-                visibleBlocks.addAll(diagram.getGraph().getBlocks());\n+                visibleBlocks.addAll(diagram.getInputBlocks());\n@@ -1201,1 +1124,1 @@\n-            for (InputBlock b : diagram.getGraph().getBlocks()) {\n+            for (InputBlock b : diagram.getInputBlocks()) {\n@@ -1209,7 +1132,1 @@\n-                if (visibleAfter) {\n-                    \/\/ Block must be shown\n-                    w.setVisible(true);\n-                } else {\n-                    \/\/ Block must be hidden\n-                    w.setVisible(false);\n-                }\n+                w.setVisible(visibleAfter);\n@@ -1222,1 +1139,1 @@\n-        this.validate();\n+        validate();\n@@ -1228,14 +1145,2 @@\n-        newHiddenNodes.removeAll(f.getSource().getSourceNodesAsSet());\n-        this.model.setHiddenNodes(newHiddenNodes);\n-    }\n-\n-    public void show(final Figure f) {\n-        showFigure(f);\n-    }\n-\n-    public void setSelectedObjects(Object... args) {\n-        Set<Object> set = new HashSet<>();\n-        for (Object o : args) {\n-            set.add(o);\n-        }\n-        super.setSelectedObjects(set);\n+        newHiddenNodes.remove(f.getInputNode().getId());\n+        getModel().setHiddenNodes(newHiddenNodes);\n@@ -1247,0 +1152,1 @@\n+        assert r != null;\n@@ -1258,1 +1164,1 @@\n-            setSelection(Arrays.asList(f));\n+            setSelection(Collections.singletonList(f));\n@@ -1266,1 +1172,1 @@\n-        if (this.getSelectedObjects().isEmpty()) {\n+        if (getSelectedObjects().isEmpty()) {\n@@ -1281,4 +1187,4 @@\n-        private DiagramViewModel oldModel;\n-        private DiagramViewModel newModel;\n-        private Point oldScrollPosition;\n-        private DiagramScene scene;\n+        private final DiagramViewModel oldModel;\n+        private final DiagramViewModel newModel;\n+        private final Point oldScrollPosition;\n+        private final DiagramScene scene;\n@@ -1315,7 +1221,1 @@\n-            SwingUtilities.invokeLater(new Runnable() {\n-\n-                @Override\n-                public void run() {\n-                    scene.setScrollPosition(oldScrollPosition);\n-                }\n-            });\n+            SwingUtilities.invokeLater(() -> scene.setScrollPosition(oldScrollPosition));\n@@ -1329,5 +1229,1 @@\n-            if (oldModel.getHiddenNodes().equals(newModel.getHiddenNodes())) {\n-                scene.smallUpdate(false);\n-            } else {\n-                scene.smallUpdate(true);\n-            }\n+            scene.smallUpdate(!oldModel.getHiddenNodes().equals(newModel.getHiddenNodes()));\n@@ -1338,2 +1234,2 @@\n-    public void setUndoRedoEnabled(boolean b) {\n-        this.undoRedoEnabled = b;\n+    private void setUndoRedoEnabled(boolean enable) {\n+        undoRedoEnabled = enable;\n@@ -1342,1 +1238,1 @@\n-    public boolean getUndoRedoEnabled() {\n+    private boolean getUndoRedoEnabled() {\n@@ -1379,1 +1275,1 @@\n-            this.getUndoRedoManager().undoableEditHappened(new UndoableEditEvent(this, new DiagramUndoRedo(this, this.getScrollPosition(), modelCopy, newModelCopy)));\n+            getUndoRedoManager().undoableEditHappened(new UndoableEditEvent(this, new DiagramUndoRedo(this, getScrollPosition(), modelCopy, newModelCopy)));\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/DiagramScene.java","additions":247,"deletions":351,"binary":false,"changes":598,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import com.sun.hotspot.igv.data.Properties;\n@@ -38,0 +39,1 @@\n+import java.util.*;\n@@ -39,7 +41,0 @@\n-import java.util.Arrays;\n-import java.util.ArrayList;\n-import java.util.Collection;\n-import java.util.HashSet;\n-import java.util.Iterator;\n-import java.util.List;\n-import java.util.Set;\n@@ -57,1 +52,0 @@\n-    private Set<Integer> onScreenNodes;\n@@ -62,5 +56,5 @@\n-    private InputGraph inputGraph;\n-    private ChangedEvent<DiagramViewModel> diagramChangedEvent;\n-    private ChangedEvent<DiagramViewModel> viewChangedEvent;\n-    private ChangedEvent<DiagramViewModel> hiddenNodesChangedEvent;\n-    private ChangedEvent<DiagramViewModel> viewPropertiesChangedEvent;\n+    private InputGraph cachedInputGraph;\n+    private final ChangedEvent<DiagramViewModel> diagramChangedEvent;\n+    private final ChangedEvent<DiagramViewModel> viewChangedEvent;\n+    private final ChangedEvent<DiagramViewModel> hiddenNodesChangedEvent;\n+    private final ChangedEvent<DiagramViewModel> viewPropertiesChangedEvent;\n@@ -73,1 +67,0 @@\n-    private ChangedListener<FilterChain> filterChainChangedListener = new ChangedListener<FilterChain>() {\n@@ -75,5 +68,1 @@\n-        @Override\n-        public void changed(FilterChain source) {\n-            diagramChanged();\n-        }\n-    };\n+    private final ChangedListener<FilterChain> filterChainChangedListener = source -> updateDiagram();\n@@ -83,1 +72,1 @@\n-        DiagramViewModel result = new DiagramViewModel(group, filterChain, sequenceFilterChain);\n+        DiagramViewModel result = new DiagramViewModel(cachedInputGraph, filterChain, sequenceFilterChain);\n@@ -94,3 +83,0 @@\n-        boolean diagramChanged = false;\n-        boolean viewChanged = false;\n-        boolean viewPropertiesChanged = false;\n@@ -109,2 +95,1 @@\n-        diagramChanged |= (filterChain != newModel.filterChain);\n-        this.filterChain = newModel.filterChain;\n+        boolean diagramChanged = filterChain != newModel.filterChain;\n@@ -112,1 +97,0 @@\n-        this.sequenceFilterChain = newModel.sequenceFilterChain;\n@@ -114,5 +98,2 @@\n-        this.diagram = newModel.diagram;\n-        viewChanged |= (hiddenNodes != newModel.hiddenNodes);\n-        this.hiddenNodes = newModel.hiddenNodes;\n-        viewChanged |= (onScreenNodes != newModel.onScreenNodes);\n-        this.onScreenNodes = newModel.onScreenNodes;\n+\n+        boolean viewChanged = hiddenNodes != newModel.hiddenNodes;\n@@ -120,3 +101,2 @@\n-        this.selectedNodes = newModel.selectedNodes;\n-        viewPropertiesChanged |= (showSea != newModel.showSea);\n-        this.showSea = newModel.showSea;\n+\n+        boolean viewPropertiesChanged = (showSea != newModel.showSea);\n@@ -124,1 +104,0 @@\n-        this.showBlocks = newModel.showBlocks;\n@@ -126,1 +105,0 @@\n-        this.showCFG = newModel.showCFG;\n@@ -128,1 +106,10 @@\n-        this.showNodeHull = newModel.showNodeHull;\n+\n+        filterChain = newModel.filterChain;\n+        sequenceFilterChain = newModel.sequenceFilterChain;\n+        diagram = newModel.diagram;\n+        hiddenNodes = newModel.hiddenNodes;\n+        selectedNodes = newModel.selectedNodes;\n+        showSea = newModel.showSea;\n+        showBlocks = newModel.showBlocks;\n+        showCFG = newModel.showCFG;\n+        showNodeHull = newModel.showNodeHull;\n@@ -201,2 +188,0 @@\n-    public DiagramViewModel(Group g, FilterChain filterChain, FilterChain sequenceFilterChain) {\n-        super(Arrays.asList(\"default\"));\n@@ -204,6 +189,9 @@\n-        this.showSea = Settings.get().getInt(Settings.DEFAULT_VIEW, Settings.DEFAULT_VIEW_DEFAULT) == Settings.DefaultView.SEA_OF_NODES;\n-        this.showBlocks = Settings.get().getInt(Settings.DEFAULT_VIEW, Settings.DEFAULT_VIEW_DEFAULT) == Settings.DefaultView.CLUSTERED_SEA_OF_NODES;\n-        this.showCFG = Settings.get().getInt(Settings.DEFAULT_VIEW, Settings.DEFAULT_VIEW_DEFAULT) == Settings.DefaultView.CONTROL_FLOW_GRAPH;\n-        this.showNodeHull = true;\n-        this.showEmptyBlocks = true;\n-        this.group = g;\n+    public DiagramViewModel(InputGraph graph, FilterChain filterChain, FilterChain sequenceFilterChain) {\n+        super(Collections.singletonList(\"default\"));\n+\n+        showSea = Settings.get().getInt(Settings.DEFAULT_VIEW, Settings.DEFAULT_VIEW_DEFAULT) == Settings.DefaultView.SEA_OF_NODES;\n+        showBlocks = Settings.get().getInt(Settings.DEFAULT_VIEW, Settings.DEFAULT_VIEW_DEFAULT) == Settings.DefaultView.CLUSTERED_SEA_OF_NODES;\n+        showCFG = Settings.get().getInt(Settings.DEFAULT_VIEW, Settings.DEFAULT_VIEW_DEFAULT) == Settings.DefaultView.CONTROL_FLOW_GRAPH;\n+        showNodeHull = true;\n+        showEmptyBlocks = true;\n+        group = graph.getGroup();\n@@ -217,1 +205,0 @@\n-        onScreenNodes = new HashSet<>();\n@@ -225,1 +212,0 @@\n-\n@@ -228,0 +214,2 @@\n+\n+        selectGraph(graph);\n@@ -269,4 +257,0 @@\n-    public Set<Integer> getOnScreenNodes() {\n-        return onScreenNodes;\n-    }\n-\n@@ -276,1 +260,1 @@\n-        for (String s : getPositions()) {\n+        for (String ignored : getPositions()) {\n@@ -314,5 +298,1 @@\n-    public void showNot(final Set<Integer> nodes) {\n-        setHiddenNodes(nodes);\n-    }\n-\n-    public void showFigures(Collection<Figure> f) {\n+    public void showFigures(Collection<Figure> figures) {\n@@ -320,2 +300,2 @@\n-        for (Figure fig : f) {\n-            newHiddenNodes.removeAll(fig.getSource().getSourceNodesAsSet());\n+        for (Figure f : figures) {\n+            newHiddenNodes.remove(f.getInputNode().getId());\n@@ -330,4 +310,2 @@\n-            for (InputNode node : f.getSource().getSourceNodes()) {\n-                if (getSelectedNodes().contains(node.getId())) {\n-                    result.add(f);\n-                }\n+            if (getSelectedNodes().contains(f.getInputNode().getId())) {\n+                result.add(f);\n@@ -344,1 +322,1 @@\n-        final HashSet<Integer> allNodes = new HashSet<>(getGraphToView().getGroup().getAllNodes());\n+        final HashSet<Integer> allNodes = new HashSet<>(getGroup().getAllNodes());\n@@ -354,5 +332,0 @@\n-    public void setOnScreenNodes(Set<Integer> onScreenNodes) {\n-        this.onScreenNodes = onScreenNodes;\n-        viewChangedEvent.fire();\n-    }\n-\n@@ -363,9 +336,1 @@\n-    public void setSequenceFilterChain(FilterChain chain) {\n-        assert chain != null : \"sequenceFilterChain must never be null\";\n-        sequenceFilterChain.getChangedEvent().removeListener(filterChainChangedListener);\n-        sequenceFilterChain = chain;\n-        sequenceFilterChain.getChangedEvent().addListener(filterChainChangedListener);\n-        diagramChanged();\n-    }\n-\n-    private void diagramChanged() {\n+    private void updateDiagram() {\n@@ -373,2 +338,20 @@\n-        diagram = null;\n-        getDiagramChangedEvent().fire();\n+        InputGraph graph = getGraph();\n+        if (graph.getBlocks().isEmpty()) {\n+            Scheduler s = Lookup.getDefault().lookup(Scheduler.class);\n+            graph.clearBlocks();\n+            s.schedule(graph);\n+            graph.ensureNodesInBlocks();\n+        }\n+        diagram = new Diagram(graph,\n+                Settings.get().get(Settings.NODE_TEXT, Settings.NODE_TEXT_DEFAULT),\n+                Settings.get().get(Settings.NODE_SHORT_TEXT, Settings.NODE_SHORT_TEXT_DEFAULT),\n+                Settings.get().get(Settings.NODE_TINY_TEXT, Settings.NODE_TINY_TEXT_DEFAULT));\n+        getFilterChain().apply(diagram, getSequenceFilterChain());\n+        if (graph.isDiffGraph()) {\n+            ColorFilter f = new ColorFilter(\"\");\n+            f.addRule(stateColorRule(\"same\",    Color.white));\n+            f.addRule(stateColorRule(\"changed\", Color.orange));\n+            f.addRule(stateColorRule(\"new\",     Color.green));\n+            f.addRule(stateColorRule(\"deleted\", Color.red));\n+            f.apply(diagram);\n+        }\n@@ -376,0 +359,1 @@\n+        getDiagramChangedEvent().fire();\n@@ -382,8 +366,0 @@\n-    public void setFilterChain(FilterChain chain) {\n-        assert chain != null : \"filterChain must never be null\";\n-        filterChain.getChangedEvent().removeListener(filterChainChangedListener);\n-        filterChain = chain;\n-        filterChain.getChangedEvent().addListener(filterChainChangedListener);\n-        diagramChanged();\n-    }\n-\n@@ -465,25 +441,1 @@\n-    public Diagram getDiagramToView() {\n-\n-        if (diagram == null) {\n-            InputGraph graph = getGraphToView();\n-            if (graph.getBlocks().isEmpty()) {\n-                Scheduler s = Lookup.getDefault().lookup(Scheduler.class);\n-                graph.clearBlocks();\n-                s.schedule(graph);\n-                graph.ensureNodesInBlocks();\n-            }\n-            diagram = Diagram.createDiagram(graph,\n-                                            Settings.get().get(Settings.NODE_TEXT, Settings.NODE_TEXT_DEFAULT),\n-                                            Settings.get().get(Settings.NODE_SHORT_TEXT, Settings.NODE_SHORT_TEXT_DEFAULT),\n-                                            Settings.get().get(Settings.NODE_TINY_TEXT, Settings.NODE_TINY_TEXT_DEFAULT));\n-            getFilterChain().apply(diagram, getSequenceFilterChain());\n-            if (graph.isDiffGraph()) {\n-                ColorFilter f = new ColorFilter(\"\");\n-                f.addRule(stateColorRule(\"same\",    Color.white));\n-                f.addRule(stateColorRule(\"changed\", Color.orange));\n-                f.addRule(stateColorRule(\"new\",     Color.green));\n-                f.addRule(stateColorRule(\"deleted\", Color.red));\n-                f.apply(diagram);\n-           }\n-        }\n-\n+    public Diagram getDiagram() {\n@@ -494,10 +446,2 @@\n-    public InputGraph getGraphToView() {\n-        if (inputGraph == null) {\n-            if (getFirstGraph() != getSecondGraph()) {\n-                inputGraph = Difference.createDiffGraph(getFirstGraph(), getSecondGraph());\n-            } else {\n-                inputGraph = getFirstGraph();\n-            }\n-        }\n-\n-        return inputGraph;\n+    public InputGraph getGraph() {\n+        return cachedInputGraph;\n@@ -508,8 +452,4 @@\n-        inputGraph = null;\n-        diagramChanged();\n-    }\n-\n-    void setSelectedFigures(List<Figure> list) {\n-        Set<Integer> newSelectedNodes = new HashSet<>();\n-        for (Figure f : list) {\n-            newSelectedNodes.addAll(f.getSource().getSourceNodesAsSet());\n+        if (getFirstGraph() != getSecondGraph()) {\n+            cachedInputGraph = Difference.createDiffGraph(getFirstGraph(), getSecondGraph());\n+        } else {\n+            cachedInputGraph = getFirstGraph();\n@@ -517,1 +457,1 @@\n-        this.setSelectedNodes(newSelectedNodes);\n+        updateDiagram();\n@@ -527,1 +467,2 @@\n-        return new Iterable<InputGraph>() {\n+        return () -> new Iterator<InputGraph>() {\n+            int index = getFirstPosition();\n@@ -530,8 +471,3 @@\n-            public Iterator<InputGraph> iterator() {\n-                return new Iterator<InputGraph>() {\n-                    int index = getFirstPosition();\n-\n-                    @Override\n-                    public boolean hasNext() {\n-                        return index + 1 < graphs.size();\n-                    }\n+            public boolean hasNext() {\n+                return index + 1 < graphs.size();\n+            }\n@@ -539,5 +475,3 @@\n-                    @Override\n-                    public InputGraph next() {\n-                        return graphs.get(++index);\n-                    }\n-                };\n+            @Override\n+            public InputGraph next() {\n+                return graphs.get(++index);\n@@ -549,5 +483,2 @@\n-        return new Iterable<InputGraph>() {\n-            @Override\n-            public Iterator<InputGraph> iterator() {\n-                return new Iterator<InputGraph>() {\n-                    int index = getFirstPosition();\n+        return () -> new Iterator<InputGraph>() {\n+            int index = getFirstPosition();\n@@ -555,4 +486,4 @@\n-                    @Override\n-                    public boolean hasNext() {\n-                        return index - 1 > 0;\n-                    }\n+            @Override\n+            public boolean hasNext() {\n+                return index - 1 > 0;\n+            }\n@@ -560,5 +491,3 @@\n-                    @Override\n-                    public InputGraph next() {\n-                        return graphs.get(--index);\n-                    }\n-                };\n+            @Override\n+            public InputGraph next() {\n+                return graphs.get(--index);\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/DiagramViewModel.java","additions":89,"deletions":160,"binary":false,"changes":249,"status":"modified"},{"patch":"@@ -69,0 +69,1 @@\n+\n@@ -70,0 +71,1 @@\n+    \n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/DiagramViewer.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-import com.sun.hotspot.igv.data.Properties;\n@@ -28,1 +27,0 @@\n-import com.sun.hotspot.igv.data.Properties.PropertyMatcher;\n@@ -79,1 +77,2 @@\n-    public EditorTopComponent(Diagram diagram) {\n+\n+    public EditorTopComponent(InputGraph graph) {\n@@ -122,0 +121,1 @@\n+        add(container, BorderLayout.NORTH);\n@@ -123,4 +123,3 @@\n-        DiagramViewModel diagramViewModel = new DiagramViewModel(diagram.getGraph().getGroup(), filterChain, sequence);\n-        RangeSlider rangeSlider = new RangeSlider();\n-        rangeSlider.setModel(diagramViewModel);\n-        if (diagram.getGraph().getGroup().getGraphsCount() == 1) {\n+        DiagramViewModel diagramViewModel = new DiagramViewModel(graph, filterChain, sequence);\n+        RangeSlider rangeSlider = new RangeSlider(diagramViewModel);\n+        if (diagramViewModel.getGroup().getGraphs().size() == 1) {\n@@ -131,1 +130,0 @@\n-        add(container, BorderLayout.NORTH);\n@@ -140,6 +138,4 @@\n-        diagramViewModel.getDiagramChangedEvent().addListener(source -> {\n-            setDisplayName(getDiagram().getName());\n-            setToolTipText(getDiagram().getGraph().getGroup().getName());\n-            Collection<Object> list = new ArrayList<>();\n-            list.add(new EditorInputGraphProvider(EditorTopComponent.this));\n-            graphContent.set(list, null);\n+        diagramViewModel.getDiagramChangedEvent().addListener(model -> {\n+            setDisplayName(model.getGraph().getName());\n+            setToolTipText(model.getGroup().getName());\n+            graphContent.set(Collections.singletonList(new EditorInputGraphProvider(this)), null);\n@@ -147,1 +143,0 @@\n-        diagramViewModel.selectGraph(diagram.getGraph());\n@@ -149,1 +144,1 @@\n-        Group group = getDiagram().getGraph().getGroup();\n+        Group group = diagramViewModel.getGroup();\n@@ -255,1 +250,1 @@\n-        return getModel().getDiagramToView();\n+        return getModel().getDiagram();\n@@ -331,6 +326,0 @@\n-    public void setSelection(PropertyMatcher matcher) {\n-        Properties.PropertySelector<Figure> selector = new Properties.PropertySelector<>(getDiagram().getFigures());\n-        List<Figure> list = selector.selectMultiple(matcher);\n-        setSelectedFigures(list);\n-    }\n-\n@@ -349,5 +338,2 @@\n-            for (InputNode n : f.getSource().getSourceNodes()) {\n-                if (ids.contains(n.getId())) {\n-                    list.add(f);\n-                    break;\n-                }\n+            if (ids.contains(f.getInputNode().getId())) {\n+                list.add(f);\n@@ -362,1 +348,1 @@\n-            if (f.getBlock() == b) {\n+            if (f.getBlock().getInputBlock() == b) {\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/EditorTopComponent.java","additions":15,"deletions":29,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -1,216 +0,0 @@\n-\/*\n- * Copyright (c) 2008, 2015, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-package com.sun.hotspot.igv.view;\n-\n-import java.awt.*;\n-import java.awt.event.*;\n-import javax.swing.JComponent;\n-import org.netbeans.api.visual.widget.Scene;\n-\n-\/**\n- * @author David Kaspar\n- * @author Thomas Wuerthinger\n- *\/\n-public class ExtendedSatelliteComponent extends JComponent implements MouseListener, MouseMotionListener, Scene.SceneListener, ComponentListener {\n-\n-    private DiagramScene scene;\n-    private Image image;\n-    private int imageWidth;\n-    private int imageHeight;\n-\n-    public ExtendedSatelliteComponent(DiagramScene scene) {\n-        this.scene = scene;\n-        setDoubleBuffered(true);\n-        setPreferredSize(new Dimension(128, 128));\n-        addMouseListener(this);\n-        addMouseMotionListener(this);\n-    }\n-\n-    @Override\n-    public void addNotify() {\n-        super.addNotify();\n-        scene.addSceneListener(this);\n-        JComponent viewComponent = scene.getView();\n-        if (viewComponent == null) {\n-            viewComponent = scene.createView();\n-        }\n-        viewComponent.addComponentListener(this);\n-        repaint();\n-    }\n-\n-    @Override\n-    public void removeNotify() {\n-        scene.getView().removeComponentListener(this);\n-        scene.removeSceneListener(this);\n-        super.removeNotify();\n-    }\n-\n-    public void update() {\n-        this.image = null;\n-        if (this.isVisible()) {\n-            repaint();\n-            revalidate();\n-            validate();\n-        }\n-    }\n-\n-    @Override\n-    public void paint(Graphics g) {\n-        Graphics2D gr = (Graphics2D) g;\n-        super.paint(g);\n-        Rectangle bounds = scene.getBounds();\n-        Dimension size = getSize();\n-\n-        double sx = bounds.width > 0 ? (double) size.width \/ bounds.width : 0.0;\n-        double sy = bounds.width > 0 ? (double) size.height \/ bounds.height : 0.0;\n-        double scale = Math.min(sx, sy);\n-\n-        int vw = (int) (scale * bounds.width);\n-        int vh = (int) (scale * bounds.height);\n-        int vx = (size.width - vw) \/ 2;\n-        int vy = (size.height - vh) \/ 2;\n-\n-\n-        if (image == null || vw != imageWidth || vh != imageHeight) {\n-            imageWidth = vw;\n-            imageHeight = vh;\n-            image = this.createImage(imageWidth, imageHeight);\n-            Graphics2D ig = (Graphics2D) image.getGraphics();\n-            ig.scale(scale, scale);\n-            double oldFactor = scene.getZoomFactor();\n-            scene.setZoomFactor(scale);\n-            scene.paint(ig);\n-            scene.setZoomFactor(oldFactor);\n-        }\n-\n-        gr.drawImage(image, vx, vy, this);\n-\n-        JComponent component = scene.getView();\n-        double zoomFactor = scene.getZoomFactor();\n-        Rectangle viewRectangle = component != null ? component.getVisibleRect() : null;\n-        if (viewRectangle != null) {\n-            Rectangle window = new Rectangle(\n-                    (int) ((double) viewRectangle.x * scale \/ zoomFactor),\n-                    (int) ((double) viewRectangle.y * scale \/ zoomFactor),\n-                    (int) ((double) viewRectangle.width * scale \/ zoomFactor),\n-                    (int) ((double) viewRectangle.height * scale \/ zoomFactor));\n-            window.translate(vx, vy);\n-            gr.setColor(new Color(200, 200, 200, 128));\n-            gr.fill(window);\n-            gr.setColor(Color.BLACK);\n-            gr.drawRect(window.x, window.y, window.width - 1, window.height - 1);\n-        }\n-    }\n-\n-    @Override\n-    public void mouseClicked(MouseEvent e) {\n-    }\n-\n-    @Override\n-    public void mousePressed(MouseEvent e) {\n-        moveVisibleRect(e.getPoint());\n-    }\n-\n-    @Override\n-    public void mouseReleased(MouseEvent e) {\n-        moveVisibleRect(e.getPoint());\n-    }\n-\n-    @Override\n-    public void mouseEntered(MouseEvent e) {\n-    }\n-\n-    @Override\n-    public void mouseExited(MouseEvent e) {\n-    }\n-\n-    @Override\n-    public void mouseDragged(MouseEvent e) {\n-        moveVisibleRect(e.getPoint());\n-    }\n-\n-    @Override\n-    public void mouseMoved(MouseEvent e) {\n-    }\n-\n-    private void moveVisibleRect(Point center) {\n-        JComponent component = scene.getView();\n-        if (component == null) {\n-            return;\n-        }\n-        double zoomFactor = scene.getZoomFactor();\n-        Rectangle bounds = scene.getBounds();\n-        Dimension size = getSize();\n-\n-        double sx = bounds.width > 0 ? (double) size.width \/ bounds.width : 0.0;\n-        double sy = bounds.width > 0 ? (double) size.height \/ bounds.height : 0.0;\n-        double scale = Math.min(sx, sy);\n-\n-        int vw = (int) (scale * bounds.width);\n-        int vh = (int) (scale * bounds.height);\n-        int vx = (size.width - vw) \/ 2;\n-        int vy = (size.height - vh) \/ 2;\n-\n-        int cx = (int) ((double) (center.x - vx) \/ scale * zoomFactor);\n-        int cy = (int) ((double) (center.y - vy) \/ scale * zoomFactor);\n-\n-        Rectangle visibleRect = component.getVisibleRect();\n-        visibleRect.x = cx - visibleRect.width \/ 2;\n-        visibleRect.y = cy - visibleRect.height \/ 2;\n-        component.scrollRectToVisible(visibleRect);\n-\n-        this.repaint();\n-    }\n-\n-    @Override\n-    public void sceneRepaint() {\n-    \/\/repaint ();\n-    }\n-\n-    @Override\n-    public void sceneValidating() {\n-    }\n-\n-    @Override\n-    public void sceneValidated() {\n-    }\n-\n-    @Override\n-    public void componentResized(ComponentEvent e) {\n-        repaint();\n-    }\n-\n-    @Override\n-    public void componentMoved(ComponentEvent e) {\n-        repaint();\n-    }\n-\n-    @Override\n-    public void componentShown(ComponentEvent e) {\n-    }\n-\n-    @Override\n-    public void componentHidden(ComponentEvent e) {\n-    }\n-}\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/ExtendedSatelliteComponent.java","additions":0,"deletions":216,"binary":false,"changes":216,"status":"deleted"},{"patch":"@@ -66,6 +66,1 @@\n-        Diagram diagram = Diagram.createDiagram(graph,\n-                                                Settings.get().get(Settings.NODE_TEXT, Settings.NODE_TEXT_DEFAULT),\n-                                                Settings.get().get(Settings.NODE_SHORT_TEXT, Settings.NODE_SHORT_TEXT_DEFAULT),\n-                                                Settings.get().get(Settings.NODE_TINY_TEXT, Settings.NODE_TINY_TEXT_DEFAULT));\n-        EditorTopComponent tc = new EditorTopComponent(diagram);\n-        diagram.setCFG(tc.getModel().getShowCFG());\n+        EditorTopComponent tc = new EditorTopComponent(graph);\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/GraphViewerImplementation.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -179,8 +179,5 @@\n-            response.addResult(new Runnable() {\n-                @Override\n-                public void run() {\n-                    Message desc = new NotifyDescriptor.Message(\"An exception occurred during the search, \"\n-                            + \"perhaps due to a malformed query string:\\n\" + msg,\n-                            NotifyDescriptor.WARNING_MESSAGE);\n-                    DialogDisplayer.getDefault().notify(desc);\n-                }\n+            response.addResult(() -> {\n+                Message desc = new Message(\"An exception occurred during the search, \"\n+                        + \"perhaps due to a malformed query string:\\n\" + msg,\n+                        NotifyDescriptor.WARNING_MESSAGE);\n+                DialogDisplayer.getDefault().notify(desc);\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/NodeQuickSearch.java","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -26,4 +26,1 @@\n-import org.netbeans.api.visual.widget.Widget;\n-import org.netbeans.api.visual.action.WidgetAction;\n-import org.netbeans.api.visual.action.SelectProvider;\n-\n+import java.awt.Point;\n@@ -31,2 +28,3 @@\n-import java.awt.event.KeyEvent;\n-import java.awt.*;\n+import org.netbeans.api.visual.action.SelectProvider;\n+import org.netbeans.api.visual.action.WidgetAction;\n+import org.netbeans.api.visual.widget.Widget;\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/actions\/CustomSelectAction.java","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -53,1 +53,0 @@\n-import javax.swing.JScrollBar;\n@@ -55,2 +54,0 @@\n-import org.netbeans.api.visual.action.WidgetAction.State;\n-import org.netbeans.api.visual.action.WidgetAction.WidgetMouseEvent;\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/actions\/CustomizablePanAction.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-            for (Figure f : editor.getModel().getDiagramToView().getFigures()) {\n+            for (Figure f : editor.getModel().getDiagram().getFigures()) {\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/actions\/ExpandAdjacentAction.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,6 +36,1 @@\n-import org.openide.util.HelpCtx;\n-import org.openide.util.ImageUtilities;\n-import org.openide.util.Lookup;\n-import org.openide.util.LookupEvent;\n-import org.openide.util.LookupListener;\n-import org.openide.util.NbBundle;\n+import org.openide.util.*;\n@@ -43,1 +38,0 @@\n-import org.openide.util.Utilities;\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/actions\/ExportAction.java","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -72,1 +72,1 @@\n-        model.showNot(nodes);\n+        model.setHiddenNodes(nodes);\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/actions\/HideAction.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+import com.sun.hotspot.igv.view.EditorTopComponent;\n@@ -30,2 +31,0 @@\n-\n-import com.sun.hotspot.igv.view.EditorTopComponent;\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/actions\/HideDuplicatesAction.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,59 +0,0 @@\n-\/*\n- * Copyright (c) 2008, 2015, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-package com.sun.hotspot.igv.view.actions;\n-\n-import org.netbeans.api.visual.action.HoverProvider;\n-import org.netbeans.api.visual.action.WidgetAction;\n-import org.netbeans.api.visual.action.WidgetAction.State;\n-import org.netbeans.api.visual.widget.Widget;\n-\n-\/**\n- *\n- * @author Thomas Wuerthinger\n- *\/\n-public class MouseOverAction extends WidgetAction.Adapter {\n-\n-    private long eventID = Integer.MIN_VALUE;\n-    private HoverProvider provider;\n-\n-    public MouseOverAction(HoverProvider provider) {\n-        this.provider = provider;\n-    }\n-\n-    @Override\n-    public State mouseMoved(Widget widget, WidgetMouseEvent event) {\n-        long id = event.getEventID();\n-        if (id != eventID) {\n-            eventID = id;\n-            provider.widgetHovered(widget);\n-        }\n-        return State.REJECTED;\n-    }\n-\n-    @Override\n-    public State mouseExited(Widget widget, WidgetMouseEvent event) {\n-        provider.widgetHovered(null);\n-        return State.REJECTED;\n-    }\n-}\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/actions\/MouseOverAction.java","additions":0,"deletions":59,"binary":false,"changes":59,"status":"deleted"},{"patch":"@@ -26,1 +26,1 @@\n-import java.awt.*;\n+import com.sun.hotspot.igv.view.EditorTopComponent;\n@@ -30,2 +30,0 @@\n-\n-import com.sun.hotspot.igv.view.EditorTopComponent;\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/actions\/OverviewAction.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+import com.sun.hotspot.igv.view.EditorTopComponent;\n@@ -30,2 +31,0 @@\n-\n-import com.sun.hotspot.igv.view.EditorTopComponent;\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/actions\/PredSuccAction.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+import com.sun.hotspot.igv.view.EditorTopComponent;\n@@ -30,2 +31,0 @@\n-\n-import com.sun.hotspot.igv.view.EditorTopComponent;\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/actions\/SelectionModeAction.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -68,1 +68,1 @@\n-        model.showNot(new HashSet<>());\n+        model.setHiddenNodes(new HashSet<>());\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/actions\/ShowAllAction.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+import com.sun.hotspot.igv.view.EditorTopComponent;\n@@ -30,1 +31,0 @@\n-import javax.swing.Action;\n@@ -32,2 +32,0 @@\n-\n-import com.sun.hotspot.igv.view.EditorTopComponent;\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/actions\/ShowEmptyBlocksAction.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,1 +31,4 @@\n-import javax.swing.*;\n+import javax.swing.BorderFactory;\n+import javax.swing.DefaultComboBoxModel;\n+import javax.swing.JComboBox;\n+import javax.swing.JTextField;\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/actions\/ZoomLevelAction.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -28,6 +28,1 @@\n-import java.awt.BasicStroke;\n-import java.awt.Color;\n-import java.awt.Font;\n-import java.awt.Graphics2D;\n-import java.awt.Rectangle;\n-import java.awt.Stroke;\n+import java.awt.*;\n@@ -44,1 +39,0 @@\n-    public static final int BORDER = 20;\n@@ -49,1 +43,0 @@\n-    private Diagram diagram;\n@@ -54,1 +47,0 @@\n-        this.diagram = d;\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/widgets\/BlockWidget.java","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-import com.sun.hotspot.igv.data.InputGraph;\n@@ -28,1 +27,1 @@\n-import com.sun.hotspot.igv.data.services.GraphViewer;\n+import com.sun.hotspot.igv.graph.Diagram;\n@@ -36,1 +35,0 @@\n-import java.awt.event.ActionEvent;\n@@ -40,1 +38,0 @@\n-import javax.swing.AbstractAction;\n@@ -60,1 +57,0 @@\n-import org.openide.util.Lookup;\n@@ -68,1 +64,0 @@\n-    public static final boolean VERTICAL_LAYOUT = true;\n@@ -71,2 +66,0 @@\n-    private Widget leftWidget;\n-    private Widget rightWidget;\n@@ -89,4 +82,0 @@\n-    public Node getNode() {\n-        return node;\n-    }\n-\n@@ -147,1 +136,1 @@\n-            lw.setFont(figure.getDiagram().getFont());\n+            lw.setFont(Diagram.FONT);\n@@ -187,8 +176,0 @@\n-    public Widget getLeftWidget() {\n-        return leftWidget;\n-    }\n-\n-    public Widget getRightWidget() {\n-        return rightWidget;\n-    }\n-\n@@ -199,1 +180,1 @@\n-        Font font = this.figure.getDiagram().getFont();\n+        Font font = Diagram.FONT;\n@@ -202,1 +183,1 @@\n-            font = this.figure.getDiagram().getBoldFont();\n+            font = Diagram.BOLD_FONT;\n@@ -289,21 +270,0 @@\n-        if (getFigure().getSubgraphs() != null) {\n-            menu.addSeparator();\n-            JMenu subgraphs = new JMenu(\"Subgraphs\");\n-            menu.add(subgraphs);\n-\n-            final GraphViewer viewer = Lookup.getDefault().lookup(GraphViewer.class);\n-            for (final InputGraph subgraph : getFigure().getSubgraphs()) {\n-                Action a = new AbstractAction() {\n-\n-                    @Override\n-                    public void actionPerformed(ActionEvent e) {\n-                        viewer.view(subgraph, true);\n-                    }\n-                };\n-\n-                a.setEnabled(true);\n-                a.putValue(Action.NAME, subgraph.getName());\n-                subgraphs.add(a);\n-            }\n-        }\n-\n@@ -386,1 +346,0 @@\n-\n@@ -388,3 +347,3 @@\n-            final Set<Integer> hiddenNodes = new HashSet<>(diagramScene.getModel().getGraphToView().getGroup().getAllNodes());\n-            hiddenNodes.removeAll(this.getFigure().getSource().getSourceNodesAsSet());\n-            this.diagramScene.getModel().showNot(hiddenNodes);\n+            final Set<Integer> hiddenNodes = new HashSet<>(diagramScene.getModel().getGroup().getAllNodes());\n+            hiddenNodes.remove(this.getFigure().getInputNode().getId());\n+            this.diagramScene.getModel().setHiddenNodes(hiddenNodes);\n@@ -392,1 +351,0 @@\n-\n@@ -394,2 +352,2 @@\n-            hiddenNodes.removeAll(this.getFigure().getSource().getSourceNodesAsSet());\n-            this.diagramScene.getModel().showNot(hiddenNodes);\n+            hiddenNodes.remove(this.getFigure().getInputNode().getId());\n+            this.diagramScene.getModel().setHiddenNodes(hiddenNodes);\n@@ -398,2 +356,2 @@\n-            hiddenNodes.addAll(this.getFigure().getSource().getSourceNodesAsSet());\n-            this.diagramScene.getModel().showNot(hiddenNodes);\n+            hiddenNodes.add(this.getFigure().getInputNode().getId());\n+            this.diagramScene.getModel().setHiddenNodes(hiddenNodes);\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/widgets\/FigureWidget.java","additions":11,"deletions":53,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -61,11 +61,0 @@\n-\/*\n-    protected Point calculateRelativeLocation() {\n-        if (getFigureWidget().getBounds() == null) {\n-            return new Point(0, 0);\n-        }\n-\n-        double x = 0;\n-        List<InputSlot> slots = inputSlot.getFigure().getInputSlots();\n-        assert slots.contains(inputSlot);\n-        return new Point((int) x, (int) (calculateRelativeY(slots.size(), slots.indexOf(inputSlot))));\n-    }*\/\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/widgets\/InputSlotWidget.java","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+import com.sun.hotspot.igv.graph.Block;\n@@ -29,1 +30,0 @@\n-import com.sun.hotspot.igv.graph.Block;\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/widgets\/LineWidget.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+import com.sun.hotspot.igv.graph.Diagram;\n@@ -31,6 +32,1 @@\n-import java.awt.BasicStroke;\n-import java.awt.Color;\n-import java.awt.Font;\n-import java.awt.Graphics2D;\n-import java.awt.Point;\n-import java.awt.Rectangle;\n+import java.awt.*;\n@@ -38,0 +34,1 @@\n+import java.util.Collections;\n@@ -108,1 +105,1 @@\n-            Font font = this.getSlot().getFigure().getDiagram().getSlotFont();\n+            Font font = Diagram.SLOT_FONT;\n@@ -173,1 +170,1 @@\n-            hiddenNodes = new HashSet<>(diagramScene.getModel().getGraphToView().getGroup().getAllNodes());\n+            hiddenNodes = new HashSet<>(diagramScene.getModel().getGroup().getAllNodes());\n@@ -177,1 +174,1 @@\n-        for (Figure f : diagramScene.getModel().getDiagramToView().getFigures()) {\n+        for (Figure f : diagramScene.getModel().getDiagram().getFigures()) {\n@@ -179,1 +176,1 @@\n-                if (DiagramScene.doesIntersect(s.getSource().getSourceNodesAsSet(), slot.getSource().getSourceNodesAsSet())) {\n+                if (!Collections.disjoint(s.getSource().getSourceNodesAsSet(), slot.getSource().getSourceNodesAsSet())) {\n@@ -181,1 +178,1 @@\n-                    hiddenNodes.removeAll(f.getSource().getSourceNodesAsSet());\n+                    hiddenNodes.remove(f.getInputNode().getId());\n@@ -187,1 +184,1 @@\n-            this.diagramScene.getModel().showNot(hiddenNodes);\n+            this.diagramScene.getModel().setHiddenNodes(hiddenNodes);\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/widgets\/SlotWidget.java","additions":9,"deletions":12,"binary":false,"changes":21,"status":"modified"},{"filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/resources\/com\/sun\/hotspot\/igv\/view\/images\/hideDuplicates.png","binary":true,"status":"deleted"},{"patch":"@@ -26,15 +26,15 @@\n-   version=\"1.1\"\n-   id=\"Vector_Icons\"\n-   x=\"0px\"\n-   y=\"0px\"\n-   width=\"16px\"\n-   height=\"16px\"\n-   viewBox=\"0 0 16 16\"\n-   style=\"enable-background:new 0 0 16 16;\"\n-   xml:space=\"preserve\"\n-   sodipodi:docname=\"zoomIn.svg\"\n-   inkscape:version=\"1.2.1 (9c6d41e, 2022-07-14)\"\n-   xmlns:inkscape=\"http:\/\/www.inkscape.org\/namespaces\/inkscape\"\n-   xmlns:sodipodi=\"http:\/\/sodipodi.sourceforge.net\/DTD\/sodipodi-0.dtd\"\n-   xmlns=\"http:\/\/www.w3.org\/2000\/svg\"\n-   xmlns:svg=\"http:\/\/www.w3.org\/2000\/svg\"><defs\n+        version=\"1.1\"\n+        id=\"Vector_Icons\"\n+        x=\"0px\"\n+        y=\"0px\"\n+        width=\"16px\"\n+        height=\"16px\"\n+        viewBox=\"0 0 16 16\"\n+        style=\"enable-background:new 0 0 16 16;\"\n+        xml:space=\"preserve\"\n+        sodipodi:docname=\"zoomIn.svg\"\n+        inkscape:version=\"1.2.1 (9c6d41e, 2022-07-14)\"\n+        xmlns:inkscape=\"http:\/\/www.inkscape.org\/namespaces\/inkscape\"\n+        xmlns:sodipodi=\"http:\/\/sodipodi.sourceforge.net\/DTD\/sodipodi-0.dtd\"\n+        xmlns=\"http:\/\/www.w3.org\/2000\/svg\"\n+><defs\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/resources\/com\/sun\/hotspot\/igv\/view\/images\/zoomIn.svg","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -26,15 +26,15 @@\n-   version=\"1.1\"\n-   id=\"Vector_Icons\"\n-   x=\"0px\"\n-   y=\"0px\"\n-   width=\"16px\"\n-   height=\"16px\"\n-   viewBox=\"0 0 16 16\"\n-   style=\"enable-background:new 0 0 16 16;\"\n-   xml:space=\"preserve\"\n-   sodipodi:docname=\"zoomIn.svg\"\n-   inkscape:version=\"1.2.1 (9c6d41e, 2022-07-14)\"\n-   xmlns:inkscape=\"http:\/\/www.inkscape.org\/namespaces\/inkscape\"\n-   xmlns:sodipodi=\"http:\/\/sodipodi.sourceforge.net\/DTD\/sodipodi-0.dtd\"\n-   xmlns=\"http:\/\/www.w3.org\/2000\/svg\"\n-   xmlns:svg=\"http:\/\/www.w3.org\/2000\/svg\"><defs\n+        version=\"1.1\"\n+        id=\"Vector_Icons\"\n+        x=\"0px\"\n+        y=\"0px\"\n+        width=\"16px\"\n+        height=\"16px\"\n+        viewBox=\"0 0 16 16\"\n+        style=\"enable-background:new 0 0 16 16;\"\n+        xml:space=\"preserve\"\n+        sodipodi:docname=\"zoomIn.svg\"\n+        inkscape:version=\"1.2.1 (9c6d41e, 2022-07-14)\"\n+        xmlns:inkscape=\"http:\/\/www.inkscape.org\/namespaces\/inkscape\"\n+        xmlns:sodipodi=\"http:\/\/sodipodi.sourceforge.net\/DTD\/sodipodi-0.dtd\"\n+        xmlns=\"http:\/\/www.w3.org\/2000\/svg\"\n+><defs\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/resources\/com\/sun\/hotspot\/igv\/view\/images\/zoomOut.svg","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -26,15 +26,15 @@\n-   version=\"1.1\"\n-   id=\"Vector_Icons\"\n-   x=\"0px\"\n-   y=\"0px\"\n-   width=\"16px\"\n-   height=\"16px\"\n-   viewBox=\"0 0 16 16\"\n-   style=\"enable-background:new 0 0 16 16;\"\n-   xml:space=\"preserve\"\n-   sodipodi:docname=\"zoomReset.svg\"\n-   inkscape:version=\"1.2.1 (9c6d41e, 2022-07-14)\"\n-   xmlns:inkscape=\"http:\/\/www.inkscape.org\/namespaces\/inkscape\"\n-   xmlns:sodipodi=\"http:\/\/sodipodi.sourceforge.net\/DTD\/sodipodi-0.dtd\"\n-   xmlns=\"http:\/\/www.w3.org\/2000\/svg\"\n-   xmlns:svg=\"http:\/\/www.w3.org\/2000\/svg\"><defs\n+        version=\"1.1\"\n+        id=\"Vector_Icons\"\n+        x=\"0px\"\n+        y=\"0px\"\n+        width=\"16px\"\n+        height=\"16px\"\n+        viewBox=\"0 0 16 16\"\n+        style=\"enable-background:new 0 0 16 16;\"\n+        xml:space=\"preserve\"\n+        sodipodi:docname=\"zoomReset.svg\"\n+        inkscape:version=\"1.2.1 (9c6d41e, 2022-07-14)\"\n+        xmlns:inkscape=\"http:\/\/www.inkscape.org\/namespaces\/inkscape\"\n+        xmlns:sodipodi=\"http:\/\/sodipodi.sourceforge.net\/DTD\/sodipodi-0.dtd\"\n+        xmlns=\"http:\/\/www.w3.org\/2000\/svg\"\n+><defs\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/resources\/com\/sun\/hotspot\/igv\/view\/images\/zoomReset.svg","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"}]}