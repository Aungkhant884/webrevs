{"files":[{"patch":"@@ -240,1 +240,0 @@\n-            assert w.getBounds() != null;\n","filename":"src\/utils\/IdealGraphVisualizer\/ControlFlow\/src\/main\/java\/com\/sun\/hotspot\/igv\/controlflow\/ControlFlowScene.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -103,0 +103,1 @@\n+\n@@ -106,0 +107,1 @@\n+\n@@ -107,0 +109,1 @@\n+\n@@ -110,0 +113,1 @@\n+\n","filename":"src\/utils\/IdealGraphVisualizer\/Coordinator\/src\/main\/java\/com\/sun\/hotspot\/igv\/coordinator\/OutlineTopComponent.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -110,0 +110,30 @@\n+    public String getType() {\n+        return getProperties().get(\"type\");\n+\n+    }\n+\n+    InputGraph getPrev(InputGraph graph) {\n+        InputGraph lastGraph = null;\n+        for (FolderElement e : getElements()) {\n+            if (e == graph) {\n+                return lastGraph;\n+            }\n+            if (e instanceof InputGraph) {\n+                lastGraph = (InputGraph) e;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    InputGraph getNext(InputGraph graph) {\n+        boolean found = false;\n+        for (FolderElement e : getElements()) {\n+            if (e == graph) {\n+                found = true;\n+            } else if (found && e instanceof InputGraph) {\n+                return (InputGraph) e;\n+            }\n+        }\n+        return null;\n+    }\n+\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/main\/java\/com\/sun\/hotspot\/igv\/data\/Group.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-import java.lang.ref.WeakReference;\n+import java.util.Comparator;\n@@ -28,1 +28,0 @@\n-import java.util.WeakHashMap;\n@@ -43,0 +42,14 @@\n+    public static final Comparator<InputEdge> OUTGOING_COMPARATOR = (o1, o2) -> {\n+            if(o1.getFromIndex() == o2.getFromIndex()) {\n+                return o1.getTo() - o2.getTo();\n+            }\n+            return o1.getFromIndex() - o2.getFromIndex();\n+        };\n+\n+    public static final Comparator<InputEdge> INGOING_COMPARATOR = (o1, o2) -> {\n+            if(o1.getToIndex() == o2.getToIndex()) {\n+                return o1.getFrom() - o2.getFrom();\n+            }\n+            return o1.getToIndex() - o2.getToIndex();\n+        };\n+\n@@ -61,25 +74,0 @@\n-    static WeakHashMap<InputEdge, WeakReference<InputEdge>> immutableCache = new WeakHashMap<>();\n-\n-    public static synchronized InputEdge createImmutable(char fromIndex, char toIndex, int from, int to, String label, String type) {\n-        InputEdge edge = new InputEdge(fromIndex, toIndex, from, to, label, type, State.IMMUTABLE);\n-        WeakReference<InputEdge> result = immutableCache.get(edge);\n-        if (result != null) {\n-            InputEdge edge2 = result.get();\n-            if (edge2 != null) {\n-                return edge2;\n-            }\n-        }\n-        immutableCache.put(edge, new WeakReference<>(edge));\n-        return edge;\n-    }\n-\n-    public InputEdge(char fromIndex, char toIndex, int from, int to, String label, String type, State state) {\n-        this.toIndex = toIndex;\n-        this.fromIndex = fromIndex;\n-        this.from = from;\n-        this.to = to;\n-        this.state = state;\n-        this.label = label;\n-        this.type = type;\n-    }\n-\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/main\/java\/com\/sun\/hotspot\/igv\/data\/InputEdge.java","additions":15,"deletions":27,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -98,0 +98,74 @@\n+    public List<InputNode> findRootNodes() {\n+        List<InputNode> result = new ArrayList<>();\n+        Set<Integer> nonRoot = new HashSet<>();\n+        for(InputEdge curEdges : getEdges()) {\n+            nonRoot.add(curEdges.getTo());\n+        }\n+\n+        for(InputNode node : getNodes()) {\n+            if(!nonRoot.contains(node.getId())) {\n+                result.add(node);\n+            }\n+        }\n+\n+        return result;\n+    }\n+\n+    public Map<InputNode, List<InputEdge>> findAllOutgoingEdges() {\n+        Map<InputNode, List<InputEdge>> result = new HashMap<>(getNodes().size());\n+        for(InputNode n : this.getNodes()) {\n+            result.put(n, new ArrayList<>());\n+        }\n+\n+        for(InputEdge e : this.edges) {\n+            int from = e.getFrom();\n+            InputNode fromNode = this.getNode(from);\n+            List<InputEdge> fromList = result.get(fromNode);\n+            assert fromList != null;\n+            fromList.add(e);\n+        }\n+\n+        for(InputNode n : this.getNodes()) {\n+            List<InputEdge> list = result.get(n);\n+            list.sort(InputEdge.OUTGOING_COMPARATOR);\n+        }\n+\n+        return result;\n+    }\n+\n+    public Map<InputNode, List<InputEdge>> findAllIngoingEdges() {\n+        Map<InputNode, List<InputEdge>> result = new HashMap<>(getNodes().size());\n+        for(InputNode n : this.getNodes()) {\n+            result.put(n, new ArrayList<InputEdge>());\n+        }\n+\n+        for(InputEdge e : this.edges) {\n+            int to = e.getTo();\n+            InputNode toNode = this.getNode(to);\n+            List<InputEdge> toList = result.get(toNode);\n+            assert toList != null;\n+            toList.add(e);\n+        }\n+\n+        for(InputNode n : this.getNodes()) {\n+            List<InputEdge> list = result.get(n);\n+            list.sort(InputEdge.INGOING_COMPARATOR);\n+        }\n+\n+        return result;\n+    }\n+\n+    public List<InputEdge> findOutgoingEdges(InputNode n) {\n+        List<InputEdge> result = new ArrayList<>();\n+\n+        for(InputEdge e : this.edges) {\n+            if(e.getFrom() == n.getId()) {\n+                result.add(e);\n+            }\n+        }\n+\n+        result.sort(InputEdge.OUTGOING_COMPARATOR);\n+\n+        return result;\n+    }\n+\n@@ -141,0 +215,8 @@\n+    public InputGraph getNext() {\n+        return parentGroup.getNext(this);\n+    }\n+\n+    public InputGraph getPrev() {\n+        return parentGroup.getPrev(this);\n+    }\n+\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/main\/java\/com\/sun\/hotspot\/igv\/data\/InputGraph.java","additions":82,"deletions":0,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -52,0 +52,1 @@\n+    public static final String INDENT = \"  \";\n@@ -65,0 +66,6 @@\n+    public static final String GROUP_NAME_PROPERTY = \"name\";\n+    public static final String METHOD_IS_PUBLIC_PROPERTY = \"public\";\n+    public static final String METHOD_IS_STATIC_PROPERTY = \"static\";\n+    public static final String TRUE_VALUE = \"true\";\n+    public static final String NODE_NAME_PROPERTY = \"name\";\n+    public static final String EDGE_NAME_PROPERTY = \"name\";\n@@ -85,0 +92,1 @@\n+    public static final String ASSEMBLY_ELEMENT = \"assembly\";\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/main\/java\/com\/sun\/hotspot\/igv\/data\/serialization\/Parser.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -27,0 +27,5 @@\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n@@ -121,0 +126,85 @@\n+\n+    \/**\n+     * Test of findRootNodes method, of class InputGraph.\n+     *\/\n+    @Test\n+    public void testFindRootNodes() {\n+        assertTrue(emptyGraph.findRootNodes().isEmpty());\n+\n+        List<InputNode> result = referenceGraph.findRootNodes();\n+        assertTrue(result.size() == 2);\n+        assertTrue(result.contains(N1));\n+        assertTrue(result.contains(N5));\n+    }\n+\n+    \/**\n+     * Test of findAllOutgoingEdges method, of class InputGraph.\n+     *\/\n+    @Test\n+    public void testFindAllOutgoingEdges() {\n+        assertTrue(emptyGraph.findAllOutgoingEdges().isEmpty());\n+\n+        Map<InputNode, List<InputEdge>> result = referenceGraph.findAllOutgoingEdges();\n+        assertTrue(result.size() == 5);\n+        assertEquals(result.get(N1), Arrays.asList(E12, E13));\n+        assertEquals(result.get(N2), Arrays.asList(E24));\n+        assertEquals(result.get(N3), Arrays.asList(E34));\n+        assertEquals(result.get(N4), Arrays.asList());\n+        assertEquals(result.get(N5), Arrays.asList(E54));\n+    }\n+\n+    \/**\n+     * Test of findAllIngoingEdges method, of class InputGraph.\n+     *\/\n+    @Test\n+    public void testFindAllIngoingEdges() {\n+        assertTrue(emptyGraph.findAllIngoingEdges().isEmpty());\n+\n+        Map<InputNode, List<InputEdge>> result = referenceGraph.findAllIngoingEdges();\n+        assertTrue(result.size() == 5);\n+        assertEquals(result.get(N1), Arrays.asList());\n+        assertEquals(result.get(N2), Arrays.asList(E12));\n+        assertEquals(result.get(N3), Arrays.asList(E13));\n+        assertEquals(result.get(N4), Arrays.asList(E24, E34, E54));\n+        assertEquals(result.get(N5), Arrays.asList());\n+    }\n+\n+    \/**\n+     * Test of findOutgoingEdges method, of class InputGraph.\n+     *\/\n+    @Test\n+    public void testFindOutgoingEdges() {\n+        assertTrue(emptyGraph.findOutgoingEdges(new InputNode(1)).isEmpty());\n+\n+        assertEquals(referenceGraph.findOutgoingEdges(N1), Arrays.asList(E12, E13));\n+        assertEquals(referenceGraph.findOutgoingEdges(N2), Arrays.asList(E24));\n+        assertEquals(referenceGraph.findOutgoingEdges(N3), Arrays.asList(E34));\n+        assertEquals(referenceGraph.findOutgoingEdges(N4), Arrays.asList());\n+        assertEquals(referenceGraph.findOutgoingEdges(N5), Arrays.asList(E54));\n+    }\n+\n+    \/**\n+     * Test of getNext method, of class InputGraph.\n+     *\/\n+    @Test\n+    public void testGetNextPrev() {\n+        final Group group = new Group(null);\n+\n+        final InputGraph a = new InputGraph(\"a\");\n+\n+        final InputGraph b = new InputGraph(\"b\");\n+\n+        final InputGraph c = new InputGraph(\"c\");\n+        group.addElement(a);\n+        group.addElement(b);\n+        group.addElement(c);\n+\n+        assertEquals(null, a.getPrev());\n+        assertEquals(b, a.getNext());\n+\n+        assertEquals(a, b.getPrev());\n+        assertEquals(c, b.getNext());\n+\n+        assertEquals(b, c.getPrev());\n+        assertEquals(null, c.getNext());\n+    }\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/test\/java\/com\/sun\/hotspot\/igv\/data\/InputGraphTest.java","additions":90,"deletions":0,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -28,2 +28,1 @@\n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.fail;\n+import static org.junit.Assert.*;\n@@ -57,1 +56,1 @@\n-        if (a.getGraphs().size() != b.getGraphs().size()) {\n+        if (a.getElements().size() != b.getElements().size()) {\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/test\/java\/com\/sun\/hotspot\/igv\/data\/Util.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import com.sun.hotspot.igv.data.Properties;\n@@ -236,0 +237,34 @@\n+    public void printStatistics() {\n+        System.out.println(\"=============================================================\");\n+        System.out.println(\"Diagram statistics\");\n+\n+        List<Figure> tmpFigures = getFigures();\n+        Set<FigureConnection> connections = getConnections();\n+\n+        System.out.println(\"Number of figures: \" + tmpFigures.size());\n+        System.out.println(\"Number of connections: \" + connections.size());\n+\n+        List<Figure> figuresSorted = new ArrayList<>(tmpFigures);\n+        figuresSorted.sort(new Comparator<Figure>() {\n+\n+            @Override\n+            public int compare(Figure a, Figure b) {\n+                return b.getPredecessors().size() + b.getSuccessors().size() - a.getPredecessors().size() - a.getSuccessors().size();\n+            }\n+        });\n+\n+        final int COUNT = 10;\n+        int z = 0;\n+        for (Figure f : figuresSorted) {\n+\n+            z++;\n+            int sum = f.getPredecessors().size() + f.getSuccessors().size();\n+            System.out.println(\"#\" + z + \": \" + f + \", predCount=\" + f.getPredecessors().size() + \" succCount=\" + f.getSuccessors().size());\n+            if (sum < COUNT) {\n+                break;\n+            }\n+\n+        }\n+\n+        System.out.println(\"=============================================================\");\n+    }\n","filename":"src\/utils\/IdealGraphVisualizer\/Graph\/src\/main\/java\/com\/sun\/hotspot\/igv\/graph\/Diagram.java","additions":35,"deletions":0,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-            return editor.getModel().getGraphToView();\n+            return editor.getModel().getGraph();\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/EditorInputGraphProvider.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,15 +26,15 @@\n-        version=\"1.1\"\n-        id=\"Vector_Icons\"\n-        x=\"0px\"\n-        y=\"0px\"\n-        width=\"16px\"\n-        height=\"16px\"\n-        viewBox=\"0 0 16 16\"\n-        style=\"enable-background:new 0 0 16 16;\"\n-        xml:space=\"preserve\"\n-        sodipodi:docname=\"zoomIn.svg\"\n-        inkscape:version=\"1.2.1 (9c6d41e, 2022-07-14)\"\n-        xmlns:inkscape=\"http:\/\/www.inkscape.org\/namespaces\/inkscape\"\n-        xmlns:sodipodi=\"http:\/\/sodipodi.sourceforge.net\/DTD\/sodipodi-0.dtd\"\n-        xmlns=\"http:\/\/www.w3.org\/2000\/svg\"\n-><defs\n+   version=\"1.1\"\n+   id=\"Vector_Icons\"\n+   x=\"0px\"\n+   y=\"0px\"\n+   width=\"16px\"\n+   height=\"16px\"\n+   viewBox=\"0 0 16 16\"\n+   style=\"enable-background:new 0 0 16 16;\"\n+   xml:space=\"preserve\"\n+   sodipodi:docname=\"zoomIn.svg\"\n+   inkscape:version=\"1.2.1 (9c6d41e, 2022-07-14)\"\n+   xmlns:inkscape=\"http:\/\/www.inkscape.org\/namespaces\/inkscape\"\n+   xmlns:sodipodi=\"http:\/\/sodipodi.sourceforge.net\/DTD\/sodipodi-0.dtd\"\n+   xmlns=\"http:\/\/www.w3.org\/2000\/svg\"\n+   xmlns:svg=\"http:\/\/www.w3.org\/2000\/svg\"><defs\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/resources\/com\/sun\/hotspot\/igv\/view\/images\/zoomIn.svg","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -26,15 +26,15 @@\n-        version=\"1.1\"\n-        id=\"Vector_Icons\"\n-        x=\"0px\"\n-        y=\"0px\"\n-        width=\"16px\"\n-        height=\"16px\"\n-        viewBox=\"0 0 16 16\"\n-        style=\"enable-background:new 0 0 16 16;\"\n-        xml:space=\"preserve\"\n-        sodipodi:docname=\"zoomIn.svg\"\n-        inkscape:version=\"1.2.1 (9c6d41e, 2022-07-14)\"\n-        xmlns:inkscape=\"http:\/\/www.inkscape.org\/namespaces\/inkscape\"\n-        xmlns:sodipodi=\"http:\/\/sodipodi.sourceforge.net\/DTD\/sodipodi-0.dtd\"\n-        xmlns=\"http:\/\/www.w3.org\/2000\/svg\"\n-><defs\n+   version=\"1.1\"\n+   id=\"Vector_Icons\"\n+   x=\"0px\"\n+   y=\"0px\"\n+   width=\"16px\"\n+   height=\"16px\"\n+   viewBox=\"0 0 16 16\"\n+   style=\"enable-background:new 0 0 16 16;\"\n+   xml:space=\"preserve\"\n+   sodipodi:docname=\"zoomIn.svg\"\n+   inkscape:version=\"1.2.1 (9c6d41e, 2022-07-14)\"\n+   xmlns:inkscape=\"http:\/\/www.inkscape.org\/namespaces\/inkscape\"\n+   xmlns:sodipodi=\"http:\/\/sodipodi.sourceforge.net\/DTD\/sodipodi-0.dtd\"\n+   xmlns=\"http:\/\/www.w3.org\/2000\/svg\"\n+   xmlns:svg=\"http:\/\/www.w3.org\/2000\/svg\"><defs\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/resources\/com\/sun\/hotspot\/igv\/view\/images\/zoomOut.svg","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -26,15 +26,15 @@\n-        version=\"1.1\"\n-        id=\"Vector_Icons\"\n-        x=\"0px\"\n-        y=\"0px\"\n-        width=\"16px\"\n-        height=\"16px\"\n-        viewBox=\"0 0 16 16\"\n-        style=\"enable-background:new 0 0 16 16;\"\n-        xml:space=\"preserve\"\n-        sodipodi:docname=\"zoomReset.svg\"\n-        inkscape:version=\"1.2.1 (9c6d41e, 2022-07-14)\"\n-        xmlns:inkscape=\"http:\/\/www.inkscape.org\/namespaces\/inkscape\"\n-        xmlns:sodipodi=\"http:\/\/sodipodi.sourceforge.net\/DTD\/sodipodi-0.dtd\"\n-        xmlns=\"http:\/\/www.w3.org\/2000\/svg\"\n-><defs\n+   version=\"1.1\"\n+   id=\"Vector_Icons\"\n+   x=\"0px\"\n+   y=\"0px\"\n+   width=\"16px\"\n+   height=\"16px\"\n+   viewBox=\"0 0 16 16\"\n+   style=\"enable-background:new 0 0 16 16;\"\n+   xml:space=\"preserve\"\n+   sodipodi:docname=\"zoomReset.svg\"\n+   inkscape:version=\"1.2.1 (9c6d41e, 2022-07-14)\"\n+   xmlns:inkscape=\"http:\/\/www.inkscape.org\/namespaces\/inkscape\"\n+   xmlns:sodipodi=\"http:\/\/sodipodi.sourceforge.net\/DTD\/sodipodi-0.dtd\"\n+   xmlns=\"http:\/\/www.w3.org\/2000\/svg\"\n+   xmlns:svg=\"http:\/\/www.w3.org\/2000\/svg\"><defs\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/resources\/com\/sun\/hotspot\/igv\/view\/images\/zoomReset.svg","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"}]}