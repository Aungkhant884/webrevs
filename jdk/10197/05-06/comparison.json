{"files":[{"patch":"@@ -1,90 +0,0 @@\n-\/*\n- * Copyright (c) 2008, 2015, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-package com.sun.hotspot.igv.hierarchicallayout;\n-\n-\/**\n- *\n- * @author Thomas Wuerthinger\n- *\/\n-public class Edge<N, E> {\n-\n-    private E data;\n-    private Node<N, E> source;\n-    private Node<N, E> dest;\n-\n-    protected Edge(Graph<N, E> graph, Node<N, E> source, Node<N, E> dest, E data) {\n-        setData(data);\n-        this.source = source;\n-        this.dest = dest;\n-        assert source != null;\n-        assert dest != null;\n-        assert source.getGraph() == dest.getGraph();\n-        assert source.getGraph() != null;\n-        assert dest.getGraph() != null;\n-    }\n-\n-    public Node<N, E> getSource() {\n-        return source;\n-    }\n-\n-    public Node<N, E> getDest() {\n-        return dest;\n-    }\n-\n-    public E getData() {\n-        return data;\n-    }\n-\n-    public void setData(E e) {\n-        data = e;\n-    }\n-\n-    public void remove() {\n-        source.getGraph().removeEdge(this, null);\n-    }\n-\n-    public boolean isSelfLoop() {\n-        return source == dest;\n-    }\n-\n-    public void reverse() {\n-\n-        \/\/ Remove from current source \/ dest\n-        source.removeOutEdge(this);\n-        dest.removeInEdge(this);\n-\n-        Node<N, E> tmp = source;\n-        source = dest;\n-        dest = tmp;\n-\n-        \/\/ Add to new source \/ dest\n-        source.addOutEdge(this);\n-        dest.addInEdge(this);\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return \"Edge (\" + source + \" -- \" + dest + \"): \" + data;\n-    }\n-}\n","filename":"src\/utils\/IdealGraphVisualizer\/HierarchicalLayout\/src\/main\/java\/com\/sun\/hotspot\/igv\/hierarchicallayout\/Edge.java","additions":0,"deletions":90,"binary":false,"changes":90,"status":"deleted"},{"patch":"@@ -1,292 +0,0 @@\n-\/*\n- * Copyright (c) 2008, 2015, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-package com.sun.hotspot.igv.hierarchicallayout;\n-\n-import java.util.*;\n-\n-\/**\n- *\n- * @author Thomas Wuerthinger\n- *\/\n-public class Graph<N, E> {\n-\n-    private HashMap<Object, Node<N, E>> nodes;\n-    private HashMap<Object, Edge<N, E>> edges;\n-    private List<Node<N, E>> nodeList;\n-\n-    public Graph() {\n-        nodes = new HashMap<>();\n-        edges = new HashMap<>();\n-        nodeList = new ArrayList<>();\n-    }\n-\n-    public Node<N, E> createNode(N data, Object key) {\n-        Node<N, E> n = new Node<>(this, data);\n-        assert key == null || !nodes.containsKey(key);\n-        if (key != null) {\n-            nodes.put(key, n);\n-        }\n-        nodeList.add(n);\n-        return n;\n-    }\n-\n-    public Edge<N, E> createEdge(Node<N, E> source, Node<N, E> dest, E data, Object key) {\n-        Edge<N, E> e = new Edge<>(this, source, dest, data);\n-        source.addOutEdge(e);\n-        dest.addInEdge(e);\n-        if (key != null) {\n-            edges.put(key, e);\n-        }\n-        return e;\n-    }\n-\n-    public Node<N, E> getNode(Object key) {\n-        return nodes.get(key);\n-    }\n-\n-    public Edge<N, E> getEdge(Object key) {\n-        return edges.get(key);\n-    }\n-\n-    public Collection<Edge<N, E>> getEdges() {\n-        return Collections.unmodifiableCollection(edges.values());\n-    }\n-\n-    public Collection<Node<N, E>> getNodes() {\n-        return Collections.unmodifiableList(nodeList);\n-    }\n-\n-    public void removeEdge(Edge<N, E> e, Object key) {\n-        assert key == null || edges.containsKey(key);\n-        if (key != null) {\n-            edges.remove(key);\n-        }\n-        e.getSource().removeOutEdge(e);\n-        e.getDest().removeInEdge(e);\n-    }\n-\n-    public class DFSTraversalVisitor {\n-\n-        public void visitNode(Node<N, E> n) {\n-        }\n-\n-        public boolean visitEdge(Edge<N, E> e, boolean backEdge) {\n-            return true;\n-        }\n-    }\n-\n-    public class BFSTraversalVisitor {\n-\n-        public void visitNode(Node<N, E> n, int depth) {\n-        }\n-    }\n-\n-    public List<Node<N, E>> getNodesWithInDegree(int x) {\n-        return getNodesWithInDegree(x, true);\n-    }\n-\n-    public List<Node<N, E>> getNodesWithInDegree(int x, boolean countSelfLoops) {\n-\n-        List<Node<N, E>> result = new ArrayList<>();\n-        for (Node<N, E> n : getNodes()) {\n-            if (n.getInDegree(countSelfLoops) == x) {\n-                result.add(n);\n-            }\n-        }\n-\n-        return result;\n-\n-    }\n-\n-    private void markReachable(Node<N, E> startingNode) {\n-        ArrayList<Node<N, E>> arr = new ArrayList<>();\n-        arr.add(startingNode);\n-        for (Node<N, E> n : getNodes()) {\n-            n.setReachable(false);\n-        }\n-        traverseDFS(arr, new DFSTraversalVisitor() {\n-\n-            @Override\n-            public void visitNode(Node<N, E> n) {\n-                n.setReachable(true);\n-            }\n-        });\n-    }\n-\n-    public void traverseBFS(Node<N, E> startingNode, BFSTraversalVisitor tv, boolean longestPath) {\n-\n-        if (longestPath) {\n-            markReachable(startingNode);\n-        }\n-\n-        for (Node<N, E> n : getNodes()) {\n-            n.setVisited(false);\n-            n.setActive(false);\n-        }\n-\n-        Queue<Node<N, E>> queue = new LinkedList<>();\n-        queue.add(startingNode);\n-        startingNode.setVisited(true);\n-        int layer = 0;\n-        Node<N, E> lastOfLayer = startingNode;\n-        Node<N, E> lastAdded = null;\n-\n-        while (!queue.isEmpty()) {\n-\n-            Node<N, E> current = queue.poll();\n-            tv.visitNode(current, layer);\n-            current.setActive(false);\n-\n-\n-            for (Edge<N, E> e : current.getOutEdges()) {\n-                if (!e.getDest().isVisited()) {\n-\n-                    boolean allow = true;\n-                    if (longestPath) {\n-                        for (Node<N, E> pred : e.getDest().getPredecessors()) {\n-                            if ((!pred.isVisited() || pred.isActive()) && pred.isReachable()) {\n-                                allow = false;\n-                                break;\n-                            }\n-                        }\n-                    }\n-\n-                    if (allow) {\n-                        queue.offer(e.getDest());\n-                        lastAdded = e.getDest();\n-                        e.getDest().setVisited(true);\n-                        e.getDest().setActive(true);\n-                    }\n-                }\n-            }\n-\n-            if (current == lastOfLayer && !queue.isEmpty()) {\n-                lastOfLayer = lastAdded;\n-                layer++;\n-            }\n-        }\n-    }\n-\n-    public void traverseDFS(DFSTraversalVisitor tv) {\n-        traverseDFS(getNodes(), tv);\n-    }\n-\n-    public void traverseDFS(Collection<Node<N, E>> startingNodes, DFSTraversalVisitor tv) {\n-\n-        for (Node<N, E> n : getNodes()) {\n-            n.setVisited(false);\n-            n.setActive(false);\n-        }\n-\n-        boolean result = false;\n-        for (Node<N, E> n : startingNodes) {\n-            traverse(tv, n);\n-        }\n-    }\n-\n-    private void traverse(DFSTraversalVisitor tv, Node<N, E> n) {\n-\n-        if (!n.isVisited()) {\n-            n.setVisited(true);\n-            n.setActive(true);\n-            tv.visitNode(n);\n-\n-            for (Edge<N, E> e : n.getOutEdges()) {\n-\n-                Node<N, E> next = e.getDest();\n-                if (next.isActive()) {\n-                    tv.visitEdge(e, true);\n-                } else {\n-                    if (tv.visitEdge(e, false)) {\n-                        traverse(tv, next);\n-                    }\n-                }\n-            }\n-\n-            n.setActive(false);\n-        }\n-\n-    }\n-\n-    public boolean hasCycles() {\n-\n-        for (Node<N, E> n : getNodes()) {\n-            n.setVisited(false);\n-            n.setActive(false);\n-        }\n-\n-        boolean result = false;\n-        for (Node<N, E> n : getNodes()) {\n-            result |= checkCycles(n);\n-            if (result) {\n-                break;\n-            }\n-        }\n-        return result;\n-    }\n-\n-    private boolean checkCycles(Node<N, E> n) {\n-\n-        if (n.isActive()) {\n-            return true;\n-        }\n-\n-        if (!n.isVisited()) {\n-\n-            n.setVisited(true);\n-            n.setActive(true);\n-\n-            for (Node<N, E> succ : n.getSuccessors()) {\n-                if (checkCycles(succ)) {\n-                    return true;\n-                }\n-            }\n-\n-            n.setActive(false);\n-\n-        }\n-\n-        return false;\n-    }\n-\n-    @Override\n-    public String toString() {\n-\n-        StringBuilder s = new StringBuilder();\n-        s.append(\"Nodes: \");\n-        for (Node<N, E> n : getNodes()) {\n-            s.append(n.toString());\n-            s.append(\"\\n\");\n-        }\n-\n-        s.append(\"Edges: \");\n-\n-        for (Edge<N, E> e : getEdges()) {\n-            s.append(e.toString());\n-            s.append(\"\\n\");\n-        }\n-\n-        return s.toString();\n-    }\n-}\n","filename":"src\/utils\/IdealGraphVisualizer\/HierarchicalLayout\/src\/main\/java\/com\/sun\/hotspot\/igv\/hierarchicallayout\/Graph.java","additions":0,"deletions":292,"binary":false,"changes":292,"status":"deleted"},{"patch":"@@ -34,1 +34,1 @@\n-public class Node<N, E> {\n+public class Node<N> {\n@@ -37,6 +37,0 @@\n-    private List<Edge<N, E>> inEdges;\n-    private List<Edge<N, E>> outEdges;\n-    private boolean visited;\n-    private boolean active;\n-    private boolean reachable;\n-    private Graph<N, E> graph;\n@@ -44,47 +38,1 @@\n-    protected boolean isVisited() {\n-        return visited;\n-    }\n-\n-    protected void setVisited(boolean b) {\n-        visited = b;\n-    }\n-\n-    protected boolean isReachable() {\n-        return reachable;\n-    }\n-\n-    protected void setReachable(boolean b) {\n-        reachable = b;\n-    }\n-\n-    protected boolean isActive() {\n-        return active;\n-    }\n-\n-    protected void setActive(boolean b) {\n-        active = b;\n-    }\n-\n-    public int getInDegree() {\n-        return getInDegree(true);\n-    }\n-\n-    public int getInDegree(boolean countSelfLoops) {\n-        if (countSelfLoops) {\n-            return inEdges.size();\n-        } else {\n-            int cnt = 0;\n-            for (Edge<N, E> e : inEdges) {\n-                if (e.getSource() != this) {\n-                    cnt++;\n-                }\n-            }\n-            return cnt;\n-        }\n-    }\n-\n-    public int getOutDegree() {\n-        return outEdges.size();\n-    }\n-\n-    protected Node(Graph<N, E> graph, N data) {\n+    protected Node(N data) {\n@@ -92,59 +40,0 @@\n-        this.graph = graph;\n-        inEdges = new ArrayList<>();\n-        outEdges = new ArrayList<>();\n-    }\n-\n-    protected void addInEdge(Edge<N, E> e) {\n-        inEdges.add(e);\n-    }\n-\n-    public Graph<N, E> getGraph() {\n-        return graph;\n-    }\n-\n-    protected void addOutEdge(Edge<N, E> e) {\n-        outEdges.add(e);\n-    }\n-\n-    protected void removeInEdge(Edge<N, E> e) {\n-        \/\/assert inEdges.contains(e);\n-        inEdges.remove(e);\n-    }\n-\n-    protected void removeOutEdge(Edge<N, E> e) {\n-        \/\/assert outEdges.contains(e);\n-        outEdges.remove(e);\n-    }\n-\n-    public List<Edge<N, E>> getInEdges() {\n-        return Collections.unmodifiableList(inEdges);\n-    }\n-\n-    public List<Edge<N, E>> getOutEdges() {\n-        return Collections.unmodifiableList(outEdges);\n-    }\n-\n-    public List<Node<N, E>> getSuccessors() {\n-        ArrayList<Node<N, E>> succ = new ArrayList<>();\n-        for (Edge<N, E> e : getOutEdges()) {\n-            Node<N, E> n = e.getDest();\n-            if (!succ.contains(n)) {\n-                succ.add(n);\n-            }\n-        }\n-        return succ;\n-    }\n-\n-    public List<Node<N, E>> getPredecessors() {\n-        ArrayList<Node<N, E>> pred = new ArrayList<>();\n-        for (Edge<N, E> e : getInEdges()) {\n-            Node<N, E> n = e.getSource();\n-            if (!pred.contains(n)) {\n-                pred.add(n);\n-            }\n-        }\n-        return pred;\n-    }\n-\n-    public N getData() {\n-        return data;\n","filename":"src\/utils\/IdealGraphVisualizer\/HierarchicalLayout\/src\/main\/java\/com\/sun\/hotspot\/igv\/hierarchicallayout\/Node.java","additions":2,"deletions":113,"binary":false,"changes":115,"status":"modified"},{"patch":"@@ -38,5 +38,5 @@\n-    private static SelectionCoordinator singleInstance = new SelectionCoordinator();\n-    private Set<Object> selectedObjects;\n-    private Set<Object> highlightedObjects;\n-    private ChangedEvent<SelectionCoordinator> selectedChangedEvent;\n-    private ChangedEvent<SelectionCoordinator> highlightedChangedEvent;\n+    private static final SelectionCoordinator singleInstance = new SelectionCoordinator();\n+    private final Set<Integer> selectedObjects;\n+    private final Set<Integer> highlightedObjects;\n+    private final ChangedEvent<SelectionCoordinator> selectedChangedEvent;\n+    private final ChangedEvent<SelectionCoordinator> highlightedChangedEvent;\n@@ -49,4 +49,4 @@\n-        selectedChangedEvent = new ChangedEvent<SelectionCoordinator>(this);\n-        highlightedChangedEvent = new ChangedEvent<SelectionCoordinator>(this);\n-        selectedObjects = new HashSet<Object>();\n-        highlightedObjects = new HashSet<Object>();\n+        selectedChangedEvent = new ChangedEvent<>(this);\n+        highlightedChangedEvent = new ChangedEvent<>(this);\n+        selectedObjects = new HashSet<>();\n+        highlightedObjects = new HashSet<>();\n@@ -55,1 +55,1 @@\n-    public Set<Object> getSelectedObjects() {\n+    public Set<Integer> getSelectedObjects() {\n@@ -59,1 +59,1 @@\n-    public Set<Object> getHighlightedObjects() {\n+    public Set<Integer> getHighlightedObjects() {\n@@ -72,1 +72,1 @@\n-    public void setSelectedObjects(Set<? extends Object> s) {\n+    public void setSelectedObjects(Set<Integer> s) {\n@@ -79,1 +79,1 @@\n-    public void setHighlightedObjects(Set<? extends Object> s) {\n+    public void setHighlightedObjects(Set<Integer> s) {\n","filename":"src\/utils\/IdealGraphVisualizer\/SelectionCoordinator\/src\/main\/java\/com\/sun\/hotspot\/igv\/selectioncoordinator\/SelectionCoordinator.java","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-    private Lookup context = null;\n@@ -49,1 +48,0 @@\n-        this.context = context;\n","filename":"src\/utils\/IdealGraphVisualizer\/Util\/src\/main\/java\/com\/sun\/hotspot\/igv\/util\/ContextAction.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-    private DoubleClickHandler handler;\n+    private final DoubleClickHandler handler;\n","filename":"src\/utils\/IdealGraphVisualizer\/Util\/src\/main\/java\/com\/sun\/hotspot\/igv\/util\/DoubleClickAction.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-    public void handleDoubleClick(Widget w, WidgetMouseEvent e);\n+    void handleDoubleClick(Widget w, WidgetMouseEvent e);\n","filename":"src\/utils\/IdealGraphVisualizer\/Util\/src\/main\/java\/com\/sun\/hotspot\/igv\/util\/DoubleClickHandler.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,2 +43,1 @@\n-        private Class<T> klass;\n-        private Result<T> result;\n+        private final Class<T> klass;\n@@ -49,1 +48,1 @@\n-            result = Utilities.actionsGlobalContext().lookupResult(klass);\n+            Result<T> result = Utilities.actionsGlobalContext().lookupResult(klass);\n","filename":"src\/utils\/IdealGraphVisualizer\/Util\/src\/main\/java\/com\/sun\/hotspot\/igv\/util\/LookupHistory.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import java.lang.reflect.InvocationTargetException;\n@@ -52,1 +51,1 @@\n-                public String getValue() throws IllegalAccessException, InvocationTargetException {\n+                public String getValue() {\n@@ -62,1 +61,1 @@\n-                public void setValue(String arg0) throws IllegalAccessException, IllegalArgumentException, InvocationTargetException {\n+                public void setValue(String arg0) throws IllegalArgumentException {\n","filename":"src\/utils\/IdealGraphVisualizer\/Util\/src\/main\/java\/com\/sun\/hotspot\/igv\/util\/PropertiesSheet.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-    private RangeSliderModel model;\n+    private final RangeSliderModel model;\n@@ -208,1 +208,1 @@\n-        return getHeight() \/ 2 - BAR_HEIGHT \/ 2;\n+        return getHeight() \/ 2.0f - BAR_HEIGHT \/ 2.0f;\n@@ -235,1 +235,1 @@\n-                    g.drawString(curS, startX + (endX - startX) \/ 2 - bounds.width \/ 2, barStartY \/ 2 + bounds.height \/ 2);\n+                    g.drawString(curS, (startX + (endX - startX) \/ 2.0f - bounds.width \/ 2.0f), barStartY \/ 2.0f + bounds.height \/ 2.0f);\n@@ -395,1 +395,1 @@\n-        if (model == null || tempModel == false) {\n+        if (model == null || !tempModel) {\n","filename":"src\/utils\/IdealGraphVisualizer\/Util\/src\/main\/java\/com\/sun\/hotspot\/igv\/util\/RangeSlider.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -41,2 +41,2 @@\n-    private ChangedEvent<RangeSliderModel> changedEvent;\n-    private ChangedEvent<RangeSliderModel> colorChangedEvent;\n+    private final ChangedEvent<RangeSliderModel> changedEvent;\n+    private final ChangedEvent<RangeSliderModel> colorChangedEvent;\n@@ -49,2 +49,1 @@\n-        boolean changed = false;\n-        changed |= (positions != model.positions);\n+        boolean changed = (positions != model.positions);\n","filename":"src\/utils\/IdealGraphVisualizer\/Util\/src\/main\/java\/com\/sun\/hotspot\/igv\/util\/RangeSliderModel.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -120,1 +120,1 @@\n-     *\n+     * <p>\n","filename":"src\/utils\/IdealGraphVisualizer\/Util\/src\/main\/java\/com\/sun\/hotspot\/igv\/util\/StringUtils.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -73,9 +73,9 @@\n-    private CustomizablePanAction panAction;\n-    private WidgetAction hoverAction;\n-    private WidgetAction selectAction;\n-    private Lookup lookup;\n-    private InstanceContent content;\n-    private Action[] actions;\n-    private Action[] actionsWithSelection;\n-    private LayerWidget connectionLayer;\n-    private JScrollPane scrollPane;\n+    private final CustomizablePanAction panAction;\n+    private final WidgetAction hoverAction;\n+    private final WidgetAction selectAction;\n+    private final Lookup lookup;\n+    private final InstanceContent content;\n+    private final Action[] actions;\n+    private final Action[] actionsWithSelection;\n+    private final LayerWidget connectionLayer;\n+    private final JScrollPane scrollPane;\n@@ -83,2 +83,2 @@\n-    private LayerWidget mainLayer;\n-    private LayerWidget blockLayer;\n+    private final LayerWidget mainLayer;\n+    private final LayerWidget blockLayer;\n@@ -111,19 +111,0 @@\n-    private PopupMenuProvider popupMenuProvider = new PopupMenuProvider() {\n-\n-        @Override\n-        public JPopupMenu getPopupMenu(Widget widget, Point localLocation) {\n-            return DiagramScene.this.createPopupMenu();\n-        }\n-    };\n-\n-    private RectangularSelectDecorator rectangularSelectDecorator = new RectangularSelectDecorator() {\n-\n-        @Override\n-        public Widget createSelectionWidget() {\n-            Widget widget = new Widget(DiagramScene.this);\n-            widget.setBorder(BorderFactory.createLineBorder(Color.black, 2));\n-            widget.setForeground(Color.red);\n-            return widget;\n-        }\n-    };\n-\n@@ -178,16 +159,1 @@\n-    private Set<Object> getObjectsFromIdSet(Set<Object> set) {\n-        Set<Object> selectedObjects = new HashSet<>();\n-        for (Figure f : getModel().getDiagram().getFigures()) {\n-            if (set.contains(f.getInputNode().getId())) {\n-                selectedObjects.add(f);\n-            }\n-\n-            for (Slot s : f.getSlots()) {\n-                if (!Collections.disjoint(s.getSource().getSourceNodesAsSet(), set)) {\n-                    selectedObjects.add(s);\n-                }\n-            }\n-        }\n-        return selectedObjects;\n-    }\n-    private ControllableChangedListener<SelectionCoordinator> highlightedCoordinatorListener = new ControllableChangedListener<SelectionCoordinator>() {\n+    private final ControllableChangedListener<SelectionCoordinator> highlightedCoordinatorListener = new ControllableChangedListener<SelectionCoordinator>() {\n@@ -197,1 +163,1 @@\n-            DiagramScene.this.setHighlightedObjects(getObjectsFromIdSet(source.getHighlightedObjects()));\n+            DiagramScene.this.setHighlightedObjects(idSetToObjectSet(source.getHighlightedObjects()));\n@@ -201,1 +167,1 @@\n-    private ControllableChangedListener<SelectionCoordinator> selectedCoordinatorListener = new ControllableChangedListener<SelectionCoordinator>() {\n+    private final ControllableChangedListener<SelectionCoordinator> selectedCoordinatorListener = new ControllableChangedListener<SelectionCoordinator>() {\n@@ -210,43 +176,0 @@\n-    private RectangularSelectProvider rectangularSelectProvider = new RectangularSelectProvider() {\n-\n-        @Override\n-        public void performSelection(Rectangle rectangle) {\n-            if (rectangle.width < 0) {\n-                rectangle.x += rectangle.width;\n-                rectangle.width *= -1;\n-            }\n-\n-            if (rectangle.height < 0) {\n-                rectangle.y += rectangle.height;\n-                rectangle.height *= -1;\n-            }\n-\n-            Set<Object> selectedObjects = new HashSet<>();\n-            for (Figure f : getModel().getDiagram().getFigures()) {\n-                FigureWidget w = getWidget(f);\n-                if (w != null) {\n-                    Rectangle r = new Rectangle(w.getBounds());\n-                    r.setLocation(w.getLocation());\n-\n-                    if (r.intersects(rectangle)) {\n-                        selectedObjects.add(f);\n-                    }\n-\n-                    for (Slot s : f.getSlots()) {\n-                        SlotWidget sw = getWidget(s);\n-                        Rectangle r2 = new Rectangle(sw.getBounds());\n-                        r2.setLocation(sw.convertLocalToScene(new Point(0, 0)));\n-\n-                        if (r2.intersects(rectangle)) {\n-                            selectedObjects.add(s);\n-                        }\n-                    }\n-                } else {\n-                    assert false : \"w should not be null here!\";\n-                }\n-            }\n-\n-            setSelectedObjects(selectedObjects);\n-        }\n-    };\n-\n@@ -276,88 +199,0 @@\n-    private ObjectSceneListener selectionChangedListener = new ObjectSceneListener() {\n-\n-        @Override\n-        public void objectAdded(ObjectSceneEvent arg0, Object arg1) {\n-        }\n-\n-        @Override\n-        public void objectRemoved(ObjectSceneEvent arg0, Object arg1) {\n-        }\n-\n-        @Override\n-        public void objectStateChanged(ObjectSceneEvent e, Object o, ObjectState oldState, ObjectState newState) {\n-        }\n-\n-        @Override\n-        public void selectionChanged(ObjectSceneEvent e, Set<Object> oldSet, Set<Object> newSet) {\n-            DiagramScene scene = (DiagramScene) e.getObjectScene();\n-            if (scene.isRebuilding()) {\n-                return;\n-            }\n-\n-            content.set(newSet, null);\n-\n-            Set<Integer> nodeSelection = new HashSet<>();\n-            for (Object o : newSet) {\n-                if (o instanceof Properties.Provider) {\n-                    final Properties.Provider provider = (Properties.Provider) o;\n-                    AbstractNode node = new AbstractNode(Children.LEAF) {\n-\n-                        @Override\n-                        protected Sheet createSheet() {\n-                            Sheet s = super.createSheet();\n-                            PropertiesSheet.initializeSheet(provider.getProperties(), s);\n-                            return s;\n-                        }\n-                    };\n-                    node.setDisplayName(provider.getProperties().get(\"name\"));\n-                    content.add(node);\n-                }\n-\n-\n-                if (o instanceof Figure) {\n-                    nodeSelection.add(((Figure) o).getInputNode().getId());\n-                } else if (o instanceof Slot) {\n-                    nodeSelection.addAll(((Slot) o).getSource().getSourceNodesAsSet());\n-                }\n-            }\n-            getModel().setSelectedNodes(nodeSelection);\n-\n-            boolean b = selectedCoordinatorListener.isEnabled();\n-            selectedCoordinatorListener.setEnabled(false);\n-            SelectionCoordinator.getInstance().setSelectedObjects(nodeSelection);\n-            selectedCoordinatorListener.setEnabled(b);\n-\n-        }\n-\n-        @Override\n-        public void highlightingChanged(ObjectSceneEvent e, Set<Object> oldSet, Set<Object> newSet) {\n-            Set<Integer> nodeHighlighting = new HashSet<>();\n-            for (Object o : newSet) {\n-                if (o instanceof Figure) {\n-                    nodeHighlighting.add(((Figure) o).getInputNode().getId());\n-                } else if (o instanceof Slot) {\n-                    nodeHighlighting.addAll(((Slot) o).getSource().getSourceNodesAsSet());\n-                }\n-            }\n-            boolean b = highlightedCoordinatorListener.isEnabled();\n-            highlightedCoordinatorListener.setEnabled(false);\n-            SelectionCoordinator.getInstance().setHighlightedObjects(nodeHighlighting);\n-            highlightedCoordinatorListener.setEnabled(true);\n-        }\n-\n-        @Override\n-        public void hoverChanged(ObjectSceneEvent e, Object oldObject, Object newObject) {\n-            Set<Object> newHighlightedObjects = new HashSet<>(DiagramScene.this.getHighlightedObjects());\n-            if (oldObject != null) {\n-                newHighlightedObjects.remove(oldObject);\n-            }\n-            if (newObject != null) {\n-                newHighlightedObjects.add(newObject);\n-            }\n-            DiagramScene.this.setHighlightedObjects(newHighlightedObjects);\n-        }\n-\n-        @Override\n-        public void focusChanged(ObjectSceneEvent arg0, Object arg1, Object arg2) {\n-        }\n-    };\n@@ -432,1 +267,1 @@\n-        this.getInputBindings().setZoomActionModifiers(Utilities.isMac() ? KeyEvent.META_MASK : KeyEvent.CTRL_MASK);\n+        this.getInputBindings().setZoomActionModifiers(Utilities.isMac() ? KeyEvent.META_DOWN_MASK : KeyEvent.CTRL_DOWN_MASK);\n@@ -434,0 +269,1 @@\n+        PopupMenuProvider popupMenuProvider = (widget, localLocation) -> DiagramScene.this.createPopupMenu();\n@@ -439,0 +275,46 @@\n+        RectangularSelectDecorator rectangularSelectDecorator = () -> {\n+            Widget widget = new Widget(DiagramScene.this);\n+            widget.setBorder(BorderFactory.createLineBorder(Color.black, 2));\n+            widget.setForeground(Color.red);\n+            return widget;\n+        };\n+        RectangularSelectProvider rectangularSelectProvider = rectangle -> {\n+            if (rectangle.width < 0) {\n+                rectangle.x += rectangle.width;\n+                rectangle.width *= -1;\n+            }\n+\n+            if (rectangle.height < 0) {\n+                rectangle.y += rectangle.height;\n+                rectangle.height *= -1;\n+            }\n+\n+            Set<Object> selectedObjects = new HashSet<>();\n+            for (Figure f : getModel().getDiagram().getFigures()) {\n+                FigureWidget w = getWidget(f);\n+                if (w != null) {\n+                    assert w.getBounds() != null;\n+                    Rectangle r = new Rectangle(w.getBounds());\n+                    r.setLocation(w.getLocation());\n+\n+                    if (r.intersects(rectangle)) {\n+                        selectedObjects.add(f);\n+                    }\n+\n+                    for (Slot s : f.getSlots()) {\n+                        SlotWidget sw = getWidget(s);\n+                        assert sw.getBounds() != null;\n+                        Rectangle r2 = new Rectangle(sw.getBounds());\n+                        r2.setLocation(sw.convertLocalToScene(new Point(0, 0)));\n+\n+                        if (r2.intersects(rectangle)) {\n+                            selectedObjects.add(s);\n+                        }\n+                    }\n+                } else {\n+                    assert false : \"w should not be null here!\";\n+                }\n+            }\n+\n+            setSelectedObjects(selectedObjects);\n+        };\n@@ -445,0 +327,87 @@\n+        ObjectSceneListener selectionChangedListener = new ObjectSceneListener() {\n+\n+            @Override\n+            public void objectAdded(ObjectSceneEvent arg0, Object arg1) {\n+            }\n+\n+            @Override\n+            public void objectRemoved(ObjectSceneEvent arg0, Object arg1) {\n+            }\n+\n+            @Override\n+            public void objectStateChanged(ObjectSceneEvent e, Object o, ObjectState oldState, ObjectState newState) {\n+            }\n+\n+            @Override\n+            public void selectionChanged(ObjectSceneEvent e, Set<Object> oldSet, Set<Object> newSet) {\n+                DiagramScene scene = (DiagramScene) e.getObjectScene();\n+                if (scene.isRebuilding()) {\n+                    return;\n+                }\n+\n+                content.set(newSet, null);\n+\n+                Set<Integer> nodeSelection = new HashSet<>();\n+                for (Object o : newSet) {\n+                    if (o instanceof Properties.Provider) {\n+                        final Properties.Provider provider = (Properties.Provider) o;\n+                        AbstractNode node = new AbstractNode(Children.LEAF) {\n+\n+                            @Override\n+                            protected Sheet createSheet() {\n+                                Sheet s = super.createSheet();\n+                                PropertiesSheet.initializeSheet(provider.getProperties(), s);\n+                                return s;\n+                            }\n+                        };\n+                        node.setDisplayName(provider.getProperties().get(\"name\"));\n+                        content.add(node);\n+                    }\n+\n+\n+                    if (o instanceof Figure) {\n+                        nodeSelection.add(((Figure) o).getInputNode().getId());\n+                    } else if (o instanceof Slot) {\n+                        nodeSelection.addAll(((Slot) o).getSource().getSourceNodesAsSet());\n+                    }\n+                }\n+                getModel().setSelectedNodes(nodeSelection);\n+\n+                boolean b = selectedCoordinatorListener.isEnabled();\n+                selectedCoordinatorListener.setEnabled(false);\n+                SelectionCoordinator.getInstance().setSelectedObjects(nodeSelection);\n+                selectedCoordinatorListener.setEnabled(b);\n+\n+            }\n+\n+            @Override\n+            public void highlightingChanged(ObjectSceneEvent e, Set<Object> oldSet, Set<Object> newSet) {\n+                Set<Integer> nodeHighlighting = new HashSet<>();\n+                for (Object o : newSet) {\n+                    if (o instanceof Figure) {\n+                        nodeHighlighting.add(((Figure) o).getInputNode().getId());\n+                    } else if (o instanceof Slot) {\n+                        nodeHighlighting.addAll(((Slot) o).getSource().getSourceNodesAsSet());\n+                    }\n+                }\n+                highlightedCoordinatorListener.setEnabled(false);\n+                SelectionCoordinator.getInstance().setHighlightedObjects(nodeHighlighting);\n+                highlightedCoordinatorListener.setEnabled(true);\n+            }\n+\n+            @Override\n+            public void hoverChanged(ObjectSceneEvent e, Object oldObject, Object newObject) {\n+                Set<Object> newHighlightedObjects = new HashSet<>(DiagramScene.this.getHighlightedObjects());\n+                if (oldObject != null) {\n+                    newHighlightedObjects.remove(oldObject);\n+                }\n+                if (newObject != null) {\n+                    newHighlightedObjects.add(newObject);\n+                }\n+                DiagramScene.this.setHighlightedObjects(newHighlightedObjects);\n+            }\n+\n+            @Override\n+            public void focusChanged(ObjectSceneEvent arg0, Object arg1, Object arg2) {\n+            }\n+        };\n@@ -643,1 +612,1 @@\n-            doClusteredLayout(figures, edges);\n+            doClusteredLayout(edges);\n@@ -657,1 +626,1 @@\n-    private void doClusteredLayout(HashSet<Figure> figures, HashSet<Connection> edges) {\n+    private void doClusteredLayout(HashSet<Connection> edges) {\n@@ -664,1 +633,1 @@\n-        m.doLayout(new LayoutGraph(edges, figures));\n+        m.doLayout(new LayoutGraph(edges));\n@@ -677,1 +646,1 @@\n-        Map<InputNode, Figure> nodeFig = new HashMap<InputNode, Figure>();\n+        Map<InputNode, Figure> nodeFig = new HashMap<>();\n@@ -687,2 +656,1 @@\n-        Map<Figure, Integer> figureRank =\n-            new HashMap<Figure, Integer>(figures.size());\n+        Map<Figure, Integer> figureRank = new HashMap<>(figures.size());\n@@ -737,2 +705,2 @@\n-            FigureWidget w1 = getWidget((Figure) c.getTo().getVertex());\n-            FigureWidget w2 = getWidget((Figure) c.getFrom().getVertex());\n+            FigureWidget w1 = getWidget(c.getTo().getVertex());\n+            FigureWidget w2 = getWidget(c.getFrom().getVertex());\n@@ -908,3 +876,1 @@\n-            if (p == specialNullPoint) {\n-            } else if (lastPoint == specialNullPoint) {\n-            } else if (lastPoint != null) {\n+            if (p != specialNullPoint && lastPoint != specialNullPoint && lastPoint != null) {\n@@ -953,0 +919,1 @@\n+                assert r != null;\n@@ -974,2 +941,1 @@\n-    private Set<Object> idSetToObjectSet(Set<Object> ids) {\n-\n+    private Set<Object> idSetToObjectSet(Set<Integer> ids) {\n@@ -991,1 +957,1 @@\n-    private void gotoSelection(Set<Object> ids) {\n+    private void gotoSelection(Set<Integer> ids) {\n@@ -1006,0 +972,1 @@\n+                assert r != null;\n@@ -1081,4 +1048,1 @@\n-        if (getModel().getHiddenNodes().contains(f.getInputNode().getId())) {\n-            return false;\n-        }\n-        return true;\n+        return !getModel().getHiddenNodes().contains(f.getInputNode().getId());\n@@ -1104,1 +1068,1 @@\n-        Set<InputBlock> visibleBlocks = new HashSet<InputBlock>();\n+        Set<InputBlock> visibleBlocks = new HashSet<>();\n@@ -1191,7 +1155,1 @@\n-                if (visibleAfter) {\n-                    \/\/ Block must be shown\n-                    w.setVisible(true);\n-                } else {\n-                    \/\/ Block must be hidden\n-                    w.setVisible(false);\n-                }\n+                w.setVisible(visibleAfter);\n@@ -1217,0 +1175,1 @@\n+        assert r != null;\n@@ -1228,1 +1187,1 @@\n-            setSelection(Arrays.asList(f));\n+            setSelection(Collections.singletonList(f));\n@@ -1251,4 +1210,4 @@\n-        private DiagramViewModel oldModel;\n-        private DiagramViewModel newModel;\n-        private Point oldScrollPosition;\n-        private DiagramScene scene;\n+        private final DiagramViewModel oldModel;\n+        private final DiagramViewModel newModel;\n+        private final Point oldScrollPosition;\n+        private final DiagramScene scene;\n@@ -1285,7 +1244,1 @@\n-            SwingUtilities.invokeLater(new Runnable() {\n-\n-                @Override\n-                public void run() {\n-                    scene.setScrollPosition(oldScrollPosition);\n-                }\n-            });\n+            SwingUtilities.invokeLater(() -> scene.setScrollPosition(oldScrollPosition));\n@@ -1299,5 +1252,1 @@\n-            if (oldModel.getHiddenNodes().equals(newModel.getHiddenNodes())) {\n-                scene.smallUpdate(false);\n-            } else {\n-                scene.smallUpdate(true);\n-            }\n+            scene.smallUpdate(!oldModel.getHiddenNodes().equals(newModel.getHiddenNodes()));\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/DiagramScene.java","additions":172,"deletions":223,"binary":false,"changes":395,"status":"modified"},{"patch":"@@ -57,5 +57,5 @@\n-    private ChangedEvent<DiagramViewModel> groupChangedEvent;\n-    private ChangedEvent<DiagramViewModel> diagramChangedEvent;\n-    private ChangedEvent<DiagramViewModel> viewChangedEvent;\n-    private ChangedEvent<DiagramViewModel> hiddenNodesChangedEvent;\n-    private ChangedEvent<DiagramViewModel> viewPropertiesChangedEvent;\n+    private final ChangedEvent<DiagramViewModel> groupChangedEvent;\n+    private final ChangedEvent<DiagramViewModel> diagramChangedEvent;\n+    private final ChangedEvent<DiagramViewModel> viewChangedEvent;\n+    private final ChangedEvent<DiagramViewModel> hiddenNodesChangedEvent;\n+    private final ChangedEvent<DiagramViewModel> viewPropertiesChangedEvent;\n@@ -67,7 +67,1 @@\n-    private ChangedListener<FilterChain> filterChainChangedListener = new ChangedListener<FilterChain>() {\n-\n-        @Override\n-        public void changed(FilterChain source) {\n-            updateDiagram();\n-        }\n-    };\n+    private final ChangedListener<FilterChain> filterChainChangedListener = source -> updateDiagram();\n@@ -88,3 +82,0 @@\n-        boolean diagramChanged = false;\n-        boolean viewChanged = false;\n-        boolean viewPropertiesChanged = false;\n@@ -98,1 +89,1 @@\n-        diagramChanged |= (filterChain != newModel.filterChain);\n+        boolean diagramChanged = (filterChain != newModel.filterChain);\n@@ -104,1 +95,1 @@\n-        viewChanged |= (hiddenNodes != newModel.hiddenNodes);\n+        boolean viewChanged = (hiddenNodes != newModel.hiddenNodes);\n@@ -108,1 +99,1 @@\n-        viewPropertiesChanged |= (showSea != newModel.showSea);\n+        boolean viewPropertiesChanged = (showSea != newModel.showSea);\n@@ -178,1 +169,1 @@\n-        super(Arrays.asList(\"default\"));\n+        super(Collections.singletonList(\"default\"));\n@@ -200,0 +191,13 @@\n+        ChangedListener<DiagramViewModel> groupChangedListener = new ChangedListener<DiagramViewModel>() {\n+\n+            private Group oldGroup;\n+\n+            @Override\n+            public void changed(DiagramViewModel source) {\n+                if (oldGroup != null) {\n+                    oldGroup.getChangedEvent().removeListener(groupContentChangedListener);\n+                }\n+                group.getChangedEvent().addListener(groupContentChangedListener);\n+                oldGroup = group;\n+            }\n+        };\n@@ -208,1 +212,0 @@\n-    private final ChangedListener<DiagramViewModel> groupChangedListener = new ChangedListener<DiagramViewModel>() {\n@@ -210,11 +213,0 @@\n-        private Group oldGroup;\n-\n-        @Override\n-        public void changed(DiagramViewModel source) {\n-            if (oldGroup != null) {\n-                oldGroup.getChangedEvent().removeListener(groupContentChangedListener);\n-            }\n-            group.getChangedEvent().addListener(groupContentChangedListener);\n-            oldGroup = group;\n-        }\n-    };\n@@ -263,1 +255,1 @@\n-        for (String s : getPositions()) {\n+        for (String ignored : getPositions()) {\n@@ -432,1 +424,2 @@\n-        return new Iterable<InputGraph>() {\n+        return () -> new Iterator<InputGraph>() {\n+            int index = getFirstPosition();\n@@ -435,8 +428,3 @@\n-            public Iterator<InputGraph> iterator() {\n-                return new Iterator<InputGraph>() {\n-                    int index = getFirstPosition();\n-\n-                    @Override\n-                    public boolean hasNext() {\n-                        return index + 1 < graphs.size();\n-                    }\n+            public boolean hasNext() {\n+                return index + 1 < graphs.size();\n+            }\n@@ -444,5 +432,3 @@\n-                    @Override\n-                    public InputGraph next() {\n-                        return graphs.get(++index);\n-                    }\n-                };\n+            @Override\n+            public InputGraph next() {\n+                return graphs.get(++index);\n@@ -454,5 +440,2 @@\n-        return new Iterable<InputGraph>() {\n-            @Override\n-            public Iterator<InputGraph> iterator() {\n-                return new Iterator<InputGraph>() {\n-                    int index = getFirstPosition();\n+        return () -> new Iterator<InputGraph>() {\n+            int index = getFirstPosition();\n@@ -460,4 +443,4 @@\n-                    @Override\n-                    public boolean hasNext() {\n-                        return index - 1 > 0;\n-                    }\n+            @Override\n+            public boolean hasNext() {\n+                return index - 1 > 0;\n+            }\n@@ -465,5 +448,3 @@\n-                    @Override\n-                    public InputGraph next() {\n-                        return graphs.get(--index);\n-                    }\n-                };\n+            @Override\n+            public InputGraph next() {\n+                return graphs.get(--index);\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/DiagramViewModel.java","additions":41,"deletions":60,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-    public void paint(Graphics2D generator);\n+    void paint(Graphics2D generator);\n@@ -52,1 +52,1 @@\n-    public Lookup getLookup();\n+    Lookup getLookup();\n@@ -54,1 +54,1 @@\n-    public JComponent createSatelliteView();\n+    JComponent createSatelliteView();\n@@ -56,1 +56,1 @@\n-    public Component getComponent();\n+    Component getComponent();\n@@ -58,1 +58,1 @@\n-    public void zoomOut();\n+    void zoomOut();\n@@ -60,1 +60,1 @@\n-    public void zoomIn();\n+    void zoomIn();\n@@ -62,1 +62,1 @@\n-    public UndoRedo getUndoRedo();\n+    UndoRedo getUndoRedo();\n@@ -64,1 +64,1 @@\n-    public void componentHidden();\n+    void componentHidden();\n@@ -66,1 +66,1 @@\n-    public void componentShowing();\n+    void componentShowing();\n@@ -68,1 +68,1 @@\n-    public void setSelection(Collection<Figure> list);\n+    void setSelection(Collection<Figure> list);\n@@ -70,1 +70,1 @@\n-    public void centerFigures(List<Figure> list);\n+    void centerFigures(List<Figure> list);\n@@ -72,1 +72,1 @@\n-    public void setInteractionMode(InteractionMode mode);\n+    void setInteractionMode(InteractionMode mode);\n@@ -74,1 +74,1 @@\n-    public Rectangle getBounds();\n+    Rectangle getBounds();\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/DiagramViewer.java","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+import java.nio.file.Files;\n@@ -80,15 +81,14 @@\n-    private DiagramViewer scene;\n-    private InstanceContent graphContent;\n-    private EnableSeaLayoutAction seaLayoutAction;\n-    private EnableBlockLayoutAction blockLayoutAction;\n-    private EnableCFGLayoutAction cfgLayoutAction;\n-    private OverviewAction overviewAction;\n-    private PredSuccAction predSuccAction;\n-    private ShowEmptyBlocksAction showEmptyBlocksAction;\n-    private SelectionModeAction selectionModeAction;\n-    private JComponent satelliteComponent;\n-    private JPanel centerPanel;\n-    private CardLayout cardLayout;\n-    private JToggleButton overviewButton;\n-    private JPanel topPanel;\n-    private Toolbar quickSearchToolbar;\n+    private final DiagramViewer scene;\n+    private final InstanceContent graphContent;\n+    private final EnableSeaLayoutAction seaLayoutAction;\n+    private final EnableBlockLayoutAction blockLayoutAction;\n+    private final EnableCFGLayoutAction cfgLayoutAction;\n+    private final OverviewAction overviewAction;\n+    private final PredSuccAction predSuccAction;\n+    private final ShowEmptyBlocksAction showEmptyBlocksAction;\n+    private final SelectionModeAction selectionModeAction;\n+    private final JComponent satelliteComponent;\n+    private final JPanel centerPanel;\n+    private final CardLayout cardLayout;\n+    private final JToggleButton overviewButton;\n+    private final Toolbar quickSearchToolbar;\n@@ -124,2 +124,2 @@\n-        FilterChain filterChain = null;\n-        FilterChain sequence = null;\n+        FilterChain filterChain;\n+        FilterChain sequence;\n@@ -175,0 +175,11 @@\n+        ChangedListener<DiagramViewModel> diagramChangedListener = new ChangedListener<DiagramViewModel>() {\n+\n+            @Override\n+            public void changed(DiagramViewModel source) {\n+                updateDisplayName();\n+                Collection<Object> list = new ArrayList<>();\n+                list.add(new EditorInputGraphProvider(EditorTopComponent.this));\n+                graphContent.set(list, null);\n+            }\n+\n+        };\n@@ -188,1 +199,1 @@\n-        this.associateLookup(new ProxyLookup(new Lookup[]{scene.getLookup(), new AbstractLookup(graphContent), new AbstractLookup(content)}));\n+        this.associateLookup(new ProxyLookup(scene.getLookup(), new AbstractLookup(graphContent), new AbstractLookup(content)));\n@@ -281,1 +292,1 @@\n-        topPanel = new JPanel();\n+        JPanel topPanel = new JPanel();\n@@ -396,12 +407,0 @@\n-    private ChangedListener<DiagramViewModel> diagramChangedListener = new ChangedListener<DiagramViewModel>() {\n-\n-        @Override\n-        public void changed(DiagramViewModel source) {\n-            updateDisplayName();\n-            Collection<Object> list = new ArrayList<>();\n-            list.add(new EditorInputGraphProvider(EditorTopComponent.this));\n-            graphContent.set(list, null);\n-        }\n-\n-    };\n-\n@@ -566,1 +565,1 @@\n-            writer = PdfWriter.getInstance(document, new FileOutputStream(f));\n+            writer = PdfWriter.getInstance(document, Files.newOutputStream(f.toPath()));\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/EditorTopComponent.java","additions":31,"deletions":32,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -1,58 +0,0 @@\n-\/*\n- * Copyright (c) 2008, 2015, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-package com.sun.hotspot.igv.view.actions;\n-\n-import org.netbeans.api.visual.action.HoverProvider;\n-import org.netbeans.api.visual.action.WidgetAction;\n-import org.netbeans.api.visual.widget.Widget;\n-\n-\/**\n- *\n- * @author Thomas Wuerthinger\n- *\/\n-public class MouseOverAction extends WidgetAction.Adapter {\n-\n-    private long eventID = Integer.MIN_VALUE;\n-    private HoverProvider provider;\n-\n-    public MouseOverAction(HoverProvider provider) {\n-        this.provider = provider;\n-    }\n-\n-    @Override\n-    public State mouseMoved(Widget widget, WidgetMouseEvent event) {\n-        long id = event.getEventID();\n-        if (id != eventID) {\n-            eventID = id;\n-            provider.widgetHovered(widget);\n-        }\n-        return State.REJECTED;\n-    }\n-\n-    @Override\n-    public State mouseExited(Widget widget, WidgetMouseEvent event) {\n-        provider.widgetHovered(null);\n-        return State.REJECTED;\n-    }\n-}\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/actions\/MouseOverAction.java","additions":0,"deletions":58,"binary":false,"changes":58,"status":"deleted"}]}