{"files":[{"patch":"@@ -31,1 +31,0 @@\n-import java.io.Serializable;\n@@ -138,5 +137,0 @@\n-    @Override\n-    public Object writeReplace() {\n-        return new ResolvableHelper();\n-    }\n-\n@@ -173,1 +167,1 @@\n-        final InputGraphProvider p = LookupHistory.getLast(InputGraphProvider.class);\/\/)Utilities.actionsGlobalContext().lookup(InputGraphProvider.class);\n+        final InputGraphProvider p = LookupHistory.getLast(InputGraphProvider.class);\n@@ -190,9 +184,0 @@\n-\n-    static final class ResolvableHelper implements Serializable {\n-\n-        private static final long serialVersionUID = 1L;\n-\n-        public Object readResolve() {\n-            return BytecodeViewTopComponent.getDefault();\n-        }\n-    }\n","filename":"src\/utils\/IdealGraphVisualizer\/Bytecodes\/src\/main\/java\/com\/sun\/hotspot\/igv\/bytecodes\/BytecodeViewTopComponent.java","additions":1,"deletions":16,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-        InputGraphProvider p = LookupHistory.getLast(InputGraphProvider.class);\/\/Utilities.actionsGlobalContext().lookup(InputGraphProvider.class);\n+        InputGraphProvider p = LookupHistory.getLast(InputGraphProvider.class);\n","filename":"src\/utils\/IdealGraphVisualizer\/Bytecodes\/src\/main\/java\/com\/sun\/hotspot\/igv\/bytecodes\/SelectBytecodesAction.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -16,0 +16,1 @@\n+                <attr name=\"position\" intvalue=\"1\"\/>\n","filename":"src\/utils\/IdealGraphVisualizer\/Bytecodes\/src\/main\/resources\/com\/sun\/hotspot\/igv\/bytecodes\/layer.xml","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import com.sun.hotspot.igv.layout.Cluster;\n@@ -29,1 +30,0 @@\n-import com.sun.hotspot.igv.layout.Cluster;\n","filename":"src\/utils\/IdealGraphVisualizer\/ControlFlow\/src\/main\/java\/com\/sun\/hotspot\/igv\/controlflow\/BlockConnectionWidget.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,5 +30,1 @@\n-import java.awt.Color;\n-import java.awt.Dimension;\n-import java.awt.Font;\n-import java.awt.Point;\n-import java.awt.Rectangle;\n+import java.awt.*;\n","filename":"src\/utils\/IdealGraphVisualizer\/ControlFlow\/src\/main\/java\/com\/sun\/hotspot\/igv\/controlflow\/BlockWidget.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-import com.sun.hotspot.igv.data.InputBlockEdge;\n@@ -28,0 +27,1 @@\n+import com.sun.hotspot.igv.data.InputBlockEdge;\n@@ -29,1 +29,0 @@\n-import com.sun.hotspot.igv.data.services.InputGraphProvider;\n@@ -31,0 +30,1 @@\n+import com.sun.hotspot.igv.data.services.InputGraphProvider;\n@@ -39,6 +39,1 @@\n-import org.netbeans.api.visual.action.ActionFactory;\n-import org.netbeans.api.visual.action.MoveProvider;\n-import org.netbeans.api.visual.action.RectangularSelectDecorator;\n-import org.netbeans.api.visual.action.RectangularSelectProvider;\n-import org.netbeans.api.visual.action.SelectProvider;\n-import org.netbeans.api.visual.action.WidgetAction;\n+import org.netbeans.api.visual.action.*;\n@@ -47,3 +42,0 @@\n-import org.netbeans.api.visual.router.RouterFactory;\n-import org.netbeans.api.visual.widget.LayerWidget;\n-import org.netbeans.api.visual.widget.Widget;\n@@ -54,0 +46,1 @@\n+import org.netbeans.api.visual.router.RouterFactory;\n@@ -55,0 +48,2 @@\n+import org.netbeans.api.visual.widget.LayerWidget;\n+import org.netbeans.api.visual.widget.Widget;\n@@ -136,1 +131,1 @@\n-        InputGraphProvider p = LookupHistory.getLast(InputGraphProvider.class);\/\/)Utilities.actionsGlobalContext().lookup(InputGraphProvider.class);\n+        InputGraphProvider p = LookupHistory.getLast(InputGraphProvider.class);\n","filename":"src\/utils\/IdealGraphVisualizer\/ControlFlow\/src\/main\/java\/com\/sun\/hotspot\/igv\/controlflow\/ControlFlowScene.java","additions":7,"deletions":12,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import java.io.Serializable;\n@@ -34,5 +33,1 @@\n-import org.openide.util.Lookup;\n-import org.openide.util.LookupEvent;\n-import org.openide.util.LookupListener;\n-import org.openide.util.NbBundle;\n-import org.openide.util.Utilities;\n+import org.openide.util.*;\n@@ -138,1 +133,1 @@\n-        final InputGraphProvider p = LookupHistory.getLast(InputGraphProvider.class);\/\/Utilities.actionsGlobalContext().lookup(InputGraphProvider.class);\n+        final InputGraphProvider p = LookupHistory.getLast(InputGraphProvider.class);\n@@ -152,5 +147,0 @@\n-    @Override\n-    public Object writeReplace() {\n-        return new ResolvableHelper();\n-    }\n-\n@@ -167,9 +157,0 @@\n-\n-    static final class ResolvableHelper implements Serializable {\n-\n-        private static final long serialVersionUID = 1L;\n-\n-        public Object readResolve() {\n-            return ControlFlowTopComponent.getDefault();\n-        }\n-    }\n","filename":"src\/utils\/IdealGraphVisualizer\/ControlFlow\/src\/main\/java\/com\/sun\/hotspot\/igv\/controlflow\/ControlFlowTopComponent.java","additions":2,"deletions":21,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -27,5 +27,1 @@\n-import com.sun.hotspot.igv.layout.Cluster;\n-import com.sun.hotspot.igv.layout.LayoutGraph;\n-import com.sun.hotspot.igv.layout.Link;\n-import com.sun.hotspot.igv.layout.Port;\n-import com.sun.hotspot.igv.layout.Vertex;\n+import com.sun.hotspot.igv.layout.*;\n@@ -34,7 +30,1 @@\n-import java.util.ArrayList;\n-import java.util.Collection;\n-import java.util.HashMap;\n-import java.util.LinkedHashSet;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n+import java.util.*;\n","filename":"src\/utils\/IdealGraphVisualizer\/ControlFlow\/src\/main\/java\/com\/sun\/hotspot\/igv\/controlflow\/HierarchicalGraphLayout.java","additions":2,"deletions":12,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -13,0 +13,1 @@\n+                <attr name=\"position\" intvalue=\"2\"\/>\n","filename":"src\/utils\/IdealGraphVisualizer\/ControlFlow\/src\/main\/resources\/com\/sun\/hotspot\/igv\/controlflow\/layer.xml","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import java.util.List;\n@@ -32,0 +31,1 @@\n+import java.util.List;\n","filename":"src\/utils\/IdealGraphVisualizer\/Coordinator\/src\/main\/java\/com\/sun\/hotspot\/igv\/coordinator\/FolderNode.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,6 +26,1 @@\n-import com.sun.hotspot.igv.coordinator.actions.CloneGraphAction;\n-import com.sun.hotspot.igv.coordinator.actions.DiffGraphAction;\n-import com.sun.hotspot.igv.coordinator.actions.DiffGraphCookie;\n-import com.sun.hotspot.igv.coordinator.actions.GraphCloneCookie;\n-import com.sun.hotspot.igv.coordinator.actions.GraphOpenCookie;\n-import com.sun.hotspot.igv.coordinator.actions.GraphRemoveCookie;\n+import com.sun.hotspot.igv.coordinator.actions.*;\n@@ -39,6 +34,1 @@\n-import org.openide.nodes.AbstractNode;\n-import org.openide.nodes.Children;\n-import org.openide.nodes.NodeAdapter;\n-import org.openide.nodes.NodeEvent;\n-import org.openide.nodes.NodeMemberEvent;\n-import org.openide.nodes.Sheet;\n+import org.openide.nodes.*;\n","filename":"src\/utils\/IdealGraphVisualizer\/Coordinator\/src\/main\/java\/com\/sun\/hotspot\/igv\/coordinator\/GraphNode.java","additions":2,"deletions":12,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -40,1 +40,0 @@\n-import java.io.Serializable;\n@@ -69,1 +68,0 @@\n-    private Server binaryServer;\n@@ -73,1 +71,0 @@\n-\n@@ -137,1 +134,0 @@\n-                    getDocument().addElement(g);\n@@ -139,0 +135,1 @@\n+                    getDocument().addElement(g);\n@@ -143,2 +140,1 @@\n-        server = new Server(getDocument(), callback, false);\n-        binaryServer = new Server(getDocument(), callback, true);\n+        server = new Server(callback);\n@@ -278,9 +274,0 @@\n-    static final class ResolvableHelper implements Serializable {\n-\n-        private static final long serialVersionUID = 1L;\n-\n-        public Object readResolve() {\n-            return OutlineTopComponent.getDefault();\n-        }\n-    }\n-\n","filename":"src\/utils\/IdealGraphVisualizer\/Coordinator\/src\/main\/java\/com\/sun\/hotspot\/igv\/coordinator\/OutlineTopComponent.java","additions":2,"deletions":15,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import com.sun.hotspot.igv.data.serialization.BinaryParser;\n@@ -34,1 +33,0 @@\n-import java.awt.event.ActionEvent;\n@@ -42,0 +40,1 @@\n+import javax.swing.Action;\n@@ -45,1 +44,0 @@\n-import javax.swing.Action;\n@@ -48,4 +46,1 @@\n-import org.openide.util.Exceptions;\n-import org.openide.util.RequestProcessor;\n-import org.openide.util.HelpCtx;\n-import org.openide.util.NbBundle;\n+import org.openide.util.*;\n@@ -53,1 +48,0 @@\n-import org.openide.util.Utilities;\n@@ -68,1 +62,1 @@\n-                return f.getName().toLowerCase().endsWith(\".xml\") || f.getName().toLowerCase().endsWith(\".bgv\") || f.isDirectory();\n+                return f.getName().toLowerCase().endsWith(\".xml\") || f.isDirectory();\n@@ -73,1 +67,1 @@\n-                return \"Graph files (*.xml, *.bgv)\";\n+                return \"Graph files (*.xml)\";\n@@ -118,2 +112,0 @@\n-                    } else if (file.getName().endsWith(\".bgv\")) {\n-                        parser = new BinaryParser(channel, monitor, component.getDocument(), null);\n","filename":"src\/utils\/IdealGraphVisualizer\/Coordinator\/src\/main\/java\/com\/sun\/hotspot\/igv\/coordinator\/actions\/ImportAction.java","additions":4,"deletions":12,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-import java.awt.event.InputEvent;\n-import java.awt.event.KeyEvent;\n@@ -31,1 +29,0 @@\n-import javax.swing.KeyStroke;\n","filename":"src\/utils\/IdealGraphVisualizer\/Coordinator\/src\/main\/java\/com\/sun\/hotspot\/igv\/coordinator\/actions\/RemoveAllAction.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-import java.awt.event.InputEvent;\n-import java.awt.event.KeyEvent;\n@@ -31,1 +29,0 @@\n-import javax.swing.KeyStroke;\n@@ -34,2 +31,0 @@\n-import org.openide.util.NbBundle.Messages;\n-import org.openide.util.actions.CallableSystemAction;\n@@ -37,0 +32,1 @@\n+import org.openide.util.actions.CallableSystemAction;\n","filename":"src\/utils\/IdealGraphVisualizer\/Coordinator\/src\/main\/java\/com\/sun\/hotspot\/igv\/coordinator\/actions\/SaveAllAction.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-    \n+\n@@ -49,0 +49,1 @@\n+            <attr name=\"position\" intvalue=\"50\"\/>\n@@ -99,1 +100,1 @@\n-        \n+\n@@ -101,0 +102,1 @@\n+            <attr name=\"position\" intvalue=\"100\"\/>\n@@ -133,1 +135,1 @@\n-        \n+\n@@ -135,0 +137,1 @@\n+            <attr name=\"position\" intvalue=\"150\"\/>\n@@ -151,1 +154,1 @@\n-        \n+\n@@ -162,0 +165,1 @@\n+            <attr name=\"position\" intvalue=\"200\"\/>\n@@ -164,0 +168,1 @@\n+                <attr name=\"position\" intvalue=\"1\"\/>\n@@ -168,0 +173,1 @@\n+            <attr name=\"position\" intvalue=\"250\"\/>\n@@ -170,0 +176,1 @@\n+                <attr name=\"position\" intvalue=\"4\"\/>\n@@ -191,0 +198,1 @@\n+            <attr name=\"position\" intvalue=\"300\"\/>\n@@ -217,1 +225,1 @@\n-    \n+\n@@ -222,1 +230,1 @@\n-        <folder name=\"Modes\">  \n+        <folder name=\"Modes\">\n","filename":"src\/utils\/IdealGraphVisualizer\/Coordinator\/src\/main\/resources\/com\/sun\/hotspot\/igv\/coordinator\/layer.xml","additions":14,"deletions":6,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -61,1 +61,0 @@\n-        getChangedEvent().fire();\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/main\/java\/com\/sun\/hotspot\/igv\/data\/GraphDocument.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-    private final List<FolderElement> elements;\n@@ -36,1 +35,0 @@\n-\n@@ -42,1 +40,0 @@\n-        elements = new ArrayList<>();\n@@ -47,1 +44,1 @@\n-        \/\/ Ensure that name and type are never null\n+        \/\/ Ensure that name is never null\n@@ -49,5 +46,0 @@\n-        getProperties().setProperty(\"type\", \"\");\n-    }\n-\n-    public void fireChangedEvent() {\n-        changedEvent.fire();\n@@ -70,2 +62,5 @@\n-    public List<FolderElement> getElements() {\n-        return Collections.unmodifiableList(elements);\n+    public void addElement(FolderElement element) {\n+        assert element instanceof InputGraph;\n+        graphs.add((InputGraph) element);\n+        element.setParent(this);\n+        getChangedEvent().fire();\n@@ -74,2 +69,6 @@\n-    public int getGraphsCount() {\n-        return elements.size();\n+    @Override\n+    public void removeElement(FolderElement element) {\n+        assert element instanceof InputGraph;\n+        if (graphs.remove((InputGraph) element)) {\n+            getChangedEvent().fire();\n+        }\n@@ -79,5 +78,3 @@\n-    public void addElement(FolderElement element) {\n-        elements.add(element);\n-        if (element instanceof InputGraph) {\n-            graphs.add((InputGraph) element);\n-        } else {\n+    public List<FolderElement> getElements() {\n+        return Collections.unmodifiableList(graphs);\n+    }\n@@ -85,3 +82,2 @@\n-        }\n-        element.setParent(this);\n-        changedEvent.fire();\n+    public List<InputGraph> getGraphs() {\n+        return Collections.unmodifiableList(graphs);\n@@ -92,5 +88,2 @@\n-        for (FolderElement e : elements) {\n-            if (e instanceof InputGraph) {\n-                InputGraph g = (InputGraph) e;\n-                result.addAll(g.getNodesAsSet());\n-            }\n+        for (InputGraph g : graphs) {\n+            result.addAll(g.getNodesAsSet());\n@@ -101,11 +94,0 @@\n-    @Override\n-    public String toString() {\n-        StringBuilder sb = new StringBuilder();\n-        sb.append(\"Group \").append(getProperties()).append(\"\\n\");\n-        for (FolderElement g : elements) {\n-            sb.append(g.toString());\n-            sb.append('\\n');\n-        }\n-        return sb.toString();\n-    }\n-\n@@ -117,40 +99,0 @@\n-    public String getType() {\n-        return getProperties().get(\"type\");\n-\n-    }\n-\n-    InputGraph getPrev(InputGraph graph) {\n-        InputGraph lastGraph = null;\n-        for (FolderElement e : elements) {\n-            if (e == graph) {\n-                return lastGraph;\n-            }\n-            if (e instanceof InputGraph) {\n-                lastGraph = (InputGraph) e;\n-            }\n-        }\n-        return null;\n-    }\n-\n-    InputGraph getNext(InputGraph graph) {\n-        boolean found = false;\n-        for (FolderElement e : elements) {\n-            if (e == graph) {\n-                found = true;\n-            } else if (found && e instanceof InputGraph) {\n-                return (InputGraph) e;\n-            }\n-        }\n-        return null;\n-    }\n-\n-    public InputGraph getLastGraph() {\n-        InputGraph lastGraph = null;\n-        for (FolderElement e : elements) {\n-            if (e instanceof InputGraph) {\n-                lastGraph = (InputGraph) e;\n-            }\n-        }\n-        return lastGraph;\n-    }\n-\n@@ -161,15 +103,0 @@\n-\n-    @Override\n-    public void removeElement(FolderElement element) {\n-        if (elements.remove(element)) {\n-            if (element instanceof InputGraph) {\n-                graphs.remove((InputGraph) element);\n-            }\n-            changedEvent.fire();\n-        }\n-    }\n-\n-    public List<InputGraph> getGraphs() {\n-        return graphs;\n-    }\n-\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/main\/java\/com\/sun\/hotspot\/igv\/data\/Group.java","additions":19,"deletions":92,"binary":false,"changes":111,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+import java.lang.ref.WeakReference;\n@@ -28,1 +29,0 @@\n-import java.lang.ref.WeakReference;\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/main\/java\/com\/sun\/hotspot\/igv\/data\/InputEdge.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -82,74 +82,0 @@\n-    public List<InputNode> findRootNodes() {\n-        List<InputNode> result = new ArrayList<>();\n-        Set<Integer> nonRoot = new HashSet<>();\n-        for(InputEdge curEdges : getEdges()) {\n-            nonRoot.add(curEdges.getTo());\n-        }\n-\n-        for(InputNode node : getNodes()) {\n-            if(!nonRoot.contains(node.getId())) {\n-                result.add(node);\n-            }\n-        }\n-\n-        return result;\n-    }\n-\n-    public Map<InputNode, List<InputEdge>> findAllOutgoingEdges() {\n-        Map<InputNode, List<InputEdge>> result = new HashMap<>(getNodes().size());\n-        for(InputNode n : this.getNodes()) {\n-            result.put(n, new ArrayList<InputEdge>());\n-        }\n-\n-        for(InputEdge e : this.edges) {\n-            int from = e.getFrom();\n-            InputNode fromNode = this.getNode(from);\n-            List<InputEdge> fromList = result.get(fromNode);\n-            assert fromList != null;\n-            fromList.add(e);\n-        }\n-\n-        for(InputNode n : this.getNodes()) {\n-            List<InputEdge> list = result.get(n);\n-            list.sort(InputEdge.OUTGOING_COMPARATOR);\n-        }\n-\n-        return result;\n-    }\n-\n-    public Map<InputNode, List<InputEdge>> findAllIngoingEdges() {\n-        Map<InputNode, List<InputEdge>> result = new HashMap<>(getNodes().size());\n-        for(InputNode n : this.getNodes()) {\n-            result.put(n, new ArrayList<InputEdge>());\n-        }\n-\n-        for(InputEdge e : this.edges) {\n-            int to = e.getTo();\n-            InputNode toNode = this.getNode(to);\n-            List<InputEdge> toList = result.get(toNode);\n-            assert toList != null;\n-            toList.add(e);\n-        }\n-\n-        for(InputNode n : this.getNodes()) {\n-            List<InputEdge> list = result.get(n);\n-            list.sort(InputEdge.INGOING_COMPARATOR);\n-        }\n-\n-        return result;\n-    }\n-\n-    public List<InputEdge> findOutgoingEdges(InputNode n) {\n-        List<InputEdge> result = new ArrayList<>();\n-\n-        for(InputEdge e : this.edges) {\n-            if(e.getFrom() == n.getId()) {\n-                result.add(e);\n-            }\n-        }\n-\n-        result.sort(InputEdge.OUTGOING_COMPARATOR);\n-\n-        return result;\n-    }\n-\n@@ -162,10 +88,0 @@\n-    public void setEdge(int fromIndex, int toIndex, int from, int to) {\n-        assert fromIndex == ((char)fromIndex) : \"Downcast must be safe\";\n-        assert toIndex == ((char)toIndex) : \"Downcast must be safe\";\n-\n-        InputEdge edge = new InputEdge((char)fromIndex, (char)toIndex, from, to);\n-        if(!this.getEdges().contains(edge)) {\n-            this.addEdge(edge);\n-        }\n-    }\n-\n@@ -209,8 +125,0 @@\n-    public InputGraph getNext() {\n-        return parentGroup.getNext(this);\n-    }\n-\n-    public InputGraph getPrev() {\n-        return parentGroup.getPrev(this);\n-    }\n-\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/main\/java\/com\/sun\/hotspot\/igv\/data\/InputGraph.java","additions":0,"deletions":92,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -26,4 +26,0 @@\n-import java.util.ArrayList;\n-import java.util.Comparator;\n-import java.util.List;\n-\n@@ -37,31 +33,0 @@\n-    private List<InputGraph> subgraphs;\n-\n-    public static final Comparator<InputNode> COMPARATOR = new Comparator<InputNode>() {\n-        @Override\n-        public int compare(InputNode o1, InputNode o2) {\n-            return o1.getId() - o2.getId();\n-        }\n-    };\n-\n-    public static Comparator<InputNode> getPropertyComparator(final String propertyName) {\n-        return new Comparator<InputNode>() {\n-\n-            @Override\n-            public int compare(InputNode o1, InputNode o2) {\n-\n-                int i1 = 0;\n-                try {\n-                    i1 = Integer.parseInt(o1.getProperties().get(propertyName));\n-                } catch(NumberFormatException e) {\n-                }\n-\n-                int i2 = 0;\n-                try {\n-                    i2 = Integer.parseInt(o2.getProperties().get(propertyName));\n-                } catch(NumberFormatException e) {\n-                }\n-\n-                return i1 - i2;\n-            }\n-        };\n-    }\n@@ -86,11 +51,0 @@\n-    public void addSubgraph(InputGraph graph) {\n-        if (subgraphs == null) {\n-            subgraphs = new ArrayList<>();\n-        }\n-        subgraphs.add(graph);\n-    }\n-\n-    public List<InputGraph> getSubgraphs() {\n-        return subgraphs;\n-    }\n-\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/main\/java\/com\/sun\/hotspot\/igv\/data\/InputNode.java","additions":0,"deletions":46,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import java.util.Map.Entry;\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/main\/java\/com\/sun\/hotspot\/igv\/data\/Properties.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1,937 +0,0 @@\n-\/*\n- * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package com.sun.hotspot.igv.data.serialization;\n-\n-import com.sun.hotspot.igv.data.*;\n-import com.sun.hotspot.igv.data.Properties;\n-import com.sun.hotspot.igv.data.services.GroupCallback;\n-import java.io.EOFException;\n-import java.io.IOException;\n-import java.nio.ByteBuffer;\n-import java.nio.channels.ReadableByteChannel;\n-import java.util.*;\n-import java.util.regex.Matcher;\n-import java.util.regex.Pattern;\n-import javax.swing.SwingUtilities;\n-import java.security.MessageDigest;\n-import java.security.NoSuchAlgorithmException;\n-\n-import static java.nio.charset.StandardCharsets.UTF_8;\n-\n-public class BinaryParser implements GraphParser {\n-    private static final int BEGIN_GROUP = 0x00;\n-    private static final int BEGIN_GRAPH = 0x01;\n-    private static final int CLOSE_GROUP = 0x02;\n-\n-    private static final int POOL_NEW = 0x00;\n-    private static final int POOL_STRING = 0x01;\n-    private static final int POOL_ENUM = 0x02;\n-    private static final int POOL_CLASS = 0x03;\n-    private static final int POOL_METHOD = 0x04;\n-    private static final int POOL_NULL = 0x05;\n-    private static final int POOL_NODE_CLASS = 0x06;\n-    private static final int POOL_FIELD = 0x07;\n-    private static final int POOL_SIGNATURE = 0x08;\n-\n-    private static final int KLASS = 0x00;\n-    private static final int ENUM_KLASS = 0x01;\n-\n-    private static final int PROPERTY_POOL = 0x00;\n-    private static final int PROPERTY_INT = 0x01;\n-    private static final int PROPERTY_LONG = 0x02;\n-    private static final int PROPERTY_DOUBLE = 0x03;\n-    private static final int PROPERTY_FLOAT = 0x04;\n-    private static final int PROPERTY_TRUE = 0x05;\n-    private static final int PROPERTY_FALSE = 0x06;\n-    private static final int PROPERTY_ARRAY = 0x07;\n-    private static final int PROPERTY_SUBGRAPH = 0x08;\n-\n-    private static final String NO_BLOCK = \"noBlock\";\n-\n-    private final GroupCallback callback;\n-    private final List<Object> constantPool;\n-    private final ByteBuffer buffer;\n-    private final ReadableByteChannel channel;\n-    private final GraphDocument rootDocument;\n-    private final Deque<Folder> folderStack;\n-    private final Deque<byte[]> hashStack;\n-    private final ParseMonitor monitor;\n-\n-    private MessageDigest digest;\n-\n-    private enum Length {\n-        S,\n-        M,\n-        L\n-    }\n-\n-    private interface LengthToString {\n-        String toString(Length l);\n-    }\n-\n-    private abstract static class Member implements LengthToString {\n-        public final Klass holder;\n-        public final int accessFlags;\n-        public final String name;\n-        public Member(Klass holder, String name, int accessFlags) {\n-            this.holder = holder;\n-            this.accessFlags = accessFlags;\n-            this.name = name;\n-        }\n-    }\n-\n-    private static class Method extends Member {\n-        public final Signature signature;\n-        public final byte[] code;\n-        public Method(String name, Signature signature, byte[] code, Klass holder, int accessFlags) {\n-            super(holder, name, accessFlags);\n-            this.signature = signature;\n-            this.code = code;\n-        }\n-        @Override\n-        public String toString() {\n-            StringBuilder sb = new StringBuilder();\n-            sb.append(holder).append('.').append(name).append('(');\n-            for (int i = 0; i < signature.argTypes.length; i++) {\n-                if (i > 0) {\n-                    sb.append(\", \");\n-                }\n-                sb.append(signature.argTypes[i]);\n-            }\n-            sb.append(')');\n-            return sb.toString();\n-        }\n-        @Override\n-        public String toString(Length l) {\n-            switch(l) {\n-                case M:\n-                    return holder.toString(Length.L) + \".\" + name;\n-                case S:\n-                    return holder.toString(Length.S) + \".\" + name;\n-                default:\n-                case L:\n-                    return toString();\n-            }\n-        }\n-    }\n-\n-    private static class Signature {\n-        public final String returnType;\n-        public final String[] argTypes;\n-        public Signature(String returnType, String[] argTypes) {\n-            this.returnType = returnType;\n-            this.argTypes = argTypes;\n-        }\n-    }\n-\n-    private static class Field extends Member {\n-        public final String type;\n-        public Field(String type, Klass holder, String name, int accessFlags) {\n-            super(holder, name, accessFlags);\n-            this.type = type;\n-        }\n-        @Override\n-        public String toString() {\n-            return holder + \".\" + name;\n-        }\n-        @Override\n-        public String toString(Length l) {\n-            switch(l) {\n-                case M:\n-                    return holder.toString(Length.L) + \".\" + name;\n-                case S:\n-                    return holder.toString(Length.S) + \".\" + name;\n-                default:\n-                case L:\n-                    return toString();\n-            }\n-        }\n-    }\n-\n-    private static class Klass implements LengthToString {\n-        public final String name;\n-        public final String simpleName;\n-        public Klass(String name) {\n-            this.name = name;\n-            String simple;\n-            try {\n-                simple = name.substring(name.lastIndexOf('.') + 1);\n-            } catch (IndexOutOfBoundsException ioobe) {\n-                simple = name;\n-            }\n-            this.simpleName = simple;\n-        }\n-        @Override\n-        public String toString() {\n-            return name;\n-        }\n-        @Override\n-        public String toString(Length l) {\n-            switch(l) {\n-                case S:\n-                    return simpleName;\n-                default:\n-                case L:\n-                case M:\n-                    return toString();\n-            }\n-        }\n-    }\n-\n-    private static class EnumKlass extends Klass {\n-        public final String[] values;\n-        public EnumKlass(String name, String[] values) {\n-            super(name);\n-            this.values = values;\n-        }\n-    }\n-\n-    private static class Port {\n-        public final boolean isList;\n-        public final String name;\n-        private Port(boolean isList, String name) {\n-            this.isList = isList;\n-            this.name = name;\n-        }\n-    }\n-\n-    private static class TypedPort extends Port {\n-        public final EnumValue type;\n-        private TypedPort(boolean isList, String name, EnumValue type) {\n-            super(isList, name);\n-            this.type = type;\n-        }\n-    }\n-\n-    private static class NodeClass {\n-        public final String className;\n-        public final String nameTemplate;\n-        public final List<TypedPort> inputs;\n-        public final List<Port> sux;\n-        private NodeClass(String className, String nameTemplate, List<TypedPort> inputs, List<Port> sux) {\n-            this.className = className;\n-            this.nameTemplate = nameTemplate;\n-            this.inputs = inputs;\n-            this.sux = sux;\n-        }\n-        @Override\n-        public String toString() {\n-            return className;\n-        }\n-    }\n-\n-    private static class EnumValue implements LengthToString {\n-        public EnumKlass enumKlass;\n-        public int ordinal;\n-        public EnumValue(EnumKlass enumKlass, int ordinal) {\n-            this.enumKlass = enumKlass;\n-            this.ordinal = ordinal;\n-        }\n-        @Override\n-        public String toString() {\n-            return enumKlass.simpleName + \".\" + enumKlass.values[ordinal];\n-        }\n-        @Override\n-        public String toString(Length l) {\n-            switch(l) {\n-                case S:\n-                    return enumKlass.values[ordinal];\n-                default:\n-                case M:\n-                case L:\n-                    return toString();\n-            }\n-        }\n-    }\n-\n-    public BinaryParser(ReadableByteChannel channel, ParseMonitor monitor, GraphDocument rootDocument, GroupCallback callback) {\n-        this.callback = callback;\n-        constantPool = new ArrayList<>();\n-        buffer = ByteBuffer.allocateDirect(256 * 1024);\n-        buffer.flip();\n-        this.channel = channel;\n-        this.rootDocument = rootDocument;\n-        folderStack = new LinkedList<>();\n-        hashStack = new LinkedList<>();\n-        this.monitor = monitor;\n-        try {\n-            this.digest = MessageDigest.getInstance(\"SHA-1\");\n-        } catch (NoSuchAlgorithmException e) {\n-        }\n-    }\n-\n-    private void fill() throws IOException {\n-        \/\/ All the data between lastPosition and position has been\n-        \/\/ used so add it to the digest.\n-        int position = buffer.position();\n-        buffer.position(lastPosition);\n-        byte[] remaining = new byte[position - buffer.position()];\n-        buffer.get(remaining);\n-        digest.update(remaining);\n-        assert position == buffer.position();\n-\n-        buffer.compact();\n-        if (channel.read(buffer) < 0) {\n-            throw new EOFException();\n-        }\n-        buffer.flip();\n-        lastPosition = buffer.position();\n-    }\n-\n-    private void ensureAvailable(int i) throws IOException {\n-        if (i > buffer.capacity()) {\n-            throw new IllegalArgumentException(String.format(\"Can not request %d bytes: buffer capacity is %d\", i, buffer.capacity()));\n-        }\n-        while (buffer.remaining() < i) {\n-            fill();\n-        }\n-    }\n-\n-    private int readByte() throws IOException {\n-        ensureAvailable(1);\n-        return ((int)buffer.get()) & 0xff;\n-    }\n-\n-    private int readInt() throws IOException {\n-        ensureAvailable(4);\n-        return buffer.getInt();\n-    }\n-\n-    private char readShort() throws IOException {\n-        ensureAvailable(2);\n-        return buffer.getChar();\n-    }\n-\n-    private long readLong() throws IOException {\n-        ensureAvailable(8);\n-        return buffer.getLong();\n-    }\n-\n-    private double readDouble() throws IOException {\n-        ensureAvailable(8);\n-        return buffer.getDouble();\n-    }\n-\n-    private float readFloat() throws IOException {\n-        ensureAvailable(4);\n-        return buffer.getFloat();\n-    }\n-\n-    private String readString() throws IOException {\n-        return new String(readBytes(), UTF_8).intern();\n-    }\n-\n-    private byte[] readBytes() throws IOException {\n-        int len = readInt();\n-        if (len < 0) {\n-            return null;\n-        }\n-        byte[] b = new byte[len];\n-        int bytesRead = 0;\n-        while (bytesRead < b.length) {\n-            int toRead = Math.min(b.length - bytesRead, buffer.capacity());\n-            ensureAvailable(toRead);\n-            buffer.get(b, bytesRead, toRead);\n-            bytesRead += toRead;\n-        }\n-        return b;\n-    }\n-\n-    private String readIntsToString() throws IOException {\n-        int len = readInt();\n-        if (len < 0) {\n-            return \"null\";\n-        }\n-        ensureAvailable(len * 4);\n-        StringBuilder sb = new StringBuilder().append('[');\n-        for (int i = 0; i < len; i++) {\n-            sb.append(buffer.getInt());\n-            if (i < len - 1) {\n-                sb.append(\", \");\n-            }\n-        }\n-        sb.append(']');\n-        return sb.toString().intern();\n-    }\n-\n-    private String readDoublesToString() throws IOException {\n-        int len = readInt();\n-        if (len < 0) {\n-            return \"null\";\n-        }\n-        ensureAvailable(len * 8);\n-        StringBuilder sb = new StringBuilder().append('[');\n-        for (int i = 0; i < len; i++) {\n-            sb.append(buffer.getDouble());\n-            if (i < len - 1) {\n-                sb.append(\", \");\n-            }\n-        }\n-        sb.append(']');\n-        return sb.toString().intern();\n-    }\n-\n-    private String readPoolObjectsToString() throws IOException {\n-        int len = readInt();\n-        if (len < 0) {\n-            return \"null\";\n-        }\n-        StringBuilder sb = new StringBuilder().append('[');\n-        for (int i = 0; i < len; i++) {\n-            sb.append(readPoolObject(Object.class));\n-            if (i < len - 1) {\n-                sb.append(\", \");\n-            }\n-        }\n-        sb.append(']');\n-        return sb.toString().intern();\n-    }\n-\n-    private <T> T readPoolObject(Class<T> klass) throws IOException {\n-        int type = readByte();\n-        if (type == POOL_NULL) {\n-            return null;\n-        }\n-        if (type == POOL_NEW) {\n-            return (T) addPoolEntry(klass);\n-        }\n-        assert assertObjectType(klass, type);\n-        char index = readShort();\n-        if (index < 0 || index >= constantPool.size()) {\n-            throw new IOException(\"Invalid constant pool index : \" + index);\n-        }\n-        Object obj = constantPool.get(index);\n-        return (T) obj;\n-    }\n-\n-    private boolean assertObjectType(Class<?> klass, int type) {\n-        switch(type) {\n-            case POOL_CLASS:\n-                return klass.isAssignableFrom(EnumKlass.class);\n-            case POOL_ENUM:\n-                return klass.isAssignableFrom(EnumValue.class);\n-            case POOL_METHOD:\n-                return klass.isAssignableFrom(Method.class);\n-            case POOL_STRING:\n-                return klass.isAssignableFrom(String.class);\n-            case POOL_NODE_CLASS:\n-                return klass.isAssignableFrom(NodeClass.class);\n-            case POOL_FIELD:\n-                return klass.isAssignableFrom(Field.class);\n-            case POOL_SIGNATURE:\n-                return klass.isAssignableFrom(Signature.class);\n-            case POOL_NULL:\n-                return true;\n-            default:\n-                return false;\n-        }\n-    }\n-\n-    private Object addPoolEntry(Class<?> klass) throws IOException {\n-        char index = readShort();\n-        int type = readByte();\n-        assert assertObjectType(klass, type) : \"Wrong object type : \" + klass + \" != \" + type;\n-        Object obj;\n-        switch(type) {\n-            case POOL_CLASS: {\n-                String name = readString();\n-                int klasstype = readByte();\n-                if (klasstype == ENUM_KLASS) {\n-                    int len = readInt();\n-                    String[] values = new String[len];\n-                    for (int i = 0; i < len; i++) {\n-                        values[i] = readPoolObject(String.class);\n-                    }\n-                    obj = new EnumKlass(name, values);\n-                } else if (klasstype == KLASS) {\n-                    obj = new Klass(name);\n-                } else {\n-                    throw new IOException(\"unknown klass type : \" + klasstype);\n-                }\n-                break;\n-            }\n-            case POOL_ENUM: {\n-                EnumKlass enumClass = readPoolObject(EnumKlass.class);\n-                int ordinal = readInt();\n-                obj = new EnumValue(enumClass, ordinal);\n-                break;\n-            }\n-            case POOL_NODE_CLASS: {\n-                String className = readString();\n-                String nameTemplate = readString();\n-                int inputCount = readShort();\n-                List<TypedPort> inputs = new ArrayList<>(inputCount);\n-                for (int i = 0; i < inputCount; i++) {\n-                    boolean isList = readByte() != 0;\n-                    String name = readPoolObject(String.class);\n-                    EnumValue inputType = readPoolObject(EnumValue.class);\n-                    inputs.add(new TypedPort(isList, name, inputType));\n-                }\n-                int suxCount = readShort();\n-                List<Port> sux = new ArrayList<>(suxCount);\n-                for (int i = 0; i < suxCount; i++) {\n-                    boolean isList = readByte() != 0;\n-                    String name = readPoolObject(String.class);\n-                    sux.add(new Port(isList, name));\n-                }\n-                obj = new NodeClass(className, nameTemplate, inputs, sux);\n-                break;\n-            }\n-            case POOL_METHOD: {\n-                Klass holder = readPoolObject(Klass.class);\n-                String name = readPoolObject(String.class);\n-                Signature sign = readPoolObject(Signature.class);\n-                int flags = readInt();\n-                byte[] code = readBytes();\n-                obj = new Method(name, sign, code, holder, flags);\n-                break;\n-            }\n-            case POOL_FIELD: {\n-                Klass holder = readPoolObject(Klass.class);\n-                String name = readPoolObject(String.class);\n-                String fType = readPoolObject(String.class);\n-                int flags = readInt();\n-                obj = new Field(fType, holder, name, flags);\n-                break;\n-            }\n-            case POOL_SIGNATURE: {\n-                int argc = readShort();\n-                String[] args = new String[argc];\n-                for (int i = 0; i < argc; i++) {\n-                    args[i] = readPoolObject(String.class);\n-                }\n-                String returnType = readPoolObject(String.class);\n-                obj = new Signature(returnType, args);\n-                break;\n-            }\n-            case POOL_STRING: {\n-                obj = readString();\n-                break;\n-            }\n-            default:\n-                throw new IOException(\"unknown pool type\");\n-        }\n-        while (constantPool.size() <= index) {\n-            constantPool.add(null);\n-        }\n-        constantPool.set(index, obj);\n-        return obj;\n-    }\n-\n-    private Object readPropertyObject() throws IOException {\n-        int type = readByte();\n-        switch (type) {\n-            case PROPERTY_INT:\n-                return readInt();\n-            case PROPERTY_LONG:\n-                return readLong();\n-            case PROPERTY_FLOAT:\n-                return readFloat();\n-            case PROPERTY_DOUBLE:\n-                return readDouble();\n-            case PROPERTY_TRUE:\n-                return Boolean.TRUE;\n-            case PROPERTY_FALSE:\n-                return Boolean.FALSE;\n-            case PROPERTY_POOL:\n-                return readPoolObject(Object.class);\n-            case PROPERTY_ARRAY:\n-                int subType = readByte();\n-                switch(subType) {\n-                    case PROPERTY_INT:\n-                        return readIntsToString();\n-                    case PROPERTY_DOUBLE:\n-                        return readDoublesToString();\n-                    case PROPERTY_POOL:\n-                        return readPoolObjectsToString();\n-                    default:\n-                        throw new IOException(\"Unknown type\");\n-                }\n-            case PROPERTY_SUBGRAPH:\n-                InputGraph graph = parseGraph(\"\");\n-                new Group(null).addElement(graph);\n-                return graph;\n-            default:\n-                throw new IOException(\"Unknown type\");\n-        }\n-    }\n-\n-    @Override\n-    public GraphDocument parse() throws IOException {\n-        folderStack.push(rootDocument);\n-        hashStack.push(null);\n-        if (monitor != null) {\n-            monitor.setState(\"Starting parsing\");\n-        }\n-        try {\n-            while(true) {\n-                parseRoot();\n-            }\n-        } catch (EOFException e) {\n-\n-        }\n-        if (monitor != null) {\n-            monitor.setState(\"Finished parsing\");\n-        }\n-        return rootDocument;\n-    }\n-\n-    private void parseRoot() throws IOException {\n-        int type = readByte();\n-        switch(type) {\n-            case BEGIN_GRAPH: {\n-                final Folder parent = folderStack.peek();\n-                final InputGraph graph = parseGraph();\n-                SwingUtilities.invokeLater(new Runnable(){\n-                    @Override\n-                    public void run() {\n-                        parent.addElement(graph);\n-                    }\n-                });\n-                break;\n-            }\n-            case BEGIN_GROUP: {\n-                final Folder parent = folderStack.peek();\n-                final Group group = parseGroup(parent);\n-                if (callback == null || parent instanceof Group) {\n-                    SwingUtilities.invokeLater(new Runnable(){\n-                        @Override\n-                        public void run() {\n-                            parent.addElement(group);\n-                        }\n-                    });\n-                }\n-                folderStack.push(group);\n-                hashStack.push(null);\n-                if (callback != null && parent instanceof GraphDocument) {\n-                    callback.started(group);\n-                }\n-                break;\n-            }\n-            case CLOSE_GROUP: {\n-                if (folderStack.isEmpty()) {\n-                    throw new IOException(\"Unbalanced groups\");\n-                }\n-                folderStack.pop();\n-                hashStack.pop();\n-                break;\n-            }\n-            default:\n-                throw new IOException(\"unknown root : \" + type);\n-        }\n-    }\n-\n-    private Group parseGroup(Folder parent) throws IOException {\n-        String name = readPoolObject(String.class);\n-        String shortName = readPoolObject(String.class);\n-        if (monitor != null) {\n-            monitor.setState(shortName);\n-        }\n-        Method method = readPoolObject(Method.class);\n-        int bci = readInt();\n-        Group group = new Group(parent);\n-        group.getProperties().setProperty(\"name\", name);\n-        parseProperties(group.getProperties());\n-        if (method != null) {\n-            InputMethod inMethod = new InputMethod(group, method.name, shortName, bci);\n-            inMethod.setBytecodes(\"TODO\");\n-            group.setMethod(inMethod);\n-        }\n-        return group;\n-    }\n-\n-    int lastPosition = 0;\n-\n-    private InputGraph parseGraph() throws IOException {\n-        if (monitor != null) {\n-            monitor.updateProgress();\n-        }\n-        String title = readPoolObject(String.class);\n-        digest.reset();\n-        lastPosition = buffer.position();\n-        InputGraph graph = parseGraph(title);\n-\n-        int position = buffer.position();\n-        buffer.position(lastPosition);\n-        byte[] remaining = new byte[position - buffer.position()];\n-        buffer.get(remaining);\n-        digest.update(remaining);\n-        assert position == buffer.position();\n-        lastPosition = buffer.position();\n-\n-        byte[] d = digest.digest();\n-        byte[] hash = hashStack.peek();\n-        if (hash != null && Arrays.equals(hash, d)) {\n-            graph.getProperties().setProperty(\"_isDuplicate\", \"true\");\n-        } else {\n-            hashStack.pop();\n-            hashStack.push(d);\n-        }\n-        return graph;\n-    }\n-\n-    private void parseProperties(Properties properties) throws IOException {\n-        int propCount = readShort();\n-        for (int j = 0; j < propCount; j++) {\n-            String key = readPoolObject(String.class);\n-            Object value = readPropertyObject();\n-            properties.setProperty(key, value != null ? value.toString() : \"null\");\n-        }\n-    }\n-\n-    private InputGraph parseGraph(String title) throws IOException {\n-        InputGraph graph = new InputGraph(title);\n-        parseProperties(graph.getProperties());\n-        parseNodes(graph);\n-        parseBlocks(graph);\n-        graph.ensureNodesInBlocks();\n-        for (InputNode node : graph.getNodes()) {\n-            node.internProperties();\n-        }\n-        return graph;\n-    }\n-\n-    private void parseBlocks(InputGraph graph) throws IOException {\n-        int blockCount = readInt();\n-        List<Edge> edges = new LinkedList<>();\n-        for (int i = 0; i < blockCount; i++) {\n-            int id = readInt();\n-            String name = id >= 0 ? Integer.toString(id) : NO_BLOCK;\n-            InputBlock block = graph.addBlock(name);\n-            int nodeCount = readInt();\n-            for (int j = 0; j < nodeCount; j++) {\n-                int nodeId = readInt();\n-                if (nodeId < 0) {\n-                    continue;\n-                }\n-                final Properties properties = graph.getNode(nodeId).getProperties();\n-                final String oldBlock = properties.get(\"block\");\n-                if(oldBlock != null) {\n-                    properties.setProperty(\"block\", oldBlock + \", \" + name);\n-                } else {\n-                    block.addNode(nodeId);\n-                    properties.setProperty(\"block\", name);\n-                }\n-            }\n-            int edgeCount = readInt();\n-            for (int j = 0; j < edgeCount; j++) {\n-                int to = readInt();\n-                edges.add(new Edge(id, to));\n-            }\n-        }\n-        for (Edge e : edges) {\n-            String fromName = e.from >= 0 ? Integer.toString(e.from) : NO_BLOCK;\n-            String toName = e.to >= 0 ? Integer.toString(e.to) : NO_BLOCK;\n-            graph.addBlockEdge(graph.getBlock(fromName), graph.getBlock(toName));\n-        }\n-    }\n-\n-    private void parseNodes(InputGraph graph) throws IOException {\n-        int count = readInt();\n-        Map<String, Object> props = new HashMap<>();\n-        List<Edge> inputEdges = new ArrayList<>(count);\n-        List<Edge> succEdges = new ArrayList<>(count);\n-        for (int i = 0; i < count; i++) {\n-            int id = readInt();\n-            InputNode node = new InputNode(id);\n-            final Properties properties = node.getProperties();\n-            NodeClass nodeClass = readPoolObject(NodeClass.class);\n-            int preds = readByte();\n-            if (preds > 0) {\n-                properties.setProperty(\"hasPredecessor\", \"true\");\n-            }\n-            properties.setProperty(\"idx\", Integer.toString(id));\n-            int propCount = readShort();\n-            for (int j = 0; j < propCount; j++) {\n-                String key = readPoolObject(String.class);\n-                if (key.equals(\"hasPredecessor\") || key.equals(\"name\") || key.equals(\"class\") || key.equals(\"id\") || key.equals(\"idx\")) {\n-                    key = \"!data.\" + key;\n-                }\n-                Object value = readPropertyObject();\n-                if (value instanceof InputGraph) {\n-                    InputGraph subgraph = (InputGraph) value;\n-                    subgraph.getProperties().setProperty(\"name\", node.getId() + \":\" + key);\n-                    node.addSubgraph((InputGraph) value);\n-                } else {\n-                    properties.setProperty(key, value != null ? value.toString() : \"null\");\n-                    props.put(key, value);\n-                }\n-            }\n-            ArrayList<Edge> currentEdges = new ArrayList<>();\n-            int portNum = 0;\n-            for (TypedPort p : nodeClass.inputs) {\n-                if (p.isList) {\n-                    int size = readShort();\n-                    for (int j = 0; j < size; j++) {\n-                        int in = readInt();\n-                        if (in >= 0) {\n-                            Edge e = new Edge(in, id, (char) (preds + portNum), p.name + \"[\" + j + \"]\", p.type.toString(Length.S), true);\n-                            currentEdges.add(e);\n-                            inputEdges.add(e);\n-                            portNum++;\n-                        }\n-                    }\n-                } else {\n-                    int in = readInt();\n-                    if (in >= 0) {\n-                        Edge e = new Edge(in, id, (char) (preds + portNum), p.name, p.type.toString(Length.S), true);\n-                        currentEdges.add(e);\n-                        inputEdges.add(e);\n-                        portNum++;\n-                    }\n-                }\n-\n-            }\n-            portNum = 0;\n-            for (Port p : nodeClass.sux) {\n-                if (p.isList) {\n-                    int size = readShort();\n-                    for (int j = 0; j < size; j++) {\n-                        int sux = readInt();\n-                        if (sux >= 0) {\n-                            Edge e = new Edge(id, sux, (char) portNum, p.name + \"[\" + j + \"]\", \"Successor\", false);\n-                            currentEdges.add(e);\n-                            succEdges.add(e);\n-                            portNum++;\n-                        }\n-                    }\n-                } else {\n-                    int sux = readInt();\n-                    if (sux >= 0) {\n-                        Edge e = new Edge(id, sux, (char) portNum, p.name, \"Successor\", false);\n-                        currentEdges.add(e);\n-                        succEdges.add(e);\n-                        portNum++;\n-                    }\n-                }\n-            }\n-            properties.setProperty(\"name\", createName(currentEdges, props, nodeClass.nameTemplate));\n-            properties.setProperty(\"class\", nodeClass.className);\n-            switch (nodeClass.className) {\n-                case \"BeginNode\":\n-                    properties.setProperty(\"shortName\", \"B\");\n-                    break;\n-                case \"EndNode\":\n-                    properties.setProperty(\"shortName\", \"E\");\n-                    break;\n-            }\n-            graph.addNode(node);\n-            props.clear();\n-        }\n-\n-        Set<InputNode> nodesWithSuccessor = new HashSet<>();\n-\n-        for (Edge e : succEdges) {\n-            assert !e.input;\n-            char fromIndex = e.num;\n-            nodesWithSuccessor.add(graph.getNode(e.from));\n-            char toIndex = 0;\n-            graph.addEdge(InputEdge.createImmutable(fromIndex, toIndex, e.from, e.to, e.label, e.type));\n-        }\n-        for (Edge e : inputEdges) {\n-            assert e.input;\n-            char fromIndex = (char) (nodesWithSuccessor.contains(graph.getNode(e.from)) ? 1 : 0);\n-            char toIndex = e.num;\n-            graph.addEdge(InputEdge.createImmutable(fromIndex, toIndex, e.from, e.to, e.label, e.type));\n-        }\n-    }\n-\n-    static final Pattern templatePattern = Pattern.compile(\"\\\\{(p|i)#([a-zA-Z0-9$_]+)(\/(l|m|s))?\\\\}\");\n-\n-    private String createName(List<Edge> edges, Map<String, Object> properties, String template) {\n-        Matcher m = templatePattern.matcher(template);\n-        StringBuffer sb = new StringBuffer();\n-        while (m.find()) {\n-            String name = m.group(2);\n-            String type = m.group(1);\n-            String result;\n-            switch (type) {\n-                case \"i\":\n-                    StringBuilder inputString = new StringBuilder();\n-                    for(Edge edge : edges) {\n-                        if (edge.label.startsWith(name) && (name.length() == edge.label.length() || edge.label.charAt(name.length()) == '[')) {\n-                            if (inputString.length() > 0) {\n-                                inputString.append(\", \");\n-                            }\n-                            inputString.append(edge.from);\n-                        }\n-                    }\n-                    result = inputString.toString();\n-                    break;\n-                case \"p\":\n-                    Object prop = properties.get(name);\n-                    String length = m.group(4);\n-                    if (prop == null) {\n-                        result = \"?\";\n-                    } else if (length != null && prop instanceof LengthToString) {\n-                        LengthToString lengthProp = (LengthToString) prop;\n-                        switch(length) {\n-                            default:\n-                            case \"l\":\n-                                result = lengthProp.toString(Length.L);\n-                                break;\n-                            case \"m\":\n-                                result = lengthProp.toString(Length.M);\n-                                break;\n-                            case \"s\":\n-                                result = lengthProp.toString(Length.S);\n-                                break;\n-                        }\n-                    } else {\n-                        result = prop.toString();\n-                    }\n-                    break;\n-                default:\n-                    result = \"#?#\";\n-                    break;\n-            }\n-            result = result.replace(\"\\\\\", \"\\\\\\\\\");\n-            result = result.replace(\"$\", \"\\\\$\");\n-            m.appendReplacement(sb, result);\n-        }\n-        m.appendTail(sb);\n-        return sb.toString().intern();\n-    }\n-\n-    private static class Edge {\n-        final int from;\n-        final int to;\n-        final char num;\n-        final String label;\n-        final String type;\n-        final boolean input;\n-        public Edge(int from, int to) {\n-            this(from, to, (char) 0, null, null, false);\n-        }\n-        public Edge(int from, int to, char num, String label, String type, boolean input) {\n-            this.from = from;\n-            this.to = to;\n-            this.label = label != null ? label.intern() : label;\n-            this.type = type != null ? type.intern() : type;\n-            this.num = num;\n-            this.input = input;\n-        }\n-    }\n-}\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/main\/java\/com\/sun\/hotspot\/igv\/data\/serialization\/BinaryParser.java","additions":0,"deletions":937,"binary":false,"changes":937,"status":"deleted"},{"patch":"@@ -32,1 +32,0 @@\n-import java.io.InputStream;\n@@ -42,3 +41,0 @@\n-import javax.xml.transform.Source;\n-import javax.xml.transform.stream.StreamSource;\n-import javax.xml.validation.SchemaFactory;\n@@ -56,1 +52,0 @@\n-    public static final String INDENT = \"  \";\n@@ -70,6 +65,0 @@\n-    public static final String GROUP_NAME_PROPERTY = \"name\";\n-    public static final String METHOD_IS_PUBLIC_PROPERTY = \"public\";\n-    public static final String METHOD_IS_STATIC_PROPERTY = \"static\";\n-    public static final String TRUE_VALUE = \"true\";\n-    public static final String NODE_NAME_PROPERTY = \"name\";\n-    public static final String EDGE_NAME_PROPERTY = \"name\";\n@@ -96,1 +85,0 @@\n-    public static final String ASSEMBLY_ELEMENT = \"assembly\";\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/main\/java\/com\/sun\/hotspot\/igv\/data\/serialization\/Parser.java","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import static org.junit.Assert.assertEquals;\n@@ -29,0 +28,1 @@\n+import static org.junit.Assert.assertEquals;\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/test\/java\/com\/sun\/hotspot\/igv\/data\/ChangedEventTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import static org.junit.Assert.*;\n@@ -29,0 +28,1 @@\n+import static org.junit.Assert.*;\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/test\/java\/com\/sun\/hotspot\/igv\/data\/ControllableChangedListenerTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import static org.junit.Assert.assertEquals;\n@@ -31,0 +30,1 @@\n+import static org.junit.Assert.assertEquals;\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/test\/java\/com\/sun\/hotspot\/igv\/data\/GroupTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,5 +27,0 @@\n-import java.util.Arrays;\n-import java.util.List;\n-import java.util.Map;\n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertTrue;\n@@ -126,85 +121,0 @@\n-\n-    \/**\n-     * Test of findRootNodes method, of class InputGraph.\n-     *\/\n-    @Test\n-    public void testFindRootNodes() {\n-        assertTrue(emptyGraph.findRootNodes().isEmpty());\n-\n-        List<InputNode> result = referenceGraph.findRootNodes();\n-        assertTrue(result.size() == 2);\n-        assertTrue(result.contains(N1));\n-        assertTrue(result.contains(N5));\n-    }\n-\n-    \/**\n-     * Test of findAllOutgoingEdges method, of class InputGraph.\n-     *\/\n-    @Test\n-    public void testFindAllOutgoingEdges() {\n-        assertTrue(emptyGraph.findAllOutgoingEdges().isEmpty());\n-\n-        Map<InputNode, List<InputEdge>> result = referenceGraph.findAllOutgoingEdges();\n-        assertTrue(result.size() == 5);\n-        assertEquals(result.get(N1), Arrays.asList(E12, E13));\n-        assertEquals(result.get(N2), Arrays.asList(E24));\n-        assertEquals(result.get(N3), Arrays.asList(E34));\n-        assertEquals(result.get(N4), Arrays.asList());\n-        assertEquals(result.get(N5), Arrays.asList(E54));\n-    }\n-\n-    \/**\n-     * Test of findAllIngoingEdges method, of class InputGraph.\n-     *\/\n-    @Test\n-    public void testFindAllIngoingEdges() {\n-        assertTrue(emptyGraph.findAllIngoingEdges().isEmpty());\n-\n-        Map<InputNode, List<InputEdge>> result = referenceGraph.findAllIngoingEdges();\n-        assertTrue(result.size() == 5);\n-        assertEquals(result.get(N1), Arrays.asList());\n-        assertEquals(result.get(N2), Arrays.asList(E12));\n-        assertEquals(result.get(N3), Arrays.asList(E13));\n-        assertEquals(result.get(N4), Arrays.asList(E24, E34, E54));\n-        assertEquals(result.get(N5), Arrays.asList());\n-    }\n-\n-    \/**\n-     * Test of findOutgoingEdges method, of class InputGraph.\n-     *\/\n-    @Test\n-    public void testFindOutgoingEdges() {\n-        assertTrue(emptyGraph.findOutgoingEdges(new InputNode(1)).isEmpty());\n-\n-        assertEquals(referenceGraph.findOutgoingEdges(N1), Arrays.asList(E12, E13));\n-        assertEquals(referenceGraph.findOutgoingEdges(N2), Arrays.asList(E24));\n-        assertEquals(referenceGraph.findOutgoingEdges(N3), Arrays.asList(E34));\n-        assertEquals(referenceGraph.findOutgoingEdges(N4), Arrays.asList());\n-        assertEquals(referenceGraph.findOutgoingEdges(N5), Arrays.asList(E54));\n-    }\n-\n-    \/**\n-     * Test of getNext method, of class InputGraph.\n-     *\/\n-    @Test\n-    public void testGetNextPrev() {\n-        final Group group = new Group(null);\n-\n-        final InputGraph a = new InputGraph(\"a\");\n-\n-        final InputGraph b = new InputGraph(\"b\");\n-\n-        final InputGraph c = new InputGraph(\"c\");\n-        group.addElement(a);\n-        group.addElement(b);\n-        group.addElement(c);\n-\n-        assertEquals(null, a.getPrev());\n-        assertEquals(b, a.getNext());\n-\n-        assertEquals(a, b.getPrev());\n-        assertEquals(c, b.getNext());\n-\n-        assertEquals(b, c.getPrev());\n-        assertEquals(null, c.getNext());\n-    }\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/test\/java\/com\/sun\/hotspot\/igv\/data\/InputGraphTest.java","additions":0,"deletions":90,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import static org.junit.Assert.assertThat;\n@@ -31,0 +30,1 @@\n+import static org.junit.Assert.assertThat;\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/test\/java\/com\/sun\/hotspot\/igv\/data\/InputMethodTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import static org.junit.Assert.*;\n@@ -30,0 +29,1 @@\n+import static org.junit.Assert.*;\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/test\/java\/com\/sun\/hotspot\/igv\/data\/PairTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,5 +28,1 @@\n-import com.sun.hotspot.igv.data.Properties.InvertPropertyMatcher;\n-import com.sun.hotspot.igv.data.Properties.PropertyMatcher;\n-import com.sun.hotspot.igv.data.Properties.PropertySelector;\n-import com.sun.hotspot.igv.data.Properties.RegexpPropertyMatcher;\n-import com.sun.hotspot.igv.data.Properties.StringPropertyMatcher;\n+import com.sun.hotspot.igv.data.Properties.*;\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/test\/java\/com\/sun\/hotspot\/igv\/data\/PropertiesTest.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import static org.junit.Assert.*;\n@@ -30,0 +29,1 @@\n+import static org.junit.Assert.*;\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/test\/java\/com\/sun\/hotspot\/igv\/data\/PropertyTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import static org.junit.Assert.assertEquals;\n@@ -31,0 +30,1 @@\n+import static org.junit.Assert.assertEquals;\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/test\/java\/com\/sun\/hotspot\/igv\/data\/SourceTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,2 @@\n-import static org.junit.Assert.*;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.fail;\n@@ -36,10 +37,0 @@\n-    public static void assertGraphDocumentNotEquals(GraphDocument a, GraphDocument b) {\n-        try {\n-            assertGraphDocumentEquals(a, b);\n-        } catch(AssertionError e) {\n-            return;\n-        }\n-\n-        fail(\"Graphs documents are equal!\");\n-    }\n-\n@@ -64,10 +55,0 @@\n-    public static void assertGroupNotEquals(Group a, Group b) {\n-        try {\n-            assertGroupEquals(a, b);\n-        } catch(AssertionError e) {\n-            return;\n-        }\n-\n-        fail(\"Groups are equal!\");\n-    }\n-\n@@ -76,1 +57,1 @@\n-        if (a.getGraphsCount() != b.getGraphsCount()) {\n+        if (a.getGraphs().size() != b.getGraphs().size()) {\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/test\/java\/com\/sun\/hotspot\/igv\/data\/Util.java","additions":3,"deletions":22,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -29,1 +29,4 @@\n-import java.io.*;\n+import java.io.ByteArrayInputStream;\n+import java.io.CharArrayWriter;\n+import java.io.IOException;\n+import java.io.InputStream;\n@@ -31,1 +34,0 @@\n-\n@@ -33,0 +35,1 @@\n+import org.junit.*;\n@@ -35,3 +38,0 @@\n-import org.junit.*;\n-import org.openide.util.Exceptions;\n-import org.xml.sax.InputSource;\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/test\/java\/com\/sun\/hotspot\/igv\/data\/serialization\/ParserTest.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -290,3 +290,0 @@\n-\n-        Set<InputNode> matched = new HashSet<>();\n-\n","filename":"src\/utils\/IdealGraphVisualizer\/Difference\/src\/main\/java\/com\/sun\/hotspot\/igv\/difference\/Difference.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import com.sun.hotspot.igv.graph.Connection.ConnectionStyle;\n@@ -29,0 +28,1 @@\n+import com.sun.hotspot.igv.graph.Connection.ConnectionStyle;\n","filename":"src\/utils\/IdealGraphVisualizer\/Filter\/src\/main\/java\/com\/sun\/hotspot\/igv\/filter\/ColorFilter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -77,1 +77,1 @@\n-                        slot.getSource().addSourceNodes(f.getSource());\n+                        slot.getSource().addSourceNode(f.getInputNode());\n@@ -133,1 +133,1 @@\n-                                slot.getSource().addSourceNodes(succ.getSource());\n+                                slot.getSource().addSourceNode(succ.getInputNode());\n","filename":"src\/utils\/IdealGraphVisualizer\/Filter\/src\/main\/java\/com\/sun\/hotspot\/igv\/filter\/CombineFilter.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,1 +28,4 @@\n-import javax.script.*;\n+import javax.script.Bindings;\n+import javax.script.ScriptContext;\n+import javax.script.ScriptEngine;\n+import javax.script.ScriptException;\n","filename":"src\/utils\/IdealGraphVisualizer\/Filter\/src\/main\/java\/com\/sun\/hotspot\/igv\/filter\/CustomFilter.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-import com.sun.hotspot.igv.graph.Diagram;\n@@ -29,0 +28,1 @@\n+import com.sun.hotspot.igv.graph.Diagram;\n","filename":"src\/utils\/IdealGraphVisualizer\/Filter\/src\/main\/java\/com\/sun\/hotspot\/igv\/filter\/RemoveBlockFilter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -59,3 +59,3 @@\n-                    if (f.getSource().getSourceNodes().size() > 0) {\n-                        os.getSource().addSourceNodes(f.getSource());\n-                        os.setAssociatedNode(f.getSource().getSourceNodes().get(0));\n+                    if (f.getInputNode() != null) {\n+                        os.getSource().addSourceNode(f.getInputNode());\n+                        os.setAssociatedNode(f.getInputNode());\n@@ -76,3 +76,3 @@\n-                    if (f.getSource().getSourceNodes().size() > 0) {\n-                        is.getSource().addSourceNodes(f.getSource());\n-                        is.setAssociatedNode(f.getSource().getSourceNodes().get(0));\n+                    if (f.getInputNode() != null) {\n+                        is.getSource().addSourceNode(f.getInputNode());\n+                        is.setAssociatedNode(f.getInputNode());\n","filename":"src\/utils\/IdealGraphVisualizer\/Filter\/src\/main\/java\/com\/sun\/hotspot\/igv\/filter\/SplitFilter.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -27,1 +27,3 @@\n-import com.sun.hotspot.igv.graph.*;\n+import com.sun.hotspot.igv.graph.Diagram;\n+import com.sun.hotspot.igv.graph.Figure;\n+import com.sun.hotspot.igv.graph.Selector;\n","filename":"src\/utils\/IdealGraphVisualizer\/Filter\/src\/main\/java\/com\/sun\/hotspot\/igv\/filter\/WarningFilter.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -709,9 +709,0 @@\n-\n-    static final class ResolvableHelper implements Serializable {\n-\n-        private static final long serialVersionUID = 1L;\n-\n-        public Object readResolve() {\n-            return FilterTopComponent.getDefault();\n-        }\n-    }\n","filename":"src\/utils\/IdealGraphVisualizer\/FilterWindow\/src\/main\/java\/com\/sun\/hotspot\/igv\/filterwindow\/FilterTopComponent.java","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -21,1 +21,1 @@\n-    \n+\n@@ -31,0 +31,1 @@\n+                <attr name=\"position\" intvalue=\"3\"\/>\n","filename":"src\/utils\/IdealGraphVisualizer\/FilterWindow\/src\/main\/resources\/com\/sun\/hotspot\/igv\/filterwindow\/layer.xml","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-import java.util.List;\n@@ -28,0 +27,1 @@\n+import java.util.List;\n@@ -42,1 +42,1 @@\n-            l.add(d.getBlock(f.getBlock()));\n+            l.add(f.getBlock());\n","filename":"src\/utils\/IdealGraphVisualizer\/Graph\/src\/main\/java\/com\/sun\/hotspot\/igv\/graph\/AnySelector.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-import java.awt.Dimension;\n@@ -29,0 +28,1 @@\n+import java.awt.Dimension;\n@@ -48,4 +48,0 @@\n-    public Cluster getOuter() {\n-        return null;\n-    }\n-\n","filename":"src\/utils\/IdealGraphVisualizer\/Graph\/src\/main\/java\/com\/sun\/hotspot\/igv\/graph\/Block.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -26,7 +26,1 @@\n-import com.sun.hotspot.igv.data.InputBlock;\n-import com.sun.hotspot.igv.data.InputBlockEdge;\n-import com.sun.hotspot.igv.data.InputEdge;\n-import com.sun.hotspot.igv.data.InputGraph;\n-import com.sun.hotspot.igv.data.InputNode;\n-import com.sun.hotspot.igv.data.Properties;\n-import com.sun.hotspot.igv.data.Properties.StringPropertyMatcher;\n+import com.sun.hotspot.igv.data.*;\n@@ -34,1 +28,0 @@\n-import java.awt.Color;\n@@ -45,1 +38,0 @@\n-    private InputGraph graph;\n@@ -50,3 +42,3 @@\n-    private final Font font;\n-    private final Font slotFont;\n-    private final Font boldFont;\n+    private static final Font font = new Font(\"Arial\", Font.PLAIN, 12);\n+    private static final Font slotFont = new Font(\"Arial\", Font.PLAIN, 10);\n+    private static final Font boldFont = font.deriveFont(Font.BOLD);\n@@ -58,1 +50,1 @@\n-    public Font getFont() {\n+    public static Font getFont() {\n@@ -62,1 +54,1 @@\n-    public Font getSlotFont() {\n+    public static Font getSlotFont() {\n@@ -66,1 +58,1 @@\n-    public Font getBoldFont() {\n+    public static Font getBoldFont() {\n@@ -78,12 +70,4 @@\n-    private Diagram(InputGraph graph, String nodeText, String shortNodeText,\n-                    String tinyNodeText) {\n-        figures = new ArrayList<>();\n-        blocks = new LinkedHashMap<>(8);\n-        this.nodeText = \"\";\n-        this.shortNodeText = \"\";\n-        this.font = new Font(\"Arial\", Font.PLAIN, 12);\n-        this.slotFont = new Font(\"Arial\", Font.PLAIN, 10);\n-        this.boldFont = this.font.deriveFont(Font.BOLD);\n-        this.cfg = false;\n-        this.blockConnections = new HashSet<>();\n-        this.graph = graph;\n+    public Diagram(InputGraph graph, String nodeText, String shortNodeText,\n+                   String tinyNodeText) {\n+        assert graph != null;\n+\n@@ -93,22 +77,5 @@\n-    }\n-\n-    public Block getBlock(InputBlock b) {\n-        assert blocks.containsKey(b);\n-        return blocks.get(b);\n-    }\n-\n-    public boolean hasBlock(InputBlock b) {\n-        return blocks.containsKey(b);\n-    }\n-\n-    public String getNodeText() {\n-        return nodeText;\n-    }\n-\n-    public String getShortNodeText() {\n-        return shortNodeText;\n-    }\n-\n-    public String getTinyNodeText() {\n-        return tinyNodeText;\n-    }\n+        this.figures = new ArrayList<Figure>();\n+        this.blocks = new LinkedHashMap<InputBlock, Block>(8);\n+        this.blockConnections = new HashSet<BlockConnection>();\n+        this.cfg = false;\n+        this.curId = 0;\n@@ -116,2 +83,0 @@\n-    public void updateBlocks() {\n-        blocks.clear();\n@@ -119,47 +84,1 @@\n-            Block curBlock = new Block(b, this);\n-            blocks.put(b, curBlock);\n-        }\n-    }\n-\n-    public Collection<Block> getBlocks() {\n-        return Collections.unmodifiableCollection(blocks.values());\n-    }\n-\n-    public List<Figure> getFigures() {\n-        return Collections.unmodifiableList(figures);\n-    }\n-\n-    public Figure createFigure() {\n-        Figure f = new Figure(this, curId);\n-        curId++;\n-        this.figures.add(f);\n-        return f;\n-    }\n-\n-    public FigureConnection createConnection(InputSlot inputSlot, OutputSlot outputSlot, String label) {\n-        assert inputSlot.getFigure().getDiagram() == this;\n-        assert outputSlot.getFigure().getDiagram() == this;\n-        return new FigureConnection(inputSlot, outputSlot, label);\n-    }\n-\n-    public Map<InputNode, Set<Figure>> calcSourceToFigureRelation() {\n-        Map<InputNode, Set<Figure>> map = new HashMap<>();\n-\n-        for(InputNode node : this.getGraph().getNodes()) {\n-            map.put(node, new HashSet<Figure>());\n-        }\n-\n-        for(Figure f : this.getFigures()) {\n-            for(InputNode node : f.getSource().getSourceNodes()) {\n-                map.get(node).add(f);\n-            }\n-        }\n-\n-        return map;\n-    }\n-\n-    public static Diagram createDiagram(InputGraph graph, String nodeText,\n-                                        String shortNodeText,\n-                                        String tinyNodeText) {\n-        if (graph == null) {\n-            return null;\n+            blocks.put(b,  new Block(b, this));\n@@ -168,3 +87,0 @@\n-        Diagram d = new Diagram(graph, nodeText, shortNodeText, tinyNodeText);\n-        d.updateBlocks();\n-\n@@ -174,2 +90,2 @@\n-            Figure f = d.createFigure();\n-            f.getSource().addSourceNode(n);\n+            Figure f = new Figure(this, curId, n);\n+            curId++;\n@@ -177,2 +93,1 @@\n-            f.setSubgraphs(n.getSubgraphs());\n-            f.setBlock(graph.getBlock(n));\n+            f.setBlock(blocks.get(graph.getBlock(n)));\n@@ -180,0 +95,1 @@\n+            this.figures.add(f);\n@@ -204,1 +120,1 @@\n-            FigureConnection c = d.createConnection(inputSlot, outputSlot, e.getLabel());\n+            FigureConnection c = createConnection(inputSlot, outputSlot, e.getLabel());\n@@ -214,3 +130,3 @@\n-            Block p = d.getBlock(e.getFrom());\n-            Block s = d.getBlock(e.getTo());\n-            d.blockConnections.add(new BlockConnection(p, s, e.getLabel()));\n+            Block p = getBlock(e.getFrom());\n+            Block s = getBlock(e.getTo());\n+            blockConnections.add(new BlockConnection(p, s, e.getLabel()));\n@@ -218,0 +134,10 @@\n+    }\n+\n+    public Block getBlock(InputBlock b) {\n+        assert blocks.containsKey(b);\n+        return blocks.get(b);\n+    }\n+\n+    public boolean hasBlock(InputBlock b) {\n+        return blocks.containsKey(b);\n+    }\n@@ -219,1 +145,28 @@\n-        return d;\n+    public String getNodeText() {\n+        return nodeText;\n+    }\n+\n+    public String getShortNodeText() {\n+        return shortNodeText;\n+    }\n+\n+    public String getTinyNodeText() {\n+        return tinyNodeText;\n+    }\n+\n+    public Collection<Block> getBlocks() {\n+        return Collections.unmodifiableCollection(blocks.values());\n+    }\n+\n+    public Collection<InputBlock> getInputBlocks() {\n+        return Collections.unmodifiableCollection(blocks.keySet());\n+    }\n+\n+    public List<Figure> getFigures() {\n+        return Collections.unmodifiableList(figures);\n+    }\n+\n+    public FigureConnection createConnection(InputSlot inputSlot, OutputSlot outputSlot, String label) {\n+        assert inputSlot.getFigure().getDiagram() == this;\n+        assert outputSlot.getFigure().getDiagram() == this;\n+        return new FigureConnection(inputSlot, outputSlot, label);\n@@ -226,1 +179,1 @@\n-                if (f.getBlock() == b.getInputBlock()) {\n+                if (f.getBlock() == b) {\n@@ -276,8 +229,0 @@\n-    public String getName() {\n-        return graph.getName();\n-    }\n-\n-    public InputGraph getGraph() {\n-        return graph;\n-    }\n-\n@@ -305,62 +250,0 @@\n-    public Figure getRootFigure() {\n-        Properties.PropertySelector<Figure> selector = new Properties.PropertySelector<>(figures);\n-        Figure root = selector.selectSingle(new StringPropertyMatcher(\"name\", \"Root\"));\n-        if (root == null) {\n-            root = selector.selectSingle(new StringPropertyMatcher(\"name\", \"Start\"));\n-        }\n-        if (root == null) {\n-            List<Figure> rootFigures = getRootFigures();\n-            if (rootFigures.size() > 0) {\n-                root = rootFigures.get(0);\n-            } else if (figures.size() > 0) {\n-                root = figures.get(0);\n-            }\n-        }\n-\n-        return root;\n-    }\n-\n-    public void printStatistics() {\n-        System.out.println(\"=============================================================\");\n-        System.out.println(\"Diagram statistics\");\n-\n-        List<Figure> tmpFigures = getFigures();\n-        Set<FigureConnection> connections = getConnections();\n-\n-        System.out.println(\"Number of figures: \" + tmpFigures.size());\n-        System.out.println(\"Number of connections: \" + connections.size());\n-\n-        List<Figure> figuresSorted = new ArrayList<>(tmpFigures);\n-        figuresSorted.sort(new Comparator<Figure>() {\n-\n-            @Override\n-            public int compare(Figure a, Figure b) {\n-                return b.getPredecessors().size() + b.getSuccessors().size() - a.getPredecessors().size() - a.getSuccessors().size();\n-            }\n-        });\n-\n-        final int COUNT = 10;\n-        int z = 0;\n-        for (Figure f : figuresSorted) {\n-\n-            z++;\n-            int sum = f.getPredecessors().size() + f.getSuccessors().size();\n-            System.out.println(\"#\" + z + \": \" + f + \", predCount=\" + f.getPredecessors().size() + \" succCount=\" + f.getSuccessors().size());\n-            if (sum < COUNT) {\n-                break;\n-            }\n-\n-        }\n-\n-        System.out.println(\"=============================================================\");\n-    }\n-\n-    public List<Figure> getRootFigures() {\n-        ArrayList<Figure> rootFigures = new ArrayList<>();\n-        for (Figure f : figures) {\n-            if (f.getPredecessors().size() == 0) {\n-                rootFigures.add(f);\n-            }\n-        }\n-        return rootFigures;\n-    }\n","filename":"src\/utils\/IdealGraphVisualizer\/Graph\/src\/main\/java\/com\/sun\/hotspot\/igv\/graph\/Diagram.java","additions":64,"deletions":181,"binary":false,"changes":245,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n-import com.sun.hotspot.igv.data.InputBlock;\n-import com.sun.hotspot.igv.data.InputGraph;\n@@ -30,1 +28,0 @@\n-import com.sun.hotspot.igv.data.Source;\n@@ -37,1 +34,1 @@\n-public class Figure extends Properties.Entity implements Source.Provider, Vertex {\n+public class Figure extends Properties.Entity implements Vertex {\n@@ -49,1 +46,1 @@\n-    private Source source;\n+    private InputNode inputNode;\n@@ -54,1 +51,0 @@\n-    private List<InputGraph> subgraphs;\n@@ -62,1 +58,1 @@\n-    private InputBlock block;\n+    private Block block;\n@@ -135,1 +131,1 @@\n-    protected Figure(Diagram diagram, int id) {\n+    protected Figure(Diagram diagram, int id, InputNode node) {\n@@ -137,5 +133,5 @@\n-        this.source = new Source();\n-        inputSlots = new ArrayList<>(5);\n-        outputSlots = new ArrayList<>(1);\n-        predecessors = new ArrayList<>(6);\n-        successors = new ArrayList<>(6);\n+        this.inputNode = node;\n+        this.inputSlots = new ArrayList<>(5);\n+        this.outputSlots = new ArrayList<>(1);\n+        this.predecessors = new ArrayList<>(6);\n+        this.successors = new ArrayList<>(6);\n@@ -143,2 +139,1 @@\n-        idString = Integer.toString(id);\n-\n+        this.idString = Integer.toString(id);\n@@ -148,1 +143,1 @@\n-        metrics = canvas.getFontMetrics(diagram.getFont().deriveFont(Font.BOLD));\n+        this.metrics = canvas.getFontMetrics(diagram.getFont().deriveFont(Font.BOLD));\n@@ -175,1 +170,1 @@\n-    public void setBlock(InputBlock block) {\n+    public void setBlock(Block block) {\n@@ -179,1 +174,1 @@\n-    public InputBlock getBlock() {\n+    public Block getBlock() {\n@@ -225,8 +220,0 @@\n-    public List<InputGraph> getSubgraphs() {\n-        return subgraphs;\n-    }\n-\n-    public void setSubgraphs(List<InputGraph> subgraphs) {\n-        this.subgraphs = subgraphs;\n-    }\n-\n@@ -247,3 +234,2 @@\n-    @Override\n-    public Source getSource() {\n-        return source;\n+    public InputNode getInputNode() {\n+        return inputNode;\n@@ -369,1 +355,1 @@\n-        \/\/ Set the \"label\" property of each input node, so that by default\n+        \/\/ Set the \"label\" property of the input node, so that by default\n@@ -372,4 +358,3 @@\n-        for (InputNode n : getSource().getSourceNodes()) {\n-            String label = n.getProperties().resolveString(diagram.getNodeText());\n-            n.getProperties().setProperty(\"label\", label.replaceAll(\"\\\\R\", \" \"));\n-        }\n+        String label = inputNode.getProperties().resolveString(diagram.getNodeText());\n+        inputNode.getProperties().setProperty(\"label\", label.replaceAll(\"\\\\R\", \" \"));\n+\n@@ -393,4 +378,0 @@\n-    public InputNode getFirstSourceNode() {\n-        return getSource().getSourceNodes().get(0);\n-    }\n-\n@@ -402,10 +383,1 @@\n-        if (getSource().getSourceNodes().size() == 0) {\n-            assert false : \"Should never reach here, every figure must have at least one source node!\";\n-            return null;\n-        } else {\n-            final InputBlock inputBlock = diagram.getGraph().getBlock(getFirstSourceNode());\n-            assert inputBlock != null;\n-            Cluster result = diagram.getBlock(inputBlock);\n-            assert result != null;\n-            return result;\n-        }\n+        return block;\n@@ -416,4 +388,2 @@\n-\n-        List<InputNode> sourceNodes = source.getSourceNodes();\n-        if (sourceNodes.size() > 0 && getFirstSourceNode().getProperties().get(\"name\") != null) {\n-            return getFirstSourceNode().getProperties().get(\"name\").equals(\"Root\");\n+        if (inputNode != null && inputNode.getProperties().get(\"name\") != null) {\n+            return inputNode.getProperties().get(\"name\").equals(\"Root\");\n","filename":"src\/utils\/IdealGraphVisualizer\/Graph\/src\/main\/java\/com\/sun\/hotspot\/igv\/graph\/Figure.java","additions":22,"deletions":52,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-import com.sun.hotspot.igv.layout.Port;\n@@ -28,0 +27,1 @@\n+import com.sun.hotspot.igv.layout.Port;\n","filename":"src\/utils\/IdealGraphVisualizer\/Graph\/src\/main\/java\/com\/sun\/hotspot\/igv\/graph\/FigureConnection.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,38 +0,0 @@\n-\/*\n- * Copyright (c) 2008, 2015, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-package com.sun.hotspot.igv.graph.services;\n-\n-import com.sun.hotspot.igv.data.ChangedEvent;\n-import com.sun.hotspot.igv.graph.Diagram;\n-\n-\/**\n- *\n- * @author Thomas Wuerthinger\n- *\/\n-public interface DiagramProvider {\n-    Diagram getDiagram();\n-    ChangedEvent<DiagramProvider> getChangedEvent();\n-\n-}\n","filename":"src\/utils\/IdealGraphVisualizer\/Graph\/src\/main\/java\/com\/sun\/hotspot\/igv\/graph\/services\/DiagramProvider.java","additions":0,"deletions":38,"binary":false,"changes":38,"status":"deleted"},{"patch":"@@ -26,0 +26,1 @@\n+import com.sun.hotspot.igv.layout.Cluster;\n@@ -28,1 +29,0 @@\n-import com.sun.hotspot.igv.layout.Cluster;\n","filename":"src\/utils\/IdealGraphVisualizer\/HierarchicalLayout\/src\/main\/java\/com\/sun\/hotspot\/igv\/hierarchicallayout\/ClusterEdge.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+import com.sun.hotspot.igv.layout.Cluster;\n@@ -28,1 +29,0 @@\n-import com.sun.hotspot.igv.layout.Cluster;\n","filename":"src\/utils\/IdealGraphVisualizer\/HierarchicalLayout\/src\/main\/java\/com\/sun\/hotspot\/igv\/hierarchicallayout\/ClusterIngoingConnection.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,5 +32,1 @@\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.HashSet;\n-import java.util.List;\n-import java.util.Set;\n+import java.util.*;\n","filename":"src\/utils\/IdealGraphVisualizer\/HierarchicalLayout\/src\/main\/java\/com\/sun\/hotspot\/igv\/hierarchicallayout\/ClusterNode.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+import com.sun.hotspot.igv.layout.Cluster;\n@@ -28,1 +29,0 @@\n-import com.sun.hotspot.igv.layout.Cluster;\n","filename":"src\/utils\/IdealGraphVisualizer\/HierarchicalLayout\/src\/main\/java\/com\/sun\/hotspot\/igv\/hierarchicallayout\/ClusterOutgoingConnection.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,8 +26,0 @@\n-import java.awt.Dimension;\n-import java.awt.Rectangle;\n-import java.awt.Canvas;\n-import java.awt.Font;\n-import java.awt.FontMetrics;\n-import java.util.*;\n-import com.sun.hotspot.igv.layout.Cluster;\n-import com.sun.hotspot.igv.layout.LayoutGraph;\n@@ -35,2 +27,3 @@\n-import com.sun.hotspot.igv.layout.Link;\n-import com.sun.hotspot.igv.layout.Vertex;\n+import com.sun.hotspot.igv.layout.*;\n+import java.awt.*;\n+import java.util.*;\n","filename":"src\/utils\/IdealGraphVisualizer\/HierarchicalLayout\/src\/main\/java\/com\/sun\/hotspot\/igv\/hierarchicallayout\/HierarchicalCFGLayoutManager.java","additions":3,"deletions":10,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+import com.sun.hotspot.igv.layout.*;\n@@ -28,12 +29,1 @@\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Set;\n-import java.util.ArrayList;\n-import java.util.HashSet;\n-import java.util.TreeSet;\n-import com.sun.hotspot.igv.layout.Cluster;\n-import com.sun.hotspot.igv.layout.LayoutGraph;\n-import com.sun.hotspot.igv.layout.LayoutManager;\n-import com.sun.hotspot.igv.layout.Link;\n-import com.sun.hotspot.igv.layout.Port;\n-import com.sun.hotspot.igv.layout.Vertex;\n+import java.util.*;\n","filename":"src\/utils\/IdealGraphVisualizer\/HierarchicalLayout\/src\/main\/java\/com\/sun\/hotspot\/igv\/hierarchicallayout\/HierarchicalClusterLayoutManager.java","additions":2,"deletions":12,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+import com.sun.hotspot.igv.layout.Cluster;\n@@ -28,1 +29,0 @@\n-import com.sun.hotspot.igv.layout.Cluster;\n","filename":"src\/utils\/IdealGraphVisualizer\/HierarchicalLayout\/src\/main\/java\/com\/sun\/hotspot\/igv\/hierarchicallayout\/InterClusterConnection.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,2 +36,0 @@\n-    public Cluster getOuter();\n-\n","filename":"src\/utils\/IdealGraphVisualizer\/Layout\/src\/main\/java\/com\/sun\/hotspot\/igv\/layout\/Cluster.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,2 +27,0 @@\n-import com.sun.hotspot.igv.data.GraphDocument;\n-import com.sun.hotspot.igv.data.serialization.BinaryParser;\n@@ -36,1 +34,0 @@\n-    private final boolean binary;\n@@ -38,1 +35,0 @@\n-    private final GraphDocument rootDocument;\n@@ -41,1 +37,1 @@\n-    public Client(SocketChannel socket, GraphDocument rootDocument, GroupCallback callback, boolean  binary) {\n+    public Client(SocketChannel socket, GroupCallback callback) {\n@@ -44,2 +40,0 @@\n-        this.binary = binary;\n-        this.rootDocument = rootDocument;\n@@ -54,7 +48,2 @@\n-            if (binary) {\n-                new BinaryParser(channel, null, rootDocument, callback).parse();\n-            } else {\n-                \/\/ signal readiness to client VM (old protocol)\n-                channel.socket().getOutputStream().write('y');\n-                new Parser(channel, null, callback).parse();\n-            }\n+            channel.socket().getOutputStream().write('y');\n+            new Parser(channel, null, callback).parse();\n","filename":"src\/utils\/IdealGraphVisualizer\/NetworkConnection\/src\/main\/java\/com\/sun\/hotspot\/igv\/connection\/Client.java","additions":3,"deletions":14,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import com.sun.hotspot.igv.data.GraphDocument;\n@@ -45,1 +44,0 @@\n-    private final boolean binary;\n@@ -47,1 +45,0 @@\n-    private final GraphDocument rootDocument;\n@@ -52,3 +49,1 @@\n-    public Server(GraphDocument rootDocument, GroupCallback callback, boolean binary) {\n-        this.binary = binary;\n-        this.rootDocument = rootDocument;\n+    public Server(GroupCallback callback) {\n@@ -62,2 +57,1 @@\n-\n-        int curPort = Integer.parseInt(Settings.get().get(binary ? Settings.PORT_BINARY : Settings.PORT, binary ? Settings.PORT_BINARY_DEFAULT : Settings.PORT_DEFAULT));\n+        int curPort = Integer.parseInt(Settings.get().get(Settings.PORT, Settings.PORT_DEFAULT));\n@@ -70,2 +64,1 @@\n-\n-        int curPort = Integer.parseInt(Settings.get().get(binary ? Settings.PORT_BINARY : Settings.PORT, binary ? Settings.PORT_BINARY_DEFAULT : Settings.PORT_DEFAULT));\n+        int curPort = Integer.parseInt(Settings.get().get(Settings.PORT, Settings.PORT_DEFAULT));\n@@ -77,1 +70,1 @@\n-            NotifyDescriptor message = new NotifyDescriptor.Message(\"Could not create server. Listening for incoming binary data is disabled.\", NotifyDescriptor.ERROR_MESSAGE);\n+            NotifyDescriptor message = new NotifyDescriptor.Message(\"Could not create server. Listening for incoming data is disabled.\", NotifyDescriptor.ERROR_MESSAGE);\n@@ -93,1 +86,1 @@\n-                        RequestProcessor.getDefault().post(new Client(clientSocket, rootDocument, callback, binary), 0, Thread.MAX_PRIORITY);\n+                        RequestProcessor.getDefault().post(new Client(clientSocket, callback), 0, Thread.MAX_PRIORITY);\n@@ -96,1 +89,1 @@\n-                        NotifyDescriptor message = new NotifyDescriptor.Message(\"Error during listening for incoming connections. Listening for incoming binary data is disabled.\", NotifyDescriptor.ERROR_MESSAGE);\n+                        NotifyDescriptor message = new NotifyDescriptor.Message(\"Error during listening for incoming connections. Listening for incoming data is disabled.\", NotifyDescriptor.ERROR_MESSAGE);\n","filename":"src\/utils\/IdealGraphVisualizer\/NetworkConnection\/src\/main\/java\/com\/sun\/hotspot\/igv\/connection\/Server.java","additions":6,"deletions":13,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -49,4 +49,4 @@\n-        selectedChangedEvent = new ChangedEvent<>(this);\n-        highlightedChangedEvent = new ChangedEvent<>(this);\n-        selectedObjects = new HashSet<>();\n-        highlightedObjects = new HashSet<>();\n+        selectedChangedEvent = new ChangedEvent<SelectionCoordinator>(this);\n+        highlightedChangedEvent = new ChangedEvent<SelectionCoordinator>(this);\n+        selectedObjects = new HashSet<Object>();\n+        highlightedObjects = new HashSet<Object>();\n@@ -71,50 +71,0 @@\n-    public void addHighlighted(Object o) {\n-        if (!highlightedObjects.contains(o)) {\n-            highlightedObjects.add(o);\n-            highlightedObjectsChanged();\n-        }\n-    }\n-\n-    public void removeHighlighted(Object o) {\n-        if (highlightedObjects.contains(o)) {\n-            highlightedObjects.remove(o);\n-            highlightedObjectsChanged();\n-        }\n-    }\n-\n-    public void addAllHighlighted(Set<? extends Object> s) {\n-        int oldSize = highlightedObjects.size();\n-        highlightedObjects.addAll(s);\n-        if (oldSize != highlightedObjects.size()) {\n-            highlightedObjectsChanged();\n-        }\n-    }\n-\n-    public void removeAllHighlighted(Set<? extends Object> s) {\n-        int oldSize = highlightedObjects.size();\n-        highlightedObjects.removeAll(s);\n-        if (oldSize != highlightedObjects.size()) {\n-            highlightedObjectsChanged();\n-        }\n-    }\n-\n-    private void highlightedObjectsChanged() {\n-        highlightedChangedEvent.fire();\n-\n-    }\n-\n-    public void addAllSelected(Set<? extends Object> s) {\n-        int oldSize = selectedObjects.size();\n-        selectedObjects.addAll(s);\n-        if (oldSize != selectedObjects.size()) {\n-            selectedObjectsChanged();\n-        }\n-    }\n-\n-    public void removeAllSelected(Set<? extends Object> s) {\n-        int oldSize = selectedObjects.size();\n-        selectedObjects.removeAll(s);\n-        if (oldSize != selectedObjects.size()) {\n-            selectedObjectsChanged();\n-        }\n-    }\n@@ -126,5 +76,1 @@\n-        selectedObjectsChanged();\n-    }\n-\n-    private void selectedObjectsChanged() {\n-        selectedChangedEvent.fire();\n+        getSelectedChangedEvent().fire();\n@@ -135,3 +81,3 @@\n-        this.highlightedObjects.clear();\n-        this.highlightedObjects.addAll(s);\n-        highlightedObjectsChanged();\n+        highlightedObjects.clear();\n+        highlightedObjects.addAll(s);\n+        getHighlightedChangedEvent().fire();\n","filename":"src\/utils\/IdealGraphVisualizer\/SelectionCoordinator\/src\/main\/java\/com\/sun\/hotspot\/igv\/selectioncoordinator\/SelectionCoordinator.java","additions":8,"deletions":62,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -27,0 +27,3 @@\n+import com.ibm.wala.util.graph.Graph;\n+import com.ibm.wala.util.graph.dominators.Dominators;\n+import com.ibm.wala.util.graph.impl.SlowSparseNumberedGraph;\n@@ -36,3 +39,0 @@\n-import com.ibm.wala.util.graph.Graph;\n-import com.ibm.wala.util.graph.impl.SlowSparseNumberedGraph;\n-import com.ibm.wala.util.graph.dominators.Dominators;\n","filename":"src\/utils\/IdealGraphVisualizer\/ServerCompiler\/src\/main\/java\/com\/sun\/hotspot\/igv\/servercompiler\/ServerCompilerScheduler.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -50,1 +50,0 @@\n-    public static final String PORT_BINARY = \"portBinary\";\n@@ -52,1 +51,0 @@\n-    public static final String PORT_BINARY_DEFAULT = \"4445\";\n","filename":"src\/utils\/IdealGraphVisualizer\/Settings\/src\/main\/java\/com\/sun\/hotspot\/igv\/settings\/Settings.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,182 +0,0 @@\n-\/*\n- * Copyright (c) 2008, 2015, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-package com.sun.hotspot.igv.util;\n-\n-import java.awt.Container;\n-import java.awt.Dimension;\n-import java.awt.Point;\n-import java.awt.Rectangle;\n-import javax.swing.JComponent;\n-import javax.swing.JScrollPane;\n-import org.netbeans.api.visual.action.WidgetAction;\n-import org.netbeans.api.visual.action.WidgetAction.State;\n-import org.netbeans.api.visual.action.WidgetAction.WidgetMouseWheelEvent;\n-import org.netbeans.api.visual.animator.SceneAnimator;\n-import org.netbeans.api.visual.widget.Scene;\n-import org.netbeans.api.visual.widget.Widget;\n-\n-\/**\n- *\n- * @author Thomas Wuerthinger\n- *\/\n-public class BoundedZoomAction extends WidgetAction.Adapter {\n-\n-    private double minFactor = 0.0;\n-    private double maxFactor = Double.MAX_VALUE;\n-    private double zoomMultiplier;\n-    private boolean useAnimator;\n-\n-    public BoundedZoomAction(double zoomMultiplier, boolean useAnimator) {\n-        this.zoomMultiplier = zoomMultiplier;\n-        this.useAnimator = useAnimator;\n-    }\n-\n-    public double getMinFactor() {\n-        return minFactor;\n-    }\n-\n-    public void setMinFactor(double d) {\n-        minFactor = d;\n-    }\n-\n-    public double getMaxFactor() {\n-        return maxFactor;\n-    }\n-\n-    public void setMaxFactor(double d) {\n-        maxFactor = d;\n-    }\n-\n-    private JScrollPane findScrollPane(JComponent component) {\n-        for (;;) {\n-            if (component == null) {\n-                return null;\n-            }\n-            if (component instanceof JScrollPane) {\n-                return ((JScrollPane) component);\n-            }\n-            Container parent = component.getParent();\n-            if (!(parent instanceof JComponent)) {\n-                return null;\n-            }\n-            component = (JComponent) parent;\n-        }\n-    }\n-\n-    @Override\n-    public State mouseWheelMoved(Widget widget, WidgetMouseWheelEvent event) {\n-        final Scene scene = widget.getScene();\n-        int amount = event.getWheelRotation();\n-        JScrollPane scrollPane = findScrollPane(scene.getView());\n-        Point viewPosition = null;\n-        Point mouseLocation = scene.convertSceneToView(event.getPoint());\n-        int xOffset = 0;\n-        int yOffset = 0;\n-        Point oldViewPosition = null;\n-        Rectangle bounds = new Rectangle(scene.getBounds());\n-        Dimension componentSize = new Dimension(scene.getView().getPreferredSize());\n-\n-        if (scrollPane != null) {\n-            viewPosition = new Point(scrollPane.getViewport().getViewPosition());\n-            oldViewPosition = new Point(viewPosition);\n-            xOffset = (mouseLocation.x - viewPosition.x);\n-            yOffset = (mouseLocation.y - viewPosition.y);\n-            viewPosition.x += xOffset;\n-            viewPosition.y += yOffset;\n-        }\n-\n-        if (useAnimator) {\n-            SceneAnimator sceneAnimator = scene.getSceneAnimator();\n-            synchronized (sceneAnimator) {\n-                double zoom = sceneAnimator.isAnimatingZoomFactor() ? sceneAnimator.getTargetZoomFactor() : scene.getZoomFactor();\n-                while (amount > 0 && zoom \/ zoomMultiplier >= minFactor && zoom \/ zoomMultiplier <= maxFactor) {\n-                    zoom \/= zoomMultiplier;\n-                    if (viewPosition != null) {\n-                        viewPosition.x \/= zoomMultiplier;\n-                        viewPosition.y \/= zoomMultiplier;\n-                        bounds.width \/= zoomMultiplier;\n-                        bounds.height \/= zoomMultiplier;\n-                        componentSize.width \/= zoomMultiplier;\n-                        componentSize.height \/= zoomMultiplier;\n-                    }\n-                    amount--;\n-                }\n-                while (amount < 0 && zoom * zoomMultiplier >= minFactor && zoom * zoomMultiplier <= maxFactor) {\n-                    zoom *= zoomMultiplier;\n-                    if (viewPosition != null) {\n-                        viewPosition.x *= zoomMultiplier;\n-                        viewPosition.y *= zoomMultiplier;\n-                        bounds.width *= zoomMultiplier;\n-                        bounds.height *= zoomMultiplier;\n-                        componentSize.width *= zoomMultiplier;\n-                        componentSize.height *= zoomMultiplier;\n-                    }\n-                    amount++;\n-                }\n-                sceneAnimator.animateZoomFactor(zoom);\n-            }\n-        } else {\n-            double zoom = scene.getZoomFactor();\n-            while (amount > 0 && zoom \/ zoomMultiplier >= minFactor && zoom \/ zoomMultiplier <= maxFactor) {\n-                zoom \/= zoomMultiplier;\n-                if (viewPosition != null) {\n-                    viewPosition.x \/= zoomMultiplier;\n-                    viewPosition.y \/= zoomMultiplier;\n-                    bounds.width \/= zoomMultiplier;\n-                    bounds.height \/= zoomMultiplier;\n-                    componentSize.width \/= zoomMultiplier;\n-                    componentSize.height \/= zoomMultiplier;\n-                }\n-                amount--;\n-            }\n-            while (amount < 0 && zoom * zoomMultiplier >= minFactor && zoom * zoomMultiplier <= maxFactor) {\n-                zoom *= zoomMultiplier;\n-                if (viewPosition != null) {\n-                    viewPosition.x *= zoomMultiplier;\n-                    viewPosition.y *= zoomMultiplier;\n-                    bounds.width *= zoomMultiplier;\n-                    bounds.height *= zoomMultiplier;\n-                    componentSize.width *= zoomMultiplier;\n-                    componentSize.height *= zoomMultiplier;\n-                }\n-                amount++;\n-            }\n-            scene.setZoomFactor(zoom);\n-        }\n-\n-        if (scrollPane != null) {\n-            scene.validate(); \/\/ Call validate to update size of scene\n-            Dimension size = scrollPane.getViewport().getExtentSize();\n-            viewPosition.x -= xOffset;\n-            viewPosition.y -= yOffset;\n-            scene.resolveBounds(scene.getLocation(), bounds);\n-            scene.getView().setPreferredSize(componentSize);\n-            scene.getView().revalidate();\n-            scene.getView().addNotify();\n-            scrollPane.getViewport().setViewPosition(viewPosition);\n-        }\n-\n-        return WidgetAction.State.CONSUMED;\n-    }\n-}\n","filename":"src\/utils\/IdealGraphVisualizer\/Util\/src\/main\/java\/com\/sun\/hotspot\/igv\/util\/BoundedZoomAction.java","additions":0,"deletions":182,"binary":false,"changes":182,"status":"deleted"},{"patch":"@@ -1,208 +0,0 @@\n-\/*\n- * Copyright (c) 2008, 2015, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-package com.sun.hotspot.igv.util;\n-\n-import java.awt.*;\n-import java.awt.event.*;\n-import javax.swing.JComponent;\n-import org.netbeans.api.visual.widget.Scene;\n-\n-\/**\n- * @author David Kaspar\n- * @author Thomas Wuerthinger\n- *\/\n-public class ExtendedSatelliteComponent extends JComponent implements MouseListener, MouseMotionListener, Scene.SceneListener, ComponentListener {\n-\n-    private Scene scene;\n-    private Image image;\n-    private int imageWidth;\n-    private int imageHeight;\n-\n-    public ExtendedSatelliteComponent(Scene scene) {\n-        this.scene = scene;\n-        setDoubleBuffered(true);\n-        setPreferredSize(new Dimension(128, 128));\n-        addMouseListener(this);\n-        addMouseMotionListener(this);\n-    }\n-\n-    @Override\n-    public void addNotify() {\n-        super.addNotify();\n-        scene.addSceneListener(this);\n-        JComponent viewComponent = scene.getView();\n-        if (viewComponent == null) {\n-            viewComponent = scene.createView();\n-        }\n-        viewComponent.addComponentListener(this);\n-        repaint();\n-    }\n-\n-    @Override\n-    public void removeNotify() {\n-        scene.getView().removeComponentListener(this);\n-        scene.removeSceneListener(this);\n-        super.removeNotify();\n-    }\n-\n-    public void update() {\n-        this.image = null;\n-        repaint();\n-    }\n-\n-    @Override\n-    public void paint(Graphics g) {\n-        Graphics2D gr = (Graphics2D) g;\n-        super.paint(g);\n-        Rectangle bounds = scene.getBounds();\n-        Dimension size = getSize();\n-\n-        double sx = bounds.width > 0 ? (double) size.width \/ bounds.width : 0.0;\n-        double sy = bounds.width > 0 ? (double) size.height \/ bounds.height : 0.0;\n-        double scale = Math.min(sx, sy);\n-\n-        int vw = (int) (scale * bounds.width);\n-        int vh = (int) (scale * bounds.height);\n-        int vx = (size.width - vw) \/ 2;\n-        int vy = (size.height - vh) \/ 2;\n-\n-\n-        if (image == null || vw != imageWidth || vh != imageHeight) {\n-\n-            imageWidth = vw;\n-            imageHeight = vh;\n-            image = this.createImage(imageWidth, imageHeight);\n-            Graphics2D ig = (Graphics2D) image.getGraphics();\n-            ig.scale(scale, scale);\n-            scene.paint(ig);\n-        }\n-\n-        gr.drawImage(image, vx, vy, this);\n-\n-        JComponent component = scene.getView();\n-        double zoomFactor = scene.getZoomFactor();\n-        Rectangle viewRectangle = component != null ? component.getVisibleRect() : null;\n-        if (viewRectangle != null) {\n-            Rectangle window = new Rectangle(\n-                    (int) ((double) viewRectangle.x * scale \/ zoomFactor),\n-                    (int) ((double) viewRectangle.y * scale \/ zoomFactor),\n-                    (int) ((double) viewRectangle.width * scale \/ zoomFactor),\n-                    (int) ((double) viewRectangle.height * scale \/ zoomFactor));\n-            window.translate(vx, vy);\n-            gr.setColor(new Color(200, 200, 200, 128));\n-            gr.fill(window);\n-            gr.setColor(Color.BLACK);\n-            gr.drawRect(window.x, window.y, window.width - 1, window.height - 1);\n-        }\n-    }\n-\n-    @Override\n-    public void mouseClicked(MouseEvent e) {\n-    }\n-\n-    @Override\n-    public void mousePressed(MouseEvent e) {\n-        moveVisibleRect(e.getPoint());\n-    }\n-\n-    @Override\n-    public void mouseReleased(MouseEvent e) {\n-        moveVisibleRect(e.getPoint());\n-    }\n-\n-    @Override\n-    public void mouseEntered(MouseEvent e) {\n-    }\n-\n-    @Override\n-    public void mouseExited(MouseEvent e) {\n-    }\n-\n-    @Override\n-    public void mouseDragged(MouseEvent e) {\n-        moveVisibleRect(e.getPoint());\n-    }\n-\n-    @Override\n-    public void mouseMoved(MouseEvent e) {\n-    }\n-\n-    private void moveVisibleRect(Point center) {\n-        JComponent component = scene.getView();\n-        if (component == null) {\n-            return;\n-        }\n-        double zoomFactor = scene.getZoomFactor();\n-        Rectangle bounds = scene.getBounds();\n-        Dimension size = getSize();\n-\n-        double sx = bounds.width > 0 ? (double) size.width \/ bounds.width : 0.0;\n-        double sy = bounds.width > 0 ? (double) size.height \/ bounds.height : 0.0;\n-        double scale = Math.min(sx, sy);\n-\n-        int vw = (int) (scale * bounds.width);\n-        int vh = (int) (scale * bounds.height);\n-        int vx = (size.width - vw) \/ 2;\n-        int vy = (size.height - vh) \/ 2;\n-\n-        int cx = (int) ((double) (center.x - vx) \/ scale * zoomFactor);\n-        int cy = (int) ((double) (center.y - vy) \/ scale * zoomFactor);\n-\n-        Rectangle visibleRect = component.getVisibleRect();\n-        visibleRect.x = cx - visibleRect.width \/ 2;\n-        visibleRect.y = cy - visibleRect.height \/ 2;\n-        component.scrollRectToVisible(visibleRect);\n-\n-    }\n-\n-    @Override\n-    public void sceneRepaint() {\n-    }\n-\n-    @Override\n-    public void sceneValidating() {\n-    }\n-\n-    @Override\n-    public void sceneValidated() {\n-    }\n-\n-    @Override\n-    public void componentResized(ComponentEvent e) {\n-        repaint();\n-    }\n-\n-    @Override\n-    public void componentMoved(ComponentEvent e) {\n-        repaint();\n-    }\n-\n-    @Override\n-    public void componentShown(ComponentEvent e) {\n-    }\n-\n-    @Override\n-    public void componentHidden(ComponentEvent e) {\n-    }\n-}\n","filename":"src\/utils\/IdealGraphVisualizer\/Util\/src\/main\/java\/com\/sun\/hotspot\/igv\/util\/ExtendedSatelliteComponent.java","additions":0,"deletions":208,"binary":false,"changes":208,"status":"deleted"},{"patch":"@@ -29,1 +29,0 @@\n-import com.sun.hotspot.igv.util.StringUtils;\n","filename":"src\/utils\/IdealGraphVisualizer\/Util\/src\/main\/java\/com\/sun\/hotspot\/igv\/util\/PropertiesConverter.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import java.awt.geom.*;\n@@ -33,0 +32,2 @@\n+import java.awt.geom.Ellipse2D;\n+import java.awt.geom.Rectangle2D;\n@@ -34,1 +35,4 @@\n-import javax.swing.*;\n+import javax.swing.JComponent;\n+import javax.swing.JViewport;\n+import javax.swing.Scrollable;\n+import javax.swing.SwingConstants;\n@@ -58,1 +62,4 @@\n-    private RangeSliderModel tempModel;\n+    private boolean tempModel = false;\n+    private int tempFirstPos;\n+    private int tempSecondPos;\n+\n@@ -69,1 +76,1 @@\n-    public RangeSlider() {\n+    public RangeSlider(RangeSliderModel newModel) {\n@@ -73,7 +80,0 @@\n-    }\n-\n-    public void setModel(RangeSliderModel newModel) {\n-        if (model != null) {\n-            model.getChangedEvent().removeListener(this);\n-            model.getColorChangedEvent().removeListener(this);\n-        }\n@@ -88,3 +88,3 @@\n-    private RangeSliderModel getPaintingModel() {\n-        if (tempModel != null) {\n-            return tempModel;\n+    private int getFirstPos() {\n+        if (tempModel) {\n+            return tempFirstPos;\n@@ -92,1 +92,8 @@\n-        return model;\n+        return model.getFirstPosition();\n+    }\n+\n+    private int getSecondPos() {\n+        if (tempModel) {\n+            return tempSecondPos;\n+        }\n+        return model.getSecondPosition();\n@@ -136,1 +143,1 @@\n-        d.width = Math.max(d.width, (int)(2 * BAR_CIRCLE_CONNECTOR_SIZE + getPaintingModel().getPositions().size() * (BAR_CIRCLE_SIZE + BAR_CIRCLE_CONNECTOR_SIZE)));\n+        d.width = Math.max(d.width, (int)(2 * BAR_CIRCLE_CONNECTOR_SIZE + model.getPositions().size() * (BAR_CIRCLE_SIZE + BAR_CIRCLE_CONNECTOR_SIZE)));\n@@ -143,1 +150,0 @@\n-\n@@ -158,1 +164,1 @@\n-        assert index >= 0 && index < getPaintingModel().getPositions().size();\n+        assert index >= 0 && index < model.getPositions().size();\n@@ -163,1 +169,1 @@\n-        int size = getPaintingModel().getPositions().size();\n+        int size = model.getPositions().size();\n@@ -189,1 +195,1 @@\n-        if (getPaintingModel() == null || getPaintingModel().getPositions().size() == 0) {\n+        if (model == null || model.getPositions().size() == 0) {\n@@ -193,2 +199,2 @@\n-        int firstPos = getPaintingModel().getFirstPosition();\n-        int secondPos = getPaintingModel().getSecondPosition();\n+        int firstPos = getFirstPos();\n+        int secondPos = getSecondPos();\n@@ -206,1 +212,1 @@\n-        List<String> list = getPaintingModel().getPositions();\n+        List<String> list = model.getPositions();\n@@ -215,1 +221,1 @@\n-            g.setColor(getPaintingModel().getColors().get(i));\n+            g.setColor(model.getColors().get(i));\n@@ -261,1 +267,1 @@\n-            float destX = getEndXPosition(getPaintingModel().getSecondPosition());\n+            float destX = getEndXPosition(getSecondPos());\n@@ -270,1 +276,1 @@\n-            float destX = getStartXPosition(getPaintingModel().getFirstPosition());\n+            float destX = getStartXPosition(getFirstPos());\n@@ -279,1 +285,1 @@\n-            return p.x > getStartXPosition(getPaintingModel().getFirstPosition()) && p.x < getEndXPosition(getPaintingModel().getSecondPosition());\n+            return p.x > getStartXPosition(getFirstPos()) && p.x < getEndXPosition(getSecondPos());\n@@ -292,3 +298,3 @@\n-            int newIndex = getIndexFromPosition(newFirstX) + 1;\n-            if (newIndex + model.getSecondPosition() - model.getFirstPosition() >= model.getPositions().size()) {\n-                newIndex = model.getPositions().size() - (model.getSecondPosition() - model.getFirstPosition()) - 1;\n+            tempFirstPos = getIndexFromPosition(newFirstX) + 1;\n+            if (tempFirstPos + model.getSecondPosition() - model.getFirstPosition() >= model.getPositions().size()) {\n+                tempFirstPos = model.getPositions().size() - (model.getSecondPosition() - model.getFirstPosition()) - 1;\n@@ -296,2 +302,1 @@\n-            int secondPosition = newIndex + model.getSecondPosition() - model.getFirstPosition();\n-            tempModel.setPositions(newIndex, secondPosition);\n+            tempSecondPos = tempFirstPos + model.getSecondPosition() - model.getFirstPosition();\n@@ -300,4 +305,4 @@\n-            int firstPosition = getIndexFromPosition(e.getPoint().x) + 1;\n-            int secondPosition = model.getSecondPosition();\n-            if (firstPosition > secondPosition) {\n-                firstPosition--;\n+            tempFirstPos = getIndexFromPosition(e.getPoint().x) + 1;\n+            tempSecondPos = model.getSecondPosition();\n+            if (tempFirstPos > tempSecondPos) {\n+                tempFirstPos--;\n@@ -305,1 +310,0 @@\n-            tempModel.setPositions(firstPosition, secondPosition);\n@@ -308,4 +312,4 @@\n-            int firstPosition = model.getFirstPosition();\n-            int secondPosition = getIndexFromPosition(e.getPoint().x);\n-            if (secondPosition < firstPosition) {\n-                secondPosition++;\n+            tempFirstPos = model.getFirstPosition();\n+            tempSecondPos = getIndexFromPosition(e.getPoint().x);\n+            if (tempSecondPos < tempFirstPos) {\n+                tempSecondPos++;\n@@ -313,1 +317,0 @@\n-            tempModel.setPositions(firstPosition, secondPosition);\n@@ -322,1 +325,1 @@\n-        for (int i = 0; i < getPaintingModel().getPositions().size() - 1; i++) {\n+        for (int i = 0; i < model.getPositions().size() - 1; i++) {\n@@ -329,1 +332,1 @@\n-        return getPaintingModel().getPositions().size() - 1;\n+        return model.getPositions().size() - 1;\n@@ -334,1 +337,1 @@\n-        for (int i = 1; i < getPaintingModel().getPositions().size(); i++) {\n+        for (int i = 1; i < model.getPositions().size(); i++) {\n@@ -348,2 +351,0 @@\n-\n-\n@@ -389,1 +390,1 @@\n-        tempModel = model.copy();\n+        tempModel = true;\n@@ -394,1 +395,1 @@\n-        if (model == null || tempModel == null) {\n+        if (model == null || tempModel == false) {\n@@ -398,2 +399,2 @@\n-        model.setPositions(tempModel.getFirstPosition(), tempModel.getSecondPosition());\n-        tempModel = null;\n+        model.setPositions(tempFirstPos, tempSecondPos);\n+        tempModel = false;\n@@ -403,2 +404,1 @@\n-    public void mouseEntered(MouseEvent e) {\n-    }\n+    public void mouseEntered(MouseEvent e) { }\n","filename":"src\/utils\/IdealGraphVisualizer\/Util\/src\/main\/java\/com\/sun\/hotspot\/igv\/util\/RangeSlider.java","additions":53,"deletions":53,"binary":false,"changes":106,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-import com.sun.hotspot.igv.data.InputGraph;\n@@ -28,0 +27,1 @@\n+import com.sun.hotspot.igv.data.InputGraph;\n@@ -32,1 +32,0 @@\n-import java.util.List;\n@@ -34,0 +33,1 @@\n+import java.util.List;\n@@ -93,1 +93,1 @@\n-                                comp.getDiagramModel().selectGraph(theGraph);\n+                                comp.getModel().selectGraph(theGraph);\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/BlockQuickSearch.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1,175 +0,0 @@\n-\/*\n- * Copyright (c) 2008, 2015, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-package com.sun.hotspot.igv.view;\n-\n-import java.awt.Container;\n-import java.awt.Dimension;\n-import java.awt.Point;\n-import java.awt.Rectangle;\n-import javax.swing.JComponent;\n-import javax.swing.JScrollPane;\n-import org.netbeans.api.visual.action.WidgetAction;\n-import org.netbeans.api.visual.action.WidgetAction.State;\n-import org.netbeans.api.visual.action.WidgetAction.WidgetMouseWheelEvent;\n-import org.netbeans.api.visual.animator.SceneAnimator;\n-import org.netbeans.api.visual.widget.Scene;\n-import org.netbeans.api.visual.widget.Widget;\n-\n-\/**\n- *\n- * @author Thomas Wuerthinger\n- *\/\n-public class BoundedZoomAction extends WidgetAction.Adapter {\n-\n-    private double minFactor = 0.0;\n-    private double maxFactor = Double.MAX_VALUE;\n-    private double zoomMultiplier;\n-    private boolean useAnimator;\n-\n-    public BoundedZoomAction(double zoomMultiplier, boolean useAnimator) {\n-        assert zoomMultiplier > 1.0;\n-        this.zoomMultiplier = zoomMultiplier;\n-        this.useAnimator = useAnimator;\n-    }\n-\n-    public double getMinFactor() {\n-        return minFactor;\n-    }\n-\n-    public void setMinFactor(double d) {\n-        minFactor = d;\n-    }\n-\n-    public double getMaxFactor() {\n-        return maxFactor;\n-    }\n-\n-    public void setMaxFactor(double d) {\n-        maxFactor = d;\n-    }\n-\n-    private JScrollPane findScrollPane(JComponent component) {\n-        for (;;) {\n-            if (component == null) {\n-                return null;\n-            }\n-            if (component instanceof JScrollPane) {\n-                return ((JScrollPane) component);\n-            }\n-            Container parent = component.getParent();\n-            if (!(parent instanceof JComponent)) {\n-                return null;\n-            }\n-            component = (JComponent) parent;\n-        }\n-    }\n-\n-    @Override\n-    public State mouseWheelMoved(Widget widget, WidgetMouseWheelEvent event) {\n-        final Scene scene = widget.getScene();\n-        int amount = event.getWheelRotation();\n-        JScrollPane scrollPane = findScrollPane(scene.getView());\n-        Point viewPosition = null;\n-        Point mouseLocation = scene.convertSceneToView(event.getPoint());\n-        int xOffset = 0;\n-        int yOffset = 0;\n-        Rectangle bounds = new Rectangle(scene.getBounds());\n-        Dimension componentSize = new Dimension(scene.getView().getPreferredSize());\n-        if (scrollPane != null) {\n-            viewPosition = new Point(scrollPane.getViewport().getViewPosition());\n-            xOffset = (mouseLocation.x - viewPosition.x);\n-            yOffset = (mouseLocation.y - viewPosition.y);\n-            viewPosition.x += xOffset;\n-            viewPosition.y += yOffset;\n-        }\n-\n-        if (useAnimator) {\n-            SceneAnimator sceneAnimator = scene.getSceneAnimator();\n-            synchronized (sceneAnimator) {\n-                double zoom = sceneAnimator.isAnimatingZoomFactor() ? sceneAnimator.getTargetZoomFactor() : scene.getZoomFactor();\n-                while (amount > 0 && zoom \/ zoomMultiplier >= minFactor) {\n-                    zoom \/= zoomMultiplier;\n-                    if (viewPosition != null) {\n-                        viewPosition.x \/= zoomMultiplier;\n-                        viewPosition.y \/= zoomMultiplier;\n-                        bounds.width \/= zoomMultiplier;\n-                        bounds.height \/= zoomMultiplier;\n-                        componentSize.width \/= zoomMultiplier;\n-                        componentSize.height \/= zoomMultiplier;\n-                    }\n-                    amount--;\n-                }\n-                while (amount < 0 && zoom * zoomMultiplier <= maxFactor) {\n-                    zoom *= zoomMultiplier;\n-                    if (viewPosition != null) {\n-                        viewPosition.x *= zoomMultiplier;\n-                        viewPosition.y *= zoomMultiplier;\n-                        bounds.width *= zoomMultiplier;\n-                        bounds.height *= zoomMultiplier;\n-                        componentSize.width *= zoomMultiplier;\n-                        componentSize.height *= zoomMultiplier;\n-                    }\n-                    amount++;\n-                }\n-                sceneAnimator.animateZoomFactor(zoom);\n-            }\n-        } else {\n-            double zoom = scene.getZoomFactor();\n-            while (amount > 0 && zoom \/ zoomMultiplier >= minFactor) {\n-                zoom \/= zoomMultiplier;\n-                if (viewPosition != null) {\n-                    viewPosition.x \/= zoomMultiplier;\n-                    viewPosition.y \/= zoomMultiplier;\n-                    bounds.width \/= zoomMultiplier;\n-                    bounds.height \/= zoomMultiplier;\n-                    componentSize.width \/= zoomMultiplier;\n-                    componentSize.height \/= zoomMultiplier;\n-                }\n-                amount--;\n-            }\n-            while (amount < 0 && zoom * zoomMultiplier <= maxFactor) {\n-                zoom *= zoomMultiplier;\n-                if (viewPosition != null) {\n-                    viewPosition.x *= zoomMultiplier;\n-                    viewPosition.y *= zoomMultiplier;\n-                    bounds.width *= zoomMultiplier;\n-                    bounds.height *= zoomMultiplier;\n-                    componentSize.width *= zoomMultiplier;\n-                    componentSize.height *= zoomMultiplier;\n-                }\n-                amount++;\n-            }\n-            scene.setZoomFactor(zoom);\n-        }\n-\n-        if (scrollPane != null) {\n-            viewPosition.x -= xOffset;\n-            viewPosition.y -= yOffset;\n-            scrollPane.getViewport().setViewPosition(viewPosition);\n-        }\n-\n-\n-        return WidgetAction.State.CONSUMED;\n-    }\n-}\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/BoundedZoomAction.java","additions":0,"deletions":175,"binary":false,"changes":175,"status":"deleted"},{"patch":"@@ -26,5 +26,0 @@\n-import com.sun.hotspot.igv.data.ChangedListener;\n-import com.sun.hotspot.igv.data.ControllableChangedListener;\n-import com.sun.hotspot.igv.data.InputBlock;\n-import com.sun.hotspot.igv.data.InputNode;\n-import com.sun.hotspot.igv.data.Pair;\n@@ -32,1 +27,1 @@\n-import com.sun.hotspot.igv.data.services.Scheduler;\n+import com.sun.hotspot.igv.data.*;\n@@ -34,1 +29,0 @@\n-import com.sun.hotspot.igv.hierarchicallayout.HierarchicalClusterLayoutManager;\n@@ -36,1 +30,1 @@\n-import com.sun.hotspot.igv.hierarchicallayout.LinearLayoutManager;\n+import com.sun.hotspot.igv.hierarchicallayout.HierarchicalClusterLayoutManager;\n@@ -38,0 +32,1 @@\n+import com.sun.hotspot.igv.hierarchicallayout.LinearLayoutManager;\n@@ -39,1 +34,0 @@\n-import com.sun.hotspot.igv.layout.Link;\n@@ -46,1 +40,0 @@\n-import com.sun.hotspot.igv.view.EditorTopComponent;\n@@ -49,1 +42,3 @@\n-import java.awt.event.*;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.KeyEvent;\n+import java.awt.event.MouseEvent;\n@@ -68,0 +63,1 @@\n+import org.openide.util.Utilities;\n@@ -70,1 +66,0 @@\n-import org.openide.util.Utilities;\n@@ -147,9 +142,0 @@\n-    private static boolean intersects(Set<? extends Object> s1, Set<? extends Object> s2) {\n-        for (Object o : s1) {\n-            if (s2.contains(o)) {\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n-\n@@ -167,1 +153,0 @@\n-\n@@ -187,1 +172,0 @@\n-\n@@ -196,2 +180,2 @@\n-        for (Figure f : getModel().getDiagramToView().getFigures()) {\n-            if (intersects(f.getSource().getSourceNodesAsSet(), set)) {\n+        for (Figure f : getModel().getDiagram().getFigures()) {\n+            if (set.contains(f.getInputNode().getId())) {\n@@ -202,1 +186,1 @@\n-                if (intersects(s.getSource().getSourceNodesAsSet(), set)) {\n+                if (!Collections.disjoint(s.getSource().getSourceNodesAsSet(), set)) {\n@@ -241,1 +225,1 @@\n-            for (Figure f : getModel().getDiagramToView().getFigures()) {\n+            for (Figure f : getModel().getDiagram().getFigures()) {\n@@ -269,1 +253,1 @@\n-    public Point getScrollPosition() {\n+    private Point getScrollPosition() {\n@@ -273,1 +257,1 @@\n-    public void setScrollPosition(Point p) {\n+    private void setScrollPosition(Point p) {\n@@ -334,1 +318,1 @@\n-                    nodeSelection.addAll(((Figure) o).getSource().getSourceNodesAsSet());\n+                    nodeSelection.add(((Figure) o).getInputNode().getId());\n@@ -353,1 +337,1 @@\n-                    nodeHighlighting.addAll(((Figure) o).getSource().getSourceNodesAsSet());\n+                    nodeHighlighting.add(((Figure) o).getInputNode().getId());\n@@ -468,1 +452,1 @@\n-    public JScrollPane getScrollPane() {\n+    private JScrollPane getScrollPane() {\n@@ -523,1 +507,1 @@\n-    public void setNewModel(DiagramViewModel model) {\n+    private void setNewModel(DiagramViewModel model) {\n@@ -546,1 +530,1 @@\n-        Diagram d = getModel().getDiagramToView();\n+        Diagram d = getModel().getDiagram();\n@@ -549,1 +533,1 @@\n-        for (InputBlock b : d.getGraph().getBlocks()) {\n+        for (InputBlock b : d.getInputBlocks()) {\n@@ -556,2 +540,2 @@\n-            if (f.getWidth() > maxWidth.get(f.getBlock())) {\n-                maxWidth.put(f.getBlock(), f.getWidth());\n+            if (f.getWidth() > maxWidth.get(f.getBlock().getInputBlock())) {\n+                maxWidth.put(f.getBlock().getInputBlock(), f.getWidth());\n@@ -562,1 +546,0 @@\n-\n@@ -565,1 +548,1 @@\n-                f.setWidth(maxWidth.get(f.getBlock()));\n+                f.setWidth(maxWidth.get(f.getBlock().getInputBlock()));\n@@ -594,1 +577,1 @@\n-            for (InputBlock bn : d.getGraph().getBlocks()) {\n+            for (InputBlock bn : d.getInputBlocks()) {\n@@ -606,1 +589,1 @@\n-    public boolean isRebuilding() {\n+    protected boolean isRebuilding() {\n@@ -638,1 +621,1 @@\n-        Diagram diagram = getModel().getDiagramToView();\n+        Diagram diagram = getModel().getDiagram();\n@@ -685,1 +668,1 @@\n-        Diagram diagram = getModel().getDiagramToView();\n+        Diagram diagram = getModel().getDiagram();\n@@ -696,1 +679,1 @@\n-            InputNode n = f.getFirstSourceNode();\n+            InputNode n = f.getInputNode();\n@@ -707,1 +690,1 @@\n-        for (InputBlock b : getModel().getGraphToView().getBlocks()) {\n+        for (InputBlock b : diagram.getInputBlocks()) {\n@@ -738,1 +721,1 @@\n-        Diagram diagram = getModel().getDiagramToView();\n+        Diagram diagram = getModel().getDiagram();\n@@ -942,1 +925,0 @@\n-                this.addObject(new ConnectionSet(connectionList), w);\n@@ -957,13 +939,0 @@\n-    private class ConnectionSet {\n-\n-        private Set<Connection> connections;\n-\n-        public ConnectionSet(Collection<Connection> connections) {\n-            connections = new HashSet<>(connections);\n-        }\n-\n-        public Set<Connection> getConnectionSet() {\n-            return Collections.unmodifiableSet(connections);\n-        }\n-    }\n-\n@@ -975,11 +944,1 @@\n-    @Override\n-    public void initialize() {\n-        Figure f = getModel().getDiagramToView().getRootFigure();\n-        if (f != null) {\n-            setUndoRedoEnabled(false);\n-            gotoFigure(f);\n-            setUndoRedoEnabled(true);\n-        }\n-    }\n-\n-    public void gotoFigures(final List<Figure> figures) {\n+    private void gotoFigures(final List<Figure> figures) {\n@@ -1008,1 +967,1 @@\n-    public void gotoBlock(final Block block) {\n+    private void gotoBlock(final Block block) {\n@@ -1018,2 +977,2 @@\n-        for (Figure f : getModel().getDiagramToView().getFigures()) {\n-            if (DiagramScene.doesIntersect(f.getSource().getSourceNodesAsSet(), ids)) {\n+        for (Figure f : getModel().getDiagram().getFigures()) {\n+            if (ids.contains(f.getInputNode().getId())) {\n@@ -1024,1 +983,1 @@\n-                if (DiagramScene.doesIntersect(s.getSource().getSourceNodesAsSet(), ids)) {\n+                if (!Collections.disjoint(s.getSource().getSourceNodesAsSet(), ids)) {\n@@ -1032,1 +991,1 @@\n-    public void gotoSelection(Set<Object> ids) {\n+    private void gotoSelection(Set<Object> ids) {\n@@ -1037,1 +996,1 @@\n-        this.getModel().showNot(hiddenNodes);\n+        this.getModel().setHiddenNodes(hiddenNodes);\n@@ -1091,1 +1050,0 @@\n-            Point p = getScrollPane().getViewport().getViewPosition();\n@@ -1123,4 +1081,2 @@\n-        for (Integer n : f.getSource().getSourceNodesAsSet()) {\n-            if (getModel().getHiddenNodes().contains(n)) {\n-                return false;\n-            }\n+        if (getModel().getHiddenNodes().contains(f.getInputNode().getId())) {\n+            return false;\n@@ -1131,16 +1087,0 @@\n-    public static boolean doesIntersect(Set<?> s1, Set<?> s2) {\n-        if (s1.size() > s2.size()) {\n-            Set<?> tmp = s1;\n-            s1 = s2;\n-            s2 = tmp;\n-        }\n-\n-        for (Object o : s1) {\n-            if (s2.contains(o)) {\n-                return true;\n-            }\n-        }\n-\n-        return false;\n-    }\n-\n@@ -1161,1 +1101,1 @@\n-        Diagram diagram = getModel().getDiagramToView();\n+        Diagram diagram = getModel().getDiagram();\n@@ -1175,1 +1115,1 @@\n-            for (InputBlock b : diagram.getGraph().getBlocks()) {\n+            for (InputBlock b : diagram.getInputBlocks()) {\n@@ -1184,2 +1124,0 @@\n-            boolean hiddenAfter = doesIntersect(f.getSource().getSourceNodesAsSet(), newHiddenNodes);\n-\n@@ -1188,7 +1126,1 @@\n-            if (!hiddenAfter) {\n-                \/\/ Figure is shown\n-                w.setVisible(true);\n-                for (InputNode n : f.getSource().getSourceNodes()) {\n-                    visibleBlocks.add(diagram.getGraph().getBlock(n));\n-                }\n-            } else {\n+            if (newHiddenNodes.contains(f.getInputNode().getId())) {\n@@ -1197,0 +1129,4 @@\n+            } else {\n+                \/\/ Figure is shown\n+                w.setVisible(true);\n+                visibleBlocks.add(f.getBlock().getInputBlock());\n@@ -1219,3 +1155,1 @@\n-                        for (InputNode n : f.getSource().getSourceNodes()) {\n-                            visibleBlocks.add(diagram.getGraph().getBlock(n));\n-                        }\n+                        visibleBlocks.add(f.getBlock().getInputBlock());\n@@ -1237,1 +1171,1 @@\n-                if (f.getBlock().isArtificial()) {\n+                if (f.getBlock().getInputBlock().isArtificial()) {\n@@ -1244,1 +1178,1 @@\n-                visibleBlocks.addAll(diagram.getGraph().getBlocks());\n+                visibleBlocks.addAll(diagram.getInputBlocks());\n@@ -1249,1 +1183,1 @@\n-            for (InputBlock b : diagram.getGraph().getBlocks()) {\n+            for (InputBlock b : diagram.getInputBlocks()) {\n@@ -1276,14 +1210,2 @@\n-        newHiddenNodes.removeAll(f.getSource().getSourceNodesAsSet());\n-        this.model.setHiddenNodes(newHiddenNodes);\n-    }\n-\n-    public void show(final Figure f) {\n-        showFigure(f);\n-    }\n-\n-    public void setSelectedObjects(Object... args) {\n-        Set<Object> set = new HashSet<>();\n-        for (Object o : args) {\n-            set.add(o);\n-        }\n-        super.setSelectedObjects(set);\n+        newHiddenNodes.remove(f.getInputNode().getId());\n+        this.getModel().setHiddenNodes(newHiddenNodes);\n@@ -1386,1 +1308,1 @@\n-    public void setUndoRedoEnabled(boolean b) {\n+    private void setUndoRedoEnabled(boolean b) {\n@@ -1390,1 +1312,1 @@\n-    public boolean getUndoRedoEnabled() {\n+    private boolean getUndoRedoEnabled() {\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/DiagramScene.java","additions":53,"deletions":131,"binary":false,"changes":184,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import com.sun.hotspot.igv.data.Properties;\n@@ -38,0 +39,1 @@\n+import java.util.*;\n@@ -39,7 +41,0 @@\n-import java.util.Arrays;\n-import java.util.ArrayList;\n-import java.util.Collection;\n-import java.util.HashSet;\n-import java.util.Iterator;\n-import java.util.List;\n-import java.util.Set;\n@@ -57,1 +52,0 @@\n-    private Set<Integer> onScreenNodes;\n@@ -62,1 +56,1 @@\n-    private InputGraph inputGraph;\n+    private InputGraph cachedInputGraph;\n@@ -73,1 +67,0 @@\n-    private boolean hideDuplicates;\n@@ -78,1 +71,1 @@\n-            diagramChanged();\n+            updateDiagram();\n@@ -84,1 +77,1 @@\n-        DiagramViewModel result = new DiagramViewModel(group, filterChain, sequenceFilterChain);\n+        DiagramViewModel result = new DiagramViewModel(cachedInputGraph, filterChain, sequenceFilterChain);\n@@ -99,1 +92,1 @@\n-        boolean groupChanged = (group == newModel.group);\n+        boolean groupChanged = (group != newModel.group);\n@@ -113,2 +106,0 @@\n-        viewChanged |= (onScreenNodes != newModel.onScreenNodes);\n-        this.onScreenNodes = newModel.onScreenNodes;\n@@ -186,22 +177,1 @@\n-    public boolean getHideDuplicates() {\n-        return hideDuplicates;\n-    }\n-\n-    public void setHideDuplicates(boolean b) {\n-        System.err.println(\"setHideDuplicates: \" + b);\n-        hideDuplicates = b;\n-        InputGraph currentGraph = getFirstGraph();\n-        if (hideDuplicates) {\n-            \/\/ Back up to the unhidden equivalent graph\n-            int index = graphs.indexOf(currentGraph);\n-            while (graphs.get(index).getProperties().get(\"_isDuplicate\") != null) {\n-                index--;\n-            }\n-            currentGraph = graphs.get(index);\n-        }\n-        filterGraphs();\n-        selectGraph(currentGraph);\n-        viewPropertiesChangedEvent.fire();\n-    }\n-\n-    public DiagramViewModel(Group g, FilterChain filterChain, FilterChain sequenceFilterChain) {\n+    public DiagramViewModel(InputGraph graph, FilterChain filterChain, FilterChain sequenceFilterChain) {\n@@ -215,1 +185,1 @@\n-        this.group = g;\n+        this.group = graph.getGroup();\n@@ -222,1 +192,0 @@\n-        onScreenNodes = new HashSet<>();\n@@ -236,0 +205,2 @@\n+\n+        selectGraph(graph);\n@@ -289,4 +260,0 @@\n-    public Set<Integer> getOnScreenNodes() {\n-        return onScreenNodes;\n-    }\n-\n@@ -334,4 +301,0 @@\n-    public void showNot(final Set<Integer> nodes) {\n-        setHiddenNodes(nodes);\n-    }\n-\n@@ -341,1 +304,1 @@\n-            newHiddenNodes.removeAll(fig.getSource().getSourceNodesAsSet());\n+            newHiddenNodes.remove(fig.getInputNode().getId());\n@@ -350,4 +313,2 @@\n-            for (InputNode node : f.getSource().getSourceNodes()) {\n-                if (getSelectedNodes().contains(node.getId())) {\n-                    result.add(f);\n-                }\n+            if (getSelectedNodes().contains(f.getInputNode().getId())) {\n+                result.add(f);\n@@ -364,1 +325,1 @@\n-        final HashSet<Integer> allNodes = new HashSet<>(getGraphToView().getGroup().getAllNodes());\n+        final HashSet<Integer> allNodes = new HashSet<>(getGroup().getAllNodes());\n@@ -374,5 +335,0 @@\n-    public void setOnScreenNodes(Set<Integer> onScreenNodes) {\n-        this.onScreenNodes = onScreenNodes;\n-        viewChangedEvent.fire();\n-    }\n-\n@@ -383,9 +339,1 @@\n-    public void setSequenceFilterChain(FilterChain chain) {\n-        assert chain != null : \"sequenceFilterChain must never be null\";\n-        sequenceFilterChain.getChangedEvent().removeListener(filterChainChangedListener);\n-        sequenceFilterChain = chain;\n-        sequenceFilterChain.getChangedEvent().addListener(filterChainChangedListener);\n-        diagramChanged();\n-    }\n-\n-    private void diagramChanged() {\n+    private void updateDiagram() {\n@@ -393,2 +341,20 @@\n-        diagram = null;\n-        getDiagramChangedEvent().fire();\n+        InputGraph graph = getGraph();\n+        if (graph.getBlocks().isEmpty()) {\n+            Scheduler s = Lookup.getDefault().lookup(Scheduler.class);\n+            graph.clearBlocks();\n+            s.schedule(graph);\n+            graph.ensureNodesInBlocks();\n+        }\n+        diagram = new Diagram(graph,\n+                Settings.get().get(Settings.NODE_TEXT, Settings.NODE_TEXT_DEFAULT),\n+                Settings.get().get(Settings.NODE_SHORT_TEXT, Settings.NODE_SHORT_TEXT_DEFAULT),\n+                Settings.get().get(Settings.NODE_TINY_TEXT, Settings.NODE_TINY_TEXT_DEFAULT));\n+        getFilterChain().apply(diagram, getSequenceFilterChain());\n+        if (graph.isDiffGraph()) {\n+            ColorFilter f = new ColorFilter(\"\");\n+            f.addRule(stateColorRule(\"same\",    Color.white));\n+            f.addRule(stateColorRule(\"changed\", Color.orange));\n+            f.addRule(stateColorRule(\"new\",     Color.green));\n+            f.addRule(stateColorRule(\"deleted\", Color.red));\n+            f.apply(diagram);\n+        }\n@@ -396,0 +362,1 @@\n+        diagramChangedEvent.fire();\n@@ -402,8 +369,0 @@\n-    public void setFilterChain(FilterChain chain) {\n-        assert chain != null : \"filterChain must never be null\";\n-        filterChain.getChangedEvent().removeListener(filterChainChangedListener);\n-        filterChain = chain;\n-        filterChain.getChangedEvent().addListener(filterChainChangedListener);\n-        diagramChanged();\n-    }\n-\n@@ -417,5 +376,2 @@\n-            String duplicate = graph.getProperties().get(\"_isDuplicate\");\n-            if (duplicate == null || !hideDuplicates) {\n-                result.add(graph);\n-                positions.add(graph.getName());\n-            }\n+            result.add(graph);\n+            positions.add(graph.getName());\n@@ -443,5 +399,0 @@\n-        if (index == -1 && hideDuplicates) {\n-            \/\/ A graph was selected that's currently hidden, so unhide and select it.\n-            setHideDuplicates(false);\n-            index = graphs.indexOf(g);\n-        }\n@@ -456,25 +407,1 @@\n-    public Diagram getDiagramToView() {\n-\n-        if (diagram == null) {\n-            InputGraph graph = getGraphToView();\n-            if (graph.getBlocks().isEmpty()) {\n-                Scheduler s = Lookup.getDefault().lookup(Scheduler.class);\n-                graph.clearBlocks();\n-                s.schedule(graph);\n-                graph.ensureNodesInBlocks();\n-            }\n-            diagram = Diagram.createDiagram(graph,\n-                                            Settings.get().get(Settings.NODE_TEXT, Settings.NODE_TEXT_DEFAULT),\n-                                            Settings.get().get(Settings.NODE_SHORT_TEXT, Settings.NODE_SHORT_TEXT_DEFAULT),\n-                                            Settings.get().get(Settings.NODE_TINY_TEXT, Settings.NODE_TINY_TEXT_DEFAULT));\n-            getFilterChain().apply(diagram, getSequenceFilterChain());\n-            if (graph.isDiffGraph()) {\n-                ColorFilter f = new ColorFilter(\"\");\n-                f.addRule(stateColorRule(\"same\",    Color.white));\n-                f.addRule(stateColorRule(\"changed\", Color.orange));\n-                f.addRule(stateColorRule(\"new\",     Color.green));\n-                f.addRule(stateColorRule(\"deleted\", Color.red));\n-                f.apply(diagram);\n-           }\n-        }\n-\n+    public Diagram getDiagram() {\n@@ -485,10 +412,2 @@\n-    public InputGraph getGraphToView() {\n-        if (inputGraph == null) {\n-            if (getFirstGraph() != getSecondGraph()) {\n-                inputGraph = Difference.createDiffGraph(getFirstGraph(), getSecondGraph());\n-            } else {\n-                inputGraph = getFirstGraph();\n-            }\n-        }\n-\n-        return inputGraph;\n+    public InputGraph getGraph() {\n+        return cachedInputGraph;\n@@ -499,8 +418,4 @@\n-        inputGraph = null;\n-        diagramChanged();\n-    }\n-\n-    void setSelectedFigures(List<Figure> list) {\n-        Set<Integer> newSelectedNodes = new HashSet<>();\n-        for (Figure f : list) {\n-            newSelectedNodes.addAll(f.getSource().getSourceNodesAsSet());\n+        if (getFirstGraph() != getSecondGraph()) {\n+            cachedInputGraph = Difference.createDiffGraph(getFirstGraph(), getSecondGraph());\n+        } else {\n+            cachedInputGraph = getFirstGraph();\n@@ -508,1 +423,1 @@\n-        this.setSelectedNodes(newSelectedNodes);\n+        updateDiagram();\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/DiagramViewModel.java","additions":46,"deletions":131,"binary":false,"changes":177,"status":"modified"},{"patch":"@@ -48,0 +48,2 @@\n+    DiagramViewModel getModel();\n+\n@@ -66,2 +68,0 @@\n-    public void initialize();\n-\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/DiagramViewer.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-        return editor.getDiagramModel().getGraphToView();\n+        return editor.getModel().getGraph();\n@@ -60,1 +60,1 @@\n-        return editor.getDiagramModel().getGraphsBackward();\n+        return editor.getModel().getGraphsBackward();\n@@ -65,1 +65,1 @@\n-        return editor.getDiagramModel().getGraphsForward();\n+        return editor.getModel().getGraphsForward();\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/EditorInputGraphProvider.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import com.sun.hotspot.igv.data.Properties;\n@@ -34,1 +33,0 @@\n-import com.sun.hotspot.igv.data.Properties.PropertyMatcher;\n@@ -40,1 +38,0 @@\n-import com.sun.hotspot.igv.graph.services.DiagramProvider;\n@@ -47,2 +44,0 @@\n-import java.awt.event.HierarchyBoundsListener;\n-import java.awt.event.HierarchyEvent;\n@@ -86,1 +81,0 @@\n-    private InstanceContent content;\n@@ -92,1 +86,0 @@\n-    private HideDuplicatesAction hideDuplicatesAction;\n@@ -96,1 +89,0 @@\n-    private boolean notFirstTime;\n@@ -100,1 +92,0 @@\n-    private RangeSlider rangeSlider;\n@@ -102,1 +93,0 @@\n-    private JToggleButton hideDuplicatesButton;\n@@ -109,1 +99,0 @@\n-    private DiagramViewModel rangeSliderModel;\n@@ -127,16 +116,0 @@\n-    private DiagramProvider diagramProvider = new DiagramProvider() {\n-\n-        @Override\n-        public Diagram getDiagram() {\n-            return getModel().getDiagramToView();\n-        }\n-\n-        @Override\n-        public ChangedEvent<DiagramProvider> getChangedEvent() {\n-            return diagramChangedEvent;\n-        }\n-    };\n-\n-    private ChangedEvent<DiagramProvider> diagramChangedEvent = new ChangedEvent<>(diagramProvider);\n-\n-\n@@ -144,2 +117,2 @@\n-        setDisplayName(getDiagram().getName());\n-        setToolTipText(getDiagram().getGraph().getGroup().getName());\n+        setDisplayName(getModel().getGraph().getName());\n+        setToolTipText(getModel().getGroup().getName());\n@@ -148,2 +121,1 @@\n-    public EditorTopComponent(Diagram diagram) {\n-\n+    public EditorTopComponent(InputGraph graph) {\n@@ -151,1 +123,0 @@\n-        LookupHistory.init(DiagramProvider.class);\n@@ -203,3 +174,6 @@\n-        rangeSliderModel = new DiagramViewModel(diagram.getGraph().getGroup(), filterChain, sequence);\n-        rangeSlider = new RangeSlider();\n-        rangeSlider.setModel(rangeSliderModel);\n+        DiagramViewModel diagramViewModel = new DiagramViewModel(graph, filterChain, sequence);\n+        diagramViewModel.getDiagramChangedEvent().addListener(diagramChangedListener);\n+        RangeSlider rangeSlider = new RangeSlider(diagramViewModel);\n+        if (diagramViewModel.getGroup().getGraphs().size() == 1) {\n+            rangeSlider.setVisible(false);\n+        }\n@@ -209,2 +183,1 @@\n-        scene = new DiagramScene(actions, actionsWithSelection, rangeSliderModel);\n-        content = new InstanceContent();\n+        scene = new DiagramScene(actions, actionsWithSelection, diagramViewModel);\n@@ -212,1 +185,1 @@\n-        this.associateLookup(new ProxyLookup(new Lookup[]{scene.getLookup(), new AbstractLookup(graphContent), new AbstractLookup(content)}));\n+        InstanceContent content = new InstanceContent();\n@@ -214,12 +187,2 @@\n-        content.add(rangeSliderModel);\n-        content.add(diagramProvider);\n-\n-        rangeSliderModel.getDiagramChangedEvent().addListener(diagramChangedListener);\n-        rangeSliderModel.selectGraph(diagram.getGraph());\n-        rangeSliderModel.getViewPropertiesChangedEvent().addListener(new ChangedListener<DiagramViewModel>() {\n-                @Override\n-                public void changed(DiagramViewModel source) {\n-                    hideDuplicatesButton.setSelected(getModel().getHideDuplicates());\n-                    hideDuplicatesAction.setState(getModel().getHideDuplicates());\n-                }\n-            });\n+        content.add(diagramViewModel);\n+        this.associateLookup(new ProxyLookup(new Lookup[]{scene.getLookup(), new AbstractLookup(graphContent), new AbstractLookup(content)}));\n@@ -227,1 +190,1 @@\n-        Group group = getDiagram().getGraph().getGroup();\n+        Group group = diagramViewModel.getGroup();\n@@ -291,6 +254,0 @@\n-        hideDuplicatesAction = new HideDuplicatesAction();\n-        hideDuplicatesButton = new JToggleButton(hideDuplicatesAction);\n-        hideDuplicatesButton.setSelected(false);\n-        toolBar.add(hideDuplicatesButton);\n-        hideDuplicatesAction.addPropertyChangeListener(this);\n-\n@@ -361,25 +318,0 @@\n-        scene.getComponent().addHierarchyBoundsListener(new HierarchyBoundsListener() {\n-\n-            @Override\n-            public void ancestorMoved(HierarchyEvent e) {\n-            }\n-\n-            @Override\n-            public void ancestorResized(HierarchyEvent e) {\n-                if (!notFirstTime && scene.getComponent().getBounds().width > 0) {\n-                    notFirstTime = true;\n-                    SwingUtilities.invokeLater(new Runnable() {\n-\n-                        @Override\n-                        public void run() {\n-                            EditorTopComponent.this.scene.initialize();\n-                        }\n-                    });\n-                }\n-            }\n-        });\n-\n-        if (diagram.getGraph().getGroup().getGraphsCount() == 1) {\n-            rangeSlider.setVisible(false);\n-        }\n-\n@@ -389,2 +321,6 @@\n-    public DiagramViewModel getDiagramModel() {\n-        return rangeSliderModel;\n+    public DiagramViewModel getModel() {\n+        return scene.getModel();\n+    }\n+\n+    private Diagram getDiagram() {\n+        return getModel().getDiagram();\n@@ -412,18 +348,0 @@\n-    public void showPrevDiagram() {\n-        int fp = getModel().getFirstPosition();\n-        int sp = getModel().getSecondPosition();\n-        if (fp != 0) {\n-            fp--;\n-            sp--;\n-            getModel().setPositions(fp, sp);\n-        }\n-    }\n-\n-    public DiagramViewModel getModel() {\n-        return rangeSliderModel;\n-    }\n-\n-    public FilterChain getFilterChain() {\n-        return getModel().getFilterChain();\n-    }\n-\n@@ -462,1 +380,1 @@\n-        rangeSliderModel.close();\n+        getModel().close();\n@@ -471,1 +389,1 @@\n-        Group group = getDiagram().getGraph().getGroup();\n+        Group group = getModel().getGroup();\n@@ -486,1 +404,0 @@\n-            diagramProvider.getChangedEvent().fire();\n@@ -491,12 +408,1 @@\n-    public boolean showPredSucc() {\n-        return (Boolean) predSuccAction.getValue(PredSuccAction.STATE);\n-    }\n-\n-    public void setSelection(PropertyMatcher matcher) {\n-\n-        Properties.PropertySelector<Figure> selector = new Properties.PropertySelector<>(getModel().getDiagramToView().getFigures());\n-        List<Figure> list = selector.selectMultiple(matcher);\n-        setSelectedFigures(list);\n-    }\n-\n-    public void setSelectedFigures(List<Figure> list) {\n+    private void setSelectedFigures(List<Figure> list) {\n@@ -515,6 +421,3 @@\n-        for (Figure f : getModel().getDiagramToView().getFigures()) {\n-            for (InputNode n : f.getSource().getSourceNodes()) {\n-                if (ids.contains(n.getId())) {\n-                    list.add(f);\n-                    break;\n-                }\n+        for (Figure f : getDiagram().getFigures()) {\n+            if (ids.contains(f.getInputNode().getId())) {\n+                list.add(f);\n@@ -529,2 +432,2 @@\n-        for (Figure f : getModel().getDiagramToView().getFigures()) {\n-            if (f.getBlock() == b) {\n+        for (Figure f : getDiagram().getFigures()) {\n+            if (f.getBlock().getInputBlock() == b) {\n@@ -564,3 +467,0 @@\n-        } else if (evt.getSource() == this.hideDuplicatesAction) {\n-            boolean b = (Boolean) hideDuplicatesAction.getValue(HideDuplicatesAction.STATE);\n-            this.getModel().setHideDuplicates(b);\n@@ -579,11 +479,0 @@\n-    public void extract() {\n-        getModel().showOnly(getModel().getSelectedNodes());\n-    }\n-\n-    public void hideNodes() {\n-        Set<Integer> selectedNodes = this.getModel().getSelectedNodes();\n-        HashSet<Integer> nodes = new HashSet<>(getModel().getHiddenNodes());\n-        nodes.addAll(selectedNodes);\n-        this.getModel().showNot(nodes);\n-    }\n-\n@@ -594,1 +483,1 @@\n-        for (Figure f : this.getDiagramModel().getDiagramToView().getFigures()) {\n+        for (Figure f : getDiagram().getFigures()) {\n@@ -619,1 +508,1 @@\n-        for (Figure f : this.getDiagramModel().getDiagramToView().getFigures()) {\n+        for (Figure f : getDiagram().getFigures()) {\n@@ -640,8 +529,0 @@\n-    public void showAll() {\n-        getModel().showNot(new HashSet<Integer>());\n-    }\n-\n-    public Diagram getDiagram() {\n-        return getDiagramModel().getDiagramToView();\n-    }\n-\n@@ -679,5 +560,0 @@\n-    @Override\n-    protected Object writeReplace() throws ObjectStreamException {\n-        throw new NotSerializableException();\n-    }\n-\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/EditorTopComponent.java","additions":30,"deletions":154,"binary":false,"changes":184,"status":"modified"},{"patch":"@@ -1,216 +0,0 @@\n-\/*\n- * Copyright (c) 2008, 2015, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-package com.sun.hotspot.igv.view;\n-\n-import java.awt.*;\n-import java.awt.event.*;\n-import javax.swing.JComponent;\n-import org.netbeans.api.visual.widget.Scene;\n-\n-\/**\n- * @author David Kaspar\n- * @author Thomas Wuerthinger\n- *\/\n-public class ExtendedSatelliteComponent extends JComponent implements MouseListener, MouseMotionListener, Scene.SceneListener, ComponentListener {\n-\n-    private DiagramScene scene;\n-    private Image image;\n-    private int imageWidth;\n-    private int imageHeight;\n-\n-    public ExtendedSatelliteComponent(DiagramScene scene) {\n-        this.scene = scene;\n-        setDoubleBuffered(true);\n-        setPreferredSize(new Dimension(128, 128));\n-        addMouseListener(this);\n-        addMouseMotionListener(this);\n-    }\n-\n-    @Override\n-    public void addNotify() {\n-        super.addNotify();\n-        scene.addSceneListener(this);\n-        JComponent viewComponent = scene.getView();\n-        if (viewComponent == null) {\n-            viewComponent = scene.createView();\n-        }\n-        viewComponent.addComponentListener(this);\n-        repaint();\n-    }\n-\n-    @Override\n-    public void removeNotify() {\n-        scene.getView().removeComponentListener(this);\n-        scene.removeSceneListener(this);\n-        super.removeNotify();\n-    }\n-\n-    public void update() {\n-        this.image = null;\n-        if (this.isVisible()) {\n-            repaint();\n-            revalidate();\n-            validate();\n-        }\n-    }\n-\n-    @Override\n-    public void paint(Graphics g) {\n-        Graphics2D gr = (Graphics2D) g;\n-        super.paint(g);\n-        Rectangle bounds = scene.getBounds();\n-        Dimension size = getSize();\n-\n-        double sx = bounds.width > 0 ? (double) size.width \/ bounds.width : 0.0;\n-        double sy = bounds.width > 0 ? (double) size.height \/ bounds.height : 0.0;\n-        double scale = Math.min(sx, sy);\n-\n-        int vw = (int) (scale * bounds.width);\n-        int vh = (int) (scale * bounds.height);\n-        int vx = (size.width - vw) \/ 2;\n-        int vy = (size.height - vh) \/ 2;\n-\n-\n-        if (image == null || vw != imageWidth || vh != imageHeight) {\n-            imageWidth = vw;\n-            imageHeight = vh;\n-            image = this.createImage(imageWidth, imageHeight);\n-            Graphics2D ig = (Graphics2D) image.getGraphics();\n-            ig.scale(scale, scale);\n-            double oldFactor = scene.getZoomFactor();\n-            scene.setZoomFactor(scale);\n-            scene.paint(ig);\n-            scene.setZoomFactor(oldFactor);\n-        }\n-\n-        gr.drawImage(image, vx, vy, this);\n-\n-        JComponent component = scene.getView();\n-        double zoomFactor = scene.getZoomFactor();\n-        Rectangle viewRectangle = component != null ? component.getVisibleRect() : null;\n-        if (viewRectangle != null) {\n-            Rectangle window = new Rectangle(\n-                    (int) ((double) viewRectangle.x * scale \/ zoomFactor),\n-                    (int) ((double) viewRectangle.y * scale \/ zoomFactor),\n-                    (int) ((double) viewRectangle.width * scale \/ zoomFactor),\n-                    (int) ((double) viewRectangle.height * scale \/ zoomFactor));\n-            window.translate(vx, vy);\n-            gr.setColor(new Color(200, 200, 200, 128));\n-            gr.fill(window);\n-            gr.setColor(Color.BLACK);\n-            gr.drawRect(window.x, window.y, window.width - 1, window.height - 1);\n-        }\n-    }\n-\n-    @Override\n-    public void mouseClicked(MouseEvent e) {\n-    }\n-\n-    @Override\n-    public void mousePressed(MouseEvent e) {\n-        moveVisibleRect(e.getPoint());\n-    }\n-\n-    @Override\n-    public void mouseReleased(MouseEvent e) {\n-        moveVisibleRect(e.getPoint());\n-    }\n-\n-    @Override\n-    public void mouseEntered(MouseEvent e) {\n-    }\n-\n-    @Override\n-    public void mouseExited(MouseEvent e) {\n-    }\n-\n-    @Override\n-    public void mouseDragged(MouseEvent e) {\n-        moveVisibleRect(e.getPoint());\n-    }\n-\n-    @Override\n-    public void mouseMoved(MouseEvent e) {\n-    }\n-\n-    private void moveVisibleRect(Point center) {\n-        JComponent component = scene.getView();\n-        if (component == null) {\n-            return;\n-        }\n-        double zoomFactor = scene.getZoomFactor();\n-        Rectangle bounds = scene.getBounds();\n-        Dimension size = getSize();\n-\n-        double sx = bounds.width > 0 ? (double) size.width \/ bounds.width : 0.0;\n-        double sy = bounds.width > 0 ? (double) size.height \/ bounds.height : 0.0;\n-        double scale = Math.min(sx, sy);\n-\n-        int vw = (int) (scale * bounds.width);\n-        int vh = (int) (scale * bounds.height);\n-        int vx = (size.width - vw) \/ 2;\n-        int vy = (size.height - vh) \/ 2;\n-\n-        int cx = (int) ((double) (center.x - vx) \/ scale * zoomFactor);\n-        int cy = (int) ((double) (center.y - vy) \/ scale * zoomFactor);\n-\n-        Rectangle visibleRect = component.getVisibleRect();\n-        visibleRect.x = cx - visibleRect.width \/ 2;\n-        visibleRect.y = cy - visibleRect.height \/ 2;\n-        component.scrollRectToVisible(visibleRect);\n-\n-        this.repaint();\n-    }\n-\n-    @Override\n-    public void sceneRepaint() {\n-    \/\/repaint ();\n-    }\n-\n-    @Override\n-    public void sceneValidating() {\n-    }\n-\n-    @Override\n-    public void sceneValidated() {\n-    }\n-\n-    @Override\n-    public void componentResized(ComponentEvent e) {\n-        repaint();\n-    }\n-\n-    @Override\n-    public void componentMoved(ComponentEvent e) {\n-        repaint();\n-    }\n-\n-    @Override\n-    public void componentShown(ComponentEvent e) {\n-    }\n-\n-    @Override\n-    public void componentHidden(ComponentEvent e) {\n-    }\n-}\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/ExtendedSatelliteComponent.java","additions":0,"deletions":216,"binary":false,"changes":216,"status":"deleted"},{"patch":"@@ -28,2 +28,0 @@\n-import com.sun.hotspot.igv.graph.Diagram;\n-import com.sun.hotspot.igv.settings.Settings;\n@@ -33,0 +31,1 @@\n+import org.openide.util.lookup.ServiceProvider;\n@@ -36,1 +35,0 @@\n-import org.openide.util.lookup.ServiceProvider;\n@@ -47,1 +45,0 @@\n-\n@@ -67,6 +64,1 @@\n-        Diagram diagram = Diagram.createDiagram(graph,\n-                                                Settings.get().get(Settings.NODE_TEXT, Settings.NODE_TEXT_DEFAULT),\n-                                                Settings.get().get(Settings.NODE_SHORT_TEXT, Settings.NODE_SHORT_TEXT_DEFAULT),\n-                                                Settings.get().get(Settings.NODE_TINY_TEXT, Settings.NODE_TINY_TEXT_DEFAULT));\n-        EditorTopComponent tc = new EditorTopComponent(diagram);\n-        diagram.setCFG(tc.getModel().getShowCFG());\n+        EditorTopComponent tc = new EditorTopComponent(graph);\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/GraphViewerImplementation.java","additions":2,"deletions":10,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -124,1 +124,1 @@\n-                                    comp.getDiagramModel().selectGraph(theGraph);\n+                                    comp.getModel().selectGraph(theGraph);\n@@ -153,1 +153,1 @@\n-                                    comp.getDiagramModel().selectGraph(theGraph);\n+                                    comp.getModel().selectGraph(theGraph);\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/NodeQuickSearch.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,4 +26,1 @@\n-import org.netbeans.api.visual.widget.Widget;\n-import org.netbeans.api.visual.action.WidgetAction;\n-import org.netbeans.api.visual.action.SelectProvider;\n-\n+import java.awt.Point;\n@@ -31,2 +28,3 @@\n-import java.awt.event.KeyEvent;\n-import java.awt.*;\n+import org.netbeans.api.visual.action.SelectProvider;\n+import org.netbeans.api.visual.action.WidgetAction;\n+import org.netbeans.api.visual.widget.Widget;\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/actions\/CustomSelectAction.java","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -53,1 +53,0 @@\n-import javax.swing.JScrollBar;\n@@ -55,2 +54,0 @@\n-import org.netbeans.api.visual.action.WidgetAction.State;\n-import org.netbeans.api.visual.action.WidgetAction.WidgetMouseEvent;\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/actions\/CustomizablePanAction.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -31,1 +31,4 @@\n-import org.openide.util.*;\n+import org.openide.util.HelpCtx;\n+import org.openide.util.ImageUtilities;\n+import org.openide.util.Lookup;\n+import org.openide.util.NbBundle;\n@@ -94,0 +97,5 @@\n+\n+    @Override\n+    protected boolean asynchronous() {\n+        return false;\n+    }\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/actions\/ExpandDiffAction.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-import java.awt.event.InputEvent;\n-import java.awt.event.KeyEvent;\n@@ -33,1 +31,0 @@\n-import javax.swing.KeyStroke;\n@@ -37,1 +34,0 @@\n-import org.openide.util.Utilities;\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/actions\/ExportAction.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,2 +27,0 @@\n-import java.awt.Event;\n-import java.awt.event.KeyEvent;\n@@ -30,1 +28,0 @@\n-import javax.swing.KeyStroke;\n@@ -32,1 +29,0 @@\n-import org.openide.util.actions.CallableSystemAction;\n@@ -34,0 +30,1 @@\n+import org.openide.util.actions.CallableSystemAction;\n@@ -45,1 +42,1 @@\n-            editor.extract();\n+            editor.getModel().showOnly(editor.getModel().getSelectedNodes());\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/actions\/ExtractAction.java","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -27,2 +27,2 @@\n-import java.awt.Event;\n-import java.awt.event.KeyEvent;\n+import java.util.HashSet;\n+import java.util.Set;\n@@ -30,1 +30,0 @@\n-import javax.swing.KeyStroke;\n@@ -32,1 +31,0 @@\n-import org.openide.util.actions.CallableSystemAction;\n@@ -34,0 +32,1 @@\n+import org.openide.util.actions.CallableSystemAction;\n@@ -45,1 +44,4 @@\n-            editor.hideNodes();\n+            Set<Integer> selectedNodes = editor.getModel().getSelectedNodes();\n+            HashSet<Integer> nodes = new HashSet<>(editor.getModel().getHiddenNodes());\n+            nodes.addAll(selectedNodes);\n+            editor.getModel().setHiddenNodes(nodes);\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/actions\/HideAction.java","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1,60 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2015, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-package com.sun.hotspot.igv.view.actions;\n-\n-import java.awt.event.ActionEvent;\n-import javax.swing.AbstractAction;\n-import javax.swing.Action;\n-import javax.swing.ImageIcon;\n-import org.openide.util.ImageUtilities;\n-\n-\/**\n- *\n- * @author Tom Rodriguez\n- *\/\n-public class HideDuplicatesAction extends AbstractAction {\n-\n-    private boolean state;\n-    public static final String STATE = \"state\";\n-\n-    public HideDuplicatesAction() {\n-        putValue(AbstractAction.SMALL_ICON, new ImageIcon(ImageUtilities.loadImage(iconResource())));\n-        putValue(Action.SHORT_DESCRIPTION, \"Hide graphs which are the same as the previous graph\");\n-        setState(false);\n-    }\n-\n-    @Override\n-    public void actionPerformed(ActionEvent ev) {\n-        setState(!state);\n-    }\n-\n-    public void setState(boolean b) {\n-        this.putValue(STATE, b);\n-        this.state = b;\n-    }\n-\n-    protected String iconResource() {\n-        return \"com\/sun\/hotspot\/igv\/view\/images\/hideDuplicates.png\";\n-    }\n-}\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/actions\/HideDuplicatesAction.java","additions":0,"deletions":60,"binary":false,"changes":60,"status":"deleted"},{"patch":"@@ -28,1 +28,0 @@\n-import org.netbeans.api.visual.action.WidgetAction.State;\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/actions\/MouseOverAction.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,1 +31,4 @@\n-import org.openide.util.*;\n+import org.openide.util.HelpCtx;\n+import org.openide.util.ImageUtilities;\n+import org.openide.util.Lookup;\n+import org.openide.util.NbBundle;\n@@ -98,0 +101,5 @@\n+\n+    @Override\n+    protected boolean asynchronous() {\n+        return false;\n+    }\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/actions\/NextDiagramAction.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -31,1 +31,4 @@\n-import org.openide.util.*;\n+import org.openide.util.HelpCtx;\n+import org.openide.util.ImageUtilities;\n+import org.openide.util.Lookup;\n+import org.openide.util.NbBundle;\n@@ -98,0 +101,5 @@\n+\n+    @Override\n+    protected boolean asynchronous() {\n+        return false;\n+    }\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/actions\/PrevDiagramAction.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -27,2 +27,1 @@\n-import java.awt.event.InputEvent;\n-import java.awt.event.KeyEvent;\n+import java.util.HashSet;\n@@ -30,1 +29,0 @@\n-import javax.swing.KeyStroke;\n@@ -32,1 +30,0 @@\n-import org.openide.util.actions.CallableSystemAction;\n@@ -34,0 +31,1 @@\n+import org.openide.util.actions.CallableSystemAction;\n@@ -45,1 +43,1 @@\n-            editor.showAll();\n+            editor.getModel().setHiddenNodes(new HashSet<Integer>());\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/actions\/ShowAllAction.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -31,1 +31,4 @@\n-import org.openide.util.*;\n+import org.openide.util.HelpCtx;\n+import org.openide.util.ImageUtilities;\n+import org.openide.util.Lookup;\n+import org.openide.util.NbBundle;\n@@ -95,0 +98,5 @@\n+\n+    @Override\n+    protected boolean asynchronous() {\n+        return false;\n+    }\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/actions\/ShrinkDiffAction.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -27,2 +27,0 @@\n-import java.awt.Event;\n-import java.awt.event.KeyEvent;\n@@ -30,1 +28,0 @@\n-import javax.swing.KeyStroke;\n@@ -32,1 +29,0 @@\n-import org.openide.util.actions.CallableSystemAction;\n@@ -34,0 +30,1 @@\n+import org.openide.util.actions.CallableSystemAction;\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/actions\/ZoomInAction.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -27,2 +27,0 @@\n-import java.awt.Event;\n-import java.awt.event.KeyEvent;\n@@ -30,1 +28,0 @@\n-import javax.swing.KeyStroke;\n@@ -32,1 +29,0 @@\n-import org.openide.util.actions.CallableSystemAction;\n@@ -34,0 +30,1 @@\n+import org.openide.util.actions.CallableSystemAction;\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/actions\/ZoomOutAction.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -28,6 +28,1 @@\n-import java.awt.BasicStroke;\n-import java.awt.Color;\n-import java.awt.Font;\n-import java.awt.Graphics2D;\n-import java.awt.Rectangle;\n-import java.awt.Stroke;\n+import java.awt.*;\n@@ -44,1 +39,0 @@\n-    public static final int BORDER = 20;\n@@ -49,1 +43,0 @@\n-    private Diagram diagram;\n@@ -54,1 +47,0 @@\n-        this.diagram = d;\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/widgets\/BlockWidget.java","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-import com.sun.hotspot.igv.data.InputGraph;\n@@ -28,1 +27,0 @@\n-import com.sun.hotspot.igv.data.services.GraphViewer;\n@@ -36,1 +34,0 @@\n-import java.awt.event.ActionEvent;\n@@ -40,1 +37,0 @@\n-import javax.swing.AbstractAction;\n@@ -60,1 +56,0 @@\n-import org.openide.util.Lookup;\n@@ -71,2 +66,0 @@\n-    private Widget leftWidget;\n-    private Widget rightWidget;\n@@ -187,8 +180,0 @@\n-    public Widget getLeftWidget() {\n-        return leftWidget;\n-    }\n-\n-    public Widget getRightWidget() {\n-        return rightWidget;\n-    }\n-\n@@ -289,21 +274,0 @@\n-        if (getFigure().getSubgraphs() != null) {\n-            menu.addSeparator();\n-            JMenu subgraphs = new JMenu(\"Subgraphs\");\n-            menu.add(subgraphs);\n-\n-            final GraphViewer viewer = Lookup.getDefault().lookup(GraphViewer.class);\n-            for (final InputGraph subgraph : getFigure().getSubgraphs()) {\n-                Action a = new AbstractAction() {\n-\n-                    @Override\n-                    public void actionPerformed(ActionEvent e) {\n-                        viewer.view(subgraph, true);\n-                    }\n-                };\n-\n-                a.setEnabled(true);\n-                a.putValue(Action.NAME, subgraph.getName());\n-                subgraphs.add(a);\n-            }\n-        }\n-\n@@ -386,1 +350,0 @@\n-\n@@ -388,3 +351,3 @@\n-            final Set<Integer> hiddenNodes = new HashSet<>(diagramScene.getModel().getGraphToView().getGroup().getAllNodes());\n-            hiddenNodes.removeAll(this.getFigure().getSource().getSourceNodesAsSet());\n-            this.diagramScene.getModel().showNot(hiddenNodes);\n+            final Set<Integer> hiddenNodes = new HashSet<>(diagramScene.getModel().getGroup().getAllNodes());\n+            hiddenNodes.remove(this.getFigure().getInputNode().getId());\n+            this.diagramScene.getModel().setHiddenNodes(hiddenNodes);\n@@ -392,1 +355,0 @@\n-\n@@ -394,2 +356,2 @@\n-            hiddenNodes.removeAll(this.getFigure().getSource().getSourceNodesAsSet());\n-            this.diagramScene.getModel().showNot(hiddenNodes);\n+            hiddenNodes.remove(this.getFigure().getInputNode().getId());\n+            this.diagramScene.getModel().setHiddenNodes(hiddenNodes);\n@@ -398,2 +360,2 @@\n-            hiddenNodes.addAll(this.getFigure().getSource().getSourceNodesAsSet());\n-            this.diagramScene.getModel().showNot(hiddenNodes);\n+            hiddenNodes.add(this.getFigure().getInputNode().getId());\n+            this.diagramScene.getModel().setHiddenNodes(hiddenNodes);\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/widgets\/FigureWidget.java","additions":7,"deletions":45,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -61,11 +61,0 @@\n-\/*\n-    protected Point calculateRelativeLocation() {\n-        if (getFigureWidget().getBounds() == null) {\n-            return new Point(0, 0);\n-        }\n-\n-        double x = 0;\n-        List<InputSlot> slots = inputSlot.getFigure().getInputSlots();\n-        assert slots.contains(inputSlot);\n-        return new Point((int) x, (int) (calculateRelativeY(slots.size(), slots.indexOf(inputSlot))));\n-    }*\/\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/widgets\/InputSlotWidget.java","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+import com.sun.hotspot.igv.graph.Block;\n@@ -29,1 +30,0 @@\n-import com.sun.hotspot.igv.graph.Block;\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/widgets\/LineWidget.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,6 +31,1 @@\n-import java.awt.BasicStroke;\n-import java.awt.Color;\n-import java.awt.Font;\n-import java.awt.Graphics2D;\n-import java.awt.Point;\n-import java.awt.Rectangle;\n+import java.awt.*;\n@@ -38,0 +33,1 @@\n+import java.util.Collections;\n@@ -173,1 +169,1 @@\n-            hiddenNodes = new HashSet<>(diagramScene.getModel().getGraphToView().getGroup().getAllNodes());\n+            hiddenNodes = new HashSet<>(diagramScene.getModel().getGroup().getAllNodes());\n@@ -177,1 +173,1 @@\n-        for (Figure f : diagramScene.getModel().getDiagramToView().getFigures()) {\n+        for (Figure f : diagramScene.getModel().getDiagram().getFigures()) {\n@@ -179,1 +175,1 @@\n-                if (DiagramScene.doesIntersect(s.getSource().getSourceNodesAsSet(), slot.getSource().getSourceNodesAsSet())) {\n+                if (!Collections.disjoint(s.getSource().getSourceNodesAsSet(), slot.getSource().getSourceNodesAsSet())) {\n@@ -181,1 +177,1 @@\n-                    hiddenNodes.removeAll(f.getSource().getSourceNodesAsSet());\n+                    hiddenNodes.remove(f.getInputNode().getId());\n@@ -187,1 +183,1 @@\n-            this.diagramScene.getModel().showNot(hiddenNodes);\n+            this.diagramScene.getModel().setHiddenNodes(hiddenNodes);\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/widgets\/SlotWidget.java","additions":7,"deletions":11,"binary":false,"changes":18,"status":"modified"},{"filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/resources\/com\/sun\/hotspot\/igv\/view\/images\/hideDuplicates.png","binary":true,"status":"deleted"}]}