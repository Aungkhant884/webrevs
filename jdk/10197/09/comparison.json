{"files":[{"patch":"@@ -62,3 +62,1 @@\n-            for (InputNode n : nodeList) {\n-                nodes.add(n);\n-            }\n+            nodes.addAll(nodeList);\n@@ -91,1 +89,1 @@\n-        return new Action[]{(Action) SelectBytecodesAction.findObject(SelectBytecodesAction.class, true)};\n+        return new Action[]{SelectBytecodesAction.findObject(SelectBytecodesAction.class, true)};\n@@ -96,1 +94,1 @@\n-        return (Action) SelectBytecodesAction.findObject(SelectBytecodesAction.class, true);\n+        return SelectBytecodesAction.findObject(SelectBytecodesAction.class, true);\n","filename":"src\/utils\/IdealGraphVisualizer\/Bytecodes\/src\/main\/java\/com\/sun\/hotspot\/igv\/bytecodes\/BytecodeNode.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import java.io.Serializable;\n@@ -48,2 +47,2 @@\n-    private ExplorerManager manager;\n-    private BeanTreeView treeView;\n+    private final ExplorerManager manager;\n+    private final BeanTreeView treeView;\n@@ -51,1 +50,1 @@\n-    private MethodNode rootNode;\n+    private final MethodNode rootNode;\n@@ -95,1 +94,1 @@\n-     * To obtain the singleton instance, use {@link findInstance}.\n+     * To obtain the singleton instance, use {@link #findInstance()}.\n@@ -138,5 +137,0 @@\n-    @Override\n-    public Object writeReplace() {\n-        return new ResolvableHelper();\n-    }\n-\n@@ -173,11 +167,8 @@\n-        final InputGraphProvider p = LookupHistory.getLast(InputGraphProvider.class);\/\/)Utilities.actionsGlobalContext().lookup(InputGraphProvider.class);\n-            SwingUtilities.invokeLater(new Runnable() {\n-                @Override\n-                public void run() {\n-                if (p != null) {\n-                    InputGraph graph = p.getGraph();\n-                    if (graph != null) {\n-                        Group g = graph.getGroup();\n-                        rootNode.update(graph, g.getMethod());\n-                        return;\n-                    }\n+        final InputGraphProvider p = LookupHistory.getLast(InputGraphProvider.class);\n+            SwingUtilities.invokeLater(() -> {\n+            if (p != null) {\n+                InputGraph graph = p.getGraph();\n+                if (graph != null) {\n+                    Group g = graph.getGroup();\n+                    rootNode.update(graph, g.getMethod());\n+                    return;\n@@ -185,7 +176,3 @@\n-                        rootNode.update(null, null);\n-                    }\n-            });\n-\n-    }\n-\n-    static final class ResolvableHelper implements Serializable {\n+            }\n+                    rootNode.update(null, null);\n+                });\n@@ -193,5 +180,0 @@\n-        private static final long serialVersionUID = 1L;\n-\n-        public Object readResolve() {\n-            return BytecodeViewTopComponent.getDefault();\n-        }\n","filename":"src\/utils\/IdealGraphVisualizer\/Bytecodes\/src\/main\/java\/com\/sun\/hotspot\/igv\/bytecodes\/BytecodeViewTopComponent.java","additions":15,"deletions":33,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-        private String bciString;\n+        private final String bciString;\n","filename":"src\/utils\/IdealGraphVisualizer\/Bytecodes\/src\/main\/java\/com\/sun\/hotspot\/igv\/bytecodes\/MethodNode.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-        InputGraphProvider p = LookupHistory.getLast(InputGraphProvider.class);\/\/Utilities.actionsGlobalContext().lookup(InputGraphProvider.class);\n+        InputGraphProvider p = LookupHistory.getLast(InputGraphProvider.class);\n","filename":"src\/utils\/IdealGraphVisualizer\/Bytecodes\/src\/main\/java\/com\/sun\/hotspot\/igv\/bytecodes\/SelectBytecodesAction.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-    private Set<InputNode> nodes;\n+    private final Set<InputNode> nodes;\n","filename":"src\/utils\/IdealGraphVisualizer\/Bytecodes\/src\/main\/java\/com\/sun\/hotspot\/igv\/bytecodes\/SelectBytecodesCookie.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -16,0 +16,1 @@\n+                <attr name=\"position\" intvalue=\"1\"\/>\n","filename":"src\/utils\/IdealGraphVisualizer\/Bytecodes\/src\/main\/resources\/com\/sun\/hotspot\/igv\/bytecodes\/layer.xml","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import com.sun.hotspot.igv.layout.Cluster;\n@@ -29,1 +30,0 @@\n-import com.sun.hotspot.igv.layout.Cluster;\n@@ -48,4 +48,4 @@\n-    private BlockWidget from;\n-    private BlockWidget to;\n-    private Port inputSlot;\n-    private Port outputSlot;\n+    private final BlockWidget from;\n+    private final BlockWidget to;\n+    private final Port inputSlot;\n+    private final Port outputSlot;\n@@ -53,1 +53,1 @@\n-    private InputBlockEdge edge;\n+    private final InputBlockEdge edge;\n@@ -65,5 +65,1 @@\n-        points = new ArrayList<Point>();\n-    }\n-\n-    public InputBlockEdge getEdge() {\n-        return edge;\n+        points = new ArrayList<>();\n","filename":"src\/utils\/IdealGraphVisualizer\/ControlFlow\/src\/main\/java\/com\/sun\/hotspot\/igv\/controlflow\/BlockConnectionWidget.java","additions":7,"deletions":11,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -30,5 +30,1 @@\n-import java.awt.Color;\n-import java.awt.Dimension;\n-import java.awt.Font;\n-import java.awt.Point;\n-import java.awt.Rectangle;\n+import java.awt.*;\n@@ -46,3 +42,3 @@\n-    private InputBlock block;\n-    private Port inputSlot;\n-    private Port outputSlot;\n+    private final InputBlock block;\n+    private final Port inputSlot;\n+    private final Port outputSlot;\n@@ -51,2 +47,2 @@\n-    private static final Font font = new Font(Font.SANS_SERIF, Font.PLAIN, 12);\n-    private static final Font boldFont = font.deriveFont(Font.BOLD);\n+    private static final Font FOND = new Font(Font.SANS_SERIF, Font.PLAIN, 12);\n+    private static final Font BOLD_FOND = FOND.deriveFont(Font.BOLD);\n@@ -65,1 +61,1 @@\n-        this.setFont(font);\n+        this.setFont(FOND);\n@@ -129,8 +125,0 @@\n-    public void setCluster(Cluster c) {\n-        cluster = c;\n-    }\n-\n-    public void setRoot(boolean b) {\n-        root = b;\n-    }\n-\n@@ -155,1 +143,1 @@\n-                this.setFont(boldFont);\n+                this.setFont(BOLD_FOND);\n@@ -157,1 +145,1 @@\n-                this.setFont(font);\n+                this.setFont(FOND);\n","filename":"src\/utils\/IdealGraphVisualizer\/ControlFlow\/src\/main\/java\/com\/sun\/hotspot\/igv\/controlflow\/BlockWidget.java","additions":9,"deletions":21,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-import com.sun.hotspot.igv.data.InputBlockEdge;\n@@ -28,0 +27,1 @@\n+import com.sun.hotspot.igv.data.InputBlockEdge;\n@@ -29,1 +29,0 @@\n-import com.sun.hotspot.igv.data.services.InputGraphProvider;\n@@ -31,0 +30,1 @@\n+import com.sun.hotspot.igv.data.services.InputGraphProvider;\n@@ -39,6 +39,1 @@\n-import org.netbeans.api.visual.action.ActionFactory;\n-import org.netbeans.api.visual.action.MoveProvider;\n-import org.netbeans.api.visual.action.RectangularSelectDecorator;\n-import org.netbeans.api.visual.action.RectangularSelectProvider;\n-import org.netbeans.api.visual.action.SelectProvider;\n-import org.netbeans.api.visual.action.WidgetAction;\n+import org.netbeans.api.visual.action.*;\n@@ -47,3 +42,0 @@\n-import org.netbeans.api.visual.router.RouterFactory;\n-import org.netbeans.api.visual.widget.LayerWidget;\n-import org.netbeans.api.visual.widget.Widget;\n@@ -54,0 +46,1 @@\n+import org.netbeans.api.visual.router.RouterFactory;\n@@ -55,0 +48,2 @@\n+import org.netbeans.api.visual.widget.LayerWidget;\n+import org.netbeans.api.visual.widget.Widget;\n@@ -62,1 +57,1 @@\n-    private HashSet<BlockWidget> selection;\n+    private final HashSet<BlockWidget> selection;\n@@ -64,6 +59,5 @@\n-    private LayerWidget edgeLayer;\n-    private LayerWidget mainLayer;\n-    private LayerWidget selectLayer;\n-    private WidgetAction hoverAction = this.createWidgetHoverAction();\n-    private WidgetAction selectAction = new DoubleClickSelectAction(this);\n-    private WidgetAction moveAction = ActionFactory.createMoveAction(null, this);\n+    private final LayerWidget edgeLayer;\n+    private final LayerWidget mainLayer;\n+    private final WidgetAction hoverAction = this.createWidgetHoverAction();\n+    private final WidgetAction selectAction = new DoubleClickSelectAction(this);\n+    private final WidgetAction moveAction = ActionFactory.createMoveAction(null, this);\n@@ -72,1 +66,1 @@\n-        selection = new HashSet<BlockWidget>();\n+        selection = new HashSet<>();\n@@ -83,1 +77,1 @@\n-        selectLayer = new LayerWidget(this);\n+        LayerWidget selectLayer = new LayerWidget(this);\n@@ -98,1 +92,1 @@\n-        ArrayList<InputBlock> blocks = new ArrayList<InputBlock>(this.getNodes());\n+        ArrayList<InputBlock> blocks = new ArrayList<>(this.getNodes());\n@@ -103,1 +97,1 @@\n-        ArrayList<InputBlockEdge> edges = new ArrayList<InputBlockEdge>(this.getEdges());\n+        ArrayList<InputBlockEdge> edges = new ArrayList<>(this.getEdges());\n@@ -120,1 +114,1 @@\n-        GraphLayout<InputBlock, InputBlockEdge> layout = new HierarchicalGraphLayout<InputBlock, InputBlockEdge>();\/\/GridGraphLayout();\n+        GraphLayout<InputBlock, InputBlockEdge> layout = new HierarchicalGraphLayout<>();\n@@ -136,1 +130,1 @@\n-        InputGraphProvider p = LookupHistory.getLast(InputGraphProvider.class);\/\/)Utilities.actionsGlobalContext().lookup(InputGraphProvider.class);\n+        InputGraphProvider p = LookupHistory.getLast(InputGraphProvider.class);\n@@ -138,1 +132,1 @@\n-            Set<InputNode> inputNodes = new HashSet<InputNode>();\n+            Set<InputNode> inputNodes = new HashSet<>();\n@@ -237,0 +231,1 @@\n+            assert w.getBounds() != null;\n","filename":"src\/utils\/IdealGraphVisualizer\/ControlFlow\/src\/main\/java\/com\/sun\/hotspot\/igv\/controlflow\/ControlFlowScene.java","additions":20,"deletions":25,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import java.io.Serializable;\n@@ -34,5 +33,1 @@\n-import org.openide.util.Lookup;\n-import org.openide.util.LookupEvent;\n-import org.openide.util.LookupListener;\n-import org.openide.util.NbBundle;\n-import org.openide.util.Utilities;\n+import org.openide.util.*;\n@@ -51,1 +46,1 @@\n-    private ControlFlowScene scene;\n+    private final ControlFlowScene scene;\n@@ -94,1 +89,1 @@\n-     * To obtain the singleton instance, use {@link findInstance}.\n+     * To obtain the singleton instance, use {@link #findInstance()}.\n@@ -126,1 +121,1 @@\n-        Lookup.Template<InputGraphProvider> tpl = new Lookup.Template<InputGraphProvider>(InputGraphProvider.class);\n+        Lookup.Template<InputGraphProvider> tpl = new Lookup.Template<>(InputGraphProvider.class);\n@@ -138,1 +133,1 @@\n-        final InputGraphProvider p = LookupHistory.getLast(InputGraphProvider.class);\/\/Utilities.actionsGlobalContext().lookup(InputGraphProvider.class);\n+        final InputGraphProvider p = LookupHistory.getLast(InputGraphProvider.class);\n@@ -140,7 +135,4 @@\n-            SwingUtilities.invokeLater(new Runnable() {\n-\n-                public void run() {\n-                    InputGraph g = p.getGraph();\n-                    if (g != null) {\n-                        scene.setGraph(g);\n-                    }\n+            SwingUtilities.invokeLater(() -> {\n+                InputGraph g = p.getGraph();\n+                if (g != null) {\n+                    scene.setGraph(g);\n@@ -152,5 +144,0 @@\n-    @Override\n-    public Object writeReplace() {\n-        return new ResolvableHelper();\n-    }\n-\n@@ -167,9 +154,0 @@\n-\n-    static final class ResolvableHelper implements Serializable {\n-\n-        private static final long serialVersionUID = 1L;\n-\n-        public Object readResolve() {\n-            return ControlFlowTopComponent.getDefault();\n-        }\n-    }\n","filename":"src\/utils\/IdealGraphVisualizer\/ControlFlow\/src\/main\/java\/com\/sun\/hotspot\/igv\/controlflow\/ControlFlowTopComponent.java","additions":9,"deletions":31,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -27,5 +27,1 @@\n-import com.sun.hotspot.igv.layout.Cluster;\n-import com.sun.hotspot.igv.layout.LayoutGraph;\n-import com.sun.hotspot.igv.layout.Link;\n-import com.sun.hotspot.igv.layout.Port;\n-import com.sun.hotspot.igv.layout.Vertex;\n+import com.sun.hotspot.igv.layout.*;\n@@ -34,7 +30,1 @@\n-import java.util.ArrayList;\n-import java.util.Collection;\n-import java.util.HashMap;\n-import java.util.LinkedHashSet;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n+import java.util.*;\n@@ -56,2 +46,2 @@\n-        private VertexWrapper from;\n-        private VertexWrapper to;\n+        private final VertexWrapper from;\n+        private final VertexWrapper to;\n@@ -81,1 +71,1 @@\n-            return new ArrayList<Point>();\n+            return new ArrayList<>();\n@@ -95,3 +85,3 @@\n-        private N node;\n-        private UniversalGraph<N, E> graph;\n-        private Port slot;\n+        private final N node;\n+        private final UniversalGraph<N, E> graph;\n+        private final Port slot;\n@@ -125,0 +115,1 @@\n+            assert w.getBounds() != null;\n@@ -154,3 +145,3 @@\n-        Set<LinkWrapper> links = new LinkedHashSet<LinkWrapper>();\n-        Set<VertexWrapper> vertices = new LinkedHashSet<VertexWrapper>();\n-        Map<N, VertexWrapper> vertexMap = new HashMap<N, VertexWrapper>();\n+        Set<LinkWrapper> links = new LinkedHashSet<>();\n+        Set<VertexWrapper> vertices = new LinkedHashSet<>();\n+        Map<N, VertexWrapper> vertexMap = new HashMap<>();\n","filename":"src\/utils\/IdealGraphVisualizer\/ControlFlow\/src\/main\/java\/com\/sun\/hotspot\/igv\/controlflow\/HierarchicalGraphLayout.java","additions":12,"deletions":21,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -13,0 +13,1 @@\n+                <attr name=\"position\" intvalue=\"2\"\/>\n","filename":"src\/utils\/IdealGraphVisualizer\/ControlFlow\/src\/main\/resources\/com\/sun\/hotspot\/igv\/controlflow\/layer.xml","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import java.util.List;\n@@ -32,0 +31,1 @@\n+import java.util.List;\n@@ -47,2 +47,2 @@\n-    private InstanceContent content;\n-    private FolderChildren children;\n+    private final InstanceContent content;\n+    private final FolderChildren children;\n@@ -51,1 +51,1 @@\n-    private static Map<InputGraph, GraphNode> graphNode = new HashMap<>();\n+    private static final Map<InputGraph, GraphNode> graphNode = new HashMap<>();\n@@ -125,6 +125,3 @@\n-            content.add(new RemoveCookie() {\n-                @Override\n-                public void remove() {\n-                    children.destroyNodes(children.getNodes());\n-                    folderElement.getParent().removeElement(folderElement);\n-                }\n+            content.add((RemoveCookie) () -> {\n+                children.destroyNodes(children.getNodes());\n+                folderElement.getParent().removeElement(folderElement);\n@@ -146,1 +143,1 @@\n-        return (folder != null && folder instanceof GraphDocument);\n+        return (folder instanceof GraphDocument);\n","filename":"src\/utils\/IdealGraphVisualizer\/Coordinator\/src\/main\/java\/com\/sun\/hotspot\/igv\/coordinator\/FolderNode.java","additions":8,"deletions":11,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -26,6 +26,1 @@\n-import com.sun.hotspot.igv.coordinator.actions.CloneGraphAction;\n-import com.sun.hotspot.igv.coordinator.actions.DiffGraphAction;\n-import com.sun.hotspot.igv.coordinator.actions.DiffGraphCookie;\n-import com.sun.hotspot.igv.coordinator.actions.GraphCloneCookie;\n-import com.sun.hotspot.igv.coordinator.actions.GraphOpenCookie;\n-import com.sun.hotspot.igv.coordinator.actions.GraphRemoveCookie;\n+import com.sun.hotspot.igv.coordinator.actions.*;\n@@ -39,6 +34,1 @@\n-import org.openide.nodes.AbstractNode;\n-import org.openide.nodes.Children;\n-import org.openide.nodes.NodeAdapter;\n-import org.openide.nodes.NodeEvent;\n-import org.openide.nodes.NodeMemberEvent;\n-import org.openide.nodes.Sheet;\n+import org.openide.nodes.*;\n@@ -115,1 +105,1 @@\n-        return new Action[]{(Action) DiffGraphAction.findObject(DiffGraphAction.class, true), (Action) CloneGraphAction.findObject(CloneGraphAction.class, true), (Action) OpenAction.findObject(OpenAction.class, true)};\n+        return new Action[]{DiffGraphAction.findObject(DiffGraphAction.class, true), CloneGraphAction.findObject(CloneGraphAction.class, true), OpenAction.findObject(OpenAction.class, true)};\n@@ -120,1 +110,1 @@\n-        return (Action) OpenAction.findObject(OpenAction.class, true);\n+        return OpenAction.findObject(OpenAction.class, true);\n","filename":"src\/utils\/IdealGraphVisualizer\/Coordinator\/src\/main\/java\/com\/sun\/hotspot\/igv\/coordinator\/GraphNode.java","additions":4,"deletions":14,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -40,1 +40,0 @@\n-import java.io.Serializable;\n@@ -66,1 +65,1 @@\n-    private GraphDocument document;\n+    private final GraphDocument document;\n@@ -68,2 +67,0 @@\n-    private Server server;\n-    private Server binaryServer;\n@@ -73,1 +70,0 @@\n-\n@@ -103,1 +99,1 @@\n-        toolbar.add(((NodeAction) SaveAsAction.get(SaveAsAction.class)).createContextAwareInstance(this.getLookup()));\n+        toolbar.add((SaveAsAction.get(SaveAsAction.class)).createContextAwareInstance(this.getLookup()));\n@@ -109,1 +105,1 @@\n-        toolbar.add(((NodeAction) RemoveAction.get(RemoveAction.class)).createContextAwareInstance(this.getLookup()));\n+        toolbar.add((RemoveAction.get(RemoveAction.class)).createContextAwareInstance(this.getLookup()));\n@@ -132,8 +128,4 @@\n-        final GroupCallback callback = new GroupCallback() {\n-\n-            @Override\n-            public void started(Group g) {\n-                synchronized(OutlineTopComponent.this) {\n-                    getDocument().addElement(g);\n-                    g.setParent(getDocument());\n-                }\n+        final GroupCallback callback = g -> {\n+            synchronized(OutlineTopComponent.this) {\n+                g.setParent(getDocument());\n+                getDocument().addElement(g);\n@@ -143,2 +135,1 @@\n-        server = new Server(getDocument(), callback, false);\n-        binaryServer = new Server(getDocument(), callback, true);\n+        Server server = new Server(callback);\n@@ -188,1 +179,1 @@\n-     * To obtain the singleton instance, use {@link findInstance}.\n+     * To obtain the singleton instance, use {@link #findInstance()}.\n@@ -220,1 +211,1 @@\n-        Lookup.Template<InputGraphProvider> tpl = new Lookup.Template<InputGraphProvider>(InputGraphProvider.class);\n+        Lookup.Template<InputGraphProvider> tpl = new Lookup.Template<>(InputGraphProvider.class);\n@@ -263,1 +254,1 @@\n-        SwingUtilities.invokeLater(() -> updateGraphSelection());\n+        SwingUtilities.invokeLater(this::updateGraphSelection);\n@@ -278,9 +269,0 @@\n-    static final class ResolvableHelper implements Serializable {\n-\n-        private static final long serialVersionUID = 1L;\n-\n-        public Object readResolve() {\n-            return OutlineTopComponent.getDefault();\n-        }\n-    }\n-\n","filename":"src\/utils\/IdealGraphVisualizer\/Coordinator\/src\/main\/java\/com\/sun\/hotspot\/igv\/coordinator\/OutlineTopComponent.java","additions":11,"deletions":29,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-    private InputGraph graph;\n+    private final InputGraph graph;\n@@ -62,0 +62,1 @@\n+            assert other != null;\n","filename":"src\/utils\/IdealGraphVisualizer\/Coordinator\/src\/main\/java\/com\/sun\/hotspot\/igv\/coordinator\/actions\/DiffGraphCookie.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import com.sun.hotspot.igv.data.serialization.BinaryParser;\n@@ -34,1 +33,0 @@\n-import java.awt.event.ActionEvent;\n@@ -42,0 +40,1 @@\n+import javax.swing.Action;\n@@ -45,1 +44,0 @@\n-import javax.swing.Action;\n@@ -48,4 +46,1 @@\n-import org.openide.util.Exceptions;\n-import org.openide.util.RequestProcessor;\n-import org.openide.util.HelpCtx;\n-import org.openide.util.NbBundle;\n+import org.openide.util.*;\n@@ -53,1 +48,0 @@\n-import org.openide.util.Utilities;\n@@ -68,1 +62,1 @@\n-                return f.getName().toLowerCase().endsWith(\".xml\") || f.getName().toLowerCase().endsWith(\".bgv\") || f.isDirectory();\n+                return f.getName().toLowerCase().endsWith(\".xml\") || f.isDirectory();\n@@ -73,1 +67,1 @@\n-                return \"Graph files (*.xml, *.bgv)\";\n+                return \"Graph files (*.xml)\";\n@@ -105,2 +99,1 @@\n-                                } catch (IOException ex) {\n-                                }\n+                                } catch (IOException ignored) {}\n@@ -118,2 +111,0 @@\n-                    } else if (file.getName().endsWith(\".bgv\")) {\n-                        parser = new BinaryParser(channel, monitor, component.getDocument(), null);\n@@ -129,7 +120,4 @@\n-                                        SwingUtilities.invokeLater(new Runnable(){\n-                                                @Override\n-                                                public void run() {\n-                                                    component.requestActive();\n-                                                    component.getDocument().addGraphDocument(document);\n-                                                }\n-                                            });\n+                                        SwingUtilities.invokeLater(() -> {\n+                                            component.requestActive();\n+                                            component.getDocument().addGraphDocument(document);\n+                                        });\n@@ -145,2 +133,0 @@\n-                } catch (FileNotFoundException ex) {\n-                    Exceptions.printStackTrace(ex);\n","filename":"src\/utils\/IdealGraphVisualizer\/Coordinator\/src\/main\/java\/com\/sun\/hotspot\/igv\/coordinator\/actions\/ImportAction.java","additions":9,"deletions":23,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-import java.awt.event.InputEvent;\n-import java.awt.event.KeyEvent;\n@@ -31,1 +29,0 @@\n-import javax.swing.KeyStroke;\n","filename":"src\/utils\/IdealGraphVisualizer\/Coordinator\/src\/main\/java\/com\/sun\/hotspot\/igv\/coordinator\/actions\/RemoveAllAction.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-import java.awt.event.InputEvent;\n-import java.awt.event.KeyEvent;\n@@ -31,1 +29,0 @@\n-import javax.swing.KeyStroke;\n@@ -34,2 +31,0 @@\n-import org.openide.util.NbBundle.Messages;\n-import org.openide.util.actions.CallableSystemAction;\n@@ -37,0 +32,1 @@\n+import org.openide.util.actions.CallableSystemAction;\n","filename":"src\/utils\/IdealGraphVisualizer\/Coordinator\/src\/main\/java\/com\/sun\/hotspot\/igv\/coordinator\/actions\/SaveAllAction.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -55,1 +55,0 @@\n-        final OutlineTopComponent component = OutlineTopComponent.findInstance();\n@@ -91,2 +90,0 @@\n-            } catch (FileNotFoundException e) {\n-                e.printStackTrace();\n@@ -95,1 +92,0 @@\n-\n@@ -100,4 +96,0 @@\n-    protected int mode() {\n-        return CookieAction.MODE_SOME;\n-    }\n-\n","filename":"src\/utils\/IdealGraphVisualizer\/Coordinator\/src\/main\/java\/com\/sun\/hotspot\/igv\/coordinator\/actions\/SaveAsAction.java","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-    \n+\n@@ -49,0 +49,1 @@\n+            <attr name=\"position\" intvalue=\"50\"\/>\n@@ -99,1 +100,1 @@\n-        \n+\n@@ -101,0 +102,1 @@\n+            <attr name=\"position\" intvalue=\"100\"\/>\n@@ -133,1 +135,1 @@\n-        \n+\n@@ -135,0 +137,1 @@\n+            <attr name=\"position\" intvalue=\"150\"\/>\n@@ -151,1 +154,1 @@\n-        \n+\n@@ -162,0 +165,1 @@\n+            <attr name=\"position\" intvalue=\"200\"\/>\n@@ -164,0 +168,1 @@\n+                <attr name=\"position\" intvalue=\"1\"\/>\n@@ -168,0 +173,1 @@\n+            <attr name=\"position\" intvalue=\"250\"\/>\n@@ -170,0 +176,1 @@\n+                <attr name=\"position\" intvalue=\"4\"\/>\n@@ -191,0 +198,1 @@\n+            <attr name=\"position\" intvalue=\"300\"\/>\n@@ -217,1 +225,1 @@\n-    \n+\n@@ -222,1 +230,1 @@\n-        <folder name=\"Modes\">  \n+        <folder name=\"Modes\">\n","filename":"src\/utils\/IdealGraphVisualizer\/Coordinator\/src\/main\/resources\/com\/sun\/hotspot\/igv\/coordinator\/layer.xml","additions":14,"deletions":6,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-    private T object;\n+    private final T object;\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/main\/java\/com\/sun\/hotspot\/igv\/data\/ChangedEvent.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-    private List<L> listener;\n+    private final List<L> listener;\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/main\/java\/com\/sun\/hotspot\/igv\/data\/Event.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,2 +35,2 @@\n-    private List<FolderElement> elements;\n-    private ChangedEvent<GraphDocument> changedEvent;\n+    private final List<FolderElement> elements;\n+    private final ChangedEvent<GraphDocument> changedEvent;\n@@ -61,1 +61,0 @@\n-        getChangedEvent().fire();\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/main\/java\/com\/sun\/hotspot\/igv\/data\/GraphDocument.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-    private final List<FolderElement> elements;\n@@ -36,1 +35,0 @@\n-\n@@ -38,1 +36,1 @@\n-    private transient ChangedEvent<Group> changedEvent;\n+    private final transient ChangedEvent<Group> changedEvent;\n@@ -42,1 +40,0 @@\n-        elements = new ArrayList<>();\n@@ -47,1 +44,1 @@\n-        \/\/ Ensure that name and type are never null\n+        \/\/ Ensure that name is never null\n@@ -49,5 +46,0 @@\n-        getProperties().setProperty(\"type\", \"\");\n-    }\n-\n-    public void fireChangedEvent() {\n-        changedEvent.fire();\n@@ -70,2 +62,5 @@\n-    public List<FolderElement> getElements() {\n-        return Collections.unmodifiableList(elements);\n+    public void addElement(FolderElement element) {\n+        assert element instanceof InputGraph;\n+        graphs.add((InputGraph) element);\n+        element.setParent(this);\n+        getChangedEvent().fire();\n@@ -74,2 +69,6 @@\n-    public int getGraphsCount() {\n-        return elements.size();\n+    @Override\n+    public void removeElement(FolderElement element) {\n+        assert element instanceof InputGraph;\n+        if (graphs.remove((InputGraph) element)) {\n+            getChangedEvent().fire();\n+        }\n@@ -79,5 +78,3 @@\n-    public void addElement(FolderElement element) {\n-        elements.add(element);\n-        if (element instanceof InputGraph) {\n-            graphs.add((InputGraph) element);\n-        } else {\n+    public List<FolderElement> getElements() {\n+        return Collections.unmodifiableList(graphs);\n+    }\n@@ -85,3 +82,2 @@\n-        }\n-        element.setParent(this);\n-        changedEvent.fire();\n+    public List<InputGraph> getGraphs() {\n+        return Collections.unmodifiableList(graphs);\n@@ -92,5 +88,2 @@\n-        for (FolderElement e : elements) {\n-            if (e instanceof InputGraph) {\n-                InputGraph g = (InputGraph) e;\n-                result.addAll(g.getNodesAsSet());\n-            }\n+        for (InputGraph g : graphs) {\n+            result.addAll(g.getNodesAsSet());\n@@ -105,1 +98,1 @@\n-        for (FolderElement g : elements) {\n+        for (FolderElement g : getElements()) {\n@@ -117,40 +110,0 @@\n-    public String getType() {\n-        return getProperties().get(\"type\");\n-\n-    }\n-\n-    InputGraph getPrev(InputGraph graph) {\n-        InputGraph lastGraph = null;\n-        for (FolderElement e : elements) {\n-            if (e == graph) {\n-                return lastGraph;\n-            }\n-            if (e instanceof InputGraph) {\n-                lastGraph = (InputGraph) e;\n-            }\n-        }\n-        return null;\n-    }\n-\n-    InputGraph getNext(InputGraph graph) {\n-        boolean found = false;\n-        for (FolderElement e : elements) {\n-            if (e == graph) {\n-                found = true;\n-            } else if (found && e instanceof InputGraph) {\n-                return (InputGraph) e;\n-            }\n-        }\n-        return null;\n-    }\n-\n-    public InputGraph getLastGraph() {\n-        InputGraph lastGraph = null;\n-        for (FolderElement e : elements) {\n-            if (e instanceof InputGraph) {\n-                lastGraph = (InputGraph) e;\n-            }\n-        }\n-        return lastGraph;\n-    }\n-\n@@ -161,15 +114,0 @@\n-\n-    @Override\n-    public void removeElement(FolderElement element) {\n-        if (elements.remove(element)) {\n-            if (element instanceof InputGraph) {\n-                graphs.remove((InputGraph) element);\n-            }\n-            changedEvent.fire();\n-        }\n-    }\n-\n-    public List<InputGraph> getGraphs() {\n-        return graphs;\n-    }\n-\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/main\/java\/com\/sun\/hotspot\/igv\/data\/Group.java","additions":21,"deletions":83,"binary":false,"changes":104,"status":"modified"},{"patch":"@@ -35,3 +35,3 @@\n-    private String name;\n-    private InputGraph graph;\n-    private Set<InputBlock> successors;\n+    private final String name;\n+    private final InputGraph graph;\n+    private final Set<InputBlock> successors;\n@@ -52,1 +52,1 @@\n-        if (o == null || (!(o instanceof InputBlock))) {\n+        if ((!(o instanceof InputBlock))) {\n@@ -116,3 +116,1 @@\n-        if (!successors.contains(b)) {\n-            successors.add(b);\n-        }\n+        successors.add(b);\n@@ -121,2 +119,2 @@\n-    void setArtificial(boolean artificial) {\n-        this.artificial = artificial;\n+    void setArtificial() {\n+        this.artificial = true;\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/main\/java\/com\/sun\/hotspot\/igv\/data\/InputBlock.java","additions":7,"deletions":9,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -38,2 +38,2 @@\n-    private InputBlock from;\n-    private InputBlock to;\n+    private final InputBlock from;\n+    private final InputBlock to;\n@@ -41,1 +41,1 @@\n-    private String label;\n+    private final String label;\n@@ -73,1 +73,1 @@\n-        if (obj != null && obj instanceof InputBlockEdge) {\n+        if (obj instanceof InputBlockEdge) {\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/main\/java\/com\/sun\/hotspot\/igv\/data\/InputBlockEdge.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -32,4 +32,4 @@\n-    private int bci;\n-    private String name;\n-    private String operands;\n-    private String comment;\n+    private final int bci;\n+    private final String name;\n+    private final String operands;\n+    private final String comment;\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/main\/java\/com\/sun\/hotspot\/igv\/data\/InputBytecode.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n-import java.util.Comparator;\n-import java.util.WeakHashMap;\n@@ -29,0 +27,2 @@\n+import java.util.Objects;\n+import java.util.WeakHashMap;\n@@ -43,22 +43,0 @@\n-    public static final Comparator<InputEdge> OUTGOING_COMPARATOR = new Comparator<InputEdge>(){\n-\n-        @Override\n-            public int compare(InputEdge o1, InputEdge o2) {\n-                if(o1.getFromIndex() == o2.getFromIndex()) {\n-                    return o1.getTo() - o2.getTo();\n-                }\n-                return o1.getFromIndex() - o2.getFromIndex();\n-            }\n-    };\n-\n-    public static final Comparator<InputEdge> INGOING_COMPARATOR = new Comparator<InputEdge>(){\n-\n-        @Override\n-            public int compare(InputEdge o1, InputEdge o2) {\n-                if(o1.getToIndex() == o2.getToIndex()) {\n-                    return o1.getFrom() - o2.getFrom();\n-                }\n-                return o1.getToIndex() - o2.getToIndex();\n-            }\n-    };\n-\n@@ -73,8 +51,0 @@\n-    public InputEdge(char toIndex, int from, int to) {\n-        this((char) 0, toIndex, from, to, null, null);\n-    }\n-\n-    public InputEdge(char fromIndex, char toIndex, int from, int to) {\n-        this(fromIndex, toIndex, from, to, null, null);\n-    }\n-\n@@ -157,1 +127,1 @@\n-        if (o == null || !(o instanceof InputEdge)) {\n+        if (!(o instanceof InputEdge)) {\n@@ -164,1 +134,1 @@\n-            return conn2.label == label && conn2.state == state;\n+            return Objects.equals(conn2.label, label) && conn2.state == state;\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/main\/java\/com\/sun\/hotspot\/igv\/data\/InputEdge.java","additions":4,"deletions":34,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -34,2 +34,2 @@\n-    private Map<Integer, InputNode> nodes;\n-    private List<InputEdge> edges;\n+    private final Map<Integer, InputNode> nodes;\n+    private final List<InputEdge> edges;\n@@ -38,3 +38,3 @@\n-    private Map<String, InputBlock> blocks;\n-    private List<InputBlockEdge> blockEdges;\n-    private Map<Integer, InputBlock> nodeToBlock;\n+    private final Map<String, InputBlock> blocks;\n+    private final List<InputBlockEdge> blockEdges;\n+    private final Map<Integer, InputBlock> nodeToBlock;\n@@ -82,74 +82,0 @@\n-    public List<InputNode> findRootNodes() {\n-        List<InputNode> result = new ArrayList<>();\n-        Set<Integer> nonRoot = new HashSet<>();\n-        for(InputEdge curEdges : getEdges()) {\n-            nonRoot.add(curEdges.getTo());\n-        }\n-\n-        for(InputNode node : getNodes()) {\n-            if(!nonRoot.contains(node.getId())) {\n-                result.add(node);\n-            }\n-        }\n-\n-        return result;\n-    }\n-\n-    public Map<InputNode, List<InputEdge>> findAllOutgoingEdges() {\n-        Map<InputNode, List<InputEdge>> result = new HashMap<>(getNodes().size());\n-        for(InputNode n : this.getNodes()) {\n-            result.put(n, new ArrayList<InputEdge>());\n-        }\n-\n-        for(InputEdge e : this.edges) {\n-            int from = e.getFrom();\n-            InputNode fromNode = this.getNode(from);\n-            List<InputEdge> fromList = result.get(fromNode);\n-            assert fromList != null;\n-            fromList.add(e);\n-        }\n-\n-        for(InputNode n : this.getNodes()) {\n-            List<InputEdge> list = result.get(n);\n-            list.sort(InputEdge.OUTGOING_COMPARATOR);\n-        }\n-\n-        return result;\n-    }\n-\n-    public Map<InputNode, List<InputEdge>> findAllIngoingEdges() {\n-        Map<InputNode, List<InputEdge>> result = new HashMap<>(getNodes().size());\n-        for(InputNode n : this.getNodes()) {\n-            result.put(n, new ArrayList<InputEdge>());\n-        }\n-\n-        for(InputEdge e : this.edges) {\n-            int to = e.getTo();\n-            InputNode toNode = this.getNode(to);\n-            List<InputEdge> toList = result.get(toNode);\n-            assert toList != null;\n-            toList.add(e);\n-        }\n-\n-        for(InputNode n : this.getNodes()) {\n-            List<InputEdge> list = result.get(n);\n-            list.sort(InputEdge.INGOING_COMPARATOR);\n-        }\n-\n-        return result;\n-    }\n-\n-    public List<InputEdge> findOutgoingEdges(InputNode n) {\n-        List<InputEdge> result = new ArrayList<>();\n-\n-        for(InputEdge e : this.edges) {\n-            if(e.getFrom() == n.getId()) {\n-                result.add(e);\n-            }\n-        }\n-\n-        result.sort(InputEdge.OUTGOING_COMPARATOR);\n-\n-        return result;\n-    }\n-\n@@ -162,10 +88,0 @@\n-    public void setEdge(int fromIndex, int toIndex, int from, int to) {\n-        assert fromIndex == ((char)fromIndex) : \"Downcast must be safe\";\n-        assert toIndex == ((char)toIndex) : \"Downcast must be safe\";\n-\n-        InputEdge edge = new InputEdge((char)fromIndex, (char)toIndex, from, to);\n-        if(!this.getEdges().contains(edge)) {\n-            this.addEdge(edge);\n-        }\n-    }\n-\n@@ -209,8 +125,0 @@\n-    public InputGraph getNext() {\n-        return parentGroup.getNext(this);\n-    }\n-\n-    public InputGraph getPrev() {\n-        return parentGroup.getPrev(this);\n-    }\n-\n@@ -291,1 +199,1 @@\n-        b.setArtificial(true);\n+        b.setArtificial();\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/main\/java\/com\/sun\/hotspot\/igv\/data\/InputGraph.java","additions":6,"deletions":98,"binary":false,"changes":104,"status":"modified"},{"patch":"@@ -38,4 +38,4 @@\n-    private String name;\n-    private int bci;\n-    private String shortName;\n-    private List<InputMethod> inlined;\n+    private final String name;\n+    private final int bci;\n+    private final String shortName;\n+    private final List<InputMethod> inlined;\n@@ -43,2 +43,2 @@\n-    private Group group;\n-    private List<InputBytecode> bytecodes;\n+    private final Group group;\n+    private final List<InputBytecode> bytecodes;\n@@ -58,1 +58,1 @@\n-        if (o == null || (!(o instanceof InputMethod))) {\n+        if ((!(o instanceof InputMethod))) {\n@@ -61,2 +61,1 @@\n-\n-        final InputMethod im = (InputMethod)o;\n+        final InputMethod im = (InputMethod) o;\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/main\/java\/com\/sun\/hotspot\/igv\/data\/InputMethod.java","additions":8,"deletions":9,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -26,4 +26,0 @@\n-import java.util.ArrayList;\n-import java.util.Comparator;\n-import java.util.List;\n-\n@@ -37,31 +33,0 @@\n-    private List<InputGraph> subgraphs;\n-\n-    public static final Comparator<InputNode> COMPARATOR = new Comparator<InputNode>() {\n-        @Override\n-        public int compare(InputNode o1, InputNode o2) {\n-            return o1.getId() - o2.getId();\n-        }\n-    };\n-\n-    public static Comparator<InputNode> getPropertyComparator(final String propertyName) {\n-        return new Comparator<InputNode>() {\n-\n-            @Override\n-            public int compare(InputNode o1, InputNode o2) {\n-\n-                int i1 = 0;\n-                try {\n-                    i1 = Integer.parseInt(o1.getProperties().get(propertyName));\n-                } catch(NumberFormatException e) {\n-                }\n-\n-                int i2 = 0;\n-                try {\n-                    i2 = Integer.parseInt(o2.getProperties().get(propertyName));\n-                } catch(NumberFormatException e) {\n-                }\n-\n-                return i1 - i2;\n-            }\n-        };\n-    }\n@@ -86,11 +51,0 @@\n-    public void addSubgraph(InputGraph graph) {\n-        if (subgraphs == null) {\n-            subgraphs = new ArrayList<>();\n-        }\n-        subgraphs.add(graph);\n-    }\n-\n-    public List<InputGraph> getSubgraphs() {\n-        return subgraphs;\n-    }\n-\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/main\/java\/com\/sun\/hotspot\/igv\/data\/InputNode.java","additions":0,"deletions":46,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -61,1 +61,1 @@\n-        if (o == null || !(o instanceof Pair)) {\n+        if (!(o instanceof Pair<?, ?>)) {\n@@ -64,1 +64,1 @@\n-        Pair<?,?> obj = (Pair<?,?>) o;\n+        Pair<?, ?> obj = (Pair<?, ?>) o;\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/main\/java\/com\/sun\/hotspot\/igv\/data\/Pair.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import java.util.Map.Entry;\n@@ -191,1 +190,1 @@\n-        private PropertyMatcher matcher;\n+        private final PropertyMatcher matcher;\n@@ -213,2 +212,2 @@\n-        private String name;\n-        private String value;\n+        private final String name;\n+        private final String value;\n@@ -243,2 +242,2 @@\n-        private String name;\n-        private Pattern valuePattern;\n+        private final String name;\n+        private final Pattern valuePattern;\n@@ -315,7 +314,4 @@\n-        pairs.sort(new Comparator<String[]>() {\n-            @Override\n-            public int compare(String[] o1, String[] o2) {\n-                assert o1.length == 2;\n-                assert o2.length == 2;\n-                return o1[0].compareTo(o2[0]);\n-            }\n+        pairs.sort((o1, o2) -> {\n+            assert o1.length == 2;\n+            assert o2.length == 2;\n+            return o1[0].compareTo(o2[0]);\n@@ -340,1 +336,1 @@\n-        private Collection<T> objects;\n+        private final Collection<T> objects;\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/main\/java\/com\/sun\/hotspot\/igv\/data\/Properties.java","additions":10,"deletions":14,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -35,2 +35,2 @@\n-    private String name;\n-    private String value;\n+    private final String name;\n+    private final String value;\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/main\/java\/com\/sun\/hotspot\/igv\/data\/Property.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -34,2 +34,2 @@\n-    private List<InputNode> sourceNodes;\n-    private Set<Integer> set;\n+    private final List<InputNode> sourceNodes;\n+    private final Set<Integer> set;\n@@ -59,1 +59,1 @@\n-        public Source getSource();\n+        Source getSource();\n@@ -62,5 +62,0 @@\n-    public void addSourceNodes(Source s) {\n-        for (InputNode n : s.getSourceNodes()) {\n-            addSourceNode(n);\n-        }\n-    }\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/main\/java\/com\/sun\/hotspot\/igv\/data\/Source.java","additions":3,"deletions":8,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1,937 +0,0 @@\n-\/*\n- * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package com.sun.hotspot.igv.data.serialization;\n-\n-import com.sun.hotspot.igv.data.*;\n-import com.sun.hotspot.igv.data.Properties;\n-import com.sun.hotspot.igv.data.services.GroupCallback;\n-import java.io.EOFException;\n-import java.io.IOException;\n-import java.nio.ByteBuffer;\n-import java.nio.channels.ReadableByteChannel;\n-import java.util.*;\n-import java.util.regex.Matcher;\n-import java.util.regex.Pattern;\n-import javax.swing.SwingUtilities;\n-import java.security.MessageDigest;\n-import java.security.NoSuchAlgorithmException;\n-\n-import static java.nio.charset.StandardCharsets.UTF_8;\n-\n-public class BinaryParser implements GraphParser {\n-    private static final int BEGIN_GROUP = 0x00;\n-    private static final int BEGIN_GRAPH = 0x01;\n-    private static final int CLOSE_GROUP = 0x02;\n-\n-    private static final int POOL_NEW = 0x00;\n-    private static final int POOL_STRING = 0x01;\n-    private static final int POOL_ENUM = 0x02;\n-    private static final int POOL_CLASS = 0x03;\n-    private static final int POOL_METHOD = 0x04;\n-    private static final int POOL_NULL = 0x05;\n-    private static final int POOL_NODE_CLASS = 0x06;\n-    private static final int POOL_FIELD = 0x07;\n-    private static final int POOL_SIGNATURE = 0x08;\n-\n-    private static final int KLASS = 0x00;\n-    private static final int ENUM_KLASS = 0x01;\n-\n-    private static final int PROPERTY_POOL = 0x00;\n-    private static final int PROPERTY_INT = 0x01;\n-    private static final int PROPERTY_LONG = 0x02;\n-    private static final int PROPERTY_DOUBLE = 0x03;\n-    private static final int PROPERTY_FLOAT = 0x04;\n-    private static final int PROPERTY_TRUE = 0x05;\n-    private static final int PROPERTY_FALSE = 0x06;\n-    private static final int PROPERTY_ARRAY = 0x07;\n-    private static final int PROPERTY_SUBGRAPH = 0x08;\n-\n-    private static final String NO_BLOCK = \"noBlock\";\n-\n-    private final GroupCallback callback;\n-    private final List<Object> constantPool;\n-    private final ByteBuffer buffer;\n-    private final ReadableByteChannel channel;\n-    private final GraphDocument rootDocument;\n-    private final Deque<Folder> folderStack;\n-    private final Deque<byte[]> hashStack;\n-    private final ParseMonitor monitor;\n-\n-    private MessageDigest digest;\n-\n-    private enum Length {\n-        S,\n-        M,\n-        L\n-    }\n-\n-    private interface LengthToString {\n-        String toString(Length l);\n-    }\n-\n-    private abstract static class Member implements LengthToString {\n-        public final Klass holder;\n-        public final int accessFlags;\n-        public final String name;\n-        public Member(Klass holder, String name, int accessFlags) {\n-            this.holder = holder;\n-            this.accessFlags = accessFlags;\n-            this.name = name;\n-        }\n-    }\n-\n-    private static class Method extends Member {\n-        public final Signature signature;\n-        public final byte[] code;\n-        public Method(String name, Signature signature, byte[] code, Klass holder, int accessFlags) {\n-            super(holder, name, accessFlags);\n-            this.signature = signature;\n-            this.code = code;\n-        }\n-        @Override\n-        public String toString() {\n-            StringBuilder sb = new StringBuilder();\n-            sb.append(holder).append('.').append(name).append('(');\n-            for (int i = 0; i < signature.argTypes.length; i++) {\n-                if (i > 0) {\n-                    sb.append(\", \");\n-                }\n-                sb.append(signature.argTypes[i]);\n-            }\n-            sb.append(')');\n-            return sb.toString();\n-        }\n-        @Override\n-        public String toString(Length l) {\n-            switch(l) {\n-                case M:\n-                    return holder.toString(Length.L) + \".\" + name;\n-                case S:\n-                    return holder.toString(Length.S) + \".\" + name;\n-                default:\n-                case L:\n-                    return toString();\n-            }\n-        }\n-    }\n-\n-    private static class Signature {\n-        public final String returnType;\n-        public final String[] argTypes;\n-        public Signature(String returnType, String[] argTypes) {\n-            this.returnType = returnType;\n-            this.argTypes = argTypes;\n-        }\n-    }\n-\n-    private static class Field extends Member {\n-        public final String type;\n-        public Field(String type, Klass holder, String name, int accessFlags) {\n-            super(holder, name, accessFlags);\n-            this.type = type;\n-        }\n-        @Override\n-        public String toString() {\n-            return holder + \".\" + name;\n-        }\n-        @Override\n-        public String toString(Length l) {\n-            switch(l) {\n-                case M:\n-                    return holder.toString(Length.L) + \".\" + name;\n-                case S:\n-                    return holder.toString(Length.S) + \".\" + name;\n-                default:\n-                case L:\n-                    return toString();\n-            }\n-        }\n-    }\n-\n-    private static class Klass implements LengthToString {\n-        public final String name;\n-        public final String simpleName;\n-        public Klass(String name) {\n-            this.name = name;\n-            String simple;\n-            try {\n-                simple = name.substring(name.lastIndexOf('.') + 1);\n-            } catch (IndexOutOfBoundsException ioobe) {\n-                simple = name;\n-            }\n-            this.simpleName = simple;\n-        }\n-        @Override\n-        public String toString() {\n-            return name;\n-        }\n-        @Override\n-        public String toString(Length l) {\n-            switch(l) {\n-                case S:\n-                    return simpleName;\n-                default:\n-                case L:\n-                case M:\n-                    return toString();\n-            }\n-        }\n-    }\n-\n-    private static class EnumKlass extends Klass {\n-        public final String[] values;\n-        public EnumKlass(String name, String[] values) {\n-            super(name);\n-            this.values = values;\n-        }\n-    }\n-\n-    private static class Port {\n-        public final boolean isList;\n-        public final String name;\n-        private Port(boolean isList, String name) {\n-            this.isList = isList;\n-            this.name = name;\n-        }\n-    }\n-\n-    private static class TypedPort extends Port {\n-        public final EnumValue type;\n-        private TypedPort(boolean isList, String name, EnumValue type) {\n-            super(isList, name);\n-            this.type = type;\n-        }\n-    }\n-\n-    private static class NodeClass {\n-        public final String className;\n-        public final String nameTemplate;\n-        public final List<TypedPort> inputs;\n-        public final List<Port> sux;\n-        private NodeClass(String className, String nameTemplate, List<TypedPort> inputs, List<Port> sux) {\n-            this.className = className;\n-            this.nameTemplate = nameTemplate;\n-            this.inputs = inputs;\n-            this.sux = sux;\n-        }\n-        @Override\n-        public String toString() {\n-            return className;\n-        }\n-    }\n-\n-    private static class EnumValue implements LengthToString {\n-        public EnumKlass enumKlass;\n-        public int ordinal;\n-        public EnumValue(EnumKlass enumKlass, int ordinal) {\n-            this.enumKlass = enumKlass;\n-            this.ordinal = ordinal;\n-        }\n-        @Override\n-        public String toString() {\n-            return enumKlass.simpleName + \".\" + enumKlass.values[ordinal];\n-        }\n-        @Override\n-        public String toString(Length l) {\n-            switch(l) {\n-                case S:\n-                    return enumKlass.values[ordinal];\n-                default:\n-                case M:\n-                case L:\n-                    return toString();\n-            }\n-        }\n-    }\n-\n-    public BinaryParser(ReadableByteChannel channel, ParseMonitor monitor, GraphDocument rootDocument, GroupCallback callback) {\n-        this.callback = callback;\n-        constantPool = new ArrayList<>();\n-        buffer = ByteBuffer.allocateDirect(256 * 1024);\n-        buffer.flip();\n-        this.channel = channel;\n-        this.rootDocument = rootDocument;\n-        folderStack = new LinkedList<>();\n-        hashStack = new LinkedList<>();\n-        this.monitor = monitor;\n-        try {\n-            this.digest = MessageDigest.getInstance(\"SHA-1\");\n-        } catch (NoSuchAlgorithmException e) {\n-        }\n-    }\n-\n-    private void fill() throws IOException {\n-        \/\/ All the data between lastPosition and position has been\n-        \/\/ used so add it to the digest.\n-        int position = buffer.position();\n-        buffer.position(lastPosition);\n-        byte[] remaining = new byte[position - buffer.position()];\n-        buffer.get(remaining);\n-        digest.update(remaining);\n-        assert position == buffer.position();\n-\n-        buffer.compact();\n-        if (channel.read(buffer) < 0) {\n-            throw new EOFException();\n-        }\n-        buffer.flip();\n-        lastPosition = buffer.position();\n-    }\n-\n-    private void ensureAvailable(int i) throws IOException {\n-        if (i > buffer.capacity()) {\n-            throw new IllegalArgumentException(String.format(\"Can not request %d bytes: buffer capacity is %d\", i, buffer.capacity()));\n-        }\n-        while (buffer.remaining() < i) {\n-            fill();\n-        }\n-    }\n-\n-    private int readByte() throws IOException {\n-        ensureAvailable(1);\n-        return ((int)buffer.get()) & 0xff;\n-    }\n-\n-    private int readInt() throws IOException {\n-        ensureAvailable(4);\n-        return buffer.getInt();\n-    }\n-\n-    private char readShort() throws IOException {\n-        ensureAvailable(2);\n-        return buffer.getChar();\n-    }\n-\n-    private long readLong() throws IOException {\n-        ensureAvailable(8);\n-        return buffer.getLong();\n-    }\n-\n-    private double readDouble() throws IOException {\n-        ensureAvailable(8);\n-        return buffer.getDouble();\n-    }\n-\n-    private float readFloat() throws IOException {\n-        ensureAvailable(4);\n-        return buffer.getFloat();\n-    }\n-\n-    private String readString() throws IOException {\n-        return new String(readBytes(), UTF_8).intern();\n-    }\n-\n-    private byte[] readBytes() throws IOException {\n-        int len = readInt();\n-        if (len < 0) {\n-            return null;\n-        }\n-        byte[] b = new byte[len];\n-        int bytesRead = 0;\n-        while (bytesRead < b.length) {\n-            int toRead = Math.min(b.length - bytesRead, buffer.capacity());\n-            ensureAvailable(toRead);\n-            buffer.get(b, bytesRead, toRead);\n-            bytesRead += toRead;\n-        }\n-        return b;\n-    }\n-\n-    private String readIntsToString() throws IOException {\n-        int len = readInt();\n-        if (len < 0) {\n-            return \"null\";\n-        }\n-        ensureAvailable(len * 4);\n-        StringBuilder sb = new StringBuilder().append('[');\n-        for (int i = 0; i < len; i++) {\n-            sb.append(buffer.getInt());\n-            if (i < len - 1) {\n-                sb.append(\", \");\n-            }\n-        }\n-        sb.append(']');\n-        return sb.toString().intern();\n-    }\n-\n-    private String readDoublesToString() throws IOException {\n-        int len = readInt();\n-        if (len < 0) {\n-            return \"null\";\n-        }\n-        ensureAvailable(len * 8);\n-        StringBuilder sb = new StringBuilder().append('[');\n-        for (int i = 0; i < len; i++) {\n-            sb.append(buffer.getDouble());\n-            if (i < len - 1) {\n-                sb.append(\", \");\n-            }\n-        }\n-        sb.append(']');\n-        return sb.toString().intern();\n-    }\n-\n-    private String readPoolObjectsToString() throws IOException {\n-        int len = readInt();\n-        if (len < 0) {\n-            return \"null\";\n-        }\n-        StringBuilder sb = new StringBuilder().append('[');\n-        for (int i = 0; i < len; i++) {\n-            sb.append(readPoolObject(Object.class));\n-            if (i < len - 1) {\n-                sb.append(\", \");\n-            }\n-        }\n-        sb.append(']');\n-        return sb.toString().intern();\n-    }\n-\n-    private <T> T readPoolObject(Class<T> klass) throws IOException {\n-        int type = readByte();\n-        if (type == POOL_NULL) {\n-            return null;\n-        }\n-        if (type == POOL_NEW) {\n-            return (T) addPoolEntry(klass);\n-        }\n-        assert assertObjectType(klass, type);\n-        char index = readShort();\n-        if (index < 0 || index >= constantPool.size()) {\n-            throw new IOException(\"Invalid constant pool index : \" + index);\n-        }\n-        Object obj = constantPool.get(index);\n-        return (T) obj;\n-    }\n-\n-    private boolean assertObjectType(Class<?> klass, int type) {\n-        switch(type) {\n-            case POOL_CLASS:\n-                return klass.isAssignableFrom(EnumKlass.class);\n-            case POOL_ENUM:\n-                return klass.isAssignableFrom(EnumValue.class);\n-            case POOL_METHOD:\n-                return klass.isAssignableFrom(Method.class);\n-            case POOL_STRING:\n-                return klass.isAssignableFrom(String.class);\n-            case POOL_NODE_CLASS:\n-                return klass.isAssignableFrom(NodeClass.class);\n-            case POOL_FIELD:\n-                return klass.isAssignableFrom(Field.class);\n-            case POOL_SIGNATURE:\n-                return klass.isAssignableFrom(Signature.class);\n-            case POOL_NULL:\n-                return true;\n-            default:\n-                return false;\n-        }\n-    }\n-\n-    private Object addPoolEntry(Class<?> klass) throws IOException {\n-        char index = readShort();\n-        int type = readByte();\n-        assert assertObjectType(klass, type) : \"Wrong object type : \" + klass + \" != \" + type;\n-        Object obj;\n-        switch(type) {\n-            case POOL_CLASS: {\n-                String name = readString();\n-                int klasstype = readByte();\n-                if (klasstype == ENUM_KLASS) {\n-                    int len = readInt();\n-                    String[] values = new String[len];\n-                    for (int i = 0; i < len; i++) {\n-                        values[i] = readPoolObject(String.class);\n-                    }\n-                    obj = new EnumKlass(name, values);\n-                } else if (klasstype == KLASS) {\n-                    obj = new Klass(name);\n-                } else {\n-                    throw new IOException(\"unknown klass type : \" + klasstype);\n-                }\n-                break;\n-            }\n-            case POOL_ENUM: {\n-                EnumKlass enumClass = readPoolObject(EnumKlass.class);\n-                int ordinal = readInt();\n-                obj = new EnumValue(enumClass, ordinal);\n-                break;\n-            }\n-            case POOL_NODE_CLASS: {\n-                String className = readString();\n-                String nameTemplate = readString();\n-                int inputCount = readShort();\n-                List<TypedPort> inputs = new ArrayList<>(inputCount);\n-                for (int i = 0; i < inputCount; i++) {\n-                    boolean isList = readByte() != 0;\n-                    String name = readPoolObject(String.class);\n-                    EnumValue inputType = readPoolObject(EnumValue.class);\n-                    inputs.add(new TypedPort(isList, name, inputType));\n-                }\n-                int suxCount = readShort();\n-                List<Port> sux = new ArrayList<>(suxCount);\n-                for (int i = 0; i < suxCount; i++) {\n-                    boolean isList = readByte() != 0;\n-                    String name = readPoolObject(String.class);\n-                    sux.add(new Port(isList, name));\n-                }\n-                obj = new NodeClass(className, nameTemplate, inputs, sux);\n-                break;\n-            }\n-            case POOL_METHOD: {\n-                Klass holder = readPoolObject(Klass.class);\n-                String name = readPoolObject(String.class);\n-                Signature sign = readPoolObject(Signature.class);\n-                int flags = readInt();\n-                byte[] code = readBytes();\n-                obj = new Method(name, sign, code, holder, flags);\n-                break;\n-            }\n-            case POOL_FIELD: {\n-                Klass holder = readPoolObject(Klass.class);\n-                String name = readPoolObject(String.class);\n-                String fType = readPoolObject(String.class);\n-                int flags = readInt();\n-                obj = new Field(fType, holder, name, flags);\n-                break;\n-            }\n-            case POOL_SIGNATURE: {\n-                int argc = readShort();\n-                String[] args = new String[argc];\n-                for (int i = 0; i < argc; i++) {\n-                    args[i] = readPoolObject(String.class);\n-                }\n-                String returnType = readPoolObject(String.class);\n-                obj = new Signature(returnType, args);\n-                break;\n-            }\n-            case POOL_STRING: {\n-                obj = readString();\n-                break;\n-            }\n-            default:\n-                throw new IOException(\"unknown pool type\");\n-        }\n-        while (constantPool.size() <= index) {\n-            constantPool.add(null);\n-        }\n-        constantPool.set(index, obj);\n-        return obj;\n-    }\n-\n-    private Object readPropertyObject() throws IOException {\n-        int type = readByte();\n-        switch (type) {\n-            case PROPERTY_INT:\n-                return readInt();\n-            case PROPERTY_LONG:\n-                return readLong();\n-            case PROPERTY_FLOAT:\n-                return readFloat();\n-            case PROPERTY_DOUBLE:\n-                return readDouble();\n-            case PROPERTY_TRUE:\n-                return Boolean.TRUE;\n-            case PROPERTY_FALSE:\n-                return Boolean.FALSE;\n-            case PROPERTY_POOL:\n-                return readPoolObject(Object.class);\n-            case PROPERTY_ARRAY:\n-                int subType = readByte();\n-                switch(subType) {\n-                    case PROPERTY_INT:\n-                        return readIntsToString();\n-                    case PROPERTY_DOUBLE:\n-                        return readDoublesToString();\n-                    case PROPERTY_POOL:\n-                        return readPoolObjectsToString();\n-                    default:\n-                        throw new IOException(\"Unknown type\");\n-                }\n-            case PROPERTY_SUBGRAPH:\n-                InputGraph graph = parseGraph(\"\");\n-                new Group(null).addElement(graph);\n-                return graph;\n-            default:\n-                throw new IOException(\"Unknown type\");\n-        }\n-    }\n-\n-    @Override\n-    public GraphDocument parse() throws IOException {\n-        folderStack.push(rootDocument);\n-        hashStack.push(null);\n-        if (monitor != null) {\n-            monitor.setState(\"Starting parsing\");\n-        }\n-        try {\n-            while(true) {\n-                parseRoot();\n-            }\n-        } catch (EOFException e) {\n-\n-        }\n-        if (monitor != null) {\n-            monitor.setState(\"Finished parsing\");\n-        }\n-        return rootDocument;\n-    }\n-\n-    private void parseRoot() throws IOException {\n-        int type = readByte();\n-        switch(type) {\n-            case BEGIN_GRAPH: {\n-                final Folder parent = folderStack.peek();\n-                final InputGraph graph = parseGraph();\n-                SwingUtilities.invokeLater(new Runnable(){\n-                    @Override\n-                    public void run() {\n-                        parent.addElement(graph);\n-                    }\n-                });\n-                break;\n-            }\n-            case BEGIN_GROUP: {\n-                final Folder parent = folderStack.peek();\n-                final Group group = parseGroup(parent);\n-                if (callback == null || parent instanceof Group) {\n-                    SwingUtilities.invokeLater(new Runnable(){\n-                        @Override\n-                        public void run() {\n-                            parent.addElement(group);\n-                        }\n-                    });\n-                }\n-                folderStack.push(group);\n-                hashStack.push(null);\n-                if (callback != null && parent instanceof GraphDocument) {\n-                    callback.started(group);\n-                }\n-                break;\n-            }\n-            case CLOSE_GROUP: {\n-                if (folderStack.isEmpty()) {\n-                    throw new IOException(\"Unbalanced groups\");\n-                }\n-                folderStack.pop();\n-                hashStack.pop();\n-                break;\n-            }\n-            default:\n-                throw new IOException(\"unknown root : \" + type);\n-        }\n-    }\n-\n-    private Group parseGroup(Folder parent) throws IOException {\n-        String name = readPoolObject(String.class);\n-        String shortName = readPoolObject(String.class);\n-        if (monitor != null) {\n-            monitor.setState(shortName);\n-        }\n-        Method method = readPoolObject(Method.class);\n-        int bci = readInt();\n-        Group group = new Group(parent);\n-        group.getProperties().setProperty(\"name\", name);\n-        parseProperties(group.getProperties());\n-        if (method != null) {\n-            InputMethod inMethod = new InputMethod(group, method.name, shortName, bci);\n-            inMethod.setBytecodes(\"TODO\");\n-            group.setMethod(inMethod);\n-        }\n-        return group;\n-    }\n-\n-    int lastPosition = 0;\n-\n-    private InputGraph parseGraph() throws IOException {\n-        if (monitor != null) {\n-            monitor.updateProgress();\n-        }\n-        String title = readPoolObject(String.class);\n-        digest.reset();\n-        lastPosition = buffer.position();\n-        InputGraph graph = parseGraph(title);\n-\n-        int position = buffer.position();\n-        buffer.position(lastPosition);\n-        byte[] remaining = new byte[position - buffer.position()];\n-        buffer.get(remaining);\n-        digest.update(remaining);\n-        assert position == buffer.position();\n-        lastPosition = buffer.position();\n-\n-        byte[] d = digest.digest();\n-        byte[] hash = hashStack.peek();\n-        if (hash != null && Arrays.equals(hash, d)) {\n-            graph.getProperties().setProperty(\"_isDuplicate\", \"true\");\n-        } else {\n-            hashStack.pop();\n-            hashStack.push(d);\n-        }\n-        return graph;\n-    }\n-\n-    private void parseProperties(Properties properties) throws IOException {\n-        int propCount = readShort();\n-        for (int j = 0; j < propCount; j++) {\n-            String key = readPoolObject(String.class);\n-            Object value = readPropertyObject();\n-            properties.setProperty(key, value != null ? value.toString() : \"null\");\n-        }\n-    }\n-\n-    private InputGraph parseGraph(String title) throws IOException {\n-        InputGraph graph = new InputGraph(title);\n-        parseProperties(graph.getProperties());\n-        parseNodes(graph);\n-        parseBlocks(graph);\n-        graph.ensureNodesInBlocks();\n-        for (InputNode node : graph.getNodes()) {\n-            node.internProperties();\n-        }\n-        return graph;\n-    }\n-\n-    private void parseBlocks(InputGraph graph) throws IOException {\n-        int blockCount = readInt();\n-        List<Edge> edges = new LinkedList<>();\n-        for (int i = 0; i < blockCount; i++) {\n-            int id = readInt();\n-            String name = id >= 0 ? Integer.toString(id) : NO_BLOCK;\n-            InputBlock block = graph.addBlock(name);\n-            int nodeCount = readInt();\n-            for (int j = 0; j < nodeCount; j++) {\n-                int nodeId = readInt();\n-                if (nodeId < 0) {\n-                    continue;\n-                }\n-                final Properties properties = graph.getNode(nodeId).getProperties();\n-                final String oldBlock = properties.get(\"block\");\n-                if(oldBlock != null) {\n-                    properties.setProperty(\"block\", oldBlock + \", \" + name);\n-                } else {\n-                    block.addNode(nodeId);\n-                    properties.setProperty(\"block\", name);\n-                }\n-            }\n-            int edgeCount = readInt();\n-            for (int j = 0; j < edgeCount; j++) {\n-                int to = readInt();\n-                edges.add(new Edge(id, to));\n-            }\n-        }\n-        for (Edge e : edges) {\n-            String fromName = e.from >= 0 ? Integer.toString(e.from) : NO_BLOCK;\n-            String toName = e.to >= 0 ? Integer.toString(e.to) : NO_BLOCK;\n-            graph.addBlockEdge(graph.getBlock(fromName), graph.getBlock(toName));\n-        }\n-    }\n-\n-    private void parseNodes(InputGraph graph) throws IOException {\n-        int count = readInt();\n-        Map<String, Object> props = new HashMap<>();\n-        List<Edge> inputEdges = new ArrayList<>(count);\n-        List<Edge> succEdges = new ArrayList<>(count);\n-        for (int i = 0; i < count; i++) {\n-            int id = readInt();\n-            InputNode node = new InputNode(id);\n-            final Properties properties = node.getProperties();\n-            NodeClass nodeClass = readPoolObject(NodeClass.class);\n-            int preds = readByte();\n-            if (preds > 0) {\n-                properties.setProperty(\"hasPredecessor\", \"true\");\n-            }\n-            properties.setProperty(\"idx\", Integer.toString(id));\n-            int propCount = readShort();\n-            for (int j = 0; j < propCount; j++) {\n-                String key = readPoolObject(String.class);\n-                if (key.equals(\"hasPredecessor\") || key.equals(\"name\") || key.equals(\"class\") || key.equals(\"id\") || key.equals(\"idx\")) {\n-                    key = \"!data.\" + key;\n-                }\n-                Object value = readPropertyObject();\n-                if (value instanceof InputGraph) {\n-                    InputGraph subgraph = (InputGraph) value;\n-                    subgraph.getProperties().setProperty(\"name\", node.getId() + \":\" + key);\n-                    node.addSubgraph((InputGraph) value);\n-                } else {\n-                    properties.setProperty(key, value != null ? value.toString() : \"null\");\n-                    props.put(key, value);\n-                }\n-            }\n-            ArrayList<Edge> currentEdges = new ArrayList<>();\n-            int portNum = 0;\n-            for (TypedPort p : nodeClass.inputs) {\n-                if (p.isList) {\n-                    int size = readShort();\n-                    for (int j = 0; j < size; j++) {\n-                        int in = readInt();\n-                        if (in >= 0) {\n-                            Edge e = new Edge(in, id, (char) (preds + portNum), p.name + \"[\" + j + \"]\", p.type.toString(Length.S), true);\n-                            currentEdges.add(e);\n-                            inputEdges.add(e);\n-                            portNum++;\n-                        }\n-                    }\n-                } else {\n-                    int in = readInt();\n-                    if (in >= 0) {\n-                        Edge e = new Edge(in, id, (char) (preds + portNum), p.name, p.type.toString(Length.S), true);\n-                        currentEdges.add(e);\n-                        inputEdges.add(e);\n-                        portNum++;\n-                    }\n-                }\n-\n-            }\n-            portNum = 0;\n-            for (Port p : nodeClass.sux) {\n-                if (p.isList) {\n-                    int size = readShort();\n-                    for (int j = 0; j < size; j++) {\n-                        int sux = readInt();\n-                        if (sux >= 0) {\n-                            Edge e = new Edge(id, sux, (char) portNum, p.name + \"[\" + j + \"]\", \"Successor\", false);\n-                            currentEdges.add(e);\n-                            succEdges.add(e);\n-                            portNum++;\n-                        }\n-                    }\n-                } else {\n-                    int sux = readInt();\n-                    if (sux >= 0) {\n-                        Edge e = new Edge(id, sux, (char) portNum, p.name, \"Successor\", false);\n-                        currentEdges.add(e);\n-                        succEdges.add(e);\n-                        portNum++;\n-                    }\n-                }\n-            }\n-            properties.setProperty(\"name\", createName(currentEdges, props, nodeClass.nameTemplate));\n-            properties.setProperty(\"class\", nodeClass.className);\n-            switch (nodeClass.className) {\n-                case \"BeginNode\":\n-                    properties.setProperty(\"shortName\", \"B\");\n-                    break;\n-                case \"EndNode\":\n-                    properties.setProperty(\"shortName\", \"E\");\n-                    break;\n-            }\n-            graph.addNode(node);\n-            props.clear();\n-        }\n-\n-        Set<InputNode> nodesWithSuccessor = new HashSet<>();\n-\n-        for (Edge e : succEdges) {\n-            assert !e.input;\n-            char fromIndex = e.num;\n-            nodesWithSuccessor.add(graph.getNode(e.from));\n-            char toIndex = 0;\n-            graph.addEdge(InputEdge.createImmutable(fromIndex, toIndex, e.from, e.to, e.label, e.type));\n-        }\n-        for (Edge e : inputEdges) {\n-            assert e.input;\n-            char fromIndex = (char) (nodesWithSuccessor.contains(graph.getNode(e.from)) ? 1 : 0);\n-            char toIndex = e.num;\n-            graph.addEdge(InputEdge.createImmutable(fromIndex, toIndex, e.from, e.to, e.label, e.type));\n-        }\n-    }\n-\n-    static final Pattern templatePattern = Pattern.compile(\"\\\\{(p|i)#([a-zA-Z0-9$_]+)(\/(l|m|s))?\\\\}\");\n-\n-    private String createName(List<Edge> edges, Map<String, Object> properties, String template) {\n-        Matcher m = templatePattern.matcher(template);\n-        StringBuffer sb = new StringBuffer();\n-        while (m.find()) {\n-            String name = m.group(2);\n-            String type = m.group(1);\n-            String result;\n-            switch (type) {\n-                case \"i\":\n-                    StringBuilder inputString = new StringBuilder();\n-                    for(Edge edge : edges) {\n-                        if (edge.label.startsWith(name) && (name.length() == edge.label.length() || edge.label.charAt(name.length()) == '[')) {\n-                            if (inputString.length() > 0) {\n-                                inputString.append(\", \");\n-                            }\n-                            inputString.append(edge.from);\n-                        }\n-                    }\n-                    result = inputString.toString();\n-                    break;\n-                case \"p\":\n-                    Object prop = properties.get(name);\n-                    String length = m.group(4);\n-                    if (prop == null) {\n-                        result = \"?\";\n-                    } else if (length != null && prop instanceof LengthToString) {\n-                        LengthToString lengthProp = (LengthToString) prop;\n-                        switch(length) {\n-                            default:\n-                            case \"l\":\n-                                result = lengthProp.toString(Length.L);\n-                                break;\n-                            case \"m\":\n-                                result = lengthProp.toString(Length.M);\n-                                break;\n-                            case \"s\":\n-                                result = lengthProp.toString(Length.S);\n-                                break;\n-                        }\n-                    } else {\n-                        result = prop.toString();\n-                    }\n-                    break;\n-                default:\n-                    result = \"#?#\";\n-                    break;\n-            }\n-            result = result.replace(\"\\\\\", \"\\\\\\\\\");\n-            result = result.replace(\"$\", \"\\\\$\");\n-            m.appendReplacement(sb, result);\n-        }\n-        m.appendTail(sb);\n-        return sb.toString().intern();\n-    }\n-\n-    private static class Edge {\n-        final int from;\n-        final int to;\n-        final char num;\n-        final String label;\n-        final String type;\n-        final boolean input;\n-        public Edge(int from, int to) {\n-            this(from, to, (char) 0, null, null, false);\n-        }\n-        public Edge(int from, int to, char num, String label, String type, boolean input) {\n-            this.from = from;\n-            this.to = to;\n-            this.label = label != null ? label.intern() : label;\n-            this.type = type != null ? type.intern() : type;\n-            this.num = num;\n-            this.input = input;\n-        }\n-    }\n-}\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/main\/java\/com\/sun\/hotspot\/igv\/data\/serialization\/BinaryParser.java","additions":0,"deletions":937,"binary":false,"changes":937,"status":"deleted"},{"patch":"@@ -31,1 +31,1 @@\n-    public GraphDocument parse() throws IOException;\n+    GraphDocument parse() throws IOException;\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/main\/java\/com\/sun\/hotspot\/igv\/data\/serialization\/GraphParser.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-    public void updateProgress();\n+    void updateProgress();\n@@ -31,1 +31,1 @@\n-    public void setState(String state);\n+    void setState(String state);\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/main\/java\/com\/sun\/hotspot\/igv\/data\/serialization\/ParseMonitor.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import java.io.InputStream;\n@@ -42,3 +41,0 @@\n-import javax.xml.transform.Source;\n-import javax.xml.transform.stream.StreamSource;\n-import javax.xml.validation.SchemaFactory;\n@@ -56,1 +52,0 @@\n-    public static final String INDENT = \"  \";\n@@ -70,6 +65,0 @@\n-    public static final String GROUP_NAME_PROPERTY = \"name\";\n-    public static final String METHOD_IS_PUBLIC_PROPERTY = \"public\";\n-    public static final String METHOD_IS_STATIC_PROPERTY = \"static\";\n-    public static final String TRUE_VALUE = \"true\";\n-    public static final String NODE_NAME_PROPERTY = \"name\";\n-    public static final String EDGE_NAME_PROPERTY = \"name\";\n@@ -96,1 +85,0 @@\n-    public static final String ASSEMBLY_ELEMENT = \"assembly\";\n@@ -98,6 +86,6 @@\n-    private TopElementHandler<GraphDocument> xmlDocument = new TopElementHandler<>();\n-    private Map<Group, Boolean> differenceEncoding = new HashMap<>();\n-    private Map<Group, InputGraph> lastParsedGraph = new HashMap<>();\n-    private GroupCallback groupCallback;\n-    private HashMap<String, Integer> idCache = new HashMap<>();\n-    private ArrayList<Pair<String, String>> blockConnections = new ArrayList<>();\n+    private final TopElementHandler<GraphDocument> xmlDocument = new TopElementHandler<>();\n+    private final Map<Group, Boolean> differenceEncoding = new HashMap<>();\n+    private final Map<Group, InputGraph> lastParsedGraph = new HashMap<>();\n+    private final GroupCallback groupCallback;\n+    private final HashMap<String, Integer> idCache = new HashMap<>();\n+    private final ArrayList<Pair<String, String>> blockConnections = new ArrayList<>();\n@@ -121,1 +109,1 @@\n-        return id.intValue();\n+        return id;\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/main\/java\/com\/sun\/hotspot\/igv\/data\/serialization\/Parser.java","additions":7,"deletions":19,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -55,2 +55,1 @@\n-        } catch (IOException ex) {\n-        }\n+        } catch (IOException ignored) {}\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/main\/java\/com\/sun\/hotspot\/igv\/data\/serialization\/Printer.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -42,2 +42,0 @@\n-        private String name;\n-\n@@ -46,1 +44,0 @@\n-            this.name = name;\n@@ -49,3 +46,0 @@\n-        public String getAttributeName() {\n-            return this.getMessage();\n-        }\n@@ -79,2 +73,2 @@\n-        private String name;\n-        private Stack<T> object = new Stack<>();\n+        private final String name;\n+        private final Stack<T> object = new Stack<>();\n@@ -84,4 +78,4 @@\n-        private HashMap<String, ElementHandler<?, ? super T>> hashtable;\n-        private boolean needsText;\n-        private Stack<ElementHandler<P, ?>> parentElement = new Stack<>();\n-        private Stack<P> parentObject = new Stack<>();\n+        private final HashMap<String, ElementHandler<?, ? super T>> hashtable;\n+        private final boolean needsText;\n+        private final Stack<ElementHandler<P, ?>> parentElement = new Stack<>();\n+        private final Stack<P> parentObject = new Stack<>();\n@@ -93,4 +87,0 @@\n-        public ElementHandler<P, ?> getParentElement() {\n-            return parentElement.peek();\n-        }\n-\n@@ -144,9 +134,0 @@\n-        public void processAttributesAsProperties(Properties p) {\n-            int length = attr.getLength();\n-            for (int i = 0; i < length; i++) {\n-                String val = attr.getValue(i);\n-                String localName = attr.getLocalName(i);\n-                p.setProperty(val, localName);\n-            }\n-        }\n-\n@@ -182,2 +163,2 @@\n-    private Stack<ElementHandler> stack;\n-    private ParseMonitor monitor;\n+    private final Stack<ElementHandler> stack;\n+    private final ParseMonitor monitor;\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/main\/java\/com\/sun\/hotspot\/igv\/data\/serialization\/XMLParser.java","additions":8,"deletions":27,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -39,2 +39,2 @@\n-    private Writer inner;\n-    private Stack<String> elementStack;\n+    private final Writer inner;\n+    private final Stack<String> elementStack;\n@@ -117,1 +117,1 @@\n-        if (props.iterator().hasNext() == false) {\n+        if (!props.iterator().hasNext()) {\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/main\/java\/com\/sun\/hotspot\/igv\/data\/serialization\/XMLWriter.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import static org.junit.Assert.assertEquals;\n@@ -29,0 +28,1 @@\n+import static org.junit.Assert.assertEquals;\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/test\/java\/com\/sun\/hotspot\/igv\/data\/ChangedEventTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import static org.junit.Assert.*;\n@@ -29,0 +28,1 @@\n+import static org.junit.Assert.*;\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/test\/java\/com\/sun\/hotspot\/igv\/data\/ControllableChangedListenerTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import static org.junit.Assert.assertEquals;\n@@ -31,0 +30,1 @@\n+import static org.junit.Assert.assertEquals;\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/test\/java\/com\/sun\/hotspot\/igv\/data\/GroupTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,5 +27,0 @@\n-import java.util.Arrays;\n-import java.util.List;\n-import java.util.Map;\n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertTrue;\n@@ -126,85 +121,0 @@\n-\n-    \/**\n-     * Test of findRootNodes method, of class InputGraph.\n-     *\/\n-    @Test\n-    public void testFindRootNodes() {\n-        assertTrue(emptyGraph.findRootNodes().isEmpty());\n-\n-        List<InputNode> result = referenceGraph.findRootNodes();\n-        assertTrue(result.size() == 2);\n-        assertTrue(result.contains(N1));\n-        assertTrue(result.contains(N5));\n-    }\n-\n-    \/**\n-     * Test of findAllOutgoingEdges method, of class InputGraph.\n-     *\/\n-    @Test\n-    public void testFindAllOutgoingEdges() {\n-        assertTrue(emptyGraph.findAllOutgoingEdges().isEmpty());\n-\n-        Map<InputNode, List<InputEdge>> result = referenceGraph.findAllOutgoingEdges();\n-        assertTrue(result.size() == 5);\n-        assertEquals(result.get(N1), Arrays.asList(E12, E13));\n-        assertEquals(result.get(N2), Arrays.asList(E24));\n-        assertEquals(result.get(N3), Arrays.asList(E34));\n-        assertEquals(result.get(N4), Arrays.asList());\n-        assertEquals(result.get(N5), Arrays.asList(E54));\n-    }\n-\n-    \/**\n-     * Test of findAllIngoingEdges method, of class InputGraph.\n-     *\/\n-    @Test\n-    public void testFindAllIngoingEdges() {\n-        assertTrue(emptyGraph.findAllIngoingEdges().isEmpty());\n-\n-        Map<InputNode, List<InputEdge>> result = referenceGraph.findAllIngoingEdges();\n-        assertTrue(result.size() == 5);\n-        assertEquals(result.get(N1), Arrays.asList());\n-        assertEquals(result.get(N2), Arrays.asList(E12));\n-        assertEquals(result.get(N3), Arrays.asList(E13));\n-        assertEquals(result.get(N4), Arrays.asList(E24, E34, E54));\n-        assertEquals(result.get(N5), Arrays.asList());\n-    }\n-\n-    \/**\n-     * Test of findOutgoingEdges method, of class InputGraph.\n-     *\/\n-    @Test\n-    public void testFindOutgoingEdges() {\n-        assertTrue(emptyGraph.findOutgoingEdges(new InputNode(1)).isEmpty());\n-\n-        assertEquals(referenceGraph.findOutgoingEdges(N1), Arrays.asList(E12, E13));\n-        assertEquals(referenceGraph.findOutgoingEdges(N2), Arrays.asList(E24));\n-        assertEquals(referenceGraph.findOutgoingEdges(N3), Arrays.asList(E34));\n-        assertEquals(referenceGraph.findOutgoingEdges(N4), Arrays.asList());\n-        assertEquals(referenceGraph.findOutgoingEdges(N5), Arrays.asList(E54));\n-    }\n-\n-    \/**\n-     * Test of getNext method, of class InputGraph.\n-     *\/\n-    @Test\n-    public void testGetNextPrev() {\n-        final Group group = new Group(null);\n-\n-        final InputGraph a = new InputGraph(\"a\");\n-\n-        final InputGraph b = new InputGraph(\"b\");\n-\n-        final InputGraph c = new InputGraph(\"c\");\n-        group.addElement(a);\n-        group.addElement(b);\n-        group.addElement(c);\n-\n-        assertEquals(null, a.getPrev());\n-        assertEquals(b, a.getNext());\n-\n-        assertEquals(a, b.getPrev());\n-        assertEquals(c, b.getNext());\n-\n-        assertEquals(b, c.getPrev());\n-        assertEquals(null, c.getNext());\n-    }\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/test\/java\/com\/sun\/hotspot\/igv\/data\/InputGraphTest.java","additions":0,"deletions":90,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import static org.junit.Assert.assertThat;\n@@ -31,0 +30,1 @@\n+import static org.junit.Assert.assertThat;\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/test\/java\/com\/sun\/hotspot\/igv\/data\/InputMethodTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import static org.junit.Assert.*;\n@@ -30,0 +29,1 @@\n+import static org.junit.Assert.*;\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/test\/java\/com\/sun\/hotspot\/igv\/data\/PairTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,5 +28,1 @@\n-import com.sun.hotspot.igv.data.Properties.InvertPropertyMatcher;\n-import com.sun.hotspot.igv.data.Properties.PropertyMatcher;\n-import com.sun.hotspot.igv.data.Properties.PropertySelector;\n-import com.sun.hotspot.igv.data.Properties.RegexpPropertyMatcher;\n-import com.sun.hotspot.igv.data.Properties.StringPropertyMatcher;\n+import com.sun.hotspot.igv.data.Properties.*;\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/test\/java\/com\/sun\/hotspot\/igv\/data\/PropertiesTest.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import static org.junit.Assert.*;\n@@ -30,0 +29,1 @@\n+import static org.junit.Assert.*;\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/test\/java\/com\/sun\/hotspot\/igv\/data\/PropertyTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import static org.junit.Assert.assertEquals;\n@@ -31,0 +30,1 @@\n+import static org.junit.Assert.assertEquals;\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/test\/java\/com\/sun\/hotspot\/igv\/data\/SourceTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,2 @@\n-import static org.junit.Assert.*;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.fail;\n@@ -36,10 +37,0 @@\n-    public static void assertGraphDocumentNotEquals(GraphDocument a, GraphDocument b) {\n-        try {\n-            assertGraphDocumentEquals(a, b);\n-        } catch(AssertionError e) {\n-            return;\n-        }\n-\n-        fail(\"Graphs documents are equal!\");\n-    }\n-\n@@ -64,10 +55,0 @@\n-    public static void assertGroupNotEquals(Group a, Group b) {\n-        try {\n-            assertGroupEquals(a, b);\n-        } catch(AssertionError e) {\n-            return;\n-        }\n-\n-        fail(\"Groups are equal!\");\n-    }\n-\n@@ -76,1 +57,1 @@\n-        if (a.getGraphsCount() != b.getGraphsCount()) {\n+        if (a.getGraphs().size() != b.getGraphs().size()) {\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/test\/java\/com\/sun\/hotspot\/igv\/data\/Util.java","additions":3,"deletions":22,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -29,1 +29,4 @@\n-import java.io.*;\n+import java.io.ByteArrayInputStream;\n+import java.io.CharArrayWriter;\n+import java.io.IOException;\n+import java.io.InputStream;\n@@ -31,1 +34,0 @@\n-\n@@ -33,0 +35,1 @@\n+import org.junit.*;\n@@ -35,3 +38,0 @@\n-import org.junit.*;\n-import org.openide.util.Exceptions;\n-import org.xml.sax.InputSource;\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/test\/java\/com\/sun\/hotspot\/igv\/data\/serialization\/ParserTest.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -290,3 +290,0 @@\n-\n-        Set<InputNode> matched = new HashSet<>();\n-\n","filename":"src\/utils\/IdealGraphVisualizer\/Difference\/src\/main\/java\/com\/sun\/hotspot\/igv\/difference\/Difference.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import com.sun.hotspot.igv.graph.Connection.ConnectionStyle;\n@@ -29,0 +28,1 @@\n+import com.sun.hotspot.igv.graph.Connection.ConnectionStyle;\n","filename":"src\/utils\/IdealGraphVisualizer\/Filter\/src\/main\/java\/com\/sun\/hotspot\/igv\/filter\/ColorFilter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -77,1 +77,1 @@\n-                        slot.getSource().addSourceNodes(f.getSource());\n+                        slot.getSource().addSourceNode(f.getInputNode());\n@@ -133,1 +133,1 @@\n-                                slot.getSource().addSourceNodes(succ.getSource());\n+                                slot.getSource().addSourceNode(succ.getInputNode());\n","filename":"src\/utils\/IdealGraphVisualizer\/Filter\/src\/main\/java\/com\/sun\/hotspot\/igv\/filter\/CombineFilter.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,1 +28,4 @@\n-import javax.script.*;\n+import javax.script.Bindings;\n+import javax.script.ScriptContext;\n+import javax.script.ScriptEngine;\n+import javax.script.ScriptException;\n","filename":"src\/utils\/IdealGraphVisualizer\/Filter\/src\/main\/java\/com\/sun\/hotspot\/igv\/filter\/CustomFilter.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-import com.sun.hotspot.igv.graph.Diagram;\n@@ -29,0 +28,1 @@\n+import com.sun.hotspot.igv.graph.Diagram;\n","filename":"src\/utils\/IdealGraphVisualizer\/Filter\/src\/main\/java\/com\/sun\/hotspot\/igv\/filter\/RemoveBlockFilter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -59,3 +59,3 @@\n-                    if (f.getSource().getSourceNodes().size() > 0) {\n-                        os.getSource().addSourceNodes(f.getSource());\n-                        os.setAssociatedNode(f.getSource().getSourceNodes().get(0));\n+                    if (f.getInputNode() != null) {\n+                        os.getSource().addSourceNode(f.getInputNode());\n+                        os.setAssociatedNode(f.getInputNode());\n@@ -76,3 +76,3 @@\n-                    if (f.getSource().getSourceNodes().size() > 0) {\n-                        is.getSource().addSourceNodes(f.getSource());\n-                        is.setAssociatedNode(f.getSource().getSourceNodes().get(0));\n+                    if (f.getInputNode() != null) {\n+                        is.getSource().addSourceNode(f.getInputNode());\n+                        is.setAssociatedNode(f.getInputNode());\n","filename":"src\/utils\/IdealGraphVisualizer\/Filter\/src\/main\/java\/com\/sun\/hotspot\/igv\/filter\/SplitFilter.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -27,1 +27,3 @@\n-import com.sun.hotspot.igv.graph.*;\n+import com.sun.hotspot.igv.graph.Diagram;\n+import com.sun.hotspot.igv.graph.Figure;\n+import com.sun.hotspot.igv.graph.Selector;\n","filename":"src\/utils\/IdealGraphVisualizer\/Filter\/src\/main\/java\/com\/sun\/hotspot\/igv\/filter\/WarningFilter.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -271,7 +271,1 @@\n-            sequence.getChangedEvent().addListener(new ChangedListener<FilterChain>() {\n-\n-                @Override\n-                public void changed(FilterChain source) {\n-                    addNotify();\n-                }\n-            });\n+            sequence.getChangedEvent().addListener(source -> addNotify());\n@@ -709,9 +703,0 @@\n-\n-    static final class ResolvableHelper implements Serializable {\n-\n-        private static final long serialVersionUID = 1L;\n-\n-        public Object readResolve() {\n-            return FilterTopComponent.getDefault();\n-        }\n-    }\n","filename":"src\/utils\/IdealGraphVisualizer\/FilterWindow\/src\/main\/java\/com\/sun\/hotspot\/igv\/filterwindow\/FilterTopComponent.java","additions":1,"deletions":16,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -21,1 +21,1 @@\n-    \n+\n@@ -31,0 +31,1 @@\n+                <attr name=\"position\" intvalue=\"3\"\/>\n","filename":"src\/utils\/IdealGraphVisualizer\/FilterWindow\/src\/main\/resources\/com\/sun\/hotspot\/igv\/filterwindow\/layer.xml","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-import java.util.List;\n@@ -28,0 +27,1 @@\n+import java.util.List;\n@@ -42,1 +42,1 @@\n-            l.add(d.getBlock(f.getBlock()));\n+            l.add(f.getBlock());\n","filename":"src\/utils\/IdealGraphVisualizer\/Graph\/src\/main\/java\/com\/sun\/hotspot\/igv\/graph\/AnySelector.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-import java.awt.Dimension;\n@@ -29,0 +28,1 @@\n+import java.awt.Dimension;\n@@ -48,4 +48,0 @@\n-    public Cluster getOuter() {\n-        return null;\n-    }\n-\n","filename":"src\/utils\/IdealGraphVisualizer\/Graph\/src\/main\/java\/com\/sun\/hotspot\/igv\/graph\/Block.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -26,7 +26,1 @@\n-import com.sun.hotspot.igv.data.InputBlock;\n-import com.sun.hotspot.igv.data.InputBlockEdge;\n-import com.sun.hotspot.igv.data.InputEdge;\n-import com.sun.hotspot.igv.data.InputGraph;\n-import com.sun.hotspot.igv.data.InputNode;\n-import com.sun.hotspot.igv.data.Properties;\n-import com.sun.hotspot.igv.data.Properties.StringPropertyMatcher;\n+import com.sun.hotspot.igv.data.*;\n@@ -34,1 +28,0 @@\n-import java.awt.Color;\n@@ -44,9 +37,7 @@\n-    private Map<InputBlock, Block> blocks;\n-    private InputGraph graph;\n-    private int curId;\n-    private String nodeText;\n-    private String shortNodeText;\n-    private String tinyNodeText;\n-    private final Font font;\n-    private final Font slotFont;\n-    private final Font boldFont;\n+    private final Map<InputBlock, Block> blocks;\n+    private final String nodeText;\n+    private final String shortNodeText;\n+    private final String tinyNodeText;\n+    public static final Font FONT = new Font(\"Arial\", Font.PLAIN, 12);\n+    public static final Font SLOT_FONT = new Font(\"Arial\", Font.PLAIN, 10);\n+    public static final Font BOLD_FONT = FONT.deriveFont(Font.BOLD);\n@@ -58,12 +49,0 @@\n-    public Font getFont() {\n-        return font;\n-    }\n-\n-    public Font getSlotFont() {\n-        return slotFont;\n-    }\n-\n-    public Font getBoldFont() {\n-        return boldFont;\n-    }\n-\n@@ -78,12 +57,4 @@\n-    private Diagram(InputGraph graph, String nodeText, String shortNodeText,\n-                    String tinyNodeText) {\n-        figures = new ArrayList<>();\n-        blocks = new LinkedHashMap<>(8);\n-        this.nodeText = \"\";\n-        this.shortNodeText = \"\";\n-        this.font = new Font(\"Arial\", Font.PLAIN, 12);\n-        this.slotFont = new Font(\"Arial\", Font.PLAIN, 10);\n-        this.boldFont = this.font.deriveFont(Font.BOLD);\n-        this.cfg = false;\n-        this.blockConnections = new HashSet<>();\n-        this.graph = graph;\n+    public Diagram(InputGraph graph, String nodeText, String shortNodeText,\n+                   String tinyNodeText) {\n+        assert graph != null;\n+\n@@ -93,22 +64,5 @@\n-    }\n-\n-    public Block getBlock(InputBlock b) {\n-        assert blocks.containsKey(b);\n-        return blocks.get(b);\n-    }\n-\n-    public boolean hasBlock(InputBlock b) {\n-        return blocks.containsKey(b);\n-    }\n-\n-    public String getNodeText() {\n-        return nodeText;\n-    }\n-\n-    public String getShortNodeText() {\n-        return shortNodeText;\n-    }\n-\n-    public String getTinyNodeText() {\n-        return tinyNodeText;\n-    }\n+        this.figures = new ArrayList<>();\n+        this.blocks = new LinkedHashMap<>(8);\n+        this.blockConnections = new HashSet<>();\n+        this.cfg = false;\n+        int curId = 0;\n@@ -116,2 +70,0 @@\n-    public void updateBlocks() {\n-        blocks.clear();\n@@ -119,2 +71,1 @@\n-            Block curBlock = new Block(b, this);\n-            blocks.put(b, curBlock);\n+            blocks.put(b,  new Block(b, this));\n@@ -122,48 +73,0 @@\n-    }\n-\n-    public Collection<Block> getBlocks() {\n-        return Collections.unmodifiableCollection(blocks.values());\n-    }\n-\n-    public List<Figure> getFigures() {\n-        return Collections.unmodifiableList(figures);\n-    }\n-\n-    public Figure createFigure() {\n-        Figure f = new Figure(this, curId);\n-        curId++;\n-        this.figures.add(f);\n-        return f;\n-    }\n-\n-    public FigureConnection createConnection(InputSlot inputSlot, OutputSlot outputSlot, String label) {\n-        assert inputSlot.getFigure().getDiagram() == this;\n-        assert outputSlot.getFigure().getDiagram() == this;\n-        return new FigureConnection(inputSlot, outputSlot, label);\n-    }\n-\n-    public Map<InputNode, Set<Figure>> calcSourceToFigureRelation() {\n-        Map<InputNode, Set<Figure>> map = new HashMap<>();\n-\n-        for(InputNode node : this.getGraph().getNodes()) {\n-            map.put(node, new HashSet<Figure>());\n-        }\n-\n-        for(Figure f : this.getFigures()) {\n-            for(InputNode node : f.getSource().getSourceNodes()) {\n-                map.get(node).add(f);\n-            }\n-        }\n-\n-        return map;\n-    }\n-\n-    public static Diagram createDiagram(InputGraph graph, String nodeText,\n-                                        String shortNodeText,\n-                                        String tinyNodeText) {\n-        if (graph == null) {\n-            return null;\n-        }\n-\n-        Diagram d = new Diagram(graph, nodeText, shortNodeText, tinyNodeText);\n-        d.updateBlocks();\n@@ -174,2 +77,2 @@\n-            Figure f = d.createFigure();\n-            f.getSource().addSourceNode(n);\n+            Figure f = new Figure(this, curId, n);\n+            curId++;\n@@ -177,2 +80,1 @@\n-            f.setSubgraphs(n.getSubgraphs());\n-            f.setBlock(graph.getBlock(n));\n+            f.setBlock(blocks.get(graph.getBlock(n)));\n@@ -180,0 +82,1 @@\n+            this.figures.add(f);\n@@ -190,1 +93,0 @@\n-            assert fromFigure != null && toFigure != null;\n@@ -204,1 +106,1 @@\n-            FigureConnection c = d.createConnection(inputSlot, outputSlot, e.getLabel());\n+            FigureConnection c = createConnection(inputSlot, outputSlot, e.getLabel());\n@@ -214,3 +116,3 @@\n-            Block p = d.getBlock(e.getFrom());\n-            Block s = d.getBlock(e.getTo());\n-            d.blockConnections.add(new BlockConnection(p, s, e.getLabel()));\n+            Block p = getBlock(e.getFrom());\n+            Block s = getBlock(e.getTo());\n+            blockConnections.add(new BlockConnection(p, s, e.getLabel()));\n@@ -218,0 +120,1 @@\n+    }\n@@ -219,1 +122,37 @@\n-        return d;\n+    public Block getBlock(InputBlock b) {\n+        assert blocks.containsKey(b);\n+        return blocks.get(b);\n+    }\n+\n+    public boolean hasBlock(InputBlock b) {\n+        return blocks.containsKey(b);\n+    }\n+\n+    public String getNodeText() {\n+        return nodeText;\n+    }\n+\n+    public String getShortNodeText() {\n+        return shortNodeText;\n+    }\n+\n+    public String getTinyNodeText() {\n+        return tinyNodeText;\n+    }\n+\n+    public Collection<Block> getBlocks() {\n+        return Collections.unmodifiableCollection(blocks.values());\n+    }\n+\n+    public Collection<InputBlock> getInputBlocks() {\n+        return Collections.unmodifiableCollection(blocks.keySet());\n+    }\n+\n+    public List<Figure> getFigures() {\n+        return Collections.unmodifiableList(figures);\n+    }\n+\n+    public FigureConnection createConnection(InputSlot inputSlot, OutputSlot outputSlot, String label) {\n+        assert inputSlot.getFigure().getDiagram() == this;\n+        assert outputSlot.getFigure().getDiagram() == this;\n+        return new FigureConnection(inputSlot, outputSlot, label);\n@@ -226,1 +165,1 @@\n-                if (f.getBlock() == b.getInputBlock()) {\n+                if (f.getBlock() == b) {\n@@ -276,8 +215,0 @@\n-    public String getName() {\n-        return graph.getName();\n-    }\n-\n-    public InputGraph getGraph() {\n-        return graph;\n-    }\n-\n@@ -305,62 +236,0 @@\n-    public Figure getRootFigure() {\n-        Properties.PropertySelector<Figure> selector = new Properties.PropertySelector<>(figures);\n-        Figure root = selector.selectSingle(new StringPropertyMatcher(\"name\", \"Root\"));\n-        if (root == null) {\n-            root = selector.selectSingle(new StringPropertyMatcher(\"name\", \"Start\"));\n-        }\n-        if (root == null) {\n-            List<Figure> rootFigures = getRootFigures();\n-            if (rootFigures.size() > 0) {\n-                root = rootFigures.get(0);\n-            } else if (figures.size() > 0) {\n-                root = figures.get(0);\n-            }\n-        }\n-\n-        return root;\n-    }\n-\n-    public void printStatistics() {\n-        System.out.println(\"=============================================================\");\n-        System.out.println(\"Diagram statistics\");\n-\n-        List<Figure> tmpFigures = getFigures();\n-        Set<FigureConnection> connections = getConnections();\n-\n-        System.out.println(\"Number of figures: \" + tmpFigures.size());\n-        System.out.println(\"Number of connections: \" + connections.size());\n-\n-        List<Figure> figuresSorted = new ArrayList<>(tmpFigures);\n-        figuresSorted.sort(new Comparator<Figure>() {\n-\n-            @Override\n-            public int compare(Figure a, Figure b) {\n-                return b.getPredecessors().size() + b.getSuccessors().size() - a.getPredecessors().size() - a.getSuccessors().size();\n-            }\n-        });\n-\n-        final int COUNT = 10;\n-        int z = 0;\n-        for (Figure f : figuresSorted) {\n-\n-            z++;\n-            int sum = f.getPredecessors().size() + f.getSuccessors().size();\n-            System.out.println(\"#\" + z + \": \" + f + \", predCount=\" + f.getPredecessors().size() + \" succCount=\" + f.getSuccessors().size());\n-            if (sum < COUNT) {\n-                break;\n-            }\n-\n-        }\n-\n-        System.out.println(\"=============================================================\");\n-    }\n-\n-    public List<Figure> getRootFigures() {\n-        ArrayList<Figure> rootFigures = new ArrayList<>();\n-        for (Figure f : figures) {\n-            if (f.getPredecessors().size() == 0) {\n-                rootFigures.add(f);\n-            }\n-        }\n-        return rootFigures;\n-    }\n","filename":"src\/utils\/IdealGraphVisualizer\/Graph\/src\/main\/java\/com\/sun\/hotspot\/igv\/graph\/Diagram.java","additions":65,"deletions":196,"binary":false,"changes":261,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n-import com.sun.hotspot.igv.data.InputBlock;\n-import com.sun.hotspot.igv.data.InputGraph;\n@@ -30,1 +28,0 @@\n-import com.sun.hotspot.igv.data.Source;\n@@ -37,1 +34,1 @@\n-public class Figure extends Properties.Entity implements Source.Provider, Vertex {\n+public class Figure extends Properties.Entity implements Vertex {\n@@ -49,1 +46,1 @@\n-    private Source source;\n+    private InputNode inputNode;\n@@ -54,1 +51,0 @@\n-    private List<InputGraph> subgraphs;\n@@ -62,1 +58,1 @@\n-    private InputBlock block;\n+    private Block block;\n@@ -135,1 +131,1 @@\n-    protected Figure(Diagram diagram, int id) {\n+    protected Figure(Diagram diagram, int id, InputNode node) {\n@@ -137,5 +133,5 @@\n-        this.source = new Source();\n-        inputSlots = new ArrayList<>(5);\n-        outputSlots = new ArrayList<>(1);\n-        predecessors = new ArrayList<>(6);\n-        successors = new ArrayList<>(6);\n+        this.inputNode = node;\n+        this.inputSlots = new ArrayList<>(5);\n+        this.outputSlots = new ArrayList<>(1);\n+        this.predecessors = new ArrayList<>(6);\n+        this.successors = new ArrayList<>(6);\n@@ -143,2 +139,1 @@\n-        idString = Integer.toString(id);\n-\n+        this.idString = Integer.toString(id);\n@@ -148,1 +143,1 @@\n-        metrics = canvas.getFontMetrics(diagram.getFont().deriveFont(Font.BOLD));\n+        this.metrics = canvas.getFontMetrics(Diagram.FONT.deriveFont(Font.BOLD));\n@@ -175,1 +170,1 @@\n-    public void setBlock(InputBlock block) {\n+    public void setBlock(Block block) {\n@@ -179,1 +174,1 @@\n-    public InputBlock getBlock() {\n+    public Block getBlock() {\n@@ -225,8 +220,0 @@\n-    public List<InputGraph> getSubgraphs() {\n-        return subgraphs;\n-    }\n-\n-    public void setSubgraphs(List<InputGraph> subgraphs) {\n-        this.subgraphs = subgraphs;\n-    }\n-\n@@ -247,3 +234,2 @@\n-    @Override\n-    public Source getSource() {\n-        return source;\n+    public InputNode getInputNode() {\n+        return inputNode;\n@@ -354,1 +340,1 @@\n-            List<String> inputs = new ArrayList<String>(getPredecessors().size());\n+            List<String> inputs = new ArrayList<>(getPredecessors().size());\n@@ -369,1 +355,1 @@\n-        \/\/ Set the \"label\" property of each input node, so that by default\n+        \/\/ Set the \"label\" property of the input node, so that by default\n@@ -372,4 +358,3 @@\n-        for (InputNode n : getSource().getSourceNodes()) {\n-            String label = n.getProperties().resolveString(diagram.getNodeText());\n-            n.getProperties().setProperty(\"label\", label.replaceAll(\"\\\\R\", \" \"));\n-        }\n+        String label = inputNode.getProperties().resolveString(diagram.getNodeText());\n+        inputNode.getProperties().setProperty(\"label\", label.replaceAll(\"\\\\R\", \" \"));\n+\n@@ -393,4 +378,0 @@\n-    public InputNode getFirstSourceNode() {\n-        return getSource().getSourceNodes().get(0);\n-    }\n-\n@@ -402,10 +383,1 @@\n-        if (getSource().getSourceNodes().size() == 0) {\n-            assert false : \"Should never reach here, every figure must have at least one source node!\";\n-            return null;\n-        } else {\n-            final InputBlock inputBlock = diagram.getGraph().getBlock(getFirstSourceNode());\n-            assert inputBlock != null;\n-            Cluster result = diagram.getBlock(inputBlock);\n-            assert result != null;\n-            return result;\n-        }\n+        return block;\n@@ -416,4 +388,2 @@\n-\n-        List<InputNode> sourceNodes = source.getSourceNodes();\n-        if (sourceNodes.size() > 0 && getFirstSourceNode().getProperties().get(\"name\") != null) {\n-            return getFirstSourceNode().getProperties().get(\"name\").equals(\"Root\");\n+        if (inputNode != null && inputNode.getProperties().get(\"name\") != null) {\n+            return inputNode.getProperties().get(\"name\").equals(\"Root\");\n","filename":"src\/utils\/IdealGraphVisualizer\/Graph\/src\/main\/java\/com\/sun\/hotspot\/igv\/graph\/Figure.java","additions":23,"deletions":53,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-import com.sun.hotspot.igv.layout.Port;\n@@ -28,0 +27,1 @@\n+import com.sun.hotspot.igv.layout.Port;\n","filename":"src\/utils\/IdealGraphVisualizer\/Graph\/src\/main\/java\/com\/sun\/hotspot\/igv\/graph\/FigureConnection.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -81,18 +81,1 @@\n-    public static final Comparator<Slot> slotIndexComparator = new Comparator<Slot>() {\n-\n-        @Override\n-        public int compare(Slot o1, Slot o2) {\n-            return o1.wantedIndex - o2.wantedIndex;\n-        }\n-    };\n-    public static final Comparator<Slot> slotFigureComparator = new Comparator<Slot>() {\n-\n-        @Override\n-        public int compare(Slot o1, Slot o2) {\n-            return o1.figure.getId() - o2.figure.getId();\n-        }\n-    };\n-\n-    public InputNode getAssociatedNode() {\n-        return associatedNode;\n-    }\n+    public static final Comparator<Slot> slotIndexComparator = Comparator.comparingInt(o -> o.wantedIndex);\n@@ -110,1 +93,1 @@\n-            g.setFont(figure.getDiagram().getSlotFont().deriveFont(Font.BOLD));\n+            g.setFont(Diagram.SLOT_FONT.deriveFont(Font.BOLD));\n","filename":"src\/utils\/IdealGraphVisualizer\/Graph\/src\/main\/java\/com\/sun\/hotspot\/igv\/graph\/Slot.java","additions":2,"deletions":19,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -1,38 +0,0 @@\n-\/*\n- * Copyright (c) 2008, 2015, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-package com.sun.hotspot.igv.graph.services;\n-\n-import com.sun.hotspot.igv.data.ChangedEvent;\n-import com.sun.hotspot.igv.graph.Diagram;\n-\n-\/**\n- *\n- * @author Thomas Wuerthinger\n- *\/\n-public interface DiagramProvider {\n-    Diagram getDiagram();\n-    ChangedEvent<DiagramProvider> getChangedEvent();\n-\n-}\n","filename":"src\/utils\/IdealGraphVisualizer\/Graph\/src\/main\/java\/com\/sun\/hotspot\/igv\/graph\/services\/DiagramProvider.java","additions":0,"deletions":38,"binary":false,"changes":38,"status":"deleted"},{"patch":"@@ -26,0 +26,1 @@\n+import com.sun.hotspot.igv.layout.Cluster;\n@@ -28,1 +29,0 @@\n-import com.sun.hotspot.igv.layout.Cluster;\n@@ -38,2 +38,2 @@\n-    private ClusterNode from;\n-    private ClusterNode to;\n+    private final ClusterNode from;\n+    private final ClusterNode to;\n","filename":"src\/utils\/IdealGraphVisualizer\/HierarchicalLayout\/src\/main\/java\/com\/sun\/hotspot\/igv\/hierarchicallayout\/ClusterEdge.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+import com.sun.hotspot.igv.layout.Cluster;\n@@ -28,1 +29,0 @@\n-import com.sun.hotspot.igv.layout.Cluster;\n@@ -40,4 +40,2 @@\n-    private ClusterInputSlotNode inputSlotNode;\n-    private Link connection;\n-    private Port inputSlot;\n-    private Port outputSlot;\n+    private final Port inputSlot;\n+    private final Port outputSlot;\n@@ -46,3 +44,1 @@\n-        this.inputSlotNode = inputSlotNode;\n-        this.connection = c;\n-        this.controlPoints = new ArrayList<Point>();\n+        this.controlPoints = new ArrayList<>();\n@@ -54,8 +50,0 @@\n-    public Link getConnection() {\n-        return connection;\n-    }\n-\n-    public ClusterInputSlotNode getInputSlotNode() {\n-        return inputSlotNode;\n-    }\n-\n","filename":"src\/utils\/IdealGraphVisualizer\/HierarchicalLayout\/src\/main\/java\/com\/sun\/hotspot\/igv\/hierarchicallayout\/ClusterIngoingConnection.java","additions":4,"deletions":16,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n-    private final int SIZE = 0;\n@@ -40,10 +39,3 @@\n-    private Port inputSlot;\n-    private Port outputSlot;\n-    private ClusterNode blockNode;\n-    private InterClusterConnection interBlockConnection;\n-    private Cluster cluster;\n-    private ClusterIngoingConnection conn;\n-\n-    public void setIngoingConnection(ClusterIngoingConnection c) {\n-        conn = c;\n-    }\n+    private final Port inputSlot;\n+    private final Port outputSlot;\n+    private final ClusterNode blockNode;\n@@ -51,4 +43,1 @@\n-    public ClusterIngoingConnection getIngoingConnection() {\n-        return conn;\n-    }\n-    private String id;\n+    private final String id;\n@@ -82,1 +71,1 @@\n-                return \"OutPort of \" + thisNode.toString();\n+                return \"OutPort of \" + thisNode;\n@@ -101,1 +90,1 @@\n-                return \"InPort of \" + thisNode.toString();\n+                return \"InPort of \" + thisNode;\n@@ -110,4 +99,0 @@\n-    public InterClusterConnection getInterBlockConnection() {\n-        return interBlockConnection;\n-    }\n-\n@@ -119,0 +104,1 @@\n+        int SIZE = 0;\n@@ -130,4 +116,0 @@\n-    public void setInterBlockConnection(InterClusterConnection interBlockConnection) {\n-        this.interBlockConnection = interBlockConnection;\n-    }\n-\n@@ -135,1 +117,1 @@\n-        return cluster;\n+        return null;\n","filename":"src\/utils\/IdealGraphVisualizer\/HierarchicalLayout\/src\/main\/java\/com\/sun\/hotspot\/igv\/hierarchicallayout\/ClusterInputSlotNode.java","additions":8,"deletions":26,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -32,5 +32,1 @@\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.HashSet;\n-import java.util.List;\n-import java.util.Set;\n+import java.util.*;\n@@ -46,2 +42,1 @@\n-    private Port outputSlot;\n-    private Set<Vertex> subNodes;\n+    private final Set<Vertex> subNodes;\n@@ -50,2 +45,1 @@\n-    private Set<Link> subEdges;\n-    private boolean dirty;\n+    private final Set<Link> subEdges;\n@@ -53,1 +47,1 @@\n-    private String name;\n+    private final String name;\n@@ -62,2 +56,2 @@\n-        this.subNodes = new HashSet<Vertex>();\n-        this.subEdges = new HashSet<Link>();\n+        this.subNodes = new HashSet<>();\n+        this.subEdges = new HashSet<>();\n@@ -65,1 +59,1 @@\n-        position = new Point(0, 0);\n+        this.position = new Point(0, 0);\n@@ -97,2 +91,0 @@\n-\n-\n@@ -117,16 +109,0 @@\n-\n-        outputSlot = new Port() {\n-\n-            public Point getRelativePosition() {\n-                return new Point(size.width \/ 2, 0);\/\/size.height);\n-            }\n-\n-            public Vertex getVertex() {\n-                return widget;\n-            }\n-\n-            @Override\n-            public String toString() {\n-                return \"ClusterOutput(\" + name + \")\";\n-            }\n-        };\n@@ -177,1 +153,1 @@\n-            List<Point> points = new ArrayList<Point>(l.getControlPoints());\n+            List<Point> points = new ArrayList<>(l.getControlPoints());\n@@ -195,4 +171,0 @@\n-    public Port getOutputSlot() {\n-        return outputSlot;\n-    }\n-\n@@ -218,1 +190,1 @@\n-            ArrayList<Point> newArr = new ArrayList<Point>(arr.size());\n+            ArrayList<Point> newArr = new ArrayList<>(arr.size());\n@@ -241,4 +213,0 @@\n-    public void setDirty(boolean b) {\n-        dirty = b;\n-    }\n-\n","filename":"src\/utils\/IdealGraphVisualizer\/HierarchicalLayout\/src\/main\/java\/com\/sun\/hotspot\/igv\/hierarchicallayout\/ClusterNode.java","additions":9,"deletions":41,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+import com.sun.hotspot.igv.layout.Cluster;\n@@ -28,1 +29,0 @@\n-import com.sun.hotspot.igv.layout.Cluster;\n@@ -40,4 +40,2 @@\n-    private ClusterOutputSlotNode outputSlotNode;\n-    private Link connection;\n-    private Port inputSlot;\n-    private Port outputSlot;\n+    private final Port inputSlot;\n+    private final Port outputSlot;\n@@ -46,6 +44,3 @@\n-        this.outputSlotNode = outputSlotNode;\n-        this.connection = c;\n-        this.intermediatePoints = new ArrayList<Point>();\n-\n-        outputSlot = c.getFrom();\n-        inputSlot = outputSlotNode.getInputSlot();\n+        this.intermediatePoints = new ArrayList<>();\n+        this.outputSlot = c.getFrom();\n+        this.inputSlot = outputSlotNode.getInputSlot();\n","filename":"src\/utils\/IdealGraphVisualizer\/HierarchicalLayout\/src\/main\/java\/com\/sun\/hotspot\/igv\/hierarchicallayout\/ClusterOutgoingConnection.java","additions":6,"deletions":11,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n-    private final int SIZE = 0;\n@@ -40,4 +39,3 @@\n-    private Port inputSlot;\n-    private Port outputSlot;\n-    private ClusterNode blockNode;\n-    private boolean root;\n+    private final Port inputSlot;\n+    private final Port outputSlot;\n+    private final ClusterNode blockNode;\n@@ -46,1 +44,1 @@\n-    private String id;\n+    private final String id;\n@@ -82,1 +80,1 @@\n-                return \"InPort of \" + thisNode.toString();\n+                return \"InPort of \" + thisNode;\n@@ -91,1 +89,1 @@\n-                p.y = 0;\/\/thisBlockNode.getSize().height;\n+                p.y = 0;\n@@ -101,1 +99,1 @@\n-                return \"OutPort of \" + thisNode.toString();\n+                return \"OutPort of \" + thisNode;\n@@ -107,0 +105,1 @@\n+        int SIZE = 0;\n@@ -130,4 +129,0 @@\n-    public void setRoot(boolean b) {\n-        root = b;\n-    }\n-\n@@ -139,1 +134,1 @@\n-        return root;\n+        return false;\n","filename":"src\/utils\/IdealGraphVisualizer\/HierarchicalLayout\/src\/main\/java\/com\/sun\/hotspot\/igv\/hierarchicallayout\/ClusterOutputSlotNode.java","additions":9,"deletions":14,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -1,90 +0,0 @@\n-\/*\n- * Copyright (c) 2008, 2015, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-package com.sun.hotspot.igv.hierarchicallayout;\n-\n-\/**\n- *\n- * @author Thomas Wuerthinger\n- *\/\n-public class Edge<N, E> {\n-\n-    private E data;\n-    private Node<N, E> source;\n-    private Node<N, E> dest;\n-\n-    protected Edge(Graph<N, E> graph, Node<N, E> source, Node<N, E> dest, E data) {\n-        setData(data);\n-        this.source = source;\n-        this.dest = dest;\n-        assert source != null;\n-        assert dest != null;\n-        assert source.getGraph() == dest.getGraph();\n-        assert source.getGraph() != null;\n-        assert dest.getGraph() != null;\n-    }\n-\n-    public Node<N, E> getSource() {\n-        return source;\n-    }\n-\n-    public Node<N, E> getDest() {\n-        return dest;\n-    }\n-\n-    public E getData() {\n-        return data;\n-    }\n-\n-    public void setData(E e) {\n-        data = e;\n-    }\n-\n-    public void remove() {\n-        source.getGraph().removeEdge(this, null);\n-    }\n-\n-    public boolean isSelfLoop() {\n-        return source == dest;\n-    }\n-\n-    public void reverse() {\n-\n-        \/\/ Remove from current source \/ dest\n-        source.removeOutEdge(this);\n-        dest.removeInEdge(this);\n-\n-        Node<N, E> tmp = source;\n-        source = dest;\n-        dest = tmp;\n-\n-        \/\/ Add to new source \/ dest\n-        source.addOutEdge(this);\n-        dest.addInEdge(this);\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return \"Edge (\" + source + \" -- \" + dest + \"): \" + data;\n-    }\n-}\n","filename":"src\/utils\/IdealGraphVisualizer\/HierarchicalLayout\/src\/main\/java\/com\/sun\/hotspot\/igv\/hierarchicallayout\/Edge.java","additions":0,"deletions":90,"binary":false,"changes":90,"status":"deleted"},{"patch":"@@ -1,292 +0,0 @@\n-\/*\n- * Copyright (c) 2008, 2015, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-package com.sun.hotspot.igv.hierarchicallayout;\n-\n-import java.util.*;\n-\n-\/**\n- *\n- * @author Thomas Wuerthinger\n- *\/\n-public class Graph<N, E> {\n-\n-    private HashMap<Object, Node<N, E>> nodes;\n-    private HashMap<Object, Edge<N, E>> edges;\n-    private List<Node<N, E>> nodeList;\n-\n-    public Graph() {\n-        nodes = new HashMap<>();\n-        edges = new HashMap<>();\n-        nodeList = new ArrayList<>();\n-    }\n-\n-    public Node<N, E> createNode(N data, Object key) {\n-        Node<N, E> n = new Node<>(this, data);\n-        assert key == null || !nodes.containsKey(key);\n-        if (key != null) {\n-            nodes.put(key, n);\n-        }\n-        nodeList.add(n);\n-        return n;\n-    }\n-\n-    public Edge<N, E> createEdge(Node<N, E> source, Node<N, E> dest, E data, Object key) {\n-        Edge<N, E> e = new Edge<>(this, source, dest, data);\n-        source.addOutEdge(e);\n-        dest.addInEdge(e);\n-        if (key != null) {\n-            edges.put(key, e);\n-        }\n-        return e;\n-    }\n-\n-    public Node<N, E> getNode(Object key) {\n-        return nodes.get(key);\n-    }\n-\n-    public Edge<N, E> getEdge(Object key) {\n-        return edges.get(key);\n-    }\n-\n-    public Collection<Edge<N, E>> getEdges() {\n-        return Collections.unmodifiableCollection(edges.values());\n-    }\n-\n-    public Collection<Node<N, E>> getNodes() {\n-        return Collections.unmodifiableList(nodeList);\n-    }\n-\n-    public void removeEdge(Edge<N, E> e, Object key) {\n-        assert key == null || edges.containsKey(key);\n-        if (key != null) {\n-            edges.remove(key);\n-        }\n-        e.getSource().removeOutEdge(e);\n-        e.getDest().removeInEdge(e);\n-    }\n-\n-    public class DFSTraversalVisitor {\n-\n-        public void visitNode(Node<N, E> n) {\n-        }\n-\n-        public boolean visitEdge(Edge<N, E> e, boolean backEdge) {\n-            return true;\n-        }\n-    }\n-\n-    public class BFSTraversalVisitor {\n-\n-        public void visitNode(Node<N, E> n, int depth) {\n-        }\n-    }\n-\n-    public List<Node<N, E>> getNodesWithInDegree(int x) {\n-        return getNodesWithInDegree(x, true);\n-    }\n-\n-    public List<Node<N, E>> getNodesWithInDegree(int x, boolean countSelfLoops) {\n-\n-        List<Node<N, E>> result = new ArrayList<>();\n-        for (Node<N, E> n : getNodes()) {\n-            if (n.getInDegree(countSelfLoops) == x) {\n-                result.add(n);\n-            }\n-        }\n-\n-        return result;\n-\n-    }\n-\n-    private void markReachable(Node<N, E> startingNode) {\n-        ArrayList<Node<N, E>> arr = new ArrayList<>();\n-        arr.add(startingNode);\n-        for (Node<N, E> n : getNodes()) {\n-            n.setReachable(false);\n-        }\n-        traverseDFS(arr, new DFSTraversalVisitor() {\n-\n-            @Override\n-            public void visitNode(Node<N, E> n) {\n-                n.setReachable(true);\n-            }\n-        });\n-    }\n-\n-    public void traverseBFS(Node<N, E> startingNode, BFSTraversalVisitor tv, boolean longestPath) {\n-\n-        if (longestPath) {\n-            markReachable(startingNode);\n-        }\n-\n-        for (Node<N, E> n : getNodes()) {\n-            n.setVisited(false);\n-            n.setActive(false);\n-        }\n-\n-        Queue<Node<N, E>> queue = new LinkedList<>();\n-        queue.add(startingNode);\n-        startingNode.setVisited(true);\n-        int layer = 0;\n-        Node<N, E> lastOfLayer = startingNode;\n-        Node<N, E> lastAdded = null;\n-\n-        while (!queue.isEmpty()) {\n-\n-            Node<N, E> current = queue.poll();\n-            tv.visitNode(current, layer);\n-            current.setActive(false);\n-\n-\n-            for (Edge<N, E> e : current.getOutEdges()) {\n-                if (!e.getDest().isVisited()) {\n-\n-                    boolean allow = true;\n-                    if (longestPath) {\n-                        for (Node<N, E> pred : e.getDest().getPredecessors()) {\n-                            if ((!pred.isVisited() || pred.isActive()) && pred.isReachable()) {\n-                                allow = false;\n-                                break;\n-                            }\n-                        }\n-                    }\n-\n-                    if (allow) {\n-                        queue.offer(e.getDest());\n-                        lastAdded = e.getDest();\n-                        e.getDest().setVisited(true);\n-                        e.getDest().setActive(true);\n-                    }\n-                }\n-            }\n-\n-            if (current == lastOfLayer && !queue.isEmpty()) {\n-                lastOfLayer = lastAdded;\n-                layer++;\n-            }\n-        }\n-    }\n-\n-    public void traverseDFS(DFSTraversalVisitor tv) {\n-        traverseDFS(getNodes(), tv);\n-    }\n-\n-    public void traverseDFS(Collection<Node<N, E>> startingNodes, DFSTraversalVisitor tv) {\n-\n-        for (Node<N, E> n : getNodes()) {\n-            n.setVisited(false);\n-            n.setActive(false);\n-        }\n-\n-        boolean result = false;\n-        for (Node<N, E> n : startingNodes) {\n-            traverse(tv, n);\n-        }\n-    }\n-\n-    private void traverse(DFSTraversalVisitor tv, Node<N, E> n) {\n-\n-        if (!n.isVisited()) {\n-            n.setVisited(true);\n-            n.setActive(true);\n-            tv.visitNode(n);\n-\n-            for (Edge<N, E> e : n.getOutEdges()) {\n-\n-                Node<N, E> next = e.getDest();\n-                if (next.isActive()) {\n-                    tv.visitEdge(e, true);\n-                } else {\n-                    if (tv.visitEdge(e, false)) {\n-                        traverse(tv, next);\n-                    }\n-                }\n-            }\n-\n-            n.setActive(false);\n-        }\n-\n-    }\n-\n-    public boolean hasCycles() {\n-\n-        for (Node<N, E> n : getNodes()) {\n-            n.setVisited(false);\n-            n.setActive(false);\n-        }\n-\n-        boolean result = false;\n-        for (Node<N, E> n : getNodes()) {\n-            result |= checkCycles(n);\n-            if (result) {\n-                break;\n-            }\n-        }\n-        return result;\n-    }\n-\n-    private boolean checkCycles(Node<N, E> n) {\n-\n-        if (n.isActive()) {\n-            return true;\n-        }\n-\n-        if (!n.isVisited()) {\n-\n-            n.setVisited(true);\n-            n.setActive(true);\n-\n-            for (Node<N, E> succ : n.getSuccessors()) {\n-                if (checkCycles(succ)) {\n-                    return true;\n-                }\n-            }\n-\n-            n.setActive(false);\n-\n-        }\n-\n-        return false;\n-    }\n-\n-    @Override\n-    public String toString() {\n-\n-        StringBuilder s = new StringBuilder();\n-        s.append(\"Nodes: \");\n-        for (Node<N, E> n : getNodes()) {\n-            s.append(n.toString());\n-            s.append(\"\\n\");\n-        }\n-\n-        s.append(\"Edges: \");\n-\n-        for (Edge<N, E> e : getEdges()) {\n-            s.append(e.toString());\n-            s.append(\"\\n\");\n-        }\n-\n-        return s.toString();\n-    }\n-}\n","filename":"src\/utils\/IdealGraphVisualizer\/HierarchicalLayout\/src\/main\/java\/com\/sun\/hotspot\/igv\/hierarchicallayout\/Graph.java","additions":0,"deletions":292,"binary":false,"changes":292,"status":"deleted"},{"patch":"@@ -26,8 +26,0 @@\n-import java.awt.Dimension;\n-import java.awt.Rectangle;\n-import java.awt.Canvas;\n-import java.awt.Font;\n-import java.awt.FontMetrics;\n-import java.util.*;\n-import com.sun.hotspot.igv.layout.Cluster;\n-import com.sun.hotspot.igv.layout.LayoutGraph;\n@@ -35,2 +27,3 @@\n-import com.sun.hotspot.igv.layout.Link;\n-import com.sun.hotspot.igv.layout.Vertex;\n+import com.sun.hotspot.igv.layout.*;\n+import java.awt.*;\n+import java.util.*;\n@@ -41,1 +34,1 @@\n-    private FontMetrics fontMetrics;\n+    private final FontMetrics fontMetrics;\n@@ -81,1 +74,1 @@\n-            subManager.doLayout(new LayoutGraph(n.getSubEdges(), n.getSubNodes()), new HashSet<Link>());\n+            subManager.doLayout(new LayoutGraph(n.getSubEdges(), n.getSubNodes()), new HashSet<>());\n@@ -86,2 +79,1 @@\n-        manager.doLayout(new LayoutGraph(clusterEdges, new HashSet<>(clusterNode.values())),\n-                         new HashSet<Link>());\n+        manager.doLayout(new LayoutGraph(clusterEdges, new HashSet<>(clusterNode.values())), new HashSet<>());\n@@ -147,1 +139,1 @@\n-            inputLink.put(new AbstractMap.SimpleEntry<Cluster, Cluster>(l.getFromCluster(), l.getToCluster()), l);\n+            inputLink.put(new AbstractMap.SimpleEntry<>(l.getFromCluster(), l.getToCluster()), l);\n@@ -151,1 +143,1 @@\n-            Link l = inputLink.get(new AbstractMap.SimpleEntry<Cluster, Cluster>(ce.getFromCluster(), ce.getToCluster()));\n+            Link l = inputLink.get(new AbstractMap.SimpleEntry<>(ce.getFromCluster(), ce.getToCluster()));\n","filename":"src\/utils\/IdealGraphVisualizer\/HierarchicalLayout\/src\/main\/java\/com\/sun\/hotspot\/igv\/hierarchicallayout\/HierarchicalCFGLayoutManager.java","additions":8,"deletions":16,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+import com.sun.hotspot.igv.layout.*;\n@@ -28,12 +29,1 @@\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Set;\n-import java.util.ArrayList;\n-import java.util.HashSet;\n-import java.util.TreeSet;\n-import com.sun.hotspot.igv.layout.Cluster;\n-import com.sun.hotspot.igv.layout.LayoutGraph;\n-import com.sun.hotspot.igv.layout.LayoutManager;\n-import com.sun.hotspot.igv.layout.Link;\n-import com.sun.hotspot.igv.layout.Port;\n-import com.sun.hotspot.igv.layout.Vertex;\n+import java.util.*;\n@@ -56,4 +46,0 @@\n-    public void doLayout(LayoutGraph graph) {\n-        doLayout(graph, new HashSet<Vertex>(), new HashSet<Vertex>(), new HashSet<Link>());\n-    }\n-\n@@ -72,1 +58,1 @@\n-    public void doLayout(LayoutGraph graph, Set<? extends Vertex> firstLayerHint, Set<? extends Vertex> lastLayerHint, Set<? extends Link> importantLinks) {\n+    public void doLayout(LayoutGraph graph) {\n@@ -76,14 +62,13 @@\n-        HashMap<Cluster, List<Vertex>> lists = new HashMap<Cluster, List<Vertex>>();\n-        HashMap<Cluster, List<Link>> listsConnection = new HashMap<Cluster, List<Link>>();\n-        HashMap<Cluster, HashMap<Port, ClusterInputSlotNode>> clusterInputSlotHash = new HashMap<Cluster, HashMap<Port, ClusterInputSlotNode>>();\n-        HashMap<Cluster, HashMap<Port, ClusterOutputSlotNode>> clusterOutputSlotHash = new HashMap<Cluster, HashMap<Port, ClusterOutputSlotNode>>();\n-\n-        HashMap<Cluster, ClusterNode> clusterNodes = new HashMap<Cluster, ClusterNode>();\n-        HashMap<Cluster, Set<ClusterInputSlotNode>> clusterInputSlotSet = new HashMap<Cluster, Set<ClusterInputSlotNode>>();\n-        HashMap<Cluster, Set<ClusterOutputSlotNode>> clusterOutputSlotSet = new HashMap<Cluster, Set<ClusterOutputSlotNode>>();\n-        Set<Link> clusterEdges = new HashSet<Link>();\n-        Set<Link> interClusterEdges = new HashSet<Link>();\n-        HashMap<Link, ClusterOutgoingConnection> linkClusterOutgoingConnection = new HashMap<Link, ClusterOutgoingConnection>();\n-        HashMap<Link, InterClusterConnection> linkInterClusterConnection = new HashMap<Link, InterClusterConnection>();\n-        HashMap<Link, ClusterIngoingConnection> linkClusterIngoingConnection = new HashMap<Link, ClusterIngoingConnection>();\n-        Set<ClusterNode> clusterNodeSet = new HashSet<ClusterNode>();\n+        HashMap<Cluster, List<Link>> listsConnection = new HashMap<>();\n+        HashMap<Cluster, HashMap<Port, ClusterInputSlotNode>> clusterInputSlotHash = new HashMap<>();\n+        HashMap<Cluster, HashMap<Port, ClusterOutputSlotNode>> clusterOutputSlotHash = new HashMap<>();\n+\n+        HashMap<Cluster, ClusterNode> clusterNodes = new HashMap<>();\n+        HashMap<Cluster, Set<ClusterInputSlotNode>> clusterInputSlotSet = new HashMap<>();\n+        HashMap<Cluster, Set<ClusterOutputSlotNode>> clusterOutputSlotSet = new HashMap<>();\n+        Set<Link> clusterEdges = new HashSet<>();\n+        Set<Link> interClusterEdges = new HashSet<>();\n+        HashMap<Link, ClusterOutgoingConnection> linkClusterOutgoingConnection = new HashMap<>();\n+        HashMap<Link, InterClusterConnection> linkInterClusterConnection = new HashMap<>();\n+        HashMap<Link, ClusterIngoingConnection> linkClusterIngoingConnection = new HashMap<>();\n+        Set<ClusterNode> clusterNodeSet = new HashSet<>();\n@@ -94,6 +79,5 @@\n-            lists.put(c, new ArrayList<Vertex>());\n-            listsConnection.put(c, new ArrayList<Link>());\n-            clusterInputSlotHash.put(c, new HashMap<Port, ClusterInputSlotNode>());\n-            clusterOutputSlotHash.put(c, new HashMap<Port, ClusterOutputSlotNode>());\n-            clusterOutputSlotSet.put(c, new TreeSet<ClusterOutputSlotNode>());\n-            clusterInputSlotSet.put(c, new TreeSet<ClusterInputSlotNode>());\n+            listsConnection.put(c, new ArrayList<>());\n+            clusterInputSlotHash.put(c, new HashMap<>());\n+            clusterOutputSlotHash.put(c, new HashMap<>());\n+            clusterOutputSlotSet.put(c, new TreeSet<>());\n+            clusterInputSlotSet.put(c, new TreeSet<>());\n@@ -159,1 +143,1 @@\n-                    outputSlotNode = new ClusterOutputSlotNode(clusterNodes.get(fromCluster), \"Out \" + fromCluster.toString() + \" \" + samePort.toString());\n+                    outputSlotNode = new ClusterOutputSlotNode(clusterNodes.get(fromCluster), \"Out \" + fromCluster.toString() + \" \" + samePort);\n@@ -174,1 +158,1 @@\n-                    inputSlotNode = new ClusterInputSlotNode(clusterNodes.get(toCluster), \"In \" + toCluster.toString() + \" \" + samePort.toString());\n+                    inputSlotNode = new ClusterInputSlotNode(clusterNodes.get(toCluster), \"In \" + toCluster.toString() + \" \" + samePort);\n@@ -179,1 +163,0 @@\n-                inputSlotNode.setIngoingConnection(conn);\n@@ -181,3 +164,1 @@\n-                if (samePort != null) {\n-                    clusterInputSlotHash.get(toCluster).put(samePort, inputSlotNode);\n-                }\n+                clusterInputSlotHash.get(toCluster).put(samePort, inputSlotNode);\n@@ -238,1 +219,1 @@\n-                List<Point> points = new ArrayList<Point>();\n+                List<Point> points = new ArrayList<>();\n","filename":"src\/utils\/IdealGraphVisualizer\/HierarchicalLayout\/src\/main\/java\/com\/sun\/hotspot\/igv\/hierarchicallayout\/HierarchicalClusterLayoutManager.java","additions":25,"deletions":44,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -59,3 +59,3 @@\n-    private Combine combine;\n-    private int dummyWidth;\n-    private int dummyHeight;\n+    private final Combine combine;\n+    private final int dummyWidth;\n+    private final int dummyHeight;\n@@ -74,1 +74,0 @@\n-    private HashMap<LayoutEdge, LayoutEdge> bottomEdgeHash;\n@@ -81,1 +80,1 @@\n-    private Set<Link> linksToFollow;\n+    private final Set<Link> linksToFollow;\n@@ -126,1 +125,1 @@\n-    private abstract class AlgorithmPart {\n+    private abstract static class AlgorithmPart {\n@@ -162,4 +161,0 @@\n-    public HierarchicalLayoutManager() {\n-        this(Combine.NONE);\n-    }\n-\n@@ -186,4 +181,0 @@\n-    public int getMaxLayerLength() {\n-        return maxLayerLength;\n-    }\n-\n@@ -219,1 +210,1 @@\n-        doLayout(graph, new HashSet<Link>());\n+        doLayout(graph, new HashSet<>());\n@@ -234,1 +225,0 @@\n-        bottomEdgeHash = new HashMap<>();\n@@ -455,1 +445,0 @@\n-                                \/\/checkPoints(points);\n@@ -479,1 +468,0 @@\n-                            \/\/checkPoints(points);\n@@ -541,14 +529,7 @@\n-    private static class Segment {\n-\n-        public float d;\n-        public int orderNumber = -1;\n-        public ArrayList<LayoutNode> nodes = new ArrayList<>();\n-        public HashSet<Segment> succs = new HashSet<>();\n-        public HashSet<Segment> preds = new HashSet<>();\n-        public Region region;\n-    }\n-    private static final Comparator<Segment> segmentComparator = new Comparator<Segment>() {\n-\n-        @Override\n-        public int compare(Segment s1, Segment s2) {\n-            return s1.orderNumber - s2.orderNumber;\n+    private static final Comparator<LayoutNode> nodePositionComparator = Comparator.comparingInt(n -> n.pos);\n+    private static final Comparator<LayoutNode> nodeProcessingDownComparator = (n1, n2) -> {\n+        int n1VIP = 0;\n+        for (LayoutEdge e : n1.preds) {\n+            if (e.vip) {\n+                n1VIP++;\n+            }\n@@ -556,15 +537,5 @@\n-    };\n-\n-    private static class Region {\n-\n-        public float d;\n-        public int minOrderNumber;\n-        public SortedSet<Segment> segments = new TreeSet<>(segmentComparator);\n-        public HashSet<Region> succs = new HashSet<>(4);\n-        public HashSet<Region> preds = new HashSet<>(4);\n-    }\n-    private static final Comparator<Region> regionComparator = new Comparator<Region>() {\n-\n-        @Override\n-        public int compare(Region r1, Region r2) {\n-            return r1.minOrderNumber - r2.minOrderNumber;\n+        int n2VIP = 0;\n+        for (LayoutEdge e : n2.preds) {\n+            if (e.vip) {\n+                n2VIP++;\n+            }\n@@ -572,6 +543,2 @@\n-    };\n-    private static final Comparator<LayoutNode> nodePositionComparator = new Comparator<LayoutNode>() {\n-\n-        @Override\n-        public int compare(LayoutNode n1, LayoutNode n2) {\n-            return n1.pos - n2.pos;\n+        if (n1VIP != n2VIP) {\n+            return n2VIP - n1VIP;\n@@ -579,25 +546,1 @@\n-    };\n-    private static final Comparator<LayoutNode> nodeProcessingDownComparator = new Comparator<LayoutNode>() {\n-        @Override\n-        public int compare(LayoutNode n1, LayoutNode n2) {\n-            int n1VIP = 0;\n-            for (LayoutEdge e : n1.preds) {\n-                if (e.vip) {\n-                    n1VIP++;\n-                }\n-            }\n-            int n2VIP = 0;\n-            for (LayoutEdge e : n2.preds) {\n-                if (e.vip) {\n-                    n2VIP++;\n-                }\n-            }\n-            if (n1VIP != n2VIP) {\n-                return n2VIP - n1VIP;\n-            }\n-            if (n1.vertex == null) {\n-                if (n2.vertex == null) {\n-                    return 0;\n-                }\n-                return -1;\n-            }\n+        if (n1.vertex == null) {\n@@ -605,1 +548,1 @@\n-                return 1;\n+                return 0;\n@@ -607,1 +550,4 @@\n-            return n1.preds.size() - n2.preds.size();\n+            return -1;\n+        }\n+        if (n2.vertex == null) {\n+            return 1;\n@@ -609,0 +555,1 @@\n+        return n1.preds.size() - n2.preds.size();\n@@ -697,1 +644,0 @@\n-                \/\/               space[i] = new ArrayList<>();\n@@ -701,1 +647,0 @@\n-\/\/                    curX += n.width + xOffset;\n@@ -817,2 +762,2 @@\n-        private TreeSet<LayoutNode> treeSet;\n-        private ArrayList<Integer> space;\n+        private final TreeSet<LayoutNode> treeSet;\n+        private final ArrayList<Integer> space;\n@@ -835,1 +780,1 @@\n-            LayoutNode leftNeighbor = null;\n+            LayoutNode leftNeighbor;\n@@ -846,1 +791,1 @@\n-                LayoutNode rightNeighbor = null;\n+                LayoutNode rightNeighbor;\n@@ -854,5 +799,1 @@\n-                if (pos > maxX) {\n-                    n.x = maxX;\n-                } else {\n-                    n.x = pos;\n-                }\n+                n.x = Math.min(pos, maxX);\n@@ -866,7 +807,1 @@\n-    private static Comparator<LayoutNode> crossingNodeComparator = new Comparator<LayoutNode>() {\n-\n-        @Override\n-        public int compare(LayoutNode n1, LayoutNode n2) {\n-            return n1.crossingNumber - n2.crossingNumber;\n-        }\n-    };\n+    private static final Comparator<LayoutNode> crossingNodeComparator = Comparator.comparingInt(n -> n.crossingNumber);\n@@ -948,2 +883,1 @@\n-\n-            for (int i = 0; i < layers.length; i++) {\n+            for (List<LayoutNode> layer : layers) {\n@@ -951,1 +885,1 @@\n-                for (LayoutNode n : layers[i]) {\n+                for (LayoutNode n : layer) {\n@@ -1091,1 +1025,1 @@\n-            for (int i = 0; i < layers.length; i++) {\n+            for (List<LayoutNode> layer : layers) {\n@@ -1095,1 +1029,1 @@\n-                for (LayoutNode n : layers[i]) {\n+                for (LayoutNode n : layer) {\n@@ -1102,1 +1036,1 @@\n-                for (LayoutNode n : layers[i]) {\n+                for (LayoutNode n : layer) {\n@@ -1150,7 +1084,1 @@\n-                Comparator<LayoutEdge> comparator = new Comparator<LayoutEdge>() {\n-\n-                    @Override\n-                    public int compare(LayoutEdge e1, LayoutEdge e2) {\n-                        return e1.to.layer - e2.to.layer;\n-                    }\n-                };\n+                Comparator<LayoutEdge> comparator = Comparator.comparingInt(e -> e.to.layer);\n@@ -1168,1 +1096,1 @@\n-                            if (maxLayerLength != -1 && e.to.layer - e.from.layer > maxLayerLength\/* && e.to.preds.size() > 1 && e.from.succs.size() > 1*\/) {\n+                            if (maxLayerLength != -1 && e.to.layer - e.from.layer > maxLayerLength) {\n@@ -1173,1 +1101,1 @@\n-                                LayoutEdge topEdge = null;\n+                                LayoutEdge topEdge;\n@@ -1196,1 +1124,1 @@\n-                                    topEdge.relativeTo = topNode.width \/ 2;\n+                                    topEdge.relativeTo = 0;\n@@ -1203,1 +1131,1 @@\n-                                    bottomNodeHash.put(e.relativeFrom, new HashMap<Integer, LayoutNode>());\n+                                    bottomNodeHash.put(e.relativeFrom, new HashMap<>());\n@@ -1208,1 +1136,1 @@\n-                                LayoutNode bottomNode = null;\n+                                LayoutNode bottomNode;\n@@ -1229,1 +1157,0 @@\n-                                bottomEdgeHash.put(topEdge, bottomEdge);\n@@ -1235,1 +1162,1 @@\n-                                    portHash.put(i, new ArrayList<LayoutEdge>());\n+                                    portHash.put(i, new ArrayList<>());\n@@ -1764,7 +1691,4 @@\n-    private Comparator<Link> linkComparator = new Comparator<Link>() {\n-\n-        @Override\n-        public int compare(Link l1, Link l2) {\n-            if (l1.isVIP() && !l2.isVIP()) {\n-                return -1;\n-            }\n+    private final Comparator<Link> linkComparator = (l1, l2) -> {\n+        if (l1.isVIP() && !l2.isVIP()) {\n+            return -1;\n+        }\n@@ -1772,3 +1696,3 @@\n-            if (!l1.isVIP() && l2.isVIP()) {\n-                return 1;\n-            }\n+        if (!l1.isVIP() && l2.isVIP()) {\n+            return 1;\n+        }\n@@ -1776,13 +1700,10 @@\n-            int result = l1.getFrom().getVertex().compareTo(l2.getFrom().getVertex());\n-            if (result != 0) {\n-                return result;\n-            }\n-            result = l1.getTo().getVertex().compareTo(l2.getTo().getVertex());\n-            if (result != 0) {\n-                return result;\n-            }\n-            result = l1.getFrom().getRelativePosition().x - l2.getFrom().getRelativePosition().x;\n-            if (result != 0) {\n-                return result;\n-            }\n-            result = l1.getTo().getRelativePosition().x - l2.getTo().getRelativePosition().x;\n+        int result = l1.getFrom().getVertex().compareTo(l2.getFrom().getVertex());\n+        if (result != 0) {\n+            return result;\n+        }\n+        result = l1.getTo().getVertex().compareTo(l2.getTo().getVertex());\n+        if (result != 0) {\n+            return result;\n+        }\n+        result = l1.getFrom().getRelativePosition().x - l2.getFrom().getRelativePosition().x;\n+        if (result != 0) {\n@@ -1791,0 +1712,2 @@\n+        result = l1.getTo().getRelativePosition().x - l2.getTo().getRelativePosition().x;\n+        return result;\n@@ -1800,5 +1723,2 @@\n-            Collections.sort(vertices,\n-                             (Vertex a, Vertex b) ->\n-                             a.isRoot() == b.isRoot() ?\n-                             a.compareTo(b) :\n-                             Boolean.compare(b.isRoot(), a.isRoot()));\n+            vertices.sort((Vertex a, Vertex b) ->\n+                    a.isRoot() == b.isRoot() ? a.compareTo(b) : Boolean.compare(b.isRoot(), a.isRoot()));\n","filename":"src\/utils\/IdealGraphVisualizer\/HierarchicalLayout\/src\/main\/java\/com\/sun\/hotspot\/igv\/hierarchicallayout\/HierarchicalLayoutManager.java","additions":66,"deletions":146,"binary":false,"changes":212,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+import com.sun.hotspot.igv.layout.Cluster;\n@@ -28,1 +29,0 @@\n-import com.sun.hotspot.igv.layout.Cluster;\n@@ -39,2 +39,2 @@\n-    private Port inputSlot;\n-    private Port outputSlot;\n+    private final Port inputSlot;\n+    private final Port outputSlot;\n@@ -42,2 +42,0 @@\n-    private ClusterInputSlotNode inputSlotNode;\n-    private ClusterOutputSlotNode outputSlotNode;\n@@ -46,2 +44,0 @@\n-        this.outputSlotNode = outputSlotNode;\n-        this.inputSlotNode = inputSlotNode;\n@@ -50,5 +46,1 @@\n-        intermediatePoints = new ArrayList<Point>();\n-    }\n-\n-    public ClusterOutputSlotNode getOutputSlotNode() {\n-        return outputSlotNode;\n+        this.intermediatePoints = new ArrayList<>();\n","filename":"src\/utils\/IdealGraphVisualizer\/HierarchicalLayout\/src\/main\/java\/com\/sun\/hotspot\/igv\/hierarchicallayout\/InterClusterConnection.java","additions":4,"deletions":12,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-        doLayout(graph, new HashSet<Link>());\n+        doLayout(graph, new HashSet<>());\n","filename":"src\/utils\/IdealGraphVisualizer\/HierarchicalLayout\/src\/main\/java\/com\/sun\/hotspot\/igv\/hierarchicallayout\/LinearLayoutManager.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,161 +0,0 @@\n-\/*\n- * Copyright (c) 2008, 2015, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-package com.sun.hotspot.igv.hierarchicallayout;\n-\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.List;\n-\n-\/**\n- *\n- * @author Thomas Wuerthinger\n- *\/\n-public class Node<N, E> {\n-\n-    private N data;\n-    private List<Edge<N, E>> inEdges;\n-    private List<Edge<N, E>> outEdges;\n-    private boolean visited;\n-    private boolean active;\n-    private boolean reachable;\n-    private Graph<N, E> graph;\n-\n-    protected boolean isVisited() {\n-        return visited;\n-    }\n-\n-    protected void setVisited(boolean b) {\n-        visited = b;\n-    }\n-\n-    protected boolean isReachable() {\n-        return reachable;\n-    }\n-\n-    protected void setReachable(boolean b) {\n-        reachable = b;\n-    }\n-\n-    protected boolean isActive() {\n-        return active;\n-    }\n-\n-    protected void setActive(boolean b) {\n-        active = b;\n-    }\n-\n-    public int getInDegree() {\n-        return getInDegree(true);\n-    }\n-\n-    public int getInDegree(boolean countSelfLoops) {\n-        if (countSelfLoops) {\n-            return inEdges.size();\n-        } else {\n-            int cnt = 0;\n-            for (Edge<N, E> e : inEdges) {\n-                if (e.getSource() != this) {\n-                    cnt++;\n-                }\n-            }\n-            return cnt;\n-        }\n-    }\n-\n-    public int getOutDegree() {\n-        return outEdges.size();\n-    }\n-\n-    protected Node(Graph<N, E> graph, N data) {\n-        setData(data);\n-        this.graph = graph;\n-        inEdges = new ArrayList<>();\n-        outEdges = new ArrayList<>();\n-    }\n-\n-    protected void addInEdge(Edge<N, E> e) {\n-        inEdges.add(e);\n-    }\n-\n-    public Graph<N, E> getGraph() {\n-        return graph;\n-    }\n-\n-    protected void addOutEdge(Edge<N, E> e) {\n-        outEdges.add(e);\n-    }\n-\n-    protected void removeInEdge(Edge<N, E> e) {\n-        \/\/assert inEdges.contains(e);\n-        inEdges.remove(e);\n-    }\n-\n-    protected void removeOutEdge(Edge<N, E> e) {\n-        \/\/assert outEdges.contains(e);\n-        outEdges.remove(e);\n-    }\n-\n-    public List<Edge<N, E>> getInEdges() {\n-        return Collections.unmodifiableList(inEdges);\n-    }\n-\n-    public List<Edge<N, E>> getOutEdges() {\n-        return Collections.unmodifiableList(outEdges);\n-    }\n-\n-    public List<Node<N, E>> getSuccessors() {\n-        ArrayList<Node<N, E>> succ = new ArrayList<>();\n-        for (Edge<N, E> e : getOutEdges()) {\n-            Node<N, E> n = e.getDest();\n-            if (!succ.contains(n)) {\n-                succ.add(n);\n-            }\n-        }\n-        return succ;\n-    }\n-\n-    public List<Node<N, E>> getPredecessors() {\n-        ArrayList<Node<N, E>> pred = new ArrayList<>();\n-        for (Edge<N, E> e : getInEdges()) {\n-            Node<N, E> n = e.getSource();\n-            if (!pred.contains(n)) {\n-                pred.add(n);\n-            }\n-        }\n-        return pred;\n-    }\n-\n-    public N getData() {\n-        return data;\n-    }\n-\n-    public void setData(N d) {\n-        data = d;\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return \"Node: \" + data;\n-    }\n-}\n","filename":"src\/utils\/IdealGraphVisualizer\/HierarchicalLayout\/src\/main\/java\/com\/sun\/hotspot\/igv\/hierarchicallayout\/Node.java","additions":0,"deletions":161,"binary":false,"changes":161,"status":"deleted"},{"patch":"@@ -34,1 +34,1 @@\n-    private String name;\n+    private final String name;\n@@ -52,1 +52,1 @@\n-        System.out.println(toString());\n+        System.out.println();\n","filename":"src\/utils\/IdealGraphVisualizer\/HierarchicalLayout\/src\/main\/java\/com\/sun\/hotspot\/igv\/hierarchicallayout\/Timing.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -36,2 +36,0 @@\n-    public Cluster getOuter();\n-\n","filename":"src\/utils\/IdealGraphVisualizer\/Layout\/src\/main\/java\/com\/sun\/hotspot\/igv\/layout\/Cluster.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-    public void doLayout(LayoutGraph graph);\n+    void doLayout(LayoutGraph graph);\n","filename":"src\/utils\/IdealGraphVisualizer\/Layout\/src\/main\/java\/com\/sun\/hotspot\/igv\/layout\/LayoutManager.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,2 +27,0 @@\n-import com.sun.hotspot.igv.data.GraphDocument;\n-import com.sun.hotspot.igv.data.serialization.BinaryParser;\n@@ -36,1 +34,0 @@\n-    private final boolean binary;\n@@ -38,1 +35,0 @@\n-    private final GraphDocument rootDocument;\n@@ -41,1 +37,1 @@\n-    public Client(SocketChannel socket, GraphDocument rootDocument, GroupCallback callback, boolean  binary) {\n+    public Client(SocketChannel socket, GroupCallback callback) {\n@@ -44,2 +40,0 @@\n-        this.binary = binary;\n-        this.rootDocument = rootDocument;\n@@ -54,7 +48,2 @@\n-            if (binary) {\n-                new BinaryParser(channel, null, rootDocument, callback).parse();\n-            } else {\n-                \/\/ signal readiness to client VM (old protocol)\n-                channel.socket().getOutputStream().write('y');\n-                new Parser(channel, null, callback).parse();\n-            }\n+            channel.socket().getOutputStream().write('y');\n+            new Parser(channel, null, callback).parse();\n","filename":"src\/utils\/IdealGraphVisualizer\/NetworkConnection\/src\/main\/java\/com\/sun\/hotspot\/igv\/connection\/Client.java","additions":3,"deletions":14,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import com.sun.hotspot.igv.data.GraphDocument;\n@@ -45,1 +44,0 @@\n-    private final boolean binary;\n@@ -47,1 +45,0 @@\n-    private final GraphDocument rootDocument;\n@@ -52,3 +49,1 @@\n-    public Server(GraphDocument rootDocument, GroupCallback callback, boolean binary) {\n-        this.binary = binary;\n-        this.rootDocument = rootDocument;\n+    public Server(GroupCallback callback) {\n@@ -62,2 +57,1 @@\n-\n-        int curPort = Integer.parseInt(Settings.get().get(binary ? Settings.PORT_BINARY : Settings.PORT, binary ? Settings.PORT_BINARY_DEFAULT : Settings.PORT_DEFAULT));\n+        int curPort = Integer.parseInt(Settings.get().get(Settings.PORT, Settings.PORT_DEFAULT));\n@@ -70,2 +64,1 @@\n-\n-        int curPort = Integer.parseInt(Settings.get().get(binary ? Settings.PORT_BINARY : Settings.PORT, binary ? Settings.PORT_BINARY_DEFAULT : Settings.PORT_DEFAULT));\n+        int curPort = Integer.parseInt(Settings.get().get(Settings.PORT, Settings.PORT_DEFAULT));\n@@ -77,1 +70,1 @@\n-            NotifyDescriptor message = new NotifyDescriptor.Message(\"Could not create server. Listening for incoming binary data is disabled.\", NotifyDescriptor.ERROR_MESSAGE);\n+            NotifyDescriptor message = new NotifyDescriptor.Message(\"Could not create server. Listening for incoming data is disabled.\", NotifyDescriptor.ERROR_MESSAGE);\n@@ -93,1 +86,1 @@\n-                        RequestProcessor.getDefault().post(new Client(clientSocket, rootDocument, callback, binary), 0, Thread.MAX_PRIORITY);\n+                        RequestProcessor.getDefault().post(new Client(clientSocket, callback), 0, Thread.MAX_PRIORITY);\n@@ -96,1 +89,1 @@\n-                        NotifyDescriptor message = new NotifyDescriptor.Message(\"Error during listening for incoming connections. Listening for incoming binary data is disabled.\", NotifyDescriptor.ERROR_MESSAGE);\n+                        NotifyDescriptor message = new NotifyDescriptor.Message(\"Error during listening for incoming connections. Listening for incoming data is disabled.\", NotifyDescriptor.ERROR_MESSAGE);\n","filename":"src\/utils\/IdealGraphVisualizer\/NetworkConnection\/src\/main\/java\/com\/sun\/hotspot\/igv\/connection\/Server.java","additions":6,"deletions":13,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -38,5 +38,5 @@\n-    private static SelectionCoordinator singleInstance = new SelectionCoordinator();\n-    private Set<Object> selectedObjects;\n-    private Set<Object> highlightedObjects;\n-    private ChangedEvent<SelectionCoordinator> selectedChangedEvent;\n-    private ChangedEvent<SelectionCoordinator> highlightedChangedEvent;\n+    private static final SelectionCoordinator singleInstance = new SelectionCoordinator();\n+    private final Set<Integer> selectedObjects;\n+    private final Set<Integer> highlightedObjects;\n+    private final ChangedEvent<SelectionCoordinator> selectedChangedEvent;\n+    private final ChangedEvent<SelectionCoordinator> highlightedChangedEvent;\n@@ -55,1 +55,1 @@\n-    public Set<Object> getSelectedObjects() {\n+    public Set<Integer> getSelectedObjects() {\n@@ -59,1 +59,1 @@\n-    public Set<Object> getHighlightedObjects() {\n+    public Set<Integer> getHighlightedObjects() {\n@@ -71,29 +71,0 @@\n-    public void addHighlighted(Object o) {\n-        if (!highlightedObjects.contains(o)) {\n-            highlightedObjects.add(o);\n-            highlightedObjectsChanged();\n-        }\n-    }\n-\n-    public void removeHighlighted(Object o) {\n-        if (highlightedObjects.contains(o)) {\n-            highlightedObjects.remove(o);\n-            highlightedObjectsChanged();\n-        }\n-    }\n-\n-    public void addAllHighlighted(Set<? extends Object> s) {\n-        int oldSize = highlightedObjects.size();\n-        highlightedObjects.addAll(s);\n-        if (oldSize != highlightedObjects.size()) {\n-            highlightedObjectsChanged();\n-        }\n-    }\n-\n-    public void removeAllHighlighted(Set<? extends Object> s) {\n-        int oldSize = highlightedObjects.size();\n-        highlightedObjects.removeAll(s);\n-        if (oldSize != highlightedObjects.size()) {\n-            highlightedObjectsChanged();\n-        }\n-    }\n@@ -101,22 +72,1 @@\n-    private void highlightedObjectsChanged() {\n-        highlightedChangedEvent.fire();\n-\n-    }\n-\n-    public void addAllSelected(Set<? extends Object> s) {\n-        int oldSize = selectedObjects.size();\n-        selectedObjects.addAll(s);\n-        if (oldSize != selectedObjects.size()) {\n-            selectedObjectsChanged();\n-        }\n-    }\n-\n-    public void removeAllSelected(Set<? extends Object> s) {\n-        int oldSize = selectedObjects.size();\n-        selectedObjects.removeAll(s);\n-        if (oldSize != selectedObjects.size()) {\n-            selectedObjectsChanged();\n-        }\n-    }\n-\n-    public void setSelectedObjects(Set<? extends Object> s) {\n+    public void setSelectedObjects(Set<Integer> s) {\n@@ -126,5 +76,1 @@\n-        selectedObjectsChanged();\n-    }\n-\n-    private void selectedObjectsChanged() {\n-        selectedChangedEvent.fire();\n+        getSelectedChangedEvent().fire();\n@@ -133,1 +79,1 @@\n-    public void setHighlightedObjects(Set<? extends Object> s) {\n+    public void setHighlightedObjects(Set<Integer> s) {\n@@ -135,3 +81,3 @@\n-        this.highlightedObjects.clear();\n-        this.highlightedObjects.addAll(s);\n-        highlightedObjectsChanged();\n+        highlightedObjects.clear();\n+        highlightedObjects.addAll(s);\n+        getHighlightedChangedEvent().fire();\n","filename":"src\/utils\/IdealGraphVisualizer\/SelectionCoordinator\/src\/main\/java\/com\/sun\/hotspot\/igv\/selectioncoordinator\/SelectionCoordinator.java","additions":13,"deletions":67,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -27,0 +27,3 @@\n+import com.ibm.wala.util.graph.Graph;\n+import com.ibm.wala.util.graph.dominators.Dominators;\n+import com.ibm.wala.util.graph.impl.SlowSparseNumberedGraph;\n@@ -36,3 +39,0 @@\n-import com.ibm.wala.util.graph.Graph;\n-import com.ibm.wala.util.graph.impl.SlowSparseNumberedGraph;\n-import com.ibm.wala.util.graph.dominators.Dominators;\n","filename":"src\/utils\/IdealGraphVisualizer\/ServerCompiler\/src\/main\/java\/com\/sun\/hotspot\/igv\/servercompiler\/ServerCompilerScheduler.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -50,1 +50,0 @@\n-    public static final String PORT_BINARY = \"portBinary\";\n@@ -52,1 +51,0 @@\n-    public static final String PORT_BINARY_DEFAULT = \"4445\";\n","filename":"src\/utils\/IdealGraphVisualizer\/Settings\/src\/main\/java\/com\/sun\/hotspot\/igv\/settings\/Settings.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,182 +0,0 @@\n-\/*\n- * Copyright (c) 2008, 2015, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-package com.sun.hotspot.igv.util;\n-\n-import java.awt.Container;\n-import java.awt.Dimension;\n-import java.awt.Point;\n-import java.awt.Rectangle;\n-import javax.swing.JComponent;\n-import javax.swing.JScrollPane;\n-import org.netbeans.api.visual.action.WidgetAction;\n-import org.netbeans.api.visual.action.WidgetAction.State;\n-import org.netbeans.api.visual.action.WidgetAction.WidgetMouseWheelEvent;\n-import org.netbeans.api.visual.animator.SceneAnimator;\n-import org.netbeans.api.visual.widget.Scene;\n-import org.netbeans.api.visual.widget.Widget;\n-\n-\/**\n- *\n- * @author Thomas Wuerthinger\n- *\/\n-public class BoundedZoomAction extends WidgetAction.Adapter {\n-\n-    private double minFactor = 0.0;\n-    private double maxFactor = Double.MAX_VALUE;\n-    private double zoomMultiplier;\n-    private boolean useAnimator;\n-\n-    public BoundedZoomAction(double zoomMultiplier, boolean useAnimator) {\n-        this.zoomMultiplier = zoomMultiplier;\n-        this.useAnimator = useAnimator;\n-    }\n-\n-    public double getMinFactor() {\n-        return minFactor;\n-    }\n-\n-    public void setMinFactor(double d) {\n-        minFactor = d;\n-    }\n-\n-    public double getMaxFactor() {\n-        return maxFactor;\n-    }\n-\n-    public void setMaxFactor(double d) {\n-        maxFactor = d;\n-    }\n-\n-    private JScrollPane findScrollPane(JComponent component) {\n-        for (;;) {\n-            if (component == null) {\n-                return null;\n-            }\n-            if (component instanceof JScrollPane) {\n-                return ((JScrollPane) component);\n-            }\n-            Container parent = component.getParent();\n-            if (!(parent instanceof JComponent)) {\n-                return null;\n-            }\n-            component = (JComponent) parent;\n-        }\n-    }\n-\n-    @Override\n-    public State mouseWheelMoved(Widget widget, WidgetMouseWheelEvent event) {\n-        final Scene scene = widget.getScene();\n-        int amount = event.getWheelRotation();\n-        JScrollPane scrollPane = findScrollPane(scene.getView());\n-        Point viewPosition = null;\n-        Point mouseLocation = scene.convertSceneToView(event.getPoint());\n-        int xOffset = 0;\n-        int yOffset = 0;\n-        Point oldViewPosition = null;\n-        Rectangle bounds = new Rectangle(scene.getBounds());\n-        Dimension componentSize = new Dimension(scene.getView().getPreferredSize());\n-\n-        if (scrollPane != null) {\n-            viewPosition = new Point(scrollPane.getViewport().getViewPosition());\n-            oldViewPosition = new Point(viewPosition);\n-            xOffset = (mouseLocation.x - viewPosition.x);\n-            yOffset = (mouseLocation.y - viewPosition.y);\n-            viewPosition.x += xOffset;\n-            viewPosition.y += yOffset;\n-        }\n-\n-        if (useAnimator) {\n-            SceneAnimator sceneAnimator = scene.getSceneAnimator();\n-            synchronized (sceneAnimator) {\n-                double zoom = sceneAnimator.isAnimatingZoomFactor() ? sceneAnimator.getTargetZoomFactor() : scene.getZoomFactor();\n-                while (amount > 0 && zoom \/ zoomMultiplier >= minFactor && zoom \/ zoomMultiplier <= maxFactor) {\n-                    zoom \/= zoomMultiplier;\n-                    if (viewPosition != null) {\n-                        viewPosition.x \/= zoomMultiplier;\n-                        viewPosition.y \/= zoomMultiplier;\n-                        bounds.width \/= zoomMultiplier;\n-                        bounds.height \/= zoomMultiplier;\n-                        componentSize.width \/= zoomMultiplier;\n-                        componentSize.height \/= zoomMultiplier;\n-                    }\n-                    amount--;\n-                }\n-                while (amount < 0 && zoom * zoomMultiplier >= minFactor && zoom * zoomMultiplier <= maxFactor) {\n-                    zoom *= zoomMultiplier;\n-                    if (viewPosition != null) {\n-                        viewPosition.x *= zoomMultiplier;\n-                        viewPosition.y *= zoomMultiplier;\n-                        bounds.width *= zoomMultiplier;\n-                        bounds.height *= zoomMultiplier;\n-                        componentSize.width *= zoomMultiplier;\n-                        componentSize.height *= zoomMultiplier;\n-                    }\n-                    amount++;\n-                }\n-                sceneAnimator.animateZoomFactor(zoom);\n-            }\n-        } else {\n-            double zoom = scene.getZoomFactor();\n-            while (amount > 0 && zoom \/ zoomMultiplier >= minFactor && zoom \/ zoomMultiplier <= maxFactor) {\n-                zoom \/= zoomMultiplier;\n-                if (viewPosition != null) {\n-                    viewPosition.x \/= zoomMultiplier;\n-                    viewPosition.y \/= zoomMultiplier;\n-                    bounds.width \/= zoomMultiplier;\n-                    bounds.height \/= zoomMultiplier;\n-                    componentSize.width \/= zoomMultiplier;\n-                    componentSize.height \/= zoomMultiplier;\n-                }\n-                amount--;\n-            }\n-            while (amount < 0 && zoom * zoomMultiplier >= minFactor && zoom * zoomMultiplier <= maxFactor) {\n-                zoom *= zoomMultiplier;\n-                if (viewPosition != null) {\n-                    viewPosition.x *= zoomMultiplier;\n-                    viewPosition.y *= zoomMultiplier;\n-                    bounds.width *= zoomMultiplier;\n-                    bounds.height *= zoomMultiplier;\n-                    componentSize.width *= zoomMultiplier;\n-                    componentSize.height *= zoomMultiplier;\n-                }\n-                amount++;\n-            }\n-            scene.setZoomFactor(zoom);\n-        }\n-\n-        if (scrollPane != null) {\n-            scene.validate(); \/\/ Call validate to update size of scene\n-            Dimension size = scrollPane.getViewport().getExtentSize();\n-            viewPosition.x -= xOffset;\n-            viewPosition.y -= yOffset;\n-            scene.resolveBounds(scene.getLocation(), bounds);\n-            scene.getView().setPreferredSize(componentSize);\n-            scene.getView().revalidate();\n-            scene.getView().addNotify();\n-            scrollPane.getViewport().setViewPosition(viewPosition);\n-        }\n-\n-        return WidgetAction.State.CONSUMED;\n-    }\n-}\n","filename":"src\/utils\/IdealGraphVisualizer\/Util\/src\/main\/java\/com\/sun\/hotspot\/igv\/util\/BoundedZoomAction.java","additions":0,"deletions":182,"binary":false,"changes":182,"status":"deleted"},{"patch":"@@ -37,1 +37,0 @@\n-    private Lookup context = null;\n@@ -49,1 +48,0 @@\n-        this.context = context;\n","filename":"src\/utils\/IdealGraphVisualizer\/Util\/src\/main\/java\/com\/sun\/hotspot\/igv\/util\/ContextAction.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-    private DoubleClickHandler handler;\n+    private final DoubleClickHandler handler;\n","filename":"src\/utils\/IdealGraphVisualizer\/Util\/src\/main\/java\/com\/sun\/hotspot\/igv\/util\/DoubleClickAction.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-    public void handleDoubleClick(Widget w, WidgetMouseEvent e);\n+    void handleDoubleClick(Widget w, WidgetMouseEvent e);\n","filename":"src\/utils\/IdealGraphVisualizer\/Util\/src\/main\/java\/com\/sun\/hotspot\/igv\/util\/DoubleClickHandler.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,208 +0,0 @@\n-\/*\n- * Copyright (c) 2008, 2015, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-package com.sun.hotspot.igv.util;\n-\n-import java.awt.*;\n-import java.awt.event.*;\n-import javax.swing.JComponent;\n-import org.netbeans.api.visual.widget.Scene;\n-\n-\/**\n- * @author David Kaspar\n- * @author Thomas Wuerthinger\n- *\/\n-public class ExtendedSatelliteComponent extends JComponent implements MouseListener, MouseMotionListener, Scene.SceneListener, ComponentListener {\n-\n-    private Scene scene;\n-    private Image image;\n-    private int imageWidth;\n-    private int imageHeight;\n-\n-    public ExtendedSatelliteComponent(Scene scene) {\n-        this.scene = scene;\n-        setDoubleBuffered(true);\n-        setPreferredSize(new Dimension(128, 128));\n-        addMouseListener(this);\n-        addMouseMotionListener(this);\n-    }\n-\n-    @Override\n-    public void addNotify() {\n-        super.addNotify();\n-        scene.addSceneListener(this);\n-        JComponent viewComponent = scene.getView();\n-        if (viewComponent == null) {\n-            viewComponent = scene.createView();\n-        }\n-        viewComponent.addComponentListener(this);\n-        repaint();\n-    }\n-\n-    @Override\n-    public void removeNotify() {\n-        scene.getView().removeComponentListener(this);\n-        scene.removeSceneListener(this);\n-        super.removeNotify();\n-    }\n-\n-    public void update() {\n-        this.image = null;\n-        repaint();\n-    }\n-\n-    @Override\n-    public void paint(Graphics g) {\n-        Graphics2D gr = (Graphics2D) g;\n-        super.paint(g);\n-        Rectangle bounds = scene.getBounds();\n-        Dimension size = getSize();\n-\n-        double sx = bounds.width > 0 ? (double) size.width \/ bounds.width : 0.0;\n-        double sy = bounds.width > 0 ? (double) size.height \/ bounds.height : 0.0;\n-        double scale = Math.min(sx, sy);\n-\n-        int vw = (int) (scale * bounds.width);\n-        int vh = (int) (scale * bounds.height);\n-        int vx = (size.width - vw) \/ 2;\n-        int vy = (size.height - vh) \/ 2;\n-\n-\n-        if (image == null || vw != imageWidth || vh != imageHeight) {\n-\n-            imageWidth = vw;\n-            imageHeight = vh;\n-            image = this.createImage(imageWidth, imageHeight);\n-            Graphics2D ig = (Graphics2D) image.getGraphics();\n-            ig.scale(scale, scale);\n-            scene.paint(ig);\n-        }\n-\n-        gr.drawImage(image, vx, vy, this);\n-\n-        JComponent component = scene.getView();\n-        double zoomFactor = scene.getZoomFactor();\n-        Rectangle viewRectangle = component != null ? component.getVisibleRect() : null;\n-        if (viewRectangle != null) {\n-            Rectangle window = new Rectangle(\n-                    (int) ((double) viewRectangle.x * scale \/ zoomFactor),\n-                    (int) ((double) viewRectangle.y * scale \/ zoomFactor),\n-                    (int) ((double) viewRectangle.width * scale \/ zoomFactor),\n-                    (int) ((double) viewRectangle.height * scale \/ zoomFactor));\n-            window.translate(vx, vy);\n-            gr.setColor(new Color(200, 200, 200, 128));\n-            gr.fill(window);\n-            gr.setColor(Color.BLACK);\n-            gr.drawRect(window.x, window.y, window.width - 1, window.height - 1);\n-        }\n-    }\n-\n-    @Override\n-    public void mouseClicked(MouseEvent e) {\n-    }\n-\n-    @Override\n-    public void mousePressed(MouseEvent e) {\n-        moveVisibleRect(e.getPoint());\n-    }\n-\n-    @Override\n-    public void mouseReleased(MouseEvent e) {\n-        moveVisibleRect(e.getPoint());\n-    }\n-\n-    @Override\n-    public void mouseEntered(MouseEvent e) {\n-    }\n-\n-    @Override\n-    public void mouseExited(MouseEvent e) {\n-    }\n-\n-    @Override\n-    public void mouseDragged(MouseEvent e) {\n-        moveVisibleRect(e.getPoint());\n-    }\n-\n-    @Override\n-    public void mouseMoved(MouseEvent e) {\n-    }\n-\n-    private void moveVisibleRect(Point center) {\n-        JComponent component = scene.getView();\n-        if (component == null) {\n-            return;\n-        }\n-        double zoomFactor = scene.getZoomFactor();\n-        Rectangle bounds = scene.getBounds();\n-        Dimension size = getSize();\n-\n-        double sx = bounds.width > 0 ? (double) size.width \/ bounds.width : 0.0;\n-        double sy = bounds.width > 0 ? (double) size.height \/ bounds.height : 0.0;\n-        double scale = Math.min(sx, sy);\n-\n-        int vw = (int) (scale * bounds.width);\n-        int vh = (int) (scale * bounds.height);\n-        int vx = (size.width - vw) \/ 2;\n-        int vy = (size.height - vh) \/ 2;\n-\n-        int cx = (int) ((double) (center.x - vx) \/ scale * zoomFactor);\n-        int cy = (int) ((double) (center.y - vy) \/ scale * zoomFactor);\n-\n-        Rectangle visibleRect = component.getVisibleRect();\n-        visibleRect.x = cx - visibleRect.width \/ 2;\n-        visibleRect.y = cy - visibleRect.height \/ 2;\n-        component.scrollRectToVisible(visibleRect);\n-\n-    }\n-\n-    @Override\n-    public void sceneRepaint() {\n-    }\n-\n-    @Override\n-    public void sceneValidating() {\n-    }\n-\n-    @Override\n-    public void sceneValidated() {\n-    }\n-\n-    @Override\n-    public void componentResized(ComponentEvent e) {\n-        repaint();\n-    }\n-\n-    @Override\n-    public void componentMoved(ComponentEvent e) {\n-        repaint();\n-    }\n-\n-    @Override\n-    public void componentShown(ComponentEvent e) {\n-    }\n-\n-    @Override\n-    public void componentHidden(ComponentEvent e) {\n-    }\n-}\n","filename":"src\/utils\/IdealGraphVisualizer\/Util\/src\/main\/java\/com\/sun\/hotspot\/igv\/util\/ExtendedSatelliteComponent.java","additions":0,"deletions":208,"binary":false,"changes":208,"status":"deleted"},{"patch":"@@ -43,2 +43,1 @@\n-        private Class<T> klass;\n-        private Result<T> result;\n+        private final Class<T> klass;\n@@ -49,1 +48,1 @@\n-            result = Utilities.actionsGlobalContext().lookupResult(klass);\n+            Result<T> result = Utilities.actionsGlobalContext().lookupResult(klass);\n","filename":"src\/utils\/IdealGraphVisualizer\/Util\/src\/main\/java\/com\/sun\/hotspot\/igv\/util\/LookupHistory.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import com.sun.hotspot.igv.util.StringUtils;\n","filename":"src\/utils\/IdealGraphVisualizer\/Util\/src\/main\/java\/com\/sun\/hotspot\/igv\/util\/PropertiesConverter.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import java.lang.reflect.InvocationTargetException;\n@@ -52,1 +51,1 @@\n-                public String getValue() throws IllegalAccessException, InvocationTargetException {\n+                public String getValue() {\n@@ -62,1 +61,1 @@\n-                public void setValue(String arg0) throws IllegalAccessException, IllegalArgumentException, InvocationTargetException {\n+                public void setValue(String arg0) throws IllegalArgumentException {\n","filename":"src\/utils\/IdealGraphVisualizer\/Util\/src\/main\/java\/com\/sun\/hotspot\/igv\/util\/PropertiesSheet.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import java.awt.geom.*;\n@@ -33,0 +32,2 @@\n+import java.awt.geom.Ellipse2D;\n+import java.awt.geom.Rectangle2D;\n@@ -34,1 +35,4 @@\n-import javax.swing.*;\n+import javax.swing.JComponent;\n+import javax.swing.JViewport;\n+import javax.swing.Scrollable;\n+import javax.swing.SwingConstants;\n@@ -55,1 +59,1 @@\n-    private RangeSliderModel model;\n+    private final RangeSliderModel model;\n@@ -58,1 +62,4 @@\n-    private RangeSliderModel tempModel;\n+    private boolean tempModel = false;\n+    private int tempFirstPos;\n+    private int tempSecondPos;\n+\n@@ -69,1 +76,1 @@\n-    public RangeSlider() {\n+    public RangeSlider(RangeSliderModel newModel) {\n@@ -73,7 +80,0 @@\n-    }\n-\n-    public void setModel(RangeSliderModel newModel) {\n-        if (model != null) {\n-            model.getChangedEvent().removeListener(this);\n-            model.getColorChangedEvent().removeListener(this);\n-        }\n@@ -88,3 +88,3 @@\n-    private RangeSliderModel getPaintingModel() {\n-        if (tempModel != null) {\n-            return tempModel;\n+    private int getFirstPos() {\n+        if (tempModel) {\n+            return tempFirstPos;\n@@ -92,1 +92,8 @@\n-        return model;\n+        return model.getFirstPosition();\n+    }\n+\n+    private int getSecondPos() {\n+        if (tempModel) {\n+            return tempSecondPos;\n+        }\n+        return model.getSecondPosition();\n@@ -136,1 +143,1 @@\n-        d.width = Math.max(d.width, (int)(2 * BAR_CIRCLE_CONNECTOR_SIZE + getPaintingModel().getPositions().size() * (BAR_CIRCLE_SIZE + BAR_CIRCLE_CONNECTOR_SIZE)));\n+        d.width = Math.max(d.width, (int)(2 * BAR_CIRCLE_CONNECTOR_SIZE + model.getPositions().size() * (BAR_CIRCLE_SIZE + BAR_CIRCLE_CONNECTOR_SIZE)));\n@@ -143,1 +150,0 @@\n-\n@@ -158,1 +164,1 @@\n-        assert index >= 0 && index < getPaintingModel().getPositions().size();\n+        assert index >= 0 && index < model.getPositions().size();\n@@ -163,1 +169,1 @@\n-        int size = getPaintingModel().getPositions().size();\n+        int size = model.getPositions().size();\n@@ -189,1 +195,1 @@\n-        if (getPaintingModel() == null || getPaintingModel().getPositions().size() == 0) {\n+        if (model == null || model.getPositions().size() == 0) {\n@@ -193,2 +199,2 @@\n-        int firstPos = getPaintingModel().getFirstPosition();\n-        int secondPos = getPaintingModel().getSecondPosition();\n+        int firstPos = getFirstPos();\n+        int secondPos = getSecondPos();\n@@ -202,1 +208,1 @@\n-        return getHeight() \/ 2 - BAR_HEIGHT \/ 2;\n+        return getHeight() \/ 2.0f - BAR_HEIGHT \/ 2.0f;\n@@ -206,1 +212,1 @@\n-        List<String> list = getPaintingModel().getPositions();\n+        List<String> list = model.getPositions();\n@@ -215,1 +221,1 @@\n-            g.setColor(getPaintingModel().getColors().get(i));\n+            g.setColor(model.getColors().get(i));\n@@ -229,1 +235,1 @@\n-                    g.drawString(curS, startX + (endX - startX) \/ 2 - bounds.width \/ 2, barStartY \/ 2 + bounds.height \/ 2);\n+                    g.drawString(curS, (startX + (endX - startX) \/ 2.0f - bounds.width \/ 2.0f), barStartY \/ 2.0f + bounds.height \/ 2.0f);\n@@ -261,1 +267,1 @@\n-            float destX = getEndXPosition(getPaintingModel().getSecondPosition());\n+            float destX = getEndXPosition(getSecondPos());\n@@ -270,1 +276,1 @@\n-            float destX = getStartXPosition(getPaintingModel().getFirstPosition());\n+            float destX = getStartXPosition(getFirstPos());\n@@ -279,1 +285,1 @@\n-            return p.x > getStartXPosition(getPaintingModel().getFirstPosition()) && p.x < getEndXPosition(getPaintingModel().getSecondPosition());\n+            return p.x > getStartXPosition(getFirstPos()) && p.x < getEndXPosition(getSecondPos());\n@@ -292,3 +298,3 @@\n-            int newIndex = getIndexFromPosition(newFirstX) + 1;\n-            if (newIndex + model.getSecondPosition() - model.getFirstPosition() >= model.getPositions().size()) {\n-                newIndex = model.getPositions().size() - (model.getSecondPosition() - model.getFirstPosition()) - 1;\n+            tempFirstPos = getIndexFromPosition(newFirstX) + 1;\n+            if (tempFirstPos + model.getSecondPosition() - model.getFirstPosition() >= model.getPositions().size()) {\n+                tempFirstPos = model.getPositions().size() - (model.getSecondPosition() - model.getFirstPosition()) - 1;\n@@ -296,2 +302,1 @@\n-            int secondPosition = newIndex + model.getSecondPosition() - model.getFirstPosition();\n-            tempModel.setPositions(newIndex, secondPosition);\n+            tempSecondPos = tempFirstPos + model.getSecondPosition() - model.getFirstPosition();\n@@ -300,4 +305,4 @@\n-            int firstPosition = getIndexFromPosition(e.getPoint().x) + 1;\n-            int secondPosition = model.getSecondPosition();\n-            if (firstPosition > secondPosition) {\n-                firstPosition--;\n+            tempFirstPos = getIndexFromPosition(e.getPoint().x) + 1;\n+            tempSecondPos = model.getSecondPosition();\n+            if (tempFirstPos > tempSecondPos) {\n+                tempFirstPos--;\n@@ -305,1 +310,0 @@\n-            tempModel.setPositions(firstPosition, secondPosition);\n@@ -308,4 +312,4 @@\n-            int firstPosition = model.getFirstPosition();\n-            int secondPosition = getIndexFromPosition(e.getPoint().x);\n-            if (secondPosition < firstPosition) {\n-                secondPosition++;\n+            tempFirstPos = model.getFirstPosition();\n+            tempSecondPos = getIndexFromPosition(e.getPoint().x);\n+            if (tempSecondPos < tempFirstPos) {\n+                tempSecondPos++;\n@@ -313,1 +317,0 @@\n-            tempModel.setPositions(firstPosition, secondPosition);\n@@ -322,1 +325,1 @@\n-        for (int i = 0; i < getPaintingModel().getPositions().size() - 1; i++) {\n+        for (int i = 0; i < model.getPositions().size() - 1; i++) {\n@@ -329,1 +332,1 @@\n-        return getPaintingModel().getPositions().size() - 1;\n+        return model.getPositions().size() - 1;\n@@ -334,1 +337,1 @@\n-        for (int i = 1; i < getPaintingModel().getPositions().size(); i++) {\n+        for (int i = 1; i < model.getPositions().size(); i++) {\n@@ -348,2 +351,0 @@\n-\n-\n@@ -389,1 +390,1 @@\n-        tempModel = model.copy();\n+        tempModel = true;\n@@ -394,1 +395,1 @@\n-        if (model == null || tempModel == null) {\n+        if (model == null || !tempModel) {\n@@ -398,2 +399,2 @@\n-        model.setPositions(tempModel.getFirstPosition(), tempModel.getSecondPosition());\n-        tempModel = null;\n+        model.setPositions(tempFirstPos, tempSecondPos);\n+        tempModel = false;\n@@ -403,2 +404,1 @@\n-    public void mouseEntered(MouseEvent e) {\n-    }\n+    public void mouseEntered(MouseEvent e) { }\n","filename":"src\/utils\/IdealGraphVisualizer\/Util\/src\/main\/java\/com\/sun\/hotspot\/igv\/util\/RangeSlider.java","additions":56,"deletions":56,"binary":false,"changes":112,"status":"modified"},{"patch":"@@ -41,2 +41,2 @@\n-    private ChangedEvent<RangeSliderModel> changedEvent;\n-    private ChangedEvent<RangeSliderModel> colorChangedEvent;\n+    private final ChangedEvent<RangeSliderModel> changedEvent;\n+    private final ChangedEvent<RangeSliderModel> colorChangedEvent;\n@@ -49,2 +49,1 @@\n-        boolean changed = false;\n-        changed |= (positions != model.positions);\n+        boolean changed = (positions != model.positions);\n","filename":"src\/utils\/IdealGraphVisualizer\/Util\/src\/main\/java\/com\/sun\/hotspot\/igv\/util\/RangeSliderModel.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -120,1 +120,1 @@\n-     *\n+     * <p>\n","filename":"src\/utils\/IdealGraphVisualizer\/Util\/src\/main\/java\/com\/sun\/hotspot\/igv\/util\/StringUtils.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-import com.sun.hotspot.igv.data.InputGraph;\n@@ -28,0 +27,1 @@\n+import com.sun.hotspot.igv.data.InputGraph;\n@@ -32,1 +32,0 @@\n-import java.util.List;\n@@ -34,0 +33,1 @@\n+import java.util.List;\n@@ -93,1 +93,1 @@\n-                                comp.getDiagramModel().selectGraph(theGraph);\n+                                comp.getModel().selectGraph(theGraph);\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/BlockQuickSearch.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1,175 +0,0 @@\n-\/*\n- * Copyright (c) 2008, 2015, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-package com.sun.hotspot.igv.view;\n-\n-import java.awt.Container;\n-import java.awt.Dimension;\n-import java.awt.Point;\n-import java.awt.Rectangle;\n-import javax.swing.JComponent;\n-import javax.swing.JScrollPane;\n-import org.netbeans.api.visual.action.WidgetAction;\n-import org.netbeans.api.visual.action.WidgetAction.State;\n-import org.netbeans.api.visual.action.WidgetAction.WidgetMouseWheelEvent;\n-import org.netbeans.api.visual.animator.SceneAnimator;\n-import org.netbeans.api.visual.widget.Scene;\n-import org.netbeans.api.visual.widget.Widget;\n-\n-\/**\n- *\n- * @author Thomas Wuerthinger\n- *\/\n-public class BoundedZoomAction extends WidgetAction.Adapter {\n-\n-    private double minFactor = 0.0;\n-    private double maxFactor = Double.MAX_VALUE;\n-    private double zoomMultiplier;\n-    private boolean useAnimator;\n-\n-    public BoundedZoomAction(double zoomMultiplier, boolean useAnimator) {\n-        assert zoomMultiplier > 1.0;\n-        this.zoomMultiplier = zoomMultiplier;\n-        this.useAnimator = useAnimator;\n-    }\n-\n-    public double getMinFactor() {\n-        return minFactor;\n-    }\n-\n-    public void setMinFactor(double d) {\n-        minFactor = d;\n-    }\n-\n-    public double getMaxFactor() {\n-        return maxFactor;\n-    }\n-\n-    public void setMaxFactor(double d) {\n-        maxFactor = d;\n-    }\n-\n-    private JScrollPane findScrollPane(JComponent component) {\n-        for (;;) {\n-            if (component == null) {\n-                return null;\n-            }\n-            if (component instanceof JScrollPane) {\n-                return ((JScrollPane) component);\n-            }\n-            Container parent = component.getParent();\n-            if (!(parent instanceof JComponent)) {\n-                return null;\n-            }\n-            component = (JComponent) parent;\n-        }\n-    }\n-\n-    @Override\n-    public State mouseWheelMoved(Widget widget, WidgetMouseWheelEvent event) {\n-        final Scene scene = widget.getScene();\n-        int amount = event.getWheelRotation();\n-        JScrollPane scrollPane = findScrollPane(scene.getView());\n-        Point viewPosition = null;\n-        Point mouseLocation = scene.convertSceneToView(event.getPoint());\n-        int xOffset = 0;\n-        int yOffset = 0;\n-        Rectangle bounds = new Rectangle(scene.getBounds());\n-        Dimension componentSize = new Dimension(scene.getView().getPreferredSize());\n-        if (scrollPane != null) {\n-            viewPosition = new Point(scrollPane.getViewport().getViewPosition());\n-            xOffset = (mouseLocation.x - viewPosition.x);\n-            yOffset = (mouseLocation.y - viewPosition.y);\n-            viewPosition.x += xOffset;\n-            viewPosition.y += yOffset;\n-        }\n-\n-        if (useAnimator) {\n-            SceneAnimator sceneAnimator = scene.getSceneAnimator();\n-            synchronized (sceneAnimator) {\n-                double zoom = sceneAnimator.isAnimatingZoomFactor() ? sceneAnimator.getTargetZoomFactor() : scene.getZoomFactor();\n-                while (amount > 0 && zoom \/ zoomMultiplier >= minFactor) {\n-                    zoom \/= zoomMultiplier;\n-                    if (viewPosition != null) {\n-                        viewPosition.x \/= zoomMultiplier;\n-                        viewPosition.y \/= zoomMultiplier;\n-                        bounds.width \/= zoomMultiplier;\n-                        bounds.height \/= zoomMultiplier;\n-                        componentSize.width \/= zoomMultiplier;\n-                        componentSize.height \/= zoomMultiplier;\n-                    }\n-                    amount--;\n-                }\n-                while (amount < 0 && zoom * zoomMultiplier <= maxFactor) {\n-                    zoom *= zoomMultiplier;\n-                    if (viewPosition != null) {\n-                        viewPosition.x *= zoomMultiplier;\n-                        viewPosition.y *= zoomMultiplier;\n-                        bounds.width *= zoomMultiplier;\n-                        bounds.height *= zoomMultiplier;\n-                        componentSize.width *= zoomMultiplier;\n-                        componentSize.height *= zoomMultiplier;\n-                    }\n-                    amount++;\n-                }\n-                sceneAnimator.animateZoomFactor(zoom);\n-            }\n-        } else {\n-            double zoom = scene.getZoomFactor();\n-            while (amount > 0 && zoom \/ zoomMultiplier >= minFactor) {\n-                zoom \/= zoomMultiplier;\n-                if (viewPosition != null) {\n-                    viewPosition.x \/= zoomMultiplier;\n-                    viewPosition.y \/= zoomMultiplier;\n-                    bounds.width \/= zoomMultiplier;\n-                    bounds.height \/= zoomMultiplier;\n-                    componentSize.width \/= zoomMultiplier;\n-                    componentSize.height \/= zoomMultiplier;\n-                }\n-                amount--;\n-            }\n-            while (amount < 0 && zoom * zoomMultiplier <= maxFactor) {\n-                zoom *= zoomMultiplier;\n-                if (viewPosition != null) {\n-                    viewPosition.x *= zoomMultiplier;\n-                    viewPosition.y *= zoomMultiplier;\n-                    bounds.width *= zoomMultiplier;\n-                    bounds.height *= zoomMultiplier;\n-                    componentSize.width *= zoomMultiplier;\n-                    componentSize.height *= zoomMultiplier;\n-                }\n-                amount++;\n-            }\n-            scene.setZoomFactor(zoom);\n-        }\n-\n-        if (scrollPane != null) {\n-            viewPosition.x -= xOffset;\n-            viewPosition.y -= yOffset;\n-            scrollPane.getViewport().setViewPosition(viewPosition);\n-        }\n-\n-\n-        return WidgetAction.State.CONSUMED;\n-    }\n-}\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/BoundedZoomAction.java","additions":0,"deletions":175,"binary":false,"changes":175,"status":"deleted"},{"patch":"@@ -26,5 +26,0 @@\n-import com.sun.hotspot.igv.data.ChangedListener;\n-import com.sun.hotspot.igv.data.ControllableChangedListener;\n-import com.sun.hotspot.igv.data.InputBlock;\n-import com.sun.hotspot.igv.data.InputNode;\n-import com.sun.hotspot.igv.data.Pair;\n@@ -32,1 +27,1 @@\n-import com.sun.hotspot.igv.data.services.Scheduler;\n+import com.sun.hotspot.igv.data.*;\n@@ -34,1 +29,0 @@\n-import com.sun.hotspot.igv.hierarchicallayout.HierarchicalClusterLayoutManager;\n@@ -36,1 +30,1 @@\n-import com.sun.hotspot.igv.hierarchicallayout.LinearLayoutManager;\n+import com.sun.hotspot.igv.hierarchicallayout.HierarchicalClusterLayoutManager;\n@@ -38,0 +32,1 @@\n+import com.sun.hotspot.igv.hierarchicallayout.LinearLayoutManager;\n@@ -39,1 +34,0 @@\n-import com.sun.hotspot.igv.layout.Link;\n@@ -46,1 +40,0 @@\n-import com.sun.hotspot.igv.view.EditorTopComponent;\n@@ -49,1 +42,3 @@\n-import java.awt.event.*;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.KeyEvent;\n+import java.awt.event.MouseEvent;\n@@ -68,0 +63,1 @@\n+import org.openide.util.Utilities;\n@@ -70,1 +66,0 @@\n-import org.openide.util.Utilities;\n@@ -78,9 +73,9 @@\n-    private CustomizablePanAction panAction;\n-    private WidgetAction hoverAction;\n-    private WidgetAction selectAction;\n-    private Lookup lookup;\n-    private InstanceContent content;\n-    private Action[] actions;\n-    private Action[] actionsWithSelection;\n-    private LayerWidget connectionLayer;\n-    private JScrollPane scrollPane;\n+    private final CustomizablePanAction panAction;\n+    private final WidgetAction hoverAction;\n+    private final WidgetAction selectAction;\n+    private final Lookup lookup;\n+    private final InstanceContent content;\n+    private final Action[] actions;\n+    private final Action[] actionsWithSelection;\n+    private final LayerWidget connectionLayer;\n+    private final JScrollPane scrollPane;\n@@ -88,2 +83,2 @@\n-    private LayerWidget mainLayer;\n-    private LayerWidget blockLayer;\n+    private final LayerWidget mainLayer;\n+    private final LayerWidget blockLayer;\n@@ -116,19 +111,0 @@\n-    private PopupMenuProvider popupMenuProvider = new PopupMenuProvider() {\n-\n-        @Override\n-        public JPopupMenu getPopupMenu(Widget widget, Point localLocation) {\n-            return DiagramScene.this.createPopupMenu();\n-        }\n-    };\n-\n-    private RectangularSelectDecorator rectangularSelectDecorator = new RectangularSelectDecorator() {\n-\n-        @Override\n-        public Widget createSelectionWidget() {\n-            Widget widget = new Widget(DiagramScene.this);\n-            widget.setBorder(BorderFactory.createLineBorder(Color.black, 2));\n-            widget.setForeground(Color.red);\n-            return widget;\n-        }\n-    };\n-\n@@ -147,9 +123,0 @@\n-    private static boolean intersects(Set<? extends Object> s1, Set<? extends Object> s2) {\n-        for (Object o : s1) {\n-            if (s2.contains(o)) {\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n-\n@@ -167,1 +134,0 @@\n-\n@@ -187,1 +153,0 @@\n-\n@@ -194,16 +159,1 @@\n-    private Set<Object> getObjectsFromIdSet(Set<Object> set) {\n-        Set<Object> selectedObjects = new HashSet<>();\n-        for (Figure f : getModel().getDiagramToView().getFigures()) {\n-            if (intersects(f.getSource().getSourceNodesAsSet(), set)) {\n-                selectedObjects.add(f);\n-            }\n-\n-            for (Slot s : f.getSlots()) {\n-                if (intersects(s.getSource().getSourceNodesAsSet(), set)) {\n-                    selectedObjects.add(s);\n-                }\n-            }\n-        }\n-        return selectedObjects;\n-    }\n-    private ControllableChangedListener<SelectionCoordinator> highlightedCoordinatorListener = new ControllableChangedListener<SelectionCoordinator>() {\n+    private final ControllableChangedListener<SelectionCoordinator> highlightedCoordinatorListener = new ControllableChangedListener<SelectionCoordinator>() {\n@@ -213,1 +163,1 @@\n-            DiagramScene.this.setHighlightedObjects(getObjectsFromIdSet(source.getHighlightedObjects()));\n+            DiagramScene.this.setHighlightedObjects(idSetToObjectSet(source.getHighlightedObjects()));\n@@ -217,1 +167,1 @@\n-    private ControllableChangedListener<SelectionCoordinator> selectedCoordinatorListener = new ControllableChangedListener<SelectionCoordinator>() {\n+    private final ControllableChangedListener<SelectionCoordinator> selectedCoordinatorListener = new ControllableChangedListener<SelectionCoordinator>() {\n@@ -226,44 +176,1 @@\n-    private RectangularSelectProvider rectangularSelectProvider = new RectangularSelectProvider() {\n-\n-        @Override\n-        public void performSelection(Rectangle rectangle) {\n-            if (rectangle.width < 0) {\n-                rectangle.x += rectangle.width;\n-                rectangle.width *= -1;\n-            }\n-\n-            if (rectangle.height < 0) {\n-                rectangle.y += rectangle.height;\n-                rectangle.height *= -1;\n-            }\n-\n-            Set<Object> selectedObjects = new HashSet<>();\n-            for (Figure f : getModel().getDiagramToView().getFigures()) {\n-                FigureWidget w = getWidget(f);\n-                if (w != null) {\n-                    Rectangle r = new Rectangle(w.getBounds());\n-                    r.setLocation(w.getLocation());\n-\n-                    if (r.intersects(rectangle)) {\n-                        selectedObjects.add(f);\n-                    }\n-\n-                    for (Slot s : f.getSlots()) {\n-                        SlotWidget sw = getWidget(s);\n-                        Rectangle r2 = new Rectangle(sw.getBounds());\n-                        r2.setLocation(sw.convertLocalToScene(new Point(0, 0)));\n-\n-                        if (r2.intersects(rectangle)) {\n-                            selectedObjects.add(s);\n-                        }\n-                    }\n-                } else {\n-                    assert false : \"w should not be null here!\";\n-                }\n-            }\n-\n-            setSelectedObjects(selectedObjects);\n-        }\n-    };\n-\n-    public Point getScrollPosition() {\n+    private Point getScrollPosition() {\n@@ -273,1 +180,1 @@\n-    public void setScrollPosition(Point p) {\n+    private void setScrollPosition(Point p) {\n@@ -292,88 +199,0 @@\n-    private ObjectSceneListener selectionChangedListener = new ObjectSceneListener() {\n-\n-        @Override\n-        public void objectAdded(ObjectSceneEvent arg0, Object arg1) {\n-        }\n-\n-        @Override\n-        public void objectRemoved(ObjectSceneEvent arg0, Object arg1) {\n-        }\n-\n-        @Override\n-        public void objectStateChanged(ObjectSceneEvent e, Object o, ObjectState oldState, ObjectState newState) {\n-        }\n-\n-        @Override\n-        public void selectionChanged(ObjectSceneEvent e, Set<Object> oldSet, Set<Object> newSet) {\n-            DiagramScene scene = (DiagramScene) e.getObjectScene();\n-            if (scene.isRebuilding()) {\n-                return;\n-            }\n-\n-            content.set(newSet, null);\n-\n-            Set<Integer> nodeSelection = new HashSet<>();\n-            for (Object o : newSet) {\n-                if (o instanceof Properties.Provider) {\n-                    final Properties.Provider provider = (Properties.Provider) o;\n-                    AbstractNode node = new AbstractNode(Children.LEAF) {\n-\n-                        @Override\n-                        protected Sheet createSheet() {\n-                            Sheet s = super.createSheet();\n-                            PropertiesSheet.initializeSheet(provider.getProperties(), s);\n-                            return s;\n-                        }\n-                    };\n-                    node.setDisplayName(provider.getProperties().get(\"name\"));\n-                    content.add(node);\n-                }\n-\n-\n-                if (o instanceof Figure) {\n-                    nodeSelection.addAll(((Figure) o).getSource().getSourceNodesAsSet());\n-                } else if (o instanceof Slot) {\n-                    nodeSelection.addAll(((Slot) o).getSource().getSourceNodesAsSet());\n-                }\n-            }\n-            getModel().setSelectedNodes(nodeSelection);\n-\n-            boolean b = selectedCoordinatorListener.isEnabled();\n-            selectedCoordinatorListener.setEnabled(false);\n-            SelectionCoordinator.getInstance().setSelectedObjects(nodeSelection);\n-            selectedCoordinatorListener.setEnabled(b);\n-\n-        }\n-\n-        @Override\n-        public void highlightingChanged(ObjectSceneEvent e, Set<Object> oldSet, Set<Object> newSet) {\n-            Set<Integer> nodeHighlighting = new HashSet<>();\n-            for (Object o : newSet) {\n-                if (o instanceof Figure) {\n-                    nodeHighlighting.addAll(((Figure) o).getSource().getSourceNodesAsSet());\n-                } else if (o instanceof Slot) {\n-                    nodeHighlighting.addAll(((Slot) o).getSource().getSourceNodesAsSet());\n-                }\n-            }\n-            boolean b = highlightedCoordinatorListener.isEnabled();\n-            highlightedCoordinatorListener.setEnabled(false);\n-            SelectionCoordinator.getInstance().setHighlightedObjects(nodeHighlighting);\n-            highlightedCoordinatorListener.setEnabled(true);\n-        }\n-\n-        @Override\n-        public void hoverChanged(ObjectSceneEvent e, Object oldObject, Object newObject) {\n-            Set<Object> newHighlightedObjects = new HashSet<>(DiagramScene.this.getHighlightedObjects());\n-            if (oldObject != null) {\n-                newHighlightedObjects.remove(oldObject);\n-            }\n-            if (newObject != null) {\n-                newHighlightedObjects.add(newObject);\n-            }\n-            DiagramScene.this.setHighlightedObjects(newHighlightedObjects);\n-        }\n-\n-        @Override\n-        public void focusChanged(ObjectSceneEvent arg0, Object arg1, Object arg2) {\n-        }\n-    };\n@@ -448,1 +267,1 @@\n-        this.getInputBindings().setZoomActionModifiers(Utilities.isMac() ? KeyEvent.META_MASK : KeyEvent.CTRL_MASK);\n+        this.getInputBindings().setZoomActionModifiers(Utilities.isMac() ? KeyEvent.META_DOWN_MASK : KeyEvent.CTRL_DOWN_MASK);\n@@ -450,0 +269,1 @@\n+        PopupMenuProvider popupMenuProvider = (widget, localLocation) -> DiagramScene.this.createPopupMenu();\n@@ -455,0 +275,46 @@\n+        RectangularSelectDecorator rectangularSelectDecorator = () -> {\n+            Widget widget = new Widget(DiagramScene.this);\n+            widget.setBorder(BorderFactory.createLineBorder(Color.black, 2));\n+            widget.setForeground(Color.red);\n+            return widget;\n+        };\n+        RectangularSelectProvider rectangularSelectProvider = rectangle -> {\n+            if (rectangle.width < 0) {\n+                rectangle.x += rectangle.width;\n+                rectangle.width *= -1;\n+            }\n+\n+            if (rectangle.height < 0) {\n+                rectangle.y += rectangle.height;\n+                rectangle.height *= -1;\n+            }\n+\n+            Set<Object> selectedObjects = new HashSet<>();\n+            for (Figure f : getModel().getDiagram().getFigures()) {\n+                FigureWidget w = getWidget(f);\n+                if (w != null) {\n+                    assert w.getBounds() != null;\n+                    Rectangle r = new Rectangle(w.getBounds());\n+                    r.setLocation(w.getLocation());\n+\n+                    if (r.intersects(rectangle)) {\n+                        selectedObjects.add(f);\n+                    }\n+\n+                    for (Slot s : f.getSlots()) {\n+                        SlotWidget sw = getWidget(s);\n+                        assert sw.getBounds() != null;\n+                        Rectangle r2 = new Rectangle(sw.getBounds());\n+                        r2.setLocation(sw.convertLocalToScene(new Point(0, 0)));\n+\n+                        if (r2.intersects(rectangle)) {\n+                            selectedObjects.add(s);\n+                        }\n+                    }\n+                } else {\n+                    assert false : \"w should not be null here!\";\n+                }\n+            }\n+\n+            setSelectedObjects(selectedObjects);\n+        };\n@@ -461,0 +327,87 @@\n+        ObjectSceneListener selectionChangedListener = new ObjectSceneListener() {\n+\n+            @Override\n+            public void objectAdded(ObjectSceneEvent arg0, Object arg1) {\n+            }\n+\n+            @Override\n+            public void objectRemoved(ObjectSceneEvent arg0, Object arg1) {\n+            }\n+\n+            @Override\n+            public void objectStateChanged(ObjectSceneEvent e, Object o, ObjectState oldState, ObjectState newState) {\n+            }\n+\n+            @Override\n+            public void selectionChanged(ObjectSceneEvent e, Set<Object> oldSet, Set<Object> newSet) {\n+                DiagramScene scene = (DiagramScene) e.getObjectScene();\n+                if (scene.isRebuilding()) {\n+                    return;\n+                }\n+\n+                content.set(newSet, null);\n+\n+                Set<Integer> nodeSelection = new HashSet<>();\n+                for (Object o : newSet) {\n+                    if (o instanceof Properties.Provider) {\n+                        final Properties.Provider provider = (Properties.Provider) o;\n+                        AbstractNode node = new AbstractNode(Children.LEAF) {\n+\n+                            @Override\n+                            protected Sheet createSheet() {\n+                                Sheet s = super.createSheet();\n+                                PropertiesSheet.initializeSheet(provider.getProperties(), s);\n+                                return s;\n+                            }\n+                        };\n+                        node.setDisplayName(provider.getProperties().get(\"name\"));\n+                        content.add(node);\n+                    }\n+\n+\n+                    if (o instanceof Figure) {\n+                        nodeSelection.add(((Figure) o).getInputNode().getId());\n+                    } else if (o instanceof Slot) {\n+                        nodeSelection.addAll(((Slot) o).getSource().getSourceNodesAsSet());\n+                    }\n+                }\n+                getModel().setSelectedNodes(nodeSelection);\n+\n+                boolean b = selectedCoordinatorListener.isEnabled();\n+                selectedCoordinatorListener.setEnabled(false);\n+                SelectionCoordinator.getInstance().setSelectedObjects(nodeSelection);\n+                selectedCoordinatorListener.setEnabled(b);\n+\n+            }\n+\n+            @Override\n+            public void highlightingChanged(ObjectSceneEvent e, Set<Object> oldSet, Set<Object> newSet) {\n+                Set<Integer> nodeHighlighting = new HashSet<>();\n+                for (Object o : newSet) {\n+                    if (o instanceof Figure) {\n+                        nodeHighlighting.add(((Figure) o).getInputNode().getId());\n+                    } else if (o instanceof Slot) {\n+                        nodeHighlighting.addAll(((Slot) o).getSource().getSourceNodesAsSet());\n+                    }\n+                }\n+                highlightedCoordinatorListener.setEnabled(false);\n+                SelectionCoordinator.getInstance().setHighlightedObjects(nodeHighlighting);\n+                highlightedCoordinatorListener.setEnabled(true);\n+            }\n+\n+            @Override\n+            public void hoverChanged(ObjectSceneEvent e, Object oldObject, Object newObject) {\n+                Set<Object> newHighlightedObjects = new HashSet<>(DiagramScene.this.getHighlightedObjects());\n+                if (oldObject != null) {\n+                    newHighlightedObjects.remove(oldObject);\n+                }\n+                if (newObject != null) {\n+                    newHighlightedObjects.add(newObject);\n+                }\n+                DiagramScene.this.setHighlightedObjects(newHighlightedObjects);\n+            }\n+\n+            @Override\n+            public void focusChanged(ObjectSceneEvent arg0, Object arg1, Object arg2) {\n+            }\n+        };\n@@ -468,1 +421,1 @@\n-    public JScrollPane getScrollPane() {\n+    private JScrollPane getScrollPane() {\n@@ -523,1 +476,1 @@\n-    public void setNewModel(DiagramViewModel model) {\n+    private void setNewModel(DiagramViewModel model) {\n@@ -546,1 +499,1 @@\n-        Diagram d = getModel().getDiagramToView();\n+        Diagram d = getModel().getDiagram();\n@@ -549,1 +502,1 @@\n-        for (InputBlock b : d.getGraph().getBlocks()) {\n+        for (InputBlock b : d.getInputBlocks()) {\n@@ -556,2 +509,2 @@\n-            if (f.getWidth() > maxWidth.get(f.getBlock())) {\n-                maxWidth.put(f.getBlock(), f.getWidth());\n+            if (f.getWidth() > maxWidth.get(f.getBlock().getInputBlock())) {\n+                maxWidth.put(f.getBlock().getInputBlock(), f.getWidth());\n@@ -562,1 +515,0 @@\n-\n@@ -565,1 +517,1 @@\n-                f.setWidth(maxWidth.get(f.getBlock()));\n+                f.setWidth(maxWidth.get(f.getBlock().getInputBlock()));\n@@ -594,1 +546,1 @@\n-            for (InputBlock bn : d.getGraph().getBlocks()) {\n+            for (InputBlock bn : d.getInputBlocks()) {\n@@ -606,1 +558,1 @@\n-    public boolean isRebuilding() {\n+    protected boolean isRebuilding() {\n@@ -638,1 +590,1 @@\n-        Diagram diagram = getModel().getDiagramToView();\n+        Diagram diagram = getModel().getDiagram();\n@@ -660,1 +612,1 @@\n-            doClusteredLayout(figures, edges);\n+            doClusteredLayout(edges);\n@@ -674,1 +626,1 @@\n-    private void doClusteredLayout(HashSet<Figure> figures, HashSet<Connection> edges) {\n+    private void doClusteredLayout(HashSet<Connection> edges) {\n@@ -681,1 +633,1 @@\n-        m.doLayout(new LayoutGraph(edges, figures));\n+        m.doLayout(new LayoutGraph(edges));\n@@ -685,1 +637,1 @@\n-        Diagram diagram = getModel().getDiagramToView();\n+        Diagram diagram = getModel().getDiagram();\n@@ -694,1 +646,1 @@\n-        Map<InputNode, Figure> nodeFig = new HashMap<InputNode, Figure>();\n+        Map<InputNode, Figure> nodeFig = new HashMap<>();\n@@ -696,1 +648,1 @@\n-            InputNode n = f.getFirstSourceNode();\n+            InputNode n = f.getInputNode();\n@@ -704,2 +656,1 @@\n-        Map<Figure, Integer> figureRank =\n-            new HashMap<Figure, Integer>(figures.size());\n+        Map<Figure, Integer> figureRank = new HashMap<>(figures.size());\n@@ -707,1 +658,1 @@\n-        for (InputBlock b : getModel().getGraphToView().getBlocks()) {\n+        for (InputBlock b : diagram.getInputBlocks()) {\n@@ -738,1 +689,1 @@\n-        Diagram diagram = getModel().getDiagramToView();\n+        Diagram diagram = getModel().getDiagram();\n@@ -754,2 +705,2 @@\n-            FigureWidget w1 = getWidget((Figure) c.getTo().getVertex());\n-            FigureWidget w2 = getWidget((Figure) c.getFrom().getVertex());\n+            FigureWidget w1 = getWidget(c.getTo().getVertex());\n+            FigureWidget w2 = getWidget(c.getFrom().getVertex());\n@@ -925,3 +876,1 @@\n-            if (p == specialNullPoint) {\n-            } else if (lastPoint == specialNullPoint) {\n-            } else if (lastPoint != null) {\n+            if (p != specialNullPoint && lastPoint != specialNullPoint && lastPoint != null) {\n@@ -942,1 +891,0 @@\n-                this.addObject(new ConnectionSet(connectionList), w);\n@@ -957,13 +905,0 @@\n-    private class ConnectionSet {\n-\n-        private Set<Connection> connections;\n-\n-        public ConnectionSet(Collection<Connection> connections) {\n-            connections = new HashSet<>(connections);\n-        }\n-\n-        public Set<Connection> getConnectionSet() {\n-            return Collections.unmodifiableSet(connections);\n-        }\n-    }\n-\n@@ -975,11 +910,1 @@\n-    @Override\n-    public void initialize() {\n-        Figure f = getModel().getDiagramToView().getRootFigure();\n-        if (f != null) {\n-            setUndoRedoEnabled(false);\n-            gotoFigure(f);\n-            setUndoRedoEnabled(true);\n-        }\n-    }\n-\n-    public void gotoFigures(final List<Figure> figures) {\n+    private void gotoFigures(final List<Figure> figures) {\n@@ -994,0 +919,1 @@\n+                assert r != null;\n@@ -1008,1 +934,1 @@\n-    public void gotoBlock(final Block block) {\n+    private void gotoBlock(final Block block) {\n@@ -1015,2 +941,1 @@\n-    private Set<Object> idSetToObjectSet(Set<Object> ids) {\n-\n+    private Set<Object> idSetToObjectSet(Set<Integer> ids) {\n@@ -1018,2 +943,2 @@\n-        for (Figure f : getModel().getDiagramToView().getFigures()) {\n-            if (DiagramScene.doesIntersect(f.getSource().getSourceNodesAsSet(), ids)) {\n+        for (Figure f : getModel().getDiagram().getFigures()) {\n+            if (ids.contains(f.getInputNode().getId())) {\n@@ -1024,1 +949,1 @@\n-                if (DiagramScene.doesIntersect(s.getSource().getSourceNodesAsSet(), ids)) {\n+                if (!Collections.disjoint(s.getSource().getSourceNodesAsSet(), ids)) {\n@@ -1032,1 +957,1 @@\n-    public void gotoSelection(Set<Object> ids) {\n+    private void gotoSelection(Set<Integer> ids) {\n@@ -1037,1 +962,1 @@\n-        this.getModel().showNot(hiddenNodes);\n+        this.getModel().setHiddenNodes(hiddenNodes);\n@@ -1047,0 +972,1 @@\n+                assert r != null;\n@@ -1091,1 +1017,0 @@\n-            Point p = getScrollPane().getViewport().getViewPosition();\n@@ -1123,22 +1048,1 @@\n-        for (Integer n : f.getSource().getSourceNodesAsSet()) {\n-            if (getModel().getHiddenNodes().contains(n)) {\n-                return false;\n-            }\n-        }\n-        return true;\n-    }\n-\n-    public static boolean doesIntersect(Set<?> s1, Set<?> s2) {\n-        if (s1.size() > s2.size()) {\n-            Set<?> tmp = s1;\n-            s1 = s2;\n-            s2 = tmp;\n-        }\n-\n-        for (Object o : s1) {\n-            if (s2.contains(o)) {\n-                return true;\n-            }\n-        }\n-\n-        return false;\n+        return !getModel().getHiddenNodes().contains(f.getInputNode().getId());\n@@ -1161,1 +1065,1 @@\n-        Diagram diagram = getModel().getDiagramToView();\n+        Diagram diagram = getModel().getDiagram();\n@@ -1164,1 +1068,1 @@\n-        Set<InputBlock> visibleBlocks = new HashSet<InputBlock>();\n+        Set<InputBlock> visibleBlocks = new HashSet<>();\n@@ -1175,1 +1079,1 @@\n-            for (InputBlock b : diagram.getGraph().getBlocks()) {\n+            for (InputBlock b : diagram.getInputBlocks()) {\n@@ -1184,2 +1088,0 @@\n-            boolean hiddenAfter = doesIntersect(f.getSource().getSourceNodesAsSet(), newHiddenNodes);\n-\n@@ -1188,7 +1090,1 @@\n-            if (!hiddenAfter) {\n-                \/\/ Figure is shown\n-                w.setVisible(true);\n-                for (InputNode n : f.getSource().getSourceNodes()) {\n-                    visibleBlocks.add(diagram.getGraph().getBlock(n));\n-                }\n-            } else {\n+            if (newHiddenNodes.contains(f.getInputNode().getId())) {\n@@ -1197,0 +1093,4 @@\n+            } else {\n+                \/\/ Figure is shown\n+                w.setVisible(true);\n+                visibleBlocks.add(f.getBlock().getInputBlock());\n@@ -1219,3 +1119,1 @@\n-                        for (InputNode n : f.getSource().getSourceNodes()) {\n-                            visibleBlocks.add(diagram.getGraph().getBlock(n));\n-                        }\n+                        visibleBlocks.add(f.getBlock().getInputBlock());\n@@ -1237,1 +1135,1 @@\n-                if (f.getBlock().isArtificial()) {\n+                if (f.getBlock().getInputBlock().isArtificial()) {\n@@ -1244,1 +1142,1 @@\n-                visibleBlocks.addAll(diagram.getGraph().getBlocks());\n+                visibleBlocks.addAll(diagram.getInputBlocks());\n@@ -1249,1 +1147,1 @@\n-            for (InputBlock b : diagram.getGraph().getBlocks()) {\n+            for (InputBlock b : diagram.getInputBlocks()) {\n@@ -1257,7 +1155,1 @@\n-                if (visibleAfter) {\n-                    \/\/ Block must be shown\n-                    w.setVisible(true);\n-                } else {\n-                    \/\/ Block must be hidden\n-                    w.setVisible(false);\n-                }\n+                w.setVisible(visibleAfter);\n@@ -1276,14 +1168,2 @@\n-        newHiddenNodes.removeAll(f.getSource().getSourceNodesAsSet());\n-        this.model.setHiddenNodes(newHiddenNodes);\n-    }\n-\n-    public void show(final Figure f) {\n-        showFigure(f);\n-    }\n-\n-    public void setSelectedObjects(Object... args) {\n-        Set<Object> set = new HashSet<>();\n-        for (Object o : args) {\n-            set.add(o);\n-        }\n-        super.setSelectedObjects(set);\n+        newHiddenNodes.remove(f.getInputNode().getId());\n+        this.getModel().setHiddenNodes(newHiddenNodes);\n@@ -1295,0 +1175,1 @@\n+        assert r != null;\n@@ -1306,1 +1187,1 @@\n-            setSelection(Arrays.asList(f));\n+            setSelection(Collections.singletonList(f));\n@@ -1329,4 +1210,4 @@\n-        private DiagramViewModel oldModel;\n-        private DiagramViewModel newModel;\n-        private Point oldScrollPosition;\n-        private DiagramScene scene;\n+        private final DiagramViewModel oldModel;\n+        private final DiagramViewModel newModel;\n+        private final Point oldScrollPosition;\n+        private final DiagramScene scene;\n@@ -1363,7 +1244,1 @@\n-            SwingUtilities.invokeLater(new Runnable() {\n-\n-                @Override\n-                public void run() {\n-                    scene.setScrollPosition(oldScrollPosition);\n-                }\n-            });\n+            SwingUtilities.invokeLater(() -> scene.setScrollPosition(oldScrollPosition));\n@@ -1377,5 +1252,1 @@\n-            if (oldModel.getHiddenNodes().equals(newModel.getHiddenNodes())) {\n-                scene.smallUpdate(false);\n-            } else {\n-                scene.smallUpdate(true);\n-            }\n+            scene.smallUpdate(!oldModel.getHiddenNodes().equals(newModel.getHiddenNodes()));\n@@ -1386,1 +1257,1 @@\n-    public void setUndoRedoEnabled(boolean b) {\n+    private void setUndoRedoEnabled(boolean b) {\n@@ -1390,1 +1261,1 @@\n-    public boolean getUndoRedoEnabled() {\n+    private boolean getUndoRedoEnabled() {\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/DiagramScene.java","additions":216,"deletions":345,"binary":false,"changes":561,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import com.sun.hotspot.igv.data.Properties;\n@@ -38,0 +39,1 @@\n+import java.util.*;\n@@ -39,7 +41,0 @@\n-import java.util.Arrays;\n-import java.util.ArrayList;\n-import java.util.Collection;\n-import java.util.HashSet;\n-import java.util.Iterator;\n-import java.util.List;\n-import java.util.Set;\n@@ -57,1 +52,0 @@\n-    private Set<Integer> onScreenNodes;\n@@ -62,6 +56,6 @@\n-    private InputGraph inputGraph;\n-    private ChangedEvent<DiagramViewModel> groupChangedEvent;\n-    private ChangedEvent<DiagramViewModel> diagramChangedEvent;\n-    private ChangedEvent<DiagramViewModel> viewChangedEvent;\n-    private ChangedEvent<DiagramViewModel> hiddenNodesChangedEvent;\n-    private ChangedEvent<DiagramViewModel> viewPropertiesChangedEvent;\n+    private InputGraph cachedInputGraph;\n+    private final ChangedEvent<DiagramViewModel> groupChangedEvent;\n+    private final ChangedEvent<DiagramViewModel> diagramChangedEvent;\n+    private final ChangedEvent<DiagramViewModel> viewChangedEvent;\n+    private final ChangedEvent<DiagramViewModel> hiddenNodesChangedEvent;\n+    private final ChangedEvent<DiagramViewModel> viewPropertiesChangedEvent;\n@@ -73,8 +67,1 @@\n-    private boolean hideDuplicates;\n-    private ChangedListener<FilterChain> filterChainChangedListener = new ChangedListener<FilterChain>() {\n-\n-        @Override\n-        public void changed(FilterChain source) {\n-            diagramChanged();\n-        }\n-    };\n+    private final ChangedListener<FilterChain> filterChainChangedListener = source -> updateDiagram();\n@@ -84,1 +71,1 @@\n-        DiagramViewModel result = new DiagramViewModel(group, filterChain, sequenceFilterChain);\n+        DiagramViewModel result = new DiagramViewModel(cachedInputGraph, filterChain, sequenceFilterChain);\n@@ -95,3 +82,0 @@\n-        boolean diagramChanged = false;\n-        boolean viewChanged = false;\n-        boolean viewPropertiesChanged = false;\n@@ -99,1 +83,1 @@\n-        boolean groupChanged = (group == newModel.group);\n+        boolean groupChanged = (group != newModel.group);\n@@ -105,1 +89,1 @@\n-        diagramChanged |= (filterChain != newModel.filterChain);\n+        boolean diagramChanged = (filterChain != newModel.filterChain);\n@@ -111,1 +95,1 @@\n-        viewChanged |= (hiddenNodes != newModel.hiddenNodes);\n+        boolean viewChanged = (hiddenNodes != newModel.hiddenNodes);\n@@ -113,2 +97,0 @@\n-        viewChanged |= (onScreenNodes != newModel.onScreenNodes);\n-        this.onScreenNodes = newModel.onScreenNodes;\n@@ -117,1 +99,1 @@\n-        viewPropertiesChanged |= (showSea != newModel.showSea);\n+        boolean viewPropertiesChanged = (showSea != newModel.showSea);\n@@ -186,23 +168,2 @@\n-    public boolean getHideDuplicates() {\n-        return hideDuplicates;\n-    }\n-\n-    public void setHideDuplicates(boolean b) {\n-        System.err.println(\"setHideDuplicates: \" + b);\n-        hideDuplicates = b;\n-        InputGraph currentGraph = getFirstGraph();\n-        if (hideDuplicates) {\n-            \/\/ Back up to the unhidden equivalent graph\n-            int index = graphs.indexOf(currentGraph);\n-            while (graphs.get(index).getProperties().get(\"_isDuplicate\") != null) {\n-                index--;\n-            }\n-            currentGraph = graphs.get(index);\n-        }\n-        filterGraphs();\n-        selectGraph(currentGraph);\n-        viewPropertiesChangedEvent.fire();\n-    }\n-\n-    public DiagramViewModel(Group g, FilterChain filterChain, FilterChain sequenceFilterChain) {\n-        super(Arrays.asList(\"default\"));\n+    public DiagramViewModel(InputGraph graph, FilterChain filterChain, FilterChain sequenceFilterChain) {\n+        super(Collections.singletonList(\"default\"));\n@@ -215,1 +176,1 @@\n-        this.group = g;\n+        this.group = graph.getGroup();\n@@ -222,1 +183,0 @@\n-        onScreenNodes = new HashSet<>();\n@@ -231,0 +191,13 @@\n+        ChangedListener<DiagramViewModel> groupChangedListener = new ChangedListener<DiagramViewModel>() {\n+\n+            private Group oldGroup;\n+\n+            @Override\n+            public void changed(DiagramViewModel source) {\n+                if (oldGroup != null) {\n+                    oldGroup.getChangedEvent().removeListener(groupContentChangedListener);\n+                }\n+                group.getChangedEvent().addListener(groupContentChangedListener);\n+                oldGroup = group;\n+            }\n+        };\n@@ -236,2 +209,0 @@\n-    }\n-    private final ChangedListener<DiagramViewModel> groupChangedListener = new ChangedListener<DiagramViewModel>() {\n@@ -239,1 +210,2 @@\n-        private Group oldGroup;\n+        selectGraph(graph);\n+    }\n@@ -241,9 +213,0 @@\n-        @Override\n-        public void changed(DiagramViewModel source) {\n-            if (oldGroup != null) {\n-                oldGroup.getChangedEvent().removeListener(groupContentChangedListener);\n-            }\n-            group.getChangedEvent().addListener(groupContentChangedListener);\n-            oldGroup = group;\n-        }\n-    };\n@@ -289,4 +252,0 @@\n-    public Set<Integer> getOnScreenNodes() {\n-        return onScreenNodes;\n-    }\n-\n@@ -296,1 +255,1 @@\n-        for (String s : getPositions()) {\n+        for (String ignored : getPositions()) {\n@@ -334,4 +293,0 @@\n-    public void showNot(final Set<Integer> nodes) {\n-        setHiddenNodes(nodes);\n-    }\n-\n@@ -341,1 +296,1 @@\n-            newHiddenNodes.removeAll(fig.getSource().getSourceNodesAsSet());\n+            newHiddenNodes.remove(fig.getInputNode().getId());\n@@ -350,4 +305,2 @@\n-            for (InputNode node : f.getSource().getSourceNodes()) {\n-                if (getSelectedNodes().contains(node.getId())) {\n-                    result.add(f);\n-                }\n+            if (getSelectedNodes().contains(f.getInputNode().getId())) {\n+                result.add(f);\n@@ -364,1 +317,1 @@\n-        final HashSet<Integer> allNodes = new HashSet<>(getGraphToView().getGroup().getAllNodes());\n+        final HashSet<Integer> allNodes = new HashSet<>(getGroup().getAllNodes());\n@@ -374,5 +327,0 @@\n-    public void setOnScreenNodes(Set<Integer> onScreenNodes) {\n-        this.onScreenNodes = onScreenNodes;\n-        viewChangedEvent.fire();\n-    }\n-\n@@ -383,9 +331,1 @@\n-    public void setSequenceFilterChain(FilterChain chain) {\n-        assert chain != null : \"sequenceFilterChain must never be null\";\n-        sequenceFilterChain.getChangedEvent().removeListener(filterChainChangedListener);\n-        sequenceFilterChain = chain;\n-        sequenceFilterChain.getChangedEvent().addListener(filterChainChangedListener);\n-        diagramChanged();\n-    }\n-\n-    private void diagramChanged() {\n+    private void updateDiagram() {\n@@ -393,2 +333,20 @@\n-        diagram = null;\n-        getDiagramChangedEvent().fire();\n+        InputGraph graph = getGraph();\n+        if (graph.getBlocks().isEmpty()) {\n+            Scheduler s = Lookup.getDefault().lookup(Scheduler.class);\n+            graph.clearBlocks();\n+            s.schedule(graph);\n+            graph.ensureNodesInBlocks();\n+        }\n+        diagram = new Diagram(graph,\n+                Settings.get().get(Settings.NODE_TEXT, Settings.NODE_TEXT_DEFAULT),\n+                Settings.get().get(Settings.NODE_SHORT_TEXT, Settings.NODE_SHORT_TEXT_DEFAULT),\n+                Settings.get().get(Settings.NODE_TINY_TEXT, Settings.NODE_TINY_TEXT_DEFAULT));\n+        getFilterChain().apply(diagram, getSequenceFilterChain());\n+        if (graph.isDiffGraph()) {\n+            ColorFilter f = new ColorFilter(\"\");\n+            f.addRule(stateColorRule(\"same\",    Color.white));\n+            f.addRule(stateColorRule(\"changed\", Color.orange));\n+            f.addRule(stateColorRule(\"new\",     Color.green));\n+            f.addRule(stateColorRule(\"deleted\", Color.red));\n+            f.apply(diagram);\n+        }\n@@ -396,0 +354,1 @@\n+        diagramChangedEvent.fire();\n@@ -402,8 +361,0 @@\n-    public void setFilterChain(FilterChain chain) {\n-        assert chain != null : \"filterChain must never be null\";\n-        filterChain.getChangedEvent().removeListener(filterChainChangedListener);\n-        filterChain = chain;\n-        filterChain.getChangedEvent().addListener(filterChainChangedListener);\n-        diagramChanged();\n-    }\n-\n@@ -417,5 +368,2 @@\n-            String duplicate = graph.getProperties().get(\"_isDuplicate\");\n-            if (duplicate == null || !hideDuplicates) {\n-                result.add(graph);\n-                positions.add(graph.getName());\n-            }\n+            result.add(graph);\n+            positions.add(graph.getName());\n@@ -443,5 +391,0 @@\n-        if (index == -1 && hideDuplicates) {\n-            \/\/ A graph was selected that's currently hidden, so unhide and select it.\n-            setHideDuplicates(false);\n-            index = graphs.indexOf(g);\n-        }\n@@ -456,25 +399,1 @@\n-    public Diagram getDiagramToView() {\n-\n-        if (diagram == null) {\n-            InputGraph graph = getGraphToView();\n-            if (graph.getBlocks().isEmpty()) {\n-                Scheduler s = Lookup.getDefault().lookup(Scheduler.class);\n-                graph.clearBlocks();\n-                s.schedule(graph);\n-                graph.ensureNodesInBlocks();\n-            }\n-            diagram = Diagram.createDiagram(graph,\n-                                            Settings.get().get(Settings.NODE_TEXT, Settings.NODE_TEXT_DEFAULT),\n-                                            Settings.get().get(Settings.NODE_SHORT_TEXT, Settings.NODE_SHORT_TEXT_DEFAULT),\n-                                            Settings.get().get(Settings.NODE_TINY_TEXT, Settings.NODE_TINY_TEXT_DEFAULT));\n-            getFilterChain().apply(diagram, getSequenceFilterChain());\n-            if (graph.isDiffGraph()) {\n-                ColorFilter f = new ColorFilter(\"\");\n-                f.addRule(stateColorRule(\"same\",    Color.white));\n-                f.addRule(stateColorRule(\"changed\", Color.orange));\n-                f.addRule(stateColorRule(\"new\",     Color.green));\n-                f.addRule(stateColorRule(\"deleted\", Color.red));\n-                f.apply(diagram);\n-           }\n-        }\n-\n+    public Diagram getDiagram() {\n@@ -485,10 +404,2 @@\n-    public InputGraph getGraphToView() {\n-        if (inputGraph == null) {\n-            if (getFirstGraph() != getSecondGraph()) {\n-                inputGraph = Difference.createDiffGraph(getFirstGraph(), getSecondGraph());\n-            } else {\n-                inputGraph = getFirstGraph();\n-            }\n-        }\n-\n-        return inputGraph;\n+    public InputGraph getGraph() {\n+        return cachedInputGraph;\n@@ -499,8 +410,4 @@\n-        inputGraph = null;\n-        diagramChanged();\n-    }\n-\n-    void setSelectedFigures(List<Figure> list) {\n-        Set<Integer> newSelectedNodes = new HashSet<>();\n-        for (Figure f : list) {\n-            newSelectedNodes.addAll(f.getSource().getSourceNodesAsSet());\n+        if (getFirstGraph() != getSecondGraph()) {\n+            cachedInputGraph = Difference.createDiffGraph(getFirstGraph(), getSecondGraph());\n+        } else {\n+            cachedInputGraph = getFirstGraph();\n@@ -508,1 +415,1 @@\n-        this.setSelectedNodes(newSelectedNodes);\n+        updateDiagram();\n@@ -517,1 +424,2 @@\n-        return new Iterable<InputGraph>() {\n+        return () -> new Iterator<InputGraph>() {\n+            int index = getFirstPosition();\n@@ -520,8 +428,3 @@\n-            public Iterator<InputGraph> iterator() {\n-                return new Iterator<InputGraph>() {\n-                    int index = getFirstPosition();\n-\n-                    @Override\n-                    public boolean hasNext() {\n-                        return index + 1 < graphs.size();\n-                    }\n+            public boolean hasNext() {\n+                return index + 1 < graphs.size();\n+            }\n@@ -529,5 +432,3 @@\n-                    @Override\n-                    public InputGraph next() {\n-                        return graphs.get(++index);\n-                    }\n-                };\n+            @Override\n+            public InputGraph next() {\n+                return graphs.get(++index);\n@@ -539,5 +440,2 @@\n-        return new Iterable<InputGraph>() {\n-            @Override\n-            public Iterator<InputGraph> iterator() {\n-                return new Iterator<InputGraph>() {\n-                    int index = getFirstPosition();\n+        return () -> new Iterator<InputGraph>() {\n+            int index = getFirstPosition();\n@@ -545,4 +443,4 @@\n-                    @Override\n-                    public boolean hasNext() {\n-                        return index - 1 > 0;\n-                    }\n+            @Override\n+            public boolean hasNext() {\n+                return index - 1 > 0;\n+            }\n@@ -550,5 +448,3 @@\n-                    @Override\n-                    public InputGraph next() {\n-                        return graphs.get(--index);\n-                    }\n-                };\n+            @Override\n+            public InputGraph next() {\n+                return graphs.get(--index);\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/DiagramViewModel.java","additions":86,"deletions":190,"binary":false,"changes":276,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-    public void paint(Graphics2D generator);\n+    DiagramViewModel getModel();\n@@ -50,1 +50,1 @@\n-    public Lookup getLookup();\n+    void paint(Graphics2D generator);\n@@ -52,1 +52,1 @@\n-    public JComponent createSatelliteView();\n+    Lookup getLookup();\n@@ -54,1 +54,1 @@\n-    public Component getComponent();\n+    JComponent createSatelliteView();\n@@ -56,1 +56,1 @@\n-    public void zoomOut();\n+    Component getComponent();\n@@ -58,1 +58,1 @@\n-    public void zoomIn();\n+    void zoomOut();\n@@ -60,1 +60,1 @@\n-    public UndoRedo getUndoRedo();\n+    void zoomIn();\n@@ -62,1 +62,1 @@\n-    public void componentHidden();\n+    UndoRedo getUndoRedo();\n@@ -64,1 +64,1 @@\n-    public void componentShowing();\n+    void componentHidden();\n@@ -66,1 +66,1 @@\n-    public void initialize();\n+    void componentShowing();\n@@ -68,1 +68,1 @@\n-    public void setSelection(Collection<Figure> list);\n+    void setSelection(Collection<Figure> list);\n@@ -70,1 +70,1 @@\n-    public void centerFigures(List<Figure> list);\n+    void centerFigures(List<Figure> list);\n@@ -72,1 +72,1 @@\n-    public void setInteractionMode(InteractionMode mode);\n+    void setInteractionMode(InteractionMode mode);\n@@ -74,1 +74,1 @@\n-    public Rectangle getBounds();\n+    Rectangle getBounds();\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/DiagramViewer.java","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-        return editor.getDiagramModel().getGraphToView();\n+        return editor.getModel().getGraph();\n@@ -60,1 +60,1 @@\n-        return editor.getDiagramModel().getGraphsBackward();\n+        return editor.getModel().getGraphsBackward();\n@@ -65,1 +65,1 @@\n-        return editor.getDiagramModel().getGraphsForward();\n+        return editor.getModel().getGraphsForward();\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/EditorInputGraphProvider.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import com.sun.hotspot.igv.data.Properties;\n@@ -34,1 +33,0 @@\n-import com.sun.hotspot.igv.data.Properties.PropertyMatcher;\n@@ -40,1 +38,0 @@\n-import com.sun.hotspot.igv.graph.services.DiagramProvider;\n@@ -47,2 +44,0 @@\n-import java.awt.event.HierarchyBoundsListener;\n-import java.awt.event.HierarchyEvent;\n@@ -54,0 +49,1 @@\n+import java.nio.file.Files;\n@@ -85,20 +81,14 @@\n-    private DiagramViewer scene;\n-    private InstanceContent content;\n-    private InstanceContent graphContent;\n-    private EnableSeaLayoutAction seaLayoutAction;\n-    private EnableBlockLayoutAction blockLayoutAction;\n-    private EnableCFGLayoutAction cfgLayoutAction;\n-    private OverviewAction overviewAction;\n-    private HideDuplicatesAction hideDuplicatesAction;\n-    private PredSuccAction predSuccAction;\n-    private ShowEmptyBlocksAction showEmptyBlocksAction;\n-    private SelectionModeAction selectionModeAction;\n-    private boolean notFirstTime;\n-    private JComponent satelliteComponent;\n-    private JPanel centerPanel;\n-    private CardLayout cardLayout;\n-    private RangeSlider rangeSlider;\n-    private JToggleButton overviewButton;\n-    private JToggleButton hideDuplicatesButton;\n-    private JPanel topPanel;\n-    private Toolbar quickSearchToolbar;\n+    private final DiagramViewer scene;\n+    private final InstanceContent graphContent;\n+    private final EnableSeaLayoutAction seaLayoutAction;\n+    private final EnableBlockLayoutAction blockLayoutAction;\n+    private final EnableCFGLayoutAction cfgLayoutAction;\n+    private final OverviewAction overviewAction;\n+    private final PredSuccAction predSuccAction;\n+    private final ShowEmptyBlocksAction showEmptyBlocksAction;\n+    private final SelectionModeAction selectionModeAction;\n+    private final JComponent satelliteComponent;\n+    private final JPanel centerPanel;\n+    private final CardLayout cardLayout;\n+    private final JToggleButton overviewButton;\n+    private final Toolbar quickSearchToolbar;\n@@ -109,1 +99,0 @@\n-    private DiagramViewModel rangeSliderModel;\n@@ -127,16 +116,0 @@\n-    private DiagramProvider diagramProvider = new DiagramProvider() {\n-\n-        @Override\n-        public Diagram getDiagram() {\n-            return getModel().getDiagramToView();\n-        }\n-\n-        @Override\n-        public ChangedEvent<DiagramProvider> getChangedEvent() {\n-            return diagramChangedEvent;\n-        }\n-    };\n-\n-    private ChangedEvent<DiagramProvider> diagramChangedEvent = new ChangedEvent<>(diagramProvider);\n-\n-\n@@ -144,2 +117,2 @@\n-        setDisplayName(getDiagram().getName());\n-        setToolTipText(getDiagram().getGraph().getGroup().getName());\n+        setDisplayName(getModel().getGraph().getName());\n+        setToolTipText(getModel().getGroup().getName());\n@@ -148,2 +121,1 @@\n-    public EditorTopComponent(Diagram diagram) {\n-\n+    public EditorTopComponent(InputGraph graph) {\n@@ -151,1 +123,0 @@\n-        LookupHistory.init(DiagramProvider.class);\n@@ -153,2 +124,2 @@\n-        FilterChain filterChain = null;\n-        FilterChain sequence = null;\n+        FilterChain filterChain;\n+        FilterChain sequence;\n@@ -203,3 +174,17 @@\n-        rangeSliderModel = new DiagramViewModel(diagram.getGraph().getGroup(), filterChain, sequence);\n-        rangeSlider = new RangeSlider();\n-        rangeSlider.setModel(rangeSliderModel);\n+        DiagramViewModel diagramViewModel = new DiagramViewModel(graph, filterChain, sequence);\n+        ChangedListener<DiagramViewModel> diagramChangedListener = new ChangedListener<DiagramViewModel>() {\n+\n+            @Override\n+            public void changed(DiagramViewModel source) {\n+                updateDisplayName();\n+                Collection<Object> list = new ArrayList<>();\n+                list.add(new EditorInputGraphProvider(EditorTopComponent.this));\n+                graphContent.set(list, null);\n+            }\n+\n+        };\n+        diagramViewModel.getDiagramChangedEvent().addListener(diagramChangedListener);\n+        RangeSlider rangeSlider = new RangeSlider(diagramViewModel);\n+        if (diagramViewModel.getGroup().getGraphs().size() == 1) {\n+            rangeSlider.setVisible(false);\n+        }\n@@ -209,2 +194,1 @@\n-        scene = new DiagramScene(actions, actionsWithSelection, rangeSliderModel);\n-        content = new InstanceContent();\n+        scene = new DiagramScene(actions, actionsWithSelection, diagramViewModel);\n@@ -212,1 +196,1 @@\n-        this.associateLookup(new ProxyLookup(new Lookup[]{scene.getLookup(), new AbstractLookup(graphContent), new AbstractLookup(content)}));\n+        InstanceContent content = new InstanceContent();\n@@ -214,12 +198,2 @@\n-        content.add(rangeSliderModel);\n-        content.add(diagramProvider);\n-\n-        rangeSliderModel.getDiagramChangedEvent().addListener(diagramChangedListener);\n-        rangeSliderModel.selectGraph(diagram.getGraph());\n-        rangeSliderModel.getViewPropertiesChangedEvent().addListener(new ChangedListener<DiagramViewModel>() {\n-                @Override\n-                public void changed(DiagramViewModel source) {\n-                    hideDuplicatesButton.setSelected(getModel().getHideDuplicates());\n-                    hideDuplicatesAction.setState(getModel().getHideDuplicates());\n-                }\n-            });\n+        content.add(diagramViewModel);\n+        this.associateLookup(new ProxyLookup(scene.getLookup(), new AbstractLookup(graphContent), new AbstractLookup(content)));\n@@ -227,1 +201,1 @@\n-        Group group = getDiagram().getGraph().getGroup();\n+        Group group = diagramViewModel.getGroup();\n@@ -291,6 +265,0 @@\n-        hideDuplicatesAction = new HideDuplicatesAction();\n-        hideDuplicatesButton = new JToggleButton(hideDuplicatesAction);\n-        hideDuplicatesButton.setSelected(false);\n-        toolBar.add(hideDuplicatesButton);\n-        hideDuplicatesAction.addPropertyChangeListener(this);\n-\n@@ -324,1 +292,1 @@\n-        topPanel = new JPanel();\n+        JPanel topPanel = new JPanel();\n@@ -361,25 +329,0 @@\n-        scene.getComponent().addHierarchyBoundsListener(new HierarchyBoundsListener() {\n-\n-            @Override\n-            public void ancestorMoved(HierarchyEvent e) {\n-            }\n-\n-            @Override\n-            public void ancestorResized(HierarchyEvent e) {\n-                if (!notFirstTime && scene.getComponent().getBounds().width > 0) {\n-                    notFirstTime = true;\n-                    SwingUtilities.invokeLater(new Runnable() {\n-\n-                        @Override\n-                        public void run() {\n-                            EditorTopComponent.this.scene.initialize();\n-                        }\n-                    });\n-                }\n-            }\n-        });\n-\n-        if (diagram.getGraph().getGroup().getGraphsCount() == 1) {\n-            rangeSlider.setVisible(false);\n-        }\n-\n@@ -389,2 +332,6 @@\n-    public DiagramViewModel getDiagramModel() {\n-        return rangeSliderModel;\n+    public DiagramViewModel getModel() {\n+        return scene.getModel();\n+    }\n+\n+    private Diagram getDiagram() {\n+        return getModel().getDiagram();\n@@ -412,18 +359,0 @@\n-    public void showPrevDiagram() {\n-        int fp = getModel().getFirstPosition();\n-        int sp = getModel().getSecondPosition();\n-        if (fp != 0) {\n-            fp--;\n-            sp--;\n-            getModel().setPositions(fp, sp);\n-        }\n-    }\n-\n-    public DiagramViewModel getModel() {\n-        return rangeSliderModel;\n-    }\n-\n-    public FilterChain getFilterChain() {\n-        return getModel().getFilterChain();\n-    }\n-\n@@ -462,1 +391,1 @@\n-        rangeSliderModel.close();\n+        getModel().close();\n@@ -471,1 +400,1 @@\n-        Group group = getDiagram().getGraph().getGroup();\n+        Group group = getModel().getGroup();\n@@ -478,25 +407,1 @@\n-    private ChangedListener<DiagramViewModel> diagramChangedListener = new ChangedListener<DiagramViewModel>() {\n-\n-        @Override\n-        public void changed(DiagramViewModel source) {\n-            updateDisplayName();\n-            Collection<Object> list = new ArrayList<>();\n-            list.add(new EditorInputGraphProvider(EditorTopComponent.this));\n-            graphContent.set(list, null);\n-            diagramProvider.getChangedEvent().fire();\n-        }\n-\n-    };\n-\n-    public boolean showPredSucc() {\n-        return (Boolean) predSuccAction.getValue(PredSuccAction.STATE);\n-    }\n-\n-    public void setSelection(PropertyMatcher matcher) {\n-\n-        Properties.PropertySelector<Figure> selector = new Properties.PropertySelector<>(getModel().getDiagramToView().getFigures());\n-        List<Figure> list = selector.selectMultiple(matcher);\n-        setSelectedFigures(list);\n-    }\n-\n-    public void setSelectedFigures(List<Figure> list) {\n+    private void setSelectedFigures(List<Figure> list) {\n@@ -515,6 +420,3 @@\n-        for (Figure f : getModel().getDiagramToView().getFigures()) {\n-            for (InputNode n : f.getSource().getSourceNodes()) {\n-                if (ids.contains(n.getId())) {\n-                    list.add(f);\n-                    break;\n-                }\n+        for (Figure f : getDiagram().getFigures()) {\n+            if (ids.contains(f.getInputNode().getId())) {\n+                list.add(f);\n@@ -529,2 +431,2 @@\n-        for (Figure f : getModel().getDiagramToView().getFigures()) {\n-            if (f.getBlock() == b) {\n+        for (Figure f : getDiagram().getFigures()) {\n+            if (f.getBlock().getInputBlock() == b) {\n@@ -564,3 +466,0 @@\n-        } else if (evt.getSource() == this.hideDuplicatesAction) {\n-            boolean b = (Boolean) hideDuplicatesAction.getValue(HideDuplicatesAction.STATE);\n-            this.getModel().setHideDuplicates(b);\n@@ -579,11 +478,0 @@\n-    public void extract() {\n-        getModel().showOnly(getModel().getSelectedNodes());\n-    }\n-\n-    public void hideNodes() {\n-        Set<Integer> selectedNodes = this.getModel().getSelectedNodes();\n-        HashSet<Integer> nodes = new HashSet<>(getModel().getHiddenNodes());\n-        nodes.addAll(selectedNodes);\n-        this.getModel().showNot(nodes);\n-    }\n-\n@@ -594,1 +482,1 @@\n-        for (Figure f : this.getDiagramModel().getDiagramToView().getFigures()) {\n+        for (Figure f : getDiagram().getFigures()) {\n@@ -619,1 +507,1 @@\n-        for (Figure f : this.getDiagramModel().getDiagramToView().getFigures()) {\n+        for (Figure f : getDiagram().getFigures()) {\n@@ -640,8 +528,0 @@\n-    public void showAll() {\n-        getModel().showNot(new HashSet<Integer>());\n-    }\n-\n-    public Diagram getDiagram() {\n-        return getDiagramModel().getDiagramToView();\n-    }\n-\n@@ -679,5 +559,0 @@\n-    @Override\n-    protected Object writeReplace() throws ObjectStreamException {\n-        throw new NotSerializableException();\n-    }\n-\n@@ -690,1 +565,1 @@\n-            writer = PdfWriter.getInstance(document, new FileOutputStream(f));\n+            writer = PdfWriter.getInstance(document, Files.newOutputStream(f.toPath()));\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/EditorTopComponent.java","additions":60,"deletions":185,"binary":false,"changes":245,"status":"modified"},{"patch":"@@ -1,216 +0,0 @@\n-\/*\n- * Copyright (c) 2008, 2015, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-package com.sun.hotspot.igv.view;\n-\n-import java.awt.*;\n-import java.awt.event.*;\n-import javax.swing.JComponent;\n-import org.netbeans.api.visual.widget.Scene;\n-\n-\/**\n- * @author David Kaspar\n- * @author Thomas Wuerthinger\n- *\/\n-public class ExtendedSatelliteComponent extends JComponent implements MouseListener, MouseMotionListener, Scene.SceneListener, ComponentListener {\n-\n-    private DiagramScene scene;\n-    private Image image;\n-    private int imageWidth;\n-    private int imageHeight;\n-\n-    public ExtendedSatelliteComponent(DiagramScene scene) {\n-        this.scene = scene;\n-        setDoubleBuffered(true);\n-        setPreferredSize(new Dimension(128, 128));\n-        addMouseListener(this);\n-        addMouseMotionListener(this);\n-    }\n-\n-    @Override\n-    public void addNotify() {\n-        super.addNotify();\n-        scene.addSceneListener(this);\n-        JComponent viewComponent = scene.getView();\n-        if (viewComponent == null) {\n-            viewComponent = scene.createView();\n-        }\n-        viewComponent.addComponentListener(this);\n-        repaint();\n-    }\n-\n-    @Override\n-    public void removeNotify() {\n-        scene.getView().removeComponentListener(this);\n-        scene.removeSceneListener(this);\n-        super.removeNotify();\n-    }\n-\n-    public void update() {\n-        this.image = null;\n-        if (this.isVisible()) {\n-            repaint();\n-            revalidate();\n-            validate();\n-        }\n-    }\n-\n-    @Override\n-    public void paint(Graphics g) {\n-        Graphics2D gr = (Graphics2D) g;\n-        super.paint(g);\n-        Rectangle bounds = scene.getBounds();\n-        Dimension size = getSize();\n-\n-        double sx = bounds.width > 0 ? (double) size.width \/ bounds.width : 0.0;\n-        double sy = bounds.width > 0 ? (double) size.height \/ bounds.height : 0.0;\n-        double scale = Math.min(sx, sy);\n-\n-        int vw = (int) (scale * bounds.width);\n-        int vh = (int) (scale * bounds.height);\n-        int vx = (size.width - vw) \/ 2;\n-        int vy = (size.height - vh) \/ 2;\n-\n-\n-        if (image == null || vw != imageWidth || vh != imageHeight) {\n-            imageWidth = vw;\n-            imageHeight = vh;\n-            image = this.createImage(imageWidth, imageHeight);\n-            Graphics2D ig = (Graphics2D) image.getGraphics();\n-            ig.scale(scale, scale);\n-            double oldFactor = scene.getZoomFactor();\n-            scene.setZoomFactor(scale);\n-            scene.paint(ig);\n-            scene.setZoomFactor(oldFactor);\n-        }\n-\n-        gr.drawImage(image, vx, vy, this);\n-\n-        JComponent component = scene.getView();\n-        double zoomFactor = scene.getZoomFactor();\n-        Rectangle viewRectangle = component != null ? component.getVisibleRect() : null;\n-        if (viewRectangle != null) {\n-            Rectangle window = new Rectangle(\n-                    (int) ((double) viewRectangle.x * scale \/ zoomFactor),\n-                    (int) ((double) viewRectangle.y * scale \/ zoomFactor),\n-                    (int) ((double) viewRectangle.width * scale \/ zoomFactor),\n-                    (int) ((double) viewRectangle.height * scale \/ zoomFactor));\n-            window.translate(vx, vy);\n-            gr.setColor(new Color(200, 200, 200, 128));\n-            gr.fill(window);\n-            gr.setColor(Color.BLACK);\n-            gr.drawRect(window.x, window.y, window.width - 1, window.height - 1);\n-        }\n-    }\n-\n-    @Override\n-    public void mouseClicked(MouseEvent e) {\n-    }\n-\n-    @Override\n-    public void mousePressed(MouseEvent e) {\n-        moveVisibleRect(e.getPoint());\n-    }\n-\n-    @Override\n-    public void mouseReleased(MouseEvent e) {\n-        moveVisibleRect(e.getPoint());\n-    }\n-\n-    @Override\n-    public void mouseEntered(MouseEvent e) {\n-    }\n-\n-    @Override\n-    public void mouseExited(MouseEvent e) {\n-    }\n-\n-    @Override\n-    public void mouseDragged(MouseEvent e) {\n-        moveVisibleRect(e.getPoint());\n-    }\n-\n-    @Override\n-    public void mouseMoved(MouseEvent e) {\n-    }\n-\n-    private void moveVisibleRect(Point center) {\n-        JComponent component = scene.getView();\n-        if (component == null) {\n-            return;\n-        }\n-        double zoomFactor = scene.getZoomFactor();\n-        Rectangle bounds = scene.getBounds();\n-        Dimension size = getSize();\n-\n-        double sx = bounds.width > 0 ? (double) size.width \/ bounds.width : 0.0;\n-        double sy = bounds.width > 0 ? (double) size.height \/ bounds.height : 0.0;\n-        double scale = Math.min(sx, sy);\n-\n-        int vw = (int) (scale * bounds.width);\n-        int vh = (int) (scale * bounds.height);\n-        int vx = (size.width - vw) \/ 2;\n-        int vy = (size.height - vh) \/ 2;\n-\n-        int cx = (int) ((double) (center.x - vx) \/ scale * zoomFactor);\n-        int cy = (int) ((double) (center.y - vy) \/ scale * zoomFactor);\n-\n-        Rectangle visibleRect = component.getVisibleRect();\n-        visibleRect.x = cx - visibleRect.width \/ 2;\n-        visibleRect.y = cy - visibleRect.height \/ 2;\n-        component.scrollRectToVisible(visibleRect);\n-\n-        this.repaint();\n-    }\n-\n-    @Override\n-    public void sceneRepaint() {\n-    \/\/repaint ();\n-    }\n-\n-    @Override\n-    public void sceneValidating() {\n-    }\n-\n-    @Override\n-    public void sceneValidated() {\n-    }\n-\n-    @Override\n-    public void componentResized(ComponentEvent e) {\n-        repaint();\n-    }\n-\n-    @Override\n-    public void componentMoved(ComponentEvent e) {\n-        repaint();\n-    }\n-\n-    @Override\n-    public void componentShown(ComponentEvent e) {\n-    }\n-\n-    @Override\n-    public void componentHidden(ComponentEvent e) {\n-    }\n-}\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/ExtendedSatelliteComponent.java","additions":0,"deletions":216,"binary":false,"changes":216,"status":"deleted"},{"patch":"@@ -28,2 +28,0 @@\n-import com.sun.hotspot.igv.graph.Diagram;\n-import com.sun.hotspot.igv.settings.Settings;\n@@ -33,0 +31,1 @@\n+import org.openide.util.lookup.ServiceProvider;\n@@ -36,1 +35,0 @@\n-import org.openide.util.lookup.ServiceProvider;\n@@ -47,1 +45,0 @@\n-\n@@ -67,6 +64,1 @@\n-        Diagram diagram = Diagram.createDiagram(graph,\n-                                                Settings.get().get(Settings.NODE_TEXT, Settings.NODE_TEXT_DEFAULT),\n-                                                Settings.get().get(Settings.NODE_SHORT_TEXT, Settings.NODE_SHORT_TEXT_DEFAULT),\n-                                                Settings.get().get(Settings.NODE_TINY_TEXT, Settings.NODE_TINY_TEXT_DEFAULT));\n-        EditorTopComponent tc = new EditorTopComponent(diagram);\n-        diagram.setCFG(tc.getModel().getShowCFG());\n+        EditorTopComponent tc = new EditorTopComponent(graph);\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/GraphViewerImplementation.java","additions":2,"deletions":10,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -124,1 +124,1 @@\n-                                    comp.getDiagramModel().selectGraph(theGraph);\n+                                    comp.getModel().selectGraph(theGraph);\n@@ -153,1 +153,1 @@\n-                                    comp.getDiagramModel().selectGraph(theGraph);\n+                                    comp.getModel().selectGraph(theGraph);\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/NodeQuickSearch.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,4 +26,1 @@\n-import org.netbeans.api.visual.widget.Widget;\n-import org.netbeans.api.visual.action.WidgetAction;\n-import org.netbeans.api.visual.action.SelectProvider;\n-\n+import java.awt.Point;\n@@ -31,2 +28,3 @@\n-import java.awt.event.KeyEvent;\n-import java.awt.*;\n+import org.netbeans.api.visual.action.SelectProvider;\n+import org.netbeans.api.visual.action.WidgetAction;\n+import org.netbeans.api.visual.widget.Widget;\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/actions\/CustomSelectAction.java","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -53,1 +53,0 @@\n-import javax.swing.JScrollBar;\n@@ -55,2 +54,0 @@\n-import org.netbeans.api.visual.action.WidgetAction.State;\n-import org.netbeans.api.visual.action.WidgetAction.WidgetMouseEvent;\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/actions\/CustomizablePanAction.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -31,1 +31,4 @@\n-import org.openide.util.*;\n+import org.openide.util.HelpCtx;\n+import org.openide.util.ImageUtilities;\n+import org.openide.util.Lookup;\n+import org.openide.util.NbBundle;\n@@ -94,0 +97,5 @@\n+\n+    @Override\n+    protected boolean asynchronous() {\n+        return false;\n+    }\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/actions\/ExpandDiffAction.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-import java.awt.event.InputEvent;\n-import java.awt.event.KeyEvent;\n@@ -33,1 +31,0 @@\n-import javax.swing.KeyStroke;\n@@ -37,1 +34,0 @@\n-import org.openide.util.Utilities;\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/actions\/ExportAction.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,2 +27,0 @@\n-import java.awt.Event;\n-import java.awt.event.KeyEvent;\n@@ -30,1 +28,0 @@\n-import javax.swing.KeyStroke;\n@@ -32,1 +29,0 @@\n-import org.openide.util.actions.CallableSystemAction;\n@@ -34,0 +30,1 @@\n+import org.openide.util.actions.CallableSystemAction;\n@@ -45,1 +42,1 @@\n-            editor.extract();\n+            editor.getModel().showOnly(editor.getModel().getSelectedNodes());\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/actions\/ExtractAction.java","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -27,2 +27,2 @@\n-import java.awt.Event;\n-import java.awt.event.KeyEvent;\n+import java.util.HashSet;\n+import java.util.Set;\n@@ -30,1 +30,0 @@\n-import javax.swing.KeyStroke;\n@@ -32,1 +31,0 @@\n-import org.openide.util.actions.CallableSystemAction;\n@@ -34,0 +32,1 @@\n+import org.openide.util.actions.CallableSystemAction;\n@@ -45,1 +44,4 @@\n-            editor.hideNodes();\n+            Set<Integer> selectedNodes = editor.getModel().getSelectedNodes();\n+            HashSet<Integer> nodes = new HashSet<>(editor.getModel().getHiddenNodes());\n+            nodes.addAll(selectedNodes);\n+            editor.getModel().setHiddenNodes(nodes);\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/actions\/HideAction.java","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1,60 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2015, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-package com.sun.hotspot.igv.view.actions;\n-\n-import java.awt.event.ActionEvent;\n-import javax.swing.AbstractAction;\n-import javax.swing.Action;\n-import javax.swing.ImageIcon;\n-import org.openide.util.ImageUtilities;\n-\n-\/**\n- *\n- * @author Tom Rodriguez\n- *\/\n-public class HideDuplicatesAction extends AbstractAction {\n-\n-    private boolean state;\n-    public static final String STATE = \"state\";\n-\n-    public HideDuplicatesAction() {\n-        putValue(AbstractAction.SMALL_ICON, new ImageIcon(ImageUtilities.loadImage(iconResource())));\n-        putValue(Action.SHORT_DESCRIPTION, \"Hide graphs which are the same as the previous graph\");\n-        setState(false);\n-    }\n-\n-    @Override\n-    public void actionPerformed(ActionEvent ev) {\n-        setState(!state);\n-    }\n-\n-    public void setState(boolean b) {\n-        this.putValue(STATE, b);\n-        this.state = b;\n-    }\n-\n-    protected String iconResource() {\n-        return \"com\/sun\/hotspot\/igv\/view\/images\/hideDuplicates.png\";\n-    }\n-}\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/actions\/HideDuplicatesAction.java","additions":0,"deletions":60,"binary":false,"changes":60,"status":"deleted"},{"patch":"@@ -1,59 +0,0 @@\n-\/*\n- * Copyright (c) 2008, 2015, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-package com.sun.hotspot.igv.view.actions;\n-\n-import org.netbeans.api.visual.action.HoverProvider;\n-import org.netbeans.api.visual.action.WidgetAction;\n-import org.netbeans.api.visual.action.WidgetAction.State;\n-import org.netbeans.api.visual.widget.Widget;\n-\n-\/**\n- *\n- * @author Thomas Wuerthinger\n- *\/\n-public class MouseOverAction extends WidgetAction.Adapter {\n-\n-    private long eventID = Integer.MIN_VALUE;\n-    private HoverProvider provider;\n-\n-    public MouseOverAction(HoverProvider provider) {\n-        this.provider = provider;\n-    }\n-\n-    @Override\n-    public State mouseMoved(Widget widget, WidgetMouseEvent event) {\n-        long id = event.getEventID();\n-        if (id != eventID) {\n-            eventID = id;\n-            provider.widgetHovered(widget);\n-        }\n-        return State.REJECTED;\n-    }\n-\n-    @Override\n-    public State mouseExited(Widget widget, WidgetMouseEvent event) {\n-        provider.widgetHovered(null);\n-        return State.REJECTED;\n-    }\n-}\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/actions\/MouseOverAction.java","additions":0,"deletions":59,"binary":false,"changes":59,"status":"deleted"},{"patch":"@@ -31,1 +31,4 @@\n-import org.openide.util.*;\n+import org.openide.util.HelpCtx;\n+import org.openide.util.ImageUtilities;\n+import org.openide.util.Lookup;\n+import org.openide.util.NbBundle;\n@@ -98,0 +101,5 @@\n+\n+    @Override\n+    protected boolean asynchronous() {\n+        return false;\n+    }\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/actions\/NextDiagramAction.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -31,1 +31,4 @@\n-import org.openide.util.*;\n+import org.openide.util.HelpCtx;\n+import org.openide.util.ImageUtilities;\n+import org.openide.util.Lookup;\n+import org.openide.util.NbBundle;\n@@ -98,0 +101,5 @@\n+\n+    @Override\n+    protected boolean asynchronous() {\n+        return false;\n+    }\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/actions\/PrevDiagramAction.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -27,2 +27,1 @@\n-import java.awt.event.InputEvent;\n-import java.awt.event.KeyEvent;\n+import java.util.HashSet;\n@@ -30,1 +29,0 @@\n-import javax.swing.KeyStroke;\n@@ -32,1 +30,0 @@\n-import org.openide.util.actions.CallableSystemAction;\n@@ -34,0 +31,1 @@\n+import org.openide.util.actions.CallableSystemAction;\n@@ -45,1 +43,1 @@\n-            editor.showAll();\n+            editor.getModel().setHiddenNodes(new HashSet<Integer>());\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/actions\/ShowAllAction.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -31,1 +31,4 @@\n-import org.openide.util.*;\n+import org.openide.util.HelpCtx;\n+import org.openide.util.ImageUtilities;\n+import org.openide.util.Lookup;\n+import org.openide.util.NbBundle;\n@@ -95,0 +98,5 @@\n+\n+    @Override\n+    protected boolean asynchronous() {\n+        return false;\n+    }\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/actions\/ShrinkDiffAction.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -27,2 +27,0 @@\n-import java.awt.Event;\n-import java.awt.event.KeyEvent;\n@@ -30,1 +28,0 @@\n-import javax.swing.KeyStroke;\n@@ -32,1 +29,0 @@\n-import org.openide.util.actions.CallableSystemAction;\n@@ -34,0 +30,1 @@\n+import org.openide.util.actions.CallableSystemAction;\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/actions\/ZoomInAction.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -27,2 +27,0 @@\n-import java.awt.Event;\n-import java.awt.event.KeyEvent;\n@@ -30,1 +28,0 @@\n-import javax.swing.KeyStroke;\n@@ -32,1 +29,0 @@\n-import org.openide.util.actions.CallableSystemAction;\n@@ -34,0 +30,1 @@\n+import org.openide.util.actions.CallableSystemAction;\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/actions\/ZoomOutAction.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -28,6 +28,1 @@\n-import java.awt.BasicStroke;\n-import java.awt.Color;\n-import java.awt.Font;\n-import java.awt.Graphics2D;\n-import java.awt.Rectangle;\n-import java.awt.Stroke;\n+import java.awt.*;\n@@ -44,1 +39,0 @@\n-    public static final int BORDER = 20;\n@@ -49,1 +43,0 @@\n-    private Diagram diagram;\n@@ -54,1 +47,0 @@\n-        this.diagram = d;\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/widgets\/BlockWidget.java","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-import com.sun.hotspot.igv.data.InputGraph;\n@@ -28,1 +27,1 @@\n-import com.sun.hotspot.igv.data.services.GraphViewer;\n+import com.sun.hotspot.igv.graph.Diagram;\n@@ -36,1 +35,0 @@\n-import java.awt.event.ActionEvent;\n@@ -40,1 +38,0 @@\n-import javax.swing.AbstractAction;\n@@ -60,1 +57,0 @@\n-import org.openide.util.Lookup;\n@@ -71,2 +67,0 @@\n-    private Widget leftWidget;\n-    private Widget rightWidget;\n@@ -147,1 +141,1 @@\n-            lw.setFont(figure.getDiagram().getFont());\n+            lw.setFont(Diagram.FONT);\n@@ -187,8 +181,0 @@\n-    public Widget getLeftWidget() {\n-        return leftWidget;\n-    }\n-\n-    public Widget getRightWidget() {\n-        return rightWidget;\n-    }\n-\n@@ -199,1 +185,1 @@\n-        Font font = this.figure.getDiagram().getFont();\n+        Font font = Diagram.FONT;\n@@ -202,1 +188,1 @@\n-            font = this.figure.getDiagram().getBoldFont();\n+            font = Diagram.BOLD_FONT;\n@@ -289,21 +275,0 @@\n-        if (getFigure().getSubgraphs() != null) {\n-            menu.addSeparator();\n-            JMenu subgraphs = new JMenu(\"Subgraphs\");\n-            menu.add(subgraphs);\n-\n-            final GraphViewer viewer = Lookup.getDefault().lookup(GraphViewer.class);\n-            for (final InputGraph subgraph : getFigure().getSubgraphs()) {\n-                Action a = new AbstractAction() {\n-\n-                    @Override\n-                    public void actionPerformed(ActionEvent e) {\n-                        viewer.view(subgraph, true);\n-                    }\n-                };\n-\n-                a.setEnabled(true);\n-                a.putValue(Action.NAME, subgraph.getName());\n-                subgraphs.add(a);\n-            }\n-        }\n-\n@@ -386,1 +351,0 @@\n-\n@@ -388,3 +352,3 @@\n-            final Set<Integer> hiddenNodes = new HashSet<>(diagramScene.getModel().getGraphToView().getGroup().getAllNodes());\n-            hiddenNodes.removeAll(this.getFigure().getSource().getSourceNodesAsSet());\n-            this.diagramScene.getModel().showNot(hiddenNodes);\n+            final Set<Integer> hiddenNodes = new HashSet<>(diagramScene.getModel().getGroup().getAllNodes());\n+            hiddenNodes.remove(this.getFigure().getInputNode().getId());\n+            this.diagramScene.getModel().setHiddenNodes(hiddenNodes);\n@@ -392,1 +356,0 @@\n-\n@@ -394,2 +357,2 @@\n-            hiddenNodes.removeAll(this.getFigure().getSource().getSourceNodesAsSet());\n-            this.diagramScene.getModel().showNot(hiddenNodes);\n+            hiddenNodes.remove(this.getFigure().getInputNode().getId());\n+            this.diagramScene.getModel().setHiddenNodes(hiddenNodes);\n@@ -398,2 +361,2 @@\n-            hiddenNodes.addAll(this.getFigure().getSource().getSourceNodesAsSet());\n-            this.diagramScene.getModel().showNot(hiddenNodes);\n+            hiddenNodes.add(this.getFigure().getInputNode().getId());\n+            this.diagramScene.getModel().setHiddenNodes(hiddenNodes);\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/widgets\/FigureWidget.java","additions":11,"deletions":48,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -61,11 +61,0 @@\n-\/*\n-    protected Point calculateRelativeLocation() {\n-        if (getFigureWidget().getBounds() == null) {\n-            return new Point(0, 0);\n-        }\n-\n-        double x = 0;\n-        List<InputSlot> slots = inputSlot.getFigure().getInputSlots();\n-        assert slots.contains(inputSlot);\n-        return new Point((int) x, (int) (calculateRelativeY(slots.size(), slots.indexOf(inputSlot))));\n-    }*\/\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/widgets\/InputSlotWidget.java","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+import com.sun.hotspot.igv.graph.Block;\n@@ -29,1 +30,0 @@\n-import com.sun.hotspot.igv.graph.Block;\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/widgets\/LineWidget.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+import com.sun.hotspot.igv.graph.Diagram;\n@@ -31,6 +32,1 @@\n-import java.awt.BasicStroke;\n-import java.awt.Color;\n-import java.awt.Font;\n-import java.awt.Graphics2D;\n-import java.awt.Point;\n-import java.awt.Rectangle;\n+import java.awt.*;\n@@ -38,0 +34,1 @@\n+import java.util.Collections;\n@@ -108,1 +105,1 @@\n-            Font font = this.getSlot().getFigure().getDiagram().getSlotFont();\n+            Font font = Diagram.SLOT_FONT;\n@@ -173,1 +170,1 @@\n-            hiddenNodes = new HashSet<>(diagramScene.getModel().getGraphToView().getGroup().getAllNodes());\n+            hiddenNodes = new HashSet<>(diagramScene.getModel().getGroup().getAllNodes());\n@@ -177,1 +174,1 @@\n-        for (Figure f : diagramScene.getModel().getDiagramToView().getFigures()) {\n+        for (Figure f : diagramScene.getModel().getDiagram().getFigures()) {\n@@ -179,1 +176,1 @@\n-                if (DiagramScene.doesIntersect(s.getSource().getSourceNodesAsSet(), slot.getSource().getSourceNodesAsSet())) {\n+                if (!Collections.disjoint(s.getSource().getSourceNodesAsSet(), slot.getSource().getSourceNodesAsSet())) {\n@@ -181,1 +178,1 @@\n-                    hiddenNodes.removeAll(f.getSource().getSourceNodesAsSet());\n+                    hiddenNodes.remove(f.getInputNode().getId());\n@@ -187,1 +184,1 @@\n-            this.diagramScene.getModel().showNot(hiddenNodes);\n+            this.diagramScene.getModel().setHiddenNodes(hiddenNodes);\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/widgets\/SlotWidget.java","additions":9,"deletions":12,"binary":false,"changes":21,"status":"modified"},{"filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/resources\/com\/sun\/hotspot\/igv\/view\/images\/hideDuplicates.png","binary":true,"status":"deleted"}]}