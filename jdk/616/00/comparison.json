{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,4 +55,0 @@\n-    final WeakCleanable<?> weakCleanableList;\n-\n-    final SoftCleanable<?> softCleanableList;\n-\n@@ -90,2 +86,0 @@\n-        weakCleanableList = new WeakCleanableRef();\n-        softCleanableList = new SoftCleanableRef();\n@@ -138,3 +132,1 @@\n-        while (!phantomCleanableList.isListEmpty() ||\n-                !weakCleanableList.isListEmpty() ||\n-                !softCleanableList.isListEmpty()) {\n+        while (!phantomCleanableList.isListEmpty()) {\n@@ -210,103 +202,0 @@\n-    \/**\n-     * Perform cleaning on an unreachable WeakReference.\n-     *\/\n-    public static final class WeakCleanableRef extends WeakCleanable<Object> {\n-        private final Runnable action;\n-\n-        \/**\n-         * Constructor for a weak cleanable reference.\n-         * @param obj the object to monitor\n-         * @param cleaner the cleaner\n-         * @param action the action Runnable\n-         *\/\n-        WeakCleanableRef(Object obj, Cleaner cleaner, Runnable action) {\n-            super(obj, cleaner);\n-            this.action = action;\n-        }\n-\n-        \/**\n-         * Constructor used only for root of weak cleanable list.\n-         *\/\n-        WeakCleanableRef() {\n-            super();\n-            this.action = null;\n-        }\n-\n-        @Override\n-        protected void performCleanup() {\n-            action.run();\n-        }\n-\n-        \/**\n-         * Prevent access to referent even when it is still alive.\n-         *\n-         * @throws UnsupportedOperationException always\n-         *\/\n-        @Override\n-        public Object get() {\n-            throw new UnsupportedOperationException(\"get\");\n-        }\n-\n-        \/**\n-         * Direct clearing of the referent is not supported.\n-         *\n-         * @throws UnsupportedOperationException always\n-         *\/\n-        @Override\n-        public void clear() {\n-            throw new UnsupportedOperationException(\"clear\");\n-        }\n-    }\n-\n-    \/**\n-     * Perform cleaning on an unreachable SoftReference.\n-     *\/\n-    public static final class SoftCleanableRef extends SoftCleanable<Object> {\n-        private final Runnable action;\n-\n-        \/**\n-         * Constructor for a soft cleanable reference.\n-         * @param obj the object to monitor\n-         * @param cleaner the cleaner\n-         * @param action the action Runnable\n-         *\/\n-        SoftCleanableRef(Object obj, Cleaner cleaner, Runnable action) {\n-            super(obj, cleaner);\n-            this.action = action;\n-        }\n-\n-        \/**\n-         * Constructor used only for root of soft cleanable list.\n-         *\/\n-        SoftCleanableRef() {\n-            super();\n-            this.action = null;\n-        }\n-\n-        @Override\n-        protected void performCleanup() {\n-            action.run();\n-        }\n-\n-        \/**\n-         * Prevent access to referent even when it is still alive.\n-         *\n-         * @throws UnsupportedOperationException always\n-         *\/\n-        @Override\n-        public Object get() {\n-            throw new UnsupportedOperationException(\"get\");\n-        }\n-\n-        \/**\n-         * Direct clearing of the referent is not supported.\n-         *\n-         * @throws UnsupportedOperationException always\n-         *\/\n-        @Override\n-        public void clear() {\n-            throw new UnsupportedOperationException(\"clear\");\n-        }\n-\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/ref\/CleanerImpl.java","additions":2,"deletions":113,"binary":false,"changes":115,"status":"modified"},{"patch":"@@ -1,179 +0,0 @@\n-\/*\n- * Copyright (c) 2015, 2016, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.internal.ref;\n-\n-import java.lang.ref.Cleaner;\n-import java.lang.ref.Reference;\n-import java.lang.ref.SoftReference;\n-import java.util.Objects;\n-\n-\/**\n- * SoftCleanable subclasses efficiently encapsulate cleanup state and\n- * the cleaning action.\n- * Subclasses implement the abstract {@link #performCleanup()}  method\n- * to provide the cleaning action.\n- * When constructed, the object reference and the {@link Cleaner.Cleanable Cleanable}\n- * are registered with the {@link Cleaner}.\n- * The Cleaner invokes {@link Cleaner.Cleanable#clean() clean} after the\n- * referent becomes softly reachable.\n- *\/\n-public abstract class SoftCleanable<T> extends SoftReference<T>\n-        implements Cleaner.Cleanable {\n-\n-    \/**\n-     * Links to previous and next in a doubly-linked list.\n-     *\/\n-    SoftCleanable<?> prev = this, next = this;\n-\n-    \/**\n-     * The list of SoftCleanable; synchronizes insert and remove.\n-     *\/\n-    private final SoftCleanable<?> list;\n-\n-    \/**\n-     * Constructs new {@code SoftCleanableReference} with\n-     * {@code non-null referent} and {@code non-null cleaner}.\n-     * The {@code cleaner} is not retained by this reference; it is only used\n-     * to register the newly constructed {@link Cleaner.Cleanable Cleanable}.\n-     *\n-     * @param referent the referent to track\n-     * @param cleaner  the {@code Cleaner} to register with\n-     *\/\n-    public SoftCleanable(T referent, Cleaner cleaner) {\n-        super(Objects.requireNonNull(referent), CleanerImpl.getCleanerImpl(cleaner).queue);\n-        list = CleanerImpl.getCleanerImpl(cleaner).softCleanableList;\n-        insert();\n-\n-        \/\/ Ensure referent and cleaner remain accessible\n-        Reference.reachabilityFence(referent);\n-        Reference.reachabilityFence(cleaner);\n-    }\n-\n-    \/**\n-     * Construct a new root of the list; not inserted.\n-     *\/\n-    SoftCleanable() {\n-        super(null, null);\n-        this.list = this;\n-    }\n-\n-    \/**\n-     * Insert this SoftCleanableReference after the list head.\n-     *\/\n-    private void insert() {\n-        synchronized (list) {\n-            prev = list;\n-            next = list.next;\n-            next.prev = this;\n-            list.next = this;\n-        }\n-    }\n-\n-    \/**\n-     * Remove this SoftCleanableReference from the list.\n-     *\n-     * @return true if Cleanable was removed or false if not because\n-     * it had already been removed before\n-     *\/\n-    private boolean remove() {\n-        synchronized (list) {\n-            if (next != this) {\n-                next.prev = prev;\n-                prev.next = next;\n-                prev = this;\n-                next = this;\n-                return true;\n-            }\n-            return false;\n-        }\n-    }\n-\n-    \/**\n-     * Returns true if the list's next reference refers to itself.\n-     *\n-     * @return true if the list is empty\n-     *\/\n-    boolean isListEmpty() {\n-        synchronized (list) {\n-            return list == list.next;\n-        }\n-    }\n-\n-    \/**\n-     * Unregister this SoftCleanable reference and invoke {@link #performCleanup()},\n-     * ensuring at-most-once semantics.\n-     *\/\n-    @Override\n-    public final void clean() {\n-        if (remove()) {\n-            super.clear();\n-            performCleanup();\n-        }\n-    }\n-\n-    \/**\n-     * Unregister this SoftCleanable and clear the reference.\n-     * Due to inherent concurrency, {@link #performCleanup()} may still be invoked.\n-     *\/\n-    @Override\n-    public void clear() {\n-        if (remove()) {\n-            super.clear();\n-        }\n-    }\n-\n-    \/**\n-     * The {@code performCleanup} abstract method is overridden\n-     * to implement the cleaning logic.\n-     * The {@code performCleanup} method should not be called except\n-     * by the {@link #clean} method which ensures at most once semantics.\n-     *\/\n-    protected abstract void performCleanup();\n-\n-    \/**\n-     * This method always throws {@link UnsupportedOperationException}.\n-     * Enqueuing details of {@link Cleaner.Cleanable}\n-     * are a private implementation detail.\n-     *\n-     * @throws UnsupportedOperationException always\n-     *\/\n-    @Override\n-    public final boolean isEnqueued() {\n-        throw new UnsupportedOperationException(\"isEnqueued\");\n-    }\n-\n-    \/**\n-     * This method always throws {@link UnsupportedOperationException}.\n-     * Enqueuing details of {@link Cleaner.Cleanable}\n-     * are a private implementation detail.\n-     *\n-     * @throws UnsupportedOperationException always\n-     *\/\n-    @Override\n-    public final boolean enqueue() {\n-        throw new UnsupportedOperationException(\"enqueue\");\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/ref\/SoftCleanable.java","additions":0,"deletions":179,"binary":false,"changes":179,"status":"deleted"},{"patch":"@@ -1,180 +0,0 @@\n-\/*\n- * Copyright (c) 2015, 2016, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.internal.ref;\n-\n-import java.lang.ref.Cleaner;\n-import java.lang.ref.Reference;\n-import java.lang.ref.WeakReference;\n-import java.util.Objects;\n-\n-\/**\n- * WeakCleanable subclasses efficiently encapsulate cleanup state and\n- * the cleaning action.\n- * Subclasses implement the abstract {@link #performCleanup()}  method\n- * to provide the cleaning action.\n- * When constructed, the object reference and the {@link Cleaner.Cleanable Cleanable}\n- * are registered with the {@link Cleaner}.\n- * The Cleaner invokes {@link Cleaner.Cleanable#clean() clean} after the\n- * referent becomes weakly reachable.\n- *\/\n-public abstract class WeakCleanable<T> extends WeakReference<T>\n-        implements Cleaner.Cleanable {\n-\n-    \/**\n-     * Links to previous and next in a doubly-linked list.\n-     *\/\n-    WeakCleanable<?> prev = this, next = this;\n-\n-    \/**\n-     * The list of WeakCleanable; synchronizes insert and remove.\n-     *\/\n-    private final WeakCleanable<?> list;\n-\n-    \/**\n-     * Constructs new {@code WeakCleanableReference} with\n-     * {@code non-null referent} and {@code non-null cleaner}.\n-     * The {@code cleaner} is not retained by this reference; it is only used\n-     * to register the newly constructed {@link Cleaner.Cleanable Cleanable}.\n-     *\n-     * @param referent the referent to track\n-     * @param cleaner  the {@code Cleaner} to register new reference with\n-     *\/\n-    public WeakCleanable(T referent, Cleaner cleaner) {\n-        super(Objects.requireNonNull(referent), CleanerImpl.getCleanerImpl(cleaner).queue);\n-        list = CleanerImpl.getCleanerImpl(cleaner).weakCleanableList;\n-        insert();\n-\n-        \/\/ Ensure referent and cleaner remain accessible\n-        Reference.reachabilityFence(referent);\n-        Reference.reachabilityFence(cleaner);\n-\n-    }\n-\n-    \/**\n-     * Construct a new root of the list; not inserted.\n-     *\/\n-    WeakCleanable() {\n-        super(null, null);\n-        this.list = this;\n-    }\n-\n-    \/**\n-     * Insert this WeakCleanableReference after the list head.\n-     *\/\n-    private void insert() {\n-        synchronized (list) {\n-            prev = list;\n-            next = list.next;\n-            next.prev = this;\n-            list.next = this;\n-        }\n-    }\n-\n-    \/**\n-     * Remove this WeakCleanableReference from the list.\n-     *\n-     * @return true if Cleanable was removed or false if not because\n-     * it had already been removed before\n-     *\/\n-    private boolean remove() {\n-        synchronized (list) {\n-            if (next != this) {\n-                next.prev = prev;\n-                prev.next = next;\n-                prev = this;\n-                next = this;\n-                return true;\n-            }\n-            return false;\n-        }\n-    }\n-\n-    \/**\n-     * Returns true if the list's next reference refers to itself.\n-     *\n-     * @return true if the list is empty\n-     *\/\n-    boolean isListEmpty() {\n-        synchronized (list) {\n-            return list == list.next;\n-        }\n-    }\n-\n-    \/**\n-     * Unregister this WeakCleanable reference and invoke {@link #performCleanup()},\n-     * ensuring at-most-once semantics.\n-     *\/\n-    @Override\n-    public final void clean() {\n-        if (remove()) {\n-            super.clear();\n-            performCleanup();\n-        }\n-    }\n-\n-    \/**\n-     * Unregister this WeakCleanable and clear the reference.\n-     * Due to inherent concurrency, {@link #performCleanup()} may still be invoked.\n-     *\/\n-    @Override\n-    public void clear() {\n-        if (remove()) {\n-            super.clear();\n-        }\n-    }\n-\n-    \/**\n-     * The {@code performCleanup} abstract method is overridden\n-     * to implement the cleaning logic.\n-     * The {@code performCleanup} method should not be called except\n-     * by the {@link #clean} method which ensures at most once semantics.\n-     *\/\n-    protected abstract void performCleanup();\n-\n-    \/**\n-     * This method always throws {@link UnsupportedOperationException}.\n-     * Enqueuing details of {@link Cleaner.Cleanable}\n-     * are a private implementation detail.\n-     *\n-     * @throws UnsupportedOperationException always\n-     *\/\n-    @Override\n-    public final boolean isEnqueued() {\n-        throw new UnsupportedOperationException(\"isEnqueued\");\n-    }\n-\n-    \/**\n-     * This method always throws {@link UnsupportedOperationException}.\n-     * Enqueuing details of {@link Cleaner.Cleanable}\n-     * are a private implementation detail.\n-     *\n-     * @throws UnsupportedOperationException always\n-     *\/\n-    @Override\n-    public final boolean enqueue() {\n-        throw new UnsupportedOperationException(\"enqueue\");\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/ref\/WeakCleanable.java","additions":0,"deletions":180,"binary":false,"changes":180,"status":"deleted"},{"patch":"@@ -38,2 +38,0 @@\n-import jdk.internal.ref.WeakCleanable;\n-import jdk.internal.ref.SoftCleanable;\n@@ -155,4 +153,0 @@\n-        generateCases(() -> setupWeakSubclass(cleaner, null),\n-                runnables.length, runnables);\n-        generateCases(() -> setupSoftSubclass(cleaner, null),\n-                runnables.length, runnables);\n@@ -165,4 +159,0 @@\n-        generateCases(() -> setupWeakSubclassException(cleaner, null),\n-                1, c -> c.clearRef());\n-        generateCases(() -> setupSoftSubclassException(cleaner, null),\n-                1, c -> c.clearRef());\n@@ -349,41 +339,0 @@\n-    \/**\n-     * Create a CleanableCase for a WeakReference.\n-     * @param cleaner the cleaner to use\n-     * @param obj an object or null to create a new Object\n-     * @return a new CleanableCase preset with the object, cleanup, and semaphore\n-     *\/\n-    static CleanableCase setupWeakSubclass(Cleaner cleaner, Object obj) {\n-        if (obj == null) {\n-            obj = new Object();\n-        }\n-        Semaphore s1 = new Semaphore(0);\n-\n-        Cleaner.Cleanable c1 = new WeakCleanable<Object>(obj, cleaner) {\n-            protected void performCleanup() {\n-                s1.release();\n-            }\n-        };\n-\n-        return new CleanableCase(new WeakReference<>(obj, null), c1, s1);\n-    }\n-\n-    \/**\n-     * Create a CleanableCase for a SoftReference.\n-     * @param cleaner the cleaner to use\n-     * @param obj an object or null to create a new Object\n-     * @return a new CleanableCase preset with the object, cleanup, and semaphore\n-     *\/\n-    static CleanableCase setupSoftSubclass(Cleaner cleaner, Object obj) {\n-        if (obj == null) {\n-            obj = new Object();\n-        }\n-        Semaphore s1 = new Semaphore(0);\n-\n-        Cleaner.Cleanable c1 = new SoftCleanable<Object>(obj, cleaner) {\n-            protected void performCleanup() {\n-                s1.release();\n-            }\n-        };\n-\n-        return new CleanableCase(new SoftReference<>(obj, null), c1, s1);\n-    }\n@@ -413,44 +362,0 @@\n-    \/**\n-     * Create a CleanableCase for a WeakReference.\n-     * @param cleaner the cleaner to use\n-     * @param obj an object or null to create a new Object\n-     * @return a new CleanableCase preset with the object, cleanup, and semaphore\n-     *\/\n-    static CleanableCase setupWeakSubclassException(Cleaner cleaner, Object obj) {\n-        if (obj == null) {\n-            obj = new Object();\n-        }\n-        Semaphore s1 = new Semaphore(0);\n-\n-        Cleaner.Cleanable c1 = new WeakCleanable<Object>(obj, cleaner) {\n-            protected void performCleanup() {\n-                s1.release();\n-                throw new RuntimeException(\"Exception thrown to cleaner thread\");\n-            }\n-        };\n-\n-        return new CleanableCase(new WeakReference<>(obj, null), c1, s1, true);\n-    }\n-\n-    \/**\n-     * Create a CleanableCase for a SoftReference.\n-     * @param cleaner the cleaner to use\n-     * @param obj an object or null to create a new Object\n-     * @return a new CleanableCase preset with the object, cleanup, and semaphore\n-     *\/\n-    static CleanableCase setupSoftSubclassException(Cleaner cleaner, Object obj) {\n-        if (obj == null) {\n-            obj = new Object();\n-        }\n-        Semaphore s1 = new Semaphore(0);\n-\n-        Cleaner.Cleanable c1 = new SoftCleanable<Object>(obj, cleaner) {\n-            protected void performCleanup() {\n-                s1.release();\n-                throw new RuntimeException(\"Exception thrown to cleaner thread\");\n-            }\n-        };\n-\n-        return new CleanableCase(new SoftReference<>(obj, null), c1, s1, true);\n-    }\n-\n@@ -614,68 +519,0 @@\n-\n-    \/**\n-     * Example using a Cleaner to remove WeakKey references from a Map.\n-     *\/\n-    @Test\n-    void testWeakKey() {\n-        ConcurrentHashMap<WeakKey<String>, String> map = new ConcurrentHashMap<>();\n-        Cleaner cleaner = Cleaner.create();\n-        String key = new String(\"foo\");  \/\/  ensure it is not interned\n-        String data = \"bar\";\n-\n-        map.put(new WeakKey<>(key, cleaner, map), data);\n-\n-        WeakKey<String> k2 = new WeakKey<>(key, cleaner, map);\n-\n-        Assert.assertEquals(map.get(k2), data, \"value should be found in the map\");\n-        key = null;\n-        System.gc();\n-        Assert.assertNotEquals(map.get(k2), data, \"value should not be found in the map\");\n-\n-        final long CYCLE_MAX = Utils.adjustTimeout(30L);\n-        for (int i = 1; map.size() > 0 && i < CYCLE_MAX; i++) {\n-            map.forEach( (k, v) -> System.out.printf(\"    k: %s, v: %s%n\", k, v));\n-            try {\n-                Thread.sleep(10L);\n-            } catch (InterruptedException ie) {}\n-        }\n-        Assert.assertEquals(map.size(), 0, \"Expected map to be empty;\");\n-        cleaner = null;\n-    }\n-\n-    \/**\n-     * Test sample class for WeakKeys in Map.\n-     * @param <K> A WeakKey of type K\n-     *\/\n-    class WeakKey<K> extends WeakReference<K> {\n-        private final int hash;\n-        private final ConcurrentHashMap<WeakKey<K>, ?> map;\n-        Cleaner.Cleanable cleanable;\n-\n-        public WeakKey(K key, Cleaner c, ConcurrentHashMap<WeakKey<K>, ?> map) {\n-            super(key);\n-            this.hash = key.hashCode();\n-            this.map = map;\n-            cleanable = new WeakCleanable<Object>(key, c) {\n-                protected void performCleanup() {\n-                    map.remove(WeakKey.this);\n-                }\n-            };\n-        }\n-        public int hashCode() { return hash; }\n-\n-        public boolean equals(Object obj) {\n-            if (obj == this) {\n-                return true;\n-            }\n-            if (!(obj instanceof WeakKey)) return false;\n-            K key = get();\n-            if (key == null) return obj == this;\n-            return key == ((WeakKey<?>)obj).get();\n-        }\n-\n-        public String toString() {\n-            return \"WeakKey:\" + Objects.toString(get() + \", cleanableRef: \" +\n-                    ((Reference)cleanable).get());\n-        }\n-    }\n-\n","filename":"test\/jdk\/java\/lang\/ref\/CleanerTest.java","additions":0,"deletions":163,"binary":false,"changes":163,"status":"modified"}]}