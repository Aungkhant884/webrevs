{"files":[{"patch":"@@ -43,0 +43,1 @@\n+#include \"utilities\/macros.hpp\"\n@@ -314,0 +315,3 @@\n+    \/\/ Adjust sender SP for callee, for proper stack walking.\n+    \/\/ Note: the caller canâ€™t be compiled as MH intrinsics always have native wrappers.\n+    __ addptr(LP64_ONLY(r13) NOT_LP64(rsi), Interpreter::stackElementSize);\n","filename":"src\/hotspot\/cpu\/x86\/methodHandles_x86.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -233,1 +233,34 @@\n-  return strcmp(name.get(), \"checkAsyncGetCallTraceCall\") == 0;\n+  if (strcmp(name.get(), \"checkAsyncGetCallTraceCall\") != 0) {\n+    fprintf(stderr, \"Name is not checkAsyncGetCallTraceCall: %s\\n\", name.get());\n+    return false;\n+  }\n+\n+  \/\/ AsyncGetCallTrace and GetStackTrace should return comparable frames\n+  \/\/ so we obtain the frames using GetStackTrace and compare them.\n+\n+  jthread thread;\n+  jvmti->GetCurrentThread(&thread);\n+  jvmtiFrameInfo gstFrames[MAX_DEPTH];\n+  jint gstCount = 0;\n+\n+  jvmti->GetStackTrace(thread, 0, MAX_DEPTH, gstFrames, &gstCount);\n+\n+  if (gstCount != trace.num_frames) {\n+    fprintf(stderr, \"GetStackTrace and AsyncGetCallTrace return different number of frames: %d vs %d)\", gstCount, trace.num_frames);\n+    return false;\n+  }\n+\n+  for (int i = 0; i < trace.num_frames; ++i) {\n+    if (trace.frames[i].lineno == -3) {\n+      if (gstFrames[i].location != -1) {\n+        fprintf(stderr, \"%d: ASGCT found native frame but GST did not\\n\", i);\n+        return false;\n+      }\n+    } else {\n+      if (gstFrames[i].method != trace.frames[i].method_id) {\n+        fprintf(stderr, \"%d: method_id mismatch: %p vs %p\\n\", i, gstFrames[i].method, trace.frames[i].method_id);\n+        return false;\n+      }\n+    }\n+  }\n+  return true;\n","filename":"test\/hotspot\/jtreg\/serviceability\/AsyncGetCallTrace\/libAsyncGetCallTraceTest.cpp","additions":34,"deletions":1,"binary":false,"changes":35,"status":"modified"}]}