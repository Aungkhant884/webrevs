{"files":[{"patch":"@@ -38,0 +38,1 @@\n+#include \"classfile\/javaClasses.inline.hpp\"\n@@ -51,0 +52,1 @@\n+#include \"interpreter\/bytecodeStream.hpp\"\n@@ -67,0 +69,1 @@\n+#include \"runtime\/fieldDescriptor.inline.hpp\"\n@@ -169,0 +172,4 @@\n+\n+  _dyno_klasses = NULL;\n+  _dyno_locs = NULL;\n+  _dyno_name[0] = '\\0';\n@@ -171,0 +178,61 @@\n+\/\/ Record components of a location descriptor string.  Components are appended by the constructor and\n+\/\/ removed by the destructor, like a stack, so scope matters.  These location descriptors are used to\n+\/\/ locate dynamic classes, and terminate at a Method* or oop field associated with dynamic\/hidden class.\n+\/\/\n+\/\/ Example use:\n+\/\/\n+\/\/ {\n+\/\/   RecordLocation fp(this, \"field1\");\n+\/\/   \/\/ location: \"field1\"\n+\/\/   { RecordLocation fp(this, \" field2\"); \/\/ location: \"field1 field2\" }\n+\/\/   \/\/ location: \"field1\"\n+\/\/   { RecordLocation fp(this, \" field3\"); \/\/ location: \"field1 field3\" }\n+\/\/   \/\/ location: \"field1\"\n+\/\/ }\n+\/\/ \/\/ location: \"\"\n+\/\/\n+\/\/ Examples of actual locations\n+\/\/ @bci compiler\/ciReplay\/CiReplayBase$TestMain test (I)V 1 <appendix> argL0 ;\n+\/\/ \/\/ resolve invokedynamic at bci 1 of TestMain.test, then read field \"argL0\" from appendix\n+\/\/ @bci compiler\/ciReplay\/CiReplayBase$TestMain main ([Ljava\/lang\/String;)V 0 <appendix> form vmentry <vmtarget> ;\n+\/\/ \/\/ resolve invokedynamic at bci 0 of TestMain.main, then read field \"form.vmentry.method.vmtarget\" from appendix\n+\/\/ @cpi compiler\/ciReplay\/CiReplayBase$TestMain 56 form vmentry <vmtarget> ;\n+\/\/ \/\/ resolve MethodHandle at cpi 56 of TestMain, then read field \"vmentry.method.vmtarget\" from resolved MethodHandle\n+class RecordLocation {\n+private:\n+  char* end;\n+\n+  ATTRIBUTE_PRINTF(3, 4)\n+  void push(ciEnv* ci, const char* fmt, ...) {\n+    va_list args;\n+    va_start(args, fmt);\n+    push_va(ci, fmt, args);\n+    va_end(args);\n+  }\n+\n+public:\n+  ATTRIBUTE_PRINTF(3, 0)\n+  void push_va(ciEnv* ci, const char* fmt, va_list args) {\n+    char *e = ci->_dyno_name + strlen(ci->_dyno_name);\n+    char *m = ci->_dyno_name + ARRAY_SIZE(ci->_dyno_name) - 1;\n+    os::vsnprintf(e, m - e, fmt, args);\n+    assert(strlen(ci->_dyno_name) < (ARRAY_SIZE(ci->_dyno_name) - 1), \"overflow\");\n+  }\n+\n+  \/\/ append a new component\n+  ATTRIBUTE_PRINTF(3, 4)\n+  RecordLocation(ciEnv* ci, const char* fmt, ...) {\n+    end = ci->_dyno_name + strlen(ci->_dyno_name);\n+    va_list args;\n+    va_start(args, fmt);\n+    push(ci, \" \");\n+    push_va(ci, fmt, args);\n+    va_end(args);\n+  }\n+\n+  \/\/ reset to previous state\n+  ~RecordLocation() {\n+    *end = '\\0';\n+  }\n+};\n+\n@@ -225,0 +293,3 @@\n+\n+  _dyno_klasses = NULL;\n+  _dyno_locs = NULL;\n@@ -1193,1 +1264,114 @@\n-\/\/ ciEnv::dump_replay_data*\n+\/\/ Replay support\n+\n+\n+\/\/ Lookup location descriptor for the class, if any.\n+\/\/ Returns false if not found.\n+bool ciEnv::dyno_loc(const InstanceKlass* ik, const char *&loc) const {\n+  bool found = false;\n+  int pos = _dyno_klasses->find_sorted<const InstanceKlass*, klass_compare>(ik, found);\n+  if (!found) {\n+    return false;\n+  }\n+  loc = _dyno_locs->at(pos);\n+  return found;\n+}\n+\n+\/\/ Associate the current location descriptor with the given class and record for later lookup.\n+void ciEnv::set_dyno_loc(const InstanceKlass* ik) {\n+  const char *loc = os::strdup(_dyno_name);\n+  bool found = false;\n+  int pos = _dyno_klasses->find_sorted<const InstanceKlass*, klass_compare>(ik, found);\n+  if (found) {\n+    _dyno_locs->at_put(pos, loc);\n+  } else {\n+    _dyno_klasses->insert_before(pos, ik);\n+    _dyno_locs->insert_before(pos, loc);\n+  }\n+}\n+\n+\/\/ Associate the current location descriptor with the given class and record for later lookup.\n+\/\/ If it turns out that there are multiple locations for the given class, that conflict should\n+\/\/ be handled here.  Currently we choose the first location found.\n+void ciEnv::record_best_dyno_loc(const InstanceKlass* ik) {\n+  if (!ik->is_hidden()) {\n+    return;\n+  }\n+  const char *loc0;\n+  if (dyno_loc(ik, loc0)) {\n+    \/\/ TODO: found multiple references, see if we can improve\n+    if (Verbose) {\n+      tty->print_cr(\"existing call site @ %s for %s\",\n+                     loc0, ik->external_name());\n+    }\n+  } else {\n+    set_dyno_loc(ik);\n+  }\n+}\n+\n+\/\/ Look up the location descriptor for the given class and print it to the output stream.\n+bool ciEnv::print_dyno_loc(outputStream* out, const InstanceKlass* ik) const {\n+  const char *loc;\n+  if (dyno_loc(ik, loc)) {\n+    out->print(\"%s\", loc);\n+    return true;\n+  } else {\n+    return false;\n+  }\n+}\n+\n+\/\/ Look up the location descriptor for the given class and return it as a string.\n+\/\/ Returns NULL if no location is found.\n+const char *ciEnv::dyno_name(const InstanceKlass* ik) const {\n+  if (ik->is_hidden()) {\n+    stringStream ss;\n+    if (print_dyno_loc(&ss, ik)) {\n+      ss.print(\" ;\"); \/\/ add terminator\n+      const char* call_site = ss.as_string();\n+      return call_site;\n+    }\n+  }\n+  return NULL;\n+}\n+\n+\/\/ Look up the location descriptor for the given class and return it as a string.\n+\/\/ Returns the class name as a fallback if no location is found.\n+const char *ciEnv::replay_name(ciKlass* k) const {\n+  if (k->is_instance_klass()) {\n+    return replay_name(k->as_instance_klass()->get_instanceKlass());\n+  }\n+  return k->name()->as_quoted_ascii();\n+}\n+\n+\/\/ Look up the location descriptor for the given class and return it as a string.\n+\/\/ Returns the class name as a fallback if no location is found.\n+const char *ciEnv::replay_name(const InstanceKlass* ik) const {\n+  const char* name = dyno_name(ik);\n+  if (name != NULL) {\n+      return name;\n+  }\n+  return ik->name()->as_quoted_ascii();\n+}\n+\n+\/\/ Process a java.lang.invoke.MemberName object and record any dynamic locations.\n+void ciEnv::record_member(Thread* thread, oop member) {\n+  assert(java_lang_invoke_MemberName::is_instance(member), \"!\");\n+  \/\/ Check MemberName.clazz field\n+  oop clazz = java_lang_invoke_MemberName::clazz(member);\n+  if (clazz->klass()->is_instance_klass()) {\n+    RecordLocation fp(this, \"clazz\");\n+    InstanceKlass* ik = InstanceKlass::cast(clazz->klass());\n+    record_best_dyno_loc(ik);\n+  }\n+  \/\/ Check MemberName.method.vmtarget field\n+  Method* vmtarget = java_lang_invoke_MemberName::vmtarget(member);\n+  if (vmtarget != NULL) {\n+    RecordLocation fp2(this, \"<vmtarget>\");\n+    InstanceKlass* ik = vmtarget->method_holder();\n+    record_best_dyno_loc(ik);\n+  }\n+}\n+\n+\/\/ Read an object field.  Lookup is done by name only.\n+static inline oop obj_field(oop obj, const char* name) {\n+    return ciReplay::obj_field(obj, name);\n+}\n@@ -1195,2 +1379,219 @@\n-\/\/ Don't change thread state and acquire any locks.\n-\/\/ Safe to call from VM error reporter.\n+\/\/ Process a java.lang.invoke.LambdaForm object and record any dynamic locations.\n+void ciEnv::record_lambdaform(Thread* thread, oop form) {\n+  assert(java_lang_invoke_LambdaForm::is_instance(form), \"!\");\n+\n+  {\n+    \/\/ Check LambdaForm.vmentry field\n+    oop member = java_lang_invoke_LambdaForm::vmentry(form);\n+    RecordLocation fp0(this, \"vmentry\");\n+    record_member(thread, member);\n+  }\n+\n+  \/\/ Check LambdaForm.names array\n+  objArrayOop names = (objArrayOop)obj_field(form, \"names\");\n+  if (names != NULL) {\n+    RecordLocation lp0(this, \"names\");\n+    int len = names->length();\n+    for (int i = 0; i < len; ++i) {\n+      oop name = names->obj_at(i);\n+      RecordLocation lp1(this, \"%d\", i);\n+     \/\/ Check LambdaForm.names[i].function field\n+      RecordLocation lp2(this, \"function\");\n+      oop function = obj_field(name, \"function\");\n+      if (function != NULL) {\n+        \/\/ Check LambdaForm.names[i].function.member field\n+        oop member = obj_field(function, \"member\");\n+        if (member != NULL) {\n+          RecordLocation lp3(this, \"member\");\n+          record_member(thread, member);\n+        }\n+        \/\/ Check LambdaForm.names[i].function.resolvedHandle field\n+        oop mh = obj_field(function, \"resolvedHandle\");\n+        if (mh != NULL) {\n+          RecordLocation lp3(this, \"resolvedHandle\");\n+          record_mh(thread, mh);\n+        }\n+        \/\/ Check LambdaForm.names[i].function.invoker field\n+        oop invoker = obj_field(function, \"invoker\");\n+        if (invoker != NULL) {\n+          RecordLocation lp3(this, \"invoker\");\n+          record_mh(thread, invoker);\n+        }\n+      }\n+    }\n+  }\n+}\n+\n+\/\/ Process a java.lang.invoke.MethodHandle object and record any dynamic locations.\n+void ciEnv::record_mh(Thread* thread, oop mh) {\n+  {\n+    \/\/ Check MethodHandle.form field\n+    oop form = java_lang_invoke_MethodHandle::form(mh);\n+    RecordLocation fp(this, \"form\");\n+    record_lambdaform(thread, form);\n+  }\n+  \/\/ Check DirectMethodHandle.member field\n+  if (java_lang_invoke_DirectMethodHandle::is_instance(mh)) {\n+    oop member = java_lang_invoke_DirectMethodHandle::member(mh);\n+    RecordLocation fp(this, \"member\");\n+    record_member(thread, member);\n+  } else {\n+    \/\/ Check <MethodHandle subclass>.argL0 field\n+    \/\/ Probably BoundMethodHandle.Species_L, but we only care if the field exists\n+    oop arg = obj_field(mh, \"argL0\");\n+    if (arg != NULL) {\n+      RecordLocation fp(this, \"argL0\");\n+      if (arg->klass()->is_instance_klass()) {\n+        InstanceKlass* ik2 = InstanceKlass::cast(arg->klass());\n+        record_best_dyno_loc(ik2);\n+      }\n+    }\n+  }\n+}\n+\n+\/\/ Process an object found at an invokedynamic\/invokehandle call site and record any dynamic locations.\n+\/\/ Types currently supported are MethodHandle and CallSite.\n+\/\/ The object is typically the \"appendix\" object, or Bootstrap Method (BSM) object.\n+void ciEnv::record_call_site_obj(Thread* thread, const constantPoolHandle& pool, const Handle obj)\n+{\n+  if (obj.not_null()) {\n+    if (java_lang_invoke_MethodHandle::is_instance(obj())) {\n+        record_mh(thread, obj());\n+    } else if (java_lang_invoke_ConstantCallSite::is_instance(obj())) {\n+      oop target = java_lang_invoke_CallSite::target(obj());\n+      if (target->klass()->is_instance_klass()) {\n+        RecordLocation fp(this, \"target\");\n+        InstanceKlass* ik = InstanceKlass::cast(target->klass());\n+        record_best_dyno_loc(ik);\n+      }\n+    }\n+  }\n+}\n+\n+\/\/ Process an adapter Method* found at an invokedynamic\/invokehandle call site and record any dynamic locations.\n+void ciEnv::record_call_site_method(Thread* thread, const constantPoolHandle& pool, Method* adapter) {\n+  InstanceKlass* holder = adapter->method_holder();\n+  if (!holder->is_hidden()) {\n+    return;\n+  }\n+  RecordLocation fp(this, \"<adapter>\");\n+  record_best_dyno_loc(holder);\n+}\n+\n+\/\/ Process an invokedynamic call site and record any dynamic locations.\n+void ciEnv::process_invokedynamic(const constantPoolHandle &cp, int indy_index, JavaThread* thread) {\n+  ConstantPoolCacheEntry* cp_cache_entry = cp->invokedynamic_cp_cache_entry_at(indy_index);\n+  if (cp_cache_entry->is_resolved(Bytecodes::_invokedynamic)) {\n+    \/\/ process the adapter\n+    Method* adapter = cp_cache_entry->f1_as_method();\n+    record_call_site_method(thread, cp, adapter);\n+    \/\/ process the appendix\n+    Handle appendix(thread, cp_cache_entry->appendix_if_resolved(cp));\n+    {\n+      RecordLocation fp(this, \"<appendix>\");\n+      record_call_site_obj(thread, cp, appendix);\n+    }\n+    \/\/ process the BSM\n+    int pool_index = cp_cache_entry->constant_pool_index();\n+    BootstrapInfo bootstrap_specifier(cp, pool_index, indy_index);\n+    oop bsm_oop = cp->resolve_possibly_cached_constant_at(bootstrap_specifier.bsm_index(), thread);\n+    Handle bsm(thread, bsm_oop);\n+    {\n+      RecordLocation fp(this, \"<bsm>\");\n+      record_call_site_obj(thread, cp, bsm);\n+    }\n+  }\n+}\n+\n+\/\/ Process an invokehandle call site and record any dynamic locations.\n+void ciEnv::process_invokehandle(const constantPoolHandle &cp, int index, JavaThread* thread) {\n+  const int holder_index = cp->klass_ref_index_at(index);\n+  if (!cp->tag_at(holder_index).is_klass()) {\n+    return;  \/\/ not resolved\n+  }\n+  Klass* holder = ConstantPool::klass_at_if_loaded(cp, holder_index);\n+  Symbol* name = cp->name_ref_at(index);\n+  if (MethodHandles::is_signature_polymorphic_name(holder, name)) {\n+    ConstantPoolCacheEntry* cp_cache_entry = cp->cache()->entry_at(cp->decode_cpcache_index(index));\n+    if (cp_cache_entry->is_resolved(Bytecodes::_invokehandle)) {\n+      \/\/ process the adapter\n+      Method* adapter = cp_cache_entry->f1_as_method();\n+      Handle appendix(thread, cp_cache_entry->appendix_if_resolved(cp));\n+      record_call_site_method(thread, cp, adapter);\n+      \/\/ process the appendix\n+      {\n+        RecordLocation fp(this, \"<appendix>\");\n+        record_call_site_obj(thread, cp, appendix);\n+      }\n+    }\n+  }\n+}\n+\n+\/\/ Search the class hierarchy for dynamic classes reachable through dynamic call sites or\n+\/\/ constant pool entries and record for future lookup.\n+void ciEnv::find_dynamic_call_sites() {\n+  _dyno_klasses = new (arena()) GrowableArray<const InstanceKlass*>(arena(), 100, 0, NULL);\n+  _dyno_locs    = new (arena()) GrowableArray<const char *>(arena(), 100, 0, NULL);\n+\n+  \/\/ Iterate over the class hierarchy\n+  for (ClassHierarchyIterator iter(vmClasses::Object_klass()); !iter.done(); iter.next()) {\n+    Klass* sub = iter.klass();\n+    if (sub->is_instance_klass()) {\n+      InstanceKlass *isub = InstanceKlass::cast(sub);\n+      InstanceKlass* ik = isub;\n+      if (!ik->is_linked()) {\n+        continue;\n+      }\n+      if (ik->is_hidden()) {\n+        continue;\n+      }\n+      JavaThread* thread = JavaThread::current();\n+      const constantPoolHandle pool(thread, ik->constants());\n+\n+      \/\/ Look for invokedynamic\/invokehandle call sites\n+      for (int i = 0; i < ik->methods()->length(); ++i) {\n+        Method* m = ik->methods()->at(i);\n+\n+        BytecodeStream bcs(methodHandle(thread, m));\n+        while (!bcs.is_last_bytecode()) {\n+          Bytecodes::Code opcode = bcs.next();\n+          opcode = bcs.raw_code();\n+          switch (opcode) {\n+          case Bytecodes::_invokedynamic:\n+          case Bytecodes::_invokehandle: {\n+            RecordLocation fp(this, \"@bci %s %s %s %d\",\n+                         ik->name()->as_quoted_ascii(),\n+                         m->name()->as_quoted_ascii(), m->signature()->as_quoted_ascii(),\n+                         bcs.bci());\n+            if (opcode == Bytecodes::_invokedynamic) {\n+              int index = bcs.get_index_u4();\n+              process_invokedynamic(pool, index, thread);\n+            } else {\n+              assert(opcode == Bytecodes::_invokehandle, \"new switch label added?\");\n+              int cp_cache_index = bcs.get_index_u2_cpcache();\n+              process_invokehandle(pool, cp_cache_index, thread);\n+            }\n+            break;\n+          }\n+          default:\n+            break;\n+          }\n+        }\n+      }\n+\n+      \/\/ Look for MethodHandle contant pool entries\n+      RecordLocation fp(this, \"@cpi %s\", ik->name()->as_quoted_ascii());\n+      int len = pool->length();\n+      for (int i = 0; i < len; ++i) {\n+        if (pool->tag_at(i).is_method_handle()) {\n+          bool found_it;\n+          oop mh = pool->find_cached_constant_at(i, found_it, thread);\n+          if (mh != NULL) {\n+            RecordLocation fp(this, \"%d\", i);\n+            record_mh(thread, mh);\n+          }\n+        }\n+      }\n+    }\n+  }\n+}\n@@ -1204,5 +1605,3 @@\n-    out->print(\"compile %s %s %s %d %d\",\n-               method->klass_name()->as_quoted_ascii(),\n-               method->name()->as_quoted_ascii(),\n-               method->signature()->as_quoted_ascii(),\n-               entry_bci, comp_level);\n+    out->print(\"compile \");\n+    get_method(method)->dump_name_as_ascii(out);\n+    out->print(\" %d %d\", entry_bci, comp_level);\n@@ -1226,1 +1625,5 @@\n-void ciEnv::dump_replay_data_unsafe(outputStream* out) {\n+\/\/ Called from VM error reporter, so be careful.\n+\/\/ Don't safepoint or acquire any locks.\n+\/\/\n+void ciEnv::dump_replay_data_helper(outputStream* out) {\n+  NoSafepointVerifier no_safepoint;\n@@ -1228,0 +1631,1 @@\n+\n@@ -1234,0 +1638,2 @@\n+  find_dynamic_call_sites();\n+\n@@ -1243,0 +1649,9 @@\n+\/\/ Called from VM error reporter, so be careful.\n+\/\/ Don't safepoint or acquire any locks.\n+\/\/\n+void ciEnv::dump_replay_data_unsafe(outputStream* out) {\n+  GUARDED_VM_ENTRY(\n+    dump_replay_data_helper(out);\n+  )\n+}\n+\n@@ -1246,1 +1661,1 @@\n-    dump_replay_data_unsafe(out);\n+    dump_replay_data_helper(out);\n","filename":"src\/hotspot\/share\/ci\/ciEnv.cpp","additions":425,"deletions":10,"binary":false,"changes":435,"status":"modified"},{"patch":"@@ -47,1 +47,0 @@\n-\n@@ -50,0 +49,1 @@\n+  friend class RecordLocation;\n@@ -463,0 +463,23 @@\n+  \/\/ Replay support\n+private:\n+  static int klass_compare(const InstanceKlass* const &ik1, const InstanceKlass* const &ik2) {\n+    if (ik1 > ik2) {\n+      return 1;\n+    } else if (ik1 < ik2) {\n+      return -1;\n+    } else {\n+      return 0;\n+    }\n+  }\n+  bool dyno_loc(const InstanceKlass* ik, const char *&loc) const;\n+  void set_dyno_loc(const InstanceKlass* ik);\n+  void record_best_dyno_loc(const InstanceKlass* ik);\n+  bool print_dyno_loc(outputStream* out, const InstanceKlass* ik) const;\n+\n+  GrowableArray<const InstanceKlass*>* _dyno_klasses;\n+  GrowableArray<const char *>*         _dyno_locs;\n+\n+#define MAX_DYNO_NAME_LENGTH 1024\n+  char _dyno_name[MAX_DYNO_NAME_LENGTH+1];\n+\n+public:\n@@ -468,0 +491,1 @@\n+  void dump_replay_data_helper(outputStream* out);\n@@ -469,0 +493,13 @@\n+\n+  const char *dyno_name(const InstanceKlass* ik) const;\n+  const char *replay_name(const InstanceKlass* ik) const;\n+  const char *replay_name(ciKlass* i) const;\n+\n+  void record_lambdaform(Thread* thread, oop obj);\n+  void record_member(Thread* thread, oop obj);\n+  void record_mh(Thread* thread, oop obj);\n+  void record_call_site_obj(Thread* thread, const constantPoolHandle& pool, const Handle appendix);\n+  void record_call_site_method(Thread* thread, const constantPoolHandle& pool, Method* adapter);\n+  void process_invokedynamic(const constantPoolHandle &cp, int index, JavaThread* thread);\n+  void process_invokehandle(const constantPoolHandle &cp, int index, JavaThread* thread);\n+  void find_dynamic_call_sites();\n","filename":"src\/hotspot\/share\/ci\/ciEnv.hpp","additions":38,"deletions":1,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -734,0 +734,3 @@\n+const char *ciInstanceKlass::replay_name() const {\n+  return CURRENT_ENV->replay_name(get_instanceKlass());\n+}\n@@ -744,2 +747,12 @@\n-    if (sub->is_instance_klass() && !sub->is_hidden()) {\n-      out->print_cr(\"instanceKlass %s\", sub->name()->as_quoted_ascii());\n+    if (sub->is_instance_klass()) {\n+      InstanceKlass *isub = InstanceKlass::cast(sub);\n+      if (isub->is_hidden()) {\n+        const char *name = CURRENT_ENV->dyno_name(isub);\n+        if (name != NULL) {\n+          out->print_cr(\"instanceKlass %s # %s\", name, sub->name()->as_quoted_ascii());\n+        } else {\n+          out->print_cr(\"# instanceKlass %s\", sub->name()->as_quoted_ascii());\n+        }\n+      } else {\n+        out->print_cr(\"instanceKlass %s\", sub->name()->as_quoted_ascii());\n+      }\n@@ -754,1 +767,2 @@\n-  out->print(\"ciInstanceKlass %s %d %d %d\", ik->name()->as_quoted_ascii(),\n+  const char *name = replay_name();\n+  out->print(\"ciInstanceKlass %s %d %d %d\", name,\n@@ -763,1 +777,1 @@\n-    StaticFinalFieldPrinter sffp(out, ik->name()->as_quoted_ascii());\n+    StaticFinalFieldPrinter sffp(out, name);\n","filename":"src\/hotspot\/share\/ci\/ciInstanceKlass.cpp","additions":18,"deletions":4,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -296,0 +296,2 @@\n+  \/\/ Replay support\n+\n@@ -299,0 +301,3 @@\n+  \/\/ Return stable class name suitable for replay file.\n+  const char *replay_name() const;\n+\n","filename":"src\/hotspot\/share\/ci\/ciInstanceKlass.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -73,0 +73,1 @@\n+  assert(_holder->get_instanceKlass() == h_m->method_holder(), \"\");\n@@ -1291,2 +1292,1 @@\n-void ciMethod::dump_name_as_ascii(outputStream* st) {\n-  Method* method = get_Method();\n+void ciMethod::dump_name_as_ascii(outputStream* st, Method* method) {\n@@ -1294,1 +1294,1 @@\n-            method->klass_name()->as_quoted_ascii(),\n+            CURRENT_ENV->replay_name(method->method_holder()),\n@@ -1299,0 +1299,5 @@\n+void ciMethod::dump_name_as_ascii(outputStream* st) {\n+  Method* method = get_Method();\n+  dump_name_as_ascii(st, method);\n+}\n+\n@@ -1302,0 +1307,4 @@\n+  if (MethodHandles::is_signature_polymorphic_method(method)) {\n+    \/\/ ignore for now\n+    return;\n+  }\n","filename":"src\/hotspot\/share\/ci\/ciMethod.cpp","additions":12,"deletions":3,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -368,0 +368,1 @@\n+  static void dump_name_as_ascii(outputStream* st, Method* method);\n","filename":"src\/hotspot\/share\/ci\/ciMethod.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -650,1 +650,2 @@\n-      out->print(\" %d %s\", (int)(dp_to_di(pdata->dp() + in_bytes(offset)) \/ sizeof(intptr_t)), k->name()->as_quoted_ascii());\n+      out->print(\" %d %s\", (int)(dp_to_di(pdata->dp() + in_bytes(offset)) \/ sizeof(intptr_t)),\n+                           CURRENT_ENV->replay_name(k));\n@@ -706,7 +707,3 @@\n-  Klass* holder = method->method_holder();\n-  out->print(\"ciMethodData %s %s %s %d %d\",\n-             holder->name()->as_quoted_ascii(),\n-             method->name()->as_quoted_ascii(),\n-             method->signature()->as_quoted_ascii(),\n-             _state,\n-             current_mileage());\n+  out->print(\"ciMethodData \");\n+  ciMethod::dump_name_as_ascii(out, method);\n+  out->print(\" %d %d\", _state, current_mileage());\n","filename":"src\/hotspot\/share\/ci\/ciMethodData.cpp","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+#include \"interpreter\/linkResolver.hpp\"\n@@ -41,0 +42,2 @@\n+#include \"oops\/cpCache.inline.hpp\"\n+#include \"oops\/fieldStreams.inline.hpp\"\n@@ -45,0 +48,1 @@\n+#include \"prims\/methodHandles.hpp\"\n@@ -260,1 +264,1 @@\n-  const char* parse_escaped_string() {\n+  char* parse_escaped_string() {\n@@ -343,1 +347,1 @@\n-  Symbol* parse_symbol(TRAPS) {\n+  Symbol* parse_symbol() {\n@@ -352,0 +356,151 @@\n+  bool parse_terminator() {\n+    char* terminator = parse_string();\n+    if (terminator != NULL && strcmp(terminator, \";\") == 0) {\n+      return true;\n+    }\n+    return false;\n+  }\n+\n+  \/\/ Parse a special hidden klass location syntax\n+  \/\/ syntax: @bci <klass> <name> <signature> <bci> <location>* ;\n+  \/\/ syntax: @cpi <klass> <cpi> <location>* ;\n+  Klass* parse_cp_ref(TRAPS) {\n+    JavaThread* thread = THREAD;\n+    oop obj = NULL;\n+    char* ref = parse_string();\n+    if (strcmp(ref, \"bci\") == 0) {\n+      Method* m = parse_method(CHECK_NULL);\n+\n+      InstanceKlass* ik = m->method_holder();\n+      const constantPoolHandle cp(Thread::current(), ik->constants());\n+\n+      \/\/ invokedynamic or invokehandle\n+\n+      methodHandle caller(Thread::current(), m);\n+      int bci = parse_int(\"bci\");\n+      if (m->validate_bci(bci) != bci) {\n+        report_error(\"bad bci\");\n+        return NULL;\n+      }\n+\n+      ik->link_class(CHECK_NULL);\n+\n+      Bytecode_invoke bytecode(caller, bci);\n+      int index = bytecode.index();\n+\n+      ConstantPoolCacheEntry* cp_cache_entry = NULL;\n+      CallInfo callInfo;\n+      Bytecodes::Code bc = bytecode.invoke_code();\n+      LinkResolver::resolve_invoke(callInfo, Handle(), cp, index, bc, CHECK_NULL);\n+      if (bytecode.is_invokedynamic()) {\n+        cp_cache_entry = cp->invokedynamic_cp_cache_entry_at(index);\n+        cp_cache_entry->set_dynamic_call(cp, callInfo);\n+      } else if (bytecode.is_invokehandle()) {\n+#ifdef ASSERT\n+        Klass* holder = cp->klass_ref_at(index, CHECK_NULL);\n+        Symbol* name = cp->name_ref_at(index);\n+        assert(MethodHandles::is_signature_polymorphic_name(holder, name), \"\");\n+#endif\n+        cp_cache_entry = cp->cache()->entry_at(cp->decode_cpcache_index(index));\n+        cp_cache_entry->set_method_handle(cp, callInfo);\n+      } else {\n+        report_error(\"no dynamic invoke found\");\n+        return NULL;\n+      }\n+      char* dyno_ref = parse_string();\n+      if (strcmp(dyno_ref, \"<appendix>\") == 0) {\n+        obj = cp_cache_entry->appendix_if_resolved(cp);\n+      } else if (strcmp(dyno_ref, \"<adapter>\") == 0) {\n+        if (!parse_terminator()) {\n+          report_error(\"no dynamic invoke found\");\n+          return NULL;\n+        }\n+        Method* adapter = cp_cache_entry->f1_as_method();\n+        if (adapter == NULL) {\n+          report_error(\"no adapter found\");\n+          return NULL;\n+        }\n+        return adapter->method_holder();\n+      } else if (strcmp(dyno_ref, \"<bsm>\") == 0) {\n+        int pool_index = cp_cache_entry->constant_pool_index();\n+        BootstrapInfo bootstrap_specifier(cp, pool_index, index);\n+        obj = cp->resolve_possibly_cached_constant_at(bootstrap_specifier.bsm_index(), thread);\n+      } else {\n+        report_error(\"unrecognized token\");\n+        return NULL;\n+      }\n+    } else {\n+      \/\/ constant pool ref (MethodHandle)\n+      if (strcmp(ref, \"cpi\") != 0) {\n+        report_error(\"unexpected token\");\n+        return NULL;\n+      }\n+\n+      Klass* k = parse_klass(CHECK_NULL);\n+      InstanceKlass* ik = InstanceKlass::cast(k);\n+      const constantPoolHandle cp(Thread::current(), ik->constants());\n+\n+      int cpi = parse_int(\"cpi\");\n+\n+      if (cpi >= cp->length()) {\n+        report_error(\"bad cpi\");\n+        return NULL;\n+      }\n+      if (!cp->tag_at(cpi).is_method_handle()) {\n+        report_error(\"no method handle found at cpi\");\n+        return NULL;\n+      }\n+      {\n+        bool found_it;\n+        obj = cp->find_cached_constant_at(cpi, found_it, thread);\n+      }\n+    }\n+    Klass* k = NULL;\n+    if (obj != NULL) {\n+      skip_ws();\n+      \/\/ loop: read fields\n+      char* field = NULL;\n+      do {\n+        field = parse_string();\n+        if (field == NULL) {\n+          report_error(\"no field found\");\n+          return NULL;\n+        }\n+        if (strcmp(field, \";\") == 0) {\n+          break;\n+        }\n+        \/\/ raw Method*\n+        if (strcmp(field, \"<vmtarget>\") == 0) {\n+          Method* vmtarget = java_lang_invoke_MemberName::vmtarget(obj);\n+          k = (vmtarget == NULL) ? NULL : vmtarget->method_holder();\n+          if (k == NULL) {\n+            report_error(\"null vmtarget found\");\n+            return NULL;\n+          }\n+          if (!parse_terminator()) {\n+            report_error(\"missing terminator\");\n+            return NULL;\n+          }\n+          return k;\n+        }\n+        obj = ciReplay::obj_field(obj, field);\n+        \/\/ array\n+        if (obj != NULL && obj->is_objArray()) {\n+          objArrayOop arr = (objArrayOop)obj;\n+          int index = parse_int(\"index\");\n+          if (index >= arr->length()) {\n+            report_error(\"bad array index\");\n+            return NULL;\n+          }\n+          obj = arr->obj_at(index);\n+        }\n+      } while (obj != NULL);\n+      if (obj == NULL) {\n+        report_error(\"null field found\");\n+        return NULL;\n+      }\n+      k = obj->klass();\n+    }\n+    return k;\n+  }\n+\n@@ -353,0 +508,2 @@\n+  \/\/ syntax: <name>\n+  \/\/ syntax: <constant pool ref>\n@@ -354,1 +511,13 @@\n-    const char* str = parse_escaped_string();\n+    skip_ws();\n+    \/\/ check for constant pool object reference (for a dynamic\/hidden class)\n+    bool cp_ref = (*_bufptr == '@');\n+    if (cp_ref) {\n+      ++_bufptr;\n+      Klass* k = parse_cp_ref(CHECK_NULL);\n+      if (k != NULL && !k->is_hidden()) {\n+        report_error(\"expected hidden class\");\n+        return NULL;\n+      }\n+      return k;\n+    }\n+    char* str = parse_escaped_string();\n@@ -392,2 +561,2 @@\n-    Symbol* method_name = parse_symbol(CHECK_NULL);\n-    Symbol* method_signature = parse_symbol(CHECK_NULL);\n+    Symbol* method_name = parse_symbol();\n+    Symbol* method_signature = parse_symbol();\n@@ -682,0 +851,1 @@\n+  \/\/ instanceKlass <constant pool ref> # <original hidden class name>\n@@ -688,0 +858,13 @@\n+    if (k == NULL) {\n+      return;\n+    }\n+    const char* comment = parse_string();\n+    bool is_comment = comment != NULL && strcmp(comment, \"#\") == 0;\n+    if (k->is_hidden() != is_comment) {\n+      report_error(\"hidden class with comment expected\");\n+      return;\n+    }\n+    if (is_comment && Verbose) {\n+      const char* hidden = parse_string();\n+      tty->print_cr(\"Found %s for %s\", k->name()->as_quoted_ascii(), hidden);\n+    }\n@@ -1282,0 +1465,37 @@\n+\n+oop ciReplay::obj_field(oop obj, Symbol* name) {\n+  InstanceKlass* ik = InstanceKlass::cast(obj->klass());\n+\n+  do {\n+    if (!ik->has_nonstatic_fields()) {\n+      ik = ik->java_super();\n+      continue;\n+    }\n+\n+    for (JavaFieldStream fs(ik); !fs.done(); fs.next()) {\n+      if (fs.access_flags().is_static()) {\n+        continue;\n+      }\n+      if (fs.name() == name) {\n+        int offset = fs.offset();\n+#ifdef ASSERT\n+        fieldDescriptor fd = fs.field_descriptor();\n+        assert(fd.offset() == ik->field_offset(fd.index()), \"!\");\n+#endif\n+        oop f = obj->obj_field(offset);\n+        return f;\n+      }\n+    }\n+\n+    ik = ik->java_super();\n+  } while (ik != NULL);\n+  return NULL;\n+}\n+\n+oop ciReplay::obj_field(oop obj, const char *name) {\n+  Symbol* fname = SymbolTable::probe(name, (int)strlen(name));\n+  if (fname == NULL) {\n+    return NULL;\n+  }\n+  return obj_field(obj, fname);\n+}\n","filename":"src\/hotspot\/share\/ci\/ciReplay.cpp","additions":225,"deletions":5,"binary":false,"changes":230,"status":"modified"},{"patch":"@@ -123,1 +123,0 @@\n-\n@@ -125,0 +124,5 @@\n+\n+ public:\n+  static oop obj_field(oop obj, Symbol* name);\n+  static oop obj_field(oop obj, const char *name);\n+\n","filename":"src\/hotspot\/share\/ci\/ciReplay.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -94,0 +94,1 @@\n+            i += ((Lambda)(() -> 0)).value();\n","filename":"test\/hotspot\/jtreg\/compiler\/ciReplay\/CiReplayBase.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -54,0 +54,1 @@\n+        positiveTest(TIERED_DISABLED_VM_OPTION);\n","filename":"test\/hotspot\/jtreg\/compiler\/ciReplay\/TestInlining.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}