{"files":[{"patch":"@@ -263,2 +263,0 @@\n-\n-\n@@ -506,1 +504,4 @@\n-     * name and the encryption algorithm name inside a PKCS7 SignerInfo.\n+     * and the encryption algorithm inside a PKCS7 SignerInfo.\n+     *\n+     * The digest algorithm is in the form \"DIG\", and the encryption\n+     * algorithm can be in any of the 3 forms:\n@@ -508,4 +509,7 @@\n-     * For old style PKCS7 files where we use RSA, DSA, EC as encAlgId\n-     * a DIGESTwithENC algorithm is returned. For new style RSASSA-PSS\n-     * and EdDSA encryption, this method ensures digAlgId is compatible\n-     * with the algorithm.\n+     * 1. Old style key algorithm like RSA, DSA, EC, this method returns\n+     *    DIGwithKEY.\n+     * 2. New style signature algorithm in the form of HASHwithKEY, this\n+     *    method returns DIGwithKEY. Please note this is not HASHwithKEY.\n+     * 3. Modern signature algorithm like RSASSA-PSS and EdDSA, this method\n+     *    returns the signature algorithm itself but ensures digAlgId is\n+     *    compatible with the algorithm as described in RFC 4056 and 8419.\n@@ -514,1 +518,1 @@\n-     * @param encAlgId the encryption or signature algorithm\n+     * @param encAlgId the encryption algorithm\n@@ -521,3 +525,0 @@\n-        if (encAlg.contains(\"with\")) {\n-            return encAlg;\n-        }\n@@ -550,0 +551,5 @@\n+                String keyAlg = SignatureUtil.extractKeyAlgFromDwithE(encAlg);\n+                if (keyAlg == null) {\n+                    \/\/ The encAlg used to be only the key alg\n+                    keyAlg = encAlg;\n+                }\n@@ -553,2 +559,2 @@\n-                if (encAlg.equals(\"EC\")) encAlg = \"ECDSA\";\n-                return digAlg + \"with\" + encAlg;\n+                if (keyAlg.equals(\"EC\")) keyAlg = \"ECDSA\";\n+                return digAlg + \"with\" + keyAlg;\n","filename":"src\/java.base\/share\/classes\/sun\/security\/pkcs\/SignerInfo.java","additions":19,"deletions":13,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -285,0 +285,26 @@\n+    \/**\n+     * Extracts the key algorithm name from a signature\n+     * algorithm name in either the \"DIGESTwithENCRYPTION\" or the\n+     * \"DIGESTwithENCRYPTIONandWHATEVER\" format.\n+     *\n+     * @return the key algorithm name, or null if the input\n+     *      is not in either of the formats.\n+     *\/\n+    public static String extractKeyAlgFromDwithE(String signatureAlgorithm) {\n+        signatureAlgorithm = signatureAlgorithm.toUpperCase(Locale.ENGLISH);\n+        int with = signatureAlgorithm.indexOf(\"WITH\");\n+        String keyAlgorithm = null;\n+        if (with > 0) {\n+            int and = signatureAlgorithm.indexOf(\"AND\", with + 4);\n+            if (and > 0) {\n+                keyAlgorithm = signatureAlgorithm.substring(with + 4, and);\n+            } else {\n+                keyAlgorithm = signatureAlgorithm.substring(with + 4);\n+            }\n+            if (keyAlgorithm.equalsIgnoreCase(\"ECDSA\")) {\n+                keyAlgorithm = \"EC\";\n+            }\n+        }\n+        return keyAlgorithm;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/SignatureUtil.java","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8255494\n+ * @summary Make sure the signature algorithm to verify a PKCS7 block is\n+ *      DIGwithENC instead of HASHwithENC.\n+ * @modules java.base\/sun.security.pkcs\n+ *          java.base\/sun.security.tools.keytool\n+ *          java.base\/sun.security.x509\n+ *\/\n+\n+import sun.security.pkcs.PKCS7;\n+import sun.security.tools.keytool.CertAndKeyGen;\n+import sun.security.x509.X500Name;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.security.cert.X509Certificate;\n+\n+public class TwoHash {\n+    public static void main(String[] args) throws Exception {\n+\n+        byte[] content = \"Hello You fool I love you\".getBytes();\n+\n+        CertAndKeyGen cak = new CertAndKeyGen(\"EC\", \"SHA512withECDSA\");\n+        cak.generate(\"secp256r1\");\n+        byte[] signature = PKCS7.generateNewSignedData(\n+                \"SHA256withECDSA\",\n+                null,\n+                cak.getPrivateKey(),\n+                new X509Certificate[] {cak.getSelfCertificate(new X500Name(\"CN=Me\"), 1000)},\n+                content,\n+                false,\n+                true, \/\/ direct sign, so that RFC 6211 check is not possible\n+                null);\n+\n+        \/\/ The original signature should verify.\n+        if (new PKCS7(signature).verify(content) == null) {\n+            throw new RuntimeException(\"Should be verified\");\n+        }\n+\n+        \/\/ Modify the SHA256withECDSA signature algorithm (OID encoded as\n+        \/\/ \"06 08 2A 86 48 CE 3D 04 03 02\") to SHA384withECDSA (OID encoded as\n+        \/\/ \"06 08 2A 86 48 CE 3D 04 03 03\"). ISO_8859_1 charset is chosen\n+        \/\/ because it's a strictly one byte per char encoding.\n+        String s = new String(signature, StandardCharsets.ISO_8859_1);\n+        String s1 = s.replace(\n+                \"\\u0006\\u0008\\u002A\\u0086\\u0048\\u00CE\\u003D\\u0004\\u0003\\u0002\",\n+                \"\\u0006\\u0008\\u002A\\u0086\\u0048\\u00CE\\u003D\\u0004\\u0003\\u0003\");\n+        byte[] modified = s1.getBytes(StandardCharsets.ISO_8859_1);\n+\n+        \/\/ The modified signature should still verify because the HASH\n+        \/\/ part of signature algorithm is ignored.\n+        if (new PKCS7(modified).verify(content) == null) {\n+            throw new RuntimeException(\"Should be verified\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/pkcs\/pkcs7\/TwoHash.java","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"}]}