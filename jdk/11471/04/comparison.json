{"files":[{"patch":"@@ -1934,1 +1934,1 @@\n-  assert(VM_Version::supports_avx512vl() || VM_Version::supports_f16c(), \"\");\n+  assert(VM_Version::supports_evex() || VM_Version::supports_f16c(), \"\");\n@@ -1941,1 +1941,1 @@\n-  assert(VM_Version::supports_avx512vl(), \"\");\n+  assert(VM_Version::supports_evex(), \"\");\n@@ -1954,0 +1954,11 @@\n+void Assembler::vcvtps2ph(Address dst, XMMRegister src, int imm8, int vector_len) {\n+  assert(VM_Version::supports_evex() || VM_Version::supports_f16c(), \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* rex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/*uses_vl *\/ true);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_HVM, \/* input_size_in_bits *\/ EVEX_NObit);\n+  vex_prefix(dst, 0, src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &attributes);\n+  emit_int8(0x1D);\n+  emit_operand(src, dst, 1);\n+  emit_int8(imm8);\n+}\n+\n@@ -1955,1 +1966,1 @@\n-  assert(VM_Version::supports_avx512vl() || VM_Version::supports_f16c(), \"\");\n+  assert(VM_Version::supports_evex() || VM_Version::supports_f16c(), \"\");\n@@ -1961,0 +1972,10 @@\n+void Assembler::vcvtph2ps(XMMRegister dst, Address src, int vector_len) {\n+  assert(VM_Version::supports_evex() || VM_Version::supports_f16c(), \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* rex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/*uses_vl *\/ true);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_HVM, \/* input_size_in_bits *\/ EVEX_NObit);\n+  vex_prefix(src, 0, dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int8(0x13);\n+  emit_operand(dst, src, 0);\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":24,"deletions":3,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -1163,0 +1163,2 @@\n+  void vcvtps2ph(Address dst, XMMRegister src, int imm8, int vector_len);\n+  void vcvtph2ps(XMMRegister dst, Address src, int vector_len);\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -959,0 +959,1 @@\n+    _features &= ~CPU_F16C;\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1690,0 +1690,6 @@\n+    case Op_VectorCastF2H:\n+    case Op_VectorCastH2F:\n+      if (!VM_Version::supports_f16c() && !VM_Version::supports_evex()) {\n+        return false;\n+      }\n+      break;\n@@ -1904,0 +1910,8 @@\n+    case Op_VectorCastF2H:\n+    case Op_VectorCastH2F:\n+      if (!VM_Version::supports_f16c() &&\n+         ((!VM_Version::supports_evex() ||\n+         ((size_in_bits != 512) && !VM_Version::supports_avx512vl())))) {\n+        return false;\n+      }\n+      break;\n@@ -3676,0 +3690,20 @@\n+instruct vconvF2HF(vec dst, vec src) %{\n+  match(Set dst (VectorCastF2H src));\n+  format %{ \"vector_conv_F2HF $dst $src\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this, $src);\n+    __ vcvtps2ph($dst$$XMMRegister, $src$$XMMRegister, 0x04, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct vconvF2HF_mem_reg(memory mem, vec src) %{\n+  match(Set mem (StoreVector mem (VectorCastF2H src)));\n+  format %{ \"vcvtps2ph $mem,$src\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this, $src);\n+    __ vcvtps2ph($mem$$Address, $src$$XMMRegister, 0x04, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n@@ -3686,0 +3720,21 @@\n+instruct vconvHF2F_reg_mem(vec dst, memory mem) %{\n+  match(Set dst (VectorCastH2F (LoadVector mem)));\n+  format %{ \"vcvtph2ps $dst,$mem\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    __ vcvtph2ps($dst$$XMMRegister, $mem$$Address, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct vconvHF2F(vec dst, vec src) %{\n+  match(Set dst (VectorCastH2F src));\n+  ins_cost(125);\n+  format %{ \"vector_conv_HF2F $dst,$src\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    __ vcvtph2ps($dst$$XMMRegister, $src$$XMMRegister, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":55,"deletions":0,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -4226,1 +4226,1 @@\n-    \"VectorCastL2X\", \"VectorCastF2X\", \"VectorCastD2X\",\n+    \"VectorCastL2X\", \"VectorCastF2X\", \"VectorCastD2X\", \"VectorCastF2H\", \"VectorCastH2F\",\n","filename":"src\/hotspot\/share\/adlc\/formssel.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -508,0 +508,2 @@\n+macro(VectorCastF2H)\n+macro(VectorCastH2F)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2693,1 +2693,2 @@\n-                 opc == Op_CountTrailingZerosI) {\n+                 opc == Op_CountTrailingZerosI || opc == Op_ConvHF2F ||\n+                 opc == Op_ConvF2HF) {\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -270,0 +270,4 @@\n+  case Op_ConvHF2F:\n+    return Op_VectorCastH2F;\n+  case Op_ConvF2HF:\n+    return Op_VectorCastF2H;\n@@ -470,0 +474,2 @@\n+    case Op_ConvF2HF:\n+    case Op_ConvHF2F:\n@@ -697,0 +703,2 @@\n+  case Op_VectorCastH2F: return new VectorCastH2FNode(n1, vt);\n+  case Op_VectorCastF2H: return new VectorCastF2HNode(n1, vt);\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1631,0 +1631,16 @@\n+class VectorCastH2FNode : public VectorNode {\n+ public:\n+  VectorCastH2FNode(Node* in, const TypeVect* vt) : VectorNode(in, vt) {\n+    assert(in->bottom_type()->is_vect()->element_basic_type() == T_SHORT, \"must be short\");\n+  }\n+  virtual int Opcode() const;\n+};\n+\n+class VectorCastF2HNode : public VectorNode {\n+ public:\n+  VectorCastF2HNode(Node* in, const TypeVect* vt) : VectorNode(in, vt) {\n+    assert(in->bottom_type()->is_vect()->element_basic_type() == T_FLOAT, \"must be float\");\n+  }\n+  virtual int Opcode() const;\n+};\n+\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -1082,0 +1082,10 @@\n+    public static final String VECTOR_CAST_F2H = PREFIX + \"VECTOR_CAST_F2H\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(VECTOR_CAST_F2H, \"VectorCastF2H\");\n+    }\n+\n+    public static final String VECTOR_CAST_H2F = PREFIX + \"VECTOR_CAST_H2F\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(VECTOR_CAST_H2F, \"VectorCastH2F\");\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,96 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8294588\n+ * @summary Auto-vectorize Float.floatToFloat16, Float.float16ToFloat API's\n+ * @requires vm.compiler2.enabled\n+ * @requires vm.cpu.features ~= \".*avx.*\"\n+ * @requires os.simpleArch == \"x64\"\n+ * @library \/test\/lib \/\n+ * @run driver compiler.vectorization.TestFloatConversionsVector\n+ *\/\n+\n+package compiler.vectorization;\n+\n+import compiler.lib.ir_framework.*;\n+\n+public class TestFloatConversionsVector {\n+  private static final int ARRLEN = 1024;\n+  private static final int ITERS  = 11000;\n+  private static float  [] finp;\n+  private static short  [] sout;\n+  private static short  [] sinp;\n+  private static float  [] fout;\n+\n+  public static void main(String args[]) {\n+      TestFramework.runWithFlags(\"-XX:-TieredCompilation\",\n+                                 \"-XX:CompileThresholdScaling=0.3\");\n+      System.out.println(\"PASSED\");\n+  }\n+\n+  @Test\n+  @IR(counts = {IRNode.VECTOR_CAST_F2H, \"> 0\"})\n+  public void test_float_float16(short[] sout, float[] finp) {\n+      for (int i = 0; i < finp.length; i+=1) {\n+          sout[i] = Float.floatToFloat16(finp[i]);\n+      }\n+  }\n+\n+  @Run(test = {\"test_float_float16\"}, mode = RunMode.STANDALONE)\n+  public void kernel_test_float_float16() {\n+      finp = new float[ARRLEN];\n+      sout = new short[ARRLEN];\n+\n+      for (int i = 0; i < ARRLEN; i++) {\n+          finp[i] = (float) i * 1.4f;\n+      }\n+\n+      for (int i = 0; i < ITERS; i++) {\n+         test_float_float16(sout, finp);\n+      }\n+  }\n+\n+  @Test\n+  @IR(counts = {IRNode.VECTOR_CAST_H2F, \"> 0\"})\n+  public void test_float16_float(float[] fout, short[] sinp) {\n+      for (int i = 0; i < sinp.length; i+=1) {\n+          fout[i] = Float.float16ToFloat(sinp[i]);\n+      }\n+  }\n+\n+  @Run(test = {\"test_float16_float\"}, mode = RunMode.STANDALONE)\n+  public void kernel_test_float16_float() {\n+      sinp = new short[ARRLEN];\n+      fout = new float[ARRLEN];\n+\n+      for (int i = 0; i < ARRLEN; i++) {\n+          sinp[i] = (short)i;\n+      }\n+\n+      for (int i = 0; i < ITERS; i++) {\n+          test_float16_float(fout , sinp);\n+      }\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestFloatConversionsVector.java","additions":96,"deletions":0,"binary":false,"changes":96,"status":"added"}]}