{"files":[{"patch":"@@ -1934,1 +1934,1 @@\n-  assert(VM_Version::supports_avx512vl() || VM_Version::supports_f16c(), \"\");\n+  assert(VM_Version::supports_evex() || VM_Version::supports_f16c(), \"\");\n@@ -1941,1 +1941,1 @@\n-  assert(VM_Version::supports_avx512vl(), \"\");\n+  assert(VM_Version::supports_evex(), \"\");\n@@ -1954,0 +1954,11 @@\n+void Assembler::vcvtps2ph(Address dst, XMMRegister src, int imm8, int vector_len) {\n+  assert(VM_Version::supports_evex() || VM_Version::supports_f16c(), \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* rex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/*uses_vl *\/ true);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_HVM, \/* input_size_in_bits *\/ EVEX_NObit);\n+  vex_prefix(dst, 0, src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &attributes);\n+  emit_int8(0x1D);\n+  emit_operand(src, dst, 1);\n+  emit_int8(imm8);\n+}\n+\n@@ -1955,1 +1966,1 @@\n-  assert(VM_Version::supports_avx512vl() || VM_Version::supports_f16c(), \"\");\n+  assert(VM_Version::supports_evex() || VM_Version::supports_f16c(), \"\");\n@@ -1961,0 +1972,10 @@\n+void Assembler::vcvtph2ps(XMMRegister dst, Address src, int vector_len) {\n+  assert(VM_Version::supports_evex() || VM_Version::supports_f16c(), \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* rex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/*uses_vl *\/ true);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_HVM, \/* input_size_in_bits *\/ EVEX_NObit);\n+  vex_prefix(src, 0, dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int8(0x13);\n+  emit_operand(dst, src, 0);\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":24,"deletions":3,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -1163,0 +1163,2 @@\n+  void vcvtps2ph(Address dst, XMMRegister src, int imm8, int vector_len);\n+  void vcvtph2ps(XMMRegister dst, Address src, int vector_len);\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -959,0 +959,1 @@\n+    _features &= ~CPU_F16C;\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1690,0 +1690,7 @@\n+    case Op_VectorCastF2HF:\n+    case Op_VectorCastHF2F:\n+      if ((UseAVX < 2) ||\n+          (!VM_Version::supports_f16c() && !VM_Version::supports_evex())) {\n+        return false;\n+      }\n+      break;\n@@ -1904,0 +1911,8 @@\n+    case Op_VectorCastF2HF:\n+    case Op_VectorCastHF2F:\n+      if (!VM_Version::supports_f16c() &&\n+         ((!VM_Version::supports_evex() ||\n+         ((size_in_bits != 512) && !VM_Version::supports_avx512vl())))) {\n+        return false;\n+      }\n+      break;\n@@ -3676,0 +3691,20 @@\n+instruct vconvF2HF(vec dst, vec src) %{\n+  match(Set dst (VectorCastF2HF src));\n+  format %{ \"vector_conv_F2HF $dst $src\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this, $src);\n+    __ vcvtps2ph($dst$$XMMRegister, $src$$XMMRegister, 0x04, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct vconvF2HF_mem_reg(memory mem, vec src) %{\n+  match(Set mem (StoreVector mem (VectorCastF2HF src)));\n+  format %{ \"vcvtps2ph $mem,$src\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this, $src);\n+    __ vcvtps2ph($mem$$Address, $src$$XMMRegister, 0x04, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n@@ -3686,0 +3721,21 @@\n+instruct vconvHF2F_reg_mem(vec dst, memory mem) %{\n+  match(Set dst (VectorCastHF2F (LoadVector mem)));\n+  format %{ \"vcvtph2ps $dst,$mem\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    __ vcvtph2ps($dst$$XMMRegister, $mem$$Address, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct vconvHF2F(vec dst, vec src) %{\n+  match(Set dst (VectorCastHF2F src));\n+  ins_cost(125);\n+  format %{ \"vector_conv_HF2F $dst,$src\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    __ vcvtph2ps($dst$$XMMRegister, $src$$XMMRegister, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":56,"deletions":0,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -4226,1 +4226,1 @@\n-    \"VectorCastL2X\", \"VectorCastF2X\", \"VectorCastD2X\",\n+    \"VectorCastL2X\", \"VectorCastF2X\", \"VectorCastD2X\", \"VectorCastF2HF\", \"VectorCastHF2F\",\n","filename":"src\/hotspot\/share\/adlc\/formssel.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -508,0 +508,2 @@\n+macro(VectorCastF2HF)\n+macro(VectorCastHF2F)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2715,1 +2715,1 @@\n-        int vopc = VectorCastNode::opcode(in->bottom_type()->is_vect()->element_basic_type());\n+        int vopc = VectorCastNode::opcode(opc, in->bottom_type()->is_vect()->element_basic_type());\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -778,1 +778,1 @@\n-  int cast_vopc = VectorCastNode::opcode(T_BYTE); \/\/ from shuffle of type T_BYTE\n+  int cast_vopc = VectorCastNode::opcode(-1, T_BYTE); \/\/ from shuffle of type T_BYTE\n@@ -2492,1 +2492,1 @@\n-    int cast_vopc = VectorCastNode::opcode(elem_bt_from, !is_ucast);\n+    int cast_vopc = VectorCastNode::opcode(-1, elem_bt_from, !is_ucast);\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -470,0 +470,2 @@\n+    case Op_ConvF2HF:\n+    case Op_ConvHF2F:\n@@ -1331,0 +1333,2 @@\n+    case Op_VectorCastHF2F: return new VectorCastHF2FNode(n1, vt);\n+    case Op_VectorCastF2HF: return new VectorCastF2HFNode(n1, vt);\n@@ -1337,1 +1341,1 @@\n-int VectorCastNode::opcode(BasicType bt, bool is_signed) {\n+int VectorCastNode::opcode(int sopc, BasicType bt, bool is_signed) {\n@@ -1339,0 +1343,15 @@\n+\n+  \/\/ Handle special case for to\/from Half Float conversions\n+  switch (sopc) {\n+    case Op_ConvHF2F:\n+      assert(bt == T_SHORT, \"\");\n+      return Op_VectorCastHF2F;\n+    case Op_ConvF2HF:\n+      assert(bt == T_FLOAT, \"\");\n+      return Op_VectorCastF2HF;\n+    default:\n+      \/\/ Handled normally below\n+      break;\n+  }\n+\n+  \/\/ Handle normal conversions\n@@ -1357,1 +1376,1 @@\n-    int vopc = VectorCastNode::opcode(src_type);\n+    int vopc = VectorCastNode::opcode(opc, src_type);\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":21,"deletions":2,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -1545,1 +1545,1 @@\n-  static int  opcode(BasicType bt, bool is_signed = true);\n+  static int  opcode(int opc, BasicType bt, bool is_signed = true);\n@@ -1631,0 +1631,16 @@\n+class VectorCastHF2FNode : public VectorCastNode {\n+ public:\n+  VectorCastHF2FNode(Node* in, const TypeVect* vt) : VectorCastNode(in, vt) {\n+    assert(in->bottom_type()->is_vect()->element_basic_type() == T_SHORT, \"must be short\");\n+  }\n+  virtual int Opcode() const;\n+};\n+\n+class VectorCastF2HFNode : public VectorCastNode {\n+ public:\n+  VectorCastF2HFNode(Node* in, const TypeVect* vt) : VectorCastNode(in, vt) {\n+    assert(in->bottom_type()->is_vect()->element_basic_type() == T_FLOAT, \"must be float\");\n+  }\n+  virtual int Opcode() const;\n+};\n+\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -1082,0 +1082,10 @@\n+    public static final String VECTOR_CAST_F2HF = PREFIX + \"VECTOR_CAST_F2HF\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(VECTOR_CAST_F2HF, \"VectorCastF2HF\");\n+    }\n+\n+    public static final String VECTOR_CAST_HF2F = PREFIX + \"VECTOR_CAST_HF2F\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(VECTOR_CAST_HF2F, \"VectorCastHF2F\");\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,96 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8294588\n+ * @summary Auto-vectorize Float.floatToFloat16, Float.float16ToFloat APIs\n+ * @requires vm.compiler2.enabled\n+ * @requires vm.cpu.features ~= \".*avx2.*\"\n+ * @requires os.simpleArch == \"x64\"\n+ * @library \/test\/lib \/\n+ * @run driver compiler.vectorization.TestFloatConversionsVector\n+ *\/\n+\n+package compiler.vectorization;\n+\n+import compiler.lib.ir_framework.*;\n+\n+public class TestFloatConversionsVector {\n+  private static final int ARRLEN = 1024;\n+  private static final int ITERS  = 11000;\n+  private static float  [] finp;\n+  private static short  [] sout;\n+  private static short  [] sinp;\n+  private static float  [] fout;\n+\n+  public static void main(String args[]) {\n+      TestFramework.runWithFlags(\"-XX:-TieredCompilation\",\n+                                 \"-XX:CompileThresholdScaling=0.3\");\n+      System.out.println(\"PASSED\");\n+  }\n+\n+  @Test\n+  @IR(counts = {IRNode.VECTOR_CAST_F2HF, \"> 0\"}, applyIfCPUFeatureOr = {\"avx512f\", \"true\", \"f16c\", \"true\"})\n+  public void test_float_float16(short[] sout, float[] finp) {\n+      for (int i = 0; i < finp.length; i++) {\n+          sout[i] = Float.floatToFloat16(finp[i]);\n+      }\n+  }\n+\n+  @Run(test = {\"test_float_float16\"}, mode = RunMode.STANDALONE)\n+  public void kernel_test_float_float16() {\n+      finp = new float[ARRLEN];\n+      sout = new short[ARRLEN];\n+\n+      for (int i = 0; i < ARRLEN; i++) {\n+          finp[i] = (float) i * 1.4f;\n+      }\n+\n+      for (int i = 0; i < ITERS; i++) {\n+         test_float_float16(sout, finp);\n+      }\n+  }\n+\n+  @Test\n+  @IR(counts = {IRNode.VECTOR_CAST_HF2F, \"> 0\"}, applyIfCPUFeatureOr = {\"avx512f\", \"true\", \"f16c\", \"true\"})\n+  public void test_float16_float(float[] fout, short[] sinp) {\n+      for (int i = 0; i < sinp.length; i+=1) {\n+          fout[i] = Float.float16ToFloat(sinp[i]);\n+      }\n+  }\n+\n+  @Run(test = {\"test_float16_float\"}, mode = RunMode.STANDALONE)\n+  public void kernel_test_float16_float() {\n+      sinp = new short[ARRLEN];\n+      fout = new float[ARRLEN];\n+\n+      for (int i = 0; i < ARRLEN; i++) {\n+          sinp[i] = (short)i;\n+      }\n+\n+      for (int i = 0; i < ITERS; i++) {\n+          test_float16_float(fout , sinp);\n+      }\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestFloatConversionsVector.java","additions":96,"deletions":0,"binary":false,"changes":96,"status":"added"}]}