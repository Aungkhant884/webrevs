{"files":[{"patch":"@@ -1066,1 +1066,1 @@\n-  G1BarrierSet::dirty_card_queue_set().abandon_logs_and_stats();\n+  G1BarrierSet::dirty_card_queue_set().abandon_logs();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -533,1 +533,1 @@\n-void G1DirtyCardQueueSet::abandon_logs_and_stats() {\n+void G1DirtyCardQueueSet::abandon_logs() {\n@@ -535,0 +535,2 @@\n+  abandon_completed_buffers();\n+  _detached_refinement_stats.reset();\n@@ -539,1 +541,2 @@\n-  \/\/ Iterate over all the threads, resetting per-thread queues and stats.\n+  \/\/ Since abandon is done only at safepoints, we can safely manipulate\n+  \/\/ these queues.\n@@ -550,7 +553,0 @@\n-\n-  enqueue_all_paused_buffers();\n-  abandon_completed_buffers();\n-\n-  \/\/ Reset stats from detached threads.\n-  MutexLocker ml(G1DetachedRefinementStats_lock, Mutex::_no_safepoint_check_flag);\n-  _detached_refinement_stats.reset();\n@@ -559,1 +555,1 @@\n-void G1DirtyCardQueueSet::concatenate_logs_and_stats() {\n+void G1DirtyCardQueueSet::concatenate_logs() {\n@@ -569,5 +565,1 @@\n-    G1ConcurrentRefineStats _total_stats;\n-\n-    ConcatenateThreadLogClosure(G1DirtyCardQueueSet& qset) :\n-      _qset{qset}, _total_stats{} {}\n-\n+    ConcatenateThreadLogClosure(G1DirtyCardQueueSet& qset) : _qset(qset) {}\n@@ -576,2 +568,0 @@\n-      \/\/ Flush the buffer if non-empty.  Flush before accumulating and\n-      \/\/ resetting stats, since flushing may modify the stats.\n@@ -582,3 +572,0 @@\n-      G1ConcurrentRefineStats& qstats = *queue.refinement_stats();\n-      _total_stats += qstats;\n-      qstats.reset();\n@@ -588,1 +575,0 @@\n-  _concatenated_refinement_stats = closure._total_stats;\n@@ -592,0 +578,21 @@\n+}\n+\n+G1ConcurrentRefineStats G1DirtyCardQueueSet::get_and_reset_refinement_stats() {\n+  assert_at_safepoint();\n+\n+  \/\/ Since we're at a safepoint, there aren't any races with recording of\n+  \/\/ detached refinement stats.  In particular, there's no risk of double\n+  \/\/ counting a thread that detaches after we've examined it but before\n+  \/\/ we've processed the detached stats.\n+\n+  \/\/ Collect and reset stats for attached threads.\n+  struct CollectStats : public ThreadClosure {\n+    G1ConcurrentRefineStats _total_stats;\n+    virtual void do_thread(Thread* t) {\n+      G1DirtyCardQueue& dcq = G1ThreadLocalData::dirty_card_queue(t);\n+      G1ConcurrentRefineStats& stats = *dcq.refinement_stats();\n+      _total_stats += stats;\n+      stats.reset();\n+    }\n+  } closure;\n+  Threads::threads_do(&closure);\n@@ -595,1 +602,1 @@\n-  _concatenated_refinement_stats += _detached_refinement_stats;\n+  closure._total_stats += _detached_refinement_stats;\n@@ -597,1 +604,0 @@\n-}\n@@ -599,3 +605,1 @@\n-G1ConcurrentRefineStats G1DirtyCardQueueSet::concatenated_refinement_stats() const {\n-  assert_at_safepoint();\n-  return _concatenated_refinement_stats;\n+  return closure._total_stats;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1DirtyCardQueue.cpp","additions":30,"deletions":26,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -98,4 +98,4 @@\n-  \/\/ (such as concatenating or abandoning logs) also need to deal with any\n-  \/\/ paused buffers.  In general, if a safepoint performs a GC then the paused\n-  \/\/ buffers will be processed as part of it, and there won't be any paused\n-  \/\/ buffers after a GC safepoint.\n+  \/\/ (such as concatenate_logs) also need to deal with any paused buffers.  In\n+  \/\/ general, if a safepoint performs a GC then the paused buffers will be\n+  \/\/ processed as part of it, and there won't be any paused buffers after a\n+  \/\/ GC safepoint.\n@@ -178,1 +178,0 @@\n-  G1ConcurrentRefineStats _concatenated_refinement_stats;\n@@ -271,5 +270,3 @@\n-  \/\/ If a full collection is happening, reset per-thread refinement stats and\n-  \/\/ partial logs, and release completed logs. The full collection will make\n-  \/\/ them all irrelevant.\n-  \/\/ precondition: at safepoint.\n-  void abandon_logs_and_stats();\n+  \/\/ If a full collection is happening, reset partial logs, and release\n+  \/\/ completed ones: the full collection will make them all irrelevant.\n+  void abandon_logs();\n@@ -277,4 +274,2 @@\n-  \/\/ Collect and reset all the per-thread refinement stats.  If any threads\n-  \/\/ have partial logs then add them to the global list.\n-  \/\/ precondition: at safepoint.\n-  void concatenate_logs_and_stats();\n+  \/\/ If any threads have partial logs, add them to the global list of logs.\n+  void concatenate_logs();\n@@ -283,0 +278,1 @@\n+  \/\/ Also resets the stats for the threads.\n@@ -284,2 +280,1 @@\n-  \/\/ precondition: only call after concatenate_logs_and_stats.\n-  G1ConcurrentRefineStats concatenated_refinement_stats() const;\n+  G1ConcurrentRefineStats get_and_reset_refinement_stats();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1DirtyCardQueue.hpp","additions":11,"deletions":16,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -588,4 +588,3 @@\n-void G1Policy::record_concurrent_refinement_stats(size_t pending_cards,\n-                                                  size_t thread_buffer_cards) {\n-  _pending_cards_at_gc_start = pending_cards;\n-  _analytics->report_dirtied_cards_in_thread_buffers(thread_buffer_cards);\n+void G1Policy::record_concurrent_refinement_stats() {\n+  G1DirtyCardQueueSet& dcqs = G1BarrierSet::dirty_card_queue_set();\n+  _pending_cards_at_gc_start = dcqs.num_cards();\n@@ -594,2 +593,1 @@\n-  G1DirtyCardQueueSet& dcqs = G1BarrierSet::dirty_card_queue_set();\n-  G1ConcurrentRefineStats mut_stats = dcqs.concatenated_refinement_stats();\n+  G1ConcurrentRefineStats mut_stats = dcqs.get_and_reset_refinement_stats();\n@@ -632,0 +630,5 @@\n+void G1Policy::record_concatenate_dirty_card_logs(Tickspan concat_time, size_t num_cards) {\n+  _analytics->report_dirtied_cards_in_thread_buffers(num_cards);\n+  phase_times()->record_concatenate_dirty_card_logs_time_ms(concat_time.seconds() * MILLIUNITS);\n+}\n+\n@@ -646,0 +649,2 @@\n+  record_concurrent_refinement_stats();\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.cpp","additions":11,"deletions":6,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -281,0 +281,3 @@\n+  \/\/ Record and log stats before not-full collection.\n+  void record_concurrent_refinement_stats();\n+\n@@ -299,0 +302,2 @@\n+  void record_concatenate_dirty_card_logs(Tickspan concat_time, size_t num_cards);\n+\n@@ -396,6 +401,0 @@\n-  \/\/ Record and log stats and pending cards before not-full collection.\n-  \/\/ thread_buffer_cards is the number of cards that were in per-thread\n-  \/\/ buffers.  pending_cards includes thread_buffer_cards.\n-  void record_concurrent_refinement_stats(size_t pending_cards,\n-                                          size_t thread_buffer_cards);\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.hpp","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -470,1 +470,1 @@\n-void G1YoungCollector::concatenate_dirty_card_logs_and_stats() {\n+void G1YoungCollector::flush_dirty_card_queues() {\n@@ -474,6 +474,4 @@\n-  qset.concatenate_logs_and_stats();\n-  size_t pending_cards = qset.num_cards();\n-  size_t thread_buffer_cards = pending_cards - old_cards;\n-  policy()->record_concurrent_refinement_stats(pending_cards, thread_buffer_cards);\n-  double concat_time = (Ticks::now() - start).seconds() * MILLIUNITS;\n-  phase_times()->record_concatenate_dirty_card_logs_time_ms(concat_time);\n+  qset.concatenate_logs();\n+  size_t added_cards = qset.num_cards() - old_cards;\n+  Tickspan concat_time = Ticks::now() - start;\n+  policy()->record_concatenate_dirty_card_logs(concat_time, added_cards);\n@@ -498,0 +496,4 @@\n+  \/\/ Flush dirty card queues to qset, so later phases don't need to account\n+  \/\/ for partially filled per-thread queues and such.\n+  flush_dirty_card_queues();\n+\n@@ -1074,3 +1076,0 @@\n-    \/\/ Flush early, so later phases don't need to account for per-thread stuff.\n-    concatenate_dirty_card_logs_and_stats();\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungCollector.cpp","additions":9,"deletions":10,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -101,1 +101,1 @@\n-  void concatenate_dirty_card_logs_and_stats();\n+  void flush_dirty_card_queues();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungCollector.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}