{"files":[{"patch":"@@ -971,2 +971,2 @@\n-  Klass*    _participants[PARTICIPANT_LIMIT+1];\n-  int       _num_participants;\n+  Klass*  _participants[PARTICIPANT_LIMIT+1];\n+  uint    _num_participants;\n@@ -978,1 +978,1 @@\n-  int       _record_witnesses;\n+  uint    _record_witnesses;\n@@ -1015,1 +1015,1 @@\n-  ClassHierarchyWalker(Klass* participants[], int num_participants) {\n+  ClassHierarchyWalker(Klass* participants[], uint num_participants) {\n@@ -1019,1 +1019,1 @@\n-    for (int i = 0; i < num_participants; ++i) {\n+    for (uint i = 0; i < num_participants; ++i) {\n@@ -1031,2 +1031,2 @@\n-  Klass* participant(int n) {\n-    assert((uint)n <= (uint)_num_participants, \"oob\");\n+  Klass* participant(uint n) {\n+    assert(n <= _num_participants, \"oob\");\n@@ -1037,2 +1037,2 @@\n-  Method* found_method(int n) {\n-    assert((uint)n <= (uint)_num_participants, \"oob\");\n+  Method* found_method(uint n) {\n+    assert(n <= _num_participants, \"oob\");\n@@ -1051,54 +1051,0 @@\n-#ifdef ASSERT\n-  \/\/ Assert that m is inherited into ctxk, without intervening overrides.\n-  \/\/ (May return true even if this is not true, in corner cases where we punt.)\n-  bool check_method_context(InstanceKlass* ctxk, Method* m) {\n-    if (m->method_holder() == ctxk)\n-      return true;  \/\/ Quick win.\n-    if (m->is_private())\n-      return false; \/\/ Quick lose.  Should not happen.\n-    if (!(m->is_public() || m->is_protected()))\n-      \/\/ The override story is complex when packages get involved.\n-      return true;  \/\/ Must punt the assertion to true.\n-    Method* lm = ctxk->lookup_method(m->name(), m->signature());\n-    if (lm == NULL && ctxk->is_instance_klass()) {\n-      \/\/ It might be an interface method\n-      lm = InstanceKlass::cast(ctxk)->lookup_method_in_ordered_interfaces(m->name(),\n-                                                                          m->signature());\n-    }\n-    if (lm == m)\n-      \/\/ Method m is inherited into ctxk.\n-      return true;\n-    if (lm != NULL) {\n-      if (!(lm->is_public() || lm->is_protected())) {\n-        \/\/ Method is [package-]private, so the override story is complex.\n-        return true;  \/\/ Must punt the assertion to true.\n-      }\n-      if (lm->is_static()) {\n-        \/\/ Static methods don't override non-static so punt\n-        return true;\n-      }\n-      if (!Dependencies::is_concrete_method(lm, ctxk) &&\n-          !Dependencies::is_concrete_method(m, ctxk)) {\n-        \/\/ They are both non-concrete\n-        if (lm->method_holder()->is_subtype_of(m->method_holder())) {\n-          \/\/ Method m is overridden by lm, but both are non-concrete.\n-          return true;\n-        }\n-        if (lm->method_holder()->is_interface() && m->method_holder()->is_interface() &&\n-            ctxk->is_subtype_of(m->method_holder()) && ctxk->is_subtype_of(lm->method_holder())) {\n-          \/\/ Interface method defined in multiple super interfaces\n-          return true;\n-        }\n-      }\n-    }\n-    ResourceMark rm;\n-    tty->print_cr(\"Dependency method not found in the associated context:\");\n-    tty->print_cr(\"  context = %s\", ctxk->external_name());\n-    tty->print(   \"  method = \"); m->print_short_name(tty); tty->cr();\n-    if (lm != NULL) {\n-      tty->print( \"  found = \"); lm->print_short_name(tty); tty->cr();\n-    }\n-    return false;\n-  }\n-#endif\n-\n@@ -1107,1 +1053,1 @@\n-    int np = _num_participants++;\n+    uint np = _num_participants++;\n@@ -1113,1 +1059,1 @@\n-  void record_witnesses(int add) {\n+  void record_witnesses(uint add) {\n@@ -1284,0 +1230,57 @@\n+#ifdef ASSERT\n+\/\/ Assert that m is inherited into ctxk, without intervening overrides.\n+\/\/ (May return true even if this is not true, in corner cases where we punt.)\n+bool Dependencies::verify_method_context(InstanceKlass* ctxk, Method* m) {\n+  if (m->is_private()) {\n+    return false; \/\/ Quick lose.  Should not happen.\n+  }\n+  if (m->method_holder() == ctxk) {\n+    return true;  \/\/ Quick win.\n+  }\n+  if (!(m->is_public() || m->is_protected())) {\n+    \/\/ The override story is complex when packages get involved.\n+    return true;  \/\/ Must punt the assertion to true.\n+  }\n+  Method* lm = ctxk->lookup_method(m->name(), m->signature());\n+  if (lm == NULL && ctxk->is_instance_klass()) {\n+    \/\/ It might be an interface method\n+    lm = InstanceKlass::cast(ctxk)->lookup_method_in_ordered_interfaces(m->name(),\n+                                                                        m->signature());\n+  }\n+  if (lm == m) {\n+    \/\/ Method m is inherited into ctxk.\n+    return true;\n+  }\n+  if (lm != NULL) {\n+    if (!(lm->is_public() || lm->is_protected())) {\n+      \/\/ Method is [package-]private, so the override story is complex.\n+      return true;  \/\/ Must punt the assertion to true.\n+    }\n+    if (lm->is_static()) {\n+      \/\/ Static methods don't override non-static so punt\n+      return true;\n+    }\n+    if (!Dependencies::is_concrete_method(lm, ctxk) &&\n+        !Dependencies::is_concrete_method(m, ctxk)) {\n+      \/\/ They are both non-concrete\n+      if (lm->method_holder()->is_subtype_of(m->method_holder())) {\n+        \/\/ Method m is overridden by lm, but both are non-concrete.\n+        return true;\n+      }\n+      if (lm->method_holder()->is_interface() && m->method_holder()->is_interface() &&\n+          ctxk->is_subtype_of(m->method_holder()) && ctxk->is_subtype_of(lm->method_holder())) {\n+        \/\/ Interface method defined in multiple super interfaces\n+        return true;\n+      }\n+    }\n+  }\n+  ResourceMark rm;\n+  tty->print_cr(\"Dependency method not found in the associated context:\");\n+  tty->print_cr(\"  context = %s\", ctxk->external_name());\n+  tty->print(   \"  method = \"); m->print_short_name(tty); tty->cr();\n+  if (lm != NULL) {\n+    tty->print( \"  found = \"); lm->print_short_name(tty); tty->cr();\n+  }\n+  return false;\n+}\n+#endif \/\/ ASSERT\n@@ -1311,5 +1314,1 @@\n-      Klass* part = participant(i);\n-      if (part == NULL)  continue;\n-      assert(changes.involves_context(part) == new_type->is_subtype_of(part),\n-             \"correct marking of participants, b\/c new_type is unique\");\n-      if (changes.involves_context(part)) {\n+      if (changes.involves_context(participant(i))) {\n@@ -1395,12 +1394,21 @@\n-bool Dependencies::is_concrete_method(Method* m, Klass * k) {\n-  \/\/ NULL is not a concrete method,\n-  \/\/ statics are irrelevant to virtual call sites,\n-  \/\/ abstract methods are not concrete,\n-  \/\/ overpass (error) methods are not concrete if k is abstract\n-  \/\/\n-  \/\/ note \"true\" is conservative answer --\n-  \/\/     overpass clause is false if k == NULL, implies return true if\n-  \/\/     answer depends on overpass clause.\n-  return ! ( m == NULL || m -> is_static() || m -> is_abstract() ||\n-             (m->is_overpass() && k != NULL && k -> is_abstract()) );\n-}\n+bool Dependencies::is_concrete_method(Method* m, Klass* k) {\n+  \/\/ NULL is not a concrete method.\n+  if (m == NULL) {\n+    return false;\n+  }\n+  \/\/ Statics are irrelevant to virtual call sites.\n+  if (m->is_static()) {\n+    return false;\n+  }\n+  \/\/ Abstract methods are not concrete.\n+  if (m->is_abstract()) {\n+    return false;\n+  }\n+  \/\/ Overpass (error) methods are not concrete if k is abstract.\n+  if (m->is_overpass() && k != NULL) {\n+     return !k->is_abstract();\n+  }\n+  \/\/ Note \"true\" is conservative answer: overpass clause is false if k == NULL,\n+  \/\/ implies return true if answer depends on overpass clause.\n+  return true;\n+ }\n@@ -1541,1 +1549,1 @@\n-  assert(wf.check_method_context(ctxk, m), \"proper context\");\n+  assert(verify_method_context(ctxk, m), \"proper context\");\n","filename":"src\/hotspot\/share\/code\/dependencies.cpp","additions":91,"deletions":83,"binary":false,"changes":174,"status":"modified"},{"patch":"@@ -423,0 +423,4 @@\n+#ifdef ASSERT\n+  static bool verify_method_context(InstanceKlass* ctxk, Method* m);\n+#endif \/\/ ASSERT\n+\n@@ -722,1 +726,1 @@\n-  Klass* _new_type;\n+  InstanceKlass* _new_type;\n@@ -728,1 +732,1 @@\n-  KlassDepChange(Klass* new_type)\n+  KlassDepChange(InstanceKlass* new_type)\n@@ -744,1 +748,1 @@\n-  Klass* new_type() { return _new_type; }\n+  InstanceKlass* new_type() { return _new_type; }\n","filename":"src\/hotspot\/share\/code\/dependencies.hpp","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"}]}