{"files":[{"patch":"@@ -82,1 +82,4 @@\n-          \"Use CPU_ALLOC code path in os::active_processor_count \")\n+          \"Use CPU_ALLOC code path in os::active_processor_count \")     \\\n+                                                                        \\\n+  product(bool, DumpPerfMapAtExit, false, DIAGNOSTIC,                   \\\n+          \"Write map file for Linux perf tool at exit\")\n","filename":"src\/hotspot\/os\/linux\/globals_linux.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -4638,0 +4638,6 @@\n+  if (DumpPerfMapAtExit && FLAG_IS_DEFAULT(UseCodeCacheFlushing)) {\n+    \/\/ Disable code cache flushing to ensure the map file written at\n+    \/\/ exit contains all nmethods generated during execution.\n+    FLAG_SET_DEFAULT(UseCodeCacheFlushing, false);\n+  }\n+\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1562,0 +1562,28 @@\n+#ifdef LINUX\n+void CodeCache::write_perf_map() {\n+  MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);\n+\n+  \/\/ Perf expects to find the map file at \/tmp\/perf-<pid>.map.\n+  char fname[32];\n+  jio_snprintf(fname, sizeof(fname), \"\/tmp\/perf-%d.map\", os::current_process_id());\n+\n+  fileStream fs(fname, \"w\");\n+  if (!fs.is_open()) {\n+    log_warning(codecache)(\"Failed to create %s for perf map\", fname);\n+    return;\n+  }\n+\n+  AllCodeBlobsIterator iter(AllCodeBlobsIterator::only_alive_and_not_unloading);\n+  while (iter.next()) {\n+    CodeBlob *cb = iter.method();\n+    ResourceMark rm;\n+    const char* method_name =\n+      cb->is_compiled() ? cb->as_compiled_method()->method()->external_name()\n+                        : cb->name();\n+    fs.print_cr(INTPTR_FORMAT \" \" INTPTR_FORMAT \" %s\",\n+                (intptr_t)cb->code_begin(), (intptr_t)cb->code_size(),\n+                method_name);\n+  }\n+}\n+#endif \/\/ LINUX\n+\n","filename":"src\/hotspot\/share\/code\/codeCache.cpp","additions":28,"deletions":0,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -194,0 +194,1 @@\n+  LINUX_ONLY(static void write_perf_map();)\n@@ -412,0 +413,5 @@\n+struct AllCodeBlobsFilter {\n+  static bool apply(CodeBlob* cb) { return true; }\n+  static const GrowableArray<CodeHeap*>* heaps() { return CodeCache::heaps(); }\n+};\n+\n@@ -414,0 +420,1 @@\n+typedef CodeBlobIterator<CodeBlob, AllCodeBlobsFilter> AllCodeBlobsIterator;\n","filename":"src\/hotspot\/share\/code\/codeCache.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -481,0 +481,6 @@\n+#ifdef LINUX\n+  if (DumpPerfMapAtExit) {\n+    CodeCache::write_perf_map();\n+  }\n+#endif\n+\n","filename":"src\/hotspot\/share\/runtime\/java.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -113,0 +113,3 @@\n+#ifdef LINUX\n+  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<PerfMapDCmd>(full_export, true, false));\n+#endif \/\/ LINUX\n@@ -896,0 +899,6 @@\n+#ifdef LINUX\n+void PerfMapDCmd::execute(DCmdSource source, TRAPS) {\n+  CodeCache::write_perf_map();\n+}\n+#endif \/\/ LINUX\n+\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -580,0 +580,23 @@\n+#ifdef LINUX\n+class PerfMapDCmd : public DCmd {\n+public:\n+  PerfMapDCmd(outputStream* output, bool heap) : DCmd(output, heap) {}\n+  static const char* name() {\n+    return \"Compiler.perfmap\";\n+  }\n+  static const char* description() {\n+    return \"Write map file for Linux perf tool.\";\n+  }\n+  static const char* impact() {\n+    return \"Low\";\n+  }\n+  static const JavaPermission permission() {\n+    JavaPermission p = {\"java.lang.management.ManagementPermission\",\n+                        \"monitor\", NULL};\n+    return p;\n+  }\n+  static int num_arguments() { return 0; }\n+  virtual void execute(DCmdSource source, TRAPS);\n+};\n+#endif \/\/ LINUX\n+\n@@ -601,1 +624,0 @@\n-\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.hpp","additions":23,"deletions":1,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -0,0 +1,87 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test PerfMapTest\n+ * @bug 8254723\n+ * @requires os.family == \"linux\"\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.compiler\n+ *          java.management\n+ *          jdk.internal.jvmstat\/sun.jvmstat.monitor\n+ * @run testng\/othervm PerfMapTest\n+ * @summary Test of diagnostic command Compiler.perfmap\n+ *\/\n+\n+import org.testng.annotations.Test;\n+import org.testng.Assert;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.dcmd.CommandExecutor;\n+import jdk.test.lib.dcmd.JMXExecutor;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+\/**\n+ * Call jcmd Compiler.perfmap and check the output file has the expected\n+ * format.\n+ *\/\n+public class PerfMapTest {\n+\n+    static final Pattern LINE_PATTERN =\n+        Pattern.compile(\"^((?:0x)?\\\\p{XDigit}+)\\\\s+((?:0x)?\\\\p{XDigit}+)\\\\s+(.*)$\");\n+\n+    public void run(CommandExecutor executor) {\n+        OutputAnalyzer output = executor.execute(\"Compiler.perfmap\");\n+\n+        output.stderrShouldBeEmpty();\n+        output.stdoutShouldBeEmpty();\n+\n+        final long pid = ProcessHandle.current().pid();\n+        final Path path = Paths.get(String.format(\"\/tmp\/perf-%d.map\", pid));\n+\n+        Assert.assertTrue(Files.exists(path));\n+\n+        \/\/ Sanity check the file contents\n+        try {\n+            for (String entry : Files.readAllLines(path)) {\n+                Matcher m = LINE_PATTERN.matcher(entry);\n+                Assert.assertTrue(m.matches(), \"Invalid file format: \" + entry);\n+            }\n+        } catch (IOException e) {\n+            Assert.fail(e.toString());\n+        }\n+    }\n+\n+    @Test\n+    public void jmx() {\n+        run(new JMXExecutor());\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/dcmd\/compiler\/PerfMapTest.java","additions":87,"deletions":0,"binary":false,"changes":87,"status":"added"}]}