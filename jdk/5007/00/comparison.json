{"files":[{"patch":"@@ -129,0 +129,4 @@\n+    \/\/ Maintenance note: check if the default implementation of\n+    \/\/ Elements.getOutermostTypeElement needs updating when new kind\n+    \/\/ constants are added.\n+\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/element\/ElementKind.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -536,0 +536,61 @@\n+    \/**\n+     * {@return the outermost type element an element is contained in\n+     * if such a containing element exists; otherwise returns {@code\n+     * null}}\n+     *\n+     * {@linkplain ModuleElement Modules} and {@linkplain\n+     * PackageElement packages} do <em>not<\/em> have a containing type\n+     * element and therefore {@code null} is returned for those kinds\n+     * of elements.\n+     *\n+     * A {@link NestingKind#TOP_LEVEL top-level} class or\n+     * interface is its own outermost type element.\n+     *\n+     * @implSpec\n+     * The default implementation of this method first checks the kind\n+     * of the argument. For elements of kind {@code PACKAGE}, {@code\n+     * MODULE}, and {@code OTHER}, {@code null} is returned. For\n+     * elements of other kinds, the element is examined to see if it\n+     * is a top-level class or interface. If so, that element is\n+     * returned; otherwise, the {@linkplain\n+     * Element#getEnclosingElement enclosing element} chain is\n+     * followed until a top-level class or interface is found. The\n+     * element for the eventual top-level class or interface is\n+     * returned.\n+     *\n+     * @param e the element being examined\n+     * @see Element#getEnclosingElement\n+     * @since 18\n+     *\/\n+    default TypeElement getOutermostTypeElement(Element e) {\n+        return switch (e.getKind()) {\n+        case PACKAGE,\n+             MODULE  -> null; \/\/ Per the general spec above.\n+        case OTHER   -> null; \/\/ Outside of base model of the javax.lang.model API\n+\n+        \/\/ Elements of all remaining kinds should be enclosed in some\n+        \/\/ sort of class or interface. Check to see if the element is\n+        \/\/ a top-level type; if so, return it. Otherwise, keep going\n+        \/\/ up the enclosing element chain until a top-level type is\n+        \/\/ found.\n+        default -> {\n+            Element enclosing = e;\n+            \/\/ This implementation is susceptible to infinite loops\n+            \/\/ for misbehaving element implementations.\n+            while (true) {\n+                \/\/ Conceptual instanceof TypeElment check. If the\n+                \/\/ argument is a type element, put it into a\n+                \/\/ one-element list, otherwise an empty list.\n+                List<TypeElement> possibleTypeElement = ElementFilter.typesIn(List.of(enclosing));\n+                if (!possibleTypeElement.isEmpty()) {\n+                    TypeElement typeElement = possibleTypeElement.get(0);\n+                    if (typeElement.getNestingKind() == NestingKind.TOP_LEVEL) {\n+                        yield typeElement;\n+                    }\n+                }\n+                enclosing = enclosing.getEnclosingElement();\n+            }\n+        }\n+        };\n+    }\n+\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/Elements.java","additions":61,"deletions":0,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -574,0 +574,6 @@\n+    @DefinedBy(Api.LANGUAGE_MODEL)\n+    public TypeElement getOutermostTypeElement(Element e) {\n+        Symbol sym = cast(Symbol.class, e);\n+        return sym.outermostClass();\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/model\/JavacElements.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -24,0 +24,1 @@\n+import java.io.Writer;\n@@ -27,0 +28,1 @@\n+import javax.lang.model.element.*;\n@@ -267,0 +269,56 @@\n+\n+    \/**\n+     * Vacuous implementation of javax.lang.model.util.Elements to aid\n+     * in test development. Methods with defaults in the interface are\n+     * *not* overridden to allow them to be tested.\n+     *\/\n+    public static class VacuousElements implements Elements {\n+        public VacuousElements() {}\n+\n+        @Override\n+        public PackageElement getPackageElement(CharSequence name) {return null;}\n+\n+        @Override\n+        public TypeElement getTypeElement(CharSequence name) {return null;}\n+\n+        @Override\n+        public Map<? extends ExecutableElement, ? extends AnnotationValue>\n+                                                          getElementValuesWithDefaults(AnnotationMirror a) {return null;}\n+        @Override\n+        public String getDocComment(Element e) {return null;}\n+\n+        @Override\n+        public boolean isDeprecated(Element e) {return false;}\n+\n+        @Override\n+        public  Name getBinaryName(TypeElement type) {return null;}\n+\n+        @Override\n+        public PackageElement getPackageOf(Element e) {return null;}\n+\n+        @Override\n+        public List<? extends Element> getAllMembers(TypeElement type) {return null;}\n+\n+        @Override\n+        public List<? extends AnnotationMirror> getAllAnnotationMirrors(Element e) {return null;}\n+\n+        @Override\n+        public boolean hides(Element hider, Element hidden) {return false;}\n+\n+        @Override\n+        public boolean overrides(ExecutableElement overrider,\n+                             ExecutableElement overridden,\n+                             TypeElement type) {return false;}\n+\n+        @Override\n+        public String getConstantExpression(Object value) {return null;}\n+\n+        @Override\n+        public void printElements(Writer w, Element... elements) {}\n+\n+        @Override\n+        public Name getName(CharSequence cs)  {return null;}\n+\n+        @Override\n+        public boolean isFunctionalInterface(TypeElement type) {return false;}\n+    }\n","filename":"test\/langtools\/tools\/javac\/lib\/JavacTestingAbstractProcessor.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-            if ((new TestElements()).isAutomaticModule(null) != false) {\n+            if ((new VacuousElements()).isAutomaticModule(null) != false) {\n@@ -71,53 +71,0 @@\n-\n-    \/\/ Use default methods of javax.lang.model.util.Elements; define\n-    \/\/ vacuous methods to override the abstract methods.\n-    private static class TestElements implements Elements {\n-        public TestElements() {}\n-\n-        @Override\n-        public PackageElement getPackageElement(CharSequence name) {return null;}\n-\n-        @Override\n-        public TypeElement getTypeElement(CharSequence name) {return null;}\n-\n-        @Override\n-        public Map<? extends ExecutableElement, ? extends AnnotationValue>\n-                                                          getElementValuesWithDefaults(AnnotationMirror a) {return null;}\n-        @Override\n-        public String getDocComment(Element e) {return null;}\n-\n-        @Override\n-        public boolean isDeprecated(Element e) {return false;}\n-\n-        @Override\n-        public  Name getBinaryName(TypeElement type) {return null;}\n-\n-        @Override\n-        public PackageElement getPackageOf(Element e) {return null;}\n-\n-        @Override\n-        public List<? extends Element> getAllMembers(TypeElement type) {return null;}\n-\n-        @Override\n-        public List<? extends AnnotationMirror> getAllAnnotationMirrors(Element e) {return null;}\n-\n-        @Override\n-        public boolean hides(Element hider, Element hidden) {return false;}\n-\n-        @Override\n-        public boolean overrides(ExecutableElement overrider,\n-                             ExecutableElement overridden,\n-                             TypeElement type) {return false;}\n-\n-        @Override\n-        public String getConstantExpression(Object value) {return null;}\n-\n-        @Override\n-        public void printElements(Writer w, Element... elements) {}\n-\n-        @Override\n-        public Name getName(CharSequence cs)  {return null;}\n-\n-        @Override\n-        public boolean isFunctionalInterface(TypeElement type) {return false;}\n-    }\n","filename":"test\/langtools\/tools\/javac\/processing\/model\/util\/elements\/TestIsAutomaticMod.java","additions":1,"deletions":54,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -0,0 +1,139 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8140442\n+ * @summary Test Elements.getOutermostTypeElement\n+ * @library \/tools\/javac\/lib\n+ * @build   JavacTestingAbstractProcessor TestOutermostTypeElement\n+ * @compile -processor TestOutermostTypeElement -proc:only TestOutermostTypeElement.java\n+ *\/\n+\n+import java.io.Writer;\n+import java.util.*;\n+import javax.annotation.processing.*;\n+import javax.lang.model.element.*;\n+import javax.lang.model.util.*;\n+\n+\/**\n+ * Test basic workings of Elements.getOutermostTypeElement\n+ *\/\n+public class TestOutermostTypeElement extends JavacTestingAbstractProcessor {\n+    public boolean process(Set<? extends TypeElement> annotations,\n+                           RoundEnvironment roundEnv) {\n+        if (!roundEnv.processingOver()) {\n+            Elements vacuousElts = new VacuousElements();\n+\n+            ModuleElement javaBaseMod = eltUtils.getModuleElement(\"java.base\");\n+            checkOuter(javaBaseMod, null, vacuousElts);\n+            checkOuter(javaBaseMod, null, eltUtils);\n+\n+            PackageElement javaLangPkg = eltUtils.getPackageElement(\"java.lang\");\n+            checkOuter(javaLangPkg, null, vacuousElts);\n+            checkOuter(javaLangPkg, null, eltUtils);\n+\n+            \/\/ Starting from the root elements, traverse over all\n+            \/\/ enclosed elements and type parameters. The outermost\n+            \/\/ enclosing type element such equal the root\n+            \/\/ element. This traversal does not hit elements\n+            \/\/ corresponding to structures inside of a method.\n+            for (TypeElement e : ElementFilter.typesIn(roundEnv.getRootElements()) ) {\n+                var outerScaner = new OuterScanner(e);\n+                outerScaner.scan(e, vacuousElts);\n+                outerScaner.scan(e, eltUtils);\n+             }\n+        }\n+        return true;\n+    }\n+\n+    private class OuterScanner extends ElementScanner<Void, Elements> {\n+        private TypeElement expectedOuter;\n+        public OuterScanner(TypeElement expectedOuter) {\n+            this.expectedOuter = expectedOuter;\n+        }\n+\n+        @Override\n+        public Void scan(Element e, Elements elts) {\n+            \/\/ System.out.println(e.getSimpleName() + \" \" + e.getKind());\n+            checkOuter(e, expectedOuter, elts);\n+            super.scan(e, elts);\n+            return null;\n+        }\n+    }\n+\n+    private void checkOuter(Element e, TypeElement expectedOuter, Elements elts) {\n+        var actualOuter = elts.getOutermostTypeElement(e);\n+        if (!Objects.equals(actualOuter, expectedOuter)) {\n+            throw new RuntimeException(String.format(\"Unexpected outermost ``%s''' for %s, expected ``%s.''%n\",\n+                                                     actualOuter,\n+                                                     e,\n+                                                     expectedOuter));\n+        }\n+    }\n+}\n+\n+\/**\n+ * Outer class to host a variety of kinds of inner elements with Outer\n+ * as their outermost class.\n+ *\/\n+class Outer {\n+    private Outer() {}\n+\n+    public enum InnerEnum {\n+        VALUE1,\n+        VALUE2;\n+\n+        private int field;\n+    }\n+\n+    public static class InnerClass {\n+        private static int field;\n+        static {\n+            field = 5;\n+        }\n+\n+        public <C> InnerClass(C c) {}\n+\n+        void foo() {return;}\n+        static void bar() {return;}\n+        static <R> R baz(Class<? extends R> clazz) {return null;}\n+\n+        private class InnerInnerClass {\n+            public InnerInnerClass() {}\n+        }\n+    }\n+\n+    public interface InnerInterface {\n+        final int field = 42;\n+        void foo();\n+    }\n+\n+    public @interface InnerAnnotation {\n+        int value() default 1;\n+    }\n+\n+    public record InnerRecord(double rpm, double diameter) {\n+        void foo() {return;}\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/processing\/model\/util\/elements\/TestOutermostTypeElement.java","additions":139,"deletions":0,"binary":false,"changes":139,"status":"added"}]}