{"files":[{"patch":"@@ -159,1 +159,1 @@\n-#define SCOPE PKG_FOREIGN \"MemorySessionImpl;\"\n+#define SCOPE PKG_FOREIGN \"MemorySessionImpl$State;\"\n@@ -165,1 +165,1 @@\n-    {CC \"closeScope0\",   CC \"(\" SCOPE \")Z\",           FN_PTR(ScopedMemoryAccess_closeScope)},\n+    {CC \"closeScope\",   CC \"(\" SCOPE \")Z\",           FN_PTR(ScopedMemoryAccess_closeScope)},\n","filename":"src\/hotspot\/share\/prims\/scopedMemoryAccess.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1079,3 +1079,3 @@\n-            ScopedMemoryAccess.getScopedMemoryAccess().copyMemory(srcImpl.sessionImpl(), dstImpl.sessionImpl(),\n-                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffset,\n-                    dstImpl.unsafeGetBase(), dstImpl.unsafeGetOffset() + dstOffset, size);\n+            ScopedMemoryAccess.getScopedMemoryAccess().copyMemory(srcImpl.session().state(), dstImpl.session().state(),\n+                    srcImpl.base(), srcImpl.min() + srcOffset,\n+                    dstImpl.base(), dstImpl.min() + dstOffset, size);\n@@ -1083,3 +1083,3 @@\n-            ScopedMemoryAccess.getScopedMemoryAccess().copySwapMemory(srcImpl.sessionImpl(), dstImpl.sessionImpl(),\n-                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffset,\n-                    dstImpl.unsafeGetBase(), dstImpl.unsafeGetOffset() + dstOffset, size, srcElementLayout.byteSize());\n+            ScopedMemoryAccess.getScopedMemoryAccess().copySwapMemory(srcImpl.session().state(), dstImpl.session().state(),\n+                    srcImpl.base(), srcImpl.min() + srcOffset,\n+                    dstImpl.base(), dstImpl.min() + dstOffset, size, srcElementLayout.byteSize());\n@@ -1892,2 +1892,2 @@\n-            ScopedMemoryAccess.getScopedMemoryAccess().copyMemory(srcImpl.sessionImpl(), null,\n-                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffset,\n+            ScopedMemoryAccess.getScopedMemoryAccess().copyMemory(srcImpl.session().state(), null,\n+                    srcImpl.base(), srcImpl.min() + srcOffset,\n@@ -1896,2 +1896,2 @@\n-            ScopedMemoryAccess.getScopedMemoryAccess().copySwapMemory(srcImpl.sessionImpl(), null,\n-                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffset,\n+            ScopedMemoryAccess.getScopedMemoryAccess().copySwapMemory(srcImpl.session().state(), null,\n+                    srcImpl.base(), srcImpl.min() + srcOffset,\n@@ -1944,1 +1944,1 @@\n-            ScopedMemoryAccess.getScopedMemoryAccess().copyMemory(null, destImpl.sessionImpl(),\n+            ScopedMemoryAccess.getScopedMemoryAccess().copyMemory(null, destImpl.session().state(),\n@@ -1946,1 +1946,1 @@\n-                    destImpl.unsafeGetBase(), destImpl.unsafeGetOffset() + dstOffset, elementCount * srcWidth);\n+                    destImpl.base(), destImpl.min() + dstOffset, elementCount * srcWidth);\n@@ -1948,1 +1948,1 @@\n-            ScopedMemoryAccess.getScopedMemoryAccess().copySwapMemory(null, destImpl.sessionImpl(),\n+            ScopedMemoryAccess.getScopedMemoryAccess().copySwapMemory(null, destImpl.session().state(),\n@@ -1950,1 +1950,1 @@\n-                    destImpl.unsafeGetBase(), destImpl.unsafeGetOffset() + dstOffset, elementCount * srcWidth, srcWidth);\n+                    destImpl.base(), destImpl.min() + dstOffset, elementCount * srcWidth, srcWidth);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemorySegment.java","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -130,1 +130,1 @@\n-public sealed interface MemorySession extends AutoCloseable, SegmentAllocator permits MemorySessionImpl, MemorySessionImpl.NonCloseableView {\n+public sealed interface MemorySession extends AutoCloseable, SegmentAllocator permits MemorySessionImpl {\n@@ -275,1 +275,1 @@\n-        return MemorySessionImpl.createImplicit();\n+        return MemorySessionImpl.createImplicit(null);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemorySession.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -238,1 +238,1 @@\n-        MemorySessionImpl.toSessionImpl(session).addOrCleanupIfFail(new MemorySessionImpl.ResourceList.ResourceCleanup() {\n+        MemorySessionImpl.addOrCleanupIfFail(session, new MemorySessionImpl.State.ResourceCleanup() {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/SymbolLookup.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -617,1 +617,1 @@\n-        static MemorySessionImpl session(ByteBuffer bb) {\n+        static MemorySessionImpl.State state(ByteBuffer bb) {\n@@ -620,1 +620,1 @@\n-                    ((AbstractMemorySegmentImpl)segment).sessionImpl() : null;\n+                    ((AbstractMemorySegmentImpl)segment).session().state() : null;\n@@ -643,1 +643,1 @@\n-            $rawType$ rawValue = SCOPED_MEMORY_ACCESS.get$RawType$Unaligned(session(bb),\n+            $rawType$ rawValue = SCOPED_MEMORY_ACCESS.get$RawType$Unaligned(state(bb),\n@@ -649,1 +649,1 @@\n-            return SCOPED_MEMORY_ACCESS.get$Type$Unaligned(session(bb),\n+            return SCOPED_MEMORY_ACCESS.get$Type$Unaligned(state(bb),\n@@ -661,1 +661,1 @@\n-            SCOPED_MEMORY_ACCESS.put$RawType$Unaligned(session(bb),\n+            SCOPED_MEMORY_ACCESS.put$RawType$Unaligned(state(bb),\n@@ -667,1 +667,1 @@\n-            SCOPED_MEMORY_ACCESS.put$Type$Unaligned(session(bb),\n+            SCOPED_MEMORY_ACCESS.put$Type$Unaligned(state(bb),\n@@ -680,1 +680,1 @@\n-                              SCOPED_MEMORY_ACCESS.get$RawType$Volatile(session(bb),\n+                              SCOPED_MEMORY_ACCESS.get$RawType$Volatile(state(bb),\n@@ -689,1 +689,1 @@\n-            SCOPED_MEMORY_ACCESS.put$RawType$Volatile(session(bb),\n+            SCOPED_MEMORY_ACCESS.put$RawType$Volatile(state(bb),\n@@ -700,1 +700,1 @@\n-                              SCOPED_MEMORY_ACCESS.get$RawType$Acquire(session(bb),\n+                              SCOPED_MEMORY_ACCESS.get$RawType$Acquire(state(bb),\n@@ -709,1 +709,1 @@\n-            SCOPED_MEMORY_ACCESS.put$RawType$Release(session(bb),\n+            SCOPED_MEMORY_ACCESS.put$RawType$Release(state(bb),\n@@ -720,1 +720,1 @@\n-                              SCOPED_MEMORY_ACCESS.get$RawType$Opaque(session(bb),\n+                              SCOPED_MEMORY_ACCESS.get$RawType$Opaque(state(bb),\n@@ -729,1 +729,1 @@\n-            SCOPED_MEMORY_ACCESS.put$RawType$Opaque(session(bb),\n+            SCOPED_MEMORY_ACCESS.put$RawType$Opaque(state(bb),\n@@ -741,1 +741,1 @@\n-            return SCOPED_MEMORY_ACCESS.compareAndSetReference(session(bb),\n+            return SCOPED_MEMORY_ACCESS.compareAndSetReference(state(bb),\n@@ -746,1 +746,1 @@\n-            return SCOPED_MEMORY_ACCESS.compareAndSet$RawType$(session(bb),\n+            return SCOPED_MEMORY_ACCESS.compareAndSet$RawType$(state(bb),\n@@ -758,1 +758,1 @@\n-                              SCOPED_MEMORY_ACCESS.compareAndExchange$RawType$(session(bb),\n+                              SCOPED_MEMORY_ACCESS.compareAndExchange$RawType$(state(bb),\n@@ -769,1 +769,1 @@\n-                              SCOPED_MEMORY_ACCESS.compareAndExchange$RawType$Acquire(session(bb),\n+                              SCOPED_MEMORY_ACCESS.compareAndExchange$RawType$Acquire(state(bb),\n@@ -780,1 +780,1 @@\n-                              SCOPED_MEMORY_ACCESS.compareAndExchange$RawType$Release(session(bb),\n+                              SCOPED_MEMORY_ACCESS.compareAndExchange$RawType$Release(state(bb),\n@@ -790,1 +790,1 @@\n-            return SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$Plain(session(bb),\n+            return SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$Plain(state(bb),\n@@ -800,1 +800,1 @@\n-            return SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$(session(bb),\n+            return SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$(state(bb),\n@@ -810,1 +810,1 @@\n-            return SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$Acquire(session(bb),\n+            return SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$Acquire(state(bb),\n@@ -820,1 +820,1 @@\n-            return SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$Release(session(bb),\n+            return SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$Release(state(bb),\n@@ -832,1 +832,1 @@\n-                              SCOPED_MEMORY_ACCESS.getAndSetReference(session(bb),\n+                              SCOPED_MEMORY_ACCESS.getAndSetReference(state(bb),\n@@ -838,1 +838,1 @@\n-                              SCOPED_MEMORY_ACCESS.getAndSet$RawType$(session(bb),\n+                              SCOPED_MEMORY_ACCESS.getAndSet$RawType$(state(bb),\n@@ -850,1 +850,1 @@\n-                              SCOPED_MEMORY_ACCESS.getAndSet$RawType$Acquire(session(bb),\n+                              SCOPED_MEMORY_ACCESS.getAndSet$RawType$Acquire(state(bb),\n@@ -861,1 +861,1 @@\n-                              SCOPED_MEMORY_ACCESS.getAndSet$RawType$Release(session(bb),\n+                              SCOPED_MEMORY_ACCESS.getAndSet$RawType$Release(state(bb),\n@@ -874,1 +874,1 @@\n-                return SCOPED_MEMORY_ACCESS.getAndAdd$RawType$(session(bb),\n+                return SCOPED_MEMORY_ACCESS.getAndAdd$RawType$(state(bb),\n@@ -888,1 +888,1 @@\n-                return SCOPED_MEMORY_ACCESS.getAndAdd$RawType$Acquire(session(bb),\n+                return SCOPED_MEMORY_ACCESS.getAndAdd$RawType$Acquire(state(bb),\n@@ -902,1 +902,1 @@\n-                return SCOPED_MEMORY_ACCESS.getAndAdd$RawType$Release(session(bb),\n+                return SCOPED_MEMORY_ACCESS.getAndAdd$RawType$Release(state(bb),\n@@ -917,1 +917,1 @@\n-                nativeExpectedValue = SCOPED_MEMORY_ACCESS.get$RawType$Volatile(session(bb), base, offset);\n+                nativeExpectedValue = SCOPED_MEMORY_ACCESS.get$RawType$Volatile(state(bb), base, offset);\n@@ -931,1 +931,1 @@\n-                return SCOPED_MEMORY_ACCESS.getAndBitwiseOr$RawType$(session(bb),\n+                return SCOPED_MEMORY_ACCESS.getAndBitwiseOr$RawType$(state(bb),\n@@ -945,1 +945,1 @@\n-                return SCOPED_MEMORY_ACCESS.getAndBitwiseOr$RawType$Release(session(bb),\n+                return SCOPED_MEMORY_ACCESS.getAndBitwiseOr$RawType$Release(state(bb),\n@@ -959,1 +959,1 @@\n-                return SCOPED_MEMORY_ACCESS.getAndBitwiseOr$RawType$Acquire(session(bb),\n+                return SCOPED_MEMORY_ACCESS.getAndBitwiseOr$RawType$Acquire(state(bb),\n@@ -974,1 +974,1 @@\n-                nativeExpectedValue = SCOPED_MEMORY_ACCESS.get$RawType$Volatile(session(bb), base, offset);\n+                nativeExpectedValue = SCOPED_MEMORY_ACCESS.get$RawType$Volatile(state(bb), base, offset);\n@@ -986,1 +986,1 @@\n-                return SCOPED_MEMORY_ACCESS.getAndBitwiseAnd$RawType$(session(bb),\n+                return SCOPED_MEMORY_ACCESS.getAndBitwiseAnd$RawType$(state(bb),\n@@ -1000,1 +1000,1 @@\n-                return SCOPED_MEMORY_ACCESS.getAndBitwiseAnd$RawType$Release(session(bb),\n+                return SCOPED_MEMORY_ACCESS.getAndBitwiseAnd$RawType$Release(state(bb),\n@@ -1014,1 +1014,1 @@\n-                return SCOPED_MEMORY_ACCESS.getAndBitwiseAnd$RawType$Acquire(session(bb),\n+                return SCOPED_MEMORY_ACCESS.getAndBitwiseAnd$RawType$Acquire(state(bb),\n@@ -1029,1 +1029,1 @@\n-                nativeExpectedValue = SCOPED_MEMORY_ACCESS.get$RawType$Volatile(session(bb), base, offset);\n+                nativeExpectedValue = SCOPED_MEMORY_ACCESS.get$RawType$Volatile(state(bb), base, offset);\n@@ -1042,1 +1042,1 @@\n-                return SCOPED_MEMORY_ACCESS.getAndBitwiseXor$RawType$(session(bb),\n+                return SCOPED_MEMORY_ACCESS.getAndBitwiseXor$RawType$(state(bb),\n@@ -1056,1 +1056,1 @@\n-                return SCOPED_MEMORY_ACCESS.getAndBitwiseXor$RawType$Release(session(bb),\n+                return SCOPED_MEMORY_ACCESS.getAndBitwiseXor$RawType$Release(state(bb),\n@@ -1070,1 +1070,1 @@\n-                return SCOPED_MEMORY_ACCESS.getAndBitwiseXor$RawType$Acquire(session(bb),\n+                return SCOPED_MEMORY_ACCESS.getAndBitwiseXor$RawType$Acquire(state(bb),\n@@ -1085,1 +1085,1 @@\n-                nativeExpectedValue = SCOPED_MEMORY_ACCESS.get$RawType$Volatile(session(bb), base, offset);\n+                nativeExpectedValue = SCOPED_MEMORY_ACCESS.get$RawType$Volatile(state(bb), base, offset);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/X-VarHandleByteArrayView.java.template","additions":41,"deletions":41,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -117,1 +117,1 @@\n-        long base = bb.unsafeGetOffset();\n+        long base = bb.min();\n@@ -131,2 +131,2 @@\n-        $rawType$ rawValue = SCOPED_MEMORY_ACCESS.get$RawType$Unaligned(bb.sessionImpl(),\n-                bb.unsafeGetBase(),\n+        $rawType$ rawValue = SCOPED_MEMORY_ACCESS.get$RawType$Unaligned(bb.session().state(),\n+                bb.base(),\n@@ -138,2 +138,2 @@\n-        return SCOPED_MEMORY_ACCESS.get$Type$(bb.sessionImpl(),\n-                bb.unsafeGetBase(),\n+        return SCOPED_MEMORY_ACCESS.get$Type$(bb.session().state(),\n+                bb.base(),\n@@ -142,2 +142,2 @@\n-        return SCOPED_MEMORY_ACCESS.get$Type$Unaligned(bb.sessionImpl(),\n-                bb.unsafeGetBase(),\n+        return SCOPED_MEMORY_ACCESS.get$Type$Unaligned(bb.session().state(),\n+                bb.base(),\n@@ -155,2 +155,2 @@\n-        SCOPED_MEMORY_ACCESS.put$RawType$Unaligned(bb.sessionImpl(),\n-                bb.unsafeGetBase(),\n+        SCOPED_MEMORY_ACCESS.put$RawType$Unaligned(bb.session().state(),\n+                bb.base(),\n@@ -162,2 +162,2 @@\n-        SCOPED_MEMORY_ACCESS.put$Type$(bb.sessionImpl(),\n-                bb.unsafeGetBase(),\n+        SCOPED_MEMORY_ACCESS.put$Type$(bb.session().state(),\n+                bb.base(),\n@@ -167,2 +167,2 @@\n-        SCOPED_MEMORY_ACCESS.put$Type$Unaligned(bb.sessionImpl(),\n-                bb.unsafeGetBase(),\n+        SCOPED_MEMORY_ACCESS.put$Type$Unaligned(bb.session().state(),\n+                bb.base(),\n@@ -181,2 +181,2 @@\n-                          SCOPED_MEMORY_ACCESS.get$RawType$Volatile(bb.sessionImpl(),\n-                                  bb.unsafeGetBase(),\n+                          SCOPED_MEMORY_ACCESS.get$RawType$Volatile(bb.session().state(),\n+                                  bb.base(),\n@@ -190,2 +190,2 @@\n-        SCOPED_MEMORY_ACCESS.put$RawType$Volatile(bb.sessionImpl(),\n-                bb.unsafeGetBase(),\n+        SCOPED_MEMORY_ACCESS.put$RawType$Volatile(bb.session().state(),\n+                bb.base(),\n@@ -201,2 +201,2 @@\n-                          SCOPED_MEMORY_ACCESS.get$RawType$Acquire(bb.sessionImpl(),\n-                                  bb.unsafeGetBase(),\n+                          SCOPED_MEMORY_ACCESS.get$RawType$Acquire(bb.session().state(),\n+                                  bb.base(),\n@@ -210,2 +210,2 @@\n-        SCOPED_MEMORY_ACCESS.put$RawType$Release(bb.sessionImpl(),\n-                bb.unsafeGetBase(),\n+        SCOPED_MEMORY_ACCESS.put$RawType$Release(bb.session().state(),\n+                bb.base(),\n@@ -221,2 +221,2 @@\n-                          SCOPED_MEMORY_ACCESS.get$RawType$Opaque(bb.sessionImpl(),\n-                                  bb.unsafeGetBase(),\n+                          SCOPED_MEMORY_ACCESS.get$RawType$Opaque(bb.session().state(),\n+                                  bb.base(),\n@@ -230,2 +230,2 @@\n-        SCOPED_MEMORY_ACCESS.put$RawType$Opaque(bb.sessionImpl(),\n-                bb.unsafeGetBase(),\n+        SCOPED_MEMORY_ACCESS.put$RawType$Opaque(bb.session().state(),\n+                bb.base(),\n@@ -241,2 +241,2 @@\n-        return SCOPED_MEMORY_ACCESS.compareAndSet$RawType$(bb.sessionImpl(),\n-                bb.unsafeGetBase(),\n+        return SCOPED_MEMORY_ACCESS.compareAndSet$RawType$(bb.session().state(),\n+                bb.base(),\n@@ -252,2 +252,2 @@\n-                          SCOPED_MEMORY_ACCESS.compareAndExchange$RawType$(bb.sessionImpl(),\n-                                  bb.unsafeGetBase(),\n+                          SCOPED_MEMORY_ACCESS.compareAndExchange$RawType$(bb.session().state(),\n+                                  bb.base(),\n@@ -263,2 +263,2 @@\n-                          SCOPED_MEMORY_ACCESS.compareAndExchange$RawType$Acquire(bb.sessionImpl(),\n-                                  bb.unsafeGetBase(),\n+                          SCOPED_MEMORY_ACCESS.compareAndExchange$RawType$Acquire(bb.session().state(),\n+                                  bb.base(),\n@@ -274,2 +274,2 @@\n-                          SCOPED_MEMORY_ACCESS.compareAndExchange$RawType$Release(bb.sessionImpl(),\n-                                  bb.unsafeGetBase(),\n+                          SCOPED_MEMORY_ACCESS.compareAndExchange$RawType$Release(bb.session().state(),\n+                                  bb.base(),\n@@ -284,2 +284,2 @@\n-        return SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$Plain(bb.sessionImpl(),\n-                bb.unsafeGetBase(),\n+        return SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$Plain(bb.session().state(),\n+                bb.base(),\n@@ -294,2 +294,2 @@\n-        return SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$(bb.sessionImpl(),\n-                bb.unsafeGetBase(),\n+        return SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$(bb.session().state(),\n+                bb.base(),\n@@ -304,2 +304,2 @@\n-        return SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$Acquire(bb.sessionImpl(),\n-                bb.unsafeGetBase(),\n+        return SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$Acquire(bb.session().state(),\n+                bb.base(),\n@@ -314,2 +314,2 @@\n-        return SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$Release(bb.sessionImpl(),\n-                bb.unsafeGetBase(),\n+        return SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$Release(bb.session().state(),\n+                bb.base(),\n@@ -325,2 +325,2 @@\n-                          SCOPED_MEMORY_ACCESS.getAndSet$RawType$(bb.sessionImpl(),\n-                                  bb.unsafeGetBase(),\n+                          SCOPED_MEMORY_ACCESS.getAndSet$RawType$(bb.session().state(),\n+                                  bb.base(),\n@@ -336,2 +336,2 @@\n-                          SCOPED_MEMORY_ACCESS.getAndSet$RawType$Acquire(bb.sessionImpl(),\n-                                  bb.unsafeGetBase(),\n+                          SCOPED_MEMORY_ACCESS.getAndSet$RawType$Acquire(bb.session().state(),\n+                                  bb.base(),\n@@ -347,2 +347,2 @@\n-                          SCOPED_MEMORY_ACCESS.getAndSet$RawType$Release(bb.sessionImpl(),\n-                                  bb.unsafeGetBase(),\n+                          SCOPED_MEMORY_ACCESS.getAndSet$RawType$Release(bb.session().state(),\n+                                  bb.base(),\n@@ -360,2 +360,2 @@\n-            return SCOPED_MEMORY_ACCESS.getAndAdd$RawType$(bb.sessionImpl(),\n-                    bb.unsafeGetBase(),\n+            return SCOPED_MEMORY_ACCESS.getAndAdd$RawType$(bb.session().state(),\n+                    bb.base(),\n@@ -374,2 +374,2 @@\n-            return SCOPED_MEMORY_ACCESS.getAndAdd$RawType$Acquire(bb.sessionImpl(),\n-                    bb.unsafeGetBase(),\n+            return SCOPED_MEMORY_ACCESS.getAndAdd$RawType$Acquire(bb.session().state(),\n+                    bb.base(),\n@@ -388,2 +388,2 @@\n-            return SCOPED_MEMORY_ACCESS.getAndAdd$RawType$Release(bb.sessionImpl(),\n-                    bb.unsafeGetBase(),\n+            return SCOPED_MEMORY_ACCESS.getAndAdd$RawType$Release(bb.session().state(),\n+                    bb.base(),\n@@ -400,1 +400,1 @@\n-        Object base = bb.unsafeGetBase();\n+        Object base = bb.base();\n@@ -402,1 +402,1 @@\n-            nativeExpectedValue = SCOPED_MEMORY_ACCESS.get$RawType$Volatile(bb.sessionImpl(),base, offset);\n+            nativeExpectedValue = SCOPED_MEMORY_ACCESS.get$RawType$Volatile(bb.session().state(),base, offset);\n@@ -404,1 +404,1 @@\n-        } while (!SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$(bb.sessionImpl(),base, offset,\n+        } while (!SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$(bb.session().state(),base, offset,\n@@ -416,2 +416,2 @@\n-            return SCOPED_MEMORY_ACCESS.getAndBitwiseOr$RawType$(bb.sessionImpl(),\n-                    bb.unsafeGetBase(),\n+            return SCOPED_MEMORY_ACCESS.getAndBitwiseOr$RawType$(bb.session().state(),\n+                    bb.base(),\n@@ -430,2 +430,2 @@\n-            return SCOPED_MEMORY_ACCESS.getAndBitwiseOr$RawType$Release(bb.sessionImpl(),\n-                    bb.unsafeGetBase(),\n+            return SCOPED_MEMORY_ACCESS.getAndBitwiseOr$RawType$Release(bb.session().state(),\n+                    bb.base(),\n@@ -444,2 +444,2 @@\n-            return SCOPED_MEMORY_ACCESS.getAndBitwiseOr$RawType$Acquire(bb.sessionImpl(),\n-                    bb.unsafeGetBase(),\n+            return SCOPED_MEMORY_ACCESS.getAndBitwiseOr$RawType$Acquire(bb.session().state(),\n+                    bb.base(),\n@@ -456,1 +456,1 @@\n-        Object base = bb.unsafeGetBase();\n+        Object base = bb.base();\n@@ -458,1 +458,1 @@\n-            nativeExpectedValue = SCOPED_MEMORY_ACCESS.get$RawType$Volatile(bb.sessionImpl(),base, offset);\n+            nativeExpectedValue = SCOPED_MEMORY_ACCESS.get$RawType$Volatile(bb.session().state(),base, offset);\n@@ -460,1 +460,1 @@\n-        } while (!SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$(bb.sessionImpl(),base, offset,\n+        } while (!SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$(bb.session().state(),base, offset,\n@@ -470,2 +470,2 @@\n-            return SCOPED_MEMORY_ACCESS.getAndBitwiseAnd$RawType$(bb.sessionImpl(),\n-                    bb.unsafeGetBase(),\n+            return SCOPED_MEMORY_ACCESS.getAndBitwiseAnd$RawType$(bb.session().state(),\n+                    bb.base(),\n@@ -484,2 +484,2 @@\n-            return SCOPED_MEMORY_ACCESS.getAndBitwiseAnd$RawType$Release(bb.sessionImpl(),\n-                    bb.unsafeGetBase(),\n+            return SCOPED_MEMORY_ACCESS.getAndBitwiseAnd$RawType$Release(bb.session().state(),\n+                    bb.base(),\n@@ -498,2 +498,2 @@\n-            return SCOPED_MEMORY_ACCESS.getAndBitwiseAnd$RawType$Acquire(bb.sessionImpl(),\n-                    bb.unsafeGetBase(),\n+            return SCOPED_MEMORY_ACCESS.getAndBitwiseAnd$RawType$Acquire(bb.session().state(),\n+                    bb.base(),\n@@ -510,1 +510,1 @@\n-        Object base = bb.unsafeGetBase();\n+        Object base = bb.base();\n@@ -512,1 +512,1 @@\n-            nativeExpectedValue = SCOPED_MEMORY_ACCESS.get$RawType$Volatile(bb.sessionImpl(),base, offset);\n+            nativeExpectedValue = SCOPED_MEMORY_ACCESS.get$RawType$Volatile(bb.session().state(),base, offset);\n@@ -514,1 +514,1 @@\n-        } while (!SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$(bb.sessionImpl(),base, offset,\n+        } while (!SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$(bb.session().state(),base, offset,\n@@ -525,2 +525,2 @@\n-            return SCOPED_MEMORY_ACCESS.getAndBitwiseXor$RawType$(bb.sessionImpl(),\n-                    bb.unsafeGetBase(),\n+            return SCOPED_MEMORY_ACCESS.getAndBitwiseXor$RawType$(bb.session().state(),\n+                    bb.base(),\n@@ -539,2 +539,2 @@\n-            return SCOPED_MEMORY_ACCESS.getAndBitwiseXor$RawType$Release(bb.sessionImpl(),\n-                    bb.unsafeGetBase(),\n+            return SCOPED_MEMORY_ACCESS.getAndBitwiseXor$RawType$Release(bb.session().state(),\n+                    bb.base(),\n@@ -553,2 +553,2 @@\n-            return SCOPED_MEMORY_ACCESS.getAndBitwiseXor$RawType$Acquire(bb.sessionImpl(),\n-                    bb.unsafeGetBase(),\n+            return SCOPED_MEMORY_ACCESS.getAndBitwiseXor$RawType$Acquire(bb.session().state(),\n+                    bb.base(),\n@@ -565,1 +565,1 @@\n-        Object base = bb.unsafeGetBase();\n+        Object base = bb.base();\n@@ -567,1 +567,1 @@\n-            nativeExpectedValue = SCOPED_MEMORY_ACCESS.get$RawType$Volatile(bb.sessionImpl(),base, offset);\n+            nativeExpectedValue = SCOPED_MEMORY_ACCESS.get$RawType$Volatile(bb.session().state(),base, offset);\n@@ -569,1 +569,1 @@\n-        } while (!SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$(bb.sessionImpl(),base, offset,\n+        } while (!SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$(bb.session().state(),base, offset,\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/X-VarHandleSegmentView.java.template","additions":83,"deletions":83,"binary":false,"changes":166,"status":"modified"},{"patch":"@@ -40,1 +40,0 @@\n-import java.lang.foreign.MemorySession;\n@@ -763,1 +762,1 @@\n-    final MemorySessionImpl session() {\n+    final MemorySessionImpl.State state() {\n@@ -765,1 +764,1 @@\n-            return ((AbstractMemorySegmentImpl)segment).sessionImpl();\n+            return ((AbstractMemorySegmentImpl)segment).session().state();\n@@ -771,8 +770,3 @@\n-    final void checkSession() {\n-        MemorySessionImpl session = session();\n-        if (session != null) {\n-            try {\n-                session.checkValidState();\n-            } catch (ScopedMemoryAccess.ScopedAccessError e) {\n-                throw new IllegalStateException(\"This segment is already closed\");\n-            }\n+    final void checkState() {\n+        if (segment != null) {\n+            MemorySessionImpl.checkValidState(segment.session());\n@@ -831,3 +825,3 @@\n-                public Runnable acquireSession(Buffer buffer, boolean async) {\n-                    var session = buffer.session();\n-                    if (session == null) {\n+                public Runnable acquire(Buffer buffer, boolean async) {\n+                    var state = buffer.state();\n+                    if (state == null) {\n@@ -836,1 +830,1 @@\n-                    if (async && session.ownerThread() != null) {\n+                    if (async && state.ownerThread() != null) {\n@@ -839,2 +833,2 @@\n-                    session.acquire0();\n-                    return session::release0;\n+                    state.acquire();\n+                    return state::release;\n","filename":"src\/java.base\/share\/classes\/java\/nio\/Buffer.java","additions":11,"deletions":17,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-            i = SCOPED_MEMORY_ACCESS.vectorizedMismatch(a.session(), b.session(),\n+            i = SCOPED_MEMORY_ACCESS.vectorizedMismatch(a.state(), b.state(),\n@@ -66,1 +66,1 @@\n-            i = SCOPED_MEMORY_ACCESS.vectorizedMismatch(a.session(), b.session(),\n+            i = SCOPED_MEMORY_ACCESS.vectorizedMismatch(a.state(), b.state(),\n@@ -86,1 +86,1 @@\n-            i = SCOPED_MEMORY_ACCESS.vectorizedMismatch(a.session(), b.session(),\n+            i = SCOPED_MEMORY_ACCESS.vectorizedMismatch(a.state(), b.state(),\n@@ -106,1 +106,1 @@\n-            i = SCOPED_MEMORY_ACCESS.vectorizedMismatch(a.session(), b.session(),\n+            i = SCOPED_MEMORY_ACCESS.vectorizedMismatch(a.state(), b.state(),\n@@ -125,1 +125,1 @@\n-                i = SCOPED_MEMORY_ACCESS.vectorizedMismatch(a.session(), b.session(),\n+                i = SCOPED_MEMORY_ACCESS.vectorizedMismatch(a.state(), b.state(),\n@@ -164,1 +164,1 @@\n-            i = SCOPED_MEMORY_ACCESS.vectorizedMismatch(a.session(), b.session(),\n+            i = SCOPED_MEMORY_ACCESS.vectorizedMismatch(a.state(), b.state(),\n@@ -182,1 +182,1 @@\n-                i = SCOPED_MEMORY_ACCESS.vectorizedMismatch(a.session(), b.session(),\n+                i = SCOPED_MEMORY_ACCESS.vectorizedMismatch(a.state(), b.state(),\n","filename":"src\/java.base\/share\/classes\/java\/nio\/BufferMismatch.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -141,1 +141,1 @@\n-        $memtype$ x = SCOPED_MEMORY_ACCESS.get$Memtype$Unaligned(session(), bb.hb, byteOffset(nextGetIndex()),\n+        $memtype$ x = SCOPED_MEMORY_ACCESS.get$Memtype$Unaligned(state(), bb.hb, byteOffset(nextGetIndex()),\n@@ -147,1 +147,1 @@\n-        $memtype$ x = SCOPED_MEMORY_ACCESS.get$Memtype$Unaligned(session(), bb.hb, byteOffset(checkIndex(i)),\n+        $memtype$ x = SCOPED_MEMORY_ACCESS.get$Memtype$Unaligned(state(), bb.hb, byteOffset(checkIndex(i)),\n@@ -165,1 +165,1 @@\n-        SCOPED_MEMORY_ACCESS.put$Memtype$Unaligned(session(), bb.hb, byteOffset(nextPutIndex()), y,\n+        SCOPED_MEMORY_ACCESS.put$Memtype$Unaligned(state(), bb.hb, byteOffset(nextPutIndex()), y,\n@@ -176,1 +176,1 @@\n-        SCOPED_MEMORY_ACCESS.put$Memtype$Unaligned(session(), bb.hb, byteOffset(checkIndex(i)), y,\n+        SCOPED_MEMORY_ACCESS.put$Memtype$Unaligned(state(), bb.hb, byteOffset(checkIndex(i)), y,\n","filename":"src\/java.base\/share\/classes\/java\/nio\/ByteBufferAs-X-Buffer.java.template","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-            $memtype$ x = SCOPED_MEMORY_ACCESS.get$Memtype$Unaligned(session(), null, a, bigEndian);\n+            $memtype$ x = SCOPED_MEMORY_ACCESS.get$Memtype$Unaligned(state(), null, a, bigEndian);\n@@ -65,1 +65,1 @@\n-            SCOPED_MEMORY_ACCESS.put$Memtype$Unaligned(session(), null, a, y, bigEndian);\n+            SCOPED_MEMORY_ACCESS.put$Memtype$Unaligned(state(), null, a, y, bigEndian);\n","filename":"src\/java.base\/share\/classes\/java\/nio\/Direct-X-Buffer-bin.java.template","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -311,3 +311,3 @@\n-        MemorySessionImpl session = session();\n-        if (session != null) {\n-            if (session.ownerThread() == null && session.isCloseable()) {\n+        MemorySessionImpl.State state = state();\n+        if (state != null) {\n+            if (state.ownerThread() == null && !state.isImplicit()) {\n@@ -316,5 +316,1 @@\n-            try {\n-                session.checkValidState();\n-            } catch (ScopedAccessError e) {\n-                throw new IllegalStateException(\"This segment is already closed\");\n-            }\n+            state.checkValidStateWrapException();\n@@ -331,1 +327,1 @@\n-            return $fromBits$($swap$(SCOPED_MEMORY_ACCESS.get$Swaptype$(session(), null, ix(nextGetIndex()))));\n+            return $fromBits$($swap$(SCOPED_MEMORY_ACCESS.get$Swaptype$(state(), null, ix(nextGetIndex()))));\n@@ -339,1 +335,1 @@\n-            return $fromBits$($swap$(SCOPED_MEMORY_ACCESS.get$Swaptype$(session(), null, ix(checkIndex(i)))));\n+            return $fromBits$($swap$(SCOPED_MEMORY_ACCESS.get$Swaptype$(state(), null, ix(checkIndex(i)))));\n@@ -359,1 +355,1 @@\n-            SCOPED_MEMORY_ACCESS.put$Swaptype$(session(), null, ix(nextPutIndex()), $swap$($toBits$(x)));\n+            SCOPED_MEMORY_ACCESS.put$Swaptype$(state(), null, ix(nextPutIndex()), $swap$($toBits$(x)));\n@@ -372,1 +368,1 @@\n-            SCOPED_MEMORY_ACCESS.put$Swaptype$(session(), null, ix(checkIndex(i)), $swap$($toBits$(x)));\n+            SCOPED_MEMORY_ACCESS.put$Swaptype$(state(), null, ix(checkIndex(i)), $swap$($toBits$(x)));\n@@ -389,2 +385,2 @@\n-            \/\/ null is passed as destination MemorySession to avoid checking session() twice\n-            SCOPED_MEMORY_ACCESS.copyMemory(session(), null, null,\n+            \/\/ null is passed as destination MemorySession to avoid checking state() twice\n+            SCOPED_MEMORY_ACCESS.copyMemory(state(), null, null,\n","filename":"src\/java.base\/share\/classes\/java\/nio\/Direct-X-Buffer.java.template","additions":10,"deletions":14,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -186,1 +186,1 @@\n-        checkSession();\n+        checkState();\n@@ -197,1 +197,1 @@\n-        checkSession();\n+        checkState();\n@@ -234,1 +234,1 @@\n-        checkSession();\n+        checkState();\n@@ -249,1 +249,1 @@\n-        checkSession();\n+        checkState();\n@@ -259,1 +259,1 @@\n-        checkSession();\n+        checkState();\n@@ -269,1 +269,1 @@\n-        checkSession();\n+        checkState();\n@@ -283,1 +283,1 @@\n-        checkSession();\n+        checkState();\n@@ -338,1 +338,1 @@\n-        return SCOPED_MEMORY_ACCESS.getCharUnaligned(session(), hb, byteOffset(nextGetIndex(2)), bigEndian);\n+        return SCOPED_MEMORY_ACCESS.getCharUnaligned(state(), hb, byteOffset(nextGetIndex(2)), bigEndian);\n@@ -342,1 +342,1 @@\n-        return SCOPED_MEMORY_ACCESS.getCharUnaligned(session(), hb, byteOffset(checkIndex(i, 2)), bigEndian);\n+        return SCOPED_MEMORY_ACCESS.getCharUnaligned(state(), hb, byteOffset(checkIndex(i, 2)), bigEndian);\n@@ -349,1 +349,1 @@\n-        SCOPED_MEMORY_ACCESS.putCharUnaligned(session(), hb, byteOffset(nextPutIndex(2)), x, bigEndian);\n+        SCOPED_MEMORY_ACCESS.putCharUnaligned(state(), hb, byteOffset(nextPutIndex(2)), x, bigEndian);\n@@ -358,1 +358,1 @@\n-        SCOPED_MEMORY_ACCESS.putCharUnaligned(session(), hb, byteOffset(checkIndex(i, 2)), x, bigEndian);\n+        SCOPED_MEMORY_ACCESS.putCharUnaligned(state(), hb, byteOffset(checkIndex(i, 2)), x, bigEndian);\n@@ -390,1 +390,1 @@\n-        return SCOPED_MEMORY_ACCESS.getShortUnaligned(session(), hb, byteOffset(nextGetIndex(2)), bigEndian);\n+        return SCOPED_MEMORY_ACCESS.getShortUnaligned(state(), hb, byteOffset(nextGetIndex(2)), bigEndian);\n@@ -394,1 +394,1 @@\n-        return SCOPED_MEMORY_ACCESS.getShortUnaligned(session(), hb, byteOffset(checkIndex(i, 2)), bigEndian);\n+        return SCOPED_MEMORY_ACCESS.getShortUnaligned(state(), hb, byteOffset(checkIndex(i, 2)), bigEndian);\n@@ -401,1 +401,1 @@\n-        SCOPED_MEMORY_ACCESS.putShortUnaligned(session(), hb, byteOffset(nextPutIndex(2)), x, bigEndian);\n+        SCOPED_MEMORY_ACCESS.putShortUnaligned(state(), hb, byteOffset(nextPutIndex(2)), x, bigEndian);\n@@ -410,1 +410,1 @@\n-        SCOPED_MEMORY_ACCESS.putShortUnaligned(session(), hb, byteOffset(checkIndex(i, 2)), x, bigEndian);\n+        SCOPED_MEMORY_ACCESS.putShortUnaligned(state(), hb, byteOffset(checkIndex(i, 2)), x, bigEndian);\n@@ -442,1 +442,1 @@\n-        return SCOPED_MEMORY_ACCESS.getIntUnaligned(session(), hb, byteOffset(nextGetIndex(4)), bigEndian);\n+        return SCOPED_MEMORY_ACCESS.getIntUnaligned(state(), hb, byteOffset(nextGetIndex(4)), bigEndian);\n@@ -446,1 +446,1 @@\n-        return SCOPED_MEMORY_ACCESS.getIntUnaligned(session(), hb, byteOffset(checkIndex(i, 4)), bigEndian);\n+        return SCOPED_MEMORY_ACCESS.getIntUnaligned(state(), hb, byteOffset(checkIndex(i, 4)), bigEndian);\n@@ -453,1 +453,1 @@\n-        SCOPED_MEMORY_ACCESS.putIntUnaligned(session(), hb, byteOffset(nextPutIndex(4)), x, bigEndian);\n+        SCOPED_MEMORY_ACCESS.putIntUnaligned(state(), hb, byteOffset(nextPutIndex(4)), x, bigEndian);\n@@ -462,1 +462,1 @@\n-        SCOPED_MEMORY_ACCESS.putIntUnaligned(session(), hb, byteOffset(checkIndex(i, 4)), x, bigEndian);\n+        SCOPED_MEMORY_ACCESS.putIntUnaligned(state(), hb, byteOffset(checkIndex(i, 4)), x, bigEndian);\n@@ -494,1 +494,1 @@\n-        return SCOPED_MEMORY_ACCESS.getLongUnaligned(session(), hb, byteOffset(nextGetIndex(8)), bigEndian);\n+        return SCOPED_MEMORY_ACCESS.getLongUnaligned(state(), hb, byteOffset(nextGetIndex(8)), bigEndian);\n@@ -498,1 +498,1 @@\n-        return SCOPED_MEMORY_ACCESS.getLongUnaligned(session(), hb, byteOffset(checkIndex(i, 8)), bigEndian);\n+        return SCOPED_MEMORY_ACCESS.getLongUnaligned(state(), hb, byteOffset(checkIndex(i, 8)), bigEndian);\n@@ -505,1 +505,1 @@\n-        SCOPED_MEMORY_ACCESS.putLongUnaligned(session(), hb, byteOffset(nextPutIndex(8)), x, bigEndian);\n+        SCOPED_MEMORY_ACCESS.putLongUnaligned(state(), hb, byteOffset(nextPutIndex(8)), x, bigEndian);\n@@ -514,1 +514,1 @@\n-        SCOPED_MEMORY_ACCESS.putLongUnaligned(session(), hb, byteOffset(checkIndex(i, 8)), x, bigEndian);\n+        SCOPED_MEMORY_ACCESS.putLongUnaligned(state(), hb, byteOffset(checkIndex(i, 8)), x, bigEndian);\n@@ -546,1 +546,1 @@\n-        int x = SCOPED_MEMORY_ACCESS.getIntUnaligned(session(), hb, byteOffset(nextGetIndex(4)), bigEndian);\n+        int x = SCOPED_MEMORY_ACCESS.getIntUnaligned(state(), hb, byteOffset(nextGetIndex(4)), bigEndian);\n@@ -551,1 +551,1 @@\n-        int x = SCOPED_MEMORY_ACCESS.getIntUnaligned(session(), hb, byteOffset(checkIndex(i, 4)), bigEndian);\n+        int x = SCOPED_MEMORY_ACCESS.getIntUnaligned(state(), hb, byteOffset(checkIndex(i, 4)), bigEndian);\n@@ -560,1 +560,1 @@\n-        SCOPED_MEMORY_ACCESS.putIntUnaligned(session(), hb, byteOffset(nextPutIndex(4)), y, bigEndian);\n+        SCOPED_MEMORY_ACCESS.putIntUnaligned(state(), hb, byteOffset(nextPutIndex(4)), y, bigEndian);\n@@ -570,1 +570,1 @@\n-        SCOPED_MEMORY_ACCESS.putIntUnaligned(session(), hb, byteOffset(checkIndex(i, 4)), y, bigEndian);\n+        SCOPED_MEMORY_ACCESS.putIntUnaligned(state(), hb, byteOffset(checkIndex(i, 4)), y, bigEndian);\n@@ -602,1 +602,1 @@\n-        long x = SCOPED_MEMORY_ACCESS.getLongUnaligned(session(), hb, byteOffset(nextGetIndex(8)), bigEndian);\n+        long x = SCOPED_MEMORY_ACCESS.getLongUnaligned(state(), hb, byteOffset(nextGetIndex(8)), bigEndian);\n@@ -607,1 +607,1 @@\n-        long x = SCOPED_MEMORY_ACCESS.getLongUnaligned(session(), hb, byteOffset(checkIndex(i, 8)), bigEndian);\n+        long x = SCOPED_MEMORY_ACCESS.getLongUnaligned(state(), hb, byteOffset(checkIndex(i, 8)), bigEndian);\n@@ -616,1 +616,1 @@\n-        SCOPED_MEMORY_ACCESS.putLongUnaligned(session(), hb, byteOffset(nextPutIndex(8)), y, bigEndian);\n+        SCOPED_MEMORY_ACCESS.putLongUnaligned(state(), hb, byteOffset(nextPutIndex(8)), y, bigEndian);\n@@ -626,1 +626,1 @@\n-        SCOPED_MEMORY_ACCESS.putLongUnaligned(session(), hb, byteOffset(checkIndex(i, 8)), y, bigEndian);\n+        SCOPED_MEMORY_ACCESS.putLongUnaligned(state(), hb, byteOffset(checkIndex(i, 8)), y, bigEndian);\n","filename":"src\/java.base\/share\/classes\/java\/nio\/Heap-X-Buffer.java.template","additions":31,"deletions":31,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -192,1 +192,1 @@\n-        return SCOPED_MEMORY_ACCESS.isLoaded(session(), address, isSync, capacity());\n+        return SCOPED_MEMORY_ACCESS.isLoaded(state(), address, isSync, capacity());\n@@ -210,1 +210,1 @@\n-            SCOPED_MEMORY_ACCESS.load(session(), address, isSync, capacity());\n+            SCOPED_MEMORY_ACCESS.load(state(), address, isSync, capacity());\n@@ -310,1 +310,1 @@\n-            SCOPED_MEMORY_ACCESS.force(session(), fd, address, isSync, index, length);\n+            SCOPED_MEMORY_ACCESS.force(state(), fd, address, isSync, index, length);\n","filename":"src\/java.base\/share\/classes\/java\/nio\/MappedByteBuffer.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -938,1 +938,1 @@\n-                            session(), null, base(), bufAddr,\n+                            state(), null, base(), bufAddr,\n@@ -943,1 +943,1 @@\n-                            session(), null, base(), bufAddr,\n+                            state(), null, base(), bufAddr,\n@@ -1108,1 +1108,1 @@\n-                            src.session(), session(), srcBase, srcAddr,\n+                            src.state(), state(), srcBase, srcAddr,\n@@ -1113,1 +1113,1 @@\n-                            src.session(), session(), srcBase, srcAddr,\n+                            src.state(), state(), srcBase, srcAddr,\n@@ -1328,1 +1328,1 @@\n-                            null, session(), src, srcOffset,\n+                            null, state(), src, srcOffset,\n@@ -1333,1 +1333,1 @@\n-                            null, session(), src, srcOffset,\n+                            null, state(), src, srcOffset,\n","filename":"src\/java.base\/share\/classes\/java\/nio\/X-Buffer.java.template","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -94,1 +94,1 @@\n-    Runnable acquireSession(Buffer buffer, boolean async);\n+    Runnable acquire(Buffer buffer, boolean async);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaNioAccess.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -71,1 +71,0 @@\n-    static final int READ_ONLY = 1;\n@@ -74,2 +73,0 @@\n-    static final int DEFAULT_MODES = 0;\n-\n@@ -79,2 +76,2 @@\n-    final int mask;\n-    final MemorySession session;\n+    final boolean isReadOnly;\n+    final MemorySessionImpl session;\n@@ -83,1 +80,1 @@\n-    AbstractMemorySegmentImpl(long length, int mask, MemorySession session) {\n+    AbstractMemorySegmentImpl(long length, boolean isReadOnly, MemorySessionImpl session) {\n@@ -85,1 +82,1 @@\n-        this.mask = mask;\n+        this.isReadOnly = isReadOnly;\n@@ -89,1 +86,1 @@\n-    abstract long min();\n+    public abstract long min();\n@@ -91,1 +88,1 @@\n-    abstract Object base();\n+    public abstract Object base();\n@@ -93,1 +90,1 @@\n-    abstract AbstractMemorySegmentImpl dup(long offset, long size, int mask, MemorySession session);\n+    abstract AbstractMemorySegmentImpl dup(long offset, long size, boolean isReadOnly, MemorySessionImpl session);\n@@ -99,1 +96,1 @@\n-        return dup(0, length, mask | READ_ONLY, session);\n+        return dup(0, length, true, session);\n@@ -104,1 +101,1 @@\n-        return isSet(READ_ONLY);\n+        return isReadOnly;\n@@ -120,1 +117,1 @@\n-        return dup(offset, newSize, mask, session);\n+        return dup(offset, newSize, isReadOnly, session);\n@@ -148,1 +145,1 @@\n-        SCOPED_MEMORY_ACCESS.setMemory(sessionImpl(), base(), min(), length, value);\n+        SCOPED_MEMORY_ACCESS.setMemory(session().state(), base(), min(), length, value);\n@@ -179,1 +176,1 @@\n-            i = vectorizedMismatchLargeForBytes(sessionImpl(), that.sessionImpl(),\n+            i = vectorizedMismatchLargeForBytes(session(), that.session(),\n@@ -216,1 +213,1 @@\n-            i = SCOPED_MEMORY_ACCESS.vectorizedMismatch(aSession, bSession,\n+            i = SCOPED_MEMORY_ACCESS.vectorizedMismatch(aSession.state(), bSession.state(),\n@@ -239,1 +236,1 @@\n-        if (isSet(READ_ONLY)) {\n+        if (isReadOnly) {\n@@ -351,0 +348,1 @@\n+    @ForceInline\n@@ -352,1 +350,1 @@\n-        if (!readOnly && isSet(READ_ONLY)) {\n+        if (!readOnly && this.isReadOnly) {\n@@ -359,9 +357,1 @@\n-        sessionImpl().checkValidStateSlow();\n-    }\n-\n-    public long unsafeGetOffset() {\n-        return min();\n-    }\n-\n-    public Object unsafeGetBase() {\n-        return base();\n+        MemorySessionImpl.checkValidState(session());\n@@ -372,4 +362,0 @@\n-    private boolean isSet(int mask) {\n-        return (this.mask & mask) != 0;\n-    }\n-\n@@ -380,1 +366,1 @@\n-        return (((unsafeGetOffset() + offset) | maxAlignMask()) & (layout.byteAlignment() - 1)) == 0;\n+        return (((min() + offset) | maxAlignMask()) & (layout.byteAlignment() - 1)) == 0;\n@@ -405,7 +391,1 @@\n-    @ForceInline\n-    public MemorySessionImpl sessionImpl() {\n-        return MemorySessionImpl.toSessionImpl(session);\n-    }\n-\n-    @Override\n-    public MemorySession session() {\n+    public MemorySessionImpl session() {\n@@ -510,2 +490,2 @@\n-                unsafeGetOffset() == that.unsafeGetOffset() &&\n-                unsafeGetBase() == that.unsafeGetBase() &&\n+                min() == that.min() &&\n+                base() == that.base() &&\n@@ -520,2 +500,2 @@\n-                unsafeGetOffset(),\n-                unsafeGetBase(),\n+                min(),\n+                base(),\n@@ -539,1 +519,1 @@\n-        int modes;\n+        boolean isReadOnly;\n@@ -541,2 +521,2 @@\n-            bufferSession = bufferSegment.sessionImpl();\n-            modes = bufferSegment.mask;\n+            bufferSession = bufferSegment.session();\n+            isReadOnly = bufferSegment.isReadOnly;\n@@ -545,1 +525,1 @@\n-            modes = DEFAULT_MODES;\n+            isReadOnly = false;\n@@ -548,1 +528,1 @@\n-            modes |= READ_ONLY;\n+            isReadOnly = true;\n@@ -553,1 +533,1 @@\n-                return new HeapMemorySegmentImpl.OfByte(bbAddress + (pos << scaleFactor), base, size << scaleFactor, modes);\n+                return new HeapMemorySegmentImpl.OfByte(bbAddress + (pos << scaleFactor), base, size << scaleFactor, isReadOnly);\n@@ -555,1 +535,1 @@\n-                return new HeapMemorySegmentImpl.OfShort(bbAddress + (pos << scaleFactor), base, size << scaleFactor, modes);\n+                return new HeapMemorySegmentImpl.OfShort(bbAddress + (pos << scaleFactor), base, size << scaleFactor, isReadOnly);\n@@ -557,1 +537,1 @@\n-                return new HeapMemorySegmentImpl.OfChar(bbAddress + (pos << scaleFactor), base, size << scaleFactor, modes);\n+                return new HeapMemorySegmentImpl.OfChar(bbAddress + (pos << scaleFactor), base, size << scaleFactor, isReadOnly);\n@@ -559,1 +539,1 @@\n-                return new HeapMemorySegmentImpl.OfInt(bbAddress + (pos << scaleFactor), base, size << scaleFactor, modes);\n+                return new HeapMemorySegmentImpl.OfInt(bbAddress + (pos << scaleFactor), base, size << scaleFactor, isReadOnly);\n@@ -561,1 +541,1 @@\n-                return new HeapMemorySegmentImpl.OfFloat(bbAddress + (pos << scaleFactor), base, size << scaleFactor, modes);\n+                return new HeapMemorySegmentImpl.OfFloat(bbAddress + (pos << scaleFactor), base, size << scaleFactor, isReadOnly);\n@@ -563,1 +543,1 @@\n-                return new HeapMemorySegmentImpl.OfLong(bbAddress + (pos << scaleFactor), base, size << scaleFactor, modes);\n+                return new HeapMemorySegmentImpl.OfLong(bbAddress + (pos << scaleFactor), base, size << scaleFactor, isReadOnly);\n@@ -565,1 +545,1 @@\n-                return new HeapMemorySegmentImpl.OfDouble(bbAddress + (pos << scaleFactor), base, size << scaleFactor, modes);\n+                return new HeapMemorySegmentImpl.OfDouble(bbAddress + (pos << scaleFactor), base, size << scaleFactor, isReadOnly);\n@@ -570,1 +550,1 @@\n-            return new NativeMemorySegmentImpl(bbAddress + (pos << scaleFactor), size << scaleFactor, modes, bufferSession);\n+            return new NativeMemorySegmentImpl(bbAddress + (pos << scaleFactor), size << scaleFactor, isReadOnly, bufferSession);\n@@ -573,1 +553,1 @@\n-            return new MappedMemorySegmentImpl(bbAddress + pos, unmapper, size, modes, bufferSession);\n+            return new MappedMemorySegmentImpl(bbAddress + pos, unmapper, size, isReadOnly, bufferSession);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":37,"deletions":57,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -1,121 +0,0 @@\n-\/*\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.internal.foreign;\n-\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.VarHandle;\n-import java.lang.ref.Cleaner;\n-\n-import jdk.internal.vm.annotation.ForceInline;\n-\n-\/**\n- * A confined session, which features an owner thread. The liveness check features an additional\n- * confinement check - that is, calling any operation on this session from a thread other than the\n- * owner thread will result in an exception. Because of this restriction, checking the liveness bit\n- * can be performed in plain mode.\n- *\/\n-final class ConfinedSession extends MemorySessionImpl {\n-\n-    private int asyncReleaseCount = 0;\n-\n-    static final VarHandle ASYNC_RELEASE_COUNT;\n-\n-    static {\n-        try {\n-            ASYNC_RELEASE_COUNT = MethodHandles.lookup().findVarHandle(ConfinedSession.class, \"asyncReleaseCount\", int.class);\n-        } catch (Throwable ex) {\n-            throw new ExceptionInInitializerError(ex);\n-        }\n-    }\n-\n-    public ConfinedSession(Thread owner, Cleaner cleaner) {\n-        super(owner, new ConfinedResourceList(), cleaner);\n-    }\n-\n-    @Override\n-    public boolean isAlive() {\n-        return state != CLOSED;\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public void acquire0() {\n-        checkValidStateSlow();\n-        if (state == MAX_FORKS) {\n-            throw new IllegalStateException(\"Session keep alive limit exceeded\");\n-        }\n-        state++;\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public void release0() {\n-        if (Thread.currentThread() == owner) {\n-            state--;\n-        } else {\n-            \/\/ It is possible to end up here in two cases: this session was kept alive by some other confined session\n-            \/\/ which is implicitly released (in which case the release call comes from the cleaner thread). Or,\n-            \/\/ this session might be kept alive by a shared session, which means the release call can come from any\n-            \/\/ thread.\n-            ASYNC_RELEASE_COUNT.getAndAdd(this, 1);\n-        }\n-    }\n-\n-    void justClose() {\n-        checkValidStateSlow();\n-        if (state == 0 || state - ((int)ASYNC_RELEASE_COUNT.getVolatile(this)) == 0) {\n-            state = CLOSED;\n-        } else {\n-            throw new IllegalStateException(\"Session is acquired by \" + state + \" clients\");\n-        }\n-    }\n-\n-    \/**\n-     * A confined resource list; no races are possible here.\n-     *\/\n-    static final class ConfinedResourceList extends ResourceList {\n-        @Override\n-        void add(ResourceCleanup cleanup) {\n-            if (fst != ResourceCleanup.CLOSED_LIST) {\n-                cleanup.next = fst;\n-                fst = cleanup;\n-            } else {\n-                throw new IllegalStateException(\"Already closed!\");\n-            }\n-        }\n-\n-        @Override\n-        void cleanup() {\n-            if (fst != ResourceCleanup.CLOSED_LIST) {\n-                ResourceCleanup prev = fst;\n-                fst = ResourceCleanup.CLOSED_LIST;\n-                cleanup(prev);\n-            } else {\n-                throw new IllegalStateException(\"Attempt to cleanup an already closed resource list\");\n-            }\n-        }\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/ConfinedSession.java","additions":0,"deletions":121,"binary":false,"changes":121,"status":"deleted"},{"patch":"@@ -0,0 +1,121 @@\n+\/*\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.foreign;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n+import java.lang.ref.Cleaner;\n+\n+import jdk.internal.vm.annotation.ForceInline;\n+\n+\/**\n+ * A confined session state, which features an owner thread. Because of this restriction, acquire and release\n+ * can be implemented cheaply, with a plain field update. Closing the state is also cheap (since the liveness\n+ * bit cannot be updated concurrently from other threads). Some extra complexity is required to support release\n+ * operations triggered by threads other than the owner thread, which we support.\n+ *\/\n+final class ConfinedSessionState extends MemorySessionImpl.State {\n+\n+    private int asyncReleaseCount = 0;\n+\n+    static final VarHandle ASYNC_RELEASE_COUNT;\n+\n+    static {\n+        try {\n+            ASYNC_RELEASE_COUNT = MethodHandles.lookup().findVarHandle(ConfinedSessionState.class, \"asyncReleaseCount\", int.class);\n+        } catch (Throwable ex) {\n+            throw new ExceptionInInitializerError(ex);\n+        }\n+    }\n+\n+    ConfinedSessionState(Thread owner, Cleaner cleaner) {\n+        super(owner, new ConfinedList(), cleaner);\n+    }\n+\n+    @Override\n+    boolean isAlive() {\n+        return state != CLOSED;\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public void acquire() {\n+        checkValidStateWrapException();\n+        if (state == MAX_FORKS) {\n+            throw tooManyAcquires();\n+        }\n+        state++;\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public void release() {\n+        if (Thread.currentThread() == owner) {\n+            state--;\n+        } else {\n+            \/\/ It is possible to end up here in two cases: this session was kept alive by some other confined session\n+            \/\/ which is implicitly released (in which case the release call comes from the cleaner thread). Or,\n+            \/\/ this session might be kept alive by a shared session, which means the release call can come from any\n+            \/\/ thread.\n+            ASYNC_RELEASE_COUNT.getAndAdd(this, 1);\n+        }\n+    }\n+\n+    void justClose() {\n+        checkValidStateWrapException();\n+        if (state == 0 || state - ((int)ASYNC_RELEASE_COUNT.getVolatile(this)) == 0) {\n+            state = CLOSED;\n+        } else {\n+            throw alreadyAcquired(state);\n+        }\n+    }\n+\n+    \/**\n+     * A confined resource list; no races are possible here.\n+     *\/\n+    static final class ConfinedList extends ResourceList {\n+        @Override\n+        void add(ResourceCleanup cleanup) {\n+            if (fst != ResourceCleanup.CLOSED_LIST) {\n+                cleanup.next = fst;\n+                fst = cleanup;\n+            } else {\n+                throw alreadyClosed();\n+            }\n+        }\n+\n+        @Override\n+        void cleanup() {\n+            if (fst != ResourceCleanup.CLOSED_LIST) {\n+                ResourceCleanup prev = fst;\n+                fst = ResourceCleanup.CLOSED_LIST;\n+                cleanup(prev);\n+            } else {\n+                throw alreadyClosed();\n+            }\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/ConfinedSessionState.java","additions":121,"deletions":0,"binary":false,"changes":121,"status":"added"},{"patch":"@@ -47,1 +47,1 @@\n- * such as the elimination of store barriers in methods like {@link HeapMemorySegmentImpl#dup(long, long, int, MemorySession)}.\n+ * such as the elimination of store barriers in methods like {@link HeapMemorySegmentImpl#dup(long, long, boolean, MemorySessionImpl)}.\n@@ -63,2 +63,2 @@\n-    HeapMemorySegmentImpl(long offset, Object base, long length, int mask) {\n-        super(length, mask, MemorySessionImpl.GLOBAL);\n+    HeapMemorySegmentImpl(long offset, Object base, long length, boolean isReadOnly) {\n+        super(length, isReadOnly, MemorySessionImpl.GLOBAL);\n@@ -70,1 +70,1 @@\n-    abstract Object base();\n+    public abstract Object base();\n@@ -73,1 +73,1 @@\n-    long min() {\n+    public long min() {\n@@ -78,1 +78,1 @@\n-    abstract HeapMemorySegmentImpl dup(long offset, long size, int mask, MemorySession session);\n+    abstract HeapMemorySegmentImpl dup(long offset, long size, boolean isReadOnly, MemorySessionImpl session);\n@@ -93,2 +93,2 @@\n-        OfByte(long offset, Object base, long length, int mask) {\n-            super(offset, base, length, mask);\n+        OfByte(long offset, Object base, long length, boolean isReadOnly) {\n+            super(offset, base, length, isReadOnly);\n@@ -98,2 +98,2 @@\n-        OfByte dup(long offset, long size, int mask, MemorySession session) {\n-            return new OfByte(this.offset + offset, base, size, mask);\n+        OfByte dup(long offset, long size, boolean isReadOnly, MemorySessionImpl session) {\n+            return new OfByte(this.offset + offset, base, size, isReadOnly);\n@@ -103,1 +103,1 @@\n-        byte[] base() {\n+        public byte[] base() {\n@@ -110,1 +110,1 @@\n-            return new OfByte(Unsafe.ARRAY_BYTE_BASE_OFFSET, arr, byteSize, DEFAULT_MODES);\n+            return new OfByte(Unsafe.ARRAY_BYTE_BASE_OFFSET, arr, byteSize, false);\n@@ -121,2 +121,2 @@\n-        OfChar(long offset, Object base, long length, int mask) {\n-            super(offset, base, length, mask);\n+        OfChar(long offset, Object base, long length, boolean isReadOnly) {\n+            super(offset, base, length, isReadOnly);\n@@ -126,2 +126,2 @@\n-        OfChar dup(long offset, long size, int mask, MemorySession session) {\n-            return new OfChar(this.offset + offset, base, size, mask);\n+        OfChar dup(long offset, long size, boolean isReadOnly, MemorySessionImpl session) {\n+            return new OfChar(this.offset + offset, base, size, isReadOnly);\n@@ -131,1 +131,1 @@\n-        char[] base() {\n+        public char[] base() {\n@@ -138,1 +138,1 @@\n-            return new OfChar(Unsafe.ARRAY_CHAR_BASE_OFFSET, arr, byteSize, DEFAULT_MODES);\n+            return new OfChar(Unsafe.ARRAY_CHAR_BASE_OFFSET, arr, byteSize, false);\n@@ -149,2 +149,2 @@\n-        OfShort(long offset, Object base, long length, int mask) {\n-            super(offset, base, length, mask);\n+        OfShort(long offset, Object base, long length, boolean isReadOnly) {\n+            super(offset, base, length, isReadOnly);\n@@ -154,2 +154,2 @@\n-        OfShort dup(long offset, long size, int mask, MemorySession session) {\n-            return new OfShort(this.offset + offset, base, size, mask);\n+        OfShort dup(long offset, long size, boolean isReadOnly, MemorySessionImpl session) {\n+            return new OfShort(this.offset + offset, base, size, isReadOnly);\n@@ -159,1 +159,1 @@\n-        short[] base() {\n+        public short[] base() {\n@@ -166,1 +166,1 @@\n-            return new OfShort(Unsafe.ARRAY_SHORT_BASE_OFFSET, arr, byteSize, DEFAULT_MODES);\n+            return new OfShort(Unsafe.ARRAY_SHORT_BASE_OFFSET, arr, byteSize, false);\n@@ -177,2 +177,2 @@\n-        OfInt(long offset, Object base, long length, int mask) {\n-            super(offset, base, length, mask);\n+        OfInt(long offset, Object base, long length, boolean isReadOnly) {\n+            super(offset, base, length, isReadOnly);\n@@ -182,2 +182,2 @@\n-        OfInt dup(long offset, long size, int mask, MemorySession session) {\n-            return new OfInt(this.offset + offset, base, size, mask);\n+        OfInt dup(long offset, long size, boolean isReadOnly, MemorySessionImpl session) {\n+            return new OfInt(this.offset + offset, base, size, isReadOnly);\n@@ -187,1 +187,1 @@\n-        int[] base() {\n+        public int[] base() {\n@@ -194,1 +194,1 @@\n-            return new OfInt(Unsafe.ARRAY_INT_BASE_OFFSET, arr, byteSize, DEFAULT_MODES);\n+            return new OfInt(Unsafe.ARRAY_INT_BASE_OFFSET, arr, byteSize, false);\n@@ -205,2 +205,2 @@\n-        OfLong(long offset, Object base, long length, int mask) {\n-            super(offset, base, length, mask);\n+        OfLong(long offset, Object base, long length, boolean isReadOnly) {\n+            super(offset, base, length, isReadOnly);\n@@ -210,2 +210,2 @@\n-        OfLong dup(long offset, long size, int mask, MemorySession session) {\n-            return new OfLong(this.offset + offset, base, size, mask);\n+        OfLong dup(long offset, long size, boolean isReadOnly, MemorySessionImpl session) {\n+            return new OfLong(this.offset + offset, base, size, isReadOnly);\n@@ -215,1 +215,1 @@\n-        long[] base() {\n+        public long[] base() {\n@@ -222,1 +222,1 @@\n-            return new OfLong(Unsafe.ARRAY_LONG_BASE_OFFSET, arr, byteSize, DEFAULT_MODES);\n+            return new OfLong(Unsafe.ARRAY_LONG_BASE_OFFSET, arr, byteSize, false);\n@@ -233,2 +233,2 @@\n-        OfFloat(long offset, Object base, long length, int mask) {\n-            super(offset, base, length, mask);\n+        OfFloat(long offset, Object base, long length, boolean isReadOnly) {\n+            super(offset, base, length, isReadOnly);\n@@ -238,2 +238,2 @@\n-        OfFloat dup(long offset, long size, int mask, MemorySession session) {\n-            return new OfFloat(this.offset + offset, base, size, mask);\n+        OfFloat dup(long offset, long size, boolean isReadOnly, MemorySessionImpl session) {\n+            return new OfFloat(this.offset + offset, base, size, isReadOnly);\n@@ -243,1 +243,1 @@\n-        float[] base() {\n+        public float[] base() {\n@@ -250,1 +250,1 @@\n-            return new OfFloat(Unsafe.ARRAY_FLOAT_BASE_OFFSET, arr, byteSize, DEFAULT_MODES);\n+            return new OfFloat(Unsafe.ARRAY_FLOAT_BASE_OFFSET, arr, byteSize, false);\n@@ -261,2 +261,2 @@\n-        OfDouble(long offset, Object base, long length, int mask) {\n-            super(offset, base, length, mask);\n+        OfDouble(long offset, Object base, long length, boolean isReadOnly) {\n+            super(offset, base, length, isReadOnly);\n@@ -266,2 +266,2 @@\n-        OfDouble dup(long offset, long size, int mask, MemorySession session) {\n-            return new OfDouble(this.offset + offset, base, size, mask);\n+        OfDouble dup(long offset, long size, boolean isReadOnly, MemorySessionImpl session) {\n+            return new OfDouble(this.offset + offset, base, size, isReadOnly);\n@@ -271,1 +271,1 @@\n-        double[] base() {\n+        public double[] base() {\n@@ -278,1 +278,1 @@\n-            return new OfDouble(Unsafe.ARRAY_DOUBLE_BASE_OFFSET, arr, byteSize, DEFAULT_MODES);\n+            return new OfDouble(Unsafe.ARRAY_DOUBLE_BASE_OFFSET, arr, byteSize, false);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/HeapMemorySegmentImpl.java","additions":48,"deletions":48,"binary":false,"changes":96,"status":"modified"},{"patch":"@@ -46,2 +46,2 @@\n-    public MappedMemorySegmentImpl(long min, UnmapperProxy unmapper, long length, int mask, MemorySession session) {\n-        super(min, length, mask, session);\n+    public MappedMemorySegmentImpl(long min, UnmapperProxy unmapper, long length, boolean isReadOnly, MemorySessionImpl session) {\n+        super(min, length, isReadOnly, session);\n@@ -58,2 +58,2 @@\n-    MappedMemorySegmentImpl dup(long offset, long size, int mask, MemorySession session) {\n-        return new MappedMemorySegmentImpl(min + offset, unmapper, size, mask, session);\n+    MappedMemorySegmentImpl dup(long offset, long size, boolean isReadOnly, MemorySessionImpl session) {\n+        return new MappedMemorySegmentImpl(min + offset, unmapper, size, isReadOnly, session);\n@@ -81,1 +81,1 @@\n-        SCOPED_MEMORY_ACCESS.load(sessionImpl(), min, unmapper.isSync(), length);\n+        SCOPED_MEMORY_ACCESS.load(session().state(), min, unmapper.isSync(), length);\n@@ -85,1 +85,1 @@\n-        SCOPED_MEMORY_ACCESS.unload(sessionImpl(), min, unmapper.isSync(), length);\n+        SCOPED_MEMORY_ACCESS.unload(session().state(), min, unmapper.isSync(), length);\n@@ -89,1 +89,1 @@\n-        return SCOPED_MEMORY_ACCESS.isLoaded(sessionImpl(), min, unmapper.isSync(), length);\n+        return SCOPED_MEMORY_ACCESS.isLoaded(session().state(), min, unmapper.isSync(), length);\n@@ -93,1 +93,1 @@\n-        SCOPED_MEMORY_ACCESS.force(sessionImpl(), unmapper.fileDescriptor(), min, unmapper.isSync(), 0, length);\n+        SCOPED_MEMORY_ACCESS.force(session().state(), unmapper.fileDescriptor(), min, unmapper.isSync(), 0, length);\n@@ -98,2 +98,2 @@\n-        public EmptyMappedMemorySegmentImpl(int modes, MemorySession session) {\n-            super(0, null, 0, modes, session);\n+        public EmptyMappedMemorySegmentImpl(boolean isReadOnly, MemorySessionImpl session) {\n+            super(0, null, 0, isReadOnly, session);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/MappedMemorySegmentImpl.java","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -98,1 +98,1 @@\n-    public MemorySessionImpl sessionImpl() {\n+    public MemorySessionImpl session() {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/MemoryAddressImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import java.lang.foreign.MemorySegment;\n@@ -36,0 +35,1 @@\n+import java.nio.ByteBuffer;\n@@ -37,0 +37,1 @@\n+\n@@ -38,1 +39,0 @@\n-import jdk.internal.ref.CleanerFactory;\n@@ -40,1 +40,0 @@\n-import sun.nio.ch.DirectBuffer;\n@@ -44,10 +43,7 @@\n- * as thread confinement. A session has a liveness bit, which is updated when the session is closed\n- * (this operation is triggered by {@link MemorySession#close()}). This bit is consulted prior\n- * to memory access (see {@link #checkValidState()}).\n- * There are two kinds of memory session: confined memory session and shared memory session.\n- * A confined memory session has an associated owner thread that confines some operations to\n- * associated owner thread such as {@link #close()} or {@link #checkValidState()}.\n- * Shared sessions do not feature an owner thread - meaning their operations can be called, in a racy\n- * manner, by multiple threads. To guarantee temporal safety in the presence of concurrent thread,\n- * shared sessions use a more sophisticated synchronization mechanism, which guarantees that no concurrent\n- * access is possible when a session is being closed (see {@link jdk.internal.misc.ScopedMemoryAccess}).\n+ * as thread confinement. A session is associated with a {@link State#state liveness bit},\n+ * which is updated when the session is closed (this operation is triggered by {@link MemorySession#close()}).\n+ * This bit is consulted prior to memory access (see {@link State#checkValidState()}).\n+ * <p>\n+ * Since the API allows the creation of non-closeable session views, the implementation of this class encapsulates\n+ * the state of a memory session into a separate class, namely {@link State}. This allows to create views that are\n+ * backed by the very same state.\n@@ -55,66 +51,1 @@\n-public abstract non-sealed class MemorySessionImpl implements Scoped, MemorySession, SegmentAllocator {\n-    final ResourceList resourceList;\n-    final Cleaner.Cleanable cleanable;\n-    final Thread owner;\n-\n-    static final int OPEN = 0;\n-    static final int CLOSING = -1;\n-    static final int CLOSED = -2;\n-\n-    int state = OPEN;\n-\n-    static final VarHandle STATE;\n-\n-    static {\n-        try {\n-            STATE = MethodHandles.lookup().findVarHandle(MemorySessionImpl.class, \"state\", int.class);\n-        } catch (Throwable ex) {\n-            throw new ExceptionInInitializerError(ex);\n-        }\n-    }\n-\n-    static final int MAX_FORKS = Integer.MAX_VALUE;\n-\n-    @Override\n-    public void addCloseAction(Runnable runnable) {\n-        Objects.requireNonNull(runnable);\n-        addInternal(runnable instanceof ResourceList.ResourceCleanup cleanup ?\n-                cleanup : ResourceList.ResourceCleanup.ofRunnable(runnable));\n-    }\n-\n-    \/**\n-     * Add a cleanup action. If a failure occurred (because of a add vs. close race), call the cleanup action.\n-     * This semantics is useful when allocating new memory segments, since we first do a malloc\/mmap and _then_\n-     * we register the cleanup (free\/munmap) against the session; so, if registration fails, we still have to\n-     * cleanup memory. From the perspective of the client, such a failure would manifest as a factory\n-     * returning a segment that is already \"closed\" - which is always possible anyway (e.g. if the session\n-     * is closed _after_ the cleanup for the segment is registered but _before_ the factory returns the\n-     * new segment to the client). For this reason, it's not worth adding extra complexity to the segment\n-     * initialization logic here - and using an optimistic logic works well in practice.\n-     *\/\n-    public void addOrCleanupIfFail(ResourceList.ResourceCleanup resource) {\n-        try {\n-            addInternal(resource);\n-        } catch (Throwable ex) {\n-            resource.cleanup();\n-            throw ex;\n-        }\n-    }\n-\n-    void addInternal(ResourceList.ResourceCleanup resource) {\n-        checkValidStateSlow();\n-        \/\/ Note: from here on we no longer check the session state. Two cases are possible: either the resource cleanup\n-        \/\/ is added to the list when the session is still open, in which case everything works ok; or the resource\n-        \/\/ cleanup is added while the session is being closed. In this latter case, what matters is whether we have already\n-        \/\/ called `ResourceList::cleanup` to run all the cleanup actions. If not, we can still add this resource\n-        \/\/ to the list (and, in case of an add vs. close race, it might happen that the cleanup action will be\n-        \/\/ called immediately after).\n-        resourceList.add(resource);\n-    }\n-\n-    protected MemorySessionImpl(Thread owner, ResourceList resourceList, Cleaner cleaner) {\n-        this.owner = owner;\n-        this.resourceList = resourceList;\n-        cleanable = (cleaner != null) ?\n-            cleaner.register(this, resourceList) : null;\n-    }\n+public non-sealed class MemorySessionImpl implements MemorySession, SegmentAllocator {\n@@ -122,3 +53,1 @@\n-    public static MemorySession createConfined(Thread thread, Cleaner cleaner) {\n-        return new ConfinedSession(thread, cleaner);\n-    }\n+    final State state;\n@@ -126,2 +55,2 @@\n-    public static MemorySession createShared(Cleaner cleaner) {\n-        return new SharedSession(cleaner);\n+    public MemorySessionImpl(State state) {\n+        this.state = state;\n@@ -130,2 +59,2 @@\n-    public static MemorySessionImpl createImplicit() {\n-        return new ImplicitSession();\n+    public State state() {\n+        return state;\n@@ -135,2 +64,2 @@\n-    public MemorySegment allocate(long bytesSize, long bytesAlignment) {\n-        return MemorySegment.allocateNative(bytesSize, bytesAlignment, this);\n+    public final boolean isAlive() {\n+        return state.isAlive();\n@@ -139,4 +68,0 @@\n-    public abstract void release0();\n-\n-    public abstract void acquire0();\n-\n@@ -144,3 +69,2 @@\n-    public boolean equals(Object o) {\n-        return (o instanceof MemorySession other) &&\n-            toSessionImpl(other) == this;\n+    public boolean isCloseable() {\n+        return true;\n@@ -150,2 +74,2 @@\n-    public int hashCode() {\n-        return super.hashCode();\n+    public final Thread ownerThread() {\n+        return state.ownerThread();\n@@ -155,1 +79,1 @@\n-    public void whileAlive(Runnable action) {\n+    public final void whileAlive(Runnable action) {\n@@ -157,1 +81,1 @@\n-        acquire0();\n+        state.acquire();\n@@ -161,1 +85,1 @@\n-            release0();\n+            state.release();\n@@ -165,14 +89,0 @@\n-    \/**\n-     * Returns \"owner\" thread of this session.\n-     * @return owner thread (or null for a shared session)\n-     *\/\n-    public final Thread ownerThread() {\n-        return owner;\n-    }\n-\n-    \/**\n-     * Returns true, if this session is still open. This method may be called in any thread.\n-     * @return {@code true} if this session is not closed yet.\n-     *\/\n-    public abstract boolean isAlive();\n-\n@@ -180,7 +90,4 @@\n-    public MemorySession asNonCloseable() {\n-        return isCloseable() ?\n-                new NonCloseableView(this) : this;\n-    }\n-\n-    public static MemorySessionImpl toSessionImpl(MemorySession session) {\n-        return ((Scoped)session).sessionImpl();\n+    public void addCloseAction(Runnable runnable) {\n+        Objects.requireNonNull(runnable);\n+        state.checkValidStateWrapException();\n+        state.resourceList.add(State.ResourceCleanup.ofRunnable(runnable));\n@@ -190,32 +97,5 @@\n-    public MemorySessionImpl sessionImpl() {\n-        return this;\n-    }\n-\n-    \/**\n-     * This is a faster version of {@link #checkValidStateSlow()}, which is called upon memory access, and which\n-     * relies on invariants associated with the memory session implementations (volatile access\n-     * to the closed state bit is replaced with plain access). This method should be monomorphic,\n-     * to avoid virtual calls in the memory access hot path. This method is not intended as general purpose method\n-     * and should only be used in the memory access handle hot path; for liveness checks triggered by other API methods,\n-     * please use {@link #checkValidStateSlow()}.\n-     *\/\n-    @ForceInline\n-    public final void checkValidState() {\n-        if (owner != null && owner != Thread.currentThread()) {\n-            throw new WrongThreadException(\"Attempted access outside owning thread\");\n-        }\n-        if (state < OPEN) {\n-            throw ScopedMemoryAccess.ScopedAccessError.INSTANCE;\n-        }\n-    }\n-\n-    \/**\n-     * Checks that this session is still alive (see {@link #isAlive()}).\n-     * @throws IllegalStateException if this session is already closed or if this is\n-     * a confined session and this method is called outside of the owner thread.\n-     *\/\n-    public final void checkValidStateSlow() {\n-        if (owner != null && Thread.currentThread() != owner) {\n-            throw new WrongThreadException(\"Attempted access outside owning thread\");\n-        } else if (!isAlive()) {\n-            throw new IllegalStateException(\"Already closed\");\n+    public void close() {\n+        if (isCloseable()) {\n+            state.close();\n+        } else {\n+            throw new UnsupportedOperationException(\"Cannot close!\");\n@@ -226,2 +106,8 @@\n-    protected Object clone() throws CloneNotSupportedException {\n-        throw new CloneNotSupportedException();\n+    public final MemorySession asNonCloseable() {\n+        if (!isCloseable()) return this;\n+        return new MemorySessionImpl(state) {\n+            @Override\n+            public boolean isCloseable() {\n+                return false;\n+            }\n+        };\n@@ -231,2 +117,3 @@\n-    public boolean isCloseable() {\n-        return true;\n+    public final boolean equals(Object obj) {\n+        return obj instanceof MemorySessionImpl sessionImpl &&\n+                sessionImpl.state == state;\n@@ -235,5 +122,0 @@\n-    \/**\n-     * Closes this session, executing any cleanup action (where provided).\n-     * @throws IllegalStateException if this session is already closed or if this is\n-     * a confined session and this method is called outside of the owner thread.\n-     *\/\n@@ -241,11 +123,2 @@\n-    public void close() {\n-        try {\n-            justClose();\n-            if (cleanable != null) {\n-                cleanable.clean();\n-            } else {\n-                resourceList.cleanup();\n-            }\n-        } finally {\n-            Reference.reachabilityFence(this);\n-        }\n+    public final int hashCode() {\n+        return state.hashCode();\n@@ -254,8 +127,1 @@\n-    abstract void justClose();\n-\n-    \/**\n-     * The global, non-closeable, shared session. Similar to a shared session, but its {@link #close()} method throws unconditionally.\n-     * Adding new resources to the global session, does nothing: as the session can never become not-alive, there is nothing to track.\n-     * Acquiring and or releasing a memory session similarly does nothing.\n-     *\/\n-    static class GlobalSessionImpl extends MemorySessionImpl {\n+    \/\/ helper functions\n@@ -263,1 +129,3 @@\n-        final Object ref;\n+    public static void checkValidState(MemorySession session) {\n+        ((MemorySessionImpl)session).state.checkValidStateWrapException();\n+    }\n@@ -265,3 +133,6 @@\n-        public GlobalSessionImpl(Object ref) {\n-            super(null, null ,null);\n-            this.ref = ref;\n+    public static void addOrCleanupIfFail(MemorySession session, State.ResourceCleanup cleanup) {\n+        try {\n+            session.addCloseAction(cleanup);\n+        } catch (Throwable ex) {\n+            cleanup.cleanup();\n+            throw ex;\n@@ -269,0 +140,4 @@\n+    }\n+\n+    \/** The global memory session *\/\n+    public final static MemorySessionImpl GLOBAL = new MemorySessionImpl(new SharedSessionState.OfImplicit()) {\n@@ -271,2 +146,2 @@\n-        @ForceInline\n-        public void release0() {\n+        public void addCloseAction(Runnable runnable) {\n+            Objects.requireNonNull(runnable);\n@@ -280,0 +155,1 @@\n+    };\n@@ -281,5 +157,1 @@\n-        @Override\n-        @ForceInline\n-        public void acquire0() {\n-            \/\/ do nothing\n-        }\n+    \/\/ session factories\n@@ -287,4 +159,3 @@\n-        @Override\n-        void addInternal(ResourceList.ResourceCleanup resource) {\n-            \/\/ do nothing\n-        }\n+    public final static MemorySessionImpl heapSession(Object o) {\n+        return createImplicit(o);\n+    }\n@@ -292,4 +163,3 @@\n-        @Override\n-        public boolean isAlive() {\n-            return true;\n-        }\n+    public final static MemorySessionImpl createConfined(Thread thread, Cleaner cleaner) {\n+        return new MemorySessionImpl(new ConfinedSessionState(thread, cleaner));\n+    }\n@@ -297,4 +167,2 @@\n-        @Override\n-        public void justClose() {\n-            throw new UnsupportedOperationException();\n-        }\n+    public final static MemorySessionImpl createShared(Cleaner cleaner) {\n+        return new MemorySessionImpl(new SharedSessionState(cleaner));\n@@ -303,1 +171,3 @@\n-    public static final MemorySessionImpl GLOBAL = new GlobalSessionImpl(null);\n+    public final static MemorySessionImpl createImplicit(Object ref) {\n+        return new MemorySessionImpl(new SharedSessionState.OfImplicit()) {\n+            final Object o = ref;\n@@ -305,2 +175,5 @@\n-    public static MemorySessionImpl heapSession(Object ref) {\n-        return new GlobalSessionImpl(ref);\n+            @Override\n+            public boolean isCloseable() {\n+                return false;\n+            }\n+        };\n@@ -310,6 +183,12 @@\n-     * This is an implicit, GC-backed memory session. Implicit sessions cannot be closed explicitly.\n-     * While it would be possible to model an implicit session as a non-closeable view of a shared\n-     * session, it is better to capture the fact that an implicit session is not just a non-closeable\n-     * view of some session which might be closeable. This is useful e.g. in the implementations of\n-     * {@link DirectBuffer#address()}, where obtaining an address of a buffer instance associated\n-     * with a potentially closeable session is forbidden.\n+     * This class is used to model the state of a memory session. It contains a {@link State#state liveness bit},\n+     * which can also be used to implement reference counting. There are two three main kinds of session states:\n+     * {@linkplain ConfinedSessionState confined state}, {@link SharedSessionState shared state} and\n+     * {@link SharedSessionState.OfImplicit implicit state}, each of which is implemented in its own subclass.\n+     * Different kinds of session state implementations feature different performance characteristics: for instance\n+     * closing a confined session state is much cheaper than closing a shared session state.\n+     * <p>\n+     * Memory session state support reference counting: the state can be acquired and released; when the state\n+     * is in the acquired state, it cannot be closed until it is released. This is useful to make sure that\n+     * memory sessions cannot be closed prematurely, e.g. while a native function call is executing,\n+     * or while the segment is manipulated by some asynchronous IO operation, like\n+     * {@link java.nio.channels.AsynchronousSocketChannel#read(ByteBuffer)}.\n@@ -317,1 +196,1 @@\n-    static class ImplicitSession extends SharedSession {\n+    public abstract static class State {\n@@ -319,3 +198,3 @@\n-        public ImplicitSession() {\n-            super(CleanerFactory.cleaner());\n-        }\n+        static final int OPEN = 0;\n+        static final int CLOSING = -1;\n+        static final int CLOSED = -2;\n@@ -323,4 +202,2 @@\n-        @Override\n-        public void release0() {\n-            Reference.reachabilityFence(this);\n-        }\n+        int state = OPEN;\n+        final Thread owner;\n@@ -328,4 +205,1 @@\n-        @Override\n-        public void acquire0() {\n-            \/\/ do nothing\n-        }\n+        static final VarHandle STATE;\n@@ -333,3 +207,6 @@\n-        @Override\n-        public boolean isCloseable() {\n-            return false;\n+        static {\n+            try {\n+                STATE = MethodHandles.lookup().findVarHandle(State.class, \"state\", int.class);\n+            } catch (Throwable ex) {\n+                throw new ExceptionInInitializerError(ex);\n+            }\n@@ -338,4 +215,1 @@\n-        @Override\n-        public boolean isAlive() {\n-            return true;\n-        }\n+        static final int MAX_FORKS = Integer.MAX_VALUE;\n@@ -343,4 +217,2 @@\n-        @Override\n-        public MemorySession asNonCloseable() {\n-            return this;\n-        }\n+        final Cleaner.Cleanable cleanable;\n+        final ResourceList resourceList;\n@@ -348,3 +220,6 @@\n-        @Override\n-        public void justClose() {\n-            throw new UnsupportedOperationException();\n+        State(Thread owner, ResourceList resourceList, Cleaner cleaner) {\n+            this.resourceList = resourceList;\n+            this.owner = owner;\n+            cleanable = cleaner != null ?\n+                    cleaner.register(this, resourceList) :\n+                    null;\n@@ -352,1 +227,0 @@\n-    }\n@@ -354,12 +228,11 @@\n-    \/**\n-     * This is a non-closeable view of another memory session. Instances of this class are used in resource session\n-     * accessors (see {@link MemorySegment#session()}). This class forwards all session methods to the underlying\n-     * \"root\" session implementation, and throws {@link UnsupportedOperationException} on close. This class contains\n-     * a strong reference to the original session, so even if the original session is dropped by the client\n-     * it would still be reachable by the GC, which is important if the session is implicitly closed.\n-     *\/\n-    public final static class NonCloseableView implements MemorySession, Scoped {\n-        final MemorySessionImpl session;\n-\n-        public NonCloseableView(MemorySessionImpl session) {\n-            this.session = session;\n+        final void close() {\n+            try {\n+                justClose();\n+                if (cleanable != null) {\n+                    cleanable.clean();\n+                } else {\n+                    resourceList.cleanup();\n+                }\n+            } finally {\n+                Reference.reachabilityFence(this);\n+            }\n@@ -368,3 +241,1 @@\n-        public MemorySessionImpl sessionImpl() {\n-            return session;\n-        }\n+        abstract void justClose();\n@@ -372,3 +243,6 @@\n-        @Override\n-        public boolean isAlive() {\n-            return session.isAlive();\n+        public final void checkValidStateWrapException() {\n+            try {\n+                checkValidState();\n+            } catch (ScopedMemoryAccess.ScopedAccessError ex) {\n+                throw ex.newRuntimeException();\n+            }\n@@ -377,2 +251,1 @@\n-        @Override\n-        public boolean isCloseable() {\n+        public boolean isImplicit() {\n@@ -382,4 +255,1 @@\n-        @Override\n-        public Thread ownerThread() {\n-            return session.ownerThread();\n-        }\n+        abstract boolean isAlive();\n@@ -387,3 +257,2 @@\n-        @Override\n-        public boolean equals(Object o) {\n-            return session.equals(o);\n+        public final Thread ownerThread() {\n+            return owner;\n@@ -392,3 +261,15 @@\n-        @Override\n-        public int hashCode() {\n-            return session.hashCode();\n+        \/*\n+         * This is the liveness check used by classes such as ScopedMemoryAccess. To allow for better inlining,\n+         * this method is kept monomorphic. Note that we cannot create exceptions while executing this method,\n+         * as doing so will end up creating a deep stack trace; this interferes with the algorithm we use\n+         * to make sure that no other thread is accessing a shared memory session while the session is closed.\n+         * Note also that this routine performs only plain access checks: this is by design, see comments\n+         * in ScopedMemoryAccess.\n+         *\/\n+        @ForceInline\n+        public final void checkValidState() {\n+            if (owner != null && owner != Thread.currentThread()) {\n+                throw WRONG_THREAD;\n+            } else if (state < OPEN) {\n+                throw ALREADY_CLOSED;\n+            }\n@@ -397,3 +278,8 @@\n-        @Override\n-        public void whileAlive(Runnable action) {\n-            session.whileAlive(action);\n+        public abstract void acquire();\n+\n+        public abstract void release();\n+\n+        \/\/ helper functions to centralize error handling\n+\n+        static IllegalStateException tooManyAcquires() {\n+            return new IllegalStateException(\"Session acquire limit exceeded\");\n@@ -402,3 +288,2 @@\n-        @Override\n-        public MemorySession asNonCloseable() {\n-            return this;\n+        static IllegalStateException alreadyAcquired(int acquires) {\n+            return new IllegalStateException(String.format(\"Session is acquired by %d clients\", acquires));\n@@ -407,3 +292,2 @@\n-        @Override\n-        public void addCloseAction(Runnable runnable) {\n-            session.addCloseAction(runnable);\n+        static IllegalStateException alreadyClosed() {\n+            return new IllegalStateException(\"Already closed\");\n@@ -412,3 +296,2 @@\n-        @Override\n-        public void close() {\n-            throw new UnsupportedOperationException();\n+        static WrongThreadException wrongThread() {\n+            return new WrongThreadException(\"Attempted access outside owning thread\");\n@@ -416,1 +299,0 @@\n-    }\n@@ -418,8 +300,1 @@\n-    \/**\n-     * A list of all cleanup actions associated with a memory session. Cleanup actions are modelled as instances\n-     * of the {@link ResourceCleanup} class, and, together, form a linked list. Depending on whether a session\n-     * is shared or confined, different implementations of this class will be used, see {@link ConfinedSession.ConfinedResourceList}\n-     * and {@link SharedSession.SharedResourceList}.\n-     *\/\n-    public abstract static class ResourceList implements Runnable {\n-        ResourceCleanup fst;\n+        static final ScopedMemoryAccess.ScopedAccessError ALREADY_CLOSED = new ScopedMemoryAccess.ScopedAccessError(State::alreadyClosed);\n@@ -427,1 +302,1 @@\n-        abstract void add(ResourceCleanup cleanup);\n+        static final ScopedMemoryAccess.ScopedAccessError WRONG_THREAD = new ScopedMemoryAccess.ScopedAccessError(State::wrongThread);\n@@ -429,1 +304,8 @@\n-        abstract void cleanup();\n+        \/**\n+         * A list of all cleanup actions associated with a memory session state. Cleanup actions are modelled as instances\n+         * of the {@link ResourceCleanup} class, and, together, form a linked list. Depending on whether a session\n+         * is shared or confined, different implementations of this class will be used, see {@link ConfinedSessionState.ConfinedList}\n+         * and {@link SharedSessionState.SharedList}.\n+         *\/\n+        abstract static class ResourceList implements Runnable {\n+            ResourceCleanup fst;\n@@ -431,3 +313,7 @@\n-        public final void run() {\n-            cleanup(); \/\/ cleaner interop\n-        }\n+            abstract void add(ResourceCleanup cleanup);\n+\n+            abstract void cleanup();\n+\n+            public final void run() {\n+                cleanup(); \/\/ cleaner interop\n+            }\n@@ -435,5 +321,6 @@\n-        static void cleanup(ResourceCleanup first) {\n-            ResourceCleanup current = first;\n-            while (current != null) {\n-                current.cleanup();\n-                current = current.next;\n+            static void cleanup(ResourceCleanup first) {\n+                ResourceCleanup current = first;\n+                while (current != null) {\n+                    current.cleanup();\n+                    current = current.next;\n+                }\n@@ -443,1 +330,6 @@\n-        public abstract static class ResourceCleanup {\n+        \/**\n+         * This class is used to model a resource that can be managed by a memory session. It features\n+         * a method that can be used to cleanup the resource (this method is typically called when\n+         * the memory session is closed).\n+         *\/\n+        public abstract static class ResourceCleanup implements Runnable {\n@@ -448,0 +340,4 @@\n+            public final void run() {\n+                cleanup();\n+            }\n+\n@@ -456,6 +352,8 @@\n-                return new ResourceCleanup() {\n-                    @Override\n-                    public void cleanup() {\n-                        cleanupAction.run();\n-                    }\n-                };\n+                return cleanupAction instanceof ResourceCleanup ?\n+                        (ResourceCleanup)cleanupAction :\n+                        new ResourceCleanup() {\n+                            @Override\n+                            public void cleanup() {\n+                                cleanupAction.run();\n+                            }\n+                        };\n@@ -464,1 +362,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/MemorySessionImpl.java","additions":206,"deletions":309,"binary":false,"changes":515,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-    public static final MemorySegment EVERYTHING = new NativeMemorySegmentImpl(0, Long.MAX_VALUE, 0, MemorySessionImpl.GLOBAL) {\n+    public static final MemorySegment EVERYTHING = new NativeMemorySegmentImpl(0, Long.MAX_VALUE, false, MemorySessionImpl.GLOBAL) {\n@@ -51,1 +51,1 @@\n-        NativeMemorySegmentImpl dup(long offset, long size, int mask, MemorySession scope) {\n+        NativeMemorySegmentImpl dup(long offset, long size, boolean isReadOnly, MemorySessionImpl session) {\n@@ -67,2 +67,2 @@\n-    NativeMemorySegmentImpl(long min, long length, int mask, MemorySession session) {\n-        super(length, mask, session);\n+    NativeMemorySegmentImpl(long min, long length, boolean isReadOnly, MemorySessionImpl session) {\n+        super(length, isReadOnly, session);\n@@ -76,1 +76,1 @@\n-        return MemoryAddress.ofLong(unsafeGetOffset());\n+        return MemoryAddress.ofLong(min());\n@@ -80,2 +80,2 @@\n-    NativeMemorySegmentImpl dup(long offset, long size, int mask, MemorySession session) {\n-        return new NativeMemorySegmentImpl(min + offset, size, mask, session);\n+    NativeMemorySegmentImpl dup(long offset, long size, boolean isReadOnly, MemorySessionImpl session) {\n+        return new NativeMemorySegmentImpl(min + offset, size, isReadOnly, session);\n@@ -96,1 +96,1 @@\n-    long min() {\n+    public long min() {\n@@ -101,1 +101,1 @@\n-    Object base() {\n+    public Object base() {\n@@ -113,2 +113,1 @@\n-        MemorySessionImpl sessionImpl = MemorySessionImpl.toSessionImpl(session);\n-        sessionImpl.checkValidStateSlow();\n+        MemorySessionImpl.checkValidState(session);\n@@ -130,2 +129,2 @@\n-                DEFAULT_MODES, session);\n-        sessionImpl.addOrCleanupIfFail(new MemorySessionImpl.ResourceList.ResourceCleanup() {\n+                false, (MemorySessionImpl)session);\n+        MemorySessionImpl.addOrCleanupIfFail(session, new MemorySessionImpl.State.ResourceCleanup() {\n@@ -146,4 +145,2 @@\n-        MemorySessionImpl sessionImpl = MemorySessionImpl.toSessionImpl(session);\n-        sessionImpl.checkValidStateSlow();\n-        AbstractMemorySegmentImpl segment = new NativeMemorySegmentImpl(min.toRawLongValue(), bytesSize, DEFAULT_MODES, session);\n-        return segment;\n+        MemorySessionImpl.checkValidState(session);\n+        return new NativeMemorySegmentImpl(min.toRawLongValue(), bytesSize, false, (MemorySessionImpl)session);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/NativeMemorySegmentImpl.java","additions":14,"deletions":17,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-    MemorySessionImpl sessionImpl();\n+    MemorySessionImpl session();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/Scoped.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,151 +0,0 @@\n-\/*\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.internal.foreign;\n-\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.VarHandle;\n-import java.lang.ref.Cleaner;\n-import jdk.internal.misc.ScopedMemoryAccess;\n-import jdk.internal.vm.annotation.ForceInline;\n-\n-\/**\n- * A shared session, which can be shared across multiple threads. Closing a shared session has to ensure that\n- * (i) only one thread can successfully close a session (e.g. in a close vs. close race) and that\n- * (ii) no other thread is accessing the memory associated with this session while the segment is being\n- * closed. To ensure the former condition, a CAS is performed on the liveness bit. Ensuring the latter\n- * is trickier, and require a complex synchronization protocol (see {@link jdk.internal.misc.ScopedMemoryAccess}).\n- * Since it is the responsibility of the closing thread to make sure that no concurrent access is possible,\n- * checking the liveness bit upon access can be performed in plain mode, as in the confined case.\n- *\/\n-class SharedSession extends MemorySessionImpl {\n-\n-    private static final ScopedMemoryAccess SCOPED_MEMORY_ACCESS = ScopedMemoryAccess.getScopedMemoryAccess();\n-\n-    SharedSession(Cleaner cleaner) {\n-        super(null, new SharedResourceList(), cleaner);\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public void acquire0() {\n-        int value;\n-        do {\n-            value = (int) STATE.getVolatile(this);\n-            if (value < OPEN) {\n-                \/\/segment is not open!\n-                throw new IllegalStateException(\"Already closed\");\n-            } else if (value == MAX_FORKS) {\n-                \/\/overflow\n-                throw new IllegalStateException(\"Session acquire limit exceeded\");\n-            }\n-        } while (!STATE.compareAndSet(this, value, value + 1));\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public void release0() {\n-        int value;\n-        do {\n-            value = (int) STATE.getVolatile(this);\n-            if (value <= OPEN) {\n-                \/\/cannot get here - we can't close segment twice\n-                throw new IllegalStateException(\"Already closed\");\n-            }\n-        } while (!STATE.compareAndSet(this, value, value - 1));\n-    }\n-\n-    void justClose() {\n-        int prevState = (int) STATE.compareAndExchange(this, OPEN, CLOSING);\n-        if (prevState < 0) {\n-            throw new IllegalStateException(\"Already closed\");\n-        } else if (prevState != OPEN) {\n-            throw new IllegalStateException(\"Session is acquired by \" + prevState + \" clients\");\n-        }\n-        boolean success = SCOPED_MEMORY_ACCESS.closeScope(this);\n-        STATE.setVolatile(this, success ? CLOSED : OPEN);\n-        if (!success) {\n-            throw new IllegalStateException(\"Session is acquired by 1 client\");\n-        }\n-    }\n-\n-    @Override\n-    public boolean isAlive() {\n-        return (int) STATE.getVolatile(this) != CLOSED;\n-    }\n-\n-    \/**\n-     * A shared resource list; this implementation has to handle add vs. add races, as well as add vs. cleanup races.\n-     *\/\n-    static class SharedResourceList extends ResourceList {\n-\n-        static final VarHandle FST;\n-\n-        static {\n-            try {\n-                FST = MethodHandles.lookup().findVarHandle(ResourceList.class, \"fst\", ResourceCleanup.class);\n-            } catch (Throwable ex) {\n-                throw new ExceptionInInitializerError();\n-            }\n-        }\n-\n-        @Override\n-        void add(ResourceCleanup cleanup) {\n-            while (true) {\n-                ResourceCleanup prev = (ResourceCleanup) FST.getVolatile(this);\n-                if (prev == ResourceCleanup.CLOSED_LIST) {\n-                    \/\/ too late\n-                    throw new IllegalStateException(\"Already closed\");\n-                }\n-                cleanup.next = prev;\n-                if (FST.compareAndSet(this, prev, cleanup)) {\n-                    return; \/\/victory\n-                }\n-                \/\/ keep trying\n-            }\n-        }\n-\n-        void cleanup() {\n-            \/\/ At this point we are only interested about add vs. close races - not close vs. close\n-            \/\/ (because MemorySessionImpl::justClose ensured that this thread won the race to close the session).\n-            \/\/ So, the only \"bad\" thing that could happen is that some other thread adds to this list\n-            \/\/ while we're closing it.\n-            if (FST.getAcquire(this) != ResourceCleanup.CLOSED_LIST) {\n-                \/\/ok now we're really closing down\n-                ResourceCleanup prev = null;\n-                while (true) {\n-                    prev = (ResourceCleanup) FST.getVolatile(this);\n-                    \/\/ no need to check for DUMMY, since only one thread can get here!\n-                    if (FST.compareAndSet(this, prev, ResourceCleanup.CLOSED_LIST)) {\n-                        break;\n-                    }\n-                }\n-                cleanup(prev);\n-            } else {\n-                throw new IllegalStateException(\"Attempt to cleanup an already closed resource list\");\n-            }\n-        }\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/SharedSession.java","additions":0,"deletions":151,"binary":false,"changes":151,"status":"deleted"},{"patch":"@@ -0,0 +1,175 @@\n+\/*\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.foreign;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n+import java.lang.ref.Cleaner;\n+import java.lang.ref.Reference;\n+\n+import jdk.internal.misc.ScopedMemoryAccess;\n+import jdk.internal.ref.CleanerFactory;\n+import jdk.internal.vm.annotation.ForceInline;\n+\n+\/**\n+ * A shared session state, which can be manipulated by multiple threads. Closing a shared state has to ensure that\n+ * (i) only one thread can successfully close the state (e.g. in a close vs. close race) and that\n+ * (ii) no other thread is accessing the memory associated with this state while the state is being\n+ * closed. To ensure the former condition, a CAS is performed on the liveness bit. Ensuring the latter\n+ * is trickier, and require a complex synchronization protocol (see {@link jdk.internal.misc.ScopedMemoryAccess}).\n+ * Since it is the responsibility of the closing thread to make sure that no concurrent access is possible,\n+ * checking the liveness bit upon access can be performed in plain mode, as in the confined case.\n+ *\/\n+class SharedSessionState extends MemorySessionImpl.State {\n+\n+    private static final ScopedMemoryAccess SCOPED_MEMORY_ACCESS = ScopedMemoryAccess.getScopedMemoryAccess();\n+\n+    SharedSessionState(Cleaner cleaner) {\n+        super(null, new SharedList(), cleaner);\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public void acquire() {\n+        int value;\n+        do {\n+            value = (int) STATE.getVolatile(this);\n+            if (value < OPEN) {\n+                \/\/segment is not open!\n+                throw alreadyClosed();\n+            } else if (value == MAX_FORKS) {\n+                \/\/overflow\n+                throw tooManyAcquires();\n+            }\n+        } while (!STATE.compareAndSet(this, value, value + 1));\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public void release() {\n+        int value;\n+        do {\n+            value = (int) STATE.getVolatile(this);\n+            if (value <= OPEN) {\n+                \/\/cannot get here - we can't close segment twice\n+                throw alreadyClosed();\n+            }\n+        } while (!STATE.compareAndSet(this, value, value - 1));\n+    }\n+\n+    void justClose() {\n+        int prevState = (int) STATE.compareAndExchange(this, OPEN, CLOSING);\n+        if (prevState < 0) {\n+            throw alreadyClosed();\n+        } else if (prevState != OPEN) {\n+            throw alreadyAcquired(prevState);\n+        }\n+        boolean success = SCOPED_MEMORY_ACCESS.closeScope(this);\n+        STATE.setVolatile(this, success ? CLOSED : OPEN);\n+        if (!success) {\n+            throw alreadyAcquired(1);\n+        }\n+    }\n+\n+    @Override\n+    boolean isAlive() {\n+        return (int) STATE.getVolatile(this) != CLOSED;\n+    }\n+\n+    \/**\n+     * A shared resource list; this implementation has to handle add vs. add races, as well as add vs. cleanup races.\n+     *\/\n+    static class SharedList extends ResourceList {\n+\n+        static final VarHandle FST;\n+\n+        static {\n+            try {\n+                FST = MethodHandles.lookup().findVarHandle(ResourceList.class, \"fst\", ResourceCleanup.class);\n+            } catch (Throwable ex) {\n+                throw new ExceptionInInitializerError();\n+            }\n+        }\n+\n+        @Override\n+        void add(ResourceCleanup cleanup) {\n+            while (true) {\n+                ResourceCleanup prev = (ResourceCleanup) FST.getVolatile(this);\n+                if (prev == ResourceCleanup.CLOSED_LIST) {\n+                    \/\/ too late\n+                    throw alreadyClosed();\n+                }\n+                cleanup.next = prev;\n+                if (FST.compareAndSet(this, prev, cleanup)) {\n+                    return; \/\/victory\n+                }\n+                \/\/ keep trying\n+            }\n+        }\n+\n+        void cleanup() {\n+            \/\/ At this point we are only interested about add vs. close races - not close vs. close\n+            \/\/ (because MemorySessionImpl::justClose ensured that this thread won the race to close the session).\n+            \/\/ So, the only \"bad\" thing that could happen is that some other thread adds to this list\n+            \/\/ while we're closing it.\n+            if (FST.getAcquire(this) != ResourceCleanup.CLOSED_LIST) {\n+                \/\/ok now we're really closing down\n+                ResourceCleanup prev = null;\n+                while (true) {\n+                    prev = (ResourceCleanup) FST.getVolatile(this);\n+                    \/\/ no need to check for DUMMY, since only one thread can get here!\n+                    if (FST.compareAndSet(this, prev, ResourceCleanup.CLOSED_LIST)) {\n+                        break;\n+                    }\n+                }\n+                cleanup(prev);\n+            } else {\n+                throw alreadyClosed();\n+            }\n+        }\n+    }\n+\n+    static final class OfImplicit extends SharedSessionState {\n+        OfImplicit() {\n+            super(CleanerFactory.cleaner());\n+        }\n+\n+        @Override\n+        public void acquire() {\n+            \/\/ do nothing\n+        }\n+\n+        public boolean isImplicit() {\n+            return true;\n+        }\n+\n+        @Override\n+        public void release() {\n+            Reference.reachabilityFence(this);\n+        }\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/SharedSessionState.java","additions":175,"deletions":0,"binary":false,"changes":175,"status":"added"},{"patch":"@@ -89,0 +89,2 @@\n+\n+    private static final String SESSION_STATE_DESC = methodType(MemorySessionImpl.State.class).descriptorString();\n@@ -497,1 +499,2 @@\n-        emitInvokeInterface(Scoped.class, \"sessionImpl\", SESSION_IMPL_DESC);\n+        emitInvokeInterface(Scoped.class, \"session\", SESSION_IMPL_DESC);\n+        emitInvokeVirtual(MemorySessionImpl.class, \"state\", SESSION_STATE_DESC);\n@@ -514,1 +517,1 @@\n-        emitInvokeVirtual(MemorySessionImpl.class, \"acquire0\", ACQUIRE0_DESC); \/\/ call acquire on the other\n+        emitInvokeVirtual(MemorySessionImpl.State.class, \"acquire\", ACQUIRE0_DESC); \/\/ call acquire on the other\n@@ -533,1 +536,1 @@\n-            emitInvokeVirtual(MemorySessionImpl.class, \"release0\", RELEASE0_DESC);\n+            emitInvokeVirtual(MemorySessionImpl.State.class, \"release\", RELEASE0_DESC);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/BindingSpecializer.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -444,6 +444,1 @@\n-        public MemorySession session() {\n-            return MemorySessionImpl.GLOBAL;\n-        }\n-\n-        @Override\n-        public MemorySessionImpl sessionImpl() {\n+        public MemorySessionImpl session() {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/SharedUtils.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-        MemorySessionImpl.toSessionImpl(session).addOrCleanupIfFail(new MemorySessionImpl.ResourceList.ResourceCleanup() {\n+        MemorySessionImpl.addOrCleanupIfFail(session, new MemorySessionImpl.State.ResourceCleanup() {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/UpcallStubs.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -323,1 +323,1 @@\n-        MemorySessionImpl.toSessionImpl(session()).checkValidStateSlow();\n+        MemorySessionImpl.checkValidState(session());\n@@ -349,7 +349,2 @@\n-    public MemorySession session() {\n-        return segment.session();\n-    }\n-\n-    @Override\n-    public MemorySessionImpl sessionImpl() {\n-        return MemorySessionImpl.toSessionImpl(session());\n+    public MemorySessionImpl session() {\n+        return (MemorySessionImpl)segment.session();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/linux\/LinuxAArch64VaList.java","additions":3,"deletions":8,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -130,1 +130,1 @@\n-        MemorySessionImpl.toSessionImpl(session()).checkValidStateSlow();\n+        MemorySessionImpl.checkValidState(session);\n@@ -151,7 +151,2 @@\n-    public MemorySession session() {\n-        return session;\n-    }\n-\n-    @Override\n-    public MemorySessionImpl sessionImpl() {\n-        return MemorySessionImpl.toSessionImpl(session());\n+    public MemorySessionImpl session() {\n+        return (MemorySessionImpl)session;\n@@ -162,1 +157,1 @@\n-        MemorySessionImpl.toSessionImpl(session()).checkValidStateSlow();\n+        MemorySessionImpl.checkValidState(session);\n@@ -177,1 +172,1 @@\n-            MemorySessionImpl.toSessionImpl(session).checkValidStateSlow();\n+            MemorySessionImpl.checkValidState(session);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/macos\/MacOsAArch64VaList.java","additions":5,"deletions":10,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -280,1 +280,1 @@\n-        MemorySessionImpl.toSessionImpl(session()).checkValidStateSlow();\n+        MemorySessionImpl.checkValidState(session());\n@@ -303,7 +303,2 @@\n-    public MemorySession session() {\n-        return segment.session();\n-    }\n-\n-    @Override\n-    public MemorySessionImpl sessionImpl() {\n-        return MemorySessionImpl.toSessionImpl(session());\n+    public MemorySessionImpl session() {\n+        return (MemorySessionImpl)segment.session();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/SysVVaList.java","additions":3,"deletions":8,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -136,1 +136,1 @@\n-        MemorySessionImpl.toSessionImpl(session()).checkValidStateSlow();\n+        MemorySessionImpl.checkValidState(session);\n@@ -151,7 +151,2 @@\n-    public MemorySession session() {\n-        return session;\n-    }\n-\n-    @Override\n-    public MemorySessionImpl sessionImpl() {\n-        return MemorySessionImpl.toSessionImpl(session());\n+    public MemorySessionImpl session() {\n+        return (MemorySessionImpl)session;\n@@ -162,1 +157,1 @@\n-        MemorySessionImpl.toSessionImpl(session).checkValidStateSlow();\n+        MemorySessionImpl.checkValidState(session);\n@@ -177,1 +172,1 @@\n-            MemorySessionImpl.toSessionImpl(session).checkValidStateSlow();\n+            MemorySessionImpl.checkValidState(session);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/WinVaList.java","additions":5,"deletions":10,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-    public $type$ get$Type$(MemorySessionImpl session, Object base, long offset) {\n+    public $type$ get$Type$(MemorySessionImpl.State state, Object base, long offset) {\n@@ -4,1 +4,1 @@\n-            return get$Type$Internal(session, base, offset);\n+            return get$Type$Internal(state, base, offset);\n@@ -6,1 +6,1 @@\n-            throw new IllegalStateException(\"This segment is already closed\");\n+            throw ex.newRuntimeException();\n@@ -11,1 +11,1 @@\n-    private $type$ get$Type$Internal(MemorySessionImpl session, Object base, long offset) {\n+    private $type$ get$Type$Internal(MemorySessionImpl.State state, Object base, long offset) {\n@@ -13,2 +13,2 @@\n-            if (session != null) {\n-                session.checkValidState();\n+            if (state != null) {\n+                state.checkValidState();\n@@ -18,1 +18,1 @@\n-            Reference.reachabilityFence(session);\n+            Reference.reachabilityFence(state);\n@@ -23,1 +23,1 @@\n-    public void put$Type$(MemorySessionImpl session, Object base, long offset, $type$ value) {\n+    public void put$Type$(MemorySessionImpl.State state, Object base, long offset, $type$ value) {\n@@ -25,1 +25,1 @@\n-            put$Type$Internal(session, base, offset, value);\n+            put$Type$Internal(state, base, offset, value);\n@@ -27,1 +27,1 @@\n-            throw new IllegalStateException(\"This segment is already closed\");\n+            throw ex.newRuntimeException();\n@@ -32,1 +32,1 @@\n-    private void put$Type$Internal(MemorySessionImpl session, Object base, long offset, $type$ value) {\n+    private void put$Type$Internal(MemorySessionImpl.State state, Object base, long offset, $type$ value) {\n@@ -34,2 +34,2 @@\n-            if (session != null) {\n-                session.checkValidState();\n+            if (state != null) {\n+                state.checkValidState();\n@@ -39,1 +39,1 @@\n-            Reference.reachabilityFence(session);\n+            Reference.reachabilityFence(state);\n@@ -45,1 +45,1 @@\n-    public $type$ get$Type$Unaligned(MemorySessionImpl session, Object base, long offset, boolean be) {\n+    public $type$ get$Type$Unaligned(MemorySessionImpl.State state, Object base, long offset, boolean be) {\n@@ -47,1 +47,1 @@\n-            return get$Type$UnalignedInternal(session, base, offset, be);\n+            return get$Type$UnalignedInternal(state, base, offset, be);\n@@ -49,1 +49,1 @@\n-            throw new IllegalStateException(\"This segment is already closed\");\n+            throw ex.newRuntimeException();\n@@ -54,1 +54,1 @@\n-    private $type$ get$Type$UnalignedInternal(MemorySessionImpl session, Object base, long offset, boolean be) {\n+    private $type$ get$Type$UnalignedInternal(MemorySessionImpl.State state, Object base, long offset, boolean be) {\n@@ -56,2 +56,2 @@\n-            if (session != null) {\n-                session.checkValidState();\n+            if (state != null) {\n+                state.checkValidState();\n@@ -61,1 +61,1 @@\n-            Reference.reachabilityFence(session);\n+            Reference.reachabilityFence(state);\n@@ -66,1 +66,1 @@\n-    public void put$Type$Unaligned(MemorySessionImpl session, Object base, long offset, $type$ value, boolean be) {\n+    public void put$Type$Unaligned(MemorySessionImpl.State state, Object base, long offset, $type$ value, boolean be) {\n@@ -68,1 +68,1 @@\n-            put$Type$UnalignedInternal(session, base, offset, value, be);\n+            put$Type$UnalignedInternal(state, base, offset, value, be);\n@@ -70,1 +70,1 @@\n-            throw new IllegalStateException(\"This segment is already closed\");\n+            throw ex.newRuntimeException();\n@@ -75,1 +75,1 @@\n-    private void put$Type$UnalignedInternal(MemorySessionImpl session, Object base, long offset, $type$ value, boolean be) {\n+    private void put$Type$UnalignedInternal(MemorySessionImpl.State state, Object base, long offset, $type$ value, boolean be) {\n@@ -77,2 +77,2 @@\n-            if (session != null) {\n-                session.checkValidState();\n+            if (state != null) {\n+                state.checkValidState();\n@@ -82,1 +82,1 @@\n-            Reference.reachabilityFence(session);\n+            Reference.reachabilityFence(state);\n@@ -88,1 +88,1 @@\n-    public $type$ get$Type$Volatile(MemorySessionImpl session, Object base, long offset) {\n+    public $type$ get$Type$Volatile(MemorySessionImpl.State state, Object base, long offset) {\n@@ -90,1 +90,1 @@\n-            return get$Type$VolatileInternal(session, base, offset);\n+            return get$Type$VolatileInternal(state, base, offset);\n@@ -92,1 +92,1 @@\n-            throw new IllegalStateException(\"This segment is already closed\");\n+            throw ex.newRuntimeException();\n@@ -97,1 +97,1 @@\n-    private $type$ get$Type$VolatileInternal(MemorySessionImpl session, Object base, long offset) {\n+    private $type$ get$Type$VolatileInternal(MemorySessionImpl.State state, Object base, long offset) {\n@@ -99,2 +99,2 @@\n-            if (session != null) {\n-                session.checkValidState();\n+            if (state != null) {\n+                state.checkValidState();\n@@ -104,1 +104,1 @@\n-            Reference.reachabilityFence(session);\n+            Reference.reachabilityFence(state);\n@@ -109,1 +109,1 @@\n-    public void put$Type$Volatile(MemorySessionImpl session, Object base, long offset, $type$ value) {\n+    public void put$Type$Volatile(MemorySessionImpl.State state, Object base, long offset, $type$ value) {\n@@ -111,1 +111,1 @@\n-            put$Type$VolatileInternal(session, base, offset, value);\n+            put$Type$VolatileInternal(state, base, offset, value);\n@@ -113,1 +113,1 @@\n-            throw new IllegalStateException(\"This segment is already closed\");\n+            throw ex.newRuntimeException();\n@@ -118,1 +118,1 @@\n-    private void put$Type$VolatileInternal(MemorySessionImpl session, Object base, long offset, $type$ value) {\n+    private void put$Type$VolatileInternal(MemorySessionImpl.State state, Object base, long offset, $type$ value) {\n@@ -120,2 +120,2 @@\n-            if (session != null) {\n-                session.checkValidState();\n+            if (state != null) {\n+                state.checkValidState();\n@@ -125,1 +125,1 @@\n-            Reference.reachabilityFence(session);\n+            Reference.reachabilityFence(state);\n@@ -130,1 +130,1 @@\n-    public $type$ get$Type$Acquire(MemorySessionImpl session, Object base, long offset) {\n+    public $type$ get$Type$Acquire(MemorySessionImpl.State state, Object base, long offset) {\n@@ -132,1 +132,1 @@\n-            return get$Type$AcquireInternal(session, base, offset);\n+            return get$Type$AcquireInternal(state, base, offset);\n@@ -134,1 +134,1 @@\n-            throw new IllegalStateException(\"This segment is already closed\");\n+            throw ex.newRuntimeException();\n@@ -139,1 +139,1 @@\n-    private $type$ get$Type$AcquireInternal(MemorySessionImpl session, Object base, long offset) {\n+    private $type$ get$Type$AcquireInternal(MemorySessionImpl.State state, Object base, long offset) {\n@@ -141,2 +141,2 @@\n-            if (session != null) {\n-                session.checkValidState();\n+            if (state != null) {\n+                state.checkValidState();\n@@ -146,1 +146,1 @@\n-            Reference.reachabilityFence(session);\n+            Reference.reachabilityFence(state);\n@@ -151,1 +151,1 @@\n-    public void put$Type$Release(MemorySessionImpl session, Object base, long offset, $type$ value) {\n+    public void put$Type$Release(MemorySessionImpl.State state, Object base, long offset, $type$ value) {\n@@ -153,1 +153,1 @@\n-            put$Type$ReleaseInternal(session, base, offset, value);\n+            put$Type$ReleaseInternal(state, base, offset, value);\n@@ -155,1 +155,1 @@\n-            throw new IllegalStateException(\"This segment is already closed\");\n+            throw ex.newRuntimeException();\n@@ -160,1 +160,1 @@\n-    private void put$Type$ReleaseInternal(MemorySessionImpl session, Object base, long offset, $type$ value) {\n+    private void put$Type$ReleaseInternal(MemorySessionImpl.State state, Object base, long offset, $type$ value) {\n@@ -162,2 +162,2 @@\n-            if (session != null) {\n-                session.checkValidState();\n+            if (state != null) {\n+                state.checkValidState();\n@@ -167,1 +167,1 @@\n-            Reference.reachabilityFence(session);\n+            Reference.reachabilityFence(state);\n@@ -172,1 +172,1 @@\n-    public $type$ get$Type$Opaque(MemorySessionImpl session, Object base, long offset) {\n+    public $type$ get$Type$Opaque(MemorySessionImpl.State state, Object base, long offset) {\n@@ -174,1 +174,1 @@\n-            return get$Type$OpaqueInternal(session, base, offset);\n+            return get$Type$OpaqueInternal(state, base, offset);\n@@ -176,1 +176,1 @@\n-            throw new IllegalStateException(\"This segment is already closed\");\n+            throw ex.newRuntimeException();\n@@ -181,1 +181,1 @@\n-    private $type$ get$Type$OpaqueInternal(MemorySessionImpl session, Object base, long offset) {\n+    private $type$ get$Type$OpaqueInternal(MemorySessionImpl.State state, Object base, long offset) {\n@@ -183,2 +183,2 @@\n-            if (session != null) {\n-                session.checkValidState();\n+            if (state != null) {\n+                state.checkValidState();\n@@ -188,1 +188,1 @@\n-            Reference.reachabilityFence(session);\n+            Reference.reachabilityFence(state);\n@@ -192,1 +192,1 @@\n-    public void put$Type$Opaque(MemorySessionImpl session, Object base, long offset, $type$ value) {\n+    public void put$Type$Opaque(MemorySessionImpl.State state, Object base, long offset, $type$ value) {\n@@ -194,1 +194,1 @@\n-            put$Type$OpaqueInternal(session, base, offset, value);\n+            put$Type$OpaqueInternal(state, base, offset, value);\n@@ -196,1 +196,1 @@\n-            throw new IllegalStateException(\"This segment is already closed\");\n+            throw ex.newRuntimeException();\n@@ -201,1 +201,1 @@\n-    private void put$Type$OpaqueInternal(MemorySessionImpl session, Object base, long offset, $type$ value) {\n+    private void put$Type$OpaqueInternal(MemorySessionImpl.State state, Object base, long offset, $type$ value) {\n@@ -203,2 +203,2 @@\n-            if (session != null) {\n-                session.checkValidState();\n+            if (state != null) {\n+                state.checkValidState();\n@@ -208,1 +208,1 @@\n-            Reference.reachabilityFence(session);\n+            Reference.reachabilityFence(state);\n@@ -213,1 +213,1 @@\n-    public boolean compareAndSet$Type$(MemorySessionImpl session, Object base, long offset, $type$ expected, $type$ value) {\n+    public boolean compareAndSet$Type$(MemorySessionImpl.State state, Object base, long offset, $type$ expected, $type$ value) {\n@@ -215,1 +215,1 @@\n-            return compareAndSet$Type$Internal(session, base, offset, expected, value);\n+            return compareAndSet$Type$Internal(state, base, offset, expected, value);\n@@ -217,1 +217,1 @@\n-            throw new IllegalStateException(\"This segment is already closed\");\n+            throw ex.newRuntimeException();\n@@ -222,1 +222,1 @@\n-    private boolean compareAndSet$Type$Internal(MemorySessionImpl session, Object base, long offset, $type$ expected, $type$ value) {\n+    private boolean compareAndSet$Type$Internal(MemorySessionImpl.State state, Object base, long offset, $type$ expected, $type$ value) {\n@@ -224,2 +224,2 @@\n-            if (session != null) {\n-                session.checkValidState();\n+            if (state != null) {\n+                state.checkValidState();\n@@ -229,1 +229,1 @@\n-            Reference.reachabilityFence(session);\n+            Reference.reachabilityFence(state);\n@@ -234,1 +234,1 @@\n-    public $type$ compareAndExchange$Type$(MemorySessionImpl session, Object base, long offset, $type$ expected, $type$ value) {\n+    public $type$ compareAndExchange$Type$(MemorySessionImpl.State state, Object base, long offset, $type$ expected, $type$ value) {\n@@ -236,1 +236,1 @@\n-            return compareAndExchange$Type$Internal(session, base, offset, expected, value);\n+            return compareAndExchange$Type$Internal(state, base, offset, expected, value);\n@@ -238,1 +238,1 @@\n-            throw new IllegalStateException(\"This segment is already closed\");\n+            throw ex.newRuntimeException();\n@@ -243,1 +243,1 @@\n-    private $type$ compareAndExchange$Type$Internal(MemorySessionImpl session, Object base, long offset, $type$ expected, $type$ value) {\n+    private $type$ compareAndExchange$Type$Internal(MemorySessionImpl.State state, Object base, long offset, $type$ expected, $type$ value) {\n@@ -245,2 +245,2 @@\n-            if (session != null) {\n-                session.checkValidState();\n+            if (state != null) {\n+                state.checkValidState();\n@@ -250,1 +250,1 @@\n-            Reference.reachabilityFence(session);\n+            Reference.reachabilityFence(state);\n@@ -255,1 +255,1 @@\n-    public $type$ compareAndExchange$Type$Acquire(MemorySessionImpl session, Object base, long offset, $type$ expected, $type$ value) {\n+    public $type$ compareAndExchange$Type$Acquire(MemorySessionImpl.State state, Object base, long offset, $type$ expected, $type$ value) {\n@@ -257,1 +257,1 @@\n-            return compareAndExchange$Type$AcquireInternal(session, base, offset, expected, value);\n+            return compareAndExchange$Type$AcquireInternal(state, base, offset, expected, value);\n@@ -259,1 +259,1 @@\n-            throw new IllegalStateException(\"This segment is already closed\");\n+            throw ex.newRuntimeException();\n@@ -264,1 +264,1 @@\n-    private $type$ compareAndExchange$Type$AcquireInternal(MemorySessionImpl session, Object base, long offset, $type$ expected, $type$ value) {\n+    private $type$ compareAndExchange$Type$AcquireInternal(MemorySessionImpl.State state, Object base, long offset, $type$ expected, $type$ value) {\n@@ -266,2 +266,2 @@\n-            if (session != null) {\n-                session.checkValidState();\n+            if (state != null) {\n+                state.checkValidState();\n@@ -271,1 +271,1 @@\n-            Reference.reachabilityFence(session);\n+            Reference.reachabilityFence(state);\n@@ -276,1 +276,1 @@\n-    public $type$ compareAndExchange$Type$Release(MemorySessionImpl session, Object base, long offset, $type$ expected, $type$ value) {\n+    public $type$ compareAndExchange$Type$Release(MemorySessionImpl.State state, Object base, long offset, $type$ expected, $type$ value) {\n@@ -278,1 +278,1 @@\n-            return compareAndExchange$Type$ReleaseInternal(session, base, offset, expected, value);\n+            return compareAndExchange$Type$ReleaseInternal(state, base, offset, expected, value);\n@@ -280,1 +280,1 @@\n-            throw new IllegalStateException(\"This segment is already closed\");\n+            throw ex.newRuntimeException();\n@@ -285,1 +285,1 @@\n-    private $type$ compareAndExchange$Type$ReleaseInternal(MemorySessionImpl session, Object base, long offset, $type$ expected, $type$ value) {\n+    private $type$ compareAndExchange$Type$ReleaseInternal(MemorySessionImpl.State state, Object base, long offset, $type$ expected, $type$ value) {\n@@ -287,2 +287,2 @@\n-            if (session != null) {\n-                session.checkValidState();\n+            if (state != null) {\n+                state.checkValidState();\n@@ -292,1 +292,1 @@\n-            Reference.reachabilityFence(session);\n+            Reference.reachabilityFence(state);\n@@ -297,1 +297,1 @@\n-    public boolean weakCompareAndSet$Type$Plain(MemorySessionImpl session, Object base, long offset, $type$ expected, $type$ value) {\n+    public boolean weakCompareAndSet$Type$Plain(MemorySessionImpl.State state, Object base, long offset, $type$ expected, $type$ value) {\n@@ -299,1 +299,1 @@\n-            return weakCompareAndSet$Type$PlainInternal(session, base, offset, expected, value);\n+            return weakCompareAndSet$Type$PlainInternal(state, base, offset, expected, value);\n@@ -301,1 +301,1 @@\n-            throw new IllegalStateException(\"This segment is already closed\");\n+            throw ex.newRuntimeException();\n@@ -306,1 +306,1 @@\n-    private boolean weakCompareAndSet$Type$PlainInternal(MemorySessionImpl session, Object base, long offset, $type$ expected, $type$ value) {\n+    private boolean weakCompareAndSet$Type$PlainInternal(MemorySessionImpl.State state, Object base, long offset, $type$ expected, $type$ value) {\n@@ -308,2 +308,2 @@\n-            if (session != null) {\n-                session.checkValidState();\n+            if (state != null) {\n+                state.checkValidState();\n@@ -313,1 +313,1 @@\n-            Reference.reachabilityFence(session);\n+            Reference.reachabilityFence(state);\n@@ -318,1 +318,1 @@\n-    public boolean weakCompareAndSet$Type$(MemorySessionImpl session, Object base, long offset, $type$ expected, $type$ value) {\n+    public boolean weakCompareAndSet$Type$(MemorySessionImpl.State state, Object base, long offset, $type$ expected, $type$ value) {\n@@ -320,1 +320,1 @@\n-            return weakCompareAndSet$Type$Internal(session, base, offset, expected, value);\n+            return weakCompareAndSet$Type$Internal(state, base, offset, expected, value);\n@@ -322,1 +322,1 @@\n-            throw new IllegalStateException(\"This segment is already closed\");\n+            throw ex.newRuntimeException();\n@@ -327,1 +327,1 @@\n-    private boolean weakCompareAndSet$Type$Internal(MemorySessionImpl session, Object base, long offset, $type$ expected, $type$ value) {\n+    private boolean weakCompareAndSet$Type$Internal(MemorySessionImpl.State state, Object base, long offset, $type$ expected, $type$ value) {\n@@ -329,2 +329,2 @@\n-            if (session != null) {\n-                session.checkValidState();\n+            if (state != null) {\n+                state.checkValidState();\n@@ -334,1 +334,1 @@\n-            Reference.reachabilityFence(session);\n+            Reference.reachabilityFence(state);\n@@ -339,1 +339,1 @@\n-    public boolean weakCompareAndSet$Type$Acquire(MemorySessionImpl session, Object base, long offset, $type$ expected, $type$ value) {\n+    public boolean weakCompareAndSet$Type$Acquire(MemorySessionImpl.State state, Object base, long offset, $type$ expected, $type$ value) {\n@@ -341,1 +341,1 @@\n-            return weakCompareAndSet$Type$AcquireInternal(session, base, offset, expected, value);\n+            return weakCompareAndSet$Type$AcquireInternal(state, base, offset, expected, value);\n@@ -343,1 +343,1 @@\n-            throw new IllegalStateException(\"This segment is already closed\");\n+            throw ex.newRuntimeException();\n@@ -348,1 +348,1 @@\n-    private boolean weakCompareAndSet$Type$AcquireInternal(MemorySessionImpl session, Object base, long offset, $type$ expected, $type$ value) {\n+    private boolean weakCompareAndSet$Type$AcquireInternal(MemorySessionImpl.State state, Object base, long offset, $type$ expected, $type$ value) {\n@@ -350,2 +350,2 @@\n-            if (session != null) {\n-                session.checkValidState();\n+            if (state != null) {\n+                state.checkValidState();\n@@ -355,1 +355,1 @@\n-            Reference.reachabilityFence(session);\n+            Reference.reachabilityFence(state);\n@@ -360,1 +360,1 @@\n-    public boolean weakCompareAndSet$Type$Release(MemorySessionImpl session, Object base, long offset, $type$ expected, $type$ value) {\n+    public boolean weakCompareAndSet$Type$Release(MemorySessionImpl.State state, Object base, long offset, $type$ expected, $type$ value) {\n@@ -362,1 +362,1 @@\n-            return weakCompareAndSet$Type$ReleaseInternal(session, base, offset, expected, value);\n+            return weakCompareAndSet$Type$ReleaseInternal(state, base, offset, expected, value);\n@@ -364,1 +364,1 @@\n-            throw new IllegalStateException(\"This segment is already closed\");\n+            throw ex.newRuntimeException();\n@@ -369,1 +369,1 @@\n-    private boolean weakCompareAndSet$Type$ReleaseInternal(MemorySessionImpl session, Object base, long offset, $type$ expected, $type$ value) {\n+    private boolean weakCompareAndSet$Type$ReleaseInternal(MemorySessionImpl.State state, Object base, long offset, $type$ expected, $type$ value) {\n@@ -371,2 +371,2 @@\n-            if (session != null) {\n-                session.checkValidState();\n+            if (state != null) {\n+                state.checkValidState();\n@@ -376,1 +376,1 @@\n-            Reference.reachabilityFence(session);\n+            Reference.reachabilityFence(state);\n@@ -381,1 +381,1 @@\n-    public $type$ getAndSet$Type$(MemorySessionImpl session, Object base, long offset, $type$ value) {\n+    public $type$ getAndSet$Type$(MemorySessionImpl.State state, Object base, long offset, $type$ value) {\n@@ -383,1 +383,1 @@\n-            return getAndSet$Type$Internal(session, base, offset, value);\n+            return getAndSet$Type$Internal(state, base, offset, value);\n@@ -385,1 +385,1 @@\n-            throw new IllegalStateException(\"This segment is already closed\");\n+            throw ex.newRuntimeException();\n@@ -390,1 +390,1 @@\n-    private $type$ getAndSet$Type$Internal(MemorySessionImpl session, Object base, long offset, $type$ value) {\n+    private $type$ getAndSet$Type$Internal(MemorySessionImpl.State state, Object base, long offset, $type$ value) {\n@@ -392,2 +392,2 @@\n-            if (session != null) {\n-                session.checkValidState();\n+            if (state != null) {\n+                state.checkValidState();\n@@ -397,1 +397,1 @@\n-            Reference.reachabilityFence(session);\n+            Reference.reachabilityFence(state);\n@@ -402,1 +402,1 @@\n-    public $type$ getAndSet$Type$Acquire(MemorySessionImpl session, Object base, long offset, $type$ value) {\n+    public $type$ getAndSet$Type$Acquire(MemorySessionImpl.State state, Object base, long offset, $type$ value) {\n@@ -404,1 +404,1 @@\n-            return getAndSet$Type$AcquireInternal(session, base, offset, value);\n+            return getAndSet$Type$AcquireInternal(state, base, offset, value);\n@@ -406,1 +406,1 @@\n-            throw new IllegalStateException(\"This segment is already closed\");\n+            throw ex.newRuntimeException();\n@@ -411,1 +411,1 @@\n-    private $type$ getAndSet$Type$AcquireInternal(MemorySessionImpl session, Object base, long offset, $type$ value) {\n+    private $type$ getAndSet$Type$AcquireInternal(MemorySessionImpl.State state, Object base, long offset, $type$ value) {\n@@ -413,2 +413,2 @@\n-            if (session != null) {\n-                session.checkValidState();\n+            if (state != null) {\n+                state.checkValidState();\n@@ -418,1 +418,1 @@\n-            Reference.reachabilityFence(session);\n+            Reference.reachabilityFence(state);\n@@ -423,1 +423,1 @@\n-    public $type$ getAndSet$Type$Release(MemorySessionImpl session, Object base, long offset, $type$ value) {\n+    public $type$ getAndSet$Type$Release(MemorySessionImpl.State state, Object base, long offset, $type$ value) {\n@@ -425,1 +425,1 @@\n-            return getAndSet$Type$ReleaseInternal(session, base, offset, value);\n+            return getAndSet$Type$ReleaseInternal(state, base, offset, value);\n@@ -427,1 +427,1 @@\n-            throw new IllegalStateException(\"This segment is already closed\");\n+            throw ex.newRuntimeException();\n@@ -432,1 +432,1 @@\n-    private $type$ getAndSet$Type$ReleaseInternal(MemorySessionImpl session, Object base, long offset, $type$ value) {\n+    private $type$ getAndSet$Type$ReleaseInternal(MemorySessionImpl.State state, Object base, long offset, $type$ value) {\n@@ -434,2 +434,2 @@\n-            if (session != null) {\n-                session.checkValidState();\n+            if (state != null) {\n+                state.checkValidState();\n@@ -439,1 +439,1 @@\n-            Reference.reachabilityFence(session);\n+            Reference.reachabilityFence(state);\n@@ -446,1 +446,1 @@\n-    public $type$ getAndAdd$Type$(MemorySessionImpl session, Object base, long offset, $type$ delta) {\n+    public $type$ getAndAdd$Type$(MemorySessionImpl.State state, Object base, long offset, $type$ delta) {\n@@ -448,1 +448,1 @@\n-            return getAndAdd$Type$Internal(session, base, offset, delta);\n+            return getAndAdd$Type$Internal(state, base, offset, delta);\n@@ -450,1 +450,1 @@\n-            throw new IllegalStateException(\"This segment is already closed\");\n+            throw ex.newRuntimeException();\n@@ -455,1 +455,1 @@\n-    private $type$ getAndAdd$Type$Internal(MemorySessionImpl session, Object base, long offset, $type$ delta) {\n+    private $type$ getAndAdd$Type$Internal(MemorySessionImpl.State state, Object base, long offset, $type$ delta) {\n@@ -457,2 +457,2 @@\n-            if (session != null) {\n-                session.checkValidState();\n+            if (state != null) {\n+                state.checkValidState();\n@@ -462,1 +462,1 @@\n-            Reference.reachabilityFence(session);\n+            Reference.reachabilityFence(state);\n@@ -467,1 +467,1 @@\n-    public $type$ getAndAdd$Type$Acquire(MemorySessionImpl session, Object base, long offset, $type$ delta) {\n+    public $type$ getAndAdd$Type$Acquire(MemorySessionImpl.State state, Object base, long offset, $type$ delta) {\n@@ -469,1 +469,1 @@\n-            return getAndAdd$Type$AcquireInternal(session, base, offset, delta);\n+            return getAndAdd$Type$AcquireInternal(state, base, offset, delta);\n@@ -471,1 +471,1 @@\n-            throw new IllegalStateException(\"This segment is already closed\");\n+            throw ex.newRuntimeException();\n@@ -476,1 +476,1 @@\n-    private $type$ getAndAdd$Type$AcquireInternal(MemorySessionImpl session, Object base, long offset, $type$ delta) {\n+    private $type$ getAndAdd$Type$AcquireInternal(MemorySessionImpl.State state, Object base, long offset, $type$ delta) {\n@@ -478,2 +478,2 @@\n-            if (session != null) {\n-                session.checkValidState();\n+            if (state != null) {\n+                state.checkValidState();\n@@ -483,1 +483,1 @@\n-            Reference.reachabilityFence(session);\n+            Reference.reachabilityFence(state);\n@@ -488,1 +488,1 @@\n-    public $type$ getAndAdd$Type$Release(MemorySessionImpl session, Object base, long offset, $type$ delta) {\n+    public $type$ getAndAdd$Type$Release(MemorySessionImpl.State state, Object base, long offset, $type$ delta) {\n@@ -490,1 +490,1 @@\n-            return getAndAdd$Type$ReleaseInternal(session, base, offset, delta);\n+            return getAndAdd$Type$ReleaseInternal(state, base, offset, delta);\n@@ -492,1 +492,1 @@\n-            throw new IllegalStateException(\"This segment is already closed\");\n+            throw ex.newRuntimeException();\n@@ -497,1 +497,1 @@\n-    private $type$ getAndAdd$Type$ReleaseInternal(MemorySessionImpl session, Object base, long offset, $type$ delta) {\n+    private $type$ getAndAdd$Type$ReleaseInternal(MemorySessionImpl.State state, Object base, long offset, $type$ delta) {\n@@ -499,2 +499,2 @@\n-            if (session != null) {\n-                session.checkValidState();\n+            if (state != null) {\n+                state.checkValidState();\n@@ -504,1 +504,1 @@\n-            Reference.reachabilityFence(session);\n+            Reference.reachabilityFence(state);\n@@ -511,1 +511,1 @@\n-    public $type$ getAndBitwiseOr$Type$(MemorySessionImpl session, Object base, long offset, $type$ value) {\n+    public $type$ getAndBitwiseOr$Type$(MemorySessionImpl.State state, Object base, long offset, $type$ value) {\n@@ -513,1 +513,1 @@\n-            return getAndBitwiseOr$Type$Internal(session, base, offset, value);\n+            return getAndBitwiseOr$Type$Internal(state, base, offset, value);\n@@ -515,1 +515,1 @@\n-            throw new IllegalStateException(\"This segment is already closed\");\n+            throw ex.newRuntimeException();\n@@ -520,1 +520,1 @@\n-    private $type$ getAndBitwiseOr$Type$Internal(MemorySessionImpl session, Object base, long offset, $type$ value) {\n+    private $type$ getAndBitwiseOr$Type$Internal(MemorySessionImpl.State state, Object base, long offset, $type$ value) {\n@@ -522,2 +522,2 @@\n-            if (session != null) {\n-                session.checkValidState();\n+            if (state != null) {\n+                state.checkValidState();\n@@ -527,1 +527,1 @@\n-            Reference.reachabilityFence(session);\n+            Reference.reachabilityFence(state);\n@@ -532,1 +532,1 @@\n-    public $type$ getAndBitwiseOr$Type$Acquire(MemorySessionImpl session, Object base, long offset, $type$ value) {\n+    public $type$ getAndBitwiseOr$Type$Acquire(MemorySessionImpl.State state, Object base, long offset, $type$ value) {\n@@ -534,1 +534,1 @@\n-            return getAndBitwiseOr$Type$AcquireInternal(session, base, offset, value);\n+            return getAndBitwiseOr$Type$AcquireInternal(state, base, offset, value);\n@@ -536,1 +536,1 @@\n-            throw new IllegalStateException(\"This segment is already closed\");\n+            throw ex.newRuntimeException();\n@@ -541,1 +541,1 @@\n-    private $type$ getAndBitwiseOr$Type$AcquireInternal(MemorySessionImpl session, Object base, long offset, $type$ value) {\n+    private $type$ getAndBitwiseOr$Type$AcquireInternal(MemorySessionImpl.State state, Object base, long offset, $type$ value) {\n@@ -543,2 +543,2 @@\n-            if (session != null) {\n-                session.checkValidState();\n+            if (state != null) {\n+                state.checkValidState();\n@@ -548,1 +548,1 @@\n-            Reference.reachabilityFence(session);\n+            Reference.reachabilityFence(state);\n@@ -553,1 +553,1 @@\n-    public $type$ getAndBitwiseOr$Type$Release(MemorySessionImpl session, Object base, long offset, $type$ value) {\n+    public $type$ getAndBitwiseOr$Type$Release(MemorySessionImpl.State state, Object base, long offset, $type$ value) {\n@@ -555,1 +555,1 @@\n-            return getAndBitwiseOr$Type$ReleaseInternal(session, base, offset, value);\n+            return getAndBitwiseOr$Type$ReleaseInternal(state, base, offset, value);\n@@ -557,1 +557,1 @@\n-            throw new IllegalStateException(\"This segment is already closed\");\n+            throw ex.newRuntimeException();\n@@ -562,1 +562,1 @@\n-    private $type$ getAndBitwiseOr$Type$ReleaseInternal(MemorySessionImpl session, Object base, long offset, $type$ value) {\n+    private $type$ getAndBitwiseOr$Type$ReleaseInternal(MemorySessionImpl.State state, Object base, long offset, $type$ value) {\n@@ -564,2 +564,2 @@\n-            if (session != null) {\n-                session.checkValidState();\n+            if (state != null) {\n+                state.checkValidState();\n@@ -569,1 +569,1 @@\n-            Reference.reachabilityFence(session);\n+            Reference.reachabilityFence(state);\n@@ -574,1 +574,1 @@\n-    public $type$ getAndBitwiseAnd$Type$(MemorySessionImpl session, Object base, long offset, $type$ value) {\n+    public $type$ getAndBitwiseAnd$Type$(MemorySessionImpl.State state, Object base, long offset, $type$ value) {\n@@ -576,1 +576,1 @@\n-            return getAndBitwiseAnd$Type$Internal(session, base, offset, value);\n+            return getAndBitwiseAnd$Type$Internal(state, base, offset, value);\n@@ -578,1 +578,1 @@\n-            throw new IllegalStateException(\"This segment is already closed\");\n+            throw ex.newRuntimeException();\n@@ -583,1 +583,1 @@\n-    private $type$ getAndBitwiseAnd$Type$Internal(MemorySessionImpl session, Object base, long offset, $type$ value) {\n+    private $type$ getAndBitwiseAnd$Type$Internal(MemorySessionImpl.State state, Object base, long offset, $type$ value) {\n@@ -585,2 +585,2 @@\n-            if (session != null) {\n-                session.checkValidState();\n+            if (state != null) {\n+                state.checkValidState();\n@@ -590,1 +590,1 @@\n-            Reference.reachabilityFence(session);\n+            Reference.reachabilityFence(state);\n@@ -595,1 +595,1 @@\n-    public $type$ getAndBitwiseAnd$Type$Acquire(MemorySessionImpl session, Object base, long offset, $type$ value) {\n+    public $type$ getAndBitwiseAnd$Type$Acquire(MemorySessionImpl.State state, Object base, long offset, $type$ value) {\n@@ -597,1 +597,1 @@\n-            return getAndBitwiseAnd$Type$AcquireInternal(session, base, offset, value);\n+            return getAndBitwiseAnd$Type$AcquireInternal(state, base, offset, value);\n@@ -599,1 +599,1 @@\n-            throw new IllegalStateException(\"This segment is already closed\");\n+            throw ex.newRuntimeException();\n@@ -604,1 +604,1 @@\n-    private $type$ getAndBitwiseAnd$Type$AcquireInternal(MemorySessionImpl session, Object base, long offset, $type$ value) {\n+    private $type$ getAndBitwiseAnd$Type$AcquireInternal(MemorySessionImpl.State state, Object base, long offset, $type$ value) {\n@@ -606,2 +606,2 @@\n-            if (session != null) {\n-                session.checkValidState();\n+            if (state != null) {\n+                state.checkValidState();\n@@ -611,1 +611,1 @@\n-            Reference.reachabilityFence(session);\n+            Reference.reachabilityFence(state);\n@@ -616,1 +616,1 @@\n-    public $type$ getAndBitwiseAnd$Type$Release(MemorySessionImpl session, Object base, long offset, $type$ value) {\n+    public $type$ getAndBitwiseAnd$Type$Release(MemorySessionImpl.State state, Object base, long offset, $type$ value) {\n@@ -618,1 +618,1 @@\n-            return getAndBitwiseAnd$Type$ReleaseInternal(session, base, offset, value);\n+            return getAndBitwiseAnd$Type$ReleaseInternal(state, base, offset, value);\n@@ -620,1 +620,1 @@\n-            throw new IllegalStateException(\"This segment is already closed\");\n+            throw ex.newRuntimeException();\n@@ -625,1 +625,1 @@\n-    private $type$ getAndBitwiseAnd$Type$ReleaseInternal(MemorySessionImpl session, Object base, long offset, $type$ value) {\n+    private $type$ getAndBitwiseAnd$Type$ReleaseInternal(MemorySessionImpl.State state, Object base, long offset, $type$ value) {\n@@ -627,2 +627,2 @@\n-            if (session != null) {\n-                session.checkValidState();\n+            if (state != null) {\n+                state.checkValidState();\n@@ -632,1 +632,1 @@\n-            Reference.reachabilityFence(session);\n+            Reference.reachabilityFence(state);\n@@ -637,1 +637,1 @@\n-    public $type$ getAndBitwiseXor$Type$(MemorySessionImpl session, Object base, long offset, $type$ value) {\n+    public $type$ getAndBitwiseXor$Type$(MemorySessionImpl.State state, Object base, long offset, $type$ value) {\n@@ -639,1 +639,1 @@\n-            return getAndBitwiseXor$Type$Internal(session, base, offset, value);\n+            return getAndBitwiseXor$Type$Internal(state, base, offset, value);\n@@ -641,1 +641,1 @@\n-            throw new IllegalStateException(\"This segment is already closed\");\n+            throw ex.newRuntimeException();\n@@ -646,1 +646,1 @@\n-    private $type$ getAndBitwiseXor$Type$Internal(MemorySessionImpl session, Object base, long offset, $type$ value) {\n+    private $type$ getAndBitwiseXor$Type$Internal(MemorySessionImpl.State state, Object base, long offset, $type$ value) {\n@@ -648,2 +648,2 @@\n-            if (session != null) {\n-                session.checkValidState();\n+            if (state != null) {\n+                state.checkValidState();\n@@ -653,1 +653,1 @@\n-            Reference.reachabilityFence(session);\n+            Reference.reachabilityFence(state);\n@@ -658,1 +658,1 @@\n-    public $type$ getAndBitwiseXor$Type$Acquire(MemorySessionImpl session, Object base, long offset, $type$ value) {\n+    public $type$ getAndBitwiseXor$Type$Acquire(MemorySessionImpl.State state, Object base, long offset, $type$ value) {\n@@ -660,1 +660,1 @@\n-            return getAndBitwiseXor$Type$AcquireInternal(session, base, offset, value);\n+            return getAndBitwiseXor$Type$AcquireInternal(state, base, offset, value);\n@@ -662,1 +662,1 @@\n-            throw new IllegalStateException(\"This segment is already closed\");\n+            throw ex.newRuntimeException();\n@@ -667,1 +667,1 @@\n-    private $type$ getAndBitwiseXor$Type$AcquireInternal(MemorySessionImpl session, Object base, long offset, $type$ value) {\n+    private $type$ getAndBitwiseXor$Type$AcquireInternal(MemorySessionImpl.State state, Object base, long offset, $type$ value) {\n@@ -669,2 +669,2 @@\n-            if (session != null) {\n-                session.checkValidState();\n+            if (state != null) {\n+                state.checkValidState();\n@@ -674,1 +674,1 @@\n-            Reference.reachabilityFence(session);\n+            Reference.reachabilityFence(state);\n@@ -679,1 +679,1 @@\n-    public $type$ getAndBitwiseXor$Type$Release(MemorySessionImpl session, Object base, long offset, $type$ value) {\n+    public $type$ getAndBitwiseXor$Type$Release(MemorySessionImpl.State state, Object base, long offset, $type$ value) {\n@@ -681,1 +681,1 @@\n-            return getAndBitwiseXor$Type$ReleaseInternal(session, base, offset, value);\n+            return getAndBitwiseXor$Type$ReleaseInternal(state, base, offset, value);\n@@ -683,1 +683,1 @@\n-            throw new IllegalStateException(\"This segment is already closed\");\n+            throw ex.newRuntimeException();\n@@ -688,1 +688,1 @@\n-    private $type$ getAndBitwiseXor$Type$ReleaseInternal(MemorySessionImpl session, Object base, long offset, $type$ value) {\n+    private $type$ getAndBitwiseXor$Type$ReleaseInternal(MemorySessionImpl.State state, Object base, long offset, $type$ value) {\n@@ -690,2 +690,2 @@\n-            if (session != null) {\n-                session.checkValidState();\n+            if (state != null) {\n+                state.checkValidState();\n@@ -695,1 +695,1 @@\n-            Reference.reachabilityFence(session);\n+            Reference.reachabilityFence(state);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/X-ScopedMemoryAccess-bin.java.template","additions":231,"deletions":231,"binary":false,"changes":462,"status":"modified"},{"patch":"@@ -35,0 +35,3 @@\n+import java.nio.Buffer;\n+import java.nio.ByteBuffer;\n+import java.util.function.Supplier;\n@@ -48,1 +51,1 @@\n- * class accept one or more {@link MemorySessionImpl} parameter, which is used to validate as to whether access to memory\n+ * class accept one or more {@link MemorySessionImpl.State} parameter, which is used to validate as to whether access to memory\n@@ -58,4 +61,4 @@\n- * region concurrently. More specifically, when a thread wants to release a memory region, it should call the\n- * {@link MemorySessionImpl#close()} method. This method initiates thread-local handshakes with all the other VM threads,\n- * which are then stopped one by one. If any thread is found accessing a resource associated to the very memory session\n- * being closed, the handshake fails, and the session cannot be closed.\n+ * session concurrently. More specifically, when a thread wants to close a memory session, it should call the\n+ * {@link ScopedMemoryAccess#closeScope(MemorySessionImpl.State)} method. This method initiates thread-local handshakes\n+ * with all the other VM threads, which are then stopped one by one. If any thread is found accessing a resource associated\n+ * to the very memory session being closed, the handshake fails, and the session will not be closed.\n@@ -68,1 +71,1 @@\n- * operations. Additionally, to make sure that the session object(s) of the memory being accessed is always\n+ * operations. Additionally, to make sure that the state object(s) of the memory being accessed is always\n@@ -85,5 +88,1 @@\n-    public boolean closeScope(MemorySessionImpl session) {\n-        return closeScope0(session);\n-    }\n-\n-    native boolean closeScope0(MemorySessionImpl session);\n+    public native boolean closeScope(MemorySessionImpl.State state);\n@@ -100,2 +99,7 @@\n-        private ScopedAccessError() {\n-            super(\"Attempt to access an already released memory resource\", null, false, false);\n+\n+        @SuppressWarnings(\"serial\")\n+        private final Supplier<RuntimeException> runtimeExceptionSupplier;\n+\n+        public ScopedAccessError(Supplier<RuntimeException> runtimeExceptionSupplier) {\n+            super(\"Invalid memory access\", null, false, false);\n+            this.runtimeExceptionSupplier = runtimeExceptionSupplier;\n@@ -103,0 +107,1 @@\n+\n@@ -105,1 +110,3 @@\n-        public static final ScopedAccessError INSTANCE = new ScopedAccessError();\n+        public final RuntimeException newRuntimeException() {\n+            return runtimeExceptionSupplier.get();\n+        }\n@@ -115,1 +122,1 @@\n-    public void copyMemory(MemorySessionImpl srcScope, MemorySessionImpl dstScope,\n+    public void copyMemory(MemorySessionImpl.State srcState, MemorySessionImpl.State dstState,\n@@ -120,1 +127,1 @@\n-              copyMemoryInternal(srcScope, dstScope, srcBase, srcOffset, destBase, destOffset, bytes);\n+              copyMemoryInternal(srcState, dstState, srcBase, srcOffset, destBase, destOffset, bytes);\n@@ -122,1 +129,1 @@\n-              throw new IllegalStateException(\"This segment is already closed\");\n+              throw ex.newRuntimeException();\n@@ -127,1 +134,1 @@\n-    private void copyMemoryInternal(MemorySessionImpl srcScope, MemorySessionImpl dstScope,\n+    private void copyMemoryInternal(MemorySessionImpl.State srcState, MemorySessionImpl.State dstState,\n@@ -132,2 +139,2 @@\n-            if (srcScope != null) {\n-                srcScope.checkValidState();\n+            if (srcState != null) {\n+                srcState.checkValidState();\n@@ -135,2 +142,2 @@\n-            if (dstScope != null) {\n-                dstScope.checkValidState();\n+            if (dstState != null) {\n+                dstState.checkValidState();\n@@ -140,2 +147,2 @@\n-            Reference.reachabilityFence(srcScope);\n-            Reference.reachabilityFence(dstScope);\n+            Reference.reachabilityFence(srcState);\n+            Reference.reachabilityFence(dstState);\n@@ -146,1 +153,1 @@\n-    public void copySwapMemory(MemorySessionImpl srcScope, MemorySessionImpl dstScope,\n+    public void copySwapMemory(MemorySessionImpl.State srcState, MemorySessionImpl.State dstState,\n@@ -151,1 +158,1 @@\n-              copySwapMemoryInternal(srcScope, dstScope, srcBase, srcOffset, destBase, destOffset, bytes, elemSize);\n+              copySwapMemoryInternal(srcState, dstState, srcBase, srcOffset, destBase, destOffset, bytes, elemSize);\n@@ -153,1 +160,1 @@\n-              throw new IllegalStateException(\"This segment is already closed\");\n+              throw ex.newRuntimeException();\n@@ -158,1 +165,1 @@\n-    private void copySwapMemoryInternal(MemorySessionImpl srcScope, MemorySessionImpl dstScope,\n+    private void copySwapMemoryInternal(MemorySessionImpl.State srcState, MemorySessionImpl.State dstState,\n@@ -163,2 +170,2 @@\n-            if (srcScope != null) {\n-                srcScope.checkValidState();\n+            if (srcState != null) {\n+                srcState.checkValidState();\n@@ -166,2 +173,2 @@\n-            if (dstScope != null) {\n-                dstScope.checkValidState();\n+            if (dstState != null) {\n+                dstState.checkValidState();\n@@ -171,2 +178,2 @@\n-            Reference.reachabilityFence(srcScope);\n-            Reference.reachabilityFence(dstScope);\n+            Reference.reachabilityFence(srcState);\n+            Reference.reachabilityFence(dstState);\n@@ -177,1 +184,1 @@\n-    public void setMemory(MemorySessionImpl session, Object o, long offset, long bytes, byte value) {\n+    public void setMemory(MemorySessionImpl.State state, Object o, long offset, long bytes, byte value) {\n@@ -179,1 +186,1 @@\n-            setMemoryInternal(session, o, offset, bytes, value);\n+            setMemoryInternal(state, o, offset, bytes, value);\n@@ -181,1 +188,1 @@\n-            throw new IllegalStateException(\"This segment is already closed\");\n+            throw ex.newRuntimeException();\n@@ -186,1 +193,1 @@\n-    private void setMemoryInternal(MemorySessionImpl session, Object o, long offset, long bytes, byte value) {\n+    private void setMemoryInternal(MemorySessionImpl.State state, Object o, long offset, long bytes, byte value) {\n@@ -188,2 +195,2 @@\n-            if (session != null) {\n-                session.checkValidState();\n+            if (state != null) {\n+                state.checkValidState();\n@@ -193,1 +200,1 @@\n-            Reference.reachabilityFence(session);\n+            Reference.reachabilityFence(state);\n@@ -198,1 +205,1 @@\n-    public int vectorizedMismatch(MemorySessionImpl aScope, MemorySessionImpl bScope,\n+    public int vectorizedMismatch(MemorySessionImpl.State aState, MemorySessionImpl.State bState,\n@@ -204,1 +211,1 @@\n-            return vectorizedMismatchInternal(aScope, bScope, a, aOffset, b, bOffset, length, log2ArrayIndexScale);\n+            return vectorizedMismatchInternal(aState, bState, a, aOffset, b, bOffset, length, log2ArrayIndexScale);\n@@ -206,1 +213,1 @@\n-            throw new IllegalStateException(\"This segment is already closed\");\n+            throw ex.newRuntimeException();\n@@ -211,1 +218,1 @@\n-    private int vectorizedMismatchInternal(MemorySessionImpl aScope, MemorySessionImpl bScope,\n+    private int vectorizedMismatchInternal(MemorySessionImpl.State aState, MemorySessionImpl.State bState,\n@@ -217,2 +224,2 @@\n-            if (aScope != null) {\n-                aScope.checkValidState();\n+            if (aState != null) {\n+                aState.checkValidState();\n@@ -220,2 +227,2 @@\n-            if (bScope != null) {\n-                bScope.checkValidState();\n+            if (bState != null) {\n+                bState.checkValidState();\n@@ -225,2 +232,2 @@\n-            Reference.reachabilityFence(aScope);\n-            Reference.reachabilityFence(bScope);\n+            Reference.reachabilityFence(aState);\n+            Reference.reachabilityFence(bState);\n@@ -231,1 +238,1 @@\n-    public boolean isLoaded(MemorySessionImpl session, long address, boolean isSync, long size) {\n+    public boolean isLoaded(MemorySessionImpl.State state, long address, boolean isSync, long size) {\n@@ -233,1 +240,1 @@\n-            return isLoadedInternal(session, address, isSync, size);\n+            return isLoadedInternal(state, address, isSync, size);\n@@ -235,1 +242,1 @@\n-            throw new IllegalStateException(\"This segment is already closed\");\n+            throw ex.newRuntimeException();\n@@ -240,1 +247,1 @@\n-    public boolean isLoadedInternal(MemorySessionImpl session, long address, boolean isSync, long size) {\n+    public boolean isLoadedInternal(MemorySessionImpl.State state, long address, boolean isSync, long size) {\n@@ -242,2 +249,2 @@\n-            if (session != null) {\n-                session.checkValidState();\n+            if (state != null) {\n+                state.checkValidState();\n@@ -247,1 +254,1 @@\n-            Reference.reachabilityFence(session);\n+            Reference.reachabilityFence(state);\n@@ -252,1 +259,1 @@\n-    public void load(MemorySessionImpl session, long address, boolean isSync, long size) {\n+    public void load(MemorySessionImpl.State state, long address, boolean isSync, long size) {\n@@ -254,1 +261,1 @@\n-            loadInternal(session, address, isSync, size);\n+            loadInternal(state, address, isSync, size);\n@@ -256,1 +263,1 @@\n-            throw new IllegalStateException(\"This segment is already closed\");\n+            throw ex.newRuntimeException();\n@@ -261,1 +268,1 @@\n-    public void loadInternal(MemorySessionImpl session, long address, boolean isSync, long size) {\n+    public void loadInternal(MemorySessionImpl.State state, long address, boolean isSync, long size) {\n@@ -263,2 +270,2 @@\n-            if (session != null) {\n-                session.checkValidState();\n+            if (state != null) {\n+                state.checkValidState();\n@@ -268,1 +275,1 @@\n-            Reference.reachabilityFence(session);\n+            Reference.reachabilityFence(state);\n@@ -273,1 +280,1 @@\n-    public void unload(MemorySessionImpl session, long address, boolean isSync, long size) {\n+    public void unload(MemorySessionImpl.State state, long address, boolean isSync, long size) {\n@@ -275,1 +282,1 @@\n-            unloadInternal(session, address, isSync, size);\n+            unloadInternal(state, address, isSync, size);\n@@ -277,1 +284,1 @@\n-            throw new IllegalStateException(\"This segment is already closed\");\n+            throw ex.newRuntimeException();\n@@ -282,1 +289,1 @@\n-    public void unloadInternal(MemorySessionImpl session, long address, boolean isSync, long size) {\n+    public void unloadInternal(MemorySessionImpl.State state, long address, boolean isSync, long size) {\n@@ -284,2 +291,2 @@\n-            if (session != null) {\n-                session.checkValidState();\n+            if (state != null) {\n+                state.checkValidState();\n@@ -289,1 +296,1 @@\n-            Reference.reachabilityFence(session);\n+            Reference.reachabilityFence(state);\n@@ -294,1 +301,1 @@\n-    public void force(MemorySessionImpl session, FileDescriptor fd, long address, boolean isSync, long index, long length) {\n+    public void force(MemorySessionImpl.State state, FileDescriptor fd, long address, boolean isSync, long index, long length) {\n@@ -296,1 +303,1 @@\n-            forceInternal(session, fd, address, isSync, index, length);\n+            forceInternal(state, fd, address, isSync, index, length);\n@@ -298,1 +305,1 @@\n-            throw new IllegalStateException(\"This segment is already closed\");\n+            throw ex.newRuntimeException();\n@@ -303,1 +310,1 @@\n-    public void forceInternal(MemorySessionImpl session, FileDescriptor fd, long address, boolean isSync, long index, long length) {\n+    public void forceInternal(MemorySessionImpl.State state, FileDescriptor fd, long address, boolean isSync, long index, long length) {\n@@ -305,2 +312,2 @@\n-            if (session != null) {\n-                session.checkValidState();\n+            if (state != null) {\n+                state.checkValidState();\n@@ -310,1 +317,1 @@\n-            Reference.reachabilityFence(session);\n+            Reference.reachabilityFence(state);\n@@ -330,1 +337,1 @@\n-                    msp.sessionImpl(),\n+                    msp.session().state(),\n@@ -336,1 +343,1 @@\n-            throw new IllegalStateException(\"This segment is already closed\");\n+            throw ex.newRuntimeException();\n@@ -344,1 +351,1 @@\n-    V loadFromMemorySegmentScopedInternal(MemorySessionImpl session,\n+    V loadFromMemorySegmentScopedInternal(MemorySessionImpl.State state,\n@@ -350,1 +357,1 @@\n-            session.checkValidState();\n+            state.checkValidState();\n@@ -353,1 +360,1 @@\n-                    msp.unsafeGetBase(), msp.unsafeGetOffset() + offset,\n+                    msp.base(), msp.min() + offset,\n@@ -357,1 +364,1 @@\n-            Reference.reachabilityFence(session);\n+            Reference.reachabilityFence(state);\n@@ -375,1 +382,1 @@\n-                    msp.sessionImpl(),\n+                    msp.session().state(),\n@@ -381,1 +388,1 @@\n-            throw new IllegalStateException(\"This segment is already closed\");\n+            throw ex.newRuntimeException();\n@@ -390,1 +397,1 @@\n-    V loadFromMemorySegmentMaskedScopedInternal(MemorySessionImpl session, Class<? extends V> vmClass,\n+    V loadFromMemorySegmentMaskedScopedInternal(MemorySessionImpl.State state, Class<? extends V> vmClass,\n@@ -396,1 +403,1 @@\n-            session.checkValidState();\n+            state.checkValidState();\n@@ -399,1 +406,1 @@\n-                    msp.unsafeGetBase(), msp.unsafeGetOffset() + offset, m, offsetInRange,\n+                    msp.base(), msp.min() + offset, m, offsetInRange,\n@@ -403,1 +410,1 @@\n-            Reference.reachabilityFence(session);\n+            Reference.reachabilityFence(state);\n@@ -421,1 +428,1 @@\n-                    msp.sessionImpl(),\n+                    msp.session().state(),\n@@ -427,1 +434,1 @@\n-            throw new IllegalStateException(\"This segment is already closed\");\n+            throw ex.newRuntimeException();\n@@ -435,1 +442,1 @@\n-    void storeIntoMemorySegmentScopedInternal(MemorySessionImpl session,\n+    void storeIntoMemorySegmentScopedInternal(MemorySessionImpl.State state,\n@@ -441,1 +448,1 @@\n-            session.checkValidState();\n+            state.checkValidState();\n@@ -444,1 +451,1 @@\n-                    msp.unsafeGetBase(), msp.unsafeGetOffset() + offset,\n+                    msp.base(), msp.min() + offset,\n@@ -449,1 +456,1 @@\n-            Reference.reachabilityFence(session);\n+            Reference.reachabilityFence(state);\n@@ -467,1 +474,1 @@\n-                    msp.sessionImpl(),\n+                    msp.session().state(),\n@@ -473,1 +480,1 @@\n-            throw new IllegalStateException(\"This segment is already closed\");\n+            throw ex.newRuntimeException();\n@@ -481,1 +488,1 @@\n-    void storeIntoMemorySegmentMaskedScopedInternal(MemorySessionImpl session,\n+    void storeIntoMemorySegmentMaskedScopedInternal(MemorySessionImpl.State state,\n@@ -487,1 +494,1 @@\n-            session.checkValidState();\n+            state.checkValidState();\n@@ -490,1 +497,1 @@\n-                    msp.unsafeGetBase(), msp.unsafeGetOffset() + offset,\n+                    msp.base(), msp.min() + offset,\n@@ -495,1 +502,1 @@\n-            Reference.reachabilityFence(session);\n+            Reference.reachabilityFence(state);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/X-ScopedMemoryAccess.java.template","additions":110,"deletions":103,"binary":false,"changes":213,"status":"modified"},{"patch":"@@ -1202,3 +1202,0 @@\n-    private static final int MAP_MEM_SEG_DEFAULT_MODES = 0;\n-    private static final int MAP_MEM_SEG_READ_ONLY = 1;\n-\n@@ -1212,2 +1209,1 @@\n-        MemorySessionImpl sessionImpl = MemorySessionImpl.toSessionImpl(session);\n-        sessionImpl.checkValidStateSlow();\n+        MemorySessionImpl.checkValidState(session);\n@@ -1222,4 +1218,1 @@\n-        int modes = MAP_MEM_SEG_DEFAULT_MODES;\n-        if (mode == MapMode.READ_ONLY) {\n-            modes |= MAP_MEM_SEG_READ_ONLY;\n-        }\n+        boolean isReadOnly = (mode == MapMode.READ_ONLY);\n@@ -1229,3 +1222,3 @@\n-                                            modes, session);\n-            MemorySessionImpl.ResourceList.ResourceCleanup resource =\n-                new MemorySessionImpl.ResourceList.ResourceCleanup() {\n+                                            isReadOnly, (MemorySessionImpl)session);\n+            MemorySessionImpl.addOrCleanupIfFail(session,\n+                new MemorySessionImpl.State.ResourceCleanup() {\n@@ -1236,2 +1229,1 @@\n-                };\n-            sessionImpl.addOrCleanupIfFail(resource);\n+                });\n@@ -1240,1 +1232,1 @@\n-            return new MappedMemorySegmentImpl.EmptyMappedMemorySegmentImpl(modes, session);\n+            return new MappedMemorySegmentImpl.EmptyMappedMemorySegmentImpl(isReadOnly, (MemorySessionImpl)session);\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/FileChannelImpl.java","additions":7,"deletions":15,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -478,1 +478,1 @@\n-        return NIO_ACCESS.acquireSession(bb, async);\n+        return NIO_ACCESS.acquire(bb, async);\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/IOUtil.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -376,1 +376,1 @@\n-                assertTrue(ex.getCause().getMessage().contains(\"already closed\"));\n+                assertTrue(ex.getCause().getMessage().contains(\"Already closed\"));\n@@ -413,1 +413,1 @@\n-                assertTrue(ex.getMessage().contains(\"already closed\"));\n+                assertTrue(ex.getMessage().contains(\"Already closed\"));\n","filename":"test\/jdk\/java\/foreign\/TestByteBuffer.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -55,0 +55,17 @@\n+    @Test\n+    public void testImplicit() {\n+        AtomicInteger acc = new AtomicInteger();\n+        MemorySession session = MemorySession.openImplicit();\n+        for (int i = 0 ; i < N_THREADS ; i++) {\n+            int delta = i;\n+            session.addCloseAction(() -> acc.addAndGet(delta));\n+        }\n+        assertEquals(acc.get(), 0);\n+\n+        session = null;\n+        int expected = IntStream.range(0, N_THREADS).sum();\n+        while (acc.get() != expected) {\n+            kickGC();\n+        }\n+    }\n+\n@@ -373,3 +390,3 @@\n-        MemorySessionImpl sessionImpl = MemorySessionImpl.toSessionImpl(parent);\n-        sessionImpl.acquire0();\n-        child.addCloseAction(sessionImpl::release0);\n+        MemorySessionImpl sessionImpl = (MemorySessionImpl)parent;\n+        sessionImpl.state().acquire();\n+        child.addCloseAction(sessionImpl.state()::release);\n","filename":"test\/jdk\/java\/foreign\/TestMemorySession.java","additions":20,"deletions":3,"binary":false,"changes":23,"status":"modified"}]}