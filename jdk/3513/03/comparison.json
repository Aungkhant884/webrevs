{"files":[{"patch":"@@ -65,1 +65,1 @@\n-static bool commute(Node *add, bool con_left, bool con_right) {\n+static bool commute(PhaseGVN* phase, Node* add) {\n@@ -69,0 +69,25 @@\n+  \/\/ convert \"max(a,b) + min(a,b)\" into \"a+b\".\n+  if ((in1->Opcode() == add->as_Add()->max_opcode() && in2->Opcode() == add->as_Add()->min_opcode())\n+      || (in1->Opcode() == add->as_Add()->min_opcode() && in2->Opcode() == add->as_Add()->max_opcode())) {\n+    Node *in11 = in1->in(1);\n+    Node *in12 = in1->in(2);\n+\n+    Node *in21 = in2->in(1);\n+    Node *in22 = in2->in(2);\n+\n+    if ((in11 == in21 && in12 == in22) ||\n+        (in11 == in22 && in12 == in21)) {\n+      add->set_req(1, in11);\n+      add->set_req(2, in12);\n+      PhaseIterGVN* igvn = phase->is_IterGVN();\n+      if (igvn) {\n+        igvn->_worklist.push(in1);\n+        igvn->_worklist.push(in2);\n+      }\n+      return true;\n+    }\n+  }\n+\n+  bool con_left = phase->type(in1)->singleton();\n+  bool con_right = phase->type(in2)->singleton();\n+\n@@ -118,1 +143,1 @@\n-  if (commute(this, con_left, con_right)) return this;\n+  if (commute(phase, this)) return this;\n@@ -552,3 +577,1 @@\n-  return commute(this,\n-                 phase->type( in(1) )->singleton(),\n-                 phase->type( in(2) )->singleton() ) ? this : NULL;\n+  return commute(phase, this) ? this : NULL;\n@@ -589,3 +612,1 @@\n-  return commute(this,\n-                 phase->type( in(1) )->singleton(),\n-                 phase->type( in(2) )->singleton() ) ? this : NULL;\n+  return commute(phase, this) ? this : NULL;\n","filename":"src\/hotspot\/share\/opto\/addnode.cpp","additions":29,"deletions":8,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -71,0 +71,6 @@\n+  \/\/ Supplied function to return the additive opcode\n+  virtual int max_opcode() const = 0;\n+\n+  \/\/ Supplied function to return the multiplicative opcode\n+  virtual int min_opcode() const = 0;\n+\n@@ -87,0 +93,2 @@\n+  int max_opcode() const { return Op_MaxI; }\n+  int min_opcode() const { return Op_MinI; }\n@@ -105,0 +113,2 @@\n+  int max_opcode() const { return Op_MaxL; }\n+  int min_opcode() const { return Op_MinL; }\n@@ -125,0 +135,2 @@\n+  int max_opcode() const { return Op_MaxF; }\n+  int min_opcode() const { return Op_MinF; }\n@@ -140,0 +152,2 @@\n+  int max_opcode() const { return Op_MaxD; }\n+  int min_opcode() const { return Op_MinD; }\n@@ -186,0 +200,2 @@\n+  int max_opcode() const { return Op_MaxI; }\n+  int min_opcode() const { return Op_MinI; }\n@@ -201,0 +217,2 @@\n+  int max_opcode() const { return Op_MaxL; }\n+  int min_opcode() const { return Op_MinL; }\n@@ -215,0 +233,2 @@\n+  int max_opcode() const { return Op_MaxI; }\n+  int min_opcode() const { return Op_MinI; }\n@@ -228,0 +248,2 @@\n+  int max_opcode() const { return Op_MaxL; }\n+  int min_opcode() const { return Op_MinL; }\n@@ -244,0 +266,2 @@\n+  virtual int max_opcode() const = 0;\n+  virtual int min_opcode() const = 0;\n@@ -283,0 +307,2 @@\n+  int max_opcode() const { return Op_MaxI; }\n+  int min_opcode() const { return Op_MinI; }\n@@ -296,0 +322,2 @@\n+  int max_opcode() const { return Op_MaxI; }\n+  int min_opcode() const { return Op_MinI; }\n@@ -309,0 +337,2 @@\n+  int max_opcode() const { return Op_MaxL; }\n+  int min_opcode() const { return Op_MinL; }\n@@ -321,0 +351,2 @@\n+  int max_opcode() const { return Op_MaxL; }\n+  int min_opcode() const { return Op_MinL; }\n@@ -333,0 +365,2 @@\n+  int max_opcode() const { return Op_MaxF; }\n+  int min_opcode() const { return Op_MinF; }\n@@ -345,0 +379,2 @@\n+  int max_opcode() const { return Op_MaxF; }\n+  int min_opcode() const { return Op_MinF; }\n@@ -357,0 +393,2 @@\n+  int max_opcode() const { return Op_MaxD; }\n+  int min_opcode() const { return Op_MinD; }\n@@ -369,0 +407,2 @@\n+  int max_opcode() const { return Op_MaxD; }\n+  int min_opcode() const { return Op_MinD; }\n","filename":"src\/hotspot\/share\/opto\/addnode.hpp","additions":40,"deletions":0,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -65,0 +65,25 @@\n+\n+  \/\/ convert \"max(a,b) * min(a,b)\" into \"a*b\".\n+  Node *in1 = in(1);\n+  Node *in2 = in(2);\n+  if ((in(1)->Opcode() == max_opcode() && in(2)->Opcode() == min_opcode())\n+      || (in(1)->Opcode() == min_opcode() && in(2)->Opcode() == max_opcode())) {\n+    Node *in11 = in(1)->in(1);\n+    Node *in12 = in(1)->in(2);\n+\n+    Node *in21 = in(2)->in(1);\n+    Node *in22 = in(2)->in(2);\n+\n+    if ((in11 == in21 && in12 == in22) ||\n+        (in11 == in22 && in12 == in21)) {\n+      set_req(1, in11);\n+      set_req(2, in12);\n+      PhaseIterGVN* igvn = phase->is_IterGVN();\n+      if (igvn) {\n+        igvn->_worklist.push(in1);\n+        igvn->_worklist.push(in2);\n+      }\n+      progress = this;\n+    }\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/mulnode.cpp","additions":26,"deletions":1,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -78,0 +78,5 @@\n+  \/\/ Supplied function to return the additive opcode\n+  virtual int max_opcode() const = 0;\n+\n+  \/\/ Supplied function to return the multiplicative opcode\n+  virtual int min_opcode() const = 0;\n@@ -92,0 +97,2 @@\n+  int max_opcode() const { return Op_MaxI; }\n+  int min_opcode() const { return Op_MinI; }\n@@ -108,0 +115,2 @@\n+  int max_opcode() const { return Op_MaxL; }\n+  int min_opcode() const { return Op_MinL; }\n@@ -124,0 +133,2 @@\n+  int max_opcode() const { return Op_MaxF; }\n+  int min_opcode() const { return Op_MinF; }\n@@ -139,0 +150,2 @@\n+  int max_opcode() const { return Op_MaxD; }\n+  int min_opcode() const { return Op_MinD; }\n@@ -168,0 +181,2 @@\n+  int max_opcode() const { return Op_MaxI; }\n+  int min_opcode() const { return Op_MinI; }\n@@ -185,0 +200,2 @@\n+  int max_opcode() const { return Op_MaxL; }\n+  int min_opcode() const { return Op_MinL; }\n","filename":"src\/hotspot\/share\/opto\/mulnode.hpp","additions":18,"deletions":1,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -0,0 +1,209 @@\n+\/*\n+ * Copyright (c) 2021, Huawei Technologies Co. Ltd. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8263006\n+ * @summary Test the result of 8263006's optimization\n+ *\n+ * @run main\/othervm -Xcomp -XX:-TieredCompilation\n+ *      compiler.intrinsics.math.MaxMinOptimizeTest\n+ *\/\n+\n+package compiler.intrinsics.math;\n+\n+import java.util.Arrays;\n+\n+public class MaxMinOptimizeTest {\n+\n+    private static final float fPos     =  15280.0f;\n+    private static final float fNeg     = -55555.5f;\n+    private static final float fPosZero =      0.0f;\n+    private static final float fNegZero =     -0.0f;\n+    private static final float fPosInf  = Float.POSITIVE_INFINITY;\n+    private static final float fNegInf  = Float.NEGATIVE_INFINITY;\n+    private static final float fNaN     = Float.NaN;\n+\n+    private static final float fPosPosAdd = Float.intBitsToFloat(1190051840);\n+    private static final float fNegNegAdd = Float.intBitsToFloat(-942079104);\n+    private static final float fPosNegAdd = Float.intBitsToFloat(-954379392);\n+    private static final float fPosPosMul = Float.intBitsToFloat(1298049424);\n+    private static final float fNegNegMul = Float.intBitsToFloat(1329067759);\n+    private static final float fPosNegMul = Float.intBitsToFloat(-833985532);\n+\n+    private static final double dPos     =  482390926662501720.0;\n+    private static final double dNeg     = -333333333333333333.3;\n+    private static final double dPosZero =                   0.0;\n+    private static final double dNegZero =                  -0.0;\n+    private static final double dPosInf  = Double.POSITIVE_INFINITY;\n+    private static final double dNegInf  = Double.NEGATIVE_INFINITY;\n+    private static final double dNaN     = Double.NaN;\n+\n+    private static final double dPosPosAdd = Double.longBitsToDouble(4875928555416607765L);\n+    private static final double dNegNegAdd = Double.longBitsToDouble(-4349772506333936299L);\n+    private static final double dPosNegAdd = Double.longBitsToDouble(4864042047724301696L);\n+    private static final double dPosPosMul = Double.longBitsToDouble(5135907348984537565L);\n+    private static final double dNegNegMul = Double.longBitsToDouble(5131119721350321694L);\n+    private static final double dPosNegMul = Double.longBitsToDouble(-4089558839395905027L);\n+\n+    private static final float[][] f_cases = {\n+        \/\/     a         b         min       max        add          mul\n+        {     fPos,     fPos,     fPos,     fPos, fPosPosAdd, fPosPosMul},\n+        {     fNeg,     fNeg,     fNeg,     fNeg, fNegNegAdd, fNegNegMul},\n+        {     fPos,     fNeg,     fNeg,     fPos, fPosNegAdd, fPosNegMul},\n+        {     fNeg,     fPos,     fNeg,     fPos, fPosNegAdd, fPosNegMul},\n+\n+        { fPosZero, fNegZero, fNegZero, fPosZero,   fPosZero,   fNegZero},\n+        { fNegZero, fPosZero, fNegZero, fPosZero,   fPosZero,   fNegZero},\n+        { fNegZero, fNegZero, fNegZero, fNegZero,   fNegZero,   fPosZero},\n+\n+        {     fPos,  fPosInf,     fPos,  fPosInf,    fPosInf,    fPosInf},\n+        {     fNeg,  fNegInf,  fNegInf,     fNeg,    fNegInf,    fPosInf},\n+\n+        {     fPos,     fNaN,     fNaN,     fNaN,       fNaN,       fNaN},\n+        {     fNaN,     fPos,     fNaN,     fNaN,       fNaN,       fNaN},\n+        {     fNeg,     fNaN,     fNaN,     fNaN,       fNaN,       fNaN},\n+        {     fNaN,     fNeg,     fNaN,     fNaN,       fNaN,       fNaN},\n+\n+        {  fPosInf,     fNaN,     fNaN,     fNaN,       fNaN,       fNaN},\n+        {     fNaN,  fPosInf,     fNaN,     fNaN,       fNaN,       fNaN},\n+        {  fNegInf,     fNaN,     fNaN,     fNaN,       fNaN,       fNaN},\n+        {     fNaN,  fNegInf,     fNaN,     fNaN,       fNaN,       fNaN}\n+    };\n+\n+    private static final double[][] d_cases = {\n+        \/\/     a         b         min       max        add          mul\n+        {     dPos,     dPos,     dPos,     dPos, dPosPosAdd, dPosPosMul},\n+        {     dNeg,     dNeg,     dNeg,     dNeg, dNegNegAdd, dNegNegMul},\n+        {     dPos,     dNeg,     dNeg,     dPos, dPosNegAdd, dPosNegMul},\n+        {     dNeg,     dPos,     dNeg,     dPos, dPosNegAdd, dPosNegMul},\n+\n+        { dPosZero, dNegZero, dNegZero, dPosZero,   dPosZero,   dNegZero},\n+        { dNegZero, dPosZero, dNegZero, dPosZero,   dPosZero,   dNegZero},\n+        { dNegZero, dNegZero, dNegZero, dNegZero,   dNegZero,   dPosZero},\n+\n+        {     dPos,  dPosInf,     dPos,  dPosInf,    dPosInf,    dPosInf},\n+        {     dNeg,  dNegInf,  dNegInf,     dNeg,    dNegInf,    dPosInf},\n+\n+        {     dPos,     dNaN,     dNaN,     dNaN,       dNaN,       dNaN},\n+        {     dNaN,     dPos,     dNaN,     dNaN,       dNaN,       dNaN},\n+        {     dNeg,     dNaN,     dNaN,     dNaN,       dNaN,       dNaN},\n+        {     dNaN,     dNeg,     dNaN,     dNaN,       dNaN,       dNaN},\n+\n+        {  dPosInf,     dNaN,     dNaN,     dNaN,       dNaN,       dNaN},\n+        {     dNaN,  dPosInf,     dNaN,     dNaN,       dNaN,       dNaN},\n+        {  dNegInf,     dNaN,     dNaN,     dNaN,       dNaN,       dNaN},\n+        {     dNaN,  dNegInf,     dNaN,     dNaN,       dNaN,       dNaN}\n+    };\n+\n+    static float add_opt_float(float a, float b) {\n+      return Math.max(a, b) + Math.min(a, b);\n+    }\n+\n+    static float mul_opt_float(float a, float b) {\n+      return Math.max(a, b) * Math.min(a, b);\n+    }\n+\n+    static float max_opt_float(float a, float b) {\n+      return Math.max(Math.max(a, b), Math.min(a, b));\n+    }\n+\n+    static float min_opt_float(float a, float b) {\n+      return Math.min(Math.max(a, b), Math.min(a, b));\n+    }\n+\n+    static double add_opt_double(double a, double b) {\n+      return Math.max(a, b) + Math.min(a, b);\n+    }\n+\n+    static double mul_opt_double(double a, double b) {\n+      return Math.max(a, b) * Math.min(a, b);\n+    }\n+\n+    static double max_opt_double(double a, double b) {\n+      return Math.max(Math.max(a, b), Math.min(a, b));\n+    }\n+\n+    static double min_opt_double(double a, double b) {\n+      return Math.min(Math.max(a, b), Math.min(a, b));\n+    }\n+\n+    private static void fTest(float[] row) {\n+        fCheck(row[0], row[1],\n+               min_opt_float(row[0], row[1]),\n+               max_opt_float(row[0], row[1]),\n+               add_opt_float(row[0], row[1]),\n+               mul_opt_float(row[0], row[1]),\n+               row[2], row[3], row[4], row[5]);\n+    }\n+\n+    private static void fCheck(float a, float b, float fmin, float fmax, float fadd, float fmul, float efmin, float efmax, float efadd, float efmul) {\n+        int min = Float.floatToRawIntBits(fmin);\n+        int max = Float.floatToRawIntBits(fmax);\n+        int add = Float.floatToRawIntBits(fadd);\n+        int mul = Float.floatToRawIntBits(fmul);\n+        int emin = Float.floatToRawIntBits(efmin);\n+        int emax = Float.floatToRawIntBits(efmax);\n+        int eadd = Float.floatToRawIntBits(efadd);\n+        int emul = Float.floatToRawIntBits(efmul);\n+\n+        if (min != emin || max != emax || add != eadd || mul != emul) {\n+            throw new AssertionError(\"Unexpected result of float test: \" +\n+                    \"a = \" + a + \", b = \" + b + \", \" +\n+                    \"result = (\" + fmin + \", \" + fmax + \", \" + fadd + \", \" + fmul + \"), \" +\n+                    \"expected = (\" + efmin + \", \" + efmax + \", \" + efadd + \", \" + efmul + \")\");\n+        }\n+    }\n+\n+    private static void dTest(double[] row) {\n+        dCheck(row[0], row[1],\n+               min_opt_double(row[0], row[1]),\n+               max_opt_double(row[0], row[1]),\n+               add_opt_double(row[0], row[1]),\n+               mul_opt_double(row[0], row[1]),\n+               row[2], row[3], row[4], row[5]);\n+    }\n+\n+    private static void dCheck(double a, double b, double dmin, double dmax, double dadd, double dmul, double edmin, double edmax, double edadd, double edmul) {\n+        long min = Double.doubleToRawLongBits(dmin);\n+        long max = Double.doubleToRawLongBits(dmax);\n+        long add = Double.doubleToRawLongBits(dadd);\n+        long mul = Double.doubleToRawLongBits(dmul);\n+        long emin = Double.doubleToRawLongBits(edmin);\n+        long emax = Double.doubleToRawLongBits(edmax);\n+        long eadd = Double.doubleToRawLongBits(edadd);\n+        long emul = Double.doubleToRawLongBits(edmul);\n+\n+        if (min != emin || max != emax || add != eadd || mul != emul) {\n+            throw new AssertionError(\"Unexpected result of double test: \" +\n+                    \"a = \" + a + \", b = \" + b + \", \" +\n+                    \"result = (\" + dmin + \", \" + dmax + \", \" + dadd + \", \" + dmul + \"), \" +\n+                    \"expected = (\" + edmin + \", \" + edmax + \", \" + edadd + \", \" + edmul + \")\");\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+      Arrays.stream(f_cases).forEach(MaxMinOptimizeTest::fTest);\n+      Arrays.stream(d_cases).forEach(MaxMinOptimizeTest::dTest);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/math\/MaxMinOptimizeTest.java","additions":209,"deletions":0,"binary":false,"changes":209,"status":"added"},{"patch":"@@ -0,0 +1,151 @@\n+\/*\n+ * Copyright (c) 2021, Huawei Technologies Co. Ltd. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.vm.compiler;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.*;\n+\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode({Mode.AverageTime})\n+@OutputTimeUnit(TimeUnit.MICROSECONDS)\n+@State(Scope.Thread)\n+public class MaxMinOptimizeTest {\n+    private static final int COUNT = 100000;\n+\n+    private float[] floats_a = new float[COUNT];\n+    private float[] floats_b = new float[COUNT];\n+    private double[] doubles_a = new double[COUNT];\n+    private double[] doubles_b = new double[COUNT];\n+\n+    private Random r = new Random();\n+\n+    @Setup\n+    public void init() {\n+        for (int i=0; i<COUNT; i++) {\n+            floats_a[i] = r.nextFloat();\n+            floats_b[i] = r.nextFloat();\n+            doubles_a[i] = r.nextDouble();\n+            doubles_b[i] = r.nextDouble();\n+        }\n+    }\n+\n+    @Benchmark\n+    public void fAdd(Blackhole bh) {\n+        float sum = 0;\n+        for (int i=0; i<COUNT; i++)\n+            sum += fAddBench(floats_a[i], floats_b[i]);\n+        bh.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void fMul(Blackhole bh) {\n+        float sum = 0;\n+        for (int i=0; i<COUNT; i++)\n+            sum += fMulBench(floats_a[i], floats_b[i]);\n+        bh.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void fMax(Blackhole bh) {\n+        float sum = 0;\n+        for (int i=0; i<COUNT; i++)\n+            sum += fMaxBench(floats_a[i], floats_b[i]);\n+        bh.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void fMin(Blackhole bh) {\n+        float sum = 0;\n+        for (int i=0; i<COUNT; i++)\n+            sum += fMinBench(floats_a[i], floats_b[i]);\n+        bh.consume(sum);\n+    }\n+\n+    private float fAddBench(float a, float b) {\n+        return Math.max(a, b) + Math.min(a, b);\n+    }\n+\n+    private float fMulBench(float a, float b) {\n+        return Math.max(a, b) * Math.min(a, b);\n+    }\n+\n+    private float fMaxBench(float a, float b) {\n+        return Math.max(Math.max(a, b), Math.min(a, b));\n+    }\n+\n+    private float fMinBench(float a, float b) {\n+        return Math.min(Math.max(a, b), Math.min(a, b));\n+    }\n+\n+\n+    @Benchmark\n+    public void dAdd(Blackhole bh) {\n+        double sum = 0;\n+        for (int i=0; i<COUNT; i++)\n+            sum += dAddBench(doubles_a[i], doubles_b[i]);\n+        bh.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void dMul(Blackhole bh) {\n+        double sum = 0;\n+        for (int i=0; i<COUNT; i++)\n+            sum += dMulBench(doubles_a[i], doubles_b[i]);\n+        bh.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void dMax(Blackhole bh) {\n+        double sum = 0;\n+        for (int i=0; i<COUNT; i++)\n+            sum += dMaxBench(doubles_a[i], doubles_b[i]);\n+        bh.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void dMin(Blackhole bh) {\n+        double sum = 0;\n+        for (int i=0; i<COUNT; i++)\n+            sum += dMinBench(doubles_a[i], doubles_b[i]);\n+        bh.consume(sum);\n+    }\n+\n+    private double dAddBench(double a, double b) {\n+        return Math.max(a, b) + Math.min(a, b);\n+    }\n+\n+    private double dMulBench(double a, double b) {\n+        return Math.max(a, b) * Math.min(a, b);\n+    }\n+\n+    private double dMaxBench(double a, double b) {\n+        return Math.max(Math.max(a, b), Math.min(a, b));\n+    }\n+\n+    private double dMinBench(double a, double b) {\n+        return Math.min(Math.max(a, b), Math.min(a, b));\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/MaxMinOptimizeTest.java","additions":151,"deletions":0,"binary":false,"changes":151,"status":"added"}]}