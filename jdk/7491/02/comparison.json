{"files":[{"patch":"@@ -2468,0 +2468,1 @@\n+    case Op_PopulateIndex:\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -5185,0 +5185,15 @@\n+\/\/ -------------------------- Populate Index to a Vector --------------------------\n+\n+instruct populateindex(vReg dst, iRegIorL2I src1, immI src2) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (PopulateIndex src1 src2));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_index $dst, $src1, $src2\\t # populate index (sve)\" %}\n+  ins_encode %{\n+    int size = type2aelembytes(this->bottom_type()->is_vect()->element_basic_type());\n+    __ sve_index(as_FloatRegister($dst$$reg), __ elemBytes_to_regVariant(size),\n+                 as_Register($src1$$reg), $src2$$constant);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_sve.ad","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2790,0 +2790,15 @@\n+\/\/ -------------------------- Populate Index to a Vector --------------------------\n+\n+instruct populateindex(vReg dst, iRegIorL2I src1, immI src2) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (PopulateIndex src1 src2));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_index $dst, $src1, $src2\\t # populate index (sve)\" %}\n+  ins_encode %{\n+    int size = type2aelembytes(this->bottom_type()->is_vect()->element_basic_type());\n+    __ sve_index(as_FloatRegister($dst$$reg), __ elemBytes_to_regVariant(size),\n+                 as_Register($src1$$reg), $src2$$constant);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_sve_ad.m4","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -3736,0 +3736,9 @@\n+  \/\/ SVE Create index starting from general-purpose register and incremented by immediate\n+  void sve_index(FloatRegister Zd, SIMD_RegVariant T, Register Rn, int imm) {\n+    starti;\n+    assert(T != Q, \"invalid size\");\n+    f(0b00000100, 31, 24), f(T, 23, 22), f(0b1, 21);\n+    sf(imm, 20, 16), f(0b010001, 15, 10);\n+    rf(Rn, 5), rf(Zd, 0);\n+  }\n+\n@@ -3739,0 +3748,1 @@\n+    assert(T != Q, \"invalid size\");\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.hpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -4230,1 +4230,1 @@\n-    \"ReplicateB\",\"ReplicateS\",\"ReplicateI\",\"ReplicateL\",\"ReplicateF\",\"ReplicateD\",\n+    \"ReplicateB\",\"ReplicateS\",\"ReplicateI\",\"ReplicateL\",\"ReplicateF\",\"ReplicateD\",\"PopulateIndex\",\n","filename":"src\/hotspot\/share\/adlc\/formssel.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -281,0 +281,1 @@\n+macro(PopulateIndex)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -152,0 +152,1 @@\n+class PopulateIndexNode;\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1315,1 +1315,10 @@\n-      if (s1->in(i)->Opcode() != s2->in(i)->Opcode()) return false;\n+      Node* s1_in = s1->in(i);\n+      Node* s2_in = s2->in(i);\n+      if (s1_in->is_Phi() && s2_in->is_Add() && s2_in->in(1) == s1_in) {\n+        \/\/ Special handling for expressions with loop iv, like \"b[i] = a[i] * i\".\n+        \/\/ In this case, one node has an input from the tripcount iv and another\n+        \/\/ node has an input from iv plus an offset.\n+        if (!s1_in->as_Phi()->is_tripcount(T_INT)) return false;\n+      } else {\n+        if (s1_in->Opcode() != s2_in->Opcode()) return false;\n+      }\n@@ -2840,0 +2849,17 @@\n+  \/\/ Insert index population operation\n+  if (opd == iv()) {\n+    BasicType p0_bt = velt_basic_type(p0);\n+    BasicType iv_bt = is_subword_type(p0_bt) ? p0_bt : T_INT;\n+    const TypeVect* vt = TypeVect::make(iv_bt, vlen);\n+    Node* vn = new PopulateIndexNode(iv(), _igvn.intcon(1), vt);\n+#ifdef ASSERT\n+    if (TraceNewVectors) {\n+      tty->print(\"new Vector node: \");\n+      vn->dump();\n+    }\n+#endif\n+    _igvn.register_new_node_with_optimizer(vn);\n+    _phase->set_ctrl(vn, _phase->get_ctrl(opd));\n+    return vn;\n+  }\n+\n@@ -2850,1 +2876,0 @@\n-      Compile* C = _phase->C;\n@@ -3011,1 +3036,0 @@\n-    \/\/ check for scalar promotion\n@@ -3013,2 +3037,18 @@\n-    for (uint i = 1; i < u_pk->size(); i++) {\n-      if (u_pk->at(i)->in(u_idx) != n) return false;\n+    if (n == iv()) {\n+      \/\/ check for index population\n+      BasicType bt = velt_basic_type(use);\n+      if (!VectorNode::is_populate_index_supported(bt)) return false;\n+      for (uint i = 1; i < u_pk->size(); i++) {\n+        \/\/ We can create a vector filled with iv indices if all other nodes\n+        \/\/ in use pack have inputs of iv plus node index.\n+        Node* use_in = u_pk->at(i)->in(u_idx);\n+        if (!use_in->is_Add() || use_in->in(1) != n) return false;\n+        const TypeInt* offset_t = use_in->in(2)->bottom_type()->is_int();\n+        if (offset_t == NULL || !offset_t->is_con() ||\n+            offset_t->get_con() != (jint) i) return false;\n+      }\n+    } else {\n+      \/\/ check for scalar promotion\n+      for (uint i = 1; i < u_pk->size(); i++) {\n+        if (u_pk->at(i)->in(u_idx) != n) return false;\n+      }\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":45,"deletions":5,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -398,0 +398,5 @@\n+bool VectorNode::is_populate_index_supported(BasicType bt) {\n+  int vlen = Matcher::max_vector_size(bt);\n+  return Matcher::match_rule_supported_vector(Op_PopulateIndex, vlen, bt);\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -101,0 +101,1 @@\n+  static bool is_populate_index_supported(BasicType bt);\n@@ -1107,0 +1108,7 @@\n+\/\/======================Populate_Indices_into_a_Vector=========================\n+class PopulateIndexNode : public VectorNode {\n+ public:\n+  PopulateIndexNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {}\n+  virtual int Opcode() const;\n+};\n+\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,73 @@\n+\/*\n+ * Copyright (c) 2022, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.vm.compiler;\n+\n+import java.util.Random;\n+\n+import org.openjdk.jmh.annotations.*;\n+\n+@State(Scope.Benchmark)\n+public class IndexVector {\n+    @Param({\"65536\"})\n+    private int count;\n+\n+    private int[] idx;\n+    private int[] src;\n+    private int[] dst;\n+    private float[] f;\n+\n+    @Setup\n+    public void init() {\n+        idx = new int[count];\n+        src = new int[count];\n+        dst = new int[count];\n+        f = new float[count];\n+        Random ran = new Random(0);\n+        for (int i = 0; i < count; i++) {\n+            src[i] = ran.nextInt();\n+        }\n+    }\n+\n+    @Benchmark\n+    public void indexArrayFill() {\n+        for (int i = 0; i < count; i++) {\n+            idx[i] = i;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void exprWithIndex1() {\n+        for (int i = 0; i < count; i++) {\n+            dst[i] = src[i] * (i & 7);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void exprWithIndex2() {\n+        for (int i = 0; i < count; i++) {\n+            f[i] = i * i + 100;\n+        }\n+    }\n+}\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/IndexVector.java","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"}]}