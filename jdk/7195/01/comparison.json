{"files":[{"patch":"@@ -73,1 +73,1 @@\n-  _manager_array = NEW_C_HEAP_ARRAY(ParCompactionManager*, parallel_gc_threads+1, mtGC);\n+  _manager_array = NEW_C_HEAP_ARRAY(ParCompactionManager*, parallel_gc_threads, mtGC);\n@@ -87,3 +87,0 @@\n-  \/\/ The VMThread gets its own ParCompactionManager, which is not available\n-  \/\/ for work stealing.\n-  _manager_array[parallel_gc_threads] = new ParCompactionManager();\n@@ -100,1 +97,1 @@\n-  for (uint i=0; i<=parallel_gc_threads; i++) {\n+  for (uint i=0; i<parallel_gc_threads; i++) {\n@@ -107,1 +104,1 @@\n-  for (uint i=0; i<=parallel_gc_threads; i++) {\n+  for (uint i=0; i<parallel_gc_threads; i++) {\n@@ -187,1 +184,1 @@\n-  for (uint i = 0; i <= parallel_gc_threads; i++) {\n+  for (uint i = 0; i < parallel_gc_threads; i++) {\n@@ -194,1 +191,1 @@\n-  for (uint i = 0; i <= parallel_gc_threads; i++) {\n+  for (uint i = 0; i < parallel_gc_threads; i++) {\n","filename":"src\/hotspot\/share\/gc\/parallel\/psCompactionManager.cpp","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -150,1 +150,3 @@\n-  static ParCompactionManager* get_vmthread_cm() { return _manager_array[ParallelGCThreads]; }\n+  \/\/ Get the compaction manager when doing evacuation work from the VM thread.\n+  \/\/ Simply use the first compaction manager here.\n+  static ParCompactionManager* get_vmthread_cm() { return _manager_array[0]; }\n","filename":"src\/hotspot\/share\/gc\/parallel\/psCompactionManager.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1598,2 +1598,1 @@\n-void PSParallelCompact::summary_phase(ParCompactionManager* cm,\n-                                      bool maximum_compaction)\n+void PSParallelCompact::summary_phase(bool maximum_compaction)\n@@ -1759,3 +1758,0 @@\n-  \/\/ Get the compaction manager reserved for the VM thread.\n-  ParCompactionManager* const vmthread_cm = ParCompactionManager::get_vmthread_cm();\n-\n@@ -1790,1 +1786,1 @@\n-    marking_phase(vmthread_cm, &_gc_tracer);\n+    marking_phase(&_gc_tracer);\n@@ -1794,1 +1790,1 @@\n-    summary_phase(vmthread_cm, maximum_heap_compaction || max_on_system_gc);\n+    summary_phase(maximum_heap_compaction || max_on_system_gc);\n@@ -2066,2 +2062,1 @@\n-void PSParallelCompact::marking_phase(ParCompactionManager* cm,\n-                                      ParallelOldTracer *gc_tracer) {\n+void PSParallelCompact::marking_phase(ParallelOldTracer *gc_tracer) {\n@@ -2128,13 +2123,0 @@\n-#ifdef ASSERT\n-void PCAdjustPointerClosure::verify_cm(ParCompactionManager* cm) {\n-  assert(cm != NULL, \"associate ParCompactionManage should not be NULL\");\n-  auto vmthread_cm = ParCompactionManager::get_vmthread_cm();\n-  if (Thread::current()->is_VM_thread()) {\n-    assert(cm == vmthread_cm, \"VM threads should use ParCompactionManager from get_vmthread_cm()\");\n-  } else {\n-    assert(Thread::current()->is_Worker_thread(), \"Must be a GC thread\");\n-    assert(cm != vmthread_cm, \"GC threads should use ParCompactionManager from gc_thread_compaction_manager()\");\n-  }\n-}\n-#endif\n-\n@@ -2531,3 +2513,1 @@\n-    \/\/ Update the deferred objects, if any. In principle, any compaction\n-    \/\/ manager can be used. However, since the current thread is VM thread, we\n-    \/\/ use the rightful one to keep the verification logic happy.\n+    \/\/ Update the deferred objects, if any.\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":5,"deletions":25,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -1065,2 +1065,1 @@\n-  static void marking_phase(ParCompactionManager* cm,\n-                            ParallelOldTracer *gc_tracer);\n+  static void marking_phase(ParallelOldTracer *gc_tracer);\n@@ -1126,1 +1125,1 @@\n-  static void summary_phase(ParCompactionManager* cm, bool maximum_compaction);\n+  static void summary_phase(bool maximum_compaction);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -129,3 +129,1 @@\n-  PCAdjustPointerClosure(ParCompactionManager* cm) {\n-    verify_cm(cm);\n-    _cm = cm;\n+  PCAdjustPointerClosure(ParCompactionManager* cm) : _cm(cm) {\n@@ -140,2 +138,0 @@\n-\n-  static void verify_cm(ParCompactionManager* cm) NOT_DEBUG_RETURN;\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.inline.hpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-  const uint promotion_manager_num = ParallelGCThreads + 1;\n+  const uint promotion_manager_num = ParallelGCThreads;\n@@ -98,1 +98,1 @@\n-  return &_manager_array[ParallelGCThreads];\n+  return &_manager_array[0];\n@@ -107,1 +107,1 @@\n-  for(uint i=0; i<ParallelGCThreads+1; i++) {\n+  for(uint i=0; i<ParallelGCThreads; i++) {\n@@ -116,1 +116,1 @@\n-  for (uint i = 0; i < ParallelGCThreads + 1; i++) {\n+  for (uint i = 0; i < ParallelGCThreads; i++) {\n@@ -165,1 +165,1 @@\n-  for (uint i = 0; i < ParallelGCThreads + 1; ++i) {\n+  for (uint i = 0; i < ParallelGCThreads; ++i) {\n@@ -174,1 +174,1 @@\n-  for (uint i = 0; i < ParallelGCThreads + 1; ++i) {\n+  for (uint i = 0; i < ParallelGCThreads; ++i) {\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-  assert(index <= ParallelGCThreads, \"out of range manager_array access\");\n+  assert(index < ParallelGCThreads, \"out of range manager_array access\");\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}