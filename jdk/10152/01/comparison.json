{"files":[{"patch":"@@ -40,0 +40,3 @@\n+      extra-conf-options:\n+        required: false\n+        type: string\n@@ -44,1 +47,1 @@\n-    runs-on: ubuntu-20.04\n+    runs-on: ubuntu-22.04\n@@ -54,0 +57,1 @@\n+          - riscv64\n@@ -56,1 +60,0 @@\n-            debian-arch: arm64\n@@ -58,0 +61,3 @@\n+            debian-arch: arm64\n+            debian-repository: https:\/\/httpredir.debian.org\/debian\/\n+            debian-version: bullseye\n@@ -59,1 +65,0 @@\n-            debian-arch: armhf\n@@ -61,0 +66,3 @@\n+            debian-arch: armhf\n+            debian-repository: https:\/\/httpredir.debian.org\/debian\/\n+            debian-version: bullseye\n@@ -63,1 +71,0 @@\n-            debian-arch: s390x\n@@ -65,0 +72,3 @@\n+            debian-arch: s390x\n+            debian-repository: https:\/\/httpredir.debian.org\/debian\/\n+            debian-version: bullseye\n@@ -66,1 +76,0 @@\n-            debian-arch: ppc64el\n@@ -68,0 +77,9 @@\n+            debian-arch: ppc64el\n+            debian-repository: https:\/\/httpredir.debian.org\/debian\/\n+            debian-version: bullseye\n+          - target-cpu: riscv64\n+            gnu-arch: riscv64\n+            debian-arch: riscv64\n+            debian-repository: https:\/\/deb.debian.org\/debian-ports\n+            debian-keyring: \/usr\/share\/keyrings\/debian-ports-archive-keyring.gpg\n+            debian-version: sid\n@@ -97,1 +115,2 @@\n-              libxrandr-dev libxtst-dev libcups2-dev libasound2-dev\n+              libxrandr-dev libxtst-dev libcups2-dev libasound2-dev \\\n+              debian-ports-archive-keyring\n@@ -118,1 +137,2 @@\n-          buster\n+          $(test -n \"${{ matrix.debian-keyring }}\" && echo \"--keyring=${{ matrix.debian-keyring }}\")\n+          ${{ matrix.debian-version }}\n@@ -120,1 +140,1 @@\n-          https:\/\/httpredir.debian.org\/debian\/\n+          ${{ matrix.debian-repository }}\n@@ -145,0 +165,4 @@\n+          ${{ inputs.extra-conf-options }} || (\n+          echo \"Dumping config.log:\" &&\n+          cat config.log &&\n+          exit 1)\n","filename":".github\/workflows\/build-cross-compile.yml","additions":32,"deletions":8,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -65,1 +65,1 @@\n-    runs-on: ubuntu-20.04\n+    runs-on: ubuntu-22.04\n@@ -125,1 +125,4 @@\n-          ${{ inputs.extra-conf-options }}\n+          ${{ inputs.extra-conf-options }} || (\n+          echo \"Dumping config.log:\" &&\n+          cat config.log &&\n+          exit 1)\n","filename":".github\/workflows\/build-linux.yml","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -100,1 +100,4 @@\n-          ${{ inputs.extra-conf-options }}\n+          ${{ inputs.extra-conf-options }} || (\n+          echo \"Dumping config.log:\" &&\n+          cat config.log &&\n+          exit 1)\n","filename":".github\/workflows\/build-macos.yml","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -113,1 +113,4 @@\n-          ${{ inputs.extra-conf-options }}\n+          ${{ inputs.extra-conf-options }} || (\n+          echo \"Dumping config.log:\" &&\n+          cat config.log &&\n+          exit 1)\n","filename":".github\/workflows\/build-windows.yml","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-    runs-on: ubuntu-20.04\n+    runs-on: ubuntu-22.04\n@@ -127,1 +127,1 @@\n-      apt-gcc-version: '10.3.0-1ubuntu1~20.04'\n+      apt-gcc-version: '10.3.0-15ubuntu1'\n@@ -139,1 +139,1 @@\n-      apt-gcc-version: '10.3.0-1ubuntu1~20.04'\n+      apt-gcc-version: '10.3.0-15ubuntu1'\n@@ -156,1 +156,1 @@\n-      apt-gcc-version: '10.3.0-1ubuntu1~20.04'\n+      apt-gcc-version: '10.3.0-15ubuntu1'\n@@ -169,1 +169,1 @@\n-      apt-gcc-version: '10.3.0-1ubuntu1~20.04'\n+      apt-gcc-version: '10.3.0-15ubuntu1'\n@@ -182,1 +182,1 @@\n-      apt-gcc-version: '10.3.0-1ubuntu1~20.04'\n+      apt-gcc-version: '10.3.0-15ubuntu1'\n@@ -196,1 +196,1 @@\n-      apt-gcc-version: '10.3.0-1ubuntu1~20.04'\n+      apt-gcc-version: '10.3.0-15ubuntu1'\n@@ -208,2 +208,2 @@\n-      apt-gcc-version: '10.3.0-1ubuntu1~20.04'\n-      apt-gcc-cross-version: '10.3.0-1ubuntu1~20.04cross1'\n+      apt-gcc-version: '10.3.0-15ubuntu1'\n+      apt-gcc-cross-version: '10.3.0-8ubuntu1cross1'\n@@ -237,1 +237,1 @@\n-      msvc-toolset-version: '14.25'\n+      msvc-toolset-version: '14.29'\n@@ -265,1 +265,1 @@\n-      runs-on: ubuntu-20.04\n+      runs-on: ubuntu-22.04\n@@ -275,1 +275,1 @@\n-      runs-on: ubuntu-20.04\n+      runs-on: ubuntu-22.04\n@@ -300,1 +300,1 @@\n-    runs-on: ubuntu-20.04\n+    runs-on: ubuntu-22.04\n","filename":".github\/workflows\/main.yml","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -304,1 +304,1 @@\n-<p>The minimum accepted version is Visual Studio 2019 (for aarch64, at least 16.8 is required). Older versions will not be accepted by <code>configure<\/code> and will not work. The maximum accepted version of Visual Studio is 2022.<\/p>\n+<p>The minimum accepted version is Visual Studio 2019 version 16.8. (Note that this version is often presented as &quot;MSVC 14.28&quot;, and reported by cl.exe as 19.28.) Older versions will not be accepted by <code>configure<\/code> and will not work. The maximum accepted version of Visual Studio is 2022.<\/p>\n","filename":"doc\/building.html","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -385,3 +385,4 @@\n-The minimum accepted version is Visual Studio 2019 (for aarch64, at least 16.8\n-is required). Older versions will not be accepted by `configure` and will not\n-work. The maximum accepted version of Visual Studio is 2022.\n+The minimum accepted version is Visual Studio 2019 version 16.8. (Note that this\n+version is often presented as \"MSVC 14.28\", and reported by cl.exe as 19.28.)\n+Older versions will not be accepted by `configure` and will not work. The\n+maximum accepted version of Visual Studio is 2022.\n@@ -1953,2 +1954,2 @@\n-If you want to contribute changes to this document, edit `doc\/building.md` and \n-then run `make update-build-docs` to generate the same changes in \n+If you want to contribute changes to this document, edit `doc\/building.md` and\n+then run `make update-build-docs` to generate the same changes in\n","filename":"doc\/building.md","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -89,1 +89,1 @@\n-<p>JTReg tests can be selected either by picking a JTReg test group, or a selection of files or directories containing JTReg tests.<\/p>\n+<p>JTReg tests can be selected either by picking a JTReg test group, or a selection of files or directories containing JTReg tests. Documentation can be found at <a href=\"https:\/\/openjdk.org\/jtreg\/\">https:\/\/openjdk.org\/jtreg\/<\/a>, note especially the extensive <a href=\"https:\/\/openjdk.org\/jtreg\/faq.html\">FAQ<\/a>.<\/p>\n","filename":"doc\/testing.html","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -141,1 +141,3 @@\n-of files or directories containing JTReg tests.\n+of files or directories containing JTReg tests. Documentation can be found at \n+[https:\/\/openjdk.org\/jtreg\/](https:\/\/openjdk.org\/jtreg\/), note especially the\n+extensive [FAQ](https:\/\/openjdk.org\/jtreg\/faq.html).\n","filename":"doc\/testing.md","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -533,2 +533,2 @@\n-    TOOLCHAIN_CFLAGS_JVM=\"-nologo -MD -Zc:strictStrings -MP\"\n-    TOOLCHAIN_CFLAGS_JDK=\"-nologo -MD -Zc:strictStrings -Zc:wchar_t-\"\n+    TOOLCHAIN_CFLAGS_JVM=\"-nologo -MD -Zc:preprocessor -Zc:strictStrings -MP\"\n+    TOOLCHAIN_CFLAGS_JDK=\"-nologo -MD -Zc:preprocessor -Zc:strictStrings -Zc:wchar_t-\"\n","filename":"make\/autoconf\/flags-cflags.m4","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-TOOLCHAIN_MINIMUM_VERSION_microsoft=\"19.20.0.0\" # VS2019\n+TOOLCHAIN_MINIMUM_VERSION_microsoft=\"19.28.0.0\" # VS2019 16.8, aka MSVC 14.28\n","filename":"make\/autoconf\/toolchain.m4","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -123,1 +123,0 @@\n-      cdsProtectionDomain.cpp \\\n@@ -126,3 +125,0 @@\n-      dumpTimeSharedClassInfo.cpp \\\n-      lambdaProxyClassDictionary.cpp \\\n-      runTimeSharedClassInfo.cpp \\\n","filename":"make\/hotspot\/lib\/JvmFeatures.gmk","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -383,0 +383,9 @@\n+  \/\/ Is marking still active?\n+  if (in_bytes(SATBMarkQueue::byte_width_of_active()) == 4) {\n+    __ ldrw(tmp, in_progress);\n+  } else {\n+    assert(in_bytes(SATBMarkQueue::byte_width_of_active()) == 1, \"Assumption\");\n+    __ ldrb(tmp, in_progress);\n+  }\n+  __ cbzw(tmp, done);\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/g1\/g1BarrierSetAssembler_aarch64.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -385,0 +385,5 @@\n+  \/\/ Is marking still active?\n+  assert(in_bytes(SATBMarkQueue::byte_width_of_active()) == 1, \"Assumption\");\n+  __ ldrb(R1, queue_active);\n+  __ cbz(R1, done);\n+\n","filename":"src\/hotspot\/cpu\/arm\/gc\/g1\/g1BarrierSetAssembler_arm.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -472,0 +472,10 @@\n+  \/\/ Is marking still active?\n+  if (in_bytes(SATBMarkQueue::byte_width_of_active()) == 4) {\n+    __ lwz(tmp, satb_q_active_byte_offset, R16_thread);\n+  } else {\n+    assert(in_bytes(SATBMarkQueue::byte_width_of_active()) == 1, \"Assumption\");\n+    __ lbz(tmp, satb_q_active_byte_offset, R16_thread);\n+  }\n+  __ cmpdi(CCR0, tmp, 0);\n+  __ beq(CCR0, marking_not_active);\n+\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/g1\/g1BarrierSetAssembler_ppc.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -275,1 +275,1 @@\n-                                         Address dst, Register val, Register tmp1, Register tmp2) {\n+                                         Address dst, Register val, Register tmp1, Register tmp2, Register tmp3) {\n@@ -278,2 +278,2 @@\n-    if (dst.base() != x13) {\n-      __ mv(x13, dst.base());\n+    if (dst.base() != tmp3) {\n+      __ mv(tmp3, dst.base());\n@@ -282,1 +282,1 @@\n-    __ la(x13, dst);\n+    __ la(tmp3, dst);\n@@ -286,1 +286,1 @@\n-                       x13 \/* obj *\/,\n+                       tmp3 \/* obj *\/,\n@@ -294,1 +294,1 @@\n-    BarrierSetAssembler::store_at(masm, decorators, type, Address(x13, 0), noreg, noreg, noreg);\n+    BarrierSetAssembler::store_at(masm, decorators, type, Address(tmp3, 0), noreg, noreg, noreg, noreg);\n@@ -302,1 +302,1 @@\n-    BarrierSetAssembler::store_at(masm, decorators, type, Address(x13, 0), val, noreg, noreg);\n+    BarrierSetAssembler::store_at(masm, decorators, type, Address(tmp3, 0), val, noreg, noreg, noreg);\n@@ -304,1 +304,1 @@\n-                          x13 \/* store_adr *\/,\n+                          tmp3 \/* store_adr *\/,\n@@ -372,0 +372,9 @@\n+  \/\/ Is marking still active?\n+  if (in_bytes(SATBMarkQueue::byte_width_of_active()) == 4) {  \/\/ 4-byte width\n+    __ lwu(tmp, in_progress);\n+  } else {\n+    assert(in_bytes(SATBMarkQueue::byte_width_of_active()) == 1, \"Assumption\");\n+    __ lbu(tmp, in_progress);\n+  }\n+  __ beqz(tmp, done);\n+\n","filename":"src\/hotspot\/cpu\/riscv\/gc\/g1\/g1BarrierSetAssembler_riscv.cpp","additions":17,"deletions":8,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -63,1 +63,1 @@\n-                            Address dst, Register val, Register tmp1, Register tmp2);\n+                            Address dst, Register val, Register tmp1, Register tmp2, Register tmp3);\n","filename":"src\/hotspot\/cpu\/riscv\/gc\/g1\/g1BarrierSetAssembler_riscv.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -82,1 +82,1 @@\n-                                   Address dst, Register val, Register tmp1, Register tmp2) {\n+                                   Address dst, Register val, Register tmp1, Register tmp2, Register tmp3) {\n","filename":"src\/hotspot\/cpu\/riscv\/gc\/shared\/barrierSetAssembler_riscv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-                        Address dst, Register val, Register tmp1, Register tmp2);\n+                        Address dst, Register val, Register tmp1, Register tmp2, Register tmp3);\n","filename":"src\/hotspot\/cpu\/riscv\/gc\/shared\/barrierSetAssembler_riscv.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -91,1 +91,1 @@\n-                                                Address dst, Register val, Register tmp1, Register tmp2) {\n+                                                Address dst, Register val, Register tmp1, Register tmp2, Register tmp3) {\n@@ -98,1 +98,1 @@\n-  BarrierSetAssembler::store_at(masm, decorators, type, dst, val, noreg, noreg);\n+  BarrierSetAssembler::store_at(masm, decorators, type, dst, val, noreg, noreg, noreg);\n@@ -102,1 +102,1 @@\n-      store_check(masm, dst.base(), x13);\n+      store_check(masm, dst.base(), tmp3);\n@@ -104,2 +104,2 @@\n-      __ la(x13, dst);\n-      store_check(masm, x13, t0);\n+      __ la(tmp3, dst);\n+      store_check(masm, tmp3, t0);\n","filename":"src\/hotspot\/cpu\/riscv\/gc\/shared\/cardTableBarrierSetAssembler_riscv.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2020, 2021, Huawei Technologies Co., Ltd. All rights reserved.\n+ * Copyright (c) 2020, 2022, Huawei Technologies Co., Ltd. All rights reserved.\n@@ -39,1 +39,1 @@\n-                            Address dst, Register val, Register tmp1, Register tmp2);\n+                            Address dst, Register val, Register tmp1, Register tmp2, Register tmp3);\n","filename":"src\/hotspot\/cpu\/riscv\/gc\/shared\/cardTableBarrierSetAssembler_riscv.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-                                         Address dst, Register val, Register tmp1, Register tmp2) {\n+                                         Address dst, Register val, Register tmp1, Register tmp2, Register tmp3) {\n@@ -50,1 +50,1 @@\n-    oop_store_at(masm, decorators, type, dst, val, tmp1, tmp2);\n+    oop_store_at(masm, decorators, type, dst, val, tmp1, tmp2, tmp3);\n@@ -52,1 +52,1 @@\n-    BarrierSetAssembler::store_at(masm, decorators, type, dst, val, tmp1, tmp2);\n+    BarrierSetAssembler::store_at(masm, decorators, type, dst, val, tmp1, tmp2, tmp3);\n","filename":"src\/hotspot\/cpu\/riscv\/gc\/shared\/modRefBarrierSetAssembler_riscv.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2020, 2021, Huawei Technologies Co., Ltd. All rights reserved.\n+ * Copyright (c) 2020, 2022, Huawei Technologies Co., Ltd. All rights reserved.\n@@ -44,1 +44,1 @@\n-                            Address dst, Register val, Register tmp1, Register tmp2) = 0;\n+                            Address dst, Register val, Register tmp1, Register tmp2, Register tmp3) = 0;\n@@ -52,1 +52,1 @@\n-                        Address dst, Register val, Register tmp1, Register tmp2);\n+                        Address dst, Register val, Register tmp1, Register tmp2, Register tmp3);\n","filename":"src\/hotspot\/cpu\/riscv\/gc\/shared\/modRefBarrierSetAssembler_riscv.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -397,1 +397,1 @@\n-                                             Address dst, Register val, Register tmp1, Register tmp2) {\n+                                             Address dst, Register val, Register tmp1, Register tmp2, Register tmp3) {\n@@ -400,1 +400,1 @@\n-    BarrierSetAssembler::store_at(masm, decorators, type, dst, val, tmp1, tmp2);\n+    BarrierSetAssembler::store_at(masm, decorators, type, dst, val, tmp1, tmp2, tmp3);\n@@ -406,2 +406,2 @@\n-    if (dst.base() != x13) {\n-      __ mv(x13, dst.base());\n+    if (dst.base() != tmp3) {\n+      __ mv(tmp3, dst.base());\n@@ -410,1 +410,1 @@\n-    __ la(x13, dst);\n+    __ la(tmp3, dst);\n@@ -414,1 +414,1 @@\n-                               x13 \/* obj *\/,\n+                               tmp3 \/* obj *\/,\n@@ -422,1 +422,1 @@\n-    BarrierSetAssembler::store_at(masm, decorators, type, Address(x13, 0), noreg, noreg, noreg);\n+    BarrierSetAssembler::store_at(masm, decorators, type, Address(tmp3, 0), noreg, noreg, noreg, noreg);\n@@ -431,1 +431,1 @@\n-    BarrierSetAssembler::store_at(masm, decorators, type, Address(x13, 0), val, noreg, noreg);\n+    BarrierSetAssembler::store_at(masm, decorators, type, Address(tmp3, 0), val, noreg, noreg, noreg);\n","filename":"src\/hotspot\/cpu\/riscv\/gc\/shenandoah\/shenandoahBarrierSetAssembler_riscv.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -81,1 +81,1 @@\n-                        Address dst, Register val, Register tmp1, Register tmp2);\n+                        Address dst, Register val, Register tmp1, Register tmp2, Register tmp3);\n","filename":"src\/hotspot\/cpu\/riscv\/gc\/shenandoah\/shenandoahBarrierSetAssembler_riscv.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -114,1 +114,2 @@\n-                                    Register tmp2) {\n+                                    Register tmp2,\n+                                    Register tmp3) {\n@@ -122,1 +123,1 @@\n-      \/\/ tmp1 and tmp2 are often set to noreg.\n+      \/\/ tmp1, tmp2 and tmp3 are often set to noreg.\n@@ -137,1 +138,1 @@\n-  BarrierSetAssembler::store_at(masm, decorators, type, dst, val, tmp1, tmp2);\n+  BarrierSetAssembler::store_at(masm, decorators, type, dst, val, tmp1, tmp2, noreg);\n","filename":"src\/hotspot\/cpu\/riscv\/gc\/z\/zBarrierSetAssembler_riscv.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -64,1 +64,2 @@\n-                        Register tmp2);\n+                        Register tmp2,\n+                        Register tmp3);\n","filename":"src\/hotspot\/cpu\/riscv\/gc\/z\/zBarrierSetAssembler_riscv.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1783,1 +1783,1 @@\n-                                     Register tmp1, Register thread_tmp) {\n+                                     Register tmp1, Register tmp2, Register tmp3) {\n@@ -1788,1 +1788,1 @@\n-    bs->BarrierSetAssembler::store_at(this, decorators, type, dst, src, tmp1, thread_tmp);\n+    bs->BarrierSetAssembler::store_at(this, decorators, type, dst, src, tmp1, tmp2, tmp3);\n@@ -1790,1 +1790,1 @@\n-    bs->store_at(this, decorators, type, dst, src, tmp1, thread_tmp);\n+    bs->store_at(this, decorators, type, dst, src, tmp1, tmp2, tmp3);\n@@ -1958,2 +1958,2 @@\n-                                    Register thread_tmp, DecoratorSet decorators) {\n-  access_store_at(T_OBJECT, IN_HEAP | decorators, dst, src, tmp1, thread_tmp);\n+                                    Register tmp2, Register tmp3, DecoratorSet decorators) {\n+  access_store_at(T_OBJECT, IN_HEAP | decorators, dst, src, tmp1, tmp2, tmp3);\n@@ -1974,1 +1974,1 @@\n-  access_store_at(T_OBJECT, IN_HEAP, dst, noreg, noreg, noreg);\n+  access_store_at(T_OBJECT, IN_HEAP, dst, noreg, noreg, noreg, noreg);\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -188,1 +188,1 @@\n-                       Register src, Register tmp1, Register thread_tmp);\n+                       Register src, Register tmp1, Register tmp2, Register tmp3);\n@@ -208,1 +208,1 @@\n-                      Register thread_tmp = noreg, DecoratorSet decorators = 0);\n+                      Register tmp2 = noreg, Register tmp3 = noreg, DecoratorSet decorators = 0);\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1561,1 +1561,1 @@\n-    __ store_heap_oop(Address(to, 0), copied_oop, noreg, noreg, AS_RAW);  \/\/ store the oop\n+    __ store_heap_oop(Address(to, 0), copied_oop, noreg, noreg, noreg, AS_RAW); \/\/ store the oop\n","filename":"src\/hotspot\/cpu\/riscv\/stubGenerator_riscv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -133,1 +133,1 @@\n-  __ store_heap_oop(dst, val, x29, x11, decorators);\n+  __ store_heap_oop(dst, val, x29, x11, x13, decorators);\n@@ -1044,1 +1044,1 @@\n-  __ access_store_at(T_INT, IN_HEAP | IS_ARRAY, Address(t0, 0), x10, noreg, noreg);\n+  __ access_store_at(T_INT, IN_HEAP | IS_ARRAY, Address(t0, 0), x10, noreg, noreg, noreg);\n@@ -1057,1 +1057,1 @@\n-  __ access_store_at(T_LONG, IN_HEAP | IS_ARRAY, Address(t0, 0), x10, noreg, noreg);\n+  __ access_store_at(T_LONG, IN_HEAP | IS_ARRAY, Address(t0, 0), x10, noreg, noreg, noreg);\n@@ -1070,1 +1070,1 @@\n-  __ access_store_at(T_FLOAT, IN_HEAP | IS_ARRAY, Address(t0, 0), noreg \/* ftos *\/, noreg, noreg);\n+  __ access_store_at(T_FLOAT, IN_HEAP | IS_ARRAY, Address(t0, 0), noreg \/* ftos *\/, noreg, noreg, noreg);\n@@ -1083,1 +1083,1 @@\n-  __ access_store_at(T_DOUBLE, IN_HEAP | IS_ARRAY, Address(t0, 0), noreg \/* dtos *\/, noreg, noreg);\n+  __ access_store_at(T_DOUBLE, IN_HEAP | IS_ARRAY, Address(t0, 0), noreg \/* dtos *\/, noreg, noreg, noreg);\n@@ -1164,1 +1164,1 @@\n-  __ access_store_at(T_BYTE, IN_HEAP | IS_ARRAY, Address(x11, 0), x10, noreg, noreg);\n+  __ access_store_at(T_BYTE, IN_HEAP | IS_ARRAY, Address(x11, 0), x10, noreg, noreg, noreg);\n@@ -1178,1 +1178,1 @@\n-  __ access_store_at(T_CHAR, IN_HEAP | IS_ARRAY, Address(t0, 0), x10, noreg, noreg);\n+  __ access_store_at(T_CHAR, IN_HEAP | IS_ARRAY, Address(t0, 0), x10, noreg, noreg, noreg);\n@@ -2670,1 +2670,1 @@\n-    __ access_store_at(T_BYTE, IN_HEAP, field, x10, noreg, noreg);\n+    __ access_store_at(T_BYTE, IN_HEAP, field, x10, noreg, noreg, noreg);\n@@ -2690,1 +2690,1 @@\n-    __ access_store_at(T_BOOLEAN, IN_HEAP, field, x10, noreg, noreg);\n+    __ access_store_at(T_BOOLEAN, IN_HEAP, field, x10, noreg, noreg, noreg);\n@@ -2731,1 +2731,1 @@\n-    __ access_store_at(T_INT, IN_HEAP, field, x10, noreg, noreg);\n+    __ access_store_at(T_INT, IN_HEAP, field, x10, noreg, noreg, noreg);\n@@ -2751,1 +2751,1 @@\n-    __ access_store_at(T_CHAR, IN_HEAP, field, x10, noreg, noreg);\n+    __ access_store_at(T_CHAR, IN_HEAP, field, x10, noreg, noreg, noreg);\n@@ -2771,1 +2771,1 @@\n-    __ access_store_at(T_SHORT, IN_HEAP, field, x10, noreg, noreg);\n+    __ access_store_at(T_SHORT, IN_HEAP, field, x10, noreg, noreg, noreg);\n@@ -2791,1 +2791,1 @@\n-    __ access_store_at(T_LONG, IN_HEAP, field, x10, noreg, noreg);\n+    __ access_store_at(T_LONG, IN_HEAP, field, x10, noreg, noreg, noreg);\n@@ -2811,1 +2811,1 @@\n-    __ access_store_at(T_FLOAT, IN_HEAP, field, noreg \/* ftos *\/, noreg, noreg);\n+    __ access_store_at(T_FLOAT, IN_HEAP, field, noreg \/* ftos *\/, noreg, noreg, noreg);\n@@ -2833,1 +2833,1 @@\n-    __ access_store_at(T_DOUBLE, IN_HEAP, field, noreg \/* dtos *\/, noreg, noreg);\n+    __ access_store_at(T_DOUBLE, IN_HEAP, field, noreg \/* dtos *\/, noreg, noreg, noreg);\n@@ -2970,1 +2970,1 @@\n-      __ access_store_at(T_LONG, IN_HEAP, field, x10, noreg, noreg);\n+      __ access_store_at(T_LONG, IN_HEAP, field, x10, noreg, noreg, noreg);\n@@ -2973,1 +2973,1 @@\n-      __ access_store_at(T_INT, IN_HEAP, field, x10, noreg, noreg);\n+      __ access_store_at(T_INT, IN_HEAP, field, x10, noreg, noreg, noreg);\n@@ -2976,1 +2976,1 @@\n-      __ access_store_at(T_BOOLEAN, IN_HEAP, field, x10, noreg, noreg);\n+      __ access_store_at(T_BOOLEAN, IN_HEAP, field, x10, noreg, noreg, noreg);\n@@ -2979,1 +2979,1 @@\n-      __ access_store_at(T_BYTE, IN_HEAP, field, x10, noreg, noreg);\n+      __ access_store_at(T_BYTE, IN_HEAP, field, x10, noreg, noreg, noreg);\n@@ -2982,1 +2982,1 @@\n-      __ access_store_at(T_SHORT, IN_HEAP, field, x10, noreg, noreg);\n+      __ access_store_at(T_SHORT, IN_HEAP, field, x10, noreg, noreg, noreg);\n@@ -2985,1 +2985,1 @@\n-      __ access_store_at(T_CHAR, IN_HEAP, field, x10, noreg, noreg);\n+      __ access_store_at(T_CHAR, IN_HEAP, field, x10, noreg, noreg, noreg);\n@@ -2988,1 +2988,1 @@\n-      __ access_store_at(T_FLOAT, IN_HEAP, field, noreg \/* ftos *\/, noreg, noreg);\n+      __ access_store_at(T_FLOAT, IN_HEAP, field, noreg \/* ftos *\/, noreg, noreg, noreg);\n@@ -2991,1 +2991,1 @@\n-      __ access_store_at(T_DOUBLE, IN_HEAP, field, noreg \/* dtos *\/, noreg, noreg);\n+      __ access_store_at(T_DOUBLE, IN_HEAP, field, noreg \/* dtos *\/, noreg, noreg, noreg);\n","filename":"src\/hotspot\/cpu\/riscv\/templateTable_riscv.cpp","additions":23,"deletions":23,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -491,0 +491,9 @@\n+  \/\/ Is marking still active?\n+  if (in_bytes(SATBMarkQueue::byte_width_of_active()) == 4) {\n+    __ load_and_test_int(tmp, Address(Z_thread, satb_q_active_byte_offset));\n+  } else {\n+    assert(in_bytes(SATBMarkQueue::byte_width_of_active()) == 1, \"Assumption\");\n+    __ load_and_test_byte(tmp, Address(Z_thread, satb_q_active_byte_offset));\n+  }\n+  __ z_bre(marking_not_active); \/\/ Activity indicator is zero, so there is no marking going on currently.\n+\n","filename":"src\/hotspot\/cpu\/s390\/gc\/g1\/g1BarrierSetAssembler_s390.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -471,0 +471,9 @@\n+  \/\/ Is marking still active?\n+  if (in_bytes(SATBMarkQueue::byte_width_of_active()) == 4) {\n+    __ cmpl(queue_active, 0);\n+  } else {\n+    assert(in_bytes(SATBMarkQueue::byte_width_of_active()) == 1, \"Assumption\");\n+    __ cmpb(queue_active, 0);\n+  }\n+  __ jcc(Assembler::equal, done);\n+\n","filename":"src\/hotspot\/cpu\/x86\/gc\/g1\/g1BarrierSetAssembler_x86.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1000,51 +1000,1 @@\n-#ifdef _LP64\n- private:\n-  \/\/ Initialized in macroAssembler_x86_constants.cpp\n-  static address ONE;\n-  static address ONEHALF;\n-  static address SIGN_MASK;\n-  static address TWO_POW_55;\n-  static address TWO_POW_M55;\n-  static address SHIFTER;\n-  static address ZERO;\n-  static address NEG_ZERO;\n-  static address PI32INV;\n-  static address PI_INV_TABLE;\n-  static address Ctable;\n-  static address SC_1;\n-  static address SC_2;\n-  static address SC_3;\n-  static address SC_4;\n-  static address PI_4;\n-  static address P_1;\n-  static address P_3;\n-  static address P_2;\n-\n- public:\n-  void fast_log(XMMRegister xmm0, XMMRegister xmm1, XMMRegister xmm2, XMMRegister xmm3,\n-                XMMRegister xmm4, XMMRegister xmm5, XMMRegister xmm6, XMMRegister xmm7,\n-                Register rax, Register rcx, Register rdx, Register tmp1, Register tmp2);\n-\n-  void fast_log10(XMMRegister xmm0, XMMRegister xmm1, XMMRegister xmm2, XMMRegister xmm3,\n-                  XMMRegister xmm4, XMMRegister xmm5, XMMRegister xmm6, XMMRegister xmm7,\n-                  Register rax, Register rcx, Register rdx, Register r11, Register tmp);\n-\n-  void fast_pow(XMMRegister xmm0, XMMRegister xmm1, XMMRegister xmm2, XMMRegister xmm3, XMMRegister xmm4,\n-                XMMRegister xmm5, XMMRegister xmm6, XMMRegister xmm7, Register rax, Register rcx,\n-                Register rdx, Register tmp1, Register tmp2, Register tmp3, Register tmp4);\n-\n-  void fast_sin(XMMRegister xmm0, XMMRegister xmm1, XMMRegister xmm2, XMMRegister xmm3,\n-                XMMRegister xmm4, XMMRegister xmm5, XMMRegister xmm6, XMMRegister xmm7,\n-                Register rax, Register rbx, Register rcx, Register rdx, Register tmp1);\n-\n-  void fast_cos(XMMRegister xmm0, XMMRegister xmm1, XMMRegister xmm2, XMMRegister xmm3,\n-                XMMRegister xmm4, XMMRegister xmm5, XMMRegister xmm6, XMMRegister xmm7,\n-                Register rax, Register rcx, Register rdx, Register r8,\n-                Register  r9, Register r10, Register r11, Register tmp);\n-\n-  void fast_tan(XMMRegister xmm0, XMMRegister xmm1, XMMRegister xmm2, XMMRegister xmm3,\n-                XMMRegister xmm4, XMMRegister xmm5, XMMRegister xmm6, XMMRegister xmm7,\n-                Register rax, Register rcx, Register rdx, Register r8,\n-                Register  r9, Register r10, Register r11, Register tmp);\n-\n-#else\n+#ifndef _LP64\n@@ -1094,1 +1044,1 @@\n-#endif\n+#endif \/\/ !_LP64\n@@ -1934,1 +1884,0 @@\n-  void updateBytesAdler32(Register adler32, Register buf, Register length, XMMRegister shuf0, XMMRegister shuf1, ExternalAddress scale);\n@@ -2021,27 +1970,1 @@\n-#if COMPILER2_OR_JVMCI\n-  void arraycopy_avx3_special_cases(XMMRegister xmm, KRegister mask, Register from,\n-                                    Register to, Register count, int shift,\n-                                    Register index, Register temp,\n-                                    bool use64byteVector, Label& L_entry, Label& L_exit);\n-\n-  void arraycopy_avx3_special_cases_conjoint(XMMRegister xmm, KRegister mask, Register from,\n-                                             Register to, Register start_index, Register end_index,\n-                                             Register count, int shift, Register temp,\n-                                             bool use64byteVector, Label& L_entry, Label& L_exit);\n-\n-  void copy64_masked_avx(Register dst, Register src, XMMRegister xmm,\n-                         KRegister mask, Register length, Register index,\n-                         Register temp, int shift = Address::times_1, int offset = 0,\n-                         bool use64byteVector = false);\n-\n-  void copy32_masked_avx(Register dst, Register src, XMMRegister xmm,\n-                         KRegister mask, Register length, Register index,\n-                         Register temp, int shift = Address::times_1, int offset = 0);\n-\n-  void copy32_avx(Register dst, Register src, Register index, XMMRegister xmm,\n-                  int shift = Address::times_1, int offset = 0);\n-\n-  void copy64_avx(Register dst, Register src, Register index, XMMRegister xmm,\n-                  bool conjoint, int shift = Address::times_1, int offset = 0,\n-                  bool use64byteVector = false);\n-\n+#ifdef COMPILER2_OR_JVMCI\n@@ -2050,1 +1973,0 @@\n-\n@@ -2056,1 +1978,0 @@\n-\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":3,"deletions":82,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"macroAssembler_x86.hpp\"\n+\n+ATTRIBUTE_ALIGNED(16) juint _ONES[] = {\n+    0x00000000UL, 0x3ff00000UL, 0x00000000UL, 0xbff00000UL\n+};\n+address MacroAssembler::ONES = (address)_ONES;\n+\n+ATTRIBUTE_ALIGNED(16) juint _PI4_INV[] = {\n+    0x6dc9c883UL, 0x3ff45f30UL\n+};\n+address MacroAssembler::PI4_INV = (address)_PI4_INV;\n+\n+ATTRIBUTE_ALIGNED(16) juint _PI4X3[] = {\n+    0x54443000UL, 0xbfe921fbUL, 0x3b39a000UL, 0x3d373dcbUL, 0xe0e68948UL,\n+    0xba845c06UL\n+};\n+address MacroAssembler::PI4X3 = (address)_PI4X3;\n+\n+ATTRIBUTE_ALIGNED(16) juint _PI4X4[] = {\n+    0x54400000UL, 0xbfe921fbUL, 0x1a600000UL, 0xbdc0b461UL, 0x2e000000UL,\n+    0xbb93198aUL, 0x252049c1UL, 0xb96b839aUL\n+};\n+address MacroAssembler::PI4X4 = (address)_PI4X4;\n+\n+ATTRIBUTE_ALIGNED(16) juint _L_2IL0FLOATPACKET_0[] = {\n+    0xffffffffUL, 0x7fffffffUL, 0x00000000UL, 0x00000000UL\n+};\n+address MacroAssembler::L_2IL0FLOATPACKET_0 = (address)_L_2IL0FLOATPACKET_0;\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86_32_constants.cpp","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -0,0 +1,428 @@\n+\/*\n+* Copyright (c) 2016, 2021, Intel Corporation. All rights reserved.\n+* Intel Math Library (LIBM) Source Code\n+*\n+* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+*\n+* This code is free software; you can redistribute it and\/or modify it\n+* under the terms of the GNU General Public License version 2 only, as\n+* published by the Free Software Foundation.\n+*\n+* This code is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+* FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+* version 2 for more details (a copy is included in the LICENSE file that\n+* accompanied this code).\n+*\n+* You should have received a copy of the GNU General Public License version\n+* 2 along with this work; if not, write to the Free Software Foundation,\n+* Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+*\n+* Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+* or visit www.oracle.com if you need additional information or have any\n+* questions.\n+*\n+*\/\n+\n+#include \"precompiled.hpp\"\n+#include \"asm\/assembler.hpp\"\n+#include \"asm\/assembler.inline.hpp\"\n+#include \"macroAssembler_x86.hpp\"\n+#include \"runtime\/stubRoutines.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+\/******************************************************************************\/\n+\/\/                     ALGORITHM DESCRIPTION - COS()\n+\/\/                     ---------------------\n+\/\/\n+\/\/     1. RANGE REDUCTION\n+\/\/\n+\/\/     We perform an initial range reduction from X to r with\n+\/\/\n+\/\/          X =~= N * pi\/32 + r\n+\/\/\n+\/\/     so that |r| <= pi\/64 + epsilon. We restrict inputs to those\n+\/\/     where |N| <= 932560. Beyond this, the range reduction is\n+\/\/     insufficiently accurate. For extremely small inputs,\n+\/\/     denormalization can occur internally, impacting performance.\n+\/\/     This means that the main path is actually only taken for\n+\/\/     2^-252 <= |X| < 90112.\n+\/\/\n+\/\/     To avoid branches, we perform the range reduction to full\n+\/\/     accuracy each time.\n+\/\/\n+\/\/          X - N * (P_1 + P_2 + P_3)\n+\/\/\n+\/\/     where P_1 and P_2 are 32-bit numbers (so multiplication by N\n+\/\/     is exact) and P_3 is a 53-bit number. Together, these\n+\/\/     approximate pi well enough for all cases in the restricted\n+\/\/     range.\n+\/\/\n+\/\/     The main reduction sequence is:\n+\/\/\n+\/\/             y = 32\/pi * x\n+\/\/             N = integer(y)\n+\/\/     (computed by adding and subtracting off SHIFTER)\n+\/\/\n+\/\/             m_1 = N * P_1\n+\/\/             m_2 = N * P_2\n+\/\/             r_1 = x - m_1\n+\/\/             r = r_1 - m_2\n+\/\/     (this r can be used for most of the calculation)\n+\/\/\n+\/\/             c_1 = r_1 - r\n+\/\/             m_3 = N * P_3\n+\/\/             c_2 = c_1 - m_2\n+\/\/             c = c_2 - m_3\n+\/\/\n+\/\/     2. MAIN ALGORITHM\n+\/\/\n+\/\/     The algorithm uses a table lookup based on B = M * pi \/ 32\n+\/\/     where M = N mod 64. The stored values are:\n+\/\/       sigma             closest power of 2 to cos(B)\n+\/\/       C_hl              53-bit cos(B) - sigma\n+\/\/       S_hi + S_lo       2 * 53-bit sin(B)\n+\/\/\n+\/\/     The computation is organized as follows:\n+\/\/\n+\/\/          sin(B + r + c) = [sin(B) + sigma * r] +\n+\/\/                           r * (cos(B) - sigma) +\n+\/\/                           sin(B) * [cos(r + c) - 1] +\n+\/\/                           cos(B) * [sin(r + c) - r]\n+\/\/\n+\/\/     which is approximately:\n+\/\/\n+\/\/          [S_hi + sigma * r] +\n+\/\/          C_hl * r +\n+\/\/          S_lo + S_hi * [(cos(r) - 1) - r * c] +\n+\/\/          (C_hl + sigma) * [(sin(r) - r) + c]\n+\/\/\n+\/\/     and this is what is actually computed. We separate this sum\n+\/\/     into four parts:\n+\/\/\n+\/\/          hi + med + pols + corr\n+\/\/\n+\/\/     where\n+\/\/\n+\/\/          hi       = S_hi + sigma r\n+\/\/          med      = C_hl * r\n+\/\/          pols     = S_hi * (cos(r) - 1) + (C_hl + sigma) * (sin(r) - r)\n+\/\/          corr     = S_lo + c * ((C_hl + sigma) - S_hi * r)\n+\/\/\n+\/\/     3. POLYNOMIAL\n+\/\/\n+\/\/     The polynomial S_hi * (cos(r) - 1) + (C_hl + sigma) *\n+\/\/     (sin(r) - r) can be rearranged freely, since it is quite\n+\/\/     small, so we exploit parallelism to the fullest.\n+\/\/\n+\/\/          psc4       =   SC_4 * r_1\n+\/\/          msc4       =   psc4 * r\n+\/\/          r2         =   r * r\n+\/\/          msc2       =   SC_2 * r2\n+\/\/          r4         =   r2 * r2\n+\/\/          psc3       =   SC_3 + msc4\n+\/\/          psc1       =   SC_1 + msc2\n+\/\/          msc3       =   r4 * psc3\n+\/\/          sincospols =   psc1 + msc3\n+\/\/          pols       =   sincospols *\n+\/\/                         <S_hi * r^2 | (C_hl + sigma) * r^3>\n+\/\/\n+\/\/     4. CORRECTION TERM\n+\/\/\n+\/\/     This is where the \"c\" component of the range reduction is\n+\/\/     taken into account; recall that just \"r\" is used for most of\n+\/\/     the calculation.\n+\/\/\n+\/\/          -c   = m_3 - c_2\n+\/\/          -d   = S_hi * r - (C_hl + sigma)\n+\/\/          corr = -c * -d + S_lo\n+\/\/\n+\/\/     5. COMPENSATED SUMMATIONS\n+\/\/\n+\/\/     The two successive compensated summations add up the high\n+\/\/     and medium parts, leaving just the low parts to add up at\n+\/\/     the end.\n+\/\/\n+\/\/          rs        =  sigma * r\n+\/\/          res_int   =  S_hi + rs\n+\/\/          k_0       =  S_hi - res_int\n+\/\/          k_2       =  k_0 + rs\n+\/\/          med       =  C_hl * r\n+\/\/          res_hi    =  res_int + med\n+\/\/          k_1       =  res_int - res_hi\n+\/\/          k_3       =  k_1 + med\n+\/\/\n+\/\/     6. FINAL SUMMATION\n+\/\/\n+\/\/     We now add up all the small parts:\n+\/\/\n+\/\/          res_lo = pols(hi) + pols(lo) + corr + k_1 + k_3\n+\/\/\n+\/\/     Now the overall result is just:\n+\/\/\n+\/\/          res_hi + res_lo\n+\/\/\n+\/\/     7. SMALL ARGUMENTS\n+\/\/\n+\/\/     Inputs with |X| < 2^-252 are treated specially as\n+\/\/     1 - |x|.\n+\/\/\n+\/\/ Special cases:\n+\/\/  cos(NaN) = quiet NaN, and raise invalid exception\n+\/\/  cos(INF) = NaN and raise invalid exception\n+\/\/  cos(0) = 1\n+\/\/\n+\/******************************************************************************\/\n+\n+\/\/ The 32 bit code is at most SSE2 compliant\n+\n+ATTRIBUTE_ALIGNED(16) juint _static_const_table_cos[] =\n+{\n+    0x00000000UL, 0x00000000UL, 0x00000000UL, 0x00000000UL, 0x00000000UL,\n+    0x00000000UL, 0x00000000UL, 0x3ff00000UL, 0x176d6d31UL, 0xbf73b92eUL,\n+    0xbc29b42cUL, 0x3fb917a6UL, 0xe0000000UL, 0xbc3e2718UL, 0x00000000UL,\n+    0x3ff00000UL, 0x011469fbUL, 0xbf93ad06UL, 0x3c69a60bUL, 0x3fc8f8b8UL,\n+    0xc0000000UL, 0xbc626d19UL, 0x00000000UL, 0x3ff00000UL, 0x939d225aUL,\n+    0xbfa60beaUL, 0x2ed59f06UL, 0x3fd29406UL, 0xa0000000UL, 0xbc75d28dUL,\n+    0x00000000UL, 0x3ff00000UL, 0x866b95cfUL, 0xbfb37ca1UL, 0xa6aea963UL,\n+    0x3fd87de2UL, 0xe0000000UL, 0xbc672cedUL, 0x00000000UL, 0x3ff00000UL,\n+    0x73fa1279UL, 0xbfbe3a68UL, 0x3806f63bUL, 0x3fde2b5dUL, 0x20000000UL,\n+    0x3c5e0d89UL, 0x00000000UL, 0x3ff00000UL, 0x5bc57974UL, 0xbfc59267UL,\n+    0x39ae68c8UL, 0x3fe1c73bUL, 0x20000000UL, 0x3c8b25ddUL, 0x00000000UL,\n+    0x3ff00000UL, 0x53aba2fdUL, 0xbfcd0dfeUL, 0x25091dd6UL, 0x3fe44cf3UL,\n+    0x20000000UL, 0x3c68076aUL, 0x00000000UL, 0x3ff00000UL, 0x99fcef32UL,\n+    0x3fca8279UL, 0x667f3bcdUL, 0x3fe6a09eUL, 0x20000000UL, 0xbc8bdd34UL,\n+    0x00000000UL, 0x3fe00000UL, 0x94247758UL, 0x3fc133ccUL, 0x6b151741UL,\n+    0x3fe8bc80UL, 0x20000000UL, 0xbc82c5e1UL, 0x00000000UL, 0x3fe00000UL,\n+    0x9ae68c87UL, 0x3fac73b3UL, 0x290ea1a3UL, 0x3fea9b66UL, 0xe0000000UL,\n+    0x3c39f630UL, 0x00000000UL, 0x3fe00000UL, 0x7f909c4eUL, 0xbf9d4a2cUL,\n+    0xf180bdb1UL, 0x3fec38b2UL, 0x80000000UL, 0xbc76e0b1UL, 0x00000000UL,\n+    0x3fe00000UL, 0x65455a75UL, 0xbfbe0875UL, 0xcf328d46UL, 0x3fed906bUL,\n+    0x20000000UL, 0x3c7457e6UL, 0x00000000UL, 0x3fe00000UL, 0x76acf82dUL,\n+    0x3fa4a031UL, 0x56c62ddaUL, 0x3fee9f41UL, 0xe0000000UL, 0x3c8760b1UL,\n+    0x00000000UL, 0x3fd00000UL, 0x0e5967d5UL, 0xbfac1d1fUL, 0xcff75cb0UL,\n+    0x3fef6297UL, 0x20000000UL, 0x3c756217UL, 0x00000000UL, 0x3fd00000UL,\n+    0x0f592f50UL, 0xbf9ba165UL, 0xa3d12526UL, 0x3fefd88dUL, 0x40000000UL,\n+    0xbc887df6UL, 0x00000000UL, 0x3fc00000UL, 0x00000000UL, 0x00000000UL,\n+    0x00000000UL, 0x3ff00000UL, 0x00000000UL, 0x00000000UL, 0x00000000UL,\n+    0x00000000UL, 0x0f592f50UL, 0x3f9ba165UL, 0xa3d12526UL, 0x3fefd88dUL,\n+    0x40000000UL, 0xbc887df6UL, 0x00000000UL, 0xbfc00000UL, 0x0e5967d5UL,\n+    0x3fac1d1fUL, 0xcff75cb0UL, 0x3fef6297UL, 0x20000000UL, 0x3c756217UL,\n+    0x00000000UL, 0xbfd00000UL, 0x76acf82dUL, 0xbfa4a031UL, 0x56c62ddaUL,\n+    0x3fee9f41UL, 0xe0000000UL, 0x3c8760b1UL, 0x00000000UL, 0xbfd00000UL,\n+    0x65455a75UL, 0x3fbe0875UL, 0xcf328d46UL, 0x3fed906bUL, 0x20000000UL,\n+    0x3c7457e6UL, 0x00000000UL, 0xbfe00000UL, 0x7f909c4eUL, 0x3f9d4a2cUL,\n+    0xf180bdb1UL, 0x3fec38b2UL, 0x80000000UL, 0xbc76e0b1UL, 0x00000000UL,\n+    0xbfe00000UL, 0x9ae68c87UL, 0xbfac73b3UL, 0x290ea1a3UL, 0x3fea9b66UL,\n+    0xe0000000UL, 0x3c39f630UL, 0x00000000UL, 0xbfe00000UL, 0x94247758UL,\n+    0xbfc133ccUL, 0x6b151741UL, 0x3fe8bc80UL, 0x20000000UL, 0xbc82c5e1UL,\n+    0x00000000UL, 0xbfe00000UL, 0x99fcef32UL, 0xbfca8279UL, 0x667f3bcdUL,\n+    0x3fe6a09eUL, 0x20000000UL, 0xbc8bdd34UL, 0x00000000UL, 0xbfe00000UL,\n+    0x53aba2fdUL, 0x3fcd0dfeUL, 0x25091dd6UL, 0x3fe44cf3UL, 0x20000000UL,\n+    0x3c68076aUL, 0x00000000UL, 0xbff00000UL, 0x5bc57974UL, 0x3fc59267UL,\n+    0x39ae68c8UL, 0x3fe1c73bUL, 0x20000000UL, 0x3c8b25ddUL, 0x00000000UL,\n+    0xbff00000UL, 0x73fa1279UL, 0x3fbe3a68UL, 0x3806f63bUL, 0x3fde2b5dUL,\n+    0x20000000UL, 0x3c5e0d89UL, 0x00000000UL, 0xbff00000UL, 0x866b95cfUL,\n+    0x3fb37ca1UL, 0xa6aea963UL, 0x3fd87de2UL, 0xe0000000UL, 0xbc672cedUL,\n+    0x00000000UL, 0xbff00000UL, 0x939d225aUL, 0x3fa60beaUL, 0x2ed59f06UL,\n+    0x3fd29406UL, 0xa0000000UL, 0xbc75d28dUL, 0x00000000UL, 0xbff00000UL,\n+    0x011469fbUL, 0x3f93ad06UL, 0x3c69a60bUL, 0x3fc8f8b8UL, 0xc0000000UL,\n+    0xbc626d19UL, 0x00000000UL, 0xbff00000UL, 0x176d6d31UL, 0x3f73b92eUL,\n+    0xbc29b42cUL, 0x3fb917a6UL, 0xe0000000UL, 0xbc3e2718UL, 0x00000000UL,\n+    0xbff00000UL, 0x00000000UL, 0x00000000UL, 0x00000000UL, 0x00000000UL,\n+    0x00000000UL, 0x00000000UL, 0x00000000UL, 0xbff00000UL, 0x176d6d31UL,\n+    0x3f73b92eUL, 0xbc29b42cUL, 0xbfb917a6UL, 0xe0000000UL, 0x3c3e2718UL,\n+    0x00000000UL, 0xbff00000UL, 0x011469fbUL, 0x3f93ad06UL, 0x3c69a60bUL,\n+    0xbfc8f8b8UL, 0xc0000000UL, 0x3c626d19UL, 0x00000000UL, 0xbff00000UL,\n+    0x939d225aUL, 0x3fa60beaUL, 0x2ed59f06UL, 0xbfd29406UL, 0xa0000000UL,\n+    0x3c75d28dUL, 0x00000000UL, 0xbff00000UL, 0x866b95cfUL, 0x3fb37ca1UL,\n+    0xa6aea963UL, 0xbfd87de2UL, 0xe0000000UL, 0x3c672cedUL, 0x00000000UL,\n+    0xbff00000UL, 0x73fa1279UL, 0x3fbe3a68UL, 0x3806f63bUL, 0xbfde2b5dUL,\n+    0x20000000UL, 0xbc5e0d89UL, 0x00000000UL, 0xbff00000UL, 0x5bc57974UL,\n+    0x3fc59267UL, 0x39ae68c8UL, 0xbfe1c73bUL, 0x20000000UL, 0xbc8b25ddUL,\n+    0x00000000UL, 0xbff00000UL, 0x53aba2fdUL, 0x3fcd0dfeUL, 0x25091dd6UL,\n+    0xbfe44cf3UL, 0x20000000UL, 0xbc68076aUL, 0x00000000UL, 0xbff00000UL,\n+    0x99fcef32UL, 0xbfca8279UL, 0x667f3bcdUL, 0xbfe6a09eUL, 0x20000000UL,\n+    0x3c8bdd34UL, 0x00000000UL, 0xbfe00000UL, 0x94247758UL, 0xbfc133ccUL,\n+    0x6b151741UL, 0xbfe8bc80UL, 0x20000000UL, 0x3c82c5e1UL, 0x00000000UL,\n+    0xbfe00000UL, 0x9ae68c87UL, 0xbfac73b3UL, 0x290ea1a3UL, 0xbfea9b66UL,\n+    0xe0000000UL, 0xbc39f630UL, 0x00000000UL, 0xbfe00000UL, 0x7f909c4eUL,\n+    0x3f9d4a2cUL, 0xf180bdb1UL, 0xbfec38b2UL, 0x80000000UL, 0x3c76e0b1UL,\n+    0x00000000UL, 0xbfe00000UL, 0x65455a75UL, 0x3fbe0875UL, 0xcf328d46UL,\n+    0xbfed906bUL, 0x20000000UL, 0xbc7457e6UL, 0x00000000UL, 0xbfe00000UL,\n+    0x76acf82dUL, 0xbfa4a031UL, 0x56c62ddaUL, 0xbfee9f41UL, 0xe0000000UL,\n+    0xbc8760b1UL, 0x00000000UL, 0xbfd00000UL, 0x0e5967d5UL, 0x3fac1d1fUL,\n+    0xcff75cb0UL, 0xbfef6297UL, 0x20000000UL, 0xbc756217UL, 0x00000000UL,\n+    0xbfd00000UL, 0x0f592f50UL, 0x3f9ba165UL, 0xa3d12526UL, 0xbfefd88dUL,\n+    0x40000000UL, 0x3c887df6UL, 0x00000000UL, 0xbfc00000UL, 0x00000000UL,\n+    0x00000000UL, 0x00000000UL, 0xbff00000UL, 0x00000000UL, 0x00000000UL,\n+    0x00000000UL, 0x00000000UL, 0x0f592f50UL, 0xbf9ba165UL, 0xa3d12526UL,\n+    0xbfefd88dUL, 0x40000000UL, 0x3c887df6UL, 0x00000000UL, 0x3fc00000UL,\n+    0x0e5967d5UL, 0xbfac1d1fUL, 0xcff75cb0UL, 0xbfef6297UL, 0x20000000UL,\n+    0xbc756217UL, 0x00000000UL, 0x3fd00000UL, 0x76acf82dUL, 0x3fa4a031UL,\n+    0x56c62ddaUL, 0xbfee9f41UL, 0xe0000000UL, 0xbc8760b1UL, 0x00000000UL,\n+    0x3fd00000UL, 0x65455a75UL, 0xbfbe0875UL, 0xcf328d46UL, 0xbfed906bUL,\n+    0x20000000UL, 0xbc7457e6UL, 0x00000000UL, 0x3fe00000UL, 0x7f909c4eUL,\n+    0xbf9d4a2cUL, 0xf180bdb1UL, 0xbfec38b2UL, 0x80000000UL, 0x3c76e0b1UL,\n+    0x00000000UL, 0x3fe00000UL, 0x9ae68c87UL, 0x3fac73b3UL, 0x290ea1a3UL,\n+    0xbfea9b66UL, 0xe0000000UL, 0xbc39f630UL, 0x00000000UL, 0x3fe00000UL,\n+    0x94247758UL, 0x3fc133ccUL, 0x6b151741UL, 0xbfe8bc80UL, 0x20000000UL,\n+    0x3c82c5e1UL, 0x00000000UL, 0x3fe00000UL, 0x99fcef32UL, 0x3fca8279UL,\n+    0x667f3bcdUL, 0xbfe6a09eUL, 0x20000000UL, 0x3c8bdd34UL, 0x00000000UL,\n+    0x3fe00000UL, 0x53aba2fdUL, 0xbfcd0dfeUL, 0x25091dd6UL, 0xbfe44cf3UL,\n+    0x20000000UL, 0xbc68076aUL, 0x00000000UL, 0x3ff00000UL, 0x5bc57974UL,\n+    0xbfc59267UL, 0x39ae68c8UL, 0xbfe1c73bUL, 0x20000000UL, 0xbc8b25ddUL,\n+    0x00000000UL, 0x3ff00000UL, 0x73fa1279UL, 0xbfbe3a68UL, 0x3806f63bUL,\n+    0xbfde2b5dUL, 0x20000000UL, 0xbc5e0d89UL, 0x00000000UL, 0x3ff00000UL,\n+    0x866b95cfUL, 0xbfb37ca1UL, 0xa6aea963UL, 0xbfd87de2UL, 0xe0000000UL,\n+    0x3c672cedUL, 0x00000000UL, 0x3ff00000UL, 0x939d225aUL, 0xbfa60beaUL,\n+    0x2ed59f06UL, 0xbfd29406UL, 0xa0000000UL, 0x3c75d28dUL, 0x00000000UL,\n+    0x3ff00000UL, 0x011469fbUL, 0xbf93ad06UL, 0x3c69a60bUL, 0xbfc8f8b8UL,\n+    0xc0000000UL, 0x3c626d19UL, 0x00000000UL, 0x3ff00000UL, 0x176d6d31UL,\n+    0xbf73b92eUL, 0xbc29b42cUL, 0xbfb917a6UL, 0xe0000000UL, 0x3c3e2718UL,\n+    0x00000000UL, 0x3ff00000UL, 0x55555555UL, 0xbfc55555UL, 0x00000000UL,\n+    0xbfe00000UL, 0x11111111UL, 0x3f811111UL, 0x55555555UL, 0x3fa55555UL,\n+    0x1a01a01aUL, 0xbf2a01a0UL, 0x16c16c17UL, 0xbf56c16cUL, 0xa556c734UL,\n+    0x3ec71de3UL, 0x1a01a01aUL, 0x3efa01a0UL, 0x1a600000UL, 0x3d90b461UL,\n+    0x1a600000UL, 0x3d90b461UL, 0x54400000UL, 0x3fb921fbUL, 0x00000000UL,\n+    0x00000000UL, 0x2e037073UL, 0x3b63198aUL, 0x00000000UL, 0x00000000UL,\n+    0x6dc9c883UL, 0x40245f30UL, 0x00000000UL, 0x00000000UL, 0x00000000UL,\n+    0x43380000UL, 0x00000000UL, 0x00000000UL, 0x00000000UL, 0x3ff00000UL,\n+    0x00000000UL, 0x00000000UL, 0x00000000UL, 0x80000000UL, 0x00000000UL,\n+    0x00000000UL, 0x00000000UL, 0x80000000UL, 0x00000000UL, 0x00000000UL,\n+    0x00000000UL, 0x3fe00000UL, 0x00000000UL, 0x3fe00000UL\n+};\n+\/\/registers,\n+\/\/ input: (rbp + 8)\n+\/\/ scratch: xmm1, xmm2, xmm3, xmm4, xmm5, xmm6, xmm7\n+\/\/          eax, ecx, edx, ebx (tmp)\n+\n+\/\/ Code generated by Intel C compiler for LIBM library\n+\n+void MacroAssembler::fast_cos(XMMRegister xmm0, XMMRegister xmm1, XMMRegister xmm2, XMMRegister xmm3,\n+                              XMMRegister xmm4, XMMRegister xmm5, XMMRegister xmm6, XMMRegister xmm7,\n+                              Register eax, Register ecx, Register edx, Register tmp) {\n+  Label L_2TAG_PACKET_0_0_2, L_2TAG_PACKET_1_0_2, L_2TAG_PACKET_2_0_2, L_2TAG_PACKET_3_0_2;\n+  Label start;\n+\n+  assert_different_registers(tmp, eax, ecx, edx);\n+\n+  address static_const_table_cos = (address)_static_const_table_cos;\n+\n+  bind(start);\n+  subl(rsp, 120);\n+  movl(Address(rsp, 56), tmp);\n+  lea(tmp, ExternalAddress(static_const_table_cos));\n+  movsd(xmm0, Address(rsp, 128));\n+  pextrw(eax, xmm0, 3);\n+  andl(eax, 32767);\n+  subl(eax, 12336);\n+  cmpl(eax, 4293);\n+  jcc(Assembler::above, L_2TAG_PACKET_0_0_2);\n+  movsd(xmm1, Address(tmp, 2160));\n+  mulsd(xmm1, xmm0);\n+  movdqu(xmm5, Address(tmp, 2240));\n+  movsd(xmm4, Address(tmp, 2224));\n+  pand(xmm4, xmm0);\n+  por(xmm5, xmm4);\n+  movsd(xmm3, Address(tmp, 2128));\n+  movdqu(xmm2, Address(tmp, 2112));\n+  addpd(xmm1, xmm5);\n+  cvttsd2sil(edx, xmm1);\n+  cvtsi2sdl(xmm1, edx);\n+  mulsd(xmm3, xmm1);\n+  unpcklpd(xmm1, xmm1);\n+  addl(edx, 1865232);\n+  movdqu(xmm4, xmm0);\n+  andl(edx, 63);\n+  movdqu(xmm5, Address(tmp, 2096));\n+  lea(eax, Address(tmp, 0));\n+  shll(edx, 5);\n+  addl(eax, edx);\n+  mulpd(xmm2, xmm1);\n+  subsd(xmm0, xmm3);\n+  mulsd(xmm1, Address(tmp, 2144));\n+  subsd(xmm4, xmm3);\n+  movsd(xmm7, Address(eax, 8));\n+  unpcklpd(xmm0, xmm0);\n+  movapd(xmm3, xmm4);\n+  subsd(xmm4, xmm2);\n+  mulpd(xmm5, xmm0);\n+  subpd(xmm0, xmm2);\n+  movdqu(xmm6, Address(tmp, 2064));\n+  mulsd(xmm7, xmm4);\n+  subsd(xmm3, xmm4);\n+  mulpd(xmm5, xmm0);\n+  mulpd(xmm0, xmm0);\n+  subsd(xmm3, xmm2);\n+  movdqu(xmm2, Address(eax, 0));\n+  subsd(xmm1, xmm3);\n+  movsd(xmm3, Address(eax, 24));\n+  addsd(xmm2, xmm3);\n+  subsd(xmm7, xmm2);\n+  mulsd(xmm2, xmm4);\n+  mulpd(xmm6, xmm0);\n+  mulsd(xmm3, xmm4);\n+  mulpd(xmm2, xmm0);\n+  mulpd(xmm0, xmm0);\n+  addpd(xmm5, Address(tmp, 2080));\n+  mulsd(xmm4, Address(eax, 0));\n+  addpd(xmm6, Address(tmp, 2048));\n+  mulpd(xmm5, xmm0);\n+  movapd(xmm0, xmm3);\n+  addsd(xmm3, Address(eax, 8));\n+  mulpd(xmm1, xmm7);\n+  movapd(xmm7, xmm4);\n+  addsd(xmm4, xmm3);\n+  addpd(xmm6, xmm5);\n+  movsd(xmm5, Address(eax, 8));\n+  subsd(xmm5, xmm3);\n+  subsd(xmm3, xmm4);\n+  addsd(xmm1, Address(eax, 16));\n+  mulpd(xmm6, xmm2);\n+  addsd(xmm5, xmm0);\n+  addsd(xmm3, xmm7);\n+  addsd(xmm1, xmm5);\n+  addsd(xmm1, xmm3);\n+  addsd(xmm1, xmm6);\n+  unpckhpd(xmm6, xmm6);\n+  addsd(xmm1, xmm6);\n+  addsd(xmm4, xmm1);\n+  movsd(Address(rsp, 0), xmm4);\n+  fld_d(Address(rsp, 0));\n+  jmp(L_2TAG_PACKET_1_0_2);\n+\n+  bind(L_2TAG_PACKET_0_0_2);\n+  jcc(Assembler::greater, L_2TAG_PACKET_2_0_2);\n+  pextrw(eax, xmm0, 3);\n+  andl(eax, 32767);\n+  pinsrw(xmm0, eax, 3);\n+  movsd(xmm1, Address(tmp, 2192));\n+  subsd(xmm1, xmm0);\n+  movsd(Address(rsp, 0), xmm1);\n+  fld_d(Address(rsp, 0));\n+  jmp(L_2TAG_PACKET_1_0_2);\n+\n+  bind(L_2TAG_PACKET_2_0_2);\n+  movl(eax, Address(rsp, 132));\n+  andl(eax, 2146435072);\n+  cmpl(eax, 2146435072);\n+  jcc(Assembler::equal, L_2TAG_PACKET_3_0_2);\n+  subl(rsp, 32);\n+  movsd(Address(rsp, 0), xmm0);\n+  lea(eax, Address(rsp, 40));\n+  movl(Address(rsp, 8), eax);\n+  movl(eax, 1);\n+  movl(Address(rsp, 12), eax);\n+  call(RuntimeAddress(CAST_FROM_FN_PTR(address, StubRoutines::dlibm_sin_cos_huge())));\n+  addl(rsp, 32);\n+  fld_d(Address(rsp, 8));\n+  jmp(L_2TAG_PACKET_1_0_2);\n+\n+  bind(L_2TAG_PACKET_3_0_2);\n+  fld_d(Address(rsp, 128));\n+  fmul_d(Address(tmp, 2208));\n+\n+  bind(L_2TAG_PACKET_1_0_2);\n+  movl(tmp, Address(rsp, 56));\n+}\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86_32_cos.cpp","additions":428,"deletions":0,"binary":false,"changes":428,"status":"added"},{"patch":"@@ -0,0 +1,330 @@\n+\/*\n+* Copyright (c) 2016, 2021, Intel Corporation. All rights reserved.\n+* Copyright (C) 2021 THL A29 Limited, a Tencent company. All rights reserved.\n+* Intel Math Library (LIBM) Source Code\n+*\n+* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+*\n+* This code is free software; you can redistribute it and\/or modify it\n+* under the terms of the GNU General Public License version 2 only, as\n+* published by the Free Software Foundation.\n+*\n+* This code is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+* FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+* version 2 for more details (a copy is included in the LICENSE file that\n+* accompanied this code).\n+*\n+* You should have received a copy of the GNU General Public License version\n+* 2 along with this work; if not, write to the Free Software Foundation,\n+* Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+*\n+* Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+* or visit www.oracle.com if you need additional information or have any\n+* questions.\n+*\n+*\/\n+\n+#include \"precompiled.hpp\"\n+#include \"asm\/assembler.hpp\"\n+#include \"asm\/assembler.inline.hpp\"\n+#include \"macroAssembler_x86.hpp\"\n+#include \"runtime\/stubRoutines.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+\/******************************************************************************\/\n+\/\/                     ALGORITHM DESCRIPTION - EXP()\n+\/\/                     ---------------------\n+\/\/\n+\/\/ Description:\n+\/\/  Let K = 64 (table size).\n+\/\/        x    x\/log(2)     n\n+\/\/       e  = 2          = 2 * T[j] * (1 + P(y))\n+\/\/  where\n+\/\/       x = m*log(2)\/K + y,    y in [-log(2)\/K..log(2)\/K]\n+\/\/       m = n*K + j,           m,n,j - signed integer, j in [-K\/2..K\/2]\n+\/\/                  j\/K\n+\/\/       values of 2   are tabulated as T[j] = T_hi[j] ( 1 + T_lo[j]).\n+\/\/\n+\/\/       P(y) is a minimax polynomial approximation of exp(x)-1\n+\/\/       on small interval [-log(2)\/K..log(2)\/K] (were calculated by Maple V).\n+\/\/\n+\/\/  To avoid problems with arithmetic overflow and underflow,\n+\/\/            n                        n1  n2\n+\/\/  value of 2  is safely computed as 2 * 2 where n1 in [-BIAS\/2..BIAS\/2]\n+\/\/  where BIAS is a value of exponent bias.\n+\/\/\n+\/\/ Special cases:\n+\/\/  exp(NaN) = NaN\n+\/\/  exp(+INF) = +INF\n+\/\/  exp(-INF) = 0\n+\/\/  exp(x) = 1 for subnormals\n+\/\/  for finite argument, only exp(0)=1 is exact\n+\/\/  For IEEE double\n+\/\/    if x >  709.782712893383973096 then exp(x) overflow\n+\/\/    if x < -745.133219101941108420 then exp(x) underflow\n+\/\/\n+\/******************************************************************************\/\n+\n+\/\/ The 32 bit code is at most SSE2 compliant\n+\n+ATTRIBUTE_ALIGNED(16) juint _static_const_table[] =\n+{\n+    0x00000000UL, 0xfff00000UL, 0x00000000UL, 0xfff00000UL, 0xffffffc0UL,\n+    0x00000000UL, 0xffffffc0UL, 0x00000000UL, 0x0000ffc0UL, 0x00000000UL,\n+    0x0000ffc0UL, 0x00000000UL, 0x00000000UL, 0x43380000UL, 0x00000000UL,\n+    0x43380000UL, 0x652b82feUL, 0x40571547UL, 0x652b82feUL, 0x40571547UL,\n+    0xfefa0000UL, 0x3f862e42UL, 0xfefa0000UL, 0x3f862e42UL, 0xbc9e3b3aUL,\n+    0x3d1cf79aUL, 0xbc9e3b3aUL, 0x3d1cf79aUL, 0xfffffffeUL, 0x3fdfffffUL,\n+    0xfffffffeUL, 0x3fdfffffUL, 0xe3289860UL, 0x3f56c15cUL, 0x555b9e25UL,\n+    0x3fa55555UL, 0xc090cf0fUL, 0x3f811115UL, 0x55548ba1UL, 0x3fc55555UL,\n+    0x00000000UL, 0x00000000UL, 0x00000000UL, 0x00000000UL, 0x0e03754dUL,\n+    0x3cad7bbfUL, 0x3e778060UL, 0x00002c9aUL, 0x3567f613UL, 0x3c8cd252UL,\n+    0xd3158574UL, 0x000059b0UL, 0x61e6c861UL, 0x3c60f74eUL, 0x18759bc8UL,\n+    0x00008745UL, 0x5d837b6cUL, 0x3c979aa6UL, 0x6cf9890fUL, 0x0000b558UL,\n+    0x702f9cd1UL, 0x3c3ebe3dUL, 0x32d3d1a2UL, 0x0000e3ecUL, 0x1e63bcd8UL,\n+    0x3ca3516eUL, 0xd0125b50UL, 0x00011301UL, 0x26f0387bUL, 0x3ca4c554UL,\n+    0xaea92ddfUL, 0x0001429aUL, 0x62523fb6UL, 0x3ca95153UL, 0x3c7d517aUL,\n+    0x000172b8UL, 0x3f1353bfUL, 0x3c8b898cUL, 0xeb6fcb75UL, 0x0001a35bUL,\n+    0x3e3a2f5fUL, 0x3c9aecf7UL, 0x3168b9aaUL, 0x0001d487UL, 0x44a6c38dUL,\n+    0x3c8a6f41UL, 0x88628cd6UL, 0x0002063bUL, 0xe3a8a894UL, 0x3c968efdUL,\n+    0x6e756238UL, 0x0002387aUL, 0x981fe7f2UL, 0x3c80472bUL, 0x65e27cddUL,\n+    0x00026b45UL, 0x6d09ab31UL, 0x3c82f7e1UL, 0xf51fdee1UL, 0x00029e9dUL,\n+    0x720c0ab3UL, 0x3c8b3782UL, 0xa6e4030bUL, 0x0002d285UL, 0x4db0abb6UL,\n+    0x3c834d75UL, 0x0a31b715UL, 0x000306feUL, 0x5dd3f84aUL, 0x3c8fdd39UL,\n+    0xb26416ffUL, 0x00033c08UL, 0xcc187d29UL, 0x3ca12f8cUL, 0x373aa9caUL,\n+    0x000371a7UL, 0x738b5e8bUL, 0x3ca7d229UL, 0x34e59ff6UL, 0x0003a7dbUL,\n+    0xa72a4c6dUL, 0x3c859f48UL, 0x4c123422UL, 0x0003dea6UL, 0x259d9205UL,\n+    0x3ca8b846UL, 0x21f72e29UL, 0x0004160aUL, 0x60c2ac12UL, 0x3c4363edUL,\n+    0x6061892dUL, 0x00044e08UL, 0xdaa10379UL, 0x3c6ecce1UL, 0xb5c13cd0UL,\n+    0x000486a2UL, 0xbb7aafb0UL, 0x3c7690ceUL, 0xd5362a27UL, 0x0004bfdaUL,\n+    0x9b282a09UL, 0x3ca083ccUL, 0x769d2ca6UL, 0x0004f9b2UL, 0xc1aae707UL,\n+    0x3ca509b0UL, 0x569d4f81UL, 0x0005342bUL, 0x18fdd78eUL, 0x3c933505UL,\n+    0x36b527daUL, 0x00056f47UL, 0xe21c5409UL, 0x3c9063e1UL, 0xdd485429UL,\n+    0x0005ab07UL, 0x2b64c035UL, 0x3c9432e6UL, 0x15ad2148UL, 0x0005e76fUL,\n+    0x99f08c0aUL, 0x3ca01284UL, 0xb03a5584UL, 0x0006247eUL, 0x0073dc06UL,\n+    0x3c99f087UL, 0x82552224UL, 0x00066238UL, 0x0da05571UL, 0x3c998d4dUL,\n+    0x667f3bccUL, 0x0006a09eUL, 0x86ce4786UL, 0x3ca52bb9UL, 0x3c651a2eUL,\n+    0x0006dfb2UL, 0x206f0dabUL, 0x3ca32092UL, 0xe8ec5f73UL, 0x00071f75UL,\n+    0x8e17a7a6UL, 0x3ca06122UL, 0x564267c8UL, 0x00075febUL, 0x461e9f86UL,\n+    0x3ca244acUL, 0x73eb0186UL, 0x0007a114UL, 0xabd66c55UL, 0x3c65ebe1UL,\n+    0x36cf4e62UL, 0x0007e2f3UL, 0xbbff67d0UL, 0x3c96fe9fUL, 0x994cce12UL,\n+    0x00082589UL, 0x14c801dfUL, 0x3c951f14UL, 0x9b4492ecUL, 0x000868d9UL,\n+    0xc1f0eab4UL, 0x3c8db72fUL, 0x422aa0dbUL, 0x0008ace5UL, 0x59f35f44UL,\n+    0x3c7bf683UL, 0x99157736UL, 0x0008f1aeUL, 0x9c06283cUL, 0x3ca360baUL,\n+    0xb0cdc5e4UL, 0x00093737UL, 0x20f962aaUL, 0x3c95e8d1UL, 0x9fde4e4fUL,\n+    0x00097d82UL, 0x2b91ce27UL, 0x3c71affcUL, 0x82a3f090UL, 0x0009c491UL,\n+    0x589a2ebdUL, 0x3c9b6d34UL, 0x7b5de564UL, 0x000a0c66UL, 0x9ab89880UL,\n+    0x3c95277cUL, 0xb23e255cUL, 0x000a5503UL, 0x6e735ab3UL, 0x3c846984UL,\n+    0x5579fdbfUL, 0x000a9e6bUL, 0x92cb3387UL, 0x3c8c1a77UL, 0x995ad3adUL,\n+    0x000ae89fUL, 0xdc2d1d96UL, 0x3ca22466UL, 0xb84f15faUL, 0x000b33a2UL,\n+    0xb19505aeUL, 0x3ca1112eUL, 0xf2fb5e46UL, 0x000b7f76UL, 0x0a5fddcdUL,\n+    0x3c74ffd7UL, 0x904bc1d2UL, 0x000bcc1eUL, 0x30af0cb3UL, 0x3c736eaeUL,\n+    0xdd85529cUL, 0x000c199bUL, 0xd10959acUL, 0x3c84e08fUL, 0x2e57d14bUL,\n+    0x000c67f1UL, 0x6c921968UL, 0x3c676b2cUL, 0xdcef9069UL, 0x000cb720UL,\n+    0x36df99b3UL, 0x3c937009UL, 0x4a07897bUL, 0x000d072dUL, 0xa63d07a7UL,\n+    0x3c74a385UL, 0xdcfba487UL, 0x000d5818UL, 0xd5c192acUL, 0x3c8e5a50UL,\n+    0x03db3285UL, 0x000da9e6UL, 0x1c4a9792UL, 0x3c98bb73UL, 0x337b9b5eUL,\n+    0x000dfc97UL, 0x603a88d3UL, 0x3c74b604UL, 0xe78b3ff6UL, 0x000e502eUL,\n+    0x92094926UL, 0x3c916f27UL, 0xa2a490d9UL, 0x000ea4afUL, 0x41aa2008UL,\n+    0x3c8ec3bcUL, 0xee615a27UL, 0x000efa1bUL, 0x31d185eeUL, 0x3c8a64a9UL,\n+    0x5b6e4540UL, 0x000f5076UL, 0x4d91cd9dUL, 0x3c77893bUL, 0x819e90d8UL,\n+    0x000fa7c1UL, 0x00000000UL, 0x3ff00000UL, 0x00000000UL, 0x7ff00000UL,\n+    0x00000000UL, 0x00000000UL, 0xffffffffUL, 0x7fefffffUL, 0x00000000UL,\n+    0x00100000UL\n+};\n+\n+\/\/registers,\n+\/\/ input: (rbp + 8)\n+\/\/ scratch: xmm1, xmm2, xmm3, xmm4, xmm5, xmm6, xmm7\n+\/\/          rax, rdx, rcx, rbx (tmp)\n+\n+\/\/ Code generated by Intel C compiler for LIBM library\n+\n+void MacroAssembler::fast_exp(XMMRegister xmm0, XMMRegister xmm1, XMMRegister xmm2, XMMRegister xmm3,\n+                              XMMRegister xmm4, XMMRegister xmm5, XMMRegister xmm6, XMMRegister xmm7,\n+                              Register eax, Register ecx, Register edx, Register tmp) {\n+  Label L_2TAG_PACKET_0_0_2, L_2TAG_PACKET_1_0_2, L_2TAG_PACKET_2_0_2, L_2TAG_PACKET_3_0_2;\n+  Label L_2TAG_PACKET_4_0_2, L_2TAG_PACKET_5_0_2, L_2TAG_PACKET_6_0_2, L_2TAG_PACKET_7_0_2;\n+  Label L_2TAG_PACKET_8_0_2, L_2TAG_PACKET_9_0_2, L_2TAG_PACKET_10_0_2, L_2TAG_PACKET_11_0_2;\n+  Label L_2TAG_PACKET_12_0_2;\n+\n+  assert_different_registers(tmp, eax, ecx, edx);\n+  address static_const_table = (address)_static_const_table;\n+\n+  subl(rsp, 120);\n+  movl(Address(rsp, 64), tmp);\n+  lea(tmp, ExternalAddress(static_const_table));\n+  movsd(xmm0, Address(rsp, 128));\n+  unpcklpd(xmm0, xmm0);\n+  movdqu(xmm1, Address(tmp, 64));          \/\/ 0x652b82feUL, 0x40571547UL, 0x652b82feUL, 0x40571547UL\n+  movdqu(xmm6, Address(tmp, 48));          \/\/ 0x00000000UL, 0x43380000UL, 0x00000000UL, 0x43380000UL\n+  movdqu(xmm2, Address(tmp, 80));          \/\/ 0xfefa0000UL, 0x3f862e42UL, 0xfefa0000UL, 0x3f862e42UL\n+  movdqu(xmm3, Address(tmp, 96));          \/\/ 0xbc9e3b3aUL, 0x3d1cf79aUL, 0xbc9e3b3aUL, 0x3d1cf79aUL\n+  pextrw(eax, xmm0, 3);\n+  andl(eax, 32767);\n+  movl(edx, 16527);\n+  subl(edx, eax);\n+  subl(eax, 15504);\n+  orl(edx, eax);\n+  cmpl(edx, INT_MIN);\n+  jcc(Assembler::aboveEqual, L_2TAG_PACKET_0_0_2);\n+  mulpd(xmm1, xmm0);\n+  addpd(xmm1, xmm6);\n+  movapd(xmm7, xmm1);\n+  subpd(xmm1, xmm6);\n+  mulpd(xmm2, xmm1);\n+  movdqu(xmm4, Address(tmp, 128));         \/\/ 0xe3289860UL, 0x3f56c15cUL, 0x555b9e25UL, 0x3fa55555UL\n+  mulpd(xmm3, xmm1);\n+  movdqu(xmm5, Address(tmp, 144));         \/\/ 0xc090cf0fUL, 0x3f811115UL, 0x55548ba1UL, 0x3fc55555UL\n+  subpd(xmm0, xmm2);\n+  movdl(eax, xmm7);\n+  movl(ecx, eax);\n+  andl(ecx, 63);\n+  shll(ecx, 4);\n+  sarl(eax, 6);\n+  movl(edx, eax);\n+  movdqu(xmm6, Address(tmp, 16));          \/\/ 0xffffffc0UL, 0x00000000UL, 0xffffffc0UL, 0x00000000UL\n+  pand(xmm7, xmm6);\n+  movdqu(xmm6, Address(tmp, 32));          \/\/ 0x0000ffc0UL, 0x00000000UL, 0x0000ffc0UL, 0x00000000UL\n+  paddq(xmm7, xmm6);\n+  psllq(xmm7, 46);\n+  subpd(xmm0, xmm3);\n+  movdqu(xmm2, Address(tmp, ecx, Address::times_1, 160));\n+  mulpd(xmm4, xmm0);\n+  movapd(xmm6, xmm0);\n+  movapd(xmm1, xmm0);\n+  mulpd(xmm6, xmm6);\n+  mulpd(xmm0, xmm6);\n+  addpd(xmm5, xmm4);\n+  mulsd(xmm0, xmm6);\n+  mulpd(xmm6, Address(tmp, 112));          \/\/ 0xfffffffeUL, 0x3fdfffffUL, 0xfffffffeUL, 0x3fdfffffUL\n+  addsd(xmm1, xmm2);\n+  unpckhpd(xmm2, xmm2);\n+  mulpd(xmm0, xmm5);\n+  addsd(xmm1, xmm0);\n+  por(xmm2, xmm7);\n+  unpckhpd(xmm0, xmm0);\n+  addsd(xmm0, xmm1);\n+  addsd(xmm0, xmm6);\n+  addl(edx, 894);\n+  cmpl(edx, 1916);\n+  jcc(Assembler::above, L_2TAG_PACKET_1_0_2);\n+  mulsd(xmm0, xmm2);\n+  addsd(xmm0, xmm2);\n+  jmp(L_2TAG_PACKET_2_0_2);\n+\n+  bind(L_2TAG_PACKET_1_0_2);\n+  fnstcw(Address(rsp, 24));\n+  movzwl(edx, Address(rsp, 24));\n+  orl(edx, 768);\n+  movw(Address(rsp, 28), edx);\n+  fldcw(Address(rsp, 28));\n+  movl(edx, eax);\n+  sarl(eax, 1);\n+  subl(edx, eax);\n+  movdqu(xmm6, Address(tmp, 0));           \/\/ 0x00000000UL, 0xfff00000UL, 0x00000000UL, 0xfff00000UL\n+  pandn(xmm6, xmm2);\n+  addl(eax, 1023);\n+  movdl(xmm3, eax);\n+  psllq(xmm3, 52);\n+  por(xmm6, xmm3);\n+  addl(edx, 1023);\n+  movdl(xmm4, edx);\n+  psllq(xmm4, 52);\n+  movsd(Address(rsp, 8), xmm0);\n+  fld_d(Address(rsp, 8));\n+  movsd(Address(rsp, 16), xmm6);\n+  fld_d(Address(rsp, 16));\n+  fmula(1);\n+  faddp(1);\n+  movsd(Address(rsp, 8), xmm4);\n+  fld_d(Address(rsp, 8));\n+  fmulp(1);\n+  fstp_d(Address(rsp, 8));\n+  movsd(xmm0, Address(rsp, 8));\n+  fldcw(Address(rsp, 24));\n+  pextrw(ecx, xmm0, 3);\n+  andl(ecx, 32752);\n+  cmpl(ecx, 32752);\n+  jcc(Assembler::aboveEqual, L_2TAG_PACKET_3_0_2);\n+  cmpl(ecx, 0);\n+  jcc(Assembler::equal, L_2TAG_PACKET_4_0_2);\n+  jmp(L_2TAG_PACKET_2_0_2);\n+  cmpl(ecx, INT_MIN);\n+  jcc(Assembler::below, L_2TAG_PACKET_3_0_2);\n+  cmpl(ecx, -1064950997);\n+  jcc(Assembler::below, L_2TAG_PACKET_2_0_2);\n+  jcc(Assembler::above, L_2TAG_PACKET_4_0_2);\n+  movl(edx, Address(rsp, 128));\n+  cmpl(edx, -17155601);\n+  jcc(Assembler::below, L_2TAG_PACKET_2_0_2);\n+  jmp(L_2TAG_PACKET_4_0_2);\n+\n+  bind(L_2TAG_PACKET_3_0_2);\n+  movl(edx, 14);\n+  jmp(L_2TAG_PACKET_5_0_2);\n+\n+  bind(L_2TAG_PACKET_4_0_2);\n+  movl(edx, 15);\n+\n+  bind(L_2TAG_PACKET_5_0_2);\n+  movsd(Address(rsp, 0), xmm0);\n+  movsd(xmm0, Address(rsp, 128));\n+  fld_d(Address(rsp, 0));\n+  jmp(L_2TAG_PACKET_6_0_2);\n+\n+  bind(L_2TAG_PACKET_7_0_2);\n+  cmpl(eax, 2146435072);\n+  jcc(Assembler::aboveEqual, L_2TAG_PACKET_8_0_2);\n+  movl(eax, Address(rsp, 132));\n+  cmpl(eax, INT_MIN);\n+  jcc(Assembler::aboveEqual, L_2TAG_PACKET_9_0_2);\n+  movsd(xmm0, Address(tmp, 1208));         \/\/ 0xffffffffUL, 0x7fefffffUL\n+  mulsd(xmm0, xmm0);\n+  movl(edx, 14);\n+  jmp(L_2TAG_PACKET_5_0_2);\n+\n+  bind(L_2TAG_PACKET_9_0_2);\n+  movsd(xmm0, Address(tmp, 1216));\n+  mulsd(xmm0, xmm0);\n+  movl(edx, 15);\n+  jmp(L_2TAG_PACKET_5_0_2);\n+\n+  bind(L_2TAG_PACKET_8_0_2);\n+  movl(edx, Address(rsp, 128));\n+  cmpl(eax, 2146435072);\n+  jcc(Assembler::above, L_2TAG_PACKET_10_0_2);\n+  cmpl(edx, 0);\n+  jcc(Assembler::notEqual, L_2TAG_PACKET_10_0_2);\n+  movl(eax, Address(rsp, 132));\n+  cmpl(eax, 2146435072);\n+  jcc(Assembler::notEqual, L_2TAG_PACKET_11_0_2);\n+  movsd(xmm0, Address(tmp, 1192));         \/\/ 0x00000000UL, 0x7ff00000UL\n+  jmp(L_2TAG_PACKET_2_0_2);\n+\n+  bind(L_2TAG_PACKET_11_0_2);\n+  movsd(xmm0, Address(tmp, 1200));         \/\/ 0x00000000UL, 0x00000000UL\n+  jmp(L_2TAG_PACKET_2_0_2);\n+\n+  bind(L_2TAG_PACKET_10_0_2);\n+  movsd(xmm0, Address(rsp, 128));\n+  addsd(xmm0, xmm0);\n+  jmp(L_2TAG_PACKET_2_0_2);\n+\n+  bind(L_2TAG_PACKET_0_0_2);\n+  movl(eax, Address(rsp, 132));\n+  andl(eax, 2147483647);\n+  cmpl(eax, 1083179008);\n+  jcc(Assembler::aboveEqual, L_2TAG_PACKET_7_0_2);\n+  movsd(xmm0, Address(rsp, 128));\n+  addsd(xmm0, Address(tmp, 1184));         \/\/ 0x00000000UL, 0x3ff00000UL\n+  jmp(L_2TAG_PACKET_2_0_2);\n+\n+  bind(L_2TAG_PACKET_2_0_2);\n+  movsd(Address(rsp, 48), xmm0);\n+  fld_d(Address(rsp, 48));\n+\n+  bind(L_2TAG_PACKET_6_0_2);\n+  movl(tmp, Address(rsp, 64));\n+}\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86_32_exp.cpp","additions":330,"deletions":0,"binary":false,"changes":330,"status":"added"},{"patch":"@@ -0,0 +1,345 @@\n+\/*\n+* Copyright (c) 2016, 2021, Intel Corporation. All rights reserved.\n+* Copyright (C) 2021 THL A29 Limited, a Tencent company. All rights reserved.\n+* Intel Math Library (LIBM) Source Code\n+*\n+* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+*\n+* This code is free software; you can redistribute it and\/or modify it\n+* under the terms of the GNU General Public License version 2 only, as\n+* published by the Free Software Foundation.\n+*\n+* This code is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+* FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+* version 2 for more details (a copy is included in the LICENSE file that\n+* accompanied this code).\n+*\n+* You should have received a copy of the GNU General Public License version\n+* 2 along with this work; if not, write to the Free Software Foundation,\n+* Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+*\n+* Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+* or visit www.oracle.com if you need additional information or have any\n+* questions.\n+*\n+*\/\n+\n+#include \"precompiled.hpp\"\n+#include \"asm\/assembler.hpp\"\n+#include \"asm\/assembler.inline.hpp\"\n+#include \"macroAssembler_x86.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+\/******************************************************************************\/\n+\/\/                     ALGORITHM DESCRIPTION - LOG()\n+\/\/                     ---------------------\n+\/\/\n+\/\/    x=2^k * mx, mx in [1,2)\n+\/\/\n+\/\/    Get B~1\/mx based on the output of rcpss instruction (B0)\n+\/\/    B = int((B0*2^7+0.5))\/2^7\n+\/\/\n+\/\/    Reduced argument: r=B*mx-1.0 (computed accurately in high and low parts)\n+\/\/\n+\/\/    Result:  k*log(2) - log(B) + p(r) if |x-1| >= small value (2^-6)  and\n+\/\/             p(r) is a degree 7 polynomial\n+\/\/             -log(B) read from data table (high, low parts)\n+\/\/             Result is formed from high and low parts\n+\/\/\n+\/\/ Special cases:\n+\/\/  log(NaN) = quiet NaN, and raise invalid exception\n+\/\/  log(+INF) = that INF\n+\/\/  log(0) = -INF with divide-by-zero exception raised\n+\/\/  log(1) = +0\n+\/\/  log(x) = NaN with invalid exception raised if x < -0, including -INF\n+\/\/\n+\/******************************************************************************\/\n+\n+\/\/ The 32 bit code is at most SSE2 compliant\n+\/\/\n+ATTRIBUTE_ALIGNED(16) juint _static_const_table_log[] =\n+{\n+    0xfefa3800UL, 0x3fe62e42UL, 0x93c76730UL, 0x3d2ef357UL, 0xaa241800UL,\n+    0x3fe5ee82UL, 0x0cda46beUL, 0x3d220238UL, 0x5c364800UL, 0x3fe5af40UL,\n+    0xac10c9fbUL, 0x3d2dfa63UL, 0x26bb8c00UL, 0x3fe5707aUL, 0xff3303ddUL,\n+    0x3d09980bUL, 0x26867800UL, 0x3fe5322eUL, 0x5d257531UL, 0x3d05ccc4UL,\n+    0x835a5000UL, 0x3fe4f45aUL, 0x6d93b8fbUL, 0xbd2e6c51UL, 0x6f970c00UL,\n+    0x3fe4b6fdUL, 0xed4c541cUL, 0x3cef7115UL, 0x27e8a400UL, 0x3fe47a15UL,\n+    0xf94d60aaUL, 0xbd22cb6aUL, 0xf2f92400UL, 0x3fe43d9fUL, 0x481051f7UL,\n+    0xbcfd984fUL, 0x2125cc00UL, 0x3fe4019cUL, 0x30f0c74cUL, 0xbd26ce79UL,\n+    0x0c36c000UL, 0x3fe3c608UL, 0x7cfe13c2UL, 0xbd02b736UL, 0x17197800UL,\n+    0x3fe38ae2UL, 0xbb5569a4UL, 0xbd218b7aUL, 0xad9d8c00UL, 0x3fe35028UL,\n+    0x9527e6acUL, 0x3d10b83fUL, 0x44340800UL, 0x3fe315daUL, 0xc5a0ed9cUL,\n+    0xbd274e93UL, 0x57b0e000UL, 0x3fe2dbf5UL, 0x07b9dc11UL, 0xbd17a6e5UL,\n+    0x6d0ec000UL, 0x3fe2a278UL, 0xe797882dUL, 0x3d206d2bUL, 0x1134dc00UL,\n+    0x3fe26962UL, 0x05226250UL, 0xbd0b61f1UL, 0xd8bebc00UL, 0x3fe230b0UL,\n+    0x6e48667bUL, 0x3d12fc06UL, 0x5fc61800UL, 0x3fe1f863UL, 0xc9fe81d3UL,\n+    0xbd2a7242UL, 0x49ae6000UL, 0x3fe1c078UL, 0xed70e667UL, 0x3cccacdeUL,\n+    0x40f23c00UL, 0x3fe188eeUL, 0xf8ab4650UL, 0x3d14cc4eUL, 0xf6f29800UL,\n+    0x3fe151c3UL, 0xa293ae49UL, 0xbd2edd97UL, 0x23c75c00UL, 0x3fe11af8UL,\n+    0xbb9ddcb2UL, 0xbd258647UL, 0x8611cc00UL, 0x3fe0e489UL, 0x07801742UL,\n+    0x3d1c2998UL, 0xe2d05400UL, 0x3fe0ae76UL, 0x887e7e27UL, 0x3d1f486bUL,\n+    0x0533c400UL, 0x3fe078bfUL, 0x41edf5fdUL, 0x3d268122UL, 0xbe760400UL,\n+    0x3fe04360UL, 0xe79539e0UL, 0xbd04c45fUL, 0xe5b20800UL, 0x3fe00e5aUL,\n+    0xb1727b1cUL, 0xbd053ba3UL, 0xaf7a4800UL, 0x3fdfb358UL, 0x3c164935UL,\n+    0x3d0085faUL, 0xee031800UL, 0x3fdf4aa7UL, 0x6f014a8bUL, 0x3d12cde5UL,\n+    0x56b41000UL, 0x3fdee2a1UL, 0x5a470251UL, 0x3d2f27f4UL, 0xc3ddb000UL,\n+    0x3fde7b42UL, 0x5372bd08UL, 0xbd246550UL, 0x1a272800UL, 0x3fde148aUL,\n+    0x07322938UL, 0xbd1326b2UL, 0x484c9800UL, 0x3fddae75UL, 0x60dc616aUL,\n+    0xbd1ea42dUL, 0x46def800UL, 0x3fdd4902UL, 0xe9a767a8UL, 0x3d235bafUL,\n+    0x18064800UL, 0x3fdce42fUL, 0x3ec7a6b0UL, 0xbd0797c3UL, 0xc7455800UL,\n+    0x3fdc7ff9UL, 0xc15249aeUL, 0xbd29b6ddUL, 0x693fa000UL, 0x3fdc1c60UL,\n+    0x7fe8e180UL, 0x3d2cec80UL, 0x1b80e000UL, 0x3fdbb961UL, 0xf40a666dUL,\n+    0x3d27d85bUL, 0x04462800UL, 0x3fdb56faUL, 0x2d841995UL, 0x3d109525UL,\n+    0x5248d000UL, 0x3fdaf529UL, 0x52774458UL, 0xbd217cc5UL, 0x3c8ad800UL,\n+    0x3fda93edUL, 0xbea77a5dUL, 0x3d1e36f2UL, 0x0224f800UL, 0x3fda3344UL,\n+    0x7f9d79f5UL, 0x3d23c645UL, 0xea15f000UL, 0x3fd9d32bUL, 0x10d0c0b0UL,\n+    0xbd26279eUL, 0x43135800UL, 0x3fd973a3UL, 0xa502d9f0UL, 0xbd152313UL,\n+    0x635bf800UL, 0x3fd914a8UL, 0x2ee6307dUL, 0xbd1766b5UL, 0xa88b3000UL,\n+    0x3fd8b639UL, 0xe5e70470UL, 0xbd205ae1UL, 0x776dc800UL, 0x3fd85855UL,\n+    0x3333778aUL, 0x3d2fd56fUL, 0x3bd81800UL, 0x3fd7fafaUL, 0xc812566aUL,\n+    0xbd272090UL, 0x687cf800UL, 0x3fd79e26UL, 0x2efd1778UL, 0x3d29ec7dUL,\n+    0x76c67800UL, 0x3fd741d8UL, 0x49dc60b3UL, 0x3d2d8b09UL, 0xe6af1800UL,\n+    0x3fd6e60eUL, 0x7c222d87UL, 0x3d172165UL, 0x3e9c6800UL, 0x3fd68ac8UL,\n+    0x2756eba0UL, 0x3d20a0d3UL, 0x0b3ab000UL, 0x3fd63003UL, 0xe731ae00UL,\n+    0xbd2db623UL, 0xdf596000UL, 0x3fd5d5bdUL, 0x08a465dcUL, 0xbd0a0b2aUL,\n+    0x53c8d000UL, 0x3fd57bf7UL, 0xee5d40efUL, 0x3d1fadedUL, 0x0738a000UL,\n+    0x3fd522aeUL, 0x8164c759UL, 0x3d2ebe70UL, 0x9e173000UL, 0x3fd4c9e0UL,\n+    0x1b0ad8a4UL, 0xbd2e2089UL, 0xc271c800UL, 0x3fd4718dUL, 0x0967d675UL,\n+    0xbd2f27ceUL, 0x23d5e800UL, 0x3fd419b4UL, 0xec90e09dUL, 0x3d08e436UL,\n+    0x77333000UL, 0x3fd3c252UL, 0xb606bd5cUL, 0x3d183b54UL, 0x76be1000UL,\n+    0x3fd36b67UL, 0xb0f177c8UL, 0x3d116ecdUL, 0xe1d36000UL, 0x3fd314f1UL,\n+    0xd3213cb8UL, 0xbd28e27aUL, 0x7cdc9000UL, 0x3fd2bef0UL, 0x4a5004f4UL,\n+    0x3d2a9cfaUL, 0x1134d800UL, 0x3fd26962UL, 0xdf5bb3b6UL, 0x3d2c93c1UL,\n+    0x6d0eb800UL, 0x3fd21445UL, 0xba46baeaUL, 0x3d0a87deUL, 0x635a6800UL,\n+    0x3fd1bf99UL, 0x5147bdb7UL, 0x3d2ca6edUL, 0xcbacf800UL, 0x3fd16b5cUL,\n+    0xf7a51681UL, 0x3d2b9acdUL, 0x8227e800UL, 0x3fd1178eUL, 0x63a5f01cUL,\n+    0xbd2c210eUL, 0x67616000UL, 0x3fd0c42dUL, 0x163ceae9UL, 0x3d27188bUL,\n+    0x604d5800UL, 0x3fd07138UL, 0x16ed4e91UL, 0x3cf89cdbUL, 0x5626c800UL,\n+    0x3fd01eaeUL, 0x1485e94aUL, 0xbd16f08cUL, 0x6cb3b000UL, 0x3fcf991cUL,\n+    0xca0cdf30UL, 0x3d1bcbecUL, 0xe4dd0000UL, 0x3fcef5adUL, 0x65bb8e11UL,\n+    0xbcca2115UL, 0xffe71000UL, 0x3fce530eUL, 0x6041f430UL, 0x3cc21227UL,\n+    0xb0d49000UL, 0x3fcdb13dUL, 0xf715b035UL, 0xbd2aff2aUL, 0xf2656000UL,\n+    0x3fcd1037UL, 0x75b6f6e4UL, 0xbd084a7eUL, 0xc6f01000UL, 0x3fcc6ffbUL,\n+    0xc5962bd2UL, 0xbcf1ec72UL, 0x383be000UL, 0x3fcbd087UL, 0x595412b6UL,\n+    0xbd2d4bc4UL, 0x575bd000UL, 0x3fcb31d8UL, 0x4eace1aaUL, 0xbd0c358dUL,\n+    0x3c8ae000UL, 0x3fca93edUL, 0x50562169UL, 0xbd287243UL, 0x07089000UL,\n+    0x3fc9f6c4UL, 0x6865817aUL, 0x3d29904dUL, 0xdcf70000UL, 0x3fc95a5aUL,\n+    0x58a0ff6fUL, 0x3d07f228UL, 0xeb390000UL, 0x3fc8beafUL, 0xaae92cd1UL,\n+    0xbd073d54UL, 0x6551a000UL, 0x3fc823c1UL, 0x9a631e83UL, 0x3d1e0ddbUL,\n+    0x85445000UL, 0x3fc7898dUL, 0x70914305UL, 0xbd1c6610UL, 0x8b757000UL,\n+    0x3fc6f012UL, 0xe59c21e1UL, 0xbd25118dUL, 0xbe8c1000UL, 0x3fc6574eUL,\n+    0x2c3c2e78UL, 0x3d19cf8bUL, 0x6b544000UL, 0x3fc5bf40UL, 0xeb68981cUL,\n+    0xbd127023UL, 0xe4a1b000UL, 0x3fc527e5UL, 0xe5697dc7UL, 0x3d2633e8UL,\n+    0x8333b000UL, 0x3fc4913dUL, 0x54fdb678UL, 0x3d258379UL, 0xa5993000UL,\n+    0x3fc3fb45UL, 0x7e6a354dUL, 0xbd2cd1d8UL, 0xb0159000UL, 0x3fc365fcUL,\n+    0x234b7289UL, 0x3cc62fa8UL, 0x0c868000UL, 0x3fc2d161UL, 0xcb81b4a1UL,\n+    0x3d039d6cUL, 0x2a49c000UL, 0x3fc23d71UL, 0x8fd3df5cUL, 0x3d100d23UL,\n+    0x7e23f000UL, 0x3fc1aa2bUL, 0x44389934UL, 0x3d2ca78eUL, 0x8227e000UL,\n+    0x3fc1178eUL, 0xce2d07f2UL, 0x3d21ef78UL, 0xb59e4000UL, 0x3fc08598UL,\n+    0x7009902cUL, 0xbd27e5ddUL, 0x39dbe000UL, 0x3fbfe891UL, 0x4fa10afdUL,\n+    0xbd2534d6UL, 0x830a2000UL, 0x3fbec739UL, 0xafe645e0UL, 0xbd2dc068UL,\n+    0x63844000UL, 0x3fbda727UL, 0x1fa71733UL, 0x3d1a8940UL, 0x01bc4000UL,\n+    0x3fbc8858UL, 0xc65aacd3UL, 0x3d2646d1UL, 0x8dad6000UL, 0x3fbb6ac8UL,\n+    0x2bf768e5UL, 0xbd139080UL, 0x40b1c000UL, 0x3fba4e76UL, 0xb94407c8UL,\n+    0xbd0e42b6UL, 0x5d594000UL, 0x3fb9335eUL, 0x3abd47daUL, 0x3d23115cUL,\n+    0x2f40e000UL, 0x3fb8197eUL, 0xf96ffdf7UL, 0x3d0f80dcUL, 0x0aeac000UL,\n+    0x3fb700d3UL, 0xa99ded32UL, 0x3cec1e8dUL, 0x4d97a000UL, 0x3fb5e95aUL,\n+    0x3c5d1d1eUL, 0xbd2c6906UL, 0x5d208000UL, 0x3fb4d311UL, 0x82f4e1efUL,\n+    0xbcf53a25UL, 0xa7d1e000UL, 0x3fb3bdf5UL, 0xa5db4ed7UL, 0x3d2cc85eUL,\n+    0xa4472000UL, 0x3fb2aa04UL, 0xae9c697dUL, 0xbd20b6e8UL, 0xd1466000UL,\n+    0x3fb1973bUL, 0x560d9e9bUL, 0xbd25325dUL, 0xb59e4000UL, 0x3fb08598UL,\n+    0x7009902cUL, 0xbd17e5ddUL, 0xc006c000UL, 0x3faeea31UL, 0x4fc93b7bUL,\n+    0xbd0e113eUL, 0xcdddc000UL, 0x3faccb73UL, 0x47d82807UL, 0xbd1a68f2UL,\n+    0xd0fb0000UL, 0x3faaaef2UL, 0x353bb42eUL, 0x3d20fc1aUL, 0x149fc000UL,\n+    0x3fa894aaUL, 0xd05a267dUL, 0xbd197995UL, 0xf2d4c000UL, 0x3fa67c94UL,\n+    0xec19afa2UL, 0xbd029efbUL, 0xd42e0000UL, 0x3fa466aeUL, 0x75bdfd28UL,\n+    0xbd2c1673UL, 0x2f8d0000UL, 0x3fa252f3UL, 0xe021b67bUL, 0x3d283e9aUL,\n+    0x89e74000UL, 0x3fa0415dUL, 0x5cf1d753UL, 0x3d0111c0UL, 0xec148000UL,\n+    0x3f9c63d2UL, 0x3f9eb2f3UL, 0x3d2578c6UL, 0x28c90000UL, 0x3f984925UL,\n+    0x325a0c34UL, 0xbd2aa0baUL, 0x25980000UL, 0x3f9432a9UL, 0x928637feUL,\n+    0x3d098139UL, 0x58938000UL, 0x3f902056UL, 0x06e2f7d2UL, 0xbd23dc5bUL,\n+    0xa3890000UL, 0x3f882448UL, 0xda74f640UL, 0xbd275577UL, 0x75890000UL,\n+    0x3f801015UL, 0x999d2be8UL, 0xbd10c76bUL, 0x59580000UL, 0x3f700805UL,\n+    0xcb31c67bUL, 0x3d2166afUL, 0x00000000UL, 0x00000000UL, 0x00000000UL,\n+    0x80000000UL, 0xfefa3800UL, 0x3fa62e42UL, 0x93c76730UL, 0x3ceef357UL,\n+    0x92492492UL, 0x3fc24924UL, 0x00000000UL, 0xbfd00000UL, 0x3d6fb175UL,\n+    0xbfc5555eUL, 0x55555555UL, 0x3fd55555UL, 0x9999999aUL, 0x3fc99999UL,\n+    0x00000000UL, 0xbfe00000UL, 0x00000000UL, 0xffffe000UL, 0x00000000UL,\n+    0xffffe000UL\n+};\n+\n+\/\/registers,\n+\/\/ input: xmm0\n+\/\/ scratch: xmm1, xmm2, xmm3, xmm4, xmm5, xmm6, xmm7\n+\/\/          rax, rdx, rcx, rbx (tmp)\n+void MacroAssembler::fast_log(XMMRegister xmm0, XMMRegister xmm1, XMMRegister xmm2, XMMRegister xmm3,\n+                              XMMRegister xmm4, XMMRegister xmm5, XMMRegister xmm6, XMMRegister xmm7,\n+                              Register eax, Register ecx, Register edx, Register tmp) {\n+  Label L_2TAG_PACKET_0_0_2, L_2TAG_PACKET_1_0_2, L_2TAG_PACKET_2_0_2, L_2TAG_PACKET_3_0_2;\n+  Label L_2TAG_PACKET_4_0_2, L_2TAG_PACKET_5_0_2, L_2TAG_PACKET_6_0_2, L_2TAG_PACKET_7_0_2;\n+  Label L_2TAG_PACKET_8_0_2, L_2TAG_PACKET_9_0_2;\n+  Label L_2TAG_PACKET_10_0_2;\n+\n+  assert_different_registers(tmp, eax, ecx, edx);\n+  address static_const_table = (address)_static_const_table_log;\n+\n+  subl(rsp, 104);\n+  movl(Address(rsp, 40), tmp);\n+  lea(tmp, ExternalAddress(static_const_table));\n+  xorpd(xmm2, xmm2);\n+  movl(eax, 16368);\n+  pinsrw(xmm2, eax, 3);\n+  xorpd(xmm3, xmm3);\n+  movl(edx, 30704);\n+  pinsrw(xmm3, edx, 3);\n+  movsd(xmm0, Address(rsp, 112));\n+  movapd(xmm1, xmm0);\n+  movl(ecx, 32768);\n+  movdl(xmm4, ecx);\n+  movsd(xmm5, Address(tmp, 2128));         \/\/ 0x00000000UL, 0xffffe000UL\n+  pextrw(eax, xmm0, 3);\n+  por(xmm0, xmm2);\n+  psllq(xmm0, 5);\n+  movl(ecx, 16352);\n+  psrlq(xmm0, 34);\n+  rcpss(xmm0, xmm0);\n+  psllq(xmm1, 12);\n+  pshufd(xmm6, xmm5, 228);\n+  psrlq(xmm1, 12);\n+  subl(eax, 16);\n+  cmpl(eax, 32736);\n+  jcc(Assembler::aboveEqual, L_2TAG_PACKET_0_0_2);\n+\n+  bind(L_2TAG_PACKET_1_0_2);\n+  paddd(xmm0, xmm4);\n+  por(xmm1, xmm3);\n+  movdl(edx, xmm0);\n+  psllq(xmm0, 29);\n+  pand(xmm5, xmm1);\n+  pand(xmm0, xmm6);\n+  subsd(xmm1, xmm5);\n+  mulpd(xmm5, xmm0);\n+  andl(eax, 32752);\n+  subl(eax, ecx);\n+  cvtsi2sdl(xmm7, eax);\n+  mulsd(xmm1, xmm0);\n+  movsd(xmm6, Address(tmp, 2064));         \/\/ 0xfefa3800UL, 0x3fa62e42UL\n+  movdqu(xmm3, Address(tmp, 2080));        \/\/ 0x92492492UL, 0x3fc24924UL, 0x00000000UL, 0xbfd00000UL\n+  subsd(xmm5, xmm2);\n+  andl(edx, 16711680);\n+  shrl(edx, 12);\n+  movdqu(xmm0, Address(tmp, edx));\n+  movdqu(xmm4, Address(tmp, 2096));        \/\/ 0x3d6fb175UL, 0xbfc5555eUL, 0x55555555UL, 0x3fd55555UL\n+  addsd(xmm1, xmm5);\n+  movdqu(xmm2, Address(tmp, 2112));        \/\/ 0x9999999aUL, 0x3fc99999UL, 0x00000000UL, 0xbfe00000UL\n+  mulsd(xmm6, xmm7);\n+  pshufd(xmm5, xmm1, 68);\n+  mulsd(xmm7, Address(tmp, 2072));         \/\/ 0x93c76730UL, 0x3ceef357UL, 0x92492492UL, 0x3fc24924UL\n+  mulsd(xmm3, xmm1);\n+  addsd(xmm0, xmm6);\n+  mulpd(xmm4, xmm5);\n+  mulpd(xmm5, xmm5);\n+  pshufd(xmm6, xmm0, 228);\n+  addsd(xmm0, xmm1);\n+  addpd(xmm4, xmm2);\n+  mulpd(xmm3, xmm5);\n+  subsd(xmm6, xmm0);\n+  mulsd(xmm4, xmm1);\n+  pshufd(xmm2, xmm0, 238);\n+  addsd(xmm1, xmm6);\n+  mulsd(xmm5, xmm5);\n+  addsd(xmm7, xmm2);\n+  addpd(xmm4, xmm3);\n+  addsd(xmm1, xmm7);\n+  mulpd(xmm4, xmm5);\n+  addsd(xmm1, xmm4);\n+  pshufd(xmm5, xmm4, 238);\n+  addsd(xmm1, xmm5);\n+  addsd(xmm0, xmm1);\n+  jmp(L_2TAG_PACKET_2_0_2);\n+\n+  bind(L_2TAG_PACKET_0_0_2);\n+  movsd(xmm0, Address(rsp, 112));\n+  movdqu(xmm1, xmm0);\n+  addl(eax, 16);\n+  cmpl(eax, 32768);\n+  jcc(Assembler::aboveEqual, L_2TAG_PACKET_3_0_2);\n+  cmpl(eax, 16);\n+  jcc(Assembler::below, L_2TAG_PACKET_4_0_2);\n+\n+  bind(L_2TAG_PACKET_5_0_2);\n+  addsd(xmm0, xmm0);\n+  jmp(L_2TAG_PACKET_2_0_2);\n+\n+  bind(L_2TAG_PACKET_6_0_2);\n+  jcc(Assembler::above, L_2TAG_PACKET_5_0_2);\n+  cmpl(edx, 0);\n+  jcc(Assembler::above, L_2TAG_PACKET_5_0_2);\n+  jmp(L_2TAG_PACKET_7_0_2);\n+\n+  bind(L_2TAG_PACKET_3_0_2);\n+  movdl(edx, xmm1);\n+  psrlq(xmm1, 32);\n+  movdl(ecx, xmm1);\n+  addl(ecx, ecx);\n+  cmpl(ecx, -2097152);\n+  jcc(Assembler::aboveEqual, L_2TAG_PACKET_6_0_2);\n+  orl(edx, ecx);\n+  cmpl(edx, 0);\n+  jcc(Assembler::equal, L_2TAG_PACKET_8_0_2);\n+\n+  bind(L_2TAG_PACKET_7_0_2);\n+  xorpd(xmm1, xmm1);\n+  xorpd(xmm0, xmm0);\n+  movl(eax, 32752);\n+  pinsrw(xmm1, eax, 3);\n+  movl(edx, 3);\n+  mulsd(xmm0, xmm1);\n+\n+  bind(L_2TAG_PACKET_9_0_2);\n+  movsd(Address(rsp, 0), xmm0);\n+  movsd(xmm0, Address(rsp, 112));\n+  fld_d(Address(rsp, 0));\n+  jmp(L_2TAG_PACKET_10_0_2);\n+\n+  bind(L_2TAG_PACKET_8_0_2);\n+  xorpd(xmm1, xmm1);\n+  xorpd(xmm0, xmm0);\n+  movl(eax, 49136);\n+  pinsrw(xmm0, eax, 3);\n+  divsd(xmm0, xmm1);\n+  movl(edx, 2);\n+  jmp(L_2TAG_PACKET_9_0_2);\n+\n+  bind(L_2TAG_PACKET_4_0_2);\n+  movdl(edx, xmm1);\n+  psrlq(xmm1, 32);\n+  movdl(ecx, xmm1);\n+  orl(edx, ecx);\n+  cmpl(edx, 0);\n+  jcc(Assembler::equal, L_2TAG_PACKET_8_0_2);\n+  xorpd(xmm1, xmm1);\n+  movl(eax, 18416);\n+  pinsrw(xmm1, eax, 3);\n+  mulsd(xmm0, xmm1);\n+  movapd(xmm1, xmm0);\n+  pextrw(eax, xmm0, 3);\n+  por(xmm0, xmm2);\n+  psllq(xmm0, 5);\n+  movl(ecx, 18416);\n+  psrlq(xmm0, 34);\n+  rcpss(xmm0, xmm0);\n+  psllq(xmm1, 12);\n+  pshufd(xmm6, xmm5, 228);\n+  psrlq(xmm1, 12);\n+  jmp(L_2TAG_PACKET_1_0_2);\n+\n+  bind(L_2TAG_PACKET_2_0_2);\n+  movsd(Address(rsp, 24), xmm0);\n+  fld_d(Address(rsp, 24));\n+\n+  bind(L_2TAG_PACKET_10_0_2);\n+  movl(tmp, Address(rsp, 40));\n+}\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86_32_log.cpp","additions":345,"deletions":0,"binary":false,"changes":345,"status":"added"},{"patch":"@@ -0,0 +1,358 @@\n+\/*\n+* Copyright (c) 2016, 2021, Intel Corporation. All rights reserved.\n+* Intel Math Library (LIBM) Source Code\n+*\n+* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+*\n+* This code is free software; you can redistribute it and\/or modify it\n+* under the terms of the GNU General Public License version 2 only, as\n+* published by the Free Software Foundation.\n+*\n+* This code is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+* FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+* version 2 for more details (a copy is included in the LICENSE file that\n+* accompanied this code).\n+*\n+* You should have received a copy of the GNU General Public License version\n+* 2 along with this work; if not, write to the Free Software Foundation,\n+* Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+*\n+* Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+* or visit www.oracle.com if you need additional information or have any\n+* questions.\n+*\n+*\/\n+\n+#include \"precompiled.hpp\"\n+#include \"asm\/assembler.hpp\"\n+#include \"asm\/assembler.inline.hpp\"\n+#include \"macroAssembler_x86.hpp\"\n+#include \"runtime\/stubRoutines.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+\/******************************************************************************\/\n+\/\/                     ALGORITHM DESCRIPTION - LOG10()\n+\/\/                     ---------------------\n+\/\/\n+\/\/    Let x=2^k * mx, mx in [1,2)\n+\/\/\n+\/\/    Get B~1\/mx based on the output of rcpss instruction (B0)\n+\/\/    B = int((B0*LH*2^7+0.5))\/2^7\n+\/\/    LH is a short approximation for log10(e)\n+\/\/\n+\/\/    Reduced argument: r=B*mx-LH (computed accurately in high and low parts)\n+\/\/\n+\/\/    Result:  k*log10(2) - log(B) + p(r)\n+\/\/             p(r) is a degree 7 polynomial\n+\/\/             -log(B) read from data table (high, low parts)\n+\/\/             Result is formed from high and low parts\n+\/\/\n+\/\/ Special cases:\n+\/\/  log10(0) = -INF with divide-by-zero exception raised\n+\/\/  log10(1) = +0\n+\/\/  log10(x) = NaN with invalid exception raised if x < -0, including -INF\n+\/\/  log10(+INF) = +INF\n+\/\/\n+\/******************************************************************************\/\n+\n+\/\/ The 32 bit code is at most SSE2 compliant\n+\n+ATTRIBUTE_ALIGNED(16) juint _static_const_table_log10[] =\n+{\n+    0x509f7800UL, 0x3fd34413UL, 0x1f12b358UL, 0x3d1fef31UL, 0x80333400UL,\n+    0x3fd32418UL, 0xc671d9d0UL, 0xbcf542bfUL, 0x51195000UL, 0x3fd30442UL,\n+    0x78a4b0c3UL, 0x3d18216aUL, 0x6fc79400UL, 0x3fd2e490UL, 0x80fa389dUL,\n+    0xbc902869UL, 0x89d04000UL, 0x3fd2c502UL, 0x75c2f564UL, 0x3d040754UL,\n+    0x4ddd1c00UL, 0x3fd2a598UL, 0xd219b2c3UL, 0xbcfa1d84UL, 0x6baa7c00UL,\n+    0x3fd28651UL, 0xfd9abec1UL, 0x3d1be6d3UL, 0x94028800UL, 0x3fd2672dUL,\n+    0xe289a455UL, 0xbd1ede5eUL, 0x78b86400UL, 0x3fd2482cUL, 0x6734d179UL,\n+    0x3d1fe79bUL, 0xcca3c800UL, 0x3fd2294dUL, 0x981a40b8UL, 0xbced34eaUL,\n+    0x439c5000UL, 0x3fd20a91UL, 0xcc392737UL, 0xbd1a9cc3UL, 0x92752c00UL,\n+    0x3fd1ebf6UL, 0x03c9afe7UL, 0x3d1e98f8UL, 0x6ef8dc00UL, 0x3fd1cd7dUL,\n+    0x71dae7f4UL, 0x3d08a86cUL, 0x8fe4dc00UL, 0x3fd1af25UL, 0xee9185a1UL,\n+    0xbcff3412UL, 0xace59400UL, 0x3fd190eeUL, 0xc2cab353UL, 0x3cf17ed9UL,\n+    0x7e925000UL, 0x3fd172d8UL, 0x6952c1b2UL, 0x3cf1521cUL, 0xbe694400UL,\n+    0x3fd154e2UL, 0xcacb79caUL, 0xbd0bdc78UL, 0x26cbac00UL, 0x3fd1370dUL,\n+    0xf71f4de1UL, 0xbd01f8beUL, 0x72fa0800UL, 0x3fd11957UL, 0x55bf910bUL,\n+    0x3c946e2bUL, 0x5f106000UL, 0x3fd0fbc1UL, 0x39e639c1UL, 0x3d14a84bUL,\n+    0xa802a800UL, 0x3fd0de4aUL, 0xd3f31d5dUL, 0xbd178385UL, 0x0b992000UL,\n+    0x3fd0c0f3UL, 0x3843106fUL, 0xbd1f602fUL, 0x486ce800UL, 0x3fd0a3baUL,\n+    0x8819497cUL, 0x3cef987aUL, 0x1de49400UL, 0x3fd086a0UL, 0x1caa0467UL,\n+    0x3d0faec7UL, 0x4c30cc00UL, 0x3fd069a4UL, 0xa4424372UL, 0xbd1618fcUL,\n+    0x94490000UL, 0x3fd04cc6UL, 0x946517d2UL, 0xbd18384bUL, 0xb7e84000UL,\n+    0x3fd03006UL, 0xe0109c37UL, 0xbd19a6acUL, 0x798a0c00UL, 0x3fd01364UL,\n+    0x5121e864UL, 0xbd164cf7UL, 0x38ce8000UL, 0x3fcfedbfUL, 0x46214d1aUL,\n+    0xbcbbc402UL, 0xc8e62000UL, 0x3fcfb4efUL, 0xdab93203UL, 0x3d1e0176UL,\n+    0x2cb02800UL, 0x3fcf7c5aUL, 0x2a2ea8e4UL, 0xbcfec86aUL, 0xeeeaa000UL,\n+    0x3fcf43fdUL, 0xc18e49a4UL, 0x3cf110a8UL, 0x9bb6e800UL, 0x3fcf0bdaUL,\n+    0x923cc9c0UL, 0xbd15ce99UL, 0xc093f000UL, 0x3fced3efUL, 0x4d4b51e9UL,\n+    0x3d1a04c7UL, 0xec58f800UL, 0x3fce9c3cUL, 0x163cad59UL, 0x3cac8260UL,\n+    0x9a907000UL, 0x3fce2d7dUL, 0x3fa93646UL, 0x3ce4a1c0UL, 0x37311000UL,\n+    0x3fcdbf99UL, 0x32abd1fdUL, 0x3d07ea9dUL, 0x6744b800UL, 0x3fcd528cUL,\n+    0x4dcbdfd4UL, 0xbd1b08e2UL, 0xe36de800UL, 0x3fcce653UL, 0x0b7b7f7fUL,\n+    0xbd1b8f03UL, 0x77506800UL, 0x3fcc7aecUL, 0xa821c9fbUL, 0x3d13c163UL,\n+    0x00ff8800UL, 0x3fcc1053UL, 0x536bca76UL, 0xbd074ee5UL, 0x70719800UL,\n+    0x3fcba684UL, 0xd7da9b6bUL, 0xbd1fbf16UL, 0xc6f8d800UL, 0x3fcb3d7dUL,\n+    0xe2220bb3UL, 0x3d1a295dUL, 0x16c15800UL, 0x3fcad53cUL, 0xe724911eUL,\n+    0xbcf55822UL, 0x82533800UL, 0x3fca6dbcUL, 0x6d982371UL, 0x3cac567cUL,\n+    0x3c19e800UL, 0x3fca06fcUL, 0x84d17d80UL, 0x3d1da204UL, 0x85ef8000UL,\n+    0x3fc9a0f8UL, 0x54466a6aUL, 0xbd002204UL, 0xb0ac2000UL, 0x3fc93baeUL,\n+    0xd601fd65UL, 0x3d18840cUL, 0x1bb9b000UL, 0x3fc8d71cUL, 0x7bf58766UL,\n+    0xbd14f897UL, 0x34aae800UL, 0x3fc8733eUL, 0x3af6ac24UL, 0xbd0f5c45UL,\n+    0x76d68000UL, 0x3fc81012UL, 0x4303e1a1UL, 0xbd1f9a80UL, 0x6af57800UL,\n+    0x3fc7ad96UL, 0x43fbcb46UL, 0x3cf4c33eUL, 0xa6c51000UL, 0x3fc74bc7UL,\n+    0x70f0eac5UL, 0xbd192e3bUL, 0xccab9800UL, 0x3fc6eaa3UL, 0xc0093dfeUL,\n+    0xbd0faf15UL, 0x8b60b800UL, 0x3fc68a28UL, 0xde78d5fdUL, 0xbc9ea4eeUL,\n+    0x9d987000UL, 0x3fc62a53UL, 0x962bea6eUL, 0xbd194084UL, 0xc9b0e800UL,\n+    0x3fc5cb22UL, 0x888dd999UL, 0x3d1fe201UL, 0xe1634800UL, 0x3fc56c93UL,\n+    0x16ada7adUL, 0x3d1b1188UL, 0xc176c000UL, 0x3fc50ea4UL, 0x4159b5b5UL,\n+    0xbcf09c08UL, 0x51766000UL, 0x3fc4b153UL, 0x84393d23UL, 0xbcf6a89cUL,\n+    0x83695000UL, 0x3fc4549dUL, 0x9f0b8bbbUL, 0x3d1c4b8cUL, 0x538d5800UL,\n+    0x3fc3f881UL, 0xf49df747UL, 0x3cf89b99UL, 0xc8138000UL, 0x3fc39cfcUL,\n+    0xd503b834UL, 0xbd13b99fUL, 0xf0df0800UL, 0x3fc3420dUL, 0xf011b386UL,\n+    0xbd05d8beUL, 0xe7466800UL, 0x3fc2e7b2UL, 0xf39c7bc2UL, 0xbd1bb94eUL,\n+    0xcdd62800UL, 0x3fc28de9UL, 0x05e6d69bUL, 0xbd10ed05UL, 0xd015d800UL,\n+    0x3fc234b0UL, 0xe29b6c9dUL, 0xbd1ff967UL, 0x224ea800UL, 0x3fc1dc06UL,\n+    0x727711fcUL, 0xbcffb30dUL, 0x01540000UL, 0x3fc183e8UL, 0x39786c5aUL,\n+    0x3cc23f57UL, 0xb24d9800UL, 0x3fc12c54UL, 0xc905a342UL, 0x3d003a1dUL,\n+    0x82835800UL, 0x3fc0d54aUL, 0x9b9920c0UL, 0x3d03b25aUL, 0xc72ac000UL,\n+    0x3fc07ec7UL, 0x46f26a24UL, 0x3cf0fa41UL, 0xdd35d800UL, 0x3fc028caUL,\n+    0x41d9d6dcUL, 0x3d034a65UL, 0x52474000UL, 0x3fbfa6a4UL, 0x44f66449UL,\n+    0x3d19cad3UL, 0x2da3d000UL, 0x3fbefcb8UL, 0x67832999UL, 0x3d18400fUL,\n+    0x32a10000UL, 0x3fbe53ceUL, 0x9c0e3b1aUL, 0xbcff62fdUL, 0x556b7000UL,\n+    0x3fbdabe3UL, 0x02976913UL, 0xbcf8243bUL, 0x97e88000UL, 0x3fbd04f4UL,\n+    0xec793797UL, 0x3d1c0578UL, 0x09647000UL, 0x3fbc5effUL, 0x05fc0565UL,\n+    0xbd1d799eUL, 0xc6426000UL, 0x3fbbb9ffUL, 0x4625f5edUL, 0x3d1f5723UL,\n+    0xf7afd000UL, 0x3fbb15f3UL, 0xdd5aae61UL, 0xbd1a7e1eUL, 0xd358b000UL,\n+    0x3fba72d8UL, 0x3314e4d3UL, 0x3d17bc91UL, 0x9b1f5000UL, 0x3fb9d0abUL,\n+    0x9a4d514bUL, 0x3cf18c9bUL, 0x9cd4e000UL, 0x3fb92f69UL, 0x7e4496abUL,\n+    0x3cf1f96dUL, 0x31f4f000UL, 0x3fb88f10UL, 0xf56479e7UL, 0x3d165818UL,\n+    0xbf628000UL, 0x3fb7ef9cUL, 0x26bf486dUL, 0xbd1113a6UL, 0xb526b000UL,\n+    0x3fb7510cUL, 0x1a1c3384UL, 0x3ca9898dUL, 0x8e31e000UL, 0x3fb6b35dUL,\n+    0xb3875361UL, 0xbd0661acUL, 0xd01de000UL, 0x3fb6168cUL, 0x2a7cacfaUL,\n+    0xbd1bdf10UL, 0x0af23000UL, 0x3fb57a98UL, 0xff868816UL, 0x3cf046d0UL,\n+    0xd8ea0000UL, 0x3fb4df7cUL, 0x1515fbe7UL, 0xbd1fd529UL, 0xde3b2000UL,\n+    0x3fb44538UL, 0x6e59a132UL, 0x3d1faeeeUL, 0xc8df9000UL, 0x3fb3abc9UL,\n+    0xf1322361UL, 0xbd198807UL, 0x505f1000UL, 0x3fb3132dUL, 0x0888e6abUL,\n+    0x3d1e5380UL, 0x359bd000UL, 0x3fb27b61UL, 0xdfbcbb22UL, 0xbcfe2724UL,\n+    0x429ee000UL, 0x3fb1e463UL, 0x6eb4c58cUL, 0xbcfe4dd6UL, 0x4a673000UL,\n+    0x3fb14e31UL, 0x4ce1ac9bUL, 0x3d1ba691UL, 0x28b96000UL, 0x3fb0b8c9UL,\n+    0x8c7813b8UL, 0xbd0b3872UL, 0xc1f08000UL, 0x3fb02428UL, 0xc2bc8c2cUL,\n+    0x3cb5ea6bUL, 0x05a1a000UL, 0x3faf209cUL, 0x72e8f18eUL, 0xbce8df84UL,\n+    0xc0b5e000UL, 0x3fadfa6dUL, 0x9fdef436UL, 0x3d087364UL, 0xaf416000UL,\n+    0x3facd5c2UL, 0x1068c3a9UL, 0x3d0827e7UL, 0xdb356000UL, 0x3fabb296UL,\n+    0x120a34d3UL, 0x3d101a9fUL, 0x5dfea000UL, 0x3faa90e6UL, 0xdaded264UL,\n+    0xbd14c392UL, 0x6034c000UL, 0x3fa970adUL, 0x1c9d06a9UL, 0xbd1b705eUL,\n+    0x194c6000UL, 0x3fa851e8UL, 0x83996ad9UL, 0xbd0117bcUL, 0xcf4ac000UL,\n+    0x3fa73492UL, 0xb1a94a62UL, 0xbca5ea42UL, 0xd67b4000UL, 0x3fa618a9UL,\n+    0x75aed8caUL, 0xbd07119bUL, 0x9126c000UL, 0x3fa4fe29UL, 0x5291d533UL,\n+    0x3d12658fUL, 0x6f4d4000UL, 0x3fa3e50eUL, 0xcd2c5cd9UL, 0x3d1d5c70UL,\n+    0xee608000UL, 0x3fa2cd54UL, 0xd1008489UL, 0x3d1a4802UL, 0x9900e000UL,\n+    0x3fa1b6f9UL, 0x54fb5598UL, 0xbd16593fUL, 0x06bb6000UL, 0x3fa0a1f9UL,\n+    0x64ef57b4UL, 0xbd17636bUL, 0xb7940000UL, 0x3f9f1c9fUL, 0xee6a4737UL,\n+    0x3cb5d479UL, 0x91aa0000UL, 0x3f9cf7f5UL, 0x3a16373cUL, 0x3d087114UL,\n+    0x156b8000UL, 0x3f9ad5edUL, 0x836c554aUL, 0x3c6900b0UL, 0xd4764000UL,\n+    0x3f98b67fUL, 0xed12f17bUL, 0xbcffc974UL, 0x77dec000UL, 0x3f9699a7UL,\n+    0x232ce7eaUL, 0x3d1e35bbUL, 0xbfbf4000UL, 0x3f947f5dUL, 0xd84ffa6eUL,\n+    0x3d0e0a49UL, 0x82c7c000UL, 0x3f92679cUL, 0x8d170e90UL, 0xbd14d9f2UL,\n+    0xadd20000UL, 0x3f90525dUL, 0x86d9f88eUL, 0x3cdeb986UL, 0x86f10000UL,\n+    0x3f8c7f36UL, 0xb9e0a517UL, 0x3ce29faaUL, 0xb75c8000UL, 0x3f885e9eUL,\n+    0x542568cbUL, 0xbd1f7bdbUL, 0x46b30000UL, 0x3f8442e8UL, 0xb954e7d9UL,\n+    0x3d1e5287UL, 0xb7e60000UL, 0x3f802c07UL, 0x22da0b17UL, 0xbd19fb27UL,\n+    0x6c8b0000UL, 0x3f7833e3UL, 0x821271efUL, 0xbd190f96UL, 0x29910000UL,\n+    0x3f701936UL, 0xbc3491a5UL, 0xbd1bcf45UL, 0x354a0000UL, 0x3f600fe3UL,\n+    0xc0ff520aUL, 0xbd19d71cUL, 0x00000000UL, 0x00000000UL, 0x00000000UL,\n+    0x00000000UL, 0x509f7800UL, 0x3f934413UL, 0x1f12b358UL, 0x3cdfef31UL,\n+    0xc1a5f12eUL, 0x40358874UL, 0x64d4ef0dUL, 0xc0089309UL, 0x385593b1UL,\n+    0xc025c917UL, 0xdc963467UL, 0x3ffc6a02UL, 0x7f9d3aa1UL, 0x4016ab9fUL,\n+    0xdc77b115UL, 0xbff27af2UL, 0xf8000000UL, 0xffffffffUL, 0x00000000UL,\n+    0xffffe000UL, 0x00000000UL, 0x3fdbc000UL, 0xbf2e4108UL, 0x3f5a7a6cUL\n+};\n+\/\/registers,\n+\/\/ input: xmm0\n+\/\/ scratch: xmm1, xmm2, xmm3, xmm4, xmm5, xmm6, xmm7\n+\/\/          rax, rdx, rcx, rbx (tmp)\n+\n+void MacroAssembler::fast_log10(XMMRegister xmm0, XMMRegister xmm1, XMMRegister xmm2, XMMRegister xmm3,\n+                                XMMRegister xmm4, XMMRegister xmm5, XMMRegister xmm6, XMMRegister xmm7,\n+                                Register eax, Register ecx, Register edx, Register tmp) {\n+\n+  Label L_2TAG_PACKET_0_0_2, L_2TAG_PACKET_1_0_2, L_2TAG_PACKET_2_0_2, L_2TAG_PACKET_3_0_2;\n+  Label L_2TAG_PACKET_4_0_2, L_2TAG_PACKET_5_0_2, L_2TAG_PACKET_6_0_2, L_2TAG_PACKET_7_0_2;\n+  Label L_2TAG_PACKET_8_0_2, L_2TAG_PACKET_9_0_2, L_2TAG_PACKET_10_0_2;\n+\n+  assert_different_registers(tmp, eax, ecx, edx);\n+\n+  address static_const_table_log10 = (address)_static_const_table_log10;\n+\n+  subl(rsp, 104);\n+  movl(Address(rsp, 40), tmp);\n+  lea(tmp, ExternalAddress(static_const_table_log10));\n+  xorpd(xmm2, xmm2);\n+  movl(eax, 16368);\n+  pinsrw(xmm2, eax, 3);\n+  movl(ecx, 1054736384);\n+  movdl(xmm7, ecx);\n+  xorpd(xmm3, xmm3);\n+  movl(edx, 30704);\n+  pinsrw(xmm3, edx, 3);\n+  movsd(xmm0, Address(rsp, 112));\n+  movdqu(xmm1, xmm0);\n+  movl(edx, 32768);\n+  movdl(xmm4, edx);\n+  movdqu(xmm5, Address(tmp, 2128));    \/\/0x3ffc6a02UL, 0x7f9d3aa1UL, 0x4016ab9fUL, 0xdc77b115UL\n+  pextrw(eax, xmm0, 3);\n+  por(xmm0, xmm2);\n+  movl(ecx, 16352);\n+  psllq(xmm0, 5);\n+  movsd(xmm2, Address(tmp, 2144));    \/\/0xbff27af2UL, 0xf8000000UL, 0xffffffffUL, 0x00000000UL\n+  psrlq(xmm0, 34);\n+  rcpss(xmm0, xmm0);\n+  psllq(xmm1, 12);\n+  pshufd(xmm6, xmm5, 78);\n+  psrlq(xmm1, 12);\n+  subl(eax, 16);\n+  cmpl(eax, 32736);\n+  jcc(Assembler::aboveEqual, L_2TAG_PACKET_0_0_2);\n+\n+  bind(L_2TAG_PACKET_1_0_2);\n+  mulss(xmm0, xmm7);\n+  por(xmm1, xmm3);\n+  andpd(xmm5, xmm1);\n+  paddd(xmm0, xmm4);\n+  subsd(xmm1, xmm5);\n+  movdl(edx, xmm0);\n+  psllq(xmm0, 29);\n+  andpd(xmm0, xmm6);\n+  andl(eax, 32752);\n+  subl(eax, ecx);\n+  cvtsi2sdl(xmm7, eax);\n+  mulpd(xmm5, xmm0);\n+  mulsd(xmm1, xmm0);\n+  movsd(xmm6, Address(tmp, 2064));    \/\/0xbd19d71cUL, 0x00000000UL, 0x00000000UL, 0x00000000UL\n+  movdqu(xmm3, Address(tmp, 2080));    \/\/0x00000000UL, 0x509f7800UL, 0x3f934413UL, 0x1f12b358UL\n+  subsd(xmm5, xmm2);\n+  andl(edx, 16711680);\n+  shrl(edx, 12);\n+  movdqu(xmm0, Address(tmp, edx, Address::times_1, -1504));\n+  movdqu(xmm4, Address(tmp, 2096));    \/\/0x3cdfef31UL, 0xc1a5f12eUL, 0x40358874UL, 0x64d4ef0dUL\n+  addsd(xmm1, xmm5);\n+  movdqu(xmm2, Address(tmp, 2112));    \/\/0xc0089309UL, 0x385593b1UL, 0xc025c917UL, 0xdc963467UL\n+  mulsd(xmm6, xmm7);\n+  pshufd(xmm5, xmm1, 68);\n+  mulsd(xmm7, Address(tmp, 2072));    \/\/0x00000000UL, 0x00000000UL, 0x00000000UL, 0x509f7800UL\n+  mulsd(xmm3, xmm1);\n+  addsd(xmm0, xmm6);\n+  mulpd(xmm4, xmm5);\n+  movsd(xmm6, Address(tmp, 2152));    \/\/0xffffffffUL, 0x00000000UL, 0xffffe000UL, 0x00000000UL\n+  mulpd(xmm5, xmm5);\n+  addpd(xmm4, xmm2);\n+  mulpd(xmm3, xmm5);\n+  pshufd(xmm2, xmm0, 228);\n+  addsd(xmm0, xmm1);\n+  mulsd(xmm4, xmm1);\n+  subsd(xmm2, xmm0);\n+  mulsd(xmm6, xmm1);\n+  addsd(xmm1, xmm2);\n+  pshufd(xmm2, xmm0, 238);\n+  mulsd(xmm5, xmm5);\n+  addsd(xmm7, xmm2);\n+  addsd(xmm1, xmm6);\n+  addpd(xmm4, xmm3);\n+  addsd(xmm1, xmm7);\n+  mulpd(xmm4, xmm5);\n+  addsd(xmm1, xmm4);\n+  pshufd(xmm5, xmm4, 238);\n+  addsd(xmm1, xmm5);\n+  addsd(xmm0, xmm1);\n+  jmp(L_2TAG_PACKET_2_0_2);\n+\n+  bind(L_2TAG_PACKET_0_0_2);\n+  movsd(xmm0, Address(rsp, 112));    \/\/0xbcfa1d84UL, 0x6baa7c00UL, 0x3fd28651UL, 0xfd9abec1UL\n+  movdqu(xmm1, xmm0);\n+  addl(eax, 16);\n+  cmpl(eax, 32768);\n+  jcc(Assembler::aboveEqual, L_2TAG_PACKET_3_0_2);\n+  cmpl(eax, 16);\n+  jcc(Assembler::below, L_2TAG_PACKET_4_0_2);\n+\n+  bind(L_2TAG_PACKET_5_0_2);\n+  addsd(xmm0, xmm0);\n+  jmp(L_2TAG_PACKET_2_0_2);\n+\n+  bind(L_2TAG_PACKET_6_0_2);\n+  jcc(Assembler::above, L_2TAG_PACKET_5_0_2);\n+  cmpl(edx, 0);\n+  jcc(Assembler::above, L_2TAG_PACKET_5_0_2);\n+  jmp(L_2TAG_PACKET_7_0_2);\n+\n+  bind(L_2TAG_PACKET_3_0_2);\n+  movdl(edx, xmm1);\n+  psrlq(xmm1, 32);\n+  movdl(ecx, xmm1);\n+  addl(ecx, ecx);\n+  cmpl(ecx, -2097152);\n+  jcc(Assembler::aboveEqual, L_2TAG_PACKET_6_0_2);\n+  orl(edx, ecx);\n+  cmpl(edx, 0);\n+  jcc(Assembler::equal, L_2TAG_PACKET_8_0_2);\n+\n+  bind(L_2TAG_PACKET_7_0_2);\n+  xorpd(xmm1, xmm1);\n+  xorpd(xmm0, xmm0);\n+  movl(eax, 32752);\n+  pinsrw(xmm1, eax, 3);\n+  movl(edx, 9);\n+  mulsd(xmm0, xmm1);\n+\n+  bind(L_2TAG_PACKET_9_0_2);\n+  movsd(Address(rsp, 0), xmm0);\n+  movsd(xmm0, Address(rsp, 112));    \/\/0xbcfa1d84UL, 0x6baa7c00UL, 0x3fd28651UL, 0xfd9abec1UL\n+  fld_d(Address(rsp, 0));\n+  jmp(L_2TAG_PACKET_10_0_2);\n+\n+  bind(L_2TAG_PACKET_8_0_2);\n+  xorpd(xmm1, xmm1);\n+  xorpd(xmm0, xmm0);\n+  movl(eax, 49136);\n+  pinsrw(xmm0, eax, 3);\n+  divsd(xmm0, xmm1);\n+  movl(edx, 8);\n+  jmp(L_2TAG_PACKET_9_0_2);\n+\n+  bind(L_2TAG_PACKET_4_0_2);\n+  movdl(edx, xmm1);\n+  psrlq(xmm1, 32);\n+  movdl(ecx, xmm1);\n+  orl(edx, ecx);\n+  cmpl(edx, 0);\n+  jcc(Assembler::equal, L_2TAG_PACKET_8_0_2);\n+  xorpd(xmm1, xmm1);\n+  movl(eax, 18416);\n+  pinsrw(xmm1, eax, 3);\n+  mulsd(xmm0, xmm1);\n+  xorpd(xmm2, xmm2);\n+  movl(eax, 16368);\n+  pinsrw(xmm2, eax, 3);\n+  movdqu(xmm1, xmm0);\n+  pextrw(eax, xmm0, 3);\n+  por(xmm0, xmm2);\n+  movl(ecx, 18416);\n+  psllq(xmm0, 5);\n+  movsd(xmm2, Address(tmp, 2144));    \/\/0xbff27af2UL, 0xf8000000UL, 0xffffffffUL, 0x00000000UL\n+  psrlq(xmm0, 34);\n+  rcpss(xmm0, xmm0);\n+  psllq(xmm1, 12);\n+  pshufd(xmm6, xmm5, 78);\n+  psrlq(xmm1, 12);\n+  jmp(L_2TAG_PACKET_1_0_2);\n+\n+  bind(L_2TAG_PACKET_2_0_2);\n+  movsd(Address(rsp, 24), xmm0);\n+  fld_d(Address(rsp, 24));\n+\n+  bind(L_2TAG_PACKET_10_0_2);\n+  movl(tmp, Address(rsp, 40));\n+\n+}\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86_32_log10.cpp","additions":358,"deletions":0,"binary":false,"changes":358,"status":"added"},{"patch":"@@ -0,0 +1,1856 @@\n+\/*\n+* Copyright (c) 2016, 2021, Intel Corporation. All rights reserved.\n+* Copyright (C) 2021 THL A29 Limited, a Tencent company. All rights reserved.\n+* Intel Math Library (LIBM) Source Code\n+*\n+* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+*\n+* This code is free software; you can redistribute it and\/or modify it\n+* under the terms of the GNU General Public License version 2 only, as\n+* published by the Free Software Foundation.\n+*\n+* This code is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+* FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+* version 2 for more details (a copy is included in the LICENSE file that\n+* accompanied this code).\n+*\n+* You should have received a copy of the GNU General Public License version\n+* 2 along with this work; if not, write to the Free Software Foundation,\n+* Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+*\n+* Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+* or visit www.oracle.com if you need additional information or have any\n+* questions.\n+*\n+*\/\n+\n+#include \"precompiled.hpp\"\n+#include \"asm\/assembler.hpp\"\n+#include \"asm\/assembler.inline.hpp\"\n+#include \"macroAssembler_x86.hpp\"\n+#include \"runtime\/stubRoutines.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+\/******************************************************************************\/\n+\/\/                     ALGORITHM DESCRIPTION  - POW()\n+\/\/                     ---------------------\n+\/\/\n+\/\/    Let x=2^k * mx, mx in [1,2)\n+\/\/\n+\/\/    log2(x) calculation:\n+\/\/\n+\/\/    Get B~1\/mx based on the output of rcpps instruction (B0)\n+\/\/    B = int((B0*LH*2^9+0.5))\/2^9\n+\/\/    LH is a short approximation for log2(e)\n+\/\/\n+\/\/    Reduced argument, scaled by LH:\n+\/\/                r=B*mx-LH (computed accurately in high and low parts)\n+\/\/\n+\/\/    log2(x) result:  k - log2(B) + p(r)\n+\/\/             p(r) is a degree 8 polynomial\n+\/\/             -log2(B) read from data table (high, low parts)\n+\/\/             log2(x) is formed from high and low parts\n+\/\/    For |x| in [1-1\/32, 1+1\/16), a slower but more accurate computation\n+\/\/    based om the same table design is performed.\n+\/\/\n+\/\/   Main path is taken if | floor(log2(|log2(|x|)|) + floor(log2|y|) | < 8,\n+\/\/   to filter out all potential OF\/UF cases.\n+\/\/   exp2(y*log2(x)) is computed using an 8-bit index table and a degree 5\n+\/\/   polynomial\n+\/\/\n+\/\/ Special cases:\n+\/\/  pow(-0,y) = -INF and raises the divide-by-zero exception for y an odd\n+\/\/  integer < 0.\n+\/\/  pow(-0,y) = +INF and raises the divide-by-zero exception for y < 0 and\n+\/\/  not an odd integer.\n+\/\/  pow(-0,y) = -0 for y an odd integer > 0.\n+\/\/  pow(-0,y) = +0 for y > 0 and not an odd integer.\n+\/\/  pow(-1,-INF) = NaN.\n+\/\/  pow(+1,y) = NaN for any y, even a NaN.\n+\/\/  pow(x,-0) = 1 for any x, even a NaN.\n+\/\/  pow(x,y) = a NaN and raises the invalid exception for finite x < 0 and\n+\/\/  finite non-integer y.\n+\/\/  pow(x,-INF) = +INF for |x|<1.\n+\/\/  pow(x,-INF) = +0 for |x|>1.\n+\/\/  pow(x,+INF) = +0 for |x|<1.\n+\/\/  pow(x,+INF) = +INF for |x|>1.\n+\/\/  pow(-INF,y) = -0 for y an odd integer < 0.\n+\/\/  pow(-INF,y) = +0 for y < 0 and not an odd integer.\n+\/\/  pow(-INF,y) = -INF for y an odd integer > 0.\n+\/\/  pow(-INF,y) = +INF for y > 0 and not an odd integer.\n+\/\/  pow(+INF,y) = +0 for y <0.\n+\/\/  pow(+INF,y) = +INF for y >0.\n+\/\/\n+\/******************************************************************************\/\n+\n+\/\/ The 32 bit code is at most SSE2 compliant\n+ATTRIBUTE_ALIGNED(16) juint _static_const_table_pow[] =\n+{\n+    0x00000000UL, 0xbfd61a00UL, 0x00000000UL, 0xbf5dabe1UL, 0xf8000000UL,\n+    0xffffffffUL, 0x00000000UL, 0xfffff800UL, 0x00000000UL, 0x3ff00000UL,\n+    0x00000000UL, 0x00000000UL, 0x20000000UL, 0x3feff00aUL, 0x96621f95UL,\n+    0x3e5b1856UL, 0xe0000000UL, 0x3fefe019UL, 0xe5916f9eUL, 0xbe325278UL,\n+    0x00000000UL, 0x3fefd02fUL, 0x859a1062UL, 0x3e595fb7UL, 0xc0000000UL,\n+    0x3fefc049UL, 0xb245f18fUL, 0xbe529c38UL, 0xe0000000UL, 0x3fefb069UL,\n+    0xad2880a7UL, 0xbe501230UL, 0x60000000UL, 0x3fefa08fUL, 0xc8e72420UL,\n+    0x3e597bd1UL, 0x80000000UL, 0x3fef90baUL, 0xc30c4500UL, 0xbe5d6c75UL,\n+    0xe0000000UL, 0x3fef80eaUL, 0x02c63f43UL, 0x3e2e1318UL, 0xc0000000UL,\n+    0x3fef7120UL, 0xb3d4ccccUL, 0xbe44c52aUL, 0x00000000UL, 0x3fef615cUL,\n+    0xdbd91397UL, 0xbe4e7d6cUL, 0xa0000000UL, 0x3fef519cUL, 0x65c5cd68UL,\n+    0xbe522dc8UL, 0xa0000000UL, 0x3fef41e2UL, 0x46d1306cUL, 0xbe5a840eUL,\n+    0xe0000000UL, 0x3fef322dUL, 0xd2980e94UL, 0x3e5071afUL, 0xa0000000UL,\n+    0x3fef227eUL, 0x773abadeUL, 0xbe5891e5UL, 0xa0000000UL, 0x3fef12d4UL,\n+    0xdc6bf46bUL, 0xbe5cccbeUL, 0xe0000000UL, 0x3fef032fUL, 0xbc7247faUL,\n+    0xbe2bab83UL, 0x80000000UL, 0x3feef390UL, 0xbcaa1e46UL, 0xbe53bb3bUL,\n+    0x60000000UL, 0x3feee3f6UL, 0x5f6c682dUL, 0xbe54c619UL, 0x80000000UL,\n+    0x3feed461UL, 0x5141e368UL, 0xbe4b6d86UL, 0xe0000000UL, 0x3feec4d1UL,\n+    0xec678f76UL, 0xbe369af6UL, 0x80000000UL, 0x3feeb547UL, 0x41301f55UL,\n+    0xbe2d4312UL, 0x60000000UL, 0x3feea5c2UL, 0x676da6bdUL, 0xbe4d8dd0UL,\n+    0x60000000UL, 0x3fee9642UL, 0x57a891c4UL, 0x3e51f991UL, 0xa0000000UL,\n+    0x3fee86c7UL, 0xe4eb491eUL, 0x3e579bf9UL, 0x20000000UL, 0x3fee7752UL,\n+    0xfddc4a2cUL, 0xbe3356e6UL, 0xc0000000UL, 0x3fee67e1UL, 0xd75b5bf1UL,\n+    0xbe449531UL, 0x80000000UL, 0x3fee5876UL, 0xbd423b8eUL, 0x3df54fe4UL,\n+    0x60000000UL, 0x3fee4910UL, 0x330e51b9UL, 0x3e54289cUL, 0x80000000UL,\n+    0x3fee39afUL, 0x8651a95fUL, 0xbe55aad6UL, 0xa0000000UL, 0x3fee2a53UL,\n+    0x5e98c708UL, 0xbe2fc4a9UL, 0xe0000000UL, 0x3fee1afcUL, 0x0989328dUL,\n+    0x3e23958cUL, 0x40000000UL, 0x3fee0babUL, 0xee642abdUL, 0xbe425dd8UL,\n+    0xa0000000UL, 0x3fedfc5eUL, 0xc394d236UL, 0x3e526362UL, 0x20000000UL,\n+    0x3feded17UL, 0xe104aa8eUL, 0x3e4ce247UL, 0xc0000000UL, 0x3fedddd4UL,\n+    0x265a9be4UL, 0xbe5bb77aUL, 0x40000000UL, 0x3fedce97UL, 0x0ecac52fUL,\n+    0x3e4a7cb1UL, 0xe0000000UL, 0x3fedbf5eUL, 0x124cb3b8UL, 0x3e257024UL,\n+    0x80000000UL, 0x3fedb02bUL, 0xe6d4febeUL, 0xbe2033eeUL, 0x20000000UL,\n+    0x3feda0fdUL, 0x39cca00eUL, 0xbe3ddabcUL, 0xc0000000UL, 0x3fed91d3UL,\n+    0xef8a552aUL, 0xbe543390UL, 0x40000000UL, 0x3fed82afUL, 0xb8e85204UL,\n+    0x3e513850UL, 0xe0000000UL, 0x3fed738fUL, 0x3d59fe08UL, 0xbe5db728UL,\n+    0x40000000UL, 0x3fed6475UL, 0x3aa7ead1UL, 0x3e58804bUL, 0xc0000000UL,\n+    0x3fed555fUL, 0xf8a35ba9UL, 0xbe5298b0UL, 0x00000000UL, 0x3fed464fUL,\n+    0x9a88dd15UL, 0x3e5a8cdbUL, 0x40000000UL, 0x3fed3743UL, 0xb0b0a190UL,\n+    0x3e598635UL, 0x80000000UL, 0x3fed283cUL, 0xe2113295UL, 0xbe5c1119UL,\n+    0x80000000UL, 0x3fed193aUL, 0xafbf1728UL, 0xbe492e9cUL, 0x60000000UL,\n+    0x3fed0a3dUL, 0xe4a4ccf3UL, 0x3e19b90eUL, 0x20000000UL, 0x3fecfb45UL,\n+    0xba3cbeb8UL, 0x3e406b50UL, 0xc0000000UL, 0x3fecec51UL, 0x110f7dddUL,\n+    0x3e0d6806UL, 0x40000000UL, 0x3fecdd63UL, 0x7dd7d508UL, 0xbe5a8943UL,\n+    0x80000000UL, 0x3fecce79UL, 0x9b60f271UL, 0xbe50676aUL, 0x80000000UL,\n+    0x3fecbf94UL, 0x0b9ad660UL, 0x3e59174fUL, 0x60000000UL, 0x3fecb0b4UL,\n+    0x00823d9cUL, 0x3e5bbf72UL, 0x20000000UL, 0x3feca1d9UL, 0x38a6ec89UL,\n+    0xbe4d38f9UL, 0x80000000UL, 0x3fec9302UL, 0x3a0b7d8eUL, 0x3e53dbfdUL,\n+    0xc0000000UL, 0x3fec8430UL, 0xc6826b34UL, 0xbe27c5c9UL, 0xc0000000UL,\n+    0x3fec7563UL, 0x0c706381UL, 0xbe593653UL, 0x60000000UL, 0x3fec669bUL,\n+    0x7df34ec7UL, 0x3e461ab5UL, 0xe0000000UL, 0x3fec57d7UL, 0x40e5e7e8UL,\n+    0xbe5c3daeUL, 0x00000000UL, 0x3fec4919UL, 0x5602770fUL, 0xbe55219dUL,\n+    0xc0000000UL, 0x3fec3a5eUL, 0xec7911ebUL, 0x3e5a5d25UL, 0x60000000UL,\n+    0x3fec2ba9UL, 0xb39ea225UL, 0xbe53c00bUL, 0x80000000UL, 0x3fec1cf8UL,\n+    0x967a212eUL, 0x3e5a8ddfUL, 0x60000000UL, 0x3fec0e4cUL, 0x580798bdUL,\n+    0x3e5f53abUL, 0x00000000UL, 0x3febffa5UL, 0xb8282df6UL, 0xbe46b874UL,\n+    0x20000000UL, 0x3febf102UL, 0xe33a6729UL, 0x3e54963fUL, 0x00000000UL,\n+    0x3febe264UL, 0x3b53e88aUL, 0xbe3adce1UL, 0x60000000UL, 0x3febd3caUL,\n+    0xc2585084UL, 0x3e5cde9fUL, 0x80000000UL, 0x3febc535UL, 0xa335c5eeUL,\n+    0xbe39fd9cUL, 0x20000000UL, 0x3febb6a5UL, 0x7325b04dUL, 0x3e42ba15UL,\n+    0x60000000UL, 0x3feba819UL, 0x1564540fUL, 0x3e3a9f35UL, 0x40000000UL,\n+    0x3feb9992UL, 0x83fff592UL, 0xbe5465ceUL, 0xa0000000UL, 0x3feb8b0fUL,\n+    0xb9da63d3UL, 0xbe4b1a0aUL, 0x80000000UL, 0x3feb7c91UL, 0x6d6f1ea4UL,\n+    0x3e557657UL, 0x00000000UL, 0x3feb6e18UL, 0x5e80a1bfUL, 0x3e4ddbb6UL,\n+    0x00000000UL, 0x3feb5fa3UL, 0x1c9eacb5UL, 0x3e592877UL, 0xa0000000UL,\n+    0x3feb5132UL, 0x6d40beb3UL, 0xbe51858cUL, 0xa0000000UL, 0x3feb42c6UL,\n+    0xd740c67bUL, 0x3e427ad2UL, 0x40000000UL, 0x3feb345fUL, 0xa3e0cceeUL,\n+    0xbe5c2fc4UL, 0x40000000UL, 0x3feb25fcUL, 0x8e752b50UL, 0xbe3da3c2UL,\n+    0xc0000000UL, 0x3feb179dUL, 0xa892e7deUL, 0x3e1fb481UL, 0xc0000000UL,\n+    0x3feb0943UL, 0x21ed71e9UL, 0xbe365206UL, 0x20000000UL, 0x3feafaeeUL,\n+    0x0e1380a3UL, 0x3e5c5b7bUL, 0x20000000UL, 0x3feaec9dUL, 0x3c3d640eUL,\n+    0xbe5dbbd0UL, 0x60000000UL, 0x3feade50UL, 0x8f97a715UL, 0x3e3a8ec5UL,\n+    0x20000000UL, 0x3fead008UL, 0x23ab2839UL, 0x3e2fe98aUL, 0x40000000UL,\n+    0x3feac1c4UL, 0xf4bbd50fUL, 0x3e54d8f6UL, 0xe0000000UL, 0x3feab384UL,\n+    0x14757c4dUL, 0xbe48774cUL, 0xc0000000UL, 0x3feaa549UL, 0x7c7b0eeaUL,\n+    0x3e5b51bbUL, 0x20000000UL, 0x3fea9713UL, 0xf56f7013UL, 0x3e386200UL,\n+    0xe0000000UL, 0x3fea88e0UL, 0xbe428ebeUL, 0xbe514af5UL, 0xe0000000UL,\n+    0x3fea7ab2UL, 0x8d0e4496UL, 0x3e4f9165UL, 0x60000000UL, 0x3fea6c89UL,\n+    0xdbacc5d5UL, 0xbe5c063bUL, 0x20000000UL, 0x3fea5e64UL, 0x3f19d970UL,\n+    0xbe5a0c8cUL, 0x20000000UL, 0x3fea5043UL, 0x09ea3e6bUL, 0x3e5065dcUL,\n+    0x80000000UL, 0x3fea4226UL, 0x78df246cUL, 0x3e5e05f6UL, 0x40000000UL,\n+    0x3fea340eUL, 0x4057d4a0UL, 0x3e431b2bUL, 0x40000000UL, 0x3fea25faUL,\n+    0x82867bb5UL, 0x3e4b76beUL, 0xa0000000UL, 0x3fea17eaUL, 0x9436f40aUL,\n+    0xbe5aad39UL, 0x20000000UL, 0x3fea09dfUL, 0x4b5253b3UL, 0x3e46380bUL,\n+    0x00000000UL, 0x3fe9fbd8UL, 0x8fc52466UL, 0xbe386f9bUL, 0x20000000UL,\n+    0x3fe9edd5UL, 0x22d3f344UL, 0xbe538347UL, 0x60000000UL, 0x3fe9dfd6UL,\n+    0x1ac33522UL, 0x3e5dbc53UL, 0x00000000UL, 0x3fe9d1dcUL, 0xeabdff1dUL,\n+    0x3e40fc0cUL, 0xe0000000UL, 0x3fe9c3e5UL, 0xafd30e73UL, 0xbe585e63UL,\n+    0xe0000000UL, 0x3fe9b5f3UL, 0xa52f226aUL, 0xbe43e8f9UL, 0x20000000UL,\n+    0x3fe9a806UL, 0xecb8698dUL, 0xbe515b36UL, 0x80000000UL, 0x3fe99a1cUL,\n+    0xf2b4e89dUL, 0x3e48b62bUL, 0x20000000UL, 0x3fe98c37UL, 0x7c9a88fbUL,\n+    0x3e44414cUL, 0x00000000UL, 0x3fe97e56UL, 0xda015741UL, 0xbe5d13baUL,\n+    0xe0000000UL, 0x3fe97078UL, 0x5fdace06UL, 0x3e51b947UL, 0x00000000UL,\n+    0x3fe962a0UL, 0x956ca094UL, 0x3e518785UL, 0x40000000UL, 0x3fe954cbUL,\n+    0x01164c1dUL, 0x3e5d5b57UL, 0xc0000000UL, 0x3fe946faUL, 0xe63b3767UL,\n+    0xbe4f84e7UL, 0x40000000UL, 0x3fe9392eUL, 0xe57cc2a9UL, 0x3e34eda3UL,\n+    0xe0000000UL, 0x3fe92b65UL, 0x8c75b544UL, 0x3e5766a0UL, 0xc0000000UL,\n+    0x3fe91da1UL, 0x37d1d087UL, 0xbe5e2ab1UL, 0x80000000UL, 0x3fe90fe1UL,\n+    0xa953dc20UL, 0x3e5fa1f3UL, 0x80000000UL, 0x3fe90225UL, 0xdbd3f369UL,\n+    0x3e47d6dbUL, 0xa0000000UL, 0x3fe8f46dUL, 0x1c9be989UL, 0xbe5e2b0aUL,\n+    0xa0000000UL, 0x3fe8e6b9UL, 0x3c93d76aUL, 0x3e5c8618UL, 0xe0000000UL,\n+    0x3fe8d909UL, 0x2182fc9aUL, 0xbe41aa9eUL, 0x20000000UL, 0x3fe8cb5eUL,\n+    0xe6b3539dUL, 0xbe530d19UL, 0x60000000UL, 0x3fe8bdb6UL, 0x49e58cc3UL,\n+    0xbe3bb374UL, 0xa0000000UL, 0x3fe8b012UL, 0xa7cfeb8fUL, 0x3e56c412UL,\n+    0x00000000UL, 0x3fe8a273UL, 0x8d52bc19UL, 0x3e1429b8UL, 0x60000000UL,\n+    0x3fe894d7UL, 0x4dc32c6cUL, 0xbe48604cUL, 0xc0000000UL, 0x3fe8873fUL,\n+    0x0c868e56UL, 0xbe564ee5UL, 0x00000000UL, 0x3fe879acUL, 0x56aee828UL,\n+    0x3e5e2fd8UL, 0x60000000UL, 0x3fe86c1cUL, 0x7ceab8ecUL, 0x3e493365UL,\n+    0xc0000000UL, 0x3fe85e90UL, 0x78d4dadcUL, 0xbe4f7f25UL, 0x00000000UL,\n+    0x3fe85109UL, 0x0ccd8280UL, 0x3e31e7a2UL, 0x40000000UL, 0x3fe84385UL,\n+    0x34ba4e15UL, 0x3e328077UL, 0x80000000UL, 0x3fe83605UL, 0xa670975aUL,\n+    0xbe53eee5UL, 0xa0000000UL, 0x3fe82889UL, 0xf61b77b2UL, 0xbe43a20aUL,\n+    0xa0000000UL, 0x3fe81b11UL, 0x13e6643bUL, 0x3e5e5fe5UL, 0xc0000000UL,\n+    0x3fe80d9dUL, 0x82cc94e8UL, 0xbe5ff1f9UL, 0xa0000000UL, 0x3fe8002dUL,\n+    0x8a0c9c5dUL, 0xbe42b0e7UL, 0x60000000UL, 0x3fe7f2c1UL, 0x22a16f01UL,\n+    0x3e5d9ea0UL, 0x20000000UL, 0x3fe7e559UL, 0xc38cd451UL, 0x3e506963UL,\n+    0xc0000000UL, 0x3fe7d7f4UL, 0x9902bc71UL, 0x3e4503d7UL, 0x40000000UL,\n+    0x3fe7ca94UL, 0xdef2a3c0UL, 0x3e3d98edUL, 0xa0000000UL, 0x3fe7bd37UL,\n+    0xed49abb0UL, 0x3e24c1ffUL, 0xe0000000UL, 0x3fe7afdeUL, 0xe3b0be70UL,\n+    0xbe40c467UL, 0x00000000UL, 0x3fe7a28aUL, 0xaf9f193cUL, 0xbe5dff6cUL,\n+    0xe0000000UL, 0x3fe79538UL, 0xb74cf6b6UL, 0xbe258ed0UL, 0xa0000000UL,\n+    0x3fe787ebUL, 0x1d9127c7UL, 0x3e345fb0UL, 0x40000000UL, 0x3fe77aa2UL,\n+    0x1028c21dUL, 0xbe4619bdUL, 0xa0000000UL, 0x3fe76d5cUL, 0x7cb0b5e4UL,\n+    0x3e40f1a2UL, 0xe0000000UL, 0x3fe7601aUL, 0x2b1bc4adUL, 0xbe32e8bbUL,\n+    0xe0000000UL, 0x3fe752dcUL, 0x6839f64eUL, 0x3e41f57bUL, 0xc0000000UL,\n+    0x3fe745a2UL, 0xc4121f7eUL, 0xbe52c40aUL, 0x60000000UL, 0x3fe7386cUL,\n+    0xd6852d72UL, 0xbe5c4e6bUL, 0xc0000000UL, 0x3fe72b39UL, 0x91d690f7UL,\n+    0xbe57f88fUL, 0xe0000000UL, 0x3fe71e0aUL, 0x627a2159UL, 0xbe4425d5UL,\n+    0xc0000000UL, 0x3fe710dfUL, 0x50a54033UL, 0x3e422b7eUL, 0x60000000UL,\n+    0x3fe703b8UL, 0x3b0b5f91UL, 0x3e5d3857UL, 0xe0000000UL, 0x3fe6f694UL,\n+    0x84d628a2UL, 0xbe51f090UL, 0x00000000UL, 0x3fe6e975UL, 0x306d8894UL,\n+    0xbe414d83UL, 0xe0000000UL, 0x3fe6dc58UL, 0x30bf24aaUL, 0xbe4650caUL,\n+    0x80000000UL, 0x3fe6cf40UL, 0xd4628d69UL, 0xbe5db007UL, 0xc0000000UL,\n+    0x3fe6c22bUL, 0xa2aae57bUL, 0xbe31d279UL, 0xc0000000UL, 0x3fe6b51aUL,\n+    0x860edf7eUL, 0xbe2d4c4aUL, 0x80000000UL, 0x3fe6a80dUL, 0xf3559341UL,\n+    0xbe5f7e98UL, 0xe0000000UL, 0x3fe69b03UL, 0xa885899eUL, 0xbe5c2011UL,\n+    0xe0000000UL, 0x3fe68dfdUL, 0x2bdc6d37UL, 0x3e224a82UL, 0xa0000000UL,\n+    0x3fe680fbUL, 0xc12ad1b9UL, 0xbe40cf56UL, 0x00000000UL, 0x3fe673fdUL,\n+    0x1bcdf659UL, 0xbdf52f2dUL, 0x00000000UL, 0x3fe66702UL, 0x5df10408UL,\n+    0x3e5663e0UL, 0xc0000000UL, 0x3fe65a0aUL, 0xa4070568UL, 0xbe40b12fUL,\n+    0x00000000UL, 0x3fe64d17UL, 0x71c54c47UL, 0x3e5f5e8bUL, 0x00000000UL,\n+    0x3fe64027UL, 0xbd4b7e83UL, 0x3e42ead6UL, 0xa0000000UL, 0x3fe6333aUL,\n+    0x61598bd2UL, 0xbe4c48d4UL, 0xc0000000UL, 0x3fe62651UL, 0x6f538d61UL,\n+    0x3e548401UL, 0xa0000000UL, 0x3fe6196cUL, 0x14344120UL, 0xbe529af6UL,\n+    0x00000000UL, 0x3fe60c8bUL, 0x5982c587UL, 0xbe3e1e4fUL, 0x00000000UL,\n+    0x3fe5ffadUL, 0xfe51d4eaUL, 0xbe4c897aUL, 0x80000000UL, 0x3fe5f2d2UL,\n+    0xfd46ebe1UL, 0x3e552e00UL, 0xa0000000UL, 0x3fe5e5fbUL, 0xa4695699UL,\n+    0x3e5ed471UL, 0x60000000UL, 0x3fe5d928UL, 0x80d118aeUL, 0x3e456b61UL,\n+    0xa0000000UL, 0x3fe5cc58UL, 0x304c330bUL, 0x3e54dc29UL, 0x80000000UL,\n+    0x3fe5bf8cUL, 0x0af2dedfUL, 0xbe3aa9bdUL, 0xe0000000UL, 0x3fe5b2c3UL,\n+    0x15fc9258UL, 0xbe479a37UL, 0xc0000000UL, 0x3fe5a5feUL, 0x9292c7eaUL,\n+    0x3e188650UL, 0x20000000UL, 0x3fe5993dUL, 0x33b4d380UL, 0x3e5d6d93UL,\n+    0x20000000UL, 0x3fe58c7fUL, 0x02fd16c7UL, 0x3e2fe961UL, 0xa0000000UL,\n+    0x3fe57fc4UL, 0x4a05edb6UL, 0xbe4d55b4UL, 0xa0000000UL, 0x3fe5730dUL,\n+    0x3d443abbUL, 0xbe5e6954UL, 0x00000000UL, 0x3fe5665aUL, 0x024acfeaUL,\n+    0x3e50e61bUL, 0x00000000UL, 0x3fe559aaUL, 0xcc9edd09UL, 0xbe325403UL,\n+    0x60000000UL, 0x3fe54cfdUL, 0x1fe26950UL, 0x3e5d500eUL, 0x60000000UL,\n+    0x3fe54054UL, 0x6c5ae164UL, 0xbe4a79b4UL, 0xc0000000UL, 0x3fe533aeUL,\n+    0x154b0287UL, 0xbe401571UL, 0xa0000000UL, 0x3fe5270cUL, 0x0673f401UL,\n+    0xbe56e56bUL, 0xe0000000UL, 0x3fe51a6dUL, 0x751b639cUL, 0x3e235269UL,\n+    0xa0000000UL, 0x3fe50dd2UL, 0x7c7b2bedUL, 0x3ddec887UL, 0xc0000000UL,\n+    0x3fe5013aUL, 0xafab4e17UL, 0x3e5e7575UL, 0x60000000UL, 0x3fe4f4a6UL,\n+    0x2e308668UL, 0x3e59aed6UL, 0x80000000UL, 0x3fe4e815UL, 0xf33e2a76UL,\n+    0xbe51f184UL, 0xe0000000UL, 0x3fe4db87UL, 0x839f3e3eUL, 0x3e57db01UL,\n+    0xc0000000UL, 0x3fe4cefdUL, 0xa9eda7bbUL, 0x3e535e0fUL, 0x00000000UL,\n+    0x3fe4c277UL, 0x2a8f66a5UL, 0x3e5ce451UL, 0xc0000000UL, 0x3fe4b5f3UL,\n+    0x05192456UL, 0xbe4e8518UL, 0xc0000000UL, 0x3fe4a973UL, 0x4aa7cd1dUL,\n+    0x3e46784aUL, 0x40000000UL, 0x3fe49cf7UL, 0x8e23025eUL, 0xbe5749f2UL,\n+    0x00000000UL, 0x3fe4907eUL, 0x18d30215UL, 0x3e360f39UL, 0x20000000UL,\n+    0x3fe48408UL, 0x63dcf2f3UL, 0x3e5e00feUL, 0xc0000000UL, 0x3fe47795UL,\n+    0x46182d09UL, 0xbe5173d9UL, 0xa0000000UL, 0x3fe46b26UL, 0x8f0e62aaUL,\n+    0xbe48f281UL, 0xe0000000UL, 0x3fe45ebaUL, 0x5775c40cUL, 0xbe56aad4UL,\n+    0x60000000UL, 0x3fe45252UL, 0x0fe25f69UL, 0x3e48bd71UL, 0x40000000UL,\n+    0x3fe445edUL, 0xe9989ec5UL, 0x3e590d97UL, 0x80000000UL, 0x3fe4398bUL,\n+    0xb3d9ffe3UL, 0x3e479dbcUL, 0x20000000UL, 0x3fe42d2dUL, 0x388e4d2eUL,\n+    0xbe5eed80UL, 0xe0000000UL, 0x3fe420d1UL, 0x6f797c18UL, 0x3e554b4cUL,\n+    0x20000000UL, 0x3fe4147aUL, 0x31048bb4UL, 0xbe5b1112UL, 0x80000000UL,\n+    0x3fe40825UL, 0x2efba4f9UL, 0x3e48ebc7UL, 0x40000000UL, 0x3fe3fbd4UL,\n+    0x50201119UL, 0x3e40b701UL, 0x40000000UL, 0x3fe3ef86UL, 0x0a4db32cUL,\n+    0x3e551de8UL, 0xa0000000UL, 0x3fe3e33bUL, 0x0c9c148bUL, 0xbe50c1f6UL,\n+    0x20000000UL, 0x3fe3d6f4UL, 0xc9129447UL, 0x3e533fa0UL, 0x00000000UL,\n+    0x3fe3cab0UL, 0xaae5b5a0UL, 0xbe22b68eUL, 0x20000000UL, 0x3fe3be6fUL,\n+    0x02305e8aUL, 0xbe54fc08UL, 0x60000000UL, 0x3fe3b231UL, 0x7f908258UL,\n+    0x3e57dc05UL, 0x00000000UL, 0x3fe3a5f7UL, 0x1a09af78UL, 0x3e08038bUL,\n+    0xe0000000UL, 0x3fe399bfUL, 0x490643c1UL, 0xbe5dbe42UL, 0xe0000000UL,\n+    0x3fe38d8bUL, 0x5e8ad724UL, 0xbe3c2b72UL, 0x20000000UL, 0x3fe3815bUL,\n+    0xc67196b6UL, 0x3e1713cfUL, 0xa0000000UL, 0x3fe3752dUL, 0x6182e429UL,\n+    0xbe3ec14cUL, 0x40000000UL, 0x3fe36903UL, 0xab6eb1aeUL, 0x3e5a2cc5UL,\n+    0x40000000UL, 0x3fe35cdcUL, 0xfe5dc064UL, 0xbe5c5878UL, 0x40000000UL,\n+    0x3fe350b8UL, 0x0ba6b9e4UL, 0x3e51619bUL, 0x80000000UL, 0x3fe34497UL,\n+    0x857761aaUL, 0x3e5fff53UL, 0x00000000UL, 0x3fe3387aUL, 0xf872d68cUL,\n+    0x3e484f4dUL, 0xa0000000UL, 0x3fe32c5fUL, 0x087e97c2UL, 0x3e52842eUL,\n+    0x80000000UL, 0x3fe32048UL, 0x73d6d0c0UL, 0xbe503edfUL, 0x80000000UL,\n+    0x3fe31434UL, 0x0c1456a1UL, 0xbe5f72adUL, 0xa0000000UL, 0x3fe30823UL,\n+    0x83a1a4d5UL, 0xbe5e65ccUL, 0xe0000000UL, 0x3fe2fc15UL, 0x855a7390UL,\n+    0xbe506438UL, 0x40000000UL, 0x3fe2f00bUL, 0xa2898287UL, 0x3e3d22a2UL,\n+    0xe0000000UL, 0x3fe2e403UL, 0x8b56f66fUL, 0xbe5aa5fdUL, 0x80000000UL,\n+    0x3fe2d7ffUL, 0x52db119aUL, 0x3e3a2e3dUL, 0x60000000UL, 0x3fe2cbfeUL,\n+    0xe2ddd4c0UL, 0xbe586469UL, 0x40000000UL, 0x3fe2c000UL, 0x6b01bf10UL,\n+    0x3e352b9dUL, 0x40000000UL, 0x3fe2b405UL, 0xb07a1cdfUL, 0x3e5c5cdaUL,\n+    0x80000000UL, 0x3fe2a80dUL, 0xc7b5f868UL, 0xbe5668b3UL, 0xc0000000UL,\n+    0x3fe29c18UL, 0x185edf62UL, 0xbe563d66UL, 0x00000000UL, 0x3fe29027UL,\n+    0xf729e1ccUL, 0x3e59a9a0UL, 0x80000000UL, 0x3fe28438UL, 0x6433c727UL,\n+    0xbe43cc89UL, 0x00000000UL, 0x3fe2784dUL, 0x41782631UL, 0xbe30750cUL,\n+    0xa0000000UL, 0x3fe26c64UL, 0x914911b7UL, 0xbe58290eUL, 0x40000000UL,\n+    0x3fe2607fUL, 0x3dcc73e1UL, 0xbe4269cdUL, 0x00000000UL, 0x3fe2549dUL,\n+    0x2751bf70UL, 0xbe5a6998UL, 0xc0000000UL, 0x3fe248bdUL, 0x4248b9fbUL,\n+    0xbe4ddb00UL, 0x80000000UL, 0x3fe23ce1UL, 0xf35cf82fUL, 0x3e561b71UL,\n+    0x60000000UL, 0x3fe23108UL, 0x8e481a2dUL, 0x3e518fb9UL, 0x60000000UL,\n+    0x3fe22532UL, 0x5ab96edcUL, 0xbe5fafc5UL, 0x40000000UL, 0x3fe2195fUL,\n+    0x80943911UL, 0xbe07f819UL, 0x40000000UL, 0x3fe20d8fUL, 0x386f2d6cUL,\n+    0xbe54ba8bUL, 0x40000000UL, 0x3fe201c2UL, 0xf29664acUL, 0xbe5eb815UL,\n+    0x20000000UL, 0x3fe1f5f8UL, 0x64f03390UL, 0x3e5e320cUL, 0x20000000UL,\n+    0x3fe1ea31UL, 0x747ff696UL, 0x3e5ef0a5UL, 0x40000000UL, 0x3fe1de6dUL,\n+    0x3e9ceb51UL, 0xbe5f8d27UL, 0x20000000UL, 0x3fe1d2acUL, 0x4ae0b55eUL,\n+    0x3e5faa21UL, 0x20000000UL, 0x3fe1c6eeUL, 0x28569a5eUL, 0x3e598a4fUL,\n+    0x20000000UL, 0x3fe1bb33UL, 0x54b33e07UL, 0x3e46130aUL, 0x20000000UL,\n+    0x3fe1af7bUL, 0x024f1078UL, 0xbe4dbf93UL, 0x00000000UL, 0x3fe1a3c6UL,\n+    0xb0783bfaUL, 0x3e419248UL, 0xe0000000UL, 0x3fe19813UL, 0x2f02b836UL,\n+    0x3e4e02b7UL, 0xc0000000UL, 0x3fe18c64UL, 0x28dec9d4UL, 0x3e09064fUL,\n+    0x80000000UL, 0x3fe180b8UL, 0x45cbf406UL, 0x3e5b1f46UL, 0x40000000UL,\n+    0x3fe1750fUL, 0x03d9964cUL, 0x3e5b0a79UL, 0x00000000UL, 0x3fe16969UL,\n+    0x8b5b882bUL, 0xbe238086UL, 0xa0000000UL, 0x3fe15dc5UL, 0x73bad6f8UL,\n+    0xbdf1fca4UL, 0x20000000UL, 0x3fe15225UL, 0x5385769cUL, 0x3e5e8d76UL,\n+    0xa0000000UL, 0x3fe14687UL, 0x1676dc6bUL, 0x3e571d08UL, 0x20000000UL,\n+    0x3fe13aedUL, 0xa8c41c7fUL, 0xbe598a25UL, 0x60000000UL, 0x3fe12f55UL,\n+    0xc4e1aaf0UL, 0x3e435277UL, 0xa0000000UL, 0x3fe123c0UL, 0x403638e1UL,\n+    0xbe21aa7cUL, 0xc0000000UL, 0x3fe1182eUL, 0x557a092bUL, 0xbdd0116bUL,\n+    0xc0000000UL, 0x3fe10c9fUL, 0x7d779f66UL, 0x3e4a61baUL, 0xc0000000UL,\n+    0x3fe10113UL, 0x2b09c645UL, 0xbe5d586eUL, 0x20000000UL, 0x3fe0ea04UL,\n+    0xea2cad46UL, 0x3e5aa97cUL, 0x20000000UL, 0x3fe0d300UL, 0x23190e54UL,\n+    0x3e50f1a7UL, 0xa0000000UL, 0x3fe0bc07UL, 0x1379a5a6UL, 0xbe51619dUL,\n+    0x60000000UL, 0x3fe0a51aUL, 0x926a3d4aUL, 0x3e5cf019UL, 0xa0000000UL,\n+    0x3fe08e38UL, 0xa8c24358UL, 0x3e35241eUL, 0x20000000UL, 0x3fe07762UL,\n+    0x24317e7aUL, 0x3e512cfaUL, 0x00000000UL, 0x3fe06097UL, 0xfd9cf274UL,\n+    0xbe55bef3UL, 0x00000000UL, 0x3fe049d7UL, 0x3689b49dUL, 0xbe36d26dUL,\n+    0x40000000UL, 0x3fe03322UL, 0xf72ef6c4UL, 0xbe54cd08UL, 0xa0000000UL,\n+    0x3fe01c78UL, 0x23702d2dUL, 0xbe5900bfUL, 0x00000000UL, 0x3fe005daUL,\n+    0x3f59c14cUL, 0x3e57d80bUL, 0x40000000UL, 0x3fdfde8dUL, 0xad67766dUL,\n+    0xbe57fad4UL, 0x40000000UL, 0x3fdfb17cUL, 0x644f4ae7UL, 0x3e1ee43bUL,\n+    0x40000000UL, 0x3fdf8481UL, 0x903234d2UL, 0x3e501a86UL, 0x40000000UL,\n+    0x3fdf579cUL, 0xafe9e509UL, 0xbe267c3eUL, 0x00000000UL, 0x3fdf2acdUL,\n+    0xb7dfda0bUL, 0xbe48149bUL, 0x40000000UL, 0x3fdefe13UL, 0x3b94305eUL,\n+    0x3e5f4ea7UL, 0x80000000UL, 0x3fded16fUL, 0x5d95da61UL, 0xbe55c198UL,\n+    0x00000000UL, 0x3fdea4e1UL, 0x406960c9UL, 0xbdd99a19UL, 0x00000000UL,\n+    0x3fde7868UL, 0xd22f3539UL, 0x3e470c78UL, 0x80000000UL, 0x3fde4c04UL,\n+    0x83eec535UL, 0xbe3e1232UL, 0x40000000UL, 0x3fde1fb6UL, 0x3dfbffcbUL,\n+    0xbe4b7d71UL, 0x40000000UL, 0x3fddf37dUL, 0x7e1be4e0UL, 0xbe5b8f8fUL,\n+    0x40000000UL, 0x3fddc759UL, 0x46dae887UL, 0xbe350458UL, 0x80000000UL,\n+    0x3fdd9b4aUL, 0xed6ecc49UL, 0xbe5f0045UL, 0x80000000UL, 0x3fdd6f50UL,\n+    0x2e9e883cUL, 0x3e2915daUL, 0x80000000UL, 0x3fdd436bUL, 0xf0bccb32UL,\n+    0x3e4a68c9UL, 0x80000000UL, 0x3fdd179bUL, 0x9bbfc779UL, 0xbe54a26aUL,\n+    0x00000000UL, 0x3fdcebe0UL, 0x7cea33abUL, 0x3e43c6b7UL, 0x40000000UL,\n+    0x3fdcc039UL, 0xe740fd06UL, 0x3e5526c2UL, 0x40000000UL, 0x3fdc94a7UL,\n+    0x9eadeb1aUL, 0xbe396d8dUL, 0xc0000000UL, 0x3fdc6929UL, 0xf0a8f95aUL,\n+    0xbe5c0ab2UL, 0x80000000UL, 0x3fdc3dc0UL, 0x6ee2693bUL, 0x3e0992e6UL,\n+    0xc0000000UL, 0x3fdc126bUL, 0x5ac6b581UL, 0xbe2834b6UL, 0x40000000UL,\n+    0x3fdbe72bUL, 0x8cc226ffUL, 0x3e3596a6UL, 0x00000000UL, 0x3fdbbbffUL,\n+    0xf92a74bbUL, 0x3e3c5813UL, 0x00000000UL, 0x3fdb90e7UL, 0x479664c0UL,\n+    0xbe50d644UL, 0x00000000UL, 0x3fdb65e3UL, 0x5004975bUL, 0xbe55258fUL,\n+    0x00000000UL, 0x3fdb3af3UL, 0xe4b23194UL, 0xbe588407UL, 0xc0000000UL,\n+    0x3fdb1016UL, 0xe65d4d0aUL, 0x3e527c26UL, 0x80000000UL, 0x3fdae54eUL,\n+    0x814fddd6UL, 0x3e5962a2UL, 0x40000000UL, 0x3fdaba9aUL, 0xe19d0913UL,\n+    0xbe562f4eUL, 0x80000000UL, 0x3fda8ff9UL, 0x43cfd006UL, 0xbe4cfdebUL,\n+    0x40000000UL, 0x3fda656cUL, 0x686f0a4eUL, 0x3e5e47a8UL, 0xc0000000UL,\n+    0x3fda3af2UL, 0x7200d410UL, 0x3e5e1199UL, 0xc0000000UL, 0x3fda108cUL,\n+    0xabd2266eUL, 0x3e5ee4d1UL, 0x40000000UL, 0x3fd9e63aUL, 0x396f8f2cUL,\n+    0x3e4dbffbUL, 0x00000000UL, 0x3fd9bbfbUL, 0xe32b25ddUL, 0x3e5c3a54UL,\n+    0x40000000UL, 0x3fd991cfUL, 0x431e4035UL, 0xbe457925UL, 0x80000000UL,\n+    0x3fd967b6UL, 0x7bed3dd3UL, 0x3e40c61dUL, 0x00000000UL, 0x3fd93db1UL,\n+    0xd7449365UL, 0x3e306419UL, 0x80000000UL, 0x3fd913beUL, 0x1746e791UL,\n+    0x3e56fcfcUL, 0x40000000UL, 0x3fd8e9dfUL, 0xf3a9028bUL, 0xbe5041b9UL,\n+    0xc0000000UL, 0x3fd8c012UL, 0x56840c50UL, 0xbe26e20aUL, 0x40000000UL,\n+    0x3fd89659UL, 0x19763102UL, 0xbe51f466UL, 0x80000000UL, 0x3fd86cb2UL,\n+    0x7032de7cUL, 0xbe4d298aUL, 0x80000000UL, 0x3fd8431eUL, 0xdeb39fabUL,\n+    0xbe4361ebUL, 0x40000000UL, 0x3fd8199dUL, 0x5d01cbe0UL, 0xbe5425b3UL,\n+    0x80000000UL, 0x3fd7f02eUL, 0x3ce99aa9UL, 0x3e146fa8UL, 0x80000000UL,\n+    0x3fd7c6d2UL, 0xd1a262b9UL, 0xbe5a1a69UL, 0xc0000000UL, 0x3fd79d88UL,\n+    0x8606c236UL, 0x3e423a08UL, 0x80000000UL, 0x3fd77451UL, 0x8fd1e1b7UL,\n+    0x3e5a6a63UL, 0xc0000000UL, 0x3fd74b2cUL, 0xe491456aUL, 0x3e42c1caUL,\n+    0x40000000UL, 0x3fd7221aUL, 0x4499a6d7UL, 0x3e36a69aUL, 0x00000000UL,\n+    0x3fd6f91aUL, 0x5237df94UL, 0xbe0f8f02UL, 0x00000000UL, 0x3fd6d02cUL,\n+    0xb6482c6eUL, 0xbe5abcf7UL, 0x00000000UL, 0x3fd6a750UL, 0x1919fd61UL,\n+    0xbe57ade2UL, 0x00000000UL, 0x3fd67e86UL, 0xaa7a994dUL, 0xbe3f3fbdUL,\n+    0x00000000UL, 0x3fd655ceUL, 0x67db014cUL, 0x3e33c550UL, 0x00000000UL,\n+    0x3fd62d28UL, 0xa82856b7UL, 0xbe1409d1UL, 0xc0000000UL, 0x3fd60493UL,\n+    0x1e6a300dUL, 0x3e55d899UL, 0x80000000UL, 0x3fd5dc11UL, 0x1222bd5cUL,\n+    0xbe35bfc0UL, 0xc0000000UL, 0x3fd5b3a0UL, 0x6e8dc2d3UL, 0x3e5d4d79UL,\n+    0x00000000UL, 0x3fd58b42UL, 0xe0e4ace6UL, 0xbe517303UL, 0x80000000UL,\n+    0x3fd562f4UL, 0xb306e0a8UL, 0x3e5edf0fUL, 0xc0000000UL, 0x3fd53ab8UL,\n+    0x6574bc54UL, 0x3e5ee859UL, 0x80000000UL, 0x3fd5128eUL, 0xea902207UL,\n+    0x3e5f6188UL, 0xc0000000UL, 0x3fd4ea75UL, 0x9f911d79UL, 0x3e511735UL,\n+    0x80000000UL, 0x3fd4c26eUL, 0xf9c77397UL, 0xbe5b1643UL, 0x40000000UL,\n+    0x3fd49a78UL, 0x15fc9258UL, 0x3e479a37UL, 0x80000000UL, 0x3fd47293UL,\n+    0xd5a04dd9UL, 0xbe426e56UL, 0xc0000000UL, 0x3fd44abfUL, 0xe04042f5UL,\n+    0x3e56f7c6UL, 0x40000000UL, 0x3fd422fdUL, 0x1d8bf2c8UL, 0x3e5d8810UL,\n+    0x00000000UL, 0x3fd3fb4cUL, 0x88a8ddeeUL, 0xbe311454UL, 0xc0000000UL,\n+    0x3fd3d3abUL, 0x3e3b5e47UL, 0xbe5d1b72UL, 0x40000000UL, 0x3fd3ac1cUL,\n+    0xc2ab5d59UL, 0x3e31b02bUL, 0xc0000000UL, 0x3fd3849dUL, 0xd4e34b9eUL,\n+    0x3e51cb2fUL, 0x40000000UL, 0x3fd35d30UL, 0x177204fbUL, 0xbe2b8cd7UL,\n+    0x80000000UL, 0x3fd335d3UL, 0xfcd38c82UL, 0xbe4356e1UL, 0x80000000UL,\n+    0x3fd30e87UL, 0x64f54accUL, 0xbe4e6224UL, 0x00000000UL, 0x3fd2e74cUL,\n+    0xaa7975d9UL, 0x3e5dc0feUL, 0x80000000UL, 0x3fd2c021UL, 0x516dab3fUL,\n+    0xbe50ffa3UL, 0x40000000UL, 0x3fd29907UL, 0x2bfb7313UL, 0x3e5674a2UL,\n+    0xc0000000UL, 0x3fd271fdUL, 0x0549fc99UL, 0x3e385d29UL, 0xc0000000UL,\n+    0x3fd24b04UL, 0x55b63073UL, 0xbe500c6dUL, 0x00000000UL, 0x3fd2241cUL,\n+    0x3f91953aUL, 0x3e389977UL, 0xc0000000UL, 0x3fd1fd43UL, 0xa1543f71UL,\n+    0xbe3487abUL, 0xc0000000UL, 0x3fd1d67bUL, 0x4ec8867cUL, 0x3df6a2dcUL,\n+    0x00000000UL, 0x3fd1afc4UL, 0x4328e3bbUL, 0x3e41d9c0UL, 0x80000000UL,\n+    0x3fd1891cUL, 0x2e1cda84UL, 0x3e3bdd87UL, 0x40000000UL, 0x3fd16285UL,\n+    0x4b5331aeUL, 0xbe53128eUL, 0x00000000UL, 0x3fd13bfeUL, 0xb9aec164UL,\n+    0xbe52ac98UL, 0xc0000000UL, 0x3fd11586UL, 0xd91e1316UL, 0xbe350630UL,\n+    0x80000000UL, 0x3fd0ef1fUL, 0x7cacc12cUL, 0x3e3f5219UL, 0x40000000UL,\n+    0x3fd0c8c8UL, 0xbce277b7UL, 0x3e3d30c0UL, 0x00000000UL, 0x3fd0a281UL,\n+    0x2a63447dUL, 0xbe541377UL, 0x80000000UL, 0x3fd07c49UL, 0xfac483b5UL,\n+    0xbe5772ecUL, 0xc0000000UL, 0x3fd05621UL, 0x36b8a570UL, 0xbe4fd4bdUL,\n+    0xc0000000UL, 0x3fd03009UL, 0xbae505f7UL, 0xbe450388UL, 0x80000000UL,\n+    0x3fd00a01UL, 0x3e35aeadUL, 0xbe5430fcUL, 0x80000000UL, 0x3fcfc811UL,\n+    0x707475acUL, 0x3e38806eUL, 0x80000000UL, 0x3fcf7c3fUL, 0xc91817fcUL,\n+    0xbe40cceaUL, 0x80000000UL, 0x3fcf308cUL, 0xae05d5e9UL, 0xbe4919b8UL,\n+    0x80000000UL, 0x3fcee4f8UL, 0xae6cc9e6UL, 0xbe530b94UL, 0x00000000UL,\n+    0x3fce9983UL, 0x1efe3e8eUL, 0x3e57747eUL, 0x00000000UL, 0x3fce4e2dUL,\n+    0xda78d9bfUL, 0xbe59a608UL, 0x00000000UL, 0x3fce02f5UL, 0x8abe2c2eUL,\n+    0x3e4a35adUL, 0x00000000UL, 0x3fcdb7dcUL, 0x1495450dUL, 0xbe0872ccUL,\n+    0x80000000UL, 0x3fcd6ce1UL, 0x86ee0ba0UL, 0xbe4f59a0UL, 0x00000000UL,\n+    0x3fcd2205UL, 0xe81ca888UL, 0x3e5402c3UL, 0x00000000UL, 0x3fccd747UL,\n+    0x3b4424b9UL, 0x3e5dfdc3UL, 0x80000000UL, 0x3fcc8ca7UL, 0xd305b56cUL,\n+    0x3e202da6UL, 0x00000000UL, 0x3fcc4226UL, 0x399a6910UL, 0xbe482a1cUL,\n+    0x80000000UL, 0x3fcbf7c2UL, 0x747f7938UL, 0xbe587372UL, 0x80000000UL,\n+    0x3fcbad7cUL, 0x6fc246a0UL, 0x3e50d83dUL, 0x00000000UL, 0x3fcb6355UL,\n+    0xee9e9be5UL, 0xbe5c35bdUL, 0x80000000UL, 0x3fcb194aUL, 0x8416c0bcUL,\n+    0x3e546d4fUL, 0x00000000UL, 0x3fcacf5eUL, 0x49f7f08fUL, 0x3e56da76UL,\n+    0x00000000UL, 0x3fca858fUL, 0x5dc30de2UL, 0x3e5f390cUL, 0x00000000UL,\n+    0x3fca3bdeUL, 0x950583b6UL, 0xbe5e4169UL, 0x80000000UL, 0x3fc9f249UL,\n+    0x33631553UL, 0x3e52aeb1UL, 0x00000000UL, 0x3fc9a8d3UL, 0xde8795a6UL,\n+    0xbe59a504UL, 0x00000000UL, 0x3fc95f79UL, 0x076bf41eUL, 0x3e5122feUL,\n+    0x80000000UL, 0x3fc9163cUL, 0x2914c8e7UL, 0x3e3dd064UL, 0x00000000UL,\n+    0x3fc8cd1dUL, 0x3a30eca3UL, 0xbe21b4aaUL, 0x80000000UL, 0x3fc8841aUL,\n+    0xb2a96650UL, 0xbe575444UL, 0x80000000UL, 0x3fc83b34UL, 0x2376c0cbUL,\n+    0xbe2a74c7UL, 0x80000000UL, 0x3fc7f26bUL, 0xd8a0b653UL, 0xbe5181b6UL,\n+    0x00000000UL, 0x3fc7a9bfUL, 0x32257882UL, 0xbe4a78b4UL, 0x00000000UL,\n+    0x3fc7612fUL, 0x1eee8bd9UL, 0xbe1bfe9dUL, 0x80000000UL, 0x3fc718bbUL,\n+    0x0c603cc4UL, 0x3e36fdc9UL, 0x80000000UL, 0x3fc6d064UL, 0x3728b8cfUL,\n+    0xbe1e542eUL, 0x80000000UL, 0x3fc68829UL, 0xc79a4067UL, 0x3e5c380fUL,\n+    0x00000000UL, 0x3fc6400bUL, 0xf69eac69UL, 0x3e550a84UL, 0x80000000UL,\n+    0x3fc5f808UL, 0xb7a780a4UL, 0x3e5d9224UL, 0x80000000UL, 0x3fc5b022UL,\n+    0xad9dfb1eUL, 0xbe55242fUL, 0x00000000UL, 0x3fc56858UL, 0x659b18beUL,\n+    0xbe4bfda3UL, 0x80000000UL, 0x3fc520a9UL, 0x66ee3631UL, 0xbe57d769UL,\n+    0x80000000UL, 0x3fc4d916UL, 0x1ec62819UL, 0x3e2427f7UL, 0x80000000UL,\n+    0x3fc4919fUL, 0xdec25369UL, 0xbe435431UL, 0x00000000UL, 0x3fc44a44UL,\n+    0xa8acfc4bUL, 0xbe3c62e8UL, 0x00000000UL, 0x3fc40304UL, 0xcf1d3eabUL,\n+    0xbdfba29fUL, 0x80000000UL, 0x3fc3bbdfUL, 0x79aba3eaUL, 0xbdf1b7c8UL,\n+    0x80000000UL, 0x3fc374d6UL, 0xb8d186daUL, 0xbe5130cfUL, 0x80000000UL,\n+    0x3fc32de8UL, 0x9d74f152UL, 0x3e2285b6UL, 0x00000000UL, 0x3fc2e716UL,\n+    0x50ae7ca9UL, 0xbe503920UL, 0x80000000UL, 0x3fc2a05eUL, 0x6caed92eUL,\n+    0xbe533924UL, 0x00000000UL, 0x3fc259c2UL, 0x9cb5034eUL, 0xbe510e31UL,\n+    0x80000000UL, 0x3fc21340UL, 0x12c4d378UL, 0xbe540b43UL, 0x80000000UL,\n+    0x3fc1ccd9UL, 0xcc418706UL, 0x3e59887aUL, 0x00000000UL, 0x3fc1868eUL,\n+    0x921f4106UL, 0xbe528e67UL, 0x80000000UL, 0x3fc1405cUL, 0x3969441eUL,\n+    0x3e5d8051UL, 0x00000000UL, 0x3fc0fa46UL, 0xd941ef5bUL, 0x3e5f9079UL,\n+    0x80000000UL, 0x3fc0b44aUL, 0x5a3e81b2UL, 0xbe567691UL, 0x00000000UL,\n+    0x3fc06e69UL, 0x9d66afe7UL, 0xbe4d43fbUL, 0x00000000UL, 0x3fc028a2UL,\n+    0x0a92a162UL, 0xbe52f394UL, 0x00000000UL, 0x3fbfc5eaUL, 0x209897e5UL,\n+    0x3e529e37UL, 0x00000000UL, 0x3fbf3ac5UL, 0x8458bd7bUL, 0x3e582831UL,\n+    0x00000000UL, 0x3fbeafd5UL, 0xb8d8b4b8UL, 0xbe486b4aUL, 0x00000000UL,\n+    0x3fbe2518UL, 0xe0a3b7b6UL, 0x3e5bafd2UL, 0x00000000UL, 0x3fbd9a90UL,\n+    0x2bf2710eUL, 0x3e383b2bUL, 0x00000000UL, 0x3fbd103cUL, 0x73eb6ab7UL,\n+    0xbe56d78dUL, 0x00000000UL, 0x3fbc861bUL, 0x32ceaff5UL, 0xbe32dc5aUL,\n+    0x00000000UL, 0x3fbbfc2eUL, 0xbee04cb7UL, 0xbe4a71a4UL, 0x00000000UL,\n+    0x3fbb7274UL, 0x35ae9577UL, 0x3e38142fUL, 0x00000000UL, 0x3fbae8eeUL,\n+    0xcbaddab4UL, 0xbe5490f0UL, 0x00000000UL, 0x3fba5f9aUL, 0x95ce1114UL,\n+    0x3e597c71UL, 0x00000000UL, 0x3fb9d67aUL, 0x6d7c0f78UL, 0x3e3abc2dUL,\n+    0x00000000UL, 0x3fb94d8dUL, 0x2841a782UL, 0xbe566cbcUL, 0x00000000UL,\n+    0x3fb8c4d2UL, 0x6ed429c6UL, 0xbe3cfff9UL, 0x00000000UL, 0x3fb83c4aUL,\n+    0xe4a49fbbUL, 0xbe552964UL, 0x00000000UL, 0x3fb7b3f4UL, 0x2193d81eUL,\n+    0xbe42fa72UL, 0x00000000UL, 0x3fb72bd0UL, 0xdd70c122UL, 0x3e527a8cUL,\n+    0x00000000UL, 0x3fb6a3dfUL, 0x03108a54UL, 0xbe450393UL, 0x00000000UL,\n+    0x3fb61c1fUL, 0x30ff7954UL, 0x3e565840UL, 0x00000000UL, 0x3fb59492UL,\n+    0xdedd460cUL, 0xbe5422b5UL, 0x00000000UL, 0x3fb50d36UL, 0x950f9f45UL,\n+    0xbe5313f6UL, 0x00000000UL, 0x3fb4860bUL, 0x582cdcb1UL, 0x3e506d39UL,\n+    0x00000000UL, 0x3fb3ff12UL, 0x7216d3a6UL, 0x3e4aa719UL, 0x00000000UL,\n+    0x3fb3784aUL, 0x57a423fdUL, 0x3e5a9b9fUL, 0x00000000UL, 0x3fb2f1b4UL,\n+    0x7a138b41UL, 0xbe50b418UL, 0x00000000UL, 0x3fb26b4eUL, 0x2fbfd7eaUL,\n+    0x3e23a53eUL, 0x00000000UL, 0x3fb1e519UL, 0x18913ccbUL, 0x3e465fc1UL,\n+    0x00000000UL, 0x3fb15f15UL, 0x7ea24e21UL, 0x3e042843UL, 0x00000000UL,\n+    0x3fb0d941UL, 0x7c6d9c77UL, 0x3e59f61eUL, 0x00000000UL, 0x3fb0539eUL,\n+    0x114efd44UL, 0x3e4ccab7UL, 0x00000000UL, 0x3faf9c56UL, 0x1777f657UL,\n+    0x3e552f65UL, 0x00000000UL, 0x3fae91d2UL, 0xc317b86aUL, 0xbe5a61e0UL,\n+    0x00000000UL, 0x3fad87acUL, 0xb7664efbUL, 0xbe41f64eUL, 0x00000000UL,\n+    0x3fac7de6UL, 0x5d3d03a9UL, 0x3e0807a0UL, 0x00000000UL, 0x3fab7480UL,\n+    0x743c38ebUL, 0xbe3726e1UL, 0x00000000UL, 0x3faa6b78UL, 0x06a253f1UL,\n+    0x3e5ad636UL, 0x00000000UL, 0x3fa962d0UL, 0xa35f541bUL, 0x3e5a187aUL,\n+    0x00000000UL, 0x3fa85a88UL, 0x4b86e446UL, 0xbe508150UL, 0x00000000UL,\n+    0x3fa7529cUL, 0x2589cacfUL, 0x3e52938aUL, 0x00000000UL, 0x3fa64b10UL,\n+    0xaf6b11f2UL, 0xbe3454cdUL, 0x00000000UL, 0x3fa543e2UL, 0x97506fefUL,\n+    0xbe5fdec5UL, 0x00000000UL, 0x3fa43d10UL, 0xe75f7dd9UL, 0xbe388dd3UL,\n+    0x00000000UL, 0x3fa3369cUL, 0xa4139632UL, 0xbdea5177UL, 0x00000000UL,\n+    0x3fa23086UL, 0x352d6f1eUL, 0xbe565ad6UL, 0x00000000UL, 0x3fa12accUL,\n+    0x77449eb7UL, 0xbe50d5c7UL, 0x00000000UL, 0x3fa0256eUL, 0x7478da78UL,\n+    0x3e404724UL, 0x00000000UL, 0x3f9e40dcUL, 0xf59cef7fUL, 0xbe539d0aUL,\n+    0x00000000UL, 0x3f9c3790UL, 0x1511d43cUL, 0x3e53c2c8UL, 0x00000000UL,\n+    0x3f9a2f00UL, 0x9b8bff3cUL, 0xbe43b3e1UL, 0x00000000UL, 0x3f982724UL,\n+    0xad1e22a5UL, 0x3e46f0bdUL, 0x00000000UL, 0x3f962000UL, 0x130d9356UL,\n+    0x3e475ba0UL, 0x00000000UL, 0x3f941994UL, 0x8f86f883UL, 0xbe513d0bUL,\n+    0x00000000UL, 0x3f9213dcUL, 0x914d0dc8UL, 0xbe534335UL, 0x00000000UL,\n+    0x3f900ed8UL, 0x2d73e5e7UL, 0xbe22ba75UL, 0x00000000UL, 0x3f8c1510UL,\n+    0xc5b7d70eUL, 0x3e599c5dUL, 0x00000000UL, 0x3f880de0UL, 0x8a27857eUL,\n+    0xbe3d28c8UL, 0x00000000UL, 0x3f840810UL, 0xda767328UL, 0x3e531b3dUL,\n+    0x00000000UL, 0x3f8003b0UL, 0x77bacaf3UL, 0xbe5f04e3UL, 0x00000000UL,\n+    0x3f780150UL, 0xdf4b0720UL, 0x3e5a8bffUL, 0x00000000UL, 0x3f6ffc40UL,\n+    0x34c48e71UL, 0xbe3fcd99UL, 0x00000000UL, 0x3f5ff6c0UL, 0x1ad218afUL,\n+    0xbe4c78a7UL, 0x00000000UL, 0x00000000UL, 0x00000000UL, 0x80000000UL,\n+    0x00000000UL, 0xfffff800UL, 0x00000000UL, 0xfffff800UL, 0x00000000UL,\n+    0x3ff72000UL, 0x161bb241UL, 0xbf5dabe1UL, 0x6dc96112UL, 0xbf836578UL,\n+    0xee241472UL, 0xbf9b0301UL, 0x9f95985aUL, 0xbfb528dbUL, 0xb3841d2aUL,\n+    0xbfd619b6UL, 0x518775e3UL, 0x3f9004f2UL, 0xac8349bbUL, 0x3fa76c9bUL,\n+    0x486ececcUL, 0x3fc4635eUL, 0x161bb241UL, 0xbf5dabe1UL, 0x9f95985aUL,\n+    0xbfb528dbUL, 0xf8b5787dUL, 0x3ef2531eUL, 0x486ececbUL, 0x3fc4635eUL,\n+    0x412055ccUL, 0xbdd61bb2UL, 0x00000000UL, 0xfffffff8UL, 0x00000000UL,\n+    0xffffffffUL, 0x00000000UL, 0x3ff00000UL, 0x00000000UL, 0x3b700000UL,\n+    0xfa5abcbfUL, 0x3ff00b1aUL, 0xa7609f71UL, 0xbc84f6b2UL, 0xa9fb3335UL,\n+    0x3ff0163dUL, 0x9ab8cdb7UL, 0x3c9b6129UL, 0x143b0281UL, 0x3ff02168UL,\n+    0x0fc54eb6UL, 0xbc82bf31UL, 0x3e778061UL, 0x3ff02c9aUL, 0x535b085dUL,\n+    0xbc719083UL, 0x2e11bbccUL, 0x3ff037d4UL, 0xeeade11aUL, 0x3c656811UL,\n+    0xe86e7f85UL, 0x3ff04315UL, 0x1977c96eUL, 0xbc90a31cUL, 0x72f654b1UL,\n+    0x3ff04e5fUL, 0x3aa0d08cUL, 0x3c84c379UL, 0xd3158574UL, 0x3ff059b0UL,\n+    0xa475b465UL, 0x3c8d73e2UL, 0x0e3c1f89UL, 0x3ff0650aUL, 0x5799c397UL,\n+    0xbc95cb7bUL, 0x29ddf6deUL, 0x3ff0706bUL, 0xe2b13c27UL, 0xbc8c91dfUL,\n+    0x2b72a836UL, 0x3ff07bd4UL, 0x54458700UL, 0x3c832334UL, 0x18759bc8UL,\n+    0x3ff08745UL, 0x4bb284ffUL, 0x3c6186beUL, 0xf66607e0UL, 0x3ff092bdUL,\n+    0x800a3fd1UL, 0xbc968063UL, 0xcac6f383UL, 0x3ff09e3eUL, 0x18316136UL,\n+    0x3c914878UL, 0x9b1f3919UL, 0x3ff0a9c7UL, 0x873d1d38UL, 0x3c85d16cUL,\n+    0x6cf9890fUL, 0x3ff0b558UL, 0x4adc610bUL, 0x3c98a62eUL, 0x45e46c85UL,\n+    0x3ff0c0f1UL, 0x06d21cefUL, 0x3c94f989UL, 0x2b7247f7UL, 0x3ff0cc92UL,\n+    0x16e24f71UL, 0x3c901edcUL, 0x23395decUL, 0x3ff0d83bUL, 0xe43f316aUL,\n+    0xbc9bc14dUL, 0x32d3d1a2UL, 0x3ff0e3ecUL, 0x27c57b52UL, 0x3c403a17UL,\n+    0x5fdfa9c5UL, 0x3ff0efa5UL, 0xbc54021bUL, 0xbc949db9UL, 0xaffed31bUL,\n+    0x3ff0fb66UL, 0xc44ebd7bUL, 0xbc6b9bedUL, 0x28d7233eUL, 0x3ff10730UL,\n+    0x1692fdd5UL, 0x3c8d46ebUL, 0xd0125b51UL, 0x3ff11301UL, 0x39449b3aUL,\n+    0xbc96c510UL, 0xab5e2ab6UL, 0x3ff11edbUL, 0xf703fb72UL, 0xbc9ca454UL,\n+    0xc06c31ccUL, 0x3ff12abdUL, 0xb36ca5c7UL, 0xbc51b514UL, 0x14f204abUL,\n+    0x3ff136a8UL, 0xba48dcf0UL, 0xbc67108fUL, 0xaea92de0UL, 0x3ff1429aUL,\n+    0x9af1369eUL, 0xbc932fbfUL, 0x934f312eUL, 0x3ff14e95UL, 0x39bf44abUL,\n+    0xbc8b91e8UL, 0xc8a58e51UL, 0x3ff15a98UL, 0xb9eeab0aUL, 0x3c82406aUL,\n+    0x5471c3c2UL, 0x3ff166a4UL, 0x82ea1a32UL, 0x3c58f23bUL, 0x3c7d517bUL,\n+    0x3ff172b8UL, 0xb9d78a76UL, 0xbc819041UL, 0x8695bbc0UL, 0x3ff17ed4UL,\n+    0xe2ac5a64UL, 0x3c709e3fUL, 0x388c8deaUL, 0x3ff18af9UL, 0xd1970f6cUL,\n+    0xbc911023UL, 0x58375d2fUL, 0x3ff19726UL, 0x85f17e08UL, 0x3c94aaddUL,\n+    0xeb6fcb75UL, 0x3ff1a35bUL, 0x7b4968e4UL, 0x3c8e5b4cUL, 0xf8138a1cUL,\n+    0x3ff1af99UL, 0xa4b69280UL, 0x3c97bf85UL, 0x84045cd4UL, 0x3ff1bbe0UL,\n+    0x352ef607UL, 0xbc995386UL, 0x95281c6bUL, 0x3ff1c82fUL, 0x8010f8c9UL,\n+    0x3c900977UL, 0x3168b9aaUL, 0x3ff1d487UL, 0x00a2643cUL, 0x3c9e016eUL,\n+    0x5eb44027UL, 0x3ff1e0e7UL, 0x088cb6deUL, 0xbc96fdd8UL, 0x22fcd91dUL,\n+    0x3ff1ed50UL, 0x027bb78cUL, 0xbc91df98UL, 0x8438ce4dUL, 0x3ff1f9c1UL,\n+    0xa097af5cUL, 0xbc9bf524UL, 0x88628cd6UL, 0x3ff2063bUL, 0x814a8495UL,\n+    0x3c8dc775UL, 0x3578a819UL, 0x3ff212beUL, 0x2cfcaac9UL, 0x3c93592dUL,\n+    0x917ddc96UL, 0x3ff21f49UL, 0x9494a5eeUL, 0x3c82a97eUL, 0xa27912d1UL,\n+    0x3ff22bddUL, 0x5577d69fUL, 0x3c8d34fbUL, 0x6e756238UL, 0x3ff2387aUL,\n+    0xb6c70573UL, 0x3c99b07eUL, 0xfb82140aUL, 0x3ff2451fUL, 0x911ca996UL,\n+    0x3c8acfccUL, 0x4fb2a63fUL, 0x3ff251ceUL, 0xbef4f4a4UL, 0x3c8ac155UL,\n+    0x711ece75UL, 0x3ff25e85UL, 0x4ac31b2cUL, 0x3c93e1a2UL, 0x65e27cddUL,\n+    0x3ff26b45UL, 0x9940e9d9UL, 0x3c82bd33UL, 0x341ddf29UL, 0x3ff2780eUL,\n+    0x05f9e76cUL, 0x3c9e067cUL, 0xe1f56381UL, 0x3ff284dfUL, 0x8c3f0d7eUL,\n+    0xbc9a4c3aUL, 0x7591bb70UL, 0x3ff291baUL, 0x28401cbdUL, 0xbc82cc72UL,\n+    0xf51fdee1UL, 0x3ff29e9dUL, 0xafad1255UL, 0x3c8612e8UL, 0x66d10f13UL,\n+    0x3ff2ab8aUL, 0x191690a7UL, 0xbc995743UL, 0xd0dad990UL, 0x3ff2b87fUL,\n+    0xd6381aa4UL, 0xbc410adcUL, 0x39771b2fUL, 0x3ff2c57eUL, 0xa6eb5124UL,\n+    0xbc950145UL, 0xa6e4030bUL, 0x3ff2d285UL, 0x54db41d5UL, 0x3c900247UL,\n+    0x1f641589UL, 0x3ff2df96UL, 0xfbbce198UL, 0x3c9d16cfUL, 0xa93e2f56UL,\n+    0x3ff2ecafUL, 0x45d52383UL, 0x3c71ca0fUL, 0x4abd886bUL, 0x3ff2f9d2UL,\n+    0x532bda93UL, 0xbc653c55UL, 0x0a31b715UL, 0x3ff306feUL, 0xd23182e4UL,\n+    0x3c86f46aUL, 0xedeeb2fdUL, 0x3ff31432UL, 0xf3f3fcd1UL, 0x3c8959a3UL,\n+    0xfc4cd831UL, 0x3ff32170UL, 0x8e18047cUL, 0x3c8a9ce7UL, 0x3ba8ea32UL,\n+    0x3ff32eb8UL, 0x3cb4f318UL, 0xbc9c45e8UL, 0xb26416ffUL, 0x3ff33c08UL,\n+    0x843659a6UL, 0x3c932721UL, 0x66e3fa2dUL, 0x3ff34962UL, 0x930881a4UL,\n+    0xbc835a75UL, 0x5f929ff1UL, 0x3ff356c5UL, 0x5c4e4628UL, 0xbc8b5ceeUL,\n+    0xa2de883bUL, 0x3ff36431UL, 0xa06cb85eUL, 0xbc8c3144UL, 0x373aa9cbUL,\n+    0x3ff371a7UL, 0xbf42eae2UL, 0xbc963aeaUL, 0x231e754aUL, 0x3ff37f26UL,\n+    0x9eceb23cUL, 0xbc99f5caUL, 0x6d05d866UL, 0x3ff38caeUL, 0x3c9904bdUL,\n+    0xbc9e958dUL, 0x1b7140efUL, 0x3ff39a40UL, 0xfc8e2934UL, 0xbc99a9a5UL,\n+    0x34e59ff7UL, 0x3ff3a7dbUL, 0xd661f5e3UL, 0xbc75e436UL, 0xbfec6cf4UL,\n+    0x3ff3b57fUL, 0xe26fff18UL, 0x3c954c66UL, 0xc313a8e5UL, 0x3ff3c32dUL,\n+    0x375d29c3UL, 0xbc9efff8UL, 0x44ede173UL, 0x3ff3d0e5UL, 0x8c284c71UL,\n+    0x3c7fe8d0UL, 0x4c123422UL, 0x3ff3dea6UL, 0x11f09ebcUL, 0x3c8ada09UL,\n+    0xdf1c5175UL, 0x3ff3ec70UL, 0x7b8c9bcaUL, 0xbc8af663UL, 0x04ac801cUL,\n+    0x3ff3fa45UL, 0xf956f9f3UL, 0xbc97d023UL, 0xc367a024UL, 0x3ff40822UL,\n+    0xb6f4d048UL, 0x3c8bddf8UL, 0x21f72e2aUL, 0x3ff4160aUL, 0x1c309278UL,\n+    0xbc5ef369UL, 0x2709468aUL, 0x3ff423fbUL, 0xc0b314ddUL, 0xbc98462dUL,\n+    0xd950a897UL, 0x3ff431f5UL, 0xe35f7999UL, 0xbc81c7ddUL, 0x3f84b9d4UL,\n+    0x3ff43ffaUL, 0x9704c003UL, 0x3c8880beUL, 0x6061892dUL, 0x3ff44e08UL,\n+    0x04ef80d0UL, 0x3c489b7aUL, 0x42a7d232UL, 0x3ff45c20UL, 0x82fb1f8eUL,\n+    0xbc686419UL, 0xed1d0057UL, 0x3ff46a41UL, 0xd1648a76UL, 0x3c9c944bUL,\n+    0x668b3237UL, 0x3ff4786dUL, 0xed445733UL, 0xbc9c20f0UL, 0xb5c13cd0UL,\n+    0x3ff486a2UL, 0xb69062f0UL, 0x3c73c1a3UL, 0xe192aed2UL, 0x3ff494e1UL,\n+    0x5e499ea0UL, 0xbc83b289UL, 0xf0d7d3deUL, 0x3ff4a32aUL, 0xf3d1be56UL,\n+    0x3c99cb62UL, 0xea6db7d7UL, 0x3ff4b17dUL, 0x7f2897f0UL, 0xbc8125b8UL,\n+    0xd5362a27UL, 0x3ff4bfdaUL, 0xafec42e2UL, 0x3c7d4397UL, 0xb817c114UL,\n+    0x3ff4ce41UL, 0x690abd5dUL, 0x3c905e29UL, 0x99fddd0dUL, 0x3ff4dcb2UL,\n+    0xbc6a7833UL, 0x3c98ecdbUL, 0x81d8abffUL, 0x3ff4eb2dUL, 0x2e5d7a52UL,\n+    0xbc95257dUL, 0x769d2ca7UL, 0x3ff4f9b2UL, 0xd25957e3UL, 0xbc94b309UL,\n+    0x7f4531eeUL, 0x3ff50841UL, 0x49b7465fUL, 0x3c7a249bUL, 0xa2cf6642UL,\n+    0x3ff516daUL, 0x69bd93efUL, 0xbc8f7685UL, 0xe83f4eefUL, 0x3ff5257dUL,\n+    0x43efef71UL, 0xbc7c998dUL, 0x569d4f82UL, 0x3ff5342bUL, 0x1db13cadUL,\n+    0xbc807abeUL, 0xf4f6ad27UL, 0x3ff542e2UL, 0x192d5f7eUL, 0x3c87926dUL,\n+    0xca5d920fUL, 0x3ff551a4UL, 0xefede59bUL, 0xbc8d689cUL, 0xdde910d2UL,\n+    0x3ff56070UL, 0x168eebf0UL, 0xbc90fb6eUL, 0x36b527daUL, 0x3ff56f47UL,\n+    0x011d93adUL, 0x3c99bb2cUL, 0xdbe2c4cfUL, 0x3ff57e27UL, 0x8a57b9c4UL,\n+    0xbc90b98cUL, 0xd497c7fdUL, 0x3ff58d12UL, 0x5b9a1de8UL, 0x3c8295e1UL,\n+    0x27ff07ccUL, 0x3ff59c08UL, 0xe467e60fUL, 0xbc97e2ceUL, 0xdd485429UL,\n+    0x3ff5ab07UL, 0x054647adUL, 0x3c96324cUL, 0xfba87a03UL, 0x3ff5ba11UL,\n+    0x4c233e1aUL, 0xbc9b77a1UL, 0x8a5946b7UL, 0x3ff5c926UL, 0x816986a2UL,\n+    0x3c3c4b1bUL, 0x90998b93UL, 0x3ff5d845UL, 0xa8b45643UL, 0xbc9cd6a7UL,\n+    0x15ad2148UL, 0x3ff5e76fUL, 0x3080e65eUL, 0x3c9ba6f9UL, 0x20dceb71UL,\n+    0x3ff5f6a3UL, 0xe3cdcf92UL, 0xbc89eaddUL, 0xb976dc09UL, 0x3ff605e1UL,\n+    0x9b56de47UL, 0xbc93e242UL, 0xe6cdf6f4UL, 0x3ff6152aUL, 0x4ab84c27UL,\n+    0x3c9e4b3eUL, 0xb03a5585UL, 0x3ff6247eUL, 0x7e40b497UL, 0xbc9383c1UL,\n+    0x1d1929fdUL, 0x3ff633ddUL, 0xbeb964e5UL, 0x3c984710UL, 0x34ccc320UL,\n+    0x3ff64346UL, 0x759d8933UL, 0xbc8c483cUL, 0xfebc8fb7UL, 0x3ff652b9UL,\n+    0xc9a73e09UL, 0xbc9ae3d5UL, 0x82552225UL, 0x3ff66238UL, 0x87591c34UL,\n+    0xbc9bb609UL, 0xc70833f6UL, 0x3ff671c1UL, 0x586c6134UL, 0xbc8e8732UL,\n+    0xd44ca973UL, 0x3ff68155UL, 0x44f73e65UL, 0x3c6038aeUL, 0xb19e9538UL,\n+    0x3ff690f4UL, 0x9aeb445dUL, 0x3c8804bdUL, 0x667f3bcdUL, 0x3ff6a09eUL,\n+    0x13b26456UL, 0xbc9bdd34UL, 0xfa75173eUL, 0x3ff6b052UL, 0x2c9a9d0eUL,\n+    0x3c7a38f5UL, 0x750bdabfUL, 0x3ff6c012UL, 0x67ff0b0dUL, 0xbc728956UL,\n+    0xddd47645UL, 0x3ff6cfdcUL, 0xb6f17309UL, 0x3c9c7aa9UL, 0x3c651a2fUL,\n+    0x3ff6dfb2UL, 0x683c88abUL, 0xbc6bbe3aUL, 0x98593ae5UL, 0x3ff6ef92UL,\n+    0x9e1ac8b2UL, 0xbc90b974UL, 0xf9519484UL, 0x3ff6ff7dUL, 0x25860ef6UL,\n+    0xbc883c0fUL, 0x66f42e87UL, 0x3ff70f74UL, 0xd45aa65fUL, 0x3c59d644UL,\n+    0xe8ec5f74UL, 0x3ff71f75UL, 0x86887a99UL, 0xbc816e47UL, 0x86ead08aUL,\n+    0x3ff72f82UL, 0x2cd62c72UL, 0xbc920aa0UL, 0x48a58174UL, 0x3ff73f9aUL,\n+    0x6c65d53cUL, 0xbc90a8d9UL, 0x35d7cbfdUL, 0x3ff74fbdUL, 0x618a6e1cUL,\n+    0x3c9047fdUL, 0x564267c9UL, 0x3ff75febUL, 0x57316dd3UL, 0xbc902459UL,\n+    0xb1ab6e09UL, 0x3ff77024UL, 0x169147f8UL, 0x3c9b7877UL, 0x4fde5d3fUL,\n+    0x3ff78069UL, 0x0a02162dUL, 0x3c9866b8UL, 0x38ac1cf6UL, 0x3ff790b9UL,\n+    0x62aadd3eUL, 0x3c9349a8UL, 0x73eb0187UL, 0x3ff7a114UL, 0xee04992fUL,\n+    0xbc841577UL, 0x0976cfdbUL, 0x3ff7b17bUL, 0x8468dc88UL, 0xbc9bebb5UL,\n+    0x0130c132UL, 0x3ff7c1edUL, 0xd1164dd6UL, 0x3c9f124cUL, 0x62ff86f0UL,\n+    0x3ff7d26aUL, 0xfb72b8b4UL, 0x3c91bddbUL, 0x36cf4e62UL, 0x3ff7e2f3UL,\n+    0xba15797eUL, 0x3c705d02UL, 0x8491c491UL, 0x3ff7f387UL, 0xcf9311aeUL,\n+    0xbc807f11UL, 0x543e1a12UL, 0x3ff80427UL, 0x626d972bUL, 0xbc927c86UL,\n+    0xadd106d9UL, 0x3ff814d2UL, 0x0d151d4dUL, 0x3c946437UL, 0x994cce13UL,\n+    0x3ff82589UL, 0xd41532d8UL, 0xbc9d4c1dUL, 0x1eb941f7UL, 0x3ff8364cUL,\n+    0x31df2bd5UL, 0x3c999b9aUL, 0x4623c7adUL, 0x3ff8471aUL, 0xa341cdfbUL,\n+    0xbc88d684UL, 0x179f5b21UL, 0x3ff857f4UL, 0xf8b216d0UL, 0xbc5ba748UL,\n+    0x9b4492edUL, 0x3ff868d9UL, 0x9bd4f6baUL, 0xbc9fc6f8UL, 0xd931a436UL,\n+    0x3ff879caUL, 0xd2db47bdUL, 0x3c85d2d7UL, 0xd98a6699UL, 0x3ff88ac7UL,\n+    0xf37cb53aUL, 0x3c9994c2UL, 0xa478580fUL, 0x3ff89bd0UL, 0x4475202aUL,\n+    0x3c9d5395UL, 0x422aa0dbUL, 0x3ff8ace5UL, 0x56864b27UL, 0x3c96e9f1UL,\n+    0xbad61778UL, 0x3ff8be05UL, 0xfc43446eUL, 0x3c9ecb5eUL, 0x16b5448cUL,\n+    0x3ff8cf32UL, 0x32e9e3aaUL, 0xbc70d55eUL, 0x5e0866d9UL, 0x3ff8e06aUL,\n+    0x6fc9b2e6UL, 0xbc97114aUL, 0x99157736UL, 0x3ff8f1aeUL, 0xa2e3976cUL,\n+    0x3c85cc13UL, 0xd0282c8aUL, 0x3ff902feUL, 0x85fe3fd2UL, 0x3c9592caUL,\n+    0x0b91ffc6UL, 0x3ff9145bUL, 0x2e582524UL, 0xbc9dd679UL, 0x53aa2fe2UL,\n+    0x3ff925c3UL, 0xa639db7fUL, 0xbc83455fUL, 0xb0cdc5e5UL, 0x3ff93737UL,\n+    0x81b57ebcUL, 0xbc675fc7UL, 0x2b5f98e5UL, 0x3ff948b8UL, 0x797d2d99UL,\n+    0xbc8dc3d6UL, 0xcbc8520fUL, 0x3ff95a44UL, 0x96a5f039UL, 0xbc764b7cUL,\n+    0x9a7670b3UL, 0x3ff96bddUL, 0x7f19c896UL, 0xbc5ba596UL, 0x9fde4e50UL,\n+    0x3ff97d82UL, 0x7c1b85d1UL, 0xbc9d185bUL, 0xe47a22a2UL, 0x3ff98f33UL,\n+    0xa24c78ecUL, 0x3c7cabdaUL, 0x70ca07baUL, 0x3ff9a0f1UL, 0x91cee632UL,\n+    0xbc9173bdUL, 0x4d53fe0dUL, 0x3ff9b2bbUL, 0x4df6d518UL, 0xbc9dd84eUL,\n+    0x82a3f090UL, 0x3ff9c491UL, 0xb071f2beUL, 0x3c7c7c46UL, 0x194bb8d5UL,\n+    0x3ff9d674UL, 0xa3dd8233UL, 0xbc9516beUL, 0x19e32323UL, 0x3ff9e863UL,\n+    0x78e64c6eUL, 0x3c7824caUL, 0x8d07f29eUL, 0x3ff9fa5eUL, 0xaaf1faceUL,\n+    0xbc84a9ceUL, 0x7b5de565UL, 0x3ffa0c66UL, 0x5d1cd533UL, 0xbc935949UL,\n+    0xed8eb8bbUL, 0x3ffa1e7aUL, 0xee8be70eUL, 0x3c9c6618UL, 0xec4a2d33UL,\n+    0x3ffa309bUL, 0x7ddc36abUL, 0x3c96305cUL, 0x80460ad8UL, 0x3ffa42c9UL,\n+    0x589fb120UL, 0xbc9aa780UL, 0xb23e255dUL, 0x3ffa5503UL, 0xdb8d41e1UL,\n+    0xbc9d2f6eUL, 0x8af46052UL, 0x3ffa674aUL, 0x30670366UL, 0x3c650f56UL,\n+    0x1330b358UL, 0x3ffa799eUL, 0xcac563c7UL, 0x3c9bcb7eUL, 0x53c12e59UL,\n+    0x3ffa8bfeUL, 0xb2ba15a9UL, 0xbc94f867UL, 0x5579fdbfUL, 0x3ffa9e6bUL,\n+    0x0ef7fd31UL, 0x3c90fac9UL, 0x21356ebaUL, 0x3ffab0e5UL, 0xdae94545UL,\n+    0x3c889c31UL, 0xbfd3f37aUL, 0x3ffac36bUL, 0xcae76cd0UL, 0xbc8f9234UL,\n+    0x3a3c2774UL, 0x3ffad5ffUL, 0xb6b1b8e5UL, 0x3c97ef3bUL, 0x995ad3adUL,\n+    0x3ffae89fUL, 0x345dcc81UL, 0x3c97a1cdUL, 0xe622f2ffUL, 0x3ffafb4cUL,\n+    0x0f315ecdUL, 0xbc94b2fcUL, 0x298db666UL, 0x3ffb0e07UL, 0x4c80e425UL,\n+    0xbc9bdef5UL, 0x6c9a8952UL, 0x3ffb20ceUL, 0x4a0756ccUL, 0x3c94dd02UL,\n+    0xb84f15fbUL, 0x3ffb33a2UL, 0x3084d708UL, 0xbc62805eUL, 0x15b749b1UL,\n+    0x3ffb4684UL, 0xe9df7c90UL, 0xbc7f763dUL, 0x8de5593aUL, 0x3ffb5972UL,\n+    0xbbba6de3UL, 0xbc9c71dfUL, 0x29f1c52aUL, 0x3ffb6c6eUL, 0x52883f6eUL,\n+    0x3c92a8f3UL, 0xf2fb5e47UL, 0x3ffb7f76UL, 0x7e54ac3bUL, 0xbc75584fUL,\n+    0xf22749e4UL, 0x3ffb928cUL, 0x54cb65c6UL, 0xbc9b7216UL, 0x30a1064aUL,\n+    0x3ffba5b0UL, 0x0e54292eUL, 0xbc9efcd3UL, 0xb79a6f1fUL, 0x3ffbb8e0UL,\n+    0xc9696205UL, 0xbc3f52d1UL, 0x904bc1d2UL, 0x3ffbcc1eUL, 0x7a2d9e84UL,\n+    0x3c823dd0UL, 0xc3f3a207UL, 0x3ffbdf69UL, 0x60ea5b53UL, 0xbc3c2623UL,\n+    0x5bd71e09UL, 0x3ffbf2c2UL, 0x3f6b9c73UL, 0xbc9efdcaUL, 0x6141b33dUL,\n+    0x3ffc0628UL, 0xa1fbca34UL, 0xbc8d8a5aUL, 0xdd85529cUL, 0x3ffc199bUL,\n+    0x895048ddUL, 0x3c811065UL, 0xd9fa652cUL, 0x3ffc2d1cUL, 0x17c8a5d7UL,\n+    0xbc96e516UL, 0x5fffd07aUL, 0x3ffc40abUL, 0xe083c60aUL, 0x3c9b4537UL,\n+    0x78fafb22UL, 0x3ffc5447UL, 0x2493b5afUL, 0x3c912f07UL, 0x2e57d14bUL,\n+    0x3ffc67f1UL, 0xff483cadUL, 0x3c92884dUL, 0x8988c933UL, 0x3ffc7ba8UL,\n+    0xbe255559UL, 0xbc8e76bbUL, 0x9406e7b5UL, 0x3ffc8f6dUL, 0x48805c44UL,\n+    0x3c71acbcUL, 0x5751c4dbUL, 0x3ffca340UL, 0xd10d08f5UL, 0xbc87f2beUL,\n+    0xdcef9069UL, 0x3ffcb720UL, 0xd1e949dbUL, 0x3c7503cbUL, 0x2e6d1675UL,\n+    0x3ffccb0fUL, 0x86009092UL, 0xbc7d220fUL, 0x555dc3faUL, 0x3ffcdf0bUL,\n+    0x53829d72UL, 0xbc8dd83bUL, 0x5b5bab74UL, 0x3ffcf315UL, 0xb86dff57UL,\n+    0xbc9a08e9UL, 0x4a07897cUL, 0x3ffd072dUL, 0x43797a9cUL, 0xbc9cbc37UL,\n+    0x2b08c968UL, 0x3ffd1b53UL, 0x219a36eeUL, 0x3c955636UL, 0x080d89f2UL,\n+    0x3ffd2f87UL, 0x719d8578UL, 0xbc9d487bUL, 0xeacaa1d6UL, 0x3ffd43c8UL,\n+    0xbf5a1614UL, 0x3c93db53UL, 0xdcfba487UL, 0x3ffd5818UL, 0xd75b3707UL,\n+    0x3c82ed02UL, 0xe862e6d3UL, 0x3ffd6c76UL, 0x4a8165a0UL, 0x3c5fe87aUL,\n+    0x16c98398UL, 0x3ffd80e3UL, 0x8beddfe8UL, 0xbc911ec1UL, 0x71ff6075UL,\n+    0x3ffd955dUL, 0xbb9af6beUL, 0x3c9a052dUL, 0x03db3285UL, 0x3ffda9e6UL,\n+    0x696db532UL, 0x3c9c2300UL, 0xd63a8315UL, 0x3ffdbe7cUL, 0x926b8be4UL,\n+    0xbc9b76f1UL, 0xf301b460UL, 0x3ffdd321UL, 0x78f018c3UL, 0x3c92da57UL,\n+    0x641c0658UL, 0x3ffde7d5UL, 0x8e79ba8fUL, 0xbc9ca552UL, 0x337b9b5fUL,\n+    0x3ffdfc97UL, 0x4f184b5cUL, 0xbc91a5cdUL, 0x6b197d17UL, 0x3ffe1167UL,\n+    0xbd5c7f44UL, 0xbc72b529UL, 0x14f5a129UL, 0x3ffe2646UL, 0x817a1496UL,\n+    0xbc97b627UL, 0x3b16ee12UL, 0x3ffe3b33UL, 0x31fdc68bUL, 0xbc99f4a4UL,\n+    0xe78b3ff6UL, 0x3ffe502eUL, 0x80a9cc8fUL, 0x3c839e89UL, 0x24676d76UL,\n+    0x3ffe6539UL, 0x7522b735UL, 0xbc863ff8UL, 0xfbc74c83UL, 0x3ffe7a51UL,\n+    0xca0c8de2UL, 0x3c92d522UL, 0x77cdb740UL, 0x3ffe8f79UL, 0x80b054b1UL,\n+    0xbc910894UL, 0xa2a490daUL, 0x3ffea4afUL, 0x179c2893UL, 0xbc9e9c23UL,\n+    0x867cca6eUL, 0x3ffeb9f4UL, 0x2293e4f2UL, 0x3c94832fUL, 0x2d8e67f1UL,\n+    0x3ffecf48UL, 0xb411ad8cUL, 0xbc9c93f3UL, 0xa2188510UL, 0x3ffee4aaUL,\n+    0xa487568dUL, 0x3c91c68dUL, 0xee615a27UL, 0x3ffefa1bUL, 0x86a4b6b0UL,\n+    0x3c9dc7f4UL, 0x1cb6412aUL, 0x3fff0f9cUL, 0x65181d45UL, 0xbc932200UL,\n+    0x376bba97UL, 0x3fff252bUL, 0xbf0d8e43UL, 0x3c93a1a5UL, 0x48dd7274UL,\n+    0x3fff3ac9UL, 0x3ed837deUL, 0xbc795a5aUL, 0x5b6e4540UL, 0x3fff5076UL,\n+    0x2dd8a18bUL, 0x3c99d3e1UL, 0x798844f8UL, 0x3fff6632UL, 0x3539343eUL,\n+    0x3c9fa37bUL, 0xad9cbe14UL, 0x3fff7bfdUL, 0xd006350aUL, 0xbc9dbb12UL,\n+    0x02243c89UL, 0x3fff91d8UL, 0xa779f689UL, 0xbc612ea8UL, 0x819e90d8UL,\n+    0x3fffa7c1UL, 0xf3a5931eUL, 0x3c874853UL, 0x3692d514UL, 0x3fffbdbaUL,\n+    0x15098eb6UL, 0xbc796773UL, 0x2b8f71f1UL, 0x3fffd3c2UL, 0x966579e7UL,\n+    0x3c62eb74UL, 0x6b2a23d9UL, 0x3fffe9d9UL, 0x7442fde3UL, 0x3c74a603UL,\n+    0xe78a6731UL, 0x3f55d87fUL, 0xd704a0c0UL, 0x3fac6b08UL, 0x6fba4e77UL,\n+    0x3f83b2abUL, 0xff82c58fUL, 0x3fcebfbdUL, 0xfefa39efUL, 0x3fe62e42UL,\n+    0x00000000UL, 0x00000000UL, 0xfefa39efUL, 0x3fe62e42UL, 0xfefa39efUL,\n+    0xbfe62e42UL, 0xf8000000UL, 0xffffffffUL, 0xf8000000UL, 0xffffffffUL,\n+    0x00000000UL, 0x80000000UL, 0x00000000UL, 0x00000000UL\n+\n+};\n+\n+ATTRIBUTE_ALIGNED(8) double _DOUBLE2 = 2.0;\n+ATTRIBUTE_ALIGNED(8) double _DOUBLE0 = 0.0;\n+ATTRIBUTE_ALIGNED(8) double _DOUBLE0DOT5 = 0.5;\n+\n+\/\/registers,\n+\/\/ input: xmm0, xmm1\n+\/\/ scratch: xmm1, xmm2, xmm3, xmm4, xmm5, xmm6, xmm7\n+\/\/          eax, edx, ecx, ebx\n+\n+\/\/ Code generated by Intel C compiler for LIBM library\n+\n+void MacroAssembler::fast_pow(XMMRegister xmm0, XMMRegister xmm1, XMMRegister xmm2, XMMRegister xmm3, XMMRegister xmm4, XMMRegister xmm5, XMMRegister xmm6, XMMRegister xmm7, Register eax, Register ecx, Register edx, Register tmp) {\n+  Label L_2TAG_PACKET_0_0_2, L_2TAG_PACKET_1_0_2, L_2TAG_PACKET_2_0_2, L_2TAG_PACKET_3_0_2;\n+  Label L_2TAG_PACKET_4_0_2, L_2TAG_PACKET_5_0_2, L_2TAG_PACKET_6_0_2, L_2TAG_PACKET_7_0_2;\n+  Label L_2TAG_PACKET_8_0_2, L_2TAG_PACKET_9_0_2, L_2TAG_PACKET_10_0_2, L_2TAG_PACKET_11_0_2;\n+  Label L_2TAG_PACKET_12_0_2, L_2TAG_PACKET_13_0_2, L_2TAG_PACKET_14_0_2, L_2TAG_PACKET_15_0_2;\n+  Label L_2TAG_PACKET_16_0_2, L_2TAG_PACKET_17_0_2, L_2TAG_PACKET_18_0_2, L_2TAG_PACKET_19_0_2;\n+  Label L_2TAG_PACKET_20_0_2, L_2TAG_PACKET_21_0_2, L_2TAG_PACKET_22_0_2, L_2TAG_PACKET_23_0_2;\n+  Label L_2TAG_PACKET_24_0_2, L_2TAG_PACKET_25_0_2, L_2TAG_PACKET_26_0_2, L_2TAG_PACKET_27_0_2;\n+  Label L_2TAG_PACKET_28_0_2, L_2TAG_PACKET_29_0_2, L_2TAG_PACKET_30_0_2, L_2TAG_PACKET_31_0_2;\n+  Label L_2TAG_PACKET_32_0_2, L_2TAG_PACKET_33_0_2, L_2TAG_PACKET_34_0_2, L_2TAG_PACKET_35_0_2;\n+  Label L_2TAG_PACKET_36_0_2, L_2TAG_PACKET_37_0_2, L_2TAG_PACKET_38_0_2, L_2TAG_PACKET_39_0_2;\n+  Label L_2TAG_PACKET_40_0_2, L_2TAG_PACKET_41_0_2, L_2TAG_PACKET_42_0_2, L_2TAG_PACKET_43_0_2;\n+  Label L_2TAG_PACKET_44_0_2, L_2TAG_PACKET_45_0_2, L_2TAG_PACKET_46_0_2, L_2TAG_PACKET_47_0_2;\n+  Label L_2TAG_PACKET_48_0_2, L_2TAG_PACKET_49_0_2, L_2TAG_PACKET_50_0_2, L_2TAG_PACKET_51_0_2;\n+  Label L_2TAG_PACKET_52_0_2, L_2TAG_PACKET_53_0_2, L_2TAG_PACKET_54_0_2, L_2TAG_PACKET_55_0_2;\n+  Label L_2TAG_PACKET_56_0_2, L_2TAG_PACKET_57_0_2, L_2TAG_PACKET_58_0_2, start;\n+  Label L_NOT_DOUBLE2, L_NOT_DOUBLE0DOT5;\n+\n+  assert_different_registers(tmp, eax, ecx, edx);\n+\n+  address static_const_table_pow = (address)_static_const_table_pow;\n+  address DOUBLE2 = (address) &_DOUBLE2;\n+  address DOUBLE0 = (address) &_DOUBLE0;\n+  address DOUBLE0DOT5 = (address) &_DOUBLE0DOT5;\n+\n+  subl(rsp, 120);\n+  movl(Address(rsp, 64), tmp);\n+  lea(tmp, ExternalAddress(static_const_table_pow));\n+  movsd(xmm0, Address(rsp, 128));\n+  movsd(xmm1, Address(rsp, 136));\n+\n+  \/\/ Special case: pow(x, 2.0) => x * x\n+  ucomisd(xmm1, ExternalAddress(DOUBLE2));\n+  jccb(Assembler::notEqual, L_NOT_DOUBLE2);\n+  jccb(Assembler::parity, L_NOT_DOUBLE2);\n+  mulsd(xmm0, xmm0);\n+  jmp(L_2TAG_PACKET_21_0_2);\n+\n+  bind(L_NOT_DOUBLE2);\n+  \/\/ Special case: pow(x, 0.5) => sqrt(x)\n+  ucomisd(xmm1, ExternalAddress(DOUBLE0DOT5)); \/\/ For pow(x, y), check whether y == 0.5\n+  jccb(Assembler::notEqual, L_NOT_DOUBLE0DOT5);\n+  jccb(Assembler::parity, L_NOT_DOUBLE0DOT5);\n+  ucomisd(xmm0, ExternalAddress(DOUBLE0));\n+  \/\/ According to the API specs, pow(-0.0, 0.5) = 0.0 and sqrt(-0.0) = -0.0.\n+  \/\/ So pow(-0.0, 0.5) shouldn't be replaced with sqrt(-0.0).\n+  \/\/ -0.0\/+0.0 are both excluded since floating-point comparison doesn't distinguish -0.0 from +0.0.\n+  jccb(Assembler::belowEqual, L_NOT_DOUBLE0DOT5); \/\/ pow(x, 0.5) => sqrt(x) only for x > 0.0\n+  sqrtsd(xmm0, xmm0);\n+  jmp(L_2TAG_PACKET_21_0_2);\n+\n+  bind(L_NOT_DOUBLE0DOT5);\n+  xorpd(xmm2, xmm2);\n+  movl(eax, 16368);\n+  pinsrw(xmm2, eax, 3);\n+  movl(ecx, 1069088768);\n+  movdl(xmm7, ecx);\n+  movsd(Address(rsp, 16), xmm1);\n+  xorpd(xmm1, xmm1);\n+  movl(edx, 30704);\n+  pinsrw(xmm1, edx, 3);\n+  movsd(Address(rsp, 8), xmm0);\n+  movdqu(xmm3, xmm0);\n+  movl(edx, 8192);\n+  movdl(xmm4, edx);\n+  movdqu(xmm6, Address(tmp, 8240));\n+  pextrw(eax, xmm0, 3);\n+  por(xmm0, xmm2);\n+  psllq(xmm0, 5);\n+  movsd(xmm2, Address(tmp, 8256));\n+  psrlq(xmm0, 34);\n+  movl(edx, eax);\n+  andl(edx, 32752);\n+  subl(edx, 16368);\n+  movl(ecx, edx);\n+  sarl(edx, 31);\n+  addl(ecx, edx);\n+  xorl(ecx, edx);\n+  rcpss(xmm0, xmm0);\n+  psllq(xmm3, 12);\n+  addl(ecx, 16);\n+  bsrl(ecx, ecx);\n+  psrlq(xmm3, 12);\n+  movl(Address(rsp, 24), rsi);\n+  subl(eax, 16);\n+  cmpl(eax, 32736);\n+  jcc(Assembler::aboveEqual, L_2TAG_PACKET_0_0_2);\n+  movl(rsi, 0);\n+\n+  bind(L_2TAG_PACKET_1_0_2);\n+  mulss(xmm0, xmm7);\n+  movl(edx, -1);\n+  subl(ecx, 4);\n+  shll(edx);\n+  movdl(xmm5, edx);\n+  por(xmm3, xmm1);\n+  subl(eax, 16351);\n+  cmpl(eax, 1);\n+  jcc(Assembler::belowEqual, L_2TAG_PACKET_2_0_2);\n+  paddd(xmm0, xmm4);\n+  psllq(xmm5, 32);\n+  movdl(edx, xmm0);\n+  psllq(xmm0, 29);\n+  pand(xmm5, xmm3);\n+\n+  bind(L_2TAG_PACKET_3_0_2);\n+  pand(xmm0, xmm6);\n+  subsd(xmm3, xmm5);\n+  subl(eax, 1);\n+  sarl(eax, 4);\n+  cvtsi2sdl(xmm7, eax);\n+  mulpd(xmm5, xmm0);\n+\n+  bind(L_2TAG_PACKET_4_0_2);\n+  mulsd(xmm3, xmm0);\n+  movdqu(xmm1, Address(tmp, 8272));\n+  subsd(xmm5, xmm2);\n+  movdqu(xmm4, Address(tmp, 8288));\n+  movl(ecx, eax);\n+  sarl(eax, 31);\n+  addl(ecx, eax);\n+  xorl(eax, ecx);\n+  addl(eax, 1);\n+  bsrl(eax, eax);\n+  unpcklpd(xmm5, xmm3);\n+  movdqu(xmm6, Address(tmp, 8304));\n+  addsd(xmm3, xmm5);\n+  andl(edx, 16760832);\n+  shrl(edx, 10);\n+  addpd(xmm5, Address(tmp, edx, Address::times_1, -3616));\n+  movdqu(xmm0, Address(tmp, 8320));\n+  pshufd(xmm2, xmm3, 68);\n+  mulsd(xmm3, xmm3);\n+  mulpd(xmm1, xmm2);\n+  mulpd(xmm4, xmm2);\n+  addsd(xmm5, xmm7);\n+  mulsd(xmm2, xmm3);\n+  addpd(xmm6, xmm1);\n+  mulsd(xmm3, xmm3);\n+  addpd(xmm0, xmm4);\n+  movsd(xmm1, Address(rsp, 16));\n+  movzwl(ecx, Address(rsp, 22));\n+  pshufd(xmm7, xmm5, 238);\n+  movsd(xmm4, Address(tmp, 8368));\n+  mulpd(xmm6, xmm2);\n+  pshufd(xmm3, xmm3, 68);\n+  mulpd(xmm0, xmm2);\n+  shll(eax, 4);\n+  subl(eax, 15872);\n+  andl(ecx, 32752);\n+  addl(eax, ecx);\n+  mulpd(xmm3, xmm6);\n+  cmpl(eax, 624);\n+  jcc(Assembler::aboveEqual, L_2TAG_PACKET_5_0_2);\n+  xorpd(xmm6, xmm6);\n+  movl(edx, 17080);\n+  pinsrw(xmm6, edx, 3);\n+  movdqu(xmm2, xmm1);\n+  pand(xmm4, xmm1);\n+  subsd(xmm1, xmm4);\n+  mulsd(xmm4, xmm5);\n+  addsd(xmm0, xmm7);\n+  mulsd(xmm1, xmm5);\n+  movdqu(xmm7, xmm6);\n+  addsd(xmm6, xmm4);\n+  addpd(xmm3, xmm0);\n+  movdl(edx, xmm6);\n+  subsd(xmm6, xmm7);\n+  pshufd(xmm0, xmm3, 238);\n+  subsd(xmm4, xmm6);\n+  addsd(xmm0, xmm3);\n+  movl(ecx, edx);\n+  andl(edx, 255);\n+  addl(edx, edx);\n+  movdqu(xmm5, Address(tmp, edx, Address::times_8, 8384));\n+  addsd(xmm4, xmm1);\n+  mulsd(xmm2, xmm0);\n+  movdqu(xmm7, Address(tmp, 12480));\n+  movdqu(xmm3, Address(tmp, 12496));\n+  shll(ecx, 12);\n+  xorl(ecx, rsi);\n+  andl(ecx, -1048576);\n+  movdl(xmm6, ecx);\n+  addsd(xmm2, xmm4);\n+  movsd(xmm1, Address(tmp, 12512));\n+  pshufd(xmm0, xmm2, 68);\n+  pshufd(xmm4, xmm2, 68);\n+  mulpd(xmm0, xmm0);\n+  movl(rsi, Address(rsp, 24));\n+  mulpd(xmm7, xmm4);\n+  pshufd(xmm6, xmm6, 17);\n+  mulsd(xmm1, xmm2);\n+  mulsd(xmm0, xmm0);\n+  paddd(xmm5, xmm6);\n+  addpd(xmm3, xmm7);\n+  mulsd(xmm1, xmm5);\n+  pshufd(xmm6, xmm5, 238);\n+  mulpd(xmm0, xmm3);\n+  addsd(xmm1, xmm6);\n+  pshufd(xmm3, xmm0, 238);\n+  mulsd(xmm0, xmm5);\n+  mulsd(xmm3, xmm5);\n+  addsd(xmm0, xmm1);\n+  addsd(xmm0, xmm3);\n+  addsd(xmm0, xmm5);\n+  movsd(Address(rsp, 0), xmm0);\n+  fld_d(Address(rsp, 0));\n+  jmp(L_2TAG_PACKET_6_0_2);\n+\n+  bind(L_2TAG_PACKET_7_0_2);\n+  movsd(xmm0, Address(rsp, 128));\n+  movsd(xmm1, Address(rsp, 136));\n+  mulsd(xmm0, xmm1);\n+  movsd(Address(rsp, 0), xmm0);\n+  fld_d(Address(rsp, 0));\n+  jmp(L_2TAG_PACKET_6_0_2);\n+\n+  bind(L_2TAG_PACKET_0_0_2);\n+  addl(eax, 16);\n+  movl(edx, 32752);\n+  andl(edx, eax);\n+  cmpl(edx, 32752);\n+  jcc(Assembler::equal, L_2TAG_PACKET_8_0_2);\n+  testl(eax, 32768);\n+  jcc(Assembler::notEqual, L_2TAG_PACKET_9_0_2);\n+\n+  bind(L_2TAG_PACKET_10_0_2);\n+  movl(ecx, Address(rsp, 16));\n+  xorl(edx, edx);\n+  testl(ecx, ecx);\n+  movl(ecx, 1);\n+  cmovl(Assembler::notEqual, edx, ecx);\n+  orl(edx, Address(rsp, 20));\n+  cmpl(edx, 1072693248);\n+  jcc(Assembler::equal, L_2TAG_PACKET_7_0_2);\n+  movsd(xmm0, Address(rsp, 8));\n+  movsd(xmm3, Address(rsp, 8));\n+  movdl(edx, xmm3);\n+  psrlq(xmm3, 32);\n+  movdl(ecx, xmm3);\n+  orl(edx, ecx);\n+  cmpl(edx, 0);\n+  jcc(Assembler::equal, L_2TAG_PACKET_11_0_2);\n+  xorpd(xmm3, xmm3);\n+  movl(eax, 18416);\n+  pinsrw(xmm3, eax, 3);\n+  mulsd(xmm0, xmm3);\n+  xorpd(xmm2, xmm2);\n+  movl(eax, 16368);\n+  pinsrw(xmm2, eax, 3);\n+  movdqu(xmm3, xmm0);\n+  pextrw(eax, xmm0, 3);\n+  por(xmm0, xmm2);\n+  movl(ecx, 18416);\n+  psllq(xmm0, 5);\n+  movsd(xmm2, Address(tmp, 8256));\n+  psrlq(xmm0, 34);\n+  rcpss(xmm0, xmm0);\n+  psllq(xmm3, 12);\n+  movdqu(xmm6, Address(tmp, 8240));\n+  psrlq(xmm3, 12);\n+  mulss(xmm0, xmm7);\n+  movl(edx, -1024);\n+  movdl(xmm5, edx);\n+  por(xmm3, xmm1);\n+  paddd(xmm0, xmm4);\n+  psllq(xmm5, 32);\n+  movdl(edx, xmm0);\n+  psllq(xmm0, 29);\n+  pand(xmm5, xmm3);\n+  movl(rsi, 0);\n+  pand(xmm0, xmm6);\n+  subsd(xmm3, xmm5);\n+  andl(eax, 32752);\n+  subl(eax, 18416);\n+  sarl(eax, 4);\n+  cvtsi2sdl(xmm7, eax);\n+  mulpd(xmm5, xmm0);\n+  jmp(L_2TAG_PACKET_4_0_2);\n+\n+  bind(L_2TAG_PACKET_12_0_2);\n+  movl(ecx, Address(rsp, 16));\n+  xorl(edx, edx);\n+  testl(ecx, ecx);\n+  movl(ecx, 1);\n+  cmovl(Assembler::notEqual, edx, ecx);\n+  orl(edx, Address(rsp, 20));\n+  cmpl(edx, 1072693248);\n+  jcc(Assembler::equal, L_2TAG_PACKET_7_0_2);\n+  movsd(xmm0, Address(rsp, 8));\n+  movsd(xmm3, Address(rsp, 8));\n+  movdl(edx, xmm3);\n+  psrlq(xmm3, 32);\n+  movdl(ecx, xmm3);\n+  orl(edx, ecx);\n+  cmpl(edx, 0);\n+  jcc(Assembler::equal, L_2TAG_PACKET_11_0_2);\n+  xorpd(xmm3, xmm3);\n+  movl(eax, 18416);\n+  pinsrw(xmm3, eax, 3);\n+  mulsd(xmm0, xmm3);\n+  xorpd(xmm2, xmm2);\n+  movl(eax, 16368);\n+  pinsrw(xmm2, eax, 3);\n+  movdqu(xmm3, xmm0);\n+  pextrw(eax, xmm0, 3);\n+  por(xmm0, xmm2);\n+  movl(ecx, 18416);\n+  psllq(xmm0, 5);\n+  movsd(xmm2, Address(tmp, 8256));\n+  psrlq(xmm0, 34);\n+  rcpss(xmm0, xmm0);\n+  psllq(xmm3, 12);\n+  movdqu(xmm6, Address(tmp, 8240));\n+  psrlq(xmm3, 12);\n+  mulss(xmm0, xmm7);\n+  movl(edx, -1024);\n+  movdl(xmm5, edx);\n+  por(xmm3, xmm1);\n+  paddd(xmm0, xmm4);\n+  psllq(xmm5, 32);\n+  movdl(edx, xmm0);\n+  psllq(xmm0, 29);\n+  pand(xmm5, xmm3);\n+  movl(rsi, INT_MIN);\n+  pand(xmm0, xmm6);\n+  subsd(xmm3, xmm5);\n+  andl(eax, 32752);\n+  subl(eax, 18416);\n+  sarl(eax, 4);\n+  cvtsi2sdl(xmm7, eax);\n+  mulpd(xmm5, xmm0);\n+  jmp(L_2TAG_PACKET_4_0_2);\n+\n+  bind(L_2TAG_PACKET_5_0_2);\n+  cmpl(eax, 0);\n+  jcc(Assembler::less, L_2TAG_PACKET_13_0_2);\n+  cmpl(eax, 752);\n+  jcc(Assembler::aboveEqual, L_2TAG_PACKET_14_0_2);\n+\n+  bind(L_2TAG_PACKET_15_0_2);\n+  addsd(xmm0, xmm7);\n+  movsd(xmm2, Address(tmp, 12544));\n+  addpd(xmm3, xmm0);\n+  xorpd(xmm6, xmm6);\n+  movl(eax, 17080);\n+  pinsrw(xmm6, eax, 3);\n+  pshufd(xmm0, xmm3, 238);\n+  addsd(xmm0, xmm3);\n+  movdqu(xmm3, xmm5);\n+  addsd(xmm5, xmm0);\n+  movdqu(xmm4, xmm2);\n+  subsd(xmm3, xmm5);\n+  movdqu(xmm7, xmm5);\n+  pand(xmm5, xmm2);\n+  movdqu(xmm2, xmm1);\n+  pand(xmm4, xmm1);\n+  subsd(xmm7, xmm5);\n+  addsd(xmm0, xmm3);\n+  subsd(xmm1, xmm4);\n+  mulsd(xmm4, xmm5);\n+  addsd(xmm0, xmm7);\n+  mulsd(xmm2, xmm0);\n+  movdqu(xmm7, xmm6);\n+  mulsd(xmm1, xmm5);\n+  addsd(xmm6, xmm4);\n+  movdl(eax, xmm6);\n+  subsd(xmm6, xmm7);\n+  addsd(xmm2, xmm1);\n+  movdqu(xmm7, Address(tmp, 12480));\n+  movdqu(xmm3, Address(tmp, 12496));\n+  subsd(xmm4, xmm6);\n+  pextrw(edx, xmm6, 3);\n+  movl(ecx, eax);\n+  andl(eax, 255);\n+  addl(eax, eax);\n+  movdqu(xmm5, Address(tmp, eax, Address::times_8, 8384));\n+  addsd(xmm2, xmm4);\n+  sarl(ecx, 8);\n+  movl(eax, ecx);\n+  sarl(ecx, 1);\n+  subl(eax, ecx);\n+  shll(ecx, 20);\n+  xorl(ecx, rsi);\n+  movdl(xmm6, ecx);\n+  movsd(xmm1, Address(tmp, 12512));\n+  andl(edx, 32767);\n+  cmpl(edx, 16529);\n+  jcc(Assembler::above, L_2TAG_PACKET_14_0_2);\n+  pshufd(xmm0, xmm2, 68);\n+  pshufd(xmm4, xmm2, 68);\n+  mulpd(xmm0, xmm0);\n+  mulpd(xmm7, xmm4);\n+  pshufd(xmm6, xmm6, 17);\n+  mulsd(xmm1, xmm2);\n+  mulsd(xmm0, xmm0);\n+  paddd(xmm5, xmm6);\n+  addpd(xmm3, xmm7);\n+  mulsd(xmm1, xmm5);\n+  pshufd(xmm6, xmm5, 238);\n+  mulpd(xmm0, xmm3);\n+  addsd(xmm1, xmm6);\n+  pshufd(xmm3, xmm0, 238);\n+  mulsd(xmm0, xmm5);\n+  mulsd(xmm3, xmm5);\n+  shll(eax, 4);\n+  xorpd(xmm4, xmm4);\n+  addl(eax, 16368);\n+  pinsrw(xmm4, eax, 3);\n+  addsd(xmm0, xmm1);\n+  movl(rsi, Address(rsp, 24));\n+  addsd(xmm0, xmm3);\n+  movdqu(xmm1, xmm0);\n+  addsd(xmm0, xmm5);\n+  mulsd(xmm0, xmm4);\n+  pextrw(eax, xmm0, 3);\n+  andl(eax, 32752);\n+  jcc(Assembler::equal, L_2TAG_PACKET_16_0_2);\n+  cmpl(eax, 32752);\n+  jcc(Assembler::equal, L_2TAG_PACKET_17_0_2);\n+\n+  bind(L_2TAG_PACKET_18_0_2);\n+  movsd(Address(rsp, 0), xmm0);\n+  fld_d(Address(rsp, 0));\n+  jmp(L_2TAG_PACKET_6_0_2);\n+\n+  bind(L_2TAG_PACKET_8_0_2);\n+  movsd(xmm1, Address(rsp, 16));\n+  movsd(xmm0, Address(rsp, 8));\n+  movdqu(xmm2, xmm0);\n+  movdl(eax, xmm2);\n+  psrlq(xmm2, 20);\n+  movdl(edx, xmm2);\n+  orl(eax, edx);\n+  jcc(Assembler::equal, L_2TAG_PACKET_19_0_2);\n+  addsd(xmm0, xmm0);\n+  movdl(eax, xmm1);\n+  psrlq(xmm1, 32);\n+  movdl(edx, xmm1);\n+  movl(ecx, edx);\n+  addl(edx, edx);\n+  orl(eax, edx);\n+  jcc(Assembler::equal, L_2TAG_PACKET_20_0_2);\n+  jmp(L_2TAG_PACKET_18_0_2);\n+\n+  bind(L_2TAG_PACKET_20_0_2);\n+  xorpd(xmm0, xmm0);\n+  movl(eax, 16368);\n+  pinsrw(xmm0, eax, 3);\n+  movl(edx, 29);\n+  jmp(L_2TAG_PACKET_21_0_2);\n+\n+  bind(L_2TAG_PACKET_22_0_2);\n+  movsd(xmm0, Address(rsp, 16));\n+  addpd(xmm0, xmm0);\n+  jmp(L_2TAG_PACKET_18_0_2);\n+\n+  bind(L_2TAG_PACKET_19_0_2);\n+  movdl(eax, xmm1);\n+  movdqu(xmm2, xmm1);\n+  psrlq(xmm1, 32);\n+  movdl(edx, xmm1);\n+  movl(ecx, edx);\n+  addl(edx, edx);\n+  orl(eax, edx);\n+  jcc(Assembler::equal, L_2TAG_PACKET_23_0_2);\n+  pextrw(eax, xmm2, 3);\n+  andl(eax, 32752);\n+  cmpl(eax, 32752);\n+  jcc(Assembler::notEqual, L_2TAG_PACKET_24_0_2);\n+  movdl(eax, xmm2);\n+  psrlq(xmm2, 20);\n+  movdl(edx, xmm2);\n+  orl(eax, edx);\n+  jcc(Assembler::notEqual, L_2TAG_PACKET_22_0_2);\n+\n+  bind(L_2TAG_PACKET_24_0_2);\n+  pextrw(eax, xmm0, 3);\n+  testl(eax, 32768);\n+  jcc(Assembler::notEqual, L_2TAG_PACKET_25_0_2);\n+  testl(ecx, INT_MIN);\n+  jcc(Assembler::notEqual, L_2TAG_PACKET_26_0_2);\n+  jmp(L_2TAG_PACKET_18_0_2);\n+\n+  bind(L_2TAG_PACKET_27_0_2);\n+  movsd(xmm1, Address(rsp, 16));\n+  movdl(eax, xmm1);\n+  testl(eax, 1);\n+  jcc(Assembler::notEqual, L_2TAG_PACKET_28_0_2);\n+  testl(eax, 2);\n+  jcc(Assembler::notEqual, L_2TAG_PACKET_29_0_2);\n+  jmp(L_2TAG_PACKET_28_0_2);\n+\n+  bind(L_2TAG_PACKET_25_0_2);\n+  shrl(ecx, 20);\n+  andl(ecx, 2047);\n+  cmpl(ecx, 1075);\n+  jcc(Assembler::above, L_2TAG_PACKET_28_0_2);\n+  jcc(Assembler::equal, L_2TAG_PACKET_30_0_2);\n+  cmpl(ecx, 1074);\n+  jcc(Assembler::above, L_2TAG_PACKET_27_0_2);\n+  cmpl(ecx, 1023);\n+  jcc(Assembler::below, L_2TAG_PACKET_28_0_2);\n+  movsd(xmm1, Address(rsp, 16));\n+  movl(eax, 17208);\n+  xorpd(xmm3, xmm3);\n+  pinsrw(xmm3, eax, 3);\n+  movdqu(xmm4, xmm3);\n+  addsd(xmm3, xmm1);\n+  subsd(xmm4, xmm3);\n+  addsd(xmm1, xmm4);\n+  pextrw(eax, xmm1, 3);\n+  andl(eax, 32752);\n+  jcc(Assembler::notEqual, L_2TAG_PACKET_28_0_2);\n+  movdl(eax, xmm3);\n+  andl(eax, 1);\n+  jcc(Assembler::equal, L_2TAG_PACKET_28_0_2);\n+\n+  bind(L_2TAG_PACKET_29_0_2);\n+  movsd(xmm1, Address(rsp, 16));\n+  pextrw(eax, xmm1, 3);\n+  andl(eax, 32768);\n+  jcc(Assembler::equal, L_2TAG_PACKET_18_0_2);\n+  xorpd(xmm0, xmm0);\n+  movl(eax, 32768);\n+  pinsrw(xmm0, eax, 3);\n+  jmp(L_2TAG_PACKET_18_0_2);\n+\n+  bind(L_2TAG_PACKET_28_0_2);\n+  movsd(xmm1, Address(rsp, 16));\n+  pextrw(eax, xmm1, 3);\n+  andl(eax, 32768);\n+  jcc(Assembler::notEqual, L_2TAG_PACKET_26_0_2);\n+\n+  bind(L_2TAG_PACKET_31_0_2);\n+  xorpd(xmm0, xmm0);\n+  movl(eax, 32752);\n+  pinsrw(xmm0, eax, 3);\n+  jmp(L_2TAG_PACKET_18_0_2);\n+\n+  bind(L_2TAG_PACKET_30_0_2);\n+  movsd(xmm1, Address(rsp, 16));\n+  movdl(eax, xmm1);\n+  andl(eax, 1);\n+  jcc(Assembler::equal, L_2TAG_PACKET_28_0_2);\n+  jmp(L_2TAG_PACKET_29_0_2);\n+\n+  bind(L_2TAG_PACKET_32_0_2);\n+  movdl(eax, xmm1);\n+  psrlq(xmm1, 20);\n+  movdl(edx, xmm1);\n+  orl(eax, edx);\n+  jcc(Assembler::equal, L_2TAG_PACKET_33_0_2);\n+  movsd(xmm0, Address(rsp, 16));\n+  addsd(xmm0, xmm0);\n+  jmp(L_2TAG_PACKET_18_0_2);\n+\n+  bind(L_2TAG_PACKET_33_0_2);\n+  movsd(xmm0, Address(rsp, 8));\n+  pextrw(eax, xmm0, 3);\n+  cmpl(eax, 49136);\n+  jcc(Assembler::notEqual, L_2TAG_PACKET_34_0_2);\n+  movdl(ecx, xmm0);\n+  psrlq(xmm0, 20);\n+  movdl(edx, xmm0);\n+  orl(ecx, edx);\n+  jcc(Assembler::notEqual, L_2TAG_PACKET_34_0_2);\n+  xorpd(xmm0, xmm0);\n+  movl(eax, 32760);\n+  pinsrw(xmm0, eax, 3);\n+  jmp(L_2TAG_PACKET_18_0_2);\n+\n+  bind(L_2TAG_PACKET_34_0_2);\n+  movsd(xmm1, Address(rsp, 16));\n+  andl(eax, 32752);\n+  subl(eax, 16368);\n+  pextrw(edx, xmm1, 3);\n+  xorpd(xmm0, xmm0);\n+  xorl(eax, edx);\n+  andl(eax, 32768);\n+  jcc(Assembler::notEqual, L_2TAG_PACKET_18_0_2);\n+  movl(ecx, 32752);\n+  pinsrw(xmm0, ecx, 3);\n+  jmp(L_2TAG_PACKET_18_0_2);\n+\n+  bind(L_2TAG_PACKET_35_0_2);\n+  movdl(eax, xmm1);\n+  cmpl(edx, 17184);\n+  jcc(Assembler::above, L_2TAG_PACKET_36_0_2);\n+  testl(eax, 1);\n+  jcc(Assembler::notEqual, L_2TAG_PACKET_37_0_2);\n+  testl(eax, 2);\n+  jcc(Assembler::equal, L_2TAG_PACKET_38_0_2);\n+  jmp(L_2TAG_PACKET_39_0_2);\n+\n+  bind(L_2TAG_PACKET_36_0_2);\n+  testl(eax, 1);\n+  jcc(Assembler::equal, L_2TAG_PACKET_38_0_2);\n+  jmp(L_2TAG_PACKET_39_0_2);\n+\n+  bind(L_2TAG_PACKET_9_0_2);\n+  movsd(xmm2, Address(rsp, 8));\n+  movdl(eax, xmm2);\n+  psrlq(xmm2, 31);\n+  movdl(ecx, xmm2);\n+  orl(eax, ecx);\n+  jcc(Assembler::equal, L_2TAG_PACKET_11_0_2);\n+  movsd(xmm1, Address(rsp, 16));\n+  pextrw(edx, xmm1, 3);\n+  movdl(eax, xmm1);\n+  movdqu(xmm2, xmm1);\n+  psrlq(xmm2, 32);\n+  movdl(ecx, xmm2);\n+  addl(ecx, ecx);\n+  orl(ecx, eax);\n+  jcc(Assembler::equal, L_2TAG_PACKET_40_0_2);\n+  andl(edx, 32752);\n+  cmpl(edx, 32752);\n+  jcc(Assembler::equal, L_2TAG_PACKET_32_0_2);\n+  cmpl(edx, 17200);\n+  jcc(Assembler::above, L_2TAG_PACKET_38_0_2);\n+  cmpl(edx, 17184);\n+  jcc(Assembler::aboveEqual, L_2TAG_PACKET_35_0_2);\n+  cmpl(edx, 16368);\n+  jcc(Assembler::below, L_2TAG_PACKET_37_0_2);\n+  movl(eax, 17208);\n+  xorpd(xmm2, xmm2);\n+  pinsrw(xmm2, eax, 3);\n+  movdqu(xmm4, xmm2);\n+  addsd(xmm2, xmm1);\n+  subsd(xmm4, xmm2);\n+  addsd(xmm1, xmm4);\n+  pextrw(eax, xmm1, 3);\n+  andl(eax, 32767);\n+  jcc(Assembler::notEqual, L_2TAG_PACKET_37_0_2);\n+  movdl(eax, xmm2);\n+  andl(eax, 1);\n+  jcc(Assembler::equal, L_2TAG_PACKET_38_0_2);\n+\n+  bind(L_2TAG_PACKET_39_0_2);\n+  xorpd(xmm1, xmm1);\n+  movl(edx, 30704);\n+  pinsrw(xmm1, edx, 3);\n+  movsd(xmm2, Address(tmp, 8256));\n+  movsd(xmm4, Address(rsp, 8));\n+  pextrw(eax, xmm4, 3);\n+  movl(edx, 8192);\n+  movdl(xmm4, edx);\n+  andl(eax, 32767);\n+  subl(eax, 16);\n+  jcc(Assembler::less, L_2TAG_PACKET_12_0_2);\n+  movl(edx, eax);\n+  andl(edx, 32752);\n+  subl(edx, 16368);\n+  movl(ecx, edx);\n+  sarl(edx, 31);\n+  addl(ecx, edx);\n+  xorl(ecx, edx);\n+  addl(ecx, 16);\n+  bsrl(ecx, ecx);\n+  movl(rsi, INT_MIN);\n+  jmp(L_2TAG_PACKET_1_0_2);\n+\n+  bind(L_2TAG_PACKET_37_0_2);\n+  xorpd(xmm1, xmm1);\n+  movl(eax, 32752);\n+  pinsrw(xmm1, eax, 3);\n+  xorpd(xmm0, xmm0);\n+  mulsd(xmm0, xmm1);\n+  movl(edx, 28);\n+  jmp(L_2TAG_PACKET_21_0_2);\n+\n+  bind(L_2TAG_PACKET_38_0_2);\n+  xorpd(xmm1, xmm1);\n+  movl(edx, 30704);\n+  pinsrw(xmm1, edx, 3);\n+  movsd(xmm2, Address(tmp, 8256));\n+  movsd(xmm4, Address(rsp, 8));\n+  pextrw(eax, xmm4, 3);\n+  movl(edx, 8192);\n+  movdl(xmm4, edx);\n+  andl(eax, 32767);\n+  subl(eax, 16);\n+  jcc(Assembler::less, L_2TAG_PACKET_10_0_2);\n+  movl(edx, eax);\n+  andl(edx, 32752);\n+  subl(edx, 16368);\n+  movl(ecx, edx);\n+  sarl(edx, 31);\n+  addl(ecx, edx);\n+  xorl(ecx, edx);\n+  addl(ecx, 16);\n+  bsrl(ecx, ecx);\n+  movl(rsi, 0);\n+  jmp(L_2TAG_PACKET_1_0_2);\n+\n+  bind(L_2TAG_PACKET_23_0_2);\n+  xorpd(xmm0, xmm0);\n+  movl(eax, 16368);\n+  pinsrw(xmm0, eax, 3);\n+  jmp(L_2TAG_PACKET_18_0_2);\n+\n+  bind(L_2TAG_PACKET_26_0_2);\n+  xorpd(xmm0, xmm0);\n+  jmp(L_2TAG_PACKET_18_0_2);\n+\n+  bind(L_2TAG_PACKET_13_0_2);\n+  addl(eax, 384);\n+  cmpl(eax, 0);\n+  jcc(Assembler::less, L_2TAG_PACKET_41_0_2);\n+  mulsd(xmm5, xmm1);\n+  addsd(xmm0, xmm7);\n+  shrl(rsi, 31);\n+  addpd(xmm3, xmm0);\n+  pshufd(xmm0, xmm3, 238);\n+  addsd(xmm3, xmm0);\n+  movsd(xmm4, Address(tmp, rsi, Address::times_8, 12528));\n+  mulsd(xmm1, xmm3);\n+  xorpd(xmm0, xmm0);\n+  movl(eax, 16368);\n+  shll(rsi, 15);\n+  orl(eax, rsi);\n+  pinsrw(xmm0, eax, 3);\n+  addsd(xmm5, xmm1);\n+  movl(rsi, Address(rsp, 24));\n+  mulsd(xmm5, xmm4);\n+  addsd(xmm0, xmm5);\n+  jmp(L_2TAG_PACKET_18_0_2);\n+\n+  bind(L_2TAG_PACKET_41_0_2);\n+  movl(rsi, Address(rsp, 24));\n+  xorpd(xmm0, xmm0);\n+  movl(eax, 16368);\n+  pinsrw(xmm0, eax, 3);\n+  jmp(L_2TAG_PACKET_18_0_2);\n+\n+  bind(L_2TAG_PACKET_40_0_2);\n+  xorpd(xmm0, xmm0);\n+  movl(eax, 16368);\n+  pinsrw(xmm0, eax, 3);\n+  jmp(L_2TAG_PACKET_18_0_2);\n+\n+  bind(L_2TAG_PACKET_42_0_2);\n+  xorpd(xmm0, xmm0);\n+  movl(eax, 16368);\n+  pinsrw(xmm0, eax, 3);\n+  movl(edx, 26);\n+  jmp(L_2TAG_PACKET_21_0_2);\n+\n+  bind(L_2TAG_PACKET_11_0_2);\n+  movsd(xmm1, Address(rsp, 16));\n+  movdqu(xmm2, xmm1);\n+  pextrw(eax, xmm1, 3);\n+  andl(eax, 32752);\n+  cmpl(eax, 32752);\n+  jcc(Assembler::notEqual, L_2TAG_PACKET_43_0_2);\n+  movdl(eax, xmm2);\n+  psrlq(xmm2, 20);\n+  movdl(edx, xmm2);\n+  orl(eax, edx);\n+  jcc(Assembler::notEqual, L_2TAG_PACKET_22_0_2);\n+\n+  bind(L_2TAG_PACKET_43_0_2);\n+  movdl(eax, xmm1);\n+  psrlq(xmm1, 32);\n+  movdl(edx, xmm1);\n+  movl(ecx, edx);\n+  addl(edx, edx);\n+  orl(eax, edx);\n+  jcc(Assembler::equal, L_2TAG_PACKET_42_0_2);\n+  shrl(edx, 21);\n+  cmpl(edx, 1075);\n+  jcc(Assembler::above, L_2TAG_PACKET_44_0_2);\n+  jcc(Assembler::equal, L_2TAG_PACKET_45_0_2);\n+  cmpl(edx, 1023);\n+  jcc(Assembler::below, L_2TAG_PACKET_44_0_2);\n+  movsd(xmm1, Address(rsp, 16));\n+  movl(eax, 17208);\n+  xorpd(xmm3, xmm3);\n+  pinsrw(xmm3, eax, 3);\n+  movdqu(xmm4, xmm3);\n+  addsd(xmm3, xmm1);\n+  subsd(xmm4, xmm3);\n+  addsd(xmm1, xmm4);\n+  pextrw(eax, xmm1, 3);\n+  andl(eax, 32752);\n+  jcc(Assembler::notEqual, L_2TAG_PACKET_44_0_2);\n+  movdl(eax, xmm3);\n+  andl(eax, 1);\n+  jcc(Assembler::equal, L_2TAG_PACKET_44_0_2);\n+\n+  bind(L_2TAG_PACKET_46_0_2);\n+  movsd(xmm0, Address(rsp, 8));\n+  testl(ecx, INT_MIN);\n+  jcc(Assembler::notEqual, L_2TAG_PACKET_47_0_2);\n+  jmp(L_2TAG_PACKET_18_0_2);\n+\n+  bind(L_2TAG_PACKET_45_0_2);\n+  movsd(xmm1, Address(rsp, 16));\n+  movdl(eax, xmm1);\n+  testl(eax, 1);\n+  jcc(Assembler::notEqual, L_2TAG_PACKET_46_0_2);\n+\n+  bind(L_2TAG_PACKET_44_0_2);\n+  testl(ecx, INT_MIN);\n+  jcc(Assembler::equal, L_2TAG_PACKET_26_0_2);\n+  xorpd(xmm0, xmm0);\n+\n+  bind(L_2TAG_PACKET_47_0_2);\n+  movl(eax, 16368);\n+  xorpd(xmm1, xmm1);\n+  pinsrw(xmm1, eax, 3);\n+  divsd(xmm1, xmm0);\n+  movdqu(xmm0, xmm1);\n+  movl(edx, 27);\n+  jmp(L_2TAG_PACKET_21_0_2);\n+\n+  bind(L_2TAG_PACKET_14_0_2);\n+  movsd(xmm2, Address(rsp, 8));\n+  movsd(xmm6, Address(rsp, 16));\n+  pextrw(eax, xmm2, 3);\n+  pextrw(edx, xmm6, 3);\n+  movl(ecx, 32752);\n+  andl(ecx, edx);\n+  cmpl(ecx, 32752);\n+  jcc(Assembler::equal, L_2TAG_PACKET_48_0_2);\n+  andl(eax, 32752);\n+  subl(eax, 16368);\n+  xorl(edx, eax);\n+  testl(edx, 32768);\n+  jcc(Assembler::notEqual, L_2TAG_PACKET_49_0_2);\n+\n+  bind(L_2TAG_PACKET_50_0_2);\n+  movl(eax, 32736);\n+  pinsrw(xmm0, eax, 3);\n+  shrl(rsi, 16);\n+  orl(eax, rsi);\n+  pinsrw(xmm1, eax, 3);\n+  movl(rsi, Address(rsp, 24));\n+  mulsd(xmm0, xmm1);\n+\n+  bind(L_2TAG_PACKET_17_0_2);\n+  movl(edx, 24);\n+\n+  bind(L_2TAG_PACKET_21_0_2);\n+  movsd(Address(rsp, 0), xmm0);\n+  fld_d(Address(rsp, 0));\n+  jmp(L_2TAG_PACKET_6_0_2);\n+\n+  bind(L_2TAG_PACKET_49_0_2);\n+  movl(eax, 16);\n+  pinsrw(xmm0, eax, 3);\n+  mulsd(xmm0, xmm0);\n+  testl(rsi, INT_MIN);\n+  jcc(Assembler::equal, L_2TAG_PACKET_51_0_2);\n+  movsd(xmm2, Address(tmp, 12560));\n+  xorpd(xmm0, xmm2);\n+\n+  bind(L_2TAG_PACKET_51_0_2);\n+  movl(rsi, Address(rsp, 24));\n+  movl(edx, 25);\n+  jmp(L_2TAG_PACKET_21_0_2);\n+\n+  bind(L_2TAG_PACKET_16_0_2);\n+  pextrw(ecx, xmm5, 3);\n+  pextrw(edx, xmm4, 3);\n+  movl(eax, -1);\n+  andl(ecx, 32752);\n+  subl(ecx, 16368);\n+  andl(edx, 32752);\n+  addl(edx, ecx);\n+  movl(ecx, -31);\n+  sarl(edx, 4);\n+  subl(ecx, edx);\n+  jcc(Assembler::lessEqual, L_2TAG_PACKET_52_0_2);\n+  cmpl(ecx, 20);\n+  jcc(Assembler::above, L_2TAG_PACKET_53_0_2);\n+  shll(eax);\n+\n+  bind(L_2TAG_PACKET_52_0_2);\n+  movdl(xmm0, eax);\n+  psllq(xmm0, 32);\n+  pand(xmm0, xmm5);\n+  subsd(xmm5, xmm0);\n+  addsd(xmm5, xmm1);\n+  mulsd(xmm0, xmm4);\n+  mulsd(xmm5, xmm4);\n+  addsd(xmm0, xmm5);\n+\n+  bind(L_2TAG_PACKET_53_0_2);\n+  movl(edx, 25);\n+  jmp(L_2TAG_PACKET_21_0_2);\n+\n+  bind(L_2TAG_PACKET_2_0_2);\n+  movzwl(ecx, Address(rsp, 22));\n+  movl(edx, INT_MIN);\n+  movdl(xmm1, edx);\n+  xorpd(xmm7, xmm7);\n+  paddd(xmm0, xmm4);\n+  psllq(xmm5, 32);\n+  movdl(edx, xmm0);\n+  psllq(xmm0, 29);\n+  paddq(xmm1, xmm3);\n+  pand(xmm5, xmm1);\n+  andl(ecx, 32752);\n+  cmpl(ecx, 16560);\n+  jcc(Assembler::below, L_2TAG_PACKET_3_0_2);\n+  pand(xmm0, xmm6);\n+  subsd(xmm3, xmm5);\n+  addl(eax, 16351);\n+  shrl(eax, 4);\n+  subl(eax, 1022);\n+  cvtsi2sdl(xmm7, eax);\n+  mulpd(xmm5, xmm0);\n+  movsd(xmm4, Address(tmp, 0));\n+  mulsd(xmm3, xmm0);\n+  movsd(xmm6, Address(tmp, 0));\n+  subsd(xmm5, xmm2);\n+  movsd(xmm1, Address(tmp, 8));\n+  pshufd(xmm2, xmm3, 68);\n+  unpcklpd(xmm5, xmm3);\n+  addsd(xmm3, xmm5);\n+  movsd(xmm0, Address(tmp, 8));\n+  andl(edx, 16760832);\n+  shrl(edx, 10);\n+  addpd(xmm7, Address(tmp, edx, Address::times_1, -3616));\n+  mulsd(xmm4, xmm5);\n+  mulsd(xmm0, xmm5);\n+  mulsd(xmm6, xmm2);\n+  mulsd(xmm1, xmm2);\n+  movdqu(xmm2, xmm5);\n+  mulsd(xmm4, xmm5);\n+  addsd(xmm5, xmm0);\n+  movdqu(xmm0, xmm7);\n+  addsd(xmm2, xmm3);\n+  addsd(xmm7, xmm5);\n+  mulsd(xmm6, xmm2);\n+  subsd(xmm0, xmm7);\n+  movdqu(xmm2, xmm7);\n+  addsd(xmm7, xmm4);\n+  addsd(xmm0, xmm5);\n+  subsd(xmm2, xmm7);\n+  addsd(xmm4, xmm2);\n+  pshufd(xmm2, xmm5, 238);\n+  movdqu(xmm5, xmm7);\n+  addsd(xmm7, xmm2);\n+  addsd(xmm4, xmm0);\n+  movdqu(xmm0, Address(tmp, 8272));\n+  subsd(xmm5, xmm7);\n+  addsd(xmm6, xmm4);\n+  movdqu(xmm4, xmm7);\n+  addsd(xmm5, xmm2);\n+  addsd(xmm7, xmm1);\n+  movdqu(xmm2, Address(tmp, 8336));\n+  subsd(xmm4, xmm7);\n+  addsd(xmm6, xmm5);\n+  addsd(xmm4, xmm1);\n+  pshufd(xmm5, xmm7, 238);\n+  movdqu(xmm1, xmm7);\n+  addsd(xmm7, xmm5);\n+  subsd(xmm1, xmm7);\n+  addsd(xmm1, xmm5);\n+  movdqu(xmm5, Address(tmp, 8352));\n+  pshufd(xmm3, xmm3, 68);\n+  addsd(xmm6, xmm4);\n+  addsd(xmm6, xmm1);\n+  movdqu(xmm1, Address(tmp, 8304));\n+  mulpd(xmm0, xmm3);\n+  mulpd(xmm2, xmm3);\n+  pshufd(xmm4, xmm3, 68);\n+  mulpd(xmm3, xmm3);\n+  addpd(xmm0, xmm1);\n+  addpd(xmm5, xmm2);\n+  mulsd(xmm4, xmm3);\n+  movsd(xmm2, Address(tmp, 16));\n+  mulpd(xmm3, xmm3);\n+  movsd(xmm1, Address(rsp, 16));\n+  movzwl(ecx, Address(rsp, 22));\n+  mulpd(xmm0, xmm4);\n+  pextrw(eax, xmm7, 3);\n+  mulpd(xmm5, xmm4);\n+  mulpd(xmm0, xmm3);\n+  movsd(xmm4, Address(tmp, 8376));\n+  pand(xmm2, xmm7);\n+  addsd(xmm5, xmm6);\n+  subsd(xmm7, xmm2);\n+  addpd(xmm5, xmm0);\n+  andl(eax, 32752);\n+  subl(eax, 16368);\n+  andl(ecx, 32752);\n+  cmpl(ecx, 32752);\n+  jcc(Assembler::equal, L_2TAG_PACKET_48_0_2);\n+  addl(ecx, eax);\n+  cmpl(ecx, 16576);\n+  jcc(Assembler::aboveEqual, L_2TAG_PACKET_54_0_2);\n+  pshufd(xmm0, xmm5, 238);\n+  pand(xmm4, xmm1);\n+  movdqu(xmm3, xmm1);\n+  addsd(xmm5, xmm0);\n+  subsd(xmm1, xmm4);\n+  xorpd(xmm6, xmm6);\n+  movl(edx, 17080);\n+  pinsrw(xmm6, edx, 3);\n+  addsd(xmm7, xmm5);\n+  mulsd(xmm4, xmm2);\n+  mulsd(xmm1, xmm2);\n+  movdqu(xmm5, xmm6);\n+  mulsd(xmm3, xmm7);\n+  addsd(xmm6, xmm4);\n+  addsd(xmm1, xmm3);\n+  movdqu(xmm7, Address(tmp, 12480));\n+  movdl(edx, xmm6);\n+  subsd(xmm6, xmm5);\n+  movdqu(xmm3, Address(tmp, 12496));\n+  movsd(xmm2, Address(tmp, 12512));\n+  subsd(xmm4, xmm6);\n+  movl(ecx, edx);\n+  andl(edx, 255);\n+  addl(edx, edx);\n+  movdqu(xmm5, Address(tmp, edx, Address::times_8, 8384));\n+  addsd(xmm4, xmm1);\n+  pextrw(edx, xmm6, 3);\n+  shrl(ecx, 8);\n+  movl(eax, ecx);\n+  shrl(ecx, 1);\n+  subl(eax, ecx);\n+  shll(ecx, 20);\n+  movdl(xmm6, ecx);\n+  pshufd(xmm0, xmm4, 68);\n+  pshufd(xmm1, xmm4, 68);\n+  mulpd(xmm0, xmm0);\n+  mulpd(xmm7, xmm1);\n+  pshufd(xmm6, xmm6, 17);\n+  mulsd(xmm2, xmm4);\n+  andl(edx, 32767);\n+  cmpl(edx, 16529);\n+  jcc(Assembler::above, L_2TAG_PACKET_14_0_2);\n+  mulsd(xmm0, xmm0);\n+  paddd(xmm5, xmm6);\n+  addpd(xmm3, xmm7);\n+  mulsd(xmm2, xmm5);\n+  pshufd(xmm6, xmm5, 238);\n+  mulpd(xmm0, xmm3);\n+  addsd(xmm2, xmm6);\n+  pshufd(xmm3, xmm0, 238);\n+  addl(eax, 1023);\n+  shll(eax, 20);\n+  orl(eax, rsi);\n+  movdl(xmm4, eax);\n+  mulsd(xmm0, xmm5);\n+  mulsd(xmm3, xmm5);\n+  addsd(xmm0, xmm2);\n+  psllq(xmm4, 32);\n+  addsd(xmm0, xmm3);\n+  movdqu(xmm1, xmm0);\n+  addsd(xmm0, xmm5);\n+  movl(rsi, Address(rsp, 24));\n+  mulsd(xmm0, xmm4);\n+  pextrw(eax, xmm0, 3);\n+  andl(eax, 32752);\n+  jcc(Assembler::equal, L_2TAG_PACKET_16_0_2);\n+  cmpl(eax, 32752);\n+  jcc(Assembler::equal, L_2TAG_PACKET_17_0_2);\n+\n+  bind(L_2TAG_PACKET_55_0_2);\n+  movsd(Address(rsp, 0), xmm0);\n+  fld_d(Address(rsp, 0));\n+  jmp(L_2TAG_PACKET_6_0_2);\n+\n+  bind(L_2TAG_PACKET_48_0_2);\n+  movl(rsi, Address(rsp, 24));\n+\n+  bind(L_2TAG_PACKET_56_0_2);\n+  movsd(xmm0, Address(rsp, 8));\n+  movsd(xmm1, Address(rsp, 16));\n+  addsd(xmm1, xmm1);\n+  xorpd(xmm2, xmm2);\n+  movl(eax, 49136);\n+  pinsrw(xmm2, eax, 3);\n+  addsd(xmm2, xmm0);\n+  pextrw(eax, xmm2, 3);\n+  cmpl(eax, 0);\n+  jcc(Assembler::notEqual, L_2TAG_PACKET_57_0_2);\n+  xorpd(xmm0, xmm0);\n+  movl(eax, 32760);\n+  pinsrw(xmm0, eax, 3);\n+  jmp(L_2TAG_PACKET_18_0_2);\n+\n+  bind(L_2TAG_PACKET_57_0_2);\n+  movdl(edx, xmm1);\n+  movdqu(xmm3, xmm1);\n+  psrlq(xmm3, 20);\n+  movdl(ecx, xmm3);\n+  orl(ecx, edx);\n+  jcc(Assembler::equal, L_2TAG_PACKET_58_0_2);\n+  addsd(xmm1, xmm1);\n+  movdqu(xmm0, xmm1);\n+  jmp(L_2TAG_PACKET_18_0_2);\n+\n+  bind(L_2TAG_PACKET_58_0_2);\n+  pextrw(eax, xmm0, 3);\n+  andl(eax, 32752);\n+  pextrw(edx, xmm1, 3);\n+  xorpd(xmm0, xmm0);\n+  subl(eax, 16368);\n+  xorl(eax, edx);\n+  testl(eax, 32768);\n+  jcc(Assembler::notEqual, L_2TAG_PACKET_18_0_2);\n+  movl(edx, 32752);\n+  pinsrw(xmm0, edx, 3);\n+  jmp(L_2TAG_PACKET_18_0_2);\n+\n+  bind(L_2TAG_PACKET_54_0_2);\n+  pextrw(eax, xmm1, 3);\n+  pextrw(ecx, xmm2, 3);\n+  xorl(eax, ecx);\n+  testl(eax, 32768);\n+  jcc(Assembler::equal, L_2TAG_PACKET_50_0_2);\n+  jmp(L_2TAG_PACKET_49_0_2);\n+\n+  bind(L_2TAG_PACKET_6_0_2);\n+  movl(tmp, Address(rsp, 64));\n+\n+}\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86_32_pow.cpp","additions":1856,"deletions":0,"binary":false,"changes":1856,"status":"added"},{"patch":"@@ -0,0 +1,1743 @@\n+\/*\n+* Copyright (c) 2016, 2021, Intel Corporation. All rights reserved.\n+* Intel Math Library (LIBM) Source Code\n+*\n+* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+*\n+* This code is free software; you can redistribute it and\/or modify it\n+* under the terms of the GNU General Public License version 2 only, as\n+* published by the Free Software Foundation.\n+*\n+* This code is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+* FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+* version 2 for more details (a copy is included in the LICENSE file that\n+* accompanied this code).\n+*\n+* You should have received a copy of the GNU General Public License version\n+* 2 along with this work; if not, write to the Free Software Foundation,\n+* Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+*\n+* Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+* or visit www.oracle.com if you need additional information or have any\n+* questions.\n+*\n+*\/\n+\n+#include \"precompiled.hpp\"\n+#include \"asm\/assembler.hpp\"\n+#include \"asm\/assembler.inline.hpp\"\n+#include \"macroAssembler_x86.hpp\"\n+#include \"runtime\/stubRoutines.hpp\"\n+#include \"stubRoutines_x86.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+\/******************************************************************************\/\n+\/\/                     ALGORITHM DESCRIPTION - SIN()\n+\/\/                     ---------------------\n+\/\/\n+\/\/     1. RANGE REDUCTION\n+\/\/\n+\/\/     We perform an initial range reduction from X to r with\n+\/\/\n+\/\/          X =~= N * pi\/32 + r\n+\/\/\n+\/\/     so that |r| <= pi\/64 + epsilon. We restrict inputs to those\n+\/\/     where |N| <= 932560. Beyond this, the range reduction is\n+\/\/     insufficiently accurate. For extremely small inputs,\n+\/\/     denormalization can occur internally, impacting performance.\n+\/\/     This means that the main path is actually only taken for\n+\/\/     2^-252 <= |X| < 90112.\n+\/\/\n+\/\/     To avoid branches, we perform the range reduction to full\n+\/\/     accuracy each time.\n+\/\/\n+\/\/          X - N * (P_1 + P_2 + P_3)\n+\/\/\n+\/\/     where P_1 and P_2 are 32-bit numbers (so multiplication by N\n+\/\/     is exact) and P_3 is a 53-bit number. Together, these\n+\/\/     approximate pi well enough for all cases in the restricted\n+\/\/     range.\n+\/\/\n+\/\/     The main reduction sequence is:\n+\/\/\n+\/\/             y = 32\/pi * x\n+\/\/             N = integer(y)\n+\/\/     (computed by adding and subtracting off SHIFTER)\n+\/\/\n+\/\/             m_1 = N * P_1\n+\/\/             m_2 = N * P_2\n+\/\/             r_1 = x - m_1\n+\/\/             r = r_1 - m_2\n+\/\/     (this r can be used for most of the calculation)\n+\/\/\n+\/\/             c_1 = r_1 - r\n+\/\/             m_3 = N * P_3\n+\/\/             c_2 = c_1 - m_2\n+\/\/             c = c_2 - m_3\n+\/\/\n+\/\/     2. MAIN ALGORITHM\n+\/\/\n+\/\/     The algorithm uses a table lookup based on B = M * pi \/ 32\n+\/\/     where M = N mod 64. The stored values are:\n+\/\/       sigma             closest power of 2 to cos(B)\n+\/\/       C_hl              53-bit cos(B) - sigma\n+\/\/       S_hi + S_lo       2 * 53-bit sin(B)\n+\/\/\n+\/\/     The computation is organized as follows:\n+\/\/\n+\/\/          sin(B + r + c) = [sin(B) + sigma * r] +\n+\/\/                           r * (cos(B) - sigma) +\n+\/\/                           sin(B) * [cos(r + c) - 1] +\n+\/\/                           cos(B) * [sin(r + c) - r]\n+\/\/\n+\/\/     which is approximately:\n+\/\/\n+\/\/          [S_hi + sigma * r] +\n+\/\/          C_hl * r +\n+\/\/          S_lo + S_hi * [(cos(r) - 1) - r * c] +\n+\/\/          (C_hl + sigma) * [(sin(r) - r) + c]\n+\/\/\n+\/\/     and this is what is actually computed. We separate this sum\n+\/\/     into four parts:\n+\/\/\n+\/\/          hi + med + pols + corr\n+\/\/\n+\/\/     where\n+\/\/\n+\/\/          hi       = S_hi + sigma r\n+\/\/          med      = C_hl * r\n+\/\/          pols     = S_hi * (cos(r) - 1) + (C_hl + sigma) * (sin(r) - r)\n+\/\/          corr     = S_lo + c * ((C_hl + sigma) - S_hi * r)\n+\/\/\n+\/\/     3. POLYNOMIAL\n+\/\/\n+\/\/     The polynomial S_hi * (cos(r) - 1) + (C_hl + sigma) *\n+\/\/     (sin(r) - r) can be rearranged freely, since it is quite\n+\/\/     small, so we exploit parallelism to the fullest.\n+\/\/\n+\/\/          psc4       =   SC_4 * r_1\n+\/\/          msc4       =   psc4 * r\n+\/\/          r2         =   r * r\n+\/\/          msc2       =   SC_2 * r2\n+\/\/          r4         =   r2 * r2\n+\/\/          psc3       =   SC_3 + msc4\n+\/\/          psc1       =   SC_1 + msc2\n+\/\/          msc3       =   r4 * psc3\n+\/\/          sincospols =   psc1 + msc3\n+\/\/          pols       =   sincospols *\n+\/\/                         <S_hi * r^2 | (C_hl + sigma) * r^3>\n+\/\/\n+\/\/     4. CORRECTION TERM\n+\/\/\n+\/\/     This is where the \"c\" component of the range reduction is\n+\/\/     taken into account; recall that just \"r\" is used for most of\n+\/\/     the calculation.\n+\/\/\n+\/\/          -c   = m_3 - c_2\n+\/\/          -d   = S_hi * r - (C_hl + sigma)\n+\/\/          corr = -c * -d + S_lo\n+\/\/\n+\/\/     5. COMPENSATED SUMMATIONS\n+\/\/\n+\/\/     The two successive compensated summations add up the high\n+\/\/     and medium parts, leaving just the low parts to add up at\n+\/\/     the end.\n+\/\/\n+\/\/          rs        =  sigma * r\n+\/\/          res_int   =  S_hi + rs\n+\/\/          k_0       =  S_hi - res_int\n+\/\/          k_2       =  k_0 + rs\n+\/\/          med       =  C_hl * r\n+\/\/          res_hi    =  res_int + med\n+\/\/          k_1       =  res_int - res_hi\n+\/\/          k_3       =  k_1 + med\n+\/\/\n+\/\/     6. FINAL SUMMATION\n+\/\/\n+\/\/     We now add up all the small parts:\n+\/\/\n+\/\/          res_lo = pols(hi) + pols(lo) + corr + k_1 + k_3\n+\/\/\n+\/\/     Now the overall result is just:\n+\/\/\n+\/\/          res_hi + res_lo\n+\/\/\n+\/\/     7. SMALL ARGUMENTS\n+\/\/\n+\/\/     If |x| < SNN (SNN meaning the smallest normal number), we\n+\/\/     simply perform 0.1111111 cdots 1111 * x. For SNN <= |x|, we\n+\/\/     do 2^-55 * (2^55 * x - x).\n+\/\/\n+\/\/ Special cases:\n+\/\/  sin(NaN) = quiet NaN, and raise invalid exception\n+\/\/  sin(INF) = NaN and raise invalid exception\n+\/\/  sin(+\/-0) = +\/-0\n+\/\/\n+\/******************************************************************************\/\n+\n+\/\/ The 32 bit code is at most SSE2 compliant\n+ATTRIBUTE_ALIGNED(8) juint _zero_none[] =\n+{\n+    0x00000000UL, 0x00000000UL, 0x00000000UL, 0xbff00000UL\n+};\n+\n+ATTRIBUTE_ALIGNED(4) juint __4onpi_d[] =\n+{\n+    0x6dc9c883UL, 0x3ff45f30UL\n+};\n+\n+ATTRIBUTE_ALIGNED(4) juint _TWO_32H[] =\n+{\n+    0x00000000UL, 0x41f80000UL\n+};\n+\n+ATTRIBUTE_ALIGNED(4) juint _pi04_3d[] =\n+{\n+    0x54442d00UL, 0x3fe921fbUL, 0x98cc5180UL, 0x3ce84698UL, 0xcbb5bf6cUL,\n+    0xb9dfc8f8UL\n+};\n+\n+ATTRIBUTE_ALIGNED(4) juint _pi04_5d[] =\n+{\n+    0x54400000UL, 0x3fe921fbUL, 0x1a600000UL, 0x3dc0b461UL, 0x2e000000UL,\n+    0x3b93198aUL, 0x25200000UL, 0x396b839aUL, 0x533e63a0UL, 0x37027044UL\n+};\n+\n+ATTRIBUTE_ALIGNED(4) juint _SCALE[] =\n+{\n+    0x00000000UL, 0x32600000UL\n+};\n+\n+ATTRIBUTE_ALIGNED(4) juint _zeros[] =\n+{\n+    0x00000000UL, 0x00000000UL, 0x00000000UL, 0x80000000UL\n+};\n+\n+ATTRIBUTE_ALIGNED(4) juint _pi04_2d[] =\n+{\n+    0x54400000UL, 0x3fe921fbUL, 0x1a626331UL, 0x3dc0b461UL\n+};\n+\n+ATTRIBUTE_ALIGNED(4) juint _TWO_12H[] =\n+{\n+    0x00000000UL, 0x40b80000UL\n+};\n+\n+ATTRIBUTE_ALIGNED(2) jushort __4onpi_31l[] =\n+{\n+    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x836e, 0xa2f9,\n+    0x40d8, 0x0000, 0x0000, 0x0000, 0x2a50, 0x9c88, 0x40b7, 0x0000, 0x0000, 0x0000,\n+    0xabe8, 0xfe13, 0x4099, 0x0000, 0x0000, 0x0000, 0x6ee0, 0xfa9a, 0x4079, 0x0000,\n+    0x0000, 0x0000, 0x9580, 0xdb62, 0x4058, 0x0000, 0x0000, 0x0000, 0x1c82, 0xc9e2,\n+    0x403d, 0x0000, 0x0000, 0x0000, 0xb1c0, 0xff28, 0x4019, 0x0000, 0x0000, 0x0000,\n+    0xef14, 0xaf7a, 0x3ffe, 0x0000, 0x0000, 0x0000, 0x48dc, 0xc36e, 0x3fdf, 0x0000,\n+    0x0000, 0x0000, 0x3740, 0xe909, 0x3fbe, 0x0000, 0x0000, 0x0000, 0x924a, 0xb801,\n+    0x3fa2, 0x0000, 0x0000, 0x0000, 0x3a32, 0xdd41, 0x3f83, 0x0000, 0x0000, 0x0000,\n+    0x8778, 0x873f, 0x3f62, 0x0000, 0x0000, 0x0000, 0x1298, 0xb1cb, 0x3f44, 0x0000,\n+    0x0000, 0x0000, 0xa208, 0x9cfb, 0x3f26, 0x0000, 0x0000, 0x0000, 0xbaec, 0xd7d4,\n+    0x3f06, 0x0000, 0x0000, 0x0000, 0xd338, 0x8909, 0x3ee7, 0x0000, 0x0000, 0x0000,\n+    0x68b8, 0xe04d, 0x3ec7, 0x0000, 0x0000, 0x0000, 0x4e64, 0xdf90, 0x3eaa, 0x0000,\n+    0x0000, 0x0000, 0xc1a8, 0xeb1c, 0x3e89, 0x0000, 0x0000, 0x0000, 0x2720, 0xce7d,\n+    0x3e6a, 0x0000, 0x0000, 0x0000, 0x77b8, 0x8bf1, 0x3e4b, 0x0000, 0x0000, 0x0000,\n+    0xec7e, 0xe4a0, 0x3e2e, 0x0000, 0x0000, 0x0000, 0xffbc, 0xf12f, 0x3e0f, 0x0000,\n+    0x0000, 0x0000, 0xfdc0, 0xb301, 0x3deb, 0x0000, 0x0000, 0x0000, 0xc5ac, 0x9788,\n+    0x3dd1, 0x0000, 0x0000, 0x0000, 0x47da, 0x829b, 0x3db2, 0x0000, 0x0000, 0x0000,\n+    0xd9e4, 0xa6cf, 0x3d93, 0x0000, 0x0000, 0x0000, 0x36e8, 0xf961, 0x3d73, 0x0000,\n+    0x0000, 0x0000, 0xf668, 0xf463, 0x3d54, 0x0000, 0x0000, 0x0000, 0x5168, 0xf2ff,\n+    0x3d35, 0x0000, 0x0000, 0x0000, 0x758e, 0xea4f, 0x3d17, 0x0000, 0x0000, 0x0000,\n+    0xf17a, 0xebe5, 0x3cf8, 0x0000, 0x0000, 0x0000, 0x9cfa, 0x9e83, 0x3cd9, 0x0000,\n+    0x0000, 0x0000, 0xa4ba, 0xe294, 0x3cba, 0x0000, 0x0000, 0x0000, 0xd7ec, 0x9afe,\n+    0x3c9a, 0x0000, 0x0000, 0x0000, 0xae80, 0x8fc6, 0x3c79, 0x0000, 0x0000, 0x0000,\n+    0x3304, 0x8560, 0x3c5c, 0x0000, 0x0000, 0x0000, 0x6d70, 0xdf8f, 0x3c3b, 0x0000,\n+    0x0000, 0x0000, 0x3ef0, 0xafc3, 0x3c1e, 0x0000, 0x0000, 0x0000, 0xd0d8, 0x826b,\n+    0x3bfe, 0x0000, 0x0000, 0x0000, 0x1c80, 0xed4f, 0x3bdd, 0x0000, 0x0000, 0x0000,\n+    0x730c, 0xb0af, 0x3bc1, 0x0000, 0x0000, 0x0000, 0x6660, 0xc219, 0x3ba2, 0x0000,\n+    0x0000, 0x0000, 0x940c, 0xabe2, 0x3b83, 0x0000, 0x0000, 0x0000, 0xdffc, 0x8408,\n+    0x3b64, 0x0000, 0x0000, 0x0000, 0x6b98, 0xc402, 0x3b45, 0x0000, 0x0000, 0x0000,\n+    0x1818, 0x9cc4, 0x3b26, 0x0000, 0x0000, 0x0000, 0x5390, 0xaab6, 0x3b05, 0x0000,\n+    0x0000, 0x0000, 0xb070, 0xd464, 0x3ae9, 0x0000, 0x0000, 0x0000, 0x231a, 0x9ef0,\n+    0x3aca, 0x0000, 0x0000, 0x0000, 0x0670, 0xd1f1, 0x3aaa, 0x0000, 0x0000, 0x0000,\n+    0x7738, 0xd9f3, 0x3a8a, 0x0000, 0x0000, 0x0000, 0xa834, 0x8092, 0x3a6c, 0x0000,\n+    0x0000, 0x0000, 0xb45c, 0xce23, 0x3a4d, 0x0000, 0x0000, 0x0000, 0x36e8, 0xb0e5,\n+    0x3a2d, 0x0000, 0x0000, 0x0000, 0xd156, 0xaf44, 0x3a10, 0x0000, 0x0000, 0x0000,\n+    0x9f52, 0x8c82, 0x39f1, 0x0000, 0x0000, 0x0000, 0x829c, 0xff83, 0x39d1, 0x0000,\n+    0x0000, 0x0000, 0x7d06, 0xefc6, 0x39b3, 0x0000, 0x0000, 0x0000, 0x93e0, 0xb0b7,\n+    0x3992, 0x0000, 0x0000, 0x0000, 0xedde, 0xc193, 0x3975, 0x0000, 0x0000, 0x0000,\n+    0xbbc0, 0xcf49, 0x3952, 0x0000, 0x0000, 0x0000, 0xbdf0, 0xd63c, 0x3937, 0x0000,\n+    0x0000, 0x0000, 0x1f34, 0x9f3a, 0x3918, 0x0000, 0x0000, 0x0000, 0x3f8e, 0xe579,\n+    0x38f9, 0x0000, 0x0000, 0x0000, 0x90c8, 0xc3f8, 0x38d9, 0x0000, 0x0000, 0x0000,\n+    0x48c0, 0xf8f8, 0x38b7, 0x0000, 0x0000, 0x0000, 0xed56, 0xafa6, 0x389c, 0x0000,\n+    0x0000, 0x0000, 0x8218, 0xb969, 0x387d, 0x0000, 0x0000, 0x0000, 0x1852, 0xec57,\n+    0x385e, 0x0000, 0x0000, 0x0000, 0x670c, 0xd674, 0x383e, 0x0000, 0x0000, 0x0000,\n+    0xad40, 0xc2c4, 0x3820, 0x0000, 0x0000, 0x0000, 0x2e80, 0xa696, 0x3801, 0x0000,\n+    0x0000, 0x0000, 0xd800, 0xc467, 0x37dc, 0x0000, 0x0000, 0x0000, 0x3c72, 0xc5ae,\n+    0x37c3, 0x0000, 0x0000, 0x0000, 0xb006, 0xac69, 0x37a4, 0x0000, 0x0000, 0x0000,\n+    0x34a0, 0x8cdf, 0x3782, 0x0000, 0x0000, 0x0000, 0x9ed2, 0xd25e, 0x3766, 0x0000,\n+    0x0000, 0x0000, 0x6fec, 0xaaaa, 0x3747, 0x0000, 0x0000, 0x0000, 0x6040, 0xfb5c,\n+    0x3726, 0x0000, 0x0000, 0x0000, 0x764c, 0xa3fc, 0x3708, 0x0000, 0x0000, 0x0000,\n+    0xb254, 0x954e, 0x36e9, 0x0000, 0x0000, 0x0000, 0x3e1c, 0xf5dc, 0x36ca, 0x0000,\n+    0x0000, 0x0000, 0x7b06, 0xc635, 0x36ac, 0x0000, 0x0000, 0x0000, 0xa8ba, 0xd738,\n+    0x368d, 0x0000, 0x0000, 0x0000, 0x06cc, 0xb24e, 0x366d, 0x0000, 0x0000, 0x0000,\n+    0x7108, 0xac76, 0x364f, 0x0000, 0x0000, 0x0000, 0x2324, 0xa7cb, 0x3630, 0x0000,\n+    0x0000, 0x0000, 0xac40, 0xef15, 0x360f, 0x0000, 0x0000, 0x0000, 0xae46, 0xd516,\n+    0x35f2, 0x0000, 0x0000, 0x0000, 0x615e, 0xe003, 0x35d3, 0x0000, 0x0000, 0x0000,\n+    0x0cf0, 0xefe7, 0x35b1, 0x0000, 0x0000, 0x0000, 0xfb50, 0xf98c, 0x3595, 0x0000,\n+    0x0000, 0x0000, 0x0abc, 0xf333, 0x3575, 0x0000, 0x0000, 0x0000, 0xdd60, 0xca3f,\n+    0x3555, 0x0000, 0x0000, 0x0000, 0x7eb6, 0xd87f, 0x3538, 0x0000, 0x0000, 0x0000,\n+    0x44f4, 0xb291, 0x3519, 0x0000, 0x0000, 0x0000, 0xff80, 0xc982, 0x34f6, 0x0000,\n+    0x0000, 0x0000, 0x9de0, 0xd9b8, 0x34db, 0x0000, 0x0000, 0x0000, 0xcd42, 0x9366,\n+    0x34bc, 0x0000, 0x0000, 0x0000, 0xbef0, 0xfaee, 0x349d, 0x0000, 0x0000, 0x0000,\n+    0xdac4, 0xb6f1, 0x347d, 0x0000, 0x0000, 0x0000, 0xf140, 0x94de, 0x345d, 0x0000,\n+    0x0000, 0x0000, 0xa218, 0x8b4b, 0x343e, 0x0000, 0x0000, 0x0000, 0x6380, 0xa135,\n+    0x341e, 0x0000, 0x0000, 0x0000, 0xb184, 0x8cb2, 0x3402, 0x0000, 0x0000, 0x0000,\n+    0x196e, 0xdc61, 0x33e3, 0x0000, 0x0000, 0x0000, 0x0c00, 0xde05, 0x33c4, 0x0000,\n+    0x0000, 0x0000, 0xef9a, 0xbd38, 0x33a5, 0x0000, 0x0000, 0x0000, 0xc1a0, 0xdf00,\n+    0x3385, 0x0000, 0x0000, 0x0000, 0x1090, 0x9973, 0x3365, 0x0000, 0x0000, 0x0000,\n+    0x4882, 0x8301, 0x3348, 0x0000, 0x0000, 0x0000, 0x7abe, 0xadc7, 0x3329, 0x0000,\n+    0x0000, 0x0000, 0x7cba, 0xec2b, 0x330a, 0x0000, 0x0000, 0x0000, 0xa520, 0x8f21,\n+    0x32e9, 0x0000, 0x0000, 0x0000, 0x710c, 0x8d36, 0x32cc, 0x0000, 0x0000, 0x0000,\n+    0x5212, 0xc6ed, 0x32ad, 0x0000, 0x0000, 0x0000, 0x7308, 0xfd76, 0x328d, 0x0000,\n+    0x0000, 0x0000, 0x5014, 0xd548, 0x326f, 0x0000, 0x0000, 0x0000, 0xd3f2, 0xb499,\n+    0x3250, 0x0000, 0x0000, 0x0000, 0x7f74, 0xa606, 0x3230, 0x0000, 0x0000, 0x0000,\n+    0xf0a8, 0xd720, 0x3212, 0x0000, 0x0000, 0x0000, 0x185c, 0xe20f, 0x31f2, 0x0000,\n+    0x0000, 0x0000, 0xa5a8, 0x8738, 0x31d4, 0x0000, 0x0000, 0x0000, 0xdd74, 0xcafb,\n+    0x31b4, 0x0000, 0x0000, 0x0000, 0x98b6, 0xbd8e, 0x3196, 0x0000, 0x0000, 0x0000,\n+    0xe9de, 0x977f, 0x3177, 0x0000, 0x0000, 0x0000, 0x67c0, 0x818d, 0x3158, 0x0000,\n+    0x0000, 0x0000, 0xe52a, 0x9322, 0x3139, 0x0000, 0x0000, 0x0000, 0xe568, 0x9b6c,\n+    0x3119, 0x0000, 0x0000, 0x0000, 0x2358, 0xaa0a, 0x30fa, 0x0000, 0x0000, 0x0000,\n+    0xe480, 0xe13b, 0x30d9, 0x0000, 0x0000, 0x0000, 0x3024, 0x90a1, 0x30bd, 0x0000,\n+    0x0000, 0x0000, 0x9620, 0xda30, 0x309d, 0x0000, 0x0000, 0x0000, 0x898a, 0xb388,\n+    0x307f, 0x0000, 0x0000, 0x0000, 0xb24c, 0xc891, 0x3060, 0x0000, 0x0000, 0x0000,\n+    0x8056, 0xf98b, 0x3041, 0x0000, 0x0000, 0x0000, 0x72a4, 0xa1ea, 0x3021, 0x0000,\n+    0x0000, 0x0000, 0x6af8, 0x9488, 0x3001, 0x0000, 0x0000, 0x0000, 0xe00c, 0xdfcb,\n+    0x2fe4, 0x0000, 0x0000, 0x0000, 0xeeec, 0xc941, 0x2fc4, 0x0000, 0x0000, 0x0000,\n+    0x53e0, 0xe70f, 0x2fa4, 0x0000, 0x0000, 0x0000, 0x8f60, 0x9c07, 0x2f85, 0x0000,\n+    0x0000, 0x0000, 0xb328, 0xc3e7, 0x2f68, 0x0000, 0x0000, 0x0000, 0x9404, 0xf8c7,\n+    0x2f48, 0x0000, 0x0000, 0x0000, 0x38e0, 0xc99f, 0x2f29, 0x0000, 0x0000, 0x0000,\n+    0x9778, 0xd984, 0x2f09, 0x0000, 0x0000, 0x0000, 0xe700, 0xd142, 0x2eea, 0x0000,\n+    0x0000, 0x0000, 0xd904, 0x9443, 0x2ecd, 0x0000, 0x0000, 0x0000, 0xd4ba, 0xae7e,\n+    0x2eae, 0x0000, 0x0000, 0x0000, 0x8e5e, 0x8524, 0x2e8f, 0x0000, 0x0000, 0x0000,\n+    0xb550, 0xc9ed, 0x2e6e, 0x0000, 0x0000, 0x0000, 0x53b8, 0x8648, 0x2e51, 0x0000,\n+    0x0000, 0x0000, 0xdae4, 0x87f9, 0x2e32, 0x0000, 0x0000, 0x0000, 0x2942, 0xd966,\n+    0x2e13, 0x0000, 0x0000, 0x0000, 0x4f28, 0xcf3c, 0x2df3, 0x0000, 0x0000, 0x0000,\n+    0xfa40, 0xc4ef, 0x2dd1, 0x0000, 0x0000, 0x0000, 0x4424, 0xbca7, 0x2db5, 0x0000,\n+    0x0000, 0x0000, 0x2e62, 0xcdc5, 0x2d97, 0x0000, 0x0000, 0x0000, 0xed88, 0x996b,\n+    0x2d78, 0x0000, 0x0000, 0x0000, 0x7c30, 0xd97d, 0x2d56, 0x0000, 0x0000, 0x0000,\n+    0xed26, 0xbf6e, 0x2d3a, 0x0000, 0x0000, 0x0000, 0x2918, 0x921b, 0x2d1a, 0x0000,\n+    0x0000, 0x0000, 0x4e24, 0xe84e, 0x2cfb, 0x0000, 0x0000, 0x0000, 0x6dc0, 0x92ec,\n+    0x2cdd, 0x0000, 0x0000, 0x0000, 0x4f2c, 0xacf8, 0x2cbd, 0x0000, 0x0000, 0x0000,\n+    0xc634, 0xf094, 0x2c9e, 0x0000, 0x0000, 0x0000, 0xdc70, 0xe5d3, 0x2c7e, 0x0000,\n+    0x0000, 0x0000, 0x2180, 0xa600, 0x2c5b, 0x0000, 0x0000, 0x0000, 0x8480, 0xd680,\n+    0x2c3c, 0x0000, 0x0000, 0x0000, 0x8b24, 0xd63b, 0x2c22, 0x0000, 0x0000, 0x0000,\n+    0x02e0, 0xaa47, 0x2c00, 0x0000, 0x0000, 0x0000, 0x9ad0, 0xee84, 0x2be3, 0x0000,\n+    0x0000, 0x0000, 0xf7dc, 0xf699, 0x2bc6, 0x0000, 0x0000, 0x0000, 0xddde, 0xe490,\n+    0x2ba7, 0x0000, 0x0000, 0x0000, 0x34a0, 0xb4fd, 0x2b85, 0x0000, 0x0000, 0x0000,\n+    0x91b4, 0x8ef6, 0x2b68, 0x0000, 0x0000, 0x0000, 0xa3e0, 0xa2a7, 0x2b47, 0x0000,\n+    0x0000, 0x0000, 0xcce4, 0x82b3, 0x2b2a, 0x0000, 0x0000, 0x0000, 0xe4be, 0x8207,\n+    0x2b0c, 0x0000, 0x0000, 0x0000, 0x1d92, 0xab43, 0x2aed, 0x0000, 0x0000, 0x0000,\n+    0xe818, 0xf9f6, 0x2acd, 0x0000, 0x0000, 0x0000, 0xff12, 0xba80, 0x2aaf, 0x0000,\n+    0x0000, 0x0000, 0x5254, 0x8529, 0x2a90, 0x0000, 0x0000, 0x0000, 0x1b88, 0xe032,\n+    0x2a71, 0x0000, 0x0000, 0x0000, 0x3248, 0xd86d, 0x2a50, 0x0000, 0x0000, 0x0000,\n+    0x3140, 0xc9d5, 0x2a2e, 0x0000, 0x0000, 0x0000, 0x14e6, 0xbd47, 0x2a14, 0x0000,\n+    0x0000, 0x0000, 0x5c10, 0xe544, 0x29f4, 0x0000, 0x0000, 0x0000, 0x9f50, 0x90b6,\n+    0x29d4, 0x0000, 0x0000, 0x0000, 0x9850, 0xab55, 0x29b6, 0x0000, 0x0000, 0x0000,\n+    0x2750, 0x9d07, 0x2998, 0x0000, 0x0000, 0x0000, 0x6700, 0x8bbb, 0x2973, 0x0000,\n+    0x0000, 0x0000, 0x5dba, 0xed31, 0x295a, 0x0000, 0x0000, 0x0000, 0x61dc, 0x85fe,\n+    0x293a, 0x0000, 0x0000, 0x0000, 0x9ba2, 0xd6b4, 0x291c, 0x0000, 0x0000, 0x0000,\n+    0x2d30, 0xe3a5, 0x28fb, 0x0000, 0x0000, 0x0000, 0x6630, 0xb566, 0x28dd, 0x0000,\n+    0x0000, 0x0000, 0x5ad4, 0xa829, 0x28bf, 0x0000, 0x0000, 0x0000, 0x89d8, 0xe290,\n+    0x28a0, 0x0000, 0x0000, 0x0000, 0x3916, 0xc428, 0x2881, 0x0000, 0x0000, 0x0000,\n+    0x0490, 0xbea4, 0x2860, 0x0000, 0x0000, 0x0000, 0xee06, 0x80ee, 0x2843, 0x0000,\n+    0x0000, 0x0000, 0xfc00, 0xf327, 0x2820, 0x0000, 0x0000, 0x0000, 0xea40, 0xa871,\n+    0x2800, 0x0000, 0x0000, 0x0000, 0x63d8, 0x9c26, 0x27e4, 0x0000, 0x0000, 0x0000,\n+    0x07ba, 0xc0c9, 0x27c7, 0x0000, 0x0000, 0x0000, 0x3fa2, 0x9797, 0x27a8, 0x0000,\n+    0x0000, 0x0000, 0x21c6, 0xfeca, 0x2789, 0x0000, 0x0000, 0x0000, 0xde40, 0x860d,\n+    0x2768, 0x0000, 0x0000, 0x0000, 0x9cc8, 0x98ce, 0x2749, 0x0000, 0x0000, 0x0000,\n+    0x3778, 0xa31c, 0x272a, 0x0000, 0x0000, 0x0000, 0xe778, 0xf6e2, 0x270b, 0x0000,\n+    0x0000, 0x0000, 0x59b8, 0xf841, 0x26ed, 0x0000, 0x0000, 0x0000, 0x02e0, 0xad04,\n+    0x26cd, 0x0000, 0x0000, 0x0000, 0x5a92, 0x9380, 0x26b0, 0x0000, 0x0000, 0x0000,\n+    0xc740, 0x8886, 0x268d, 0x0000, 0x0000, 0x0000, 0x0680, 0xfaf8, 0x266c, 0x0000,\n+    0x0000, 0x0000, 0xfb60, 0x897f, 0x2653, 0x0000, 0x0000, 0x0000, 0x8760, 0xf903,\n+    0x2634, 0x0000, 0x0000, 0x0000, 0xad2a, 0xc2c8, 0x2615, 0x0000, 0x0000, 0x0000,\n+    0x2d86, 0x8aef, 0x25f6, 0x0000, 0x0000, 0x0000, 0x1ef4, 0xe627, 0x25d6, 0x0000,\n+    0x0000, 0x0000, 0x09e4, 0x8020, 0x25b7, 0x0000, 0x0000, 0x0000, 0x7548, 0xd227,\n+    0x2598, 0x0000, 0x0000, 0x0000, 0x75dc, 0xfb5b, 0x2579, 0x0000, 0x0000, 0x0000,\n+    0xea84, 0xc8b6, 0x255a, 0x0000, 0x0000, 0x0000, 0xe4d0, 0x8145, 0x253b, 0x0000,\n+    0x0000, 0x0000, 0x3640, 0x9768, 0x251c, 0x0000, 0x0000, 0x0000, 0x246a, 0xccec,\n+    0x24fe, 0x0000, 0x0000, 0x0000, 0x51d0, 0xa075, 0x24dd, 0x0000, 0x0000, 0x0000,\n+    0x4638, 0xa385, 0x24bf, 0x0000, 0x0000, 0x0000, 0xd788, 0xd776, 0x24a1, 0x0000,\n+    0x0000, 0x0000, 0x1370, 0x8997, 0x2482, 0x0000, 0x0000, 0x0000, 0x1e88, 0x9b67,\n+    0x2462, 0x0000, 0x0000, 0x0000, 0x6c08, 0xd975, 0x2444, 0x0000, 0x0000, 0x0000,\n+    0xfdb0, 0xcfc0, 0x2422, 0x0000, 0x0000, 0x0000, 0x3100, 0xc026, 0x2406, 0x0000,\n+    0x0000, 0x0000, 0xc5b4, 0xae64, 0x23e6, 0x0000, 0x0000, 0x0000, 0x2280, 0xf687,\n+    0x23c3, 0x0000, 0x0000, 0x0000, 0x2de0, 0x9006, 0x23a9, 0x0000, 0x0000, 0x0000,\n+    0x24bc, 0xf631, 0x238a, 0x0000, 0x0000, 0x0000, 0xb8d4, 0xa975, 0x236b, 0x0000,\n+    0x0000, 0x0000, 0xd9a4, 0xb949, 0x234b, 0x0000, 0x0000, 0x0000, 0xb54e, 0xbd39,\n+    0x232d, 0x0000, 0x0000, 0x0000, 0x4aac, 0x9a52, 0x230e, 0x0000, 0x0000, 0x0000,\n+    0xbbbc, 0xd085, 0x22ef, 0x0000, 0x0000, 0x0000, 0xdf18, 0xc633, 0x22cf, 0x0000,\n+    0x0000, 0x0000, 0x16d0, 0xeca5, 0x22af, 0x0000, 0x0000, 0x0000, 0xf2a0, 0xdf6f,\n+    0x228e, 0x0000, 0x0000, 0x0000, 0x8c44, 0xe86b, 0x2272, 0x0000, 0x0000, 0x0000,\n+    0x35c0, 0xbbf4, 0x2253, 0x0000, 0x0000, 0x0000, 0x0c40, 0xdafb, 0x2230, 0x0000,\n+    0x0000, 0x0000, 0x92dc, 0x9935, 0x2216, 0x0000, 0x0000, 0x0000, 0x0ca0, 0xbda6,\n+    0x21f3, 0x0000, 0x0000, 0x0000, 0x5958, 0xa6fd, 0x21d6, 0x0000, 0x0000, 0x0000,\n+    0xa3dc, 0x9d7f, 0x21b9, 0x0000, 0x0000, 0x0000, 0x79dc, 0xfcb5, 0x2199, 0x0000,\n+    0x0000, 0x0000, 0xf264, 0xcebb, 0x217b, 0x0000, 0x0000, 0x0000, 0x0abe, 0x8308,\n+    0x215c, 0x0000, 0x0000, 0x0000, 0x30ae, 0xb463, 0x213d, 0x0000, 0x0000, 0x0000,\n+    0x6228, 0xb040, 0x211c, 0x0000, 0x0000, 0x0000, 0xc9b2, 0xf43b, 0x20ff, 0x0000,\n+    0x0000, 0x0000, 0x3d8e, 0xa4b3, 0x20e0, 0x0000, 0x0000, 0x0000, 0x84e6, 0x8dab,\n+    0x20c1, 0x0000, 0x0000, 0x0000, 0xa124, 0x9b74, 0x20a1, 0x0000, 0x0000, 0x0000,\n+    0xc276, 0xd497, 0x2083, 0x0000, 0x0000, 0x0000, 0x6354, 0xa466, 0x2063, 0x0000,\n+    0x0000, 0x0000, 0x8654, 0xaf0a, 0x2044, 0x0000, 0x0000, 0x0000, 0x1d20, 0xfa5c,\n+    0x2024, 0x0000, 0x0000, 0x0000, 0xbcd0, 0xf3f0, 0x2004, 0x0000, 0x0000, 0x0000,\n+    0xedf0, 0xf0b6, 0x1fe7, 0x0000, 0x0000, 0x0000, 0x45bc, 0x9182, 0x1fc9, 0x0000,\n+    0x0000, 0x0000, 0xe254, 0xdc85, 0x1faa, 0x0000, 0x0000, 0x0000, 0xb898, 0xe9b1,\n+    0x1f8a, 0x0000, 0x0000, 0x0000, 0x0ebe, 0xe6f0, 0x1f6c, 0x0000, 0x0000, 0x0000,\n+    0xa9b8, 0xf584, 0x1f4c, 0x0000, 0x0000, 0x0000, 0x12e8, 0xdf6b, 0x1f2e, 0x0000,\n+    0x0000, 0x0000, 0x9f9e, 0xcd55, 0x1f0f, 0x0000, 0x0000, 0x0000, 0x05a0, 0xec3a,\n+    0x1eef, 0x0000, 0x0000, 0x0000, 0xd8e0, 0x96f8, 0x1ed1, 0x0000, 0x0000, 0x0000,\n+    0x3bd4, 0xccc6, 0x1eb1, 0x0000, 0x0000, 0x0000, 0x4910, 0xb87b, 0x1e93, 0x0000,\n+    0x0000, 0x0000, 0xbefc, 0xd40b, 0x1e73, 0x0000, 0x0000, 0x0000, 0x317e, 0xa406,\n+    0x1e55, 0x0000, 0x0000, 0x0000, 0x6bb2, 0xc2b2, 0x1e36, 0x0000, 0x0000, 0x0000,\n+    0xb87e, 0xbb78, 0x1e17, 0x0000, 0x0000, 0x0000, 0xa03c, 0xdbbd, 0x1df7, 0x0000,\n+    0x0000, 0x0000, 0x5b6c, 0xe3c8, 0x1dd9, 0x0000, 0x0000, 0x0000, 0x8968, 0xca8e,\n+    0x1dba, 0x0000, 0x0000, 0x0000, 0xc024, 0xe6ab, 0x1d9a, 0x0000, 0x0000, 0x0000,\n+    0x4110, 0xd4eb, 0x1d7a, 0x0000, 0x0000, 0x0000, 0xa168, 0xbdb5, 0x1d5d, 0x0000,\n+    0x0000, 0x0000, 0x012e, 0xa5fa, 0x1d3e, 0x0000, 0x0000, 0x0000, 0x6838, 0x9c1f,\n+    0x1d1e, 0x0000, 0x0000, 0x0000, 0xa158, 0xaa76, 0x1d00, 0x0000, 0x0000, 0x0000,\n+    0x090a, 0xbd95, 0x1ce1, 0x0000, 0x0000, 0x0000, 0xf73e, 0x8b6d, 0x1cc2, 0x0000,\n+    0x0000, 0x0000, 0x5fda, 0xbcbf, 0x1ca3, 0x0000, 0x0000, 0x0000, 0xdbe8, 0xb89f,\n+    0x1c84, 0x0000, 0x0000, 0x0000, 0x6e4c, 0x96c7, 0x1c64, 0x0000, 0x0000, 0x0000,\n+    0x19c2, 0xf2a4, 0x1c46, 0x0000, 0x0000, 0x0000, 0xb800, 0xf855, 0x1c1e, 0x0000,\n+    0x0000, 0x0000, 0x87fc, 0x85ff, 0x1c08, 0x0000, 0x0000, 0x0000, 0x1418, 0x839f,\n+    0x1be9, 0x0000, 0x0000, 0x0000, 0x6186, 0xd9d8, 0x1bca, 0x0000, 0x0000, 0x0000,\n+    0xf500, 0xabaa, 0x1ba6, 0x0000, 0x0000, 0x0000, 0x7b36, 0xdafe, 0x1b8c, 0x0000,\n+    0x0000, 0x0000, 0xf394, 0xe6d8, 0x1b6c, 0x0000, 0x0000, 0x0000, 0x6efc, 0x9e55,\n+    0x1b4e, 0x0000, 0x0000, 0x0000, 0x5e10, 0xc523, 0x1b2e, 0x0000, 0x0000, 0x0000,\n+    0x8210, 0xb6f9, 0x1b0d, 0x0000, 0x0000, 0x0000, 0x9ab0, 0x96e3, 0x1af1, 0x0000,\n+    0x0000, 0x0000, 0x3864, 0x92e7, 0x1ad1, 0x0000, 0x0000, 0x0000, 0x9878, 0xdc65,\n+    0x1ab1, 0x0000, 0x0000, 0x0000, 0xfa20, 0xd6cb, 0x1a94, 0x0000, 0x0000, 0x0000,\n+    0x6c00, 0xa4e4, 0x1a70, 0x0000, 0x0000, 0x0000, 0xab40, 0xb41b, 0x1a53, 0x0000,\n+    0x0000, 0x0000, 0x43a4, 0x8ede, 0x1a37, 0x0000, 0x0000, 0x0000, 0x22e0, 0x9314,\n+    0x1a15, 0x0000, 0x0000, 0x0000, 0x6170, 0xb949, 0x19f8, 0x0000, 0x0000, 0x0000,\n+    0x6b00, 0xe056, 0x19d8, 0x0000, 0x0000, 0x0000, 0x9ba8, 0xa94c, 0x19b9, 0x0000,\n+    0x0000, 0x0000, 0xfaa0, 0xaa16, 0x199b, 0x0000, 0x0000, 0x0000, 0x899a, 0xf627,\n+    0x197d, 0x0000, 0x0000, 0x0000, 0x9f20, 0xfb70, 0x195d, 0x0000, 0x0000, 0x0000,\n+    0xa4b8, 0xc176, 0x193e, 0x0000, 0x0000, 0x0000, 0xb21c, 0x85c3, 0x1920, 0x0000,\n+    0x0000, 0x0000, 0x50d2, 0x9b19, 0x1901, 0x0000, 0x0000, 0x0000, 0xd4b0, 0xb708,\n+    0x18e0, 0x0000, 0x0000, 0x0000, 0xfb88, 0xf510, 0x18c1, 0x0000, 0x0000, 0x0000,\n+    0x31ec, 0xdc8d, 0x18a3, 0x0000, 0x0000, 0x0000, 0x3c00, 0xbff9, 0x1885, 0x0000,\n+    0x0000, 0x0000, 0x5020, 0xc30b, 0x1862, 0x0000, 0x0000, 0x0000, 0xd4f0, 0xda0c,\n+    0x1844, 0x0000, 0x0000, 0x0000, 0x20d2, 0x99a5, 0x1828, 0x0000, 0x0000, 0x0000,\n+    0x852e, 0xd159, 0x1809, 0x0000, 0x0000, 0x0000, 0x7cd8, 0x97a1, 0x17e9, 0x0000,\n+    0x0000, 0x0000, 0x423a, 0x997b, 0x17cb, 0x0000, 0x0000, 0x0000, 0xc1c0, 0xbe7d,\n+    0x17a8, 0x0000, 0x0000, 0x0000, 0xe8bc, 0xdcdd, 0x178d, 0x0000, 0x0000, 0x0000,\n+    0x8b28, 0xae06, 0x176e, 0x0000, 0x0000, 0x0000, 0x102e, 0xb8d4, 0x174f, 0x0000,\n+    0x0000, 0x0000, 0xaa00, 0xaa5c, 0x172f, 0x0000, 0x0000, 0x0000, 0x51f0, 0x9fc0,\n+    0x170e, 0x0000, 0x0000, 0x0000, 0xf858, 0xe181, 0x16f2, 0x0000, 0x0000, 0x0000,\n+    0x91a8, 0x8162, 0x16d3, 0x0000, 0x0000, 0x0000, 0x5f40, 0xcb6f, 0x16b1, 0x0000,\n+    0x0000, 0x0000, 0xbb50, 0xe55f, 0x1693, 0x0000, 0x0000, 0x0000, 0xacd2, 0xd895,\n+    0x1676, 0x0000, 0x0000, 0x0000, 0xef30, 0x97bf, 0x1654, 0x0000, 0x0000, 0x0000,\n+    0xf700, 0xb3d7, 0x1633, 0x0000, 0x0000, 0x0000, 0x3454, 0xa7b5, 0x1619, 0x0000,\n+    0x0000, 0x0000, 0x6b00, 0xa929, 0x15f6, 0x0000, 0x0000, 0x0000, 0x9f04, 0x89f7,\n+    0x15db, 0x0000, 0x0000, 0x0000, 0xad78, 0xd985, 0x15bc, 0x0000, 0x0000, 0x0000,\n+    0xa46a, 0xae3f, 0x159d, 0x0000, 0x0000, 0x0000, 0x63a0, 0xd0da, 0x157c, 0x0000,\n+    0x0000, 0x0000, 0x5e90, 0x817d, 0x155e, 0x0000, 0x0000, 0x0000, 0x1494, 0xb13f,\n+    0x1540, 0x0000, 0x0000, 0x0000, 0x0090, 0x9c40, 0x1521, 0x0000, 0x0000, 0x0000,\n+    0xdd70, 0xcc86, 0x1500, 0x0000, 0x0000, 0x0000, 0x64f8, 0xdb6f, 0x14e1, 0x0000,\n+    0x0000, 0x0000, 0xe22c, 0xac17, 0x14c3, 0x0000, 0x0000, 0x0000, 0x60e0, 0xa9ad,\n+    0x14a3, 0x0000, 0x0000, 0x0000, 0x4640, 0xd658, 0x1481, 0x0000, 0x0000, 0x0000,\n+    0x6490, 0xa181, 0x1467, 0x0000, 0x0000, 0x0000, 0x1df4, 0xaaa2, 0x1447, 0x0000,\n+    0x0000, 0x0000, 0xb94a, 0x8f61, 0x1429, 0x0000, 0x0000, 0x0000, 0x5198, 0x9d83,\n+    0x1409, 0x0000, 0x0000, 0x0000, 0x0f7a, 0xa818, 0x13eb, 0x0000, 0x0000, 0x0000,\n+    0xc45e, 0xc06c, 0x13cc, 0x0000, 0x0000, 0x0000, 0x4ec0, 0xfa29, 0x13a8, 0x0000,\n+    0x0000, 0x0000, 0x6418, 0x8cad, 0x138c, 0x0000, 0x0000, 0x0000, 0xbcc8, 0xe7d1,\n+    0x136f, 0x0000, 0x0000, 0x0000, 0xc934, 0xf9b0, 0x134f, 0x0000, 0x0000, 0x0000,\n+    0x6ce0, 0x98df, 0x1331, 0x0000, 0x0000, 0x0000, 0x3516, 0xe5e9, 0x1312, 0x0000,\n+    0x0000, 0x0000, 0xc6c0, 0xef8b, 0x12ef, 0x0000, 0x0000, 0x0000, 0xaf02, 0x913d,\n+    0x12d4, 0x0000, 0x0000, 0x0000, 0xd230, 0xe1d5, 0x12b5, 0x0000, 0x0000, 0x0000,\n+    0xfba8, 0xc232, 0x1295, 0x0000, 0x0000, 0x0000, 0x7ba4, 0xabeb, 0x1277, 0x0000,\n+    0x0000, 0x0000, 0x6e5c, 0xc692, 0x1258, 0x0000, 0x0000, 0x0000, 0x76a2, 0x9756,\n+    0x1239, 0x0000, 0x0000, 0x0000, 0xe180, 0xe423, 0x1214, 0x0000, 0x0000, 0x0000,\n+    0x8c3c, 0x90f8, 0x11fb, 0x0000, 0x0000, 0x0000, 0x9f3c, 0x9fd2, 0x11dc, 0x0000,\n+    0x0000, 0x0000, 0x53e0, 0xb73e, 0x11bd, 0x0000, 0x0000, 0x0000, 0x45be, 0x88d6,\n+    0x119e, 0x0000, 0x0000, 0x0000, 0x111a, 0x8bc0, 0x117f, 0x0000, 0x0000, 0x0000,\n+    0xe26a, 0xd7ff, 0x1160, 0x0000, 0x0000, 0x0000, 0xfb60, 0xdd8d, 0x113f, 0x0000,\n+    0x0000, 0x0000, 0x9370, 0xc108, 0x1120, 0x0000, 0x0000, 0x0000, 0x9654, 0x8baf,\n+    0x1103, 0x0000, 0x0000, 0x0000, 0xd6ec, 0xd6b9, 0x10e4, 0x0000, 0x0000, 0x0000,\n+    0x23e4, 0xd7b7, 0x10c4, 0x0000, 0x0000, 0x0000, 0x1aa6, 0xa847, 0x10a6, 0x0000,\n+    0x0000, 0x0000, 0xbee6, 0x9fef, 0x1087, 0x0000, 0x0000, 0x0000, 0x26d0, 0xa6eb,\n+    0x1066, 0x0000, 0x0000, 0x0000, 0x5b86, 0xa880, 0x1049, 0x0000, 0x0000, 0x0000,\n+    0x125c, 0xd971, 0x1029, 0x0000, 0x0000, 0x0000, 0x1f78, 0x9d18, 0x100a, 0x0000,\n+    0x0000, 0x0000, 0x0e84, 0xb15b, 0x0feb, 0x0000, 0x0000, 0x0000, 0xd0c0, 0xc150,\n+    0x0fcc, 0x0000, 0x0000, 0x0000, 0xa330, 0xc40c, 0x0fad, 0x0000, 0x0000, 0x0000,\n+    0x5202, 0xfc2c, 0x0f8f, 0x0000, 0x0000, 0x0000, 0x3f7c, 0xecf5, 0x0f6f, 0x0000,\n+    0x0000, 0x0000, 0xef44, 0xfdfd, 0x0f50, 0x0000, 0x0000, 0x0000, 0x3f6c, 0xab1b,\n+    0x0f31, 0x0000, 0x0000, 0x0000, 0xf658, 0x89ec, 0x0f11, 0x0000, 0x0000, 0x0000,\n+    0xbfc8, 0x9ba8, 0x0ef4, 0x0000, 0x0000, 0x0000, 0x3d40, 0xbe21, 0x0ed5, 0x0000,\n+    0x0000, 0x0000, 0xbbc4, 0xc70d, 0x0eb6, 0x0000, 0x0000, 0x0000, 0x5158, 0xdb16,\n+    0x0e96, 0x0000, 0x0000, 0x0000, 0xb5a8, 0xa8d8, 0x0e78, 0x0000, 0x0000, 0x0000,\n+    0xcccc, 0xb40e, 0x0e58, 0x0000, 0x0000, 0x0000, 0x448c, 0xcb62, 0x0e3a, 0x0000,\n+    0x0000, 0x0000, 0xf12a, 0x8aed, 0x0e1b, 0x0000, 0x0000, 0x0000, 0x79d0, 0xc59c,\n+    0x0dfb, 0x0000, 0x0000, 0x0000, 0x06b4, 0xcdc9, 0x0ddd, 0x0000, 0x0000, 0x0000,\n+    0xae70, 0xa979, 0x0dbe, 0x0000, 0x0000, 0x0000, 0x317c, 0xa8fb, 0x0d9e, 0x0000,\n+    0x0000, 0x0000, 0x5fe0, 0x8a50, 0x0d7d, 0x0000, 0x0000, 0x0000, 0x70b6, 0xfdfa,\n+    0x0d61, 0x0000, 0x0000, 0x0000, 0x1640, 0x9dc7, 0x0d41, 0x0000, 0x0000, 0x0000,\n+    0x9a9c, 0xdc50, 0x0d23, 0x0000, 0x0000, 0x0000, 0x4fcc, 0x9a9b, 0x0d04, 0x0000,\n+    0x0000, 0x0000, 0x7e48, 0x8f77, 0x0ce5, 0x0000, 0x0000, 0x0000, 0x84e4, 0xd4b9,\n+    0x0cc6, 0x0000, 0x0000, 0x0000, 0x84e0, 0xbd10, 0x0ca6, 0x0000, 0x0000, 0x0000,\n+    0x1b0a, 0xc8d9, 0x0c88, 0x0000, 0x0000, 0x0000, 0x6a48, 0xfc81, 0x0c68, 0x0000,\n+    0x0000, 0x0000, 0x070a, 0xbef6, 0x0c4a, 0x0000, 0x0000, 0x0000, 0x8a70, 0xf096,\n+    0x0c2b, 0x0000, 0x0000, 0x0000, 0xecc2, 0xc994, 0x0c0c, 0x0000, 0x0000, 0x0000,\n+    0x1540, 0x9537, 0x0bea, 0x0000, 0x0000, 0x0000, 0x1b02, 0xab5b, 0x0bce, 0x0000,\n+    0x0000, 0x0000, 0x5dc0, 0xb0c8, 0x0bad, 0x0000, 0x0000, 0x0000, 0xc928, 0xe034,\n+    0x0b8f, 0x0000, 0x0000, 0x0000, 0x2d12, 0xb4b0, 0x0b71, 0x0000, 0x0000, 0x0000,\n+    0x8fc2, 0xbb94, 0x0b52, 0x0000, 0x0000, 0x0000, 0xe236, 0xe22f, 0x0b33, 0x0000,\n+    0x0000, 0x0000, 0xb97c, 0xbe9e, 0x0b13, 0x0000, 0x0000, 0x0000, 0xe1a6, 0xe16d,\n+    0x0af5, 0x0000, 0x0000, 0x0000, 0xd330, 0xbaf0, 0x0ad6, 0x0000, 0x0000, 0x0000,\n+    0xc0bc, 0xbbd0, 0x0ab7, 0x0000, 0x0000, 0x0000, 0x8e66, 0xdd9b, 0x0a98, 0x0000,\n+    0x0000, 0x0000, 0xc95c, 0xf799, 0x0a79, 0x0000, 0x0000, 0x0000, 0xdac0, 0xbe4c,\n+    0x0a55, 0x0000, 0x0000, 0x0000, 0xafc0, 0xc378, 0x0a37, 0x0000, 0x0000, 0x0000,\n+    0xa880, 0xe341, 0x0a19, 0x0000, 0x0000, 0x0000, 0xc242, 0x81f6, 0x09fd, 0x0000,\n+    0x0000, 0x0000, 0x7470, 0xc777, 0x09de, 0x0000, 0x0000, 0x0000, 0x62bc, 0xb684,\n+    0x09be, 0x0000, 0x0000, 0x0000, 0x43ac, 0x8c58, 0x099f, 0x0000, 0x0000, 0x0000,\n+    0xcc3c, 0xf9ac, 0x0981, 0x0000, 0x0000, 0x0000, 0x1526, 0xb670, 0x0962, 0x0000,\n+    0x0000, 0x0000, 0xc9fe, 0xdf50, 0x0943, 0x0000, 0x0000, 0x0000, 0x6ae6, 0xc065,\n+    0x0924, 0x0000, 0x0000, 0x0000, 0xb114, 0xcf29, 0x0905, 0x0000, 0x0000, 0x0000,\n+    0xd388, 0x922a, 0x08e4, 0x0000, 0x0000, 0x0000, 0xcf54, 0xb926, 0x08c7, 0x0000,\n+    0x0000, 0x0000, 0x3826, 0xe855, 0x08a8, 0x0000, 0x0000, 0x0000, 0xe7c8, 0x829b,\n+    0x0888, 0x0000, 0x0000, 0x0000, 0x546c, 0xa903, 0x086a, 0x0000, 0x0000, 0x0000,\n+    0x8768, 0x99cc, 0x0849, 0x0000, 0x0000, 0x0000, 0x00ac, 0xf529, 0x082b, 0x0000,\n+    0x0000, 0x0000, 0x2658, 0x9f0b, 0x080c, 0x0000, 0x0000, 0x0000, 0xfe5c, 0x9e21,\n+    0x07ee, 0x0000, 0x0000, 0x0000, 0x6da2, 0x9910, 0x07cf, 0x0000, 0x0000, 0x0000,\n+    0x9220, 0xf9b3, 0x07b0, 0x0000, 0x0000, 0x0000, 0x3d90, 0xa541, 0x0791, 0x0000,\n+    0x0000, 0x0000, 0x6e4c, 0xe7cc, 0x0771, 0x0000, 0x0000, 0x0000, 0xa8fa, 0xe80a,\n+    0x0753, 0x0000, 0x0000, 0x0000, 0x4e14, 0xc3a7, 0x0734, 0x0000, 0x0000, 0x0000,\n+    0xf7e0, 0xbad9, 0x0712, 0x0000, 0x0000, 0x0000, 0xfea0, 0xeff2, 0x06f5, 0x0000,\n+    0x0000, 0x0000, 0xcef6, 0xbd48, 0x06d7, 0x0000, 0x0000, 0x0000, 0x7544, 0xf559,\n+    0x06b7, 0x0000, 0x0000, 0x0000, 0x2388, 0xf655, 0x0698, 0x0000, 0x0000, 0x0000,\n+    0xe900, 0xad56, 0x0676, 0x0000, 0x0000, 0x0000, 0x2cc0, 0x8437, 0x0659, 0x0000,\n+    0x0000, 0x0000, 0x3068, 0xc544, 0x063b, 0x0000, 0x0000, 0x0000, 0xdc70, 0xe73c,\n+    0x061b, 0x0000, 0x0000, 0x0000, 0xee50, 0x9d49, 0x05fc, 0x0000, 0x0000, 0x0000,\n+    0x93d2, 0x81f6, 0x05df, 0x0000, 0x0000, 0x0000, 0x941c, 0xadff, 0x05bf, 0x0000,\n+    0x0000, 0x0000, 0x2ce2, 0x8e45, 0x05a1, 0x0000, 0x0000, 0x0000, 0x4a60, 0x95fd,\n+    0x0581, 0x0000, 0x0000, 0x0000, 0x79f8, 0xb83a, 0x0563, 0x0000, 0x0000, 0x0000,\n+    0xcb58, 0xa1f5, 0x0543, 0x0000, 0x0000, 0x0000, 0x2a3a, 0xdc36, 0x0525, 0x0000,\n+    0x0000, 0x0000, 0x14ee, 0x890e, 0x0506, 0x0000, 0x0000, 0x0000, 0x8f20, 0xc432,\n+    0x04e3, 0x0000, 0x0000, 0x0000, 0x8440, 0xb21d, 0x04c6, 0x0000, 0x0000, 0x0000,\n+    0x5430, 0xf698, 0x04a7, 0x0000, 0x0000, 0x0000, 0x04ae, 0x8b20, 0x048a, 0x0000,\n+    0x0000, 0x0000, 0x04d0, 0xe872, 0x046b, 0x0000, 0x0000, 0x0000, 0xc78e, 0x8893,\n+    0x044c, 0x0000, 0x0000, 0x0000, 0x0f78, 0x9895, 0x042b, 0x0000, 0x0000, 0x0000,\n+    0x11d4, 0xdf2e, 0x040d, 0x0000, 0x0000, 0x0000, 0xe84c, 0x89d5, 0x03ef, 0x0000,\n+    0x0000, 0x0000, 0xf7be, 0x8a67, 0x03d0, 0x0000, 0x0000, 0x0000, 0x95d0, 0xc906,\n+    0x03b1, 0x0000, 0x0000, 0x0000, 0x64ce, 0xd96c, 0x0392, 0x0000, 0x0000, 0x0000,\n+    0x97ba, 0xa16f, 0x0373, 0x0000, 0x0000, 0x0000, 0x463c, 0xc51a, 0x0354, 0x0000,\n+    0x0000, 0x0000, 0xef0a, 0xe93e, 0x0335, 0x0000, 0x0000, 0x0000, 0x526a, 0xa466,\n+    0x0316, 0x0000, 0x0000, 0x0000, 0x4140, 0xa94d, 0x02f5, 0x0000, 0x0000, 0x0000,\n+    0xb4ec, 0xce68, 0x02d8, 0x0000, 0x0000, 0x0000, 0x4fa2, 0x8490, 0x02b9, 0x0000,\n+    0x0000, 0x0000, 0x4e60, 0xca98, 0x0298, 0x0000, 0x0000, 0x0000, 0x08dc, 0xe09c,\n+    0x027a, 0x0000, 0x0000, 0x0000, 0x2b90, 0xc7e3, 0x025c, 0x0000, 0x0000, 0x0000,\n+    0x5a7c, 0xf8ef, 0x023c, 0x0000, 0x0000, 0x0000, 0x5022, 0x9d58, 0x021e, 0x0000,\n+    0x0000, 0x0000, 0x553a, 0xe242, 0x01ff, 0x0000, 0x0000, 0x0000, 0x7e6e, 0xb54d,\n+    0x01e0, 0x0000, 0x0000, 0x0000, 0xd2d4, 0xa88c, 0x01c1, 0x0000, 0x0000, 0x0000,\n+    0x75b6, 0xfe6d, 0x01a2, 0x0000, 0x0000, 0x0000, 0x3bb2, 0xf04c, 0x0183, 0x0000,\n+    0x0000, 0x0000, 0xc2d0, 0xc046, 0x0163, 0x0000, 0x0000, 0x0000, 0x250c, 0xf9d6,\n+    0x0145, 0x0000, 0x0000, 0x0000, 0xb7b4, 0x8a0d, 0x0126, 0x0000, 0x0000, 0x0000,\n+    0x1a72, 0xe4f5, 0x0107, 0x0000, 0x0000, 0x0000, 0x825c, 0xa9b8, 0x00e8, 0x0000,\n+    0x0000, 0x0000, 0x6c90, 0xc9ad, 0x00c6, 0x0000, 0x0000, 0x0000, 0x4d00, 0xd1bb,\n+    0x00aa, 0x0000, 0x0000, 0x0000, 0xa4a0, 0xee01, 0x0087, 0x0000, 0x0000, 0x0000,\n+    0x89a8, 0xbe9f, 0x006b, 0x0000, 0x0000, 0x0000, 0x038e, 0xc80c, 0x004d, 0x0000,\n+    0x0000, 0x0000, 0xfe26, 0x8384, 0x002e, 0x0000, 0x0000, 0x0000, 0xcd90, 0xca57,\n+    0x000e, 0x0000\n+};\n+\n+void MacroAssembler::libm_reduce_pi04l(Register eax, Register ecx, Register edx, Register ebx, Register esi, Register edi, Register ebp, Register esp) {\n+  Label B1_1, B1_2, B1_3, B1_4, B1_5, B1_6, B1_7, B1_8, B1_9, B1_10, B1_11, B1_12;\n+  Label B1_13, B1_14, B1_15;\n+\n+  assert_different_registers(ebx, eax, ecx, edx, esi, edi, ebp, esp);\n+\n+  address zero_none  = (address)_zero_none;\n+  address _4onpi_d   = (address)__4onpi_d;\n+  address TWO_32H    = (address)_TWO_32H;\n+  address pi04_3d    = (address)_pi04_3d;\n+  address pi04_5d    = (address)_pi04_5d;\n+  address SCALE      = (address)_SCALE;\n+  address zeros      = (address)_zeros;\n+  address pi04_2d    = (address)_pi04_2d;\n+  address TWO_12H    = (address)_TWO_12H;\n+  address _4onpi_31l = (address)__4onpi_31l;\n+\n+  bind(B1_1);\n+  push(ebp);\n+  movl(ebp, esp);\n+  andl(esp, -16);\n+  push(esi);\n+  push(edi);\n+  push(ebx);\n+  subl(esp, 20);\n+  movzwl(ebx, Address(ebp, 16));\n+  andl(ebx, 32767);\n+  movl(eax, Address(ebp, 20));\n+  cmpl(ebx, 16413);\n+  movl(esi, Address(ebp, 24));\n+  movl(Address(esp, 4), eax);\n+  jcc(Assembler::greaterEqual, B1_8);\n+\n+  bind(B1_2);\n+  fld_x(Address(ebp, 8));\n+  fld_d(ExternalAddress(_4onpi_d));    \/\/0x6dc9c883UL, 0x3ff45f30UL\n+  fmul(1);\n+  fstp_x(Address(esp, 8));\n+  movzwl(ecx, Address(esp, 16));\n+  negl(ecx);\n+  addl(ecx, 30);\n+  movl(eax, Address(esp, 12));\n+  shrl(eax);\n+  cmpl(Address(esp, 4), 0);\n+  jcc(Assembler::notEqual, B1_4);\n+\n+  bind(B1_3);\n+  lea(ecx, Address(eax, 1));\n+  andl(ecx, -2);\n+  jmp(B1_5);\n+\n+  bind(B1_4);\n+  movl(ecx, eax);\n+  addl(eax, Address(esp, 4));\n+  movl(edx, eax);\n+  andl(edx, 1);\n+  addl(ecx, edx);\n+\n+  bind(B1_5);\n+  fld_d(ExternalAddress(TWO_32H));    \/\/0x00000000UL, 0x41f80000UL\n+  cmpl(ebx, 16400);\n+  movl(Address(esp, 0), ecx);\n+  fild_s(Address(esp, 0));\n+  jcc(Assembler::greaterEqual, B1_7);\n+\n+  bind(B1_6);\n+  fld_d(ExternalAddress(pi04_3d));    \/\/0x54442d00UL, 0x3fe921fbUL\n+  fmul(1);\n+  fsubp(3);\n+  fxch(1);\n+  fmul(2);\n+  fld_s(2);\n+  fadd(1);\n+  fsubrp(1);\n+  fld_s(0);\n+  fxch(1);\n+  fsuba(3);\n+  fld_d(ExternalAddress(8 + pi04_3d));    \/\/0x98cc5180UL, 0x3ce84698UL\n+  fmul(3);\n+  fsuba(2);\n+  fxch(1);\n+  fsub(2);\n+  fsubrp(1);\n+  faddp(3);\n+  fld_d(ExternalAddress(16 + pi04_3d));    \/\/0xcbb5bf6cUL, 0xb9dfc8f8UL\n+  fmulp(2);\n+  fld_s(1);\n+  fsubr(1);\n+  fsuba(1);\n+  fxch(2);\n+  fsubp(1);\n+  faddp(2);\n+  fxch(1);\n+  jmp(B1_15);\n+\n+  bind(B1_7);\n+  fld_d(ExternalAddress(pi04_5d));    \/\/0x54400000UL, 0x3fe921fbUL\n+  fmul(1);\n+  fsubp(3);\n+  fxch(1);\n+  fmul(2);\n+  fld_s(2);\n+  fadd(1);\n+  fsubrp(1);\n+  fld_s(0);\n+  fxch(1);\n+  fsuba(3);\n+  fld_d(ExternalAddress(8 + pi04_5d));    \/\/0x1a600000UL, 0x3dc0b461UL\n+  fmul(3);\n+  fsuba(2);\n+  fxch(1);\n+  fsub(2);\n+  fsubrp(1);\n+  faddp(3);\n+  fld_d(ExternalAddress(16 + pi04_5d));    \/\/0x2e000000UL, 0x3b93198aUL\n+  fmul(2);\n+  fld_s(0);\n+  fsubr(2);\n+  fsuba(2);\n+  fxch(1);\n+  fsubp(2);\n+  fxch(1);\n+  faddp(3);\n+  fld_d(ExternalAddress(24 + pi04_5d));    \/\/0x25200000UL, 0x396b839aUL\n+  fmul(2);\n+  fld_s(0);\n+  fsubr(2);\n+  fsuba(2);\n+  fxch(1);\n+  fsubp(2);\n+  fxch(1);\n+  faddp(3);\n+  fld_d(ExternalAddress(32 + pi04_5d));    \/\/0x533e63a0UL, 0x37027044UL\n+  fmulp(2);\n+  fld_s(1);\n+  fsubr(1);\n+  fsuba(1);\n+  fxch(2);\n+  fsubp(1);\n+  faddp(2);\n+  fxch(1);\n+  jmp(B1_15);\n+\n+  bind(B1_8);\n+  fld_x(Address(ebp, 8));\n+  addl(ebx, -16417);\n+  fmul_d(as_Address(ExternalAddress(SCALE)));    \/\/0x00000000UL, 0x32600000UL\n+  movl(eax, -2078209981);\n+  imull(ebx);\n+  addl(edx, ebx);\n+  movl(ecx, ebx);\n+  sarl(edx, 4);\n+  sarl(ecx, 31);\n+  subl(edx, ecx);\n+  movl(eax, edx);\n+  shll(eax, 5);\n+  fstp_x(Address(ebp, 8));\n+  fld_x(Address(ebp, 8));\n+  subl(eax, edx);\n+  movl(Address(ebp, 8), 0);\n+  subl(ebx, eax);\n+  fld_x(Address(ebp, 8));\n+  cmpl(ebx, 17);\n+  fsuba(1);\n+  jcc(Assembler::less, B1_10);\n+\n+  bind(B1_9);\n+  lea(eax, Address(noreg, edx, Address::times_8));\n+  lea(ecx, Address(eax, edx, Address::times_4));\n+  incl(edx);\n+  fld_x(Address(_4onpi_31l, RelocationHolder::none).plus_disp(ecx, Address::times_1));\n+  fmul(2);\n+  fld_x(Address(12 + _4onpi_31l, RelocationHolder::none).plus_disp(ecx, Address::times_1));\n+  fmul(2);\n+  fld_s(0);\n+  fadd(2);\n+  fsuba(2);\n+  fxch(1);\n+  faddp(2);\n+  fld_s(1);\n+  fadd(1);\n+  fstp_x(Address(esp, 8));\n+  andl(Address(esp, 8), -16777216);\n+  fld_x(Address(esp, 8));\n+  fsubp(1);\n+  jmp(B1_11);\n+\n+  bind(B1_10);\n+  fld_d(ExternalAddress(zeros));    \/\/0x00000000UL, 0x00000000UL\n+  fld_s(0);\n+\n+  bind(B1_11);\n+  fld_s(0);\n+  lea(eax, Address(noreg, edx, Address::times_8));\n+  fld_s(3);\n+  lea(edx, Address(eax, edx, Address::times_4));\n+  fld_x(Address(_4onpi_31l, RelocationHolder::none).plus_disp(edx, Address::times_1));\n+  fmul(6);\n+  movl(Address(esp, 0), edx);\n+  fadda(2);\n+  fxch(2);\n+  fsuba(3);\n+  fxch(2);\n+  faddp(3);\n+  fxch(2);\n+  faddp(3);\n+  fld_x(Address(12 + _4onpi_31l, RelocationHolder::none).plus_disp(edx, Address::times_1));\n+  fmula(2);\n+  fld_s(2);\n+  fadd(2);\n+  fld_s(0);\n+  fxch(1);\n+  fsubra(3);\n+  fxch(3);\n+  fchs();\n+  faddp(4);\n+  fxch(3);\n+  faddp(4);\n+  fxch(2);\n+  fadd(3);\n+  fxch(2);\n+  fmul(5);\n+  fadda(2);\n+  fld_s(4);\n+  fld_x(Address(24 + _4onpi_31l, RelocationHolder::none).plus_disp(edx, Address::times_1));\n+  fmula(1);\n+  fxch(1);\n+  fadda(4);\n+  fxch(4);\n+  fstp_x(Address(esp, 8));\n+  movzwl(ebx, Address(esp, 16));\n+  andl(ebx, 32767);\n+  cmpl(ebx, 16415);\n+  jcc(Assembler::greaterEqual, B1_13);\n+\n+  bind(B1_12);\n+  negl(ebx);\n+  addl(ebx, 30);\n+  movl(ecx, ebx);\n+  movl(eax, Address(esp, 12));\n+  shrl(eax);\n+  shll(eax);\n+  movl(Address(esp, 12), eax);\n+  movl(Address(esp, 8), 0);\n+  shrl(eax);\n+  jmp(B1_14);\n+\n+  bind(B1_13);\n+  negl(ebx);\n+  addl(ebx, 30);\n+  movl(ecx, ebx);\n+  movl(edx, Address(esp, 8));\n+  shrl(edx);\n+  shll(edx);\n+  negl(ecx);\n+  movl(eax, Address(esp, 12));\n+  shll(eax);\n+  movl(ecx, ebx);\n+  movl(Address(esp, 8), edx);\n+  shrl(edx);\n+  orl(eax, edx);\n+\n+  bind(B1_14);\n+  fld_x(Address(esp, 8));\n+  addl(eax, Address(esp, 4));\n+  fsubp(3);\n+  fmul(6);\n+  fld_s(4);\n+  movl(edx, eax);\n+  andl(edx, 1);\n+  fadd(3);\n+  movl(ecx, Address(esp, 0));\n+  fsuba(3);\n+  fxch(3);\n+  faddp(5);\n+  fld_s(1);\n+  fxch(3);\n+  fadd_d(Address(zero_none, RelocationHolder::none).plus_disp(edx, Address::times_8));\n+  fadda(3);\n+  fsub(3);\n+  faddp(2);\n+  fxch(1);\n+  faddp(4);\n+  fld_s(2);\n+  fadd(2);\n+  fsuba(2);\n+  fxch(3);\n+  faddp(2);\n+  fxch(1);\n+  faddp(3);\n+  fld_s(0);\n+  fadd(2);\n+  fsuba(2);\n+  fxch(1);\n+  faddp(2);\n+  fxch(1);\n+  faddp(2);\n+  fld_s(2);\n+  fld_x(Address(36 + _4onpi_31l, RelocationHolder::none).plus_disp(ecx, Address::times_1));\n+  fmula(1);\n+  fld_s(1);\n+  fadd(3);\n+  fsuba(3);\n+  fxch(2);\n+  faddp(3);\n+  fxch(2);\n+  faddp(3);\n+  fxch(1);\n+  fmul(4);\n+  fld_s(0);\n+  fadd(2);\n+  fsuba(2);\n+  fxch(1);\n+  faddp(2);\n+  fxch(1);\n+  faddp(2);\n+  fld_s(2);\n+  fld_x(Address(48 + _4onpi_31l, RelocationHolder::none).plus_disp(ecx, Address::times_1));\n+  fmula(1);\n+  fld_s(1);\n+  fadd(3);\n+  fsuba(3);\n+  fxch(2);\n+  faddp(3);\n+  fxch(2);\n+  faddp(3);\n+  fld_s(3);\n+  fxch(2);\n+  fmul(5);\n+  fld_x(Address(60 + _4onpi_31l, RelocationHolder::none).plus_disp(ecx, Address::times_1));\n+  fmula(3);\n+  fxch(3);\n+  faddp(1);\n+  fld_s(0);\n+  fadd(2);\n+  fsuba(2);\n+  fxch(1);\n+  faddp(2);\n+  fxch(1);\n+  faddp(3);\n+  fld_s(3);\n+  fxch(2);\n+  fmul(5);\n+  fld_x(Address(72 + _4onpi_31l, RelocationHolder::none).plus_disp(ecx, Address::times_1));\n+  fmula(3);\n+  fxch(3);\n+  faddp(1);\n+  fld_s(0);\n+  fadd(2);\n+  fsuba(2);\n+  fxch(1);\n+  faddp(2);\n+  fxch(1);\n+  faddp(3);\n+  fxch(1);\n+  fmulp(4);\n+  fld_x(Address(84 + _4onpi_31l, RelocationHolder::none).plus_disp(ecx, Address::times_1));\n+  fmulp(3);\n+  fxch(2);\n+  faddp(3);\n+  fld_s(2);\n+  fadd(2);\n+  fld_d(ExternalAddress(TWO_32H));    \/\/0x00000000UL, 0x41f80000UL\n+  fmul(1);\n+  fadda(1);\n+  fsubp(1);\n+  fsuba(2);\n+  fxch(3);\n+  faddp(2);\n+  faddp(1);\n+  fld_d(ExternalAddress(pi04_2d));    \/\/0x54400000UL, 0x3fe921fbUL\n+  fld_s(0);\n+  fmul(2);\n+  fxch(2);\n+  fadd(3);\n+  fxch(1);\n+  fmulp(3);\n+  fmul_d(as_Address(ExternalAddress(8 + pi04_2d)));    \/\/0x1a626331UL, 0x3dc0b461UL\n+  faddp(1);\n+\n+  bind(B1_15);\n+  fld_d(ExternalAddress(TWO_12H));    \/\/0x00000000UL, 0x40b80000UL\n+  fld_s(2);\n+  fadd(2);\n+  fmula(1);\n+  fstp_x(Address(esp, 8));\n+  fld_x(Address(esp, 8));\n+  fadd(1);\n+  fsubrp(1);\n+  fst_d(Address(esi, 0));\n+  fsubp(2);\n+  faddp(1);\n+  fstp_d(Address(esi, 8));\n+  addl(esp, 20);\n+  pop(ebx);\n+  pop(edi);\n+  pop(esi);\n+  movl(esp, ebp);\n+  pop(ebp);\n+  ret(0);\n+}\n+\n+\n+ATTRIBUTE_ALIGNED(16) jushort _SP[] =\n+{\n+    0xaaab, 0xaaaa, 0xaaaa, 0xaaaa, 0xbffc, 0x0000, 0x8887, 0x8888, 0x8888, 0x8888,\n+    0x3ff8, 0x0000, 0xc527, 0x0d00, 0x00d0, 0xd00d, 0xbff2, 0x0000, 0x45f6, 0xb616,\n+    0x1d2a, 0xb8ef, 0x3fec, 0x0000, 0x825b, 0x3997, 0x2b3f, 0xd732, 0xbfe5, 0x0000,\n+    0xbf33, 0x8bb4, 0x2fda, 0xb092, 0x3fde, 0x0000, 0x44a6, 0xed1a, 0x29ef, 0xd73e,\n+    0xbfd6, 0x0000, 0x8610, 0x307f, 0x62a1, 0xc921, 0x3fce, 0x0000\n+};\n+\n+ATTRIBUTE_ALIGNED(16) jushort _CP[] =\n+{\n+    0x0000, 0x0000, 0x0000, 0x8000, 0xbffe, 0x0000, 0xaaa5, 0xaaaa, 0xaaaa, 0xaaaa,\n+    0x3ffa, 0x0000, 0x9c2f, 0x0b60, 0x60b6, 0xb60b, 0xbff5, 0x0000, 0xf024, 0x0cac,\n+    0x00d0, 0xd00d, 0x3fef, 0x0000, 0x03fe, 0x3f65, 0x7dbb, 0x93f2, 0xbfe9, 0x0000,\n+    0xd84d, 0xadee, 0xc698, 0x8f76, 0x3fe2, 0x0000, 0xdaba, 0xfe79, 0xea36, 0xc9c9,\n+    0xbfda, 0x0000, 0x3ac6, 0x0ba0, 0x07ce, 0xd585, 0x3fd2, 0x0000\n+};\n+\n+void MacroAssembler::libm_sincos_huge(XMMRegister xmm0, XMMRegister xmm1, Register eax, Register ecx, Register edx, Register ebx, Register esi, Register edi, Register ebp, Register esp) {\n+  Label B1_1, B1_2, B1_3, B1_4, B1_5, B1_6, B1_7, B1_8, B1_9, B1_10, B1_11, B1_12;\n+  Label B1_13, B1_14, B1_15, B1_16, B1_17, B1_18, B1_19, B1_20, B1_21, B1_22, B1_23;\n+  Label B1_24, B1_25, B1_26, B1_27, B1_28, B1_29, B1_30, B1_31, B1_32, B1_33, B1_34;\n+  Label B1_35, B1_36, B1_37, B1_38, B1_39, B1_40, B1_41, B1_42, B1_43, B1_46;\n+\n+  assert_different_registers(ebx, eax, ecx, edx, esi, edi, ebp, esp);\n+\n+  address CP = (address)_CP;\n+  address SP = (address)_SP;\n+\n+  bind(B1_1);\n+  push(ebp);\n+  movl(ebp, esp);\n+  andl(esp, -64);\n+  push(esi);\n+  push(edi);\n+  push(ebx);\n+  subl(esp, 52);\n+  movl(eax, Address(ebp, 16));\n+  movl(edx, Address(ebp, 20));\n+  movl(Address(esp, 32), eax);\n+  movl(Address(esp, 36), edx);\n+\n+  bind(B1_2);\n+  fnstcw(Address(esp, 30));\n+\n+  bind(B1_3);\n+  movsd(xmm1, Address(ebp, 8));\n+  movl(esi, Address(ebp, 12));\n+  movl(eax, esi);\n+  andl(eax, 2147483647);\n+  andps(xmm1, ExternalAddress(L_2IL0FLOATPACKET_0));    \/\/0xffffffffUL, 0x7fffffffUL, 0x00000000UL, 0x00000000UL\n+  shrl(esi, 31);\n+  movl(Address(esp, 40), eax);\n+  cmpl(eax, 1104150528);\n+  movsd(Address(ebp, 8), xmm1);\n+  jcc(Assembler::aboveEqual, B1_11);\n+\n+  bind(B1_4);\n+  movsd(xmm0, ExternalAddress(PI4_INV));    \/\/0x6dc9c883UL, 0x3ff45f30UL\n+  mulsd(xmm0, xmm1);\n+  movzwl(edx, Address(esp, 30));\n+  movl(eax, edx);\n+  andl(eax, 768);\n+  movsd(Address(esp, 0), xmm0);\n+  cmpl(eax, 768);\n+  jcc(Assembler::equal, B1_42);\n+\n+  bind(B1_5);\n+  orl(edx, -64768);\n+  movw(Address(esp, 28), edx);\n+\n+  bind(B1_6);\n+  fldcw(Address(esp, 28));\n+\n+  bind(B1_7);\n+  movsd(xmm1, Address(ebp, 8));\n+  movl(ebx, 1);\n+\n+  bind(B1_8);\n+  movl(Address(esp, 12), ebx);\n+  movl(ebx, Address(esp, 4));\n+  movl(eax, ebx);\n+  movl(Address(esp, 8), esi);\n+  movl(esi, ebx);\n+  shrl(esi, 20);\n+  andl(eax, 1048575);\n+  movl(ecx, esi);\n+  orl(eax, 1048576);\n+  negl(ecx);\n+  movl(edx, eax);\n+  addl(ecx, 19);\n+  addl(esi, 13);\n+  movl(Address(esp, 24), ecx);\n+  shrl(edx);\n+  movl(ecx, esi);\n+  shll(eax);\n+  movl(ecx, Address(esp, 24));\n+  movl(esi, Address(esp, 0));\n+  shrl(esi);\n+  orl(eax, esi);\n+  cmpl(ebx, 1094713344);\n+  movsd(Address(esp, 16), xmm1);\n+  fld_d(Address(esp, 16));\n+  cmov32(Assembler::below, eax, edx);\n+  movl(esi, Address(esp, 8));\n+  lea(edx, Address(eax, 1));\n+  movl(ebx, edx);\n+  andl(ebx, -2);\n+  movl(Address(esp, 16), ebx);\n+  fild_s(Address(esp, 16));\n+  movl(ebx, Address(esp, 12));\n+  cmpl(Address(esp, 40), 1094713344);\n+  jcc(Assembler::aboveEqual, B1_10);\n+\n+  bind(B1_9);\n+  fld_d(ExternalAddress(PI4X3));    \/\/0x54443000UL, 0xbfe921fbUL\n+  fmul(1);\n+  faddp(2);\n+  fld_d(ExternalAddress(PI4X3 + 8));    \/\/0x3b39a000UL, 0x3d373dcbUL\n+  fmul(1);\n+  faddp(2);\n+  fld_d(ExternalAddress(PI4X3 + 16));    \/\/0xe0e68948UL, 0xba845c06UL\n+  fmulp(1);\n+  faddp(1);\n+  jmp(B1_17);\n+\n+  bind(B1_10);\n+  fld_d(ExternalAddress(PI4X4));    \/\/0x54400000UL, 0xbfe921fbUL\n+  fmul(1);\n+  faddp(2);\n+  fld_d(ExternalAddress(PI4X4 + 8));    \/\/0x1a600000UL, 0xbdc0b461UL\n+  fmul(1);\n+  faddp(2);\n+  fld_d(ExternalAddress(PI4X4 + 16));    \/\/0x2e000000UL, 0xbb93198aUL\n+  fmul(1);\n+  faddp(2);\n+  fld_d(ExternalAddress(PI4X4 + 24));    \/\/0x252049c1UL, 0xb96b839aUL\n+  fmulp(1);\n+  faddp(1);\n+  jmp(B1_17);\n+\n+  bind(B1_11);\n+  movzwl(edx, Address(esp, 30));\n+  movl(eax, edx);\n+  andl(eax, 768);\n+  cmpl(eax, 768);\n+  jcc(Assembler::equal, B1_43);\n+  bind(B1_12);\n+  orl(edx, -64768);\n+  movw(Address(esp, 28), edx);\n+\n+  bind(B1_13);\n+  fldcw(Address(esp, 28));\n+\n+  bind(B1_14);\n+  movsd(xmm1, Address(ebp, 8));\n+  movl(ebx, 1);\n+\n+  bind(B1_15);\n+  movsd(Address(esp, 16), xmm1);\n+  fld_d(Address(esp, 16));\n+  addl(esp, -32);\n+  lea(eax, Address(esp, 32));\n+  fstp_x(Address(esp, 0));\n+  movl(Address(esp, 12), 0);\n+  movl(Address(esp, 16), eax);\n+  call(RuntimeAddress(CAST_FROM_FN_PTR(address, StubRoutines::dlibm_reduce_pi04l())));\n+\n+  bind(B1_46);\n+  addl(esp, 32);\n+\n+  bind(B1_16);\n+  fld_d(Address(esp, 0));\n+  lea(edx, Address(eax, 1));\n+  fld_d(Address(esp, 8));\n+  faddp(1);\n+\n+  bind(B1_17);\n+  movl(ecx, edx);\n+  addl(eax, 3);\n+  shrl(ecx, 2);\n+  andl(ecx, 1);\n+  shrl(eax, 2);\n+  xorl(esi, ecx);\n+  movl(ecx, Address(esp, 36));\n+  andl(eax, 1);\n+  andl(ecx, 3);\n+  cmpl(ecx, 3);\n+  jcc(Assembler::notEqual, B1_25);\n+\n+  bind(B1_18);\n+  fld_x(ExternalAddress(84 + SP));    \/\/0x8610, 0x307f, 0x62\n+  fld_s(1);\n+  fmul((2));\n+  testb(edx, 2);\n+  fmula((1));\n+  fld_x(ExternalAddress(72 + SP));    \/\/0x44a6, 0xed1a, 0x29\n+  faddp(2);\n+  fmula(1);\n+  fld_x(ExternalAddress(60 + SP));    \/\/0xbf33, 0x8bb4, 0x2f\n+  faddp(2);\n+  fmula(1);\n+  fld_x(ExternalAddress(48 + SP));    \/\/0x825b, 0x3997, 0x2b\n+  faddp(2);\n+  fmula(1);\n+  fld_x(ExternalAddress(36 + SP));    \/\/0x45f6, 0xb616, 0x1d\n+  faddp(2);\n+  fmula(1);\n+  fld_x(ExternalAddress(24 + SP));    \/\/0xc527, 0x0d00, 0x00\n+  faddp(2);\n+  fmula(1);\n+  fld_x(ExternalAddress(12 + SP));    \/\/0x8887, 0x8888, 0x88\n+  faddp(2);\n+  fmula(1);\n+  fld_x(ExternalAddress(SP));    \/\/0xaaab, 0xaaaa, 0xaa\n+  faddp(2);\n+  fmula(1);\n+  fld_x(ExternalAddress(84 + CP));    \/\/0x3ac6, 0x0ba0, 0x07\n+  fmul(1);\n+  fld_x(ExternalAddress(72 + CP));    \/\/0xdaba, 0xfe79, 0xea\n+  faddp(1);\n+  fmul(1);\n+  fld_x(ExternalAddress(62 + CP));    \/\/0xd84d, 0xadee, 0xc6\n+  faddp(1);\n+  fmul(1);\n+  fld_x(ExternalAddress(48 + CP));    \/\/0x03fe, 0x3f65, 0x7d\n+  faddp(1);\n+  fmul(1);\n+  fld_x(ExternalAddress(36 + CP));    \/\/0xf024, 0x0cac, 0x00\n+  faddp(1);\n+  fmul(1);\n+  fld_x(ExternalAddress(24 + CP));    \/\/0x9c2f, 0x0b60, 0x60\n+  faddp(1);\n+  fmul(1);\n+  fld_x(ExternalAddress(12 + CP));    \/\/0xaaa5, 0xaaaa, 0xaa\n+  faddp(1);\n+  fmul(1);\n+  fld_x(ExternalAddress(CP));    \/\/0x0000, 0x0000, 0x00\n+  faddp(1);\n+  fmulp(1);\n+  fld_d(Address(ONES, RelocationHolder::none).plus_disp(esi, Address::times_8));\n+  fld_d(Address(ONES, RelocationHolder::none).plus_disp(eax, Address::times_8));\n+  jcc(Assembler::equal, B1_22);\n+\n+  bind(B1_19);\n+  fmulp(4);\n+  testl(ebx, ebx);\n+  fxch(2);\n+  fmul(3);\n+  movl(eax, Address(esp, 2));\n+  faddp(3);\n+  fxch(2);\n+  fstp_d(Address(eax, 0));\n+  fmula(1);\n+  faddp(1);\n+  fstp_d(Address(eax, 8));\n+  jcc(Assembler::equal, B1_21);\n+\n+  bind(B1_20);\n+  fldcw(Address(esp, 30));\n+\n+  bind(B1_21);\n+  addl(esp, 52);\n+  pop(ebx);\n+  pop(edi);\n+  pop(esi);\n+  movl(esp, ebp);\n+  pop(ebp);\n+  ret(0);\n+\n+  bind(B1_22);\n+  fxch(1);\n+  fmulp(4);\n+  testl(ebx, ebx);\n+  fxch(2);\n+  fmul(3);\n+  movl(eax, Address(esp, 32));\n+  faddp(3);\n+  fxch(2);\n+  fstp_d(Address(eax, 8));\n+  fmula(1);\n+  faddp(1);\n+  fstp_d(Address(eax, 0));\n+  jcc(Assembler::equal, B1_24);\n+\n+  bind(B1_23);\n+  fldcw(Address(esp, 30));\n+\n+  bind(B1_24);\n+  addl(esp, 52);\n+  pop(ebx);\n+  pop(edi);\n+  pop(esi);\n+  movl(esp, ebp);\n+  pop(ebp);\n+  ret(0);\n+\n+  bind(B1_25);\n+  testb(Address(esp, 36), 2);\n+  jcc(Assembler::equal, B1_33);\n+\n+  bind(B1_26);\n+  fld_s(0);\n+  testb(edx, 2);\n+  fmul(1);\n+  fld_s(0);\n+  fmul(1);\n+  jcc(Assembler::equal, B1_30);\n+\n+  bind(B1_27);\n+  fstp_d(2);\n+  fld_x(ExternalAddress(84 + CP));    \/\/0x3ac6, 0x0ba0, 0x07\n+  testl(ebx, ebx);\n+  fmul(2);\n+  fld_x(ExternalAddress(72 + CP));    \/\/0xdaba, 0xfe79, 0xea\n+  fmul(3);\n+  fld_x(ExternalAddress(60 + CP));    \/\/0xd84d, 0xadee, 0xc6\n+  movl(eax, Address(rsp, 32));\n+  faddp(2);\n+  fxch(1);\n+  fmul(3);\n+  fld_x(ExternalAddress(48 + CP));    \/\/0x03fe, 0x3f65, 0x7d\n+  faddp(2);\n+  fxch(1);\n+  fmul(3);\n+  fld_x(ExternalAddress(36 + CP));    \/\/0xf024, 0x0cac, 0x00\n+  faddp(2);\n+  fxch(1);\n+  fmul(3);\n+  fld_x(ExternalAddress(24 + CP));    \/\/0x9c2f, 0x0b60, 0x60\n+  faddp(2);\n+  fxch(1);\n+  fmul(3);\n+  fld_x(ExternalAddress(12 + CP));    \/\/0xaaa5, 0xaaaa, 0xaa\n+  faddp(2);\n+  fxch(1);\n+  fmulp(3);\n+  fld_x(ExternalAddress(CP));    \/\/0x0000, 0x0000, 0x00\n+  faddp(1);\n+  fmulp(1);\n+  faddp(1);\n+  fld_d(Address(ONES, RelocationHolder::none).plus_disp(rsi, Address::times_8));\n+  fmula(1);\n+  faddp(1);\n+  fstp_d(Address(eax, 8));\n+  jcc(Assembler::equal, B1_29);\n+\n+  bind(B1_28);\n+  fldcw(Address(esp, 30));\n+\n+  bind(B1_29);\n+  addl(esp, 52);\n+  pop(ebx);\n+  pop(edi);\n+  pop(esi);\n+  movl(esp, ebp);\n+  pop(ebp);\n+  ret(0);\n+\n+  bind(B1_30);\n+  fld_x(ExternalAddress(84 + SP));    \/\/0x8610, 0x307f, 0x62\n+  testl(ebx, ebx);\n+  fmul(1);\n+  fld_x(ExternalAddress(72 + SP));    \/\/0x44a6, 0xed1a, 0x29\n+  fmul(2);\n+  fld_x(ExternalAddress(60 + SP));    \/\/0xbf33, 0x8bb4, 0x2f\n+  movl(eax, Address(rsp, 32));\n+  faddp(2);\n+  fxch(1);\n+  fmul(2);\n+  fld_x(ExternalAddress(48 + SP));    \/\/0x825b, 0x3997, 0x2b\n+  faddp(2);\n+  fxch(1);\n+  fmul(2);\n+  fld_x(ExternalAddress(36 + SP));    \/\/0x45f6, 0xb616, 0x1d\n+  faddp(2);\n+  fxch(1);\n+  fmul(2);\n+  fld_x(ExternalAddress(24 + SP));    \/\/0xc527, 0x0d00, 0x00\n+  faddp(2);\n+  fxch(1);\n+  fmul(2);\n+  fld_x(ExternalAddress(12 + SP));    \/\/0x8887, 0x8888, 0x88\n+  faddp(2);\n+  fxch(1);\n+  fmulp(2);\n+  fld_x(ExternalAddress(SP));    \/\/0xaaab, 0xaaaa, 0xaa\n+  faddp(1);\n+  fmulp(2);\n+  faddp(1);\n+  fld_d(Address(ONES, RelocationHolder::none).plus_disp(rsi, Address::times_8));\n+  fmulp(2);\n+  fmul(1);\n+  faddp(1);\n+  fstp_d(Address(eax, 8));\n+  jcc(Assembler::equal, B1_32);\n+\n+  bind(B1_31);\n+  fldcw(Address(esp, 30));\n+\n+  bind(B1_32);\n+  addl(esp, 52);\n+  pop(ebx);\n+  pop(edi);\n+  pop(esi);\n+  movl(esp, ebp);\n+  pop(ebp);\n+  ret(0);\n+\n+  bind(B1_33);\n+  testb(Address(esp, 36), 1);\n+  jcc(Assembler::equal, B1_41);\n+\n+  bind(B1_34);\n+  fld_s(0);\n+  testb(edx, 2);\n+  fmul(1);\n+  fld_s(0);\n+  fmul(1);\n+  jcc(Assembler::equal, B1_38);\n+\n+  bind(B1_35);\n+  fld_x(ExternalAddress(84 + SP));    \/\/0x8610, 0x307f, 0x62\n+  testl(ebx, ebx);\n+  fmul(1);\n+  fld_x(ExternalAddress(72 + SP));    \/\/0x44a6, 0xed1a, 0x29\n+  fmul(2);\n+  fld_x(ExternalAddress(60 + SP));    \/\/0xbf33, 0x8bb4, 0x2f\n+  faddp(2);\n+  fxch(1);\n+  fmul(2);\n+  fld_x(ExternalAddress(48 + SP));    \/\/0x825b, 0x3997, 0x2b\n+  faddp(2);\n+  fxch(1);\n+  fmul(2);\n+  fld_x(ExternalAddress(36 + SP));    \/\/0x45f6, 0xb616, 0x1d\n+  faddp(2);\n+  fxch(1);\n+  fmul(2);\n+  fld_x(ExternalAddress(24 + SP));    \/\/0xc527, 0x0d00, 0x00\n+  faddp(2);\n+  fxch(1);\n+  fmul(2);\n+  fld_x(ExternalAddress(12 + SP));    \/\/0x8887, 0x8888, 0x88\n+  faddp(2);\n+  fxch(1);\n+  fmulp(2);\n+  fld_x(ExternalAddress(SP));    \/\/0xaaab, 0xaaaa, 0xaa\n+  faddp(1);\n+  fmulp(2);\n+  faddp(1);\n+  fld_d(Address(ONES, RelocationHolder::none).plus_disp(eax, Address::times_8));\n+  fmulp(2);\n+  fmul(1);\n+  movl(eax, Address(esp, 32));\n+  faddp(1);\n+  fstp_d(Address(eax, 0));\n+  jcc(Assembler::equal, B1_37);\n+\n+  bind(B1_36);\n+  fldcw(Address(esp, 30));\n+\n+  bind(B1_37);\n+  addl(esp, 52);\n+  pop(ebx);\n+  pop(edi);\n+  pop(esi);\n+  movl(esp, ebp);\n+  pop(ebp);\n+  ret(0);\n+\n+  bind(B1_38);\n+  fstp_d(2);\n+  fld_x(ExternalAddress(84 + CP));    \/\/0x3ac6, 0x0ba0, 0x07\n+  testl(ebx, ebx);\n+  fmul(2);\n+  fld_x(ExternalAddress(72 + CP));    \/\/0xdaba, 0xfe79, 0xea\n+  fmul(3);\n+  fld_x(ExternalAddress(60 + CP));    \/\/0xd84d, 0xadee, 0xc6\n+  faddp(2);\n+  fxch(1);\n+  fmul(3);\n+  fld_x(ExternalAddress(48 + CP));    \/\/0x03fe, 0x3f65, 0x7d\n+  faddp(2);\n+  fxch(1);\n+  fmul(3);\n+  fld_x(ExternalAddress(36 + CP));    \/\/0xf024, 0x0cac, 0x00\n+  faddp(2);\n+  fxch(1);\n+  fmul(3);\n+  fld_x(ExternalAddress(24 + CP));    \/\/0x9c2f, 0x0b60, 0x60\n+  faddp(2);\n+  fxch(1);\n+  fmul(3);\n+  fld_x(ExternalAddress(12 + CP));    \/\/0xaaa5, 0xaaaa, 0xaa\n+  faddp(2);\n+  fxch(1);\n+  fmulp(3);\n+  fld_x(ExternalAddress(CP));    \/\/0x0000, 0x0000, 0x00\n+  faddp(1);\n+  fmulp(1);\n+  faddp(1);\n+  fld_d(Address(ONES, RelocationHolder::none).plus_disp(eax, Address::times_8));\n+  fmula(1);\n+  movl(eax, Address(esp, 32));\n+  faddp(1);\n+  fstp_d(Address(eax, 0));\n+  jcc(Assembler::equal, B1_40);\n+\n+  bind(B1_39);\n+  fldcw(Address(esp, 30));\n+  bind(B1_40);\n+  addl(esp, 52);\n+  pop(ebx);\n+  pop(edi);\n+  pop(esi);\n+  movl(esp, ebp);\n+  pop(ebp);\n+  ret(0);\n+  bind(B1_41);\n+  fstp_d(0);\n+  addl(esp, 52);\n+  pop(ebx);\n+  pop(edi);\n+  pop(esi);\n+  movl(esp, ebp);\n+  pop(ebp);\n+  ret(0);\n+  bind(B1_42);\n+  xorl(ebx, ebx);\n+  jmp(B1_8);\n+  bind(B1_43);\n+  xorl(ebx, ebx);\n+  jmp(B1_15);\n+}\n+\n+ATTRIBUTE_ALIGNED(16) juint _static_const_table_sin[] =\n+{\n+    0x00000000UL, 0x00000000UL, 0x00000000UL, 0x00000000UL, 0x00000000UL,\n+    0x00000000UL, 0x00000000UL, 0x3ff00000UL, 0x176d6d31UL, 0xbf73b92eUL,\n+    0xbc29b42cUL, 0x3fb917a6UL, 0xe0000000UL, 0xbc3e2718UL, 0x00000000UL,\n+    0x3ff00000UL, 0x011469fbUL, 0xbf93ad06UL, 0x3c69a60bUL, 0x3fc8f8b8UL,\n+    0xc0000000UL, 0xbc626d19UL, 0x00000000UL, 0x3ff00000UL, 0x939d225aUL,\n+    0xbfa60beaUL, 0x2ed59f06UL, 0x3fd29406UL, 0xa0000000UL, 0xbc75d28dUL,\n+    0x00000000UL, 0x3ff00000UL, 0x866b95cfUL, 0xbfb37ca1UL, 0xa6aea963UL,\n+    0x3fd87de2UL, 0xe0000000UL, 0xbc672cedUL, 0x00000000UL, 0x3ff00000UL,\n+    0x73fa1279UL, 0xbfbe3a68UL, 0x3806f63bUL, 0x3fde2b5dUL, 0x20000000UL,\n+    0x3c5e0d89UL, 0x00000000UL, 0x3ff00000UL, 0x5bc57974UL, 0xbfc59267UL,\n+    0x39ae68c8UL, 0x3fe1c73bUL, 0x20000000UL, 0x3c8b25ddUL, 0x00000000UL,\n+    0x3ff00000UL, 0x53aba2fdUL, 0xbfcd0dfeUL, 0x25091dd6UL, 0x3fe44cf3UL,\n+    0x20000000UL, 0x3c68076aUL, 0x00000000UL, 0x3ff00000UL, 0x99fcef32UL,\n+    0x3fca8279UL, 0x667f3bcdUL, 0x3fe6a09eUL, 0x20000000UL, 0xbc8bdd34UL,\n+    0x00000000UL, 0x3fe00000UL, 0x94247758UL, 0x3fc133ccUL, 0x6b151741UL,\n+    0x3fe8bc80UL, 0x20000000UL, 0xbc82c5e1UL, 0x00000000UL, 0x3fe00000UL,\n+    0x9ae68c87UL, 0x3fac73b3UL, 0x290ea1a3UL, 0x3fea9b66UL, 0xe0000000UL,\n+    0x3c39f630UL, 0x00000000UL, 0x3fe00000UL, 0x7f909c4eUL, 0xbf9d4a2cUL,\n+    0xf180bdb1UL, 0x3fec38b2UL, 0x80000000UL, 0xbc76e0b1UL, 0x00000000UL,\n+    0x3fe00000UL, 0x65455a75UL, 0xbfbe0875UL, 0xcf328d46UL, 0x3fed906bUL,\n+    0x20000000UL, 0x3c7457e6UL, 0x00000000UL, 0x3fe00000UL, 0x76acf82dUL,\n+    0x3fa4a031UL, 0x56c62ddaUL, 0x3fee9f41UL, 0xe0000000UL, 0x3c8760b1UL,\n+    0x00000000UL, 0x3fd00000UL, 0x0e5967d5UL, 0xbfac1d1fUL, 0xcff75cb0UL,\n+    0x3fef6297UL, 0x20000000UL, 0x3c756217UL, 0x00000000UL, 0x3fd00000UL,\n+    0x0f592f50UL, 0xbf9ba165UL, 0xa3d12526UL, 0x3fefd88dUL, 0x40000000UL,\n+    0xbc887df6UL, 0x00000000UL, 0x3fc00000UL, 0x00000000UL, 0x00000000UL,\n+    0x00000000UL, 0x3ff00000UL, 0x00000000UL, 0x00000000UL, 0x00000000UL,\n+    0x00000000UL, 0x0f592f50UL, 0x3f9ba165UL, 0xa3d12526UL, 0x3fefd88dUL,\n+    0x40000000UL, 0xbc887df6UL, 0x00000000UL, 0xbfc00000UL, 0x0e5967d5UL,\n+    0x3fac1d1fUL, 0xcff75cb0UL, 0x3fef6297UL, 0x20000000UL, 0x3c756217UL,\n+    0x00000000UL, 0xbfd00000UL, 0x76acf82dUL, 0xbfa4a031UL, 0x56c62ddaUL,\n+    0x3fee9f41UL, 0xe0000000UL, 0x3c8760b1UL, 0x00000000UL, 0xbfd00000UL,\n+    0x65455a75UL, 0x3fbe0875UL, 0xcf328d46UL, 0x3fed906bUL, 0x20000000UL,\n+    0x3c7457e6UL, 0x00000000UL, 0xbfe00000UL, 0x7f909c4eUL, 0x3f9d4a2cUL,\n+    0xf180bdb1UL, 0x3fec38b2UL, 0x80000000UL, 0xbc76e0b1UL, 0x00000000UL,\n+    0xbfe00000UL, 0x9ae68c87UL, 0xbfac73b3UL, 0x290ea1a3UL, 0x3fea9b66UL,\n+    0xe0000000UL, 0x3c39f630UL, 0x00000000UL, 0xbfe00000UL, 0x94247758UL,\n+    0xbfc133ccUL, 0x6b151741UL, 0x3fe8bc80UL, 0x20000000UL, 0xbc82c5e1UL,\n+    0x00000000UL, 0xbfe00000UL, 0x99fcef32UL, 0xbfca8279UL, 0x667f3bcdUL,\n+    0x3fe6a09eUL, 0x20000000UL, 0xbc8bdd34UL, 0x00000000UL, 0xbfe00000UL,\n+    0x53aba2fdUL, 0x3fcd0dfeUL, 0x25091dd6UL, 0x3fe44cf3UL, 0x20000000UL,\n+    0x3c68076aUL, 0x00000000UL, 0xbff00000UL, 0x5bc57974UL, 0x3fc59267UL,\n+    0x39ae68c8UL, 0x3fe1c73bUL, 0x20000000UL, 0x3c8b25ddUL, 0x00000000UL,\n+    0xbff00000UL, 0x73fa1279UL, 0x3fbe3a68UL, 0x3806f63bUL, 0x3fde2b5dUL,\n+    0x20000000UL, 0x3c5e0d89UL, 0x00000000UL, 0xbff00000UL, 0x866b95cfUL,\n+    0x3fb37ca1UL, 0xa6aea963UL, 0x3fd87de2UL, 0xe0000000UL, 0xbc672cedUL,\n+    0x00000000UL, 0xbff00000UL, 0x939d225aUL, 0x3fa60beaUL, 0x2ed59f06UL,\n+    0x3fd29406UL, 0xa0000000UL, 0xbc75d28dUL, 0x00000000UL, 0xbff00000UL,\n+    0x011469fbUL, 0x3f93ad06UL, 0x3c69a60bUL, 0x3fc8f8b8UL, 0xc0000000UL,\n+    0xbc626d19UL, 0x00000000UL, 0xbff00000UL, 0x176d6d31UL, 0x3f73b92eUL,\n+    0xbc29b42cUL, 0x3fb917a6UL, 0xe0000000UL, 0xbc3e2718UL, 0x00000000UL,\n+    0xbff00000UL, 0x00000000UL, 0x00000000UL, 0x00000000UL, 0x00000000UL,\n+    0x00000000UL, 0x00000000UL, 0x00000000UL, 0xbff00000UL, 0x176d6d31UL,\n+    0x3f73b92eUL, 0xbc29b42cUL, 0xbfb917a6UL, 0xe0000000UL, 0x3c3e2718UL,\n+    0x00000000UL, 0xbff00000UL, 0x011469fbUL, 0x3f93ad06UL, 0x3c69a60bUL,\n+    0xbfc8f8b8UL, 0xc0000000UL, 0x3c626d19UL, 0x00000000UL, 0xbff00000UL,\n+    0x939d225aUL, 0x3fa60beaUL, 0x2ed59f06UL, 0xbfd29406UL, 0xa0000000UL,\n+    0x3c75d28dUL, 0x00000000UL, 0xbff00000UL, 0x866b95cfUL, 0x3fb37ca1UL,\n+    0xa6aea963UL, 0xbfd87de2UL, 0xe0000000UL, 0x3c672cedUL, 0x00000000UL,\n+    0xbff00000UL, 0x73fa1279UL, 0x3fbe3a68UL, 0x3806f63bUL, 0xbfde2b5dUL,\n+    0x20000000UL, 0xbc5e0d89UL, 0x00000000UL, 0xbff00000UL, 0x5bc57974UL,\n+    0x3fc59267UL, 0x39ae68c8UL, 0xbfe1c73bUL, 0x20000000UL, 0xbc8b25ddUL,\n+    0x00000000UL, 0xbff00000UL, 0x53aba2fdUL, 0x3fcd0dfeUL, 0x25091dd6UL,\n+    0xbfe44cf3UL, 0x20000000UL, 0xbc68076aUL, 0x00000000UL, 0xbff00000UL,\n+    0x99fcef32UL, 0xbfca8279UL, 0x667f3bcdUL, 0xbfe6a09eUL, 0x20000000UL,\n+    0x3c8bdd34UL, 0x00000000UL, 0xbfe00000UL, 0x94247758UL, 0xbfc133ccUL,\n+    0x6b151741UL, 0xbfe8bc80UL, 0x20000000UL, 0x3c82c5e1UL, 0x00000000UL,\n+    0xbfe00000UL, 0x9ae68c87UL, 0xbfac73b3UL, 0x290ea1a3UL, 0xbfea9b66UL,\n+    0xe0000000UL, 0xbc39f630UL, 0x00000000UL, 0xbfe00000UL, 0x7f909c4eUL,\n+    0x3f9d4a2cUL, 0xf180bdb1UL, 0xbfec38b2UL, 0x80000000UL, 0x3c76e0b1UL,\n+    0x00000000UL, 0xbfe00000UL, 0x65455a75UL, 0x3fbe0875UL, 0xcf328d46UL,\n+    0xbfed906bUL, 0x20000000UL, 0xbc7457e6UL, 0x00000000UL, 0xbfe00000UL,\n+    0x76acf82dUL, 0xbfa4a031UL, 0x56c62ddaUL, 0xbfee9f41UL, 0xe0000000UL,\n+    0xbc8760b1UL, 0x00000000UL, 0xbfd00000UL, 0x0e5967d5UL, 0x3fac1d1fUL,\n+    0xcff75cb0UL, 0xbfef6297UL, 0x20000000UL, 0xbc756217UL, 0x00000000UL,\n+    0xbfd00000UL, 0x0f592f50UL, 0x3f9ba165UL, 0xa3d12526UL, 0xbfefd88dUL,\n+    0x40000000UL, 0x3c887df6UL, 0x00000000UL, 0xbfc00000UL, 0x00000000UL,\n+    0x00000000UL, 0x00000000UL, 0xbff00000UL, 0x00000000UL, 0x00000000UL,\n+    0x00000000UL, 0x00000000UL, 0x0f592f50UL, 0xbf9ba165UL, 0xa3d12526UL,\n+    0xbfefd88dUL, 0x40000000UL, 0x3c887df6UL, 0x00000000UL, 0x3fc00000UL,\n+    0x0e5967d5UL, 0xbfac1d1fUL, 0xcff75cb0UL, 0xbfef6297UL, 0x20000000UL,\n+    0xbc756217UL, 0x00000000UL, 0x3fd00000UL, 0x76acf82dUL, 0x3fa4a031UL,\n+    0x56c62ddaUL, 0xbfee9f41UL, 0xe0000000UL, 0xbc8760b1UL, 0x00000000UL,\n+    0x3fd00000UL, 0x65455a75UL, 0xbfbe0875UL, 0xcf328d46UL, 0xbfed906bUL,\n+    0x20000000UL, 0xbc7457e6UL, 0x00000000UL, 0x3fe00000UL, 0x7f909c4eUL,\n+    0xbf9d4a2cUL, 0xf180bdb1UL, 0xbfec38b2UL, 0x80000000UL, 0x3c76e0b1UL,\n+    0x00000000UL, 0x3fe00000UL, 0x9ae68c87UL, 0x3fac73b3UL, 0x290ea1a3UL,\n+    0xbfea9b66UL, 0xe0000000UL, 0xbc39f630UL, 0x00000000UL, 0x3fe00000UL,\n+    0x94247758UL, 0x3fc133ccUL, 0x6b151741UL, 0xbfe8bc80UL, 0x20000000UL,\n+    0x3c82c5e1UL, 0x00000000UL, 0x3fe00000UL, 0x99fcef32UL, 0x3fca8279UL,\n+    0x667f3bcdUL, 0xbfe6a09eUL, 0x20000000UL, 0x3c8bdd34UL, 0x00000000UL,\n+    0x3fe00000UL, 0x53aba2fdUL, 0xbfcd0dfeUL, 0x25091dd6UL, 0xbfe44cf3UL,\n+    0x20000000UL, 0xbc68076aUL, 0x00000000UL, 0x3ff00000UL, 0x5bc57974UL,\n+    0xbfc59267UL, 0x39ae68c8UL, 0xbfe1c73bUL, 0x20000000UL, 0xbc8b25ddUL,\n+    0x00000000UL, 0x3ff00000UL, 0x73fa1279UL, 0xbfbe3a68UL, 0x3806f63bUL,\n+    0xbfde2b5dUL, 0x20000000UL, 0xbc5e0d89UL, 0x00000000UL, 0x3ff00000UL,\n+    0x866b95cfUL, 0xbfb37ca1UL, 0xa6aea963UL, 0xbfd87de2UL, 0xe0000000UL,\n+    0x3c672cedUL, 0x00000000UL, 0x3ff00000UL, 0x939d225aUL, 0xbfa60beaUL,\n+    0x2ed59f06UL, 0xbfd29406UL, 0xa0000000UL, 0x3c75d28dUL, 0x00000000UL,\n+    0x3ff00000UL, 0x011469fbUL, 0xbf93ad06UL, 0x3c69a60bUL, 0xbfc8f8b8UL,\n+    0xc0000000UL, 0x3c626d19UL, 0x00000000UL, 0x3ff00000UL, 0x176d6d31UL,\n+    0xbf73b92eUL, 0xbc29b42cUL, 0xbfb917a6UL, 0xe0000000UL, 0x3c3e2718UL,\n+    0x00000000UL, 0x3ff00000UL, 0x55555555UL, 0xbfc55555UL, 0x00000000UL,\n+    0xbfe00000UL, 0x11111111UL, 0x3f811111UL, 0x55555555UL, 0x3fa55555UL,\n+    0x1a01a01aUL, 0xbf2a01a0UL, 0x16c16c17UL, 0xbf56c16cUL, 0xa556c734UL,\n+    0x3ec71de3UL, 0x1a01a01aUL, 0x3efa01a0UL, 0x1a600000UL, 0x3d90b461UL,\n+    0x1a600000UL, 0x3d90b461UL, 0x54400000UL, 0x3fb921fbUL, 0x00000000UL,\n+    0x00000000UL, 0x2e037073UL, 0x3b63198aUL, 0x00000000UL, 0x00000000UL,\n+    0x6dc9c883UL, 0x40245f30UL, 0x00000000UL, 0x00000000UL, 0x00000000UL,\n+    0x43380000UL, 0x00000000UL, 0x00000000UL, 0x00000000UL, 0x43600000UL,\n+    0x00000000UL, 0x00000000UL, 0x00000000UL, 0x3c800000UL, 0x00000000UL,\n+    0x00000000UL, 0xffffffffUL, 0x3fefffffUL, 0x00000000UL, 0x00000000UL,\n+    0x00000000UL, 0x80000000UL, 0x00000000UL, 0x00000000UL, 0x00000000UL,\n+    0x80000000UL, 0x00000000UL, 0x80000000UL, 0x00000000UL, 0x3fe00000UL,\n+    0x00000000UL, 0x3fe00000UL\n+};\n+\n+void MacroAssembler::fast_sin(XMMRegister xmm0, XMMRegister xmm1, XMMRegister xmm2, XMMRegister xmm3,\n+                              XMMRegister xmm4, XMMRegister xmm5, XMMRegister xmm6, XMMRegister xmm7,\n+                              Register eax, Register ebx, Register edx) {\n+\n+  Label L_2TAG_PACKET_0_0_2, L_2TAG_PACKET_1_0_2, L_2TAG_PACKET_2_0_2, L_2TAG_PACKET_3_0_2;\n+  Label L_2TAG_PACKET_4_0_2;\n+\n+  assert_different_registers(eax, ebx, edx);\n+\n+  address static_const_table_sin = (address)_static_const_table_sin;\n+\n+  subl(rsp, 120);\n+  movl(Address(rsp, 56), ebx);\n+  lea(ebx, ExternalAddress(static_const_table_sin));\n+  movsd(xmm0, Address(rsp, 128));\n+  pextrw(eax, xmm0, 3);\n+  andl(eax, 32767);\n+  subl(eax, 12336);\n+  cmpl(eax, 4293);\n+  jcc(Assembler::above, L_2TAG_PACKET_0_0_2);\n+  movsd(xmm1, Address(ebx, 2160));\n+  mulsd(xmm1, xmm0);\n+  movsd(xmm5, Address(ebx, 2272));\n+  movdqu(xmm4, Address(ebx, 2256));\n+  pand(xmm4, xmm0);\n+  por(xmm5, xmm4);\n+  movsd(xmm3, Address(ebx, 2128));\n+  movdqu(xmm2, Address(ebx, 2112));\n+  addpd(xmm1, xmm5);\n+  cvttsd2sil(edx, xmm1);\n+  cvtsi2sdl(xmm1, edx);\n+  mulsd(xmm3, xmm1);\n+  unpcklpd(xmm1, xmm1);\n+  addl(edx, 1865216);\n+  movdqu(xmm4, xmm0);\n+  andl(edx, 63);\n+  movdqu(xmm5, Address(ebx, 2096));\n+  lea(eax, Address(ebx, 0));\n+  shll(edx, 5);\n+  addl(eax, edx);\n+  mulpd(xmm2, xmm1);\n+  subsd(xmm0, xmm3);\n+  mulsd(xmm1, Address(ebx, 2144));\n+  subsd(xmm4, xmm3);\n+  movsd(xmm7, Address(eax, 8));\n+  unpcklpd(xmm0, xmm0);\n+  movapd(xmm3, xmm4);\n+  subsd(xmm4, xmm2);\n+  mulpd(xmm5, xmm0);\n+  subpd(xmm0, xmm2);\n+  movdqu(xmm6, Address(ebx, 2064));\n+  mulsd(xmm7, xmm4);\n+  subsd(xmm3, xmm4);\n+  mulpd(xmm5, xmm0);\n+  mulpd(xmm0, xmm0);\n+  subsd(xmm3, xmm2);\n+  movdqu(xmm2, Address(eax, 0));\n+  subsd(xmm1, xmm3);\n+  movsd(xmm3, Address(eax, 24));\n+  addsd(xmm2, xmm3);\n+  subsd(xmm7, xmm2);\n+  mulsd(xmm2, xmm4);\n+  mulpd(xmm6, xmm0);\n+  mulsd(xmm3, xmm4);\n+  mulpd(xmm2, xmm0);\n+  mulpd(xmm0, xmm0);\n+  addpd(xmm5, Address(ebx, 2080));\n+  mulsd(xmm4, Address(eax, 0));\n+  addpd(xmm6, Address(ebx, 2048));\n+  mulpd(xmm5, xmm0);\n+  movapd(xmm0, xmm3);\n+  addsd(xmm3, Address(eax, 8));\n+  mulpd(xmm1, xmm7);\n+  movapd(xmm7, xmm4);\n+  addsd(xmm4, xmm3);\n+  addpd(xmm6, xmm5);\n+  movsd(xmm5, Address(eax, 8));\n+  subsd(xmm5, xmm3);\n+  subsd(xmm3, xmm4);\n+  addsd(xmm1, Address(eax, 16));\n+  mulpd(xmm6, xmm2);\n+  addsd(xmm5, xmm0);\n+  addsd(xmm3, xmm7);\n+  addsd(xmm1, xmm5);\n+  addsd(xmm1, xmm3);\n+  addsd(xmm1, xmm6);\n+  unpckhpd(xmm6, xmm6);\n+  addsd(xmm1, xmm6);\n+  addsd(xmm4, xmm1);\n+  movsd(Address(rsp, 0), xmm4);\n+  fld_d(Address(rsp, 0));\n+  jmp(L_2TAG_PACKET_1_0_2);\n+\n+  bind(L_2TAG_PACKET_0_0_2);\n+  jcc(Assembler::greater, L_2TAG_PACKET_2_0_2);\n+  shrl(eax, 4);\n+  cmpl(eax, 268434685);\n+  jcc(Assembler::notEqual, L_2TAG_PACKET_3_0_2);\n+  movsd(Address(rsp, 0), xmm0);\n+  fld_d(Address(rsp, 0));\n+  jmp(L_2TAG_PACKET_1_0_2);\n+\n+  bind(L_2TAG_PACKET_3_0_2);\n+  movsd(xmm3, Address(ebx, 2192));\n+  mulsd(xmm3, xmm0);\n+  subsd(xmm3, xmm0);\n+  mulsd(xmm3, Address(ebx, 2208));\n+  movsd(Address(rsp, 0), xmm0);\n+  fld_d(Address(rsp, 0));\n+  jmp(L_2TAG_PACKET_1_0_2);\n+\n+  bind(L_2TAG_PACKET_2_0_2);\n+  movl(eax, Address(rsp, 132));\n+  andl(eax, 2146435072);\n+  cmpl(eax, 2146435072);\n+  jcc(Assembler::equal, L_2TAG_PACKET_4_0_2);\n+  subl(rsp, 32);\n+  movsd(Address(rsp, 0), xmm0);\n+  lea(eax, Address(rsp, 40));\n+  movl(Address(rsp, 8), eax);\n+  movl(eax, 2);\n+  movl(Address(rsp, 12), eax);\n+  call(RuntimeAddress(CAST_FROM_FN_PTR(address, StubRoutines::dlibm_sin_cos_huge())));\n+  addl(rsp, 32);\n+  fld_d(Address(rsp, 16));\n+  jmp(L_2TAG_PACKET_1_0_2);\n+  bind(L_2TAG_PACKET_4_0_2);\n+  fld_d(Address(rsp, 128));\n+  fmul_d(Address(ebx, 2240));\n+  bind(L_2TAG_PACKET_1_0_2);\n+  movl(ebx, Address(rsp, 56));\n+}\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86_32_sin.cpp","additions":1743,"deletions":0,"binary":false,"changes":1743,"status":"added"},{"patch":"@@ -0,0 +1,1173 @@\n+\/*\n+* Copyright (c) 2016, 2021, Intel Corporation. All rights reserved.\n+* Intel Math Library (LIBM) Source Code\n+*\n+* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+*\n+* This code is free software; you can redistribute it and\/or modify it\n+* under the terms of the GNU General Public License version 2 only, as\n+* published by the Free Software Foundation.\n+*\n+* This code is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+* FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+* version 2 for more details (a copy is included in the LICENSE file that\n+* accompanied this code).\n+*\n+* You should have received a copy of the GNU General Public License version\n+* 2 along with this work; if not, write to the Free Software Foundation,\n+* Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+*\n+* Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+* or visit www.oracle.com if you need additional information or have any\n+* questions.\n+*\n+*\/\n+\n+#include \"precompiled.hpp\"\n+#include \"asm\/assembler.hpp\"\n+#include \"asm\/assembler.inline.hpp\"\n+#include \"macroAssembler_x86.hpp\"\n+#include \"runtime\/stubRoutines.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+\/******************************************************************************\/\n+\/\/                     ALGORITHM DESCRIPTION - TAN()\n+\/\/                     ---------------------\n+\/\/\n+\/\/ Polynomials coefficients and other constants.\n+\/\/\n+\/\/ Note that in this algorithm, there is a different polynomial for\n+\/\/ each breakpoint, so there are 32 sets of polynomial coefficients\n+\/\/ as well as 32 instances of the other constants.\n+\/\/\n+\/\/ The polynomial coefficients and constants are offset from the start\n+\/\/ of the main block as follows:\n+\/\/\n+\/\/   0:  c8 | c0\n+\/\/  16:  c9 | c1\n+\/\/  32: c10 | c2\n+\/\/  48: c11 | c3\n+\/\/  64: c12 | c4\n+\/\/  80: c13 | c5\n+\/\/  96: c14 | c6\n+\/\/ 112: c15 | c7\n+\/\/ 128: T_hi\n+\/\/ 136: T_lo\n+\/\/ 144: Sigma\n+\/\/ 152: T_hl\n+\/\/ 160: Tau\n+\/\/ 168: Mask\n+\/\/ 176: (end of block)\n+\/\/\n+\/\/ The total table size is therefore 5632 bytes.\n+\/\/\n+\/\/ Note that c0 and c1 are always zero. We could try storing\n+\/\/ other constants here, and just loading the low part of the\n+\/\/ SIMD register in these cases, after ensuring the high part\n+\/\/ is zero.\n+\/\/\n+\/\/ The higher terms of the polynomial are computed in the *low*\n+\/\/ part of the SIMD register. This is so we can overlap the\n+\/\/ multiplication by r^8 and the unpacking of the other part.\n+\/\/\n+\/\/ The constants are:\n+\/\/ T_hi + T_lo = accurate constant term in power series\n+\/\/ Sigma + T_hl = accurate coefficient of r in power series (Sigma=1 bit)\n+\/\/ Tau = multiplier for the reciprocal, always -1 or 0\n+\/\/\n+\/\/ The basic reconstruction formula using these constants is:\n+\/\/\n+\/\/ High = tau * recip_hi + t_hi\n+\/\/ Med = (sgn * r + t_hl * r)_hi\n+\/\/ Low = (sgn * r + t_hl * r)_lo +\n+\/\/       tau * recip_lo + T_lo + (T_hl + sigma) * c + pol\n+\/\/\n+\/\/ where pol = c0 + c1 * r + c2 * r^2 + ... + c15 * r^15\n+\/\/\n+\/\/ (c0 = c1 = 0, but using them keeps SIMD regularity)\n+\/\/\n+\/\/ We then do a compensated sum High + Med, add the low parts together\n+\/\/ and then do the final sum.\n+\/\/\n+\/\/ Here recip_hi + recip_lo is an accurate reciprocal of the remainder\n+\/\/ modulo pi\/2\n+\/\/\n+\/\/ Special cases:\n+\/\/  tan(NaN) = quiet NaN, and raise invalid exception\n+\/\/  tan(INF) = NaN and raise invalid exception\n+\/\/  tan(+\/-0) = +\/-0\n+\/\/\n+\/******************************************************************************\/\n+\n+\/\/ The 32 bit code is at most SSE2 compliant\n+\n+ATTRIBUTE_ALIGNED(16) jushort _TP[] =\n+{\n+    0x4cd6, 0xaf6c, 0xc710, 0xc662, 0xbffd, 0x0000, 0x4b06, 0xb0ac, 0xd3b2, 0xcc2c,\n+    0x3ff9, 0x0000, 0x00e3, 0xc850, 0xaa28, 0x9533, 0xbff3, 0x0000, 0x2ff0, 0x466d,\n+    0x1a3b, 0xb266, 0x3fe5, 0x0000\n+};\n+\n+ATTRIBUTE_ALIGNED(16) jushort _TQ[] =\n+{\n+    0x399c, 0x8391, 0x154c, 0x94ca, 0xbfff, 0x0000, 0xb6a3, 0xc36a, 0x44e2, 0x8a2c,\n+    0x3ffe, 0x0000, 0xb70f, 0xd068, 0xa6ce, 0xe9dd, 0xbff9, 0x0000, 0x820f, 0x51ce,\n+    0x7d76, 0x9bff, 0x3ff3, 0x0000\n+};\n+\n+ATTRIBUTE_ALIGNED(16) jushort _GP[] =\n+{\n+    0xaaab, 0xaaaa, 0xaaaa, 0xaaaa, 0xbffd, 0x0000, 0xb62f, 0x0b60, 0x60b6, 0xb60b,\n+    0xbff9, 0x0000, 0xdfa7, 0x08aa, 0x55e0, 0x8ab3, 0xbff6, 0x0000, 0x85a0, 0xa819,\n+    0xbc99, 0xddeb, 0xbff2, 0x0000, 0x7065, 0x6a37, 0x795f, 0xb354, 0xbfef, 0x0000,\n+    0xa8f9, 0x83f1, 0x2ec8, 0x9140, 0xbfec, 0x0000, 0xf3ca, 0x8c96, 0x8e0b, 0xeb6d,\n+    0xbfe8, 0x0000, 0x355b, 0xd910, 0x67c9, 0xbed3, 0xbfe5, 0x0000, 0x286b, 0xb49e,\n+    0xb854, 0x9a98, 0xbfe2, 0x0000, 0x0871, 0x1a2f, 0x6477, 0xfcc4, 0xbfde, 0x0000,\n+    0xa559, 0x1da9, 0xaed2, 0xba76, 0xbfdb, 0x0000, 0x00a3, 0x7fea, 0x9bc3, 0xf205,\n+    0xbfd8, 0x0000\n+};\n+\n+void MacroAssembler::libm_tancot_huge(XMMRegister xmm0, XMMRegister xmm1, Register eax, Register ecx, Register edx, Register ebx, Register esi, Register edi, Register ebp, Register esp) {\n+  Label B1_1, B1_2, B1_3, B1_4, B1_5, B1_6, B1_7, B1_8, B1_9, B1_10, B1_11, B1_12;\n+  Label B1_13, B1_14, B1_15, B1_16, B1_17, B1_18, B1_19, B1_20, B1_21, B1_22, B1_23;\n+  Label B1_24, B1_25, B1_26, B1_27, B1_28, B1_29, B1_30, B1_31, B1_32, B1_33, B1_34;\n+  Label B1_35, B1_36, B1_37, B1_38, B1_39, B1_40, B1_43;\n+\n+  assert_different_registers(ebx, eax, ecx, edx, esi, edi, ebp, esp);\n+\n+  address TP = (address)_TP;\n+  address TQ = (address)_TQ;\n+  address GP = (address)_GP;\n+\n+  bind(B1_1);\n+  push(ebp);\n+  movl(ebp, esp);\n+  andl(esp, -64);\n+  push(esi);\n+  push(edi);\n+  push(ebx);\n+  subl(esp, 52);\n+  movl(eax, Address(ebp, 16));\n+  movl(ebx, Address(ebp, 20));\n+  movl(Address(esp, 40), eax);\n+\n+  bind(B1_2);\n+  fnstcw(Address(esp, 38));\n+\n+  bind(B1_3);\n+  movl(edx, Address(ebp, 12));\n+  movl(eax, edx);\n+  andl(eax, 2147483647);\n+  shrl(edx, 31);\n+  movl(Address(esp, 44), edx);\n+  cmpl(eax, 1104150528);\n+  jcc(Assembler::aboveEqual, B1_11);\n+\n+  bind(B1_4);\n+  movsd(xmm1, Address(ebp, 8));\n+  movzwl(ecx, Address(esp, 38));\n+  movl(edx, ecx);\n+  andl(edx, 768);\n+  andps(xmm1, ExternalAddress(L_2IL0FLOATPACKET_0));    \/\/0xffffffffUL, 0x7fffffffUL, 0x00000000UL, 0x00000000UL\n+  cmpl(edx, 768);\n+  movsd(xmm0, ExternalAddress(PI4_INV));    \/\/\/\/0x6dc9c883UL, 0x3ff45f30UL\n+  mulsd(xmm0, xmm1);\n+  movsd(Address(ebp, 8), xmm1);\n+  movsd(Address(esp, 0), xmm0);\n+  jcc(Assembler::equal, B1_39);\n+\n+  bind(B1_5);\n+  orl(ecx, -64768);\n+  movw(Address(esp, 36), ecx);\n+\n+  bind(B1_6);\n+  fldcw(Address(esp, 36));\n+\n+  bind(B1_7);\n+  movsd(xmm1, Address(ebp, 8));\n+  movl(edi, 1);\n+\n+  bind(B1_8);\n+  movl(Address(esp, 12), esi);\n+  movl(esi, Address(esp, 4));\n+  movl(edx, esi);\n+  movl(Address(esp, 24), edi);\n+  movl(edi, esi);\n+  shrl(edi, 20);\n+  andl(edx, 1048575);\n+  movl(ecx, edi);\n+  orl(edx, 1048576);\n+  negl(ecx);\n+  addl(edi, 13);\n+  movl(Address(esp, 8), ebx);\n+  addl(ecx, 19);\n+  movl(ebx, edx);\n+  movl(Address(esp, 28), ecx);\n+  shrl(ebx);\n+  movl(ecx, edi);\n+  shll(edx);\n+  movl(ecx, Address(esp, 28));\n+  movl(edi, Address(esp, 0));\n+  shrl(edi);\n+  orl(edx, edi);\n+  cmpl(esi, 1094713344);\n+  movsd(Address(esp, 16), xmm1);\n+  fld_d(Address(esp, 16));\n+  cmov32(Assembler::below, edx, ebx);\n+  movl(edi, Address(esp, 24));\n+  movl(esi, Address(esp, 12));\n+  lea(ebx, Address(edx, 1));\n+  andl(ebx, -2);\n+  movl(Address(esp, 16), ebx);\n+  cmpl(eax, 1094713344);\n+  fild_s(Address(esp, 16));\n+  movl(ebx, Address(esp, 8));\n+  jcc(Assembler::aboveEqual, B1_10);\n+\n+  bind(B1_9);\n+  fld_d(ExternalAddress(PI4X3));    \/\/0x54443000UL, 0xbfe921fbUL\n+  fmul(1);\n+  faddp(2);\n+  fld_d(ExternalAddress(PI4X3 + 8));    \/\/0x3b39a000UL, 0x3d373dcbUL\n+  fmul(1);\n+  faddp(2);\n+  fld_d(ExternalAddress(PI4X3 + 16));    \/\/0xe0e68948UL, 0xba845c06UL\n+  fmulp(1);\n+  faddp(1);\n+  jmp(B1_17);\n+\n+  bind(B1_10);\n+  fld_d(ExternalAddress(PI4X4));    \/\/0x54400000UL, 0xbfe921fbUL\n+  fmul(1);\n+  faddp(2);\n+  fld_d(ExternalAddress(PI4X4 + 8));    \/\/0x1a600000UL, 0xbdc0b461UL\n+  fmul(1);\n+  faddp(2);\n+  fld_d(ExternalAddress(PI4X4 + 16));    \/\/0x2e000000UL, 0xbb93198aUL\n+  fmul(1);\n+  faddp(2);\n+  fld_d(ExternalAddress(PI4X4 + 24));    \/\/0x252049c1UL, 0xb96b839aUL\n+  fmulp(1);\n+  faddp(1);\n+  jmp(B1_17);\n+\n+  bind(B1_11);\n+  movzwl(edx, Address(esp, 38));\n+  movl(eax, edx);\n+  andl(eax, 768);\n+  cmpl(eax, 768);\n+  jcc(Assembler::equal, B1_40);\n+\n+  bind(B1_12);\n+  orl(edx, -64768);\n+  movw(Address(esp, 36), edx);\n+\n+  bind(B1_13);\n+  fldcw(Address(esp, 36));\n+\n+  bind(B1_14);\n+  movl(edi, 1);\n+\n+  bind(B1_15);\n+  movsd(xmm0, Address(ebp, 8));\n+  addl(esp, -32);\n+  andps(xmm0, ExternalAddress(L_2IL0FLOATPACKET_0));    \/\/0xffffffffUL, 0x7fffffffUL, 0x00000000UL, 0x00000000UL\n+  lea(eax, Address(esp, 32));\n+  movsd(Address(eax, 16), xmm0);\n+  fld_d(Address(eax, 16));\n+  fstp_x(Address(esp, 0));\n+  movl(Address(esp, 12), 0);\n+  movl(Address(esp, 16), eax);\n+  call(RuntimeAddress(CAST_FROM_FN_PTR(address, StubRoutines::dlibm_reduce_pi04l())));\n+\n+  bind(B1_43);\n+  movl(edx, eax);\n+  addl(esp, 32);\n+\n+  bind(B1_16);\n+  fld_d(Address(esp, 0));\n+  fld_d(Address(esp, 8));\n+  faddp(1);\n+\n+  bind(B1_17);\n+  movl(eax, ebx);\n+  andl(eax, 3);\n+  cmpl(eax, 3);\n+  jcc(Assembler::notEqual, B1_24);\n+\n+  bind(B1_18);\n+  fld_d(ExternalAddress(ONES));\n+  incl(edx);\n+  fdiv(1);\n+  testb(edx, 2);\n+  fstp_x(Address(esp, 24));\n+  fld_s(0);\n+  fmul(1);\n+  fld_s(0);\n+  fmul(1);\n+  fld_x(ExternalAddress(36 + TP));    \/\/0x2ff0, 0x466d, 0x1a\n+  fmul(2);\n+  fld_x(ExternalAddress(24 + TP));    \/\/0x00e3, 0xc850, 0xaa\n+  faddp(1);\n+  fmul(2);\n+  fld_x(ExternalAddress(12 + TP));    \/\/0x4b06, 0xb0ac, 0xd3\n+  faddp(1);\n+  fmul(2);\n+  fld_x(ExternalAddress(36 + TQ));    \/\/0x820f, 0x51ce, 0x7d\n+  fmul(3);\n+  fld_x(ExternalAddress(24 + TQ));    \/\/0xb70f, 0xd068, 0xa6\n+  faddp(1);\n+  fmul(3);\n+  fld_x(ExternalAddress(12 + TQ));    \/\/0xb6a3, 0xc36a, 0x44\n+  faddp(1);\n+  fmul(3);\n+  fld_x(ExternalAddress(TQ));    \/\/0x399c, 0x8391, 0x15\n+  faddp(1);\n+  fld_x(ExternalAddress(TP));    \/\/0x4cd6, 0xaf6c, 0xc7\n+  faddp(2);\n+  fld_x(ExternalAddress(132 + GP));    \/\/0x00a3, 0x7fea, 0x9b\n+  fmul(3);\n+  fld_x(ExternalAddress(120 + GP));    \/\/0xa559, 0x1da9, 0xae\n+  fmul(4);\n+  fld_x(ExternalAddress(108 + GP));    \/\/0x0871, 0x1a2f, 0x64\n+  faddp(2);\n+  fxch(1);\n+  fmul(4);\n+  fld_x(ExternalAddress(96 + GP));    \/\/0x286b, 0xb49e, 0xb8\n+  faddp(2);\n+  fxch(1);\n+  fmul(4);\n+  fld_x(ExternalAddress(84 + GP));    \/\/0x355b, 0xd910, 0x67\n+  faddp(2);\n+  fxch(1);\n+  fmul(4);\n+  fld_x(ExternalAddress(72 + GP));    \/\/0x8c96, 0x8e0b, 0xeb\n+  faddp(2);\n+  fxch(1);\n+  fmul(4);\n+  fld_x(ExternalAddress(60 + GP));    \/\/0xa8f9, 0x83f1, 0x2e\n+  faddp(2);\n+  fxch(1);\n+  fmul(4);\n+  fld_x(ExternalAddress(48 + GP));    \/\/0x7065, 0x6a37, 0x79\n+  faddp(2);\n+  fxch(1);\n+  fmul(4);\n+  fld_x(ExternalAddress(36 + GP));    \/\/0x85a0, 0xa819, 0xbc\n+  faddp(2);\n+  fxch(1);\n+  fmul(4);\n+  fld_x(ExternalAddress(24 + GP));    \/\/0xdfa7, 0x08aa, 0x55\n+  faddp(2);\n+  fxch(1);\n+  fmulp(4);\n+  fld_x(ExternalAddress(12 + GP));    \/\/0xb62f, 0x0b60, 0x60\n+  faddp(1);\n+  fmul(4);\n+  fmul(5);\n+  fld_x(ExternalAddress(GP));    \/\/0xaaab, 0xaaaa, 0xaa\n+  faddp(4);\n+  fxch(3);\n+  fmul(5);\n+  faddp(3);\n+  jcc(Assembler::equal, B1_20);\n+\n+  bind(B1_19);\n+  fld_x(Address(esp, 24));\n+  fxch(1);\n+  fdivrp(2);\n+  fxch(1);\n+  fmulp(3);\n+  movl(eax, Address(esp, 44));\n+  xorl(eax, 1);\n+  fxch(2);\n+  fmul(3);\n+  fld_d(Address(ONES, RelocationHolder::none).plus_disp(eax, Address::times_8));\n+  fmula(2);\n+  fmula(3);\n+  fxch(3);\n+  faddp(2);\n+  fxch(1);\n+  fstp_d(Address(esp, 16));\n+  fmul(1);\n+  fxch(1);\n+  fmulp(2);\n+  movsd(xmm0, Address(esp, 16));\n+  faddp(1);\n+  fstp_d(Address(esp, 16));\n+  movsd(xmm1, Address(esp, 16));\n+  jmp(B1_21);\n+\n+  bind(B1_20);\n+  fdivrp(1);\n+  fmulp(2);\n+  fxch(1);\n+  fmul(2);\n+  movl(eax, Address(esp, 44));\n+  fld_d(Address(ONES, RelocationHolder::none).plus_disp(eax, Address::times_8));\n+  fmula(1);\n+  fmula(3);\n+  fxch(3);\n+  faddp(1);\n+  fstp_d(Address(esp, 16));\n+  fmul(1);\n+  fld_x(Address(esp, 24));\n+  fmulp(2);\n+  movsd(xmm0, Address(esp, 16));\n+  faddp(1);\n+  fstp_d(Address(esp, 16));\n+  movsd(xmm1, Address(esp, 16));\n+\n+  bind(B1_21);\n+  testl(edi, edi);\n+  jcc(Assembler::equal, B1_23);\n+\n+  bind(B1_22);\n+  fldcw(Address(esp, 38));\n+\n+  bind(B1_23);\n+  movl(eax, Address(esp, 40));\n+  movsd(Address(eax, 0), xmm0);\n+  movsd(Address(eax, 8), xmm1);\n+  addl(esp, 52);\n+  pop(ebx);\n+  pop(edi);\n+  pop(esi);\n+  movl(esp, ebp);\n+  pop(ebp);\n+  ret(0);\n+\n+  bind(B1_24);\n+  testb(ebx, 2);\n+  jcc(Assembler::equal, B1_31);\n+\n+  bind(B1_25);\n+  incl(edx);\n+  fld_s(0);\n+  fmul(1);\n+  testb(edx, 2);\n+  jcc(Assembler::equal, B1_27);\n+\n+  bind(B1_26);\n+  fld_d(ExternalAddress(ONES));\n+  fdiv(2);\n+  fld_s(1);\n+  fmul(2);\n+  fld_x(ExternalAddress(132 + GP));    \/\/0x00a3, 0x7fea, 0x9b\n+  fmul(1);\n+  fld_x(ExternalAddress(120 + GP));    \/\/0xa559, 0x1da9, 0xae\n+  fmul(2);\n+  fld_x(ExternalAddress(108 + GP));    \/\/0x67c9, 0xbed3, 0xbf\n+  movl(eax, Address(esp, 44));\n+  faddp(2);\n+  fxch(1);\n+  fmul(2);\n+  xorl(eax, 1);\n+  fld_x(ExternalAddress(96 + GP));    \/\/0x286b, 0xb49e, 0xb8\n+  faddp(2);\n+  fxch(1);\n+  fmul(2);\n+  fld_x(ExternalAddress(84 + GP));    \/\/0x355b, 0xd910, 0x67\n+  faddp(2);\n+  fxch(1);\n+  fmul(2);\n+  fld_x(ExternalAddress(72 + GP));    \/\/0xf3ca, 0x8c96, 0x8e\n+  faddp(2);\n+  fxch(1);\n+  fmul(2);\n+  fld_x(ExternalAddress(60 + GP));    \/\/0xa8f9, 0x83f1, 0x2e\n+  faddp(2);\n+  fxch(1);\n+  fmul(2);\n+  fld_x(ExternalAddress(48 + GP));    \/\/0x7065, 0x6a37, 0x79\n+  faddp(2);\n+  fxch(1);\n+  fmul(2);\n+  fld_x(ExternalAddress(36 + GP));    \/\/0x85a0, 0xa819, 0xbc\n+  faddp(2);\n+  fxch(1);\n+  fmul(2);\n+  fld_x(ExternalAddress(24 + GP));    \/\/0xdfa7, 0x08aa, 0x55\n+  faddp(2);\n+  fxch(1);\n+  fmulp(2);\n+  fld_x(ExternalAddress(12 + GP));    \/\/0xb62f, 0x0b60, 0x60\n+  faddp(1);\n+  fmulp(3);\n+  fld_x(ExternalAddress(GP));    \/\/0xaaab, 0xaaaa, 0xaa\n+  faddp(1);\n+  fmul(3);\n+  fxch(2);\n+  fmulp(3);\n+  fxch(1);\n+  faddp(2);\n+  fld_d(Address(ONES, RelocationHolder::none).plus_disp(eax, Address::times_8));\n+  fmula(2);\n+  fmulp(1);\n+  faddp(1);\n+  fstp_d(Address(esp, 16));\n+  movsd(xmm0, Address(esp, 16));\n+  jmp(B1_28);\n+\n+  bind(B1_27);\n+  fld_x(ExternalAddress(36 + TP));    \/\/0x2ff0, 0x466d, 0x1a\n+  fmul(1);\n+  fld_x(ExternalAddress(24 + TP));    \/\/0x00e3, 0xc850, 0xaa\n+  movl(eax, Address(esp, 44));\n+  faddp(1);\n+  fmul(1);\n+  fld_x(ExternalAddress(36 + TQ));    \/\/0x820f, 0x51ce, 0x7d\n+  fmul(2);\n+  fld_x(ExternalAddress(24 + TQ));    \/\/0xb70f, 0xd068, 0xa6\n+  faddp(1);\n+  fmul(2);\n+  fld_x(ExternalAddress(12 + TQ));    \/\/0xb6a3, 0xc36a, 0x44\n+  faddp(1);\n+  fmul(2);\n+  fld_x(ExternalAddress(TQ));    \/\/0x399c, 0x8391, 0x15\n+  faddp(1);\n+  fld_x(ExternalAddress(12 + TP));    \/\/0x4b06, 0xb0ac, 0xd3\n+  faddp(2);\n+  fxch(1);\n+  fmul(2);\n+  fld_x(ExternalAddress(TP));    \/\/0x4cd6, 0xaf6c, 0xc7\n+  faddp(1);\n+  fdivrp(1);\n+  fmulp(1);\n+  fmul(1);\n+  fld_d(Address(ONES, RelocationHolder::none).plus_disp(eax, Address::times_8));\n+  fmula(1);\n+  fmulp(2);\n+  faddp(1);\n+  fstp_d(Address(esp, 16));\n+  movsd(xmm0, Address(esp, 16));\n+\n+  bind(B1_28);\n+  testl(edi, edi);\n+  jcc(Assembler::equal, B1_30);\n+\n+  bind(B1_29);\n+  fldcw(Address(esp, 38));\n+\n+  bind(B1_30);\n+  movl(eax, Address(esp, 40));\n+  movsd(Address(eax, 0), xmm0);\n+  addl(esp, 52);\n+  pop(ebx);\n+  pop(edi);\n+  pop(esi);\n+  movl(esp, ebp);\n+  pop(ebp);\n+  ret(0);\n+\n+  bind(B1_31);\n+  testb(ebx, 1);\n+  jcc(Assembler::equal, B1_38);\n+\n+  bind(B1_32);\n+  incl(edx);\n+  fld_s(0);\n+  fmul(1);\n+  testb(edx, 2);\n+  jcc(Assembler::equal, B1_34);\n+\n+  bind(B1_33);\n+  fld_x(ExternalAddress(36 + TP));    \/\/0x2ff0, 0x466d, 0x1a\n+  fmul(1);\n+  fld_x(ExternalAddress(24 + TP));    \/\/0x00e3, 0xc850, 0xaa\n+  movl(eax, Address(esp, 44));\n+  faddp(1);\n+  fmul(1);\n+  xorl(eax, 1);\n+  fld_x(ExternalAddress(36 + TQ));    \/\/0x820f, 0x51ce, 0x7d\n+  fmul(2);\n+  fld_x(ExternalAddress(24 + TQ));    \/\/0xb70f, 0xd068, 0xa6\n+  faddp(1);\n+  fmul(2);\n+  fld_x(ExternalAddress(12 + TQ));    \/\/0xb6a3, 0xc36a, 0x44\n+  faddp(1);\n+  fmul(2);\n+  fld_x(ExternalAddress(TQ));    \/\/0x399c, 0x8391, 0x15\n+  faddp(1);\n+  fld_x(ExternalAddress(12 + TP));    \/\/0x4b06, 0xb0ac, 0xd3\n+  faddp(2);\n+  fxch(1);\n+  fmul(2);\n+  fld_x(ExternalAddress(TP));    \/\/0x4cd6, 0xaf6c, 0xc7\n+  faddp(1);\n+  fdivrp(1);\n+  fmulp(1);\n+  fmul(1);\n+  fld_d(Address(ONES, RelocationHolder::none).plus_disp(eax, Address::times_8));\n+  fmula(1);\n+  fmulp(2);\n+  faddp(1);\n+  fstp_d(Address(esp, 16));\n+  movsd(xmm0, Address(esp, 16));\n+  jmp(B1_35);\n+\n+  bind(B1_34);\n+  fld_d(ExternalAddress(ONES));\n+  fdiv(2);\n+  fld_s(1);\n+  fmul(2);\n+  fld_x(ExternalAddress(132 + GP));    \/\/0x00a3, 0x7fea, 0x9b\n+  fmul(1);\n+  fld_x(ExternalAddress(120 + GP));    \/\/0xa559, 0x1da9, 0xae\n+  fmul(2);\n+  fld_x(ExternalAddress(108 + GP));    \/\/0x67c9, 0xbed3, 0xbf\n+  movl(eax, Address(esp, 44));\n+  faddp(2);\n+  fxch(1);\n+  fmul(2);\n+  fld_x(ExternalAddress(96 + GP));    \/\/0x286b, 0xb49e, 0xb8\n+  faddp(2);\n+  fxch(1);\n+  fmul(2);\n+  fld_x(ExternalAddress(84 + GP));    \/\/0x355b, 0xd910, 0x67\n+  faddp(2);\n+  fxch(1);\n+  fmul(2);\n+  fld_x(ExternalAddress(72 + GP));    \/\/0xf3ca, 0x8c96, 0x8e\n+  faddp(2);\n+  fxch(1);\n+  fmul(2);\n+  fld_x(ExternalAddress(60 + GP));    \/\/0xa8f9, 0x83f1, 0x2e\n+  faddp(2);\n+  fxch(1);\n+  fmul(2);\n+  fld_x(ExternalAddress(48 + GP));    \/\/0x7065, 0x6a37, 0x79\n+  faddp(2);\n+  fxch(1);\n+  fmul(2);\n+  fld_x(ExternalAddress(36 + GP));    \/\/0x85a0, 0xa819, 0xbc\n+  faddp(2);\n+  fxch(1);\n+  fmul(2);\n+  fld_x(ExternalAddress(24 + GP));    \/\/0xdfa7, 0x08aa, 0x55\n+  faddp(2);\n+  fxch(1);\n+  fmulp(2);\n+  fld_x(ExternalAddress(12 + GP));    \/\/0xb62f, 0x0b60, 0x60\n+  faddp(1);\n+  fmulp(3);\n+  fld_x(ExternalAddress(GP));    \/\/0xaaab, 0xaaaa, 0xaa\n+  faddp(1);\n+  fmul(3);\n+  fxch(2);\n+  fmulp(3);\n+  fxch(1);\n+  faddp(2);\n+  fld_d(Address(ONES, RelocationHolder::none).plus_disp(eax, Address::times_8));\n+  fmula(2);\n+  fmulp(1);\n+  faddp(1);\n+  fstp_d(Address(esp, 16));\n+  movsd(xmm0, Address(esp, 16));\n+\n+  bind(B1_35);\n+  testl(edi, edi);\n+  jcc(Assembler::equal, B1_37);\n+\n+  bind(B1_36);\n+  fldcw(Address(esp, 38));\n+\n+  bind(B1_37);\n+  movl(eax, Address(esp, 40));\n+  movsd(Address(eax, 8), xmm0);\n+  addl(esp, 52);\n+  pop(ebx);\n+  pop(edi);\n+  pop(esi);\n+  mov(esp, ebp);\n+  pop(ebp);\n+  ret(0);\n+\n+  bind(B1_38);\n+  fstp_d(0);\n+  addl(esp, 52);\n+  pop(ebx);\n+  pop(edi);\n+  pop(esi);\n+  mov(esp, ebp);\n+  pop(ebp);\n+  ret(0);\n+\n+  bind(B1_39);\n+  xorl(edi, edi);\n+  jmp(B1_8);\n+\n+  bind(B1_40);\n+  xorl(edi, edi);\n+  jmp(B1_15);\n+}\n+\n+ATTRIBUTE_ALIGNED(16) juint _static_const_table_tan[] =\n+{\n+    0x00000000UL, 0x00000000UL, 0x00000000UL, 0x00000000UL, 0x882c10faUL,\n+    0x3f9664f4UL, 0x00000000UL, 0x00000000UL, 0x00000000UL, 0x00000000UL,\n+    0x00000000UL, 0x00000000UL, 0x55e6c23dUL, 0x3f8226e3UL, 0x55555555UL,\n+    0x3fd55555UL, 0x00000000UL, 0x00000000UL, 0x00000000UL, 0x00000000UL,\n+    0x0e157de0UL, 0x3f6d6d3dUL, 0x11111111UL, 0x3fc11111UL, 0x00000000UL,\n+    0x00000000UL, 0x00000000UL, 0x00000000UL, 0x452b75e3UL, 0x3f57da36UL,\n+    0x1ba1ba1cUL, 0x3faba1baUL, 0x00000000UL, 0x00000000UL, 0x00000000UL,\n+    0x00000000UL, 0x00000000UL, 0x3ff00000UL, 0x00000000UL, 0x00000000UL,\n+    0x00000000UL, 0x00000000UL, 0x00000000UL, 0x00000000UL, 0x4e435f9bUL,\n+    0x3f953f83UL, 0x00000000UL, 0x00000000UL, 0x3c6e8e46UL, 0x3f9b74eaUL,\n+    0x00000000UL, 0x00000000UL, 0xda5b7511UL, 0x3f85ad63UL, 0xdc230b9bUL,\n+    0x3fb97558UL, 0x26cb3788UL, 0x3f881308UL, 0x76fc4985UL, 0x3fd62ac9UL,\n+    0x77bb08baUL, 0x3f757c85UL, 0xb6247521UL, 0x3fb1381eUL, 0x5922170cUL,\n+    0x3f754e95UL, 0x8746482dUL, 0x3fc27f83UL, 0x11055b30UL, 0x3f64e391UL,\n+    0x3e666320UL, 0x3fa3e609UL, 0x0de9dae3UL, 0x3f6301dfUL, 0x1f1dca06UL,\n+    0x3fafa8aeUL, 0x8c5b2da2UL, 0x3fb936bbUL, 0x4e88f7a5UL, 0x3c587d05UL,\n+    0x00000000UL, 0x3ff00000UL, 0xa8935dd9UL, 0x3f83dde2UL, 0x00000000UL,\n+    0x00000000UL, 0x00000000UL, 0x00000000UL, 0x5a279ea3UL, 0x3faa3407UL,\n+    0x00000000UL, 0x00000000UL, 0x432d65faUL, 0x3fa70153UL, 0x00000000UL,\n+    0x00000000UL, 0x891a4602UL, 0x3f9d03efUL, 0xd62ca5f8UL, 0x3fca77d9UL,\n+    0xb35f4628UL, 0x3f97a265UL, 0x433258faUL, 0x3fd8cf51UL, 0xb58fd909UL,\n+    0x3f8f88e3UL, 0x01771ceaUL, 0x3fc2b154UL, 0xf3562f8eUL, 0x3f888f57UL,\n+    0xc028a723UL, 0x3fc7370fUL, 0x20b7f9f0UL, 0x3f80f44cUL, 0x214368e9UL,\n+    0x3fb6dfaaUL, 0x28891863UL, 0x3f79b4b6UL, 0x172dbbf0UL, 0x3fb6cb8eUL,\n+    0xe0553158UL, 0x3fc975f5UL, 0x593fe814UL, 0x3c2ef5d3UL, 0x00000000UL,\n+    0x3ff00000UL, 0x03dec550UL, 0x3fa44203UL, 0x00000000UL, 0x00000000UL,\n+    0x00000000UL, 0x00000000UL, 0x9314533eUL, 0x3fbb8ec5UL, 0x00000000UL,\n+    0x00000000UL, 0x09aa36d0UL, 0x3fb6d3f4UL, 0x00000000UL, 0x00000000UL,\n+    0xdcb427fdUL, 0x3fb13950UL, 0xd87ab0bbUL, 0x3fd5335eUL, 0xce0ae8a5UL,\n+    0x3fabb382UL, 0x79143126UL, 0x3fddba41UL, 0x5f2b28d4UL, 0x3fa552f1UL,\n+    0x59f21a6dUL, 0x3fd015abUL, 0x22c27d95UL, 0x3fa0e984UL, 0xe19fc6aaUL,\n+    0x3fd0576cUL, 0x8f2c2950UL, 0x3f9a4898UL, 0xc0b3f22cUL, 0x3fc59462UL,\n+    0x1883a4b8UL, 0x3f94b61cUL, 0x3f838640UL, 0x3fc30eb8UL, 0x355c63dcUL,\n+    0x3fd36a08UL, 0x1dce993dUL, 0xbc6d704dUL, 0x00000000UL, 0x3ff00000UL,\n+    0x2b82ab63UL, 0x3fb78e92UL, 0x00000000UL, 0x00000000UL, 0x00000000UL,\n+    0x00000000UL, 0x56f37042UL, 0x3fccfc56UL, 0x00000000UL, 0x00000000UL,\n+    0xaa563951UL, 0x3fc90125UL, 0x00000000UL, 0x00000000UL, 0x3d0e7c5dUL,\n+    0x3fc50533UL, 0x9bed9b2eUL, 0x3fdf0ed9UL, 0x5fe7c47cUL, 0x3fc1f250UL,\n+    0x96c125e5UL, 0x3fe2edd9UL, 0x5a02bbd8UL, 0x3fbe5c71UL, 0x86362c20UL,\n+    0x3fda08b7UL, 0x4b4435edUL, 0x3fb9d342UL, 0x4b494091UL, 0x3fd911bdUL,\n+    0xb56658beUL, 0x3fb5e4c7UL, 0x93a2fd76UL, 0x3fd3c092UL, 0xda271794UL,\n+    0x3fb29910UL, 0x3303df2bUL, 0x3fd189beUL, 0x99fcef32UL, 0x3fda8279UL,\n+    0xb68c1467UL, 0x3c708b2fUL, 0x00000000UL, 0x3ff00000UL, 0x980c4337UL,\n+    0x3fc5f619UL, 0x00000000UL, 0x00000000UL, 0x00000000UL, 0x00000000UL,\n+    0xcc03e501UL, 0x3fdff10fUL, 0x00000000UL, 0x00000000UL, 0x44a4e845UL,\n+    0x3fddb63bUL, 0x00000000UL, 0x00000000UL, 0x3768ad9fUL, 0x3fdb72a4UL,\n+    0x3dd01ccaUL, 0x3fe5fdb9UL, 0xa61d2811UL, 0x3fd972b2UL, 0x5645ad0bUL,\n+    0x3fe977f9UL, 0xd013b3abUL, 0x3fd78ca3UL, 0xbf0bf914UL, 0x3fe4f192UL,\n+    0x4d53e730UL, 0x3fd5d060UL, 0x3f8b9000UL, 0x3fe49933UL, 0xe2b82f08UL,\n+    0x3fd4322aUL, 0x5936a835UL, 0x3fe27ae1UL, 0xb1c61c9bUL, 0x3fd2b3fbUL,\n+    0xef478605UL, 0x3fe1659eUL, 0x190834ecUL, 0x3fe11ab7UL, 0xcdb625eaUL,\n+    0xbc8e564bUL, 0x00000000UL, 0x3ff00000UL, 0xb07217e3UL, 0x3fd248f1UL,\n+    0x00000000UL, 0x00000000UL, 0x00000000UL, 0x00000000UL, 0x2b2c49d0UL,\n+    0x3ff2de9cUL, 0x00000000UL, 0x00000000UL, 0x2655bc98UL, 0x3ff33e58UL,\n+    0x00000000UL, 0x00000000UL, 0xff691fa2UL, 0x3ff3972eUL, 0xe93463bdUL,\n+    0x3feeed87UL, 0x070e10a0UL, 0x3ff3f5b2UL, 0xf4d790a4UL, 0x3ff20c10UL,\n+    0xa04e8ea3UL, 0x3ff4541aUL, 0x386accd3UL, 0x3ff1369eUL, 0x222a66ddUL,\n+    0x3ff4b521UL, 0x22a9777eUL, 0x3ff20817UL, 0x52a04a6eUL, 0x3ff5178fUL,\n+    0xddaa0031UL, 0x3ff22137UL, 0x4447d47cUL, 0x3ff57c01UL, 0x1e9c7f1dUL,\n+    0x3ff29311UL, 0x2ab7f990UL, 0x3fe561b8UL, 0x209c7df1UL, 0x3c87a8c5UL,\n+    0x00000000UL, 0x3ff00000UL, 0x4170bcc6UL, 0x3fdc92d8UL, 0x00000000UL,\n+    0x00000000UL, 0x00000000UL, 0x00000000UL, 0xc7ab4d5aUL, 0x40085e24UL,\n+    0x00000000UL, 0x00000000UL, 0xe93ea75dUL, 0x400b963dUL, 0x00000000UL,\n+    0x00000000UL, 0x94a7f25aUL, 0x400f37e2UL, 0x4b6261cbUL, 0x3ff5f984UL,\n+    0x5a9dd812UL, 0x4011aab0UL, 0x74c30018UL, 0x3ffaf5a5UL, 0x7f2ce8e3UL,\n+    0x4013fe8bUL, 0xfe8e54faUL, 0x3ffd7334UL, 0x670d618dUL, 0x4016a10cUL,\n+    0x4db97058UL, 0x4000e012UL, 0x24df44ddUL, 0x40199c5fUL, 0x697d6eceUL,\n+    0x4003006eUL, 0x83298b82UL, 0x401cfc4dUL, 0x19d490d6UL, 0x40058c19UL,\n+    0x2ae42850UL, 0x3fea4300UL, 0x118e20e6UL, 0xbc7a6db8UL, 0x00000000UL,\n+    0x40000000UL, 0xe33345b8UL, 0xbfd4e526UL, 0x00000000UL, 0x00000000UL,\n+    0x00000000UL, 0x00000000UL, 0x65965966UL, 0x40219659UL, 0x00000000UL,\n+    0x00000000UL, 0x882c10faUL, 0x402664f4UL, 0x00000000UL, 0x00000000UL,\n+    0x83cd3723UL, 0x402c8342UL, 0x00000000UL, 0x40000000UL, 0x55e6c23dUL,\n+    0x403226e3UL, 0x55555555UL, 0x40055555UL, 0x34451939UL, 0x40371c96UL,\n+    0xaaaaaaabUL, 0x400aaaaaUL, 0x0e157de0UL, 0x403d6d3dUL, 0x11111111UL,\n+    0x40111111UL, 0xa738201fUL, 0x4042bbceUL, 0x05b05b06UL, 0x4015b05bUL,\n+    0x452b75e3UL, 0x4047da36UL, 0x1ba1ba1cUL, 0x401ba1baUL, 0x00000000UL,\n+    0x3ff00000UL, 0x00000000UL, 0x00000000UL, 0x00000000UL, 0x40000000UL,\n+    0x00000000UL, 0x00000000UL, 0x00000000UL, 0x00000000UL, 0x00000000UL,\n+    0x00000000UL, 0x4f48b8d3UL, 0xbf33eaf9UL, 0x00000000UL, 0x00000000UL,\n+    0x0cf7586fUL, 0x3f20b8eaUL, 0x00000000UL, 0x00000000UL, 0xd0258911UL,\n+    0xbf0abaf3UL, 0x23e49fe9UL, 0xbfab5a8cUL, 0x2d53222eUL, 0x3ef60d15UL,\n+    0x21169451UL, 0x3fa172b2UL, 0xbb254dbcUL, 0xbee1d3b5UL, 0xdbf93b8eUL,\n+    0xbf84c7dbUL, 0x05b4630bUL, 0x3ecd3364UL, 0xee9aada7UL, 0x3f743924UL,\n+    0x794a8297UL, 0xbeb7b7b9UL, 0xe015f797UL, 0xbf5d41f5UL, 0xe41a4a56UL,\n+    0x3ea35dfbUL, 0xe4c2a251UL, 0x3f49a2abUL, 0x5af9e000UL, 0xbfce49ceUL,\n+    0x8c743719UL, 0x3d1eb860UL, 0x00000000UL, 0x00000000UL, 0x1b4863cfUL,\n+    0x3fd78294UL, 0x00000000UL, 0x3ff00000UL, 0x00000000UL, 0xfffffff8UL,\n+    0x535ad890UL, 0xbf2b9320UL, 0x00000000UL, 0x00000000UL, 0x018fdf1fUL,\n+    0x3f16d61dUL, 0x00000000UL, 0x00000000UL, 0x0359f1beUL, 0xbf0139e4UL,\n+    0xa4317c6dUL, 0xbfa67e17UL, 0x82672d0fUL, 0x3eebb405UL, 0x2f1b621eUL,\n+    0x3f9f455bUL, 0x51ccf238UL, 0xbed55317UL, 0xf437b9acUL, 0xbf804beeUL,\n+    0xc791a2b5UL, 0x3ec0e993UL, 0x919a1db2UL, 0x3f7080c2UL, 0x336a5b0eUL,\n+    0xbeaa48a2UL, 0x0a268358UL, 0xbf55a443UL, 0xdfd978e4UL, 0x3e94b61fUL,\n+    0xd7767a58UL, 0x3f431806UL, 0x2aea0000UL, 0xbfc9bbe8UL, 0x7723ea61UL,\n+    0xbd3a2369UL, 0x00000000UL, 0x00000000UL, 0xdf7796ffUL, 0x3fd6e642UL,\n+    0x00000000UL, 0x3ff00000UL, 0x00000000UL, 0xfffffff8UL, 0xb9ff07ceUL,\n+    0xbf231c78UL, 0x00000000UL, 0x00000000UL, 0xa5517182UL, 0x3f0ff0e0UL,\n+    0x00000000UL, 0x00000000UL, 0x790b4cbcUL, 0xbef66191UL, 0x848a46c6UL,\n+    0xbfa21ac0UL, 0xb16435faUL, 0x3ee1d3ecUL, 0x2a1aa832UL, 0x3f9c71eaUL,\n+    0xfdd299efUL, 0xbec9dd1aUL, 0x3f8dbaafUL, 0xbf793363UL, 0x309fc6eaUL,\n+    0x3eb415d6UL, 0xbee60471UL, 0x3f6b83baUL, 0x94a0a697UL, 0xbe9dae11UL,\n+    0x3e5c67b3UL, 0xbf4fd07bUL, 0x9a8f3e3eUL, 0x3e86bd75UL, 0xa4beb7a4UL,\n+    0x3f3d1eb1UL, 0x29cfc000UL, 0xbfc549ceUL, 0xbf159358UL, 0xbd397b33UL,\n+    0x00000000UL, 0x00000000UL, 0x871fee6cUL, 0x3fd666f0UL, 0x00000000UL,\n+    0x3ff00000UL, 0x00000000UL, 0xfffffff8UL, 0x7d98a556UL, 0xbf1a3958UL,\n+    0x00000000UL, 0x00000000UL, 0x9d88dc01UL, 0x3f0704c2UL, 0x00000000UL,\n+    0x00000000UL, 0x73742a2bUL, 0xbeed054aUL, 0x58844587UL, 0xbf9c2a13UL,\n+    0x55688a79UL, 0x3ed7a326UL, 0xee33f1d6UL, 0x3f9a48f4UL, 0xa8dc9888UL,\n+    0xbebf8939UL, 0xaad4b5b8UL, 0xbf72f746UL, 0x9102efa1UL, 0x3ea88f82UL,\n+    0xdabc29cfUL, 0x3f678228UL, 0x9289afb8UL, 0xbe90f456UL, 0x741fb4edUL,\n+    0xbf46f3a3UL, 0xa97f6663UL, 0x3e79b4bfUL, 0xca89ff3fUL, 0x3f36db70UL,\n+    0xa8a2a000UL, 0xbfc0ee13UL, 0x3da24be1UL, 0xbd338b9fUL, 0x00000000UL,\n+    0x00000000UL, 0x11cd6c69UL, 0x3fd601fdUL, 0x00000000UL, 0x3ff00000UL,\n+    0x00000000UL, 0xfffffff8UL, 0x1a154b97UL, 0xbf116b01UL, 0x00000000UL,\n+    0x00000000UL, 0x2d427630UL, 0x3f0147bfUL, 0x00000000UL, 0x00000000UL,\n+    0xb93820c8UL, 0xbee264d4UL, 0xbb6cbb18UL, 0xbf94ab8cUL, 0x888d4d92UL,\n+    0x3ed0568bUL, 0x60730f7cUL, 0x3f98b19bUL, 0xe4b1fb11UL, 0xbeb2f950UL,\n+    0x22cf9f74UL, 0xbf6b21cdUL, 0x4a3ff0a6UL, 0x3e9f499eUL, 0xfd2b83ceUL,\n+    0x3f64aad7UL, 0x637b73afUL, 0xbe83487cUL, 0xe522591aUL, 0xbf3fc092UL,\n+    0xa158e8bcUL, 0x3e6e3aaeUL, 0xe5e82ffaUL, 0x3f329d2fUL, 0xd636a000UL,\n+    0xbfb9477fUL, 0xc2c2d2bcUL, 0xbd135ef9UL, 0x00000000UL, 0x00000000UL,\n+    0xf2fdb123UL, 0x3fd5b566UL, 0x00000000UL, 0x3ff00000UL, 0x00000000UL,\n+    0xfffffff8UL, 0xc41acb64UL, 0xbf05448dUL, 0x00000000UL, 0x00000000UL,\n+    0xdbb03d6fUL, 0x3efb7ad2UL, 0x00000000UL, 0x00000000UL, 0x9e42962dUL,\n+    0xbed5aea5UL, 0x2579f8efUL, 0xbf8b2398UL, 0x288a1ed9UL, 0x3ec81441UL,\n+    0xb0198dc5UL, 0x3f979a3aUL, 0x2fdfe253UL, 0xbea57cd3UL, 0x5766336fUL,\n+    0xbf617caaUL, 0x600944c3UL, 0x3e954ed6UL, 0xa4e0aaf8UL, 0x3f62c646UL,\n+    0x6b8fb29cUL, 0xbe74e3a3UL, 0xdc4c0409UL, 0xbf33f952UL, 0x9bffe365UL,\n+    0x3e6301ecUL, 0xb8869e44UL, 0x3f2fc566UL, 0xe1e04000UL, 0xbfb0cc62UL,\n+    0x016b907fUL, 0xbd119cbcUL, 0x00000000UL, 0x00000000UL, 0xe6b9d8faUL,\n+    0x3fd57fb3UL, 0x00000000UL, 0x3ff00000UL, 0x00000000UL, 0xfffffff8UL,\n+    0x5daf22a6UL, 0xbef429d7UL, 0x00000000UL, 0x00000000UL, 0x06bca545UL,\n+    0x3ef7a27dUL, 0x00000000UL, 0x00000000UL, 0x7211c19aUL, 0xbec41c3eUL,\n+    0x956ed53eUL, 0xbf7ae3f4UL, 0xee750e72UL, 0x3ec3901bUL, 0x91d443f5UL,\n+    0x3f96f713UL, 0x36661e6cUL, 0xbe936e09UL, 0x506f9381UL, 0xbf5122e8UL,\n+    0xcb6dd43fUL, 0x3e9041b9UL, 0x6698b2ffUL, 0x3f61b0c7UL, 0x576bf12bUL,\n+    0xbe625a8aUL, 0xe5a0e9dcUL, 0xbf23499dUL, 0x110384ddUL, 0x3e5b1c2cUL,\n+    0x68d43db6UL, 0x3f2cb899UL, 0x6ecac000UL, 0xbfa0c414UL, 0xcd7dd58cUL,\n+    0x3d13500fUL, 0x00000000UL, 0x00000000UL, 0x85a2c8fbUL, 0x3fd55fe0UL,\n+    0x00000000UL, 0x3ff00000UL, 0x00000000UL, 0xfffffff8UL, 0x00000000UL,\n+    0x00000000UL, 0x00000000UL, 0x00000000UL, 0x2bf70ebeUL, 0x3ef66a8fUL,\n+    0x00000000UL, 0x00000000UL, 0x00000000UL, 0x00000000UL, 0x00000000UL,\n+    0x00000000UL, 0xd644267fUL, 0x3ec22805UL, 0x16c16c17UL, 0x3f96c16cUL,\n+    0x00000000UL, 0x00000000UL, 0x00000000UL, 0x00000000UL, 0xc4e09162UL,\n+    0x3e8d6db2UL, 0xbc011567UL, 0x3f61566aUL, 0x00000000UL, 0x00000000UL,\n+    0x00000000UL, 0x00000000UL, 0x1f79955cUL, 0x3e57da4eUL, 0x9334ef0bUL,\n+    0x3f2bbd77UL, 0x00000000UL, 0x00000000UL, 0x00000000UL, 0x00000000UL,\n+    0x00000000UL, 0x00000000UL, 0x55555555UL, 0x3fd55555UL, 0x00000000UL,\n+    0x3ff00000UL, 0x00000000UL, 0xfffffff8UL, 0x5daf22a6UL, 0x3ef429d7UL,\n+    0x00000000UL, 0x00000000UL, 0x06bca545UL, 0x3ef7a27dUL, 0x00000000UL,\n+    0x00000000UL, 0x7211c19aUL, 0x3ec41c3eUL, 0x956ed53eUL, 0x3f7ae3f4UL,\n+    0xee750e72UL, 0x3ec3901bUL, 0x91d443f5UL, 0x3f96f713UL, 0x36661e6cUL,\n+    0x3e936e09UL, 0x506f9381UL, 0x3f5122e8UL, 0xcb6dd43fUL, 0x3e9041b9UL,\n+    0x6698b2ffUL, 0x3f61b0c7UL, 0x576bf12bUL, 0x3e625a8aUL, 0xe5a0e9dcUL,\n+    0x3f23499dUL, 0x110384ddUL, 0x3e5b1c2cUL, 0x68d43db6UL, 0x3f2cb899UL,\n+    0x6ecac000UL, 0x3fa0c414UL, 0xcd7dd58cUL, 0xbd13500fUL, 0x00000000UL,\n+    0x00000000UL, 0x85a2c8fbUL, 0x3fd55fe0UL, 0x00000000UL, 0x3ff00000UL,\n+    0x00000000UL, 0xfffffff8UL, 0xc41acb64UL, 0x3f05448dUL, 0x00000000UL,\n+    0x00000000UL, 0xdbb03d6fUL, 0x3efb7ad2UL, 0x00000000UL, 0x00000000UL,\n+    0x9e42962dUL, 0x3ed5aea5UL, 0x2579f8efUL, 0x3f8b2398UL, 0x288a1ed9UL,\n+    0x3ec81441UL, 0xb0198dc5UL, 0x3f979a3aUL, 0x2fdfe253UL, 0x3ea57cd3UL,\n+    0x5766336fUL, 0x3f617caaUL, 0x600944c3UL, 0x3e954ed6UL, 0xa4e0aaf8UL,\n+    0x3f62c646UL, 0x6b8fb29cUL, 0x3e74e3a3UL, 0xdc4c0409UL, 0x3f33f952UL,\n+    0x9bffe365UL, 0x3e6301ecUL, 0xb8869e44UL, 0x3f2fc566UL, 0xe1e04000UL,\n+    0x3fb0cc62UL, 0x016b907fUL, 0x3d119cbcUL, 0x00000000UL, 0x00000000UL,\n+    0xe6b9d8faUL, 0x3fd57fb3UL, 0x00000000UL, 0x3ff00000UL, 0x00000000UL,\n+    0xfffffff8UL, 0x1a154b97UL, 0x3f116b01UL, 0x00000000UL, 0x00000000UL,\n+    0x2d427630UL, 0x3f0147bfUL, 0x00000000UL, 0x00000000UL, 0xb93820c8UL,\n+    0x3ee264d4UL, 0xbb6cbb18UL, 0x3f94ab8cUL, 0x888d4d92UL, 0x3ed0568bUL,\n+    0x60730f7cUL, 0x3f98b19bUL, 0xe4b1fb11UL, 0x3eb2f950UL, 0x22cf9f74UL,\n+    0x3f6b21cdUL, 0x4a3ff0a6UL, 0x3e9f499eUL, 0xfd2b83ceUL, 0x3f64aad7UL,\n+    0x637b73afUL, 0x3e83487cUL, 0xe522591aUL, 0x3f3fc092UL, 0xa158e8bcUL,\n+    0x3e6e3aaeUL, 0xe5e82ffaUL, 0x3f329d2fUL, 0xd636a000UL, 0x3fb9477fUL,\n+    0xc2c2d2bcUL, 0x3d135ef9UL, 0x00000000UL, 0x00000000UL, 0xf2fdb123UL,\n+    0x3fd5b566UL, 0x00000000UL, 0x3ff00000UL, 0x00000000UL, 0xfffffff8UL,\n+    0x7d98a556UL, 0x3f1a3958UL, 0x00000000UL, 0x00000000UL, 0x9d88dc01UL,\n+    0x3f0704c2UL, 0x00000000UL, 0x00000000UL, 0x73742a2bUL, 0x3eed054aUL,\n+    0x58844587UL, 0x3f9c2a13UL, 0x55688a79UL, 0x3ed7a326UL, 0xee33f1d6UL,\n+    0x3f9a48f4UL, 0xa8dc9888UL, 0x3ebf8939UL, 0xaad4b5b8UL, 0x3f72f746UL,\n+    0x9102efa1UL, 0x3ea88f82UL, 0xdabc29cfUL, 0x3f678228UL, 0x9289afb8UL,\n+    0x3e90f456UL, 0x741fb4edUL, 0x3f46f3a3UL, 0xa97f6663UL, 0x3e79b4bfUL,\n+    0xca89ff3fUL, 0x3f36db70UL, 0xa8a2a000UL, 0x3fc0ee13UL, 0x3da24be1UL,\n+    0x3d338b9fUL, 0x00000000UL, 0x00000000UL, 0x11cd6c69UL, 0x3fd601fdUL,\n+    0x00000000UL, 0x3ff00000UL, 0x00000000UL, 0xfffffff8UL, 0xb9ff07ceUL,\n+    0x3f231c78UL, 0x00000000UL, 0x00000000UL, 0xa5517182UL, 0x3f0ff0e0UL,\n+    0x00000000UL, 0x00000000UL, 0x790b4cbcUL, 0x3ef66191UL, 0x848a46c6UL,\n+    0x3fa21ac0UL, 0xb16435faUL, 0x3ee1d3ecUL, 0x2a1aa832UL, 0x3f9c71eaUL,\n+    0xfdd299efUL, 0x3ec9dd1aUL, 0x3f8dbaafUL, 0x3f793363UL, 0x309fc6eaUL,\n+    0x3eb415d6UL, 0xbee60471UL, 0x3f6b83baUL, 0x94a0a697UL, 0x3e9dae11UL,\n+    0x3e5c67b3UL, 0x3f4fd07bUL, 0x9a8f3e3eUL, 0x3e86bd75UL, 0xa4beb7a4UL,\n+    0x3f3d1eb1UL, 0x29cfc000UL, 0x3fc549ceUL, 0xbf159358UL, 0x3d397b33UL,\n+    0x00000000UL, 0x00000000UL, 0x871fee6cUL, 0x3fd666f0UL, 0x00000000UL,\n+    0x3ff00000UL, 0x00000000UL, 0xfffffff8UL, 0x535ad890UL, 0x3f2b9320UL,\n+    0x00000000UL, 0x00000000UL, 0x018fdf1fUL, 0x3f16d61dUL, 0x00000000UL,\n+    0x00000000UL, 0x0359f1beUL, 0x3f0139e4UL, 0xa4317c6dUL, 0x3fa67e17UL,\n+    0x82672d0fUL, 0x3eebb405UL, 0x2f1b621eUL, 0x3f9f455bUL, 0x51ccf238UL,\n+    0x3ed55317UL, 0xf437b9acUL, 0x3f804beeUL, 0xc791a2b5UL, 0x3ec0e993UL,\n+    0x919a1db2UL, 0x3f7080c2UL, 0x336a5b0eUL, 0x3eaa48a2UL, 0x0a268358UL,\n+    0x3f55a443UL, 0xdfd978e4UL, 0x3e94b61fUL, 0xd7767a58UL, 0x3f431806UL,\n+    0x2aea0000UL, 0x3fc9bbe8UL, 0x7723ea61UL, 0x3d3a2369UL, 0x00000000UL,\n+    0x00000000UL, 0xdf7796ffUL, 0x3fd6e642UL, 0x00000000UL, 0x3ff00000UL,\n+    0x00000000UL, 0xfffffff8UL, 0x4f48b8d3UL, 0x3f33eaf9UL, 0x00000000UL,\n+    0x00000000UL, 0x0cf7586fUL, 0x3f20b8eaUL, 0x00000000UL, 0x00000000UL,\n+    0xd0258911UL, 0x3f0abaf3UL, 0x23e49fe9UL, 0x3fab5a8cUL, 0x2d53222eUL,\n+    0x3ef60d15UL, 0x21169451UL, 0x3fa172b2UL, 0xbb254dbcUL, 0x3ee1d3b5UL,\n+    0xdbf93b8eUL, 0x3f84c7dbUL, 0x05b4630bUL, 0x3ecd3364UL, 0xee9aada7UL,\n+    0x3f743924UL, 0x794a8297UL, 0x3eb7b7b9UL, 0xe015f797UL, 0x3f5d41f5UL,\n+    0xe41a4a56UL, 0x3ea35dfbUL, 0xe4c2a251UL, 0x3f49a2abUL, 0x5af9e000UL,\n+    0x3fce49ceUL, 0x8c743719UL, 0xbd1eb860UL, 0x00000000UL, 0x00000000UL,\n+    0x1b4863cfUL, 0x3fd78294UL, 0x00000000UL, 0x3ff00000UL, 0x00000000UL,\n+    0xfffffff8UL, 0x65965966UL, 0xc0219659UL, 0x00000000UL, 0x00000000UL,\n+    0x882c10faUL, 0x402664f4UL, 0x00000000UL, 0x00000000UL, 0x83cd3723UL,\n+    0xc02c8342UL, 0x00000000UL, 0xc0000000UL, 0x55e6c23dUL, 0x403226e3UL,\n+    0x55555555UL, 0x40055555UL, 0x34451939UL, 0xc0371c96UL, 0xaaaaaaabUL,\n+    0xc00aaaaaUL, 0x0e157de0UL, 0x403d6d3dUL, 0x11111111UL, 0x40111111UL,\n+    0xa738201fUL, 0xc042bbceUL, 0x05b05b06UL, 0xc015b05bUL, 0x452b75e3UL,\n+    0x4047da36UL, 0x1ba1ba1cUL, 0x401ba1baUL, 0x00000000UL, 0xbff00000UL,\n+    0x00000000UL, 0x00000000UL, 0x00000000UL, 0x40000000UL, 0x00000000UL,\n+    0x00000000UL, 0x00000000UL, 0x00000000UL, 0x00000000UL, 0x00000000UL,\n+    0xc7ab4d5aUL, 0xc0085e24UL, 0x00000000UL, 0x00000000UL, 0xe93ea75dUL,\n+    0x400b963dUL, 0x00000000UL, 0x00000000UL, 0x94a7f25aUL, 0xc00f37e2UL,\n+    0x4b6261cbUL, 0xbff5f984UL, 0x5a9dd812UL, 0x4011aab0UL, 0x74c30018UL,\n+    0x3ffaf5a5UL, 0x7f2ce8e3UL, 0xc013fe8bUL, 0xfe8e54faUL, 0xbffd7334UL,\n+    0x670d618dUL, 0x4016a10cUL, 0x4db97058UL, 0x4000e012UL, 0x24df44ddUL,\n+    0xc0199c5fUL, 0x697d6eceUL, 0xc003006eUL, 0x83298b82UL, 0x401cfc4dUL,\n+    0x19d490d6UL, 0x40058c19UL, 0x2ae42850UL, 0xbfea4300UL, 0x118e20e6UL,\n+    0x3c7a6db8UL, 0x00000000UL, 0x40000000UL, 0xe33345b8UL, 0xbfd4e526UL,\n+    0x00000000UL, 0x00000000UL, 0x00000000UL, 0x00000000UL, 0x2b2c49d0UL,\n+    0xbff2de9cUL, 0x00000000UL, 0x00000000UL, 0x2655bc98UL, 0x3ff33e58UL,\n+    0x00000000UL, 0x00000000UL, 0xff691fa2UL, 0xbff3972eUL, 0xe93463bdUL,\n+    0xbfeeed87UL, 0x070e10a0UL, 0x3ff3f5b2UL, 0xf4d790a4UL, 0x3ff20c10UL,\n+    0xa04e8ea3UL, 0xbff4541aUL, 0x386accd3UL, 0xbff1369eUL, 0x222a66ddUL,\n+    0x3ff4b521UL, 0x22a9777eUL, 0x3ff20817UL, 0x52a04a6eUL, 0xbff5178fUL,\n+    0xddaa0031UL, 0xbff22137UL, 0x4447d47cUL, 0x3ff57c01UL, 0x1e9c7f1dUL,\n+    0x3ff29311UL, 0x2ab7f990UL, 0xbfe561b8UL, 0x209c7df1UL, 0xbc87a8c5UL,\n+    0x00000000UL, 0x3ff00000UL, 0x4170bcc6UL, 0x3fdc92d8UL, 0x00000000UL,\n+    0x00000000UL, 0x00000000UL, 0x00000000UL, 0xcc03e501UL, 0xbfdff10fUL,\n+    0x00000000UL, 0x00000000UL, 0x44a4e845UL, 0x3fddb63bUL, 0x00000000UL,\n+    0x00000000UL, 0x3768ad9fUL, 0xbfdb72a4UL, 0x3dd01ccaUL, 0xbfe5fdb9UL,\n+    0xa61d2811UL, 0x3fd972b2UL, 0x5645ad0bUL, 0x3fe977f9UL, 0xd013b3abUL,\n+    0xbfd78ca3UL, 0xbf0bf914UL, 0xbfe4f192UL, 0x4d53e730UL, 0x3fd5d060UL,\n+    0x3f8b9000UL, 0x3fe49933UL, 0xe2b82f08UL, 0xbfd4322aUL, 0x5936a835UL,\n+    0xbfe27ae1UL, 0xb1c61c9bUL, 0x3fd2b3fbUL, 0xef478605UL, 0x3fe1659eUL,\n+    0x190834ecUL, 0xbfe11ab7UL, 0xcdb625eaUL, 0x3c8e564bUL, 0x00000000UL,\n+    0x3ff00000UL, 0xb07217e3UL, 0x3fd248f1UL, 0x00000000UL, 0x00000000UL,\n+    0x00000000UL, 0x00000000UL, 0x56f37042UL, 0xbfccfc56UL, 0x00000000UL,\n+    0x00000000UL, 0xaa563951UL, 0x3fc90125UL, 0x00000000UL, 0x00000000UL,\n+    0x3d0e7c5dUL, 0xbfc50533UL, 0x9bed9b2eUL, 0xbfdf0ed9UL, 0x5fe7c47cUL,\n+    0x3fc1f250UL, 0x96c125e5UL, 0x3fe2edd9UL, 0x5a02bbd8UL, 0xbfbe5c71UL,\n+    0x86362c20UL, 0xbfda08b7UL, 0x4b4435edUL, 0x3fb9d342UL, 0x4b494091UL,\n+    0x3fd911bdUL, 0xb56658beUL, 0xbfb5e4c7UL, 0x93a2fd76UL, 0xbfd3c092UL,\n+    0xda271794UL, 0x3fb29910UL, 0x3303df2bUL, 0x3fd189beUL, 0x99fcef32UL,\n+    0xbfda8279UL, 0xb68c1467UL, 0xbc708b2fUL, 0x00000000UL, 0x3ff00000UL,\n+    0x980c4337UL, 0x3fc5f619UL, 0x00000000UL, 0x00000000UL, 0x00000000UL,\n+    0x00000000UL, 0x9314533eUL, 0xbfbb8ec5UL, 0x00000000UL, 0x00000000UL,\n+    0x09aa36d0UL, 0x3fb6d3f4UL, 0x00000000UL, 0x00000000UL, 0xdcb427fdUL,\n+    0xbfb13950UL, 0xd87ab0bbUL, 0xbfd5335eUL, 0xce0ae8a5UL, 0x3fabb382UL,\n+    0x79143126UL, 0x3fddba41UL, 0x5f2b28d4UL, 0xbfa552f1UL, 0x59f21a6dUL,\n+    0xbfd015abUL, 0x22c27d95UL, 0x3fa0e984UL, 0xe19fc6aaUL, 0x3fd0576cUL,\n+    0x8f2c2950UL, 0xbf9a4898UL, 0xc0b3f22cUL, 0xbfc59462UL, 0x1883a4b8UL,\n+    0x3f94b61cUL, 0x3f838640UL, 0x3fc30eb8UL, 0x355c63dcUL, 0xbfd36a08UL,\n+    0x1dce993dUL, 0x3c6d704dUL, 0x00000000UL, 0x3ff00000UL, 0x2b82ab63UL,\n+    0x3fb78e92UL, 0x00000000UL, 0x00000000UL, 0x00000000UL, 0x00000000UL,\n+    0x5a279ea3UL, 0xbfaa3407UL, 0x00000000UL, 0x00000000UL, 0x432d65faUL,\n+    0x3fa70153UL, 0x00000000UL, 0x00000000UL, 0x891a4602UL, 0xbf9d03efUL,\n+    0xd62ca5f8UL, 0xbfca77d9UL, 0xb35f4628UL, 0x3f97a265UL, 0x433258faUL,\n+    0x3fd8cf51UL, 0xb58fd909UL, 0xbf8f88e3UL, 0x01771ceaUL, 0xbfc2b154UL,\n+    0xf3562f8eUL, 0x3f888f57UL, 0xc028a723UL, 0x3fc7370fUL, 0x20b7f9f0UL,\n+    0xbf80f44cUL, 0x214368e9UL, 0xbfb6dfaaUL, 0x28891863UL, 0x3f79b4b6UL,\n+    0x172dbbf0UL, 0x3fb6cb8eUL, 0xe0553158UL, 0xbfc975f5UL, 0x593fe814UL,\n+    0xbc2ef5d3UL, 0x00000000UL, 0x3ff00000UL, 0x03dec550UL, 0x3fa44203UL,\n+    0x00000000UL, 0x00000000UL, 0x00000000UL, 0x00000000UL, 0x4e435f9bUL,\n+    0xbf953f83UL, 0x00000000UL, 0x00000000UL, 0x3c6e8e46UL, 0x3f9b74eaUL,\n+    0x00000000UL, 0x00000000UL, 0xda5b7511UL, 0xbf85ad63UL, 0xdc230b9bUL,\n+    0xbfb97558UL, 0x26cb3788UL, 0x3f881308UL, 0x76fc4985UL, 0x3fd62ac9UL,\n+    0x77bb08baUL, 0xbf757c85UL, 0xb6247521UL, 0xbfb1381eUL, 0x5922170cUL,\n+    0x3f754e95UL, 0x8746482dUL, 0x3fc27f83UL, 0x11055b30UL, 0xbf64e391UL,\n+    0x3e666320UL, 0xbfa3e609UL, 0x0de9dae3UL, 0x3f6301dfUL, 0x1f1dca06UL,\n+    0x3fafa8aeUL, 0x8c5b2da2UL, 0xbfb936bbUL, 0x4e88f7a5UL, 0xbc587d05UL,\n+    0x00000000UL, 0x3ff00000UL, 0xa8935dd9UL, 0x3f83dde2UL, 0x00000000UL,\n+    0x00000000UL, 0x00000000UL, 0x00000000UL, 0x6dc9c883UL, 0x3fe45f30UL,\n+    0x6dc9c883UL, 0x40245f30UL, 0x00000000UL, 0x43780000UL, 0x00000000UL,\n+    0x43380000UL, 0x54444000UL, 0x3fb921fbUL, 0x54440000UL, 0x3fb921fbUL,\n+    0x67674000UL, 0xbd32e7b9UL, 0x4c4c0000UL, 0x3d468c23UL, 0x3707344aUL,\n+    0x3aa8a2e0UL, 0x03707345UL, 0x3ae98a2eUL, 0x00000000UL, 0x80000000UL,\n+    0x00000000UL, 0x80000000UL, 0x676733afUL, 0x3d32e7b9UL, 0x00000000UL,\n+    0x00000000UL, 0x00000000UL, 0x3ff00000UL, 0x00000000UL, 0x00000000UL,\n+    0x00000000UL, 0x7ff00000UL, 0x00000000UL, 0x00000000UL, 0xfffc0000UL,\n+    0xffffffffUL, 0x00000000UL, 0x00000000UL, 0x00000000UL, 0x43600000UL,\n+    0x00000000UL, 0x00000000UL, 0x00000000UL, 0x3c800000UL, 0x00000000UL,\n+    0x00000000UL, 0x00000000UL, 0x3ca00000UL, 0x00000000UL, 0x00000000UL,\n+    0x00000000UL, 0x3fe00000UL, 0x00000000UL, 0x3fe00000UL, 0x00000000UL,\n+    0x40300000UL, 0x00000000UL, 0x3ff00000UL\n+};\n+\n+void MacroAssembler::fast_tan(XMMRegister xmm0, XMMRegister xmm1, XMMRegister xmm2, XMMRegister xmm3, XMMRegister xmm4, XMMRegister xmm5, XMMRegister xmm6, XMMRegister xmm7, Register eax, Register ecx, Register edx, Register tmp) {\n+\n+  Label L_2TAG_PACKET_0_0_2, L_2TAG_PACKET_1_0_2, L_2TAG_PACKET_2_0_2, L_2TAG_PACKET_3_0_2;\n+  Label L_2TAG_PACKET_4_0_2;\n+\n+  assert_different_registers(tmp, eax, ecx, edx);\n+\n+  address static_const_table_tan = (address)_static_const_table_tan;\n+\n+  subl(rsp, 120);\n+  movl(Address(rsp, 56), tmp);\n+  lea(tmp, ExternalAddress(static_const_table_tan));\n+  movsd(xmm0, Address(rsp, 128));\n+  pextrw(eax, xmm0, 3);\n+  andl(eax, 32767);\n+  subl(eax, 14368);\n+  cmpl(eax, 2216);\n+  jcc(Assembler::above, L_2TAG_PACKET_0_0_2);\n+  movdqu(xmm5, Address(tmp, 5840));\n+  movdqu(xmm6, Address(tmp, 5856));\n+  unpcklpd(xmm0, xmm0);\n+  movdqu(xmm4, Address(tmp, 5712));\n+  andpd(xmm4, xmm0);\n+  movdqu(xmm1, Address(tmp, 5632));\n+  mulpd(xmm1, xmm0);\n+  por(xmm5, xmm4);\n+  addpd(xmm1, xmm5);\n+  movdqu(xmm7, xmm1);\n+  unpckhpd(xmm7, xmm7);\n+  cvttsd2sil(edx, xmm7);\n+  cvttpd2dq(xmm1, xmm1);\n+  cvtdq2pd(xmm1, xmm1);\n+  mulpd(xmm1, xmm6);\n+  movdqu(xmm3, Address(tmp, 5664));\n+  movsd(xmm5, Address(tmp, 5728));\n+  addl(edx, 469248);\n+  movdqu(xmm4, Address(tmp, 5680));\n+  mulpd(xmm3, xmm1);\n+  andl(edx, 31);\n+  mulsd(xmm5, xmm1);\n+  movl(ecx, edx);\n+  mulpd(xmm4, xmm1);\n+  shll(ecx, 1);\n+  subpd(xmm0, xmm3);\n+  mulpd(xmm1, Address(tmp, 5696));\n+  addl(edx, ecx);\n+  shll(ecx, 2);\n+  addl(edx, ecx);\n+  addsd(xmm5, xmm0);\n+  movdqu(xmm2, xmm0);\n+  subpd(xmm0, xmm4);\n+  movsd(xmm6, Address(tmp, 5744));\n+  shll(edx, 4);\n+  lea(eax, Address(tmp, 0));\n+  andpd(xmm5, Address(tmp, 5776));\n+  movdqu(xmm3, xmm0);\n+  addl(eax, edx);\n+  subpd(xmm2, xmm0);\n+  unpckhpd(xmm0, xmm0);\n+  divsd(xmm6, xmm5);\n+  subpd(xmm2, xmm4);\n+  movdqu(xmm7, Address(eax, 16));\n+  subsd(xmm3, xmm5);\n+  mulpd(xmm7, xmm0);\n+  subpd(xmm2, xmm1);\n+  movdqu(xmm1, Address(eax, 48));\n+  mulpd(xmm1, xmm0);\n+  movdqu(xmm4, Address(eax, 96));\n+  mulpd(xmm4, xmm0);\n+  addsd(xmm2, xmm3);\n+  movdqu(xmm3, xmm0);\n+  mulpd(xmm0, xmm0);\n+  addpd(xmm7, Address(eax, 0));\n+  addpd(xmm1, Address(eax, 32));\n+  mulpd(xmm1, xmm0);\n+  addpd(xmm4, Address(eax, 80));\n+  addpd(xmm7, xmm1);\n+  movdqu(xmm1, Address(eax, 112));\n+  mulpd(xmm1, xmm0);\n+  mulpd(xmm0, xmm0);\n+  addpd(xmm4, xmm1);\n+  movdqu(xmm1, Address(eax, 64));\n+  mulpd(xmm1, xmm0);\n+  addpd(xmm7, xmm1);\n+  movdqu(xmm1, xmm3);\n+  mulpd(xmm3, xmm0);\n+  mulsd(xmm0, xmm0);\n+  mulpd(xmm1, Address(eax, 144));\n+  mulpd(xmm4, xmm3);\n+  movdqu(xmm3, xmm1);\n+  addpd(xmm7, xmm4);\n+  movdqu(xmm4, xmm1);\n+  mulsd(xmm0, xmm7);\n+  unpckhpd(xmm7, xmm7);\n+  addsd(xmm0, xmm7);\n+  unpckhpd(xmm1, xmm1);\n+  addsd(xmm3, xmm1);\n+  subsd(xmm4, xmm3);\n+  addsd(xmm1, xmm4);\n+  movdqu(xmm4, xmm2);\n+  movsd(xmm7, Address(eax, 144));\n+  unpckhpd(xmm2, xmm2);\n+  addsd(xmm7, Address(eax, 152));\n+  mulsd(xmm7, xmm2);\n+  addsd(xmm7, Address(eax, 136));\n+  addsd(xmm7, xmm1);\n+  addsd(xmm0, xmm7);\n+  movsd(xmm7, Address(tmp, 5744));\n+  mulsd(xmm4, xmm6);\n+  movsd(xmm2, Address(eax, 168));\n+  andpd(xmm2, xmm6);\n+  mulsd(xmm5, xmm2);\n+  mulsd(xmm6, Address(eax, 160));\n+  subsd(xmm7, xmm5);\n+  subsd(xmm2, Address(eax, 128));\n+  subsd(xmm7, xmm4);\n+  mulsd(xmm7, xmm6);\n+  movdqu(xmm4, xmm3);\n+  subsd(xmm3, xmm2);\n+  addsd(xmm2, xmm3);\n+  subsd(xmm4, xmm2);\n+  addsd(xmm0, xmm4);\n+  subsd(xmm0, xmm7);\n+  addsd(xmm0, xmm3);\n+  movsd(Address(rsp, 0), xmm0);\n+  fld_d(Address(rsp, 0));\n+  jmp(L_2TAG_PACKET_1_0_2);\n+\n+  bind(L_2TAG_PACKET_0_0_2);\n+  jcc(Assembler::greater, L_2TAG_PACKET_2_0_2);\n+  shrl(eax, 4);\n+  cmpl(eax, 268434558);\n+  jcc(Assembler::notEqual, L_2TAG_PACKET_3_0_2);\n+  movdqu(xmm3, xmm0);\n+  mulsd(xmm3, Address(tmp, 5808));\n+\n+  bind(L_2TAG_PACKET_3_0_2);\n+  movsd(xmm3, Address(tmp, 5792));\n+  mulsd(xmm3, xmm0);\n+  addsd(xmm3, xmm0);\n+  mulsd(xmm3, Address(tmp, 5808));\n+  movsd(Address(rsp, 0), xmm3);\n+  fld_d(Address(rsp, 0));\n+  jmp(L_2TAG_PACKET_1_0_2);\n+\n+  bind(L_2TAG_PACKET_2_0_2);\n+  movq(xmm7, Address(tmp, 5712));\n+  andpd(xmm7, xmm0);\n+  xorpd(xmm7, xmm0);\n+  ucomisd(xmm7, Address(tmp, 5760));\n+  jcc(Assembler::equal, L_2TAG_PACKET_4_0_2);\n+  subl(rsp, 32);\n+  movsd(Address(rsp, 0), xmm0);\n+  lea(eax, Address(rsp, 40));\n+  movl(Address(rsp, 8), eax);\n+  movl(eax, 2);\n+  movl(Address(rsp, 12), eax);\n+  call(RuntimeAddress(CAST_FROM_FN_PTR(address, StubRoutines::dlibm_tan_cot_huge())));\n+  addl(rsp, 32);\n+  fld_d(Address(rsp, 8));\n+  jmp(L_2TAG_PACKET_1_0_2);\n+\n+  bind(L_2TAG_PACKET_4_0_2);\n+  movq(Address(rsp, 0), xmm0);\n+  fld_d(Address(rsp, 0));\n+  fsub_d(Address(rsp, 0));\n+\n+  bind(L_2TAG_PACKET_1_0_2);\n+  movl(tmp, Address(rsp, 56));\n+}\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86_32_tan.cpp","additions":1173,"deletions":0,"binary":false,"changes":1173,"status":"added"},{"patch":"@@ -1,211 +0,0 @@\n-\/*\n-* Copyright (c) 2021, Intel Corporation. All rights reserved.\n-*\n-* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-*\n-* This code is free software; you can redistribute it and\/or modify it\n-* under the terms of the GNU General Public License version 2 only, as\n-* published by the Free Software Foundation.\n-*\n-* This code is distributed in the hope that it will be useful, but WITHOUT\n-* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-* FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-* version 2 for more details (a copy is included in the LICENSE file that\n-* accompanied this code).\n-*\n-* You should have received a copy of the GNU General Public License version\n-* 2 along with this work; if not, write to the Free Software Foundation,\n-* Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-*\n-* Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-* or visit www.oracle.com if you need additional information or have any\n-* questions.\n-*\n-*\/\n-\n-#include \"precompiled.hpp\"\n-#include \"asm\/assembler.hpp\"\n-#include \"asm\/assembler.inline.hpp\"\n-#include \"runtime\/stubRoutines.hpp\"\n-#include \"macroAssembler_x86.hpp\"\n-\n-#ifdef _LP64\n-void MacroAssembler::updateBytesAdler32(Register init_d, Register data, Register size, XMMRegister yshuf0, XMMRegister yshuf1, ExternalAddress ascaletab)\n-{\n-      const int LIMIT = 5552;\n-      const int BASE = 65521;\n-      const int CHUNKSIZE =  16;\n-      const int CHUNKSIZE_M1 = CHUNKSIZE - 1;\n-\n-      const Register s = r11;\n-      const Register a_d = r12; \/\/r12d\n-      const Register b_d = r8; \/\/r8d\n-      const Register end = r13;\n-\n-      const XMMRegister ya = xmm0;\n-      const XMMRegister yb = xmm1;\n-      const XMMRegister ydata0 = xmm2;\n-      const XMMRegister ydata1 = xmm3;\n-      const XMMRegister ysa = xmm4;\n-      const XMMRegister ydata = ysa;\n-      const XMMRegister ytmp0 = ydata0;\n-      const XMMRegister ytmp1 = ydata1;\n-      const XMMRegister ytmp2 = xmm5;\n-      const XMMRegister xa = xmm0;\n-      const XMMRegister xb = xmm1;\n-      const XMMRegister xtmp0 = xmm2;\n-      const XMMRegister xtmp1 = xmm3;\n-      const XMMRegister xsa = xmm4;\n-      const XMMRegister xtmp2 = xmm5;\n-      assert_different_registers(init_d, data, size, s, a_d, b_d, end, rax);\n-\n-      Label SLOOP1, SLOOP1A, SKIP_LOOP_1A, FINISH, LT64, DO_FINAL, FINAL_LOOP, ZERO_SIZE, END;\n-\n-      push(r12);\n-      push(r13);\n-      push(r14);\n-      movl(b_d, init_d); \/\/adler\n-      shrl(b_d, 16);\n-      andl(init_d, 0xFFFF);\n-      cmpl(size, 32);\n-      jcc(Assembler::below, LT64);\n-      movdl(xa, init_d); \/\/vmovd - 32bit\n-      vpxor(yb, yb, yb, Assembler::AVX_256bit);\n-\n-      bind(SLOOP1);\n-      movl(s, LIMIT);\n-      cmpl(s, size);\n-      cmovl(Assembler::above, s, size); \/\/ s = min(size, LIMIT)\n-      lea(end, Address(s, data, Address::times_1, -CHUNKSIZE_M1));\n-      cmpptr(data, end);\n-      jcc(Assembler::aboveEqual, SKIP_LOOP_1A);\n-\n-      align32();\n-      bind(SLOOP1A);\n-      vbroadcastf128(ydata, Address(data, 0), Assembler::AVX_256bit);\n-      addptr(data, CHUNKSIZE);\n-      vpshufb(ydata0, ydata, yshuf0, Assembler::AVX_256bit);\n-      vpaddd(ya, ya, ydata0, Assembler::AVX_256bit);\n-      vpaddd(yb, yb, ya, Assembler::AVX_256bit);\n-      vpshufb(ydata1, ydata, yshuf1, Assembler::AVX_256bit);\n-      vpaddd(ya, ya, ydata1, Assembler::AVX_256bit);\n-      vpaddd(yb, yb, ya, Assembler::AVX_256bit);\n-      cmpptr(data, end);\n-      jcc(Assembler::below, SLOOP1A);\n-\n-      bind(SKIP_LOOP_1A);\n-      addptr(end, CHUNKSIZE_M1);\n-      testl(s, CHUNKSIZE_M1);\n-      jcc(Assembler::notEqual, DO_FINAL);\n-\n-      \/\/ either we're done, or we just did LIMIT\n-      subl(size, s);\n-\n-      \/\/ reduce\n-      vpslld(yb, yb, 3, Assembler::AVX_256bit); \/\/b is scaled by 8\n-      vpmulld(ysa, ya, ascaletab, Assembler::AVX_256bit, r14);\n-\n-      \/\/ compute horizontal sums of ya, yb, ysa\n-      vextracti128(xtmp0, ya, 1);\n-      vextracti128(xtmp1, yb, 1);\n-      vextracti128(xtmp2, ysa, 1);\n-      vpaddd(xa, xa, xtmp0, Assembler::AVX_128bit);\n-      vpaddd(xb, xb, xtmp1, Assembler::AVX_128bit);\n-      vpaddd(xsa, xsa, xtmp2, Assembler::AVX_128bit);\n-      vphaddd(xa, xa, xa, Assembler::AVX_128bit);\n-      vphaddd(xb, xb, xb, Assembler::AVX_128bit);\n-      vphaddd(xsa, xsa, xsa, Assembler::AVX_128bit);\n-      vphaddd(xa, xa, xa, Assembler::AVX_128bit);\n-      vphaddd(xb, xb, xb, Assembler::AVX_128bit);\n-      vphaddd(xsa, xsa, xsa, Assembler::AVX_128bit);\n-\n-      movdl(rax, xa);\n-      xorl(rdx, rdx);\n-      movl(rcx, BASE);\n-      divl(rcx); \/\/ divide edx:eax by ecx, quot->eax, rem->edx\n-      movl(a_d, rdx);\n-\n-      vpsubd(xb, xb, xsa, Assembler::AVX_128bit);\n-      movdl(rax, xb);\n-      addl(rax, b_d);\n-      xorl(rdx, rdx);\n-      movl(rcx, BASE);\n-      divl(rcx); \/\/ divide edx:eax by ecx, quot->eax, rem->edx\n-      movl(b_d, rdx);\n-\n-      testl(size, size);\n-      jcc(Assembler::zero, FINISH);\n-\n-      \/\/ continue loop\n-      movdl(xa, a_d);\n-      vpxor(yb, yb, yb, Assembler::AVX_256bit);\n-      jmp(SLOOP1);\n-\n-      bind(FINISH);\n-      movl(rax, b_d);\n-      shll(rax, 16);\n-      orl(rax, a_d);\n-      jmp(END);\n-\n-      bind(LT64);\n-      movl(a_d, init_d);\n-      lea(end, Address(data, size, Address::times_1));\n-      testl(size, size);\n-      jcc(Assembler::notZero, FINAL_LOOP);\n-      jmp(ZERO_SIZE);\n-\n-      \/\/ handle remaining 1...15 bytes\n-      bind(DO_FINAL);\n-      \/\/ reduce\n-      vpslld(yb, yb, 3, Assembler::AVX_256bit); \/\/b is scaled by 8\n-      vpmulld(ysa, ya, ascaletab, Assembler::AVX_256bit, r14); \/\/scaled a\n-\n-      vextracti128(xtmp0, ya, 1);\n-      vextracti128(xtmp1, yb, 1);\n-      vextracti128(xtmp2, ysa, 1);\n-      vpaddd(xa, xa, xtmp0, Assembler::AVX_128bit);\n-      vpaddd(xb, xb, xtmp1, Assembler::AVX_128bit);\n-      vpaddd(xsa, xsa, xtmp2, Assembler::AVX_128bit);\n-      vphaddd(xa, xa, xa, Assembler::AVX_128bit);\n-      vphaddd(xb, xb, xb, Assembler::AVX_128bit);\n-      vphaddd(xsa, xsa, xsa, Assembler::AVX_128bit);\n-      vphaddd(xa, xa, xa, Assembler::AVX_128bit);\n-      vphaddd(xb, xb, xb, Assembler::AVX_128bit);\n-      vphaddd(xsa, xsa, xsa, Assembler::AVX_128bit);\n-      vpsubd(xb, xb, xsa, Assembler::AVX_128bit);\n-\n-      movdl(a_d, xa);\n-      movdl(rax, xb);\n-      addl(b_d, rax);\n-\n-      align32();\n-      bind(FINAL_LOOP);\n-      movzbl(rax, Address(data, 0)); \/\/movzx   eax, byte[data]\n-      addl(a_d, rax);\n-      addptr(data, 1);\n-      addl(b_d, a_d);\n-      cmpptr(data, end);\n-      jcc(Assembler::below, FINAL_LOOP);\n-\n-      bind(ZERO_SIZE);\n-\n-      movl(rax, a_d);\n-      xorl(rdx, rdx);\n-      movl(rcx, BASE);\n-      divl(rcx); \/\/ div ecx -- divide edx:eax by ecx, quot->eax, rem->edx\n-      movl(a_d, rdx);\n-\n-      movl(rax, b_d);\n-      xorl(rdx, rdx);\n-      movl(rcx, BASE);\n-      divl(rcx); \/\/ divide edx:eax by ecx, quot->eax, rem->edx\n-      shll(rdx, 16);\n-      orl(rdx, a_d);\n-      movl(rax, rdx);\n-\n-      bind(END);\n-      pop(r14);\n-      pop(r13);\n-      pop(r12);\n-  }\n-#endif\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86_adler.cpp","additions":0,"deletions":211,"binary":false,"changes":211,"status":"deleted"},{"patch":"@@ -1,251 +0,0 @@\n-\/*\n-* Copyright (c) 2020, 2022, Intel Corporation. All rights reserved.\n-*\n-* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-*\n-* This code is free software; you can redistribute it and\/or modify it\n-* under the terms of the GNU General Public License version 2 only, as\n-* published by the Free Software Foundation.\n-*\n-* This code is distributed in the hope that it will be useful, but WITHOUT\n-* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-* FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-* version 2 for more details (a copy is included in the LICENSE file that\n-* accompanied this code).\n-*\n-* You should have received a copy of the GNU General Public License version\n-* 2 along with this work; if not, write to the Free Software Foundation,\n-* Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-*\n-* Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-* or visit www.oracle.com if you need additional information or have any\n-* questions.\n-*\n-*\/\n-\n-#include \"precompiled.hpp\"\n-#include \"asm\/macroAssembler.hpp\"\n-#include \"asm\/macroAssembler.inline.hpp\"\n-#include \"compiler\/compiler_globals.hpp\"\n-\n-#ifdef PRODUCT\n-#define BLOCK_COMMENT(str) \/* nothing *\/\n-#else\n-#define BLOCK_COMMENT(str) block_comment(str)\n-#endif\n-\n-#define BIND(label) bind(label); BLOCK_COMMENT(#label \":\")\n-\n-#ifdef _LP64\n-\n-#if COMPILER2_OR_JVMCI\n-\n-void MacroAssembler::arraycopy_avx3_special_cases(XMMRegister xmm, KRegister mask, Register from,\n-                                                  Register to, Register count, int shift,\n-                                                  Register index, Register temp,\n-                                                  bool use64byteVector, Label& L_entry, Label& L_exit) {\n-  Label L_entry_64, L_entry_96, L_entry_128;\n-  Label L_entry_160, L_entry_192;\n-\n-  int size_mat[][6] = {\n-  \/* T_BYTE *\/ {32 , 64,  96 , 128 , 160 , 192 },\n-  \/* T_SHORT*\/ {16 , 32,  48 , 64  , 80  , 96  },\n-  \/* T_INT  *\/ {8  , 16,  24 , 32  , 40  , 48  },\n-  \/* T_LONG *\/ {4  ,  8,  12 , 16  , 20  , 24  }\n-  };\n-\n-  \/\/ Case A) Special case for length less than equal to 32 bytes.\n-  cmpq(count, size_mat[shift][0]);\n-  jccb(Assembler::greater, L_entry_64);\n-  copy32_masked_avx(to, from, xmm, mask, count, index, temp, shift);\n-  jmp(L_exit);\n-\n-  \/\/ Case B) Special case for length less than equal to 64 bytes.\n-  BIND(L_entry_64);\n-  cmpq(count, size_mat[shift][1]);\n-  jccb(Assembler::greater, L_entry_96);\n-  copy64_masked_avx(to, from, xmm, mask, count, index, temp, shift, 0, use64byteVector);\n-  jmp(L_exit);\n-\n-  \/\/ Case C) Special case for length less than equal to 96 bytes.\n-  BIND(L_entry_96);\n-  cmpq(count, size_mat[shift][2]);\n-  jccb(Assembler::greater, L_entry_128);\n-  copy64_avx(to, from, index, xmm, false, shift, 0, use64byteVector);\n-  subq(count, 64 >> shift);\n-  copy32_masked_avx(to, from, xmm, mask, count, index, temp, shift, 64);\n-  jmp(L_exit);\n-\n-  \/\/ Case D) Special case for length less than equal to 128 bytes.\n-  BIND(L_entry_128);\n-  cmpq(count, size_mat[shift][3]);\n-  jccb(Assembler::greater, L_entry_160);\n-  copy64_avx(to, from, index, xmm, false, shift, 0, use64byteVector);\n-  copy32_avx(to, from, index, xmm, shift, 64);\n-  subq(count, 96 >> shift);\n-  copy32_masked_avx(to, from, xmm, mask, count, index, temp, shift, 96);\n-  jmp(L_exit);\n-\n-  \/\/ Case E) Special case for length less than equal to 160 bytes.\n-  BIND(L_entry_160);\n-  cmpq(count, size_mat[shift][4]);\n-  jccb(Assembler::greater, L_entry_192);\n-  copy64_avx(to, from, index, xmm, false, shift, 0, use64byteVector);\n-  copy64_avx(to, from, index, xmm, false, shift, 64, use64byteVector);\n-  subq(count, 128 >> shift);\n-  copy32_masked_avx(to, from, xmm, mask, count, index, temp, shift, 128);\n-  jmp(L_exit);\n-\n-  \/\/ Case F) Special case for length less than equal to 192 bytes.\n-  BIND(L_entry_192);\n-  cmpq(count, size_mat[shift][5]);\n-  jcc(Assembler::greater, L_entry);\n-  copy64_avx(to, from, index, xmm, false, shift, 0, use64byteVector);\n-  copy64_avx(to, from, index, xmm, false, shift, 64, use64byteVector);\n-  copy32_avx(to, from, index, xmm, shift, 128);\n-  subq(count, 160 >> shift);\n-  copy32_masked_avx(to, from, xmm, mask, count, index, temp, shift, 160);\n-  jmp(L_exit);\n-}\n-\n-void MacroAssembler::arraycopy_avx3_special_cases_conjoint(XMMRegister xmm, KRegister mask, Register from,\n-                                                           Register to, Register start_index, Register end_index,\n-                                                           Register count, int shift, Register temp,\n-                                                           bool use64byteVector, Label& L_entry, Label& L_exit) {\n-  Label L_entry_64, L_entry_96, L_entry_128;\n-  Label L_entry_160, L_entry_192;\n-  bool avx3 = (MaxVectorSize > 32) && (VM_Version::avx3_threshold() == 0);\n-\n-  int size_mat[][6] = {\n-  \/* T_BYTE *\/ {32 , 64,  96 , 128 , 160 , 192 },\n-  \/* T_SHORT*\/ {16 , 32,  48 , 64  , 80  , 96  },\n-  \/* T_INT  *\/ {8  , 16,  24 , 32  , 40  , 48  },\n-  \/* T_LONG *\/ {4  ,  8,  12 , 16  , 20  , 24  }\n-  };\n-\n-  \/\/ Case A) Special case for length less than equal to 32 bytes.\n-  cmpq(count, size_mat[shift][0]);\n-  jccb(Assembler::greater, L_entry_64);\n-  copy32_masked_avx(to, from, xmm, mask, count, start_index, temp, shift);\n-  jmp(L_exit);\n-\n-  \/\/ Case B) Special case for length less than equal to 64 bytes.\n-  BIND(L_entry_64);\n-  cmpq(count, size_mat[shift][1]);\n-  jccb(Assembler::greater, L_entry_96);\n-  if (avx3) {\n-     copy64_masked_avx(to, from, xmm, mask, count, start_index, temp, shift, 0, true);\n-  } else {\n-     copy32_avx(to, from, end_index, xmm, shift, -32);\n-     subq(count, 32 >> shift);\n-     copy32_masked_avx(to, from, xmm, mask, count, start_index, temp, shift);\n-  }\n-  jmp(L_exit);\n-\n-  \/\/ Case C) Special case for length less than equal to 96 bytes.\n-  BIND(L_entry_96);\n-  cmpq(count, size_mat[shift][2]);\n-  jccb(Assembler::greater, L_entry_128);\n-  copy64_avx(to, from, end_index, xmm, true, shift, -64, use64byteVector);\n-  subq(count, 64 >> shift);\n-  copy32_masked_avx(to, from, xmm, mask, count, start_index, temp, shift);\n-  jmp(L_exit);\n-\n-  \/\/ Case D) Special case for length less than equal to 128 bytes.\n-  BIND(L_entry_128);\n-  cmpq(count, size_mat[shift][3]);\n-  jccb(Assembler::greater, L_entry_160);\n-  copy64_avx(to, from, end_index, xmm, true, shift, -64, use64byteVector);\n-  copy32_avx(to, from, end_index, xmm, shift, -96);\n-  subq(count, 96 >> shift);\n-  copy32_masked_avx(to, from, xmm, mask, count, start_index, temp, shift);\n-  jmp(L_exit);\n-\n-  \/\/ Case E) Special case for length less than equal to 160 bytes.\n-  BIND(L_entry_160);\n-  cmpq(count, size_mat[shift][4]);\n-  jccb(Assembler::greater, L_entry_192);\n-  copy64_avx(to, from, end_index, xmm, true, shift, -64, use64byteVector);\n-  copy64_avx(to, from, end_index, xmm, true, shift, -128, use64byteVector);\n-  subq(count, 128 >> shift);\n-  copy32_masked_avx(to, from, xmm, mask, count, start_index, temp, shift);\n-  jmp(L_exit);\n-\n-  \/\/ Case F) Special case for length less than equal to 192 bytes.\n-  BIND(L_entry_192);\n-  cmpq(count, size_mat[shift][5]);\n-  jcc(Assembler::greater, L_entry);\n-  copy64_avx(to, from, end_index, xmm, true, shift, -64, use64byteVector);\n-  copy64_avx(to, from, end_index, xmm, true, shift, -128, use64byteVector);\n-  copy32_avx(to, from, end_index, xmm, shift, -160);\n-  subq(count, 160 >> shift);\n-  copy32_masked_avx(to, from, xmm, mask, count, start_index, temp, shift);\n-  jmp(L_exit);\n-}\n-\n-void MacroAssembler::copy64_masked_avx(Register dst, Register src, XMMRegister xmm,\n-                                       KRegister mask, Register length, Register index,\n-                                       Register temp, int shift, int offset,\n-                                       bool use64byteVector) {\n-  BasicType type[] = { T_BYTE,  T_SHORT,  T_INT,   T_LONG};\n-  assert(MaxVectorSize >= 32, \"vector length should be >= 32\");\n-  if (!use64byteVector) {\n-    copy32_avx(dst, src, index, xmm, shift, offset);\n-    subptr(length, 32 >> shift);\n-    copy32_masked_avx(dst, src, xmm, mask, length, index, temp, shift, offset+32);\n-  } else {\n-    Address::ScaleFactor scale = (Address::ScaleFactor)(shift);\n-    assert(MaxVectorSize == 64, \"vector length != 64\");\n-    mov64(temp, -1L);\n-    bzhiq(temp, temp, length);\n-    kmovql(mask, temp);\n-    evmovdqu(type[shift], mask, xmm, Address(src, index, scale, offset), false, Assembler::AVX_512bit);\n-    evmovdqu(type[shift], mask, Address(dst, index, scale, offset), xmm, true, Assembler::AVX_512bit);\n-  }\n-}\n-\n-\n-void MacroAssembler::copy32_masked_avx(Register dst, Register src, XMMRegister xmm,\n-                                       KRegister mask, Register length, Register index,\n-                                       Register temp, int shift, int offset) {\n-  assert(MaxVectorSize >= 32, \"vector length should be >= 32\");\n-  BasicType type[] = { T_BYTE,  T_SHORT,  T_INT,   T_LONG};\n-  Address::ScaleFactor scale = (Address::ScaleFactor)(shift);\n-  mov64(temp, -1L);\n-  bzhiq(temp, temp, length);\n-  kmovql(mask, temp);\n-  evmovdqu(type[shift], mask, xmm, Address(src, index, scale, offset), false, Assembler::AVX_256bit);\n-  evmovdqu(type[shift], mask, Address(dst, index, scale, offset), xmm, true, Assembler::AVX_256bit);\n-}\n-\n-\n-void MacroAssembler::copy32_avx(Register dst, Register src, Register index, XMMRegister xmm,\n-                                int shift, int offset) {\n-  assert(MaxVectorSize >= 32, \"vector length should be >= 32\");\n-  Address::ScaleFactor scale = (Address::ScaleFactor)(shift);\n-  vmovdqu(xmm, Address(src, index, scale, offset));\n-  vmovdqu(Address(dst, index, scale, offset), xmm);\n-}\n-\n-\n-void MacroAssembler::copy64_avx(Register dst, Register src, Register index, XMMRegister xmm,\n-                                bool conjoint, int shift, int offset, bool use64byteVector) {\n-  assert(MaxVectorSize == 64 || MaxVectorSize == 32, \"vector length mismatch\");\n-  if (!use64byteVector) {\n-    if (conjoint) {\n-      copy32_avx(dst, src, index, xmm, shift, offset+32);\n-      copy32_avx(dst, src, index, xmm, shift, offset);\n-    } else {\n-      copy32_avx(dst, src, index, xmm, shift, offset);\n-      copy32_avx(dst, src, index, xmm, shift, offset+32);\n-    }\n-  } else {\n-    Address::ScaleFactor scale = (Address::ScaleFactor)(shift);\n-    evmovdquq(xmm, Address(src, index, scale, offset), Assembler::AVX_512bit);\n-    evmovdquq(Address(dst, index, scale, offset), xmm, Assembler::AVX_512bit);\n-  }\n-}\n-\n-#endif \/\/ COMPILER2_OR_JVMCI\n-\n-#endif\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86_arrayCopy_avx3.cpp","additions":0,"deletions":251,"binary":false,"changes":251,"status":"deleted"},{"patch":"@@ -1,267 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"precompiled.hpp\"\n-\n-#include \"macroAssembler_x86.hpp\"\n-\n-#ifdef _LP64\n-\n-ATTRIBUTE_ALIGNED(8) juint _ONE[] = {\n-    0x00000000UL, 0x3ff00000UL\n-};\n-address MacroAssembler::ONE = (address)_ONE;\n-\n-ATTRIBUTE_ALIGNED(16) juint _ONEHALF[] = {\n-    0x00000000UL, 0x3fe00000UL, 0x00000000UL, 0x3fe00000UL\n-};\n-address MacroAssembler::ONEHALF = (address)_ONEHALF;\n-\n-ATTRIBUTE_ALIGNED(8) juint _SIGN_MASK[] = {\n-    0x00000000UL, 0x80000000UL\n-};\n-address MacroAssembler::SIGN_MASK = (address)_SIGN_MASK;\n-\n-ATTRIBUTE_ALIGNED(8) juint _TWO_POW_55[] = {\n-    0x00000000UL, 0x43600000UL\n-};\n-address MacroAssembler::TWO_POW_55 = (address)_TWO_POW_55;\n-\n-ATTRIBUTE_ALIGNED(8) juint _TWO_POW_M55[] = {\n-    0x00000000UL, 0x3c800000UL\n-};\n-address MacroAssembler::TWO_POW_M55 = (address)_TWO_POW_M55;\n-\n-ATTRIBUTE_ALIGNED(16) juint _SHIFTER[] = {\n-    0x00000000UL, 0x43380000UL, 0x00000000UL, 0x43380000UL\n-};\n-address MacroAssembler::SHIFTER = (address)_SHIFTER;\n-\n-ATTRIBUTE_ALIGNED(4) juint _ZERO[] = {\n-    0x00000000UL, 0x00000000UL\n-};\n-address MacroAssembler::ZERO = (address)_ZERO;\n-\n-ATTRIBUTE_ALIGNED(16) juint _SC_1[] = {\n-    0x55555555UL, 0xbfc55555UL, 0x00000000UL, 0xbfe00000UL\n-};\n-address MacroAssembler::SC_1 = (address)_SC_1;\n-\n-ATTRIBUTE_ALIGNED(16) juint _SC_2[] = {\n-    0x11111111UL, 0x3f811111UL, 0x55555555UL, 0x3fa55555UL\n-};\n-address MacroAssembler::SC_2 = (address)_SC_2;\n-\n-ATTRIBUTE_ALIGNED(16) juint _SC_3[] = {\n-    0x1a01a01aUL, 0xbf2a01a0UL, 0x16c16c17UL, 0xbf56c16cUL\n-};\n-address MacroAssembler::SC_3 = (address)_SC_3;\n-\n-ATTRIBUTE_ALIGNED(16) juint _SC_4[] = {\n-    0xa556c734UL, 0x3ec71de3UL, 0x1a01a01aUL, 0x3efa01a0UL\n-};\n-address MacroAssembler::SC_4 = (address)_SC_4;\n-\n-ATTRIBUTE_ALIGNED(8) juint _PI_4[] = {\n-    0x40000000UL, 0x3fe921fbUL, 0x18469899UL, 0x3e64442dUL\n-};\n-address MacroAssembler::PI_4 = (address)_PI_4;\n-\n-ATTRIBUTE_ALIGNED(8) juint _PI32INV[] = {\n-    0x6dc9c883UL, 0x40245f30UL\n-};\n-address MacroAssembler::PI32INV = (address)_PI32INV;\n-\n-ATTRIBUTE_ALIGNED(8) juint _NEG_ZERO[] = {\n-    0x00000000UL, 0x80000000UL\n-};\n-address MacroAssembler::NEG_ZERO = (address)_NEG_ZERO;\n-\n-ATTRIBUTE_ALIGNED(8) juint _P_1[] = {\n-    0x54400000UL, 0x3fb921fbUL\n-};\n-address MacroAssembler::P_1 = (address)_P_1;\n-\n-ATTRIBUTE_ALIGNED(16) juint _P_2[] = {\n-    0x1a600000UL, 0x3d90b461UL, 0x1a600000UL, 0x3d90b461UL\n-};\n-address MacroAssembler::P_2 = (address)_P_2;\n-\n-ATTRIBUTE_ALIGNED(8) juint _P_3[] = {\n-    0x2e037073UL, 0x3b63198aUL\n-};\n-address MacroAssembler::P_3 = (address)_P_3;\n-\n-\n-ATTRIBUTE_ALIGNED(16) juint _PI_INV_TABLE[] = {\n-    0x00000000UL, 0x00000000UL, 0xa2f9836eUL, 0x4e441529UL, 0xfc2757d1UL,\n-    0xf534ddc0UL, 0xdb629599UL, 0x3c439041UL, 0xfe5163abUL, 0xdebbc561UL,\n-    0xb7246e3aUL, 0x424dd2e0UL, 0x06492eeaUL, 0x09d1921cUL, 0xfe1deb1cUL,\n-    0xb129a73eUL, 0xe88235f5UL, 0x2ebb4484UL, 0xe99c7026UL, 0xb45f7e41UL,\n-    0x3991d639UL, 0x835339f4UL, 0x9c845f8bUL, 0xbdf9283bUL, 0x1ff897ffUL,\n-    0xde05980fUL, 0xef2f118bUL, 0x5a0a6d1fUL, 0x6d367ecfUL, 0x27cb09b7UL,\n-    0x4f463f66UL, 0x9e5fea2dUL, 0x7527bac7UL, 0xebe5f17bUL, 0x3d0739f7UL,\n-    0x8a5292eaUL, 0x6bfb5fb1UL, 0x1f8d5d08UL, 0x56033046UL, 0xfc7b6babUL,\n-    0xf0cfbc21UL\n-};\n-address MacroAssembler::PI_INV_TABLE = (address)_PI_INV_TABLE;\n-\n-\n-ATTRIBUTE_ALIGNED(16) juint _Ctable[] = {\n-    0x00000000UL, 0x00000000UL, 0x00000000UL, 0x00000000UL, 0x00000000UL,\n-    0x00000000UL, 0x00000000UL, 0x3ff00000UL, 0x176d6d31UL, 0xbf73b92eUL,\n-    0xbc29b42cUL, 0x3fb917a6UL, 0xe0000000UL, 0xbc3e2718UL, 0x00000000UL,\n-    0x3ff00000UL, 0x011469fbUL, 0xbf93ad06UL, 0x3c69a60bUL, 0x3fc8f8b8UL,\n-    0xc0000000UL, 0xbc626d19UL, 0x00000000UL, 0x3ff00000UL, 0x939d225aUL,\n-    0xbfa60beaUL, 0x2ed59f06UL, 0x3fd29406UL, 0xa0000000UL, 0xbc75d28dUL,\n-    0x00000000UL, 0x3ff00000UL, 0x866b95cfUL, 0xbfb37ca1UL, 0xa6aea963UL,\n-    0x3fd87de2UL, 0xe0000000UL, 0xbc672cedUL, 0x00000000UL, 0x3ff00000UL,\n-    0x73fa1279UL, 0xbfbe3a68UL, 0x3806f63bUL, 0x3fde2b5dUL, 0x20000000UL,\n-    0x3c5e0d89UL, 0x00000000UL, 0x3ff00000UL, 0x5bc57974UL, 0xbfc59267UL,\n-    0x39ae68c8UL, 0x3fe1c73bUL, 0x20000000UL, 0x3c8b25ddUL, 0x00000000UL,\n-    0x3ff00000UL, 0x53aba2fdUL, 0xbfcd0dfeUL, 0x25091dd6UL, 0x3fe44cf3UL,\n-    0x20000000UL, 0x3c68076aUL, 0x00000000UL, 0x3ff00000UL, 0x99fcef32UL,\n-    0x3fca8279UL, 0x667f3bcdUL, 0x3fe6a09eUL, 0x20000000UL, 0xbc8bdd34UL,\n-    0x00000000UL, 0x3fe00000UL, 0x94247758UL, 0x3fc133ccUL, 0x6b151741UL,\n-    0x3fe8bc80UL, 0x20000000UL, 0xbc82c5e1UL, 0x00000000UL, 0x3fe00000UL,\n-    0x9ae68c87UL, 0x3fac73b3UL, 0x290ea1a3UL, 0x3fea9b66UL, 0xe0000000UL,\n-    0x3c39f630UL, 0x00000000UL, 0x3fe00000UL, 0x7f909c4eUL, 0xbf9d4a2cUL,\n-    0xf180bdb1UL, 0x3fec38b2UL, 0x80000000UL, 0xbc76e0b1UL, 0x00000000UL,\n-    0x3fe00000UL, 0x65455a75UL, 0xbfbe0875UL, 0xcf328d46UL, 0x3fed906bUL,\n-    0x20000000UL, 0x3c7457e6UL, 0x00000000UL, 0x3fe00000UL, 0x76acf82dUL,\n-    0x3fa4a031UL, 0x56c62ddaUL, 0x3fee9f41UL, 0xe0000000UL, 0x3c8760b1UL,\n-    0x00000000UL, 0x3fd00000UL, 0x0e5967d5UL, 0xbfac1d1fUL, 0xcff75cb0UL,\n-    0x3fef6297UL, 0x20000000UL, 0x3c756217UL, 0x00000000UL, 0x3fd00000UL,\n-    0x0f592f50UL, 0xbf9ba165UL, 0xa3d12526UL, 0x3fefd88dUL, 0x40000000UL,\n-    0xbc887df6UL, 0x00000000UL, 0x3fc00000UL, 0x00000000UL, 0x00000000UL,\n-    0x00000000UL, 0x3ff00000UL, 0x00000000UL, 0x00000000UL, 0x00000000UL,\n-    0x00000000UL, 0x0f592f50UL, 0x3f9ba165UL, 0xa3d12526UL, 0x3fefd88dUL,\n-    0x40000000UL, 0xbc887df6UL, 0x00000000UL, 0xbfc00000UL, 0x0e5967d5UL,\n-    0x3fac1d1fUL, 0xcff75cb0UL, 0x3fef6297UL, 0x20000000UL, 0x3c756217UL,\n-    0x00000000UL, 0xbfd00000UL, 0x76acf82dUL, 0xbfa4a031UL, 0x56c62ddaUL,\n-    0x3fee9f41UL, 0xe0000000UL, 0x3c8760b1UL, 0x00000000UL, 0xbfd00000UL,\n-    0x65455a75UL, 0x3fbe0875UL, 0xcf328d46UL, 0x3fed906bUL, 0x20000000UL,\n-    0x3c7457e6UL, 0x00000000UL, 0xbfe00000UL, 0x7f909c4eUL, 0x3f9d4a2cUL,\n-    0xf180bdb1UL, 0x3fec38b2UL, 0x80000000UL, 0xbc76e0b1UL, 0x00000000UL,\n-    0xbfe00000UL, 0x9ae68c87UL, 0xbfac73b3UL, 0x290ea1a3UL, 0x3fea9b66UL,\n-    0xe0000000UL, 0x3c39f630UL, 0x00000000UL, 0xbfe00000UL, 0x94247758UL,\n-    0xbfc133ccUL, 0x6b151741UL, 0x3fe8bc80UL, 0x20000000UL, 0xbc82c5e1UL,\n-    0x00000000UL, 0xbfe00000UL, 0x99fcef32UL, 0xbfca8279UL, 0x667f3bcdUL,\n-    0x3fe6a09eUL, 0x20000000UL, 0xbc8bdd34UL, 0x00000000UL, 0xbfe00000UL,\n-    0x53aba2fdUL, 0x3fcd0dfeUL, 0x25091dd6UL, 0x3fe44cf3UL, 0x20000000UL,\n-    0x3c68076aUL, 0x00000000UL, 0xbff00000UL, 0x5bc57974UL, 0x3fc59267UL,\n-    0x39ae68c8UL, 0x3fe1c73bUL, 0x20000000UL, 0x3c8b25ddUL, 0x00000000UL,\n-    0xbff00000UL, 0x73fa1279UL, 0x3fbe3a68UL, 0x3806f63bUL, 0x3fde2b5dUL,\n-    0x20000000UL, 0x3c5e0d89UL, 0x00000000UL, 0xbff00000UL, 0x866b95cfUL,\n-    0x3fb37ca1UL, 0xa6aea963UL, 0x3fd87de2UL, 0xe0000000UL, 0xbc672cedUL,\n-    0x00000000UL, 0xbff00000UL, 0x939d225aUL, 0x3fa60beaUL, 0x2ed59f06UL,\n-    0x3fd29406UL, 0xa0000000UL, 0xbc75d28dUL, 0x00000000UL, 0xbff00000UL,\n-    0x011469fbUL, 0x3f93ad06UL, 0x3c69a60bUL, 0x3fc8f8b8UL, 0xc0000000UL,\n-    0xbc626d19UL, 0x00000000UL, 0xbff00000UL, 0x176d6d31UL, 0x3f73b92eUL,\n-    0xbc29b42cUL, 0x3fb917a6UL, 0xe0000000UL, 0xbc3e2718UL, 0x00000000UL,\n-    0xbff00000UL, 0x00000000UL, 0x00000000UL, 0x00000000UL, 0x00000000UL,\n-    0x00000000UL, 0x00000000UL, 0x00000000UL, 0xbff00000UL, 0x176d6d31UL,\n-    0x3f73b92eUL, 0xbc29b42cUL, 0xbfb917a6UL, 0xe0000000UL, 0x3c3e2718UL,\n-    0x00000000UL, 0xbff00000UL, 0x011469fbUL, 0x3f93ad06UL, 0x3c69a60bUL,\n-    0xbfc8f8b8UL, 0xc0000000UL, 0x3c626d19UL, 0x00000000UL, 0xbff00000UL,\n-    0x939d225aUL, 0x3fa60beaUL, 0x2ed59f06UL, 0xbfd29406UL, 0xa0000000UL,\n-    0x3c75d28dUL, 0x00000000UL, 0xbff00000UL, 0x866b95cfUL, 0x3fb37ca1UL,\n-    0xa6aea963UL, 0xbfd87de2UL, 0xe0000000UL, 0x3c672cedUL, 0x00000000UL,\n-    0xbff00000UL, 0x73fa1279UL, 0x3fbe3a68UL, 0x3806f63bUL, 0xbfde2b5dUL,\n-    0x20000000UL, 0xbc5e0d89UL, 0x00000000UL, 0xbff00000UL, 0x5bc57974UL,\n-    0x3fc59267UL, 0x39ae68c8UL, 0xbfe1c73bUL, 0x20000000UL, 0xbc8b25ddUL,\n-    0x00000000UL, 0xbff00000UL, 0x53aba2fdUL, 0x3fcd0dfeUL, 0x25091dd6UL,\n-    0xbfe44cf3UL, 0x20000000UL, 0xbc68076aUL, 0x00000000UL, 0xbff00000UL,\n-    0x99fcef32UL, 0xbfca8279UL, 0x667f3bcdUL, 0xbfe6a09eUL, 0x20000000UL,\n-    0x3c8bdd34UL, 0x00000000UL, 0xbfe00000UL, 0x94247758UL, 0xbfc133ccUL,\n-    0x6b151741UL, 0xbfe8bc80UL, 0x20000000UL, 0x3c82c5e1UL, 0x00000000UL,\n-    0xbfe00000UL, 0x9ae68c87UL, 0xbfac73b3UL, 0x290ea1a3UL, 0xbfea9b66UL,\n-    0xe0000000UL, 0xbc39f630UL, 0x00000000UL, 0xbfe00000UL, 0x7f909c4eUL,\n-    0x3f9d4a2cUL, 0xf180bdb1UL, 0xbfec38b2UL, 0x80000000UL, 0x3c76e0b1UL,\n-    0x00000000UL, 0xbfe00000UL, 0x65455a75UL, 0x3fbe0875UL, 0xcf328d46UL,\n-    0xbfed906bUL, 0x20000000UL, 0xbc7457e6UL, 0x00000000UL, 0xbfe00000UL,\n-    0x76acf82dUL, 0xbfa4a031UL, 0x56c62ddaUL, 0xbfee9f41UL, 0xe0000000UL,\n-    0xbc8760b1UL, 0x00000000UL, 0xbfd00000UL, 0x0e5967d5UL, 0x3fac1d1fUL,\n-    0xcff75cb0UL, 0xbfef6297UL, 0x20000000UL, 0xbc756217UL, 0x00000000UL,\n-    0xbfd00000UL, 0x0f592f50UL, 0x3f9ba165UL, 0xa3d12526UL, 0xbfefd88dUL,\n-    0x40000000UL, 0x3c887df6UL, 0x00000000UL, 0xbfc00000UL, 0x00000000UL,\n-    0x00000000UL, 0x00000000UL, 0xbff00000UL, 0x00000000UL, 0x00000000UL,\n-    0x00000000UL, 0x00000000UL, 0x0f592f50UL, 0xbf9ba165UL, 0xa3d12526UL,\n-    0xbfefd88dUL, 0x40000000UL, 0x3c887df6UL, 0x00000000UL, 0x3fc00000UL,\n-    0x0e5967d5UL, 0xbfac1d1fUL, 0xcff75cb0UL, 0xbfef6297UL, 0x20000000UL,\n-    0xbc756217UL, 0x00000000UL, 0x3fd00000UL, 0x76acf82dUL, 0x3fa4a031UL,\n-    0x56c62ddaUL, 0xbfee9f41UL, 0xe0000000UL, 0xbc8760b1UL, 0x00000000UL,\n-    0x3fd00000UL, 0x65455a75UL, 0xbfbe0875UL, 0xcf328d46UL, 0xbfed906bUL,\n-    0x20000000UL, 0xbc7457e6UL, 0x00000000UL, 0x3fe00000UL, 0x7f909c4eUL,\n-    0xbf9d4a2cUL, 0xf180bdb1UL, 0xbfec38b2UL, 0x80000000UL, 0x3c76e0b1UL,\n-    0x00000000UL, 0x3fe00000UL, 0x9ae68c87UL, 0x3fac73b3UL, 0x290ea1a3UL,\n-    0xbfea9b66UL, 0xe0000000UL, 0xbc39f630UL, 0x00000000UL, 0x3fe00000UL,\n-    0x94247758UL, 0x3fc133ccUL, 0x6b151741UL, 0xbfe8bc80UL, 0x20000000UL,\n-    0x3c82c5e1UL, 0x00000000UL, 0x3fe00000UL, 0x99fcef32UL, 0x3fca8279UL,\n-    0x667f3bcdUL, 0xbfe6a09eUL, 0x20000000UL, 0x3c8bdd34UL, 0x00000000UL,\n-    0x3fe00000UL, 0x53aba2fdUL, 0xbfcd0dfeUL, 0x25091dd6UL, 0xbfe44cf3UL,\n-    0x20000000UL, 0xbc68076aUL, 0x00000000UL, 0x3ff00000UL, 0x5bc57974UL,\n-    0xbfc59267UL, 0x39ae68c8UL, 0xbfe1c73bUL, 0x20000000UL, 0xbc8b25ddUL,\n-    0x00000000UL, 0x3ff00000UL, 0x73fa1279UL, 0xbfbe3a68UL, 0x3806f63bUL,\n-    0xbfde2b5dUL, 0x20000000UL, 0xbc5e0d89UL, 0x00000000UL, 0x3ff00000UL,\n-    0x866b95cfUL, 0xbfb37ca1UL, 0xa6aea963UL, 0xbfd87de2UL, 0xe0000000UL,\n-    0x3c672cedUL, 0x00000000UL, 0x3ff00000UL, 0x939d225aUL, 0xbfa60beaUL,\n-    0x2ed59f06UL, 0xbfd29406UL, 0xa0000000UL, 0x3c75d28dUL, 0x00000000UL,\n-    0x3ff00000UL, 0x011469fbUL, 0xbf93ad06UL, 0x3c69a60bUL, 0xbfc8f8b8UL,\n-    0xc0000000UL, 0x3c626d19UL, 0x00000000UL, 0x3ff00000UL, 0x176d6d31UL,\n-    0xbf73b92eUL, 0xbc29b42cUL, 0xbfb917a6UL, 0xe0000000UL, 0x3c3e2718UL,\n-    0x00000000UL, 0x3ff00000UL\n-};\n-address MacroAssembler::Ctable = (address)_Ctable;\n-\n-#else \/\/ !_LP64\n-\n-ATTRIBUTE_ALIGNED(16) juint _ONES[] = {\n-    0x00000000UL, 0x3ff00000UL, 0x00000000UL, 0xbff00000UL\n-};\n-address MacroAssembler::ONES = (address)_ONES;\n-\n-ATTRIBUTE_ALIGNED(16) juint _PI4_INV[] = {\n-    0x6dc9c883UL, 0x3ff45f30UL\n-};\n-address MacroAssembler::PI4_INV = (address)_PI4_INV;\n-\n-ATTRIBUTE_ALIGNED(16) juint _PI4X3[] = {\n-    0x54443000UL, 0xbfe921fbUL, 0x3b39a000UL, 0x3d373dcbUL, 0xe0e68948UL,\n-    0xba845c06UL\n-};\n-address MacroAssembler::PI4X3 = (address)_PI4X3;\n-\n-ATTRIBUTE_ALIGNED(16) juint _PI4X4[] = {\n-    0x54400000UL, 0xbfe921fbUL, 0x1a600000UL, 0xbdc0b461UL, 0x2e000000UL,\n-    0xbb93198aUL, 0x252049c1UL, 0xb96b839aUL\n-};\n-address MacroAssembler::PI4X4 = (address)_PI4X4;\n-\n-ATTRIBUTE_ALIGNED(16) juint _L_2IL0FLOATPACKET_0[] = {\n-    0xffffffffUL, 0x7fffffffUL, 0x00000000UL, 0x00000000UL\n-};\n-address MacroAssembler::L_2IL0FLOATPACKET_0 = (address)_L_2IL0FLOATPACKET_0;\n-\n-#endif \/\/ _LP64\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86_constants.cpp","additions":0,"deletions":267,"binary":false,"changes":267,"status":"deleted"},{"patch":"@@ -1,866 +0,0 @@\n-\/*\n-* Copyright (c) 2016, 2021, Intel Corporation. All rights reserved.\n-* Intel Math Library (LIBM) Source Code\n-*\n-* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-*\n-* This code is free software; you can redistribute it and\/or modify it\n-* under the terms of the GNU General Public License version 2 only, as\n-* published by the Free Software Foundation.\n-*\n-* This code is distributed in the hope that it will be useful, but WITHOUT\n-* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-* FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-* version 2 for more details (a copy is included in the LICENSE file that\n-* accompanied this code).\n-*\n-* You should have received a copy of the GNU General Public License version\n-* 2 along with this work; if not, write to the Free Software Foundation,\n-* Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-*\n-* Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-* or visit www.oracle.com if you need additional information or have any\n-* questions.\n-*\n-*\/\n-\n-#include \"precompiled.hpp\"\n-#include \"asm\/assembler.hpp\"\n-#include \"asm\/assembler.inline.hpp\"\n-#include \"macroAssembler_x86.hpp\"\n-#include \"runtime\/stubRoutines.hpp\"\n-#include \"utilities\/globalDefinitions.hpp\"\n-\n-\/******************************************************************************\/\n-\/\/                     ALGORITHM DESCRIPTION - COS()\n-\/\/                     ---------------------\n-\/\/\n-\/\/     1. RANGE REDUCTION\n-\/\/\n-\/\/     We perform an initial range reduction from X to r with\n-\/\/\n-\/\/          X =~= N * pi\/32 + r\n-\/\/\n-\/\/     so that |r| <= pi\/64 + epsilon. We restrict inputs to those\n-\/\/     where |N| <= 932560. Beyond this, the range reduction is\n-\/\/     insufficiently accurate. For extremely small inputs,\n-\/\/     denormalization can occur internally, impacting performance.\n-\/\/     This means that the main path is actually only taken for\n-\/\/     2^-252 <= |X| < 90112.\n-\/\/\n-\/\/     To avoid branches, we perform the range reduction to full\n-\/\/     accuracy each time.\n-\/\/\n-\/\/          X - N * (P_1 + P_2 + P_3)\n-\/\/\n-\/\/     where P_1 and P_2 are 32-bit numbers (so multiplication by N\n-\/\/     is exact) and P_3 is a 53-bit number. Together, these\n-\/\/     approximate pi well enough for all cases in the restricted\n-\/\/     range.\n-\/\/\n-\/\/     The main reduction sequence is:\n-\/\/\n-\/\/             y = 32\/pi * x\n-\/\/             N = integer(y)\n-\/\/     (computed by adding and subtracting off SHIFTER)\n-\/\/\n-\/\/             m_1 = N * P_1\n-\/\/             m_2 = N * P_2\n-\/\/             r_1 = x - m_1\n-\/\/             r = r_1 - m_2\n-\/\/     (this r can be used for most of the calculation)\n-\/\/\n-\/\/             c_1 = r_1 - r\n-\/\/             m_3 = N * P_3\n-\/\/             c_2 = c_1 - m_2\n-\/\/             c = c_2 - m_3\n-\/\/\n-\/\/     2. MAIN ALGORITHM\n-\/\/\n-\/\/     The algorithm uses a table lookup based on B = M * pi \/ 32\n-\/\/     where M = N mod 64. The stored values are:\n-\/\/       sigma             closest power of 2 to cos(B)\n-\/\/       C_hl              53-bit cos(B) - sigma\n-\/\/       S_hi + S_lo       2 * 53-bit sin(B)\n-\/\/\n-\/\/     The computation is organized as follows:\n-\/\/\n-\/\/          sin(B + r + c) = [sin(B) + sigma * r] +\n-\/\/                           r * (cos(B) - sigma) +\n-\/\/                           sin(B) * [cos(r + c) - 1] +\n-\/\/                           cos(B) * [sin(r + c) - r]\n-\/\/\n-\/\/     which is approximately:\n-\/\/\n-\/\/          [S_hi + sigma * r] +\n-\/\/          C_hl * r +\n-\/\/          S_lo + S_hi * [(cos(r) - 1) - r * c] +\n-\/\/          (C_hl + sigma) * [(sin(r) - r) + c]\n-\/\/\n-\/\/     and this is what is actually computed. We separate this sum\n-\/\/     into four parts:\n-\/\/\n-\/\/          hi + med + pols + corr\n-\/\/\n-\/\/     where\n-\/\/\n-\/\/          hi       = S_hi + sigma r\n-\/\/          med      = C_hl * r\n-\/\/          pols     = S_hi * (cos(r) - 1) + (C_hl + sigma) * (sin(r) - r)\n-\/\/          corr     = S_lo + c * ((C_hl + sigma) - S_hi * r)\n-\/\/\n-\/\/     3. POLYNOMIAL\n-\/\/\n-\/\/     The polynomial S_hi * (cos(r) - 1) + (C_hl + sigma) *\n-\/\/     (sin(r) - r) can be rearranged freely, since it is quite\n-\/\/     small, so we exploit parallelism to the fullest.\n-\/\/\n-\/\/          psc4       =   SC_4 * r_1\n-\/\/          msc4       =   psc4 * r\n-\/\/          r2         =   r * r\n-\/\/          msc2       =   SC_2 * r2\n-\/\/          r4         =   r2 * r2\n-\/\/          psc3       =   SC_3 + msc4\n-\/\/          psc1       =   SC_1 + msc2\n-\/\/          msc3       =   r4 * psc3\n-\/\/          sincospols =   psc1 + msc3\n-\/\/          pols       =   sincospols *\n-\/\/                         <S_hi * r^2 | (C_hl + sigma) * r^3>\n-\/\/\n-\/\/     4. CORRECTION TERM\n-\/\/\n-\/\/     This is where the \"c\" component of the range reduction is\n-\/\/     taken into account; recall that just \"r\" is used for most of\n-\/\/     the calculation.\n-\/\/\n-\/\/          -c   = m_3 - c_2\n-\/\/          -d   = S_hi * r - (C_hl + sigma)\n-\/\/          corr = -c * -d + S_lo\n-\/\/\n-\/\/     5. COMPENSATED SUMMATIONS\n-\/\/\n-\/\/     The two successive compensated summations add up the high\n-\/\/     and medium parts, leaving just the low parts to add up at\n-\/\/     the end.\n-\/\/\n-\/\/          rs        =  sigma * r\n-\/\/          res_int   =  S_hi + rs\n-\/\/          k_0       =  S_hi - res_int\n-\/\/          k_2       =  k_0 + rs\n-\/\/          med       =  C_hl * r\n-\/\/          res_hi    =  res_int + med\n-\/\/          k_1       =  res_int - res_hi\n-\/\/          k_3       =  k_1 + med\n-\/\/\n-\/\/     6. FINAL SUMMATION\n-\/\/\n-\/\/     We now add up all the small parts:\n-\/\/\n-\/\/          res_lo = pols(hi) + pols(lo) + corr + k_1 + k_3\n-\/\/\n-\/\/     Now the overall result is just:\n-\/\/\n-\/\/          res_hi + res_lo\n-\/\/\n-\/\/     7. SMALL ARGUMENTS\n-\/\/\n-\/\/     Inputs with |X| < 2^-252 are treated specially as\n-\/\/     1 - |x|.\n-\/\/\n-\/\/ Special cases:\n-\/\/  cos(NaN) = quiet NaN, and raise invalid exception\n-\/\/  cos(INF) = NaN and raise invalid exception\n-\/\/  cos(0) = 1\n-\/\/\n-\/******************************************************************************\/\n-\n-#ifdef _LP64\n-\/\/ The 64 bit code is at most SSE2 compliant\n-void MacroAssembler::fast_cos(XMMRegister xmm0, XMMRegister xmm1, XMMRegister xmm2, XMMRegister xmm3,\n-                              XMMRegister xmm4, XMMRegister xmm5, XMMRegister xmm6, XMMRegister xmm7,\n-                              Register eax, Register ecx, Register edx, Register r8,\n-                              Register  r9, Register r10, Register r11, Register tmp) {\n-  Label L_2TAG_PACKET_0_0_1, L_2TAG_PACKET_1_0_1, L_2TAG_PACKET_2_0_1, L_2TAG_PACKET_3_0_1;\n-  Label L_2TAG_PACKET_4_0_1, L_2TAG_PACKET_5_0_1, L_2TAG_PACKET_6_0_1, L_2TAG_PACKET_7_0_1;\n-  Label L_2TAG_PACKET_8_0_1, L_2TAG_PACKET_9_0_1, L_2TAG_PACKET_10_0_1, L_2TAG_PACKET_11_0_1;\n-  Label L_2TAG_PACKET_12_0_1, L_2TAG_PACKET_13_0_1, B1_2, B1_4, start;\n-\n-  assert_different_registers(eax, ecx, edx, r8, r9, r10, r11, tmp);\n-\n-  bind(start);\n-  push(rbx);\n-  subq(rsp, 16);\n-  movsd(Address(rsp, 8), xmm0);\n-\n-  bind(B1_2);\n-  movl(eax, Address(rsp, 12));\n-  movq(xmm1, ExternalAddress(PI32INV), tmp \/*rscratch*\/);    \/\/0x6dc9c883UL, 0x40245f30UL\n-  andl(eax, 2147418112);\n-  subl(eax, 808452096);\n-  cmpl(eax, 281346048);\n-  jcc(Assembler::above, L_2TAG_PACKET_0_0_1);\n-  mulsd(xmm1, xmm0);\n-  movdqu(xmm5, ExternalAddress(ONEHALF), tmp \/*rscratch*\/);    \/\/0x00000000UL, 0x3fe00000UL, 0x00000000UL, 0x3fe00000UL\n-  movq(xmm4, ExternalAddress(SIGN_MASK), tmp \/*rscratch*\/);    \/\/0x00000000UL, 0x80000000UL\n-  pand(xmm4, xmm0);\n-  por(xmm5, xmm4);\n-  addpd(xmm1, xmm5);\n-  cvttsd2sil(edx, xmm1);\n-  cvtsi2sdl(xmm1, edx);\n-  movdqu(xmm2, ExternalAddress(P_2), tmp \/*rscratch*\/);    \/\/0x1a600000UL, 0x3d90b461UL, 0x1a600000UL, 0x3d90b461UL\n-  movq(xmm3, ExternalAddress(P_1), tmp \/*rscratch*\/);    \/\/0x54400000UL, 0x3fb921fbUL\n-  mulsd(xmm3, xmm1);\n-  unpcklpd(xmm1, xmm1);\n-  addq(rdx, 1865232);\n-  movdqu(xmm4, xmm0);\n-  andq(rdx, 63);\n-  movdqu(xmm5, ExternalAddress(SC_4), tmp \/*rscratch*\/);    \/\/0xa556c734UL, 0x3ec71de3UL, 0x1a01a01aUL, 0x3efa01a0UL\n-  lea(rax, ExternalAddress(Ctable));\n-  shlq(rdx, 5);\n-  addq(rax, rdx);\n-  mulpd(xmm2, xmm1);\n-  subsd(xmm0, xmm3);\n-  mulsd(xmm1, ExternalAddress(P_3), tmp \/*rscratch*\/);    \/\/0x2e037073UL, 0x3b63198aUL\n-  subsd(xmm4, xmm3);\n-  movq(xmm7, Address(rax, 8));\n-  unpcklpd(xmm0, xmm0);\n-  movdqu(xmm3, xmm4);\n-  subsd(xmm4, xmm2);\n-  mulpd(xmm5, xmm0);\n-  subpd(xmm0, xmm2);\n-  movdqu(xmm6, ExternalAddress(SC_2), tmp \/*rscratch*\/);    \/\/0x11111111UL, 0x3f811111UL, 0x55555555UL, 0x3fa55555UL\n-  mulsd(xmm7, xmm4);\n-  subsd(xmm3, xmm4);\n-  mulpd(xmm5, xmm0);\n-  mulpd(xmm0, xmm0);\n-  subsd(xmm3, xmm2);\n-  movdqu(xmm2, Address(rax, 0));\n-  subsd(xmm1, xmm3);\n-  movq(xmm3, Address(rax, 24));\n-  addsd(xmm2, xmm3);\n-  subsd(xmm7, xmm2);\n-  mulsd(xmm2, xmm4);\n-  mulpd(xmm6, xmm0);\n-  mulsd(xmm3, xmm4);\n-  mulpd(xmm2, xmm0);\n-  mulpd(xmm0, xmm0);\n-  addpd(xmm5, ExternalAddress(SC_3), tmp \/*rscratch*\/);    \/\/0x1a01a01aUL, 0xbf2a01a0UL, 0x16c16c17UL, 0xbf56c16cUL\n-  mulsd(xmm4, Address(rax, 0));\n-  addpd(xmm6, ExternalAddress(SC_1), tmp \/*rscratch*\/);    \/\/0x55555555UL, 0xbfc55555UL, 0x00000000UL, 0xbfe00000UL\n-  mulpd(xmm5, xmm0);\n-  movdqu(xmm0, xmm3);\n-  addsd(xmm3, Address(rax, 8));\n-  mulpd(xmm1, xmm7);\n-  movdqu(xmm7, xmm4);\n-  addsd(xmm4, xmm3);\n-  addpd(xmm6, xmm5);\n-  movq(xmm5, Address(rax, 8));\n-  subsd(xmm5, xmm3);\n-  subsd(xmm3, xmm4);\n-  addsd(xmm1, Address(rax, 16));\n-  mulpd(xmm6, xmm2);\n-  addsd(xmm0, xmm5);\n-  addsd(xmm3, xmm7);\n-  addsd(xmm0, xmm1);\n-  addsd(xmm0, xmm3);\n-  addsd(xmm0, xmm6);\n-  unpckhpd(xmm6, xmm6);\n-  addsd(xmm0, xmm6);\n-  addsd(xmm0, xmm4);\n-  jmp(B1_4);\n-\n-  bind(L_2TAG_PACKET_0_0_1);\n-  jcc(Assembler::greater, L_2TAG_PACKET_1_0_1);\n-  pextrw(eax, xmm0, 3);\n-  andl(eax, 32767);\n-  pinsrw(xmm0, eax, 3);\n-  movq(xmm1, ExternalAddress(ONE), tmp \/*rscratch*\/); \/\/ 0x00000000UL, 0x3ff00000UL\n-  subsd(xmm1, xmm0);\n-  movdqu(xmm0, xmm1);\n-  jmp(B1_4);\n-\n-  bind(L_2TAG_PACKET_1_0_1);\n-  pextrw(eax, xmm0, 3);\n-  andl(eax, 32752);\n-  cmpl(eax, 32752);\n-  jcc(Assembler::equal, L_2TAG_PACKET_2_0_1);\n-  pextrw(ecx, xmm0, 3);\n-  andl(ecx, 32752);\n-  subl(ecx, 16224);\n-  shrl(ecx, 7);\n-  andl(ecx, 65532);\n-  lea(r11, ExternalAddress(PI_INV_TABLE));\n-  addq(rcx, r11);\n-  movdq(rax, xmm0);\n-  movl(r10, Address(rcx, 20));\n-  movl(r8, Address(rcx, 24));\n-  movl(edx, eax);\n-  shrq(rax, 21);\n-  orl(eax, INT_MIN);\n-  shrl(eax, 11);\n-  movl(r9, r10);\n-  imulq(r10, rdx);\n-  imulq(r9, rax);\n-  imulq(r8, rax);\n-  movl(rsi, Address(rcx, 16));\n-  movl(rdi, Address(rcx, 12));\n-  movl(r11, r10);\n-  shrq(r10, 32);\n-  addq(r9, r10);\n-  addq(r11, r8);\n-  movl(r8, r11);\n-  shrq(r11, 32);\n-  addq(r9, r11);\n-  movl(r10, rsi);\n-  imulq(rsi, rdx);\n-  imulq(r10, rax);\n-  movl(r11, rdi);\n-  imulq(rdi, rdx);\n-  movl(rbx, rsi);\n-  shrq(rsi, 32);\n-  addq(r9, rbx);\n-  movl(rbx, r9);\n-  shrq(r9, 32);\n-  addq(r10, rsi);\n-  addq(r10, r9);\n-  shlq(rbx, 32);\n-  orq(r8, rbx);\n-  imulq(r11, rax);\n-  movl(r9, Address(rcx, 8));\n-  movl(rsi, Address(rcx, 4));\n-  movl(rbx, rdi);\n-  shrq(rdi, 32);\n-  addq(r10, rbx);\n-  movl(rbx, r10);\n-  shrq(r10, 32);\n-  addq(r11, rdi);\n-  addq(r11, r10);\n-  movq(rdi, r9);\n-  imulq(r9, rdx);\n-  imulq(rdi, rax);\n-  movl(r10, r9);\n-  shrq(r9, 32);\n-  addq(r11, r10);\n-  movl(r10, r11);\n-  shrq(r11, 32);\n-  addq(rdi, r9);\n-  addq(rdi, r11);\n-  movq(r9, rsi);\n-  imulq(rsi, rdx);\n-  imulq(r9, rax);\n-  shlq(r10, 32);\n-  orq(r10, rbx);\n-  movl(eax, Address(rcx, 0));\n-  movl(r11, rsi);\n-  shrq(rsi, 32);\n-  addq(rdi, r11);\n-  movl(r11, rdi);\n-  shrq(rdi, 32);\n-  addq(r9, rsi);\n-  addq(r9, rdi);\n-  imulq(rdx, rax);\n-  pextrw(rbx, xmm0, 3);\n-  lea(rdi, ExternalAddress(PI_INV_TABLE));\n-  subq(rcx, rdi);\n-  addl(ecx, ecx);\n-  addl(ecx, ecx);\n-  addl(ecx, ecx);\n-  addl(ecx, 19);\n-  movl(rsi, 32768);\n-  andl(rsi, rbx);\n-  shrl(rbx, 4);\n-  andl(rbx, 2047);\n-  subl(rbx, 1023);\n-  subl(ecx, rbx);\n-  addq(r9, rdx);\n-  movl(edx, ecx);\n-  addl(edx, 32);\n-  cmpl(ecx, 1);\n-  jcc(Assembler::less, L_2TAG_PACKET_3_0_1);\n-  negl(ecx);\n-  addl(ecx, 29);\n-  shll(r9);\n-  movl(rdi, r9);\n-  andl(r9, 536870911);\n-  testl(r9, 268435456);\n-  jcc(Assembler::notEqual, L_2TAG_PACKET_4_0_1);\n-  shrl(r9);\n-  movl(rbx, 0);\n-  shlq(r9, 32);\n-  orq(r9, r11);\n-\n-  bind(L_2TAG_PACKET_5_0_1);\n-\n-  bind(L_2TAG_PACKET_6_0_1);\n-  cmpq(r9, 0);\n-  jcc(Assembler::equal, L_2TAG_PACKET_7_0_1);\n-\n-  bind(L_2TAG_PACKET_8_0_1);\n-  bsrq(r11, r9);\n-  movl(ecx, 29);\n-  subl(ecx, r11);\n-  jcc(Assembler::lessEqual, L_2TAG_PACKET_9_0_1);\n-  shlq(r9);\n-  movq(rax, r10);\n-  shlq(r10);\n-  addl(edx, ecx);\n-  negl(ecx);\n-  addl(ecx, 64);\n-  shrq(rax);\n-  shrq(r8);\n-  orq(r9, rax);\n-  orq(r10, r8);\n-\n-  bind(L_2TAG_PACKET_10_0_1);\n-  cvtsi2sdq(xmm0, r9);\n-  shrq(r10, 1);\n-  cvtsi2sdq(xmm3, r10);\n-  xorpd(xmm4, xmm4);\n-  shll(edx, 4);\n-  negl(edx);\n-  addl(edx, 16368);\n-  orl(edx, rsi);\n-  xorl(edx, rbx);\n-  pinsrw(xmm4, edx, 3);\n-  movq(xmm2, ExternalAddress(PI_4),     tmp \/*rscratch*\/); \/\/0x40000000UL, 0x3fe921fbUL, 0x18469899UL, 0x3e64442dUL\n-  movq(xmm6, ExternalAddress(PI_4 + 8), tmp \/*rscratch*\/); \/\/0x3fe921fbUL, 0x18469899UL, 0x3e64442dUL\n-  xorpd(xmm5, xmm5);\n-  subl(edx, 1008);\n-  pinsrw(xmm5, edx, 3);\n-  mulsd(xmm0, xmm4);\n-  shll(rsi, 16);\n-  sarl(rsi, 31);\n-  mulsd(xmm3, xmm5);\n-  movdqu(xmm1, xmm0);\n-  mulsd(xmm0, xmm2);\n-  shrl(rdi, 29);\n-  addsd(xmm1, xmm3);\n-  mulsd(xmm3, xmm2);\n-  addl(rdi, rsi);\n-  xorl(rdi, rsi);\n-  mulsd(xmm6, xmm1);\n-  movl(eax, rdi);\n-  addsd(xmm6, xmm3);\n-  movdqu(xmm2, xmm0);\n-  addsd(xmm0, xmm6);\n-  subsd(xmm2, xmm0);\n-  addsd(xmm6, xmm2);\n-\n-  bind(L_2TAG_PACKET_11_0_1);\n-  movq(xmm1, ExternalAddress(PI32INV), tmp \/*rscratch*\/);   \/\/0x6dc9c883UL, 0x40245f30UL\n-  mulsd(xmm1, xmm0);\n-  movq(xmm5, ExternalAddress(ONEHALF), tmp \/*rscratch*\/);   \/\/0x00000000UL, 0x3fe00000UL, 0x00000000UL, 0x3fe00000UL\n-  movq(xmm4, ExternalAddress(SIGN_MASK), tmp \/*rscratch*\/); \/\/0x00000000UL, 0x80000000UL\n-  pand(xmm4, xmm0);\n-  por(xmm5, xmm4);\n-  addpd(xmm1, xmm5);\n-  cvttsd2siq(rdx, xmm1);\n-  cvtsi2sdq(xmm1, rdx);\n-  movq(xmm3, ExternalAddress(P_1), tmp \/*rscratch*\/);    \/\/0x54400000UL, 0x3fb921fbUL\n-  movdqu(xmm2, ExternalAddress(P_2), tmp \/*rscratch*\/);    \/\/0x1a600000UL, 0x3d90b461UL, 0x1a600000UL, 0x3d90b461UL\n-  mulsd(xmm3, xmm1);\n-  unpcklpd(xmm1, xmm1);\n-  shll(eax, 3);\n-  addl(edx, 1865232);\n-  movdqu(xmm4, xmm0);\n-  addl(edx, eax);\n-  andl(edx, 63);\n-  movdqu(xmm5, ExternalAddress(SC_4), tmp \/*rscratch*\/);    \/\/0xa556c734UL, 0x3ec71de3UL, 0x1a01a01aUL, 0x3efa01a0UL\n-  lea(rax, ExternalAddress(Ctable));\n-  shll(edx, 5);\n-  addq(rax, rdx);\n-  mulpd(xmm2, xmm1);\n-  subsd(xmm0, xmm3);\n-  mulsd(xmm1, ExternalAddress(P_3), tmp \/*rscratch*\/);    \/\/0x2e037073UL, 0x3b63198aUL\n-  subsd(xmm4, xmm3);\n-  movq(xmm7, Address(rax, 8));\n-  unpcklpd(xmm0, xmm0);\n-  movdqu(xmm3, xmm4);\n-  subsd(xmm4, xmm2);\n-  mulpd(xmm5, xmm0);\n-  subpd(xmm0, xmm2);\n-  mulsd(xmm7, xmm4);\n-  subsd(xmm3, xmm4);\n-  mulpd(xmm5, xmm0);\n-  mulpd(xmm0, xmm0);\n-  subsd(xmm3, xmm2);\n-  movdqu(xmm2, Address(rax, 0));\n-  subsd(xmm1, xmm3);\n-  movq(xmm3, Address(rax, 24));\n-  addsd(xmm2, xmm3);\n-  subsd(xmm7, xmm2);\n-  subsd(xmm1, xmm6);\n-  movdqu(xmm6, ExternalAddress(SC_2), tmp \/*rscratch*\/);    \/\/0x11111111UL, 0x3f811111UL, 0x55555555UL, 0x3fa55555UL\n-  mulsd(xmm2, xmm4);\n-  mulpd(xmm6, xmm0);\n-  mulsd(xmm3, xmm4);\n-  mulpd(xmm2, xmm0);\n-  mulpd(xmm0, xmm0);\n-  addpd(xmm5, ExternalAddress(SC_3), tmp \/*rscratch*\/);    \/\/0x1a01a01aUL, 0xbf2a01a0UL, 0x16c16c17UL, 0xbf56c16cUL\n-  mulsd(xmm4, Address(rax, 0));\n-  addpd(xmm6, ExternalAddress(SC_1), tmp \/*rscratch*\/);    \/\/0x55555555UL, 0xbfc55555UL, 0x00000000UL, 0xbfe00000UL\n-  mulpd(xmm5, xmm0);\n-  movdqu(xmm0, xmm3);\n-  addsd(xmm3, Address(rax, 8));\n-  mulpd(xmm1, xmm7);\n-  movdqu(xmm7, xmm4);\n-  addsd(xmm4, xmm3);\n-  addpd(xmm6, xmm5);\n-  movq(xmm5, Address(rax, 8));\n-  subsd(xmm5, xmm3);\n-  subsd(xmm3, xmm4);\n-  addsd(xmm1, Address(rax, 16));\n-  mulpd(xmm6, xmm2);\n-  addsd(xmm5, xmm0);\n-  addsd(xmm3, xmm7);\n-  addsd(xmm1, xmm5);\n-  addsd(xmm1, xmm3);\n-  addsd(xmm1, xmm6);\n-  unpckhpd(xmm6, xmm6);\n-  movdqu(xmm0, xmm4);\n-  addsd(xmm1, xmm6);\n-  addsd(xmm0, xmm1);\n-  jmp(B1_4);\n-\n-  bind(L_2TAG_PACKET_7_0_1);\n-  addl(edx, 64);\n-  movq(r9, r10);\n-  movq(r10, r8);\n-  movl(r8, 0);\n-  cmpq(r9, 0);\n-  jcc(Assembler::notEqual, L_2TAG_PACKET_8_0_1);\n-  addl(edx, 64);\n-  movq(r9, r10);\n-  movq(r10, r8);\n-  cmpq(r9, 0);\n-  jcc(Assembler::notEqual, L_2TAG_PACKET_8_0_1);\n-  xorpd(xmm0, xmm0);\n-  xorpd(xmm6, xmm6);\n-  jmp(L_2TAG_PACKET_11_0_1);\n-\n-  bind(L_2TAG_PACKET_9_0_1);\n-  jcc(Assembler::equal, L_2TAG_PACKET_10_0_1);\n-  negl(ecx);\n-  shrq(r10);\n-  movq(rax, r9);\n-  shrq(r9);\n-  subl(edx, ecx);\n-  negl(ecx);\n-  addl(ecx, 64);\n-  shlq(rax);\n-  orq(r10, rax);\n-  jmp(L_2TAG_PACKET_10_0_1);\n-  bind(L_2TAG_PACKET_3_0_1);\n-  negl(ecx);\n-  shlq(r9, 32);\n-  orq(r9, r11);\n-  shlq(r9);\n-  movq(rdi, r9);\n-  testl(r9, INT_MIN);\n-  jcc(Assembler::notEqual, L_2TAG_PACKET_12_0_1);\n-  shrl(r9);\n-  movl(rbx, 0);\n-  shrq(rdi, 3);\n-  jmp(L_2TAG_PACKET_6_0_1);\n-\n-  bind(L_2TAG_PACKET_4_0_1);\n-  shrl(r9);\n-  movl(rbx, 536870912);\n-  shrl(rbx);\n-  shlq(r9, 32);\n-  orq(r9, r11);\n-  shlq(rbx, 32);\n-  addl(rdi, 536870912);\n-  movl(rcx, 0);\n-  movl(r11, 0);\n-  subq(rcx, r8);\n-  sbbq(r11, r10);\n-  sbbq(rbx, r9);\n-  movq(r8, rcx);\n-  movq(r10, r11);\n-  movq(r9, rbx);\n-  movl(rbx, 32768);\n-  jmp(L_2TAG_PACKET_5_0_1);\n-\n-  bind(L_2TAG_PACKET_12_0_1);\n-  shrl(r9);\n-  mov64(rbx, 0x100000000);\n-  shrq(rbx);\n-  movl(rcx, 0);\n-  movl(r11, 0);\n-  subq(rcx, r8);\n-  sbbq(r11, r10);\n-  sbbq(rbx, r9);\n-  movq(r8, rcx);\n-  movq(r10, r11);\n-  movq(r9, rbx);\n-  movl(rbx, 32768);\n-  shrq(rdi, 3);\n-  addl(rdi, 536870912);\n-  jmp(L_2TAG_PACKET_6_0_1);\n-\n-  bind(L_2TAG_PACKET_2_0_1);\n-  movsd(xmm0, Address(rsp, 8));\n-  mulsd(xmm0, ExternalAddress(NEG_ZERO), tmp \/*rscratch*\/);    \/\/0x00000000UL, 0x80000000UL\n-  movq(Address(rsp, 0), xmm0);\n-\n-  bind(L_2TAG_PACKET_13_0_1);\n-\n-  bind(B1_4);\n-  addq(rsp, 16);\n-  pop(rbx);\n-}\n-#else\n-\/\/ The 32 bit code is at most SSE2 compliant\n-\n-ATTRIBUTE_ALIGNED(16) juint _static_const_table_cos[] =\n-{\n-    0x00000000UL, 0x00000000UL, 0x00000000UL, 0x00000000UL, 0x00000000UL,\n-    0x00000000UL, 0x00000000UL, 0x3ff00000UL, 0x176d6d31UL, 0xbf73b92eUL,\n-    0xbc29b42cUL, 0x3fb917a6UL, 0xe0000000UL, 0xbc3e2718UL, 0x00000000UL,\n-    0x3ff00000UL, 0x011469fbUL, 0xbf93ad06UL, 0x3c69a60bUL, 0x3fc8f8b8UL,\n-    0xc0000000UL, 0xbc626d19UL, 0x00000000UL, 0x3ff00000UL, 0x939d225aUL,\n-    0xbfa60beaUL, 0x2ed59f06UL, 0x3fd29406UL, 0xa0000000UL, 0xbc75d28dUL,\n-    0x00000000UL, 0x3ff00000UL, 0x866b95cfUL, 0xbfb37ca1UL, 0xa6aea963UL,\n-    0x3fd87de2UL, 0xe0000000UL, 0xbc672cedUL, 0x00000000UL, 0x3ff00000UL,\n-    0x73fa1279UL, 0xbfbe3a68UL, 0x3806f63bUL, 0x3fde2b5dUL, 0x20000000UL,\n-    0x3c5e0d89UL, 0x00000000UL, 0x3ff00000UL, 0x5bc57974UL, 0xbfc59267UL,\n-    0x39ae68c8UL, 0x3fe1c73bUL, 0x20000000UL, 0x3c8b25ddUL, 0x00000000UL,\n-    0x3ff00000UL, 0x53aba2fdUL, 0xbfcd0dfeUL, 0x25091dd6UL, 0x3fe44cf3UL,\n-    0x20000000UL, 0x3c68076aUL, 0x00000000UL, 0x3ff00000UL, 0x99fcef32UL,\n-    0x3fca8279UL, 0x667f3bcdUL, 0x3fe6a09eUL, 0x20000000UL, 0xbc8bdd34UL,\n-    0x00000000UL, 0x3fe00000UL, 0x94247758UL, 0x3fc133ccUL, 0x6b151741UL,\n-    0x3fe8bc80UL, 0x20000000UL, 0xbc82c5e1UL, 0x00000000UL, 0x3fe00000UL,\n-    0x9ae68c87UL, 0x3fac73b3UL, 0x290ea1a3UL, 0x3fea9b66UL, 0xe0000000UL,\n-    0x3c39f630UL, 0x00000000UL, 0x3fe00000UL, 0x7f909c4eUL, 0xbf9d4a2cUL,\n-    0xf180bdb1UL, 0x3fec38b2UL, 0x80000000UL, 0xbc76e0b1UL, 0x00000000UL,\n-    0x3fe00000UL, 0x65455a75UL, 0xbfbe0875UL, 0xcf328d46UL, 0x3fed906bUL,\n-    0x20000000UL, 0x3c7457e6UL, 0x00000000UL, 0x3fe00000UL, 0x76acf82dUL,\n-    0x3fa4a031UL, 0x56c62ddaUL, 0x3fee9f41UL, 0xe0000000UL, 0x3c8760b1UL,\n-    0x00000000UL, 0x3fd00000UL, 0x0e5967d5UL, 0xbfac1d1fUL, 0xcff75cb0UL,\n-    0x3fef6297UL, 0x20000000UL, 0x3c756217UL, 0x00000000UL, 0x3fd00000UL,\n-    0x0f592f50UL, 0xbf9ba165UL, 0xa3d12526UL, 0x3fefd88dUL, 0x40000000UL,\n-    0xbc887df6UL, 0x00000000UL, 0x3fc00000UL, 0x00000000UL, 0x00000000UL,\n-    0x00000000UL, 0x3ff00000UL, 0x00000000UL, 0x00000000UL, 0x00000000UL,\n-    0x00000000UL, 0x0f592f50UL, 0x3f9ba165UL, 0xa3d12526UL, 0x3fefd88dUL,\n-    0x40000000UL, 0xbc887df6UL, 0x00000000UL, 0xbfc00000UL, 0x0e5967d5UL,\n-    0x3fac1d1fUL, 0xcff75cb0UL, 0x3fef6297UL, 0x20000000UL, 0x3c756217UL,\n-    0x00000000UL, 0xbfd00000UL, 0x76acf82dUL, 0xbfa4a031UL, 0x56c62ddaUL,\n-    0x3fee9f41UL, 0xe0000000UL, 0x3c8760b1UL, 0x00000000UL, 0xbfd00000UL,\n-    0x65455a75UL, 0x3fbe0875UL, 0xcf328d46UL, 0x3fed906bUL, 0x20000000UL,\n-    0x3c7457e6UL, 0x00000000UL, 0xbfe00000UL, 0x7f909c4eUL, 0x3f9d4a2cUL,\n-    0xf180bdb1UL, 0x3fec38b2UL, 0x80000000UL, 0xbc76e0b1UL, 0x00000000UL,\n-    0xbfe00000UL, 0x9ae68c87UL, 0xbfac73b3UL, 0x290ea1a3UL, 0x3fea9b66UL,\n-    0xe0000000UL, 0x3c39f630UL, 0x00000000UL, 0xbfe00000UL, 0x94247758UL,\n-    0xbfc133ccUL, 0x6b151741UL, 0x3fe8bc80UL, 0x20000000UL, 0xbc82c5e1UL,\n-    0x00000000UL, 0xbfe00000UL, 0x99fcef32UL, 0xbfca8279UL, 0x667f3bcdUL,\n-    0x3fe6a09eUL, 0x20000000UL, 0xbc8bdd34UL, 0x00000000UL, 0xbfe00000UL,\n-    0x53aba2fdUL, 0x3fcd0dfeUL, 0x25091dd6UL, 0x3fe44cf3UL, 0x20000000UL,\n-    0x3c68076aUL, 0x00000000UL, 0xbff00000UL, 0x5bc57974UL, 0x3fc59267UL,\n-    0x39ae68c8UL, 0x3fe1c73bUL, 0x20000000UL, 0x3c8b25ddUL, 0x00000000UL,\n-    0xbff00000UL, 0x73fa1279UL, 0x3fbe3a68UL, 0x3806f63bUL, 0x3fde2b5dUL,\n-    0x20000000UL, 0x3c5e0d89UL, 0x00000000UL, 0xbff00000UL, 0x866b95cfUL,\n-    0x3fb37ca1UL, 0xa6aea963UL, 0x3fd87de2UL, 0xe0000000UL, 0xbc672cedUL,\n-    0x00000000UL, 0xbff00000UL, 0x939d225aUL, 0x3fa60beaUL, 0x2ed59f06UL,\n-    0x3fd29406UL, 0xa0000000UL, 0xbc75d28dUL, 0x00000000UL, 0xbff00000UL,\n-    0x011469fbUL, 0x3f93ad06UL, 0x3c69a60bUL, 0x3fc8f8b8UL, 0xc0000000UL,\n-    0xbc626d19UL, 0x00000000UL, 0xbff00000UL, 0x176d6d31UL, 0x3f73b92eUL,\n-    0xbc29b42cUL, 0x3fb917a6UL, 0xe0000000UL, 0xbc3e2718UL, 0x00000000UL,\n-    0xbff00000UL, 0x00000000UL, 0x00000000UL, 0x00000000UL, 0x00000000UL,\n-    0x00000000UL, 0x00000000UL, 0x00000000UL, 0xbff00000UL, 0x176d6d31UL,\n-    0x3f73b92eUL, 0xbc29b42cUL, 0xbfb917a6UL, 0xe0000000UL, 0x3c3e2718UL,\n-    0x00000000UL, 0xbff00000UL, 0x011469fbUL, 0x3f93ad06UL, 0x3c69a60bUL,\n-    0xbfc8f8b8UL, 0xc0000000UL, 0x3c626d19UL, 0x00000000UL, 0xbff00000UL,\n-    0x939d225aUL, 0x3fa60beaUL, 0x2ed59f06UL, 0xbfd29406UL, 0xa0000000UL,\n-    0x3c75d28dUL, 0x00000000UL, 0xbff00000UL, 0x866b95cfUL, 0x3fb37ca1UL,\n-    0xa6aea963UL, 0xbfd87de2UL, 0xe0000000UL, 0x3c672cedUL, 0x00000000UL,\n-    0xbff00000UL, 0x73fa1279UL, 0x3fbe3a68UL, 0x3806f63bUL, 0xbfde2b5dUL,\n-    0x20000000UL, 0xbc5e0d89UL, 0x00000000UL, 0xbff00000UL, 0x5bc57974UL,\n-    0x3fc59267UL, 0x39ae68c8UL, 0xbfe1c73bUL, 0x20000000UL, 0xbc8b25ddUL,\n-    0x00000000UL, 0xbff00000UL, 0x53aba2fdUL, 0x3fcd0dfeUL, 0x25091dd6UL,\n-    0xbfe44cf3UL, 0x20000000UL, 0xbc68076aUL, 0x00000000UL, 0xbff00000UL,\n-    0x99fcef32UL, 0xbfca8279UL, 0x667f3bcdUL, 0xbfe6a09eUL, 0x20000000UL,\n-    0x3c8bdd34UL, 0x00000000UL, 0xbfe00000UL, 0x94247758UL, 0xbfc133ccUL,\n-    0x6b151741UL, 0xbfe8bc80UL, 0x20000000UL, 0x3c82c5e1UL, 0x00000000UL,\n-    0xbfe00000UL, 0x9ae68c87UL, 0xbfac73b3UL, 0x290ea1a3UL, 0xbfea9b66UL,\n-    0xe0000000UL, 0xbc39f630UL, 0x00000000UL, 0xbfe00000UL, 0x7f909c4eUL,\n-    0x3f9d4a2cUL, 0xf180bdb1UL, 0xbfec38b2UL, 0x80000000UL, 0x3c76e0b1UL,\n-    0x00000000UL, 0xbfe00000UL, 0x65455a75UL, 0x3fbe0875UL, 0xcf328d46UL,\n-    0xbfed906bUL, 0x20000000UL, 0xbc7457e6UL, 0x00000000UL, 0xbfe00000UL,\n-    0x76acf82dUL, 0xbfa4a031UL, 0x56c62ddaUL, 0xbfee9f41UL, 0xe0000000UL,\n-    0xbc8760b1UL, 0x00000000UL, 0xbfd00000UL, 0x0e5967d5UL, 0x3fac1d1fUL,\n-    0xcff75cb0UL, 0xbfef6297UL, 0x20000000UL, 0xbc756217UL, 0x00000000UL,\n-    0xbfd00000UL, 0x0f592f50UL, 0x3f9ba165UL, 0xa3d12526UL, 0xbfefd88dUL,\n-    0x40000000UL, 0x3c887df6UL, 0x00000000UL, 0xbfc00000UL, 0x00000000UL,\n-    0x00000000UL, 0x00000000UL, 0xbff00000UL, 0x00000000UL, 0x00000000UL,\n-    0x00000000UL, 0x00000000UL, 0x0f592f50UL, 0xbf9ba165UL, 0xa3d12526UL,\n-    0xbfefd88dUL, 0x40000000UL, 0x3c887df6UL, 0x00000000UL, 0x3fc00000UL,\n-    0x0e5967d5UL, 0xbfac1d1fUL, 0xcff75cb0UL, 0xbfef6297UL, 0x20000000UL,\n-    0xbc756217UL, 0x00000000UL, 0x3fd00000UL, 0x76acf82dUL, 0x3fa4a031UL,\n-    0x56c62ddaUL, 0xbfee9f41UL, 0xe0000000UL, 0xbc8760b1UL, 0x00000000UL,\n-    0x3fd00000UL, 0x65455a75UL, 0xbfbe0875UL, 0xcf328d46UL, 0xbfed906bUL,\n-    0x20000000UL, 0xbc7457e6UL, 0x00000000UL, 0x3fe00000UL, 0x7f909c4eUL,\n-    0xbf9d4a2cUL, 0xf180bdb1UL, 0xbfec38b2UL, 0x80000000UL, 0x3c76e0b1UL,\n-    0x00000000UL, 0x3fe00000UL, 0x9ae68c87UL, 0x3fac73b3UL, 0x290ea1a3UL,\n-    0xbfea9b66UL, 0xe0000000UL, 0xbc39f630UL, 0x00000000UL, 0x3fe00000UL,\n-    0x94247758UL, 0x3fc133ccUL, 0x6b151741UL, 0xbfe8bc80UL, 0x20000000UL,\n-    0x3c82c5e1UL, 0x00000000UL, 0x3fe00000UL, 0x99fcef32UL, 0x3fca8279UL,\n-    0x667f3bcdUL, 0xbfe6a09eUL, 0x20000000UL, 0x3c8bdd34UL, 0x00000000UL,\n-    0x3fe00000UL, 0x53aba2fdUL, 0xbfcd0dfeUL, 0x25091dd6UL, 0xbfe44cf3UL,\n-    0x20000000UL, 0xbc68076aUL, 0x00000000UL, 0x3ff00000UL, 0x5bc57974UL,\n-    0xbfc59267UL, 0x39ae68c8UL, 0xbfe1c73bUL, 0x20000000UL, 0xbc8b25ddUL,\n-    0x00000000UL, 0x3ff00000UL, 0x73fa1279UL, 0xbfbe3a68UL, 0x3806f63bUL,\n-    0xbfde2b5dUL, 0x20000000UL, 0xbc5e0d89UL, 0x00000000UL, 0x3ff00000UL,\n-    0x866b95cfUL, 0xbfb37ca1UL, 0xa6aea963UL, 0xbfd87de2UL, 0xe0000000UL,\n-    0x3c672cedUL, 0x00000000UL, 0x3ff00000UL, 0x939d225aUL, 0xbfa60beaUL,\n-    0x2ed59f06UL, 0xbfd29406UL, 0xa0000000UL, 0x3c75d28dUL, 0x00000000UL,\n-    0x3ff00000UL, 0x011469fbUL, 0xbf93ad06UL, 0x3c69a60bUL, 0xbfc8f8b8UL,\n-    0xc0000000UL, 0x3c626d19UL, 0x00000000UL, 0x3ff00000UL, 0x176d6d31UL,\n-    0xbf73b92eUL, 0xbc29b42cUL, 0xbfb917a6UL, 0xe0000000UL, 0x3c3e2718UL,\n-    0x00000000UL, 0x3ff00000UL, 0x55555555UL, 0xbfc55555UL, 0x00000000UL,\n-    0xbfe00000UL, 0x11111111UL, 0x3f811111UL, 0x55555555UL, 0x3fa55555UL,\n-    0x1a01a01aUL, 0xbf2a01a0UL, 0x16c16c17UL, 0xbf56c16cUL, 0xa556c734UL,\n-    0x3ec71de3UL, 0x1a01a01aUL, 0x3efa01a0UL, 0x1a600000UL, 0x3d90b461UL,\n-    0x1a600000UL, 0x3d90b461UL, 0x54400000UL, 0x3fb921fbUL, 0x00000000UL,\n-    0x00000000UL, 0x2e037073UL, 0x3b63198aUL, 0x00000000UL, 0x00000000UL,\n-    0x6dc9c883UL, 0x40245f30UL, 0x00000000UL, 0x00000000UL, 0x00000000UL,\n-    0x43380000UL, 0x00000000UL, 0x00000000UL, 0x00000000UL, 0x3ff00000UL,\n-    0x00000000UL, 0x00000000UL, 0x00000000UL, 0x80000000UL, 0x00000000UL,\n-    0x00000000UL, 0x00000000UL, 0x80000000UL, 0x00000000UL, 0x00000000UL,\n-    0x00000000UL, 0x3fe00000UL, 0x00000000UL, 0x3fe00000UL\n-};\n-\/\/registers,\n-\/\/ input: (rbp + 8)\n-\/\/ scratch: xmm1, xmm2, xmm3, xmm4, xmm5, xmm6, xmm7\n-\/\/          eax, ecx, edx, ebx (tmp)\n-\n-\/\/ Code generated by Intel C compiler for LIBM library\n-\n-void MacroAssembler::fast_cos(XMMRegister xmm0, XMMRegister xmm1, XMMRegister xmm2, XMMRegister xmm3,\n-                              XMMRegister xmm4, XMMRegister xmm5, XMMRegister xmm6, XMMRegister xmm7,\n-                              Register eax, Register ecx, Register edx, Register tmp) {\n-  Label L_2TAG_PACKET_0_0_2, L_2TAG_PACKET_1_0_2, L_2TAG_PACKET_2_0_2, L_2TAG_PACKET_3_0_2;\n-  Label start;\n-\n-  assert_different_registers(tmp, eax, ecx, edx);\n-\n-  address static_const_table_cos = (address)_static_const_table_cos;\n-\n-  bind(start);\n-  subl(rsp, 120);\n-  movl(Address(rsp, 56), tmp);\n-  lea(tmp, ExternalAddress(static_const_table_cos));\n-  movsd(xmm0, Address(rsp, 128));\n-  pextrw(eax, xmm0, 3);\n-  andl(eax, 32767);\n-  subl(eax, 12336);\n-  cmpl(eax, 4293);\n-  jcc(Assembler::above, L_2TAG_PACKET_0_0_2);\n-  movsd(xmm1, Address(tmp, 2160));\n-  mulsd(xmm1, xmm0);\n-  movdqu(xmm5, Address(tmp, 2240));\n-  movsd(xmm4, Address(tmp, 2224));\n-  pand(xmm4, xmm0);\n-  por(xmm5, xmm4);\n-  movsd(xmm3, Address(tmp, 2128));\n-  movdqu(xmm2, Address(tmp, 2112));\n-  addpd(xmm1, xmm5);\n-  cvttsd2sil(edx, xmm1);\n-  cvtsi2sdl(xmm1, edx);\n-  mulsd(xmm3, xmm1);\n-  unpcklpd(xmm1, xmm1);\n-  addl(edx, 1865232);\n-  movdqu(xmm4, xmm0);\n-  andl(edx, 63);\n-  movdqu(xmm5, Address(tmp, 2096));\n-  lea(eax, Address(tmp, 0));\n-  shll(edx, 5);\n-  addl(eax, edx);\n-  mulpd(xmm2, xmm1);\n-  subsd(xmm0, xmm3);\n-  mulsd(xmm1, Address(tmp, 2144));\n-  subsd(xmm4, xmm3);\n-  movsd(xmm7, Address(eax, 8));\n-  unpcklpd(xmm0, xmm0);\n-  movapd(xmm3, xmm4);\n-  subsd(xmm4, xmm2);\n-  mulpd(xmm5, xmm0);\n-  subpd(xmm0, xmm2);\n-  movdqu(xmm6, Address(tmp, 2064));\n-  mulsd(xmm7, xmm4);\n-  subsd(xmm3, xmm4);\n-  mulpd(xmm5, xmm0);\n-  mulpd(xmm0, xmm0);\n-  subsd(xmm3, xmm2);\n-  movdqu(xmm2, Address(eax, 0));\n-  subsd(xmm1, xmm3);\n-  movsd(xmm3, Address(eax, 24));\n-  addsd(xmm2, xmm3);\n-  subsd(xmm7, xmm2);\n-  mulsd(xmm2, xmm4);\n-  mulpd(xmm6, xmm0);\n-  mulsd(xmm3, xmm4);\n-  mulpd(xmm2, xmm0);\n-  mulpd(xmm0, xmm0);\n-  addpd(xmm5, Address(tmp, 2080));\n-  mulsd(xmm4, Address(eax, 0));\n-  addpd(xmm6, Address(tmp, 2048));\n-  mulpd(xmm5, xmm0);\n-  movapd(xmm0, xmm3);\n-  addsd(xmm3, Address(eax, 8));\n-  mulpd(xmm1, xmm7);\n-  movapd(xmm7, xmm4);\n-  addsd(xmm4, xmm3);\n-  addpd(xmm6, xmm5);\n-  movsd(xmm5, Address(eax, 8));\n-  subsd(xmm5, xmm3);\n-  subsd(xmm3, xmm4);\n-  addsd(xmm1, Address(eax, 16));\n-  mulpd(xmm6, xmm2);\n-  addsd(xmm5, xmm0);\n-  addsd(xmm3, xmm7);\n-  addsd(xmm1, xmm5);\n-  addsd(xmm1, xmm3);\n-  addsd(xmm1, xmm6);\n-  unpckhpd(xmm6, xmm6);\n-  addsd(xmm1, xmm6);\n-  addsd(xmm4, xmm1);\n-  movsd(Address(rsp, 0), xmm4);\n-  fld_d(Address(rsp, 0));\n-  jmp(L_2TAG_PACKET_1_0_2);\n-\n-  bind(L_2TAG_PACKET_0_0_2);\n-  jcc(Assembler::greater, L_2TAG_PACKET_2_0_2);\n-  pextrw(eax, xmm0, 3);\n-  andl(eax, 32767);\n-  pinsrw(xmm0, eax, 3);\n-  movsd(xmm1, Address(tmp, 2192));\n-  subsd(xmm1, xmm0);\n-  movsd(Address(rsp, 0), xmm1);\n-  fld_d(Address(rsp, 0));\n-  jmp(L_2TAG_PACKET_1_0_2);\n-\n-  bind(L_2TAG_PACKET_2_0_2);\n-  movl(eax, Address(rsp, 132));\n-  andl(eax, 2146435072);\n-  cmpl(eax, 2146435072);\n-  jcc(Assembler::equal, L_2TAG_PACKET_3_0_2);\n-  subl(rsp, 32);\n-  movsd(Address(rsp, 0), xmm0);\n-  lea(eax, Address(rsp, 40));\n-  movl(Address(rsp, 8), eax);\n-  movl(eax, 1);\n-  movl(Address(rsp, 12), eax);\n-  call(RuntimeAddress(CAST_FROM_FN_PTR(address, StubRoutines::dlibm_sin_cos_huge())));\n-  addl(rsp, 32);\n-  fld_d(Address(rsp, 8));\n-  jmp(L_2TAG_PACKET_1_0_2);\n-\n-  bind(L_2TAG_PACKET_3_0_2);\n-  fld_d(Address(rsp, 128));\n-  fmul_d(Address(tmp, 2208));\n-\n-  bind(L_2TAG_PACKET_1_0_2);\n-  movl(tmp, Address(rsp, 56));\n-}\n-#endif\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86_cos.cpp","additions":0,"deletions":866,"binary":false,"changes":866,"status":"deleted"},{"patch":"@@ -1,654 +0,0 @@\n-\/*\n-* Copyright (c) 2016, 2021, Intel Corporation. All rights reserved.\n-* Copyright (C) 2021 THL A29 Limited, a Tencent company. All rights reserved.\n-* Intel Math Library (LIBM) Source Code\n-*\n-* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-*\n-* This code is free software; you can redistribute it and\/or modify it\n-* under the terms of the GNU General Public License version 2 only, as\n-* published by the Free Software Foundation.\n-*\n-* This code is distributed in the hope that it will be useful, but WITHOUT\n-* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-* FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-* version 2 for more details (a copy is included in the LICENSE file that\n-* accompanied this code).\n-*\n-* You should have received a copy of the GNU General Public License version\n-* 2 along with this work; if not, write to the Free Software Foundation,\n-* Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-*\n-* Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-* or visit www.oracle.com if you need additional information or have any\n-* questions.\n-*\n-*\/\n-\n-#include \"precompiled.hpp\"\n-#include \"asm\/assembler.hpp\"\n-#include \"asm\/assembler.inline.hpp\"\n-#include \"macroAssembler_x86.hpp\"\n-#include \"runtime\/stubRoutines.hpp\"\n-#include \"utilities\/globalDefinitions.hpp\"\n-\n-\/******************************************************************************\/\n-\/\/                     ALGORITHM DESCRIPTION - EXP()\n-\/\/                     ---------------------\n-\/\/\n-\/\/ Description:\n-\/\/  Let K = 64 (table size).\n-\/\/        x    x\/log(2)     n\n-\/\/       e  = 2          = 2 * T[j] * (1 + P(y))\n-\/\/  where\n-\/\/       x = m*log(2)\/K + y,    y in [-log(2)\/K..log(2)\/K]\n-\/\/       m = n*K + j,           m,n,j - signed integer, j in [-K\/2..K\/2]\n-\/\/                  j\/K\n-\/\/       values of 2   are tabulated as T[j] = T_hi[j] ( 1 + T_lo[j]).\n-\/\/\n-\/\/       P(y) is a minimax polynomial approximation of exp(x)-1\n-\/\/       on small interval [-log(2)\/K..log(2)\/K] (were calculated by Maple V).\n-\/\/\n-\/\/  To avoid problems with arithmetic overflow and underflow,\n-\/\/            n                        n1  n2\n-\/\/  value of 2  is safely computed as 2 * 2 where n1 in [-BIAS\/2..BIAS\/2]\n-\/\/  where BIAS is a value of exponent bias.\n-\/\/\n-\/\/ Special cases:\n-\/\/  exp(NaN) = NaN\n-\/\/  exp(+INF) = +INF\n-\/\/  exp(-INF) = 0\n-\/\/  exp(x) = 1 for subnormals\n-\/\/  for finite argument, only exp(0)=1 is exact\n-\/\/  For IEEE double\n-\/\/    if x >  709.782712893383973096 then exp(x) overflow\n-\/\/    if x < -745.133219101941108420 then exp(x) underflow\n-\/\/\n-\/******************************************************************************\/\n-\n-#ifdef _LP64\n-\/\/ The 64 bit code is at most SSE2 compliant\n-ATTRIBUTE_ALIGNED(16) juint _cv[] =\n-{\n-    0x652b82feUL, 0x40571547UL, 0x652b82feUL, 0x40571547UL, 0xfefa0000UL,\n-    0x3f862e42UL, 0xfefa0000UL, 0x3f862e42UL, 0xbc9e3b3aUL, 0x3d1cf79aUL,\n-    0xbc9e3b3aUL, 0x3d1cf79aUL, 0xfffffffeUL, 0x3fdfffffUL, 0xfffffffeUL,\n-    0x3fdfffffUL, 0xe3289860UL, 0x3f56c15cUL, 0x555b9e25UL, 0x3fa55555UL,\n-    0xc090cf0fUL, 0x3f811115UL, 0x55548ba1UL, 0x3fc55555UL\n-};\n-\n-ATTRIBUTE_ALIGNED(16) juint _mmask[] =\n-{\n-    0xffffffc0UL, 0x00000000UL, 0xffffffc0UL, 0x00000000UL\n-};\n-\n-ATTRIBUTE_ALIGNED(16) juint _bias[] =\n-{\n-    0x0000ffc0UL, 0x00000000UL, 0x0000ffc0UL, 0x00000000UL\n-};\n-\n-ATTRIBUTE_ALIGNED(16) juint _Tbl_addr[] =\n-{\n-    0x00000000UL, 0x00000000UL, 0x00000000UL, 0x00000000UL, 0x0e03754dUL,\n-    0x3cad7bbfUL, 0x3e778060UL, 0x00002c9aUL, 0x3567f613UL, 0x3c8cd252UL,\n-    0xd3158574UL, 0x000059b0UL, 0x61e6c861UL, 0x3c60f74eUL, 0x18759bc8UL,\n-    0x00008745UL, 0x5d837b6cUL, 0x3c979aa6UL, 0x6cf9890fUL, 0x0000b558UL,\n-    0x702f9cd1UL, 0x3c3ebe3dUL, 0x32d3d1a2UL, 0x0000e3ecUL, 0x1e63bcd8UL,\n-    0x3ca3516eUL, 0xd0125b50UL, 0x00011301UL, 0x26f0387bUL, 0x3ca4c554UL,\n-    0xaea92ddfUL, 0x0001429aUL, 0x62523fb6UL, 0x3ca95153UL, 0x3c7d517aUL,\n-    0x000172b8UL, 0x3f1353bfUL, 0x3c8b898cUL, 0xeb6fcb75UL, 0x0001a35bUL,\n-    0x3e3a2f5fUL, 0x3c9aecf7UL, 0x3168b9aaUL, 0x0001d487UL, 0x44a6c38dUL,\n-    0x3c8a6f41UL, 0x88628cd6UL, 0x0002063bUL, 0xe3a8a894UL, 0x3c968efdUL,\n-    0x6e756238UL, 0x0002387aUL, 0x981fe7f2UL, 0x3c80472bUL, 0x65e27cddUL,\n-    0x00026b45UL, 0x6d09ab31UL, 0x3c82f7e1UL, 0xf51fdee1UL, 0x00029e9dUL,\n-    0x720c0ab3UL, 0x3c8b3782UL, 0xa6e4030bUL, 0x0002d285UL, 0x4db0abb6UL,\n-    0x3c834d75UL, 0x0a31b715UL, 0x000306feUL, 0x5dd3f84aUL, 0x3c8fdd39UL,\n-    0xb26416ffUL, 0x00033c08UL, 0xcc187d29UL, 0x3ca12f8cUL, 0x373aa9caUL,\n-    0x000371a7UL, 0x738b5e8bUL, 0x3ca7d229UL, 0x34e59ff6UL, 0x0003a7dbUL,\n-    0xa72a4c6dUL, 0x3c859f48UL, 0x4c123422UL, 0x0003dea6UL, 0x259d9205UL,\n-    0x3ca8b846UL, 0x21f72e29UL, 0x0004160aUL, 0x60c2ac12UL, 0x3c4363edUL,\n-    0x6061892dUL, 0x00044e08UL, 0xdaa10379UL, 0x3c6ecce1UL, 0xb5c13cd0UL,\n-    0x000486a2UL, 0xbb7aafb0UL, 0x3c7690ceUL, 0xd5362a27UL, 0x0004bfdaUL,\n-    0x9b282a09UL, 0x3ca083ccUL, 0x769d2ca6UL, 0x0004f9b2UL, 0xc1aae707UL,\n-    0x3ca509b0UL, 0x569d4f81UL, 0x0005342bUL, 0x18fdd78eUL, 0x3c933505UL,\n-    0x36b527daUL, 0x00056f47UL, 0xe21c5409UL, 0x3c9063e1UL, 0xdd485429UL,\n-    0x0005ab07UL, 0x2b64c035UL, 0x3c9432e6UL, 0x15ad2148UL, 0x0005e76fUL,\n-    0x99f08c0aUL, 0x3ca01284UL, 0xb03a5584UL, 0x0006247eUL, 0x0073dc06UL,\n-    0x3c99f087UL, 0x82552224UL, 0x00066238UL, 0x0da05571UL, 0x3c998d4dUL,\n-    0x667f3bccUL, 0x0006a09eUL, 0x86ce4786UL, 0x3ca52bb9UL, 0x3c651a2eUL,\n-    0x0006dfb2UL, 0x206f0dabUL, 0x3ca32092UL, 0xe8ec5f73UL, 0x00071f75UL,\n-    0x8e17a7a6UL, 0x3ca06122UL, 0x564267c8UL, 0x00075febUL, 0x461e9f86UL,\n-    0x3ca244acUL, 0x73eb0186UL, 0x0007a114UL, 0xabd66c55UL, 0x3c65ebe1UL,\n-    0x36cf4e62UL, 0x0007e2f3UL, 0xbbff67d0UL, 0x3c96fe9fUL, 0x994cce12UL,\n-    0x00082589UL, 0x14c801dfUL, 0x3c951f14UL, 0x9b4492ecUL, 0x000868d9UL,\n-    0xc1f0eab4UL, 0x3c8db72fUL, 0x422aa0dbUL, 0x0008ace5UL, 0x59f35f44UL,\n-    0x3c7bf683UL, 0x99157736UL, 0x0008f1aeUL, 0x9c06283cUL, 0x3ca360baUL,\n-    0xb0cdc5e4UL, 0x00093737UL, 0x20f962aaUL, 0x3c95e8d1UL, 0x9fde4e4fUL,\n-    0x00097d82UL, 0x2b91ce27UL, 0x3c71affcUL, 0x82a3f090UL, 0x0009c491UL,\n-    0x589a2ebdUL, 0x3c9b6d34UL, 0x7b5de564UL, 0x000a0c66UL, 0x9ab89880UL,\n-    0x3c95277cUL, 0xb23e255cUL, 0x000a5503UL, 0x6e735ab3UL, 0x3c846984UL,\n-    0x5579fdbfUL, 0x000a9e6bUL, 0x92cb3387UL, 0x3c8c1a77UL, 0x995ad3adUL,\n-    0x000ae89fUL, 0xdc2d1d96UL, 0x3ca22466UL, 0xb84f15faUL, 0x000b33a2UL,\n-    0xb19505aeUL, 0x3ca1112eUL, 0xf2fb5e46UL, 0x000b7f76UL, 0x0a5fddcdUL,\n-    0x3c74ffd7UL, 0x904bc1d2UL, 0x000bcc1eUL, 0x30af0cb3UL, 0x3c736eaeUL,\n-    0xdd85529cUL, 0x000c199bUL, 0xd10959acUL, 0x3c84e08fUL, 0x2e57d14bUL,\n-    0x000c67f1UL, 0x6c921968UL, 0x3c676b2cUL, 0xdcef9069UL, 0x000cb720UL,\n-    0x36df99b3UL, 0x3c937009UL, 0x4a07897bUL, 0x000d072dUL, 0xa63d07a7UL,\n-    0x3c74a385UL, 0xdcfba487UL, 0x000d5818UL, 0xd5c192acUL, 0x3c8e5a50UL,\n-    0x03db3285UL, 0x000da9e6UL, 0x1c4a9792UL, 0x3c98bb73UL, 0x337b9b5eUL,\n-    0x000dfc97UL, 0x603a88d3UL, 0x3c74b604UL, 0xe78b3ff6UL, 0x000e502eUL,\n-    0x92094926UL, 0x3c916f27UL, 0xa2a490d9UL, 0x000ea4afUL, 0x41aa2008UL,\n-    0x3c8ec3bcUL, 0xee615a27UL, 0x000efa1bUL, 0x31d185eeUL, 0x3c8a64a9UL,\n-    0x5b6e4540UL, 0x000f5076UL, 0x4d91cd9dUL, 0x3c77893bUL, 0x819e90d8UL,\n-    0x000fa7c1UL\n-};\n-\n-ATTRIBUTE_ALIGNED(16) juint _ALLONES[] =\n-{\n-    0xffffffffUL, 0xffffffffUL, 0xffffffffUL, 0xffffffffUL\n-};\n-\n-ATTRIBUTE_ALIGNED(16) juint _ebias[] =\n-{\n-    0x00000000UL, 0x3ff00000UL, 0x00000000UL, 0x3ff00000UL\n-};\n-\n-ATTRIBUTE_ALIGNED(4) juint _XMAX[] =\n-{\n-    0xffffffffUL, 0x7fefffffUL\n-};\n-\n-ATTRIBUTE_ALIGNED(4) juint _XMIN[] =\n-{\n-    0x00000000UL, 0x00100000UL\n-};\n-\n-ATTRIBUTE_ALIGNED(4) juint _INF[] =\n-{\n-    0x00000000UL, 0x7ff00000UL\n-};\n-\n-\n-\n-\/\/ Registers:\n-\/\/ input: xmm0\n-\/\/ scratch: xmm1, xmm2, xmm3, xmm4, xmm5, xmm6, xmm7\n-\/\/          rax, rdx, rcx, tmp - r11\n-\n-\/\/ Code generated by Intel C compiler for LIBM library\n-\n-void MacroAssembler::fast_exp(XMMRegister xmm0, XMMRegister xmm1, XMMRegister xmm2, XMMRegister xmm3,\n-                              XMMRegister xmm4, XMMRegister xmm5, XMMRegister xmm6, XMMRegister xmm7,\n-                              Register eax, Register ecx, Register edx, Register tmp) {\n-  Label L_2TAG_PACKET_0_0_2, L_2TAG_PACKET_1_0_2, L_2TAG_PACKET_2_0_2, L_2TAG_PACKET_3_0_2;\n-  Label L_2TAG_PACKET_4_0_2, L_2TAG_PACKET_5_0_2, L_2TAG_PACKET_6_0_2, L_2TAG_PACKET_7_0_2;\n-  Label L_2TAG_PACKET_8_0_2, L_2TAG_PACKET_9_0_2, L_2TAG_PACKET_10_0_2, L_2TAG_PACKET_11_0_2;\n-  Label L_2TAG_PACKET_12_0_2, B1_3, B1_5;\n-\n-  assert_different_registers(tmp, eax, ecx, edx);\n-\n-  address cv       = (address)_cv;\n-  address mmask    = (address)_mmask;\n-  address bias     = (address)_bias;\n-  address Tbl_addr = (address)_Tbl_addr;\n-  address ALLONES  = (address)_ALLONES;\n-  address ebias    = (address)_ebias;\n-  address XMAX     = (address)_XMAX;\n-  address XMIN     = (address)_XMIN;\n-  address INF      = (address)_INF;\n-\n-  subq(rsp, 24);\n-  movsd(Address(rsp, 8), xmm0);\n-  unpcklpd(xmm0, xmm0);\n-  movdqu(xmm1, ExternalAddress(cv),      tmp \/*rscratch*\/); \/\/ 0x652b82feUL, 0x40571547UL, 0x652b82feUL, 0x40571547UL\n-  movdqu(xmm2, ExternalAddress(cv + 16), tmp \/*rscratch*\/); \/\/ 0xfefa0000UL, 0x3f862e42UL, 0xfefa0000UL, 0x3f862e42UL\n-  movdqu(xmm3, ExternalAddress(cv + 32), tmp \/*rscratch*\/); \/\/ 0xbc9e3b3aUL, 0x3d1cf79aUL, 0xbc9e3b3aUL, 0x3d1cf79aUL\n-  movdqu(xmm6, ExternalAddress(SHIFTER), tmp \/*rscratch*\/); \/\/ 0x00000000UL, 0x43380000UL, 0x00000000UL, 0x43380000UL\n-  pextrw(eax, xmm0, 3);\n-  andl(eax, 32767);\n-  movl(edx, 16527);\n-  subl(edx, eax);\n-  subl(eax, 15504);\n-  orl(edx, eax);\n-  cmpl(edx, INT_MIN);\n-  jcc(Assembler::aboveEqual, L_2TAG_PACKET_0_0_2);\n-  mulpd(xmm1, xmm0);\n-  addpd(xmm1, xmm6);\n-  movapd(xmm7, xmm1);\n-  subpd(xmm1, xmm6);\n-  mulpd(xmm2, xmm1);\n-  movdqu(xmm4, ExternalAddress(cv + 64), tmp \/*rscratch*\/);  \/\/ 0xe3289860UL, 0x3f56c15cUL, 0x555b9e25UL, 0x3fa55555UL\n-  mulpd(xmm3, xmm1);\n-  movdqu(xmm5, ExternalAddress(cv + 80), tmp \/*rscratch*\/);  \/\/ 0xc090cf0fUL, 0x3f811115UL, 0x55548ba1UL, 0x3fc55555UL\n-  subpd(xmm0, xmm2);\n-  movdl(eax, xmm7);\n-  movl(ecx, eax);\n-  andl(ecx, 63);\n-  shll(ecx, 4);\n-  sarl(eax, 6);\n-  movl(edx, eax);\n-  movdqu(xmm6, ExternalAddress(mmask), tmp \/*rscratch*\/);    \/\/ 0xffffffc0UL, 0x00000000UL, 0xffffffc0UL, 0x00000000UL\n-  pand(xmm7, xmm6);\n-  movdqu(xmm6, ExternalAddress(bias), tmp \/*rscratch*\/);     \/\/ 0x0000ffc0UL, 0x00000000UL, 0x0000ffc0UL, 0x00000000UL\n-  paddq(xmm7, xmm6);\n-  psllq(xmm7, 46);\n-  subpd(xmm0, xmm3);\n-  lea(tmp, ExternalAddress(Tbl_addr));\n-  movdqu(xmm2, Address(ecx, tmp));\n-  mulpd(xmm4, xmm0);\n-  movapd(xmm6, xmm0);\n-  movapd(xmm1, xmm0);\n-  mulpd(xmm6, xmm6);\n-  mulpd(xmm0, xmm6);\n-  addpd(xmm5, xmm4);\n-  mulsd(xmm0, xmm6);\n-  mulpd(xmm6, ExternalAddress(cv + 48), tmp \/*rscratch*\/);     \/\/ 0xfffffffeUL, 0x3fdfffffUL, 0xfffffffeUL, 0x3fdfffffUL\n-  addsd(xmm1, xmm2);\n-  unpckhpd(xmm2, xmm2);\n-  mulpd(xmm0, xmm5);\n-  addsd(xmm1, xmm0);\n-  por(xmm2, xmm7);\n-  unpckhpd(xmm0, xmm0);\n-  addsd(xmm0, xmm1);\n-  addsd(xmm0, xmm6);\n-  addl(edx, 894);\n-  cmpl(edx, 1916);\n-  jcc(Assembler::above, L_2TAG_PACKET_1_0_2);\n-  mulsd(xmm0, xmm2);\n-  addsd(xmm0, xmm2);\n-  jmp(B1_5);\n-\n-  bind(L_2TAG_PACKET_1_0_2);\n-  xorpd(xmm3, xmm3);\n-  movdqu(xmm4, ExternalAddress(ALLONES), tmp \/*rscratch*\/);  \/\/ 0xffffffffUL, 0xffffffffUL, 0xffffffffUL, 0xffffffffUL\n-  movl(edx, -1022);\n-  subl(edx, eax);\n-  movdl(xmm5, edx);\n-  psllq(xmm4, xmm5);\n-  movl(ecx, eax);\n-  sarl(eax, 1);\n-  pinsrw(xmm3, eax, 3);\n-  movdqu(xmm6, ExternalAddress(ebias), tmp \/*rscratch*\/);    \/\/ 0x00000000UL, 0x3ff00000UL, 0x00000000UL, 0x3ff00000UL\n-  psllq(xmm3, 4);\n-  psubd(xmm2, xmm3);\n-  mulsd(xmm0, xmm2);\n-  cmpl(edx, 52);\n-  jcc(Assembler::greater, L_2TAG_PACKET_2_0_2);\n-  pand(xmm4, xmm2);\n-  paddd(xmm3, xmm6);\n-  subsd(xmm2, xmm4);\n-  addsd(xmm0, xmm2);\n-  cmpl(ecx, 1023);\n-  jcc(Assembler::greaterEqual, L_2TAG_PACKET_3_0_2);\n-  pextrw(ecx, xmm0, 3);\n-  andl(ecx, 32768);\n-  orl(edx, ecx);\n-  cmpl(edx, 0);\n-  jcc(Assembler::equal, L_2TAG_PACKET_4_0_2);\n-  movapd(xmm6, xmm0);\n-  addsd(xmm0, xmm4);\n-  mulsd(xmm0, xmm3);\n-  pextrw(ecx, xmm0, 3);\n-  andl(ecx, 32752);\n-  cmpl(ecx, 0);\n-  jcc(Assembler::equal, L_2TAG_PACKET_5_0_2);\n-  jmp(B1_5);\n-\n-  bind(L_2TAG_PACKET_5_0_2);\n-  mulsd(xmm6, xmm3);\n-  mulsd(xmm4, xmm3);\n-  movdqu(xmm0, xmm6);\n-  pxor(xmm6, xmm4);\n-  psrad(xmm6, 31);\n-  pshufd(xmm6, xmm6, 85);\n-  psllq(xmm0, 1);\n-  psrlq(xmm0, 1);\n-  pxor(xmm0, xmm6);\n-  psrlq(xmm6, 63);\n-  paddq(xmm0, xmm6);\n-  paddq(xmm0, xmm4);\n-  movl(Address(rsp, 0), 15);\n-  jmp(L_2TAG_PACKET_6_0_2);\n-\n-  bind(L_2TAG_PACKET_4_0_2);\n-  addsd(xmm0, xmm4);\n-  mulsd(xmm0, xmm3);\n-  jmp(B1_5);\n-\n-  bind(L_2TAG_PACKET_3_0_2);\n-  addsd(xmm0, xmm4);\n-  mulsd(xmm0, xmm3);\n-  pextrw(ecx, xmm0, 3);\n-  andl(ecx, 32752);\n-  cmpl(ecx, 32752);\n-  jcc(Assembler::aboveEqual, L_2TAG_PACKET_7_0_2);\n-  jmp(B1_5);\n-\n-  bind(L_2TAG_PACKET_2_0_2);\n-  paddd(xmm3, xmm6);\n-  addpd(xmm0, xmm2);\n-  mulsd(xmm0, xmm3);\n-  movl(Address(rsp, 0), 15);\n-  jmp(L_2TAG_PACKET_6_0_2);\n-\n-  bind(L_2TAG_PACKET_8_0_2);\n-  cmpl(eax, 2146435072);\n-  jcc(Assembler::aboveEqual, L_2TAG_PACKET_9_0_2);\n-  movl(eax, Address(rsp, 12));\n-  cmpl(eax, INT_MIN);\n-  jcc(Assembler::aboveEqual, L_2TAG_PACKET_10_0_2);\n-  movsd(xmm0, ExternalAddress(XMAX), tmp \/*rscratch*\/);      \/\/ 0xffffffffUL, 0x7fefffffUL\n-  mulsd(xmm0, xmm0);\n-\n-  bind(L_2TAG_PACKET_7_0_2);\n-  movl(Address(rsp, 0), 14);\n-  jmp(L_2TAG_PACKET_6_0_2);\n-\n-  bind(L_2TAG_PACKET_10_0_2);\n-  movsd(xmm0, ExternalAddress(XMIN), tmp \/*rscratch*\/);      \/\/ 0x00000000UL, 0x00100000UL\n-  mulsd(xmm0, xmm0);\n-  movl(Address(rsp, 0), 15);\n-  jmp(L_2TAG_PACKET_6_0_2);\n-\n-  bind(L_2TAG_PACKET_9_0_2);\n-  movl(edx, Address(rsp, 8));\n-  cmpl(eax, 2146435072);\n-  jcc(Assembler::above, L_2TAG_PACKET_11_0_2);\n-  cmpl(edx, 0);\n-  jcc(Assembler::notEqual, L_2TAG_PACKET_11_0_2);\n-  movl(eax, Address(rsp, 12));\n-  cmpl(eax, 2146435072);\n-  jcc(Assembler::notEqual, L_2TAG_PACKET_12_0_2);\n-  movsd(xmm0, ExternalAddress(INF), tmp \/*rscratch*\/);       \/\/ 0x00000000UL, 0x7ff00000UL\n-  jmp(B1_5);\n-\n-  bind(L_2TAG_PACKET_12_0_2);\n-  movsd(xmm0, ExternalAddress(ZERO), tmp \/*rscratch*\/);      \/\/ 0x00000000UL, 0x00000000UL\n-  jmp(B1_5);\n-\n-  bind(L_2TAG_PACKET_11_0_2);\n-  movsd(xmm0, Address(rsp, 8));\n-  addsd(xmm0, xmm0);\n-  jmp(B1_5);\n-\n-  bind(L_2TAG_PACKET_0_0_2);\n-  movl(eax, Address(rsp, 12));\n-  andl(eax, 2147483647);\n-  cmpl(eax, 1083179008);\n-  jcc(Assembler::aboveEqual, L_2TAG_PACKET_8_0_2);\n-  movsd(Address(rsp, 8), xmm0);\n-  addsd(xmm0, ExternalAddress(ONE), tmp \/*rscratch*\/); \/\/ 0x00000000UL, 0x3ff00000UL\n-  jmp(B1_5);\n-\n-  bind(L_2TAG_PACKET_6_0_2);\n-  movq(Address(rsp, 16), xmm0);\n-\n-  bind(B1_3);\n-  movq(xmm0, Address(rsp, 16));\n-\n-  bind(B1_5);\n-  addq(rsp, 24);\n-}\n-#else\n-\/\/ The 32 bit code is at most SSE2 compliant\n-ATTRIBUTE_ALIGNED(16) juint _static_const_table[] =\n-{\n-    0x00000000UL, 0xfff00000UL, 0x00000000UL, 0xfff00000UL, 0xffffffc0UL,\n-    0x00000000UL, 0xffffffc0UL, 0x00000000UL, 0x0000ffc0UL, 0x00000000UL,\n-    0x0000ffc0UL, 0x00000000UL, 0x00000000UL, 0x43380000UL, 0x00000000UL,\n-    0x43380000UL, 0x652b82feUL, 0x40571547UL, 0x652b82feUL, 0x40571547UL,\n-    0xfefa0000UL, 0x3f862e42UL, 0xfefa0000UL, 0x3f862e42UL, 0xbc9e3b3aUL,\n-    0x3d1cf79aUL, 0xbc9e3b3aUL, 0x3d1cf79aUL, 0xfffffffeUL, 0x3fdfffffUL,\n-    0xfffffffeUL, 0x3fdfffffUL, 0xe3289860UL, 0x3f56c15cUL, 0x555b9e25UL,\n-    0x3fa55555UL, 0xc090cf0fUL, 0x3f811115UL, 0x55548ba1UL, 0x3fc55555UL,\n-    0x00000000UL, 0x00000000UL, 0x00000000UL, 0x00000000UL, 0x0e03754dUL,\n-    0x3cad7bbfUL, 0x3e778060UL, 0x00002c9aUL, 0x3567f613UL, 0x3c8cd252UL,\n-    0xd3158574UL, 0x000059b0UL, 0x61e6c861UL, 0x3c60f74eUL, 0x18759bc8UL,\n-    0x00008745UL, 0x5d837b6cUL, 0x3c979aa6UL, 0x6cf9890fUL, 0x0000b558UL,\n-    0x702f9cd1UL, 0x3c3ebe3dUL, 0x32d3d1a2UL, 0x0000e3ecUL, 0x1e63bcd8UL,\n-    0x3ca3516eUL, 0xd0125b50UL, 0x00011301UL, 0x26f0387bUL, 0x3ca4c554UL,\n-    0xaea92ddfUL, 0x0001429aUL, 0x62523fb6UL, 0x3ca95153UL, 0x3c7d517aUL,\n-    0x000172b8UL, 0x3f1353bfUL, 0x3c8b898cUL, 0xeb6fcb75UL, 0x0001a35bUL,\n-    0x3e3a2f5fUL, 0x3c9aecf7UL, 0x3168b9aaUL, 0x0001d487UL, 0x44a6c38dUL,\n-    0x3c8a6f41UL, 0x88628cd6UL, 0x0002063bUL, 0xe3a8a894UL, 0x3c968efdUL,\n-    0x6e756238UL, 0x0002387aUL, 0x981fe7f2UL, 0x3c80472bUL, 0x65e27cddUL,\n-    0x00026b45UL, 0x6d09ab31UL, 0x3c82f7e1UL, 0xf51fdee1UL, 0x00029e9dUL,\n-    0x720c0ab3UL, 0x3c8b3782UL, 0xa6e4030bUL, 0x0002d285UL, 0x4db0abb6UL,\n-    0x3c834d75UL, 0x0a31b715UL, 0x000306feUL, 0x5dd3f84aUL, 0x3c8fdd39UL,\n-    0xb26416ffUL, 0x00033c08UL, 0xcc187d29UL, 0x3ca12f8cUL, 0x373aa9caUL,\n-    0x000371a7UL, 0x738b5e8bUL, 0x3ca7d229UL, 0x34e59ff6UL, 0x0003a7dbUL,\n-    0xa72a4c6dUL, 0x3c859f48UL, 0x4c123422UL, 0x0003dea6UL, 0x259d9205UL,\n-    0x3ca8b846UL, 0x21f72e29UL, 0x0004160aUL, 0x60c2ac12UL, 0x3c4363edUL,\n-    0x6061892dUL, 0x00044e08UL, 0xdaa10379UL, 0x3c6ecce1UL, 0xb5c13cd0UL,\n-    0x000486a2UL, 0xbb7aafb0UL, 0x3c7690ceUL, 0xd5362a27UL, 0x0004bfdaUL,\n-    0x9b282a09UL, 0x3ca083ccUL, 0x769d2ca6UL, 0x0004f9b2UL, 0xc1aae707UL,\n-    0x3ca509b0UL, 0x569d4f81UL, 0x0005342bUL, 0x18fdd78eUL, 0x3c933505UL,\n-    0x36b527daUL, 0x00056f47UL, 0xe21c5409UL, 0x3c9063e1UL, 0xdd485429UL,\n-    0x0005ab07UL, 0x2b64c035UL, 0x3c9432e6UL, 0x15ad2148UL, 0x0005e76fUL,\n-    0x99f08c0aUL, 0x3ca01284UL, 0xb03a5584UL, 0x0006247eUL, 0x0073dc06UL,\n-    0x3c99f087UL, 0x82552224UL, 0x00066238UL, 0x0da05571UL, 0x3c998d4dUL,\n-    0x667f3bccUL, 0x0006a09eUL, 0x86ce4786UL, 0x3ca52bb9UL, 0x3c651a2eUL,\n-    0x0006dfb2UL, 0x206f0dabUL, 0x3ca32092UL, 0xe8ec5f73UL, 0x00071f75UL,\n-    0x8e17a7a6UL, 0x3ca06122UL, 0x564267c8UL, 0x00075febUL, 0x461e9f86UL,\n-    0x3ca244acUL, 0x73eb0186UL, 0x0007a114UL, 0xabd66c55UL, 0x3c65ebe1UL,\n-    0x36cf4e62UL, 0x0007e2f3UL, 0xbbff67d0UL, 0x3c96fe9fUL, 0x994cce12UL,\n-    0x00082589UL, 0x14c801dfUL, 0x3c951f14UL, 0x9b4492ecUL, 0x000868d9UL,\n-    0xc1f0eab4UL, 0x3c8db72fUL, 0x422aa0dbUL, 0x0008ace5UL, 0x59f35f44UL,\n-    0x3c7bf683UL, 0x99157736UL, 0x0008f1aeUL, 0x9c06283cUL, 0x3ca360baUL,\n-    0xb0cdc5e4UL, 0x00093737UL, 0x20f962aaUL, 0x3c95e8d1UL, 0x9fde4e4fUL,\n-    0x00097d82UL, 0x2b91ce27UL, 0x3c71affcUL, 0x82a3f090UL, 0x0009c491UL,\n-    0x589a2ebdUL, 0x3c9b6d34UL, 0x7b5de564UL, 0x000a0c66UL, 0x9ab89880UL,\n-    0x3c95277cUL, 0xb23e255cUL, 0x000a5503UL, 0x6e735ab3UL, 0x3c846984UL,\n-    0x5579fdbfUL, 0x000a9e6bUL, 0x92cb3387UL, 0x3c8c1a77UL, 0x995ad3adUL,\n-    0x000ae89fUL, 0xdc2d1d96UL, 0x3ca22466UL, 0xb84f15faUL, 0x000b33a2UL,\n-    0xb19505aeUL, 0x3ca1112eUL, 0xf2fb5e46UL, 0x000b7f76UL, 0x0a5fddcdUL,\n-    0x3c74ffd7UL, 0x904bc1d2UL, 0x000bcc1eUL, 0x30af0cb3UL, 0x3c736eaeUL,\n-    0xdd85529cUL, 0x000c199bUL, 0xd10959acUL, 0x3c84e08fUL, 0x2e57d14bUL,\n-    0x000c67f1UL, 0x6c921968UL, 0x3c676b2cUL, 0xdcef9069UL, 0x000cb720UL,\n-    0x36df99b3UL, 0x3c937009UL, 0x4a07897bUL, 0x000d072dUL, 0xa63d07a7UL,\n-    0x3c74a385UL, 0xdcfba487UL, 0x000d5818UL, 0xd5c192acUL, 0x3c8e5a50UL,\n-    0x03db3285UL, 0x000da9e6UL, 0x1c4a9792UL, 0x3c98bb73UL, 0x337b9b5eUL,\n-    0x000dfc97UL, 0x603a88d3UL, 0x3c74b604UL, 0xe78b3ff6UL, 0x000e502eUL,\n-    0x92094926UL, 0x3c916f27UL, 0xa2a490d9UL, 0x000ea4afUL, 0x41aa2008UL,\n-    0x3c8ec3bcUL, 0xee615a27UL, 0x000efa1bUL, 0x31d185eeUL, 0x3c8a64a9UL,\n-    0x5b6e4540UL, 0x000f5076UL, 0x4d91cd9dUL, 0x3c77893bUL, 0x819e90d8UL,\n-    0x000fa7c1UL, 0x00000000UL, 0x3ff00000UL, 0x00000000UL, 0x7ff00000UL,\n-    0x00000000UL, 0x00000000UL, 0xffffffffUL, 0x7fefffffUL, 0x00000000UL,\n-    0x00100000UL\n-};\n-\n-\/\/registers,\n-\/\/ input: (rbp + 8)\n-\/\/ scratch: xmm1, xmm2, xmm3, xmm4, xmm5, xmm6, xmm7\n-\/\/          rax, rdx, rcx, rbx (tmp)\n-\n-\/\/ Code generated by Intel C compiler for LIBM library\n-\n-void MacroAssembler::fast_exp(XMMRegister xmm0, XMMRegister xmm1, XMMRegister xmm2, XMMRegister xmm3,\n-                              XMMRegister xmm4, XMMRegister xmm5, XMMRegister xmm6, XMMRegister xmm7,\n-                              Register eax, Register ecx, Register edx, Register tmp) {\n-  Label L_2TAG_PACKET_0_0_2, L_2TAG_PACKET_1_0_2, L_2TAG_PACKET_2_0_2, L_2TAG_PACKET_3_0_2;\n-  Label L_2TAG_PACKET_4_0_2, L_2TAG_PACKET_5_0_2, L_2TAG_PACKET_6_0_2, L_2TAG_PACKET_7_0_2;\n-  Label L_2TAG_PACKET_8_0_2, L_2TAG_PACKET_9_0_2, L_2TAG_PACKET_10_0_2, L_2TAG_PACKET_11_0_2;\n-  Label L_2TAG_PACKET_12_0_2;\n-\n-  assert_different_registers(tmp, eax, ecx, edx);\n-  address static_const_table = (address)_static_const_table;\n-\n-  subl(rsp, 120);\n-  movl(Address(rsp, 64), tmp);\n-  lea(tmp, ExternalAddress(static_const_table));\n-  movsd(xmm0, Address(rsp, 128));\n-  unpcklpd(xmm0, xmm0);\n-  movdqu(xmm1, Address(tmp, 64));          \/\/ 0x652b82feUL, 0x40571547UL, 0x652b82feUL, 0x40571547UL\n-  movdqu(xmm6, Address(tmp, 48));          \/\/ 0x00000000UL, 0x43380000UL, 0x00000000UL, 0x43380000UL\n-  movdqu(xmm2, Address(tmp, 80));          \/\/ 0xfefa0000UL, 0x3f862e42UL, 0xfefa0000UL, 0x3f862e42UL\n-  movdqu(xmm3, Address(tmp, 96));          \/\/ 0xbc9e3b3aUL, 0x3d1cf79aUL, 0xbc9e3b3aUL, 0x3d1cf79aUL\n-  pextrw(eax, xmm0, 3);\n-  andl(eax, 32767);\n-  movl(edx, 16527);\n-  subl(edx, eax);\n-  subl(eax, 15504);\n-  orl(edx, eax);\n-  cmpl(edx, INT_MIN);\n-  jcc(Assembler::aboveEqual, L_2TAG_PACKET_0_0_2);\n-  mulpd(xmm1, xmm0);\n-  addpd(xmm1, xmm6);\n-  movapd(xmm7, xmm1);\n-  subpd(xmm1, xmm6);\n-  mulpd(xmm2, xmm1);\n-  movdqu(xmm4, Address(tmp, 128));         \/\/ 0xe3289860UL, 0x3f56c15cUL, 0x555b9e25UL, 0x3fa55555UL\n-  mulpd(xmm3, xmm1);\n-  movdqu(xmm5, Address(tmp, 144));         \/\/ 0xc090cf0fUL, 0x3f811115UL, 0x55548ba1UL, 0x3fc55555UL\n-  subpd(xmm0, xmm2);\n-  movdl(eax, xmm7);\n-  movl(ecx, eax);\n-  andl(ecx, 63);\n-  shll(ecx, 4);\n-  sarl(eax, 6);\n-  movl(edx, eax);\n-  movdqu(xmm6, Address(tmp, 16));          \/\/ 0xffffffc0UL, 0x00000000UL, 0xffffffc0UL, 0x00000000UL\n-  pand(xmm7, xmm6);\n-  movdqu(xmm6, Address(tmp, 32));          \/\/ 0x0000ffc0UL, 0x00000000UL, 0x0000ffc0UL, 0x00000000UL\n-  paddq(xmm7, xmm6);\n-  psllq(xmm7, 46);\n-  subpd(xmm0, xmm3);\n-  movdqu(xmm2, Address(tmp, ecx, Address::times_1, 160));\n-  mulpd(xmm4, xmm0);\n-  movapd(xmm6, xmm0);\n-  movapd(xmm1, xmm0);\n-  mulpd(xmm6, xmm6);\n-  mulpd(xmm0, xmm6);\n-  addpd(xmm5, xmm4);\n-  mulsd(xmm0, xmm6);\n-  mulpd(xmm6, Address(tmp, 112));          \/\/ 0xfffffffeUL, 0x3fdfffffUL, 0xfffffffeUL, 0x3fdfffffUL\n-  addsd(xmm1, xmm2);\n-  unpckhpd(xmm2, xmm2);\n-  mulpd(xmm0, xmm5);\n-  addsd(xmm1, xmm0);\n-  por(xmm2, xmm7);\n-  unpckhpd(xmm0, xmm0);\n-  addsd(xmm0, xmm1);\n-  addsd(xmm0, xmm6);\n-  addl(edx, 894);\n-  cmpl(edx, 1916);\n-  jcc(Assembler::above, L_2TAG_PACKET_1_0_2);\n-  mulsd(xmm0, xmm2);\n-  addsd(xmm0, xmm2);\n-  jmp(L_2TAG_PACKET_2_0_2);\n-\n-  bind(L_2TAG_PACKET_1_0_2);\n-  fnstcw(Address(rsp, 24));\n-  movzwl(edx, Address(rsp, 24));\n-  orl(edx, 768);\n-  movw(Address(rsp, 28), edx);\n-  fldcw(Address(rsp, 28));\n-  movl(edx, eax);\n-  sarl(eax, 1);\n-  subl(edx, eax);\n-  movdqu(xmm6, Address(tmp, 0));           \/\/ 0x00000000UL, 0xfff00000UL, 0x00000000UL, 0xfff00000UL\n-  pandn(xmm6, xmm2);\n-  addl(eax, 1023);\n-  movdl(xmm3, eax);\n-  psllq(xmm3, 52);\n-  por(xmm6, xmm3);\n-  addl(edx, 1023);\n-  movdl(xmm4, edx);\n-  psllq(xmm4, 52);\n-  movsd(Address(rsp, 8), xmm0);\n-  fld_d(Address(rsp, 8));\n-  movsd(Address(rsp, 16), xmm6);\n-  fld_d(Address(rsp, 16));\n-  fmula(1);\n-  faddp(1);\n-  movsd(Address(rsp, 8), xmm4);\n-  fld_d(Address(rsp, 8));\n-  fmulp(1);\n-  fstp_d(Address(rsp, 8));\n-  movsd(xmm0, Address(rsp, 8));\n-  fldcw(Address(rsp, 24));\n-  pextrw(ecx, xmm0, 3);\n-  andl(ecx, 32752);\n-  cmpl(ecx, 32752);\n-  jcc(Assembler::aboveEqual, L_2TAG_PACKET_3_0_2);\n-  cmpl(ecx, 0);\n-  jcc(Assembler::equal, L_2TAG_PACKET_4_0_2);\n-  jmp(L_2TAG_PACKET_2_0_2);\n-  cmpl(ecx, INT_MIN);\n-  jcc(Assembler::below, L_2TAG_PACKET_3_0_2);\n-  cmpl(ecx, -1064950997);\n-  jcc(Assembler::below, L_2TAG_PACKET_2_0_2);\n-  jcc(Assembler::above, L_2TAG_PACKET_4_0_2);\n-  movl(edx, Address(rsp, 128));\n-  cmpl(edx, -17155601);\n-  jcc(Assembler::below, L_2TAG_PACKET_2_0_2);\n-  jmp(L_2TAG_PACKET_4_0_2);\n-\n-  bind(L_2TAG_PACKET_3_0_2);\n-  movl(edx, 14);\n-  jmp(L_2TAG_PACKET_5_0_2);\n-\n-  bind(L_2TAG_PACKET_4_0_2);\n-  movl(edx, 15);\n-\n-  bind(L_2TAG_PACKET_5_0_2);\n-  movsd(Address(rsp, 0), xmm0);\n-  movsd(xmm0, Address(rsp, 128));\n-  fld_d(Address(rsp, 0));\n-  jmp(L_2TAG_PACKET_6_0_2);\n-\n-  bind(L_2TAG_PACKET_7_0_2);\n-  cmpl(eax, 2146435072);\n-  jcc(Assembler::aboveEqual, L_2TAG_PACKET_8_0_2);\n-  movl(eax, Address(rsp, 132));\n-  cmpl(eax, INT_MIN);\n-  jcc(Assembler::aboveEqual, L_2TAG_PACKET_9_0_2);\n-  movsd(xmm0, Address(tmp, 1208));         \/\/ 0xffffffffUL, 0x7fefffffUL\n-  mulsd(xmm0, xmm0);\n-  movl(edx, 14);\n-  jmp(L_2TAG_PACKET_5_0_2);\n-\n-  bind(L_2TAG_PACKET_9_0_2);\n-  movsd(xmm0, Address(tmp, 1216));\n-  mulsd(xmm0, xmm0);\n-  movl(edx, 15);\n-  jmp(L_2TAG_PACKET_5_0_2);\n-\n-  bind(L_2TAG_PACKET_8_0_2);\n-  movl(edx, Address(rsp, 128));\n-  cmpl(eax, 2146435072);\n-  jcc(Assembler::above, L_2TAG_PACKET_10_0_2);\n-  cmpl(edx, 0);\n-  jcc(Assembler::notEqual, L_2TAG_PACKET_10_0_2);\n-  movl(eax, Address(rsp, 132));\n-  cmpl(eax, 2146435072);\n-  jcc(Assembler::notEqual, L_2TAG_PACKET_11_0_2);\n-  movsd(xmm0, Address(tmp, 1192));         \/\/ 0x00000000UL, 0x7ff00000UL\n-  jmp(L_2TAG_PACKET_2_0_2);\n-\n-  bind(L_2TAG_PACKET_11_0_2);\n-  movsd(xmm0, Address(tmp, 1200));         \/\/ 0x00000000UL, 0x00000000UL\n-  jmp(L_2TAG_PACKET_2_0_2);\n-\n-  bind(L_2TAG_PACKET_10_0_2);\n-  movsd(xmm0, Address(rsp, 128));\n-  addsd(xmm0, xmm0);\n-  jmp(L_2TAG_PACKET_2_0_2);\n-\n-  bind(L_2TAG_PACKET_0_0_2);\n-  movl(eax, Address(rsp, 132));\n-  andl(eax, 2147483647);\n-  cmpl(eax, 1083179008);\n-  jcc(Assembler::aboveEqual, L_2TAG_PACKET_7_0_2);\n-  movsd(xmm0, Address(rsp, 128));\n-  addsd(xmm0, Address(tmp, 1184));         \/\/ 0x00000000UL, 0x3ff00000UL\n-  jmp(L_2TAG_PACKET_2_0_2);\n-\n-  bind(L_2TAG_PACKET_2_0_2);\n-  movsd(Address(rsp, 48), xmm0);\n-  fld_d(Address(rsp, 48));\n-\n-  bind(L_2TAG_PACKET_6_0_2);\n-  movl(tmp, Address(rsp, 64));\n-}\n-#endif\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86_exp.cpp","additions":0,"deletions":654,"binary":false,"changes":654,"status":"deleted"},{"patch":"@@ -1,651 +0,0 @@\n-\/*\n-* Copyright (c) 2016, 2021, Intel Corporation. All rights reserved.\n-* Copyright (C) 2021 THL A29 Limited, a Tencent company. All rights reserved.\n-* Intel Math Library (LIBM) Source Code\n-*\n-* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-*\n-* This code is free software; you can redistribute it and\/or modify it\n-* under the terms of the GNU General Public License version 2 only, as\n-* published by the Free Software Foundation.\n-*\n-* This code is distributed in the hope that it will be useful, but WITHOUT\n-* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-* FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-* version 2 for more details (a copy is included in the LICENSE file that\n-* accompanied this code).\n-*\n-* You should have received a copy of the GNU General Public License version\n-* 2 along with this work; if not, write to the Free Software Foundation,\n-* Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-*\n-* Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-* or visit www.oracle.com if you need additional information or have any\n-* questions.\n-*\n-*\/\n-\n-#include \"precompiled.hpp\"\n-#include \"asm\/assembler.hpp\"\n-#include \"asm\/assembler.inline.hpp\"\n-#include \"macroAssembler_x86.hpp\"\n-#include \"utilities\/globalDefinitions.hpp\"\n-\n-\/******************************************************************************\/\n-\/\/                     ALGORITHM DESCRIPTION - LOG()\n-\/\/                     ---------------------\n-\/\/\n-\/\/    x=2^k * mx, mx in [1,2)\n-\/\/\n-\/\/    Get B~1\/mx based on the output of rcpss instruction (B0)\n-\/\/    B = int((B0*2^7+0.5))\/2^7\n-\/\/\n-\/\/    Reduced argument: r=B*mx-1.0 (computed accurately in high and low parts)\n-\/\/\n-\/\/    Result:  k*log(2) - log(B) + p(r) if |x-1| >= small value (2^-6)  and\n-\/\/             p(r) is a degree 7 polynomial\n-\/\/             -log(B) read from data table (high, low parts)\n-\/\/             Result is formed from high and low parts\n-\/\/\n-\/\/ Special cases:\n-\/\/  log(NaN) = quiet NaN, and raise invalid exception\n-\/\/  log(+INF) = that INF\n-\/\/  log(0) = -INF with divide-by-zero exception raised\n-\/\/  log(1) = +0\n-\/\/  log(x) = NaN with invalid exception raised if x < -0, including -INF\n-\/\/\n-\/******************************************************************************\/\n-\n-#ifdef _LP64\n-\/\/ The 64 bit code is at most SSE2 compliant\n-ATTRIBUTE_ALIGNED(16) juint _L_tbl[] =\n-{\n-    0xfefa3800UL, 0x3fe62e42UL, 0x93c76730UL, 0x3d2ef357UL, 0xaa241800UL,\n-    0x3fe5ee82UL, 0x0cda46beUL, 0x3d220238UL, 0x5c364800UL, 0x3fe5af40UL,\n-    0xac10c9fbUL, 0x3d2dfa63UL, 0x26bb8c00UL, 0x3fe5707aUL, 0xff3303ddUL,\n-    0x3d09980bUL, 0x26867800UL, 0x3fe5322eUL, 0x5d257531UL, 0x3d05ccc4UL,\n-    0x835a5000UL, 0x3fe4f45aUL, 0x6d93b8fbUL, 0xbd2e6c51UL, 0x6f970c00UL,\n-    0x3fe4b6fdUL, 0xed4c541cUL, 0x3cef7115UL, 0x27e8a400UL, 0x3fe47a15UL,\n-    0xf94d60aaUL, 0xbd22cb6aUL, 0xf2f92400UL, 0x3fe43d9fUL, 0x481051f7UL,\n-    0xbcfd984fUL, 0x2125cc00UL, 0x3fe4019cUL, 0x30f0c74cUL, 0xbd26ce79UL,\n-    0x0c36c000UL, 0x3fe3c608UL, 0x7cfe13c2UL, 0xbd02b736UL, 0x17197800UL,\n-    0x3fe38ae2UL, 0xbb5569a4UL, 0xbd218b7aUL, 0xad9d8c00UL, 0x3fe35028UL,\n-    0x9527e6acUL, 0x3d10b83fUL, 0x44340800UL, 0x3fe315daUL, 0xc5a0ed9cUL,\n-    0xbd274e93UL, 0x57b0e000UL, 0x3fe2dbf5UL, 0x07b9dc11UL, 0xbd17a6e5UL,\n-    0x6d0ec000UL, 0x3fe2a278UL, 0xe797882dUL, 0x3d206d2bUL, 0x1134dc00UL,\n-    0x3fe26962UL, 0x05226250UL, 0xbd0b61f1UL, 0xd8bebc00UL, 0x3fe230b0UL,\n-    0x6e48667bUL, 0x3d12fc06UL, 0x5fc61800UL, 0x3fe1f863UL, 0xc9fe81d3UL,\n-    0xbd2a7242UL, 0x49ae6000UL, 0x3fe1c078UL, 0xed70e667UL, 0x3cccacdeUL,\n-    0x40f23c00UL, 0x3fe188eeUL, 0xf8ab4650UL, 0x3d14cc4eUL, 0xf6f29800UL,\n-    0x3fe151c3UL, 0xa293ae49UL, 0xbd2edd97UL, 0x23c75c00UL, 0x3fe11af8UL,\n-    0xbb9ddcb2UL, 0xbd258647UL, 0x8611cc00UL, 0x3fe0e489UL, 0x07801742UL,\n-    0x3d1c2998UL, 0xe2d05400UL, 0x3fe0ae76UL, 0x887e7e27UL, 0x3d1f486bUL,\n-    0x0533c400UL, 0x3fe078bfUL, 0x41edf5fdUL, 0x3d268122UL, 0xbe760400UL,\n-    0x3fe04360UL, 0xe79539e0UL, 0xbd04c45fUL, 0xe5b20800UL, 0x3fe00e5aUL,\n-    0xb1727b1cUL, 0xbd053ba3UL, 0xaf7a4800UL, 0x3fdfb358UL, 0x3c164935UL,\n-    0x3d0085faUL, 0xee031800UL, 0x3fdf4aa7UL, 0x6f014a8bUL, 0x3d12cde5UL,\n-    0x56b41000UL, 0x3fdee2a1UL, 0x5a470251UL, 0x3d2f27f4UL, 0xc3ddb000UL,\n-    0x3fde7b42UL, 0x5372bd08UL, 0xbd246550UL, 0x1a272800UL, 0x3fde148aUL,\n-    0x07322938UL, 0xbd1326b2UL, 0x484c9800UL, 0x3fddae75UL, 0x60dc616aUL,\n-    0xbd1ea42dUL, 0x46def800UL, 0x3fdd4902UL, 0xe9a767a8UL, 0x3d235bafUL,\n-    0x18064800UL, 0x3fdce42fUL, 0x3ec7a6b0UL, 0xbd0797c3UL, 0xc7455800UL,\n-    0x3fdc7ff9UL, 0xc15249aeUL, 0xbd29b6ddUL, 0x693fa000UL, 0x3fdc1c60UL,\n-    0x7fe8e180UL, 0x3d2cec80UL, 0x1b80e000UL, 0x3fdbb961UL, 0xf40a666dUL,\n-    0x3d27d85bUL, 0x04462800UL, 0x3fdb56faUL, 0x2d841995UL, 0x3d109525UL,\n-    0x5248d000UL, 0x3fdaf529UL, 0x52774458UL, 0xbd217cc5UL, 0x3c8ad800UL,\n-    0x3fda93edUL, 0xbea77a5dUL, 0x3d1e36f2UL, 0x0224f800UL, 0x3fda3344UL,\n-    0x7f9d79f5UL, 0x3d23c645UL, 0xea15f000UL, 0x3fd9d32bUL, 0x10d0c0b0UL,\n-    0xbd26279eUL, 0x43135800UL, 0x3fd973a3UL, 0xa502d9f0UL, 0xbd152313UL,\n-    0x635bf800UL, 0x3fd914a8UL, 0x2ee6307dUL, 0xbd1766b5UL, 0xa88b3000UL,\n-    0x3fd8b639UL, 0xe5e70470UL, 0xbd205ae1UL, 0x776dc800UL, 0x3fd85855UL,\n-    0x3333778aUL, 0x3d2fd56fUL, 0x3bd81800UL, 0x3fd7fafaUL, 0xc812566aUL,\n-    0xbd272090UL, 0x687cf800UL, 0x3fd79e26UL, 0x2efd1778UL, 0x3d29ec7dUL,\n-    0x76c67800UL, 0x3fd741d8UL, 0x49dc60b3UL, 0x3d2d8b09UL, 0xe6af1800UL,\n-    0x3fd6e60eUL, 0x7c222d87UL, 0x3d172165UL, 0x3e9c6800UL, 0x3fd68ac8UL,\n-    0x2756eba0UL, 0x3d20a0d3UL, 0x0b3ab000UL, 0x3fd63003UL, 0xe731ae00UL,\n-    0xbd2db623UL, 0xdf596000UL, 0x3fd5d5bdUL, 0x08a465dcUL, 0xbd0a0b2aUL,\n-    0x53c8d000UL, 0x3fd57bf7UL, 0xee5d40efUL, 0x3d1fadedUL, 0x0738a000UL,\n-    0x3fd522aeUL, 0x8164c759UL, 0x3d2ebe70UL, 0x9e173000UL, 0x3fd4c9e0UL,\n-    0x1b0ad8a4UL, 0xbd2e2089UL, 0xc271c800UL, 0x3fd4718dUL, 0x0967d675UL,\n-    0xbd2f27ceUL, 0x23d5e800UL, 0x3fd419b4UL, 0xec90e09dUL, 0x3d08e436UL,\n-    0x77333000UL, 0x3fd3c252UL, 0xb606bd5cUL, 0x3d183b54UL, 0x76be1000UL,\n-    0x3fd36b67UL, 0xb0f177c8UL, 0x3d116ecdUL, 0xe1d36000UL, 0x3fd314f1UL,\n-    0xd3213cb8UL, 0xbd28e27aUL, 0x7cdc9000UL, 0x3fd2bef0UL, 0x4a5004f4UL,\n-    0x3d2a9cfaUL, 0x1134d800UL, 0x3fd26962UL, 0xdf5bb3b6UL, 0x3d2c93c1UL,\n-    0x6d0eb800UL, 0x3fd21445UL, 0xba46baeaUL, 0x3d0a87deUL, 0x635a6800UL,\n-    0x3fd1bf99UL, 0x5147bdb7UL, 0x3d2ca6edUL, 0xcbacf800UL, 0x3fd16b5cUL,\n-    0xf7a51681UL, 0x3d2b9acdUL, 0x8227e800UL, 0x3fd1178eUL, 0x63a5f01cUL,\n-    0xbd2c210eUL, 0x67616000UL, 0x3fd0c42dUL, 0x163ceae9UL, 0x3d27188bUL,\n-    0x604d5800UL, 0x3fd07138UL, 0x16ed4e91UL, 0x3cf89cdbUL, 0x5626c800UL,\n-    0x3fd01eaeUL, 0x1485e94aUL, 0xbd16f08cUL, 0x6cb3b000UL, 0x3fcf991cUL,\n-    0xca0cdf30UL, 0x3d1bcbecUL, 0xe4dd0000UL, 0x3fcef5adUL, 0x65bb8e11UL,\n-    0xbcca2115UL, 0xffe71000UL, 0x3fce530eUL, 0x6041f430UL, 0x3cc21227UL,\n-    0xb0d49000UL, 0x3fcdb13dUL, 0xf715b035UL, 0xbd2aff2aUL, 0xf2656000UL,\n-    0x3fcd1037UL, 0x75b6f6e4UL, 0xbd084a7eUL, 0xc6f01000UL, 0x3fcc6ffbUL,\n-    0xc5962bd2UL, 0xbcf1ec72UL, 0x383be000UL, 0x3fcbd087UL, 0x595412b6UL,\n-    0xbd2d4bc4UL, 0x575bd000UL, 0x3fcb31d8UL, 0x4eace1aaUL, 0xbd0c358dUL,\n-    0x3c8ae000UL, 0x3fca93edUL, 0x50562169UL, 0xbd287243UL, 0x07089000UL,\n-    0x3fc9f6c4UL, 0x6865817aUL, 0x3d29904dUL, 0xdcf70000UL, 0x3fc95a5aUL,\n-    0x58a0ff6fUL, 0x3d07f228UL, 0xeb390000UL, 0x3fc8beafUL, 0xaae92cd1UL,\n-    0xbd073d54UL, 0x6551a000UL, 0x3fc823c1UL, 0x9a631e83UL, 0x3d1e0ddbUL,\n-    0x85445000UL, 0x3fc7898dUL, 0x70914305UL, 0xbd1c6610UL, 0x8b757000UL,\n-    0x3fc6f012UL, 0xe59c21e1UL, 0xbd25118dUL, 0xbe8c1000UL, 0x3fc6574eUL,\n-    0x2c3c2e78UL, 0x3d19cf8bUL, 0x6b544000UL, 0x3fc5bf40UL, 0xeb68981cUL,\n-    0xbd127023UL, 0xe4a1b000UL, 0x3fc527e5UL, 0xe5697dc7UL, 0x3d2633e8UL,\n-    0x8333b000UL, 0x3fc4913dUL, 0x54fdb678UL, 0x3d258379UL, 0xa5993000UL,\n-    0x3fc3fb45UL, 0x7e6a354dUL, 0xbd2cd1d8UL, 0xb0159000UL, 0x3fc365fcUL,\n-    0x234b7289UL, 0x3cc62fa8UL, 0x0c868000UL, 0x3fc2d161UL, 0xcb81b4a1UL,\n-    0x3d039d6cUL, 0x2a49c000UL, 0x3fc23d71UL, 0x8fd3df5cUL, 0x3d100d23UL,\n-    0x7e23f000UL, 0x3fc1aa2bUL, 0x44389934UL, 0x3d2ca78eUL, 0x8227e000UL,\n-    0x3fc1178eUL, 0xce2d07f2UL, 0x3d21ef78UL, 0xb59e4000UL, 0x3fc08598UL,\n-    0x7009902cUL, 0xbd27e5ddUL, 0x39dbe000UL, 0x3fbfe891UL, 0x4fa10afdUL,\n-    0xbd2534d6UL, 0x830a2000UL, 0x3fbec739UL, 0xafe645e0UL, 0xbd2dc068UL,\n-    0x63844000UL, 0x3fbda727UL, 0x1fa71733UL, 0x3d1a8940UL, 0x01bc4000UL,\n-    0x3fbc8858UL, 0xc65aacd3UL, 0x3d2646d1UL, 0x8dad6000UL, 0x3fbb6ac8UL,\n-    0x2bf768e5UL, 0xbd139080UL, 0x40b1c000UL, 0x3fba4e76UL, 0xb94407c8UL,\n-    0xbd0e42b6UL, 0x5d594000UL, 0x3fb9335eUL, 0x3abd47daUL, 0x3d23115cUL,\n-    0x2f40e000UL, 0x3fb8197eUL, 0xf96ffdf7UL, 0x3d0f80dcUL, 0x0aeac000UL,\n-    0x3fb700d3UL, 0xa99ded32UL, 0x3cec1e8dUL, 0x4d97a000UL, 0x3fb5e95aUL,\n-    0x3c5d1d1eUL, 0xbd2c6906UL, 0x5d208000UL, 0x3fb4d311UL, 0x82f4e1efUL,\n-    0xbcf53a25UL, 0xa7d1e000UL, 0x3fb3bdf5UL, 0xa5db4ed7UL, 0x3d2cc85eUL,\n-    0xa4472000UL, 0x3fb2aa04UL, 0xae9c697dUL, 0xbd20b6e8UL, 0xd1466000UL,\n-    0x3fb1973bUL, 0x560d9e9bUL, 0xbd25325dUL, 0xb59e4000UL, 0x3fb08598UL,\n-    0x7009902cUL, 0xbd17e5ddUL, 0xc006c000UL, 0x3faeea31UL, 0x4fc93b7bUL,\n-    0xbd0e113eUL, 0xcdddc000UL, 0x3faccb73UL, 0x47d82807UL, 0xbd1a68f2UL,\n-    0xd0fb0000UL, 0x3faaaef2UL, 0x353bb42eUL, 0x3d20fc1aUL, 0x149fc000UL,\n-    0x3fa894aaUL, 0xd05a267dUL, 0xbd197995UL, 0xf2d4c000UL, 0x3fa67c94UL,\n-    0xec19afa2UL, 0xbd029efbUL, 0xd42e0000UL, 0x3fa466aeUL, 0x75bdfd28UL,\n-    0xbd2c1673UL, 0x2f8d0000UL, 0x3fa252f3UL, 0xe021b67bUL, 0x3d283e9aUL,\n-    0x89e74000UL, 0x3fa0415dUL, 0x5cf1d753UL, 0x3d0111c0UL, 0xec148000UL,\n-    0x3f9c63d2UL, 0x3f9eb2f3UL, 0x3d2578c6UL, 0x28c90000UL, 0x3f984925UL,\n-    0x325a0c34UL, 0xbd2aa0baUL, 0x25980000UL, 0x3f9432a9UL, 0x928637feUL,\n-    0x3d098139UL, 0x58938000UL, 0x3f902056UL, 0x06e2f7d2UL, 0xbd23dc5bUL,\n-    0xa3890000UL, 0x3f882448UL, 0xda74f640UL, 0xbd275577UL, 0x75890000UL,\n-    0x3f801015UL, 0x999d2be8UL, 0xbd10c76bUL, 0x59580000UL, 0x3f700805UL,\n-    0xcb31c67bUL, 0x3d2166afUL, 0x00000000UL, 0x00000000UL, 0x00000000UL,\n-    0x80000000UL\n-};\n-\n-ATTRIBUTE_ALIGNED(16) juint _log2[] =\n-{\n-    0xfefa3800UL, 0x3fa62e42UL, 0x93c76730UL, 0x3ceef357UL\n-};\n-\n-ATTRIBUTE_ALIGNED(16) juint _coeff[] =\n-{\n-    0x92492492UL, 0x3fc24924UL, 0x00000000UL, 0xbfd00000UL, 0x3d6fb175UL,\n-    0xbfc5555eUL, 0x55555555UL, 0x3fd55555UL, 0x9999999aUL, 0x3fc99999UL,\n-    0x00000000UL, 0xbfe00000UL\n-};\n-\n-\/\/registers,\n-\/\/ input: xmm0\n-\/\/ scratch: xmm1, xmm2, xmm3, xmm4, xmm5, xmm6, xmm7\n-\/\/          rax, rdx, rcx, r8, r11\n-\n-void MacroAssembler::fast_log(XMMRegister xmm0, XMMRegister xmm1, XMMRegister xmm2, XMMRegister xmm3,\n-                              XMMRegister xmm4, XMMRegister xmm5, XMMRegister xmm6, XMMRegister xmm7,\n-                              Register eax, Register ecx, Register edx, Register tmp1, Register tmp2) {\n-  Label L_2TAG_PACKET_0_0_2, L_2TAG_PACKET_1_0_2, L_2TAG_PACKET_2_0_2, L_2TAG_PACKET_3_0_2;\n-  Label L_2TAG_PACKET_4_0_2, L_2TAG_PACKET_5_0_2, L_2TAG_PACKET_6_0_2, L_2TAG_PACKET_7_0_2;\n-  Label L_2TAG_PACKET_8_0_2;\n-  Label B1_3, B1_5;\n-\n-  assert_different_registers(tmp1, tmp2, eax, ecx, edx);\n-  address L_tbl = (address)_L_tbl;\n-  address log2  = (address)_log2;\n-  address coeff = (address)_coeff;\n-\n-  subq(rsp, 24);\n-  movsd(Address(rsp, 0), xmm0);\n-  mov64(rax, 0x3ff0000000000000);\n-  movdq(xmm2, rax);\n-  mov64(rdx, 0x77f0000000000000);\n-  movdq(xmm3, rdx);\n-  movl(ecx, 32768);\n-  movdl(xmm4, rcx);\n-  mov64(tmp1, 0xffffe00000000000);\n-  movdq(xmm5, tmp1);\n-  movdqu(xmm1, xmm0);\n-  pextrw(eax, xmm0, 3);\n-  por(xmm0, xmm2);\n-  movl(ecx, 16352);\n-  psrlq(xmm0, 27);\n-  lea(tmp2, ExternalAddress(L_tbl));\n-  psrld(xmm0, 2);\n-  rcpps(xmm0, xmm0);\n-  psllq(xmm1, 12);\n-  pshufd(xmm6, xmm5, 228);\n-  psrlq(xmm1, 12);\n-  subl(eax, 16);\n-  cmpl(eax, 32736);\n-  jcc(Assembler::aboveEqual, L_2TAG_PACKET_0_0_2);\n-\n-  bind(L_2TAG_PACKET_1_0_2);\n-  paddd(xmm0, xmm4);\n-  por(xmm1, xmm3);\n-  movdl(edx, xmm0);\n-  psllq(xmm0, 29);\n-  pand(xmm5, xmm1);\n-  pand(xmm0, xmm6);\n-  subsd(xmm1, xmm5);\n-  mulpd(xmm5, xmm0);\n-  andl(eax, 32752);\n-  subl(eax, ecx);\n-  cvtsi2sdl(xmm7, eax);\n-  mulsd(xmm1, xmm0);\n-  movq(xmm6, ExternalAddress(log2), tmp1 \/*rscratch*\/);       \/\/ 0xfefa3800UL, 0x3fa62e42UL\n-  movdqu(xmm3, ExternalAddress(coeff), tmp1 \/*rscratch*\/);    \/\/ 0x92492492UL, 0x3fc24924UL, 0x00000000UL, 0xbfd00000UL\n-  subsd(xmm5, xmm2);\n-  andl(edx, 16711680);\n-  shrl(edx, 12);\n-  movdqu(xmm0, Address(tmp2, edx));\n-  movdqu(xmm4, ExternalAddress(coeff + 16), tmp1 \/*rscratch*\/); \/\/ 0x3d6fb175UL, 0xbfc5555eUL, 0x55555555UL, 0x3fd55555UL\n-  addsd(xmm1, xmm5);\n-  movdqu(xmm2, ExternalAddress(coeff + 32), tmp1 \/*rscratch*\/); \/\/ 0x9999999aUL, 0x3fc99999UL, 0x00000000UL, 0xbfe00000UL\n-  mulsd(xmm6, xmm7);\n-  if (VM_Version::supports_sse3()) {\n-    movddup(xmm5, xmm1);\n-  }\n-  else {\n-    movdqu(xmm5, xmm1);\n-    movlhps(xmm5, xmm5);\n-  }\n-  mulsd(xmm7, ExternalAddress(log2 + 8), tmp1 \/*rscratch*\/);    \/\/ 0x93c76730UL, 0x3ceef357UL\n-  mulsd(xmm3, xmm1);\n-  addsd(xmm0, xmm6);\n-  mulpd(xmm4, xmm5);\n-  mulpd(xmm5, xmm5);\n-  if (VM_Version::supports_sse3()) {\n-    movddup(xmm6, xmm0);\n-  }\n-  else {\n-    movdqu(xmm6, xmm0);\n-    movlhps(xmm6, xmm6);\n-  }\n-  addsd(xmm0, xmm1);\n-  addpd(xmm4, xmm2);\n-  mulpd(xmm3, xmm5);\n-  subsd(xmm6, xmm0);\n-  mulsd(xmm4, xmm1);\n-  pshufd(xmm2, xmm0, 238);\n-  addsd(xmm1, xmm6);\n-  mulsd(xmm5, xmm5);\n-  addsd(xmm7, xmm2);\n-  addpd(xmm4, xmm3);\n-  addsd(xmm1, xmm7);\n-  mulpd(xmm4, xmm5);\n-  addsd(xmm1, xmm4);\n-  pshufd(xmm5, xmm4, 238);\n-  addsd(xmm1, xmm5);\n-  addsd(xmm0, xmm1);\n-  jmp(B1_5);\n-\n-  bind(L_2TAG_PACKET_0_0_2);\n-  movq(xmm0, Address(rsp, 0));\n-  movq(xmm1, Address(rsp, 0));\n-  addl(eax, 16);\n-  cmpl(eax, 32768);\n-  jcc(Assembler::aboveEqual, L_2TAG_PACKET_2_0_2);\n-  cmpl(eax, 16);\n-  jcc(Assembler::below, L_2TAG_PACKET_3_0_2);\n-\n-  bind(L_2TAG_PACKET_4_0_2);\n-  addsd(xmm0, xmm0);\n-  jmp(B1_5);\n-\n-  bind(L_2TAG_PACKET_5_0_2);\n-  jcc(Assembler::above, L_2TAG_PACKET_4_0_2);\n-  cmpl(edx, 0);\n-  jcc(Assembler::above, L_2TAG_PACKET_4_0_2);\n-  jmp(L_2TAG_PACKET_6_0_2);\n-\n-  bind(L_2TAG_PACKET_3_0_2);\n-  xorpd(xmm1, xmm1);\n-  addsd(xmm1, xmm0);\n-  movdl(edx, xmm1);\n-  psrlq(xmm1, 32);\n-  movdl(ecx, xmm1);\n-  orl(edx, ecx);\n-  cmpl(edx, 0);\n-  jcc(Assembler::equal, L_2TAG_PACKET_7_0_2);\n-  xorpd(xmm1, xmm1);\n-  movl(eax, 18416);\n-  pinsrw(xmm1, eax, 3);\n-  mulsd(xmm0, xmm1);\n-  movdqu(xmm1, xmm0);\n-  pextrw(eax, xmm0, 3);\n-  por(xmm0, xmm2);\n-  psrlq(xmm0, 27);\n-  movl(ecx, 18416);\n-  psrld(xmm0, 2);\n-  rcpps(xmm0, xmm0);\n-  psllq(xmm1, 12);\n-  pshufd(xmm6, xmm5, 228);\n-  psrlq(xmm1, 12);\n-  jmp(L_2TAG_PACKET_1_0_2);\n-\n-  bind(L_2TAG_PACKET_2_0_2);\n-  movdl(edx, xmm1);\n-  psrlq(xmm1, 32);\n-  movdl(ecx, xmm1);\n-  addl(ecx, ecx);\n-  cmpl(ecx, -2097152);\n-  jcc(Assembler::aboveEqual, L_2TAG_PACKET_5_0_2);\n-  orl(edx, ecx);\n-  cmpl(edx, 0);\n-  jcc(Assembler::equal, L_2TAG_PACKET_7_0_2);\n-\n-  bind(L_2TAG_PACKET_6_0_2);\n-  xorpd(xmm1, xmm1);\n-  xorpd(xmm0, xmm0);\n-  movl(eax, 32752);\n-  pinsrw(xmm1, eax, 3);\n-  mulsd(xmm0, xmm1);\n-  movl(Address(rsp, 16), 3);\n-  jmp(L_2TAG_PACKET_8_0_2);\n-  bind(L_2TAG_PACKET_7_0_2);\n-  xorpd(xmm1, xmm1);\n-  xorpd(xmm0, xmm0);\n-  movl(eax, 49136);\n-  pinsrw(xmm0, eax, 3);\n-  divsd(xmm0, xmm1);\n-  movl(Address(rsp, 16), 2);\n-\n-  bind(L_2TAG_PACKET_8_0_2);\n-  movq(Address(rsp, 8), xmm0);\n-\n-  bind(B1_3);\n-  movq(xmm0, Address(rsp, 8));\n-\n-  bind(B1_5);\n-  addq(rsp, 24);\n-}\n-#else\n-\/\/ The 32 bit code is at most SSE2 compliant\n-ATTRIBUTE_ALIGNED(16) juint _static_const_table_log[] =\n-{\n-    0xfefa3800UL, 0x3fe62e42UL, 0x93c76730UL, 0x3d2ef357UL, 0xaa241800UL,\n-    0x3fe5ee82UL, 0x0cda46beUL, 0x3d220238UL, 0x5c364800UL, 0x3fe5af40UL,\n-    0xac10c9fbUL, 0x3d2dfa63UL, 0x26bb8c00UL, 0x3fe5707aUL, 0xff3303ddUL,\n-    0x3d09980bUL, 0x26867800UL, 0x3fe5322eUL, 0x5d257531UL, 0x3d05ccc4UL,\n-    0x835a5000UL, 0x3fe4f45aUL, 0x6d93b8fbUL, 0xbd2e6c51UL, 0x6f970c00UL,\n-    0x3fe4b6fdUL, 0xed4c541cUL, 0x3cef7115UL, 0x27e8a400UL, 0x3fe47a15UL,\n-    0xf94d60aaUL, 0xbd22cb6aUL, 0xf2f92400UL, 0x3fe43d9fUL, 0x481051f7UL,\n-    0xbcfd984fUL, 0x2125cc00UL, 0x3fe4019cUL, 0x30f0c74cUL, 0xbd26ce79UL,\n-    0x0c36c000UL, 0x3fe3c608UL, 0x7cfe13c2UL, 0xbd02b736UL, 0x17197800UL,\n-    0x3fe38ae2UL, 0xbb5569a4UL, 0xbd218b7aUL, 0xad9d8c00UL, 0x3fe35028UL,\n-    0x9527e6acUL, 0x3d10b83fUL, 0x44340800UL, 0x3fe315daUL, 0xc5a0ed9cUL,\n-    0xbd274e93UL, 0x57b0e000UL, 0x3fe2dbf5UL, 0x07b9dc11UL, 0xbd17a6e5UL,\n-    0x6d0ec000UL, 0x3fe2a278UL, 0xe797882dUL, 0x3d206d2bUL, 0x1134dc00UL,\n-    0x3fe26962UL, 0x05226250UL, 0xbd0b61f1UL, 0xd8bebc00UL, 0x3fe230b0UL,\n-    0x6e48667bUL, 0x3d12fc06UL, 0x5fc61800UL, 0x3fe1f863UL, 0xc9fe81d3UL,\n-    0xbd2a7242UL, 0x49ae6000UL, 0x3fe1c078UL, 0xed70e667UL, 0x3cccacdeUL,\n-    0x40f23c00UL, 0x3fe188eeUL, 0xf8ab4650UL, 0x3d14cc4eUL, 0xf6f29800UL,\n-    0x3fe151c3UL, 0xa293ae49UL, 0xbd2edd97UL, 0x23c75c00UL, 0x3fe11af8UL,\n-    0xbb9ddcb2UL, 0xbd258647UL, 0x8611cc00UL, 0x3fe0e489UL, 0x07801742UL,\n-    0x3d1c2998UL, 0xe2d05400UL, 0x3fe0ae76UL, 0x887e7e27UL, 0x3d1f486bUL,\n-    0x0533c400UL, 0x3fe078bfUL, 0x41edf5fdUL, 0x3d268122UL, 0xbe760400UL,\n-    0x3fe04360UL, 0xe79539e0UL, 0xbd04c45fUL, 0xe5b20800UL, 0x3fe00e5aUL,\n-    0xb1727b1cUL, 0xbd053ba3UL, 0xaf7a4800UL, 0x3fdfb358UL, 0x3c164935UL,\n-    0x3d0085faUL, 0xee031800UL, 0x3fdf4aa7UL, 0x6f014a8bUL, 0x3d12cde5UL,\n-    0x56b41000UL, 0x3fdee2a1UL, 0x5a470251UL, 0x3d2f27f4UL, 0xc3ddb000UL,\n-    0x3fde7b42UL, 0x5372bd08UL, 0xbd246550UL, 0x1a272800UL, 0x3fde148aUL,\n-    0x07322938UL, 0xbd1326b2UL, 0x484c9800UL, 0x3fddae75UL, 0x60dc616aUL,\n-    0xbd1ea42dUL, 0x46def800UL, 0x3fdd4902UL, 0xe9a767a8UL, 0x3d235bafUL,\n-    0x18064800UL, 0x3fdce42fUL, 0x3ec7a6b0UL, 0xbd0797c3UL, 0xc7455800UL,\n-    0x3fdc7ff9UL, 0xc15249aeUL, 0xbd29b6ddUL, 0x693fa000UL, 0x3fdc1c60UL,\n-    0x7fe8e180UL, 0x3d2cec80UL, 0x1b80e000UL, 0x3fdbb961UL, 0xf40a666dUL,\n-    0x3d27d85bUL, 0x04462800UL, 0x3fdb56faUL, 0x2d841995UL, 0x3d109525UL,\n-    0x5248d000UL, 0x3fdaf529UL, 0x52774458UL, 0xbd217cc5UL, 0x3c8ad800UL,\n-    0x3fda93edUL, 0xbea77a5dUL, 0x3d1e36f2UL, 0x0224f800UL, 0x3fda3344UL,\n-    0x7f9d79f5UL, 0x3d23c645UL, 0xea15f000UL, 0x3fd9d32bUL, 0x10d0c0b0UL,\n-    0xbd26279eUL, 0x43135800UL, 0x3fd973a3UL, 0xa502d9f0UL, 0xbd152313UL,\n-    0x635bf800UL, 0x3fd914a8UL, 0x2ee6307dUL, 0xbd1766b5UL, 0xa88b3000UL,\n-    0x3fd8b639UL, 0xe5e70470UL, 0xbd205ae1UL, 0x776dc800UL, 0x3fd85855UL,\n-    0x3333778aUL, 0x3d2fd56fUL, 0x3bd81800UL, 0x3fd7fafaUL, 0xc812566aUL,\n-    0xbd272090UL, 0x687cf800UL, 0x3fd79e26UL, 0x2efd1778UL, 0x3d29ec7dUL,\n-    0x76c67800UL, 0x3fd741d8UL, 0x49dc60b3UL, 0x3d2d8b09UL, 0xe6af1800UL,\n-    0x3fd6e60eUL, 0x7c222d87UL, 0x3d172165UL, 0x3e9c6800UL, 0x3fd68ac8UL,\n-    0x2756eba0UL, 0x3d20a0d3UL, 0x0b3ab000UL, 0x3fd63003UL, 0xe731ae00UL,\n-    0xbd2db623UL, 0xdf596000UL, 0x3fd5d5bdUL, 0x08a465dcUL, 0xbd0a0b2aUL,\n-    0x53c8d000UL, 0x3fd57bf7UL, 0xee5d40efUL, 0x3d1fadedUL, 0x0738a000UL,\n-    0x3fd522aeUL, 0x8164c759UL, 0x3d2ebe70UL, 0x9e173000UL, 0x3fd4c9e0UL,\n-    0x1b0ad8a4UL, 0xbd2e2089UL, 0xc271c800UL, 0x3fd4718dUL, 0x0967d675UL,\n-    0xbd2f27ceUL, 0x23d5e800UL, 0x3fd419b4UL, 0xec90e09dUL, 0x3d08e436UL,\n-    0x77333000UL, 0x3fd3c252UL, 0xb606bd5cUL, 0x3d183b54UL, 0x76be1000UL,\n-    0x3fd36b67UL, 0xb0f177c8UL, 0x3d116ecdUL, 0xe1d36000UL, 0x3fd314f1UL,\n-    0xd3213cb8UL, 0xbd28e27aUL, 0x7cdc9000UL, 0x3fd2bef0UL, 0x4a5004f4UL,\n-    0x3d2a9cfaUL, 0x1134d800UL, 0x3fd26962UL, 0xdf5bb3b6UL, 0x3d2c93c1UL,\n-    0x6d0eb800UL, 0x3fd21445UL, 0xba46baeaUL, 0x3d0a87deUL, 0x635a6800UL,\n-    0x3fd1bf99UL, 0x5147bdb7UL, 0x3d2ca6edUL, 0xcbacf800UL, 0x3fd16b5cUL,\n-    0xf7a51681UL, 0x3d2b9acdUL, 0x8227e800UL, 0x3fd1178eUL, 0x63a5f01cUL,\n-    0xbd2c210eUL, 0x67616000UL, 0x3fd0c42dUL, 0x163ceae9UL, 0x3d27188bUL,\n-    0x604d5800UL, 0x3fd07138UL, 0x16ed4e91UL, 0x3cf89cdbUL, 0x5626c800UL,\n-    0x3fd01eaeUL, 0x1485e94aUL, 0xbd16f08cUL, 0x6cb3b000UL, 0x3fcf991cUL,\n-    0xca0cdf30UL, 0x3d1bcbecUL, 0xe4dd0000UL, 0x3fcef5adUL, 0x65bb8e11UL,\n-    0xbcca2115UL, 0xffe71000UL, 0x3fce530eUL, 0x6041f430UL, 0x3cc21227UL,\n-    0xb0d49000UL, 0x3fcdb13dUL, 0xf715b035UL, 0xbd2aff2aUL, 0xf2656000UL,\n-    0x3fcd1037UL, 0x75b6f6e4UL, 0xbd084a7eUL, 0xc6f01000UL, 0x3fcc6ffbUL,\n-    0xc5962bd2UL, 0xbcf1ec72UL, 0x383be000UL, 0x3fcbd087UL, 0x595412b6UL,\n-    0xbd2d4bc4UL, 0x575bd000UL, 0x3fcb31d8UL, 0x4eace1aaUL, 0xbd0c358dUL,\n-    0x3c8ae000UL, 0x3fca93edUL, 0x50562169UL, 0xbd287243UL, 0x07089000UL,\n-    0x3fc9f6c4UL, 0x6865817aUL, 0x3d29904dUL, 0xdcf70000UL, 0x3fc95a5aUL,\n-    0x58a0ff6fUL, 0x3d07f228UL, 0xeb390000UL, 0x3fc8beafUL, 0xaae92cd1UL,\n-    0xbd073d54UL, 0x6551a000UL, 0x3fc823c1UL, 0x9a631e83UL, 0x3d1e0ddbUL,\n-    0x85445000UL, 0x3fc7898dUL, 0x70914305UL, 0xbd1c6610UL, 0x8b757000UL,\n-    0x3fc6f012UL, 0xe59c21e1UL, 0xbd25118dUL, 0xbe8c1000UL, 0x3fc6574eUL,\n-    0x2c3c2e78UL, 0x3d19cf8bUL, 0x6b544000UL, 0x3fc5bf40UL, 0xeb68981cUL,\n-    0xbd127023UL, 0xe4a1b000UL, 0x3fc527e5UL, 0xe5697dc7UL, 0x3d2633e8UL,\n-    0x8333b000UL, 0x3fc4913dUL, 0x54fdb678UL, 0x3d258379UL, 0xa5993000UL,\n-    0x3fc3fb45UL, 0x7e6a354dUL, 0xbd2cd1d8UL, 0xb0159000UL, 0x3fc365fcUL,\n-    0x234b7289UL, 0x3cc62fa8UL, 0x0c868000UL, 0x3fc2d161UL, 0xcb81b4a1UL,\n-    0x3d039d6cUL, 0x2a49c000UL, 0x3fc23d71UL, 0x8fd3df5cUL, 0x3d100d23UL,\n-    0x7e23f000UL, 0x3fc1aa2bUL, 0x44389934UL, 0x3d2ca78eUL, 0x8227e000UL,\n-    0x3fc1178eUL, 0xce2d07f2UL, 0x3d21ef78UL, 0xb59e4000UL, 0x3fc08598UL,\n-    0x7009902cUL, 0xbd27e5ddUL, 0x39dbe000UL, 0x3fbfe891UL, 0x4fa10afdUL,\n-    0xbd2534d6UL, 0x830a2000UL, 0x3fbec739UL, 0xafe645e0UL, 0xbd2dc068UL,\n-    0x63844000UL, 0x3fbda727UL, 0x1fa71733UL, 0x3d1a8940UL, 0x01bc4000UL,\n-    0x3fbc8858UL, 0xc65aacd3UL, 0x3d2646d1UL, 0x8dad6000UL, 0x3fbb6ac8UL,\n-    0x2bf768e5UL, 0xbd139080UL, 0x40b1c000UL, 0x3fba4e76UL, 0xb94407c8UL,\n-    0xbd0e42b6UL, 0x5d594000UL, 0x3fb9335eUL, 0x3abd47daUL, 0x3d23115cUL,\n-    0x2f40e000UL, 0x3fb8197eUL, 0xf96ffdf7UL, 0x3d0f80dcUL, 0x0aeac000UL,\n-    0x3fb700d3UL, 0xa99ded32UL, 0x3cec1e8dUL, 0x4d97a000UL, 0x3fb5e95aUL,\n-    0x3c5d1d1eUL, 0xbd2c6906UL, 0x5d208000UL, 0x3fb4d311UL, 0x82f4e1efUL,\n-    0xbcf53a25UL, 0xa7d1e000UL, 0x3fb3bdf5UL, 0xa5db4ed7UL, 0x3d2cc85eUL,\n-    0xa4472000UL, 0x3fb2aa04UL, 0xae9c697dUL, 0xbd20b6e8UL, 0xd1466000UL,\n-    0x3fb1973bUL, 0x560d9e9bUL, 0xbd25325dUL, 0xb59e4000UL, 0x3fb08598UL,\n-    0x7009902cUL, 0xbd17e5ddUL, 0xc006c000UL, 0x3faeea31UL, 0x4fc93b7bUL,\n-    0xbd0e113eUL, 0xcdddc000UL, 0x3faccb73UL, 0x47d82807UL, 0xbd1a68f2UL,\n-    0xd0fb0000UL, 0x3faaaef2UL, 0x353bb42eUL, 0x3d20fc1aUL, 0x149fc000UL,\n-    0x3fa894aaUL, 0xd05a267dUL, 0xbd197995UL, 0xf2d4c000UL, 0x3fa67c94UL,\n-    0xec19afa2UL, 0xbd029efbUL, 0xd42e0000UL, 0x3fa466aeUL, 0x75bdfd28UL,\n-    0xbd2c1673UL, 0x2f8d0000UL, 0x3fa252f3UL, 0xe021b67bUL, 0x3d283e9aUL,\n-    0x89e74000UL, 0x3fa0415dUL, 0x5cf1d753UL, 0x3d0111c0UL, 0xec148000UL,\n-    0x3f9c63d2UL, 0x3f9eb2f3UL, 0x3d2578c6UL, 0x28c90000UL, 0x3f984925UL,\n-    0x325a0c34UL, 0xbd2aa0baUL, 0x25980000UL, 0x3f9432a9UL, 0x928637feUL,\n-    0x3d098139UL, 0x58938000UL, 0x3f902056UL, 0x06e2f7d2UL, 0xbd23dc5bUL,\n-    0xa3890000UL, 0x3f882448UL, 0xda74f640UL, 0xbd275577UL, 0x75890000UL,\n-    0x3f801015UL, 0x999d2be8UL, 0xbd10c76bUL, 0x59580000UL, 0x3f700805UL,\n-    0xcb31c67bUL, 0x3d2166afUL, 0x00000000UL, 0x00000000UL, 0x00000000UL,\n-    0x80000000UL, 0xfefa3800UL, 0x3fa62e42UL, 0x93c76730UL, 0x3ceef357UL,\n-    0x92492492UL, 0x3fc24924UL, 0x00000000UL, 0xbfd00000UL, 0x3d6fb175UL,\n-    0xbfc5555eUL, 0x55555555UL, 0x3fd55555UL, 0x9999999aUL, 0x3fc99999UL,\n-    0x00000000UL, 0xbfe00000UL, 0x00000000UL, 0xffffe000UL, 0x00000000UL,\n-    0xffffe000UL\n-};\n-\/\/registers,\n-\/\/ input: xmm0\n-\/\/ scratch: xmm1, xmm2, xmm3, xmm4, xmm5, xmm6, xmm7\n-\/\/          rax, rdx, rcx, rbx (tmp)\n-\n-void MacroAssembler::fast_log(XMMRegister xmm0, XMMRegister xmm1, XMMRegister xmm2, XMMRegister xmm3,\n-                              XMMRegister xmm4, XMMRegister xmm5, XMMRegister xmm6, XMMRegister xmm7,\n-                              Register eax, Register ecx, Register edx, Register tmp) {\n-  Label L_2TAG_PACKET_0_0_2, L_2TAG_PACKET_1_0_2, L_2TAG_PACKET_2_0_2, L_2TAG_PACKET_3_0_2;\n-  Label L_2TAG_PACKET_4_0_2, L_2TAG_PACKET_5_0_2, L_2TAG_PACKET_6_0_2, L_2TAG_PACKET_7_0_2;\n-  Label L_2TAG_PACKET_8_0_2, L_2TAG_PACKET_9_0_2;\n-  Label L_2TAG_PACKET_10_0_2;\n-\n-  assert_different_registers(tmp, eax, ecx, edx);\n-  address static_const_table = (address)_static_const_table_log;\n-\n-  subl(rsp, 104);\n-  movl(Address(rsp, 40), tmp);\n-  lea(tmp, ExternalAddress(static_const_table));\n-  xorpd(xmm2, xmm2);\n-  movl(eax, 16368);\n-  pinsrw(xmm2, eax, 3);\n-  xorpd(xmm3, xmm3);\n-  movl(edx, 30704);\n-  pinsrw(xmm3, edx, 3);\n-  movsd(xmm0, Address(rsp, 112));\n-  movapd(xmm1, xmm0);\n-  movl(ecx, 32768);\n-  movdl(xmm4, ecx);\n-  movsd(xmm5, Address(tmp, 2128));         \/\/ 0x00000000UL, 0xffffe000UL\n-  pextrw(eax, xmm0, 3);\n-  por(xmm0, xmm2);\n-  psllq(xmm0, 5);\n-  movl(ecx, 16352);\n-  psrlq(xmm0, 34);\n-  rcpss(xmm0, xmm0);\n-  psllq(xmm1, 12);\n-  pshufd(xmm6, xmm5, 228);\n-  psrlq(xmm1, 12);\n-  subl(eax, 16);\n-  cmpl(eax, 32736);\n-  jcc(Assembler::aboveEqual, L_2TAG_PACKET_0_0_2);\n-\n-  bind(L_2TAG_PACKET_1_0_2);\n-  paddd(xmm0, xmm4);\n-  por(xmm1, xmm3);\n-  movdl(edx, xmm0);\n-  psllq(xmm0, 29);\n-  pand(xmm5, xmm1);\n-  pand(xmm0, xmm6);\n-  subsd(xmm1, xmm5);\n-  mulpd(xmm5, xmm0);\n-  andl(eax, 32752);\n-  subl(eax, ecx);\n-  cvtsi2sdl(xmm7, eax);\n-  mulsd(xmm1, xmm0);\n-  movsd(xmm6, Address(tmp, 2064));         \/\/ 0xfefa3800UL, 0x3fa62e42UL\n-  movdqu(xmm3, Address(tmp, 2080));        \/\/ 0x92492492UL, 0x3fc24924UL, 0x00000000UL, 0xbfd00000UL\n-  subsd(xmm5, xmm2);\n-  andl(edx, 16711680);\n-  shrl(edx, 12);\n-  movdqu(xmm0, Address(tmp, edx));\n-  movdqu(xmm4, Address(tmp, 2096));        \/\/ 0x3d6fb175UL, 0xbfc5555eUL, 0x55555555UL, 0x3fd55555UL\n-  addsd(xmm1, xmm5);\n-  movdqu(xmm2, Address(tmp, 2112));        \/\/ 0x9999999aUL, 0x3fc99999UL, 0x00000000UL, 0xbfe00000UL\n-  mulsd(xmm6, xmm7);\n-  pshufd(xmm5, xmm1, 68);\n-  mulsd(xmm7, Address(tmp, 2072));         \/\/ 0x93c76730UL, 0x3ceef357UL, 0x92492492UL, 0x3fc24924UL\n-  mulsd(xmm3, xmm1);\n-  addsd(xmm0, xmm6);\n-  mulpd(xmm4, xmm5);\n-  mulpd(xmm5, xmm5);\n-  pshufd(xmm6, xmm0, 228);\n-  addsd(xmm0, xmm1);\n-  addpd(xmm4, xmm2);\n-  mulpd(xmm3, xmm5);\n-  subsd(xmm6, xmm0);\n-  mulsd(xmm4, xmm1);\n-  pshufd(xmm2, xmm0, 238);\n-  addsd(xmm1, xmm6);\n-  mulsd(xmm5, xmm5);\n-  addsd(xmm7, xmm2);\n-  addpd(xmm4, xmm3);\n-  addsd(xmm1, xmm7);\n-  mulpd(xmm4, xmm5);\n-  addsd(xmm1, xmm4);\n-  pshufd(xmm5, xmm4, 238);\n-  addsd(xmm1, xmm5);\n-  addsd(xmm0, xmm1);\n-  jmp(L_2TAG_PACKET_2_0_2);\n-\n-  bind(L_2TAG_PACKET_0_0_2);\n-  movsd(xmm0, Address(rsp, 112));\n-  movdqu(xmm1, xmm0);\n-  addl(eax, 16);\n-  cmpl(eax, 32768);\n-  jcc(Assembler::aboveEqual, L_2TAG_PACKET_3_0_2);\n-  cmpl(eax, 16);\n-  jcc(Assembler::below, L_2TAG_PACKET_4_0_2);\n-\n-  bind(L_2TAG_PACKET_5_0_2);\n-  addsd(xmm0, xmm0);\n-  jmp(L_2TAG_PACKET_2_0_2);\n-\n-  bind(L_2TAG_PACKET_6_0_2);\n-  jcc(Assembler::above, L_2TAG_PACKET_5_0_2);\n-  cmpl(edx, 0);\n-  jcc(Assembler::above, L_2TAG_PACKET_5_0_2);\n-  jmp(L_2TAG_PACKET_7_0_2);\n-\n-  bind(L_2TAG_PACKET_3_0_2);\n-  movdl(edx, xmm1);\n-  psrlq(xmm1, 32);\n-  movdl(ecx, xmm1);\n-  addl(ecx, ecx);\n-  cmpl(ecx, -2097152);\n-  jcc(Assembler::aboveEqual, L_2TAG_PACKET_6_0_2);\n-  orl(edx, ecx);\n-  cmpl(edx, 0);\n-  jcc(Assembler::equal, L_2TAG_PACKET_8_0_2);\n-\n-  bind(L_2TAG_PACKET_7_0_2);\n-  xorpd(xmm1, xmm1);\n-  xorpd(xmm0, xmm0);\n-  movl(eax, 32752);\n-  pinsrw(xmm1, eax, 3);\n-  movl(edx, 3);\n-  mulsd(xmm0, xmm1);\n-\n-  bind(L_2TAG_PACKET_9_0_2);\n-  movsd(Address(rsp, 0), xmm0);\n-  movsd(xmm0, Address(rsp, 112));\n-  fld_d(Address(rsp, 0));\n-  jmp(L_2TAG_PACKET_10_0_2);\n-\n-  bind(L_2TAG_PACKET_8_0_2);\n-  xorpd(xmm1, xmm1);\n-  xorpd(xmm0, xmm0);\n-  movl(eax, 49136);\n-  pinsrw(xmm0, eax, 3);\n-  divsd(xmm0, xmm1);\n-  movl(edx, 2);\n-  jmp(L_2TAG_PACKET_9_0_2);\n-\n-  bind(L_2TAG_PACKET_4_0_2);\n-  movdl(edx, xmm1);\n-  psrlq(xmm1, 32);\n-  movdl(ecx, xmm1);\n-  orl(edx, ecx);\n-  cmpl(edx, 0);\n-  jcc(Assembler::equal, L_2TAG_PACKET_8_0_2);\n-  xorpd(xmm1, xmm1);\n-  movl(eax, 18416);\n-  pinsrw(xmm1, eax, 3);\n-  mulsd(xmm0, xmm1);\n-  movapd(xmm1, xmm0);\n-  pextrw(eax, xmm0, 3);\n-  por(xmm0, xmm2);\n-  psllq(xmm0, 5);\n-  movl(ecx, 18416);\n-  psrlq(xmm0, 34);\n-  rcpss(xmm0, xmm0);\n-  psllq(xmm1, 12);\n-  pshufd(xmm6, xmm5, 228);\n-  psrlq(xmm1, 12);\n-  jmp(L_2TAG_PACKET_1_0_2);\n-\n-  bind(L_2TAG_PACKET_2_0_2);\n-  movsd(Address(rsp, 24), xmm0);\n-  fld_d(Address(rsp, 24));\n-\n-  bind(L_2TAG_PACKET_10_0_2);\n-  movl(tmp, Address(rsp, 40));\n-}\n-#endif\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86_log.cpp","additions":0,"deletions":651,"binary":false,"changes":651,"status":"deleted"},{"patch":"@@ -1,684 +0,0 @@\n-\/*\n-* Copyright (c) 2016, 2021, Intel Corporation. All rights reserved.\n-* Intel Math Library (LIBM) Source Code\n-*\n-* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-*\n-* This code is free software; you can redistribute it and\/or modify it\n-* under the terms of the GNU General Public License version 2 only, as\n-* published by the Free Software Foundation.\n-*\n-* This code is distributed in the hope that it will be useful, but WITHOUT\n-* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-* FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-* version 2 for more details (a copy is included in the LICENSE file that\n-* accompanied this code).\n-*\n-* You should have received a copy of the GNU General Public License version\n-* 2 along with this work; if not, write to the Free Software Foundation,\n-* Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-*\n-* Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-* or visit www.oracle.com if you need additional information or have any\n-* questions.\n-*\n-*\/\n-\n-#include \"precompiled.hpp\"\n-#include \"asm\/assembler.hpp\"\n-#include \"asm\/assembler.inline.hpp\"\n-#include \"macroAssembler_x86.hpp\"\n-#include \"runtime\/stubRoutines.hpp\"\n-#include \"utilities\/globalDefinitions.hpp\"\n-\n-\/******************************************************************************\/\n-\/\/                     ALGORITHM DESCRIPTION - LOG10()\n-\/\/                     ---------------------\n-\/\/\n-\/\/    Let x=2^k * mx, mx in [1,2)\n-\/\/\n-\/\/    Get B~1\/mx based on the output of rcpss instruction (B0)\n-\/\/    B = int((B0*LH*2^7+0.5))\/2^7\n-\/\/    LH is a short approximation for log10(e)\n-\/\/\n-\/\/    Reduced argument: r=B*mx-LH (computed accurately in high and low parts)\n-\/\/\n-\/\/    Result:  k*log10(2) - log(B) + p(r)\n-\/\/             p(r) is a degree 7 polynomial\n-\/\/             -log(B) read from data table (high, low parts)\n-\/\/             Result is formed from high and low parts\n-\/\/\n-\/\/ Special cases:\n-\/\/  log10(0) = -INF with divide-by-zero exception raised\n-\/\/  log10(1) = +0\n-\/\/  log10(x) = NaN with invalid exception raised if x < -0, including -INF\n-\/\/  log10(+INF) = +INF\n-\/\/\n-\/******************************************************************************\/\n-\n-#ifdef _LP64\n-\/\/ The 64 bit code is at most SSE2 compliant\n-ATTRIBUTE_ALIGNED(16) juint _HIGHSIGMASK_log10[] =\n-{\n-    0xf8000000UL, 0xffffffffUL, 0x00000000UL, 0xffffe000UL\n-};\n-\n-ATTRIBUTE_ALIGNED(16) juint _LOG10_E[] =\n-{\n-    0x00000000UL, 0x3fdbc000UL, 0xbf2e4108UL, 0x3f5a7a6cUL\n-};\n-\n-ATTRIBUTE_ALIGNED(16) juint _L_tbl_log10[] =\n-{\n-    0x509f7800UL, 0x3fd34413UL, 0x1f12b358UL, 0x3d1fef31UL, 0x80333400UL,\n-    0x3fd32418UL, 0xc671d9d0UL, 0xbcf542bfUL, 0x51195000UL, 0x3fd30442UL,\n-    0x78a4b0c3UL, 0x3d18216aUL, 0x6fc79400UL, 0x3fd2e490UL, 0x80fa389dUL,\n-    0xbc902869UL, 0x89d04000UL, 0x3fd2c502UL, 0x75c2f564UL, 0x3d040754UL,\n-    0x4ddd1c00UL, 0x3fd2a598UL, 0xd219b2c3UL, 0xbcfa1d84UL, 0x6baa7c00UL,\n-    0x3fd28651UL, 0xfd9abec1UL, 0x3d1be6d3UL, 0x94028800UL, 0x3fd2672dUL,\n-    0xe289a455UL, 0xbd1ede5eUL, 0x78b86400UL, 0x3fd2482cUL, 0x6734d179UL,\n-    0x3d1fe79bUL, 0xcca3c800UL, 0x3fd2294dUL, 0x981a40b8UL, 0xbced34eaUL,\n-    0x439c5000UL, 0x3fd20a91UL, 0xcc392737UL, 0xbd1a9cc3UL, 0x92752c00UL,\n-    0x3fd1ebf6UL, 0x03c9afe7UL, 0x3d1e98f8UL, 0x6ef8dc00UL, 0x3fd1cd7dUL,\n-    0x71dae7f4UL, 0x3d08a86cUL, 0x8fe4dc00UL, 0x3fd1af25UL, 0xee9185a1UL,\n-    0xbcff3412UL, 0xace59400UL, 0x3fd190eeUL, 0xc2cab353UL, 0x3cf17ed9UL,\n-    0x7e925000UL, 0x3fd172d8UL, 0x6952c1b2UL, 0x3cf1521cUL, 0xbe694400UL,\n-    0x3fd154e2UL, 0xcacb79caUL, 0xbd0bdc78UL, 0x26cbac00UL, 0x3fd1370dUL,\n-    0xf71f4de1UL, 0xbd01f8beUL, 0x72fa0800UL, 0x3fd11957UL, 0x55bf910bUL,\n-    0x3c946e2bUL, 0x5f106000UL, 0x3fd0fbc1UL, 0x39e639c1UL, 0x3d14a84bUL,\n-    0xa802a800UL, 0x3fd0de4aUL, 0xd3f31d5dUL, 0xbd178385UL, 0x0b992000UL,\n-    0x3fd0c0f3UL, 0x3843106fUL, 0xbd1f602fUL, 0x486ce800UL, 0x3fd0a3baUL,\n-    0x8819497cUL, 0x3cef987aUL, 0x1de49400UL, 0x3fd086a0UL, 0x1caa0467UL,\n-    0x3d0faec7UL, 0x4c30cc00UL, 0x3fd069a4UL, 0xa4424372UL, 0xbd1618fcUL,\n-    0x94490000UL, 0x3fd04cc6UL, 0x946517d2UL, 0xbd18384bUL, 0xb7e84000UL,\n-    0x3fd03006UL, 0xe0109c37UL, 0xbd19a6acUL, 0x798a0c00UL, 0x3fd01364UL,\n-    0x5121e864UL, 0xbd164cf7UL, 0x38ce8000UL, 0x3fcfedbfUL, 0x46214d1aUL,\n-    0xbcbbc402UL, 0xc8e62000UL, 0x3fcfb4efUL, 0xdab93203UL, 0x3d1e0176UL,\n-    0x2cb02800UL, 0x3fcf7c5aUL, 0x2a2ea8e4UL, 0xbcfec86aUL, 0xeeeaa000UL,\n-    0x3fcf43fdUL, 0xc18e49a4UL, 0x3cf110a8UL, 0x9bb6e800UL, 0x3fcf0bdaUL,\n-    0x923cc9c0UL, 0xbd15ce99UL, 0xc093f000UL, 0x3fced3efUL, 0x4d4b51e9UL,\n-    0x3d1a04c7UL, 0xec58f800UL, 0x3fce9c3cUL, 0x163cad59UL, 0x3cac8260UL,\n-    0x9a907000UL, 0x3fce2d7dUL, 0x3fa93646UL, 0x3ce4a1c0UL, 0x37311000UL,\n-    0x3fcdbf99UL, 0x32abd1fdUL, 0x3d07ea9dUL, 0x6744b800UL, 0x3fcd528cUL,\n-    0x4dcbdfd4UL, 0xbd1b08e2UL, 0xe36de800UL, 0x3fcce653UL, 0x0b7b7f7fUL,\n-    0xbd1b8f03UL, 0x77506800UL, 0x3fcc7aecUL, 0xa821c9fbUL, 0x3d13c163UL,\n-    0x00ff8800UL, 0x3fcc1053UL, 0x536bca76UL, 0xbd074ee5UL, 0x70719800UL,\n-    0x3fcba684UL, 0xd7da9b6bUL, 0xbd1fbf16UL, 0xc6f8d800UL, 0x3fcb3d7dUL,\n-    0xe2220bb3UL, 0x3d1a295dUL, 0x16c15800UL, 0x3fcad53cUL, 0xe724911eUL,\n-    0xbcf55822UL, 0x82533800UL, 0x3fca6dbcUL, 0x6d982371UL, 0x3cac567cUL,\n-    0x3c19e800UL, 0x3fca06fcUL, 0x84d17d80UL, 0x3d1da204UL, 0x85ef8000UL,\n-    0x3fc9a0f8UL, 0x54466a6aUL, 0xbd002204UL, 0xb0ac2000UL, 0x3fc93baeUL,\n-    0xd601fd65UL, 0x3d18840cUL, 0x1bb9b000UL, 0x3fc8d71cUL, 0x7bf58766UL,\n-    0xbd14f897UL, 0x34aae800UL, 0x3fc8733eUL, 0x3af6ac24UL, 0xbd0f5c45UL,\n-    0x76d68000UL, 0x3fc81012UL, 0x4303e1a1UL, 0xbd1f9a80UL, 0x6af57800UL,\n-    0x3fc7ad96UL, 0x43fbcb46UL, 0x3cf4c33eUL, 0xa6c51000UL, 0x3fc74bc7UL,\n-    0x70f0eac5UL, 0xbd192e3bUL, 0xccab9800UL, 0x3fc6eaa3UL, 0xc0093dfeUL,\n-    0xbd0faf15UL, 0x8b60b800UL, 0x3fc68a28UL, 0xde78d5fdUL, 0xbc9ea4eeUL,\n-    0x9d987000UL, 0x3fc62a53UL, 0x962bea6eUL, 0xbd194084UL, 0xc9b0e800UL,\n-    0x3fc5cb22UL, 0x888dd999UL, 0x3d1fe201UL, 0xe1634800UL, 0x3fc56c93UL,\n-    0x16ada7adUL, 0x3d1b1188UL, 0xc176c000UL, 0x3fc50ea4UL, 0x4159b5b5UL,\n-    0xbcf09c08UL, 0x51766000UL, 0x3fc4b153UL, 0x84393d23UL, 0xbcf6a89cUL,\n-    0x83695000UL, 0x3fc4549dUL, 0x9f0b8bbbUL, 0x3d1c4b8cUL, 0x538d5800UL,\n-    0x3fc3f881UL, 0xf49df747UL, 0x3cf89b99UL, 0xc8138000UL, 0x3fc39cfcUL,\n-    0xd503b834UL, 0xbd13b99fUL, 0xf0df0800UL, 0x3fc3420dUL, 0xf011b386UL,\n-    0xbd05d8beUL, 0xe7466800UL, 0x3fc2e7b2UL, 0xf39c7bc2UL, 0xbd1bb94eUL,\n-    0xcdd62800UL, 0x3fc28de9UL, 0x05e6d69bUL, 0xbd10ed05UL, 0xd015d800UL,\n-    0x3fc234b0UL, 0xe29b6c9dUL, 0xbd1ff967UL, 0x224ea800UL, 0x3fc1dc06UL,\n-    0x727711fcUL, 0xbcffb30dUL, 0x01540000UL, 0x3fc183e8UL, 0x39786c5aUL,\n-    0x3cc23f57UL, 0xb24d9800UL, 0x3fc12c54UL, 0xc905a342UL, 0x3d003a1dUL,\n-    0x82835800UL, 0x3fc0d54aUL, 0x9b9920c0UL, 0x3d03b25aUL, 0xc72ac000UL,\n-    0x3fc07ec7UL, 0x46f26a24UL, 0x3cf0fa41UL, 0xdd35d800UL, 0x3fc028caUL,\n-    0x41d9d6dcUL, 0x3d034a65UL, 0x52474000UL, 0x3fbfa6a4UL, 0x44f66449UL,\n-    0x3d19cad3UL, 0x2da3d000UL, 0x3fbefcb8UL, 0x67832999UL, 0x3d18400fUL,\n-    0x32a10000UL, 0x3fbe53ceUL, 0x9c0e3b1aUL, 0xbcff62fdUL, 0x556b7000UL,\n-    0x3fbdabe3UL, 0x02976913UL, 0xbcf8243bUL, 0x97e88000UL, 0x3fbd04f4UL,\n-    0xec793797UL, 0x3d1c0578UL, 0x09647000UL, 0x3fbc5effUL, 0x05fc0565UL,\n-    0xbd1d799eUL, 0xc6426000UL, 0x3fbbb9ffUL, 0x4625f5edUL, 0x3d1f5723UL,\n-    0xf7afd000UL, 0x3fbb15f3UL, 0xdd5aae61UL, 0xbd1a7e1eUL, 0xd358b000UL,\n-    0x3fba72d8UL, 0x3314e4d3UL, 0x3d17bc91UL, 0x9b1f5000UL, 0x3fb9d0abUL,\n-    0x9a4d514bUL, 0x3cf18c9bUL, 0x9cd4e000UL, 0x3fb92f69UL, 0x7e4496abUL,\n-    0x3cf1f96dUL, 0x31f4f000UL, 0x3fb88f10UL, 0xf56479e7UL, 0x3d165818UL,\n-    0xbf628000UL, 0x3fb7ef9cUL, 0x26bf486dUL, 0xbd1113a6UL, 0xb526b000UL,\n-    0x3fb7510cUL, 0x1a1c3384UL, 0x3ca9898dUL, 0x8e31e000UL, 0x3fb6b35dUL,\n-    0xb3875361UL, 0xbd0661acUL, 0xd01de000UL, 0x3fb6168cUL, 0x2a7cacfaUL,\n-    0xbd1bdf10UL, 0x0af23000UL, 0x3fb57a98UL, 0xff868816UL, 0x3cf046d0UL,\n-    0xd8ea0000UL, 0x3fb4df7cUL, 0x1515fbe7UL, 0xbd1fd529UL, 0xde3b2000UL,\n-    0x3fb44538UL, 0x6e59a132UL, 0x3d1faeeeUL, 0xc8df9000UL, 0x3fb3abc9UL,\n-    0xf1322361UL, 0xbd198807UL, 0x505f1000UL, 0x3fb3132dUL, 0x0888e6abUL,\n-    0x3d1e5380UL, 0x359bd000UL, 0x3fb27b61UL, 0xdfbcbb22UL, 0xbcfe2724UL,\n-    0x429ee000UL, 0x3fb1e463UL, 0x6eb4c58cUL, 0xbcfe4dd6UL, 0x4a673000UL,\n-    0x3fb14e31UL, 0x4ce1ac9bUL, 0x3d1ba691UL, 0x28b96000UL, 0x3fb0b8c9UL,\n-    0x8c7813b8UL, 0xbd0b3872UL, 0xc1f08000UL, 0x3fb02428UL, 0xc2bc8c2cUL,\n-    0x3cb5ea6bUL, 0x05a1a000UL, 0x3faf209cUL, 0x72e8f18eUL, 0xbce8df84UL,\n-    0xc0b5e000UL, 0x3fadfa6dUL, 0x9fdef436UL, 0x3d087364UL, 0xaf416000UL,\n-    0x3facd5c2UL, 0x1068c3a9UL, 0x3d0827e7UL, 0xdb356000UL, 0x3fabb296UL,\n-    0x120a34d3UL, 0x3d101a9fUL, 0x5dfea000UL, 0x3faa90e6UL, 0xdaded264UL,\n-    0xbd14c392UL, 0x6034c000UL, 0x3fa970adUL, 0x1c9d06a9UL, 0xbd1b705eUL,\n-    0x194c6000UL, 0x3fa851e8UL, 0x83996ad9UL, 0xbd0117bcUL, 0xcf4ac000UL,\n-    0x3fa73492UL, 0xb1a94a62UL, 0xbca5ea42UL, 0xd67b4000UL, 0x3fa618a9UL,\n-    0x75aed8caUL, 0xbd07119bUL, 0x9126c000UL, 0x3fa4fe29UL, 0x5291d533UL,\n-    0x3d12658fUL, 0x6f4d4000UL, 0x3fa3e50eUL, 0xcd2c5cd9UL, 0x3d1d5c70UL,\n-    0xee608000UL, 0x3fa2cd54UL, 0xd1008489UL, 0x3d1a4802UL, 0x9900e000UL,\n-    0x3fa1b6f9UL, 0x54fb5598UL, 0xbd16593fUL, 0x06bb6000UL, 0x3fa0a1f9UL,\n-    0x64ef57b4UL, 0xbd17636bUL, 0xb7940000UL, 0x3f9f1c9fUL, 0xee6a4737UL,\n-    0x3cb5d479UL, 0x91aa0000UL, 0x3f9cf7f5UL, 0x3a16373cUL, 0x3d087114UL,\n-    0x156b8000UL, 0x3f9ad5edUL, 0x836c554aUL, 0x3c6900b0UL, 0xd4764000UL,\n-    0x3f98b67fUL, 0xed12f17bUL, 0xbcffc974UL, 0x77dec000UL, 0x3f9699a7UL,\n-    0x232ce7eaUL, 0x3d1e35bbUL, 0xbfbf4000UL, 0x3f947f5dUL, 0xd84ffa6eUL,\n-    0x3d0e0a49UL, 0x82c7c000UL, 0x3f92679cUL, 0x8d170e90UL, 0xbd14d9f2UL,\n-    0xadd20000UL, 0x3f90525dUL, 0x86d9f88eUL, 0x3cdeb986UL, 0x86f10000UL,\n-    0x3f8c7f36UL, 0xb9e0a517UL, 0x3ce29faaUL, 0xb75c8000UL, 0x3f885e9eUL,\n-    0x542568cbUL, 0xbd1f7bdbUL, 0x46b30000UL, 0x3f8442e8UL, 0xb954e7d9UL,\n-    0x3d1e5287UL, 0xb7e60000UL, 0x3f802c07UL, 0x22da0b17UL, 0xbd19fb27UL,\n-    0x6c8b0000UL, 0x3f7833e3UL, 0x821271efUL, 0xbd190f96UL, 0x29910000UL,\n-    0x3f701936UL, 0xbc3491a5UL, 0xbd1bcf45UL, 0x354a0000UL, 0x3f600fe3UL,\n-    0xc0ff520aUL, 0xbd19d71cUL, 0x00000000UL, 0x00000000UL, 0x00000000UL,\n-    0x00000000UL\n-};\n-\n-ATTRIBUTE_ALIGNED(16) juint _log2_log10[] =\n-{\n-    0x509f7800UL, 0x3f934413UL, 0x1f12b358UL, 0x3cdfef31UL\n-};\n-\n-ATTRIBUTE_ALIGNED(16) juint _coeff_log10[] =\n-{\n-    0xc1a5f12eUL, 0x40358874UL, 0x64d4ef0dUL, 0xc0089309UL, 0x385593b1UL,\n-    0xc025c917UL, 0xdc963467UL, 0x3ffc6a02UL, 0x7f9d3aa1UL, 0x4016ab9fUL,\n-    0xdc77b115UL, 0xbff27af2UL\n-};\n-\n-\/\/ Registers:\n-\/\/ input: xmm0\n-\/\/ scratch: xmm1, xmm2, xmm3, xmm4, xmm5, xmm6, xmm7\n-\/\/          rax, rdx, rcx, r11, tmp\n-\n-\/\/ Code generated by Intel C compiler for LIBM library\n-\n-void MacroAssembler::fast_log10(XMMRegister xmm0, XMMRegister xmm1, XMMRegister xmm2, XMMRegister xmm3,\n-                                XMMRegister xmm4, XMMRegister xmm5, XMMRegister xmm6, XMMRegister xmm7,\n-                                Register eax, Register ecx, Register edx, Register r11, Register tmp) {\n-  Label L_2TAG_PACKET_0_0_2, L_2TAG_PACKET_1_0_2, L_2TAG_PACKET_2_0_2, L_2TAG_PACKET_3_0_2;\n-  Label L_2TAG_PACKET_4_0_2, L_2TAG_PACKET_5_0_2, L_2TAG_PACKET_6_0_2, L_2TAG_PACKET_7_0_2;\n-  Label L_2TAG_PACKET_8_0_2, L_2TAG_PACKET_9_0_2, B1_2, B1_3, B1_5;\n-\n-  assert_different_registers(r11, eax, ecx, edx);\n-\n-  address HIGHSIGMASK = (address)_HIGHSIGMASK_log10;\n-  address LOG10_E = (address)_LOG10_E;\n-  address L_tbl = (address)_L_tbl_log10;\n-  address log2 = (address)_log2_log10;\n-  address coeff = (address)_coeff_log10;\n-\n-  subq(rsp, 24);\n-  movsd(Address(rsp, 0), xmm0);\n-\n-  bind(B1_2);\n-  xorpd(xmm2, xmm2);\n-  movl(eax, 16368);\n-  pinsrw(xmm2, eax, 3);\n-  movl(ecx, 1054736384);\n-  movdl(xmm7, ecx);\n-  xorpd(xmm3, xmm3);\n-  movl(edx, 30704);\n-  pinsrw(xmm3, edx, 3);\n-  movdqu(xmm1, xmm0);\n-  movl(edx, 32768);\n-  movdl(xmm4, edx);\n-  movdqu(xmm5, ExternalAddress(HIGHSIGMASK), tmp \/*rscratch*\/);    \/\/0xf8000000UL, 0xffffffffUL, 0x00000000UL, 0xffffe000UL\n-  pextrw(eax, xmm0, 3);\n-  por(xmm0, xmm2);\n-  movl(ecx, 16352);\n-  psrlq(xmm0, 27);\n-  movdqu(xmm2, ExternalAddress(LOG10_E), tmp \/*rscratch*\/);    \/\/0x00000000UL, 0x3fdbc000UL, 0xbf2e4108UL, 0x3f5a7a6cUL\n-  psrld(xmm0, 2);\n-  rcpps(xmm0, xmm0);\n-  psllq(xmm1, 12);\n-  pshufd(xmm6, xmm5, 78);\n-  psrlq(xmm1, 12);\n-  subl(eax, 16);\n-  cmpl(eax, 32736);\n-  jcc(Assembler::aboveEqual, L_2TAG_PACKET_0_0_2);\n-\n-  bind(L_2TAG_PACKET_1_0_2);\n-  mulss(xmm0, xmm7);\n-  por(xmm1, xmm3);\n-  lea(r11, ExternalAddress(L_tbl));\n-  andpd(xmm5, xmm1);\n-  paddd(xmm0, xmm4);\n-  subsd(xmm1, xmm5);\n-  movdl(edx, xmm0);\n-  psllq(xmm0, 29);\n-  andpd(xmm0, xmm6);\n-  andl(eax, 32752);\n-  subl(eax, ecx);\n-  cvtsi2sdl(xmm7, eax);\n-  mulpd(xmm5, xmm0);\n-  mulsd(xmm1, xmm0);\n-  movq(xmm6, ExternalAddress(log2), tmp \/*rscratch*\/);    \/\/0x509f7800UL, 0x3f934413UL, 0x1f12b358UL, 0x3cdfef31UL\n-  movdqu(xmm3, ExternalAddress(coeff), tmp \/*rscratch*\/);    \/\/0xc1a5f12eUL, 0x40358874UL, 0x64d4ef0dUL, 0xc0089309UL\n-  subsd(xmm5, xmm2);\n-  andl(edx, 16711680);\n-  shrl(edx, 12);\n-  movdqu(xmm0, Address(r11, rdx, Address::times_1, -1504));\n-  movdqu(xmm4, ExternalAddress(coeff + 16), tmp \/*rscratch*\/);    \/\/0x385593b1UL, 0xc025c917UL, 0xdc963467UL, 0x3ffc6a02UL\n-  addsd(xmm1, xmm5);\n-  movdqu(xmm2, ExternalAddress(coeff + 32), tmp \/*rscratch*\/);    \/\/0x7f9d3aa1UL, 0x4016ab9fUL, 0xdc77b115UL, 0xbff27af2UL\n-  mulsd(xmm6, xmm7);\n-  pshufd(xmm5, xmm1, 68);\n-  mulsd(xmm7, ExternalAddress(log2 + 8), tmp \/*rscratch*\/);    \/\/0x1f12b358UL, 0x3cdfef31UL\n-  mulsd(xmm3, xmm1);\n-  addsd(xmm0, xmm6);\n-  mulpd(xmm4, xmm5);\n-  movq(xmm6, ExternalAddress(LOG10_E + 8), tmp \/*rscratch*\/);    \/\/0xbf2e4108UL, 0x3f5a7a6cUL\n-  mulpd(xmm5, xmm5);\n-  addpd(xmm4, xmm2);\n-  mulpd(xmm3, xmm5);\n-  pshufd(xmm2, xmm0, 228);\n-  addsd(xmm0, xmm1);\n-  mulsd(xmm4, xmm1);\n-  subsd(xmm2, xmm0);\n-  mulsd(xmm6, xmm1);\n-  addsd(xmm1, xmm2);\n-  pshufd(xmm2, xmm0, 238);\n-  mulsd(xmm5, xmm5);\n-  addsd(xmm7, xmm2);\n-  addsd(xmm1, xmm6);\n-  addpd(xmm4, xmm3);\n-  addsd(xmm1, xmm7);\n-  mulpd(xmm4, xmm5);\n-  addsd(xmm1, xmm4);\n-  pshufd(xmm5, xmm4, 238);\n-  addsd(xmm1, xmm5);\n-  addsd(xmm0, xmm1);\n-  jmp(B1_5);\n-\n-  bind(L_2TAG_PACKET_0_0_2);\n-  movq(xmm0, Address(rsp, 0));\n-  movq(xmm1, Address(rsp, 0));\n-  addl(eax, 16);\n-  cmpl(eax, 32768);\n-  jcc(Assembler::aboveEqual, L_2TAG_PACKET_2_0_2);\n-  cmpl(eax, 16);\n-  jcc(Assembler::below, L_2TAG_PACKET_3_0_2);\n-\n-  bind(L_2TAG_PACKET_4_0_2);\n-  addsd(xmm0, xmm0);\n-  jmp(B1_5);\n-\n-  bind(L_2TAG_PACKET_5_0_2);\n-  jcc(Assembler::above, L_2TAG_PACKET_4_0_2);\n-  cmpl(edx, 0);\n-  jcc(Assembler::above, L_2TAG_PACKET_4_0_2);\n-  jmp(L_2TAG_PACKET_6_0_2);\n-\n-  bind(L_2TAG_PACKET_3_0_2);\n-  xorpd(xmm1, xmm1);\n-  addsd(xmm1, xmm0);\n-  movdl(edx, xmm1);\n-  psrlq(xmm1, 32);\n-  movdl(ecx, xmm1);\n-  orl(edx, ecx);\n-  cmpl(edx, 0);\n-  jcc(Assembler::equal, L_2TAG_PACKET_7_0_2);\n-  xorpd(xmm1, xmm1);\n-  movl(eax, 18416);\n-  pinsrw(xmm1, eax, 3);\n-  mulsd(xmm0, xmm1);\n-  xorpd(xmm2, xmm2);\n-  movl(eax, 16368);\n-  pinsrw(xmm2, eax, 3);\n-  movdqu(xmm1, xmm0);\n-  pextrw(eax, xmm0, 3);\n-  por(xmm0, xmm2);\n-  movl(ecx, 18416);\n-  psrlq(xmm0, 27);\n-  movdqu(xmm2, ExternalAddress(LOG10_E), tmp \/*rscratch*\/);    \/\/0x00000000UL, 0x3fdbc000UL, 0xbf2e4108UL, 0x3f5a7a6cUL\n-  psrld(xmm0, 2);\n-  rcpps(xmm0, xmm0);\n-  psllq(xmm1, 12);\n-  pshufd(xmm6, xmm5, 78);\n-  psrlq(xmm1, 12);\n-  jmp(L_2TAG_PACKET_1_0_2);\n-\n-  bind(L_2TAG_PACKET_2_0_2);\n-  movdl(edx, xmm1);\n-  psrlq(xmm1, 32);\n-  movdl(ecx, xmm1);\n-  addl(ecx, ecx);\n-  cmpl(ecx, -2097152);\n-  jcc(Assembler::aboveEqual, L_2TAG_PACKET_5_0_2);\n-  orl(edx, ecx);\n-  cmpl(edx, 0);\n-  jcc(Assembler::equal, L_2TAG_PACKET_7_0_2);\n-\n-  bind(L_2TAG_PACKET_6_0_2);\n-  xorpd(xmm1, xmm1);\n-  xorpd(xmm0, xmm0);\n-  movl(eax, 32752);\n-  pinsrw(xmm1, eax, 3);\n-  mulsd(xmm0, xmm1);\n-  movl(Address(rsp, 16), 9);\n-  jmp(L_2TAG_PACKET_8_0_2);\n-\n-  bind(L_2TAG_PACKET_7_0_2);\n-  xorpd(xmm1, xmm1);\n-  xorpd(xmm0, xmm0);\n-  movl(eax, 49136);\n-  pinsrw(xmm0, eax, 3);\n-  divsd(xmm0, xmm1);\n-  movl(Address(rsp, 16), 8);\n-\n-  bind(L_2TAG_PACKET_8_0_2);\n-  movq(Address(rsp, 8), xmm0);\n-\n-  bind(B1_3);\n-  movq(xmm0, Address(rsp, 8));\n-\n-  bind(L_2TAG_PACKET_9_0_2);\n-\n-  bind(B1_5);\n-  addq(rsp, 24);\n-\n-}\n-#else\n-\/\/ The 32 bit code is at most SSE2 compliant\n-ATTRIBUTE_ALIGNED(16) juint _static_const_table_log10[] =\n-{\n-    0x509f7800UL, 0x3fd34413UL, 0x1f12b358UL, 0x3d1fef31UL, 0x80333400UL,\n-    0x3fd32418UL, 0xc671d9d0UL, 0xbcf542bfUL, 0x51195000UL, 0x3fd30442UL,\n-    0x78a4b0c3UL, 0x3d18216aUL, 0x6fc79400UL, 0x3fd2e490UL, 0x80fa389dUL,\n-    0xbc902869UL, 0x89d04000UL, 0x3fd2c502UL, 0x75c2f564UL, 0x3d040754UL,\n-    0x4ddd1c00UL, 0x3fd2a598UL, 0xd219b2c3UL, 0xbcfa1d84UL, 0x6baa7c00UL,\n-    0x3fd28651UL, 0xfd9abec1UL, 0x3d1be6d3UL, 0x94028800UL, 0x3fd2672dUL,\n-    0xe289a455UL, 0xbd1ede5eUL, 0x78b86400UL, 0x3fd2482cUL, 0x6734d179UL,\n-    0x3d1fe79bUL, 0xcca3c800UL, 0x3fd2294dUL, 0x981a40b8UL, 0xbced34eaUL,\n-    0x439c5000UL, 0x3fd20a91UL, 0xcc392737UL, 0xbd1a9cc3UL, 0x92752c00UL,\n-    0x3fd1ebf6UL, 0x03c9afe7UL, 0x3d1e98f8UL, 0x6ef8dc00UL, 0x3fd1cd7dUL,\n-    0x71dae7f4UL, 0x3d08a86cUL, 0x8fe4dc00UL, 0x3fd1af25UL, 0xee9185a1UL,\n-    0xbcff3412UL, 0xace59400UL, 0x3fd190eeUL, 0xc2cab353UL, 0x3cf17ed9UL,\n-    0x7e925000UL, 0x3fd172d8UL, 0x6952c1b2UL, 0x3cf1521cUL, 0xbe694400UL,\n-    0x3fd154e2UL, 0xcacb79caUL, 0xbd0bdc78UL, 0x26cbac00UL, 0x3fd1370dUL,\n-    0xf71f4de1UL, 0xbd01f8beUL, 0x72fa0800UL, 0x3fd11957UL, 0x55bf910bUL,\n-    0x3c946e2bUL, 0x5f106000UL, 0x3fd0fbc1UL, 0x39e639c1UL, 0x3d14a84bUL,\n-    0xa802a800UL, 0x3fd0de4aUL, 0xd3f31d5dUL, 0xbd178385UL, 0x0b992000UL,\n-    0x3fd0c0f3UL, 0x3843106fUL, 0xbd1f602fUL, 0x486ce800UL, 0x3fd0a3baUL,\n-    0x8819497cUL, 0x3cef987aUL, 0x1de49400UL, 0x3fd086a0UL, 0x1caa0467UL,\n-    0x3d0faec7UL, 0x4c30cc00UL, 0x3fd069a4UL, 0xa4424372UL, 0xbd1618fcUL,\n-    0x94490000UL, 0x3fd04cc6UL, 0x946517d2UL, 0xbd18384bUL, 0xb7e84000UL,\n-    0x3fd03006UL, 0xe0109c37UL, 0xbd19a6acUL, 0x798a0c00UL, 0x3fd01364UL,\n-    0x5121e864UL, 0xbd164cf7UL, 0x38ce8000UL, 0x3fcfedbfUL, 0x46214d1aUL,\n-    0xbcbbc402UL, 0xc8e62000UL, 0x3fcfb4efUL, 0xdab93203UL, 0x3d1e0176UL,\n-    0x2cb02800UL, 0x3fcf7c5aUL, 0x2a2ea8e4UL, 0xbcfec86aUL, 0xeeeaa000UL,\n-    0x3fcf43fdUL, 0xc18e49a4UL, 0x3cf110a8UL, 0x9bb6e800UL, 0x3fcf0bdaUL,\n-    0x923cc9c0UL, 0xbd15ce99UL, 0xc093f000UL, 0x3fced3efUL, 0x4d4b51e9UL,\n-    0x3d1a04c7UL, 0xec58f800UL, 0x3fce9c3cUL, 0x163cad59UL, 0x3cac8260UL,\n-    0x9a907000UL, 0x3fce2d7dUL, 0x3fa93646UL, 0x3ce4a1c0UL, 0x37311000UL,\n-    0x3fcdbf99UL, 0x32abd1fdUL, 0x3d07ea9dUL, 0x6744b800UL, 0x3fcd528cUL,\n-    0x4dcbdfd4UL, 0xbd1b08e2UL, 0xe36de800UL, 0x3fcce653UL, 0x0b7b7f7fUL,\n-    0xbd1b8f03UL, 0x77506800UL, 0x3fcc7aecUL, 0xa821c9fbUL, 0x3d13c163UL,\n-    0x00ff8800UL, 0x3fcc1053UL, 0x536bca76UL, 0xbd074ee5UL, 0x70719800UL,\n-    0x3fcba684UL, 0xd7da9b6bUL, 0xbd1fbf16UL, 0xc6f8d800UL, 0x3fcb3d7dUL,\n-    0xe2220bb3UL, 0x3d1a295dUL, 0x16c15800UL, 0x3fcad53cUL, 0xe724911eUL,\n-    0xbcf55822UL, 0x82533800UL, 0x3fca6dbcUL, 0x6d982371UL, 0x3cac567cUL,\n-    0x3c19e800UL, 0x3fca06fcUL, 0x84d17d80UL, 0x3d1da204UL, 0x85ef8000UL,\n-    0x3fc9a0f8UL, 0x54466a6aUL, 0xbd002204UL, 0xb0ac2000UL, 0x3fc93baeUL,\n-    0xd601fd65UL, 0x3d18840cUL, 0x1bb9b000UL, 0x3fc8d71cUL, 0x7bf58766UL,\n-    0xbd14f897UL, 0x34aae800UL, 0x3fc8733eUL, 0x3af6ac24UL, 0xbd0f5c45UL,\n-    0x76d68000UL, 0x3fc81012UL, 0x4303e1a1UL, 0xbd1f9a80UL, 0x6af57800UL,\n-    0x3fc7ad96UL, 0x43fbcb46UL, 0x3cf4c33eUL, 0xa6c51000UL, 0x3fc74bc7UL,\n-    0x70f0eac5UL, 0xbd192e3bUL, 0xccab9800UL, 0x3fc6eaa3UL, 0xc0093dfeUL,\n-    0xbd0faf15UL, 0x8b60b800UL, 0x3fc68a28UL, 0xde78d5fdUL, 0xbc9ea4eeUL,\n-    0x9d987000UL, 0x3fc62a53UL, 0x962bea6eUL, 0xbd194084UL, 0xc9b0e800UL,\n-    0x3fc5cb22UL, 0x888dd999UL, 0x3d1fe201UL, 0xe1634800UL, 0x3fc56c93UL,\n-    0x16ada7adUL, 0x3d1b1188UL, 0xc176c000UL, 0x3fc50ea4UL, 0x4159b5b5UL,\n-    0xbcf09c08UL, 0x51766000UL, 0x3fc4b153UL, 0x84393d23UL, 0xbcf6a89cUL,\n-    0x83695000UL, 0x3fc4549dUL, 0x9f0b8bbbUL, 0x3d1c4b8cUL, 0x538d5800UL,\n-    0x3fc3f881UL, 0xf49df747UL, 0x3cf89b99UL, 0xc8138000UL, 0x3fc39cfcUL,\n-    0xd503b834UL, 0xbd13b99fUL, 0xf0df0800UL, 0x3fc3420dUL, 0xf011b386UL,\n-    0xbd05d8beUL, 0xe7466800UL, 0x3fc2e7b2UL, 0xf39c7bc2UL, 0xbd1bb94eUL,\n-    0xcdd62800UL, 0x3fc28de9UL, 0x05e6d69bUL, 0xbd10ed05UL, 0xd015d800UL,\n-    0x3fc234b0UL, 0xe29b6c9dUL, 0xbd1ff967UL, 0x224ea800UL, 0x3fc1dc06UL,\n-    0x727711fcUL, 0xbcffb30dUL, 0x01540000UL, 0x3fc183e8UL, 0x39786c5aUL,\n-    0x3cc23f57UL, 0xb24d9800UL, 0x3fc12c54UL, 0xc905a342UL, 0x3d003a1dUL,\n-    0x82835800UL, 0x3fc0d54aUL, 0x9b9920c0UL, 0x3d03b25aUL, 0xc72ac000UL,\n-    0x3fc07ec7UL, 0x46f26a24UL, 0x3cf0fa41UL, 0xdd35d800UL, 0x3fc028caUL,\n-    0x41d9d6dcUL, 0x3d034a65UL, 0x52474000UL, 0x3fbfa6a4UL, 0x44f66449UL,\n-    0x3d19cad3UL, 0x2da3d000UL, 0x3fbefcb8UL, 0x67832999UL, 0x3d18400fUL,\n-    0x32a10000UL, 0x3fbe53ceUL, 0x9c0e3b1aUL, 0xbcff62fdUL, 0x556b7000UL,\n-    0x3fbdabe3UL, 0x02976913UL, 0xbcf8243bUL, 0x97e88000UL, 0x3fbd04f4UL,\n-    0xec793797UL, 0x3d1c0578UL, 0x09647000UL, 0x3fbc5effUL, 0x05fc0565UL,\n-    0xbd1d799eUL, 0xc6426000UL, 0x3fbbb9ffUL, 0x4625f5edUL, 0x3d1f5723UL,\n-    0xf7afd000UL, 0x3fbb15f3UL, 0xdd5aae61UL, 0xbd1a7e1eUL, 0xd358b000UL,\n-    0x3fba72d8UL, 0x3314e4d3UL, 0x3d17bc91UL, 0x9b1f5000UL, 0x3fb9d0abUL,\n-    0x9a4d514bUL, 0x3cf18c9bUL, 0x9cd4e000UL, 0x3fb92f69UL, 0x7e4496abUL,\n-    0x3cf1f96dUL, 0x31f4f000UL, 0x3fb88f10UL, 0xf56479e7UL, 0x3d165818UL,\n-    0xbf628000UL, 0x3fb7ef9cUL, 0x26bf486dUL, 0xbd1113a6UL, 0xb526b000UL,\n-    0x3fb7510cUL, 0x1a1c3384UL, 0x3ca9898dUL, 0x8e31e000UL, 0x3fb6b35dUL,\n-    0xb3875361UL, 0xbd0661acUL, 0xd01de000UL, 0x3fb6168cUL, 0x2a7cacfaUL,\n-    0xbd1bdf10UL, 0x0af23000UL, 0x3fb57a98UL, 0xff868816UL, 0x3cf046d0UL,\n-    0xd8ea0000UL, 0x3fb4df7cUL, 0x1515fbe7UL, 0xbd1fd529UL, 0xde3b2000UL,\n-    0x3fb44538UL, 0x6e59a132UL, 0x3d1faeeeUL, 0xc8df9000UL, 0x3fb3abc9UL,\n-    0xf1322361UL, 0xbd198807UL, 0x505f1000UL, 0x3fb3132dUL, 0x0888e6abUL,\n-    0x3d1e5380UL, 0x359bd000UL, 0x3fb27b61UL, 0xdfbcbb22UL, 0xbcfe2724UL,\n-    0x429ee000UL, 0x3fb1e463UL, 0x6eb4c58cUL, 0xbcfe4dd6UL, 0x4a673000UL,\n-    0x3fb14e31UL, 0x4ce1ac9bUL, 0x3d1ba691UL, 0x28b96000UL, 0x3fb0b8c9UL,\n-    0x8c7813b8UL, 0xbd0b3872UL, 0xc1f08000UL, 0x3fb02428UL, 0xc2bc8c2cUL,\n-    0x3cb5ea6bUL, 0x05a1a000UL, 0x3faf209cUL, 0x72e8f18eUL, 0xbce8df84UL,\n-    0xc0b5e000UL, 0x3fadfa6dUL, 0x9fdef436UL, 0x3d087364UL, 0xaf416000UL,\n-    0x3facd5c2UL, 0x1068c3a9UL, 0x3d0827e7UL, 0xdb356000UL, 0x3fabb296UL,\n-    0x120a34d3UL, 0x3d101a9fUL, 0x5dfea000UL, 0x3faa90e6UL, 0xdaded264UL,\n-    0xbd14c392UL, 0x6034c000UL, 0x3fa970adUL, 0x1c9d06a9UL, 0xbd1b705eUL,\n-    0x194c6000UL, 0x3fa851e8UL, 0x83996ad9UL, 0xbd0117bcUL, 0xcf4ac000UL,\n-    0x3fa73492UL, 0xb1a94a62UL, 0xbca5ea42UL, 0xd67b4000UL, 0x3fa618a9UL,\n-    0x75aed8caUL, 0xbd07119bUL, 0x9126c000UL, 0x3fa4fe29UL, 0x5291d533UL,\n-    0x3d12658fUL, 0x6f4d4000UL, 0x3fa3e50eUL, 0xcd2c5cd9UL, 0x3d1d5c70UL,\n-    0xee608000UL, 0x3fa2cd54UL, 0xd1008489UL, 0x3d1a4802UL, 0x9900e000UL,\n-    0x3fa1b6f9UL, 0x54fb5598UL, 0xbd16593fUL, 0x06bb6000UL, 0x3fa0a1f9UL,\n-    0x64ef57b4UL, 0xbd17636bUL, 0xb7940000UL, 0x3f9f1c9fUL, 0xee6a4737UL,\n-    0x3cb5d479UL, 0x91aa0000UL, 0x3f9cf7f5UL, 0x3a16373cUL, 0x3d087114UL,\n-    0x156b8000UL, 0x3f9ad5edUL, 0x836c554aUL, 0x3c6900b0UL, 0xd4764000UL,\n-    0x3f98b67fUL, 0xed12f17bUL, 0xbcffc974UL, 0x77dec000UL, 0x3f9699a7UL,\n-    0x232ce7eaUL, 0x3d1e35bbUL, 0xbfbf4000UL, 0x3f947f5dUL, 0xd84ffa6eUL,\n-    0x3d0e0a49UL, 0x82c7c000UL, 0x3f92679cUL, 0x8d170e90UL, 0xbd14d9f2UL,\n-    0xadd20000UL, 0x3f90525dUL, 0x86d9f88eUL, 0x3cdeb986UL, 0x86f10000UL,\n-    0x3f8c7f36UL, 0xb9e0a517UL, 0x3ce29faaUL, 0xb75c8000UL, 0x3f885e9eUL,\n-    0x542568cbUL, 0xbd1f7bdbUL, 0x46b30000UL, 0x3f8442e8UL, 0xb954e7d9UL,\n-    0x3d1e5287UL, 0xb7e60000UL, 0x3f802c07UL, 0x22da0b17UL, 0xbd19fb27UL,\n-    0x6c8b0000UL, 0x3f7833e3UL, 0x821271efUL, 0xbd190f96UL, 0x29910000UL,\n-    0x3f701936UL, 0xbc3491a5UL, 0xbd1bcf45UL, 0x354a0000UL, 0x3f600fe3UL,\n-    0xc0ff520aUL, 0xbd19d71cUL, 0x00000000UL, 0x00000000UL, 0x00000000UL,\n-    0x00000000UL, 0x509f7800UL, 0x3f934413UL, 0x1f12b358UL, 0x3cdfef31UL,\n-    0xc1a5f12eUL, 0x40358874UL, 0x64d4ef0dUL, 0xc0089309UL, 0x385593b1UL,\n-    0xc025c917UL, 0xdc963467UL, 0x3ffc6a02UL, 0x7f9d3aa1UL, 0x4016ab9fUL,\n-    0xdc77b115UL, 0xbff27af2UL, 0xf8000000UL, 0xffffffffUL, 0x00000000UL,\n-    0xffffe000UL, 0x00000000UL, 0x3fdbc000UL, 0xbf2e4108UL, 0x3f5a7a6cUL\n-};\n-\/\/registers,\n-\/\/ input: xmm0\n-\/\/ scratch: xmm1, xmm2, xmm3, xmm4, xmm5, xmm6, xmm7\n-\/\/          rax, rdx, rcx, rbx (tmp)\n-\n-void MacroAssembler::fast_log10(XMMRegister xmm0, XMMRegister xmm1, XMMRegister xmm2, XMMRegister xmm3,\n-                                XMMRegister xmm4, XMMRegister xmm5, XMMRegister xmm6, XMMRegister xmm7,\n-                                Register eax, Register ecx, Register edx, Register tmp) {\n-\n-  Label L_2TAG_PACKET_0_0_2, L_2TAG_PACKET_1_0_2, L_2TAG_PACKET_2_0_2, L_2TAG_PACKET_3_0_2;\n-  Label L_2TAG_PACKET_4_0_2, L_2TAG_PACKET_5_0_2, L_2TAG_PACKET_6_0_2, L_2TAG_PACKET_7_0_2;\n-  Label L_2TAG_PACKET_8_0_2, L_2TAG_PACKET_9_0_2, L_2TAG_PACKET_10_0_2;\n-\n-  assert_different_registers(tmp, eax, ecx, edx);\n-\n-  address static_const_table_log10 = (address)_static_const_table_log10;\n-\n-  subl(rsp, 104);\n-  movl(Address(rsp, 40), tmp);\n-  lea(tmp, ExternalAddress(static_const_table_log10));\n-  xorpd(xmm2, xmm2);\n-  movl(eax, 16368);\n-  pinsrw(xmm2, eax, 3);\n-  movl(ecx, 1054736384);\n-  movdl(xmm7, ecx);\n-  xorpd(xmm3, xmm3);\n-  movl(edx, 30704);\n-  pinsrw(xmm3, edx, 3);\n-  movsd(xmm0, Address(rsp, 112));\n-  movdqu(xmm1, xmm0);\n-  movl(edx, 32768);\n-  movdl(xmm4, edx);\n-  movdqu(xmm5, Address(tmp, 2128));    \/\/0x3ffc6a02UL, 0x7f9d3aa1UL, 0x4016ab9fUL, 0xdc77b115UL\n-  pextrw(eax, xmm0, 3);\n-  por(xmm0, xmm2);\n-  movl(ecx, 16352);\n-  psllq(xmm0, 5);\n-  movsd(xmm2, Address(tmp, 2144));    \/\/0xbff27af2UL, 0xf8000000UL, 0xffffffffUL, 0x00000000UL\n-  psrlq(xmm0, 34);\n-  rcpss(xmm0, xmm0);\n-  psllq(xmm1, 12);\n-  pshufd(xmm6, xmm5, 78);\n-  psrlq(xmm1, 12);\n-  subl(eax, 16);\n-  cmpl(eax, 32736);\n-  jcc(Assembler::aboveEqual, L_2TAG_PACKET_0_0_2);\n-\n-  bind(L_2TAG_PACKET_1_0_2);\n-  mulss(xmm0, xmm7);\n-  por(xmm1, xmm3);\n-  andpd(xmm5, xmm1);\n-  paddd(xmm0, xmm4);\n-  subsd(xmm1, xmm5);\n-  movdl(edx, xmm0);\n-  psllq(xmm0, 29);\n-  andpd(xmm0, xmm6);\n-  andl(eax, 32752);\n-  subl(eax, ecx);\n-  cvtsi2sdl(xmm7, eax);\n-  mulpd(xmm5, xmm0);\n-  mulsd(xmm1, xmm0);\n-  movsd(xmm6, Address(tmp, 2064));    \/\/0xbd19d71cUL, 0x00000000UL, 0x00000000UL, 0x00000000UL\n-  movdqu(xmm3, Address(tmp, 2080));    \/\/0x00000000UL, 0x509f7800UL, 0x3f934413UL, 0x1f12b358UL\n-  subsd(xmm5, xmm2);\n-  andl(edx, 16711680);\n-  shrl(edx, 12);\n-  movdqu(xmm0, Address(tmp, edx, Address::times_1, -1504));\n-  movdqu(xmm4, Address(tmp, 2096));    \/\/0x3cdfef31UL, 0xc1a5f12eUL, 0x40358874UL, 0x64d4ef0dUL\n-  addsd(xmm1, xmm5);\n-  movdqu(xmm2, Address(tmp, 2112));    \/\/0xc0089309UL, 0x385593b1UL, 0xc025c917UL, 0xdc963467UL\n-  mulsd(xmm6, xmm7);\n-  pshufd(xmm5, xmm1, 68);\n-  mulsd(xmm7, Address(tmp, 2072));    \/\/0x00000000UL, 0x00000000UL, 0x00000000UL, 0x509f7800UL\n-  mulsd(xmm3, xmm1);\n-  addsd(xmm0, xmm6);\n-  mulpd(xmm4, xmm5);\n-  movsd(xmm6, Address(tmp, 2152));    \/\/0xffffffffUL, 0x00000000UL, 0xffffe000UL, 0x00000000UL\n-  mulpd(xmm5, xmm5);\n-  addpd(xmm4, xmm2);\n-  mulpd(xmm3, xmm5);\n-  pshufd(xmm2, xmm0, 228);\n-  addsd(xmm0, xmm1);\n-  mulsd(xmm4, xmm1);\n-  subsd(xmm2, xmm0);\n-  mulsd(xmm6, xmm1);\n-  addsd(xmm1, xmm2);\n-  pshufd(xmm2, xmm0, 238);\n-  mulsd(xmm5, xmm5);\n-  addsd(xmm7, xmm2);\n-  addsd(xmm1, xmm6);\n-  addpd(xmm4, xmm3);\n-  addsd(xmm1, xmm7);\n-  mulpd(xmm4, xmm5);\n-  addsd(xmm1, xmm4);\n-  pshufd(xmm5, xmm4, 238);\n-  addsd(xmm1, xmm5);\n-  addsd(xmm0, xmm1);\n-  jmp(L_2TAG_PACKET_2_0_2);\n-\n-  bind(L_2TAG_PACKET_0_0_2);\n-  movsd(xmm0, Address(rsp, 112));    \/\/0xbcfa1d84UL, 0x6baa7c00UL, 0x3fd28651UL, 0xfd9abec1UL\n-  movdqu(xmm1, xmm0);\n-  addl(eax, 16);\n-  cmpl(eax, 32768);\n-  jcc(Assembler::aboveEqual, L_2TAG_PACKET_3_0_2);\n-  cmpl(eax, 16);\n-  jcc(Assembler::below, L_2TAG_PACKET_4_0_2);\n-\n-  bind(L_2TAG_PACKET_5_0_2);\n-  addsd(xmm0, xmm0);\n-  jmp(L_2TAG_PACKET_2_0_2);\n-\n-  bind(L_2TAG_PACKET_6_0_2);\n-  jcc(Assembler::above, L_2TAG_PACKET_5_0_2);\n-  cmpl(edx, 0);\n-  jcc(Assembler::above, L_2TAG_PACKET_5_0_2);\n-  jmp(L_2TAG_PACKET_7_0_2);\n-\n-  bind(L_2TAG_PACKET_3_0_2);\n-  movdl(edx, xmm1);\n-  psrlq(xmm1, 32);\n-  movdl(ecx, xmm1);\n-  addl(ecx, ecx);\n-  cmpl(ecx, -2097152);\n-  jcc(Assembler::aboveEqual, L_2TAG_PACKET_6_0_2);\n-  orl(edx, ecx);\n-  cmpl(edx, 0);\n-  jcc(Assembler::equal, L_2TAG_PACKET_8_0_2);\n-\n-  bind(L_2TAG_PACKET_7_0_2);\n-  xorpd(xmm1, xmm1);\n-  xorpd(xmm0, xmm0);\n-  movl(eax, 32752);\n-  pinsrw(xmm1, eax, 3);\n-  movl(edx, 9);\n-  mulsd(xmm0, xmm1);\n-\n-  bind(L_2TAG_PACKET_9_0_2);\n-  movsd(Address(rsp, 0), xmm0);\n-  movsd(xmm0, Address(rsp, 112));    \/\/0xbcfa1d84UL, 0x6baa7c00UL, 0x3fd28651UL, 0xfd9abec1UL\n-  fld_d(Address(rsp, 0));\n-  jmp(L_2TAG_PACKET_10_0_2);\n-\n-  bind(L_2TAG_PACKET_8_0_2);\n-  xorpd(xmm1, xmm1);\n-  xorpd(xmm0, xmm0);\n-  movl(eax, 49136);\n-  pinsrw(xmm0, eax, 3);\n-  divsd(xmm0, xmm1);\n-  movl(edx, 8);\n-  jmp(L_2TAG_PACKET_9_0_2);\n-\n-  bind(L_2TAG_PACKET_4_0_2);\n-  movdl(edx, xmm1);\n-  psrlq(xmm1, 32);\n-  movdl(ecx, xmm1);\n-  orl(edx, ecx);\n-  cmpl(edx, 0);\n-  jcc(Assembler::equal, L_2TAG_PACKET_8_0_2);\n-  xorpd(xmm1, xmm1);\n-  movl(eax, 18416);\n-  pinsrw(xmm1, eax, 3);\n-  mulsd(xmm0, xmm1);\n-  xorpd(xmm2, xmm2);\n-  movl(eax, 16368);\n-  pinsrw(xmm2, eax, 3);\n-  movdqu(xmm1, xmm0);\n-  pextrw(eax, xmm0, 3);\n-  por(xmm0, xmm2);\n-  movl(ecx, 18416);\n-  psllq(xmm0, 5);\n-  movsd(xmm2, Address(tmp, 2144));    \/\/0xbff27af2UL, 0xf8000000UL, 0xffffffffUL, 0x00000000UL\n-  psrlq(xmm0, 34);\n-  rcpss(xmm0, xmm0);\n-  psllq(xmm1, 12);\n-  pshufd(xmm6, xmm5, 78);\n-  psrlq(xmm1, 12);\n-  jmp(L_2TAG_PACKET_1_0_2);\n-\n-  bind(L_2TAG_PACKET_2_0_2);\n-  movsd(Address(rsp, 24), xmm0);\n-  fld_d(Address(rsp, 24));\n-\n-  bind(L_2TAG_PACKET_10_0_2);\n-  movl(tmp, Address(rsp, 40));\n-\n-}\n-#endif\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86_log10.cpp","additions":0,"deletions":684,"binary":false,"changes":684,"status":"deleted"},{"patch":"@@ -1,3653 +0,0 @@\n-\/*\n-* Copyright (c) 2016, 2021, Intel Corporation. All rights reserved.\n-* Copyright (C) 2021 THL A29 Limited, a Tencent company. All rights reserved.\n-* Intel Math Library (LIBM) Source Code\n-*\n-* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-*\n-* This code is free software; you can redistribute it and\/or modify it\n-* under the terms of the GNU General Public License version 2 only, as\n-* published by the Free Software Foundation.\n-*\n-* This code is distributed in the hope that it will be useful, but WITHOUT\n-* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-* FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-* version 2 for more details (a copy is included in the LICENSE file that\n-* accompanied this code).\n-*\n-* You should have received a copy of the GNU General Public License version\n-* 2 along with this work; if not, write to the Free Software Foundation,\n-* Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-*\n-* Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-* or visit www.oracle.com if you need additional information or have any\n-* questions.\n-*\n-*\/\n-\n-#include \"precompiled.hpp\"\n-#include \"asm\/assembler.hpp\"\n-#include \"asm\/assembler.inline.hpp\"\n-#include \"macroAssembler_x86.hpp\"\n-#include \"runtime\/stubRoutines.hpp\"\n-#include \"utilities\/globalDefinitions.hpp\"\n-\n-\/******************************************************************************\/\n-\/\/                     ALGORITHM DESCRIPTION  - POW()\n-\/\/                     ---------------------\n-\/\/\n-\/\/    Let x=2^k * mx, mx in [1,2)\n-\/\/\n-\/\/    log2(x) calculation:\n-\/\/\n-\/\/    Get B~1\/mx based on the output of rcpps instruction (B0)\n-\/\/    B = int((B0*LH*2^9+0.5))\/2^9\n-\/\/    LH is a short approximation for log2(e)\n-\/\/\n-\/\/    Reduced argument, scaled by LH:\n-\/\/                r=B*mx-LH (computed accurately in high and low parts)\n-\/\/\n-\/\/    log2(x) result:  k - log2(B) + p(r)\n-\/\/             p(r) is a degree 8 polynomial\n-\/\/             -log2(B) read from data table (high, low parts)\n-\/\/             log2(x) is formed from high and low parts\n-\/\/    For |x| in [1-1\/32, 1+1\/16), a slower but more accurate computation\n-\/\/    based om the same table design is performed.\n-\/\/\n-\/\/   Main path is taken if | floor(log2(|log2(|x|)|) + floor(log2|y|) | < 8,\n-\/\/   to filter out all potential OF\/UF cases.\n-\/\/   exp2(y*log2(x)) is computed using an 8-bit index table and a degree 5\n-\/\/   polynomial\n-\/\/\n-\/\/ Special cases:\n-\/\/  pow(-0,y) = -INF and raises the divide-by-zero exception for y an odd\n-\/\/  integer < 0.\n-\/\/  pow(-0,y) = +INF and raises the divide-by-zero exception for y < 0 and\n-\/\/  not an odd integer.\n-\/\/  pow(-0,y) = -0 for y an odd integer > 0.\n-\/\/  pow(-0,y) = +0 for y > 0 and not an odd integer.\n-\/\/  pow(-1,-INF) = NaN.\n-\/\/  pow(+1,y) = NaN for any y, even a NaN.\n-\/\/  pow(x,-0) = 1 for any x, even a NaN.\n-\/\/  pow(x,y) = a NaN and raises the invalid exception for finite x < 0 and\n-\/\/  finite non-integer y.\n-\/\/  pow(x,-INF) = +INF for |x|<1.\n-\/\/  pow(x,-INF) = +0 for |x|>1.\n-\/\/  pow(x,+INF) = +0 for |x|<1.\n-\/\/  pow(x,+INF) = +INF for |x|>1.\n-\/\/  pow(-INF,y) = -0 for y an odd integer < 0.\n-\/\/  pow(-INF,y) = +0 for y < 0 and not an odd integer.\n-\/\/  pow(-INF,y) = -INF for y an odd integer > 0.\n-\/\/  pow(-INF,y) = +INF for y > 0 and not an odd integer.\n-\/\/  pow(+INF,y) = +0 for y <0.\n-\/\/  pow(+INF,y) = +INF for y >0.\n-\/\/\n-\/******************************************************************************\/\n-\n-#ifdef _LP64\n-\/\/ The 64 bit code is at most SSE2 compliant\n-ATTRIBUTE_ALIGNED(16) juint _HIGHSIGMASK[] =\n-{\n-    0x00000000UL, 0xfffff800UL, 0x00000000UL, 0xfffff800UL\n-};\n-\n-ATTRIBUTE_ALIGNED(16) juint _LOG2_E[] =\n-{\n-    0x00000000UL, 0x3ff72000UL, 0x161bb241UL, 0xbf5dabe1UL\n-};\n-\n-ATTRIBUTE_ALIGNED(16) juint _HIGHMASK_Y[] =\n-{\n-    0x00000000UL, 0xfffffff8UL, 0x00000000UL, 0xffffffffUL\n-};\n-\n-ATTRIBUTE_ALIGNED(16) juint _T_exp[] =\n-{\n-    0x00000000UL, 0x3ff00000UL, 0x00000000UL, 0x3b700000UL, 0xfa5abcbfUL,\n-    0x3ff00b1aUL, 0xa7609f71UL, 0xbc84f6b2UL, 0xa9fb3335UL, 0x3ff0163dUL,\n-    0x9ab8cdb7UL, 0x3c9b6129UL, 0x143b0281UL, 0x3ff02168UL, 0x0fc54eb6UL,\n-    0xbc82bf31UL, 0x3e778061UL, 0x3ff02c9aUL, 0x535b085dUL, 0xbc719083UL,\n-    0x2e11bbccUL, 0x3ff037d4UL, 0xeeade11aUL, 0x3c656811UL, 0xe86e7f85UL,\n-    0x3ff04315UL, 0x1977c96eUL, 0xbc90a31cUL, 0x72f654b1UL, 0x3ff04e5fUL,\n-    0x3aa0d08cUL, 0x3c84c379UL, 0xd3158574UL, 0x3ff059b0UL, 0xa475b465UL,\n-    0x3c8d73e2UL, 0x0e3c1f89UL, 0x3ff0650aUL, 0x5799c397UL, 0xbc95cb7bUL,\n-    0x29ddf6deUL, 0x3ff0706bUL, 0xe2b13c27UL, 0xbc8c91dfUL, 0x2b72a836UL,\n-    0x3ff07bd4UL, 0x54458700UL, 0x3c832334UL, 0x18759bc8UL, 0x3ff08745UL,\n-    0x4bb284ffUL, 0x3c6186beUL, 0xf66607e0UL, 0x3ff092bdUL, 0x800a3fd1UL,\n-    0xbc968063UL, 0xcac6f383UL, 0x3ff09e3eUL, 0x18316136UL, 0x3c914878UL,\n-    0x9b1f3919UL, 0x3ff0a9c7UL, 0x873d1d38UL, 0x3c85d16cUL, 0x6cf9890fUL,\n-    0x3ff0b558UL, 0x4adc610bUL, 0x3c98a62eUL, 0x45e46c85UL, 0x3ff0c0f1UL,\n-    0x06d21cefUL, 0x3c94f989UL, 0x2b7247f7UL, 0x3ff0cc92UL, 0x16e24f71UL,\n-    0x3c901edcUL, 0x23395decUL, 0x3ff0d83bUL, 0xe43f316aUL, 0xbc9bc14dUL,\n-    0x32d3d1a2UL, 0x3ff0e3ecUL, 0x27c57b52UL, 0x3c403a17UL, 0x5fdfa9c5UL,\n-    0x3ff0efa5UL, 0xbc54021bUL, 0xbc949db9UL, 0xaffed31bUL, 0x3ff0fb66UL,\n-    0xc44ebd7bUL, 0xbc6b9bedUL, 0x28d7233eUL, 0x3ff10730UL, 0x1692fdd5UL,\n-    0x3c8d46ebUL, 0xd0125b51UL, 0x3ff11301UL, 0x39449b3aUL, 0xbc96c510UL,\n-    0xab5e2ab6UL, 0x3ff11edbUL, 0xf703fb72UL, 0xbc9ca454UL, 0xc06c31ccUL,\n-    0x3ff12abdUL, 0xb36ca5c7UL, 0xbc51b514UL, 0x14f204abUL, 0x3ff136a8UL,\n-    0xba48dcf0UL, 0xbc67108fUL, 0xaea92de0UL, 0x3ff1429aUL, 0x9af1369eUL,\n-    0xbc932fbfUL, 0x934f312eUL, 0x3ff14e95UL, 0x39bf44abUL, 0xbc8b91e8UL,\n-    0xc8a58e51UL, 0x3ff15a98UL, 0xb9eeab0aUL, 0x3c82406aUL, 0x5471c3c2UL,\n-    0x3ff166a4UL, 0x82ea1a32UL, 0x3c58f23bUL, 0x3c7d517bUL, 0x3ff172b8UL,\n-    0xb9d78a76UL, 0xbc819041UL, 0x8695bbc0UL, 0x3ff17ed4UL, 0xe2ac5a64UL,\n-    0x3c709e3fUL, 0x388c8deaUL, 0x3ff18af9UL, 0xd1970f6cUL, 0xbc911023UL,\n-    0x58375d2fUL, 0x3ff19726UL, 0x85f17e08UL, 0x3c94aaddUL, 0xeb6fcb75UL,\n-    0x3ff1a35bUL, 0x7b4968e4UL, 0x3c8e5b4cUL, 0xf8138a1cUL, 0x3ff1af99UL,\n-    0xa4b69280UL, 0x3c97bf85UL, 0x84045cd4UL, 0x3ff1bbe0UL, 0x352ef607UL,\n-    0xbc995386UL, 0x95281c6bUL, 0x3ff1c82fUL, 0x8010f8c9UL, 0x3c900977UL,\n-    0x3168b9aaUL, 0x3ff1d487UL, 0x00a2643cUL, 0x3c9e016eUL, 0x5eb44027UL,\n-    0x3ff1e0e7UL, 0x088cb6deUL, 0xbc96fdd8UL, 0x22fcd91dUL, 0x3ff1ed50UL,\n-    0x027bb78cUL, 0xbc91df98UL, 0x8438ce4dUL, 0x3ff1f9c1UL, 0xa097af5cUL,\n-    0xbc9bf524UL, 0x88628cd6UL, 0x3ff2063bUL, 0x814a8495UL, 0x3c8dc775UL,\n-    0x3578a819UL, 0x3ff212beUL, 0x2cfcaac9UL, 0x3c93592dUL, 0x917ddc96UL,\n-    0x3ff21f49UL, 0x9494a5eeUL, 0x3c82a97eUL, 0xa27912d1UL, 0x3ff22bddUL,\n-    0x5577d69fUL, 0x3c8d34fbUL, 0x6e756238UL, 0x3ff2387aUL, 0xb6c70573UL,\n-    0x3c99b07eUL, 0xfb82140aUL, 0x3ff2451fUL, 0x911ca996UL, 0x3c8acfccUL,\n-    0x4fb2a63fUL, 0x3ff251ceUL, 0xbef4f4a4UL, 0x3c8ac155UL, 0x711ece75UL,\n-    0x3ff25e85UL, 0x4ac31b2cUL, 0x3c93e1a2UL, 0x65e27cddUL, 0x3ff26b45UL,\n-    0x9940e9d9UL, 0x3c82bd33UL, 0x341ddf29UL, 0x3ff2780eUL, 0x05f9e76cUL,\n-    0x3c9e067cUL, 0xe1f56381UL, 0x3ff284dfUL, 0x8c3f0d7eUL, 0xbc9a4c3aUL,\n-    0x7591bb70UL, 0x3ff291baUL, 0x28401cbdUL, 0xbc82cc72UL, 0xf51fdee1UL,\n-    0x3ff29e9dUL, 0xafad1255UL, 0x3c8612e8UL, 0x66d10f13UL, 0x3ff2ab8aUL,\n-    0x191690a7UL, 0xbc995743UL, 0xd0dad990UL, 0x3ff2b87fUL, 0xd6381aa4UL,\n-    0xbc410adcUL, 0x39771b2fUL, 0x3ff2c57eUL, 0xa6eb5124UL, 0xbc950145UL,\n-    0xa6e4030bUL, 0x3ff2d285UL, 0x54db41d5UL, 0x3c900247UL, 0x1f641589UL,\n-    0x3ff2df96UL, 0xfbbce198UL, 0x3c9d16cfUL, 0xa93e2f56UL, 0x3ff2ecafUL,\n-    0x45d52383UL, 0x3c71ca0fUL, 0x4abd886bUL, 0x3ff2f9d2UL, 0x532bda93UL,\n-    0xbc653c55UL, 0x0a31b715UL, 0x3ff306feUL, 0xd23182e4UL, 0x3c86f46aUL,\n-    0xedeeb2fdUL, 0x3ff31432UL, 0xf3f3fcd1UL, 0x3c8959a3UL, 0xfc4cd831UL,\n-    0x3ff32170UL, 0x8e18047cUL, 0x3c8a9ce7UL, 0x3ba8ea32UL, 0x3ff32eb8UL,\n-    0x3cb4f318UL, 0xbc9c45e8UL, 0xb26416ffUL, 0x3ff33c08UL, 0x843659a6UL,\n-    0x3c932721UL, 0x66e3fa2dUL, 0x3ff34962UL, 0x930881a4UL, 0xbc835a75UL,\n-    0x5f929ff1UL, 0x3ff356c5UL, 0x5c4e4628UL, 0xbc8b5ceeUL, 0xa2de883bUL,\n-    0x3ff36431UL, 0xa06cb85eUL, 0xbc8c3144UL, 0x373aa9cbUL, 0x3ff371a7UL,\n-    0xbf42eae2UL, 0xbc963aeaUL, 0x231e754aUL, 0x3ff37f26UL, 0x9eceb23cUL,\n-    0xbc99f5caUL, 0x6d05d866UL, 0x3ff38caeUL, 0x3c9904bdUL, 0xbc9e958dUL,\n-    0x1b7140efUL, 0x3ff39a40UL, 0xfc8e2934UL, 0xbc99a9a5UL, 0x34e59ff7UL,\n-    0x3ff3a7dbUL, 0xd661f5e3UL, 0xbc75e436UL, 0xbfec6cf4UL, 0x3ff3b57fUL,\n-    0xe26fff18UL, 0x3c954c66UL, 0xc313a8e5UL, 0x3ff3c32dUL, 0x375d29c3UL,\n-    0xbc9efff8UL, 0x44ede173UL, 0x3ff3d0e5UL, 0x8c284c71UL, 0x3c7fe8d0UL,\n-    0x4c123422UL, 0x3ff3dea6UL, 0x11f09ebcUL, 0x3c8ada09UL, 0xdf1c5175UL,\n-    0x3ff3ec70UL, 0x7b8c9bcaUL, 0xbc8af663UL, 0x04ac801cUL, 0x3ff3fa45UL,\n-    0xf956f9f3UL, 0xbc97d023UL, 0xc367a024UL, 0x3ff40822UL, 0xb6f4d048UL,\n-    0x3c8bddf8UL, 0x21f72e2aUL, 0x3ff4160aUL, 0x1c309278UL, 0xbc5ef369UL,\n-    0x2709468aUL, 0x3ff423fbUL, 0xc0b314ddUL, 0xbc98462dUL, 0xd950a897UL,\n-    0x3ff431f5UL, 0xe35f7999UL, 0xbc81c7ddUL, 0x3f84b9d4UL, 0x3ff43ffaUL,\n-    0x9704c003UL, 0x3c8880beUL, 0x6061892dUL, 0x3ff44e08UL, 0x04ef80d0UL,\n-    0x3c489b7aUL, 0x42a7d232UL, 0x3ff45c20UL, 0x82fb1f8eUL, 0xbc686419UL,\n-    0xed1d0057UL, 0x3ff46a41UL, 0xd1648a76UL, 0x3c9c944bUL, 0x668b3237UL,\n-    0x3ff4786dUL, 0xed445733UL, 0xbc9c20f0UL, 0xb5c13cd0UL, 0x3ff486a2UL,\n-    0xb69062f0UL, 0x3c73c1a3UL, 0xe192aed2UL, 0x3ff494e1UL, 0x5e499ea0UL,\n-    0xbc83b289UL, 0xf0d7d3deUL, 0x3ff4a32aUL, 0xf3d1be56UL, 0x3c99cb62UL,\n-    0xea6db7d7UL, 0x3ff4b17dUL, 0x7f2897f0UL, 0xbc8125b8UL, 0xd5362a27UL,\n-    0x3ff4bfdaUL, 0xafec42e2UL, 0x3c7d4397UL, 0xb817c114UL, 0x3ff4ce41UL,\n-    0x690abd5dUL, 0x3c905e29UL, 0x99fddd0dUL, 0x3ff4dcb2UL, 0xbc6a7833UL,\n-    0x3c98ecdbUL, 0x81d8abffUL, 0x3ff4eb2dUL, 0x2e5d7a52UL, 0xbc95257dUL,\n-    0x769d2ca7UL, 0x3ff4f9b2UL, 0xd25957e3UL, 0xbc94b309UL, 0x7f4531eeUL,\n-    0x3ff50841UL, 0x49b7465fUL, 0x3c7a249bUL, 0xa2cf6642UL, 0x3ff516daUL,\n-    0x69bd93efUL, 0xbc8f7685UL, 0xe83f4eefUL, 0x3ff5257dUL, 0x43efef71UL,\n-    0xbc7c998dUL, 0x569d4f82UL, 0x3ff5342bUL, 0x1db13cadUL, 0xbc807abeUL,\n-    0xf4f6ad27UL, 0x3ff542e2UL, 0x192d5f7eUL, 0x3c87926dUL, 0xca5d920fUL,\n-    0x3ff551a4UL, 0xefede59bUL, 0xbc8d689cUL, 0xdde910d2UL, 0x3ff56070UL,\n-    0x168eebf0UL, 0xbc90fb6eUL, 0x36b527daUL, 0x3ff56f47UL, 0x011d93adUL,\n-    0x3c99bb2cUL, 0xdbe2c4cfUL, 0x3ff57e27UL, 0x8a57b9c4UL, 0xbc90b98cUL,\n-    0xd497c7fdUL, 0x3ff58d12UL, 0x5b9a1de8UL, 0x3c8295e1UL, 0x27ff07ccUL,\n-    0x3ff59c08UL, 0xe467e60fUL, 0xbc97e2ceUL, 0xdd485429UL, 0x3ff5ab07UL,\n-    0x054647adUL, 0x3c96324cUL, 0xfba87a03UL, 0x3ff5ba11UL, 0x4c233e1aUL,\n-    0xbc9b77a1UL, 0x8a5946b7UL, 0x3ff5c926UL, 0x816986a2UL, 0x3c3c4b1bUL,\n-    0x90998b93UL, 0x3ff5d845UL, 0xa8b45643UL, 0xbc9cd6a7UL, 0x15ad2148UL,\n-    0x3ff5e76fUL, 0x3080e65eUL, 0x3c9ba6f9UL, 0x20dceb71UL, 0x3ff5f6a3UL,\n-    0xe3cdcf92UL, 0xbc89eaddUL, 0xb976dc09UL, 0x3ff605e1UL, 0x9b56de47UL,\n-    0xbc93e242UL, 0xe6cdf6f4UL, 0x3ff6152aUL, 0x4ab84c27UL, 0x3c9e4b3eUL,\n-    0xb03a5585UL, 0x3ff6247eUL, 0x7e40b497UL, 0xbc9383c1UL, 0x1d1929fdUL,\n-    0x3ff633ddUL, 0xbeb964e5UL, 0x3c984710UL, 0x34ccc320UL, 0x3ff64346UL,\n-    0x759d8933UL, 0xbc8c483cUL, 0xfebc8fb7UL, 0x3ff652b9UL, 0xc9a73e09UL,\n-    0xbc9ae3d5UL, 0x82552225UL, 0x3ff66238UL, 0x87591c34UL, 0xbc9bb609UL,\n-    0xc70833f6UL, 0x3ff671c1UL, 0x586c6134UL, 0xbc8e8732UL, 0xd44ca973UL,\n-    0x3ff68155UL, 0x44f73e65UL, 0x3c6038aeUL, 0xb19e9538UL, 0x3ff690f4UL,\n-    0x9aeb445dUL, 0x3c8804bdUL, 0x667f3bcdUL, 0x3ff6a09eUL, 0x13b26456UL,\n-    0xbc9bdd34UL, 0xfa75173eUL, 0x3ff6b052UL, 0x2c9a9d0eUL, 0x3c7a38f5UL,\n-    0x750bdabfUL, 0x3ff6c012UL, 0x67ff0b0dUL, 0xbc728956UL, 0xddd47645UL,\n-    0x3ff6cfdcUL, 0xb6f17309UL, 0x3c9c7aa9UL, 0x3c651a2fUL, 0x3ff6dfb2UL,\n-    0x683c88abUL, 0xbc6bbe3aUL, 0x98593ae5UL, 0x3ff6ef92UL, 0x9e1ac8b2UL,\n-    0xbc90b974UL, 0xf9519484UL, 0x3ff6ff7dUL, 0x25860ef6UL, 0xbc883c0fUL,\n-    0x66f42e87UL, 0x3ff70f74UL, 0xd45aa65fUL, 0x3c59d644UL, 0xe8ec5f74UL,\n-    0x3ff71f75UL, 0x86887a99UL, 0xbc816e47UL, 0x86ead08aUL, 0x3ff72f82UL,\n-    0x2cd62c72UL, 0xbc920aa0UL, 0x48a58174UL, 0x3ff73f9aUL, 0x6c65d53cUL,\n-    0xbc90a8d9UL, 0x35d7cbfdUL, 0x3ff74fbdUL, 0x618a6e1cUL, 0x3c9047fdUL,\n-    0x564267c9UL, 0x3ff75febUL, 0x57316dd3UL, 0xbc902459UL, 0xb1ab6e09UL,\n-    0x3ff77024UL, 0x169147f8UL, 0x3c9b7877UL, 0x4fde5d3fUL, 0x3ff78069UL,\n-    0x0a02162dUL, 0x3c9866b8UL, 0x38ac1cf6UL, 0x3ff790b9UL, 0x62aadd3eUL,\n-    0x3c9349a8UL, 0x73eb0187UL, 0x3ff7a114UL, 0xee04992fUL, 0xbc841577UL,\n-    0x0976cfdbUL, 0x3ff7b17bUL, 0x8468dc88UL, 0xbc9bebb5UL, 0x0130c132UL,\n-    0x3ff7c1edUL, 0xd1164dd6UL, 0x3c9f124cUL, 0x62ff86f0UL, 0x3ff7d26aUL,\n-    0xfb72b8b4UL, 0x3c91bddbUL, 0x36cf4e62UL, 0x3ff7e2f3UL, 0xba15797eUL,\n-    0x3c705d02UL, 0x8491c491UL, 0x3ff7f387UL, 0xcf9311aeUL, 0xbc807f11UL,\n-    0x543e1a12UL, 0x3ff80427UL, 0x626d972bUL, 0xbc927c86UL, 0xadd106d9UL,\n-    0x3ff814d2UL, 0x0d151d4dUL, 0x3c946437UL, 0x994cce13UL, 0x3ff82589UL,\n-    0xd41532d8UL, 0xbc9d4c1dUL, 0x1eb941f7UL, 0x3ff8364cUL, 0x31df2bd5UL,\n-    0x3c999b9aUL, 0x4623c7adUL, 0x3ff8471aUL, 0xa341cdfbUL, 0xbc88d684UL,\n-    0x179f5b21UL, 0x3ff857f4UL, 0xf8b216d0UL, 0xbc5ba748UL, 0x9b4492edUL,\n-    0x3ff868d9UL, 0x9bd4f6baUL, 0xbc9fc6f8UL, 0xd931a436UL, 0x3ff879caUL,\n-    0xd2db47bdUL, 0x3c85d2d7UL, 0xd98a6699UL, 0x3ff88ac7UL, 0xf37cb53aUL,\n-    0x3c9994c2UL, 0xa478580fUL, 0x3ff89bd0UL, 0x4475202aUL, 0x3c9d5395UL,\n-    0x422aa0dbUL, 0x3ff8ace5UL, 0x56864b27UL, 0x3c96e9f1UL, 0xbad61778UL,\n-    0x3ff8be05UL, 0xfc43446eUL, 0x3c9ecb5eUL, 0x16b5448cUL, 0x3ff8cf32UL,\n-    0x32e9e3aaUL, 0xbc70d55eUL, 0x5e0866d9UL, 0x3ff8e06aUL, 0x6fc9b2e6UL,\n-    0xbc97114aUL, 0x99157736UL, 0x3ff8f1aeUL, 0xa2e3976cUL, 0x3c85cc13UL,\n-    0xd0282c8aUL, 0x3ff902feUL, 0x85fe3fd2UL, 0x3c9592caUL, 0x0b91ffc6UL,\n-    0x3ff9145bUL, 0x2e582524UL, 0xbc9dd679UL, 0x53aa2fe2UL, 0x3ff925c3UL,\n-    0xa639db7fUL, 0xbc83455fUL, 0xb0cdc5e5UL, 0x3ff93737UL, 0x81b57ebcUL,\n-    0xbc675fc7UL, 0x2b5f98e5UL, 0x3ff948b8UL, 0x797d2d99UL, 0xbc8dc3d6UL,\n-    0xcbc8520fUL, 0x3ff95a44UL, 0x96a5f039UL, 0xbc764b7cUL, 0x9a7670b3UL,\n-    0x3ff96bddUL, 0x7f19c896UL, 0xbc5ba596UL, 0x9fde4e50UL, 0x3ff97d82UL,\n-    0x7c1b85d1UL, 0xbc9d185bUL, 0xe47a22a2UL, 0x3ff98f33UL, 0xa24c78ecUL,\n-    0x3c7cabdaUL, 0x70ca07baUL, 0x3ff9a0f1UL, 0x91cee632UL, 0xbc9173bdUL,\n-    0x4d53fe0dUL, 0x3ff9b2bbUL, 0x4df6d518UL, 0xbc9dd84eUL, 0x82a3f090UL,\n-    0x3ff9c491UL, 0xb071f2beUL, 0x3c7c7c46UL, 0x194bb8d5UL, 0x3ff9d674UL,\n-    0xa3dd8233UL, 0xbc9516beUL, 0x19e32323UL, 0x3ff9e863UL, 0x78e64c6eUL,\n-    0x3c7824caUL, 0x8d07f29eUL, 0x3ff9fa5eUL, 0xaaf1faceUL, 0xbc84a9ceUL,\n-    0x7b5de565UL, 0x3ffa0c66UL, 0x5d1cd533UL, 0xbc935949UL, 0xed8eb8bbUL,\n-    0x3ffa1e7aUL, 0xee8be70eUL, 0x3c9c6618UL, 0xec4a2d33UL, 0x3ffa309bUL,\n-    0x7ddc36abUL, 0x3c96305cUL, 0x80460ad8UL, 0x3ffa42c9UL, 0x589fb120UL,\n-    0xbc9aa780UL, 0xb23e255dUL, 0x3ffa5503UL, 0xdb8d41e1UL, 0xbc9d2f6eUL,\n-    0x8af46052UL, 0x3ffa674aUL, 0x30670366UL, 0x3c650f56UL, 0x1330b358UL,\n-    0x3ffa799eUL, 0xcac563c7UL, 0x3c9bcb7eUL, 0x53c12e59UL, 0x3ffa8bfeUL,\n-    0xb2ba15a9UL, 0xbc94f867UL, 0x5579fdbfUL, 0x3ffa9e6bUL, 0x0ef7fd31UL,\n-    0x3c90fac9UL, 0x21356ebaUL, 0x3ffab0e5UL, 0xdae94545UL, 0x3c889c31UL,\n-    0xbfd3f37aUL, 0x3ffac36bUL, 0xcae76cd0UL, 0xbc8f9234UL, 0x3a3c2774UL,\n-    0x3ffad5ffUL, 0xb6b1b8e5UL, 0x3c97ef3bUL, 0x995ad3adUL, 0x3ffae89fUL,\n-    0x345dcc81UL, 0x3c97a1cdUL, 0xe622f2ffUL, 0x3ffafb4cUL, 0x0f315ecdUL,\n-    0xbc94b2fcUL, 0x298db666UL, 0x3ffb0e07UL, 0x4c80e425UL, 0xbc9bdef5UL,\n-    0x6c9a8952UL, 0x3ffb20ceUL, 0x4a0756ccUL, 0x3c94dd02UL, 0xb84f15fbUL,\n-    0x3ffb33a2UL, 0x3084d708UL, 0xbc62805eUL, 0x15b749b1UL, 0x3ffb4684UL,\n-    0xe9df7c90UL, 0xbc7f763dUL, 0x8de5593aUL, 0x3ffb5972UL, 0xbbba6de3UL,\n-    0xbc9c71dfUL, 0x29f1c52aUL, 0x3ffb6c6eUL, 0x52883f6eUL, 0x3c92a8f3UL,\n-    0xf2fb5e47UL, 0x3ffb7f76UL, 0x7e54ac3bUL, 0xbc75584fUL, 0xf22749e4UL,\n-    0x3ffb928cUL, 0x54cb65c6UL, 0xbc9b7216UL, 0x30a1064aUL, 0x3ffba5b0UL,\n-    0x0e54292eUL, 0xbc9efcd3UL, 0xb79a6f1fUL, 0x3ffbb8e0UL, 0xc9696205UL,\n-    0xbc3f52d1UL, 0x904bc1d2UL, 0x3ffbcc1eUL, 0x7a2d9e84UL, 0x3c823dd0UL,\n-    0xc3f3a207UL, 0x3ffbdf69UL, 0x60ea5b53UL, 0xbc3c2623UL, 0x5bd71e09UL,\n-    0x3ffbf2c2UL, 0x3f6b9c73UL, 0xbc9efdcaUL, 0x6141b33dUL, 0x3ffc0628UL,\n-    0xa1fbca34UL, 0xbc8d8a5aUL, 0xdd85529cUL, 0x3ffc199bUL, 0x895048ddUL,\n-    0x3c811065UL, 0xd9fa652cUL, 0x3ffc2d1cUL, 0x17c8a5d7UL, 0xbc96e516UL,\n-    0x5fffd07aUL, 0x3ffc40abUL, 0xe083c60aUL, 0x3c9b4537UL, 0x78fafb22UL,\n-    0x3ffc5447UL, 0x2493b5afUL, 0x3c912f07UL, 0x2e57d14bUL, 0x3ffc67f1UL,\n-    0xff483cadUL, 0x3c92884dUL, 0x8988c933UL, 0x3ffc7ba8UL, 0xbe255559UL,\n-    0xbc8e76bbUL, 0x9406e7b5UL, 0x3ffc8f6dUL, 0x48805c44UL, 0x3c71acbcUL,\n-    0x5751c4dbUL, 0x3ffca340UL, 0xd10d08f5UL, 0xbc87f2beUL, 0xdcef9069UL,\n-    0x3ffcb720UL, 0xd1e949dbUL, 0x3c7503cbUL, 0x2e6d1675UL, 0x3ffccb0fUL,\n-    0x86009092UL, 0xbc7d220fUL, 0x555dc3faUL, 0x3ffcdf0bUL, 0x53829d72UL,\n-    0xbc8dd83bUL, 0x5b5bab74UL, 0x3ffcf315UL, 0xb86dff57UL, 0xbc9a08e9UL,\n-    0x4a07897cUL, 0x3ffd072dUL, 0x43797a9cUL, 0xbc9cbc37UL, 0x2b08c968UL,\n-    0x3ffd1b53UL, 0x219a36eeUL, 0x3c955636UL, 0x080d89f2UL, 0x3ffd2f87UL,\n-    0x719d8578UL, 0xbc9d487bUL, 0xeacaa1d6UL, 0x3ffd43c8UL, 0xbf5a1614UL,\n-    0x3c93db53UL, 0xdcfba487UL, 0x3ffd5818UL, 0xd75b3707UL, 0x3c82ed02UL,\n-    0xe862e6d3UL, 0x3ffd6c76UL, 0x4a8165a0UL, 0x3c5fe87aUL, 0x16c98398UL,\n-    0x3ffd80e3UL, 0x8beddfe8UL, 0xbc911ec1UL, 0x71ff6075UL, 0x3ffd955dUL,\n-    0xbb9af6beUL, 0x3c9a052dUL, 0x03db3285UL, 0x3ffda9e6UL, 0x696db532UL,\n-    0x3c9c2300UL, 0xd63a8315UL, 0x3ffdbe7cUL, 0x926b8be4UL, 0xbc9b76f1UL,\n-    0xf301b460UL, 0x3ffdd321UL, 0x78f018c3UL, 0x3c92da57UL, 0x641c0658UL,\n-    0x3ffde7d5UL, 0x8e79ba8fUL, 0xbc9ca552UL, 0x337b9b5fUL, 0x3ffdfc97UL,\n-    0x4f184b5cUL, 0xbc91a5cdUL, 0x6b197d17UL, 0x3ffe1167UL, 0xbd5c7f44UL,\n-    0xbc72b529UL, 0x14f5a129UL, 0x3ffe2646UL, 0x817a1496UL, 0xbc97b627UL,\n-    0x3b16ee12UL, 0x3ffe3b33UL, 0x31fdc68bUL, 0xbc99f4a4UL, 0xe78b3ff6UL,\n-    0x3ffe502eUL, 0x80a9cc8fUL, 0x3c839e89UL, 0x24676d76UL, 0x3ffe6539UL,\n-    0x7522b735UL, 0xbc863ff8UL, 0xfbc74c83UL, 0x3ffe7a51UL, 0xca0c8de2UL,\n-    0x3c92d522UL, 0x77cdb740UL, 0x3ffe8f79UL, 0x80b054b1UL, 0xbc910894UL,\n-    0xa2a490daUL, 0x3ffea4afUL, 0x179c2893UL, 0xbc9e9c23UL, 0x867cca6eUL,\n-    0x3ffeb9f4UL, 0x2293e4f2UL, 0x3c94832fUL, 0x2d8e67f1UL, 0x3ffecf48UL,\n-    0xb411ad8cUL, 0xbc9c93f3UL, 0xa2188510UL, 0x3ffee4aaUL, 0xa487568dUL,\n-    0x3c91c68dUL, 0xee615a27UL, 0x3ffefa1bUL, 0x86a4b6b0UL, 0x3c9dc7f4UL,\n-    0x1cb6412aUL, 0x3fff0f9cUL, 0x65181d45UL, 0xbc932200UL, 0x376bba97UL,\n-    0x3fff252bUL, 0xbf0d8e43UL, 0x3c93a1a5UL, 0x48dd7274UL, 0x3fff3ac9UL,\n-    0x3ed837deUL, 0xbc795a5aUL, 0x5b6e4540UL, 0x3fff5076UL, 0x2dd8a18bUL,\n-    0x3c99d3e1UL, 0x798844f8UL, 0x3fff6632UL, 0x3539343eUL, 0x3c9fa37bUL,\n-    0xad9cbe14UL, 0x3fff7bfdUL, 0xd006350aUL, 0xbc9dbb12UL, 0x02243c89UL,\n-    0x3fff91d8UL, 0xa779f689UL, 0xbc612ea8UL, 0x819e90d8UL, 0x3fffa7c1UL,\n-    0xf3a5931eUL, 0x3c874853UL, 0x3692d514UL, 0x3fffbdbaUL, 0x15098eb6UL,\n-    0xbc796773UL, 0x2b8f71f1UL, 0x3fffd3c2UL, 0x966579e7UL, 0x3c62eb74UL,\n-    0x6b2a23d9UL, 0x3fffe9d9UL, 0x7442fde3UL, 0x3c74a603UL\n-};\n-\n-ATTRIBUTE_ALIGNED(16) juint _e_coeff[] =\n-{\n-    0xe78a6731UL, 0x3f55d87fUL, 0xd704a0c0UL, 0x3fac6b08UL, 0x6fba4e77UL,\n-    0x3f83b2abUL, 0xff82c58fUL, 0x3fcebfbdUL, 0xfefa39efUL, 0x3fe62e42UL,\n-    0x00000000UL, 0x00000000UL\n-};\n-\n-ATTRIBUTE_ALIGNED(16) juint _coeff_h[] =\n-{\n-    0x00000000UL, 0xbfd61a00UL, 0x00000000UL, 0xbf5dabe1UL\n-};\n-\n-ATTRIBUTE_ALIGNED(16) juint _HIGHMASK_LOG_X[] =\n-{\n-    0xf8000000UL, 0xffffffffUL, 0x00000000UL, 0xfffff800UL\n-};\n-\n-ATTRIBUTE_ALIGNED(8) juint _HALFMASK[] =\n-{\n-    0xf8000000UL, 0xffffffffUL, 0xf8000000UL, 0xffffffffUL\n-};\n-\n-ATTRIBUTE_ALIGNED(16) juint _coeff_pow[] =\n-{\n-    0x6dc96112UL, 0xbf836578UL, 0xee241472UL, 0xbf9b0301UL, 0x9f95985aUL,\n-    0xbfb528dbUL, 0xb3841d2aUL, 0xbfd619b6UL, 0x518775e3UL, 0x3f9004f2UL,\n-    0xac8349bbUL, 0x3fa76c9bUL, 0x486ececcUL, 0x3fc4635eUL, 0x161bb241UL,\n-    0xbf5dabe1UL, 0x9f95985aUL, 0xbfb528dbUL, 0xf8b5787dUL, 0x3ef2531eUL,\n-    0x486ececbUL, 0x3fc4635eUL, 0x412055ccUL, 0xbdd61bb2UL\n-};\n-\n-ATTRIBUTE_ALIGNED(16) juint _L_tbl_pow[] =\n-{\n-    0x00000000UL, 0x3ff00000UL, 0x00000000UL, 0x00000000UL, 0x20000000UL,\n-    0x3feff00aUL, 0x96621f95UL, 0x3e5b1856UL, 0xe0000000UL, 0x3fefe019UL,\n-    0xe5916f9eUL, 0xbe325278UL, 0x00000000UL, 0x3fefd02fUL, 0x859a1062UL,\n-    0x3e595fb7UL, 0xc0000000UL, 0x3fefc049UL, 0xb245f18fUL, 0xbe529c38UL,\n-    0xe0000000UL, 0x3fefb069UL, 0xad2880a7UL, 0xbe501230UL, 0x60000000UL,\n-    0x3fefa08fUL, 0xc8e72420UL, 0x3e597bd1UL, 0x80000000UL, 0x3fef90baUL,\n-    0xc30c4500UL, 0xbe5d6c75UL, 0xe0000000UL, 0x3fef80eaUL, 0x02c63f43UL,\n-    0x3e2e1318UL, 0xc0000000UL, 0x3fef7120UL, 0xb3d4ccccUL, 0xbe44c52aUL,\n-    0x00000000UL, 0x3fef615cUL, 0xdbd91397UL, 0xbe4e7d6cUL, 0xa0000000UL,\n-    0x3fef519cUL, 0x65c5cd68UL, 0xbe522dc8UL, 0xa0000000UL, 0x3fef41e2UL,\n-    0x46d1306cUL, 0xbe5a840eUL, 0xe0000000UL, 0x3fef322dUL, 0xd2980e94UL,\n-    0x3e5071afUL, 0xa0000000UL, 0x3fef227eUL, 0x773abadeUL, 0xbe5891e5UL,\n-    0xa0000000UL, 0x3fef12d4UL, 0xdc6bf46bUL, 0xbe5cccbeUL, 0xe0000000UL,\n-    0x3fef032fUL, 0xbc7247faUL, 0xbe2bab83UL, 0x80000000UL, 0x3feef390UL,\n-    0xbcaa1e46UL, 0xbe53bb3bUL, 0x60000000UL, 0x3feee3f6UL, 0x5f6c682dUL,\n-    0xbe54c619UL, 0x80000000UL, 0x3feed461UL, 0x5141e368UL, 0xbe4b6d86UL,\n-    0xe0000000UL, 0x3feec4d1UL, 0xec678f76UL, 0xbe369af6UL, 0x80000000UL,\n-    0x3feeb547UL, 0x41301f55UL, 0xbe2d4312UL, 0x60000000UL, 0x3feea5c2UL,\n-    0x676da6bdUL, 0xbe4d8dd0UL, 0x60000000UL, 0x3fee9642UL, 0x57a891c4UL,\n-    0x3e51f991UL, 0xa0000000UL, 0x3fee86c7UL, 0xe4eb491eUL, 0x3e579bf9UL,\n-    0x20000000UL, 0x3fee7752UL, 0xfddc4a2cUL, 0xbe3356e6UL, 0xc0000000UL,\n-    0x3fee67e1UL, 0xd75b5bf1UL, 0xbe449531UL, 0x80000000UL, 0x3fee5876UL,\n-    0xbd423b8eUL, 0x3df54fe4UL, 0x60000000UL, 0x3fee4910UL, 0x330e51b9UL,\n-    0x3e54289cUL, 0x80000000UL, 0x3fee39afUL, 0x8651a95fUL, 0xbe55aad6UL,\n-    0xa0000000UL, 0x3fee2a53UL, 0x5e98c708UL, 0xbe2fc4a9UL, 0xe0000000UL,\n-    0x3fee1afcUL, 0x0989328dUL, 0x3e23958cUL, 0x40000000UL, 0x3fee0babUL,\n-    0xee642abdUL, 0xbe425dd8UL, 0xa0000000UL, 0x3fedfc5eUL, 0xc394d236UL,\n-    0x3e526362UL, 0x20000000UL, 0x3feded17UL, 0xe104aa8eUL, 0x3e4ce247UL,\n-    0xc0000000UL, 0x3fedddd4UL, 0x265a9be4UL, 0xbe5bb77aUL, 0x40000000UL,\n-    0x3fedce97UL, 0x0ecac52fUL, 0x3e4a7cb1UL, 0xe0000000UL, 0x3fedbf5eUL,\n-    0x124cb3b8UL, 0x3e257024UL, 0x80000000UL, 0x3fedb02bUL, 0xe6d4febeUL,\n-    0xbe2033eeUL, 0x20000000UL, 0x3feda0fdUL, 0x39cca00eUL, 0xbe3ddabcUL,\n-    0xc0000000UL, 0x3fed91d3UL, 0xef8a552aUL, 0xbe543390UL, 0x40000000UL,\n-    0x3fed82afUL, 0xb8e85204UL, 0x3e513850UL, 0xe0000000UL, 0x3fed738fUL,\n-    0x3d59fe08UL, 0xbe5db728UL, 0x40000000UL, 0x3fed6475UL, 0x3aa7ead1UL,\n-    0x3e58804bUL, 0xc0000000UL, 0x3fed555fUL, 0xf8a35ba9UL, 0xbe5298b0UL,\n-    0x00000000UL, 0x3fed464fUL, 0x9a88dd15UL, 0x3e5a8cdbUL, 0x40000000UL,\n-    0x3fed3743UL, 0xb0b0a190UL, 0x3e598635UL, 0x80000000UL, 0x3fed283cUL,\n-    0xe2113295UL, 0xbe5c1119UL, 0x80000000UL, 0x3fed193aUL, 0xafbf1728UL,\n-    0xbe492e9cUL, 0x60000000UL, 0x3fed0a3dUL, 0xe4a4ccf3UL, 0x3e19b90eUL,\n-    0x20000000UL, 0x3fecfb45UL, 0xba3cbeb8UL, 0x3e406b50UL, 0xc0000000UL,\n-    0x3fecec51UL, 0x110f7dddUL, 0x3e0d6806UL, 0x40000000UL, 0x3fecdd63UL,\n-    0x7dd7d508UL, 0xbe5a8943UL, 0x80000000UL, 0x3fecce79UL, 0x9b60f271UL,\n-    0xbe50676aUL, 0x80000000UL, 0x3fecbf94UL, 0x0b9ad660UL, 0x3e59174fUL,\n-    0x60000000UL, 0x3fecb0b4UL, 0x00823d9cUL, 0x3e5bbf72UL, 0x20000000UL,\n-    0x3feca1d9UL, 0x38a6ec89UL, 0xbe4d38f9UL, 0x80000000UL, 0x3fec9302UL,\n-    0x3a0b7d8eUL, 0x3e53dbfdUL, 0xc0000000UL, 0x3fec8430UL, 0xc6826b34UL,\n-    0xbe27c5c9UL, 0xc0000000UL, 0x3fec7563UL, 0x0c706381UL, 0xbe593653UL,\n-    0x60000000UL, 0x3fec669bUL, 0x7df34ec7UL, 0x3e461ab5UL, 0xe0000000UL,\n-    0x3fec57d7UL, 0x40e5e7e8UL, 0xbe5c3daeUL, 0x00000000UL, 0x3fec4919UL,\n-    0x5602770fUL, 0xbe55219dUL, 0xc0000000UL, 0x3fec3a5eUL, 0xec7911ebUL,\n-    0x3e5a5d25UL, 0x60000000UL, 0x3fec2ba9UL, 0xb39ea225UL, 0xbe53c00bUL,\n-    0x80000000UL, 0x3fec1cf8UL, 0x967a212eUL, 0x3e5a8ddfUL, 0x60000000UL,\n-    0x3fec0e4cUL, 0x580798bdUL, 0x3e5f53abUL, 0x00000000UL, 0x3febffa5UL,\n-    0xb8282df6UL, 0xbe46b874UL, 0x20000000UL, 0x3febf102UL, 0xe33a6729UL,\n-    0x3e54963fUL, 0x00000000UL, 0x3febe264UL, 0x3b53e88aUL, 0xbe3adce1UL,\n-    0x60000000UL, 0x3febd3caUL, 0xc2585084UL, 0x3e5cde9fUL, 0x80000000UL,\n-    0x3febc535UL, 0xa335c5eeUL, 0xbe39fd9cUL, 0x20000000UL, 0x3febb6a5UL,\n-    0x7325b04dUL, 0x3e42ba15UL, 0x60000000UL, 0x3feba819UL, 0x1564540fUL,\n-    0x3e3a9f35UL, 0x40000000UL, 0x3feb9992UL, 0x83fff592UL, 0xbe5465ceUL,\n-    0xa0000000UL, 0x3feb8b0fUL, 0xb9da63d3UL, 0xbe4b1a0aUL, 0x80000000UL,\n-    0x3feb7c91UL, 0x6d6f1ea4UL, 0x3e557657UL, 0x00000000UL, 0x3feb6e18UL,\n-    0x5e80a1bfUL, 0x3e4ddbb6UL, 0x00000000UL, 0x3feb5fa3UL, 0x1c9eacb5UL,\n-    0x3e592877UL, 0xa0000000UL, 0x3feb5132UL, 0x6d40beb3UL, 0xbe51858cUL,\n-    0xa0000000UL, 0x3feb42c6UL, 0xd740c67bUL, 0x3e427ad2UL, 0x40000000UL,\n-    0x3feb345fUL, 0xa3e0cceeUL, 0xbe5c2fc4UL, 0x40000000UL, 0x3feb25fcUL,\n-    0x8e752b50UL, 0xbe3da3c2UL, 0xc0000000UL, 0x3feb179dUL, 0xa892e7deUL,\n-    0x3e1fb481UL, 0xc0000000UL, 0x3feb0943UL, 0x21ed71e9UL, 0xbe365206UL,\n-    0x20000000UL, 0x3feafaeeUL, 0x0e1380a3UL, 0x3e5c5b7bUL, 0x20000000UL,\n-    0x3feaec9dUL, 0x3c3d640eUL, 0xbe5dbbd0UL, 0x60000000UL, 0x3feade50UL,\n-    0x8f97a715UL, 0x3e3a8ec5UL, 0x20000000UL, 0x3fead008UL, 0x23ab2839UL,\n-    0x3e2fe98aUL, 0x40000000UL, 0x3feac1c4UL, 0xf4bbd50fUL, 0x3e54d8f6UL,\n-    0xe0000000UL, 0x3feab384UL, 0x14757c4dUL, 0xbe48774cUL, 0xc0000000UL,\n-    0x3feaa549UL, 0x7c7b0eeaUL, 0x3e5b51bbUL, 0x20000000UL, 0x3fea9713UL,\n-    0xf56f7013UL, 0x3e386200UL, 0xe0000000UL, 0x3fea88e0UL, 0xbe428ebeUL,\n-    0xbe514af5UL, 0xe0000000UL, 0x3fea7ab2UL, 0x8d0e4496UL, 0x3e4f9165UL,\n-    0x60000000UL, 0x3fea6c89UL, 0xdbacc5d5UL, 0xbe5c063bUL, 0x20000000UL,\n-    0x3fea5e64UL, 0x3f19d970UL, 0xbe5a0c8cUL, 0x20000000UL, 0x3fea5043UL,\n-    0x09ea3e6bUL, 0x3e5065dcUL, 0x80000000UL, 0x3fea4226UL, 0x78df246cUL,\n-    0x3e5e05f6UL, 0x40000000UL, 0x3fea340eUL, 0x4057d4a0UL, 0x3e431b2bUL,\n-    0x40000000UL, 0x3fea25faUL, 0x82867bb5UL, 0x3e4b76beUL, 0xa0000000UL,\n-    0x3fea17eaUL, 0x9436f40aUL, 0xbe5aad39UL, 0x20000000UL, 0x3fea09dfUL,\n-    0x4b5253b3UL, 0x3e46380bUL, 0x00000000UL, 0x3fe9fbd8UL, 0x8fc52466UL,\n-    0xbe386f9bUL, 0x20000000UL, 0x3fe9edd5UL, 0x22d3f344UL, 0xbe538347UL,\n-    0x60000000UL, 0x3fe9dfd6UL, 0x1ac33522UL, 0x3e5dbc53UL, 0x00000000UL,\n-    0x3fe9d1dcUL, 0xeabdff1dUL, 0x3e40fc0cUL, 0xe0000000UL, 0x3fe9c3e5UL,\n-    0xafd30e73UL, 0xbe585e63UL, 0xe0000000UL, 0x3fe9b5f3UL, 0xa52f226aUL,\n-    0xbe43e8f9UL, 0x20000000UL, 0x3fe9a806UL, 0xecb8698dUL, 0xbe515b36UL,\n-    0x80000000UL, 0x3fe99a1cUL, 0xf2b4e89dUL, 0x3e48b62bUL, 0x20000000UL,\n-    0x3fe98c37UL, 0x7c9a88fbUL, 0x3e44414cUL, 0x00000000UL, 0x3fe97e56UL,\n-    0xda015741UL, 0xbe5d13baUL, 0xe0000000UL, 0x3fe97078UL, 0x5fdace06UL,\n-    0x3e51b947UL, 0x00000000UL, 0x3fe962a0UL, 0x956ca094UL, 0x3e518785UL,\n-    0x40000000UL, 0x3fe954cbUL, 0x01164c1dUL, 0x3e5d5b57UL, 0xc0000000UL,\n-    0x3fe946faUL, 0xe63b3767UL, 0xbe4f84e7UL, 0x40000000UL, 0x3fe9392eUL,\n-    0xe57cc2a9UL, 0x3e34eda3UL, 0xe0000000UL, 0x3fe92b65UL, 0x8c75b544UL,\n-    0x3e5766a0UL, 0xc0000000UL, 0x3fe91da1UL, 0x37d1d087UL, 0xbe5e2ab1UL,\n-    0x80000000UL, 0x3fe90fe1UL, 0xa953dc20UL, 0x3e5fa1f3UL, 0x80000000UL,\n-    0x3fe90225UL, 0xdbd3f369UL, 0x3e47d6dbUL, 0xa0000000UL, 0x3fe8f46dUL,\n-    0x1c9be989UL, 0xbe5e2b0aUL, 0xa0000000UL, 0x3fe8e6b9UL, 0x3c93d76aUL,\n-    0x3e5c8618UL, 0xe0000000UL, 0x3fe8d909UL, 0x2182fc9aUL, 0xbe41aa9eUL,\n-    0x20000000UL, 0x3fe8cb5eUL, 0xe6b3539dUL, 0xbe530d19UL, 0x60000000UL,\n-    0x3fe8bdb6UL, 0x49e58cc3UL, 0xbe3bb374UL, 0xa0000000UL, 0x3fe8b012UL,\n-    0xa7cfeb8fUL, 0x3e56c412UL, 0x00000000UL, 0x3fe8a273UL, 0x8d52bc19UL,\n-    0x3e1429b8UL, 0x60000000UL, 0x3fe894d7UL, 0x4dc32c6cUL, 0xbe48604cUL,\n-    0xc0000000UL, 0x3fe8873fUL, 0x0c868e56UL, 0xbe564ee5UL, 0x00000000UL,\n-    0x3fe879acUL, 0x56aee828UL, 0x3e5e2fd8UL, 0x60000000UL, 0x3fe86c1cUL,\n-    0x7ceab8ecUL, 0x3e493365UL, 0xc0000000UL, 0x3fe85e90UL, 0x78d4dadcUL,\n-    0xbe4f7f25UL, 0x00000000UL, 0x3fe85109UL, 0x0ccd8280UL, 0x3e31e7a2UL,\n-    0x40000000UL, 0x3fe84385UL, 0x34ba4e15UL, 0x3e328077UL, 0x80000000UL,\n-    0x3fe83605UL, 0xa670975aUL, 0xbe53eee5UL, 0xa0000000UL, 0x3fe82889UL,\n-    0xf61b77b2UL, 0xbe43a20aUL, 0xa0000000UL, 0x3fe81b11UL, 0x13e6643bUL,\n-    0x3e5e5fe5UL, 0xc0000000UL, 0x3fe80d9dUL, 0x82cc94e8UL, 0xbe5ff1f9UL,\n-    0xa0000000UL, 0x3fe8002dUL, 0x8a0c9c5dUL, 0xbe42b0e7UL, 0x60000000UL,\n-    0x3fe7f2c1UL, 0x22a16f01UL, 0x3e5d9ea0UL, 0x20000000UL, 0x3fe7e559UL,\n-    0xc38cd451UL, 0x3e506963UL, 0xc0000000UL, 0x3fe7d7f4UL, 0x9902bc71UL,\n-    0x3e4503d7UL, 0x40000000UL, 0x3fe7ca94UL, 0xdef2a3c0UL, 0x3e3d98edUL,\n-    0xa0000000UL, 0x3fe7bd37UL, 0xed49abb0UL, 0x3e24c1ffUL, 0xe0000000UL,\n-    0x3fe7afdeUL, 0xe3b0be70UL, 0xbe40c467UL, 0x00000000UL, 0x3fe7a28aUL,\n-    0xaf9f193cUL, 0xbe5dff6cUL, 0xe0000000UL, 0x3fe79538UL, 0xb74cf6b6UL,\n-    0xbe258ed0UL, 0xa0000000UL, 0x3fe787ebUL, 0x1d9127c7UL, 0x3e345fb0UL,\n-    0x40000000UL, 0x3fe77aa2UL, 0x1028c21dUL, 0xbe4619bdUL, 0xa0000000UL,\n-    0x3fe76d5cUL, 0x7cb0b5e4UL, 0x3e40f1a2UL, 0xe0000000UL, 0x3fe7601aUL,\n-    0x2b1bc4adUL, 0xbe32e8bbUL, 0xe0000000UL, 0x3fe752dcUL, 0x6839f64eUL,\n-    0x3e41f57bUL, 0xc0000000UL, 0x3fe745a2UL, 0xc4121f7eUL, 0xbe52c40aUL,\n-    0x60000000UL, 0x3fe7386cUL, 0xd6852d72UL, 0xbe5c4e6bUL, 0xc0000000UL,\n-    0x3fe72b39UL, 0x91d690f7UL, 0xbe57f88fUL, 0xe0000000UL, 0x3fe71e0aUL,\n-    0x627a2159UL, 0xbe4425d5UL, 0xc0000000UL, 0x3fe710dfUL, 0x50a54033UL,\n-    0x3e422b7eUL, 0x60000000UL, 0x3fe703b8UL, 0x3b0b5f91UL, 0x3e5d3857UL,\n-    0xe0000000UL, 0x3fe6f694UL, 0x84d628a2UL, 0xbe51f090UL, 0x00000000UL,\n-    0x3fe6e975UL, 0x306d8894UL, 0xbe414d83UL, 0xe0000000UL, 0x3fe6dc58UL,\n-    0x30bf24aaUL, 0xbe4650caUL, 0x80000000UL, 0x3fe6cf40UL, 0xd4628d69UL,\n-    0xbe5db007UL, 0xc0000000UL, 0x3fe6c22bUL, 0xa2aae57bUL, 0xbe31d279UL,\n-    0xc0000000UL, 0x3fe6b51aUL, 0x860edf7eUL, 0xbe2d4c4aUL, 0x80000000UL,\n-    0x3fe6a80dUL, 0xf3559341UL, 0xbe5f7e98UL, 0xe0000000UL, 0x3fe69b03UL,\n-    0xa885899eUL, 0xbe5c2011UL, 0xe0000000UL, 0x3fe68dfdUL, 0x2bdc6d37UL,\n-    0x3e224a82UL, 0xa0000000UL, 0x3fe680fbUL, 0xc12ad1b9UL, 0xbe40cf56UL,\n-    0x00000000UL, 0x3fe673fdUL, 0x1bcdf659UL, 0xbdf52f2dUL, 0x00000000UL,\n-    0x3fe66702UL, 0x5df10408UL, 0x3e5663e0UL, 0xc0000000UL, 0x3fe65a0aUL,\n-    0xa4070568UL, 0xbe40b12fUL, 0x00000000UL, 0x3fe64d17UL, 0x71c54c47UL,\n-    0x3e5f5e8bUL, 0x00000000UL, 0x3fe64027UL, 0xbd4b7e83UL, 0x3e42ead6UL,\n-    0xa0000000UL, 0x3fe6333aUL, 0x61598bd2UL, 0xbe4c48d4UL, 0xc0000000UL,\n-    0x3fe62651UL, 0x6f538d61UL, 0x3e548401UL, 0xa0000000UL, 0x3fe6196cUL,\n-    0x14344120UL, 0xbe529af6UL, 0x00000000UL, 0x3fe60c8bUL, 0x5982c587UL,\n-    0xbe3e1e4fUL, 0x00000000UL, 0x3fe5ffadUL, 0xfe51d4eaUL, 0xbe4c897aUL,\n-    0x80000000UL, 0x3fe5f2d2UL, 0xfd46ebe1UL, 0x3e552e00UL, 0xa0000000UL,\n-    0x3fe5e5fbUL, 0xa4695699UL, 0x3e5ed471UL, 0x60000000UL, 0x3fe5d928UL,\n-    0x80d118aeUL, 0x3e456b61UL, 0xa0000000UL, 0x3fe5cc58UL, 0x304c330bUL,\n-    0x3e54dc29UL, 0x80000000UL, 0x3fe5bf8cUL, 0x0af2dedfUL, 0xbe3aa9bdUL,\n-    0xe0000000UL, 0x3fe5b2c3UL, 0x15fc9258UL, 0xbe479a37UL, 0xc0000000UL,\n-    0x3fe5a5feUL, 0x9292c7eaUL, 0x3e188650UL, 0x20000000UL, 0x3fe5993dUL,\n-    0x33b4d380UL, 0x3e5d6d93UL, 0x20000000UL, 0x3fe58c7fUL, 0x02fd16c7UL,\n-    0x3e2fe961UL, 0xa0000000UL, 0x3fe57fc4UL, 0x4a05edb6UL, 0xbe4d55b4UL,\n-    0xa0000000UL, 0x3fe5730dUL, 0x3d443abbUL, 0xbe5e6954UL, 0x00000000UL,\n-    0x3fe5665aUL, 0x024acfeaUL, 0x3e50e61bUL, 0x00000000UL, 0x3fe559aaUL,\n-    0xcc9edd09UL, 0xbe325403UL, 0x60000000UL, 0x3fe54cfdUL, 0x1fe26950UL,\n-    0x3e5d500eUL, 0x60000000UL, 0x3fe54054UL, 0x6c5ae164UL, 0xbe4a79b4UL,\n-    0xc0000000UL, 0x3fe533aeUL, 0x154b0287UL, 0xbe401571UL, 0xa0000000UL,\n-    0x3fe5270cUL, 0x0673f401UL, 0xbe56e56bUL, 0xe0000000UL, 0x3fe51a6dUL,\n-    0x751b639cUL, 0x3e235269UL, 0xa0000000UL, 0x3fe50dd2UL, 0x7c7b2bedUL,\n-    0x3ddec887UL, 0xc0000000UL, 0x3fe5013aUL, 0xafab4e17UL, 0x3e5e7575UL,\n-    0x60000000UL, 0x3fe4f4a6UL, 0x2e308668UL, 0x3e59aed6UL, 0x80000000UL,\n-    0x3fe4e815UL, 0xf33e2a76UL, 0xbe51f184UL, 0xe0000000UL, 0x3fe4db87UL,\n-    0x839f3e3eUL, 0x3e57db01UL, 0xc0000000UL, 0x3fe4cefdUL, 0xa9eda7bbUL,\n-    0x3e535e0fUL, 0x00000000UL, 0x3fe4c277UL, 0x2a8f66a5UL, 0x3e5ce451UL,\n-    0xc0000000UL, 0x3fe4b5f3UL, 0x05192456UL, 0xbe4e8518UL, 0xc0000000UL,\n-    0x3fe4a973UL, 0x4aa7cd1dUL, 0x3e46784aUL, 0x40000000UL, 0x3fe49cf7UL,\n-    0x8e23025eUL, 0xbe5749f2UL, 0x00000000UL, 0x3fe4907eUL, 0x18d30215UL,\n-    0x3e360f39UL, 0x20000000UL, 0x3fe48408UL, 0x63dcf2f3UL, 0x3e5e00feUL,\n-    0xc0000000UL, 0x3fe47795UL, 0x46182d09UL, 0xbe5173d9UL, 0xa0000000UL,\n-    0x3fe46b26UL, 0x8f0e62aaUL, 0xbe48f281UL, 0xe0000000UL, 0x3fe45ebaUL,\n-    0x5775c40cUL, 0xbe56aad4UL, 0x60000000UL, 0x3fe45252UL, 0x0fe25f69UL,\n-    0x3e48bd71UL, 0x40000000UL, 0x3fe445edUL, 0xe9989ec5UL, 0x3e590d97UL,\n-    0x80000000UL, 0x3fe4398bUL, 0xb3d9ffe3UL, 0x3e479dbcUL, 0x20000000UL,\n-    0x3fe42d2dUL, 0x388e4d2eUL, 0xbe5eed80UL, 0xe0000000UL, 0x3fe420d1UL,\n-    0x6f797c18UL, 0x3e554b4cUL, 0x20000000UL, 0x3fe4147aUL, 0x31048bb4UL,\n-    0xbe5b1112UL, 0x80000000UL, 0x3fe40825UL, 0x2efba4f9UL, 0x3e48ebc7UL,\n-    0x40000000UL, 0x3fe3fbd4UL, 0x50201119UL, 0x3e40b701UL, 0x40000000UL,\n-    0x3fe3ef86UL, 0x0a4db32cUL, 0x3e551de8UL, 0xa0000000UL, 0x3fe3e33bUL,\n-    0x0c9c148bUL, 0xbe50c1f6UL, 0x20000000UL, 0x3fe3d6f4UL, 0xc9129447UL,\n-    0x3e533fa0UL, 0x00000000UL, 0x3fe3cab0UL, 0xaae5b5a0UL, 0xbe22b68eUL,\n-    0x20000000UL, 0x3fe3be6fUL, 0x02305e8aUL, 0xbe54fc08UL, 0x60000000UL,\n-    0x3fe3b231UL, 0x7f908258UL, 0x3e57dc05UL, 0x00000000UL, 0x3fe3a5f7UL,\n-    0x1a09af78UL, 0x3e08038bUL, 0xe0000000UL, 0x3fe399bfUL, 0x490643c1UL,\n-    0xbe5dbe42UL, 0xe0000000UL, 0x3fe38d8bUL, 0x5e8ad724UL, 0xbe3c2b72UL,\n-    0x20000000UL, 0x3fe3815bUL, 0xc67196b6UL, 0x3e1713cfUL, 0xa0000000UL,\n-    0x3fe3752dUL, 0x6182e429UL, 0xbe3ec14cUL, 0x40000000UL, 0x3fe36903UL,\n-    0xab6eb1aeUL, 0x3e5a2cc5UL, 0x40000000UL, 0x3fe35cdcUL, 0xfe5dc064UL,\n-    0xbe5c5878UL, 0x40000000UL, 0x3fe350b8UL, 0x0ba6b9e4UL, 0x3e51619bUL,\n-    0x80000000UL, 0x3fe34497UL, 0x857761aaUL, 0x3e5fff53UL, 0x00000000UL,\n-    0x3fe3387aUL, 0xf872d68cUL, 0x3e484f4dUL, 0xa0000000UL, 0x3fe32c5fUL,\n-    0x087e97c2UL, 0x3e52842eUL, 0x80000000UL, 0x3fe32048UL, 0x73d6d0c0UL,\n-    0xbe503edfUL, 0x80000000UL, 0x3fe31434UL, 0x0c1456a1UL, 0xbe5f72adUL,\n-    0xa0000000UL, 0x3fe30823UL, 0x83a1a4d5UL, 0xbe5e65ccUL, 0xe0000000UL,\n-    0x3fe2fc15UL, 0x855a7390UL, 0xbe506438UL, 0x40000000UL, 0x3fe2f00bUL,\n-    0xa2898287UL, 0x3e3d22a2UL, 0xe0000000UL, 0x3fe2e403UL, 0x8b56f66fUL,\n-    0xbe5aa5fdUL, 0x80000000UL, 0x3fe2d7ffUL, 0x52db119aUL, 0x3e3a2e3dUL,\n-    0x60000000UL, 0x3fe2cbfeUL, 0xe2ddd4c0UL, 0xbe586469UL, 0x40000000UL,\n-    0x3fe2c000UL, 0x6b01bf10UL, 0x3e352b9dUL, 0x40000000UL, 0x3fe2b405UL,\n-    0xb07a1cdfUL, 0x3e5c5cdaUL, 0x80000000UL, 0x3fe2a80dUL, 0xc7b5f868UL,\n-    0xbe5668b3UL, 0xc0000000UL, 0x3fe29c18UL, 0x185edf62UL, 0xbe563d66UL,\n-    0x00000000UL, 0x3fe29027UL, 0xf729e1ccUL, 0x3e59a9a0UL, 0x80000000UL,\n-    0x3fe28438UL, 0x6433c727UL, 0xbe43cc89UL, 0x00000000UL, 0x3fe2784dUL,\n-    0x41782631UL, 0xbe30750cUL, 0xa0000000UL, 0x3fe26c64UL, 0x914911b7UL,\n-    0xbe58290eUL, 0x40000000UL, 0x3fe2607fUL, 0x3dcc73e1UL, 0xbe4269cdUL,\n-    0x00000000UL, 0x3fe2549dUL, 0x2751bf70UL, 0xbe5a6998UL, 0xc0000000UL,\n-    0x3fe248bdUL, 0x4248b9fbUL, 0xbe4ddb00UL, 0x80000000UL, 0x3fe23ce1UL,\n-    0xf35cf82fUL, 0x3e561b71UL, 0x60000000UL, 0x3fe23108UL, 0x8e481a2dUL,\n-    0x3e518fb9UL, 0x60000000UL, 0x3fe22532UL, 0x5ab96edcUL, 0xbe5fafc5UL,\n-    0x40000000UL, 0x3fe2195fUL, 0x80943911UL, 0xbe07f819UL, 0x40000000UL,\n-    0x3fe20d8fUL, 0x386f2d6cUL, 0xbe54ba8bUL, 0x40000000UL, 0x3fe201c2UL,\n-    0xf29664acUL, 0xbe5eb815UL, 0x20000000UL, 0x3fe1f5f8UL, 0x64f03390UL,\n-    0x3e5e320cUL, 0x20000000UL, 0x3fe1ea31UL, 0x747ff696UL, 0x3e5ef0a5UL,\n-    0x40000000UL, 0x3fe1de6dUL, 0x3e9ceb51UL, 0xbe5f8d27UL, 0x20000000UL,\n-    0x3fe1d2acUL, 0x4ae0b55eUL, 0x3e5faa21UL, 0x20000000UL, 0x3fe1c6eeUL,\n-    0x28569a5eUL, 0x3e598a4fUL, 0x20000000UL, 0x3fe1bb33UL, 0x54b33e07UL,\n-    0x3e46130aUL, 0x20000000UL, 0x3fe1af7bUL, 0x024f1078UL, 0xbe4dbf93UL,\n-    0x00000000UL, 0x3fe1a3c6UL, 0xb0783bfaUL, 0x3e419248UL, 0xe0000000UL,\n-    0x3fe19813UL, 0x2f02b836UL, 0x3e4e02b7UL, 0xc0000000UL, 0x3fe18c64UL,\n-    0x28dec9d4UL, 0x3e09064fUL, 0x80000000UL, 0x3fe180b8UL, 0x45cbf406UL,\n-    0x3e5b1f46UL, 0x40000000UL, 0x3fe1750fUL, 0x03d9964cUL, 0x3e5b0a79UL,\n-    0x00000000UL, 0x3fe16969UL, 0x8b5b882bUL, 0xbe238086UL, 0xa0000000UL,\n-    0x3fe15dc5UL, 0x73bad6f8UL, 0xbdf1fca4UL, 0x20000000UL, 0x3fe15225UL,\n-    0x5385769cUL, 0x3e5e8d76UL, 0xa0000000UL, 0x3fe14687UL, 0x1676dc6bUL,\n-    0x3e571d08UL, 0x20000000UL, 0x3fe13aedUL, 0xa8c41c7fUL, 0xbe598a25UL,\n-    0x60000000UL, 0x3fe12f55UL, 0xc4e1aaf0UL, 0x3e435277UL, 0xa0000000UL,\n-    0x3fe123c0UL, 0x403638e1UL, 0xbe21aa7cUL, 0xc0000000UL, 0x3fe1182eUL,\n-    0x557a092bUL, 0xbdd0116bUL, 0xc0000000UL, 0x3fe10c9fUL, 0x7d779f66UL,\n-    0x3e4a61baUL, 0xc0000000UL, 0x3fe10113UL, 0x2b09c645UL, 0xbe5d586eUL,\n-    0x20000000UL, 0x3fe0ea04UL, 0xea2cad46UL, 0x3e5aa97cUL, 0x20000000UL,\n-    0x3fe0d300UL, 0x23190e54UL, 0x3e50f1a7UL, 0xa0000000UL, 0x3fe0bc07UL,\n-    0x1379a5a6UL, 0xbe51619dUL, 0x60000000UL, 0x3fe0a51aUL, 0x926a3d4aUL,\n-    0x3e5cf019UL, 0xa0000000UL, 0x3fe08e38UL, 0xa8c24358UL, 0x3e35241eUL,\n-    0x20000000UL, 0x3fe07762UL, 0x24317e7aUL, 0x3e512cfaUL, 0x00000000UL,\n-    0x3fe06097UL, 0xfd9cf274UL, 0xbe55bef3UL, 0x00000000UL, 0x3fe049d7UL,\n-    0x3689b49dUL, 0xbe36d26dUL, 0x40000000UL, 0x3fe03322UL, 0xf72ef6c4UL,\n-    0xbe54cd08UL, 0xa0000000UL, 0x3fe01c78UL, 0x23702d2dUL, 0xbe5900bfUL,\n-    0x00000000UL, 0x3fe005daUL, 0x3f59c14cUL, 0x3e57d80bUL, 0x40000000UL,\n-    0x3fdfde8dUL, 0xad67766dUL, 0xbe57fad4UL, 0x40000000UL, 0x3fdfb17cUL,\n-    0x644f4ae7UL, 0x3e1ee43bUL, 0x40000000UL, 0x3fdf8481UL, 0x903234d2UL,\n-    0x3e501a86UL, 0x40000000UL, 0x3fdf579cUL, 0xafe9e509UL, 0xbe267c3eUL,\n-    0x00000000UL, 0x3fdf2acdUL, 0xb7dfda0bUL, 0xbe48149bUL, 0x40000000UL,\n-    0x3fdefe13UL, 0x3b94305eUL, 0x3e5f4ea7UL, 0x80000000UL, 0x3fded16fUL,\n-    0x5d95da61UL, 0xbe55c198UL, 0x00000000UL, 0x3fdea4e1UL, 0x406960c9UL,\n-    0xbdd99a19UL, 0x00000000UL, 0x3fde7868UL, 0xd22f3539UL, 0x3e470c78UL,\n-    0x80000000UL, 0x3fde4c04UL, 0x83eec535UL, 0xbe3e1232UL, 0x40000000UL,\n-    0x3fde1fb6UL, 0x3dfbffcbUL, 0xbe4b7d71UL, 0x40000000UL, 0x3fddf37dUL,\n-    0x7e1be4e0UL, 0xbe5b8f8fUL, 0x40000000UL, 0x3fddc759UL, 0x46dae887UL,\n-    0xbe350458UL, 0x80000000UL, 0x3fdd9b4aUL, 0xed6ecc49UL, 0xbe5f0045UL,\n-    0x80000000UL, 0x3fdd6f50UL, 0x2e9e883cUL, 0x3e2915daUL, 0x80000000UL,\n-    0x3fdd436bUL, 0xf0bccb32UL, 0x3e4a68c9UL, 0x80000000UL, 0x3fdd179bUL,\n-    0x9bbfc779UL, 0xbe54a26aUL, 0x00000000UL, 0x3fdcebe0UL, 0x7cea33abUL,\n-    0x3e43c6b7UL, 0x40000000UL, 0x3fdcc039UL, 0xe740fd06UL, 0x3e5526c2UL,\n-    0x40000000UL, 0x3fdc94a7UL, 0x9eadeb1aUL, 0xbe396d8dUL, 0xc0000000UL,\n-    0x3fdc6929UL, 0xf0a8f95aUL, 0xbe5c0ab2UL, 0x80000000UL, 0x3fdc3dc0UL,\n-    0x6ee2693bUL, 0x3e0992e6UL, 0xc0000000UL, 0x3fdc126bUL, 0x5ac6b581UL,\n-    0xbe2834b6UL, 0x40000000UL, 0x3fdbe72bUL, 0x8cc226ffUL, 0x3e3596a6UL,\n-    0x00000000UL, 0x3fdbbbffUL, 0xf92a74bbUL, 0x3e3c5813UL, 0x00000000UL,\n-    0x3fdb90e7UL, 0x479664c0UL, 0xbe50d644UL, 0x00000000UL, 0x3fdb65e3UL,\n-    0x5004975bUL, 0xbe55258fUL, 0x00000000UL, 0x3fdb3af3UL, 0xe4b23194UL,\n-    0xbe588407UL, 0xc0000000UL, 0x3fdb1016UL, 0xe65d4d0aUL, 0x3e527c26UL,\n-    0x80000000UL, 0x3fdae54eUL, 0x814fddd6UL, 0x3e5962a2UL, 0x40000000UL,\n-    0x3fdaba9aUL, 0xe19d0913UL, 0xbe562f4eUL, 0x80000000UL, 0x3fda8ff9UL,\n-    0x43cfd006UL, 0xbe4cfdebUL, 0x40000000UL, 0x3fda656cUL, 0x686f0a4eUL,\n-    0x3e5e47a8UL, 0xc0000000UL, 0x3fda3af2UL, 0x7200d410UL, 0x3e5e1199UL,\n-    0xc0000000UL, 0x3fda108cUL, 0xabd2266eUL, 0x3e5ee4d1UL, 0x40000000UL,\n-    0x3fd9e63aUL, 0x396f8f2cUL, 0x3e4dbffbUL, 0x00000000UL, 0x3fd9bbfbUL,\n-    0xe32b25ddUL, 0x3e5c3a54UL, 0x40000000UL, 0x3fd991cfUL, 0x431e4035UL,\n-    0xbe457925UL, 0x80000000UL, 0x3fd967b6UL, 0x7bed3dd3UL, 0x3e40c61dUL,\n-    0x00000000UL, 0x3fd93db1UL, 0xd7449365UL, 0x3e306419UL, 0x80000000UL,\n-    0x3fd913beUL, 0x1746e791UL, 0x3e56fcfcUL, 0x40000000UL, 0x3fd8e9dfUL,\n-    0xf3a9028bUL, 0xbe5041b9UL, 0xc0000000UL, 0x3fd8c012UL, 0x56840c50UL,\n-    0xbe26e20aUL, 0x40000000UL, 0x3fd89659UL, 0x19763102UL, 0xbe51f466UL,\n-    0x80000000UL, 0x3fd86cb2UL, 0x7032de7cUL, 0xbe4d298aUL, 0x80000000UL,\n-    0x3fd8431eUL, 0xdeb39fabUL, 0xbe4361ebUL, 0x40000000UL, 0x3fd8199dUL,\n-    0x5d01cbe0UL, 0xbe5425b3UL, 0x80000000UL, 0x3fd7f02eUL, 0x3ce99aa9UL,\n-    0x3e146fa8UL, 0x80000000UL, 0x3fd7c6d2UL, 0xd1a262b9UL, 0xbe5a1a69UL,\n-    0xc0000000UL, 0x3fd79d88UL, 0x8606c236UL, 0x3e423a08UL, 0x80000000UL,\n-    0x3fd77451UL, 0x8fd1e1b7UL, 0x3e5a6a63UL, 0xc0000000UL, 0x3fd74b2cUL,\n-    0xe491456aUL, 0x3e42c1caUL, 0x40000000UL, 0x3fd7221aUL, 0x4499a6d7UL,\n-    0x3e36a69aUL, 0x00000000UL, 0x3fd6f91aUL, 0x5237df94UL, 0xbe0f8f02UL,\n-    0x00000000UL, 0x3fd6d02cUL, 0xb6482c6eUL, 0xbe5abcf7UL, 0x00000000UL,\n-    0x3fd6a750UL, 0x1919fd61UL, 0xbe57ade2UL, 0x00000000UL, 0x3fd67e86UL,\n-    0xaa7a994dUL, 0xbe3f3fbdUL, 0x00000000UL, 0x3fd655ceUL, 0x67db014cUL,\n-    0x3e33c550UL, 0x00000000UL, 0x3fd62d28UL, 0xa82856b7UL, 0xbe1409d1UL,\n-    0xc0000000UL, 0x3fd60493UL, 0x1e6a300dUL, 0x3e55d899UL, 0x80000000UL,\n-    0x3fd5dc11UL, 0x1222bd5cUL, 0xbe35bfc0UL, 0xc0000000UL, 0x3fd5b3a0UL,\n-    0x6e8dc2d3UL, 0x3e5d4d79UL, 0x00000000UL, 0x3fd58b42UL, 0xe0e4ace6UL,\n-    0xbe517303UL, 0x80000000UL, 0x3fd562f4UL, 0xb306e0a8UL, 0x3e5edf0fUL,\n-    0xc0000000UL, 0x3fd53ab8UL, 0x6574bc54UL, 0x3e5ee859UL, 0x80000000UL,\n-    0x3fd5128eUL, 0xea902207UL, 0x3e5f6188UL, 0xc0000000UL, 0x3fd4ea75UL,\n-    0x9f911d79UL, 0x3e511735UL, 0x80000000UL, 0x3fd4c26eUL, 0xf9c77397UL,\n-    0xbe5b1643UL, 0x40000000UL, 0x3fd49a78UL, 0x15fc9258UL, 0x3e479a37UL,\n-    0x80000000UL, 0x3fd47293UL, 0xd5a04dd9UL, 0xbe426e56UL, 0xc0000000UL,\n-    0x3fd44abfUL, 0xe04042f5UL, 0x3e56f7c6UL, 0x40000000UL, 0x3fd422fdUL,\n-    0x1d8bf2c8UL, 0x3e5d8810UL, 0x00000000UL, 0x3fd3fb4cUL, 0x88a8ddeeUL,\n-    0xbe311454UL, 0xc0000000UL, 0x3fd3d3abUL, 0x3e3b5e47UL, 0xbe5d1b72UL,\n-    0x40000000UL, 0x3fd3ac1cUL, 0xc2ab5d59UL, 0x3e31b02bUL, 0xc0000000UL,\n-    0x3fd3849dUL, 0xd4e34b9eUL, 0x3e51cb2fUL, 0x40000000UL, 0x3fd35d30UL,\n-    0x177204fbUL, 0xbe2b8cd7UL, 0x80000000UL, 0x3fd335d3UL, 0xfcd38c82UL,\n-    0xbe4356e1UL, 0x80000000UL, 0x3fd30e87UL, 0x64f54accUL, 0xbe4e6224UL,\n-    0x00000000UL, 0x3fd2e74cUL, 0xaa7975d9UL, 0x3e5dc0feUL, 0x80000000UL,\n-    0x3fd2c021UL, 0x516dab3fUL, 0xbe50ffa3UL, 0x40000000UL, 0x3fd29907UL,\n-    0x2bfb7313UL, 0x3e5674a2UL, 0xc0000000UL, 0x3fd271fdUL, 0x0549fc99UL,\n-    0x3e385d29UL, 0xc0000000UL, 0x3fd24b04UL, 0x55b63073UL, 0xbe500c6dUL,\n-    0x00000000UL, 0x3fd2241cUL, 0x3f91953aUL, 0x3e389977UL, 0xc0000000UL,\n-    0x3fd1fd43UL, 0xa1543f71UL, 0xbe3487abUL, 0xc0000000UL, 0x3fd1d67bUL,\n-    0x4ec8867cUL, 0x3df6a2dcUL, 0x00000000UL, 0x3fd1afc4UL, 0x4328e3bbUL,\n-    0x3e41d9c0UL, 0x80000000UL, 0x3fd1891cUL, 0x2e1cda84UL, 0x3e3bdd87UL,\n-    0x40000000UL, 0x3fd16285UL, 0x4b5331aeUL, 0xbe53128eUL, 0x00000000UL,\n-    0x3fd13bfeUL, 0xb9aec164UL, 0xbe52ac98UL, 0xc0000000UL, 0x3fd11586UL,\n-    0xd91e1316UL, 0xbe350630UL, 0x80000000UL, 0x3fd0ef1fUL, 0x7cacc12cUL,\n-    0x3e3f5219UL, 0x40000000UL, 0x3fd0c8c8UL, 0xbce277b7UL, 0x3e3d30c0UL,\n-    0x00000000UL, 0x3fd0a281UL, 0x2a63447dUL, 0xbe541377UL, 0x80000000UL,\n-    0x3fd07c49UL, 0xfac483b5UL, 0xbe5772ecUL, 0xc0000000UL, 0x3fd05621UL,\n-    0x36b8a570UL, 0xbe4fd4bdUL, 0xc0000000UL, 0x3fd03009UL, 0xbae505f7UL,\n-    0xbe450388UL, 0x80000000UL, 0x3fd00a01UL, 0x3e35aeadUL, 0xbe5430fcUL,\n-    0x80000000UL, 0x3fcfc811UL, 0x707475acUL, 0x3e38806eUL, 0x80000000UL,\n-    0x3fcf7c3fUL, 0xc91817fcUL, 0xbe40cceaUL, 0x80000000UL, 0x3fcf308cUL,\n-    0xae05d5e9UL, 0xbe4919b8UL, 0x80000000UL, 0x3fcee4f8UL, 0xae6cc9e6UL,\n-    0xbe530b94UL, 0x00000000UL, 0x3fce9983UL, 0x1efe3e8eUL, 0x3e57747eUL,\n-    0x00000000UL, 0x3fce4e2dUL, 0xda78d9bfUL, 0xbe59a608UL, 0x00000000UL,\n-    0x3fce02f5UL, 0x8abe2c2eUL, 0x3e4a35adUL, 0x00000000UL, 0x3fcdb7dcUL,\n-    0x1495450dUL, 0xbe0872ccUL, 0x80000000UL, 0x3fcd6ce1UL, 0x86ee0ba0UL,\n-    0xbe4f59a0UL, 0x00000000UL, 0x3fcd2205UL, 0xe81ca888UL, 0x3e5402c3UL,\n-    0x00000000UL, 0x3fccd747UL, 0x3b4424b9UL, 0x3e5dfdc3UL, 0x80000000UL,\n-    0x3fcc8ca7UL, 0xd305b56cUL, 0x3e202da6UL, 0x00000000UL, 0x3fcc4226UL,\n-    0x399a6910UL, 0xbe482a1cUL, 0x80000000UL, 0x3fcbf7c2UL, 0x747f7938UL,\n-    0xbe587372UL, 0x80000000UL, 0x3fcbad7cUL, 0x6fc246a0UL, 0x3e50d83dUL,\n-    0x00000000UL, 0x3fcb6355UL, 0xee9e9be5UL, 0xbe5c35bdUL, 0x80000000UL,\n-    0x3fcb194aUL, 0x8416c0bcUL, 0x3e546d4fUL, 0x00000000UL, 0x3fcacf5eUL,\n-    0x49f7f08fUL, 0x3e56da76UL, 0x00000000UL, 0x3fca858fUL, 0x5dc30de2UL,\n-    0x3e5f390cUL, 0x00000000UL, 0x3fca3bdeUL, 0x950583b6UL, 0xbe5e4169UL,\n-    0x80000000UL, 0x3fc9f249UL, 0x33631553UL, 0x3e52aeb1UL, 0x00000000UL,\n-    0x3fc9a8d3UL, 0xde8795a6UL, 0xbe59a504UL, 0x00000000UL, 0x3fc95f79UL,\n-    0x076bf41eUL, 0x3e5122feUL, 0x80000000UL, 0x3fc9163cUL, 0x2914c8e7UL,\n-    0x3e3dd064UL, 0x00000000UL, 0x3fc8cd1dUL, 0x3a30eca3UL, 0xbe21b4aaUL,\n-    0x80000000UL, 0x3fc8841aUL, 0xb2a96650UL, 0xbe575444UL, 0x80000000UL,\n-    0x3fc83b34UL, 0x2376c0cbUL, 0xbe2a74c7UL, 0x80000000UL, 0x3fc7f26bUL,\n-    0xd8a0b653UL, 0xbe5181b6UL, 0x00000000UL, 0x3fc7a9bfUL, 0x32257882UL,\n-    0xbe4a78b4UL, 0x00000000UL, 0x3fc7612fUL, 0x1eee8bd9UL, 0xbe1bfe9dUL,\n-    0x80000000UL, 0x3fc718bbUL, 0x0c603cc4UL, 0x3e36fdc9UL, 0x80000000UL,\n-    0x3fc6d064UL, 0x3728b8cfUL, 0xbe1e542eUL, 0x80000000UL, 0x3fc68829UL,\n-    0xc79a4067UL, 0x3e5c380fUL, 0x00000000UL, 0x3fc6400bUL, 0xf69eac69UL,\n-    0x3e550a84UL, 0x80000000UL, 0x3fc5f808UL, 0xb7a780a4UL, 0x3e5d9224UL,\n-    0x80000000UL, 0x3fc5b022UL, 0xad9dfb1eUL, 0xbe55242fUL, 0x00000000UL,\n-    0x3fc56858UL, 0x659b18beUL, 0xbe4bfda3UL, 0x80000000UL, 0x3fc520a9UL,\n-    0x66ee3631UL, 0xbe57d769UL, 0x80000000UL, 0x3fc4d916UL, 0x1ec62819UL,\n-    0x3e2427f7UL, 0x80000000UL, 0x3fc4919fUL, 0xdec25369UL, 0xbe435431UL,\n-    0x00000000UL, 0x3fc44a44UL, 0xa8acfc4bUL, 0xbe3c62e8UL, 0x00000000UL,\n-    0x3fc40304UL, 0xcf1d3eabUL, 0xbdfba29fUL, 0x80000000UL, 0x3fc3bbdfUL,\n-    0x79aba3eaUL, 0xbdf1b7c8UL, 0x80000000UL, 0x3fc374d6UL, 0xb8d186daUL,\n-    0xbe5130cfUL, 0x80000000UL, 0x3fc32de8UL, 0x9d74f152UL, 0x3e2285b6UL,\n-    0x00000000UL, 0x3fc2e716UL, 0x50ae7ca9UL, 0xbe503920UL, 0x80000000UL,\n-    0x3fc2a05eUL, 0x6caed92eUL, 0xbe533924UL, 0x00000000UL, 0x3fc259c2UL,\n-    0x9cb5034eUL, 0xbe510e31UL, 0x80000000UL, 0x3fc21340UL, 0x12c4d378UL,\n-    0xbe540b43UL, 0x80000000UL, 0x3fc1ccd9UL, 0xcc418706UL, 0x3e59887aUL,\n-    0x00000000UL, 0x3fc1868eUL, 0x921f4106UL, 0xbe528e67UL, 0x80000000UL,\n-    0x3fc1405cUL, 0x3969441eUL, 0x3e5d8051UL, 0x00000000UL, 0x3fc0fa46UL,\n-    0xd941ef5bUL, 0x3e5f9079UL, 0x80000000UL, 0x3fc0b44aUL, 0x5a3e81b2UL,\n-    0xbe567691UL, 0x00000000UL, 0x3fc06e69UL, 0x9d66afe7UL, 0xbe4d43fbUL,\n-    0x00000000UL, 0x3fc028a2UL, 0x0a92a162UL, 0xbe52f394UL, 0x00000000UL,\n-    0x3fbfc5eaUL, 0x209897e5UL, 0x3e529e37UL, 0x00000000UL, 0x3fbf3ac5UL,\n-    0x8458bd7bUL, 0x3e582831UL, 0x00000000UL, 0x3fbeafd5UL, 0xb8d8b4b8UL,\n-    0xbe486b4aUL, 0x00000000UL, 0x3fbe2518UL, 0xe0a3b7b6UL, 0x3e5bafd2UL,\n-    0x00000000UL, 0x3fbd9a90UL, 0x2bf2710eUL, 0x3e383b2bUL, 0x00000000UL,\n-    0x3fbd103cUL, 0x73eb6ab7UL, 0xbe56d78dUL, 0x00000000UL, 0x3fbc861bUL,\n-    0x32ceaff5UL, 0xbe32dc5aUL, 0x00000000UL, 0x3fbbfc2eUL, 0xbee04cb7UL,\n-    0xbe4a71a4UL, 0x00000000UL, 0x3fbb7274UL, 0x35ae9577UL, 0x3e38142fUL,\n-    0x00000000UL, 0x3fbae8eeUL, 0xcbaddab4UL, 0xbe5490f0UL, 0x00000000UL,\n-    0x3fba5f9aUL, 0x95ce1114UL, 0x3e597c71UL, 0x00000000UL, 0x3fb9d67aUL,\n-    0x6d7c0f78UL, 0x3e3abc2dUL, 0x00000000UL, 0x3fb94d8dUL, 0x2841a782UL,\n-    0xbe566cbcUL, 0x00000000UL, 0x3fb8c4d2UL, 0x6ed429c6UL, 0xbe3cfff9UL,\n-    0x00000000UL, 0x3fb83c4aUL, 0xe4a49fbbUL, 0xbe552964UL, 0x00000000UL,\n-    0x3fb7b3f4UL, 0x2193d81eUL, 0xbe42fa72UL, 0x00000000UL, 0x3fb72bd0UL,\n-    0xdd70c122UL, 0x3e527a8cUL, 0x00000000UL, 0x3fb6a3dfUL, 0x03108a54UL,\n-    0xbe450393UL, 0x00000000UL, 0x3fb61c1fUL, 0x30ff7954UL, 0x3e565840UL,\n-    0x00000000UL, 0x3fb59492UL, 0xdedd460cUL, 0xbe5422b5UL, 0x00000000UL,\n-    0x3fb50d36UL, 0x950f9f45UL, 0xbe5313f6UL, 0x00000000UL, 0x3fb4860bUL,\n-    0x582cdcb1UL, 0x3e506d39UL, 0x00000000UL, 0x3fb3ff12UL, 0x7216d3a6UL,\n-    0x3e4aa719UL, 0x00000000UL, 0x3fb3784aUL, 0x57a423fdUL, 0x3e5a9b9fUL,\n-    0x00000000UL, 0x3fb2f1b4UL, 0x7a138b41UL, 0xbe50b418UL, 0x00000000UL,\n-    0x3fb26b4eUL, 0x2fbfd7eaUL, 0x3e23a53eUL, 0x00000000UL, 0x3fb1e519UL,\n-    0x18913ccbUL, 0x3e465fc1UL, 0x00000000UL, 0x3fb15f15UL, 0x7ea24e21UL,\n-    0x3e042843UL, 0x00000000UL, 0x3fb0d941UL, 0x7c6d9c77UL, 0x3e59f61eUL,\n-    0x00000000UL, 0x3fb0539eUL, 0x114efd44UL, 0x3e4ccab7UL, 0x00000000UL,\n-    0x3faf9c56UL, 0x1777f657UL, 0x3e552f65UL, 0x00000000UL, 0x3fae91d2UL,\n-    0xc317b86aUL, 0xbe5a61e0UL, 0x00000000UL, 0x3fad87acUL, 0xb7664efbUL,\n-    0xbe41f64eUL, 0x00000000UL, 0x3fac7de6UL, 0x5d3d03a9UL, 0x3e0807a0UL,\n-    0x00000000UL, 0x3fab7480UL, 0x743c38ebUL, 0xbe3726e1UL, 0x00000000UL,\n-    0x3faa6b78UL, 0x06a253f1UL, 0x3e5ad636UL, 0x00000000UL, 0x3fa962d0UL,\n-    0xa35f541bUL, 0x3e5a187aUL, 0x00000000UL, 0x3fa85a88UL, 0x4b86e446UL,\n-    0xbe508150UL, 0x00000000UL, 0x3fa7529cUL, 0x2589cacfUL, 0x3e52938aUL,\n-    0x00000000UL, 0x3fa64b10UL, 0xaf6b11f2UL, 0xbe3454cdUL, 0x00000000UL,\n-    0x3fa543e2UL, 0x97506fefUL, 0xbe5fdec5UL, 0x00000000UL, 0x3fa43d10UL,\n-    0xe75f7dd9UL, 0xbe388dd3UL, 0x00000000UL, 0x3fa3369cUL, 0xa4139632UL,\n-    0xbdea5177UL, 0x00000000UL, 0x3fa23086UL, 0x352d6f1eUL, 0xbe565ad6UL,\n-    0x00000000UL, 0x3fa12accUL, 0x77449eb7UL, 0xbe50d5c7UL, 0x00000000UL,\n-    0x3fa0256eUL, 0x7478da78UL, 0x3e404724UL, 0x00000000UL, 0x3f9e40dcUL,\n-    0xf59cef7fUL, 0xbe539d0aUL, 0x00000000UL, 0x3f9c3790UL, 0x1511d43cUL,\n-    0x3e53c2c8UL, 0x00000000UL, 0x3f9a2f00UL, 0x9b8bff3cUL, 0xbe43b3e1UL,\n-    0x00000000UL, 0x3f982724UL, 0xad1e22a5UL, 0x3e46f0bdUL, 0x00000000UL,\n-    0x3f962000UL, 0x130d9356UL, 0x3e475ba0UL, 0x00000000UL, 0x3f941994UL,\n-    0x8f86f883UL, 0xbe513d0bUL, 0x00000000UL, 0x3f9213dcUL, 0x914d0dc8UL,\n-    0xbe534335UL, 0x00000000UL, 0x3f900ed8UL, 0x2d73e5e7UL, 0xbe22ba75UL,\n-    0x00000000UL, 0x3f8c1510UL, 0xc5b7d70eUL, 0x3e599c5dUL, 0x00000000UL,\n-    0x3f880de0UL, 0x8a27857eUL, 0xbe3d28c8UL, 0x00000000UL, 0x3f840810UL,\n-    0xda767328UL, 0x3e531b3dUL, 0x00000000UL, 0x3f8003b0UL, 0x77bacaf3UL,\n-    0xbe5f04e3UL, 0x00000000UL, 0x3f780150UL, 0xdf4b0720UL, 0x3e5a8bffUL,\n-    0x00000000UL, 0x3f6ffc40UL, 0x34c48e71UL, 0xbe3fcd99UL, 0x00000000UL,\n-    0x3f5ff6c0UL, 0x1ad218afUL, 0xbe4c78a7UL, 0x00000000UL, 0x00000000UL,\n-    0x00000000UL, 0x80000000UL\n-};\n-\n-ATTRIBUTE_ALIGNED(8) juint _log2_pow[] =\n-{\n-    0xfefa39efUL, 0x3fe62e42UL, 0xfefa39efUL, 0xbfe62e42UL\n-};\n-\n-ATTRIBUTE_ALIGNED(8) juint _DOUBLE2[] =\n-{\n-    0x00000000UL, 0x40000000UL\n-};\n-\n-ATTRIBUTE_ALIGNED(8) juint _DOUBLE0[] =\n-{\n-    0x00000000UL, 0x00000000UL\n-};\n-\n-ATTRIBUTE_ALIGNED(8) juint _DOUBLE0DOT5[] =\n-{\n-    0x00000000UL, 0x3fe00000UL\n-};\n-\n-\/\/registers,\n-\/\/ input: xmm0, xmm1\n-\/\/ scratch: xmm1, xmm2, xmm3, xmm4, xmm5, xmm6, xmm7\n-\/\/          rax, rdx, rcx, r8, r11\n-\n-\/\/ Code generated by Intel C compiler for LIBM library\n-\n-void MacroAssembler::fast_pow(XMMRegister xmm0, XMMRegister xmm1, XMMRegister xmm2, XMMRegister xmm3,\n-                              XMMRegister xmm4, XMMRegister xmm5, XMMRegister xmm6, XMMRegister xmm7,\n-                              Register eax, Register ecx, Register edx,\n-                              Register tmp1, Register tmp2, Register tmp3, Register tmp4) {\n-  Label L_2TAG_PACKET_0_0_2, L_2TAG_PACKET_1_0_2, L_2TAG_PACKET_2_0_2, L_2TAG_PACKET_3_0_2;\n-  Label L_2TAG_PACKET_4_0_2, L_2TAG_PACKET_5_0_2, L_2TAG_PACKET_6_0_2, L_2TAG_PACKET_7_0_2;\n-  Label L_2TAG_PACKET_8_0_2, L_2TAG_PACKET_9_0_2, L_2TAG_PACKET_10_0_2, L_2TAG_PACKET_11_0_2;\n-  Label L_2TAG_PACKET_12_0_2, L_2TAG_PACKET_13_0_2, L_2TAG_PACKET_14_0_2, L_2TAG_PACKET_15_0_2;\n-  Label L_2TAG_PACKET_16_0_2, L_2TAG_PACKET_17_0_2, L_2TAG_PACKET_18_0_2, L_2TAG_PACKET_19_0_2;\n-  Label L_2TAG_PACKET_20_0_2, L_2TAG_PACKET_21_0_2, L_2TAG_PACKET_22_0_2, L_2TAG_PACKET_23_0_2;\n-  Label L_2TAG_PACKET_24_0_2, L_2TAG_PACKET_25_0_2, L_2TAG_PACKET_26_0_2, L_2TAG_PACKET_27_0_2;\n-  Label L_2TAG_PACKET_28_0_2, L_2TAG_PACKET_29_0_2, L_2TAG_PACKET_30_0_2, L_2TAG_PACKET_31_0_2;\n-  Label L_2TAG_PACKET_32_0_2, L_2TAG_PACKET_33_0_2, L_2TAG_PACKET_34_0_2, L_2TAG_PACKET_35_0_2;\n-  Label L_2TAG_PACKET_36_0_2, L_2TAG_PACKET_37_0_2, L_2TAG_PACKET_38_0_2, L_2TAG_PACKET_39_0_2;\n-  Label L_2TAG_PACKET_40_0_2, L_2TAG_PACKET_41_0_2, L_2TAG_PACKET_42_0_2, L_2TAG_PACKET_43_0_2;\n-  Label L_2TAG_PACKET_44_0_2, L_2TAG_PACKET_45_0_2, L_2TAG_PACKET_46_0_2, L_2TAG_PACKET_47_0_2;\n-  Label L_2TAG_PACKET_48_0_2, L_2TAG_PACKET_49_0_2, L_2TAG_PACKET_50_0_2, L_2TAG_PACKET_51_0_2;\n-  Label L_2TAG_PACKET_52_0_2, L_2TAG_PACKET_53_0_2, L_2TAG_PACKET_54_0_2, L_2TAG_PACKET_55_0_2;\n-  Label L_2TAG_PACKET_56_0_2;\n-  Label B1_2, B1_3, B1_5;\n-  Label L_POW;\n-\n-  assert_different_registers(tmp1, tmp2, eax, ecx, edx);\n-  address HIGHSIGMASK = (address)_HIGHSIGMASK;\n-  address LOG2_E = (address)_LOG2_E;\n-  address coeff = (address)_coeff_pow;\n-  address L_tbl = (address)_L_tbl_pow;\n-  address HIGHMASK_Y = (address)_HIGHMASK_Y;\n-  address T_exp = (address)_T_exp;\n-  address e_coeff = (address)_e_coeff;\n-  address coeff_h = (address)_coeff_h;\n-  address HIGHMASK_LOG_X = (address)_HIGHMASK_LOG_X;\n-  address HALFMASK = (address)_HALFMASK;\n-  address log2 = (address)_log2_pow;\n-  address DOUBLE2 = (address)_DOUBLE2;\n-  address DOUBLE0 = (address)_DOUBLE0;\n-  address DOUBLE0DOT5 = (address)_DOUBLE0DOT5;\n-\n-  subq(rsp, 40);\n-  movsd(Address(rsp, 8), xmm0);\n-  movsd(Address(rsp, 16), xmm1);\n-\n-  \/\/ Special case: pow(x, 2.0) => x * x\n-  movdq(tmp1, xmm1);\n-  cmp64(tmp1, ExternalAddress(DOUBLE2), tmp2 \/*rscratch*\/);\n-  jccb(Assembler::notEqual, B1_2);\n-  mulsd(xmm0, xmm0);\n-  jmp(B1_5);\n-\n-  \/\/ Special case: pow(x, 0.5) => sqrt(x)\n-  bind(B1_2);\n-  cmp64(tmp1, ExternalAddress(DOUBLE0DOT5), tmp2 \/*rscratch*\/);\n-  jccb(Assembler::notEqual, L_POW); \/\/ For pow(x, y), check whether y == 0.5\n-  movdq(tmp2, xmm0);\n-  cmp64(tmp2, ExternalAddress(DOUBLE0), tmp3 \/*rscratch*\/);\n-  jccb(Assembler::less, L_POW); \/\/ pow(x, 0.5) => sqrt(x) only for x >= 0.0 or x is +inf\/NaN\n-  sqrtsd(xmm0, xmm0);\n-  jmp(B1_5);\n-\n-  bind(L_POW);\n-  pextrw(eax, xmm0, 3);\n-  xorpd(xmm2, xmm2);\n-  mov64(tmp2, 0x3ff0000000000000);\n-  movdq(xmm2, tmp2);\n-  movl(tmp1, 1069088768);\n-  movdq(xmm7, tmp1);\n-  xorpd(xmm1, xmm1);\n-  mov64(tmp3, 0x77f0000000000000);\n-  movdq(xmm1, tmp3);\n-  movdqu(xmm3, xmm0);\n-  movl(edx, 32752);\n-  andl(edx, eax);\n-  subl(edx, 16368);\n-  movl(ecx, edx);\n-  sarl(edx, 31);\n-  addl(ecx, edx);\n-  xorl(ecx, edx);\n-  por(xmm0, xmm2);\n-  movdqu(xmm6, ExternalAddress(HIGHSIGMASK), tmp2 \/*rscratch*\/);    \/\/0x00000000UL, 0xfffff800UL, 0x00000000UL, 0xfffff800UL\n-  psrlq(xmm0, 27);\n-  movq(xmm2, ExternalAddress(LOG2_E), tmp2 \/*rscratch*\/);    \/\/0x00000000UL, 0x3ff72000UL, 0x161bb241UL, 0xbf5dabe1UL\n-  psrld(xmm0, 2);\n-  addl(ecx, 16);\n-  bsrl(ecx, ecx);\n-  rcpps(xmm0, xmm0);\n-  psllq(xmm3, 12);\n-  movl(tmp4, 8192);\n-  movdq(xmm4, tmp4);\n-  psrlq(xmm3, 12);\n-  subl(eax, 16);\n-  cmpl(eax, 32736);\n-  jcc(Assembler::aboveEqual, L_2TAG_PACKET_0_0_2);\n-  movl(tmp1, 0);\n-\n-  bind(L_2TAG_PACKET_1_0_2);\n-  mulss(xmm0, xmm7);\n-  movl(edx, -1);\n-  subl(ecx, 4);\n-  shll(edx);\n-  shlq(edx, 32);\n-  movdq(xmm5, edx);\n-  por(xmm3, xmm1);\n-  subl(eax, 16351);\n-  cmpl(eax, 1);\n-  jcc(Assembler::belowEqual, L_2TAG_PACKET_2_0_2);\n-  paddd(xmm0, xmm4);\n-  pand(xmm5, xmm3);\n-  movdl(edx, xmm0);\n-  psllq(xmm0, 29);\n-\n-  bind(L_2TAG_PACKET_3_0_2);\n-  subsd(xmm3, xmm5);\n-  pand(xmm0, xmm6);\n-  subl(eax, 1);\n-  sarl(eax, 4);\n-  cvtsi2sdl(xmm7, eax);\n-  mulpd(xmm5, xmm0);\n-\n-  bind(L_2TAG_PACKET_4_0_2);\n-  mulsd(xmm3, xmm0);\n-  movdqu(xmm1, ExternalAddress(coeff), tmp2 \/*rscratch*\/);    \/\/0x6dc96112UL, 0xbf836578UL, 0xee241472UL, 0xbf9b0301UL\n-  lea(tmp4, ExternalAddress(L_tbl));\n-  subsd(xmm5, xmm2);\n-  movdqu(xmm4, ExternalAddress(coeff + 16), tmp2 \/*rscratch*\/);    \/\/0x9f95985aUL, 0xbfb528dbUL, 0xb3841d2aUL, 0xbfd619b6UL\n-  movl(ecx, eax);\n-  sarl(eax, 31);\n-  addl(ecx, eax);\n-  xorl(eax, ecx);\n-  addl(eax, 1);\n-  bsrl(eax, eax);\n-  unpcklpd(xmm5, xmm3);\n-  movdqu(xmm6, ExternalAddress(coeff + 32), tmp2 \/*rscratch*\/);    \/\/0x518775e3UL, 0x3f9004f2UL, 0xac8349bbUL, 0x3fa76c9bUL\n-  addsd(xmm3, xmm5);\n-  andl(edx, 16760832);\n-  shrl(edx, 10);\n-  addpd(xmm5, Address(tmp4, edx, Address::times_1, -3648));\n-  movdqu(xmm0, ExternalAddress(coeff + 48), tmp2 \/*rscratch*\/);    \/\/0x486ececcUL, 0x3fc4635eUL, 0x161bb241UL, 0xbf5dabe1UL\n-  pshufd(xmm2, xmm3, 68);\n-  mulsd(xmm3, xmm3);\n-  mulpd(xmm1, xmm2);\n-  mulpd(xmm4, xmm2);\n-  addsd(xmm5, xmm7);\n-  mulsd(xmm2, xmm3);\n-  addpd(xmm6, xmm1);\n-  mulsd(xmm3, xmm3);\n-  addpd(xmm0, xmm4);\n-  movq(xmm1, Address(rsp, 16));\n-  movw(ecx, Address(rsp, 22));\n-  pshufd(xmm7, xmm5, 238);\n-  movq(xmm4, ExternalAddress(HIGHMASK_Y), tmp2 \/*rscratch*\/);    \/\/0x00000000UL, 0xfffffff8UL, 0x00000000UL, 0xffffffffUL\n-  mulpd(xmm6, xmm2);\n-  pshufd(xmm3, xmm3, 68);\n-  mulpd(xmm0, xmm2);\n-  shll(eax, 4);\n-  subl(eax, 15872);\n-  andl(ecx, 32752);\n-  addl(eax, ecx);\n-  mulpd(xmm3, xmm6);\n-  cmpl(eax, 624);\n-  jcc(Assembler::aboveEqual, L_2TAG_PACKET_5_0_2);\n-  xorpd(xmm6, xmm6);\n-  movl(edx, 17080);\n-  pinsrw(xmm6, edx, 3);\n-  movdqu(xmm2, xmm1);\n-  pand(xmm4, xmm1);\n-  subsd(xmm1, xmm4);\n-  mulsd(xmm4, xmm5);\n-  addsd(xmm0, xmm7);\n-  mulsd(xmm1, xmm5);\n-  movdqu(xmm7, xmm6);\n-  addsd(xmm6, xmm4);\n-  lea(tmp4, ExternalAddress(T_exp));\n-  addpd(xmm3, xmm0);\n-  movdl(edx, xmm6);\n-  subsd(xmm6, xmm7);\n-  pshufd(xmm0, xmm3, 238);\n-  subsd(xmm4, xmm6);\n-  addsd(xmm0, xmm3);\n-  movl(ecx, edx);\n-  andl(edx, 255);\n-  addl(edx, edx);\n-  movdqu(xmm5, Address(tmp4, edx, Address::times_8, 0));\n-  addsd(xmm4, xmm1);\n-  mulsd(xmm2, xmm0);\n-  movdqu(xmm7, ExternalAddress(e_coeff),      tmp2 \/*rscratch*\/);    \/\/0xe78a6731UL, 0x3f55d87fUL, 0xd704a0c0UL, 0x3fac6b08UL\n-  movdqu(xmm3, ExternalAddress(e_coeff + 16), tmp2 \/*rscratch*\/);    \/\/0x6fba4e77UL, 0x3f83b2abUL, 0xff82c58fUL, 0x3fcebfbdUL\n-  shll(ecx, 12);\n-  xorl(ecx, tmp1);\n-  andl(rcx, -1048576);\n-  movdq(xmm6, rcx);\n-  addsd(xmm2, xmm4);\n-  mov64(tmp2, 0x3fe62e42fefa39ef);\n-  movdq(xmm1, tmp2);\n-  pshufd(xmm0, xmm2, 68);\n-  pshufd(xmm4, xmm2, 68);\n-  mulsd(xmm1, xmm2);\n-  pshufd(xmm6, xmm6, 17);\n-  mulpd(xmm0, xmm0);\n-  mulpd(xmm7, xmm4);\n-  paddd(xmm5, xmm6);\n-  mulsd(xmm1, xmm5);\n-  pshufd(xmm6, xmm5, 238);\n-  mulsd(xmm0, xmm0);\n-  addpd(xmm3, xmm7);\n-  addsd(xmm1, xmm6);\n-  mulpd(xmm0, xmm3);\n-  pshufd(xmm3, xmm0, 238);\n-  mulsd(xmm0, xmm5);\n-  mulsd(xmm3, xmm5);\n-  addsd(xmm0, xmm1);\n-  addsd(xmm0, xmm3);\n-  addsd(xmm0, xmm5);\n-  jmp(B1_5);\n-\n-  bind(L_2TAG_PACKET_0_0_2);\n-  addl(eax, 16);\n-  movl(edx, 32752);\n-  andl(edx, eax);\n-  cmpl(edx, 32752);\n-  jcc(Assembler::equal, L_2TAG_PACKET_6_0_2);\n-  testl(eax, 32768);\n-  jcc(Assembler::notEqual, L_2TAG_PACKET_7_0_2);\n-\n-  bind(L_2TAG_PACKET_8_0_2);\n-  movq(xmm0, Address(rsp, 8));\n-  movq(xmm3, Address(rsp, 8));\n-  movdl(edx, xmm3);\n-  psrlq(xmm3, 32);\n-  movdl(ecx, xmm3);\n-  orl(edx, ecx);\n-  cmpl(edx, 0);\n-  jcc(Assembler::equal, L_2TAG_PACKET_9_0_2);\n-  xorpd(xmm3, xmm3);\n-  movl(eax, 18416);\n-  pinsrw(xmm3, eax, 3);\n-  mulsd(xmm0, xmm3);\n-  xorpd(xmm2, xmm2);\n-  movl(eax, 16368);\n-  pinsrw(xmm2, eax, 3);\n-  movdqu(xmm3, xmm0);\n-  pextrw(eax, xmm0, 3);\n-  por(xmm0, xmm2);\n-  movl(ecx, 18416);\n-  psrlq(xmm0, 27);\n-  movq(xmm2, ExternalAddress(LOG2_E), tmp2 \/*rscratch*\/);    \/\/0x00000000UL, 0x3ff72000UL, 0x161bb241UL, 0xbf5dabe1UL\n-  psrld(xmm0, 2);\n-  rcpps(xmm0, xmm0);\n-  psllq(xmm3, 12);\n-  movdqu(xmm6, ExternalAddress(HIGHSIGMASK), tmp2 \/*rscratch*\/);    \/\/0x00000000UL, 0xfffff800UL, 0x00000000UL, 0xfffff800UL\n-  psrlq(xmm3, 12);\n-  mulss(xmm0, xmm7);\n-  movl(edx, -1024);\n-  movdl(xmm5, edx);\n-  por(xmm3, xmm1);\n-  paddd(xmm0, xmm4);\n-  psllq(xmm5, 32);\n-  movdl(edx, xmm0);\n-  psllq(xmm0, 29);\n-  pand(xmm5, xmm3);\n-  movl(tmp1, 0);\n-  pand(xmm0, xmm6);\n-  subsd(xmm3, xmm5);\n-  andl(eax, 32752);\n-  subl(eax, 18416);\n-  sarl(eax, 4);\n-  cvtsi2sdl(xmm7, eax);\n-  mulpd(xmm5, xmm0);\n-  jmp(L_2TAG_PACKET_4_0_2);\n-\n-  bind(L_2TAG_PACKET_10_0_2);\n-  movq(xmm0, Address(rsp, 8));\n-  movq(xmm3, Address(rsp, 8));\n-  movdl(edx, xmm3);\n-  psrlq(xmm3, 32);\n-  movdl(ecx, xmm3);\n-  orl(edx, ecx);\n-  cmpl(edx, 0);\n-  jcc(Assembler::equal, L_2TAG_PACKET_9_0_2);\n-  xorpd(xmm3, xmm3);\n-  movl(eax, 18416);\n-  pinsrw(xmm3, eax, 3);\n-  mulsd(xmm0, xmm3);\n-  xorpd(xmm2, xmm2);\n-  movl(eax, 16368);\n-  pinsrw(xmm2, eax, 3);\n-  movdqu(xmm3, xmm0);\n-  pextrw(eax, xmm0, 3);\n-  por(xmm0, xmm2);\n-  movl(ecx, 18416);\n-  psrlq(xmm0, 27);\n-  movq(xmm2, ExternalAddress(LOG2_E), tmp2 \/*rscratch*\/);    \/\/0x00000000UL, 0x3ff72000UL, 0x161bb241UL, 0xbf5dabe1UL\n-  psrld(xmm0, 2);\n-  rcpps(xmm0, xmm0);\n-  psllq(xmm3, 12);\n-  movdqu(xmm6, ExternalAddress(HIGHSIGMASK), tmp2 \/*rscratch*\/);    \/\/0x00000000UL, 0xfffff800UL, 0x00000000UL, 0xfffff800UL\n-  psrlq(xmm3, 12);\n-  mulss(xmm0, xmm7);\n-  movl(edx, -1024);\n-  movdl(xmm5, edx);\n-  por(xmm3, xmm1);\n-  paddd(xmm0, xmm4);\n-  psllq(xmm5, 32);\n-  movdl(edx, xmm0);\n-  psllq(xmm0, 29);\n-  pand(xmm5, xmm3);\n-  movl(tmp1, INT_MIN);\n-  pand(xmm0, xmm6);\n-  subsd(xmm3, xmm5);\n-  andl(eax, 32752);\n-  subl(eax, 18416);\n-  sarl(eax, 4);\n-  cvtsi2sdl(xmm7, eax);\n-  mulpd(xmm5, xmm0);\n-  jmp(L_2TAG_PACKET_4_0_2);\n-\n-  bind(L_2TAG_PACKET_5_0_2);\n-  cmpl(eax, 0);\n-  jcc(Assembler::less, L_2TAG_PACKET_11_0_2);\n-  cmpl(eax, 752);\n-  jcc(Assembler::aboveEqual, L_2TAG_PACKET_12_0_2);\n-  addsd(xmm0, xmm7);\n-  movq(xmm2, ExternalAddress(HALFMASK), tmp2 \/*rscratch*\/);    \/\/0xf8000000UL, 0xffffffffUL, 0xf8000000UL, 0xffffffffUL\n-  addpd(xmm3, xmm0);\n-  xorpd(xmm6, xmm6);\n-  movl(eax, 17080);\n-  pinsrw(xmm6, eax, 3);\n-  pshufd(xmm0, xmm3, 238);\n-  addsd(xmm0, xmm3);\n-  movdqu(xmm3, xmm5);\n-  addsd(xmm5, xmm0);\n-  movdqu(xmm4, xmm2);\n-  subsd(xmm3, xmm5);\n-  movdqu(xmm7, xmm5);\n-  pand(xmm5, xmm2);\n-  movdqu(xmm2, xmm1);\n-  pand(xmm4, xmm1);\n-  subsd(xmm7, xmm5);\n-  addsd(xmm0, xmm3);\n-  subsd(xmm1, xmm4);\n-  mulsd(xmm4, xmm5);\n-  addsd(xmm0, xmm7);\n-  mulsd(xmm2, xmm0);\n-  movdqu(xmm7, xmm6);\n-  mulsd(xmm1, xmm5);\n-  addsd(xmm6, xmm4);\n-  movdl(eax, xmm6);\n-  subsd(xmm6, xmm7);\n-  lea(tmp4, ExternalAddress(T_exp));\n-  addsd(xmm2, xmm1);\n-  movdqu(xmm7, ExternalAddress(e_coeff +  0), tmp2 \/*rscratch*\/);    \/\/0xe78a6731UL, 0x3f55d87fUL, 0xd704a0c0UL, 0x3fac6b08UL\n-  movdqu(xmm3, ExternalAddress(e_coeff + 16), tmp2 \/*rscratch*\/);    \/\/0x6fba4e77UL, 0x3f83b2abUL, 0xff82c58fUL, 0x3fcebfbdUL\n-  subsd(xmm4, xmm6);\n-  pextrw(edx, xmm6, 3);\n-  movl(ecx, eax);\n-  andl(eax, 255);\n-  addl(eax, eax);\n-  movdqu(xmm5, Address(tmp4, rax, Address::times_8, 0));\n-  addsd(xmm2, xmm4);\n-  sarl(ecx, 8);\n-  movl(eax, ecx);\n-  sarl(ecx, 1);\n-  subl(eax, ecx);\n-  shll(ecx, 20);\n-  xorl(ecx, tmp1);\n-  movdl(xmm6, ecx);\n-  movq(xmm1, ExternalAddress(e_coeff + 32), tmp2 \/*rscratch*\/);    \/\/0xfefa39efUL, 0x3fe62e42UL, 0x00000000UL, 0x00000000UL\n-  andl(edx, 32767);\n-  cmpl(edx, 16529);\n-  jcc(Assembler::above, L_2TAG_PACKET_12_0_2);\n-  pshufd(xmm0, xmm2, 68);\n-  pshufd(xmm4, xmm2, 68);\n-  mulpd(xmm0, xmm0);\n-  mulpd(xmm7, xmm4);\n-  pshufd(xmm6, xmm6, 17);\n-  mulsd(xmm1, xmm2);\n-  mulsd(xmm0, xmm0);\n-  paddd(xmm5, xmm6);\n-  addpd(xmm3, xmm7);\n-  mulsd(xmm1, xmm5);\n-  pshufd(xmm6, xmm5, 238);\n-  mulpd(xmm0, xmm3);\n-  addsd(xmm1, xmm6);\n-  pshufd(xmm3, xmm0, 238);\n-  mulsd(xmm0, xmm5);\n-  mulsd(xmm3, xmm5);\n-  shll(eax, 4);\n-  xorpd(xmm4, xmm4);\n-  addl(eax, 16368);\n-  pinsrw(xmm4, eax, 3);\n-  addsd(xmm0, xmm1);\n-  addsd(xmm0, xmm3);\n-  movdqu(xmm1, xmm0);\n-  addsd(xmm0, xmm5);\n-  mulsd(xmm0, xmm4);\n-  pextrw(eax, xmm0, 3);\n-  andl(eax, 32752);\n-  jcc(Assembler::equal, L_2TAG_PACKET_13_0_2);\n-  cmpl(eax, 32752);\n-  jcc(Assembler::equal, L_2TAG_PACKET_14_0_2);\n-  jmp(B1_5);\n-\n-  bind(L_2TAG_PACKET_6_0_2);\n-  movq(xmm1, Address(rsp, 16));\n-  movq(xmm0, Address(rsp, 8));\n-  movdqu(xmm2, xmm0);\n-  movdl(eax, xmm2);\n-  psrlq(xmm2, 20);\n-  movdl(edx, xmm2);\n-  orl(eax, edx);\n-  jcc(Assembler::equal, L_2TAG_PACKET_15_0_2);\n-  movdl(eax, xmm1);\n-  psrlq(xmm1, 32);\n-  movdl(edx, xmm1);\n-  movl(ecx, edx);\n-  addl(edx, edx);\n-  orl(eax, edx);\n-  jcc(Assembler::equal, L_2TAG_PACKET_16_0_2);\n-  addsd(xmm0, xmm0);\n-  jmp(B1_5);\n-\n-  bind(L_2TAG_PACKET_16_0_2);\n-  xorpd(xmm0, xmm0);\n-  movl(eax, 16368);\n-  pinsrw(xmm0, eax, 3);\n-  movl(Address(rsp, 0), 29);\n-  jmp(L_2TAG_PACKET_17_0_2);\n-\n-  bind(L_2TAG_PACKET_18_0_2);\n-  movq(xmm0, Address(rsp, 16));\n-  addpd(xmm0, xmm0);\n-  jmp(B1_5);\n-\n-  bind(L_2TAG_PACKET_15_0_2);\n-  movdl(eax, xmm1);\n-  movdqu(xmm2, xmm1);\n-  psrlq(xmm1, 32);\n-  movdl(edx, xmm1);\n-  movl(ecx, edx);\n-  addl(edx, edx);\n-  orl(eax, edx);\n-  jcc(Assembler::equal, L_2TAG_PACKET_19_0_2);\n-  pextrw(eax, xmm2, 3);\n-  andl(eax, 32752);\n-  cmpl(eax, 32752);\n-  jcc(Assembler::notEqual, L_2TAG_PACKET_20_0_2);\n-  movdl(eax, xmm2);\n-  psrlq(xmm2, 20);\n-  movdl(edx, xmm2);\n-  orl(eax, edx);\n-  jcc(Assembler::notEqual, L_2TAG_PACKET_18_0_2);\n-\n-  bind(L_2TAG_PACKET_20_0_2);\n-  pextrw(eax, xmm0, 3);\n-  testl(eax, 32768);\n-  jcc(Assembler::notEqual, L_2TAG_PACKET_21_0_2);\n-  testl(ecx, INT_MIN);\n-  jcc(Assembler::notEqual, L_2TAG_PACKET_22_0_2);\n-  jmp(B1_5);\n-\n-  bind(L_2TAG_PACKET_23_0_2);\n-  movq(xmm1, Address(rsp, 16));\n-  movdl(eax, xmm1);\n-  testl(eax, 1);\n-  jcc(Assembler::notEqual, L_2TAG_PACKET_24_0_2);\n-  testl(eax, 2);\n-  jcc(Assembler::notEqual, L_2TAG_PACKET_25_0_2);\n-  jmp(L_2TAG_PACKET_24_0_2);\n-\n-  bind(L_2TAG_PACKET_21_0_2);\n-  shrl(ecx, 20);\n-  andl(ecx, 2047);\n-  cmpl(ecx, 1075);\n-  jcc(Assembler::above, L_2TAG_PACKET_24_0_2);\n-  jcc(Assembler::equal, L_2TAG_PACKET_26_0_2);\n-  cmpl(ecx, 1074);\n-  jcc(Assembler::above, L_2TAG_PACKET_23_0_2);\n-  cmpl(ecx, 1023);\n-  jcc(Assembler::below, L_2TAG_PACKET_24_0_2);\n-  movq(xmm1, Address(rsp, 16));\n-  movl(eax, 17208);\n-  xorpd(xmm3, xmm3);\n-  pinsrw(xmm3, eax, 3);\n-  movdqu(xmm4, xmm3);\n-  addsd(xmm3, xmm1);\n-  subsd(xmm4, xmm3);\n-  addsd(xmm1, xmm4);\n-  pextrw(eax, xmm1, 3);\n-  andl(eax, 32752);\n-  jcc(Assembler::notEqual, L_2TAG_PACKET_24_0_2);\n-  movdl(eax, xmm3);\n-  andl(eax, 1);\n-  jcc(Assembler::equal, L_2TAG_PACKET_24_0_2);\n-\n-  bind(L_2TAG_PACKET_25_0_2);\n-  movq(xmm1, Address(rsp, 16));\n-  pextrw(eax, xmm1, 3);\n-  andl(eax, 32768);\n-  jcc(Assembler::notEqual, L_2TAG_PACKET_27_0_2);\n-  jmp(B1_5);\n-\n-  bind(L_2TAG_PACKET_27_0_2);\n-  xorpd(xmm0, xmm0);\n-  movl(eax, 32768);\n-  pinsrw(xmm0, eax, 3);\n-  jmp(B1_5);\n-\n-  bind(L_2TAG_PACKET_24_0_2);\n-  movq(xmm1, Address(rsp, 16));\n-  pextrw(eax, xmm1, 3);\n-  andl(eax, 32768);\n-  jcc(Assembler::notEqual, L_2TAG_PACKET_22_0_2);\n-  xorpd(xmm0, xmm0);\n-  movl(eax, 32752);\n-  pinsrw(xmm0, eax, 3);\n-  jmp(B1_5);\n-\n-  bind(L_2TAG_PACKET_26_0_2);\n-  movq(xmm1, Address(rsp, 16));\n-  movdl(eax, xmm1);\n-  andl(eax, 1);\n-  jcc(Assembler::equal, L_2TAG_PACKET_24_0_2);\n-  jmp(L_2TAG_PACKET_25_0_2);\n-\n-  bind(L_2TAG_PACKET_28_0_2);\n-  movdl(eax, xmm1);\n-  psrlq(xmm1, 20);\n-  movdl(edx, xmm1);\n-  orl(eax, edx);\n-  jcc(Assembler::equal, L_2TAG_PACKET_29_0_2);\n-  movq(xmm0, Address(rsp, 16));\n-  addsd(xmm0, xmm0);\n-  jmp(B1_5);\n-\n-  bind(L_2TAG_PACKET_29_0_2);\n-  movq(xmm0, Address(rsp, 8));\n-  pextrw(eax, xmm0, 3);\n-  cmpl(eax, 49136);\n-  jcc(Assembler::notEqual, L_2TAG_PACKET_30_0_2);\n-  movdl(ecx, xmm0);\n-  psrlq(xmm0, 20);\n-  movdl(edx, xmm0);\n-  orl(ecx, edx);\n-  jcc(Assembler::notEqual, L_2TAG_PACKET_30_0_2);\n-  xorpd(xmm0, xmm0);\n-  movl(eax, 32760);\n-  pinsrw(xmm0, eax, 3);\n-  jmp(B1_5);\n-\n-  bind(L_2TAG_PACKET_30_0_2);\n-  movq(xmm1, Address(rsp, 16));\n-  andl(eax, 32752);\n-  subl(eax, 16368);\n-  pextrw(edx, xmm1, 3);\n-  xorpd(xmm0, xmm0);\n-  xorl(eax, edx);\n-  andl(eax, 32768);\n-  jcc(Assembler::equal, L_2TAG_PACKET_31_0_2);\n-  jmp(B1_5);\n-\n-  bind(L_2TAG_PACKET_31_0_2);\n-  movl(ecx, 32752);\n-  pinsrw(xmm0, ecx, 3);\n-  jmp(B1_5);\n-\n-  bind(L_2TAG_PACKET_32_0_2);\n-  movdl(eax, xmm1);\n-  cmpl(edx, 17184);\n-  jcc(Assembler::above, L_2TAG_PACKET_33_0_2);\n-  testl(eax, 1);\n-  jcc(Assembler::notEqual, L_2TAG_PACKET_34_0_2);\n-  testl(eax, 2);\n-  jcc(Assembler::equal, L_2TAG_PACKET_35_0_2);\n-  jmp(L_2TAG_PACKET_36_0_2);\n-\n-  bind(L_2TAG_PACKET_33_0_2);\n-  testl(eax, 1);\n-  jcc(Assembler::equal, L_2TAG_PACKET_35_0_2);\n-  jmp(L_2TAG_PACKET_36_0_2);\n-\n-  bind(L_2TAG_PACKET_7_0_2);\n-  movq(xmm2, Address(rsp, 8));\n-  movdl(eax, xmm2);\n-  psrlq(xmm2, 31);\n-  movdl(ecx, xmm2);\n-  orl(eax, ecx);\n-  jcc(Assembler::equal, L_2TAG_PACKET_9_0_2);\n-  movq(xmm1, Address(rsp, 16));\n-  pextrw(edx, xmm1, 3);\n-  movdl(eax, xmm1);\n-  movdqu(xmm2, xmm1);\n-  psrlq(xmm2, 32);\n-  movdl(ecx, xmm2);\n-  addl(ecx, ecx);\n-  orl(ecx, eax);\n-  jcc(Assembler::equal, L_2TAG_PACKET_37_0_2);\n-  andl(edx, 32752);\n-  cmpl(edx, 32752);\n-  jcc(Assembler::equal, L_2TAG_PACKET_28_0_2);\n-  cmpl(edx, 17200);\n-  jcc(Assembler::above, L_2TAG_PACKET_35_0_2);\n-  cmpl(edx, 17184);\n-  jcc(Assembler::aboveEqual, L_2TAG_PACKET_32_0_2);\n-  cmpl(edx, 16368);\n-  jcc(Assembler::below, L_2TAG_PACKET_34_0_2);\n-  movl(eax, 17208);\n-  xorpd(xmm2, xmm2);\n-  pinsrw(xmm2, eax, 3);\n-  movdqu(xmm4, xmm2);\n-  addsd(xmm2, xmm1);\n-  subsd(xmm4, xmm2);\n-  addsd(xmm1, xmm4);\n-  pextrw(eax, xmm1, 3);\n-  andl(eax, 32767);\n-  jcc(Assembler::notEqual, L_2TAG_PACKET_34_0_2);\n-  movdl(eax, xmm2);\n-  andl(eax, 1);\n-  jcc(Assembler::equal, L_2TAG_PACKET_35_0_2);\n-\n-  bind(L_2TAG_PACKET_36_0_2);\n-  xorpd(xmm1, xmm1);\n-  movl(edx, 30704);\n-  pinsrw(xmm1, edx, 3);\n-  movq(xmm2, ExternalAddress(LOG2_E), tmp2 \/*rscratch*\/);    \/\/0x00000000UL, 0x3ff72000UL, 0x161bb241UL, 0xbf5dabe1UL\n-  movq(xmm4, Address(rsp, 8));\n-  pextrw(eax, xmm4, 3);\n-  movl(edx, 8192);\n-  movdl(xmm4, edx);\n-  andl(eax, 32767);\n-  subl(eax, 16);\n-  jcc(Assembler::less, L_2TAG_PACKET_10_0_2);\n-  movl(edx, eax);\n-  andl(edx, 32752);\n-  subl(edx, 16368);\n-  movl(ecx, edx);\n-  sarl(edx, 31);\n-  addl(ecx, edx);\n-  xorl(ecx, edx);\n-  addl(ecx, 16);\n-  bsrl(ecx, ecx);\n-  movl(tmp1, INT_MIN);\n-  jmp(L_2TAG_PACKET_1_0_2);\n-\n-  bind(L_2TAG_PACKET_34_0_2);\n-  xorpd(xmm1, xmm1);\n-  movl(eax, 32752);\n-  pinsrw(xmm1, eax, 3);\n-  xorpd(xmm0, xmm0);\n-  mulsd(xmm0, xmm1);\n-  movl(Address(rsp, 0), 28);\n-  jmp(L_2TAG_PACKET_17_0_2);\n-\n-  bind(L_2TAG_PACKET_35_0_2);\n-  xorpd(xmm1, xmm1);\n-  movl(edx, 30704);\n-  pinsrw(xmm1, edx, 3);\n-  movq(xmm2, ExternalAddress(LOG2_E), tmp2 \/*rscratch*\/);    \/\/0x00000000UL, 0x3ff72000UL, 0x161bb241UL, 0xbf5dabe1UL\n-  movq(xmm4, Address(rsp, 8));\n-  pextrw(eax, xmm4, 3);\n-  movl(edx, 8192);\n-  movdl(xmm4, edx);\n-  andl(eax, 32767);\n-  subl(eax, 16);\n-  jcc(Assembler::less, L_2TAG_PACKET_8_0_2);\n-  movl(edx, eax);\n-  andl(edx, 32752);\n-  subl(edx, 16368);\n-  movl(ecx, edx);\n-  sarl(edx, 31);\n-  addl(ecx, edx);\n-  xorl(ecx, edx);\n-  addl(ecx, 16);\n-  bsrl(ecx, ecx);\n-  movl(tmp1, 0);\n-  jmp(L_2TAG_PACKET_1_0_2);\n-\n-  bind(L_2TAG_PACKET_19_0_2);\n-  xorpd(xmm0, xmm0);\n-  movl(eax, 16368);\n-  pinsrw(xmm0, eax, 3);\n-  jmp(B1_5);\n-\n-  bind(L_2TAG_PACKET_22_0_2);\n-  xorpd(xmm0, xmm0);\n-  jmp(B1_5);\n-\n-  bind(L_2TAG_PACKET_11_0_2);\n-  addl(eax, 384);\n-  cmpl(eax, 0);\n-  jcc(Assembler::less, L_2TAG_PACKET_38_0_2);\n-  mulsd(xmm5, xmm1);\n-  addsd(xmm0, xmm7);\n-  shrl(tmp1, 31);\n-  addpd(xmm3, xmm0);\n-  pshufd(xmm0, xmm3, 238);\n-  addsd(xmm3, xmm0);\n-  lea(tmp4, ExternalAddress(log2));    \/\/0xfefa39efUL, 0x3fe62e42UL, 0xfefa39efUL, 0xbfe62e42UL\n-  movq(xmm4, Address(tmp4, tmp1, Address::times_8, 0));\n-  mulsd(xmm1, xmm3);\n-  xorpd(xmm0, xmm0);\n-  movl(eax, 16368);\n-  shll(tmp1, 15);\n-  orl(eax, tmp1);\n-  pinsrw(xmm0, eax, 3);\n-  addsd(xmm5, xmm1);\n-  mulsd(xmm5, xmm4);\n-  addsd(xmm0, xmm5);\n-  jmp(B1_5);\n-\n-  bind(L_2TAG_PACKET_38_0_2);\n-\n-  bind(L_2TAG_PACKET_37_0_2);\n-  xorpd(xmm0, xmm0);\n-  movl(eax, 16368);\n-  pinsrw(xmm0, eax, 3);\n-  jmp(B1_5);\n-\n-  bind(L_2TAG_PACKET_39_0_2);\n-  xorpd(xmm0, xmm0);\n-  movl(eax, 16368);\n-  pinsrw(xmm0, eax, 3);\n-  movl(Address(rsp, 0), 26);\n-  jmp(L_2TAG_PACKET_17_0_2);\n-\n-  bind(L_2TAG_PACKET_9_0_2);\n-  movq(xmm1, Address(rsp, 16));\n-  movdqu(xmm2, xmm1);\n-  pextrw(eax, xmm1, 3);\n-  andl(eax, 32752);\n-  cmpl(eax, 32752);\n-  jcc(Assembler::notEqual, L_2TAG_PACKET_40_0_2);\n-  movdl(eax, xmm2);\n-  psrlq(xmm2, 20);\n-  movdl(edx, xmm2);\n-  orl(eax, edx);\n-  jcc(Assembler::notEqual, L_2TAG_PACKET_18_0_2);\n-\n-  bind(L_2TAG_PACKET_40_0_2);\n-  movdl(eax, xmm1);\n-  psrlq(xmm1, 32);\n-  movdl(edx, xmm1);\n-  movl(ecx, edx);\n-  addl(edx, edx);\n-  orl(eax, edx);\n-  jcc(Assembler::equal, L_2TAG_PACKET_39_0_2);\n-  shrl(edx, 21);\n-  cmpl(edx, 1075);\n-  jcc(Assembler::above, L_2TAG_PACKET_41_0_2);\n-  jcc(Assembler::equal, L_2TAG_PACKET_42_0_2);\n-  cmpl(edx, 1023);\n-  jcc(Assembler::below, L_2TAG_PACKET_41_0_2);\n-  movq(xmm1, Address(rsp, 16));\n-  movl(eax, 17208);\n-  xorpd(xmm3, xmm3);\n-  pinsrw(xmm3, eax, 3);\n-  movdqu(xmm4, xmm3);\n-  addsd(xmm3, xmm1);\n-  subsd(xmm4, xmm3);\n-  addsd(xmm1, xmm4);\n-  pextrw(eax, xmm1, 3);\n-  andl(eax, 32752);\n-  jcc(Assembler::notEqual, L_2TAG_PACKET_41_0_2);\n-  movdl(eax, xmm3);\n-  andl(eax, 1);\n-  jcc(Assembler::equal, L_2TAG_PACKET_41_0_2);\n-\n-  bind(L_2TAG_PACKET_43_0_2);\n-  movq(xmm0, Address(rsp, 8));\n-  testl(ecx, INT_MIN);\n-  jcc(Assembler::notEqual, L_2TAG_PACKET_44_0_2);\n-  jmp(B1_5);\n-\n-  bind(L_2TAG_PACKET_42_0_2);\n-  movq(xmm1, Address(rsp, 16));\n-  movdl(eax, xmm1);\n-  testl(eax, 1);\n-  jcc(Assembler::notEqual, L_2TAG_PACKET_43_0_2);\n-\n-  bind(L_2TAG_PACKET_41_0_2);\n-  testl(ecx, INT_MIN);\n-  jcc(Assembler::equal, L_2TAG_PACKET_22_0_2);\n-  xorpd(xmm0, xmm0);\n-\n-  bind(L_2TAG_PACKET_44_0_2);\n-  movl(eax, 16368);\n-  xorpd(xmm1, xmm1);\n-  pinsrw(xmm1, eax, 3);\n-  divsd(xmm1, xmm0);\n-  movdqu(xmm0, xmm1);\n-  movl(Address(rsp, 0), 27);\n-  jmp(L_2TAG_PACKET_17_0_2);\n-\n-  bind(L_2TAG_PACKET_12_0_2);\n-  movq(xmm2, Address(rsp, 8));\n-  movq(xmm6, Address(rsp, 16));\n-  pextrw(eax, xmm2, 3);\n-  pextrw(edx, xmm6, 3);\n-  movl(ecx, 32752);\n-  andl(ecx, edx);\n-  cmpl(ecx, 32752);\n-  jcc(Assembler::equal, L_2TAG_PACKET_45_0_2);\n-  andl(eax, 32752);\n-  subl(eax, 16368);\n-  xorl(edx, eax);\n-  testl(edx, 32768);\n-  jcc(Assembler::notEqual, L_2TAG_PACKET_46_0_2);\n-\n-  bind(L_2TAG_PACKET_47_0_2);\n-  movl(eax, 32736);\n-  pinsrw(xmm0, eax, 3);\n-  shrl(tmp1, 16);\n-  orl(eax, tmp1);\n-  pinsrw(xmm1, eax, 3);\n-  mulsd(xmm0, xmm1);\n-\n-  bind(L_2TAG_PACKET_14_0_2);\n-  movl(Address(rsp, 0), 24);\n-  jmp(L_2TAG_PACKET_17_0_2);\n-\n-  bind(L_2TAG_PACKET_46_0_2);\n-  movl(eax, 16);\n-  pinsrw(xmm0, eax, 3);\n-  mulsd(xmm0, xmm0);\n-  testl(tmp1, INT_MIN);\n-  jcc(Assembler::equal, L_2TAG_PACKET_48_0_2);\n-  mov64(tmp2, 0x8000000000000000);\n-  movdq(xmm2, tmp2);\n-  xorpd(xmm0, xmm2);\n-\n-  bind(L_2TAG_PACKET_48_0_2);\n-  movl(Address(rsp, 0), 25);\n-  jmp(L_2TAG_PACKET_17_0_2);\n-\n-  bind(L_2TAG_PACKET_13_0_2);\n-  pextrw(ecx, xmm5, 3);\n-  pextrw(edx, xmm4, 3);\n-  movl(eax, -1);\n-  andl(ecx, 32752);\n-  subl(ecx, 16368);\n-  andl(edx, 32752);\n-  addl(edx, ecx);\n-  movl(ecx, -31);\n-  sarl(edx, 4);\n-  subl(ecx, edx);\n-  jcc(Assembler::lessEqual, L_2TAG_PACKET_49_0_2);\n-  cmpl(ecx, 20);\n-  jcc(Assembler::above, L_2TAG_PACKET_50_0_2);\n-  shll(eax);\n-\n-  bind(L_2TAG_PACKET_49_0_2);\n-  movdl(xmm0, eax);\n-  psllq(xmm0, 32);\n-  pand(xmm0, xmm5);\n-  subsd(xmm5, xmm0);\n-  addsd(xmm5, xmm1);\n-  mulsd(xmm0, xmm4);\n-  mulsd(xmm5, xmm4);\n-  addsd(xmm0, xmm5);\n-\n-  bind(L_2TAG_PACKET_50_0_2);\n-  jmp(L_2TAG_PACKET_48_0_2);\n-\n-  bind(L_2TAG_PACKET_2_0_2);\n-  movw(ecx, Address(rsp, 22));\n-  movl(edx, INT_MIN);\n-  movdl(xmm1, rdx);\n-  xorpd(xmm7, xmm7);\n-  paddd(xmm0, xmm4);\n-  movdl(edx, xmm0);\n-  psllq(xmm0, 29);\n-  paddq(xmm1, xmm3);\n-  pand(xmm5, xmm1);\n-  andl(ecx, 32752);\n-  cmpl(ecx, 16560);\n-  jcc(Assembler::less, L_2TAG_PACKET_3_0_2);\n-  pand(xmm0, xmm6);\n-  subsd(xmm3, xmm5);\n-  addl(eax, 16351);\n-  shrl(eax, 4);\n-  subl(eax, 1022);\n-  cvtsi2sdl(xmm7, eax);\n-  mulpd(xmm5, xmm0);\n-  lea(r11, ExternalAddress(L_tbl));\n-  movq(xmm4, ExternalAddress(coeff_h), tmp2 \/*rscratch*\/);    \/\/0x00000000UL, 0xbfd61a00UL, 0x00000000UL, 0xbf5dabe1UL\n-  mulsd(xmm3, xmm0);\n-  movq(xmm6, ExternalAddress(coeff_h), tmp2 \/*rscratch*\/);    \/\/0x00000000UL, 0xbfd61a00UL, 0x00000000UL, 0xbf5dabe1UL\n-  subsd(xmm5, xmm2);\n-  movq(xmm1, ExternalAddress(coeff_h + 8), tmp2 \/*rscratch*\/);    \/\/0x00000000UL, 0xbf5dabe1UL\n-  pshufd(xmm2, xmm3, 68);\n-  unpcklpd(xmm5, xmm3);\n-  addsd(xmm3, xmm5);\n-  movq(xmm0, ExternalAddress(coeff_h + 8), tmp2 \/*rscratch*\/);    \/\/0x00000000UL, 0xbf5dabe1UL\n-  andl(edx, 16760832);\n-  shrl(edx, 10);\n-  addpd(xmm7, Address(tmp4, edx, Address::times_1, -3648));\n-  mulsd(xmm4, xmm5);\n-  mulsd(xmm0, xmm5);\n-  mulsd(xmm6, xmm2);\n-  mulsd(xmm1, xmm2);\n-  movdqu(xmm2, xmm5);\n-  mulsd(xmm4, xmm5);\n-  addsd(xmm5, xmm0);\n-  movdqu(xmm0, xmm7);\n-  addsd(xmm2, xmm3);\n-  addsd(xmm7, xmm5);\n-  mulsd(xmm6, xmm2);\n-  subsd(xmm0, xmm7);\n-  movdqu(xmm2, xmm7);\n-  addsd(xmm7, xmm4);\n-  addsd(xmm0, xmm5);\n-  subsd(xmm2, xmm7);\n-  addsd(xmm4, xmm2);\n-  pshufd(xmm2, xmm5, 238);\n-  movdqu(xmm5, xmm7);\n-  addsd(xmm7, xmm2);\n-  addsd(xmm4, xmm0);\n-  movdqu(xmm0, ExternalAddress(coeff), tmp2 \/*rscratch*\/);    \/\/0x6dc96112UL, 0xbf836578UL, 0xee241472UL, 0xbf9b0301UL\n-  subsd(xmm5, xmm7);\n-  addsd(xmm6, xmm4);\n-  movdqu(xmm4, xmm7);\n-  addsd(xmm5, xmm2);\n-  addsd(xmm7, xmm1);\n-  movdqu(xmm2, ExternalAddress(coeff + 64), tmp2 \/*rscratch*\/);    \/\/0x486ececcUL, 0x3fc4635eUL, 0x161bb241UL, 0xbf5dabe1UL\n-  subsd(xmm4, xmm7);\n-  addsd(xmm6, xmm5);\n-  addsd(xmm4, xmm1);\n-  pshufd(xmm5, xmm7, 238);\n-  movapd(xmm1, xmm7);\n-  addsd(xmm7, xmm5);\n-  subsd(xmm1, xmm7);\n-  addsd(xmm1, xmm5);\n-  movdqu(xmm5, ExternalAddress(coeff + 80), tmp2 \/*rscratch*\/);    \/\/0x9f95985aUL, 0xbfb528dbUL, 0xf8b5787dUL, 0x3ef2531eUL\n-  pshufd(xmm3, xmm3, 68);\n-  addsd(xmm6, xmm4);\n-  addsd(xmm6, xmm1);\n-  movdqu(xmm1, ExternalAddress(coeff + 32), tmp2 \/*rscratch*\/);    \/\/0x9f95985aUL, 0xbfb528dbUL, 0xb3841d2aUL, 0xbfd619b6UL\n-  mulpd(xmm0, xmm3);\n-  mulpd(xmm2, xmm3);\n-  pshufd(xmm4, xmm3, 68);\n-  mulpd(xmm3, xmm3);\n-  addpd(xmm0, xmm1);\n-  addpd(xmm5, xmm2);\n-  mulsd(xmm4, xmm3);\n-  movq(xmm2, ExternalAddress(HIGHMASK_LOG_X), tmp2 \/*rscratch*\/);    \/\/0xf8000000UL, 0xffffffffUL, 0x00000000UL, 0xfffff800UL\n-  mulpd(xmm3, xmm3);\n-  movq(xmm1, Address(rsp, 16));\n-  movw(ecx, Address(rsp, 22));\n-  mulpd(xmm0, xmm4);\n-  pextrw(eax, xmm7, 3);\n-  mulpd(xmm5, xmm4);\n-  mulpd(xmm0, xmm3);\n-  movq(xmm4, ExternalAddress(HIGHMASK_Y + 8), tmp2 \/*rscratch*\/);    \/\/0x00000000UL, 0xffffffffUL\n-  pand(xmm2, xmm7);\n-  addsd(xmm5, xmm6);\n-  subsd(xmm7, xmm2);\n-  addpd(xmm5, xmm0);\n-  andl(eax, 32752);\n-  subl(eax, 16368);\n-  andl(ecx, 32752);\n-  cmpl(ecx, 32752);\n-  jcc(Assembler::equal, L_2TAG_PACKET_45_0_2);\n-  addl(ecx, eax);\n-  cmpl(ecx, 16576);\n-  jcc(Assembler::aboveEqual, L_2TAG_PACKET_51_0_2);\n-  pshufd(xmm0, xmm5, 238);\n-  pand(xmm4, xmm1);\n-  movdqu(xmm3, xmm1);\n-  addsd(xmm5, xmm0);\n-  subsd(xmm1, xmm4);\n-  xorpd(xmm6, xmm6);\n-  movl(edx, 17080);\n-  pinsrw(xmm6, edx, 3);\n-  addsd(xmm7, xmm5);\n-  mulsd(xmm4, xmm2);\n-  mulsd(xmm1, xmm2);\n-  movdqu(xmm5, xmm6);\n-  mulsd(xmm3, xmm7);\n-  addsd(xmm6, xmm4);\n-  addsd(xmm1, xmm3);\n-  movdqu(xmm7, ExternalAddress(e_coeff), tmp2 \/*rscratch*\/);    \/\/0xe78a6731UL, 0x3f55d87fUL, 0xd704a0c0UL, 0x3fac6b08UL\n-  movdl(edx, xmm6);\n-  subsd(xmm6, xmm5);\n-  lea(tmp4, ExternalAddress(T_exp));\n-  movdqu(xmm3, ExternalAddress(e_coeff + 16), tmp2 \/*rscratch*\/);    \/\/0x6fba4e77UL, 0x3f83b2abUL, 0xff82c58fUL, 0x3fcebfbdUL\n-  movq(xmm2, ExternalAddress(e_coeff + 32), tmp2 \/*rscratch*\/);    \/\/0xfefa39efUL, 0x3fe62e42UL, 0x00000000UL, 0x00000000UL\n-  subsd(xmm4, xmm6);\n-  movl(ecx, edx);\n-  andl(edx, 255);\n-  addl(edx, edx);\n-  movdqu(xmm5, Address(tmp4, edx, Address::times_8, 0));\n-  addsd(xmm4, xmm1);\n-  pextrw(edx, xmm6, 3);\n-  shrl(ecx, 8);\n-  movl(eax, ecx);\n-  shrl(ecx, 1);\n-  subl(eax, ecx);\n-  shll(ecx, 20);\n-  movdl(xmm6, ecx);\n-  pshufd(xmm0, xmm4, 68);\n-  pshufd(xmm1, xmm4, 68);\n-  mulpd(xmm0, xmm0);\n-  mulpd(xmm7, xmm1);\n-  pshufd(xmm6, xmm6, 17);\n-  mulsd(xmm2, xmm4);\n-  andl(edx, 32767);\n-  cmpl(edx, 16529);\n-  jcc(Assembler::above, L_2TAG_PACKET_12_0_2);\n-  mulsd(xmm0, xmm0);\n-  paddd(xmm5, xmm6);\n-  addpd(xmm3, xmm7);\n-  mulsd(xmm2, xmm5);\n-  pshufd(xmm6, xmm5, 238);\n-  mulpd(xmm0, xmm3);\n-  addsd(xmm2, xmm6);\n-  pshufd(xmm3, xmm0, 238);\n-  addl(eax, 1023);\n-  shll(eax, 20);\n-  orl(eax, tmp1);\n-  movdl(xmm4, eax);\n-  mulsd(xmm0, xmm5);\n-  mulsd(xmm3, xmm5);\n-  addsd(xmm0, xmm2);\n-  psllq(xmm4, 32);\n-  addsd(xmm0, xmm3);\n-  movdqu(xmm1, xmm0);\n-  addsd(xmm0, xmm5);\n-  mulsd(xmm0, xmm4);\n-  pextrw(eax, xmm0, 3);\n-  andl(eax, 32752);\n-  jcc(Assembler::equal, L_2TAG_PACKET_13_0_2);\n-  cmpl(eax, 32752);\n-  jcc(Assembler::equal, L_2TAG_PACKET_14_0_2);\n-\n-  bind(L_2TAG_PACKET_52_0_2);\n-  jmp(B1_5);\n-\n-  bind(L_2TAG_PACKET_45_0_2);\n-  movq(xmm0, Address(rsp, 8));\n-  xorpd(xmm2, xmm2);\n-  movl(eax, 49136);\n-  pinsrw(xmm2, eax, 3);\n-  addsd(xmm2, xmm0);\n-  pextrw(eax, xmm2, 3);\n-  cmpl(eax, 0);\n-  jcc(Assembler::notEqual, L_2TAG_PACKET_53_0_2);\n-  xorpd(xmm0, xmm0);\n-  movl(eax, 32760);\n-  pinsrw(xmm0, eax, 3);\n-  jmp(B1_5);\n-\n-  bind(L_2TAG_PACKET_53_0_2);\n-  movq(xmm1, Address(rsp, 16));\n-  movdl(edx, xmm1);\n-  movdqu(xmm3, xmm1);\n-  psrlq(xmm3, 20);\n-  movdl(ecx, xmm3);\n-  orl(ecx, edx);\n-  jcc(Assembler::equal, L_2TAG_PACKET_54_0_2);\n-  addsd(xmm1, xmm1);\n-  movdqu(xmm0, xmm1);\n-  jmp(B1_5);\n-\n-  bind(L_2TAG_PACKET_51_0_2);\n-  pextrw(eax, xmm1, 3);\n-  pextrw(ecx, xmm2, 3);\n-  xorl(eax, ecx);\n-  testl(eax, 32768);\n-  jcc(Assembler::equal, L_2TAG_PACKET_47_0_2);\n-  jmp(L_2TAG_PACKET_46_0_2);\n-\n-  bind(L_2TAG_PACKET_54_0_2);\n-  pextrw(eax, xmm0, 3);\n-  andl(eax, 32752);\n-  pextrw(edx, xmm1, 3);\n-  xorpd(xmm0, xmm0);\n-  subl(eax, 16368);\n-  xorl(eax, edx);\n-  testl(eax, 32768);\n-  jcc(Assembler::equal, L_2TAG_PACKET_55_0_2);\n-  jmp(B1_5);\n-\n-  bind(L_2TAG_PACKET_55_0_2);\n-  movl(edx, 32752);\n-  pinsrw(xmm0, edx, 3);\n-  jmp(B1_5);\n-\n-  bind(L_2TAG_PACKET_17_0_2);\n-  movq(Address(rsp, 24), xmm0);\n-\n-  bind(B1_3);\n-  movq(xmm0, Address(rsp, 24));\n-\n-  bind(L_2TAG_PACKET_56_0_2);\n-\n-  bind(B1_5);\n-  addq(rsp, 40);\n-}\n-#else\n-\/\/ The 32 bit code is at most SSE2 compliant\n-ATTRIBUTE_ALIGNED(16) juint _static_const_table_pow[] =\n-{\n-    0x00000000UL, 0xbfd61a00UL, 0x00000000UL, 0xbf5dabe1UL, 0xf8000000UL,\n-    0xffffffffUL, 0x00000000UL, 0xfffff800UL, 0x00000000UL, 0x3ff00000UL,\n-    0x00000000UL, 0x00000000UL, 0x20000000UL, 0x3feff00aUL, 0x96621f95UL,\n-    0x3e5b1856UL, 0xe0000000UL, 0x3fefe019UL, 0xe5916f9eUL, 0xbe325278UL,\n-    0x00000000UL, 0x3fefd02fUL, 0x859a1062UL, 0x3e595fb7UL, 0xc0000000UL,\n-    0x3fefc049UL, 0xb245f18fUL, 0xbe529c38UL, 0xe0000000UL, 0x3fefb069UL,\n-    0xad2880a7UL, 0xbe501230UL, 0x60000000UL, 0x3fefa08fUL, 0xc8e72420UL,\n-    0x3e597bd1UL, 0x80000000UL, 0x3fef90baUL, 0xc30c4500UL, 0xbe5d6c75UL,\n-    0xe0000000UL, 0x3fef80eaUL, 0x02c63f43UL, 0x3e2e1318UL, 0xc0000000UL,\n-    0x3fef7120UL, 0xb3d4ccccUL, 0xbe44c52aUL, 0x00000000UL, 0x3fef615cUL,\n-    0xdbd91397UL, 0xbe4e7d6cUL, 0xa0000000UL, 0x3fef519cUL, 0x65c5cd68UL,\n-    0xbe522dc8UL, 0xa0000000UL, 0x3fef41e2UL, 0x46d1306cUL, 0xbe5a840eUL,\n-    0xe0000000UL, 0x3fef322dUL, 0xd2980e94UL, 0x3e5071afUL, 0xa0000000UL,\n-    0x3fef227eUL, 0x773abadeUL, 0xbe5891e5UL, 0xa0000000UL, 0x3fef12d4UL,\n-    0xdc6bf46bUL, 0xbe5cccbeUL, 0xe0000000UL, 0x3fef032fUL, 0xbc7247faUL,\n-    0xbe2bab83UL, 0x80000000UL, 0x3feef390UL, 0xbcaa1e46UL, 0xbe53bb3bUL,\n-    0x60000000UL, 0x3feee3f6UL, 0x5f6c682dUL, 0xbe54c619UL, 0x80000000UL,\n-    0x3feed461UL, 0x5141e368UL, 0xbe4b6d86UL, 0xe0000000UL, 0x3feec4d1UL,\n-    0xec678f76UL, 0xbe369af6UL, 0x80000000UL, 0x3feeb547UL, 0x41301f55UL,\n-    0xbe2d4312UL, 0x60000000UL, 0x3feea5c2UL, 0x676da6bdUL, 0xbe4d8dd0UL,\n-    0x60000000UL, 0x3fee9642UL, 0x57a891c4UL, 0x3e51f991UL, 0xa0000000UL,\n-    0x3fee86c7UL, 0xe4eb491eUL, 0x3e579bf9UL, 0x20000000UL, 0x3fee7752UL,\n-    0xfddc4a2cUL, 0xbe3356e6UL, 0xc0000000UL, 0x3fee67e1UL, 0xd75b5bf1UL,\n-    0xbe449531UL, 0x80000000UL, 0x3fee5876UL, 0xbd423b8eUL, 0x3df54fe4UL,\n-    0x60000000UL, 0x3fee4910UL, 0x330e51b9UL, 0x3e54289cUL, 0x80000000UL,\n-    0x3fee39afUL, 0x8651a95fUL, 0xbe55aad6UL, 0xa0000000UL, 0x3fee2a53UL,\n-    0x5e98c708UL, 0xbe2fc4a9UL, 0xe0000000UL, 0x3fee1afcUL, 0x0989328dUL,\n-    0x3e23958cUL, 0x40000000UL, 0x3fee0babUL, 0xee642abdUL, 0xbe425dd8UL,\n-    0xa0000000UL, 0x3fedfc5eUL, 0xc394d236UL, 0x3e526362UL, 0x20000000UL,\n-    0x3feded17UL, 0xe104aa8eUL, 0x3e4ce247UL, 0xc0000000UL, 0x3fedddd4UL,\n-    0x265a9be4UL, 0xbe5bb77aUL, 0x40000000UL, 0x3fedce97UL, 0x0ecac52fUL,\n-    0x3e4a7cb1UL, 0xe0000000UL, 0x3fedbf5eUL, 0x124cb3b8UL, 0x3e257024UL,\n-    0x80000000UL, 0x3fedb02bUL, 0xe6d4febeUL, 0xbe2033eeUL, 0x20000000UL,\n-    0x3feda0fdUL, 0x39cca00eUL, 0xbe3ddabcUL, 0xc0000000UL, 0x3fed91d3UL,\n-    0xef8a552aUL, 0xbe543390UL, 0x40000000UL, 0x3fed82afUL, 0xb8e85204UL,\n-    0x3e513850UL, 0xe0000000UL, 0x3fed738fUL, 0x3d59fe08UL, 0xbe5db728UL,\n-    0x40000000UL, 0x3fed6475UL, 0x3aa7ead1UL, 0x3e58804bUL, 0xc0000000UL,\n-    0x3fed555fUL, 0xf8a35ba9UL, 0xbe5298b0UL, 0x00000000UL, 0x3fed464fUL,\n-    0x9a88dd15UL, 0x3e5a8cdbUL, 0x40000000UL, 0x3fed3743UL, 0xb0b0a190UL,\n-    0x3e598635UL, 0x80000000UL, 0x3fed283cUL, 0xe2113295UL, 0xbe5c1119UL,\n-    0x80000000UL, 0x3fed193aUL, 0xafbf1728UL, 0xbe492e9cUL, 0x60000000UL,\n-    0x3fed0a3dUL, 0xe4a4ccf3UL, 0x3e19b90eUL, 0x20000000UL, 0x3fecfb45UL,\n-    0xba3cbeb8UL, 0x3e406b50UL, 0xc0000000UL, 0x3fecec51UL, 0x110f7dddUL,\n-    0x3e0d6806UL, 0x40000000UL, 0x3fecdd63UL, 0x7dd7d508UL, 0xbe5a8943UL,\n-    0x80000000UL, 0x3fecce79UL, 0x9b60f271UL, 0xbe50676aUL, 0x80000000UL,\n-    0x3fecbf94UL, 0x0b9ad660UL, 0x3e59174fUL, 0x60000000UL, 0x3fecb0b4UL,\n-    0x00823d9cUL, 0x3e5bbf72UL, 0x20000000UL, 0x3feca1d9UL, 0x38a6ec89UL,\n-    0xbe4d38f9UL, 0x80000000UL, 0x3fec9302UL, 0x3a0b7d8eUL, 0x3e53dbfdUL,\n-    0xc0000000UL, 0x3fec8430UL, 0xc6826b34UL, 0xbe27c5c9UL, 0xc0000000UL,\n-    0x3fec7563UL, 0x0c706381UL, 0xbe593653UL, 0x60000000UL, 0x3fec669bUL,\n-    0x7df34ec7UL, 0x3e461ab5UL, 0xe0000000UL, 0x3fec57d7UL, 0x40e5e7e8UL,\n-    0xbe5c3daeUL, 0x00000000UL, 0x3fec4919UL, 0x5602770fUL, 0xbe55219dUL,\n-    0xc0000000UL, 0x3fec3a5eUL, 0xec7911ebUL, 0x3e5a5d25UL, 0x60000000UL,\n-    0x3fec2ba9UL, 0xb39ea225UL, 0xbe53c00bUL, 0x80000000UL, 0x3fec1cf8UL,\n-    0x967a212eUL, 0x3e5a8ddfUL, 0x60000000UL, 0x3fec0e4cUL, 0x580798bdUL,\n-    0x3e5f53abUL, 0x00000000UL, 0x3febffa5UL, 0xb8282df6UL, 0xbe46b874UL,\n-    0x20000000UL, 0x3febf102UL, 0xe33a6729UL, 0x3e54963fUL, 0x00000000UL,\n-    0x3febe264UL, 0x3b53e88aUL, 0xbe3adce1UL, 0x60000000UL, 0x3febd3caUL,\n-    0xc2585084UL, 0x3e5cde9fUL, 0x80000000UL, 0x3febc535UL, 0xa335c5eeUL,\n-    0xbe39fd9cUL, 0x20000000UL, 0x3febb6a5UL, 0x7325b04dUL, 0x3e42ba15UL,\n-    0x60000000UL, 0x3feba819UL, 0x1564540fUL, 0x3e3a9f35UL, 0x40000000UL,\n-    0x3feb9992UL, 0x83fff592UL, 0xbe5465ceUL, 0xa0000000UL, 0x3feb8b0fUL,\n-    0xb9da63d3UL, 0xbe4b1a0aUL, 0x80000000UL, 0x3feb7c91UL, 0x6d6f1ea4UL,\n-    0x3e557657UL, 0x00000000UL, 0x3feb6e18UL, 0x5e80a1bfUL, 0x3e4ddbb6UL,\n-    0x00000000UL, 0x3feb5fa3UL, 0x1c9eacb5UL, 0x3e592877UL, 0xa0000000UL,\n-    0x3feb5132UL, 0x6d40beb3UL, 0xbe51858cUL, 0xa0000000UL, 0x3feb42c6UL,\n-    0xd740c67bUL, 0x3e427ad2UL, 0x40000000UL, 0x3feb345fUL, 0xa3e0cceeUL,\n-    0xbe5c2fc4UL, 0x40000000UL, 0x3feb25fcUL, 0x8e752b50UL, 0xbe3da3c2UL,\n-    0xc0000000UL, 0x3feb179dUL, 0xa892e7deUL, 0x3e1fb481UL, 0xc0000000UL,\n-    0x3feb0943UL, 0x21ed71e9UL, 0xbe365206UL, 0x20000000UL, 0x3feafaeeUL,\n-    0x0e1380a3UL, 0x3e5c5b7bUL, 0x20000000UL, 0x3feaec9dUL, 0x3c3d640eUL,\n-    0xbe5dbbd0UL, 0x60000000UL, 0x3feade50UL, 0x8f97a715UL, 0x3e3a8ec5UL,\n-    0x20000000UL, 0x3fead008UL, 0x23ab2839UL, 0x3e2fe98aUL, 0x40000000UL,\n-    0x3feac1c4UL, 0xf4bbd50fUL, 0x3e54d8f6UL, 0xe0000000UL, 0x3feab384UL,\n-    0x14757c4dUL, 0xbe48774cUL, 0xc0000000UL, 0x3feaa549UL, 0x7c7b0eeaUL,\n-    0x3e5b51bbUL, 0x20000000UL, 0x3fea9713UL, 0xf56f7013UL, 0x3e386200UL,\n-    0xe0000000UL, 0x3fea88e0UL, 0xbe428ebeUL, 0xbe514af5UL, 0xe0000000UL,\n-    0x3fea7ab2UL, 0x8d0e4496UL, 0x3e4f9165UL, 0x60000000UL, 0x3fea6c89UL,\n-    0xdbacc5d5UL, 0xbe5c063bUL, 0x20000000UL, 0x3fea5e64UL, 0x3f19d970UL,\n-    0xbe5a0c8cUL, 0x20000000UL, 0x3fea5043UL, 0x09ea3e6bUL, 0x3e5065dcUL,\n-    0x80000000UL, 0x3fea4226UL, 0x78df246cUL, 0x3e5e05f6UL, 0x40000000UL,\n-    0x3fea340eUL, 0x4057d4a0UL, 0x3e431b2bUL, 0x40000000UL, 0x3fea25faUL,\n-    0x82867bb5UL, 0x3e4b76beUL, 0xa0000000UL, 0x3fea17eaUL, 0x9436f40aUL,\n-    0xbe5aad39UL, 0x20000000UL, 0x3fea09dfUL, 0x4b5253b3UL, 0x3e46380bUL,\n-    0x00000000UL, 0x3fe9fbd8UL, 0x8fc52466UL, 0xbe386f9bUL, 0x20000000UL,\n-    0x3fe9edd5UL, 0x22d3f344UL, 0xbe538347UL, 0x60000000UL, 0x3fe9dfd6UL,\n-    0x1ac33522UL, 0x3e5dbc53UL, 0x00000000UL, 0x3fe9d1dcUL, 0xeabdff1dUL,\n-    0x3e40fc0cUL, 0xe0000000UL, 0x3fe9c3e5UL, 0xafd30e73UL, 0xbe585e63UL,\n-    0xe0000000UL, 0x3fe9b5f3UL, 0xa52f226aUL, 0xbe43e8f9UL, 0x20000000UL,\n-    0x3fe9a806UL, 0xecb8698dUL, 0xbe515b36UL, 0x80000000UL, 0x3fe99a1cUL,\n-    0xf2b4e89dUL, 0x3e48b62bUL, 0x20000000UL, 0x3fe98c37UL, 0x7c9a88fbUL,\n-    0x3e44414cUL, 0x00000000UL, 0x3fe97e56UL, 0xda015741UL, 0xbe5d13baUL,\n-    0xe0000000UL, 0x3fe97078UL, 0x5fdace06UL, 0x3e51b947UL, 0x00000000UL,\n-    0x3fe962a0UL, 0x956ca094UL, 0x3e518785UL, 0x40000000UL, 0x3fe954cbUL,\n-    0x01164c1dUL, 0x3e5d5b57UL, 0xc0000000UL, 0x3fe946faUL, 0xe63b3767UL,\n-    0xbe4f84e7UL, 0x40000000UL, 0x3fe9392eUL, 0xe57cc2a9UL, 0x3e34eda3UL,\n-    0xe0000000UL, 0x3fe92b65UL, 0x8c75b544UL, 0x3e5766a0UL, 0xc0000000UL,\n-    0x3fe91da1UL, 0x37d1d087UL, 0xbe5e2ab1UL, 0x80000000UL, 0x3fe90fe1UL,\n-    0xa953dc20UL, 0x3e5fa1f3UL, 0x80000000UL, 0x3fe90225UL, 0xdbd3f369UL,\n-    0x3e47d6dbUL, 0xa0000000UL, 0x3fe8f46dUL, 0x1c9be989UL, 0xbe5e2b0aUL,\n-    0xa0000000UL, 0x3fe8e6b9UL, 0x3c93d76aUL, 0x3e5c8618UL, 0xe0000000UL,\n-    0x3fe8d909UL, 0x2182fc9aUL, 0xbe41aa9eUL, 0x20000000UL, 0x3fe8cb5eUL,\n-    0xe6b3539dUL, 0xbe530d19UL, 0x60000000UL, 0x3fe8bdb6UL, 0x49e58cc3UL,\n-    0xbe3bb374UL, 0xa0000000UL, 0x3fe8b012UL, 0xa7cfeb8fUL, 0x3e56c412UL,\n-    0x00000000UL, 0x3fe8a273UL, 0x8d52bc19UL, 0x3e1429b8UL, 0x60000000UL,\n-    0x3fe894d7UL, 0x4dc32c6cUL, 0xbe48604cUL, 0xc0000000UL, 0x3fe8873fUL,\n-    0x0c868e56UL, 0xbe564ee5UL, 0x00000000UL, 0x3fe879acUL, 0x56aee828UL,\n-    0x3e5e2fd8UL, 0x60000000UL, 0x3fe86c1cUL, 0x7ceab8ecUL, 0x3e493365UL,\n-    0xc0000000UL, 0x3fe85e90UL, 0x78d4dadcUL, 0xbe4f7f25UL, 0x00000000UL,\n-    0x3fe85109UL, 0x0ccd8280UL, 0x3e31e7a2UL, 0x40000000UL, 0x3fe84385UL,\n-    0x34ba4e15UL, 0x3e328077UL, 0x80000000UL, 0x3fe83605UL, 0xa670975aUL,\n-    0xbe53eee5UL, 0xa0000000UL, 0x3fe82889UL, 0xf61b77b2UL, 0xbe43a20aUL,\n-    0xa0000000UL, 0x3fe81b11UL, 0x13e6643bUL, 0x3e5e5fe5UL, 0xc0000000UL,\n-    0x3fe80d9dUL, 0x82cc94e8UL, 0xbe5ff1f9UL, 0xa0000000UL, 0x3fe8002dUL,\n-    0x8a0c9c5dUL, 0xbe42b0e7UL, 0x60000000UL, 0x3fe7f2c1UL, 0x22a16f01UL,\n-    0x3e5d9ea0UL, 0x20000000UL, 0x3fe7e559UL, 0xc38cd451UL, 0x3e506963UL,\n-    0xc0000000UL, 0x3fe7d7f4UL, 0x9902bc71UL, 0x3e4503d7UL, 0x40000000UL,\n-    0x3fe7ca94UL, 0xdef2a3c0UL, 0x3e3d98edUL, 0xa0000000UL, 0x3fe7bd37UL,\n-    0xed49abb0UL, 0x3e24c1ffUL, 0xe0000000UL, 0x3fe7afdeUL, 0xe3b0be70UL,\n-    0xbe40c467UL, 0x00000000UL, 0x3fe7a28aUL, 0xaf9f193cUL, 0xbe5dff6cUL,\n-    0xe0000000UL, 0x3fe79538UL, 0xb74cf6b6UL, 0xbe258ed0UL, 0xa0000000UL,\n-    0x3fe787ebUL, 0x1d9127c7UL, 0x3e345fb0UL, 0x40000000UL, 0x3fe77aa2UL,\n-    0x1028c21dUL, 0xbe4619bdUL, 0xa0000000UL, 0x3fe76d5cUL, 0x7cb0b5e4UL,\n-    0x3e40f1a2UL, 0xe0000000UL, 0x3fe7601aUL, 0x2b1bc4adUL, 0xbe32e8bbUL,\n-    0xe0000000UL, 0x3fe752dcUL, 0x6839f64eUL, 0x3e41f57bUL, 0xc0000000UL,\n-    0x3fe745a2UL, 0xc4121f7eUL, 0xbe52c40aUL, 0x60000000UL, 0x3fe7386cUL,\n-    0xd6852d72UL, 0xbe5c4e6bUL, 0xc0000000UL, 0x3fe72b39UL, 0x91d690f7UL,\n-    0xbe57f88fUL, 0xe0000000UL, 0x3fe71e0aUL, 0x627a2159UL, 0xbe4425d5UL,\n-    0xc0000000UL, 0x3fe710dfUL, 0x50a54033UL, 0x3e422b7eUL, 0x60000000UL,\n-    0x3fe703b8UL, 0x3b0b5f91UL, 0x3e5d3857UL, 0xe0000000UL, 0x3fe6f694UL,\n-    0x84d628a2UL, 0xbe51f090UL, 0x00000000UL, 0x3fe6e975UL, 0x306d8894UL,\n-    0xbe414d83UL, 0xe0000000UL, 0x3fe6dc58UL, 0x30bf24aaUL, 0xbe4650caUL,\n-    0x80000000UL, 0x3fe6cf40UL, 0xd4628d69UL, 0xbe5db007UL, 0xc0000000UL,\n-    0x3fe6c22bUL, 0xa2aae57bUL, 0xbe31d279UL, 0xc0000000UL, 0x3fe6b51aUL,\n-    0x860edf7eUL, 0xbe2d4c4aUL, 0x80000000UL, 0x3fe6a80dUL, 0xf3559341UL,\n-    0xbe5f7e98UL, 0xe0000000UL, 0x3fe69b03UL, 0xa885899eUL, 0xbe5c2011UL,\n-    0xe0000000UL, 0x3fe68dfdUL, 0x2bdc6d37UL, 0x3e224a82UL, 0xa0000000UL,\n-    0x3fe680fbUL, 0xc12ad1b9UL, 0xbe40cf56UL, 0x00000000UL, 0x3fe673fdUL,\n-    0x1bcdf659UL, 0xbdf52f2dUL, 0x00000000UL, 0x3fe66702UL, 0x5df10408UL,\n-    0x3e5663e0UL, 0xc0000000UL, 0x3fe65a0aUL, 0xa4070568UL, 0xbe40b12fUL,\n-    0x00000000UL, 0x3fe64d17UL, 0x71c54c47UL, 0x3e5f5e8bUL, 0x00000000UL,\n-    0x3fe64027UL, 0xbd4b7e83UL, 0x3e42ead6UL, 0xa0000000UL, 0x3fe6333aUL,\n-    0x61598bd2UL, 0xbe4c48d4UL, 0xc0000000UL, 0x3fe62651UL, 0x6f538d61UL,\n-    0x3e548401UL, 0xa0000000UL, 0x3fe6196cUL, 0x14344120UL, 0xbe529af6UL,\n-    0x00000000UL, 0x3fe60c8bUL, 0x5982c587UL, 0xbe3e1e4fUL, 0x00000000UL,\n-    0x3fe5ffadUL, 0xfe51d4eaUL, 0xbe4c897aUL, 0x80000000UL, 0x3fe5f2d2UL,\n-    0xfd46ebe1UL, 0x3e552e00UL, 0xa0000000UL, 0x3fe5e5fbUL, 0xa4695699UL,\n-    0x3e5ed471UL, 0x60000000UL, 0x3fe5d928UL, 0x80d118aeUL, 0x3e456b61UL,\n-    0xa0000000UL, 0x3fe5cc58UL, 0x304c330bUL, 0x3e54dc29UL, 0x80000000UL,\n-    0x3fe5bf8cUL, 0x0af2dedfUL, 0xbe3aa9bdUL, 0xe0000000UL, 0x3fe5b2c3UL,\n-    0x15fc9258UL, 0xbe479a37UL, 0xc0000000UL, 0x3fe5a5feUL, 0x9292c7eaUL,\n-    0x3e188650UL, 0x20000000UL, 0x3fe5993dUL, 0x33b4d380UL, 0x3e5d6d93UL,\n-    0x20000000UL, 0x3fe58c7fUL, 0x02fd16c7UL, 0x3e2fe961UL, 0xa0000000UL,\n-    0x3fe57fc4UL, 0x4a05edb6UL, 0xbe4d55b4UL, 0xa0000000UL, 0x3fe5730dUL,\n-    0x3d443abbUL, 0xbe5e6954UL, 0x00000000UL, 0x3fe5665aUL, 0x024acfeaUL,\n-    0x3e50e61bUL, 0x00000000UL, 0x3fe559aaUL, 0xcc9edd09UL, 0xbe325403UL,\n-    0x60000000UL, 0x3fe54cfdUL, 0x1fe26950UL, 0x3e5d500eUL, 0x60000000UL,\n-    0x3fe54054UL, 0x6c5ae164UL, 0xbe4a79b4UL, 0xc0000000UL, 0x3fe533aeUL,\n-    0x154b0287UL, 0xbe401571UL, 0xa0000000UL, 0x3fe5270cUL, 0x0673f401UL,\n-    0xbe56e56bUL, 0xe0000000UL, 0x3fe51a6dUL, 0x751b639cUL, 0x3e235269UL,\n-    0xa0000000UL, 0x3fe50dd2UL, 0x7c7b2bedUL, 0x3ddec887UL, 0xc0000000UL,\n-    0x3fe5013aUL, 0xafab4e17UL, 0x3e5e7575UL, 0x60000000UL, 0x3fe4f4a6UL,\n-    0x2e308668UL, 0x3e59aed6UL, 0x80000000UL, 0x3fe4e815UL, 0xf33e2a76UL,\n-    0xbe51f184UL, 0xe0000000UL, 0x3fe4db87UL, 0x839f3e3eUL, 0x3e57db01UL,\n-    0xc0000000UL, 0x3fe4cefdUL, 0xa9eda7bbUL, 0x3e535e0fUL, 0x00000000UL,\n-    0x3fe4c277UL, 0x2a8f66a5UL, 0x3e5ce451UL, 0xc0000000UL, 0x3fe4b5f3UL,\n-    0x05192456UL, 0xbe4e8518UL, 0xc0000000UL, 0x3fe4a973UL, 0x4aa7cd1dUL,\n-    0x3e46784aUL, 0x40000000UL, 0x3fe49cf7UL, 0x8e23025eUL, 0xbe5749f2UL,\n-    0x00000000UL, 0x3fe4907eUL, 0x18d30215UL, 0x3e360f39UL, 0x20000000UL,\n-    0x3fe48408UL, 0x63dcf2f3UL, 0x3e5e00feUL, 0xc0000000UL, 0x3fe47795UL,\n-    0x46182d09UL, 0xbe5173d9UL, 0xa0000000UL, 0x3fe46b26UL, 0x8f0e62aaUL,\n-    0xbe48f281UL, 0xe0000000UL, 0x3fe45ebaUL, 0x5775c40cUL, 0xbe56aad4UL,\n-    0x60000000UL, 0x3fe45252UL, 0x0fe25f69UL, 0x3e48bd71UL, 0x40000000UL,\n-    0x3fe445edUL, 0xe9989ec5UL, 0x3e590d97UL, 0x80000000UL, 0x3fe4398bUL,\n-    0xb3d9ffe3UL, 0x3e479dbcUL, 0x20000000UL, 0x3fe42d2dUL, 0x388e4d2eUL,\n-    0xbe5eed80UL, 0xe0000000UL, 0x3fe420d1UL, 0x6f797c18UL, 0x3e554b4cUL,\n-    0x20000000UL, 0x3fe4147aUL, 0x31048bb4UL, 0xbe5b1112UL, 0x80000000UL,\n-    0x3fe40825UL, 0x2efba4f9UL, 0x3e48ebc7UL, 0x40000000UL, 0x3fe3fbd4UL,\n-    0x50201119UL, 0x3e40b701UL, 0x40000000UL, 0x3fe3ef86UL, 0x0a4db32cUL,\n-    0x3e551de8UL, 0xa0000000UL, 0x3fe3e33bUL, 0x0c9c148bUL, 0xbe50c1f6UL,\n-    0x20000000UL, 0x3fe3d6f4UL, 0xc9129447UL, 0x3e533fa0UL, 0x00000000UL,\n-    0x3fe3cab0UL, 0xaae5b5a0UL, 0xbe22b68eUL, 0x20000000UL, 0x3fe3be6fUL,\n-    0x02305e8aUL, 0xbe54fc08UL, 0x60000000UL, 0x3fe3b231UL, 0x7f908258UL,\n-    0x3e57dc05UL, 0x00000000UL, 0x3fe3a5f7UL, 0x1a09af78UL, 0x3e08038bUL,\n-    0xe0000000UL, 0x3fe399bfUL, 0x490643c1UL, 0xbe5dbe42UL, 0xe0000000UL,\n-    0x3fe38d8bUL, 0x5e8ad724UL, 0xbe3c2b72UL, 0x20000000UL, 0x3fe3815bUL,\n-    0xc67196b6UL, 0x3e1713cfUL, 0xa0000000UL, 0x3fe3752dUL, 0x6182e429UL,\n-    0xbe3ec14cUL, 0x40000000UL, 0x3fe36903UL, 0xab6eb1aeUL, 0x3e5a2cc5UL,\n-    0x40000000UL, 0x3fe35cdcUL, 0xfe5dc064UL, 0xbe5c5878UL, 0x40000000UL,\n-    0x3fe350b8UL, 0x0ba6b9e4UL, 0x3e51619bUL, 0x80000000UL, 0x3fe34497UL,\n-    0x857761aaUL, 0x3e5fff53UL, 0x00000000UL, 0x3fe3387aUL, 0xf872d68cUL,\n-    0x3e484f4dUL, 0xa0000000UL, 0x3fe32c5fUL, 0x087e97c2UL, 0x3e52842eUL,\n-    0x80000000UL, 0x3fe32048UL, 0x73d6d0c0UL, 0xbe503edfUL, 0x80000000UL,\n-    0x3fe31434UL, 0x0c1456a1UL, 0xbe5f72adUL, 0xa0000000UL, 0x3fe30823UL,\n-    0x83a1a4d5UL, 0xbe5e65ccUL, 0xe0000000UL, 0x3fe2fc15UL, 0x855a7390UL,\n-    0xbe506438UL, 0x40000000UL, 0x3fe2f00bUL, 0xa2898287UL, 0x3e3d22a2UL,\n-    0xe0000000UL, 0x3fe2e403UL, 0x8b56f66fUL, 0xbe5aa5fdUL, 0x80000000UL,\n-    0x3fe2d7ffUL, 0x52db119aUL, 0x3e3a2e3dUL, 0x60000000UL, 0x3fe2cbfeUL,\n-    0xe2ddd4c0UL, 0xbe586469UL, 0x40000000UL, 0x3fe2c000UL, 0x6b01bf10UL,\n-    0x3e352b9dUL, 0x40000000UL, 0x3fe2b405UL, 0xb07a1cdfUL, 0x3e5c5cdaUL,\n-    0x80000000UL, 0x3fe2a80dUL, 0xc7b5f868UL, 0xbe5668b3UL, 0xc0000000UL,\n-    0x3fe29c18UL, 0x185edf62UL, 0xbe563d66UL, 0x00000000UL, 0x3fe29027UL,\n-    0xf729e1ccUL, 0x3e59a9a0UL, 0x80000000UL, 0x3fe28438UL, 0x6433c727UL,\n-    0xbe43cc89UL, 0x00000000UL, 0x3fe2784dUL, 0x41782631UL, 0xbe30750cUL,\n-    0xa0000000UL, 0x3fe26c64UL, 0x914911b7UL, 0xbe58290eUL, 0x40000000UL,\n-    0x3fe2607fUL, 0x3dcc73e1UL, 0xbe4269cdUL, 0x00000000UL, 0x3fe2549dUL,\n-    0x2751bf70UL, 0xbe5a6998UL, 0xc0000000UL, 0x3fe248bdUL, 0x4248b9fbUL,\n-    0xbe4ddb00UL, 0x80000000UL, 0x3fe23ce1UL, 0xf35cf82fUL, 0x3e561b71UL,\n-    0x60000000UL, 0x3fe23108UL, 0x8e481a2dUL, 0x3e518fb9UL, 0x60000000UL,\n-    0x3fe22532UL, 0x5ab96edcUL, 0xbe5fafc5UL, 0x40000000UL, 0x3fe2195fUL,\n-    0x80943911UL, 0xbe07f819UL, 0x40000000UL, 0x3fe20d8fUL, 0x386f2d6cUL,\n-    0xbe54ba8bUL, 0x40000000UL, 0x3fe201c2UL, 0xf29664acUL, 0xbe5eb815UL,\n-    0x20000000UL, 0x3fe1f5f8UL, 0x64f03390UL, 0x3e5e320cUL, 0x20000000UL,\n-    0x3fe1ea31UL, 0x747ff696UL, 0x3e5ef0a5UL, 0x40000000UL, 0x3fe1de6dUL,\n-    0x3e9ceb51UL, 0xbe5f8d27UL, 0x20000000UL, 0x3fe1d2acUL, 0x4ae0b55eUL,\n-    0x3e5faa21UL, 0x20000000UL, 0x3fe1c6eeUL, 0x28569a5eUL, 0x3e598a4fUL,\n-    0x20000000UL, 0x3fe1bb33UL, 0x54b33e07UL, 0x3e46130aUL, 0x20000000UL,\n-    0x3fe1af7bUL, 0x024f1078UL, 0xbe4dbf93UL, 0x00000000UL, 0x3fe1a3c6UL,\n-    0xb0783bfaUL, 0x3e419248UL, 0xe0000000UL, 0x3fe19813UL, 0x2f02b836UL,\n-    0x3e4e02b7UL, 0xc0000000UL, 0x3fe18c64UL, 0x28dec9d4UL, 0x3e09064fUL,\n-    0x80000000UL, 0x3fe180b8UL, 0x45cbf406UL, 0x3e5b1f46UL, 0x40000000UL,\n-    0x3fe1750fUL, 0x03d9964cUL, 0x3e5b0a79UL, 0x00000000UL, 0x3fe16969UL,\n-    0x8b5b882bUL, 0xbe238086UL, 0xa0000000UL, 0x3fe15dc5UL, 0x73bad6f8UL,\n-    0xbdf1fca4UL, 0x20000000UL, 0x3fe15225UL, 0x5385769cUL, 0x3e5e8d76UL,\n-    0xa0000000UL, 0x3fe14687UL, 0x1676dc6bUL, 0x3e571d08UL, 0x20000000UL,\n-    0x3fe13aedUL, 0xa8c41c7fUL, 0xbe598a25UL, 0x60000000UL, 0x3fe12f55UL,\n-    0xc4e1aaf0UL, 0x3e435277UL, 0xa0000000UL, 0x3fe123c0UL, 0x403638e1UL,\n-    0xbe21aa7cUL, 0xc0000000UL, 0x3fe1182eUL, 0x557a092bUL, 0xbdd0116bUL,\n-    0xc0000000UL, 0x3fe10c9fUL, 0x7d779f66UL, 0x3e4a61baUL, 0xc0000000UL,\n-    0x3fe10113UL, 0x2b09c645UL, 0xbe5d586eUL, 0x20000000UL, 0x3fe0ea04UL,\n-    0xea2cad46UL, 0x3e5aa97cUL, 0x20000000UL, 0x3fe0d300UL, 0x23190e54UL,\n-    0x3e50f1a7UL, 0xa0000000UL, 0x3fe0bc07UL, 0x1379a5a6UL, 0xbe51619dUL,\n-    0x60000000UL, 0x3fe0a51aUL, 0x926a3d4aUL, 0x3e5cf019UL, 0xa0000000UL,\n-    0x3fe08e38UL, 0xa8c24358UL, 0x3e35241eUL, 0x20000000UL, 0x3fe07762UL,\n-    0x24317e7aUL, 0x3e512cfaUL, 0x00000000UL, 0x3fe06097UL, 0xfd9cf274UL,\n-    0xbe55bef3UL, 0x00000000UL, 0x3fe049d7UL, 0x3689b49dUL, 0xbe36d26dUL,\n-    0x40000000UL, 0x3fe03322UL, 0xf72ef6c4UL, 0xbe54cd08UL, 0xa0000000UL,\n-    0x3fe01c78UL, 0x23702d2dUL, 0xbe5900bfUL, 0x00000000UL, 0x3fe005daUL,\n-    0x3f59c14cUL, 0x3e57d80bUL, 0x40000000UL, 0x3fdfde8dUL, 0xad67766dUL,\n-    0xbe57fad4UL, 0x40000000UL, 0x3fdfb17cUL, 0x644f4ae7UL, 0x3e1ee43bUL,\n-    0x40000000UL, 0x3fdf8481UL, 0x903234d2UL, 0x3e501a86UL, 0x40000000UL,\n-    0x3fdf579cUL, 0xafe9e509UL, 0xbe267c3eUL, 0x00000000UL, 0x3fdf2acdUL,\n-    0xb7dfda0bUL, 0xbe48149bUL, 0x40000000UL, 0x3fdefe13UL, 0x3b94305eUL,\n-    0x3e5f4ea7UL, 0x80000000UL, 0x3fded16fUL, 0x5d95da61UL, 0xbe55c198UL,\n-    0x00000000UL, 0x3fdea4e1UL, 0x406960c9UL, 0xbdd99a19UL, 0x00000000UL,\n-    0x3fde7868UL, 0xd22f3539UL, 0x3e470c78UL, 0x80000000UL, 0x3fde4c04UL,\n-    0x83eec535UL, 0xbe3e1232UL, 0x40000000UL, 0x3fde1fb6UL, 0x3dfbffcbUL,\n-    0xbe4b7d71UL, 0x40000000UL, 0x3fddf37dUL, 0x7e1be4e0UL, 0xbe5b8f8fUL,\n-    0x40000000UL, 0x3fddc759UL, 0x46dae887UL, 0xbe350458UL, 0x80000000UL,\n-    0x3fdd9b4aUL, 0xed6ecc49UL, 0xbe5f0045UL, 0x80000000UL, 0x3fdd6f50UL,\n-    0x2e9e883cUL, 0x3e2915daUL, 0x80000000UL, 0x3fdd436bUL, 0xf0bccb32UL,\n-    0x3e4a68c9UL, 0x80000000UL, 0x3fdd179bUL, 0x9bbfc779UL, 0xbe54a26aUL,\n-    0x00000000UL, 0x3fdcebe0UL, 0x7cea33abUL, 0x3e43c6b7UL, 0x40000000UL,\n-    0x3fdcc039UL, 0xe740fd06UL, 0x3e5526c2UL, 0x40000000UL, 0x3fdc94a7UL,\n-    0x9eadeb1aUL, 0xbe396d8dUL, 0xc0000000UL, 0x3fdc6929UL, 0xf0a8f95aUL,\n-    0xbe5c0ab2UL, 0x80000000UL, 0x3fdc3dc0UL, 0x6ee2693bUL, 0x3e0992e6UL,\n-    0xc0000000UL, 0x3fdc126bUL, 0x5ac6b581UL, 0xbe2834b6UL, 0x40000000UL,\n-    0x3fdbe72bUL, 0x8cc226ffUL, 0x3e3596a6UL, 0x00000000UL, 0x3fdbbbffUL,\n-    0xf92a74bbUL, 0x3e3c5813UL, 0x00000000UL, 0x3fdb90e7UL, 0x479664c0UL,\n-    0xbe50d644UL, 0x00000000UL, 0x3fdb65e3UL, 0x5004975bUL, 0xbe55258fUL,\n-    0x00000000UL, 0x3fdb3af3UL, 0xe4b23194UL, 0xbe588407UL, 0xc0000000UL,\n-    0x3fdb1016UL, 0xe65d4d0aUL, 0x3e527c26UL, 0x80000000UL, 0x3fdae54eUL,\n-    0x814fddd6UL, 0x3e5962a2UL, 0x40000000UL, 0x3fdaba9aUL, 0xe19d0913UL,\n-    0xbe562f4eUL, 0x80000000UL, 0x3fda8ff9UL, 0x43cfd006UL, 0xbe4cfdebUL,\n-    0x40000000UL, 0x3fda656cUL, 0x686f0a4eUL, 0x3e5e47a8UL, 0xc0000000UL,\n-    0x3fda3af2UL, 0x7200d410UL, 0x3e5e1199UL, 0xc0000000UL, 0x3fda108cUL,\n-    0xabd2266eUL, 0x3e5ee4d1UL, 0x40000000UL, 0x3fd9e63aUL, 0x396f8f2cUL,\n-    0x3e4dbffbUL, 0x00000000UL, 0x3fd9bbfbUL, 0xe32b25ddUL, 0x3e5c3a54UL,\n-    0x40000000UL, 0x3fd991cfUL, 0x431e4035UL, 0xbe457925UL, 0x80000000UL,\n-    0x3fd967b6UL, 0x7bed3dd3UL, 0x3e40c61dUL, 0x00000000UL, 0x3fd93db1UL,\n-    0xd7449365UL, 0x3e306419UL, 0x80000000UL, 0x3fd913beUL, 0x1746e791UL,\n-    0x3e56fcfcUL, 0x40000000UL, 0x3fd8e9dfUL, 0xf3a9028bUL, 0xbe5041b9UL,\n-    0xc0000000UL, 0x3fd8c012UL, 0x56840c50UL, 0xbe26e20aUL, 0x40000000UL,\n-    0x3fd89659UL, 0x19763102UL, 0xbe51f466UL, 0x80000000UL, 0x3fd86cb2UL,\n-    0x7032de7cUL, 0xbe4d298aUL, 0x80000000UL, 0x3fd8431eUL, 0xdeb39fabUL,\n-    0xbe4361ebUL, 0x40000000UL, 0x3fd8199dUL, 0x5d01cbe0UL, 0xbe5425b3UL,\n-    0x80000000UL, 0x3fd7f02eUL, 0x3ce99aa9UL, 0x3e146fa8UL, 0x80000000UL,\n-    0x3fd7c6d2UL, 0xd1a262b9UL, 0xbe5a1a69UL, 0xc0000000UL, 0x3fd79d88UL,\n-    0x8606c236UL, 0x3e423a08UL, 0x80000000UL, 0x3fd77451UL, 0x8fd1e1b7UL,\n-    0x3e5a6a63UL, 0xc0000000UL, 0x3fd74b2cUL, 0xe491456aUL, 0x3e42c1caUL,\n-    0x40000000UL, 0x3fd7221aUL, 0x4499a6d7UL, 0x3e36a69aUL, 0x00000000UL,\n-    0x3fd6f91aUL, 0x5237df94UL, 0xbe0f8f02UL, 0x00000000UL, 0x3fd6d02cUL,\n-    0xb6482c6eUL, 0xbe5abcf7UL, 0x00000000UL, 0x3fd6a750UL, 0x1919fd61UL,\n-    0xbe57ade2UL, 0x00000000UL, 0x3fd67e86UL, 0xaa7a994dUL, 0xbe3f3fbdUL,\n-    0x00000000UL, 0x3fd655ceUL, 0x67db014cUL, 0x3e33c550UL, 0x00000000UL,\n-    0x3fd62d28UL, 0xa82856b7UL, 0xbe1409d1UL, 0xc0000000UL, 0x3fd60493UL,\n-    0x1e6a300dUL, 0x3e55d899UL, 0x80000000UL, 0x3fd5dc11UL, 0x1222bd5cUL,\n-    0xbe35bfc0UL, 0xc0000000UL, 0x3fd5b3a0UL, 0x6e8dc2d3UL, 0x3e5d4d79UL,\n-    0x00000000UL, 0x3fd58b42UL, 0xe0e4ace6UL, 0xbe517303UL, 0x80000000UL,\n-    0x3fd562f4UL, 0xb306e0a8UL, 0x3e5edf0fUL, 0xc0000000UL, 0x3fd53ab8UL,\n-    0x6574bc54UL, 0x3e5ee859UL, 0x80000000UL, 0x3fd5128eUL, 0xea902207UL,\n-    0x3e5f6188UL, 0xc0000000UL, 0x3fd4ea75UL, 0x9f911d79UL, 0x3e511735UL,\n-    0x80000000UL, 0x3fd4c26eUL, 0xf9c77397UL, 0xbe5b1643UL, 0x40000000UL,\n-    0x3fd49a78UL, 0x15fc9258UL, 0x3e479a37UL, 0x80000000UL, 0x3fd47293UL,\n-    0xd5a04dd9UL, 0xbe426e56UL, 0xc0000000UL, 0x3fd44abfUL, 0xe04042f5UL,\n-    0x3e56f7c6UL, 0x40000000UL, 0x3fd422fdUL, 0x1d8bf2c8UL, 0x3e5d8810UL,\n-    0x00000000UL, 0x3fd3fb4cUL, 0x88a8ddeeUL, 0xbe311454UL, 0xc0000000UL,\n-    0x3fd3d3abUL, 0x3e3b5e47UL, 0xbe5d1b72UL, 0x40000000UL, 0x3fd3ac1cUL,\n-    0xc2ab5d59UL, 0x3e31b02bUL, 0xc0000000UL, 0x3fd3849dUL, 0xd4e34b9eUL,\n-    0x3e51cb2fUL, 0x40000000UL, 0x3fd35d30UL, 0x177204fbUL, 0xbe2b8cd7UL,\n-    0x80000000UL, 0x3fd335d3UL, 0xfcd38c82UL, 0xbe4356e1UL, 0x80000000UL,\n-    0x3fd30e87UL, 0x64f54accUL, 0xbe4e6224UL, 0x00000000UL, 0x3fd2e74cUL,\n-    0xaa7975d9UL, 0x3e5dc0feUL, 0x80000000UL, 0x3fd2c021UL, 0x516dab3fUL,\n-    0xbe50ffa3UL, 0x40000000UL, 0x3fd29907UL, 0x2bfb7313UL, 0x3e5674a2UL,\n-    0xc0000000UL, 0x3fd271fdUL, 0x0549fc99UL, 0x3e385d29UL, 0xc0000000UL,\n-    0x3fd24b04UL, 0x55b63073UL, 0xbe500c6dUL, 0x00000000UL, 0x3fd2241cUL,\n-    0x3f91953aUL, 0x3e389977UL, 0xc0000000UL, 0x3fd1fd43UL, 0xa1543f71UL,\n-    0xbe3487abUL, 0xc0000000UL, 0x3fd1d67bUL, 0x4ec8867cUL, 0x3df6a2dcUL,\n-    0x00000000UL, 0x3fd1afc4UL, 0x4328e3bbUL, 0x3e41d9c0UL, 0x80000000UL,\n-    0x3fd1891cUL, 0x2e1cda84UL, 0x3e3bdd87UL, 0x40000000UL, 0x3fd16285UL,\n-    0x4b5331aeUL, 0xbe53128eUL, 0x00000000UL, 0x3fd13bfeUL, 0xb9aec164UL,\n-    0xbe52ac98UL, 0xc0000000UL, 0x3fd11586UL, 0xd91e1316UL, 0xbe350630UL,\n-    0x80000000UL, 0x3fd0ef1fUL, 0x7cacc12cUL, 0x3e3f5219UL, 0x40000000UL,\n-    0x3fd0c8c8UL, 0xbce277b7UL, 0x3e3d30c0UL, 0x00000000UL, 0x3fd0a281UL,\n-    0x2a63447dUL, 0xbe541377UL, 0x80000000UL, 0x3fd07c49UL, 0xfac483b5UL,\n-    0xbe5772ecUL, 0xc0000000UL, 0x3fd05621UL, 0x36b8a570UL, 0xbe4fd4bdUL,\n-    0xc0000000UL, 0x3fd03009UL, 0xbae505f7UL, 0xbe450388UL, 0x80000000UL,\n-    0x3fd00a01UL, 0x3e35aeadUL, 0xbe5430fcUL, 0x80000000UL, 0x3fcfc811UL,\n-    0x707475acUL, 0x3e38806eUL, 0x80000000UL, 0x3fcf7c3fUL, 0xc91817fcUL,\n-    0xbe40cceaUL, 0x80000000UL, 0x3fcf308cUL, 0xae05d5e9UL, 0xbe4919b8UL,\n-    0x80000000UL, 0x3fcee4f8UL, 0xae6cc9e6UL, 0xbe530b94UL, 0x00000000UL,\n-    0x3fce9983UL, 0x1efe3e8eUL, 0x3e57747eUL, 0x00000000UL, 0x3fce4e2dUL,\n-    0xda78d9bfUL, 0xbe59a608UL, 0x00000000UL, 0x3fce02f5UL, 0x8abe2c2eUL,\n-    0x3e4a35adUL, 0x00000000UL, 0x3fcdb7dcUL, 0x1495450dUL, 0xbe0872ccUL,\n-    0x80000000UL, 0x3fcd6ce1UL, 0x86ee0ba0UL, 0xbe4f59a0UL, 0x00000000UL,\n-    0x3fcd2205UL, 0xe81ca888UL, 0x3e5402c3UL, 0x00000000UL, 0x3fccd747UL,\n-    0x3b4424b9UL, 0x3e5dfdc3UL, 0x80000000UL, 0x3fcc8ca7UL, 0xd305b56cUL,\n-    0x3e202da6UL, 0x00000000UL, 0x3fcc4226UL, 0x399a6910UL, 0xbe482a1cUL,\n-    0x80000000UL, 0x3fcbf7c2UL, 0x747f7938UL, 0xbe587372UL, 0x80000000UL,\n-    0x3fcbad7cUL, 0x6fc246a0UL, 0x3e50d83dUL, 0x00000000UL, 0x3fcb6355UL,\n-    0xee9e9be5UL, 0xbe5c35bdUL, 0x80000000UL, 0x3fcb194aUL, 0x8416c0bcUL,\n-    0x3e546d4fUL, 0x00000000UL, 0x3fcacf5eUL, 0x49f7f08fUL, 0x3e56da76UL,\n-    0x00000000UL, 0x3fca858fUL, 0x5dc30de2UL, 0x3e5f390cUL, 0x00000000UL,\n-    0x3fca3bdeUL, 0x950583b6UL, 0xbe5e4169UL, 0x80000000UL, 0x3fc9f249UL,\n-    0x33631553UL, 0x3e52aeb1UL, 0x00000000UL, 0x3fc9a8d3UL, 0xde8795a6UL,\n-    0xbe59a504UL, 0x00000000UL, 0x3fc95f79UL, 0x076bf41eUL, 0x3e5122feUL,\n-    0x80000000UL, 0x3fc9163cUL, 0x2914c8e7UL, 0x3e3dd064UL, 0x00000000UL,\n-    0x3fc8cd1dUL, 0x3a30eca3UL, 0xbe21b4aaUL, 0x80000000UL, 0x3fc8841aUL,\n-    0xb2a96650UL, 0xbe575444UL, 0x80000000UL, 0x3fc83b34UL, 0x2376c0cbUL,\n-    0xbe2a74c7UL, 0x80000000UL, 0x3fc7f26bUL, 0xd8a0b653UL, 0xbe5181b6UL,\n-    0x00000000UL, 0x3fc7a9bfUL, 0x32257882UL, 0xbe4a78b4UL, 0x00000000UL,\n-    0x3fc7612fUL, 0x1eee8bd9UL, 0xbe1bfe9dUL, 0x80000000UL, 0x3fc718bbUL,\n-    0x0c603cc4UL, 0x3e36fdc9UL, 0x80000000UL, 0x3fc6d064UL, 0x3728b8cfUL,\n-    0xbe1e542eUL, 0x80000000UL, 0x3fc68829UL, 0xc79a4067UL, 0x3e5c380fUL,\n-    0x00000000UL, 0x3fc6400bUL, 0xf69eac69UL, 0x3e550a84UL, 0x80000000UL,\n-    0x3fc5f808UL, 0xb7a780a4UL, 0x3e5d9224UL, 0x80000000UL, 0x3fc5b022UL,\n-    0xad9dfb1eUL, 0xbe55242fUL, 0x00000000UL, 0x3fc56858UL, 0x659b18beUL,\n-    0xbe4bfda3UL, 0x80000000UL, 0x3fc520a9UL, 0x66ee3631UL, 0xbe57d769UL,\n-    0x80000000UL, 0x3fc4d916UL, 0x1ec62819UL, 0x3e2427f7UL, 0x80000000UL,\n-    0x3fc4919fUL, 0xdec25369UL, 0xbe435431UL, 0x00000000UL, 0x3fc44a44UL,\n-    0xa8acfc4bUL, 0xbe3c62e8UL, 0x00000000UL, 0x3fc40304UL, 0xcf1d3eabUL,\n-    0xbdfba29fUL, 0x80000000UL, 0x3fc3bbdfUL, 0x79aba3eaUL, 0xbdf1b7c8UL,\n-    0x80000000UL, 0x3fc374d6UL, 0xb8d186daUL, 0xbe5130cfUL, 0x80000000UL,\n-    0x3fc32de8UL, 0x9d74f152UL, 0x3e2285b6UL, 0x00000000UL, 0x3fc2e716UL,\n-    0x50ae7ca9UL, 0xbe503920UL, 0x80000000UL, 0x3fc2a05eUL, 0x6caed92eUL,\n-    0xbe533924UL, 0x00000000UL, 0x3fc259c2UL, 0x9cb5034eUL, 0xbe510e31UL,\n-    0x80000000UL, 0x3fc21340UL, 0x12c4d378UL, 0xbe540b43UL, 0x80000000UL,\n-    0x3fc1ccd9UL, 0xcc418706UL, 0x3e59887aUL, 0x00000000UL, 0x3fc1868eUL,\n-    0x921f4106UL, 0xbe528e67UL, 0x80000000UL, 0x3fc1405cUL, 0x3969441eUL,\n-    0x3e5d8051UL, 0x00000000UL, 0x3fc0fa46UL, 0xd941ef5bUL, 0x3e5f9079UL,\n-    0x80000000UL, 0x3fc0b44aUL, 0x5a3e81b2UL, 0xbe567691UL, 0x00000000UL,\n-    0x3fc06e69UL, 0x9d66afe7UL, 0xbe4d43fbUL, 0x00000000UL, 0x3fc028a2UL,\n-    0x0a92a162UL, 0xbe52f394UL, 0x00000000UL, 0x3fbfc5eaUL, 0x209897e5UL,\n-    0x3e529e37UL, 0x00000000UL, 0x3fbf3ac5UL, 0x8458bd7bUL, 0x3e582831UL,\n-    0x00000000UL, 0x3fbeafd5UL, 0xb8d8b4b8UL, 0xbe486b4aUL, 0x00000000UL,\n-    0x3fbe2518UL, 0xe0a3b7b6UL, 0x3e5bafd2UL, 0x00000000UL, 0x3fbd9a90UL,\n-    0x2bf2710eUL, 0x3e383b2bUL, 0x00000000UL, 0x3fbd103cUL, 0x73eb6ab7UL,\n-    0xbe56d78dUL, 0x00000000UL, 0x3fbc861bUL, 0x32ceaff5UL, 0xbe32dc5aUL,\n-    0x00000000UL, 0x3fbbfc2eUL, 0xbee04cb7UL, 0xbe4a71a4UL, 0x00000000UL,\n-    0x3fbb7274UL, 0x35ae9577UL, 0x3e38142fUL, 0x00000000UL, 0x3fbae8eeUL,\n-    0xcbaddab4UL, 0xbe5490f0UL, 0x00000000UL, 0x3fba5f9aUL, 0x95ce1114UL,\n-    0x3e597c71UL, 0x00000000UL, 0x3fb9d67aUL, 0x6d7c0f78UL, 0x3e3abc2dUL,\n-    0x00000000UL, 0x3fb94d8dUL, 0x2841a782UL, 0xbe566cbcUL, 0x00000000UL,\n-    0x3fb8c4d2UL, 0x6ed429c6UL, 0xbe3cfff9UL, 0x00000000UL, 0x3fb83c4aUL,\n-    0xe4a49fbbUL, 0xbe552964UL, 0x00000000UL, 0x3fb7b3f4UL, 0x2193d81eUL,\n-    0xbe42fa72UL, 0x00000000UL, 0x3fb72bd0UL, 0xdd70c122UL, 0x3e527a8cUL,\n-    0x00000000UL, 0x3fb6a3dfUL, 0x03108a54UL, 0xbe450393UL, 0x00000000UL,\n-    0x3fb61c1fUL, 0x30ff7954UL, 0x3e565840UL, 0x00000000UL, 0x3fb59492UL,\n-    0xdedd460cUL, 0xbe5422b5UL, 0x00000000UL, 0x3fb50d36UL, 0x950f9f45UL,\n-    0xbe5313f6UL, 0x00000000UL, 0x3fb4860bUL, 0x582cdcb1UL, 0x3e506d39UL,\n-    0x00000000UL, 0x3fb3ff12UL, 0x7216d3a6UL, 0x3e4aa719UL, 0x00000000UL,\n-    0x3fb3784aUL, 0x57a423fdUL, 0x3e5a9b9fUL, 0x00000000UL, 0x3fb2f1b4UL,\n-    0x7a138b41UL, 0xbe50b418UL, 0x00000000UL, 0x3fb26b4eUL, 0x2fbfd7eaUL,\n-    0x3e23a53eUL, 0x00000000UL, 0x3fb1e519UL, 0x18913ccbUL, 0x3e465fc1UL,\n-    0x00000000UL, 0x3fb15f15UL, 0x7ea24e21UL, 0x3e042843UL, 0x00000000UL,\n-    0x3fb0d941UL, 0x7c6d9c77UL, 0x3e59f61eUL, 0x00000000UL, 0x3fb0539eUL,\n-    0x114efd44UL, 0x3e4ccab7UL, 0x00000000UL, 0x3faf9c56UL, 0x1777f657UL,\n-    0x3e552f65UL, 0x00000000UL, 0x3fae91d2UL, 0xc317b86aUL, 0xbe5a61e0UL,\n-    0x00000000UL, 0x3fad87acUL, 0xb7664efbUL, 0xbe41f64eUL, 0x00000000UL,\n-    0x3fac7de6UL, 0x5d3d03a9UL, 0x3e0807a0UL, 0x00000000UL, 0x3fab7480UL,\n-    0x743c38ebUL, 0xbe3726e1UL, 0x00000000UL, 0x3faa6b78UL, 0x06a253f1UL,\n-    0x3e5ad636UL, 0x00000000UL, 0x3fa962d0UL, 0xa35f541bUL, 0x3e5a187aUL,\n-    0x00000000UL, 0x3fa85a88UL, 0x4b86e446UL, 0xbe508150UL, 0x00000000UL,\n-    0x3fa7529cUL, 0x2589cacfUL, 0x3e52938aUL, 0x00000000UL, 0x3fa64b10UL,\n-    0xaf6b11f2UL, 0xbe3454cdUL, 0x00000000UL, 0x3fa543e2UL, 0x97506fefUL,\n-    0xbe5fdec5UL, 0x00000000UL, 0x3fa43d10UL, 0xe75f7dd9UL, 0xbe388dd3UL,\n-    0x00000000UL, 0x3fa3369cUL, 0xa4139632UL, 0xbdea5177UL, 0x00000000UL,\n-    0x3fa23086UL, 0x352d6f1eUL, 0xbe565ad6UL, 0x00000000UL, 0x3fa12accUL,\n-    0x77449eb7UL, 0xbe50d5c7UL, 0x00000000UL, 0x3fa0256eUL, 0x7478da78UL,\n-    0x3e404724UL, 0x00000000UL, 0x3f9e40dcUL, 0xf59cef7fUL, 0xbe539d0aUL,\n-    0x00000000UL, 0x3f9c3790UL, 0x1511d43cUL, 0x3e53c2c8UL, 0x00000000UL,\n-    0x3f9a2f00UL, 0x9b8bff3cUL, 0xbe43b3e1UL, 0x00000000UL, 0x3f982724UL,\n-    0xad1e22a5UL, 0x3e46f0bdUL, 0x00000000UL, 0x3f962000UL, 0x130d9356UL,\n-    0x3e475ba0UL, 0x00000000UL, 0x3f941994UL, 0x8f86f883UL, 0xbe513d0bUL,\n-    0x00000000UL, 0x3f9213dcUL, 0x914d0dc8UL, 0xbe534335UL, 0x00000000UL,\n-    0x3f900ed8UL, 0x2d73e5e7UL, 0xbe22ba75UL, 0x00000000UL, 0x3f8c1510UL,\n-    0xc5b7d70eUL, 0x3e599c5dUL, 0x00000000UL, 0x3f880de0UL, 0x8a27857eUL,\n-    0xbe3d28c8UL, 0x00000000UL, 0x3f840810UL, 0xda767328UL, 0x3e531b3dUL,\n-    0x00000000UL, 0x3f8003b0UL, 0x77bacaf3UL, 0xbe5f04e3UL, 0x00000000UL,\n-    0x3f780150UL, 0xdf4b0720UL, 0x3e5a8bffUL, 0x00000000UL, 0x3f6ffc40UL,\n-    0x34c48e71UL, 0xbe3fcd99UL, 0x00000000UL, 0x3f5ff6c0UL, 0x1ad218afUL,\n-    0xbe4c78a7UL, 0x00000000UL, 0x00000000UL, 0x00000000UL, 0x80000000UL,\n-    0x00000000UL, 0xfffff800UL, 0x00000000UL, 0xfffff800UL, 0x00000000UL,\n-    0x3ff72000UL, 0x161bb241UL, 0xbf5dabe1UL, 0x6dc96112UL, 0xbf836578UL,\n-    0xee241472UL, 0xbf9b0301UL, 0x9f95985aUL, 0xbfb528dbUL, 0xb3841d2aUL,\n-    0xbfd619b6UL, 0x518775e3UL, 0x3f9004f2UL, 0xac8349bbUL, 0x3fa76c9bUL,\n-    0x486ececcUL, 0x3fc4635eUL, 0x161bb241UL, 0xbf5dabe1UL, 0x9f95985aUL,\n-    0xbfb528dbUL, 0xf8b5787dUL, 0x3ef2531eUL, 0x486ececbUL, 0x3fc4635eUL,\n-    0x412055ccUL, 0xbdd61bb2UL, 0x00000000UL, 0xfffffff8UL, 0x00000000UL,\n-    0xffffffffUL, 0x00000000UL, 0x3ff00000UL, 0x00000000UL, 0x3b700000UL,\n-    0xfa5abcbfUL, 0x3ff00b1aUL, 0xa7609f71UL, 0xbc84f6b2UL, 0xa9fb3335UL,\n-    0x3ff0163dUL, 0x9ab8cdb7UL, 0x3c9b6129UL, 0x143b0281UL, 0x3ff02168UL,\n-    0x0fc54eb6UL, 0xbc82bf31UL, 0x3e778061UL, 0x3ff02c9aUL, 0x535b085dUL,\n-    0xbc719083UL, 0x2e11bbccUL, 0x3ff037d4UL, 0xeeade11aUL, 0x3c656811UL,\n-    0xe86e7f85UL, 0x3ff04315UL, 0x1977c96eUL, 0xbc90a31cUL, 0x72f654b1UL,\n-    0x3ff04e5fUL, 0x3aa0d08cUL, 0x3c84c379UL, 0xd3158574UL, 0x3ff059b0UL,\n-    0xa475b465UL, 0x3c8d73e2UL, 0x0e3c1f89UL, 0x3ff0650aUL, 0x5799c397UL,\n-    0xbc95cb7bUL, 0x29ddf6deUL, 0x3ff0706bUL, 0xe2b13c27UL, 0xbc8c91dfUL,\n-    0x2b72a836UL, 0x3ff07bd4UL, 0x54458700UL, 0x3c832334UL, 0x18759bc8UL,\n-    0x3ff08745UL, 0x4bb284ffUL, 0x3c6186beUL, 0xf66607e0UL, 0x3ff092bdUL,\n-    0x800a3fd1UL, 0xbc968063UL, 0xcac6f383UL, 0x3ff09e3eUL, 0x18316136UL,\n-    0x3c914878UL, 0x9b1f3919UL, 0x3ff0a9c7UL, 0x873d1d38UL, 0x3c85d16cUL,\n-    0x6cf9890fUL, 0x3ff0b558UL, 0x4adc610bUL, 0x3c98a62eUL, 0x45e46c85UL,\n-    0x3ff0c0f1UL, 0x06d21cefUL, 0x3c94f989UL, 0x2b7247f7UL, 0x3ff0cc92UL,\n-    0x16e24f71UL, 0x3c901edcUL, 0x23395decUL, 0x3ff0d83bUL, 0xe43f316aUL,\n-    0xbc9bc14dUL, 0x32d3d1a2UL, 0x3ff0e3ecUL, 0x27c57b52UL, 0x3c403a17UL,\n-    0x5fdfa9c5UL, 0x3ff0efa5UL, 0xbc54021bUL, 0xbc949db9UL, 0xaffed31bUL,\n-    0x3ff0fb66UL, 0xc44ebd7bUL, 0xbc6b9bedUL, 0x28d7233eUL, 0x3ff10730UL,\n-    0x1692fdd5UL, 0x3c8d46ebUL, 0xd0125b51UL, 0x3ff11301UL, 0x39449b3aUL,\n-    0xbc96c510UL, 0xab5e2ab6UL, 0x3ff11edbUL, 0xf703fb72UL, 0xbc9ca454UL,\n-    0xc06c31ccUL, 0x3ff12abdUL, 0xb36ca5c7UL, 0xbc51b514UL, 0x14f204abUL,\n-    0x3ff136a8UL, 0xba48dcf0UL, 0xbc67108fUL, 0xaea92de0UL, 0x3ff1429aUL,\n-    0x9af1369eUL, 0xbc932fbfUL, 0x934f312eUL, 0x3ff14e95UL, 0x39bf44abUL,\n-    0xbc8b91e8UL, 0xc8a58e51UL, 0x3ff15a98UL, 0xb9eeab0aUL, 0x3c82406aUL,\n-    0x5471c3c2UL, 0x3ff166a4UL, 0x82ea1a32UL, 0x3c58f23bUL, 0x3c7d517bUL,\n-    0x3ff172b8UL, 0xb9d78a76UL, 0xbc819041UL, 0x8695bbc0UL, 0x3ff17ed4UL,\n-    0xe2ac5a64UL, 0x3c709e3fUL, 0x388c8deaUL, 0x3ff18af9UL, 0xd1970f6cUL,\n-    0xbc911023UL, 0x58375d2fUL, 0x3ff19726UL, 0x85f17e08UL, 0x3c94aaddUL,\n-    0xeb6fcb75UL, 0x3ff1a35bUL, 0x7b4968e4UL, 0x3c8e5b4cUL, 0xf8138a1cUL,\n-    0x3ff1af99UL, 0xa4b69280UL, 0x3c97bf85UL, 0x84045cd4UL, 0x3ff1bbe0UL,\n-    0x352ef607UL, 0xbc995386UL, 0x95281c6bUL, 0x3ff1c82fUL, 0x8010f8c9UL,\n-    0x3c900977UL, 0x3168b9aaUL, 0x3ff1d487UL, 0x00a2643cUL, 0x3c9e016eUL,\n-    0x5eb44027UL, 0x3ff1e0e7UL, 0x088cb6deUL, 0xbc96fdd8UL, 0x22fcd91dUL,\n-    0x3ff1ed50UL, 0x027bb78cUL, 0xbc91df98UL, 0x8438ce4dUL, 0x3ff1f9c1UL,\n-    0xa097af5cUL, 0xbc9bf524UL, 0x88628cd6UL, 0x3ff2063bUL, 0x814a8495UL,\n-    0x3c8dc775UL, 0x3578a819UL, 0x3ff212beUL, 0x2cfcaac9UL, 0x3c93592dUL,\n-    0x917ddc96UL, 0x3ff21f49UL, 0x9494a5eeUL, 0x3c82a97eUL, 0xa27912d1UL,\n-    0x3ff22bddUL, 0x5577d69fUL, 0x3c8d34fbUL, 0x6e756238UL, 0x3ff2387aUL,\n-    0xb6c70573UL, 0x3c99b07eUL, 0xfb82140aUL, 0x3ff2451fUL, 0x911ca996UL,\n-    0x3c8acfccUL, 0x4fb2a63fUL, 0x3ff251ceUL, 0xbef4f4a4UL, 0x3c8ac155UL,\n-    0x711ece75UL, 0x3ff25e85UL, 0x4ac31b2cUL, 0x3c93e1a2UL, 0x65e27cddUL,\n-    0x3ff26b45UL, 0x9940e9d9UL, 0x3c82bd33UL, 0x341ddf29UL, 0x3ff2780eUL,\n-    0x05f9e76cUL, 0x3c9e067cUL, 0xe1f56381UL, 0x3ff284dfUL, 0x8c3f0d7eUL,\n-    0xbc9a4c3aUL, 0x7591bb70UL, 0x3ff291baUL, 0x28401cbdUL, 0xbc82cc72UL,\n-    0xf51fdee1UL, 0x3ff29e9dUL, 0xafad1255UL, 0x3c8612e8UL, 0x66d10f13UL,\n-    0x3ff2ab8aUL, 0x191690a7UL, 0xbc995743UL, 0xd0dad990UL, 0x3ff2b87fUL,\n-    0xd6381aa4UL, 0xbc410adcUL, 0x39771b2fUL, 0x3ff2c57eUL, 0xa6eb5124UL,\n-    0xbc950145UL, 0xa6e4030bUL, 0x3ff2d285UL, 0x54db41d5UL, 0x3c900247UL,\n-    0x1f641589UL, 0x3ff2df96UL, 0xfbbce198UL, 0x3c9d16cfUL, 0xa93e2f56UL,\n-    0x3ff2ecafUL, 0x45d52383UL, 0x3c71ca0fUL, 0x4abd886bUL, 0x3ff2f9d2UL,\n-    0x532bda93UL, 0xbc653c55UL, 0x0a31b715UL, 0x3ff306feUL, 0xd23182e4UL,\n-    0x3c86f46aUL, 0xedeeb2fdUL, 0x3ff31432UL, 0xf3f3fcd1UL, 0x3c8959a3UL,\n-    0xfc4cd831UL, 0x3ff32170UL, 0x8e18047cUL, 0x3c8a9ce7UL, 0x3ba8ea32UL,\n-    0x3ff32eb8UL, 0x3cb4f318UL, 0xbc9c45e8UL, 0xb26416ffUL, 0x3ff33c08UL,\n-    0x843659a6UL, 0x3c932721UL, 0x66e3fa2dUL, 0x3ff34962UL, 0x930881a4UL,\n-    0xbc835a75UL, 0x5f929ff1UL, 0x3ff356c5UL, 0x5c4e4628UL, 0xbc8b5ceeUL,\n-    0xa2de883bUL, 0x3ff36431UL, 0xa06cb85eUL, 0xbc8c3144UL, 0x373aa9cbUL,\n-    0x3ff371a7UL, 0xbf42eae2UL, 0xbc963aeaUL, 0x231e754aUL, 0x3ff37f26UL,\n-    0x9eceb23cUL, 0xbc99f5caUL, 0x6d05d866UL, 0x3ff38caeUL, 0x3c9904bdUL,\n-    0xbc9e958dUL, 0x1b7140efUL, 0x3ff39a40UL, 0xfc8e2934UL, 0xbc99a9a5UL,\n-    0x34e59ff7UL, 0x3ff3a7dbUL, 0xd661f5e3UL, 0xbc75e436UL, 0xbfec6cf4UL,\n-    0x3ff3b57fUL, 0xe26fff18UL, 0x3c954c66UL, 0xc313a8e5UL, 0x3ff3c32dUL,\n-    0x375d29c3UL, 0xbc9efff8UL, 0x44ede173UL, 0x3ff3d0e5UL, 0x8c284c71UL,\n-    0x3c7fe8d0UL, 0x4c123422UL, 0x3ff3dea6UL, 0x11f09ebcUL, 0x3c8ada09UL,\n-    0xdf1c5175UL, 0x3ff3ec70UL, 0x7b8c9bcaUL, 0xbc8af663UL, 0x04ac801cUL,\n-    0x3ff3fa45UL, 0xf956f9f3UL, 0xbc97d023UL, 0xc367a024UL, 0x3ff40822UL,\n-    0xb6f4d048UL, 0x3c8bddf8UL, 0x21f72e2aUL, 0x3ff4160aUL, 0x1c309278UL,\n-    0xbc5ef369UL, 0x2709468aUL, 0x3ff423fbUL, 0xc0b314ddUL, 0xbc98462dUL,\n-    0xd950a897UL, 0x3ff431f5UL, 0xe35f7999UL, 0xbc81c7ddUL, 0x3f84b9d4UL,\n-    0x3ff43ffaUL, 0x9704c003UL, 0x3c8880beUL, 0x6061892dUL, 0x3ff44e08UL,\n-    0x04ef80d0UL, 0x3c489b7aUL, 0x42a7d232UL, 0x3ff45c20UL, 0x82fb1f8eUL,\n-    0xbc686419UL, 0xed1d0057UL, 0x3ff46a41UL, 0xd1648a76UL, 0x3c9c944bUL,\n-    0x668b3237UL, 0x3ff4786dUL, 0xed445733UL, 0xbc9c20f0UL, 0xb5c13cd0UL,\n-    0x3ff486a2UL, 0xb69062f0UL, 0x3c73c1a3UL, 0xe192aed2UL, 0x3ff494e1UL,\n-    0x5e499ea0UL, 0xbc83b289UL, 0xf0d7d3deUL, 0x3ff4a32aUL, 0xf3d1be56UL,\n-    0x3c99cb62UL, 0xea6db7d7UL, 0x3ff4b17dUL, 0x7f2897f0UL, 0xbc8125b8UL,\n-    0xd5362a27UL, 0x3ff4bfdaUL, 0xafec42e2UL, 0x3c7d4397UL, 0xb817c114UL,\n-    0x3ff4ce41UL, 0x690abd5dUL, 0x3c905e29UL, 0x99fddd0dUL, 0x3ff4dcb2UL,\n-    0xbc6a7833UL, 0x3c98ecdbUL, 0x81d8abffUL, 0x3ff4eb2dUL, 0x2e5d7a52UL,\n-    0xbc95257dUL, 0x769d2ca7UL, 0x3ff4f9b2UL, 0xd25957e3UL, 0xbc94b309UL,\n-    0x7f4531eeUL, 0x3ff50841UL, 0x49b7465fUL, 0x3c7a249bUL, 0xa2cf6642UL,\n-    0x3ff516daUL, 0x69bd93efUL, 0xbc8f7685UL, 0xe83f4eefUL, 0x3ff5257dUL,\n-    0x43efef71UL, 0xbc7c998dUL, 0x569d4f82UL, 0x3ff5342bUL, 0x1db13cadUL,\n-    0xbc807abeUL, 0xf4f6ad27UL, 0x3ff542e2UL, 0x192d5f7eUL, 0x3c87926dUL,\n-    0xca5d920fUL, 0x3ff551a4UL, 0xefede59bUL, 0xbc8d689cUL, 0xdde910d2UL,\n-    0x3ff56070UL, 0x168eebf0UL, 0xbc90fb6eUL, 0x36b527daUL, 0x3ff56f47UL,\n-    0x011d93adUL, 0x3c99bb2cUL, 0xdbe2c4cfUL, 0x3ff57e27UL, 0x8a57b9c4UL,\n-    0xbc90b98cUL, 0xd497c7fdUL, 0x3ff58d12UL, 0x5b9a1de8UL, 0x3c8295e1UL,\n-    0x27ff07ccUL, 0x3ff59c08UL, 0xe467e60fUL, 0xbc97e2ceUL, 0xdd485429UL,\n-    0x3ff5ab07UL, 0x054647adUL, 0x3c96324cUL, 0xfba87a03UL, 0x3ff5ba11UL,\n-    0x4c233e1aUL, 0xbc9b77a1UL, 0x8a5946b7UL, 0x3ff5c926UL, 0x816986a2UL,\n-    0x3c3c4b1bUL, 0x90998b93UL, 0x3ff5d845UL, 0xa8b45643UL, 0xbc9cd6a7UL,\n-    0x15ad2148UL, 0x3ff5e76fUL, 0x3080e65eUL, 0x3c9ba6f9UL, 0x20dceb71UL,\n-    0x3ff5f6a3UL, 0xe3cdcf92UL, 0xbc89eaddUL, 0xb976dc09UL, 0x3ff605e1UL,\n-    0x9b56de47UL, 0xbc93e242UL, 0xe6cdf6f4UL, 0x3ff6152aUL, 0x4ab84c27UL,\n-    0x3c9e4b3eUL, 0xb03a5585UL, 0x3ff6247eUL, 0x7e40b497UL, 0xbc9383c1UL,\n-    0x1d1929fdUL, 0x3ff633ddUL, 0xbeb964e5UL, 0x3c984710UL, 0x34ccc320UL,\n-    0x3ff64346UL, 0x759d8933UL, 0xbc8c483cUL, 0xfebc8fb7UL, 0x3ff652b9UL,\n-    0xc9a73e09UL, 0xbc9ae3d5UL, 0x82552225UL, 0x3ff66238UL, 0x87591c34UL,\n-    0xbc9bb609UL, 0xc70833f6UL, 0x3ff671c1UL, 0x586c6134UL, 0xbc8e8732UL,\n-    0xd44ca973UL, 0x3ff68155UL, 0x44f73e65UL, 0x3c6038aeUL, 0xb19e9538UL,\n-    0x3ff690f4UL, 0x9aeb445dUL, 0x3c8804bdUL, 0x667f3bcdUL, 0x3ff6a09eUL,\n-    0x13b26456UL, 0xbc9bdd34UL, 0xfa75173eUL, 0x3ff6b052UL, 0x2c9a9d0eUL,\n-    0x3c7a38f5UL, 0x750bdabfUL, 0x3ff6c012UL, 0x67ff0b0dUL, 0xbc728956UL,\n-    0xddd47645UL, 0x3ff6cfdcUL, 0xb6f17309UL, 0x3c9c7aa9UL, 0x3c651a2fUL,\n-    0x3ff6dfb2UL, 0x683c88abUL, 0xbc6bbe3aUL, 0x98593ae5UL, 0x3ff6ef92UL,\n-    0x9e1ac8b2UL, 0xbc90b974UL, 0xf9519484UL, 0x3ff6ff7dUL, 0x25860ef6UL,\n-    0xbc883c0fUL, 0x66f42e87UL, 0x3ff70f74UL, 0xd45aa65fUL, 0x3c59d644UL,\n-    0xe8ec5f74UL, 0x3ff71f75UL, 0x86887a99UL, 0xbc816e47UL, 0x86ead08aUL,\n-    0x3ff72f82UL, 0x2cd62c72UL, 0xbc920aa0UL, 0x48a58174UL, 0x3ff73f9aUL,\n-    0x6c65d53cUL, 0xbc90a8d9UL, 0x35d7cbfdUL, 0x3ff74fbdUL, 0x618a6e1cUL,\n-    0x3c9047fdUL, 0x564267c9UL, 0x3ff75febUL, 0x57316dd3UL, 0xbc902459UL,\n-    0xb1ab6e09UL, 0x3ff77024UL, 0x169147f8UL, 0x3c9b7877UL, 0x4fde5d3fUL,\n-    0x3ff78069UL, 0x0a02162dUL, 0x3c9866b8UL, 0x38ac1cf6UL, 0x3ff790b9UL,\n-    0x62aadd3eUL, 0x3c9349a8UL, 0x73eb0187UL, 0x3ff7a114UL, 0xee04992fUL,\n-    0xbc841577UL, 0x0976cfdbUL, 0x3ff7b17bUL, 0x8468dc88UL, 0xbc9bebb5UL,\n-    0x0130c132UL, 0x3ff7c1edUL, 0xd1164dd6UL, 0x3c9f124cUL, 0x62ff86f0UL,\n-    0x3ff7d26aUL, 0xfb72b8b4UL, 0x3c91bddbUL, 0x36cf4e62UL, 0x3ff7e2f3UL,\n-    0xba15797eUL, 0x3c705d02UL, 0x8491c491UL, 0x3ff7f387UL, 0xcf9311aeUL,\n-    0xbc807f11UL, 0x543e1a12UL, 0x3ff80427UL, 0x626d972bUL, 0xbc927c86UL,\n-    0xadd106d9UL, 0x3ff814d2UL, 0x0d151d4dUL, 0x3c946437UL, 0x994cce13UL,\n-    0x3ff82589UL, 0xd41532d8UL, 0xbc9d4c1dUL, 0x1eb941f7UL, 0x3ff8364cUL,\n-    0x31df2bd5UL, 0x3c999b9aUL, 0x4623c7adUL, 0x3ff8471aUL, 0xa341cdfbUL,\n-    0xbc88d684UL, 0x179f5b21UL, 0x3ff857f4UL, 0xf8b216d0UL, 0xbc5ba748UL,\n-    0x9b4492edUL, 0x3ff868d9UL, 0x9bd4f6baUL, 0xbc9fc6f8UL, 0xd931a436UL,\n-    0x3ff879caUL, 0xd2db47bdUL, 0x3c85d2d7UL, 0xd98a6699UL, 0x3ff88ac7UL,\n-    0xf37cb53aUL, 0x3c9994c2UL, 0xa478580fUL, 0x3ff89bd0UL, 0x4475202aUL,\n-    0x3c9d5395UL, 0x422aa0dbUL, 0x3ff8ace5UL, 0x56864b27UL, 0x3c96e9f1UL,\n-    0xbad61778UL, 0x3ff8be05UL, 0xfc43446eUL, 0x3c9ecb5eUL, 0x16b5448cUL,\n-    0x3ff8cf32UL, 0x32e9e3aaUL, 0xbc70d55eUL, 0x5e0866d9UL, 0x3ff8e06aUL,\n-    0x6fc9b2e6UL, 0xbc97114aUL, 0x99157736UL, 0x3ff8f1aeUL, 0xa2e3976cUL,\n-    0x3c85cc13UL, 0xd0282c8aUL, 0x3ff902feUL, 0x85fe3fd2UL, 0x3c9592caUL,\n-    0x0b91ffc6UL, 0x3ff9145bUL, 0x2e582524UL, 0xbc9dd679UL, 0x53aa2fe2UL,\n-    0x3ff925c3UL, 0xa639db7fUL, 0xbc83455fUL, 0xb0cdc5e5UL, 0x3ff93737UL,\n-    0x81b57ebcUL, 0xbc675fc7UL, 0x2b5f98e5UL, 0x3ff948b8UL, 0x797d2d99UL,\n-    0xbc8dc3d6UL, 0xcbc8520fUL, 0x3ff95a44UL, 0x96a5f039UL, 0xbc764b7cUL,\n-    0x9a7670b3UL, 0x3ff96bddUL, 0x7f19c896UL, 0xbc5ba596UL, 0x9fde4e50UL,\n-    0x3ff97d82UL, 0x7c1b85d1UL, 0xbc9d185bUL, 0xe47a22a2UL, 0x3ff98f33UL,\n-    0xa24c78ecUL, 0x3c7cabdaUL, 0x70ca07baUL, 0x3ff9a0f1UL, 0x91cee632UL,\n-    0xbc9173bdUL, 0x4d53fe0dUL, 0x3ff9b2bbUL, 0x4df6d518UL, 0xbc9dd84eUL,\n-    0x82a3f090UL, 0x3ff9c491UL, 0xb071f2beUL, 0x3c7c7c46UL, 0x194bb8d5UL,\n-    0x3ff9d674UL, 0xa3dd8233UL, 0xbc9516beUL, 0x19e32323UL, 0x3ff9e863UL,\n-    0x78e64c6eUL, 0x3c7824caUL, 0x8d07f29eUL, 0x3ff9fa5eUL, 0xaaf1faceUL,\n-    0xbc84a9ceUL, 0x7b5de565UL, 0x3ffa0c66UL, 0x5d1cd533UL, 0xbc935949UL,\n-    0xed8eb8bbUL, 0x3ffa1e7aUL, 0xee8be70eUL, 0x3c9c6618UL, 0xec4a2d33UL,\n-    0x3ffa309bUL, 0x7ddc36abUL, 0x3c96305cUL, 0x80460ad8UL, 0x3ffa42c9UL,\n-    0x589fb120UL, 0xbc9aa780UL, 0xb23e255dUL, 0x3ffa5503UL, 0xdb8d41e1UL,\n-    0xbc9d2f6eUL, 0x8af46052UL, 0x3ffa674aUL, 0x30670366UL, 0x3c650f56UL,\n-    0x1330b358UL, 0x3ffa799eUL, 0xcac563c7UL, 0x3c9bcb7eUL, 0x53c12e59UL,\n-    0x3ffa8bfeUL, 0xb2ba15a9UL, 0xbc94f867UL, 0x5579fdbfUL, 0x3ffa9e6bUL,\n-    0x0ef7fd31UL, 0x3c90fac9UL, 0x21356ebaUL, 0x3ffab0e5UL, 0xdae94545UL,\n-    0x3c889c31UL, 0xbfd3f37aUL, 0x3ffac36bUL, 0xcae76cd0UL, 0xbc8f9234UL,\n-    0x3a3c2774UL, 0x3ffad5ffUL, 0xb6b1b8e5UL, 0x3c97ef3bUL, 0x995ad3adUL,\n-    0x3ffae89fUL, 0x345dcc81UL, 0x3c97a1cdUL, 0xe622f2ffUL, 0x3ffafb4cUL,\n-    0x0f315ecdUL, 0xbc94b2fcUL, 0x298db666UL, 0x3ffb0e07UL, 0x4c80e425UL,\n-    0xbc9bdef5UL, 0x6c9a8952UL, 0x3ffb20ceUL, 0x4a0756ccUL, 0x3c94dd02UL,\n-    0xb84f15fbUL, 0x3ffb33a2UL, 0x3084d708UL, 0xbc62805eUL, 0x15b749b1UL,\n-    0x3ffb4684UL, 0xe9df7c90UL, 0xbc7f763dUL, 0x8de5593aUL, 0x3ffb5972UL,\n-    0xbbba6de3UL, 0xbc9c71dfUL, 0x29f1c52aUL, 0x3ffb6c6eUL, 0x52883f6eUL,\n-    0x3c92a8f3UL, 0xf2fb5e47UL, 0x3ffb7f76UL, 0x7e54ac3bUL, 0xbc75584fUL,\n-    0xf22749e4UL, 0x3ffb928cUL, 0x54cb65c6UL, 0xbc9b7216UL, 0x30a1064aUL,\n-    0x3ffba5b0UL, 0x0e54292eUL, 0xbc9efcd3UL, 0xb79a6f1fUL, 0x3ffbb8e0UL,\n-    0xc9696205UL, 0xbc3f52d1UL, 0x904bc1d2UL, 0x3ffbcc1eUL, 0x7a2d9e84UL,\n-    0x3c823dd0UL, 0xc3f3a207UL, 0x3ffbdf69UL, 0x60ea5b53UL, 0xbc3c2623UL,\n-    0x5bd71e09UL, 0x3ffbf2c2UL, 0x3f6b9c73UL, 0xbc9efdcaUL, 0x6141b33dUL,\n-    0x3ffc0628UL, 0xa1fbca34UL, 0xbc8d8a5aUL, 0xdd85529cUL, 0x3ffc199bUL,\n-    0x895048ddUL, 0x3c811065UL, 0xd9fa652cUL, 0x3ffc2d1cUL, 0x17c8a5d7UL,\n-    0xbc96e516UL, 0x5fffd07aUL, 0x3ffc40abUL, 0xe083c60aUL, 0x3c9b4537UL,\n-    0x78fafb22UL, 0x3ffc5447UL, 0x2493b5afUL, 0x3c912f07UL, 0x2e57d14bUL,\n-    0x3ffc67f1UL, 0xff483cadUL, 0x3c92884dUL, 0x8988c933UL, 0x3ffc7ba8UL,\n-    0xbe255559UL, 0xbc8e76bbUL, 0x9406e7b5UL, 0x3ffc8f6dUL, 0x48805c44UL,\n-    0x3c71acbcUL, 0x5751c4dbUL, 0x3ffca340UL, 0xd10d08f5UL, 0xbc87f2beUL,\n-    0xdcef9069UL, 0x3ffcb720UL, 0xd1e949dbUL, 0x3c7503cbUL, 0x2e6d1675UL,\n-    0x3ffccb0fUL, 0x86009092UL, 0xbc7d220fUL, 0x555dc3faUL, 0x3ffcdf0bUL,\n-    0x53829d72UL, 0xbc8dd83bUL, 0x5b5bab74UL, 0x3ffcf315UL, 0xb86dff57UL,\n-    0xbc9a08e9UL, 0x4a07897cUL, 0x3ffd072dUL, 0x43797a9cUL, 0xbc9cbc37UL,\n-    0x2b08c968UL, 0x3ffd1b53UL, 0x219a36eeUL, 0x3c955636UL, 0x080d89f2UL,\n-    0x3ffd2f87UL, 0x719d8578UL, 0xbc9d487bUL, 0xeacaa1d6UL, 0x3ffd43c8UL,\n-    0xbf5a1614UL, 0x3c93db53UL, 0xdcfba487UL, 0x3ffd5818UL, 0xd75b3707UL,\n-    0x3c82ed02UL, 0xe862e6d3UL, 0x3ffd6c76UL, 0x4a8165a0UL, 0x3c5fe87aUL,\n-    0x16c98398UL, 0x3ffd80e3UL, 0x8beddfe8UL, 0xbc911ec1UL, 0x71ff6075UL,\n-    0x3ffd955dUL, 0xbb9af6beUL, 0x3c9a052dUL, 0x03db3285UL, 0x3ffda9e6UL,\n-    0x696db532UL, 0x3c9c2300UL, 0xd63a8315UL, 0x3ffdbe7cUL, 0x926b8be4UL,\n-    0xbc9b76f1UL, 0xf301b460UL, 0x3ffdd321UL, 0x78f018c3UL, 0x3c92da57UL,\n-    0x641c0658UL, 0x3ffde7d5UL, 0x8e79ba8fUL, 0xbc9ca552UL, 0x337b9b5fUL,\n-    0x3ffdfc97UL, 0x4f184b5cUL, 0xbc91a5cdUL, 0x6b197d17UL, 0x3ffe1167UL,\n-    0xbd5c7f44UL, 0xbc72b529UL, 0x14f5a129UL, 0x3ffe2646UL, 0x817a1496UL,\n-    0xbc97b627UL, 0x3b16ee12UL, 0x3ffe3b33UL, 0x31fdc68bUL, 0xbc99f4a4UL,\n-    0xe78b3ff6UL, 0x3ffe502eUL, 0x80a9cc8fUL, 0x3c839e89UL, 0x24676d76UL,\n-    0x3ffe6539UL, 0x7522b735UL, 0xbc863ff8UL, 0xfbc74c83UL, 0x3ffe7a51UL,\n-    0xca0c8de2UL, 0x3c92d522UL, 0x77cdb740UL, 0x3ffe8f79UL, 0x80b054b1UL,\n-    0xbc910894UL, 0xa2a490daUL, 0x3ffea4afUL, 0x179c2893UL, 0xbc9e9c23UL,\n-    0x867cca6eUL, 0x3ffeb9f4UL, 0x2293e4f2UL, 0x3c94832fUL, 0x2d8e67f1UL,\n-    0x3ffecf48UL, 0xb411ad8cUL, 0xbc9c93f3UL, 0xa2188510UL, 0x3ffee4aaUL,\n-    0xa487568dUL, 0x3c91c68dUL, 0xee615a27UL, 0x3ffefa1bUL, 0x86a4b6b0UL,\n-    0x3c9dc7f4UL, 0x1cb6412aUL, 0x3fff0f9cUL, 0x65181d45UL, 0xbc932200UL,\n-    0x376bba97UL, 0x3fff252bUL, 0xbf0d8e43UL, 0x3c93a1a5UL, 0x48dd7274UL,\n-    0x3fff3ac9UL, 0x3ed837deUL, 0xbc795a5aUL, 0x5b6e4540UL, 0x3fff5076UL,\n-    0x2dd8a18bUL, 0x3c99d3e1UL, 0x798844f8UL, 0x3fff6632UL, 0x3539343eUL,\n-    0x3c9fa37bUL, 0xad9cbe14UL, 0x3fff7bfdUL, 0xd006350aUL, 0xbc9dbb12UL,\n-    0x02243c89UL, 0x3fff91d8UL, 0xa779f689UL, 0xbc612ea8UL, 0x819e90d8UL,\n-    0x3fffa7c1UL, 0xf3a5931eUL, 0x3c874853UL, 0x3692d514UL, 0x3fffbdbaUL,\n-    0x15098eb6UL, 0xbc796773UL, 0x2b8f71f1UL, 0x3fffd3c2UL, 0x966579e7UL,\n-    0x3c62eb74UL, 0x6b2a23d9UL, 0x3fffe9d9UL, 0x7442fde3UL, 0x3c74a603UL,\n-    0xe78a6731UL, 0x3f55d87fUL, 0xd704a0c0UL, 0x3fac6b08UL, 0x6fba4e77UL,\n-    0x3f83b2abUL, 0xff82c58fUL, 0x3fcebfbdUL, 0xfefa39efUL, 0x3fe62e42UL,\n-    0x00000000UL, 0x00000000UL, 0xfefa39efUL, 0x3fe62e42UL, 0xfefa39efUL,\n-    0xbfe62e42UL, 0xf8000000UL, 0xffffffffUL, 0xf8000000UL, 0xffffffffUL,\n-    0x00000000UL, 0x80000000UL, 0x00000000UL, 0x00000000UL\n-\n-};\n-\n-ATTRIBUTE_ALIGNED(8) double _DOUBLE2 = 2.0;\n-ATTRIBUTE_ALIGNED(8) double _DOUBLE0 = 0.0;\n-ATTRIBUTE_ALIGNED(8) double _DOUBLE0DOT5 = 0.5;\n-\n-\/\/registers,\n-\/\/ input: xmm0, xmm1\n-\/\/ scratch: xmm1, xmm2, xmm3, xmm4, xmm5, xmm6, xmm7\n-\/\/          eax, edx, ecx, ebx\n-\n-\/\/ Code generated by Intel C compiler for LIBM library\n-\n-void MacroAssembler::fast_pow(XMMRegister xmm0, XMMRegister xmm1, XMMRegister xmm2, XMMRegister xmm3, XMMRegister xmm4, XMMRegister xmm5, XMMRegister xmm6, XMMRegister xmm7, Register eax, Register ecx, Register edx, Register tmp) {\n-  Label L_2TAG_PACKET_0_0_2, L_2TAG_PACKET_1_0_2, L_2TAG_PACKET_2_0_2, L_2TAG_PACKET_3_0_2;\n-  Label L_2TAG_PACKET_4_0_2, L_2TAG_PACKET_5_0_2, L_2TAG_PACKET_6_0_2, L_2TAG_PACKET_7_0_2;\n-  Label L_2TAG_PACKET_8_0_2, L_2TAG_PACKET_9_0_2, L_2TAG_PACKET_10_0_2, L_2TAG_PACKET_11_0_2;\n-  Label L_2TAG_PACKET_12_0_2, L_2TAG_PACKET_13_0_2, L_2TAG_PACKET_14_0_2, L_2TAG_PACKET_15_0_2;\n-  Label L_2TAG_PACKET_16_0_2, L_2TAG_PACKET_17_0_2, L_2TAG_PACKET_18_0_2, L_2TAG_PACKET_19_0_2;\n-  Label L_2TAG_PACKET_20_0_2, L_2TAG_PACKET_21_0_2, L_2TAG_PACKET_22_0_2, L_2TAG_PACKET_23_0_2;\n-  Label L_2TAG_PACKET_24_0_2, L_2TAG_PACKET_25_0_2, L_2TAG_PACKET_26_0_2, L_2TAG_PACKET_27_0_2;\n-  Label L_2TAG_PACKET_28_0_2, L_2TAG_PACKET_29_0_2, L_2TAG_PACKET_30_0_2, L_2TAG_PACKET_31_0_2;\n-  Label L_2TAG_PACKET_32_0_2, L_2TAG_PACKET_33_0_2, L_2TAG_PACKET_34_0_2, L_2TAG_PACKET_35_0_2;\n-  Label L_2TAG_PACKET_36_0_2, L_2TAG_PACKET_37_0_2, L_2TAG_PACKET_38_0_2, L_2TAG_PACKET_39_0_2;\n-  Label L_2TAG_PACKET_40_0_2, L_2TAG_PACKET_41_0_2, L_2TAG_PACKET_42_0_2, L_2TAG_PACKET_43_0_2;\n-  Label L_2TAG_PACKET_44_0_2, L_2TAG_PACKET_45_0_2, L_2TAG_PACKET_46_0_2, L_2TAG_PACKET_47_0_2;\n-  Label L_2TAG_PACKET_48_0_2, L_2TAG_PACKET_49_0_2, L_2TAG_PACKET_50_0_2, L_2TAG_PACKET_51_0_2;\n-  Label L_2TAG_PACKET_52_0_2, L_2TAG_PACKET_53_0_2, L_2TAG_PACKET_54_0_2, L_2TAG_PACKET_55_0_2;\n-  Label L_2TAG_PACKET_56_0_2, L_2TAG_PACKET_57_0_2, L_2TAG_PACKET_58_0_2, start;\n-  Label L_NOT_DOUBLE2, L_NOT_DOUBLE0DOT5;\n-\n-  assert_different_registers(tmp, eax, ecx, edx);\n-\n-  address static_const_table_pow = (address)_static_const_table_pow;\n-  address DOUBLE2 = (address) &_DOUBLE2;\n-  address DOUBLE0 = (address) &_DOUBLE0;\n-  address DOUBLE0DOT5 = (address) &_DOUBLE0DOT5;\n-\n-  subl(rsp, 120);\n-  movl(Address(rsp, 64), tmp);\n-  lea(tmp, ExternalAddress(static_const_table_pow));\n-  movsd(xmm0, Address(rsp, 128));\n-  movsd(xmm1, Address(rsp, 136));\n-\n-  \/\/ Special case: pow(x, 2.0) => x * x\n-  ucomisd(xmm1, ExternalAddress(DOUBLE2));\n-  jccb(Assembler::notEqual, L_NOT_DOUBLE2);\n-  jccb(Assembler::parity, L_NOT_DOUBLE2);\n-  mulsd(xmm0, xmm0);\n-  jmp(L_2TAG_PACKET_21_0_2);\n-\n-  bind(L_NOT_DOUBLE2);\n-  \/\/ Special case: pow(x, 0.5) => sqrt(x)\n-  ucomisd(xmm1, ExternalAddress(DOUBLE0DOT5)); \/\/ For pow(x, y), check whether y == 0.5\n-  jccb(Assembler::notEqual, L_NOT_DOUBLE0DOT5);\n-  jccb(Assembler::parity, L_NOT_DOUBLE0DOT5);\n-  ucomisd(xmm0, ExternalAddress(DOUBLE0));\n-  \/\/ According to the API specs, pow(-0.0, 0.5) = 0.0 and sqrt(-0.0) = -0.0.\n-  \/\/ So pow(-0.0, 0.5) shouldn't be replaced with sqrt(-0.0).\n-  \/\/ -0.0\/+0.0 are both excluded since floating-point comparison doesn't distinguish -0.0 from +0.0.\n-  jccb(Assembler::belowEqual, L_NOT_DOUBLE0DOT5); \/\/ pow(x, 0.5) => sqrt(x) only for x > 0.0\n-  sqrtsd(xmm0, xmm0);\n-  jmp(L_2TAG_PACKET_21_0_2);\n-\n-  bind(L_NOT_DOUBLE0DOT5);\n-  xorpd(xmm2, xmm2);\n-  movl(eax, 16368);\n-  pinsrw(xmm2, eax, 3);\n-  movl(ecx, 1069088768);\n-  movdl(xmm7, ecx);\n-  movsd(Address(rsp, 16), xmm1);\n-  xorpd(xmm1, xmm1);\n-  movl(edx, 30704);\n-  pinsrw(xmm1, edx, 3);\n-  movsd(Address(rsp, 8), xmm0);\n-  movdqu(xmm3, xmm0);\n-  movl(edx, 8192);\n-  movdl(xmm4, edx);\n-  movdqu(xmm6, Address(tmp, 8240));\n-  pextrw(eax, xmm0, 3);\n-  por(xmm0, xmm2);\n-  psllq(xmm0, 5);\n-  movsd(xmm2, Address(tmp, 8256));\n-  psrlq(xmm0, 34);\n-  movl(edx, eax);\n-  andl(edx, 32752);\n-  subl(edx, 16368);\n-  movl(ecx, edx);\n-  sarl(edx, 31);\n-  addl(ecx, edx);\n-  xorl(ecx, edx);\n-  rcpss(xmm0, xmm0);\n-  psllq(xmm3, 12);\n-  addl(ecx, 16);\n-  bsrl(ecx, ecx);\n-  psrlq(xmm3, 12);\n-  movl(Address(rsp, 24), rsi);\n-  subl(eax, 16);\n-  cmpl(eax, 32736);\n-  jcc(Assembler::aboveEqual, L_2TAG_PACKET_0_0_2);\n-  movl(rsi, 0);\n-\n-  bind(L_2TAG_PACKET_1_0_2);\n-  mulss(xmm0, xmm7);\n-  movl(edx, -1);\n-  subl(ecx, 4);\n-  shll(edx);\n-  movdl(xmm5, edx);\n-  por(xmm3, xmm1);\n-  subl(eax, 16351);\n-  cmpl(eax, 1);\n-  jcc(Assembler::belowEqual, L_2TAG_PACKET_2_0_2);\n-  paddd(xmm0, xmm4);\n-  psllq(xmm5, 32);\n-  movdl(edx, xmm0);\n-  psllq(xmm0, 29);\n-  pand(xmm5, xmm3);\n-\n-  bind(L_2TAG_PACKET_3_0_2);\n-  pand(xmm0, xmm6);\n-  subsd(xmm3, xmm5);\n-  subl(eax, 1);\n-  sarl(eax, 4);\n-  cvtsi2sdl(xmm7, eax);\n-  mulpd(xmm5, xmm0);\n-\n-  bind(L_2TAG_PACKET_4_0_2);\n-  mulsd(xmm3, xmm0);\n-  movdqu(xmm1, Address(tmp, 8272));\n-  subsd(xmm5, xmm2);\n-  movdqu(xmm4, Address(tmp, 8288));\n-  movl(ecx, eax);\n-  sarl(eax, 31);\n-  addl(ecx, eax);\n-  xorl(eax, ecx);\n-  addl(eax, 1);\n-  bsrl(eax, eax);\n-  unpcklpd(xmm5, xmm3);\n-  movdqu(xmm6, Address(tmp, 8304));\n-  addsd(xmm3, xmm5);\n-  andl(edx, 16760832);\n-  shrl(edx, 10);\n-  addpd(xmm5, Address(tmp, edx, Address::times_1, -3616));\n-  movdqu(xmm0, Address(tmp, 8320));\n-  pshufd(xmm2, xmm3, 68);\n-  mulsd(xmm3, xmm3);\n-  mulpd(xmm1, xmm2);\n-  mulpd(xmm4, xmm2);\n-  addsd(xmm5, xmm7);\n-  mulsd(xmm2, xmm3);\n-  addpd(xmm6, xmm1);\n-  mulsd(xmm3, xmm3);\n-  addpd(xmm0, xmm4);\n-  movsd(xmm1, Address(rsp, 16));\n-  movzwl(ecx, Address(rsp, 22));\n-  pshufd(xmm7, xmm5, 238);\n-  movsd(xmm4, Address(tmp, 8368));\n-  mulpd(xmm6, xmm2);\n-  pshufd(xmm3, xmm3, 68);\n-  mulpd(xmm0, xmm2);\n-  shll(eax, 4);\n-  subl(eax, 15872);\n-  andl(ecx, 32752);\n-  addl(eax, ecx);\n-  mulpd(xmm3, xmm6);\n-  cmpl(eax, 624);\n-  jcc(Assembler::aboveEqual, L_2TAG_PACKET_5_0_2);\n-  xorpd(xmm6, xmm6);\n-  movl(edx, 17080);\n-  pinsrw(xmm6, edx, 3);\n-  movdqu(xmm2, xmm1);\n-  pand(xmm4, xmm1);\n-  subsd(xmm1, xmm4);\n-  mulsd(xmm4, xmm5);\n-  addsd(xmm0, xmm7);\n-  mulsd(xmm1, xmm5);\n-  movdqu(xmm7, xmm6);\n-  addsd(xmm6, xmm4);\n-  addpd(xmm3, xmm0);\n-  movdl(edx, xmm6);\n-  subsd(xmm6, xmm7);\n-  pshufd(xmm0, xmm3, 238);\n-  subsd(xmm4, xmm6);\n-  addsd(xmm0, xmm3);\n-  movl(ecx, edx);\n-  andl(edx, 255);\n-  addl(edx, edx);\n-  movdqu(xmm5, Address(tmp, edx, Address::times_8, 8384));\n-  addsd(xmm4, xmm1);\n-  mulsd(xmm2, xmm0);\n-  movdqu(xmm7, Address(tmp, 12480));\n-  movdqu(xmm3, Address(tmp, 12496));\n-  shll(ecx, 12);\n-  xorl(ecx, rsi);\n-  andl(ecx, -1048576);\n-  movdl(xmm6, ecx);\n-  addsd(xmm2, xmm4);\n-  movsd(xmm1, Address(tmp, 12512));\n-  pshufd(xmm0, xmm2, 68);\n-  pshufd(xmm4, xmm2, 68);\n-  mulpd(xmm0, xmm0);\n-  movl(rsi, Address(rsp, 24));\n-  mulpd(xmm7, xmm4);\n-  pshufd(xmm6, xmm6, 17);\n-  mulsd(xmm1, xmm2);\n-  mulsd(xmm0, xmm0);\n-  paddd(xmm5, xmm6);\n-  addpd(xmm3, xmm7);\n-  mulsd(xmm1, xmm5);\n-  pshufd(xmm6, xmm5, 238);\n-  mulpd(xmm0, xmm3);\n-  addsd(xmm1, xmm6);\n-  pshufd(xmm3, xmm0, 238);\n-  mulsd(xmm0, xmm5);\n-  mulsd(xmm3, xmm5);\n-  addsd(xmm0, xmm1);\n-  addsd(xmm0, xmm3);\n-  addsd(xmm0, xmm5);\n-  movsd(Address(rsp, 0), xmm0);\n-  fld_d(Address(rsp, 0));\n-  jmp(L_2TAG_PACKET_6_0_2);\n-\n-  bind(L_2TAG_PACKET_7_0_2);\n-  movsd(xmm0, Address(rsp, 128));\n-  movsd(xmm1, Address(rsp, 136));\n-  mulsd(xmm0, xmm1);\n-  movsd(Address(rsp, 0), xmm0);\n-  fld_d(Address(rsp, 0));\n-  jmp(L_2TAG_PACKET_6_0_2);\n-\n-  bind(L_2TAG_PACKET_0_0_2);\n-  addl(eax, 16);\n-  movl(edx, 32752);\n-  andl(edx, eax);\n-  cmpl(edx, 32752);\n-  jcc(Assembler::equal, L_2TAG_PACKET_8_0_2);\n-  testl(eax, 32768);\n-  jcc(Assembler::notEqual, L_2TAG_PACKET_9_0_2);\n-\n-  bind(L_2TAG_PACKET_10_0_2);\n-  movl(ecx, Address(rsp, 16));\n-  xorl(edx, edx);\n-  testl(ecx, ecx);\n-  movl(ecx, 1);\n-  cmovl(Assembler::notEqual, edx, ecx);\n-  orl(edx, Address(rsp, 20));\n-  cmpl(edx, 1072693248);\n-  jcc(Assembler::equal, L_2TAG_PACKET_7_0_2);\n-  movsd(xmm0, Address(rsp, 8));\n-  movsd(xmm3, Address(rsp, 8));\n-  movdl(edx, xmm3);\n-  psrlq(xmm3, 32);\n-  movdl(ecx, xmm3);\n-  orl(edx, ecx);\n-  cmpl(edx, 0);\n-  jcc(Assembler::equal, L_2TAG_PACKET_11_0_2);\n-  xorpd(xmm3, xmm3);\n-  movl(eax, 18416);\n-  pinsrw(xmm3, eax, 3);\n-  mulsd(xmm0, xmm3);\n-  xorpd(xmm2, xmm2);\n-  movl(eax, 16368);\n-  pinsrw(xmm2, eax, 3);\n-  movdqu(xmm3, xmm0);\n-  pextrw(eax, xmm0, 3);\n-  por(xmm0, xmm2);\n-  movl(ecx, 18416);\n-  psllq(xmm0, 5);\n-  movsd(xmm2, Address(tmp, 8256));\n-  psrlq(xmm0, 34);\n-  rcpss(xmm0, xmm0);\n-  psllq(xmm3, 12);\n-  movdqu(xmm6, Address(tmp, 8240));\n-  psrlq(xmm3, 12);\n-  mulss(xmm0, xmm7);\n-  movl(edx, -1024);\n-  movdl(xmm5, edx);\n-  por(xmm3, xmm1);\n-  paddd(xmm0, xmm4);\n-  psllq(xmm5, 32);\n-  movdl(edx, xmm0);\n-  psllq(xmm0, 29);\n-  pand(xmm5, xmm3);\n-  movl(rsi, 0);\n-  pand(xmm0, xmm6);\n-  subsd(xmm3, xmm5);\n-  andl(eax, 32752);\n-  subl(eax, 18416);\n-  sarl(eax, 4);\n-  cvtsi2sdl(xmm7, eax);\n-  mulpd(xmm5, xmm0);\n-  jmp(L_2TAG_PACKET_4_0_2);\n-\n-  bind(L_2TAG_PACKET_12_0_2);\n-  movl(ecx, Address(rsp, 16));\n-  xorl(edx, edx);\n-  testl(ecx, ecx);\n-  movl(ecx, 1);\n-  cmovl(Assembler::notEqual, edx, ecx);\n-  orl(edx, Address(rsp, 20));\n-  cmpl(edx, 1072693248);\n-  jcc(Assembler::equal, L_2TAG_PACKET_7_0_2);\n-  movsd(xmm0, Address(rsp, 8));\n-  movsd(xmm3, Address(rsp, 8));\n-  movdl(edx, xmm3);\n-  psrlq(xmm3, 32);\n-  movdl(ecx, xmm3);\n-  orl(edx, ecx);\n-  cmpl(edx, 0);\n-  jcc(Assembler::equal, L_2TAG_PACKET_11_0_2);\n-  xorpd(xmm3, xmm3);\n-  movl(eax, 18416);\n-  pinsrw(xmm3, eax, 3);\n-  mulsd(xmm0, xmm3);\n-  xorpd(xmm2, xmm2);\n-  movl(eax, 16368);\n-  pinsrw(xmm2, eax, 3);\n-  movdqu(xmm3, xmm0);\n-  pextrw(eax, xmm0, 3);\n-  por(xmm0, xmm2);\n-  movl(ecx, 18416);\n-  psllq(xmm0, 5);\n-  movsd(xmm2, Address(tmp, 8256));\n-  psrlq(xmm0, 34);\n-  rcpss(xmm0, xmm0);\n-  psllq(xmm3, 12);\n-  movdqu(xmm6, Address(tmp, 8240));\n-  psrlq(xmm3, 12);\n-  mulss(xmm0, xmm7);\n-  movl(edx, -1024);\n-  movdl(xmm5, edx);\n-  por(xmm3, xmm1);\n-  paddd(xmm0, xmm4);\n-  psllq(xmm5, 32);\n-  movdl(edx, xmm0);\n-  psllq(xmm0, 29);\n-  pand(xmm5, xmm3);\n-  movl(rsi, INT_MIN);\n-  pand(xmm0, xmm6);\n-  subsd(xmm3, xmm5);\n-  andl(eax, 32752);\n-  subl(eax, 18416);\n-  sarl(eax, 4);\n-  cvtsi2sdl(xmm7, eax);\n-  mulpd(xmm5, xmm0);\n-  jmp(L_2TAG_PACKET_4_0_2);\n-\n-  bind(L_2TAG_PACKET_5_0_2);\n-  cmpl(eax, 0);\n-  jcc(Assembler::less, L_2TAG_PACKET_13_0_2);\n-  cmpl(eax, 752);\n-  jcc(Assembler::aboveEqual, L_2TAG_PACKET_14_0_2);\n-\n-  bind(L_2TAG_PACKET_15_0_2);\n-  addsd(xmm0, xmm7);\n-  movsd(xmm2, Address(tmp, 12544));\n-  addpd(xmm3, xmm0);\n-  xorpd(xmm6, xmm6);\n-  movl(eax, 17080);\n-  pinsrw(xmm6, eax, 3);\n-  pshufd(xmm0, xmm3, 238);\n-  addsd(xmm0, xmm3);\n-  movdqu(xmm3, xmm5);\n-  addsd(xmm5, xmm0);\n-  movdqu(xmm4, xmm2);\n-  subsd(xmm3, xmm5);\n-  movdqu(xmm7, xmm5);\n-  pand(xmm5, xmm2);\n-  movdqu(xmm2, xmm1);\n-  pand(xmm4, xmm1);\n-  subsd(xmm7, xmm5);\n-  addsd(xmm0, xmm3);\n-  subsd(xmm1, xmm4);\n-  mulsd(xmm4, xmm5);\n-  addsd(xmm0, xmm7);\n-  mulsd(xmm2, xmm0);\n-  movdqu(xmm7, xmm6);\n-  mulsd(xmm1, xmm5);\n-  addsd(xmm6, xmm4);\n-  movdl(eax, xmm6);\n-  subsd(xmm6, xmm7);\n-  addsd(xmm2, xmm1);\n-  movdqu(xmm7, Address(tmp, 12480));\n-  movdqu(xmm3, Address(tmp, 12496));\n-  subsd(xmm4, xmm6);\n-  pextrw(edx, xmm6, 3);\n-  movl(ecx, eax);\n-  andl(eax, 255);\n-  addl(eax, eax);\n-  movdqu(xmm5, Address(tmp, eax, Address::times_8, 8384));\n-  addsd(xmm2, xmm4);\n-  sarl(ecx, 8);\n-  movl(eax, ecx);\n-  sarl(ecx, 1);\n-  subl(eax, ecx);\n-  shll(ecx, 20);\n-  xorl(ecx, rsi);\n-  movdl(xmm6, ecx);\n-  movsd(xmm1, Address(tmp, 12512));\n-  andl(edx, 32767);\n-  cmpl(edx, 16529);\n-  jcc(Assembler::above, L_2TAG_PACKET_14_0_2);\n-  pshufd(xmm0, xmm2, 68);\n-  pshufd(xmm4, xmm2, 68);\n-  mulpd(xmm0, xmm0);\n-  mulpd(xmm7, xmm4);\n-  pshufd(xmm6, xmm6, 17);\n-  mulsd(xmm1, xmm2);\n-  mulsd(xmm0, xmm0);\n-  paddd(xmm5, xmm6);\n-  addpd(xmm3, xmm7);\n-  mulsd(xmm1, xmm5);\n-  pshufd(xmm6, xmm5, 238);\n-  mulpd(xmm0, xmm3);\n-  addsd(xmm1, xmm6);\n-  pshufd(xmm3, xmm0, 238);\n-  mulsd(xmm0, xmm5);\n-  mulsd(xmm3, xmm5);\n-  shll(eax, 4);\n-  xorpd(xmm4, xmm4);\n-  addl(eax, 16368);\n-  pinsrw(xmm4, eax, 3);\n-  addsd(xmm0, xmm1);\n-  movl(rsi, Address(rsp, 24));\n-  addsd(xmm0, xmm3);\n-  movdqu(xmm1, xmm0);\n-  addsd(xmm0, xmm5);\n-  mulsd(xmm0, xmm4);\n-  pextrw(eax, xmm0, 3);\n-  andl(eax, 32752);\n-  jcc(Assembler::equal, L_2TAG_PACKET_16_0_2);\n-  cmpl(eax, 32752);\n-  jcc(Assembler::equal, L_2TAG_PACKET_17_0_2);\n-\n-  bind(L_2TAG_PACKET_18_0_2);\n-  movsd(Address(rsp, 0), xmm0);\n-  fld_d(Address(rsp, 0));\n-  jmp(L_2TAG_PACKET_6_0_2);\n-\n-  bind(L_2TAG_PACKET_8_0_2);\n-  movsd(xmm1, Address(rsp, 16));\n-  movsd(xmm0, Address(rsp, 8));\n-  movdqu(xmm2, xmm0);\n-  movdl(eax, xmm2);\n-  psrlq(xmm2, 20);\n-  movdl(edx, xmm2);\n-  orl(eax, edx);\n-  jcc(Assembler::equal, L_2TAG_PACKET_19_0_2);\n-  addsd(xmm0, xmm0);\n-  movdl(eax, xmm1);\n-  psrlq(xmm1, 32);\n-  movdl(edx, xmm1);\n-  movl(ecx, edx);\n-  addl(edx, edx);\n-  orl(eax, edx);\n-  jcc(Assembler::equal, L_2TAG_PACKET_20_0_2);\n-  jmp(L_2TAG_PACKET_18_0_2);\n-\n-  bind(L_2TAG_PACKET_20_0_2);\n-  xorpd(xmm0, xmm0);\n-  movl(eax, 16368);\n-  pinsrw(xmm0, eax, 3);\n-  movl(edx, 29);\n-  jmp(L_2TAG_PACKET_21_0_2);\n-\n-  bind(L_2TAG_PACKET_22_0_2);\n-  movsd(xmm0, Address(rsp, 16));\n-  addpd(xmm0, xmm0);\n-  jmp(L_2TAG_PACKET_18_0_2);\n-\n-  bind(L_2TAG_PACKET_19_0_2);\n-  movdl(eax, xmm1);\n-  movdqu(xmm2, xmm1);\n-  psrlq(xmm1, 32);\n-  movdl(edx, xmm1);\n-  movl(ecx, edx);\n-  addl(edx, edx);\n-  orl(eax, edx);\n-  jcc(Assembler::equal, L_2TAG_PACKET_23_0_2);\n-  pextrw(eax, xmm2, 3);\n-  andl(eax, 32752);\n-  cmpl(eax, 32752);\n-  jcc(Assembler::notEqual, L_2TAG_PACKET_24_0_2);\n-  movdl(eax, xmm2);\n-  psrlq(xmm2, 20);\n-  movdl(edx, xmm2);\n-  orl(eax, edx);\n-  jcc(Assembler::notEqual, L_2TAG_PACKET_22_0_2);\n-\n-  bind(L_2TAG_PACKET_24_0_2);\n-  pextrw(eax, xmm0, 3);\n-  testl(eax, 32768);\n-  jcc(Assembler::notEqual, L_2TAG_PACKET_25_0_2);\n-  testl(ecx, INT_MIN);\n-  jcc(Assembler::notEqual, L_2TAG_PACKET_26_0_2);\n-  jmp(L_2TAG_PACKET_18_0_2);\n-\n-  bind(L_2TAG_PACKET_27_0_2);\n-  movsd(xmm1, Address(rsp, 16));\n-  movdl(eax, xmm1);\n-  testl(eax, 1);\n-  jcc(Assembler::notEqual, L_2TAG_PACKET_28_0_2);\n-  testl(eax, 2);\n-  jcc(Assembler::notEqual, L_2TAG_PACKET_29_0_2);\n-  jmp(L_2TAG_PACKET_28_0_2);\n-\n-  bind(L_2TAG_PACKET_25_0_2);\n-  shrl(ecx, 20);\n-  andl(ecx, 2047);\n-  cmpl(ecx, 1075);\n-  jcc(Assembler::above, L_2TAG_PACKET_28_0_2);\n-  jcc(Assembler::equal, L_2TAG_PACKET_30_0_2);\n-  cmpl(ecx, 1074);\n-  jcc(Assembler::above, L_2TAG_PACKET_27_0_2);\n-  cmpl(ecx, 1023);\n-  jcc(Assembler::below, L_2TAG_PACKET_28_0_2);\n-  movsd(xmm1, Address(rsp, 16));\n-  movl(eax, 17208);\n-  xorpd(xmm3, xmm3);\n-  pinsrw(xmm3, eax, 3);\n-  movdqu(xmm4, xmm3);\n-  addsd(xmm3, xmm1);\n-  subsd(xmm4, xmm3);\n-  addsd(xmm1, xmm4);\n-  pextrw(eax, xmm1, 3);\n-  andl(eax, 32752);\n-  jcc(Assembler::notEqual, L_2TAG_PACKET_28_0_2);\n-  movdl(eax, xmm3);\n-  andl(eax, 1);\n-  jcc(Assembler::equal, L_2TAG_PACKET_28_0_2);\n-\n-  bind(L_2TAG_PACKET_29_0_2);\n-  movsd(xmm1, Address(rsp, 16));\n-  pextrw(eax, xmm1, 3);\n-  andl(eax, 32768);\n-  jcc(Assembler::equal, L_2TAG_PACKET_18_0_2);\n-  xorpd(xmm0, xmm0);\n-  movl(eax, 32768);\n-  pinsrw(xmm0, eax, 3);\n-  jmp(L_2TAG_PACKET_18_0_2);\n-\n-  bind(L_2TAG_PACKET_28_0_2);\n-  movsd(xmm1, Address(rsp, 16));\n-  pextrw(eax, xmm1, 3);\n-  andl(eax, 32768);\n-  jcc(Assembler::notEqual, L_2TAG_PACKET_26_0_2);\n-\n-  bind(L_2TAG_PACKET_31_0_2);\n-  xorpd(xmm0, xmm0);\n-  movl(eax, 32752);\n-  pinsrw(xmm0, eax, 3);\n-  jmp(L_2TAG_PACKET_18_0_2);\n-\n-  bind(L_2TAG_PACKET_30_0_2);\n-  movsd(xmm1, Address(rsp, 16));\n-  movdl(eax, xmm1);\n-  andl(eax, 1);\n-  jcc(Assembler::equal, L_2TAG_PACKET_28_0_2);\n-  jmp(L_2TAG_PACKET_29_0_2);\n-\n-  bind(L_2TAG_PACKET_32_0_2);\n-  movdl(eax, xmm1);\n-  psrlq(xmm1, 20);\n-  movdl(edx, xmm1);\n-  orl(eax, edx);\n-  jcc(Assembler::equal, L_2TAG_PACKET_33_0_2);\n-  movsd(xmm0, Address(rsp, 16));\n-  addsd(xmm0, xmm0);\n-  jmp(L_2TAG_PACKET_18_0_2);\n-\n-  bind(L_2TAG_PACKET_33_0_2);\n-  movsd(xmm0, Address(rsp, 8));\n-  pextrw(eax, xmm0, 3);\n-  cmpl(eax, 49136);\n-  jcc(Assembler::notEqual, L_2TAG_PACKET_34_0_2);\n-  movdl(ecx, xmm0);\n-  psrlq(xmm0, 20);\n-  movdl(edx, xmm0);\n-  orl(ecx, edx);\n-  jcc(Assembler::notEqual, L_2TAG_PACKET_34_0_2);\n-  xorpd(xmm0, xmm0);\n-  movl(eax, 32760);\n-  pinsrw(xmm0, eax, 3);\n-  jmp(L_2TAG_PACKET_18_0_2);\n-\n-  bind(L_2TAG_PACKET_34_0_2);\n-  movsd(xmm1, Address(rsp, 16));\n-  andl(eax, 32752);\n-  subl(eax, 16368);\n-  pextrw(edx, xmm1, 3);\n-  xorpd(xmm0, xmm0);\n-  xorl(eax, edx);\n-  andl(eax, 32768);\n-  jcc(Assembler::notEqual, L_2TAG_PACKET_18_0_2);\n-  movl(ecx, 32752);\n-  pinsrw(xmm0, ecx, 3);\n-  jmp(L_2TAG_PACKET_18_0_2);\n-\n-  bind(L_2TAG_PACKET_35_0_2);\n-  movdl(eax, xmm1);\n-  cmpl(edx, 17184);\n-  jcc(Assembler::above, L_2TAG_PACKET_36_0_2);\n-  testl(eax, 1);\n-  jcc(Assembler::notEqual, L_2TAG_PACKET_37_0_2);\n-  testl(eax, 2);\n-  jcc(Assembler::equal, L_2TAG_PACKET_38_0_2);\n-  jmp(L_2TAG_PACKET_39_0_2);\n-\n-  bind(L_2TAG_PACKET_36_0_2);\n-  testl(eax, 1);\n-  jcc(Assembler::equal, L_2TAG_PACKET_38_0_2);\n-  jmp(L_2TAG_PACKET_39_0_2);\n-\n-  bind(L_2TAG_PACKET_9_0_2);\n-  movsd(xmm2, Address(rsp, 8));\n-  movdl(eax, xmm2);\n-  psrlq(xmm2, 31);\n-  movdl(ecx, xmm2);\n-  orl(eax, ecx);\n-  jcc(Assembler::equal, L_2TAG_PACKET_11_0_2);\n-  movsd(xmm1, Address(rsp, 16));\n-  pextrw(edx, xmm1, 3);\n-  movdl(eax, xmm1);\n-  movdqu(xmm2, xmm1);\n-  psrlq(xmm2, 32);\n-  movdl(ecx, xmm2);\n-  addl(ecx, ecx);\n-  orl(ecx, eax);\n-  jcc(Assembler::equal, L_2TAG_PACKET_40_0_2);\n-  andl(edx, 32752);\n-  cmpl(edx, 32752);\n-  jcc(Assembler::equal, L_2TAG_PACKET_32_0_2);\n-  cmpl(edx, 17200);\n-  jcc(Assembler::above, L_2TAG_PACKET_38_0_2);\n-  cmpl(edx, 17184);\n-  jcc(Assembler::aboveEqual, L_2TAG_PACKET_35_0_2);\n-  cmpl(edx, 16368);\n-  jcc(Assembler::below, L_2TAG_PACKET_37_0_2);\n-  movl(eax, 17208);\n-  xorpd(xmm2, xmm2);\n-  pinsrw(xmm2, eax, 3);\n-  movdqu(xmm4, xmm2);\n-  addsd(xmm2, xmm1);\n-  subsd(xmm4, xmm2);\n-  addsd(xmm1, xmm4);\n-  pextrw(eax, xmm1, 3);\n-  andl(eax, 32767);\n-  jcc(Assembler::notEqual, L_2TAG_PACKET_37_0_2);\n-  movdl(eax, xmm2);\n-  andl(eax, 1);\n-  jcc(Assembler::equal, L_2TAG_PACKET_38_0_2);\n-\n-  bind(L_2TAG_PACKET_39_0_2);\n-  xorpd(xmm1, xmm1);\n-  movl(edx, 30704);\n-  pinsrw(xmm1, edx, 3);\n-  movsd(xmm2, Address(tmp, 8256));\n-  movsd(xmm4, Address(rsp, 8));\n-  pextrw(eax, xmm4, 3);\n-  movl(edx, 8192);\n-  movdl(xmm4, edx);\n-  andl(eax, 32767);\n-  subl(eax, 16);\n-  jcc(Assembler::less, L_2TAG_PACKET_12_0_2);\n-  movl(edx, eax);\n-  andl(edx, 32752);\n-  subl(edx, 16368);\n-  movl(ecx, edx);\n-  sarl(edx, 31);\n-  addl(ecx, edx);\n-  xorl(ecx, edx);\n-  addl(ecx, 16);\n-  bsrl(ecx, ecx);\n-  movl(rsi, INT_MIN);\n-  jmp(L_2TAG_PACKET_1_0_2);\n-\n-  bind(L_2TAG_PACKET_37_0_2);\n-  xorpd(xmm1, xmm1);\n-  movl(eax, 32752);\n-  pinsrw(xmm1, eax, 3);\n-  xorpd(xmm0, xmm0);\n-  mulsd(xmm0, xmm1);\n-  movl(edx, 28);\n-  jmp(L_2TAG_PACKET_21_0_2);\n-\n-  bind(L_2TAG_PACKET_38_0_2);\n-  xorpd(xmm1, xmm1);\n-  movl(edx, 30704);\n-  pinsrw(xmm1, edx, 3);\n-  movsd(xmm2, Address(tmp, 8256));\n-  movsd(xmm4, Address(rsp, 8));\n-  pextrw(eax, xmm4, 3);\n-  movl(edx, 8192);\n-  movdl(xmm4, edx);\n-  andl(eax, 32767);\n-  subl(eax, 16);\n-  jcc(Assembler::less, L_2TAG_PACKET_10_0_2);\n-  movl(edx, eax);\n-  andl(edx, 32752);\n-  subl(edx, 16368);\n-  movl(ecx, edx);\n-  sarl(edx, 31);\n-  addl(ecx, edx);\n-  xorl(ecx, edx);\n-  addl(ecx, 16);\n-  bsrl(ecx, ecx);\n-  movl(rsi, 0);\n-  jmp(L_2TAG_PACKET_1_0_2);\n-\n-  bind(L_2TAG_PACKET_23_0_2);\n-  xorpd(xmm0, xmm0);\n-  movl(eax, 16368);\n-  pinsrw(xmm0, eax, 3);\n-  jmp(L_2TAG_PACKET_18_0_2);\n-\n-  bind(L_2TAG_PACKET_26_0_2);\n-  xorpd(xmm0, xmm0);\n-  jmp(L_2TAG_PACKET_18_0_2);\n-\n-  bind(L_2TAG_PACKET_13_0_2);\n-  addl(eax, 384);\n-  cmpl(eax, 0);\n-  jcc(Assembler::less, L_2TAG_PACKET_41_0_2);\n-  mulsd(xmm5, xmm1);\n-  addsd(xmm0, xmm7);\n-  shrl(rsi, 31);\n-  addpd(xmm3, xmm0);\n-  pshufd(xmm0, xmm3, 238);\n-  addsd(xmm3, xmm0);\n-  movsd(xmm4, Address(tmp, rsi, Address::times_8, 12528));\n-  mulsd(xmm1, xmm3);\n-  xorpd(xmm0, xmm0);\n-  movl(eax, 16368);\n-  shll(rsi, 15);\n-  orl(eax, rsi);\n-  pinsrw(xmm0, eax, 3);\n-  addsd(xmm5, xmm1);\n-  movl(rsi, Address(rsp, 24));\n-  mulsd(xmm5, xmm4);\n-  addsd(xmm0, xmm5);\n-  jmp(L_2TAG_PACKET_18_0_2);\n-\n-  bind(L_2TAG_PACKET_41_0_2);\n-  movl(rsi, Address(rsp, 24));\n-  xorpd(xmm0, xmm0);\n-  movl(eax, 16368);\n-  pinsrw(xmm0, eax, 3);\n-  jmp(L_2TAG_PACKET_18_0_2);\n-\n-  bind(L_2TAG_PACKET_40_0_2);\n-  xorpd(xmm0, xmm0);\n-  movl(eax, 16368);\n-  pinsrw(xmm0, eax, 3);\n-  jmp(L_2TAG_PACKET_18_0_2);\n-\n-  bind(L_2TAG_PACKET_42_0_2);\n-  xorpd(xmm0, xmm0);\n-  movl(eax, 16368);\n-  pinsrw(xmm0, eax, 3);\n-  movl(edx, 26);\n-  jmp(L_2TAG_PACKET_21_0_2);\n-\n-  bind(L_2TAG_PACKET_11_0_2);\n-  movsd(xmm1, Address(rsp, 16));\n-  movdqu(xmm2, xmm1);\n-  pextrw(eax, xmm1, 3);\n-  andl(eax, 32752);\n-  cmpl(eax, 32752);\n-  jcc(Assembler::notEqual, L_2TAG_PACKET_43_0_2);\n-  movdl(eax, xmm2);\n-  psrlq(xmm2, 20);\n-  movdl(edx, xmm2);\n-  orl(eax, edx);\n-  jcc(Assembler::notEqual, L_2TAG_PACKET_22_0_2);\n-\n-  bind(L_2TAG_PACKET_43_0_2);\n-  movdl(eax, xmm1);\n-  psrlq(xmm1, 32);\n-  movdl(edx, xmm1);\n-  movl(ecx, edx);\n-  addl(edx, edx);\n-  orl(eax, edx);\n-  jcc(Assembler::equal, L_2TAG_PACKET_42_0_2);\n-  shrl(edx, 21);\n-  cmpl(edx, 1075);\n-  jcc(Assembler::above, L_2TAG_PACKET_44_0_2);\n-  jcc(Assembler::equal, L_2TAG_PACKET_45_0_2);\n-  cmpl(edx, 1023);\n-  jcc(Assembler::below, L_2TAG_PACKET_44_0_2);\n-  movsd(xmm1, Address(rsp, 16));\n-  movl(eax, 17208);\n-  xorpd(xmm3, xmm3);\n-  pinsrw(xmm3, eax, 3);\n-  movdqu(xmm4, xmm3);\n-  addsd(xmm3, xmm1);\n-  subsd(xmm4, xmm3);\n-  addsd(xmm1, xmm4);\n-  pextrw(eax, xmm1, 3);\n-  andl(eax, 32752);\n-  jcc(Assembler::notEqual, L_2TAG_PACKET_44_0_2);\n-  movdl(eax, xmm3);\n-  andl(eax, 1);\n-  jcc(Assembler::equal, L_2TAG_PACKET_44_0_2);\n-\n-  bind(L_2TAG_PACKET_46_0_2);\n-  movsd(xmm0, Address(rsp, 8));\n-  testl(ecx, INT_MIN);\n-  jcc(Assembler::notEqual, L_2TAG_PACKET_47_0_2);\n-  jmp(L_2TAG_PACKET_18_0_2);\n-\n-  bind(L_2TAG_PACKET_45_0_2);\n-  movsd(xmm1, Address(rsp, 16));\n-  movdl(eax, xmm1);\n-  testl(eax, 1);\n-  jcc(Assembler::notEqual, L_2TAG_PACKET_46_0_2);\n-\n-  bind(L_2TAG_PACKET_44_0_2);\n-  testl(ecx, INT_MIN);\n-  jcc(Assembler::equal, L_2TAG_PACKET_26_0_2);\n-  xorpd(xmm0, xmm0);\n-\n-  bind(L_2TAG_PACKET_47_0_2);\n-  movl(eax, 16368);\n-  xorpd(xmm1, xmm1);\n-  pinsrw(xmm1, eax, 3);\n-  divsd(xmm1, xmm0);\n-  movdqu(xmm0, xmm1);\n-  movl(edx, 27);\n-  jmp(L_2TAG_PACKET_21_0_2);\n-\n-  bind(L_2TAG_PACKET_14_0_2);\n-  movsd(xmm2, Address(rsp, 8));\n-  movsd(xmm6, Address(rsp, 16));\n-  pextrw(eax, xmm2, 3);\n-  pextrw(edx, xmm6, 3);\n-  movl(ecx, 32752);\n-  andl(ecx, edx);\n-  cmpl(ecx, 32752);\n-  jcc(Assembler::equal, L_2TAG_PACKET_48_0_2);\n-  andl(eax, 32752);\n-  subl(eax, 16368);\n-  xorl(edx, eax);\n-  testl(edx, 32768);\n-  jcc(Assembler::notEqual, L_2TAG_PACKET_49_0_2);\n-\n-  bind(L_2TAG_PACKET_50_0_2);\n-  movl(eax, 32736);\n-  pinsrw(xmm0, eax, 3);\n-  shrl(rsi, 16);\n-  orl(eax, rsi);\n-  pinsrw(xmm1, eax, 3);\n-  movl(rsi, Address(rsp, 24));\n-  mulsd(xmm0, xmm1);\n-\n-  bind(L_2TAG_PACKET_17_0_2);\n-  movl(edx, 24);\n-\n-  bind(L_2TAG_PACKET_21_0_2);\n-  movsd(Address(rsp, 0), xmm0);\n-  fld_d(Address(rsp, 0));\n-  jmp(L_2TAG_PACKET_6_0_2);\n-\n-  bind(L_2TAG_PACKET_49_0_2);\n-  movl(eax, 16);\n-  pinsrw(xmm0, eax, 3);\n-  mulsd(xmm0, xmm0);\n-  testl(rsi, INT_MIN);\n-  jcc(Assembler::equal, L_2TAG_PACKET_51_0_2);\n-  movsd(xmm2, Address(tmp, 12560));\n-  xorpd(xmm0, xmm2);\n-\n-  bind(L_2TAG_PACKET_51_0_2);\n-  movl(rsi, Address(rsp, 24));\n-  movl(edx, 25);\n-  jmp(L_2TAG_PACKET_21_0_2);\n-\n-  bind(L_2TAG_PACKET_16_0_2);\n-  pextrw(ecx, xmm5, 3);\n-  pextrw(edx, xmm4, 3);\n-  movl(eax, -1);\n-  andl(ecx, 32752);\n-  subl(ecx, 16368);\n-  andl(edx, 32752);\n-  addl(edx, ecx);\n-  movl(ecx, -31);\n-  sarl(edx, 4);\n-  subl(ecx, edx);\n-  jcc(Assembler::lessEqual, L_2TAG_PACKET_52_0_2);\n-  cmpl(ecx, 20);\n-  jcc(Assembler::above, L_2TAG_PACKET_53_0_2);\n-  shll(eax);\n-\n-  bind(L_2TAG_PACKET_52_0_2);\n-  movdl(xmm0, eax);\n-  psllq(xmm0, 32);\n-  pand(xmm0, xmm5);\n-  subsd(xmm5, xmm0);\n-  addsd(xmm5, xmm1);\n-  mulsd(xmm0, xmm4);\n-  mulsd(xmm5, xmm4);\n-  addsd(xmm0, xmm5);\n-\n-  bind(L_2TAG_PACKET_53_0_2);\n-  movl(edx, 25);\n-  jmp(L_2TAG_PACKET_21_0_2);\n-\n-  bind(L_2TAG_PACKET_2_0_2);\n-  movzwl(ecx, Address(rsp, 22));\n-  movl(edx, INT_MIN);\n-  movdl(xmm1, edx);\n-  xorpd(xmm7, xmm7);\n-  paddd(xmm0, xmm4);\n-  psllq(xmm5, 32);\n-  movdl(edx, xmm0);\n-  psllq(xmm0, 29);\n-  paddq(xmm1, xmm3);\n-  pand(xmm5, xmm1);\n-  andl(ecx, 32752);\n-  cmpl(ecx, 16560);\n-  jcc(Assembler::below, L_2TAG_PACKET_3_0_2);\n-  pand(xmm0, xmm6);\n-  subsd(xmm3, xmm5);\n-  addl(eax, 16351);\n-  shrl(eax, 4);\n-  subl(eax, 1022);\n-  cvtsi2sdl(xmm7, eax);\n-  mulpd(xmm5, xmm0);\n-  movsd(xmm4, Address(tmp, 0));\n-  mulsd(xmm3, xmm0);\n-  movsd(xmm6, Address(tmp, 0));\n-  subsd(xmm5, xmm2);\n-  movsd(xmm1, Address(tmp, 8));\n-  pshufd(xmm2, xmm3, 68);\n-  unpcklpd(xmm5, xmm3);\n-  addsd(xmm3, xmm5);\n-  movsd(xmm0, Address(tmp, 8));\n-  andl(edx, 16760832);\n-  shrl(edx, 10);\n-  addpd(xmm7, Address(tmp, edx, Address::times_1, -3616));\n-  mulsd(xmm4, xmm5);\n-  mulsd(xmm0, xmm5);\n-  mulsd(xmm6, xmm2);\n-  mulsd(xmm1, xmm2);\n-  movdqu(xmm2, xmm5);\n-  mulsd(xmm4, xmm5);\n-  addsd(xmm5, xmm0);\n-  movdqu(xmm0, xmm7);\n-  addsd(xmm2, xmm3);\n-  addsd(xmm7, xmm5);\n-  mulsd(xmm6, xmm2);\n-  subsd(xmm0, xmm7);\n-  movdqu(xmm2, xmm7);\n-  addsd(xmm7, xmm4);\n-  addsd(xmm0, xmm5);\n-  subsd(xmm2, xmm7);\n-  addsd(xmm4, xmm2);\n-  pshufd(xmm2, xmm5, 238);\n-  movdqu(xmm5, xmm7);\n-  addsd(xmm7, xmm2);\n-  addsd(xmm4, xmm0);\n-  movdqu(xmm0, Address(tmp, 8272));\n-  subsd(xmm5, xmm7);\n-  addsd(xmm6, xmm4);\n-  movdqu(xmm4, xmm7);\n-  addsd(xmm5, xmm2);\n-  addsd(xmm7, xmm1);\n-  movdqu(xmm2, Address(tmp, 8336));\n-  subsd(xmm4, xmm7);\n-  addsd(xmm6, xmm5);\n-  addsd(xmm4, xmm1);\n-  pshufd(xmm5, xmm7, 238);\n-  movdqu(xmm1, xmm7);\n-  addsd(xmm7, xmm5);\n-  subsd(xmm1, xmm7);\n-  addsd(xmm1, xmm5);\n-  movdqu(xmm5, Address(tmp, 8352));\n-  pshufd(xmm3, xmm3, 68);\n-  addsd(xmm6, xmm4);\n-  addsd(xmm6, xmm1);\n-  movdqu(xmm1, Address(tmp, 8304));\n-  mulpd(xmm0, xmm3);\n-  mulpd(xmm2, xmm3);\n-  pshufd(xmm4, xmm3, 68);\n-  mulpd(xmm3, xmm3);\n-  addpd(xmm0, xmm1);\n-  addpd(xmm5, xmm2);\n-  mulsd(xmm4, xmm3);\n-  movsd(xmm2, Address(tmp, 16));\n-  mulpd(xmm3, xmm3);\n-  movsd(xmm1, Address(rsp, 16));\n-  movzwl(ecx, Address(rsp, 22));\n-  mulpd(xmm0, xmm4);\n-  pextrw(eax, xmm7, 3);\n-  mulpd(xmm5, xmm4);\n-  mulpd(xmm0, xmm3);\n-  movsd(xmm4, Address(tmp, 8376));\n-  pand(xmm2, xmm7);\n-  addsd(xmm5, xmm6);\n-  subsd(xmm7, xmm2);\n-  addpd(xmm5, xmm0);\n-  andl(eax, 32752);\n-  subl(eax, 16368);\n-  andl(ecx, 32752);\n-  cmpl(ecx, 32752);\n-  jcc(Assembler::equal, L_2TAG_PACKET_48_0_2);\n-  addl(ecx, eax);\n-  cmpl(ecx, 16576);\n-  jcc(Assembler::aboveEqual, L_2TAG_PACKET_54_0_2);\n-  pshufd(xmm0, xmm5, 238);\n-  pand(xmm4, xmm1);\n-  movdqu(xmm3, xmm1);\n-  addsd(xmm5, xmm0);\n-  subsd(xmm1, xmm4);\n-  xorpd(xmm6, xmm6);\n-  movl(edx, 17080);\n-  pinsrw(xmm6, edx, 3);\n-  addsd(xmm7, xmm5);\n-  mulsd(xmm4, xmm2);\n-  mulsd(xmm1, xmm2);\n-  movdqu(xmm5, xmm6);\n-  mulsd(xmm3, xmm7);\n-  addsd(xmm6, xmm4);\n-  addsd(xmm1, xmm3);\n-  movdqu(xmm7, Address(tmp, 12480));\n-  movdl(edx, xmm6);\n-  subsd(xmm6, xmm5);\n-  movdqu(xmm3, Address(tmp, 12496));\n-  movsd(xmm2, Address(tmp, 12512));\n-  subsd(xmm4, xmm6);\n-  movl(ecx, edx);\n-  andl(edx, 255);\n-  addl(edx, edx);\n-  movdqu(xmm5, Address(tmp, edx, Address::times_8, 8384));\n-  addsd(xmm4, xmm1);\n-  pextrw(edx, xmm6, 3);\n-  shrl(ecx, 8);\n-  movl(eax, ecx);\n-  shrl(ecx, 1);\n-  subl(eax, ecx);\n-  shll(ecx, 20);\n-  movdl(xmm6, ecx);\n-  pshufd(xmm0, xmm4, 68);\n-  pshufd(xmm1, xmm4, 68);\n-  mulpd(xmm0, xmm0);\n-  mulpd(xmm7, xmm1);\n-  pshufd(xmm6, xmm6, 17);\n-  mulsd(xmm2, xmm4);\n-  andl(edx, 32767);\n-  cmpl(edx, 16529);\n-  jcc(Assembler::above, L_2TAG_PACKET_14_0_2);\n-  mulsd(xmm0, xmm0);\n-  paddd(xmm5, xmm6);\n-  addpd(xmm3, xmm7);\n-  mulsd(xmm2, xmm5);\n-  pshufd(xmm6, xmm5, 238);\n-  mulpd(xmm0, xmm3);\n-  addsd(xmm2, xmm6);\n-  pshufd(xmm3, xmm0, 238);\n-  addl(eax, 1023);\n-  shll(eax, 20);\n-  orl(eax, rsi);\n-  movdl(xmm4, eax);\n-  mulsd(xmm0, xmm5);\n-  mulsd(xmm3, xmm5);\n-  addsd(xmm0, xmm2);\n-  psllq(xmm4, 32);\n-  addsd(xmm0, xmm3);\n-  movdqu(xmm1, xmm0);\n-  addsd(xmm0, xmm5);\n-  movl(rsi, Address(rsp, 24));\n-  mulsd(xmm0, xmm4);\n-  pextrw(eax, xmm0, 3);\n-  andl(eax, 32752);\n-  jcc(Assembler::equal, L_2TAG_PACKET_16_0_2);\n-  cmpl(eax, 32752);\n-  jcc(Assembler::equal, L_2TAG_PACKET_17_0_2);\n-\n-  bind(L_2TAG_PACKET_55_0_2);\n-  movsd(Address(rsp, 0), xmm0);\n-  fld_d(Address(rsp, 0));\n-  jmp(L_2TAG_PACKET_6_0_2);\n-\n-  bind(L_2TAG_PACKET_48_0_2);\n-  movl(rsi, Address(rsp, 24));\n-\n-  bind(L_2TAG_PACKET_56_0_2);\n-  movsd(xmm0, Address(rsp, 8));\n-  movsd(xmm1, Address(rsp, 16));\n-  addsd(xmm1, xmm1);\n-  xorpd(xmm2, xmm2);\n-  movl(eax, 49136);\n-  pinsrw(xmm2, eax, 3);\n-  addsd(xmm2, xmm0);\n-  pextrw(eax, xmm2, 3);\n-  cmpl(eax, 0);\n-  jcc(Assembler::notEqual, L_2TAG_PACKET_57_0_2);\n-  xorpd(xmm0, xmm0);\n-  movl(eax, 32760);\n-  pinsrw(xmm0, eax, 3);\n-  jmp(L_2TAG_PACKET_18_0_2);\n-\n-  bind(L_2TAG_PACKET_57_0_2);\n-  movdl(edx, xmm1);\n-  movdqu(xmm3, xmm1);\n-  psrlq(xmm3, 20);\n-  movdl(ecx, xmm3);\n-  orl(ecx, edx);\n-  jcc(Assembler::equal, L_2TAG_PACKET_58_0_2);\n-  addsd(xmm1, xmm1);\n-  movdqu(xmm0, xmm1);\n-  jmp(L_2TAG_PACKET_18_0_2);\n-\n-  bind(L_2TAG_PACKET_58_0_2);\n-  pextrw(eax, xmm0, 3);\n-  andl(eax, 32752);\n-  pextrw(edx, xmm1, 3);\n-  xorpd(xmm0, xmm0);\n-  subl(eax, 16368);\n-  xorl(eax, edx);\n-  testl(eax, 32768);\n-  jcc(Assembler::notEqual, L_2TAG_PACKET_18_0_2);\n-  movl(edx, 32752);\n-  pinsrw(xmm0, edx, 3);\n-  jmp(L_2TAG_PACKET_18_0_2);\n-\n-  bind(L_2TAG_PACKET_54_0_2);\n-  pextrw(eax, xmm1, 3);\n-  pextrw(ecx, xmm2, 3);\n-  xorl(eax, ecx);\n-  testl(eax, 32768);\n-  jcc(Assembler::equal, L_2TAG_PACKET_50_0_2);\n-  jmp(L_2TAG_PACKET_49_0_2);\n-\n-  bind(L_2TAG_PACKET_6_0_2);\n-  movl(tmp, Address(rsp, 64));\n-\n-}\n-#endif\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86_pow.cpp","additions":0,"deletions":3653,"binary":false,"changes":3653,"status":"deleted"},{"patch":"@@ -1,2203 +0,0 @@\n-\/*\n-* Copyright (c) 2016, 2021, Intel Corporation. All rights reserved.\n-* Intel Math Library (LIBM) Source Code\n-*\n-* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-*\n-* This code is free software; you can redistribute it and\/or modify it\n-* under the terms of the GNU General Public License version 2 only, as\n-* published by the Free Software Foundation.\n-*\n-* This code is distributed in the hope that it will be useful, but WITHOUT\n-* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-* FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-* version 2 for more details (a copy is included in the LICENSE file that\n-* accompanied this code).\n-*\n-* You should have received a copy of the GNU General Public License version\n-* 2 along with this work; if not, write to the Free Software Foundation,\n-* Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-*\n-* Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-* or visit www.oracle.com if you need additional information or have any\n-* questions.\n-*\n-*\/\n-\n-#include \"precompiled.hpp\"\n-#include \"asm\/assembler.hpp\"\n-#include \"asm\/assembler.inline.hpp\"\n-#include \"macroAssembler_x86.hpp\"\n-#include \"runtime\/stubRoutines.hpp\"\n-#include \"stubRoutines_x86.hpp\"\n-#include \"utilities\/globalDefinitions.hpp\"\n-\n-\/******************************************************************************\/\n-\/\/                     ALGORITHM DESCRIPTION - SIN()\n-\/\/                     ---------------------\n-\/\/\n-\/\/     1. RANGE REDUCTION\n-\/\/\n-\/\/     We perform an initial range reduction from X to r with\n-\/\/\n-\/\/          X =~= N * pi\/32 + r\n-\/\/\n-\/\/     so that |r| <= pi\/64 + epsilon. We restrict inputs to those\n-\/\/     where |N| <= 932560. Beyond this, the range reduction is\n-\/\/     insufficiently accurate. For extremely small inputs,\n-\/\/     denormalization can occur internally, impacting performance.\n-\/\/     This means that the main path is actually only taken for\n-\/\/     2^-252 <= |X| < 90112.\n-\/\/\n-\/\/     To avoid branches, we perform the range reduction to full\n-\/\/     accuracy each time.\n-\/\/\n-\/\/          X - N * (P_1 + P_2 + P_3)\n-\/\/\n-\/\/     where P_1 and P_2 are 32-bit numbers (so multiplication by N\n-\/\/     is exact) and P_3 is a 53-bit number. Together, these\n-\/\/     approximate pi well enough for all cases in the restricted\n-\/\/     range.\n-\/\/\n-\/\/     The main reduction sequence is:\n-\/\/\n-\/\/             y = 32\/pi * x\n-\/\/             N = integer(y)\n-\/\/     (computed by adding and subtracting off SHIFTER)\n-\/\/\n-\/\/             m_1 = N * P_1\n-\/\/             m_2 = N * P_2\n-\/\/             r_1 = x - m_1\n-\/\/             r = r_1 - m_2\n-\/\/     (this r can be used for most of the calculation)\n-\/\/\n-\/\/             c_1 = r_1 - r\n-\/\/             m_3 = N * P_3\n-\/\/             c_2 = c_1 - m_2\n-\/\/             c = c_2 - m_3\n-\/\/\n-\/\/     2. MAIN ALGORITHM\n-\/\/\n-\/\/     The algorithm uses a table lookup based on B = M * pi \/ 32\n-\/\/     where M = N mod 64. The stored values are:\n-\/\/       sigma             closest power of 2 to cos(B)\n-\/\/       C_hl              53-bit cos(B) - sigma\n-\/\/       S_hi + S_lo       2 * 53-bit sin(B)\n-\/\/\n-\/\/     The computation is organized as follows:\n-\/\/\n-\/\/          sin(B + r + c) = [sin(B) + sigma * r] +\n-\/\/                           r * (cos(B) - sigma) +\n-\/\/                           sin(B) * [cos(r + c) - 1] +\n-\/\/                           cos(B) * [sin(r + c) - r]\n-\/\/\n-\/\/     which is approximately:\n-\/\/\n-\/\/          [S_hi + sigma * r] +\n-\/\/          C_hl * r +\n-\/\/          S_lo + S_hi * [(cos(r) - 1) - r * c] +\n-\/\/          (C_hl + sigma) * [(sin(r) - r) + c]\n-\/\/\n-\/\/     and this is what is actually computed. We separate this sum\n-\/\/     into four parts:\n-\/\/\n-\/\/          hi + med + pols + corr\n-\/\/\n-\/\/     where\n-\/\/\n-\/\/          hi       = S_hi + sigma r\n-\/\/          med      = C_hl * r\n-\/\/          pols     = S_hi * (cos(r) - 1) + (C_hl + sigma) * (sin(r) - r)\n-\/\/          corr     = S_lo + c * ((C_hl + sigma) - S_hi * r)\n-\/\/\n-\/\/     3. POLYNOMIAL\n-\/\/\n-\/\/     The polynomial S_hi * (cos(r) - 1) + (C_hl + sigma) *\n-\/\/     (sin(r) - r) can be rearranged freely, since it is quite\n-\/\/     small, so we exploit parallelism to the fullest.\n-\/\/\n-\/\/          psc4       =   SC_4 * r_1\n-\/\/          msc4       =   psc4 * r\n-\/\/          r2         =   r * r\n-\/\/          msc2       =   SC_2 * r2\n-\/\/          r4         =   r2 * r2\n-\/\/          psc3       =   SC_3 + msc4\n-\/\/          psc1       =   SC_1 + msc2\n-\/\/          msc3       =   r4 * psc3\n-\/\/          sincospols =   psc1 + msc3\n-\/\/          pols       =   sincospols *\n-\/\/                         <S_hi * r^2 | (C_hl + sigma) * r^3>\n-\/\/\n-\/\/     4. CORRECTION TERM\n-\/\/\n-\/\/     This is where the \"c\" component of the range reduction is\n-\/\/     taken into account; recall that just \"r\" is used for most of\n-\/\/     the calculation.\n-\/\/\n-\/\/          -c   = m_3 - c_2\n-\/\/          -d   = S_hi * r - (C_hl + sigma)\n-\/\/          corr = -c * -d + S_lo\n-\/\/\n-\/\/     5. COMPENSATED SUMMATIONS\n-\/\/\n-\/\/     The two successive compensated summations add up the high\n-\/\/     and medium parts, leaving just the low parts to add up at\n-\/\/     the end.\n-\/\/\n-\/\/          rs        =  sigma * r\n-\/\/          res_int   =  S_hi + rs\n-\/\/          k_0       =  S_hi - res_int\n-\/\/          k_2       =  k_0 + rs\n-\/\/          med       =  C_hl * r\n-\/\/          res_hi    =  res_int + med\n-\/\/          k_1       =  res_int - res_hi\n-\/\/          k_3       =  k_1 + med\n-\/\/\n-\/\/     6. FINAL SUMMATION\n-\/\/\n-\/\/     We now add up all the small parts:\n-\/\/\n-\/\/          res_lo = pols(hi) + pols(lo) + corr + k_1 + k_3\n-\/\/\n-\/\/     Now the overall result is just:\n-\/\/\n-\/\/          res_hi + res_lo\n-\/\/\n-\/\/     7. SMALL ARGUMENTS\n-\/\/\n-\/\/     If |x| < SNN (SNN meaning the smallest normal number), we\n-\/\/     simply perform 0.1111111 cdots 1111 * x. For SNN <= |x|, we\n-\/\/     do 2^-55 * (2^55 * x - x).\n-\/\/\n-\/\/ Special cases:\n-\/\/  sin(NaN) = quiet NaN, and raise invalid exception\n-\/\/  sin(INF) = NaN and raise invalid exception\n-\/\/  sin(+\/-0) = +\/-0\n-\/\/\n-\/******************************************************************************\/\n-\n-#ifdef _LP64\n-\/\/ The 64 bit code is at most SSE2 compliant\n-ATTRIBUTE_ALIGNED(8) juint _ALL_ONES[] =\n-{\n-    0xffffffffUL, 0x3fefffffUL\n-};\n-\n-void MacroAssembler::fast_sin(XMMRegister xmm0, XMMRegister xmm1, XMMRegister xmm2, XMMRegister xmm3,\n-                              XMMRegister xmm4, XMMRegister xmm5, XMMRegister xmm6, XMMRegister xmm7,\n-                              Register eax, Register ebx, Register ecx, Register edx, Register tmp) {\n-  Label L_2TAG_PACKET_0_0_1, L_2TAG_PACKET_1_0_1, L_2TAG_PACKET_2_0_1, L_2TAG_PACKET_3_0_1;\n-  Label L_2TAG_PACKET_4_0_1, L_2TAG_PACKET_5_0_1, L_2TAG_PACKET_6_0_1, L_2TAG_PACKET_7_0_1;\n-  Label L_2TAG_PACKET_8_0_1, L_2TAG_PACKET_9_0_1, L_2TAG_PACKET_10_0_1, L_2TAG_PACKET_11_0_1;\n-  Label L_2TAG_PACKET_13_0_1, L_2TAG_PACKET_14_0_1;\n-  Label L_2TAG_PACKET_12_0_1, B1_4;\n-\n-  assert_different_registers(tmp, eax, ebx, ecx, edx);\n-\n-  address ALL_ONES = (address)_ALL_ONES;\n-\n-  push(rbx);\n-  subq(rsp, 16);\n-  movsd(Address(rsp, 8), xmm0);\n-  movl(eax, Address(rsp, 12));\n-  movq(xmm1, ExternalAddress(PI32INV), tmp \/*rscratch*\/); \/\/0x6dc9c883UL, 0x40245f30UL\n-  movq(xmm2, ExternalAddress(SHIFTER), tmp \/*rscratch*\/); \/\/0x00000000UL, 0x43380000UL\n-  andl(eax, 2147418112);\n-  subl(eax, 808452096);\n-  cmpl(eax, 281346048);\n-  jcc(Assembler::above, L_2TAG_PACKET_0_0_1);\n-  mulsd(xmm1, xmm0);\n-  movdqu(xmm5, ExternalAddress(ONEHALF), tmp \/*rscratch*\/); \/\/0x00000000UL, 0x3fe00000UL, 0x00000000UL, 0x3fe00000UL\n-  movq(xmm4, ExternalAddress(SIGN_MASK), tmp \/*rscratch*\/); \/\/0x00000000UL, 0x80000000UL\n-  pand(xmm4, xmm0);\n-  por(xmm5, xmm4);\n-  addpd(xmm1, xmm5);\n-  cvttsd2sil(edx, xmm1);\n-  cvtsi2sdl(xmm1, edx);\n-  movdqu(xmm6, ExternalAddress(P_2), tmp \/*rscratch*\/); \/\/0x1a600000UL, 0x3d90b461UL, 0x1a600000UL, 0x3d90b461UL\n-  mov64(r8, 0x3fb921fb54400000);\n-  movdq(xmm3, r8);\n-  movdqu(xmm5, ExternalAddress(SC_4), tmp \/*rscratch*\/); \/\/0xa556c734UL, 0x3ec71de3UL, 0x1a01a01aUL, 0x3efa01a0UL\n-  pshufd(xmm4, xmm0, 68);\n-  mulsd(xmm3, xmm1);\n-  if (VM_Version::supports_sse3()) {\n-    movddup(xmm1, xmm1);\n-  } else {\n-    movlhps(xmm1, xmm1);\n-  }\n-  andl(edx, 63);\n-  shll(edx, 5);\n-  lea(rax, ExternalAddress(Ctable));\n-  addq(rax, rdx);\n-  mulpd(xmm6, xmm1);\n-  mulsd(xmm1, ExternalAddress(P_3), tmp \/*rscratch*\/); \/\/0x2e037073UL, 0x3b63198aUL\n-  subsd(xmm4, xmm3);\n-  movq(xmm7, Address(rax, 8));\n-  subsd(xmm0, xmm3);\n-  if (VM_Version::supports_sse3()) {\n-    movddup(xmm3, xmm4);\n-  } else {\n-    movdqu(xmm3, xmm4);\n-    movlhps(xmm3, xmm3);\n-  }\n-  subsd(xmm4, xmm6);\n-  pshufd(xmm0, xmm0, 68);\n-  movdqu(xmm2, Address(rax, 0));\n-  mulpd(xmm5, xmm0);\n-  subpd(xmm0, xmm6);\n-  mulsd(xmm7, xmm4);\n-  subsd(xmm3, xmm4);\n-  mulpd(xmm5, xmm0);\n-  mulpd(xmm0, xmm0);\n-  subsd(xmm3, xmm6);\n-  movdqu(xmm6, ExternalAddress(SC_2), tmp \/*rscratch*\/); \/\/0x11111111UL, 0x3f811111UL, 0x55555555UL, 0x3fa55555UL\n-  subsd(xmm1, xmm3);\n-  movq(xmm3, Address(rax, 24));\n-  addsd(xmm2, xmm3);\n-  subsd(xmm7, xmm2);\n-  mulsd(xmm2, xmm4);\n-  mulpd(xmm6, xmm0);\n-  mulsd(xmm3, xmm4);\n-  mulpd(xmm2, xmm0);\n-  mulpd(xmm0, xmm0);\n-  addpd(xmm5, ExternalAddress(SC_3), tmp \/*rscratch*\/); \/\/0x1a01a01aUL, 0xbf2a01a0UL, 0x16c16c17UL, 0xbf56c16cUL\n-  mulsd(xmm4, Address(rax, 0));\n-  addpd(xmm6, ExternalAddress(SC_1), tmp \/*rscratch*\/); \/\/0x55555555UL, 0xbfc55555UL, 0x00000000UL, 0xbfe00000UL\n-  mulpd(xmm5, xmm0);\n-  movdqu(xmm0, xmm3);\n-  addsd(xmm3, Address(rax, 8));\n-  mulpd(xmm1, xmm7);\n-  movdqu(xmm7, xmm4);\n-  addsd(xmm4, xmm3);\n-  addpd(xmm6, xmm5);\n-  movq(xmm5, Address(rax, 8));\n-  subsd(xmm5, xmm3);\n-  subsd(xmm3, xmm4);\n-  addsd(xmm1, Address(rax, 16));\n-  mulpd(xmm6, xmm2);\n-  addsd(xmm5, xmm0);\n-  addsd(xmm3, xmm7);\n-  addsd(xmm1, xmm5);\n-  addsd(xmm1, xmm3);\n-  addsd(xmm1, xmm6);\n-  unpckhpd(xmm6, xmm6);\n-  movdqu(xmm0, xmm4);\n-  addsd(xmm1, xmm6);\n-  addsd(xmm0, xmm1);\n-  jmp(B1_4);\n-\n-  bind(L_2TAG_PACKET_0_0_1);\n-  jcc(Assembler::greater, L_2TAG_PACKET_1_0_1);\n-  shrl(eax, 20);\n-  cmpl(eax, 3325);\n-  jcc(Assembler::notEqual, L_2TAG_PACKET_2_0_1);\n-  mulsd(xmm0, ExternalAddress(ALL_ONES), tmp \/*rscratch*\/); \/\/0xffffffffUL, 0x3fefffffUL\n-  jmp(B1_4);\n-\n-  bind(L_2TAG_PACKET_2_0_1);\n-  movq(xmm3, ExternalAddress(TWO_POW_55), tmp \/*rscratch*\/); \/\/0x00000000UL, 0x43600000UL\n-  mulsd(xmm3, xmm0);\n-  subsd(xmm3, xmm0);\n-  mulsd(xmm3, ExternalAddress(TWO_POW_M55), tmp \/*rscratch*\/); \/\/0x00000000UL, 0x3c800000UL\n-  jmp(B1_4);\n-\n-  bind(L_2TAG_PACKET_1_0_1);\n-  pextrw(eax, xmm0, 3);\n-  andl(eax, 32752);\n-  cmpl(eax, 32752);\n-  jcc(Assembler::equal, L_2TAG_PACKET_3_0_1);\n-  pextrw(ecx, xmm0, 3);\n-  andl(ecx, 32752);\n-  subl(ecx, 16224);\n-  shrl(ecx, 7);\n-  andl(ecx, 65532);\n-  lea(r11, ExternalAddress(PI_INV_TABLE));\n-  addq(rcx, r11);\n-  movdq(rax, xmm0);\n-  movl(r10, Address(rcx, 20));\n-  movl(r8, Address(rcx, 24));\n-  movl(edx, eax);\n-  shrq(rax, 21);\n-  orl(eax, INT_MIN);\n-  shrl(eax, 11);\n-  movl(r9, r10);\n-  imulq(r10, rdx);\n-  imulq(r9, rax);\n-  imulq(r8, rax);\n-  movl(rsi, Address(rcx, 16));\n-  movl(rdi, Address(rcx, 12));\n-  movl(r11, r10);\n-  shrq(r10, 32);\n-  addq(r9, r10);\n-  addq(r11, r8);\n-  movl(r8, r11);\n-  shrq(r11, 32);\n-  addq(r9, r11);\n-  movl(r10, rsi);\n-  imulq(rsi, rdx);\n-  imulq(r10, rax);\n-  movl(r11, rdi);\n-  imulq(rdi, rdx);\n-  movl(ebx, rsi);\n-  shrq(rsi, 32);\n-  addq(r9, rbx);\n-  movl(ebx, r9);\n-  shrq(r9, 32);\n-  addq(r10, rsi);\n-  addq(r10, r9);\n-  shlq(rbx, 32);\n-  orq(r8, rbx);\n-  imulq(r11, rax);\n-  movl(r9, Address(rcx, 8));\n-  movl(rsi, Address(rcx, 4));\n-  movl(ebx, rdi);\n-  shrq(rdi, 32);\n-  addq(r10, rbx);\n-  movl(ebx, r10);\n-  shrq(r10, 32);\n-  addq(r11, rdi);\n-  addq(r11, r10);\n-  movq(rdi, r9);\n-  imulq(r9, rdx);\n-  imulq(rdi, rax);\n-  movl(r10, r9);\n-  shrq(r9, 32);\n-  addq(r11, r10);\n-  movl(r10, r11);\n-  shrq(r11, 32);\n-  addq(rdi, r9);\n-  addq(rdi, r11);\n-  movq(r9, rsi);\n-  imulq(rsi, rdx);\n-  imulq(r9, rax);\n-  shlq(r10, 32);\n-  orq(r10, rbx);\n-  movl(eax, Address(rcx, 0));\n-  movl(r11, rsi);\n-  shrq(rsi, 32);\n-  addq(rdi, r11);\n-  movl(r11, rdi);\n-  shrq(rdi, 32);\n-  addq(r9, rsi);\n-  addq(r9, rdi);\n-  imulq(rdx, rax);\n-  pextrw(ebx, xmm0, 3);\n-  lea(rdi, ExternalAddress(PI_INV_TABLE));\n-  subq(rcx, rdi);\n-  addl(ecx, ecx);\n-  addl(ecx, ecx);\n-  addl(ecx, ecx);\n-  addl(ecx, 19);\n-  movl(rsi, 32768);\n-  andl(rsi, ebx);\n-  shrl(ebx, 4);\n-  andl(ebx, 2047);\n-  subl(ebx, 1023);\n-  subl(ecx, ebx);\n-  addq(r9, rdx);\n-  movl(edx, ecx);\n-  addl(edx, 32);\n-  cmpl(ecx, 1);\n-  jcc(Assembler::less, L_2TAG_PACKET_4_0_1);\n-  negl(ecx);\n-  addl(ecx, 29);\n-  shll(r9);\n-  movl(rdi, r9);\n-  andl(r9, 536870911);\n-  testl(r9, 268435456);\n-  jcc(Assembler::notEqual, L_2TAG_PACKET_5_0_1);\n-  shrl(r9);\n-  movl(ebx, 0);\n-  shlq(r9, 32);\n-  orq(r9, r11);\n-\n-  bind(L_2TAG_PACKET_6_0_1);\n-\n-  bind(L_2TAG_PACKET_7_0_1);\n-\n-  cmpq(r9, 0);\n-  jcc(Assembler::equal, L_2TAG_PACKET_8_0_1);\n-\n-  bind(L_2TAG_PACKET_9_0_1);\n-  bsrq(r11, r9);\n-  movl(ecx, 29);\n-  subl(ecx, r11);\n-  jcc(Assembler::lessEqual, L_2TAG_PACKET_10_0_1);\n-  shlq(r9);\n-  movq(rax, r10);\n-  shlq(r10);\n-  addl(edx, ecx);\n-  negl(ecx);\n-  addl(ecx, 64);\n-  shrq(rax);\n-  shrq(r8);\n-  orq(r9, rax);\n-  orq(r10, r8);\n-\n-  bind(L_2TAG_PACKET_11_0_1);\n-  cvtsi2sdq(xmm0, r9);\n-  shrq(r10, 1);\n-  cvtsi2sdq(xmm3, r10);\n-  xorpd(xmm4, xmm4);\n-  shll(edx, 4);\n-  negl(edx);\n-  addl(edx, 16368);\n-  orl(edx, rsi);\n-  xorl(edx, ebx);\n-  pinsrw(xmm4, edx, 3);\n-  movq(xmm2, ExternalAddress(PI_4),     tmp \/*rscratch*\/); \/\/0x40000000UL, 0x3fe921fbUL, 0x18469899UL, 0x3e64442dUL\n-  movq(xmm6, ExternalAddress(PI_4 + 8), tmp \/*rscratch*\/); \/\/0x3fe921fbUL, 0x18469899UL, 0x3e64442dUL\n-  xorpd(xmm5, xmm5);\n-  subl(edx, 1008);\n-  pinsrw(xmm5, edx, 3);\n-  mulsd(xmm0, xmm4);\n-  shll(rsi, 16);\n-  sarl(rsi, 31);\n-  mulsd(xmm3, xmm5);\n-  movdqu(xmm1, xmm0);\n-  mulsd(xmm0, xmm2);\n-  shrl(rdi, 29);\n-  addsd(xmm1, xmm3);\n-  mulsd(xmm3, xmm2);\n-  addl(rdi, rsi);\n-  xorl(rdi, rsi);\n-  mulsd(xmm6, xmm1);\n-  movl(eax, rdi);\n-  addsd(xmm6, xmm3);\n-  movdqu(xmm2, xmm0);\n-  addsd(xmm0, xmm6);\n-  subsd(xmm2, xmm0);\n-  addsd(xmm6, xmm2);\n-\n-  bind(L_2TAG_PACKET_12_0_1);\n-  movq(xmm1, ExternalAddress(PI32INV), tmp \/*rscratch*\/);    \/\/0x6dc9c883UL, 0x40245f30UL\n-  mulsd(xmm1, xmm0);\n-  movq(xmm5, ExternalAddress(ONEHALF), tmp \/*rscratch*\/);    \/\/0x00000000UL, 0x3fe00000UL, 0x00000000UL, 0x3fe00000UL\n-  movq(xmm4, ExternalAddress(SIGN_MASK), tmp \/*rscratch*\/);  \/\/0x00000000UL, 0x80000000UL\n-  pand(xmm4, xmm0);\n-  por(xmm5, xmm4);\n-  addpd(xmm1, xmm5);\n-  cvttsd2sil(edx, xmm1);\n-  cvtsi2sdl(xmm1, edx);\n-  movq(xmm3, ExternalAddress(P_1), tmp \/*rscratch*\/);      \/\/0x54400000UL, 0x3fb921fbUL\n-  movdqu(xmm2, ExternalAddress(P_2), tmp \/*rscratch*\/);    \/\/0x1a600000UL, 0x3d90b461UL, 0x1a600000UL, 0x3d90b461UL\n-  mulsd(xmm3, xmm1);\n-  unpcklpd(xmm1, xmm1);\n-  shll(eax, 3);\n-  addl(edx, 1865216);\n-  movdqu(xmm4, xmm0);\n-  addl(edx, eax);\n-  andl(edx, 63);\n-  movdqu(xmm5, ExternalAddress(SC_4), tmp \/*rscratch*\/);    \/\/0x54400000UL, 0x3fb921fbUL\n-  lea(rax, ExternalAddress(Ctable));\n-  shll(edx, 5);\n-  addq(rax, rdx);\n-  mulpd(xmm2, xmm1);\n-  subsd(xmm0, xmm3);\n-  mulsd(xmm1, ExternalAddress(P_3), tmp \/*rscratch*\/);    \/\/0x2e037073UL, 0x3b63198aUL\n-  subsd(xmm4, xmm3);\n-  movq(xmm7, Address(rax, 8));\n-  unpcklpd(xmm0, xmm0);\n-  movdqu(xmm3, xmm4);\n-  subsd(xmm4, xmm2);\n-  mulpd(xmm5, xmm0);\n-  subpd(xmm0, xmm2);\n-  mulsd(xmm7, xmm4);\n-  subsd(xmm3, xmm4);\n-  mulpd(xmm5, xmm0);\n-  mulpd(xmm0, xmm0);\n-  subsd(xmm3, xmm2);\n-  movdqu(xmm2, Address(rax, 0));\n-  subsd(xmm1, xmm3);\n-  movq(xmm3, Address(rax, 24));\n-  addsd(xmm2, xmm3);\n-  subsd(xmm7, xmm2);\n-  subsd(xmm1, xmm6);\n-  movdqu(xmm6, ExternalAddress(SC_2), tmp \/*rscratch*\/);    \/\/0x11111111UL, 0x3f811111UL, 0x55555555UL, 0x3fa55555UL\n-  mulsd(xmm2, xmm4);\n-  mulpd(xmm6, xmm0);\n-  mulsd(xmm3, xmm4);\n-  mulpd(xmm2, xmm0);\n-  mulpd(xmm0, xmm0);\n-  addpd(xmm5, ExternalAddress(SC_3), tmp \/*rscratch*\/);    \/\/0x1a01a01aUL, 0xbf2a01a0UL, 0x16c16c17UL, 0xbf56c16cUL\n-  mulsd(xmm4, Address(rax, 0));\n-  addpd(xmm6, ExternalAddress(SC_1), tmp \/*rscratch*\/);    \/\/0x55555555UL, 0xbfc55555UL, 0x00000000UL, 0xbfe00000UL\n-  mulpd(xmm5, xmm0);\n-  movdqu(xmm0, xmm3);\n-  addsd(xmm3, Address(rax, 8));\n-  mulpd(xmm1, xmm7);\n-  movdqu(xmm7, xmm4);\n-  addsd(xmm4, xmm3);\n-  addpd(xmm6, xmm5);\n-  movq(xmm5, Address(rax, 8));\n-  subsd(xmm5, xmm3);\n-  subsd(xmm3, xmm4);\n-  addsd(xmm1, Address(rax, 16));\n-  mulpd(xmm6, xmm2);\n-  addsd(xmm5, xmm0);\n-  addsd(xmm3, xmm7);\n-  addsd(xmm1, xmm5);\n-  addsd(xmm1, xmm3);\n-  addsd(xmm1, xmm6);\n-  unpckhpd(xmm6, xmm6);\n-  movdqu(xmm0, xmm4);\n-  addsd(xmm1, xmm6);\n-  addsd(xmm0, xmm1);\n-  jmp(B1_4);\n-\n-  bind(L_2TAG_PACKET_8_0_1);\n-  addl(edx, 64);\n-  movq(r9, r10);\n-  movq(r10, r8);\n-  movl(r8, 0);\n-  cmpq(r9, 0);\n-  jcc(Assembler::notEqual, L_2TAG_PACKET_9_0_1);\n-  addl(edx, 64);\n-  movq(r9, r10);\n-  movq(r10, r8);\n-  cmpq(r9, 0);\n-  jcc(Assembler::notEqual, L_2TAG_PACKET_9_0_1);\n-  xorpd(xmm0, xmm0);\n-  xorpd(xmm6, xmm6);\n-  jmp(L_2TAG_PACKET_12_0_1);\n-\n-  bind(L_2TAG_PACKET_10_0_1);\n-  jcc(Assembler::equal, L_2TAG_PACKET_11_0_1);\n-  negl(ecx);\n-  shrq(r10);\n-  movq(rax, r9);\n-  shrq(r9);\n-  subl(edx, ecx);\n-  negl(ecx);\n-  addl(ecx, 64);\n-  shlq(rax);\n-  orq(r10, rax);\n-  jmp(L_2TAG_PACKET_11_0_1);\n-\n-  bind(L_2TAG_PACKET_4_0_1);\n-  negl(ecx);\n-  shlq(r9, 32);\n-  orq(r9, r11);\n-  shlq(r9);\n-  movq(rdi, r9);\n-  testl(r9, INT_MIN);\n-  jcc(Assembler::notEqual, L_2TAG_PACKET_13_0_1);\n-  shrl(r9);\n-  movl(ebx, 0);\n-  shrq(rdi, 3);\n-  jmp(L_2TAG_PACKET_7_0_1);\n-\n-  bind(L_2TAG_PACKET_5_0_1);\n-  shrl(r9);\n-  movl(ebx, 536870912);\n-  shrl(ebx);\n-  shlq(r9, 32);\n-  orq(r9, r11);\n-  shlq(rbx, 32);\n-  addl(rdi, 536870912);\n-  movl(rcx, 0);\n-  movl(r11, 0);\n-  subq(rcx, r8);\n-  sbbq(r11, r10);\n-  sbbq(rbx, r9);\n-  movq(r8, rcx);\n-  movq(r10, r11);\n-  movq(r9, rbx);\n-  movl(ebx, 32768);\n-  jmp(L_2TAG_PACKET_6_0_1);\n-\n-  bind(L_2TAG_PACKET_13_0_1);\n-  shrl(r9);\n-  mov64(rbx, 0x100000000);\n-  shrq(rbx);\n-  movl(rcx, 0);\n-  movl(r11, 0);\n-  subq(rcx, r8);\n-  sbbq(r11, r10);\n-  sbbq(rbx, r9);\n-  movq(r8, rcx);\n-  movq(r10, r11);\n-  movq(r9, rbx);\n-  movl(ebx, 32768);\n-  shrq(rdi, 3);\n-  addl(rdi, 536870912);\n-  jmp(L_2TAG_PACKET_7_0_1);\n-\n-  bind(L_2TAG_PACKET_3_0_1);\n-  movq(xmm0, Address(rsp, 8));\n-  mulsd(xmm0, ExternalAddress(NEG_ZERO), tmp \/*rscratch*\/);    \/\/0x00000000UL, 0x80000000UL\n-  movq(Address(rsp, 0), xmm0);\n-\n-  bind(L_2TAG_PACKET_14_0_1);\n-\n-  bind(B1_4);\n-  addq(rsp, 16);\n-  pop(rbx);\n-}\n-#else\n-\/\/ The 32 bit code is at most SSE2 compliant\n-ATTRIBUTE_ALIGNED(8) juint _zero_none[] =\n-{\n-    0x00000000UL, 0x00000000UL, 0x00000000UL, 0xbff00000UL\n-};\n-\n-ATTRIBUTE_ALIGNED(4) juint __4onpi_d[] =\n-{\n-    0x6dc9c883UL, 0x3ff45f30UL\n-};\n-\n-ATTRIBUTE_ALIGNED(4) juint _TWO_32H[] =\n-{\n-    0x00000000UL, 0x41f80000UL\n-};\n-\n-ATTRIBUTE_ALIGNED(4) juint _pi04_3d[] =\n-{\n-    0x54442d00UL, 0x3fe921fbUL, 0x98cc5180UL, 0x3ce84698UL, 0xcbb5bf6cUL,\n-    0xb9dfc8f8UL\n-};\n-\n-ATTRIBUTE_ALIGNED(4) juint _pi04_5d[] =\n-{\n-    0x54400000UL, 0x3fe921fbUL, 0x1a600000UL, 0x3dc0b461UL, 0x2e000000UL,\n-    0x3b93198aUL, 0x25200000UL, 0x396b839aUL, 0x533e63a0UL, 0x37027044UL\n-};\n-\n-ATTRIBUTE_ALIGNED(4) juint _SCALE[] =\n-{\n-    0x00000000UL, 0x32600000UL\n-};\n-\n-ATTRIBUTE_ALIGNED(4) juint _zeros[] =\n-{\n-    0x00000000UL, 0x00000000UL, 0x00000000UL, 0x80000000UL\n-};\n-\n-ATTRIBUTE_ALIGNED(4) juint _pi04_2d[] =\n-{\n-    0x54400000UL, 0x3fe921fbUL, 0x1a626331UL, 0x3dc0b461UL\n-};\n-\n-ATTRIBUTE_ALIGNED(4) juint _TWO_12H[] =\n-{\n-    0x00000000UL, 0x40b80000UL\n-};\n-\n-ATTRIBUTE_ALIGNED(2) jushort __4onpi_31l[] =\n-{\n-    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x836e, 0xa2f9,\n-    0x40d8, 0x0000, 0x0000, 0x0000, 0x2a50, 0x9c88, 0x40b7, 0x0000, 0x0000, 0x0000,\n-    0xabe8, 0xfe13, 0x4099, 0x0000, 0x0000, 0x0000, 0x6ee0, 0xfa9a, 0x4079, 0x0000,\n-    0x0000, 0x0000, 0x9580, 0xdb62, 0x4058, 0x0000, 0x0000, 0x0000, 0x1c82, 0xc9e2,\n-    0x403d, 0x0000, 0x0000, 0x0000, 0xb1c0, 0xff28, 0x4019, 0x0000, 0x0000, 0x0000,\n-    0xef14, 0xaf7a, 0x3ffe, 0x0000, 0x0000, 0x0000, 0x48dc, 0xc36e, 0x3fdf, 0x0000,\n-    0x0000, 0x0000, 0x3740, 0xe909, 0x3fbe, 0x0000, 0x0000, 0x0000, 0x924a, 0xb801,\n-    0x3fa2, 0x0000, 0x0000, 0x0000, 0x3a32, 0xdd41, 0x3f83, 0x0000, 0x0000, 0x0000,\n-    0x8778, 0x873f, 0x3f62, 0x0000, 0x0000, 0x0000, 0x1298, 0xb1cb, 0x3f44, 0x0000,\n-    0x0000, 0x0000, 0xa208, 0x9cfb, 0x3f26, 0x0000, 0x0000, 0x0000, 0xbaec, 0xd7d4,\n-    0x3f06, 0x0000, 0x0000, 0x0000, 0xd338, 0x8909, 0x3ee7, 0x0000, 0x0000, 0x0000,\n-    0x68b8, 0xe04d, 0x3ec7, 0x0000, 0x0000, 0x0000, 0x4e64, 0xdf90, 0x3eaa, 0x0000,\n-    0x0000, 0x0000, 0xc1a8, 0xeb1c, 0x3e89, 0x0000, 0x0000, 0x0000, 0x2720, 0xce7d,\n-    0x3e6a, 0x0000, 0x0000, 0x0000, 0x77b8, 0x8bf1, 0x3e4b, 0x0000, 0x0000, 0x0000,\n-    0xec7e, 0xe4a0, 0x3e2e, 0x0000, 0x0000, 0x0000, 0xffbc, 0xf12f, 0x3e0f, 0x0000,\n-    0x0000, 0x0000, 0xfdc0, 0xb301, 0x3deb, 0x0000, 0x0000, 0x0000, 0xc5ac, 0x9788,\n-    0x3dd1, 0x0000, 0x0000, 0x0000, 0x47da, 0x829b, 0x3db2, 0x0000, 0x0000, 0x0000,\n-    0xd9e4, 0xa6cf, 0x3d93, 0x0000, 0x0000, 0x0000, 0x36e8, 0xf961, 0x3d73, 0x0000,\n-    0x0000, 0x0000, 0xf668, 0xf463, 0x3d54, 0x0000, 0x0000, 0x0000, 0x5168, 0xf2ff,\n-    0x3d35, 0x0000, 0x0000, 0x0000, 0x758e, 0xea4f, 0x3d17, 0x0000, 0x0000, 0x0000,\n-    0xf17a, 0xebe5, 0x3cf8, 0x0000, 0x0000, 0x0000, 0x9cfa, 0x9e83, 0x3cd9, 0x0000,\n-    0x0000, 0x0000, 0xa4ba, 0xe294, 0x3cba, 0x0000, 0x0000, 0x0000, 0xd7ec, 0x9afe,\n-    0x3c9a, 0x0000, 0x0000, 0x0000, 0xae80, 0x8fc6, 0x3c79, 0x0000, 0x0000, 0x0000,\n-    0x3304, 0x8560, 0x3c5c, 0x0000, 0x0000, 0x0000, 0x6d70, 0xdf8f, 0x3c3b, 0x0000,\n-    0x0000, 0x0000, 0x3ef0, 0xafc3, 0x3c1e, 0x0000, 0x0000, 0x0000, 0xd0d8, 0x826b,\n-    0x3bfe, 0x0000, 0x0000, 0x0000, 0x1c80, 0xed4f, 0x3bdd, 0x0000, 0x0000, 0x0000,\n-    0x730c, 0xb0af, 0x3bc1, 0x0000, 0x0000, 0x0000, 0x6660, 0xc219, 0x3ba2, 0x0000,\n-    0x0000, 0x0000, 0x940c, 0xabe2, 0x3b83, 0x0000, 0x0000, 0x0000, 0xdffc, 0x8408,\n-    0x3b64, 0x0000, 0x0000, 0x0000, 0x6b98, 0xc402, 0x3b45, 0x0000, 0x0000, 0x0000,\n-    0x1818, 0x9cc4, 0x3b26, 0x0000, 0x0000, 0x0000, 0x5390, 0xaab6, 0x3b05, 0x0000,\n-    0x0000, 0x0000, 0xb070, 0xd464, 0x3ae9, 0x0000, 0x0000, 0x0000, 0x231a, 0x9ef0,\n-    0x3aca, 0x0000, 0x0000, 0x0000, 0x0670, 0xd1f1, 0x3aaa, 0x0000, 0x0000, 0x0000,\n-    0x7738, 0xd9f3, 0x3a8a, 0x0000, 0x0000, 0x0000, 0xa834, 0x8092, 0x3a6c, 0x0000,\n-    0x0000, 0x0000, 0xb45c, 0xce23, 0x3a4d, 0x0000, 0x0000, 0x0000, 0x36e8, 0xb0e5,\n-    0x3a2d, 0x0000, 0x0000, 0x0000, 0xd156, 0xaf44, 0x3a10, 0x0000, 0x0000, 0x0000,\n-    0x9f52, 0x8c82, 0x39f1, 0x0000, 0x0000, 0x0000, 0x829c, 0xff83, 0x39d1, 0x0000,\n-    0x0000, 0x0000, 0x7d06, 0xefc6, 0x39b3, 0x0000, 0x0000, 0x0000, 0x93e0, 0xb0b7,\n-    0x3992, 0x0000, 0x0000, 0x0000, 0xedde, 0xc193, 0x3975, 0x0000, 0x0000, 0x0000,\n-    0xbbc0, 0xcf49, 0x3952, 0x0000, 0x0000, 0x0000, 0xbdf0, 0xd63c, 0x3937, 0x0000,\n-    0x0000, 0x0000, 0x1f34, 0x9f3a, 0x3918, 0x0000, 0x0000, 0x0000, 0x3f8e, 0xe579,\n-    0x38f9, 0x0000, 0x0000, 0x0000, 0x90c8, 0xc3f8, 0x38d9, 0x0000, 0x0000, 0x0000,\n-    0x48c0, 0xf8f8, 0x38b7, 0x0000, 0x0000, 0x0000, 0xed56, 0xafa6, 0x389c, 0x0000,\n-    0x0000, 0x0000, 0x8218, 0xb969, 0x387d, 0x0000, 0x0000, 0x0000, 0x1852, 0xec57,\n-    0x385e, 0x0000, 0x0000, 0x0000, 0x670c, 0xd674, 0x383e, 0x0000, 0x0000, 0x0000,\n-    0xad40, 0xc2c4, 0x3820, 0x0000, 0x0000, 0x0000, 0x2e80, 0xa696, 0x3801, 0x0000,\n-    0x0000, 0x0000, 0xd800, 0xc467, 0x37dc, 0x0000, 0x0000, 0x0000, 0x3c72, 0xc5ae,\n-    0x37c3, 0x0000, 0x0000, 0x0000, 0xb006, 0xac69, 0x37a4, 0x0000, 0x0000, 0x0000,\n-    0x34a0, 0x8cdf, 0x3782, 0x0000, 0x0000, 0x0000, 0x9ed2, 0xd25e, 0x3766, 0x0000,\n-    0x0000, 0x0000, 0x6fec, 0xaaaa, 0x3747, 0x0000, 0x0000, 0x0000, 0x6040, 0xfb5c,\n-    0x3726, 0x0000, 0x0000, 0x0000, 0x764c, 0xa3fc, 0x3708, 0x0000, 0x0000, 0x0000,\n-    0xb254, 0x954e, 0x36e9, 0x0000, 0x0000, 0x0000, 0x3e1c, 0xf5dc, 0x36ca, 0x0000,\n-    0x0000, 0x0000, 0x7b06, 0xc635, 0x36ac, 0x0000, 0x0000, 0x0000, 0xa8ba, 0xd738,\n-    0x368d, 0x0000, 0x0000, 0x0000, 0x06cc, 0xb24e, 0x366d, 0x0000, 0x0000, 0x0000,\n-    0x7108, 0xac76, 0x364f, 0x0000, 0x0000, 0x0000, 0x2324, 0xa7cb, 0x3630, 0x0000,\n-    0x0000, 0x0000, 0xac40, 0xef15, 0x360f, 0x0000, 0x0000, 0x0000, 0xae46, 0xd516,\n-    0x35f2, 0x0000, 0x0000, 0x0000, 0x615e, 0xe003, 0x35d3, 0x0000, 0x0000, 0x0000,\n-    0x0cf0, 0xefe7, 0x35b1, 0x0000, 0x0000, 0x0000, 0xfb50, 0xf98c, 0x3595, 0x0000,\n-    0x0000, 0x0000, 0x0abc, 0xf333, 0x3575, 0x0000, 0x0000, 0x0000, 0xdd60, 0xca3f,\n-    0x3555, 0x0000, 0x0000, 0x0000, 0x7eb6, 0xd87f, 0x3538, 0x0000, 0x0000, 0x0000,\n-    0x44f4, 0xb291, 0x3519, 0x0000, 0x0000, 0x0000, 0xff80, 0xc982, 0x34f6, 0x0000,\n-    0x0000, 0x0000, 0x9de0, 0xd9b8, 0x34db, 0x0000, 0x0000, 0x0000, 0xcd42, 0x9366,\n-    0x34bc, 0x0000, 0x0000, 0x0000, 0xbef0, 0xfaee, 0x349d, 0x0000, 0x0000, 0x0000,\n-    0xdac4, 0xb6f1, 0x347d, 0x0000, 0x0000, 0x0000, 0xf140, 0x94de, 0x345d, 0x0000,\n-    0x0000, 0x0000, 0xa218, 0x8b4b, 0x343e, 0x0000, 0x0000, 0x0000, 0x6380, 0xa135,\n-    0x341e, 0x0000, 0x0000, 0x0000, 0xb184, 0x8cb2, 0x3402, 0x0000, 0x0000, 0x0000,\n-    0x196e, 0xdc61, 0x33e3, 0x0000, 0x0000, 0x0000, 0x0c00, 0xde05, 0x33c4, 0x0000,\n-    0x0000, 0x0000, 0xef9a, 0xbd38, 0x33a5, 0x0000, 0x0000, 0x0000, 0xc1a0, 0xdf00,\n-    0x3385, 0x0000, 0x0000, 0x0000, 0x1090, 0x9973, 0x3365, 0x0000, 0x0000, 0x0000,\n-    0x4882, 0x8301, 0x3348, 0x0000, 0x0000, 0x0000, 0x7abe, 0xadc7, 0x3329, 0x0000,\n-    0x0000, 0x0000, 0x7cba, 0xec2b, 0x330a, 0x0000, 0x0000, 0x0000, 0xa520, 0x8f21,\n-    0x32e9, 0x0000, 0x0000, 0x0000, 0x710c, 0x8d36, 0x32cc, 0x0000, 0x0000, 0x0000,\n-    0x5212, 0xc6ed, 0x32ad, 0x0000, 0x0000, 0x0000, 0x7308, 0xfd76, 0x328d, 0x0000,\n-    0x0000, 0x0000, 0x5014, 0xd548, 0x326f, 0x0000, 0x0000, 0x0000, 0xd3f2, 0xb499,\n-    0x3250, 0x0000, 0x0000, 0x0000, 0x7f74, 0xa606, 0x3230, 0x0000, 0x0000, 0x0000,\n-    0xf0a8, 0xd720, 0x3212, 0x0000, 0x0000, 0x0000, 0x185c, 0xe20f, 0x31f2, 0x0000,\n-    0x0000, 0x0000, 0xa5a8, 0x8738, 0x31d4, 0x0000, 0x0000, 0x0000, 0xdd74, 0xcafb,\n-    0x31b4, 0x0000, 0x0000, 0x0000, 0x98b6, 0xbd8e, 0x3196, 0x0000, 0x0000, 0x0000,\n-    0xe9de, 0x977f, 0x3177, 0x0000, 0x0000, 0x0000, 0x67c0, 0x818d, 0x3158, 0x0000,\n-    0x0000, 0x0000, 0xe52a, 0x9322, 0x3139, 0x0000, 0x0000, 0x0000, 0xe568, 0x9b6c,\n-    0x3119, 0x0000, 0x0000, 0x0000, 0x2358, 0xaa0a, 0x30fa, 0x0000, 0x0000, 0x0000,\n-    0xe480, 0xe13b, 0x30d9, 0x0000, 0x0000, 0x0000, 0x3024, 0x90a1, 0x30bd, 0x0000,\n-    0x0000, 0x0000, 0x9620, 0xda30, 0x309d, 0x0000, 0x0000, 0x0000, 0x898a, 0xb388,\n-    0x307f, 0x0000, 0x0000, 0x0000, 0xb24c, 0xc891, 0x3060, 0x0000, 0x0000, 0x0000,\n-    0x8056, 0xf98b, 0x3041, 0x0000, 0x0000, 0x0000, 0x72a4, 0xa1ea, 0x3021, 0x0000,\n-    0x0000, 0x0000, 0x6af8, 0x9488, 0x3001, 0x0000, 0x0000, 0x0000, 0xe00c, 0xdfcb,\n-    0x2fe4, 0x0000, 0x0000, 0x0000, 0xeeec, 0xc941, 0x2fc4, 0x0000, 0x0000, 0x0000,\n-    0x53e0, 0xe70f, 0x2fa4, 0x0000, 0x0000, 0x0000, 0x8f60, 0x9c07, 0x2f85, 0x0000,\n-    0x0000, 0x0000, 0xb328, 0xc3e7, 0x2f68, 0x0000, 0x0000, 0x0000, 0x9404, 0xf8c7,\n-    0x2f48, 0x0000, 0x0000, 0x0000, 0x38e0, 0xc99f, 0x2f29, 0x0000, 0x0000, 0x0000,\n-    0x9778, 0xd984, 0x2f09, 0x0000, 0x0000, 0x0000, 0xe700, 0xd142, 0x2eea, 0x0000,\n-    0x0000, 0x0000, 0xd904, 0x9443, 0x2ecd, 0x0000, 0x0000, 0x0000, 0xd4ba, 0xae7e,\n-    0x2eae, 0x0000, 0x0000, 0x0000, 0x8e5e, 0x8524, 0x2e8f, 0x0000, 0x0000, 0x0000,\n-    0xb550, 0xc9ed, 0x2e6e, 0x0000, 0x0000, 0x0000, 0x53b8, 0x8648, 0x2e51, 0x0000,\n-    0x0000, 0x0000, 0xdae4, 0x87f9, 0x2e32, 0x0000, 0x0000, 0x0000, 0x2942, 0xd966,\n-    0x2e13, 0x0000, 0x0000, 0x0000, 0x4f28, 0xcf3c, 0x2df3, 0x0000, 0x0000, 0x0000,\n-    0xfa40, 0xc4ef, 0x2dd1, 0x0000, 0x0000, 0x0000, 0x4424, 0xbca7, 0x2db5, 0x0000,\n-    0x0000, 0x0000, 0x2e62, 0xcdc5, 0x2d97, 0x0000, 0x0000, 0x0000, 0xed88, 0x996b,\n-    0x2d78, 0x0000, 0x0000, 0x0000, 0x7c30, 0xd97d, 0x2d56, 0x0000, 0x0000, 0x0000,\n-    0xed26, 0xbf6e, 0x2d3a, 0x0000, 0x0000, 0x0000, 0x2918, 0x921b, 0x2d1a, 0x0000,\n-    0x0000, 0x0000, 0x4e24, 0xe84e, 0x2cfb, 0x0000, 0x0000, 0x0000, 0x6dc0, 0x92ec,\n-    0x2cdd, 0x0000, 0x0000, 0x0000, 0x4f2c, 0xacf8, 0x2cbd, 0x0000, 0x0000, 0x0000,\n-    0xc634, 0xf094, 0x2c9e, 0x0000, 0x0000, 0x0000, 0xdc70, 0xe5d3, 0x2c7e, 0x0000,\n-    0x0000, 0x0000, 0x2180, 0xa600, 0x2c5b, 0x0000, 0x0000, 0x0000, 0x8480, 0xd680,\n-    0x2c3c, 0x0000, 0x0000, 0x0000, 0x8b24, 0xd63b, 0x2c22, 0x0000, 0x0000, 0x0000,\n-    0x02e0, 0xaa47, 0x2c00, 0x0000, 0x0000, 0x0000, 0x9ad0, 0xee84, 0x2be3, 0x0000,\n-    0x0000, 0x0000, 0xf7dc, 0xf699, 0x2bc6, 0x0000, 0x0000, 0x0000, 0xddde, 0xe490,\n-    0x2ba7, 0x0000, 0x0000, 0x0000, 0x34a0, 0xb4fd, 0x2b85, 0x0000, 0x0000, 0x0000,\n-    0x91b4, 0x8ef6, 0x2b68, 0x0000, 0x0000, 0x0000, 0xa3e0, 0xa2a7, 0x2b47, 0x0000,\n-    0x0000, 0x0000, 0xcce4, 0x82b3, 0x2b2a, 0x0000, 0x0000, 0x0000, 0xe4be, 0x8207,\n-    0x2b0c, 0x0000, 0x0000, 0x0000, 0x1d92, 0xab43, 0x2aed, 0x0000, 0x0000, 0x0000,\n-    0xe818, 0xf9f6, 0x2acd, 0x0000, 0x0000, 0x0000, 0xff12, 0xba80, 0x2aaf, 0x0000,\n-    0x0000, 0x0000, 0x5254, 0x8529, 0x2a90, 0x0000, 0x0000, 0x0000, 0x1b88, 0xe032,\n-    0x2a71, 0x0000, 0x0000, 0x0000, 0x3248, 0xd86d, 0x2a50, 0x0000, 0x0000, 0x0000,\n-    0x3140, 0xc9d5, 0x2a2e, 0x0000, 0x0000, 0x0000, 0x14e6, 0xbd47, 0x2a14, 0x0000,\n-    0x0000, 0x0000, 0x5c10, 0xe544, 0x29f4, 0x0000, 0x0000, 0x0000, 0x9f50, 0x90b6,\n-    0x29d4, 0x0000, 0x0000, 0x0000, 0x9850, 0xab55, 0x29b6, 0x0000, 0x0000, 0x0000,\n-    0x2750, 0x9d07, 0x2998, 0x0000, 0x0000, 0x0000, 0x6700, 0x8bbb, 0x2973, 0x0000,\n-    0x0000, 0x0000, 0x5dba, 0xed31, 0x295a, 0x0000, 0x0000, 0x0000, 0x61dc, 0x85fe,\n-    0x293a, 0x0000, 0x0000, 0x0000, 0x9ba2, 0xd6b4, 0x291c, 0x0000, 0x0000, 0x0000,\n-    0x2d30, 0xe3a5, 0x28fb, 0x0000, 0x0000, 0x0000, 0x6630, 0xb566, 0x28dd, 0x0000,\n-    0x0000, 0x0000, 0x5ad4, 0xa829, 0x28bf, 0x0000, 0x0000, 0x0000, 0x89d8, 0xe290,\n-    0x28a0, 0x0000, 0x0000, 0x0000, 0x3916, 0xc428, 0x2881, 0x0000, 0x0000, 0x0000,\n-    0x0490, 0xbea4, 0x2860, 0x0000, 0x0000, 0x0000, 0xee06, 0x80ee, 0x2843, 0x0000,\n-    0x0000, 0x0000, 0xfc00, 0xf327, 0x2820, 0x0000, 0x0000, 0x0000, 0xea40, 0xa871,\n-    0x2800, 0x0000, 0x0000, 0x0000, 0x63d8, 0x9c26, 0x27e4, 0x0000, 0x0000, 0x0000,\n-    0x07ba, 0xc0c9, 0x27c7, 0x0000, 0x0000, 0x0000, 0x3fa2, 0x9797, 0x27a8, 0x0000,\n-    0x0000, 0x0000, 0x21c6, 0xfeca, 0x2789, 0x0000, 0x0000, 0x0000, 0xde40, 0x860d,\n-    0x2768, 0x0000, 0x0000, 0x0000, 0x9cc8, 0x98ce, 0x2749, 0x0000, 0x0000, 0x0000,\n-    0x3778, 0xa31c, 0x272a, 0x0000, 0x0000, 0x0000, 0xe778, 0xf6e2, 0x270b, 0x0000,\n-    0x0000, 0x0000, 0x59b8, 0xf841, 0x26ed, 0x0000, 0x0000, 0x0000, 0x02e0, 0xad04,\n-    0x26cd, 0x0000, 0x0000, 0x0000, 0x5a92, 0x9380, 0x26b0, 0x0000, 0x0000, 0x0000,\n-    0xc740, 0x8886, 0x268d, 0x0000, 0x0000, 0x0000, 0x0680, 0xfaf8, 0x266c, 0x0000,\n-    0x0000, 0x0000, 0xfb60, 0x897f, 0x2653, 0x0000, 0x0000, 0x0000, 0x8760, 0xf903,\n-    0x2634, 0x0000, 0x0000, 0x0000, 0xad2a, 0xc2c8, 0x2615, 0x0000, 0x0000, 0x0000,\n-    0x2d86, 0x8aef, 0x25f6, 0x0000, 0x0000, 0x0000, 0x1ef4, 0xe627, 0x25d6, 0x0000,\n-    0x0000, 0x0000, 0x09e4, 0x8020, 0x25b7, 0x0000, 0x0000, 0x0000, 0x7548, 0xd227,\n-    0x2598, 0x0000, 0x0000, 0x0000, 0x75dc, 0xfb5b, 0x2579, 0x0000, 0x0000, 0x0000,\n-    0xea84, 0xc8b6, 0x255a, 0x0000, 0x0000, 0x0000, 0xe4d0, 0x8145, 0x253b, 0x0000,\n-    0x0000, 0x0000, 0x3640, 0x9768, 0x251c, 0x0000, 0x0000, 0x0000, 0x246a, 0xccec,\n-    0x24fe, 0x0000, 0x0000, 0x0000, 0x51d0, 0xa075, 0x24dd, 0x0000, 0x0000, 0x0000,\n-    0x4638, 0xa385, 0x24bf, 0x0000, 0x0000, 0x0000, 0xd788, 0xd776, 0x24a1, 0x0000,\n-    0x0000, 0x0000, 0x1370, 0x8997, 0x2482, 0x0000, 0x0000, 0x0000, 0x1e88, 0x9b67,\n-    0x2462, 0x0000, 0x0000, 0x0000, 0x6c08, 0xd975, 0x2444, 0x0000, 0x0000, 0x0000,\n-    0xfdb0, 0xcfc0, 0x2422, 0x0000, 0x0000, 0x0000, 0x3100, 0xc026, 0x2406, 0x0000,\n-    0x0000, 0x0000, 0xc5b4, 0xae64, 0x23e6, 0x0000, 0x0000, 0x0000, 0x2280, 0xf687,\n-    0x23c3, 0x0000, 0x0000, 0x0000, 0x2de0, 0x9006, 0x23a9, 0x0000, 0x0000, 0x0000,\n-    0x24bc, 0xf631, 0x238a, 0x0000, 0x0000, 0x0000, 0xb8d4, 0xa975, 0x236b, 0x0000,\n-    0x0000, 0x0000, 0xd9a4, 0xb949, 0x234b, 0x0000, 0x0000, 0x0000, 0xb54e, 0xbd39,\n-    0x232d, 0x0000, 0x0000, 0x0000, 0x4aac, 0x9a52, 0x230e, 0x0000, 0x0000, 0x0000,\n-    0xbbbc, 0xd085, 0x22ef, 0x0000, 0x0000, 0x0000, 0xdf18, 0xc633, 0x22cf, 0x0000,\n-    0x0000, 0x0000, 0x16d0, 0xeca5, 0x22af, 0x0000, 0x0000, 0x0000, 0xf2a0, 0xdf6f,\n-    0x228e, 0x0000, 0x0000, 0x0000, 0x8c44, 0xe86b, 0x2272, 0x0000, 0x0000, 0x0000,\n-    0x35c0, 0xbbf4, 0x2253, 0x0000, 0x0000, 0x0000, 0x0c40, 0xdafb, 0x2230, 0x0000,\n-    0x0000, 0x0000, 0x92dc, 0x9935, 0x2216, 0x0000, 0x0000, 0x0000, 0x0ca0, 0xbda6,\n-    0x21f3, 0x0000, 0x0000, 0x0000, 0x5958, 0xa6fd, 0x21d6, 0x0000, 0x0000, 0x0000,\n-    0xa3dc, 0x9d7f, 0x21b9, 0x0000, 0x0000, 0x0000, 0x79dc, 0xfcb5, 0x2199, 0x0000,\n-    0x0000, 0x0000, 0xf264, 0xcebb, 0x217b, 0x0000, 0x0000, 0x0000, 0x0abe, 0x8308,\n-    0x215c, 0x0000, 0x0000, 0x0000, 0x30ae, 0xb463, 0x213d, 0x0000, 0x0000, 0x0000,\n-    0x6228, 0xb040, 0x211c, 0x0000, 0x0000, 0x0000, 0xc9b2, 0xf43b, 0x20ff, 0x0000,\n-    0x0000, 0x0000, 0x3d8e, 0xa4b3, 0x20e0, 0x0000, 0x0000, 0x0000, 0x84e6, 0x8dab,\n-    0x20c1, 0x0000, 0x0000, 0x0000, 0xa124, 0x9b74, 0x20a1, 0x0000, 0x0000, 0x0000,\n-    0xc276, 0xd497, 0x2083, 0x0000, 0x0000, 0x0000, 0x6354, 0xa466, 0x2063, 0x0000,\n-    0x0000, 0x0000, 0x8654, 0xaf0a, 0x2044, 0x0000, 0x0000, 0x0000, 0x1d20, 0xfa5c,\n-    0x2024, 0x0000, 0x0000, 0x0000, 0xbcd0, 0xf3f0, 0x2004, 0x0000, 0x0000, 0x0000,\n-    0xedf0, 0xf0b6, 0x1fe7, 0x0000, 0x0000, 0x0000, 0x45bc, 0x9182, 0x1fc9, 0x0000,\n-    0x0000, 0x0000, 0xe254, 0xdc85, 0x1faa, 0x0000, 0x0000, 0x0000, 0xb898, 0xe9b1,\n-    0x1f8a, 0x0000, 0x0000, 0x0000, 0x0ebe, 0xe6f0, 0x1f6c, 0x0000, 0x0000, 0x0000,\n-    0xa9b8, 0xf584, 0x1f4c, 0x0000, 0x0000, 0x0000, 0x12e8, 0xdf6b, 0x1f2e, 0x0000,\n-    0x0000, 0x0000, 0x9f9e, 0xcd55, 0x1f0f, 0x0000, 0x0000, 0x0000, 0x05a0, 0xec3a,\n-    0x1eef, 0x0000, 0x0000, 0x0000, 0xd8e0, 0x96f8, 0x1ed1, 0x0000, 0x0000, 0x0000,\n-    0x3bd4, 0xccc6, 0x1eb1, 0x0000, 0x0000, 0x0000, 0x4910, 0xb87b, 0x1e93, 0x0000,\n-    0x0000, 0x0000, 0xbefc, 0xd40b, 0x1e73, 0x0000, 0x0000, 0x0000, 0x317e, 0xa406,\n-    0x1e55, 0x0000, 0x0000, 0x0000, 0x6bb2, 0xc2b2, 0x1e36, 0x0000, 0x0000, 0x0000,\n-    0xb87e, 0xbb78, 0x1e17, 0x0000, 0x0000, 0x0000, 0xa03c, 0xdbbd, 0x1df7, 0x0000,\n-    0x0000, 0x0000, 0x5b6c, 0xe3c8, 0x1dd9, 0x0000, 0x0000, 0x0000, 0x8968, 0xca8e,\n-    0x1dba, 0x0000, 0x0000, 0x0000, 0xc024, 0xe6ab, 0x1d9a, 0x0000, 0x0000, 0x0000,\n-    0x4110, 0xd4eb, 0x1d7a, 0x0000, 0x0000, 0x0000, 0xa168, 0xbdb5, 0x1d5d, 0x0000,\n-    0x0000, 0x0000, 0x012e, 0xa5fa, 0x1d3e, 0x0000, 0x0000, 0x0000, 0x6838, 0x9c1f,\n-    0x1d1e, 0x0000, 0x0000, 0x0000, 0xa158, 0xaa76, 0x1d00, 0x0000, 0x0000, 0x0000,\n-    0x090a, 0xbd95, 0x1ce1, 0x0000, 0x0000, 0x0000, 0xf73e, 0x8b6d, 0x1cc2, 0x0000,\n-    0x0000, 0x0000, 0x5fda, 0xbcbf, 0x1ca3, 0x0000, 0x0000, 0x0000, 0xdbe8, 0xb89f,\n-    0x1c84, 0x0000, 0x0000, 0x0000, 0x6e4c, 0x96c7, 0x1c64, 0x0000, 0x0000, 0x0000,\n-    0x19c2, 0xf2a4, 0x1c46, 0x0000, 0x0000, 0x0000, 0xb800, 0xf855, 0x1c1e, 0x0000,\n-    0x0000, 0x0000, 0x87fc, 0x85ff, 0x1c08, 0x0000, 0x0000, 0x0000, 0x1418, 0x839f,\n-    0x1be9, 0x0000, 0x0000, 0x0000, 0x6186, 0xd9d8, 0x1bca, 0x0000, 0x0000, 0x0000,\n-    0xf500, 0xabaa, 0x1ba6, 0x0000, 0x0000, 0x0000, 0x7b36, 0xdafe, 0x1b8c, 0x0000,\n-    0x0000, 0x0000, 0xf394, 0xe6d8, 0x1b6c, 0x0000, 0x0000, 0x0000, 0x6efc, 0x9e55,\n-    0x1b4e, 0x0000, 0x0000, 0x0000, 0x5e10, 0xc523, 0x1b2e, 0x0000, 0x0000, 0x0000,\n-    0x8210, 0xb6f9, 0x1b0d, 0x0000, 0x0000, 0x0000, 0x9ab0, 0x96e3, 0x1af1, 0x0000,\n-    0x0000, 0x0000, 0x3864, 0x92e7, 0x1ad1, 0x0000, 0x0000, 0x0000, 0x9878, 0xdc65,\n-    0x1ab1, 0x0000, 0x0000, 0x0000, 0xfa20, 0xd6cb, 0x1a94, 0x0000, 0x0000, 0x0000,\n-    0x6c00, 0xa4e4, 0x1a70, 0x0000, 0x0000, 0x0000, 0xab40, 0xb41b, 0x1a53, 0x0000,\n-    0x0000, 0x0000, 0x43a4, 0x8ede, 0x1a37, 0x0000, 0x0000, 0x0000, 0x22e0, 0x9314,\n-    0x1a15, 0x0000, 0x0000, 0x0000, 0x6170, 0xb949, 0x19f8, 0x0000, 0x0000, 0x0000,\n-    0x6b00, 0xe056, 0x19d8, 0x0000, 0x0000, 0x0000, 0x9ba8, 0xa94c, 0x19b9, 0x0000,\n-    0x0000, 0x0000, 0xfaa0, 0xaa16, 0x199b, 0x0000, 0x0000, 0x0000, 0x899a, 0xf627,\n-    0x197d, 0x0000, 0x0000, 0x0000, 0x9f20, 0xfb70, 0x195d, 0x0000, 0x0000, 0x0000,\n-    0xa4b8, 0xc176, 0x193e, 0x0000, 0x0000, 0x0000, 0xb21c, 0x85c3, 0x1920, 0x0000,\n-    0x0000, 0x0000, 0x50d2, 0x9b19, 0x1901, 0x0000, 0x0000, 0x0000, 0xd4b0, 0xb708,\n-    0x18e0, 0x0000, 0x0000, 0x0000, 0xfb88, 0xf510, 0x18c1, 0x0000, 0x0000, 0x0000,\n-    0x31ec, 0xdc8d, 0x18a3, 0x0000, 0x0000, 0x0000, 0x3c00, 0xbff9, 0x1885, 0x0000,\n-    0x0000, 0x0000, 0x5020, 0xc30b, 0x1862, 0x0000, 0x0000, 0x0000, 0xd4f0, 0xda0c,\n-    0x1844, 0x0000, 0x0000, 0x0000, 0x20d2, 0x99a5, 0x1828, 0x0000, 0x0000, 0x0000,\n-    0x852e, 0xd159, 0x1809, 0x0000, 0x0000, 0x0000, 0x7cd8, 0x97a1, 0x17e9, 0x0000,\n-    0x0000, 0x0000, 0x423a, 0x997b, 0x17cb, 0x0000, 0x0000, 0x0000, 0xc1c0, 0xbe7d,\n-    0x17a8, 0x0000, 0x0000, 0x0000, 0xe8bc, 0xdcdd, 0x178d, 0x0000, 0x0000, 0x0000,\n-    0x8b28, 0xae06, 0x176e, 0x0000, 0x0000, 0x0000, 0x102e, 0xb8d4, 0x174f, 0x0000,\n-    0x0000, 0x0000, 0xaa00, 0xaa5c, 0x172f, 0x0000, 0x0000, 0x0000, 0x51f0, 0x9fc0,\n-    0x170e, 0x0000, 0x0000, 0x0000, 0xf858, 0xe181, 0x16f2, 0x0000, 0x0000, 0x0000,\n-    0x91a8, 0x8162, 0x16d3, 0x0000, 0x0000, 0x0000, 0x5f40, 0xcb6f, 0x16b1, 0x0000,\n-    0x0000, 0x0000, 0xbb50, 0xe55f, 0x1693, 0x0000, 0x0000, 0x0000, 0xacd2, 0xd895,\n-    0x1676, 0x0000, 0x0000, 0x0000, 0xef30, 0x97bf, 0x1654, 0x0000, 0x0000, 0x0000,\n-    0xf700, 0xb3d7, 0x1633, 0x0000, 0x0000, 0x0000, 0x3454, 0xa7b5, 0x1619, 0x0000,\n-    0x0000, 0x0000, 0x6b00, 0xa929, 0x15f6, 0x0000, 0x0000, 0x0000, 0x9f04, 0x89f7,\n-    0x15db, 0x0000, 0x0000, 0x0000, 0xad78, 0xd985, 0x15bc, 0x0000, 0x0000, 0x0000,\n-    0xa46a, 0xae3f, 0x159d, 0x0000, 0x0000, 0x0000, 0x63a0, 0xd0da, 0x157c, 0x0000,\n-    0x0000, 0x0000, 0x5e90, 0x817d, 0x155e, 0x0000, 0x0000, 0x0000, 0x1494, 0xb13f,\n-    0x1540, 0x0000, 0x0000, 0x0000, 0x0090, 0x9c40, 0x1521, 0x0000, 0x0000, 0x0000,\n-    0xdd70, 0xcc86, 0x1500, 0x0000, 0x0000, 0x0000, 0x64f8, 0xdb6f, 0x14e1, 0x0000,\n-    0x0000, 0x0000, 0xe22c, 0xac17, 0x14c3, 0x0000, 0x0000, 0x0000, 0x60e0, 0xa9ad,\n-    0x14a3, 0x0000, 0x0000, 0x0000, 0x4640, 0xd658, 0x1481, 0x0000, 0x0000, 0x0000,\n-    0x6490, 0xa181, 0x1467, 0x0000, 0x0000, 0x0000, 0x1df4, 0xaaa2, 0x1447, 0x0000,\n-    0x0000, 0x0000, 0xb94a, 0x8f61, 0x1429, 0x0000, 0x0000, 0x0000, 0x5198, 0x9d83,\n-    0x1409, 0x0000, 0x0000, 0x0000, 0x0f7a, 0xa818, 0x13eb, 0x0000, 0x0000, 0x0000,\n-    0xc45e, 0xc06c, 0x13cc, 0x0000, 0x0000, 0x0000, 0x4ec0, 0xfa29, 0x13a8, 0x0000,\n-    0x0000, 0x0000, 0x6418, 0x8cad, 0x138c, 0x0000, 0x0000, 0x0000, 0xbcc8, 0xe7d1,\n-    0x136f, 0x0000, 0x0000, 0x0000, 0xc934, 0xf9b0, 0x134f, 0x0000, 0x0000, 0x0000,\n-    0x6ce0, 0x98df, 0x1331, 0x0000, 0x0000, 0x0000, 0x3516, 0xe5e9, 0x1312, 0x0000,\n-    0x0000, 0x0000, 0xc6c0, 0xef8b, 0x12ef, 0x0000, 0x0000, 0x0000, 0xaf02, 0x913d,\n-    0x12d4, 0x0000, 0x0000, 0x0000, 0xd230, 0xe1d5, 0x12b5, 0x0000, 0x0000, 0x0000,\n-    0xfba8, 0xc232, 0x1295, 0x0000, 0x0000, 0x0000, 0x7ba4, 0xabeb, 0x1277, 0x0000,\n-    0x0000, 0x0000, 0x6e5c, 0xc692, 0x1258, 0x0000, 0x0000, 0x0000, 0x76a2, 0x9756,\n-    0x1239, 0x0000, 0x0000, 0x0000, 0xe180, 0xe423, 0x1214, 0x0000, 0x0000, 0x0000,\n-    0x8c3c, 0x90f8, 0x11fb, 0x0000, 0x0000, 0x0000, 0x9f3c, 0x9fd2, 0x11dc, 0x0000,\n-    0x0000, 0x0000, 0x53e0, 0xb73e, 0x11bd, 0x0000, 0x0000, 0x0000, 0x45be, 0x88d6,\n-    0x119e, 0x0000, 0x0000, 0x0000, 0x111a, 0x8bc0, 0x117f, 0x0000, 0x0000, 0x0000,\n-    0xe26a, 0xd7ff, 0x1160, 0x0000, 0x0000, 0x0000, 0xfb60, 0xdd8d, 0x113f, 0x0000,\n-    0x0000, 0x0000, 0x9370, 0xc108, 0x1120, 0x0000, 0x0000, 0x0000, 0x9654, 0x8baf,\n-    0x1103, 0x0000, 0x0000, 0x0000, 0xd6ec, 0xd6b9, 0x10e4, 0x0000, 0x0000, 0x0000,\n-    0x23e4, 0xd7b7, 0x10c4, 0x0000, 0x0000, 0x0000, 0x1aa6, 0xa847, 0x10a6, 0x0000,\n-    0x0000, 0x0000, 0xbee6, 0x9fef, 0x1087, 0x0000, 0x0000, 0x0000, 0x26d0, 0xa6eb,\n-    0x1066, 0x0000, 0x0000, 0x0000, 0x5b86, 0xa880, 0x1049, 0x0000, 0x0000, 0x0000,\n-    0x125c, 0xd971, 0x1029, 0x0000, 0x0000, 0x0000, 0x1f78, 0x9d18, 0x100a, 0x0000,\n-    0x0000, 0x0000, 0x0e84, 0xb15b, 0x0feb, 0x0000, 0x0000, 0x0000, 0xd0c0, 0xc150,\n-    0x0fcc, 0x0000, 0x0000, 0x0000, 0xa330, 0xc40c, 0x0fad, 0x0000, 0x0000, 0x0000,\n-    0x5202, 0xfc2c, 0x0f8f, 0x0000, 0x0000, 0x0000, 0x3f7c, 0xecf5, 0x0f6f, 0x0000,\n-    0x0000, 0x0000, 0xef44, 0xfdfd, 0x0f50, 0x0000, 0x0000, 0x0000, 0x3f6c, 0xab1b,\n-    0x0f31, 0x0000, 0x0000, 0x0000, 0xf658, 0x89ec, 0x0f11, 0x0000, 0x0000, 0x0000,\n-    0xbfc8, 0x9ba8, 0x0ef4, 0x0000, 0x0000, 0x0000, 0x3d40, 0xbe21, 0x0ed5, 0x0000,\n-    0x0000, 0x0000, 0xbbc4, 0xc70d, 0x0eb6, 0x0000, 0x0000, 0x0000, 0x5158, 0xdb16,\n-    0x0e96, 0x0000, 0x0000, 0x0000, 0xb5a8, 0xa8d8, 0x0e78, 0x0000, 0x0000, 0x0000,\n-    0xcccc, 0xb40e, 0x0e58, 0x0000, 0x0000, 0x0000, 0x448c, 0xcb62, 0x0e3a, 0x0000,\n-    0x0000, 0x0000, 0xf12a, 0x8aed, 0x0e1b, 0x0000, 0x0000, 0x0000, 0x79d0, 0xc59c,\n-    0x0dfb, 0x0000, 0x0000, 0x0000, 0x06b4, 0xcdc9, 0x0ddd, 0x0000, 0x0000, 0x0000,\n-    0xae70, 0xa979, 0x0dbe, 0x0000, 0x0000, 0x0000, 0x317c, 0xa8fb, 0x0d9e, 0x0000,\n-    0x0000, 0x0000, 0x5fe0, 0x8a50, 0x0d7d, 0x0000, 0x0000, 0x0000, 0x70b6, 0xfdfa,\n-    0x0d61, 0x0000, 0x0000, 0x0000, 0x1640, 0x9dc7, 0x0d41, 0x0000, 0x0000, 0x0000,\n-    0x9a9c, 0xdc50, 0x0d23, 0x0000, 0x0000, 0x0000, 0x4fcc, 0x9a9b, 0x0d04, 0x0000,\n-    0x0000, 0x0000, 0x7e48, 0x8f77, 0x0ce5, 0x0000, 0x0000, 0x0000, 0x84e4, 0xd4b9,\n-    0x0cc6, 0x0000, 0x0000, 0x0000, 0x84e0, 0xbd10, 0x0ca6, 0x0000, 0x0000, 0x0000,\n-    0x1b0a, 0xc8d9, 0x0c88, 0x0000, 0x0000, 0x0000, 0x6a48, 0xfc81, 0x0c68, 0x0000,\n-    0x0000, 0x0000, 0x070a, 0xbef6, 0x0c4a, 0x0000, 0x0000, 0x0000, 0x8a70, 0xf096,\n-    0x0c2b, 0x0000, 0x0000, 0x0000, 0xecc2, 0xc994, 0x0c0c, 0x0000, 0x0000, 0x0000,\n-    0x1540, 0x9537, 0x0bea, 0x0000, 0x0000, 0x0000, 0x1b02, 0xab5b, 0x0bce, 0x0000,\n-    0x0000, 0x0000, 0x5dc0, 0xb0c8, 0x0bad, 0x0000, 0x0000, 0x0000, 0xc928, 0xe034,\n-    0x0b8f, 0x0000, 0x0000, 0x0000, 0x2d12, 0xb4b0, 0x0b71, 0x0000, 0x0000, 0x0000,\n-    0x8fc2, 0xbb94, 0x0b52, 0x0000, 0x0000, 0x0000, 0xe236, 0xe22f, 0x0b33, 0x0000,\n-    0x0000, 0x0000, 0xb97c, 0xbe9e, 0x0b13, 0x0000, 0x0000, 0x0000, 0xe1a6, 0xe16d,\n-    0x0af5, 0x0000, 0x0000, 0x0000, 0xd330, 0xbaf0, 0x0ad6, 0x0000, 0x0000, 0x0000,\n-    0xc0bc, 0xbbd0, 0x0ab7, 0x0000, 0x0000, 0x0000, 0x8e66, 0xdd9b, 0x0a98, 0x0000,\n-    0x0000, 0x0000, 0xc95c, 0xf799, 0x0a79, 0x0000, 0x0000, 0x0000, 0xdac0, 0xbe4c,\n-    0x0a55, 0x0000, 0x0000, 0x0000, 0xafc0, 0xc378, 0x0a37, 0x0000, 0x0000, 0x0000,\n-    0xa880, 0xe341, 0x0a19, 0x0000, 0x0000, 0x0000, 0xc242, 0x81f6, 0x09fd, 0x0000,\n-    0x0000, 0x0000, 0x7470, 0xc777, 0x09de, 0x0000, 0x0000, 0x0000, 0x62bc, 0xb684,\n-    0x09be, 0x0000, 0x0000, 0x0000, 0x43ac, 0x8c58, 0x099f, 0x0000, 0x0000, 0x0000,\n-    0xcc3c, 0xf9ac, 0x0981, 0x0000, 0x0000, 0x0000, 0x1526, 0xb670, 0x0962, 0x0000,\n-    0x0000, 0x0000, 0xc9fe, 0xdf50, 0x0943, 0x0000, 0x0000, 0x0000, 0x6ae6, 0xc065,\n-    0x0924, 0x0000, 0x0000, 0x0000, 0xb114, 0xcf29, 0x0905, 0x0000, 0x0000, 0x0000,\n-    0xd388, 0x922a, 0x08e4, 0x0000, 0x0000, 0x0000, 0xcf54, 0xb926, 0x08c7, 0x0000,\n-    0x0000, 0x0000, 0x3826, 0xe855, 0x08a8, 0x0000, 0x0000, 0x0000, 0xe7c8, 0x829b,\n-    0x0888, 0x0000, 0x0000, 0x0000, 0x546c, 0xa903, 0x086a, 0x0000, 0x0000, 0x0000,\n-    0x8768, 0x99cc, 0x0849, 0x0000, 0x0000, 0x0000, 0x00ac, 0xf529, 0x082b, 0x0000,\n-    0x0000, 0x0000, 0x2658, 0x9f0b, 0x080c, 0x0000, 0x0000, 0x0000, 0xfe5c, 0x9e21,\n-    0x07ee, 0x0000, 0x0000, 0x0000, 0x6da2, 0x9910, 0x07cf, 0x0000, 0x0000, 0x0000,\n-    0x9220, 0xf9b3, 0x07b0, 0x0000, 0x0000, 0x0000, 0x3d90, 0xa541, 0x0791, 0x0000,\n-    0x0000, 0x0000, 0x6e4c, 0xe7cc, 0x0771, 0x0000, 0x0000, 0x0000, 0xa8fa, 0xe80a,\n-    0x0753, 0x0000, 0x0000, 0x0000, 0x4e14, 0xc3a7, 0x0734, 0x0000, 0x0000, 0x0000,\n-    0xf7e0, 0xbad9, 0x0712, 0x0000, 0x0000, 0x0000, 0xfea0, 0xeff2, 0x06f5, 0x0000,\n-    0x0000, 0x0000, 0xcef6, 0xbd48, 0x06d7, 0x0000, 0x0000, 0x0000, 0x7544, 0xf559,\n-    0x06b7, 0x0000, 0x0000, 0x0000, 0x2388, 0xf655, 0x0698, 0x0000, 0x0000, 0x0000,\n-    0xe900, 0xad56, 0x0676, 0x0000, 0x0000, 0x0000, 0x2cc0, 0x8437, 0x0659, 0x0000,\n-    0x0000, 0x0000, 0x3068, 0xc544, 0x063b, 0x0000, 0x0000, 0x0000, 0xdc70, 0xe73c,\n-    0x061b, 0x0000, 0x0000, 0x0000, 0xee50, 0x9d49, 0x05fc, 0x0000, 0x0000, 0x0000,\n-    0x93d2, 0x81f6, 0x05df, 0x0000, 0x0000, 0x0000, 0x941c, 0xadff, 0x05bf, 0x0000,\n-    0x0000, 0x0000, 0x2ce2, 0x8e45, 0x05a1, 0x0000, 0x0000, 0x0000, 0x4a60, 0x95fd,\n-    0x0581, 0x0000, 0x0000, 0x0000, 0x79f8, 0xb83a, 0x0563, 0x0000, 0x0000, 0x0000,\n-    0xcb58, 0xa1f5, 0x0543, 0x0000, 0x0000, 0x0000, 0x2a3a, 0xdc36, 0x0525, 0x0000,\n-    0x0000, 0x0000, 0x14ee, 0x890e, 0x0506, 0x0000, 0x0000, 0x0000, 0x8f20, 0xc432,\n-    0x04e3, 0x0000, 0x0000, 0x0000, 0x8440, 0xb21d, 0x04c6, 0x0000, 0x0000, 0x0000,\n-    0x5430, 0xf698, 0x04a7, 0x0000, 0x0000, 0x0000, 0x04ae, 0x8b20, 0x048a, 0x0000,\n-    0x0000, 0x0000, 0x04d0, 0xe872, 0x046b, 0x0000, 0x0000, 0x0000, 0xc78e, 0x8893,\n-    0x044c, 0x0000, 0x0000, 0x0000, 0x0f78, 0x9895, 0x042b, 0x0000, 0x0000, 0x0000,\n-    0x11d4, 0xdf2e, 0x040d, 0x0000, 0x0000, 0x0000, 0xe84c, 0x89d5, 0x03ef, 0x0000,\n-    0x0000, 0x0000, 0xf7be, 0x8a67, 0x03d0, 0x0000, 0x0000, 0x0000, 0x95d0, 0xc906,\n-    0x03b1, 0x0000, 0x0000, 0x0000, 0x64ce, 0xd96c, 0x0392, 0x0000, 0x0000, 0x0000,\n-    0x97ba, 0xa16f, 0x0373, 0x0000, 0x0000, 0x0000, 0x463c, 0xc51a, 0x0354, 0x0000,\n-    0x0000, 0x0000, 0xef0a, 0xe93e, 0x0335, 0x0000, 0x0000, 0x0000, 0x526a, 0xa466,\n-    0x0316, 0x0000, 0x0000, 0x0000, 0x4140, 0xa94d, 0x02f5, 0x0000, 0x0000, 0x0000,\n-    0xb4ec, 0xce68, 0x02d8, 0x0000, 0x0000, 0x0000, 0x4fa2, 0x8490, 0x02b9, 0x0000,\n-    0x0000, 0x0000, 0x4e60, 0xca98, 0x0298, 0x0000, 0x0000, 0x0000, 0x08dc, 0xe09c,\n-    0x027a, 0x0000, 0x0000, 0x0000, 0x2b90, 0xc7e3, 0x025c, 0x0000, 0x0000, 0x0000,\n-    0x5a7c, 0xf8ef, 0x023c, 0x0000, 0x0000, 0x0000, 0x5022, 0x9d58, 0x021e, 0x0000,\n-    0x0000, 0x0000, 0x553a, 0xe242, 0x01ff, 0x0000, 0x0000, 0x0000, 0x7e6e, 0xb54d,\n-    0x01e0, 0x0000, 0x0000, 0x0000, 0xd2d4, 0xa88c, 0x01c1, 0x0000, 0x0000, 0x0000,\n-    0x75b6, 0xfe6d, 0x01a2, 0x0000, 0x0000, 0x0000, 0x3bb2, 0xf04c, 0x0183, 0x0000,\n-    0x0000, 0x0000, 0xc2d0, 0xc046, 0x0163, 0x0000, 0x0000, 0x0000, 0x250c, 0xf9d6,\n-    0x0145, 0x0000, 0x0000, 0x0000, 0xb7b4, 0x8a0d, 0x0126, 0x0000, 0x0000, 0x0000,\n-    0x1a72, 0xe4f5, 0x0107, 0x0000, 0x0000, 0x0000, 0x825c, 0xa9b8, 0x00e8, 0x0000,\n-    0x0000, 0x0000, 0x6c90, 0xc9ad, 0x00c6, 0x0000, 0x0000, 0x0000, 0x4d00, 0xd1bb,\n-    0x00aa, 0x0000, 0x0000, 0x0000, 0xa4a0, 0xee01, 0x0087, 0x0000, 0x0000, 0x0000,\n-    0x89a8, 0xbe9f, 0x006b, 0x0000, 0x0000, 0x0000, 0x038e, 0xc80c, 0x004d, 0x0000,\n-    0x0000, 0x0000, 0xfe26, 0x8384, 0x002e, 0x0000, 0x0000, 0x0000, 0xcd90, 0xca57,\n-    0x000e, 0x0000\n-};\n-\n-void MacroAssembler::libm_reduce_pi04l(Register eax, Register ecx, Register edx, Register ebx, Register esi, Register edi, Register ebp, Register esp) {\n-  Label B1_1, B1_2, B1_3, B1_4, B1_5, B1_6, B1_7, B1_8, B1_9, B1_10, B1_11, B1_12;\n-  Label B1_13, B1_14, B1_15;\n-\n-  assert_different_registers(ebx, eax, ecx, edx, esi, edi, ebp, esp);\n-\n-  address zero_none  = (address)_zero_none;\n-  address _4onpi_d   = (address)__4onpi_d;\n-  address TWO_32H    = (address)_TWO_32H;\n-  address pi04_3d    = (address)_pi04_3d;\n-  address pi04_5d    = (address)_pi04_5d;\n-  address SCALE      = (address)_SCALE;\n-  address zeros      = (address)_zeros;\n-  address pi04_2d    = (address)_pi04_2d;\n-  address TWO_12H    = (address)_TWO_12H;\n-  address _4onpi_31l = (address)__4onpi_31l;\n-\n-  bind(B1_1);\n-  push(ebp);\n-  movl(ebp, esp);\n-  andl(esp, -16);\n-  push(esi);\n-  push(edi);\n-  push(ebx);\n-  subl(esp, 20);\n-  movzwl(ebx, Address(ebp, 16));\n-  andl(ebx, 32767);\n-  movl(eax, Address(ebp, 20));\n-  cmpl(ebx, 16413);\n-  movl(esi, Address(ebp, 24));\n-  movl(Address(esp, 4), eax);\n-  jcc(Assembler::greaterEqual, B1_8);\n-\n-  bind(B1_2);\n-  fld_x(Address(ebp, 8));\n-  fld_d(ExternalAddress(_4onpi_d));    \/\/0x6dc9c883UL, 0x3ff45f30UL\n-  fmul(1);\n-  fstp_x(Address(esp, 8));\n-  movzwl(ecx, Address(esp, 16));\n-  negl(ecx);\n-  addl(ecx, 30);\n-  movl(eax, Address(esp, 12));\n-  shrl(eax);\n-  cmpl(Address(esp, 4), 0);\n-  jcc(Assembler::notEqual, B1_4);\n-\n-  bind(B1_3);\n-  lea(ecx, Address(eax, 1));\n-  andl(ecx, -2);\n-  jmp(B1_5);\n-\n-  bind(B1_4);\n-  movl(ecx, eax);\n-  addl(eax, Address(esp, 4));\n-  movl(edx, eax);\n-  andl(edx, 1);\n-  addl(ecx, edx);\n-\n-  bind(B1_5);\n-  fld_d(ExternalAddress(TWO_32H));    \/\/0x00000000UL, 0x41f80000UL\n-  cmpl(ebx, 16400);\n-  movl(Address(esp, 0), ecx);\n-  fild_s(Address(esp, 0));\n-  jcc(Assembler::greaterEqual, B1_7);\n-\n-  bind(B1_6);\n-  fld_d(ExternalAddress(pi04_3d));    \/\/0x54442d00UL, 0x3fe921fbUL\n-  fmul(1);\n-  fsubp(3);\n-  fxch(1);\n-  fmul(2);\n-  fld_s(2);\n-  fadd(1);\n-  fsubrp(1);\n-  fld_s(0);\n-  fxch(1);\n-  fsuba(3);\n-  fld_d(ExternalAddress(8 + pi04_3d));    \/\/0x98cc5180UL, 0x3ce84698UL\n-  fmul(3);\n-  fsuba(2);\n-  fxch(1);\n-  fsub(2);\n-  fsubrp(1);\n-  faddp(3);\n-  fld_d(ExternalAddress(16 + pi04_3d));    \/\/0xcbb5bf6cUL, 0xb9dfc8f8UL\n-  fmulp(2);\n-  fld_s(1);\n-  fsubr(1);\n-  fsuba(1);\n-  fxch(2);\n-  fsubp(1);\n-  faddp(2);\n-  fxch(1);\n-  jmp(B1_15);\n-\n-  bind(B1_7);\n-  fld_d(ExternalAddress(pi04_5d));    \/\/0x54400000UL, 0x3fe921fbUL\n-  fmul(1);\n-  fsubp(3);\n-  fxch(1);\n-  fmul(2);\n-  fld_s(2);\n-  fadd(1);\n-  fsubrp(1);\n-  fld_s(0);\n-  fxch(1);\n-  fsuba(3);\n-  fld_d(ExternalAddress(8 + pi04_5d));    \/\/0x1a600000UL, 0x3dc0b461UL\n-  fmul(3);\n-  fsuba(2);\n-  fxch(1);\n-  fsub(2);\n-  fsubrp(1);\n-  faddp(3);\n-  fld_d(ExternalAddress(16 + pi04_5d));    \/\/0x2e000000UL, 0x3b93198aUL\n-  fmul(2);\n-  fld_s(0);\n-  fsubr(2);\n-  fsuba(2);\n-  fxch(1);\n-  fsubp(2);\n-  fxch(1);\n-  faddp(3);\n-  fld_d(ExternalAddress(24 + pi04_5d));    \/\/0x25200000UL, 0x396b839aUL\n-  fmul(2);\n-  fld_s(0);\n-  fsubr(2);\n-  fsuba(2);\n-  fxch(1);\n-  fsubp(2);\n-  fxch(1);\n-  faddp(3);\n-  fld_d(ExternalAddress(32 + pi04_5d));    \/\/0x533e63a0UL, 0x37027044UL\n-  fmulp(2);\n-  fld_s(1);\n-  fsubr(1);\n-  fsuba(1);\n-  fxch(2);\n-  fsubp(1);\n-  faddp(2);\n-  fxch(1);\n-  jmp(B1_15);\n-\n-  bind(B1_8);\n-  fld_x(Address(ebp, 8));\n-  addl(ebx, -16417);\n-  fmul_d(as_Address(ExternalAddress(SCALE)));    \/\/0x00000000UL, 0x32600000UL\n-  movl(eax, -2078209981);\n-  imull(ebx);\n-  addl(edx, ebx);\n-  movl(ecx, ebx);\n-  sarl(edx, 4);\n-  sarl(ecx, 31);\n-  subl(edx, ecx);\n-  movl(eax, edx);\n-  shll(eax, 5);\n-  fstp_x(Address(ebp, 8));\n-  fld_x(Address(ebp, 8));\n-  subl(eax, edx);\n-  movl(Address(ebp, 8), 0);\n-  subl(ebx, eax);\n-  fld_x(Address(ebp, 8));\n-  cmpl(ebx, 17);\n-  fsuba(1);\n-  jcc(Assembler::less, B1_10);\n-\n-  bind(B1_9);\n-  lea(eax, Address(noreg, edx, Address::times_8));\n-  lea(ecx, Address(eax, edx, Address::times_4));\n-  incl(edx);\n-  fld_x(Address(_4onpi_31l, RelocationHolder::none).plus_disp(ecx, Address::times_1));\n-  fmul(2);\n-  fld_x(Address(12 + _4onpi_31l, RelocationHolder::none).plus_disp(ecx, Address::times_1));\n-  fmul(2);\n-  fld_s(0);\n-  fadd(2);\n-  fsuba(2);\n-  fxch(1);\n-  faddp(2);\n-  fld_s(1);\n-  fadd(1);\n-  fstp_x(Address(esp, 8));\n-  andl(Address(esp, 8), -16777216);\n-  fld_x(Address(esp, 8));\n-  fsubp(1);\n-  jmp(B1_11);\n-\n-  bind(B1_10);\n-  fld_d(ExternalAddress(zeros));    \/\/0x00000000UL, 0x00000000UL\n-  fld_s(0);\n-\n-  bind(B1_11);\n-  fld_s(0);\n-  lea(eax, Address(noreg, edx, Address::times_8));\n-  fld_s(3);\n-  lea(edx, Address(eax, edx, Address::times_4));\n-  fld_x(Address(_4onpi_31l, RelocationHolder::none).plus_disp(edx, Address::times_1));\n-  fmul(6);\n-  movl(Address(esp, 0), edx);\n-  fadda(2);\n-  fxch(2);\n-  fsuba(3);\n-  fxch(2);\n-  faddp(3);\n-  fxch(2);\n-  faddp(3);\n-  fld_x(Address(12 + _4onpi_31l, RelocationHolder::none).plus_disp(edx, Address::times_1));\n-  fmula(2);\n-  fld_s(2);\n-  fadd(2);\n-  fld_s(0);\n-  fxch(1);\n-  fsubra(3);\n-  fxch(3);\n-  fchs();\n-  faddp(4);\n-  fxch(3);\n-  faddp(4);\n-  fxch(2);\n-  fadd(3);\n-  fxch(2);\n-  fmul(5);\n-  fadda(2);\n-  fld_s(4);\n-  fld_x(Address(24 + _4onpi_31l, RelocationHolder::none).plus_disp(edx, Address::times_1));\n-  fmula(1);\n-  fxch(1);\n-  fadda(4);\n-  fxch(4);\n-  fstp_x(Address(esp, 8));\n-  movzwl(ebx, Address(esp, 16));\n-  andl(ebx, 32767);\n-  cmpl(ebx, 16415);\n-  jcc(Assembler::greaterEqual, B1_13);\n-\n-  bind(B1_12);\n-  negl(ebx);\n-  addl(ebx, 30);\n-  movl(ecx, ebx);\n-  movl(eax, Address(esp, 12));\n-  shrl(eax);\n-  shll(eax);\n-  movl(Address(esp, 12), eax);\n-  movl(Address(esp, 8), 0);\n-  shrl(eax);\n-  jmp(B1_14);\n-\n-  bind(B1_13);\n-  negl(ebx);\n-  addl(ebx, 30);\n-  movl(ecx, ebx);\n-  movl(edx, Address(esp, 8));\n-  shrl(edx);\n-  shll(edx);\n-  negl(ecx);\n-  movl(eax, Address(esp, 12));\n-  shll(eax);\n-  movl(ecx, ebx);\n-  movl(Address(esp, 8), edx);\n-  shrl(edx);\n-  orl(eax, edx);\n-\n-  bind(B1_14);\n-  fld_x(Address(esp, 8));\n-  addl(eax, Address(esp, 4));\n-  fsubp(3);\n-  fmul(6);\n-  fld_s(4);\n-  movl(edx, eax);\n-  andl(edx, 1);\n-  fadd(3);\n-  movl(ecx, Address(esp, 0));\n-  fsuba(3);\n-  fxch(3);\n-  faddp(5);\n-  fld_s(1);\n-  fxch(3);\n-  fadd_d(Address(zero_none, RelocationHolder::none).plus_disp(edx, Address::times_8));\n-  fadda(3);\n-  fsub(3);\n-  faddp(2);\n-  fxch(1);\n-  faddp(4);\n-  fld_s(2);\n-  fadd(2);\n-  fsuba(2);\n-  fxch(3);\n-  faddp(2);\n-  fxch(1);\n-  faddp(3);\n-  fld_s(0);\n-  fadd(2);\n-  fsuba(2);\n-  fxch(1);\n-  faddp(2);\n-  fxch(1);\n-  faddp(2);\n-  fld_s(2);\n-  fld_x(Address(36 + _4onpi_31l, RelocationHolder::none).plus_disp(ecx, Address::times_1));\n-  fmula(1);\n-  fld_s(1);\n-  fadd(3);\n-  fsuba(3);\n-  fxch(2);\n-  faddp(3);\n-  fxch(2);\n-  faddp(3);\n-  fxch(1);\n-  fmul(4);\n-  fld_s(0);\n-  fadd(2);\n-  fsuba(2);\n-  fxch(1);\n-  faddp(2);\n-  fxch(1);\n-  faddp(2);\n-  fld_s(2);\n-  fld_x(Address(48 + _4onpi_31l, RelocationHolder::none).plus_disp(ecx, Address::times_1));\n-  fmula(1);\n-  fld_s(1);\n-  fadd(3);\n-  fsuba(3);\n-  fxch(2);\n-  faddp(3);\n-  fxch(2);\n-  faddp(3);\n-  fld_s(3);\n-  fxch(2);\n-  fmul(5);\n-  fld_x(Address(60 + _4onpi_31l, RelocationHolder::none).plus_disp(ecx, Address::times_1));\n-  fmula(3);\n-  fxch(3);\n-  faddp(1);\n-  fld_s(0);\n-  fadd(2);\n-  fsuba(2);\n-  fxch(1);\n-  faddp(2);\n-  fxch(1);\n-  faddp(3);\n-  fld_s(3);\n-  fxch(2);\n-  fmul(5);\n-  fld_x(Address(72 + _4onpi_31l, RelocationHolder::none).plus_disp(ecx, Address::times_1));\n-  fmula(3);\n-  fxch(3);\n-  faddp(1);\n-  fld_s(0);\n-  fadd(2);\n-  fsuba(2);\n-  fxch(1);\n-  faddp(2);\n-  fxch(1);\n-  faddp(3);\n-  fxch(1);\n-  fmulp(4);\n-  fld_x(Address(84 + _4onpi_31l, RelocationHolder::none).plus_disp(ecx, Address::times_1));\n-  fmulp(3);\n-  fxch(2);\n-  faddp(3);\n-  fld_s(2);\n-  fadd(2);\n-  fld_d(ExternalAddress(TWO_32H));    \/\/0x00000000UL, 0x41f80000UL\n-  fmul(1);\n-  fadda(1);\n-  fsubp(1);\n-  fsuba(2);\n-  fxch(3);\n-  faddp(2);\n-  faddp(1);\n-  fld_d(ExternalAddress(pi04_2d));    \/\/0x54400000UL, 0x3fe921fbUL\n-  fld_s(0);\n-  fmul(2);\n-  fxch(2);\n-  fadd(3);\n-  fxch(1);\n-  fmulp(3);\n-  fmul_d(as_Address(ExternalAddress(8 + pi04_2d)));    \/\/0x1a626331UL, 0x3dc0b461UL\n-  faddp(1);\n-\n-  bind(B1_15);\n-  fld_d(ExternalAddress(TWO_12H));    \/\/0x00000000UL, 0x40b80000UL\n-  fld_s(2);\n-  fadd(2);\n-  fmula(1);\n-  fstp_x(Address(esp, 8));\n-  fld_x(Address(esp, 8));\n-  fadd(1);\n-  fsubrp(1);\n-  fst_d(Address(esi, 0));\n-  fsubp(2);\n-  faddp(1);\n-  fstp_d(Address(esi, 8));\n-  addl(esp, 20);\n-  pop(ebx);\n-  pop(edi);\n-  pop(esi);\n-  movl(esp, ebp);\n-  pop(ebp);\n-  ret(0);\n-}\n-\n-\n-ATTRIBUTE_ALIGNED(16) jushort _SP[] =\n-{\n-    0xaaab, 0xaaaa, 0xaaaa, 0xaaaa, 0xbffc, 0x0000, 0x8887, 0x8888, 0x8888, 0x8888,\n-    0x3ff8, 0x0000, 0xc527, 0x0d00, 0x00d0, 0xd00d, 0xbff2, 0x0000, 0x45f6, 0xb616,\n-    0x1d2a, 0xb8ef, 0x3fec, 0x0000, 0x825b, 0x3997, 0x2b3f, 0xd732, 0xbfe5, 0x0000,\n-    0xbf33, 0x8bb4, 0x2fda, 0xb092, 0x3fde, 0x0000, 0x44a6, 0xed1a, 0x29ef, 0xd73e,\n-    0xbfd6, 0x0000, 0x8610, 0x307f, 0x62a1, 0xc921, 0x3fce, 0x0000\n-};\n-\n-ATTRIBUTE_ALIGNED(16) jushort _CP[] =\n-{\n-    0x0000, 0x0000, 0x0000, 0x8000, 0xbffe, 0x0000, 0xaaa5, 0xaaaa, 0xaaaa, 0xaaaa,\n-    0x3ffa, 0x0000, 0x9c2f, 0x0b60, 0x60b6, 0xb60b, 0xbff5, 0x0000, 0xf024, 0x0cac,\n-    0x00d0, 0xd00d, 0x3fef, 0x0000, 0x03fe, 0x3f65, 0x7dbb, 0x93f2, 0xbfe9, 0x0000,\n-    0xd84d, 0xadee, 0xc698, 0x8f76, 0x3fe2, 0x0000, 0xdaba, 0xfe79, 0xea36, 0xc9c9,\n-    0xbfda, 0x0000, 0x3ac6, 0x0ba0, 0x07ce, 0xd585, 0x3fd2, 0x0000\n-};\n-\n-void MacroAssembler::libm_sincos_huge(XMMRegister xmm0, XMMRegister xmm1, Register eax, Register ecx, Register edx, Register ebx, Register esi, Register edi, Register ebp, Register esp) {\n-  Label B1_1, B1_2, B1_3, B1_4, B1_5, B1_6, B1_7, B1_8, B1_9, B1_10, B1_11, B1_12;\n-  Label B1_13, B1_14, B1_15, B1_16, B1_17, B1_18, B1_19, B1_20, B1_21, B1_22, B1_23;\n-  Label B1_24, B1_25, B1_26, B1_27, B1_28, B1_29, B1_30, B1_31, B1_32, B1_33, B1_34;\n-  Label B1_35, B1_36, B1_37, B1_38, B1_39, B1_40, B1_41, B1_42, B1_43, B1_46;\n-\n-  assert_different_registers(ebx, eax, ecx, edx, esi, edi, ebp, esp);\n-\n-  address CP = (address)_CP;\n-  address SP = (address)_SP;\n-\n-  bind(B1_1);\n-  push(ebp);\n-  movl(ebp, esp);\n-  andl(esp, -64);\n-  push(esi);\n-  push(edi);\n-  push(ebx);\n-  subl(esp, 52);\n-  movl(eax, Address(ebp, 16));\n-  movl(edx, Address(ebp, 20));\n-  movl(Address(esp, 32), eax);\n-  movl(Address(esp, 36), edx);\n-\n-  bind(B1_2);\n-  fnstcw(Address(esp, 30));\n-\n-  bind(B1_3);\n-  movsd(xmm1, Address(ebp, 8));\n-  movl(esi, Address(ebp, 12));\n-  movl(eax, esi);\n-  andl(eax, 2147483647);\n-  andps(xmm1, ExternalAddress(L_2IL0FLOATPACKET_0));    \/\/0xffffffffUL, 0x7fffffffUL, 0x00000000UL, 0x00000000UL\n-  shrl(esi, 31);\n-  movl(Address(esp, 40), eax);\n-  cmpl(eax, 1104150528);\n-  movsd(Address(ebp, 8), xmm1);\n-  jcc(Assembler::aboveEqual, B1_11);\n-\n-  bind(B1_4);\n-  movsd(xmm0, ExternalAddress(PI4_INV));    \/\/0x6dc9c883UL, 0x3ff45f30UL\n-  mulsd(xmm0, xmm1);\n-  movzwl(edx, Address(esp, 30));\n-  movl(eax, edx);\n-  andl(eax, 768);\n-  movsd(Address(esp, 0), xmm0);\n-  cmpl(eax, 768);\n-  jcc(Assembler::equal, B1_42);\n-\n-  bind(B1_5);\n-  orl(edx, -64768);\n-  movw(Address(esp, 28), edx);\n-\n-  bind(B1_6);\n-  fldcw(Address(esp, 28));\n-\n-  bind(B1_7);\n-  movsd(xmm1, Address(ebp, 8));\n-  movl(ebx, 1);\n-\n-  bind(B1_8);\n-  movl(Address(esp, 12), ebx);\n-  movl(ebx, Address(esp, 4));\n-  movl(eax, ebx);\n-  movl(Address(esp, 8), esi);\n-  movl(esi, ebx);\n-  shrl(esi, 20);\n-  andl(eax, 1048575);\n-  movl(ecx, esi);\n-  orl(eax, 1048576);\n-  negl(ecx);\n-  movl(edx, eax);\n-  addl(ecx, 19);\n-  addl(esi, 13);\n-  movl(Address(esp, 24), ecx);\n-  shrl(edx);\n-  movl(ecx, esi);\n-  shll(eax);\n-  movl(ecx, Address(esp, 24));\n-  movl(esi, Address(esp, 0));\n-  shrl(esi);\n-  orl(eax, esi);\n-  cmpl(ebx, 1094713344);\n-  movsd(Address(esp, 16), xmm1);\n-  fld_d(Address(esp, 16));\n-  cmov32(Assembler::below, eax, edx);\n-  movl(esi, Address(esp, 8));\n-  lea(edx, Address(eax, 1));\n-  movl(ebx, edx);\n-  andl(ebx, -2);\n-  movl(Address(esp, 16), ebx);\n-  fild_s(Address(esp, 16));\n-  movl(ebx, Address(esp, 12));\n-  cmpl(Address(esp, 40), 1094713344);\n-  jcc(Assembler::aboveEqual, B1_10);\n-\n-  bind(B1_9);\n-  fld_d(ExternalAddress(PI4X3));    \/\/0x54443000UL, 0xbfe921fbUL\n-  fmul(1);\n-  faddp(2);\n-  fld_d(ExternalAddress(PI4X3 + 8));    \/\/0x3b39a000UL, 0x3d373dcbUL\n-  fmul(1);\n-  faddp(2);\n-  fld_d(ExternalAddress(PI4X3 + 16));    \/\/0xe0e68948UL, 0xba845c06UL\n-  fmulp(1);\n-  faddp(1);\n-  jmp(B1_17);\n-\n-  bind(B1_10);\n-  fld_d(ExternalAddress(PI4X4));    \/\/0x54400000UL, 0xbfe921fbUL\n-  fmul(1);\n-  faddp(2);\n-  fld_d(ExternalAddress(PI4X4 + 8));    \/\/0x1a600000UL, 0xbdc0b461UL\n-  fmul(1);\n-  faddp(2);\n-  fld_d(ExternalAddress(PI4X4 + 16));    \/\/0x2e000000UL, 0xbb93198aUL\n-  fmul(1);\n-  faddp(2);\n-  fld_d(ExternalAddress(PI4X4 + 24));    \/\/0x252049c1UL, 0xb96b839aUL\n-  fmulp(1);\n-  faddp(1);\n-  jmp(B1_17);\n-\n-  bind(B1_11);\n-  movzwl(edx, Address(esp, 30));\n-  movl(eax, edx);\n-  andl(eax, 768);\n-  cmpl(eax, 768);\n-  jcc(Assembler::equal, B1_43);\n-  bind(B1_12);\n-  orl(edx, -64768);\n-  movw(Address(esp, 28), edx);\n-\n-  bind(B1_13);\n-  fldcw(Address(esp, 28));\n-\n-  bind(B1_14);\n-  movsd(xmm1, Address(ebp, 8));\n-  movl(ebx, 1);\n-\n-  bind(B1_15);\n-  movsd(Address(esp, 16), xmm1);\n-  fld_d(Address(esp, 16));\n-  addl(esp, -32);\n-  lea(eax, Address(esp, 32));\n-  fstp_x(Address(esp, 0));\n-  movl(Address(esp, 12), 0);\n-  movl(Address(esp, 16), eax);\n-  call(RuntimeAddress(CAST_FROM_FN_PTR(address, StubRoutines::dlibm_reduce_pi04l())));\n-\n-  bind(B1_46);\n-  addl(esp, 32);\n-\n-  bind(B1_16);\n-  fld_d(Address(esp, 0));\n-  lea(edx, Address(eax, 1));\n-  fld_d(Address(esp, 8));\n-  faddp(1);\n-\n-  bind(B1_17);\n-  movl(ecx, edx);\n-  addl(eax, 3);\n-  shrl(ecx, 2);\n-  andl(ecx, 1);\n-  shrl(eax, 2);\n-  xorl(esi, ecx);\n-  movl(ecx, Address(esp, 36));\n-  andl(eax, 1);\n-  andl(ecx, 3);\n-  cmpl(ecx, 3);\n-  jcc(Assembler::notEqual, B1_25);\n-\n-  bind(B1_18);\n-  fld_x(ExternalAddress(84 + SP));    \/\/0x8610, 0x307f, 0x62\n-  fld_s(1);\n-  fmul((2));\n-  testb(edx, 2);\n-  fmula((1));\n-  fld_x(ExternalAddress(72 + SP));    \/\/0x44a6, 0xed1a, 0x29\n-  faddp(2);\n-  fmula(1);\n-  fld_x(ExternalAddress(60 + SP));    \/\/0xbf33, 0x8bb4, 0x2f\n-  faddp(2);\n-  fmula(1);\n-  fld_x(ExternalAddress(48 + SP));    \/\/0x825b, 0x3997, 0x2b\n-  faddp(2);\n-  fmula(1);\n-  fld_x(ExternalAddress(36 + SP));    \/\/0x45f6, 0xb616, 0x1d\n-  faddp(2);\n-  fmula(1);\n-  fld_x(ExternalAddress(24 + SP));    \/\/0xc527, 0x0d00, 0x00\n-  faddp(2);\n-  fmula(1);\n-  fld_x(ExternalAddress(12 + SP));    \/\/0x8887, 0x8888, 0x88\n-  faddp(2);\n-  fmula(1);\n-  fld_x(ExternalAddress(SP));    \/\/0xaaab, 0xaaaa, 0xaa\n-  faddp(2);\n-  fmula(1);\n-  fld_x(ExternalAddress(84 + CP));    \/\/0x3ac6, 0x0ba0, 0x07\n-  fmul(1);\n-  fld_x(ExternalAddress(72 + CP));    \/\/0xdaba, 0xfe79, 0xea\n-  faddp(1);\n-  fmul(1);\n-  fld_x(ExternalAddress(62 + CP));    \/\/0xd84d, 0xadee, 0xc6\n-  faddp(1);\n-  fmul(1);\n-  fld_x(ExternalAddress(48 + CP));    \/\/0x03fe, 0x3f65, 0x7d\n-  faddp(1);\n-  fmul(1);\n-  fld_x(ExternalAddress(36 + CP));    \/\/0xf024, 0x0cac, 0x00\n-  faddp(1);\n-  fmul(1);\n-  fld_x(ExternalAddress(24 + CP));    \/\/0x9c2f, 0x0b60, 0x60\n-  faddp(1);\n-  fmul(1);\n-  fld_x(ExternalAddress(12 + CP));    \/\/0xaaa5, 0xaaaa, 0xaa\n-  faddp(1);\n-  fmul(1);\n-  fld_x(ExternalAddress(CP));    \/\/0x0000, 0x0000, 0x00\n-  faddp(1);\n-  fmulp(1);\n-  fld_d(Address(ONES, RelocationHolder::none).plus_disp(esi, Address::times_8));\n-  fld_d(Address(ONES, RelocationHolder::none).plus_disp(eax, Address::times_8));\n-  jcc(Assembler::equal, B1_22);\n-\n-  bind(B1_19);\n-  fmulp(4);\n-  testl(ebx, ebx);\n-  fxch(2);\n-  fmul(3);\n-  movl(eax, Address(esp, 2));\n-  faddp(3);\n-  fxch(2);\n-  fstp_d(Address(eax, 0));\n-  fmula(1);\n-  faddp(1);\n-  fstp_d(Address(eax, 8));\n-  jcc(Assembler::equal, B1_21);\n-\n-  bind(B1_20);\n-  fldcw(Address(esp, 30));\n-\n-  bind(B1_21);\n-  addl(esp, 52);\n-  pop(ebx);\n-  pop(edi);\n-  pop(esi);\n-  movl(esp, ebp);\n-  pop(ebp);\n-  ret(0);\n-\n-  bind(B1_22);\n-  fxch(1);\n-  fmulp(4);\n-  testl(ebx, ebx);\n-  fxch(2);\n-  fmul(3);\n-  movl(eax, Address(esp, 32));\n-  faddp(3);\n-  fxch(2);\n-  fstp_d(Address(eax, 8));\n-  fmula(1);\n-  faddp(1);\n-  fstp_d(Address(eax, 0));\n-  jcc(Assembler::equal, B1_24);\n-\n-  bind(B1_23);\n-  fldcw(Address(esp, 30));\n-\n-  bind(B1_24);\n-  addl(esp, 52);\n-  pop(ebx);\n-  pop(edi);\n-  pop(esi);\n-  movl(esp, ebp);\n-  pop(ebp);\n-  ret(0);\n-\n-  bind(B1_25);\n-  testb(Address(esp, 36), 2);\n-  jcc(Assembler::equal, B1_33);\n-\n-  bind(B1_26);\n-  fld_s(0);\n-  testb(edx, 2);\n-  fmul(1);\n-  fld_s(0);\n-  fmul(1);\n-  jcc(Assembler::equal, B1_30);\n-\n-  bind(B1_27);\n-  fstp_d(2);\n-  fld_x(ExternalAddress(84 + CP));    \/\/0x3ac6, 0x0ba0, 0x07\n-  testl(ebx, ebx);\n-  fmul(2);\n-  fld_x(ExternalAddress(72 + CP));    \/\/0xdaba, 0xfe79, 0xea\n-  fmul(3);\n-  fld_x(ExternalAddress(60 + CP));    \/\/0xd84d, 0xadee, 0xc6\n-  movl(eax, Address(rsp, 32));\n-  faddp(2);\n-  fxch(1);\n-  fmul(3);\n-  fld_x(ExternalAddress(48 + CP));    \/\/0x03fe, 0x3f65, 0x7d\n-  faddp(2);\n-  fxch(1);\n-  fmul(3);\n-  fld_x(ExternalAddress(36 + CP));    \/\/0xf024, 0x0cac, 0x00\n-  faddp(2);\n-  fxch(1);\n-  fmul(3);\n-  fld_x(ExternalAddress(24 + CP));    \/\/0x9c2f, 0x0b60, 0x60\n-  faddp(2);\n-  fxch(1);\n-  fmul(3);\n-  fld_x(ExternalAddress(12 + CP));    \/\/0xaaa5, 0xaaaa, 0xaa\n-  faddp(2);\n-  fxch(1);\n-  fmulp(3);\n-  fld_x(ExternalAddress(CP));    \/\/0x0000, 0x0000, 0x00\n-  faddp(1);\n-  fmulp(1);\n-  faddp(1);\n-  fld_d(Address(ONES, RelocationHolder::none).plus_disp(rsi, Address::times_8));\n-  fmula(1);\n-  faddp(1);\n-  fstp_d(Address(eax, 8));\n-  jcc(Assembler::equal, B1_29);\n-\n-  bind(B1_28);\n-  fldcw(Address(esp, 30));\n-\n-  bind(B1_29);\n-  addl(esp, 52);\n-  pop(ebx);\n-  pop(edi);\n-  pop(esi);\n-  movl(esp, ebp);\n-  pop(ebp);\n-  ret(0);\n-\n-  bind(B1_30);\n-  fld_x(ExternalAddress(84 + SP));    \/\/0x8610, 0x307f, 0x62\n-  testl(ebx, ebx);\n-  fmul(1);\n-  fld_x(ExternalAddress(72 + SP));    \/\/0x44a6, 0xed1a, 0x29\n-  fmul(2);\n-  fld_x(ExternalAddress(60 + SP));    \/\/0xbf33, 0x8bb4, 0x2f\n-  movl(eax, Address(rsp, 32));\n-  faddp(2);\n-  fxch(1);\n-  fmul(2);\n-  fld_x(ExternalAddress(48 + SP));    \/\/0x825b, 0x3997, 0x2b\n-  faddp(2);\n-  fxch(1);\n-  fmul(2);\n-  fld_x(ExternalAddress(36 + SP));    \/\/0x45f6, 0xb616, 0x1d\n-  faddp(2);\n-  fxch(1);\n-  fmul(2);\n-  fld_x(ExternalAddress(24 + SP));    \/\/0xc527, 0x0d00, 0x00\n-  faddp(2);\n-  fxch(1);\n-  fmul(2);\n-  fld_x(ExternalAddress(12 + SP));    \/\/0x8887, 0x8888, 0x88\n-  faddp(2);\n-  fxch(1);\n-  fmulp(2);\n-  fld_x(ExternalAddress(SP));    \/\/0xaaab, 0xaaaa, 0xaa\n-  faddp(1);\n-  fmulp(2);\n-  faddp(1);\n-  fld_d(Address(ONES, RelocationHolder::none).plus_disp(rsi, Address::times_8));\n-  fmulp(2);\n-  fmul(1);\n-  faddp(1);\n-  fstp_d(Address(eax, 8));\n-  jcc(Assembler::equal, B1_32);\n-\n-  bind(B1_31);\n-  fldcw(Address(esp, 30));\n-\n-  bind(B1_32);\n-  addl(esp, 52);\n-  pop(ebx);\n-  pop(edi);\n-  pop(esi);\n-  movl(esp, ebp);\n-  pop(ebp);\n-  ret(0);\n-\n-  bind(B1_33);\n-  testb(Address(esp, 36), 1);\n-  jcc(Assembler::equal, B1_41);\n-\n-  bind(B1_34);\n-  fld_s(0);\n-  testb(edx, 2);\n-  fmul(1);\n-  fld_s(0);\n-  fmul(1);\n-  jcc(Assembler::equal, B1_38);\n-\n-  bind(B1_35);\n-  fld_x(ExternalAddress(84 + SP));    \/\/0x8610, 0x307f, 0x62\n-  testl(ebx, ebx);\n-  fmul(1);\n-  fld_x(ExternalAddress(72 + SP));    \/\/0x44a6, 0xed1a, 0x29\n-  fmul(2);\n-  fld_x(ExternalAddress(60 + SP));    \/\/0xbf33, 0x8bb4, 0x2f\n-  faddp(2);\n-  fxch(1);\n-  fmul(2);\n-  fld_x(ExternalAddress(48 + SP));    \/\/0x825b, 0x3997, 0x2b\n-  faddp(2);\n-  fxch(1);\n-  fmul(2);\n-  fld_x(ExternalAddress(36 + SP));    \/\/0x45f6, 0xb616, 0x1d\n-  faddp(2);\n-  fxch(1);\n-  fmul(2);\n-  fld_x(ExternalAddress(24 + SP));    \/\/0xc527, 0x0d00, 0x00\n-  faddp(2);\n-  fxch(1);\n-  fmul(2);\n-  fld_x(ExternalAddress(12 + SP));    \/\/0x8887, 0x8888, 0x88\n-  faddp(2);\n-  fxch(1);\n-  fmulp(2);\n-  fld_x(ExternalAddress(SP));    \/\/0xaaab, 0xaaaa, 0xaa\n-  faddp(1);\n-  fmulp(2);\n-  faddp(1);\n-  fld_d(Address(ONES, RelocationHolder::none).plus_disp(eax, Address::times_8));\n-  fmulp(2);\n-  fmul(1);\n-  movl(eax, Address(esp, 32));\n-  faddp(1);\n-  fstp_d(Address(eax, 0));\n-  jcc(Assembler::equal, B1_37);\n-\n-  bind(B1_36);\n-  fldcw(Address(esp, 30));\n-\n-  bind(B1_37);\n-  addl(esp, 52);\n-  pop(ebx);\n-  pop(edi);\n-  pop(esi);\n-  movl(esp, ebp);\n-  pop(ebp);\n-  ret(0);\n-\n-  bind(B1_38);\n-  fstp_d(2);\n-  fld_x(ExternalAddress(84 + CP));    \/\/0x3ac6, 0x0ba0, 0x07\n-  testl(ebx, ebx);\n-  fmul(2);\n-  fld_x(ExternalAddress(72 + CP));    \/\/0xdaba, 0xfe79, 0xea\n-  fmul(3);\n-  fld_x(ExternalAddress(60 + CP));    \/\/0xd84d, 0xadee, 0xc6\n-  faddp(2);\n-  fxch(1);\n-  fmul(3);\n-  fld_x(ExternalAddress(48 + CP));    \/\/0x03fe, 0x3f65, 0x7d\n-  faddp(2);\n-  fxch(1);\n-  fmul(3);\n-  fld_x(ExternalAddress(36 + CP));    \/\/0xf024, 0x0cac, 0x00\n-  faddp(2);\n-  fxch(1);\n-  fmul(3);\n-  fld_x(ExternalAddress(24 + CP));    \/\/0x9c2f, 0x0b60, 0x60\n-  faddp(2);\n-  fxch(1);\n-  fmul(3);\n-  fld_x(ExternalAddress(12 + CP));    \/\/0xaaa5, 0xaaaa, 0xaa\n-  faddp(2);\n-  fxch(1);\n-  fmulp(3);\n-  fld_x(ExternalAddress(CP));    \/\/0x0000, 0x0000, 0x00\n-  faddp(1);\n-  fmulp(1);\n-  faddp(1);\n-  fld_d(Address(ONES, RelocationHolder::none).plus_disp(eax, Address::times_8));\n-  fmula(1);\n-  movl(eax, Address(esp, 32));\n-  faddp(1);\n-  fstp_d(Address(eax, 0));\n-  jcc(Assembler::equal, B1_40);\n-\n-  bind(B1_39);\n-  fldcw(Address(esp, 30));\n-  bind(B1_40);\n-  addl(esp, 52);\n-  pop(ebx);\n-  pop(edi);\n-  pop(esi);\n-  movl(esp, ebp);\n-  pop(ebp);\n-  ret(0);\n-  bind(B1_41);\n-  fstp_d(0);\n-  addl(esp, 52);\n-  pop(ebx);\n-  pop(edi);\n-  pop(esi);\n-  movl(esp, ebp);\n-  pop(ebp);\n-  ret(0);\n-  bind(B1_42);\n-  xorl(ebx, ebx);\n-  jmp(B1_8);\n-  bind(B1_43);\n-  xorl(ebx, ebx);\n-  jmp(B1_15);\n-}\n-\n-ATTRIBUTE_ALIGNED(16) juint _static_const_table_sin[] =\n-{\n-    0x00000000UL, 0x00000000UL, 0x00000000UL, 0x00000000UL, 0x00000000UL,\n-    0x00000000UL, 0x00000000UL, 0x3ff00000UL, 0x176d6d31UL, 0xbf73b92eUL,\n-    0xbc29b42cUL, 0x3fb917a6UL, 0xe0000000UL, 0xbc3e2718UL, 0x00000000UL,\n-    0x3ff00000UL, 0x011469fbUL, 0xbf93ad06UL, 0x3c69a60bUL, 0x3fc8f8b8UL,\n-    0xc0000000UL, 0xbc626d19UL, 0x00000000UL, 0x3ff00000UL, 0x939d225aUL,\n-    0xbfa60beaUL, 0x2ed59f06UL, 0x3fd29406UL, 0xa0000000UL, 0xbc75d28dUL,\n-    0x00000000UL, 0x3ff00000UL, 0x866b95cfUL, 0xbfb37ca1UL, 0xa6aea963UL,\n-    0x3fd87de2UL, 0xe0000000UL, 0xbc672cedUL, 0x00000000UL, 0x3ff00000UL,\n-    0x73fa1279UL, 0xbfbe3a68UL, 0x3806f63bUL, 0x3fde2b5dUL, 0x20000000UL,\n-    0x3c5e0d89UL, 0x00000000UL, 0x3ff00000UL, 0x5bc57974UL, 0xbfc59267UL,\n-    0x39ae68c8UL, 0x3fe1c73bUL, 0x20000000UL, 0x3c8b25ddUL, 0x00000000UL,\n-    0x3ff00000UL, 0x53aba2fdUL, 0xbfcd0dfeUL, 0x25091dd6UL, 0x3fe44cf3UL,\n-    0x20000000UL, 0x3c68076aUL, 0x00000000UL, 0x3ff00000UL, 0x99fcef32UL,\n-    0x3fca8279UL, 0x667f3bcdUL, 0x3fe6a09eUL, 0x20000000UL, 0xbc8bdd34UL,\n-    0x00000000UL, 0x3fe00000UL, 0x94247758UL, 0x3fc133ccUL, 0x6b151741UL,\n-    0x3fe8bc80UL, 0x20000000UL, 0xbc82c5e1UL, 0x00000000UL, 0x3fe00000UL,\n-    0x9ae68c87UL, 0x3fac73b3UL, 0x290ea1a3UL, 0x3fea9b66UL, 0xe0000000UL,\n-    0x3c39f630UL, 0x00000000UL, 0x3fe00000UL, 0x7f909c4eUL, 0xbf9d4a2cUL,\n-    0xf180bdb1UL, 0x3fec38b2UL, 0x80000000UL, 0xbc76e0b1UL, 0x00000000UL,\n-    0x3fe00000UL, 0x65455a75UL, 0xbfbe0875UL, 0xcf328d46UL, 0x3fed906bUL,\n-    0x20000000UL, 0x3c7457e6UL, 0x00000000UL, 0x3fe00000UL, 0x76acf82dUL,\n-    0x3fa4a031UL, 0x56c62ddaUL, 0x3fee9f41UL, 0xe0000000UL, 0x3c8760b1UL,\n-    0x00000000UL, 0x3fd00000UL, 0x0e5967d5UL, 0xbfac1d1fUL, 0xcff75cb0UL,\n-    0x3fef6297UL, 0x20000000UL, 0x3c756217UL, 0x00000000UL, 0x3fd00000UL,\n-    0x0f592f50UL, 0xbf9ba165UL, 0xa3d12526UL, 0x3fefd88dUL, 0x40000000UL,\n-    0xbc887df6UL, 0x00000000UL, 0x3fc00000UL, 0x00000000UL, 0x00000000UL,\n-    0x00000000UL, 0x3ff00000UL, 0x00000000UL, 0x00000000UL, 0x00000000UL,\n-    0x00000000UL, 0x0f592f50UL, 0x3f9ba165UL, 0xa3d12526UL, 0x3fefd88dUL,\n-    0x40000000UL, 0xbc887df6UL, 0x00000000UL, 0xbfc00000UL, 0x0e5967d5UL,\n-    0x3fac1d1fUL, 0xcff75cb0UL, 0x3fef6297UL, 0x20000000UL, 0x3c756217UL,\n-    0x00000000UL, 0xbfd00000UL, 0x76acf82dUL, 0xbfa4a031UL, 0x56c62ddaUL,\n-    0x3fee9f41UL, 0xe0000000UL, 0x3c8760b1UL, 0x00000000UL, 0xbfd00000UL,\n-    0x65455a75UL, 0x3fbe0875UL, 0xcf328d46UL, 0x3fed906bUL, 0x20000000UL,\n-    0x3c7457e6UL, 0x00000000UL, 0xbfe00000UL, 0x7f909c4eUL, 0x3f9d4a2cUL,\n-    0xf180bdb1UL, 0x3fec38b2UL, 0x80000000UL, 0xbc76e0b1UL, 0x00000000UL,\n-    0xbfe00000UL, 0x9ae68c87UL, 0xbfac73b3UL, 0x290ea1a3UL, 0x3fea9b66UL,\n-    0xe0000000UL, 0x3c39f630UL, 0x00000000UL, 0xbfe00000UL, 0x94247758UL,\n-    0xbfc133ccUL, 0x6b151741UL, 0x3fe8bc80UL, 0x20000000UL, 0xbc82c5e1UL,\n-    0x00000000UL, 0xbfe00000UL, 0x99fcef32UL, 0xbfca8279UL, 0x667f3bcdUL,\n-    0x3fe6a09eUL, 0x20000000UL, 0xbc8bdd34UL, 0x00000000UL, 0xbfe00000UL,\n-    0x53aba2fdUL, 0x3fcd0dfeUL, 0x25091dd6UL, 0x3fe44cf3UL, 0x20000000UL,\n-    0x3c68076aUL, 0x00000000UL, 0xbff00000UL, 0x5bc57974UL, 0x3fc59267UL,\n-    0x39ae68c8UL, 0x3fe1c73bUL, 0x20000000UL, 0x3c8b25ddUL, 0x00000000UL,\n-    0xbff00000UL, 0x73fa1279UL, 0x3fbe3a68UL, 0x3806f63bUL, 0x3fde2b5dUL,\n-    0x20000000UL, 0x3c5e0d89UL, 0x00000000UL, 0xbff00000UL, 0x866b95cfUL,\n-    0x3fb37ca1UL, 0xa6aea963UL, 0x3fd87de2UL, 0xe0000000UL, 0xbc672cedUL,\n-    0x00000000UL, 0xbff00000UL, 0x939d225aUL, 0x3fa60beaUL, 0x2ed59f06UL,\n-    0x3fd29406UL, 0xa0000000UL, 0xbc75d28dUL, 0x00000000UL, 0xbff00000UL,\n-    0x011469fbUL, 0x3f93ad06UL, 0x3c69a60bUL, 0x3fc8f8b8UL, 0xc0000000UL,\n-    0xbc626d19UL, 0x00000000UL, 0xbff00000UL, 0x176d6d31UL, 0x3f73b92eUL,\n-    0xbc29b42cUL, 0x3fb917a6UL, 0xe0000000UL, 0xbc3e2718UL, 0x00000000UL,\n-    0xbff00000UL, 0x00000000UL, 0x00000000UL, 0x00000000UL, 0x00000000UL,\n-    0x00000000UL, 0x00000000UL, 0x00000000UL, 0xbff00000UL, 0x176d6d31UL,\n-    0x3f73b92eUL, 0xbc29b42cUL, 0xbfb917a6UL, 0xe0000000UL, 0x3c3e2718UL,\n-    0x00000000UL, 0xbff00000UL, 0x011469fbUL, 0x3f93ad06UL, 0x3c69a60bUL,\n-    0xbfc8f8b8UL, 0xc0000000UL, 0x3c626d19UL, 0x00000000UL, 0xbff00000UL,\n-    0x939d225aUL, 0x3fa60beaUL, 0x2ed59f06UL, 0xbfd29406UL, 0xa0000000UL,\n-    0x3c75d28dUL, 0x00000000UL, 0xbff00000UL, 0x866b95cfUL, 0x3fb37ca1UL,\n-    0xa6aea963UL, 0xbfd87de2UL, 0xe0000000UL, 0x3c672cedUL, 0x00000000UL,\n-    0xbff00000UL, 0x73fa1279UL, 0x3fbe3a68UL, 0x3806f63bUL, 0xbfde2b5dUL,\n-    0x20000000UL, 0xbc5e0d89UL, 0x00000000UL, 0xbff00000UL, 0x5bc57974UL,\n-    0x3fc59267UL, 0x39ae68c8UL, 0xbfe1c73bUL, 0x20000000UL, 0xbc8b25ddUL,\n-    0x00000000UL, 0xbff00000UL, 0x53aba2fdUL, 0x3fcd0dfeUL, 0x25091dd6UL,\n-    0xbfe44cf3UL, 0x20000000UL, 0xbc68076aUL, 0x00000000UL, 0xbff00000UL,\n-    0x99fcef32UL, 0xbfca8279UL, 0x667f3bcdUL, 0xbfe6a09eUL, 0x20000000UL,\n-    0x3c8bdd34UL, 0x00000000UL, 0xbfe00000UL, 0x94247758UL, 0xbfc133ccUL,\n-    0x6b151741UL, 0xbfe8bc80UL, 0x20000000UL, 0x3c82c5e1UL, 0x00000000UL,\n-    0xbfe00000UL, 0x9ae68c87UL, 0xbfac73b3UL, 0x290ea1a3UL, 0xbfea9b66UL,\n-    0xe0000000UL, 0xbc39f630UL, 0x00000000UL, 0xbfe00000UL, 0x7f909c4eUL,\n-    0x3f9d4a2cUL, 0xf180bdb1UL, 0xbfec38b2UL, 0x80000000UL, 0x3c76e0b1UL,\n-    0x00000000UL, 0xbfe00000UL, 0x65455a75UL, 0x3fbe0875UL, 0xcf328d46UL,\n-    0xbfed906bUL, 0x20000000UL, 0xbc7457e6UL, 0x00000000UL, 0xbfe00000UL,\n-    0x76acf82dUL, 0xbfa4a031UL, 0x56c62ddaUL, 0xbfee9f41UL, 0xe0000000UL,\n-    0xbc8760b1UL, 0x00000000UL, 0xbfd00000UL, 0x0e5967d5UL, 0x3fac1d1fUL,\n-    0xcff75cb0UL, 0xbfef6297UL, 0x20000000UL, 0xbc756217UL, 0x00000000UL,\n-    0xbfd00000UL, 0x0f592f50UL, 0x3f9ba165UL, 0xa3d12526UL, 0xbfefd88dUL,\n-    0x40000000UL, 0x3c887df6UL, 0x00000000UL, 0xbfc00000UL, 0x00000000UL,\n-    0x00000000UL, 0x00000000UL, 0xbff00000UL, 0x00000000UL, 0x00000000UL,\n-    0x00000000UL, 0x00000000UL, 0x0f592f50UL, 0xbf9ba165UL, 0xa3d12526UL,\n-    0xbfefd88dUL, 0x40000000UL, 0x3c887df6UL, 0x00000000UL, 0x3fc00000UL,\n-    0x0e5967d5UL, 0xbfac1d1fUL, 0xcff75cb0UL, 0xbfef6297UL, 0x20000000UL,\n-    0xbc756217UL, 0x00000000UL, 0x3fd00000UL, 0x76acf82dUL, 0x3fa4a031UL,\n-    0x56c62ddaUL, 0xbfee9f41UL, 0xe0000000UL, 0xbc8760b1UL, 0x00000000UL,\n-    0x3fd00000UL, 0x65455a75UL, 0xbfbe0875UL, 0xcf328d46UL, 0xbfed906bUL,\n-    0x20000000UL, 0xbc7457e6UL, 0x00000000UL, 0x3fe00000UL, 0x7f909c4eUL,\n-    0xbf9d4a2cUL, 0xf180bdb1UL, 0xbfec38b2UL, 0x80000000UL, 0x3c76e0b1UL,\n-    0x00000000UL, 0x3fe00000UL, 0x9ae68c87UL, 0x3fac73b3UL, 0x290ea1a3UL,\n-    0xbfea9b66UL, 0xe0000000UL, 0xbc39f630UL, 0x00000000UL, 0x3fe00000UL,\n-    0x94247758UL, 0x3fc133ccUL, 0x6b151741UL, 0xbfe8bc80UL, 0x20000000UL,\n-    0x3c82c5e1UL, 0x00000000UL, 0x3fe00000UL, 0x99fcef32UL, 0x3fca8279UL,\n-    0x667f3bcdUL, 0xbfe6a09eUL, 0x20000000UL, 0x3c8bdd34UL, 0x00000000UL,\n-    0x3fe00000UL, 0x53aba2fdUL, 0xbfcd0dfeUL, 0x25091dd6UL, 0xbfe44cf3UL,\n-    0x20000000UL, 0xbc68076aUL, 0x00000000UL, 0x3ff00000UL, 0x5bc57974UL,\n-    0xbfc59267UL, 0x39ae68c8UL, 0xbfe1c73bUL, 0x20000000UL, 0xbc8b25ddUL,\n-    0x00000000UL, 0x3ff00000UL, 0x73fa1279UL, 0xbfbe3a68UL, 0x3806f63bUL,\n-    0xbfde2b5dUL, 0x20000000UL, 0xbc5e0d89UL, 0x00000000UL, 0x3ff00000UL,\n-    0x866b95cfUL, 0xbfb37ca1UL, 0xa6aea963UL, 0xbfd87de2UL, 0xe0000000UL,\n-    0x3c672cedUL, 0x00000000UL, 0x3ff00000UL, 0x939d225aUL, 0xbfa60beaUL,\n-    0x2ed59f06UL, 0xbfd29406UL, 0xa0000000UL, 0x3c75d28dUL, 0x00000000UL,\n-    0x3ff00000UL, 0x011469fbUL, 0xbf93ad06UL, 0x3c69a60bUL, 0xbfc8f8b8UL,\n-    0xc0000000UL, 0x3c626d19UL, 0x00000000UL, 0x3ff00000UL, 0x176d6d31UL,\n-    0xbf73b92eUL, 0xbc29b42cUL, 0xbfb917a6UL, 0xe0000000UL, 0x3c3e2718UL,\n-    0x00000000UL, 0x3ff00000UL, 0x55555555UL, 0xbfc55555UL, 0x00000000UL,\n-    0xbfe00000UL, 0x11111111UL, 0x3f811111UL, 0x55555555UL, 0x3fa55555UL,\n-    0x1a01a01aUL, 0xbf2a01a0UL, 0x16c16c17UL, 0xbf56c16cUL, 0xa556c734UL,\n-    0x3ec71de3UL, 0x1a01a01aUL, 0x3efa01a0UL, 0x1a600000UL, 0x3d90b461UL,\n-    0x1a600000UL, 0x3d90b461UL, 0x54400000UL, 0x3fb921fbUL, 0x00000000UL,\n-    0x00000000UL, 0x2e037073UL, 0x3b63198aUL, 0x00000000UL, 0x00000000UL,\n-    0x6dc9c883UL, 0x40245f30UL, 0x00000000UL, 0x00000000UL, 0x00000000UL,\n-    0x43380000UL, 0x00000000UL, 0x00000000UL, 0x00000000UL, 0x43600000UL,\n-    0x00000000UL, 0x00000000UL, 0x00000000UL, 0x3c800000UL, 0x00000000UL,\n-    0x00000000UL, 0xffffffffUL, 0x3fefffffUL, 0x00000000UL, 0x00000000UL,\n-    0x00000000UL, 0x80000000UL, 0x00000000UL, 0x00000000UL, 0x00000000UL,\n-    0x80000000UL, 0x00000000UL, 0x80000000UL, 0x00000000UL, 0x3fe00000UL,\n-    0x00000000UL, 0x3fe00000UL\n-};\n-\n-void MacroAssembler::fast_sin(XMMRegister xmm0, XMMRegister xmm1, XMMRegister xmm2, XMMRegister xmm3,\n-                              XMMRegister xmm4, XMMRegister xmm5, XMMRegister xmm6, XMMRegister xmm7,\n-                              Register eax, Register ebx, Register edx) {\n-\n-  Label L_2TAG_PACKET_0_0_2, L_2TAG_PACKET_1_0_2, L_2TAG_PACKET_2_0_2, L_2TAG_PACKET_3_0_2;\n-  Label L_2TAG_PACKET_4_0_2;\n-\n-  assert_different_registers(eax, ebx, edx);\n-\n-  address static_const_table_sin = (address)_static_const_table_sin;\n-\n-  subl(rsp, 120);\n-  movl(Address(rsp, 56), ebx);\n-  lea(ebx, ExternalAddress(static_const_table_sin));\n-  movsd(xmm0, Address(rsp, 128));\n-  pextrw(eax, xmm0, 3);\n-  andl(eax, 32767);\n-  subl(eax, 12336);\n-  cmpl(eax, 4293);\n-  jcc(Assembler::above, L_2TAG_PACKET_0_0_2);\n-  movsd(xmm1, Address(ebx, 2160));\n-  mulsd(xmm1, xmm0);\n-  movsd(xmm5, Address(ebx, 2272));\n-  movdqu(xmm4, Address(ebx, 2256));\n-  pand(xmm4, xmm0);\n-  por(xmm5, xmm4);\n-  movsd(xmm3, Address(ebx, 2128));\n-  movdqu(xmm2, Address(ebx, 2112));\n-  addpd(xmm1, xmm5);\n-  cvttsd2sil(edx, xmm1);\n-  cvtsi2sdl(xmm1, edx);\n-  mulsd(xmm3, xmm1);\n-  unpcklpd(xmm1, xmm1);\n-  addl(edx, 1865216);\n-  movdqu(xmm4, xmm0);\n-  andl(edx, 63);\n-  movdqu(xmm5, Address(ebx, 2096));\n-  lea(eax, Address(ebx, 0));\n-  shll(edx, 5);\n-  addl(eax, edx);\n-  mulpd(xmm2, xmm1);\n-  subsd(xmm0, xmm3);\n-  mulsd(xmm1, Address(ebx, 2144));\n-  subsd(xmm4, xmm3);\n-  movsd(xmm7, Address(eax, 8));\n-  unpcklpd(xmm0, xmm0);\n-  movapd(xmm3, xmm4);\n-  subsd(xmm4, xmm2);\n-  mulpd(xmm5, xmm0);\n-  subpd(xmm0, xmm2);\n-  movdqu(xmm6, Address(ebx, 2064));\n-  mulsd(xmm7, xmm4);\n-  subsd(xmm3, xmm4);\n-  mulpd(xmm5, xmm0);\n-  mulpd(xmm0, xmm0);\n-  subsd(xmm3, xmm2);\n-  movdqu(xmm2, Address(eax, 0));\n-  subsd(xmm1, xmm3);\n-  movsd(xmm3, Address(eax, 24));\n-  addsd(xmm2, xmm3);\n-  subsd(xmm7, xmm2);\n-  mulsd(xmm2, xmm4);\n-  mulpd(xmm6, xmm0);\n-  mulsd(xmm3, xmm4);\n-  mulpd(xmm2, xmm0);\n-  mulpd(xmm0, xmm0);\n-  addpd(xmm5, Address(ebx, 2080));\n-  mulsd(xmm4, Address(eax, 0));\n-  addpd(xmm6, Address(ebx, 2048));\n-  mulpd(xmm5, xmm0);\n-  movapd(xmm0, xmm3);\n-  addsd(xmm3, Address(eax, 8));\n-  mulpd(xmm1, xmm7);\n-  movapd(xmm7, xmm4);\n-  addsd(xmm4, xmm3);\n-  addpd(xmm6, xmm5);\n-  movsd(xmm5, Address(eax, 8));\n-  subsd(xmm5, xmm3);\n-  subsd(xmm3, xmm4);\n-  addsd(xmm1, Address(eax, 16));\n-  mulpd(xmm6, xmm2);\n-  addsd(xmm5, xmm0);\n-  addsd(xmm3, xmm7);\n-  addsd(xmm1, xmm5);\n-  addsd(xmm1, xmm3);\n-  addsd(xmm1, xmm6);\n-  unpckhpd(xmm6, xmm6);\n-  addsd(xmm1, xmm6);\n-  addsd(xmm4, xmm1);\n-  movsd(Address(rsp, 0), xmm4);\n-  fld_d(Address(rsp, 0));\n-  jmp(L_2TAG_PACKET_1_0_2);\n-\n-  bind(L_2TAG_PACKET_0_0_2);\n-  jcc(Assembler::greater, L_2TAG_PACKET_2_0_2);\n-  shrl(eax, 4);\n-  cmpl(eax, 268434685);\n-  jcc(Assembler::notEqual, L_2TAG_PACKET_3_0_2);\n-  movsd(Address(rsp, 0), xmm0);\n-  fld_d(Address(rsp, 0));\n-  jmp(L_2TAG_PACKET_1_0_2);\n-\n-  bind(L_2TAG_PACKET_3_0_2);\n-  movsd(xmm3, Address(ebx, 2192));\n-  mulsd(xmm3, xmm0);\n-  subsd(xmm3, xmm0);\n-  mulsd(xmm3, Address(ebx, 2208));\n-  movsd(Address(rsp, 0), xmm0);\n-  fld_d(Address(rsp, 0));\n-  jmp(L_2TAG_PACKET_1_0_2);\n-\n-  bind(L_2TAG_PACKET_2_0_2);\n-  movl(eax, Address(rsp, 132));\n-  andl(eax, 2146435072);\n-  cmpl(eax, 2146435072);\n-  jcc(Assembler::equal, L_2TAG_PACKET_4_0_2);\n-  subl(rsp, 32);\n-  movsd(Address(rsp, 0), xmm0);\n-  lea(eax, Address(rsp, 40));\n-  movl(Address(rsp, 8), eax);\n-  movl(eax, 2);\n-  movl(Address(rsp, 12), eax);\n-  call(RuntimeAddress(CAST_FROM_FN_PTR(address, StubRoutines::dlibm_sin_cos_huge())));\n-  addl(rsp, 32);\n-  fld_d(Address(rsp, 16));\n-  jmp(L_2TAG_PACKET_1_0_2);\n-  bind(L_2TAG_PACKET_4_0_2);\n-  fld_d(Address(rsp, 128));\n-  fmul_d(Address(ebx, 2240));\n-  bind(L_2TAG_PACKET_1_0_2);\n-  movl(ebx, Address(rsp, 56));\n-}\n-#endif \/\/ _LP64\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86_sin.cpp","additions":0,"deletions":2203,"binary":false,"changes":2203,"status":"deleted"},{"patch":"@@ -1,2093 +0,0 @@\n-\/*\n-* Copyright (c) 2016, 2021, Intel Corporation. All rights reserved.\n-* Intel Math Library (LIBM) Source Code\n-*\n-* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-*\n-* This code is free software; you can redistribute it and\/or modify it\n-* under the terms of the GNU General Public License version 2 only, as\n-* published by the Free Software Foundation.\n-*\n-* This code is distributed in the hope that it will be useful, but WITHOUT\n-* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-* FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-* version 2 for more details (a copy is included in the LICENSE file that\n-* accompanied this code).\n-*\n-* You should have received a copy of the GNU General Public License version\n-* 2 along with this work; if not, write to the Free Software Foundation,\n-* Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-*\n-* Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-* or visit www.oracle.com if you need additional information or have any\n-* questions.\n-*\n-*\/\n-\n-#include \"precompiled.hpp\"\n-#include \"asm\/assembler.hpp\"\n-#include \"asm\/assembler.inline.hpp\"\n-#include \"macroAssembler_x86.hpp\"\n-#include \"runtime\/stubRoutines.hpp\"\n-#include \"utilities\/globalDefinitions.hpp\"\n-\n-\/******************************************************************************\/\n-\/\/                     ALGORITHM DESCRIPTION - TAN()\n-\/\/                     ---------------------\n-\/\/\n-\/\/ Polynomials coefficients and other constants.\n-\/\/\n-\/\/ Note that in this algorithm, there is a different polynomial for\n-\/\/ each breakpoint, so there are 32 sets of polynomial coefficients\n-\/\/ as well as 32 instances of the other constants.\n-\/\/\n-\/\/ The polynomial coefficients and constants are offset from the start\n-\/\/ of the main block as follows:\n-\/\/\n-\/\/   0:  c8 | c0\n-\/\/  16:  c9 | c1\n-\/\/  32: c10 | c2\n-\/\/  48: c11 | c3\n-\/\/  64: c12 | c4\n-\/\/  80: c13 | c5\n-\/\/  96: c14 | c6\n-\/\/ 112: c15 | c7\n-\/\/ 128: T_hi\n-\/\/ 136: T_lo\n-\/\/ 144: Sigma\n-\/\/ 152: T_hl\n-\/\/ 160: Tau\n-\/\/ 168: Mask\n-\/\/ 176: (end of block)\n-\/\/\n-\/\/ The total table size is therefore 5632 bytes.\n-\/\/\n-\/\/ Note that c0 and c1 are always zero. We could try storing\n-\/\/ other constants here, and just loading the low part of the\n-\/\/ SIMD register in these cases, after ensuring the high part\n-\/\/ is zero.\n-\/\/\n-\/\/ The higher terms of the polynomial are computed in the *low*\n-\/\/ part of the SIMD register. This is so we can overlap the\n-\/\/ multiplication by r^8 and the unpacking of the other part.\n-\/\/\n-\/\/ The constants are:\n-\/\/ T_hi + T_lo = accurate constant term in power series\n-\/\/ Sigma + T_hl = accurate coefficient of r in power series (Sigma=1 bit)\n-\/\/ Tau = multiplier for the reciprocal, always -1 or 0\n-\/\/\n-\/\/ The basic reconstruction formula using these constants is:\n-\/\/\n-\/\/ High = tau * recip_hi + t_hi\n-\/\/ Med = (sgn * r + t_hl * r)_hi\n-\/\/ Low = (sgn * r + t_hl * r)_lo +\n-\/\/       tau * recip_lo + T_lo + (T_hl + sigma) * c + pol\n-\/\/\n-\/\/ where pol = c0 + c1 * r + c2 * r^2 + ... + c15 * r^15\n-\/\/\n-\/\/ (c0 = c1 = 0, but using them keeps SIMD regularity)\n-\/\/\n-\/\/ We then do a compensated sum High + Med, add the low parts together\n-\/\/ and then do the final sum.\n-\/\/\n-\/\/ Here recip_hi + recip_lo is an accurate reciprocal of the remainder\n-\/\/ modulo pi\/2\n-\/\/\n-\/\/ Special cases:\n-\/\/  tan(NaN) = quiet NaN, and raise invalid exception\n-\/\/  tan(INF) = NaN and raise invalid exception\n-\/\/  tan(+\/-0) = +\/-0\n-\/\/\n-\/******************************************************************************\/\n-\n-#ifdef _LP64\n-\/\/ The 64 bit code is at most SSE2 compliant\n-\n-ATTRIBUTE_ALIGNED(16) juint _MUL16[] =\n-{\n-    0x00000000UL, 0x40300000UL, 0x00000000UL, 0x3ff00000UL\n-};\n-\n-ATTRIBUTE_ALIGNED(16) juint _sign_mask_tan[] =\n-{\n-    0x00000000UL, 0x80000000UL, 0x00000000UL, 0x80000000UL\n-};\n-\n-ATTRIBUTE_ALIGNED(16) juint _PI32INV_tan[] =\n-{\n-    0x6dc9c883UL, 0x3fe45f30UL, 0x6dc9c883UL, 0x40245f30UL\n-};\n-\n-ATTRIBUTE_ALIGNED(16) juint _P_1_tan[] =\n-{\n-    0x54444000UL, 0x3fb921fbUL, 0x54440000UL, 0x3fb921fbUL\n-};\n-\n-ATTRIBUTE_ALIGNED(16) juint _P_2_tan[] =\n-{\n-    0x67674000UL, 0xbd32e7b9UL, 0x4c4c0000UL, 0x3d468c23UL\n-};\n-\n-ATTRIBUTE_ALIGNED(16) juint _P_3_tan[] =\n-{\n-    0x3707344aUL, 0x3aa8a2e0UL, 0x03707345UL, 0x3ae98a2eUL\n-};\n-\n-ATTRIBUTE_ALIGNED(16) juint _Ctable_tan[] =\n-{\n-    0x00000000UL, 0x00000000UL, 0x00000000UL, 0x00000000UL, 0x882c10faUL,\n-    0x3f9664f4UL, 0x00000000UL, 0x00000000UL, 0x00000000UL, 0x00000000UL,\n-    0x00000000UL, 0x00000000UL, 0x55e6c23dUL, 0x3f8226e3UL, 0x55555555UL,\n-    0x3fd55555UL, 0x00000000UL, 0x00000000UL, 0x00000000UL, 0x00000000UL,\n-    0x0e157de0UL, 0x3f6d6d3dUL, 0x11111111UL, 0x3fc11111UL, 0x00000000UL,\n-    0x00000000UL, 0x00000000UL, 0x00000000UL, 0x452b75e3UL, 0x3f57da36UL,\n-    0x1ba1ba1cUL, 0x3faba1baUL, 0x00000000UL, 0x00000000UL, 0x00000000UL,\n-    0x00000000UL, 0x00000000UL, 0x3ff00000UL, 0x00000000UL, 0x00000000UL,\n-    0x00000000UL, 0x00000000UL, 0x00000000UL, 0x00000000UL, 0x4e435f9bUL,\n-    0x3f953f83UL, 0x00000000UL, 0x00000000UL, 0x3c6e8e46UL, 0x3f9b74eaUL,\n-    0x00000000UL, 0x00000000UL, 0xda5b7511UL, 0x3f85ad63UL, 0xdc230b9bUL,\n-    0x3fb97558UL, 0x26cb3788UL, 0x3f881308UL, 0x76fc4985UL, 0x3fd62ac9UL,\n-    0x77bb08baUL, 0x3f757c85UL, 0xb6247521UL, 0x3fb1381eUL, 0x5922170cUL,\n-    0x3f754e95UL, 0x8746482dUL, 0x3fc27f83UL, 0x11055b30UL, 0x3f64e391UL,\n-    0x3e666320UL, 0x3fa3e609UL, 0x0de9dae3UL, 0x3f6301dfUL, 0x1f1dca06UL,\n-    0x3fafa8aeUL, 0x8c5b2da2UL, 0x3fb936bbUL, 0x4e88f7a5UL, 0x3c587d05UL,\n-    0x00000000UL, 0x3ff00000UL, 0xa8935dd9UL, 0x3f83dde2UL, 0x00000000UL,\n-    0x00000000UL, 0x00000000UL, 0x00000000UL, 0x5a279ea3UL, 0x3faa3407UL,\n-    0x00000000UL, 0x00000000UL, 0x432d65faUL, 0x3fa70153UL, 0x00000000UL,\n-    0x00000000UL, 0x891a4602UL, 0x3f9d03efUL, 0xd62ca5f8UL, 0x3fca77d9UL,\n-    0xb35f4628UL, 0x3f97a265UL, 0x433258faUL, 0x3fd8cf51UL, 0xb58fd909UL,\n-    0x3f8f88e3UL, 0x01771ceaUL, 0x3fc2b154UL, 0xf3562f8eUL, 0x3f888f57UL,\n-    0xc028a723UL, 0x3fc7370fUL, 0x20b7f9f0UL, 0x3f80f44cUL, 0x214368e9UL,\n-    0x3fb6dfaaUL, 0x28891863UL, 0x3f79b4b6UL, 0x172dbbf0UL, 0x3fb6cb8eUL,\n-    0xe0553158UL, 0x3fc975f5UL, 0x593fe814UL, 0x3c2ef5d3UL, 0x00000000UL,\n-    0x3ff00000UL, 0x03dec550UL, 0x3fa44203UL, 0x00000000UL, 0x00000000UL,\n-    0x00000000UL, 0x00000000UL, 0x9314533eUL, 0x3fbb8ec5UL, 0x00000000UL,\n-    0x00000000UL, 0x09aa36d0UL, 0x3fb6d3f4UL, 0x00000000UL, 0x00000000UL,\n-    0xdcb427fdUL, 0x3fb13950UL, 0xd87ab0bbUL, 0x3fd5335eUL, 0xce0ae8a5UL,\n-    0x3fabb382UL, 0x79143126UL, 0x3fddba41UL, 0x5f2b28d4UL, 0x3fa552f1UL,\n-    0x59f21a6dUL, 0x3fd015abUL, 0x22c27d95UL, 0x3fa0e984UL, 0xe19fc6aaUL,\n-    0x3fd0576cUL, 0x8f2c2950UL, 0x3f9a4898UL, 0xc0b3f22cUL, 0x3fc59462UL,\n-    0x1883a4b8UL, 0x3f94b61cUL, 0x3f838640UL, 0x3fc30eb8UL, 0x355c63dcUL,\n-    0x3fd36a08UL, 0x1dce993dUL, 0xbc6d704dUL, 0x00000000UL, 0x3ff00000UL,\n-    0x2b82ab63UL, 0x3fb78e92UL, 0x00000000UL, 0x00000000UL, 0x00000000UL,\n-    0x00000000UL, 0x56f37042UL, 0x3fccfc56UL, 0x00000000UL, 0x00000000UL,\n-    0xaa563951UL, 0x3fc90125UL, 0x00000000UL, 0x00000000UL, 0x3d0e7c5dUL,\n-    0x3fc50533UL, 0x9bed9b2eUL, 0x3fdf0ed9UL, 0x5fe7c47cUL, 0x3fc1f250UL,\n-    0x96c125e5UL, 0x3fe2edd9UL, 0x5a02bbd8UL, 0x3fbe5c71UL, 0x86362c20UL,\n-    0x3fda08b7UL, 0x4b4435edUL, 0x3fb9d342UL, 0x4b494091UL, 0x3fd911bdUL,\n-    0xb56658beUL, 0x3fb5e4c7UL, 0x93a2fd76UL, 0x3fd3c092UL, 0xda271794UL,\n-    0x3fb29910UL, 0x3303df2bUL, 0x3fd189beUL, 0x99fcef32UL, 0x3fda8279UL,\n-    0xb68c1467UL, 0x3c708b2fUL, 0x00000000UL, 0x3ff00000UL, 0x980c4337UL,\n-    0x3fc5f619UL, 0x00000000UL, 0x00000000UL, 0x00000000UL, 0x00000000UL,\n-    0xcc03e501UL, 0x3fdff10fUL, 0x00000000UL, 0x00000000UL, 0x44a4e845UL,\n-    0x3fddb63bUL, 0x00000000UL, 0x00000000UL, 0x3768ad9fUL, 0x3fdb72a4UL,\n-    0x3dd01ccaUL, 0x3fe5fdb9UL, 0xa61d2811UL, 0x3fd972b2UL, 0x5645ad0bUL,\n-    0x3fe977f9UL, 0xd013b3abUL, 0x3fd78ca3UL, 0xbf0bf914UL, 0x3fe4f192UL,\n-    0x4d53e730UL, 0x3fd5d060UL, 0x3f8b9000UL, 0x3fe49933UL, 0xe2b82f08UL,\n-    0x3fd4322aUL, 0x5936a835UL, 0x3fe27ae1UL, 0xb1c61c9bUL, 0x3fd2b3fbUL,\n-    0xef478605UL, 0x3fe1659eUL, 0x190834ecUL, 0x3fe11ab7UL, 0xcdb625eaUL,\n-    0xbc8e564bUL, 0x00000000UL, 0x3ff00000UL, 0xb07217e3UL, 0x3fd248f1UL,\n-    0x00000000UL, 0x00000000UL, 0x00000000UL, 0x00000000UL, 0x2b2c49d0UL,\n-    0x3ff2de9cUL, 0x00000000UL, 0x00000000UL, 0x2655bc98UL, 0x3ff33e58UL,\n-    0x00000000UL, 0x00000000UL, 0xff691fa2UL, 0x3ff3972eUL, 0xe93463bdUL,\n-    0x3feeed87UL, 0x070e10a0UL, 0x3ff3f5b2UL, 0xf4d790a4UL, 0x3ff20c10UL,\n-    0xa04e8ea3UL, 0x3ff4541aUL, 0x386accd3UL, 0x3ff1369eUL, 0x222a66ddUL,\n-    0x3ff4b521UL, 0x22a9777eUL, 0x3ff20817UL, 0x52a04a6eUL, 0x3ff5178fUL,\n-    0xddaa0031UL, 0x3ff22137UL, 0x4447d47cUL, 0x3ff57c01UL, 0x1e9c7f1dUL,\n-    0x3ff29311UL, 0x2ab7f990UL, 0x3fe561b8UL, 0x209c7df1UL, 0x3c87a8c5UL,\n-    0x00000000UL, 0x3ff00000UL, 0x4170bcc6UL, 0x3fdc92d8UL, 0x00000000UL,\n-    0x00000000UL, 0x00000000UL, 0x00000000UL, 0xc7ab4d5aUL, 0x40085e24UL,\n-    0x00000000UL, 0x00000000UL, 0xe93ea75dUL, 0x400b963dUL, 0x00000000UL,\n-    0x00000000UL, 0x94a7f25aUL, 0x400f37e2UL, 0x4b6261cbUL, 0x3ff5f984UL,\n-    0x5a9dd812UL, 0x4011aab0UL, 0x74c30018UL, 0x3ffaf5a5UL, 0x7f2ce8e3UL,\n-    0x4013fe8bUL, 0xfe8e54faUL, 0x3ffd7334UL, 0x670d618dUL, 0x4016a10cUL,\n-    0x4db97058UL, 0x4000e012UL, 0x24df44ddUL, 0x40199c5fUL, 0x697d6eceUL,\n-    0x4003006eUL, 0x83298b82UL, 0x401cfc4dUL, 0x19d490d6UL, 0x40058c19UL,\n-    0x2ae42850UL, 0x3fea4300UL, 0x118e20e6UL, 0xbc7a6db8UL, 0x00000000UL,\n-    0x40000000UL, 0xe33345b8UL, 0xbfd4e526UL, 0x00000000UL, 0x00000000UL,\n-    0x00000000UL, 0x00000000UL, 0x65965966UL, 0x40219659UL, 0x00000000UL,\n-    0x00000000UL, 0x882c10faUL, 0x402664f4UL, 0x00000000UL, 0x00000000UL,\n-    0x83cd3723UL, 0x402c8342UL, 0x00000000UL, 0x40000000UL, 0x55e6c23dUL,\n-    0x403226e3UL, 0x55555555UL, 0x40055555UL, 0x34451939UL, 0x40371c96UL,\n-    0xaaaaaaabUL, 0x400aaaaaUL, 0x0e157de0UL, 0x403d6d3dUL, 0x11111111UL,\n-    0x40111111UL, 0xa738201fUL, 0x4042bbceUL, 0x05b05b06UL, 0x4015b05bUL,\n-    0x452b75e3UL, 0x4047da36UL, 0x1ba1ba1cUL, 0x401ba1baUL, 0x00000000UL,\n-    0x3ff00000UL, 0x00000000UL, 0x00000000UL, 0x00000000UL, 0x40000000UL,\n-    0x00000000UL, 0x00000000UL, 0x00000000UL, 0x00000000UL, 0x00000000UL,\n-    0x00000000UL, 0x4f48b8d3UL, 0xbf33eaf9UL, 0x00000000UL, 0x00000000UL,\n-    0x0cf7586fUL, 0x3f20b8eaUL, 0x00000000UL, 0x00000000UL, 0xd0258911UL,\n-    0xbf0abaf3UL, 0x23e49fe9UL, 0xbfab5a8cUL, 0x2d53222eUL, 0x3ef60d15UL,\n-    0x21169451UL, 0x3fa172b2UL, 0xbb254dbcUL, 0xbee1d3b5UL, 0xdbf93b8eUL,\n-    0xbf84c7dbUL, 0x05b4630bUL, 0x3ecd3364UL, 0xee9aada7UL, 0x3f743924UL,\n-    0x794a8297UL, 0xbeb7b7b9UL, 0xe015f797UL, 0xbf5d41f5UL, 0xe41a4a56UL,\n-    0x3ea35dfbUL, 0xe4c2a251UL, 0x3f49a2abUL, 0x5af9e000UL, 0xbfce49ceUL,\n-    0x8c743719UL, 0x3d1eb860UL, 0x00000000UL, 0x00000000UL, 0x1b4863cfUL,\n-    0x3fd78294UL, 0x00000000UL, 0x3ff00000UL, 0x00000000UL, 0xfffffff8UL,\n-    0x535ad890UL, 0xbf2b9320UL, 0x00000000UL, 0x00000000UL, 0x018fdf1fUL,\n-    0x3f16d61dUL, 0x00000000UL, 0x00000000UL, 0x0359f1beUL, 0xbf0139e4UL,\n-    0xa4317c6dUL, 0xbfa67e17UL, 0x82672d0fUL, 0x3eebb405UL, 0x2f1b621eUL,\n-    0x3f9f455bUL, 0x51ccf238UL, 0xbed55317UL, 0xf437b9acUL, 0xbf804beeUL,\n-    0xc791a2b5UL, 0x3ec0e993UL, 0x919a1db2UL, 0x3f7080c2UL, 0x336a5b0eUL,\n-    0xbeaa48a2UL, 0x0a268358UL, 0xbf55a443UL, 0xdfd978e4UL, 0x3e94b61fUL,\n-    0xd7767a58UL, 0x3f431806UL, 0x2aea0000UL, 0xbfc9bbe8UL, 0x7723ea61UL,\n-    0xbd3a2369UL, 0x00000000UL, 0x00000000UL, 0xdf7796ffUL, 0x3fd6e642UL,\n-    0x00000000UL, 0x3ff00000UL, 0x00000000UL, 0xfffffff8UL, 0xb9ff07ceUL,\n-    0xbf231c78UL, 0x00000000UL, 0x00000000UL, 0xa5517182UL, 0x3f0ff0e0UL,\n-    0x00000000UL, 0x00000000UL, 0x790b4cbcUL, 0xbef66191UL, 0x848a46c6UL,\n-    0xbfa21ac0UL, 0xb16435faUL, 0x3ee1d3ecUL, 0x2a1aa832UL, 0x3f9c71eaUL,\n-    0xfdd299efUL, 0xbec9dd1aUL, 0x3f8dbaafUL, 0xbf793363UL, 0x309fc6eaUL,\n-    0x3eb415d6UL, 0xbee60471UL, 0x3f6b83baUL, 0x94a0a697UL, 0xbe9dae11UL,\n-    0x3e5c67b3UL, 0xbf4fd07bUL, 0x9a8f3e3eUL, 0x3e86bd75UL, 0xa4beb7a4UL,\n-    0x3f3d1eb1UL, 0x29cfc000UL, 0xbfc549ceUL, 0xbf159358UL, 0xbd397b33UL,\n-    0x00000000UL, 0x00000000UL, 0x871fee6cUL, 0x3fd666f0UL, 0x00000000UL,\n-    0x3ff00000UL, 0x00000000UL, 0xfffffff8UL, 0x7d98a556UL, 0xbf1a3958UL,\n-    0x00000000UL, 0x00000000UL, 0x9d88dc01UL, 0x3f0704c2UL, 0x00000000UL,\n-    0x00000000UL, 0x73742a2bUL, 0xbeed054aUL, 0x58844587UL, 0xbf9c2a13UL,\n-    0x55688a79UL, 0x3ed7a326UL, 0xee33f1d6UL, 0x3f9a48f4UL, 0xa8dc9888UL,\n-    0xbebf8939UL, 0xaad4b5b8UL, 0xbf72f746UL, 0x9102efa1UL, 0x3ea88f82UL,\n-    0xdabc29cfUL, 0x3f678228UL, 0x9289afb8UL, 0xbe90f456UL, 0x741fb4edUL,\n-    0xbf46f3a3UL, 0xa97f6663UL, 0x3e79b4bfUL, 0xca89ff3fUL, 0x3f36db70UL,\n-    0xa8a2a000UL, 0xbfc0ee13UL, 0x3da24be1UL, 0xbd338b9fUL, 0x00000000UL,\n-    0x00000000UL, 0x11cd6c69UL, 0x3fd601fdUL, 0x00000000UL, 0x3ff00000UL,\n-    0x00000000UL, 0xfffffff8UL, 0x1a154b97UL, 0xbf116b01UL, 0x00000000UL,\n-    0x00000000UL, 0x2d427630UL, 0x3f0147bfUL, 0x00000000UL, 0x00000000UL,\n-    0xb93820c8UL, 0xbee264d4UL, 0xbb6cbb18UL, 0xbf94ab8cUL, 0x888d4d92UL,\n-    0x3ed0568bUL, 0x60730f7cUL, 0x3f98b19bUL, 0xe4b1fb11UL, 0xbeb2f950UL,\n-    0x22cf9f74UL, 0xbf6b21cdUL, 0x4a3ff0a6UL, 0x3e9f499eUL, 0xfd2b83ceUL,\n-    0x3f64aad7UL, 0x637b73afUL, 0xbe83487cUL, 0xe522591aUL, 0xbf3fc092UL,\n-    0xa158e8bcUL, 0x3e6e3aaeUL, 0xe5e82ffaUL, 0x3f329d2fUL, 0xd636a000UL,\n-    0xbfb9477fUL, 0xc2c2d2bcUL, 0xbd135ef9UL, 0x00000000UL, 0x00000000UL,\n-    0xf2fdb123UL, 0x3fd5b566UL, 0x00000000UL, 0x3ff00000UL, 0x00000000UL,\n-    0xfffffff8UL, 0xc41acb64UL, 0xbf05448dUL, 0x00000000UL, 0x00000000UL,\n-    0xdbb03d6fUL, 0x3efb7ad2UL, 0x00000000UL, 0x00000000UL, 0x9e42962dUL,\n-    0xbed5aea5UL, 0x2579f8efUL, 0xbf8b2398UL, 0x288a1ed9UL, 0x3ec81441UL,\n-    0xb0198dc5UL, 0x3f979a3aUL, 0x2fdfe253UL, 0xbea57cd3UL, 0x5766336fUL,\n-    0xbf617caaUL, 0x600944c3UL, 0x3e954ed6UL, 0xa4e0aaf8UL, 0x3f62c646UL,\n-    0x6b8fb29cUL, 0xbe74e3a3UL, 0xdc4c0409UL, 0xbf33f952UL, 0x9bffe365UL,\n-    0x3e6301ecUL, 0xb8869e44UL, 0x3f2fc566UL, 0xe1e04000UL, 0xbfb0cc62UL,\n-    0x016b907fUL, 0xbd119cbcUL, 0x00000000UL, 0x00000000UL, 0xe6b9d8faUL,\n-    0x3fd57fb3UL, 0x00000000UL, 0x3ff00000UL, 0x00000000UL, 0xfffffff8UL,\n-    0x5daf22a6UL, 0xbef429d7UL, 0x00000000UL, 0x00000000UL, 0x06bca545UL,\n-    0x3ef7a27dUL, 0x00000000UL, 0x00000000UL, 0x7211c19aUL, 0xbec41c3eUL,\n-    0x956ed53eUL, 0xbf7ae3f4UL, 0xee750e72UL, 0x3ec3901bUL, 0x91d443f5UL,\n-    0x3f96f713UL, 0x36661e6cUL, 0xbe936e09UL, 0x506f9381UL, 0xbf5122e8UL,\n-    0xcb6dd43fUL, 0x3e9041b9UL, 0x6698b2ffUL, 0x3f61b0c7UL, 0x576bf12bUL,\n-    0xbe625a8aUL, 0xe5a0e9dcUL, 0xbf23499dUL, 0x110384ddUL, 0x3e5b1c2cUL,\n-    0x68d43db6UL, 0x3f2cb899UL, 0x6ecac000UL, 0xbfa0c414UL, 0xcd7dd58cUL,\n-    0x3d13500fUL, 0x00000000UL, 0x00000000UL, 0x85a2c8fbUL, 0x3fd55fe0UL,\n-    0x00000000UL, 0x3ff00000UL, 0x00000000UL, 0xfffffff8UL, 0x00000000UL,\n-    0x00000000UL, 0x00000000UL, 0x00000000UL, 0x2bf70ebeUL, 0x3ef66a8fUL,\n-    0x00000000UL, 0x00000000UL, 0x00000000UL, 0x00000000UL, 0x00000000UL,\n-    0x00000000UL, 0xd644267fUL, 0x3ec22805UL, 0x16c16c17UL, 0x3f96c16cUL,\n-    0x00000000UL, 0x00000000UL, 0x00000000UL, 0x00000000UL, 0xc4e09162UL,\n-    0x3e8d6db2UL, 0xbc011567UL, 0x3f61566aUL, 0x00000000UL, 0x00000000UL,\n-    0x00000000UL, 0x00000000UL, 0x1f79955cUL, 0x3e57da4eUL, 0x9334ef0bUL,\n-    0x3f2bbd77UL, 0x00000000UL, 0x00000000UL, 0x00000000UL, 0x00000000UL,\n-    0x00000000UL, 0x00000000UL, 0x55555555UL, 0x3fd55555UL, 0x00000000UL,\n-    0x3ff00000UL, 0x00000000UL, 0xfffffff8UL, 0x5daf22a6UL, 0x3ef429d7UL,\n-    0x00000000UL, 0x00000000UL, 0x06bca545UL, 0x3ef7a27dUL, 0x00000000UL,\n-    0x00000000UL, 0x7211c19aUL, 0x3ec41c3eUL, 0x956ed53eUL, 0x3f7ae3f4UL,\n-    0xee750e72UL, 0x3ec3901bUL, 0x91d443f5UL, 0x3f96f713UL, 0x36661e6cUL,\n-    0x3e936e09UL, 0x506f9381UL, 0x3f5122e8UL, 0xcb6dd43fUL, 0x3e9041b9UL,\n-    0x6698b2ffUL, 0x3f61b0c7UL, 0x576bf12bUL, 0x3e625a8aUL, 0xe5a0e9dcUL,\n-    0x3f23499dUL, 0x110384ddUL, 0x3e5b1c2cUL, 0x68d43db6UL, 0x3f2cb899UL,\n-    0x6ecac000UL, 0x3fa0c414UL, 0xcd7dd58cUL, 0xbd13500fUL, 0x00000000UL,\n-    0x00000000UL, 0x85a2c8fbUL, 0x3fd55fe0UL, 0x00000000UL, 0x3ff00000UL,\n-    0x00000000UL, 0xfffffff8UL, 0xc41acb64UL, 0x3f05448dUL, 0x00000000UL,\n-    0x00000000UL, 0xdbb03d6fUL, 0x3efb7ad2UL, 0x00000000UL, 0x00000000UL,\n-    0x9e42962dUL, 0x3ed5aea5UL, 0x2579f8efUL, 0x3f8b2398UL, 0x288a1ed9UL,\n-    0x3ec81441UL, 0xb0198dc5UL, 0x3f979a3aUL, 0x2fdfe253UL, 0x3ea57cd3UL,\n-    0x5766336fUL, 0x3f617caaUL, 0x600944c3UL, 0x3e954ed6UL, 0xa4e0aaf8UL,\n-    0x3f62c646UL, 0x6b8fb29cUL, 0x3e74e3a3UL, 0xdc4c0409UL, 0x3f33f952UL,\n-    0x9bffe365UL, 0x3e6301ecUL, 0xb8869e44UL, 0x3f2fc566UL, 0xe1e04000UL,\n-    0x3fb0cc62UL, 0x016b907fUL, 0x3d119cbcUL, 0x00000000UL, 0x00000000UL,\n-    0xe6b9d8faUL, 0x3fd57fb3UL, 0x00000000UL, 0x3ff00000UL, 0x00000000UL,\n-    0xfffffff8UL, 0x1a154b97UL, 0x3f116b01UL, 0x00000000UL, 0x00000000UL,\n-    0x2d427630UL, 0x3f0147bfUL, 0x00000000UL, 0x00000000UL, 0xb93820c8UL,\n-    0x3ee264d4UL, 0xbb6cbb18UL, 0x3f94ab8cUL, 0x888d4d92UL, 0x3ed0568bUL,\n-    0x60730f7cUL, 0x3f98b19bUL, 0xe4b1fb11UL, 0x3eb2f950UL, 0x22cf9f74UL,\n-    0x3f6b21cdUL, 0x4a3ff0a6UL, 0x3e9f499eUL, 0xfd2b83ceUL, 0x3f64aad7UL,\n-    0x637b73afUL, 0x3e83487cUL, 0xe522591aUL, 0x3f3fc092UL, 0xa158e8bcUL,\n-    0x3e6e3aaeUL, 0xe5e82ffaUL, 0x3f329d2fUL, 0xd636a000UL, 0x3fb9477fUL,\n-    0xc2c2d2bcUL, 0x3d135ef9UL, 0x00000000UL, 0x00000000UL, 0xf2fdb123UL,\n-    0x3fd5b566UL, 0x00000000UL, 0x3ff00000UL, 0x00000000UL, 0xfffffff8UL,\n-    0x7d98a556UL, 0x3f1a3958UL, 0x00000000UL, 0x00000000UL, 0x9d88dc01UL,\n-    0x3f0704c2UL, 0x00000000UL, 0x00000000UL, 0x73742a2bUL, 0x3eed054aUL,\n-    0x58844587UL, 0x3f9c2a13UL, 0x55688a79UL, 0x3ed7a326UL, 0xee33f1d6UL,\n-    0x3f9a48f4UL, 0xa8dc9888UL, 0x3ebf8939UL, 0xaad4b5b8UL, 0x3f72f746UL,\n-    0x9102efa1UL, 0x3ea88f82UL, 0xdabc29cfUL, 0x3f678228UL, 0x9289afb8UL,\n-    0x3e90f456UL, 0x741fb4edUL, 0x3f46f3a3UL, 0xa97f6663UL, 0x3e79b4bfUL,\n-    0xca89ff3fUL, 0x3f36db70UL, 0xa8a2a000UL, 0x3fc0ee13UL, 0x3da24be1UL,\n-    0x3d338b9fUL, 0x00000000UL, 0x00000000UL, 0x11cd6c69UL, 0x3fd601fdUL,\n-    0x00000000UL, 0x3ff00000UL, 0x00000000UL, 0xfffffff8UL, 0xb9ff07ceUL,\n-    0x3f231c78UL, 0x00000000UL, 0x00000000UL, 0xa5517182UL, 0x3f0ff0e0UL,\n-    0x00000000UL, 0x00000000UL, 0x790b4cbcUL, 0x3ef66191UL, 0x848a46c6UL,\n-    0x3fa21ac0UL, 0xb16435faUL, 0x3ee1d3ecUL, 0x2a1aa832UL, 0x3f9c71eaUL,\n-    0xfdd299efUL, 0x3ec9dd1aUL, 0x3f8dbaafUL, 0x3f793363UL, 0x309fc6eaUL,\n-    0x3eb415d6UL, 0xbee60471UL, 0x3f6b83baUL, 0x94a0a697UL, 0x3e9dae11UL,\n-    0x3e5c67b3UL, 0x3f4fd07bUL, 0x9a8f3e3eUL, 0x3e86bd75UL, 0xa4beb7a4UL,\n-    0x3f3d1eb1UL, 0x29cfc000UL, 0x3fc549ceUL, 0xbf159358UL, 0x3d397b33UL,\n-    0x00000000UL, 0x00000000UL, 0x871fee6cUL, 0x3fd666f0UL, 0x00000000UL,\n-    0x3ff00000UL, 0x00000000UL, 0xfffffff8UL, 0x535ad890UL, 0x3f2b9320UL,\n-    0x00000000UL, 0x00000000UL, 0x018fdf1fUL, 0x3f16d61dUL, 0x00000000UL,\n-    0x00000000UL, 0x0359f1beUL, 0x3f0139e4UL, 0xa4317c6dUL, 0x3fa67e17UL,\n-    0x82672d0fUL, 0x3eebb405UL, 0x2f1b621eUL, 0x3f9f455bUL, 0x51ccf238UL,\n-    0x3ed55317UL, 0xf437b9acUL, 0x3f804beeUL, 0xc791a2b5UL, 0x3ec0e993UL,\n-    0x919a1db2UL, 0x3f7080c2UL, 0x336a5b0eUL, 0x3eaa48a2UL, 0x0a268358UL,\n-    0x3f55a443UL, 0xdfd978e4UL, 0x3e94b61fUL, 0xd7767a58UL, 0x3f431806UL,\n-    0x2aea0000UL, 0x3fc9bbe8UL, 0x7723ea61UL, 0x3d3a2369UL, 0x00000000UL,\n-    0x00000000UL, 0xdf7796ffUL, 0x3fd6e642UL, 0x00000000UL, 0x3ff00000UL,\n-    0x00000000UL, 0xfffffff8UL, 0x4f48b8d3UL, 0x3f33eaf9UL, 0x00000000UL,\n-    0x00000000UL, 0x0cf7586fUL, 0x3f20b8eaUL, 0x00000000UL, 0x00000000UL,\n-    0xd0258911UL, 0x3f0abaf3UL, 0x23e49fe9UL, 0x3fab5a8cUL, 0x2d53222eUL,\n-    0x3ef60d15UL, 0x21169451UL, 0x3fa172b2UL, 0xbb254dbcUL, 0x3ee1d3b5UL,\n-    0xdbf93b8eUL, 0x3f84c7dbUL, 0x05b4630bUL, 0x3ecd3364UL, 0xee9aada7UL,\n-    0x3f743924UL, 0x794a8297UL, 0x3eb7b7b9UL, 0xe015f797UL, 0x3f5d41f5UL,\n-    0xe41a4a56UL, 0x3ea35dfbUL, 0xe4c2a251UL, 0x3f49a2abUL, 0x5af9e000UL,\n-    0x3fce49ceUL, 0x8c743719UL, 0xbd1eb860UL, 0x00000000UL, 0x00000000UL,\n-    0x1b4863cfUL, 0x3fd78294UL, 0x00000000UL, 0x3ff00000UL, 0x00000000UL,\n-    0xfffffff8UL, 0x65965966UL, 0xc0219659UL, 0x00000000UL, 0x00000000UL,\n-    0x882c10faUL, 0x402664f4UL, 0x00000000UL, 0x00000000UL, 0x83cd3723UL,\n-    0xc02c8342UL, 0x00000000UL, 0xc0000000UL, 0x55e6c23dUL, 0x403226e3UL,\n-    0x55555555UL, 0x40055555UL, 0x34451939UL, 0xc0371c96UL, 0xaaaaaaabUL,\n-    0xc00aaaaaUL, 0x0e157de0UL, 0x403d6d3dUL, 0x11111111UL, 0x40111111UL,\n-    0xa738201fUL, 0xc042bbceUL, 0x05b05b06UL, 0xc015b05bUL, 0x452b75e3UL,\n-    0x4047da36UL, 0x1ba1ba1cUL, 0x401ba1baUL, 0x00000000UL, 0xbff00000UL,\n-    0x00000000UL, 0x00000000UL, 0x00000000UL, 0x40000000UL, 0x00000000UL,\n-    0x00000000UL, 0x00000000UL, 0x00000000UL, 0x00000000UL, 0x00000000UL,\n-    0xc7ab4d5aUL, 0xc0085e24UL, 0x00000000UL, 0x00000000UL, 0xe93ea75dUL,\n-    0x400b963dUL, 0x00000000UL, 0x00000000UL, 0x94a7f25aUL, 0xc00f37e2UL,\n-    0x4b6261cbUL, 0xbff5f984UL, 0x5a9dd812UL, 0x4011aab0UL, 0x74c30018UL,\n-    0x3ffaf5a5UL, 0x7f2ce8e3UL, 0xc013fe8bUL, 0xfe8e54faUL, 0xbffd7334UL,\n-    0x670d618dUL, 0x4016a10cUL, 0x4db97058UL, 0x4000e012UL, 0x24df44ddUL,\n-    0xc0199c5fUL, 0x697d6eceUL, 0xc003006eUL, 0x83298b82UL, 0x401cfc4dUL,\n-    0x19d490d6UL, 0x40058c19UL, 0x2ae42850UL, 0xbfea4300UL, 0x118e20e6UL,\n-    0x3c7a6db8UL, 0x00000000UL, 0x40000000UL, 0xe33345b8UL, 0xbfd4e526UL,\n-    0x00000000UL, 0x00000000UL, 0x00000000UL, 0x00000000UL, 0x2b2c49d0UL,\n-    0xbff2de9cUL, 0x00000000UL, 0x00000000UL, 0x2655bc98UL, 0x3ff33e58UL,\n-    0x00000000UL, 0x00000000UL, 0xff691fa2UL, 0xbff3972eUL, 0xe93463bdUL,\n-    0xbfeeed87UL, 0x070e10a0UL, 0x3ff3f5b2UL, 0xf4d790a4UL, 0x3ff20c10UL,\n-    0xa04e8ea3UL, 0xbff4541aUL, 0x386accd3UL, 0xbff1369eUL, 0x222a66ddUL,\n-    0x3ff4b521UL, 0x22a9777eUL, 0x3ff20817UL, 0x52a04a6eUL, 0xbff5178fUL,\n-    0xddaa0031UL, 0xbff22137UL, 0x4447d47cUL, 0x3ff57c01UL, 0x1e9c7f1dUL,\n-    0x3ff29311UL, 0x2ab7f990UL, 0xbfe561b8UL, 0x209c7df1UL, 0xbc87a8c5UL,\n-    0x00000000UL, 0x3ff00000UL, 0x4170bcc6UL, 0x3fdc92d8UL, 0x00000000UL,\n-    0x00000000UL, 0x00000000UL, 0x00000000UL, 0xcc03e501UL, 0xbfdff10fUL,\n-    0x00000000UL, 0x00000000UL, 0x44a4e845UL, 0x3fddb63bUL, 0x00000000UL,\n-    0x00000000UL, 0x3768ad9fUL, 0xbfdb72a4UL, 0x3dd01ccaUL, 0xbfe5fdb9UL,\n-    0xa61d2811UL, 0x3fd972b2UL, 0x5645ad0bUL, 0x3fe977f9UL, 0xd013b3abUL,\n-    0xbfd78ca3UL, 0xbf0bf914UL, 0xbfe4f192UL, 0x4d53e730UL, 0x3fd5d060UL,\n-    0x3f8b9000UL, 0x3fe49933UL, 0xe2b82f08UL, 0xbfd4322aUL, 0x5936a835UL,\n-    0xbfe27ae1UL, 0xb1c61c9bUL, 0x3fd2b3fbUL, 0xef478605UL, 0x3fe1659eUL,\n-    0x190834ecUL, 0xbfe11ab7UL, 0xcdb625eaUL, 0x3c8e564bUL, 0x00000000UL,\n-    0x3ff00000UL, 0xb07217e3UL, 0x3fd248f1UL, 0x00000000UL, 0x00000000UL,\n-    0x00000000UL, 0x00000000UL, 0x56f37042UL, 0xbfccfc56UL, 0x00000000UL,\n-    0x00000000UL, 0xaa563951UL, 0x3fc90125UL, 0x00000000UL, 0x00000000UL,\n-    0x3d0e7c5dUL, 0xbfc50533UL, 0x9bed9b2eUL, 0xbfdf0ed9UL, 0x5fe7c47cUL,\n-    0x3fc1f250UL, 0x96c125e5UL, 0x3fe2edd9UL, 0x5a02bbd8UL, 0xbfbe5c71UL,\n-    0x86362c20UL, 0xbfda08b7UL, 0x4b4435edUL, 0x3fb9d342UL, 0x4b494091UL,\n-    0x3fd911bdUL, 0xb56658beUL, 0xbfb5e4c7UL, 0x93a2fd76UL, 0xbfd3c092UL,\n-    0xda271794UL, 0x3fb29910UL, 0x3303df2bUL, 0x3fd189beUL, 0x99fcef32UL,\n-    0xbfda8279UL, 0xb68c1467UL, 0xbc708b2fUL, 0x00000000UL, 0x3ff00000UL,\n-    0x980c4337UL, 0x3fc5f619UL, 0x00000000UL, 0x00000000UL, 0x00000000UL,\n-    0x00000000UL, 0x9314533eUL, 0xbfbb8ec5UL, 0x00000000UL, 0x00000000UL,\n-    0x09aa36d0UL, 0x3fb6d3f4UL, 0x00000000UL, 0x00000000UL, 0xdcb427fdUL,\n-    0xbfb13950UL, 0xd87ab0bbUL, 0xbfd5335eUL, 0xce0ae8a5UL, 0x3fabb382UL,\n-    0x79143126UL, 0x3fddba41UL, 0x5f2b28d4UL, 0xbfa552f1UL, 0x59f21a6dUL,\n-    0xbfd015abUL, 0x22c27d95UL, 0x3fa0e984UL, 0xe19fc6aaUL, 0x3fd0576cUL,\n-    0x8f2c2950UL, 0xbf9a4898UL, 0xc0b3f22cUL, 0xbfc59462UL, 0x1883a4b8UL,\n-    0x3f94b61cUL, 0x3f838640UL, 0x3fc30eb8UL, 0x355c63dcUL, 0xbfd36a08UL,\n-    0x1dce993dUL, 0x3c6d704dUL, 0x00000000UL, 0x3ff00000UL, 0x2b82ab63UL,\n-    0x3fb78e92UL, 0x00000000UL, 0x00000000UL, 0x00000000UL, 0x00000000UL,\n-    0x5a279ea3UL, 0xbfaa3407UL, 0x00000000UL, 0x00000000UL, 0x432d65faUL,\n-    0x3fa70153UL, 0x00000000UL, 0x00000000UL, 0x891a4602UL, 0xbf9d03efUL,\n-    0xd62ca5f8UL, 0xbfca77d9UL, 0xb35f4628UL, 0x3f97a265UL, 0x433258faUL,\n-    0x3fd8cf51UL, 0xb58fd909UL, 0xbf8f88e3UL, 0x01771ceaUL, 0xbfc2b154UL,\n-    0xf3562f8eUL, 0x3f888f57UL, 0xc028a723UL, 0x3fc7370fUL, 0x20b7f9f0UL,\n-    0xbf80f44cUL, 0x214368e9UL, 0xbfb6dfaaUL, 0x28891863UL, 0x3f79b4b6UL,\n-    0x172dbbf0UL, 0x3fb6cb8eUL, 0xe0553158UL, 0xbfc975f5UL, 0x593fe814UL,\n-    0xbc2ef5d3UL, 0x00000000UL, 0x3ff00000UL, 0x03dec550UL, 0x3fa44203UL,\n-    0x00000000UL, 0x00000000UL, 0x00000000UL, 0x00000000UL, 0x4e435f9bUL,\n-    0xbf953f83UL, 0x00000000UL, 0x00000000UL, 0x3c6e8e46UL, 0x3f9b74eaUL,\n-    0x00000000UL, 0x00000000UL, 0xda5b7511UL, 0xbf85ad63UL, 0xdc230b9bUL,\n-    0xbfb97558UL, 0x26cb3788UL, 0x3f881308UL, 0x76fc4985UL, 0x3fd62ac9UL,\n-    0x77bb08baUL, 0xbf757c85UL, 0xb6247521UL, 0xbfb1381eUL, 0x5922170cUL,\n-    0x3f754e95UL, 0x8746482dUL, 0x3fc27f83UL, 0x11055b30UL, 0xbf64e391UL,\n-    0x3e666320UL, 0xbfa3e609UL, 0x0de9dae3UL, 0x3f6301dfUL, 0x1f1dca06UL,\n-    0x3fafa8aeUL, 0x8c5b2da2UL, 0xbfb936bbUL, 0x4e88f7a5UL, 0xbc587d05UL,\n-    0x00000000UL, 0x3ff00000UL, 0xa8935dd9UL, 0x3f83dde2UL, 0x00000000UL,\n-    0x00000000UL, 0x00000000UL, 0x00000000UL\n-};\n-\n-ATTRIBUTE_ALIGNED(16) juint _MASK_35_tan[] =\n-{\n-    0xfffc0000UL, 0xffffffffUL, 0x00000000UL, 0x00000000UL\n-};\n-\n-ATTRIBUTE_ALIGNED(16) juint _Q_11_tan[] =\n-{\n-    0xb8fe4d77UL, 0x3f82609aUL\n-};\n-\n-ATTRIBUTE_ALIGNED(16) juint _Q_9_tan[] =\n-{\n-    0xbf847a43UL, 0x3f9664a0UL\n-};\n-\n-ATTRIBUTE_ALIGNED(16) juint _Q_7_tan[] =\n-{\n-    0x52c4c8abUL, 0x3faba1baUL\n-};\n-\n-ATTRIBUTE_ALIGNED(16) juint _Q_5_tan[] =\n-{\n-    0x11092746UL, 0x3fc11111UL\n-};\n-\n-ATTRIBUTE_ALIGNED(16) juint _Q_3_tan[] =\n-{\n-    0x55555612UL, 0x3fd55555UL\n-};\n-\n-ATTRIBUTE_ALIGNED(8) juint _PI_4_tan[] =\n-{\n-    0x00000000UL, 0x3fe921fbUL, 0x4611a626UL, 0x3e85110bUL\n-};\n-\n-ATTRIBUTE_ALIGNED(8) juint _QQ_2_tan[] =\n-{\n-    0x676733afUL, 0x3d32e7b9UL\n-};\n-\n-void MacroAssembler::fast_tan(XMMRegister xmm0, XMMRegister xmm1, XMMRegister xmm2, XMMRegister xmm3,\n-                              XMMRegister xmm4, XMMRegister xmm5, XMMRegister xmm6, XMMRegister xmm7,\n-                              Register eax, Register ecx, Register edx, Register r8, Register r9,\n-                              Register r10, Register r11, Register tmp) {\n-\n-  Label L_2TAG_PACKET_0_0_1, L_2TAG_PACKET_1_0_1, L_2TAG_PACKET_2_0_1, L_2TAG_PACKET_3_0_1;\n-  Label L_2TAG_PACKET_4_0_1, L_2TAG_PACKET_5_0_1, L_2TAG_PACKET_6_0_1, L_2TAG_PACKET_7_0_1;\n-  Label L_2TAG_PACKET_8_0_1, L_2TAG_PACKET_9_0_1, L_2TAG_PACKET_10_0_1, L_2TAG_PACKET_11_0_1;\n-  Label L_2TAG_PACKET_12_0_1, L_2TAG_PACKET_13_0_1, L_2TAG_PACKET_14_0_1, B1_2, B1_4;\n-\n-  assert_different_registers(eax, ecx, edx, r8, r9, r10, r11, tmp);\n-\n-  address MUL16     = (address)_MUL16;\n-  address sign_mask = (address)_sign_mask_tan;\n-  address PI32INV   = (address)_PI32INV_tan;\n-  address P_1       = (address)_P_1_tan;\n-  address P_2       = (address)_P_2_tan;\n-  address P_3       = (address)_P_3_tan;\n-  address Ctable    = (address)_Ctable_tan;\n-  address MASK_35   = (address)_MASK_35_tan;\n-  address Q_11      = (address)_Q_11_tan;\n-  address Q_9       = (address)_Q_9_tan;\n-  address Q_7       = (address)_Q_7_tan;\n-  address Q_5       = (address)_Q_5_tan;\n-  address Q_3       = (address)_Q_3_tan;\n-  address PI_4      = (address)_PI_4_tan;\n-  address QQ_2      = (address)_QQ_2_tan;\n-\n-  push(rbx);\n-  subq(rsp, 16);\n-  movsd(Address(rsp, 8), xmm0);\n-\n-  bind(B1_2);\n-  pextrw(eax, xmm0, 3);\n-  andl(eax, 32767);\n-  subl(eax, 16314);\n-  cmpl(eax, 270);\n-  jcc(Assembler::above, L_2TAG_PACKET_0_0_1);\n-  movdqu(xmm5, ExternalAddress(ONEHALF), tmp \/*rscratch*\/);    \/\/0x00000000UL, 0x3fe00000UL, 0x00000000UL, 0x3fe00000UL\n-  movdqu(xmm6, ExternalAddress(MUL16), tmp \/*rscratch*\/);    \/\/0x00000000UL, 0x40300000UL, 0x00000000UL, 0x3ff00000UL\n-  unpcklpd(xmm0, xmm0);\n-  movdqu(xmm4, ExternalAddress(sign_mask), tmp \/*rscratch*\/);    \/\/0x00000000UL, 0x80000000UL, 0x00000000UL, 0x80000000UL\n-  andpd(xmm4, xmm0);\n-  movdqu(xmm1, ExternalAddress(PI32INV), tmp \/*rscratch*\/);    \/\/0x6dc9c883UL, 0x3fe45f30UL, 0x6dc9c883UL, 0x40245f30UL\n-  mulpd(xmm1, xmm0);\n-  por(xmm5, xmm4);\n-  addpd(xmm1, xmm5);\n-  movdqu(xmm7, xmm1);\n-  unpckhpd(xmm7, xmm7);\n-  cvttsd2sil(edx, xmm7);\n-  cvttpd2dq(xmm1, xmm1);\n-  cvtdq2pd(xmm1, xmm1);\n-  mulpd(xmm1, xmm6);\n-  movdqu(xmm3, ExternalAddress(P_1), tmp \/*rscratch*\/);    \/\/0x54444000UL, 0x3fb921fbUL, 0x54440000UL, 0x3fb921fbUL\n-  movq(xmm5, ExternalAddress(QQ_2), tmp \/*rscratch*\/);    \/\/0x676733afUL, 0x3d32e7b9UL\n-  addq(rdx, 469248);\n-  movdqu(xmm4, ExternalAddress(P_2), tmp \/*rscratch*\/);    \/\/0x67674000UL, 0xbd32e7b9UL, 0x4c4c0000UL, 0x3d468c23UL\n-  mulpd(xmm3, xmm1);\n-  andq(rdx, 31);\n-  mulsd(xmm5, xmm1);\n-  movq(rcx, rdx);\n-  mulpd(xmm4, xmm1);\n-  shlq(rcx, 1);\n-  subpd(xmm0, xmm3);\n-  mulpd(xmm1, ExternalAddress(P_3), tmp \/*rscratch*\/);    \/\/0x3707344aUL, 0x3aa8a2e0UL, 0x03707345UL, 0x3ae98a2eUL\n-  addq(rdx, rcx);\n-  shlq(rcx, 2);\n-  addq(rdx, rcx);\n-  addsd(xmm5, xmm0);\n-  movdqu(xmm2, xmm0);\n-  subpd(xmm0, xmm4);\n-  movq(xmm6, ExternalAddress(ONE), tmp \/*rscratch*\/);    \/\/0x00000000UL, 0x3ff00000UL\n-  shlq(rdx, 4);\n-  lea(rax, ExternalAddress(Ctable));\n-  andpd(xmm5, ExternalAddress(MASK_35), tmp \/*rscratch*\/);    \/\/0xfffc0000UL, 0xffffffffUL, 0x00000000UL, 0x00000000UL\n-  movdqu(xmm3, xmm0);\n-  addq(rax, rdx);\n-  subpd(xmm2, xmm0);\n-  unpckhpd(xmm0, xmm0);\n-  divsd(xmm6, xmm5);\n-  subpd(xmm2, xmm4);\n-  movdqu(xmm7, Address(rax, 16));\n-  subsd(xmm3, xmm5);\n-  mulpd(xmm7, xmm0);\n-  subpd(xmm2, xmm1);\n-  movdqu(xmm1, Address(rax, 48));\n-  mulpd(xmm1, xmm0);\n-  movdqu(xmm4, Address(rax, 96));\n-  mulpd(xmm4, xmm0);\n-  addsd(xmm2, xmm3);\n-  movdqu(xmm3, xmm0);\n-  mulpd(xmm0, xmm0);\n-  addpd(xmm7, Address(rax, 0));\n-  addpd(xmm1, Address(rax, 32));\n-  mulpd(xmm1, xmm0);\n-  addpd(xmm4, Address(rax, 80));\n-  addpd(xmm7, xmm1);\n-  movdqu(xmm1, Address(rax, 112));\n-  mulpd(xmm1, xmm0);\n-  mulpd(xmm0, xmm0);\n-  addpd(xmm4, xmm1);\n-  movdqu(xmm1, Address(rax, 64));\n-  mulpd(xmm1, xmm0);\n-  addpd(xmm7, xmm1);\n-  movdqu(xmm1, xmm3);\n-  mulpd(xmm3, xmm0);\n-  mulsd(xmm0, xmm0);\n-  mulpd(xmm1, Address(rax, 144));\n-  mulpd(xmm4, xmm3);\n-  movdqu(xmm3, xmm1);\n-  addpd(xmm7, xmm4);\n-  movdqu(xmm4, xmm1);\n-  mulsd(xmm0, xmm7);\n-  unpckhpd(xmm7, xmm7);\n-  addsd(xmm0, xmm7);\n-  unpckhpd(xmm1, xmm1);\n-  addsd(xmm3, xmm1);\n-  subsd(xmm4, xmm3);\n-  addsd(xmm1, xmm4);\n-  movdqu(xmm4, xmm2);\n-  movq(xmm7, Address(rax, 144));\n-  unpckhpd(xmm2, xmm2);\n-  addsd(xmm7, Address(rax, 152));\n-  mulsd(xmm7, xmm2);\n-  addsd(xmm7, Address(rax, 136));\n-  addsd(xmm7, xmm1);\n-  addsd(xmm0, xmm7);\n-  movq(xmm7, ExternalAddress(ONE), tmp \/*rscratch*\/);    \/\/0x00000000UL, 0x3ff00000UL\n-  mulsd(xmm4, xmm6);\n-  movq(xmm2, Address(rax, 168));\n-  andpd(xmm2, xmm6);\n-  mulsd(xmm5, xmm2);\n-  mulsd(xmm6, Address(rax, 160));\n-  subsd(xmm7, xmm5);\n-  subsd(xmm2, Address(rax, 128));\n-  subsd(xmm7, xmm4);\n-  mulsd(xmm7, xmm6);\n-  movdqu(xmm4, xmm3);\n-  subsd(xmm3, xmm2);\n-  addsd(xmm2, xmm3);\n-  subsd(xmm4, xmm2);\n-  addsd(xmm0, xmm4);\n-  subsd(xmm0, xmm7);\n-  addsd(xmm0, xmm3);\n-  jmp(B1_4);\n-\n-  bind(L_2TAG_PACKET_0_0_1);\n-  jcc(Assembler::greater, L_2TAG_PACKET_1_0_1);\n-  pextrw(eax, xmm0, 3);\n-  movl(edx, eax);\n-  andl(eax, 32752);\n-  jcc(Assembler::equal, L_2TAG_PACKET_2_0_1);\n-  andl(edx, 32767);\n-  cmpl(edx, 15904);\n-  jcc(Assembler::below, L_2TAG_PACKET_3_0_1);\n-  movdqu(xmm2, xmm0);\n-  movdqu(xmm3, xmm0);\n-  movq(xmm1, ExternalAddress(Q_11), tmp \/*rscratch*\/);    \/\/0xb8fe4d77UL, 0x3f82609aUL\n-  mulsd(xmm2, xmm0);\n-  mulsd(xmm3, xmm2);\n-  mulsd(xmm1, xmm2);\n-  addsd(xmm1, ExternalAddress(Q_9), tmp \/*rscratch*\/);    \/\/0xbf847a43UL, 0x3f9664a0UL\n-  mulsd(xmm1, xmm2);\n-  addsd(xmm1, ExternalAddress(Q_7), tmp \/*rscratch*\/);    \/\/0x52c4c8abUL, 0x3faba1baUL\n-  mulsd(xmm1, xmm2);\n-  addsd(xmm1, ExternalAddress(Q_5), tmp \/*rscratch*\/);    \/\/0x11092746UL, 0x3fc11111UL\n-  mulsd(xmm1, xmm2);\n-  addsd(xmm1, ExternalAddress(Q_3), tmp \/*rscratch*\/);    \/\/0x55555612UL, 0x3fd55555UL\n-  mulsd(xmm1, xmm3);\n-  addsd(xmm0, xmm1);\n-  jmp(B1_4);\n-\n-  bind(L_2TAG_PACKET_3_0_1);\n-  movq(xmm3, ExternalAddress(TWO_POW_55), tmp \/*rscratch*\/);    \/\/0x00000000UL, 0x43600000UL\n-  mulsd(xmm3, xmm0);\n-  addsd(xmm0, xmm3);\n-  mulsd(xmm0, ExternalAddress(TWO_POW_M55), tmp \/*rscratch*\/);    \/\/0x00000000UL, 0x3c800000UL\n-  jmp(B1_4);\n-\n-  bind(L_2TAG_PACKET_2_0_1);\n-  movdqu(xmm1, xmm0);\n-  mulsd(xmm1, xmm1);\n-  jmp(B1_4);\n-\n-  bind(L_2TAG_PACKET_1_0_1);\n-  pextrw(eax, xmm0, 3);\n-  andl(eax, 32752);\n-  cmpl(eax, 32752);\n-  jcc(Assembler::equal, L_2TAG_PACKET_4_0_1);\n-  pextrw(ecx, xmm0, 3);\n-  andl(ecx, 32752);\n-  subl(ecx, 16224);\n-  shrl(ecx, 7);\n-  andl(ecx, 65532);\n-  lea(r11, ExternalAddress(PI_INV_TABLE));\n-  addq(rcx, r11);\n-  movdq(rax, xmm0);\n-  movl(r10, Address(rcx, 20));\n-  movl(r8, Address(rcx, 24));\n-  movl(edx, eax);\n-  shrq(rax, 21);\n-  orl(eax, INT_MIN);\n-  shrl(eax, 11);\n-  movl(r9, r10);\n-  imulq(r10, rdx);\n-  imulq(r9, rax);\n-  imulq(r8, rax);\n-  movl(rsi, Address(rcx, 16));\n-  movl(rdi, Address(rcx, 12));\n-  movl(r11, r10);\n-  shrq(r10, 32);\n-  addq(r9, r10);\n-  addq(r11, r8);\n-  movl(r8, r11);\n-  shrq(r11, 32);\n-  addq(r9, r11);\n-  movl(r10, rsi);\n-  imulq(rsi, rdx);\n-  imulq(r10, rax);\n-  movl(r11, rdi);\n-  imulq(rdi, rdx);\n-  movl(rbx, rsi);\n-  shrq(rsi, 32);\n-  addq(r9, rbx);\n-  movl(rbx, r9);\n-  shrq(r9, 32);\n-  addq(r10, rsi);\n-  addq(r10, r9);\n-  shlq(rbx, 32);\n-  orq(r8, rbx);\n-  imulq(r11, rax);\n-  movl(r9, Address(rcx, 8));\n-  movl(rsi, Address(rcx, 4));\n-  movl(rbx, rdi);\n-  shrq(rdi, 32);\n-  addq(r10, rbx);\n-  movl(rbx, r10);\n-  shrq(r10, 32);\n-  addq(r11, rdi);\n-  addq(r11, r10);\n-  movq(rdi, r9);\n-  imulq(r9, rdx);\n-  imulq(rdi, rax);\n-  movl(r10, r9);\n-  shrq(r9, 32);\n-  addq(r11, r10);\n-  movl(r10, r11);\n-  shrq(r11, 32);\n-  addq(rdi, r9);\n-  addq(rdi, r11);\n-  movq(r9, rsi);\n-  imulq(rsi, rdx);\n-  imulq(r9, rax);\n-  shlq(r10, 32);\n-  orq(r10, rbx);\n-  movl(eax, Address(rcx, 0));\n-  movl(r11, rsi);\n-  shrq(rsi, 32);\n-  addq(rdi, r11);\n-  movl(r11, rdi);\n-  shrq(rdi, 32);\n-  addq(r9, rsi);\n-  addq(r9, rdi);\n-  imulq(rdx, rax);\n-  pextrw(rbx, xmm0, 3);\n-  lea(rdi, ExternalAddress(PI_INV_TABLE));\n-  subq(rcx, rdi);\n-  addl(ecx, ecx);\n-  addl(ecx, ecx);\n-  addl(ecx, ecx);\n-  addl(ecx, 19);\n-  movl(rsi, 32768);\n-  andl(rsi, rbx);\n-  shrl(rbx, 4);\n-  andl(rbx, 2047);\n-  subl(rbx, 1023);\n-  subl(ecx, rbx);\n-  addq(r9, rdx);\n-  movl(edx, ecx);\n-  addl(edx, 32);\n-  cmpl(ecx, 0);\n-  jcc(Assembler::less, L_2TAG_PACKET_5_0_1);\n-  negl(ecx);\n-  addl(ecx, 29);\n-  shll(r9);\n-  movl(rdi, r9);\n-  andl(r9, 1073741823);\n-  testl(r9, 536870912);\n-  jcc(Assembler::notEqual, L_2TAG_PACKET_6_0_1);\n-  shrl(r9);\n-  movl(rbx, 0);\n-  shlq(r9, 32);\n-  orq(r9, r11);\n-\n-  bind(L_2TAG_PACKET_7_0_1);\n-\n-  bind(L_2TAG_PACKET_8_0_1);\n-  cmpq(r9, 0);\n-  jcc(Assembler::equal, L_2TAG_PACKET_9_0_1);\n-\n-  bind(L_2TAG_PACKET_10_0_1);\n-  bsrq(r11, r9);\n-  movl(ecx, 29);\n-  subl(ecx, r11);\n-  jcc(Assembler::lessEqual, L_2TAG_PACKET_11_0_1);\n-  shlq(r9);\n-  movq(rax, r10);\n-  shlq(r10);\n-  addl(edx, ecx);\n-  negl(ecx);\n-  addl(ecx, 64);\n-  shrq(rax);\n-  shrq(r8);\n-  orq(r9, rax);\n-  orq(r10, r8);\n-\n-  bind(L_2TAG_PACKET_12_0_1);\n-  cvtsi2sdq(xmm0, r9);\n-  shrq(r10, 1);\n-  cvtsi2sdq(xmm3, r10);\n-  xorpd(xmm4, xmm4);\n-  shll(edx, 4);\n-  negl(edx);\n-  addl(edx, 16368);\n-  orl(edx, rsi);\n-  xorl(edx, rbx);\n-  pinsrw(xmm4, edx, 3);\n-  movq(xmm2, ExternalAddress(PI_4),     tmp \/*rscratch*\/);    \/\/0x00000000UL, 0x3fe921fbUL, 0x4611a626UL, 0x3e85110bUL\n-  movq(xmm7, ExternalAddress(PI_4 + 8), tmp \/*rscratch*\/);    \/\/0x3fe921fbUL, 0x4611a626UL, 0x3e85110bUL\n-  xorpd(xmm5, xmm5);\n-  subl(edx, 1008);\n-  pinsrw(xmm5, edx, 3);\n-  mulsd(xmm0, xmm4);\n-  shll(rsi, 16);\n-  sarl(rsi, 31);\n-  mulsd(xmm3, xmm5);\n-  movdqu(xmm1, xmm0);\n-  mulsd(xmm0, xmm2);\n-  shrl(rdi, 30);\n-  addsd(xmm1, xmm3);\n-  mulsd(xmm3, xmm2);\n-  addl(rdi, rsi);\n-  xorl(rdi, rsi);\n-  mulsd(xmm7, xmm1);\n-  movl(eax, rdi);\n-  addsd(xmm7, xmm3);\n-  movdqu(xmm2, xmm0);\n-  addsd(xmm0, xmm7);\n-  subsd(xmm2, xmm0);\n-  addsd(xmm7, xmm2);\n-  movdqu(xmm1, ExternalAddress(PI32INV), tmp \/*rscratch*\/);    \/\/0x6dc9c883UL, 0x3fe45f30UL, 0x6dc9c883UL, 0x40245f30UL\n-  if (VM_Version::supports_sse3()) {\n-    movddup(xmm0, xmm0);\n-  }\n-  else {\n-    movlhps(xmm0, xmm0);\n-  }\n-  movdqu(xmm4, ExternalAddress(sign_mask), tmp \/*rscratch*\/);    \/\/0x00000000UL, 0x80000000UL, 0x00000000UL, 0x80000000UL\n-  andpd(xmm4, xmm0);\n-  mulpd(xmm1, xmm0);\n-  if (VM_Version::supports_sse3()) {\n-    movddup(xmm7, xmm7);\n-  }\n-  else {\n-    movlhps(xmm7, xmm7);\n-  }\n-  movdqu(xmm5, ExternalAddress(ONEHALF), tmp \/*rscratch*\/);    \/\/0x00000000UL, 0x3fe00000UL, 0x00000000UL, 0x3fe00000UL\n-  movdqu(xmm6, ExternalAddress(MUL16), tmp \/*rscratch*\/);    \/\/0x00000000UL, 0x40300000UL, 0x00000000UL, 0x3ff00000UL\n-  por(xmm5, xmm4);\n-  addpd(xmm1, xmm5);\n-  movdqu(xmm5, xmm1);\n-  unpckhpd(xmm5, xmm5);\n-  cvttsd2sil(edx, xmm5);\n-  cvttpd2dq(xmm1, xmm1);\n-  cvtdq2pd(xmm1, xmm1);\n-  mulpd(xmm1, xmm6);\n-  movdqu(xmm3, ExternalAddress(P_1), tmp \/*rscratch*\/);    \/\/0x54444000UL, 0x3fb921fbUL, 0x54440000UL, 0x3fb921fbUL\n-  movq(xmm5, ExternalAddress(QQ_2), tmp \/*rscratch*\/);    \/\/0x676733afUL, 0x3d32e7b9UL\n-  shll(eax, 4);\n-  addl(edx, 469248);\n-  movdqu(xmm4, ExternalAddress(P_2), tmp \/*rscratch*\/);    \/\/0x67674000UL, 0xbd32e7b9UL, 0x4c4c0000UL, 0x3d468c23UL\n-  mulpd(xmm3, xmm1);\n-  addl(edx, eax);\n-  andl(edx, 31);\n-  mulsd(xmm5, xmm1);\n-  movl(ecx, edx);\n-  mulpd(xmm4, xmm1);\n-  shll(ecx, 1);\n-  subpd(xmm0, xmm3);\n-  mulpd(xmm1, ExternalAddress(P_3), tmp \/*rscratch*\/);    \/\/0x3707344aUL, 0x3aa8a2e0UL, 0x03707345UL, 0x3ae98a2eUL\n-  addl(edx, ecx);\n-  shll(ecx, 2);\n-  addl(edx, ecx);\n-  addsd(xmm5, xmm0);\n-  movdqu(xmm2, xmm0);\n-  subpd(xmm0, xmm4);\n-  movq(xmm6, ExternalAddress(ONE), tmp \/*rscratch*\/);    \/\/0x00000000UL, 0x3ff00000UL\n-  shll(edx, 4);\n-  lea(rax, ExternalAddress(Ctable));\n-  andpd(xmm5, ExternalAddress(MASK_35), tmp \/*rscratch*\/);    \/\/0xfffc0000UL, 0xffffffffUL, 0x00000000UL, 0x00000000UL\n-  movdqu(xmm3, xmm0);\n-  addq(rax, rdx);\n-  subpd(xmm2, xmm0);\n-  unpckhpd(xmm0, xmm0);\n-  divsd(xmm6, xmm5);\n-  subpd(xmm2, xmm4);\n-  subsd(xmm3, xmm5);\n-  subpd(xmm2, xmm1);\n-  movdqu(xmm1, Address(rax, 48));\n-  addpd(xmm2, xmm7);\n-  movdqu(xmm7, Address(rax, 16));\n-  mulpd(xmm7, xmm0);\n-  movdqu(xmm4, Address(rax, 96));\n-  mulpd(xmm1, xmm0);\n-  mulpd(xmm4, xmm0);\n-  addsd(xmm2, xmm3);\n-  movdqu(xmm3, xmm0);\n-  mulpd(xmm0, xmm0);\n-  addpd(xmm7, Address(rax, 0));\n-  addpd(xmm1, Address(rax, 32));\n-  mulpd(xmm1, xmm0);\n-  addpd(xmm4, Address(rax, 80));\n-  addpd(xmm7, xmm1);\n-  movdqu(xmm1, Address(rax, 112));\n-  mulpd(xmm1, xmm0);\n-  mulpd(xmm0, xmm0);\n-  addpd(xmm4, xmm1);\n-  movdqu(xmm1, Address(rax, 64));\n-  mulpd(xmm1, xmm0);\n-  addpd(xmm7, xmm1);\n-  movdqu(xmm1, xmm3);\n-  mulpd(xmm3, xmm0);\n-  mulsd(xmm0, xmm0);\n-  mulpd(xmm1, Address(rax, 144));\n-  mulpd(xmm4, xmm3);\n-  movdqu(xmm3, xmm1);\n-  addpd(xmm7, xmm4);\n-  movdqu(xmm4, xmm1);\n-  mulsd(xmm0, xmm7);\n-  unpckhpd(xmm7, xmm7);\n-  addsd(xmm0, xmm7);\n-  unpckhpd(xmm1, xmm1);\n-  addsd(xmm3, xmm1);\n-  subsd(xmm4, xmm3);\n-  addsd(xmm1, xmm4);\n-  movdqu(xmm4, xmm2);\n-  movq(xmm7, Address(rax, 144));\n-  unpckhpd(xmm2, xmm2);\n-  addsd(xmm7, Address(rax, 152));\n-  mulsd(xmm7, xmm2);\n-  addsd(xmm7, Address(rax, 136));\n-  addsd(xmm7, xmm1);\n-  addsd(xmm0, xmm7);\n-  movq(xmm7, ExternalAddress(ONE), tmp \/*rscratch*\/);    \/\/0x00000000UL, 0x3ff00000UL\n-  mulsd(xmm4, xmm6);\n-  movq(xmm2, Address(rax, 168));\n-  andpd(xmm2, xmm6);\n-  mulsd(xmm5, xmm2);\n-  mulsd(xmm6, Address(rax, 160));\n-  subsd(xmm7, xmm5);\n-  subsd(xmm2, Address(rax, 128));\n-  subsd(xmm7, xmm4);\n-  mulsd(xmm7, xmm6);\n-  movdqu(xmm4, xmm3);\n-  subsd(xmm3, xmm2);\n-  addsd(xmm2, xmm3);\n-  subsd(xmm4, xmm2);\n-  addsd(xmm0, xmm4);\n-  subsd(xmm0, xmm7);\n-  addsd(xmm0, xmm3);\n-  jmp(B1_4);\n-\n-  bind(L_2TAG_PACKET_9_0_1);\n-  addl(edx, 64);\n-  movq(r9, r10);\n-  movq(r10, r8);\n-  movl(r8, 0);\n-  cmpq(r9, 0);\n-  jcc(Assembler::notEqual, L_2TAG_PACKET_10_0_1);\n-  addl(edx, 64);\n-  movq(r9, r10);\n-  movq(r10, r8);\n-  cmpq(r9, 0);\n-  jcc(Assembler::notEqual, L_2TAG_PACKET_10_0_1);\n-  jmp(L_2TAG_PACKET_12_0_1);\n-\n-  bind(L_2TAG_PACKET_11_0_1);\n-  jcc(Assembler::equal, L_2TAG_PACKET_12_0_1);\n-  negl(ecx);\n-  shrq(r10);\n-  movq(rax, r9);\n-  shrq(r9);\n-  subl(edx, ecx);\n-  negl(ecx);\n-  addl(ecx, 64);\n-  shlq(rax);\n-  orq(r10, rax);\n-  jmp(L_2TAG_PACKET_12_0_1);\n-\n-  bind(L_2TAG_PACKET_5_0_1);\n-  notl(ecx);\n-  shlq(r9, 32);\n-  orq(r9, r11);\n-  shlq(r9);\n-  movq(rdi, r9);\n-  testl(r9, INT_MIN);\n-  jcc(Assembler::notEqual, L_2TAG_PACKET_13_0_1);\n-  shrl(r9);\n-  movl(rbx, 0);\n-  shrq(rdi, 2);\n-  jmp(L_2TAG_PACKET_8_0_1);\n-\n-  bind(L_2TAG_PACKET_6_0_1);\n-  shrl(r9);\n-  movl(rbx, 1073741824);\n-  shrl(rbx);\n-  shlq(r9, 32);\n-  orq(r9, r11);\n-  shlq(rbx, 32);\n-  addl(rdi, 1073741824);\n-  movl(rcx, 0);\n-  movl(r11, 0);\n-  subq(rcx, r8);\n-  sbbq(r11, r10);\n-  sbbq(rbx, r9);\n-  movq(r8, rcx);\n-  movq(r10, r11);\n-  movq(r9, rbx);\n-  movl(rbx, 32768);\n-  jmp(L_2TAG_PACKET_7_0_1);\n-\n-  bind(L_2TAG_PACKET_13_0_1);\n-  shrl(r9);\n-  mov64(rbx, 0x100000000);\n-  shrq(rbx);\n-  movl(rcx, 0);\n-  movl(r11, 0);\n-  subq(rcx, r8);\n-  sbbq(r11, r10);\n-  sbbq(rbx, r9);\n-  movq(r8, rcx);\n-  movq(r10, r11);\n-  movq(r9, rbx);\n-  movl(rbx, 32768);\n-  shrq(rdi, 2);\n-  addl(rdi, 1073741824);\n-  jmp(L_2TAG_PACKET_8_0_1);\n-\n-  bind(L_2TAG_PACKET_4_0_1);\n-  movq(xmm0, Address(rsp, 8));\n-  mulsd(xmm0, ExternalAddress(NEG_ZERO), tmp \/*rscratch*\/);    \/\/0x00000000UL, 0x80000000UL\n-  movq(Address(rsp, 0), xmm0);\n-\n-  bind(L_2TAG_PACKET_14_0_1);\n-\n-  bind(B1_4);\n-  addq(rsp, 16);\n-  pop(rbx);\n-}\n-#else\n-\/\/ The 32 bit code is at most SSE2 compliant\n-\n-ATTRIBUTE_ALIGNED(16) jushort _TP[] =\n-{\n-    0x4cd6, 0xaf6c, 0xc710, 0xc662, 0xbffd, 0x0000, 0x4b06, 0xb0ac, 0xd3b2, 0xcc2c,\n-    0x3ff9, 0x0000, 0x00e3, 0xc850, 0xaa28, 0x9533, 0xbff3, 0x0000, 0x2ff0, 0x466d,\n-    0x1a3b, 0xb266, 0x3fe5, 0x0000\n-};\n-\n-ATTRIBUTE_ALIGNED(16) jushort _TQ[] =\n-{\n-    0x399c, 0x8391, 0x154c, 0x94ca, 0xbfff, 0x0000, 0xb6a3, 0xc36a, 0x44e2, 0x8a2c,\n-    0x3ffe, 0x0000, 0xb70f, 0xd068, 0xa6ce, 0xe9dd, 0xbff9, 0x0000, 0x820f, 0x51ce,\n-    0x7d76, 0x9bff, 0x3ff3, 0x0000\n-};\n-\n-ATTRIBUTE_ALIGNED(16) jushort _GP[] =\n-{\n-    0xaaab, 0xaaaa, 0xaaaa, 0xaaaa, 0xbffd, 0x0000, 0xb62f, 0x0b60, 0x60b6, 0xb60b,\n-    0xbff9, 0x0000, 0xdfa7, 0x08aa, 0x55e0, 0x8ab3, 0xbff6, 0x0000, 0x85a0, 0xa819,\n-    0xbc99, 0xddeb, 0xbff2, 0x0000, 0x7065, 0x6a37, 0x795f, 0xb354, 0xbfef, 0x0000,\n-    0xa8f9, 0x83f1, 0x2ec8, 0x9140, 0xbfec, 0x0000, 0xf3ca, 0x8c96, 0x8e0b, 0xeb6d,\n-    0xbfe8, 0x0000, 0x355b, 0xd910, 0x67c9, 0xbed3, 0xbfe5, 0x0000, 0x286b, 0xb49e,\n-    0xb854, 0x9a98, 0xbfe2, 0x0000, 0x0871, 0x1a2f, 0x6477, 0xfcc4, 0xbfde, 0x0000,\n-    0xa559, 0x1da9, 0xaed2, 0xba76, 0xbfdb, 0x0000, 0x00a3, 0x7fea, 0x9bc3, 0xf205,\n-    0xbfd8, 0x0000\n-};\n-\n-void MacroAssembler::libm_tancot_huge(XMMRegister xmm0, XMMRegister xmm1, Register eax, Register ecx, Register edx, Register ebx, Register esi, Register edi, Register ebp, Register esp) {\n-  Label B1_1, B1_2, B1_3, B1_4, B1_5, B1_6, B1_7, B1_8, B1_9, B1_10, B1_11, B1_12;\n-  Label B1_13, B1_14, B1_15, B1_16, B1_17, B1_18, B1_19, B1_20, B1_21, B1_22, B1_23;\n-  Label B1_24, B1_25, B1_26, B1_27, B1_28, B1_29, B1_30, B1_31, B1_32, B1_33, B1_34;\n-  Label B1_35, B1_36, B1_37, B1_38, B1_39, B1_40, B1_43;\n-\n-  assert_different_registers(ebx, eax, ecx, edx, esi, edi, ebp, esp);\n-\n-  address TP = (address)_TP;\n-  address TQ = (address)_TQ;\n-  address GP = (address)_GP;\n-\n-  bind(B1_1);\n-  push(ebp);\n-  movl(ebp, esp);\n-  andl(esp, -64);\n-  push(esi);\n-  push(edi);\n-  push(ebx);\n-  subl(esp, 52);\n-  movl(eax, Address(ebp, 16));\n-  movl(ebx, Address(ebp, 20));\n-  movl(Address(esp, 40), eax);\n-\n-  bind(B1_2);\n-  fnstcw(Address(esp, 38));\n-\n-  bind(B1_3);\n-  movl(edx, Address(ebp, 12));\n-  movl(eax, edx);\n-  andl(eax, 2147483647);\n-  shrl(edx, 31);\n-  movl(Address(esp, 44), edx);\n-  cmpl(eax, 1104150528);\n-  jcc(Assembler::aboveEqual, B1_11);\n-\n-  bind(B1_4);\n-  movsd(xmm1, Address(ebp, 8));\n-  movzwl(ecx, Address(esp, 38));\n-  movl(edx, ecx);\n-  andl(edx, 768);\n-  andps(xmm1, ExternalAddress(L_2IL0FLOATPACKET_0));    \/\/0xffffffffUL, 0x7fffffffUL, 0x00000000UL, 0x00000000UL\n-  cmpl(edx, 768);\n-  movsd(xmm0, ExternalAddress(PI4_INV));    \/\/\/\/0x6dc9c883UL, 0x3ff45f30UL\n-  mulsd(xmm0, xmm1);\n-  movsd(Address(ebp, 8), xmm1);\n-  movsd(Address(esp, 0), xmm0);\n-  jcc(Assembler::equal, B1_39);\n-\n-  bind(B1_5);\n-  orl(ecx, -64768);\n-  movw(Address(esp, 36), ecx);\n-\n-  bind(B1_6);\n-  fldcw(Address(esp, 36));\n-\n-  bind(B1_7);\n-  movsd(xmm1, Address(ebp, 8));\n-  movl(edi, 1);\n-\n-  bind(B1_8);\n-  movl(Address(esp, 12), esi);\n-  movl(esi, Address(esp, 4));\n-  movl(edx, esi);\n-  movl(Address(esp, 24), edi);\n-  movl(edi, esi);\n-  shrl(edi, 20);\n-  andl(edx, 1048575);\n-  movl(ecx, edi);\n-  orl(edx, 1048576);\n-  negl(ecx);\n-  addl(edi, 13);\n-  movl(Address(esp, 8), ebx);\n-  addl(ecx, 19);\n-  movl(ebx, edx);\n-  movl(Address(esp, 28), ecx);\n-  shrl(ebx);\n-  movl(ecx, edi);\n-  shll(edx);\n-  movl(ecx, Address(esp, 28));\n-  movl(edi, Address(esp, 0));\n-  shrl(edi);\n-  orl(edx, edi);\n-  cmpl(esi, 1094713344);\n-  movsd(Address(esp, 16), xmm1);\n-  fld_d(Address(esp, 16));\n-  cmov32(Assembler::below, edx, ebx);\n-  movl(edi, Address(esp, 24));\n-  movl(esi, Address(esp, 12));\n-  lea(ebx, Address(edx, 1));\n-  andl(ebx, -2);\n-  movl(Address(esp, 16), ebx);\n-  cmpl(eax, 1094713344);\n-  fild_s(Address(esp, 16));\n-  movl(ebx, Address(esp, 8));\n-  jcc(Assembler::aboveEqual, B1_10);\n-\n-  bind(B1_9);\n-  fld_d(ExternalAddress(PI4X3));    \/\/0x54443000UL, 0xbfe921fbUL\n-  fmul(1);\n-  faddp(2);\n-  fld_d(ExternalAddress(PI4X3 + 8));    \/\/0x3b39a000UL, 0x3d373dcbUL\n-  fmul(1);\n-  faddp(2);\n-  fld_d(ExternalAddress(PI4X3 + 16));    \/\/0xe0e68948UL, 0xba845c06UL\n-  fmulp(1);\n-  faddp(1);\n-  jmp(B1_17);\n-\n-  bind(B1_10);\n-  fld_d(ExternalAddress(PI4X4));    \/\/0x54400000UL, 0xbfe921fbUL\n-  fmul(1);\n-  faddp(2);\n-  fld_d(ExternalAddress(PI4X4 + 8));    \/\/0x1a600000UL, 0xbdc0b461UL\n-  fmul(1);\n-  faddp(2);\n-  fld_d(ExternalAddress(PI4X4 + 16));    \/\/0x2e000000UL, 0xbb93198aUL\n-  fmul(1);\n-  faddp(2);\n-  fld_d(ExternalAddress(PI4X4 + 24));    \/\/0x252049c1UL, 0xb96b839aUL\n-  fmulp(1);\n-  faddp(1);\n-  jmp(B1_17);\n-\n-  bind(B1_11);\n-  movzwl(edx, Address(esp, 38));\n-  movl(eax, edx);\n-  andl(eax, 768);\n-  cmpl(eax, 768);\n-  jcc(Assembler::equal, B1_40);\n-\n-  bind(B1_12);\n-  orl(edx, -64768);\n-  movw(Address(esp, 36), edx);\n-\n-  bind(B1_13);\n-  fldcw(Address(esp, 36));\n-\n-  bind(B1_14);\n-  movl(edi, 1);\n-\n-  bind(B1_15);\n-  movsd(xmm0, Address(ebp, 8));\n-  addl(esp, -32);\n-  andps(xmm0, ExternalAddress(L_2IL0FLOATPACKET_0));    \/\/0xffffffffUL, 0x7fffffffUL, 0x00000000UL, 0x00000000UL\n-  lea(eax, Address(esp, 32));\n-  movsd(Address(eax, 16), xmm0);\n-  fld_d(Address(eax, 16));\n-  fstp_x(Address(esp, 0));\n-  movl(Address(esp, 12), 0);\n-  movl(Address(esp, 16), eax);\n-  call(RuntimeAddress(CAST_FROM_FN_PTR(address, StubRoutines::dlibm_reduce_pi04l())));\n-\n-  bind(B1_43);\n-  movl(edx, eax);\n-  addl(esp, 32);\n-\n-  bind(B1_16);\n-  fld_d(Address(esp, 0));\n-  fld_d(Address(esp, 8));\n-  faddp(1);\n-\n-  bind(B1_17);\n-  movl(eax, ebx);\n-  andl(eax, 3);\n-  cmpl(eax, 3);\n-  jcc(Assembler::notEqual, B1_24);\n-\n-  bind(B1_18);\n-  fld_d(ExternalAddress(ONES));\n-  incl(edx);\n-  fdiv(1);\n-  testb(edx, 2);\n-  fstp_x(Address(esp, 24));\n-  fld_s(0);\n-  fmul(1);\n-  fld_s(0);\n-  fmul(1);\n-  fld_x(ExternalAddress(36 + TP));    \/\/0x2ff0, 0x466d, 0x1a\n-  fmul(2);\n-  fld_x(ExternalAddress(24 + TP));    \/\/0x00e3, 0xc850, 0xaa\n-  faddp(1);\n-  fmul(2);\n-  fld_x(ExternalAddress(12 + TP));    \/\/0x4b06, 0xb0ac, 0xd3\n-  faddp(1);\n-  fmul(2);\n-  fld_x(ExternalAddress(36 + TQ));    \/\/0x820f, 0x51ce, 0x7d\n-  fmul(3);\n-  fld_x(ExternalAddress(24 + TQ));    \/\/0xb70f, 0xd068, 0xa6\n-  faddp(1);\n-  fmul(3);\n-  fld_x(ExternalAddress(12 + TQ));    \/\/0xb6a3, 0xc36a, 0x44\n-  faddp(1);\n-  fmul(3);\n-  fld_x(ExternalAddress(TQ));    \/\/0x399c, 0x8391, 0x15\n-  faddp(1);\n-  fld_x(ExternalAddress(TP));    \/\/0x4cd6, 0xaf6c, 0xc7\n-  faddp(2);\n-  fld_x(ExternalAddress(132 + GP));    \/\/0x00a3, 0x7fea, 0x9b\n-  fmul(3);\n-  fld_x(ExternalAddress(120 + GP));    \/\/0xa559, 0x1da9, 0xae\n-  fmul(4);\n-  fld_x(ExternalAddress(108 + GP));    \/\/0x0871, 0x1a2f, 0x64\n-  faddp(2);\n-  fxch(1);\n-  fmul(4);\n-  fld_x(ExternalAddress(96 + GP));    \/\/0x286b, 0xb49e, 0xb8\n-  faddp(2);\n-  fxch(1);\n-  fmul(4);\n-  fld_x(ExternalAddress(84 + GP));    \/\/0x355b, 0xd910, 0x67\n-  faddp(2);\n-  fxch(1);\n-  fmul(4);\n-  fld_x(ExternalAddress(72 + GP));    \/\/0x8c96, 0x8e0b, 0xeb\n-  faddp(2);\n-  fxch(1);\n-  fmul(4);\n-  fld_x(ExternalAddress(60 + GP));    \/\/0xa8f9, 0x83f1, 0x2e\n-  faddp(2);\n-  fxch(1);\n-  fmul(4);\n-  fld_x(ExternalAddress(48 + GP));    \/\/0x7065, 0x6a37, 0x79\n-  faddp(2);\n-  fxch(1);\n-  fmul(4);\n-  fld_x(ExternalAddress(36 + GP));    \/\/0x85a0, 0xa819, 0xbc\n-  faddp(2);\n-  fxch(1);\n-  fmul(4);\n-  fld_x(ExternalAddress(24 + GP));    \/\/0xdfa7, 0x08aa, 0x55\n-  faddp(2);\n-  fxch(1);\n-  fmulp(4);\n-  fld_x(ExternalAddress(12 + GP));    \/\/0xb62f, 0x0b60, 0x60\n-  faddp(1);\n-  fmul(4);\n-  fmul(5);\n-  fld_x(ExternalAddress(GP));    \/\/0xaaab, 0xaaaa, 0xaa\n-  faddp(4);\n-  fxch(3);\n-  fmul(5);\n-  faddp(3);\n-  jcc(Assembler::equal, B1_20);\n-\n-  bind(B1_19);\n-  fld_x(Address(esp, 24));\n-  fxch(1);\n-  fdivrp(2);\n-  fxch(1);\n-  fmulp(3);\n-  movl(eax, Address(esp, 44));\n-  xorl(eax, 1);\n-  fxch(2);\n-  fmul(3);\n-  fld_d(Address(ONES, RelocationHolder::none).plus_disp(eax, Address::times_8));\n-  fmula(2);\n-  fmula(3);\n-  fxch(3);\n-  faddp(2);\n-  fxch(1);\n-  fstp_d(Address(esp, 16));\n-  fmul(1);\n-  fxch(1);\n-  fmulp(2);\n-  movsd(xmm0, Address(esp, 16));\n-  faddp(1);\n-  fstp_d(Address(esp, 16));\n-  movsd(xmm1, Address(esp, 16));\n-  jmp(B1_21);\n-\n-  bind(B1_20);\n-  fdivrp(1);\n-  fmulp(2);\n-  fxch(1);\n-  fmul(2);\n-  movl(eax, Address(esp, 44));\n-  fld_d(Address(ONES, RelocationHolder::none).plus_disp(eax, Address::times_8));\n-  fmula(1);\n-  fmula(3);\n-  fxch(3);\n-  faddp(1);\n-  fstp_d(Address(esp, 16));\n-  fmul(1);\n-  fld_x(Address(esp, 24));\n-  fmulp(2);\n-  movsd(xmm0, Address(esp, 16));\n-  faddp(1);\n-  fstp_d(Address(esp, 16));\n-  movsd(xmm1, Address(esp, 16));\n-\n-  bind(B1_21);\n-  testl(edi, edi);\n-  jcc(Assembler::equal, B1_23);\n-\n-  bind(B1_22);\n-  fldcw(Address(esp, 38));\n-\n-  bind(B1_23);\n-  movl(eax, Address(esp, 40));\n-  movsd(Address(eax, 0), xmm0);\n-  movsd(Address(eax, 8), xmm1);\n-  addl(esp, 52);\n-  pop(ebx);\n-  pop(edi);\n-  pop(esi);\n-  movl(esp, ebp);\n-  pop(ebp);\n-  ret(0);\n-\n-  bind(B1_24);\n-  testb(ebx, 2);\n-  jcc(Assembler::equal, B1_31);\n-\n-  bind(B1_25);\n-  incl(edx);\n-  fld_s(0);\n-  fmul(1);\n-  testb(edx, 2);\n-  jcc(Assembler::equal, B1_27);\n-\n-  bind(B1_26);\n-  fld_d(ExternalAddress(ONES));\n-  fdiv(2);\n-  fld_s(1);\n-  fmul(2);\n-  fld_x(ExternalAddress(132 + GP));    \/\/0x00a3, 0x7fea, 0x9b\n-  fmul(1);\n-  fld_x(ExternalAddress(120 + GP));    \/\/0xa559, 0x1da9, 0xae\n-  fmul(2);\n-  fld_x(ExternalAddress(108 + GP));    \/\/0x67c9, 0xbed3, 0xbf\n-  movl(eax, Address(esp, 44));\n-  faddp(2);\n-  fxch(1);\n-  fmul(2);\n-  xorl(eax, 1);\n-  fld_x(ExternalAddress(96 + GP));    \/\/0x286b, 0xb49e, 0xb8\n-  faddp(2);\n-  fxch(1);\n-  fmul(2);\n-  fld_x(ExternalAddress(84 + GP));    \/\/0x355b, 0xd910, 0x67\n-  faddp(2);\n-  fxch(1);\n-  fmul(2);\n-  fld_x(ExternalAddress(72 + GP));    \/\/0xf3ca, 0x8c96, 0x8e\n-  faddp(2);\n-  fxch(1);\n-  fmul(2);\n-  fld_x(ExternalAddress(60 + GP));    \/\/0xa8f9, 0x83f1, 0x2e\n-  faddp(2);\n-  fxch(1);\n-  fmul(2);\n-  fld_x(ExternalAddress(48 + GP));    \/\/0x7065, 0x6a37, 0x79\n-  faddp(2);\n-  fxch(1);\n-  fmul(2);\n-  fld_x(ExternalAddress(36 + GP));    \/\/0x85a0, 0xa819, 0xbc\n-  faddp(2);\n-  fxch(1);\n-  fmul(2);\n-  fld_x(ExternalAddress(24 + GP));    \/\/0xdfa7, 0x08aa, 0x55\n-  faddp(2);\n-  fxch(1);\n-  fmulp(2);\n-  fld_x(ExternalAddress(12 + GP));    \/\/0xb62f, 0x0b60, 0x60\n-  faddp(1);\n-  fmulp(3);\n-  fld_x(ExternalAddress(GP));    \/\/0xaaab, 0xaaaa, 0xaa\n-  faddp(1);\n-  fmul(3);\n-  fxch(2);\n-  fmulp(3);\n-  fxch(1);\n-  faddp(2);\n-  fld_d(Address(ONES, RelocationHolder::none).plus_disp(eax, Address::times_8));\n-  fmula(2);\n-  fmulp(1);\n-  faddp(1);\n-  fstp_d(Address(esp, 16));\n-  movsd(xmm0, Address(esp, 16));\n-  jmp(B1_28);\n-\n-  bind(B1_27);\n-  fld_x(ExternalAddress(36 + TP));    \/\/0x2ff0, 0x466d, 0x1a\n-  fmul(1);\n-  fld_x(ExternalAddress(24 + TP));    \/\/0x00e3, 0xc850, 0xaa\n-  movl(eax, Address(esp, 44));\n-  faddp(1);\n-  fmul(1);\n-  fld_x(ExternalAddress(36 + TQ));    \/\/0x820f, 0x51ce, 0x7d\n-  fmul(2);\n-  fld_x(ExternalAddress(24 + TQ));    \/\/0xb70f, 0xd068, 0xa6\n-  faddp(1);\n-  fmul(2);\n-  fld_x(ExternalAddress(12 + TQ));    \/\/0xb6a3, 0xc36a, 0x44\n-  faddp(1);\n-  fmul(2);\n-  fld_x(ExternalAddress(TQ));    \/\/0x399c, 0x8391, 0x15\n-  faddp(1);\n-  fld_x(ExternalAddress(12 + TP));    \/\/0x4b06, 0xb0ac, 0xd3\n-  faddp(2);\n-  fxch(1);\n-  fmul(2);\n-  fld_x(ExternalAddress(TP));    \/\/0x4cd6, 0xaf6c, 0xc7\n-  faddp(1);\n-  fdivrp(1);\n-  fmulp(1);\n-  fmul(1);\n-  fld_d(Address(ONES, RelocationHolder::none).plus_disp(eax, Address::times_8));\n-  fmula(1);\n-  fmulp(2);\n-  faddp(1);\n-  fstp_d(Address(esp, 16));\n-  movsd(xmm0, Address(esp, 16));\n-\n-  bind(B1_28);\n-  testl(edi, edi);\n-  jcc(Assembler::equal, B1_30);\n-\n-  bind(B1_29);\n-  fldcw(Address(esp, 38));\n-\n-  bind(B1_30);\n-  movl(eax, Address(esp, 40));\n-  movsd(Address(eax, 0), xmm0);\n-  addl(esp, 52);\n-  pop(ebx);\n-  pop(edi);\n-  pop(esi);\n-  movl(esp, ebp);\n-  pop(ebp);\n-  ret(0);\n-\n-  bind(B1_31);\n-  testb(ebx, 1);\n-  jcc(Assembler::equal, B1_38);\n-\n-  bind(B1_32);\n-  incl(edx);\n-  fld_s(0);\n-  fmul(1);\n-  testb(edx, 2);\n-  jcc(Assembler::equal, B1_34);\n-\n-  bind(B1_33);\n-  fld_x(ExternalAddress(36 + TP));    \/\/0x2ff0, 0x466d, 0x1a\n-  fmul(1);\n-  fld_x(ExternalAddress(24 + TP));    \/\/0x00e3, 0xc850, 0xaa\n-  movl(eax, Address(esp, 44));\n-  faddp(1);\n-  fmul(1);\n-  xorl(eax, 1);\n-  fld_x(ExternalAddress(36 + TQ));    \/\/0x820f, 0x51ce, 0x7d\n-  fmul(2);\n-  fld_x(ExternalAddress(24 + TQ));    \/\/0xb70f, 0xd068, 0xa6\n-  faddp(1);\n-  fmul(2);\n-  fld_x(ExternalAddress(12 + TQ));    \/\/0xb6a3, 0xc36a, 0x44\n-  faddp(1);\n-  fmul(2);\n-  fld_x(ExternalAddress(TQ));    \/\/0x399c, 0x8391, 0x15\n-  faddp(1);\n-  fld_x(ExternalAddress(12 + TP));    \/\/0x4b06, 0xb0ac, 0xd3\n-  faddp(2);\n-  fxch(1);\n-  fmul(2);\n-  fld_x(ExternalAddress(TP));    \/\/0x4cd6, 0xaf6c, 0xc7\n-  faddp(1);\n-  fdivrp(1);\n-  fmulp(1);\n-  fmul(1);\n-  fld_d(Address(ONES, RelocationHolder::none).plus_disp(eax, Address::times_8));\n-  fmula(1);\n-  fmulp(2);\n-  faddp(1);\n-  fstp_d(Address(esp, 16));\n-  movsd(xmm0, Address(esp, 16));\n-  jmp(B1_35);\n-\n-  bind(B1_34);\n-  fld_d(ExternalAddress(ONES));\n-  fdiv(2);\n-  fld_s(1);\n-  fmul(2);\n-  fld_x(ExternalAddress(132 + GP));    \/\/0x00a3, 0x7fea, 0x9b\n-  fmul(1);\n-  fld_x(ExternalAddress(120 + GP));    \/\/0xa559, 0x1da9, 0xae\n-  fmul(2);\n-  fld_x(ExternalAddress(108 + GP));    \/\/0x67c9, 0xbed3, 0xbf\n-  movl(eax, Address(esp, 44));\n-  faddp(2);\n-  fxch(1);\n-  fmul(2);\n-  fld_x(ExternalAddress(96 + GP));    \/\/0x286b, 0xb49e, 0xb8\n-  faddp(2);\n-  fxch(1);\n-  fmul(2);\n-  fld_x(ExternalAddress(84 + GP));    \/\/0x355b, 0xd910, 0x67\n-  faddp(2);\n-  fxch(1);\n-  fmul(2);\n-  fld_x(ExternalAddress(72 + GP));    \/\/0xf3ca, 0x8c96, 0x8e\n-  faddp(2);\n-  fxch(1);\n-  fmul(2);\n-  fld_x(ExternalAddress(60 + GP));    \/\/0xa8f9, 0x83f1, 0x2e\n-  faddp(2);\n-  fxch(1);\n-  fmul(2);\n-  fld_x(ExternalAddress(48 + GP));    \/\/0x7065, 0x6a37, 0x79\n-  faddp(2);\n-  fxch(1);\n-  fmul(2);\n-  fld_x(ExternalAddress(36 + GP));    \/\/0x85a0, 0xa819, 0xbc\n-  faddp(2);\n-  fxch(1);\n-  fmul(2);\n-  fld_x(ExternalAddress(24 + GP));    \/\/0xdfa7, 0x08aa, 0x55\n-  faddp(2);\n-  fxch(1);\n-  fmulp(2);\n-  fld_x(ExternalAddress(12 + GP));    \/\/0xb62f, 0x0b60, 0x60\n-  faddp(1);\n-  fmulp(3);\n-  fld_x(ExternalAddress(GP));    \/\/0xaaab, 0xaaaa, 0xaa\n-  faddp(1);\n-  fmul(3);\n-  fxch(2);\n-  fmulp(3);\n-  fxch(1);\n-  faddp(2);\n-  fld_d(Address(ONES, RelocationHolder::none).plus_disp(eax, Address::times_8));\n-  fmula(2);\n-  fmulp(1);\n-  faddp(1);\n-  fstp_d(Address(esp, 16));\n-  movsd(xmm0, Address(esp, 16));\n-\n-  bind(B1_35);\n-  testl(edi, edi);\n-  jcc(Assembler::equal, B1_37);\n-\n-  bind(B1_36);\n-  fldcw(Address(esp, 38));\n-\n-  bind(B1_37);\n-  movl(eax, Address(esp, 40));\n-  movsd(Address(eax, 8), xmm0);\n-  addl(esp, 52);\n-  pop(ebx);\n-  pop(edi);\n-  pop(esi);\n-  mov(esp, ebp);\n-  pop(ebp);\n-  ret(0);\n-\n-  bind(B1_38);\n-  fstp_d(0);\n-  addl(esp, 52);\n-  pop(ebx);\n-  pop(edi);\n-  pop(esi);\n-  mov(esp, ebp);\n-  pop(ebp);\n-  ret(0);\n-\n-  bind(B1_39);\n-  xorl(edi, edi);\n-  jmp(B1_8);\n-\n-  bind(B1_40);\n-  xorl(edi, edi);\n-  jmp(B1_15);\n-}\n-\n-ATTRIBUTE_ALIGNED(16) juint _static_const_table_tan[] =\n-{\n-    0x00000000UL, 0x00000000UL, 0x00000000UL, 0x00000000UL, 0x882c10faUL,\n-    0x3f9664f4UL, 0x00000000UL, 0x00000000UL, 0x00000000UL, 0x00000000UL,\n-    0x00000000UL, 0x00000000UL, 0x55e6c23dUL, 0x3f8226e3UL, 0x55555555UL,\n-    0x3fd55555UL, 0x00000000UL, 0x00000000UL, 0x00000000UL, 0x00000000UL,\n-    0x0e157de0UL, 0x3f6d6d3dUL, 0x11111111UL, 0x3fc11111UL, 0x00000000UL,\n-    0x00000000UL, 0x00000000UL, 0x00000000UL, 0x452b75e3UL, 0x3f57da36UL,\n-    0x1ba1ba1cUL, 0x3faba1baUL, 0x00000000UL, 0x00000000UL, 0x00000000UL,\n-    0x00000000UL, 0x00000000UL, 0x3ff00000UL, 0x00000000UL, 0x00000000UL,\n-    0x00000000UL, 0x00000000UL, 0x00000000UL, 0x00000000UL, 0x4e435f9bUL,\n-    0x3f953f83UL, 0x00000000UL, 0x00000000UL, 0x3c6e8e46UL, 0x3f9b74eaUL,\n-    0x00000000UL, 0x00000000UL, 0xda5b7511UL, 0x3f85ad63UL, 0xdc230b9bUL,\n-    0x3fb97558UL, 0x26cb3788UL, 0x3f881308UL, 0x76fc4985UL, 0x3fd62ac9UL,\n-    0x77bb08baUL, 0x3f757c85UL, 0xb6247521UL, 0x3fb1381eUL, 0x5922170cUL,\n-    0x3f754e95UL, 0x8746482dUL, 0x3fc27f83UL, 0x11055b30UL, 0x3f64e391UL,\n-    0x3e666320UL, 0x3fa3e609UL, 0x0de9dae3UL, 0x3f6301dfUL, 0x1f1dca06UL,\n-    0x3fafa8aeUL, 0x8c5b2da2UL, 0x3fb936bbUL, 0x4e88f7a5UL, 0x3c587d05UL,\n-    0x00000000UL, 0x3ff00000UL, 0xa8935dd9UL, 0x3f83dde2UL, 0x00000000UL,\n-    0x00000000UL, 0x00000000UL, 0x00000000UL, 0x5a279ea3UL, 0x3faa3407UL,\n-    0x00000000UL, 0x00000000UL, 0x432d65faUL, 0x3fa70153UL, 0x00000000UL,\n-    0x00000000UL, 0x891a4602UL, 0x3f9d03efUL, 0xd62ca5f8UL, 0x3fca77d9UL,\n-    0xb35f4628UL, 0x3f97a265UL, 0x433258faUL, 0x3fd8cf51UL, 0xb58fd909UL,\n-    0x3f8f88e3UL, 0x01771ceaUL, 0x3fc2b154UL, 0xf3562f8eUL, 0x3f888f57UL,\n-    0xc028a723UL, 0x3fc7370fUL, 0x20b7f9f0UL, 0x3f80f44cUL, 0x214368e9UL,\n-    0x3fb6dfaaUL, 0x28891863UL, 0x3f79b4b6UL, 0x172dbbf0UL, 0x3fb6cb8eUL,\n-    0xe0553158UL, 0x3fc975f5UL, 0x593fe814UL, 0x3c2ef5d3UL, 0x00000000UL,\n-    0x3ff00000UL, 0x03dec550UL, 0x3fa44203UL, 0x00000000UL, 0x00000000UL,\n-    0x00000000UL, 0x00000000UL, 0x9314533eUL, 0x3fbb8ec5UL, 0x00000000UL,\n-    0x00000000UL, 0x09aa36d0UL, 0x3fb6d3f4UL, 0x00000000UL, 0x00000000UL,\n-    0xdcb427fdUL, 0x3fb13950UL, 0xd87ab0bbUL, 0x3fd5335eUL, 0xce0ae8a5UL,\n-    0x3fabb382UL, 0x79143126UL, 0x3fddba41UL, 0x5f2b28d4UL, 0x3fa552f1UL,\n-    0x59f21a6dUL, 0x3fd015abUL, 0x22c27d95UL, 0x3fa0e984UL, 0xe19fc6aaUL,\n-    0x3fd0576cUL, 0x8f2c2950UL, 0x3f9a4898UL, 0xc0b3f22cUL, 0x3fc59462UL,\n-    0x1883a4b8UL, 0x3f94b61cUL, 0x3f838640UL, 0x3fc30eb8UL, 0x355c63dcUL,\n-    0x3fd36a08UL, 0x1dce993dUL, 0xbc6d704dUL, 0x00000000UL, 0x3ff00000UL,\n-    0x2b82ab63UL, 0x3fb78e92UL, 0x00000000UL, 0x00000000UL, 0x00000000UL,\n-    0x00000000UL, 0x56f37042UL, 0x3fccfc56UL, 0x00000000UL, 0x00000000UL,\n-    0xaa563951UL, 0x3fc90125UL, 0x00000000UL, 0x00000000UL, 0x3d0e7c5dUL,\n-    0x3fc50533UL, 0x9bed9b2eUL, 0x3fdf0ed9UL, 0x5fe7c47cUL, 0x3fc1f250UL,\n-    0x96c125e5UL, 0x3fe2edd9UL, 0x5a02bbd8UL, 0x3fbe5c71UL, 0x86362c20UL,\n-    0x3fda08b7UL, 0x4b4435edUL, 0x3fb9d342UL, 0x4b494091UL, 0x3fd911bdUL,\n-    0xb56658beUL, 0x3fb5e4c7UL, 0x93a2fd76UL, 0x3fd3c092UL, 0xda271794UL,\n-    0x3fb29910UL, 0x3303df2bUL, 0x3fd189beUL, 0x99fcef32UL, 0x3fda8279UL,\n-    0xb68c1467UL, 0x3c708b2fUL, 0x00000000UL, 0x3ff00000UL, 0x980c4337UL,\n-    0x3fc5f619UL, 0x00000000UL, 0x00000000UL, 0x00000000UL, 0x00000000UL,\n-    0xcc03e501UL, 0x3fdff10fUL, 0x00000000UL, 0x00000000UL, 0x44a4e845UL,\n-    0x3fddb63bUL, 0x00000000UL, 0x00000000UL, 0x3768ad9fUL, 0x3fdb72a4UL,\n-    0x3dd01ccaUL, 0x3fe5fdb9UL, 0xa61d2811UL, 0x3fd972b2UL, 0x5645ad0bUL,\n-    0x3fe977f9UL, 0xd013b3abUL, 0x3fd78ca3UL, 0xbf0bf914UL, 0x3fe4f192UL,\n-    0x4d53e730UL, 0x3fd5d060UL, 0x3f8b9000UL, 0x3fe49933UL, 0xe2b82f08UL,\n-    0x3fd4322aUL, 0x5936a835UL, 0x3fe27ae1UL, 0xb1c61c9bUL, 0x3fd2b3fbUL,\n-    0xef478605UL, 0x3fe1659eUL, 0x190834ecUL, 0x3fe11ab7UL, 0xcdb625eaUL,\n-    0xbc8e564bUL, 0x00000000UL, 0x3ff00000UL, 0xb07217e3UL, 0x3fd248f1UL,\n-    0x00000000UL, 0x00000000UL, 0x00000000UL, 0x00000000UL, 0x2b2c49d0UL,\n-    0x3ff2de9cUL, 0x00000000UL, 0x00000000UL, 0x2655bc98UL, 0x3ff33e58UL,\n-    0x00000000UL, 0x00000000UL, 0xff691fa2UL, 0x3ff3972eUL, 0xe93463bdUL,\n-    0x3feeed87UL, 0x070e10a0UL, 0x3ff3f5b2UL, 0xf4d790a4UL, 0x3ff20c10UL,\n-    0xa04e8ea3UL, 0x3ff4541aUL, 0x386accd3UL, 0x3ff1369eUL, 0x222a66ddUL,\n-    0x3ff4b521UL, 0x22a9777eUL, 0x3ff20817UL, 0x52a04a6eUL, 0x3ff5178fUL,\n-    0xddaa0031UL, 0x3ff22137UL, 0x4447d47cUL, 0x3ff57c01UL, 0x1e9c7f1dUL,\n-    0x3ff29311UL, 0x2ab7f990UL, 0x3fe561b8UL, 0x209c7df1UL, 0x3c87a8c5UL,\n-    0x00000000UL, 0x3ff00000UL, 0x4170bcc6UL, 0x3fdc92d8UL, 0x00000000UL,\n-    0x00000000UL, 0x00000000UL, 0x00000000UL, 0xc7ab4d5aUL, 0x40085e24UL,\n-    0x00000000UL, 0x00000000UL, 0xe93ea75dUL, 0x400b963dUL, 0x00000000UL,\n-    0x00000000UL, 0x94a7f25aUL, 0x400f37e2UL, 0x4b6261cbUL, 0x3ff5f984UL,\n-    0x5a9dd812UL, 0x4011aab0UL, 0x74c30018UL, 0x3ffaf5a5UL, 0x7f2ce8e3UL,\n-    0x4013fe8bUL, 0xfe8e54faUL, 0x3ffd7334UL, 0x670d618dUL, 0x4016a10cUL,\n-    0x4db97058UL, 0x4000e012UL, 0x24df44ddUL, 0x40199c5fUL, 0x697d6eceUL,\n-    0x4003006eUL, 0x83298b82UL, 0x401cfc4dUL, 0x19d490d6UL, 0x40058c19UL,\n-    0x2ae42850UL, 0x3fea4300UL, 0x118e20e6UL, 0xbc7a6db8UL, 0x00000000UL,\n-    0x40000000UL, 0xe33345b8UL, 0xbfd4e526UL, 0x00000000UL, 0x00000000UL,\n-    0x00000000UL, 0x00000000UL, 0x65965966UL, 0x40219659UL, 0x00000000UL,\n-    0x00000000UL, 0x882c10faUL, 0x402664f4UL, 0x00000000UL, 0x00000000UL,\n-    0x83cd3723UL, 0x402c8342UL, 0x00000000UL, 0x40000000UL, 0x55e6c23dUL,\n-    0x403226e3UL, 0x55555555UL, 0x40055555UL, 0x34451939UL, 0x40371c96UL,\n-    0xaaaaaaabUL, 0x400aaaaaUL, 0x0e157de0UL, 0x403d6d3dUL, 0x11111111UL,\n-    0x40111111UL, 0xa738201fUL, 0x4042bbceUL, 0x05b05b06UL, 0x4015b05bUL,\n-    0x452b75e3UL, 0x4047da36UL, 0x1ba1ba1cUL, 0x401ba1baUL, 0x00000000UL,\n-    0x3ff00000UL, 0x00000000UL, 0x00000000UL, 0x00000000UL, 0x40000000UL,\n-    0x00000000UL, 0x00000000UL, 0x00000000UL, 0x00000000UL, 0x00000000UL,\n-    0x00000000UL, 0x4f48b8d3UL, 0xbf33eaf9UL, 0x00000000UL, 0x00000000UL,\n-    0x0cf7586fUL, 0x3f20b8eaUL, 0x00000000UL, 0x00000000UL, 0xd0258911UL,\n-    0xbf0abaf3UL, 0x23e49fe9UL, 0xbfab5a8cUL, 0x2d53222eUL, 0x3ef60d15UL,\n-    0x21169451UL, 0x3fa172b2UL, 0xbb254dbcUL, 0xbee1d3b5UL, 0xdbf93b8eUL,\n-    0xbf84c7dbUL, 0x05b4630bUL, 0x3ecd3364UL, 0xee9aada7UL, 0x3f743924UL,\n-    0x794a8297UL, 0xbeb7b7b9UL, 0xe015f797UL, 0xbf5d41f5UL, 0xe41a4a56UL,\n-    0x3ea35dfbUL, 0xe4c2a251UL, 0x3f49a2abUL, 0x5af9e000UL, 0xbfce49ceUL,\n-    0x8c743719UL, 0x3d1eb860UL, 0x00000000UL, 0x00000000UL, 0x1b4863cfUL,\n-    0x3fd78294UL, 0x00000000UL, 0x3ff00000UL, 0x00000000UL, 0xfffffff8UL,\n-    0x535ad890UL, 0xbf2b9320UL, 0x00000000UL, 0x00000000UL, 0x018fdf1fUL,\n-    0x3f16d61dUL, 0x00000000UL, 0x00000000UL, 0x0359f1beUL, 0xbf0139e4UL,\n-    0xa4317c6dUL, 0xbfa67e17UL, 0x82672d0fUL, 0x3eebb405UL, 0x2f1b621eUL,\n-    0x3f9f455bUL, 0x51ccf238UL, 0xbed55317UL, 0xf437b9acUL, 0xbf804beeUL,\n-    0xc791a2b5UL, 0x3ec0e993UL, 0x919a1db2UL, 0x3f7080c2UL, 0x336a5b0eUL,\n-    0xbeaa48a2UL, 0x0a268358UL, 0xbf55a443UL, 0xdfd978e4UL, 0x3e94b61fUL,\n-    0xd7767a58UL, 0x3f431806UL, 0x2aea0000UL, 0xbfc9bbe8UL, 0x7723ea61UL,\n-    0xbd3a2369UL, 0x00000000UL, 0x00000000UL, 0xdf7796ffUL, 0x3fd6e642UL,\n-    0x00000000UL, 0x3ff00000UL, 0x00000000UL, 0xfffffff8UL, 0xb9ff07ceUL,\n-    0xbf231c78UL, 0x00000000UL, 0x00000000UL, 0xa5517182UL, 0x3f0ff0e0UL,\n-    0x00000000UL, 0x00000000UL, 0x790b4cbcUL, 0xbef66191UL, 0x848a46c6UL,\n-    0xbfa21ac0UL, 0xb16435faUL, 0x3ee1d3ecUL, 0x2a1aa832UL, 0x3f9c71eaUL,\n-    0xfdd299efUL, 0xbec9dd1aUL, 0x3f8dbaafUL, 0xbf793363UL, 0x309fc6eaUL,\n-    0x3eb415d6UL, 0xbee60471UL, 0x3f6b83baUL, 0x94a0a697UL, 0xbe9dae11UL,\n-    0x3e5c67b3UL, 0xbf4fd07bUL, 0x9a8f3e3eUL, 0x3e86bd75UL, 0xa4beb7a4UL,\n-    0x3f3d1eb1UL, 0x29cfc000UL, 0xbfc549ceUL, 0xbf159358UL, 0xbd397b33UL,\n-    0x00000000UL, 0x00000000UL, 0x871fee6cUL, 0x3fd666f0UL, 0x00000000UL,\n-    0x3ff00000UL, 0x00000000UL, 0xfffffff8UL, 0x7d98a556UL, 0xbf1a3958UL,\n-    0x00000000UL, 0x00000000UL, 0x9d88dc01UL, 0x3f0704c2UL, 0x00000000UL,\n-    0x00000000UL, 0x73742a2bUL, 0xbeed054aUL, 0x58844587UL, 0xbf9c2a13UL,\n-    0x55688a79UL, 0x3ed7a326UL, 0xee33f1d6UL, 0x3f9a48f4UL, 0xa8dc9888UL,\n-    0xbebf8939UL, 0xaad4b5b8UL, 0xbf72f746UL, 0x9102efa1UL, 0x3ea88f82UL,\n-    0xdabc29cfUL, 0x3f678228UL, 0x9289afb8UL, 0xbe90f456UL, 0x741fb4edUL,\n-    0xbf46f3a3UL, 0xa97f6663UL, 0x3e79b4bfUL, 0xca89ff3fUL, 0x3f36db70UL,\n-    0xa8a2a000UL, 0xbfc0ee13UL, 0x3da24be1UL, 0xbd338b9fUL, 0x00000000UL,\n-    0x00000000UL, 0x11cd6c69UL, 0x3fd601fdUL, 0x00000000UL, 0x3ff00000UL,\n-    0x00000000UL, 0xfffffff8UL, 0x1a154b97UL, 0xbf116b01UL, 0x00000000UL,\n-    0x00000000UL, 0x2d427630UL, 0x3f0147bfUL, 0x00000000UL, 0x00000000UL,\n-    0xb93820c8UL, 0xbee264d4UL, 0xbb6cbb18UL, 0xbf94ab8cUL, 0x888d4d92UL,\n-    0x3ed0568bUL, 0x60730f7cUL, 0x3f98b19bUL, 0xe4b1fb11UL, 0xbeb2f950UL,\n-    0x22cf9f74UL, 0xbf6b21cdUL, 0x4a3ff0a6UL, 0x3e9f499eUL, 0xfd2b83ceUL,\n-    0x3f64aad7UL, 0x637b73afUL, 0xbe83487cUL, 0xe522591aUL, 0xbf3fc092UL,\n-    0xa158e8bcUL, 0x3e6e3aaeUL, 0xe5e82ffaUL, 0x3f329d2fUL, 0xd636a000UL,\n-    0xbfb9477fUL, 0xc2c2d2bcUL, 0xbd135ef9UL, 0x00000000UL, 0x00000000UL,\n-    0xf2fdb123UL, 0x3fd5b566UL, 0x00000000UL, 0x3ff00000UL, 0x00000000UL,\n-    0xfffffff8UL, 0xc41acb64UL, 0xbf05448dUL, 0x00000000UL, 0x00000000UL,\n-    0xdbb03d6fUL, 0x3efb7ad2UL, 0x00000000UL, 0x00000000UL, 0x9e42962dUL,\n-    0xbed5aea5UL, 0x2579f8efUL, 0xbf8b2398UL, 0x288a1ed9UL, 0x3ec81441UL,\n-    0xb0198dc5UL, 0x3f979a3aUL, 0x2fdfe253UL, 0xbea57cd3UL, 0x5766336fUL,\n-    0xbf617caaUL, 0x600944c3UL, 0x3e954ed6UL, 0xa4e0aaf8UL, 0x3f62c646UL,\n-    0x6b8fb29cUL, 0xbe74e3a3UL, 0xdc4c0409UL, 0xbf33f952UL, 0x9bffe365UL,\n-    0x3e6301ecUL, 0xb8869e44UL, 0x3f2fc566UL, 0xe1e04000UL, 0xbfb0cc62UL,\n-    0x016b907fUL, 0xbd119cbcUL, 0x00000000UL, 0x00000000UL, 0xe6b9d8faUL,\n-    0x3fd57fb3UL, 0x00000000UL, 0x3ff00000UL, 0x00000000UL, 0xfffffff8UL,\n-    0x5daf22a6UL, 0xbef429d7UL, 0x00000000UL, 0x00000000UL, 0x06bca545UL,\n-    0x3ef7a27dUL, 0x00000000UL, 0x00000000UL, 0x7211c19aUL, 0xbec41c3eUL,\n-    0x956ed53eUL, 0xbf7ae3f4UL, 0xee750e72UL, 0x3ec3901bUL, 0x91d443f5UL,\n-    0x3f96f713UL, 0x36661e6cUL, 0xbe936e09UL, 0x506f9381UL, 0xbf5122e8UL,\n-    0xcb6dd43fUL, 0x3e9041b9UL, 0x6698b2ffUL, 0x3f61b0c7UL, 0x576bf12bUL,\n-    0xbe625a8aUL, 0xe5a0e9dcUL, 0xbf23499dUL, 0x110384ddUL, 0x3e5b1c2cUL,\n-    0x68d43db6UL, 0x3f2cb899UL, 0x6ecac000UL, 0xbfa0c414UL, 0xcd7dd58cUL,\n-    0x3d13500fUL, 0x00000000UL, 0x00000000UL, 0x85a2c8fbUL, 0x3fd55fe0UL,\n-    0x00000000UL, 0x3ff00000UL, 0x00000000UL, 0xfffffff8UL, 0x00000000UL,\n-    0x00000000UL, 0x00000000UL, 0x00000000UL, 0x2bf70ebeUL, 0x3ef66a8fUL,\n-    0x00000000UL, 0x00000000UL, 0x00000000UL, 0x00000000UL, 0x00000000UL,\n-    0x00000000UL, 0xd644267fUL, 0x3ec22805UL, 0x16c16c17UL, 0x3f96c16cUL,\n-    0x00000000UL, 0x00000000UL, 0x00000000UL, 0x00000000UL, 0xc4e09162UL,\n-    0x3e8d6db2UL, 0xbc011567UL, 0x3f61566aUL, 0x00000000UL, 0x00000000UL,\n-    0x00000000UL, 0x00000000UL, 0x1f79955cUL, 0x3e57da4eUL, 0x9334ef0bUL,\n-    0x3f2bbd77UL, 0x00000000UL, 0x00000000UL, 0x00000000UL, 0x00000000UL,\n-    0x00000000UL, 0x00000000UL, 0x55555555UL, 0x3fd55555UL, 0x00000000UL,\n-    0x3ff00000UL, 0x00000000UL, 0xfffffff8UL, 0x5daf22a6UL, 0x3ef429d7UL,\n-    0x00000000UL, 0x00000000UL, 0x06bca545UL, 0x3ef7a27dUL, 0x00000000UL,\n-    0x00000000UL, 0x7211c19aUL, 0x3ec41c3eUL, 0x956ed53eUL, 0x3f7ae3f4UL,\n-    0xee750e72UL, 0x3ec3901bUL, 0x91d443f5UL, 0x3f96f713UL, 0x36661e6cUL,\n-    0x3e936e09UL, 0x506f9381UL, 0x3f5122e8UL, 0xcb6dd43fUL, 0x3e9041b9UL,\n-    0x6698b2ffUL, 0x3f61b0c7UL, 0x576bf12bUL, 0x3e625a8aUL, 0xe5a0e9dcUL,\n-    0x3f23499dUL, 0x110384ddUL, 0x3e5b1c2cUL, 0x68d43db6UL, 0x3f2cb899UL,\n-    0x6ecac000UL, 0x3fa0c414UL, 0xcd7dd58cUL, 0xbd13500fUL, 0x00000000UL,\n-    0x00000000UL, 0x85a2c8fbUL, 0x3fd55fe0UL, 0x00000000UL, 0x3ff00000UL,\n-    0x00000000UL, 0xfffffff8UL, 0xc41acb64UL, 0x3f05448dUL, 0x00000000UL,\n-    0x00000000UL, 0xdbb03d6fUL, 0x3efb7ad2UL, 0x00000000UL, 0x00000000UL,\n-    0x9e42962dUL, 0x3ed5aea5UL, 0x2579f8efUL, 0x3f8b2398UL, 0x288a1ed9UL,\n-    0x3ec81441UL, 0xb0198dc5UL, 0x3f979a3aUL, 0x2fdfe253UL, 0x3ea57cd3UL,\n-    0x5766336fUL, 0x3f617caaUL, 0x600944c3UL, 0x3e954ed6UL, 0xa4e0aaf8UL,\n-    0x3f62c646UL, 0x6b8fb29cUL, 0x3e74e3a3UL, 0xdc4c0409UL, 0x3f33f952UL,\n-    0x9bffe365UL, 0x3e6301ecUL, 0xb8869e44UL, 0x3f2fc566UL, 0xe1e04000UL,\n-    0x3fb0cc62UL, 0x016b907fUL, 0x3d119cbcUL, 0x00000000UL, 0x00000000UL,\n-    0xe6b9d8faUL, 0x3fd57fb3UL, 0x00000000UL, 0x3ff00000UL, 0x00000000UL,\n-    0xfffffff8UL, 0x1a154b97UL, 0x3f116b01UL, 0x00000000UL, 0x00000000UL,\n-    0x2d427630UL, 0x3f0147bfUL, 0x00000000UL, 0x00000000UL, 0xb93820c8UL,\n-    0x3ee264d4UL, 0xbb6cbb18UL, 0x3f94ab8cUL, 0x888d4d92UL, 0x3ed0568bUL,\n-    0x60730f7cUL, 0x3f98b19bUL, 0xe4b1fb11UL, 0x3eb2f950UL, 0x22cf9f74UL,\n-    0x3f6b21cdUL, 0x4a3ff0a6UL, 0x3e9f499eUL, 0xfd2b83ceUL, 0x3f64aad7UL,\n-    0x637b73afUL, 0x3e83487cUL, 0xe522591aUL, 0x3f3fc092UL, 0xa158e8bcUL,\n-    0x3e6e3aaeUL, 0xe5e82ffaUL, 0x3f329d2fUL, 0xd636a000UL, 0x3fb9477fUL,\n-    0xc2c2d2bcUL, 0x3d135ef9UL, 0x00000000UL, 0x00000000UL, 0xf2fdb123UL,\n-    0x3fd5b566UL, 0x00000000UL, 0x3ff00000UL, 0x00000000UL, 0xfffffff8UL,\n-    0x7d98a556UL, 0x3f1a3958UL, 0x00000000UL, 0x00000000UL, 0x9d88dc01UL,\n-    0x3f0704c2UL, 0x00000000UL, 0x00000000UL, 0x73742a2bUL, 0x3eed054aUL,\n-    0x58844587UL, 0x3f9c2a13UL, 0x55688a79UL, 0x3ed7a326UL, 0xee33f1d6UL,\n-    0x3f9a48f4UL, 0xa8dc9888UL, 0x3ebf8939UL, 0xaad4b5b8UL, 0x3f72f746UL,\n-    0x9102efa1UL, 0x3ea88f82UL, 0xdabc29cfUL, 0x3f678228UL, 0x9289afb8UL,\n-    0x3e90f456UL, 0x741fb4edUL, 0x3f46f3a3UL, 0xa97f6663UL, 0x3e79b4bfUL,\n-    0xca89ff3fUL, 0x3f36db70UL, 0xa8a2a000UL, 0x3fc0ee13UL, 0x3da24be1UL,\n-    0x3d338b9fUL, 0x00000000UL, 0x00000000UL, 0x11cd6c69UL, 0x3fd601fdUL,\n-    0x00000000UL, 0x3ff00000UL, 0x00000000UL, 0xfffffff8UL, 0xb9ff07ceUL,\n-    0x3f231c78UL, 0x00000000UL, 0x00000000UL, 0xa5517182UL, 0x3f0ff0e0UL,\n-    0x00000000UL, 0x00000000UL, 0x790b4cbcUL, 0x3ef66191UL, 0x848a46c6UL,\n-    0x3fa21ac0UL, 0xb16435faUL, 0x3ee1d3ecUL, 0x2a1aa832UL, 0x3f9c71eaUL,\n-    0xfdd299efUL, 0x3ec9dd1aUL, 0x3f8dbaafUL, 0x3f793363UL, 0x309fc6eaUL,\n-    0x3eb415d6UL, 0xbee60471UL, 0x3f6b83baUL, 0x94a0a697UL, 0x3e9dae11UL,\n-    0x3e5c67b3UL, 0x3f4fd07bUL, 0x9a8f3e3eUL, 0x3e86bd75UL, 0xa4beb7a4UL,\n-    0x3f3d1eb1UL, 0x29cfc000UL, 0x3fc549ceUL, 0xbf159358UL, 0x3d397b33UL,\n-    0x00000000UL, 0x00000000UL, 0x871fee6cUL, 0x3fd666f0UL, 0x00000000UL,\n-    0x3ff00000UL, 0x00000000UL, 0xfffffff8UL, 0x535ad890UL, 0x3f2b9320UL,\n-    0x00000000UL, 0x00000000UL, 0x018fdf1fUL, 0x3f16d61dUL, 0x00000000UL,\n-    0x00000000UL, 0x0359f1beUL, 0x3f0139e4UL, 0xa4317c6dUL, 0x3fa67e17UL,\n-    0x82672d0fUL, 0x3eebb405UL, 0x2f1b621eUL, 0x3f9f455bUL, 0x51ccf238UL,\n-    0x3ed55317UL, 0xf437b9acUL, 0x3f804beeUL, 0xc791a2b5UL, 0x3ec0e993UL,\n-    0x919a1db2UL, 0x3f7080c2UL, 0x336a5b0eUL, 0x3eaa48a2UL, 0x0a268358UL,\n-    0x3f55a443UL, 0xdfd978e4UL, 0x3e94b61fUL, 0xd7767a58UL, 0x3f431806UL,\n-    0x2aea0000UL, 0x3fc9bbe8UL, 0x7723ea61UL, 0x3d3a2369UL, 0x00000000UL,\n-    0x00000000UL, 0xdf7796ffUL, 0x3fd6e642UL, 0x00000000UL, 0x3ff00000UL,\n-    0x00000000UL, 0xfffffff8UL, 0x4f48b8d3UL, 0x3f33eaf9UL, 0x00000000UL,\n-    0x00000000UL, 0x0cf7586fUL, 0x3f20b8eaUL, 0x00000000UL, 0x00000000UL,\n-    0xd0258911UL, 0x3f0abaf3UL, 0x23e49fe9UL, 0x3fab5a8cUL, 0x2d53222eUL,\n-    0x3ef60d15UL, 0x21169451UL, 0x3fa172b2UL, 0xbb254dbcUL, 0x3ee1d3b5UL,\n-    0xdbf93b8eUL, 0x3f84c7dbUL, 0x05b4630bUL, 0x3ecd3364UL, 0xee9aada7UL,\n-    0x3f743924UL, 0x794a8297UL, 0x3eb7b7b9UL, 0xe015f797UL, 0x3f5d41f5UL,\n-    0xe41a4a56UL, 0x3ea35dfbUL, 0xe4c2a251UL, 0x3f49a2abUL, 0x5af9e000UL,\n-    0x3fce49ceUL, 0x8c743719UL, 0xbd1eb860UL, 0x00000000UL, 0x00000000UL,\n-    0x1b4863cfUL, 0x3fd78294UL, 0x00000000UL, 0x3ff00000UL, 0x00000000UL,\n-    0xfffffff8UL, 0x65965966UL, 0xc0219659UL, 0x00000000UL, 0x00000000UL,\n-    0x882c10faUL, 0x402664f4UL, 0x00000000UL, 0x00000000UL, 0x83cd3723UL,\n-    0xc02c8342UL, 0x00000000UL, 0xc0000000UL, 0x55e6c23dUL, 0x403226e3UL,\n-    0x55555555UL, 0x40055555UL, 0x34451939UL, 0xc0371c96UL, 0xaaaaaaabUL,\n-    0xc00aaaaaUL, 0x0e157de0UL, 0x403d6d3dUL, 0x11111111UL, 0x40111111UL,\n-    0xa738201fUL, 0xc042bbceUL, 0x05b05b06UL, 0xc015b05bUL, 0x452b75e3UL,\n-    0x4047da36UL, 0x1ba1ba1cUL, 0x401ba1baUL, 0x00000000UL, 0xbff00000UL,\n-    0x00000000UL, 0x00000000UL, 0x00000000UL, 0x40000000UL, 0x00000000UL,\n-    0x00000000UL, 0x00000000UL, 0x00000000UL, 0x00000000UL, 0x00000000UL,\n-    0xc7ab4d5aUL, 0xc0085e24UL, 0x00000000UL, 0x00000000UL, 0xe93ea75dUL,\n-    0x400b963dUL, 0x00000000UL, 0x00000000UL, 0x94a7f25aUL, 0xc00f37e2UL,\n-    0x4b6261cbUL, 0xbff5f984UL, 0x5a9dd812UL, 0x4011aab0UL, 0x74c30018UL,\n-    0x3ffaf5a5UL, 0x7f2ce8e3UL, 0xc013fe8bUL, 0xfe8e54faUL, 0xbffd7334UL,\n-    0x670d618dUL, 0x4016a10cUL, 0x4db97058UL, 0x4000e012UL, 0x24df44ddUL,\n-    0xc0199c5fUL, 0x697d6eceUL, 0xc003006eUL, 0x83298b82UL, 0x401cfc4dUL,\n-    0x19d490d6UL, 0x40058c19UL, 0x2ae42850UL, 0xbfea4300UL, 0x118e20e6UL,\n-    0x3c7a6db8UL, 0x00000000UL, 0x40000000UL, 0xe33345b8UL, 0xbfd4e526UL,\n-    0x00000000UL, 0x00000000UL, 0x00000000UL, 0x00000000UL, 0x2b2c49d0UL,\n-    0xbff2de9cUL, 0x00000000UL, 0x00000000UL, 0x2655bc98UL, 0x3ff33e58UL,\n-    0x00000000UL, 0x00000000UL, 0xff691fa2UL, 0xbff3972eUL, 0xe93463bdUL,\n-    0xbfeeed87UL, 0x070e10a0UL, 0x3ff3f5b2UL, 0xf4d790a4UL, 0x3ff20c10UL,\n-    0xa04e8ea3UL, 0xbff4541aUL, 0x386accd3UL, 0xbff1369eUL, 0x222a66ddUL,\n-    0x3ff4b521UL, 0x22a9777eUL, 0x3ff20817UL, 0x52a04a6eUL, 0xbff5178fUL,\n-    0xddaa0031UL, 0xbff22137UL, 0x4447d47cUL, 0x3ff57c01UL, 0x1e9c7f1dUL,\n-    0x3ff29311UL, 0x2ab7f990UL, 0xbfe561b8UL, 0x209c7df1UL, 0xbc87a8c5UL,\n-    0x00000000UL, 0x3ff00000UL, 0x4170bcc6UL, 0x3fdc92d8UL, 0x00000000UL,\n-    0x00000000UL, 0x00000000UL, 0x00000000UL, 0xcc03e501UL, 0xbfdff10fUL,\n-    0x00000000UL, 0x00000000UL, 0x44a4e845UL, 0x3fddb63bUL, 0x00000000UL,\n-    0x00000000UL, 0x3768ad9fUL, 0xbfdb72a4UL, 0x3dd01ccaUL, 0xbfe5fdb9UL,\n-    0xa61d2811UL, 0x3fd972b2UL, 0x5645ad0bUL, 0x3fe977f9UL, 0xd013b3abUL,\n-    0xbfd78ca3UL, 0xbf0bf914UL, 0xbfe4f192UL, 0x4d53e730UL, 0x3fd5d060UL,\n-    0x3f8b9000UL, 0x3fe49933UL, 0xe2b82f08UL, 0xbfd4322aUL, 0x5936a835UL,\n-    0xbfe27ae1UL, 0xb1c61c9bUL, 0x3fd2b3fbUL, 0xef478605UL, 0x3fe1659eUL,\n-    0x190834ecUL, 0xbfe11ab7UL, 0xcdb625eaUL, 0x3c8e564bUL, 0x00000000UL,\n-    0x3ff00000UL, 0xb07217e3UL, 0x3fd248f1UL, 0x00000000UL, 0x00000000UL,\n-    0x00000000UL, 0x00000000UL, 0x56f37042UL, 0xbfccfc56UL, 0x00000000UL,\n-    0x00000000UL, 0xaa563951UL, 0x3fc90125UL, 0x00000000UL, 0x00000000UL,\n-    0x3d0e7c5dUL, 0xbfc50533UL, 0x9bed9b2eUL, 0xbfdf0ed9UL, 0x5fe7c47cUL,\n-    0x3fc1f250UL, 0x96c125e5UL, 0x3fe2edd9UL, 0x5a02bbd8UL, 0xbfbe5c71UL,\n-    0x86362c20UL, 0xbfda08b7UL, 0x4b4435edUL, 0x3fb9d342UL, 0x4b494091UL,\n-    0x3fd911bdUL, 0xb56658beUL, 0xbfb5e4c7UL, 0x93a2fd76UL, 0xbfd3c092UL,\n-    0xda271794UL, 0x3fb29910UL, 0x3303df2bUL, 0x3fd189beUL, 0x99fcef32UL,\n-    0xbfda8279UL, 0xb68c1467UL, 0xbc708b2fUL, 0x00000000UL, 0x3ff00000UL,\n-    0x980c4337UL, 0x3fc5f619UL, 0x00000000UL, 0x00000000UL, 0x00000000UL,\n-    0x00000000UL, 0x9314533eUL, 0xbfbb8ec5UL, 0x00000000UL, 0x00000000UL,\n-    0x09aa36d0UL, 0x3fb6d3f4UL, 0x00000000UL, 0x00000000UL, 0xdcb427fdUL,\n-    0xbfb13950UL, 0xd87ab0bbUL, 0xbfd5335eUL, 0xce0ae8a5UL, 0x3fabb382UL,\n-    0x79143126UL, 0x3fddba41UL, 0x5f2b28d4UL, 0xbfa552f1UL, 0x59f21a6dUL,\n-    0xbfd015abUL, 0x22c27d95UL, 0x3fa0e984UL, 0xe19fc6aaUL, 0x3fd0576cUL,\n-    0x8f2c2950UL, 0xbf9a4898UL, 0xc0b3f22cUL, 0xbfc59462UL, 0x1883a4b8UL,\n-    0x3f94b61cUL, 0x3f838640UL, 0x3fc30eb8UL, 0x355c63dcUL, 0xbfd36a08UL,\n-    0x1dce993dUL, 0x3c6d704dUL, 0x00000000UL, 0x3ff00000UL, 0x2b82ab63UL,\n-    0x3fb78e92UL, 0x00000000UL, 0x00000000UL, 0x00000000UL, 0x00000000UL,\n-    0x5a279ea3UL, 0xbfaa3407UL, 0x00000000UL, 0x00000000UL, 0x432d65faUL,\n-    0x3fa70153UL, 0x00000000UL, 0x00000000UL, 0x891a4602UL, 0xbf9d03efUL,\n-    0xd62ca5f8UL, 0xbfca77d9UL, 0xb35f4628UL, 0x3f97a265UL, 0x433258faUL,\n-    0x3fd8cf51UL, 0xb58fd909UL, 0xbf8f88e3UL, 0x01771ceaUL, 0xbfc2b154UL,\n-    0xf3562f8eUL, 0x3f888f57UL, 0xc028a723UL, 0x3fc7370fUL, 0x20b7f9f0UL,\n-    0xbf80f44cUL, 0x214368e9UL, 0xbfb6dfaaUL, 0x28891863UL, 0x3f79b4b6UL,\n-    0x172dbbf0UL, 0x3fb6cb8eUL, 0xe0553158UL, 0xbfc975f5UL, 0x593fe814UL,\n-    0xbc2ef5d3UL, 0x00000000UL, 0x3ff00000UL, 0x03dec550UL, 0x3fa44203UL,\n-    0x00000000UL, 0x00000000UL, 0x00000000UL, 0x00000000UL, 0x4e435f9bUL,\n-    0xbf953f83UL, 0x00000000UL, 0x00000000UL, 0x3c6e8e46UL, 0x3f9b74eaUL,\n-    0x00000000UL, 0x00000000UL, 0xda5b7511UL, 0xbf85ad63UL, 0xdc230b9bUL,\n-    0xbfb97558UL, 0x26cb3788UL, 0x3f881308UL, 0x76fc4985UL, 0x3fd62ac9UL,\n-    0x77bb08baUL, 0xbf757c85UL, 0xb6247521UL, 0xbfb1381eUL, 0x5922170cUL,\n-    0x3f754e95UL, 0x8746482dUL, 0x3fc27f83UL, 0x11055b30UL, 0xbf64e391UL,\n-    0x3e666320UL, 0xbfa3e609UL, 0x0de9dae3UL, 0x3f6301dfUL, 0x1f1dca06UL,\n-    0x3fafa8aeUL, 0x8c5b2da2UL, 0xbfb936bbUL, 0x4e88f7a5UL, 0xbc587d05UL,\n-    0x00000000UL, 0x3ff00000UL, 0xa8935dd9UL, 0x3f83dde2UL, 0x00000000UL,\n-    0x00000000UL, 0x00000000UL, 0x00000000UL, 0x6dc9c883UL, 0x3fe45f30UL,\n-    0x6dc9c883UL, 0x40245f30UL, 0x00000000UL, 0x43780000UL, 0x00000000UL,\n-    0x43380000UL, 0x54444000UL, 0x3fb921fbUL, 0x54440000UL, 0x3fb921fbUL,\n-    0x67674000UL, 0xbd32e7b9UL, 0x4c4c0000UL, 0x3d468c23UL, 0x3707344aUL,\n-    0x3aa8a2e0UL, 0x03707345UL, 0x3ae98a2eUL, 0x00000000UL, 0x80000000UL,\n-    0x00000000UL, 0x80000000UL, 0x676733afUL, 0x3d32e7b9UL, 0x00000000UL,\n-    0x00000000UL, 0x00000000UL, 0x3ff00000UL, 0x00000000UL, 0x00000000UL,\n-    0x00000000UL, 0x7ff00000UL, 0x00000000UL, 0x00000000UL, 0xfffc0000UL,\n-    0xffffffffUL, 0x00000000UL, 0x00000000UL, 0x00000000UL, 0x43600000UL,\n-    0x00000000UL, 0x00000000UL, 0x00000000UL, 0x3c800000UL, 0x00000000UL,\n-    0x00000000UL, 0x00000000UL, 0x3ca00000UL, 0x00000000UL, 0x00000000UL,\n-    0x00000000UL, 0x3fe00000UL, 0x00000000UL, 0x3fe00000UL, 0x00000000UL,\n-    0x40300000UL, 0x00000000UL, 0x3ff00000UL\n-};\n-\n-void MacroAssembler::fast_tan(XMMRegister xmm0, XMMRegister xmm1, XMMRegister xmm2, XMMRegister xmm3, XMMRegister xmm4, XMMRegister xmm5, XMMRegister xmm6, XMMRegister xmm7, Register eax, Register ecx, Register edx, Register tmp) {\n-\n-  Label L_2TAG_PACKET_0_0_2, L_2TAG_PACKET_1_0_2, L_2TAG_PACKET_2_0_2, L_2TAG_PACKET_3_0_2;\n-  Label L_2TAG_PACKET_4_0_2;\n-\n-  assert_different_registers(tmp, eax, ecx, edx);\n-\n-  address static_const_table_tan = (address)_static_const_table_tan;\n-\n-  subl(rsp, 120);\n-  movl(Address(rsp, 56), tmp);\n-  lea(tmp, ExternalAddress(static_const_table_tan));\n-  movsd(xmm0, Address(rsp, 128));\n-  pextrw(eax, xmm0, 3);\n-  andl(eax, 32767);\n-  subl(eax, 14368);\n-  cmpl(eax, 2216);\n-  jcc(Assembler::above, L_2TAG_PACKET_0_0_2);\n-  movdqu(xmm5, Address(tmp, 5840));\n-  movdqu(xmm6, Address(tmp, 5856));\n-  unpcklpd(xmm0, xmm0);\n-  movdqu(xmm4, Address(tmp, 5712));\n-  andpd(xmm4, xmm0);\n-  movdqu(xmm1, Address(tmp, 5632));\n-  mulpd(xmm1, xmm0);\n-  por(xmm5, xmm4);\n-  addpd(xmm1, xmm5);\n-  movdqu(xmm7, xmm1);\n-  unpckhpd(xmm7, xmm7);\n-  cvttsd2sil(edx, xmm7);\n-  cvttpd2dq(xmm1, xmm1);\n-  cvtdq2pd(xmm1, xmm1);\n-  mulpd(xmm1, xmm6);\n-  movdqu(xmm3, Address(tmp, 5664));\n-  movsd(xmm5, Address(tmp, 5728));\n-  addl(edx, 469248);\n-  movdqu(xmm4, Address(tmp, 5680));\n-  mulpd(xmm3, xmm1);\n-  andl(edx, 31);\n-  mulsd(xmm5, xmm1);\n-  movl(ecx, edx);\n-  mulpd(xmm4, xmm1);\n-  shll(ecx, 1);\n-  subpd(xmm0, xmm3);\n-  mulpd(xmm1, Address(tmp, 5696));\n-  addl(edx, ecx);\n-  shll(ecx, 2);\n-  addl(edx, ecx);\n-  addsd(xmm5, xmm0);\n-  movdqu(xmm2, xmm0);\n-  subpd(xmm0, xmm4);\n-  movsd(xmm6, Address(tmp, 5744));\n-  shll(edx, 4);\n-  lea(eax, Address(tmp, 0));\n-  andpd(xmm5, Address(tmp, 5776));\n-  movdqu(xmm3, xmm0);\n-  addl(eax, edx);\n-  subpd(xmm2, xmm0);\n-  unpckhpd(xmm0, xmm0);\n-  divsd(xmm6, xmm5);\n-  subpd(xmm2, xmm4);\n-  movdqu(xmm7, Address(eax, 16));\n-  subsd(xmm3, xmm5);\n-  mulpd(xmm7, xmm0);\n-  subpd(xmm2, xmm1);\n-  movdqu(xmm1, Address(eax, 48));\n-  mulpd(xmm1, xmm0);\n-  movdqu(xmm4, Address(eax, 96));\n-  mulpd(xmm4, xmm0);\n-  addsd(xmm2, xmm3);\n-  movdqu(xmm3, xmm0);\n-  mulpd(xmm0, xmm0);\n-  addpd(xmm7, Address(eax, 0));\n-  addpd(xmm1, Address(eax, 32));\n-  mulpd(xmm1, xmm0);\n-  addpd(xmm4, Address(eax, 80));\n-  addpd(xmm7, xmm1);\n-  movdqu(xmm1, Address(eax, 112));\n-  mulpd(xmm1, xmm0);\n-  mulpd(xmm0, xmm0);\n-  addpd(xmm4, xmm1);\n-  movdqu(xmm1, Address(eax, 64));\n-  mulpd(xmm1, xmm0);\n-  addpd(xmm7, xmm1);\n-  movdqu(xmm1, xmm3);\n-  mulpd(xmm3, xmm0);\n-  mulsd(xmm0, xmm0);\n-  mulpd(xmm1, Address(eax, 144));\n-  mulpd(xmm4, xmm3);\n-  movdqu(xmm3, xmm1);\n-  addpd(xmm7, xmm4);\n-  movdqu(xmm4, xmm1);\n-  mulsd(xmm0, xmm7);\n-  unpckhpd(xmm7, xmm7);\n-  addsd(xmm0, xmm7);\n-  unpckhpd(xmm1, xmm1);\n-  addsd(xmm3, xmm1);\n-  subsd(xmm4, xmm3);\n-  addsd(xmm1, xmm4);\n-  movdqu(xmm4, xmm2);\n-  movsd(xmm7, Address(eax, 144));\n-  unpckhpd(xmm2, xmm2);\n-  addsd(xmm7, Address(eax, 152));\n-  mulsd(xmm7, xmm2);\n-  addsd(xmm7, Address(eax, 136));\n-  addsd(xmm7, xmm1);\n-  addsd(xmm0, xmm7);\n-  movsd(xmm7, Address(tmp, 5744));\n-  mulsd(xmm4, xmm6);\n-  movsd(xmm2, Address(eax, 168));\n-  andpd(xmm2, xmm6);\n-  mulsd(xmm5, xmm2);\n-  mulsd(xmm6, Address(eax, 160));\n-  subsd(xmm7, xmm5);\n-  subsd(xmm2, Address(eax, 128));\n-  subsd(xmm7, xmm4);\n-  mulsd(xmm7, xmm6);\n-  movdqu(xmm4, xmm3);\n-  subsd(xmm3, xmm2);\n-  addsd(xmm2, xmm3);\n-  subsd(xmm4, xmm2);\n-  addsd(xmm0, xmm4);\n-  subsd(xmm0, xmm7);\n-  addsd(xmm0, xmm3);\n-  movsd(Address(rsp, 0), xmm0);\n-  fld_d(Address(rsp, 0));\n-  jmp(L_2TAG_PACKET_1_0_2);\n-\n-  bind(L_2TAG_PACKET_0_0_2);\n-  jcc(Assembler::greater, L_2TAG_PACKET_2_0_2);\n-  shrl(eax, 4);\n-  cmpl(eax, 268434558);\n-  jcc(Assembler::notEqual, L_2TAG_PACKET_3_0_2);\n-  movdqu(xmm3, xmm0);\n-  mulsd(xmm3, Address(tmp, 5808));\n-\n-  bind(L_2TAG_PACKET_3_0_2);\n-  movsd(xmm3, Address(tmp, 5792));\n-  mulsd(xmm3, xmm0);\n-  addsd(xmm3, xmm0);\n-  mulsd(xmm3, Address(tmp, 5808));\n-  movsd(Address(rsp, 0), xmm3);\n-  fld_d(Address(rsp, 0));\n-  jmp(L_2TAG_PACKET_1_0_2);\n-\n-  bind(L_2TAG_PACKET_2_0_2);\n-  movq(xmm7, Address(tmp, 5712));\n-  andpd(xmm7, xmm0);\n-  xorpd(xmm7, xmm0);\n-  ucomisd(xmm7, Address(tmp, 5760));\n-  jcc(Assembler::equal, L_2TAG_PACKET_4_0_2);\n-  subl(rsp, 32);\n-  movsd(Address(rsp, 0), xmm0);\n-  lea(eax, Address(rsp, 40));\n-  movl(Address(rsp, 8), eax);\n-  movl(eax, 2);\n-  movl(Address(rsp, 12), eax);\n-  call(RuntimeAddress(CAST_FROM_FN_PTR(address, StubRoutines::dlibm_tan_cot_huge())));\n-  addl(rsp, 32);\n-  fld_d(Address(rsp, 8));\n-  jmp(L_2TAG_PACKET_1_0_2);\n-\n-  bind(L_2TAG_PACKET_4_0_2);\n-  movq(Address(rsp, 0), xmm0);\n-  fld_d(Address(rsp, 0));\n-  fsub_d(Address(rsp, 0));\n-\n-  bind(L_2TAG_PACKET_1_0_2);\n-  movl(tmp, Address(rsp, 56));\n-}\n-#endif\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86_tan.cpp","additions":0,"deletions":2093,"binary":false,"changes":2093,"status":"deleted"},{"patch":"@@ -68,0 +68,16 @@\n+ATTRIBUTE_ALIGNED(16) uint32_t KEY_SHUFFLE_MASK[] = {\n+    0x00010203UL, 0x04050607UL, 0x08090A0BUL, 0x0C0D0E0FUL,\n+};\n+\n+ATTRIBUTE_ALIGNED(16) uint32_t COUNTER_SHUFFLE_MASK[] = {\n+    0x0C0D0E0FUL, 0x08090A0BUL, 0x04050607UL, 0x00010203UL,\n+};\n+\n+ATTRIBUTE_ALIGNED(16) uint32_t GHASH_BYTE_SWAP_MASK[] = {\n+    0x0C0D0E0FUL, 0x08090A0BUL, 0x04050607UL, 0x00010203UL,\n+};\n+\n+ATTRIBUTE_ALIGNED(16) uint32_t GHASH_LONG_SWAP_MASK[] = {\n+    0x0B0A0908UL, 0x0F0E0D0CUL, 0x03020100UL, 0x07060504UL,\n+};\n+\n@@ -2183,9 +2199,2 @@\n-  address generate_key_shuffle_mask() {\n-    __ align(16);\n-    StubCodeMark mark(this, \"StubRoutines\", \"key_shuffle_mask\");\n-    address start = __ pc();\n-    __ emit_data(0x00010203, relocInfo::none, 0 );\n-    __ emit_data(0x04050607, relocInfo::none, 0 );\n-    __ emit_data(0x08090a0b, relocInfo::none, 0 );\n-    __ emit_data(0x0c0d0e0f, relocInfo::none, 0 );\n-    return start;\n+  address key_shuffle_mask_addr() {\n+    return (address)KEY_SHUFFLE_MASK;\n@@ -2194,9 +2203,2 @@\n-  address generate_counter_shuffle_mask() {\n-    __ align(16);\n-    StubCodeMark mark(this, \"StubRoutines\", \"counter_shuffle_mask\");\n-    address start = __ pc();\n-    __ emit_data(0x0c0d0e0f, relocInfo::none, 0);\n-    __ emit_data(0x08090a0b, relocInfo::none, 0);\n-    __ emit_data(0x04050607, relocInfo::none, 0);\n-    __ emit_data(0x00010203, relocInfo::none, 0);\n-    return start;\n+  address counter_shuffle_mask_addr() {\n+    return (address)COUNTER_SHUFFLE_MASK;\n@@ -2212,1 +2214,1 @@\n-      __ pshufb(xmmdst, ExternalAddress(StubRoutines::x86::key_shuffle_mask_addr()));\n+      __ pshufb(xmmdst, ExternalAddress(key_shuffle_mask_addr()));\n@@ -2293,1 +2295,1 @@\n-    __ movdqu(xmm_key_shuf_mask, ExternalAddress(StubRoutines::x86::key_shuffle_mask_addr()));\n+    __ movdqu(xmm_key_shuf_mask, ExternalAddress(key_shuffle_mask_addr()));\n@@ -2392,1 +2394,1 @@\n-    __ movdqu(xmm_key_shuf_mask, ExternalAddress(StubRoutines::x86::key_shuffle_mask_addr()));\n+    __ movdqu(xmm_key_shuf_mask, ExternalAddress(key_shuffle_mask_addr()));\n@@ -2525,1 +2527,1 @@\n-    __ movdqu(xmm_key_shuf_mask, ExternalAddress(StubRoutines::x86::key_shuffle_mask_addr()));\n+    __ movdqu(xmm_key_shuf_mask, ExternalAddress(key_shuffle_mask_addr()));\n@@ -2693,1 +2695,1 @@\n-    __ movdqu(xmm_key_shuf_mask, ExternalAddress(StubRoutines::x86::key_shuffle_mask_addr()));\n+    __ movdqu(xmm_key_shuf_mask, ExternalAddress(key_shuffle_mask_addr()));\n@@ -2912,1 +2914,1 @@\n-    __ movdqu(xmm_counter_shuf_mask, ExternalAddress(StubRoutines::x86::counter_shuffle_mask_addr()));\n+    __ movdqu(xmm_counter_shuf_mask, ExternalAddress(counter_shuffle_mask_addr()));\n@@ -2916,1 +2918,1 @@\n-    __ movdqu(xmm_key_shuf_mask, ExternalAddress(StubRoutines::x86::key_shuffle_mask_addr()));\n+    __ movdqu(xmm_key_shuf_mask, ExternalAddress(key_shuffle_mask_addr()));\n@@ -2942,2 +2944,2 @@\n-      __ movdqu(xmm_key_shuf_mask, ExternalAddress(StubRoutines::x86::key_shuffle_mask_addr()));\n-      __ movdqu(xmm_counter_shuf_mask, ExternalAddress(StubRoutines::x86::counter_shuffle_mask_addr()));\n+      __ movdqu(xmm_key_shuf_mask, ExternalAddress(key_shuffle_mask_addr()));\n+      __ movdqu(xmm_counter_shuf_mask, ExternalAddress(counter_shuffle_mask_addr()));\n@@ -2995,2 +2997,2 @@\n-      __ movdqu(xmm_key_shuf_mask, ExternalAddress(StubRoutines::x86::key_shuffle_mask_addr()));\n-      __ movdqu(xmm_counter_shuf_mask, ExternalAddress(StubRoutines::x86::counter_shuffle_mask_addr()));\n+      __ movdqu(xmm_key_shuf_mask, ExternalAddress(key_shuffle_mask_addr()));\n+      __ movdqu(xmm_counter_shuf_mask, ExternalAddress(counter_shuffle_mask_addr()));\n@@ -3081,1 +3083,1 @@\n-    __ movdqu(xmm_counter_shuf_mask, ExternalAddress(StubRoutines::x86::counter_shuffle_mask_addr()));\n+    __ movdqu(xmm_counter_shuf_mask, ExternalAddress(counter_shuffle_mask_addr()));\n@@ -3269,10 +3271,2 @@\n-  address generate_ghash_long_swap_mask() {\n-    __ align(CodeEntryAlignment);\n-    StubCodeMark mark(this, \"StubRoutines\", \"ghash_long_swap_mask\");\n-    address start = __ pc();\n-    __ emit_data(0x0b0a0908, relocInfo::none, 0);\n-    __ emit_data(0x0f0e0d0c, relocInfo::none, 0);\n-    __ emit_data(0x03020100, relocInfo::none, 0);\n-    __ emit_data(0x07060504, relocInfo::none, 0);\n-\n-  return start;\n+  address ghash_long_swap_mask_addr() {\n+    return (address)GHASH_LONG_SWAP_MASK;\n@@ -3282,9 +3276,2 @@\n-  address generate_ghash_byte_swap_mask() {\n-    __ align(CodeEntryAlignment);\n-    StubCodeMark mark(this, \"StubRoutines\", \"ghash_byte_swap_mask\");\n-    address start = __ pc();\n-    __ emit_data(0x0c0d0e0f, relocInfo::none, 0);\n-    __ emit_data(0x08090a0b, relocInfo::none, 0);\n-    __ emit_data(0x04050607, relocInfo::none, 0);\n-    __ emit_data(0x00010203, relocInfo::none, 0);\n-  return start;\n+  address ghash_byte_swap_mask_addr() {\n+    return (address)GHASH_BYTE_SWAP_MASK;\n@@ -3329,1 +3316,1 @@\n-    __ pshufb(xmm_temp0, ExternalAddress(StubRoutines::x86::ghash_long_swap_mask_addr()));\n+    __ pshufb(xmm_temp0, ExternalAddress(ghash_long_swap_mask_addr()));\n@@ -3332,1 +3319,1 @@\n-    __ pshufb(xmm_temp1, ExternalAddress(StubRoutines::x86::ghash_long_swap_mask_addr()));\n+    __ pshufb(xmm_temp1, ExternalAddress(ghash_long_swap_mask_addr()));\n@@ -3336,1 +3323,1 @@\n-    __ pshufb(xmm_temp2, ExternalAddress(StubRoutines::x86::ghash_byte_swap_mask_addr()));\n+    __ pshufb(xmm_temp2, ExternalAddress(ghash_byte_swap_mask_addr()));\n@@ -3422,1 +3409,1 @@\n-    __ pshufb(xmm_temp6, ExternalAddress(StubRoutines::x86::ghash_long_swap_mask_addr()));\n+    __ pshufb(xmm_temp6, ExternalAddress(ghash_long_swap_mask_addr()));\n@@ -4129,2 +4116,0 @@\n-      StubRoutines::x86::_key_shuffle_mask_addr = generate_key_shuffle_mask();  \/\/ might be needed by the others\n-\n@@ -4138,1 +4123,0 @@\n-      StubRoutines::x86::_counter_shuffle_mask_addr = generate_counter_shuffle_mask();\n@@ -4161,2 +4145,0 @@\n-      StubRoutines::x86::_ghash_long_swap_mask_addr = generate_ghash_long_swap_mask();\n-      StubRoutines::x86::_ghash_byte_swap_mask_addr = generate_ghash_byte_swap_mask();\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_32.cpp","additions":40,"deletions":58,"binary":false,"changes":98,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-#include \"oops\/objArrayKlass.hpp\"\n@@ -43,0 +42,1 @@\n+#include \"opto\/c2_globals.hpp\"\n@@ -68,27 +68,0 @@\n-#ifdef PRODUCT\n-#define INC_COUNTER_NP(counter, rscratch) ((void)0)\n-#else\n-#define INC_COUNTER_NP(counter, rscratch) \\\n-BLOCK_COMMENT(\"inc_counter \" #counter); \\\n-inc_counter_np(_masm, counter, rscratch);\n-\n-static void inc_counter_np(MacroAssembler* _masm, int& counter, Register rscratch) {\n-  __ incrementl(ExternalAddress((address)&counter), rscratch);\n-}\n-\n-#if COMPILER2_OR_JVMCI\n-static int& get_profile_ctr(int shift) {\n-  if (shift == 0) {\n-    return SharedRuntime::_jbyte_array_copy_ctr;\n-  } else if (shift == 1) {\n-    return SharedRuntime::_jshort_array_copy_ctr;\n-  } else if (shift == 2) {\n-    return SharedRuntime::_jint_array_copy_ctr;\n-  } else {\n-    assert(shift == 3, \"\");\n-    return SharedRuntime::_jlong_array_copy_ctr;\n-  }\n-}\n-#endif \/\/ COMPILER2_OR_JVMCI\n-#endif \/\/ !PRODUCT\n-\n@@ -1147,49 +1120,0 @@\n-\/\/\n-\/\/ Verify that a register contains clean 32-bits positive value\n-\/\/ (high 32-bits are 0) so it could be used in 64-bits shifts.\n-\/\/\n-\/\/  Input:\n-\/\/    Rint  -  32-bits value\n-\/\/    Rtmp  -  scratch\n-\/\/\n-void StubGenerator::assert_clean_int(Register Rint, Register Rtmp) {\n-#ifdef ASSERT\n-  Label L;\n-  assert_different_registers(Rtmp, Rint);\n-  __ movslq(Rtmp, Rint);\n-  __ cmpq(Rtmp, Rint);\n-  __ jcc(Assembler::equal, L);\n-  __ stop(\"high 32-bits of int value are not 0\");\n-  __ bind(L);\n-#endif\n-}\n-\n-\/\/  Generate overlap test for array copy stubs\n-\/\/\n-\/\/  Input:\n-\/\/     c_rarg0 - from\n-\/\/     c_rarg1 - to\n-\/\/     c_rarg2 - element count\n-\/\/\n-\/\/  Output:\n-\/\/     rax   - &from[element count - 1]\n-\/\/\n-void StubGenerator::array_overlap_test(address no_overlap_target, Label* NOLp, Address::ScaleFactor sf) {\n-  const Register from     = c_rarg0;\n-  const Register to       = c_rarg1;\n-  const Register count    = c_rarg2;\n-  const Register end_from = rax;\n-\n-  __ cmpptr(to, from);\n-  __ lea(end_from, Address(from, count, sf, 0));\n-  if (NOLp == NULL) {\n-    ExternalAddress no_overlap(no_overlap_target);\n-    __ jump_cc(Assembler::belowEqual, no_overlap);\n-    __ cmpptr(to, end_from);\n-    __ jump_cc(Assembler::aboveEqual, no_overlap);\n-  } else {\n-    __ jcc(Assembler::belowEqual, (*NOLp));\n-    __ cmpptr(to, end_from);\n-    __ jcc(Assembler::aboveEqual, (*NOLp));\n-  }\n-}\n@@ -1217,2013 +1141,10 @@\n-  __ movptr(saved_rdi, rdi);\n-  __ movptr(saved_rsi, rsi);\n-  __ mov(rdi, rcx); \/\/ c_rarg0\n-  __ mov(rsi, rdx); \/\/ c_rarg1\n-  __ mov(rdx, r8);  \/\/ c_rarg2\n-  if (nargs >= 4)\n-    __ mov(rcx, rax); \/\/ c_rarg3 (via rax)\n-#else\n-  assert(c_rarg0 == rdi && c_rarg1 == rsi && c_rarg2 == rdx && c_rarg3 == rcx,\n-         \"unexpected argument registers\");\n-#endif\n-  DEBUG_ONLY(_regs_in_thread = false;)\n-}\n-\n-void StubGenerator::restore_arg_regs() {\n-  assert(!_regs_in_thread, \"wrong call to restore_arg_regs\");\n-  const Register saved_rdi = r9;\n-  const Register saved_rsi = r10;\n-#ifdef _WIN64\n-  __ movptr(rdi, saved_rdi);\n-  __ movptr(rsi, saved_rsi);\n-#endif\n-}\n-\n-\/\/ This is used in places where r10 is a scratch register, and can\n-\/\/ be adapted if r9 is needed also.\n-void StubGenerator::setup_arg_regs_using_thread() {\n-  const Register saved_r15 = r9;\n-#ifdef _WIN64\n-  __ mov(saved_r15, r15);  \/\/ r15 is callee saved and needs to be restored\n-  __ get_thread(r15_thread);\n-  assert(c_rarg0 == rcx && c_rarg1 == rdx && c_rarg2 == r8 && c_rarg3 == r9,\n-         \"unexpected argument registers\");\n-  __ movptr(Address(r15_thread, in_bytes(JavaThread::windows_saved_rdi_offset())), rdi);\n-  __ movptr(Address(r15_thread, in_bytes(JavaThread::windows_saved_rsi_offset())), rsi);\n-\n-  __ mov(rdi, rcx); \/\/ c_rarg0\n-  __ mov(rsi, rdx); \/\/ c_rarg1\n-  __ mov(rdx, r8);  \/\/ c_rarg2\n-#else\n-  assert(c_rarg0 == rdi && c_rarg1 == rsi && c_rarg2 == rdx && c_rarg3 == rcx,\n-         \"unexpected argument registers\");\n-#endif\n-  DEBUG_ONLY(_regs_in_thread = true;)\n-}\n-\n-void StubGenerator::restore_arg_regs_using_thread() {\n-  assert(_regs_in_thread, \"wrong call to restore_arg_regs\");\n-  const Register saved_r15 = r9;\n-#ifdef _WIN64\n-  __ get_thread(r15_thread);\n-  __ movptr(rsi, Address(r15_thread, in_bytes(JavaThread::windows_saved_rsi_offset())));\n-  __ movptr(rdi, Address(r15_thread, in_bytes(JavaThread::windows_saved_rdi_offset())));\n-  __ mov(r15, saved_r15);  \/\/ r15 is callee saved and needs to be restored\n-#endif\n-}\n-\n-\/\/ Copy big chunks forward\n-\/\/\n-\/\/ Inputs:\n-\/\/   end_from     - source arrays end address\n-\/\/   end_to       - destination array end address\n-\/\/   qword_count  - 64-bits element count, negative\n-\/\/   to           - scratch\n-\/\/   L_copy_bytes - entry label\n-\/\/   L_copy_8_bytes  - exit  label\n-\/\/\n-void StubGenerator::copy_bytes_forward(Register end_from, Register end_to,\n-                                       Register qword_count, Register to,\n-                                       Label& L_copy_bytes, Label& L_copy_8_bytes) {\n-  DEBUG_ONLY(__ stop(\"enter at entry label, not here\"));\n-  Label L_loop;\n-  __ align(OptoLoopAlignment);\n-  if (UseUnalignedLoadStores) {\n-    Label L_end;\n-    __ BIND(L_loop);\n-    if (UseAVX >= 2) {\n-      __ vmovdqu(xmm0, Address(end_from, qword_count, Address::times_8, -56));\n-      __ vmovdqu(Address(end_to, qword_count, Address::times_8, -56), xmm0);\n-      __ vmovdqu(xmm1, Address(end_from, qword_count, Address::times_8, -24));\n-      __ vmovdqu(Address(end_to, qword_count, Address::times_8, -24), xmm1);\n-    } else {\n-      __ movdqu(xmm0, Address(end_from, qword_count, Address::times_8, -56));\n-      __ movdqu(Address(end_to, qword_count, Address::times_8, -56), xmm0);\n-      __ movdqu(xmm1, Address(end_from, qword_count, Address::times_8, -40));\n-      __ movdqu(Address(end_to, qword_count, Address::times_8, -40), xmm1);\n-      __ movdqu(xmm2, Address(end_from, qword_count, Address::times_8, -24));\n-      __ movdqu(Address(end_to, qword_count, Address::times_8, -24), xmm2);\n-      __ movdqu(xmm3, Address(end_from, qword_count, Address::times_8, - 8));\n-      __ movdqu(Address(end_to, qword_count, Address::times_8, - 8), xmm3);\n-    }\n-\n-    __ BIND(L_copy_bytes);\n-    __ addptr(qword_count, 8);\n-    __ jcc(Assembler::lessEqual, L_loop);\n-    __ subptr(qword_count, 4);  \/\/ sub(8) and add(4)\n-    __ jccb(Assembler::greater, L_end);\n-    \/\/ Copy trailing 32 bytes\n-    if (UseAVX >= 2) {\n-      __ vmovdqu(xmm0, Address(end_from, qword_count, Address::times_8, -24));\n-      __ vmovdqu(Address(end_to, qword_count, Address::times_8, -24), xmm0);\n-    } else {\n-      __ movdqu(xmm0, Address(end_from, qword_count, Address::times_8, -24));\n-      __ movdqu(Address(end_to, qword_count, Address::times_8, -24), xmm0);\n-      __ movdqu(xmm1, Address(end_from, qword_count, Address::times_8, - 8));\n-      __ movdqu(Address(end_to, qword_count, Address::times_8, - 8), xmm1);\n-    }\n-    __ addptr(qword_count, 4);\n-    __ BIND(L_end);\n-  } else {\n-    \/\/ Copy 32-bytes per iteration\n-    __ BIND(L_loop);\n-    __ movq(to, Address(end_from, qword_count, Address::times_8, -24));\n-    __ movq(Address(end_to, qword_count, Address::times_8, -24), to);\n-    __ movq(to, Address(end_from, qword_count, Address::times_8, -16));\n-    __ movq(Address(end_to, qword_count, Address::times_8, -16), to);\n-    __ movq(to, Address(end_from, qword_count, Address::times_8, - 8));\n-    __ movq(Address(end_to, qword_count, Address::times_8, - 8), to);\n-    __ movq(to, Address(end_from, qword_count, Address::times_8, - 0));\n-    __ movq(Address(end_to, qword_count, Address::times_8, - 0), to);\n-\n-    __ BIND(L_copy_bytes);\n-    __ addptr(qword_count, 4);\n-    __ jcc(Assembler::lessEqual, L_loop);\n-  }\n-  __ subptr(qword_count, 4);\n-  __ jcc(Assembler::less, L_copy_8_bytes); \/\/ Copy trailing qwords\n-}\n-\n-\/\/ Copy big chunks backward\n-\/\/\n-\/\/ Inputs:\n-\/\/   from         - source arrays address\n-\/\/   dest         - destination array address\n-\/\/   qword_count  - 64-bits element count\n-\/\/   to           - scratch\n-\/\/   L_copy_bytes - entry label\n-\/\/   L_copy_8_bytes  - exit  label\n-\/\/\n-void StubGenerator::copy_bytes_backward(Register from, Register dest,\n-                                        Register qword_count, Register to,\n-                                        Label& L_copy_bytes, Label& L_copy_8_bytes) {\n-  DEBUG_ONLY(__ stop(\"enter at entry label, not here\"));\n-  Label L_loop;\n-  __ align(OptoLoopAlignment);\n-  if (UseUnalignedLoadStores) {\n-    Label L_end;\n-    __ BIND(L_loop);\n-    if (UseAVX >= 2) {\n-      __ vmovdqu(xmm0, Address(from, qword_count, Address::times_8, 32));\n-      __ vmovdqu(Address(dest, qword_count, Address::times_8, 32), xmm0);\n-      __ vmovdqu(xmm1, Address(from, qword_count, Address::times_8,  0));\n-      __ vmovdqu(Address(dest, qword_count, Address::times_8,  0), xmm1);\n-    } else {\n-      __ movdqu(xmm0, Address(from, qword_count, Address::times_8, 48));\n-      __ movdqu(Address(dest, qword_count, Address::times_8, 48), xmm0);\n-      __ movdqu(xmm1, Address(from, qword_count, Address::times_8, 32));\n-      __ movdqu(Address(dest, qword_count, Address::times_8, 32), xmm1);\n-      __ movdqu(xmm2, Address(from, qword_count, Address::times_8, 16));\n-      __ movdqu(Address(dest, qword_count, Address::times_8, 16), xmm2);\n-      __ movdqu(xmm3, Address(from, qword_count, Address::times_8,  0));\n-      __ movdqu(Address(dest, qword_count, Address::times_8,  0), xmm3);\n-    }\n-\n-    __ BIND(L_copy_bytes);\n-    __ subptr(qword_count, 8);\n-    __ jcc(Assembler::greaterEqual, L_loop);\n-\n-    __ addptr(qword_count, 4);  \/\/ add(8) and sub(4)\n-    __ jccb(Assembler::less, L_end);\n-    \/\/ Copy trailing 32 bytes\n-    if (UseAVX >= 2) {\n-      __ vmovdqu(xmm0, Address(from, qword_count, Address::times_8, 0));\n-      __ vmovdqu(Address(dest, qword_count, Address::times_8, 0), xmm0);\n-    } else {\n-      __ movdqu(xmm0, Address(from, qword_count, Address::times_8, 16));\n-      __ movdqu(Address(dest, qword_count, Address::times_8, 16), xmm0);\n-      __ movdqu(xmm1, Address(from, qword_count, Address::times_8,  0));\n-      __ movdqu(Address(dest, qword_count, Address::times_8,  0), xmm1);\n-    }\n-    __ subptr(qword_count, 4);\n-    __ BIND(L_end);\n-  } else {\n-    \/\/ Copy 32-bytes per iteration\n-    __ BIND(L_loop);\n-    __ movq(to, Address(from, qword_count, Address::times_8, 24));\n-    __ movq(Address(dest, qword_count, Address::times_8, 24), to);\n-    __ movq(to, Address(from, qword_count, Address::times_8, 16));\n-    __ movq(Address(dest, qword_count, Address::times_8, 16), to);\n-    __ movq(to, Address(from, qword_count, Address::times_8,  8));\n-    __ movq(Address(dest, qword_count, Address::times_8,  8), to);\n-    __ movq(to, Address(from, qword_count, Address::times_8,  0));\n-    __ movq(Address(dest, qword_count, Address::times_8,  0), to);\n-\n-    __ BIND(L_copy_bytes);\n-    __ subptr(qword_count, 4);\n-    __ jcc(Assembler::greaterEqual, L_loop);\n-  }\n-  __ addptr(qword_count, 4);\n-  __ jcc(Assembler::greater, L_copy_8_bytes); \/\/ Copy trailing qwords\n-}\n-\n-void StubGenerator::setup_argument_regs(BasicType type) {\n-  if (type == T_BYTE || type == T_SHORT) {\n-    setup_arg_regs(); \/\/ from => rdi, to => rsi, count => rdx\n-                      \/\/ r9 and r10 may be used to save non-volatile registers\n-  } else {\n-    setup_arg_regs_using_thread(); \/\/ from => rdi, to => rsi, count => rdx\n-                                   \/\/ r9 is used to save r15_thread\n-  }\n-}\n-\n-void StubGenerator::restore_argument_regs(BasicType type) {\n-  if (type == T_BYTE || type == T_SHORT) {\n-    restore_arg_regs();\n-  } else {\n-    restore_arg_regs_using_thread();\n-  }\n-}\n-\n-#if COMPILER2_OR_JVMCI\n-\/\/ Note: Following rules apply to AVX3 optimized arraycopy stubs:-\n-\/\/ - If target supports AVX3 features (BW+VL+F) then implementation uses 32 byte vectors (YMMs)\n-\/\/   for both special cases (various small block sizes) and aligned copy loop. This is the\n-\/\/   default configuration.\n-\/\/ - If copy length is above AVX3Threshold, then implementation use 64 byte vectors (ZMMs)\n-\/\/   for main copy loop (and subsequent tail) since bulk of the cycles will be consumed in it.\n-\/\/ - If user forces MaxVectorSize=32 then above 4096 bytes its seen that REP MOVs shows a\n-\/\/   better performance for disjoint copies. For conjoint\/backward copy vector based\n-\/\/   copy performs better.\n-\/\/ - If user sets AVX3Threshold=0, then special cases for small blocks sizes operate over\n-\/\/   64 byte vector registers (ZMMs).\n-\n-\/\/ Inputs:\n-\/\/   c_rarg0   - source array address\n-\/\/   c_rarg1   - destination array address\n-\/\/   c_rarg2   - element count, treated as ssize_t, can be zero\n-\/\/\n-\/\/\n-\/\/ Side Effects:\n-\/\/   disjoint_copy_avx3_masked is set to the no-overlap entry point\n-\/\/   used by generate_conjoint_[byte\/int\/short\/long]_copy().\n-\/\/\n-address StubGenerator::generate_disjoint_copy_avx3_masked(address* entry, const char *name,\n-                                                          int shift, bool aligned, bool is_oop,\n-                                                          bool dest_uninitialized) {\n-  __ align(CodeEntryAlignment);\n-  StubCodeMark mark(this, \"StubRoutines\", name);\n-  address start = __ pc();\n-\n-  int avx3threshold = VM_Version::avx3_threshold();\n-  bool use64byteVector = (MaxVectorSize > 32) && (avx3threshold == 0);\n-  Label L_main_loop, L_main_loop_64bytes, L_tail, L_tail64, L_exit, L_entry;\n-  Label L_repmovs, L_main_pre_loop, L_main_pre_loop_64bytes, L_pre_main_post_64;\n-  const Register from        = rdi;  \/\/ source array address\n-  const Register to          = rsi;  \/\/ destination array address\n-  const Register count       = rdx;  \/\/ elements count\n-  const Register temp1       = r8;\n-  const Register temp2       = r11;\n-  const Register temp3       = rax;\n-  const Register temp4       = rcx;\n-  \/\/ End pointers are inclusive, and if count is not zero they point\n-  \/\/ to the last unit copied:  end_to[0] := end_from[0]\n-\n-  __ enter(); \/\/ required for proper stackwalking of RuntimeStub frame\n-  assert_clean_int(c_rarg2, rax);    \/\/ Make sure 'count' is clean int.\n-\n-  if (entry != NULL) {\n-    *entry = __ pc();\n-     \/\/ caller can pass a 64-bit byte count here (from Unsafe.copyMemory)\n-    BLOCK_COMMENT(\"Entry:\");\n-  }\n-\n-  BasicType type_vec[] = { T_BYTE,  T_SHORT,  T_INT,   T_LONG};\n-  BasicType type = is_oop ? T_OBJECT : type_vec[shift];\n-\n-  setup_argument_regs(type);\n-\n-  DecoratorSet decorators = IN_HEAP | IS_ARRAY | ARRAYCOPY_DISJOINT;\n-  if (dest_uninitialized) {\n-    decorators |= IS_DEST_UNINITIALIZED;\n-  }\n-  if (aligned) {\n-    decorators |= ARRAYCOPY_ALIGNED;\n-  }\n-  BarrierSetAssembler *bs = BarrierSet::barrier_set()->barrier_set_assembler();\n-  bs->arraycopy_prologue(_masm, decorators, type, from, to, count);\n-\n-  {\n-    \/\/ Type(shift)           byte(0), short(1), int(2),   long(3)\n-    int loop_size[]        = { 192,     96,       48,      24};\n-    int threshold[]        = { 4096,    2048,     1024,    512};\n-\n-    \/\/ UnsafeCopyMemory page error: continue after ucm\n-    UnsafeCopyMemoryMark ucmm(this, !is_oop && !aligned, true);\n-    \/\/ 'from', 'to' and 'count' are now valid\n-\n-    \/\/ temp1 holds remaining count and temp4 holds running count used to compute\n-    \/\/ next address offset for start of to\/from addresses (temp4 * scale).\n-    __ mov64(temp4, 0);\n-    __ movq(temp1, count);\n-\n-    \/\/ Zero length check.\n-    __ BIND(L_tail);\n-    __ cmpq(temp1, 0);\n-    __ jcc(Assembler::lessEqual, L_exit);\n-\n-    \/\/ Special cases using 32 byte [masked] vector copy operations.\n-    __ arraycopy_avx3_special_cases(xmm1, k2, from, to, temp1, shift,\n-                                    temp4, temp3, use64byteVector, L_entry, L_exit);\n-\n-    \/\/ PRE-MAIN-POST loop for aligned copy.\n-    __ BIND(L_entry);\n-\n-    if (avx3threshold != 0) {\n-      __ cmpq(count, threshold[shift]);\n-      if (MaxVectorSize == 64) {\n-        \/\/ Copy using 64 byte vectors.\n-        __ jcc(Assembler::greaterEqual, L_pre_main_post_64);\n-      } else {\n-        assert(MaxVectorSize < 64, \"vector size should be < 64 bytes\");\n-        \/\/ REP MOVS offer a faster copy path.\n-        __ jcc(Assembler::greaterEqual, L_repmovs);\n-      }\n-    }\n-\n-    if ((MaxVectorSize < 64)  || (avx3threshold != 0)) {\n-      \/\/ Partial copy to make dst address 32 byte aligned.\n-      __ movq(temp2, to);\n-      __ andq(temp2, 31);\n-      __ jcc(Assembler::equal, L_main_pre_loop);\n-\n-      __ negptr(temp2);\n-      __ addq(temp2, 32);\n-      if (shift) {\n-        __ shrq(temp2, shift);\n-      }\n-      __ movq(temp3, temp2);\n-      __ copy32_masked_avx(to, from, xmm1, k2, temp3, temp4, temp1, shift);\n-      __ movq(temp4, temp2);\n-      __ movq(temp1, count);\n-      __ subq(temp1, temp2);\n-\n-      __ cmpq(temp1, loop_size[shift]);\n-      __ jcc(Assembler::less, L_tail);\n-\n-      __ BIND(L_main_pre_loop);\n-      __ subq(temp1, loop_size[shift]);\n-\n-      \/\/ Main loop with aligned copy block size of 192 bytes at 32 byte granularity.\n-      __ align32();\n-      __ BIND(L_main_loop);\n-         __ copy64_avx(to, from, temp4, xmm1, false, shift, 0);\n-         __ copy64_avx(to, from, temp4, xmm1, false, shift, 64);\n-         __ copy64_avx(to, from, temp4, xmm1, false, shift, 128);\n-         __ addptr(temp4, loop_size[shift]);\n-         __ subq(temp1, loop_size[shift]);\n-         __ jcc(Assembler::greater, L_main_loop);\n-\n-      __ addq(temp1, loop_size[shift]);\n-\n-      \/\/ Tail loop.\n-      __ jmp(L_tail);\n-\n-      __ BIND(L_repmovs);\n-        __ movq(temp2, temp1);\n-        \/\/ Swap to(RSI) and from(RDI) addresses to comply with REP MOVs semantics.\n-        __ movq(temp3, to);\n-        __ movq(to,  from);\n-        __ movq(from, temp3);\n-        \/\/ Save to\/from for restoration post rep_mov.\n-        __ movq(temp1, to);\n-        __ movq(temp3, from);\n-        if(shift < 3) {\n-          __ shrq(temp2, 3-shift);     \/\/ quad word count\n-        }\n-        __ movq(temp4 , temp2);        \/\/ move quad ward count into temp4(RCX).\n-        __ rep_mov();\n-        __ shlq(temp2, 3);             \/\/ convert quad words into byte count.\n-        if(shift) {\n-          __ shrq(temp2, shift);       \/\/ type specific count.\n-        }\n-        \/\/ Restore original addresses in to\/from.\n-        __ movq(to, temp3);\n-        __ movq(from, temp1);\n-        __ movq(temp4, temp2);\n-        __ movq(temp1, count);\n-        __ subq(temp1, temp2);         \/\/ tailing part (less than a quad ward size).\n-        __ jmp(L_tail);\n-    }\n-\n-    if (MaxVectorSize > 32) {\n-      __ BIND(L_pre_main_post_64);\n-      \/\/ Partial copy to make dst address 64 byte aligned.\n-      __ movq(temp2, to);\n-      __ andq(temp2, 63);\n-      __ jcc(Assembler::equal, L_main_pre_loop_64bytes);\n-\n-      __ negptr(temp2);\n-      __ addq(temp2, 64);\n-      if (shift) {\n-        __ shrq(temp2, shift);\n-      }\n-      __ movq(temp3, temp2);\n-      __ copy64_masked_avx(to, from, xmm1, k2, temp3, temp4, temp1, shift, 0 , true);\n-      __ movq(temp4, temp2);\n-      __ movq(temp1, count);\n-      __ subq(temp1, temp2);\n-\n-      __ cmpq(temp1, loop_size[shift]);\n-      __ jcc(Assembler::less, L_tail64);\n-\n-      __ BIND(L_main_pre_loop_64bytes);\n-      __ subq(temp1, loop_size[shift]);\n-\n-      \/\/ Main loop with aligned copy block size of 192 bytes at\n-      \/\/ 64 byte copy granularity.\n-      __ align32();\n-      __ BIND(L_main_loop_64bytes);\n-         __ copy64_avx(to, from, temp4, xmm1, false, shift, 0 , true);\n-         __ copy64_avx(to, from, temp4, xmm1, false, shift, 64, true);\n-         __ copy64_avx(to, from, temp4, xmm1, false, shift, 128, true);\n-         __ addptr(temp4, loop_size[shift]);\n-         __ subq(temp1, loop_size[shift]);\n-         __ jcc(Assembler::greater, L_main_loop_64bytes);\n-\n-      __ addq(temp1, loop_size[shift]);\n-      \/\/ Zero length check.\n-      __ jcc(Assembler::lessEqual, L_exit);\n-\n-      __ BIND(L_tail64);\n-\n-      \/\/ Tail handling using 64 byte [masked] vector copy operations.\n-      use64byteVector = true;\n-      __ arraycopy_avx3_special_cases(xmm1, k2, from, to, temp1, shift,\n-                                      temp4, temp3, use64byteVector, L_entry, L_exit);\n-    }\n-    __ BIND(L_exit);\n-  }\n-\n-  address ucme_exit_pc = __ pc();\n-  \/\/ When called from generic_arraycopy r11 contains specific values\n-  \/\/ used during arraycopy epilogue, re-initializing r11.\n-  if (is_oop) {\n-    __ movq(r11, shift == 3 ? count : to);\n-  }\n-  bs->arraycopy_epilogue(_masm, decorators, type, from, to, count);\n-  restore_argument_regs(type);\n-  INC_COUNTER_NP(get_profile_ctr(shift), rscratch1); \/\/ Update counter after rscratch1 is free\n-  __ xorptr(rax, rax); \/\/ return 0\n-  __ vzeroupper();\n-  __ leave(); \/\/ required for proper stackwalking of RuntimeStub frame\n-  __ ret(0);\n-\n-  return start;\n-}\n-\n-\/\/ Inputs:\n-\/\/   c_rarg0   - source array address\n-\/\/   c_rarg1   - destination array address\n-\/\/   c_rarg2   - element count, treated as ssize_t, can be zero\n-\/\/\n-address StubGenerator::generate_conjoint_copy_avx3_masked(address* entry, const char *name, int shift,\n-                                                          address nooverlap_target, bool aligned,\n-                                                          bool is_oop, bool dest_uninitialized) {\n-  __ align(CodeEntryAlignment);\n-  StubCodeMark mark(this, \"StubRoutines\", name);\n-  address start = __ pc();\n-\n-  int avx3threshold = VM_Version::avx3_threshold();\n-  bool use64byteVector = (MaxVectorSize > 32) && (avx3threshold == 0);\n-\n-  Label L_main_pre_loop, L_main_pre_loop_64bytes, L_pre_main_post_64;\n-  Label L_main_loop, L_main_loop_64bytes, L_tail, L_tail64, L_exit, L_entry;\n-  const Register from        = rdi;  \/\/ source array address\n-  const Register to          = rsi;  \/\/ destination array address\n-  const Register count       = rdx;  \/\/ elements count\n-  const Register temp1       = r8;\n-  const Register temp2       = rcx;\n-  const Register temp3       = r11;\n-  const Register temp4       = rax;\n-  \/\/ End pointers are inclusive, and if count is not zero they point\n-  \/\/ to the last unit copied:  end_to[0] := end_from[0]\n-\n-  __ enter(); \/\/ required for proper stackwalking of RuntimeStub frame\n-  assert_clean_int(c_rarg2, rax);    \/\/ Make sure 'count' is clean int.\n-\n-  if (entry != NULL) {\n-    *entry = __ pc();\n-     \/\/ caller can pass a 64-bit byte count here (from Unsafe.copyMemory)\n-    BLOCK_COMMENT(\"Entry:\");\n-  }\n-\n-  array_overlap_test(nooverlap_target, (Address::ScaleFactor)(shift));\n-\n-  BasicType type_vec[] = { T_BYTE,  T_SHORT,  T_INT,   T_LONG};\n-  BasicType type = is_oop ? T_OBJECT : type_vec[shift];\n-\n-  setup_argument_regs(type);\n-\n-  DecoratorSet decorators = IN_HEAP | IS_ARRAY;\n-  if (dest_uninitialized) {\n-    decorators |= IS_DEST_UNINITIALIZED;\n-  }\n-  if (aligned) {\n-    decorators |= ARRAYCOPY_ALIGNED;\n-  }\n-  BarrierSetAssembler *bs = BarrierSet::barrier_set()->barrier_set_assembler();\n-  bs->arraycopy_prologue(_masm, decorators, type, from, to, count);\n-  {\n-    \/\/ Type(shift)       byte(0), short(1), int(2),   long(3)\n-    int loop_size[]   = { 192,     96,       48,      24};\n-    int threshold[]   = { 4096,    2048,     1024,    512};\n-\n-    \/\/ UnsafeCopyMemory page error: continue after ucm\n-    UnsafeCopyMemoryMark ucmm(this, !is_oop && !aligned, true);\n-    \/\/ 'from', 'to' and 'count' are now valid\n-\n-    \/\/ temp1 holds remaining count.\n-    __ movq(temp1, count);\n-\n-    \/\/ Zero length check.\n-    __ BIND(L_tail);\n-    __ cmpq(temp1, 0);\n-    __ jcc(Assembler::lessEqual, L_exit);\n-\n-    __ mov64(temp2, 0);\n-    __ movq(temp3, temp1);\n-    \/\/ Special cases using 32 byte [masked] vector copy operations.\n-    __ arraycopy_avx3_special_cases_conjoint(xmm1, k2, from, to, temp2, temp3, temp1, shift,\n-                                             temp4, use64byteVector, L_entry, L_exit);\n-\n-    \/\/ PRE-MAIN-POST loop for aligned copy.\n-    __ BIND(L_entry);\n-\n-    if ((MaxVectorSize > 32) && (avx3threshold != 0)) {\n-      __ cmpq(temp1, threshold[shift]);\n-      __ jcc(Assembler::greaterEqual, L_pre_main_post_64);\n-    }\n-\n-    if ((MaxVectorSize < 64)  || (avx3threshold != 0)) {\n-      \/\/ Partial copy to make dst address 32 byte aligned.\n-      __ leaq(temp2, Address(to, temp1, (Address::ScaleFactor)(shift), 0));\n-      __ andq(temp2, 31);\n-      __ jcc(Assembler::equal, L_main_pre_loop);\n-\n-      if (shift) {\n-        __ shrq(temp2, shift);\n-      }\n-      __ subq(temp1, temp2);\n-      __ copy32_masked_avx(to, from, xmm1, k2, temp2, temp1, temp3, shift);\n-\n-      __ cmpq(temp1, loop_size[shift]);\n-      __ jcc(Assembler::less, L_tail);\n-\n-      __ BIND(L_main_pre_loop);\n-\n-      \/\/ Main loop with aligned copy block size of 192 bytes at 32 byte granularity.\n-      __ align32();\n-      __ BIND(L_main_loop);\n-         __ copy64_avx(to, from, temp1, xmm1, true, shift, -64);\n-         __ copy64_avx(to, from, temp1, xmm1, true, shift, -128);\n-         __ copy64_avx(to, from, temp1, xmm1, true, shift, -192);\n-         __ subptr(temp1, loop_size[shift]);\n-         __ cmpq(temp1, loop_size[shift]);\n-         __ jcc(Assembler::greater, L_main_loop);\n-\n-      \/\/ Tail loop.\n-      __ jmp(L_tail);\n-    }\n-\n-    if (MaxVectorSize > 32) {\n-      __ BIND(L_pre_main_post_64);\n-      \/\/ Partial copy to make dst address 64 byte aligned.\n-      __ leaq(temp2, Address(to, temp1, (Address::ScaleFactor)(shift), 0));\n-      __ andq(temp2, 63);\n-      __ jcc(Assembler::equal, L_main_pre_loop_64bytes);\n-\n-      if (shift) {\n-        __ shrq(temp2, shift);\n-      }\n-      __ subq(temp1, temp2);\n-      __ copy64_masked_avx(to, from, xmm1, k2, temp2, temp1, temp3, shift, 0 , true);\n-\n-      __ cmpq(temp1, loop_size[shift]);\n-      __ jcc(Assembler::less, L_tail64);\n-\n-      __ BIND(L_main_pre_loop_64bytes);\n-\n-      \/\/ Main loop with aligned copy block size of 192 bytes at\n-      \/\/ 64 byte copy granularity.\n-      __ align32();\n-      __ BIND(L_main_loop_64bytes);\n-         __ copy64_avx(to, from, temp1, xmm1, true, shift, -64 , true);\n-         __ copy64_avx(to, from, temp1, xmm1, true, shift, -128, true);\n-         __ copy64_avx(to, from, temp1, xmm1, true, shift, -192, true);\n-         __ subq(temp1, loop_size[shift]);\n-         __ cmpq(temp1, loop_size[shift]);\n-         __ jcc(Assembler::greater, L_main_loop_64bytes);\n-\n-      \/\/ Zero length check.\n-      __ cmpq(temp1, 0);\n-      __ jcc(Assembler::lessEqual, L_exit);\n-\n-      __ BIND(L_tail64);\n-\n-      \/\/ Tail handling using 64 byte [masked] vector copy operations.\n-      use64byteVector = true;\n-      __ mov64(temp2, 0);\n-      __ movq(temp3, temp1);\n-      __ arraycopy_avx3_special_cases_conjoint(xmm1, k2, from, to, temp2, temp3, temp1, shift,\n-                                               temp4, use64byteVector, L_entry, L_exit);\n-    }\n-    __ BIND(L_exit);\n-  }\n-  address ucme_exit_pc = __ pc();\n-  \/\/ When called from generic_arraycopy r11 contains specific values\n-  \/\/ used during arraycopy epilogue, re-initializing r11.\n-  if(is_oop) {\n-    __ movq(r11, count);\n-  }\n-  bs->arraycopy_epilogue(_masm, decorators, type, from, to, count);\n-  restore_argument_regs(type);\n-  INC_COUNTER_NP(get_profile_ctr(shift), rscratch1); \/\/ Update counter after rscratch1 is free\n-  __ xorptr(rax, rax); \/\/ return 0\n-  __ vzeroupper();\n-  __ leave(); \/\/ required for proper stackwalking of RuntimeStub frame\n-  __ ret(0);\n-\n-  return start;\n-}\n-#endif \/\/ COMPILER2_OR_JVMCI\n-\n-\n-\/\/ Arguments:\n-\/\/   aligned - true => Input and output aligned on a HeapWord == 8-byte boundary\n-\/\/             ignored\n-\/\/   name    - stub name string\n-\/\/\n-\/\/ Inputs:\n-\/\/   c_rarg0   - source array address\n-\/\/   c_rarg1   - destination array address\n-\/\/   c_rarg2   - element count, treated as ssize_t, can be zero\n-\/\/\n-\/\/ If 'from' and\/or 'to' are aligned on 4-, 2-, or 1-byte boundaries,\n-\/\/ we let the hardware handle it.  The one to eight bytes within words,\n-\/\/ dwords or qwords that span cache line boundaries will still be loaded\n-\/\/ and stored atomically.\n-\/\/\n-\/\/ Side Effects:\n-\/\/   disjoint_byte_copy_entry is set to the no-overlap entry point\n-\/\/   used by generate_conjoint_byte_copy().\n-\/\/\n-address StubGenerator::generate_disjoint_byte_copy(bool aligned, address* entry, const char *name) {\n-#if COMPILER2_OR_JVMCI\n-  if (VM_Version::supports_avx512vlbw() && VM_Version::supports_bmi2() && MaxVectorSize  >= 32) {\n-     return generate_disjoint_copy_avx3_masked(entry, \"jbyte_disjoint_arraycopy_avx3\", 0,\n-                                               aligned, false, false);\n-  }\n-#endif\n-  __ align(CodeEntryAlignment);\n-  StubCodeMark mark(this, \"StubRoutines\", name);\n-  address start = __ pc();\n-\n-  Label L_copy_bytes, L_copy_8_bytes, L_copy_4_bytes, L_copy_2_bytes;\n-  Label L_copy_byte, L_exit;\n-  const Register from        = rdi;  \/\/ source array address\n-  const Register to          = rsi;  \/\/ destination array address\n-  const Register count       = rdx;  \/\/ elements count\n-  const Register byte_count  = rcx;\n-  const Register qword_count = count;\n-  const Register end_from    = from; \/\/ source array end address\n-  const Register end_to      = to;   \/\/ destination array end address\n-  \/\/ End pointers are inclusive, and if count is not zero they point\n-  \/\/ to the last unit copied:  end_to[0] := end_from[0]\n-\n-  __ enter(); \/\/ required for proper stackwalking of RuntimeStub frame\n-  assert_clean_int(c_rarg2, rax);    \/\/ Make sure 'count' is clean int.\n-\n-  if (entry != NULL) {\n-    *entry = __ pc();\n-     \/\/ caller can pass a 64-bit byte count here (from Unsafe.copyMemory)\n-    BLOCK_COMMENT(\"Entry:\");\n-  }\n-\n-  setup_arg_regs(); \/\/ from => rdi, to => rsi, count => rdx\n-                    \/\/ r9 and r10 may be used to save non-volatile registers\n-\n-  {\n-    \/\/ UnsafeCopyMemory page error: continue after ucm\n-    UnsafeCopyMemoryMark ucmm(this, !aligned, true);\n-    \/\/ 'from', 'to' and 'count' are now valid\n-    __ movptr(byte_count, count);\n-    __ shrptr(count, 3); \/\/ count => qword_count\n-\n-    \/\/ Copy from low to high addresses.  Use 'to' as scratch.\n-    __ lea(end_from, Address(from, qword_count, Address::times_8, -8));\n-    __ lea(end_to,   Address(to,   qword_count, Address::times_8, -8));\n-    __ negptr(qword_count); \/\/ make the count negative\n-    __ jmp(L_copy_bytes);\n-\n-    \/\/ Copy trailing qwords\n-    __ BIND(L_copy_8_bytes);\n-    __ movq(rax, Address(end_from, qword_count, Address::times_8, 8));\n-    __ movq(Address(end_to, qword_count, Address::times_8, 8), rax);\n-    __ increment(qword_count);\n-    __ jcc(Assembler::notZero, L_copy_8_bytes);\n-\n-    \/\/ Check for and copy trailing dword\n-    __ BIND(L_copy_4_bytes);\n-    __ testl(byte_count, 4);\n-    __ jccb(Assembler::zero, L_copy_2_bytes);\n-    __ movl(rax, Address(end_from, 8));\n-    __ movl(Address(end_to, 8), rax);\n-\n-    __ addptr(end_from, 4);\n-    __ addptr(end_to, 4);\n-\n-    \/\/ Check for and copy trailing word\n-    __ BIND(L_copy_2_bytes);\n-    __ testl(byte_count, 2);\n-    __ jccb(Assembler::zero, L_copy_byte);\n-    __ movw(rax, Address(end_from, 8));\n-    __ movw(Address(end_to, 8), rax);\n-\n-    __ addptr(end_from, 2);\n-    __ addptr(end_to, 2);\n-\n-    \/\/ Check for and copy trailing byte\n-    __ BIND(L_copy_byte);\n-    __ testl(byte_count, 1);\n-    __ jccb(Assembler::zero, L_exit);\n-    __ movb(rax, Address(end_from, 8));\n-    __ movb(Address(end_to, 8), rax);\n-  }\n-  __ BIND(L_exit);\n-  address ucme_exit_pc = __ pc();\n-  restore_arg_regs();\n-  INC_COUNTER_NP(SharedRuntime::_jbyte_array_copy_ctr, rscratch1); \/\/ Update counter after rscratch1 is free\n-  __ xorptr(rax, rax); \/\/ return 0\n-  __ vzeroupper();\n-  __ leave(); \/\/ required for proper stackwalking of RuntimeStub frame\n-  __ ret(0);\n-\n-  {\n-    UnsafeCopyMemoryMark ucmm(this, !aligned, false, ucme_exit_pc);\n-    \/\/ Copy in multi-bytes chunks\n-    copy_bytes_forward(end_from, end_to, qword_count, rax, L_copy_bytes, L_copy_8_bytes);\n-    __ jmp(L_copy_4_bytes);\n-  }\n-  return start;\n-}\n-\n-\/\/ Arguments:\n-\/\/   aligned - true => Input and output aligned on a HeapWord == 8-byte boundary\n-\/\/             ignored\n-\/\/   name    - stub name string\n-\/\/\n-\/\/ Inputs:\n-\/\/   c_rarg0   - source array address\n-\/\/   c_rarg1   - destination array address\n-\/\/   c_rarg2   - element count, treated as ssize_t, can be zero\n-\/\/\n-\/\/ If 'from' and\/or 'to' are aligned on 4-, 2-, or 1-byte boundaries,\n-\/\/ we let the hardware handle it.  The one to eight bytes within words,\n-\/\/ dwords or qwords that span cache line boundaries will still be loaded\n-\/\/ and stored atomically.\n-\/\/\n-address StubGenerator::generate_conjoint_byte_copy(bool aligned, address nooverlap_target,\n-                                                   address* entry, const char *name) {\n-#if COMPILER2_OR_JVMCI\n-  if (VM_Version::supports_avx512vlbw() && VM_Version::supports_bmi2() && MaxVectorSize  >= 32) {\n-     return generate_conjoint_copy_avx3_masked(entry, \"jbyte_conjoint_arraycopy_avx3\", 0,\n-                                               nooverlap_target, aligned, false, false);\n-  }\n-#endif\n-  __ align(CodeEntryAlignment);\n-  StubCodeMark mark(this, \"StubRoutines\", name);\n-  address start = __ pc();\n-\n-  Label L_copy_bytes, L_copy_8_bytes, L_copy_4_bytes, L_copy_2_bytes;\n-  const Register from        = rdi;  \/\/ source array address\n-  const Register to          = rsi;  \/\/ destination array address\n-  const Register count       = rdx;  \/\/ elements count\n-  const Register byte_count  = rcx;\n-  const Register qword_count = count;\n-\n-  __ enter(); \/\/ required for proper stackwalking of RuntimeStub frame\n-  assert_clean_int(c_rarg2, rax);    \/\/ Make sure 'count' is clean int.\n-\n-  if (entry != NULL) {\n-    *entry = __ pc();\n-    \/\/ caller can pass a 64-bit byte count here (from Unsafe.copyMemory)\n-    BLOCK_COMMENT(\"Entry:\");\n-  }\n-\n-  array_overlap_test(nooverlap_target, Address::times_1);\n-  setup_arg_regs(); \/\/ from => rdi, to => rsi, count => rdx\n-                    \/\/ r9 and r10 may be used to save non-volatile registers\n-\n-  {\n-    \/\/ UnsafeCopyMemory page error: continue after ucm\n-    UnsafeCopyMemoryMark ucmm(this, !aligned, true);\n-    \/\/ 'from', 'to' and 'count' are now valid\n-    __ movptr(byte_count, count);\n-    __ shrptr(count, 3);   \/\/ count => qword_count\n-\n-    \/\/ Copy from high to low addresses.\n-\n-    \/\/ Check for and copy trailing byte\n-    __ testl(byte_count, 1);\n-    __ jcc(Assembler::zero, L_copy_2_bytes);\n-    __ movb(rax, Address(from, byte_count, Address::times_1, -1));\n-    __ movb(Address(to, byte_count, Address::times_1, -1), rax);\n-    __ decrement(byte_count); \/\/ Adjust for possible trailing word\n-\n-    \/\/ Check for and copy trailing word\n-    __ BIND(L_copy_2_bytes);\n-    __ testl(byte_count, 2);\n-    __ jcc(Assembler::zero, L_copy_4_bytes);\n-    __ movw(rax, Address(from, byte_count, Address::times_1, -2));\n-    __ movw(Address(to, byte_count, Address::times_1, -2), rax);\n-\n-    \/\/ Check for and copy trailing dword\n-    __ BIND(L_copy_4_bytes);\n-    __ testl(byte_count, 4);\n-    __ jcc(Assembler::zero, L_copy_bytes);\n-    __ movl(rax, Address(from, qword_count, Address::times_8));\n-    __ movl(Address(to, qword_count, Address::times_8), rax);\n-    __ jmp(L_copy_bytes);\n-\n-    \/\/ Copy trailing qwords\n-    __ BIND(L_copy_8_bytes);\n-    __ movq(rax, Address(from, qword_count, Address::times_8, -8));\n-    __ movq(Address(to, qword_count, Address::times_8, -8), rax);\n-    __ decrement(qword_count);\n-    __ jcc(Assembler::notZero, L_copy_8_bytes);\n-  }\n-  restore_arg_regs();\n-  INC_COUNTER_NP(SharedRuntime::_jbyte_array_copy_ctr, rscratch1); \/\/ Update counter after rscratch1 is free\n-  __ xorptr(rax, rax); \/\/ return 0\n-  __ vzeroupper();\n-  __ leave(); \/\/ required for proper stackwalking of RuntimeStub frame\n-  __ ret(0);\n-\n-  {\n-    \/\/ UnsafeCopyMemory page error: continue after ucm\n-    UnsafeCopyMemoryMark ucmm(this, !aligned, true);\n-    \/\/ Copy in multi-bytes chunks\n-    copy_bytes_backward(from, to, qword_count, rax, L_copy_bytes, L_copy_8_bytes);\n-  }\n-  restore_arg_regs();\n-  INC_COUNTER_NP(SharedRuntime::_jbyte_array_copy_ctr, rscratch1); \/\/ Update counter after rscratch1 is free\n-  __ xorptr(rax, rax); \/\/ return 0\n-  __ vzeroupper();\n-  __ leave(); \/\/ required for proper stackwalking of RuntimeStub frame\n-  __ ret(0);\n-\n-  return start;\n-}\n-\n-\/\/ Arguments:\n-\/\/   aligned - true => Input and output aligned on a HeapWord == 8-byte boundary\n-\/\/             ignored\n-\/\/   name    - stub name string\n-\/\/\n-\/\/ Inputs:\n-\/\/   c_rarg0   - source array address\n-\/\/   c_rarg1   - destination array address\n-\/\/   c_rarg2   - element count, treated as ssize_t, can be zero\n-\/\/\n-\/\/ If 'from' and\/or 'to' are aligned on 4- or 2-byte boundaries, we\n-\/\/ let the hardware handle it.  The two or four words within dwords\n-\/\/ or qwords that span cache line boundaries will still be loaded\n-\/\/ and stored atomically.\n-\/\/\n-\/\/ Side Effects:\n-\/\/   disjoint_short_copy_entry is set to the no-overlap entry point\n-\/\/   used by generate_conjoint_short_copy().\n-\/\/\n-address StubGenerator::generate_disjoint_short_copy(bool aligned, address *entry, const char *name) {\n-#if COMPILER2_OR_JVMCI\n-  if (VM_Version::supports_avx512vlbw() && VM_Version::supports_bmi2() && MaxVectorSize  >= 32) {\n-     return generate_disjoint_copy_avx3_masked(entry, \"jshort_disjoint_arraycopy_avx3\", 1,\n-                                               aligned, false, false);\n-  }\n-#endif\n-\n-  __ align(CodeEntryAlignment);\n-  StubCodeMark mark(this, \"StubRoutines\", name);\n-  address start = __ pc();\n-\n-  Label L_copy_bytes, L_copy_8_bytes, L_copy_4_bytes,L_copy_2_bytes,L_exit;\n-  const Register from        = rdi;  \/\/ source array address\n-  const Register to          = rsi;  \/\/ destination array address\n-  const Register count       = rdx;  \/\/ elements count\n-  const Register word_count  = rcx;\n-  const Register qword_count = count;\n-  const Register end_from    = from; \/\/ source array end address\n-  const Register end_to      = to;   \/\/ destination array end address\n-  \/\/ End pointers are inclusive, and if count is not zero they point\n-  \/\/ to the last unit copied:  end_to[0] := end_from[0]\n-\n-  __ enter(); \/\/ required for proper stackwalking of RuntimeStub frame\n-  assert_clean_int(c_rarg2, rax);    \/\/ Make sure 'count' is clean int.\n-\n-  if (entry != NULL) {\n-    *entry = __ pc();\n-    \/\/ caller can pass a 64-bit byte count here (from Unsafe.copyMemory)\n-    BLOCK_COMMENT(\"Entry:\");\n-  }\n-\n-  setup_arg_regs(); \/\/ from => rdi, to => rsi, count => rdx\n-                    \/\/ r9 and r10 may be used to save non-volatile registers\n-\n-  {\n-    \/\/ UnsafeCopyMemory page error: continue after ucm\n-    UnsafeCopyMemoryMark ucmm(this, !aligned, true);\n-    \/\/ 'from', 'to' and 'count' are now valid\n-    __ movptr(word_count, count);\n-    __ shrptr(count, 2); \/\/ count => qword_count\n-\n-    \/\/ Copy from low to high addresses.  Use 'to' as scratch.\n-    __ lea(end_from, Address(from, qword_count, Address::times_8, -8));\n-    __ lea(end_to,   Address(to,   qword_count, Address::times_8, -8));\n-    __ negptr(qword_count);\n-    __ jmp(L_copy_bytes);\n-\n-    \/\/ Copy trailing qwords\n-    __ BIND(L_copy_8_bytes);\n-    __ movq(rax, Address(end_from, qword_count, Address::times_8, 8));\n-    __ movq(Address(end_to, qword_count, Address::times_8, 8), rax);\n-    __ increment(qword_count);\n-    __ jcc(Assembler::notZero, L_copy_8_bytes);\n-\n-    \/\/ Original 'dest' is trashed, so we can't use it as a\n-    \/\/ base register for a possible trailing word copy\n-\n-    \/\/ Check for and copy trailing dword\n-    __ BIND(L_copy_4_bytes);\n-    __ testl(word_count, 2);\n-    __ jccb(Assembler::zero, L_copy_2_bytes);\n-    __ movl(rax, Address(end_from, 8));\n-    __ movl(Address(end_to, 8), rax);\n-\n-    __ addptr(end_from, 4);\n-    __ addptr(end_to, 4);\n-\n-    \/\/ Check for and copy trailing word\n-    __ BIND(L_copy_2_bytes);\n-    __ testl(word_count, 1);\n-    __ jccb(Assembler::zero, L_exit);\n-    __ movw(rax, Address(end_from, 8));\n-    __ movw(Address(end_to, 8), rax);\n-  }\n-  __ BIND(L_exit);\n-  address ucme_exit_pc = __ pc();\n-  restore_arg_regs();\n-  INC_COUNTER_NP(SharedRuntime::_jshort_array_copy_ctr, rscratch1); \/\/ Update counter after rscratch1 is free\n-  __ xorptr(rax, rax); \/\/ return 0\n-  __ vzeroupper();\n-  __ leave(); \/\/ required for proper stackwalking of RuntimeStub frame\n-  __ ret(0);\n-\n-  {\n-    UnsafeCopyMemoryMark ucmm(this, !aligned, false, ucme_exit_pc);\n-    \/\/ Copy in multi-bytes chunks\n-    copy_bytes_forward(end_from, end_to, qword_count, rax, L_copy_bytes, L_copy_8_bytes);\n-    __ jmp(L_copy_4_bytes);\n-  }\n-\n-  return start;\n-}\n-\n-address StubGenerator::generate_fill(BasicType t, bool aligned, const char *name) {\n-  __ align(CodeEntryAlignment);\n-  StubCodeMark mark(this, \"StubRoutines\", name);\n-  address start = __ pc();\n-\n-  BLOCK_COMMENT(\"Entry:\");\n-\n-  const Register to       = c_rarg0;  \/\/ destination array address\n-  const Register value    = c_rarg1;  \/\/ value\n-  const Register count    = c_rarg2;  \/\/ elements count\n-  __ mov(r11, count);\n-\n-  __ enter(); \/\/ required for proper stackwalking of RuntimeStub frame\n-\n-  __ generate_fill(t, aligned, to, value, r11, rax, xmm0);\n-\n-  __ vzeroupper();\n-  __ leave(); \/\/ required for proper stackwalking of RuntimeStub frame\n-  __ ret(0);\n-\n-  return start;\n-}\n-\n-\/\/ Arguments:\n-\/\/   aligned - true => Input and output aligned on a HeapWord == 8-byte boundary\n-\/\/             ignored\n-\/\/   name    - stub name string\n-\/\/\n-\/\/ Inputs:\n-\/\/   c_rarg0   - source array address\n-\/\/   c_rarg1   - destination array address\n-\/\/   c_rarg2   - element count, treated as ssize_t, can be zero\n-\/\/\n-\/\/ If 'from' and\/or 'to' are aligned on 4- or 2-byte boundaries, we\n-\/\/ let the hardware handle it.  The two or four words within dwords\n-\/\/ or qwords that span cache line boundaries will still be loaded\n-\/\/ and stored atomically.\n-\/\/\n-address StubGenerator::generate_conjoint_short_copy(bool aligned, address nooverlap_target,\n-                                                    address *entry, const char *name) {\n-#if COMPILER2_OR_JVMCI\n-  if (VM_Version::supports_avx512vlbw() && VM_Version::supports_bmi2() && MaxVectorSize  >= 32) {\n-     return generate_conjoint_copy_avx3_masked(entry, \"jshort_conjoint_arraycopy_avx3\", 1,\n-                                               nooverlap_target, aligned, false, false);\n-  }\n-#endif\n-  __ align(CodeEntryAlignment);\n-  StubCodeMark mark(this, \"StubRoutines\", name);\n-  address start = __ pc();\n-\n-  Label L_copy_bytes, L_copy_8_bytes, L_copy_4_bytes;\n-  const Register from        = rdi;  \/\/ source array address\n-  const Register to          = rsi;  \/\/ destination array address\n-  const Register count       = rdx;  \/\/ elements count\n-  const Register word_count  = rcx;\n-  const Register qword_count = count;\n-\n-  __ enter(); \/\/ required for proper stackwalking of RuntimeStub frame\n-  assert_clean_int(c_rarg2, rax);    \/\/ Make sure 'count' is clean int.\n-\n-  if (entry != NULL) {\n-    *entry = __ pc();\n-    \/\/ caller can pass a 64-bit byte count here (from Unsafe.copyMemory)\n-    BLOCK_COMMENT(\"Entry:\");\n-  }\n-\n-  array_overlap_test(nooverlap_target, Address::times_2);\n-  setup_arg_regs(); \/\/ from => rdi, to => rsi, count => rdx\n-                    \/\/ r9 and r10 may be used to save non-volatile registers\n-\n-  {\n-    \/\/ UnsafeCopyMemory page error: continue after ucm\n-    UnsafeCopyMemoryMark ucmm(this, !aligned, true);\n-    \/\/ 'from', 'to' and 'count' are now valid\n-    __ movptr(word_count, count);\n-    __ shrptr(count, 2); \/\/ count => qword_count\n-\n-    \/\/ Copy from high to low addresses.  Use 'to' as scratch.\n-\n-    \/\/ Check for and copy trailing word\n-    __ testl(word_count, 1);\n-    __ jccb(Assembler::zero, L_copy_4_bytes);\n-    __ movw(rax, Address(from, word_count, Address::times_2, -2));\n-    __ movw(Address(to, word_count, Address::times_2, -2), rax);\n-\n-   \/\/ Check for and copy trailing dword\n-    __ BIND(L_copy_4_bytes);\n-    __ testl(word_count, 2);\n-    __ jcc(Assembler::zero, L_copy_bytes);\n-    __ movl(rax, Address(from, qword_count, Address::times_8));\n-    __ movl(Address(to, qword_count, Address::times_8), rax);\n-    __ jmp(L_copy_bytes);\n-\n-    \/\/ Copy trailing qwords\n-    __ BIND(L_copy_8_bytes);\n-    __ movq(rax, Address(from, qword_count, Address::times_8, -8));\n-    __ movq(Address(to, qword_count, Address::times_8, -8), rax);\n-    __ decrement(qword_count);\n-    __ jcc(Assembler::notZero, L_copy_8_bytes);\n-  }\n-  restore_arg_regs();\n-  INC_COUNTER_NP(SharedRuntime::_jshort_array_copy_ctr, rscratch1); \/\/ Update counter after rscratch1 is free\n-  __ xorptr(rax, rax); \/\/ return 0\n-  __ vzeroupper();\n-  __ leave(); \/\/ required for proper stackwalking of RuntimeStub frame\n-  __ ret(0);\n-\n-  {\n-    \/\/ UnsafeCopyMemory page error: continue after ucm\n-    UnsafeCopyMemoryMark ucmm(this, !aligned, true);\n-    \/\/ Copy in multi-bytes chunks\n-    copy_bytes_backward(from, to, qword_count, rax, L_copy_bytes, L_copy_8_bytes);\n-  }\n-  restore_arg_regs();\n-  INC_COUNTER_NP(SharedRuntime::_jshort_array_copy_ctr, rscratch1); \/\/ Update counter after rscratch1 is free\n-  __ xorptr(rax, rax); \/\/ return 0\n-  __ vzeroupper();\n-  __ leave(); \/\/ required for proper stackwalking of RuntimeStub frame\n-  __ ret(0);\n-\n-  return start;\n-}\n-\n-\/\/ Arguments:\n-\/\/   aligned - true => Input and output aligned on a HeapWord == 8-byte boundary\n-\/\/             ignored\n-\/\/   is_oop  - true => oop array, so generate store check code\n-\/\/   name    - stub name string\n-\/\/\n-\/\/ Inputs:\n-\/\/   c_rarg0   - source array address\n-\/\/   c_rarg1   - destination array address\n-\/\/   c_rarg2   - element count, treated as ssize_t, can be zero\n-\/\/\n-\/\/ If 'from' and\/or 'to' are aligned on 4-byte boundaries, we let\n-\/\/ the hardware handle it.  The two dwords within qwords that span\n-\/\/ cache line boundaries will still be loaded and stored atomically.\n-\/\/\n-\/\/ Side Effects:\n-\/\/   disjoint_int_copy_entry is set to the no-overlap entry point\n-\/\/   used by generate_conjoint_int_oop_copy().\n-\/\/\n-address StubGenerator::generate_disjoint_int_oop_copy(bool aligned, bool is_oop, address* entry,\n-                                                      const char *name, bool dest_uninitialized) {\n-#if COMPILER2_OR_JVMCI\n-  if (VM_Version::supports_avx512vlbw() && VM_Version::supports_bmi2() && MaxVectorSize  >= 32) {\n-     return generate_disjoint_copy_avx3_masked(entry, \"jint_disjoint_arraycopy_avx3\", 2,\n-                                               aligned, is_oop, dest_uninitialized);\n-  }\n-#endif\n-\n-  __ align(CodeEntryAlignment);\n-  StubCodeMark mark(this, \"StubRoutines\", name);\n-  address start = __ pc();\n-\n-  Label L_copy_bytes, L_copy_8_bytes, L_copy_4_bytes, L_exit;\n-  const Register from        = rdi;  \/\/ source array address\n-  const Register to          = rsi;  \/\/ destination array address\n-  const Register count       = rdx;  \/\/ elements count\n-  const Register dword_count = rcx;\n-  const Register qword_count = count;\n-  const Register end_from    = from; \/\/ source array end address\n-  const Register end_to      = to;   \/\/ destination array end address\n-  \/\/ End pointers are inclusive, and if count is not zero they point\n-  \/\/ to the last unit copied:  end_to[0] := end_from[0]\n-\n-  __ enter(); \/\/ required for proper stackwalking of RuntimeStub frame\n-  assert_clean_int(c_rarg2, rax);    \/\/ Make sure 'count' is clean int.\n-\n-  if (entry != NULL) {\n-    *entry = __ pc();\n-    \/\/ caller can pass a 64-bit byte count here (from Unsafe.copyMemory)\n-    BLOCK_COMMENT(\"Entry:\");\n-  }\n-\n-  setup_arg_regs_using_thread(); \/\/ from => rdi, to => rsi, count => rdx\n-                                 \/\/ r9 is used to save r15_thread\n-\n-  DecoratorSet decorators = IN_HEAP | IS_ARRAY | ARRAYCOPY_DISJOINT;\n-  if (dest_uninitialized) {\n-    decorators |= IS_DEST_UNINITIALIZED;\n-  }\n-  if (aligned) {\n-    decorators |= ARRAYCOPY_ALIGNED;\n-  }\n-\n-  BasicType type = is_oop ? T_OBJECT : T_INT;\n-  BarrierSetAssembler *bs = BarrierSet::barrier_set()->barrier_set_assembler();\n-  bs->arraycopy_prologue(_masm, decorators, type, from, to, count);\n-\n-  {\n-    \/\/ UnsafeCopyMemory page error: continue after ucm\n-    UnsafeCopyMemoryMark ucmm(this, !is_oop && !aligned, true);\n-    \/\/ 'from', 'to' and 'count' are now valid\n-    __ movptr(dword_count, count);\n-    __ shrptr(count, 1); \/\/ count => qword_count\n-\n-    \/\/ Copy from low to high addresses.  Use 'to' as scratch.\n-    __ lea(end_from, Address(from, qword_count, Address::times_8, -8));\n-    __ lea(end_to,   Address(to,   qword_count, Address::times_8, -8));\n-    __ negptr(qword_count);\n-    __ jmp(L_copy_bytes);\n-\n-    \/\/ Copy trailing qwords\n-    __ BIND(L_copy_8_bytes);\n-    __ movq(rax, Address(end_from, qword_count, Address::times_8, 8));\n-    __ movq(Address(end_to, qword_count, Address::times_8, 8), rax);\n-    __ increment(qword_count);\n-    __ jcc(Assembler::notZero, L_copy_8_bytes);\n-\n-    \/\/ Check for and copy trailing dword\n-    __ BIND(L_copy_4_bytes);\n-    __ testl(dword_count, 1); \/\/ Only byte test since the value is 0 or 1\n-    __ jccb(Assembler::zero, L_exit);\n-    __ movl(rax, Address(end_from, 8));\n-    __ movl(Address(end_to, 8), rax);\n-  }\n-  __ BIND(L_exit);\n-  address ucme_exit_pc = __ pc();\n-  bs->arraycopy_epilogue(_masm, decorators, type, from, to, dword_count);\n-  restore_arg_regs_using_thread();\n-  INC_COUNTER_NP(SharedRuntime::_jint_array_copy_ctr, rscratch1); \/\/ Update counter after rscratch1 is free\n-  __ vzeroupper();\n-  __ xorptr(rax, rax); \/\/ return 0\n-  __ leave(); \/\/ required for proper stackwalking of RuntimeStub frame\n-  __ ret(0);\n-\n-  {\n-    UnsafeCopyMemoryMark ucmm(this, !is_oop && !aligned, false, ucme_exit_pc);\n-    \/\/ Copy in multi-bytes chunks\n-    copy_bytes_forward(end_from, end_to, qword_count, rax, L_copy_bytes, L_copy_8_bytes);\n-    __ jmp(L_copy_4_bytes);\n-  }\n-\n-  return start;\n-}\n-\n-\/\/ Arguments:\n-\/\/   aligned - true => Input and output aligned on a HeapWord == 8-byte boundary\n-\/\/             ignored\n-\/\/   is_oop  - true => oop array, so generate store check code\n-\/\/   name    - stub name string\n-\/\/\n-\/\/ Inputs:\n-\/\/   c_rarg0   - source array address\n-\/\/   c_rarg1   - destination array address\n-\/\/   c_rarg2   - element count, treated as ssize_t, can be zero\n-\/\/\n-\/\/ If 'from' and\/or 'to' are aligned on 4-byte boundaries, we let\n-\/\/ the hardware handle it.  The two dwords within qwords that span\n-\/\/ cache line boundaries will still be loaded and stored atomically.\n-\/\/\n-address StubGenerator::generate_conjoint_int_oop_copy(bool aligned, bool is_oop, address nooverlap_target,\n-                                                      address *entry, const char *name,\n-                                                      bool dest_uninitialized) {\n-#if COMPILER2_OR_JVMCI\n-  if (VM_Version::supports_avx512vlbw() && VM_Version::supports_bmi2() && MaxVectorSize  >= 32) {\n-     return generate_conjoint_copy_avx3_masked(entry, \"jint_conjoint_arraycopy_avx3\", 2,\n-                                               nooverlap_target, aligned, is_oop, dest_uninitialized);\n-  }\n-#endif\n-  __ align(CodeEntryAlignment);\n-  StubCodeMark mark(this, \"StubRoutines\", name);\n-  address start = __ pc();\n-\n-  Label L_copy_bytes, L_copy_8_bytes, L_exit;\n-  const Register from        = rdi;  \/\/ source array address\n-  const Register to          = rsi;  \/\/ destination array address\n-  const Register count       = rdx;  \/\/ elements count\n-  const Register dword_count = rcx;\n-  const Register qword_count = count;\n-\n-  __ enter(); \/\/ required for proper stackwalking of RuntimeStub frame\n-  assert_clean_int(c_rarg2, rax);    \/\/ Make sure 'count' is clean int.\n-\n-  if (entry != NULL) {\n-    *entry = __ pc();\n-     \/\/ caller can pass a 64-bit byte count here (from Unsafe.copyMemory)\n-    BLOCK_COMMENT(\"Entry:\");\n-  }\n-\n-  array_overlap_test(nooverlap_target, Address::times_4);\n-  setup_arg_regs_using_thread(); \/\/ from => rdi, to => rsi, count => rdx\n-                                 \/\/ r9 is used to save r15_thread\n-\n-  DecoratorSet decorators = IN_HEAP | IS_ARRAY;\n-  if (dest_uninitialized) {\n-    decorators |= IS_DEST_UNINITIALIZED;\n-  }\n-  if (aligned) {\n-    decorators |= ARRAYCOPY_ALIGNED;\n-  }\n-\n-  BasicType type = is_oop ? T_OBJECT : T_INT;\n-  BarrierSetAssembler *bs = BarrierSet::barrier_set()->barrier_set_assembler();\n-  \/\/ no registers are destroyed by this call\n-  bs->arraycopy_prologue(_masm, decorators, type, from, to, count);\n-\n-  assert_clean_int(count, rax); \/\/ Make sure 'count' is clean int.\n-  {\n-    \/\/ UnsafeCopyMemory page error: continue after ucm\n-    UnsafeCopyMemoryMark ucmm(this, !is_oop && !aligned, true);\n-    \/\/ 'from', 'to' and 'count' are now valid\n-    __ movptr(dword_count, count);\n-    __ shrptr(count, 1); \/\/ count => qword_count\n-\n-    \/\/ Copy from high to low addresses.  Use 'to' as scratch.\n-\n-    \/\/ Check for and copy trailing dword\n-    __ testl(dword_count, 1);\n-    __ jcc(Assembler::zero, L_copy_bytes);\n-    __ movl(rax, Address(from, dword_count, Address::times_4, -4));\n-    __ movl(Address(to, dword_count, Address::times_4, -4), rax);\n-    __ jmp(L_copy_bytes);\n-\n-    \/\/ Copy trailing qwords\n-    __ BIND(L_copy_8_bytes);\n-    __ movq(rax, Address(from, qword_count, Address::times_8, -8));\n-    __ movq(Address(to, qword_count, Address::times_8, -8), rax);\n-    __ decrement(qword_count);\n-    __ jcc(Assembler::notZero, L_copy_8_bytes);\n-  }\n-  if (is_oop) {\n-    __ jmp(L_exit);\n-  }\n-  restore_arg_regs_using_thread();\n-  INC_COUNTER_NP(SharedRuntime::_jint_array_copy_ctr, rscratch1); \/\/ Update counter after rscratch1 is free\n-  __ xorptr(rax, rax); \/\/ return 0\n-  __ vzeroupper();\n-  __ leave(); \/\/ required for proper stackwalking of RuntimeStub frame\n-  __ ret(0);\n-\n-  {\n-    \/\/ UnsafeCopyMemory page error: continue after ucm\n-    UnsafeCopyMemoryMark ucmm(this, !is_oop && !aligned, true);\n-    \/\/ Copy in multi-bytes chunks\n-    copy_bytes_backward(from, to, qword_count, rax, L_copy_bytes, L_copy_8_bytes);\n-  }\n-\n-  __ BIND(L_exit);\n-  bs->arraycopy_epilogue(_masm, decorators, type, from, to, dword_count);\n-  restore_arg_regs_using_thread();\n-  INC_COUNTER_NP(SharedRuntime::_jint_array_copy_ctr, rscratch1); \/\/ Update counter after rscratch1 is free\n-  __ xorptr(rax, rax); \/\/ return 0\n-  __ vzeroupper();\n-  __ leave(); \/\/ required for proper stackwalking of RuntimeStub frame\n-  __ ret(0);\n-\n-  return start;\n-}\n-\n-\/\/ Arguments:\n-\/\/   aligned - true => Input and output aligned on a HeapWord boundary == 8 bytes\n-\/\/             ignored\n-\/\/   is_oop  - true => oop array, so generate store check code\n-\/\/   name    - stub name string\n-\/\/\n-\/\/ Inputs:\n-\/\/   c_rarg0   - source array address\n-\/\/   c_rarg1   - destination array address\n-\/\/   c_rarg2   - element count, treated as ssize_t, can be zero\n-\/\/\n- \/\/ Side Effects:\n-\/\/   disjoint_oop_copy_entry or disjoint_long_copy_entry is set to the\n-\/\/   no-overlap entry point used by generate_conjoint_long_oop_copy().\n-\/\/\n-address StubGenerator::generate_disjoint_long_oop_copy(bool aligned, bool is_oop, address *entry,\n-                                                       const char *name, bool dest_uninitialized) {\n-#if COMPILER2_OR_JVMCI\n-  if (VM_Version::supports_avx512vlbw() && VM_Version::supports_bmi2() && MaxVectorSize  >= 32) {\n-     return generate_disjoint_copy_avx3_masked(entry, \"jlong_disjoint_arraycopy_avx3\", 3,\n-                                               aligned, is_oop, dest_uninitialized);\n-  }\n-#endif\n-  __ align(CodeEntryAlignment);\n-  StubCodeMark mark(this, \"StubRoutines\", name);\n-  address start = __ pc();\n-\n-  Label L_copy_bytes, L_copy_8_bytes, L_exit;\n-  const Register from        = rdi;  \/\/ source array address\n-  const Register to          = rsi;  \/\/ destination array address\n-  const Register qword_count = rdx;  \/\/ elements count\n-  const Register end_from    = from; \/\/ source array end address\n-  const Register end_to      = rcx;  \/\/ destination array end address\n-  const Register saved_count = r11;\n-  \/\/ End pointers are inclusive, and if count is not zero they point\n-  \/\/ to the last unit copied:  end_to[0] := end_from[0]\n-\n-  __ enter(); \/\/ required for proper stackwalking of RuntimeStub frame\n-  \/\/ Save no-overlap entry point for generate_conjoint_long_oop_copy()\n-  assert_clean_int(c_rarg2, rax);    \/\/ Make sure 'count' is clean int.\n-\n-  if (entry != NULL) {\n-    *entry = __ pc();\n-    \/\/ caller can pass a 64-bit byte count here (from Unsafe.copyMemory)\n-    BLOCK_COMMENT(\"Entry:\");\n-  }\n-\n-  setup_arg_regs_using_thread(); \/\/ from => rdi, to => rsi, count => rdx\n-                                   \/\/ r9 is used to save r15_thread\n-  \/\/ 'from', 'to' and 'qword_count' are now valid\n-\n-  DecoratorSet decorators = IN_HEAP | IS_ARRAY | ARRAYCOPY_DISJOINT;\n-  if (dest_uninitialized) {\n-    decorators |= IS_DEST_UNINITIALIZED;\n-  }\n-  if (aligned) {\n-    decorators |= ARRAYCOPY_ALIGNED;\n-  }\n-\n-  BasicType type = is_oop ? T_OBJECT : T_LONG;\n-  BarrierSetAssembler *bs = BarrierSet::barrier_set()->barrier_set_assembler();\n-  bs->arraycopy_prologue(_masm, decorators, type, from, to, qword_count);\n-  {\n-    \/\/ UnsafeCopyMemory page error: continue after ucm\n-    UnsafeCopyMemoryMark ucmm(this, !is_oop && !aligned, true);\n-\n-    \/\/ Copy from low to high addresses.  Use 'to' as scratch.\n-    __ lea(end_from, Address(from, qword_count, Address::times_8, -8));\n-    __ lea(end_to,   Address(to,   qword_count, Address::times_8, -8));\n-    __ negptr(qword_count);\n-    __ jmp(L_copy_bytes);\n-\n-    \/\/ Copy trailing qwords\n-    __ BIND(L_copy_8_bytes);\n-    __ movq(rax, Address(end_from, qword_count, Address::times_8, 8));\n-    __ movq(Address(end_to, qword_count, Address::times_8, 8), rax);\n-    __ increment(qword_count);\n-    __ jcc(Assembler::notZero, L_copy_8_bytes);\n-  }\n-  if (is_oop) {\n-    __ jmp(L_exit);\n-  } else {\n-    restore_arg_regs_using_thread();\n-    INC_COUNTER_NP(SharedRuntime::_jlong_array_copy_ctr, rscratch1); \/\/ Update counter after rscratch1 is free\n-    __ xorptr(rax, rax); \/\/ return 0\n-    __ vzeroupper();\n-    __ leave(); \/\/ required for proper stackwalking of RuntimeStub frame\n-    __ ret(0);\n-  }\n-\n-  {\n-    \/\/ UnsafeCopyMemory page error: continue after ucm\n-    UnsafeCopyMemoryMark ucmm(this, !is_oop && !aligned, true);\n-    \/\/ Copy in multi-bytes chunks\n-    copy_bytes_forward(end_from, end_to, qword_count, rax, L_copy_bytes, L_copy_8_bytes);\n-  }\n-\n-  __ BIND(L_exit);\n-  bs->arraycopy_epilogue(_masm, decorators, type, from, to, qword_count);\n-  restore_arg_regs_using_thread();\n-  INC_COUNTER_NP(is_oop ? SharedRuntime::_oop_array_copy_ctr :\n-                          SharedRuntime::_jlong_array_copy_ctr,\n-                 rscratch1); \/\/ Update counter after rscratch1 is free\n-  __ vzeroupper();\n-  __ xorptr(rax, rax); \/\/ return 0\n-  __ leave(); \/\/ required for proper stackwalking of RuntimeStub frame\n-  __ ret(0);\n-\n-  return start;\n-}\n-\n-\/\/ Arguments:\n-\/\/   aligned - true => Input and output aligned on a HeapWord boundary == 8 bytes\n-\/\/             ignored\n-\/\/   is_oop  - true => oop array, so generate store check code\n-\/\/   name    - stub name string\n-\/\/\n-\/\/ Inputs:\n-\/\/   c_rarg0   - source array address\n-\/\/   c_rarg1   - destination array address\n-\/\/   c_rarg2   - element count, treated as ssize_t, can be zero\n-\/\/\n-address StubGenerator::generate_conjoint_long_oop_copy(bool aligned, bool is_oop, address nooverlap_target,\n-                                                       address *entry, const char *name,\n-                                                       bool dest_uninitialized) {\n-#if COMPILER2_OR_JVMCI\n-  if (VM_Version::supports_avx512vlbw() && VM_Version::supports_bmi2() && MaxVectorSize  >= 32) {\n-     return generate_conjoint_copy_avx3_masked(entry, \"jlong_conjoint_arraycopy_avx3\", 3,\n-                                               nooverlap_target, aligned, is_oop, dest_uninitialized);\n-  }\n-#endif\n-  __ align(CodeEntryAlignment);\n-  StubCodeMark mark(this, \"StubRoutines\", name);\n-  address start = __ pc();\n-\n-  Label L_copy_bytes, L_copy_8_bytes, L_exit;\n-  const Register from        = rdi;  \/\/ source array address\n-  const Register to          = rsi;  \/\/ destination array address\n-  const Register qword_count = rdx;  \/\/ elements count\n-  const Register saved_count = rcx;\n-\n-  __ enter(); \/\/ required for proper stackwalking of RuntimeStub frame\n-  assert_clean_int(c_rarg2, rax);    \/\/ Make sure 'count' is clean int.\n-\n-  if (entry != NULL) {\n-    *entry = __ pc();\n-    \/\/ caller can pass a 64-bit byte count here (from Unsafe.copyMemory)\n-    BLOCK_COMMENT(\"Entry:\");\n-  }\n-\n-  array_overlap_test(nooverlap_target, Address::times_8);\n-  setup_arg_regs_using_thread(); \/\/ from => rdi, to => rsi, count => rdx\n-                                 \/\/ r9 is used to save r15_thread\n-  \/\/ 'from', 'to' and 'qword_count' are now valid\n-\n-  DecoratorSet decorators = IN_HEAP | IS_ARRAY;\n-  if (dest_uninitialized) {\n-    decorators |= IS_DEST_UNINITIALIZED;\n-  }\n-  if (aligned) {\n-    decorators |= ARRAYCOPY_ALIGNED;\n-  }\n-\n-  BasicType type = is_oop ? T_OBJECT : T_LONG;\n-  BarrierSetAssembler *bs = BarrierSet::barrier_set()->barrier_set_assembler();\n-  bs->arraycopy_prologue(_masm, decorators, type, from, to, qword_count);\n-  {\n-    \/\/ UnsafeCopyMemory page error: continue after ucm\n-    UnsafeCopyMemoryMark ucmm(this, !is_oop && !aligned, true);\n-\n-    __ jmp(L_copy_bytes);\n-\n-    \/\/ Copy trailing qwords\n-    __ BIND(L_copy_8_bytes);\n-    __ movq(rax, Address(from, qword_count, Address::times_8, -8));\n-    __ movq(Address(to, qword_count, Address::times_8, -8), rax);\n-    __ decrement(qword_count);\n-    __ jcc(Assembler::notZero, L_copy_8_bytes);\n-  }\n-  if (is_oop) {\n-    __ jmp(L_exit);\n-  } else {\n-    restore_arg_regs_using_thread();\n-    INC_COUNTER_NP(SharedRuntime::_jlong_array_copy_ctr, rscratch1); \/\/ Update counter after rscratch1 is free\n-    __ xorptr(rax, rax); \/\/ return 0\n-    __ vzeroupper();\n-    __ leave(); \/\/ required for proper stackwalking of RuntimeStub frame\n-    __ ret(0);\n-  }\n-  {\n-    \/\/ UnsafeCopyMemory page error: continue after ucm\n-    UnsafeCopyMemoryMark ucmm(this, !is_oop && !aligned, true);\n-\n-    \/\/ Copy in multi-bytes chunks\n-    copy_bytes_backward(from, to, qword_count, rax, L_copy_bytes, L_copy_8_bytes);\n-  }\n-  __ BIND(L_exit);\n-  bs->arraycopy_epilogue(_masm, decorators, type, from, to, qword_count);\n-  restore_arg_regs_using_thread();\n-  INC_COUNTER_NP(is_oop ? SharedRuntime::_oop_array_copy_ctr :\n-                          SharedRuntime::_jlong_array_copy_ctr,\n-                 rscratch1); \/\/ Update counter after rscratch1 is free\n-  __ vzeroupper();\n-  __ xorptr(rax, rax); \/\/ return 0\n-  __ leave(); \/\/ required for proper stackwalking of RuntimeStub frame\n-  __ ret(0);\n-\n-  return start;\n-}\n-\n-\n-\/\/ Helper for generating a dynamic type check.\n-\/\/ Smashes no registers.\n-void StubGenerator::generate_type_check(Register sub_klass,\n-                                        Register super_check_offset,\n-                                        Register super_klass,\n-                                        Label& L_success) {\n-  assert_different_registers(sub_klass, super_check_offset, super_klass);\n-\n-  BLOCK_COMMENT(\"type_check:\");\n-\n-  Label L_miss;\n-\n-  __ check_klass_subtype_fast_path(sub_klass, super_klass, noreg,        &L_success, &L_miss, NULL,\n-                                   super_check_offset);\n-  __ check_klass_subtype_slow_path(sub_klass, super_klass, noreg, noreg, &L_success, NULL);\n-\n-  \/\/ Fall through on failure!\n-  __ BIND(L_miss);\n-}\n-\n-\/\/  Generate checkcasting array copy stub\n-\/\/\n-\/\/  Input:\n-\/\/    c_rarg0   - source array address\n-\/\/    c_rarg1   - destination array address\n-\/\/    c_rarg2   - element count, treated as ssize_t, can be zero\n-\/\/    c_rarg3   - size_t ckoff (super_check_offset)\n-\/\/ not Win64\n-\/\/    c_rarg4   - oop ckval (super_klass)\n-\/\/ Win64\n-\/\/    rsp+40    - oop ckval (super_klass)\n-\/\/\n-\/\/  Output:\n-\/\/    rax ==  0  -  success\n-\/\/    rax == -1^K - failure, where K is partial transfer count\n-\/\/\n-address StubGenerator::generate_checkcast_copy(const char *name, address *entry, bool dest_uninitialized) {\n-\n-  Label L_load_element, L_store_element, L_do_card_marks, L_done;\n-\n-  \/\/ Input registers (after setup_arg_regs)\n-  const Register from        = rdi;   \/\/ source array address\n-  const Register to          = rsi;   \/\/ destination array address\n-  const Register length      = rdx;   \/\/ elements count\n-  const Register ckoff       = rcx;   \/\/ super_check_offset\n-  const Register ckval       = r8;    \/\/ super_klass\n-\n-  \/\/ Registers used as temps (r13, r14 are save-on-entry)\n-  const Register end_from    = from;  \/\/ source array end address\n-  const Register end_to      = r13;   \/\/ destination array end address\n-  const Register count       = rdx;   \/\/ -(count_remaining)\n-  const Register r14_length  = r14;   \/\/ saved copy of length\n-  \/\/ End pointers are inclusive, and if length is not zero they point\n-  \/\/ to the last unit copied:  end_to[0] := end_from[0]\n-\n-  const Register rax_oop    = rax;    \/\/ actual oop copied\n-  const Register r11_klass  = r11;    \/\/ oop._klass\n-\n-  \/\/---------------------------------------------------------------\n-  \/\/ Assembler stub will be used for this call to arraycopy\n-  \/\/ if the two arrays are subtypes of Object[] but the\n-  \/\/ destination array type is not equal to or a supertype\n-  \/\/ of the source type.  Each element must be separately\n-  \/\/ checked.\n-\n-  __ align(CodeEntryAlignment);\n-  StubCodeMark mark(this, \"StubRoutines\", name);\n-  address start = __ pc();\n-\n-  __ enter(); \/\/ required for proper stackwalking of RuntimeStub frame\n-\n-#ifdef ASSERT\n-  \/\/ caller guarantees that the arrays really are different\n-  \/\/ otherwise, we would have to make conjoint checks\n-  { Label L;\n-    array_overlap_test(L, TIMES_OOP);\n-    __ stop(\"checkcast_copy within a single array\");\n-    __ bind(L);\n-  }\n-#endif \/\/ASSERT\n-\n-  setup_arg_regs(4); \/\/ from => rdi, to => rsi, length => rdx\n-                     \/\/ ckoff => rcx, ckval => r8\n-                     \/\/ r9 and r10 may be used to save non-volatile registers\n-#ifdef _WIN64\n-  \/\/ last argument (#4) is on stack on Win64\n-  __ movptr(ckval, Address(rsp, 6 * wordSize));\n-#endif\n-\n-  \/\/ Caller of this entry point must set up the argument registers.\n-  if (entry != NULL) {\n-    *entry = __ pc();\n-    BLOCK_COMMENT(\"Entry:\");\n-  }\n-\n-  \/\/ allocate spill slots for r13, r14\n-  enum {\n-    saved_r13_offset,\n-    saved_r14_offset,\n-    saved_r10_offset,\n-    saved_rbp_offset\n-  };\n-  __ subptr(rsp, saved_rbp_offset * wordSize);\n-  __ movptr(Address(rsp, saved_r13_offset * wordSize), r13);\n-  __ movptr(Address(rsp, saved_r14_offset * wordSize), r14);\n-  __ movptr(Address(rsp, saved_r10_offset * wordSize), r10);\n-\n-#ifdef ASSERT\n-    Label L2;\n-    __ get_thread(r14);\n-    __ cmpptr(r15_thread, r14);\n-    __ jcc(Assembler::equal, L2);\n-    __ stop(\"StubRoutines::call_stub: r15_thread is modified by call\");\n-    __ bind(L2);\n-#endif \/\/ ASSERT\n-\n-  \/\/ check that int operands are properly extended to size_t\n-  assert_clean_int(length, rax);\n-  assert_clean_int(ckoff, rax);\n-\n-#ifdef ASSERT\n-  BLOCK_COMMENT(\"assert consistent ckoff\/ckval\");\n-  \/\/ The ckoff and ckval must be mutually consistent,\n-  \/\/ even though caller generates both.\n-  { Label L;\n-    int sco_offset = in_bytes(Klass::super_check_offset_offset());\n-    __ cmpl(ckoff, Address(ckval, sco_offset));\n-    __ jcc(Assembler::equal, L);\n-    __ stop(\"super_check_offset inconsistent\");\n-    __ bind(L);\n-  }\n-#endif \/\/ASSERT\n-\n-  \/\/ Loop-invariant addresses.  They are exclusive end pointers.\n-  Address end_from_addr(from, length, TIMES_OOP, 0);\n-  Address   end_to_addr(to,   length, TIMES_OOP, 0);\n-  \/\/ Loop-variant addresses.  They assume post-incremented count < 0.\n-  Address from_element_addr(end_from, count, TIMES_OOP, 0);\n-  Address   to_element_addr(end_to,   count, TIMES_OOP, 0);\n-\n-  DecoratorSet decorators = IN_HEAP | IS_ARRAY | ARRAYCOPY_CHECKCAST | ARRAYCOPY_DISJOINT;\n-  if (dest_uninitialized) {\n-    decorators |= IS_DEST_UNINITIALIZED;\n-  }\n-\n-  BasicType type = T_OBJECT;\n-  BarrierSetAssembler *bs = BarrierSet::barrier_set()->barrier_set_assembler();\n-  bs->arraycopy_prologue(_masm, decorators, type, from, to, count);\n-\n-  \/\/ Copy from low to high addresses, indexed from the end of each array.\n-  __ lea(end_from, end_from_addr);\n-  __ lea(end_to,   end_to_addr);\n-  __ movptr(r14_length, length);        \/\/ save a copy of the length\n-  assert(length == count, \"\");          \/\/ else fix next line:\n-  __ negptr(count);                     \/\/ negate and test the length\n-  __ jcc(Assembler::notZero, L_load_element);\n-\n-  \/\/ Empty array:  Nothing to do.\n-  __ xorptr(rax, rax);                  \/\/ return 0 on (trivial) success\n-  __ jmp(L_done);\n-\n-  \/\/ ======== begin loop ========\n-  \/\/ (Loop is rotated; its entry is L_load_element.)\n-  \/\/ Loop control:\n-  \/\/   for (count = -count; count != 0; count++)\n-  \/\/ Base pointers src, dst are biased by 8*(count-1),to last element.\n-  __ align(OptoLoopAlignment);\n-\n-  __ BIND(L_store_element);\n-  __ store_heap_oop(to_element_addr, rax_oop, noreg, noreg, noreg, AS_RAW);  \/\/ store the oop\n-  __ increment(count);               \/\/ increment the count toward zero\n-  __ jcc(Assembler::zero, L_do_card_marks);\n-\n-  \/\/ ======== loop entry is here ========\n-  __ BIND(L_load_element);\n-  __ load_heap_oop(rax_oop, from_element_addr, noreg, noreg, AS_RAW); \/\/ load the oop\n-  __ testptr(rax_oop, rax_oop);\n-  __ jcc(Assembler::zero, L_store_element);\n-\n-  __ load_klass(r11_klass, rax_oop, rscratch1);\/\/ query the object klass\n-  generate_type_check(r11_klass, ckoff, ckval, L_store_element);\n-  \/\/ ======== end loop ========\n-\n-  \/\/ It was a real error; we must depend on the caller to finish the job.\n-  \/\/ Register rdx = -1 * number of *remaining* oops, r14 = *total* oops.\n-  \/\/ Emit GC store barriers for the oops we have copied (r14 + rdx),\n-  \/\/ and report their number to the caller.\n-  assert_different_registers(rax, r14_length, count, to, end_to, rcx, rscratch1);\n-  Label L_post_barrier;\n-  __ addptr(r14_length, count);     \/\/ K = (original - remaining) oops\n-  __ movptr(rax, r14_length);       \/\/ save the value\n-  __ notptr(rax);                   \/\/ report (-1^K) to caller (does not affect flags)\n-  __ jccb(Assembler::notZero, L_post_barrier);\n-  __ jmp(L_done); \/\/ K == 0, nothing was copied, skip post barrier\n-\n-  \/\/ Come here on success only.\n-  __ BIND(L_do_card_marks);\n-  __ xorptr(rax, rax);              \/\/ return 0 on success\n-\n-  __ BIND(L_post_barrier);\n-  bs->arraycopy_epilogue(_masm, decorators, type, from, to, r14_length);\n-\n-  \/\/ Common exit point (success or failure).\n-  __ BIND(L_done);\n-  __ movptr(r13, Address(rsp, saved_r13_offset * wordSize));\n-  __ movptr(r14, Address(rsp, saved_r14_offset * wordSize));\n-  __ movptr(r10, Address(rsp, saved_r10_offset * wordSize));\n-  restore_arg_regs();\n-  INC_COUNTER_NP(SharedRuntime::_checkcast_array_copy_ctr, rscratch1); \/\/ Update counter after rscratch1 is free\n-  __ leave(); \/\/ required for proper stackwalking of RuntimeStub frame\n-  __ ret(0);\n-\n-  return start;\n-}\n-\n-\/\/  Generate 'unsafe' array copy stub\n-\/\/  Though just as safe as the other stubs, it takes an unscaled\n-\/\/  size_t argument instead of an element count.\n-\/\/\n-\/\/  Input:\n-\/\/    c_rarg0   - source array address\n-\/\/    c_rarg1   - destination array address\n-\/\/    c_rarg2   - byte count, treated as ssize_t, can be zero\n-\/\/\n-\/\/ Examines the alignment of the operands and dispatches\n-\/\/ to a long, int, short, or byte copy loop.\n-\/\/\n-address StubGenerator::generate_unsafe_copy(const char *name,\n-                                            address byte_copy_entry, address short_copy_entry,\n-                                            address int_copy_entry, address long_copy_entry) {\n-\n-  Label L_long_aligned, L_int_aligned, L_short_aligned;\n-\n-  \/\/ Input registers (before setup_arg_regs)\n-  const Register from        = c_rarg0;  \/\/ source array address\n-  const Register to          = c_rarg1;  \/\/ destination array address\n-  const Register size        = c_rarg2;  \/\/ byte count (size_t)\n-\n-  \/\/ Register used as a temp\n-  const Register bits        = rax;      \/\/ test copy of low bits\n-\n-  __ align(CodeEntryAlignment);\n-  StubCodeMark mark(this, \"StubRoutines\", name);\n-  address start = __ pc();\n-\n-  __ enter(); \/\/ required for proper stackwalking of RuntimeStub frame\n-\n-  \/\/ bump this on entry, not on exit:\n-  INC_COUNTER_NP(SharedRuntime::_unsafe_array_copy_ctr, rscratch1);\n-\n-  __ mov(bits, from);\n-  __ orptr(bits, to);\n-  __ orptr(bits, size);\n-\n-  __ testb(bits, BytesPerLong-1);\n-  __ jccb(Assembler::zero, L_long_aligned);\n-\n-  __ testb(bits, BytesPerInt-1);\n-  __ jccb(Assembler::zero, L_int_aligned);\n-\n-  __ testb(bits, BytesPerShort-1);\n-  __ jump_cc(Assembler::notZero, RuntimeAddress(byte_copy_entry));\n-\n-  __ BIND(L_short_aligned);\n-  __ shrptr(size, LogBytesPerShort); \/\/ size => short_count\n-  __ jump(RuntimeAddress(short_copy_entry));\n-\n-  __ BIND(L_int_aligned);\n-  __ shrptr(size, LogBytesPerInt); \/\/ size => int_count\n-  __ jump(RuntimeAddress(int_copy_entry));\n-\n-  __ BIND(L_long_aligned);\n-  __ shrptr(size, LogBytesPerLong); \/\/ size => qword_count\n-  __ jump(RuntimeAddress(long_copy_entry));\n-\n-  return start;\n-}\n-\n-\/\/ Perform range checks on the proposed arraycopy.\n-\/\/ Kills temp, but nothing else.\n-\/\/ Also, clean the sign bits of src_pos and dst_pos.\n-void StubGenerator::arraycopy_range_checks(Register src,     \/\/ source array oop (c_rarg0)\n-                                           Register src_pos, \/\/ source position (c_rarg1)\n-                                           Register dst,     \/\/ destination array oo (c_rarg2)\n-                                           Register dst_pos, \/\/ destination position (c_rarg3)\n-                                           Register length,\n-                                           Register temp,\n-                                           Label& L_failed) {\n-  BLOCK_COMMENT(\"arraycopy_range_checks:\");\n-\n-  \/\/  if (src_pos + length > arrayOop(src)->length())  FAIL;\n-  __ movl(temp, length);\n-  __ addl(temp, src_pos);             \/\/ src_pos + length\n-  __ cmpl(temp, Address(src, arrayOopDesc::length_offset_in_bytes()));\n-  __ jcc(Assembler::above, L_failed);\n-\n-  \/\/  if (dst_pos + length > arrayOop(dst)->length())  FAIL;\n-  __ movl(temp, length);\n-  __ addl(temp, dst_pos);             \/\/ dst_pos + length\n-  __ cmpl(temp, Address(dst, arrayOopDesc::length_offset_in_bytes()));\n-  __ jcc(Assembler::above, L_failed);\n-\n-  \/\/ Have to clean up high 32-bits of 'src_pos' and 'dst_pos'.\n-  \/\/ Move with sign extension can be used since they are positive.\n-  __ movslq(src_pos, src_pos);\n-  __ movslq(dst_pos, dst_pos);\n-\n-  BLOCK_COMMENT(\"arraycopy_range_checks done\");\n-}\n-\n-\/\/  Generate generic array copy stubs\n-\/\/\n-\/\/  Input:\n-\/\/    c_rarg0    -  src oop\n-\/\/    c_rarg1    -  src_pos (32-bits)\n-\/\/    c_rarg2    -  dst oop\n-\/\/    c_rarg3    -  dst_pos (32-bits)\n-\/\/ not Win64\n-\/\/    c_rarg4    -  element count (32-bits)\n-\/\/ Win64\n-\/\/    rsp+40     -  element count (32-bits)\n-\/\/\n-\/\/  Output:\n-\/\/    rax ==  0  -  success\n-\/\/    rax == -1^K - failure, where K is partial transfer count\n-\/\/\n-address StubGenerator::generate_generic_copy(const char *name,\n-                                             address byte_copy_entry, address short_copy_entry,\n-                                             address int_copy_entry, address oop_copy_entry,\n-                                             address long_copy_entry, address checkcast_copy_entry) {\n-\n-  Label L_failed, L_failed_0, L_objArray;\n-  Label L_copy_shorts, L_copy_ints, L_copy_longs;\n-\n-  \/\/ Input registers\n-  const Register src        = c_rarg0;  \/\/ source array oop\n-  const Register src_pos    = c_rarg1;  \/\/ source position\n-  const Register dst        = c_rarg2;  \/\/ destination array oop\n-  const Register dst_pos    = c_rarg3;  \/\/ destination position\n-#ifndef _WIN64\n-  const Register length     = c_rarg4;\n-  const Register rklass_tmp = r9;  \/\/ load_klass\n-#else\n-  const Address  length(rsp, 7 * wordSize);  \/\/ elements count is on stack on Win64\n-  const Register rklass_tmp = rdi;  \/\/ load_klass\n-#endif\n-\n-  { int modulus = CodeEntryAlignment;\n-    int target  = modulus - 5; \/\/ 5 = sizeof jmp(L_failed)\n-    int advance = target - (__ offset() % modulus);\n-    if (advance < 0)  advance += modulus;\n-    if (advance > 0)  __ nop(advance);\n-  }\n-  StubCodeMark mark(this, \"StubRoutines\", name);\n-\n-  \/\/ Short-hop target to L_failed.  Makes for denser prologue code.\n-  __ BIND(L_failed_0);\n-  __ jmp(L_failed);\n-  assert(__ offset() % CodeEntryAlignment == 0, \"no further alignment needed\");\n-\n-  __ align(CodeEntryAlignment);\n-  address start = __ pc();\n-\n-  __ enter(); \/\/ required for proper stackwalking of RuntimeStub frame\n-\n-#ifdef _WIN64\n-  __ push(rklass_tmp); \/\/ rdi is callee-save on Windows\n-#endif\n-\n-  \/\/ bump this on entry, not on exit:\n-  INC_COUNTER_NP(SharedRuntime::_generic_array_copy_ctr, rscratch1);\n-\n-  \/\/-----------------------------------------------------------------------\n-  \/\/ Assembler stub will be used for this call to arraycopy\n-  \/\/ if the following conditions are met:\n-  \/\/\n-  \/\/ (1) src and dst must not be null.\n-  \/\/ (2) src_pos must not be negative.\n-  \/\/ (3) dst_pos must not be negative.\n-  \/\/ (4) length  must not be negative.\n-  \/\/ (5) src klass and dst klass should be the same and not NULL.\n-  \/\/ (6) src and dst should be arrays.\n-  \/\/ (7) src_pos + length must not exceed length of src.\n-  \/\/ (8) dst_pos + length must not exceed length of dst.\n-  \/\/\n-\n-  \/\/  if (src == NULL) return -1;\n-  __ testptr(src, src);         \/\/ src oop\n-  size_t j1off = __ offset();\n-  __ jccb(Assembler::zero, L_failed_0);\n-\n-  \/\/  if (src_pos < 0) return -1;\n-  __ testl(src_pos, src_pos); \/\/ src_pos (32-bits)\n-  __ jccb(Assembler::negative, L_failed_0);\n-\n-  \/\/  if (dst == NULL) return -1;\n-  __ testptr(dst, dst);         \/\/ dst oop\n-  __ jccb(Assembler::zero, L_failed_0);\n-\n-  \/\/  if (dst_pos < 0) return -1;\n-  __ testl(dst_pos, dst_pos); \/\/ dst_pos (32-bits)\n-  size_t j4off = __ offset();\n-  __ jccb(Assembler::negative, L_failed_0);\n-\n-  \/\/ The first four tests are very dense code,\n-  \/\/ but not quite dense enough to put four\n-  \/\/ jumps in a 16-byte instruction fetch buffer.\n-  \/\/ That's good, because some branch predicters\n-  \/\/ do not like jumps so close together.\n-  \/\/ Make sure of this.\n-  guarantee(((j1off ^ j4off) & ~15) != 0, \"I$ line of 1st & 4th jumps\");\n-\n-  \/\/ registers used as temp\n-  const Register r11_length    = r11; \/\/ elements count to copy\n-  const Register r10_src_klass = r10; \/\/ array klass\n-\n-  \/\/  if (length < 0) return -1;\n-  __ movl(r11_length, length);        \/\/ length (elements count, 32-bits value)\n-  __ testl(r11_length, r11_length);\n-  __ jccb(Assembler::negative, L_failed_0);\n-\n-  __ load_klass(r10_src_klass, src, rklass_tmp);\n-#ifdef ASSERT\n-  \/\/  assert(src->klass() != NULL);\n-  {\n-    BLOCK_COMMENT(\"assert klasses not null {\");\n-    Label L1, L2;\n-    __ testptr(r10_src_klass, r10_src_klass);\n-    __ jcc(Assembler::notZero, L2);   \/\/ it is broken if klass is NULL\n-    __ bind(L1);\n-    __ stop(\"broken null klass\");\n-    __ bind(L2);\n-    __ load_klass(rax, dst, rklass_tmp);\n-    __ cmpq(rax, 0);\n-    __ jcc(Assembler::equal, L1);     \/\/ this would be broken also\n-    BLOCK_COMMENT(\"} assert klasses not null done\");\n-  }\n-#endif\n-\n-  \/\/ Load layout helper (32-bits)\n-  \/\/\n-  \/\/  |array_tag|     | header_size | element_type |     |log2_element_size|\n-  \/\/ 32        30    24            16              8     2                 0\n-  \/\/\n-  \/\/   array_tag: typeArray = 0x3, objArray = 0x2, non-array = 0x0\n-  \/\/\n-\n-  const int lh_offset = in_bytes(Klass::layout_helper_offset());\n-\n-  \/\/ Handle objArrays completely differently...\n-  const jint objArray_lh = Klass::array_layout_helper(T_OBJECT);\n-  __ cmpl(Address(r10_src_klass, lh_offset), objArray_lh);\n-  __ jcc(Assembler::equal, L_objArray);\n-\n-  \/\/  if (src->klass() != dst->klass()) return -1;\n-  __ load_klass(rax, dst, rklass_tmp);\n-  __ cmpq(r10_src_klass, rax);\n-  __ jcc(Assembler::notEqual, L_failed);\n-\n-  const Register rax_lh = rax;  \/\/ layout helper\n-  __ movl(rax_lh, Address(r10_src_klass, lh_offset));\n-\n-  \/\/  if (!src->is_Array()) return -1;\n-  __ cmpl(rax_lh, Klass::_lh_neutral_value);\n-  __ jcc(Assembler::greaterEqual, L_failed);\n-\n-  \/\/ At this point, it is known to be a typeArray (array_tag 0x3).\n-#ifdef ASSERT\n-  {\n-    BLOCK_COMMENT(\"assert primitive array {\");\n-    Label L;\n-    __ cmpl(rax_lh, (Klass::_lh_array_tag_type_value << Klass::_lh_array_tag_shift));\n-    __ jcc(Assembler::greaterEqual, L);\n-    __ stop(\"must be a primitive array\");\n-    __ bind(L);\n-    BLOCK_COMMENT(\"} assert primitive array done\");\n-  }\n+  __ movptr(saved_rdi, rdi);\n+  __ movptr(saved_rsi, rsi);\n+  __ mov(rdi, rcx); \/\/ c_rarg0\n+  __ mov(rsi, rdx); \/\/ c_rarg1\n+  __ mov(rdx, r8);  \/\/ c_rarg2\n+  if (nargs >= 4)\n+    __ mov(rcx, rax); \/\/ c_rarg3 (via rax)\n+#else\n+  assert(c_rarg0 == rdi && c_rarg1 == rsi && c_rarg2 == rdx && c_rarg3 == rcx,\n+         \"unexpected argument registers\");\n@@ -3231,0 +1152,2 @@\n+  DEBUG_ONLY(_regs_in_thread = false;)\n+}\n@@ -3232,19 +1155,0 @@\n-  arraycopy_range_checks(src, src_pos, dst, dst_pos, r11_length,\n-                         r10, L_failed);\n-\n-  \/\/ TypeArrayKlass\n-  \/\/\n-  \/\/ src_addr = (src + array_header_in_bytes()) + (src_pos << log2elemsize);\n-  \/\/ dst_addr = (dst + array_header_in_bytes()) + (dst_pos << log2elemsize);\n-  \/\/\n-\n-  const Register r10_offset = r10;    \/\/ array offset\n-  const Register rax_elsize = rax_lh; \/\/ element size\n-\n-  __ movl(r10_offset, rax_lh);\n-  __ shrl(r10_offset, Klass::_lh_header_size_shift);\n-  __ andptr(r10_offset, Klass::_lh_header_size_mask);   \/\/ array_offset\n-  __ addptr(src, r10_offset);           \/\/ src array offset\n-  __ addptr(dst, r10_offset);           \/\/ dst array offset\n-  BLOCK_COMMENT(\"choose copy loop based on element size\");\n-  __ andl(rax_lh, Klass::_lh_log2_element_size_mask); \/\/ rax_lh -> rax_elsize\n@@ -3252,0 +1156,4 @@\n+void StubGenerator::restore_arg_regs() {\n+  assert(!_regs_in_thread, \"wrong call to restore_arg_regs\");\n+  const Register saved_rdi = r9;\n+  const Register saved_rsi = r10;\n@@ -3253,1 +1161,2 @@\n-  __ pop(rklass_tmp); \/\/ Restore callee-save rdi\n+  __ movptr(rdi, saved_rdi);\n+  __ movptr(rsi, saved_rsi);\n@@ -3255,0 +1164,1 @@\n+}\n@@ -3256,68 +1166,5 @@\n-  \/\/ next registers should be set before the jump to corresponding stub\n-  const Register from     = c_rarg0;  \/\/ source array address\n-  const Register to       = c_rarg1;  \/\/ destination array address\n-  const Register count    = c_rarg2;  \/\/ elements count\n-\n-  \/\/ 'from', 'to', 'count' registers should be set in such order\n-  \/\/ since they are the same as 'src', 'src_pos', 'dst'.\n-\n-  __ cmpl(rax_elsize, 0);\n-  __ jccb(Assembler::notEqual, L_copy_shorts);\n-  __ lea(from, Address(src, src_pos, Address::times_1, 0));\/\/ src_addr\n-  __ lea(to,   Address(dst, dst_pos, Address::times_1, 0));\/\/ dst_addr\n-  __ movl2ptr(count, r11_length); \/\/ length\n-  __ jump(RuntimeAddress(byte_copy_entry));\n-\n-__ BIND(L_copy_shorts);\n-  __ cmpl(rax_elsize, LogBytesPerShort);\n-  __ jccb(Assembler::notEqual, L_copy_ints);\n-  __ lea(from, Address(src, src_pos, Address::times_2, 0));\/\/ src_addr\n-  __ lea(to,   Address(dst, dst_pos, Address::times_2, 0));\/\/ dst_addr\n-  __ movl2ptr(count, r11_length); \/\/ length\n-  __ jump(RuntimeAddress(short_copy_entry));\n-\n-__ BIND(L_copy_ints);\n-  __ cmpl(rax_elsize, LogBytesPerInt);\n-  __ jccb(Assembler::notEqual, L_copy_longs);\n-  __ lea(from, Address(src, src_pos, Address::times_4, 0));\/\/ src_addr\n-  __ lea(to,   Address(dst, dst_pos, Address::times_4, 0));\/\/ dst_addr\n-  __ movl2ptr(count, r11_length); \/\/ length\n-  __ jump(RuntimeAddress(int_copy_entry));\n-\n-__ BIND(L_copy_longs);\n-#ifdef ASSERT\n-  {\n-    BLOCK_COMMENT(\"assert long copy {\");\n-    Label L;\n-    __ cmpl(rax_elsize, LogBytesPerLong);\n-    __ jcc(Assembler::equal, L);\n-    __ stop(\"must be long copy, but elsize is wrong\");\n-    __ bind(L);\n-    BLOCK_COMMENT(\"} assert long copy done\");\n-  }\n-#endif\n-  __ lea(from, Address(src, src_pos, Address::times_8, 0));\/\/ src_addr\n-  __ lea(to,   Address(dst, dst_pos, Address::times_8, 0));\/\/ dst_addr\n-  __ movl2ptr(count, r11_length); \/\/ length\n-  __ jump(RuntimeAddress(long_copy_entry));\n-\n-  \/\/ ObjArrayKlass\n-__ BIND(L_objArray);\n-  \/\/ live at this point:  r10_src_klass, r11_length, src[_pos], dst[_pos]\n-\n-  Label L_plain_copy, L_checkcast_copy;\n-  \/\/  test array classes for subtyping\n-  __ load_klass(rax, dst, rklass_tmp);\n-  __ cmpq(r10_src_klass, rax); \/\/ usual case is exact equality\n-  __ jcc(Assembler::notEqual, L_checkcast_copy);\n-\n-  \/\/ Identically typed arrays can be copied without element-wise checks.\n-  arraycopy_range_checks(src, src_pos, dst, dst_pos, r11_length,\n-                         r10, L_failed);\n-\n-  __ lea(from, Address(src, src_pos, TIMES_OOP,\n-               arrayOopDesc::base_offset_in_bytes(T_OBJECT))); \/\/ src_addr\n-  __ lea(to,   Address(dst, dst_pos, TIMES_OOP,\n-               arrayOopDesc::base_offset_in_bytes(T_OBJECT))); \/\/ dst_addr\n-  __ movl2ptr(count, r11_length); \/\/ length\n-__ BIND(L_plain_copy);\n+\n+\/\/ This is used in places where r10 is a scratch register, and can\n+\/\/ be adapted if r9 is needed also.\n+void StubGenerator::setup_arg_regs_using_thread() {\n+  const Register saved_r15 = r9;\n@@ -3325,1 +1172,13 @@\n-  __ pop(rklass_tmp); \/\/ Restore callee-save rdi\n+  __ mov(saved_r15, r15);  \/\/ r15 is callee saved and needs to be restored\n+  __ get_thread(r15_thread);\n+  assert(c_rarg0 == rcx && c_rarg1 == rdx && c_rarg2 == r8 && c_rarg3 == r9,\n+         \"unexpected argument registers\");\n+  __ movptr(Address(r15_thread, in_bytes(JavaThread::windows_saved_rdi_offset())), rdi);\n+  __ movptr(Address(r15_thread, in_bytes(JavaThread::windows_saved_rsi_offset())), rsi);\n+\n+  __ mov(rdi, rcx); \/\/ c_rarg0\n+  __ mov(rsi, rdx); \/\/ c_rarg1\n+  __ mov(rdx, r8);  \/\/ c_rarg2\n+#else\n+  assert(c_rarg0 == rdi && c_rarg1 == rsi && c_rarg2 == rdx && c_rarg3 == rcx,\n+         \"unexpected argument registers\");\n@@ -3327,1 +1186,2 @@\n-  __ jump(RuntimeAddress(oop_copy_entry));\n+  DEBUG_ONLY(_regs_in_thread = true;)\n+}\n@@ -3329,36 +1189,0 @@\n-__ BIND(L_checkcast_copy);\n-  \/\/ live at this point:  r10_src_klass, r11_length, rax (dst_klass)\n-  {\n-    \/\/ Before looking at dst.length, make sure dst is also an objArray.\n-    __ cmpl(Address(rax, lh_offset), objArray_lh);\n-    __ jcc(Assembler::notEqual, L_failed);\n-\n-    \/\/ It is safe to examine both src.length and dst.length.\n-    arraycopy_range_checks(src, src_pos, dst, dst_pos, r11_length,\n-                           rax, L_failed);\n-\n-    const Register r11_dst_klass = r11;\n-    __ load_klass(r11_dst_klass, dst, rklass_tmp); \/\/ reload\n-\n-    \/\/ Marshal the base address arguments now, freeing registers.\n-    __ lea(from, Address(src, src_pos, TIMES_OOP,\n-                 arrayOopDesc::base_offset_in_bytes(T_OBJECT)));\n-    __ lea(to,   Address(dst, dst_pos, TIMES_OOP,\n-                 arrayOopDesc::base_offset_in_bytes(T_OBJECT)));\n-    __ movl(count, length);           \/\/ length (reloaded)\n-    Register sco_temp = c_rarg3;      \/\/ this register is free now\n-    assert_different_registers(from, to, count, sco_temp,\n-                               r11_dst_klass, r10_src_klass);\n-    assert_clean_int(count, sco_temp);\n-\n-    \/\/ Generate the type check.\n-    const int sco_offset = in_bytes(Klass::super_check_offset_offset());\n-    __ movl(sco_temp, Address(r11_dst_klass, sco_offset));\n-    assert_clean_int(sco_temp, rax);\n-    generate_type_check(r10_src_klass, sco_temp, r11_dst_klass, L_plain_copy);\n-\n-    \/\/ Fetch destination element klass from the ObjArrayKlass header.\n-    int ek_offset = in_bytes(ObjArrayKlass::element_klass_offset());\n-    __ movptr(r11_dst_klass, Address(r11_dst_klass, ek_offset));\n-    __ movl(  sco_temp,      Address(r11_dst_klass, sco_offset));\n-    assert_clean_int(sco_temp, rax);\n@@ -3366,0 +1190,3 @@\n+void StubGenerator::restore_arg_regs_using_thread() {\n+  assert(_regs_in_thread, \"wrong call to restore_arg_regs\");\n+  const Register saved_r15 = r9;\n@@ -3367,1 +1194,4 @@\n-    __ pop(rklass_tmp); \/\/ Restore callee-save rdi\n+  __ get_thread(r15_thread);\n+  __ movptr(rsi, Address(r15_thread, in_bytes(JavaThread::windows_saved_rsi_offset())));\n+  __ movptr(rdi, Address(r15_thread, in_bytes(JavaThread::windows_saved_rdi_offset())));\n+  __ mov(r15, saved_r15);  \/\/ r15 is callee saved and needs to be restored\n@@ -3369,0 +1199,1 @@\n+}\n@@ -3370,6 +1201,8 @@\n-    \/\/ the checkcast_copy loop needs two extra arguments:\n-    assert(c_rarg3 == sco_temp, \"#3 already in place\");\n-    \/\/ Set up arguments for checkcast_copy_entry.\n-    setup_arg_regs(4);\n-    __ movptr(r8, r11_dst_klass);  \/\/ dst.klass.element_klass, r8 is c_rarg4 on Linux\/Solaris\n-    __ jump(RuntimeAddress(checkcast_copy_entry));\n+\n+void StubGenerator::setup_argument_regs(BasicType type) {\n+  if (type == T_BYTE || type == T_SHORT) {\n+    setup_arg_regs(); \/\/ from => rdi, to => rsi, count => rdx\n+                      \/\/ r9 and r10 may be used to save non-volatile registers\n+  } else {\n+    setup_arg_regs_using_thread(); \/\/ from => rdi, to => rsi, count => rdx\n+                                   \/\/ r9 is used to save r15_thread\n@@ -3377,0 +1210,1 @@\n+}\n@@ -3378,8 +1212,0 @@\n-__ BIND(L_failed);\n-#ifdef _WIN64\n-  __ pop(rklass_tmp); \/\/ Restore callee-save rdi\n-#endif\n-  __ xorptr(rax, rax);\n-  __ notptr(rax); \/\/ return -1\n-  __ leave();   \/\/ required for proper stackwalking of RuntimeStub frame\n-  __ ret(0);\n@@ -3387,1 +1213,6 @@\n-  return start;\n+void StubGenerator::restore_argument_regs(BasicType type) {\n+  if (type == T_BYTE || type == T_SHORT) {\n+    restore_arg_regs();\n+  } else {\n+    restore_arg_regs_using_thread();\n+  }\n@@ -3431,98 +1262,0 @@\n-void StubGenerator::generate_arraycopy_stubs() {\n-  address entry;\n-  address entry_jbyte_arraycopy;\n-  address entry_jshort_arraycopy;\n-  address entry_jint_arraycopy;\n-  address entry_oop_arraycopy;\n-  address entry_jlong_arraycopy;\n-  address entry_checkcast_arraycopy;\n-\n-  StubRoutines::_jbyte_disjoint_arraycopy  = generate_disjoint_byte_copy(false, &entry,\n-                                                                         \"jbyte_disjoint_arraycopy\");\n-  StubRoutines::_jbyte_arraycopy           = generate_conjoint_byte_copy(false, entry, &entry_jbyte_arraycopy,\n-                                                                         \"jbyte_arraycopy\");\n-\n-  StubRoutines::_jshort_disjoint_arraycopy = generate_disjoint_short_copy(false, &entry,\n-                                                                          \"jshort_disjoint_arraycopy\");\n-  StubRoutines::_jshort_arraycopy          = generate_conjoint_short_copy(false, entry, &entry_jshort_arraycopy,\n-                                                                          \"jshort_arraycopy\");\n-\n-  StubRoutines::_jint_disjoint_arraycopy   = generate_disjoint_int_oop_copy(false, false, &entry,\n-                                                                            \"jint_disjoint_arraycopy\");\n-  StubRoutines::_jint_arraycopy            = generate_conjoint_int_oop_copy(false, false, entry,\n-                                                                            &entry_jint_arraycopy, \"jint_arraycopy\");\n-\n-  StubRoutines::_jlong_disjoint_arraycopy  = generate_disjoint_long_oop_copy(false, false, &entry,\n-                                                                             \"jlong_disjoint_arraycopy\");\n-  StubRoutines::_jlong_arraycopy           = generate_conjoint_long_oop_copy(false, false, entry,\n-                                                                             &entry_jlong_arraycopy, \"jlong_arraycopy\");\n-  if (UseCompressedOops) {\n-    StubRoutines::_oop_disjoint_arraycopy  = generate_disjoint_int_oop_copy(false, true, &entry,\n-                                                                            \"oop_disjoint_arraycopy\");\n-    StubRoutines::_oop_arraycopy           = generate_conjoint_int_oop_copy(false, true, entry,\n-                                                                            &entry_oop_arraycopy, \"oop_arraycopy\");\n-    StubRoutines::_oop_disjoint_arraycopy_uninit  = generate_disjoint_int_oop_copy(false, true, &entry,\n-                                                                                   \"oop_disjoint_arraycopy_uninit\",\n-                                                                                   \/*dest_uninitialized*\/true);\n-    StubRoutines::_oop_arraycopy_uninit           = generate_conjoint_int_oop_copy(false, true, entry,\n-                                                                                   NULL, \"oop_arraycopy_uninit\",\n-                                                                                   \/*dest_uninitialized*\/true);\n-  } else {\n-    StubRoutines::_oop_disjoint_arraycopy  = generate_disjoint_long_oop_copy(false, true, &entry,\n-                                                                             \"oop_disjoint_arraycopy\");\n-    StubRoutines::_oop_arraycopy           = generate_conjoint_long_oop_copy(false, true, entry,\n-                                                                             &entry_oop_arraycopy, \"oop_arraycopy\");\n-    StubRoutines::_oop_disjoint_arraycopy_uninit  = generate_disjoint_long_oop_copy(false, true, &entry,\n-                                                                                    \"oop_disjoint_arraycopy_uninit\",\n-                                                                                    \/*dest_uninitialized*\/true);\n-    StubRoutines::_oop_arraycopy_uninit           = generate_conjoint_long_oop_copy(false, true, entry,\n-                                                                                    NULL, \"oop_arraycopy_uninit\",\n-                                                                                    \/*dest_uninitialized*\/true);\n-  }\n-\n-  StubRoutines::_checkcast_arraycopy        = generate_checkcast_copy(\"checkcast_arraycopy\", &entry_checkcast_arraycopy);\n-  StubRoutines::_checkcast_arraycopy_uninit = generate_checkcast_copy(\"checkcast_arraycopy_uninit\", NULL,\n-                                                                      \/*dest_uninitialized*\/true);\n-\n-  StubRoutines::_unsafe_arraycopy    = generate_unsafe_copy(\"unsafe_arraycopy\",\n-                                                            entry_jbyte_arraycopy,\n-                                                            entry_jshort_arraycopy,\n-                                                            entry_jint_arraycopy,\n-                                                            entry_jlong_arraycopy);\n-  StubRoutines::_generic_arraycopy   = generate_generic_copy(\"generic_arraycopy\",\n-                                                             entry_jbyte_arraycopy,\n-                                                             entry_jshort_arraycopy,\n-                                                             entry_jint_arraycopy,\n-                                                             entry_oop_arraycopy,\n-                                                             entry_jlong_arraycopy,\n-                                                             entry_checkcast_arraycopy);\n-\n-  StubRoutines::_jbyte_fill = generate_fill(T_BYTE, false, \"jbyte_fill\");\n-  StubRoutines::_jshort_fill = generate_fill(T_SHORT, false, \"jshort_fill\");\n-  StubRoutines::_jint_fill = generate_fill(T_INT, false, \"jint_fill\");\n-  StubRoutines::_arrayof_jbyte_fill = generate_fill(T_BYTE, true, \"arrayof_jbyte_fill\");\n-  StubRoutines::_arrayof_jshort_fill = generate_fill(T_SHORT, true, \"arrayof_jshort_fill\");\n-  StubRoutines::_arrayof_jint_fill = generate_fill(T_INT, true, \"arrayof_jint_fill\");\n-\n-  \/\/ We don't generate specialized code for HeapWord-aligned source\n-  \/\/ arrays, so just use the code we've already generated\n-  StubRoutines::_arrayof_jbyte_disjoint_arraycopy  = StubRoutines::_jbyte_disjoint_arraycopy;\n-  StubRoutines::_arrayof_jbyte_arraycopy           = StubRoutines::_jbyte_arraycopy;\n-\n-  StubRoutines::_arrayof_jshort_disjoint_arraycopy = StubRoutines::_jshort_disjoint_arraycopy;\n-  StubRoutines::_arrayof_jshort_arraycopy          = StubRoutines::_jshort_arraycopy;\n-\n-  StubRoutines::_arrayof_jint_disjoint_arraycopy   = StubRoutines::_jint_disjoint_arraycopy;\n-  StubRoutines::_arrayof_jint_arraycopy            = StubRoutines::_jint_arraycopy;\n-\n-  StubRoutines::_arrayof_jlong_disjoint_arraycopy  = StubRoutines::_jlong_disjoint_arraycopy;\n-  StubRoutines::_arrayof_jlong_arraycopy           = StubRoutines::_jlong_arraycopy;\n-\n-  StubRoutines::_arrayof_oop_disjoint_arraycopy    = StubRoutines::_oop_disjoint_arraycopy;\n-  StubRoutines::_arrayof_oop_arraycopy             = StubRoutines::_oop_arraycopy;\n-\n-  StubRoutines::_arrayof_oop_disjoint_arraycopy_uninit    = StubRoutines::_oop_disjoint_arraycopy_uninit;\n-  StubRoutines::_arrayof_oop_arraycopy_uninit             = StubRoutines::_oop_arraycopy_uninit;\n-}\n-\n-\n@@ -5015,40 +2748,0 @@\n-\/***\n- *  Arguments:\n- *\n- *  Inputs:\n- *   c_rarg0   - int   adler\n- *   c_rarg1   - byte* buff\n- *   c_rarg2   - int   len\n- *\n- * Output:\n- *   rax   - int adler result\n- *\/\n-\n-address StubGenerator::generate_updateBytesAdler32() {\n-  assert(UseAdler32Intrinsics, \"need AVX2\");\n-\n-  __ align(CodeEntryAlignment);\n-  StubCodeMark mark(this, \"StubRoutines\", \"updateBytesAdler32\");\n-  address start = __ pc();\n-\n-  const Register data = r9;\n-  const Register size = r10;\n-\n-  const XMMRegister yshuf0 = xmm6;\n-  const XMMRegister yshuf1 = xmm7;\n-  assert_different_registers(c_rarg0, c_rarg1, c_rarg2, data, size);\n-\n-  BLOCK_COMMENT(\"Entry:\");\n-  __ enter(); \/\/ required for proper stackwalking of RuntimeStub frame\n-\n-  __ vmovdqu(yshuf0, ExternalAddress((address) StubRoutines::x86::_adler32_shuf0_table), r9);\n-  __ vmovdqu(yshuf1, ExternalAddress((address) StubRoutines::x86::_adler32_shuf1_table), r9);\n-  __ movptr(data, c_rarg1); \/\/data\n-  __ movl(size, c_rarg2); \/\/length\n-  __ updateBytesAdler32(c_rarg0, data, size, yshuf0, yshuf1, ExternalAddress((address) StubRoutines::x86::_adler32_ascale_table));\n-  __ leave();\n-  __ ret(0);\n-\n-  return start;\n-}\n-\n@@ -5592,111 +3285,24 @@\n-address StubGenerator::generate_libmExp() {\n-  StubCodeMark mark(this, \"StubRoutines\", \"libmExp\");\n-  address start = __ pc();\n-\n-  BLOCK_COMMENT(\"Entry:\");\n-  __ enter(); \/\/ required for proper stackwalking of RuntimeStub frame\n-\n-  __ fast_exp(xmm0, xmm1, xmm2, xmm3, xmm4, xmm5, xmm6, xmm7,\n-              rax, rcx, rdx, r11);\n-\n-  __ leave(); \/\/ required for proper stackwalking of RuntimeStub frame\n-  __ ret(0);\n-\n-  return start;\n-}\n-\n-address StubGenerator::generate_libmLog() {\n-  StubCodeMark mark(this, \"StubRoutines\", \"libmLog\");\n-  address start = __ pc();\n-\n-  BLOCK_COMMENT(\"Entry:\");\n-  __ enter(); \/\/ required for proper stackwalking of RuntimeStub frame\n-\n-  __ fast_log(xmm0, xmm1, xmm2, xmm3, xmm4, xmm5, xmm6, xmm7,\n-              rax, rcx, rdx, r11, r8);\n-\n-  __ leave(); \/\/ required for proper stackwalking of RuntimeStub frame\n-  __ ret(0);\n-\n-  return start;\n-}\n-\n-address StubGenerator::generate_libmLog10() {\n-  StubCodeMark mark(this, \"StubRoutines\", \"libmLog10\");\n-  address start = __ pc();\n-\n-  BLOCK_COMMENT(\"Entry:\");\n-  __ enter(); \/\/ required for proper stackwalking of RuntimeStub frame\n-\n-  __ fast_log10(xmm0, xmm1, xmm2, xmm3, xmm4, xmm5, xmm6, xmm7,\n-                rax, rcx, rdx, r11, r8);\n-\n-  __ leave(); \/\/ required for proper stackwalking of RuntimeStub frame\n-  __ ret(0);\n-\n-  return start;\n-}\n-\n-address StubGenerator::generate_libmPow() {\n-  StubCodeMark mark(this, \"StubRoutines\", \"libmPow\");\n-  address start = __ pc();\n-\n-  BLOCK_COMMENT(\"Entry:\");\n-  __ enter(); \/\/ required for proper stackwalking of RuntimeStub frame\n-\n-  __ fast_pow(xmm0, xmm1, xmm2, xmm3, xmm4, xmm5, xmm6, xmm7,\n-              rax, rcx, rdx, r8, r9, r10, r11);\n-\n-  __ leave(); \/\/ required for proper stackwalking of RuntimeStub frame\n-  __ ret(0);\n-\n-  return start;\n-}\n-\n-address StubGenerator::generate_libmSin() {\n-  StubCodeMark mark(this, \"StubRoutines\", \"libmSin\");\n-  address start = __ pc();\n-\n-  BLOCK_COMMENT(\"Entry:\");\n-  __ enter(); \/\/ required for proper stackwalking of RuntimeStub frame\n-\n-#ifdef _WIN64\n-  __ push(rsi);\n-  __ push(rdi);\n-#endif\n-  __ fast_sin(xmm0, xmm1, xmm2, xmm3, xmm4, xmm5, xmm6, xmm7,\n-              rax, rbx, rcx, rdx, r8);\n-#ifdef _WIN64\n-  __ pop(rdi);\n-  __ pop(rsi);\n-#endif\n-\n-  __ leave(); \/\/ required for proper stackwalking of RuntimeStub frame\n-  __ ret(0);\n-\n-  return start;\n-}\n-\n-address StubGenerator::generate_libmCos() {\n-  StubCodeMark mark(this, \"StubRoutines\", \"libmCos\");\n-  address start = __ pc();\n-\n-  BLOCK_COMMENT(\"Entry:\");\n-  __ enter(); \/\/ required for proper stackwalking of RuntimeStub frame\n-\n-#ifdef _WIN64\n-  __ push(rsi);\n-  __ push(rdi);\n-#endif\n-  __ fast_cos(xmm0, xmm1, xmm2, xmm3, xmm4, xmm5, xmm6, xmm7,\n-              rax, rcx, rdx, r8, r9, r10, r11, rbx);\n-\n-#ifdef _WIN64\n-  __ pop(rdi);\n-  __ pop(rsi);\n-#endif\n-\n-  __ leave(); \/\/ required for proper stackwalking of RuntimeStub frame\n-  __ ret(0);\n-\n-  return start;\n+void StubGenerator::generate_libm_stubs() {\n+  if (UseLibmIntrinsic && InlineIntrinsics) {\n+    if (vmIntrinsics::is_intrinsic_available(vmIntrinsics::_dsin)) {\n+      StubRoutines::_dsin = generate_libmSin(); \/\/ from stubGenerator_x86_64_sin.cpp\n+    }\n+    if (vmIntrinsics::is_intrinsic_available(vmIntrinsics::_dcos)) {\n+      StubRoutines::_dcos = generate_libmCos(); \/\/ from stubGenerator_x86_64_cos.cpp\n+    }\n+    if (vmIntrinsics::is_intrinsic_available(vmIntrinsics::_dtan)) {\n+      StubRoutines::_dtan = generate_libmTan();\n+    }\n+    if (vmIntrinsics::is_intrinsic_available(vmIntrinsics::_dexp)) {\n+      StubRoutines::_dexp = generate_libmExp();\n+    }\n+    if (vmIntrinsics::is_intrinsic_available(vmIntrinsics::_dpow)) {\n+      StubRoutines::_dpow = generate_libmPow();\n+    }\n+    if (vmIntrinsics::is_intrinsic_available(vmIntrinsics::_dlog)) {\n+      StubRoutines::_dlog = generate_libmLog();\n+    }\n+    if (vmIntrinsics::is_intrinsic_available(vmIntrinsics::_dlog10)) {\n+      StubRoutines::_dlog10 = generate_libmLog10();\n+    }\n+  }\n@@ -5705,24 +3311,0 @@\n-address StubGenerator::generate_libmTan() {\n-  StubCodeMark mark(this, \"StubRoutines\", \"libmTan\");\n-  address start = __ pc();\n-\n-  BLOCK_COMMENT(\"Entry:\");\n-  __ enter(); \/\/ required for proper stackwalking of RuntimeStub frame\n-\n-#ifdef _WIN64\n-  __ push(rsi);\n-  __ push(rdi);\n-#endif\n-  __ fast_tan(xmm0, xmm1, xmm2, xmm3, xmm4, xmm5, xmm6, xmm7,\n-              rax, rcx, rdx, r8, r9, r10, r11, rbx);\n-\n-#ifdef _WIN64\n-  __ pop(rdi);\n-  __ pop(rsi);\n-#endif\n-\n-  __ leave(); \/\/ required for proper stackwalking of RuntimeStub frame\n-  __ ret(0);\n-\n-  return start;\n-}\n@@ -6096,24 +3678,0 @@\n-\n-  if (UseLibmIntrinsic && InlineIntrinsics) {\n-    if (vmIntrinsics::is_intrinsic_available(vmIntrinsics::_dexp)) {\n-      StubRoutines::_dexp = generate_libmExp();\n-    }\n-    if (vmIntrinsics::is_intrinsic_available(vmIntrinsics::_dlog)) {\n-      StubRoutines::_dlog = generate_libmLog();\n-    }\n-    if (vmIntrinsics::is_intrinsic_available(vmIntrinsics::_dlog10)) {\n-      StubRoutines::_dlog10 = generate_libmLog10();\n-    }\n-    if (vmIntrinsics::is_intrinsic_available(vmIntrinsics::_dpow)) {\n-      StubRoutines::_dpow = generate_libmPow();\n-    }\n-    if (vmIntrinsics::is_intrinsic_available(vmIntrinsics::_dsin)) {\n-      StubRoutines::_dsin = generate_libmSin();\n-    }\n-    if (vmIntrinsics::is_intrinsic_available(vmIntrinsics::_dcos)) {\n-      StubRoutines::_dcos = generate_libmCos();\n-    }\n-    if (vmIntrinsics::is_intrinsic_available(vmIntrinsics::_dtan)) {\n-      StubRoutines::_dtan = generate_libmTan();\n-    }\n-  }\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":87,"deletions":2529,"binary":false,"changes":2616,"status":"modified"},{"patch":"@@ -180,0 +180,25 @@\n+  void arraycopy_avx3_special_cases(XMMRegister xmm, KRegister mask, Register from,\n+                                    Register to, Register count, int shift,\n+                                    Register index, Register temp,\n+                                    bool use64byteVector, Label& L_entry, Label& L_exit);\n+\n+  void arraycopy_avx3_special_cases_conjoint(XMMRegister xmm, KRegister mask, Register from,\n+                                             Register to, Register start_index, Register end_index,\n+                                             Register count, int shift, Register temp,\n+                                             bool use64byteVector, Label& L_entry, Label& L_exit);\n+\n+  void copy32_avx(Register dst, Register src, Register index, XMMRegister xmm,\n+                  int shift = Address::times_1, int offset = 0);\n+\n+  void copy64_avx(Register dst, Register src, Register index, XMMRegister xmm,\n+                  bool conjoint, int shift = Address::times_1, int offset = 0,\n+                  bool use64byteVector = false);\n+\n+  void copy64_masked_avx(Register dst, Register src, XMMRegister xmm,\n+                         KRegister mask, Register length, Register index,\n+                         Register temp, int shift = Address::times_1, int offset = 0,\n+                         bool use64byteVector = false);\n+\n+  void copy32_masked_avx(Register dst, Register src, XMMRegister xmm,\n+                         KRegister mask, Register length, Register index,\n+                         Register temp, int shift = Address::times_1, int offset = 0);\n@@ -314,7 +339,0 @@\n-  address generate_counter_shuffle_mask();\n-\n-  \/\/ This mask is used for incrementing counter value(linc0, linc4, etc.)\n-  address generate_counter_mask_addr();\n-\n-  address generate_ghash_polynomial512_addr();\n-\n@@ -328,1 +346,1 @@\n-  void generateHtbl_48_block_zmm(Register htbl, Register avx512_subkeyHtbl);\n+  void generateHtbl_48_block_zmm(Register htbl, Register avx512_subkeyHtbl, Register rscratch);\n@@ -334,1 +352,2 @@\n-  void ev_load_key(XMMRegister xmmdst, Register key, int offset, XMMRegister xmm_shuf_mask = xnoreg);\n+  void ev_load_key(XMMRegister xmmdst, Register key, int offset, XMMRegister xmm_shuf_mask);\n+  void ev_load_key(XMMRegister xmmdst, Register key, int offset, Register rscratch);\n@@ -338,1 +357,2 @@\n-  void load_key(XMMRegister xmmdst, Register key, int offset, XMMRegister xmm_shuf_mask = xnoreg);\n+  void load_key(XMMRegister xmmdst, Register key, int offset, XMMRegister xmm_shuf_mask);\n+  void load_key(XMMRegister xmmdst, Register key, int offset, Register rscratch);\n@@ -353,1 +373,1 @@\n-  void generateHtbl_one_block(Register htbl);\n+  void generateHtbl_one_block(Register htbl, Register rscratch);\n@@ -357,7 +377,5 @@\n-  address generate_ghash_polynomial_addr();\n-\n-  address generate_ghash_shufflemask_addr();\n-\n-  address generate_ghash_long_swap_mask(); \/\/ byte swap x86 long\n-\n-  address generate_ghash_byte_swap_mask(); \/\/ byte swap x86 byte array\n+  \/\/ Used by GHASH and AES stubs.\n+  address ghash_polynomial_addr();\n+  address ghash_shufflemask_addr();\n+  address ghash_long_swap_mask_addr(); \/\/ byte swap x86 long\n+  address ghash_byte_swap_mask_addr(); \/\/ byte swap x86 byte array\n@@ -372,0 +390,2 @@\n+  \/\/ BASE64 stubs\n+\n@@ -420,4 +440,3 @@\n-  address generate_libmExp();\n-  address generate_libmLog();\n-  address generate_libmLog10();\n-  address generate_libmPow();\n+\n+  \/\/ Libm trigonometric stubs\n+\n@@ -427,0 +446,28 @@\n+  address generate_libmExp();\n+  address generate_libmPow();\n+  address generate_libmLog();\n+  address generate_libmLog10();\n+\n+  \/\/ Shared constants\n+  static address ZERO;\n+  static address NEG_ZERO;\n+  static address ONE;\n+  static address ONEHALF;\n+  static address SIGN_MASK;\n+  static address TWO_POW_55;\n+  static address TWO_POW_M55;\n+  static address SHIFTER;\n+  static address PI32INV;\n+  static address PI_INV_TABLE;\n+  static address Ctable;\n+  static address SC_1;\n+  static address SC_2;\n+  static address SC_3;\n+  static address SC_4;\n+  static address PI_4;\n+  static address P_1;\n+  static address P_3;\n+  static address P_2;\n+\n+  void generate_libm_stubs();\n+\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.hpp","additions":69,"deletions":22,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -0,0 +1,268 @@\n+\/*\n+* Copyright (c) 2021, Intel Corporation. All rights reserved.\n+*\n+* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+*\n+* This code is free software; you can redistribute it and\/or modify it\n+* under the terms of the GNU General Public License version 2 only, as\n+* published by the Free Software Foundation.\n+*\n+* This code is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+* FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+* version 2 for more details (a copy is included in the LICENSE file that\n+* accompanied this code).\n+*\n+* You should have received a copy of the GNU General Public License version\n+* 2 along with this work; if not, write to the Free Software Foundation,\n+* Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+*\n+* Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+* or visit www.oracle.com if you need additional information or have any\n+* questions.\n+*\n+*\/\n+\n+#include \"precompiled.hpp\"\n+#include \"asm\/assembler.hpp\"\n+#include \"asm\/assembler.inline.hpp\"\n+#include \"runtime\/globals.hpp\"\n+#include \"runtime\/stubRoutines.hpp\"\n+#include \"macroAssembler_x86.hpp\"\n+#include \"stubGenerator_x86_64.hpp\"\n+\n+#define __ _masm->\n+\n+ATTRIBUTE_ALIGNED(32) juint ADLER32_ASCALE_TABLE[] = {\n+    0x00000000UL, 0x00000001UL, 0x00000002UL, 0x00000003UL,\n+    0x00000004UL, 0x00000005UL, 0x00000006UL, 0x00000007UL\n+};\n+\n+ATTRIBUTE_ALIGNED(32) juint ADLER32_SHUF0_TABLE[] = {\n+    0xFFFFFF00UL, 0xFFFFFF01UL, 0xFFFFFF02UL, 0xFFFFFF03UL,\n+    0xFFFFFF04UL, 0xFFFFFF05UL, 0xFFFFFF06UL, 0xFFFFFF07UL\n+};\n+\n+ATTRIBUTE_ALIGNED(32) juint ADLER32_SHUF1_TABLE[] = {\n+    0xFFFFFF08UL, 0xFFFFFF09, 0xFFFFFF0AUL, 0xFFFFFF0BUL,\n+    0xFFFFFF0CUL, 0xFFFFFF0D, 0xFFFFFF0EUL, 0xFFFFFF0FUL\n+};\n+\n+\n+\/***\n+ *  Arguments:\n+ *\n+ *  Inputs:\n+ *   c_rarg0   - int   adler\n+ *   c_rarg1   - byte* buff\n+ *   c_rarg2   - int   len\n+ *\n+ * Output:\n+ *   rax   - int adler result\n+ *\/\n+address StubGenerator::generate_updateBytesAdler32() {\n+  assert(UseAdler32Intrinsics, \"\");\n+\n+  __ align(CodeEntryAlignment);\n+  StubCodeMark mark(this, \"StubRoutines\", \"updateBytesAdler32\");\n+  address start = __ pc();\n+\n+  const int LIMIT = 5552;\n+  const int BASE = 65521;\n+  const int CHUNKSIZE =  16;\n+  const int CHUNKSIZE_M1 = CHUNKSIZE - 1;\n+\n+\n+  const Register init_d = c_rarg0;\n+  const Register data = r9;\n+  const Register size = r10;\n+  const Register s = r11;\n+  const Register a_d = r12; \/\/r12d\n+  const Register b_d = r8; \/\/r8d\n+  const Register end = r13;\n+\n+  assert_different_registers(c_rarg0, c_rarg1, c_rarg2, data, size);\n+  assert_different_registers(init_d, data, size, s, a_d, b_d, end, rax);\n+\n+  const XMMRegister yshuf0 = xmm6;\n+  const XMMRegister yshuf1 = xmm7;\n+  const XMMRegister ya = xmm0;\n+  const XMMRegister yb = xmm1;\n+  const XMMRegister ydata0 = xmm2;\n+  const XMMRegister ydata1 = xmm3;\n+  const XMMRegister ysa = xmm4;\n+  const XMMRegister ydata = ysa;\n+  const XMMRegister ytmp0 = ydata0;\n+  const XMMRegister ytmp1 = ydata1;\n+  const XMMRegister ytmp2 = xmm5;\n+  const XMMRegister xa = xmm0;\n+  const XMMRegister xb = xmm1;\n+  const XMMRegister xtmp0 = xmm2;\n+  const XMMRegister xtmp1 = xmm3;\n+  const XMMRegister xsa = xmm4;\n+  const XMMRegister xtmp2 = xmm5;\n+\n+  Label SLOOP1, SLOOP1A, SKIP_LOOP_1A, FINISH, LT64, DO_FINAL, FINAL_LOOP, ZERO_SIZE, END;\n+\n+  __ enter(); \/\/ required for proper stackwalking of RuntimeStub frame\n+\n+  __ push(r12);\n+  __ push(r13);\n+  __ push(r14);\n+\n+  __ vmovdqu(yshuf0, ExternalAddress((address)ADLER32_SHUF0_TABLE), r14 \/*rscratch*\/);\n+  __ vmovdqu(yshuf1, ExternalAddress((address)ADLER32_SHUF1_TABLE), r14 \/*rscratch*\/);\n+  __ movptr(data, c_rarg1); \/\/data\n+  __ movl(size, c_rarg2); \/\/length\n+\n+  __ movl(b_d, init_d); \/\/adler\n+  __ shrl(b_d, 16);\n+  __ andl(init_d, 0xFFFF);\n+  __ cmpl(size, 32);\n+  __ jcc(Assembler::below, LT64);\n+  __ movdl(xa, init_d); \/\/vmovd - 32bit\n+  __ vpxor(yb, yb, yb, Assembler::AVX_256bit);\n+\n+  __ bind(SLOOP1);\n+  __ movl(s, LIMIT);\n+  __ cmpl(s, size);\n+  __ cmovl(Assembler::above, s, size); \/\/ s = min(size, LIMIT)\n+  __ lea(end, Address(s, data, Address::times_1, -CHUNKSIZE_M1));\n+  __ cmpptr(data, end);\n+  __ jcc(Assembler::aboveEqual, SKIP_LOOP_1A);\n+\n+  __ align32();\n+  __ bind(SLOOP1A);\n+  __ vbroadcastf128(ydata, Address(data, 0), Assembler::AVX_256bit);\n+  __ addptr(data, CHUNKSIZE);\n+  __ vpshufb(ydata0, ydata, yshuf0, Assembler::AVX_256bit);\n+  __ vpaddd(ya, ya, ydata0, Assembler::AVX_256bit);\n+  __ vpaddd(yb, yb, ya, Assembler::AVX_256bit);\n+  __ vpshufb(ydata1, ydata, yshuf1, Assembler::AVX_256bit);\n+  __ vpaddd(ya, ya, ydata1, Assembler::AVX_256bit);\n+  __ vpaddd(yb, yb, ya, Assembler::AVX_256bit);\n+  __ cmpptr(data, end);\n+  __ jcc(Assembler::below, SLOOP1A);\n+\n+  __ bind(SKIP_LOOP_1A);\n+  __ addptr(end, CHUNKSIZE_M1);\n+  __ testl(s, CHUNKSIZE_M1);\n+  __ jcc(Assembler::notEqual, DO_FINAL);\n+\n+  \/\/ either we're done, or we just did LIMIT\n+  __ subl(size, s);\n+\n+  \/\/ reduce\n+  __ vpslld(yb, yb, 3, Assembler::AVX_256bit); \/\/b is scaled by 8\n+  __ vpmulld(ysa, ya, ExternalAddress((address)ADLER32_ASCALE_TABLE), Assembler::AVX_256bit, r14 \/*rscratch*\/);\n+\n+  \/\/ compute horizontal sums of ya, yb, ysa\n+  __ vextracti128(xtmp0, ya, 1);\n+  __ vextracti128(xtmp1, yb, 1);\n+  __ vextracti128(xtmp2, ysa, 1);\n+  __ vpaddd(xa, xa, xtmp0, Assembler::AVX_128bit);\n+  __ vpaddd(xb, xb, xtmp1, Assembler::AVX_128bit);\n+  __ vpaddd(xsa, xsa, xtmp2, Assembler::AVX_128bit);\n+  __ vphaddd(xa, xa, xa, Assembler::AVX_128bit);\n+  __ vphaddd(xb, xb, xb, Assembler::AVX_128bit);\n+  __ vphaddd(xsa, xsa, xsa, Assembler::AVX_128bit);\n+  __ vphaddd(xa, xa, xa, Assembler::AVX_128bit);\n+  __ vphaddd(xb, xb, xb, Assembler::AVX_128bit);\n+  __ vphaddd(xsa, xsa, xsa, Assembler::AVX_128bit);\n+\n+  __ movdl(rax, xa);\n+  __ xorl(rdx, rdx);\n+  __ movl(rcx, BASE);\n+  __ divl(rcx); \/\/ divide edx:eax by ecx, quot->eax, rem->edx\n+  __ movl(a_d, rdx);\n+\n+  __ vpsubd(xb, xb, xsa, Assembler::AVX_128bit);\n+  __ movdl(rax, xb);\n+  __ addl(rax, b_d);\n+  __ xorl(rdx, rdx);\n+  __ movl(rcx, BASE);\n+  __ divl(rcx); \/\/ divide edx:eax by ecx, quot->eax, rem->edx\n+  __ movl(b_d, rdx);\n+\n+  __ testl(size, size);\n+  __ jcc(Assembler::zero, FINISH);\n+\n+  \/\/ continue loop\n+  __ movdl(xa, a_d);\n+  __ vpxor(yb, yb, yb, Assembler::AVX_256bit);\n+  __ jmp(SLOOP1);\n+\n+  __ bind(FINISH);\n+  __ movl(rax, b_d);\n+  __ shll(rax, 16);\n+  __ orl(rax, a_d);\n+  __ jmp(END);\n+\n+  __ bind(LT64);\n+  __ movl(a_d, init_d);\n+  __ lea(end, Address(data, size, Address::times_1));\n+  __ testl(size, size);\n+  __ jcc(Assembler::notZero, FINAL_LOOP);\n+  __ jmp(ZERO_SIZE);\n+\n+  \/\/ handle remaining 1...15 bytes\n+  __ bind(DO_FINAL);\n+  \/\/ reduce\n+  __ vpslld(yb, yb, 3, Assembler::AVX_256bit); \/\/b is scaled by 8\n+  __ vpmulld(ysa, ya, ExternalAddress((address)ADLER32_ASCALE_TABLE), Assembler::AVX_256bit, r14 \/*rscratch*\/); \/\/scaled a\n+\n+  __ vextracti128(xtmp0, ya, 1);\n+  __ vextracti128(xtmp1, yb, 1);\n+  __ vextracti128(xtmp2, ysa, 1);\n+  __ vpaddd(xa, xa, xtmp0, Assembler::AVX_128bit);\n+  __ vpaddd(xb, xb, xtmp1, Assembler::AVX_128bit);\n+  __ vpaddd(xsa, xsa, xtmp2, Assembler::AVX_128bit);\n+  __ vphaddd(xa, xa, xa, Assembler::AVX_128bit);\n+  __ vphaddd(xb, xb, xb, Assembler::AVX_128bit);\n+  __ vphaddd(xsa, xsa, xsa, Assembler::AVX_128bit);\n+  __ vphaddd(xa, xa, xa, Assembler::AVX_128bit);\n+  __ vphaddd(xb, xb, xb, Assembler::AVX_128bit);\n+  __ vphaddd(xsa, xsa, xsa, Assembler::AVX_128bit);\n+  __ vpsubd(xb, xb, xsa, Assembler::AVX_128bit);\n+\n+  __ movdl(a_d, xa);\n+  __ movdl(rax, xb);\n+  __ addl(b_d, rax);\n+\n+  __ align32();\n+  __ bind(FINAL_LOOP);\n+  __ movzbl(rax, Address(data, 0)); \/\/movzx   eax, byte[data]\n+  __ addl(a_d, rax);\n+  __ addptr(data, 1);\n+  __ addl(b_d, a_d);\n+  __ cmpptr(data, end);\n+  __ jcc(Assembler::below, FINAL_LOOP);\n+\n+  __ bind(ZERO_SIZE);\n+\n+  __ movl(rax, a_d);\n+  __ xorl(rdx, rdx);\n+  __ movl(rcx, BASE);\n+  __ divl(rcx); \/\/ div ecx -- divide edx:eax by ecx, quot->eax, rem->edx\n+  __ movl(a_d, rdx);\n+\n+  __ movl(rax, b_d);\n+  __ xorl(rdx, rdx);\n+  __ movl(rcx, BASE);\n+  __ divl(rcx); \/\/ divide edx:eax by ecx, quot->eax, rem->edx\n+  __ shll(rdx, 16);\n+  __ orl(rdx, a_d);\n+  __ movl(rax, rdx);\n+\n+  __ bind(END);\n+  __ pop(r14);\n+  __ pop(r13);\n+  __ pop(r12);\n+\n+  __ leave();\n+  __ ret(0);\n+\n+  return start;\n+}\n+\n+#undef __\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_adler.cpp","additions":268,"deletions":0,"binary":false,"changes":268,"status":"added"},{"patch":"@@ -43,2 +43,1 @@\n-\n-\/\/ AES intrinsic stubs\n+\/\/ Constants\n@@ -48,0 +47,97 @@\n+\/\/ Shuffle mask for fixing up 128-bit words consisting of big-endian 32-bit integers.\n+ATTRIBUTE_ALIGNED(16) uint64_t KEY_SHUFFLE_MASK[] = {\n+    0x0405060700010203UL, 0x0C0D0E0F08090A0BUL\n+};\n+static address key_shuffle_mask_addr() {\n+  return (address)KEY_SHUFFLE_MASK;\n+}\n+\n+\/\/ Shuffle mask for big-endian 128-bit integers.\n+ATTRIBUTE_ALIGNED(64) uint64_t COUNTER_SHUFFLE_MASK[] = {\n+    0x08090A0B0C0D0E0FUL, 0x0001020304050607UL,\n+    0x08090A0B0C0D0E0FUL, 0x0001020304050607UL,\n+    0x08090A0B0C0D0E0FUL, 0x0001020304050607UL,\n+    0x08090A0B0C0D0E0FUL, 0x0001020304050607UL,\n+};\n+static address counter_shuffle_mask_addr() {\n+  return (address)COUNTER_SHUFFLE_MASK;\n+}\n+\n+\/\/ This mask is used for incrementing counter value\n+ATTRIBUTE_ALIGNED(64) uint64_t COUNTER_MASK_LINC0[] = {\n+    0x0000000000000000UL, 0x0000000000000000UL,\n+    0x0000000000000001UL, 0x0000000000000000UL,\n+    0x0000000000000002UL, 0x0000000000000000UL,\n+    0x0000000000000003UL, 0x0000000000000000UL,\n+};\n+static address counter_mask_linc0_addr() {\n+  return (address)COUNTER_MASK_LINC0;\n+}\n+\n+ATTRIBUTE_ALIGNED(16) uint64_t COUNTER_MASK_LINC1[] = {\n+    0x0000000000000001UL, 0x0000000000000000UL,\n+};\n+static address counter_mask_linc1_addr() {\n+  return (address)COUNTER_MASK_LINC1;\n+}\n+\n+ATTRIBUTE_ALIGNED(64) uint64_t COUNTER_MASK_LINC4[] = {\n+    0x0000000000000004UL, 0x0000000000000000UL,\n+    0x0000000000000004UL, 0x0000000000000000UL,\n+    0x0000000000000004UL, 0x0000000000000000UL,\n+    0x0000000000000004UL, 0x0000000000000000UL,\n+};\n+static address counter_mask_linc4_addr() {\n+  return (address)COUNTER_MASK_LINC4;\n+}\n+\n+ATTRIBUTE_ALIGNED(64) uint64_t COUNTER_MASK_LINC8[] = {\n+    0x0000000000000008UL, 0x0000000000000000UL,\n+    0x0000000000000008UL, 0x0000000000000000UL,\n+    0x0000000000000008UL, 0x0000000000000000UL,\n+    0x0000000000000008UL, 0x0000000000000000UL,\n+};\n+static address counter_mask_linc8_addr() {\n+  return (address)COUNTER_MASK_LINC8;\n+}\n+\n+ATTRIBUTE_ALIGNED(64) uint64_t COUNTER_MASK_LINC16[] = {\n+    0x0000000000000010UL, 0x0000000000000000UL,\n+    0x0000000000000010UL, 0x0000000000000000UL,\n+    0x0000000000000010UL, 0x0000000000000000UL,\n+    0x0000000000000010UL, 0x0000000000000000UL,\n+};\n+static address counter_mask_linc16_addr() {\n+  return (address)COUNTER_MASK_LINC16;\n+}\n+\n+ATTRIBUTE_ALIGNED(64) uint64_t COUNTER_MASK_LINC32[] = {\n+    0x0000000000000020UL, 0x0000000000000000UL,\n+    0x0000000000000020UL, 0x0000000000000000UL,\n+    0x0000000000000020UL, 0x0000000000000000UL,\n+    0x0000000000000020UL, 0x0000000000000000UL,\n+};\n+static address counter_mask_linc32_addr() {\n+  return (address)COUNTER_MASK_LINC32;\n+}\n+\n+ATTRIBUTE_ALIGNED(64) uint64_t GHASH_POLYNOMIAL_REDUCTION[] = {\n+    0x00000001C2000000UL, 0xC200000000000000UL,\n+    0x00000001C2000000UL, 0xC200000000000000UL,\n+    0x00000001C2000000UL, 0xC200000000000000UL,\n+    0x00000001C2000000UL, 0xC200000000000000UL,\n+};\n+static address ghash_polynomial_reduction_addr() {\n+  return (address)GHASH_POLYNOMIAL_REDUCTION;\n+}\n+\n+ATTRIBUTE_ALIGNED(16) uint64_t GHASH_POLYNOMIAL_TWO_ONE[] = {\n+    0x0000000000000001UL, 0x0000000100000000UL,\n+};\n+static address ghash_polynomial_two_one_addr() {\n+  return (address)GHASH_POLYNOMIAL_TWO_ONE;\n+}\n+\n+\n+\/\/ AES intrinsic stubs\n+\n@@ -50,1 +146,0 @@\n-    StubRoutines::x86::_key_shuffle_mask_addr = generate_key_shuffle_mask();  \/\/ needed by the others\n@@ -58,3 +153,0 @@\n-      StubRoutines::x86::_counter_mask_addr = generate_counter_mask_addr();\n-      StubRoutines::x86::_ghash_poly512_addr = generate_ghash_polynomial512_addr();\n-      StubRoutines::x86::_ghash_long_swap_mask_addr = generate_ghash_long_swap_mask();\n@@ -69,3 +161,0 @@\n-      if (StubRoutines::x86::_counter_mask_addr == NULL) {\n-        StubRoutines::x86::_counter_mask_addr = generate_counter_mask_addr();\n-      }\n@@ -74,1 +163,0 @@\n-      StubRoutines::x86::_counter_shuffle_mask_addr = generate_counter_shuffle_mask();\n@@ -80,101 +168,0 @@\n-address StubGenerator::generate_key_shuffle_mask() {\n-  __ align(16);\n-  StubCodeMark mark(this, \"StubRoutines\", \"key_shuffle_mask\");\n-  address start = __ pc();\n-\n-  __ emit_data64( 0x0405060700010203, relocInfo::none );\n-  __ emit_data64( 0x0c0d0e0f08090a0b, relocInfo::none );\n-\n-  return start;\n-}\n-\n-address StubGenerator::generate_counter_shuffle_mask() {\n-  __ align(16);\n-  StubCodeMark mark(this, \"StubRoutines\", \"counter_shuffle_mask\");\n-  address start = __ pc();\n-\n-  __ emit_data64(0x08090a0b0c0d0e0f, relocInfo::none);\n-  __ emit_data64(0x0001020304050607, relocInfo::none);\n-\n-  return start;\n-}\n-\n-\/\/ This mask is used for incrementing counter value(linc0, linc4, etc.)\n-address StubGenerator::generate_counter_mask_addr() {\n-  __ align64();\n-  StubCodeMark mark(this, \"StubRoutines\", \"counter_mask_addr\");\n-  address start = __ pc();\n-\n-  __ emit_data64(0x08090a0b0c0d0e0f, relocInfo::none);\/\/lbswapmask\n-  __ emit_data64(0x0001020304050607, relocInfo::none);\n-  __ emit_data64(0x08090a0b0c0d0e0f, relocInfo::none);\n-  __ emit_data64(0x0001020304050607, relocInfo::none);\n-  __ emit_data64(0x08090a0b0c0d0e0f, relocInfo::none);\n-  __ emit_data64(0x0001020304050607, relocInfo::none);\n-  __ emit_data64(0x08090a0b0c0d0e0f, relocInfo::none);\n-  __ emit_data64(0x0001020304050607, relocInfo::none);\n-  __ emit_data64(0x0000000000000000, relocInfo::none);\/\/linc0 = counter_mask_addr+64\n-  __ emit_data64(0x0000000000000000, relocInfo::none);\n-  __ emit_data64(0x0000000000000001, relocInfo::none);\/\/counter_mask_addr() + 80\n-  __ emit_data64(0x0000000000000000, relocInfo::none);\n-  __ emit_data64(0x0000000000000002, relocInfo::none);\n-  __ emit_data64(0x0000000000000000, relocInfo::none);\n-  __ emit_data64(0x0000000000000003, relocInfo::none);\n-  __ emit_data64(0x0000000000000000, relocInfo::none);\n-  __ emit_data64(0x0000000000000004, relocInfo::none);\/\/linc4 = counter_mask_addr() + 128\n-  __ emit_data64(0x0000000000000000, relocInfo::none);\n-  __ emit_data64(0x0000000000000004, relocInfo::none);\n-  __ emit_data64(0x0000000000000000, relocInfo::none);\n-  __ emit_data64(0x0000000000000004, relocInfo::none);\n-  __ emit_data64(0x0000000000000000, relocInfo::none);\n-  __ emit_data64(0x0000000000000004, relocInfo::none);\n-  __ emit_data64(0x0000000000000000, relocInfo::none);\n-  __ emit_data64(0x0000000000000008, relocInfo::none);\/\/linc8 = counter_mask_addr() + 192\n-  __ emit_data64(0x0000000000000000, relocInfo::none);\n-  __ emit_data64(0x0000000000000008, relocInfo::none);\n-  __ emit_data64(0x0000000000000000, relocInfo::none);\n-  __ emit_data64(0x0000000000000008, relocInfo::none);\n-  __ emit_data64(0x0000000000000000, relocInfo::none);\n-  __ emit_data64(0x0000000000000008, relocInfo::none);\n-  __ emit_data64(0x0000000000000000, relocInfo::none);\n-  __ emit_data64(0x0000000000000020, relocInfo::none);\/\/linc32 = counter_mask_addr() + 256\n-  __ emit_data64(0x0000000000000000, relocInfo::none);\n-  __ emit_data64(0x0000000000000020, relocInfo::none);\n-  __ emit_data64(0x0000000000000000, relocInfo::none);\n-  __ emit_data64(0x0000000000000020, relocInfo::none);\n-  __ emit_data64(0x0000000000000000, relocInfo::none);\n-  __ emit_data64(0x0000000000000020, relocInfo::none);\n-  __ emit_data64(0x0000000000000000, relocInfo::none);\n-  __ emit_data64(0x0000000000000010, relocInfo::none);\/\/linc16 = counter_mask_addr() + 320\n-  __ emit_data64(0x0000000000000000, relocInfo::none);\n-  __ emit_data64(0x0000000000000010, relocInfo::none);\n-  __ emit_data64(0x0000000000000000, relocInfo::none);\n-  __ emit_data64(0x0000000000000010, relocInfo::none);\n-  __ emit_data64(0x0000000000000000, relocInfo::none);\n-  __ emit_data64(0x0000000000000010, relocInfo::none);\n-  __ emit_data64(0x0000000000000000, relocInfo::none);\n-\n-  return start;\n-}\n-\n-address StubGenerator::generate_ghash_polynomial512_addr() {\n-  __ align(CodeEntryAlignment);\n-  StubCodeMark mark(this, \"StubRoutines\", \"_ghash_poly512_addr\");\n-  address start = __ pc();\n-\n-  __ emit_data64(0x00000001C2000000, relocInfo::none); \/\/ POLY for reduction\n-  __ emit_data64(0xC200000000000000, relocInfo::none);\n-  __ emit_data64(0x00000001C2000000, relocInfo::none);\n-  __ emit_data64(0xC200000000000000, relocInfo::none);\n-  __ emit_data64(0x00000001C2000000, relocInfo::none);\n-  __ emit_data64(0xC200000000000000, relocInfo::none);\n-  __ emit_data64(0x00000001C2000000, relocInfo::none);\n-  __ emit_data64(0xC200000000000000, relocInfo::none);\n-  __ emit_data64(0x0000000000000001, relocInfo::none); \/\/ POLY\n-  __ emit_data64(0xC200000000000000, relocInfo::none);\n-  __ emit_data64(0x0000000000000001, relocInfo::none); \/\/ TWOONE\n-  __ emit_data64(0x0000000100000000, relocInfo::none);\n-\n-  return start;\n-}\n-\n@@ -446,1 +433,1 @@\n-  __ movdqu(xmm_counter_shuf_mask, ExternalAddress(StubRoutines::x86::counter_shuffle_mask_addr()), pos); \/\/ pos as scratch\n+  __ movdqu(xmm_counter_shuf_mask, ExternalAddress(counter_shuffle_mask_addr()), pos \/*rscratch*\/);\n@@ -469,1 +456,1 @@\n-  __ movdqu(xmm_key_shuf_mask, ExternalAddress(StubRoutines::x86::key_shuffle_mask_addr()), rbx); \/\/ rbx as scratch\n+  __ movdqu(xmm_key_shuf_mask, ExternalAddress(key_shuffle_mask_addr()), rbx \/*rscratch*\/);\n@@ -679,1 +666,1 @@\n-  __ movdqu(xmm_key_shuf_mask, ExternalAddress(StubRoutines::x86::key_shuffle_mask_addr()));\n+  __ movdqu(xmm_key_shuf_mask, ExternalAddress(key_shuffle_mask_addr()), rbx \/*rscratch*\/);\n@@ -952,1 +939,1 @@\n-  __ movdqu(xmm_key_shuf_mask, ExternalAddress(StubRoutines::x86::key_shuffle_mask_addr()));\n+  __ movdqu(xmm_key_shuf_mask, ExternalAddress(key_shuffle_mask_addr()), r10 \/*rscratch*\/);\n@@ -1007,0 +994,1 @@\n+\n@@ -1045,1 +1033,1 @@\n-  __ movdqu(xmm_key_shuf_mask, ExternalAddress(StubRoutines::x86::key_shuffle_mask_addr()));\n+  __ movdqu(xmm_key_shuf_mask, ExternalAddress(key_shuffle_mask_addr()), r10 \/*rscratch*\/);\n@@ -1101,0 +1089,1 @@\n+\n@@ -1132,3 +1121,1 @@\n-#ifndef _WIN64\n-  const Register len_reg     = c_rarg4;  \/\/ src len (must be multiple of blocksize 16)\n-#else\n+#ifdef _WIN64\n@@ -1137,0 +1124,2 @@\n+#else\n+  const Register len_reg     = c_rarg4;  \/\/ src len (must be multiple of blocksize 16)\n@@ -1162,1 +1151,1 @@\n-  __ movdqu(xmm_key_shuf_mask, ExternalAddress(StubRoutines::x86::key_shuffle_mask_addr()));\n+  __ movdqu(xmm_key_shuf_mask, ExternalAddress(key_shuffle_mask_addr()), r10 \/*rscratch*\/);\n@@ -1170,0 +1159,1 @@\n+\n@@ -1243,1 +1233,1 @@\n-  load_key(xmm_temp, key, 0xe0);\n+  load_key(xmm_temp, key, 0xe0, r10 \/*rscratch*\/);\n@@ -1317,1 +1307,1 @@\n-  __ movdqu(xmm_key_shuf_mask, ExternalAddress(StubRoutines::x86::key_shuffle_mask_addr()));\n+  __ movdqu(xmm_key_shuf_mask, ExternalAddress(key_shuffle_mask_addr()), rbx \/*rscratch*\/);\n@@ -1359,1 +1349,1 @@\n-      load_key(xmm15, key, 0xb0); \/\/ 0xb0; 192-bit key goes up to 0xc0\n+      load_key(xmm15, key, 0xb0, rbx \/*rscratch*\/); \/\/ 0xb0; 192-bit key goes up to 0xc0\n@@ -1361,1 +1351,1 @@\n-      load_key(xmm1, key, 0xc0);  \/\/ 0xc0;\n+      load_key(xmm1, key, 0xc0, rbx \/*rscratch*\/);  \/\/ 0xc0;\n@@ -1366,1 +1356,1 @@\n-      load_key(xmm15, key, 0xd0); \/\/ 0xd0; 256-bit key goes up to 0xe0\n+      load_key(xmm15, key, 0xd0, rbx \/*rscratch*\/); \/\/ 0xd0; 256-bit key goes up to 0xe0\n@@ -1368,1 +1358,1 @@\n-      load_key(xmm1, key, 0xe0);  \/\/ 0xe0;\n+      load_key(xmm1, key, 0xe0, rbx \/*rscratch*\/);  \/\/ 0xe0;\n@@ -1370,1 +1360,1 @@\n-      load_key(xmm15, key, 0xb0); \/\/ 0xb0;\n+      load_key(xmm15, key, 0xb0, rbx \/*rscratch*\/); \/\/ 0xb0;\n@@ -1372,1 +1362,1 @@\n-      load_key(xmm1, key, 0xc0);  \/\/ 0xc0;\n+      load_key(xmm1, key, 0xc0, rbx \/*rscratch*\/);  \/\/ 0xc0;\n@@ -1458,2 +1448,2 @@\n-      load_key(xmm_key11, key, 0xb0); \/\/ 0xb0; 192-bit key goes up to 0xc0\n-      load_key(xmm_key12, key, 0xc0); \/\/ 0xc0; 192-bit key goes up to 0xc0\n+      load_key(xmm_key11, key, 0xb0, rbx \/*rscratch*\/); \/\/ 0xb0; 192-bit key goes up to 0xc0\n+      load_key(xmm_key12, key, 0xc0, rbx \/*rscratch*\/); \/\/ 0xc0; 192-bit key goes up to 0xc0\n@@ -1462,1 +1452,1 @@\n-      load_key(xmm_key11, key, 0xb0); \/\/ 0xb0; 256-bit key goes up to 0xe0\n+      load_key(xmm_key11, key, 0xb0, rbx \/*rscratch*\/); \/\/ 0xb0; 256-bit key goes up to 0xe0\n@@ -1478,1 +1468,1 @@\n-      load_key(key_tmp, key, 0xc0);\n+      load_key(key_tmp, key, 0xc0, rbx \/*rscratch*\/);\n@@ -1480,1 +1470,1 @@\n-      load_key(key_tmp, key, 0xd0);\n+      load_key(key_tmp, key, 0xd0, rbx \/*rscratch*\/);\n@@ -1482,1 +1472,1 @@\n-      load_key(key_tmp, key, 0xe0);\n+      load_key(key_tmp, key, 0xe0, rbx \/*rscratch*\/);\n@@ -1614,1 +1604,0 @@\n-\/\/ can optionally specify that the shuffle mask is already in an xmmregister\n@@ -1617,5 +1606,6 @@\n-  if (xmm_shuf_mask != xnoreg) {\n-    __ pshufb(xmmdst, xmm_shuf_mask);\n-  } else {\n-    __ pshufb(xmmdst, ExternalAddress(StubRoutines::x86::key_shuffle_mask_addr()));\n-  }\n+  __ pshufb(xmmdst, xmm_shuf_mask);\n+}\n+\n+void StubGenerator::load_key(XMMRegister xmmdst, Register key, int offset, Register rscratch) {\n+  __ movdqu(xmmdst, Address(key, offset));\n+  __ pshufb(xmmdst, ExternalAddress(key_shuffle_mask_addr()), rscratch);\n@@ -1626,5 +1616,7 @@\n-  if (xmm_shuf_mask != xnoreg) {\n-    __ pshufb(xmmdst, xmm_shuf_mask);\n-  } else {\n-    __ pshufb(xmmdst, ExternalAddress(StubRoutines::x86::key_shuffle_mask_addr()));\n-  }\n+  __ pshufb(xmmdst, xmm_shuf_mask);\n+  __ evshufi64x2(xmmdst, xmmdst, xmmdst, 0x0, Assembler::AVX_512bit);\n+}\n+\n+void StubGenerator::ev_load_key(XMMRegister xmmdst, Register key, int offset, Register rscratch) {\n+  __ movdqu(xmmdst, Address(key, offset));\n+  __ pshufb(xmmdst, ExternalAddress(key_shuffle_mask_addr()), rscratch);\n@@ -1634,0 +1626,1 @@\n+\n@@ -1662,1 +1655,1 @@\n-  __ movdqu(xmm_key_shuf_mask, ExternalAddress(StubRoutines::x86::key_shuffle_mask_addr()));\n+  __ movdqu(xmm_key_shuf_mask, ExternalAddress(key_shuffle_mask_addr()), rbx \/*rscratch*\/);\n@@ -1872,1 +1865,1 @@\n-  __ movdqu(xmm_key_shuf_mask, ExternalAddress(StubRoutines::x86::key_shuffle_mask_addr()));\n+  __ movdqu(xmm_key_shuf_mask, ExternalAddress(key_shuffle_mask_addr()), rbx \/*rscratch*\/);\n@@ -2101,1 +2094,1 @@\n-  __ evmovdquq(xmm16, ExternalAddress(StubRoutines::x86::counter_mask_addr()), Assembler::AVX_512bit, r15);\n+  __ evmovdquq(xmm16, ExternalAddress(counter_shuffle_mask_addr()), Assembler::AVX_512bit, r15 \/*rscratch*\/);\n@@ -2111,8 +2104,8 @@\n-  __ vpaddd(xmm8, xmm8, ExternalAddress(StubRoutines::x86::counter_mask_addr() + 64), Assembler::AVX_512bit, r15);\/\/linc0\n-  __ vpaddd(xmm9, xmm8, ExternalAddress(StubRoutines::x86::counter_mask_addr() + 128), Assembler::AVX_512bit, r15);\/\/linc4(rip)\n-  __ vpaddd(xmm10, xmm9, ExternalAddress(StubRoutines::x86::counter_mask_addr() + 128), Assembler::AVX_512bit, r15);\/\/Linc4(rip)\n-  __ vpaddd(xmm11, xmm10, ExternalAddress(StubRoutines::x86::counter_mask_addr() + 128), Assembler::AVX_512bit, r15);\/\/Linc4(rip)\n-  __ vpaddd(xmm12, xmm11, ExternalAddress(StubRoutines::x86::counter_mask_addr() + 128), Assembler::AVX_512bit, r15);\/\/Linc4(rip)\n-  __ vpaddd(xmm13, xmm12, ExternalAddress(StubRoutines::x86::counter_mask_addr() + 128), Assembler::AVX_512bit, r15);\/\/Linc4(rip)\n-  __ vpaddd(xmm14, xmm13, ExternalAddress(StubRoutines::x86::counter_mask_addr() + 128), Assembler::AVX_512bit, r15);\/\/Linc4(rip)\n-  __ vpaddd(xmm15, xmm14, ExternalAddress(StubRoutines::x86::counter_mask_addr() + 128), Assembler::AVX_512bit, r15);\/\/Linc4(rip)\n+  __ vpaddd(xmm8,  xmm8,  ExternalAddress(counter_mask_linc0_addr()), Assembler::AVX_512bit, r15 \/*rscratch*\/);\n+  __ vpaddd(xmm9,  xmm8,  ExternalAddress(counter_mask_linc4_addr()), Assembler::AVX_512bit, r15 \/*rscratch*\/);\n+  __ vpaddd(xmm10, xmm9,  ExternalAddress(counter_mask_linc4_addr()), Assembler::AVX_512bit, r15 \/*rscratch*\/);\n+  __ vpaddd(xmm11, xmm10, ExternalAddress(counter_mask_linc4_addr()), Assembler::AVX_512bit, r15 \/*rscratch*\/);\n+  __ vpaddd(xmm12, xmm11, ExternalAddress(counter_mask_linc4_addr()), Assembler::AVX_512bit, r15 \/*rscratch*\/);\n+  __ vpaddd(xmm13, xmm12, ExternalAddress(counter_mask_linc4_addr()), Assembler::AVX_512bit, r15 \/*rscratch*\/);\n+  __ vpaddd(xmm14, xmm13, ExternalAddress(counter_mask_linc4_addr()), Assembler::AVX_512bit, r15 \/*rscratch*\/);\n+  __ vpaddd(xmm15, xmm14, ExternalAddress(counter_mask_linc4_addr()), Assembler::AVX_512bit, r15 \/*rscratch*\/);\n@@ -2121,1 +2114,1 @@\n-  __ evmovdquq(xmm19, ExternalAddress(StubRoutines::x86::counter_mask_addr() + 256), Assembler::AVX_512bit, r15);\/\/Linc32\n+  __ evmovdquq(xmm19, ExternalAddress(counter_mask_linc32_addr()), Assembler::AVX_512bit, r15 \/*rscratch*\/);\n@@ -2124,1 +2117,1 @@\n-  __ movdqu(xmm31, ExternalAddress(StubRoutines::x86::key_shuffle_mask_addr()));\n+  __ movdqu(xmm31, ExternalAddress(key_shuffle_mask_addr()), r15 \/*rscratch*\/);\n@@ -2240,1 +2233,1 @@\n-  __ evmovdquq(xmm19, ExternalAddress(StubRoutines::x86::counter_mask_addr() + 80), Assembler::AVX_128bit, r15);\n+  __ evmovdquq(xmm19, ExternalAddress(counter_mask_linc1_addr()), Assembler::AVX_128bit, r15 \/*rscratch*\/);\n@@ -2247,1 +2240,1 @@\n-  __ evmovdquq(xmm19, ExternalAddress(StubRoutines::x86::counter_mask_addr() + 320), Assembler::AVX_512bit, r15);\/\/Linc16(rip)\n+  __ evmovdquq(xmm19, ExternalAddress(counter_mask_linc16_addr()), Assembler::AVX_512bit, r15 \/*rscratch*\/);\n@@ -2312,1 +2305,1 @@\n-  __ evmovdquq(xmm19, ExternalAddress(StubRoutines::x86::counter_mask_addr() + 80), Assembler::AVX_128bit, r15);\/\/Linc0 + 16(rip)\n+  __ evmovdquq(xmm19, ExternalAddress(counter_mask_linc1_addr()), Assembler::AVX_128bit, r15 \/*rscratch*\/);\n@@ -2319,1 +2312,1 @@\n-  __ evmovdquq(xmm19, ExternalAddress(StubRoutines::x86::counter_mask_addr() + 192), Assembler::AVX_512bit, r15);\/\/Linc8(rip)\n+  __ evmovdquq(xmm19, ExternalAddress(counter_mask_linc8_addr()), Assembler::AVX_512bit, r15 \/*rscratch*\/);\n@@ -2372,1 +2365,1 @@\n-  __ evmovdquq(xmm19, ExternalAddress(StubRoutines::x86::counter_mask_addr() + 80), Assembler::AVX_128bit, r15);\/\/Linc0 + 16(rip)\n+  __ evmovdquq(xmm19, ExternalAddress(counter_mask_linc1_addr()), Assembler::AVX_128bit, r15 \/*rscratch*\/);\n@@ -2379,1 +2372,1 @@\n-  __ evmovdquq(xmm19, ExternalAddress(StubRoutines::x86::counter_mask_addr() + 128), Assembler::AVX_512bit, r15);\/\/Linc4(rip)\n+  __ evmovdquq(xmm19, ExternalAddress(counter_mask_linc4_addr()), Assembler::AVX_512bit, r15 \/*rscratch*\/);\n@@ -2423,1 +2416,1 @@\n-  __ evmovdquq(xmm19, ExternalAddress(StubRoutines::x86::counter_mask_addr() + 80), Assembler::AVX_128bit, r15);\/\/Linc0 + 16(rip)\n+  __ evmovdquq(xmm19, ExternalAddress(counter_mask_linc1_addr()), Assembler::AVX_128bit, r15 \/*rscratch*\/);\n@@ -2560,1 +2553,1 @@\n-  __ evmovdquq(TMP3, ExternalAddress(StubRoutines::x86::ghash_polynomial512_addr()), Assembler::AVX_512bit, r15);\n+  __ evmovdquq(TMP3, ExternalAddress(ghash_polynomial_reduction_addr()), Assembler::AVX_512bit, r15 \/*rscratch*\/);\n@@ -2571,1 +2564,1 @@\n-void StubGenerator::generateHtbl_48_block_zmm(Register htbl, Register avx512_htbl) {\n+void StubGenerator::generateHtbl_48_block_zmm(Register htbl, Register avx512_htbl, Register rscratch) {\n@@ -2580,1 +2573,1 @@\n-  __ movdqu(xmm10, ExternalAddress(StubRoutines::x86::ghash_long_swap_mask_addr()));\n+  __ movdqu(xmm10, ExternalAddress(ghash_long_swap_mask_addr()), rscratch);\n@@ -2583,2 +2576,2 @@\n-  __ movdqu(xmm11, ExternalAddress(StubRoutines::x86::ghash_polynomial512_addr() + 64)); \/\/ Poly\n-  __ movdqu(xmm12, ExternalAddress(StubRoutines::x86::ghash_polynomial512_addr() + 80)); \/\/ Twoone\n+  __ movdqu(xmm11, ExternalAddress(ghash_polynomial_addr()), rscratch);\n+  __ movdqu(xmm12, ExternalAddress(ghash_polynomial_two_one_addr()), rscratch);\n@@ -2838,1 +2831,1 @@\n-    __ evmovdquq(ZTMP12, ExternalAddress(StubRoutines::x86::ghash_polynomial512_addr()), Assembler::AVX_512bit, rbx);\n+    __ evmovdquq(ZTMP12, ExternalAddress(ghash_polynomial_reduction_addr()), Assembler::AVX_512bit, rbx \/*rscratch*\/);\n@@ -2945,1 +2938,1 @@\n-  __ movdqu(xmm24, ExternalAddress(StubRoutines::x86::ghash_long_swap_mask_addr()), rbx);\n+  __ movdqu(xmm24, ExternalAddress(ghash_long_swap_mask_addr()), rbx \/*rscratch*\/);\n@@ -2955,1 +2948,1 @@\n-  __ evmovdquq(xmm24, ExternalAddress(StubRoutines::x86::counter_mask_addr()), Assembler::AVX_512bit, rbx);\n+  __ evmovdquq(xmm24, ExternalAddress(counter_shuffle_mask_addr()), Assembler::AVX_512bit, rbx \/*rscratch*\/);\n@@ -2960,1 +2953,1 @@\n-  __ evmovdquq(COUNTER_INC_MASK, ExternalAddress(StubRoutines::x86::counter_mask_addr() + 128), Assembler::AVX_512bit, rbx);\n+  __ evmovdquq(COUNTER_INC_MASK, ExternalAddress(counter_mask_linc4_addr()), Assembler::AVX_512bit, rbx \/*rscratch*\/);\n@@ -2962,1 +2955,1 @@\n-  __ vpaddd(ZTMP5, CTR_BLOCKx, ExternalAddress(StubRoutines::x86::counter_mask_addr() + 64), Assembler::AVX_512bit, rbx);\n+  __ vpaddd(ZTMP5, CTR_BLOCKx, ExternalAddress(counter_mask_linc0_addr()), Assembler::AVX_512bit, rbx \/*rscratch*\/);\n@@ -2975,1 +2968,1 @@\n-  __ movdqu(xmm29, ExternalAddress(StubRoutines::x86::key_shuffle_mask_addr()), rbx);\n+  __ movdqu(xmm29, ExternalAddress(key_shuffle_mask_addr()), rbx \/*rscratch*\/);\n@@ -3138,1 +3131,1 @@\n-  __ evmovdquq(ZTMP15, ExternalAddress(StubRoutines::x86::ghash_polynomial512_addr()), Assembler::AVX_512bit, rbx);\n+  __ evmovdquq(ZTMP15, ExternalAddress(ghash_polynomial_reduction_addr()), Assembler::AVX_512bit, rbx \/*rscratch*\/);\n@@ -3147,1 +3140,1 @@\n-  __ movdqu(xmm24, ExternalAddress(StubRoutines::x86::ghash_long_swap_mask_addr()));\n+  __ movdqu(xmm24, ExternalAddress(ghash_long_swap_mask_addr()), rbx \/*rscratch*\/);\n@@ -3154,1 +3147,1 @@\n-  generateHtbl_48_block_zmm(subkeyHtbl, avx512_subkeyHtbl);\n+  generateHtbl_48_block_zmm(subkeyHtbl, avx512_subkeyHtbl, rbx \/*rscratch*\/);\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_aes.cpp","additions":172,"deletions":179,"binary":false,"changes":351,"status":"modified"},{"patch":"@@ -0,0 +1,2546 @@\n+\/*\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"asm\/macroAssembler.hpp\"\n+#include \"gc\/shared\/barrierSet.hpp\"\n+#include \"gc\/shared\/barrierSetAssembler.hpp\"\n+#include \"oops\/objArrayKlass.hpp\"\n+#include \"runtime\/sharedRuntime.hpp\"\n+#include \"runtime\/stubRoutines.hpp\"\n+#include \"stubGenerator_x86_64.hpp\"\n+#ifdef COMPILER2\n+#include \"opto\/c2_globals.hpp\"\n+#endif\n+\n+#define __ _masm->\n+\n+#define TIMES_OOP (UseCompressedOops ? Address::times_4 : Address::times_8)\n+\n+#ifdef PRODUCT\n+#define BLOCK_COMMENT(str) \/* nothing *\/\n+#else\n+#define BLOCK_COMMENT(str) __ block_comment(str)\n+#endif \/\/ PRODUCT\n+\n+#define BIND(label) bind(label); BLOCK_COMMENT(#label \":\")\n+\n+#ifdef PRODUCT\n+#define INC_COUNTER_NP(counter, rscratch) ((void)0)\n+#else\n+#define INC_COUNTER_NP(counter, rscratch) \\\n+BLOCK_COMMENT(\"inc_counter \" #counter); \\\n+inc_counter_np(_masm, counter, rscratch);\n+\n+static void inc_counter_np(MacroAssembler* _masm, int& counter, Register rscratch) {\n+  __ incrementl(ExternalAddress((address)&counter), rscratch);\n+}\n+\n+#if COMPILER2_OR_JVMCI\n+static int& get_profile_ctr(int shift) {\n+  if (shift == 0) {\n+    return SharedRuntime::_jbyte_array_copy_ctr;\n+  } else if (shift == 1) {\n+    return SharedRuntime::_jshort_array_copy_ctr;\n+  } else if (shift == 2) {\n+    return SharedRuntime::_jint_array_copy_ctr;\n+  } else {\n+    assert(shift == 3, \"\");\n+    return SharedRuntime::_jlong_array_copy_ctr;\n+  }\n+}\n+#endif \/\/ COMPILER2_OR_JVMCI\n+#endif \/\/ !PRODUCT\n+\n+void StubGenerator::generate_arraycopy_stubs() {\n+  address entry;\n+  address entry_jbyte_arraycopy;\n+  address entry_jshort_arraycopy;\n+  address entry_jint_arraycopy;\n+  address entry_oop_arraycopy;\n+  address entry_jlong_arraycopy;\n+  address entry_checkcast_arraycopy;\n+\n+  StubRoutines::_jbyte_disjoint_arraycopy  = generate_disjoint_byte_copy(false, &entry,\n+                                                                         \"jbyte_disjoint_arraycopy\");\n+  StubRoutines::_jbyte_arraycopy           = generate_conjoint_byte_copy(false, entry, &entry_jbyte_arraycopy,\n+                                                                         \"jbyte_arraycopy\");\n+\n+  StubRoutines::_jshort_disjoint_arraycopy = generate_disjoint_short_copy(false, &entry,\n+                                                                          \"jshort_disjoint_arraycopy\");\n+  StubRoutines::_jshort_arraycopy          = generate_conjoint_short_copy(false, entry, &entry_jshort_arraycopy,\n+                                                                          \"jshort_arraycopy\");\n+\n+  StubRoutines::_jint_disjoint_arraycopy   = generate_disjoint_int_oop_copy(false, false, &entry,\n+                                                                            \"jint_disjoint_arraycopy\");\n+  StubRoutines::_jint_arraycopy            = generate_conjoint_int_oop_copy(false, false, entry,\n+                                                                            &entry_jint_arraycopy, \"jint_arraycopy\");\n+\n+  StubRoutines::_jlong_disjoint_arraycopy  = generate_disjoint_long_oop_copy(false, false, &entry,\n+                                                                             \"jlong_disjoint_arraycopy\");\n+  StubRoutines::_jlong_arraycopy           = generate_conjoint_long_oop_copy(false, false, entry,\n+                                                                             &entry_jlong_arraycopy, \"jlong_arraycopy\");\n+  if (UseCompressedOops) {\n+    StubRoutines::_oop_disjoint_arraycopy  = generate_disjoint_int_oop_copy(false, true, &entry,\n+                                                                            \"oop_disjoint_arraycopy\");\n+    StubRoutines::_oop_arraycopy           = generate_conjoint_int_oop_copy(false, true, entry,\n+                                                                            &entry_oop_arraycopy, \"oop_arraycopy\");\n+    StubRoutines::_oop_disjoint_arraycopy_uninit  = generate_disjoint_int_oop_copy(false, true, &entry,\n+                                                                                   \"oop_disjoint_arraycopy_uninit\",\n+                                                                                   \/*dest_uninitialized*\/true);\n+    StubRoutines::_oop_arraycopy_uninit           = generate_conjoint_int_oop_copy(false, true, entry,\n+                                                                                   NULL, \"oop_arraycopy_uninit\",\n+                                                                                   \/*dest_uninitialized*\/true);\n+  } else {\n+    StubRoutines::_oop_disjoint_arraycopy  = generate_disjoint_long_oop_copy(false, true, &entry,\n+                                                                             \"oop_disjoint_arraycopy\");\n+    StubRoutines::_oop_arraycopy           = generate_conjoint_long_oop_copy(false, true, entry,\n+                                                                             &entry_oop_arraycopy, \"oop_arraycopy\");\n+    StubRoutines::_oop_disjoint_arraycopy_uninit  = generate_disjoint_long_oop_copy(false, true, &entry,\n+                                                                                    \"oop_disjoint_arraycopy_uninit\",\n+                                                                                    \/*dest_uninitialized*\/true);\n+    StubRoutines::_oop_arraycopy_uninit           = generate_conjoint_long_oop_copy(false, true, entry,\n+                                                                                    NULL, \"oop_arraycopy_uninit\",\n+                                                                                    \/*dest_uninitialized*\/true);\n+  }\n+\n+  StubRoutines::_checkcast_arraycopy        = generate_checkcast_copy(\"checkcast_arraycopy\", &entry_checkcast_arraycopy);\n+  StubRoutines::_checkcast_arraycopy_uninit = generate_checkcast_copy(\"checkcast_arraycopy_uninit\", NULL,\n+                                                                      \/*dest_uninitialized*\/true);\n+\n+  StubRoutines::_unsafe_arraycopy    = generate_unsafe_copy(\"unsafe_arraycopy\",\n+                                                            entry_jbyte_arraycopy,\n+                                                            entry_jshort_arraycopy,\n+                                                            entry_jint_arraycopy,\n+                                                            entry_jlong_arraycopy);\n+  StubRoutines::_generic_arraycopy   = generate_generic_copy(\"generic_arraycopy\",\n+                                                             entry_jbyte_arraycopy,\n+                                                             entry_jshort_arraycopy,\n+                                                             entry_jint_arraycopy,\n+                                                             entry_oop_arraycopy,\n+                                                             entry_jlong_arraycopy,\n+                                                             entry_checkcast_arraycopy);\n+\n+  StubRoutines::_jbyte_fill = generate_fill(T_BYTE, false, \"jbyte_fill\");\n+  StubRoutines::_jshort_fill = generate_fill(T_SHORT, false, \"jshort_fill\");\n+  StubRoutines::_jint_fill = generate_fill(T_INT, false, \"jint_fill\");\n+  StubRoutines::_arrayof_jbyte_fill = generate_fill(T_BYTE, true, \"arrayof_jbyte_fill\");\n+  StubRoutines::_arrayof_jshort_fill = generate_fill(T_SHORT, true, \"arrayof_jshort_fill\");\n+  StubRoutines::_arrayof_jint_fill = generate_fill(T_INT, true, \"arrayof_jint_fill\");\n+\n+  \/\/ We don't generate specialized code for HeapWord-aligned source\n+  \/\/ arrays, so just use the code we've already generated\n+  StubRoutines::_arrayof_jbyte_disjoint_arraycopy  = StubRoutines::_jbyte_disjoint_arraycopy;\n+  StubRoutines::_arrayof_jbyte_arraycopy           = StubRoutines::_jbyte_arraycopy;\n+\n+  StubRoutines::_arrayof_jshort_disjoint_arraycopy = StubRoutines::_jshort_disjoint_arraycopy;\n+  StubRoutines::_arrayof_jshort_arraycopy          = StubRoutines::_jshort_arraycopy;\n+\n+  StubRoutines::_arrayof_jint_disjoint_arraycopy   = StubRoutines::_jint_disjoint_arraycopy;\n+  StubRoutines::_arrayof_jint_arraycopy            = StubRoutines::_jint_arraycopy;\n+\n+  StubRoutines::_arrayof_jlong_disjoint_arraycopy  = StubRoutines::_jlong_disjoint_arraycopy;\n+  StubRoutines::_arrayof_jlong_arraycopy           = StubRoutines::_jlong_arraycopy;\n+\n+  StubRoutines::_arrayof_oop_disjoint_arraycopy    = StubRoutines::_oop_disjoint_arraycopy;\n+  StubRoutines::_arrayof_oop_arraycopy             = StubRoutines::_oop_arraycopy;\n+\n+  StubRoutines::_arrayof_oop_disjoint_arraycopy_uninit    = StubRoutines::_oop_disjoint_arraycopy_uninit;\n+  StubRoutines::_arrayof_oop_arraycopy_uninit             = StubRoutines::_oop_arraycopy_uninit;\n+}\n+\n+\n+\/\/ Verify that a register contains clean 32-bits positive value\n+\/\/ (high 32-bits are 0) so it could be used in 64-bits shifts.\n+\/\/\n+\/\/  Input:\n+\/\/    Rint  -  32-bits value\n+\/\/    Rtmp  -  scratch\n+\/\/\n+void StubGenerator::assert_clean_int(Register Rint, Register Rtmp) {\n+#ifdef ASSERT\n+  Label L;\n+  assert_different_registers(Rtmp, Rint);\n+  __ movslq(Rtmp, Rint);\n+  __ cmpq(Rtmp, Rint);\n+  __ jcc(Assembler::equal, L);\n+  __ stop(\"high 32-bits of int value are not 0\");\n+  __ bind(L);\n+#endif\n+}\n+\n+\n+\/\/  Generate overlap test for array copy stubs\n+\/\/\n+\/\/  Input:\n+\/\/     c_rarg0 - from\n+\/\/     c_rarg1 - to\n+\/\/     c_rarg2 - element count\n+\/\/\n+\/\/  Output:\n+\/\/     rax   - &from[element count - 1]\n+\/\/\n+void StubGenerator::array_overlap_test(address no_overlap_target, Label* NOLp, Address::ScaleFactor sf) {\n+  const Register from     = c_rarg0;\n+  const Register to       = c_rarg1;\n+  const Register count    = c_rarg2;\n+  const Register end_from = rax;\n+\n+  __ cmpptr(to, from);\n+  __ lea(end_from, Address(from, count, sf, 0));\n+  if (NOLp == NULL) {\n+    ExternalAddress no_overlap(no_overlap_target);\n+    __ jump_cc(Assembler::belowEqual, no_overlap);\n+    __ cmpptr(to, end_from);\n+    __ jump_cc(Assembler::aboveEqual, no_overlap);\n+  } else {\n+    __ jcc(Assembler::belowEqual, (*NOLp));\n+    __ cmpptr(to, end_from);\n+    __ jcc(Assembler::aboveEqual, (*NOLp));\n+  }\n+}\n+\n+\n+\/\/ Copy big chunks forward\n+\/\/\n+\/\/ Inputs:\n+\/\/   end_from     - source arrays end address\n+\/\/   end_to       - destination array end address\n+\/\/   qword_count  - 64-bits element count, negative\n+\/\/   to           - scratch\n+\/\/   L_copy_bytes - entry label\n+\/\/   L_copy_8_bytes  - exit  label\n+\/\/\n+void StubGenerator::copy_bytes_forward(Register end_from, Register end_to,\n+                                       Register qword_count, Register to,\n+                                       Label& L_copy_bytes, Label& L_copy_8_bytes) {\n+  DEBUG_ONLY(__ stop(\"enter at entry label, not here\"));\n+  Label L_loop;\n+  __ align(OptoLoopAlignment);\n+  if (UseUnalignedLoadStores) {\n+    Label L_end;\n+    __ BIND(L_loop);\n+    if (UseAVX >= 2) {\n+      __ vmovdqu(xmm0, Address(end_from, qword_count, Address::times_8, -56));\n+      __ vmovdqu(Address(end_to, qword_count, Address::times_8, -56), xmm0);\n+      __ vmovdqu(xmm1, Address(end_from, qword_count, Address::times_8, -24));\n+      __ vmovdqu(Address(end_to, qword_count, Address::times_8, -24), xmm1);\n+    } else {\n+      __ movdqu(xmm0, Address(end_from, qword_count, Address::times_8, -56));\n+      __ movdqu(Address(end_to, qword_count, Address::times_8, -56), xmm0);\n+      __ movdqu(xmm1, Address(end_from, qword_count, Address::times_8, -40));\n+      __ movdqu(Address(end_to, qword_count, Address::times_8, -40), xmm1);\n+      __ movdqu(xmm2, Address(end_from, qword_count, Address::times_8, -24));\n+      __ movdqu(Address(end_to, qword_count, Address::times_8, -24), xmm2);\n+      __ movdqu(xmm3, Address(end_from, qword_count, Address::times_8, - 8));\n+      __ movdqu(Address(end_to, qword_count, Address::times_8, - 8), xmm3);\n+    }\n+\n+    __ BIND(L_copy_bytes);\n+    __ addptr(qword_count, 8);\n+    __ jcc(Assembler::lessEqual, L_loop);\n+    __ subptr(qword_count, 4);  \/\/ sub(8) and add(4)\n+    __ jccb(Assembler::greater, L_end);\n+    \/\/ Copy trailing 32 bytes\n+    if (UseAVX >= 2) {\n+      __ vmovdqu(xmm0, Address(end_from, qword_count, Address::times_8, -24));\n+      __ vmovdqu(Address(end_to, qword_count, Address::times_8, -24), xmm0);\n+    } else {\n+      __ movdqu(xmm0, Address(end_from, qword_count, Address::times_8, -24));\n+      __ movdqu(Address(end_to, qword_count, Address::times_8, -24), xmm0);\n+      __ movdqu(xmm1, Address(end_from, qword_count, Address::times_8, - 8));\n+      __ movdqu(Address(end_to, qword_count, Address::times_8, - 8), xmm1);\n+    }\n+    __ addptr(qword_count, 4);\n+    __ BIND(L_end);\n+  } else {\n+    \/\/ Copy 32-bytes per iteration\n+    __ BIND(L_loop);\n+    __ movq(to, Address(end_from, qword_count, Address::times_8, -24));\n+    __ movq(Address(end_to, qword_count, Address::times_8, -24), to);\n+    __ movq(to, Address(end_from, qword_count, Address::times_8, -16));\n+    __ movq(Address(end_to, qword_count, Address::times_8, -16), to);\n+    __ movq(to, Address(end_from, qword_count, Address::times_8, - 8));\n+    __ movq(Address(end_to, qword_count, Address::times_8, - 8), to);\n+    __ movq(to, Address(end_from, qword_count, Address::times_8, - 0));\n+    __ movq(Address(end_to, qword_count, Address::times_8, - 0), to);\n+\n+    __ BIND(L_copy_bytes);\n+    __ addptr(qword_count, 4);\n+    __ jcc(Assembler::lessEqual, L_loop);\n+  }\n+  __ subptr(qword_count, 4);\n+  __ jcc(Assembler::less, L_copy_8_bytes); \/\/ Copy trailing qwords\n+}\n+\n+\n+\/\/ Copy big chunks backward\n+\/\/\n+\/\/ Inputs:\n+\/\/   from         - source arrays address\n+\/\/   dest         - destination array address\n+\/\/   qword_count  - 64-bits element count\n+\/\/   to           - scratch\n+\/\/   L_copy_bytes - entry label\n+\/\/   L_copy_8_bytes  - exit  label\n+\/\/\n+void StubGenerator::copy_bytes_backward(Register from, Register dest,\n+                                        Register qword_count, Register to,\n+                                        Label& L_copy_bytes, Label& L_copy_8_bytes) {\n+  DEBUG_ONLY(__ stop(\"enter at entry label, not here\"));\n+  Label L_loop;\n+  __ align(OptoLoopAlignment);\n+  if (UseUnalignedLoadStores) {\n+    Label L_end;\n+    __ BIND(L_loop);\n+    if (UseAVX >= 2) {\n+      __ vmovdqu(xmm0, Address(from, qword_count, Address::times_8, 32));\n+      __ vmovdqu(Address(dest, qword_count, Address::times_8, 32), xmm0);\n+      __ vmovdqu(xmm1, Address(from, qword_count, Address::times_8,  0));\n+      __ vmovdqu(Address(dest, qword_count, Address::times_8,  0), xmm1);\n+    } else {\n+      __ movdqu(xmm0, Address(from, qword_count, Address::times_8, 48));\n+      __ movdqu(Address(dest, qword_count, Address::times_8, 48), xmm0);\n+      __ movdqu(xmm1, Address(from, qword_count, Address::times_8, 32));\n+      __ movdqu(Address(dest, qword_count, Address::times_8, 32), xmm1);\n+      __ movdqu(xmm2, Address(from, qword_count, Address::times_8, 16));\n+      __ movdqu(Address(dest, qword_count, Address::times_8, 16), xmm2);\n+      __ movdqu(xmm3, Address(from, qword_count, Address::times_8,  0));\n+      __ movdqu(Address(dest, qword_count, Address::times_8,  0), xmm3);\n+    }\n+\n+    __ BIND(L_copy_bytes);\n+    __ subptr(qword_count, 8);\n+    __ jcc(Assembler::greaterEqual, L_loop);\n+\n+    __ addptr(qword_count, 4);  \/\/ add(8) and sub(4)\n+    __ jccb(Assembler::less, L_end);\n+    \/\/ Copy trailing 32 bytes\n+    if (UseAVX >= 2) {\n+      __ vmovdqu(xmm0, Address(from, qword_count, Address::times_8, 0));\n+      __ vmovdqu(Address(dest, qword_count, Address::times_8, 0), xmm0);\n+    } else {\n+      __ movdqu(xmm0, Address(from, qword_count, Address::times_8, 16));\n+      __ movdqu(Address(dest, qword_count, Address::times_8, 16), xmm0);\n+      __ movdqu(xmm1, Address(from, qword_count, Address::times_8,  0));\n+      __ movdqu(Address(dest, qword_count, Address::times_8,  0), xmm1);\n+    }\n+    __ subptr(qword_count, 4);\n+    __ BIND(L_end);\n+  } else {\n+    \/\/ Copy 32-bytes per iteration\n+    __ BIND(L_loop);\n+    __ movq(to, Address(from, qword_count, Address::times_8, 24));\n+    __ movq(Address(dest, qword_count, Address::times_8, 24), to);\n+    __ movq(to, Address(from, qword_count, Address::times_8, 16));\n+    __ movq(Address(dest, qword_count, Address::times_8, 16), to);\n+    __ movq(to, Address(from, qword_count, Address::times_8,  8));\n+    __ movq(Address(dest, qword_count, Address::times_8,  8), to);\n+    __ movq(to, Address(from, qword_count, Address::times_8,  0));\n+    __ movq(Address(dest, qword_count, Address::times_8,  0), to);\n+\n+    __ BIND(L_copy_bytes);\n+    __ subptr(qword_count, 4);\n+    __ jcc(Assembler::greaterEqual, L_loop);\n+  }\n+  __ addptr(qword_count, 4);\n+  __ jcc(Assembler::greater, L_copy_8_bytes); \/\/ Copy trailing qwords\n+}\n+\n+#if COMPILER2_OR_JVMCI\n+\n+\/\/ Note: Following rules apply to AVX3 optimized arraycopy stubs:-\n+\/\/ - If target supports AVX3 features (BW+VL+F) then implementation uses 32 byte vectors (YMMs)\n+\/\/   for both special cases (various small block sizes) and aligned copy loop. This is the\n+\/\/   default configuration.\n+\/\/ - If copy length is above AVX3Threshold, then implementation use 64 byte vectors (ZMMs)\n+\/\/   for main copy loop (and subsequent tail) since bulk of the cycles will be consumed in it.\n+\/\/ - If user forces MaxVectorSize=32 then above 4096 bytes its seen that REP MOVs shows a\n+\/\/   better performance for disjoint copies. For conjoint\/backward copy vector based\n+\/\/   copy performs better.\n+\/\/ - If user sets AVX3Threshold=0, then special cases for small blocks sizes operate over\n+\/\/   64 byte vector registers (ZMMs).\n+\n+\/\/ Inputs:\n+\/\/   c_rarg0   - source array address\n+\/\/   c_rarg1   - destination array address\n+\/\/   c_rarg2   - element count, treated as ssize_t, can be zero\n+\/\/\n+\/\/\n+\/\/ Side Effects:\n+\/\/   disjoint_copy_avx3_masked is set to the no-overlap entry point\n+\/\/   used by generate_conjoint_[byte\/int\/short\/long]_copy().\n+\/\/\n+address StubGenerator::generate_disjoint_copy_avx3_masked(address* entry, const char *name,\n+                                                          int shift, bool aligned, bool is_oop,\n+                                                          bool dest_uninitialized) {\n+  __ align(CodeEntryAlignment);\n+  StubCodeMark mark(this, \"StubRoutines\", name);\n+  address start = __ pc();\n+\n+  int avx3threshold = VM_Version::avx3_threshold();\n+  bool use64byteVector = (MaxVectorSize > 32) && (avx3threshold == 0);\n+  Label L_main_loop, L_main_loop_64bytes, L_tail, L_tail64, L_exit, L_entry;\n+  Label L_repmovs, L_main_pre_loop, L_main_pre_loop_64bytes, L_pre_main_post_64;\n+  const Register from        = rdi;  \/\/ source array address\n+  const Register to          = rsi;  \/\/ destination array address\n+  const Register count       = rdx;  \/\/ elements count\n+  const Register temp1       = r8;\n+  const Register temp2       = r11;\n+  const Register temp3       = rax;\n+  const Register temp4       = rcx;\n+  \/\/ End pointers are inclusive, and if count is not zero they point\n+  \/\/ to the last unit copied:  end_to[0] := end_from[0]\n+\n+  __ enter(); \/\/ required for proper stackwalking of RuntimeStub frame\n+  assert_clean_int(c_rarg2, rax);    \/\/ Make sure 'count' is clean int.\n+\n+  if (entry != NULL) {\n+    *entry = __ pc();\n+     \/\/ caller can pass a 64-bit byte count here (from Unsafe.copyMemory)\n+    BLOCK_COMMENT(\"Entry:\");\n+  }\n+\n+  BasicType type_vec[] = { T_BYTE,  T_SHORT,  T_INT,   T_LONG};\n+  BasicType type = is_oop ? T_OBJECT : type_vec[shift];\n+\n+  setup_argument_regs(type);\n+\n+  DecoratorSet decorators = IN_HEAP | IS_ARRAY | ARRAYCOPY_DISJOINT;\n+  if (dest_uninitialized) {\n+    decorators |= IS_DEST_UNINITIALIZED;\n+  }\n+  if (aligned) {\n+    decorators |= ARRAYCOPY_ALIGNED;\n+  }\n+  BarrierSetAssembler *bs = BarrierSet::barrier_set()->barrier_set_assembler();\n+  bs->arraycopy_prologue(_masm, decorators, type, from, to, count);\n+\n+  {\n+    \/\/ Type(shift)           byte(0), short(1), int(2),   long(3)\n+    int loop_size[]        = { 192,     96,       48,      24};\n+    int threshold[]        = { 4096,    2048,     1024,    512};\n+\n+    \/\/ UnsafeCopyMemory page error: continue after ucm\n+    UnsafeCopyMemoryMark ucmm(this, !is_oop && !aligned, true);\n+    \/\/ 'from', 'to' and 'count' are now valid\n+\n+    \/\/ temp1 holds remaining count and temp4 holds running count used to compute\n+    \/\/ next address offset for start of to\/from addresses (temp4 * scale).\n+    __ mov64(temp4, 0);\n+    __ movq(temp1, count);\n+\n+    \/\/ Zero length check.\n+    __ BIND(L_tail);\n+    __ cmpq(temp1, 0);\n+    __ jcc(Assembler::lessEqual, L_exit);\n+\n+    \/\/ Special cases using 32 byte [masked] vector copy operations.\n+    arraycopy_avx3_special_cases(xmm1, k2, from, to, temp1, shift,\n+                                 temp4, temp3, use64byteVector, L_entry, L_exit);\n+\n+    \/\/ PRE-MAIN-POST loop for aligned copy.\n+    __ BIND(L_entry);\n+\n+    if (avx3threshold != 0) {\n+      __ cmpq(count, threshold[shift]);\n+      if (MaxVectorSize == 64) {\n+        \/\/ Copy using 64 byte vectors.\n+        __ jcc(Assembler::greaterEqual, L_pre_main_post_64);\n+      } else {\n+        assert(MaxVectorSize < 64, \"vector size should be < 64 bytes\");\n+        \/\/ REP MOVS offer a faster copy path.\n+        __ jcc(Assembler::greaterEqual, L_repmovs);\n+      }\n+    }\n+\n+    if ((MaxVectorSize < 64)  || (avx3threshold != 0)) {\n+      \/\/ Partial copy to make dst address 32 byte aligned.\n+      __ movq(temp2, to);\n+      __ andq(temp2, 31);\n+      __ jcc(Assembler::equal, L_main_pre_loop);\n+\n+      __ negptr(temp2);\n+      __ addq(temp2, 32);\n+      if (shift) {\n+        __ shrq(temp2, shift);\n+      }\n+      __ movq(temp3, temp2);\n+      copy32_masked_avx(to, from, xmm1, k2, temp3, temp4, temp1, shift);\n+      __ movq(temp4, temp2);\n+      __ movq(temp1, count);\n+      __ subq(temp1, temp2);\n+\n+      __ cmpq(temp1, loop_size[shift]);\n+      __ jcc(Assembler::less, L_tail);\n+\n+      __ BIND(L_main_pre_loop);\n+      __ subq(temp1, loop_size[shift]);\n+\n+      \/\/ Main loop with aligned copy block size of 192 bytes at 32 byte granularity.\n+      __ align32();\n+      __ BIND(L_main_loop);\n+         copy64_avx(to, from, temp4, xmm1, false, shift, 0);\n+         copy64_avx(to, from, temp4, xmm1, false, shift, 64);\n+         copy64_avx(to, from, temp4, xmm1, false, shift, 128);\n+         __ addptr(temp4, loop_size[shift]);\n+         __ subq(temp1, loop_size[shift]);\n+         __ jcc(Assembler::greater, L_main_loop);\n+\n+      __ addq(temp1, loop_size[shift]);\n+\n+      \/\/ Tail loop.\n+      __ jmp(L_tail);\n+\n+      __ BIND(L_repmovs);\n+        __ movq(temp2, temp1);\n+        \/\/ Swap to(RSI) and from(RDI) addresses to comply with REP MOVs semantics.\n+        __ movq(temp3, to);\n+        __ movq(to,  from);\n+        __ movq(from, temp3);\n+        \/\/ Save to\/from for restoration post rep_mov.\n+        __ movq(temp1, to);\n+        __ movq(temp3, from);\n+        if(shift < 3) {\n+          __ shrq(temp2, 3-shift);     \/\/ quad word count\n+        }\n+        __ movq(temp4 , temp2);        \/\/ move quad ward count into temp4(RCX).\n+        __ rep_mov();\n+        __ shlq(temp2, 3);             \/\/ convert quad words into byte count.\n+        if(shift) {\n+          __ shrq(temp2, shift);       \/\/ type specific count.\n+        }\n+        \/\/ Restore original addresses in to\/from.\n+        __ movq(to, temp3);\n+        __ movq(from, temp1);\n+        __ movq(temp4, temp2);\n+        __ movq(temp1, count);\n+        __ subq(temp1, temp2);         \/\/ tailing part (less than a quad ward size).\n+        __ jmp(L_tail);\n+    }\n+\n+    if (MaxVectorSize > 32) {\n+      __ BIND(L_pre_main_post_64);\n+      \/\/ Partial copy to make dst address 64 byte aligned.\n+      __ movq(temp2, to);\n+      __ andq(temp2, 63);\n+      __ jcc(Assembler::equal, L_main_pre_loop_64bytes);\n+\n+      __ negptr(temp2);\n+      __ addq(temp2, 64);\n+      if (shift) {\n+        __ shrq(temp2, shift);\n+      }\n+      __ movq(temp3, temp2);\n+      copy64_masked_avx(to, from, xmm1, k2, temp3, temp4, temp1, shift, 0 , true);\n+      __ movq(temp4, temp2);\n+      __ movq(temp1, count);\n+      __ subq(temp1, temp2);\n+\n+      __ cmpq(temp1, loop_size[shift]);\n+      __ jcc(Assembler::less, L_tail64);\n+\n+      __ BIND(L_main_pre_loop_64bytes);\n+      __ subq(temp1, loop_size[shift]);\n+\n+      \/\/ Main loop with aligned copy block size of 192 bytes at\n+      \/\/ 64 byte copy granularity.\n+      __ align32();\n+      __ BIND(L_main_loop_64bytes);\n+         copy64_avx(to, from, temp4, xmm1, false, shift, 0 , true);\n+         copy64_avx(to, from, temp4, xmm1, false, shift, 64, true);\n+         copy64_avx(to, from, temp4, xmm1, false, shift, 128, true);\n+         __ addptr(temp4, loop_size[shift]);\n+         __ subq(temp1, loop_size[shift]);\n+         __ jcc(Assembler::greater, L_main_loop_64bytes);\n+\n+      __ addq(temp1, loop_size[shift]);\n+      \/\/ Zero length check.\n+      __ jcc(Assembler::lessEqual, L_exit);\n+\n+      __ BIND(L_tail64);\n+\n+      \/\/ Tail handling using 64 byte [masked] vector copy operations.\n+      use64byteVector = true;\n+      arraycopy_avx3_special_cases(xmm1, k2, from, to, temp1, shift,\n+                                   temp4, temp3, use64byteVector, L_entry, L_exit);\n+    }\n+    __ BIND(L_exit);\n+  }\n+\n+  address ucme_exit_pc = __ pc();\n+  \/\/ When called from generic_arraycopy r11 contains specific values\n+  \/\/ used during arraycopy epilogue, re-initializing r11.\n+  if (is_oop) {\n+    __ movq(r11, shift == 3 ? count : to);\n+  }\n+  bs->arraycopy_epilogue(_masm, decorators, type, from, to, count);\n+  restore_argument_regs(type);\n+  INC_COUNTER_NP(get_profile_ctr(shift), rscratch1); \/\/ Update counter after rscratch1 is free\n+  __ xorptr(rax, rax); \/\/ return 0\n+  __ vzeroupper();\n+  __ leave(); \/\/ required for proper stackwalking of RuntimeStub frame\n+  __ ret(0);\n+\n+  return start;\n+}\n+\n+\n+\/\/ Inputs:\n+\/\/   c_rarg0   - source array address\n+\/\/   c_rarg1   - destination array address\n+\/\/   c_rarg2   - element count, treated as ssize_t, can be zero\n+\/\/\n+\/\/\n+address StubGenerator::generate_conjoint_copy_avx3_masked(address* entry, const char *name, int shift,\n+                                                          address nooverlap_target, bool aligned,\n+                                                          bool is_oop, bool dest_uninitialized) {\n+  __ align(CodeEntryAlignment);\n+  StubCodeMark mark(this, \"StubRoutines\", name);\n+  address start = __ pc();\n+\n+  int avx3threshold = VM_Version::avx3_threshold();\n+  bool use64byteVector = (MaxVectorSize > 32) && (avx3threshold == 0);\n+\n+  Label L_main_pre_loop, L_main_pre_loop_64bytes, L_pre_main_post_64;\n+  Label L_main_loop, L_main_loop_64bytes, L_tail, L_tail64, L_exit, L_entry;\n+  const Register from        = rdi;  \/\/ source array address\n+  const Register to          = rsi;  \/\/ destination array address\n+  const Register count       = rdx;  \/\/ elements count\n+  const Register temp1       = r8;\n+  const Register temp2       = rcx;\n+  const Register temp3       = r11;\n+  const Register temp4       = rax;\n+  \/\/ End pointers are inclusive, and if count is not zero they point\n+  \/\/ to the last unit copied:  end_to[0] := end_from[0]\n+\n+  __ enter(); \/\/ required for proper stackwalking of RuntimeStub frame\n+  assert_clean_int(c_rarg2, rax);    \/\/ Make sure 'count' is clean int.\n+\n+  if (entry != NULL) {\n+    *entry = __ pc();\n+     \/\/ caller can pass a 64-bit byte count here (from Unsafe.copyMemory)\n+    BLOCK_COMMENT(\"Entry:\");\n+  }\n+\n+  array_overlap_test(nooverlap_target, (Address::ScaleFactor)(shift));\n+\n+  BasicType type_vec[] = { T_BYTE,  T_SHORT,  T_INT,   T_LONG};\n+  BasicType type = is_oop ? T_OBJECT : type_vec[shift];\n+\n+  setup_argument_regs(type);\n+\n+  DecoratorSet decorators = IN_HEAP | IS_ARRAY;\n+  if (dest_uninitialized) {\n+    decorators |= IS_DEST_UNINITIALIZED;\n+  }\n+  if (aligned) {\n+    decorators |= ARRAYCOPY_ALIGNED;\n+  }\n+  BarrierSetAssembler *bs = BarrierSet::barrier_set()->barrier_set_assembler();\n+  bs->arraycopy_prologue(_masm, decorators, type, from, to, count);\n+  {\n+    \/\/ Type(shift)       byte(0), short(1), int(2),   long(3)\n+    int loop_size[]   = { 192,     96,       48,      24};\n+    int threshold[]   = { 4096,    2048,     1024,    512};\n+\n+    \/\/ UnsafeCopyMemory page error: continue after ucm\n+    UnsafeCopyMemoryMark ucmm(this, !is_oop && !aligned, true);\n+    \/\/ 'from', 'to' and 'count' are now valid\n+\n+    \/\/ temp1 holds remaining count.\n+    __ movq(temp1, count);\n+\n+    \/\/ Zero length check.\n+    __ BIND(L_tail);\n+    __ cmpq(temp1, 0);\n+    __ jcc(Assembler::lessEqual, L_exit);\n+\n+    __ mov64(temp2, 0);\n+    __ movq(temp3, temp1);\n+    \/\/ Special cases using 32 byte [masked] vector copy operations.\n+    arraycopy_avx3_special_cases_conjoint(xmm1, k2, from, to, temp2, temp3, temp1, shift,\n+                                          temp4, use64byteVector, L_entry, L_exit);\n+\n+    \/\/ PRE-MAIN-POST loop for aligned copy.\n+    __ BIND(L_entry);\n+\n+    if ((MaxVectorSize > 32) && (avx3threshold != 0)) {\n+      __ cmpq(temp1, threshold[shift]);\n+      __ jcc(Assembler::greaterEqual, L_pre_main_post_64);\n+    }\n+\n+    if ((MaxVectorSize < 64)  || (avx3threshold != 0)) {\n+      \/\/ Partial copy to make dst address 32 byte aligned.\n+      __ leaq(temp2, Address(to, temp1, (Address::ScaleFactor)(shift), 0));\n+      __ andq(temp2, 31);\n+      __ jcc(Assembler::equal, L_main_pre_loop);\n+\n+      if (shift) {\n+        __ shrq(temp2, shift);\n+      }\n+      __ subq(temp1, temp2);\n+      copy32_masked_avx(to, from, xmm1, k2, temp2, temp1, temp3, shift);\n+\n+      __ cmpq(temp1, loop_size[shift]);\n+      __ jcc(Assembler::less, L_tail);\n+\n+      __ BIND(L_main_pre_loop);\n+\n+      \/\/ Main loop with aligned copy block size of 192 bytes at 32 byte granularity.\n+      __ align32();\n+      __ BIND(L_main_loop);\n+         copy64_avx(to, from, temp1, xmm1, true, shift, -64);\n+         copy64_avx(to, from, temp1, xmm1, true, shift, -128);\n+         copy64_avx(to, from, temp1, xmm1, true, shift, -192);\n+         __ subptr(temp1, loop_size[shift]);\n+         __ cmpq(temp1, loop_size[shift]);\n+         __ jcc(Assembler::greater, L_main_loop);\n+\n+      \/\/ Tail loop.\n+      __ jmp(L_tail);\n+    }\n+\n+    if (MaxVectorSize > 32) {\n+      __ BIND(L_pre_main_post_64);\n+      \/\/ Partial copy to make dst address 64 byte aligned.\n+      __ leaq(temp2, Address(to, temp1, (Address::ScaleFactor)(shift), 0));\n+      __ andq(temp2, 63);\n+      __ jcc(Assembler::equal, L_main_pre_loop_64bytes);\n+\n+      if (shift) {\n+        __ shrq(temp2, shift);\n+      }\n+      __ subq(temp1, temp2);\n+      copy64_masked_avx(to, from, xmm1, k2, temp2, temp1, temp3, shift, 0 , true);\n+\n+      __ cmpq(temp1, loop_size[shift]);\n+      __ jcc(Assembler::less, L_tail64);\n+\n+      __ BIND(L_main_pre_loop_64bytes);\n+\n+      \/\/ Main loop with aligned copy block size of 192 bytes at\n+      \/\/ 64 byte copy granularity.\n+      __ align32();\n+      __ BIND(L_main_loop_64bytes);\n+         copy64_avx(to, from, temp1, xmm1, true, shift, -64 , true);\n+         copy64_avx(to, from, temp1, xmm1, true, shift, -128, true);\n+         copy64_avx(to, from, temp1, xmm1, true, shift, -192, true);\n+         __ subq(temp1, loop_size[shift]);\n+         __ cmpq(temp1, loop_size[shift]);\n+         __ jcc(Assembler::greater, L_main_loop_64bytes);\n+\n+      \/\/ Zero length check.\n+      __ cmpq(temp1, 0);\n+      __ jcc(Assembler::lessEqual, L_exit);\n+\n+      __ BIND(L_tail64);\n+\n+      \/\/ Tail handling using 64 byte [masked] vector copy operations.\n+      use64byteVector = true;\n+      __ mov64(temp2, 0);\n+      __ movq(temp3, temp1);\n+      arraycopy_avx3_special_cases_conjoint(xmm1, k2, from, to, temp2, temp3, temp1, shift,\n+                                            temp4, use64byteVector, L_entry, L_exit);\n+    }\n+    __ BIND(L_exit);\n+  }\n+  address ucme_exit_pc = __ pc();\n+  \/\/ When called from generic_arraycopy r11 contains specific values\n+  \/\/ used during arraycopy epilogue, re-initializing r11.\n+  if(is_oop) {\n+    __ movq(r11, count);\n+  }\n+  bs->arraycopy_epilogue(_masm, decorators, type, from, to, count);\n+  restore_argument_regs(type);\n+  INC_COUNTER_NP(get_profile_ctr(shift), rscratch1); \/\/ Update counter after rscratch1 is free\n+  __ xorptr(rax, rax); \/\/ return 0\n+  __ vzeroupper();\n+  __ leave(); \/\/ required for proper stackwalking of RuntimeStub frame\n+  __ ret(0);\n+\n+  return start;\n+}\n+\n+void StubGenerator::arraycopy_avx3_special_cases(XMMRegister xmm, KRegister mask, Register from,\n+                                                 Register to, Register count, int shift,\n+                                                 Register index, Register temp,\n+                                                 bool use64byteVector, Label& L_entry, Label& L_exit) {\n+  Label L_entry_64, L_entry_96, L_entry_128;\n+  Label L_entry_160, L_entry_192;\n+\n+  int size_mat[][6] = {\n+  \/* T_BYTE *\/ {32 , 64,  96 , 128 , 160 , 192 },\n+  \/* T_SHORT*\/ {16 , 32,  48 , 64  , 80  , 96  },\n+  \/* T_INT  *\/ {8  , 16,  24 , 32  , 40  , 48  },\n+  \/* T_LONG *\/ {4  ,  8,  12 , 16  , 20  , 24  }\n+  };\n+\n+  \/\/ Case A) Special case for length less than equal to 32 bytes.\n+  __ cmpq(count, size_mat[shift][0]);\n+  __ jccb(Assembler::greater, L_entry_64);\n+  copy32_masked_avx(to, from, xmm, mask, count, index, temp, shift);\n+  __ jmp(L_exit);\n+\n+  \/\/ Case B) Special case for length less than equal to 64 bytes.\n+  __ BIND(L_entry_64);\n+  __ cmpq(count, size_mat[shift][1]);\n+  __ jccb(Assembler::greater, L_entry_96);\n+  copy64_masked_avx(to, from, xmm, mask, count, index, temp, shift, 0, use64byteVector);\n+  __ jmp(L_exit);\n+\n+  \/\/ Case C) Special case for length less than equal to 96 bytes.\n+  __ BIND(L_entry_96);\n+  __ cmpq(count, size_mat[shift][2]);\n+  __ jccb(Assembler::greater, L_entry_128);\n+  copy64_avx(to, from, index, xmm, false, shift, 0, use64byteVector);\n+  __ subq(count, 64 >> shift);\n+  copy32_masked_avx(to, from, xmm, mask, count, index, temp, shift, 64);\n+  __ jmp(L_exit);\n+\n+  \/\/ Case D) Special case for length less than equal to 128 bytes.\n+  __ BIND(L_entry_128);\n+  __ cmpq(count, size_mat[shift][3]);\n+  __ jccb(Assembler::greater, L_entry_160);\n+  copy64_avx(to, from, index, xmm, false, shift, 0, use64byteVector);\n+  copy32_avx(to, from, index, xmm, shift, 64);\n+  __ subq(count, 96 >> shift);\n+  copy32_masked_avx(to, from, xmm, mask, count, index, temp, shift, 96);\n+  __ jmp(L_exit);\n+\n+  \/\/ Case E) Special case for length less than equal to 160 bytes.\n+  __ BIND(L_entry_160);\n+  __ cmpq(count, size_mat[shift][4]);\n+  __ jccb(Assembler::greater, L_entry_192);\n+  copy64_avx(to, from, index, xmm, false, shift, 0, use64byteVector);\n+  copy64_avx(to, from, index, xmm, false, shift, 64, use64byteVector);\n+  __ subq(count, 128 >> shift);\n+  copy32_masked_avx(to, from, xmm, mask, count, index, temp, shift, 128);\n+  __ jmp(L_exit);\n+\n+  \/\/ Case F) Special case for length less than equal to 192 bytes.\n+  __ BIND(L_entry_192);\n+  __ cmpq(count, size_mat[shift][5]);\n+  __ jcc(Assembler::greater, L_entry);\n+  copy64_avx(to, from, index, xmm, false, shift, 0, use64byteVector);\n+  copy64_avx(to, from, index, xmm, false, shift, 64, use64byteVector);\n+  copy32_avx(to, from, index, xmm, shift, 128);\n+  __ subq(count, 160 >> shift);\n+  copy32_masked_avx(to, from, xmm, mask, count, index, temp, shift, 160);\n+  __ jmp(L_exit);\n+}\n+\n+void StubGenerator::arraycopy_avx3_special_cases_conjoint(XMMRegister xmm, KRegister mask, Register from,\n+                                                           Register to, Register start_index, Register end_index,\n+                                                           Register count, int shift, Register temp,\n+                                                           bool use64byteVector, Label& L_entry, Label& L_exit) {\n+  Label L_entry_64, L_entry_96, L_entry_128;\n+  Label L_entry_160, L_entry_192;\n+  bool avx3 = (MaxVectorSize > 32) && (VM_Version::avx3_threshold() == 0);\n+\n+  int size_mat[][6] = {\n+  \/* T_BYTE *\/ {32 , 64,  96 , 128 , 160 , 192 },\n+  \/* T_SHORT*\/ {16 , 32,  48 , 64  , 80  , 96  },\n+  \/* T_INT  *\/ {8  , 16,  24 , 32  , 40  , 48  },\n+  \/* T_LONG *\/ {4  ,  8,  12 , 16  , 20  , 24  }\n+  };\n+\n+  \/\/ Case A) Special case for length less than equal to 32 bytes.\n+  __ cmpq(count, size_mat[shift][0]);\n+  __ jccb(Assembler::greater, L_entry_64);\n+  copy32_masked_avx(to, from, xmm, mask, count, start_index, temp, shift);\n+  __ jmp(L_exit);\n+\n+  \/\/ Case B) Special case for length less than equal to 64 bytes.\n+  __ BIND(L_entry_64);\n+  __ cmpq(count, size_mat[shift][1]);\n+  __ jccb(Assembler::greater, L_entry_96);\n+  if (avx3) {\n+     copy64_masked_avx(to, from, xmm, mask, count, start_index, temp, shift, 0, true);\n+  } else {\n+     copy32_avx(to, from, end_index, xmm, shift, -32);\n+     __ subq(count, 32 >> shift);\n+     copy32_masked_avx(to, from, xmm, mask, count, start_index, temp, shift);\n+  }\n+  __ jmp(L_exit);\n+\n+  \/\/ Case C) Special case for length less than equal to 96 bytes.\n+  __ BIND(L_entry_96);\n+  __ cmpq(count, size_mat[shift][2]);\n+  __ jccb(Assembler::greater, L_entry_128);\n+  copy64_avx(to, from, end_index, xmm, true, shift, -64, use64byteVector);\n+  __ subq(count, 64 >> shift);\n+  copy32_masked_avx(to, from, xmm, mask, count, start_index, temp, shift);\n+  __ jmp(L_exit);\n+\n+  \/\/ Case D) Special case for length less than equal to 128 bytes.\n+  __ BIND(L_entry_128);\n+  __ cmpq(count, size_mat[shift][3]);\n+  __ jccb(Assembler::greater, L_entry_160);\n+  copy64_avx(to, from, end_index, xmm, true, shift, -64, use64byteVector);\n+  copy32_avx(to, from, end_index, xmm, shift, -96);\n+  __ subq(count, 96 >> shift);\n+  copy32_masked_avx(to, from, xmm, mask, count, start_index, temp, shift);\n+  __ jmp(L_exit);\n+\n+  \/\/ Case E) Special case for length less than equal to 160 bytes.\n+  __ BIND(L_entry_160);\n+  __ cmpq(count, size_mat[shift][4]);\n+  __ jccb(Assembler::greater, L_entry_192);\n+  copy64_avx(to, from, end_index, xmm, true, shift, -64, use64byteVector);\n+  copy64_avx(to, from, end_index, xmm, true, shift, -128, use64byteVector);\n+  __ subq(count, 128 >> shift);\n+  copy32_masked_avx(to, from, xmm, mask, count, start_index, temp, shift);\n+  __ jmp(L_exit);\n+\n+  \/\/ Case F) Special case for length less than equal to 192 bytes.\n+  __ BIND(L_entry_192);\n+  __ cmpq(count, size_mat[shift][5]);\n+  __ jcc(Assembler::greater, L_entry);\n+  copy64_avx(to, from, end_index, xmm, true, shift, -64, use64byteVector);\n+  copy64_avx(to, from, end_index, xmm, true, shift, -128, use64byteVector);\n+  copy32_avx(to, from, end_index, xmm, shift, -160);\n+  __ subq(count, 160 >> shift);\n+  copy32_masked_avx(to, from, xmm, mask, count, start_index, temp, shift);\n+  __ jmp(L_exit);\n+}\n+\n+void StubGenerator::copy64_masked_avx(Register dst, Register src, XMMRegister xmm,\n+                                       KRegister mask, Register length, Register index,\n+                                       Register temp, int shift, int offset,\n+                                       bool use64byteVector) {\n+  BasicType type[] = { T_BYTE,  T_SHORT,  T_INT,   T_LONG};\n+  assert(MaxVectorSize >= 32, \"vector length should be >= 32\");\n+  if (!use64byteVector) {\n+    copy32_avx(dst, src, index, xmm, shift, offset);\n+    __ subptr(length, 32 >> shift);\n+    copy32_masked_avx(dst, src, xmm, mask, length, index, temp, shift, offset+32);\n+  } else {\n+    Address::ScaleFactor scale = (Address::ScaleFactor)(shift);\n+    assert(MaxVectorSize == 64, \"vector length != 64\");\n+    __ mov64(temp, -1L);\n+    __ bzhiq(temp, temp, length);\n+    __ kmovql(mask, temp);\n+    __ evmovdqu(type[shift], mask, xmm, Address(src, index, scale, offset), false, Assembler::AVX_512bit);\n+    __ evmovdqu(type[shift], mask, Address(dst, index, scale, offset), xmm, true, Assembler::AVX_512bit);\n+  }\n+}\n+\n+\n+void StubGenerator::copy32_masked_avx(Register dst, Register src, XMMRegister xmm,\n+                                       KRegister mask, Register length, Register index,\n+                                       Register temp, int shift, int offset) {\n+  assert(MaxVectorSize >= 32, \"vector length should be >= 32\");\n+  BasicType type[] = { T_BYTE,  T_SHORT,  T_INT,   T_LONG};\n+  Address::ScaleFactor scale = (Address::ScaleFactor)(shift);\n+  __ mov64(temp, -1L);\n+  __ bzhiq(temp, temp, length);\n+  __ kmovql(mask, temp);\n+  __ evmovdqu(type[shift], mask, xmm, Address(src, index, scale, offset), false, Assembler::AVX_256bit);\n+  __ evmovdqu(type[shift], mask, Address(dst, index, scale, offset), xmm, true, Assembler::AVX_256bit);\n+}\n+\n+\n+void StubGenerator::copy32_avx(Register dst, Register src, Register index, XMMRegister xmm,\n+                                int shift, int offset) {\n+  assert(MaxVectorSize >= 32, \"vector length should be >= 32\");\n+  Address::ScaleFactor scale = (Address::ScaleFactor)(shift);\n+  __ vmovdqu(xmm, Address(src, index, scale, offset));\n+  __ vmovdqu(Address(dst, index, scale, offset), xmm);\n+}\n+\n+\n+void StubGenerator::copy64_avx(Register dst, Register src, Register index, XMMRegister xmm,\n+                                bool conjoint, int shift, int offset, bool use64byteVector) {\n+  assert(MaxVectorSize == 64 || MaxVectorSize == 32, \"vector length mismatch\");\n+  if (!use64byteVector) {\n+    if (conjoint) {\n+      copy32_avx(dst, src, index, xmm, shift, offset+32);\n+      copy32_avx(dst, src, index, xmm, shift, offset);\n+    } else {\n+      copy32_avx(dst, src, index, xmm, shift, offset);\n+      copy32_avx(dst, src, index, xmm, shift, offset+32);\n+    }\n+  } else {\n+    Address::ScaleFactor scale = (Address::ScaleFactor)(shift);\n+    __ evmovdquq(xmm, Address(src, index, scale, offset), Assembler::AVX_512bit);\n+    __ evmovdquq(Address(dst, index, scale, offset), xmm, Assembler::AVX_512bit);\n+  }\n+}\n+\n+#endif \/\/ COMPILER2_OR_JVMCI\n+\n+\n+\/\/ Arguments:\n+\/\/   aligned - true => Input and output aligned on a HeapWord == 8-byte boundary\n+\/\/             ignored\n+\/\/   name    - stub name string\n+\/\/\n+\/\/ Inputs:\n+\/\/   c_rarg0   - source array address\n+\/\/   c_rarg1   - destination array address\n+\/\/   c_rarg2   - element count, treated as ssize_t, can be zero\n+\/\/\n+\/\/ If 'from' and\/or 'to' are aligned on 4-, 2-, or 1-byte boundaries,\n+\/\/ we let the hardware handle it.  The one to eight bytes within words,\n+\/\/ dwords or qwords that span cache line boundaries will still be loaded\n+\/\/ and stored atomically.\n+\/\/\n+\/\/ Side Effects:\n+\/\/   disjoint_byte_copy_entry is set to the no-overlap entry point\n+\/\/   used by generate_conjoint_byte_copy().\n+\/\/\n+address StubGenerator::generate_disjoint_byte_copy(bool aligned, address* entry, const char *name) {\n+#if COMPILER2_OR_JVMCI\n+  if (VM_Version::supports_avx512vlbw() && VM_Version::supports_bmi2() && MaxVectorSize  >= 32) {\n+     return generate_disjoint_copy_avx3_masked(entry, \"jbyte_disjoint_arraycopy_avx3\", 0,\n+                                               aligned, false, false);\n+  }\n+#endif\n+  __ align(CodeEntryAlignment);\n+  StubCodeMark mark(this, \"StubRoutines\", name);\n+  address start = __ pc();\n+\n+  Label L_copy_bytes, L_copy_8_bytes, L_copy_4_bytes, L_copy_2_bytes;\n+  Label L_copy_byte, L_exit;\n+  const Register from        = rdi;  \/\/ source array address\n+  const Register to          = rsi;  \/\/ destination array address\n+  const Register count       = rdx;  \/\/ elements count\n+  const Register byte_count  = rcx;\n+  const Register qword_count = count;\n+  const Register end_from    = from; \/\/ source array end address\n+  const Register end_to      = to;   \/\/ destination array end address\n+  \/\/ End pointers are inclusive, and if count is not zero they point\n+  \/\/ to the last unit copied:  end_to[0] := end_from[0]\n+\n+  __ enter(); \/\/ required for proper stackwalking of RuntimeStub frame\n+  assert_clean_int(c_rarg2, rax);    \/\/ Make sure 'count' is clean int.\n+\n+  if (entry != NULL) {\n+    *entry = __ pc();\n+     \/\/ caller can pass a 64-bit byte count here (from Unsafe.copyMemory)\n+    BLOCK_COMMENT(\"Entry:\");\n+  }\n+\n+  setup_arg_regs(); \/\/ from => rdi, to => rsi, count => rdx\n+                    \/\/ r9 and r10 may be used to save non-volatile registers\n+\n+  {\n+    \/\/ UnsafeCopyMemory page error: continue after ucm\n+    UnsafeCopyMemoryMark ucmm(this, !aligned, true);\n+    \/\/ 'from', 'to' and 'count' are now valid\n+    __ movptr(byte_count, count);\n+    __ shrptr(count, 3); \/\/ count => qword_count\n+\n+    \/\/ Copy from low to high addresses.  Use 'to' as scratch.\n+    __ lea(end_from, Address(from, qword_count, Address::times_8, -8));\n+    __ lea(end_to,   Address(to,   qword_count, Address::times_8, -8));\n+    __ negptr(qword_count); \/\/ make the count negative\n+    __ jmp(L_copy_bytes);\n+\n+    \/\/ Copy trailing qwords\n+  __ BIND(L_copy_8_bytes);\n+    __ movq(rax, Address(end_from, qword_count, Address::times_8, 8));\n+    __ movq(Address(end_to, qword_count, Address::times_8, 8), rax);\n+    __ increment(qword_count);\n+    __ jcc(Assembler::notZero, L_copy_8_bytes);\n+\n+    \/\/ Check for and copy trailing dword\n+  __ BIND(L_copy_4_bytes);\n+    __ testl(byte_count, 4);\n+    __ jccb(Assembler::zero, L_copy_2_bytes);\n+    __ movl(rax, Address(end_from, 8));\n+    __ movl(Address(end_to, 8), rax);\n+\n+    __ addptr(end_from, 4);\n+    __ addptr(end_to, 4);\n+\n+    \/\/ Check for and copy trailing word\n+  __ BIND(L_copy_2_bytes);\n+    __ testl(byte_count, 2);\n+    __ jccb(Assembler::zero, L_copy_byte);\n+    __ movw(rax, Address(end_from, 8));\n+    __ movw(Address(end_to, 8), rax);\n+\n+    __ addptr(end_from, 2);\n+    __ addptr(end_to, 2);\n+\n+    \/\/ Check for and copy trailing byte\n+  __ BIND(L_copy_byte);\n+    __ testl(byte_count, 1);\n+    __ jccb(Assembler::zero, L_exit);\n+    __ movb(rax, Address(end_from, 8));\n+    __ movb(Address(end_to, 8), rax);\n+  }\n+__ BIND(L_exit);\n+  address ucme_exit_pc = __ pc();\n+  restore_arg_regs();\n+  INC_COUNTER_NP(SharedRuntime::_jbyte_array_copy_ctr, rscratch1); \/\/ Update counter after rscratch1 is free\n+  __ xorptr(rax, rax); \/\/ return 0\n+  __ vzeroupper();\n+  __ leave(); \/\/ required for proper stackwalking of RuntimeStub frame\n+  __ ret(0);\n+\n+  {\n+    UnsafeCopyMemoryMark ucmm(this, !aligned, false, ucme_exit_pc);\n+    \/\/ Copy in multi-bytes chunks\n+    copy_bytes_forward(end_from, end_to, qword_count, rax, L_copy_bytes, L_copy_8_bytes);\n+    __ jmp(L_copy_4_bytes);\n+  }\n+  return start;\n+}\n+\n+\n+\/\/ Arguments:\n+\/\/   aligned - true => Input and output aligned on a HeapWord == 8-byte boundary\n+\/\/             ignored\n+\/\/   name    - stub name string\n+\/\/\n+\/\/ Inputs:\n+\/\/   c_rarg0   - source array address\n+\/\/   c_rarg1   - destination array address\n+\/\/   c_rarg2   - element count, treated as ssize_t, can be zero\n+\/\/\n+\/\/ If 'from' and\/or 'to' are aligned on 4-, 2-, or 1-byte boundaries,\n+\/\/ we let the hardware handle it.  The one to eight bytes within words,\n+\/\/ dwords or qwords that span cache line boundaries will still be loaded\n+\/\/ and stored atomically.\n+\/\/\n+address StubGenerator::generate_conjoint_byte_copy(bool aligned, address nooverlap_target,\n+                                                   address* entry, const char *name) {\n+#if COMPILER2_OR_JVMCI\n+  if (VM_Version::supports_avx512vlbw() && VM_Version::supports_bmi2() && MaxVectorSize  >= 32) {\n+     return generate_conjoint_copy_avx3_masked(entry, \"jbyte_conjoint_arraycopy_avx3\", 0,\n+                                               nooverlap_target, aligned, false, false);\n+  }\n+#endif\n+  __ align(CodeEntryAlignment);\n+  StubCodeMark mark(this, \"StubRoutines\", name);\n+  address start = __ pc();\n+\n+  Label L_copy_bytes, L_copy_8_bytes, L_copy_4_bytes, L_copy_2_bytes;\n+  const Register from        = rdi;  \/\/ source array address\n+  const Register to          = rsi;  \/\/ destination array address\n+  const Register count       = rdx;  \/\/ elements count\n+  const Register byte_count  = rcx;\n+  const Register qword_count = count;\n+\n+  __ enter(); \/\/ required for proper stackwalking of RuntimeStub frame\n+  assert_clean_int(c_rarg2, rax);    \/\/ Make sure 'count' is clean int.\n+\n+  if (entry != NULL) {\n+    *entry = __ pc();\n+    \/\/ caller can pass a 64-bit byte count here (from Unsafe.copyMemory)\n+    BLOCK_COMMENT(\"Entry:\");\n+  }\n+\n+  array_overlap_test(nooverlap_target, Address::times_1);\n+  setup_arg_regs(); \/\/ from => rdi, to => rsi, count => rdx\n+                    \/\/ r9 and r10 may be used to save non-volatile registers\n+\n+  {\n+    \/\/ UnsafeCopyMemory page error: continue after ucm\n+    UnsafeCopyMemoryMark ucmm(this, !aligned, true);\n+    \/\/ 'from', 'to' and 'count' are now valid\n+    __ movptr(byte_count, count);\n+    __ shrptr(count, 3);   \/\/ count => qword_count\n+\n+    \/\/ Copy from high to low addresses.\n+\n+    \/\/ Check for and copy trailing byte\n+    __ testl(byte_count, 1);\n+    __ jcc(Assembler::zero, L_copy_2_bytes);\n+    __ movb(rax, Address(from, byte_count, Address::times_1, -1));\n+    __ movb(Address(to, byte_count, Address::times_1, -1), rax);\n+    __ decrement(byte_count); \/\/ Adjust for possible trailing word\n+\n+    \/\/ Check for and copy trailing word\n+  __ BIND(L_copy_2_bytes);\n+    __ testl(byte_count, 2);\n+    __ jcc(Assembler::zero, L_copy_4_bytes);\n+    __ movw(rax, Address(from, byte_count, Address::times_1, -2));\n+    __ movw(Address(to, byte_count, Address::times_1, -2), rax);\n+\n+    \/\/ Check for and copy trailing dword\n+  __ BIND(L_copy_4_bytes);\n+    __ testl(byte_count, 4);\n+    __ jcc(Assembler::zero, L_copy_bytes);\n+    __ movl(rax, Address(from, qword_count, Address::times_8));\n+    __ movl(Address(to, qword_count, Address::times_8), rax);\n+    __ jmp(L_copy_bytes);\n+\n+    \/\/ Copy trailing qwords\n+  __ BIND(L_copy_8_bytes);\n+    __ movq(rax, Address(from, qword_count, Address::times_8, -8));\n+    __ movq(Address(to, qword_count, Address::times_8, -8), rax);\n+    __ decrement(qword_count);\n+    __ jcc(Assembler::notZero, L_copy_8_bytes);\n+  }\n+  restore_arg_regs();\n+  INC_COUNTER_NP(SharedRuntime::_jbyte_array_copy_ctr, rscratch1); \/\/ Update counter after rscratch1 is free\n+  __ xorptr(rax, rax); \/\/ return 0\n+  __ vzeroupper();\n+  __ leave(); \/\/ required for proper stackwalking of RuntimeStub frame\n+  __ ret(0);\n+\n+  {\n+    \/\/ UnsafeCopyMemory page error: continue after ucm\n+    UnsafeCopyMemoryMark ucmm(this, !aligned, true);\n+    \/\/ Copy in multi-bytes chunks\n+    copy_bytes_backward(from, to, qword_count, rax, L_copy_bytes, L_copy_8_bytes);\n+  }\n+  restore_arg_regs();\n+  INC_COUNTER_NP(SharedRuntime::_jbyte_array_copy_ctr, rscratch1); \/\/ Update counter after rscratch1 is free\n+  __ xorptr(rax, rax); \/\/ return 0\n+  __ vzeroupper();\n+  __ leave(); \/\/ required for proper stackwalking of RuntimeStub frame\n+  __ ret(0);\n+\n+  return start;\n+}\n+\n+\n+\/\/ Arguments:\n+\/\/   aligned - true => Input and output aligned on a HeapWord == 8-byte boundary\n+\/\/             ignored\n+\/\/   name    - stub name string\n+\/\/\n+\/\/ Inputs:\n+\/\/   c_rarg0   - source array address\n+\/\/   c_rarg1   - destination array address\n+\/\/   c_rarg2   - element count, treated as ssize_t, can be zero\n+\/\/\n+\/\/ If 'from' and\/or 'to' are aligned on 4- or 2-byte boundaries, we\n+\/\/ let the hardware handle it.  The two or four words within dwords\n+\/\/ or qwords that span cache line boundaries will still be loaded\n+\/\/ and stored atomically.\n+\/\/\n+\/\/ Side Effects:\n+\/\/   disjoint_short_copy_entry is set to the no-overlap entry point\n+\/\/   used by generate_conjoint_short_copy().\n+\/\/\n+address StubGenerator::generate_disjoint_short_copy(bool aligned, address *entry, const char *name) {\n+#if COMPILER2_OR_JVMCI\n+  if (VM_Version::supports_avx512vlbw() && VM_Version::supports_bmi2() && MaxVectorSize  >= 32) {\n+     return generate_disjoint_copy_avx3_masked(entry, \"jshort_disjoint_arraycopy_avx3\", 1,\n+                                               aligned, false, false);\n+  }\n+#endif\n+\n+  __ align(CodeEntryAlignment);\n+  StubCodeMark mark(this, \"StubRoutines\", name);\n+  address start = __ pc();\n+\n+  Label L_copy_bytes, L_copy_8_bytes, L_copy_4_bytes,L_copy_2_bytes,L_exit;\n+  const Register from        = rdi;  \/\/ source array address\n+  const Register to          = rsi;  \/\/ destination array address\n+  const Register count       = rdx;  \/\/ elements count\n+  const Register word_count  = rcx;\n+  const Register qword_count = count;\n+  const Register end_from    = from; \/\/ source array end address\n+  const Register end_to      = to;   \/\/ destination array end address\n+  \/\/ End pointers are inclusive, and if count is not zero they point\n+  \/\/ to the last unit copied:  end_to[0] := end_from[0]\n+\n+  __ enter(); \/\/ required for proper stackwalking of RuntimeStub frame\n+  assert_clean_int(c_rarg2, rax);    \/\/ Make sure 'count' is clean int.\n+\n+  if (entry != NULL) {\n+    *entry = __ pc();\n+    \/\/ caller can pass a 64-bit byte count here (from Unsafe.copyMemory)\n+    BLOCK_COMMENT(\"Entry:\");\n+  }\n+\n+  setup_arg_regs(); \/\/ from => rdi, to => rsi, count => rdx\n+                    \/\/ r9 and r10 may be used to save non-volatile registers\n+\n+  {\n+    \/\/ UnsafeCopyMemory page error: continue after ucm\n+    UnsafeCopyMemoryMark ucmm(this, !aligned, true);\n+    \/\/ 'from', 'to' and 'count' are now valid\n+    __ movptr(word_count, count);\n+    __ shrptr(count, 2); \/\/ count => qword_count\n+\n+    \/\/ Copy from low to high addresses.  Use 'to' as scratch.\n+    __ lea(end_from, Address(from, qword_count, Address::times_8, -8));\n+    __ lea(end_to,   Address(to,   qword_count, Address::times_8, -8));\n+    __ negptr(qword_count);\n+    __ jmp(L_copy_bytes);\n+\n+    \/\/ Copy trailing qwords\n+  __ BIND(L_copy_8_bytes);\n+    __ movq(rax, Address(end_from, qword_count, Address::times_8, 8));\n+    __ movq(Address(end_to, qword_count, Address::times_8, 8), rax);\n+    __ increment(qword_count);\n+    __ jcc(Assembler::notZero, L_copy_8_bytes);\n+\n+    \/\/ Original 'dest' is trashed, so we can't use it as a\n+    \/\/ base register for a possible trailing word copy\n+\n+    \/\/ Check for and copy trailing dword\n+  __ BIND(L_copy_4_bytes);\n+    __ testl(word_count, 2);\n+    __ jccb(Assembler::zero, L_copy_2_bytes);\n+    __ movl(rax, Address(end_from, 8));\n+    __ movl(Address(end_to, 8), rax);\n+\n+    __ addptr(end_from, 4);\n+    __ addptr(end_to, 4);\n+\n+    \/\/ Check for and copy trailing word\n+  __ BIND(L_copy_2_bytes);\n+    __ testl(word_count, 1);\n+    __ jccb(Assembler::zero, L_exit);\n+    __ movw(rax, Address(end_from, 8));\n+    __ movw(Address(end_to, 8), rax);\n+  }\n+__ BIND(L_exit);\n+  address ucme_exit_pc = __ pc();\n+  restore_arg_regs();\n+  INC_COUNTER_NP(SharedRuntime::_jshort_array_copy_ctr, rscratch1); \/\/ Update counter after rscratch1 is free\n+  __ xorptr(rax, rax); \/\/ return 0\n+  __ vzeroupper();\n+  __ leave(); \/\/ required for proper stackwalking of RuntimeStub frame\n+  __ ret(0);\n+\n+  {\n+    UnsafeCopyMemoryMark ucmm(this, !aligned, false, ucme_exit_pc);\n+    \/\/ Copy in multi-bytes chunks\n+    copy_bytes_forward(end_from, end_to, qword_count, rax, L_copy_bytes, L_copy_8_bytes);\n+    __ jmp(L_copy_4_bytes);\n+  }\n+\n+  return start;\n+}\n+\n+\n+address StubGenerator::generate_fill(BasicType t, bool aligned, const char *name) {\n+  __ align(CodeEntryAlignment);\n+  StubCodeMark mark(this, \"StubRoutines\", name);\n+  address start = __ pc();\n+\n+  BLOCK_COMMENT(\"Entry:\");\n+\n+  const Register to       = c_rarg0;  \/\/ destination array address\n+  const Register value    = c_rarg1;  \/\/ value\n+  const Register count    = c_rarg2;  \/\/ elements count\n+  __ mov(r11, count);\n+\n+  __ enter(); \/\/ required for proper stackwalking of RuntimeStub frame\n+\n+  __ generate_fill(t, aligned, to, value, r11, rax, xmm0);\n+\n+  __ vzeroupper();\n+  __ leave(); \/\/ required for proper stackwalking of RuntimeStub frame\n+  __ ret(0);\n+\n+  return start;\n+}\n+\n+\n+\/\/ Arguments:\n+\/\/   aligned - true => Input and output aligned on a HeapWord == 8-byte boundary\n+\/\/             ignored\n+\/\/   name    - stub name string\n+\/\/\n+\/\/ Inputs:\n+\/\/   c_rarg0   - source array address\n+\/\/   c_rarg1   - destination array address\n+\/\/   c_rarg2   - element count, treated as ssize_t, can be zero\n+\/\/\n+\/\/ If 'from' and\/or 'to' are aligned on 4- or 2-byte boundaries, we\n+\/\/ let the hardware handle it.  The two or four words within dwords\n+\/\/ or qwords that span cache line boundaries will still be loaded\n+\/\/ and stored atomically.\n+\/\/\n+address StubGenerator::generate_conjoint_short_copy(bool aligned, address nooverlap_target,\n+                                                    address *entry, const char *name) {\n+#if COMPILER2_OR_JVMCI\n+  if (VM_Version::supports_avx512vlbw() && VM_Version::supports_bmi2() && MaxVectorSize  >= 32) {\n+     return generate_conjoint_copy_avx3_masked(entry, \"jshort_conjoint_arraycopy_avx3\", 1,\n+                                               nooverlap_target, aligned, false, false);\n+  }\n+#endif\n+  __ align(CodeEntryAlignment);\n+  StubCodeMark mark(this, \"StubRoutines\", name);\n+  address start = __ pc();\n+\n+  Label L_copy_bytes, L_copy_8_bytes, L_copy_4_bytes;\n+  const Register from        = rdi;  \/\/ source array address\n+  const Register to          = rsi;  \/\/ destination array address\n+  const Register count       = rdx;  \/\/ elements count\n+  const Register word_count  = rcx;\n+  const Register qword_count = count;\n+\n+  __ enter(); \/\/ required for proper stackwalking of RuntimeStub frame\n+  assert_clean_int(c_rarg2, rax);    \/\/ Make sure 'count' is clean int.\n+\n+  if (entry != NULL) {\n+    *entry = __ pc();\n+    \/\/ caller can pass a 64-bit byte count here (from Unsafe.copyMemory)\n+    BLOCK_COMMENT(\"Entry:\");\n+  }\n+\n+  array_overlap_test(nooverlap_target, Address::times_2);\n+  setup_arg_regs(); \/\/ from => rdi, to => rsi, count => rdx\n+                    \/\/ r9 and r10 may be used to save non-volatile registers\n+\n+  {\n+    \/\/ UnsafeCopyMemory page error: continue after ucm\n+    UnsafeCopyMemoryMark ucmm(this, !aligned, true);\n+    \/\/ 'from', 'to' and 'count' are now valid\n+    __ movptr(word_count, count);\n+    __ shrptr(count, 2); \/\/ count => qword_count\n+\n+    \/\/ Copy from high to low addresses.  Use 'to' as scratch.\n+\n+    \/\/ Check for and copy trailing word\n+    __ testl(word_count, 1);\n+    __ jccb(Assembler::zero, L_copy_4_bytes);\n+    __ movw(rax, Address(from, word_count, Address::times_2, -2));\n+    __ movw(Address(to, word_count, Address::times_2, -2), rax);\n+\n+   \/\/ Check for and copy trailing dword\n+  __ BIND(L_copy_4_bytes);\n+    __ testl(word_count, 2);\n+    __ jcc(Assembler::zero, L_copy_bytes);\n+    __ movl(rax, Address(from, qword_count, Address::times_8));\n+    __ movl(Address(to, qword_count, Address::times_8), rax);\n+    __ jmp(L_copy_bytes);\n+\n+    \/\/ Copy trailing qwords\n+  __ BIND(L_copy_8_bytes);\n+    __ movq(rax, Address(from, qword_count, Address::times_8, -8));\n+    __ movq(Address(to, qword_count, Address::times_8, -8), rax);\n+    __ decrement(qword_count);\n+    __ jcc(Assembler::notZero, L_copy_8_bytes);\n+  }\n+  restore_arg_regs();\n+  INC_COUNTER_NP(SharedRuntime::_jshort_array_copy_ctr, rscratch1); \/\/ Update counter after rscratch1 is free\n+  __ xorptr(rax, rax); \/\/ return 0\n+  __ vzeroupper();\n+  __ leave(); \/\/ required for proper stackwalking of RuntimeStub frame\n+  __ ret(0);\n+\n+  {\n+    \/\/ UnsafeCopyMemory page error: continue after ucm\n+    UnsafeCopyMemoryMark ucmm(this, !aligned, true);\n+    \/\/ Copy in multi-bytes chunks\n+    copy_bytes_backward(from, to, qword_count, rax, L_copy_bytes, L_copy_8_bytes);\n+  }\n+  restore_arg_regs();\n+  INC_COUNTER_NP(SharedRuntime::_jshort_array_copy_ctr, rscratch1); \/\/ Update counter after rscratch1 is free\n+  __ xorptr(rax, rax); \/\/ return 0\n+  __ vzeroupper();\n+  __ leave(); \/\/ required for proper stackwalking of RuntimeStub frame\n+  __ ret(0);\n+\n+  return start;\n+}\n+\n+\n+\/\/ Arguments:\n+\/\/   aligned - true => Input and output aligned on a HeapWord == 8-byte boundary\n+\/\/             ignored\n+\/\/   is_oop  - true => oop array, so generate store check code\n+\/\/   name    - stub name string\n+\/\/\n+\/\/ Inputs:\n+\/\/   c_rarg0   - source array address\n+\/\/   c_rarg1   - destination array address\n+\/\/   c_rarg2   - element count, treated as ssize_t, can be zero\n+\/\/\n+\/\/ If 'from' and\/or 'to' are aligned on 4-byte boundaries, we let\n+\/\/ the hardware handle it.  The two dwords within qwords that span\n+\/\/ cache line boundaries will still be loaded and stored atomically.\n+\/\/\n+\/\/ Side Effects:\n+\/\/   disjoint_int_copy_entry is set to the no-overlap entry point\n+\/\/   used by generate_conjoint_int_oop_copy().\n+\/\/\n+address StubGenerator::generate_disjoint_int_oop_copy(bool aligned, bool is_oop, address* entry,\n+                                                      const char *name, bool dest_uninitialized) {\n+#if COMPILER2_OR_JVMCI\n+  if (VM_Version::supports_avx512vlbw() && VM_Version::supports_bmi2() && MaxVectorSize  >= 32) {\n+     return generate_disjoint_copy_avx3_masked(entry, \"jint_disjoint_arraycopy_avx3\", 2,\n+                                               aligned, is_oop, dest_uninitialized);\n+  }\n+#endif\n+\n+  __ align(CodeEntryAlignment);\n+  StubCodeMark mark(this, \"StubRoutines\", name);\n+  address start = __ pc();\n+\n+  Label L_copy_bytes, L_copy_8_bytes, L_copy_4_bytes, L_exit;\n+  const Register from        = rdi;  \/\/ source array address\n+  const Register to          = rsi;  \/\/ destination array address\n+  const Register count       = rdx;  \/\/ elements count\n+  const Register dword_count = rcx;\n+  const Register qword_count = count;\n+  const Register end_from    = from; \/\/ source array end address\n+  const Register end_to      = to;   \/\/ destination array end address\n+  \/\/ End pointers are inclusive, and if count is not zero they point\n+  \/\/ to the last unit copied:  end_to[0] := end_from[0]\n+\n+  __ enter(); \/\/ required for proper stackwalking of RuntimeStub frame\n+  assert_clean_int(c_rarg2, rax);    \/\/ Make sure 'count' is clean int.\n+\n+  if (entry != NULL) {\n+    *entry = __ pc();\n+    \/\/ caller can pass a 64-bit byte count here (from Unsafe.copyMemory)\n+    BLOCK_COMMENT(\"Entry:\");\n+  }\n+\n+  setup_arg_regs_using_thread(); \/\/ from => rdi, to => rsi, count => rdx\n+                                 \/\/ r9 is used to save r15_thread\n+\n+  DecoratorSet decorators = IN_HEAP | IS_ARRAY | ARRAYCOPY_DISJOINT;\n+  if (dest_uninitialized) {\n+    decorators |= IS_DEST_UNINITIALIZED;\n+  }\n+  if (aligned) {\n+    decorators |= ARRAYCOPY_ALIGNED;\n+  }\n+\n+  BasicType type = is_oop ? T_OBJECT : T_INT;\n+  BarrierSetAssembler *bs = BarrierSet::barrier_set()->barrier_set_assembler();\n+  bs->arraycopy_prologue(_masm, decorators, type, from, to, count);\n+\n+  {\n+    \/\/ UnsafeCopyMemory page error: continue after ucm\n+    UnsafeCopyMemoryMark ucmm(this, !is_oop && !aligned, true);\n+    \/\/ 'from', 'to' and 'count' are now valid\n+    __ movptr(dword_count, count);\n+    __ shrptr(count, 1); \/\/ count => qword_count\n+\n+    \/\/ Copy from low to high addresses.  Use 'to' as scratch.\n+    __ lea(end_from, Address(from, qword_count, Address::times_8, -8));\n+    __ lea(end_to,   Address(to,   qword_count, Address::times_8, -8));\n+    __ negptr(qword_count);\n+    __ jmp(L_copy_bytes);\n+\n+    \/\/ Copy trailing qwords\n+  __ BIND(L_copy_8_bytes);\n+    __ movq(rax, Address(end_from, qword_count, Address::times_8, 8));\n+    __ movq(Address(end_to, qword_count, Address::times_8, 8), rax);\n+    __ increment(qword_count);\n+    __ jcc(Assembler::notZero, L_copy_8_bytes);\n+\n+    \/\/ Check for and copy trailing dword\n+  __ BIND(L_copy_4_bytes);\n+    __ testl(dword_count, 1); \/\/ Only byte test since the value is 0 or 1\n+    __ jccb(Assembler::zero, L_exit);\n+    __ movl(rax, Address(end_from, 8));\n+    __ movl(Address(end_to, 8), rax);\n+  }\n+__ BIND(L_exit);\n+  address ucme_exit_pc = __ pc();\n+  bs->arraycopy_epilogue(_masm, decorators, type, from, to, dword_count);\n+  restore_arg_regs_using_thread();\n+  INC_COUNTER_NP(SharedRuntime::_jint_array_copy_ctr, rscratch1); \/\/ Update counter after rscratch1 is free\n+  __ vzeroupper();\n+  __ xorptr(rax, rax); \/\/ return 0\n+  __ leave(); \/\/ required for proper stackwalking of RuntimeStub frame\n+  __ ret(0);\n+\n+  {\n+    UnsafeCopyMemoryMark ucmm(this, !is_oop && !aligned, false, ucme_exit_pc);\n+    \/\/ Copy in multi-bytes chunks\n+    copy_bytes_forward(end_from, end_to, qword_count, rax, L_copy_bytes, L_copy_8_bytes);\n+    __ jmp(L_copy_4_bytes);\n+  }\n+\n+  return start;\n+}\n+\n+\n+\/\/ Arguments:\n+\/\/   aligned - true => Input and output aligned on a HeapWord == 8-byte boundary\n+\/\/             ignored\n+\/\/   is_oop  - true => oop array, so generate store check code\n+\/\/   name    - stub name string\n+\/\/\n+\/\/ Inputs:\n+\/\/   c_rarg0   - source array address\n+\/\/   c_rarg1   - destination array address\n+\/\/   c_rarg2   - element count, treated as ssize_t, can be zero\n+\/\/\n+\/\/ If 'from' and\/or 'to' are aligned on 4-byte boundaries, we let\n+\/\/ the hardware handle it.  The two dwords within qwords that span\n+\/\/ cache line boundaries will still be loaded and stored atomically.\n+\/\/\n+address StubGenerator::generate_conjoint_int_oop_copy(bool aligned, bool is_oop, address nooverlap_target,\n+                                                      address *entry, const char *name,\n+                                                      bool dest_uninitialized) {\n+#if COMPILER2_OR_JVMCI\n+  if (VM_Version::supports_avx512vlbw() && VM_Version::supports_bmi2() && MaxVectorSize  >= 32) {\n+     return generate_conjoint_copy_avx3_masked(entry, \"jint_conjoint_arraycopy_avx3\", 2,\n+                                               nooverlap_target, aligned, is_oop, dest_uninitialized);\n+  }\n+#endif\n+  __ align(CodeEntryAlignment);\n+  StubCodeMark mark(this, \"StubRoutines\", name);\n+  address start = __ pc();\n+\n+  Label L_copy_bytes, L_copy_8_bytes, L_exit;\n+  const Register from        = rdi;  \/\/ source array address\n+  const Register to          = rsi;  \/\/ destination array address\n+  const Register count       = rdx;  \/\/ elements count\n+  const Register dword_count = rcx;\n+  const Register qword_count = count;\n+\n+  __ enter(); \/\/ required for proper stackwalking of RuntimeStub frame\n+  assert_clean_int(c_rarg2, rax);    \/\/ Make sure 'count' is clean int.\n+\n+  if (entry != NULL) {\n+    *entry = __ pc();\n+     \/\/ caller can pass a 64-bit byte count here (from Unsafe.copyMemory)\n+    BLOCK_COMMENT(\"Entry:\");\n+  }\n+\n+  array_overlap_test(nooverlap_target, Address::times_4);\n+  setup_arg_regs_using_thread(); \/\/ from => rdi, to => rsi, count => rdx\n+                                 \/\/ r9 is used to save r15_thread\n+\n+  DecoratorSet decorators = IN_HEAP | IS_ARRAY;\n+  if (dest_uninitialized) {\n+    decorators |= IS_DEST_UNINITIALIZED;\n+  }\n+  if (aligned) {\n+    decorators |= ARRAYCOPY_ALIGNED;\n+  }\n+\n+  BasicType type = is_oop ? T_OBJECT : T_INT;\n+  BarrierSetAssembler *bs = BarrierSet::barrier_set()->barrier_set_assembler();\n+  \/\/ no registers are destroyed by this call\n+  bs->arraycopy_prologue(_masm, decorators, type, from, to, count);\n+\n+  assert_clean_int(count, rax); \/\/ Make sure 'count' is clean int.\n+  {\n+    \/\/ UnsafeCopyMemory page error: continue after ucm\n+    UnsafeCopyMemoryMark ucmm(this, !is_oop && !aligned, true);\n+    \/\/ 'from', 'to' and 'count' are now valid\n+    __ movptr(dword_count, count);\n+    __ shrptr(count, 1); \/\/ count => qword_count\n+\n+    \/\/ Copy from high to low addresses.  Use 'to' as scratch.\n+\n+    \/\/ Check for and copy trailing dword\n+    __ testl(dword_count, 1);\n+    __ jcc(Assembler::zero, L_copy_bytes);\n+    __ movl(rax, Address(from, dword_count, Address::times_4, -4));\n+    __ movl(Address(to, dword_count, Address::times_4, -4), rax);\n+    __ jmp(L_copy_bytes);\n+\n+    \/\/ Copy trailing qwords\n+  __ BIND(L_copy_8_bytes);\n+    __ movq(rax, Address(from, qword_count, Address::times_8, -8));\n+    __ movq(Address(to, qword_count, Address::times_8, -8), rax);\n+    __ decrement(qword_count);\n+    __ jcc(Assembler::notZero, L_copy_8_bytes);\n+  }\n+  if (is_oop) {\n+    __ jmp(L_exit);\n+  }\n+  restore_arg_regs_using_thread();\n+  INC_COUNTER_NP(SharedRuntime::_jint_array_copy_ctr, rscratch1); \/\/ Update counter after rscratch1 is free\n+  __ xorptr(rax, rax); \/\/ return 0\n+  __ vzeroupper();\n+  __ leave(); \/\/ required for proper stackwalking of RuntimeStub frame\n+  __ ret(0);\n+\n+  {\n+    \/\/ UnsafeCopyMemory page error: continue after ucm\n+    UnsafeCopyMemoryMark ucmm(this, !is_oop && !aligned, true);\n+    \/\/ Copy in multi-bytes chunks\n+    copy_bytes_backward(from, to, qword_count, rax, L_copy_bytes, L_copy_8_bytes);\n+  }\n+\n+__ BIND(L_exit);\n+  bs->arraycopy_epilogue(_masm, decorators, type, from, to, dword_count);\n+  restore_arg_regs_using_thread();\n+  INC_COUNTER_NP(SharedRuntime::_jint_array_copy_ctr, rscratch1); \/\/ Update counter after rscratch1 is free\n+  __ xorptr(rax, rax); \/\/ return 0\n+  __ vzeroupper();\n+  __ leave(); \/\/ required for proper stackwalking of RuntimeStub frame\n+  __ ret(0);\n+\n+  return start;\n+}\n+\n+\n+\/\/ Arguments:\n+\/\/   aligned - true => Input and output aligned on a HeapWord boundary == 8 bytes\n+\/\/             ignored\n+\/\/   is_oop  - true => oop array, so generate store check code\n+\/\/   name    - stub name string\n+\/\/\n+\/\/ Inputs:\n+\/\/   c_rarg0   - source array address\n+\/\/   c_rarg1   - destination array address\n+\/\/   c_rarg2   - element count, treated as ssize_t, can be zero\n+\/\/\n+ \/\/ Side Effects:\n+\/\/   disjoint_oop_copy_entry or disjoint_long_copy_entry is set to the\n+\/\/   no-overlap entry point used by generate_conjoint_long_oop_copy().\n+\/\/\n+address StubGenerator::generate_disjoint_long_oop_copy(bool aligned, bool is_oop, address *entry,\n+                                                       const char *name, bool dest_uninitialized) {\n+#if COMPILER2_OR_JVMCI\n+  if (VM_Version::supports_avx512vlbw() && VM_Version::supports_bmi2() && MaxVectorSize  >= 32) {\n+     return generate_disjoint_copy_avx3_masked(entry, \"jlong_disjoint_arraycopy_avx3\", 3,\n+                                               aligned, is_oop, dest_uninitialized);\n+  }\n+#endif\n+  __ align(CodeEntryAlignment);\n+  StubCodeMark mark(this, \"StubRoutines\", name);\n+  address start = __ pc();\n+\n+  Label L_copy_bytes, L_copy_8_bytes, L_exit;\n+  const Register from        = rdi;  \/\/ source array address\n+  const Register to          = rsi;  \/\/ destination array address\n+  const Register qword_count = rdx;  \/\/ elements count\n+  const Register end_from    = from; \/\/ source array end address\n+  const Register end_to      = rcx;  \/\/ destination array end address\n+  const Register saved_count = r11;\n+  \/\/ End pointers are inclusive, and if count is not zero they point\n+  \/\/ to the last unit copied:  end_to[0] := end_from[0]\n+\n+  __ enter(); \/\/ required for proper stackwalking of RuntimeStub frame\n+  \/\/ Save no-overlap entry point for generate_conjoint_long_oop_copy()\n+  assert_clean_int(c_rarg2, rax);    \/\/ Make sure 'count' is clean int.\n+\n+  if (entry != NULL) {\n+    *entry = __ pc();\n+    \/\/ caller can pass a 64-bit byte count here (from Unsafe.copyMemory)\n+    BLOCK_COMMENT(\"Entry:\");\n+  }\n+\n+  setup_arg_regs_using_thread(); \/\/ from => rdi, to => rsi, count => rdx\n+                                   \/\/ r9 is used to save r15_thread\n+  \/\/ 'from', 'to' and 'qword_count' are now valid\n+\n+  DecoratorSet decorators = IN_HEAP | IS_ARRAY | ARRAYCOPY_DISJOINT;\n+  if (dest_uninitialized) {\n+    decorators |= IS_DEST_UNINITIALIZED;\n+  }\n+  if (aligned) {\n+    decorators |= ARRAYCOPY_ALIGNED;\n+  }\n+\n+  BasicType type = is_oop ? T_OBJECT : T_LONG;\n+  BarrierSetAssembler *bs = BarrierSet::barrier_set()->barrier_set_assembler();\n+  bs->arraycopy_prologue(_masm, decorators, type, from, to, qword_count);\n+  {\n+    \/\/ UnsafeCopyMemory page error: continue after ucm\n+    UnsafeCopyMemoryMark ucmm(this, !is_oop && !aligned, true);\n+\n+    \/\/ Copy from low to high addresses.  Use 'to' as scratch.\n+    __ lea(end_from, Address(from, qword_count, Address::times_8, -8));\n+    __ lea(end_to,   Address(to,   qword_count, Address::times_8, -8));\n+    __ negptr(qword_count);\n+    __ jmp(L_copy_bytes);\n+\n+    \/\/ Copy trailing qwords\n+  __ BIND(L_copy_8_bytes);\n+    __ movq(rax, Address(end_from, qword_count, Address::times_8, 8));\n+    __ movq(Address(end_to, qword_count, Address::times_8, 8), rax);\n+    __ increment(qword_count);\n+    __ jcc(Assembler::notZero, L_copy_8_bytes);\n+  }\n+  if (is_oop) {\n+    __ jmp(L_exit);\n+  } else {\n+    restore_arg_regs_using_thread();\n+    INC_COUNTER_NP(SharedRuntime::_jlong_array_copy_ctr, rscratch1); \/\/ Update counter after rscratch1 is free\n+    __ xorptr(rax, rax); \/\/ return 0\n+    __ vzeroupper();\n+    __ leave(); \/\/ required for proper stackwalking of RuntimeStub frame\n+    __ ret(0);\n+  }\n+\n+  {\n+    \/\/ UnsafeCopyMemory page error: continue after ucm\n+    UnsafeCopyMemoryMark ucmm(this, !is_oop && !aligned, true);\n+    \/\/ Copy in multi-bytes chunks\n+    copy_bytes_forward(end_from, end_to, qword_count, rax, L_copy_bytes, L_copy_8_bytes);\n+  }\n+\n+  __ BIND(L_exit);\n+  bs->arraycopy_epilogue(_masm, decorators, type, from, to, qword_count);\n+  restore_arg_regs_using_thread();\n+  INC_COUNTER_NP(is_oop ? SharedRuntime::_oop_array_copy_ctr :\n+                          SharedRuntime::_jlong_array_copy_ctr,\n+                 rscratch1); \/\/ Update counter after rscratch1 is free\n+  __ vzeroupper();\n+  __ xorptr(rax, rax); \/\/ return 0\n+  __ leave(); \/\/ required for proper stackwalking of RuntimeStub frame\n+  __ ret(0);\n+\n+  return start;\n+}\n+\n+\n+\/\/ Arguments:\n+\/\/   aligned - true => Input and output aligned on a HeapWord boundary == 8 bytes\n+\/\/             ignored\n+\/\/   is_oop  - true => oop array, so generate store check code\n+\/\/   name    - stub name string\n+\/\/\n+\/\/ Inputs:\n+\/\/   c_rarg0   - source array address\n+\/\/   c_rarg1   - destination array address\n+\/\/   c_rarg2   - element count, treated as ssize_t, can be zero\n+\/\/\n+address StubGenerator::generate_conjoint_long_oop_copy(bool aligned, bool is_oop, address nooverlap_target,\n+                                                       address *entry, const char *name,\n+                                                       bool dest_uninitialized) {\n+#if COMPILER2_OR_JVMCI\n+  if (VM_Version::supports_avx512vlbw() && VM_Version::supports_bmi2() && MaxVectorSize  >= 32) {\n+     return generate_conjoint_copy_avx3_masked(entry, \"jlong_conjoint_arraycopy_avx3\", 3,\n+                                               nooverlap_target, aligned, is_oop, dest_uninitialized);\n+  }\n+#endif\n+  __ align(CodeEntryAlignment);\n+  StubCodeMark mark(this, \"StubRoutines\", name);\n+  address start = __ pc();\n+\n+  Label L_copy_bytes, L_copy_8_bytes, L_exit;\n+  const Register from        = rdi;  \/\/ source array address\n+  const Register to          = rsi;  \/\/ destination array address\n+  const Register qword_count = rdx;  \/\/ elements count\n+  const Register saved_count = rcx;\n+\n+  __ enter(); \/\/ required for proper stackwalking of RuntimeStub frame\n+  assert_clean_int(c_rarg2, rax);    \/\/ Make sure 'count' is clean int.\n+\n+  if (entry != NULL) {\n+    *entry = __ pc();\n+    \/\/ caller can pass a 64-bit byte count here (from Unsafe.copyMemory)\n+    BLOCK_COMMENT(\"Entry:\");\n+  }\n+\n+  array_overlap_test(nooverlap_target, Address::times_8);\n+  setup_arg_regs_using_thread(); \/\/ from => rdi, to => rsi, count => rdx\n+                                 \/\/ r9 is used to save r15_thread\n+  \/\/ 'from', 'to' and 'qword_count' are now valid\n+\n+  DecoratorSet decorators = IN_HEAP | IS_ARRAY;\n+  if (dest_uninitialized) {\n+    decorators |= IS_DEST_UNINITIALIZED;\n+  }\n+  if (aligned) {\n+    decorators |= ARRAYCOPY_ALIGNED;\n+  }\n+\n+  BasicType type = is_oop ? T_OBJECT : T_LONG;\n+  BarrierSetAssembler *bs = BarrierSet::barrier_set()->barrier_set_assembler();\n+  bs->arraycopy_prologue(_masm, decorators, type, from, to, qword_count);\n+  {\n+    \/\/ UnsafeCopyMemory page error: continue after ucm\n+    UnsafeCopyMemoryMark ucmm(this, !is_oop && !aligned, true);\n+\n+    __ jmp(L_copy_bytes);\n+\n+    \/\/ Copy trailing qwords\n+  __ BIND(L_copy_8_bytes);\n+    __ movq(rax, Address(from, qword_count, Address::times_8, -8));\n+    __ movq(Address(to, qword_count, Address::times_8, -8), rax);\n+    __ decrement(qword_count);\n+    __ jcc(Assembler::notZero, L_copy_8_bytes);\n+  }\n+  if (is_oop) {\n+    __ jmp(L_exit);\n+  } else {\n+    restore_arg_regs_using_thread();\n+    INC_COUNTER_NP(SharedRuntime::_jlong_array_copy_ctr, rscratch1); \/\/ Update counter after rscratch1 is free\n+    __ xorptr(rax, rax); \/\/ return 0\n+    __ vzeroupper();\n+    __ leave(); \/\/ required for proper stackwalking of RuntimeStub frame\n+    __ ret(0);\n+  }\n+  {\n+    \/\/ UnsafeCopyMemory page error: continue after ucm\n+    UnsafeCopyMemoryMark ucmm(this, !is_oop && !aligned, true);\n+\n+    \/\/ Copy in multi-bytes chunks\n+    copy_bytes_backward(from, to, qword_count, rax, L_copy_bytes, L_copy_8_bytes);\n+  }\n+  __ BIND(L_exit);\n+  bs->arraycopy_epilogue(_masm, decorators, type, from, to, qword_count);\n+  restore_arg_regs_using_thread();\n+  INC_COUNTER_NP(is_oop ? SharedRuntime::_oop_array_copy_ctr :\n+                          SharedRuntime::_jlong_array_copy_ctr,\n+                 rscratch1); \/\/ Update counter after rscratch1 is free\n+  __ vzeroupper();\n+  __ xorptr(rax, rax); \/\/ return 0\n+  __ leave(); \/\/ required for proper stackwalking of RuntimeStub frame\n+  __ ret(0);\n+\n+  return start;\n+}\n+\n+\n+\/\/ Helper for generating a dynamic type check.\n+\/\/ Smashes no registers.\n+void StubGenerator::generate_type_check(Register sub_klass,\n+                                        Register super_check_offset,\n+                                        Register super_klass,\n+                                        Label& L_success) {\n+  assert_different_registers(sub_klass, super_check_offset, super_klass);\n+\n+  BLOCK_COMMENT(\"type_check:\");\n+\n+  Label L_miss;\n+\n+  __ check_klass_subtype_fast_path(sub_klass, super_klass, noreg,        &L_success, &L_miss, NULL,\n+                                   super_check_offset);\n+  __ check_klass_subtype_slow_path(sub_klass, super_klass, noreg, noreg, &L_success, NULL);\n+\n+  \/\/ Fall through on failure!\n+  __ BIND(L_miss);\n+}\n+\n+\/\/\n+\/\/  Generate checkcasting array copy stub\n+\/\/\n+\/\/  Input:\n+\/\/    c_rarg0   - source array address\n+\/\/    c_rarg1   - destination array address\n+\/\/    c_rarg2   - element count, treated as ssize_t, can be zero\n+\/\/    c_rarg3   - size_t ckoff (super_check_offset)\n+\/\/ not Win64\n+\/\/    c_rarg4   - oop ckval (super_klass)\n+\/\/ Win64\n+\/\/    rsp+40    - oop ckval (super_klass)\n+\/\/\n+\/\/  Output:\n+\/\/    rax ==  0  -  success\n+\/\/    rax == -1^K - failure, where K is partial transfer count\n+\/\/\n+address StubGenerator::generate_checkcast_copy(const char *name, address *entry, bool dest_uninitialized) {\n+\n+  Label L_load_element, L_store_element, L_do_card_marks, L_done;\n+\n+  \/\/ Input registers (after setup_arg_regs)\n+  const Register from        = rdi;   \/\/ source array address\n+  const Register to          = rsi;   \/\/ destination array address\n+  const Register length      = rdx;   \/\/ elements count\n+  const Register ckoff       = rcx;   \/\/ super_check_offset\n+  const Register ckval       = r8;    \/\/ super_klass\n+\n+  \/\/ Registers used as temps (r13, r14 are save-on-entry)\n+  const Register end_from    = from;  \/\/ source array end address\n+  const Register end_to      = r13;   \/\/ destination array end address\n+  const Register count       = rdx;   \/\/ -(count_remaining)\n+  const Register r14_length  = r14;   \/\/ saved copy of length\n+  \/\/ End pointers are inclusive, and if length is not zero they point\n+  \/\/ to the last unit copied:  end_to[0] := end_from[0]\n+\n+  const Register rax_oop    = rax;    \/\/ actual oop copied\n+  const Register r11_klass  = r11;    \/\/ oop._klass\n+\n+  \/\/---------------------------------------------------------------\n+  \/\/ Assembler stub will be used for this call to arraycopy\n+  \/\/ if the two arrays are subtypes of Object[] but the\n+  \/\/ destination array type is not equal to or a supertype\n+  \/\/ of the source type.  Each element must be separately\n+  \/\/ checked.\n+\n+  __ align(CodeEntryAlignment);\n+  StubCodeMark mark(this, \"StubRoutines\", name);\n+  address start = __ pc();\n+\n+  __ enter(); \/\/ required for proper stackwalking of RuntimeStub frame\n+\n+#ifdef ASSERT\n+  \/\/ caller guarantees that the arrays really are different\n+  \/\/ otherwise, we would have to make conjoint checks\n+  { Label L;\n+    array_overlap_test(L, TIMES_OOP);\n+    __ stop(\"checkcast_copy within a single array\");\n+    __ bind(L);\n+  }\n+#endif \/\/ASSERT\n+\n+  setup_arg_regs(4); \/\/ from => rdi, to => rsi, length => rdx\n+                     \/\/ ckoff => rcx, ckval => r8\n+                     \/\/ r9 and r10 may be used to save non-volatile registers\n+#ifdef _WIN64\n+  \/\/ last argument (#4) is on stack on Win64\n+  __ movptr(ckval, Address(rsp, 6 * wordSize));\n+#endif\n+\n+  \/\/ Caller of this entry point must set up the argument registers.\n+  if (entry != NULL) {\n+    *entry = __ pc();\n+    BLOCK_COMMENT(\"Entry:\");\n+  }\n+\n+  \/\/ allocate spill slots for r13, r14\n+  enum {\n+    saved_r13_offset,\n+    saved_r14_offset,\n+    saved_r10_offset,\n+    saved_rbp_offset\n+  };\n+  __ subptr(rsp, saved_rbp_offset * wordSize);\n+  __ movptr(Address(rsp, saved_r13_offset * wordSize), r13);\n+  __ movptr(Address(rsp, saved_r14_offset * wordSize), r14);\n+  __ movptr(Address(rsp, saved_r10_offset * wordSize), r10);\n+\n+#ifdef ASSERT\n+    Label L2;\n+    __ get_thread(r14);\n+    __ cmpptr(r15_thread, r14);\n+    __ jcc(Assembler::equal, L2);\n+    __ stop(\"StubRoutines::call_stub: r15_thread is modified by call\");\n+    __ bind(L2);\n+#endif \/\/ ASSERT\n+\n+  \/\/ check that int operands are properly extended to size_t\n+  assert_clean_int(length, rax);\n+  assert_clean_int(ckoff, rax);\n+\n+#ifdef ASSERT\n+  BLOCK_COMMENT(\"assert consistent ckoff\/ckval\");\n+  \/\/ The ckoff and ckval must be mutually consistent,\n+  \/\/ even though caller generates both.\n+  { Label L;\n+    int sco_offset = in_bytes(Klass::super_check_offset_offset());\n+    __ cmpl(ckoff, Address(ckval, sco_offset));\n+    __ jcc(Assembler::equal, L);\n+    __ stop(\"super_check_offset inconsistent\");\n+    __ bind(L);\n+  }\n+#endif \/\/ASSERT\n+\n+  \/\/ Loop-invariant addresses.  They are exclusive end pointers.\n+  Address end_from_addr(from, length, TIMES_OOP, 0);\n+  Address   end_to_addr(to,   length, TIMES_OOP, 0);\n+  \/\/ Loop-variant addresses.  They assume post-incremented count < 0.\n+  Address from_element_addr(end_from, count, TIMES_OOP, 0);\n+  Address   to_element_addr(end_to,   count, TIMES_OOP, 0);\n+\n+  DecoratorSet decorators = IN_HEAP | IS_ARRAY | ARRAYCOPY_CHECKCAST | ARRAYCOPY_DISJOINT;\n+  if (dest_uninitialized) {\n+    decorators |= IS_DEST_UNINITIALIZED;\n+  }\n+\n+  BasicType type = T_OBJECT;\n+  BarrierSetAssembler *bs = BarrierSet::barrier_set()->barrier_set_assembler();\n+  bs->arraycopy_prologue(_masm, decorators, type, from, to, count);\n+\n+  \/\/ Copy from low to high addresses, indexed from the end of each array.\n+  __ lea(end_from, end_from_addr);\n+  __ lea(end_to,   end_to_addr);\n+  __ movptr(r14_length, length);        \/\/ save a copy of the length\n+  assert(length == count, \"\");          \/\/ else fix next line:\n+  __ negptr(count);                     \/\/ negate and test the length\n+  __ jcc(Assembler::notZero, L_load_element);\n+\n+  \/\/ Empty array:  Nothing to do.\n+  __ xorptr(rax, rax);                  \/\/ return 0 on (trivial) success\n+  __ jmp(L_done);\n+\n+  \/\/ ======== begin loop ========\n+  \/\/ (Loop is rotated; its entry is L_load_element.)\n+  \/\/ Loop control:\n+  \/\/   for (count = -count; count != 0; count++)\n+  \/\/ Base pointers src, dst are biased by 8*(count-1),to last element.\n+  __ align(OptoLoopAlignment);\n+\n+  __ BIND(L_store_element);\n+  __ store_heap_oop(to_element_addr, rax_oop, noreg, noreg, noreg, AS_RAW);  \/\/ store the oop\n+  __ increment(count);               \/\/ increment the count toward zero\n+  __ jcc(Assembler::zero, L_do_card_marks);\n+\n+  \/\/ ======== loop entry is here ========\n+  __ BIND(L_load_element);\n+  __ load_heap_oop(rax_oop, from_element_addr, noreg, noreg, AS_RAW); \/\/ load the oop\n+  __ testptr(rax_oop, rax_oop);\n+  __ jcc(Assembler::zero, L_store_element);\n+\n+  __ load_klass(r11_klass, rax_oop, rscratch1);\/\/ query the object klass\n+  generate_type_check(r11_klass, ckoff, ckval, L_store_element);\n+  \/\/ ======== end loop ========\n+\n+  \/\/ It was a real error; we must depend on the caller to finish the job.\n+  \/\/ Register rdx = -1 * number of *remaining* oops, r14 = *total* oops.\n+  \/\/ Emit GC store barriers for the oops we have copied (r14 + rdx),\n+  \/\/ and report their number to the caller.\n+  assert_different_registers(rax, r14_length, count, to, end_to, rcx, rscratch1);\n+  Label L_post_barrier;\n+  __ addptr(r14_length, count);     \/\/ K = (original - remaining) oops\n+  __ movptr(rax, r14_length);       \/\/ save the value\n+  __ notptr(rax);                   \/\/ report (-1^K) to caller (does not affect flags)\n+  __ jccb(Assembler::notZero, L_post_barrier);\n+  __ jmp(L_done); \/\/ K == 0, nothing was copied, skip post barrier\n+\n+  \/\/ Come here on success only.\n+  __ BIND(L_do_card_marks);\n+  __ xorptr(rax, rax);              \/\/ return 0 on success\n+\n+  __ BIND(L_post_barrier);\n+  bs->arraycopy_epilogue(_masm, decorators, type, from, to, r14_length);\n+\n+  \/\/ Common exit point (success or failure).\n+  __ BIND(L_done);\n+  __ movptr(r13, Address(rsp, saved_r13_offset * wordSize));\n+  __ movptr(r14, Address(rsp, saved_r14_offset * wordSize));\n+  __ movptr(r10, Address(rsp, saved_r10_offset * wordSize));\n+  restore_arg_regs();\n+  INC_COUNTER_NP(SharedRuntime::_checkcast_array_copy_ctr, rscratch1); \/\/ Update counter after rscratch1 is free\n+  __ leave(); \/\/ required for proper stackwalking of RuntimeStub frame\n+  __ ret(0);\n+\n+  return start;\n+}\n+\n+\n+\/\/  Generate 'unsafe' array copy stub\n+\/\/  Though just as safe as the other stubs, it takes an unscaled\n+\/\/  size_t argument instead of an element count.\n+\/\/\n+\/\/  Input:\n+\/\/    c_rarg0   - source array address\n+\/\/    c_rarg1   - destination array address\n+\/\/    c_rarg2   - byte count, treated as ssize_t, can be zero\n+\/\/\n+\/\/ Examines the alignment of the operands and dispatches\n+\/\/ to a long, int, short, or byte copy loop.\n+\/\/\n+address StubGenerator::generate_unsafe_copy(const char *name,\n+                                            address byte_copy_entry, address short_copy_entry,\n+                                            address int_copy_entry, address long_copy_entry) {\n+\n+  Label L_long_aligned, L_int_aligned, L_short_aligned;\n+\n+  \/\/ Input registers (before setup_arg_regs)\n+  const Register from        = c_rarg0;  \/\/ source array address\n+  const Register to          = c_rarg1;  \/\/ destination array address\n+  const Register size        = c_rarg2;  \/\/ byte count (size_t)\n+\n+  \/\/ Register used as a temp\n+  const Register bits        = rax;      \/\/ test copy of low bits\n+\n+  __ align(CodeEntryAlignment);\n+  StubCodeMark mark(this, \"StubRoutines\", name);\n+  address start = __ pc();\n+\n+  __ enter(); \/\/ required for proper stackwalking of RuntimeStub frame\n+\n+  \/\/ bump this on entry, not on exit:\n+  INC_COUNTER_NP(SharedRuntime::_unsafe_array_copy_ctr, rscratch1);\n+\n+  __ mov(bits, from);\n+  __ orptr(bits, to);\n+  __ orptr(bits, size);\n+\n+  __ testb(bits, BytesPerLong-1);\n+  __ jccb(Assembler::zero, L_long_aligned);\n+\n+  __ testb(bits, BytesPerInt-1);\n+  __ jccb(Assembler::zero, L_int_aligned);\n+\n+  __ testb(bits, BytesPerShort-1);\n+  __ jump_cc(Assembler::notZero, RuntimeAddress(byte_copy_entry));\n+\n+  __ BIND(L_short_aligned);\n+  __ shrptr(size, LogBytesPerShort); \/\/ size => short_count\n+  __ jump(RuntimeAddress(short_copy_entry));\n+\n+  __ BIND(L_int_aligned);\n+  __ shrptr(size, LogBytesPerInt); \/\/ size => int_count\n+  __ jump(RuntimeAddress(int_copy_entry));\n+\n+  __ BIND(L_long_aligned);\n+  __ shrptr(size, LogBytesPerLong); \/\/ size => qword_count\n+  __ jump(RuntimeAddress(long_copy_entry));\n+\n+  return start;\n+}\n+\n+\n+\/\/ Perform range checks on the proposed arraycopy.\n+\/\/ Kills temp, but nothing else.\n+\/\/ Also, clean the sign bits of src_pos and dst_pos.\n+void StubGenerator::arraycopy_range_checks(Register src,     \/\/ source array oop (c_rarg0)\n+                                           Register src_pos, \/\/ source position (c_rarg1)\n+                                           Register dst,     \/\/ destination array oo (c_rarg2)\n+                                           Register dst_pos, \/\/ destination position (c_rarg3)\n+                                           Register length,\n+                                           Register temp,\n+                                           Label& L_failed) {\n+  BLOCK_COMMENT(\"arraycopy_range_checks:\");\n+\n+  \/\/  if (src_pos + length > arrayOop(src)->length())  FAIL;\n+  __ movl(temp, length);\n+  __ addl(temp, src_pos);             \/\/ src_pos + length\n+  __ cmpl(temp, Address(src, arrayOopDesc::length_offset_in_bytes()));\n+  __ jcc(Assembler::above, L_failed);\n+\n+  \/\/  if (dst_pos + length > arrayOop(dst)->length())  FAIL;\n+  __ movl(temp, length);\n+  __ addl(temp, dst_pos);             \/\/ dst_pos + length\n+  __ cmpl(temp, Address(dst, arrayOopDesc::length_offset_in_bytes()));\n+  __ jcc(Assembler::above, L_failed);\n+\n+  \/\/ Have to clean up high 32-bits of 'src_pos' and 'dst_pos'.\n+  \/\/ Move with sign extension can be used since they are positive.\n+  __ movslq(src_pos, src_pos);\n+  __ movslq(dst_pos, dst_pos);\n+\n+  BLOCK_COMMENT(\"arraycopy_range_checks done\");\n+}\n+\n+\n+\/\/  Generate generic array copy stubs\n+\/\/\n+\/\/  Input:\n+\/\/    c_rarg0    -  src oop\n+\/\/    c_rarg1    -  src_pos (32-bits)\n+\/\/    c_rarg2    -  dst oop\n+\/\/    c_rarg3    -  dst_pos (32-bits)\n+\/\/ not Win64\n+\/\/    c_rarg4    -  element count (32-bits)\n+\/\/ Win64\n+\/\/    rsp+40     -  element count (32-bits)\n+\/\/\n+\/\/  Output:\n+\/\/    rax ==  0  -  success\n+\/\/    rax == -1^K - failure, where K is partial transfer count\n+\/\/\n+address StubGenerator::generate_generic_copy(const char *name,\n+                                             address byte_copy_entry, address short_copy_entry,\n+                                             address int_copy_entry, address oop_copy_entry,\n+                                             address long_copy_entry, address checkcast_copy_entry) {\n+\n+  Label L_failed, L_failed_0, L_objArray;\n+  Label L_copy_shorts, L_copy_ints, L_copy_longs;\n+\n+  \/\/ Input registers\n+  const Register src        = c_rarg0;  \/\/ source array oop\n+  const Register src_pos    = c_rarg1;  \/\/ source position\n+  const Register dst        = c_rarg2;  \/\/ destination array oop\n+  const Register dst_pos    = c_rarg3;  \/\/ destination position\n+#ifndef _WIN64\n+  const Register length     = c_rarg4;\n+  const Register rklass_tmp = r9;  \/\/ load_klass\n+#else\n+  const Address  length(rsp, 7 * wordSize);  \/\/ elements count is on stack on Win64\n+  const Register rklass_tmp = rdi;  \/\/ load_klass\n+#endif\n+\n+  { int modulus = CodeEntryAlignment;\n+    int target  = modulus - 5; \/\/ 5 = sizeof jmp(L_failed)\n+    int advance = target - (__ offset() % modulus);\n+    if (advance < 0)  advance += modulus;\n+    if (advance > 0)  __ nop(advance);\n+  }\n+  StubCodeMark mark(this, \"StubRoutines\", name);\n+\n+  \/\/ Short-hop target to L_failed.  Makes for denser prologue code.\n+  __ BIND(L_failed_0);\n+  __ jmp(L_failed);\n+  assert(__ offset() % CodeEntryAlignment == 0, \"no further alignment needed\");\n+\n+  __ align(CodeEntryAlignment);\n+  address start = __ pc();\n+\n+  __ enter(); \/\/ required for proper stackwalking of RuntimeStub frame\n+\n+#ifdef _WIN64\n+  __ push(rklass_tmp); \/\/ rdi is callee-save on Windows\n+#endif\n+\n+  \/\/ bump this on entry, not on exit:\n+  INC_COUNTER_NP(SharedRuntime::_generic_array_copy_ctr, rscratch1);\n+\n+  \/\/-----------------------------------------------------------------------\n+  \/\/ Assembler stub will be used for this call to arraycopy\n+  \/\/ if the following conditions are met:\n+  \/\/\n+  \/\/ (1) src and dst must not be null.\n+  \/\/ (2) src_pos must not be negative.\n+  \/\/ (3) dst_pos must not be negative.\n+  \/\/ (4) length  must not be negative.\n+  \/\/ (5) src klass and dst klass should be the same and not NULL.\n+  \/\/ (6) src and dst should be arrays.\n+  \/\/ (7) src_pos + length must not exceed length of src.\n+  \/\/ (8) dst_pos + length must not exceed length of dst.\n+  \/\/\n+\n+  \/\/  if (src == NULL) return -1;\n+  __ testptr(src, src);         \/\/ src oop\n+  size_t j1off = __ offset();\n+  __ jccb(Assembler::zero, L_failed_0);\n+\n+  \/\/  if (src_pos < 0) return -1;\n+  __ testl(src_pos, src_pos); \/\/ src_pos (32-bits)\n+  __ jccb(Assembler::negative, L_failed_0);\n+\n+  \/\/  if (dst == NULL) return -1;\n+  __ testptr(dst, dst);         \/\/ dst oop\n+  __ jccb(Assembler::zero, L_failed_0);\n+\n+  \/\/  if (dst_pos < 0) return -1;\n+  __ testl(dst_pos, dst_pos); \/\/ dst_pos (32-bits)\n+  size_t j4off = __ offset();\n+  __ jccb(Assembler::negative, L_failed_0);\n+\n+  \/\/ The first four tests are very dense code,\n+  \/\/ but not quite dense enough to put four\n+  \/\/ jumps in a 16-byte instruction fetch buffer.\n+  \/\/ That's good, because some branch predicters\n+  \/\/ do not like jumps so close together.\n+  \/\/ Make sure of this.\n+  guarantee(((j1off ^ j4off) & ~15) != 0, \"I$ line of 1st & 4th jumps\");\n+\n+  \/\/ registers used as temp\n+  const Register r11_length    = r11; \/\/ elements count to copy\n+  const Register r10_src_klass = r10; \/\/ array klass\n+\n+  \/\/  if (length < 0) return -1;\n+  __ movl(r11_length, length);        \/\/ length (elements count, 32-bits value)\n+  __ testl(r11_length, r11_length);\n+  __ jccb(Assembler::negative, L_failed_0);\n+\n+  __ load_klass(r10_src_klass, src, rklass_tmp);\n+#ifdef ASSERT\n+  \/\/  assert(src->klass() != NULL);\n+  {\n+    BLOCK_COMMENT(\"assert klasses not null {\");\n+    Label L1, L2;\n+    __ testptr(r10_src_klass, r10_src_klass);\n+    __ jcc(Assembler::notZero, L2);   \/\/ it is broken if klass is NULL\n+    __ bind(L1);\n+    __ stop(\"broken null klass\");\n+    __ bind(L2);\n+    __ load_klass(rax, dst, rklass_tmp);\n+    __ cmpq(rax, 0);\n+    __ jcc(Assembler::equal, L1);     \/\/ this would be broken also\n+    BLOCK_COMMENT(\"} assert klasses not null done\");\n+  }\n+#endif\n+\n+  \/\/ Load layout helper (32-bits)\n+  \/\/\n+  \/\/  |array_tag|     | header_size | element_type |     |log2_element_size|\n+  \/\/ 32        30    24            16              8     2                 0\n+  \/\/\n+  \/\/   array_tag: typeArray = 0x3, objArray = 0x2, non-array = 0x0\n+  \/\/\n+\n+  const int lh_offset = in_bytes(Klass::layout_helper_offset());\n+\n+  \/\/ Handle objArrays completely differently...\n+  const jint objArray_lh = Klass::array_layout_helper(T_OBJECT);\n+  __ cmpl(Address(r10_src_klass, lh_offset), objArray_lh);\n+  __ jcc(Assembler::equal, L_objArray);\n+\n+  \/\/  if (src->klass() != dst->klass()) return -1;\n+  __ load_klass(rax, dst, rklass_tmp);\n+  __ cmpq(r10_src_klass, rax);\n+  __ jcc(Assembler::notEqual, L_failed);\n+\n+  const Register rax_lh = rax;  \/\/ layout helper\n+  __ movl(rax_lh, Address(r10_src_klass, lh_offset));\n+\n+  \/\/  if (!src->is_Array()) return -1;\n+  __ cmpl(rax_lh, Klass::_lh_neutral_value);\n+  __ jcc(Assembler::greaterEqual, L_failed);\n+\n+  \/\/ At this point, it is known to be a typeArray (array_tag 0x3).\n+#ifdef ASSERT\n+  {\n+    BLOCK_COMMENT(\"assert primitive array {\");\n+    Label L;\n+    __ cmpl(rax_lh, (Klass::_lh_array_tag_type_value << Klass::_lh_array_tag_shift));\n+    __ jcc(Assembler::greaterEqual, L);\n+    __ stop(\"must be a primitive array\");\n+    __ bind(L);\n+    BLOCK_COMMENT(\"} assert primitive array done\");\n+  }\n+#endif\n+\n+  arraycopy_range_checks(src, src_pos, dst, dst_pos, r11_length,\n+                         r10, L_failed);\n+\n+  \/\/ TypeArrayKlass\n+  \/\/\n+  \/\/ src_addr = (src + array_header_in_bytes()) + (src_pos << log2elemsize);\n+  \/\/ dst_addr = (dst + array_header_in_bytes()) + (dst_pos << log2elemsize);\n+  \/\/\n+\n+  const Register r10_offset = r10;    \/\/ array offset\n+  const Register rax_elsize = rax_lh; \/\/ element size\n+\n+  __ movl(r10_offset, rax_lh);\n+  __ shrl(r10_offset, Klass::_lh_header_size_shift);\n+  __ andptr(r10_offset, Klass::_lh_header_size_mask);   \/\/ array_offset\n+  __ addptr(src, r10_offset);           \/\/ src array offset\n+  __ addptr(dst, r10_offset);           \/\/ dst array offset\n+  BLOCK_COMMENT(\"choose copy loop based on element size\");\n+  __ andl(rax_lh, Klass::_lh_log2_element_size_mask); \/\/ rax_lh -> rax_elsize\n+\n+#ifdef _WIN64\n+  __ pop(rklass_tmp); \/\/ Restore callee-save rdi\n+#endif\n+\n+  \/\/ next registers should be set before the jump to corresponding stub\n+  const Register from     = c_rarg0;  \/\/ source array address\n+  const Register to       = c_rarg1;  \/\/ destination array address\n+  const Register count    = c_rarg2;  \/\/ elements count\n+\n+  \/\/ 'from', 'to', 'count' registers should be set in such order\n+  \/\/ since they are the same as 'src', 'src_pos', 'dst'.\n+\n+  __ cmpl(rax_elsize, 0);\n+  __ jccb(Assembler::notEqual, L_copy_shorts);\n+  __ lea(from, Address(src, src_pos, Address::times_1, 0));\/\/ src_addr\n+  __ lea(to,   Address(dst, dst_pos, Address::times_1, 0));\/\/ dst_addr\n+  __ movl2ptr(count, r11_length); \/\/ length\n+  __ jump(RuntimeAddress(byte_copy_entry));\n+\n+__ BIND(L_copy_shorts);\n+  __ cmpl(rax_elsize, LogBytesPerShort);\n+  __ jccb(Assembler::notEqual, L_copy_ints);\n+  __ lea(from, Address(src, src_pos, Address::times_2, 0));\/\/ src_addr\n+  __ lea(to,   Address(dst, dst_pos, Address::times_2, 0));\/\/ dst_addr\n+  __ movl2ptr(count, r11_length); \/\/ length\n+  __ jump(RuntimeAddress(short_copy_entry));\n+\n+__ BIND(L_copy_ints);\n+  __ cmpl(rax_elsize, LogBytesPerInt);\n+  __ jccb(Assembler::notEqual, L_copy_longs);\n+  __ lea(from, Address(src, src_pos, Address::times_4, 0));\/\/ src_addr\n+  __ lea(to,   Address(dst, dst_pos, Address::times_4, 0));\/\/ dst_addr\n+  __ movl2ptr(count, r11_length); \/\/ length\n+  __ jump(RuntimeAddress(int_copy_entry));\n+\n+__ BIND(L_copy_longs);\n+#ifdef ASSERT\n+  {\n+    BLOCK_COMMENT(\"assert long copy {\");\n+    Label L;\n+    __ cmpl(rax_elsize, LogBytesPerLong);\n+    __ jcc(Assembler::equal, L);\n+    __ stop(\"must be long copy, but elsize is wrong\");\n+    __ bind(L);\n+    BLOCK_COMMENT(\"} assert long copy done\");\n+  }\n+#endif\n+  __ lea(from, Address(src, src_pos, Address::times_8, 0));\/\/ src_addr\n+  __ lea(to,   Address(dst, dst_pos, Address::times_8, 0));\/\/ dst_addr\n+  __ movl2ptr(count, r11_length); \/\/ length\n+  __ jump(RuntimeAddress(long_copy_entry));\n+\n+  \/\/ ObjArrayKlass\n+__ BIND(L_objArray);\n+  \/\/ live at this point:  r10_src_klass, r11_length, src[_pos], dst[_pos]\n+\n+  Label L_plain_copy, L_checkcast_copy;\n+  \/\/  test array classes for subtyping\n+  __ load_klass(rax, dst, rklass_tmp);\n+  __ cmpq(r10_src_klass, rax); \/\/ usual case is exact equality\n+  __ jcc(Assembler::notEqual, L_checkcast_copy);\n+\n+  \/\/ Identically typed arrays can be copied without element-wise checks.\n+  arraycopy_range_checks(src, src_pos, dst, dst_pos, r11_length,\n+                         r10, L_failed);\n+\n+  __ lea(from, Address(src, src_pos, TIMES_OOP,\n+               arrayOopDesc::base_offset_in_bytes(T_OBJECT))); \/\/ src_addr\n+  __ lea(to,   Address(dst, dst_pos, TIMES_OOP,\n+               arrayOopDesc::base_offset_in_bytes(T_OBJECT))); \/\/ dst_addr\n+  __ movl2ptr(count, r11_length); \/\/ length\n+__ BIND(L_plain_copy);\n+#ifdef _WIN64\n+  __ pop(rklass_tmp); \/\/ Restore callee-save rdi\n+#endif\n+  __ jump(RuntimeAddress(oop_copy_entry));\n+\n+__ BIND(L_checkcast_copy);\n+  \/\/ live at this point:  r10_src_klass, r11_length, rax (dst_klass)\n+  {\n+    \/\/ Before looking at dst.length, make sure dst is also an objArray.\n+    __ cmpl(Address(rax, lh_offset), objArray_lh);\n+    __ jcc(Assembler::notEqual, L_failed);\n+\n+    \/\/ It is safe to examine both src.length and dst.length.\n+    arraycopy_range_checks(src, src_pos, dst, dst_pos, r11_length,\n+                           rax, L_failed);\n+\n+    const Register r11_dst_klass = r11;\n+    __ load_klass(r11_dst_klass, dst, rklass_tmp); \/\/ reload\n+\n+    \/\/ Marshal the base address arguments now, freeing registers.\n+    __ lea(from, Address(src, src_pos, TIMES_OOP,\n+                 arrayOopDesc::base_offset_in_bytes(T_OBJECT)));\n+    __ lea(to,   Address(dst, dst_pos, TIMES_OOP,\n+                 arrayOopDesc::base_offset_in_bytes(T_OBJECT)));\n+    __ movl(count, length);           \/\/ length (reloaded)\n+    Register sco_temp = c_rarg3;      \/\/ this register is free now\n+    assert_different_registers(from, to, count, sco_temp,\n+                               r11_dst_klass, r10_src_klass);\n+    assert_clean_int(count, sco_temp);\n+\n+    \/\/ Generate the type check.\n+    const int sco_offset = in_bytes(Klass::super_check_offset_offset());\n+    __ movl(sco_temp, Address(r11_dst_klass, sco_offset));\n+    assert_clean_int(sco_temp, rax);\n+    generate_type_check(r10_src_klass, sco_temp, r11_dst_klass, L_plain_copy);\n+\n+    \/\/ Fetch destination element klass from the ObjArrayKlass header.\n+    int ek_offset = in_bytes(ObjArrayKlass::element_klass_offset());\n+    __ movptr(r11_dst_klass, Address(r11_dst_klass, ek_offset));\n+    __ movl(  sco_temp,      Address(r11_dst_klass, sco_offset));\n+    assert_clean_int(sco_temp, rax);\n+\n+#ifdef _WIN64\n+    __ pop(rklass_tmp); \/\/ Restore callee-save rdi\n+#endif\n+\n+    \/\/ the checkcast_copy loop needs two extra arguments:\n+    assert(c_rarg3 == sco_temp, \"#3 already in place\");\n+    \/\/ Set up arguments for checkcast_copy_entry.\n+    setup_arg_regs(4);\n+    __ movptr(r8, r11_dst_klass);  \/\/ dst.klass.element_klass, r8 is c_rarg4 on Linux\/Solaris\n+    __ jump(RuntimeAddress(checkcast_copy_entry));\n+  }\n+\n+__ BIND(L_failed);\n+#ifdef _WIN64\n+  __ pop(rklass_tmp); \/\/ Restore callee-save rdi\n+#endif\n+  __ xorptr(rax, rax);\n+  __ notptr(rax); \/\/ return -1\n+  __ leave();   \/\/ required for proper stackwalking of RuntimeStub frame\n+  __ ret(0);\n+\n+  return start;\n+}\n+\n+#undef __\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_arraycopy.cpp","additions":2546,"deletions":0,"binary":false,"changes":2546,"status":"added"},{"patch":"@@ -0,0 +1,236 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"stubGenerator_x86_64.hpp\"\n+\n+\/\/ Constants for libm trigonometric stubs\n+\n+ATTRIBUTE_ALIGNED(8) juint _ONE[] = {\n+    0x00000000UL, 0x3ff00000UL\n+};\n+address StubGenerator::ONE = (address)_ONE;\n+\n+ATTRIBUTE_ALIGNED(16) juint _ONEHALF[] = {\n+    0x00000000UL, 0x3fe00000UL, 0x00000000UL, 0x3fe00000UL\n+};\n+address StubGenerator::ONEHALF = (address)_ONEHALF;\n+\n+ATTRIBUTE_ALIGNED(8) juint _SIGN_MASK[] = {\n+    0x00000000UL, 0x80000000UL\n+};\n+address StubGenerator::SIGN_MASK = (address)_SIGN_MASK;\n+\n+ATTRIBUTE_ALIGNED(8) juint _TWO_POW_55[] = {\n+    0x00000000UL, 0x43600000UL\n+};\n+address StubGenerator::TWO_POW_55 = (address)_TWO_POW_55;\n+\n+ATTRIBUTE_ALIGNED(8) juint _TWO_POW_M55[] = {\n+    0x00000000UL, 0x3c800000UL\n+};\n+address StubGenerator::TWO_POW_M55 = (address)_TWO_POW_M55;\n+\n+ATTRIBUTE_ALIGNED(16) juint _SHIFTER[] = {\n+    0x00000000UL, 0x43380000UL, 0x00000000UL, 0x43380000UL\n+};\n+address StubGenerator::SHIFTER = (address)_SHIFTER;\n+\n+ATTRIBUTE_ALIGNED(4) juint _ZERO[] = {\n+    0x00000000UL, 0x00000000UL\n+};\n+address StubGenerator::ZERO = (address)_ZERO;\n+\n+ATTRIBUTE_ALIGNED(16) juint _SC_1[] = {\n+    0x55555555UL, 0xbfc55555UL, 0x00000000UL, 0xbfe00000UL\n+};\n+address StubGenerator::SC_1 = (address)_SC_1;\n+\n+ATTRIBUTE_ALIGNED(16) juint _SC_2[] = {\n+    0x11111111UL, 0x3f811111UL, 0x55555555UL, 0x3fa55555UL\n+};\n+address StubGenerator::SC_2 = (address)_SC_2;\n+\n+ATTRIBUTE_ALIGNED(16) juint _SC_3[] = {\n+    0x1a01a01aUL, 0xbf2a01a0UL, 0x16c16c17UL, 0xbf56c16cUL\n+};\n+address StubGenerator::SC_3 = (address)_SC_3;\n+\n+ATTRIBUTE_ALIGNED(16) juint _SC_4[] = {\n+    0xa556c734UL, 0x3ec71de3UL, 0x1a01a01aUL, 0x3efa01a0UL\n+};\n+address StubGenerator::SC_4 = (address)_SC_4;\n+\n+ATTRIBUTE_ALIGNED(8) juint _PI_4[] = {\n+    0x40000000UL, 0x3fe921fbUL, 0x18469899UL, 0x3e64442dUL\n+};\n+address StubGenerator::PI_4 = (address)_PI_4;\n+\n+ATTRIBUTE_ALIGNED(8) juint _PI32INV[] = {\n+    0x6dc9c883UL, 0x40245f30UL\n+};\n+address StubGenerator::PI32INV = (address)_PI32INV;\n+\n+ATTRIBUTE_ALIGNED(8) juint _NEG_ZERO[] = {\n+    0x00000000UL, 0x80000000UL\n+};\n+address StubGenerator::NEG_ZERO = (address)_NEG_ZERO;\n+\n+ATTRIBUTE_ALIGNED(8) juint _P_1[] = {\n+    0x54400000UL, 0x3fb921fbUL\n+};\n+address StubGenerator::P_1 = (address)_P_1;\n+\n+ATTRIBUTE_ALIGNED(16) juint _P_2[] = {\n+    0x1a600000UL, 0x3d90b461UL, 0x1a600000UL, 0x3d90b461UL\n+};\n+address StubGenerator::P_2 = (address)_P_2;\n+\n+ATTRIBUTE_ALIGNED(8) juint _P_3[] = {\n+    0x2e037073UL, 0x3b63198aUL\n+};\n+address StubGenerator::P_3 = (address)_P_3;\n+\n+\n+ATTRIBUTE_ALIGNED(16) juint _PI_INV_TABLE[] = {\n+    0x00000000UL, 0x00000000UL, 0xa2f9836eUL, 0x4e441529UL, 0xfc2757d1UL,\n+    0xf534ddc0UL, 0xdb629599UL, 0x3c439041UL, 0xfe5163abUL, 0xdebbc561UL,\n+    0xb7246e3aUL, 0x424dd2e0UL, 0x06492eeaUL, 0x09d1921cUL, 0xfe1deb1cUL,\n+    0xb129a73eUL, 0xe88235f5UL, 0x2ebb4484UL, 0xe99c7026UL, 0xb45f7e41UL,\n+    0x3991d639UL, 0x835339f4UL, 0x9c845f8bUL, 0xbdf9283bUL, 0x1ff897ffUL,\n+    0xde05980fUL, 0xef2f118bUL, 0x5a0a6d1fUL, 0x6d367ecfUL, 0x27cb09b7UL,\n+    0x4f463f66UL, 0x9e5fea2dUL, 0x7527bac7UL, 0xebe5f17bUL, 0x3d0739f7UL,\n+    0x8a5292eaUL, 0x6bfb5fb1UL, 0x1f8d5d08UL, 0x56033046UL, 0xfc7b6babUL,\n+    0xf0cfbc21UL\n+};\n+address StubGenerator::PI_INV_TABLE = (address)_PI_INV_TABLE;\n+\n+\n+ATTRIBUTE_ALIGNED(16) juint _Ctable[] = {\n+    0x00000000UL, 0x00000000UL, 0x00000000UL, 0x00000000UL, 0x00000000UL,\n+    0x00000000UL, 0x00000000UL, 0x3ff00000UL, 0x176d6d31UL, 0xbf73b92eUL,\n+    0xbc29b42cUL, 0x3fb917a6UL, 0xe0000000UL, 0xbc3e2718UL, 0x00000000UL,\n+    0x3ff00000UL, 0x011469fbUL, 0xbf93ad06UL, 0x3c69a60bUL, 0x3fc8f8b8UL,\n+    0xc0000000UL, 0xbc626d19UL, 0x00000000UL, 0x3ff00000UL, 0x939d225aUL,\n+    0xbfa60beaUL, 0x2ed59f06UL, 0x3fd29406UL, 0xa0000000UL, 0xbc75d28dUL,\n+    0x00000000UL, 0x3ff00000UL, 0x866b95cfUL, 0xbfb37ca1UL, 0xa6aea963UL,\n+    0x3fd87de2UL, 0xe0000000UL, 0xbc672cedUL, 0x00000000UL, 0x3ff00000UL,\n+    0x73fa1279UL, 0xbfbe3a68UL, 0x3806f63bUL, 0x3fde2b5dUL, 0x20000000UL,\n+    0x3c5e0d89UL, 0x00000000UL, 0x3ff00000UL, 0x5bc57974UL, 0xbfc59267UL,\n+    0x39ae68c8UL, 0x3fe1c73bUL, 0x20000000UL, 0x3c8b25ddUL, 0x00000000UL,\n+    0x3ff00000UL, 0x53aba2fdUL, 0xbfcd0dfeUL, 0x25091dd6UL, 0x3fe44cf3UL,\n+    0x20000000UL, 0x3c68076aUL, 0x00000000UL, 0x3ff00000UL, 0x99fcef32UL,\n+    0x3fca8279UL, 0x667f3bcdUL, 0x3fe6a09eUL, 0x20000000UL, 0xbc8bdd34UL,\n+    0x00000000UL, 0x3fe00000UL, 0x94247758UL, 0x3fc133ccUL, 0x6b151741UL,\n+    0x3fe8bc80UL, 0x20000000UL, 0xbc82c5e1UL, 0x00000000UL, 0x3fe00000UL,\n+    0x9ae68c87UL, 0x3fac73b3UL, 0x290ea1a3UL, 0x3fea9b66UL, 0xe0000000UL,\n+    0x3c39f630UL, 0x00000000UL, 0x3fe00000UL, 0x7f909c4eUL, 0xbf9d4a2cUL,\n+    0xf180bdb1UL, 0x3fec38b2UL, 0x80000000UL, 0xbc76e0b1UL, 0x00000000UL,\n+    0x3fe00000UL, 0x65455a75UL, 0xbfbe0875UL, 0xcf328d46UL, 0x3fed906bUL,\n+    0x20000000UL, 0x3c7457e6UL, 0x00000000UL, 0x3fe00000UL, 0x76acf82dUL,\n+    0x3fa4a031UL, 0x56c62ddaUL, 0x3fee9f41UL, 0xe0000000UL, 0x3c8760b1UL,\n+    0x00000000UL, 0x3fd00000UL, 0x0e5967d5UL, 0xbfac1d1fUL, 0xcff75cb0UL,\n+    0x3fef6297UL, 0x20000000UL, 0x3c756217UL, 0x00000000UL, 0x3fd00000UL,\n+    0x0f592f50UL, 0xbf9ba165UL, 0xa3d12526UL, 0x3fefd88dUL, 0x40000000UL,\n+    0xbc887df6UL, 0x00000000UL, 0x3fc00000UL, 0x00000000UL, 0x00000000UL,\n+    0x00000000UL, 0x3ff00000UL, 0x00000000UL, 0x00000000UL, 0x00000000UL,\n+    0x00000000UL, 0x0f592f50UL, 0x3f9ba165UL, 0xa3d12526UL, 0x3fefd88dUL,\n+    0x40000000UL, 0xbc887df6UL, 0x00000000UL, 0xbfc00000UL, 0x0e5967d5UL,\n+    0x3fac1d1fUL, 0xcff75cb0UL, 0x3fef6297UL, 0x20000000UL, 0x3c756217UL,\n+    0x00000000UL, 0xbfd00000UL, 0x76acf82dUL, 0xbfa4a031UL, 0x56c62ddaUL,\n+    0x3fee9f41UL, 0xe0000000UL, 0x3c8760b1UL, 0x00000000UL, 0xbfd00000UL,\n+    0x65455a75UL, 0x3fbe0875UL, 0xcf328d46UL, 0x3fed906bUL, 0x20000000UL,\n+    0x3c7457e6UL, 0x00000000UL, 0xbfe00000UL, 0x7f909c4eUL, 0x3f9d4a2cUL,\n+    0xf180bdb1UL, 0x3fec38b2UL, 0x80000000UL, 0xbc76e0b1UL, 0x00000000UL,\n+    0xbfe00000UL, 0x9ae68c87UL, 0xbfac73b3UL, 0x290ea1a3UL, 0x3fea9b66UL,\n+    0xe0000000UL, 0x3c39f630UL, 0x00000000UL, 0xbfe00000UL, 0x94247758UL,\n+    0xbfc133ccUL, 0x6b151741UL, 0x3fe8bc80UL, 0x20000000UL, 0xbc82c5e1UL,\n+    0x00000000UL, 0xbfe00000UL, 0x99fcef32UL, 0xbfca8279UL, 0x667f3bcdUL,\n+    0x3fe6a09eUL, 0x20000000UL, 0xbc8bdd34UL, 0x00000000UL, 0xbfe00000UL,\n+    0x53aba2fdUL, 0x3fcd0dfeUL, 0x25091dd6UL, 0x3fe44cf3UL, 0x20000000UL,\n+    0x3c68076aUL, 0x00000000UL, 0xbff00000UL, 0x5bc57974UL, 0x3fc59267UL,\n+    0x39ae68c8UL, 0x3fe1c73bUL, 0x20000000UL, 0x3c8b25ddUL, 0x00000000UL,\n+    0xbff00000UL, 0x73fa1279UL, 0x3fbe3a68UL, 0x3806f63bUL, 0x3fde2b5dUL,\n+    0x20000000UL, 0x3c5e0d89UL, 0x00000000UL, 0xbff00000UL, 0x866b95cfUL,\n+    0x3fb37ca1UL, 0xa6aea963UL, 0x3fd87de2UL, 0xe0000000UL, 0xbc672cedUL,\n+    0x00000000UL, 0xbff00000UL, 0x939d225aUL, 0x3fa60beaUL, 0x2ed59f06UL,\n+    0x3fd29406UL, 0xa0000000UL, 0xbc75d28dUL, 0x00000000UL, 0xbff00000UL,\n+    0x011469fbUL, 0x3f93ad06UL, 0x3c69a60bUL, 0x3fc8f8b8UL, 0xc0000000UL,\n+    0xbc626d19UL, 0x00000000UL, 0xbff00000UL, 0x176d6d31UL, 0x3f73b92eUL,\n+    0xbc29b42cUL, 0x3fb917a6UL, 0xe0000000UL, 0xbc3e2718UL, 0x00000000UL,\n+    0xbff00000UL, 0x00000000UL, 0x00000000UL, 0x00000000UL, 0x00000000UL,\n+    0x00000000UL, 0x00000000UL, 0x00000000UL, 0xbff00000UL, 0x176d6d31UL,\n+    0x3f73b92eUL, 0xbc29b42cUL, 0xbfb917a6UL, 0xe0000000UL, 0x3c3e2718UL,\n+    0x00000000UL, 0xbff00000UL, 0x011469fbUL, 0x3f93ad06UL, 0x3c69a60bUL,\n+    0xbfc8f8b8UL, 0xc0000000UL, 0x3c626d19UL, 0x00000000UL, 0xbff00000UL,\n+    0x939d225aUL, 0x3fa60beaUL, 0x2ed59f06UL, 0xbfd29406UL, 0xa0000000UL,\n+    0x3c75d28dUL, 0x00000000UL, 0xbff00000UL, 0x866b95cfUL, 0x3fb37ca1UL,\n+    0xa6aea963UL, 0xbfd87de2UL, 0xe0000000UL, 0x3c672cedUL, 0x00000000UL,\n+    0xbff00000UL, 0x73fa1279UL, 0x3fbe3a68UL, 0x3806f63bUL, 0xbfde2b5dUL,\n+    0x20000000UL, 0xbc5e0d89UL, 0x00000000UL, 0xbff00000UL, 0x5bc57974UL,\n+    0x3fc59267UL, 0x39ae68c8UL, 0xbfe1c73bUL, 0x20000000UL, 0xbc8b25ddUL,\n+    0x00000000UL, 0xbff00000UL, 0x53aba2fdUL, 0x3fcd0dfeUL, 0x25091dd6UL,\n+    0xbfe44cf3UL, 0x20000000UL, 0xbc68076aUL, 0x00000000UL, 0xbff00000UL,\n+    0x99fcef32UL, 0xbfca8279UL, 0x667f3bcdUL, 0xbfe6a09eUL, 0x20000000UL,\n+    0x3c8bdd34UL, 0x00000000UL, 0xbfe00000UL, 0x94247758UL, 0xbfc133ccUL,\n+    0x6b151741UL, 0xbfe8bc80UL, 0x20000000UL, 0x3c82c5e1UL, 0x00000000UL,\n+    0xbfe00000UL, 0x9ae68c87UL, 0xbfac73b3UL, 0x290ea1a3UL, 0xbfea9b66UL,\n+    0xe0000000UL, 0xbc39f630UL, 0x00000000UL, 0xbfe00000UL, 0x7f909c4eUL,\n+    0x3f9d4a2cUL, 0xf180bdb1UL, 0xbfec38b2UL, 0x80000000UL, 0x3c76e0b1UL,\n+    0x00000000UL, 0xbfe00000UL, 0x65455a75UL, 0x3fbe0875UL, 0xcf328d46UL,\n+    0xbfed906bUL, 0x20000000UL, 0xbc7457e6UL, 0x00000000UL, 0xbfe00000UL,\n+    0x76acf82dUL, 0xbfa4a031UL, 0x56c62ddaUL, 0xbfee9f41UL, 0xe0000000UL,\n+    0xbc8760b1UL, 0x00000000UL, 0xbfd00000UL, 0x0e5967d5UL, 0x3fac1d1fUL,\n+    0xcff75cb0UL, 0xbfef6297UL, 0x20000000UL, 0xbc756217UL, 0x00000000UL,\n+    0xbfd00000UL, 0x0f592f50UL, 0x3f9ba165UL, 0xa3d12526UL, 0xbfefd88dUL,\n+    0x40000000UL, 0x3c887df6UL, 0x00000000UL, 0xbfc00000UL, 0x00000000UL,\n+    0x00000000UL, 0x00000000UL, 0xbff00000UL, 0x00000000UL, 0x00000000UL,\n+    0x00000000UL, 0x00000000UL, 0x0f592f50UL, 0xbf9ba165UL, 0xa3d12526UL,\n+    0xbfefd88dUL, 0x40000000UL, 0x3c887df6UL, 0x00000000UL, 0x3fc00000UL,\n+    0x0e5967d5UL, 0xbfac1d1fUL, 0xcff75cb0UL, 0xbfef6297UL, 0x20000000UL,\n+    0xbc756217UL, 0x00000000UL, 0x3fd00000UL, 0x76acf82dUL, 0x3fa4a031UL,\n+    0x56c62ddaUL, 0xbfee9f41UL, 0xe0000000UL, 0xbc8760b1UL, 0x00000000UL,\n+    0x3fd00000UL, 0x65455a75UL, 0xbfbe0875UL, 0xcf328d46UL, 0xbfed906bUL,\n+    0x20000000UL, 0xbc7457e6UL, 0x00000000UL, 0x3fe00000UL, 0x7f909c4eUL,\n+    0xbf9d4a2cUL, 0xf180bdb1UL, 0xbfec38b2UL, 0x80000000UL, 0x3c76e0b1UL,\n+    0x00000000UL, 0x3fe00000UL, 0x9ae68c87UL, 0x3fac73b3UL, 0x290ea1a3UL,\n+    0xbfea9b66UL, 0xe0000000UL, 0xbc39f630UL, 0x00000000UL, 0x3fe00000UL,\n+    0x94247758UL, 0x3fc133ccUL, 0x6b151741UL, 0xbfe8bc80UL, 0x20000000UL,\n+    0x3c82c5e1UL, 0x00000000UL, 0x3fe00000UL, 0x99fcef32UL, 0x3fca8279UL,\n+    0x667f3bcdUL, 0xbfe6a09eUL, 0x20000000UL, 0x3c8bdd34UL, 0x00000000UL,\n+    0x3fe00000UL, 0x53aba2fdUL, 0xbfcd0dfeUL, 0x25091dd6UL, 0xbfe44cf3UL,\n+    0x20000000UL, 0xbc68076aUL, 0x00000000UL, 0x3ff00000UL, 0x5bc57974UL,\n+    0xbfc59267UL, 0x39ae68c8UL, 0xbfe1c73bUL, 0x20000000UL, 0xbc8b25ddUL,\n+    0x00000000UL, 0x3ff00000UL, 0x73fa1279UL, 0xbfbe3a68UL, 0x3806f63bUL,\n+    0xbfde2b5dUL, 0x20000000UL, 0xbc5e0d89UL, 0x00000000UL, 0x3ff00000UL,\n+    0x866b95cfUL, 0xbfb37ca1UL, 0xa6aea963UL, 0xbfd87de2UL, 0xe0000000UL,\n+    0x3c672cedUL, 0x00000000UL, 0x3ff00000UL, 0x939d225aUL, 0xbfa60beaUL,\n+    0x2ed59f06UL, 0xbfd29406UL, 0xa0000000UL, 0x3c75d28dUL, 0x00000000UL,\n+    0x3ff00000UL, 0x011469fbUL, 0xbf93ad06UL, 0x3c69a60bUL, 0xbfc8f8b8UL,\n+    0xc0000000UL, 0x3c626d19UL, 0x00000000UL, 0x3ff00000UL, 0x176d6d31UL,\n+    0xbf73b92eUL, 0xbc29b42cUL, 0xbfb917a6UL, 0xe0000000UL, 0x3c3e2718UL,\n+    0x00000000UL, 0x3ff00000UL\n+};\n+address StubGenerator::Ctable = (address)_Ctable;\n+\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_constants.cpp","additions":236,"deletions":0,"binary":false,"changes":236,"status":"added"},{"patch":"@@ -0,0 +1,625 @@\n+\/*\n+ *  Copyright (c) 2016, 2021, Intel Corporation. All rights reserved.\n+ * Intel Math Library (LIBM) Source Code\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"macroAssembler_x86.hpp\"\n+#include \"stubGenerator_x86_64.hpp\"\n+\n+\/******************************************************************************\/\n+\/\/                     ALGORITHM DESCRIPTION - COS()\n+\/\/                     ---------------------\n+\/\/\n+\/\/     1. RANGE REDUCTION\n+\/\/\n+\/\/     We perform an initial range reduction from X to r with\n+\/\/\n+\/\/          X =~= N * pi\/32 + r\n+\/\/\n+\/\/     so that |r| <= pi\/64 + epsilon. We restrict inputs to those\n+\/\/     where |N| <= 932560. Beyond this, the range reduction is\n+\/\/     insufficiently accurate. For extremely small inputs,\n+\/\/     denormalization can occur internally, impacting performance.\n+\/\/     This means that the main path is actually only taken for\n+\/\/     2^-252 <= |X| < 90112.\n+\/\/\n+\/\/     To avoid branches, we perform the range reduction to full\n+\/\/     accuracy each time.\n+\/\/\n+\/\/          X - N * (P_1 + P_2 + P_3)\n+\/\/\n+\/\/     where P_1 and P_2 are 32-bit numbers (so multiplication by N\n+\/\/     is exact) and P_3 is a 53-bit number. Together, these\n+\/\/     approximate pi well enough for all cases in the restricted\n+\/\/     range.\n+\/\/\n+\/\/     The main reduction sequence is:\n+\/\/\n+\/\/             y = 32\/pi * x\n+\/\/             N = integer(y)\n+\/\/     (computed by adding and subtracting off SHIFTER)\n+\/\/\n+\/\/             m_1 = N * P_1\n+\/\/             m_2 = N * P_2\n+\/\/             r_1 = x - m_1\n+\/\/             r = r_1 - m_2\n+\/\/     (this r can be used for most of the calculation)\n+\/\/\n+\/\/             c_1 = r_1 - r\n+\/\/             m_3 = N * P_3\n+\/\/             c_2 = c_1 - m_2\n+\/\/             c = c_2 - m_3\n+\/\/\n+\/\/     2. MAIN ALGORITHM\n+\/\/\n+\/\/     The algorithm uses a table lookup based on B = M * pi \/ 32\n+\/\/     where M = N mod 64. The stored values are:\n+\/\/       sigma             closest power of 2 to cos(B)\n+\/\/       C_hl              53-bit cos(B) - sigma\n+\/\/       S_hi + S_lo       2 * 53-bit sin(B)\n+\/\/\n+\/\/     The computation is organized as follows:\n+\/\/\n+\/\/          sin(B + r + c) = [sin(B) + sigma * r] +\n+\/\/                           r * (cos(B) - sigma) +\n+\/\/                           sin(B) * [cos(r + c) - 1] +\n+\/\/                           cos(B) * [sin(r + c) - r]\n+\/\/\n+\/\/     which is approximately:\n+\/\/\n+\/\/          [S_hi + sigma * r] +\n+\/\/          C_hl * r +\n+\/\/          S_lo + S_hi * [(cos(r) - 1) - r * c] +\n+\/\/          (C_hl + sigma) * [(sin(r) - r) + c]\n+\/\/\n+\/\/     and this is what is actually computed. We separate this sum\n+\/\/     into four parts:\n+\/\/\n+\/\/          hi + med + pols + corr\n+\/\/\n+\/\/     where\n+\/\/\n+\/\/          hi       = S_hi + sigma r\n+\/\/          med      = C_hl * r\n+\/\/          pols     = S_hi * (cos(r) - 1) + (C_hl + sigma) * (sin(r) - r)\n+\/\/          corr     = S_lo + c * ((C_hl + sigma) - S_hi * r)\n+\/\/\n+\/\/     3. POLYNOMIAL\n+\/\/\n+\/\/     The polynomial S_hi * (cos(r) - 1) + (C_hl + sigma) *\n+\/\/     (sin(r) - r) can be rearranged freely, since it is quite\n+\/\/     small, so we exploit parallelism to the fullest.\n+\/\/\n+\/\/          psc4       =   SC_4 * r_1\n+\/\/          msc4       =   psc4 * r\n+\/\/          r2         =   r * r\n+\/\/          msc2       =   SC_2 * r2\n+\/\/          r4         =   r2 * r2\n+\/\/          psc3       =   SC_3 + msc4\n+\/\/          psc1       =   SC_1 + msc2\n+\/\/          msc3       =   r4 * psc3\n+\/\/          sincospols =   psc1 + msc3\n+\/\/          pols       =   sincospols *\n+\/\/                         <S_hi * r^2 | (C_hl + sigma) * r^3>\n+\/\/\n+\/\/     4. CORRECTION TERM\n+\/\/\n+\/\/     This is where the \"c\" component of the range reduction is\n+\/\/     taken into account; recall that just \"r\" is used for most of\n+\/\/     the calculation.\n+\/\/\n+\/\/          -c   = m_3 - c_2\n+\/\/          -d   = S_hi * r - (C_hl + sigma)\n+\/\/          corr = -c * -d + S_lo\n+\/\/\n+\/\/     5. COMPENSATED SUMMATIONS\n+\/\/\n+\/\/     The two successive compensated summations add up the high\n+\/\/     and medium parts, leaving just the low parts to add up at\n+\/\/     the end.\n+\/\/\n+\/\/          rs        =  sigma * r\n+\/\/          res_int   =  S_hi + rs\n+\/\/          k_0       =  S_hi - res_int\n+\/\/          k_2       =  k_0 + rs\n+\/\/          med       =  C_hl * r\n+\/\/          res_hi    =  res_int + med\n+\/\/          k_1       =  res_int - res_hi\n+\/\/          k_3       =  k_1 + med\n+\/\/\n+\/\/     6. FINAL SUMMATION\n+\/\/\n+\/\/     We now add up all the small parts:\n+\/\/\n+\/\/          res_lo = pols(hi) + pols(lo) + corr + k_1 + k_3\n+\/\/\n+\/\/     Now the overall result is just:\n+\/\/\n+\/\/          res_hi + res_lo\n+\/\/\n+\/\/     7. SMALL ARGUMENTS\n+\/\/\n+\/\/     Inputs with |X| < 2^-252 are treated specially as\n+\/\/     1 - |x|.\n+\/\/\n+\/\/ Special cases:\n+\/\/  cos(NaN) = quiet NaN, and raise invalid exception\n+\/\/  cos(INF) = NaN and raise invalid exception\n+\/\/  cos(0) = 1\n+\/\/\n+\/******************************************************************************\/\n+\n+#define __ _masm->\n+\n+address StubGenerator::generate_libmCos() {\n+  StubCodeMark mark(this, \"StubRoutines\", \"libmCos\");\n+  address start = __ pc();\n+\n+  Label L_2TAG_PACKET_0_0_1, L_2TAG_PACKET_1_0_1, L_2TAG_PACKET_2_0_1, L_2TAG_PACKET_3_0_1;\n+  Label L_2TAG_PACKET_4_0_1, L_2TAG_PACKET_5_0_1, L_2TAG_PACKET_6_0_1, L_2TAG_PACKET_7_0_1;\n+  Label L_2TAG_PACKET_8_0_1, L_2TAG_PACKET_9_0_1, L_2TAG_PACKET_10_0_1, L_2TAG_PACKET_11_0_1;\n+  Label L_2TAG_PACKET_12_0_1, L_2TAG_PACKET_13_0_1, B1_2, B1_4;\n+\n+  __ enter(); \/\/ required for proper stackwalking of RuntimeStub frame\n+\n+#ifdef _WIN64\n+  __ push(rsi);\n+  __ push(rdi);\n+#endif\n+\n+  __ push(rbx);\n+  __ subq(rsp, 16);\n+  __ movsd(Address(rsp, 8), xmm0);\n+\n+  __ bind(B1_2);\n+  __ movl(rax, Address(rsp, 12));\n+  __ movq(xmm1, ExternalAddress(PI32INV), rbx \/*rscratch*\/);    \/\/0x6dc9c883UL, 0x40245f30UL\n+  __ andl(rax, 2147418112);\n+  __ subl(rax, 808452096);\n+  __ cmpl(rax, 281346048);\n+  __ jcc(Assembler::above, L_2TAG_PACKET_0_0_1);\n+  __ mulsd(xmm1, xmm0);\n+  __ movdqu(xmm5, ExternalAddress(ONEHALF), rbx \/*rscratch*\/);    \/\/0x00000000UL, 0x3fe00000UL, 0x00000000UL, 0x3fe00000UL\n+  __ movq(xmm4, ExternalAddress(SIGN_MASK), rbx \/*rscratch*\/);    \/\/0x00000000UL, 0x80000000UL\n+  __ pand(xmm4, xmm0);\n+  __ por(xmm5, xmm4);\n+  __ addpd(xmm1, xmm5);\n+  __ cvttsd2sil(rdx, xmm1);\n+  __ cvtsi2sdl(xmm1, rdx);\n+  __ movdqu(xmm2, ExternalAddress(P_2), rbx \/*rscratch*\/);    \/\/0x1a600000UL, 0x3d90b461UL, 0x1a600000UL, 0x3d90b461UL\n+  __ movq(xmm3, ExternalAddress(P_1), rbx \/*rscratch*\/);    \/\/0x54400000UL, 0x3fb921fbUL\n+  __ mulsd(xmm3, xmm1);\n+  __ unpcklpd(xmm1, xmm1);\n+  __ addq(rdx, 1865232);\n+  __ movdqu(xmm4, xmm0);\n+  __ andq(rdx, 63);\n+  __ movdqu(xmm5, ExternalAddress(SC_4), rbx \/*rscratch*\/);    \/\/0xa556c734UL, 0x3ec71de3UL, 0x1a01a01aUL, 0x3efa01a0UL\n+  __ lea(rax, ExternalAddress(Ctable));\n+  __ shlq(rdx, 5);\n+  __ addq(rax, rdx);\n+  __ mulpd(xmm2, xmm1);\n+  __ subsd(xmm0, xmm3);\n+  __ mulsd(xmm1, ExternalAddress(P_3), rbx \/*rscratch*\/);    \/\/0x2e037073UL, 0x3b63198aUL\n+  __ subsd(xmm4, xmm3);\n+  __ movq(xmm7, Address(rax, 8));\n+  __ unpcklpd(xmm0, xmm0);\n+  __ movdqu(xmm3, xmm4);\n+  __ subsd(xmm4, xmm2);\n+  __ mulpd(xmm5, xmm0);\n+  __ subpd(xmm0, xmm2);\n+  __ movdqu(xmm6, ExternalAddress(SC_2), rbx \/*rscratch*\/);    \/\/0x11111111UL, 0x3f811111UL, 0x55555555UL, 0x3fa55555UL\n+  __ mulsd(xmm7, xmm4);\n+  __ subsd(xmm3, xmm4);\n+  __ mulpd(xmm5, xmm0);\n+  __ mulpd(xmm0, xmm0);\n+  __ subsd(xmm3, xmm2);\n+  __ movdqu(xmm2, Address(rax, 0));\n+  __ subsd(xmm1, xmm3);\n+  __ movq(xmm3, Address(rax, 24));\n+  __ addsd(xmm2, xmm3);\n+  __ subsd(xmm7, xmm2);\n+  __ mulsd(xmm2, xmm4);\n+  __ mulpd(xmm6, xmm0);\n+  __ mulsd(xmm3, xmm4);\n+  __ mulpd(xmm2, xmm0);\n+  __ mulpd(xmm0, xmm0);\n+  __ addpd(xmm5, ExternalAddress(SC_3), rbx \/*rscratch*\/);    \/\/0x1a01a01aUL, 0xbf2a01a0UL, 0x16c16c17UL, 0xbf56c16cUL\n+  __ mulsd(xmm4, Address(rax, 0));\n+  __ addpd(xmm6, ExternalAddress(SC_1), rbx \/*rscratch*\/);    \/\/0x55555555UL, 0xbfc55555UL, 0x00000000UL, 0xbfe00000UL\n+  __ mulpd(xmm5, xmm0);\n+  __ movdqu(xmm0, xmm3);\n+  __ addsd(xmm3, Address(rax, 8));\n+  __ mulpd(xmm1, xmm7);\n+  __ movdqu(xmm7, xmm4);\n+  __ addsd(xmm4, xmm3);\n+  __ addpd(xmm6, xmm5);\n+  __ movq(xmm5, Address(rax, 8));\n+  __ subsd(xmm5, xmm3);\n+  __ subsd(xmm3, xmm4);\n+  __ addsd(xmm1, Address(rax, 16));\n+  __ mulpd(xmm6, xmm2);\n+  __ addsd(xmm0, xmm5);\n+  __ addsd(xmm3, xmm7);\n+  __ addsd(xmm0, xmm1);\n+  __ addsd(xmm0, xmm3);\n+  __ addsd(xmm0, xmm6);\n+  __ unpckhpd(xmm6, xmm6);\n+  __ addsd(xmm0, xmm6);\n+  __ addsd(xmm0, xmm4);\n+  __ jmp(B1_4);\n+\n+  __ bind(L_2TAG_PACKET_0_0_1);\n+  __ jcc(Assembler::greater, L_2TAG_PACKET_1_0_1);\n+  __ pextrw(rax, xmm0, 3);\n+  __ andl(rax, 32767);\n+  __ pinsrw(xmm0, rax, 3);\n+  __ movq(xmm1, ExternalAddress(ONE), rbx \/*rscratch*\/); \/\/ 0x00000000UL, 0x3ff00000UL\n+  __ subsd(xmm1, xmm0);\n+  __ movdqu(xmm0, xmm1);\n+  __ jmp(B1_4);\n+\n+  __ bind(L_2TAG_PACKET_1_0_1);\n+  __ pextrw(rax, xmm0, 3);\n+  __ andl(rax, 32752);\n+  __ cmpl(rax, 32752);\n+  __ jcc(Assembler::equal, L_2TAG_PACKET_2_0_1);\n+  __ pextrw(rcx, xmm0, 3);\n+  __ andl(rcx, 32752);\n+  __ subl(rcx, 16224);\n+  __ shrl(rcx, 7);\n+  __ andl(rcx, 65532);\n+  __ lea(r11, ExternalAddress(PI_INV_TABLE));\n+  __ addq(rcx, r11);\n+  __ movdq(rax, xmm0);\n+  __ movl(r10, Address(rcx, 20));\n+  __ movl(r8, Address(rcx, 24));\n+  __ movl(rdx, rax);\n+  __ shrq(rax, 21);\n+  __ orl(rax, INT_MIN);\n+  __ shrl(rax, 11);\n+  __ movl(r9, r10);\n+  __ imulq(r10, rdx);\n+  __ imulq(r9, rax);\n+  __ imulq(r8, rax);\n+  __ movl(rsi, Address(rcx, 16));\n+  __ movl(rdi, Address(rcx, 12));\n+  __ movl(r11, r10);\n+  __ shrq(r10, 32);\n+  __ addq(r9, r10);\n+  __ addq(r11, r8);\n+  __ movl(r8, r11);\n+  __ shrq(r11, 32);\n+  __ addq(r9, r11);\n+  __ movl(r10, rsi);\n+  __ imulq(rsi, rdx);\n+  __ imulq(r10, rax);\n+  __ movl(r11, rdi);\n+  __ imulq(rdi, rdx);\n+  __ movl(rbx, rsi);\n+  __ shrq(rsi, 32);\n+  __ addq(r9, rbx);\n+  __ movl(rbx, r9);\n+  __ shrq(r9, 32);\n+  __ addq(r10, rsi);\n+  __ addq(r10, r9);\n+  __ shlq(rbx, 32);\n+  __ orq(r8, rbx);\n+  __ imulq(r11, rax);\n+  __ movl(r9, Address(rcx, 8));\n+  __ movl(rsi, Address(rcx, 4));\n+  __ movl(rbx, rdi);\n+  __ shrq(rdi, 32);\n+  __ addq(r10, rbx);\n+  __ movl(rbx, r10);\n+  __ shrq(r10, 32);\n+  __ addq(r11, rdi);\n+  __ addq(r11, r10);\n+  __ movq(rdi, r9);\n+  __ imulq(r9, rdx);\n+  __ imulq(rdi, rax);\n+  __ movl(r10, r9);\n+  __ shrq(r9, 32);\n+  __ addq(r11, r10);\n+  __ movl(r10, r11);\n+  __ shrq(r11, 32);\n+  __ addq(rdi, r9);\n+  __ addq(rdi, r11);\n+  __ movq(r9, rsi);\n+  __ imulq(rsi, rdx);\n+  __ imulq(r9, rax);\n+  __ shlq(r10, 32);\n+  __ orq(r10, rbx);\n+  __ movl(rax, Address(rcx, 0));\n+  __ movl(r11, rsi);\n+  __ shrq(rsi, 32);\n+  __ addq(rdi, r11);\n+  __ movl(r11, rdi);\n+  __ shrq(rdi, 32);\n+  __ addq(r9, rsi);\n+  __ addq(r9, rdi);\n+  __ imulq(rdx, rax);\n+  __ pextrw(rbx, xmm0, 3);\n+  __ lea(rdi, ExternalAddress(PI_INV_TABLE));\n+  __ subq(rcx, rdi);\n+  __ addl(rcx, rcx);\n+  __ addl(rcx, rcx);\n+  __ addl(rcx, rcx);\n+  __ addl(rcx, 19);\n+  __ movl(rsi, 32768);\n+  __ andl(rsi, rbx);\n+  __ shrl(rbx, 4);\n+  __ andl(rbx, 2047);\n+  __ subl(rbx, 1023);\n+  __ subl(rcx, rbx);\n+  __ addq(r9, rdx);\n+  __ movl(rdx, rcx);\n+  __ addl(rdx, 32);\n+  __ cmpl(rcx, 1);\n+  __ jcc(Assembler::less, L_2TAG_PACKET_3_0_1);\n+  __ negl(rcx);\n+  __ addl(rcx, 29);\n+  __ shll(r9);\n+  __ movl(rdi, r9);\n+  __ andl(r9, 536870911);\n+  __ testl(r9, 268435456);\n+  __ jcc(Assembler::notEqual, L_2TAG_PACKET_4_0_1);\n+  __ shrl(r9);\n+  __ movl(rbx, 0);\n+  __ shlq(r9, 32);\n+  __ orq(r9, r11);\n+\n+  __ bind(L_2TAG_PACKET_5_0_1);\n+\n+  __ bind(L_2TAG_PACKET_6_0_1);\n+  __ cmpq(r9, 0);\n+  __ jcc(Assembler::equal, L_2TAG_PACKET_7_0_1);\n+\n+  __ bind(L_2TAG_PACKET_8_0_1);\n+  __ bsrq(r11, r9);\n+  __ movl(rcx, 29);\n+  __ subl(rcx, r11);\n+  __ jcc(Assembler::lessEqual, L_2TAG_PACKET_9_0_1);\n+  __ shlq(r9);\n+  __ movq(rax, r10);\n+  __ shlq(r10);\n+  __ addl(rdx, rcx);\n+  __ negl(rcx);\n+  __ addl(rcx, 64);\n+  __ shrq(rax);\n+  __ shrq(r8);\n+  __ orq(r9, rax);\n+  __ orq(r10, r8);\n+\n+  __ bind(L_2TAG_PACKET_10_0_1);\n+  __ cvtsi2sdq(xmm0, r9);\n+  __ shrq(r10, 1);\n+  __ cvtsi2sdq(xmm3, r10);\n+  __ xorpd(xmm4, xmm4);\n+  __ shll(rdx, 4);\n+  __ negl(rdx);\n+  __ addl(rdx, 16368);\n+  __ orl(rdx, rsi);\n+  __ xorl(rdx, rbx);\n+  __ pinsrw(xmm4, rdx, 3);\n+  __ movq(xmm2, ExternalAddress(PI_4),     rbx \/*rscratch*\/); \/\/0x40000000UL, 0x3fe921fbUL, 0x18469899UL, 0x3e64442dUL\n+  __ movq(xmm6, ExternalAddress(PI_4 + 8), rbx \/*rscratch*\/); \/\/0x3fe921fbUL, 0x18469899UL, 0x3e64442dUL\n+  __ xorpd(xmm5, xmm5);\n+  __ subl(rdx, 1008);\n+  __ pinsrw(xmm5, rdx, 3);\n+  __ mulsd(xmm0, xmm4);\n+  __ shll(rsi, 16);\n+  __ sarl(rsi, 31);\n+  __ mulsd(xmm3, xmm5);\n+  __ movdqu(xmm1, xmm0);\n+  __ mulsd(xmm0, xmm2);\n+  __ shrl(rdi, 29);\n+  __ addsd(xmm1, xmm3);\n+  __ mulsd(xmm3, xmm2);\n+  __ addl(rdi, rsi);\n+  __ xorl(rdi, rsi);\n+  __ mulsd(xmm6, xmm1);\n+  __ movl(rax, rdi);\n+  __ addsd(xmm6, xmm3);\n+  __ movdqu(xmm2, xmm0);\n+  __ addsd(xmm0, xmm6);\n+  __ subsd(xmm2, xmm0);\n+  __ addsd(xmm6, xmm2);\n+\n+  __ bind(L_2TAG_PACKET_11_0_1);\n+  __ movq(xmm1, ExternalAddress(PI32INV), rbx \/*rscratch*\/);   \/\/0x6dc9c883UL, 0x40245f30UL\n+  __ mulsd(xmm1, xmm0);\n+  __ movq(xmm5, ExternalAddress(ONEHALF), rbx \/*rscratch*\/);   \/\/0x00000000UL, 0x3fe00000UL, 0x00000000UL, 0x3fe00000UL\n+  __ movq(xmm4, ExternalAddress(SIGN_MASK), rbx \/*rscratch*\/); \/\/0x00000000UL, 0x80000000UL\n+  __ pand(xmm4, xmm0);\n+  __ por(xmm5, xmm4);\n+  __ addpd(xmm1, xmm5);\n+  __ cvttsd2siq(rdx, xmm1);\n+  __ cvtsi2sdq(xmm1, rdx);\n+  __ movq(xmm3, ExternalAddress(P_1), rbx \/*rscratch*\/);    \/\/0x54400000UL, 0x3fb921fbUL\n+  __ movdqu(xmm2, ExternalAddress(P_2), rbx \/*rscratch*\/);    \/\/0x1a600000UL, 0x3d90b461UL, 0x1a600000UL, 0x3d90b461UL\n+  __ mulsd(xmm3, xmm1);\n+  __ unpcklpd(xmm1, xmm1);\n+  __ shll(rax, 3);\n+  __ addl(rdx, 1865232);\n+  __ movdqu(xmm4, xmm0);\n+  __ addl(rdx, rax);\n+  __ andl(rdx, 63);\n+  __ movdqu(xmm5, ExternalAddress(SC_4), rbx \/*rscratch*\/);    \/\/0xa556c734UL, 0x3ec71de3UL, 0x1a01a01aUL, 0x3efa01a0UL\n+  __ lea(rax, ExternalAddress(Ctable));\n+  __ shll(rdx, 5);\n+  __ addq(rax, rdx);\n+  __ mulpd(xmm2, xmm1);\n+  __ subsd(xmm0, xmm3);\n+  __ mulsd(xmm1, ExternalAddress(P_3), rbx \/*rscratch*\/);    \/\/0x2e037073UL, 0x3b63198aUL\n+  __ subsd(xmm4, xmm3);\n+  __ movq(xmm7, Address(rax, 8));\n+  __ unpcklpd(xmm0, xmm0);\n+  __ movdqu(xmm3, xmm4);\n+  __ subsd(xmm4, xmm2);\n+  __ mulpd(xmm5, xmm0);\n+  __ subpd(xmm0, xmm2);\n+  __ mulsd(xmm7, xmm4);\n+  __ subsd(xmm3, xmm4);\n+  __ mulpd(xmm5, xmm0);\n+  __ mulpd(xmm0, xmm0);\n+  __ subsd(xmm3, xmm2);\n+  __ movdqu(xmm2, Address(rax, 0));\n+  __ subsd(xmm1, xmm3);\n+  __ movq(xmm3, Address(rax, 24));\n+  __ addsd(xmm2, xmm3);\n+  __ subsd(xmm7, xmm2);\n+  __ subsd(xmm1, xmm6);\n+  __ movdqu(xmm6, ExternalAddress(SC_2), rbx \/*rscratch*\/);    \/\/0x11111111UL, 0x3f811111UL, 0x55555555UL, 0x3fa55555UL\n+  __ mulsd(xmm2, xmm4);\n+  __ mulpd(xmm6, xmm0);\n+  __ mulsd(xmm3, xmm4);\n+  __ mulpd(xmm2, xmm0);\n+  __ mulpd(xmm0, xmm0);\n+  __ addpd(xmm5, ExternalAddress(SC_3), rbx \/*rscratch*\/);    \/\/0x1a01a01aUL, 0xbf2a01a0UL, 0x16c16c17UL, 0xbf56c16cUL\n+  __ mulsd(xmm4, Address(rax, 0));\n+  __ addpd(xmm6, ExternalAddress(SC_1), rbx \/*rscratch*\/);    \/\/0x55555555UL, 0xbfc55555UL, 0x00000000UL, 0xbfe00000UL\n+  __ mulpd(xmm5, xmm0);\n+  __ movdqu(xmm0, xmm3);\n+  __ addsd(xmm3, Address(rax, 8));\n+  __ mulpd(xmm1, xmm7);\n+  __ movdqu(xmm7, xmm4);\n+  __ addsd(xmm4, xmm3);\n+  __ addpd(xmm6, xmm5);\n+  __ movq(xmm5, Address(rax, 8));\n+  __ subsd(xmm5, xmm3);\n+  __ subsd(xmm3, xmm4);\n+  __ addsd(xmm1, Address(rax, 16));\n+  __ mulpd(xmm6, xmm2);\n+  __ addsd(xmm5, xmm0);\n+  __ addsd(xmm3, xmm7);\n+  __ addsd(xmm1, xmm5);\n+  __ addsd(xmm1, xmm3);\n+  __ addsd(xmm1, xmm6);\n+  __ unpckhpd(xmm6, xmm6);\n+  __ movdqu(xmm0, xmm4);\n+  __ addsd(xmm1, xmm6);\n+  __ addsd(xmm0, xmm1);\n+  __ jmp(B1_4);\n+\n+  __ bind(L_2TAG_PACKET_7_0_1);\n+  __ addl(rdx, 64);\n+  __ movq(r9, r10);\n+  __ movq(r10, r8);\n+  __ movl(r8, 0);\n+  __ cmpq(r9, 0);\n+  __ jcc(Assembler::notEqual, L_2TAG_PACKET_8_0_1);\n+  __ addl(rdx, 64);\n+  __ movq(r9, r10);\n+  __ movq(r10, r8);\n+  __ cmpq(r9, 0);\n+  __ jcc(Assembler::notEqual, L_2TAG_PACKET_8_0_1);\n+  __ xorpd(xmm0, xmm0);\n+  __ xorpd(xmm6, xmm6);\n+  __ jmp(L_2TAG_PACKET_11_0_1);\n+\n+  __ bind(L_2TAG_PACKET_9_0_1);\n+  __ jcc(Assembler::equal, L_2TAG_PACKET_10_0_1);\n+  __ negl(rcx);\n+  __ shrq(r10);\n+  __ movq(rax, r9);\n+  __ shrq(r9);\n+  __ subl(rdx, rcx);\n+  __ negl(rcx);\n+  __ addl(rcx, 64);\n+  __ shlq(rax);\n+  __ orq(r10, rax);\n+  __ jmp(L_2TAG_PACKET_10_0_1);\n+  __ bind(L_2TAG_PACKET_3_0_1);\n+  __ negl(rcx);\n+  __ shlq(r9, 32);\n+  __ orq(r9, r11);\n+  __ shlq(r9);\n+  __ movq(rdi, r9);\n+  __ testl(r9, INT_MIN);\n+  __ jcc(Assembler::notEqual, L_2TAG_PACKET_12_0_1);\n+  __ shrl(r9);\n+  __ movl(rbx, 0);\n+  __ shrq(rdi, 3);\n+  __ jmp(L_2TAG_PACKET_6_0_1);\n+\n+  __ bind(L_2TAG_PACKET_4_0_1);\n+  __ shrl(r9);\n+  __ movl(rbx, 536870912);\n+  __ shrl(rbx);\n+  __ shlq(r9, 32);\n+  __ orq(r9, r11);\n+  __ shlq(rbx, 32);\n+  __ addl(rdi, 536870912);\n+  __ movl(rcx, 0);\n+  __ movl(r11, 0);\n+  __ subq(rcx, r8);\n+  __ sbbq(r11, r10);\n+  __ sbbq(rbx, r9);\n+  __ movq(r8, rcx);\n+  __ movq(r10, r11);\n+  __ movq(r9, rbx);\n+  __ movl(rbx, 32768);\n+  __ jmp(L_2TAG_PACKET_5_0_1);\n+\n+  __ bind(L_2TAG_PACKET_12_0_1);\n+  __ shrl(r9);\n+  __ mov64(rbx, 0x100000000);\n+  __ shrq(rbx);\n+  __ movl(rcx, 0);\n+  __ movl(r11, 0);\n+  __ subq(rcx, r8);\n+  __ sbbq(r11, r10);\n+  __ sbbq(rbx, r9);\n+  __ movq(r8, rcx);\n+  __ movq(r10, r11);\n+  __ movq(r9, rbx);\n+  __ movl(rbx, 32768);\n+  __ shrq(rdi, 3);\n+  __ addl(rdi, 536870912);\n+  __ jmp(L_2TAG_PACKET_6_0_1);\n+\n+  __ bind(L_2TAG_PACKET_2_0_1);\n+  __ movsd(xmm0, Address(rsp, 8));\n+  __ mulsd(xmm0, ExternalAddress(NEG_ZERO), rbx \/*rscratch*\/);    \/\/0x00000000UL, 0x80000000UL\n+  __ movq(Address(rsp, 0), xmm0);\n+\n+  __ bind(L_2TAG_PACKET_13_0_1);\n+\n+  __ bind(B1_4);\n+  __ addq(rsp, 16);\n+  __ pop(rbx);\n+\n+#ifdef _WIN64\n+  __ pop(rdi);\n+  __ pop(rsi);\n+#endif\n+\n+  __ leave(); \/\/ required for proper stackwalking of RuntimeStub frame\n+  __ ret(0);\n+\n+  return start;\n+}\n+\n+#undef __\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_cos.cpp","additions":625,"deletions":0,"binary":false,"changes":625,"status":"added"},{"patch":"@@ -0,0 +1,387 @@\n+\/*\n+* Copyright (c) 2016, 2021, Intel Corporation. All rights reserved.\n+* Copyright (C) 2021 THL A29 Limited, a Tencent company. All rights reserved.\n+* Intel Math Library (LIBM) Source Code\n+*\n+* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+*\n+* This code is free software; you can redistribute it and\/or modify it\n+* under the terms of the GNU General Public License version 2 only, as\n+* published by the Free Software Foundation.\n+*\n+* This code is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+* FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+* version 2 for more details (a copy is included in the LICENSE file that\n+* accompanied this code).\n+*\n+* You should have received a copy of the GNU General Public License version\n+* 2 along with this work; if not, write to the Free Software Foundation,\n+* Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+*\n+* Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+* or visit www.oracle.com if you need additional information or have any\n+* questions.\n+*\n+*\/\n+\n+#include \"precompiled.hpp\"\n+#include \"macroAssembler_x86.hpp\"\n+#include \"stubGenerator_x86_64.hpp\"\n+\n+\/******************************************************************************\/\n+\/\/                     ALGORITHM DESCRIPTION - EXP()\n+\/\/                     ---------------------\n+\/\/\n+\/\/ Description:\n+\/\/  Let K = 64 (table size).\n+\/\/        x    x\/log(2)     n\n+\/\/       e  = 2          = 2 * T[j] * (1 + P(y))\n+\/\/  where\n+\/\/       x = m*log(2)\/K + y,    y in [-log(2)\/K..log(2)\/K]\n+\/\/       m = n*K + j,           m,n,j - signed integer, j in [-K\/2..K\/2]\n+\/\/                  j\/K\n+\/\/       values of 2   are tabulated as T[j] = T_hi[j] ( 1 + T_lo[j]).\n+\/\/\n+\/\/       P(y) is a minimax polynomial approximation of exp(x)-1\n+\/\/       on small interval [-log(2)\/K..log(2)\/K] (were calculated by Maple V).\n+\/\/\n+\/\/  To avoid problems with arithmetic overflow and underflow,\n+\/\/            n                        n1  n2\n+\/\/  value of 2  is safely computed as 2 * 2 where n1 in [-BIAS\/2..BIAS\/2]\n+\/\/  where BIAS is a value of exponent bias.\n+\/\/\n+\/\/ Special cases:\n+\/\/  exp(NaN) = NaN\n+\/\/  exp(+INF) = +INF\n+\/\/  exp(-INF) = 0\n+\/\/  exp(x) = 1 for subnormals\n+\/\/  for finite argument, only exp(0)=1 is exact\n+\/\/  For IEEE double\n+\/\/    if x >  709.782712893383973096 then exp(x) overflow\n+\/\/    if x < -745.133219101941108420 then exp(x) underflow\n+\/\/\n+\/******************************************************************************\/\n+\n+ATTRIBUTE_ALIGNED(16) juint _cv[] =\n+{\n+    0x652b82feUL, 0x40571547UL, 0x652b82feUL, 0x40571547UL, 0xfefa0000UL,\n+    0x3f862e42UL, 0xfefa0000UL, 0x3f862e42UL, 0xbc9e3b3aUL, 0x3d1cf79aUL,\n+    0xbc9e3b3aUL, 0x3d1cf79aUL, 0xfffffffeUL, 0x3fdfffffUL, 0xfffffffeUL,\n+    0x3fdfffffUL, 0xe3289860UL, 0x3f56c15cUL, 0x555b9e25UL, 0x3fa55555UL,\n+    0xc090cf0fUL, 0x3f811115UL, 0x55548ba1UL, 0x3fc55555UL\n+};\n+\n+ATTRIBUTE_ALIGNED(16) juint _mmask[] =\n+{\n+    0xffffffc0UL, 0x00000000UL, 0xffffffc0UL, 0x00000000UL\n+};\n+\n+ATTRIBUTE_ALIGNED(16) juint _bias[] =\n+{\n+    0x0000ffc0UL, 0x00000000UL, 0x0000ffc0UL, 0x00000000UL\n+};\n+\n+ATTRIBUTE_ALIGNED(16) juint _Tbl_addr[] =\n+{\n+    0x00000000UL, 0x00000000UL, 0x00000000UL, 0x00000000UL, 0x0e03754dUL,\n+    0x3cad7bbfUL, 0x3e778060UL, 0x00002c9aUL, 0x3567f613UL, 0x3c8cd252UL,\n+    0xd3158574UL, 0x000059b0UL, 0x61e6c861UL, 0x3c60f74eUL, 0x18759bc8UL,\n+    0x00008745UL, 0x5d837b6cUL, 0x3c979aa6UL, 0x6cf9890fUL, 0x0000b558UL,\n+    0x702f9cd1UL, 0x3c3ebe3dUL, 0x32d3d1a2UL, 0x0000e3ecUL, 0x1e63bcd8UL,\n+    0x3ca3516eUL, 0xd0125b50UL, 0x00011301UL, 0x26f0387bUL, 0x3ca4c554UL,\n+    0xaea92ddfUL, 0x0001429aUL, 0x62523fb6UL, 0x3ca95153UL, 0x3c7d517aUL,\n+    0x000172b8UL, 0x3f1353bfUL, 0x3c8b898cUL, 0xeb6fcb75UL, 0x0001a35bUL,\n+    0x3e3a2f5fUL, 0x3c9aecf7UL, 0x3168b9aaUL, 0x0001d487UL, 0x44a6c38dUL,\n+    0x3c8a6f41UL, 0x88628cd6UL, 0x0002063bUL, 0xe3a8a894UL, 0x3c968efdUL,\n+    0x6e756238UL, 0x0002387aUL, 0x981fe7f2UL, 0x3c80472bUL, 0x65e27cddUL,\n+    0x00026b45UL, 0x6d09ab31UL, 0x3c82f7e1UL, 0xf51fdee1UL, 0x00029e9dUL,\n+    0x720c0ab3UL, 0x3c8b3782UL, 0xa6e4030bUL, 0x0002d285UL, 0x4db0abb6UL,\n+    0x3c834d75UL, 0x0a31b715UL, 0x000306feUL, 0x5dd3f84aUL, 0x3c8fdd39UL,\n+    0xb26416ffUL, 0x00033c08UL, 0xcc187d29UL, 0x3ca12f8cUL, 0x373aa9caUL,\n+    0x000371a7UL, 0x738b5e8bUL, 0x3ca7d229UL, 0x34e59ff6UL, 0x0003a7dbUL,\n+    0xa72a4c6dUL, 0x3c859f48UL, 0x4c123422UL, 0x0003dea6UL, 0x259d9205UL,\n+    0x3ca8b846UL, 0x21f72e29UL, 0x0004160aUL, 0x60c2ac12UL, 0x3c4363edUL,\n+    0x6061892dUL, 0x00044e08UL, 0xdaa10379UL, 0x3c6ecce1UL, 0xb5c13cd0UL,\n+    0x000486a2UL, 0xbb7aafb0UL, 0x3c7690ceUL, 0xd5362a27UL, 0x0004bfdaUL,\n+    0x9b282a09UL, 0x3ca083ccUL, 0x769d2ca6UL, 0x0004f9b2UL, 0xc1aae707UL,\n+    0x3ca509b0UL, 0x569d4f81UL, 0x0005342bUL, 0x18fdd78eUL, 0x3c933505UL,\n+    0x36b527daUL, 0x00056f47UL, 0xe21c5409UL, 0x3c9063e1UL, 0xdd485429UL,\n+    0x0005ab07UL, 0x2b64c035UL, 0x3c9432e6UL, 0x15ad2148UL, 0x0005e76fUL,\n+    0x99f08c0aUL, 0x3ca01284UL, 0xb03a5584UL, 0x0006247eUL, 0x0073dc06UL,\n+    0x3c99f087UL, 0x82552224UL, 0x00066238UL, 0x0da05571UL, 0x3c998d4dUL,\n+    0x667f3bccUL, 0x0006a09eUL, 0x86ce4786UL, 0x3ca52bb9UL, 0x3c651a2eUL,\n+    0x0006dfb2UL, 0x206f0dabUL, 0x3ca32092UL, 0xe8ec5f73UL, 0x00071f75UL,\n+    0x8e17a7a6UL, 0x3ca06122UL, 0x564267c8UL, 0x00075febUL, 0x461e9f86UL,\n+    0x3ca244acUL, 0x73eb0186UL, 0x0007a114UL, 0xabd66c55UL, 0x3c65ebe1UL,\n+    0x36cf4e62UL, 0x0007e2f3UL, 0xbbff67d0UL, 0x3c96fe9fUL, 0x994cce12UL,\n+    0x00082589UL, 0x14c801dfUL, 0x3c951f14UL, 0x9b4492ecUL, 0x000868d9UL,\n+    0xc1f0eab4UL, 0x3c8db72fUL, 0x422aa0dbUL, 0x0008ace5UL, 0x59f35f44UL,\n+    0x3c7bf683UL, 0x99157736UL, 0x0008f1aeUL, 0x9c06283cUL, 0x3ca360baUL,\n+    0xb0cdc5e4UL, 0x00093737UL, 0x20f962aaUL, 0x3c95e8d1UL, 0x9fde4e4fUL,\n+    0x00097d82UL, 0x2b91ce27UL, 0x3c71affcUL, 0x82a3f090UL, 0x0009c491UL,\n+    0x589a2ebdUL, 0x3c9b6d34UL, 0x7b5de564UL, 0x000a0c66UL, 0x9ab89880UL,\n+    0x3c95277cUL, 0xb23e255cUL, 0x000a5503UL, 0x6e735ab3UL, 0x3c846984UL,\n+    0x5579fdbfUL, 0x000a9e6bUL, 0x92cb3387UL, 0x3c8c1a77UL, 0x995ad3adUL,\n+    0x000ae89fUL, 0xdc2d1d96UL, 0x3ca22466UL, 0xb84f15faUL, 0x000b33a2UL,\n+    0xb19505aeUL, 0x3ca1112eUL, 0xf2fb5e46UL, 0x000b7f76UL, 0x0a5fddcdUL,\n+    0x3c74ffd7UL, 0x904bc1d2UL, 0x000bcc1eUL, 0x30af0cb3UL, 0x3c736eaeUL,\n+    0xdd85529cUL, 0x000c199bUL, 0xd10959acUL, 0x3c84e08fUL, 0x2e57d14bUL,\n+    0x000c67f1UL, 0x6c921968UL, 0x3c676b2cUL, 0xdcef9069UL, 0x000cb720UL,\n+    0x36df99b3UL, 0x3c937009UL, 0x4a07897bUL, 0x000d072dUL, 0xa63d07a7UL,\n+    0x3c74a385UL, 0xdcfba487UL, 0x000d5818UL, 0xd5c192acUL, 0x3c8e5a50UL,\n+    0x03db3285UL, 0x000da9e6UL, 0x1c4a9792UL, 0x3c98bb73UL, 0x337b9b5eUL,\n+    0x000dfc97UL, 0x603a88d3UL, 0x3c74b604UL, 0xe78b3ff6UL, 0x000e502eUL,\n+    0x92094926UL, 0x3c916f27UL, 0xa2a490d9UL, 0x000ea4afUL, 0x41aa2008UL,\n+    0x3c8ec3bcUL, 0xee615a27UL, 0x000efa1bUL, 0x31d185eeUL, 0x3c8a64a9UL,\n+    0x5b6e4540UL, 0x000f5076UL, 0x4d91cd9dUL, 0x3c77893bUL, 0x819e90d8UL,\n+    0x000fa7c1UL\n+};\n+\n+ATTRIBUTE_ALIGNED(16) juint _ALLONES[] =\n+{\n+    0xffffffffUL, 0xffffffffUL, 0xffffffffUL, 0xffffffffUL\n+};\n+\n+ATTRIBUTE_ALIGNED(16) juint _ebias[] =\n+{\n+    0x00000000UL, 0x3ff00000UL, 0x00000000UL, 0x3ff00000UL\n+};\n+\n+ATTRIBUTE_ALIGNED(4) juint _XMAX[] =\n+{\n+    0xffffffffUL, 0x7fefffffUL\n+};\n+\n+ATTRIBUTE_ALIGNED(4) juint _XMIN[] =\n+{\n+    0x00000000UL, 0x00100000UL\n+};\n+\n+ATTRIBUTE_ALIGNED(4) juint _INF[] =\n+{\n+    0x00000000UL, 0x7ff00000UL\n+};\n+\n+#define __ _masm->\n+\n+address StubGenerator::generate_libmExp() {\n+  StubCodeMark mark(this, \"StubRoutines\", \"libmExp\");\n+  address start = __ pc();\n+\n+  Label L_2TAG_PACKET_0_0_2, L_2TAG_PACKET_1_0_2, L_2TAG_PACKET_2_0_2, L_2TAG_PACKET_3_0_2;\n+  Label L_2TAG_PACKET_4_0_2, L_2TAG_PACKET_5_0_2, L_2TAG_PACKET_6_0_2, L_2TAG_PACKET_7_0_2;\n+  Label L_2TAG_PACKET_8_0_2, L_2TAG_PACKET_9_0_2, L_2TAG_PACKET_10_0_2, L_2TAG_PACKET_11_0_2;\n+  Label L_2TAG_PACKET_12_0_2, B1_3, B1_5;\n+\n+  address cv       = (address)_cv;\n+  address mmask    = (address)_mmask;\n+  address bias     = (address)_bias;\n+  address Tbl_addr = (address)_Tbl_addr;\n+  address ALLONES  = (address)_ALLONES;\n+  address ebias    = (address)_ebias;\n+  address XMAX     = (address)_XMAX;\n+  address XMIN     = (address)_XMIN;\n+  address INF      = (address)_INF;\n+\n+  __ enter(); \/\/ required for proper stackwalking of RuntimeStub frame\n+\n+  __ subq(rsp, 24);\n+  __ movsd(Address(rsp, 8), xmm0);\n+  __ unpcklpd(xmm0, xmm0);\n+  __ movdqu(xmm1, ExternalAddress(cv),      r11 \/*rscratch*\/); \/\/ 0x652b82feUL, 0x40571547UL, 0x652b82feUL, 0x40571547UL\n+  __ movdqu(xmm2, ExternalAddress(cv + 16), r11 \/*rscratch*\/); \/\/ 0xfefa0000UL, 0x3f862e42UL, 0xfefa0000UL, 0x3f862e42UL\n+  __ movdqu(xmm3, ExternalAddress(cv + 32), r11 \/*rscratch*\/); \/\/ 0xbc9e3b3aUL, 0x3d1cf79aUL, 0xbc9e3b3aUL, 0x3d1cf79aUL\n+  __ movdqu(xmm6, ExternalAddress(SHIFTER), r11 \/*rscratch*\/); \/\/ 0x00000000UL, 0x43380000UL, 0x00000000UL, 0x43380000UL\n+  __ pextrw(rax, xmm0, 3);\n+  __ andl(rax, 32767);\n+  __ movl(rdx, 16527);\n+  __ subl(rdx, rax);\n+  __ subl(rax, 15504);\n+  __ orl(rdx, rax);\n+  __ cmpl(rdx, INT_MIN);\n+  __ jcc(Assembler::aboveEqual, L_2TAG_PACKET_0_0_2);\n+  __ mulpd(xmm1, xmm0);\n+  __ addpd(xmm1, xmm6);\n+  __ movapd(xmm7, xmm1);\n+  __ subpd(xmm1, xmm6);\n+  __ mulpd(xmm2, xmm1);\n+  __ movdqu(xmm4, ExternalAddress(cv + 64), r11 \/*rscratch*\/);  \/\/ 0xe3289860UL, 0x3f56c15cUL, 0x555b9e25UL, 0x3fa55555UL\n+  __ mulpd(xmm3, xmm1);\n+  __ movdqu(xmm5, ExternalAddress(cv + 80), r11 \/*rscratch*\/);  \/\/ 0xc090cf0fUL, 0x3f811115UL, 0x55548ba1UL, 0x3fc55555UL\n+  __ subpd(xmm0, xmm2);\n+  __ movdl(rax, xmm7);\n+  __ movl(rcx, rax);\n+  __ andl(rcx, 63);\n+  __ shll(rcx, 4);\n+  __ sarl(rax, 6);\n+  __ movl(rdx, rax);\n+  __ movdqu(xmm6, ExternalAddress(mmask), r11 \/*rscratch*\/);    \/\/ 0xffffffc0UL, 0x00000000UL, 0xffffffc0UL, 0x00000000UL\n+  __ pand(xmm7, xmm6);\n+  __ movdqu(xmm6, ExternalAddress(bias), r11 \/*rscratch*\/);     \/\/ 0x0000ffc0UL, 0x00000000UL, 0x0000ffc0UL, 0x00000000UL\n+  __ paddq(xmm7, xmm6);\n+  __ psllq(xmm7, 46);\n+  __ subpd(xmm0, xmm3);\n+  __ lea(r11, ExternalAddress(Tbl_addr));\n+  __ movdqu(xmm2, Address(rcx, r11));\n+  __ mulpd(xmm4, xmm0);\n+  __ movapd(xmm6, xmm0);\n+  __ movapd(xmm1, xmm0);\n+  __ mulpd(xmm6, xmm6);\n+  __ mulpd(xmm0, xmm6);\n+  __ addpd(xmm5, xmm4);\n+  __ mulsd(xmm0, xmm6);\n+  __ mulpd(xmm6, ExternalAddress(cv + 48), r11 \/*rscratch*\/);     \/\/ 0xfffffffeUL, 0x3fdfffffUL, 0xfffffffeUL, 0x3fdfffffUL\n+  __ addsd(xmm1, xmm2);\n+  __ unpckhpd(xmm2, xmm2);\n+  __ mulpd(xmm0, xmm5);\n+  __ addsd(xmm1, xmm0);\n+  __ por(xmm2, xmm7);\n+  __ unpckhpd(xmm0, xmm0);\n+  __ addsd(xmm0, xmm1);\n+  __ addsd(xmm0, xmm6);\n+  __ addl(rdx, 894);\n+  __ cmpl(rdx, 1916);\n+  __ jcc(Assembler::above, L_2TAG_PACKET_1_0_2);\n+  __ mulsd(xmm0, xmm2);\n+  __ addsd(xmm0, xmm2);\n+  __ jmp(B1_5);\n+\n+  __ bind(L_2TAG_PACKET_1_0_2);\n+  __ xorpd(xmm3, xmm3);\n+  __ movdqu(xmm4, ExternalAddress(ALLONES), r11 \/*rscratch*\/);  \/\/ 0xffffffffUL, 0xffffffffUL, 0xffffffffUL, 0xffffffffUL\n+  __ movl(rdx, -1022);\n+  __ subl(rdx, rax);\n+  __ movdl(xmm5, rdx);\n+  __ psllq(xmm4, xmm5);\n+  __ movl(rcx, rax);\n+  __ sarl(rax, 1);\n+  __ pinsrw(xmm3, rax, 3);\n+  __ movdqu(xmm6, ExternalAddress(ebias), r11 \/*rscratch*\/);    \/\/ 0x00000000UL, 0x3ff00000UL, 0x00000000UL, 0x3ff00000UL\n+  __ psllq(xmm3, 4);\n+  __ psubd(xmm2, xmm3);\n+  __ mulsd(xmm0, xmm2);\n+  __ cmpl(rdx, 52);\n+  __ jcc(Assembler::greater, L_2TAG_PACKET_2_0_2);\n+  __ pand(xmm4, xmm2);\n+  __ paddd(xmm3, xmm6);\n+  __ subsd(xmm2, xmm4);\n+  __ addsd(xmm0, xmm2);\n+  __ cmpl(rcx, 1023);\n+  __ jcc(Assembler::greaterEqual, L_2TAG_PACKET_3_0_2);\n+  __ pextrw(rcx, xmm0, 3);\n+  __ andl(rcx, 32768);\n+  __ orl(rdx, rcx);\n+  __ cmpl(rdx, 0);\n+  __ jcc(Assembler::equal, L_2TAG_PACKET_4_0_2);\n+  __ movapd(xmm6, xmm0);\n+  __ addsd(xmm0, xmm4);\n+  __ mulsd(xmm0, xmm3);\n+  __ pextrw(rcx, xmm0, 3);\n+  __ andl(rcx, 32752);\n+  __ cmpl(rcx, 0);\n+  __ jcc(Assembler::equal, L_2TAG_PACKET_5_0_2);\n+  __ jmp(B1_5);\n+\n+  __ bind(L_2TAG_PACKET_5_0_2);\n+  __ mulsd(xmm6, xmm3);\n+  __ mulsd(xmm4, xmm3);\n+  __ movdqu(xmm0, xmm6);\n+  __ pxor(xmm6, xmm4);\n+  __ psrad(xmm6, 31);\n+  __ pshufd(xmm6, xmm6, 85);\n+  __ psllq(xmm0, 1);\n+  __ psrlq(xmm0, 1);\n+  __ pxor(xmm0, xmm6);\n+  __ psrlq(xmm6, 63);\n+  __ paddq(xmm0, xmm6);\n+  __ paddq(xmm0, xmm4);\n+  __ movl(Address(rsp, 0), 15);\n+  __ jmp(L_2TAG_PACKET_6_0_2);\n+\n+  __ bind(L_2TAG_PACKET_4_0_2);\n+  __ addsd(xmm0, xmm4);\n+  __ mulsd(xmm0, xmm3);\n+  __ jmp(B1_5);\n+\n+  __ bind(L_2TAG_PACKET_3_0_2);\n+  __ addsd(xmm0, xmm4);\n+  __ mulsd(xmm0, xmm3);\n+  __ pextrw(rcx, xmm0, 3);\n+  __ andl(rcx, 32752);\n+  __ cmpl(rcx, 32752);\n+  __ jcc(Assembler::aboveEqual, L_2TAG_PACKET_7_0_2);\n+  __ jmp(B1_5);\n+\n+  __ bind(L_2TAG_PACKET_2_0_2);\n+  __ paddd(xmm3, xmm6);\n+  __ addpd(xmm0, xmm2);\n+  __ mulsd(xmm0, xmm3);\n+  __ movl(Address(rsp, 0), 15);\n+  __ jmp(L_2TAG_PACKET_6_0_2);\n+\n+  __ bind(L_2TAG_PACKET_8_0_2);\n+  __ cmpl(rax, 2146435072);\n+  __ jcc(Assembler::aboveEqual, L_2TAG_PACKET_9_0_2);\n+  __ movl(rax, Address(rsp, 12));\n+  __ cmpl(rax, INT_MIN);\n+  __ jcc(Assembler::aboveEqual, L_2TAG_PACKET_10_0_2);\n+  __ movsd(xmm0, ExternalAddress(XMAX), r11 \/*rscratch*\/);      \/\/ 0xffffffffUL, 0x7fefffffUL\n+  __ mulsd(xmm0, xmm0);\n+\n+  __ bind(L_2TAG_PACKET_7_0_2);\n+  __ movl(Address(rsp, 0), 14);\n+  __ jmp(L_2TAG_PACKET_6_0_2);\n+\n+  __ bind(L_2TAG_PACKET_10_0_2);\n+  __ movsd(xmm0, ExternalAddress(XMIN), r11 \/*rscratch*\/);      \/\/ 0x00000000UL, 0x00100000UL\n+  __ mulsd(xmm0, xmm0);\n+  __ movl(Address(rsp, 0), 15);\n+  __ jmp(L_2TAG_PACKET_6_0_2);\n+\n+  __ bind(L_2TAG_PACKET_9_0_2);\n+  __ movl(rdx, Address(rsp, 8));\n+  __ cmpl(rax, 2146435072);\n+  __ jcc(Assembler::above, L_2TAG_PACKET_11_0_2);\n+  __ cmpl(rdx, 0);\n+  __ jcc(Assembler::notEqual, L_2TAG_PACKET_11_0_2);\n+  __ movl(rax, Address(rsp, 12));\n+  __ cmpl(rax, 2146435072);\n+  __ jcc(Assembler::notEqual, L_2TAG_PACKET_12_0_2);\n+  __ movsd(xmm0, ExternalAddress(INF), r11 \/*rscratch*\/);       \/\/ 0x00000000UL, 0x7ff00000UL\n+  __ jmp(B1_5);\n+\n+  __ bind(L_2TAG_PACKET_12_0_2);\n+  __ movsd(xmm0, ExternalAddress(ZERO), r11 \/*rscratch*\/);      \/\/ 0x00000000UL, 0x00000000UL\n+  __ jmp(B1_5);\n+\n+  __ bind(L_2TAG_PACKET_11_0_2);\n+  __ movsd(xmm0, Address(rsp, 8));\n+  __ addsd(xmm0, xmm0);\n+  __ jmp(B1_5);\n+\n+  __ bind(L_2TAG_PACKET_0_0_2);\n+  __ movl(rax, Address(rsp, 12));\n+  __ andl(rax, 2147483647);\n+  __ cmpl(rax, 1083179008);\n+  __ jcc(Assembler::aboveEqual, L_2TAG_PACKET_8_0_2);\n+  __ movsd(Address(rsp, 8), xmm0);\n+  __ addsd(xmm0, ExternalAddress(ONE), r11 \/*rscratch*\/); \/\/ 0x00000000UL, 0x3ff00000UL\n+  __ jmp(B1_5);\n+\n+  __ bind(L_2TAG_PACKET_6_0_2);\n+  __ movq(Address(rsp, 16), xmm0);\n+\n+  __ bind(B1_3);\n+  __ movq(xmm0, Address(rsp, 16));\n+\n+  __ bind(B1_5);\n+  __ addq(rsp, 24);\n+\n+  __ leave(); \/\/ required for proper stackwalking of RuntimeStub frame\n+  __ ret(0);\n+\n+  return start;\n+}\n+\n+#undef __\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_exp.cpp","additions":387,"deletions":0,"binary":false,"changes":387,"status":"added"},{"patch":"@@ -35,13 +35,5 @@\n-\/\/ GHASH intrinsic stubs\n-\n-\n-\/\/ Polynomial x^128+x^127+x^126+x^121+1\n-address StubGenerator::generate_ghash_polynomial_addr() {\n-  __ align(CodeEntryAlignment);\n-  StubCodeMark mark(this, \"StubRoutines\", \"_ghash_poly_addr\");\n-  address start = __ pc();\n-\n-  __ emit_data64(0x0000000000000001, relocInfo::none);\n-  __ emit_data64(0xc200000000000000, relocInfo::none);\n-\n-  return start;\n+ATTRIBUTE_ALIGNED(16) uint64_t GHASH_SHUFFLE_MASK[] = {\n+    0x0F0F0F0F0F0F0F0FUL, 0x0F0F0F0F0F0F0F0FUL,\n+};\n+static address ghash_shuffle_mask_addr() {\n+  return (address)GHASH_SHUFFLE_MASK;\n@@ -50,12 +42,0 @@\n-address StubGenerator::generate_ghash_shufflemask_addr() {\n-  __ align(CodeEntryAlignment);\n-  StubCodeMark mark(this, \"StubRoutines\", \"_ghash_shuffmask_addr\");\n-  address start = __ pc();\n-\n-  __ emit_data64(0x0f0f0f0f0f0f0f0f, relocInfo::none);\n-  __ emit_data64(0x0f0f0f0f0f0f0f0f, relocInfo::none);\n-\n-  return start;\n-}\n-\n-\n@@ -63,4 +43,6 @@\n-address StubGenerator::generate_ghash_long_swap_mask() {\n-  __ align(CodeEntryAlignment);\n-  StubCodeMark mark(this, \"StubRoutines\", \"ghash_long_swap_mask\");\n-  address start = __ pc();\n+ATTRIBUTE_ALIGNED(16) uint64_t GHASH_LONG_SWAP_MASK[] = {\n+    0x0F0E0D0C0B0A0908UL, 0x0706050403020100UL,\n+};\n+address StubGenerator::ghash_long_swap_mask_addr() {\n+  return (address)GHASH_LONG_SWAP_MASK;\n+}\n@@ -68,2 +50,7 @@\n-  __ emit_data64(0x0f0e0d0c0b0a0908, relocInfo::none );\n-  __ emit_data64(0x0706050403020100, relocInfo::none );\n+\/\/ byte swap x86 byte array\n+ATTRIBUTE_ALIGNED(16) uint64_t GHASH_BYTE_SWAP_MASK[] = {\n+  0x08090A0B0C0D0E0FUL, 0x0001020304050607UL,\n+};\n+address StubGenerator::ghash_byte_swap_mask_addr() {\n+  return (address)GHASH_BYTE_SWAP_MASK;\n+}\n@@ -71,1 +58,6 @@\n-return start;\n+\/\/ Polynomial x^128+x^127+x^126+x^121+1\n+ATTRIBUTE_ALIGNED(16) uint64_t GHASH_POLYNOMIAL[] = {\n+    0x0000000000000001UL, 0xC200000000000000UL,\n+};\n+address StubGenerator::ghash_polynomial_addr() {\n+  return (address)GHASH_POLYNOMIAL;\n@@ -74,5 +66,0 @@\n-\/\/ byte swap x86 byte array\n-address StubGenerator::generate_ghash_byte_swap_mask() {\n-  __ align(CodeEntryAlignment);\n-  StubCodeMark mark(this, \"StubRoutines\", \"ghash_byte_swap_mask\");\n-  address start = __ pc();\n@@ -80,2 +67,1 @@\n-  __ emit_data64(0x08090a0b0c0d0e0f, relocInfo::none );\n-  __ emit_data64(0x0001020304050607, relocInfo::none );\n+\/\/ GHASH intrinsic stubs\n@@ -83,1 +69,8 @@\n-return start;\n+void StubGenerator::generate_ghash_stubs() {\n+  if (UseGHASHIntrinsics) {\n+    if (VM_Version::supports_avx()) {\n+      StubRoutines::_ghash_processBlocks = generate_avx_ghash_processBlocks();\n+    } else {\n+      StubRoutines::_ghash_processBlocks = generate_ghash_processBlocks();\n+    }\n+  }\n@@ -113,1 +106,3 @@\n-  __ movdqu(xmm_temp10, ExternalAddress(StubRoutines::x86::ghash_long_swap_mask_addr()));\n+  __ push(rbx); \/\/ scratch\n+\n+  __ movdqu(xmm_temp10, ExternalAddress(ghash_long_swap_mask_addr()), rbx \/*rscratch*\/);\n@@ -121,1 +116,1 @@\n-  __ pshufb(xmm_temp2, ExternalAddress(StubRoutines::x86::ghash_byte_swap_mask_addr()));\n+  __ pshufb(xmm_temp2, ExternalAddress(ghash_byte_swap_mask_addr()), rbx \/*rscratch*\/);\n@@ -211,0 +206,3 @@\n+\n+  __ pop(rbx);\n+\n@@ -231,0 +229,1 @@\n+  __ push(rbx);\n@@ -234,0 +233,1 @@\n+  __ pop(rbx);\n@@ -271,1 +271,1 @@\n-  __ movdqu(lswap_mask, ExternalAddress(StubRoutines::x86::ghash_long_swap_mask_addr()));\n+  __ movdqu(lswap_mask, ExternalAddress(ghash_long_swap_mask_addr()), rbx \/*rscratch*\/);\n@@ -287,1 +287,1 @@\n-  __ movdqu(bswap_mask, ExternalAddress(StubRoutines::x86::ghash_byte_swap_mask_addr()));\n+  __ movdqu(bswap_mask, ExternalAddress(ghash_byte_swap_mask_addr()), rbx \/*rscratch*\/);\n@@ -372,1 +372,1 @@\n-  __ movdqu(bswap_mask, ExternalAddress(StubRoutines::x86::ghash_byte_swap_mask_addr()));\n+  __ movdqu(bswap_mask, ExternalAddress(ghash_byte_swap_mask_addr()), rbx \/*rscratch*\/);\n@@ -396,1 +396,1 @@\n-  generateHtbl_one_block(htbl);\n+  generateHtbl_one_block(htbl, rbx \/*rscratch*\/);\n@@ -475,1 +475,1 @@\n-void StubGenerator::generateHtbl_one_block(Register htbl) {\n+void StubGenerator::generateHtbl_one_block(Register htbl, Register rscratch) {\n@@ -481,1 +481,1 @@\n-  __ movdqu(xmm10, ExternalAddress(StubRoutines::x86::ghash_long_swap_mask_addr()));\n+  __ movdqu(xmm10, ExternalAddress(ghash_long_swap_mask_addr()), rscratch);\n@@ -486,1 +486,1 @@\n-  __ movdqu(xmm4, ExternalAddress(StubRoutines::x86::ghash_shufflemask_addr()));\n+  __ movdqu(xmm4, ExternalAddress(ghash_shuffle_mask_addr()), rscratch);\n@@ -491,1 +491,1 @@\n-  __ movdqu(xmm5, ExternalAddress(StubRoutines::x86::ghash_polynomial_addr()));\n+  __ movdqu(xmm5, ExternalAddress(ghash_polynomial_addr()), rscratch);\n@@ -537,17 +537,0 @@\n-\n-void StubGenerator::generate_ghash_stubs() {\n-  if (UseGHASHIntrinsics) {\n-    if (StubRoutines::x86::_ghash_long_swap_mask_addr == NULL) {\n-      StubRoutines::x86::_ghash_long_swap_mask_addr = generate_ghash_long_swap_mask();\n-    }\n-    StubRoutines::x86::_ghash_byte_swap_mask_addr = generate_ghash_byte_swap_mask();\n-    if (VM_Version::supports_avx()) {\n-      StubRoutines::x86::_ghash_shuffmask_addr = generate_ghash_shufflemask_addr();\n-      StubRoutines::x86::_ghash_poly_addr = generate_ghash_polynomial_addr();\n-      StubRoutines::_ghash_processBlocks = generate_avx_ghash_processBlocks();\n-    } else {\n-      StubRoutines::_ghash_processBlocks = generate_ghash_processBlocks();\n-    }\n-  }\n-}\n-\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_ghash.cpp","additions":50,"deletions":67,"binary":false,"changes":117,"status":"modified"},{"patch":"@@ -0,0 +1,709 @@\n+\/*\n+* Copyright (c) 2016, 2021, Intel Corporation. All rights reserved.\n+* Copyright (C) 2021 THL A29 Limited, a Tencent company. All rights reserved.\n+* Intel Math Library (LIBM) Source Code\n+*\n+* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+*\n+* This code is free software; you can redistribute it and\/or modify it\n+* under the terms of the GNU General Public License version 2 only, as\n+* published by the Free Software Foundation.\n+*\n+* This code is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+* FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+* version 2 for more details (a copy is included in the LICENSE file that\n+* accompanied this code).\n+*\n+* You should have received a copy of the GNU General Public License version\n+* 2 along with this work; if not, write to the Free Software Foundation,\n+* Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+*\n+* Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+* or visit www.oracle.com if you need additional information or have any\n+* questions.\n+*\n+*\/\n+\n+#include \"precompiled.hpp\"\n+#include \"macroAssembler_x86.hpp\"\n+#include \"stubGenerator_x86_64.hpp\"\n+\n+\/******************************************************************************\/\n+\/\/                     ALGORITHM DESCRIPTION - LOG()\n+\/\/                     ---------------------\n+\/\/\n+\/\/    x=2^k * mx, mx in [1,2)\n+\/\/\n+\/\/    Get B~1\/mx based on the output of rcpss instruction (B0)\n+\/\/    B = int((B0*2^7+0.5))\/2^7\n+\/\/\n+\/\/    Reduced argument: r=B*mx-1.0 (computed accurately in high and low parts)\n+\/\/\n+\/\/    Result:  k*log(2) - log(B) + p(r) if |x-1| >= small value (2^-6)  and\n+\/\/             p(r) is a degree 7 polynomial\n+\/\/             -log(B) read from data table (high, low parts)\n+\/\/             Result is formed from high and low parts\n+\/\/\n+\/\/ Special cases:\n+\/\/  log(NaN) = quiet NaN, and raise invalid exception\n+\/\/  log(+INF) = that INF\n+\/\/  log(0) = -INF with divide-by-zero exception raised\n+\/\/  log(1) = +0\n+\/\/  log(x) = NaN with invalid exception raised if x < -0, including -INF\n+\/\/\n+\/******************************************************************************\/\n+\n+ATTRIBUTE_ALIGNED(16) juint _L_tbl[] =\n+{\n+    0xfefa3800UL, 0x3fe62e42UL, 0x93c76730UL, 0x3d2ef357UL, 0xaa241800UL,\n+    0x3fe5ee82UL, 0x0cda46beUL, 0x3d220238UL, 0x5c364800UL, 0x3fe5af40UL,\n+    0xac10c9fbUL, 0x3d2dfa63UL, 0x26bb8c00UL, 0x3fe5707aUL, 0xff3303ddUL,\n+    0x3d09980bUL, 0x26867800UL, 0x3fe5322eUL, 0x5d257531UL, 0x3d05ccc4UL,\n+    0x835a5000UL, 0x3fe4f45aUL, 0x6d93b8fbUL, 0xbd2e6c51UL, 0x6f970c00UL,\n+    0x3fe4b6fdUL, 0xed4c541cUL, 0x3cef7115UL, 0x27e8a400UL, 0x3fe47a15UL,\n+    0xf94d60aaUL, 0xbd22cb6aUL, 0xf2f92400UL, 0x3fe43d9fUL, 0x481051f7UL,\n+    0xbcfd984fUL, 0x2125cc00UL, 0x3fe4019cUL, 0x30f0c74cUL, 0xbd26ce79UL,\n+    0x0c36c000UL, 0x3fe3c608UL, 0x7cfe13c2UL, 0xbd02b736UL, 0x17197800UL,\n+    0x3fe38ae2UL, 0xbb5569a4UL, 0xbd218b7aUL, 0xad9d8c00UL, 0x3fe35028UL,\n+    0x9527e6acUL, 0x3d10b83fUL, 0x44340800UL, 0x3fe315daUL, 0xc5a0ed9cUL,\n+    0xbd274e93UL, 0x57b0e000UL, 0x3fe2dbf5UL, 0x07b9dc11UL, 0xbd17a6e5UL,\n+    0x6d0ec000UL, 0x3fe2a278UL, 0xe797882dUL, 0x3d206d2bUL, 0x1134dc00UL,\n+    0x3fe26962UL, 0x05226250UL, 0xbd0b61f1UL, 0xd8bebc00UL, 0x3fe230b0UL,\n+    0x6e48667bUL, 0x3d12fc06UL, 0x5fc61800UL, 0x3fe1f863UL, 0xc9fe81d3UL,\n+    0xbd2a7242UL, 0x49ae6000UL, 0x3fe1c078UL, 0xed70e667UL, 0x3cccacdeUL,\n+    0x40f23c00UL, 0x3fe188eeUL, 0xf8ab4650UL, 0x3d14cc4eUL, 0xf6f29800UL,\n+    0x3fe151c3UL, 0xa293ae49UL, 0xbd2edd97UL, 0x23c75c00UL, 0x3fe11af8UL,\n+    0xbb9ddcb2UL, 0xbd258647UL, 0x8611cc00UL, 0x3fe0e489UL, 0x07801742UL,\n+    0x3d1c2998UL, 0xe2d05400UL, 0x3fe0ae76UL, 0x887e7e27UL, 0x3d1f486bUL,\n+    0x0533c400UL, 0x3fe078bfUL, 0x41edf5fdUL, 0x3d268122UL, 0xbe760400UL,\n+    0x3fe04360UL, 0xe79539e0UL, 0xbd04c45fUL, 0xe5b20800UL, 0x3fe00e5aUL,\n+    0xb1727b1cUL, 0xbd053ba3UL, 0xaf7a4800UL, 0x3fdfb358UL, 0x3c164935UL,\n+    0x3d0085faUL, 0xee031800UL, 0x3fdf4aa7UL, 0x6f014a8bUL, 0x3d12cde5UL,\n+    0x56b41000UL, 0x3fdee2a1UL, 0x5a470251UL, 0x3d2f27f4UL, 0xc3ddb000UL,\n+    0x3fde7b42UL, 0x5372bd08UL, 0xbd246550UL, 0x1a272800UL, 0x3fde148aUL,\n+    0x07322938UL, 0xbd1326b2UL, 0x484c9800UL, 0x3fddae75UL, 0x60dc616aUL,\n+    0xbd1ea42dUL, 0x46def800UL, 0x3fdd4902UL, 0xe9a767a8UL, 0x3d235bafUL,\n+    0x18064800UL, 0x3fdce42fUL, 0x3ec7a6b0UL, 0xbd0797c3UL, 0xc7455800UL,\n+    0x3fdc7ff9UL, 0xc15249aeUL, 0xbd29b6ddUL, 0x693fa000UL, 0x3fdc1c60UL,\n+    0x7fe8e180UL, 0x3d2cec80UL, 0x1b80e000UL, 0x3fdbb961UL, 0xf40a666dUL,\n+    0x3d27d85bUL, 0x04462800UL, 0x3fdb56faUL, 0x2d841995UL, 0x3d109525UL,\n+    0x5248d000UL, 0x3fdaf529UL, 0x52774458UL, 0xbd217cc5UL, 0x3c8ad800UL,\n+    0x3fda93edUL, 0xbea77a5dUL, 0x3d1e36f2UL, 0x0224f800UL, 0x3fda3344UL,\n+    0x7f9d79f5UL, 0x3d23c645UL, 0xea15f000UL, 0x3fd9d32bUL, 0x10d0c0b0UL,\n+    0xbd26279eUL, 0x43135800UL, 0x3fd973a3UL, 0xa502d9f0UL, 0xbd152313UL,\n+    0x635bf800UL, 0x3fd914a8UL, 0x2ee6307dUL, 0xbd1766b5UL, 0xa88b3000UL,\n+    0x3fd8b639UL, 0xe5e70470UL, 0xbd205ae1UL, 0x776dc800UL, 0x3fd85855UL,\n+    0x3333778aUL, 0x3d2fd56fUL, 0x3bd81800UL, 0x3fd7fafaUL, 0xc812566aUL,\n+    0xbd272090UL, 0x687cf800UL, 0x3fd79e26UL, 0x2efd1778UL, 0x3d29ec7dUL,\n+    0x76c67800UL, 0x3fd741d8UL, 0x49dc60b3UL, 0x3d2d8b09UL, 0xe6af1800UL,\n+    0x3fd6e60eUL, 0x7c222d87UL, 0x3d172165UL, 0x3e9c6800UL, 0x3fd68ac8UL,\n+    0x2756eba0UL, 0x3d20a0d3UL, 0x0b3ab000UL, 0x3fd63003UL, 0xe731ae00UL,\n+    0xbd2db623UL, 0xdf596000UL, 0x3fd5d5bdUL, 0x08a465dcUL, 0xbd0a0b2aUL,\n+    0x53c8d000UL, 0x3fd57bf7UL, 0xee5d40efUL, 0x3d1fadedUL, 0x0738a000UL,\n+    0x3fd522aeUL, 0x8164c759UL, 0x3d2ebe70UL, 0x9e173000UL, 0x3fd4c9e0UL,\n+    0x1b0ad8a4UL, 0xbd2e2089UL, 0xc271c800UL, 0x3fd4718dUL, 0x0967d675UL,\n+    0xbd2f27ceUL, 0x23d5e800UL, 0x3fd419b4UL, 0xec90e09dUL, 0x3d08e436UL,\n+    0x77333000UL, 0x3fd3c252UL, 0xb606bd5cUL, 0x3d183b54UL, 0x76be1000UL,\n+    0x3fd36b67UL, 0xb0f177c8UL, 0x3d116ecdUL, 0xe1d36000UL, 0x3fd314f1UL,\n+    0xd3213cb8UL, 0xbd28e27aUL, 0x7cdc9000UL, 0x3fd2bef0UL, 0x4a5004f4UL,\n+    0x3d2a9cfaUL, 0x1134d800UL, 0x3fd26962UL, 0xdf5bb3b6UL, 0x3d2c93c1UL,\n+    0x6d0eb800UL, 0x3fd21445UL, 0xba46baeaUL, 0x3d0a87deUL, 0x635a6800UL,\n+    0x3fd1bf99UL, 0x5147bdb7UL, 0x3d2ca6edUL, 0xcbacf800UL, 0x3fd16b5cUL,\n+    0xf7a51681UL, 0x3d2b9acdUL, 0x8227e800UL, 0x3fd1178eUL, 0x63a5f01cUL,\n+    0xbd2c210eUL, 0x67616000UL, 0x3fd0c42dUL, 0x163ceae9UL, 0x3d27188bUL,\n+    0x604d5800UL, 0x3fd07138UL, 0x16ed4e91UL, 0x3cf89cdbUL, 0x5626c800UL,\n+    0x3fd01eaeUL, 0x1485e94aUL, 0xbd16f08cUL, 0x6cb3b000UL, 0x3fcf991cUL,\n+    0xca0cdf30UL, 0x3d1bcbecUL, 0xe4dd0000UL, 0x3fcef5adUL, 0x65bb8e11UL,\n+    0xbcca2115UL, 0xffe71000UL, 0x3fce530eUL, 0x6041f430UL, 0x3cc21227UL,\n+    0xb0d49000UL, 0x3fcdb13dUL, 0xf715b035UL, 0xbd2aff2aUL, 0xf2656000UL,\n+    0x3fcd1037UL, 0x75b6f6e4UL, 0xbd084a7eUL, 0xc6f01000UL, 0x3fcc6ffbUL,\n+    0xc5962bd2UL, 0xbcf1ec72UL, 0x383be000UL, 0x3fcbd087UL, 0x595412b6UL,\n+    0xbd2d4bc4UL, 0x575bd000UL, 0x3fcb31d8UL, 0x4eace1aaUL, 0xbd0c358dUL,\n+    0x3c8ae000UL, 0x3fca93edUL, 0x50562169UL, 0xbd287243UL, 0x07089000UL,\n+    0x3fc9f6c4UL, 0x6865817aUL, 0x3d29904dUL, 0xdcf70000UL, 0x3fc95a5aUL,\n+    0x58a0ff6fUL, 0x3d07f228UL, 0xeb390000UL, 0x3fc8beafUL, 0xaae92cd1UL,\n+    0xbd073d54UL, 0x6551a000UL, 0x3fc823c1UL, 0x9a631e83UL, 0x3d1e0ddbUL,\n+    0x85445000UL, 0x3fc7898dUL, 0x70914305UL, 0xbd1c6610UL, 0x8b757000UL,\n+    0x3fc6f012UL, 0xe59c21e1UL, 0xbd25118dUL, 0xbe8c1000UL, 0x3fc6574eUL,\n+    0x2c3c2e78UL, 0x3d19cf8bUL, 0x6b544000UL, 0x3fc5bf40UL, 0xeb68981cUL,\n+    0xbd127023UL, 0xe4a1b000UL, 0x3fc527e5UL, 0xe5697dc7UL, 0x3d2633e8UL,\n+    0x8333b000UL, 0x3fc4913dUL, 0x54fdb678UL, 0x3d258379UL, 0xa5993000UL,\n+    0x3fc3fb45UL, 0x7e6a354dUL, 0xbd2cd1d8UL, 0xb0159000UL, 0x3fc365fcUL,\n+    0x234b7289UL, 0x3cc62fa8UL, 0x0c868000UL, 0x3fc2d161UL, 0xcb81b4a1UL,\n+    0x3d039d6cUL, 0x2a49c000UL, 0x3fc23d71UL, 0x8fd3df5cUL, 0x3d100d23UL,\n+    0x7e23f000UL, 0x3fc1aa2bUL, 0x44389934UL, 0x3d2ca78eUL, 0x8227e000UL,\n+    0x3fc1178eUL, 0xce2d07f2UL, 0x3d21ef78UL, 0xb59e4000UL, 0x3fc08598UL,\n+    0x7009902cUL, 0xbd27e5ddUL, 0x39dbe000UL, 0x3fbfe891UL, 0x4fa10afdUL,\n+    0xbd2534d6UL, 0x830a2000UL, 0x3fbec739UL, 0xafe645e0UL, 0xbd2dc068UL,\n+    0x63844000UL, 0x3fbda727UL, 0x1fa71733UL, 0x3d1a8940UL, 0x01bc4000UL,\n+    0x3fbc8858UL, 0xc65aacd3UL, 0x3d2646d1UL, 0x8dad6000UL, 0x3fbb6ac8UL,\n+    0x2bf768e5UL, 0xbd139080UL, 0x40b1c000UL, 0x3fba4e76UL, 0xb94407c8UL,\n+    0xbd0e42b6UL, 0x5d594000UL, 0x3fb9335eUL, 0x3abd47daUL, 0x3d23115cUL,\n+    0x2f40e000UL, 0x3fb8197eUL, 0xf96ffdf7UL, 0x3d0f80dcUL, 0x0aeac000UL,\n+    0x3fb700d3UL, 0xa99ded32UL, 0x3cec1e8dUL, 0x4d97a000UL, 0x3fb5e95aUL,\n+    0x3c5d1d1eUL, 0xbd2c6906UL, 0x5d208000UL, 0x3fb4d311UL, 0x82f4e1efUL,\n+    0xbcf53a25UL, 0xa7d1e000UL, 0x3fb3bdf5UL, 0xa5db4ed7UL, 0x3d2cc85eUL,\n+    0xa4472000UL, 0x3fb2aa04UL, 0xae9c697dUL, 0xbd20b6e8UL, 0xd1466000UL,\n+    0x3fb1973bUL, 0x560d9e9bUL, 0xbd25325dUL, 0xb59e4000UL, 0x3fb08598UL,\n+    0x7009902cUL, 0xbd17e5ddUL, 0xc006c000UL, 0x3faeea31UL, 0x4fc93b7bUL,\n+    0xbd0e113eUL, 0xcdddc000UL, 0x3faccb73UL, 0x47d82807UL, 0xbd1a68f2UL,\n+    0xd0fb0000UL, 0x3faaaef2UL, 0x353bb42eUL, 0x3d20fc1aUL, 0x149fc000UL,\n+    0x3fa894aaUL, 0xd05a267dUL, 0xbd197995UL, 0xf2d4c000UL, 0x3fa67c94UL,\n+    0xec19afa2UL, 0xbd029efbUL, 0xd42e0000UL, 0x3fa466aeUL, 0x75bdfd28UL,\n+    0xbd2c1673UL, 0x2f8d0000UL, 0x3fa252f3UL, 0xe021b67bUL, 0x3d283e9aUL,\n+    0x89e74000UL, 0x3fa0415dUL, 0x5cf1d753UL, 0x3d0111c0UL, 0xec148000UL,\n+    0x3f9c63d2UL, 0x3f9eb2f3UL, 0x3d2578c6UL, 0x28c90000UL, 0x3f984925UL,\n+    0x325a0c34UL, 0xbd2aa0baUL, 0x25980000UL, 0x3f9432a9UL, 0x928637feUL,\n+    0x3d098139UL, 0x58938000UL, 0x3f902056UL, 0x06e2f7d2UL, 0xbd23dc5bUL,\n+    0xa3890000UL, 0x3f882448UL, 0xda74f640UL, 0xbd275577UL, 0x75890000UL,\n+    0x3f801015UL, 0x999d2be8UL, 0xbd10c76bUL, 0x59580000UL, 0x3f700805UL,\n+    0xcb31c67bUL, 0x3d2166afUL, 0x00000000UL, 0x00000000UL, 0x00000000UL,\n+    0x80000000UL\n+};\n+\n+ATTRIBUTE_ALIGNED(16) juint _log2[] =\n+{\n+    0xfefa3800UL, 0x3fa62e42UL, 0x93c76730UL, 0x3ceef357UL\n+};\n+\n+ATTRIBUTE_ALIGNED(16) juint _coeff[] =\n+{\n+    0x92492492UL, 0x3fc24924UL, 0x00000000UL, 0xbfd00000UL, 0x3d6fb175UL,\n+    0xbfc5555eUL, 0x55555555UL, 0x3fd55555UL, 0x9999999aUL, 0x3fc99999UL,\n+    0x00000000UL, 0xbfe00000UL\n+};\n+\n+#define __ _masm->\n+\n+address StubGenerator::generate_libmLog() {\n+  StubCodeMark mark(this, \"StubRoutines\", \"libmLog\");\n+  address start = __ pc();\n+\n+  Label L_2TAG_PACKET_0_0_2, L_2TAG_PACKET_1_0_2, L_2TAG_PACKET_2_0_2, L_2TAG_PACKET_3_0_2;\n+  Label L_2TAG_PACKET_4_0_2, L_2TAG_PACKET_5_0_2, L_2TAG_PACKET_6_0_2, L_2TAG_PACKET_7_0_2;\n+  Label L_2TAG_PACKET_8_0_2;\n+  Label B1_3, B1_5;\n+\n+  address L_tbl = (address)_L_tbl;\n+  address log2  = (address)_log2;\n+  address coeff = (address)_coeff;\n+\n+  __ enter(); \/\/ required for proper stackwalking of RuntimeStub frame\n+\n+  __ subq(rsp, 24);\n+  __ movsd(Address(rsp, 0), xmm0);\n+  __ mov64(rax, 0x3ff0000000000000);\n+  __ movdq(xmm2, rax);\n+  __ mov64(rdx, 0x77f0000000000000);\n+  __ movdq(xmm3, rdx);\n+  __ movl(rcx, 32768);\n+  __ movdl(xmm4, rcx);\n+  __ mov64(r11, 0xffffe00000000000);\n+  __ movdq(xmm5, r11);\n+  __ movdqu(xmm1, xmm0);\n+  __ pextrw(rax, xmm0, 3);\n+  __ por(xmm0, xmm2);\n+  __ movl(rcx, 16352);\n+  __ psrlq(xmm0, 27);\n+  __ lea(r8, ExternalAddress(L_tbl));\n+  __ psrld(xmm0, 2);\n+  __ rcpps(xmm0, xmm0);\n+  __ psllq(xmm1, 12);\n+  __ pshufd(xmm6, xmm5, 228);\n+  __ psrlq(xmm1, 12);\n+  __ subl(rax, 16);\n+  __ cmpl(rax, 32736);\n+  __ jcc(Assembler::aboveEqual, L_2TAG_PACKET_0_0_2);\n+\n+  __ bind(L_2TAG_PACKET_1_0_2);\n+  __ paddd(xmm0, xmm4);\n+  __ por(xmm1, xmm3);\n+  __ movdl(rdx, xmm0);\n+  __ psllq(xmm0, 29);\n+  __ pand(xmm5, xmm1);\n+  __ pand(xmm0, xmm6);\n+  __ subsd(xmm1, xmm5);\n+  __ mulpd(xmm5, xmm0);\n+  __ andl(rax, 32752);\n+  __ subl(rax, rcx);\n+  __ cvtsi2sdl(xmm7, rax);\n+  __ mulsd(xmm1, xmm0);\n+  __ movq(xmm6, ExternalAddress(log2), r11 \/*rscratch*\/);       \/\/ 0xfefa3800UL, 0x3fa62e42UL\n+  __ movdqu(xmm3, ExternalAddress(coeff), r11 \/*rscratch*\/);    \/\/ 0x92492492UL, 0x3fc24924UL, 0x00000000UL, 0xbfd00000UL\n+  __ subsd(xmm5, xmm2);\n+  __ andl(rdx, 16711680);\n+  __ shrl(rdx, 12);\n+  __ movdqu(xmm0, Address(r8, rdx));\n+  __ movdqu(xmm4, ExternalAddress(coeff + 16), r11 \/*rscratch*\/); \/\/ 0x3d6fb175UL, 0xbfc5555eUL, 0x55555555UL, 0x3fd55555UL\n+  __ addsd(xmm1, xmm5);\n+  __ movdqu(xmm2, ExternalAddress(coeff + 32), r11 \/*rscratch*\/); \/\/ 0x9999999aUL, 0x3fc99999UL, 0x00000000UL, 0xbfe00000UL\n+  __ mulsd(xmm6, xmm7);\n+  if (VM_Version::supports_sse3()) {\n+    __ movddup(xmm5, xmm1);\n+  }\n+  else {\n+    __ movdqu(xmm5, xmm1);\n+    __ movlhps(xmm5, xmm5);\n+  }\n+  __ mulsd(xmm7, ExternalAddress(log2 + 8), r11 \/*rscratch*\/);    \/\/ 0x93c76730UL, 0x3ceef357UL\n+  __ mulsd(xmm3, xmm1);\n+  __ addsd(xmm0, xmm6);\n+  __ mulpd(xmm4, xmm5);\n+  __ mulpd(xmm5, xmm5);\n+  if (VM_Version::supports_sse3()) {\n+    __ movddup(xmm6, xmm0);\n+  }\n+  else {\n+    __ movdqu(xmm6, xmm0);\n+    __ movlhps(xmm6, xmm6);\n+  }\n+  __ addsd(xmm0, xmm1);\n+  __ addpd(xmm4, xmm2);\n+  __ mulpd(xmm3, xmm5);\n+  __ subsd(xmm6, xmm0);\n+  __ mulsd(xmm4, xmm1);\n+  __ pshufd(xmm2, xmm0, 238);\n+  __ addsd(xmm1, xmm6);\n+  __ mulsd(xmm5, xmm5);\n+  __ addsd(xmm7, xmm2);\n+  __ addpd(xmm4, xmm3);\n+  __ addsd(xmm1, xmm7);\n+  __ mulpd(xmm4, xmm5);\n+  __ addsd(xmm1, xmm4);\n+  __ pshufd(xmm5, xmm4, 238);\n+  __ addsd(xmm1, xmm5);\n+  __ addsd(xmm0, xmm1);\n+  __ jmp(B1_5);\n+\n+  __ bind(L_2TAG_PACKET_0_0_2);\n+  __ movq(xmm0, Address(rsp, 0));\n+  __ movq(xmm1, Address(rsp, 0));\n+  __ addl(rax, 16);\n+  __ cmpl(rax, 32768);\n+  __ jcc(Assembler::aboveEqual, L_2TAG_PACKET_2_0_2);\n+  __ cmpl(rax, 16);\n+  __ jcc(Assembler::below, L_2TAG_PACKET_3_0_2);\n+\n+  __ bind(L_2TAG_PACKET_4_0_2);\n+  __ addsd(xmm0, xmm0);\n+  __ jmp(B1_5);\n+\n+  __ bind(L_2TAG_PACKET_5_0_2);\n+  __ jcc(Assembler::above, L_2TAG_PACKET_4_0_2);\n+  __ cmpl(rdx, 0);\n+  __ jcc(Assembler::above, L_2TAG_PACKET_4_0_2);\n+  __ jmp(L_2TAG_PACKET_6_0_2);\n+\n+  __ bind(L_2TAG_PACKET_3_0_2);\n+  __ xorpd(xmm1, xmm1);\n+  __ addsd(xmm1, xmm0);\n+  __ movdl(rdx, xmm1);\n+  __ psrlq(xmm1, 32);\n+  __ movdl(rcx, xmm1);\n+  __ orl(rdx, rcx);\n+  __ cmpl(rdx, 0);\n+  __ jcc(Assembler::equal, L_2TAG_PACKET_7_0_2);\n+  __ xorpd(xmm1, xmm1);\n+  __ movl(rax, 18416);\n+  __ pinsrw(xmm1, rax, 3);\n+  __ mulsd(xmm0, xmm1);\n+  __ movdqu(xmm1, xmm0);\n+  __ pextrw(rax, xmm0, 3);\n+  __ por(xmm0, xmm2);\n+  __ psrlq(xmm0, 27);\n+  __ movl(rcx, 18416);\n+  __ psrld(xmm0, 2);\n+  __ rcpps(xmm0, xmm0);\n+  __ psllq(xmm1, 12);\n+  __ pshufd(xmm6, xmm5, 228);\n+  __ psrlq(xmm1, 12);\n+  __ jmp(L_2TAG_PACKET_1_0_2);\n+\n+  __ bind(L_2TAG_PACKET_2_0_2);\n+  __ movdl(rdx, xmm1);\n+  __ psrlq(xmm1, 32);\n+  __ movdl(rcx, xmm1);\n+  __ addl(rcx, rcx);\n+  __ cmpl(rcx, -2097152);\n+  __ jcc(Assembler::aboveEqual, L_2TAG_PACKET_5_0_2);\n+  __ orl(rdx, rcx);\n+  __ cmpl(rdx, 0);\n+  __ jcc(Assembler::equal, L_2TAG_PACKET_7_0_2);\n+\n+  __ bind(L_2TAG_PACKET_6_0_2);\n+  __ xorpd(xmm1, xmm1);\n+  __ xorpd(xmm0, xmm0);\n+  __ movl(rax, 32752);\n+  __ pinsrw(xmm1, rax, 3);\n+  __ mulsd(xmm0, xmm1);\n+  __ movl(Address(rsp, 16), 3);\n+  __ jmp(L_2TAG_PACKET_8_0_2);\n+  __ bind(L_2TAG_PACKET_7_0_2);\n+  __ xorpd(xmm1, xmm1);\n+  __ xorpd(xmm0, xmm0);\n+  __ movl(rax, 49136);\n+  __ pinsrw(xmm0, rax, 3);\n+  __ divsd(xmm0, xmm1);\n+  __ movl(Address(rsp, 16), 2);\n+\n+  __ bind(L_2TAG_PACKET_8_0_2);\n+  __ movq(Address(rsp, 8), xmm0);\n+\n+  __ bind(B1_3);\n+  __ movq(xmm0, Address(rsp, 8));\n+\n+  __ bind(B1_5);\n+  __ addq(rsp, 24);\n+\n+  __ leave(); \/\/ required for proper stackwalking of RuntimeStub frame\n+  __ ret(0);\n+\n+  return start;\n+}\n+\n+\/******************************************************************************\/\n+\/\/                     ALGORITHM DESCRIPTION - LOG10()\n+\/\/                     ---------------------\n+\/\/\n+\/\/    Let x=2^k * mx, mx in [1,2)\n+\/\/\n+\/\/    Get B~1\/mx based on the output of rcpss instruction (B0)\n+\/\/    B = int((B0*LH*2^7+0.5))\/2^7\n+\/\/    LH is a short approximation for log10(e)\n+\/\/\n+\/\/    Reduced argument: r=B*mx-LH (computed accurately in high and low parts)\n+\/\/\n+\/\/    Result:  k*log10(2) - log(B) + p(r)\n+\/\/             p(r) is a degree 7 polynomial\n+\/\/             -log(B) read from data table (high, low parts)\n+\/\/             Result is formed from high and low parts\n+\/\/\n+\/\/ Special cases:\n+\/\/  log10(0) = -INF with divide-by-zero exception raised\n+\/\/  log10(1) = +0\n+\/\/  log10(x) = NaN with invalid exception raised if x < -0, including -INF\n+\/\/  log10(+INF) = +INF\n+\/\/\n+\/******************************************************************************\/\n+\n+ATTRIBUTE_ALIGNED(16) juint _HIGHSIGMASK_log10[] = {\n+    0xf8000000UL, 0xffffffffUL, 0x00000000UL, 0xffffe000UL\n+};\n+\n+ATTRIBUTE_ALIGNED(16) juint _LOG10_E[] = {\n+    0x00000000UL, 0x3fdbc000UL, 0xbf2e4108UL, 0x3f5a7a6cUL\n+};\n+\n+ATTRIBUTE_ALIGNED(16) juint _L_tbl_log10[] = {\n+    0x509f7800UL, 0x3fd34413UL, 0x1f12b358UL, 0x3d1fef31UL, 0x80333400UL,\n+    0x3fd32418UL, 0xc671d9d0UL, 0xbcf542bfUL, 0x51195000UL, 0x3fd30442UL,\n+    0x78a4b0c3UL, 0x3d18216aUL, 0x6fc79400UL, 0x3fd2e490UL, 0x80fa389dUL,\n+    0xbc902869UL, 0x89d04000UL, 0x3fd2c502UL, 0x75c2f564UL, 0x3d040754UL,\n+    0x4ddd1c00UL, 0x3fd2a598UL, 0xd219b2c3UL, 0xbcfa1d84UL, 0x6baa7c00UL,\n+    0x3fd28651UL, 0xfd9abec1UL, 0x3d1be6d3UL, 0x94028800UL, 0x3fd2672dUL,\n+    0xe289a455UL, 0xbd1ede5eUL, 0x78b86400UL, 0x3fd2482cUL, 0x6734d179UL,\n+    0x3d1fe79bUL, 0xcca3c800UL, 0x3fd2294dUL, 0x981a40b8UL, 0xbced34eaUL,\n+    0x439c5000UL, 0x3fd20a91UL, 0xcc392737UL, 0xbd1a9cc3UL, 0x92752c00UL,\n+    0x3fd1ebf6UL, 0x03c9afe7UL, 0x3d1e98f8UL, 0x6ef8dc00UL, 0x3fd1cd7dUL,\n+    0x71dae7f4UL, 0x3d08a86cUL, 0x8fe4dc00UL, 0x3fd1af25UL, 0xee9185a1UL,\n+    0xbcff3412UL, 0xace59400UL, 0x3fd190eeUL, 0xc2cab353UL, 0x3cf17ed9UL,\n+    0x7e925000UL, 0x3fd172d8UL, 0x6952c1b2UL, 0x3cf1521cUL, 0xbe694400UL,\n+    0x3fd154e2UL, 0xcacb79caUL, 0xbd0bdc78UL, 0x26cbac00UL, 0x3fd1370dUL,\n+    0xf71f4de1UL, 0xbd01f8beUL, 0x72fa0800UL, 0x3fd11957UL, 0x55bf910bUL,\n+    0x3c946e2bUL, 0x5f106000UL, 0x3fd0fbc1UL, 0x39e639c1UL, 0x3d14a84bUL,\n+    0xa802a800UL, 0x3fd0de4aUL, 0xd3f31d5dUL, 0xbd178385UL, 0x0b992000UL,\n+    0x3fd0c0f3UL, 0x3843106fUL, 0xbd1f602fUL, 0x486ce800UL, 0x3fd0a3baUL,\n+    0x8819497cUL, 0x3cef987aUL, 0x1de49400UL, 0x3fd086a0UL, 0x1caa0467UL,\n+    0x3d0faec7UL, 0x4c30cc00UL, 0x3fd069a4UL, 0xa4424372UL, 0xbd1618fcUL,\n+    0x94490000UL, 0x3fd04cc6UL, 0x946517d2UL, 0xbd18384bUL, 0xb7e84000UL,\n+    0x3fd03006UL, 0xe0109c37UL, 0xbd19a6acUL, 0x798a0c00UL, 0x3fd01364UL,\n+    0x5121e864UL, 0xbd164cf7UL, 0x38ce8000UL, 0x3fcfedbfUL, 0x46214d1aUL,\n+    0xbcbbc402UL, 0xc8e62000UL, 0x3fcfb4efUL, 0xdab93203UL, 0x3d1e0176UL,\n+    0x2cb02800UL, 0x3fcf7c5aUL, 0x2a2ea8e4UL, 0xbcfec86aUL, 0xeeeaa000UL,\n+    0x3fcf43fdUL, 0xc18e49a4UL, 0x3cf110a8UL, 0x9bb6e800UL, 0x3fcf0bdaUL,\n+    0x923cc9c0UL, 0xbd15ce99UL, 0xc093f000UL, 0x3fced3efUL, 0x4d4b51e9UL,\n+    0x3d1a04c7UL, 0xec58f800UL, 0x3fce9c3cUL, 0x163cad59UL, 0x3cac8260UL,\n+    0x9a907000UL, 0x3fce2d7dUL, 0x3fa93646UL, 0x3ce4a1c0UL, 0x37311000UL,\n+    0x3fcdbf99UL, 0x32abd1fdUL, 0x3d07ea9dUL, 0x6744b800UL, 0x3fcd528cUL,\n+    0x4dcbdfd4UL, 0xbd1b08e2UL, 0xe36de800UL, 0x3fcce653UL, 0x0b7b7f7fUL,\n+    0xbd1b8f03UL, 0x77506800UL, 0x3fcc7aecUL, 0xa821c9fbUL, 0x3d13c163UL,\n+    0x00ff8800UL, 0x3fcc1053UL, 0x536bca76UL, 0xbd074ee5UL, 0x70719800UL,\n+    0x3fcba684UL, 0xd7da9b6bUL, 0xbd1fbf16UL, 0xc6f8d800UL, 0x3fcb3d7dUL,\n+    0xe2220bb3UL, 0x3d1a295dUL, 0x16c15800UL, 0x3fcad53cUL, 0xe724911eUL,\n+    0xbcf55822UL, 0x82533800UL, 0x3fca6dbcUL, 0x6d982371UL, 0x3cac567cUL,\n+    0x3c19e800UL, 0x3fca06fcUL, 0x84d17d80UL, 0x3d1da204UL, 0x85ef8000UL,\n+    0x3fc9a0f8UL, 0x54466a6aUL, 0xbd002204UL, 0xb0ac2000UL, 0x3fc93baeUL,\n+    0xd601fd65UL, 0x3d18840cUL, 0x1bb9b000UL, 0x3fc8d71cUL, 0x7bf58766UL,\n+    0xbd14f897UL, 0x34aae800UL, 0x3fc8733eUL, 0x3af6ac24UL, 0xbd0f5c45UL,\n+    0x76d68000UL, 0x3fc81012UL, 0x4303e1a1UL, 0xbd1f9a80UL, 0x6af57800UL,\n+    0x3fc7ad96UL, 0x43fbcb46UL, 0x3cf4c33eUL, 0xa6c51000UL, 0x3fc74bc7UL,\n+    0x70f0eac5UL, 0xbd192e3bUL, 0xccab9800UL, 0x3fc6eaa3UL, 0xc0093dfeUL,\n+    0xbd0faf15UL, 0x8b60b800UL, 0x3fc68a28UL, 0xde78d5fdUL, 0xbc9ea4eeUL,\n+    0x9d987000UL, 0x3fc62a53UL, 0x962bea6eUL, 0xbd194084UL, 0xc9b0e800UL,\n+    0x3fc5cb22UL, 0x888dd999UL, 0x3d1fe201UL, 0xe1634800UL, 0x3fc56c93UL,\n+    0x16ada7adUL, 0x3d1b1188UL, 0xc176c000UL, 0x3fc50ea4UL, 0x4159b5b5UL,\n+    0xbcf09c08UL, 0x51766000UL, 0x3fc4b153UL, 0x84393d23UL, 0xbcf6a89cUL,\n+    0x83695000UL, 0x3fc4549dUL, 0x9f0b8bbbUL, 0x3d1c4b8cUL, 0x538d5800UL,\n+    0x3fc3f881UL, 0xf49df747UL, 0x3cf89b99UL, 0xc8138000UL, 0x3fc39cfcUL,\n+    0xd503b834UL, 0xbd13b99fUL, 0xf0df0800UL, 0x3fc3420dUL, 0xf011b386UL,\n+    0xbd05d8beUL, 0xe7466800UL, 0x3fc2e7b2UL, 0xf39c7bc2UL, 0xbd1bb94eUL,\n+    0xcdd62800UL, 0x3fc28de9UL, 0x05e6d69bUL, 0xbd10ed05UL, 0xd015d800UL,\n+    0x3fc234b0UL, 0xe29b6c9dUL, 0xbd1ff967UL, 0x224ea800UL, 0x3fc1dc06UL,\n+    0x727711fcUL, 0xbcffb30dUL, 0x01540000UL, 0x3fc183e8UL, 0x39786c5aUL,\n+    0x3cc23f57UL, 0xb24d9800UL, 0x3fc12c54UL, 0xc905a342UL, 0x3d003a1dUL,\n+    0x82835800UL, 0x3fc0d54aUL, 0x9b9920c0UL, 0x3d03b25aUL, 0xc72ac000UL,\n+    0x3fc07ec7UL, 0x46f26a24UL, 0x3cf0fa41UL, 0xdd35d800UL, 0x3fc028caUL,\n+    0x41d9d6dcUL, 0x3d034a65UL, 0x52474000UL, 0x3fbfa6a4UL, 0x44f66449UL,\n+    0x3d19cad3UL, 0x2da3d000UL, 0x3fbefcb8UL, 0x67832999UL, 0x3d18400fUL,\n+    0x32a10000UL, 0x3fbe53ceUL, 0x9c0e3b1aUL, 0xbcff62fdUL, 0x556b7000UL,\n+    0x3fbdabe3UL, 0x02976913UL, 0xbcf8243bUL, 0x97e88000UL, 0x3fbd04f4UL,\n+    0xec793797UL, 0x3d1c0578UL, 0x09647000UL, 0x3fbc5effUL, 0x05fc0565UL,\n+    0xbd1d799eUL, 0xc6426000UL, 0x3fbbb9ffUL, 0x4625f5edUL, 0x3d1f5723UL,\n+    0xf7afd000UL, 0x3fbb15f3UL, 0xdd5aae61UL, 0xbd1a7e1eUL, 0xd358b000UL,\n+    0x3fba72d8UL, 0x3314e4d3UL, 0x3d17bc91UL, 0x9b1f5000UL, 0x3fb9d0abUL,\n+    0x9a4d514bUL, 0x3cf18c9bUL, 0x9cd4e000UL, 0x3fb92f69UL, 0x7e4496abUL,\n+    0x3cf1f96dUL, 0x31f4f000UL, 0x3fb88f10UL, 0xf56479e7UL, 0x3d165818UL,\n+    0xbf628000UL, 0x3fb7ef9cUL, 0x26bf486dUL, 0xbd1113a6UL, 0xb526b000UL,\n+    0x3fb7510cUL, 0x1a1c3384UL, 0x3ca9898dUL, 0x8e31e000UL, 0x3fb6b35dUL,\n+    0xb3875361UL, 0xbd0661acUL, 0xd01de000UL, 0x3fb6168cUL, 0x2a7cacfaUL,\n+    0xbd1bdf10UL, 0x0af23000UL, 0x3fb57a98UL, 0xff868816UL, 0x3cf046d0UL,\n+    0xd8ea0000UL, 0x3fb4df7cUL, 0x1515fbe7UL, 0xbd1fd529UL, 0xde3b2000UL,\n+    0x3fb44538UL, 0x6e59a132UL, 0x3d1faeeeUL, 0xc8df9000UL, 0x3fb3abc9UL,\n+    0xf1322361UL, 0xbd198807UL, 0x505f1000UL, 0x3fb3132dUL, 0x0888e6abUL,\n+    0x3d1e5380UL, 0x359bd000UL, 0x3fb27b61UL, 0xdfbcbb22UL, 0xbcfe2724UL,\n+    0x429ee000UL, 0x3fb1e463UL, 0x6eb4c58cUL, 0xbcfe4dd6UL, 0x4a673000UL,\n+    0x3fb14e31UL, 0x4ce1ac9bUL, 0x3d1ba691UL, 0x28b96000UL, 0x3fb0b8c9UL,\n+    0x8c7813b8UL, 0xbd0b3872UL, 0xc1f08000UL, 0x3fb02428UL, 0xc2bc8c2cUL,\n+    0x3cb5ea6bUL, 0x05a1a000UL, 0x3faf209cUL, 0x72e8f18eUL, 0xbce8df84UL,\n+    0xc0b5e000UL, 0x3fadfa6dUL, 0x9fdef436UL, 0x3d087364UL, 0xaf416000UL,\n+    0x3facd5c2UL, 0x1068c3a9UL, 0x3d0827e7UL, 0xdb356000UL, 0x3fabb296UL,\n+    0x120a34d3UL, 0x3d101a9fUL, 0x5dfea000UL, 0x3faa90e6UL, 0xdaded264UL,\n+    0xbd14c392UL, 0x6034c000UL, 0x3fa970adUL, 0x1c9d06a9UL, 0xbd1b705eUL,\n+    0x194c6000UL, 0x3fa851e8UL, 0x83996ad9UL, 0xbd0117bcUL, 0xcf4ac000UL,\n+    0x3fa73492UL, 0xb1a94a62UL, 0xbca5ea42UL, 0xd67b4000UL, 0x3fa618a9UL,\n+    0x75aed8caUL, 0xbd07119bUL, 0x9126c000UL, 0x3fa4fe29UL, 0x5291d533UL,\n+    0x3d12658fUL, 0x6f4d4000UL, 0x3fa3e50eUL, 0xcd2c5cd9UL, 0x3d1d5c70UL,\n+    0xee608000UL, 0x3fa2cd54UL, 0xd1008489UL, 0x3d1a4802UL, 0x9900e000UL,\n+    0x3fa1b6f9UL, 0x54fb5598UL, 0xbd16593fUL, 0x06bb6000UL, 0x3fa0a1f9UL,\n+    0x64ef57b4UL, 0xbd17636bUL, 0xb7940000UL, 0x3f9f1c9fUL, 0xee6a4737UL,\n+    0x3cb5d479UL, 0x91aa0000UL, 0x3f9cf7f5UL, 0x3a16373cUL, 0x3d087114UL,\n+    0x156b8000UL, 0x3f9ad5edUL, 0x836c554aUL, 0x3c6900b0UL, 0xd4764000UL,\n+    0x3f98b67fUL, 0xed12f17bUL, 0xbcffc974UL, 0x77dec000UL, 0x3f9699a7UL,\n+    0x232ce7eaUL, 0x3d1e35bbUL, 0xbfbf4000UL, 0x3f947f5dUL, 0xd84ffa6eUL,\n+    0x3d0e0a49UL, 0x82c7c000UL, 0x3f92679cUL, 0x8d170e90UL, 0xbd14d9f2UL,\n+    0xadd20000UL, 0x3f90525dUL, 0x86d9f88eUL, 0x3cdeb986UL, 0x86f10000UL,\n+    0x3f8c7f36UL, 0xb9e0a517UL, 0x3ce29faaUL, 0xb75c8000UL, 0x3f885e9eUL,\n+    0x542568cbUL, 0xbd1f7bdbUL, 0x46b30000UL, 0x3f8442e8UL, 0xb954e7d9UL,\n+    0x3d1e5287UL, 0xb7e60000UL, 0x3f802c07UL, 0x22da0b17UL, 0xbd19fb27UL,\n+    0x6c8b0000UL, 0x3f7833e3UL, 0x821271efUL, 0xbd190f96UL, 0x29910000UL,\n+    0x3f701936UL, 0xbc3491a5UL, 0xbd1bcf45UL, 0x354a0000UL, 0x3f600fe3UL,\n+    0xc0ff520aUL, 0xbd19d71cUL, 0x00000000UL, 0x00000000UL, 0x00000000UL,\n+    0x00000000UL\n+};\n+\n+ATTRIBUTE_ALIGNED(16) juint _log2_log10[] =\n+{\n+    0x509f7800UL, 0x3f934413UL, 0x1f12b358UL, 0x3cdfef31UL\n+};\n+\n+ATTRIBUTE_ALIGNED(16) juint _coeff_log10[] =\n+{\n+    0xc1a5f12eUL, 0x40358874UL, 0x64d4ef0dUL, 0xc0089309UL, 0x385593b1UL,\n+    0xc025c917UL, 0xdc963467UL, 0x3ffc6a02UL, 0x7f9d3aa1UL, 0x4016ab9fUL,\n+    0xdc77b115UL, 0xbff27af2UL\n+};\n+\n+address StubGenerator::generate_libmLog10() {\n+  StubCodeMark mark(this, \"StubRoutines\", \"libmLog10\");\n+  address start = __ pc();\n+\n+  Label L_2TAG_PACKET_0_0_2, L_2TAG_PACKET_1_0_2, L_2TAG_PACKET_2_0_2, L_2TAG_PACKET_3_0_2;\n+  Label L_2TAG_PACKET_4_0_2, L_2TAG_PACKET_5_0_2, L_2TAG_PACKET_6_0_2, L_2TAG_PACKET_7_0_2;\n+  Label L_2TAG_PACKET_8_0_2, L_2TAG_PACKET_9_0_2, B1_2, B1_3, B1_5;\n+\n+  address HIGHSIGMASK = (address)_HIGHSIGMASK_log10;\n+  address LOG10_E = (address)_LOG10_E;\n+  address L_tbl = (address)_L_tbl_log10;\n+  address log2 = (address)_log2_log10;\n+  address coeff = (address)_coeff_log10;\n+\n+  __ enter(); \/\/ required for proper stackwalking of RuntimeStub frame\n+\n+  __ subq(rsp, 24);\n+  __ movsd(Address(rsp, 0), xmm0);\n+\n+  __ bind(B1_2);\n+  __ xorpd(xmm2, xmm2);\n+  __ movl(rax, 16368);\n+  __ pinsrw(xmm2, rax, 3);\n+  __ movl(rcx, 1054736384);\n+  __ movdl(xmm7, rcx);\n+  __ xorpd(xmm3, xmm3);\n+  __ movl(rdx, 30704);\n+  __ pinsrw(xmm3, rdx, 3);\n+  __ movdqu(xmm1, xmm0);\n+  __ movl(rdx, 32768);\n+  __ movdl(xmm4, rdx);\n+  __ movdqu(xmm5, ExternalAddress(HIGHSIGMASK), r8 \/*rscratch*\/);    \/\/0xf8000000UL, 0xffffffffUL, 0x00000000UL, 0xffffe000UL\n+  __ pextrw(rax, xmm0, 3);\n+  __ por(xmm0, xmm2);\n+  __ movl(rcx, 16352);\n+  __ psrlq(xmm0, 27);\n+  __ movdqu(xmm2, ExternalAddress(LOG10_E), r8 \/*rscratch*\/);    \/\/0x00000000UL, 0x3fdbc000UL, 0xbf2e4108UL, 0x3f5a7a6cUL\n+  __ psrld(xmm0, 2);\n+  __ rcpps(xmm0, xmm0);\n+  __ psllq(xmm1, 12);\n+  __ pshufd(xmm6, xmm5, 78);\n+  __ psrlq(xmm1, 12);\n+  __ subl(rax, 16);\n+  __ cmpl(rax, 32736);\n+  __ jcc(Assembler::aboveEqual, L_2TAG_PACKET_0_0_2);\n+\n+  __ bind(L_2TAG_PACKET_1_0_2);\n+  __ mulss(xmm0, xmm7);\n+  __ por(xmm1, xmm3);\n+  __ lea(r11, ExternalAddress(L_tbl));\n+  __ andpd(xmm5, xmm1);\n+  __ paddd(xmm0, xmm4);\n+  __ subsd(xmm1, xmm5);\n+  __ movdl(rdx, xmm0);\n+  __ psllq(xmm0, 29);\n+  __ andpd(xmm0, xmm6);\n+  __ andl(rax, 32752);\n+  __ subl(rax, rcx);\n+  __ cvtsi2sdl(xmm7, rax);\n+  __ mulpd(xmm5, xmm0);\n+  __ mulsd(xmm1, xmm0);\n+  __ movq(xmm6, ExternalAddress(log2), r8 \/*rscratch*\/);    \/\/0x509f7800UL, 0x3f934413UL, 0x1f12b358UL, 0x3cdfef31UL\n+  __ movdqu(xmm3, ExternalAddress(coeff), r8 \/*rscratch*\/);    \/\/0xc1a5f12eUL, 0x40358874UL, 0x64d4ef0dUL, 0xc0089309UL\n+  __ subsd(xmm5, xmm2);\n+  __ andl(rdx, 16711680);\n+  __ shrl(rdx, 12);\n+  __ movdqu(xmm0, Address(r11, rdx, Address::times_1, -1504));\n+  __ movdqu(xmm4, ExternalAddress(coeff + 16), r8 \/*rscratch*\/);    \/\/0x385593b1UL, 0xc025c917UL, 0xdc963467UL, 0x3ffc6a02UL\n+  __ addsd(xmm1, xmm5);\n+  __ movdqu(xmm2, ExternalAddress(coeff + 32), r8 \/*rscratch*\/);    \/\/0x7f9d3aa1UL, 0x4016ab9fUL, 0xdc77b115UL, 0xbff27af2UL\n+  __ mulsd(xmm6, xmm7);\n+  __ pshufd(xmm5, xmm1, 68);\n+  __ mulsd(xmm7, ExternalAddress(log2 + 8), r8 \/*rscratch*\/);    \/\/0x1f12b358UL, 0x3cdfef31UL\n+  __ mulsd(xmm3, xmm1);\n+  __ addsd(xmm0, xmm6);\n+  __ mulpd(xmm4, xmm5);\n+  __ movq(xmm6, ExternalAddress(LOG10_E + 8), r8 \/*rscratch*\/);    \/\/0xbf2e4108UL, 0x3f5a7a6cUL\n+  __ mulpd(xmm5, xmm5);\n+  __ addpd(xmm4, xmm2);\n+  __ mulpd(xmm3, xmm5);\n+  __ pshufd(xmm2, xmm0, 228);\n+  __ addsd(xmm0, xmm1);\n+  __ mulsd(xmm4, xmm1);\n+  __ subsd(xmm2, xmm0);\n+  __ mulsd(xmm6, xmm1);\n+  __ addsd(xmm1, xmm2);\n+  __ pshufd(xmm2, xmm0, 238);\n+  __ mulsd(xmm5, xmm5);\n+  __ addsd(xmm7, xmm2);\n+  __ addsd(xmm1, xmm6);\n+  __ addpd(xmm4, xmm3);\n+  __ addsd(xmm1, xmm7);\n+  __ mulpd(xmm4, xmm5);\n+  __ addsd(xmm1, xmm4);\n+  __ pshufd(xmm5, xmm4, 238);\n+  __ addsd(xmm1, xmm5);\n+  __ addsd(xmm0, xmm1);\n+  __ jmp(B1_5);\n+\n+  __ bind(L_2TAG_PACKET_0_0_2);\n+  __ movq(xmm0, Address(rsp, 0));\n+  __ movq(xmm1, Address(rsp, 0));\n+  __ addl(rax, 16);\n+  __ cmpl(rax, 32768);\n+  __ jcc(Assembler::aboveEqual, L_2TAG_PACKET_2_0_2);\n+  __ cmpl(rax, 16);\n+  __ jcc(Assembler::below, L_2TAG_PACKET_3_0_2);\n+\n+  __ bind(L_2TAG_PACKET_4_0_2);\n+  __ addsd(xmm0, xmm0);\n+  __ jmp(B1_5);\n+\n+  __ bind(L_2TAG_PACKET_5_0_2);\n+  __ jcc(Assembler::above, L_2TAG_PACKET_4_0_2);\n+  __ cmpl(rdx, 0);\n+  __ jcc(Assembler::above, L_2TAG_PACKET_4_0_2);\n+  __ jmp(L_2TAG_PACKET_6_0_2);\n+\n+  __ bind(L_2TAG_PACKET_3_0_2);\n+  __ xorpd(xmm1, xmm1);\n+  __ addsd(xmm1, xmm0);\n+  __ movdl(rdx, xmm1);\n+  __ psrlq(xmm1, 32);\n+  __ movdl(rcx, xmm1);\n+  __ orl(rdx, rcx);\n+  __ cmpl(rdx, 0);\n+  __ jcc(Assembler::equal, L_2TAG_PACKET_7_0_2);\n+  __ xorpd(xmm1, xmm1);\n+  __ movl(rax, 18416);\n+  __ pinsrw(xmm1, rax, 3);\n+  __ mulsd(xmm0, xmm1);\n+  __ xorpd(xmm2, xmm2);\n+  __ movl(rax, 16368);\n+  __ pinsrw(xmm2, rax, 3);\n+  __ movdqu(xmm1, xmm0);\n+  __ pextrw(rax, xmm0, 3);\n+  __ por(xmm0, xmm2);\n+  __ movl(rcx, 18416);\n+  __ psrlq(xmm0, 27);\n+  __ movdqu(xmm2, ExternalAddress(LOG10_E), r8 \/*rscratch*\/);    \/\/0x00000000UL, 0x3fdbc000UL, 0xbf2e4108UL, 0x3f5a7a6cUL\n+  __ psrld(xmm0, 2);\n+  __ rcpps(xmm0, xmm0);\n+  __ psllq(xmm1, 12);\n+  __ pshufd(xmm6, xmm5, 78);\n+  __ psrlq(xmm1, 12);\n+  __ jmp(L_2TAG_PACKET_1_0_2);\n+\n+  __ bind(L_2TAG_PACKET_2_0_2);\n+  __ movdl(rdx, xmm1);\n+  __ psrlq(xmm1, 32);\n+  __ movdl(rcx, xmm1);\n+  __ addl(rcx, rcx);\n+  __ cmpl(rcx, -2097152);\n+  __ jcc(Assembler::aboveEqual, L_2TAG_PACKET_5_0_2);\n+  __ orl(rdx, rcx);\n+  __ cmpl(rdx, 0);\n+  __ jcc(Assembler::equal, L_2TAG_PACKET_7_0_2);\n+\n+  __ bind(L_2TAG_PACKET_6_0_2);\n+  __ xorpd(xmm1, xmm1);\n+  __ xorpd(xmm0, xmm0);\n+  __ movl(rax, 32752);\n+  __ pinsrw(xmm1, rax, 3);\n+  __ mulsd(xmm0, xmm1);\n+  __ movl(Address(rsp, 16), 9);\n+  __ jmp(L_2TAG_PACKET_8_0_2);\n+\n+  __ bind(L_2TAG_PACKET_7_0_2);\n+  __ xorpd(xmm1, xmm1);\n+  __ xorpd(xmm0, xmm0);\n+  __ movl(rax, 49136);\n+  __ pinsrw(xmm0, rax, 3);\n+  __ divsd(xmm0, xmm1);\n+  __ movl(Address(rsp, 16), 8);\n+\n+  __ bind(L_2TAG_PACKET_8_0_2);\n+  __ movq(Address(rsp, 8), xmm0);\n+\n+  __ bind(B1_3);\n+  __ movq(xmm0, Address(rsp, 8));\n+\n+  __ bind(L_2TAG_PACKET_9_0_2);\n+\n+  __ bind(B1_5);\n+  __ addq(rsp, 24);\n+\n+  __ leave(); \/\/ required for proper stackwalking of RuntimeStub frame\n+  __ ret(0);\n+\n+  return start;\n+}\n+\n+#undef __\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_log.cpp","additions":709,"deletions":0,"binary":false,"changes":709,"status":"added"},{"patch":"@@ -0,0 +1,1865 @@\n+\/*\n+* Copyright (c) 2016, 2021, Intel Corporation. All rights reserved.\n+* Copyright (C) 2021 THL A29 Limited, a Tencent company. All rights reserved.\n+* Intel Math Library (LIBM) Source Code\n+*\n+* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+*\n+* This code is free software; you can redistribute it and\/or modify it\n+* under the terms of the GNU General Public License version 2 only, as\n+* published by the Free Software Foundation.\n+*\n+* This code is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+* FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+* version 2 for more details (a copy is included in the LICENSE file that\n+* accompanied this code).\n+*\n+* You should have received a copy of the GNU General Public License version\n+* 2 along with this work; if not, write to the Free Software Foundation,\n+* Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+*\n+* Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+* or visit www.oracle.com if you need additional information or have any\n+* questions.\n+*\n+*\/\n+\n+#include \"precompiled.hpp\"\n+#include \"macroAssembler_x86.hpp\"\n+#include \"stubGenerator_x86_64.hpp\"\n+\n+\/******************************************************************************\/\n+\/\/                     ALGORITHM DESCRIPTION  - POW()\n+\/\/                     ---------------------\n+\/\/\n+\/\/    Let x=2^k * mx, mx in [1,2)\n+\/\/\n+\/\/    log2(x) calculation:\n+\/\/\n+\/\/    Get B~1\/mx based on the output of rcpps instruction (B0)\n+\/\/    B = int((B0*LH*2^9+0.5))\/2^9\n+\/\/    LH is a short approximation for log2(e)\n+\/\/\n+\/\/    Reduced argument, scaled by LH:\n+\/\/                r=B*mx-LH (computed accurately in high and low parts)\n+\/\/\n+\/\/    log2(x) result:  k - log2(B) + p(r)\n+\/\/             p(r) is a degree 8 polynomial\n+\/\/             -log2(B) read from data table (high, low parts)\n+\/\/             log2(x) is formed from high and low parts\n+\/\/    For |x| in [1-1\/32, 1+1\/16), a slower but more accurate computation\n+\/\/    based om the same table design is performed.\n+\/\/\n+\/\/   Main path is taken if | floor(log2(|log2(|x|)|) + floor(log2|y|) | < 8,\n+\/\/   to filter out all potential OF\/UF cases.\n+\/\/   exp2(y*log2(x)) is computed using an 8-bit index table and a degree 5\n+\/\/   polynomial\n+\/\/\n+\/\/ Special cases:\n+\/\/  pow(-0,y) = -INF and raises the divide-by-zero exception for y an odd\n+\/\/  integer < 0.\n+\/\/  pow(-0,y) = +INF and raises the divide-by-zero exception for y < 0 and\n+\/\/  not an odd integer.\n+\/\/  pow(-0,y) = -0 for y an odd integer > 0.\n+\/\/  pow(-0,y) = +0 for y > 0 and not an odd integer.\n+\/\/  pow(-1,-INF) = NaN.\n+\/\/  pow(+1,y) = NaN for any y, even a NaN.\n+\/\/  pow(x,-0) = 1 for any x, even a NaN.\n+\/\/  pow(x,y) = a NaN and raises the invalid exception for finite x < 0 and\n+\/\/  finite non-integer y.\n+\/\/  pow(x,-INF) = +INF for |x|<1.\n+\/\/  pow(x,-INF) = +0 for |x|>1.\n+\/\/  pow(x,+INF) = +0 for |x|<1.\n+\/\/  pow(x,+INF) = +INF for |x|>1.\n+\/\/  pow(-INF,y) = -0 for y an odd integer < 0.\n+\/\/  pow(-INF,y) = +0 for y < 0 and not an odd integer.\n+\/\/  pow(-INF,y) = -INF for y an odd integer > 0.\n+\/\/  pow(-INF,y) = +INF for y > 0 and not an odd integer.\n+\/\/  pow(+INF,y) = +0 for y <0.\n+\/\/  pow(+INF,y) = +INF for y >0.\n+\/\/\n+\/******************************************************************************\/\n+\n+ATTRIBUTE_ALIGNED(16) juint _HIGHSIGMASK[] = {\n+    0x00000000UL, 0xfffff800UL, 0x00000000UL, 0xfffff800UL\n+};\n+\n+ATTRIBUTE_ALIGNED(16) juint _LOG2_E[] = {\n+    0x00000000UL, 0x3ff72000UL, 0x161bb241UL, 0xbf5dabe1UL\n+};\n+\n+ATTRIBUTE_ALIGNED(16) juint _HIGHMASK_Y[] = {\n+    0x00000000UL, 0xfffffff8UL, 0x00000000UL, 0xffffffffUL\n+};\n+\n+ATTRIBUTE_ALIGNED(16) juint _T_exp[] = {\n+    0x00000000UL, 0x3ff00000UL, 0x00000000UL, 0x3b700000UL, 0xfa5abcbfUL,\n+    0x3ff00b1aUL, 0xa7609f71UL, 0xbc84f6b2UL, 0xa9fb3335UL, 0x3ff0163dUL,\n+    0x9ab8cdb7UL, 0x3c9b6129UL, 0x143b0281UL, 0x3ff02168UL, 0x0fc54eb6UL,\n+    0xbc82bf31UL, 0x3e778061UL, 0x3ff02c9aUL, 0x535b085dUL, 0xbc719083UL,\n+    0x2e11bbccUL, 0x3ff037d4UL, 0xeeade11aUL, 0x3c656811UL, 0xe86e7f85UL,\n+    0x3ff04315UL, 0x1977c96eUL, 0xbc90a31cUL, 0x72f654b1UL, 0x3ff04e5fUL,\n+    0x3aa0d08cUL, 0x3c84c379UL, 0xd3158574UL, 0x3ff059b0UL, 0xa475b465UL,\n+    0x3c8d73e2UL, 0x0e3c1f89UL, 0x3ff0650aUL, 0x5799c397UL, 0xbc95cb7bUL,\n+    0x29ddf6deUL, 0x3ff0706bUL, 0xe2b13c27UL, 0xbc8c91dfUL, 0x2b72a836UL,\n+    0x3ff07bd4UL, 0x54458700UL, 0x3c832334UL, 0x18759bc8UL, 0x3ff08745UL,\n+    0x4bb284ffUL, 0x3c6186beUL, 0xf66607e0UL, 0x3ff092bdUL, 0x800a3fd1UL,\n+    0xbc968063UL, 0xcac6f383UL, 0x3ff09e3eUL, 0x18316136UL, 0x3c914878UL,\n+    0x9b1f3919UL, 0x3ff0a9c7UL, 0x873d1d38UL, 0x3c85d16cUL, 0x6cf9890fUL,\n+    0x3ff0b558UL, 0x4adc610bUL, 0x3c98a62eUL, 0x45e46c85UL, 0x3ff0c0f1UL,\n+    0x06d21cefUL, 0x3c94f989UL, 0x2b7247f7UL, 0x3ff0cc92UL, 0x16e24f71UL,\n+    0x3c901edcUL, 0x23395decUL, 0x3ff0d83bUL, 0xe43f316aUL, 0xbc9bc14dUL,\n+    0x32d3d1a2UL, 0x3ff0e3ecUL, 0x27c57b52UL, 0x3c403a17UL, 0x5fdfa9c5UL,\n+    0x3ff0efa5UL, 0xbc54021bUL, 0xbc949db9UL, 0xaffed31bUL, 0x3ff0fb66UL,\n+    0xc44ebd7bUL, 0xbc6b9bedUL, 0x28d7233eUL, 0x3ff10730UL, 0x1692fdd5UL,\n+    0x3c8d46ebUL, 0xd0125b51UL, 0x3ff11301UL, 0x39449b3aUL, 0xbc96c510UL,\n+    0xab5e2ab6UL, 0x3ff11edbUL, 0xf703fb72UL, 0xbc9ca454UL, 0xc06c31ccUL,\n+    0x3ff12abdUL, 0xb36ca5c7UL, 0xbc51b514UL, 0x14f204abUL, 0x3ff136a8UL,\n+    0xba48dcf0UL, 0xbc67108fUL, 0xaea92de0UL, 0x3ff1429aUL, 0x9af1369eUL,\n+    0xbc932fbfUL, 0x934f312eUL, 0x3ff14e95UL, 0x39bf44abUL, 0xbc8b91e8UL,\n+    0xc8a58e51UL, 0x3ff15a98UL, 0xb9eeab0aUL, 0x3c82406aUL, 0x5471c3c2UL,\n+    0x3ff166a4UL, 0x82ea1a32UL, 0x3c58f23bUL, 0x3c7d517bUL, 0x3ff172b8UL,\n+    0xb9d78a76UL, 0xbc819041UL, 0x8695bbc0UL, 0x3ff17ed4UL, 0xe2ac5a64UL,\n+    0x3c709e3fUL, 0x388c8deaUL, 0x3ff18af9UL, 0xd1970f6cUL, 0xbc911023UL,\n+    0x58375d2fUL, 0x3ff19726UL, 0x85f17e08UL, 0x3c94aaddUL, 0xeb6fcb75UL,\n+    0x3ff1a35bUL, 0x7b4968e4UL, 0x3c8e5b4cUL, 0xf8138a1cUL, 0x3ff1af99UL,\n+    0xa4b69280UL, 0x3c97bf85UL, 0x84045cd4UL, 0x3ff1bbe0UL, 0x352ef607UL,\n+    0xbc995386UL, 0x95281c6bUL, 0x3ff1c82fUL, 0x8010f8c9UL, 0x3c900977UL,\n+    0x3168b9aaUL, 0x3ff1d487UL, 0x00a2643cUL, 0x3c9e016eUL, 0x5eb44027UL,\n+    0x3ff1e0e7UL, 0x088cb6deUL, 0xbc96fdd8UL, 0x22fcd91dUL, 0x3ff1ed50UL,\n+    0x027bb78cUL, 0xbc91df98UL, 0x8438ce4dUL, 0x3ff1f9c1UL, 0xa097af5cUL,\n+    0xbc9bf524UL, 0x88628cd6UL, 0x3ff2063bUL, 0x814a8495UL, 0x3c8dc775UL,\n+    0x3578a819UL, 0x3ff212beUL, 0x2cfcaac9UL, 0x3c93592dUL, 0x917ddc96UL,\n+    0x3ff21f49UL, 0x9494a5eeUL, 0x3c82a97eUL, 0xa27912d1UL, 0x3ff22bddUL,\n+    0x5577d69fUL, 0x3c8d34fbUL, 0x6e756238UL, 0x3ff2387aUL, 0xb6c70573UL,\n+    0x3c99b07eUL, 0xfb82140aUL, 0x3ff2451fUL, 0x911ca996UL, 0x3c8acfccUL,\n+    0x4fb2a63fUL, 0x3ff251ceUL, 0xbef4f4a4UL, 0x3c8ac155UL, 0x711ece75UL,\n+    0x3ff25e85UL, 0x4ac31b2cUL, 0x3c93e1a2UL, 0x65e27cddUL, 0x3ff26b45UL,\n+    0x9940e9d9UL, 0x3c82bd33UL, 0x341ddf29UL, 0x3ff2780eUL, 0x05f9e76cUL,\n+    0x3c9e067cUL, 0xe1f56381UL, 0x3ff284dfUL, 0x8c3f0d7eUL, 0xbc9a4c3aUL,\n+    0x7591bb70UL, 0x3ff291baUL, 0x28401cbdUL, 0xbc82cc72UL, 0xf51fdee1UL,\n+    0x3ff29e9dUL, 0xafad1255UL, 0x3c8612e8UL, 0x66d10f13UL, 0x3ff2ab8aUL,\n+    0x191690a7UL, 0xbc995743UL, 0xd0dad990UL, 0x3ff2b87fUL, 0xd6381aa4UL,\n+    0xbc410adcUL, 0x39771b2fUL, 0x3ff2c57eUL, 0xa6eb5124UL, 0xbc950145UL,\n+    0xa6e4030bUL, 0x3ff2d285UL, 0x54db41d5UL, 0x3c900247UL, 0x1f641589UL,\n+    0x3ff2df96UL, 0xfbbce198UL, 0x3c9d16cfUL, 0xa93e2f56UL, 0x3ff2ecafUL,\n+    0x45d52383UL, 0x3c71ca0fUL, 0x4abd886bUL, 0x3ff2f9d2UL, 0x532bda93UL,\n+    0xbc653c55UL, 0x0a31b715UL, 0x3ff306feUL, 0xd23182e4UL, 0x3c86f46aUL,\n+    0xedeeb2fdUL, 0x3ff31432UL, 0xf3f3fcd1UL, 0x3c8959a3UL, 0xfc4cd831UL,\n+    0x3ff32170UL, 0x8e18047cUL, 0x3c8a9ce7UL, 0x3ba8ea32UL, 0x3ff32eb8UL,\n+    0x3cb4f318UL, 0xbc9c45e8UL, 0xb26416ffUL, 0x3ff33c08UL, 0x843659a6UL,\n+    0x3c932721UL, 0x66e3fa2dUL, 0x3ff34962UL, 0x930881a4UL, 0xbc835a75UL,\n+    0x5f929ff1UL, 0x3ff356c5UL, 0x5c4e4628UL, 0xbc8b5ceeUL, 0xa2de883bUL,\n+    0x3ff36431UL, 0xa06cb85eUL, 0xbc8c3144UL, 0x373aa9cbUL, 0x3ff371a7UL,\n+    0xbf42eae2UL, 0xbc963aeaUL, 0x231e754aUL, 0x3ff37f26UL, 0x9eceb23cUL,\n+    0xbc99f5caUL, 0x6d05d866UL, 0x3ff38caeUL, 0x3c9904bdUL, 0xbc9e958dUL,\n+    0x1b7140efUL, 0x3ff39a40UL, 0xfc8e2934UL, 0xbc99a9a5UL, 0x34e59ff7UL,\n+    0x3ff3a7dbUL, 0xd661f5e3UL, 0xbc75e436UL, 0xbfec6cf4UL, 0x3ff3b57fUL,\n+    0xe26fff18UL, 0x3c954c66UL, 0xc313a8e5UL, 0x3ff3c32dUL, 0x375d29c3UL,\n+    0xbc9efff8UL, 0x44ede173UL, 0x3ff3d0e5UL, 0x8c284c71UL, 0x3c7fe8d0UL,\n+    0x4c123422UL, 0x3ff3dea6UL, 0x11f09ebcUL, 0x3c8ada09UL, 0xdf1c5175UL,\n+    0x3ff3ec70UL, 0x7b8c9bcaUL, 0xbc8af663UL, 0x04ac801cUL, 0x3ff3fa45UL,\n+    0xf956f9f3UL, 0xbc97d023UL, 0xc367a024UL, 0x3ff40822UL, 0xb6f4d048UL,\n+    0x3c8bddf8UL, 0x21f72e2aUL, 0x3ff4160aUL, 0x1c309278UL, 0xbc5ef369UL,\n+    0x2709468aUL, 0x3ff423fbUL, 0xc0b314ddUL, 0xbc98462dUL, 0xd950a897UL,\n+    0x3ff431f5UL, 0xe35f7999UL, 0xbc81c7ddUL, 0x3f84b9d4UL, 0x3ff43ffaUL,\n+    0x9704c003UL, 0x3c8880beUL, 0x6061892dUL, 0x3ff44e08UL, 0x04ef80d0UL,\n+    0x3c489b7aUL, 0x42a7d232UL, 0x3ff45c20UL, 0x82fb1f8eUL, 0xbc686419UL,\n+    0xed1d0057UL, 0x3ff46a41UL, 0xd1648a76UL, 0x3c9c944bUL, 0x668b3237UL,\n+    0x3ff4786dUL, 0xed445733UL, 0xbc9c20f0UL, 0xb5c13cd0UL, 0x3ff486a2UL,\n+    0xb69062f0UL, 0x3c73c1a3UL, 0xe192aed2UL, 0x3ff494e1UL, 0x5e499ea0UL,\n+    0xbc83b289UL, 0xf0d7d3deUL, 0x3ff4a32aUL, 0xf3d1be56UL, 0x3c99cb62UL,\n+    0xea6db7d7UL, 0x3ff4b17dUL, 0x7f2897f0UL, 0xbc8125b8UL, 0xd5362a27UL,\n+    0x3ff4bfdaUL, 0xafec42e2UL, 0x3c7d4397UL, 0xb817c114UL, 0x3ff4ce41UL,\n+    0x690abd5dUL, 0x3c905e29UL, 0x99fddd0dUL, 0x3ff4dcb2UL, 0xbc6a7833UL,\n+    0x3c98ecdbUL, 0x81d8abffUL, 0x3ff4eb2dUL, 0x2e5d7a52UL, 0xbc95257dUL,\n+    0x769d2ca7UL, 0x3ff4f9b2UL, 0xd25957e3UL, 0xbc94b309UL, 0x7f4531eeUL,\n+    0x3ff50841UL, 0x49b7465fUL, 0x3c7a249bUL, 0xa2cf6642UL, 0x3ff516daUL,\n+    0x69bd93efUL, 0xbc8f7685UL, 0xe83f4eefUL, 0x3ff5257dUL, 0x43efef71UL,\n+    0xbc7c998dUL, 0x569d4f82UL, 0x3ff5342bUL, 0x1db13cadUL, 0xbc807abeUL,\n+    0xf4f6ad27UL, 0x3ff542e2UL, 0x192d5f7eUL, 0x3c87926dUL, 0xca5d920fUL,\n+    0x3ff551a4UL, 0xefede59bUL, 0xbc8d689cUL, 0xdde910d2UL, 0x3ff56070UL,\n+    0x168eebf0UL, 0xbc90fb6eUL, 0x36b527daUL, 0x3ff56f47UL, 0x011d93adUL,\n+    0x3c99bb2cUL, 0xdbe2c4cfUL, 0x3ff57e27UL, 0x8a57b9c4UL, 0xbc90b98cUL,\n+    0xd497c7fdUL, 0x3ff58d12UL, 0x5b9a1de8UL, 0x3c8295e1UL, 0x27ff07ccUL,\n+    0x3ff59c08UL, 0xe467e60fUL, 0xbc97e2ceUL, 0xdd485429UL, 0x3ff5ab07UL,\n+    0x054647adUL, 0x3c96324cUL, 0xfba87a03UL, 0x3ff5ba11UL, 0x4c233e1aUL,\n+    0xbc9b77a1UL, 0x8a5946b7UL, 0x3ff5c926UL, 0x816986a2UL, 0x3c3c4b1bUL,\n+    0x90998b93UL, 0x3ff5d845UL, 0xa8b45643UL, 0xbc9cd6a7UL, 0x15ad2148UL,\n+    0x3ff5e76fUL, 0x3080e65eUL, 0x3c9ba6f9UL, 0x20dceb71UL, 0x3ff5f6a3UL,\n+    0xe3cdcf92UL, 0xbc89eaddUL, 0xb976dc09UL, 0x3ff605e1UL, 0x9b56de47UL,\n+    0xbc93e242UL, 0xe6cdf6f4UL, 0x3ff6152aUL, 0x4ab84c27UL, 0x3c9e4b3eUL,\n+    0xb03a5585UL, 0x3ff6247eUL, 0x7e40b497UL, 0xbc9383c1UL, 0x1d1929fdUL,\n+    0x3ff633ddUL, 0xbeb964e5UL, 0x3c984710UL, 0x34ccc320UL, 0x3ff64346UL,\n+    0x759d8933UL, 0xbc8c483cUL, 0xfebc8fb7UL, 0x3ff652b9UL, 0xc9a73e09UL,\n+    0xbc9ae3d5UL, 0x82552225UL, 0x3ff66238UL, 0x87591c34UL, 0xbc9bb609UL,\n+    0xc70833f6UL, 0x3ff671c1UL, 0x586c6134UL, 0xbc8e8732UL, 0xd44ca973UL,\n+    0x3ff68155UL, 0x44f73e65UL, 0x3c6038aeUL, 0xb19e9538UL, 0x3ff690f4UL,\n+    0x9aeb445dUL, 0x3c8804bdUL, 0x667f3bcdUL, 0x3ff6a09eUL, 0x13b26456UL,\n+    0xbc9bdd34UL, 0xfa75173eUL, 0x3ff6b052UL, 0x2c9a9d0eUL, 0x3c7a38f5UL,\n+    0x750bdabfUL, 0x3ff6c012UL, 0x67ff0b0dUL, 0xbc728956UL, 0xddd47645UL,\n+    0x3ff6cfdcUL, 0xb6f17309UL, 0x3c9c7aa9UL, 0x3c651a2fUL, 0x3ff6dfb2UL,\n+    0x683c88abUL, 0xbc6bbe3aUL, 0x98593ae5UL, 0x3ff6ef92UL, 0x9e1ac8b2UL,\n+    0xbc90b974UL, 0xf9519484UL, 0x3ff6ff7dUL, 0x25860ef6UL, 0xbc883c0fUL,\n+    0x66f42e87UL, 0x3ff70f74UL, 0xd45aa65fUL, 0x3c59d644UL, 0xe8ec5f74UL,\n+    0x3ff71f75UL, 0x86887a99UL, 0xbc816e47UL, 0x86ead08aUL, 0x3ff72f82UL,\n+    0x2cd62c72UL, 0xbc920aa0UL, 0x48a58174UL, 0x3ff73f9aUL, 0x6c65d53cUL,\n+    0xbc90a8d9UL, 0x35d7cbfdUL, 0x3ff74fbdUL, 0x618a6e1cUL, 0x3c9047fdUL,\n+    0x564267c9UL, 0x3ff75febUL, 0x57316dd3UL, 0xbc902459UL, 0xb1ab6e09UL,\n+    0x3ff77024UL, 0x169147f8UL, 0x3c9b7877UL, 0x4fde5d3fUL, 0x3ff78069UL,\n+    0x0a02162dUL, 0x3c9866b8UL, 0x38ac1cf6UL, 0x3ff790b9UL, 0x62aadd3eUL,\n+    0x3c9349a8UL, 0x73eb0187UL, 0x3ff7a114UL, 0xee04992fUL, 0xbc841577UL,\n+    0x0976cfdbUL, 0x3ff7b17bUL, 0x8468dc88UL, 0xbc9bebb5UL, 0x0130c132UL,\n+    0x3ff7c1edUL, 0xd1164dd6UL, 0x3c9f124cUL, 0x62ff86f0UL, 0x3ff7d26aUL,\n+    0xfb72b8b4UL, 0x3c91bddbUL, 0x36cf4e62UL, 0x3ff7e2f3UL, 0xba15797eUL,\n+    0x3c705d02UL, 0x8491c491UL, 0x3ff7f387UL, 0xcf9311aeUL, 0xbc807f11UL,\n+    0x543e1a12UL, 0x3ff80427UL, 0x626d972bUL, 0xbc927c86UL, 0xadd106d9UL,\n+    0x3ff814d2UL, 0x0d151d4dUL, 0x3c946437UL, 0x994cce13UL, 0x3ff82589UL,\n+    0xd41532d8UL, 0xbc9d4c1dUL, 0x1eb941f7UL, 0x3ff8364cUL, 0x31df2bd5UL,\n+    0x3c999b9aUL, 0x4623c7adUL, 0x3ff8471aUL, 0xa341cdfbUL, 0xbc88d684UL,\n+    0x179f5b21UL, 0x3ff857f4UL, 0xf8b216d0UL, 0xbc5ba748UL, 0x9b4492edUL,\n+    0x3ff868d9UL, 0x9bd4f6baUL, 0xbc9fc6f8UL, 0xd931a436UL, 0x3ff879caUL,\n+    0xd2db47bdUL, 0x3c85d2d7UL, 0xd98a6699UL, 0x3ff88ac7UL, 0xf37cb53aUL,\n+    0x3c9994c2UL, 0xa478580fUL, 0x3ff89bd0UL, 0x4475202aUL, 0x3c9d5395UL,\n+    0x422aa0dbUL, 0x3ff8ace5UL, 0x56864b27UL, 0x3c96e9f1UL, 0xbad61778UL,\n+    0x3ff8be05UL, 0xfc43446eUL, 0x3c9ecb5eUL, 0x16b5448cUL, 0x3ff8cf32UL,\n+    0x32e9e3aaUL, 0xbc70d55eUL, 0x5e0866d9UL, 0x3ff8e06aUL, 0x6fc9b2e6UL,\n+    0xbc97114aUL, 0x99157736UL, 0x3ff8f1aeUL, 0xa2e3976cUL, 0x3c85cc13UL,\n+    0xd0282c8aUL, 0x3ff902feUL, 0x85fe3fd2UL, 0x3c9592caUL, 0x0b91ffc6UL,\n+    0x3ff9145bUL, 0x2e582524UL, 0xbc9dd679UL, 0x53aa2fe2UL, 0x3ff925c3UL,\n+    0xa639db7fUL, 0xbc83455fUL, 0xb0cdc5e5UL, 0x3ff93737UL, 0x81b57ebcUL,\n+    0xbc675fc7UL, 0x2b5f98e5UL, 0x3ff948b8UL, 0x797d2d99UL, 0xbc8dc3d6UL,\n+    0xcbc8520fUL, 0x3ff95a44UL, 0x96a5f039UL, 0xbc764b7cUL, 0x9a7670b3UL,\n+    0x3ff96bddUL, 0x7f19c896UL, 0xbc5ba596UL, 0x9fde4e50UL, 0x3ff97d82UL,\n+    0x7c1b85d1UL, 0xbc9d185bUL, 0xe47a22a2UL, 0x3ff98f33UL, 0xa24c78ecUL,\n+    0x3c7cabdaUL, 0x70ca07baUL, 0x3ff9a0f1UL, 0x91cee632UL, 0xbc9173bdUL,\n+    0x4d53fe0dUL, 0x3ff9b2bbUL, 0x4df6d518UL, 0xbc9dd84eUL, 0x82a3f090UL,\n+    0x3ff9c491UL, 0xb071f2beUL, 0x3c7c7c46UL, 0x194bb8d5UL, 0x3ff9d674UL,\n+    0xa3dd8233UL, 0xbc9516beUL, 0x19e32323UL, 0x3ff9e863UL, 0x78e64c6eUL,\n+    0x3c7824caUL, 0x8d07f29eUL, 0x3ff9fa5eUL, 0xaaf1faceUL, 0xbc84a9ceUL,\n+    0x7b5de565UL, 0x3ffa0c66UL, 0x5d1cd533UL, 0xbc935949UL, 0xed8eb8bbUL,\n+    0x3ffa1e7aUL, 0xee8be70eUL, 0x3c9c6618UL, 0xec4a2d33UL, 0x3ffa309bUL,\n+    0x7ddc36abUL, 0x3c96305cUL, 0x80460ad8UL, 0x3ffa42c9UL, 0x589fb120UL,\n+    0xbc9aa780UL, 0xb23e255dUL, 0x3ffa5503UL, 0xdb8d41e1UL, 0xbc9d2f6eUL,\n+    0x8af46052UL, 0x3ffa674aUL, 0x30670366UL, 0x3c650f56UL, 0x1330b358UL,\n+    0x3ffa799eUL, 0xcac563c7UL, 0x3c9bcb7eUL, 0x53c12e59UL, 0x3ffa8bfeUL,\n+    0xb2ba15a9UL, 0xbc94f867UL, 0x5579fdbfUL, 0x3ffa9e6bUL, 0x0ef7fd31UL,\n+    0x3c90fac9UL, 0x21356ebaUL, 0x3ffab0e5UL, 0xdae94545UL, 0x3c889c31UL,\n+    0xbfd3f37aUL, 0x3ffac36bUL, 0xcae76cd0UL, 0xbc8f9234UL, 0x3a3c2774UL,\n+    0x3ffad5ffUL, 0xb6b1b8e5UL, 0x3c97ef3bUL, 0x995ad3adUL, 0x3ffae89fUL,\n+    0x345dcc81UL, 0x3c97a1cdUL, 0xe622f2ffUL, 0x3ffafb4cUL, 0x0f315ecdUL,\n+    0xbc94b2fcUL, 0x298db666UL, 0x3ffb0e07UL, 0x4c80e425UL, 0xbc9bdef5UL,\n+    0x6c9a8952UL, 0x3ffb20ceUL, 0x4a0756ccUL, 0x3c94dd02UL, 0xb84f15fbUL,\n+    0x3ffb33a2UL, 0x3084d708UL, 0xbc62805eUL, 0x15b749b1UL, 0x3ffb4684UL,\n+    0xe9df7c90UL, 0xbc7f763dUL, 0x8de5593aUL, 0x3ffb5972UL, 0xbbba6de3UL,\n+    0xbc9c71dfUL, 0x29f1c52aUL, 0x3ffb6c6eUL, 0x52883f6eUL, 0x3c92a8f3UL,\n+    0xf2fb5e47UL, 0x3ffb7f76UL, 0x7e54ac3bUL, 0xbc75584fUL, 0xf22749e4UL,\n+    0x3ffb928cUL, 0x54cb65c6UL, 0xbc9b7216UL, 0x30a1064aUL, 0x3ffba5b0UL,\n+    0x0e54292eUL, 0xbc9efcd3UL, 0xb79a6f1fUL, 0x3ffbb8e0UL, 0xc9696205UL,\n+    0xbc3f52d1UL, 0x904bc1d2UL, 0x3ffbcc1eUL, 0x7a2d9e84UL, 0x3c823dd0UL,\n+    0xc3f3a207UL, 0x3ffbdf69UL, 0x60ea5b53UL, 0xbc3c2623UL, 0x5bd71e09UL,\n+    0x3ffbf2c2UL, 0x3f6b9c73UL, 0xbc9efdcaUL, 0x6141b33dUL, 0x3ffc0628UL,\n+    0xa1fbca34UL, 0xbc8d8a5aUL, 0xdd85529cUL, 0x3ffc199bUL, 0x895048ddUL,\n+    0x3c811065UL, 0xd9fa652cUL, 0x3ffc2d1cUL, 0x17c8a5d7UL, 0xbc96e516UL,\n+    0x5fffd07aUL, 0x3ffc40abUL, 0xe083c60aUL, 0x3c9b4537UL, 0x78fafb22UL,\n+    0x3ffc5447UL, 0x2493b5afUL, 0x3c912f07UL, 0x2e57d14bUL, 0x3ffc67f1UL,\n+    0xff483cadUL, 0x3c92884dUL, 0x8988c933UL, 0x3ffc7ba8UL, 0xbe255559UL,\n+    0xbc8e76bbUL, 0x9406e7b5UL, 0x3ffc8f6dUL, 0x48805c44UL, 0x3c71acbcUL,\n+    0x5751c4dbUL, 0x3ffca340UL, 0xd10d08f5UL, 0xbc87f2beUL, 0xdcef9069UL,\n+    0x3ffcb720UL, 0xd1e949dbUL, 0x3c7503cbUL, 0x2e6d1675UL, 0x3ffccb0fUL,\n+    0x86009092UL, 0xbc7d220fUL, 0x555dc3faUL, 0x3ffcdf0bUL, 0x53829d72UL,\n+    0xbc8dd83bUL, 0x5b5bab74UL, 0x3ffcf315UL, 0xb86dff57UL, 0xbc9a08e9UL,\n+    0x4a07897cUL, 0x3ffd072dUL, 0x43797a9cUL, 0xbc9cbc37UL, 0x2b08c968UL,\n+    0x3ffd1b53UL, 0x219a36eeUL, 0x3c955636UL, 0x080d89f2UL, 0x3ffd2f87UL,\n+    0x719d8578UL, 0xbc9d487bUL, 0xeacaa1d6UL, 0x3ffd43c8UL, 0xbf5a1614UL,\n+    0x3c93db53UL, 0xdcfba487UL, 0x3ffd5818UL, 0xd75b3707UL, 0x3c82ed02UL,\n+    0xe862e6d3UL, 0x3ffd6c76UL, 0x4a8165a0UL, 0x3c5fe87aUL, 0x16c98398UL,\n+    0x3ffd80e3UL, 0x8beddfe8UL, 0xbc911ec1UL, 0x71ff6075UL, 0x3ffd955dUL,\n+    0xbb9af6beUL, 0x3c9a052dUL, 0x03db3285UL, 0x3ffda9e6UL, 0x696db532UL,\n+    0x3c9c2300UL, 0xd63a8315UL, 0x3ffdbe7cUL, 0x926b8be4UL, 0xbc9b76f1UL,\n+    0xf301b460UL, 0x3ffdd321UL, 0x78f018c3UL, 0x3c92da57UL, 0x641c0658UL,\n+    0x3ffde7d5UL, 0x8e79ba8fUL, 0xbc9ca552UL, 0x337b9b5fUL, 0x3ffdfc97UL,\n+    0x4f184b5cUL, 0xbc91a5cdUL, 0x6b197d17UL, 0x3ffe1167UL, 0xbd5c7f44UL,\n+    0xbc72b529UL, 0x14f5a129UL, 0x3ffe2646UL, 0x817a1496UL, 0xbc97b627UL,\n+    0x3b16ee12UL, 0x3ffe3b33UL, 0x31fdc68bUL, 0xbc99f4a4UL, 0xe78b3ff6UL,\n+    0x3ffe502eUL, 0x80a9cc8fUL, 0x3c839e89UL, 0x24676d76UL, 0x3ffe6539UL,\n+    0x7522b735UL, 0xbc863ff8UL, 0xfbc74c83UL, 0x3ffe7a51UL, 0xca0c8de2UL,\n+    0x3c92d522UL, 0x77cdb740UL, 0x3ffe8f79UL, 0x80b054b1UL, 0xbc910894UL,\n+    0xa2a490daUL, 0x3ffea4afUL, 0x179c2893UL, 0xbc9e9c23UL, 0x867cca6eUL,\n+    0x3ffeb9f4UL, 0x2293e4f2UL, 0x3c94832fUL, 0x2d8e67f1UL, 0x3ffecf48UL,\n+    0xb411ad8cUL, 0xbc9c93f3UL, 0xa2188510UL, 0x3ffee4aaUL, 0xa487568dUL,\n+    0x3c91c68dUL, 0xee615a27UL, 0x3ffefa1bUL, 0x86a4b6b0UL, 0x3c9dc7f4UL,\n+    0x1cb6412aUL, 0x3fff0f9cUL, 0x65181d45UL, 0xbc932200UL, 0x376bba97UL,\n+    0x3fff252bUL, 0xbf0d8e43UL, 0x3c93a1a5UL, 0x48dd7274UL, 0x3fff3ac9UL,\n+    0x3ed837deUL, 0xbc795a5aUL, 0x5b6e4540UL, 0x3fff5076UL, 0x2dd8a18bUL,\n+    0x3c99d3e1UL, 0x798844f8UL, 0x3fff6632UL, 0x3539343eUL, 0x3c9fa37bUL,\n+    0xad9cbe14UL, 0x3fff7bfdUL, 0xd006350aUL, 0xbc9dbb12UL, 0x02243c89UL,\n+    0x3fff91d8UL, 0xa779f689UL, 0xbc612ea8UL, 0x819e90d8UL, 0x3fffa7c1UL,\n+    0xf3a5931eUL, 0x3c874853UL, 0x3692d514UL, 0x3fffbdbaUL, 0x15098eb6UL,\n+    0xbc796773UL, 0x2b8f71f1UL, 0x3fffd3c2UL, 0x966579e7UL, 0x3c62eb74UL,\n+    0x6b2a23d9UL, 0x3fffe9d9UL, 0x7442fde3UL, 0x3c74a603UL\n+};\n+\n+ATTRIBUTE_ALIGNED(16) juint _e_coeff[] = {\n+    0xe78a6731UL, 0x3f55d87fUL, 0xd704a0c0UL, 0x3fac6b08UL, 0x6fba4e77UL,\n+    0x3f83b2abUL, 0xff82c58fUL, 0x3fcebfbdUL, 0xfefa39efUL, 0x3fe62e42UL,\n+    0x00000000UL, 0x00000000UL\n+};\n+\n+ATTRIBUTE_ALIGNED(16) juint _coeff_h[] = {\n+    0x00000000UL, 0xbfd61a00UL, 0x00000000UL, 0xbf5dabe1UL\n+};\n+\n+ATTRIBUTE_ALIGNED(16) juint _HIGHMASK_LOG_X[] = {\n+    0xf8000000UL, 0xffffffffUL, 0x00000000UL, 0xfffff800UL\n+};\n+\n+ATTRIBUTE_ALIGNED(8) juint _HALFMASK[] = {\n+    0xf8000000UL, 0xffffffffUL, 0xf8000000UL, 0xffffffffUL\n+};\n+\n+ATTRIBUTE_ALIGNED(16) juint _coeff_pow[] = {\n+    0x6dc96112UL, 0xbf836578UL, 0xee241472UL, 0xbf9b0301UL, 0x9f95985aUL,\n+    0xbfb528dbUL, 0xb3841d2aUL, 0xbfd619b6UL, 0x518775e3UL, 0x3f9004f2UL,\n+    0xac8349bbUL, 0x3fa76c9bUL, 0x486ececcUL, 0x3fc4635eUL, 0x161bb241UL,\n+    0xbf5dabe1UL, 0x9f95985aUL, 0xbfb528dbUL, 0xf8b5787dUL, 0x3ef2531eUL,\n+    0x486ececbUL, 0x3fc4635eUL, 0x412055ccUL, 0xbdd61bb2UL\n+};\n+\n+ATTRIBUTE_ALIGNED(16) juint _L_tbl_pow[] = {\n+    0x00000000UL, 0x3ff00000UL, 0x00000000UL, 0x00000000UL, 0x20000000UL,\n+    0x3feff00aUL, 0x96621f95UL, 0x3e5b1856UL, 0xe0000000UL, 0x3fefe019UL,\n+    0xe5916f9eUL, 0xbe325278UL, 0x00000000UL, 0x3fefd02fUL, 0x859a1062UL,\n+    0x3e595fb7UL, 0xc0000000UL, 0x3fefc049UL, 0xb245f18fUL, 0xbe529c38UL,\n+    0xe0000000UL, 0x3fefb069UL, 0xad2880a7UL, 0xbe501230UL, 0x60000000UL,\n+    0x3fefa08fUL, 0xc8e72420UL, 0x3e597bd1UL, 0x80000000UL, 0x3fef90baUL,\n+    0xc30c4500UL, 0xbe5d6c75UL, 0xe0000000UL, 0x3fef80eaUL, 0x02c63f43UL,\n+    0x3e2e1318UL, 0xc0000000UL, 0x3fef7120UL, 0xb3d4ccccUL, 0xbe44c52aUL,\n+    0x00000000UL, 0x3fef615cUL, 0xdbd91397UL, 0xbe4e7d6cUL, 0xa0000000UL,\n+    0x3fef519cUL, 0x65c5cd68UL, 0xbe522dc8UL, 0xa0000000UL, 0x3fef41e2UL,\n+    0x46d1306cUL, 0xbe5a840eUL, 0xe0000000UL, 0x3fef322dUL, 0xd2980e94UL,\n+    0x3e5071afUL, 0xa0000000UL, 0x3fef227eUL, 0x773abadeUL, 0xbe5891e5UL,\n+    0xa0000000UL, 0x3fef12d4UL, 0xdc6bf46bUL, 0xbe5cccbeUL, 0xe0000000UL,\n+    0x3fef032fUL, 0xbc7247faUL, 0xbe2bab83UL, 0x80000000UL, 0x3feef390UL,\n+    0xbcaa1e46UL, 0xbe53bb3bUL, 0x60000000UL, 0x3feee3f6UL, 0x5f6c682dUL,\n+    0xbe54c619UL, 0x80000000UL, 0x3feed461UL, 0x5141e368UL, 0xbe4b6d86UL,\n+    0xe0000000UL, 0x3feec4d1UL, 0xec678f76UL, 0xbe369af6UL, 0x80000000UL,\n+    0x3feeb547UL, 0x41301f55UL, 0xbe2d4312UL, 0x60000000UL, 0x3feea5c2UL,\n+    0x676da6bdUL, 0xbe4d8dd0UL, 0x60000000UL, 0x3fee9642UL, 0x57a891c4UL,\n+    0x3e51f991UL, 0xa0000000UL, 0x3fee86c7UL, 0xe4eb491eUL, 0x3e579bf9UL,\n+    0x20000000UL, 0x3fee7752UL, 0xfddc4a2cUL, 0xbe3356e6UL, 0xc0000000UL,\n+    0x3fee67e1UL, 0xd75b5bf1UL, 0xbe449531UL, 0x80000000UL, 0x3fee5876UL,\n+    0xbd423b8eUL, 0x3df54fe4UL, 0x60000000UL, 0x3fee4910UL, 0x330e51b9UL,\n+    0x3e54289cUL, 0x80000000UL, 0x3fee39afUL, 0x8651a95fUL, 0xbe55aad6UL,\n+    0xa0000000UL, 0x3fee2a53UL, 0x5e98c708UL, 0xbe2fc4a9UL, 0xe0000000UL,\n+    0x3fee1afcUL, 0x0989328dUL, 0x3e23958cUL, 0x40000000UL, 0x3fee0babUL,\n+    0xee642abdUL, 0xbe425dd8UL, 0xa0000000UL, 0x3fedfc5eUL, 0xc394d236UL,\n+    0x3e526362UL, 0x20000000UL, 0x3feded17UL, 0xe104aa8eUL, 0x3e4ce247UL,\n+    0xc0000000UL, 0x3fedddd4UL, 0x265a9be4UL, 0xbe5bb77aUL, 0x40000000UL,\n+    0x3fedce97UL, 0x0ecac52fUL, 0x3e4a7cb1UL, 0xe0000000UL, 0x3fedbf5eUL,\n+    0x124cb3b8UL, 0x3e257024UL, 0x80000000UL, 0x3fedb02bUL, 0xe6d4febeUL,\n+    0xbe2033eeUL, 0x20000000UL, 0x3feda0fdUL, 0x39cca00eUL, 0xbe3ddabcUL,\n+    0xc0000000UL, 0x3fed91d3UL, 0xef8a552aUL, 0xbe543390UL, 0x40000000UL,\n+    0x3fed82afUL, 0xb8e85204UL, 0x3e513850UL, 0xe0000000UL, 0x3fed738fUL,\n+    0x3d59fe08UL, 0xbe5db728UL, 0x40000000UL, 0x3fed6475UL, 0x3aa7ead1UL,\n+    0x3e58804bUL, 0xc0000000UL, 0x3fed555fUL, 0xf8a35ba9UL, 0xbe5298b0UL,\n+    0x00000000UL, 0x3fed464fUL, 0x9a88dd15UL, 0x3e5a8cdbUL, 0x40000000UL,\n+    0x3fed3743UL, 0xb0b0a190UL, 0x3e598635UL, 0x80000000UL, 0x3fed283cUL,\n+    0xe2113295UL, 0xbe5c1119UL, 0x80000000UL, 0x3fed193aUL, 0xafbf1728UL,\n+    0xbe492e9cUL, 0x60000000UL, 0x3fed0a3dUL, 0xe4a4ccf3UL, 0x3e19b90eUL,\n+    0x20000000UL, 0x3fecfb45UL, 0xba3cbeb8UL, 0x3e406b50UL, 0xc0000000UL,\n+    0x3fecec51UL, 0x110f7dddUL, 0x3e0d6806UL, 0x40000000UL, 0x3fecdd63UL,\n+    0x7dd7d508UL, 0xbe5a8943UL, 0x80000000UL, 0x3fecce79UL, 0x9b60f271UL,\n+    0xbe50676aUL, 0x80000000UL, 0x3fecbf94UL, 0x0b9ad660UL, 0x3e59174fUL,\n+    0x60000000UL, 0x3fecb0b4UL, 0x00823d9cUL, 0x3e5bbf72UL, 0x20000000UL,\n+    0x3feca1d9UL, 0x38a6ec89UL, 0xbe4d38f9UL, 0x80000000UL, 0x3fec9302UL,\n+    0x3a0b7d8eUL, 0x3e53dbfdUL, 0xc0000000UL, 0x3fec8430UL, 0xc6826b34UL,\n+    0xbe27c5c9UL, 0xc0000000UL, 0x3fec7563UL, 0x0c706381UL, 0xbe593653UL,\n+    0x60000000UL, 0x3fec669bUL, 0x7df34ec7UL, 0x3e461ab5UL, 0xe0000000UL,\n+    0x3fec57d7UL, 0x40e5e7e8UL, 0xbe5c3daeUL, 0x00000000UL, 0x3fec4919UL,\n+    0x5602770fUL, 0xbe55219dUL, 0xc0000000UL, 0x3fec3a5eUL, 0xec7911ebUL,\n+    0x3e5a5d25UL, 0x60000000UL, 0x3fec2ba9UL, 0xb39ea225UL, 0xbe53c00bUL,\n+    0x80000000UL, 0x3fec1cf8UL, 0x967a212eUL, 0x3e5a8ddfUL, 0x60000000UL,\n+    0x3fec0e4cUL, 0x580798bdUL, 0x3e5f53abUL, 0x00000000UL, 0x3febffa5UL,\n+    0xb8282df6UL, 0xbe46b874UL, 0x20000000UL, 0x3febf102UL, 0xe33a6729UL,\n+    0x3e54963fUL, 0x00000000UL, 0x3febe264UL, 0x3b53e88aUL, 0xbe3adce1UL,\n+    0x60000000UL, 0x3febd3caUL, 0xc2585084UL, 0x3e5cde9fUL, 0x80000000UL,\n+    0x3febc535UL, 0xa335c5eeUL, 0xbe39fd9cUL, 0x20000000UL, 0x3febb6a5UL,\n+    0x7325b04dUL, 0x3e42ba15UL, 0x60000000UL, 0x3feba819UL, 0x1564540fUL,\n+    0x3e3a9f35UL, 0x40000000UL, 0x3feb9992UL, 0x83fff592UL, 0xbe5465ceUL,\n+    0xa0000000UL, 0x3feb8b0fUL, 0xb9da63d3UL, 0xbe4b1a0aUL, 0x80000000UL,\n+    0x3feb7c91UL, 0x6d6f1ea4UL, 0x3e557657UL, 0x00000000UL, 0x3feb6e18UL,\n+    0x5e80a1bfUL, 0x3e4ddbb6UL, 0x00000000UL, 0x3feb5fa3UL, 0x1c9eacb5UL,\n+    0x3e592877UL, 0xa0000000UL, 0x3feb5132UL, 0x6d40beb3UL, 0xbe51858cUL,\n+    0xa0000000UL, 0x3feb42c6UL, 0xd740c67bUL, 0x3e427ad2UL, 0x40000000UL,\n+    0x3feb345fUL, 0xa3e0cceeUL, 0xbe5c2fc4UL, 0x40000000UL, 0x3feb25fcUL,\n+    0x8e752b50UL, 0xbe3da3c2UL, 0xc0000000UL, 0x3feb179dUL, 0xa892e7deUL,\n+    0x3e1fb481UL, 0xc0000000UL, 0x3feb0943UL, 0x21ed71e9UL, 0xbe365206UL,\n+    0x20000000UL, 0x3feafaeeUL, 0x0e1380a3UL, 0x3e5c5b7bUL, 0x20000000UL,\n+    0x3feaec9dUL, 0x3c3d640eUL, 0xbe5dbbd0UL, 0x60000000UL, 0x3feade50UL,\n+    0x8f97a715UL, 0x3e3a8ec5UL, 0x20000000UL, 0x3fead008UL, 0x23ab2839UL,\n+    0x3e2fe98aUL, 0x40000000UL, 0x3feac1c4UL, 0xf4bbd50fUL, 0x3e54d8f6UL,\n+    0xe0000000UL, 0x3feab384UL, 0x14757c4dUL, 0xbe48774cUL, 0xc0000000UL,\n+    0x3feaa549UL, 0x7c7b0eeaUL, 0x3e5b51bbUL, 0x20000000UL, 0x3fea9713UL,\n+    0xf56f7013UL, 0x3e386200UL, 0xe0000000UL, 0x3fea88e0UL, 0xbe428ebeUL,\n+    0xbe514af5UL, 0xe0000000UL, 0x3fea7ab2UL, 0x8d0e4496UL, 0x3e4f9165UL,\n+    0x60000000UL, 0x3fea6c89UL, 0xdbacc5d5UL, 0xbe5c063bUL, 0x20000000UL,\n+    0x3fea5e64UL, 0x3f19d970UL, 0xbe5a0c8cUL, 0x20000000UL, 0x3fea5043UL,\n+    0x09ea3e6bUL, 0x3e5065dcUL, 0x80000000UL, 0x3fea4226UL, 0x78df246cUL,\n+    0x3e5e05f6UL, 0x40000000UL, 0x3fea340eUL, 0x4057d4a0UL, 0x3e431b2bUL,\n+    0x40000000UL, 0x3fea25faUL, 0x82867bb5UL, 0x3e4b76beUL, 0xa0000000UL,\n+    0x3fea17eaUL, 0x9436f40aUL, 0xbe5aad39UL, 0x20000000UL, 0x3fea09dfUL,\n+    0x4b5253b3UL, 0x3e46380bUL, 0x00000000UL, 0x3fe9fbd8UL, 0x8fc52466UL,\n+    0xbe386f9bUL, 0x20000000UL, 0x3fe9edd5UL, 0x22d3f344UL, 0xbe538347UL,\n+    0x60000000UL, 0x3fe9dfd6UL, 0x1ac33522UL, 0x3e5dbc53UL, 0x00000000UL,\n+    0x3fe9d1dcUL, 0xeabdff1dUL, 0x3e40fc0cUL, 0xe0000000UL, 0x3fe9c3e5UL,\n+    0xafd30e73UL, 0xbe585e63UL, 0xe0000000UL, 0x3fe9b5f3UL, 0xa52f226aUL,\n+    0xbe43e8f9UL, 0x20000000UL, 0x3fe9a806UL, 0xecb8698dUL, 0xbe515b36UL,\n+    0x80000000UL, 0x3fe99a1cUL, 0xf2b4e89dUL, 0x3e48b62bUL, 0x20000000UL,\n+    0x3fe98c37UL, 0x7c9a88fbUL, 0x3e44414cUL, 0x00000000UL, 0x3fe97e56UL,\n+    0xda015741UL, 0xbe5d13baUL, 0xe0000000UL, 0x3fe97078UL, 0x5fdace06UL,\n+    0x3e51b947UL, 0x00000000UL, 0x3fe962a0UL, 0x956ca094UL, 0x3e518785UL,\n+    0x40000000UL, 0x3fe954cbUL, 0x01164c1dUL, 0x3e5d5b57UL, 0xc0000000UL,\n+    0x3fe946faUL, 0xe63b3767UL, 0xbe4f84e7UL, 0x40000000UL, 0x3fe9392eUL,\n+    0xe57cc2a9UL, 0x3e34eda3UL, 0xe0000000UL, 0x3fe92b65UL, 0x8c75b544UL,\n+    0x3e5766a0UL, 0xc0000000UL, 0x3fe91da1UL, 0x37d1d087UL, 0xbe5e2ab1UL,\n+    0x80000000UL, 0x3fe90fe1UL, 0xa953dc20UL, 0x3e5fa1f3UL, 0x80000000UL,\n+    0x3fe90225UL, 0xdbd3f369UL, 0x3e47d6dbUL, 0xa0000000UL, 0x3fe8f46dUL,\n+    0x1c9be989UL, 0xbe5e2b0aUL, 0xa0000000UL, 0x3fe8e6b9UL, 0x3c93d76aUL,\n+    0x3e5c8618UL, 0xe0000000UL, 0x3fe8d909UL, 0x2182fc9aUL, 0xbe41aa9eUL,\n+    0x20000000UL, 0x3fe8cb5eUL, 0xe6b3539dUL, 0xbe530d19UL, 0x60000000UL,\n+    0x3fe8bdb6UL, 0x49e58cc3UL, 0xbe3bb374UL, 0xa0000000UL, 0x3fe8b012UL,\n+    0xa7cfeb8fUL, 0x3e56c412UL, 0x00000000UL, 0x3fe8a273UL, 0x8d52bc19UL,\n+    0x3e1429b8UL, 0x60000000UL, 0x3fe894d7UL, 0x4dc32c6cUL, 0xbe48604cUL,\n+    0xc0000000UL, 0x3fe8873fUL, 0x0c868e56UL, 0xbe564ee5UL, 0x00000000UL,\n+    0x3fe879acUL, 0x56aee828UL, 0x3e5e2fd8UL, 0x60000000UL, 0x3fe86c1cUL,\n+    0x7ceab8ecUL, 0x3e493365UL, 0xc0000000UL, 0x3fe85e90UL, 0x78d4dadcUL,\n+    0xbe4f7f25UL, 0x00000000UL, 0x3fe85109UL, 0x0ccd8280UL, 0x3e31e7a2UL,\n+    0x40000000UL, 0x3fe84385UL, 0x34ba4e15UL, 0x3e328077UL, 0x80000000UL,\n+    0x3fe83605UL, 0xa670975aUL, 0xbe53eee5UL, 0xa0000000UL, 0x3fe82889UL,\n+    0xf61b77b2UL, 0xbe43a20aUL, 0xa0000000UL, 0x3fe81b11UL, 0x13e6643bUL,\n+    0x3e5e5fe5UL, 0xc0000000UL, 0x3fe80d9dUL, 0x82cc94e8UL, 0xbe5ff1f9UL,\n+    0xa0000000UL, 0x3fe8002dUL, 0x8a0c9c5dUL, 0xbe42b0e7UL, 0x60000000UL,\n+    0x3fe7f2c1UL, 0x22a16f01UL, 0x3e5d9ea0UL, 0x20000000UL, 0x3fe7e559UL,\n+    0xc38cd451UL, 0x3e506963UL, 0xc0000000UL, 0x3fe7d7f4UL, 0x9902bc71UL,\n+    0x3e4503d7UL, 0x40000000UL, 0x3fe7ca94UL, 0xdef2a3c0UL, 0x3e3d98edUL,\n+    0xa0000000UL, 0x3fe7bd37UL, 0xed49abb0UL, 0x3e24c1ffUL, 0xe0000000UL,\n+    0x3fe7afdeUL, 0xe3b0be70UL, 0xbe40c467UL, 0x00000000UL, 0x3fe7a28aUL,\n+    0xaf9f193cUL, 0xbe5dff6cUL, 0xe0000000UL, 0x3fe79538UL, 0xb74cf6b6UL,\n+    0xbe258ed0UL, 0xa0000000UL, 0x3fe787ebUL, 0x1d9127c7UL, 0x3e345fb0UL,\n+    0x40000000UL, 0x3fe77aa2UL, 0x1028c21dUL, 0xbe4619bdUL, 0xa0000000UL,\n+    0x3fe76d5cUL, 0x7cb0b5e4UL, 0x3e40f1a2UL, 0xe0000000UL, 0x3fe7601aUL,\n+    0x2b1bc4adUL, 0xbe32e8bbUL, 0xe0000000UL, 0x3fe752dcUL, 0x6839f64eUL,\n+    0x3e41f57bUL, 0xc0000000UL, 0x3fe745a2UL, 0xc4121f7eUL, 0xbe52c40aUL,\n+    0x60000000UL, 0x3fe7386cUL, 0xd6852d72UL, 0xbe5c4e6bUL, 0xc0000000UL,\n+    0x3fe72b39UL, 0x91d690f7UL, 0xbe57f88fUL, 0xe0000000UL, 0x3fe71e0aUL,\n+    0x627a2159UL, 0xbe4425d5UL, 0xc0000000UL, 0x3fe710dfUL, 0x50a54033UL,\n+    0x3e422b7eUL, 0x60000000UL, 0x3fe703b8UL, 0x3b0b5f91UL, 0x3e5d3857UL,\n+    0xe0000000UL, 0x3fe6f694UL, 0x84d628a2UL, 0xbe51f090UL, 0x00000000UL,\n+    0x3fe6e975UL, 0x306d8894UL, 0xbe414d83UL, 0xe0000000UL, 0x3fe6dc58UL,\n+    0x30bf24aaUL, 0xbe4650caUL, 0x80000000UL, 0x3fe6cf40UL, 0xd4628d69UL,\n+    0xbe5db007UL, 0xc0000000UL, 0x3fe6c22bUL, 0xa2aae57bUL, 0xbe31d279UL,\n+    0xc0000000UL, 0x3fe6b51aUL, 0x860edf7eUL, 0xbe2d4c4aUL, 0x80000000UL,\n+    0x3fe6a80dUL, 0xf3559341UL, 0xbe5f7e98UL, 0xe0000000UL, 0x3fe69b03UL,\n+    0xa885899eUL, 0xbe5c2011UL, 0xe0000000UL, 0x3fe68dfdUL, 0x2bdc6d37UL,\n+    0x3e224a82UL, 0xa0000000UL, 0x3fe680fbUL, 0xc12ad1b9UL, 0xbe40cf56UL,\n+    0x00000000UL, 0x3fe673fdUL, 0x1bcdf659UL, 0xbdf52f2dUL, 0x00000000UL,\n+    0x3fe66702UL, 0x5df10408UL, 0x3e5663e0UL, 0xc0000000UL, 0x3fe65a0aUL,\n+    0xa4070568UL, 0xbe40b12fUL, 0x00000000UL, 0x3fe64d17UL, 0x71c54c47UL,\n+    0x3e5f5e8bUL, 0x00000000UL, 0x3fe64027UL, 0xbd4b7e83UL, 0x3e42ead6UL,\n+    0xa0000000UL, 0x3fe6333aUL, 0x61598bd2UL, 0xbe4c48d4UL, 0xc0000000UL,\n+    0x3fe62651UL, 0x6f538d61UL, 0x3e548401UL, 0xa0000000UL, 0x3fe6196cUL,\n+    0x14344120UL, 0xbe529af6UL, 0x00000000UL, 0x3fe60c8bUL, 0x5982c587UL,\n+    0xbe3e1e4fUL, 0x00000000UL, 0x3fe5ffadUL, 0xfe51d4eaUL, 0xbe4c897aUL,\n+    0x80000000UL, 0x3fe5f2d2UL, 0xfd46ebe1UL, 0x3e552e00UL, 0xa0000000UL,\n+    0x3fe5e5fbUL, 0xa4695699UL, 0x3e5ed471UL, 0x60000000UL, 0x3fe5d928UL,\n+    0x80d118aeUL, 0x3e456b61UL, 0xa0000000UL, 0x3fe5cc58UL, 0x304c330bUL,\n+    0x3e54dc29UL, 0x80000000UL, 0x3fe5bf8cUL, 0x0af2dedfUL, 0xbe3aa9bdUL,\n+    0xe0000000UL, 0x3fe5b2c3UL, 0x15fc9258UL, 0xbe479a37UL, 0xc0000000UL,\n+    0x3fe5a5feUL, 0x9292c7eaUL, 0x3e188650UL, 0x20000000UL, 0x3fe5993dUL,\n+    0x33b4d380UL, 0x3e5d6d93UL, 0x20000000UL, 0x3fe58c7fUL, 0x02fd16c7UL,\n+    0x3e2fe961UL, 0xa0000000UL, 0x3fe57fc4UL, 0x4a05edb6UL, 0xbe4d55b4UL,\n+    0xa0000000UL, 0x3fe5730dUL, 0x3d443abbUL, 0xbe5e6954UL, 0x00000000UL,\n+    0x3fe5665aUL, 0x024acfeaUL, 0x3e50e61bUL, 0x00000000UL, 0x3fe559aaUL,\n+    0xcc9edd09UL, 0xbe325403UL, 0x60000000UL, 0x3fe54cfdUL, 0x1fe26950UL,\n+    0x3e5d500eUL, 0x60000000UL, 0x3fe54054UL, 0x6c5ae164UL, 0xbe4a79b4UL,\n+    0xc0000000UL, 0x3fe533aeUL, 0x154b0287UL, 0xbe401571UL, 0xa0000000UL,\n+    0x3fe5270cUL, 0x0673f401UL, 0xbe56e56bUL, 0xe0000000UL, 0x3fe51a6dUL,\n+    0x751b639cUL, 0x3e235269UL, 0xa0000000UL, 0x3fe50dd2UL, 0x7c7b2bedUL,\n+    0x3ddec887UL, 0xc0000000UL, 0x3fe5013aUL, 0xafab4e17UL, 0x3e5e7575UL,\n+    0x60000000UL, 0x3fe4f4a6UL, 0x2e308668UL, 0x3e59aed6UL, 0x80000000UL,\n+    0x3fe4e815UL, 0xf33e2a76UL, 0xbe51f184UL, 0xe0000000UL, 0x3fe4db87UL,\n+    0x839f3e3eUL, 0x3e57db01UL, 0xc0000000UL, 0x3fe4cefdUL, 0xa9eda7bbUL,\n+    0x3e535e0fUL, 0x00000000UL, 0x3fe4c277UL, 0x2a8f66a5UL, 0x3e5ce451UL,\n+    0xc0000000UL, 0x3fe4b5f3UL, 0x05192456UL, 0xbe4e8518UL, 0xc0000000UL,\n+    0x3fe4a973UL, 0x4aa7cd1dUL, 0x3e46784aUL, 0x40000000UL, 0x3fe49cf7UL,\n+    0x8e23025eUL, 0xbe5749f2UL, 0x00000000UL, 0x3fe4907eUL, 0x18d30215UL,\n+    0x3e360f39UL, 0x20000000UL, 0x3fe48408UL, 0x63dcf2f3UL, 0x3e5e00feUL,\n+    0xc0000000UL, 0x3fe47795UL, 0x46182d09UL, 0xbe5173d9UL, 0xa0000000UL,\n+    0x3fe46b26UL, 0x8f0e62aaUL, 0xbe48f281UL, 0xe0000000UL, 0x3fe45ebaUL,\n+    0x5775c40cUL, 0xbe56aad4UL, 0x60000000UL, 0x3fe45252UL, 0x0fe25f69UL,\n+    0x3e48bd71UL, 0x40000000UL, 0x3fe445edUL, 0xe9989ec5UL, 0x3e590d97UL,\n+    0x80000000UL, 0x3fe4398bUL, 0xb3d9ffe3UL, 0x3e479dbcUL, 0x20000000UL,\n+    0x3fe42d2dUL, 0x388e4d2eUL, 0xbe5eed80UL, 0xe0000000UL, 0x3fe420d1UL,\n+    0x6f797c18UL, 0x3e554b4cUL, 0x20000000UL, 0x3fe4147aUL, 0x31048bb4UL,\n+    0xbe5b1112UL, 0x80000000UL, 0x3fe40825UL, 0x2efba4f9UL, 0x3e48ebc7UL,\n+    0x40000000UL, 0x3fe3fbd4UL, 0x50201119UL, 0x3e40b701UL, 0x40000000UL,\n+    0x3fe3ef86UL, 0x0a4db32cUL, 0x3e551de8UL, 0xa0000000UL, 0x3fe3e33bUL,\n+    0x0c9c148bUL, 0xbe50c1f6UL, 0x20000000UL, 0x3fe3d6f4UL, 0xc9129447UL,\n+    0x3e533fa0UL, 0x00000000UL, 0x3fe3cab0UL, 0xaae5b5a0UL, 0xbe22b68eUL,\n+    0x20000000UL, 0x3fe3be6fUL, 0x02305e8aUL, 0xbe54fc08UL, 0x60000000UL,\n+    0x3fe3b231UL, 0x7f908258UL, 0x3e57dc05UL, 0x00000000UL, 0x3fe3a5f7UL,\n+    0x1a09af78UL, 0x3e08038bUL, 0xe0000000UL, 0x3fe399bfUL, 0x490643c1UL,\n+    0xbe5dbe42UL, 0xe0000000UL, 0x3fe38d8bUL, 0x5e8ad724UL, 0xbe3c2b72UL,\n+    0x20000000UL, 0x3fe3815bUL, 0xc67196b6UL, 0x3e1713cfUL, 0xa0000000UL,\n+    0x3fe3752dUL, 0x6182e429UL, 0xbe3ec14cUL, 0x40000000UL, 0x3fe36903UL,\n+    0xab6eb1aeUL, 0x3e5a2cc5UL, 0x40000000UL, 0x3fe35cdcUL, 0xfe5dc064UL,\n+    0xbe5c5878UL, 0x40000000UL, 0x3fe350b8UL, 0x0ba6b9e4UL, 0x3e51619bUL,\n+    0x80000000UL, 0x3fe34497UL, 0x857761aaUL, 0x3e5fff53UL, 0x00000000UL,\n+    0x3fe3387aUL, 0xf872d68cUL, 0x3e484f4dUL, 0xa0000000UL, 0x3fe32c5fUL,\n+    0x087e97c2UL, 0x3e52842eUL, 0x80000000UL, 0x3fe32048UL, 0x73d6d0c0UL,\n+    0xbe503edfUL, 0x80000000UL, 0x3fe31434UL, 0x0c1456a1UL, 0xbe5f72adUL,\n+    0xa0000000UL, 0x3fe30823UL, 0x83a1a4d5UL, 0xbe5e65ccUL, 0xe0000000UL,\n+    0x3fe2fc15UL, 0x855a7390UL, 0xbe506438UL, 0x40000000UL, 0x3fe2f00bUL,\n+    0xa2898287UL, 0x3e3d22a2UL, 0xe0000000UL, 0x3fe2e403UL, 0x8b56f66fUL,\n+    0xbe5aa5fdUL, 0x80000000UL, 0x3fe2d7ffUL, 0x52db119aUL, 0x3e3a2e3dUL,\n+    0x60000000UL, 0x3fe2cbfeUL, 0xe2ddd4c0UL, 0xbe586469UL, 0x40000000UL,\n+    0x3fe2c000UL, 0x6b01bf10UL, 0x3e352b9dUL, 0x40000000UL, 0x3fe2b405UL,\n+    0xb07a1cdfUL, 0x3e5c5cdaUL, 0x80000000UL, 0x3fe2a80dUL, 0xc7b5f868UL,\n+    0xbe5668b3UL, 0xc0000000UL, 0x3fe29c18UL, 0x185edf62UL, 0xbe563d66UL,\n+    0x00000000UL, 0x3fe29027UL, 0xf729e1ccUL, 0x3e59a9a0UL, 0x80000000UL,\n+    0x3fe28438UL, 0x6433c727UL, 0xbe43cc89UL, 0x00000000UL, 0x3fe2784dUL,\n+    0x41782631UL, 0xbe30750cUL, 0xa0000000UL, 0x3fe26c64UL, 0x914911b7UL,\n+    0xbe58290eUL, 0x40000000UL, 0x3fe2607fUL, 0x3dcc73e1UL, 0xbe4269cdUL,\n+    0x00000000UL, 0x3fe2549dUL, 0x2751bf70UL, 0xbe5a6998UL, 0xc0000000UL,\n+    0x3fe248bdUL, 0x4248b9fbUL, 0xbe4ddb00UL, 0x80000000UL, 0x3fe23ce1UL,\n+    0xf35cf82fUL, 0x3e561b71UL, 0x60000000UL, 0x3fe23108UL, 0x8e481a2dUL,\n+    0x3e518fb9UL, 0x60000000UL, 0x3fe22532UL, 0x5ab96edcUL, 0xbe5fafc5UL,\n+    0x40000000UL, 0x3fe2195fUL, 0x80943911UL, 0xbe07f819UL, 0x40000000UL,\n+    0x3fe20d8fUL, 0x386f2d6cUL, 0xbe54ba8bUL, 0x40000000UL, 0x3fe201c2UL,\n+    0xf29664acUL, 0xbe5eb815UL, 0x20000000UL, 0x3fe1f5f8UL, 0x64f03390UL,\n+    0x3e5e320cUL, 0x20000000UL, 0x3fe1ea31UL, 0x747ff696UL, 0x3e5ef0a5UL,\n+    0x40000000UL, 0x3fe1de6dUL, 0x3e9ceb51UL, 0xbe5f8d27UL, 0x20000000UL,\n+    0x3fe1d2acUL, 0x4ae0b55eUL, 0x3e5faa21UL, 0x20000000UL, 0x3fe1c6eeUL,\n+    0x28569a5eUL, 0x3e598a4fUL, 0x20000000UL, 0x3fe1bb33UL, 0x54b33e07UL,\n+    0x3e46130aUL, 0x20000000UL, 0x3fe1af7bUL, 0x024f1078UL, 0xbe4dbf93UL,\n+    0x00000000UL, 0x3fe1a3c6UL, 0xb0783bfaUL, 0x3e419248UL, 0xe0000000UL,\n+    0x3fe19813UL, 0x2f02b836UL, 0x3e4e02b7UL, 0xc0000000UL, 0x3fe18c64UL,\n+    0x28dec9d4UL, 0x3e09064fUL, 0x80000000UL, 0x3fe180b8UL, 0x45cbf406UL,\n+    0x3e5b1f46UL, 0x40000000UL, 0x3fe1750fUL, 0x03d9964cUL, 0x3e5b0a79UL,\n+    0x00000000UL, 0x3fe16969UL, 0x8b5b882bUL, 0xbe238086UL, 0xa0000000UL,\n+    0x3fe15dc5UL, 0x73bad6f8UL, 0xbdf1fca4UL, 0x20000000UL, 0x3fe15225UL,\n+    0x5385769cUL, 0x3e5e8d76UL, 0xa0000000UL, 0x3fe14687UL, 0x1676dc6bUL,\n+    0x3e571d08UL, 0x20000000UL, 0x3fe13aedUL, 0xa8c41c7fUL, 0xbe598a25UL,\n+    0x60000000UL, 0x3fe12f55UL, 0xc4e1aaf0UL, 0x3e435277UL, 0xa0000000UL,\n+    0x3fe123c0UL, 0x403638e1UL, 0xbe21aa7cUL, 0xc0000000UL, 0x3fe1182eUL,\n+    0x557a092bUL, 0xbdd0116bUL, 0xc0000000UL, 0x3fe10c9fUL, 0x7d779f66UL,\n+    0x3e4a61baUL, 0xc0000000UL, 0x3fe10113UL, 0x2b09c645UL, 0xbe5d586eUL,\n+    0x20000000UL, 0x3fe0ea04UL, 0xea2cad46UL, 0x3e5aa97cUL, 0x20000000UL,\n+    0x3fe0d300UL, 0x23190e54UL, 0x3e50f1a7UL, 0xa0000000UL, 0x3fe0bc07UL,\n+    0x1379a5a6UL, 0xbe51619dUL, 0x60000000UL, 0x3fe0a51aUL, 0x926a3d4aUL,\n+    0x3e5cf019UL, 0xa0000000UL, 0x3fe08e38UL, 0xa8c24358UL, 0x3e35241eUL,\n+    0x20000000UL, 0x3fe07762UL, 0x24317e7aUL, 0x3e512cfaUL, 0x00000000UL,\n+    0x3fe06097UL, 0xfd9cf274UL, 0xbe55bef3UL, 0x00000000UL, 0x3fe049d7UL,\n+    0x3689b49dUL, 0xbe36d26dUL, 0x40000000UL, 0x3fe03322UL, 0xf72ef6c4UL,\n+    0xbe54cd08UL, 0xa0000000UL, 0x3fe01c78UL, 0x23702d2dUL, 0xbe5900bfUL,\n+    0x00000000UL, 0x3fe005daUL, 0x3f59c14cUL, 0x3e57d80bUL, 0x40000000UL,\n+    0x3fdfde8dUL, 0xad67766dUL, 0xbe57fad4UL, 0x40000000UL, 0x3fdfb17cUL,\n+    0x644f4ae7UL, 0x3e1ee43bUL, 0x40000000UL, 0x3fdf8481UL, 0x903234d2UL,\n+    0x3e501a86UL, 0x40000000UL, 0x3fdf579cUL, 0xafe9e509UL, 0xbe267c3eUL,\n+    0x00000000UL, 0x3fdf2acdUL, 0xb7dfda0bUL, 0xbe48149bUL, 0x40000000UL,\n+    0x3fdefe13UL, 0x3b94305eUL, 0x3e5f4ea7UL, 0x80000000UL, 0x3fded16fUL,\n+    0x5d95da61UL, 0xbe55c198UL, 0x00000000UL, 0x3fdea4e1UL, 0x406960c9UL,\n+    0xbdd99a19UL, 0x00000000UL, 0x3fde7868UL, 0xd22f3539UL, 0x3e470c78UL,\n+    0x80000000UL, 0x3fde4c04UL, 0x83eec535UL, 0xbe3e1232UL, 0x40000000UL,\n+    0x3fde1fb6UL, 0x3dfbffcbUL, 0xbe4b7d71UL, 0x40000000UL, 0x3fddf37dUL,\n+    0x7e1be4e0UL, 0xbe5b8f8fUL, 0x40000000UL, 0x3fddc759UL, 0x46dae887UL,\n+    0xbe350458UL, 0x80000000UL, 0x3fdd9b4aUL, 0xed6ecc49UL, 0xbe5f0045UL,\n+    0x80000000UL, 0x3fdd6f50UL, 0x2e9e883cUL, 0x3e2915daUL, 0x80000000UL,\n+    0x3fdd436bUL, 0xf0bccb32UL, 0x3e4a68c9UL, 0x80000000UL, 0x3fdd179bUL,\n+    0x9bbfc779UL, 0xbe54a26aUL, 0x00000000UL, 0x3fdcebe0UL, 0x7cea33abUL,\n+    0x3e43c6b7UL, 0x40000000UL, 0x3fdcc039UL, 0xe740fd06UL, 0x3e5526c2UL,\n+    0x40000000UL, 0x3fdc94a7UL, 0x9eadeb1aUL, 0xbe396d8dUL, 0xc0000000UL,\n+    0x3fdc6929UL, 0xf0a8f95aUL, 0xbe5c0ab2UL, 0x80000000UL, 0x3fdc3dc0UL,\n+    0x6ee2693bUL, 0x3e0992e6UL, 0xc0000000UL, 0x3fdc126bUL, 0x5ac6b581UL,\n+    0xbe2834b6UL, 0x40000000UL, 0x3fdbe72bUL, 0x8cc226ffUL, 0x3e3596a6UL,\n+    0x00000000UL, 0x3fdbbbffUL, 0xf92a74bbUL, 0x3e3c5813UL, 0x00000000UL,\n+    0x3fdb90e7UL, 0x479664c0UL, 0xbe50d644UL, 0x00000000UL, 0x3fdb65e3UL,\n+    0x5004975bUL, 0xbe55258fUL, 0x00000000UL, 0x3fdb3af3UL, 0xe4b23194UL,\n+    0xbe588407UL, 0xc0000000UL, 0x3fdb1016UL, 0xe65d4d0aUL, 0x3e527c26UL,\n+    0x80000000UL, 0x3fdae54eUL, 0x814fddd6UL, 0x3e5962a2UL, 0x40000000UL,\n+    0x3fdaba9aUL, 0xe19d0913UL, 0xbe562f4eUL, 0x80000000UL, 0x3fda8ff9UL,\n+    0x43cfd006UL, 0xbe4cfdebUL, 0x40000000UL, 0x3fda656cUL, 0x686f0a4eUL,\n+    0x3e5e47a8UL, 0xc0000000UL, 0x3fda3af2UL, 0x7200d410UL, 0x3e5e1199UL,\n+    0xc0000000UL, 0x3fda108cUL, 0xabd2266eUL, 0x3e5ee4d1UL, 0x40000000UL,\n+    0x3fd9e63aUL, 0x396f8f2cUL, 0x3e4dbffbUL, 0x00000000UL, 0x3fd9bbfbUL,\n+    0xe32b25ddUL, 0x3e5c3a54UL, 0x40000000UL, 0x3fd991cfUL, 0x431e4035UL,\n+    0xbe457925UL, 0x80000000UL, 0x3fd967b6UL, 0x7bed3dd3UL, 0x3e40c61dUL,\n+    0x00000000UL, 0x3fd93db1UL, 0xd7449365UL, 0x3e306419UL, 0x80000000UL,\n+    0x3fd913beUL, 0x1746e791UL, 0x3e56fcfcUL, 0x40000000UL, 0x3fd8e9dfUL,\n+    0xf3a9028bUL, 0xbe5041b9UL, 0xc0000000UL, 0x3fd8c012UL, 0x56840c50UL,\n+    0xbe26e20aUL, 0x40000000UL, 0x3fd89659UL, 0x19763102UL, 0xbe51f466UL,\n+    0x80000000UL, 0x3fd86cb2UL, 0x7032de7cUL, 0xbe4d298aUL, 0x80000000UL,\n+    0x3fd8431eUL, 0xdeb39fabUL, 0xbe4361ebUL, 0x40000000UL, 0x3fd8199dUL,\n+    0x5d01cbe0UL, 0xbe5425b3UL, 0x80000000UL, 0x3fd7f02eUL, 0x3ce99aa9UL,\n+    0x3e146fa8UL, 0x80000000UL, 0x3fd7c6d2UL, 0xd1a262b9UL, 0xbe5a1a69UL,\n+    0xc0000000UL, 0x3fd79d88UL, 0x8606c236UL, 0x3e423a08UL, 0x80000000UL,\n+    0x3fd77451UL, 0x8fd1e1b7UL, 0x3e5a6a63UL, 0xc0000000UL, 0x3fd74b2cUL,\n+    0xe491456aUL, 0x3e42c1caUL, 0x40000000UL, 0x3fd7221aUL, 0x4499a6d7UL,\n+    0x3e36a69aUL, 0x00000000UL, 0x3fd6f91aUL, 0x5237df94UL, 0xbe0f8f02UL,\n+    0x00000000UL, 0x3fd6d02cUL, 0xb6482c6eUL, 0xbe5abcf7UL, 0x00000000UL,\n+    0x3fd6a750UL, 0x1919fd61UL, 0xbe57ade2UL, 0x00000000UL, 0x3fd67e86UL,\n+    0xaa7a994dUL, 0xbe3f3fbdUL, 0x00000000UL, 0x3fd655ceUL, 0x67db014cUL,\n+    0x3e33c550UL, 0x00000000UL, 0x3fd62d28UL, 0xa82856b7UL, 0xbe1409d1UL,\n+    0xc0000000UL, 0x3fd60493UL, 0x1e6a300dUL, 0x3e55d899UL, 0x80000000UL,\n+    0x3fd5dc11UL, 0x1222bd5cUL, 0xbe35bfc0UL, 0xc0000000UL, 0x3fd5b3a0UL,\n+    0x6e8dc2d3UL, 0x3e5d4d79UL, 0x00000000UL, 0x3fd58b42UL, 0xe0e4ace6UL,\n+    0xbe517303UL, 0x80000000UL, 0x3fd562f4UL, 0xb306e0a8UL, 0x3e5edf0fUL,\n+    0xc0000000UL, 0x3fd53ab8UL, 0x6574bc54UL, 0x3e5ee859UL, 0x80000000UL,\n+    0x3fd5128eUL, 0xea902207UL, 0x3e5f6188UL, 0xc0000000UL, 0x3fd4ea75UL,\n+    0x9f911d79UL, 0x3e511735UL, 0x80000000UL, 0x3fd4c26eUL, 0xf9c77397UL,\n+    0xbe5b1643UL, 0x40000000UL, 0x3fd49a78UL, 0x15fc9258UL, 0x3e479a37UL,\n+    0x80000000UL, 0x3fd47293UL, 0xd5a04dd9UL, 0xbe426e56UL, 0xc0000000UL,\n+    0x3fd44abfUL, 0xe04042f5UL, 0x3e56f7c6UL, 0x40000000UL, 0x3fd422fdUL,\n+    0x1d8bf2c8UL, 0x3e5d8810UL, 0x00000000UL, 0x3fd3fb4cUL, 0x88a8ddeeUL,\n+    0xbe311454UL, 0xc0000000UL, 0x3fd3d3abUL, 0x3e3b5e47UL, 0xbe5d1b72UL,\n+    0x40000000UL, 0x3fd3ac1cUL, 0xc2ab5d59UL, 0x3e31b02bUL, 0xc0000000UL,\n+    0x3fd3849dUL, 0xd4e34b9eUL, 0x3e51cb2fUL, 0x40000000UL, 0x3fd35d30UL,\n+    0x177204fbUL, 0xbe2b8cd7UL, 0x80000000UL, 0x3fd335d3UL, 0xfcd38c82UL,\n+    0xbe4356e1UL, 0x80000000UL, 0x3fd30e87UL, 0x64f54accUL, 0xbe4e6224UL,\n+    0x00000000UL, 0x3fd2e74cUL, 0xaa7975d9UL, 0x3e5dc0feUL, 0x80000000UL,\n+    0x3fd2c021UL, 0x516dab3fUL, 0xbe50ffa3UL, 0x40000000UL, 0x3fd29907UL,\n+    0x2bfb7313UL, 0x3e5674a2UL, 0xc0000000UL, 0x3fd271fdUL, 0x0549fc99UL,\n+    0x3e385d29UL, 0xc0000000UL, 0x3fd24b04UL, 0x55b63073UL, 0xbe500c6dUL,\n+    0x00000000UL, 0x3fd2241cUL, 0x3f91953aUL, 0x3e389977UL, 0xc0000000UL,\n+    0x3fd1fd43UL, 0xa1543f71UL, 0xbe3487abUL, 0xc0000000UL, 0x3fd1d67bUL,\n+    0x4ec8867cUL, 0x3df6a2dcUL, 0x00000000UL, 0x3fd1afc4UL, 0x4328e3bbUL,\n+    0x3e41d9c0UL, 0x80000000UL, 0x3fd1891cUL, 0x2e1cda84UL, 0x3e3bdd87UL,\n+    0x40000000UL, 0x3fd16285UL, 0x4b5331aeUL, 0xbe53128eUL, 0x00000000UL,\n+    0x3fd13bfeUL, 0xb9aec164UL, 0xbe52ac98UL, 0xc0000000UL, 0x3fd11586UL,\n+    0xd91e1316UL, 0xbe350630UL, 0x80000000UL, 0x3fd0ef1fUL, 0x7cacc12cUL,\n+    0x3e3f5219UL, 0x40000000UL, 0x3fd0c8c8UL, 0xbce277b7UL, 0x3e3d30c0UL,\n+    0x00000000UL, 0x3fd0a281UL, 0x2a63447dUL, 0xbe541377UL, 0x80000000UL,\n+    0x3fd07c49UL, 0xfac483b5UL, 0xbe5772ecUL, 0xc0000000UL, 0x3fd05621UL,\n+    0x36b8a570UL, 0xbe4fd4bdUL, 0xc0000000UL, 0x3fd03009UL, 0xbae505f7UL,\n+    0xbe450388UL, 0x80000000UL, 0x3fd00a01UL, 0x3e35aeadUL, 0xbe5430fcUL,\n+    0x80000000UL, 0x3fcfc811UL, 0x707475acUL, 0x3e38806eUL, 0x80000000UL,\n+    0x3fcf7c3fUL, 0xc91817fcUL, 0xbe40cceaUL, 0x80000000UL, 0x3fcf308cUL,\n+    0xae05d5e9UL, 0xbe4919b8UL, 0x80000000UL, 0x3fcee4f8UL, 0xae6cc9e6UL,\n+    0xbe530b94UL, 0x00000000UL, 0x3fce9983UL, 0x1efe3e8eUL, 0x3e57747eUL,\n+    0x00000000UL, 0x3fce4e2dUL, 0xda78d9bfUL, 0xbe59a608UL, 0x00000000UL,\n+    0x3fce02f5UL, 0x8abe2c2eUL, 0x3e4a35adUL, 0x00000000UL, 0x3fcdb7dcUL,\n+    0x1495450dUL, 0xbe0872ccUL, 0x80000000UL, 0x3fcd6ce1UL, 0x86ee0ba0UL,\n+    0xbe4f59a0UL, 0x00000000UL, 0x3fcd2205UL, 0xe81ca888UL, 0x3e5402c3UL,\n+    0x00000000UL, 0x3fccd747UL, 0x3b4424b9UL, 0x3e5dfdc3UL, 0x80000000UL,\n+    0x3fcc8ca7UL, 0xd305b56cUL, 0x3e202da6UL, 0x00000000UL, 0x3fcc4226UL,\n+    0x399a6910UL, 0xbe482a1cUL, 0x80000000UL, 0x3fcbf7c2UL, 0x747f7938UL,\n+    0xbe587372UL, 0x80000000UL, 0x3fcbad7cUL, 0x6fc246a0UL, 0x3e50d83dUL,\n+    0x00000000UL, 0x3fcb6355UL, 0xee9e9be5UL, 0xbe5c35bdUL, 0x80000000UL,\n+    0x3fcb194aUL, 0x8416c0bcUL, 0x3e546d4fUL, 0x00000000UL, 0x3fcacf5eUL,\n+    0x49f7f08fUL, 0x3e56da76UL, 0x00000000UL, 0x3fca858fUL, 0x5dc30de2UL,\n+    0x3e5f390cUL, 0x00000000UL, 0x3fca3bdeUL, 0x950583b6UL, 0xbe5e4169UL,\n+    0x80000000UL, 0x3fc9f249UL, 0x33631553UL, 0x3e52aeb1UL, 0x00000000UL,\n+    0x3fc9a8d3UL, 0xde8795a6UL, 0xbe59a504UL, 0x00000000UL, 0x3fc95f79UL,\n+    0x076bf41eUL, 0x3e5122feUL, 0x80000000UL, 0x3fc9163cUL, 0x2914c8e7UL,\n+    0x3e3dd064UL, 0x00000000UL, 0x3fc8cd1dUL, 0x3a30eca3UL, 0xbe21b4aaUL,\n+    0x80000000UL, 0x3fc8841aUL, 0xb2a96650UL, 0xbe575444UL, 0x80000000UL,\n+    0x3fc83b34UL, 0x2376c0cbUL, 0xbe2a74c7UL, 0x80000000UL, 0x3fc7f26bUL,\n+    0xd8a0b653UL, 0xbe5181b6UL, 0x00000000UL, 0x3fc7a9bfUL, 0x32257882UL,\n+    0xbe4a78b4UL, 0x00000000UL, 0x3fc7612fUL, 0x1eee8bd9UL, 0xbe1bfe9dUL,\n+    0x80000000UL, 0x3fc718bbUL, 0x0c603cc4UL, 0x3e36fdc9UL, 0x80000000UL,\n+    0x3fc6d064UL, 0x3728b8cfUL, 0xbe1e542eUL, 0x80000000UL, 0x3fc68829UL,\n+    0xc79a4067UL, 0x3e5c380fUL, 0x00000000UL, 0x3fc6400bUL, 0xf69eac69UL,\n+    0x3e550a84UL, 0x80000000UL, 0x3fc5f808UL, 0xb7a780a4UL, 0x3e5d9224UL,\n+    0x80000000UL, 0x3fc5b022UL, 0xad9dfb1eUL, 0xbe55242fUL, 0x00000000UL,\n+    0x3fc56858UL, 0x659b18beUL, 0xbe4bfda3UL, 0x80000000UL, 0x3fc520a9UL,\n+    0x66ee3631UL, 0xbe57d769UL, 0x80000000UL, 0x3fc4d916UL, 0x1ec62819UL,\n+    0x3e2427f7UL, 0x80000000UL, 0x3fc4919fUL, 0xdec25369UL, 0xbe435431UL,\n+    0x00000000UL, 0x3fc44a44UL, 0xa8acfc4bUL, 0xbe3c62e8UL, 0x00000000UL,\n+    0x3fc40304UL, 0xcf1d3eabUL, 0xbdfba29fUL, 0x80000000UL, 0x3fc3bbdfUL,\n+    0x79aba3eaUL, 0xbdf1b7c8UL, 0x80000000UL, 0x3fc374d6UL, 0xb8d186daUL,\n+    0xbe5130cfUL, 0x80000000UL, 0x3fc32de8UL, 0x9d74f152UL, 0x3e2285b6UL,\n+    0x00000000UL, 0x3fc2e716UL, 0x50ae7ca9UL, 0xbe503920UL, 0x80000000UL,\n+    0x3fc2a05eUL, 0x6caed92eUL, 0xbe533924UL, 0x00000000UL, 0x3fc259c2UL,\n+    0x9cb5034eUL, 0xbe510e31UL, 0x80000000UL, 0x3fc21340UL, 0x12c4d378UL,\n+    0xbe540b43UL, 0x80000000UL, 0x3fc1ccd9UL, 0xcc418706UL, 0x3e59887aUL,\n+    0x00000000UL, 0x3fc1868eUL, 0x921f4106UL, 0xbe528e67UL, 0x80000000UL,\n+    0x3fc1405cUL, 0x3969441eUL, 0x3e5d8051UL, 0x00000000UL, 0x3fc0fa46UL,\n+    0xd941ef5bUL, 0x3e5f9079UL, 0x80000000UL, 0x3fc0b44aUL, 0x5a3e81b2UL,\n+    0xbe567691UL, 0x00000000UL, 0x3fc06e69UL, 0x9d66afe7UL, 0xbe4d43fbUL,\n+    0x00000000UL, 0x3fc028a2UL, 0x0a92a162UL, 0xbe52f394UL, 0x00000000UL,\n+    0x3fbfc5eaUL, 0x209897e5UL, 0x3e529e37UL, 0x00000000UL, 0x3fbf3ac5UL,\n+    0x8458bd7bUL, 0x3e582831UL, 0x00000000UL, 0x3fbeafd5UL, 0xb8d8b4b8UL,\n+    0xbe486b4aUL, 0x00000000UL, 0x3fbe2518UL, 0xe0a3b7b6UL, 0x3e5bafd2UL,\n+    0x00000000UL, 0x3fbd9a90UL, 0x2bf2710eUL, 0x3e383b2bUL, 0x00000000UL,\n+    0x3fbd103cUL, 0x73eb6ab7UL, 0xbe56d78dUL, 0x00000000UL, 0x3fbc861bUL,\n+    0x32ceaff5UL, 0xbe32dc5aUL, 0x00000000UL, 0x3fbbfc2eUL, 0xbee04cb7UL,\n+    0xbe4a71a4UL, 0x00000000UL, 0x3fbb7274UL, 0x35ae9577UL, 0x3e38142fUL,\n+    0x00000000UL, 0x3fbae8eeUL, 0xcbaddab4UL, 0xbe5490f0UL, 0x00000000UL,\n+    0x3fba5f9aUL, 0x95ce1114UL, 0x3e597c71UL, 0x00000000UL, 0x3fb9d67aUL,\n+    0x6d7c0f78UL, 0x3e3abc2dUL, 0x00000000UL, 0x3fb94d8dUL, 0x2841a782UL,\n+    0xbe566cbcUL, 0x00000000UL, 0x3fb8c4d2UL, 0x6ed429c6UL, 0xbe3cfff9UL,\n+    0x00000000UL, 0x3fb83c4aUL, 0xe4a49fbbUL, 0xbe552964UL, 0x00000000UL,\n+    0x3fb7b3f4UL, 0x2193d81eUL, 0xbe42fa72UL, 0x00000000UL, 0x3fb72bd0UL,\n+    0xdd70c122UL, 0x3e527a8cUL, 0x00000000UL, 0x3fb6a3dfUL, 0x03108a54UL,\n+    0xbe450393UL, 0x00000000UL, 0x3fb61c1fUL, 0x30ff7954UL, 0x3e565840UL,\n+    0x00000000UL, 0x3fb59492UL, 0xdedd460cUL, 0xbe5422b5UL, 0x00000000UL,\n+    0x3fb50d36UL, 0x950f9f45UL, 0xbe5313f6UL, 0x00000000UL, 0x3fb4860bUL,\n+    0x582cdcb1UL, 0x3e506d39UL, 0x00000000UL, 0x3fb3ff12UL, 0x7216d3a6UL,\n+    0x3e4aa719UL, 0x00000000UL, 0x3fb3784aUL, 0x57a423fdUL, 0x3e5a9b9fUL,\n+    0x00000000UL, 0x3fb2f1b4UL, 0x7a138b41UL, 0xbe50b418UL, 0x00000000UL,\n+    0x3fb26b4eUL, 0x2fbfd7eaUL, 0x3e23a53eUL, 0x00000000UL, 0x3fb1e519UL,\n+    0x18913ccbUL, 0x3e465fc1UL, 0x00000000UL, 0x3fb15f15UL, 0x7ea24e21UL,\n+    0x3e042843UL, 0x00000000UL, 0x3fb0d941UL, 0x7c6d9c77UL, 0x3e59f61eUL,\n+    0x00000000UL, 0x3fb0539eUL, 0x114efd44UL, 0x3e4ccab7UL, 0x00000000UL,\n+    0x3faf9c56UL, 0x1777f657UL, 0x3e552f65UL, 0x00000000UL, 0x3fae91d2UL,\n+    0xc317b86aUL, 0xbe5a61e0UL, 0x00000000UL, 0x3fad87acUL, 0xb7664efbUL,\n+    0xbe41f64eUL, 0x00000000UL, 0x3fac7de6UL, 0x5d3d03a9UL, 0x3e0807a0UL,\n+    0x00000000UL, 0x3fab7480UL, 0x743c38ebUL, 0xbe3726e1UL, 0x00000000UL,\n+    0x3faa6b78UL, 0x06a253f1UL, 0x3e5ad636UL, 0x00000000UL, 0x3fa962d0UL,\n+    0xa35f541bUL, 0x3e5a187aUL, 0x00000000UL, 0x3fa85a88UL, 0x4b86e446UL,\n+    0xbe508150UL, 0x00000000UL, 0x3fa7529cUL, 0x2589cacfUL, 0x3e52938aUL,\n+    0x00000000UL, 0x3fa64b10UL, 0xaf6b11f2UL, 0xbe3454cdUL, 0x00000000UL,\n+    0x3fa543e2UL, 0x97506fefUL, 0xbe5fdec5UL, 0x00000000UL, 0x3fa43d10UL,\n+    0xe75f7dd9UL, 0xbe388dd3UL, 0x00000000UL, 0x3fa3369cUL, 0xa4139632UL,\n+    0xbdea5177UL, 0x00000000UL, 0x3fa23086UL, 0x352d6f1eUL, 0xbe565ad6UL,\n+    0x00000000UL, 0x3fa12accUL, 0x77449eb7UL, 0xbe50d5c7UL, 0x00000000UL,\n+    0x3fa0256eUL, 0x7478da78UL, 0x3e404724UL, 0x00000000UL, 0x3f9e40dcUL,\n+    0xf59cef7fUL, 0xbe539d0aUL, 0x00000000UL, 0x3f9c3790UL, 0x1511d43cUL,\n+    0x3e53c2c8UL, 0x00000000UL, 0x3f9a2f00UL, 0x9b8bff3cUL, 0xbe43b3e1UL,\n+    0x00000000UL, 0x3f982724UL, 0xad1e22a5UL, 0x3e46f0bdUL, 0x00000000UL,\n+    0x3f962000UL, 0x130d9356UL, 0x3e475ba0UL, 0x00000000UL, 0x3f941994UL,\n+    0x8f86f883UL, 0xbe513d0bUL, 0x00000000UL, 0x3f9213dcUL, 0x914d0dc8UL,\n+    0xbe534335UL, 0x00000000UL, 0x3f900ed8UL, 0x2d73e5e7UL, 0xbe22ba75UL,\n+    0x00000000UL, 0x3f8c1510UL, 0xc5b7d70eUL, 0x3e599c5dUL, 0x00000000UL,\n+    0x3f880de0UL, 0x8a27857eUL, 0xbe3d28c8UL, 0x00000000UL, 0x3f840810UL,\n+    0xda767328UL, 0x3e531b3dUL, 0x00000000UL, 0x3f8003b0UL, 0x77bacaf3UL,\n+    0xbe5f04e3UL, 0x00000000UL, 0x3f780150UL, 0xdf4b0720UL, 0x3e5a8bffUL,\n+    0x00000000UL, 0x3f6ffc40UL, 0x34c48e71UL, 0xbe3fcd99UL, 0x00000000UL,\n+    0x3f5ff6c0UL, 0x1ad218afUL, 0xbe4c78a7UL, 0x00000000UL, 0x00000000UL,\n+    0x00000000UL, 0x80000000UL\n+};\n+\n+ATTRIBUTE_ALIGNED(8) juint _log2_pow[] = {\n+    0xfefa39efUL, 0x3fe62e42UL, 0xfefa39efUL, 0xbfe62e42UL\n+};\n+\n+ATTRIBUTE_ALIGNED(8) juint _DOUBLE2[] = {\n+    0x00000000UL, 0x40000000UL\n+};\n+\n+ATTRIBUTE_ALIGNED(8) juint _DOUBLE0[] = {\n+    0x00000000UL, 0x00000000UL\n+};\n+\n+ATTRIBUTE_ALIGNED(8) juint _DOUBLE0DOT5[] = {\n+    0x00000000UL, 0x3fe00000UL\n+};\n+\n+#define __ _masm->\n+\n+address StubGenerator::generate_libmPow() {\n+  StubCodeMark mark(this, \"StubRoutines\", \"libmPow\");\n+  address start = __ pc();\n+\n+  Label L_2TAG_PACKET_0_0_2, L_2TAG_PACKET_1_0_2, L_2TAG_PACKET_2_0_2, L_2TAG_PACKET_3_0_2;\n+  Label L_2TAG_PACKET_4_0_2, L_2TAG_PACKET_5_0_2, L_2TAG_PACKET_6_0_2, L_2TAG_PACKET_7_0_2;\n+  Label L_2TAG_PACKET_8_0_2, L_2TAG_PACKET_9_0_2, L_2TAG_PACKET_10_0_2, L_2TAG_PACKET_11_0_2;\n+  Label L_2TAG_PACKET_12_0_2, L_2TAG_PACKET_13_0_2, L_2TAG_PACKET_14_0_2, L_2TAG_PACKET_15_0_2;\n+  Label L_2TAG_PACKET_16_0_2, L_2TAG_PACKET_17_0_2, L_2TAG_PACKET_18_0_2, L_2TAG_PACKET_19_0_2;\n+  Label L_2TAG_PACKET_20_0_2, L_2TAG_PACKET_21_0_2, L_2TAG_PACKET_22_0_2, L_2TAG_PACKET_23_0_2;\n+  Label L_2TAG_PACKET_24_0_2, L_2TAG_PACKET_25_0_2, L_2TAG_PACKET_26_0_2, L_2TAG_PACKET_27_0_2;\n+  Label L_2TAG_PACKET_28_0_2, L_2TAG_PACKET_29_0_2, L_2TAG_PACKET_30_0_2, L_2TAG_PACKET_31_0_2;\n+  Label L_2TAG_PACKET_32_0_2, L_2TAG_PACKET_33_0_2, L_2TAG_PACKET_34_0_2, L_2TAG_PACKET_35_0_2;\n+  Label L_2TAG_PACKET_36_0_2, L_2TAG_PACKET_37_0_2, L_2TAG_PACKET_38_0_2, L_2TAG_PACKET_39_0_2;\n+  Label L_2TAG_PACKET_40_0_2, L_2TAG_PACKET_41_0_2, L_2TAG_PACKET_42_0_2, L_2TAG_PACKET_43_0_2;\n+  Label L_2TAG_PACKET_44_0_2, L_2TAG_PACKET_45_0_2, L_2TAG_PACKET_46_0_2, L_2TAG_PACKET_47_0_2;\n+  Label L_2TAG_PACKET_48_0_2, L_2TAG_PACKET_49_0_2, L_2TAG_PACKET_50_0_2, L_2TAG_PACKET_51_0_2;\n+  Label L_2TAG_PACKET_52_0_2, L_2TAG_PACKET_53_0_2, L_2TAG_PACKET_54_0_2, L_2TAG_PACKET_55_0_2;\n+  Label L_2TAG_PACKET_56_0_2;\n+  Label B1_2, B1_3, B1_5;\n+  Label L_POW;\n+\n+  address HIGHSIGMASK    = (address)_HIGHSIGMASK;\n+  address LOG2_E         = (address)_LOG2_E;\n+  address coeff          = (address)_coeff_pow;\n+  address L_tbl          = (address)_L_tbl_pow;\n+  address HIGHMASK_Y     = (address)_HIGHMASK_Y;\n+  address T_exp          = (address)_T_exp;\n+  address e_coeff        = (address)_e_coeff;\n+  address coeff_h        = (address)_coeff_h;\n+  address HIGHMASK_LOG_X = (address)_HIGHMASK_LOG_X;\n+  address HALFMASK       = (address)_HALFMASK;\n+  address log2           = (address)_log2_pow;\n+  address DOUBLE2        = (address)_DOUBLE2;\n+  address DOUBLE0        = (address)_DOUBLE0;\n+  address DOUBLE0DOT5    = (address)_DOUBLE0DOT5;\n+\n+  __ enter(); \/\/ required for proper stackwalking of RuntimeStub frame\n+\n+  __ subq(rsp, 40);\n+  __ movsd(Address(rsp, 8), xmm0);\n+  __ movsd(Address(rsp, 16), xmm1);\n+\n+  \/\/ Special case: pow(x, 2.0) => x * x\n+  __ movdq(r8, xmm1);\n+  __ cmp64(r8, ExternalAddress(DOUBLE2), r9 \/*rscratch*\/);\n+  __ jccb(Assembler::notEqual, B1_2);\n+  __ mulsd(xmm0, xmm0);\n+  __ jmp(B1_5);\n+\n+  \/\/ Special case: pow(x, 0.5) => sqrt(x)\n+  __ bind(B1_2);\n+  __ cmp64(r8, ExternalAddress(DOUBLE0DOT5), r9 \/*rscratch*\/);\n+  __ jccb(Assembler::notEqual, L_POW); \/\/ For pow(x, y), check whether y == 0.5\n+  __ movdq(r9, xmm0);\n+  __ cmp64(r9, ExternalAddress(DOUBLE0), r10 \/*rscratch*\/);\n+  __ jccb(Assembler::less, L_POW); \/\/ pow(x, 0.5) => sqrt(x) only for x >= 0.0 or x is +inf\/NaN\n+  __ sqrtsd(xmm0, xmm0);\n+  __ jmp(B1_5);\n+\n+  __ bind(L_POW);\n+  __ pextrw(rax, xmm0, 3);\n+  __ xorpd(xmm2, xmm2);\n+  __ mov64(r9, 0x3ff0000000000000);\n+  __ movdq(xmm2, r9);\n+  __ movl(r8, 1069088768);\n+  __ movdq(xmm7, r8);\n+  __ xorpd(xmm1, xmm1);\n+  __ mov64(r10, 0x77f0000000000000);\n+  __ movdq(xmm1, r10);\n+  __ movdqu(xmm3, xmm0);\n+  __ movl(rdx, 32752);\n+  __ andl(rdx, rax);\n+  __ subl(rdx, 16368);\n+  __ movl(rcx, rdx);\n+  __ sarl(rdx, 31);\n+  __ addl(rcx, rdx);\n+  __ xorl(rcx, rdx);\n+  __ por(xmm0, xmm2);\n+  __ movdqu(xmm6, ExternalAddress(HIGHSIGMASK), r9 \/*rscratch*\/);    \/\/0x00000000UL, 0xfffff800UL, 0x00000000UL, 0xfffff800UL\n+  __ psrlq(xmm0, 27);\n+  __ movq(xmm2, ExternalAddress(LOG2_E), r9 \/*rscratch*\/);    \/\/0x00000000UL, 0x3ff72000UL, 0x161bb241UL, 0xbf5dabe1UL\n+  __ psrld(xmm0, 2);\n+  __ addl(rcx, 16);\n+  __ bsrl(rcx, rcx);\n+  __ rcpps(xmm0, xmm0);\n+  __ psllq(xmm3, 12);\n+  __ movl(r11, 8192);\n+  __ movdq(xmm4, r11);\n+  __ psrlq(xmm3, 12);\n+  __ subl(rax, 16);\n+  __ cmpl(rax, 32736);\n+  __ jcc(Assembler::aboveEqual, L_2TAG_PACKET_0_0_2);\n+  __ movl(r8, 0);\n+\n+  __ bind(L_2TAG_PACKET_1_0_2);\n+  __ mulss(xmm0, xmm7);\n+  __ movl(rdx, -1);\n+  __ subl(rcx, 4);\n+  __ shll(rdx);\n+  __ shlq(rdx, 32);\n+  __ movdq(xmm5, rdx);\n+  __ por(xmm3, xmm1);\n+  __ subl(rax, 16351);\n+  __ cmpl(rax, 1);\n+  __ jcc(Assembler::belowEqual, L_2TAG_PACKET_2_0_2);\n+  __ paddd(xmm0, xmm4);\n+  __ pand(xmm5, xmm3);\n+  __ movdl(rdx, xmm0);\n+  __ psllq(xmm0, 29);\n+\n+  __ bind(L_2TAG_PACKET_3_0_2);\n+  __ subsd(xmm3, xmm5);\n+  __ pand(xmm0, xmm6);\n+  __ subl(rax, 1);\n+  __ sarl(rax, 4);\n+  __ cvtsi2sdl(xmm7, rax);\n+  __ mulpd(xmm5, xmm0);\n+\n+  __ bind(L_2TAG_PACKET_4_0_2);\n+  __ mulsd(xmm3, xmm0);\n+  __ movdqu(xmm1, ExternalAddress(coeff), r9 \/*rscratch*\/);    \/\/0x6dc96112UL, 0xbf836578UL, 0xee241472UL, 0xbf9b0301UL\n+  __ lea(r11, ExternalAddress(L_tbl));\n+  __ subsd(xmm5, xmm2);\n+  __ movdqu(xmm4, ExternalAddress(coeff + 16), r9 \/*rscratch*\/);    \/\/0x9f95985aUL, 0xbfb528dbUL, 0xb3841d2aUL, 0xbfd619b6UL\n+  __ movl(rcx, rax);\n+  __ sarl(rax, 31);\n+  __ addl(rcx, rax);\n+  __ xorl(rax, rcx);\n+  __ addl(rax, 1);\n+  __ bsrl(rax, rax);\n+  __ unpcklpd(xmm5, xmm3);\n+  __ movdqu(xmm6, ExternalAddress(coeff + 32), r9 \/*rscratch*\/);    \/\/0x518775e3UL, 0x3f9004f2UL, 0xac8349bbUL, 0x3fa76c9bUL\n+  __ addsd(xmm3, xmm5);\n+  __ andl(rdx, 16760832);\n+  __ shrl(rdx, 10);\n+  __ addpd(xmm5, Address(r11, rdx, Address::times_1, -3648));\n+  __ movdqu(xmm0, ExternalAddress(coeff + 48), r9 \/*rscratch*\/);    \/\/0x486ececcUL, 0x3fc4635eUL, 0x161bb241UL, 0xbf5dabe1UL\n+  __ pshufd(xmm2, xmm3, 68);\n+  __ mulsd(xmm3, xmm3);\n+  __ mulpd(xmm1, xmm2);\n+  __ mulpd(xmm4, xmm2);\n+  __ addsd(xmm5, xmm7);\n+  __ mulsd(xmm2, xmm3);\n+  __ addpd(xmm6, xmm1);\n+  __ mulsd(xmm3, xmm3);\n+  __ addpd(xmm0, xmm4);\n+  __ movq(xmm1, Address(rsp, 16));\n+  __ movw(rcx, Address(rsp, 22));\n+  __ pshufd(xmm7, xmm5, 238);\n+  __ movq(xmm4, ExternalAddress(HIGHMASK_Y), r9 \/*rscratch*\/);    \/\/0x00000000UL, 0xfffffff8UL, 0x00000000UL, 0xffffffffUL\n+  __ mulpd(xmm6, xmm2);\n+  __ pshufd(xmm3, xmm3, 68);\n+  __ mulpd(xmm0, xmm2);\n+  __ shll(rax, 4);\n+  __ subl(rax, 15872);\n+  __ andl(rcx, 32752);\n+  __ addl(rax, rcx);\n+  __ mulpd(xmm3, xmm6);\n+  __ cmpl(rax, 624);\n+  __ jcc(Assembler::aboveEqual, L_2TAG_PACKET_5_0_2);\n+  __ xorpd(xmm6, xmm6);\n+  __ movl(rdx, 17080);\n+  __ pinsrw(xmm6, rdx, 3);\n+  __ movdqu(xmm2, xmm1);\n+  __ pand(xmm4, xmm1);\n+  __ subsd(xmm1, xmm4);\n+  __ mulsd(xmm4, xmm5);\n+  __ addsd(xmm0, xmm7);\n+  __ mulsd(xmm1, xmm5);\n+  __ movdqu(xmm7, xmm6);\n+  __ addsd(xmm6, xmm4);\n+  __ lea(r11, ExternalAddress(T_exp));\n+  __ addpd(xmm3, xmm0);\n+  __ movdl(rdx, xmm6);\n+  __ subsd(xmm6, xmm7);\n+  __ pshufd(xmm0, xmm3, 238);\n+  __ subsd(xmm4, xmm6);\n+  __ addsd(xmm0, xmm3);\n+  __ movl(rcx, rdx);\n+  __ andl(rdx, 255);\n+  __ addl(rdx, rdx);\n+  __ movdqu(xmm5, Address(r11, rdx, Address::times_8, 0));\n+  __ addsd(xmm4, xmm1);\n+  __ mulsd(xmm2, xmm0);\n+  __ movdqu(xmm7, ExternalAddress(e_coeff),      r9 \/*rscratch*\/);    \/\/0xe78a6731UL, 0x3f55d87fUL, 0xd704a0c0UL, 0x3fac6b08UL\n+  __ movdqu(xmm3, ExternalAddress(e_coeff + 16), r9 \/*rscratch*\/);    \/\/0x6fba4e77UL, 0x3f83b2abUL, 0xff82c58fUL, 0x3fcebfbdUL\n+  __ shll(rcx, 12);\n+  __ xorl(rcx, r8);\n+  __ andl(rcx, -1048576);\n+  __ movdq(xmm6, rcx);\n+  __ addsd(xmm2, xmm4);\n+  __ mov64(r9, 0x3fe62e42fefa39ef);\n+  __ movdq(xmm1, r9);\n+  __ pshufd(xmm0, xmm2, 68);\n+  __ pshufd(xmm4, xmm2, 68);\n+  __ mulsd(xmm1, xmm2);\n+  __ pshufd(xmm6, xmm6, 17);\n+  __ mulpd(xmm0, xmm0);\n+  __ mulpd(xmm7, xmm4);\n+  __ paddd(xmm5, xmm6);\n+  __ mulsd(xmm1, xmm5);\n+  __ pshufd(xmm6, xmm5, 238);\n+  __ mulsd(xmm0, xmm0);\n+  __ addpd(xmm3, xmm7);\n+  __ addsd(xmm1, xmm6);\n+  __ mulpd(xmm0, xmm3);\n+  __ pshufd(xmm3, xmm0, 238);\n+  __ mulsd(xmm0, xmm5);\n+  __ mulsd(xmm3, xmm5);\n+  __ addsd(xmm0, xmm1);\n+  __ addsd(xmm0, xmm3);\n+  __ addsd(xmm0, xmm5);\n+  __ jmp(B1_5);\n+\n+  __ bind(L_2TAG_PACKET_0_0_2);\n+  __ addl(rax, 16);\n+  __ movl(rdx, 32752);\n+  __ andl(rdx, rax);\n+  __ cmpl(rdx, 32752);\n+  __ jcc(Assembler::equal, L_2TAG_PACKET_6_0_2);\n+  __ testl(rax, 32768);\n+  __ jcc(Assembler::notEqual, L_2TAG_PACKET_7_0_2);\n+\n+  __ bind(L_2TAG_PACKET_8_0_2);\n+  __ movq(xmm0, Address(rsp, 8));\n+  __ movq(xmm3, Address(rsp, 8));\n+  __ movdl(rdx, xmm3);\n+  __ psrlq(xmm3, 32);\n+  __ movdl(rcx, xmm3);\n+  __ orl(rdx, rcx);\n+  __ cmpl(rdx, 0);\n+  __ jcc(Assembler::equal, L_2TAG_PACKET_9_0_2);\n+  __ xorpd(xmm3, xmm3);\n+  __ movl(rax, 18416);\n+  __ pinsrw(xmm3, rax, 3);\n+  __ mulsd(xmm0, xmm3);\n+  __ xorpd(xmm2, xmm2);\n+  __ movl(rax, 16368);\n+  __ pinsrw(xmm2, rax, 3);\n+  __ movdqu(xmm3, xmm0);\n+  __ pextrw(rax, xmm0, 3);\n+  __ por(xmm0, xmm2);\n+  __ movl(rcx, 18416);\n+  __ psrlq(xmm0, 27);\n+  __ movq(xmm2, ExternalAddress(LOG2_E), r9 \/*rscratch*\/);    \/\/0x00000000UL, 0x3ff72000UL, 0x161bb241UL, 0xbf5dabe1UL\n+  __ psrld(xmm0, 2);\n+  __ rcpps(xmm0, xmm0);\n+  __ psllq(xmm3, 12);\n+  __ movdqu(xmm6, ExternalAddress(HIGHSIGMASK), r9 \/*rscratch*\/);    \/\/0x00000000UL, 0xfffff800UL, 0x00000000UL, 0xfffff800UL\n+  __ psrlq(xmm3, 12);\n+  __ mulss(xmm0, xmm7);\n+  __ movl(rdx, -1024);\n+  __ movdl(xmm5, rdx);\n+  __ por(xmm3, xmm1);\n+  __ paddd(xmm0, xmm4);\n+  __ psllq(xmm5, 32);\n+  __ movdl(rdx, xmm0);\n+  __ psllq(xmm0, 29);\n+  __ pand(xmm5, xmm3);\n+  __ movl(r8, 0);\n+  __ pand(xmm0, xmm6);\n+  __ subsd(xmm3, xmm5);\n+  __ andl(rax, 32752);\n+  __ subl(rax, 18416);\n+  __ sarl(rax, 4);\n+  __ cvtsi2sdl(xmm7, rax);\n+  __ mulpd(xmm5, xmm0);\n+  __ jmp(L_2TAG_PACKET_4_0_2);\n+\n+  __ bind(L_2TAG_PACKET_10_0_2);\n+  __ movq(xmm0, Address(rsp, 8));\n+  __ movq(xmm3, Address(rsp, 8));\n+  __ movdl(rdx, xmm3);\n+  __ psrlq(xmm3, 32);\n+  __ movdl(rcx, xmm3);\n+  __ orl(rdx, rcx);\n+  __ cmpl(rdx, 0);\n+  __ jcc(Assembler::equal, L_2TAG_PACKET_9_0_2);\n+  __ xorpd(xmm3, xmm3);\n+  __ movl(rax, 18416);\n+  __ pinsrw(xmm3, rax, 3);\n+  __ mulsd(xmm0, xmm3);\n+  __ xorpd(xmm2, xmm2);\n+  __ movl(rax, 16368);\n+  __ pinsrw(xmm2, rax, 3);\n+  __ movdqu(xmm3, xmm0);\n+  __ pextrw(rax, xmm0, 3);\n+  __ por(xmm0, xmm2);\n+  __ movl(rcx, 18416);\n+  __ psrlq(xmm0, 27);\n+  __ movq(xmm2, ExternalAddress(LOG2_E), r9 \/*rscratch*\/);    \/\/0x00000000UL, 0x3ff72000UL, 0x161bb241UL, 0xbf5dabe1UL\n+  __ psrld(xmm0, 2);\n+  __ rcpps(xmm0, xmm0);\n+  __ psllq(xmm3, 12);\n+  __ movdqu(xmm6, ExternalAddress(HIGHSIGMASK), r9 \/*rscratch*\/);    \/\/0x00000000UL, 0xfffff800UL, 0x00000000UL, 0xfffff800UL\n+  __ psrlq(xmm3, 12);\n+  __ mulss(xmm0, xmm7);\n+  __ movl(rdx, -1024);\n+  __ movdl(xmm5, rdx);\n+  __ por(xmm3, xmm1);\n+  __ paddd(xmm0, xmm4);\n+  __ psllq(xmm5, 32);\n+  __ movdl(rdx, xmm0);\n+  __ psllq(xmm0, 29);\n+  __ pand(xmm5, xmm3);\n+  __ movl(r8, INT_MIN);\n+  __ pand(xmm0, xmm6);\n+  __ subsd(xmm3, xmm5);\n+  __ andl(rax, 32752);\n+  __ subl(rax, 18416);\n+  __ sarl(rax, 4);\n+  __ cvtsi2sdl(xmm7, rax);\n+  __ mulpd(xmm5, xmm0);\n+  __ jmp(L_2TAG_PACKET_4_0_2);\n+\n+  __ bind(L_2TAG_PACKET_5_0_2);\n+  __ cmpl(rax, 0);\n+  __ jcc(Assembler::less, L_2TAG_PACKET_11_0_2);\n+  __ cmpl(rax, 752);\n+  __ jcc(Assembler::aboveEqual, L_2TAG_PACKET_12_0_2);\n+  __ addsd(xmm0, xmm7);\n+  __ movq(xmm2, ExternalAddress(HALFMASK), r9 \/*rscratch*\/);    \/\/0xf8000000UL, 0xffffffffUL, 0xf8000000UL, 0xffffffffUL\n+  __ addpd(xmm3, xmm0);\n+  __ xorpd(xmm6, xmm6);\n+  __ movl(rax, 17080);\n+  __ pinsrw(xmm6, rax, 3);\n+  __ pshufd(xmm0, xmm3, 238);\n+  __ addsd(xmm0, xmm3);\n+  __ movdqu(xmm3, xmm5);\n+  __ addsd(xmm5, xmm0);\n+  __ movdqu(xmm4, xmm2);\n+  __ subsd(xmm3, xmm5);\n+  __ movdqu(xmm7, xmm5);\n+  __ pand(xmm5, xmm2);\n+  __ movdqu(xmm2, xmm1);\n+  __ pand(xmm4, xmm1);\n+  __ subsd(xmm7, xmm5);\n+  __ addsd(xmm0, xmm3);\n+  __ subsd(xmm1, xmm4);\n+  __ mulsd(xmm4, xmm5);\n+  __ addsd(xmm0, xmm7);\n+  __ mulsd(xmm2, xmm0);\n+  __ movdqu(xmm7, xmm6);\n+  __ mulsd(xmm1, xmm5);\n+  __ addsd(xmm6, xmm4);\n+  __ movdl(rax, xmm6);\n+  __ subsd(xmm6, xmm7);\n+  __ lea(r11, ExternalAddress(T_exp));\n+  __ addsd(xmm2, xmm1);\n+  __ movdqu(xmm7, ExternalAddress(e_coeff +  0), r9 \/*rscratch*\/);    \/\/0xe78a6731UL, 0x3f55d87fUL, 0xd704a0c0UL, 0x3fac6b08UL\n+  __ movdqu(xmm3, ExternalAddress(e_coeff + 16), r9 \/*rscratch*\/);    \/\/0x6fba4e77UL, 0x3f83b2abUL, 0xff82c58fUL, 0x3fcebfbdUL\n+  __ subsd(xmm4, xmm6);\n+  __ pextrw(rdx, xmm6, 3);\n+  __ movl(rcx, rax);\n+  __ andl(rax, 255);\n+  __ addl(rax, rax);\n+  __ movdqu(xmm5, Address(r11, rax, Address::times_8, 0));\n+  __ addsd(xmm2, xmm4);\n+  __ sarl(rcx, 8);\n+  __ movl(rax, rcx);\n+  __ sarl(rcx, 1);\n+  __ subl(rax, rcx);\n+  __ shll(rcx, 20);\n+  __ xorl(rcx, r8);\n+  __ movdl(xmm6, rcx);\n+  __ movq(xmm1, ExternalAddress(e_coeff + 32), r9 \/*rscratch*\/);    \/\/0xfefa39efUL, 0x3fe62e42UL, 0x00000000UL, 0x00000000UL\n+  __ andl(rdx, 32767);\n+  __ cmpl(rdx, 16529);\n+  __ jcc(Assembler::above, L_2TAG_PACKET_12_0_2);\n+  __ pshufd(xmm0, xmm2, 68);\n+  __ pshufd(xmm4, xmm2, 68);\n+  __ mulpd(xmm0, xmm0);\n+  __ mulpd(xmm7, xmm4);\n+  __ pshufd(xmm6, xmm6, 17);\n+  __ mulsd(xmm1, xmm2);\n+  __ mulsd(xmm0, xmm0);\n+  __ paddd(xmm5, xmm6);\n+  __ addpd(xmm3, xmm7);\n+  __ mulsd(xmm1, xmm5);\n+  __ pshufd(xmm6, xmm5, 238);\n+  __ mulpd(xmm0, xmm3);\n+  __ addsd(xmm1, xmm6);\n+  __ pshufd(xmm3, xmm0, 238);\n+  __ mulsd(xmm0, xmm5);\n+  __ mulsd(xmm3, xmm5);\n+  __ shll(rax, 4);\n+  __ xorpd(xmm4, xmm4);\n+  __ addl(rax, 16368);\n+  __ pinsrw(xmm4, rax, 3);\n+  __ addsd(xmm0, xmm1);\n+  __ addsd(xmm0, xmm3);\n+  __ movdqu(xmm1, xmm0);\n+  __ addsd(xmm0, xmm5);\n+  __ mulsd(xmm0, xmm4);\n+  __ pextrw(rax, xmm0, 3);\n+  __ andl(rax, 32752);\n+  __ jcc(Assembler::equal, L_2TAG_PACKET_13_0_2);\n+  __ cmpl(rax, 32752);\n+  __ jcc(Assembler::equal, L_2TAG_PACKET_14_0_2);\n+  __ jmp(B1_5);\n+\n+  __ bind(L_2TAG_PACKET_6_0_2);\n+  __ movq(xmm1, Address(rsp, 16));\n+  __ movq(xmm0, Address(rsp, 8));\n+  __ movdqu(xmm2, xmm0);\n+  __ movdl(rax, xmm2);\n+  __ psrlq(xmm2, 20);\n+  __ movdl(rdx, xmm2);\n+  __ orl(rax, rdx);\n+  __ jcc(Assembler::equal, L_2TAG_PACKET_15_0_2);\n+  __ movdl(rax, xmm1);\n+  __ psrlq(xmm1, 32);\n+  __ movdl(rdx, xmm1);\n+  __ movl(rcx, rdx);\n+  __ addl(rdx, rdx);\n+  __ orl(rax, rdx);\n+  __ jcc(Assembler::equal, L_2TAG_PACKET_16_0_2);\n+  __ addsd(xmm0, xmm0);\n+  __ jmp(B1_5);\n+\n+  __ bind(L_2TAG_PACKET_16_0_2);\n+  __ xorpd(xmm0, xmm0);\n+  __ movl(rax, 16368);\n+  __ pinsrw(xmm0, rax, 3);\n+  __ movl(Address(rsp, 0), 29);\n+  __ jmp(L_2TAG_PACKET_17_0_2);\n+\n+  __ bind(L_2TAG_PACKET_18_0_2);\n+  __ movq(xmm0, Address(rsp, 16));\n+  __ addpd(xmm0, xmm0);\n+  __ jmp(B1_5);\n+\n+  __ bind(L_2TAG_PACKET_15_0_2);\n+  __ movdl(rax, xmm1);\n+  __ movdqu(xmm2, xmm1);\n+  __ psrlq(xmm1, 32);\n+  __ movdl(rdx, xmm1);\n+  __ movl(rcx, rdx);\n+  __ addl(rdx, rdx);\n+  __ orl(rax, rdx);\n+  __ jcc(Assembler::equal, L_2TAG_PACKET_19_0_2);\n+  __ pextrw(rax, xmm2, 3);\n+  __ andl(rax, 32752);\n+  __ cmpl(rax, 32752);\n+  __ jcc(Assembler::notEqual, L_2TAG_PACKET_20_0_2);\n+  __ movdl(rax, xmm2);\n+  __ psrlq(xmm2, 20);\n+  __ movdl(rdx, xmm2);\n+  __ orl(rax, rdx);\n+  __ jcc(Assembler::notEqual, L_2TAG_PACKET_18_0_2);\n+\n+  __ bind(L_2TAG_PACKET_20_0_2);\n+  __ pextrw(rax, xmm0, 3);\n+  __ testl(rax, 32768);\n+  __ jcc(Assembler::notEqual, L_2TAG_PACKET_21_0_2);\n+  __ testl(rcx, INT_MIN);\n+  __ jcc(Assembler::notEqual, L_2TAG_PACKET_22_0_2);\n+  __ jmp(B1_5);\n+\n+  __ bind(L_2TAG_PACKET_23_0_2);\n+  __ movq(xmm1, Address(rsp, 16));\n+  __ movdl(rax, xmm1);\n+  __ testl(rax, 1);\n+  __ jcc(Assembler::notEqual, L_2TAG_PACKET_24_0_2);\n+  __ testl(rax, 2);\n+  __ jcc(Assembler::notEqual, L_2TAG_PACKET_25_0_2);\n+  __ jmp(L_2TAG_PACKET_24_0_2);\n+\n+  __ bind(L_2TAG_PACKET_21_0_2);\n+  __ shrl(rcx, 20);\n+  __ andl(rcx, 2047);\n+  __ cmpl(rcx, 1075);\n+  __ jcc(Assembler::above, L_2TAG_PACKET_24_0_2);\n+  __ jcc(Assembler::equal, L_2TAG_PACKET_26_0_2);\n+  __ cmpl(rcx, 1074);\n+  __ jcc(Assembler::above, L_2TAG_PACKET_23_0_2);\n+  __ cmpl(rcx, 1023);\n+  __ jcc(Assembler::below, L_2TAG_PACKET_24_0_2);\n+  __ movq(xmm1, Address(rsp, 16));\n+  __ movl(rax, 17208);\n+  __ xorpd(xmm3, xmm3);\n+  __ pinsrw(xmm3, rax, 3);\n+  __ movdqu(xmm4, xmm3);\n+  __ addsd(xmm3, xmm1);\n+  __ subsd(xmm4, xmm3);\n+  __ addsd(xmm1, xmm4);\n+  __ pextrw(rax, xmm1, 3);\n+  __ andl(rax, 32752);\n+  __ jcc(Assembler::notEqual, L_2TAG_PACKET_24_0_2);\n+  __ movdl(rax, xmm3);\n+  __ andl(rax, 1);\n+  __ jcc(Assembler::equal, L_2TAG_PACKET_24_0_2);\n+\n+  __ bind(L_2TAG_PACKET_25_0_2);\n+  __ movq(xmm1, Address(rsp, 16));\n+  __ pextrw(rax, xmm1, 3);\n+  __ andl(rax, 32768);\n+  __ jcc(Assembler::notEqual, L_2TAG_PACKET_27_0_2);\n+  __ jmp(B1_5);\n+\n+  __ bind(L_2TAG_PACKET_27_0_2);\n+  __ xorpd(xmm0, xmm0);\n+  __ movl(rax, 32768);\n+  __ pinsrw(xmm0, rax, 3);\n+  __ jmp(B1_5);\n+\n+  __ bind(L_2TAG_PACKET_24_0_2);\n+  __ movq(xmm1, Address(rsp, 16));\n+  __ pextrw(rax, xmm1, 3);\n+  __ andl(rax, 32768);\n+  __ jcc(Assembler::notEqual, L_2TAG_PACKET_22_0_2);\n+  __ xorpd(xmm0, xmm0);\n+  __ movl(rax, 32752);\n+  __ pinsrw(xmm0, rax, 3);\n+  __ jmp(B1_5);\n+\n+  __ bind(L_2TAG_PACKET_26_0_2);\n+  __ movq(xmm1, Address(rsp, 16));\n+  __ movdl(rax, xmm1);\n+  __ andl(rax, 1);\n+  __ jcc(Assembler::equal, L_2TAG_PACKET_24_0_2);\n+  __ jmp(L_2TAG_PACKET_25_0_2);\n+\n+  __ bind(L_2TAG_PACKET_28_0_2);\n+  __ movdl(rax, xmm1);\n+  __ psrlq(xmm1, 20);\n+  __ movdl(rdx, xmm1);\n+  __ orl(rax, rdx);\n+  __ jcc(Assembler::equal, L_2TAG_PACKET_29_0_2);\n+  __ movq(xmm0, Address(rsp, 16));\n+  __ addsd(xmm0, xmm0);\n+  __ jmp(B1_5);\n+\n+  __ bind(L_2TAG_PACKET_29_0_2);\n+  __ movq(xmm0, Address(rsp, 8));\n+  __ pextrw(rax, xmm0, 3);\n+  __ cmpl(rax, 49136);\n+  __ jcc(Assembler::notEqual, L_2TAG_PACKET_30_0_2);\n+  __ movdl(rcx, xmm0);\n+  __ psrlq(xmm0, 20);\n+  __ movdl(rdx, xmm0);\n+  __ orl(rcx, rdx);\n+  __ jcc(Assembler::notEqual, L_2TAG_PACKET_30_0_2);\n+  __ xorpd(xmm0, xmm0);\n+  __ movl(rax, 32760);\n+  __ pinsrw(xmm0, rax, 3);\n+  __ jmp(B1_5);\n+\n+  __ bind(L_2TAG_PACKET_30_0_2);\n+  __ movq(xmm1, Address(rsp, 16));\n+  __ andl(rax, 32752);\n+  __ subl(rax, 16368);\n+  __ pextrw(rdx, xmm1, 3);\n+  __ xorpd(xmm0, xmm0);\n+  __ xorl(rax, rdx);\n+  __ andl(rax, 32768);\n+  __ jcc(Assembler::equal, L_2TAG_PACKET_31_0_2);\n+  __ jmp(B1_5);\n+\n+  __ bind(L_2TAG_PACKET_31_0_2);\n+  __ movl(rcx, 32752);\n+  __ pinsrw(xmm0, rcx, 3);\n+  __ jmp(B1_5);\n+\n+  __ bind(L_2TAG_PACKET_32_0_2);\n+  __ movdl(rax, xmm1);\n+  __ cmpl(rdx, 17184);\n+  __ jcc(Assembler::above, L_2TAG_PACKET_33_0_2);\n+  __ testl(rax, 1);\n+  __ jcc(Assembler::notEqual, L_2TAG_PACKET_34_0_2);\n+  __ testl(rax, 2);\n+  __ jcc(Assembler::equal, L_2TAG_PACKET_35_0_2);\n+  __ jmp(L_2TAG_PACKET_36_0_2);\n+\n+  __ bind(L_2TAG_PACKET_33_0_2);\n+  __ testl(rax, 1);\n+  __ jcc(Assembler::equal, L_2TAG_PACKET_35_0_2);\n+  __ jmp(L_2TAG_PACKET_36_0_2);\n+\n+  __ bind(L_2TAG_PACKET_7_0_2);\n+  __ movq(xmm2, Address(rsp, 8));\n+  __ movdl(rax, xmm2);\n+  __ psrlq(xmm2, 31);\n+  __ movdl(rcx, xmm2);\n+  __ orl(rax, rcx);\n+  __ jcc(Assembler::equal, L_2TAG_PACKET_9_0_2);\n+  __ movq(xmm1, Address(rsp, 16));\n+  __ pextrw(rdx, xmm1, 3);\n+  __ movdl(rax, xmm1);\n+  __ movdqu(xmm2, xmm1);\n+  __ psrlq(xmm2, 32);\n+  __ movdl(rcx, xmm2);\n+  __ addl(rcx, rcx);\n+  __ orl(rcx, rax);\n+  __ jcc(Assembler::equal, L_2TAG_PACKET_37_0_2);\n+  __ andl(rdx, 32752);\n+  __ cmpl(rdx, 32752);\n+  __ jcc(Assembler::equal, L_2TAG_PACKET_28_0_2);\n+  __ cmpl(rdx, 17200);\n+  __ jcc(Assembler::above, L_2TAG_PACKET_35_0_2);\n+  __ cmpl(rdx, 17184);\n+  __ jcc(Assembler::aboveEqual, L_2TAG_PACKET_32_0_2);\n+  __ cmpl(rdx, 16368);\n+  __ jcc(Assembler::below, L_2TAG_PACKET_34_0_2);\n+  __ movl(rax, 17208);\n+  __ xorpd(xmm2, xmm2);\n+  __ pinsrw(xmm2, rax, 3);\n+  __ movdqu(xmm4, xmm2);\n+  __ addsd(xmm2, xmm1);\n+  __ subsd(xmm4, xmm2);\n+  __ addsd(xmm1, xmm4);\n+  __ pextrw(rax, xmm1, 3);\n+  __ andl(rax, 32767);\n+  __ jcc(Assembler::notEqual, L_2TAG_PACKET_34_0_2);\n+  __ movdl(rax, xmm2);\n+  __ andl(rax, 1);\n+  __ jcc(Assembler::equal, L_2TAG_PACKET_35_0_2);\n+\n+  __ bind(L_2TAG_PACKET_36_0_2);\n+  __ xorpd(xmm1, xmm1);\n+  __ movl(rdx, 30704);\n+  __ pinsrw(xmm1, rdx, 3);\n+  __ movq(xmm2, ExternalAddress(LOG2_E), r9 \/*rscratch*\/);    \/\/0x00000000UL, 0x3ff72000UL, 0x161bb241UL, 0xbf5dabe1UL\n+  __ movq(xmm4, Address(rsp, 8));\n+  __ pextrw(rax, xmm4, 3);\n+  __ movl(rdx, 8192);\n+  __ movdl(xmm4, rdx);\n+  __ andl(rax, 32767);\n+  __ subl(rax, 16);\n+  __ jcc(Assembler::less, L_2TAG_PACKET_10_0_2);\n+  __ movl(rdx, rax);\n+  __ andl(rdx, 32752);\n+  __ subl(rdx, 16368);\n+  __ movl(rcx, rdx);\n+  __ sarl(rdx, 31);\n+  __ addl(rcx, rdx);\n+  __ xorl(rcx, rdx);\n+  __ addl(rcx, 16);\n+  __ bsrl(rcx, rcx);\n+  __ movl(r8, INT_MIN);\n+  __ jmp(L_2TAG_PACKET_1_0_2);\n+\n+  __ bind(L_2TAG_PACKET_34_0_2);\n+  __ xorpd(xmm1, xmm1);\n+  __ movl(rax, 32752);\n+  __ pinsrw(xmm1, rax, 3);\n+  __ xorpd(xmm0, xmm0);\n+  __ mulsd(xmm0, xmm1);\n+  __ movl(Address(rsp, 0), 28);\n+  __ jmp(L_2TAG_PACKET_17_0_2);\n+\n+  __ bind(L_2TAG_PACKET_35_0_2);\n+  __ xorpd(xmm1, xmm1);\n+  __ movl(rdx, 30704);\n+  __ pinsrw(xmm1, rdx, 3);\n+  __ movq(xmm2, ExternalAddress(LOG2_E), r9 \/*rscratch*\/);    \/\/0x00000000UL, 0x3ff72000UL, 0x161bb241UL, 0xbf5dabe1UL\n+  __ movq(xmm4, Address(rsp, 8));\n+  __ pextrw(rax, xmm4, 3);\n+  __ movl(rdx, 8192);\n+  __ movdl(xmm4, rdx);\n+  __ andl(rax, 32767);\n+  __ subl(rax, 16);\n+  __ jcc(Assembler::less, L_2TAG_PACKET_8_0_2);\n+  __ movl(rdx, rax);\n+  __ andl(rdx, 32752);\n+  __ subl(rdx, 16368);\n+  __ movl(rcx, rdx);\n+  __ sarl(rdx, 31);\n+  __ addl(rcx, rdx);\n+  __ xorl(rcx, rdx);\n+  __ addl(rcx, 16);\n+  __ bsrl(rcx, rcx);\n+  __ movl(r8, 0);\n+  __ jmp(L_2TAG_PACKET_1_0_2);\n+\n+  __ bind(L_2TAG_PACKET_19_0_2);\n+  __ xorpd(xmm0, xmm0);\n+  __ movl(rax, 16368);\n+  __ pinsrw(xmm0, rax, 3);\n+  __ jmp(B1_5);\n+\n+  __ bind(L_2TAG_PACKET_22_0_2);\n+  __ xorpd(xmm0, xmm0);\n+  __ jmp(B1_5);\n+\n+  __ bind(L_2TAG_PACKET_11_0_2);\n+  __ addl(rax, 384);\n+  __ cmpl(rax, 0);\n+  __ jcc(Assembler::less, L_2TAG_PACKET_38_0_2);\n+  __ mulsd(xmm5, xmm1);\n+  __ addsd(xmm0, xmm7);\n+  __ shrl(r8, 31);\n+  __ addpd(xmm3, xmm0);\n+  __ pshufd(xmm0, xmm3, 238);\n+  __ addsd(xmm3, xmm0);\n+  __ lea(r11, ExternalAddress(log2));    \/\/0xfefa39efUL, 0x3fe62e42UL, 0xfefa39efUL, 0xbfe62e42UL\n+  __ movq(xmm4, Address(r11, r8, Address::times_8, 0));\n+  __ mulsd(xmm1, xmm3);\n+  __ xorpd(xmm0, xmm0);\n+  __ movl(rax, 16368);\n+  __ shll(r8, 15);\n+  __ orl(rax, r8);\n+  __ pinsrw(xmm0, rax, 3);\n+  __ addsd(xmm5, xmm1);\n+  __ mulsd(xmm5, xmm4);\n+  __ addsd(xmm0, xmm5);\n+  __ jmp(B1_5);\n+\n+  __ bind(L_2TAG_PACKET_38_0_2);\n+\n+  __ bind(L_2TAG_PACKET_37_0_2);\n+  __ xorpd(xmm0, xmm0);\n+  __ movl(rax, 16368);\n+  __ pinsrw(xmm0, rax, 3);\n+  __ jmp(B1_5);\n+\n+  __ bind(L_2TAG_PACKET_39_0_2);\n+  __ xorpd(xmm0, xmm0);\n+  __ movl(rax, 16368);\n+  __ pinsrw(xmm0, rax, 3);\n+  __ movl(Address(rsp, 0), 26);\n+  __ jmp(L_2TAG_PACKET_17_0_2);\n+\n+  __ bind(L_2TAG_PACKET_9_0_2);\n+  __ movq(xmm1, Address(rsp, 16));\n+  __ movdqu(xmm2, xmm1);\n+  __ pextrw(rax, xmm1, 3);\n+  __ andl(rax, 32752);\n+  __ cmpl(rax, 32752);\n+  __ jcc(Assembler::notEqual, L_2TAG_PACKET_40_0_2);\n+  __ movdl(rax, xmm2);\n+  __ psrlq(xmm2, 20);\n+  __ movdl(rdx, xmm2);\n+  __ orl(rax, rdx);\n+  __ jcc(Assembler::notEqual, L_2TAG_PACKET_18_0_2);\n+\n+  __ bind(L_2TAG_PACKET_40_0_2);\n+  __ movdl(rax, xmm1);\n+  __ psrlq(xmm1, 32);\n+  __ movdl(rdx, xmm1);\n+  __ movl(rcx, rdx);\n+  __ addl(rdx, rdx);\n+  __ orl(rax, rdx);\n+  __ jcc(Assembler::equal, L_2TAG_PACKET_39_0_2);\n+  __ shrl(rdx, 21);\n+  __ cmpl(rdx, 1075);\n+  __ jcc(Assembler::above, L_2TAG_PACKET_41_0_2);\n+  __ jcc(Assembler::equal, L_2TAG_PACKET_42_0_2);\n+  __ cmpl(rdx, 1023);\n+  __ jcc(Assembler::below, L_2TAG_PACKET_41_0_2);\n+  __ movq(xmm1, Address(rsp, 16));\n+  __ movl(rax, 17208);\n+  __ xorpd(xmm3, xmm3);\n+  __ pinsrw(xmm3, rax, 3);\n+  __ movdqu(xmm4, xmm3);\n+  __ addsd(xmm3, xmm1);\n+  __ subsd(xmm4, xmm3);\n+  __ addsd(xmm1, xmm4);\n+  __ pextrw(rax, xmm1, 3);\n+  __ andl(rax, 32752);\n+  __ jcc(Assembler::notEqual, L_2TAG_PACKET_41_0_2);\n+  __ movdl(rax, xmm3);\n+  __ andl(rax, 1);\n+  __ jcc(Assembler::equal, L_2TAG_PACKET_41_0_2);\n+\n+  __ bind(L_2TAG_PACKET_43_0_2);\n+  __ movq(xmm0, Address(rsp, 8));\n+  __ testl(rcx, INT_MIN);\n+  __ jcc(Assembler::notEqual, L_2TAG_PACKET_44_0_2);\n+  __ jmp(B1_5);\n+\n+  __ bind(L_2TAG_PACKET_42_0_2);\n+  __ movq(xmm1, Address(rsp, 16));\n+  __ movdl(rax, xmm1);\n+  __ testl(rax, 1);\n+  __ jcc(Assembler::notEqual, L_2TAG_PACKET_43_0_2);\n+\n+  __ bind(L_2TAG_PACKET_41_0_2);\n+  __ testl(rcx, INT_MIN);\n+  __ jcc(Assembler::equal, L_2TAG_PACKET_22_0_2);\n+  __ xorpd(xmm0, xmm0);\n+\n+  __ bind(L_2TAG_PACKET_44_0_2);\n+  __ movl(rax, 16368);\n+  __ xorpd(xmm1, xmm1);\n+  __ pinsrw(xmm1, rax, 3);\n+  __ divsd(xmm1, xmm0);\n+  __ movdqu(xmm0, xmm1);\n+  __ movl(Address(rsp, 0), 27);\n+  __ jmp(L_2TAG_PACKET_17_0_2);\n+\n+  __ bind(L_2TAG_PACKET_12_0_2);\n+  __ movq(xmm2, Address(rsp, 8));\n+  __ movq(xmm6, Address(rsp, 16));\n+  __ pextrw(rax, xmm2, 3);\n+  __ pextrw(rdx, xmm6, 3);\n+  __ movl(rcx, 32752);\n+  __ andl(rcx, rdx);\n+  __ cmpl(rcx, 32752);\n+  __ jcc(Assembler::equal, L_2TAG_PACKET_45_0_2);\n+  __ andl(rax, 32752);\n+  __ subl(rax, 16368);\n+  __ xorl(rdx, rax);\n+  __ testl(rdx, 32768);\n+  __ jcc(Assembler::notEqual, L_2TAG_PACKET_46_0_2);\n+\n+  __ bind(L_2TAG_PACKET_47_0_2);\n+  __ movl(rax, 32736);\n+  __ pinsrw(xmm0, rax, 3);\n+  __ shrl(r8, 16);\n+  __ orl(rax, r8);\n+  __ pinsrw(xmm1, rax, 3);\n+  __ mulsd(xmm0, xmm1);\n+\n+  __ bind(L_2TAG_PACKET_14_0_2);\n+  __ movl(Address(rsp, 0), 24);\n+  __ jmp(L_2TAG_PACKET_17_0_2);\n+\n+  __ bind(L_2TAG_PACKET_46_0_2);\n+  __ movl(rax, 16);\n+  __ pinsrw(xmm0, rax, 3);\n+  __ mulsd(xmm0, xmm0);\n+  __ testl(r8, INT_MIN);\n+  __ jcc(Assembler::equal, L_2TAG_PACKET_48_0_2);\n+  __ mov64(r9, 0x8000000000000000);\n+  __ movdq(xmm2, r9);\n+  __ xorpd(xmm0, xmm2);\n+\n+  __ bind(L_2TAG_PACKET_48_0_2);\n+  __ movl(Address(rsp, 0), 25);\n+  __ jmp(L_2TAG_PACKET_17_0_2);\n+\n+  __ bind(L_2TAG_PACKET_13_0_2);\n+  __ pextrw(rcx, xmm5, 3);\n+  __ pextrw(rdx, xmm4, 3);\n+  __ movl(rax, -1);\n+  __ andl(rcx, 32752);\n+  __ subl(rcx, 16368);\n+  __ andl(rdx, 32752);\n+  __ addl(rdx, rcx);\n+  __ movl(rcx, -31);\n+  __ sarl(rdx, 4);\n+  __ subl(rcx, rdx);\n+  __ jcc(Assembler::lessEqual, L_2TAG_PACKET_49_0_2);\n+  __ cmpl(rcx, 20);\n+  __ jcc(Assembler::above, L_2TAG_PACKET_50_0_2);\n+  __ shll(rax);\n+\n+  __ bind(L_2TAG_PACKET_49_0_2);\n+  __ movdl(xmm0, rax);\n+  __ psllq(xmm0, 32);\n+  __ pand(xmm0, xmm5);\n+  __ subsd(xmm5, xmm0);\n+  __ addsd(xmm5, xmm1);\n+  __ mulsd(xmm0, xmm4);\n+  __ mulsd(xmm5, xmm4);\n+  __ addsd(xmm0, xmm5);\n+\n+  __ bind(L_2TAG_PACKET_50_0_2);\n+  __ jmp(L_2TAG_PACKET_48_0_2);\n+\n+  __ bind(L_2TAG_PACKET_2_0_2);\n+  __ movw(rcx, Address(rsp, 22));\n+  __ movl(rdx, INT_MIN);\n+  __ movdl(xmm1, rdx);\n+  __ xorpd(xmm7, xmm7);\n+  __ paddd(xmm0, xmm4);\n+  __ movdl(rdx, xmm0);\n+  __ psllq(xmm0, 29);\n+  __ paddq(xmm1, xmm3);\n+  __ pand(xmm5, xmm1);\n+  __ andl(rcx, 32752);\n+  __ cmpl(rcx, 16560);\n+  __ jcc(Assembler::less, L_2TAG_PACKET_3_0_2);\n+  __ pand(xmm0, xmm6);\n+  __ subsd(xmm3, xmm5);\n+  __ addl(rax, 16351);\n+  __ shrl(rax, 4);\n+  __ subl(rax, 1022);\n+  __ cvtsi2sdl(xmm7, rax);\n+  __ mulpd(xmm5, xmm0);\n+  __ lea(r11, ExternalAddress(L_tbl));\n+  __ movq(xmm4, ExternalAddress(coeff_h), r9 \/*rscratch*\/);    \/\/0x00000000UL, 0xbfd61a00UL, 0x00000000UL, 0xbf5dabe1UL\n+  __ mulsd(xmm3, xmm0);\n+  __ movq(xmm6, ExternalAddress(coeff_h), r9 \/*rscratch*\/);    \/\/0x00000000UL, 0xbfd61a00UL, 0x00000000UL, 0xbf5dabe1UL\n+  __ subsd(xmm5, xmm2);\n+  __ movq(xmm1, ExternalAddress(coeff_h + 8), r9 \/*rscratch*\/);    \/\/0x00000000UL, 0xbf5dabe1UL\n+  __ pshufd(xmm2, xmm3, 68);\n+  __ unpcklpd(xmm5, xmm3);\n+  __ addsd(xmm3, xmm5);\n+  __ movq(xmm0, ExternalAddress(coeff_h + 8), r9 \/*rscratch*\/);    \/\/0x00000000UL, 0xbf5dabe1UL\n+  __ andl(rdx, 16760832);\n+  __ shrl(rdx, 10);\n+  __ addpd(xmm7, Address(r11, rdx, Address::times_1, -3648));\n+  __ mulsd(xmm4, xmm5);\n+  __ mulsd(xmm0, xmm5);\n+  __ mulsd(xmm6, xmm2);\n+  __ mulsd(xmm1, xmm2);\n+  __ movdqu(xmm2, xmm5);\n+  __ mulsd(xmm4, xmm5);\n+  __ addsd(xmm5, xmm0);\n+  __ movdqu(xmm0, xmm7);\n+  __ addsd(xmm2, xmm3);\n+  __ addsd(xmm7, xmm5);\n+  __ mulsd(xmm6, xmm2);\n+  __ subsd(xmm0, xmm7);\n+  __ movdqu(xmm2, xmm7);\n+  __ addsd(xmm7, xmm4);\n+  __ addsd(xmm0, xmm5);\n+  __ subsd(xmm2, xmm7);\n+  __ addsd(xmm4, xmm2);\n+  __ pshufd(xmm2, xmm5, 238);\n+  __ movdqu(xmm5, xmm7);\n+  __ addsd(xmm7, xmm2);\n+  __ addsd(xmm4, xmm0);\n+  __ movdqu(xmm0, ExternalAddress(coeff), r9 \/*rscratch*\/);    \/\/0x6dc96112UL, 0xbf836578UL, 0xee241472UL, 0xbf9b0301UL\n+  __ subsd(xmm5, xmm7);\n+  __ addsd(xmm6, xmm4);\n+  __ movdqu(xmm4, xmm7);\n+  __ addsd(xmm5, xmm2);\n+  __ addsd(xmm7, xmm1);\n+  __ movdqu(xmm2, ExternalAddress(coeff + 64), r9 \/*rscratch*\/);    \/\/0x486ececcUL, 0x3fc4635eUL, 0x161bb241UL, 0xbf5dabe1UL\n+  __ subsd(xmm4, xmm7);\n+  __ addsd(xmm6, xmm5);\n+  __ addsd(xmm4, xmm1);\n+  __ pshufd(xmm5, xmm7, 238);\n+  __ movapd(xmm1, xmm7);\n+  __ addsd(xmm7, xmm5);\n+  __ subsd(xmm1, xmm7);\n+  __ addsd(xmm1, xmm5);\n+  __ movdqu(xmm5, ExternalAddress(coeff + 80), r9 \/*rscratch*\/);    \/\/0x9f95985aUL, 0xbfb528dbUL, 0xf8b5787dUL, 0x3ef2531eUL\n+  __ pshufd(xmm3, xmm3, 68);\n+  __ addsd(xmm6, xmm4);\n+  __ addsd(xmm6, xmm1);\n+  __ movdqu(xmm1, ExternalAddress(coeff + 32), r9 \/*rscratch*\/);    \/\/0x9f95985aUL, 0xbfb528dbUL, 0xb3841d2aUL, 0xbfd619b6UL\n+  __ mulpd(xmm0, xmm3);\n+  __ mulpd(xmm2, xmm3);\n+  __ pshufd(xmm4, xmm3, 68);\n+  __ mulpd(xmm3, xmm3);\n+  __ addpd(xmm0, xmm1);\n+  __ addpd(xmm5, xmm2);\n+  __ mulsd(xmm4, xmm3);\n+  __ movq(xmm2, ExternalAddress(HIGHMASK_LOG_X), r9 \/*rscratch*\/);    \/\/0xf8000000UL, 0xffffffffUL, 0x00000000UL, 0xfffff800UL\n+  __ mulpd(xmm3, xmm3);\n+  __ movq(xmm1, Address(rsp, 16));\n+  __ movw(rcx, Address(rsp, 22));\n+  __ mulpd(xmm0, xmm4);\n+  __ pextrw(rax, xmm7, 3);\n+  __ mulpd(xmm5, xmm4);\n+  __ mulpd(xmm0, xmm3);\n+  __ movq(xmm4, ExternalAddress(HIGHMASK_Y + 8), r9 \/*rscratch*\/);    \/\/0x00000000UL, 0xffffffffUL\n+  __ pand(xmm2, xmm7);\n+  __ addsd(xmm5, xmm6);\n+  __ subsd(xmm7, xmm2);\n+  __ addpd(xmm5, xmm0);\n+  __ andl(rax, 32752);\n+  __ subl(rax, 16368);\n+  __ andl(rcx, 32752);\n+  __ cmpl(rcx, 32752);\n+  __ jcc(Assembler::equal, L_2TAG_PACKET_45_0_2);\n+  __ addl(rcx, rax);\n+  __ cmpl(rcx, 16576);\n+  __ jcc(Assembler::aboveEqual, L_2TAG_PACKET_51_0_2);\n+  __ pshufd(xmm0, xmm5, 238);\n+  __ pand(xmm4, xmm1);\n+  __ movdqu(xmm3, xmm1);\n+  __ addsd(xmm5, xmm0);\n+  __ subsd(xmm1, xmm4);\n+  __ xorpd(xmm6, xmm6);\n+  __ movl(rdx, 17080);\n+  __ pinsrw(xmm6, rdx, 3);\n+  __ addsd(xmm7, xmm5);\n+  __ mulsd(xmm4, xmm2);\n+  __ mulsd(xmm1, xmm2);\n+  __ movdqu(xmm5, xmm6);\n+  __ mulsd(xmm3, xmm7);\n+  __ addsd(xmm6, xmm4);\n+  __ addsd(xmm1, xmm3);\n+  __ movdqu(xmm7, ExternalAddress(e_coeff), r9 \/*rscratch*\/);    \/\/0xe78a6731UL, 0x3f55d87fUL, 0xd704a0c0UL, 0x3fac6b08UL\n+  __ movdl(rdx, xmm6);\n+  __ subsd(xmm6, xmm5);\n+  __ lea(r11, ExternalAddress(T_exp));\n+  __ movdqu(xmm3, ExternalAddress(e_coeff + 16), r9 \/*rscratch*\/);    \/\/0x6fba4e77UL, 0x3f83b2abUL, 0xff82c58fUL, 0x3fcebfbdUL\n+  __ movq(xmm2, ExternalAddress(e_coeff + 32), r9 \/*rscratch*\/);    \/\/0xfefa39efUL, 0x3fe62e42UL, 0x00000000UL, 0x00000000UL\n+  __ subsd(xmm4, xmm6);\n+  __ movl(rcx, rdx);\n+  __ andl(rdx, 255);\n+  __ addl(rdx, rdx);\n+  __ movdqu(xmm5, Address(r11, rdx, Address::times_8, 0));\n+  __ addsd(xmm4, xmm1);\n+  __ pextrw(rdx, xmm6, 3);\n+  __ shrl(rcx, 8);\n+  __ movl(rax, rcx);\n+  __ shrl(rcx, 1);\n+  __ subl(rax, rcx);\n+  __ shll(rcx, 20);\n+  __ movdl(xmm6, rcx);\n+  __ pshufd(xmm0, xmm4, 68);\n+  __ pshufd(xmm1, xmm4, 68);\n+  __ mulpd(xmm0, xmm0);\n+  __ mulpd(xmm7, xmm1);\n+  __ pshufd(xmm6, xmm6, 17);\n+  __ mulsd(xmm2, xmm4);\n+  __ andl(rdx, 32767);\n+  __ cmpl(rdx, 16529);\n+  __ jcc(Assembler::above, L_2TAG_PACKET_12_0_2);\n+  __ mulsd(xmm0, xmm0);\n+  __ paddd(xmm5, xmm6);\n+  __ addpd(xmm3, xmm7);\n+  __ mulsd(xmm2, xmm5);\n+  __ pshufd(xmm6, xmm5, 238);\n+  __ mulpd(xmm0, xmm3);\n+  __ addsd(xmm2, xmm6);\n+  __ pshufd(xmm3, xmm0, 238);\n+  __ addl(rax, 1023);\n+  __ shll(rax, 20);\n+  __ orl(rax, r8);\n+  __ movdl(xmm4, rax);\n+  __ mulsd(xmm0, xmm5);\n+  __ mulsd(xmm3, xmm5);\n+  __ addsd(xmm0, xmm2);\n+  __ psllq(xmm4, 32);\n+  __ addsd(xmm0, xmm3);\n+  __ movdqu(xmm1, xmm0);\n+  __ addsd(xmm0, xmm5);\n+  __ mulsd(xmm0, xmm4);\n+  __ pextrw(rax, xmm0, 3);\n+  __ andl(rax, 32752);\n+  __ jcc(Assembler::equal, L_2TAG_PACKET_13_0_2);\n+  __ cmpl(rax, 32752);\n+  __ jcc(Assembler::equal, L_2TAG_PACKET_14_0_2);\n+\n+  __ bind(L_2TAG_PACKET_52_0_2);\n+  __ jmp(B1_5);\n+\n+  __ bind(L_2TAG_PACKET_45_0_2);\n+  __ movq(xmm0, Address(rsp, 8));\n+  __ xorpd(xmm2, xmm2);\n+  __ movl(rax, 49136);\n+  __ pinsrw(xmm2, rax, 3);\n+  __ addsd(xmm2, xmm0);\n+  __ pextrw(rax, xmm2, 3);\n+  __ cmpl(rax, 0);\n+  __ jcc(Assembler::notEqual, L_2TAG_PACKET_53_0_2);\n+  __ xorpd(xmm0, xmm0);\n+  __ movl(rax, 32760);\n+  __ pinsrw(xmm0, rax, 3);\n+  __ jmp(B1_5);\n+\n+  __ bind(L_2TAG_PACKET_53_0_2);\n+  __ movq(xmm1, Address(rsp, 16));\n+  __ movdl(rdx, xmm1);\n+  __ movdqu(xmm3, xmm1);\n+  __ psrlq(xmm3, 20);\n+  __ movdl(rcx, xmm3);\n+  __ orl(rcx, rdx);\n+  __ jcc(Assembler::equal, L_2TAG_PACKET_54_0_2);\n+  __ addsd(xmm1, xmm1);\n+  __ movdqu(xmm0, xmm1);\n+  __ jmp(B1_5);\n+\n+  __ bind(L_2TAG_PACKET_51_0_2);\n+  __ pextrw(rax, xmm1, 3);\n+  __ pextrw(rcx, xmm2, 3);\n+  __ xorl(rax, rcx);\n+  __ testl(rax, 32768);\n+  __ jcc(Assembler::equal, L_2TAG_PACKET_47_0_2);\n+  __ jmp(L_2TAG_PACKET_46_0_2);\n+\n+  __ bind(L_2TAG_PACKET_54_0_2);\n+  __ pextrw(rax, xmm0, 3);\n+  __ andl(rax, 32752);\n+  __ pextrw(rdx, xmm1, 3);\n+  __ xorpd(xmm0, xmm0);\n+  __ subl(rax, 16368);\n+  __ xorl(rax, rdx);\n+  __ testl(rax, 32768);\n+  __ jcc(Assembler::equal, L_2TAG_PACKET_55_0_2);\n+  __ jmp(B1_5);\n+\n+  __ bind(L_2TAG_PACKET_55_0_2);\n+  __ movl(rdx, 32752);\n+  __ pinsrw(xmm0, rdx, 3);\n+  __ jmp(B1_5);\n+\n+  __ bind(L_2TAG_PACKET_17_0_2);\n+  __ movq(Address(rsp, 24), xmm0);\n+\n+  __ bind(B1_3);\n+  __ movq(xmm0, Address(rsp, 24));\n+\n+  __ bind(L_2TAG_PACKET_56_0_2);\n+\n+  __ bind(B1_5);\n+  __ addq(rsp, 40);\n+\n+  __ leave(); \/\/ required for proper stackwalking of RuntimeStub frame\n+  __ ret(0);\n+\n+  return start;\n+}\n+\n+#undef __\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_pow.cpp","additions":1865,"deletions":0,"binary":false,"changes":1865,"status":"added"},{"patch":"@@ -0,0 +1,651 @@\n+\/*\n+ * Copyright (c) 2016, 2021, Intel Corporation. All rights reserved.\n+ * Intel Math Library (LIBM) Source Code\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"macroAssembler_x86.hpp\"\n+#include \"stubGenerator_x86_64.hpp\"\n+\n+\/******************************************************************************\/\n+\/\/                     ALGORITHM DESCRIPTION - SIN()\n+\/\/                     ---------------------\n+\/\/\n+\/\/     1. RANGE REDUCTION\n+\/\/\n+\/\/     We perform an initial range reduction from X to r with\n+\/\/\n+\/\/          X =~= N * pi\/32 + r\n+\/\/\n+\/\/     so that |r| <= pi\/64 + epsilon. We restrict inputs to those\n+\/\/     where |N| <= 932560. Beyond this, the range reduction is\n+\/\/     insufficiently accurate. For extremely small inputs,\n+\/\/     denormalization can occur internally, impacting performance.\n+\/\/     This means that the main path is actually only taken for\n+\/\/     2^-252 <= |X| < 90112.\n+\/\/\n+\/\/     To avoid branches, we perform the range reduction to full\n+\/\/     accuracy each time.\n+\/\/\n+\/\/          X - N * (P_1 + P_2 + P_3)\n+\/\/\n+\/\/     where P_1 and P_2 are 32-bit numbers (so multiplication by N\n+\/\/     is exact) and P_3 is a 53-bit number. Together, these\n+\/\/     approximate pi well enough for all cases in the restricted\n+\/\/     range.\n+\/\/\n+\/\/     The main reduction sequence is:\n+\/\/\n+\/\/             y = 32\/pi * x\n+\/\/             N = integer(y)\n+\/\/     (computed by adding and subtracting off SHIFTER)\n+\/\/\n+\/\/             m_1 = N * P_1\n+\/\/             m_2 = N * P_2\n+\/\/             r_1 = x - m_1\n+\/\/             r = r_1 - m_2\n+\/\/     (this r can be used for most of the calculation)\n+\/\/\n+\/\/             c_1 = r_1 - r\n+\/\/             m_3 = N * P_3\n+\/\/             c_2 = c_1 - m_2\n+\/\/             c = c_2 - m_3\n+\/\/\n+\/\/     2. MAIN ALGORITHM\n+\/\/\n+\/\/     The algorithm uses a table lookup based on B = M * pi \/ 32\n+\/\/     where M = N mod 64. The stored values are:\n+\/\/       sigma             closest power of 2 to cos(B)\n+\/\/       C_hl              53-bit cos(B) - sigma\n+\/\/       S_hi + S_lo       2 * 53-bit sin(B)\n+\/\/\n+\/\/     The computation is organized as follows:\n+\/\/\n+\/\/          sin(B + r + c) = [sin(B) + sigma * r] +\n+\/\/                           r * (cos(B) - sigma) +\n+\/\/                           sin(B) * [cos(r + c) - 1] +\n+\/\/                           cos(B) * [sin(r + c) - r]\n+\/\/\n+\/\/     which is approximately:\n+\/\/\n+\/\/          [S_hi + sigma * r] +\n+\/\/          C_hl * r +\n+\/\/          S_lo + S_hi * [(cos(r) - 1) - r * c] +\n+\/\/          (C_hl + sigma) * [(sin(r) - r) + c]\n+\/\/\n+\/\/     and this is what is actually computed. We separate this sum\n+\/\/     into four parts:\n+\/\/\n+\/\/          hi + med + pols + corr\n+\/\/\n+\/\/     where\n+\/\/\n+\/\/          hi       = S_hi + sigma r\n+\/\/          med      = C_hl * r\n+\/\/          pols     = S_hi * (cos(r) - 1) + (C_hl + sigma) * (sin(r) - r)\n+\/\/          corr     = S_lo + c * ((C_hl + sigma) - S_hi * r)\n+\/\/\n+\/\/     3. POLYNOMIAL\n+\/\/\n+\/\/     The polynomial S_hi * (cos(r) - 1) + (C_hl + sigma) *\n+\/\/     (sin(r) - r) can be rearranged freely, since it is quite\n+\/\/     small, so we exploit parallelism to the fullest.\n+\/\/\n+\/\/          psc4       =   SC_4 * r_1\n+\/\/          msc4       =   psc4 * r\n+\/\/          r2         =   r * r\n+\/\/          msc2       =   SC_2 * r2\n+\/\/          r4         =   r2 * r2\n+\/\/          psc3       =   SC_3 + msc4\n+\/\/          psc1       =   SC_1 + msc2\n+\/\/          msc3       =   r4 * psc3\n+\/\/          sincospols =   psc1 + msc3\n+\/\/          pols       =   sincospols *\n+\/\/                         <S_hi * r^2 | (C_hl + sigma) * r^3>\n+\/\/\n+\/\/     4. CORRECTION TERM\n+\/\/\n+\/\/     This is where the \"c\" component of the range reduction is\n+\/\/     taken into account; recall that just \"r\" is used for most of\n+\/\/     the calculation.\n+\/\/\n+\/\/          -c   = m_3 - c_2\n+\/\/          -d   = S_hi * r - (C_hl + sigma)\n+\/\/          corr = -c * -d + S_lo\n+\/\/\n+\/\/     5. COMPENSATED SUMMATIONS\n+\/\/\n+\/\/     The two successive compensated summations add up the high\n+\/\/     and medium parts, leaving just the low parts to add up at\n+\/\/     the end.\n+\/\/\n+\/\/          rs        =  sigma * r\n+\/\/          res_int   =  S_hi + rs\n+\/\/          k_0       =  S_hi - res_int\n+\/\/          k_2       =  k_0 + rs\n+\/\/          med       =  C_hl * r\n+\/\/          res_hi    =  res_int + med\n+\/\/          k_1       =  res_int - res_hi\n+\/\/          k_3       =  k_1 + med\n+\/\/\n+\/\/     6. FINAL SUMMATION\n+\/\/\n+\/\/     We now add up all the small parts:\n+\/\/\n+\/\/          res_lo = pols(hi) + pols(lo) + corr + k_1 + k_3\n+\/\/\n+\/\/     Now the overall result is just:\n+\/\/\n+\/\/          res_hi + res_lo\n+\/\/\n+\/\/     7. SMALL ARGUMENTS\n+\/\/\n+\/\/     If |x| < SNN (SNN meaning the smallest normal number), we\n+\/\/     simply perform 0.1111111 cdots 1111 * x. For SNN <= |x|, we\n+\/\/     do 2^-55 * (2^55 * x - x).\n+\/\/\n+\/\/ Special cases:\n+\/\/  sin(NaN) = quiet NaN, and raise invalid exception\n+\/\/  sin(INF) = NaN and raise invalid exception\n+\/\/  sin(+\/-0) = +\/-0\n+\/\/\n+\/******************************************************************************\/\n+\n+\/\/ The 64 bit code is at most SSE2 compliant\n+ATTRIBUTE_ALIGNED(8) juint _ALL_ONES[] =\n+{\n+    0xffffffffUL, 0x3fefffffUL\n+};\n+\n+#define __ _masm->\n+\n+address StubGenerator::generate_libmSin() {\n+  StubCodeMark mark(this, \"StubRoutines\", \"libmSin\");\n+  address start = __ pc();\n+\n+  Label L_2TAG_PACKET_0_0_1, L_2TAG_PACKET_1_0_1, L_2TAG_PACKET_2_0_1, L_2TAG_PACKET_3_0_1;\n+  Label L_2TAG_PACKET_4_0_1, L_2TAG_PACKET_5_0_1, L_2TAG_PACKET_6_0_1, L_2TAG_PACKET_7_0_1;\n+  Label L_2TAG_PACKET_8_0_1, L_2TAG_PACKET_9_0_1, L_2TAG_PACKET_10_0_1, L_2TAG_PACKET_11_0_1;\n+  Label L_2TAG_PACKET_13_0_1, L_2TAG_PACKET_14_0_1;\n+  Label L_2TAG_PACKET_12_0_1, B1_4;\n+\n+  address ALL_ONES = (address)_ALL_ONES;\n+\n+  __ enter(); \/\/ required for proper stackwalking of RuntimeStub frame\n+\n+#ifdef _WIN64\n+  __ push(rsi);\n+  __ push(rdi);\n+#endif\n+\n+  __ push(rbx);\n+  __ subq(rsp, 16);\n+  __ movsd(Address(rsp, 8), xmm0);\n+  __ movl(rax, Address(rsp, 12));\n+  __ movq(xmm1, ExternalAddress(PI32INV), r8 \/*rscratch*\/); \/\/0x6dc9c883UL, 0x40245f30UL\n+  __ movq(xmm2, ExternalAddress(SHIFTER), r8 \/*rscratch*\/); \/\/0x00000000UL, 0x43380000UL\n+  __ andl(rax, 2147418112);\n+  __ subl(rax, 808452096);\n+  __ cmpl(rax, 281346048);\n+  __ jcc(Assembler::above, L_2TAG_PACKET_0_0_1);\n+  __ mulsd(xmm1, xmm0);\n+  __ movdqu(xmm5, ExternalAddress(ONEHALF), r8 \/*rscratch*\/); \/\/0x00000000UL, 0x3fe00000UL, 0x00000000UL, 0x3fe00000UL\n+  __ movq(xmm4, ExternalAddress(SIGN_MASK), r8 \/*rscratch*\/); \/\/0x00000000UL, 0x80000000UL\n+  __ pand(xmm4, xmm0);\n+  __ por(xmm5, xmm4);\n+  __ addpd(xmm1, xmm5);\n+  __ cvttsd2sil(rdx, xmm1);\n+  __ cvtsi2sdl(xmm1, rdx);\n+  __ movdqu(xmm6, ExternalAddress(P_2), r8 \/*rscratch*\/); \/\/0x1a600000UL, 0x3d90b461UL, 0x1a600000UL, 0x3d90b461UL\n+  __ mov64(r8, 0x3fb921fb54400000);\n+  __ movdq(xmm3, r8);\n+  __ movdqu(xmm5, ExternalAddress(SC_4), r8 \/*rscratch*\/); \/\/0xa556c734UL, 0x3ec71de3UL, 0x1a01a01aUL, 0x3efa01a0UL\n+  __ pshufd(xmm4, xmm0, 68);\n+  __ mulsd(xmm3, xmm1);\n+  if (VM_Version::supports_sse3()) {\n+    __ movddup(xmm1, xmm1);\n+  } else {\n+    __ movlhps(xmm1, xmm1);\n+  }\n+  __ andl(rdx, 63);\n+  __ shll(rdx, 5);\n+  __ lea(rax, ExternalAddress(Ctable));\n+  __ addq(rax, rdx);\n+  __ mulpd(xmm6, xmm1);\n+  __ mulsd(xmm1, ExternalAddress(P_3), r8 \/*rscratch*\/); \/\/0x2e037073UL, 0x3b63198aUL\n+  __ subsd(xmm4, xmm3);\n+  __ movq(xmm7, Address(rax, 8));\n+  __ subsd(xmm0, xmm3);\n+  if (VM_Version::supports_sse3()) {\n+    __ movddup(xmm3, xmm4);\n+  } else {\n+    __ movdqu(xmm3, xmm4);\n+    __ movlhps(xmm3, xmm3);\n+  }\n+  __ subsd(xmm4, xmm6);\n+  __ pshufd(xmm0, xmm0, 68);\n+  __ movdqu(xmm2, Address(rax, 0));\n+  __ mulpd(xmm5, xmm0);\n+  __ subpd(xmm0, xmm6);\n+  __ mulsd(xmm7, xmm4);\n+  __ subsd(xmm3, xmm4);\n+  __ mulpd(xmm5, xmm0);\n+  __ mulpd(xmm0, xmm0);\n+  __ subsd(xmm3, xmm6);\n+  __ movdqu(xmm6, ExternalAddress(SC_2), r8 \/*rscratch*\/); \/\/0x11111111UL, 0x3f811111UL, 0x55555555UL, 0x3fa55555UL\n+  __ subsd(xmm1, xmm3);\n+  __ movq(xmm3, Address(rax, 24));\n+  __ addsd(xmm2, xmm3);\n+  __ subsd(xmm7, xmm2);\n+  __ mulsd(xmm2, xmm4);\n+  __ mulpd(xmm6, xmm0);\n+  __ mulsd(xmm3, xmm4);\n+  __ mulpd(xmm2, xmm0);\n+  __ mulpd(xmm0, xmm0);\n+  __ addpd(xmm5, ExternalAddress(SC_3), r8 \/*rscratch*\/); \/\/0x1a01a01aUL, 0xbf2a01a0UL, 0x16c16c17UL, 0xbf56c16cUL\n+  __ mulsd(xmm4, Address(rax, 0));\n+  __ addpd(xmm6, ExternalAddress(SC_1), r8 \/*rscratch*\/); \/\/0x55555555UL, 0xbfc55555UL, 0x00000000UL, 0xbfe00000UL\n+  __ mulpd(xmm5, xmm0);\n+  __ movdqu(xmm0, xmm3);\n+  __ addsd(xmm3, Address(rax, 8));\n+  __ mulpd(xmm1, xmm7);\n+  __ movdqu(xmm7, xmm4);\n+  __ addsd(xmm4, xmm3);\n+  __ addpd(xmm6, xmm5);\n+  __ movq(xmm5, Address(rax, 8));\n+  __ subsd(xmm5, xmm3);\n+  __ subsd(xmm3, xmm4);\n+  __ addsd(xmm1, Address(rax, 16));\n+  __ mulpd(xmm6, xmm2);\n+  __ addsd(xmm5, xmm0);\n+  __ addsd(xmm3, xmm7);\n+  __ addsd(xmm1, xmm5);\n+  __ addsd(xmm1, xmm3);\n+  __ addsd(xmm1, xmm6);\n+  __ unpckhpd(xmm6, xmm6);\n+  __ movdqu(xmm0, xmm4);\n+  __ addsd(xmm1, xmm6);\n+  __ addsd(xmm0, xmm1);\n+  __ jmp(B1_4);\n+\n+  __ bind(L_2TAG_PACKET_0_0_1);\n+  __ jcc(Assembler::greater, L_2TAG_PACKET_1_0_1);\n+  __ shrl(rax, 20);\n+  __ cmpl(rax, 3325);\n+  __ jcc(Assembler::notEqual, L_2TAG_PACKET_2_0_1);\n+  __ mulsd(xmm0, ExternalAddress(ALL_ONES), r8 \/*rscratch*\/); \/\/0xffffffffUL, 0x3fefffffUL\n+  __ jmp(B1_4);\n+\n+  __ bind(L_2TAG_PACKET_2_0_1);\n+  __ movq(xmm3, ExternalAddress(TWO_POW_55), r8 \/*rscratch*\/); \/\/0x00000000UL, 0x43600000UL\n+  __ mulsd(xmm3, xmm0);\n+  __ subsd(xmm3, xmm0);\n+  __ mulsd(xmm3, ExternalAddress(TWO_POW_M55), r8 \/*rscratch*\/); \/\/0x00000000UL, 0x3c800000UL\n+  __ jmp(B1_4);\n+\n+  __ bind(L_2TAG_PACKET_1_0_1);\n+  __ pextrw(rax, xmm0, 3);\n+  __ andl(rax, 32752);\n+  __ cmpl(rax, 32752);\n+  __ jcc(Assembler::equal, L_2TAG_PACKET_3_0_1);\n+  __ pextrw(rcx, xmm0, 3);\n+  __ andl(rcx, 32752);\n+  __ subl(rcx, 16224);\n+  __ shrl(rcx, 7);\n+  __ andl(rcx, 65532);\n+  __ lea(r11, ExternalAddress(PI_INV_TABLE));\n+  __ addq(rcx, r11);\n+  __ movdq(rax, xmm0);\n+  __ movl(r10, Address(rcx, 20));\n+  __ movl(r8, Address(rcx, 24));\n+  __ movl(rdx, rax);\n+  __ shrq(rax, 21);\n+  __ orl(rax, INT_MIN);\n+  __ shrl(rax, 11);\n+  __ movl(r9, r10);\n+  __ imulq(r10, rdx);\n+  __ imulq(r9, rax);\n+  __ imulq(r8, rax);\n+  __ movl(rsi, Address(rcx, 16));\n+  __ movl(rdi, Address(rcx, 12));\n+  __ movl(r11, r10);\n+  __ shrq(r10, 32);\n+  __ addq(r9, r10);\n+  __ addq(r11, r8);\n+  __ movl(r8, r11);\n+  __ shrq(r11, 32);\n+  __ addq(r9, r11);\n+  __ movl(r10, rsi);\n+  __ imulq(rsi, rdx);\n+  __ imulq(r10, rax);\n+  __ movl(r11, rdi);\n+  __ imulq(rdi, rdx);\n+  __ movl(rbx, rsi);\n+  __ shrq(rsi, 32);\n+  __ addq(r9, rbx);\n+  __ movl(rbx, r9);\n+  __ shrq(r9, 32);\n+  __ addq(r10, rsi);\n+  __ addq(r10, r9);\n+  __ shlq(rbx, 32);\n+  __ orq(r8, rbx);\n+  __ imulq(r11, rax);\n+  __ movl(r9, Address(rcx, 8));\n+  __ movl(rsi, Address(rcx, 4));\n+  __ movl(rbx, rdi);\n+  __ shrq(rdi, 32);\n+  __ addq(r10, rbx);\n+  __ movl(rbx, r10);\n+  __ shrq(r10, 32);\n+  __ addq(r11, rdi);\n+  __ addq(r11, r10);\n+  __ movq(rdi, r9);\n+  __ imulq(r9, rdx);\n+  __ imulq(rdi, rax);\n+  __ movl(r10, r9);\n+  __ shrq(r9, 32);\n+  __ addq(r11, r10);\n+  __ movl(r10, r11);\n+  __ shrq(r11, 32);\n+  __ addq(rdi, r9);\n+  __ addq(rdi, r11);\n+  __ movq(r9, rsi);\n+  __ imulq(rsi, rdx);\n+  __ imulq(r9, rax);\n+  __ shlq(r10, 32);\n+  __ orq(r10, rbx);\n+  __ movl(rax, Address(rcx, 0));\n+  __ movl(r11, rsi);\n+  __ shrq(rsi, 32);\n+  __ addq(rdi, r11);\n+  __ movl(r11, rdi);\n+  __ shrq(rdi, 32);\n+  __ addq(r9, rsi);\n+  __ addq(r9, rdi);\n+  __ imulq(rdx, rax);\n+  __ pextrw(rbx, xmm0, 3);\n+  __ lea(rdi, ExternalAddress(PI_INV_TABLE));\n+  __ subq(rcx, rdi);\n+  __ addl(rcx, rcx);\n+  __ addl(rcx, rcx);\n+  __ addl(rcx, rcx);\n+  __ addl(rcx, 19);\n+  __ movl(rsi, 32768);\n+  __ andl(rsi, rbx);\n+  __ shrl(rbx, 4);\n+  __ andl(rbx, 2047);\n+  __ subl(rbx, 1023);\n+  __ subl(rcx, rbx);\n+  __ addq(r9, rdx);\n+  __ movl(rdx, rcx);\n+  __ addl(rdx, 32);\n+  __ cmpl(rcx, 1);\n+  __ jcc(Assembler::less, L_2TAG_PACKET_4_0_1);\n+  __ negl(rcx);\n+  __ addl(rcx, 29);\n+  __ shll(r9);\n+  __ movl(rdi, r9);\n+  __ andl(r9, 536870911);\n+  __ testl(r9, 268435456);\n+  __ jcc(Assembler::notEqual, L_2TAG_PACKET_5_0_1);\n+  __ shrl(r9);\n+  __ movl(rbx, 0);\n+  __ shlq(r9, 32);\n+  __ orq(r9, r11);\n+\n+  __ bind(L_2TAG_PACKET_6_0_1);\n+\n+  __ bind(L_2TAG_PACKET_7_0_1);\n+\n+  __ cmpq(r9, 0);\n+  __ jcc(Assembler::equal, L_2TAG_PACKET_8_0_1);\n+\n+  __ bind(L_2TAG_PACKET_9_0_1);\n+  __ bsrq(r11, r9);\n+  __ movl(rcx, 29);\n+  __ subl(rcx, r11);\n+  __ jcc(Assembler::lessEqual, L_2TAG_PACKET_10_0_1);\n+  __ shlq(r9);\n+  __ movq(rax, r10);\n+  __ shlq(r10);\n+  __ addl(rdx, rcx);\n+  __ negl(rcx);\n+  __ addl(rcx, 64);\n+  __ shrq(rax);\n+  __ shrq(r8);\n+  __ orq(r9, rax);\n+  __ orq(r10, r8);\n+\n+  __ bind(L_2TAG_PACKET_11_0_1);\n+  __ cvtsi2sdq(xmm0, r9);\n+  __ shrq(r10, 1);\n+  __ cvtsi2sdq(xmm3, r10);\n+  __ xorpd(xmm4, xmm4);\n+  __ shll(rdx, 4);\n+  __ negl(rdx);\n+  __ addl(rdx, 16368);\n+  __ orl(rdx, rsi);\n+  __ xorl(rdx, rbx);\n+  __ pinsrw(xmm4, rdx, 3);\n+  __ movq(xmm2, ExternalAddress(PI_4),     r8 \/*rscratch*\/); \/\/0x40000000UL, 0x3fe921fbUL, 0x18469899UL, 0x3e64442dUL\n+  __ movq(xmm6, ExternalAddress(PI_4 + 8), r8 \/*rscratch*\/); \/\/0x3fe921fbUL, 0x18469899UL, 0x3e64442dUL\n+  __ xorpd(xmm5, xmm5);\n+  __ subl(rdx, 1008);\n+  __ pinsrw(xmm5, rdx, 3);\n+  __ mulsd(xmm0, xmm4);\n+  __ shll(rsi, 16);\n+  __ sarl(rsi, 31);\n+  __ mulsd(xmm3, xmm5);\n+  __ movdqu(xmm1, xmm0);\n+  __ mulsd(xmm0, xmm2);\n+  __ shrl(rdi, 29);\n+  __ addsd(xmm1, xmm3);\n+  __ mulsd(xmm3, xmm2);\n+  __ addl(rdi, rsi);\n+  __ xorl(rdi, rsi);\n+  __ mulsd(xmm6, xmm1);\n+  __ movl(rax, rdi);\n+  __ addsd(xmm6, xmm3);\n+  __ movdqu(xmm2, xmm0);\n+  __ addsd(xmm0, xmm6);\n+  __ subsd(xmm2, xmm0);\n+  __ addsd(xmm6, xmm2);\n+\n+  __ bind(L_2TAG_PACKET_12_0_1);\n+  __ movq(xmm1, ExternalAddress(PI32INV), r8 \/*rscratch*\/);    \/\/0x6dc9c883UL, 0x40245f30UL\n+  __ mulsd(xmm1, xmm0);\n+  __ movq(xmm5, ExternalAddress(ONEHALF), r8 \/*rscratch*\/);    \/\/0x00000000UL, 0x3fe00000UL, 0x00000000UL, 0x3fe00000UL\n+  __ movq(xmm4, ExternalAddress(SIGN_MASK), r8 \/*rscratch*\/);  \/\/0x00000000UL, 0x80000000UL\n+  __ pand(xmm4, xmm0);\n+  __ por(xmm5, xmm4);\n+  __ addpd(xmm1, xmm5);\n+  __ cvttsd2sil(rdx, xmm1);\n+  __ cvtsi2sdl(xmm1, rdx);\n+  __ movq(xmm3, ExternalAddress(P_1), r8 \/*rscratch*\/);      \/\/0x54400000UL, 0x3fb921fbUL\n+  __ movdqu(xmm2, ExternalAddress(P_2), r8 \/*rscratch*\/);    \/\/0x1a600000UL, 0x3d90b461UL, 0x1a600000UL, 0x3d90b461UL\n+  __ mulsd(xmm3, xmm1);\n+  __ unpcklpd(xmm1, xmm1);\n+  __ shll(rax, 3);\n+  __ addl(rdx, 1865216);\n+  __ movdqu(xmm4, xmm0);\n+  __ addl(rdx, rax);\n+  __ andl(rdx, 63);\n+  __ movdqu(xmm5, ExternalAddress(SC_4), r8 \/*rscratch*\/);    \/\/0x54400000UL, 0x3fb921fbUL\n+  __ lea(rax, ExternalAddress(Ctable));\n+  __ shll(rdx, 5);\n+  __ addq(rax, rdx);\n+  __ mulpd(xmm2, xmm1);\n+  __ subsd(xmm0, xmm3);\n+  __ mulsd(xmm1, ExternalAddress(P_3), r8 \/*rscratch*\/);    \/\/0x2e037073UL, 0x3b63198aUL\n+  __ subsd(xmm4, xmm3);\n+  __ movq(xmm7, Address(rax, 8));\n+  __ unpcklpd(xmm0, xmm0);\n+  __ movdqu(xmm3, xmm4);\n+  __ subsd(xmm4, xmm2);\n+  __ mulpd(xmm5, xmm0);\n+  __ subpd(xmm0, xmm2);\n+  __ mulsd(xmm7, xmm4);\n+  __ subsd(xmm3, xmm4);\n+  __ mulpd(xmm5, xmm0);\n+  __ mulpd(xmm0, xmm0);\n+  __ subsd(xmm3, xmm2);\n+  __ movdqu(xmm2, Address(rax, 0));\n+  __ subsd(xmm1, xmm3);\n+  __ movq(xmm3, Address(rax, 24));\n+  __ addsd(xmm2, xmm3);\n+  __ subsd(xmm7, xmm2);\n+  __ subsd(xmm1, xmm6);\n+  __ movdqu(xmm6, ExternalAddress(SC_2), r8 \/*rscratch*\/);    \/\/0x11111111UL, 0x3f811111UL, 0x55555555UL, 0x3fa55555UL\n+  __ mulsd(xmm2, xmm4);\n+  __ mulpd(xmm6, xmm0);\n+  __ mulsd(xmm3, xmm4);\n+  __ mulpd(xmm2, xmm0);\n+  __ mulpd(xmm0, xmm0);\n+  __ addpd(xmm5, ExternalAddress(SC_3), r8 \/*rscratch*\/);    \/\/0x1a01a01aUL, 0xbf2a01a0UL, 0x16c16c17UL, 0xbf56c16cUL\n+  __ mulsd(xmm4, Address(rax, 0));\n+  __ addpd(xmm6, ExternalAddress(SC_1), r8 \/*rscratch*\/);    \/\/0x55555555UL, 0xbfc55555UL, 0x00000000UL, 0xbfe00000UL\n+  __ mulpd(xmm5, xmm0);\n+  __ movdqu(xmm0, xmm3);\n+  __ addsd(xmm3, Address(rax, 8));\n+  __ mulpd(xmm1, xmm7);\n+  __ movdqu(xmm7, xmm4);\n+  __ addsd(xmm4, xmm3);\n+  __ addpd(xmm6, xmm5);\n+  __ movq(xmm5, Address(rax, 8));\n+  __ subsd(xmm5, xmm3);\n+  __ subsd(xmm3, xmm4);\n+  __ addsd(xmm1, Address(rax, 16));\n+  __ mulpd(xmm6, xmm2);\n+  __ addsd(xmm5, xmm0);\n+  __ addsd(xmm3, xmm7);\n+  __ addsd(xmm1, xmm5);\n+  __ addsd(xmm1, xmm3);\n+  __ addsd(xmm1, xmm6);\n+  __ unpckhpd(xmm6, xmm6);\n+  __ movdqu(xmm0, xmm4);\n+  __ addsd(xmm1, xmm6);\n+  __ addsd(xmm0, xmm1);\n+  __ jmp(B1_4);\n+\n+  __ bind(L_2TAG_PACKET_8_0_1);\n+  __ addl(rdx, 64);\n+  __ movq(r9, r10);\n+  __ movq(r10, r8);\n+  __ movl(r8, 0);\n+  __ cmpq(r9, 0);\n+  __ jcc(Assembler::notEqual, L_2TAG_PACKET_9_0_1);\n+  __ addl(rdx, 64);\n+  __ movq(r9, r10);\n+  __ movq(r10, r8);\n+  __ cmpq(r9, 0);\n+  __ jcc(Assembler::notEqual, L_2TAG_PACKET_9_0_1);\n+  __ xorpd(xmm0, xmm0);\n+  __ xorpd(xmm6, xmm6);\n+  __ jmp(L_2TAG_PACKET_12_0_1);\n+\n+  __ bind(L_2TAG_PACKET_10_0_1);\n+  __ jcc(Assembler::equal, L_2TAG_PACKET_11_0_1);\n+  __ negl(rcx);\n+  __ shrq(r10);\n+  __ movq(rax, r9);\n+  __ shrq(r9);\n+  __ subl(rdx, rcx);\n+  __ negl(rcx);\n+  __ addl(rcx, 64);\n+  __ shlq(rax);\n+  __ orq(r10, rax);\n+  __ jmp(L_2TAG_PACKET_11_0_1);\n+\n+  __ bind(L_2TAG_PACKET_4_0_1);\n+  __ negl(rcx);\n+  __ shlq(r9, 32);\n+  __ orq(r9, r11);\n+  __ shlq(r9);\n+  __ movq(rdi, r9);\n+  __ testl(r9, INT_MIN);\n+  __ jcc(Assembler::notEqual, L_2TAG_PACKET_13_0_1);\n+  __ shrl(r9);\n+  __ movl(rbx, 0);\n+  __ shrq(rdi, 3);\n+  __ jmp(L_2TAG_PACKET_7_0_1);\n+\n+  __ bind(L_2TAG_PACKET_5_0_1);\n+  __ shrl(r9);\n+  __ movl(rbx, 536870912);\n+  __ shrl(rbx);\n+  __ shlq(r9, 32);\n+  __ orq(r9, r11);\n+  __ shlq(rbx, 32);\n+  __ addl(rdi, 536870912);\n+  __ movl(rcx, 0);\n+  __ movl(r11, 0);\n+  __ subq(rcx, r8);\n+  __ sbbq(r11, r10);\n+  __ sbbq(rbx, r9);\n+  __ movq(r8, rcx);\n+  __ movq(r10, r11);\n+  __ movq(r9, rbx);\n+  __ movl(rbx, 32768);\n+  __ jmp(L_2TAG_PACKET_6_0_1);\n+\n+  __ bind(L_2TAG_PACKET_13_0_1);\n+  __ shrl(r9);\n+  __ mov64(rbx, 0x100000000);\n+  __ shrq(rbx);\n+  __ movl(rcx, 0);\n+  __ movl(r11, 0);\n+  __ subq(rcx, r8);\n+  __ sbbq(r11, r10);\n+  __ sbbq(rbx, r9);\n+  __ movq(r8, rcx);\n+  __ movq(r10, r11);\n+  __ movq(r9, rbx);\n+  __ movl(rbx, 32768);\n+  __ shrq(rdi, 3);\n+  __ addl(rdi, 536870912);\n+  __ jmp(L_2TAG_PACKET_7_0_1);\n+\n+  __ bind(L_2TAG_PACKET_3_0_1);\n+  __ movq(xmm0, Address(rsp, 8));\n+  __ mulsd(xmm0, ExternalAddress(NEG_ZERO), r8 \/*rscratch*\/);    \/\/0x00000000UL, 0x80000000UL\n+  __ movq(Address(rsp, 0), xmm0);\n+\n+  __ bind(L_2TAG_PACKET_14_0_1);\n+\n+  __ bind(B1_4);\n+  __ addq(rsp, 16);\n+  __ pop(rbx);\n+\n+#ifdef _WIN64\n+  __ pop(rdi);\n+  __ pop(rsi);\n+#endif\n+\n+  __ leave(); \/\/ required for proper stackwalking of RuntimeStub frame\n+  __ ret(0);\n+\n+  return start;\n+}\n+\n+#undef __\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_sin.cpp","additions":651,"deletions":0,"binary":false,"changes":651,"status":"added"},{"patch":"@@ -0,0 +1,1031 @@\n+\/*\n+* Copyright (c) 2016, 2021, Intel Corporation. All rights reserved.\n+* Intel Math Library (LIBM) Source Code\n+*\n+* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+*\n+* This code is free software; you can redistribute it and\/or modify it\n+* under the terms of the GNU General Public License version 2 only, as\n+* published by the Free Software Foundation.\n+*\n+* This code is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+* FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+* version 2 for more details (a copy is included in the LICENSE file that\n+* accompanied this code).\n+*\n+* You should have received a copy of the GNU General Public License version\n+* 2 along with this work; if not, write to the Free Software Foundation,\n+* Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+*\n+* Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+* or visit www.oracle.com if you need additional information or have any\n+* questions.\n+*\n+*\/\n+\n+#include \"precompiled.hpp\"\n+#include \"macroAssembler_x86.hpp\"\n+#include \"stubGenerator_x86_64.hpp\"\n+\n+\/******************************************************************************\/\n+\/\/                     ALGORITHM DESCRIPTION - TAN()\n+\/\/                     ---------------------\n+\/\/\n+\/\/ Polynomials coefficients and other constants.\n+\/\/\n+\/\/ Note that in this algorithm, there is a different polynomial for\n+\/\/ each breakpoint, so there are 32 sets of polynomial coefficients\n+\/\/ as well as 32 instances of the other constants.\n+\/\/\n+\/\/ The polynomial coefficients and constants are offset from the start\n+\/\/ of the main block as follows:\n+\/\/\n+\/\/   0:  c8 | c0\n+\/\/  16:  c9 | c1\n+\/\/  32: c10 | c2\n+\/\/  48: c11 | c3\n+\/\/  64: c12 | c4\n+\/\/  80: c13 | c5\n+\/\/  96: c14 | c6\n+\/\/ 112: c15 | c7\n+\/\/ 128: T_hi\n+\/\/ 136: T_lo\n+\/\/ 144: Sigma\n+\/\/ 152: T_hl\n+\/\/ 160: Tau\n+\/\/ 168: Mask\n+\/\/ 176: (end of block)\n+\/\/\n+\/\/ The total table size is therefore 5632 bytes.\n+\/\/\n+\/\/ Note that c0 and c1 are always zero. We could try storing\n+\/\/ other constants here, and just loading the low part of the\n+\/\/ SIMD register in these cases, after ensuring the high part\n+\/\/ is zero.\n+\/\/\n+\/\/ The higher terms of the polynomial are computed in the *low*\n+\/\/ part of the SIMD register. This is so we can overlap the\n+\/\/ multiplication by r^8 and the unpacking of the other part.\n+\/\/\n+\/\/ The constants are:\n+\/\/ T_hi + T_lo = accurate constant term in power series\n+\/\/ Sigma + T_hl = accurate coefficient of r in power series (Sigma=1 bit)\n+\/\/ Tau = multiplier for the reciprocal, always -1 or 0\n+\/\/\n+\/\/ The basic reconstruction formula using these constants is:\n+\/\/\n+\/\/ High = tau * recip_hi + t_hi\n+\/\/ Med = (sgn * r + t_hl * r)_hi\n+\/\/ Low = (sgn * r + t_hl * r)_lo +\n+\/\/       tau * recip_lo + T_lo + (T_hl + sigma) * c + pol\n+\/\/\n+\/\/ where pol = c0 + c1 * r + c2 * r^2 + ... + c15 * r^15\n+\/\/\n+\/\/ (c0 = c1 = 0, but using them keeps SIMD regularity)\n+\/\/\n+\/\/ We then do a compensated sum High + Med, add the low parts together\n+\/\/ and then do the final sum.\n+\/\/\n+\/\/ Here recip_hi + recip_lo is an accurate reciprocal of the remainder\n+\/\/ modulo pi\/2\n+\/\/\n+\/\/ Special cases:\n+\/\/  tan(NaN) = quiet NaN, and raise invalid exception\n+\/\/  tan(INF) = NaN and raise invalid exception\n+\/\/  tan(+\/-0) = +\/-0\n+\/\/\n+\/******************************************************************************\/\n+\n+ATTRIBUTE_ALIGNED(16) juint _MUL16[] =\n+{\n+    0x00000000UL, 0x40300000UL, 0x00000000UL, 0x3ff00000UL\n+};\n+\n+ATTRIBUTE_ALIGNED(16) juint _sign_mask_tan[] =\n+{\n+    0x00000000UL, 0x80000000UL, 0x00000000UL, 0x80000000UL\n+};\n+\n+ATTRIBUTE_ALIGNED(16) juint _PI32INV_tan[] =\n+{\n+    0x6dc9c883UL, 0x3fe45f30UL, 0x6dc9c883UL, 0x40245f30UL\n+};\n+\n+ATTRIBUTE_ALIGNED(16) juint _P_1_tan[] =\n+{\n+    0x54444000UL, 0x3fb921fbUL, 0x54440000UL, 0x3fb921fbUL\n+};\n+\n+ATTRIBUTE_ALIGNED(16) juint _P_2_tan[] =\n+{\n+    0x67674000UL, 0xbd32e7b9UL, 0x4c4c0000UL, 0x3d468c23UL\n+};\n+\n+ATTRIBUTE_ALIGNED(16) juint _P_3_tan[] =\n+{\n+    0x3707344aUL, 0x3aa8a2e0UL, 0x03707345UL, 0x3ae98a2eUL\n+};\n+\n+ATTRIBUTE_ALIGNED(16) juint _Ctable_tan[] =\n+{\n+    0x00000000UL, 0x00000000UL, 0x00000000UL, 0x00000000UL, 0x882c10faUL,\n+    0x3f9664f4UL, 0x00000000UL, 0x00000000UL, 0x00000000UL, 0x00000000UL,\n+    0x00000000UL, 0x00000000UL, 0x55e6c23dUL, 0x3f8226e3UL, 0x55555555UL,\n+    0x3fd55555UL, 0x00000000UL, 0x00000000UL, 0x00000000UL, 0x00000000UL,\n+    0x0e157de0UL, 0x3f6d6d3dUL, 0x11111111UL, 0x3fc11111UL, 0x00000000UL,\n+    0x00000000UL, 0x00000000UL, 0x00000000UL, 0x452b75e3UL, 0x3f57da36UL,\n+    0x1ba1ba1cUL, 0x3faba1baUL, 0x00000000UL, 0x00000000UL, 0x00000000UL,\n+    0x00000000UL, 0x00000000UL, 0x3ff00000UL, 0x00000000UL, 0x00000000UL,\n+    0x00000000UL, 0x00000000UL, 0x00000000UL, 0x00000000UL, 0x4e435f9bUL,\n+    0x3f953f83UL, 0x00000000UL, 0x00000000UL, 0x3c6e8e46UL, 0x3f9b74eaUL,\n+    0x00000000UL, 0x00000000UL, 0xda5b7511UL, 0x3f85ad63UL, 0xdc230b9bUL,\n+    0x3fb97558UL, 0x26cb3788UL, 0x3f881308UL, 0x76fc4985UL, 0x3fd62ac9UL,\n+    0x77bb08baUL, 0x3f757c85UL, 0xb6247521UL, 0x3fb1381eUL, 0x5922170cUL,\n+    0x3f754e95UL, 0x8746482dUL, 0x3fc27f83UL, 0x11055b30UL, 0x3f64e391UL,\n+    0x3e666320UL, 0x3fa3e609UL, 0x0de9dae3UL, 0x3f6301dfUL, 0x1f1dca06UL,\n+    0x3fafa8aeUL, 0x8c5b2da2UL, 0x3fb936bbUL, 0x4e88f7a5UL, 0x3c587d05UL,\n+    0x00000000UL, 0x3ff00000UL, 0xa8935dd9UL, 0x3f83dde2UL, 0x00000000UL,\n+    0x00000000UL, 0x00000000UL, 0x00000000UL, 0x5a279ea3UL, 0x3faa3407UL,\n+    0x00000000UL, 0x00000000UL, 0x432d65faUL, 0x3fa70153UL, 0x00000000UL,\n+    0x00000000UL, 0x891a4602UL, 0x3f9d03efUL, 0xd62ca5f8UL, 0x3fca77d9UL,\n+    0xb35f4628UL, 0x3f97a265UL, 0x433258faUL, 0x3fd8cf51UL, 0xb58fd909UL,\n+    0x3f8f88e3UL, 0x01771ceaUL, 0x3fc2b154UL, 0xf3562f8eUL, 0x3f888f57UL,\n+    0xc028a723UL, 0x3fc7370fUL, 0x20b7f9f0UL, 0x3f80f44cUL, 0x214368e9UL,\n+    0x3fb6dfaaUL, 0x28891863UL, 0x3f79b4b6UL, 0x172dbbf0UL, 0x3fb6cb8eUL,\n+    0xe0553158UL, 0x3fc975f5UL, 0x593fe814UL, 0x3c2ef5d3UL, 0x00000000UL,\n+    0x3ff00000UL, 0x03dec550UL, 0x3fa44203UL, 0x00000000UL, 0x00000000UL,\n+    0x00000000UL, 0x00000000UL, 0x9314533eUL, 0x3fbb8ec5UL, 0x00000000UL,\n+    0x00000000UL, 0x09aa36d0UL, 0x3fb6d3f4UL, 0x00000000UL, 0x00000000UL,\n+    0xdcb427fdUL, 0x3fb13950UL, 0xd87ab0bbUL, 0x3fd5335eUL, 0xce0ae8a5UL,\n+    0x3fabb382UL, 0x79143126UL, 0x3fddba41UL, 0x5f2b28d4UL, 0x3fa552f1UL,\n+    0x59f21a6dUL, 0x3fd015abUL, 0x22c27d95UL, 0x3fa0e984UL, 0xe19fc6aaUL,\n+    0x3fd0576cUL, 0x8f2c2950UL, 0x3f9a4898UL, 0xc0b3f22cUL, 0x3fc59462UL,\n+    0x1883a4b8UL, 0x3f94b61cUL, 0x3f838640UL, 0x3fc30eb8UL, 0x355c63dcUL,\n+    0x3fd36a08UL, 0x1dce993dUL, 0xbc6d704dUL, 0x00000000UL, 0x3ff00000UL,\n+    0x2b82ab63UL, 0x3fb78e92UL, 0x00000000UL, 0x00000000UL, 0x00000000UL,\n+    0x00000000UL, 0x56f37042UL, 0x3fccfc56UL, 0x00000000UL, 0x00000000UL,\n+    0xaa563951UL, 0x3fc90125UL, 0x00000000UL, 0x00000000UL, 0x3d0e7c5dUL,\n+    0x3fc50533UL, 0x9bed9b2eUL, 0x3fdf0ed9UL, 0x5fe7c47cUL, 0x3fc1f250UL,\n+    0x96c125e5UL, 0x3fe2edd9UL, 0x5a02bbd8UL, 0x3fbe5c71UL, 0x86362c20UL,\n+    0x3fda08b7UL, 0x4b4435edUL, 0x3fb9d342UL, 0x4b494091UL, 0x3fd911bdUL,\n+    0xb56658beUL, 0x3fb5e4c7UL, 0x93a2fd76UL, 0x3fd3c092UL, 0xda271794UL,\n+    0x3fb29910UL, 0x3303df2bUL, 0x3fd189beUL, 0x99fcef32UL, 0x3fda8279UL,\n+    0xb68c1467UL, 0x3c708b2fUL, 0x00000000UL, 0x3ff00000UL, 0x980c4337UL,\n+    0x3fc5f619UL, 0x00000000UL, 0x00000000UL, 0x00000000UL, 0x00000000UL,\n+    0xcc03e501UL, 0x3fdff10fUL, 0x00000000UL, 0x00000000UL, 0x44a4e845UL,\n+    0x3fddb63bUL, 0x00000000UL, 0x00000000UL, 0x3768ad9fUL, 0x3fdb72a4UL,\n+    0x3dd01ccaUL, 0x3fe5fdb9UL, 0xa61d2811UL, 0x3fd972b2UL, 0x5645ad0bUL,\n+    0x3fe977f9UL, 0xd013b3abUL, 0x3fd78ca3UL, 0xbf0bf914UL, 0x3fe4f192UL,\n+    0x4d53e730UL, 0x3fd5d060UL, 0x3f8b9000UL, 0x3fe49933UL, 0xe2b82f08UL,\n+    0x3fd4322aUL, 0x5936a835UL, 0x3fe27ae1UL, 0xb1c61c9bUL, 0x3fd2b3fbUL,\n+    0xef478605UL, 0x3fe1659eUL, 0x190834ecUL, 0x3fe11ab7UL, 0xcdb625eaUL,\n+    0xbc8e564bUL, 0x00000000UL, 0x3ff00000UL, 0xb07217e3UL, 0x3fd248f1UL,\n+    0x00000000UL, 0x00000000UL, 0x00000000UL, 0x00000000UL, 0x2b2c49d0UL,\n+    0x3ff2de9cUL, 0x00000000UL, 0x00000000UL, 0x2655bc98UL, 0x3ff33e58UL,\n+    0x00000000UL, 0x00000000UL, 0xff691fa2UL, 0x3ff3972eUL, 0xe93463bdUL,\n+    0x3feeed87UL, 0x070e10a0UL, 0x3ff3f5b2UL, 0xf4d790a4UL, 0x3ff20c10UL,\n+    0xa04e8ea3UL, 0x3ff4541aUL, 0x386accd3UL, 0x3ff1369eUL, 0x222a66ddUL,\n+    0x3ff4b521UL, 0x22a9777eUL, 0x3ff20817UL, 0x52a04a6eUL, 0x3ff5178fUL,\n+    0xddaa0031UL, 0x3ff22137UL, 0x4447d47cUL, 0x3ff57c01UL, 0x1e9c7f1dUL,\n+    0x3ff29311UL, 0x2ab7f990UL, 0x3fe561b8UL, 0x209c7df1UL, 0x3c87a8c5UL,\n+    0x00000000UL, 0x3ff00000UL, 0x4170bcc6UL, 0x3fdc92d8UL, 0x00000000UL,\n+    0x00000000UL, 0x00000000UL, 0x00000000UL, 0xc7ab4d5aUL, 0x40085e24UL,\n+    0x00000000UL, 0x00000000UL, 0xe93ea75dUL, 0x400b963dUL, 0x00000000UL,\n+    0x00000000UL, 0x94a7f25aUL, 0x400f37e2UL, 0x4b6261cbUL, 0x3ff5f984UL,\n+    0x5a9dd812UL, 0x4011aab0UL, 0x74c30018UL, 0x3ffaf5a5UL, 0x7f2ce8e3UL,\n+    0x4013fe8bUL, 0xfe8e54faUL, 0x3ffd7334UL, 0x670d618dUL, 0x4016a10cUL,\n+    0x4db97058UL, 0x4000e012UL, 0x24df44ddUL, 0x40199c5fUL, 0x697d6eceUL,\n+    0x4003006eUL, 0x83298b82UL, 0x401cfc4dUL, 0x19d490d6UL, 0x40058c19UL,\n+    0x2ae42850UL, 0x3fea4300UL, 0x118e20e6UL, 0xbc7a6db8UL, 0x00000000UL,\n+    0x40000000UL, 0xe33345b8UL, 0xbfd4e526UL, 0x00000000UL, 0x00000000UL,\n+    0x00000000UL, 0x00000000UL, 0x65965966UL, 0x40219659UL, 0x00000000UL,\n+    0x00000000UL, 0x882c10faUL, 0x402664f4UL, 0x00000000UL, 0x00000000UL,\n+    0x83cd3723UL, 0x402c8342UL, 0x00000000UL, 0x40000000UL, 0x55e6c23dUL,\n+    0x403226e3UL, 0x55555555UL, 0x40055555UL, 0x34451939UL, 0x40371c96UL,\n+    0xaaaaaaabUL, 0x400aaaaaUL, 0x0e157de0UL, 0x403d6d3dUL, 0x11111111UL,\n+    0x40111111UL, 0xa738201fUL, 0x4042bbceUL, 0x05b05b06UL, 0x4015b05bUL,\n+    0x452b75e3UL, 0x4047da36UL, 0x1ba1ba1cUL, 0x401ba1baUL, 0x00000000UL,\n+    0x3ff00000UL, 0x00000000UL, 0x00000000UL, 0x00000000UL, 0x40000000UL,\n+    0x00000000UL, 0x00000000UL, 0x00000000UL, 0x00000000UL, 0x00000000UL,\n+    0x00000000UL, 0x4f48b8d3UL, 0xbf33eaf9UL, 0x00000000UL, 0x00000000UL,\n+    0x0cf7586fUL, 0x3f20b8eaUL, 0x00000000UL, 0x00000000UL, 0xd0258911UL,\n+    0xbf0abaf3UL, 0x23e49fe9UL, 0xbfab5a8cUL, 0x2d53222eUL, 0x3ef60d15UL,\n+    0x21169451UL, 0x3fa172b2UL, 0xbb254dbcUL, 0xbee1d3b5UL, 0xdbf93b8eUL,\n+    0xbf84c7dbUL, 0x05b4630bUL, 0x3ecd3364UL, 0xee9aada7UL, 0x3f743924UL,\n+    0x794a8297UL, 0xbeb7b7b9UL, 0xe015f797UL, 0xbf5d41f5UL, 0xe41a4a56UL,\n+    0x3ea35dfbUL, 0xe4c2a251UL, 0x3f49a2abUL, 0x5af9e000UL, 0xbfce49ceUL,\n+    0x8c743719UL, 0x3d1eb860UL, 0x00000000UL, 0x00000000UL, 0x1b4863cfUL,\n+    0x3fd78294UL, 0x00000000UL, 0x3ff00000UL, 0x00000000UL, 0xfffffff8UL,\n+    0x535ad890UL, 0xbf2b9320UL, 0x00000000UL, 0x00000000UL, 0x018fdf1fUL,\n+    0x3f16d61dUL, 0x00000000UL, 0x00000000UL, 0x0359f1beUL, 0xbf0139e4UL,\n+    0xa4317c6dUL, 0xbfa67e17UL, 0x82672d0fUL, 0x3eebb405UL, 0x2f1b621eUL,\n+    0x3f9f455bUL, 0x51ccf238UL, 0xbed55317UL, 0xf437b9acUL, 0xbf804beeUL,\n+    0xc791a2b5UL, 0x3ec0e993UL, 0x919a1db2UL, 0x3f7080c2UL, 0x336a5b0eUL,\n+    0xbeaa48a2UL, 0x0a268358UL, 0xbf55a443UL, 0xdfd978e4UL, 0x3e94b61fUL,\n+    0xd7767a58UL, 0x3f431806UL, 0x2aea0000UL, 0xbfc9bbe8UL, 0x7723ea61UL,\n+    0xbd3a2369UL, 0x00000000UL, 0x00000000UL, 0xdf7796ffUL, 0x3fd6e642UL,\n+    0x00000000UL, 0x3ff00000UL, 0x00000000UL, 0xfffffff8UL, 0xb9ff07ceUL,\n+    0xbf231c78UL, 0x00000000UL, 0x00000000UL, 0xa5517182UL, 0x3f0ff0e0UL,\n+    0x00000000UL, 0x00000000UL, 0x790b4cbcUL, 0xbef66191UL, 0x848a46c6UL,\n+    0xbfa21ac0UL, 0xb16435faUL, 0x3ee1d3ecUL, 0x2a1aa832UL, 0x3f9c71eaUL,\n+    0xfdd299efUL, 0xbec9dd1aUL, 0x3f8dbaafUL, 0xbf793363UL, 0x309fc6eaUL,\n+    0x3eb415d6UL, 0xbee60471UL, 0x3f6b83baUL, 0x94a0a697UL, 0xbe9dae11UL,\n+    0x3e5c67b3UL, 0xbf4fd07bUL, 0x9a8f3e3eUL, 0x3e86bd75UL, 0xa4beb7a4UL,\n+    0x3f3d1eb1UL, 0x29cfc000UL, 0xbfc549ceUL, 0xbf159358UL, 0xbd397b33UL,\n+    0x00000000UL, 0x00000000UL, 0x871fee6cUL, 0x3fd666f0UL, 0x00000000UL,\n+    0x3ff00000UL, 0x00000000UL, 0xfffffff8UL, 0x7d98a556UL, 0xbf1a3958UL,\n+    0x00000000UL, 0x00000000UL, 0x9d88dc01UL, 0x3f0704c2UL, 0x00000000UL,\n+    0x00000000UL, 0x73742a2bUL, 0xbeed054aUL, 0x58844587UL, 0xbf9c2a13UL,\n+    0x55688a79UL, 0x3ed7a326UL, 0xee33f1d6UL, 0x3f9a48f4UL, 0xa8dc9888UL,\n+    0xbebf8939UL, 0xaad4b5b8UL, 0xbf72f746UL, 0x9102efa1UL, 0x3ea88f82UL,\n+    0xdabc29cfUL, 0x3f678228UL, 0x9289afb8UL, 0xbe90f456UL, 0x741fb4edUL,\n+    0xbf46f3a3UL, 0xa97f6663UL, 0x3e79b4bfUL, 0xca89ff3fUL, 0x3f36db70UL,\n+    0xa8a2a000UL, 0xbfc0ee13UL, 0x3da24be1UL, 0xbd338b9fUL, 0x00000000UL,\n+    0x00000000UL, 0x11cd6c69UL, 0x3fd601fdUL, 0x00000000UL, 0x3ff00000UL,\n+    0x00000000UL, 0xfffffff8UL, 0x1a154b97UL, 0xbf116b01UL, 0x00000000UL,\n+    0x00000000UL, 0x2d427630UL, 0x3f0147bfUL, 0x00000000UL, 0x00000000UL,\n+    0xb93820c8UL, 0xbee264d4UL, 0xbb6cbb18UL, 0xbf94ab8cUL, 0x888d4d92UL,\n+    0x3ed0568bUL, 0x60730f7cUL, 0x3f98b19bUL, 0xe4b1fb11UL, 0xbeb2f950UL,\n+    0x22cf9f74UL, 0xbf6b21cdUL, 0x4a3ff0a6UL, 0x3e9f499eUL, 0xfd2b83ceUL,\n+    0x3f64aad7UL, 0x637b73afUL, 0xbe83487cUL, 0xe522591aUL, 0xbf3fc092UL,\n+    0xa158e8bcUL, 0x3e6e3aaeUL, 0xe5e82ffaUL, 0x3f329d2fUL, 0xd636a000UL,\n+    0xbfb9477fUL, 0xc2c2d2bcUL, 0xbd135ef9UL, 0x00000000UL, 0x00000000UL,\n+    0xf2fdb123UL, 0x3fd5b566UL, 0x00000000UL, 0x3ff00000UL, 0x00000000UL,\n+    0xfffffff8UL, 0xc41acb64UL, 0xbf05448dUL, 0x00000000UL, 0x00000000UL,\n+    0xdbb03d6fUL, 0x3efb7ad2UL, 0x00000000UL, 0x00000000UL, 0x9e42962dUL,\n+    0xbed5aea5UL, 0x2579f8efUL, 0xbf8b2398UL, 0x288a1ed9UL, 0x3ec81441UL,\n+    0xb0198dc5UL, 0x3f979a3aUL, 0x2fdfe253UL, 0xbea57cd3UL, 0x5766336fUL,\n+    0xbf617caaUL, 0x600944c3UL, 0x3e954ed6UL, 0xa4e0aaf8UL, 0x3f62c646UL,\n+    0x6b8fb29cUL, 0xbe74e3a3UL, 0xdc4c0409UL, 0xbf33f952UL, 0x9bffe365UL,\n+    0x3e6301ecUL, 0xb8869e44UL, 0x3f2fc566UL, 0xe1e04000UL, 0xbfb0cc62UL,\n+    0x016b907fUL, 0xbd119cbcUL, 0x00000000UL, 0x00000000UL, 0xe6b9d8faUL,\n+    0x3fd57fb3UL, 0x00000000UL, 0x3ff00000UL, 0x00000000UL, 0xfffffff8UL,\n+    0x5daf22a6UL, 0xbef429d7UL, 0x00000000UL, 0x00000000UL, 0x06bca545UL,\n+    0x3ef7a27dUL, 0x00000000UL, 0x00000000UL, 0x7211c19aUL, 0xbec41c3eUL,\n+    0x956ed53eUL, 0xbf7ae3f4UL, 0xee750e72UL, 0x3ec3901bUL, 0x91d443f5UL,\n+    0x3f96f713UL, 0x36661e6cUL, 0xbe936e09UL, 0x506f9381UL, 0xbf5122e8UL,\n+    0xcb6dd43fUL, 0x3e9041b9UL, 0x6698b2ffUL, 0x3f61b0c7UL, 0x576bf12bUL,\n+    0xbe625a8aUL, 0xe5a0e9dcUL, 0xbf23499dUL, 0x110384ddUL, 0x3e5b1c2cUL,\n+    0x68d43db6UL, 0x3f2cb899UL, 0x6ecac000UL, 0xbfa0c414UL, 0xcd7dd58cUL,\n+    0x3d13500fUL, 0x00000000UL, 0x00000000UL, 0x85a2c8fbUL, 0x3fd55fe0UL,\n+    0x00000000UL, 0x3ff00000UL, 0x00000000UL, 0xfffffff8UL, 0x00000000UL,\n+    0x00000000UL, 0x00000000UL, 0x00000000UL, 0x2bf70ebeUL, 0x3ef66a8fUL,\n+    0x00000000UL, 0x00000000UL, 0x00000000UL, 0x00000000UL, 0x00000000UL,\n+    0x00000000UL, 0xd644267fUL, 0x3ec22805UL, 0x16c16c17UL, 0x3f96c16cUL,\n+    0x00000000UL, 0x00000000UL, 0x00000000UL, 0x00000000UL, 0xc4e09162UL,\n+    0x3e8d6db2UL, 0xbc011567UL, 0x3f61566aUL, 0x00000000UL, 0x00000000UL,\n+    0x00000000UL, 0x00000000UL, 0x1f79955cUL, 0x3e57da4eUL, 0x9334ef0bUL,\n+    0x3f2bbd77UL, 0x00000000UL, 0x00000000UL, 0x00000000UL, 0x00000000UL,\n+    0x00000000UL, 0x00000000UL, 0x55555555UL, 0x3fd55555UL, 0x00000000UL,\n+    0x3ff00000UL, 0x00000000UL, 0xfffffff8UL, 0x5daf22a6UL, 0x3ef429d7UL,\n+    0x00000000UL, 0x00000000UL, 0x06bca545UL, 0x3ef7a27dUL, 0x00000000UL,\n+    0x00000000UL, 0x7211c19aUL, 0x3ec41c3eUL, 0x956ed53eUL, 0x3f7ae3f4UL,\n+    0xee750e72UL, 0x3ec3901bUL, 0x91d443f5UL, 0x3f96f713UL, 0x36661e6cUL,\n+    0x3e936e09UL, 0x506f9381UL, 0x3f5122e8UL, 0xcb6dd43fUL, 0x3e9041b9UL,\n+    0x6698b2ffUL, 0x3f61b0c7UL, 0x576bf12bUL, 0x3e625a8aUL, 0xe5a0e9dcUL,\n+    0x3f23499dUL, 0x110384ddUL, 0x3e5b1c2cUL, 0x68d43db6UL, 0x3f2cb899UL,\n+    0x6ecac000UL, 0x3fa0c414UL, 0xcd7dd58cUL, 0xbd13500fUL, 0x00000000UL,\n+    0x00000000UL, 0x85a2c8fbUL, 0x3fd55fe0UL, 0x00000000UL, 0x3ff00000UL,\n+    0x00000000UL, 0xfffffff8UL, 0xc41acb64UL, 0x3f05448dUL, 0x00000000UL,\n+    0x00000000UL, 0xdbb03d6fUL, 0x3efb7ad2UL, 0x00000000UL, 0x00000000UL,\n+    0x9e42962dUL, 0x3ed5aea5UL, 0x2579f8efUL, 0x3f8b2398UL, 0x288a1ed9UL,\n+    0x3ec81441UL, 0xb0198dc5UL, 0x3f979a3aUL, 0x2fdfe253UL, 0x3ea57cd3UL,\n+    0x5766336fUL, 0x3f617caaUL, 0x600944c3UL, 0x3e954ed6UL, 0xa4e0aaf8UL,\n+    0x3f62c646UL, 0x6b8fb29cUL, 0x3e74e3a3UL, 0xdc4c0409UL, 0x3f33f952UL,\n+    0x9bffe365UL, 0x3e6301ecUL, 0xb8869e44UL, 0x3f2fc566UL, 0xe1e04000UL,\n+    0x3fb0cc62UL, 0x016b907fUL, 0x3d119cbcUL, 0x00000000UL, 0x00000000UL,\n+    0xe6b9d8faUL, 0x3fd57fb3UL, 0x00000000UL, 0x3ff00000UL, 0x00000000UL,\n+    0xfffffff8UL, 0x1a154b97UL, 0x3f116b01UL, 0x00000000UL, 0x00000000UL,\n+    0x2d427630UL, 0x3f0147bfUL, 0x00000000UL, 0x00000000UL, 0xb93820c8UL,\n+    0x3ee264d4UL, 0xbb6cbb18UL, 0x3f94ab8cUL, 0x888d4d92UL, 0x3ed0568bUL,\n+    0x60730f7cUL, 0x3f98b19bUL, 0xe4b1fb11UL, 0x3eb2f950UL, 0x22cf9f74UL,\n+    0x3f6b21cdUL, 0x4a3ff0a6UL, 0x3e9f499eUL, 0xfd2b83ceUL, 0x3f64aad7UL,\n+    0x637b73afUL, 0x3e83487cUL, 0xe522591aUL, 0x3f3fc092UL, 0xa158e8bcUL,\n+    0x3e6e3aaeUL, 0xe5e82ffaUL, 0x3f329d2fUL, 0xd636a000UL, 0x3fb9477fUL,\n+    0xc2c2d2bcUL, 0x3d135ef9UL, 0x00000000UL, 0x00000000UL, 0xf2fdb123UL,\n+    0x3fd5b566UL, 0x00000000UL, 0x3ff00000UL, 0x00000000UL, 0xfffffff8UL,\n+    0x7d98a556UL, 0x3f1a3958UL, 0x00000000UL, 0x00000000UL, 0x9d88dc01UL,\n+    0x3f0704c2UL, 0x00000000UL, 0x00000000UL, 0x73742a2bUL, 0x3eed054aUL,\n+    0x58844587UL, 0x3f9c2a13UL, 0x55688a79UL, 0x3ed7a326UL, 0xee33f1d6UL,\n+    0x3f9a48f4UL, 0xa8dc9888UL, 0x3ebf8939UL, 0xaad4b5b8UL, 0x3f72f746UL,\n+    0x9102efa1UL, 0x3ea88f82UL, 0xdabc29cfUL, 0x3f678228UL, 0x9289afb8UL,\n+    0x3e90f456UL, 0x741fb4edUL, 0x3f46f3a3UL, 0xa97f6663UL, 0x3e79b4bfUL,\n+    0xca89ff3fUL, 0x3f36db70UL, 0xa8a2a000UL, 0x3fc0ee13UL, 0x3da24be1UL,\n+    0x3d338b9fUL, 0x00000000UL, 0x00000000UL, 0x11cd6c69UL, 0x3fd601fdUL,\n+    0x00000000UL, 0x3ff00000UL, 0x00000000UL, 0xfffffff8UL, 0xb9ff07ceUL,\n+    0x3f231c78UL, 0x00000000UL, 0x00000000UL, 0xa5517182UL, 0x3f0ff0e0UL,\n+    0x00000000UL, 0x00000000UL, 0x790b4cbcUL, 0x3ef66191UL, 0x848a46c6UL,\n+    0x3fa21ac0UL, 0xb16435faUL, 0x3ee1d3ecUL, 0x2a1aa832UL, 0x3f9c71eaUL,\n+    0xfdd299efUL, 0x3ec9dd1aUL, 0x3f8dbaafUL, 0x3f793363UL, 0x309fc6eaUL,\n+    0x3eb415d6UL, 0xbee60471UL, 0x3f6b83baUL, 0x94a0a697UL, 0x3e9dae11UL,\n+    0x3e5c67b3UL, 0x3f4fd07bUL, 0x9a8f3e3eUL, 0x3e86bd75UL, 0xa4beb7a4UL,\n+    0x3f3d1eb1UL, 0x29cfc000UL, 0x3fc549ceUL, 0xbf159358UL, 0x3d397b33UL,\n+    0x00000000UL, 0x00000000UL, 0x871fee6cUL, 0x3fd666f0UL, 0x00000000UL,\n+    0x3ff00000UL, 0x00000000UL, 0xfffffff8UL, 0x535ad890UL, 0x3f2b9320UL,\n+    0x00000000UL, 0x00000000UL, 0x018fdf1fUL, 0x3f16d61dUL, 0x00000000UL,\n+    0x00000000UL, 0x0359f1beUL, 0x3f0139e4UL, 0xa4317c6dUL, 0x3fa67e17UL,\n+    0x82672d0fUL, 0x3eebb405UL, 0x2f1b621eUL, 0x3f9f455bUL, 0x51ccf238UL,\n+    0x3ed55317UL, 0xf437b9acUL, 0x3f804beeUL, 0xc791a2b5UL, 0x3ec0e993UL,\n+    0x919a1db2UL, 0x3f7080c2UL, 0x336a5b0eUL, 0x3eaa48a2UL, 0x0a268358UL,\n+    0x3f55a443UL, 0xdfd978e4UL, 0x3e94b61fUL, 0xd7767a58UL, 0x3f431806UL,\n+    0x2aea0000UL, 0x3fc9bbe8UL, 0x7723ea61UL, 0x3d3a2369UL, 0x00000000UL,\n+    0x00000000UL, 0xdf7796ffUL, 0x3fd6e642UL, 0x00000000UL, 0x3ff00000UL,\n+    0x00000000UL, 0xfffffff8UL, 0x4f48b8d3UL, 0x3f33eaf9UL, 0x00000000UL,\n+    0x00000000UL, 0x0cf7586fUL, 0x3f20b8eaUL, 0x00000000UL, 0x00000000UL,\n+    0xd0258911UL, 0x3f0abaf3UL, 0x23e49fe9UL, 0x3fab5a8cUL, 0x2d53222eUL,\n+    0x3ef60d15UL, 0x21169451UL, 0x3fa172b2UL, 0xbb254dbcUL, 0x3ee1d3b5UL,\n+    0xdbf93b8eUL, 0x3f84c7dbUL, 0x05b4630bUL, 0x3ecd3364UL, 0xee9aada7UL,\n+    0x3f743924UL, 0x794a8297UL, 0x3eb7b7b9UL, 0xe015f797UL, 0x3f5d41f5UL,\n+    0xe41a4a56UL, 0x3ea35dfbUL, 0xe4c2a251UL, 0x3f49a2abUL, 0x5af9e000UL,\n+    0x3fce49ceUL, 0x8c743719UL, 0xbd1eb860UL, 0x00000000UL, 0x00000000UL,\n+    0x1b4863cfUL, 0x3fd78294UL, 0x00000000UL, 0x3ff00000UL, 0x00000000UL,\n+    0xfffffff8UL, 0x65965966UL, 0xc0219659UL, 0x00000000UL, 0x00000000UL,\n+    0x882c10faUL, 0x402664f4UL, 0x00000000UL, 0x00000000UL, 0x83cd3723UL,\n+    0xc02c8342UL, 0x00000000UL, 0xc0000000UL, 0x55e6c23dUL, 0x403226e3UL,\n+    0x55555555UL, 0x40055555UL, 0x34451939UL, 0xc0371c96UL, 0xaaaaaaabUL,\n+    0xc00aaaaaUL, 0x0e157de0UL, 0x403d6d3dUL, 0x11111111UL, 0x40111111UL,\n+    0xa738201fUL, 0xc042bbceUL, 0x05b05b06UL, 0xc015b05bUL, 0x452b75e3UL,\n+    0x4047da36UL, 0x1ba1ba1cUL, 0x401ba1baUL, 0x00000000UL, 0xbff00000UL,\n+    0x00000000UL, 0x00000000UL, 0x00000000UL, 0x40000000UL, 0x00000000UL,\n+    0x00000000UL, 0x00000000UL, 0x00000000UL, 0x00000000UL, 0x00000000UL,\n+    0xc7ab4d5aUL, 0xc0085e24UL, 0x00000000UL, 0x00000000UL, 0xe93ea75dUL,\n+    0x400b963dUL, 0x00000000UL, 0x00000000UL, 0x94a7f25aUL, 0xc00f37e2UL,\n+    0x4b6261cbUL, 0xbff5f984UL, 0x5a9dd812UL, 0x4011aab0UL, 0x74c30018UL,\n+    0x3ffaf5a5UL, 0x7f2ce8e3UL, 0xc013fe8bUL, 0xfe8e54faUL, 0xbffd7334UL,\n+    0x670d618dUL, 0x4016a10cUL, 0x4db97058UL, 0x4000e012UL, 0x24df44ddUL,\n+    0xc0199c5fUL, 0x697d6eceUL, 0xc003006eUL, 0x83298b82UL, 0x401cfc4dUL,\n+    0x19d490d6UL, 0x40058c19UL, 0x2ae42850UL, 0xbfea4300UL, 0x118e20e6UL,\n+    0x3c7a6db8UL, 0x00000000UL, 0x40000000UL, 0xe33345b8UL, 0xbfd4e526UL,\n+    0x00000000UL, 0x00000000UL, 0x00000000UL, 0x00000000UL, 0x2b2c49d0UL,\n+    0xbff2de9cUL, 0x00000000UL, 0x00000000UL, 0x2655bc98UL, 0x3ff33e58UL,\n+    0x00000000UL, 0x00000000UL, 0xff691fa2UL, 0xbff3972eUL, 0xe93463bdUL,\n+    0xbfeeed87UL, 0x070e10a0UL, 0x3ff3f5b2UL, 0xf4d790a4UL, 0x3ff20c10UL,\n+    0xa04e8ea3UL, 0xbff4541aUL, 0x386accd3UL, 0xbff1369eUL, 0x222a66ddUL,\n+    0x3ff4b521UL, 0x22a9777eUL, 0x3ff20817UL, 0x52a04a6eUL, 0xbff5178fUL,\n+    0xddaa0031UL, 0xbff22137UL, 0x4447d47cUL, 0x3ff57c01UL, 0x1e9c7f1dUL,\n+    0x3ff29311UL, 0x2ab7f990UL, 0xbfe561b8UL, 0x209c7df1UL, 0xbc87a8c5UL,\n+    0x00000000UL, 0x3ff00000UL, 0x4170bcc6UL, 0x3fdc92d8UL, 0x00000000UL,\n+    0x00000000UL, 0x00000000UL, 0x00000000UL, 0xcc03e501UL, 0xbfdff10fUL,\n+    0x00000000UL, 0x00000000UL, 0x44a4e845UL, 0x3fddb63bUL, 0x00000000UL,\n+    0x00000000UL, 0x3768ad9fUL, 0xbfdb72a4UL, 0x3dd01ccaUL, 0xbfe5fdb9UL,\n+    0xa61d2811UL, 0x3fd972b2UL, 0x5645ad0bUL, 0x3fe977f9UL, 0xd013b3abUL,\n+    0xbfd78ca3UL, 0xbf0bf914UL, 0xbfe4f192UL, 0x4d53e730UL, 0x3fd5d060UL,\n+    0x3f8b9000UL, 0x3fe49933UL, 0xe2b82f08UL, 0xbfd4322aUL, 0x5936a835UL,\n+    0xbfe27ae1UL, 0xb1c61c9bUL, 0x3fd2b3fbUL, 0xef478605UL, 0x3fe1659eUL,\n+    0x190834ecUL, 0xbfe11ab7UL, 0xcdb625eaUL, 0x3c8e564bUL, 0x00000000UL,\n+    0x3ff00000UL, 0xb07217e3UL, 0x3fd248f1UL, 0x00000000UL, 0x00000000UL,\n+    0x00000000UL, 0x00000000UL, 0x56f37042UL, 0xbfccfc56UL, 0x00000000UL,\n+    0x00000000UL, 0xaa563951UL, 0x3fc90125UL, 0x00000000UL, 0x00000000UL,\n+    0x3d0e7c5dUL, 0xbfc50533UL, 0x9bed9b2eUL, 0xbfdf0ed9UL, 0x5fe7c47cUL,\n+    0x3fc1f250UL, 0x96c125e5UL, 0x3fe2edd9UL, 0x5a02bbd8UL, 0xbfbe5c71UL,\n+    0x86362c20UL, 0xbfda08b7UL, 0x4b4435edUL, 0x3fb9d342UL, 0x4b494091UL,\n+    0x3fd911bdUL, 0xb56658beUL, 0xbfb5e4c7UL, 0x93a2fd76UL, 0xbfd3c092UL,\n+    0xda271794UL, 0x3fb29910UL, 0x3303df2bUL, 0x3fd189beUL, 0x99fcef32UL,\n+    0xbfda8279UL, 0xb68c1467UL, 0xbc708b2fUL, 0x00000000UL, 0x3ff00000UL,\n+    0x980c4337UL, 0x3fc5f619UL, 0x00000000UL, 0x00000000UL, 0x00000000UL,\n+    0x00000000UL, 0x9314533eUL, 0xbfbb8ec5UL, 0x00000000UL, 0x00000000UL,\n+    0x09aa36d0UL, 0x3fb6d3f4UL, 0x00000000UL, 0x00000000UL, 0xdcb427fdUL,\n+    0xbfb13950UL, 0xd87ab0bbUL, 0xbfd5335eUL, 0xce0ae8a5UL, 0x3fabb382UL,\n+    0x79143126UL, 0x3fddba41UL, 0x5f2b28d4UL, 0xbfa552f1UL, 0x59f21a6dUL,\n+    0xbfd015abUL, 0x22c27d95UL, 0x3fa0e984UL, 0xe19fc6aaUL, 0x3fd0576cUL,\n+    0x8f2c2950UL, 0xbf9a4898UL, 0xc0b3f22cUL, 0xbfc59462UL, 0x1883a4b8UL,\n+    0x3f94b61cUL, 0x3f838640UL, 0x3fc30eb8UL, 0x355c63dcUL, 0xbfd36a08UL,\n+    0x1dce993dUL, 0x3c6d704dUL, 0x00000000UL, 0x3ff00000UL, 0x2b82ab63UL,\n+    0x3fb78e92UL, 0x00000000UL, 0x00000000UL, 0x00000000UL, 0x00000000UL,\n+    0x5a279ea3UL, 0xbfaa3407UL, 0x00000000UL, 0x00000000UL, 0x432d65faUL,\n+    0x3fa70153UL, 0x00000000UL, 0x00000000UL, 0x891a4602UL, 0xbf9d03efUL,\n+    0xd62ca5f8UL, 0xbfca77d9UL, 0xb35f4628UL, 0x3f97a265UL, 0x433258faUL,\n+    0x3fd8cf51UL, 0xb58fd909UL, 0xbf8f88e3UL, 0x01771ceaUL, 0xbfc2b154UL,\n+    0xf3562f8eUL, 0x3f888f57UL, 0xc028a723UL, 0x3fc7370fUL, 0x20b7f9f0UL,\n+    0xbf80f44cUL, 0x214368e9UL, 0xbfb6dfaaUL, 0x28891863UL, 0x3f79b4b6UL,\n+    0x172dbbf0UL, 0x3fb6cb8eUL, 0xe0553158UL, 0xbfc975f5UL, 0x593fe814UL,\n+    0xbc2ef5d3UL, 0x00000000UL, 0x3ff00000UL, 0x03dec550UL, 0x3fa44203UL,\n+    0x00000000UL, 0x00000000UL, 0x00000000UL, 0x00000000UL, 0x4e435f9bUL,\n+    0xbf953f83UL, 0x00000000UL, 0x00000000UL, 0x3c6e8e46UL, 0x3f9b74eaUL,\n+    0x00000000UL, 0x00000000UL, 0xda5b7511UL, 0xbf85ad63UL, 0xdc230b9bUL,\n+    0xbfb97558UL, 0x26cb3788UL, 0x3f881308UL, 0x76fc4985UL, 0x3fd62ac9UL,\n+    0x77bb08baUL, 0xbf757c85UL, 0xb6247521UL, 0xbfb1381eUL, 0x5922170cUL,\n+    0x3f754e95UL, 0x8746482dUL, 0x3fc27f83UL, 0x11055b30UL, 0xbf64e391UL,\n+    0x3e666320UL, 0xbfa3e609UL, 0x0de9dae3UL, 0x3f6301dfUL, 0x1f1dca06UL,\n+    0x3fafa8aeUL, 0x8c5b2da2UL, 0xbfb936bbUL, 0x4e88f7a5UL, 0xbc587d05UL,\n+    0x00000000UL, 0x3ff00000UL, 0xa8935dd9UL, 0x3f83dde2UL, 0x00000000UL,\n+    0x00000000UL, 0x00000000UL, 0x00000000UL\n+};\n+\n+ATTRIBUTE_ALIGNED(16) juint _MASK_35_tan[] =\n+{\n+    0xfffc0000UL, 0xffffffffUL, 0x00000000UL, 0x00000000UL\n+};\n+\n+ATTRIBUTE_ALIGNED(16) juint _Q_11_tan[] =\n+{\n+    0xb8fe4d77UL, 0x3f82609aUL\n+};\n+\n+ATTRIBUTE_ALIGNED(16) juint _Q_9_tan[] =\n+{\n+    0xbf847a43UL, 0x3f9664a0UL\n+};\n+\n+ATTRIBUTE_ALIGNED(16) juint _Q_7_tan[] =\n+{\n+    0x52c4c8abUL, 0x3faba1baUL\n+};\n+\n+ATTRIBUTE_ALIGNED(16) juint _Q_5_tan[] =\n+{\n+    0x11092746UL, 0x3fc11111UL\n+};\n+\n+ATTRIBUTE_ALIGNED(16) juint _Q_3_tan[] =\n+{\n+    0x55555612UL, 0x3fd55555UL\n+};\n+\n+ATTRIBUTE_ALIGNED(8) juint _PI_4_tan[] =\n+{\n+    0x00000000UL, 0x3fe921fbUL, 0x4611a626UL, 0x3e85110bUL\n+};\n+\n+ATTRIBUTE_ALIGNED(8) juint _QQ_2_tan[] =\n+{\n+    0x676733afUL, 0x3d32e7b9UL\n+};\n+\n+#define __ _masm->\n+\n+address StubGenerator::generate_libmTan() {\n+  StubCodeMark mark(this, \"StubRoutines\", \"libmTan\");\n+  address start = __ pc();\n+\n+  Label L_2TAG_PACKET_0_0_1, L_2TAG_PACKET_1_0_1, L_2TAG_PACKET_2_0_1, L_2TAG_PACKET_3_0_1;\n+  Label L_2TAG_PACKET_4_0_1, L_2TAG_PACKET_5_0_1, L_2TAG_PACKET_6_0_1, L_2TAG_PACKET_7_0_1;\n+  Label L_2TAG_PACKET_8_0_1, L_2TAG_PACKET_9_0_1, L_2TAG_PACKET_10_0_1, L_2TAG_PACKET_11_0_1;\n+  Label L_2TAG_PACKET_12_0_1, L_2TAG_PACKET_13_0_1, L_2TAG_PACKET_14_0_1, B1_2, B1_4;\n+\n+  address MUL16     = (address)_MUL16;\n+  address sign_mask = (address)_sign_mask_tan;\n+  address PI32INV   = (address)_PI32INV_tan;\n+  address P_1       = (address)_P_1_tan;\n+  address P_2       = (address)_P_2_tan;\n+  address P_3       = (address)_P_3_tan;\n+  address Ctable    = (address)_Ctable_tan;\n+  address MASK_35   = (address)_MASK_35_tan;\n+  address Q_11      = (address)_Q_11_tan;\n+  address Q_9       = (address)_Q_9_tan;\n+  address Q_7       = (address)_Q_7_tan;\n+  address Q_5       = (address)_Q_5_tan;\n+  address Q_3       = (address)_Q_3_tan;\n+  address PI_4      = (address)_PI_4_tan;\n+  address QQ_2      = (address)_QQ_2_tan;\n+\n+  __ enter(); \/\/ required for proper stackwalking of RuntimeStub frame\n+\n+#ifdef _WIN64\n+  __ push(rsi);\n+  __ push(rdi);\n+#endif\n+\n+  __ push(rbx);\n+  __ subq(rsp, 16);\n+  __ movsd(Address(rsp, 8), xmm0);\n+\n+  __ bind(B1_2);\n+  __ pextrw(rax, xmm0, 3);\n+  __ andl(rax, 32767);\n+  __ subl(rax, 16314);\n+  __ cmpl(rax, 270);\n+  __ jcc(Assembler::above, L_2TAG_PACKET_0_0_1);\n+  __ movdqu(xmm5, ExternalAddress(ONEHALF), rbx \/*rscratch*\/);    \/\/0x00000000UL, 0x3fe00000UL, 0x00000000UL, 0x3fe00000UL\n+  __ movdqu(xmm6, ExternalAddress(MUL16), rbx \/*rscratch*\/);    \/\/0x00000000UL, 0x40300000UL, 0x00000000UL, 0x3ff00000UL\n+  __ unpcklpd(xmm0, xmm0);\n+  __ movdqu(xmm4, ExternalAddress(sign_mask), rbx \/*rscratch*\/);    \/\/0x00000000UL, 0x80000000UL, 0x00000000UL, 0x80000000UL\n+  __ andpd(xmm4, xmm0);\n+  __ movdqu(xmm1, ExternalAddress(PI32INV), rbx \/*rscratch*\/);    \/\/0x6dc9c883UL, 0x3fe45f30UL, 0x6dc9c883UL, 0x40245f30UL\n+  __ mulpd(xmm1, xmm0);\n+  __ por(xmm5, xmm4);\n+  __ addpd(xmm1, xmm5);\n+  __ movdqu(xmm7, xmm1);\n+  __ unpckhpd(xmm7, xmm7);\n+  __ cvttsd2sil(rdx, xmm7);\n+  __ cvttpd2dq(xmm1, xmm1);\n+  __ cvtdq2pd(xmm1, xmm1);\n+  __ mulpd(xmm1, xmm6);\n+  __ movdqu(xmm3, ExternalAddress(P_1), rbx \/*rscratch*\/);    \/\/0x54444000UL, 0x3fb921fbUL, 0x54440000UL, 0x3fb921fbUL\n+  __ movq(xmm5, ExternalAddress(QQ_2), rbx \/*rscratch*\/);    \/\/0x676733afUL, 0x3d32e7b9UL\n+  __ addq(rdx, 469248);\n+  __ movdqu(xmm4, ExternalAddress(P_2), rbx \/*rscratch*\/);    \/\/0x67674000UL, 0xbd32e7b9UL, 0x4c4c0000UL, 0x3d468c23UL\n+  __ mulpd(xmm3, xmm1);\n+  __ andq(rdx, 31);\n+  __ mulsd(xmm5, xmm1);\n+  __ movq(rcx, rdx);\n+  __ mulpd(xmm4, xmm1);\n+  __ shlq(rcx, 1);\n+  __ subpd(xmm0, xmm3);\n+  __ mulpd(xmm1, ExternalAddress(P_3), rbx \/*rscratch*\/);    \/\/0x3707344aUL, 0x3aa8a2e0UL, 0x03707345UL, 0x3ae98a2eUL\n+  __ addq(rdx, rcx);\n+  __ shlq(rcx, 2);\n+  __ addq(rdx, rcx);\n+  __ addsd(xmm5, xmm0);\n+  __ movdqu(xmm2, xmm0);\n+  __ subpd(xmm0, xmm4);\n+  __ movq(xmm6, ExternalAddress(ONE), rbx \/*rscratch*\/);    \/\/0x00000000UL, 0x3ff00000UL\n+  __ shlq(rdx, 4);\n+  __ lea(rax, ExternalAddress(Ctable));\n+  __ andpd(xmm5, ExternalAddress(MASK_35), rbx \/*rscratch*\/);    \/\/0xfffc0000UL, 0xffffffffUL, 0x00000000UL, 0x00000000UL\n+  __ movdqu(xmm3, xmm0);\n+  __ addq(rax, rdx);\n+  __ subpd(xmm2, xmm0);\n+  __ unpckhpd(xmm0, xmm0);\n+  __ divsd(xmm6, xmm5);\n+  __ subpd(xmm2, xmm4);\n+  __ movdqu(xmm7, Address(rax, 16));\n+  __ subsd(xmm3, xmm5);\n+  __ mulpd(xmm7, xmm0);\n+  __ subpd(xmm2, xmm1);\n+  __ movdqu(xmm1, Address(rax, 48));\n+  __ mulpd(xmm1, xmm0);\n+  __ movdqu(xmm4, Address(rax, 96));\n+  __ mulpd(xmm4, xmm0);\n+  __ addsd(xmm2, xmm3);\n+  __ movdqu(xmm3, xmm0);\n+  __ mulpd(xmm0, xmm0);\n+  __ addpd(xmm7, Address(rax, 0));\n+  __ addpd(xmm1, Address(rax, 32));\n+  __ mulpd(xmm1, xmm0);\n+  __ addpd(xmm4, Address(rax, 80));\n+  __ addpd(xmm7, xmm1);\n+  __ movdqu(xmm1, Address(rax, 112));\n+  __ mulpd(xmm1, xmm0);\n+  __ mulpd(xmm0, xmm0);\n+  __ addpd(xmm4, xmm1);\n+  __ movdqu(xmm1, Address(rax, 64));\n+  __ mulpd(xmm1, xmm0);\n+  __ addpd(xmm7, xmm1);\n+  __ movdqu(xmm1, xmm3);\n+  __ mulpd(xmm3, xmm0);\n+  __ mulsd(xmm0, xmm0);\n+  __ mulpd(xmm1, Address(rax, 144));\n+  __ mulpd(xmm4, xmm3);\n+  __ movdqu(xmm3, xmm1);\n+  __ addpd(xmm7, xmm4);\n+  __ movdqu(xmm4, xmm1);\n+  __ mulsd(xmm0, xmm7);\n+  __ unpckhpd(xmm7, xmm7);\n+  __ addsd(xmm0, xmm7);\n+  __ unpckhpd(xmm1, xmm1);\n+  __ addsd(xmm3, xmm1);\n+  __ subsd(xmm4, xmm3);\n+  __ addsd(xmm1, xmm4);\n+  __ movdqu(xmm4, xmm2);\n+  __ movq(xmm7, Address(rax, 144));\n+  __ unpckhpd(xmm2, xmm2);\n+  __ addsd(xmm7, Address(rax, 152));\n+  __ mulsd(xmm7, xmm2);\n+  __ addsd(xmm7, Address(rax, 136));\n+  __ addsd(xmm7, xmm1);\n+  __ addsd(xmm0, xmm7);\n+  __ movq(xmm7, ExternalAddress(ONE), rbx \/*rscratch*\/);    \/\/0x00000000UL, 0x3ff00000UL\n+  __ mulsd(xmm4, xmm6);\n+  __ movq(xmm2, Address(rax, 168));\n+  __ andpd(xmm2, xmm6);\n+  __ mulsd(xmm5, xmm2);\n+  __ mulsd(xmm6, Address(rax, 160));\n+  __ subsd(xmm7, xmm5);\n+  __ subsd(xmm2, Address(rax, 128));\n+  __ subsd(xmm7, xmm4);\n+  __ mulsd(xmm7, xmm6);\n+  __ movdqu(xmm4, xmm3);\n+  __ subsd(xmm3, xmm2);\n+  __ addsd(xmm2, xmm3);\n+  __ subsd(xmm4, xmm2);\n+  __ addsd(xmm0, xmm4);\n+  __ subsd(xmm0, xmm7);\n+  __ addsd(xmm0, xmm3);\n+  __ jmp(B1_4);\n+\n+  __ bind(L_2TAG_PACKET_0_0_1);\n+  __ jcc(Assembler::greater, L_2TAG_PACKET_1_0_1);\n+  __ pextrw(rax, xmm0, 3);\n+  __ movl(rdx, rax);\n+  __ andl(rax, 32752);\n+  __ jcc(Assembler::equal, L_2TAG_PACKET_2_0_1);\n+  __ andl(rdx, 32767);\n+  __ cmpl(rdx, 15904);\n+  __ jcc(Assembler::below, L_2TAG_PACKET_3_0_1);\n+  __ movdqu(xmm2, xmm0);\n+  __ movdqu(xmm3, xmm0);\n+  __ movq(xmm1, ExternalAddress(Q_11), rbx \/*rscratch*\/);    \/\/0xb8fe4d77UL, 0x3f82609aUL\n+  __ mulsd(xmm2, xmm0);\n+  __ mulsd(xmm3, xmm2);\n+  __ mulsd(xmm1, xmm2);\n+  __ addsd(xmm1, ExternalAddress(Q_9), rbx \/*rscratch*\/);    \/\/0xbf847a43UL, 0x3f9664a0UL\n+  __ mulsd(xmm1, xmm2);\n+  __ addsd(xmm1, ExternalAddress(Q_7), rbx \/*rscratch*\/);    \/\/0x52c4c8abUL, 0x3faba1baUL\n+  __ mulsd(xmm1, xmm2);\n+  __ addsd(xmm1, ExternalAddress(Q_5), rbx \/*rscratch*\/);    \/\/0x11092746UL, 0x3fc11111UL\n+  __ mulsd(xmm1, xmm2);\n+  __ addsd(xmm1, ExternalAddress(Q_3), rbx \/*rscratch*\/);    \/\/0x55555612UL, 0x3fd55555UL\n+  __ mulsd(xmm1, xmm3);\n+  __ addsd(xmm0, xmm1);\n+  __ jmp(B1_4);\n+\n+  __ bind(L_2TAG_PACKET_3_0_1);\n+  __ movq(xmm3, ExternalAddress(TWO_POW_55), rbx \/*rscratch*\/);    \/\/0x00000000UL, 0x43600000UL\n+  __ mulsd(xmm3, xmm0);\n+  __ addsd(xmm0, xmm3);\n+  __ mulsd(xmm0, ExternalAddress(TWO_POW_M55), rbx \/*rscratch*\/);    \/\/0x00000000UL, 0x3c800000UL\n+  __ jmp(B1_4);\n+\n+  __ bind(L_2TAG_PACKET_2_0_1);\n+  __ movdqu(xmm1, xmm0);\n+  __ mulsd(xmm1, xmm1);\n+  __ jmp(B1_4);\n+\n+  __ bind(L_2TAG_PACKET_1_0_1);\n+  __ pextrw(rax, xmm0, 3);\n+  __ andl(rax, 32752);\n+  __ cmpl(rax, 32752);\n+  __ jcc(Assembler::equal, L_2TAG_PACKET_4_0_1);\n+  __ pextrw(rcx, xmm0, 3);\n+  __ andl(rcx, 32752);\n+  __ subl(rcx, 16224);\n+  __ shrl(rcx, 7);\n+  __ andl(rcx, 65532);\n+  __ lea(r11, ExternalAddress(PI_INV_TABLE));\n+  __ addq(rcx, r11);\n+  __ movdq(rax, xmm0);\n+  __ movl(r10, Address(rcx, 20));\n+  __ movl(r8, Address(rcx, 24));\n+  __ movl(rdx, rax);\n+  __ shrq(rax, 21);\n+  __ orl(rax, INT_MIN);\n+  __ shrl(rax, 11);\n+  __ movl(r9, r10);\n+  __ imulq(r10, rdx);\n+  __ imulq(r9, rax);\n+  __ imulq(r8, rax);\n+  __ movl(rsi, Address(rcx, 16));\n+  __ movl(rdi, Address(rcx, 12));\n+  __ movl(r11, r10);\n+  __ shrq(r10, 32);\n+  __ addq(r9, r10);\n+  __ addq(r11, r8);\n+  __ movl(r8, r11);\n+  __ shrq(r11, 32);\n+  __ addq(r9, r11);\n+  __ movl(r10, rsi);\n+  __ imulq(rsi, rdx);\n+  __ imulq(r10, rax);\n+  __ movl(r11, rdi);\n+  __ imulq(rdi, rdx);\n+  __ movl(rbx, rsi);\n+  __ shrq(rsi, 32);\n+  __ addq(r9, rbx);\n+  __ movl(rbx, r9);\n+  __ shrq(r9, 32);\n+  __ addq(r10, rsi);\n+  __ addq(r10, r9);\n+  __ shlq(rbx, 32);\n+  __ orq(r8, rbx);\n+  __ imulq(r11, rax);\n+  __ movl(r9, Address(rcx, 8));\n+  __ movl(rsi, Address(rcx, 4));\n+  __ movl(rbx, rdi);\n+  __ shrq(rdi, 32);\n+  __ addq(r10, rbx);\n+  __ movl(rbx, r10);\n+  __ shrq(r10, 32);\n+  __ addq(r11, rdi);\n+  __ addq(r11, r10);\n+  __ movq(rdi, r9);\n+  __ imulq(r9, rdx);\n+  __ imulq(rdi, rax);\n+  __ movl(r10, r9);\n+  __ shrq(r9, 32);\n+  __ addq(r11, r10);\n+  __ movl(r10, r11);\n+  __ shrq(r11, 32);\n+  __ addq(rdi, r9);\n+  __ addq(rdi, r11);\n+  __ movq(r9, rsi);\n+  __ imulq(rsi, rdx);\n+  __ imulq(r9, rax);\n+  __ shlq(r10, 32);\n+  __ orq(r10, rbx);\n+  __ movl(rax, Address(rcx, 0));\n+  __ movl(r11, rsi);\n+  __ shrq(rsi, 32);\n+  __ addq(rdi, r11);\n+  __ movl(r11, rdi);\n+  __ shrq(rdi, 32);\n+  __ addq(r9, rsi);\n+  __ addq(r9, rdi);\n+  __ imulq(rdx, rax);\n+  __ pextrw(rbx, xmm0, 3);\n+  __ lea(rdi, ExternalAddress(PI_INV_TABLE));\n+  __ subq(rcx, rdi);\n+  __ addl(rcx, rcx);\n+  __ addl(rcx, rcx);\n+  __ addl(rcx, rcx);\n+  __ addl(rcx, 19);\n+  __ movl(rsi, 32768);\n+  __ andl(rsi, rbx);\n+  __ shrl(rbx, 4);\n+  __ andl(rbx, 2047);\n+  __ subl(rbx, 1023);\n+  __ subl(rcx, rbx);\n+  __ addq(r9, rdx);\n+  __ movl(rdx, rcx);\n+  __ addl(rdx, 32);\n+  __ cmpl(rcx, 0);\n+  __ jcc(Assembler::less, L_2TAG_PACKET_5_0_1);\n+  __ negl(rcx);\n+  __ addl(rcx, 29);\n+  __ shll(r9);\n+  __ movl(rdi, r9);\n+  __ andl(r9, 1073741823);\n+  __ testl(r9, 536870912);\n+  __ jcc(Assembler::notEqual, L_2TAG_PACKET_6_0_1);\n+  __ shrl(r9);\n+  __ movl(rbx, 0);\n+  __ shlq(r9, 32);\n+  __ orq(r9, r11);\n+\n+  __ bind(L_2TAG_PACKET_7_0_1);\n+\n+  __ bind(L_2TAG_PACKET_8_0_1);\n+  __ cmpq(r9, 0);\n+  __ jcc(Assembler::equal, L_2TAG_PACKET_9_0_1);\n+\n+  __ bind(L_2TAG_PACKET_10_0_1);\n+  __ bsrq(r11, r9);\n+  __ movl(rcx, 29);\n+  __ subl(rcx, r11);\n+  __ jcc(Assembler::lessEqual, L_2TAG_PACKET_11_0_1);\n+  __ shlq(r9);\n+  __ movq(rax, r10);\n+  __ shlq(r10);\n+  __ addl(rdx, rcx);\n+  __ negl(rcx);\n+  __ addl(rcx, 64);\n+  __ shrq(rax);\n+  __ shrq(r8);\n+  __ orq(r9, rax);\n+  __ orq(r10, r8);\n+\n+  __ bind(L_2TAG_PACKET_12_0_1);\n+  __ cvtsi2sdq(xmm0, r9);\n+  __ shrq(r10, 1);\n+  __ cvtsi2sdq(xmm3, r10);\n+  __ xorpd(xmm4, xmm4);\n+  __ shll(rdx, 4);\n+  __ negl(rdx);\n+  __ addl(rdx, 16368);\n+  __ orl(rdx, rsi);\n+  __ xorl(rdx, rbx);\n+  __ pinsrw(xmm4, rdx, 3);\n+  __ movq(xmm2, ExternalAddress(PI_4),     rbx \/*rscratch*\/);    \/\/0x00000000UL, 0x3fe921fbUL, 0x4611a626UL, 0x3e85110bUL\n+  __ movq(xmm7, ExternalAddress(PI_4 + 8), rbx \/*rscratch*\/);    \/\/0x3fe921fbUL, 0x4611a626UL, 0x3e85110bUL\n+  __ xorpd(xmm5, xmm5);\n+  __ subl(rdx, 1008);\n+  __ pinsrw(xmm5, rdx, 3);\n+  __ mulsd(xmm0, xmm4);\n+  __ shll(rsi, 16);\n+  __ sarl(rsi, 31);\n+  __ mulsd(xmm3, xmm5);\n+  __ movdqu(xmm1, xmm0);\n+  __ mulsd(xmm0, xmm2);\n+  __ shrl(rdi, 30);\n+  __ addsd(xmm1, xmm3);\n+  __ mulsd(xmm3, xmm2);\n+  __ addl(rdi, rsi);\n+  __ xorl(rdi, rsi);\n+  __ mulsd(xmm7, xmm1);\n+  __ movl(rax, rdi);\n+  __ addsd(xmm7, xmm3);\n+  __ movdqu(xmm2, xmm0);\n+  __ addsd(xmm0, xmm7);\n+  __ subsd(xmm2, xmm0);\n+  __ addsd(xmm7, xmm2);\n+  __ movdqu(xmm1, ExternalAddress(PI32INV), rbx \/*rscratch*\/);    \/\/0x6dc9c883UL, 0x3fe45f30UL, 0x6dc9c883UL, 0x40245f30UL\n+  if (VM_Version::supports_sse3()) {\n+    __ movddup(xmm0, xmm0);\n+  } else {\n+    __ movlhps(xmm0, xmm0);\n+  }\n+  __ movdqu(xmm4, ExternalAddress(sign_mask), rbx \/*rscratch*\/);    \/\/0x00000000UL, 0x80000000UL, 0x00000000UL, 0x80000000UL\n+  __ andpd(xmm4, xmm0);\n+  __ mulpd(xmm1, xmm0);\n+  if (VM_Version::supports_sse3()) {\n+    __ movddup(xmm7, xmm7);\n+  }\n+  else {\n+    __ movlhps(xmm7, xmm7);\n+  }\n+  __ movdqu(xmm5, ExternalAddress(ONEHALF), rbx \/*rscratch*\/);    \/\/0x00000000UL, 0x3fe00000UL, 0x00000000UL, 0x3fe00000UL\n+  __ movdqu(xmm6, ExternalAddress(MUL16), rbx \/*rscratch*\/);    \/\/0x00000000UL, 0x40300000UL, 0x00000000UL, 0x3ff00000UL\n+  __ por(xmm5, xmm4);\n+  __ addpd(xmm1, xmm5);\n+  __ movdqu(xmm5, xmm1);\n+  __ unpckhpd(xmm5, xmm5);\n+  __ cvttsd2sil(rdx, xmm5);\n+  __ cvttpd2dq(xmm1, xmm1);\n+  __ cvtdq2pd(xmm1, xmm1);\n+  __ mulpd(xmm1, xmm6);\n+  __ movdqu(xmm3, ExternalAddress(P_1), rbx \/*rscratch*\/);    \/\/0x54444000UL, 0x3fb921fbUL, 0x54440000UL, 0x3fb921fbUL\n+  __ movq(xmm5, ExternalAddress(QQ_2), rbx \/*rscratch*\/);    \/\/0x676733afUL, 0x3d32e7b9UL\n+  __ shll(rax, 4);\n+  __ addl(rdx, 469248);\n+  __ movdqu(xmm4, ExternalAddress(P_2), rbx \/*rscratch*\/);    \/\/0x67674000UL, 0xbd32e7b9UL, 0x4c4c0000UL, 0x3d468c23UL\n+  __ mulpd(xmm3, xmm1);\n+  __ addl(rdx, rax);\n+  __ andl(rdx, 31);\n+  __ mulsd(xmm5, xmm1);\n+  __ movl(rcx, rdx);\n+  __ mulpd(xmm4, xmm1);\n+  __ shll(rcx, 1);\n+  __ subpd(xmm0, xmm3);\n+  __ mulpd(xmm1, ExternalAddress(P_3), rbx \/*rscratch*\/);    \/\/0x3707344aUL, 0x3aa8a2e0UL, 0x03707345UL, 0x3ae98a2eUL\n+  __ addl(rdx, rcx);\n+  __ shll(rcx, 2);\n+  __ addl(rdx, rcx);\n+  __ addsd(xmm5, xmm0);\n+  __ movdqu(xmm2, xmm0);\n+  __ subpd(xmm0, xmm4);\n+  __ movq(xmm6, ExternalAddress(ONE), rbx \/*rscratch*\/);    \/\/0x00000000UL, 0x3ff00000UL\n+  __ shll(rdx, 4);\n+  __ lea(rax, ExternalAddress(Ctable));\n+  __ andpd(xmm5, ExternalAddress(MASK_35), rbx \/*rscratch*\/);    \/\/0xfffc0000UL, 0xffffffffUL, 0x00000000UL, 0x00000000UL\n+  __ movdqu(xmm3, xmm0);\n+  __ addq(rax, rdx);\n+  __ subpd(xmm2, xmm0);\n+  __ unpckhpd(xmm0, xmm0);\n+  __ divsd(xmm6, xmm5);\n+  __ subpd(xmm2, xmm4);\n+  __ subsd(xmm3, xmm5);\n+  __ subpd(xmm2, xmm1);\n+  __ movdqu(xmm1, Address(rax, 48));\n+  __ addpd(xmm2, xmm7);\n+  __ movdqu(xmm7, Address(rax, 16));\n+  __ mulpd(xmm7, xmm0);\n+  __ movdqu(xmm4, Address(rax, 96));\n+  __ mulpd(xmm1, xmm0);\n+  __ mulpd(xmm4, xmm0);\n+  __ addsd(xmm2, xmm3);\n+  __ movdqu(xmm3, xmm0);\n+  __ mulpd(xmm0, xmm0);\n+  __ addpd(xmm7, Address(rax, 0));\n+  __ addpd(xmm1, Address(rax, 32));\n+  __ mulpd(xmm1, xmm0);\n+  __ addpd(xmm4, Address(rax, 80));\n+  __ addpd(xmm7, xmm1);\n+  __ movdqu(xmm1, Address(rax, 112));\n+  __ mulpd(xmm1, xmm0);\n+  __ mulpd(xmm0, xmm0);\n+  __ addpd(xmm4, xmm1);\n+  __ movdqu(xmm1, Address(rax, 64));\n+  __ mulpd(xmm1, xmm0);\n+  __ addpd(xmm7, xmm1);\n+  __ movdqu(xmm1, xmm3);\n+  __ mulpd(xmm3, xmm0);\n+  __ mulsd(xmm0, xmm0);\n+  __ mulpd(xmm1, Address(rax, 144));\n+  __ mulpd(xmm4, xmm3);\n+  __ movdqu(xmm3, xmm1);\n+  __ addpd(xmm7, xmm4);\n+  __ movdqu(xmm4, xmm1);\n+  __ mulsd(xmm0, xmm7);\n+  __ unpckhpd(xmm7, xmm7);\n+  __ addsd(xmm0, xmm7);\n+  __ unpckhpd(xmm1, xmm1);\n+  __ addsd(xmm3, xmm1);\n+  __ subsd(xmm4, xmm3);\n+  __ addsd(xmm1, xmm4);\n+  __ movdqu(xmm4, xmm2);\n+  __ movq(xmm7, Address(rax, 144));\n+  __ unpckhpd(xmm2, xmm2);\n+  __ addsd(xmm7, Address(rax, 152));\n+  __ mulsd(xmm7, xmm2);\n+  __ addsd(xmm7, Address(rax, 136));\n+  __ addsd(xmm7, xmm1);\n+  __ addsd(xmm0, xmm7);\n+  __ movq(xmm7, ExternalAddress(ONE), rbx \/*rscratch*\/);    \/\/0x00000000UL, 0x3ff00000UL\n+  __ mulsd(xmm4, xmm6);\n+  __ movq(xmm2, Address(rax, 168));\n+  __ andpd(xmm2, xmm6);\n+  __ mulsd(xmm5, xmm2);\n+  __ mulsd(xmm6, Address(rax, 160));\n+  __ subsd(xmm7, xmm5);\n+  __ subsd(xmm2, Address(rax, 128));\n+  __ subsd(xmm7, xmm4);\n+  __ mulsd(xmm7, xmm6);\n+  __ movdqu(xmm4, xmm3);\n+  __ subsd(xmm3, xmm2);\n+  __ addsd(xmm2, xmm3);\n+  __ subsd(xmm4, xmm2);\n+  __ addsd(xmm0, xmm4);\n+  __ subsd(xmm0, xmm7);\n+  __ addsd(xmm0, xmm3);\n+  __ jmp(B1_4);\n+\n+  __ bind(L_2TAG_PACKET_9_0_1);\n+  __ addl(rdx, 64);\n+  __ movq(r9, r10);\n+  __ movq(r10, r8);\n+  __ movl(r8, 0);\n+  __ cmpq(r9, 0);\n+  __ jcc(Assembler::notEqual, L_2TAG_PACKET_10_0_1);\n+  __ addl(rdx, 64);\n+  __ movq(r9, r10);\n+  __ movq(r10, r8);\n+  __ cmpq(r9, 0);\n+  __ jcc(Assembler::notEqual, L_2TAG_PACKET_10_0_1);\n+  __ jmp(L_2TAG_PACKET_12_0_1);\n+\n+  __ bind(L_2TAG_PACKET_11_0_1);\n+  __ jcc(Assembler::equal, L_2TAG_PACKET_12_0_1);\n+  __ negl(rcx);\n+  __ shrq(r10);\n+  __ movq(rax, r9);\n+  __ shrq(r9);\n+  __ subl(rdx, rcx);\n+  __ negl(rcx);\n+  __ addl(rcx, 64);\n+  __ shlq(rax);\n+  __ orq(r10, rax);\n+  __ jmp(L_2TAG_PACKET_12_0_1);\n+\n+  __ bind(L_2TAG_PACKET_5_0_1);\n+  __ notl(rcx);\n+  __ shlq(r9, 32);\n+  __ orq(r9, r11);\n+  __ shlq(r9);\n+  __ movq(rdi, r9);\n+  __ testl(r9, INT_MIN);\n+  __ jcc(Assembler::notEqual, L_2TAG_PACKET_13_0_1);\n+  __ shrl(r9);\n+  __ movl(rbx, 0);\n+  __ shrq(rdi, 2);\n+  __ jmp(L_2TAG_PACKET_8_0_1);\n+\n+  __ bind(L_2TAG_PACKET_6_0_1);\n+  __ shrl(r9);\n+  __ movl(rbx, 1073741824);\n+  __ shrl(rbx);\n+  __ shlq(r9, 32);\n+  __ orq(r9, r11);\n+  __ shlq(rbx, 32);\n+  __ addl(rdi, 1073741824);\n+  __ movl(rcx, 0);\n+  __ movl(r11, 0);\n+  __ subq(rcx, r8);\n+  __ sbbq(r11, r10);\n+  __ sbbq(rbx, r9);\n+  __ movq(r8, rcx);\n+  __ movq(r10, r11);\n+  __ movq(r9, rbx);\n+  __ movl(rbx, 32768);\n+  __ jmp(L_2TAG_PACKET_7_0_1);\n+\n+  __ bind(L_2TAG_PACKET_13_0_1);\n+  __ shrl(r9);\n+  __ mov64(rbx, 0x100000000);\n+  __ shrq(rbx);\n+  __ movl(rcx, 0);\n+  __ movl(r11, 0);\n+  __ subq(rcx, r8);\n+  __ sbbq(r11, r10);\n+  __ sbbq(rbx, r9);\n+  __ movq(r8, rcx);\n+  __ movq(r10, r11);\n+  __ movq(r9, rbx);\n+  __ movl(rbx, 32768);\n+  __ shrq(rdi, 2);\n+  __ addl(rdi, 1073741824);\n+  __ jmp(L_2TAG_PACKET_8_0_1);\n+\n+  __ bind(L_2TAG_PACKET_4_0_1);\n+  __ movq(xmm0, Address(rsp, 8));\n+  __ mulsd(xmm0, ExternalAddress(NEG_ZERO), rbx \/*rscratch*\/);    \/\/0x00000000UL, 0x80000000UL\n+  __ movq(Address(rsp, 0), xmm0);\n+\n+  __ bind(L_2TAG_PACKET_14_0_1);\n+\n+  __ bind(B1_4);\n+  __ addq(rsp, 16);\n+  __ pop(rbx);\n+\n+#ifdef _WIN64\n+  __ pop(rdi);\n+  __ pop(rsi);\n+#endif\n+\n+  __ leave(); \/\/ required for proper stackwalking of RuntimeStub frame\n+  __ ret(0);\n+\n+  return start;\n+}\n+\n+#undef __\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_tan.cpp","additions":1031,"deletions":0,"binary":false,"changes":1031,"status":"added"},{"patch":"@@ -37,6 +37,0 @@\n-address StubRoutines::x86::_key_shuffle_mask_addr = NULL;\n-address StubRoutines::x86::_counter_shuffle_mask_addr = NULL;\n-address StubRoutines::x86::_ghash_long_swap_mask_addr = NULL;\n-address StubRoutines::x86::_ghash_byte_swap_mask_addr = NULL;\n-address StubRoutines::x86::_ghash_poly_addr = NULL;\n-address StubRoutines::x86::_ghash_shuffmask_addr = NULL;\n@@ -80,1 +74,0 @@\n-address StubRoutines::x86::_counter_mask_addr = NULL;\n@@ -90,1 +83,0 @@\n-address StubRoutines::x86::_ghash_poly512_addr = NULL;\n@@ -236,19 +228,0 @@\n-\n-juint StubRoutines::x86::_adler32_ascale_table[] =\n-{\n-    0x00000000UL, 0x00000001UL, 0x00000002UL, 0x00000003UL,\n-    0x00000004UL, 0x00000005UL, 0x00000006UL, 0x00000007UL\n-};\n-\n-juint StubRoutines::x86::_adler32_shuf0_table[] =\n-{\n-    0xFFFFFF00UL, 0xFFFFFF01UL, 0xFFFFFF02UL, 0xFFFFFF03UL,\n-    0xFFFFFF04UL, 0xFFFFFF05UL, 0xFFFFFF06UL, 0xFFFFFF07UL\n-};\n-\n-juint StubRoutines::x86::_adler32_shuf1_table[] =\n-{\n-    0xFFFFFF08UL, 0xFFFFFF09, 0xFFFFFF0AUL, 0xFFFFFF0BUL,\n-    0xFFFFFF0CUL, 0xFFFFFF0D, 0xFFFFFF0EUL, 0xFFFFFF0FUL\n-};\n-\n","filename":"src\/hotspot\/cpu\/x86\/stubRoutines_x86.cpp","additions":0,"deletions":27,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -126,5 +126,0 @@\n-  \/\/ shuffle mask for fixing up 128-bit words consisting of big-endian 32-bit integers\n-  static address _key_shuffle_mask_addr;\n-\n-  \/\/shuffle mask for big-endian 128-bit integers\n-  static address _counter_shuffle_mask_addr;\n@@ -142,3 +137,0 @@\n-  static juint    _adler32_shuf0_table[];\n-  static juint    _adler32_shuf1_table[];\n-  static juint    _adler32_ascale_table[];\n@@ -148,5 +140,0 @@\n-  \/\/ swap mask for ghash\n-  static address _ghash_long_swap_mask_addr;\n-  static address _ghash_byte_swap_mask_addr;\n-  static address _ghash_poly_addr;\n-  static address _ghash_shuffmask_addr;\n@@ -193,1 +180,0 @@\n-  static address _counter_mask_addr;\n@@ -209,1 +195,0 @@\n-  static address _ghash_poly512_addr;\n@@ -217,2 +202,0 @@\n-  static address key_shuffle_mask_addr() { return _key_shuffle_mask_addr; }\n-  static address counter_shuffle_mask_addr() { return _counter_shuffle_mask_addr; }\n@@ -225,1 +208,0 @@\n-  static address ghash_polynomial512_addr() { return _ghash_poly512_addr; }\n@@ -227,4 +209,0 @@\n-  static address ghash_long_swap_mask_addr() { return _ghash_long_swap_mask_addr; }\n-  static address ghash_byte_swap_mask_addr() { return _ghash_byte_swap_mask_addr; }\n-  static address ghash_shufflemask_addr() { return _ghash_shuffmask_addr; }\n-  static address ghash_polynomial_addr() { return _ghash_poly_addr; }\n@@ -339,1 +317,0 @@\n-  static address counter_mask_addr() { return _counter_mask_addr; }\n","filename":"src\/hotspot\/cpu\/x86\/stubRoutines_x86.hpp","additions":0,"deletions":23,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -68,1 +68,1 @@\n-    ZeroInterpreterGenerator g(_code);\n+    ZeroInterpreterGenerator g;\n","filename":"src\/hotspot\/cpu\/zero\/zeroInterpreter_zero.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,437 @@\n+\/*\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"cds\/archiveHeapLoader.inline.hpp\"\n+#include \"cds\/filemap.hpp\"\n+#include \"cds\/heapShared.hpp\"\n+#include \"cds\/metaspaceShared.hpp\"\n+#include \"classfile\/classLoaderDataShared.hpp\"\n+#include \"classfile\/systemDictionaryShared.hpp\"\n+#include \"gc\/shared\/collectedHeap.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"memory\/iterator.inline.hpp\"\n+#include \"memory\/resourceArea.hpp\"\n+#include \"memory\/universe.hpp\"\n+#include \"utilities\/bitMap.inline.hpp\"\n+#include \"utilities\/copy.hpp\"\n+\n+#if INCLUDE_CDS_JAVA_HEAP\n+\n+bool ArchiveHeapLoader::_closed_regions_mapped = false;\n+bool ArchiveHeapLoader::_open_regions_mapped = false;\n+bool ArchiveHeapLoader::_is_loaded = false;\n+address ArchiveHeapLoader::_narrow_oop_base;\n+int     ArchiveHeapLoader::_narrow_oop_shift;\n+\n+\/\/ Support for loaded heap.\n+uintptr_t ArchiveHeapLoader::_loaded_heap_bottom = 0;\n+uintptr_t ArchiveHeapLoader::_loaded_heap_top = 0;\n+uintptr_t ArchiveHeapLoader::_dumptime_base_0 = UINTPTR_MAX;\n+uintptr_t ArchiveHeapLoader::_dumptime_base_1 = UINTPTR_MAX;\n+uintptr_t ArchiveHeapLoader::_dumptime_base_2 = UINTPTR_MAX;\n+uintptr_t ArchiveHeapLoader::_dumptime_base_3 = UINTPTR_MAX;\n+uintptr_t ArchiveHeapLoader::_dumptime_top    = 0;\n+intx ArchiveHeapLoader::_runtime_offset_0 = 0;\n+intx ArchiveHeapLoader::_runtime_offset_1 = 0;\n+intx ArchiveHeapLoader::_runtime_offset_2 = 0;\n+intx ArchiveHeapLoader::_runtime_offset_3 = 0;\n+bool ArchiveHeapLoader::_loading_failed = false;\n+\n+\/\/ Support for mapped heap (!UseCompressedOops only)\n+ptrdiff_t ArchiveHeapLoader::_runtime_delta = 0;\n+\n+void ArchiveHeapLoader::init_narrow_oop_decoding(address base, int shift) {\n+  _narrow_oop_base = base;\n+  _narrow_oop_shift = shift;\n+}\n+\n+void ArchiveHeapLoader::fixup_regions() {\n+  FileMapInfo* mapinfo = FileMapInfo::current_info();\n+  if (is_mapped()) {\n+    mapinfo->fixup_mapped_heap_regions();\n+  } else if (_loading_failed) {\n+    fill_failed_loaded_region();\n+  }\n+  if (is_fully_available()) {\n+    if (!MetaspaceShared::use_full_module_graph()) {\n+      \/\/ Need to remove all the archived java.lang.Module objects from HeapShared::roots().\n+      ClassLoaderDataShared::clear_archived_oops();\n+    }\n+  }\n+  SystemDictionaryShared::update_archived_mirror_native_pointers();\n+}\n+\n+\/\/ ------------------ Support for Region MAPPING -----------------------------------------\n+\n+\/\/ Patch all the embedded oop pointers inside an archived heap region,\n+\/\/ to be consistent with the runtime oop encoding.\n+class PatchCompressedEmbeddedPointers: public BitMapClosure {\n+  narrowOop* _start;\n+\n+ public:\n+  PatchCompressedEmbeddedPointers(narrowOop* start) : _start(start) {}\n+\n+  bool do_bit(size_t offset) {\n+    narrowOop* p = _start + offset;\n+    narrowOop v = *p;\n+    assert(!CompressedOops::is_null(v), \"null oops should have been filtered out at dump time\");\n+    oop o = ArchiveHeapLoader::decode_from_archive(v);\n+    RawAccess<IS_NOT_NULL>::oop_store(p, o);\n+    return true;\n+  }\n+};\n+\n+class PatchUncompressedEmbeddedPointers: public BitMapClosure {\n+  oop* _start;\n+\n+ public:\n+  PatchUncompressedEmbeddedPointers(oop* start) : _start(start) {}\n+\n+  bool do_bit(size_t offset) {\n+    oop* p = _start + offset;\n+    intptr_t dumptime_oop = (intptr_t)((void*)*p);\n+    assert(dumptime_oop != 0, \"null oops should have been filtered out at dump time\");\n+    intptr_t runtime_oop = dumptime_oop + ArchiveHeapLoader::runtime_delta();\n+    RawAccess<IS_NOT_NULL>::oop_store(p, cast_to_oop(runtime_oop));\n+    return true;\n+  }\n+};\n+\n+\/\/ Patch all the non-null pointers that are embedded in the archived heap objects\n+\/\/ in this (mapped) region\n+void ArchiveHeapLoader::patch_embedded_pointers(MemRegion region, address oopmap,\n+                                                size_t oopmap_size_in_bits) {\n+  BitMapView bm((BitMap::bm_word_t*)oopmap, oopmap_size_in_bits);\n+\n+#ifndef PRODUCT\n+  ResourceMark rm;\n+  ResourceBitMap checkBm = HeapShared::calculate_oopmap(region);\n+  assert(bm.is_same(checkBm), \"sanity\");\n+#endif\n+\n+  if (UseCompressedOops) {\n+    PatchCompressedEmbeddedPointers patcher((narrowOop*)region.start());\n+    bm.iterate(&patcher);\n+  } else {\n+    PatchUncompressedEmbeddedPointers patcher((oop*)region.start());\n+    bm.iterate(&patcher);\n+  }\n+}\n+\n+\/\/ ------------------ Support for Region LOADING -----------------------------------------\n+\n+\/\/ The CDS archive remembers each heap object by its address at dump time, but\n+\/\/ the heap object may be loaded at a different address at run time. This structure is used\n+\/\/ to translate the dump time addresses for all objects in FileMapInfo::space_at(region_index)\n+\/\/ to their runtime addresses.\n+struct LoadedArchiveHeapRegion {\n+  int       _region_index;   \/\/ index for FileMapInfo::space_at(index)\n+  size_t    _region_size;    \/\/ number of bytes in this region\n+  uintptr_t _dumptime_base;  \/\/ The dump-time (decoded) address of the first object in this region\n+  intx      _runtime_offset; \/\/ If an object's dump time address P is within in this region, its\n+                             \/\/ runtime address is P + _runtime_offset\n+\n+  static int comparator(const void* a, const void* b) {\n+    LoadedArchiveHeapRegion* reg_a = (LoadedArchiveHeapRegion*)a;\n+    LoadedArchiveHeapRegion* reg_b = (LoadedArchiveHeapRegion*)b;\n+    if (reg_a->_dumptime_base < reg_b->_dumptime_base) {\n+      return -1;\n+    } else if (reg_a->_dumptime_base == reg_b->_dumptime_base) {\n+      return 0;\n+    } else {\n+      return 1;\n+    }\n+  }\n+\n+  uintptr_t top() {\n+    return _dumptime_base + _region_size;\n+  }\n+};\n+\n+void ArchiveHeapLoader::init_loaded_heap_relocation(LoadedArchiveHeapRegion* loaded_regions,\n+                                             int num_loaded_regions) {\n+  _dumptime_base_0 = loaded_regions[0]._dumptime_base;\n+  _dumptime_base_1 = loaded_regions[1]._dumptime_base;\n+  _dumptime_base_2 = loaded_regions[2]._dumptime_base;\n+  _dumptime_base_3 = loaded_regions[3]._dumptime_base;\n+  _dumptime_top = loaded_regions[num_loaded_regions-1].top();\n+\n+  _runtime_offset_0 = loaded_regions[0]._runtime_offset;\n+  _runtime_offset_1 = loaded_regions[1]._runtime_offset;\n+  _runtime_offset_2 = loaded_regions[2]._runtime_offset;\n+  _runtime_offset_3 = loaded_regions[3]._runtime_offset;\n+\n+  assert(2 <= num_loaded_regions && num_loaded_regions <= 4, \"must be\");\n+  if (num_loaded_regions < 4) {\n+    _dumptime_base_3 = UINTPTR_MAX;\n+  }\n+  if (num_loaded_regions < 3) {\n+    _dumptime_base_2 = UINTPTR_MAX;\n+  }\n+}\n+\n+bool ArchiveHeapLoader::can_load() {\n+  return Universe::heap()->can_load_archived_objects();\n+}\n+\n+template <int NUM_LOADED_REGIONS>\n+class PatchLoadedRegionPointers: public BitMapClosure {\n+  narrowOop* _start;\n+  intx _offset_0;\n+  intx _offset_1;\n+  intx _offset_2;\n+  intx _offset_3;\n+  uintptr_t _base_0;\n+  uintptr_t _base_1;\n+  uintptr_t _base_2;\n+  uintptr_t _base_3;\n+  uintptr_t _top;\n+\n+  static_assert(MetaspaceShared::max_num_heap_regions == 4, \"can't handle more than 4 regions\");\n+  static_assert(NUM_LOADED_REGIONS >= 2, \"we have at least 2 loaded regions\");\n+  static_assert(NUM_LOADED_REGIONS <= 4, \"we have at most 4 loaded regions\");\n+\n+ public:\n+  PatchLoadedRegionPointers(narrowOop* start, LoadedArchiveHeapRegion* loaded_regions)\n+    : _start(start),\n+      _offset_0(loaded_regions[0]._runtime_offset),\n+      _offset_1(loaded_regions[1]._runtime_offset),\n+      _offset_2(loaded_regions[2]._runtime_offset),\n+      _offset_3(loaded_regions[3]._runtime_offset),\n+      _base_0(loaded_regions[0]._dumptime_base),\n+      _base_1(loaded_regions[1]._dumptime_base),\n+      _base_2(loaded_regions[2]._dumptime_base),\n+      _base_3(loaded_regions[3]._dumptime_base) {\n+    _top = loaded_regions[NUM_LOADED_REGIONS-1].top();\n+  }\n+\n+  bool do_bit(size_t offset) {\n+    narrowOop* p = _start + offset;\n+    narrowOop v = *p;\n+    assert(!CompressedOops::is_null(v), \"null oops should have been filtered out at dump time\");\n+    uintptr_t o = cast_from_oop<uintptr_t>(ArchiveHeapLoader::decode_from_archive(v));\n+    assert(_base_0 <= o && o < _top, \"must be\");\n+\n+\n+    \/\/ We usually have only 2 regions for the default archive. Use template to avoid unnecessary comparisons.\n+    if (NUM_LOADED_REGIONS > 3 && o >= _base_3) {\n+      o += _offset_3;\n+    } else if (NUM_LOADED_REGIONS > 2 && o >= _base_2) {\n+      o += _offset_2;\n+    } else if (o >= _base_1) {\n+      o += _offset_1;\n+    } else {\n+      o += _offset_0;\n+    }\n+    ArchiveHeapLoader::assert_in_loaded_heap(o);\n+    RawAccess<IS_NOT_NULL>::oop_store(p, cast_to_oop(o));\n+    return true;\n+  }\n+};\n+\n+int ArchiveHeapLoader::init_loaded_regions(FileMapInfo* mapinfo, LoadedArchiveHeapRegion* loaded_regions,\n+                                           MemRegion& archive_space) {\n+  size_t total_bytes = 0;\n+  int num_loaded_regions = 0;\n+  for (int i = MetaspaceShared::first_archive_heap_region;\n+       i <= MetaspaceShared::last_archive_heap_region; i++) {\n+    FileMapRegion* r = mapinfo->space_at(i);\n+    r->assert_is_heap_region();\n+    if (r->used() > 0) {\n+      assert(is_aligned(r->used(), HeapWordSize), \"must be\");\n+      total_bytes += r->used();\n+      LoadedArchiveHeapRegion* ri = &loaded_regions[num_loaded_regions++];\n+      ri->_region_index = i;\n+      ri->_region_size = r->used();\n+      ri->_dumptime_base = (uintptr_t)mapinfo->start_address_as_decoded_from_archive(r);\n+    }\n+  }\n+\n+  assert(is_aligned(total_bytes, HeapWordSize), \"must be\");\n+  size_t word_size = total_bytes \/ HeapWordSize;\n+  HeapWord* buffer = Universe::heap()->allocate_loaded_archive_space(word_size);\n+  if (buffer == nullptr) {\n+    return 0;\n+  }\n+\n+  archive_space = MemRegion(buffer, word_size);\n+  _loaded_heap_bottom = (uintptr_t)archive_space.start();\n+  _loaded_heap_top    = _loaded_heap_bottom + total_bytes;\n+\n+  return num_loaded_regions;\n+}\n+\n+void ArchiveHeapLoader::sort_loaded_regions(LoadedArchiveHeapRegion* loaded_regions, int num_loaded_regions,\n+                                            uintptr_t buffer) {\n+  \/\/ Find the relocation offset of the pointers in each region\n+  qsort(loaded_regions, num_loaded_regions, sizeof(LoadedArchiveHeapRegion),\n+        LoadedArchiveHeapRegion::comparator);\n+\n+  uintptr_t p = buffer;\n+  for (int i = 0; i < num_loaded_regions; i++) {\n+    \/\/ This region will be loaded at p, so all objects inside this\n+    \/\/ region will be shifted by ri->offset\n+    LoadedArchiveHeapRegion* ri = &loaded_regions[i];\n+    ri->_runtime_offset = p - ri->_dumptime_base;\n+    p += ri->_region_size;\n+  }\n+  assert(p == _loaded_heap_top, \"must be\");\n+}\n+\n+bool ArchiveHeapLoader::load_regions(FileMapInfo* mapinfo, LoadedArchiveHeapRegion* loaded_regions,\n+                                     int num_loaded_regions, uintptr_t buffer) {\n+  uintptr_t bitmap_base = (uintptr_t)mapinfo->map_bitmap_region();\n+  if (bitmap_base == 0) {\n+    _loading_failed = true;\n+    return false; \/\/ OOM or CRC error\n+  }\n+  uintptr_t load_address = buffer;\n+  for (int i = 0; i < num_loaded_regions; i++) {\n+    LoadedArchiveHeapRegion* ri = &loaded_regions[i];\n+    FileMapRegion* r = mapinfo->space_at(ri->_region_index);\n+\n+    if (!mapinfo->read_region(ri->_region_index, (char*)load_address, r->used(), \/* do_commit = *\/ false)) {\n+      \/\/ There's no easy way to free the buffer, so we will fill it with zero later\n+      \/\/ in fill_failed_loaded_region(), and it will eventually be GC'ed.\n+      log_warning(cds)(\"Loading of heap region %d has failed. Archived objects are disabled\", i);\n+      _loading_failed = true;\n+      return false;\n+    }\n+    log_info(cds)(\"Loaded heap    region #%d at base \" INTPTR_FORMAT \" top \" INTPTR_FORMAT\n+                  \" size \" SIZE_FORMAT_W(6) \" delta \" INTX_FORMAT,\n+                  ri->_region_index, load_address, load_address + ri->_region_size,\n+                  ri->_region_size, ri->_runtime_offset);\n+\n+    uintptr_t oopmap = bitmap_base + r->oopmap_offset();\n+    BitMapView bm((BitMap::bm_word_t*)oopmap, r->oopmap_size_in_bits());\n+\n+    if (num_loaded_regions == 4) {\n+      PatchLoadedRegionPointers<4> patcher((narrowOop*)load_address, loaded_regions);\n+      bm.iterate(&patcher);\n+    } else if (num_loaded_regions == 3) {\n+      PatchLoadedRegionPointers<3> patcher((narrowOop*)load_address, loaded_regions);\n+      bm.iterate(&patcher);\n+    } else {\n+      assert(num_loaded_regions == 2, \"must be\");\n+      PatchLoadedRegionPointers<2> patcher((narrowOop*)load_address, loaded_regions);\n+      bm.iterate(&patcher);\n+    }\n+\n+    load_address += r->used();\n+  }\n+\n+  return true;\n+}\n+\n+bool ArchiveHeapLoader::load_heap_regions(FileMapInfo* mapinfo) {\n+  init_narrow_oop_decoding(mapinfo->narrow_oop_base(), mapinfo->narrow_oop_shift());\n+\n+  LoadedArchiveHeapRegion loaded_regions[MetaspaceShared::max_num_heap_regions];\n+  memset(loaded_regions, 0, sizeof(loaded_regions));\n+\n+  MemRegion archive_space;\n+  int num_loaded_regions = init_loaded_regions(mapinfo, loaded_regions, archive_space);\n+  if (num_loaded_regions <= 0) {\n+    return false;\n+  }\n+  sort_loaded_regions(loaded_regions, num_loaded_regions, (uintptr_t)archive_space.start());\n+  if (!load_regions(mapinfo, loaded_regions, num_loaded_regions, (uintptr_t)archive_space.start())) {\n+    assert(_loading_failed, \"must be\");\n+    return false;\n+  }\n+\n+  init_loaded_heap_relocation(loaded_regions, num_loaded_regions);\n+  _is_loaded = true;\n+\n+  return true;\n+}\n+\n+class VerifyLoadedHeapEmbeddedPointers: public BasicOopIterateClosure {\n+  ResourceHashtable<uintptr_t, bool>* _table;\n+\n+ public:\n+  VerifyLoadedHeapEmbeddedPointers(ResourceHashtable<uintptr_t, bool>* table) : _table(table) {}\n+\n+  virtual void do_oop(narrowOop* p) {\n+    \/\/ This should be called before the loaded regions are modified, so all the embedded pointers\n+    \/\/ must be NULL, or must point to a valid object in the loaded regions.\n+    narrowOop v = *p;\n+    if (!CompressedOops::is_null(v)) {\n+      oop o = CompressedOops::decode_not_null(v);\n+      uintptr_t u = cast_from_oop<uintptr_t>(o);\n+      ArchiveHeapLoader::assert_in_loaded_heap(u);\n+      guarantee(_table->contains(u), \"must point to beginning of object in loaded archived regions\");\n+    }\n+  }\n+  virtual void do_oop(oop* p) {\n+    ShouldNotReachHere();\n+  }\n+};\n+\n+void ArchiveHeapLoader::finish_initialization() {\n+  if (is_loaded()) {\n+    HeapWord* bottom = (HeapWord*)_loaded_heap_bottom;\n+    HeapWord* top    = (HeapWord*)_loaded_heap_top;\n+\n+    MemRegion archive_space = MemRegion(bottom, top);\n+    Universe::heap()->complete_loaded_archive_space(archive_space);\n+  }\n+\n+  if (VerifyArchivedFields <= 0 || !is_loaded()) {\n+    return;\n+  }\n+\n+  log_info(cds, heap)(\"Verify all oops and pointers in loaded heap\");\n+\n+  ResourceMark rm;\n+  ResourceHashtable<uintptr_t, bool> table;\n+  VerifyLoadedHeapEmbeddedPointers verifier(&table);\n+  HeapWord* bottom = (HeapWord*)_loaded_heap_bottom;\n+  HeapWord* top    = (HeapWord*)_loaded_heap_top;\n+\n+  for (HeapWord* p = bottom; p < top; ) {\n+    oop o = cast_to_oop(p);\n+    table.put(cast_from_oop<uintptr_t>(o), true);\n+    p += o->size();\n+  }\n+\n+  for (HeapWord* p = bottom; p < top; ) {\n+    oop o = cast_to_oop(p);\n+    o->oop_iterate(&verifier);\n+    p += o->size();\n+  }\n+}\n+\n+void ArchiveHeapLoader::fill_failed_loaded_region() {\n+  assert(_loading_failed, \"must be\");\n+  if (_loaded_heap_bottom != 0) {\n+    assert(_loaded_heap_top != 0, \"must be\");\n+    HeapWord* bottom = (HeapWord*)_loaded_heap_bottom;\n+    HeapWord* top = (HeapWord*)_loaded_heap_top;\n+    Universe::heap()->fill_with_objects(bottom, top - bottom);\n+  }\n+}\n+\n+#endif \/\/ INCLUDE_CDS_JAVA_HEAP\n","filename":"src\/hotspot\/share\/cds\/archiveHeapLoader.cpp","additions":437,"deletions":0,"binary":false,"changes":437,"status":"added"},{"patch":"@@ -0,0 +1,170 @@\n+\/*\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_CDS_ARCHIVEHEAPLOADER_HPP\n+#define SHARE_CDS_ARCHIVEHEAPLOADER_HPP\n+\n+#include \"gc\/shared\/gc_globals.hpp\"\n+#include \"memory\/allocation.hpp\"\n+#include \"memory\/allStatic.hpp\"\n+#include \"runtime\/globals.hpp\"\n+#include \"oops\/oopsHierarchy.hpp\"\n+#include \"memory\/memRegion.hpp\"\n+#include \"utilities\/macros.hpp\"\n+\n+class  FileMapInfo;\n+struct LoadedArchiveHeapRegion;\n+\n+class ArchiveHeapLoader : AllStatic {\n+public:\n+  \/\/ At runtime, heap regions in the CDS archive can be used in two different ways,\n+  \/\/ depending on the GC type:\n+  \/\/ - Mapped: (G1 only) the regions are directly mapped into the Java heap\n+  \/\/ - Loaded: At VM start-up, the objects in the heap regions are copied into the\n+  \/\/           Java heap. This is easier to implement than mapping but\n+  \/\/           slightly less efficient, as the embedded pointers need to be relocated.\n+  static bool can_use() { return can_map() || can_load(); }\n+\n+  \/\/ Can this VM map archived heap regions? Currently only G1+compressed{oops,cp}\n+  static bool can_map() {\n+    CDS_JAVA_HEAP_ONLY(return (UseG1GC && UseCompressedClassPointers);)\n+    NOT_CDS_JAVA_HEAP(return false;)\n+  }\n+  static bool is_mapped() {\n+    return closed_regions_mapped() && open_regions_mapped();\n+  }\n+\n+  \/\/ Can this VM load the objects from archived heap regions into the heap at start-up?\n+  static bool can_load()  NOT_CDS_JAVA_HEAP_RETURN_(false);\n+  static void finish_initialization() NOT_CDS_JAVA_HEAP_RETURN;\n+  static bool is_loaded() {\n+    CDS_JAVA_HEAP_ONLY(return _is_loaded;)\n+    NOT_CDS_JAVA_HEAP(return false;)\n+  }\n+\n+  static bool are_archived_strings_available() {\n+    return is_loaded() || closed_regions_mapped();\n+  }\n+  static bool are_archived_mirrors_available() {\n+    return is_fully_available();\n+  }\n+  static bool is_fully_available() {\n+    return is_loaded() || is_mapped();\n+  }\n+\n+  static ptrdiff_t runtime_delta() {\n+    assert(!UseCompressedOops, \"must be\");\n+    CDS_JAVA_HEAP_ONLY(return _runtime_delta;)\n+    NOT_CDS_JAVA_HEAP_RETURN_(0L);\n+  }\n+\n+  static void set_closed_regions_mapped() {\n+    CDS_JAVA_HEAP_ONLY(_closed_regions_mapped = true;)\n+    NOT_CDS_JAVA_HEAP_RETURN;\n+  }\n+  static bool closed_regions_mapped() {\n+    CDS_JAVA_HEAP_ONLY(return _closed_regions_mapped;)\n+    NOT_CDS_JAVA_HEAP_RETURN_(false);\n+  }\n+  static void set_open_regions_mapped() {\n+    CDS_JAVA_HEAP_ONLY(_open_regions_mapped = true;)\n+    NOT_CDS_JAVA_HEAP_RETURN;\n+  }\n+  static bool open_regions_mapped() {\n+    CDS_JAVA_HEAP_ONLY(return _open_regions_mapped;)\n+    NOT_CDS_JAVA_HEAP_RETURN_(false);\n+  }\n+\n+  \/\/ NarrowOops stored in the CDS archive may use a different encoding scheme\n+  \/\/ than CompressedOops::{base,shift} -- see FileMapInfo::map_heap_regions_impl.\n+  \/\/ To decode them, do not use CompressedOops::decode_not_null. Use this\n+  \/\/ function instead.\n+  inline static oop decode_from_archive(narrowOop v) NOT_CDS_JAVA_HEAP_RETURN_(NULL);\n+\n+  static void init_narrow_oop_decoding(address base, int shift) NOT_CDS_JAVA_HEAP_RETURN;\n+\n+  static void patch_embedded_pointers(MemRegion region, address oopmap,\n+                                      size_t oopmap_in_bits) NOT_CDS_JAVA_HEAP_RETURN;\n+\n+  static void fixup_regions() NOT_CDS_JAVA_HEAP_RETURN;\n+\n+#if INCLUDE_CDS_JAVA_HEAP\n+private:\n+  static bool _closed_regions_mapped;\n+  static bool _open_regions_mapped;\n+  static bool _is_loaded;\n+\n+  \/\/ Support for loaded archived heap. These are cached values from\n+  \/\/ LoadedArchiveHeapRegion's.\n+  static uintptr_t _dumptime_base_0;\n+  static uintptr_t _dumptime_base_1;\n+  static uintptr_t _dumptime_base_2;\n+  static uintptr_t _dumptime_base_3;\n+  static uintptr_t _dumptime_top;\n+  static intx _runtime_offset_0;\n+  static intx _runtime_offset_1;\n+  static intx _runtime_offset_2;\n+  static intx _runtime_offset_3;\n+\n+  static uintptr_t _loaded_heap_bottom;\n+  static uintptr_t _loaded_heap_top;\n+  static bool _loading_failed;\n+\n+  \/\/ UseCompressedOops only: Used by decode_from_archive\n+  static address _narrow_oop_base;\n+  static int     _narrow_oop_shift;\n+\n+  \/\/ !UseCompressedOops only: used to relocate pointers to the archived objects\n+  static ptrdiff_t _runtime_delta;\n+\n+  static int init_loaded_regions(FileMapInfo* mapinfo, LoadedArchiveHeapRegion* loaded_regions,\n+                                 MemRegion& archive_space);\n+  static void sort_loaded_regions(LoadedArchiveHeapRegion* loaded_regions, int num_loaded_regions,\n+                                  uintptr_t buffer);\n+  static bool load_regions(FileMapInfo* mapinfo, LoadedArchiveHeapRegion* loaded_regions,\n+                           int num_loaded_regions, uintptr_t buffer);\n+  static void init_loaded_heap_relocation(LoadedArchiveHeapRegion* reloc_info,\n+                                          int num_loaded_regions);\n+  static void fill_failed_loaded_region();\n+\n+  static bool is_in_loaded_heap(uintptr_t o) {\n+    return (_loaded_heap_bottom <= o && o < _loaded_heap_top);\n+  }\n+\n+public:\n+\n+  static bool load_heap_regions(FileMapInfo* mapinfo);\n+  static void assert_in_loaded_heap(uintptr_t o) {\n+    assert(is_in_loaded_heap(o), \"must be\");\n+  }\n+\n+  static void set_runtime_delta(ptrdiff_t delta) {\n+    assert(!UseCompressedOops, \"must be\");\n+    _runtime_delta = delta;\n+  }\n+#endif \/\/ INCLUDE_CDS_JAVA_HEAP\n+\n+};\n+\n+#endif \/\/ SHARE_CDS_ARCHIVEHEAPLOADER_HPP\n","filename":"src\/hotspot\/share\/cds\/archiveHeapLoader.hpp","additions":170,"deletions":0,"binary":false,"changes":170,"status":"added"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_CDS_ARCHIVEHEAPLOADER_INLINE_HPP\n+#define SHARE_CDS_ARCHIVEHEAPLOADER_INLINE_HPP\n+\n+#include \"cds\/archiveHeapLoader.hpp\"\n+\n+#include \"oops\/compressedOops.inline.hpp\"\n+#include \"utilities\/align.hpp\"\n+\n+#if INCLUDE_CDS_JAVA_HEAP\n+\n+inline oop ArchiveHeapLoader::decode_from_archive(narrowOop v) {\n+  assert(!CompressedOops::is_null(v), \"narrow oop value can never be zero\");\n+  uintptr_t p = ((uintptr_t)_narrow_oop_base) + ((uintptr_t)v << _narrow_oop_shift);\n+  if (p >= _dumptime_base_0) {\n+    assert(p < _dumptime_top, \"must be\");\n+    if (p >= _dumptime_base_3) {\n+      p += _runtime_offset_3;\n+    } else if (p >= _dumptime_base_2) {\n+      p += _runtime_offset_2;\n+    } else if (p >= _dumptime_base_1) {\n+      p += _runtime_offset_1;\n+    } else {\n+      p += _runtime_offset_0;\n+    }\n+  }\n+\n+  oop result = cast_to_oop((uintptr_t)p);\n+  assert(is_object_aligned(result), \"address not aligned: \" INTPTR_FORMAT, p2i((void*) result));\n+  return result;\n+}\n+\n+#endif\n+\n+#endif \/\/ SHARE_CDS_ARCHIVEHEAPLOADER_INLINE_HPP\n","filename":"src\/hotspot\/share\/cds\/archiveHeapLoader.inline.hpp","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"cds\/archiveHeapLoader.inline.hpp\"\n@@ -32,1 +33,1 @@\n-#include \"cds\/heapShared.inline.hpp\"\n+#include \"cds\/heapShared.hpp\"\n@@ -318,1 +319,1 @@\n-    if (CompressedOops::is_null(o) || !HeapShared::is_fully_available()) {\n+    if (CompressedOops::is_null(o) || !ArchiveHeapLoader::is_fully_available()) {\n@@ -321,3 +322,3 @@\n-      assert(HeapShared::can_use(), \"sanity\");\n-      assert(HeapShared::is_fully_available(), \"must be\");\n-      *p = HeapShared::decode_from_archive(o);\n+      assert(ArchiveHeapLoader::can_use(), \"sanity\");\n+      assert(ArchiveHeapLoader::is_fully_available(), \"must be\");\n+      *p = ArchiveHeapLoader::decode_from_archive(o);\n@@ -327,1 +328,1 @@\n-    if (dumptime_oop == 0 || !HeapShared::is_fully_available()) {\n+    if (dumptime_oop == 0 || !ArchiveHeapLoader::is_fully_available()) {\n@@ -330,1 +331,1 @@\n-      intptr_t runtime_oop = dumptime_oop + HeapShared::runtime_delta();\n+      intptr_t runtime_oop = dumptime_oop + ArchiveHeapLoader::runtime_delta();\n","filename":"src\/hotspot\/share\/cds\/archiveUtils.cpp","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"cds\/archiveHeapLoader.inline.hpp\"\n@@ -32,1 +33,1 @@\n-#include \"cds\/heapShared.inline.hpp\"\n+#include \"cds\/heapShared.hpp\"\n@@ -1973,1 +1974,1 @@\n-    return cast_from_oop<address>(HeapShared::decode_from_archive(n));\n+    return cast_from_oop<address>(ArchiveHeapLoader::decode_from_archive(n));\n@@ -2019,1 +2020,1 @@\n-    if (HeapShared::can_map()) {\n+    if (ArchiveHeapLoader::can_map()) {\n@@ -2021,2 +2022,2 @@\n-    } else if (HeapShared::can_load()) {\n-      success = HeapShared::load_heap_regions(this);\n+    } else if (ArchiveHeapLoader::can_load()) {\n+      success = ArchiveHeapLoader::load_heap_regions(this);\n@@ -2088,1 +2089,1 @@\n-    return header()->heap_begin() + spc->mapping_offset() + HeapShared::runtime_delta();\n+    return header()->heap_begin() + spc->mapping_offset() + ArchiveHeapLoader::runtime_delta();\n@@ -2094,1 +2095,1 @@\n-    HeapShared::init_narrow_oop_decoding(narrow_oop_base() + delta, narrow_oop_shift());\n+    ArchiveHeapLoader::init_narrow_oop_decoding(narrow_oop_base() + delta, narrow_oop_shift());\n@@ -2096,1 +2097,1 @@\n-    HeapShared::set_runtime_delta(delta);\n+    ArchiveHeapLoader::set_runtime_delta(delta);\n@@ -2212,1 +2213,1 @@\n-    HeapShared::set_closed_regions_mapped();\n+    ArchiveHeapLoader::set_closed_regions_mapped();\n@@ -2219,1 +2220,1 @@\n-      HeapShared::set_open_regions_mapped();\n+      ArchiveHeapLoader::set_open_regions_mapped();\n@@ -2227,1 +2228,1 @@\n-  if (!HeapShared::closed_regions_mapped()) {\n+  if (!ArchiveHeapLoader::closed_regions_mapped()) {\n@@ -2232,1 +2233,1 @@\n-  if (!HeapShared::open_regions_mapped()) {\n+  if (!ArchiveHeapLoader::open_regions_mapped()) {\n@@ -2339,1 +2340,1 @@\n-    HeapShared::patch_embedded_pointers(\n+    ArchiveHeapLoader::patch_embedded_pointers(\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":14,"deletions":13,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"cds\/archiveHeapLoader.hpp\"\n@@ -29,2 +30,1 @@\n-#include \"cds\/filemap.hpp\"\n-#include \"cds\/heapShared.inline.hpp\"\n+#include \"cds\/heapShared.hpp\"\n@@ -48,2 +48,0 @@\n-#include \"memory\/metadataFactory.hpp\"\n-#include \"memory\/metaspaceClosure.hpp\"\n@@ -59,1 +57,0 @@\n-#include \"runtime\/globals_extension.hpp\"\n@@ -61,1 +58,0 @@\n-#include \"runtime\/java.hpp\"\n@@ -72,3 +68,0 @@\n-bool HeapShared::_closed_regions_mapped = false;\n-bool HeapShared::_open_regions_mapped = false;\n-bool HeapShared::_is_loaded = false;\n@@ -76,2 +69,0 @@\n-address   HeapShared::_narrow_oop_base;\n-int       HeapShared::_narrow_oop_shift;\n@@ -80,17 +71,0 @@\n-\/\/ Support for loaded heap.\n-uintptr_t HeapShared::_loaded_heap_bottom = 0;\n-uintptr_t HeapShared::_loaded_heap_top = 0;\n-uintptr_t HeapShared::_dumptime_base_0 = UINTPTR_MAX;\n-uintptr_t HeapShared::_dumptime_base_1 = UINTPTR_MAX;\n-uintptr_t HeapShared::_dumptime_base_2 = UINTPTR_MAX;\n-uintptr_t HeapShared::_dumptime_base_3 = UINTPTR_MAX;\n-uintptr_t HeapShared::_dumptime_top    = 0;\n-intx HeapShared::_runtime_offset_0 = 0;\n-intx HeapShared::_runtime_offset_1 = 0;\n-intx HeapShared::_runtime_offset_2 = 0;\n-intx HeapShared::_runtime_offset_3 = 0;\n-bool HeapShared::_loading_failed = false;\n-\n-\/\/ Support for mapped heap (!UseCompressedOops only)\n-ptrdiff_t HeapShared::_runtime_delta = 0;\n-\n@@ -165,16 +139,0 @@\n-void HeapShared::fixup_regions() {\n-  FileMapInfo* mapinfo = FileMapInfo::current_info();\n-  if (is_mapped()) {\n-    mapinfo->fixup_mapped_heap_regions();\n-  } else if (_loading_failed) {\n-    fill_failed_loaded_region();\n-  }\n-  if (is_fully_available()) {\n-    if (!MetaspaceShared::use_full_module_graph()) {\n-      \/\/ Need to remove all the archived java.lang.Module objects from HeapShared::roots().\n-      ClassLoaderDataShared::clear_archived_oops();\n-    }\n-  }\n-  SystemDictionaryShared::update_archived_mirror_native_pointers();\n-}\n-\n@@ -296,1 +254,1 @@\n-  if (is_fully_available()) {\n+  if (ArchiveHeapLoader::is_fully_available()) {\n@@ -441,1 +399,1 @@\n-  if (!is_fully_available()) {\n+  if (!ArchiveHeapLoader::is_fully_available()) {\n@@ -588,5 +546,0 @@\n-void HeapShared::init_narrow_oop_decoding(address base, int shift) {\n-  _narrow_oop_base = base;\n-  _narrow_oop_shift = shift;\n-}\n-\n@@ -813,1 +766,1 @@\n-      assert(HeapShared::is_fully_available(), \"must be\");\n+      assert(ArchiveHeapLoader::is_fully_available(), \"must be\");\n@@ -859,1 +812,1 @@\n-  if (!is_fully_available()) {\n+  if (!ArchiveHeapLoader::is_fully_available()) {\n@@ -897,1 +850,1 @@\n-  if (!is_fully_available()) {\n+  if (!ArchiveHeapLoader::is_fully_available()) {\n@@ -1666,347 +1619,0 @@\n-\/\/ Patch all the embedded oop pointers inside an archived heap region,\n-\/\/ to be consistent with the runtime oop encoding.\n-class PatchCompressedEmbeddedPointers: public BitMapClosure {\n-  narrowOop* _start;\n-\n- public:\n-  PatchCompressedEmbeddedPointers(narrowOop* start) : _start(start) {}\n-\n-  bool do_bit(size_t offset) {\n-    narrowOop* p = _start + offset;\n-    narrowOop v = *p;\n-    assert(!CompressedOops::is_null(v), \"null oops should have been filtered out at dump time\");\n-    oop o = HeapShared::decode_from_archive(v);\n-    RawAccess<IS_NOT_NULL>::oop_store(p, o);\n-    return true;\n-  }\n-};\n-\n-class PatchUncompressedEmbeddedPointers: public BitMapClosure {\n-  oop* _start;\n-\n- public:\n-  PatchUncompressedEmbeddedPointers(oop* start) : _start(start) {}\n-\n-  bool do_bit(size_t offset) {\n-    oop* p = _start + offset;\n-    intptr_t dumptime_oop = (intptr_t)((void*)*p);\n-    assert(dumptime_oop != 0, \"null oops should have been filtered out at dump time\");\n-    intptr_t runtime_oop = dumptime_oop + HeapShared::runtime_delta();\n-    RawAccess<IS_NOT_NULL>::oop_store(p, cast_to_oop(runtime_oop));\n-    return true;\n-  }\n-};\n-\n-\/\/ Patch all the non-null pointers that are embedded in the archived heap objects\n-\/\/ in this region\n-void HeapShared::patch_embedded_pointers(MemRegion region, address oopmap,\n-                                         size_t oopmap_size_in_bits) {\n-  BitMapView bm((BitMap::bm_word_t*)oopmap, oopmap_size_in_bits);\n-\n-#ifndef PRODUCT\n-  ResourceMark rm;\n-  ResourceBitMap checkBm = calculate_oopmap(region);\n-  assert(bm.is_same(checkBm), \"sanity\");\n-#endif\n-\n-  if (UseCompressedOops) {\n-    PatchCompressedEmbeddedPointers patcher((narrowOop*)region.start());\n-    bm.iterate(&patcher);\n-  } else {\n-    PatchUncompressedEmbeddedPointers patcher((oop*)region.start());\n-    bm.iterate(&patcher);\n-  }\n-}\n-\n-\/\/ The CDS archive remembers each heap object by its address at dump time, but\n-\/\/ the heap object may be loaded at a different address at run time. This structure is used\n-\/\/ to translate the dump time addresses for all objects in FileMapInfo::space_at(region_index)\n-\/\/ to their runtime addresses.\n-struct LoadedArchiveHeapRegion {\n-  int       _region_index;   \/\/ index for FileMapInfo::space_at(index)\n-  size_t    _region_size;    \/\/ number of bytes in this region\n-  uintptr_t _dumptime_base;  \/\/ The dump-time (decoded) address of the first object in this region\n-  intx      _runtime_offset; \/\/ If an object's dump time address P is within in this region, its\n-                             \/\/ runtime address is P + _runtime_offset\n-\n-  static int comparator(const void* a, const void* b) {\n-    LoadedArchiveHeapRegion* reg_a = (LoadedArchiveHeapRegion*)a;\n-    LoadedArchiveHeapRegion* reg_b = (LoadedArchiveHeapRegion*)b;\n-    if (reg_a->_dumptime_base < reg_b->_dumptime_base) {\n-      return -1;\n-    } else if (reg_a->_dumptime_base == reg_b->_dumptime_base) {\n-      return 0;\n-    } else {\n-      return 1;\n-    }\n-  }\n-\n-  uintptr_t top() {\n-    return _dumptime_base + _region_size;\n-  }\n-};\n-\n-void HeapShared::init_loaded_heap_relocation(LoadedArchiveHeapRegion* loaded_regions,\n-                                             int num_loaded_regions) {\n-  _dumptime_base_0 = loaded_regions[0]._dumptime_base;\n-  _dumptime_base_1 = loaded_regions[1]._dumptime_base;\n-  _dumptime_base_2 = loaded_regions[2]._dumptime_base;\n-  _dumptime_base_3 = loaded_regions[3]._dumptime_base;\n-  _dumptime_top = loaded_regions[num_loaded_regions-1].top();\n-\n-  _runtime_offset_0 = loaded_regions[0]._runtime_offset;\n-  _runtime_offset_1 = loaded_regions[1]._runtime_offset;\n-  _runtime_offset_2 = loaded_regions[2]._runtime_offset;\n-  _runtime_offset_3 = loaded_regions[3]._runtime_offset;\n-\n-  assert(2 <= num_loaded_regions && num_loaded_regions <= 4, \"must be\");\n-  if (num_loaded_regions < 4) {\n-    _dumptime_base_3 = UINTPTR_MAX;\n-  }\n-  if (num_loaded_regions < 3) {\n-    _dumptime_base_2 = UINTPTR_MAX;\n-  }\n-}\n-\n-bool HeapShared::can_load() {\n-  return Universe::heap()->can_load_archived_objects();\n-}\n-\n-template <int NUM_LOADED_REGIONS>\n-class PatchLoadedRegionPointers: public BitMapClosure {\n-  narrowOop* _start;\n-  intx _offset_0;\n-  intx _offset_1;\n-  intx _offset_2;\n-  intx _offset_3;\n-  uintptr_t _base_0;\n-  uintptr_t _base_1;\n-  uintptr_t _base_2;\n-  uintptr_t _base_3;\n-  uintptr_t _top;\n-\n-  static_assert(MetaspaceShared::max_num_heap_regions == 4, \"can't handle more than 4 regions\");\n-  static_assert(NUM_LOADED_REGIONS >= 2, \"we have at least 2 loaded regions\");\n-  static_assert(NUM_LOADED_REGIONS <= 4, \"we have at most 4 loaded regions\");\n-\n- public:\n-  PatchLoadedRegionPointers(narrowOop* start, LoadedArchiveHeapRegion* loaded_regions)\n-    : _start(start),\n-      _offset_0(loaded_regions[0]._runtime_offset),\n-      _offset_1(loaded_regions[1]._runtime_offset),\n-      _offset_2(loaded_regions[2]._runtime_offset),\n-      _offset_3(loaded_regions[3]._runtime_offset),\n-      _base_0(loaded_regions[0]._dumptime_base),\n-      _base_1(loaded_regions[1]._dumptime_base),\n-      _base_2(loaded_regions[2]._dumptime_base),\n-      _base_3(loaded_regions[3]._dumptime_base) {\n-    _top = loaded_regions[NUM_LOADED_REGIONS-1].top();\n-  }\n-\n-  bool do_bit(size_t offset) {\n-    narrowOop* p = _start + offset;\n-    narrowOop v = *p;\n-    assert(!CompressedOops::is_null(v), \"null oops should have been filtered out at dump time\");\n-    uintptr_t o = cast_from_oop<uintptr_t>(HeapShared::decode_from_archive(v));\n-    assert(_base_0 <= o && o < _top, \"must be\");\n-\n-\n-    \/\/ We usually have only 2 regions for the default archive. Use template to avoid unnecessary comparisons.\n-    if (NUM_LOADED_REGIONS > 3 && o >= _base_3) {\n-      o += _offset_3;\n-    } else if (NUM_LOADED_REGIONS > 2 && o >= _base_2) {\n-      o += _offset_2;\n-    } else if (o >= _base_1) {\n-      o += _offset_1;\n-    } else {\n-      o += _offset_0;\n-    }\n-    HeapShared::assert_in_loaded_heap(o);\n-    RawAccess<IS_NOT_NULL>::oop_store(p, cast_to_oop(o));\n-    return true;\n-  }\n-};\n-\n-int HeapShared::init_loaded_regions(FileMapInfo* mapinfo, LoadedArchiveHeapRegion* loaded_regions,\n-                                    MemRegion& archive_space) {\n-  size_t total_bytes = 0;\n-  int num_loaded_regions = 0;\n-  for (int i = MetaspaceShared::first_archive_heap_region;\n-       i <= MetaspaceShared::last_archive_heap_region; i++) {\n-    FileMapRegion* r = mapinfo->space_at(i);\n-    r->assert_is_heap_region();\n-    if (r->used() > 0) {\n-      assert(is_aligned(r->used(), HeapWordSize), \"must be\");\n-      total_bytes += r->used();\n-      LoadedArchiveHeapRegion* ri = &loaded_regions[num_loaded_regions++];\n-      ri->_region_index = i;\n-      ri->_region_size = r->used();\n-      ri->_dumptime_base = (uintptr_t)mapinfo->start_address_as_decoded_from_archive(r);\n-    }\n-  }\n-\n-  assert(is_aligned(total_bytes, HeapWordSize), \"must be\");\n-  size_t word_size = total_bytes \/ HeapWordSize;\n-  HeapWord* buffer = Universe::heap()->allocate_loaded_archive_space(word_size);\n-  if (buffer == nullptr) {\n-    return 0;\n-  }\n-\n-  archive_space = MemRegion(buffer, word_size);\n-  _loaded_heap_bottom = (uintptr_t)archive_space.start();\n-  _loaded_heap_top    = _loaded_heap_bottom + total_bytes;\n-\n-  return num_loaded_regions;\n-}\n-\n-void HeapShared::sort_loaded_regions(LoadedArchiveHeapRegion* loaded_regions, int num_loaded_regions,\n-                                     uintptr_t buffer) {\n-  \/\/ Find the relocation offset of the pointers in each region\n-  qsort(loaded_regions, num_loaded_regions, sizeof(LoadedArchiveHeapRegion),\n-        LoadedArchiveHeapRegion::comparator);\n-\n-  uintptr_t p = buffer;\n-  for (int i = 0; i < num_loaded_regions; i++) {\n-    \/\/ This region will be loaded at p, so all objects inside this\n-    \/\/ region will be shifted by ri->offset\n-    LoadedArchiveHeapRegion* ri = &loaded_regions[i];\n-    ri->_runtime_offset = p - ri->_dumptime_base;\n-    p += ri->_region_size;\n-  }\n-  assert(p == _loaded_heap_top, \"must be\");\n-}\n-\n-bool HeapShared::load_regions(FileMapInfo* mapinfo, LoadedArchiveHeapRegion* loaded_regions,\n-                              int num_loaded_regions, uintptr_t buffer) {\n-  uintptr_t bitmap_base = (uintptr_t)mapinfo->map_bitmap_region();\n-  if (bitmap_base == 0) {\n-    _loading_failed = true;\n-    return false; \/\/ OOM or CRC error\n-  }\n-  uintptr_t load_address = buffer;\n-  for (int i = 0; i < num_loaded_regions; i++) {\n-    LoadedArchiveHeapRegion* ri = &loaded_regions[i];\n-    FileMapRegion* r = mapinfo->space_at(ri->_region_index);\n-\n-    if (!mapinfo->read_region(ri->_region_index, (char*)load_address, r->used(), \/* do_commit = *\/ false)) {\n-      \/\/ There's no easy way to free the buffer, so we will fill it with zero later\n-      \/\/ in fill_failed_loaded_region(), and it will eventually be GC'ed.\n-      log_warning(cds)(\"Loading of heap region %d has failed. Archived objects are disabled\", i);\n-      _loading_failed = true;\n-      return false;\n-    }\n-    log_info(cds)(\"Loaded heap    region #%d at base \" INTPTR_FORMAT \" top \" INTPTR_FORMAT\n-                  \" size \" SIZE_FORMAT_W(6) \" delta \" INTX_FORMAT,\n-                  ri->_region_index, load_address, load_address + ri->_region_size,\n-                  ri->_region_size, ri->_runtime_offset);\n-\n-    uintptr_t oopmap = bitmap_base + r->oopmap_offset();\n-    BitMapView bm((BitMap::bm_word_t*)oopmap, r->oopmap_size_in_bits());\n-\n-    if (num_loaded_regions == 4) {\n-      PatchLoadedRegionPointers<4> patcher((narrowOop*)load_address, loaded_regions);\n-      bm.iterate(&patcher);\n-    } else if (num_loaded_regions == 3) {\n-      PatchLoadedRegionPointers<3> patcher((narrowOop*)load_address, loaded_regions);\n-      bm.iterate(&patcher);\n-    } else {\n-      assert(num_loaded_regions == 2, \"must be\");\n-      PatchLoadedRegionPointers<2> patcher((narrowOop*)load_address, loaded_regions);\n-      bm.iterate(&patcher);\n-    }\n-\n-    load_address += r->used();\n-  }\n-\n-  return true;\n-}\n-\n-bool HeapShared::load_heap_regions(FileMapInfo* mapinfo) {\n-  init_narrow_oop_decoding(mapinfo->narrow_oop_base(), mapinfo->narrow_oop_shift());\n-\n-  LoadedArchiveHeapRegion loaded_regions[MetaspaceShared::max_num_heap_regions];\n-  memset(loaded_regions, 0, sizeof(loaded_regions));\n-\n-  MemRegion archive_space;\n-  int num_loaded_regions = init_loaded_regions(mapinfo, loaded_regions, archive_space);\n-  if (num_loaded_regions <= 0) {\n-    return false;\n-  }\n-  sort_loaded_regions(loaded_regions, num_loaded_regions, (uintptr_t)archive_space.start());\n-  if (!load_regions(mapinfo, loaded_regions, num_loaded_regions, (uintptr_t)archive_space.start())) {\n-    assert(_loading_failed, \"must be\");\n-    return false;\n-  }\n-\n-  init_loaded_heap_relocation(loaded_regions, num_loaded_regions);\n-  _is_loaded = true;\n-\n-  return true;\n-}\n-\n-class VerifyLoadedHeapEmbeddedPointers: public BasicOopIterateClosure {\n-  ResourceHashtable<uintptr_t, bool>* _table;\n-\n- public:\n-  VerifyLoadedHeapEmbeddedPointers(ResourceHashtable<uintptr_t, bool>* table) : _table(table) {}\n-\n-  virtual void do_oop(narrowOop* p) {\n-    \/\/ This should be called before the loaded regions are modified, so all the embedded pointers\n-    \/\/ must be NULL, or must point to a valid object in the loaded regions.\n-    narrowOop v = *p;\n-    if (!CompressedOops::is_null(v)) {\n-      oop o = CompressedOops::decode_not_null(v);\n-      uintptr_t u = cast_from_oop<uintptr_t>(o);\n-      HeapShared::assert_in_loaded_heap(u);\n-      guarantee(_table->contains(u), \"must point to beginning of object in loaded archived regions\");\n-    }\n-  }\n-  virtual void do_oop(oop* p) {\n-    ShouldNotReachHere();\n-  }\n-};\n-\n-void HeapShared::finish_initialization() {\n-  if (is_loaded()) {\n-    HeapWord* bottom = (HeapWord*)_loaded_heap_bottom;\n-    HeapWord* top    = (HeapWord*)_loaded_heap_top;\n-\n-    MemRegion archive_space = MemRegion(bottom, top);\n-    Universe::heap()->complete_loaded_archive_space(archive_space);\n-  }\n-\n-  if (VerifyArchivedFields <= 0 || !is_loaded()) {\n-    return;\n-  }\n-\n-  log_info(cds, heap)(\"Verify all oops and pointers in loaded heap\");\n-\n-  ResourceMark rm;\n-  ResourceHashtable<uintptr_t, bool> table;\n-  VerifyLoadedHeapEmbeddedPointers verifier(&table);\n-  HeapWord* bottom = (HeapWord*)_loaded_heap_bottom;\n-  HeapWord* top    = (HeapWord*)_loaded_heap_top;\n-\n-  for (HeapWord* p = bottom; p < top; ) {\n-    oop o = cast_to_oop(p);\n-    table.put(cast_from_oop<uintptr_t>(o), true);\n-    p += o->size();\n-  }\n-\n-  for (HeapWord* p = bottom; p < top; ) {\n-    oop o = cast_to_oop(p);\n-    o->oop_iterate(&verifier);\n-    p += o->size();\n-  }\n-}\n-\n-void HeapShared::fill_failed_loaded_region() {\n-  assert(_loading_failed, \"must be\");\n-  if (_loaded_heap_bottom != 0) {\n-    assert(_loaded_heap_top != 0, \"must be\");\n-    HeapWord* bottom = (HeapWord*)_loaded_heap_bottom;\n-    HeapWord* top = (HeapWord*)_loaded_heap_top;\n-    Universe::heap()->fill_with_objects(bottom, top - bottom);\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/cds\/heapShared.cpp","additions":7,"deletions":401,"binary":false,"changes":408,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-#include \"classfile\/systemDictionary.hpp\"\n@@ -35,0 +34,1 @@\n+#include \"memory\/allStatic.hpp\"\n@@ -36,1 +36,0 @@\n-#include \"oops\/objArrayKlass.hpp\"\n@@ -40,2 +39,0 @@\n-#include \"oops\/typeArrayKlass.hpp\"\n-#include \"utilities\/bitMap.hpp\"\n@@ -49,0 +46,1 @@\n+class ResourceBitMap;\n@@ -151,8 +149,0 @@\n-  \/\/ At runtime, heap regions in the CDS archive can be used in two different ways,\n-  \/\/ depending on the GC type:\n-  \/\/ - Mapped: (G1 only) the regions are directly mapped into the Java heap\n-  \/\/ - Loaded: At VM start-up, the objects in the heap regions are copied into the\n-  \/\/           Java heap. This is easier to implement than mapping but\n-  \/\/           slightly less efficient, as the embedded pointers need to be relocated.\n-  static bool can_use() { return can_map() || can_load(); }\n-\n@@ -173,8 +163,0 @@\n-  \/\/ Can this VM map archived heap regions? Currently only G1+compressed{oops,cp}\n-  static bool can_map() {\n-    CDS_JAVA_HEAP_ONLY(return (UseG1GC && UseCompressedClassPointers);)\n-    NOT_CDS_JAVA_HEAP(return false;)\n-  }\n-  static bool is_mapped() {\n-    return closed_regions_mapped() && open_regions_mapped();\n-  }\n@@ -182,17 +164,0 @@\n-  \/\/ Can this VM load the objects from archived heap regions into the heap at start-up?\n-  static bool can_load()  NOT_CDS_JAVA_HEAP_RETURN_(false);\n-  static void finish_initialization() NOT_CDS_JAVA_HEAP_RETURN;\n-  static bool is_loaded() {\n-    CDS_JAVA_HEAP_ONLY(return _is_loaded;)\n-    NOT_CDS_JAVA_HEAP(return false;)\n-  }\n-\n-  static bool are_archived_strings_available() {\n-    return is_loaded() || closed_regions_mapped();\n-  }\n-  static bool are_archived_mirrors_available() {\n-    return is_fully_available();\n-  }\n-  static bool is_fully_available() {\n-    return is_loaded() || is_mapped();\n-  }\n@@ -203,3 +168,0 @@\n-  static bool _closed_regions_mapped;\n-  static bool _open_regions_mapped;\n-  static bool _is_loaded;\n@@ -208,15 +170,0 @@\n-  \/\/ Support for loaded archived heap. These are cached values from\n-  \/\/ LoadedArchiveHeapRegion's.\n-  static uintptr_t _dumptime_base_0;\n-  static uintptr_t _dumptime_base_1;\n-  static uintptr_t _dumptime_base_2;\n-  static uintptr_t _dumptime_base_3;\n-  static uintptr_t _dumptime_top;\n-  static intx _runtime_offset_0;\n-  static intx _runtime_offset_1;\n-  static intx _runtime_offset_2;\n-  static intx _runtime_offset_3;\n-  static uintptr_t _loaded_heap_bottom;\n-  static uintptr_t _loaded_heap_top;\n-  static bool _loading_failed;\n-\n@@ -229,5 +176,0 @@\n-  static bool load_heap_regions(FileMapInfo* mapinfo);\n-  static void assert_in_loaded_heap(uintptr_t o) {\n-    assert(is_in_loaded_heap(o), \"must be\");\n-  }\n-\n@@ -246,3 +188,0 @@\n-  static bool is_in_loaded_heap(uintptr_t o) {\n-    return (_loaded_heap_bottom <= o && o < _loaded_heap_top);\n-  }\n@@ -460,5 +399,0 @@\n-  static void set_runtime_delta(ptrdiff_t delta) {\n-    assert(!UseCompressedOops, \"must be\");\n-    _runtime_delta = delta;\n-  }\n-\n@@ -468,6 +402,0 @@\n-  static ptrdiff_t runtime_delta() {\n-    assert(!UseCompressedOops, \"must be\");\n-    CDS_JAVA_HEAP_ONLY(return _runtime_delta;)\n-    NOT_CDS_JAVA_HEAP_RETURN_(0L);\n-  }\n-\n@@ -482,19 +410,0 @@\n-  static void set_closed_regions_mapped() {\n-    CDS_JAVA_HEAP_ONLY(_closed_regions_mapped = true;)\n-    NOT_CDS_JAVA_HEAP_RETURN;\n-  }\n-  static bool closed_regions_mapped() {\n-    CDS_JAVA_HEAP_ONLY(return _closed_regions_mapped;)\n-    NOT_CDS_JAVA_HEAP_RETURN_(false);\n-  }\n-  static void set_open_regions_mapped() {\n-    CDS_JAVA_HEAP_ONLY(_open_regions_mapped = true;)\n-    NOT_CDS_JAVA_HEAP_RETURN;\n-  }\n-  static bool open_regions_mapped() {\n-    CDS_JAVA_HEAP_ONLY(return _open_regions_mapped;)\n-    NOT_CDS_JAVA_HEAP_RETURN_(false);\n-  }\n-\n-  static void fixup_regions() NOT_CDS_JAVA_HEAP_RETURN;\n-\n@@ -505,11 +414,0 @@\n-\n-  \/\/ NarrowOops stored in the CDS archive may use a different encoding scheme\n-  \/\/ than CompressedOops::{base,shift} -- see FileMapInfo::map_heap_regions_impl.\n-  \/\/ To decode them, do not use CompressedOops::decode_not_null. Use this\n-  \/\/ function instead.\n-  inline static oop decode_from_archive(narrowOop v) NOT_CDS_JAVA_HEAP_RETURN_(NULL);\n-\n-  static void init_narrow_oop_decoding(address base, int shift) NOT_CDS_JAVA_HEAP_RETURN;\n-\n-  static void patch_embedded_pointers(MemRegion region, address oopmap,\n-                                      size_t oopmap_in_bits) NOT_CDS_JAVA_HEAP_RETURN;\n","filename":"src\/hotspot\/share\/cds\/heapShared.hpp","additions":2,"deletions":104,"binary":false,"changes":106,"status":"modified"},{"patch":"@@ -1,57 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_CDS_HEAPSHARED_INLINE_HPP\n-#define SHARE_CDS_HEAPSHARED_INLINE_HPP\n-\n-#include \"cds\/heapShared.hpp\"\n-#include \"oops\/compressedOops.inline.hpp\"\n-#include \"utilities\/align.hpp\"\n-\n-#if INCLUDE_CDS_JAVA_HEAP\n-\n-inline oop HeapShared::decode_from_archive(narrowOop v) {\n-  assert(!CompressedOops::is_null(v), \"narrow oop value can never be zero\");\n-  uintptr_t p = ((uintptr_t)_narrow_oop_base) + ((uintptr_t)v << _narrow_oop_shift);\n-  if (p >= _dumptime_base_0) {\n-    assert(p < _dumptime_top, \"must be\");\n-    if (p >= _dumptime_base_3) {\n-      p += _runtime_offset_3;\n-    } else if (p >= _dumptime_base_2) {\n-      p += _runtime_offset_2;\n-    } else if (p >= _dumptime_base_1) {\n-      p += _runtime_offset_1;\n-    } else {\n-      p += _runtime_offset_0;\n-    }\n-  }\n-\n-  oop result = cast_to_oop((uintptr_t)p);\n-  assert(is_object_aligned(result), \"address not aligned: \" INTPTR_FORMAT, p2i((void*) result));\n-  return result;\n-}\n-\n-#endif\n-\n-#endif \/\/ SHARE_CDS_HEAPSHARED_INLINE_HPP\n","filename":"src\/hotspot\/share\/cds\/heapShared.inline.hpp","additions":0,"deletions":57,"binary":false,"changes":57,"status":"deleted"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"cds\/archiveHeapLoader.hpp\"\n@@ -1473,1 +1474,1 @@\n-  HeapShared::finish_initialization();\n+  ArchiveHeapLoader::finish_initialization();\n@@ -1560,1 +1561,1 @@\n-    result &= HeapShared::can_use();\n+    result &= ArchiveHeapLoader::can_use();\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-#include \"cds\/heapShared.inline.hpp\"\n","filename":"src\/hotspot\/share\/classfile\/compactHashtable.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,1 +28,2 @@\n-#include \"cds\/heapShared.inline.hpp\"\n+#include \"cds\/archiveHeapLoader.hpp\"\n+#include \"cds\/heapShared.hpp\"\n@@ -58,0 +59,1 @@\n+#include \"oops\/objArrayKlass.hpp\"\n@@ -897,1 +899,1 @@\n-    if (HeapShared::are_archived_mirrors_available()) {\n+    if (ArchiveHeapLoader::are_archived_mirrors_available()) {\n@@ -1324,1 +1326,1 @@\n-  if (HeapShared::is_mapped()) {\n+  if (ArchiveHeapLoader::is_mapped()) {\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -991,0 +991,2 @@\n+  static inline bool is_weak(oop ref);\n+  static inline bool is_soft(oop ref);\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"memory\/referenceType.hpp\"\n@@ -135,0 +136,1 @@\n+  assert(java_lang_ref_Reference::is_weak(ref) || java_lang_ref_Reference::is_soft(ref), \"must be Weak or Soft Reference\");\n@@ -139,0 +141,1 @@\n+  assert(java_lang_ref_Reference::is_weak(ref) || java_lang_ref_Reference::is_soft(ref), \"must be Weak or Soft Reference\");\n@@ -143,0 +146,1 @@\n+  assert(java_lang_ref_Reference::is_phantom(ref), \"must be Phantom Reference\");\n@@ -198,0 +202,8 @@\n+bool java_lang_ref_Reference::is_weak(oop ref) {\n+  return InstanceKlass::cast(ref->klass())->reference_type() == REF_WEAK;\n+}\n+\n+bool java_lang_ref_Reference::is_soft(oop ref) {\n+  return InstanceKlass::cast(ref->klass())->reference_type() == REF_SOFT;\n+}\n+\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.inline.hpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"cds\/archiveHeapLoader.inline.hpp\"\n@@ -28,1 +29,1 @@\n-#include \"cds\/heapShared.inline.hpp\"\n+#include \"cds\/heapShared.hpp\"\n@@ -77,1 +78,1 @@\n-    return HeapShared::decode_from_archive(v);\n+    return ArchiveHeapLoader::decode_from_archive(v);\n@@ -83,1 +84,1 @@\n-                           (intptr_t)HeapShared::runtime_delta();\n+                           (intptr_t)ArchiveHeapLoader::runtime_delta();\n@@ -834,1 +835,1 @@\n-  } else if (!HeapShared::are_archived_strings_available()) {\n+  } else if (!ArchiveHeapLoader::are_archived_strings_available()) {\n@@ -864,1 +865,1 @@\n-  assert(HeapShared::is_loaded(), \"must be\");\n+  assert(ArchiveHeapLoader::is_loaded(), \"must be\");\n","filename":"src\/hotspot\/share\/classfile\/stringTable.cpp","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2039,1 +2039,0 @@\n-  methodHandle empty;\n@@ -2046,2 +2045,0 @@\n-  Method** met;\n-  InvokeMethodKey key(signature, iid_as_int);\n@@ -2050,1 +2047,2 @@\n-    met = _invoke_method_intrinsic_table.get(key);\n+    InvokeMethodKey key(signature, iid_as_int);\n+    Method** met = _invoke_method_intrinsic_table.get(key);\n@@ -2054,1 +2052,0 @@\n-  }\n@@ -2056,23 +2053,21 @@\n-  methodHandle m = Method::make_method_handle_intrinsic(iid, signature, CHECK_NULL);\n-  if (!Arguments::is_interpreter_only() || iid == vmIntrinsics::_linkToNative) {\n-      \/\/ Generate a compiled form of the MH intrinsic\n-      \/\/ linkToNative doesn't have interpreter-specific implementation, so always has to go through compiled version.\n-      AdapterHandlerLibrary::create_native_wrapper(m);\n-      \/\/ Check if have the compiled code.\n-      if (!m->has_compiled_code()) {\n-        THROW_MSG_NULL(vmSymbols::java_lang_VirtualMachineError(),\n-                       \"Out of space in CodeCache for method handle intrinsic\");\n-      }\n-  }\n-  \/\/ Now grab the lock.  We might have to throw away the new method,\n-  \/\/ if a racing thread has managed to install one at the same time.\n-  {\n-    MutexLocker ml(THREAD, InvokeMethodTable_lock);\n-    signature->make_permanent(); \/\/ The signature is never unloaded.\n-    bool created;\n-    met = _invoke_method_intrinsic_table.put_if_absent(key, m(), &created);\n-    Method* saved_method = *met;\n-    assert(Arguments::is_interpreter_only() || (saved_method->has_compiled_code() &&\n-         saved_method->code()->entry_point() == saved_method->from_compiled_entry()),\n-         \"MH intrinsic invariant\");\n-    return saved_method;\n+    bool throw_error = false;\n+    \/\/ This function could get an OOM but it is safe to call inside of a lock because\n+    \/\/ throwing OutOfMemoryError doesn't call Java code.\n+    methodHandle m = Method::make_method_handle_intrinsic(iid, signature, CHECK_NULL);\n+    if (!Arguments::is_interpreter_only() || iid == vmIntrinsics::_linkToNative) {\n+        \/\/ Generate a compiled form of the MH intrinsic\n+        \/\/ linkToNative doesn't have interpreter-specific implementation, so always has to go through compiled version.\n+        AdapterHandlerLibrary::create_native_wrapper(m);\n+        \/\/ Check if have the compiled code.\n+        throw_error = (!m->has_compiled_code());\n+    }\n+\n+    if (!throw_error) {\n+      signature->make_permanent(); \/\/ The signature is never unloaded.\n+      bool created = _invoke_method_intrinsic_table.put(key, m());\n+      assert(created, \"must be since we still hold the lock\");\n+      assert(Arguments::is_interpreter_only() || (m->has_compiled_code() &&\n+             m->code()->entry_point() == m->from_compiled_entry()),\n+             \"MH intrinsic invariant\");\n+      return m();\n+    }\n@@ -2080,0 +2075,4 @@\n+\n+  \/\/ Throw error outside of the lock.\n+  THROW_MSG_NULL(vmSymbols::java_lang_VirtualMachineError(),\n+                 \"Out of space in CodeCache for method handle intrinsic\");\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":27,"deletions":28,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-#include \"cds\/archiveUtils.hpp\"\n@@ -28,0 +27,2 @@\n+#include \"cds\/archiveHeapLoader.hpp\"\n+#include \"cds\/archiveUtils.hpp\"\n@@ -32,1 +33,0 @@\n-#include \"cds\/heapShared.hpp\"\n@@ -63,0 +63,1 @@\n+#include \"oops\/objArrayKlass.hpp\"\n@@ -1602,1 +1603,1 @@\n-  if (!HeapShared::are_archived_mirrors_available()) {\n+  if (!ArchiveHeapLoader::are_archived_mirrors_available()) {\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-#include \"cds\/heapShared.hpp\"\n+#include \"cds\/archiveHeapLoader.hpp\"\n@@ -30,0 +30,1 @@\n+#include \"classfile\/javaClasses.hpp\"\n@@ -138,1 +139,1 @@\n-    \/\/ HeapShared::fixup_regions() fills the empty\n+    \/\/ ArchiveHeapLoader::fixup_regions fills the empty\n@@ -144,1 +145,1 @@\n-    HeapShared::fixup_regions();\n+    ArchiveHeapLoader::fixup_regions();\n","filename":"src\/hotspot\/share\/classfile\/vmClasses.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1274,0 +1274,16 @@\n+    bool should_clear_region(HeapRegion* hr) const {\n+      \/\/ The bitmap for young regions must obviously be clear as we never mark through them;\n+      \/\/ old regions are only in the collection set after the concurrent cycle completed,\n+      \/\/ so their bitmaps must also be clear except when the pause occurs during the\n+      \/\/ Concurrent Cleanup for Next Mark phase. Only at that point the region's bitmap may\n+      \/\/ contain marks while being in the collection set at the same time.\n+      \/\/\n+      \/\/ There is one exception: shutdown might have aborted the Concurrent Cleanup for Next\n+      \/\/ Mark phase midway, which might have also left stale marks in old generation regions.\n+      \/\/ There might actually have been scheduled multiple collections, but at that point we do\n+      \/\/ not care that much about performance and just do the work multiple times if needed.\n+      return (_g1h->collector_state()->clearing_bitmap() ||\n+              _g1h->concurrent_mark_is_terminating()) &&\n+              hr->is_old();\n+    }\n+\n@@ -1282,7 +1298,1 @@\n-      \/\/\n-      \/\/ A clear bitmap is obvious for young regions as we never mark through them;\n-      \/\/ old regions are only in the collection set after the concurrent cycle completed,\n-      \/\/ so their bitmaps must also be clear except when the pause occurs during the\n-      \/\/ concurrent bitmap clear. At that point the region's bitmap may contain marks\n-      \/\/ while being in the collection set at the same time.\n-      if (_g1h->collector_state()->clearing_bitmap() && hr->is_old()) {\n+      if (should_clear_region(hr)) {\n@@ -1605,1 +1615,1 @@\n-  assert(!_g1h->is_gc_active(), \"Only call concurrently\");\n+  assert(!SafepointSynchronize::is_at_safepoint(), \"Only call concurrently\");\n@@ -1660,2 +1670,0 @@\n-    assert(!SafepointSynchronize::is_at_safepoint(), \"sanity\");\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSet.cpp","additions":18,"deletions":10,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -870,3 +870,0 @@\n-      assert(gch->gc_cause() == GCCause::_scavenge_alot ||\n-             !gch->incremental_collection_failed(),\n-             \"Twice in a row\");\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -99,1 +99,1 @@\n-AbstractInterpreterGenerator::AbstractInterpreterGenerator(StubQueue* _code) {\n+AbstractInterpreterGenerator::AbstractInterpreterGenerator() {\n","filename":"src\/hotspot\/share\/interpreter\/abstractInterpreter.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -298,1 +298,1 @@\n-  AbstractInterpreterGenerator(StubQueue* _code);\n+  AbstractInterpreterGenerator();\n","filename":"src\/hotspot\/share\/interpreter\/abstractInterpreter.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -66,1 +66,1 @@\n-    TemplateInterpreterGenerator g(_code);\n+    TemplateInterpreterGenerator g;\n","filename":"src\/hotspot\/share\/interpreter\/templateInterpreter.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-TemplateInterpreterGenerator::TemplateInterpreterGenerator(StubQueue* _code): AbstractInterpreterGenerator(_code) {\n+TemplateInterpreterGenerator::TemplateInterpreterGenerator(): AbstractInterpreterGenerator() {\n","filename":"src\/hotspot\/share\/interpreter\/templateInterpreterGenerator.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -130,1 +130,1 @@\n-  TemplateInterpreterGenerator(StubQueue* _code);\n+  TemplateInterpreterGenerator();\n","filename":"src\/hotspot\/share\/interpreter\/templateInterpreterGenerator.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n-ZeroInterpreterGenerator::ZeroInterpreterGenerator(StubQueue* _code): AbstractInterpreterGenerator(_code) {\n+ZeroInterpreterGenerator::ZeroInterpreterGenerator(): AbstractInterpreterGenerator() {\n","filename":"src\/hotspot\/share\/interpreter\/zero\/zeroInterpreterGenerator.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,1 +52,1 @@\n-  ZeroInterpreterGenerator(StubQueue* _code);\n+  ZeroInterpreterGenerator();\n","filename":"src\/hotspot\/share\/interpreter\/zero\/zeroInterpreterGenerator.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -130,2 +130,4 @@\n-  if (is_compiler_linking_event_writer(target->method_holder()->name(), target->name()) && !IS_METHOD_BLESSED(caller)) {\n-    THROW_MSG(vmSymbols::java_lang_IllegalAccessError(), link_error_msg);\n+  if (is_compiler_linking_event_writer(target->method_holder()->name(), target->name())) {\n+    if (caller == nullptr || !IS_METHOD_BLESSED(caller)) {\n+      THROW_MSG(vmSymbols::java_lang_IllegalAccessError(), link_error_msg);\n+    }\n","filename":"src\/hotspot\/share\/jfr\/instrumentation\/jfrResolution.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -331,1 +331,0 @@\n-  const size_t _renew_size;\n@@ -408,2 +407,1 @@\n-  _min_size(JfrOptionSet::stackdepth() * sizeof(intptr_t)),\n-  _renew_size(_min_size * 2),\n+  _min_size(max_frames * 2 * wordSize), \/\/ each frame tags at most 2 words, min size is a full stacktrace\n@@ -556,2 +554,2 @@\n-  const JfrBuffer* buffer = JfrTraceIdLoadBarrier::get_enqueue_buffer(this);\n-  return buffer != nullptr ? renew_if_full(buffer) : JfrTraceIdLoadBarrier::renew_enqueue_buffer(_renew_size, this);\n+  const JfrBuffer* buffer = JfrTraceIdLoadBarrier::get_sampler_enqueue_buffer(this);\n+  return buffer != nullptr ? renew_if_full(buffer) : JfrTraceIdLoadBarrier::renew_sampler_enqueue_buffer(this);\n@@ -562,1 +560,1 @@\n-  return enqueue_buffer->free_size() < _min_size ? JfrTraceIdLoadBarrier::renew_enqueue_buffer(_renew_size, this) : enqueue_buffer;\n+  return enqueue_buffer->free_size() < _min_size ? JfrTraceIdLoadBarrier::renew_sampler_enqueue_buffer(this) : enqueue_buffer;\n","filename":"src\/hotspot\/share\/jfr\/periodic\/sampling\/jfrThreadSampler.cpp","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -254,1 +254,1 @@\n-JfrBuffer* JfrTraceIdKlassQueue::renew_enqueue_buffer(size_t size, Thread* thread) {\n+JfrBuffer* JfrTraceIdKlassQueue::renew_enqueue_buffer(Thread* thread, size_t size \/* 0 *\/) {\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceIdKlassQueue.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -72,1 +72,1 @@\n-  JfrBuffer* renew_enqueue_buffer(size_t size, Thread* thread);\n+  JfrBuffer* renew_enqueue_buffer(Thread* thread, size_t size = 0);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceIdKlassQueue.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+#include \"jfr\/recorder\/service\/jfrOptionSet.hpp\"\n@@ -32,0 +33,1 @@\n+#include \"utilities\/powerOfTwo.hpp\"\n@@ -33,2 +35,3 @@\n-\/\/ The queue instance used by the load barrier to enqueue tagged Klass'es.\n-static JfrTraceIdKlassQueue* _klass_queue = NULL;\n+\/\/ The queue instances are used by the load barrier to enqueue tagged Klass'es.\n+static JfrTraceIdKlassQueue* _klass_queue = nullptr; \/\/ Generic for all Java threads.\n+static JfrTraceIdKlassQueue* _sampler_klass_queue = nullptr; \/\/ Specialized for the Jfr Thread Sampler using a larger buffer size.\n@@ -37,1 +40,1 @@\n-  assert(_klass_queue != NULL, \"invariant\");\n+  assert(_klass_queue != nullptr, \"invariant\");\n@@ -41,2 +44,18 @@\n-const size_t buffer_size_bytes = 1 * K; \/\/ min_elem_size of storage unit\n-const size_t prealloc_count = 32;\n+static JfrTraceIdKlassQueue& sampler_klass_queue() {\n+  assert(_sampler_klass_queue != nullptr, \"invariant\");\n+  return *_sampler_klass_queue;\n+}\n+\n+const constexpr size_t buffer_size_bytes = 1 * K; \/\/ min_elem_size of storage unit\n+const constexpr size_t prealloc_count = 32;\n+const constexpr size_t sampler_prealloc_count = 2;\n+\n+\/\/ The sampler thread cannot renew a buffer in-flight because it cannot acquire the malloc lock.\n+\/\/ It must therefore pre-allocate at least a full stack trace of buffer space before it can suspend a thread.\n+\/\/ This pre-allocation implies the need for a larger buffer size compared to other threads, a size that is a function\n+\/\/ of the stack depth parameter. For proper accommodation, there is a specialized queue only for the Jfr Sampler Thread.\n+static size_t derive_sampler_buffer_size() {\n+  size_t stackdepth_bytes = JfrOptionSet::stackdepth() * 2 * wordSize; \/\/ each frame tags at most 2 words\n+  stackdepth_bytes = round_up_power_of_2(stackdepth_bytes * 2); \/\/ accommodate at least two full stacktraces\n+  return MAX2(stackdepth_bytes, buffer_size_bytes);\n+}\n@@ -45,1 +64,1 @@\n-  assert(_klass_queue == NULL, \"invariant\");\n+  assert(_klass_queue == nullptr, \"invariant\");\n@@ -47,1 +66,8 @@\n-  return _klass_queue != NULL && _klass_queue->initialize(buffer_size_bytes, JFR_MSPACE_UNLIMITED_CACHE_SIZE, prealloc_count);\n+  if (_klass_queue == nullptr || !_klass_queue->initialize(buffer_size_bytes, JFR_MSPACE_UNLIMITED_CACHE_SIZE, prealloc_count)) {\n+    return false;\n+  }\n+  assert(_sampler_klass_queue == nullptr, \"invariant\");\n+  const size_t sampler_buffer_size_bytes = derive_sampler_buffer_size();\n+  assert(is_power_of_2(sampler_buffer_size_bytes), \"invariant\");\n+  _sampler_klass_queue = new JfrTraceIdKlassQueue();\n+  return _sampler_klass_queue != nullptr && _sampler_klass_queue->initialize(sampler_buffer_size_bytes, JFR_MSPACE_UNLIMITED_CACHE_SIZE, sampler_prealloc_count);\n@@ -51,1 +77,1 @@\n-  if (_klass_queue != NULL) {\n+  if (_klass_queue != nullptr) {\n@@ -54,0 +80,3 @@\n+  if (_sampler_klass_queue != nullptr) {\n+    _sampler_klass_queue->clear();\n+  }\n@@ -58,1 +87,3 @@\n-  _klass_queue = NULL;\n+  _klass_queue = nullptr;\n+  delete _sampler_klass_queue;\n+  _sampler_klass_queue = nullptr;\n@@ -62,1 +93,1 @@\n-  assert(klass != NULL, \"invariant\");\n+  assert(klass != nullptr, \"invariant\");\n@@ -67,3 +98,2 @@\n-void JfrTraceIdLoadBarrier::do_klasses(klass_callback callback, bool previous_epoch) {\n-  assert_locked_or_safepoint(ClassLoaderDataGraph_lock);\n-  klass_queue().iterate(callback, previous_epoch);\n+JfrBuffer* JfrTraceIdLoadBarrier::get_sampler_enqueue_buffer(Thread* thread) {\n+  return sampler_klass_queue().get_enqueue_buffer(thread);\n@@ -72,2 +102,2 @@\n-JfrBuffer* JfrTraceIdLoadBarrier::get_enqueue_buffer(Thread* thread) {\n-  return klass_queue().get_enqueue_buffer(thread);\n+JfrBuffer* JfrTraceIdLoadBarrier::renew_sampler_enqueue_buffer(Thread* thread) {\n+  return sampler_klass_queue().renew_enqueue_buffer(thread);\n@@ -76,2 +106,4 @@\n-JfrBuffer* JfrTraceIdLoadBarrier::renew_enqueue_buffer(size_t size, Thread* thread) {\n-  return klass_queue().renew_enqueue_buffer(size, thread);\n+void JfrTraceIdLoadBarrier::do_klasses(klass_callback callback, bool previous_epoch) {\n+  assert_locked_or_safepoint(ClassLoaderDataGraph_lock);\n+  klass_queue().iterate(callback, previous_epoch);\n+  sampler_klass_queue().iterate(callback, previous_epoch);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceIdLoadBarrier.cpp","additions":50,"deletions":18,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -81,2 +81,2 @@\n-  static JfrBuffer* get_enqueue_buffer(Thread* thread);\n-  static JfrBuffer* renew_enqueue_buffer(size_t size, Thread* thread);\n+  static JfrBuffer* get_sampler_enqueue_buffer(Thread* thread);\n+  static JfrBuffer* renew_sampler_enqueue_buffer(Thread* thread);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceIdLoadBarrier.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -229,1 +229,1 @@\n-  const JfrBuffer* const enqueue_buffer = JfrTraceIdLoadBarrier::get_enqueue_buffer(current_thread);\n+  const JfrBuffer* const enqueue_buffer = JfrTraceIdLoadBarrier::get_sampler_enqueue_buffer(current_thread);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/stacktrace\/jfrStackTrace.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"cds\/archiveHeapLoader.hpp\"\n@@ -454,1 +455,1 @@\n-        HeapShared::are_archived_mirrors_available() &&\n+        ArchiveHeapLoader::are_archived_mirrors_available() &&\n@@ -456,1 +457,1 @@\n-      assert(HeapShared::can_use(), \"Sanity\");\n+      assert(ArchiveHeapLoader::can_use(), \"Sanity\");\n@@ -809,1 +810,1 @@\n-    if (HeapShared::is_loaded()) {\n+    if (ArchiveHeapLoader::is_loaded()) {\n","filename":"src\/hotspot\/share\/memory\/universe.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"cds\/archiveHeapLoader.hpp\"\n@@ -349,1 +350,1 @@\n-    if (HeapShared::is_fully_available() &&\n+    if (ArchiveHeapLoader::is_fully_available() &&\n","filename":"src\/hotspot\/share\/oops\/constantPool.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"cds\/archiveHeapLoader.hpp\"\n@@ -46,0 +47,1 @@\n+#include \"oops\/objArrayKlass.hpp\"\n@@ -608,1 +610,1 @@\n-    if (HeapShared::are_archived_mirrors_available()) {\n+    if (ArchiveHeapLoader::are_archived_mirrors_available()) {\n","filename":"src\/hotspot\/share\/oops\/klass.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -154,0 +154,4 @@\n+bool Block::is_trivially_unreachable() const {\n+  return num_preds() <= 1 && !head()->is_Root() && !head()->is_Start();\n+}\n+\n@@ -173,1 +177,1 @@\n-  if (num_preds() <= 1) {\n+  if (is_trivially_unreachable()) {\n@@ -611,13 +615,0 @@\n-  \/\/ If the fake exit block becomes unreachable, remove it from the block list.\n-  if (dead->num_preds() == 1) {\n-    for (uint i = 0; i < number_of_blocks(); i++) {\n-      Block* block = get_block(i);\n-      if (block == dead) {\n-        _blocks.remove(i);\n-      } else if (block->_pre_order > dead->_pre_order) {\n-        \/\/ Enforce contiguous pre-order indices (assumed by PhaseBlockLayout).\n-        block->_pre_order--;\n-      }\n-    }\n-    _number_of_blocks--;\n-  }\n@@ -957,0 +948,40 @@\n+void PhaseCFG::remove_unreachable_blocks() {\n+  ResourceMark rm;\n+  Block_List unreachable;\n+  \/\/ Initialize worklist of unreachable blocks to be removed.\n+  for (uint i = 0; i < number_of_blocks(); i++) {\n+    Block* block = get_block(i);\n+    assert(block->_pre_order == i, \"Block::pre_order does not match block index\");\n+    if (block->is_trivially_unreachable()) {\n+      unreachable.push(block);\n+    }\n+  }\n+  \/\/ Now remove all blocks that are transitively unreachable.\n+  while (unreachable.size() > 0) {\n+    Block* dead = unreachable.pop();\n+    \/\/ When this code runs (after PhaseCFG::fixup_flow()), Block::_pre_order\n+    \/\/ does not contain pre-order but block-list indices. Ensure they stay\n+    \/\/ contiguous by decrementing _pre_order for all elements after 'dead'.\n+    \/\/ Block::_rpo does not contain valid reverse post-order indices anymore\n+    \/\/ (they are invalidated by block insertions in PhaseCFG::fixup_flow()),\n+    \/\/ so there is no need to update them.\n+    for (uint i = dead->_pre_order + 1; i < number_of_blocks(); i++) {\n+      get_block(i)->_pre_order--;\n+    }\n+    _blocks.remove(dead->_pre_order);\n+    _number_of_blocks--;\n+    \/\/ Update the successors' predecessor list and push new unreachable blocks.\n+    for (uint i = 0; i < dead->_num_succs; i++) {\n+      Block* succ = dead->_succs[i];\n+      Node* head = succ->head();\n+      for (int j = head->req() - 1; j >= 1; j--) {\n+        if (get_block_for_node(head->in(j)) == dead) {\n+          head->del_req(j);\n+        }\n+      }\n+      if (succ->is_trivially_unreachable()) {\n+        unreachable.push(succ);\n+      }\n+    }\n+  }\n+}\n","filename":"src\/hotspot\/share\/opto\/block.cpp","additions":45,"deletions":14,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -324,0 +324,3 @@\n+  \/\/ Whether the block is not root-like and does not have any predecessors.\n+  bool is_trivially_unreachable() const;\n+\n@@ -613,0 +616,4 @@\n+  \/\/ Remove all blocks that are transitively unreachable. Such blocks can be\n+  \/\/ found e.g. after PhaseCFG::convert_NeverBranch_to_Goto(). This function\n+  \/\/ assumes post-fixup_flow() block indices (Block::_pre_order, Block::_rpo).\n+  void remove_unreachable_blocks();\n","filename":"src\/hotspot\/share\/opto\/block.hpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -120,4 +120,0 @@\n-  notproduct(uintx, PrintIdealIndentThreshold, 0,                           \\\n-          \"A depth threshold of ideal graph. Indentation is disabled \"      \\\n-          \"when users attempt to dump an ideal graph deeper than it.\")      \\\n-                                                                            \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -141,7 +141,0 @@\n-\n-\/\/ For a ParmNode, all immediate inputs and outputs are considered relevant\n-\/\/ both in compact and standard representation.\n-void ParmNode::related(GrowableArray<Node*> *in_rel, GrowableArray<Node*> *out_rel, bool compact) const {\n-  this->collect_nodes(in_rel, 1, false, false);\n-  this->collect_nodes(out_rel, -1, false, false);\n-}\n@@ -1376,13 +1369,0 @@\n-\n-\/\/ The related nodes of a SafepointNode are all data inputs, excluding the\n-\/\/ control boundary, as well as all outputs till level 2 (to include projection\n-\/\/ nodes and targets). In compact mode, just include inputs till level 1 and\n-\/\/ outputs as before.\n-void SafePointNode::related(GrowableArray<Node*> *in_rel, GrowableArray<Node*> *out_rel, bool compact) const {\n-  if (compact) {\n-    this->collect_nodes(in_rel, 1, false, false);\n-  } else {\n-    this->collect_nodes_in_all_data(in_rel, false);\n-  }\n-  this->collect_nodes(out_rel, -2, false, false);\n-}\n@@ -2008,10 +1988,0 @@\n-\n-\/\/ The related set of lock nodes includes the control boundary.\n-void AbstractLockNode::related(GrowableArray<Node*> *in_rel, GrowableArray<Node*> *out_rel, bool compact) const {\n-  if (compact) {\n-      this->collect_nodes(in_rel, 1, false, false);\n-    } else {\n-      this->collect_nodes_in_all_data(in_rel, true);\n-    }\n-    this->collect_nodes(out_rel, -2, false, false);\n-}\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":0,"deletions":30,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -111,1 +111,0 @@\n-  virtual void related(GrowableArray<Node*> *in_rel, GrowableArray<Node*> *out_rel, bool compact) const;\n@@ -503,1 +502,0 @@\n-  virtual void           related(GrowableArray<Node*> *in_rel, GrowableArray<Node*> *out_rel, bool compact) const;\n@@ -1083,1 +1081,0 @@\n-  virtual void related(GrowableArray<Node*> *in_rel, GrowableArray<Node*> *out_rel, bool compact) const;\n","filename":"src\/hotspot\/share\/opto\/callnode.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2584,8 +2584,0 @@\n-void PhiNode::related(GrowableArray<Node*> *in_rel, GrowableArray<Node*> *out_rel, bool compact) const {\n-  \/\/ For a PhiNode, the set of related nodes includes all inputs till level 2,\n-  \/\/ and all outputs till level 1. In compact mode, inputs till level 1 are\n-  \/\/ collected.\n-  this->collect_nodes(in_rel, compact ? 1 : 2, false, false);\n-  this->collect_nodes(out_rel, -1, false, false);\n-}\n-\n@@ -2616,11 +2608,0 @@\n-#ifndef PRODUCT\n-\/\/-----------------------------related-----------------------------------------\n-\/\/ The related nodes of a GotoNode are all inputs at level 1, as well as the\n-\/\/ outputs at level 1. This is regardless of compact mode.\n-void GotoNode::related(GrowableArray<Node*> *in_rel, GrowableArray<Node*> *out_rel, bool compact) const {\n-  this->collect_nodes(in_rel, 1, false, false);\n-  this->collect_nodes(out_rel, -1, false, false);\n-}\n-#endif\n-\n-\n@@ -2632,11 +2613,0 @@\n-#ifndef PRODUCT\n-\/\/-----------------------------related-----------------------------------------\n-\/\/ The related nodes of a JumpNode are all inputs at level 1, as well as the\n-\/\/ outputs at level 2 (to include actual jump targets beyond projection nodes).\n-\/\/ This is regardless of compact mode.\n-void JumpNode::related(GrowableArray<Node*> *in_rel, GrowableArray<Node*> *out_rel, bool compact) const {\n-  this->collect_nodes(in_rel, 1, false, false);\n-  this->collect_nodes(out_rel, -2, false, false);\n-}\n-#endif\n-\n@@ -2703,6 +2673,0 @@\n-\n-void JumpProjNode::related(GrowableArray<Node*> *in_rel, GrowableArray<Node*> *out_rel, bool compact) const {\n-  \/\/ The related nodes of a JumpProjNode are its inputs and outputs at level 1.\n-  this->collect_nodes(in_rel, 1, false, false);\n-  this->collect_nodes(out_rel, -1, false, false);\n-}\n","filename":"src\/hotspot\/share\/opto\/cfgnode.cpp","additions":0,"deletions":36,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -227,1 +227,0 @@\n-  virtual void related(GrowableArray<Node*> *in_rel, GrowableArray<Node*> *out_rel, bool compact) const;\n@@ -253,4 +252,0 @@\n-\n-#ifndef PRODUCT\n-  virtual void related(GrowableArray<Node*> *in_rel, GrowableArray<Node*> *out_rel, bool compact) const;\n-#endif\n@@ -409,1 +404,0 @@\n-  virtual void related(GrowableArray <Node *> *in_rel, GrowableArray <Node *> *out_rel, bool compact) const;\n@@ -435,5 +429,0 @@\n-\n-#ifndef PRODUCT\n-public:\n-  virtual void related(GrowableArray<Node*> *in_rel, GrowableArray<Node*> *out_rel, bool compact) const;\n-#endif\n@@ -507,3 +496,0 @@\n-#ifndef PRODUCT\n-  virtual void related(GrowableArray<Node*> *in_rel, GrowableArray<Node*> *out_rel, bool compact) const;\n-#endif\n@@ -535,1 +521,0 @@\n-  virtual void related(GrowableArray<Node*> *in_rel, GrowableArray<Node*> *out_rel, bool compact) const;\n","filename":"src\/hotspot\/share\/opto\/cfgnode.hpp","additions":0,"deletions":15,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2972,0 +2972,1 @@\n+    cfg.remove_unreachable_blocks();\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1743,15 +1743,0 @@\n-\/\/-------------------------------related---------------------------------------\n-\/\/ An IfProjNode's related node set consists of its input (an IfNode) including\n-\/\/ the IfNode's condition, plus all of its outputs at level 1. In compact mode,\n-\/\/ the restrictions for IfNode apply (see IfNode::rel).\n-void IfProjNode::related(GrowableArray<Node*> *in_rel, GrowableArray<Node*> *out_rel, bool compact) const {\n-  Node* ifNode = this->in(0);\n-  in_rel->append(ifNode);\n-  if (compact) {\n-    ifNode->collect_nodes(in_rel, 3, false, true);\n-  } else {\n-    ifNode->collect_nodes_in_all_data(in_rel, false);\n-  }\n-  this->collect_nodes(out_rel, -1, false, false);\n-}\n-\n@@ -1762,15 +1747,0 @@\n-\n-\/\/-------------------------------related---------------------------------------\n-\/\/ For an IfNode, the set of related output nodes is just the output nodes till\n-\/\/ depth 2, i.e, the IfTrue\/IfFalse projection nodes plus the nodes they refer.\n-\/\/ The related input nodes contain no control nodes, but all data nodes\n-\/\/ pertaining to the condition. In compact mode, the input nodes are collected\n-\/\/ up to a depth of 3.\n-void IfNode::related(GrowableArray <Node *> *in_rel, GrowableArray <Node *> *out_rel, bool compact) const {\n-  if (compact) {\n-    this->collect_nodes(in_rel, 3, false, true);\n-  } else {\n-    this->collect_nodes_in_all_data(in_rel, false);\n-  }\n-  this->collect_nodes(out_rel, -2, false, false);\n-}\n","filename":"src\/hotspot\/share\/opto\/ifnode.cpp","additions":0,"deletions":30,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -947,1 +947,1 @@\n-        block->get_node(i)->fast_dump();\n+        block->get_node(i)->dump();\n@@ -1215,1 +1215,1 @@\n-      block->get_node(i)->fast_dump();\n+      block->get_node(i)->dump();\n","filename":"src\/hotspot\/share\/opto\/lcm.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -527,1 +527,1 @@\n-  Node* find_old_node(Node* new_node) {\n+  Node* find_old_node(const Node* new_node) {\n","filename":"src\/hotspot\/share\/opto\/matcher.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -465,15 +465,0 @@\n-\n-#ifndef PRODUCT\n-\/\/----------------------------BinaryNode---------------------------------------\n-\/\/ The set of related nodes for a BinaryNode is all data inputs and all outputs\n-\/\/ till level 2 (i.e., one beyond the associated CMoveNode). In compact mode,\n-\/\/ it's the inputs till level 1 and the outputs till level 2.\n-void BinaryNode::related(GrowableArray<Node*> *in_rel, GrowableArray<Node*> *out_rel, bool compact) const {\n-  if (compact) {\n-    this->collect_nodes(in_rel, 1, false, true);\n-  } else {\n-    this->collect_nodes_in_all_data(in_rel, false);\n-  }\n-  this->collect_nodes(out_rel, -2, false, false);\n-}\n-#endif\n","filename":"src\/hotspot\/share\/opto\/movenode.cpp","additions":0,"deletions":15,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -163,4 +163,0 @@\n-\n-#ifndef PRODUCT\n-  virtual void related(GrowableArray<Node*> *in_rel, GrowableArray<Node*> *out_rel, bool compact) const;\n-#endif\n","filename":"src\/hotspot\/share\/opto\/movenode.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -335,1 +335,0 @@\n-  , _indent(0)\n@@ -356,1 +355,0 @@\n-  , _indent(0)\n@@ -370,1 +368,0 @@\n-  , _indent(0)\n@@ -386,1 +383,0 @@\n-  , _indent(0)\n@@ -404,1 +400,0 @@\n-  , _indent(0)\n@@ -424,1 +419,0 @@\n-  , _indent(0)\n@@ -447,1 +441,0 @@\n-  , _indent(0)\n@@ -472,1 +465,0 @@\n-  , _indent(0)\n@@ -1651,1 +1643,1 @@\n-int node_idx_cmp(Node** n1, Node** n2) {\n+int node_idx_cmp(const Node** n1, const Node** n2) {\n@@ -1655,1 +1647,1 @@\n-Node* find_node_by_name(Node* start, const char* name) {\n+void find_nodes_by_name(Node* start, const char* name) {\n@@ -1657,3 +1649,2 @@\n-  Node* result = nullptr;\n-  GrowableArray<Node*> ns;\n-  auto callback = [&] (Node* n) {\n+  GrowableArray<const Node*> ns;\n+  auto callback = [&] (const Node* n) {\n@@ -1662,1 +1653,0 @@\n-      result = n;\n@@ -1670,1 +1660,0 @@\n-  return result;\n@@ -1673,1 +1662,1 @@\n-Node* find_node_by_dump(Node* start, const char* pattern) {\n+void find_nodes_by_dump(Node* start, const char* pattern) {\n@@ -1675,3 +1664,2 @@\n-  Node* result = nullptr;\n-  GrowableArray<Node*> ns;\n-  auto callback = [&] (Node* n) {\n+  GrowableArray<const Node*> ns;\n+  auto callback = [&] (const Node* n) {\n@@ -1682,1 +1670,0 @@\n-      result = n;\n@@ -1690,1 +1677,0 @@\n-  return result;\n@@ -1696,1 +1682,1 @@\n-Node* find_node_by_name(const char* name) {\n+void find_nodes_by_name(const char* name) {\n@@ -1698,1 +1684,1 @@\n-  return find_node_by_name(root, name);\n+  find_nodes_by_name(root, name);\n@@ -1704,1 +1690,1 @@\n-Node* find_old_node_by_name(const char* name) {\n+void find_old_nodes_by_name(const char* name) {\n@@ -1706,1 +1692,1 @@\n-  return find_node_by_name(root, name);\n+  find_nodes_by_name(root, name);\n@@ -1712,1 +1698,1 @@\n-Node* find_node_by_dump(const char* pattern) {\n+void find_nodes_by_dump(const char* pattern) {\n@@ -1714,1 +1700,1 @@\n-  return find_node_by_dump(root, pattern);\n+  find_nodes_by_dump(root, pattern);\n@@ -1720,1 +1706,1 @@\n-Node* find_old_node_by_dump(const char* pattern) {\n+void find_old_nodes_by_dump(const char* pattern) {\n@@ -1722,1 +1708,1 @@\n-  return find_node_by_dump(root, pattern);\n+  find_nodes_by_dump(root, pattern);\n@@ -1775,1 +1761,1 @@\n-  PrintBFS(Node* start, const int max_distance, Node* target, const char* options)\n+  PrintBFS(const Node* start, const int max_distance, const Node* target, const char* options)\n@@ -1792,1 +1778,1 @@\n-  Node* _start;\n+  const Node* _start;\n@@ -1794,1 +1780,1 @@\n-  Node* _target;\n+  const Node* _target;\n@@ -1816,0 +1802,10 @@\n+    \/\/ Check if the filter accepts the node. Go by the type categories, but also all CFG nodes\n+    \/\/ are considered to have control.\n+    bool accepts(const Node* n) {\n+      const Type* t = n->bottom_type();\n+      return ( _data    &&  t->has_category(Type::Category::Data)                    ) ||\n+             ( _memory  &&  t->has_category(Type::Category::Memory)                  ) ||\n+             ( _mixed   &&  t->has_category(Type::Category::Mixed)                   ) ||\n+             ( _control && (t->has_category(Type::Category::Control) || n->is_CFG()) ) ||\n+             ( _other   &&  t->has_category(Type::Category::Other)                   );\n+    }\n@@ -1824,0 +1820,1 @@\n+  bool _dump_only = false;\n@@ -1827,2 +1824,0 @@\n-  \/\/ node category (filter \/ color)\n-  static bool filter_category(Node* n, Filter& filter); \/\/ filter node category against options\n@@ -1842,4 +1837,4 @@\n-  static Node* old_node(Node* n); \/\/ mach node -> prior IR node\n-  static void print_node_idx(Node* n); \/\/ to tty\n-  static void print_block_id(Block* b); \/\/ to tty\n-  static void print_node_block(Node* n); \/\/ to tty: _pre_order, head idx, _idom, _dom_depth\n+  static Node* old_node(const Node* n); \/\/ mach node -> prior IR node\n+  static void print_node_idx(const Node* n); \/\/ to tty\n+  static void print_block_id(const Block* b); \/\/ to tty\n+  static void print_node_block(const Node* n); \/\/ to tty: _pre_order, head idx, _idom, _dom_depth\n@@ -1848,2 +1843,2 @@\n-  Node_List _worklist; \/\/ BFS queue\n-  void maybe_traverse(Node* src, Node* dst);\n+  GrowableArray<const Node*> _worklist; \/\/ BFS queue\n+  void maybe_traverse(const Node* src, const Node* dst);\n@@ -1855,1 +1850,1 @@\n-    Info(Node* node, int distance)\n+    Info(const Node* node, int distance)\n@@ -1857,1 +1852,1 @@\n-    Node* node() { return _node; };\n+    const Node* node() const { return _node; };\n@@ -1861,1 +1856,1 @@\n-    Node_List edge_bwd; \/\/ pointing toward _start\n+    GrowableArray<const Node*> edge_bwd; \/\/ pointing toward _start\n@@ -1865,1 +1860,1 @@\n-    Node* _node;\n+    const Node* _node;\n@@ -1881,1 +1876,1 @@\n-  void make_info(Node* node, const int distance) {\n+  void make_info(const Node* node, const int distance) {\n@@ -1884,1 +1879,1 @@\n-    _info_uid.Insert(node, (void*)uid);\n+    _info_uid.Insert((void*)node, (void*)uid);\n@@ -1890,1 +1885,1 @@\n-  GrowableArray<Node*> _print_list;\n+  GrowableArray<const Node*> _print_list;\n@@ -1894,1 +1889,1 @@\n-  void print_node(Node* n);\n+  void print_node(const Node* n);\n@@ -1919,3 +1914,3 @@\n-  uint pos = 0;\n-  while (pos < _worklist.size()) {\n-    Node* n = _worklist.at(pos++); \/\/ next node to traverse\n+  int pos = 0;\n+  while (pos < _worklist.length()) {\n+    const Node* n = _worklist.at(pos++); \/\/ next node to traverse\n@@ -1923,1 +1918,1 @@\n-    if (!filter_category(n, _filter_visit) && n != _start) {\n+    if (!_filter_visit.accepts(n) && n != _start) {\n@@ -1961,2 +1956,2 @@\n-  for (uint i = 0; i < _worklist.size(); i++) {\n-    Node* n = _worklist.at(i);\n+  for (int i = 0; i < _worklist.length(); i++) {\n+    const Node* n = _worklist.at(i);\n@@ -1970,2 +1965,2 @@\n-  uint pos = 0;\n-  Node_List backtrace;\n+  int pos = 0;\n+  GrowableArray<const Node*> backtrace;\n@@ -1976,2 +1971,2 @@\n-  while (pos < backtrace.size()) {\n-    Node* n = backtrace.at(pos++);\n+  while (pos < backtrace.length()) {\n+    const Node* n = backtrace.at(pos++);\n@@ -1979,1 +1974,1 @@\n-    for (uint i = 0; i < info->edge_bwd.size(); i++) {\n+    for (int i = 0; i < info->edge_bwd.length(); i++) {\n@@ -1981,1 +1976,1 @@\n-      Node* back = info->edge_bwd.at(i);\n+      const Node* back = info->edge_bwd.at(i);\n@@ -1997,1 +1992,1 @@\n-  Node* current = _target;\n+  const Node* current = _target;\n@@ -2013,2 +2008,2 @@\n-    for (int i = _worklist.size() - 1; i >= 0; i--) {\n-      Node* n = _worklist.at(i);\n+    for (int i = _worklist.length() - 1; i >= 0; i--) {\n+      const Node* n = _worklist.at(i);\n@@ -2022,2 +2017,2 @@\n-    for (uint i = 0; i < _worklist.size(); i++) {\n-      Node* n = _worklist.at(i);\n+    for (int i = 0; i < _worklist.length(); i++) {\n+      const Node* n = _worklist.at(i);\n@@ -2040,1 +2035,1 @@\n-      Node* n = _print_list.at(i);\n+      const Node* n = _print_list.at(i);\n@@ -2063,1 +2058,1 @@\n-  tty->print(\"    if nullptr: same as \\\"cdmxo@B\\\"\\n\");\n+  tty->print(\"    if nullptr: same as \\\"cdmox@B\\\"\\n\");\n@@ -2070,1 +2065,0 @@\n-  tty->print(\"      m: visit memory nodes\\n\");\n@@ -2072,1 +2066,1 @@\n-  tty->print(\"      x: visit mixed nodes\\n\");\n+  tty->print(\"      m: visit memory nodes\\n\");\n@@ -2074,0 +2068,1 @@\n+  tty->print(\"      x: visit mixed nodes\\n\");\n@@ -2075,1 +2070,0 @@\n-  tty->print(\"      M: boundary memory nodes\\n\");\n@@ -2077,1 +2071,1 @@\n-  tty->print(\"      X: boundary mixed nodes\\n\");\n+  tty->print(\"      M: boundary memory nodes\\n\");\n@@ -2079,0 +2073,2 @@\n+  tty->print(\"      X: boundary mixed nodes\\n\");\n+  tty->print(\"      #: display node category in color (not supported in all terminals)\\n\");\n@@ -2081,1 +2077,0 @@\n-  tty->print(\"      #: display node category in color (not supported in all terminals)\\n\");\n@@ -2084,0 +2079,1 @@\n+  tty->print(\"      $: dump only, no header, no other columns\\n\");\n@@ -2087,0 +2083,3 @@\n+  tty->print(\"Note: the categories can be overlapping. For example a mixed node\\n\");\n+  tty->print(\"      can contain control and memory output. Some from the other\\n\");\n+  tty->print(\"      category are also control (Halt, Return, etc).\\n\");\n@@ -2126,1 +2125,1 @@\n-    tty->print(\"  find_node(741)->dump_bfs(8, find_node(746), \\\"cdmxo+A\\\")\\n\");\n+    tty->print(\"  find_node(741)->dump_bfs(8, find_node(746), \\\"cdmox+A\\\")\\n\");\n@@ -2135,1 +2134,1 @@\n-    _options = \"cmdxo@B\"; \/\/ default options\n+    _options = \"cdmox@B\"; \/\/ default options\n@@ -2191,0 +2190,3 @@\n+      case '$':\n+        _dump_only = true;\n+        break;\n@@ -2215,23 +2217,0 @@\n-bool PrintBFS::filter_category(Node* n, Filter& filter) {\n-  const Type* t = n->bottom_type();\n-  switch (t->category()) {\n-    case Type::Category::Data:\n-      return filter._data;\n-    case Type::Category::Memory:\n-      return filter._memory;\n-    case Type::Category::Mixed:\n-      return filter._mixed;\n-    case Type::Category::Control:\n-      return filter._control;\n-    case Type::Category::Other:\n-      return filter._other;\n-    case Type::Category::Undef:\n-      n->dump();\n-      assert(false, \"category undef ??\");\n-    default:\n-      n->dump();\n-      assert(false, \"not covered\");\n-  }\n-  return false;\n-}\n-\n@@ -2282,1 +2261,1 @@\n-Node* PrintBFS::old_node(Node* n) {\n+Node* PrintBFS::old_node(const Node* n) {\n@@ -2291,1 +2270,1 @@\n-void PrintBFS::print_node_idx(Node* n) {\n+void PrintBFS::print_node_idx(const Node* n) {\n@@ -2304,1 +2283,1 @@\n-void PrintBFS::print_block_id(Block* b) {\n+void PrintBFS::print_block_id(const Block* b) {\n@@ -2311,1 +2290,1 @@\n-void PrintBFS::print_node_block(Node* n) {\n+void PrintBFS::print_node_block(const Node* n) {\n@@ -2334,1 +2313,1 @@\n-void PrintBFS::maybe_traverse(Node* src, Node* dst) {\n+void PrintBFS::maybe_traverse(const Node* src, const Node* dst) {\n@@ -2336,2 +2315,2 @@\n-     (filter_category(dst, _filter_visit) ||\n-      filter_category(dst, _filter_boundary) ||\n+     (_filter_visit.accepts(dst) ||\n+      _filter_boundary.accepts(dst) ||\n@@ -2356,0 +2335,3 @@\n+  if (_dump_only) {\n+    return; \/\/ no header in dump only mode\n+  }\n@@ -2370,1 +2352,5 @@\n-void PrintBFS::print_node(Node* n) {\n+void PrintBFS::print_node(const Node* n) {\n+  if (_dump_only) {\n+    n->dump(\"\\n\", false, tty, &_dcc);\n+    return;\n+  }\n@@ -2393,1 +2379,1 @@\n-void Node::dump_bfs(const int max_distance, Node* target, const char* options) {\n+void Node::dump_bfs(const int max_distance, Node* target, const char* options) const {\n@@ -2399,1 +2385,1 @@\n-void Node::dump_bfs(const int max_distance) {\n+void Node::dump_bfs(const int max_distance) const {\n@@ -2526,4 +2512,0 @@\n-  if (_indent > 0) {\n-    st->print(\"%*s\", (_indent << 1), \"  \");\n-  }\n-\n@@ -2606,0 +2588,5 @@\n+\/\/ call from debugger: dump node to tty with newline\n+void Node::dump() const {\n+  dump(\"\\n\");\n+}\n+\n@@ -2657,67 +2644,0 @@\n-\/\/----------------------------collect_nodes_i----------------------------------\n-\/\/ Collects nodes from an Ideal graph, starting from a given start node and\n-\/\/ moving in a given direction until a certain depth (distance from the start\n-\/\/ node) is reached. Duplicates are ignored.\n-\/\/ Arguments:\n-\/\/   queue:         the nodes are collected into this array.\n-\/\/   start:         the node at which to start collecting.\n-\/\/   direction:     if this is a positive number, collect input nodes; if it is\n-\/\/                  a negative number, collect output nodes.\n-\/\/   depth:         collect nodes up to this distance from the start node.\n-\/\/   include_start: whether to include the start node in the result collection.\n-\/\/   only_ctrl:     whether to regard control edges only during traversal.\n-\/\/   only_data:     whether to regard data edges only during traversal.\n-static void collect_nodes_i(GrowableArray<Node*>* queue, const Node* start, int direction, uint depth, bool include_start, bool only_ctrl, bool only_data) {\n-  bool indent = depth <= PrintIdealIndentThreshold;\n-  Node* s = (Node*) start; \/\/ remove const\n-  queue->append(s);\n-  int begin = 0;\n-  int end = 0;\n-\n-  s->set_indent(0);\n-  for(uint i = 0; i < depth; i++) {\n-    end = queue->length();\n-    for(int j = begin; j < end; j++) {\n-      Node* tp  = queue->at(j);\n-      uint limit = direction > 0 ? tp->len() : tp->outcnt();\n-      for(uint k = 0; k < limit; k++) {\n-        Node* n = direction > 0 ? tp->in(k) : tp->raw_out(k);\n-\n-        if (not_a_node(n))  continue;\n-        \/\/ do not recurse through top or the root (would reach unrelated stuff)\n-        if (n->is_Root() || n->is_top()) continue;\n-        if (only_ctrl && !n->is_CFG()) continue;\n-        if (only_data && n->is_CFG()) continue;\n-        bool in_queue = queue->contains(n);\n-        if (!in_queue) {\n-          queue->append(n);\n-          n->set_indent(indent ? (i + 1) : 0);\n-        }\n-      }\n-    }\n-    begin = end;\n-  }\n-  if (!include_start) {\n-    queue->remove(s);\n-  }\n-}\n-\n-\/\/------------------------------dump_nodes-------------------------------------\n-static void dump_nodes(const Node* start, int d, bool only_ctrl) {\n-  if (not_a_node(start)) return;\n-\n-  GrowableArray <Node *> queue(Compile::current()->live_nodes());\n-  collect_nodes_i(&queue, start, d, (uint) ABS(d), true, only_ctrl, false);\n-\n-  int end = queue.length();\n-  if (d > 0) {\n-    for(int j = end-1; j >= 0; j--) {\n-      queue.at(j)->dump();\n-    }\n-  } else {\n-    for(int j = 0; j < end; j++) {\n-      queue.at(j)->dump();\n-    }\n-  }\n-}\n-\n@@ -2725,0 +2645,1 @@\n+\/\/ call from debugger: dump Node's inputs (or outputs if d negative)\n@@ -2726,1 +2647,1 @@\n-  dump_nodes(this, d, false);\n+  dump_bfs(abs(d), nullptr, (d > 0) ? \"+$\" : \"-$\");\n@@ -2730,1 +2651,1 @@\n-\/\/ Dump a Node's control history to depth\n+\/\/ call from debugger: dump Node's control inputs (or outputs if d negative)\n@@ -2732,1 +2653,1 @@\n-  dump_nodes(this, d, true);\n+  dump_bfs(abs(d), nullptr, (d > 0) ? \"+$c\" : \"-$c\");\n@@ -2755,195 +2676,0 @@\n-\/\/----------------------------dump_related-------------------------------------\n-\/\/ Dump a Node's related nodes - the notion of \"related\" depends on the Node at\n-\/\/ hand and is determined by the implementation of the virtual method rel.\n-void Node::dump_related() const {\n-  Compile* C = Compile::current();\n-  GrowableArray <Node *> in_rel(C->unique());\n-  GrowableArray <Node *> out_rel(C->unique());\n-  this->related(&in_rel, &out_rel, false);\n-  for (int i = in_rel.length() - 1; i >= 0; i--) {\n-    in_rel.at(i)->dump();\n-  }\n-  this->dump(\"\\n\", true);\n-  for (int i = 0; i < out_rel.length(); i++) {\n-    out_rel.at(i)->dump();\n-  }\n-}\n-\n-\/\/----------------------------dump_related-------------------------------------\n-\/\/ Dump a Node's related nodes up to a given depth (distance from the start\n-\/\/ node).\n-\/\/ Arguments:\n-\/\/   d_in:  depth for input nodes.\n-\/\/   d_out: depth for output nodes (note: this also is a positive number).\n-void Node::dump_related(uint d_in, uint d_out) const {\n-  Compile* C = Compile::current();\n-  GrowableArray <Node *> in_rel(C->unique());\n-  GrowableArray <Node *> out_rel(C->unique());\n-\n-  \/\/ call collect_nodes_i directly\n-  collect_nodes_i(&in_rel, this, 1, d_in, false, false, false);\n-  collect_nodes_i(&out_rel, this, -1, d_out, false, false, false);\n-\n-  for (int i = in_rel.length() - 1; i >= 0; i--) {\n-    in_rel.at(i)->dump();\n-  }\n-  this->dump(\"\\n\", true);\n-  for (int i = 0; i < out_rel.length(); i++) {\n-    out_rel.at(i)->dump();\n-  }\n-}\n-\n-\/\/------------------------dump_related_compact---------------------------------\n-\/\/ Dump a Node's related nodes in compact representation. The notion of\n-\/\/ \"related\" depends on the Node at hand and is determined by the implementation\n-\/\/ of the virtual method rel.\n-void Node::dump_related_compact() const {\n-  Compile* C = Compile::current();\n-  GrowableArray <Node *> in_rel(C->unique());\n-  GrowableArray <Node *> out_rel(C->unique());\n-  this->related(&in_rel, &out_rel, true);\n-  int n_in = in_rel.length();\n-  int n_out = out_rel.length();\n-\n-  this->dump_comp(n_in == 0 ? \"\\n\" : \"  \");\n-  for (int i = 0; i < n_in; i++) {\n-    in_rel.at(i)->dump_comp(i == n_in - 1 ? \"\\n\" : \"  \");\n-  }\n-  for (int i = 0; i < n_out; i++) {\n-    out_rel.at(i)->dump_comp(i == n_out - 1 ? \"\\n\" : \"  \");\n-  }\n-}\n-\n-\/\/------------------------------related----------------------------------------\n-\/\/ Collect a Node's related nodes. The default behaviour just collects the\n-\/\/ inputs and outputs at depth 1, including both control and data flow edges,\n-\/\/ regardless of whether the presentation is compact or not. For data nodes,\n-\/\/ the default is to collect all data inputs (till level 1 if compact), and\n-\/\/ outputs till level 1.\n-void Node::related(GrowableArray<Node*> *in_rel, GrowableArray<Node*> *out_rel, bool compact) const {\n-  if (this->is_CFG()) {\n-    collect_nodes_i(in_rel, this, 1, 1, false, false, false);\n-    collect_nodes_i(out_rel, this, -1, 1, false, false, false);\n-  } else {\n-    if (compact) {\n-      this->collect_nodes(in_rel, 1, false, true);\n-    } else {\n-      this->collect_nodes_in_all_data(in_rel, false);\n-    }\n-    this->collect_nodes(out_rel, -1, false, false);\n-  }\n-}\n-\n-\/\/---------------------------collect_nodes-------------------------------------\n-\/\/ An entry point to the low-level node collection facility, to start from a\n-\/\/ given node in the graph. The start node is by default not included in the\n-\/\/ result.\n-\/\/ Arguments:\n-\/\/   ns:   collect the nodes into this data structure.\n-\/\/   d:    the depth (distance from start node) to which nodes should be\n-\/\/         collected. A value >0 indicates input nodes, a value <0, output\n-\/\/         nodes.\n-\/\/   ctrl: include only control nodes.\n-\/\/   data: include only data nodes.\n-void Node::collect_nodes(GrowableArray<Node*> *ns, int d, bool ctrl, bool data) const {\n-  if (ctrl && data) {\n-    \/\/ ignore nonsensical combination\n-    return;\n-  }\n-  collect_nodes_i(ns, this, d, (uint) ABS(d), false, ctrl, data);\n-}\n-\n-\/\/--------------------------collect_nodes_in-----------------------------------\n-static void collect_nodes_in(Node* start, GrowableArray<Node*> *ns, bool primary_is_data, bool collect_secondary) {\n-  \/\/ The maximum depth is determined using a BFS that visits all primary (data\n-  \/\/ or control) inputs and increments the depth at each level.\n-  uint d_in = 0;\n-  GrowableArray<Node*> nodes(Compile::current()->unique());\n-  nodes.push(start);\n-  int nodes_at_current_level = 1;\n-  int n_idx = 0;\n-  while (nodes_at_current_level > 0) {\n-    \/\/ Add all primary inputs reachable from the current level to the list, and\n-    \/\/ increase the depth if there were any.\n-    int nodes_at_next_level = 0;\n-    bool nodes_added = false;\n-    while (nodes_at_current_level > 0) {\n-      nodes_at_current_level--;\n-      Node* current = nodes.at(n_idx++);\n-      for (uint i = 0; i < current->len(); i++) {\n-        Node* n = current->in(i);\n-        if (not_a_node(n)) {\n-          continue;\n-        }\n-        if ((primary_is_data && n->is_CFG()) || (!primary_is_data && !n->is_CFG())) {\n-          continue;\n-        }\n-        if (!nodes.contains(n)) {\n-          nodes.push(n);\n-          nodes_added = true;\n-          nodes_at_next_level++;\n-        }\n-      }\n-    }\n-    if (nodes_added) {\n-      d_in++;\n-    }\n-    nodes_at_current_level = nodes_at_next_level;\n-  }\n-  start->collect_nodes(ns, d_in, !primary_is_data, primary_is_data);\n-  if (collect_secondary) {\n-    \/\/ Now, iterate over the secondary nodes in ns and add the respective\n-    \/\/ boundary reachable from them.\n-    GrowableArray<Node*> sns(Compile::current()->unique());\n-    for (GrowableArrayIterator<Node*> it = ns->begin(); it != ns->end(); ++it) {\n-      Node* n = *it;\n-      n->collect_nodes(&sns, 1, primary_is_data, !primary_is_data);\n-      for (GrowableArrayIterator<Node*> d = sns.begin(); d != sns.end(); ++d) {\n-        ns->append_if_missing(*d);\n-      }\n-      sns.clear();\n-    }\n-  }\n-}\n-\n-\/\/---------------------collect_nodes_in_all_data-------------------------------\n-\/\/ Collect the entire data input graph. Include the control boundary if\n-\/\/ requested.\n-\/\/ Arguments:\n-\/\/   ns:   collect the nodes into this data structure.\n-\/\/   ctrl: if true, include the control boundary.\n-void Node::collect_nodes_in_all_data(GrowableArray<Node*> *ns, bool ctrl) const {\n-  collect_nodes_in((Node*) this, ns, true, ctrl);\n-}\n-\n-\/\/--------------------------collect_nodes_in_all_ctrl--------------------------\n-\/\/ Collect the entire control input graph. Include the data boundary if\n-\/\/ requested.\n-\/\/   ns:   collect the nodes into this data structure.\n-\/\/   data: if true, include the control boundary.\n-void Node::collect_nodes_in_all_ctrl(GrowableArray<Node*> *ns, bool data) const {\n-  collect_nodes_in((Node*) this, ns, false, data);\n-}\n-\n-\/\/------------------collect_nodes_out_all_ctrl_boundary------------------------\n-\/\/ Collect the entire output graph until hitting control node boundaries, and\n-\/\/ include those.\n-void Node::collect_nodes_out_all_ctrl_boundary(GrowableArray<Node*> *ns) const {\n-  \/\/ Perform a BFS and stop at control nodes.\n-  GrowableArray<Node*> nodes(Compile::current()->unique());\n-  nodes.push((Node*) this);\n-  while (nodes.length() > 0) {\n-    Node* current = nodes.pop();\n-    if (not_a_node(current)) {\n-      continue;\n-    }\n-    ns->append_if_missing(current);\n-    if (!current->is_CFG()) {\n-      for (DUIterator i = current->outs(); current->has_out(i); i++) {\n-        nodes.push(current->out(i));\n-      }\n-    }\n-  }\n-  ns->remove((Node*) this);\n-}\n-\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":102,"deletions":376,"binary":false,"changes":478,"status":"modified"},{"patch":"@@ -1190,3 +1190,0 @@\n- private:\n-  int _indent;\n-\n@@ -1194,5 +1191,0 @@\n-  void set_indent(int indent) { _indent = indent; }\n-\n- private:\n-  static bool add_to_worklist(Node* n, Node_List* worklist, Arena* old_arena, VectorSet* old_space, VectorSet* new_space);\n-public:\n@@ -1201,2 +1193,2 @@\n-  void dump_bfs(const int max_distance, Node* target, const char* options); \/\/ Print BFS traversal\n-  void dump_bfs(const int max_distance); \/\/ dump_bfs(max_distance, nullptr, nullptr)\n+  void dump_bfs(const int max_distance, Node* target, const char* options) const; \/\/ Print BFS traversal\n+  void dump_bfs(const int max_distance) const; \/\/ dump_bfs(max_distance, nullptr, nullptr)\n@@ -1204,1 +1196,1 @@\n-  public:\n+   public:\n@@ -1211,1 +1203,1 @@\n-  void dump() const { dump(\"\\n\"); }  \/\/ Print this node.\n+  void dump() const; \/\/ print node with newline\n@@ -1218,0 +1210,1 @@\n+ private:\n@@ -1221,0 +1214,1 @@\n+ public:\n@@ -1224,16 +1218,0 @@\n-  void dump_related() const;             \/\/ Print related nodes (depends on node at hand).\n-  \/\/ Print related nodes up to given depths for input and output nodes.\n-  void dump_related(uint d_in, uint d_out) const;\n-  void dump_related_compact() const;     \/\/ Print related nodes in compact representation.\n-  \/\/ Collect related nodes.\n-  virtual void related(GrowableArray<Node*> *in_rel, GrowableArray<Node*> *out_rel, bool compact) const;\n-  \/\/ Collect nodes starting from this node, explicitly including\/excluding control and data links.\n-  void collect_nodes(GrowableArray<Node*> *ns, int d, bool ctrl, bool data) const;\n-\n-  \/\/ Node collectors, to be used in implementations of Node::rel().\n-  \/\/ Collect the entire data input graph. Include control inputs if requested.\n-  void collect_nodes_in_all_data(GrowableArray<Node*> *ns, bool ctrl) const;\n-  \/\/ Collect the entire control input graph. Include data inputs if requested.\n-  void collect_nodes_in_all_ctrl(GrowableArray<Node*> *ns, bool data) const;\n-  \/\/ Collect the entire output graph until hitting and including control nodes.\n-  void collect_nodes_out_all_ctrl_boundary(GrowableArray<Node*> *ns) const;\n@@ -1248,13 +1226,1 @@\n-  \/\/ RegMask Print Functions\n-  void dump_in_regmask(int idx) { in_RegMask(idx).dump(); }\n-  void dump_out_regmask() { out_RegMask().dump(); }\n-  static bool in_dump() { return Compile::current()->_in_dump_cnt > 0; }\n-  void fast_dump() const {\n-    tty->print(\"%4d: %-17s\", _idx, Name());\n-    for (uint i = 0; i < len(); i++)\n-      if (in(i))\n-        tty->print(\" %4d\", in(i)->_idx);\n-      else\n-        tty->print(\" NULL\");\n-    tty->print(\"\\n\");\n-  }\n+  static bool in_dump() { return Compile::current()->_in_dump_cnt > 0; } \/\/ check if we are in a dump call\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":7,"deletions":41,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -546,2 +546,1 @@\n-  void    adjust_map_after_if(BoolTest::mask btest, Node* c, float prob,\n-                              Block* path, Block* other_path);\n+  void    adjust_map_after_if(BoolTest::mask btest, Node* c, float prob, Block* path);\n","filename":"src\/hotspot\/share\/opto\/parse.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1413,1 +1413,1 @@\n-      adjust_map_after_if(btest, c, prob, branch_block, next_block);\n+      adjust_map_after_if(btest, c, prob, branch_block);\n@@ -1431,2 +1431,1 @@\n-    adjust_map_after_if(BoolTest(btest).negate(), c, 1.0-prob,\n-                        next_block, branch_block);\n+    adjust_map_after_if(BoolTest(btest).negate(), c, 1.0-prob, next_block);\n@@ -1526,1 +1525,1 @@\n-      adjust_map_after_if(taken_btest, c, prob, branch_block, next_block);\n+      adjust_map_after_if(taken_btest, c, prob, branch_block);\n@@ -1543,2 +1542,1 @@\n-    adjust_map_after_if(untaken_btest, c, untaken_prob,\n-                        next_block, branch_block);\n+    adjust_map_after_if(untaken_btest, c, untaken_prob, next_block);\n@@ -1574,2 +1572,1 @@\n-void Parse::adjust_map_after_if(BoolTest::mask btest, Node* c, float prob,\n-                                Block* path, Block* other_path) {\n+void Parse::adjust_map_after_if(BoolTest::mask btest, Node* c, float prob, Block* path) {\n","filename":"src\/hotspot\/share\/opto\/parse2.cpp","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -94,15 +94,0 @@\n-\n-#ifndef PRODUCT\n-\/\/-----------------------------related-----------------------------------------\n-\/\/ Include all control inputs in the related set, and also the input data\n-\/\/ boundary. In compact mode, include all inputs till level 2. Also include\n-\/\/ all outputs at level 1.\n-void HaltNode::related(GrowableArray<Node*> *in_rel, GrowableArray<Node*> *out_rel, bool compact) const {\n-  if (compact) {\n-    this->collect_nodes(in_rel, 2, false, false);\n-  } else {\n-    this->collect_nodes_in_all_ctrl(in_rel, true);\n-  }\n-  this->collect_nodes(out_rel, -1, false, false);\n-}\n-#endif\n","filename":"src\/hotspot\/share\/opto\/rootnode.cpp","additions":0,"deletions":15,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -71,4 +71,0 @@\n-\n-#ifndef PRODUCT\n-  virtual void related(GrowableArray<Node*> *in_rel, GrowableArray<Node*> *out_rel, bool compact) const;\n-#endif\n","filename":"src\/hotspot\/share\/opto\/rootnode.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -632,32 +632,0 @@\n-#ifndef PRODUCT\n-\/\/----------------------------related------------------------------------------\n-\/\/ Related nodes of comparison nodes include all data inputs (until hitting a\n-\/\/ control boundary) as well as all outputs until and including control nodes\n-\/\/ as well as their projections. In compact mode, data inputs till depth 1 and\n-\/\/ all outputs till depth 1 are considered.\n-void CmpNode::related(GrowableArray<Node*> *in_rel, GrowableArray<Node*> *out_rel, bool compact) const {\n-  if (compact) {\n-    this->collect_nodes(in_rel, 1, false, true);\n-    this->collect_nodes(out_rel, -1, false, false);\n-  } else {\n-    this->collect_nodes_in_all_data(in_rel, false);\n-    this->collect_nodes_out_all_ctrl_boundary(out_rel);\n-    \/\/ Now, find all control nodes in out_rel, and include their projections\n-    \/\/ and projection targets (if any) in the result.\n-    GrowableArray<Node*> proj(Compile::current()->unique());\n-    for (GrowableArrayIterator<Node*> it = out_rel->begin(); it != out_rel->end(); ++it) {\n-      Node* n = *it;\n-      if (n->is_CFG() && !n->is_Proj()) {\n-        \/\/ Assume projections and projection targets are found at levels 1 and 2.\n-        n->collect_nodes(&proj, -2, false, false);\n-        for (GrowableArrayIterator<Node*> p = proj.begin(); p != proj.end(); ++p) {\n-          out_rel->append_if_missing(*p);\n-        }\n-        proj.clear();\n-      }\n-    }\n-  }\n-}\n-\n-#endif\n-\n@@ -1798,14 +1766,0 @@\n-\n-\/\/-------------------------------related---------------------------------------\n-\/\/ A BoolNode's related nodes are all of its data inputs, and all of its\n-\/\/ outputs until control nodes are hit, which are included. In compact\n-\/\/ representation, inputs till level 3 and immediate outputs are included.\n-void BoolNode::related(GrowableArray<Node*> *in_rel, GrowableArray<Node*> *out_rel, bool compact) const {\n-  if (compact) {\n-    this->collect_nodes(in_rel, 3, false, true);\n-    this->collect_nodes(out_rel, -1, false, false);\n-  } else {\n-    this->collect_nodes_in_all_data(in_rel, false);\n-    this->collect_nodes_out_all_ctrl_boundary(out_rel);\n-  }\n-}\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":0,"deletions":46,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -146,7 +146,0 @@\n-\n-#ifndef PRODUCT\n-  \/\/ CmpNode and subclasses include all data inputs (until hitting a control\n-  \/\/ boundary) in their related node set, as well as all outputs until and\n-  \/\/ including eventual control nodes and their projections.\n-  virtual void related(GrowableArray<Node*> *in_rel, GrowableArray<Node*> *out_rel, bool compact) const;\n-#endif\n@@ -364,1 +357,0 @@\n-  virtual void related(GrowableArray<Node*> *in_rel, GrowableArray<Node*> *out_rel, bool compact) const;\n","filename":"src\/hotspot\/share\/opto\/subnode.hpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1153,0 +1153,15 @@\n+\n+bool Type::has_category(Type::Category cat) const {\n+  if (category() == cat) {\n+    return true;\n+  }\n+  if (category() == Category::Mixed) {\n+    const TypeTuple* tuple = is_tuple();\n+    for (uint i = 0; i < tuple->cnt(); i++) {\n+      if (tuple->field_at(i)->has_category(cat)) {\n+        return true;\n+      }\n+    }\n+  }\n+  return false;\n+}\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -386,0 +386,2 @@\n+  \/\/ Check recursively in tuples.\n+  bool has_category(Category cat) const;\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1175,1 +1175,1 @@\n-      <xsl:variable name=\"events\" select=\"\/\/event[capabilities\/required\/@id=$capa]\"\/>\n+      <xsl:variable name=\"events\" select=\"\/\/event[capabilities\/required\/@id=$capa and not(ancestor::elide)]\"\/>\n","filename":"src\/hotspot\/share\/prims\/jvmti.xsl","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"cds\/archiveHeapLoader.hpp\"\n@@ -30,1 +31,1 @@\n-#include \"cds\/heapShared.inline.hpp\"\n+#include \"cds\/heapShared.hpp\"\n@@ -1995,1 +1996,1 @@\n-  return HeapShared::closed_regions_mapped();\n+  return ArchiveHeapLoader::closed_regions_mapped();\n@@ -2020,1 +2021,1 @@\n-  return HeapShared::open_regions_mapped();\n+  return ArchiveHeapLoader::open_regions_mapped();\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-#include \"memory\/resourceArea.hpp\"\n@@ -263,1 +262,1 @@\n-  char* buf = NEW_RESOURCE_ARRAY(char, len);\n+  char* buf = (char*)os::malloc(len, mtInternal);\n@@ -285,0 +284,3 @@\n+\n+  os::free(buf);\n+\n@@ -353,1 +355,0 @@\n-  ResourceMark rm;\n","filename":"src\/hotspot\/share\/utilities\/elfFile.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -164,0 +164,2 @@\n+    private static native void init();\n+\n@@ -182,0 +184,5 @@\n+\n+    static {\n+        jdk.internal.loader.BootLoader.loadLibrary(\"nio\");\n+        init();\n+    }\n","filename":"src\/java.base\/linux\/classes\/sun\/nio\/fs\/LinuxFileSystem.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+#include <dlfcn.h>\n@@ -41,0 +42,4 @@\n+typedef ssize_t copy_file_range_func(int, loff_t*, int, loff_t*, size_t,\n+                                     unsigned int);\n+static copy_file_range_func* my_copy_file_range_func = NULL;\n+\n@@ -55,0 +60,8 @@\n+JNIEXPORT void JNICALL\n+Java_sun_nio_fs_LinuxFileSystem_init\n+    (JNIEnv* env, jclass this)\n+{\n+    my_copy_file_range_func =\n+        (copy_file_range_func*) dlsym(RTLD_DEFAULT, \"copy_file_range\");\n+}\n+\n@@ -75,0 +88,1 @@\n+\n@@ -76,0 +90,25 @@\n+    if (my_copy_file_range_func != NULL) {\n+        do {\n+            RESTARTABLE(my_copy_file_range_func(src, NULL, dst, NULL, count, 0),\n+                                                bytes_sent);\n+            if (bytes_sent < 0) {\n+                switch (errno) {\n+                    case EINVAL:\n+                    case ENOSYS:\n+                    case EXDEV:\n+                        \/\/ ignore and try sendfile()\n+                        break;\n+                    default:\n+                        JNU_ThrowIOExceptionWithLastError(env, \"Copy failed\");\n+                        return IOS_THROWN;\n+                }\n+            }\n+            if (cancel != NULL && *cancel != 0) {\n+                throwUnixException(env, ECANCELED);\n+                return IOS_THROWN;\n+            }\n+        } while (bytes_sent > 0);\n+\n+        if (bytes_sent == 0)\n+            return 0;\n+    }\n","filename":"src\/java.base\/linux\/native\/libnio\/fs\/LinuxFileSystem.c","additions":39,"deletions":0,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -74,0 +74,7 @@\n+    @Override\n+    protected int directCopy(int dst, int src, long addressToPollForCancel)\n+        throws UnixException\n+    {\n+        return directCopy0(dst, src, addressToPollForCancel);\n+    }\n+\n@@ -105,2 +112,0 @@\n-\n-\n@@ -112,9 +117,0 @@\n-    \/\/ --- file copying ---\n-\n-    @Override\n-    int directCopy(int dst, int src, long addressToPollForCancel)\n-        throws UnixException\n-    {\n-        return directCopy0(dst, src, addressToPollForCancel);\n-    }\n-\n","filename":"src\/java.base\/macosx\/classes\/sun\/nio\/fs\/BsdFileSystem.java","additions":7,"deletions":11,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1995, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1995, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,4 @@\n+import java.util.Objects;\n+\n+import jdk.internal.util.Preconditions;\n+\n@@ -288,6 +292,3 @@\n-        \/* this will check to see if buf is null *\/\n-        if (length < 0 || offset < 0 ||\n-            (length + offset) < 0 ||\n-            ((length + offset) > buf.length)) {\n-            throw new IllegalArgumentException(\"illegal length or offset\");\n-        }\n+        Objects.requireNonNull(buf);\n+        Preconditions.checkFromIndexSize(offset, length, buf.length,\n+                Preconditions.outOfBoundsExceptionFormatter(IllegalArgumentException::new));\n@@ -397,2 +398,3 @@\n-     * will be used for receiving data. The length must be lesser or\n-     * equal to the offset plus the length of the packet's buffer.\n+     * will be used for receiving data. The {@code length} plus the\n+     * {@link #getOffset() offset} must be lesser or equal to the\n+     * length of the packet's data buffer.\n@@ -412,4 +414,2 @@\n-        if ((length + offset) > buf.length || length < 0 ||\n-            (length + offset) < 0) {\n-            throw new IllegalArgumentException(\"illegal length\");\n-        }\n+        Preconditions.checkFromIndexSize(offset, length, buf.length,\n+                Preconditions.outOfBoundsExceptionFormatter(IllegalArgumentException::new));\n","filename":"src\/java.base\/share\/classes\/java\/net\/DatagramPacket.java","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -843,0 +843,6 @@\n+     * @apiNote The {@code InputStream} returned by this method can wrap an\n+     * {@link java.util.zip.InflaterInputStream InflaterInputStream}, whose\n+     * {@link java.util.zip.InflaterInputStream#read(byte[], int, int)\n+     * read(byte[], int, int)} method can modify any element of the output\n+     * buffer.\n+     *\n","filename":"src\/java.base\/share\/classes\/java\/net\/URLConnection.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -825,0 +825,7 @@\n+     *\n+     * @apiNote The {@code InputStream} returned by this method can wrap an\n+     * {@link java.util.zip.InflaterInputStream InflaterInputStream}, whose\n+     * {@link java.util.zip.InflaterInputStream#read(byte[], int, int)\n+     * read(byte[], int, int)} method can modify any element of the output\n+     * buffer.\n+     *\n","filename":"src\/java.base\/share\/classes\/java\/util\/jar\/JarFile.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -170,4 +170,15 @@\n-     * Reads from the current JAR file entry into an array of bytes.\n-     * If {@code len} is not zero, the method\n-     * blocks until some input is available; otherwise, no\n-     * bytes are read and {@code 0} is returned.\n+     * Reads from the current JAR entry into an array of bytes, returning the number of\n+     * inflated bytes. If {@code len} is not zero, the method blocks until some input is\n+     * available; otherwise, no bytes are read and {@code 0} is returned.\n+     * <p>\n+     * If the current entry is compressed and this method returns a nonzero\n+     * integer <i>n<\/i> then {@code buf[off]}\n+     * through {@code buf[off+}<i>n<\/i>{@code -1]} contain the uncompressed\n+     * data.  The content of elements {@code buf[off+}<i>n<\/i>{@code ]} through\n+     * {@code buf[off+}<i>len<\/i>{@code -1]} is undefined, contrary to the\n+     * specification of the {@link java.io.InputStream InputStream} superclass,\n+     * so an implementation is free to modify these elements during the inflate\n+     * operation. If this method returns {@code -1} or throws an exception then\n+     * the content of {@code buf[off]} through {@code buf[off+}<i>len<\/i>{@code\n+     * -1]} is undefined.\n+     * <p>\n","filename":"src\/java.base\/share\/classes\/java\/util\/jar\/JarInputStream.java","additions":15,"deletions":4,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -95,3 +95,14 @@\n-     * Reads uncompressed data into an array of bytes. If {@code len} is not\n-     * zero, the method will block until some input can be decompressed; otherwise,\n-     * no bytes are read and {@code 0} is returned.\n+     * Reads uncompressed data into an array of bytes, returning the number of inflated\n+     * bytes. If {@code len} is not zero, the method will block until some input can be\n+     * decompressed; otherwise, no bytes are read and {@code 0} is returned.\n+     * <p>\n+     * If this method returns a nonzero integer <i>n<\/i> then {@code buf[off]}\n+     * through {@code buf[off+}<i>n<\/i>{@code -1]} contain the uncompressed\n+     * data.  The content of elements {@code buf[off+}<i>n<\/i>{@code ]} through\n+     * {@code buf[off+}<i>len<\/i>{@code -1]} is undefined, contrary to the\n+     * specification of the {@link java.io.InputStream InputStream} superclass,\n+     * so an implementation is free to modify these elements during the inflate\n+     * operation. If this method returns {@code -1} or throws an exception then\n+     * the content of {@code buf[off]} through {@code buf[off+}<i>len<\/i>{@code\n+     * -1]} is undefined.\n+     *\n@@ -99,1 +110,1 @@\n-     * @param off the start offset in the destination array {@code b}\n+     * @param off the start offset in the destination array {@code buf}\n@@ -101,1 +112,1 @@\n-     * @return  the actual number of bytes read, or -1 if the end of the\n+     * @return  the actual number of bytes inflated, or -1 if the end of the\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/GZIPInputStream.java","additions":17,"deletions":6,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -127,3 +127,14 @@\n-     * Reads uncompressed data into an array of bytes. If {@code len} is not\n-     * zero, the method will block until some input can be decompressed; otherwise,\n-     * no bytes are read and {@code 0} is returned.\n+     * Reads uncompressed data into an array of bytes, returning the number of inflated\n+     * bytes. If {@code len} is not zero, the method will block until some input can be\n+     * decompressed; otherwise, no bytes are read and {@code 0} is returned.\n+     * <p>\n+     * If this method returns a nonzero integer <i>n<\/i> then {@code buf[off]}\n+     * through {@code buf[off+}<i>n<\/i>{@code -1]} contain the uncompressed\n+     * data.  The content of elements {@code buf[off+}<i>n<\/i>{@code ]} through\n+     * {@code buf[off+}<i>len<\/i>{@code -1]} is undefined, contrary to the\n+     * specification of the {@link java.io.InputStream InputStream} superclass,\n+     * so an implementation is free to modify these elements during the inflate\n+     * operation. If this method returns {@code -1} or throws an exception then\n+     * the content of {@code buf[off]} through {@code buf[off+}<i>len<\/i>{@code\n+     * -1]} is undefined.\n+     *\n@@ -133,1 +144,1 @@\n-     * @return the actual number of bytes read, or -1 if the end of the\n+     * @return the actual number of bytes inflated, or -1 if the end of the\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/InflaterInputStream.java","additions":15,"deletions":4,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -346,0 +346,6 @@\n+     * @apiNote The {@code InputStream} returned by this method can wrap an\n+     * {@link java.util.zip.InflaterInputStream InflaterInputStream}, whose\n+     * {@link java.util.zip.InflaterInputStream#read(byte[], int, int)\n+     * read(byte[], int, int)} method can modify any element of the output\n+     * buffer.\n+     *\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/ZipFile.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -168,4 +168,15 @@\n-     * Reads from the current ZIP entry into an array of bytes.\n-     * If {@code len} is not zero, the method\n-     * blocks until some input is available; otherwise, no\n-     * bytes are read and {@code 0} is returned.\n+     * Reads from the current ZIP entry into an array of bytes, returning the number of\n+     * inflated bytes. If {@code len} is not zero, the method blocks until some input is\n+     * available; otherwise, no bytes are read and {@code 0} is returned.\n+     * <p>\n+     * If the current entry is compressed and this method returns a nonzero\n+     * integer <i>n<\/i> then {@code buf[off]}\n+     * through {@code buf[off+}<i>n<\/i>{@code -1]} contain the uncompressed\n+     * data.  The content of elements {@code buf[off+}<i>n<\/i>{@code ]} through\n+     * {@code buf[off+}<i>len<\/i>{@code -1]} is undefined, contrary to the\n+     * specification of the {@link java.io.InputStream InputStream} superclass,\n+     * so an implementation is free to modify these elements during the inflate\n+     * operation. If this method returns {@code -1} or throws an exception then\n+     * the content of {@code buf[off]} through {@code buf[off+}<i>len<\/i>{@code\n+     * -1]} is undefined.\n+     *\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/ZipInputStream.java","additions":16,"deletions":5,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-tzdata2022a\n+tzdata2022c\n","filename":"src\/java.base\/share\/data\/tzdata\/VERSION","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -185,0 +185,1 @@\n+Link Africa\/Abidjan Atlantic\/Reykjavik\t# Iceland\n@@ -195,1 +196,1 @@\n-# observatory; round to nearest.  Milne also says that the official time for\n+# observatory.  Milne also says that the official time for\n@@ -380,0 +381,1 @@\n+\t\t#STDOFF\t2:05:08.9\n@@ -433,1 +435,1 @@\n-# [Ordinance No. 11 of 1928, The Offical Gazette, 1928-06-26, p 813]\n+# [Ordinance No. 11 of 1928, The Official Gazette, 1928-06-26, p 813]\n@@ -1336,9 +1338,1 @@\n-# Zone\tNAME\t\tSTDOFF\tRULES\tFORMAT\t[UNTIL]\n-Zone\tIndian\/Reunion\t3:41:52 -\tLMT\t1911 Jun # Saint-Denis\n-\t\t\t4:00\t-\t+04\n-#\n-# Scattered Islands (Îles Éparses) administered from Réunion are as follows.\n-# The following information about them is taken from\n-# Îles Éparses (<http:\/\/www.outre-mer.gouv.fr\/domtom\/ile.htm>, 1997-07-22,\n-# in French; no longer available as of 1999-08-17).\n-# We have no info about their time zone histories.\n+# See Asia\/Dubai.\n@@ -1346,5 +1340,1 @@\n-# Bassas da India - uninhabited\n-# Europa Island - inhabited from 1905 to 1910 by two families\n-# Glorioso Is - inhabited until at least 1958\n-# Juan de Nova - uninhabited\n-# Tromelin - inhabited until at least 1958\n+# The Crozet Islands also observe Réunion time; see the 'antarctica' file.\n@@ -1382,1 +1372,1 @@\n-# coordinated time, will be restituted at 2 o'clock on day 1 of January, 2019.]\n+# coordinated time, will be reinstituted at 2 o'clock on day 1 of January, 2019.]\n@@ -1385,0 +1375,1 @@\n+\t\t#STDOFF\t-0:36:44.68\n@@ -1394,22 +1385,1 @@\n-\n-# From P Chan (2020-11-27):\n-# Standard Time was adopted on 1907-01-01.\n-#\n-# Standard Time Ordinance (Chapter 237)\n-# The Laws of Seychelles in Force on the 31st December, 1971, Vol. 6, p 571\n-# https:\/\/books.google.com\/books?id=efE-AQAAIAAJ&pg=PA571\n-#\n-# From Tim Parenti (2020-12-05):\n-# A footnote on https:\/\/books.google.com\/books?id=DYdDAQAAMAAJ&pg=PA1689\n-# confirms that Ordinance No. 9 of 1906 \"was brought into force on the 1st\n-# January, 1907.\"\n-\n-# Zone\tNAME\t\tSTDOFF\tRULES\tFORMAT\t[UNTIL]\n-Zone\tIndian\/Mahe\t3:41:48 -\tLMT\t1907 Jan  1 # Victoria\n-\t\t\t4:00\t-\t+04\n-# From Paul Eggert (2001-05-30):\n-# Aldabra, Farquhar, and Desroches, originally dependencies of the\n-# Seychelles, were transferred to the British Indian Ocean Territory\n-# in 1965 and returned to Seychelles control in 1976.  We don't know\n-# whether this affected their time zone, so omit this for now.\n-# Possibly the islands were uninhabited.\n+# See Asia\/Dubai.\n","filename":"src\/java.base\/share\/data\/tzdata\/africa","additions":9,"deletions":39,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -183,3 +183,1 @@\n-# Zone\tNAME\t\tSTDOFF\tRULES\tFORMAT\t[UNTIL]\n-Zone Indian\/Kerguelen\t0\t-\t-00\t1950 # Port-aux-Français\n-\t\t\t5:00\t-\t+05\n+# Kerguelen - see Indian\/Maldives.\n@@ -268,25 +266,1 @@\n-# From Craig Mundell (1994-12-15):\n-# http:\/\/quest.arc.nasa.gov\/antarctica\/QA\/computers\/Directions,Time,ZIP\n-# Vostok, which is one of the Russian stations, is set on the same\n-# time as Moscow, Russia.\n-#\n-# From Lee Hotz (2001-03-08):\n-# I queried the folks at Columbia who spent the summer at Vostok and this is\n-# what they had to say about time there:\n-# \"in the US Camp (East Camp) we have been on New Zealand (McMurdo)\n-# time, which is 12 hours ahead of GMT. The Russian Station Vostok was\n-# 6 hours behind that (although only 2 miles away, i.e. 6 hours ahead\n-# of GMT). This is a time zone I think two hours east of Moscow. The\n-# natural time zone is in between the two: 8 hours ahead of GMT.\"\n-#\n-# From Paul Eggert (2001-05-04):\n-# This seems to be hopelessly confusing, so I asked Lee Hotz about it\n-# in person.  He said that some Antarctic locations set their local\n-# time so that noon is the warmest part of the day, and that this\n-# changes during the year and does not necessarily correspond to mean\n-# solar noon.  So the Vostok time might have been whatever the clocks\n-# happened to be during their visit.  So we still don't really know what time\n-# it is at Vostok.  But we'll guess +06.\n-#\n-Zone Antarctica\/Vostok\t0\t-\t-00\t1957 Dec 16\n-\t\t\t6:00\t-\t+06\n+# See Asia\/Urumqi.\n","filename":"src\/java.base\/share\/data\/tzdata\/antarctica","additions":2,"deletions":28,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -281,4 +281,1 @@\n-# Zone\tNAME\t\tSTDOFF\tRULES\tFORMAT\t[UNTIL]\n-Zone\tAsia\/Brunei\t7:39:40 -\tLMT\t1926 Mar # Bandar Seri Begawan\n-\t\t\t7:30\t-\t+0730\t1933\n-\t\t\t8:00\t-\t+08\n+# See Asia\/Kuching.\n@@ -302,0 +299,1 @@\n+Link Asia\/Yangon Indian\/Cocos\n@@ -370,6 +368,3 @@\n-# a. For the 1940 May 31 spring forward, the essay claim that it was\n-# coordinared between the international settlement authority and the French\n-# concession authority and have gathered support from Hong Kong and Xiamen,\n-# that it would spring forward an hour from May 31 \"midnight\", and the essay\n-# claim \"Hong Kong government implemented the spring forward in the same time\n-# on the same date as Shanghai\".\n+# a. For the 1940 May 31 spring forward, the essay [says] ... \"Hong\n+# Kong government implemented the spring forward in the same time on\n+# the same date as Shanghai\".\n@@ -571,1 +566,1 @@\n-# Milne gives 8:05:43.2 for Xujiahui Observatory time; round to nearest.\n+# Milne gives 8:05:43.2 for Xujiahui Observatory time....\n@@ -690,0 +685,1 @@\n+\t\t#STDOFF\t8:05:43.2\n@@ -697,0 +693,1 @@\n+Link Asia\/Urumqi Antarctica\/Vostok\n@@ -701,1 +698,1 @@\n-# Milne gives 7:36:41.7; round this.\n+# Milne gives 7:36:41.7.\n@@ -885,1 +882,2 @@\n-Zone\tAsia\/Hong_Kong\t7:36:42 -\tLMT\t1904 Oct 30  0:36:42\n+\t\t#STDOFF\t7:36:41.7\n+Zone\tAsia\/Hong_Kong\t7:36:42 -\tLMT\t1904 Oct 29 17:00u\n@@ -1360,1 +1358,1 @@\n-# civil time was 7:07:12.5; round to even for Jakarta.\n+# civil time was 7:07:12.5.\n@@ -1396,0 +1394,1 @@\n+\t\t#STDOFF\t7:07:12.5\n@@ -1399,1 +1398,1 @@\n-\t\t\t7:07:12\t-\tBMT\t1923 Dec 31 23:47:12 # Batavia\n+\t\t\t7:07:12\t-\tBMT\t1923 Dec 31 16:40u # Batavia\n@@ -1431,0 +1430,105 @@\n+# From Roozbeh Pournader (2022-05-30):\n+# Here's an order from the Cabinet to the rest of the government to switch to\n+# Tehran time, which is mentioned to be already at +03:30:\n+# https:\/\/qavanin.ir\/Law\/TreeText\/180138\n+# Just in case that goes away, I also saved a copy at archive.org:\n+# https:\/\/web.archive.org\/web\/20220530111940\/https:\/\/qavanin.ir\/Law\/TreeText\/180138\n+# Here's my translation:\n+#\n+# \"Circular on Matching the Hours of Governmental and Official Circles\n+# in Provinces\n+# Approved 1314\/03\/22 [=1935-06-13]\n+# According to the ruling of the Honorable Cabinet, it is ordered that from\n+# now on in all internal provinces of the country, governmental and official\n+# circles set their time to match Tehran time (three hours and half before\n+# Greenwich)....\n+#\n+# I still haven't found out when Tehran itself switched to +03:30....\n+#\n+# From Paul Eggert (2022-06-05):\n+# Although the above says Tehran was at +03:30 before 1935-06-13, we don't\n+# know when it switched to +03:30.  For now, use 1935-06-13 as the switch date.\n+# Although most likely wrong, we have no better info.\n+\n+# From Roozbeh Pournader (2022-06-01):\n+# This is from Kayhan newspaper, one of the major Iranian newspapers, from\n+# March 20, 1978, page 2:\n+#\n+# \"Pull the clocks 60 minutes forward\n+# As we informed before, from the fourth day of the month Farvardin of the\n+# new year [=1978-03-24], clocks will be pulled forward, and people's daily\n+# work and life program will start one hour earlier than the current program.\n+# On the 1st day of the month Farvardin of this year [=1977-03-21], they had\n+# pulled the clocks forward by one hour, but in the month of Mehr\n+# [=1977-09-23], the clocks were pulled back by 30 minutes.\n+# In this way, from the 4th day of the month Farvardin, clocks will be ahead\n+# of the previous years by one hour and a half.\n+# According to the new program, during the night of 4th of Farvardin, when\n+# the midnight, meaning 24 o'clock is announced, the hands of the clock must\n+# be pulled forward by one hour and thus consider midnight 1 o'clock in the\n+# forenoon.\"\n+#\n+# This implies that in September 1977, when the daylight savings time was\n+# done with, Iran didn't go back to +03:30, but immediately to +04:00.\n+#\n+#\n+# This is from the major Iranian newspaper Ettela'at, dated [1978-08-03]...,\n+# page 32. It looks like they decided to get the clocks back to +4:00\n+# just in time for Ramadan that year:\n+#\n+# \"Tomorrow Night, Pull the Clocks Back by One Hour\n+# At 1 o'clock in the forenoon of Saturday 14 Mordad [=1978-08-05], the\n+# clocks will be pulled one hour back and instead of 1 o'clock in the\n+# forenoon, Radio Iran will announce 24 o'clock.\n+# This decision was made in the Cabinet of Ministers meeting of 25 Tir\n+# [=1978-07-16], [...]\n+# At the beginning of the year 2537 [=March 1978: Iran was using a different\n+# year number for a few years then, based on the Coronation of Cyrus the\n+# Great], the country's official time was pulled forward by one hour and now\n+# the official time is one hour and a half ahead compared to last year,\n+# because in Farvardin of last year [=March 1977], the official time was\n+# pulled forward one hour and this continued until the second half of last\n+# year [=September 1977] until in the second half of last year the official\n+# time was pulled back half an hour and that half hour still remains.\"\n+#\n+# This matches the time of the true noon published in the newspapers, as they\n+# clearly go from +05:00 to +04:00 after that date (which happened during a\n+# long weekend in Iran).\n+\n+# From Roozbeh Pournader (2022-05-31):\n+# [Movahedi S. Cultural preconceptions of time: Can we use operational time\n+# to meddle in God's Time? Comp Stud Soc Hist. 1985;27(3):385-400]\n+# https:\/\/www.jstor.org\/stable\/178704\n+# Here's the quotes from the paper:\n+# 1. '\"Iran's official time keeper moved the clock one hour forward as from\n+# March 22, 1977 (Farvardin 2, 2536) to make maximum use of daylight and save\n+# in energy consumption. Thus Iran joined such other countries as Britain in\n+# observing what is known as 'daylight saving.' The proposal was originally\n+# put forward by the Ministry of Energy, in no way having any influence on\n+# observing religious ceremonies. Moving time one hour forward in summer\n+# means that at 11:00 o'clock on March 21, the official time was set as\n+# midnight March 22. Then September 24 will actually begin one hour later\n+# than the end of September 23 [...].\" Iran's time base thus continued to be\n+# Greenwich Mean Time plus three and one-half hours (plus four and one-half\n+# hours in summer).'\n+#\n+# The article sources this from Iran Almanac and Book of Facts, 1977, Tehran:\n+# Echo of Iran, which is on Google Books at\n+# https:\/\/www.google.com\/books\/edition\/Iran_Almanac_and_Book_of_Facts\/9ybVAAAAMAAJ.\n+# (I confirmed it by searching for snippets.)\n+#\n+# 2. \"After the fall of the shah, the revolutionary government returned to\n+# daylight-saving time (DST) on 26 May 1979.\"\n+#\n+# This seems to have been announced just one day in advance, on 25 May 1979.\n+#\n+# The change in 1977 clearly seems to be the first daylight savings effort in\n+# Iran. But the article doesn't mention what happened in 1978 (which was\n+# still during the shah's government), or how things continued in 1979\n+# onwards (which was during the Islamic Republic).\n+\n+# From Francis Santoni (2022-06-01):\n+# for Iran and 1977 the effective change is only 20 October\n+# (UIT No. 143 17.XI.1977) and not 23 September (UIT No. 141 13.IX.1977).\n+# UIT is the Operational Bulletin of International Telecommunication Union.\n+\n@@ -1465,59 +1569,6 @@\n-# From Paul Eggert (2018-11-30):\n-# Go with Shanks & Pottenger before Sept. 1991, and with Pournader thereafter.\n-# I used the following code in GNU Emacs 26.1 to generate the \"Rule Iran\"\n-# lines from 2008 through 2087.  Emacs 26.1 uses Ed Reingold's\n-# cal-persia implementation of Birashk's approximation, which in the\n-# 2008-2087 range disagrees with the astronomical Persian calendar\n-# for Persian years 1404 (Gregorian 2025) and 1437 (Gregorian 2058), so\n-# the following code special-cases those years.  See Table 15.1, page 264, of:\n-# Edward M. Reingold and Nachum Dershowitz, Calendrical Calculations:\n-# The Ultimate Edition, Cambridge University Press (2018).\n-# https:\/\/www.cambridge.org\/fr\/academic\/subjects\/computer-science\/computing-general-interest\/calendrical-calculations-ultimate-edition-4th-edition\n-# Page 258, footnote 2, of this book says there is some dispute over what will\n-# happen in 2091 (and some other years after that), so this code\n-# stops in 2087, as 2088 and 2089 agree with the \"max\" rule below.\n-# (cl-loop\n-#  initially (require 'cal-persia)\n-#  with first-persian-year = 1387\n-#  with last-persian-year = 1466\n-#  ;; Exceptional years in the above range,\n-#  ;; from Reingold & Dershowitz Table 15.1, page 264:\n-#  with exceptional-persian-years = '(1404 1437)\n-#  with range-start = nil\n-#  for persian-year from first-persian-year to last-persian-year\n-#  do\n-#  (let*\n-#      ((exceptional-year-offset\n-#        (if (member persian-year exceptional-persian-years) 1 0))\n-#       (beg-dst-absolute\n-#        (+ (calendar-persian-to-absolute (list 1 1 persian-year))\n-#           exceptional-year-offset))\n-#       (end-dst-absolute\n-#        (+ (calendar-persian-to-absolute (list 6 30 persian-year))\n-#           exceptional-year-offset))\n-#       (next-year-beg-dst-absolute\n-#        (+ (calendar-persian-to-absolute (list 1 1 (1+ persian-year)))\n-#           (if (member (1+ persian-year) exceptional-persian-years) 1 0)))\n-#       (beg-dst (calendar-gregorian-from-absolute beg-dst-absolute))\n-#       (end-dst (calendar-gregorian-from-absolute end-dst-absolute))\n-#       (next-year-beg-dst (calendar-gregorian-from-absolute\n-#                           next-year-beg-dst-absolute))\n-#       (year (calendar-extract-year beg-dst))\n-#       (range-end (if range-start year \"only\")))\n-#    (setq range-start (or range-start year))\n-#    (when (or (\/= (calendar-extract-day beg-dst)\n-#                  (calendar-extract-day next-year-beg-dst))\n-#              (= persian-year last-persian-year))\n-#      (insert\n-#       (format\n-#        \"Rule\\tIran\\t%d\\t%s\\t-\\t%s\\t%2d\\t24:00\\t1:00\\t-\\n\"\n-#        range-start range-end\n-#        (calendar-month-name (calendar-extract-month beg-dst) t)\n-#        (calendar-extract-day beg-dst)))\n-#      (insert\n-#       (format\n-#        \"Rule\\tIran\\t%d\\t%s\\t-\\t%s\\t%2d\\t24:00\\t0\\t-\\n\"\n-#        range-start range-end\n-#        (calendar-month-name (calendar-extract-month end-dst) t)\n-#        (calendar-extract-day end-dst)))\n-#      (setq range-start nil))))\n+# From Paul Eggert (2022-06-30):\n+# Go with Pournader for 1935 through spring 1979, and for timestamps\n+# after August 1991; go with with Shanks & Pottenger for other timestamps.\n+# Go with Santoni's citation of the UIT for fall 1977, as 20 October 1977\n+# is 28 Mehr 1356, consistent with the \"Mehr\" in Pournader's source.\n+# Assume that the UIT's \"1930\" is UTC, i.e., 24:00 local time.\n@@ -1557,0 +1608,6 @@\n+# From Ali Mirjamali (2022-05-10):\n+# Official IR News Agency announcement: irna.ir\/xjJ3TT\n+# ...\n+# Highlights: DST will be cancelled for the next Iranian year 1402\n+# (i.e 2023-March-21) and forthcoming years.\n+#\n@@ -1558,2 +1615,8 @@\n-Rule\tIran\t1978\t1980\t-\tMar\t20\t24:00\t1:00\t-\n-Rule\tIran\t1978\tonly\t-\tOct\t20\t24:00\t0\t-\n+# Work around a bug in zic 2022a and earlier.\n+Rule\tIran\t1910\tonly\t-\tJan\t 1\t00:00\t0\t-\n+#\n+Rule\tIran\t1977\tonly\t-\tMar\t21\t23:00\t1:00\t-\n+Rule\tIran\t1977\tonly\t-\tOct\t20\t24:00\t0\t-\n+Rule\tIran\t1978\tonly\t-\tMar\t24\t24:00\t1:00\t-\n+Rule\tIran\t1978\tonly\t-\tAug\t 5\t01:00\t0\t-\n+Rule\tIran\t1979\tonly\t-\tMay\t26\t24:00\t1:00\t-\n@@ -1561,0 +1624,1 @@\n+Rule\tIran\t1980\tonly\t-\tMar\t20\t24:00\t1:00\t-\n@@ -1591,74 +1655,2 @@\n-Rule\tIran\t2021\t2023\t-\tMar\t21\t24:00\t1:00\t-\n-Rule\tIran\t2021\t2023\t-\tSep\t21\t24:00\t0\t-\n-Rule\tIran\t2024\tonly\t-\tMar\t20\t24:00\t1:00\t-\n-Rule\tIran\t2024\tonly\t-\tSep\t20\t24:00\t0\t-\n-Rule\tIran\t2025\t2027\t-\tMar\t21\t24:00\t1:00\t-\n-Rule\tIran\t2025\t2027\t-\tSep\t21\t24:00\t0\t-\n-Rule\tIran\t2028\t2029\t-\tMar\t20\t24:00\t1:00\t-\n-Rule\tIran\t2028\t2029\t-\tSep\t20\t24:00\t0\t-\n-Rule\tIran\t2030\t2031\t-\tMar\t21\t24:00\t1:00\t-\n-Rule\tIran\t2030\t2031\t-\tSep\t21\t24:00\t0\t-\n-Rule\tIran\t2032\t2033\t-\tMar\t20\t24:00\t1:00\t-\n-Rule\tIran\t2032\t2033\t-\tSep\t20\t24:00\t0\t-\n-Rule\tIran\t2034\t2035\t-\tMar\t21\t24:00\t1:00\t-\n-Rule\tIran\t2034\t2035\t-\tSep\t21\t24:00\t0\t-\n-Rule\tIran\t2036\t2037\t-\tMar\t20\t24:00\t1:00\t-\n-Rule\tIran\t2036\t2037\t-\tSep\t20\t24:00\t0\t-\n-Rule\tIran\t2038\t2039\t-\tMar\t21\t24:00\t1:00\t-\n-Rule\tIran\t2038\t2039\t-\tSep\t21\t24:00\t0\t-\n-Rule\tIran\t2040\t2041\t-\tMar\t20\t24:00\t1:00\t-\n-Rule\tIran\t2040\t2041\t-\tSep\t20\t24:00\t0\t-\n-Rule\tIran\t2042\t2043\t-\tMar\t21\t24:00\t1:00\t-\n-Rule\tIran\t2042\t2043\t-\tSep\t21\t24:00\t0\t-\n-Rule\tIran\t2044\t2045\t-\tMar\t20\t24:00\t1:00\t-\n-Rule\tIran\t2044\t2045\t-\tSep\t20\t24:00\t0\t-\n-Rule\tIran\t2046\t2047\t-\tMar\t21\t24:00\t1:00\t-\n-Rule\tIran\t2046\t2047\t-\tSep\t21\t24:00\t0\t-\n-Rule\tIran\t2048\t2049\t-\tMar\t20\t24:00\t1:00\t-\n-Rule\tIran\t2048\t2049\t-\tSep\t20\t24:00\t0\t-\n-Rule\tIran\t2050\t2051\t-\tMar\t21\t24:00\t1:00\t-\n-Rule\tIran\t2050\t2051\t-\tSep\t21\t24:00\t0\t-\n-Rule\tIran\t2052\t2053\t-\tMar\t20\t24:00\t1:00\t-\n-Rule\tIran\t2052\t2053\t-\tSep\t20\t24:00\t0\t-\n-Rule\tIran\t2054\t2055\t-\tMar\t21\t24:00\t1:00\t-\n-Rule\tIran\t2054\t2055\t-\tSep\t21\t24:00\t0\t-\n-Rule\tIran\t2056\t2057\t-\tMar\t20\t24:00\t1:00\t-\n-Rule\tIran\t2056\t2057\t-\tSep\t20\t24:00\t0\t-\n-Rule\tIran\t2058\t2059\t-\tMar\t21\t24:00\t1:00\t-\n-Rule\tIran\t2058\t2059\t-\tSep\t21\t24:00\t0\t-\n-Rule\tIran\t2060\t2062\t-\tMar\t20\t24:00\t1:00\t-\n-Rule\tIran\t2060\t2062\t-\tSep\t20\t24:00\t0\t-\n-Rule\tIran\t2063\tonly\t-\tMar\t21\t24:00\t1:00\t-\n-Rule\tIran\t2063\tonly\t-\tSep\t21\t24:00\t0\t-\n-Rule\tIran\t2064\t2066\t-\tMar\t20\t24:00\t1:00\t-\n-Rule\tIran\t2064\t2066\t-\tSep\t20\t24:00\t0\t-\n-Rule\tIran\t2067\tonly\t-\tMar\t21\t24:00\t1:00\t-\n-Rule\tIran\t2067\tonly\t-\tSep\t21\t24:00\t0\t-\n-Rule\tIran\t2068\t2070\t-\tMar\t20\t24:00\t1:00\t-\n-Rule\tIran\t2068\t2070\t-\tSep\t20\t24:00\t0\t-\n-Rule\tIran\t2071\tonly\t-\tMar\t21\t24:00\t1:00\t-\n-Rule\tIran\t2071\tonly\t-\tSep\t21\t24:00\t0\t-\n-Rule\tIran\t2072\t2074\t-\tMar\t20\t24:00\t1:00\t-\n-Rule\tIran\t2072\t2074\t-\tSep\t20\t24:00\t0\t-\n-Rule\tIran\t2075\tonly\t-\tMar\t21\t24:00\t1:00\t-\n-Rule\tIran\t2075\tonly\t-\tSep\t21\t24:00\t0\t-\n-Rule\tIran\t2076\t2078\t-\tMar\t20\t24:00\t1:00\t-\n-Rule\tIran\t2076\t2078\t-\tSep\t20\t24:00\t0\t-\n-Rule\tIran\t2079\tonly\t-\tMar\t21\t24:00\t1:00\t-\n-Rule\tIran\t2079\tonly\t-\tSep\t21\t24:00\t0\t-\n-Rule\tIran\t2080\t2082\t-\tMar\t20\t24:00\t1:00\t-\n-Rule\tIran\t2080\t2082\t-\tSep\t20\t24:00\t0\t-\n-Rule\tIran\t2083\tonly\t-\tMar\t21\t24:00\t1:00\t-\n-Rule\tIran\t2083\tonly\t-\tSep\t21\t24:00\t0\t-\n-Rule\tIran\t2084\t2086\t-\tMar\t20\t24:00\t1:00\t-\n-Rule\tIran\t2084\t2086\t-\tSep\t20\t24:00\t0\t-\n-Rule\tIran\t2087\tonly\t-\tMar\t21\t24:00\t1:00\t-\n-Rule\tIran\t2087\tonly\t-\tSep\t21\t24:00\t0\t-\n-#\n-# The following rules are approximations starting in the year 2088.\n-# These are the best post-2088 approximations available, given the\n-# restrictions of a single rule using ordinary Gregorian dates.\n-# At some point this table will need to be extended, though quite\n-# possibly Iran will change the rules first.\n-Rule\tIran\t2088\tmax\t-\tMar\t20\t24:00\t1:00\t-\n-Rule\tIran\t2088\tmax\t-\tSep\t20\t24:00\t0\t-\n+Rule\tIran\t2021\t2022\t-\tMar\t21\t24:00\t1:00\t-\n+Rule\tIran\t2021\t2022\t-\tSep\t21\t24:00\t0\t-\n@@ -1668,2 +1660,2 @@\n-\t\t\t3:25:44\t-\tTMT\t1946     # Tehran Mean Time\n-\t\t\t3:30\t-\t+0330\t1977 Nov\n+\t\t\t3:25:44\t-\tTMT\t1935 Jun 13 # Tehran Mean Time\n+\t\t\t3:30\tIran\t+0330\/+0430 1977 Oct 20 24:00\n@@ -2491,3 +2483,3 @@\n-# Qyzyolrda Region (Asia\/Qyzylorda) is changing its time zone from\n-# UTC+6 to UTC+5 effective December 21st, 2018. The legal document is\n-# located here: http:\/\/adilet.zan.kz\/rus\/docs\/P1800000817 (russian language).\n+# (Asia\/Qyzylorda) is changing its time zone from UTC+6 to UTC+5\n+# effective December 21st, 2018....\n+# http:\/\/adilet.zan.kz\/rus\/docs\/P1800000817 (russian language).\n@@ -2770,14 +2762,2 @@\n-# peninsular Malaysia\n-# taken from Mok Ly Yng (2003-10-30)\n-# https:\/\/web.archive.org\/web\/20190822231045\/http:\/\/www.math.nus.edu.sg\/~mathelmr\/teaching\/timezone.html\n-# This agrees with Singapore since 1905-06-01.\n-# Zone\tNAME\t\tSTDOFF\tRULES\tFORMAT\t[UNTIL]\n-Zone Asia\/Kuala_Lumpur\t6:46:46 -\tLMT\t1901 Jan  1\n-\t\t\t6:55:25\t-\tSMT\t1905 Jun  1 # Singapore M.T.\n-\t\t\t7:00\t-\t+07\t1933 Jan  1\n-\t\t\t7:00\t0:20\t+0720\t1936 Jan  1\n-\t\t\t7:20\t-\t+0720\t1941 Sep  1\n-\t\t\t7:30\t-\t+0730\t1942 Feb 16\n-\t\t\t9:00\t-\t+09\t1945 Sep 12\n-\t\t\t7:30\t-\t+0730\t1982 Jan  1\n-\t\t\t8:00\t-\t+08\n+# For peninsular Malaysia see Asia\/Singapore.\n+#\n@@ -2794,0 +2774,1 @@\n+Link Asia\/Kuching Asia\/Brunei\n@@ -2800,0 +2781,1 @@\n+Link Indian\/Maldives Indian\/Kerguelen\n@@ -3634,0 +3616,1 @@\n+Link Asia\/Singapore Asia\/Kuala_Lumpur\n@@ -3868,1 +3851,1 @@\n-\t\t\t5:00\t1:00\t+05\/+06\t1991 Sep  9  2:00s\n+\t\t\t5:00\t1:00\t+06\t1991 Sep  9  2:00s\n@@ -3878,0 +3861,1 @@\n+Link Asia\/Bangkok Indian\/Christmas\n@@ -3893,0 +3877,2 @@\n+Link Asia\/Dubai Indian\/Mahe\n+Link Asia\/Dubai Indian\/Reunion\n@@ -3904,1 +3890,2 @@\n-# Milne says Tashkent was 4:37:10.8; round to nearest.\n+# Milne says Tashkent was 4:37:10.8.\n+\t\t#STDOFF\t4:37:10.8\n@@ -3923,1 +3910,1 @@\n-# From Paul Eggert (2014-10-21) after a heads-up from Trần Ngọc Quân:\n+# From Paul Eggert (2022-07-27) after a 2014 heads-up from Trần Ngọc Quân:\n@@ -3935,2 +3922,2 @@\n-# the Paris Meridian (2° 20' 14.03\" E); the former yields 07:06:30.1333...\n-# and the latter 07:06:29.333... so either way it rounds to 07:06:30,\n+# the Paris Meridian; for now guess the former and round the exact\n+# 07:06:30.1333... to 07:06:30.13 as the legal spec used 66 2\/3 ms precision.\n@@ -3963,1 +3950,2 @@\n-Zone Asia\/Ho_Chi_Minh\t7:06:40 -\tLMT\t1906 Jul  1\n+\t\t#STDOFF\t7:06:30.13\n+Zone Asia\/Ho_Chi_Minh\t7:06:30 -\tLMT\t1906 Jul  1\n","filename":"src\/java.base\/share\/data\/tzdata\/asia","additions":163,"deletions":175,"binary":false,"changes":338,"status":"modified"},{"patch":"@@ -278,3 +278,1 @@\n-# Zone\tNAME\t\tSTDOFF\tRULES\tFORMAT\t[UNTIL]\n-Zone Indian\/Christmas\t7:02:52 -\tLMT\t1895 Feb\n-\t\t\t7:00\t-\t+07\n+# See Asia\/Bangkok.\n@@ -283,5 +281,1 @@\n-# These islands were ruled by the Ross family from about 1830 to 1978.\n-# We don't know when standard time was introduced; for now, we guess 1900.\n-# Zone\tNAME\t\tSTDOFF\tRULES\tFORMAT\t[UNTIL]\n-Zone\tIndian\/Cocos\t6:27:40\t-\tLMT\t1900\n-\t\t\t6:30\t-\t+0630\n+# See Asia\/Yangon.\n@@ -504,0 +498,5 @@\n+Link Pacific\/Tarawa Pacific\/Funafuti\n+Link Pacific\/Tarawa Pacific\/Majuro\n+Link Pacific\/Tarawa Pacific\/Wake\n+Link Pacific\/Tarawa Pacific\/Wallis\n+\n@@ -517,0 +516,1 @@\n+# See Pacific\/Tarawa for most locations.\n@@ -518,8 +518,0 @@\n-Zone Pacific\/Majuro\t 11:24:48 -\tLMT\t1901\n-\t\t\t 11:00\t-\t+11\t1914 Oct\n-\t\t\t  9:00\t-\t+09\t1919 Feb  1\n-\t\t\t 11:00\t-\t+11\t1937\n-\t\t\t 10:00\t-\t+10\t1941 Apr  1\n-\t\t\t  9:00\t-\t+09\t1944 Jan 30\n-\t\t\t 11:00\t-\t+11\t1969 Oct\n-\t\t\t 12:00\t-\t+12\n@@ -535,0 +527,2 @@\n+# For Chuuk and Yap see Pacific\/Port_Moresby.\n+# For Pohnpei see Pacific\/Guadalcanal.\n@@ -536,15 +530,0 @@\n-Zone Pacific\/Chuuk\t-13:52:52 -\tLMT\t1844 Dec 31\n-\t\t\t 10:07:08 -\tLMT\t1901\n-\t\t\t 10:00\t-\t+10\t1914 Oct\n-\t\t\t  9:00\t-\t+09\t1919 Feb  1\n-\t\t\t 10:00\t-\t+10\t1941 Apr  1\n-\t\t\t  9:00\t-\t+09\t1945 Aug\n-\t\t\t 10:00\t-\t+10\n-Zone Pacific\/Pohnpei\t-13:27:08 -\tLMT\t1844 Dec 31\t# Kolonia\n-\t\t\t 10:32:52 -\tLMT\t1901\n-\t\t\t 11:00\t-\t+11\t1914 Oct\n-\t\t\t  9:00\t-\t+09\t1919 Feb  1\n-\t\t\t 11:00\t-\t+11\t1937\n-\t\t\t 10:00\t-\t+10\t1941 Apr  1\n-\t\t\t  9:00\t-\t+09\t1945 Aug\n-\t\t\t 11:00\t-\t+11\n@@ -620,0 +599,2 @@\n+Link Pacific\/Auckland Antarctica\/McMurdo\n+\n@@ -624,2 +605,0 @@\n-Link Pacific\/Auckland Antarctica\/McMurdo\n-\n@@ -684,1 +663,1 @@\n-# See Pacific\/Raratonga comments for 1952 transition.\n+# See Pacific\/Rarotonga comments for 1952 transition.\n@@ -720,0 +699,1 @@\n+Link Pacific\/Port_Moresby Pacific\/Chuuk\n@@ -847,0 +827,1 @@\n+Link Pacific\/Guadalcanal Pacific\/Pohnpei\n@@ -887,3 +868,1 @@\n-# Zone\tNAME\t\tSTDOFF\tRULES\tFORMAT\t[UNTIL]\n-Zone Pacific\/Funafuti\t11:56:52 -\tLMT\t1901\n-\t\t\t12:00\t-\t+12\n+# See Pacific\/Tarawa.\n@@ -948,3 +927,1 @@\n-# Zone\tNAME\t\tSTDOFF\tRULES\tFORMAT\t[UNTIL]\n-Zone\tPacific\/Wake\t11:06:28 -\tLMT\t1901\n-\t\t\t12:00\t-\t+12\n+# See Pacific\/Tarawa.\n@@ -989,3 +966,1 @@\n-# Zone\tNAME\t\tSTDOFF\tRULES\tFORMAT\t[UNTIL]\n-Zone\tPacific\/Wallis\t12:15:20 -\tLMT\t1901\n-\t\t\t12:00\t-\t+12\n+# See Pacific\/Tarawa.\n@@ -1309,0 +1284,1 @@\n+# [The article ends with \"Today's date is April 1.\"]\n@@ -1852,10 +1828,6 @@\n-# From Phake Nick (2018-10-27):\n-# <https:\/\/wiki.suikawiki.org\/n\/南洋群島の標準時> ... pointed out that\n-# currently tzdata say Pacific\/Kwajalein switched from GMT+11 to GMT-12 in\n-# 1969 October without explanation, however an 1993 article from NYT say it\n-# synchorized its day with US mainland about 40 years ago and thus the switch\n-# should occur at around 1950s instead.\n-#\n-# From Paul Eggert (2018-11-18):\n-# The NYT (actually, AP) article is vague and possibly wrong about this.\n-# The article says the earlier switch was \"40 years ago when the United States\n+# From Paul Eggert (2022-03-31):\n+# Phake Nick (2018-10-27) noted <https:\/\/wiki.suikawiki.org\/n\/南洋群島の標準時>'s\n+# citation of a 1993 AP article published in the New York Times saying\n+# Kwajalein synchronized its day with the US mainland about 40 years earlier.\n+# However the AP article is vague and possibly wrong about this.  The article\n+# says the earlier switch was \"about 40 years ago when the United States\n@@ -1908,7 +1880,0 @@\n-# Alan Eugene Davis writes (1996-03-16),\n-# \"I am certain, having lived there for the past decade, that 'Truk'\n-# (now properly known as Chuuk) ... is in the time zone GMT+10.\"\n-#\n-# Shanks & Pottenger write that Truk switched from UT +10 to +11\n-# on 1978-10-01; ignore this for now.\n-\n@@ -2245,1 +2210,1 @@\n-# In August government was disolved by the King.  The current prime minister\n+# In August government was dissolved by the King.  The current prime minister\n@@ -2253,20 +2218,0 @@\n-# Wake\n-\n-# From Vernice Anderson, Personal Secretary to Philip Jessup,\n-# US Ambassador At Large (oral history interview, 1971-02-02):\n-#\n-# Saturday, the 14th [of October, 1950] - ...  The time was all the\n-# more confusing at that point, because we had crossed the\n-# International Date Line, thus getting two Sundays.  Furthermore, we\n-# discovered that Wake Island had two hours of daylight saving time\n-# making calculation of time in Washington difficult if not almost\n-# impossible.\n-#\n-# https:\/\/www.trumanlibrary.org\/oralhist\/andrsonv.htm\n-\n-# From Paul Eggert (2003-03-23):\n-# We have no other report of DST in Wake Island, so omit this info for now.\n-\n-# See also the commentary for Micronesia.\n-\n-\n","filename":"src\/java.base\/share\/data\/tzdata\/australasia","additions":26,"deletions":81,"binary":false,"changes":107,"status":"modified"},{"patch":"@@ -30,1 +30,2 @@\n-# Many names changed in late 1993.  Several of these names are\n+# Many names changed in late 1993, and many merged names moved here\n+# in the period from 2013 through 2022.  Several of these names are\n@@ -34,0 +35,4 @@\n+# Although this file is optional and tzdb will work if you omit it by\n+# building with 'make BACKWARD=', in practice downstream users\n+# typically use this file for backward compatibility.\n+\n@@ -74,1 +79,1 @@\n-Link\tEurope\/Oslo\t\tAtlantic\/Jan_Mayen\n+Link\tEurope\/Berlin\t\tAtlantic\/Jan_Mayen\n@@ -109,0 +114,1 @@\n+Link\tEurope\/Kyiv\t\tEurope\/Kiev\n@@ -117,1 +123,1 @@\n-Link\tAtlantic\/Reykjavik\tIceland\n+Link\tAfrica\/Abidjan\t\tIceland\n@@ -133,1 +139,1 @@\n-Link\tPacific\/Pohnpei\t\tPacific\/Ponape\n+Link\tPacific\/Guadalcanal\tPacific\/Ponape\n@@ -135,2 +141,2 @@\n-Link\tPacific\/Chuuk\t\tPacific\/Truk\n-Link\tPacific\/Chuuk\t\tPacific\/Yap\n+Link\tPacific\/Port_Moresby\tPacific\/Truk\n+Link\tPacific\/Port_Moresby\tPacific\/Yap\n","filename":"src\/java.base\/share\/data\/tzdata\/backward","additions":12,"deletions":6,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -43,0 +43,3 @@\n+\n+# The following zone is used by tzcode functions like gmtime,\n+# which load the \"UTC\" file to handle seconds properly.\n@@ -47,2 +50,3 @@\n-# as functions like gmtime load the \"GMT\" file to handle leap seconds properly.\n-# We want this to work even on installations that omit the other older names.\n+# as it is needed for tzcode releases through 2022a,\n+# where functions like gmtime load \"GMT\" instead of the \"Etc\/UTC\".\n+# We want this to work even on installations that omit 'backward'.\n","filename":"src\/java.base\/share\/data\/tzdata\/etcetera","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -329,2 +329,1 @@\n-# transition for now and just use the latter value, omitting its\n-# fraction since our format cannot represent fractions.\n+# transition for now and just use the latter value.\n@@ -526,1 +525,1 @@\n-Zone\tEurope\/London\t-0:01:15 -\tLMT\t1847 Dec  1  0:00s\n+Zone\tEurope\/London\t-0:01:15 -\tLMT\t1847 Dec  1\n@@ -564,1 +563,2 @@\n-Zone\tEurope\/Dublin\t-0:25:00 -\tLMT\t1880 Aug  2\n+\t\t#STDOFF\t-0:25:21.1\n+Zone\tEurope\/Dublin\t-0:25:21 -\tLMT\t1880 Aug  2\n@@ -987,0 +987,2 @@\n+Link Europe\/Brussels Europe\/Amsterdam\n+Link Europe\/Brussels Europe\/Luxembourg\n@@ -1049,1 +1051,1 @@\n-# Use Europe\/Prague also for Slovakia.\n+Link Europe\/Prague Europe\/Bratislava\n@@ -1051,1 +1053,0 @@\n-# Denmark, Faroe Islands, and Greenland\n@@ -1053,31 +1054,2 @@\n-# From Jesper Nørgaard Welen (2005-04-26):\n-# the law [introducing standard time] was in effect from 1894-01-01....\n-# The page https:\/\/www.retsinformation.dk\/eli\/lta\/1893\/83\n-# confirms this, and states that the law was put forth 1893-03-29.\n-#\n-# The EU [actually, EEC and Euratom] treaty with effect from 1973:\n-# https:\/\/www.retsinformation.dk\/eli\/lta\/1972\/21100\n-#\n-# This provoked a new law from 1974 to make possible summer time changes\n-# in subsequent decrees with the law\n-# https:\/\/www.retsinformation.dk\/eli\/lta\/1974\/223\n-#\n-# It seems however that no decree was set forward until 1980.  I have\n-# not found any decree, but in another related law, the effecting DST\n-# changes are stated explicitly to be from 1980-04-06 at 02:00 to\n-# 1980-09-28 at 02:00.  If this is true, this differs slightly from\n-# the EU rule in that DST runs to 02:00, not 03:00.  We don't know\n-# when Denmark began using the EU rule correctly, but we have only\n-# confirmation of the 1980-time, so I presume it was correct in 1981:\n-# The law is about the management of the extra hour, concerning\n-# working hours reported and effect on obligatory-rest rules (which\n-# was suspended on that night):\n-# https:\/\/web.archive.org\/web\/20140104053304\/https:\/\/www.retsinformation.dk\/Forms\/R0710.aspx?id=60267\n-\n-# From Jesper Nørgaard Welen (2005-06-11):\n-# The Herning Folkeblad (1980-09-26) reported that the night between\n-# Saturday and Sunday the clock is set back from three to two.\n-\n-# From Paul Eggert (2005-06-11):\n-# Hence the \"02:00\" of the 1980 law refers to standard time, not\n-# wall-clock time, and so the EU rules were in effect in 1980.\n+# Denmark, Faroe Islands, and Greenland\n+# For Denmark see Europe\/Berlin.\n@@ -1085,20 +1057,0 @@\n-# Rule\tNAME\tFROM\tTO\t-\tIN\tON\tAT\tSAVE\tLETTER\/S\n-Rule\tDenmark\t1916\tonly\t-\tMay\t14\t23:00\t1:00\tS\n-Rule\tDenmark\t1916\tonly\t-\tSep\t30\t23:00\t0\t-\n-Rule\tDenmark\t1940\tonly\t-\tMay\t15\t 0:00\t1:00\tS\n-Rule\tDenmark\t1945\tonly\t-\tApr\t 2\t 2:00s\t1:00\tS\n-Rule\tDenmark\t1945\tonly\t-\tAug\t15\t 2:00s\t0\t-\n-Rule\tDenmark\t1946\tonly\t-\tMay\t 1\t 2:00s\t1:00\tS\n-Rule\tDenmark\t1946\tonly\t-\tSep\t 1\t 2:00s\t0\t-\n-Rule\tDenmark\t1947\tonly\t-\tMay\t 4\t 2:00s\t1:00\tS\n-Rule\tDenmark\t1947\tonly\t-\tAug\t10\t 2:00s\t0\t-\n-Rule\tDenmark\t1948\tonly\t-\tMay\t 9\t 2:00s\t1:00\tS\n-Rule\tDenmark\t1948\tonly\t-\tAug\t 8\t 2:00s\t0\t-\n-#\n-# Zone\tNAME\t\tSTDOFF\tRULES\tFORMAT\t[UNTIL]\n-Zone Europe\/Copenhagen\t 0:50:20 -\tLMT\t1890\n-\t\t\t 0:50:20 -\tCMT\t1894 Jan  1 # Copenhagen MT\n-\t\t\t 1:00\tDenmark\tCE%sT\t1942 Nov  2  2:00s\n-\t\t\t 1:00\tC-Eur\tCE%sT\t1945 Apr  2  2:00\n-\t\t\t 1:00\tDenmark\tCE%sT\t1980\n-\t\t\t 1:00\tEU\tCE%sT\n@@ -1324,2 +1276,1 @@\n-# Milne says Helsinki (Helsingfors) time was 1:39:49.2 (official document);\n-# round to nearest.\n+# Milne says Helsinki (Helsingfors) time was 1:39:49.2 (official document).\n@@ -1328,0 +1279,1 @@\n+\t\t#STDOFF\t1:39:49.2\n@@ -1474,0 +1426,1 @@\n+Link Europe\/Paris Europe\/Monaco\n@@ -1517,0 +1470,4 @@\n+Link Europe\/Berlin Arctic\/Longyearbyen\n+Link Europe\/Berlin Europe\/Copenhagen\n+Link Europe\/Berlin Europe\/Oslo\n+Link Europe\/Berlin Europe\/Stockholm\n@@ -1518,14 +1475,0 @@\n-# From Tobias Conradi (2011-09-12):\n-# Büsingen <http:\/\/www.buesingen.de>, surrounded by the Swiss canton\n-# Schaffhausen, did not start observing DST in 1980 as the rest of DE\n-# (West Germany at that time) and DD (East Germany at that time) did.\n-# DD merged into DE, the area is currently covered by code DE in ISO 3166-1,\n-# which in turn is covered by the zone Europe\/Berlin.\n-#\n-# Source for the time in Büsingen 1980:\n-# http:\/\/www.srf.ch\/player\/video?id=c012c029-03b7-4c2b-9164-aa5902cd58d3\n-\n-# From Arthur David Olson (2012-03-03):\n-# Büsingen and Zurich have shared clocks since 1970.\n-\n-Link\tEurope\/Zurich\tEurope\/Busingen\n@@ -1540,1 +1483,1 @@\n-Zone Europe\/Gibraltar\t-0:21:24 -\tLMT\t1880 Aug  2  0:00s\n+Zone Europe\/Gibraltar\t-0:21:24 -\tLMT\t1880 Aug  2\n@@ -1651,56 +1594,1 @@\n-#\n-# From Adam David (1993-11-06):\n-# The name of the timezone in Iceland for system \/ mail \/ news purposes is GMT.\n-#\n-# (1993-12-05):\n-# This material is paraphrased from the 1988 edition of the University of\n-# Iceland Almanak.\n-#\n-# From January 1st, 1908 the whole of Iceland was standardised at 1 hour\n-# behind GMT. Previously, local mean solar time was used in different parts\n-# of Iceland, the almanak had been based on Reykjavík mean solar time which\n-# was 1 hour and 28 minutes behind GMT.\n-#\n-# \"first day of winter\" referred to [below] means the first day of the 26 weeks\n-# of winter, according to the old icelandic calendar that dates back to the\n-# time the norsemen first settled Iceland.  The first day of winter is always\n-# Saturday, but is not dependent on the Julian or Gregorian calendars.\n-#\n-# (1993-12-10):\n-# I have a reference from the Oxford Icelandic-English dictionary for the\n-# beginning of winter, which ties it to the ecclesiastical calendar (and thus\n-# to the julian\/gregorian calendar) over the period in question.\n-#\tthe winter begins on the Saturday next before St. Luke's day\n-#\t(old style), or on St. Luke's day, if a Saturday.\n-# St. Luke's day ought to be traceable from ecclesiastical sources. \"old style\"\n-# might be a reference to the Julian calendar as opposed to Gregorian, or it\n-# might mean something else (???).\n-#\n-# From Paul Eggert (2014-11-22):\n-# The information below is taken from the 1988 Almanak; see\n-# http:\/\/www.almanak.hi.is\/klukkan.html\n-#\n-# Rule\tNAME\tFROM\tTO\t-\tIN\tON\tAT\tSAVE\tLETTER\/S\n-Rule\tIceland\t1917\t1919\t-\tFeb\t19\t23:00\t1:00\t-\n-Rule\tIceland\t1917\tonly\t-\tOct\t21\t 1:00\t0\t-\n-Rule\tIceland\t1918\t1919\t-\tNov\t16\t 1:00\t0\t-\n-Rule\tIceland\t1921\tonly\t-\tMar\t19\t23:00\t1:00\t-\n-Rule\tIceland\t1921\tonly\t-\tJun\t23\t 1:00\t0\t-\n-Rule\tIceland\t1939\tonly\t-\tApr\t29\t23:00\t1:00\t-\n-Rule\tIceland\t1939\tonly\t-\tOct\t29\t 2:00\t0\t-\n-Rule\tIceland\t1940\tonly\t-\tFeb\t25\t 2:00\t1:00\t-\n-Rule\tIceland\t1940\t1941\t-\tNov\tSun>=2\t 1:00s\t0\t-\n-Rule\tIceland\t1941\t1942\t-\tMar\tSun>=2\t 1:00s\t1:00\t-\n-# 1943-1946 - first Sunday in March until first Sunday in winter\n-Rule\tIceland\t1943\t1946\t-\tMar\tSun>=1\t 1:00s\t1:00\t-\n-Rule\tIceland\t1942\t1948\t-\tOct\tSun>=22\t 1:00s\t0\t-\n-# 1947-1967 - first Sunday in April until first Sunday in winter\n-Rule\tIceland\t1947\t1967\t-\tApr\tSun>=1\t 1:00s\t1:00\t-\n-# 1949 and 1967 Oct transitions delayed by 1 week\n-Rule\tIceland\t1949\tonly\t-\tOct\t30\t 1:00s\t0\t-\n-Rule\tIceland\t1950\t1966\t-\tOct\tSun>=22\t 1:00s\t0\t-\n-Rule\tIceland\t1967\tonly\t-\tOct\t29\t 1:00s\t0\t-\n-# Zone\tNAME\t\tSTDOFF\tRULES\tFORMAT\t[UNTIL]\n-Zone Atlantic\/Reykjavik\t-1:28\t-\tLMT\t1908\n-\t\t\t-1:00\tIceland\t-01\/+00\t1968 Apr  7  1:00s\n-\t\t\t 0:00\t-\tGMT\n+# See Africa\/Abidjan.\n@@ -1822,1 +1710,1 @@\n-\t\t\t0:49:56\t-\tRMT\t1893 Oct 31 23:49:56 # Rome Mean\n+\t\t\t0:49:56\t-\tRMT\t1893 Oct 31 23:00u # Rome Mean\n@@ -1827,0 +1715,3 @@\n+Link Europe\/Rome Europe\/Vatican\n+Link Europe\/Rome Europe\/San_Marino\n+\n@@ -1832,3 +1723,0 @@\n-Link\tEurope\/Rome\tEurope\/Vatican\n-Link\tEurope\/Rome\tEurope\/San_Marino\n-\n@@ -1918,10 +1806,1 @@\n-\n-# From Paul Eggert (2013-09-09):\n-# Shanks & Pottenger say Vaduz is like Zurich.\n-\n-# From Alois Treindl (2019-07-04):\n-# I was able to access the online archive of the Vaduz paper Vaterland ...\n-# I could confirm from the paper that Liechtenstein did in fact follow\n-# the same DST in 1941 and 1942 as Switzerland did.\n-\n-Link Europe\/Zurich Europe\/Vaduz\n+# See Europe\/Zurich.\n@@ -1983,34 +1862,1 @@\n-# Whitman disagrees with most of these dates in minor ways;\n-# go with Shanks & Pottenger.\n-# Rule\tNAME\tFROM\tTO\t-\tIN\tON\tAT\tSAVE\tLETTER\/S\n-Rule\tLux\t1916\tonly\t-\tMay\t14\t23:00\t1:00\tS\n-Rule\tLux\t1916\tonly\t-\tOct\t 1\t 1:00\t0\t-\n-Rule\tLux\t1917\tonly\t-\tApr\t28\t23:00\t1:00\tS\n-Rule\tLux\t1917\tonly\t-\tSep\t17\t 1:00\t0\t-\n-Rule\tLux\t1918\tonly\t-\tApr\tMon>=15\t 2:00s\t1:00\tS\n-Rule\tLux\t1918\tonly\t-\tSep\tMon>=15\t 2:00s\t0\t-\n-Rule\tLux\t1919\tonly\t-\tMar\t 1\t23:00\t1:00\tS\n-Rule\tLux\t1919\tonly\t-\tOct\t 5\t 3:00\t0\t-\n-Rule\tLux\t1920\tonly\t-\tFeb\t14\t23:00\t1:00\tS\n-Rule\tLux\t1920\tonly\t-\tOct\t24\t 2:00\t0\t-\n-Rule\tLux\t1921\tonly\t-\tMar\t14\t23:00\t1:00\tS\n-Rule\tLux\t1921\tonly\t-\tOct\t26\t 2:00\t0\t-\n-Rule\tLux\t1922\tonly\t-\tMar\t25\t23:00\t1:00\tS\n-Rule\tLux\t1922\tonly\t-\tOct\tSun>=2\t 1:00\t0\t-\n-Rule\tLux\t1923\tonly\t-\tApr\t21\t23:00\t1:00\tS\n-Rule\tLux\t1923\tonly\t-\tOct\tSun>=2\t 2:00\t0\t-\n-Rule\tLux\t1924\tonly\t-\tMar\t29\t23:00\t1:00\tS\n-Rule\tLux\t1924\t1928\t-\tOct\tSun>=2\t 1:00\t0\t-\n-Rule\tLux\t1925\tonly\t-\tApr\t 5\t23:00\t1:00\tS\n-Rule\tLux\t1926\tonly\t-\tApr\t17\t23:00\t1:00\tS\n-Rule\tLux\t1927\tonly\t-\tApr\t 9\t23:00\t1:00\tS\n-Rule\tLux\t1928\tonly\t-\tApr\t14\t23:00\t1:00\tS\n-Rule\tLux\t1929\tonly\t-\tApr\t20\t23:00\t1:00\tS\n-# Zone\tNAME\t\tSTDOFF\tRULES\tFORMAT\t[UNTIL]\n-Zone Europe\/Luxembourg\t0:24:36 -\tLMT\t1904 Jun\n-\t\t\t1:00\tLux\tCE%sT\t1918 Nov 25\n-\t\t\t0:00\tLux\tWE%sT\t1929 Oct  6  2:00s\n-\t\t\t0:00\tBelgium\tWE%sT\t1940 May 14  3:00\n-\t\t\t1:00\tC-Eur\tWE%sT\t1944 Sep 18  3:00\n-\t\t\t1:00\tBelgium\tCE%sT\t1977\n-\t\t\t1:00\tEU\tCE%sT\n+# See Europe\/Brussels.\n@@ -2035,1 +1881,1 @@\n-Zone\tEurope\/Malta\t0:58:04 -\tLMT\t1893 Nov  2  0:00s # Valletta\n+Zone\tEurope\/Malta\t0:58:04 -\tLMT\t1893 Nov  2 # Valletta\n@@ -2117,21 +1963,1 @@\n-#\n-# From Michael Deckers (2020-06-12):\n-# In the \"Journal de Monaco\" of 1892-05-24, online at\n-# https:\/\/journaldemonaco.gouv.mc\/var\/jdm\/storage\/original\/application\/b1c67c12c5af11b41ea888fb048e4fe8.pdf\n-# we read: ...\n-#  [In virtue of a Sovereign Ordinance of the May 13 of the current [year],\n-#   legal time in the Principality will be set to, from the date of June 1,\n-#   1892 onwards, to the meridian of Paris, as in France.]\n-# In the \"Journal de Monaco\" of 1911-03-28, online at\n-# https:\/\/journaldemonaco.gouv.mc\/var\/jdm\/storage\/original\/application\/de74ffb7db53d4f599059fe8f0ed482a.pdf\n-# we read an ordinance of 1911-03-16: ...\n-#  [Legal time in the Principality will be set, from the date of promulgation\n-#   of the present ordinance, to legal time in France....  Consequently, legal\n-#   time will be retarded by 9 minutes and 21 seconds.]\n-#\n-# Zone\tNAME\t\tSTDOFF\tRULES\tFORMAT\t[UNTIL]\n-Zone\tEurope\/Monaco\t0:29:32 -\tLMT\t1892 Jun  1\n-\t\t\t0:09:21\t-\tPMT\t1911 Mar 29 # Paris Mean Time\n-\t\t\t0:00\tFrance\tWE%sT\t1945 Sep 16  3:00\n-\t\t\t1:00\tFrance\tCE%sT\t1977\n-\t\t\t1:00\tEU\tCE%sT\n+# See Europe\/Paris.\n@@ -2143,76 +1969,1 @@\n-\n-# Howse writes that the Netherlands' railways used GMT between 1892 and 1940,\n-# but for other purposes the Netherlands used Amsterdam mean time.\n-\n-# However, Robert H. van Gent writes (2001-04-01):\n-# Howse's statement is only correct up to 1909. From 1909-05-01 (00:00:00\n-# Amsterdam mean time) onwards, the whole of the Netherlands (including\n-# the Dutch railways) was required by law to observe Amsterdam mean time\n-# (19 minutes 32.13 seconds ahead of GMT). This had already been the\n-# common practice (except for the railways) for many decades but it was\n-# not until 1909 when the Dutch government finally defined this by law.\n-# On 1937-07-01 this was changed to 20 minutes (exactly) ahead of GMT and\n-# was generally known as Dutch Time (\"Nederlandse Tijd\").\n-#\n-# (2001-04-08):\n-# 1892-05-01 was the date when the Dutch railways were by law required to\n-# observe GMT while the remainder of the Netherlands adhered to the common\n-# practice of following Amsterdam mean time.\n-#\n-# (2001-04-09):\n-# In 1835 the authorities of the province of North Holland requested the\n-# municipal authorities of the towns and cities in the province to observe\n-# Amsterdam mean time but I do not know in how many cases this request was\n-# actually followed.\n-#\n-# From 1852 onwards the Dutch telegraph offices were by law required to\n-# observe Amsterdam mean time. As the time signals from the observatory of\n-# Leiden were also distributed by the telegraph system, I assume that most\n-# places linked up with the telegraph (and railway) system automatically\n-# adopted Amsterdam mean time.\n-#\n-# Although the early Dutch railway companies initially observed a variety\n-# of times, most of them had adopted Amsterdam mean time by 1858 but it\n-# was not until 1866 when they were all required by law to observe\n-# Amsterdam mean time.\n-\n-# The data entries before 1945 are taken from\n-# https:\/\/www.staff.science.uu.nl\/~gent0113\/wettijd\/wettijd.htm\n-\n-# From Paul Eggert (2021-05-09):\n-# I invented the abbreviations AMT for Amsterdam Mean Time and NST for\n-# Netherlands Summer Time, used in the Netherlands from 1835 to 1937.\n-\n-# Rule\tNAME\tFROM\tTO\t-\tIN\tON\tAT\tSAVE\tLETTER\/S\n-Rule\tNeth\t1916\tonly\t-\tMay\t 1\t0:00\t1:00\tNST\t# Netherlands Summer Time\n-Rule\tNeth\t1916\tonly\t-\tOct\t 1\t0:00\t0\tAMT\t# Amsterdam Mean Time\n-Rule\tNeth\t1917\tonly\t-\tApr\t16\t2:00s\t1:00\tNST\n-Rule\tNeth\t1917\tonly\t-\tSep\t17\t2:00s\t0\tAMT\n-Rule\tNeth\t1918\t1921\t-\tApr\tMon>=1\t2:00s\t1:00\tNST\n-Rule\tNeth\t1918\t1921\t-\tSep\tlastMon\t2:00s\t0\tAMT\n-Rule\tNeth\t1922\tonly\t-\tMar\tlastSun\t2:00s\t1:00\tNST\n-Rule\tNeth\t1922\t1936\t-\tOct\tSun>=2\t2:00s\t0\tAMT\n-Rule\tNeth\t1923\tonly\t-\tJun\tFri>=1\t2:00s\t1:00\tNST\n-Rule\tNeth\t1924\tonly\t-\tMar\tlastSun\t2:00s\t1:00\tNST\n-Rule\tNeth\t1925\tonly\t-\tJun\tFri>=1\t2:00s\t1:00\tNST\n-# From 1926 through 1939 DST began 05-15, except that it was delayed by a week\n-# in years when 05-15 fell in the Pentecost weekend.\n-Rule\tNeth\t1926\t1931\t-\tMay\t15\t2:00s\t1:00\tNST\n-Rule\tNeth\t1932\tonly\t-\tMay\t22\t2:00s\t1:00\tNST\n-Rule\tNeth\t1933\t1936\t-\tMay\t15\t2:00s\t1:00\tNST\n-Rule\tNeth\t1937\tonly\t-\tMay\t22\t2:00s\t1:00\tNST\n-Rule\tNeth\t1937\tonly\t-\tJul\t 1\t0:00\t1:00\tS\n-Rule\tNeth\t1937\t1939\t-\tOct\tSun>=2\t2:00s\t0\t-\n-Rule\tNeth\t1938\t1939\t-\tMay\t15\t2:00s\t1:00\tS\n-Rule\tNeth\t1945\tonly\t-\tApr\t 2\t2:00s\t1:00\tS\n-Rule\tNeth\t1945\tonly\t-\tSep\t16\t2:00s\t0\t-\n-#\n-# Amsterdam Mean Time was +00:19:32.13, but the .13 is omitted\n-# below because the current format requires STDOFF to be an integer.\n-# Zone\tNAME\t\tSTDOFF\tRULES\tFORMAT\t[UNTIL]\n-Zone Europe\/Amsterdam\t0:19:32 -\tLMT\t1835\n-\t\t\t0:19:32\tNeth\t%s\t1937 Jul  1\n-\t\t\t0:20\tNeth +0020\/+0120 1940 May 16  0:00\n-\t\t\t1:00\tC-Eur\tCE%sT\t1945 Apr  2  2:00\n-\t\t\t1:00\tNeth\tCE%sT\t1977\n-\t\t\t1:00\tEU\tCE%sT\n+# See Europe\/Brussels.\n@@ -2221,16 +1972,1 @@\n-# http:\/\/met.no\/met\/met_lex\/q_u\/sommertid.html (2004-01) agrees with Shanks &\n-# Pottenger.\n-# Rule\tNAME\tFROM\tTO\t-\tIN\tON\tAT\tSAVE\tLETTER\/S\n-Rule\tNorway\t1916\tonly\t-\tMay\t22\t1:00\t1:00\tS\n-Rule\tNorway\t1916\tonly\t-\tSep\t30\t0:00\t0\t-\n-Rule\tNorway\t1945\tonly\t-\tApr\t 2\t2:00s\t1:00\tS\n-Rule\tNorway\t1945\tonly\t-\tOct\t 1\t2:00s\t0\t-\n-Rule\tNorway\t1959\t1964\t-\tMar\tSun>=15\t2:00s\t1:00\tS\n-Rule\tNorway\t1959\t1965\t-\tSep\tSun>=15\t2:00s\t0\t-\n-Rule\tNorway\t1965\tonly\t-\tApr\t25\t2:00s\t1:00\tS\n-# Zone\tNAME\t\tSTDOFF\tRULES\tFORMAT\t[UNTIL]\n-Zone\tEurope\/Oslo\t0:43:00 -\tLMT\t1895 Jan  1\n-\t\t\t1:00\tNorway\tCE%sT\t1940 Aug 10 23:00\n-\t\t\t1:00\tC-Eur\tCE%sT\t1945 Apr  2  2:00\n-\t\t\t1:00\tNorway\tCE%sT\t1980\n-\t\t\t1:00\tEU\tCE%sT\n+# See Europe\/Berlin.\n@@ -2283,1 +2019,1 @@\n-# All these events predate our cutoff date of 1970, so use Europe\/Oslo\n+# All these events predate our cutoff date of 1970, so use Europe\/Berlin\n@@ -2285,1 +2021,1 @@\n-Link\tEurope\/Oslo\tArctic\/Longyearbyen\n+\n@@ -2339,1 +2075,0 @@\n-# Round the old offset to -0:36:45.  This agrees with Willett....\n@@ -2426,0 +2161,1 @@\n+\t\t#STDOFF\t-0:36:44.68\n@@ -2434,1 +2170,0 @@\n-# This Zone can be simplified once we assume zic %z.\n@@ -2437,0 +2172,5 @@\n+# Vanguard section, for zic and other parsers that support %z.\n+#\t\t\t-2:00\tPort\t%z\t1966 Apr  3  2:00\n+#\t\t\t-1:00\tPort\t%z\t1983 Sep 25  1:00s\n+#\t\t\t-1:00\tW-Eur\t%z\t1992 Sep 27  1:00s\n+# Rearguard section, for parsers lacking %z; see ziguard.awk.\n@@ -2448,0 +2188,1 @@\n+# End of rearguard section.\n@@ -2450,1 +2191,0 @@\n-# This Zone can be simplified once we assume zic %z.\n@@ -2453,0 +2193,3 @@\n+# Vanguard section, for zic and other parsers that support %z.\n+#\t\t\t-1:00\tPort\t%z\t1966 Apr  3  2:00\n+# Rearguard section, for parsers lacking %z; see ziguard.awk.\n@@ -2462,0 +2205,1 @@\n+# End of rearguard section.\n@@ -2880,3 +2624,3 @@\n-# From Paul Eggert (2006-03-22):\n-# The _Economist_ (1994-05-28, p 45) reports that central Crimea switched\n-# from Kiev to Moscow time sometime after the January 1994 elections.\n+# From Paul Eggert (2022-07-21):\n+# The _Economist_ (1994-05-28, p 45) reported that central Crimea switched\n+# from Kyiv to Moscow time sometime after the January 1994 elections.\n@@ -2886,1 +2630,1 @@\n-# changed in May.\n+# changed in May.  This change evidently didn't last long; see below.\n@@ -2888,2 +2632,2 @@\n-# From IATA SSIM (1994\/1997), which also says that Kerch is still like Kiev.\n-\t\t\t 3:00\tE-Eur\tMSK\/MSD\t1996 Mar 31  0:00s\n+# From IATA SSIM (1994\/1997), which also said that Kerch is still like Kyiv.\n+\t\t\t 3:00\tC-Eur\tMSK\/MSD\t1996 Mar 31  0:00s\n@@ -2891,1 +2635,1 @@\n-# IATA SSIM (1997-09) says Crimea switched to EET\/EEST.\n+# IATA SSIM (1997-09) said Crimea switched to EET\/EEST.\n@@ -2893,1 +2637,0 @@\n-\t\t\t 3:00\tRussia\tMSK\/MSD\t1997\n@@ -3062,1 +2805,1 @@\n-# Milne says Yekaterinburg was 4:02:32.9; round to nearest.\n+# Milne says Yekaterinburg was 4:02:32.9.\n@@ -3067,0 +2810,1 @@\n+\t\t#STDOFF\t 4:02:32.9\n@@ -3378,2 +3122,2 @@\n-# From Arthur David Olson (2012-05-09):\n-# Tomponskij and Ust'-Majskij switched from Vladivostok time to Yakutsk time\n+# From Arthur David Olson (2022-03-21):\n+# Tomponsky and Ust-Maysky switched from Vladivostok time to Yakutsk time\n@@ -3504,2 +3248,2 @@\n-# From Arthur David Olson (2012-05-09):\n-# Ojmyakonskij [and the Kuril Islands] switched from\n+# From Arthur David Olson (2022-03-21):\n+# Oymyakonsky and the Kuril Islands switched from\n@@ -3579,1 +3323,1 @@\n-Link Europe\/Prague Europe\/Bratislava\n+# See Europe\/Prague.\n@@ -3668,1 +3412,1 @@\n-Zone\tEurope\/Madrid\t-0:14:44 -\tLMT\t1900 Dec 31 23:45:16\n+Zone\tEurope\/Madrid\t-0:14:44 -\tLMT\t1901 Jan  1  0:00u\n@@ -3690,55 +3434,1 @@\n-\n-# From Ivan Nilsson (2001-04-13), superseding Shanks & Pottenger:\n-#\n-# The law \"Svensk författningssamling 1878, no 14\" about standard time in 1879:\n-# From the beginning of 1879 (that is 01-01 00:00) the time for all\n-# places in the country is \"the mean solar time for the meridian at\n-# three degrees, or twelve minutes of time, to the west of the\n-# meridian of the Observatory of Stockholm\".  The law is dated 1878-05-31.\n-#\n-# The observatory at that time had the meridian 18° 03' 30\"\n-# eastern longitude = 01:12:14 in time.  Less 12 minutes gives the\n-# national standard time as 01:00:14 ahead of GMT....\n-#\n-# About the beginning of CET in Sweden. The lawtext (\"Svensk\n-# författningssamling 1899, no 44\") states, that \"from the beginning\n-# of 1900... ... the same as the mean solar time for the meridian at\n-# the distance of one hour of time from the meridian of the English\n-# observatory at Greenwich, or at 12 minutes 14 seconds to the west\n-# from the meridian of the Observatory of Stockholm\". The law is dated\n-# 1899-06-16.  In short: At 1900-01-01 00:00:00 the new standard time\n-# in Sweden is 01:00:00 ahead of GMT.\n-#\n-# 1916: The lawtext (\"Svensk författningssamling 1916, no 124\") states\n-# that \"1916-05-15 is considered to begin one hour earlier\". It is\n-# pretty obvious that at 05-14 23:00 the clocks are set to 05-15 00:00....\n-# Further the law says, that \"1916-09-30 is considered to end one hour later\".\n-#\n-# The laws regulating [DST] are available on the site of the Swedish\n-# Parliament beginning with 1985 - the laws regulating 1980\/1984 are\n-# not available on the site (to my knowledge they are only available\n-# in Swedish): <http:\/\/www.riksdagen.se\/english\/work\/sfst.asp> (type\n-# \"sommartid\" without the quotes in the field \"Fritext\" and then click\n-# the Sök-button).\n-#\n-# (2001-05-13):\n-#\n-# I have now found a newspaper stating that at 1916-10-01 01:00\n-# summertime the church-clocks etc were set back one hour to show\n-# 1916-10-01 00:00 standard time.  The article also reports that some\n-# people thought the switch to standard time would take place already\n-# at 1916-10-01 00:00 summer time, but they had to wait for another\n-# hour before the event took place.\n-#\n-# Source: The newspaper \"Dagens Nyheter\", 1916-10-01, page 7 upper left.\n-\n-# An extra-special abbreviation style is SET for Swedish Time (svensk\n-# normaltid) 1879-1899, 3° west of the Stockholm Observatory.\n-\n-# Zone\tNAME\t\tSTDOFF\tRULES\tFORMAT\t[UNTIL]\n-Zone Europe\/Stockholm\t1:12:12 -\tLMT\t1879 Jan  1\n-\t\t\t1:00:14\t-\tSET\t1900 Jan  1 # Swedish Time\n-\t\t\t1:00\t-\tCET\t1916 May 14 23:00\n-\t\t\t1:00\t1:00\tCEST\t1916 Oct  1  1:00\n-\t\t\t1:00\t-\tCET\t1980\n-\t\t\t1:00\tEU\tCE%sT\n+# See Europe\/Berlin.\n@@ -3838,0 +3528,13 @@\n+# From Tobias Conradi (2011-09-12):\n+# Büsingen <http:\/\/www.buesingen.de>, surrounded by the Swiss canton\n+# Schaffhausen, did not start observing DST in 1980 as the rest of DE\n+# (West Germany at that time) and DD (East Germany at that time) did.\n+# DD merged into DE, the area is currently covered by code DE in ISO 3166-1,\n+# which in turn is covered by the zone Europe\/Berlin.\n+#\n+# Source for the time in Büsingen 1980:\n+# http:\/\/www.srf.ch\/player\/video?id=c012c029-03b7-4c2b-9164-aa5902cd58d3\n+#\n+# From Arthur David Olson (2012-03-03):\n+# Büsingen and Zurich have shared clocks since 1970.\n+\n@@ -3846,0 +3549,3 @@\n+Link Europe\/Zurich Europe\/Busingen\n+Link Europe\/Zurich Europe\/Vaduz\n+\n@@ -4054,1 +3760,1 @@\n-# From Alois Triendl (2014-03-01):\n+# From Alois Treindl (2014-03-01):\n@@ -4114,1 +3820,1 @@\n-# From Vladimir in Moscow via Alois Treindl re Kiev time 1991\/2 (2014-02-28):\n+# From Vladimir in Moscow via Alois Treindl re Kyiv time 1991\/2 (2014-02-28):\n@@ -4142,1 +3848,1 @@\n-# From Paul Eggert (2018-10-03):\n+# From Paul Eggert (2022-04-12):\n@@ -4144,10 +3850,10 @@\n-# For example, tzdb uses Europe\/Kiev, as \"Kiev\" is the most common spelling in\n-# English for Ukraine's capital, even though it is certainly wrong as a\n-# transliteration of the Ukrainian \"Київ\".  This is similar to tzdb's use of\n-# Europe\/Prague, which is certainly wrong as a transliteration of the Czech\n-# \"Praha\".  (\"Kiev\" came from old Slavic via Russian to English, and \"Prague\"\n-# came from old Slavic via French to English, so the two cases have something\n-# in common.)  Admittedly English-language spelling of Ukrainian names is\n-# controversial, and some day \"Kyiv\" may become substantially more popular in\n-# English; in the meantime, stick with the traditional English \"Kiev\" as that\n-# means less disruption for our users.\n+# In particular, tzdb's name Europe\/Kyiv uses the most common spelling in\n+# English for Ukraine's capital.  Although tzdb's former name was Europe\/Kiev,\n+# \"Kyiv\" is now more common due to widespread reporting of the current conflict.\n+# Conversely, tzdb continues to use the names Europe\/Uzhgorod and\n+# Europe\/Zaporozhye; this is similar to tzdb's use of Europe\/Prague, which is\n+# certainly wrong as a transliteration of the Czech \"Praha\".\n+# English-language spelling of Ukrainian names is in flux, and\n+# some day \"Uzhhorod\" or \"Zaporizhzhia\" may become substantially more\n+# common in English; in the meantime, do not change these\n+# English spellings as that means less disruption for our users.\n@@ -4156,3 +3862,3 @@\n-# This represents most of Ukraine.  See above for the spelling of \"Kiev\".\n-Zone Europe\/Kiev\t2:02:04 -\tLMT\t1880\n-\t\t\t2:02:04\t-\tKMT\t1924 May  2 # Kiev Mean Time\n+# This represents most of Ukraine.  See above for the spelling of \"Kyiv\".\n+Zone Europe\/Kyiv\t2:02:04 -\tLMT\t1880\n+\t\t\t2:02:04\t-\tKMT\t1924 May  2 # Kyiv Mean Time\n@@ -4181,1 +3887,1 @@\n-# \"Zaporizhia\" is the transliteration of the Ukrainian name, but\n+# \"Zaporizhzhia\" is the transliteration of the Ukrainian name, but\n","filename":"src\/java.base\/share\/data\/tzdata\/europe","additions":90,"deletions":384,"binary":false,"changes":474,"status":"modified"},{"patch":"@@ -98,1 +98,1 @@\n-#Expires 2022\tDec\t28\t00:00:00\n+#Expires 2023\tJun\t28\t00:00:00\n@@ -102,1 +102,1 @@\n-#expires 1672185600 (2022-12-28 00:00:00 UTC)\n+#expires 1687910400 (2023-06-28 00:00:00 UTC)\n@@ -104,2 +104,2 @@\n-#\tUpdated through IERS Bulletin C63\n-#\tFile expires on:  28 December 2022\n+#\tUpdated through IERS Bulletin C64\n+#\tFile expires on:  28 June 2023\n","filename":"src\/java.base\/share\/data\/tzdata\/leapseconds","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -370,2 +370,1 @@\n-# Eastern time (i.e., -4:56:01.6) just before the 1883 switch.  Round to the\n-# nearest second.\n+# Eastern time (i.e., -4:56:01.6) just before the 1883 switch.\n@@ -380,1 +379,2 @@\n-Zone America\/New_York\t-4:56:02 -\tLMT\t1883 Nov 18 12:03:58\n+\t\t#STDOFF\t-4:56:01.6\n+Zone America\/New_York\t-4:56:02 -\tLMT\t1883 Nov 18 17:00u\n@@ -2844,1 +2844,1 @@\n-# For 1899 Milne gives -3:58:29.2; round that.\n+# For 1899 Milne gives -3:58:29.2.\n@@ -2888,0 +2888,1 @@\n+\t\t#STDOFF\t-3:58:29.2\n@@ -2948,1 +2949,1 @@\n-# From Paul Eggert (2020-11-24):\n+# From Paul Eggert (2022-07-27):\n@@ -2951,1 +2952,1 @@\n-# Daylight Saving Act, 1917 cited below.  Round that to the nearest second.\n+# Daylight Saving Act, 1917 cited below.\n@@ -3046,0 +3047,1 @@\n+\t\t#STDOFF\t-4:19:18.3\n@@ -3060,1 +3062,1 @@\n-# Milne gives -5:36:13.3 as San José mean time; round to nearest.\n+# Milne gives -5:36:13.3 as San José mean time.\n@@ -3072,0 +3074,1 @@\n+\t\t#STDOFF\t-5:36:13.3\n@@ -3494,1 +3497,1 @@\n-# island\".  Go with Milne.  Round to the nearest second as required by zic.\n+# island\".  Go with Milne.\n@@ -3507,0 +3510,1 @@\n+\t\t#STDOFF\t-5:07:10.41\n@@ -3704,0 +3708,1 @@\n+\t\t#STDOFF\t-5:07:10.41\n","filename":"src\/java.base\/share\/data\/tzdata\/northamerica","additions":13,"deletions":8,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -426,0 +426,1 @@\n+\t\t#STDOFF\t-4:16:48.25\n@@ -443,0 +444,1 @@\n+\t\t#STDOFF\t       -4:16:48.25\n@@ -455,0 +457,1 @@\n+\t\t#STDOFF\t-4:16:48.25\n@@ -467,0 +470,1 @@\n+\t\t#STDOFF\t-4:16:48.25\n@@ -480,0 +484,1 @@\n+\t\t#STDOFF\t-4:16:48.25\n@@ -494,0 +499,1 @@\n+\t\t#STDOFF\t-4:16:48.25\n@@ -508,0 +514,1 @@\n+\t\t#STDOFF\t-4:16:48.25\n@@ -523,0 +530,1 @@\n+\t\t#STDOFF\t-4:16:48.25\n@@ -537,0 +545,1 @@\n+\t\t#STDOFF\t-4:16:48.25\n@@ -559,0 +568,1 @@\n+\t\t#STDOFF\t-4:16:48.25\n@@ -577,0 +587,1 @@\n+\t\t#STDOFF\t-4:16:48.25\n@@ -589,0 +600,1 @@\n+\t\t#STDOFF\t-4:16:48.25\n@@ -671,1 +683,1 @@\n-# modern Brazilian eletronic voting machines which, apparently, can't deal\n+# modern Brazilian ... voting machines which, apparently, can't deal\n@@ -1167,1 +1179,1 @@\n-# From Tim Parenti (2022-03-15):\n+# From Tim Parenti (2022-07-06):\n@@ -1185,1 +1197,8 @@\n-# seconds\".\n+# seconds\".  Although this law specified the new Summer Time to start on 1\n+# September each year, a special \"transitional article\" started it a few days\n+# early, as soon as the law took effect.  As the law was to take force \"from\n+# the date of its publication in the 'Diario Oficial', which happened the\n+# following day, presume the change took place in Santiago and its environs\n+# from 24:00 -03 to 23:00 -04 on Wednesday 1946-08-28.  Although this was a\n+# no-op for wall clocks in the north and south of the country, put their formal\n+# start to DST an hour later when they reached 24:00 -04.\n@@ -1305,5 +1324,13 @@\n-# From Paul Eggert (2019-09-01):\n-# The above says the Magallanes exception expires 2022-04-02 at 24:00,\n-# so in theory, they will revert to -04\/-03 after that.\n-# For now, assume that they will not revert,\n-# since they have extended the expiration date once already.\n+\n+# From Juan Correa (2022-04-02):\n+# I found there was a decree published last Thursday that will keep\n+# Magallanes region to UTC -3 \"indefinitely\". The decree is available at\n+# https:\/\/www.diariooficial.interior.gob.cl\/publicaciones\/2022\/03\/31\/43217-B\/01\/2108910.pdf\n+\n+# From Juan Correa (2022-08-09):\n+# the Internal Affairs Ministry (Ministerio del Interior) informed DST\n+# for America\/Santiago will start on midnight of September 11th;\n+# and will end on April 1st, 2023. Magallanes region (America\/Punta_Arenas)\n+# will keep UTC -3 \"indefinitely\"...  This is because on September 4th\n+# we will have a voting whether to approve a new Constitution....\n+# https:\/\/www.interior.gob.cl\/noticias\/2022\/08\/09\/comunicado-el-proximo-sabado-10-de-septiembre-los-relojes-se-deben-adelantar-una-hora\/\n@@ -1347,1 +1374,3 @@\n-Rule\tChile\t2019\tmax\t-\tSep\tSun>=2\t4:00u\t1:00\t-\n+Rule\tChile\t2019\t2021\t-\tSep\tSun>=2\t4:00u\t1:00\t-\n+Rule\tChile\t2022\tonly\t-\tSep\tSun>=9\t4:00u\t1:00\t-\n+Rule\tChile\t2023\tmax\t-\tSep\tSun>=2\t4:00u\t1:00\t-\n@@ -1360,3 +1389,3 @@\n-\t\t\t-4:00\t-\t-04\t1946 Jul 15\n-\t\t\t-4:00\t1:00\t-03\t1946 Sep  1 # central Chile\n-\t\t\t-4:00\t-\t-04\t1947 Apr  1\n+\t\t\t-4:00\t-\t-04\t1946 Jul 14 24:00\n+\t\t\t-4:00\t1:00\t-03\t1946 Aug 28 24:00 # central CL\n+\t\t\t-5:00\t1:00\t-04\t1947 Mar 31 24:00\n@@ -1374,1 +1403,2 @@\n-\t\t\t-4:00\t-\t-04\t1947 Apr  1\n+\t\t\t-4:00\t-\t-04\t1946 Aug 28 24:00\n+\t\t\t-5:00\t1:00\t-04\t1947 Mar 31 24:00\n@@ -1408,1 +1438,1 @@\n-# Milne gives 4:56:16.4 for Bogotá time in 1899; round to nearest.  He writes,\n+# Milne gives 4:56:16.4 for Bogotá time in 1899.  He writes,\n@@ -1415,0 +1445,1 @@\n+\t\t#STDOFF\t-4:56:16.4\n","filename":"src\/java.base\/share\/data\/tzdata\/southamerica","additions":45,"deletions":14,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -156,1 +156,1 @@\n-CA\t+5946-12014\tAmerica\/Dawson_Creek\tMST - BC (Dawson Cr, Ft St John)\n+CA\t+5546-12014\tAmerica\/Dawson_Creek\tMST - BC (Dawson Cr, Ft St John)\n@@ -426,1 +426,1 @@\n-UA\t+5026+03031\tEurope\/Kiev\tUkraine (most areas)\n+UA\t+5026+03031\tEurope\/Kyiv\tUkraine (most areas)\n","filename":"src\/java.base\/share\/data\/tzdata\/zone.tab","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -411,6 +411,5 @@\n-     * followed by modifier fields. These are ignored here. *\/\n-    temp_tz = strchr(tz, ',');\n-    tz_len = (temp_tz == NULL) ? strlen(tz) : temp_tz - tz;\n-    tz_buf = (char *)malloc(tz_len + 1);\n-    memcpy(tz_buf, tz, tz_len);\n-    tz_buf[tz_len] = 0;\n+     * followed by modifier fields until early AIX6.1.\n+     * This restriction has been removed from AIX7. *\/\n+\n+    tz_buf = strdup(tz);\n+    tz_len = strlen(tz_buf);\n@@ -585,0 +584,10 @@\n+#if defined(_AIX)\n+    \/\/ strftime() with \"%z\" does not return ISO 8601 format by AIX default.\n+    \/\/ XPG_SUS_ENV=ON environment variable is required.\n+    \/\/ But Hotspot does not support XPG_SUS_ENV=ON.\n+    \/\/ Ignore daylight saving settings to calculate current time difference\n+    localtm.tm_isdst = 0;\n+    int gmt_off = (int)(difftime(mktime(&localtm), mktime(&gmt)) \/ 60.0);\n+    sprintf(buf, (const char *)\"GMT%c%02.2d:%02.2d\",\n+            gmt_off < 0 ? '-' : '+' , abs(gmt_off \/ 60), gmt_off % 60);\n+#else\n@@ -591,0 +600,1 @@\n+#endif\n","filename":"src\/java.base\/unix\/native\/libjava\/TimeZone_md.c","additions":16,"deletions":6,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -93,0 +93,2 @@\n+        \"alt UP\", DefaultEditorKit.beginLineUpAction,\n+        \"alt DOWN\", DefaultEditorKit.endLineDownAction,\n","filename":"src\/java.desktop\/macosx\/classes\/com\/apple\/laf\/AquaKeyBindings.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -299,8 +299,0 @@\n-    {\n-        NSAlternateKeyMask,\n-        0,\n-        61,\n-        java_awt_event_InputEvent_ALT_DOWN_MASK | java_awt_event_InputEvent_ALT_GRAPH_DOWN_MASK,\n-        java_awt_event_InputEvent_ALT_MASK | java_awt_event_InputEvent_ALT_GRAPH_MASK,\n-        java_awt_event_KeyEvent_VK_ALT | java_awt_event_KeyEvent_VK_ALT_GRAPH\n-    },\n@@ -320,1 +312,0 @@\n-static BOOL leftAltKeyPressed;\n@@ -551,1 +542,0 @@\n-                leftAltKeyPressed = YES;\n@@ -556,1 +546,0 @@\n-                leftAltKeyPressed = NO;\n@@ -560,2 +549,2 @@\n-            java_awt_event_KeyEvent_KEY_PRESSED :\n-            java_awt_event_KeyEvent_KEY_RELEASED;\n+                java_awt_event_KeyEvent_KEY_PRESSED :\n+                java_awt_event_KeyEvent_KEY_RELEASED;\n@@ -581,3 +570,0 @@\n-            if (cur->nsMask == NSAlternateKeyMask && leftAltKeyPressed) {\n-                    break; \/\/since right alt key struct is defined last, break out of the loop                }\n-            }\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/AWTEvent.m","additions":2,"deletions":16,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -1278,2 +1278,4 @@\n-                ENGINE.paintFlatBox(g, context, id, gtkState, ShadowType.NONE,\n-                        \"cell_odd\", x, y, w, h, ColorType.TEXT_BACKGROUND);\n+                if (context.getComponent().isOpaque()) {\n+                    ENGINE.paintFlatBox(g, context, id, gtkState, ShadowType.NONE,\n+                            \"cell_odd\", x, y, w, h, ColorType.TEXT_BACKGROUND);\n+                }\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/java\/swing\/plaf\/gtk\/GTKPainter.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -645,0 +645,18 @@\n+    \/**\n+     * Name of the {@code Action} for moving the caret\n+     * to the beginning of the current line or up to the\n+     * beginning of the previous line if the caret is\n+     * already at the beginning of the line.\n+     * @see #getActions\n+     *\/\n+    public static final String beginLineUpAction = \"caret-begin-line-and-up\";\n+\n+    \/**\n+     * Name of the {@code Action} for moving the caret\n+     * to the end of the current line or down to the\n+     * end of the next line if the caret is already\n+     * at the end of the line.\n+     * @see #getActions\n+     *\/\n+    public static final String endLineDownAction = \"caret-end-line-and-down\";\n+\n@@ -801,0 +819,2 @@\n+        new BeginLineUpAction(beginLineUpAction, false,\n+                    SwingConstants.NORTH),\n@@ -802,0 +822,2 @@\n+        new EndLineDownAction(endLineDownAction, false,\n+                    SwingConstants.SOUTH),\n@@ -2043,0 +2065,210 @@\n+    \/*\n+     * Position the caret to the end of the line and down one line.\n+     * @see DefaultEditorKit#endLineAction\n+     * @see DefaultEditorKit#selectEndLineAction\n+     * @see DefaultEditorKit#getActions\n+     *\/\n+    @SuppressWarnings(\"serial\") \/\/ Superclass is not serializable across versions\n+    static class EndLineDownAction extends TextAction {\n+\n+        \/**\n+         * Create this action with the appropriate identifier.\n+         * @param nm  the name of the action, Action.NAME.\n+         * @param select whether to extend the selection when\n+         *               changing the caret position.\n+         * @param direction  the direction to move the caret\n+         *\/\n+        EndLineDownAction(String nm, boolean select, int direction) {\n+            super(nm);\n+            this.select = select;\n+            this.direction = direction;\n+            firstTime = true;\n+        }\n+\n+        \/** The operation to perform when this action is triggered. *\/\n+        @SuppressWarnings(\"deprecation\")\n+        public void actionPerformed(ActionEvent e) {\n+            JTextComponent target = getTextComponent(e);\n+            if (target != null) {\n+                try {\n+                    int offs = target.getCaretPosition();\n+                    int endOffs = Utilities.getRowEnd(target, offs);\n+                    if (offs != endOffs) {\n+                        if (select) {\n+                            target.moveCaretPosition(endOffs);\n+                        } else {\n+                            target.setCaretPosition(endOffs);\n+                        }\n+                    } else {\n+                        Caret caret = target.getCaret();\n+                        DefaultCaret bidiCaret = (caret instanceof DefaultCaret) ?\n+                                (DefaultCaret) caret : null;\n+                        int dot = caret.getDot();\n+                        Position.Bias[] bias = new Position.Bias[1];\n+                        Point magicPosition = caret.getMagicCaretPosition();\n+\n+                        if (magicPosition == null &&\n+                                (direction == SwingConstants.NORTH ||\n+                                 direction == SwingConstants.SOUTH)) {\n+                            Rectangle r = (bidiCaret != null) ?\n+                                    target.getUI().modelToView(target, dot,\n+                                            bidiCaret.getDotBias()) :\n+                                    target.modelToView(dot);\n+                            magicPosition = new Point(r.x, r.y);\n+                        }\n+                        NavigationFilter filter = target.getNavigationFilter();\n+\n+                        if (filter != null) {\n+                            dot = filter.getNextVisualPositionFrom\n+                                    (target, dot, (bidiCaret != null) ?\n+                                            bidiCaret.getDotBias() :\n+                                            Position.Bias.Forward, direction, bias);\n+                        } else {\n+                            dot = target.getUI().getNextVisualPositionFrom\n+                                    (target, dot, (bidiCaret != null) ?\n+                                            bidiCaret.getDotBias() :\n+                                            Position.Bias.Forward, direction, bias);\n+                        }\n+                        if (bias[0] == null) {\n+                            bias[0] = Position.Bias.Forward;\n+                        }\n+                        if (bidiCaret != null) {\n+                            if (select) {\n+                                bidiCaret.moveDot(dot, bias[0]);\n+                            } else {\n+                                bidiCaret.setDot(dot, bias[0]);\n+                            }\n+                        } else {\n+                            if (select) {\n+                                caret.moveDot(dot);\n+                            } else {\n+                                caret.setDot(dot);\n+                            }\n+                        }\n+                        if (magicPosition != null &&\n+                                (direction == SwingConstants.NORTH ||\n+                                        direction == SwingConstants.SOUTH)) {\n+                            target.getCaret().setMagicCaretPosition(magicPosition);\n+                        }\n+                        offs = target.getCaretPosition();\n+                        endOffs = Utilities.getRowEnd(target, offs);\n+                        if (select) {\n+                            target.moveCaretPosition(endOffs);\n+                        } else {\n+                            target.setCaretPosition(endOffs);\n+                        }\n+                    }\n+                } catch (BadLocationException ex) {\n+                }\n+            }\n+        }\n+\n+        private boolean select;\n+        private int direction;\n+        private boolean firstTime;\n+    }\n+\n+    \/*\n+     * Position the caret to the start of the line and up one line.\n+     * @see DefaultEditorKit#beginLineAction\n+     * @see DefaultEditorKit#selectBeginLineAction\n+     * @see DefaultEditorKit#getActions\n+     *\/\n+    @SuppressWarnings(\"serial\") \/\/ Superclass is not serializable across versions\n+    static class BeginLineUpAction extends TextAction {\n+\n+        \/**\n+         * Create this action with the appropriate identifier.\n+         * @param nm  the name of the action, Action.NAME.\n+         * @param select whether to extend the selection when\n+         *               changing the caret position.\n+         * @param direction  the direction to move the caret\n+         *\/\n+        BeginLineUpAction(String nm, boolean select, int direction) {\n+            super(nm);\n+            this.select = select;\n+            this.direction = direction;\n+        }\n+\n+        \/** The operation to perform when this action is triggered. *\/\n+        @SuppressWarnings(\"deprecation\")\n+        public void actionPerformed(ActionEvent e) {\n+            JTextComponent target = getTextComponent(e);\n+            if (target != null) {\n+                try {\n+                    int offs = target.getCaretPosition();\n+                    int begOffs = Utilities.getRowStart(target, offs);\n+                    if (offs != begOffs) {\n+                        if (select) {\n+                            target.moveCaretPosition(begOffs);\n+                        } else {\n+                            target.setCaretPosition(begOffs);\n+                        }\n+                    } else {\n+                        if (select) {\n+                            target.moveCaretPosition(begOffs);\n+                        } else {\n+                            target.setCaretPosition(begOffs);\n+                        }\n+                        Caret caret = target.getCaret();\n+                        DefaultCaret bidiCaret = (caret instanceof DefaultCaret) ?\n+                                (DefaultCaret) caret : null;\n+                        int dot = caret.getDot();\n+                        Position.Bias[] bias = new Position.Bias[1];\n+                        Point magicPosition = caret.getMagicCaretPosition();\n+\n+                        if (magicPosition == null &&\n+                                (direction == SwingConstants.NORTH ||\n+                                        direction == SwingConstants.SOUTH)) {\n+                            Rectangle r = (bidiCaret != null) ?\n+                                    target.getUI().modelToView(target, dot,\n+                                            bidiCaret.getDotBias()) :\n+                                    target.modelToView(dot);\n+                            magicPosition = new Point(r.x, r.y);\n+                        }\n+\n+                        NavigationFilter filter = target.getNavigationFilter();\n+\n+                        if (filter != null) {\n+                            dot = filter.getNextVisualPositionFrom\n+                                    (target, dot, (bidiCaret != null) ?\n+                                            bidiCaret.getDotBias() :\n+                                            Position.Bias.Forward, direction, bias);\n+                        } else {\n+                            dot = target.getUI().getNextVisualPositionFrom\n+                                    (target, dot, (bidiCaret != null) ?\n+                                            bidiCaret.getDotBias() :\n+                                            Position.Bias.Forward, direction, bias);\n+                        }\n+                        if (bias[0] == null) {\n+                            bias[0] = Position.Bias.Forward;\n+                        }\n+                        if (bidiCaret != null) {\n+                            if (select) {\n+                                bidiCaret.moveDot(dot, bias[0]);\n+                            } else {\n+                                bidiCaret.setDot(dot, bias[0]);\n+                            }\n+                        } else {\n+                            if (select) {\n+                                caret.moveDot(dot);\n+                            } else {\n+                                caret.setDot(dot);\n+                            }\n+                        }\n+                        if (magicPosition != null &&\n+                                (direction == SwingConstants.NORTH ||\n+                                        direction == SwingConstants.SOUTH)) {\n+                            target.getCaret().setMagicCaretPosition(magicPosition);\n+                        }\n+                    }\n+                } catch (BadLocationException ex) {\n+                }\n+            }\n+        }\n+\n+        private boolean select;\n+        private int direction;\n+        private boolean firstLine;\n+    }\n+\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/DefaultEditorKit.java","additions":232,"deletions":0,"binary":false,"changes":232,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,1 +51,0 @@\n-import sun.util.logging.PlatformLogger;\n@@ -293,16 +292,16 @@\n-        FileReader fr = null;\n-        try {\n-            if (fontsDotDir.canRead()) {\n-                fr = new FileReader(fontsDotDir);\n-                BufferedReader br = new BufferedReader(fr, 8192);\n-                StreamTokenizer st = new StreamTokenizer(br);\n-                st.eolIsSignificant(true);\n-                int ttype = st.nextToken();\n-                if (ttype == StreamTokenizer.TT_NUMBER) {\n-                    int numEntries = (int)st.nval;\n-                    ttype = st.nextToken();\n-                    if (ttype == StreamTokenizer.TT_EOL) {\n-                        st.resetSyntax();\n-                        st.wordChars(32, 127);\n-                        st.wordChars(128 + 32, 255);\n-                        st.whitespaceChars(0, 31);\n+        if (!fontsDotDir.canRead()) {\n+            return;\n+        }\n+        try (FileReader fr = new FileReader(fontsDotDir)) {\n+            BufferedReader br = new BufferedReader(fr, 8192);\n+            StreamTokenizer st = new StreamTokenizer(br);\n+            st.eolIsSignificant(true);\n+            int ttype = st.nextToken();\n+            if (ttype == StreamTokenizer.TT_NUMBER) {\n+                int numEntries = (int)st.nval;\n+                ttype = st.nextToken();\n+                if (ttype == StreamTokenizer.TT_EOL) {\n+                    st.resetSyntax();\n+                    st.wordChars(32, 127);\n+                    st.wordChars(128 + 32, 255);\n+                    st.whitespaceChars(0, 31);\n@@ -310,1 +309,21 @@\n-                        for (int i=0; i < numEntries; i++) {\n+                    for (int i=0; i < numEntries; i++) {\n+                        ttype = st.nextToken();\n+                        if (ttype == StreamTokenizer.TT_EOF) {\n+                            break;\n+                        }\n+                        if (ttype != StreamTokenizer.TT_WORD) {\n+                            break;\n+                        }\n+                        int breakPos = st.sval.indexOf(' ');\n+                        if (breakPos <= 0) {\n+                            \/* On TurboLinux 8.0 a fonts.dir file had\n+                             * a line with integer value \"24\" which\n+                             * appeared to be the number of remaining\n+                             * entries in the file. This didn't add to\n+                             * the value on the first line of the file.\n+                             * Seemed like XFree86 didn't like this line\n+                             * much either. It failed to parse the file.\n+                             * Ignore lines like this completely, and\n+                             * don't let them count as an entry.\n+                             *\/\n+                            numEntries++;\n@@ -312,4 +331,1 @@\n-                            if (ttype == StreamTokenizer.TT_EOF) {\n-                                break;\n-                            }\n-                            if (ttype != StreamTokenizer.TT_WORD) {\n+                            if (ttype != StreamTokenizer.TT_EOL) {\n@@ -318,17 +334,0 @@\n-                            int breakPos = st.sval.indexOf(' ');\n-                            if (breakPos <= 0) {\n-                                \/* On TurboLinux 8.0 a fonts.dir file had\n-                                 * a line with integer value \"24\" which\n-                                 * appeared to be the number of remaining\n-                                 * entries in the file. This didn't add to\n-                                 * the value on the first line of the file.\n-                                 * Seemed like XFree86 didn't like this line\n-                                 * much either. It failed to parse the file.\n-                                 * Ignore lines like this completely, and\n-                                 * don't let them count as an entry.\n-                                 *\/\n-                                numEntries++;\n-                                ttype = st.nextToken();\n-                                if (ttype != StreamTokenizer.TT_EOL) {\n-                                    break;\n-                                }\n@@ -336,1 +335,12 @@\n-                                continue;\n+                            continue;\n+                        }\n+                        if (st.sval.charAt(0) == '!') {\n+                            \/* TurboLinux 8.0 comment line: ignore.\n+                             * can't use st.commentChar('!') to just\n+                             * skip because this line mustn't count\n+                             * against numEntries.\n+                             *\/\n+                            numEntries++;\n+                            ttype = st.nextToken();\n+                            if (ttype != StreamTokenizer.TT_EOL) {\n+                                break;\n@@ -338,11 +348,11 @@\n-                            if (st.sval.charAt(0) == '!') {\n-                                \/* TurboLinux 8.0 comment line: ignore.\n-                                 * can't use st.commentChar('!') to just\n-                                 * skip because this line mustn't count\n-                                 * against numEntries.\n-                                 *\/\n-                                numEntries++;\n-                                ttype = st.nextToken();\n-                                if (ttype != StreamTokenizer.TT_EOL) {\n-                                    break;\n-                                }\n+                            continue;\n+                        }\n+                        String fileName = st.sval.substring(0, breakPos);\n+                        \/* TurboLinux 8.0 uses some additional syntax to\n+                         * indicate algorithmic styling values.\n+                         * Ignore ':' separated files at the beginning\n+                         * of the fileName\n+                         *\/\n+                        int lastColon = fileName.lastIndexOf(':');\n+                        if (lastColon > 0) {\n+                            if (lastColon+1 >= fileName.length()) {\n@@ -351,16 +361,5 @@\n-                            String fileName = st.sval.substring(0, breakPos);\n-                            \/* TurboLinux 8.0 uses some additional syntax to\n-                             * indicate algorithmic styling values.\n-                             * Ignore ':' separated files at the beginning\n-                             * of the fileName\n-                             *\/\n-                            int lastColon = fileName.lastIndexOf(':');\n-                            if (lastColon > 0) {\n-                                if (lastColon+1 >= fileName.length()) {\n-                                    continue;\n-                                }\n-                                fileName = fileName.substring(lastColon+1);\n-                            }\n-                            String fontPart = st.sval.substring(breakPos+1);\n-                            String fontID = specificFontIDForName(fontPart);\n-                            String sVal = fontNameMap.get(fontID);\n+                            fileName = fileName.substring(lastColon+1);\n+                        }\n+                        String fontPart = st.sval.substring(breakPos+1);\n+                        String fontID = specificFontIDForName(fontPart);\n+                        String sVal = fontNameMap.get(fontID);\n@@ -368,23 +367,18 @@\n-                            if (FontUtilities.debugFonts()) {\n-                                FontUtilities.logInfo(\"file=\" + fileName +\n-                                            \" xlfd=\" + fontPart);\n-                                FontUtilities.logInfo(\"fontID=\" + fontID +\n-                                            \" sVal=\" + sVal);\n-                            }\n-                            String fullPath = null;\n-                            try {\n-                                File file = new File(path,fileName);\n-                                \/* we may have a resolved symbolic link\n-                                 * this becomes important for an xlfd we\n-                                 * still need to know the location it was\n-                                 * found to update the X server font path\n-                                 * for use by AWT heavyweights - and when 2D\n-                                 * wants to use the native rasteriser.\n-                                 *\/\n-                                if (xFontDirsMap == null) {\n-                                    xFontDirsMap = new HashMap<>();\n-                                }\n-                                xFontDirsMap.put(fontID, path);\n-                                fullPath = file.getCanonicalPath();\n-                            } catch (IOException e) {\n-                                fullPath = path + File.separator + fileName;\n+                        if (FontUtilities.debugFonts()) {\n+                            FontUtilities.logInfo(\"file=\" + fileName +\n+                                        \" xlfd=\" + fontPart);\n+                            FontUtilities.logInfo(\"fontID=\" + fontID +\n+                                        \" sVal=\" + sVal);\n+                        }\n+                        String fullPath;\n+                        try {\n+                            File file = new File(path,fileName);\n+                            \/* we may have a resolved symbolic link\n+                             * this becomes important for an xlfd we\n+                             * still need to know the location it was\n+                             * found to update the X server font path\n+                             * for use by AWT heavyweights - and when 2D\n+                             * wants to use the native rasteriser.\n+                             *\/\n+                            if (xFontDirsMap == null) {\n+                                xFontDirsMap = new HashMap<>();\n@@ -392,1 +386,12 @@\n-                            Vector<String> xVal = xlfdMap.get(fullPath);\n+                            xFontDirsMap.put(fontID, path);\n+                            fullPath = file.getCanonicalPath();\n+                        } catch (IOException e) {\n+                            fullPath = path + File.separator + fileName;\n+                        }\n+                        Vector<String> xVal = xlfdMap.get(fullPath);\n+                        if (FontUtilities.debugFonts()) {\n+                            FontUtilities.logInfo(\"fullPath=\" + fullPath +\n+                                                  \" xVal=\" + xVal);\n+                        }\n+                        if ((xVal == null || !xVal.contains(fontPart)) &&\n+                            (sVal == null) || !sVal.startsWith(\"\/\")) {\n@@ -394,2 +399,2 @@\n-                                FontUtilities.logInfo(\"fullPath=\" + fullPath +\n-                                                      \" xVal=\" + xVal);\n+                                FontUtilities.logInfo(\"Map fontID:\"+fontID +\n+                                                      \"to file:\" + fullPath);\n@@ -397,12 +402,4 @@\n-                            if ((xVal == null || !xVal.contains(fontPart)) &&\n-                                (sVal == null) || !sVal.startsWith(\"\/\")) {\n-                                if (FontUtilities.debugFonts()) {\n-                                    FontUtilities.logInfo(\"Map fontID:\"+fontID +\n-                                                          \"to file:\" + fullPath);\n-                                }\n-                                fontNameMap.put(fontID, fullPath);\n-                                if (xVal == null) {\n-                                    xVal = new Vector<>();\n-                                    xlfdMap.put (fullPath, xVal);\n-                                }\n-                                xVal.add(fontPart);\n+                            fontNameMap.put(fontID, fullPath);\n+                            if (xVal == null) {\n+                                xVal = new Vector<>();\n+                                xlfdMap.put (fullPath, xVal);\n@@ -410,0 +407,2 @@\n+                            xVal.add(fontPart);\n+                        }\n@@ -411,4 +410,3 @@\n-                            ttype = st.nextToken();\n-                            if (ttype != StreamTokenizer.TT_EOL) {\n-                                break;\n-                            }\n+                        ttype = st.nextToken();\n+                        if (ttype != StreamTokenizer.TT_EOL) {\n+                            break;\n@@ -418,9 +416,0 @@\n-                fr.close();\n-            }\n-        } catch (IOException ioe1) {\n-        } finally {\n-            if (fr != null) {\n-                try {\n-                    fr.close();\n-                }  catch (IOException ioe2) {\n-                }\n@@ -428,0 +417,1 @@\n+        } catch (IOException ioe) {\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/X11FontManager.java","additions":109,"deletions":119,"binary":false,"changes":228,"status":"modified"},{"patch":"@@ -65,1 +65,1 @@\n-        J2dTraceLn1(J2D_TRACE_ERROR, \"D3D Error: \" ## msg ## \" res=%d\", res)\n+        J2dTraceLn1(J2D_TRACE_ERROR, \"D3D Error: \" msg \" res=%d\", res)\n@@ -90,1 +90,1 @@\n-        J2dTraceLn1(J2D_TRACE_VERBOSE, \"  \" ## #RES ## \"=0x%x\", (RES)); \\\n+        J2dTraceLn1(J2D_TRACE_VERBOSE, \"  \" #RES \"=0x%x\", (RES)); \\\n@@ -92,1 +92,1 @@\n-        J2dTraceLn(J2D_TRACE_VERBOSE, \"  \" ## #RES ## \"=NULL\"); \\\n+        J2dTraceLn(J2D_TRACE_VERBOSE, \"  \" #RES \"=NULL\"); \\\n@@ -117,1 +117,1 @@\n-        DebugPrintD3DError(res, \" \" ## #EXPR ## \" failed in \" ## __FILE__); \\\n+        DebugPrintD3DError(res, \" \" #EXPR \" failed in \" __FILE__); \\\n@@ -123,1 +123,1 @@\n-        DebugPrintD3DError((status), \" failed in \" ## __FILE__ ## \", return;\");\\\n+        DebugPrintD3DError((status), \" failed in \" __FILE__ \", return;\");\\\n","filename":"src\/java.desktop\/windows\/native\/libawt\/java2d\/d3d\/D3DPipeline.h","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-            fprintf(stderr, \"[SSPI:%ld] \"fmt\"\\n\", __LINE__, ##__VA_ARGS__); \\\n+            fprintf(stderr, \"[SSPI:%ld] \" fmt \"\\n\", __LINE__, ##__VA_ARGS__); \\\n","filename":"src\/java.security.jgss\/windows\/native\/libsspi_bridge\/sspi.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -168,0 +168,1 @@\n+    private final boolean sourceLauncher;\n@@ -217,0 +218,1 @@\n+        sourceLauncher = options.isSet(\"sourceLauncher\");\n@@ -1344,1 +1346,1 @@\n-        String incubatingModules = result.stream()\n+        String incubatingModules = filterAlreadyWarnedIncubatorModules(result.stream()\n@@ -1346,1 +1348,1 @@\n-                .map(msym -> msym.name.toString())\n+                .map(msym -> msym.name.toString()))\n@@ -1362,0 +1364,9 @@\n+        private Stream<String> filterAlreadyWarnedIncubatorModules(Stream<String> incubatingModules) {\n+            if (!sourceLauncher) return incubatingModules;\n+            Set<String> bootModules = ModuleLayer.boot()\n+                                                 .modules()\n+                                                 .stream()\n+                                                 .map(Module::getName)\n+                                                 .collect(Collectors.toSet());\n+            return incubatingModules.filter(module -> !bootModules.contains(module));\n+        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Modules.java","additions":13,"deletions":2,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -371,0 +371,1 @@\n+        javacOpts.add(\"-XDsourceLauncher\");\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/launcher\/Main.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -872,6 +872,4 @@\n-  \/\/ 1. the exception type = EXC_SOFTWARE\n-  \/\/ 2. codes[0] (which is the code) = EXC_SOFT_SIGNAL\n-  \/\/ 3. codes[1] (which is the sub-code) = SIGSTOP\n-  if (!(exception_type == EXC_SOFTWARE &&\n-        codes[0] == EXC_SOFT_SIGNAL    &&\n-        codes[num_codes -1] == SIGSTOP)) {\n+  \/\/ 1. the exception type = EXC_SOFTWARE (5)\n+  \/\/ 2. codes[0] (which is the code) = EXC_SOFT_SIGNAL (0x10003 \/ 65539)\n+  \/\/ 3. codes[1] (which is the sub-code) = SIGSTOP (17)\n+  if (exception_type != EXC_SOFTWARE || codes[0] != EXC_SOFT_SIGNAL) {\n@@ -884,1 +882,9 @@\n-  return KERN_SUCCESS;\n+  int sig = codes[num_codes -1];\n+  if (sig == SIGSTOP) {\n+    return KERN_SUCCESS;\n+  } else {\n+    \/\/ Sometimes we get SIGTRAP(4) or SIGILL(5) instead of SIGSTOP (17) on aarch64.\n+    \/\/ We currently can't deal with them. See JDK-8288429.\n+    print_error(\"catch_mach_exception_raise: signal is not SIGSTOP (%d)\\n\", sig);\n+    return GOT_UNKNOWN_EXC;\n+  }\n","filename":"src\/jdk.hotspot.agent\/macosx\/native\/libsaproc\/MacosxDebuggerLocal.m","additions":13,"deletions":7,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2011, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,2 +34,2 @@\n-  public AddressException(String detail, long addr) {\n-    super(detail);\n+  public AddressException(String message, long addr) {\n+    super(message);\n@@ -44,1 +44,6 @@\n-    return Long.toHexString(addr);\n+    String msg = super.getMessage();\n+    if (msg != null) {\n+      return msg;\n+    } else {\n+      return Long.toHexString(addr);\n+    }\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/AddressException.java","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -67,0 +67,1 @@\n+  private long pageSize;\n@@ -180,0 +181,1 @@\n+    this.pageSize = pageSize;\n@@ -235,0 +237,13 @@\n+  \/** If an address for a 64-bit value starts on the last 32-bit word of a\n+      page, then we can't use the page cache to read it because it will cause\n+      an ArrayIndexOutOfBoundsException when reading past the end of the page. *\/\n+  private boolean canUsePageCacheFor64bitRead(long address) {\n+    long pageMask = ~(pageSize - 1);\n+    if ((address & pageMask) != ((address + 4) & pageMask)) {\n+      \/\/ This address starts on the last 32-bit word of the page.\n+      \/\/ Cannot use the page cache in that case.\n+      return false;\n+    }\n+    return true;\n+  }\n+\n@@ -259,2 +274,0 @@\n-  \/\/ NOTE: assumes value does not span pages (may be bad assumption on\n-  \/\/ Solaris\/x86; see unalignedAccessesOkay in DbxDebugger hierarchy)\n@@ -273,2 +286,0 @@\n-  \/\/ NOTE: assumes value does not span pages (may be bad assumption on\n-  \/\/ Solaris\/x86; see unalignedAccessesOkay in DbxDebugger hierarchy)\n@@ -279,1 +290,1 @@\n-    if (useFastAccessors) {\n+    if (useFastAccessors && canUsePageCacheFor64bitRead(address)) {\n@@ -287,2 +298,0 @@\n-  \/\/ NOTE: assumes value does not span pages (may be bad assumption on\n-  \/\/ Solaris\/x86; see unalignedAccessesOkay in DbxDebugger hierarchy)\n@@ -301,2 +310,0 @@\n-  \/\/ NOTE: assumes value does not span pages (may be bad assumption on\n-  \/\/ Solaris\/x86; see unalignedAccessesOkay in DbxDebugger hierarchy)\n@@ -315,2 +322,0 @@\n-  \/\/ NOTE: assumes value does not span pages (may be bad assumption on\n-  \/\/ Solaris\/x86; see unalignedAccessesOkay in DbxDebugger hierarchy)\n@@ -321,1 +326,1 @@\n-    if (useFastAccessors) {\n+    if (useFastAccessors && canUsePageCacheFor64bitRead(address)) {\n@@ -329,2 +334,0 @@\n-  \/\/ NOTE: assumes value does not span pages (may be bad assumption on\n-  \/\/ Solaris\/x86; see unalignedAccessesOkay in DbxDebugger hierarchy)\n@@ -343,2 +346,0 @@\n-  \/\/ NOTE: assumes value does not span pages (may be bad assumption on\n-  \/\/ Solaris\/x86; see unalignedAccessesOkay in DbxDebugger hierarchy)\n@@ -349,1 +350,1 @@\n-    if (useFastAccessors) {\n+    if (useFastAccessors && (numBytes != 8 || canUsePageCacheFor64bitRead(address))) {\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/DebuggerBase.java","additions":18,"deletions":17,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+  protected boolean supports32bitAlignmentOf64bitTypes;\n@@ -33,1 +34,2 @@\n-  public DebuggerUtilities(long addressSize, boolean isBigEndian) {\n+    public DebuggerUtilities(long addressSize, boolean isBigEndian,\n+                             boolean supports32bitAlignmentOf64bitTypes) {\n@@ -36,0 +38,1 @@\n+    this.supports32bitAlignmentOf64bitTypes = supports32bitAlignmentOf64bitTypes;\n@@ -56,0 +59,7 @@\n+    \/\/ Allow 32-bit alignment for 64-bit types on some hosts.\n+    if (supports32bitAlignmentOf64bitTypes) {\n+      if (address % 4 == 0) {\n+        return;\n+      }\n+    }\n+\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/DebuggerUtilities.java","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2008, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,0 +59,6 @@\n+\n+  \/** Indicates whether the underlying machine supports 64-bit types\n+      that are only 32-bit aligned. *\/\n+  default public boolean supports32bitAlignmentOf64bitTypes() {\n+    return false;\n+  }\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/MachineDescription.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2008, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,4 @@\n+\n+  public boolean supports32bitAlignmentOf64bitTypes() {\n+    return true;\n+  }\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/MachineDescriptionIntelX86.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -191,14 +191,2 @@\n-                                      machDesc.isBigEndian()) {\n-           public void checkAlignment(long address, long alignment) {\n-             \/\/ Need to override default checkAlignment because we need to\n-             \/\/ relax alignment constraints on Bsd\/x86\n-             if ( (address % alignment != 0)\n-                &&(alignment != 8 || address % 4 != 0)) {\n-                throw new UnalignedAddressException(\n-                        \"Trying to read at address: \"\n-                      + addressValueToString(address)\n-                      + \" with alignment: \" + alignment,\n-                        address);\n-             }\n-           }\n-        };\n+                                      machDesc.isBigEndian(),\n+                                      machDesc.supports32bitAlignmentOf64bitTypes());\n@@ -487,24 +475,0 @@\n-    \/** Need to override this to relax alignment checks on x86. *\/\n-    public long readCInteger(long address, long numBytes, boolean isUnsigned)\n-        throws UnmappedAddressException, UnalignedAddressException {\n-        \/\/ Only slightly relaxed semantics -- this is a hack, but is\n-        \/\/ necessary on x86 where it seems the compiler is\n-        \/\/ putting some global 64-bit data on 32-bit boundaries\n-        if (numBytes == 8) {\n-            utils.checkAlignment(address, 4);\n-        } else {\n-            utils.checkAlignment(address, numBytes);\n-        }\n-        byte[] data = readBytes(address, numBytes);\n-        return utils.dataToCInteger(data, isUnsigned);\n-    }\n-\n-    \/\/ Overridden from DebuggerBase because we need to relax alignment\n-    \/\/ constraints on x86\n-    public long readJLong(long address)\n-        throws UnmappedAddressException, UnalignedAddressException {\n-        utils.checkAlignment(address, jintSize);\n-        byte[] data = readBytes(address, jlongSize);\n-        return utils.dataToJLong(data, jlongSize);\n-    }\n-\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/bsd\/BsdDebuggerLocal.java","additions":2,"deletions":38,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -210,14 +210,2 @@\n-                                      machDesc.isBigEndian()) {\n-           public void checkAlignment(long address, long alignment) {\n-             \/\/ Need to override default checkAlignment because we need to\n-             \/\/ relax alignment constraints on Linux\/x86\n-             if ( (address % alignment != 0)\n-                &&(alignment != 8 || address % 4 != 0)) {\n-                throw new UnalignedAddressException(\n-                        \"Trying to read at address: \"\n-                      + addressValueToString(address)\n-                      + \" with alignment: \" + alignment,\n-                        address);\n-             }\n-           }\n-        };\n+                                      machDesc.isBigEndian(),\n+                                      machDesc.supports32bitAlignmentOf64bitTypes());\n@@ -544,24 +532,0 @@\n-    \/** Need to override this to relax alignment checks on x86. *\/\n-    public long readCInteger(long address, long numBytes, boolean isUnsigned)\n-        throws UnmappedAddressException, UnalignedAddressException {\n-        \/\/ Only slightly relaxed semantics -- this is a hack, but is\n-        \/\/ necessary on x86 where it seems the compiler is\n-        \/\/ putting some global 64-bit data on 32-bit boundaries\n-        if (numBytes == 8) {\n-            utils.checkAlignment(address, 4);\n-        } else {\n-            utils.checkAlignment(address, numBytes);\n-        }\n-        byte[] data = readBytes(address, numBytes);\n-        return utils.dataToCInteger(data, isUnsigned);\n-    }\n-\n-    \/\/ Overridden from DebuggerBase because we need to relax alignment\n-    \/\/ constraints on x86\n-    public long readJLong(long address)\n-        throws UnmappedAddressException, UnalignedAddressException {\n-        utils.checkAlignment(address, jintSize);\n-        byte[] data = readBytes(address, jlongSize);\n-        return utils.dataToJLong(data, jlongSize);\n-    }\n-\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/linux\/LinuxDebuggerLocal.java","additions":2,"deletions":38,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -46,1 +46,0 @@\n-  private boolean unalignedAccessesOkay = false;\n@@ -53,2 +52,3 @@\n-      machDesc = remoteDebugger.getMachineDescription();\n-      utils = new DebuggerUtilities(machDesc.getAddressSize(), machDesc.isBigEndian());\n+      this.machDesc = remoteDebugger.getMachineDescription();\n+      utils = new DebuggerUtilities(machDesc.getAddressSize(), machDesc.isBigEndian(),\n+                                    machDesc.supports32bitAlignmentOf64bitTypes());\n@@ -60,1 +60,0 @@\n-        unalignedAccessesOkay = true;\n@@ -63,1 +62,0 @@\n-        unalignedAccessesOkay = true;\n@@ -66,1 +64,0 @@\n-        unalignedAccessesOkay = true;\n@@ -77,1 +74,0 @@\n-        unalignedAccessesOkay = false;\n@@ -231,35 +227,0 @@\n-  \/** Need to override this to relax alignment checks on x86. *\/\n-  public long readCInteger(long address, long numBytes, boolean isUnsigned)\n-    throws UnmappedAddressException, UnalignedAddressException {\n-    if (!unalignedAccessesOkay) {\n-      utils.checkAlignment(address, numBytes);\n-    } else {\n-      \/\/ Only slightly relaxed semantics -- this is a hack, but is\n-      \/\/ necessary on x86 where it seems the compiler is\n-      \/\/ putting some global 64-bit data on 32-bit boundaries\n-      if (numBytes == 8) {\n-        utils.checkAlignment(address, 4);\n-      } else {\n-        utils.checkAlignment(address, numBytes);\n-      }\n-    }\n-    byte[] data = readBytes(address, numBytes);\n-    return utils.dataToCInteger(data, isUnsigned);\n-  }\n-\n-  \/\/ Overridden from DebuggerBase because we need to relax alignment\n-  \/\/ constraints on x86\n-  public long readJLong(long address)\n-    throws UnmappedAddressException, UnalignedAddressException {\n-    \/\/ FIXME: allow this to be configurable. Undesirable to add a\n-    \/\/ dependency on the runtime package here, though, since this\n-    \/\/ package should be strictly underneath it.\n-    if (unalignedAccessesOkay) {\n-      utils.checkAlignment(address, jintSize);\n-    } else {\n-      utils.checkAlignment(address, jlongSize);\n-    }\n-    byte[] data = readBytes(address, jlongSize);\n-    return utils.dataToJLong(data, jlongSize);\n-  }\n-\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/remote\/RemoteDebuggerClient.java","additions":3,"deletions":42,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -98,14 +98,2 @@\n-    utils = new DebuggerUtilities(machDesc.getAddressSize(), machDesc.isBigEndian()) {\n-           public void checkAlignment(long address, long alignment) {\n-             \/\/ Need to override default checkAlignment because we need to\n-             \/\/ relax alignment constraints on Windows\/x86\n-             if ( (address % alignment != 0)\n-                &&(alignment != 8 || address % 4 != 0)) {\n-                throw new UnalignedAddressException(\n-                        \"Trying to read at address: \"\n-                      + addressValueToString(address)\n-                      + \" with alignment: \" + alignment,\n-                        address);\n-             }\n-           }\n-        };\n+    utils = new DebuggerUtilities(machDesc.getAddressSize(), machDesc.isBigEndian(),\n+                                  machDesc.supports32bitAlignmentOf64bitTypes());\n@@ -272,16 +260,0 @@\n-  \/\/----------------------------------------------------------------------\n-  \/\/ Overridden from DebuggerBase because we need to relax alignment\n-  \/\/ constraints on x86\n-\n-  public long readJLong(long address)\n-    throws UnmappedAddressException, UnalignedAddressException {\n-    checkJavaConfigured();\n-    \/\/ FIXME: allow this to be configurable. Undesirable to add a\n-    \/\/ dependency on the runtime package here, though, since this\n-    \/\/ package should be strictly underneath it.\n-    \/\/    utils.checkAlignment(address, jlongSize);\n-    utils.checkAlignment(address, jintSize);\n-    byte[] data = readBytes(address, jlongSize);\n-    return utils.dataToJLong(data, jlongSize);\n-  }\n-\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/windbg\/WindbgDebuggerLocal.java","additions":2,"deletions":30,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-## jQuery UI v1.12.1\n+## jQuery UI v1.13.1\n","filename":"src\/jdk.javadoc\/share\/legal\/jqueryUI.md","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import java.lang.Character.UnicodeBlock;\n@@ -225,12 +226,15 @@\n-            return \"\\\"\" + ((String) value).codePoints()\n-                    .flatMap(cp ->\n-                        (cp == '\"')\n-                            ? \"\\\\\\\"\".codePoints()\n-                            : (cp < 256)\n-                                ? charRep[cp].codePoints()\n-                                : IntStream.of(cp))\n-                    .collect(\n-                            StringBuilder::new,\n-                            StringBuilder::appendCodePoint,\n-                            StringBuilder::append)\n-                    .toString() + \"\\\"\";\n+            StringBuilder result = new StringBuilder();\n+            result.append(\"\\\"\");\n+            var cpIt = ((String) value).codePoints().iterator();\n+            int idx = 0;\n+            while (cpIt.hasNext()) {\n+                int cp = cpIt.nextInt();\n+                if (cp == '\"') {\n+                    result.append(\"\\\\\\\"\");\n+                } else {\n+                    appendEscapedChar(idx, cp, result);\n+                }\n+                idx++;\n+            }\n+            result.append(\"\\\"\");\n+            return result.toString();\n@@ -239,6 +243,9 @@\n-            return \"'\" + (\n-                (cp == '\\'')\n-                    ? \"\\\\\\'\"\n-                    : (cp < 256)\n-                            ? charRep[cp]\n-                            : String.valueOf(cp)) + \"'\";\n+            StringBuilder result = new StringBuilder();\n+            result.append(\"'\");\n+            if (cp == '\\'') {\n+                result.append(\"\\\\\\'\");\n+            } else {\n+                appendEscapedChar(0, cp, result);\n+            }\n+            result.append(\"'\");\n+            return result.toString();\n@@ -280,0 +287,23 @@\n+    private static void appendEscapedChar(int idx, int cp, StringBuilder target) {\n+        if (cp < 256) {\n+            target.append(charRep[cp]);\n+        } else if (needsEscape(idx, cp)) {\n+            target.append(String.format(\"\\\\u%04X\", cp));\n+        } else {\n+            target.appendCodePoint(cp);\n+        }\n+    }\n+\n+    private static boolean needsEscape(int idx, int cp) {\n+        UnicodeBlock block = UnicodeBlock.of(cp);\n+        if (block == UnicodeBlock.COMBINING_DIACRITICAL_MARKS ||\n+            block == UnicodeBlock.COMBINING_DIACRITICAL_MARKS_EXTENDED ||\n+            block == UnicodeBlock.COMBINING_DIACRITICAL_MARKS_SUPPLEMENT) {\n+            \/\/escape leading combining diacritical marks,\n+            \/\/as those might be confusingly merged into the leading quotes:\n+            return idx == 0;\n+        } else {\n+            return false;\n+        }\n+    }\n+\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/execution\/DirectExecutionControl.java","additions":48,"deletions":18,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -152,1 +152,0 @@\n-vmTestbase\/gc\/lock\/jni\/jnilock001\/TestDescription.java 8292946 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8292660\n+ * @summary Test that blocks made unreachable after processing multiple infinite\n+ *          loops in the block ordering phase are removed correctly.\n+ *\n+ * @run main\/othervm -Xcomp -XX:CompileOnly=compiler.loopopts.TestMultipleInfiniteLoops::test\n+ *                   compiler.loopopts.TestMultipleInfiniteLoops\n+ *\/\n+\n+package compiler.loopopts;\n+\n+public class TestMultipleInfiniteLoops {\n+\n+    static int foo;\n+\n+    static void test() {\n+        int i = 5, j;\n+        while (i > 0) {\n+            for (j = i; 1 > j; ) {\n+                switch (i) {\n+                case 4:\n+                    foo = j;\n+                }\n+            }\n+            i++;\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        test();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TestMultipleInfiniteLoops.java","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -220,0 +220,9 @@\n+            \/\/ Use findpc on an address that is only 4 byte aligned and is the\n+            \/\/ last 4 bytes of a 4k page. This is for testing JDK-8292201.\n+            String badAddress = tid.substring(0, tid.length() - 3) + \"ffc\";\n+            cmdStr = \"findpc \" + badAddress;\n+            cmds = List.of(cmdStr);\n+            expStrMap = new HashMap<>();\n+            expStrMap.put(cmdStr, List.of(\"In unknown location\"));\n+            runTest(withCore, cmds, expStrMap);\n+\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/ClhsdbFindPC.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -72,11 +72,24 @@\n-        modifierKeys =  new int[4];\n-        modifierKeys[0] = KeyEvent.VK_SHIFT;\n-        modifierKeys[1] = KeyEvent.VK_CONTROL;\n-        modifierKeys[2] = KeyEvent.VK_ALT;\n-        modifierKeys[3] = KeyEvent.VK_ALT_GRAPH;\n-\n-        inputMasks = new int[4];\n-        inputMasks[0] =  InputEvent.SHIFT_MASK;\n-        inputMasks[1] =  InputEvent.CTRL_MASK;\n-        inputMasks[2] =  InputEvent.ALT_MASK;\n-        inputMasks[3] =  InputEvent.ALT_GRAPH_MASK;\n+        String os = System.getProperty(\"os.name\").toLowerCase();\n+        if (os.contains(\"os x\")) {\n+            modifierKeys =  new int[3];\n+            modifierKeys[0] = KeyEvent.VK_SHIFT;\n+            modifierKeys[1] = KeyEvent.VK_CONTROL;\n+            modifierKeys[2] = KeyEvent.VK_ALT;\n+\n+            inputMasks = new int[3];\n+            inputMasks[0] =  InputEvent.SHIFT_MASK;\n+            inputMasks[1] =  InputEvent.CTRL_MASK;\n+            inputMasks[2] =  InputEvent.ALT_MASK;\n+        } else {\n+            modifierKeys =  new int[4];\n+            modifierKeys[0] = KeyEvent.VK_SHIFT;\n+            modifierKeys[1] = KeyEvent.VK_CONTROL;\n+            modifierKeys[2] = KeyEvent.VK_ALT;\n+            modifierKeys[3] = KeyEvent.VK_ALT_GRAPH;\n+\n+            inputMasks = new int[4];\n+            inputMasks[0] =  InputEvent.SHIFT_MASK;\n+            inputMasks[1] =  InputEvent.CTRL_MASK;\n+            inputMasks[2] =  InputEvent.ALT_MASK;\n+            inputMasks[3] =  InputEvent.ALT_GRAPH_MASK;\n+        }\n@@ -89,1 +102,0 @@\n-        String os = System.getProperty(\"os.name\").toLowerCase();\n","filename":"test\/jdk\/java\/awt\/Robot\/ModifierRobotKey\/ModifierRobotKeyTest.java","additions":24,"deletions":12,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ @requires (os.family != \"mac\")\n@@ -258,1 +259,1 @@\n-}\n\\ No newline at end of file\n+}\n","filename":"test\/jdk\/java\/awt\/event\/MouseEvent\/AltGraphModifierTest\/AltGraphModifierTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @requires (os.family != \"mac\")\n","filename":"test\/jdk\/java\/awt\/keyboard\/8218917\/AltKeyBug.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -153,1 +153,0 @@\n-            KeyEvent.VK_ALT_GRAPH\n","filename":"test\/jdk\/java\/awt\/keyboard\/AllKeyCode\/AllKeyCode.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n- * @bug 4313887 6838333 6917021 7006126 6950237 8006645 8201407 8267820\n+ * @bug 4313887 6838333 6917021 7006126 6950237 8006645 8201407 8264744 8267820\n@@ -62,2 +62,2 @@\n-            \/\/ Different directories. Use test.dir if possible as it might be\n-            \/\/ a different volume\/file system and so improve test coverage.\n+            \/\/ Use test.dir to define second directory if possible as it might\n+            \/\/ be a different volume\/file system and so improve test coverage.\n@@ -66,0 +66,16 @@\n+            FileStore fileStore2 = getFileStore(dir2);\n+            printDirInfo(\"dir2\", dir2, fileStore2);\n+\n+            \/\/ If different type (format) from dir1, re-do same directory tests\n+            if (!fileStore1.type().equals(fileStore2.type())) {\n+                try {\n+                    testPosixAttributes =\n+                        fileStore2.supportsFileAttributeView(\"posix\");\n+                    testCopyFileToFile(dir2, dir2, TestUtil.supportsLinks(dir2));\n+                    testMove(dir2, dir2, TestUtil.supportsLinks(dir2));\n+                } finally {\n+                    TestUtil.removeAll(dir2);\n+                }\n+            }\n+\n+            \/\/ Different directories.\n@@ -67,0 +83,4 @@\n+                \/\/ Recreate dir2 if it was removed above\n+                if (notExists(dir2)) {\n+                    dir2 = TestUtil.createTemporaryDirectory(testDir);\n+                }\n@@ -69,2 +89,0 @@\n-                FileStore fileStore2 = getFileStore(dir2);\n-                printDirInfo(\"dir2\", dir2, fileStore2);\n","filename":"test\/jdk\/java\/nio\/file\/Files\/CopyAndMove.java","additions":23,"deletions":5,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-tzdata2022a\n+tzdata2022c\n","filename":"test\/jdk\/java\/util\/TimeZone\/TimeZoneData\/VERSION","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -10,0 +10,1 @@\n+Link Africa\/Abidjan Atlantic\/Reykjavik\t# Iceland\n@@ -38,0 +39,2 @@\n+Link Asia\/Yangon Indian\/Cocos\n+Link Asia\/Urumqi Antarctica\/Vostok\n@@ -39,0 +42,2 @@\n+Link Asia\/Kuching Asia\/Brunei\n+Link Indian\/Maldives Indian\/Kerguelen\n@@ -43,0 +48,1 @@\n+Link Asia\/Singapore Asia\/Kuala_Lumpur\n@@ -45,0 +51,1 @@\n+Link Asia\/Bangkok Indian\/Christmas\n@@ -46,0 +53,2 @@\n+Link Asia\/Dubai Indian\/Mahe\n+Link Asia\/Dubai Indian\/Reunion\n@@ -47,0 +56,4 @@\n+Link Pacific\/Tarawa Pacific\/Funafuti\n+Link Pacific\/Tarawa Pacific\/Majuro\n+Link Pacific\/Tarawa Pacific\/Wake\n+Link Pacific\/Tarawa Pacific\/Wallis\n@@ -49,0 +62,1 @@\n+Link Pacific\/Port_Moresby Pacific\/Chuuk\n@@ -50,0 +64,1 @@\n+Link Pacific\/Guadalcanal Pacific\/Pohnpei\n@@ -53,0 +68,3 @@\n+Link Europe\/Brussels Europe\/Amsterdam\n+Link Europe\/Brussels Europe\/Luxembourg\n+Link Europe\/Prague Europe\/Bratislava\n@@ -54,5 +72,7 @@\n-Link\tEurope\/Zurich\tEurope\/Busingen\n-Link\tEurope\/Rome\tEurope\/Vatican\n-Link\tEurope\/Rome\tEurope\/San_Marino\n-Link Europe\/Zurich Europe\/Vaduz\n-Link\tEurope\/Oslo\tArctic\/Longyearbyen\n+Link Europe\/Paris Europe\/Monaco\n+Link Europe\/Berlin Arctic\/Longyearbyen\n+Link Europe\/Berlin Europe\/Copenhagen\n+Link Europe\/Berlin Europe\/Oslo\n+Link Europe\/Berlin Europe\/Stockholm\n+Link Europe\/Rome Europe\/Vatican\n+Link Europe\/Rome Europe\/San_Marino\n@@ -64,1 +84,2 @@\n-Link Europe\/Prague Europe\/Bratislava\n+Link Europe\/Zurich Europe\/Busingen\n+Link Europe\/Zurich Europe\/Vaduz\n@@ -131,1 +152,1 @@\n-Link\tEurope\/Oslo\t\tAtlantic\/Jan_Mayen\n+Link\tEurope\/Berlin\t\tAtlantic\/Jan_Mayen\n@@ -163,0 +184,1 @@\n+Link\tEurope\/Kyiv\t\tEurope\/Kiev\n@@ -171,1 +193,1 @@\n-Link\tAtlantic\/Reykjavik\tIceland\n+Link\tAfrica\/Abidjan\t\tIceland\n@@ -187,1 +209,1 @@\n-Link\tPacific\/Pohnpei\t\tPacific\/Ponape\n+Link\tPacific\/Guadalcanal\tPacific\/Ponape\n@@ -189,2 +211,2 @@\n-Link\tPacific\/Chuuk\t\tPacific\/Truk\n-Link\tPacific\/Chuuk\t\tPacific\/Yap\n+Link\tPacific\/Port_Moresby\tPacific\/Truk\n+Link\tPacific\/Port_Moresby\tPacific\/Yap\n","filename":"test\/jdk\/java\/util\/TimeZone\/TimeZoneData\/aliases.txt","additions":33,"deletions":11,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -100,1 +100,0 @@\n-Antarctica\/Troll UTC\n@@ -127,1 +126,0 @@\n-Atlantic\/Reykjavik GMT\n@@ -142,1 +140,0 @@\n-Europe\/Amsterdam CET CEST\n@@ -151,1 +148,0 @@\n-Europe\/Copenhagen CET CEST\n@@ -156,1 +152,1 @@\n-Europe\/Kiev EET EEST\n+Europe\/Kyiv EET EEST\n@@ -159,1 +155,0 @@\n-Europe\/Luxembourg CET CEST\n@@ -162,1 +157,0 @@\n-Europe\/Monaco CET CEST\n@@ -164,1 +158,0 @@\n-Europe\/Oslo CET CEST\n@@ -171,1 +164,0 @@\n-Europe\/Stockholm CET CEST\n","filename":"test\/jdk\/java\/util\/TimeZone\/TimeZoneData\/displaynames.txt","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,118 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+   @bug 8267374\n+   @key headful\n+   @requires (os.family == \"mac\")\n+   @summary Verifies ALT+Up\/ALT+Down keypress move cursor to start\/end of textline.\n+   @run main TestAltUpDown\n+ *\/\n+\n+import java.awt.Robot;\n+import java.awt.event.KeyEvent;\n+import javax.swing.JFrame;\n+import javax.swing.JTextArea;\n+import javax.swing.SwingUtilities;\n+import javax.swing.text.BadLocationException;\n+import javax.swing.text.Utilities;\n+\n+public class TestAltUpDown {\n+    private static JFrame frame;\n+    private static JTextArea textArea;\n+    volatile static int caretPosition;\n+    volatile static int rowEnd;\n+    volatile static int rowStart;\n+\n+    public static void main(String[] args) throws Exception {\n+        try {\n+            SwingUtilities.invokeAndWait(() -> {\n+                textArea = new JTextArea(20, 40);\n+                textArea.setLineWrap(true);\n+                textArea.setText(\"This is first line\\n\" +\n+                        \"This is second line\\n\" +\n+                        \"This is thrid line\");\n+                textArea.setCaretPosition(0);\n+                frame = new JFrame(\"Alt-Arrow Bug\");\n+                frame.add(textArea);\n+                frame.pack();\n+                frame.setLocationRelativeTo(null);\n+                frame.setVisible(true);\n+            });\n+\n+            Robot robot = new Robot();\n+            robot.waitForIdle();\n+            robot.delay(1000);\n+            robot.keyPress(KeyEvent.VK_ALT);\n+            robot.keyPress(KeyEvent.VK_DOWN);\n+            robot.keyRelease(KeyEvent.VK_DOWN);\n+            robot.keyRelease(KeyEvent.VK_ALT);\n+\n+            SwingUtilities.invokeAndWait(() -> {\n+                caretPosition = textArea.getCaretPosition();\n+                try {\n+                    rowEnd = Utilities.getRowEnd(textArea, caretPosition);\n+                } catch (BadLocationException ex) {\n+                    throw new RuntimeException(ex);\n+                }\n+                System.out.println(\"caretPosition\" + caretPosition + \" rowEnd \" + rowEnd);\n+            });\n+            if (caretPosition != rowEnd) {\n+                throw new RuntimeException(\"Option+Down doesn't move the cursor\");\n+            }\n+\n+            robot.delay(1000);\n+            robot.keyPress(KeyEvent.VK_ALT);\n+            robot.keyPress(KeyEvent.VK_DOWN);\n+            robot.keyRelease(KeyEvent.VK_DOWN);\n+            robot.keyRelease(KeyEvent.VK_ALT);\n+            robot.delay(1000);\n+            robot.keyPress(KeyEvent.VK_ALT);\n+            robot.keyPress(KeyEvent.VK_UP);\n+            robot.keyRelease(KeyEvent.VK_UP);\n+            robot.keyRelease(KeyEvent.VK_ALT);\n+            robot.delay(1000);\n+            robot.keyPress(KeyEvent.VK_ALT);\n+            robot.keyPress(KeyEvent.VK_UP);\n+            robot.keyRelease(KeyEvent.VK_UP);\n+            robot.keyRelease(KeyEvent.VK_ALT);\n+\n+            caretPosition = textArea.getCaretPosition();\n+            try {\n+                rowStart = Utilities.getRowStart(textArea, caretPosition);\n+            } catch (BadLocationException bex) {\n+                throw new RuntimeException(bex);\n+            }\n+            System.out.println(\"caretPosition\" + caretPosition + \" rowStart \" + rowStart);\n+            if (caretPosition != 0) {\n+                throw new RuntimeException(\"Option+Up doesn't move the cursor\");\n+            }\n+        } finally {\n+            SwingUtilities.invokeAndWait(() -> {\n+                if (frame != null) {\n+                    frame.dispose();\n+                }\n+            });\n+        }\n+    }\n+}\n","filename":"test\/jdk\/javax\/swing\/JTextArea\/TestAltUpDown.java","additions":118,"deletions":0,"binary":false,"changes":118,"status":"added"},{"patch":"@@ -0,0 +1,111 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8287912\n+ * @key headful\n+ * @requires (os.family == \"linux\")\n+ * @summary Verifies if tree background color is red when\n+ * setOpaque(false) method is called for tree component\n+ * @run main TestTreeBackgroundColor\n+ *\/\n+\n+import java.awt.Color;\n+import java.awt.GridLayout;\n+import java.awt.Point;\n+import java.awt.Rectangle;\n+import java.awt.Robot;\n+import java.awt.image.BufferedImage;\n+import java.io.File;\n+import javax.imageio.ImageIO;\n+import javax.swing.JFrame;\n+import javax.swing.JPanel;\n+import javax.swing.JTree;\n+import javax.swing.SwingUtilities;\n+import javax.swing.UIManager;\n+\n+public class TestTreeBackgroundColor {\n+\n+    private static JFrame frame;\n+    private static JPanel panel;\n+    private static JTree tree;\n+\n+    public static void main(String[] args) throws Exception {\n+        UIManager.setLookAndFeel(\"com.sun.java.swing.plaf.gtk.GTKLookAndFeel\");\n+        Robot robot = new Robot();\n+        robot.setAutoDelay(100);\n+        try {\n+            SwingUtilities.invokeAndWait(new Runnable() {\n+                public void run() {\n+                    createAndShowUI();\n+                }\n+            });\n+\n+            robot.waitForIdle();\n+            robot.delay(1000);\n+            Point pt = tree.getLocationOnScreen();\n+            BufferedImage img =\n+                    robot.createScreenCapture(new Rectangle(pt.x, pt.y,\n+                            tree.getWidth(),\n+                            tree.getHeight()));\n+\n+            boolean passed = false;\n+            for (int x = img.getWidth()\/2; x < img.getWidth() - 1; ++x) {\n+                Color c = new Color(img.getRGB(x, img.getHeight()\/4));\n+                if (!c.equals(Color.RED)) {\n+                    passed = false;\n+                    break;\n+                } else {\n+                    passed = true;\n+                }\n+            }\n+            if (!passed) {\n+                ImageIO.write(img, \"png\", new File(\"TreeBackgroundColorFail.png\"));\n+                throw new RuntimeException(\"Test Case Failed : Tree Background Color is Not Red\");\n+            }\n+        } finally {\n+            SwingUtilities.invokeAndWait(() -> {\n+                if (frame != null) {\n+                    frame.dispose();\n+                }\n+            });\n+        }\n+    }\n+\n+    private static void createAndShowUI() {\n+        frame = new JFrame(\"Test Tree Background Color\");\n+        panel = new JPanel();\n+        tree = new JTree();\n+        panel.setBackground(Color.red);\n+        panel.setLayout(new GridLayout(1, 1));\n+        tree.setOpaque(false);\n+        panel.add(tree);\n+        frame.getContentPane().add(panel);\n+        frame.pack();\n+        frame.setSize(250, 200);\n+        frame.setLocationRelativeTo(null);\n+        frame.setVisible(true);\n+    }\n+}\n+\n","filename":"test\/jdk\/javax\/swing\/JTree\/TestTreeBackgroundColor.java","additions":111,"deletions":0,"binary":false,"changes":111,"status":"added"},{"patch":"@@ -374,0 +374,6 @@\n+                try {\n+                    \/\/ Test looking up with null caller\n+                    cp.lookupMethod(cpi, 184, null);\n+                    throw new AssertionError(\"Expected IllegalAccessError\");\n+                } catch (IllegalAccessError e) {\n+                }\n","filename":"test\/jdk\/jdk\/jfr\/jvm\/TestGetEventWriter.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -74,0 +74,1 @@\n+            long startTime = System.currentTimeMillis();\n@@ -79,1 +80,2 @@\n-            System.out.println(\"###### End of all output:\");\n+            long elapsedTime = System.currentTimeMillis() - startTime;\n+            System.out.println(\"###### End of all output which took \" + elapsedTime + \"ms\");\n","filename":"test\/jdk\/sun\/tools\/jhsdb\/JShellHeapDumpTest.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n- * @test 8130450 8158906 8154374 8166400 8171892 8173807 8173848\n+ * @test 8130450 8158906 8154374 8166400 8171892 8173807 8173848 8282434\n@@ -210,0 +210,4 @@\n+        assertEval(\"\\\"\\\\u032Ea\\\"\",\n+                   \"\\\"\\\\u032Ea\\\"\");\n+        assertEval(\"\\\"a\\\\u032Ea\\\"\",\n+                   \"\\\"a\\u032Ea\\\"\");\n@@ -225,0 +229,2 @@\n+        assertEval(\"\\\"\\\\u032E\\\".charAt(0)\",\n+                \"'\\\\u032E'\");\n","filename":"test\/langtools\/jdk\/jshell\/SimpleRegressionTest.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+ *          jdk.jdeps\/com.sun.tools.classfile\n@@ -36,0 +37,7 @@\n+import com.sun.tools.classfile.Attribute;\n+import com.sun.tools.classfile.Attributes;\n+import com.sun.tools.classfile.ClassFile;\n+import com.sun.tools.classfile.ClassWriter;\n+import com.sun.tools.classfile.ConstantPool;\n+import com.sun.tools.classfile.ConstantPool.CPInfo;\n+import com.sun.tools.classfile.ModuleResolution_attribute;\n@@ -39,0 +47,1 @@\n+import java.io.OutputStream;\n@@ -48,0 +57,2 @@\n+import java.util.HashMap;\n+import java.util.Map;\n@@ -658,0 +669,77 @@\n+    @Test\n+    public void testNoDuplicateIncubatorWarning(Path base) throws Exception {\n+        Path module = base.resolve(\"lib\");\n+        Path moduleSrc = module.resolve(\"src\");\n+        Path moduleClasses = module.resolve(\"classes\");\n+        Files.createDirectories(moduleClasses);\n+        tb.cleanDirectory(moduleClasses);\n+        tb.writeJavaFiles(moduleSrc, \"module test {}\");\n+        new JavacTask(tb)\n+                .outdir(moduleClasses)\n+                .files(tb.findJavaFiles(moduleSrc))\n+                .run()\n+                .writeAll();\n+        markModuleAsIncubator(moduleClasses.resolve(\"module-info.class\"));\n+        tb.writeJavaFiles(base, \"public class Main { public static void main(String... args) {}}\");\n+        String log = new JavaTask(tb)\n+                .vmOptions(\"--module-path\", moduleClasses.toString(),\n+                           \"--add-modules\", \"test\")\n+                .className(base.resolve(\"Main.java\").toString())\n+                .run(Task.Expect.SUCCESS)\n+                .writeAll()\n+                .getOutput(Task.OutputKind.STDERR);\n+\n+        int numberOfWarnings = log.split(\"WARNING\").length - 1;\n+\n+        if (log.contains(\"warning:\") || numberOfWarnings != 1) {\n+            error(\"Unexpected warning in error output: \" + log);\n+        }\n+\n+        List<String> compileLog = new JavacTask(tb)\n+                .options(\"--module-path\", moduleClasses.toString(),\n+                         \"--add-modules\", \"test\",\n+                         \"-XDrawDiagnostics\",\n+                         \"-XDsourceLauncher\",\n+                         \"-XDshould-stop.at=FLOW\")\n+                .files(base.resolve(\"Main.java\").toString())\n+                .run(Task.Expect.SUCCESS)\n+                .writeAll()\n+                .getOutputLines(Task.OutputKind.DIRECT);\n+\n+        List<String> expectedOutput = List.of(\n+                \"- compiler.warn.incubating.modules: test\",\n+                \"1 warning\"\n+        );\n+\n+        if (!expectedOutput.equals(compileLog)) {\n+            error(\"Unexpected options : \" + compileLog);\n+        }\n+    }\n+        \/\/where:\n+        private static void markModuleAsIncubator(Path moduleInfoFile) throws Exception {\n+            ClassFile cf = ClassFile.read(moduleInfoFile);\n+            List<CPInfo> newPool = new ArrayList<>();\n+            newPool.add(null);\n+            cf.constant_pool.entries().forEach(newPool::add);\n+            int moduleResolutionIndex = newPool.size();\n+            newPool.add(new ConstantPool.CONSTANT_Utf8_info(Attribute.ModuleResolution));\n+            Map<String, Attribute> newAttributes = new HashMap<>(cf.attributes.map);\n+            newAttributes.put(Attribute.ModuleResolution,\n+                              new ModuleResolution_attribute(moduleResolutionIndex,\n+                                                             ModuleResolution_attribute.WARN_INCUBATING));\n+            ClassFile newClassFile = new ClassFile(cf.magic,\n+                                                   cf.minor_version,\n+                                                   cf.major_version,\n+                                                   new ConstantPool(newPool.toArray(new CPInfo[0])),\n+                                                   cf.access_flags,\n+                                                   cf.this_class,\n+                                                   cf.super_class,\n+                                                   cf.interfaces,\n+                                                   cf.fields,\n+                                                   cf.methods,\n+                                                   new Attributes(newAttributes));\n+            try (OutputStream out = Files.newOutputStream(moduleInfoFile)) {\n+                new ClassWriter().write(newClassFile, out);\n+            }\n+        }\n+\n","filename":"test\/langtools\/tools\/javac\/launcher\/SourceLauncherTest.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"modified"}]}