{"files":[{"patch":"@@ -46,1 +46,3 @@\n-    __ la(t0, safepoint_pc.target());\n+    int32_t offset;\n+    __ la_patchable(t0, safepoint_pc.target(), offset);\n+    __ addi(t0, t0, offset);\n","filename":"src\/hotspot\/cpu\/riscv\/c1_CodeStubs_riscv.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -43,1 +43,3 @@\n-    __ la(t0, safepoint_pc.target());\n+    int32_t offset;\n+    __ la_patchable(t0, safepoint_pc.target(), offset);\n+    __ addi(t0, t0, offset);\n","filename":"src\/hotspot\/cpu\/riscv\/c2_safepointPollStubTable_riscv.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -213,0 +213,1 @@\n+    li32(zr, 0);\n@@ -1386,1 +1387,1 @@\n-static int patch_imm_in_li32(address branch, int32_t target) {\n+int MacroAssembler::patch_imm_in_li32(address branch, int32_t target) {\n@@ -1450,1 +1451,1 @@\n-static address get_target_of_li32(address insn_addr) {\n+address MacroAssembler::get_target_of_li32(address insn_addr) {\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -390,0 +390,3 @@\n+  static address get_target_of_li32(address insn_addr);\n+  static int patch_imm_in_li32(address branch, int32_t target);\n+\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -447,0 +447,5 @@\n+int NativePostCallNop::displacement() const {\n+  \/\/ discard the high 32-bit\n+  return (int)(intptr_t)MacroAssembler::get_target_of_li32(addr_at(4));\n+}\n+\n@@ -448,1 +453,6 @@\n-  \/\/ unsupported for now\n+#ifndef PRODUCT\n+  assert(diff != 0, \"must be\");\n+  assert(is_lui_to_zr_at(addr_at(4)) && is_addiw_to_zr_at(addr_at(8)), \"must be\");\n+#endif\n+\n+  MacroAssembler::patch_imm_in_li32(addr_at(4), diff);\n","filename":"src\/hotspot\/cpu\/riscv\/nativeInst_riscv.cpp","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -81,0 +81,1 @@\n+  static bool is_addiw_to_zr_at(address instr) { assert_cond(instr != NULL); return is_addiw_at(instr) && extract_rd(instr) == zr; }\n@@ -82,0 +83,1 @@\n+  static bool is_lui_to_zr_at(address instr)  { assert_cond(instr != NULL); return is_lui_at(instr) && extract_rd(instr) == zr; }\n@@ -557,0 +559,6 @@\n+\/\/ A NativePostCallNop takes the form of three instructions:\n+\/\/     nop; lui zr, hi20; addiw zr, lo12\n+\/\/\n+\/\/ The nop is patchable for a deoptimization trap. The lui and addiw\n+\/\/ instructions execute as nops but have a 20\/12-bit payload in which we\n+\/\/ can store an offset from the initial nop to the nmethod.\n@@ -559,2 +567,8 @@\n-  bool check() const { return is_nop(); }\n-  int displacement() const { return 0; }\n+  bool check() const {\n+    \/\/ Check for two instructions: nop; lui zr, hi20\n+    \/\/ These instructions only ever appear together in a post-call\n+    \/\/ NOP, so it's unnecessary to check that the third instruction is\n+    \/\/ an addiw as well.\n+    return is_nop() && is_lui_to_zr_at(addr_at(4));\n+  }\n+  int displacement() const;\n","filename":"src\/hotspot\/cpu\/riscv\/nativeInst_riscv.hpp","additions":16,"deletions":2,"binary":false,"changes":18,"status":"modified"}]}