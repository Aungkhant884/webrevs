{"files":[{"patch":"@@ -27,0 +27,1 @@\n+#include \"gc\/g1\/g1CardSetContainers.inline.hpp\"\n@@ -29,1 +30,0 @@\n-#include \"logging\/log.hpp\"\n@@ -31,1 +31,0 @@\n-#include \"utilities\/formatBuffer.hpp\"\n@@ -145,160 +144,0 @@\n-G1CardSetMemoryStats::G1CardSetMemoryStats() {\n-  clear();\n-}\n-\n-void G1CardSetMemoryStats::clear() {\n-  for (uint i = 0; i < num_pools(); i++) {\n-    _num_mem_sizes[i] = 0;\n-    _num_buffers[i] = 0;\n-  }\n-}\n-\n-void G1CardSetFreePool::update_unlink_processors(G1ReturnMemoryProcessorSet* unlink_processor) {\n-  uint num_free_lists = _freelist_pool.num_free_lists();\n-\n-  for (uint i = 0; i < num_free_lists; i++) {\n-    unlink_processor->at(i)->visit_free_list(_freelist_pool.free_list(i));\n-  }\n-}\n-\n-void G1CardSetFreePool::G1ReturnMemoryProcessor::visit_free_list(G1CardSetBufferList* source) {\n-  assert(_source == nullptr, \"already visited\");\n-  if (_return_to_vm_size > 0) {\n-    _source = source;\n-  } else {\n-    assert(_source == nullptr, \"must be\");\n-  }\n-  if (source->mem_size() > _return_to_vm_size) {\n-    _first = source->get_all(_num_unlinked, _unlinked_bytes);\n-  } else {\n-    assert(_first == nullptr, \"must be\");\n-  }\n-  \/\/ Above we were racing with other threads getting the contents of the free list,\n-  \/\/ so while we might have been asked to return something to the OS initially,\n-  \/\/ the free list might be empty anyway. In this case just reset internal values\n-  \/\/ used for checking whether there is work available.\n-  if (_first == nullptr) {\n-    _source = nullptr;\n-    _return_to_vm_size = 0;\n-  }\n-}\n-\n-bool G1CardSetFreePool::G1ReturnMemoryProcessor::return_to_vm(jlong deadline) {\n-  assert(!finished_return_to_vm(), \"already returned everything to the VM\");\n-  assert(_first != nullptr, \"must have element to return\");\n-\n-  size_t keep_size = 0;\n-  size_t keep_num = 0;\n-\n-  G1CardSetBuffer* cur = _first;\n-  G1CardSetBuffer* last = nullptr;\n-\n-  while (cur != nullptr && _return_to_vm_size > 0) {\n-    size_t cur_size = cur->mem_size();\n-    _return_to_vm_size -= MIN2(_return_to_vm_size, cur_size);\n-\n-    keep_size += cur_size;\n-    keep_num++;\n-\n-    last = cur;\n-    cur = cur->next();\n-    \/\/ To ensure progress, perform the deadline check here.\n-    if (os::elapsed_counter() > deadline) {\n-      break;\n-    }\n-  }\n-\n-  assert(_first != nullptr, \"must be\");\n-  assert(last != nullptr, \"must be\");\n-\n-  last->set_next(nullptr);\n-\n-  \/\/ Wait for any in-progress pops to avoid ABA for them.\n-  GlobalCounter::write_synchronize();\n-  _source->bulk_add(*_first, *last, keep_num, keep_size);\n-  _first = cur;\n-\n-  log_trace(gc, task)(\"Card Set Free Memory: Returned to VM %zu buffers size %zu\", keep_num, keep_size);\n-\n-  \/\/ _return_to_vm_size may be larger than what is available in the list at the\n-  \/\/ time we actually get the list. I.e. the list and _return_to_vm_size may be\n-  \/\/ inconsistent.\n-  \/\/ So also check if we actually already at the end of the list for the exit\n-  \/\/ condition.\n-  if (_return_to_vm_size == 0 || _first == nullptr) {\n-    _source = nullptr;\n-    _return_to_vm_size = 0;\n-  }\n-  return _source != nullptr;\n-}\n-\n-bool G1CardSetFreePool::G1ReturnMemoryProcessor::return_to_os(jlong deadline) {\n-  assert(finished_return_to_vm(), \"not finished returning to VM\");\n-  assert(!finished_return_to_os(), \"already returned everything to the OS\");\n-\n-  \/\/ Now delete the rest.\n-  size_t num_delete = 0;\n-  size_t mem_size_deleted = 0;\n-\n-  while (_first != nullptr) {\n-    G1CardSetBuffer* next = _first->next();\n-    num_delete++;\n-    mem_size_deleted += _first->mem_size();\n-    delete _first;\n-    _first = next;\n-\n-    \/\/ To ensure progress, perform the deadline check here.\n-    if (os::elapsed_counter() > deadline) {\n-      break;\n-    }\n-  }\n-\n-  log_trace(gc, task)(\"Card Set Free Memory: Return to OS %zu buffers size %zu\", num_delete, mem_size_deleted);\n-\n-  return _first != nullptr;\n-}\n-\n-G1CardSetFreePool G1CardSetFreePool::_freelist_pool(G1CardSetConfiguration::num_mem_object_types());\n-\n-G1CardSetFreePool::G1CardSetFreePool(uint num_free_lists) :\n-  _num_free_lists(num_free_lists) {\n-\n-  _free_lists = NEW_C_HEAP_ARRAY(G1CardSetBufferList, _num_free_lists, mtGC);\n-  for (uint i = 0; i < _num_free_lists; i++) {\n-    new (&_free_lists[i]) G1CardSetBufferList();\n-  }\n-}\n-\n-G1CardSetFreePool::~G1CardSetFreePool() {\n-  for (uint i = 0; i < _num_free_lists; i++) {\n-    _free_lists[i].~G1CardSetBufferList();\n-  }\n-  FREE_C_HEAP_ARRAY(mtGC, _free_lists);\n-}\n-\n-G1CardSetMemoryStats G1CardSetFreePool::memory_sizes() const {\n-  G1CardSetMemoryStats free_list_stats;\n-  assert(free_list_stats.num_pools() == num_free_lists(), \"must be\");\n-  for (uint i = 0; i < num_free_lists(); i++) {\n-    free_list_stats._num_mem_sizes[i] = _free_lists[i].mem_size();\n-    free_list_stats._num_buffers[i] = _free_lists[i].num_buffers();\n-  }\n-  return free_list_stats;\n-}\n-\n-size_t G1CardSetFreePool::mem_size() const {\n-  size_t result = 0;\n-  for (uint i = 0; i < _num_free_lists; i++) {\n-    result += _free_lists[i].mem_size();\n-  }\n-  return result;\n-}\n-\n-void G1CardSetFreePool::print_on(outputStream* out) {\n-  out->print_cr(\"  Free Pool: size %zu\", free_list_pool()->mem_size());\n-  for (uint i = 0; i < _num_free_lists; i++) {\n-    FormatBuffer<> fmt(\"    %s\", G1CardSetConfiguration::mem_object_type_name_str(i));\n-    _free_lists[i].print_on(out, fmt);\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSetMemory.cpp","additions":1,"deletions":162,"binary":false,"changes":163,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-#include \"gc\/g1\/g1CardSetContainers.inline.hpp\"\n@@ -32,0 +31,1 @@\n+#include \"gc\/g1\/g1SegmentedArrayFreePool.hpp\"\n@@ -139,93 +139,0 @@\n-\/\/ Statistics for a fixed set of buffer lists. Contains the number of buffers and memory\n-\/\/ used for each. Note that statistics are typically not taken atomically so there\n-\/\/ can be inconsistencies. The user must be prepared for them.\n-class G1CardSetMemoryStats {\n-public:\n-\n-  size_t _num_mem_sizes[G1CardSetConfiguration::num_mem_object_types()];\n-  size_t _num_buffers[G1CardSetConfiguration::num_mem_object_types()];\n-\n-  \/\/ Returns all-zero statistics.\n-  G1CardSetMemoryStats();\n-\n-  void add(G1CardSetMemoryStats const other) {\n-    STATIC_ASSERT(ARRAY_SIZE(_num_buffers) == ARRAY_SIZE(_num_mem_sizes));\n-    for (uint i = 0; i < ARRAY_SIZE(_num_mem_sizes); i++) {\n-      _num_mem_sizes[i] += other._num_mem_sizes[i];\n-      _num_buffers[i] += other._num_buffers[i];\n-    }\n-  }\n-\n-  void clear();\n-\n-  uint num_pools() const { return G1CardSetConfiguration::num_mem_object_types(); }\n-};\n-\n-\/\/ A set of free lists holding memory buffers for use by G1CardSetAllocators.\n-class G1CardSetFreePool {\n-  \/\/ The global free pool.\n-  static G1CardSetFreePool _freelist_pool;\n-\n-  const uint _num_free_lists;\n-  G1CardSetBufferList* _free_lists;\n-\n-public:\n-  static G1CardSetFreePool* free_list_pool() { return &_freelist_pool; }\n-  static G1CardSetMemoryStats free_list_sizes() { return _freelist_pool.memory_sizes(); }\n-\n-  class G1ReturnMemoryProcessor;\n-  typedef GrowableArrayCHeap<G1ReturnMemoryProcessor*, mtGC> G1ReturnMemoryProcessorSet;\n-\n-  static void update_unlink_processors(G1ReturnMemoryProcessorSet* unlink_processors);\n-\n-  explicit G1CardSetFreePool(uint num_free_lists);\n-  ~G1CardSetFreePool();\n-\n-  G1CardSetBufferList* free_list(uint i) {\n-    assert(i < _num_free_lists, \"must be\");\n-    return &_free_lists[i];\n-  }\n-\n-  uint num_free_lists() const { return _num_free_lists; }\n-\n-  G1CardSetMemoryStats memory_sizes() const;\n-  size_t mem_size() const;\n-\n-  void print_on(outputStream* out);\n-};\n-\n-\/\/ Data structure containing current in-progress state for returning memory to the\n-\/\/ operating system for a single G1CardSetBufferList.\n-class G1CardSetFreePool::G1ReturnMemoryProcessor : public CHeapObj<mtGC> {\n-  G1CardSetBufferList* _source;\n-  size_t _return_to_vm_size;\n-\n-  G1CardSetBuffer* _first;\n-  size_t _unlinked_bytes;\n-  size_t _num_unlinked;\n-\n-public:\n-  explicit G1ReturnMemoryProcessor(size_t return_to_vm) :\n-    _source(nullptr), _return_to_vm_size(return_to_vm), _first(nullptr), _unlinked_bytes(0), _num_unlinked(0) {\n-  }\n-\n-  \/\/ Updates the instance members about the given card set buffer list for the purpose\n-  \/\/ of giving back memory. Only necessary members are updated, e.g. if there is\n-  \/\/ nothing to return to the VM, do not set the source list.\n-  void visit_free_list(G1CardSetBufferList* source);\n-\n-  bool finished_return_to_vm() const { return _return_to_vm_size == 0; }\n-  bool finished_return_to_os() const { return _first == nullptr; }\n-\n-  \/\/ Returns memory to the VM until the given deadline expires. Returns true if\n-  \/\/ there is no more work. Guarantees forward progress, i.e. at least one buffer\n-  \/\/ has been processed after returning.\n-  \/\/ return_to_vm() re-adds buffers to the respective free list.\n-  bool return_to_vm(jlong deadline);\n-  \/\/ Returns memory to the VM until the given deadline expires. Returns true if\n-  \/\/ there is no more work. Guarantees forward progress, i.e. at least one buffer\n-  \/\/ has been processed after returning.\n-  \/\/ return_to_os() gives back buffers to the OS.\n-  bool return_to_os(jlong deadline);\n-};\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSetMemory.hpp","additions":1,"deletions":94,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -0,0 +1,200 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+\n+#include \"gc\/g1\/g1CardSetMemory.hpp\"\n+#include \"gc\/g1\/g1SegmentedArrayFreePool.hpp\"\n+#include \"gc\/g1\/g1SegmentedArray.inline.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"memory\/allocation.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"utilities\/formatBuffer.hpp\"\n+#include \"utilities\/ostream.hpp\"\n+\n+\n+G1CardSetMemoryStats::G1CardSetMemoryStats() {\n+  clear();\n+}\n+\n+void G1CardSetMemoryStats::clear() {\n+  for (uint i = 0; i < num_pools(); i++) {\n+    _num_mem_sizes[i] = 0;\n+    _num_buffers[i] = 0;\n+  }\n+}\n+\n+void G1CardSetFreePool::update_unlink_processors(G1ReturnMemoryProcessorSet* unlink_processor) {\n+  uint num_free_lists = _freelist_pool.num_free_lists();\n+\n+  for (uint i = 0; i < num_free_lists; i++) {\n+    unlink_processor->at(i)->visit_free_list(_freelist_pool.free_list(i));\n+  }\n+}\n+\n+void G1CardSetFreePool::G1ReturnMemoryProcessor::visit_free_list(G1CardSetBufferList* source) {\n+  assert(_source == nullptr, \"already visited\");\n+  if (_return_to_vm_size > 0) {\n+    _source = source;\n+  } else {\n+    assert(_source == nullptr, \"must be\");\n+  }\n+  if (source->mem_size() > _return_to_vm_size) {\n+    _first = source->get_all(_num_unlinked, _unlinked_bytes);\n+  } else {\n+    assert(_first == nullptr, \"must be\");\n+  }\n+  \/\/ Above we were racing with other threads getting the contents of the free list,\n+  \/\/ so while we might have been asked to return something to the OS initially,\n+  \/\/ the free list might be empty anyway. In this case just reset internal values\n+  \/\/ used for checking whether there is work available.\n+  if (_first == nullptr) {\n+    _source = nullptr;\n+    _return_to_vm_size = 0;\n+  }\n+}\n+\n+bool G1CardSetFreePool::G1ReturnMemoryProcessor::return_to_vm(jlong deadline) {\n+  assert(!finished_return_to_vm(), \"already returned everything to the VM\");\n+  assert(_first != nullptr, \"must have element to return\");\n+\n+  size_t keep_size = 0;\n+  size_t keep_num = 0;\n+\n+  G1CardSetBuffer* cur = _first;\n+  G1CardSetBuffer* last = nullptr;\n+\n+  while (cur != nullptr && _return_to_vm_size > 0) {\n+    size_t cur_size = cur->mem_size();\n+    _return_to_vm_size -= MIN2(_return_to_vm_size, cur_size);\n+\n+    keep_size += cur_size;\n+    keep_num++;\n+\n+    last = cur;\n+    cur = cur->next();\n+    \/\/ To ensure progress, perform the deadline check here.\n+    if (os::elapsed_counter() > deadline) {\n+      break;\n+    }\n+  }\n+\n+  assert(_first != nullptr, \"must be\");\n+  assert(last != nullptr, \"must be\");\n+\n+  last->set_next(nullptr);\n+\n+  \/\/ Wait for any in-progress pops to avoid ABA for them.\n+  GlobalCounter::write_synchronize();\n+  _source->bulk_add(*_first, *last, keep_num, keep_size);\n+  _first = cur;\n+\n+  log_trace(gc, task)(\"Card Set Free Memory: Returned to VM %zu buffers size %zu\", keep_num, keep_size);\n+\n+  \/\/ _return_to_vm_size may be larger than what is available in the list at the\n+  \/\/ time we actually get the list. I.e. the list and _return_to_vm_size may be\n+  \/\/ inconsistent.\n+  \/\/ So also check if we actually already at the end of the list for the exit\n+  \/\/ condition.\n+  if (_return_to_vm_size == 0 || _first == nullptr) {\n+    _source = nullptr;\n+    _return_to_vm_size = 0;\n+  }\n+  return _source != nullptr;\n+}\n+\n+bool G1CardSetFreePool::G1ReturnMemoryProcessor::return_to_os(jlong deadline) {\n+  assert(finished_return_to_vm(), \"not finished returning to VM\");\n+  assert(!finished_return_to_os(), \"already returned everything to the OS\");\n+\n+  \/\/ Now delete the rest.\n+  size_t num_delete = 0;\n+  size_t mem_size_deleted = 0;\n+\n+  while (_first != nullptr) {\n+    G1CardSetBuffer* next = _first->next();\n+    num_delete++;\n+    mem_size_deleted += _first->mem_size();\n+    delete _first;\n+    _first = next;\n+\n+    \/\/ To ensure progress, perform the deadline check here.\n+    if (os::elapsed_counter() > deadline) {\n+      break;\n+    }\n+  }\n+\n+  log_trace(gc, task)(\"Card Set Free Memory: Return to OS %zu buffers size %zu\", num_delete, mem_size_deleted);\n+\n+  return _first != nullptr;\n+}\n+\n+G1CardSetFreePool G1CardSetFreePool::_freelist_pool(G1CardSetConfiguration::num_mem_object_types());\n+\n+G1CardSetFreePool::G1CardSetFreePool(uint num_free_lists) :\n+  _num_free_lists(num_free_lists) {\n+\n+  _free_lists = NEW_C_HEAP_ARRAY(G1CardSetBufferList, _num_free_lists, mtGC);\n+  for (uint i = 0; i < _num_free_lists; i++) {\n+    new (&_free_lists[i]) G1CardSetBufferList();\n+  }\n+}\n+\n+G1CardSetFreePool::~G1CardSetFreePool() {\n+  for (uint i = 0; i < _num_free_lists; i++) {\n+    _free_lists[i].~G1CardSetBufferList();\n+  }\n+  FREE_C_HEAP_ARRAY(mtGC, _free_lists);\n+}\n+\n+G1CardSetBufferList* G1CardSetFreePool::free_list(uint i) {\n+  assert(i < _num_free_lists, \"must be\");\n+  return &_free_lists[i];\n+}\n+\n+G1CardSetMemoryStats G1CardSetFreePool::memory_sizes() const {\n+  G1CardSetMemoryStats free_list_stats;\n+  assert(free_list_stats.num_pools() == num_free_lists(), \"must be\");\n+  for (uint i = 0; i < num_free_lists(); i++) {\n+    free_list_stats._num_mem_sizes[i] = _free_lists[i].mem_size();\n+    free_list_stats._num_buffers[i] = _free_lists[i].num_buffers();\n+  }\n+  return free_list_stats;\n+}\n+\n+size_t G1CardSetFreePool::mem_size() const {\n+  size_t result = 0;\n+  for (uint i = 0; i < _num_free_lists; i++) {\n+    result += _free_lists[i].mem_size();\n+  }\n+  return result;\n+}\n+\n+void G1CardSetFreePool::print_on(outputStream* out) {\n+  out->print_cr(\"  Free Pool: size %zu\", free_list_pool()->mem_size());\n+  for (uint i = 0; i < _num_free_lists; i++) {\n+    FormatBuffer<> fmt(\"    %s\", G1CardSetConfiguration::mem_object_type_name_str(i));\n+    _free_lists[i].print_on(out, fmt);\n+  }\n+}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1SegmentedArrayFreePool.cpp","additions":200,"deletions":0,"binary":false,"changes":200,"status":"added"},{"patch":"@@ -0,0 +1,124 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+#ifndef SHARE_GC_G1_G1SEGMENTEDARRAYFREEPOOL_HPP\n+#define SHARE_GC_G1_G1SEGMENTEDARRAYFREEPOOL_HPP\n+\n+#include \"gc\/g1\/g1CardSet.hpp\"\n+#include \"gc\/g1\/g1SegmentedArray.hpp\"\n+#include \"utilities\/growableArray.hpp\"\n+\n+\/\/ Statistics for a fixed set of buffer lists. Contains the number of buffers and memory\n+\/\/ used for each. Note that statistics are typically not taken atomically so there\n+\/\/ can be inconsistencies. The user must be prepared for them.\n+class G1CardSetMemoryStats {\n+public:\n+\n+  size_t _num_mem_sizes[G1CardSetConfiguration::num_mem_object_types()];\n+  size_t _num_buffers[G1CardSetConfiguration::num_mem_object_types()];\n+\n+  \/\/ Returns all-zero statistics.\n+  G1CardSetMemoryStats();\n+\n+  void add(G1CardSetMemoryStats const other) {\n+    STATIC_ASSERT(ARRAY_SIZE(_num_buffers) == ARRAY_SIZE(_num_mem_sizes));\n+    for (uint i = 0; i < ARRAY_SIZE(_num_mem_sizes); i++) {\n+      _num_mem_sizes[i] += other._num_mem_sizes[i];\n+      _num_buffers[i] += other._num_buffers[i];\n+    }\n+  }\n+\n+  void clear();\n+\n+  uint num_pools() const { return G1CardSetConfiguration::num_mem_object_types(); }\n+};\n+\n+typedef G1SegmentedArrayBuffer<mtGCCardSet> G1CardSetBuffer;\n+typedef G1SegmentedArrayBufferList<mtGCCardSet> G1CardSetBufferList;\n+\n+\/\/ A set of free lists holding memory buffers for use by G1CardSetAllocators.\n+class G1CardSetFreePool {\n+  \/\/ The global free pool.\n+  static G1CardSetFreePool _freelist_pool;\n+\n+  const uint _num_free_lists;\n+  G1CardSetBufferList* _free_lists;\n+\n+public:\n+  static G1CardSetFreePool* free_list_pool() { return &_freelist_pool; }\n+  static G1CardSetMemoryStats free_list_sizes() { return _freelist_pool.memory_sizes(); }\n+\n+  class G1ReturnMemoryProcessor;\n+  typedef GrowableArrayCHeap<G1ReturnMemoryProcessor*, mtGC> G1ReturnMemoryProcessorSet;\n+\n+  static void update_unlink_processors(G1ReturnMemoryProcessorSet* unlink_processors);\n+\n+  explicit G1CardSetFreePool(uint num_free_lists);\n+  ~G1CardSetFreePool();\n+\n+  G1CardSetBufferList* free_list(uint i);\n+\n+  uint num_free_lists() const { return _num_free_lists; }\n+\n+  G1CardSetMemoryStats memory_sizes() const;\n+  size_t mem_size() const;\n+\n+  void print_on(outputStream* out);\n+};\n+\n+\/\/ Data structure containing current in-progress state for returning memory to the\n+\/\/ operating system for a single G1CardSetBufferList.\n+class G1CardSetFreePool::G1ReturnMemoryProcessor : public CHeapObj<mtGC> {\n+  G1CardSetBufferList* _source;\n+  size_t _return_to_vm_size;\n+\n+  G1CardSetBuffer* _first;\n+  size_t _unlinked_bytes;\n+  size_t _num_unlinked;\n+\n+public:\n+  explicit G1ReturnMemoryProcessor(size_t return_to_vm) :\n+    _source(nullptr), _return_to_vm_size(return_to_vm), _first(nullptr), _unlinked_bytes(0), _num_unlinked(0) {\n+  }\n+\n+  \/\/ Updates the instance members about the given card set buffer list for the purpose\n+  \/\/ of giving back memory. Only necessary members are updated, e.g. if there is\n+  \/\/ nothing to return to the VM, do not set the source list.\n+  void visit_free_list(G1CardSetBufferList* source);\n+\n+  bool finished_return_to_vm() const { return _return_to_vm_size == 0; }\n+  bool finished_return_to_os() const { return _first == nullptr; }\n+\n+  \/\/ Returns memory to the VM until the given deadline expires. Returns true if\n+  \/\/ there is no more work. Guarantees forward progress, i.e. at least one buffer\n+  \/\/ has been processed after returning.\n+  \/\/ return_to_vm() re-adds buffers to the respective free list.\n+  bool return_to_vm(jlong deadline);\n+  \/\/ Returns memory to the VM until the given deadline expires. Returns true if\n+  \/\/ there is no more work. Guarantees forward progress, i.e. at least one buffer\n+  \/\/ has been processed after returning.\n+  \/\/ return_to_os() gives back buffers to the OS.\n+  bool return_to_os(jlong deadline);\n+};\n+\n+#endif \/\/SHARE_GC_G1_G1SEGMENTEDARRAYFREEPOOL_HPP\n","filename":"src\/hotspot\/share\/gc\/g1\/g1SegmentedArrayFreePool.hpp","additions":124,"deletions":0,"binary":false,"changes":124,"status":"added"}]}