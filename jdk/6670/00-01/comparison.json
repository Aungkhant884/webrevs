{"files":[{"patch":"@@ -775,2 +775,8 @@\n-  if (is_range_check_if(iff, phase, T_INT, iv, range, offset, scale)) {\n-    if (!invar.is_invariant(range)) {\n+  if (!is_range_check_if(iff, phase, T_INT, iv, range, offset, scale)) {\n+    return false;\n+  }\n+  if (!invar.is_invariant(range)) {\n+    return false;\n+  }\n+  if (offset != NULL) {\n+    if (!invar.is_invariant(offset)) { \/\/ offset must be invariant\n@@ -779,2 +785,6 @@\n-    if (offset != NULL) {\n-      if (!invar.is_invariant(offset)) { \/\/ offset must be invariant\n+    Node* data_dependency_on = invar.data_dependency_on();\n+    if (data_dependency_on != NULL && old_unique_idx < C->unique()) {\n+      \/\/ 'offset' node was newly created in is_range_check_if(). Check that it does not depend on the entry projection\n+      \/\/ into the loop. If it does, we cannot perform loop predication (see Invariant::Invariant()).\n+      assert(!offset->is_CFG(), \"offset must be a data node\");\n+      if (_phase->get_ctrl(offset) == data_dependency_on) {\n@@ -783,9 +793,0 @@\n-      Node* data_dependency_on = invar.data_dependency_on();\n-      if (data_dependency_on != NULL && old_unique_idx < C->unique()) {\n-        \/\/ 'offset' node was newly created in is_range_check_if(). Check that it does not depend on the entry projection\n-        \/\/ into the loop. If it does, we cannot perform loop predication (see Invariant::Invariant()).\n-        assert(!offset->is_CFG(), \"offset must be a data node\");\n-        if (_phase->get_ctrl(offset) == data_dependency_on) {\n-          return false;\n-        }\n-      }\n@@ -793,0 +794,1 @@\n+  }\n@@ -794,12 +796,11 @@\n-    if (offset && phase->has_ctrl(offset)) {\n-      Node* offset_ctrl = phase->get_ctrl(offset);\n-      if (phase->get_loop(predicate_proj) == phase->get_loop(offset_ctrl) &&\n-          phase->is_dominator(predicate_proj, offset_ctrl)) {\n-        \/\/ If the control of offset is loop predication promoted by previous pass,\n-        \/\/ then it will lead to cyclic dependency.\n-        \/\/ Previously promoted loop predication is in the same loop of predication\n-        \/\/ point.\n-        \/\/ This situation can occur when pinning nodes too conservatively - can we do better?\n-        assert(false, \"cyclic dependency prevents range check elimination, idx: offset %d, offset_ctrl %d, predicate_proj %d\",\n-               offset->_idx, offset_ctrl->_idx, predicate_proj->_idx);\n-      }\n+  if (offset && phase->has_ctrl(offset)) {\n+    Node* offset_ctrl = phase->get_ctrl(offset);\n+    if (phase->get_loop(predicate_proj) == phase->get_loop(offset_ctrl) &&\n+        phase->is_dominator(predicate_proj, offset_ctrl)) {\n+      \/\/ If the control of offset is loop predication promoted by previous pass,\n+      \/\/ then it will lead to cyclic dependency.\n+      \/\/ Previously promoted loop predication is in the same loop of predication\n+      \/\/ point.\n+      \/\/ This situation can occur when pinning nodes too conservatively - can we do better?\n+      assert(false, \"cyclic dependency prevents range check elimination, idx: offset %d, offset_ctrl %d, predicate_proj %d\",\n+             offset->_idx, offset_ctrl->_idx, predicate_proj->_idx);\n@@ -807,2 +808,0 @@\n-#endif\n-    return true;\n@@ -810,1 +809,2 @@\n-  return false;\n+#endif\n+  return true;\n","filename":"src\/hotspot\/share\/opto\/loopPredicate.cpp","additions":28,"deletions":28,"binary":false,"changes":56,"status":"modified"}]}