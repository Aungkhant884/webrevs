{"files":[{"patch":"@@ -27,0 +27,1 @@\n+#include \"gc\/g1\/g1AnalyticsSequences.inline.hpp\"\n@@ -39,5 +40,0 @@\n-\/\/ all the same\n-static double rs_length_diff_defaults[] = {\n-  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0\n-};\n-\n@@ -49,1 +45,1 @@\n-static double young_card_merge_to_scan_ratio_defaults[] = {\n+static double young_card_scan_to_merge_ratio_defaults[] = {\n@@ -81,2 +77,0 @@\n-    _young_rs_length_diff_seq(new TruncatedSeq(TruncatedSeqLength)),\n-    _mixed_rs_length_diff_seq(new TruncatedSeq(TruncatedSeqLength)),\n@@ -85,14 +79,10 @@\n-    _young_card_scan_to_merge_ratio_seq(new TruncatedSeq(TruncatedSeqLength)),\n-    _mixed_card_scan_to_merge_ratio_seq(new TruncatedSeq(TruncatedSeqLength)),\n-    _young_cost_per_card_scan_ms_seq(new TruncatedSeq(TruncatedSeqLength)),\n-    _mixed_cost_per_card_scan_ms_seq(new TruncatedSeq(TruncatedSeqLength)),\n-    _young_cost_per_card_merge_ms_seq(new TruncatedSeq(TruncatedSeqLength)),\n-    _mixed_cost_per_card_merge_ms_seq(new TruncatedSeq(TruncatedSeqLength)),\n-    _copy_cost_per_byte_ms_seq(new TruncatedSeq(TruncatedSeqLength)),\n-    _constant_other_time_ms_seq(new TruncatedSeq(TruncatedSeqLength)),\n-    _young_other_cost_per_region_ms_seq(new TruncatedSeq(TruncatedSeqLength)),\n-    _non_young_other_cost_per_region_ms_seq(new TruncatedSeq(TruncatedSeqLength)),\n-    _young_pending_cards_seq(new TruncatedSeq(TruncatedSeqLength)),\n-    _mixed_pending_cards_seq(new TruncatedSeq(TruncatedSeqLength)),\n-    _young_rs_length_seq(new TruncatedSeq(TruncatedSeqLength)),\n-    _mixed_rs_length_seq(new TruncatedSeq(TruncatedSeqLength)),\n+    _card_scan_to_merge_ratio_seq(TruncatedSeqLength),\n+    _cost_per_card_scan_ms_seq(TruncatedSeqLength),\n+    _cost_per_card_merge_ms_seq(TruncatedSeqLength),\n+    _pending_cards_seq(TruncatedSeqLength),\n+    _rs_length_seq(TruncatedSeqLength),\n+    _rs_length_diff_seq(TruncatedSeqLength),\n+    _copy_cost_per_byte_ms_seq(TruncatedSeqLength),\n+    _constant_other_time_ms_seq(TruncatedSeqLength),\n+    _young_other_cost_per_region_ms_seq(TruncatedSeqLength),\n+    _non_young_other_cost_per_region_ms_seq(TruncatedSeqLength),\n@@ -110,1 +100,0 @@\n-  _young_rs_length_diff_seq->add(rs_length_diff_defaults[index]);\n@@ -115,2 +104,0 @@\n-  _young_card_scan_to_merge_ratio_seq->add(young_card_merge_to_scan_ratio_defaults[index]);\n-  _young_cost_per_card_scan_ms_seq->add(young_only_cost_per_card_scan_ms_defaults[index]);\n@@ -118,4 +105,9 @@\n-  _copy_cost_per_byte_ms_seq->add(cost_per_byte_ms_defaults[index]);\n-  _constant_other_time_ms_seq->add(constant_other_time_ms_defaults[index]);\n-  _young_other_cost_per_region_ms_seq->add(young_other_cost_per_region_ms_defaults[index]);\n-  _non_young_other_cost_per_region_ms_seq->add(non_young_other_cost_per_region_ms_defaults[index]);\n+  _card_scan_to_merge_ratio_seq.set_initial(young_card_scan_to_merge_ratio_defaults[index]);\n+  _cost_per_card_scan_ms_seq.set_initial(young_only_cost_per_card_scan_ms_defaults[index]);\n+  _rs_length_seq.set_initial(0);\n+  _rs_length_diff_seq.set_initial(0.0);\n+\n+  _copy_cost_per_byte_ms_seq.add(cost_per_byte_ms_defaults[index]);\n+  _constant_other_time_ms_seq.add(constant_other_time_ms_defaults[index]);\n+  _young_other_cost_per_region_ms_seq.add(young_other_cost_per_region_ms_defaults[index]);\n+  _non_young_other_cost_per_region_ms_seq.add(non_young_other_cost_per_region_ms_defaults[index]);\n@@ -128,1 +120,1 @@\n-bool G1Analytics::enough_samples_available(TruncatedSeq const* seq) const {\n+bool G1Analytics::enough_samples_available(TruncatedSeq const* seq) {\n@@ -136,4 +128,0 @@\n-size_t G1Analytics::predict_size(TruncatedSeq const* seq) const {\n-  return (size_t)predict_zero_bounded(seq);\n-}\n-\n@@ -144,0 +132,12 @@\n+double G1Analytics::predict_in_unit_interval(G1PhaseDependentSeq const* seq, bool for_young_only_phase) const {\n+  return clamp(seq->predict(_predictor, for_young_only_phase), 0.0, 1.0);\n+}\n+\n+size_t G1Analytics::predict_size(G1PhaseDependentSeq const* seq, bool for_young_only_phase) const {\n+  return (size_t)predict_zero_bounded(seq, for_young_only_phase);\n+}\n+\n+double G1Analytics::predict_zero_bounded(G1PhaseDependentSeq const* seq, bool for_young_only_phase) const {\n+  return MAX2(seq->predict(_predictor, for_young_only_phase), 0.0);\n+}\n+\n@@ -176,5 +176,1 @@\n-  if  (for_young_only_phase) {\n-    _young_cost_per_card_scan_ms_seq->add(cost_per_card_ms);\n-  } else {\n-    _mixed_cost_per_card_scan_ms_seq->add(cost_per_card_ms);\n-  }\n+  _cost_per_card_scan_ms_seq.add(cost_per_card_ms, for_young_only_phase);\n@@ -184,5 +180,1 @@\n-  if  (for_young_only_phase) {\n-    _young_cost_per_card_merge_ms_seq->add(cost_per_card_ms);\n-  } else {\n-    _mixed_cost_per_card_merge_ms_seq->add(cost_per_card_ms);\n-  }\n+  _cost_per_card_merge_ms_seq.add(cost_per_card_ms, for_young_only_phase);\n@@ -192,5 +184,1 @@\n-  if (for_young_only_phase) {\n-    _young_card_scan_to_merge_ratio_seq->add(merge_to_scan_ratio);\n-  } else {\n-    _mixed_card_scan_to_merge_ratio_seq->add(merge_to_scan_ratio);\n-  }\n+  _card_scan_to_merge_ratio_seq.add(merge_to_scan_ratio, for_young_only_phase);\n@@ -200,5 +188,1 @@\n-  if  (for_young_only_phase) {\n-    _young_rs_length_diff_seq->add(rs_length_diff);\n-  } else {\n-    _mixed_rs_length_diff_seq->add(rs_length_diff);\n-  }\n+  _rs_length_diff_seq.add(rs_length_diff, for_young_only_phase);\n@@ -211,1 +195,1 @@\n-    _copy_cost_per_byte_ms_seq->add(cost_per_byte_ms);\n+    _copy_cost_per_byte_ms_seq.add(cost_per_byte_ms);\n@@ -216,1 +200,1 @@\n-  _young_other_cost_per_region_ms_seq->add(other_cost_per_region_ms);\n+  _young_other_cost_per_region_ms_seq.add(other_cost_per_region_ms);\n@@ -220,1 +204,1 @@\n-  _non_young_other_cost_per_region_ms_seq->add(other_cost_per_region_ms);\n+  _non_young_other_cost_per_region_ms_seq.add(other_cost_per_region_ms);\n@@ -224,1 +208,1 @@\n-  _constant_other_time_ms_seq->add(constant_other_time_ms);\n+  _constant_other_time_ms_seq.add(constant_other_time_ms);\n@@ -228,5 +212,1 @@\n-  if  (for_young_only_phase) {\n-    _young_pending_cards_seq->add(pending_cards);\n-  } else {\n-    _mixed_pending_cards_seq->add(pending_cards);\n-  }\n+  _pending_cards_seq.add(pending_cards, for_young_only_phase);\n@@ -236,5 +216,1 @@\n-  if  (for_young_only_phase) {\n-    _young_rs_length_seq->add(rs_length);\n-  } else {\n-    _mixed_rs_length_seq->add(rs_length);\n-  }\n+  _rs_length_seq.add(rs_length, for_young_only_phase);\n@@ -260,5 +236,1 @@\n-  if (for_young_only_phase || !enough_samples_available(_mixed_card_scan_to_merge_ratio_seq)) {\n-    return (size_t)(rs_length * predict_in_unit_interval(_young_card_scan_to_merge_ratio_seq));\n-  } else {\n-    return (size_t)(rs_length * predict_in_unit_interval(_mixed_card_scan_to_merge_ratio_seq));\n-  }\n+  return rs_length * predict_in_unit_interval(&_card_scan_to_merge_ratio_seq, for_young_only_phase);\n@@ -268,5 +240,1 @@\n-  if  (for_young_only_phase || !enough_samples_available(_mixed_cost_per_card_merge_ms_seq)) {\n-    return card_num * predict_zero_bounded(_young_cost_per_card_merge_ms_seq);\n-  } else {\n-    return card_num * predict_zero_bounded(_mixed_cost_per_card_merge_ms_seq);\n-  }\n+  return card_num * predict_zero_bounded(&_cost_per_card_merge_ms_seq, for_young_only_phase);\n@@ -276,5 +244,1 @@\n-  if  (for_young_only_phase || !enough_samples_available(_mixed_cost_per_card_scan_ms_seq)) {\n-    return card_num * predict_zero_bounded(_young_cost_per_card_scan_ms_seq);\n-  } else {\n-    return card_num * predict_zero_bounded(_mixed_cost_per_card_scan_ms_seq);\n-  }\n+  return card_num * predict_zero_bounded(&_cost_per_card_scan_ms_seq, for_young_only_phase);\n@@ -285,1 +249,1 @@\n-    return (1.1 * bytes_to_copy) * predict_zero_bounded(_copy_cost_per_byte_ms_seq);\n+    return (1.1 * bytes_to_copy) * predict_zero_bounded(&_copy_cost_per_byte_ms_seq);\n@@ -295,1 +259,1 @@\n-    return bytes_to_copy * predict_zero_bounded(_copy_cost_per_byte_ms_seq);\n+    return bytes_to_copy * predict_zero_bounded(&_copy_cost_per_byte_ms_seq);\n@@ -300,1 +264,1 @@\n-  return predict_zero_bounded(_constant_other_time_ms_seq);\n+  return predict_zero_bounded(&_constant_other_time_ms_seq);\n@@ -304,1 +268,1 @@\n-  return young_num * predict_zero_bounded(_young_other_cost_per_region_ms_seq);\n+  return young_num * predict_zero_bounded(&_young_other_cost_per_region_ms_seq);\n@@ -308,1 +272,1 @@\n-  return non_young_num * predict_zero_bounded(_non_young_other_cost_per_region_ms_seq);\n+  return non_young_num * predict_zero_bounded(&_non_young_other_cost_per_region_ms_seq);\n@@ -320,5 +284,2 @@\n-  if  (for_young_only_phase || !enough_samples_available(_mixed_rs_length_seq)) {\n-    return predict_size(_young_rs_length_seq) + predict_size(_young_rs_length_diff_seq);\n-  } else {\n-    return predict_size(_mixed_rs_length_seq) + predict_size(_mixed_rs_length_diff_seq);\n-  }\n+  return predict_size(&_rs_length_seq, for_young_only_phase) +\n+    predict_size(&_rs_length_diff_seq, for_young_only_phase);\n@@ -328,5 +289,1 @@\n-  if (for_young_only_phase || !enough_samples_available(_mixed_pending_cards_seq)) {\n-    return predict_size(_young_pending_cards_seq);\n-  } else {\n-    return predict_size(_mixed_pending_cards_seq);\n-  }\n+  return predict_size(&_pending_cards_seq, for_young_only_phase);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Analytics.cpp","additions":55,"deletions":98,"binary":false,"changes":153,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"gc\/g1\/g1AnalyticsSequences.hpp\"\n@@ -48,2 +49,0 @@\n-  TruncatedSeq* _young_rs_length_diff_seq;\n-  TruncatedSeq* _mixed_rs_length_diff_seq;\n@@ -54,2 +53,1 @@\n-  TruncatedSeq* _young_card_scan_to_merge_ratio_seq;\n-  TruncatedSeq* _mixed_card_scan_to_merge_ratio_seq;\n+  G1PhaseDependentSeq _card_scan_to_merge_ratio_seq;\n@@ -58,2 +56,1 @@\n-  TruncatedSeq* _young_cost_per_card_scan_ms_seq;\n-  TruncatedSeq* _mixed_cost_per_card_scan_ms_seq;\n+  G1PhaseDependentSeq _cost_per_card_scan_ms_seq;\n@@ -62,2 +59,1 @@\n-  TruncatedSeq* _young_cost_per_card_merge_ms_seq;\n-  TruncatedSeq* _mixed_cost_per_card_merge_ms_seq;\n+  G1PhaseDependentSeq _cost_per_card_merge_ms_seq;\n@@ -65,5 +61,3 @@\n-  \/\/ The cost to copy a byte in ms.\n-  TruncatedSeq* _copy_cost_per_byte_ms_seq;\n-  TruncatedSeq* _constant_other_time_ms_seq;\n-  TruncatedSeq* _young_other_cost_per_region_ms_seq;\n-  TruncatedSeq* _non_young_other_cost_per_region_ms_seq;\n+  G1PhaseDependentSeq _pending_cards_seq;\n+  G1PhaseDependentSeq _rs_length_seq;\n+  G1PhaseDependentSeq _rs_length_diff_seq;\n@@ -71,4 +65,5 @@\n-  TruncatedSeq* _young_pending_cards_seq;\n-  TruncatedSeq* _mixed_pending_cards_seq;\n-  TruncatedSeq* _young_rs_length_seq;\n-  TruncatedSeq* _mixed_rs_length_seq;\n+  \/\/ The cost to copy a byte in ms.\n+  TruncatedSeq _copy_cost_per_byte_ms_seq;\n+  TruncatedSeq _constant_other_time_ms_seq;\n+  TruncatedSeq _young_other_cost_per_region_ms_seq;\n+  TruncatedSeq _non_young_other_cost_per_region_ms_seq;\n@@ -86,4 +81,0 @@\n-  \/\/ Returns whether the sequence have enough samples to get a \"good\" prediction.\n-  \/\/ The constant used is random but \"small\".\n-  bool enough_samples_available(TruncatedSeq const* seq) const;\n-\n@@ -91,1 +82,0 @@\n-  size_t predict_size(TruncatedSeq const* seq) const;\n@@ -94,0 +84,4 @@\n+  double predict_in_unit_interval(G1PhaseDependentSeq const* seq, bool for_young_only_phase) const;\n+  size_t predict_size(G1PhaseDependentSeq const* seq, bool for_young_only_phase) const;\n+  double predict_zero_bounded(G1PhaseDependentSeq const* seq, bool for_young_only_phase) const;\n+\n@@ -100,0 +94,4 @@\n+  \/\/ Returns whether the sequence have enough samples to get a \"good\" prediction.\n+  \/\/ The constant used is random but \"small\".\n+  static bool enough_samples_available(TruncatedSeq const* seq);\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Analytics.hpp","additions":20,"deletions":22,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_G1_G1ANALYTICSSEQUENCES_HPP\n+#define SHARE_GC_G1_G1ANALYTICSSEQUENCES_HPP\n+\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/numberSeq.hpp\"\n+\n+#include <float.h>\n+\n+class G1Predictions;\n+\n+\/\/ Container for TruncatedSeqs that need separate predictors by GC phase.\n+class G1PhaseDependentSeq {\n+  TruncatedSeq _young_only_seq;\n+  TruncatedSeq _mixed_seq;\n+\n+  NONCOPYABLE(G1PhaseDependentSeq);\n+\n+  TruncatedSeq* seq_raw(bool use_young_only_phase_seq);\n+\n+  bool enough_samples_to_use_mixed_seq() const;\n+public:\n+\n+  G1PhaseDependentSeq(int length);\n+\n+  void set_initial(double value);\n+  void add(double value, bool for_young_only_phase);\n+\n+  double predict(const G1Predictions* predictor, bool use_young_only_phase_seq) const;\n+};\n+\n+#endif \/* SHARE_GC_G1_G1ANALYTICSSEQUENCES_HPP *\/\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1AnalyticsSequences.hpp","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -0,0 +1,61 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_G1_G1ANALYTICSSEQUENCES_INLINE_HPP\n+#define SHARE_GC_G1_G1ANALYTICSSEQUENCES_INLINE_HPP\n+\n+#include \"gc\/g1\/g1AnalyticsSequences.hpp\"\n+#include \"gc\/g1\/g1Predictions.hpp\"\n+\n+bool G1PhaseDependentSeq::enough_samples_to_use_mixed_seq() const {\n+  return G1Analytics::enough_samples_available(&_mixed_seq);\n+}\n+\n+G1PhaseDependentSeq::G1PhaseDependentSeq(int length) :\n+  _young_only_seq(length),\n+  _mixed_seq(length)\n+{ }\n+\n+TruncatedSeq* G1PhaseDependentSeq::seq_raw(bool use_young_only_phase_seq) {\n+  return use_young_only_phase_seq ? &_young_only_seq : &_mixed_seq;\n+}\n+\n+void G1PhaseDependentSeq::set_initial(double value) {\n+  _young_only_seq.add(value);\n+}\n+\n+void G1PhaseDependentSeq::add(double value, bool for_young_only_phase) {\n+  seq_raw(for_young_only_phase)->add(value);\n+}\n+\n+double G1PhaseDependentSeq::predict(const G1Predictions* predictor, bool use_young_only_phase_seq) const {\n+  if (use_young_only_phase_seq || !enough_samples_to_use_mixed_seq()) {\n+    return predictor->predict(&_young_only_seq);\n+  } else {\n+    return predictor->predict(&_mixed_seq);\n+  }\n+}\n+\n+#endif \/* SHARE_GC_G1_G1ANALYTICSSEQUENCES_INLINE_HPP *\/\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1AnalyticsSequences.inline.hpp","additions":61,"deletions":0,"binary":false,"changes":61,"status":"added"}]}