{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -89,0 +89,7 @@\n+\n+    \/\/ The IR framework will compile this method with C1 at level 2 (with limited profiling information) after the\n+    \/\/ warm-up iterations are done.\n+    @Test(compLevel = CompLevel.C1_LIMITED_PROFILE)\n+    public void basicTestCompileWithC1() {\n+        iFld = 34;\n+    }\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/ir_framework\/examples\/BaseTestExample.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -104,1 +104,1 @@\n-    \/\/ This version of @Run passes the RunInfo object as an argument. No other arguments and combiniations are allowed.\n+    \/\/ This version of @Run passes the RunInfo object as an argument. No other arguments and combinations are allowed.\n@@ -106,2 +106,7 @@\n-    public void runWithRunInfo() {\n-        \/\/ We could also skip some invocations. This might have an influence on possible @IR rules, need to be careful.\n+    public void runWithRunInfo(RunInfo runInfo) {\n+        \/\/ We could invoke a test multiple times or even skip some invocations completely. This might have an influence\n+        \/\/ on profiling and possible @IR rules as the graph could be different.\n+        if (runInfo.isWarmUp()) {\n+            \/\/ Do something only when warming this method up (i.e. the IR framework has not queued this method for\n+            \/\/ compilation, yet).\n+        }\n@@ -109,1 +114,1 @@\n-            int returnValue = test(34);\n+            int returnValue = test2(34);\n@@ -131,0 +136,17 @@\n+    @Test\n+    public int test3a(int x) {\n+        return x;\n+    }\n+\n+    \/\/ To simulate -Xcomp, we can specify a zero warm-up. The IR framework directly compiles the @Test method test3a()\n+    \/\/ before any invocation of it (called over this @Run method). Afterwards the IR framework invokes the @Run method\n+    \/\/ exactly once.\n+    @Run(test = \"test3a\")\n+    @Warmup(0)\n+    public void runSimulateXcomp() {\n+        int returnValue = test3a(34);\n+        if (returnValue != 34) {\n+            throw new RuntimeException(\"Must match\");\n+        }\n+    }\n+\n@@ -168,0 +190,25 @@\n+\n+    @Test\n+    public int test7(int x) {\n+        return x;\n+    }\n+\n+    \/\/ RunMode.STANDALONE gives the user full control over how the associated @Test method is compiled: The IR framework\n+    \/\/ only invokes this @Run method once, without any additional warm-up iterations, and does NOT initiate a compilation.\n+    \/\/ This is entirely left to the @Run method to do. When also doing IR matching, it needs to be ensured that a C2\n+    \/\/ compilation is triggered. Otherwise, IR matching will fail due to a missing C2 compilation output to match on.\n+    @Run(test = \"test7\", mode = RunMode.STANDALONE)\n+    public void run() {\n+        final int interpreterResult = test7(34); \/\/ First invocation of test7() with interpreter\n+        int compiledResult = 0;\n+        for (int i = 0; i < 10000; i++) {\n+            compiledResult = test7(34); \/\/ At some point, test7() is normally C1 and C2 compiled.\n+            if (interpreterResult != compiledResult) {\n+                \/\/ At some point, compiledResult is the value returned by C1 compiled code and later C2 compiled code\n+                \/\/ of test7(). These values should always match the value returned by the interpreter.\n+                throw new RuntimeException(\"Different result compared to interpreter run\");\n+            }\n+        }\n+        \/\/ At this point, test7() is definitely C2 compiled due to the high number of invocations in the loop above.\n+        \/\/ There is not further invocation of this method (and hence of test7()).\n+    }\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/ir_framework\/examples\/CustomRunTestExample.java","additions":52,"deletions":5,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -181,0 +181,16 @@\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE_I, \"1\"}) \/\/ Should work but since we do not invoke the method enough times, we fail.\n+    public void testNotCompiled() {\n+        iFld2 = 34;\n+    }\n+\n+    \/\/ RunMode.STANDALONE gives the user full control over how the associated @Test method is compiled: The IR framework\n+    \/\/ only invokes this @Run method once, without any additional warm-up iterations, and does NOT initiate a compilation.\n+    \/\/ This is entirely left to the @Run method to do. Since we invoke the @Test method testNotCompiled() only once, this\n+    \/\/ is not enough to normally trigger a C2 compilation. IR matching fails since there is no C2 compilation output.\n+    \/\/ To fix that, we would need to invoke testNotCompiled() enough times to trigger a C2 compilation.\n+    @Run(test = \"testNotCompiled\", mode = RunMode.STANDALONE)\n+    public void badStandAloneNotCompiled() {\n+        testNotCompiled();\n+    }\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/ir_framework\/examples\/IRExample.java","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"}]}