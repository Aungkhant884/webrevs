{"files":[{"patch":"@@ -278,0 +278,2 @@\n+    elif test \"x$OPENJDK_TARGET_CPU\" = \"xriscv64\"; then\n+      AC_MSG_RESULT([yes])\n","filename":"make\/autoconf\/jvm-features.m4","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,128 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"asm\/macroAssembler.hpp\"\n+#include \"jvmci\/jvmci.hpp\"\n+#include \"jvmci\/jvmciCodeInstaller.hpp\"\n+#include \"jvmci\/jvmciRuntime.hpp\"\n+#include \"jvmci\/jvmciCompilerToVM.hpp\"\n+#include \"jvmci\/jvmciJavaClasses.hpp\"\n+#include \"oops\/oop.inline.hpp\"\n+#include \"runtime\/handles.inline.hpp\"\n+#include \"runtime\/jniHandles.hpp\"\n+#include \"runtime\/sharedRuntime.hpp\"\n+#include \"vmreg_riscv.inline.hpp\"\n+\n+jint CodeInstaller::pd_next_offset(NativeInstruction* inst, jint pc_offset, JVMCI_TRAPS) {\n+  address pc = (address) inst;\n+  if (inst->is_call()) {\n+    return pc_offset + NativeCall::instruction_size;\n+  } else if (inst->is_jump()) {\n+    return pc_offset + NativeJump::instruction_size;\n+  } else if (inst->is_movptr()) {\n+    return pc_offset + NativeMovConstReg::movptr_instruction_size;\n+  } else {\n+    JVMCI_ERROR_0(\"unsupported type of instruction for call site\");\n+  }\n+}\n+\n+void CodeInstaller::pd_patch_OopConstant(int pc_offset, Handle& obj, bool compressed, JVMCI_TRAPS) {\n+  address pc = _instructions->start() + pc_offset;\n+  jobject value = JNIHandles::make_local(obj());\n+  MacroAssembler::patch_oop(pc, cast_from_oop<address>(obj()));\n+  int oop_index = _oop_recorder->find_index(value);\n+  RelocationHolder rspec = oop_Relocation::spec(oop_index);\n+  _instructions->relocate(pc, rspec);\n+}\n+\n+void CodeInstaller::pd_patch_MetaspaceConstant(int pc_offset, HotSpotCompiledCodeStream* stream, u1 tag, JVMCI_TRAPS) {\n+  address pc = _instructions->start() + pc_offset;\n+  if (tag == PATCH_NARROW_KLASS) {\n+    narrowKlass narrowOop = record_narrow_metadata_reference(_instructions, pc, stream, tag, JVMCI_CHECK);\n+    MacroAssembler::pd_patch_instruction_size(pc, (address) (long) narrowOop);\n+    JVMCI_event_3(\"relocating (narrow metaspace constant) at \" PTR_FORMAT \"\/0x%x\", p2i(pc), narrowOop);\n+  } else {\n+    NativeMovConstReg* move = nativeMovConstReg_at(pc);\n+    void* reference = record_metadata_reference(_instructions, pc, stream, tag, JVMCI_CHECK);\n+    move->set_data((intptr_t) reference);\n+    JVMCI_event_3(\"relocating (metaspace constant) at \" PTR_FORMAT \"\/\" PTR_FORMAT, p2i(pc), p2i(reference));\n+  }\n+}\n+\n+void CodeInstaller::pd_patch_DataSectionReference(int pc_offset, int data_offset, JVMCI_TRAPS) {\n+  address pc = _instructions->start() + pc_offset;\n+  address dest = _constants->start() + data_offset;\n+  _instructions->relocate(pc, section_word_Relocation::spec((address) dest, CodeBuffer::SECT_CONSTS));\n+  JVMCI_event_3(\"relocating at \" PTR_FORMAT \" (+%d) with destination at %d\", p2i(pc), pc_offset, data_offset);\n+}\n+\n+void CodeInstaller::pd_relocate_ForeignCall(NativeInstruction* inst, jlong foreign_call_destination, JVMCI_TRAPS) {\n+  address pc = (address) inst;\n+  if (inst->is_jal()) {\n+    NativeCall* call = nativeCall_at(pc);\n+    call->set_destination((address) foreign_call_destination);\n+    _instructions->relocate(call->instruction_address(), runtime_call_Relocation::spec());\n+  } else if (inst->is_jump()) {\n+    NativeJump* jump = nativeJump_at(pc);\n+    jump->set_jump_destination((address) foreign_call_destination);\n+    _instructions->relocate(jump->instruction_address(), runtime_call_Relocation::spec());\n+  } else if (inst->is_movptr()) {\n+    NativeMovConstReg* movptr = nativeMovConstReg_at(pc);\n+    movptr->set_data((intptr_t) foreign_call_destination);\n+    _instructions->relocate(movptr->instruction_address(), runtime_call_Relocation::spec());\n+  } else {\n+    JVMCI_ERROR(\"unknown call or jump instruction at \" PTR_FORMAT, p2i(pc));\n+  }\n+  JVMCI_event_3(\"relocating (foreign call) at \" PTR_FORMAT, p2i(inst));\n+}\n+\n+void CodeInstaller::pd_relocate_JavaMethod(CodeBuffer &cbuf, methodHandle& method, jint pc_offset, JVMCI_TRAPS) {\n+  Unimplemented();\n+}\n+\n+void CodeInstaller::pd_relocate_poll(address pc, jint mark, JVMCI_TRAPS) {\n+  Unimplemented();\n+}\n+\n+\/\/ convert JVMCI register indices (as used in oop maps) to HotSpot registers\n+VMReg CodeInstaller::get_hotspot_reg(jint jvmci_reg, JVMCI_TRAPS) {\n+  if (jvmci_reg < RegisterImpl::number_of_registers) {\n+    return as_Register(jvmci_reg)->as_VMReg();\n+  } else {\n+    jint floatRegisterNumber = jvmci_reg - RegisterImpl::number_of_registers;\n+    if (floatRegisterNumber >= 0 && floatRegisterNumber < FloatRegisterImpl::number_of_registers) {\n+      return as_FloatRegister(floatRegisterNumber)->as_VMReg();\n+    }\n+    jint vectorRegisterNumber = floatRegisterNumber - FloatRegisterImpl::number_of_registers;\n+    if (vectorRegisterNumber >= 0 && vectorRegisterNumber - VectorRegisterImpl::number_of_registers) {\n+      return as_VectorRegister(vectorRegisterNumber)->as_VMReg();\n+    }\n+    JVMCI_ERROR_NULL(\"invalid register number: %d\", jvmci_reg);\n+  }\n+}\n+\n+bool CodeInstaller::is_general_purpose_reg(VMReg hotspotRegister) {\n+  return !(hotspotRegister->is_FloatRegister() || hotspotRegister->is_VectorRegister());\n+}\n","filename":"src\/hotspot\/cpu\/riscv\/jvmciCodeInstaller_riscv.cpp","additions":128,"deletions":0,"binary":false,"changes":128,"status":"added"},{"patch":"@@ -59,0 +59,3 @@\n+#if INCLUDE_JVMCI\n+#include \"jvmci\/jvmciJavaClasses.hpp\"\n+#endif\n@@ -213,0 +216,3 @@\n+#if !INCLUDE_JVMCI\n+  assert(!_save_vectors, \"vectors are generated only by C2 and JVMCI\");\n+#endif\n@@ -512,0 +518,12 @@\n+#if INCLUDE_JVMCI\n+  if (EnableJVMCI) {\n+    \/\/ check if this call should be routed towards a specific entry point\n+    __ ld(t0, Address(xthread, in_bytes(JavaThread::jvmci_alternate_call_target_offset())));\n+    Label no_alternative_target;\n+    __ beqz(t0, no_alternative_target);\n+    __ mv(t1, t0);\n+    __ sd(zr, Address(xthread, in_bytes(JavaThread::jvmci_alternate_call_target_offset())));\n+    __ bind(no_alternative_target);\n+  }\n+#endif \/\/ INCLUDE_JVMCI\n+\n@@ -1891,0 +1909,5 @@\n+#if INCLUDE_JVMCI\n+  if (EnableJVMCI) {\n+    pad += 512; \/\/ Increase the buffer size when compiling for JVMCI\n+  }\n+#endif\n@@ -1942,0 +1965,6 @@\n+#if INCLUDE_JVMCI && !defined(COMPILER1)\n+  if (EnableJVMCI && UseJVMCICompiler) {\n+    \/\/ JVMCI does not use this kind of deoptimization\n+    __ should_not_reach_here();\n+  }\n+#endif\n@@ -1952,0 +1981,38 @@\n+#if INCLUDE_JVMCI\n+  Label after_fetch_unroll_info_call;\n+  int implicit_exception_uncommon_trap_offset = 0;\n+  int uncommon_trap_offset = 0;\n+\n+  if (EnableJVMCI) {\n+    implicit_exception_uncommon_trap_offset = __ pc() - start;\n+\n+    __ ld(ra, Address(xthread, in_bytes(JavaThread::jvmci_implicit_exception_pc_offset())));\n+    __ sd(zr, Address(xthread, in_bytes(JavaThread::jvmci_implicit_exception_pc_offset())));\n+\n+    uncommon_trap_offset = __ pc() - start;\n+\n+    \/\/ Save everything in sight.\n+    reg_saver.save_live_registers(masm, 0, &frame_size_in_words);\n+    \/\/ fetch_unroll_info needs to call last_java_frame()\n+    Label retaddr;\n+    __ set_last_Java_frame(sp, noreg, retaddr, t0);\n+\n+    __ lwu(c_rarg1, Address(xthread, in_bytes(JavaThread::pending_deoptimization_offset())));\n+    __ mvw(t0, -1);\n+    __ sw(t0, Address(xthread, in_bytes(JavaThread::pending_deoptimization_offset())));\n+\n+    __ mvw(xcpool, (int32_t)Deoptimization::Unpack_reexecute);\n+    __ mv(c_rarg0, xthread);\n+    __ orrw(c_rarg2, zr, xcpool); \/\/ exec mode\n+    int32_t offset = 0;\n+    __ la_patchable(t0, RuntimeAddress(CAST_FROM_FN_PTR(address, Deoptimization::uncommon_trap)), offset);\n+    __ jalr(x1, t0, offset);\n+    __ bind(retaddr);\n+    oop_maps->add_gc_map( __ pc()-start, map->deep_copy());\n+\n+    __ reset_last_Java_frame(false);\n+\n+    __ j(after_fetch_unroll_info_call);\n+  } \/\/ EnableJVMCI\n+#endif \/\/ INCLUDE_JVMCI\n+\n@@ -2045,0 +2112,6 @@\n+#if INCLUDE_JVMCI\n+  if (EnableJVMCI) {\n+    __ bind(after_fetch_unroll_info_call);\n+  }\n+#endif\n+\n@@ -2200,0 +2273,6 @@\n+#if INCLUDE_JVMCI\n+  if (EnableJVMCI) {\n+    _deopt_blob->set_uncommon_trap_offset(uncommon_trap_offset);\n+    _deopt_blob->set_implicit_exception_uncommon_trap_offset(implicit_exception_uncommon_trap_offset);\n+  }\n+#endif\n","filename":"src\/hotspot\/cpu\/riscv\/sharedRuntime_riscv.cpp","additions":79,"deletions":0,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -345,1 +345,1 @@\n-  static int trap_request_index(int trap_request) {\n+  static int RISCV64_ONLY(__attribute__ ((noinline))) trap_request_index(int trap_request) {\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,161 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.vm.ci.hotspot.riscv64;\n+\n+import static java.util.Collections.emptyMap;\n+import static jdk.vm.ci.common.InitTimer.timer;\n+\n+import java.util.EnumSet;\n+import java.util.Map;\n+\n+import jdk.vm.ci.riscv64.RISCV64;\n+import jdk.vm.ci.riscv64.RISCV64.CPUFeature;\n+import jdk.vm.ci.code.Architecture;\n+import jdk.vm.ci.code.RegisterConfig;\n+import jdk.vm.ci.code.TargetDescription;\n+import jdk.vm.ci.code.stack.StackIntrospection;\n+import jdk.vm.ci.common.InitTimer;\n+import jdk.vm.ci.hotspot.HotSpotCodeCacheProvider;\n+import jdk.vm.ci.hotspot.HotSpotConstantReflectionProvider;\n+import jdk.vm.ci.hotspot.HotSpotJVMCIBackendFactory;\n+import jdk.vm.ci.hotspot.HotSpotJVMCIRuntime;\n+import jdk.vm.ci.hotspot.HotSpotMetaAccessProvider;\n+import jdk.vm.ci.hotspot.HotSpotStackIntrospection;\n+import jdk.vm.ci.meta.ConstantReflectionProvider;\n+import jdk.vm.ci.runtime.JVMCIBackend;\n+\n+public class RISCV64HotSpotJVMCIBackendFactory implements HotSpotJVMCIBackendFactory {\n+\n+    private static EnumSet<RISCV64.CPUFeature> computeFeatures(RISCV64HotSpotVMConfig config) {\n+        \/\/ Configure the feature set using the HotSpot flag settings.\n+        Map<String, Long> constants = config.getStore().getConstants();\n+        return HotSpotJVMCIBackendFactory.convertFeatures(CPUFeature.class, constants, config.vmVersionFeatures, emptyMap());\n+    }\n+\n+    private static EnumSet<RISCV64.Flag> computeFlags(RISCV64HotSpotVMConfig config) {\n+        EnumSet<RISCV64.Flag> flags = EnumSet.noneOf(RISCV64.Flag.class);\n+\n+        if (config.useConservativeFence) {\n+            flags.add(RISCV64.Flag.UseConservativeFence);\n+        }\n+        if (config.avoidUnalignedAccesses) {\n+            flags.add(RISCV64.Flag.AvoidUnalignedAccesses);\n+        }\n+        if (config.nearCpool) {\n+            flags.add(RISCV64.Flag.NearCpool);\n+        }\n+        if (config.traceTraps) {\n+            flags.add(RISCV64.Flag.TraceTraps);\n+        }\n+        if (config.useRVV) {\n+            flags.add(RISCV64.Flag.UseRVV);\n+        }\n+        if (config.useRVC) {\n+            flags.add(RISCV64.Flag.UseRVC);\n+        }\n+        if (config.useZba) {\n+            flags.add(RISCV64.Flag.UseZba);\n+        }\n+        if (config.useZbb) {\n+            flags.add(RISCV64.Flag.UseZbb);\n+        }\n+        if (config.useRVVForBigIntegerShiftIntrinsics) {\n+            flags.add(RISCV64.Flag.UseRVVForBigIntegerShiftIntrinsics);\n+        }\n+\n+        return flags;\n+    }\n+\n+    private static TargetDescription createTarget(RISCV64HotSpotVMConfig config) {\n+        final int stackFrameAlignment = 16;\n+        final int implicitNullCheckLimit = 4096;\n+        final boolean inlineObjects = true;\n+        Architecture arch = new RISCV64(computeFeatures(config), computeFlags(config));\n+        return new TargetDescription(arch, true, stackFrameAlignment, implicitNullCheckLimit, inlineObjects);\n+    }\n+\n+    protected HotSpotConstantReflectionProvider createConstantReflection(HotSpotJVMCIRuntime runtime) {\n+        return new HotSpotConstantReflectionProvider(runtime);\n+    }\n+\n+    private static RegisterConfig createRegisterConfig(RISCV64HotSpotVMConfig config, TargetDescription target) {\n+        return new RISCV64HotSpotRegisterConfig(target, config.useCompressedOops, config.linuxOs);\n+    }\n+\n+    protected HotSpotCodeCacheProvider createCodeCache(HotSpotJVMCIRuntime runtime, TargetDescription target, RegisterConfig regConfig) {\n+        return new HotSpotCodeCacheProvider(runtime, target, regConfig);\n+    }\n+\n+    protected HotSpotMetaAccessProvider createMetaAccess(HotSpotJVMCIRuntime runtime) {\n+        return new HotSpotMetaAccessProvider(runtime);\n+    }\n+\n+    @Override\n+    public String getArchitecture() {\n+        return \"riscv64\";\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"JVMCIBackend:\" + getArchitecture();\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"try\")\n+    public JVMCIBackend createJVMCIBackend(HotSpotJVMCIRuntime runtime, JVMCIBackend host) {\n+        assert host == null;\n+        RISCV64HotSpotVMConfig config = new RISCV64HotSpotVMConfig(runtime.getConfigStore());\n+        TargetDescription target = createTarget(config);\n+\n+        RegisterConfig regConfig;\n+        HotSpotCodeCacheProvider codeCache;\n+        ConstantReflectionProvider constantReflection;\n+        HotSpotMetaAccessProvider metaAccess;\n+        StackIntrospection stackIntrospection;\n+        try (InitTimer t = timer(\"create providers\")) {\n+            try (InitTimer rt = timer(\"create MetaAccess provider\")) {\n+                metaAccess = createMetaAccess(runtime);\n+            }\n+            try (InitTimer rt = timer(\"create RegisterConfig\")) {\n+                regConfig = createRegisterConfig(config, target);\n+            }\n+            try (InitTimer rt = timer(\"create CodeCache provider\")) {\n+                codeCache = createCodeCache(runtime, target, regConfig);\n+            }\n+            try (InitTimer rt = timer(\"create ConstantReflection provider\")) {\n+                constantReflection = createConstantReflection(runtime);\n+            }\n+            try (InitTimer rt = timer(\"create StackIntrospection provider\")) {\n+                stackIntrospection = new HotSpotStackIntrospection(runtime);\n+            }\n+        }\n+        try (InitTimer rt = timer(\"instantiate backend\")) {\n+            return createBackend(metaAccess, codeCache, constantReflection, stackIntrospection);\n+        }\n+    }\n+\n+    protected JVMCIBackend createBackend(HotSpotMetaAccessProvider metaAccess, HotSpotCodeCacheProvider codeCache, ConstantReflectionProvider constantReflection,\n+                    StackIntrospection stackIntrospection) {\n+        return new JVMCIBackend(metaAccess, codeCache, constantReflection, stackIntrospection);\n+    }\n+}\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot.riscv64\/src\/jdk\/vm\/ci\/hotspot\/riscv64\/RISCV64HotSpotJVMCIBackendFactory.java","additions":161,"deletions":0,"binary":false,"changes":161,"status":"added"},{"patch":"@@ -0,0 +1,303 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.vm.ci.hotspot.riscv64;\n+\n+import static jdk.vm.ci.riscv64.RISCV64.x0;\n+import static jdk.vm.ci.riscv64.RISCV64.x1;\n+import static jdk.vm.ci.riscv64.RISCV64.x2;\n+import static jdk.vm.ci.riscv64.RISCV64.x3;\n+import static jdk.vm.ci.riscv64.RISCV64.x4;\n+import static jdk.vm.ci.riscv64.RISCV64.x5;\n+import static jdk.vm.ci.riscv64.RISCV64.x6;\n+import static jdk.vm.ci.riscv64.RISCV64.x7;\n+import static jdk.vm.ci.riscv64.RISCV64.x8;\n+import static jdk.vm.ci.riscv64.RISCV64.x10;\n+import static jdk.vm.ci.riscv64.RISCV64.x11;\n+import static jdk.vm.ci.riscv64.RISCV64.x12;\n+import static jdk.vm.ci.riscv64.RISCV64.x13;\n+import static jdk.vm.ci.riscv64.RISCV64.x14;\n+import static jdk.vm.ci.riscv64.RISCV64.x15;\n+import static jdk.vm.ci.riscv64.RISCV64.x16;\n+import static jdk.vm.ci.riscv64.RISCV64.x17;\n+import static jdk.vm.ci.riscv64.RISCV64.x23;\n+import static jdk.vm.ci.riscv64.RISCV64.x27;\n+import static jdk.vm.ci.riscv64.RISCV64.f10;\n+import static jdk.vm.ci.riscv64.RISCV64.f11;\n+import static jdk.vm.ci.riscv64.RISCV64.f12;\n+import static jdk.vm.ci.riscv64.RISCV64.f13;\n+import static jdk.vm.ci.riscv64.RISCV64.f14;\n+import static jdk.vm.ci.riscv64.RISCV64.f15;\n+import static jdk.vm.ci.riscv64.RISCV64.f16;\n+import static jdk.vm.ci.riscv64.RISCV64.f17;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+import jdk.vm.ci.riscv64.RISCV64;\n+import jdk.vm.ci.code.Architecture;\n+import jdk.vm.ci.code.CallingConvention;\n+import jdk.vm.ci.code.CallingConvention.Type;\n+import jdk.vm.ci.code.Register;\n+import jdk.vm.ci.code.RegisterArray;\n+import jdk.vm.ci.code.RegisterAttributes;\n+import jdk.vm.ci.code.RegisterConfig;\n+import jdk.vm.ci.code.StackSlot;\n+import jdk.vm.ci.code.TargetDescription;\n+import jdk.vm.ci.code.ValueKindFactory;\n+import jdk.vm.ci.common.JVMCIError;\n+import jdk.vm.ci.hotspot.HotSpotCallingConventionType;\n+import jdk.vm.ci.meta.AllocatableValue;\n+import jdk.vm.ci.meta.JavaKind;\n+import jdk.vm.ci.meta.JavaType;\n+import jdk.vm.ci.meta.PlatformKind;\n+import jdk.vm.ci.meta.Value;\n+import jdk.vm.ci.meta.ValueKind;\n+\n+public class RISCV64HotSpotRegisterConfig implements RegisterConfig {\n+\n+    private final TargetDescription target;\n+\n+    private final RegisterArray allocatable;\n+\n+    \/**\n+     * The caller saved registers always include all parameter registers.\n+     *\/\n+    private final RegisterArray callerSaved;\n+\n+    private final boolean allAllocatableAreCallerSaved;\n+\n+    private final RegisterAttributes[] attributesMap;\n+\n+    @Override\n+    public RegisterArray getAllocatableRegisters() {\n+        return allocatable;\n+    }\n+\n+    @Override\n+    public RegisterArray filterAllocatableRegisters(PlatformKind kind, RegisterArray registers) {\n+        ArrayList<Register> list = new ArrayList<>();\n+        for (Register reg : registers) {\n+            if (target.arch.canStoreValue(reg.getRegisterCategory(), kind)) {\n+                list.add(reg);\n+            }\n+        }\n+\n+        return new RegisterArray(list);\n+    }\n+\n+    @Override\n+    public RegisterAttributes[] getAttributesMap() {\n+        return attributesMap.clone();\n+    }\n+\n+    private final RegisterArray javaGeneralParameterRegisters = new RegisterArray(x11, x12, x13, x14, x15, x16, x17, x10);\n+    private final RegisterArray nativeGeneralParameterRegisters = new RegisterArray(x10, x11, x12, x13, x14, x15, x16, x17);\n+    private final RegisterArray fpParameterRegisters = new RegisterArray(f10, f11, f12, f13, f14, f15, f16, f17);\n+\n+    public static final Register zero = x0;\n+    public static final Register ra = x1;\n+    public static final Register sp = x2;\n+    public static final Register gp = x3;\n+    public static final Register tp = x4;\n+    public static final Register t0 = x5;\n+    public static final Register t1 = x6;\n+    public static final Register t2 = x7;\n+    public static final Register fp = x8;\n+    public static final Register threadRegister = x23;\n+    public static final Register heapBaseRegister = x27;\n+\n+    private static final RegisterArray reservedRegisters = new RegisterArray(zero, ra, sp, gp, tp, t0, t1, t2, fp);\n+\n+    private static RegisterArray initAllocatable(Architecture arch, boolean reserveForHeapBase) {\n+        RegisterArray allRegisters = arch.getAvailableValueRegisters();\n+        Register[] registers = new Register[allRegisters.size() - reservedRegisters.size() - (reserveForHeapBase ? 1 : 0)];\n+        List<Register> reservedRegistersList = reservedRegisters.asList();\n+\n+        int idx = 0;\n+        for (Register reg : allRegisters) {\n+            if (reservedRegistersList.contains(reg)) {\n+                \/\/ skip reserved registers\n+                continue;\n+            }\n+            assert !(reg.equals(zero) || reg.equals(ra) || reg.equals(sp) || reg.equals(gp) || reg.equals(tp) ||\n+                     reg.equals(t0) || reg.equals(t1) || reg.equals(t2) || reg.equals(fp));\n+            if (reserveForHeapBase && reg.equals(heapBaseRegister)) {\n+                \/\/ skip heap base register\n+                continue;\n+            }\n+\n+            registers[idx++] = reg;\n+        }\n+\n+        assert idx == registers.length;\n+        return new RegisterArray(registers);\n+    }\n+\n+    public RISCV64HotSpotRegisterConfig(TargetDescription target, boolean useCompressedOops, boolean linuxOs) {\n+        this(target, initAllocatable(target.arch, useCompressedOops));\n+        assert callerSaved.size() >= allocatable.size();\n+    }\n+\n+    public RISCV64HotSpotRegisterConfig(TargetDescription target, RegisterArray allocatable) {\n+        this.target = target;\n+        this.allocatable = allocatable;\n+\n+        Set<Register> callerSaveSet = new HashSet<>();\n+        allocatable.addTo(callerSaveSet);\n+        fpParameterRegisters.addTo(callerSaveSet);\n+        javaGeneralParameterRegisters.addTo(callerSaveSet);\n+        nativeGeneralParameterRegisters.addTo(callerSaveSet);\n+        callerSaved = new RegisterArray(callerSaveSet);\n+\n+        allAllocatableAreCallerSaved = true;\n+        attributesMap = RegisterAttributes.createMap(this, RISCV64.allRegisters);\n+    }\n+\n+    @Override\n+    public RegisterArray getCallerSaveRegisters() {\n+        return callerSaved;\n+    }\n+\n+    @Override\n+    public RegisterArray getCalleeSaveRegisters() {\n+        return null;\n+    }\n+\n+    @Override\n+    public boolean areAllAllocatableRegistersCallerSaved() {\n+        return allAllocatableAreCallerSaved;\n+    }\n+\n+    @Override\n+    public CallingConvention getCallingConvention(Type type, JavaType returnType, JavaType[] parameterTypes, ValueKindFactory<?> valueKindFactory) {\n+        HotSpotCallingConventionType hotspotType = (HotSpotCallingConventionType) type;\n+        if (type == HotSpotCallingConventionType.NativeCall) {\n+            return callingConvention(nativeGeneralParameterRegisters, returnType, parameterTypes, hotspotType, valueKindFactory);\n+        }\n+        return callingConvention(javaGeneralParameterRegisters, returnType, parameterTypes, hotspotType, valueKindFactory);\n+    }\n+\n+    @Override\n+    public RegisterArray getCallingConventionRegisters(Type type, JavaKind kind) {\n+        HotSpotCallingConventionType hotspotType = (HotSpotCallingConventionType) type;\n+        switch (kind) {\n+            case Boolean:\n+            case Byte:\n+            case Short:\n+            case Char:\n+            case Int:\n+            case Long:\n+            case Object:\n+                return hotspotType == HotSpotCallingConventionType.NativeCall ? nativeGeneralParameterRegisters : javaGeneralParameterRegisters;\n+            case Float:\n+            case Double:\n+                return fpParameterRegisters;\n+            default:\n+                throw JVMCIError.shouldNotReachHere();\n+        }\n+    }\n+\n+    private CallingConvention callingConvention(RegisterArray generalParameterRegisters, JavaType returnType, JavaType[] parameterTypes, HotSpotCallingConventionType type,\n+                    ValueKindFactory<?> valueKindFactory) {\n+        AllocatableValue[] locations = new AllocatableValue[parameterTypes.length];\n+\n+        int currentGeneral = 0;\n+        int currentFP = 0;\n+        int currentStackOffset = 0;\n+\n+        for (int i = 0; i < parameterTypes.length; i++) {\n+            final JavaKind kind = parameterTypes[i].getJavaKind().getStackKind();\n+\n+            switch (kind) {\n+                case Byte:\n+                case Boolean:\n+                case Short:\n+                case Char:\n+                case Int:\n+                case Long:\n+                case Object:\n+                    if (currentGeneral < generalParameterRegisters.size()) {\n+                        Register register = generalParameterRegisters.get(currentGeneral++);\n+                        locations[i] = register.asValue(valueKindFactory.getValueKind(kind));\n+                    }\n+                    break;\n+                case Float:\n+                case Double:\n+                    if (currentFP < fpParameterRegisters.size()) {\n+                        Register register = fpParameterRegisters.get(currentFP++);\n+                        locations[i] = register.asValue(valueKindFactory.getValueKind(kind));\n+                    } else if (currentGeneral < generalParameterRegisters.size()) {\n+                        Register register = generalParameterRegisters.get(currentGeneral++);\n+                        locations[i] = register.asValue(valueKindFactory.getValueKind(kind));\n+                    }\n+                    break;\n+                default:\n+                    throw JVMCIError.shouldNotReachHere();\n+            }\n+\n+            if (locations[i] == null) {\n+                ValueKind<?> valueKind = valueKindFactory.getValueKind(kind);\n+                locations[i] = StackSlot.get(valueKind, currentStackOffset, !type.out);\n+                currentStackOffset += Math.max(valueKind.getPlatformKind().getSizeInBytes(), target.wordSize);\n+            }\n+        }\n+\n+        JavaKind returnKind = returnType == null ? JavaKind.Void : returnType.getJavaKind();\n+        AllocatableValue returnLocation = returnKind == JavaKind.Void ? Value.ILLEGAL : getReturnRegister(returnKind).asValue(valueKindFactory.getValueKind(returnKind.getStackKind()));\n+        return new CallingConvention(currentStackOffset, returnLocation, locations);\n+    }\n+\n+    @Override\n+    public Register getReturnRegister(JavaKind kind) {\n+        switch (kind) {\n+            case Boolean:\n+            case Byte:\n+            case Char:\n+            case Short:\n+            case Int:\n+            case Long:\n+            case Object:\n+                return x10;\n+            case Float:\n+            case Double:\n+                return f10;\n+            case Void:\n+            case Illegal:\n+                return null;\n+            default:\n+                throw new UnsupportedOperationException(\"no return register for type \" + kind);\n+        }\n+    }\n+\n+    @Override\n+    public Register getFrameRegister() {\n+        return x2;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return String.format(\"Allocatable: \" + getAllocatableRegisters() + \"%n\" + \"CallerSave:  \" + getCallerSaveRegisters() + \"%n\");\n+    }\n+}\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot.riscv64\/src\/jdk\/vm\/ci\/hotspot\/riscv64\/RISCV64HotSpotRegisterConfig.java","additions":303,"deletions":0,"binary":false,"changes":303,"status":"added"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.vm.ci.hotspot.riscv64;\n+\n+import jdk.vm.ci.hotspot.HotSpotVMConfigAccess;\n+import jdk.vm.ci.hotspot.HotSpotVMConfigStore;\n+import jdk.vm.ci.services.Services;\n+\n+\/**\n+ * Used to access native configuration details.\n+ *\n+ * All non-static, public fields in this class are so that they can be compiled as constants.\n+ *\/\n+class RISCV64HotSpotVMConfig extends HotSpotVMConfigAccess {\n+\n+    RISCV64HotSpotVMConfig(HotSpotVMConfigStore config) {\n+        super(config);\n+    }\n+\n+    final boolean linuxOs = Services.getSavedProperty(\"os.name\", \"\").startsWith(\"Linux\");\n+\n+    final boolean useCompressedOops = getFlag(\"UseCompressedOops\", Boolean.class);\n+\n+    \/\/ CPU Capabilities\n+\n+    \/*\n+     * These flags are set based on the corresponding command line flags.\n+     *\/\n+    final boolean useConservativeFence = getFlag(\"UseConservativeFence\", Boolean.class);\n+    final boolean avoidUnalignedAccesses = getFlag(\"AvoidUnalignedAccesses\", Boolean.class);\n+    final boolean nearCpool = getFlag(\"NearCpool\", Boolean.class);\n+    final boolean traceTraps = getFlag(\"TraceTraps\", Boolean.class);\n+    final boolean useRVV = getFlag(\"UseRVV\", Boolean.class);\n+    final boolean useRVC = getFlag(\"UseRVC\", Boolean.class);\n+    final boolean useZba = getFlag(\"UseZba\", Boolean.class);\n+    final boolean useZbb = getFlag(\"UseZbb\", Boolean.class);\n+    final boolean useRVVForBigIntegerShiftIntrinsics = getFlag(\"UseRVVForBigIntegerShiftIntrinsics\", Boolean.class);\n+\n+    final long vmVersionFeatures = getFieldValue(\"Abstract_VM_Version::_features\", Long.class, \"uint64_t\");\n+\n+    \/*\n+     * These flags are set if the corresponding support is in the hardware.\n+     *\/\n+    \/\/ Checkstyle: stop\n+    \/\/ CPU feature flags are currently not available in VM_Version\n+    \/\/ Checkstyle: resume\n+\n+}\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot.riscv64\/src\/jdk\/vm\/ci\/hotspot\/riscv64\/RISCV64HotSpotVMConfig.java","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -0,0 +1,27 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * The RISCV64 HotSpot specific portions of the JVMCI API.\n+ *\/\n+package jdk.vm.ci.hotspot.riscv64;\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot.riscv64\/src\/jdk\/vm\/ci\/hotspot\/riscv64\/package-info.java","additions":27,"deletions":0,"binary":false,"changes":27,"status":"added"},{"patch":"@@ -0,0 +1,291 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.vm.ci.riscv64;\n+\n+import java.nio.ByteOrder;\n+import java.util.EnumSet;\n+\n+import jdk.vm.ci.code.Architecture;\n+import jdk.vm.ci.code.CPUFeatureName;\n+import jdk.vm.ci.code.Register;\n+import jdk.vm.ci.code.Register.RegisterCategory;\n+import jdk.vm.ci.code.RegisterArray;\n+import jdk.vm.ci.meta.JavaKind;\n+import jdk.vm.ci.meta.PlatformKind;\n+\n+\/**\n+ * Represents the RISCV64 architecture.\n+ *\/\n+public class RISCV64 extends Architecture {\n+\n+    public static final RegisterCategory CPU = new RegisterCategory(\"CPU\");\n+\n+    \/\/ General purpose CPU registers\n+    public static final Register x0 = new Register(0, 0, \"x0\", CPU);\n+    public static final Register x1 = new Register(1, 1, \"x1\", CPU);\n+    public static final Register x2 = new Register(2, 2, \"x2\", CPU);\n+    public static final Register x3 = new Register(3, 3, \"x3\", CPU);\n+    public static final Register x4 = new Register(4, 4, \"x4\", CPU);\n+    public static final Register x5 = new Register(5, 5, \"x5\", CPU);\n+    public static final Register x6 = new Register(6, 6, \"x6\", CPU);\n+    public static final Register x7 = new Register(7, 7, \"x7\", CPU);\n+    public static final Register x8 = new Register(8, 8, \"x8\", CPU);\n+    public static final Register x9 = new Register(9, 9, \"x9\", CPU);\n+    public static final Register x10 = new Register(10, 10, \"x10\", CPU);\n+    public static final Register x11 = new Register(11, 11, \"x11\", CPU);\n+    public static final Register x12 = new Register(12, 12, \"x12\", CPU);\n+    public static final Register x13 = new Register(13, 13, \"x13\", CPU);\n+    public static final Register x14 = new Register(14, 14, \"x14\", CPU);\n+    public static final Register x15 = new Register(15, 15, \"x15\", CPU);\n+    public static final Register x16 = new Register(16, 16, \"x16\", CPU);\n+    public static final Register x17 = new Register(17, 17, \"x17\", CPU);\n+    public static final Register x18 = new Register(18, 18, \"x18\", CPU);\n+    public static final Register x19 = new Register(19, 19, \"x19\", CPU);\n+    public static final Register x20 = new Register(20, 20, \"x20\", CPU);\n+    public static final Register x21 = new Register(21, 21, \"x21\", CPU);\n+    public static final Register x22 = new Register(22, 22, \"x22\", CPU);\n+    public static final Register x23 = new Register(23, 23, \"x23\", CPU);\n+    public static final Register x24 = new Register(24, 24, \"x24\", CPU);\n+    public static final Register x25 = new Register(25, 25, \"x25\", CPU);\n+    public static final Register x26 = new Register(26, 26, \"x26\", CPU);\n+    public static final Register x27 = new Register(27, 27, \"x27\", CPU);\n+    public static final Register x28 = new Register(28, 28, \"x28\", CPU);\n+    public static final Register x29 = new Register(29, 29, \"x29\", CPU);\n+    public static final Register x30 = new Register(30, 30, \"x30\", CPU);\n+    public static final Register x31 = new Register(31, 31, \"x31\", CPU);\n+\n+    \/\/ @formatter:off\n+    public static final RegisterArray cpuRegisters = new RegisterArray(\n+        x0,  x1,  x2,  x3,  x4,  x5,  x6,  x7,\n+        x8,  x9,  x10, x11, x12, x13, x14, x15,\n+        x16, x17, x18, x19, x20, x21, x22, x23,\n+        x24, x25, x26, x27, x28, x29, x30, x31\n+    );\n+    \/\/ @formatter:on\n+\n+    public static final RegisterCategory FP = new RegisterCategory(\"FP\");\n+\n+    \/\/ Simd registers\n+    public static final Register f0 = new Register(32, 0, \"f0\", FP);\n+    public static final Register f1 = new Register(33, 1, \"f1\", FP);\n+    public static final Register f2 = new Register(34, 2, \"f2\", FP);\n+    public static final Register f3 = new Register(35, 3, \"f3\", FP);\n+    public static final Register f4 = new Register(36, 4, \"f4\", FP);\n+    public static final Register f5 = new Register(37, 5, \"f5\", FP);\n+    public static final Register f6 = new Register(38, 6, \"f6\", FP);\n+    public static final Register f7 = new Register(39, 7, \"f7\", FP);\n+    public static final Register f8 = new Register(40, 8, \"f8\", FP);\n+    public static final Register f9 = new Register(41, 9, \"f9\", FP);\n+    public static final Register f10 = new Register(42, 10, \"f10\", FP);\n+    public static final Register f11 = new Register(43, 11, \"f11\", FP);\n+    public static final Register f12 = new Register(44, 12, \"f12\", FP);\n+    public static final Register f13 = new Register(45, 13, \"f13\", FP);\n+    public static final Register f14 = new Register(46, 14, \"f14\", FP);\n+    public static final Register f15 = new Register(47, 15, \"f15\", FP);\n+    public static final Register f16 = new Register(48, 16, \"f16\", FP);\n+    public static final Register f17 = new Register(49, 17, \"f17\", FP);\n+    public static final Register f18 = new Register(50, 18, \"f18\", FP);\n+    public static final Register f19 = new Register(51, 19, \"f19\", FP);\n+    public static final Register f20 = new Register(52, 20, \"f20\", FP);\n+    public static final Register f21 = new Register(53, 21, \"f21\", FP);\n+    public static final Register f22 = new Register(54, 22, \"f22\", FP);\n+    public static final Register f23 = new Register(55, 23, \"f23\", FP);\n+    public static final Register f24 = new Register(56, 24, \"f24\", FP);\n+    public static final Register f25 = new Register(57, 25, \"f25\", FP);\n+    public static final Register f26 = new Register(58, 26, \"f26\", FP);\n+    public static final Register f27 = new Register(59, 27, \"f27\", FP);\n+    public static final Register f28 = new Register(60, 28, \"f28\", FP);\n+    public static final Register f29 = new Register(61, 29, \"f29\", FP);\n+    public static final Register f30 = new Register(62, 30, \"f30\", FP);\n+    public static final Register f31 = new Register(63, 31, \"f31\", FP);\n+\n+    \/\/ @formatter:off\n+    public static final RegisterArray fpRegisters = new RegisterArray(\n+        f0,  f1,  f2,  f3,  f4,  f5,  f6,  f7,\n+        f8,  f9,  f10, f11, f12, f13, f14, f15,\n+        f16, f17, f18, f19, f20, f21, f22, f23,\n+        f24, f25, f26, f27, f28, f29, f30, f31\n+    );\n+    \/\/ @formatter:on\n+\n+    public static final RegisterCategory SIMD = new RegisterCategory(\"SIMD\");\n+\n+    \/\/ Simd registers\n+    public static final Register v0 = new Register(64, 0, \"v0\", SIMD);\n+    public static final Register v1 = new Register(65, 1, \"v1\", SIMD);\n+    public static final Register v2 = new Register(66, 2, \"v2\", SIMD);\n+    public static final Register v3 = new Register(67, 3, \"v3\", SIMD);\n+    public static final Register v4 = new Register(68, 4, \"v4\", SIMD);\n+    public static final Register v5 = new Register(69, 5, \"v5\", SIMD);\n+    public static final Register v6 = new Register(70, 6, \"v6\", SIMD);\n+    public static final Register v7 = new Register(71, 7, \"v7\", SIMD);\n+    public static final Register v8 = new Register(72, 8, \"v8\", SIMD);\n+    public static final Register v9 = new Register(73, 9, \"v9\", SIMD);\n+    public static final Register v10 = new Register(74, 10, \"v10\", SIMD);\n+    public static final Register v11 = new Register(75, 11, \"v11\", SIMD);\n+    public static final Register v12 = new Register(76, 12, \"v12\", SIMD);\n+    public static final Register v13 = new Register(77, 13, \"v13\", SIMD);\n+    public static final Register v14 = new Register(78, 14, \"v14\", SIMD);\n+    public static final Register v15 = new Register(79, 15, \"v15\", SIMD);\n+    public static final Register v16 = new Register(80, 16, \"v16\", SIMD);\n+    public static final Register v17 = new Register(81, 17, \"v17\", SIMD);\n+    public static final Register v18 = new Register(82, 18, \"v18\", SIMD);\n+    public static final Register v19 = new Register(83, 19, \"v19\", SIMD);\n+    public static final Register v20 = new Register(84, 20, \"v20\", SIMD);\n+    public static final Register v21 = new Register(85, 21, \"v21\", SIMD);\n+    public static final Register v22 = new Register(86, 22, \"v22\", SIMD);\n+    public static final Register v23 = new Register(87, 23, \"v23\", SIMD);\n+    public static final Register v24 = new Register(88, 24, \"v24\", SIMD);\n+    public static final Register v25 = new Register(89, 25, \"v25\", SIMD);\n+    public static final Register v26 = new Register(90, 26, \"v26\", SIMD);\n+    public static final Register v27 = new Register(91, 27, \"v27\", SIMD);\n+    public static final Register v28 = new Register(92, 28, \"v28\", SIMD);\n+    public static final Register v29 = new Register(93, 29, \"v29\", SIMD);\n+    public static final Register v30 = new Register(94, 30, \"v30\", SIMD);\n+    public static final Register v31 = new Register(95, 31, \"v31\", SIMD);\n+\n+    \/\/ @formatter:off\n+    public static final RegisterArray simdRegisters = new RegisterArray(\n+        v0,  v1,  v2,  v3,  v4,  v5,  v6,  v7,\n+        v8,  v9,  v10, v11, v12, v13, v14, v15,\n+        v16, v17, v18, v19, v20, v21, v22, v23,\n+        v24, v25, v26, v27, v28, v29, v30, v31\n+    );\n+    \/\/ @formatter:on\n+\n+    \/\/ @formatter:off\n+    public static final RegisterArray allRegisters = new RegisterArray(\n+        x0,  x1,  x2,  x3,  x4,  x5,  x6,  x7,\n+        x8,  x9,  x10, x11, x12, x13, x14, x15,\n+        x16, x17, x18, x19, x20, x21, x22, x23,\n+        x24, x25, x26, x27, x28, x29, x30, x31,\n+\n+        f0,  f1,  f2,  f3,  f4,  f5,  f6,  f7,\n+        f8,  f9,  f10, f11, f12, f13, f14, f15,\n+        f16, f17, f18, f19, f20, f21, f22, f23,\n+        f24, f25, f26, f27, f28, f29, f30, f31,\n+\n+        v0,  v1,  v2,  v3,  v4,  v5,  v6,  v7,\n+        v8,  v9,  v10, v11, v12, v13, v14, v15,\n+        v16, v17, v18, v19, v20, v21, v22, v23,\n+        v24, v25, v26, v27, v28, v29, v30, v31\n+    );\n+    \/\/ @formatter:on\n+\n+    \/**\n+     * Basic set of CPU features mirroring what is returned from the mcpuid register. See:\n+     * {@code VM_Version::cpuFeatureFlags}.\n+     *\/\n+    public enum CPUFeature implements CPUFeatureName {\n+        I,\n+        M,\n+        A,\n+        F,\n+        D,\n+        C,\n+        V\n+    }\n+\n+    private final EnumSet<CPUFeature> features;\n+\n+    \/**\n+     * Set of flags to control code emission.\n+     *\/\n+    public enum Flag {\n+        UseConservativeFence,\n+        AvoidUnalignedAccesses,\n+        NearCpool,\n+        TraceTraps,\n+        UseRVV,\n+        UseRVC,\n+        UseZba,\n+        UseZbb,\n+        UseRVVForBigIntegerShiftIntrinsics\n+    }\n+\n+    private final EnumSet<Flag> flags;\n+\n+    public RISCV64(EnumSet<CPUFeature> features, EnumSet<Flag> flags) {\n+        super(\"riscv64\", RISCV64Kind.QWORD, ByteOrder.LITTLE_ENDIAN, true, allRegisters, 0, 0, 8);\n+        this.features = features;\n+        this.flags = flags;\n+    }\n+\n+    @Override\n+    public EnumSet<CPUFeature> getFeatures() {\n+        return features;\n+    }\n+\n+    public EnumSet<Flag> getFlags() {\n+        return flags;\n+    }\n+\n+    @Override\n+    public PlatformKind getPlatformKind(JavaKind javaKind) {\n+        switch (javaKind) {\n+            case Boolean:\n+            case Byte:\n+                return RISCV64Kind.BYTE;\n+            case Short:\n+            case Char:\n+                return RISCV64Kind.WORD;\n+            case Int:\n+                return RISCV64Kind.DWORD;\n+            case Long:\n+            case Object:\n+                return RISCV64Kind.QWORD;\n+            case Float:\n+                return RISCV64Kind.SINGLE;\n+            case Double:\n+                return RISCV64Kind.DOUBLE;\n+            default:\n+                return null;\n+        }\n+    }\n+\n+    @Override\n+    public boolean canStoreValue(RegisterCategory category, PlatformKind platformKind) {\n+        RISCV64Kind kind = (RISCV64Kind) platformKind;\n+        if (kind.isInteger()) {\n+            return category.equals(CPU);\n+        } else if (kind.isFP()) {\n+            return category.equals(FP);\n+        } else if (kind.isSIMD()) {\n+            return category.equals(SIMD);\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    public RISCV64Kind getLargestStorableKind(RegisterCategory category) {\n+        if (category.equals(CPU)) {\n+            return RISCV64Kind.QWORD;\n+        } else if (category.equals(FP)) {\n+            return RISCV64Kind.DOUBLE;\n+        } else if (category.equals(SIMD)) {\n+            return RISCV64Kind.V256_QWORD;\n+        } else {\n+            return null;\n+        }\n+    }\n+}\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.riscv64\/src\/jdk\/vm\/ci\/riscv64\/RISCV64.java","additions":291,"deletions":0,"binary":false,"changes":291,"status":"added"},{"patch":"@@ -0,0 +1,171 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.vm.ci.riscv64;\n+\n+import jdk.vm.ci.meta.PlatformKind;\n+\n+public enum RISCV64Kind implements PlatformKind {\n+\n+    \/\/ scalar\n+    BYTE(1),\n+    WORD(2),\n+    DWORD(4),\n+    QWORD(8),\n+    SINGLE(4),\n+    DOUBLE(8),\n+\n+    \/\/ SIMD\n+    V32_BYTE(4, BYTE),\n+    V32_WORD(4, WORD),\n+    V64_BYTE(8, BYTE),\n+    V64_WORD(8, WORD),\n+    V64_DWORD(8, DWORD),\n+    V128_BYTE(16, BYTE),\n+    V128_WORD(16, WORD),\n+    V128_DWORD(16, DWORD),\n+    V128_QWORD(16, QWORD),\n+    V128_SINGLE(16, SINGLE),\n+    V128_DOUBLE(16, DOUBLE),\n+    V256_BYTE(32, BYTE),\n+    V256_WORD(32, WORD),\n+    V256_DWORD(32, DWORD),\n+    V256_QWORD(32, QWORD),\n+    V256_SINGLE(32, SINGLE),\n+    V256_DOUBLE(32, DOUBLE);\n+\n+    \/\/ The maximum value of VLEN (the length of the vector registers) is 65536 according to the ISA.\n+    \/\/ Thus those types are not enough to define all the possibilites.\n+\n+    private final int size;\n+    private final int vectorLength;\n+\n+    private final RISCV64Kind scalar;\n+    private final EnumKey<RISCV64Kind> key = new EnumKey<>(this);\n+\n+    RISCV64Kind(int size) {\n+        this.size = size;\n+        this.scalar = this;\n+        this.vectorLength = 1;\n+    }\n+\n+    RISCV64Kind(int size, RISCV64Kind scalar) {\n+        this.size = size;\n+        this.scalar = scalar;\n+\n+        assert size % scalar.size == 0;\n+        this.vectorLength = size \/ scalar.size;\n+    }\n+\n+    public RISCV64Kind getScalar() {\n+        return scalar;\n+    }\n+\n+    @Override\n+    public int getSizeInBytes() {\n+        return size;\n+    }\n+\n+    @Override\n+    public int getVectorLength() {\n+        return vectorLength;\n+    }\n+\n+    @Override\n+    public Key getKey() {\n+        return key;\n+    }\n+\n+    public boolean isInteger() {\n+        switch (this) {\n+            case BYTE:\n+            case WORD:\n+            case DWORD:\n+            case QWORD:\n+                return true;\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    public boolean isFP() {\n+        switch (this) {\n+            case SINGLE:\n+            case DOUBLE:\n+                return true;\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    public boolean isSIMD() {\n+        switch (this) {\n+            case V32_BYTE:\n+            case V32_WORD:\n+            case V64_BYTE:\n+            case V64_WORD:\n+            case V64_DWORD:\n+            case V128_BYTE:\n+            case V128_WORD:\n+            case V128_DWORD:\n+            case V128_QWORD:\n+            case V128_SINGLE:\n+            case V128_DOUBLE:\n+                return true;\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    @Override\n+    public char getTypeChar() {\n+        switch (this) {\n+            case BYTE:\n+                return 'b';\n+            case WORD:\n+                return 'w';\n+            case DWORD:\n+                return 'd';\n+            case QWORD:\n+                return 'q';\n+            case SINGLE:\n+                return 'S';\n+            case DOUBLE:\n+                return 'D';\n+            case V32_BYTE:\n+            case V32_WORD:\n+            case V64_BYTE:\n+            case V64_WORD:\n+            case V64_DWORD:\n+            case V128_BYTE:\n+            case V128_WORD:\n+            case V128_DWORD:\n+            case V128_QWORD:\n+            case V128_SINGLE:\n+            case V128_DOUBLE:\n+                return 'v';\n+            default:\n+                return '-';\n+        }\n+    }\n+\n+}\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.riscv64\/src\/jdk\/vm\/ci\/riscv64\/RISCV64Kind.java","additions":171,"deletions":0,"binary":false,"changes":171,"status":"added"},{"patch":"@@ -0,0 +1,27 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * The RISCV64 platform independent portions of the JVMCI API.\n+ *\/\n+package jdk.vm.ci.riscv64;\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.riscv64\/src\/jdk\/vm\/ci\/riscv64\/package-info.java","additions":27,"deletions":0,"binary":false,"changes":27,"status":"added"},{"patch":"@@ -42,1 +42,2 @@\n-        jdk.vm.ci.hotspot.amd64.AMD64HotSpotJVMCIBackendFactory;\n+        jdk.vm.ci.hotspot.amd64.AMD64HotSpotJVMCIBackendFactory,\n+        jdk.vm.ci.hotspot.riscv64.RISCV64HotSpotJVMCIBackendFactory;\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/module-info.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import jdk.vm.ci.riscv64.RISCV64;\n@@ -33,0 +34,1 @@\n+import jdk.vm.ci.code.test.riscv64.RISCV64TestAssembler;\n@@ -79,0 +81,2 @@\n+        } else if (arch instanceof RISCV64) {\n+            return new RISCV64TestAssembler(codeCache, config);\n@@ -106,2 +110,1 @@\n-            if (DEBUG) {\n-                String str = ((HotSpotCodeCacheProvider) codeCache).disassemble(installed);\n+            String str = ((HotSpotCodeCacheProvider) codeCache).disassemble(installed);\n@@ -109,0 +112,4 @@\n+\n+            if (DEBUG) {\n+                String str2 = ((HotSpotCodeCacheProvider) codeCache).disassemble(installed);\n+                System.out.println(str2);\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.code.test\/src\/jdk\/vm\/ci\/code\/test\/CodeInstallationTest.java","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n- * @requires vm.simpleArch == \"x64\" | vm.simpleArch == \"aarch64\"\n+ * @requires vm.simpleArch == \"x64\" | vm.simpleArch == \"aarch64\" | vm.simpleArch == \"riscv64\"\n@@ -36,1 +36,2 @@\n- * @compile CodeInstallationTest.java DebugInfoTest.java TestAssembler.java TestHotSpotVMConfig.java amd64\/AMD64TestAssembler.java aarch64\/AArch64TestAssembler.java\n+ *          jdk.internal.vm.ci\/jdk.vm.ci.riscv64\n+ * @compile CodeInstallationTest.java DebugInfoTest.java TestAssembler.java TestHotSpotVMConfig.java amd64\/AMD64TestAssembler.java aarch64\/AArch64TestAssembler.java riscv64\/RISCV64TestAssembler.java\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.code.test\/src\/jdk\/vm\/ci\/code\/test\/DataPatchTest.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n- * @requires vm.simpleArch == \"x64\" | vm.simpleArch == \"aarch64\"\n+ * @requires vm.simpleArch == \"x64\" | vm.simpleArch == \"aarch64\" | vm.simpleArch == \"riscv64\"\n@@ -36,1 +36,2 @@\n- * @compile CodeInstallationTest.java TestAssembler.java TestHotSpotVMConfig.java amd64\/AMD64TestAssembler.java aarch64\/AArch64TestAssembler.java\n+ *          jdk.internal.vm.ci\/jdk.vm.ci.riscv64\n+ * @compile CodeInstallationTest.java TestAssembler.java TestHotSpotVMConfig.java amd64\/AMD64TestAssembler.java aarch64\/AArch64TestAssembler.java riscv64\/RISCV64TestAssembler.java\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.code.test\/src\/jdk\/vm\/ci\/code\/test\/InterpreterFrameSizeTest.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n- * @requires vm.simpleArch == \"x64\" | vm.simpleArch == \"aarch64\"\n+ * @requires vm.simpleArch == \"x64\" | vm.simpleArch == \"aarch64\" | vm.simpleArch == \"riscv64\"\n@@ -37,1 +37,2 @@\n- * @compile CodeInstallationTest.java DebugInfoTest.java TestAssembler.java TestHotSpotVMConfig.java amd64\/AMD64TestAssembler.java aarch64\/AArch64TestAssembler.java\n+ *          jdk.internal.vm.ci\/jdk.vm.ci.riscv64\n+ * @compile CodeInstallationTest.java DebugInfoTest.java TestAssembler.java TestHotSpotVMConfig.java amd64\/AMD64TestAssembler.java aarch64\/AArch64TestAssembler.java riscv64\/RISCV64TestAssembler.java\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.code.test\/src\/jdk\/vm\/ci\/code\/test\/MaxOopMapStackOffsetTest.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n- * @requires vm.simpleArch == \"x64\" | vm.simpleArch == \"aarch64\"\n+ * @requires vm.simpleArch == \"x64\" | vm.simpleArch == \"aarch64\" | vm.simpleArch == \"riscv64\"\n@@ -37,1 +37,2 @@\n- * @compile CodeInstallationTest.java TestHotSpotVMConfig.java NativeCallTest.java TestAssembler.java amd64\/AMD64TestAssembler.java aarch64\/AArch64TestAssembler.java\n+ *          jdk.internal.vm.ci\/jdk.vm.ci.riscv64\n+ * @compile CodeInstallationTest.java TestHotSpotVMConfig.java NativeCallTest.java TestAssembler.java amd64\/AMD64TestAssembler.java aarch64\/AArch64TestAssembler.java riscv64\/RISCV64TestAssembler.java\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.code.test\/src\/jdk\/vm\/ci\/code\/test\/NativeCallTest.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n- * @requires vm.simpleArch == \"x64\" | vm.simpleArch == \"aarch64\"\n+ * @requires vm.simpleArch == \"x64\" | vm.simpleArch == \"aarch64\" | vm.simpleArch == \"riscv64\"\n@@ -36,1 +36,2 @@\n- * @compile CodeInstallationTest.java DebugInfoTest.java TestAssembler.java TestHotSpotVMConfig.java amd64\/AMD64TestAssembler.java aarch64\/AArch64TestAssembler.java\n+ *          jdk.internal.vm.ci\/jdk.vm.ci.riscv64\n+ * @compile CodeInstallationTest.java DebugInfoTest.java TestAssembler.java TestHotSpotVMConfig.java amd64\/AMD64TestAssembler.java aarch64\/AArch64TestAssembler.java riscv64\/RISCV64TestAssembler.java\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.code.test\/src\/jdk\/vm\/ci\/code\/test\/SimpleCodeInstallationTest.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n- * @requires vm.simpleArch == \"x64\" | vm.simpleArch == \"aarch64\"\n+ * @requires vm.simpleArch == \"x64\" | vm.simpleArch == \"aarch64\" | vm.simpleArch == \"riscv64\"\n@@ -36,1 +36,2 @@\n- * @compile CodeInstallationTest.java DebugInfoTest.java TestAssembler.java TestHotSpotVMConfig.java amd64\/AMD64TestAssembler.java aarch64\/AArch64TestAssembler.java\n+ *          jdk.internal.vm.ci\/jdk.vm.ci.riscv64\n+ * @compile CodeInstallationTest.java DebugInfoTest.java TestAssembler.java TestHotSpotVMConfig.java amd64\/AMD64TestAssembler.java aarch64\/AArch64TestAssembler.java riscv64\/RISCV64TestAssembler.java\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.code.test\/src\/jdk\/vm\/ci\/code\/test\/SimpleDebugInfoTest.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n- * @requires vm.simpleArch == \"x64\" | vm.simpleArch == \"aarch64\"\n+ * @requires vm.simpleArch == \"x64\" | vm.simpleArch == \"aarch64\" | vm.simpleArch == \"riscv64\"\n@@ -36,1 +36,2 @@\n- * @compile CodeInstallationTest.java DebugInfoTest.java TestAssembler.java TestHotSpotVMConfig.java amd64\/AMD64TestAssembler.java aarch64\/AArch64TestAssembler.java\n+ *          jdk.internal.vm.ci\/jdk.vm.ci.riscv64\n+ * @compile CodeInstallationTest.java DebugInfoTest.java TestAssembler.java TestHotSpotVMConfig.java amd64\/AMD64TestAssembler.java aarch64\/AArch64TestAssembler.java riscv64\/RISCV64TestAssembler.java\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.code.test\/src\/jdk\/vm\/ci\/code\/test\/VirtualObjectDebugInfoTest.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,543 @@\n+\/*\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.vm.ci.code.test.riscv64;\n+\n+import jdk.vm.ci.code.CallingConvention;\n+import jdk.vm.ci.code.CodeCacheProvider;\n+import jdk.vm.ci.code.DebugInfo;\n+import jdk.vm.ci.code.Register;\n+import jdk.vm.ci.code.RegisterValue;\n+import jdk.vm.ci.code.StackSlot;\n+import jdk.vm.ci.code.site.ConstantReference;\n+import jdk.vm.ci.code.site.DataSectionReference;\n+import jdk.vm.ci.code.test.TestAssembler;\n+import jdk.vm.ci.code.test.TestHotSpotVMConfig;\n+import jdk.vm.ci.hotspot.HotSpotCallingConventionType;\n+import jdk.vm.ci.hotspot.HotSpotConstant;\n+import jdk.vm.ci.hotspot.HotSpotForeignCallTarget;\n+import jdk.vm.ci.meta.AllocatableValue;\n+import jdk.vm.ci.meta.JavaKind;\n+import jdk.vm.ci.meta.VMConstant;\n+import jdk.vm.ci.riscv64.RISCV64;\n+import jdk.vm.ci.riscv64.RISCV64Kind;\n+\n+public class RISCV64TestAssembler extends TestAssembler {\n+\n+    private static final Register scratchRegister = RISCV64.x5;\n+    private static final Register doubleScratch = RISCV64.f5;\n+\n+    public RISCV64TestAssembler(CodeCacheProvider codeCache, TestHotSpotVMConfig config) {\n+        super(codeCache, config,\n+              16 \/* initialFrameSize *\/, 16 \/* stackAlignment *\/,\n+              RISCV64Kind.DWORD \/* narrowOopKind *\/,\n+              \/* registers *\/\n+              RISCV64.x10, RISCV64.x11, RISCV64.x12, RISCV64.x13,\n+              RISCV64.x14, RISCV64.x15, RISCV64.x16, RISCV64.x17);\n+    }\n+\n+    private static int f(int val, int msb, int lsb) {\n+        int nbits = msb - lsb + 1;\n+        assert val >= 0;\n+        assert val < (1 << nbits);\n+        assert msb >= lsb;\n+        return val << lsb;\n+    }\n+\n+    private static int f(Register r, int msb, int lsb) {\n+        assert msb - lsb == 4;\n+        return f(r.encoding, msb, lsb);\n+    }\n+\n+    private static int instructionImmediate(int imm, int rs1, int funct, int rd, int opcode) {\n+        return f(imm, 31, 20) | f(rs1, 19, 15) | f(funct, 14, 12) | f(rd, 11, 7) | f(opcode, 6, 0);\n+    }\n+\n+    private static int instructionRegister(int funct7, int rs2, int rs1, int funct3, int rd, int opcode) {\n+        return f(funct7, 31, 25) | f(rs2, 24, 20) | f(rs1, 19, 15) | f(funct3, 14, 12) | f(rd, 11, 7) | f(opcode, 6, 0);\n+    }\n+\n+    private void emitNop() {\n+        code.emitInt(instructionImmediate(0, 0, 0b000, 0, 0b0010011));\n+    }\n+\n+    private void emitAdd(Register Rd, Register Rm, Register Rn) {\n+        \/\/ ADD\n+        code.emitInt(instructionRegister(0b0000000, Rn.encoding, Rm.encoding, 0b000, Rd.encoding, 0b0110011));\n+    }\n+\n+    private void emitAdd(Register Rd, Register Rn, int imm12) {\n+        \/\/ ADDI\n+        code.emitInt(instructionImmediate(imm12 & 0xfff, Rn.encoding, 0b000, Rd.encoding, 0b0010011));\n+    }\n+\n+    private void emitAddW(Register Rd, Register Rn, int imm12) {\n+        \/\/ ADDIW\n+        code.emitInt(instructionImmediate(imm12 & 0xfff, Rn.encoding, 0b000, Rd.encoding, 0b0011011));\n+    }\n+\n+    private void emitSub(Register Rd, Register Rn, int imm12) {\n+        \/\/ SUBI\n+        emitAdd(Rd, Rn, -imm12);;\n+    }\n+\n+    private void emitSub(Register Rd, Register Rm, Register Rn) {\n+        \/\/ SUB\n+        code.emitInt(instructionRegister(0b0100000, Rn.encoding, Rm.encoding, 0b000, Rd.encoding, 0b0110011));\n+    }\n+\n+    private void emitMv(Register Rd, Register Rn) {\n+        \/\/ MV\n+        code.emitInt(instructionRegister(0b0000000, 0, Rn.encoding, 0b000, Rd.encoding, 0b0110011));\n+    }\n+\n+    private void emitShiftLeft(Register Rd, Register Rn, int shift) {\n+        \/\/ SLLI\n+        code.emitInt(instructionImmediate(shift & 0x3f, Rn.encoding, 0b001, Rd.encoding, 0b0010011));\n+    }\n+\n+    private void emitShiftRight(Register Rd, Register Rn, int shift) {\n+        \/\/ SRLI\n+        code.emitInt(instructionImmediate(shift & 0x3f, Rn.encoding, 0b101, Rd.encoding, 0b0010011));\n+    }\n+\n+    private void emitLui(Register Rd, int imm20) {\n+        \/\/ LUI\n+        code.emitInt(f(imm20, 31, 12) | f(Rd, 11, 7) | f(0b0110111, 6, 0));\n+    }\n+\n+    private void emitAuipc(Register Rd, int imm20) {\n+        \/\/ AUIPC\n+        code.emitInt(f(imm20, 31, 12) | f(Rd, 11, 7) | f(0b0010111, 6, 0));\n+    }\n+\n+    private void emitLoadImmediate(Register Rd, int imm32) {\n+        long upper = imm32, lower = imm32;\n+        lower = (lower << 52) >> 52;\n+        upper -= lower;\n+        upper = (int) upper;\n+        emitLui(Rd, (int) (upper >> 12));\n+        emitAddW(Rd, Rd, (int) lower);\n+    }\n+\n+    private void emitLoadRegister(Register Rd, RISCV64Kind kind, Register Rn, int offset) {\n+        \/\/ LB\/LH\/LW\/LD (immediate)\n+        assert offset >= 0;\n+        int size = 0;\n+        int opc = 0;\n+        switch (kind) {\n+            case BYTE: size = 0b000; opc = 0b0000011; break;\n+            case WORD: size = 0b001; opc = 0b0000011; break;\n+            case DWORD: size = 0b010; opc = 0b0000011; break;\n+            case QWORD: size = 0b011; opc = 0b0000011; break;\n+            case SINGLE: size = 0b010; opc = 0b0000111; break;\n+            case DOUBLE: size = 0b011; opc = 0b0000111; break;\n+            default: throw new IllegalArgumentException();\n+        }\n+        code.emitInt(f(offset, 31, 20) | f(Rn, 19, 15) | f(size, 14, 12) | f(Rd, 11, 7) | f(opc, 6, 0));\n+    }\n+\n+    private void emitStoreRegister(Register Rd, RISCV64Kind kind, Register Rn, int offset) {\n+        \/\/ SB\/SH\/SW\/SD (immediate)\n+        assert offset >= 0;\n+        int size = 0;\n+        int opc = 0;\n+        switch (kind) {\n+            case BYTE: size = 0b000; opc = 0b0100011; break;\n+            case WORD: size = 0b001; opc = 0b0100011; break;\n+            case DWORD: size = 0b010; opc = 0b0100011; break;\n+            case QWORD: size = 0b011; opc = 0b0100011; break;\n+            case SINGLE: size = 0b010; opc = 0b0100111; break;\n+            case DOUBLE: size = 0b011; opc = 0b0100111; break;\n+            default: throw new IllegalArgumentException();\n+        }\n+        code.emitInt(f((offset >> 5), 31, 25) | f(Rd, 24, 20) | f(Rn, 19, 15) | f(size, 14, 12) | f((offset & 0x1f), 11, 7) | f(opc, 6, 0));\n+    }\n+\n+    private void emitJalr(Register Rd, Register Rn, int imm) {\n+        code.emitInt(instructionImmediate(imm & 0xfff, Rn.encoding, 0b000, Rd.encoding, 0b1100111));\n+    }\n+\n+    private void emitFmv(Register Rd, RISCV64Kind kind, Register Rn) {\n+        int funct = 0;\n+        switch (kind) {\n+            case SINGLE: funct = 0b1111000; break;\n+            case DOUBLE: funct = 0b1111001; break;\n+            default: throw new IllegalArgumentException();\n+        }\n+        code.emitInt(instructionRegister(funct, 0b00000, Rn.encoding, 0b000, Rd.encoding, 0b1010011));\n+    }\n+\n+    @Override\n+    public void emitGrowStack(int size) {\n+        assert size % 16 == 0;\n+        if (size > -2048 && size < 0) {\n+            emitAdd(RISCV64.x2, RISCV64.x2, -size);\n+        } else if (size == 0) {\n+            \/\/ No-op\n+        } else if (size < 2048) {\n+            emitSub(RISCV64.x2, RISCV64.x2, size);\n+        } else if (size < 65535) {\n+            emitLoadImmediate(scratchRegister, size);\n+            emitSub(RISCV64.x2, RISCV64.x2, scratchRegister);\n+        } else {\n+            throw new IllegalArgumentException();\n+        }\n+    }\n+\n+    @Override\n+    public void emitPrologue() {\n+        \/\/ Must be patchable by NativeJump::patch_verified_entry\n+        emitNop();\n+        emitAdd(RISCV64.x2, RISCV64.x2, -32); \/\/ addi sp sp -32\n+        emitStoreRegister(RISCV64.x8, RISCV64Kind.QWORD, RISCV64.x2, 0); \/\/ sd x8 sp(0)\n+        emitStoreRegister(RISCV64.x1, RISCV64Kind.QWORD, RISCV64.x2, 8); \/\/ sd x1 sp(8)\n+        emitMv(RISCV64.x8, RISCV64.x2); \/\/ mv x8, x2\n+\n+        setDeoptRescueSlot(newStackSlot(RISCV64Kind.QWORD));\n+    }\n+\n+    @Override\n+    public void emitEpilogue() {\n+        recordMark(config.MARKID_DEOPT_HANDLER_ENTRY);\n+        recordCall(new HotSpotForeignCallTarget(config.handleDeoptStub), 6*4, true, null);\n+        emitCall(0xdeaddeaddeadL);\n+    }\n+\n+    @Override\n+    public void emitCallPrologue(CallingConvention cc, Object... prim) {\n+        emitGrowStack(cc.getStackSize());\n+        frameSize += cc.getStackSize();\n+        AllocatableValue[] args = cc.getArguments();\n+        for (int i = 0; i < args.length; i++) {\n+            emitLoad(args[i], prim[i]);\n+        }\n+    }\n+\n+    @Override\n+    public void emitCallEpilogue(CallingConvention cc) {\n+        emitGrowStack(-cc.getStackSize());\n+        frameSize -= cc.getStackSize();\n+    }\n+\n+    @Override\n+    public void emitCall(long addr) {\n+        emitMovPtrHelper(scratchRegister, addr);\n+        emitJalr(RISCV64.x1, scratchRegister, (int) (addr & 0x3f));\n+    }\n+\n+    @Override\n+    public void emitLoad(AllocatableValue av, Object prim) {\n+        if (av instanceof RegisterValue) {\n+            Register reg = ((RegisterValue) av).getRegister();\n+            if (prim instanceof Float) {\n+                emitLoadFloat(reg, (Float) prim);\n+            } else if (prim instanceof Double) {\n+                emitLoadDouble(reg, (Double) prim);\n+            } else if (prim instanceof Integer) {\n+                emitLoadInt(reg, (Integer) prim);\n+            } else if (prim instanceof Long) {\n+                emitLoadLong(reg, (Long) prim);\n+            }\n+        } else if (av instanceof StackSlot) {\n+            StackSlot slot = (StackSlot) av;\n+            if (prim instanceof Float) {\n+                emitFloatToStack(slot, emitLoadFloat(doubleScratch, (Float) prim));\n+            } else if (prim instanceof Double) {\n+                emitDoubleToStack(slot, emitLoadDouble(doubleScratch, (Double) prim));\n+            } else if (prim instanceof Integer) {\n+                emitIntToStack(slot, emitLoadInt(scratchRegister, (Integer) prim));\n+            } else if (prim instanceof Long) {\n+                emitLongToStack(slot, emitLoadLong(scratchRegister, (Long) prim));\n+            } else {\n+                assert false : \"Unimplemented\";\n+            }\n+        } else {\n+            throw new IllegalArgumentException(\"Unknown value \" + av);\n+        }\n+    }\n+\n+    private void emitLoad32(Register ret, int addr) {\n+        long upper = addr, lower = addr;\n+        lower = (lower << 52) >> 52;\n+        upper -= lower;\n+        upper = (int) upper;\n+        emitLui(ret, (int) (upper >> 12));\n+        emitAdd(ret, ret, (int) lower);\n+    }\n+\n+    private void emitMovPtrHelper(Register ret, long addr) {\n+        \/\/ 48-bit VA\n+        assert (addr >> 48) == 0 : \"invalid pointer\" + Long.toHexString(addr);\n+        emitLoad32(ret, (int) (addr >> 17));\n+        emitShiftLeft(ret, ret, 11);\n+        emitAdd(ret, ret, (int) ((addr >> 6) & 0x7ff));\n+        emitShiftLeft(ret, ret, 6);\n+    }\n+\n+    private void emitLoadPointer32(Register ret, int addr) {\n+        emitLoadImmediate(ret, addr);\n+        \/\/ Lui sign-extends the value, which we do not want\n+        emitShiftLeft(ret, ret, 32);\n+        emitShiftRight(ret, ret, 32);\n+    }\n+\n+    private void emitLoadPointer48(Register ret, long addr) {\n+        emitMovPtrHelper(ret, addr);\n+        emitAdd(ret, ret, (int) (addr & 0x3f));\n+    }\n+\n+    @Override\n+    public Register emitLoadPointer(HotSpotConstant c) {\n+        recordDataPatchInCode(new ConstantReference((VMConstant) c));\n+\n+        Register ret = newRegister();\n+        if (c.isCompressed()) {\n+            emitLoadPointer32(ret, 0xdeaddead);\n+        } else {\n+            emitLoadPointer48(ret, 0xdeaddeaddeadL);\n+        }\n+        return ret;\n+    }\n+\n+    @Override\n+    public Register emitLoadPointer(Register b, int offset) {\n+        Register ret = newRegister();\n+        emitLoadRegister(ret, RISCV64Kind.QWORD, b, offset & 0xfff);\n+        return ret;\n+    }\n+\n+    @Override\n+    public Register emitLoadNarrowPointer(DataSectionReference ref) {\n+        recordDataPatchInCode(ref);\n+\n+        Register ret = newRegister();\n+        emitAuipc(ret, 0xdead >> 11);\n+        emitLoadRegister(ret, RISCV64Kind.DWORD, ret, 0xdead & 0x7ff);\n+        \/\/ The value is sign-extendsed, which we do not want\n+        emitShiftLeft(ret, ret, 32);\n+        emitShiftRight(ret, ret, 32);\n+        return ret;\n+    }\n+\n+    @Override\n+    public Register emitLoadPointer(DataSectionReference ref) {\n+        recordDataPatchInCode(ref);\n+\n+        Register ret = newRegister();\n+        emitAuipc(ret, 0xdead >> 11);\n+        emitLoadRegister(ret, RISCV64Kind.QWORD, ret, 0xdead & 0x7ff);\n+        return ret;\n+    }\n+\n+    private Register emitLoadDouble(Register reg, double c) {\n+        DataSectionReference ref = new DataSectionReference();\n+        ref.setOffset(data.position());\n+        data.emitDouble(c);\n+\n+        recordDataPatchInCode(ref);\n+        emitAuipc(scratchRegister, 0xdead >> 11);\n+        emitLoadRegister(scratchRegister, RISCV64Kind.QWORD, scratchRegister, 0xdead & 0x7ff);\n+        if (reg.getRegisterCategory().equals(RISCV64.FP)) {\n+            emitFmv(reg, RISCV64Kind.DOUBLE, scratchRegister);\n+        } else {\n+            emitMv(reg, scratchRegister);\n+        }\n+        return reg;\n+    }\n+\n+    private Register emitLoadFloat(Register reg, float c) {\n+        DataSectionReference ref = new DataSectionReference();\n+        ref.setOffset(data.position());\n+        data.emitFloat(c);\n+\n+        recordDataPatchInCode(ref);\n+        emitAuipc(scratchRegister, 0xdead >> 11);\n+        emitLoadRegister(scratchRegister, RISCV64Kind.DWORD, scratchRegister, 0xdead & 0x7ff);\n+        if (reg.getRegisterCategory().equals(RISCV64.FP)) {\n+            emitFmv(reg, RISCV64Kind.SINGLE, scratchRegister);\n+        } else {\n+            emitMv(reg, scratchRegister);\n+        }\n+        return reg;\n+    }\n+\n+    @Override\n+    public Register emitLoadFloat(float c) {\n+        Register ret = RISCV64.f10;\n+        return emitLoadFloat(ret, c);\n+    }\n+\n+    private Register emitLoadLong(Register reg, long c) {\n+        long lower = c & 0xffffffff;\n+        lower = lower - ((lower << 44) >> 44);\n+        emitLoad32(reg, (int) ((c >> 32) & 0xffffffff));\n+        emitShiftLeft(reg, reg, 12);\n+        emitAdd(reg, reg, (int) ((lower >> 20) & 0xfff));\n+        emitShiftLeft(reg, reg, 12);\n+        emitAdd(reg, reg, (int) ((c << 44) >> 52));\n+        emitShiftLeft(reg, reg, 8);\n+        emitAdd(reg, reg, (int) (c & 0xff));\n+        return reg;\n+    }\n+\n+    @Override\n+    public Register emitLoadLong(long c) {\n+        Register ret = newRegister();\n+        return emitLoadLong(ret, c);\n+    }\n+\n+    private Register emitLoadInt(Register reg, int c) {\n+        emitLoadImmediate(reg, c);\n+        return reg;\n+    }\n+\n+    @Override\n+    public Register emitLoadInt(int c) {\n+        Register ret = newRegister();\n+        return emitLoadInt(ret, c);\n+    }\n+\n+    @Override\n+    public Register emitIntArg0() {\n+        return codeCache.getRegisterConfig()\n+            .getCallingConventionRegisters(HotSpotCallingConventionType.JavaCall, JavaKind.Int)\n+            .get(0);\n+    }\n+\n+    @Override\n+    public Register emitIntArg1() {\n+        return codeCache.getRegisterConfig()\n+            .getCallingConventionRegisters(HotSpotCallingConventionType.JavaCall, JavaKind.Int)\n+            .get(1);\n+    }\n+\n+    @Override\n+    public Register emitIntAdd(Register a, Register b) {\n+        emitAdd(a, a, b);\n+        return a;\n+    }\n+\n+    @Override\n+    public void emitTrap(DebugInfo info) {\n+        \/\/ Dereference null pointer\n+        emitAdd(scratchRegister, RISCV64.x0, 0);\n+        recordImplicitException(info);\n+        emitLoadRegister(RISCV64.x0, RISCV64Kind.QWORD, scratchRegister, 0);\n+    }\n+\n+    @Override\n+    public void emitIntRet(Register a) {\n+        emitMv(RISCV64.x10, a);\n+        emitMv(RISCV64.x2, RISCV64.x8);  \/\/ mv sp, x8\n+        emitLoadRegister(RISCV64.x8, RISCV64Kind.QWORD, RISCV64.x2, 0);  \/\/ ld x8 0(sp)\n+        emitLoadRegister(RISCV64.x1, RISCV64Kind.QWORD, RISCV64.x2, 8);  \/\/ ld x1 8(sp)\n+        emitAdd(RISCV64.x2, RISCV64.x2, 32);  \/\/ addi sp sp 32\n+        emitJalr(RISCV64.x0, RISCV64.x1, 0);  \/\/ ret\n+    }\n+\n+    @Override\n+    public void emitFloatRet(Register a) {\n+        assert a == RISCV64.f10 : \"Unimplemented move \" + a;\n+        emitMv(RISCV64.x2, RISCV64.x8);  \/\/ mv sp, x8\n+        emitLoadRegister(RISCV64.x8, RISCV64Kind.QWORD, RISCV64.x2, 0);  \/\/ ld x8 0(sp)\n+        emitLoadRegister(RISCV64.x1, RISCV64Kind.QWORD, RISCV64.x2, 8);  \/\/ ld x1 8(sp)\n+        emitAdd(RISCV64.x2, RISCV64.x2, 32);  \/\/ addi sp sp 32\n+        emitJalr(RISCV64.x0, RISCV64.x1, 0);  \/\/ ret\n+    }\n+\n+    @Override\n+    public void emitPointerRet(Register a) {\n+        emitIntRet(a);\n+    }\n+\n+    @Override\n+    public StackSlot emitPointerToStack(Register a) {\n+        return emitLongToStack(a);\n+    }\n+\n+    @Override\n+    public StackSlot emitNarrowPointerToStack(Register a) {\n+        return emitIntToStack(a);\n+    }\n+\n+    @Override\n+    public Register emitUncompressPointer(Register compressed, long base, int shift) {\n+        if (shift > 0) {\n+            emitShiftLeft(compressed, compressed, shift);\n+        }\n+\n+        if (base != 0) {\n+            emitLoadLong(scratchRegister, base);\n+            emitAdd(compressed, compressed, scratchRegister);\n+        }\n+\n+        return compressed;\n+    }\n+\n+    private StackSlot emitDoubleToStack(StackSlot slot, Register a) {\n+        emitStoreRegister(a, RISCV64Kind.DOUBLE, RISCV64.x2, slot.getOffset(frameSize) & 0xfff);\n+        return slot;\n+    }\n+\n+    @Override\n+    public StackSlot emitDoubleToStack(Register a) {\n+        StackSlot ret = newStackSlot(RISCV64Kind.DOUBLE);\n+        return emitDoubleToStack(ret, a);\n+    }\n+\n+    private StackSlot emitFloatToStack(StackSlot slot, Register a) {\n+        emitStoreRegister(a, RISCV64Kind.SINGLE, RISCV64.x2, slot.getOffset(frameSize) & 0xfff);\n+        return slot;\n+    }\n+\n+    @Override\n+    public StackSlot emitFloatToStack(Register a) {\n+        StackSlot ret = newStackSlot(RISCV64Kind.SINGLE);\n+        return emitFloatToStack(ret, a);\n+    }\n+\n+    private StackSlot emitIntToStack(StackSlot slot, Register a) {\n+        emitStoreRegister(a, RISCV64Kind.DWORD, RISCV64.x2, slot.getOffset(frameSize) & 0xfff);\n+        return slot;\n+    }\n+\n+    @Override\n+    public StackSlot emitIntToStack(Register a) {\n+        StackSlot ret = newStackSlot(RISCV64Kind.DWORD);\n+        return emitIntToStack(ret, a);\n+    }\n+\n+    private StackSlot emitLongToStack(StackSlot slot, Register a) {\n+        emitStoreRegister(a, RISCV64Kind.QWORD, RISCV64.x2, slot.getOffset(frameSize) & 0xfff);\n+        return slot;\n+    }\n+\n+    @Override\n+    public StackSlot emitLongToStack(Register a) {\n+        StackSlot ret = newStackSlot(RISCV64Kind.QWORD);\n+        return emitLongToStack(ret, a);\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.code.test\/src\/jdk\/vm\/ci\/code\/test\/riscv64\/RISCV64TestAssembler.java","additions":543,"deletions":0,"binary":false,"changes":543,"status":"added"}]}