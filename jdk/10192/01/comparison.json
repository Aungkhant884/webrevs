{"files":[{"patch":"@@ -5070,0 +5070,42 @@\n+instruct vmaskcast_extend_neon(vReg dst, vReg src) %{\n+  predicate(UseSVE == 0 &&\n+            Matcher::vector_length_in_bytes(n) > Matcher::vector_length_in_bytes(n->in(1)));\n+  match(Set dst (VectorMaskCast src));\n+  format %{ \"vmaskcast_extend_neon $dst, $src\" %}\n+  ins_encode %{\n+    BasicType dst_bt = Matcher::vector_element_basic_type(this);\n+    if (is_floating_point_type(dst_bt)) {\n+      dst_bt = (dst_bt == T_FLOAT) ? T_INT : T_LONG;\n+    }\n+    uint length_in_bytes_dst = Matcher::vector_length_in_bytes(this);\n+    BasicType src_bt = Matcher::vector_element_basic_type(this, $src);\n+    if (is_floating_point_type(src_bt)) {\n+      src_bt = (src_bt == T_FLOAT) ? T_INT : T_LONG;\n+    }\n+    __ neon_vector_extend($dst$$FloatRegister, dst_bt, length_in_bytes_dst,\n+                          $src$$FloatRegister, src_bt);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmaskcast_narrow_neon(vReg dst, vReg src) %{\n+  predicate(UseSVE == 0 &&\n+            Matcher::vector_length_in_bytes(n) < Matcher::vector_length_in_bytes(n->in(1)));\n+  match(Set dst (VectorMaskCast src));\n+  format %{ \"vmaskcast_narrow_neon $dst, $src\" %}\n+  ins_encode %{\n+    BasicType dst_bt = Matcher::vector_element_basic_type(this);\n+    if (is_floating_point_type(dst_bt)) {\n+      dst_bt = (dst_bt == T_FLOAT) ? T_INT : T_LONG;\n+    }\n+    BasicType src_bt = Matcher::vector_element_basic_type(this, $src);\n+    if (is_floating_point_type(src_bt)) {\n+      src_bt = (src_bt == T_FLOAT) ? T_INT : T_LONG;\n+    }\n+    uint length_in_bytes_src = Matcher::vector_length_in_bytes(this, $src);\n+    __ neon_vector_narrow($dst$$FloatRegister, dst_bt,\n+                          $src$$FloatRegister, src_bt, length_in_bytes_src);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -5080,1 +5122,1 @@\n-instruct vmaskcast_extend(pRegGov dst, pReg src) %{\n+instruct vmaskcast_extend_sve(pRegGov dst, pReg src) %{\n@@ -5084,1 +5126,1 @@\n-  format %{ \"vmaskcast_extend $dst, $src\" %}\n+  format %{ \"vmaskcast_extend_sve $dst, $src\" %}\n@@ -5097,1 +5139,1 @@\n-instruct vmaskcast_narrow(pRegGov dst, pReg src) %{\n+instruct vmaskcast_narrow_sve(pRegGov dst, pReg src) %{\n@@ -5101,1 +5143,1 @@\n-  format %{ \"vmaskcast_narrow $dst, $src\" %}\n+  format %{ \"vmaskcast_narrow_sve $dst, $src\" %}\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector.ad","additions":46,"deletions":4,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -3476,0 +3476,42 @@\n+instruct vmaskcast_extend_neon(vReg dst, vReg src) %{\n+  predicate(UseSVE == 0 &&\n+            Matcher::vector_length_in_bytes(n) > Matcher::vector_length_in_bytes(n->in(1)));\n+  match(Set dst (VectorMaskCast src));\n+  format %{ \"vmaskcast_extend_neon $dst, $src\" %}\n+  ins_encode %{\n+    BasicType dst_bt = Matcher::vector_element_basic_type(this);\n+    if (is_floating_point_type(dst_bt)) {\n+      dst_bt = (dst_bt == T_FLOAT) ? T_INT : T_LONG;\n+    }\n+    uint length_in_bytes_dst = Matcher::vector_length_in_bytes(this);\n+    BasicType src_bt = Matcher::vector_element_basic_type(this, $src);\n+    if (is_floating_point_type(src_bt)) {\n+      src_bt = (src_bt == T_FLOAT) ? T_INT : T_LONG;\n+    }\n+    __ neon_vector_extend($dst$$FloatRegister, dst_bt, length_in_bytes_dst,\n+                          $src$$FloatRegister, src_bt);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmaskcast_narrow_neon(vReg dst, vReg src) %{\n+  predicate(UseSVE == 0 &&\n+            Matcher::vector_length_in_bytes(n) < Matcher::vector_length_in_bytes(n->in(1)));\n+  match(Set dst (VectorMaskCast src));\n+  format %{ \"vmaskcast_narrow_neon $dst, $src\" %}\n+  ins_encode %{\n+    BasicType dst_bt = Matcher::vector_element_basic_type(this);\n+    if (is_floating_point_type(dst_bt)) {\n+      dst_bt = (dst_bt == T_FLOAT) ? T_INT : T_LONG;\n+    }\n+    BasicType src_bt = Matcher::vector_element_basic_type(this, $src);\n+    if (is_floating_point_type(src_bt)) {\n+      src_bt = (src_bt == T_FLOAT) ? T_INT : T_LONG;\n+    }\n+    uint length_in_bytes_src = Matcher::vector_length_in_bytes(this, $src);\n+    __ neon_vector_narrow($dst$$FloatRegister, dst_bt,\n+                          $src$$FloatRegister, src_bt, length_in_bytes_src);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -3486,1 +3528,1 @@\n-instruct vmaskcast_extend(pRegGov dst, pReg src) %{\n+instruct vmaskcast_extend_sve(pRegGov dst, pReg src) %{\n@@ -3490,1 +3532,1 @@\n-  format %{ \"vmaskcast_extend $dst, $src\" %}\n+  format %{ \"vmaskcast_extend_sve $dst, $src\" %}\n@@ -3503,1 +3545,1 @@\n-instruct vmaskcast_narrow(pRegGov dst, pReg src) %{\n+instruct vmaskcast_narrow_sve(pRegGov dst, pReg src) %{\n@@ -3507,1 +3549,1 @@\n-  format %{ \"vmaskcast_narrow $dst, $src\" %}\n+  format %{ \"vmaskcast_narrow_sve $dst, $src\" %}\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector_ad.m4","additions":46,"deletions":4,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -4618,0 +4618,133 @@\n+void C2_MacroAssembler::vector_mask_cast(XMMRegister dst, XMMRegister src,\n+                                         BasicType dst_bt, BasicType src_bt, int vlen) {\n+  int vlen_enc = vector_length_encoding(MAX2(type2aelembytes(src_bt), type2aelembytes(dst_bt)) * vlen);\n+  int dst_bt_size = type2aelembytes(dst_bt);\n+  int src_bt_size = type2aelembytes(src_bt);\n+  if (dst_bt_size > src_bt_size) {\n+    switch (dst_bt_size \/ src_bt_size) {\n+      case 2: {\n+        if (vlen_enc == AVX_512bit && !VM_Version::supports_avx512bw()) {\n+          vpmovsxwd(dst, src, vlen_enc);\n+        } else {\n+          vpmovsxbw(dst, src, vlen_enc);\n+        }\n+        break;\n+      }\n+      case 4: vpmovsxbd(dst, src, vlen_enc); break;\n+      case 8: vpmovsxbq(dst, src, vlen_enc); break;\n+      default: ShouldNotReachHere();\n+    }\n+  } else {\n+    assert(dst_bt_size < src_bt_size, \"\");\n+    switch (src_bt_size \/ dst_bt_size) {\n+      case 2: {\n+        if (vlen_enc == AVX_512bit) {\n+          if (VM_Version::supports_avx512bw()) {\n+            evpmovwb(dst, src, vlen_enc);\n+          } else {\n+            evpmovdw(dst, src, vlen_enc);\n+          }\n+        } else if (VM_Version::supports_avx512vl()) {\n+          if (VM_Version::supports_avx512bw()) {\n+            evpmovwb(dst, src, vlen_enc);\n+          } else if (dst_bt != T_BYTE) {\n+            evpmovdw(dst, src, vlen_enc);\n+          } else if (vlen_enc == AVX_128bit) {\n+            vpacksswb(dst, src, src, vlen_enc);\n+          } else {\n+            vpacksswb(dst, src, src, vlen_enc);\n+            vpermq(dst, dst, 0x08, vlen_enc);\n+          }\n+        } else {\n+          if (vlen_enc == AVX_128bit) {\n+            vpacksswb(dst, src, src, vlen_enc);\n+          } else {\n+            vpacksswb(dst, src, src, vlen_enc);\n+            vpermq(dst, dst, 0x08, vlen_enc);\n+          }\n+        }\n+        break;\n+      }\n+      case 4: {\n+        if (vlen_enc == AVX_512bit || VM_Version::supports_avx512vl()) {\n+          evpmovdb(dst, src, vlen_enc);\n+        } else if (vlen_enc == AVX_128bit) {\n+          vpackssdw(dst, src, src, vlen_enc);\n+          vpacksswb(dst, dst, dst, vlen_enc);\n+        } else {\n+          vpackssdw(dst, src, src, vlen_enc);\n+          vpermq(dst, dst, 0x08, vlen_enc);\n+          vpacksswb(dst, dst, dst, AVX_128bit);\n+        }\n+        break;\n+      }\n+      case 8: {\n+        if (vlen_enc == AVX_512bit || VM_Version::supports_avx512vl()) {\n+          evpmovqb(dst, src, vlen_enc);\n+        } else if (vlen_enc == AVX_128bit) {\n+          vpshufd(dst, src, 0x08, vlen_enc);\n+          vpackssdw(dst, dst, dst, vlen_enc);\n+          vpacksswb(dst, dst, dst, vlen_enc);\n+        } else {\n+          vpshufd(dst, src, 0x08, vlen_enc);\n+          vpermq(dst, dst, 0x08, vlen_enc);\n+          vpackssdw(dst, dst, dst, AVX_128bit);\n+          vpacksswb(dst, dst, dst, AVX_128bit);\n+        }\n+        break;\n+      }\n+      default: ShouldNotReachHere();\n+    }\n+  }\n+}\n+\n+void C2_MacroAssembler::vector_mask_cast(XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n+                                         XMMRegister xtmp2, BasicType dst_bt, BasicType src_bt, int vlen) {\n+  int dst_bt_size = type2aelembytes(dst_bt);\n+  int src_bt_size = type2aelembytes(src_bt);\n+  if (dst_bt_size > src_bt_size) {\n+    switch (dst_bt_size \/ src_bt_size) {\n+      case 2:\n+        vpmovsxbw(xtmp1, src, AVX_128bit);\n+        vpshufd(xtmp2, src, 0x0E, AVX_128bit);\n+        vpmovsxbw(xtmp2, xtmp2, AVX_128bit);\n+        vinsertf128(dst, xtmp1, xtmp2, 0x01);\n+        break;\n+      case 4:\n+        vpmovsxbd(xtmp1, src, AVX_128bit);\n+        vpshufd(xtmp2, src, 0x01, AVX_128bit);\n+        vpmovsxbd(xtmp2, xtmp2, AVX_128bit);\n+        vinsertf128(dst, xtmp1, xtmp2, 0x01);\n+        break;\n+      case 8:\n+        vpmovsxbq(xtmp1, src, AVX_128bit);\n+        pshuflw(xtmp2, src, 0x01);\n+        vpmovsxbq(xtmp2, xtmp2, AVX_128bit);\n+        vinsertf128(dst, xtmp1, xtmp2, 0x01);\n+        break;\n+      default: ShouldNotReachHere();\n+    }\n+  } else {\n+    assert(dst_bt_size < src_bt_size, \"\");\n+    assert(xtmp2 == xnoreg, \"\");\n+    switch (src_bt_size \/ dst_bt_size) {\n+      case 2:\n+        vextractf128(xtmp1, src, 0x01);\n+        vpacksswb(dst, src, xtmp1, AVX_128bit);\n+        break;\n+      case 4:\n+        vextractf128(xtmp1, src, 0x01);\n+        vpackssdw(dst, src, xtmp1, AVX_128bit);\n+        vpacksswb(dst, dst, dst, AVX_128bit);\n+        break;\n+      case 8:\n+        vpermilps(dst, src, 0x08, AVX_256bit);\n+        vpermpd(dst, dst, 0x08, AVX_256bit);\n+        vpackssdw(dst, dst, dst, AVX_128bit);\n+        vpacksswb(dst, dst, dst, AVX_128bit);\n+        break;\n+      default: ShouldNotReachHere();\n+    }\n+  }\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":133,"deletions":0,"binary":false,"changes":133,"status":"modified"},{"patch":"@@ -342,0 +342,5 @@\n+  void vector_mask_cast(XMMRegister dst, XMMRegister src, BasicType dst_bt, BasicType src_bt, int vlen);\n+\n+  void vector_mask_cast(XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n+                        XMMRegister xtmp2, BasicType dst_bt, BasicType src_bt, int vlen);\n+\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1481,0 +1481,1 @@\n+    case Op_VectorMaskCast:\n@@ -8418,0 +8419,51 @@\n+instruct vmaskcast_avx(vec dst, vec src) %{\n+  predicate(Matcher::vector_length(n) == Matcher::vector_length(n->in(1)) &&\n+            Matcher::vector_length_in_bytes(n) != Matcher::vector_length_in_bytes(n->in(1)) &&\n+            (UseAVX >= 2 ||\n+             (Matcher::vector_length_in_bytes(n) != 32 &&\n+              Matcher::vector_length_in_bytes(n->in(1)) != 32)));\n+  match(Set dst (VectorMaskCast src));\n+  format %{ \"vector_mask_cast $dst, $src\" %}\n+  ins_encode %{\n+    int vlen = Matcher::vector_length(this);\n+    BasicType src_bt = Matcher::vector_element_basic_type(this, $src);\n+    BasicType dst_bt = Matcher::vector_element_basic_type(this);\n+    __ vector_mask_cast($dst$$XMMRegister, $src$$XMMRegister, dst_bt, src_bt, vlen);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmaskcast_avx1_32B_expand(vec dst, vec src, vec xtmp1, vec xtmp2) %{\n+  predicate(UseAVX == 1 && Matcher::vector_length_in_bytes(n) == 32 &&\n+            Matcher::vector_length(n) == Matcher::vector_length(n->in(1)) &&\n+            Matcher::vector_length_in_bytes(n) > Matcher::vector_length_in_bytes(n->in(1)));\n+  match(Set dst (VectorMaskCast src));\n+  effect(TEMP xtmp1, TEMP xtmp2);\n+  format %{ \"vector_mask_cast $dst, $src\\t! using $xtmp1, $xtmp2 as TEMP\" %}\n+  ins_encode %{\n+    int vlen = Matcher::vector_length(this);\n+    BasicType src_bt = Matcher::vector_element_basic_type(this, $src);\n+    BasicType dst_bt = Matcher::vector_element_basic_type(this);\n+    __ vector_mask_cast($dst$$XMMRegister, $src$$XMMRegister, $xtmp1$$XMMRegister,\n+                                 $xtmp2$$XMMRegister, dst_bt, src_bt, vlen);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmaskcast_avx1_32B_shrink(vec dst, vec src, vec xtmp) %{\n+  predicate(UseAVX == 1 && Matcher::vector_length_in_bytes(n->in(1)) == 32 &&\n+            Matcher::vector_length(n) == Matcher::vector_length(n->in(1)) &&\n+            Matcher::vector_length_in_bytes(n) < Matcher::vector_length_in_bytes(n->in(1)));\n+  match(Set dst (VectorMaskCast src));\n+  effect(TEMP xtmp);\n+  format %{ \"vector_mask_cast $dst, $src\\t! using $xtmp as TEMP\" %}\n+  ins_encode %{\n+    int vlen = Matcher::vector_length(this);\n+    BasicType src_bt = Matcher::vector_element_basic_type(this, $src);\n+    BasicType dst_bt = Matcher::vector_element_basic_type(this);\n+    __ vector_mask_cast($dst$$XMMRegister, $src$$XMMRegister, $xtmp$$XMMRegister,\n+                                 xnoreg, dst_bt, src_bt, vlen);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":52,"deletions":0,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -2492,9 +2492,1 @@\n-    BasicType new_elem_bt_to = elem_bt_to;\n-    BasicType new_elem_bt_from = elem_bt_from;\n-    if (is_mask && is_floating_point_type(elem_bt_from)) {\n-      new_elem_bt_from = elem_bt_from == T_FLOAT ? T_INT : T_LONG;\n-    }\n-    if (is_mask && is_floating_point_type(elem_bt_to)) {\n-      new_elem_bt_to = elem_bt_to == T_FLOAT ? T_INT : T_LONG;\n-    }\n-    int cast_vopc = VectorCastNode::opcode(new_elem_bt_from, !is_ucast);\n+    int cast_vopc = VectorCastNode::opcode(elem_bt_from, !is_ucast);\n@@ -2502,5 +2494,3 @@\n-    \/\/ Make sure that vector cast is implemented to particular type\/size combination.\n-    bool no_vec_cast_check = is_mask &&\n-                             ((src_type->isa_vectmask() && dst_type->isa_vectmask()) ||\n-                              type2aelembytes(elem_bt_from) == type2aelembytes(elem_bt_to));\n-    if (!no_vec_cast_check && !arch_supports_vector(cast_vopc, num_elem_to, new_elem_bt_to, VecMaskNotUsed)) {\n+    \/\/ Make sure that vector cast is implemented to particular type\/size combination if it is\n+    \/\/ not a mask casting.\n+    if (!is_mask && !arch_supports_vector(cast_vopc, num_elem_to, elem_bt_to, VecMaskNotUsed)) {\n@@ -2509,1 +2499,1 @@\n-                      cast_vopc, num_elem_to, type2name(new_elem_bt_to), is_mask);\n+                      cast_vopc, num_elem_to, type2name(elem_bt_to), is_mask);\n@@ -2556,5 +2546,7 @@\n-        if ((dst_type->isa_vectmask() && src_type->isa_vectmask()) ||\n-            (type2aelembytes(elem_bt_from) == type2aelembytes(elem_bt_to))) {\n-          op = gvn().transform(new VectorMaskCastNode(op, dst_type));\n-        } else {\n-          op = VectorMaskCastNode::makeCastNode(&gvn(), op, dst_type);\n+        \/\/ Make sure that cast for vector mask is implemented to particular type\/size combination.\n+        if (!arch_supports_vector(Op_VectorMaskCast, num_elem_to, elem_bt_to, VecMaskNotUsed)) {\n+          if (C->print_intrinsics()) {\n+            tty->print_cr(\"  ** not supported: arity=1 op=maskcast vlen2=%d etype2=%s ismask=%d\",\n+                          num_elem_to, type2name(elem_bt_to), is_mask);\n+          }\n+          return false;\n@@ -2562,0 +2554,1 @@\n+        op = gvn().transform(new VectorMaskCastNode(op, dst_type));\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":13,"deletions":20,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -1622,0 +1622,1 @@\n+          \/\/ VectorUnbox (VectorBox vmask) ==> VectorMaskCast vmask\n@@ -1623,10 +1624,1 @@\n-          if (in_vt->length_in_bytes() == out_vt->length_in_bytes() &&\n-              Matcher::match_rule_supported_vector(Op_VectorMaskCast, out_vt->length(), out_vt->element_basic_type())) {\n-            \/\/ Apply \"VectorUnbox (VectorBox vmask) ==> VectorMaskCast (vmask)\"\n-            \/\/ directly. This could avoid the transformation ordering issue from\n-            \/\/ \"VectorStoreMask (VectorLoadMask vmask) => vmask\".\n-            return new VectorMaskCastNode(value, vmask_type);\n-          }\n-          \/\/ VectorUnbox (VectorBox vmask) ==> VectorLoadMask (VectorStoreMask vmask)\n-          value = phase->transform(VectorStoreMaskNode::make(*phase, value, in_vt->element_basic_type(), in_vt->length()));\n-          return new VectorLoadMaskNode(value, vmask_type);\n+          return new VectorMaskCastNode(value, vmask_type);\n@@ -1723,42 +1715,0 @@\n-Node* VectorMaskCastNode::makeCastNode(PhaseGVN* phase, Node* src, const TypeVect* dst_type) {\n-  const TypeVect* src_type = src->bottom_type()->is_vect();\n-  assert(src_type->length() == dst_type->length(), \"\");\n-\n-  int num_elem = src_type->length();\n-  BasicType elem_bt_from = src_type->element_basic_type();\n-  BasicType elem_bt_to = dst_type->element_basic_type();\n-\n-  if (dst_type->isa_vectmask() == NULL && src_type->isa_vectmask() == NULL &&\n-      type2aelembytes(elem_bt_from) != type2aelembytes(elem_bt_to)) {\n-\n-    Node* op = src;\n-    BasicType new_elem_bt_from = elem_bt_from;\n-    BasicType new_elem_bt_to = elem_bt_to;\n-    if (is_floating_point_type(elem_bt_from)) {\n-      new_elem_bt_from =  elem_bt_from == T_FLOAT ? T_INT : T_LONG;\n-    }\n-    if (is_floating_point_type(elem_bt_to)) {\n-      new_elem_bt_to = elem_bt_to == T_FLOAT ? T_INT : T_LONG;\n-    }\n-\n-    \/\/ Special handling for casting operation involving floating point types.\n-    \/\/ Case A) F -> X :=  F -> VectorMaskCast (F->I\/L [NOP]) -> VectorCast[I\/L]2X\n-    \/\/ Case B) X -> F :=  X -> VectorCastX2[I\/L] -> VectorMaskCast ([I\/L]->F [NOP])\n-    \/\/ Case C) F -> F :=  VectorMaskCast (F->I\/L [NOP]) -> VectorCast[I\/L]2[L\/I] -> VectotMaskCast (L\/I->F [NOP])\n-\n-    if (new_elem_bt_from != elem_bt_from) {\n-      const TypeVect* new_src_type = TypeVect::makemask(new_elem_bt_from, num_elem);\n-      op = phase->transform(new VectorMaskCastNode(op, new_src_type));\n-    }\n-\n-    op = phase->transform(VectorCastNode::make(VectorCastNode::opcode(new_elem_bt_from), op, new_elem_bt_to, num_elem));\n-\n-    if (new_elem_bt_to != elem_bt_to) {\n-      op = phase->transform(new VectorMaskCastNode(op, dst_type));\n-    }\n-    return op;\n-  } else {\n-    return new VectorMaskCastNode(src, dst_type);\n-  }\n-}\n-\n@@ -1785,1 +1735,1 @@\n-       return VectorMaskCastNode::makeCastNode(phase, src, dst_type);\n+       return new VectorMaskCastNode(src, dst_type);\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":3,"deletions":53,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -1508,1 +1508,0 @@\n-  static Node* makeCastNode(PhaseGVN* phase, Node* in1, const TypeVect * vt);\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}