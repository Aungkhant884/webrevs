{"files":[{"patch":"@@ -5090,0 +5090,42 @@\n+instruct vmaskcast_extend_neon(vReg dst, vReg src) %{\n+  predicate(UseSVE == 0 &&\n+            Matcher::vector_length_in_bytes(n) > Matcher::vector_length_in_bytes(n->in(1)));\n+  match(Set dst (VectorMaskCast src));\n+  format %{ \"vmaskcast_extend_neon $dst, $src\" %}\n+  ins_encode %{\n+    BasicType dst_bt = Matcher::vector_element_basic_type(this);\n+    if (is_floating_point_type(dst_bt)) {\n+      dst_bt = (dst_bt == T_FLOAT) ? T_INT : T_LONG;\n+    }\n+    uint length_in_bytes_dst = Matcher::vector_length_in_bytes(this);\n+    BasicType src_bt = Matcher::vector_element_basic_type(this, $src);\n+    if (is_floating_point_type(src_bt)) {\n+      src_bt = (src_bt == T_FLOAT) ? T_INT : T_LONG;\n+    }\n+    __ neon_vector_extend($dst$$FloatRegister, dst_bt, length_in_bytes_dst,\n+                          $src$$FloatRegister, src_bt);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmaskcast_narrow_neon(vReg dst, vReg src) %{\n+  predicate(UseSVE == 0 &&\n+            Matcher::vector_length_in_bytes(n) < Matcher::vector_length_in_bytes(n->in(1)));\n+  match(Set dst (VectorMaskCast src));\n+  format %{ \"vmaskcast_narrow_neon $dst, $src\" %}\n+  ins_encode %{\n+    BasicType dst_bt = Matcher::vector_element_basic_type(this);\n+    if (is_floating_point_type(dst_bt)) {\n+      dst_bt = (dst_bt == T_FLOAT) ? T_INT : T_LONG;\n+    }\n+    BasicType src_bt = Matcher::vector_element_basic_type(this, $src);\n+    if (is_floating_point_type(src_bt)) {\n+      src_bt = (src_bt == T_FLOAT) ? T_INT : T_LONG;\n+    }\n+    uint length_in_bytes_src = Matcher::vector_length_in_bytes(this, $src);\n+    __ neon_vector_narrow($dst$$FloatRegister, dst_bt,\n+                          $src$$FloatRegister, src_bt, length_in_bytes_src);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -5100,1 +5142,1 @@\n-instruct vmaskcast_extend(pRegGov dst, pReg src) %{\n+instruct vmaskcast_extend_sve(pRegGov dst, pReg src) %{\n@@ -5104,1 +5146,1 @@\n-  format %{ \"vmaskcast_extend $dst, $src\" %}\n+  format %{ \"vmaskcast_extend_sve $dst, $src\" %}\n@@ -5117,1 +5159,1 @@\n-instruct vmaskcast_narrow(pRegGov dst, pReg src) %{\n+instruct vmaskcast_narrow_sve(pRegGov dst, pReg src) %{\n@@ -5121,1 +5163,1 @@\n-  format %{ \"vmaskcast_narrow $dst, $src\" %}\n+  format %{ \"vmaskcast_narrow_sve $dst, $src\" %}\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector.ad","additions":46,"deletions":4,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -3506,0 +3506,42 @@\n+instruct vmaskcast_extend_neon(vReg dst, vReg src) %{\n+  predicate(UseSVE == 0 &&\n+            Matcher::vector_length_in_bytes(n) > Matcher::vector_length_in_bytes(n->in(1)));\n+  match(Set dst (VectorMaskCast src));\n+  format %{ \"vmaskcast_extend_neon $dst, $src\" %}\n+  ins_encode %{\n+    BasicType dst_bt = Matcher::vector_element_basic_type(this);\n+    if (is_floating_point_type(dst_bt)) {\n+      dst_bt = (dst_bt == T_FLOAT) ? T_INT : T_LONG;\n+    }\n+    uint length_in_bytes_dst = Matcher::vector_length_in_bytes(this);\n+    BasicType src_bt = Matcher::vector_element_basic_type(this, $src);\n+    if (is_floating_point_type(src_bt)) {\n+      src_bt = (src_bt == T_FLOAT) ? T_INT : T_LONG;\n+    }\n+    __ neon_vector_extend($dst$$FloatRegister, dst_bt, length_in_bytes_dst,\n+                          $src$$FloatRegister, src_bt);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmaskcast_narrow_neon(vReg dst, vReg src) %{\n+  predicate(UseSVE == 0 &&\n+            Matcher::vector_length_in_bytes(n) < Matcher::vector_length_in_bytes(n->in(1)));\n+  match(Set dst (VectorMaskCast src));\n+  format %{ \"vmaskcast_narrow_neon $dst, $src\" %}\n+  ins_encode %{\n+    BasicType dst_bt = Matcher::vector_element_basic_type(this);\n+    if (is_floating_point_type(dst_bt)) {\n+      dst_bt = (dst_bt == T_FLOAT) ? T_INT : T_LONG;\n+    }\n+    BasicType src_bt = Matcher::vector_element_basic_type(this, $src);\n+    if (is_floating_point_type(src_bt)) {\n+      src_bt = (src_bt == T_FLOAT) ? T_INT : T_LONG;\n+    }\n+    uint length_in_bytes_src = Matcher::vector_length_in_bytes(this, $src);\n+    __ neon_vector_narrow($dst$$FloatRegister, dst_bt,\n+                          $src$$FloatRegister, src_bt, length_in_bytes_src);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -3516,1 +3558,1 @@\n-instruct vmaskcast_extend(pRegGov dst, pReg src) %{\n+instruct vmaskcast_extend_sve(pRegGov dst, pReg src) %{\n@@ -3520,1 +3562,1 @@\n-  format %{ \"vmaskcast_extend $dst, $src\" %}\n+  format %{ \"vmaskcast_extend_sve $dst, $src\" %}\n@@ -3533,1 +3575,1 @@\n-instruct vmaskcast_narrow(pRegGov dst, pReg src) %{\n+instruct vmaskcast_narrow_sve(pRegGov dst, pReg src) %{\n@@ -3537,1 +3579,1 @@\n-  format %{ \"vmaskcast_narrow $dst, $src\" %}\n+  format %{ \"vmaskcast_narrow_sve $dst, $src\" %}\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector_ad.m4","additions":46,"deletions":4,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -4618,0 +4618,53 @@\n+void C2_MacroAssembler::vector_mask_cast(XMMRegister dst, XMMRegister src,\n+                                         BasicType dst_bt, BasicType src_bt, int vlen) {\n+  int vlen_enc = vector_length_encoding(MAX2(type2aelembytes(src_bt), type2aelembytes(dst_bt)) * vlen);\n+  int dst_bt_size = type2aelembytes(dst_bt);\n+  int src_bt_size = type2aelembytes(src_bt);\n+  if (dst_bt_size > src_bt_size) {\n+    switch (dst_bt_size \/ src_bt_size) {\n+      case 2: vpmovsxbw(dst, src, vlen_enc); break;\n+      case 4: vpmovsxbd(dst, src, vlen_enc); break;\n+      case 8: vpmovsxbq(dst, src, vlen_enc); break;\n+      default: ShouldNotReachHere();\n+    }\n+  } else {\n+    assert(dst_bt_size < src_bt_size, \"\");\n+    switch (src_bt_size \/ dst_bt_size) {\n+      case 2: {\n+        if (vlen_enc == AVX_128bit) {\n+          vpacksswb(dst, src, src, vlen_enc);\n+        } else {\n+          vpacksswb(dst, src, src, vlen_enc);\n+          vpermq(dst, dst, 0x08, vlen_enc);\n+        }\n+        break;\n+      }\n+      case 4: {\n+        if (vlen_enc == AVX_128bit) {\n+          vpackssdw(dst, src, src, vlen_enc);\n+          vpacksswb(dst, dst, dst, vlen_enc);\n+        } else {\n+          vpackssdw(dst, src, src, vlen_enc);\n+          vpermq(dst, dst, 0x08, vlen_enc);\n+          vpacksswb(dst, dst, dst, AVX_128bit);\n+        }\n+        break;\n+      }\n+      case 8: {\n+        if (vlen_enc == AVX_128bit) {\n+          vpshufd(dst, src, 0x08, vlen_enc);\n+          vpackssdw(dst, dst, dst, vlen_enc);\n+          vpacksswb(dst, dst, dst, vlen_enc);\n+        } else {\n+          vpshufd(dst, src, 0x08, vlen_enc);\n+          vpermq(dst, dst, 0x08, vlen_enc);\n+          vpackssdw(dst, dst, dst, AVX_128bit);\n+          vpacksswb(dst, dst, dst, AVX_128bit);\n+        }\n+        break;\n+      }\n+      default: ShouldNotReachHere();\n+    }\n+  }\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":53,"deletions":0,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -342,0 +342,2 @@\n+  void vector_mask_cast(XMMRegister dst, XMMRegister src, BasicType dst_bt, BasicType src_bt, int vlen);\n+\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1481,0 +1481,1 @@\n+    case Op_VectorMaskCast:\n@@ -1852,0 +1853,1 @@\n+    case Op_VectorMaskCast:\n@@ -8388,1 +8390,0 @@\n-  predicate(Matcher::vector_length(n) == Matcher::vector_length(n->in(1)));\n@@ -8399,2 +8400,1 @@\n-  predicate((Matcher::vector_length(n) == Matcher::vector_length(n->in(1))) &&\n-            (Matcher::vector_length_in_bytes(n) == Matcher::vector_length_in_bytes(n->in(1))));\n+  predicate(Matcher::vector_length_in_bytes(n) == Matcher::vector_length_in_bytes(n->in(1)));\n@@ -8410,0 +8410,13 @@\n+instruct vmaskcast_avx(vec dst, vec src) %{\n+  predicate(Matcher::vector_length_in_bytes(n) != Matcher::vector_length_in_bytes(n->in(1)));\n+  match(Set dst (VectorMaskCast src));\n+  format %{ \"vector_mask_cast $dst, $src\" %}\n+  ins_encode %{\n+    int vlen = Matcher::vector_length(this);\n+    BasicType src_bt = Matcher::vector_element_basic_type(this, $src);\n+    BasicType dst_bt = Matcher::vector_element_basic_type(this);\n+    __ vector_mask_cast($dst$$XMMRegister, $src$$XMMRegister, dst_bt, src_bt, vlen);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":16,"deletions":3,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2491,9 +2491,2 @@\n-    BasicType new_elem_bt_to = elem_bt_to;\n-    BasicType new_elem_bt_from = elem_bt_from;\n-    if (is_mask && is_floating_point_type(elem_bt_from)) {\n-      new_elem_bt_from = elem_bt_from == T_FLOAT ? T_INT : T_LONG;\n-    }\n-    if (is_mask && is_floating_point_type(elem_bt_to)) {\n-      new_elem_bt_to = elem_bt_to == T_FLOAT ? T_INT : T_LONG;\n-    }\n-    int cast_vopc = VectorCastNode::opcode(new_elem_bt_from, !is_ucast);\n+    assert(!is_mask || num_elem_from == num_elem_to, \"vector mask cast needs the same elem num\");\n+    int cast_vopc = VectorCastNode::opcode(elem_bt_from, !is_ucast);\n@@ -2501,5 +2494,3 @@\n-    \/\/ Make sure that vector cast is implemented to particular type\/size combination.\n-    bool no_vec_cast_check = is_mask &&\n-                             ((src_type->isa_vectmask() && dst_type->isa_vectmask()) ||\n-                              type2aelembytes(elem_bt_from) == type2aelembytes(elem_bt_to));\n-    if (!no_vec_cast_check && !arch_supports_vector(cast_vopc, num_elem_to, new_elem_bt_to, VecMaskNotUsed)) {\n+    \/\/ Make sure that vector cast is implemented to particular type\/size combination if it is\n+    \/\/ not a mask casting.\n+    if (!is_mask && !arch_supports_vector(cast_vopc, num_elem_to, elem_bt_to, VecMaskNotUsed)) {\n@@ -2508,1 +2499,1 @@\n-                      cast_vopc, num_elem_to, type2name(new_elem_bt_to), is_mask);\n+                      cast_vopc, num_elem_to, type2name(elem_bt_to), is_mask);\n@@ -2555,5 +2546,7 @@\n-        if ((dst_type->isa_vectmask() && src_type->isa_vectmask()) ||\n-            (type2aelembytes(elem_bt_from) == type2aelembytes(elem_bt_to))) {\n-          op = gvn().transform(new VectorMaskCastNode(op, dst_type));\n-        } else {\n-          op = VectorMaskCastNode::makeCastNode(&gvn(), op, dst_type);\n+        \/\/ Make sure that cast for vector mask is implemented to particular type\/size combination.\n+        if (!arch_supports_vector(Op_VectorMaskCast, num_elem_to, elem_bt_to, VecMaskNotUsed)) {\n+          if (C->print_intrinsics()) {\n+            tty->print_cr(\"  ** not supported: arity=1 op=maskcast vlen2=%d etype2=%s ismask=%d\",\n+                          num_elem_to, type2name(elem_bt_to), is_mask);\n+          }\n+          return false;\n@@ -2561,0 +2554,1 @@\n+        op = gvn().transform(new VectorMaskCastNode(op, dst_type));\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":14,"deletions":20,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -1622,0 +1622,1 @@\n+          \/\/ VectorUnbox (VectorBox vmask) ==> VectorMaskCast vmask\n@@ -1623,10 +1624,1 @@\n-          if (in_vt->length_in_bytes() == out_vt->length_in_bytes() &&\n-              Matcher::match_rule_supported_vector(Op_VectorMaskCast, out_vt->length(), out_vt->element_basic_type())) {\n-            \/\/ Apply \"VectorUnbox (VectorBox vmask) ==> VectorMaskCast (vmask)\"\n-            \/\/ directly. This could avoid the transformation ordering issue from\n-            \/\/ \"VectorStoreMask (VectorLoadMask vmask) => vmask\".\n-            return new VectorMaskCastNode(value, vmask_type);\n-          }\n-          \/\/ VectorUnbox (VectorBox vmask) ==> VectorLoadMask (VectorStoreMask vmask)\n-          value = phase->transform(VectorStoreMaskNode::make(*phase, value, in_vt->element_basic_type(), in_vt->length()));\n-          return new VectorLoadMaskNode(value, vmask_type);\n+          return new VectorMaskCastNode(value, vmask_type);\n@@ -1723,42 +1715,0 @@\n-Node* VectorMaskCastNode::makeCastNode(PhaseGVN* phase, Node* src, const TypeVect* dst_type) {\n-  const TypeVect* src_type = src->bottom_type()->is_vect();\n-  assert(src_type->length() == dst_type->length(), \"\");\n-\n-  int num_elem = src_type->length();\n-  BasicType elem_bt_from = src_type->element_basic_type();\n-  BasicType elem_bt_to = dst_type->element_basic_type();\n-\n-  if (dst_type->isa_vectmask() == NULL && src_type->isa_vectmask() == NULL &&\n-      type2aelembytes(elem_bt_from) != type2aelembytes(elem_bt_to)) {\n-\n-    Node* op = src;\n-    BasicType new_elem_bt_from = elem_bt_from;\n-    BasicType new_elem_bt_to = elem_bt_to;\n-    if (is_floating_point_type(elem_bt_from)) {\n-      new_elem_bt_from =  elem_bt_from == T_FLOAT ? T_INT : T_LONG;\n-    }\n-    if (is_floating_point_type(elem_bt_to)) {\n-      new_elem_bt_to = elem_bt_to == T_FLOAT ? T_INT : T_LONG;\n-    }\n-\n-    \/\/ Special handling for casting operation involving floating point types.\n-    \/\/ Case A) F -> X :=  F -> VectorMaskCast (F->I\/L [NOP]) -> VectorCast[I\/L]2X\n-    \/\/ Case B) X -> F :=  X -> VectorCastX2[I\/L] -> VectorMaskCast ([I\/L]->F [NOP])\n-    \/\/ Case C) F -> F :=  VectorMaskCast (F->I\/L [NOP]) -> VectorCast[I\/L]2[L\/I] -> VectotMaskCast (L\/I->F [NOP])\n-\n-    if (new_elem_bt_from != elem_bt_from) {\n-      const TypeVect* new_src_type = TypeVect::makemask(new_elem_bt_from, num_elem);\n-      op = phase->transform(new VectorMaskCastNode(op, new_src_type));\n-    }\n-\n-    op = phase->transform(VectorCastNode::make(VectorCastNode::opcode(new_elem_bt_from), op, new_elem_bt_to, num_elem));\n-\n-    if (new_elem_bt_to != elem_bt_to) {\n-      op = phase->transform(new VectorMaskCastNode(op, dst_type));\n-    }\n-    return op;\n-  } else {\n-    return new VectorMaskCastNode(src, dst_type);\n-  }\n-}\n-\n@@ -1785,1 +1735,1 @@\n-       return VectorMaskCastNode::makeCastNode(phase, src, dst_type);\n+       return new VectorMaskCastNode(src, dst_type);\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":3,"deletions":53,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -1508,1 +1508,0 @@\n-  static Node* makeCastNode(PhaseGVN* phase, Node* in1, const TypeVect * vt);\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}