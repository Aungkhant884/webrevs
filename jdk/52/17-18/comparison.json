{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2009, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2020, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/java.base\/share\/classes\/java\/net\/StandardProtocolFamily.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2020, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/java.base\/share\/classes\/java\/nio\/channels\/package-info.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/java.base\/share\/classes\/java\/nio\/channels\/spi\/SelectorProvider.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+    private static final String JAVA_IO_TMPDIR;\n@@ -59,0 +60,1 @@\n+        JAVA_IO_TMPDIR = getProperty(props, \"java.io.tmpdir\");\n@@ -143,0 +145,13 @@\n+    \/**\n+     * Return the {@code java.io.tmpdir} system property.\n+     *\n+     * <strong>{@link SecurityManager#checkPropertyAccess} is NOT checked\n+     * in this method. The caller of this method should take care to ensure\n+     * that the returned property is not made accessible to untrusted code.<\/strong>\n+     *\n+     * @return the {@code java.io.tmpdir} system property\n+     *\/\n+    public static String javaIOTmpdir() {\n+        return JAVA_IO_TMPDIR;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/StaticProperty.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/java.base\/share\/classes\/sun\/net\/ext\/ExtendedSocketOptions.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/java.base\/share\/classes\/sun\/net\/util\/SocketExceptions.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,194 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.nio.ch;\n-\n-import java.io.FileDescriptor;\n-import java.io.IOException;\n-import java.net.InetSocketAddress;\n-import java.net.ProtocolFamily;\n-import java.net.StandardProtocolFamily;\n-import java.net.ServerSocket;\n-import java.net.SocketAddress;\n-import java.net.SocketOption;\n-import java.net.StandardSocketOptions;\n-import java.nio.channels.SocketChannel;\n-import java.nio.channels.spi.SelectorProvider;\n-import java.util.Collections;\n-import java.util.HashSet;\n-import java.util.Set;\n-\n-import sun.net.NetHooks;\n-import sun.net.ext.ExtendedSocketOptions;\n-\n-\/**\n- * An implementation of ServerSocketChannels for AF_INET\/AF_INET6 sockets\n- *\/\n-\n-class InetServerSocketChannelImpl\n-    extends ServerSocketChannelImpl\n-{\n-    \/\/ the protocol family requested by the user, or Net.UNSPEC if not specified\n-    private final ProtocolFamily family;\n-\n-    \/\/ Our socket adaptor, if any\n-    private ServerSocket socket;\n-\n-    \/\/ set true when exclusive binding is on and SO_REUSEADDR is emulated\n-    private boolean isReuseAddress;\n-\n-    InetServerSocketChannelImpl(SelectorProvider sp) throws IOException {\n-        this(sp, Net.isIPv6Available()\n-                ? StandardProtocolFamily.INET6\n-                : StandardProtocolFamily.INET);\n-    }\n-\n-    InetServerSocketChannelImpl(SelectorProvider sp, ProtocolFamily family)\n-        throws IOException\n-    {\n-        super(sp, Net.serverSocket(family, true), false);\n-        this.family = family;\n-    }\n-\n-    InetServerSocketChannelImpl(SelectorProvider sp, FileDescriptor fd, boolean bound)\n-        throws IOException\n-    {\n-        super(sp, fd, bound);\n-        this.family =  Net.isIPv6Available()\n-                ? StandardProtocolFamily.INET6\n-                : StandardProtocolFamily.INET;\n-    }\n-\n-\n-    @Override\n-    InetSocketAddress implLocalAddress(FileDescriptor fd) throws IOException {\n-        return Net.localAddress(fd);\n-    }\n-\n-    @Override\n-    protected SocketAddress getRevealedLocalAddress(SocketAddress addr) {\n-        return Net.getRevealedLocalAddress((InetSocketAddress)addr);\n-    }\n-\n-    @Override\n-    protected String getRevealedLocalAddressAsString(SocketAddress addr) {\n-        return Net.getRevealedLocalAddressAsString((InetSocketAddress)addr);\n-    }\n-\n-    \/**\n-     * Returns the local address, or null if not bound\n-     *\/\n-    @Override\n-    InetSocketAddress localAddress() {\n-        return (InetSocketAddress)super.localAddress();\n-    }\n-\n-    @Override\n-    <T> void implSetOption(SocketOption<T> name, T value) throws IOException {\n-        if (name == StandardSocketOptions.SO_REUSEADDR && Net.useExclusiveBind()) {\n-            \/\/ SO_REUSEADDR emulated when using exclusive bind\n-            isReuseAddress = (Boolean) value;\n-        } else {\n-            Net.setSocketOption(getFD(), Net.UNSPEC, name, value);\n-        }\n-    }\n-\n-    @Override\n-    @SuppressWarnings(\"unchecked\")\n-    <T> T implGetOption(SocketOption<T> name) throws IOException {\n-        if (name == StandardSocketOptions.SO_REUSEADDR && Net.useExclusiveBind()) {\n-            \/\/ SO_REUSEADDR emulated when using exclusive bind\n-            return (T) Boolean.valueOf(isReuseAddress);\n-        }\n-        return (T) Net.getSocketOption(getFD(), Net.UNSPEC, name);\n-    }\n-\n-    private static class DefaultOptionsHolder {\n-        static final Set<SocketOption<?>> defaultOptions = defaultOptions();\n-\n-        private static Set<SocketOption<?>> defaultOptions() {\n-            HashSet<SocketOption<?>> set = new HashSet<>();\n-            set.add(StandardSocketOptions.SO_RCVBUF);\n-            set.add(StandardSocketOptions.SO_REUSEADDR);\n-            if (Net.isReusePortAvailable()) {\n-                set.add(StandardSocketOptions.SO_REUSEPORT);\n-            }\n-            set.addAll(ExtendedSocketOptions.serverSocketOptions());\n-            return Collections.unmodifiableSet(set);\n-        }\n-    }\n-\n-    @Override\n-    public final Set<SocketOption<?>> supportedOptions() {\n-        return DefaultOptionsHolder.defaultOptions;\n-    }\n-\n-    @Override\n-    SocketAddress implBind(SocketAddress local, int backlog) throws IOException {\n-        InetSocketAddress isa;\n-        if (local == null) {\n-            isa = new InetSocketAddress(Net.anyLocalAddress(family), 0);\n-        } else {\n-            isa = Net.checkAddress(local, family);\n-        }\n-        SecurityManager sm = System.getSecurityManager();\n-        if (sm != null)\n-            sm.checkListen(isa.getPort());\n-        NetHooks.beforeTcpBind(getFD(), isa.getAddress(), isa.getPort());\n-        Net.bind(family, getFD(), isa.getAddress(), isa.getPort());\n-        Net.listen(getFD(), backlog < 1 ? 50 : backlog);\n-        return Net.localAddress(getFD());\n-    }\n-\n-    @Override\n-    ServerSocket implSocket() {\n-        if (socket == null)\n-            socket = ServerSocketAdaptor.create(this);\n-        return socket;\n-    }\n-\n-    @Override\n-    protected int implAccept(FileDescriptor fd, FileDescriptor newfd, SocketAddress[] addrs)\n-        throws IOException\n-    {\n-        InetSocketAddress[] a = new InetSocketAddress[1];\n-        int n = Net.accept(fd, newfd, a);\n-        addrs[0] = a[0];\n-        return n;\n-    }\n-\n-    @Override\n-    protected SocketChannel implFinishAccept(FileDescriptor newfd, SocketAddress sa)\n-        throws IOException\n-    {\n-        InetSocketAddress isa = (InetSocketAddress)sa;\n-        \/\/ check permitted to accept connections from the remote address\n-        SecurityManager sm = System.getSecurityManager();\n-        if (sm != null) {\n-            sm.checkAccept(isa.getAddress().getHostAddress(), isa.getPort());\n-        }\n-        return new InetSocketChannelImpl(provider(), family, newfd, isa);\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/InetServerSocketChannelImpl.java","additions":0,"deletions":194,"binary":false,"changes":194,"status":"deleted"},{"patch":"@@ -1,272 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.nio.ch;\n-\n-import java.io.FileDescriptor;\n-import java.io.IOException;\n-import java.net.InetAddress;\n-import java.net.Inet4Address;\n-import java.net.InetSocketAddress;\n-import java.net.ProtocolFamily;\n-import java.net.Socket;\n-import java.net.SocketAddress;\n-import java.net.SocketOption;\n-import java.net.StandardProtocolFamily;\n-import java.net.StandardSocketOptions;\n-import java.nio.ByteBuffer;\n-import java.nio.channels.spi.SelectorProvider;\n-import java.util.Collections;\n-import java.util.HashSet;\n-import java.util.Set;\n-import sun.net.NetHooks;\n-import sun.net.ext.ExtendedSocketOptions;\n-\n-\/**\n- * An implementation of SocketChannels for AF_INET\/AF_INET6 sockets\n- *\/\n-\n-class InetSocketChannelImpl extends SocketChannelImpl\n-{\n-    \/\/ the protocol family of the socket\n-    private final ProtocolFamily family;\n-\n-    \/\/ Socket adaptor, created on demand\n-    private Socket socket;\n-\n-    \/\/ set true when exclusive binding is on and SO_REUSEADDR is emulated\n-    private boolean isReuseAddress;\n-\n-    \/\/ Constructor for normal connecting sockets\n-    \/\/\n-    InetSocketChannelImpl(SelectorProvider sp) throws IOException {\n-        this(sp, Net.isIPv6Available()\n-                ? StandardProtocolFamily.INET6\n-                : StandardProtocolFamily.INET);\n-    }\n-\n-    InetSocketChannelImpl(SelectorProvider sp, ProtocolFamily family) throws IOException {\n-        super(sp, Net.socket(family, true), false);\n-        this.family = family;\n-    }\n-\n-    InetSocketChannelImpl(SelectorProvider sp, FileDescriptor fd, boolean bound)\n-        throws IOException\n-    {\n-        super(sp, fd, bound);\n-        this.family = Net.isIPv6Available()\n-                ? StandardProtocolFamily.INET6\n-                : StandardProtocolFamily.INET;\n-    }\n-\n-    @Override\n-    SocketAddress implLocalAddress(FileDescriptor fd) throws IOException {\n-        return Net.localAddress(fd);\n-    }\n-\n-    \/\/ Constructor for sockets obtained from server sockets\n-    \/\/\n-    InetSocketChannelImpl(SelectorProvider sp,\n-                          ProtocolFamily family,\n-                          FileDescriptor fd,\n-                          InetSocketAddress isa)\n-        throws IOException\n-    {\n-        super(sp, fd, isa);\n-        this.family = family;\n-    }\n-\n-\n-    @Override\n-    SocketAddress getRevealedLocalAddress(SocketAddress address) {\n-        return Net.getRevealedLocalAddress((InetSocketAddress)address);\n-    }\n-\n-    @Override\n-    <T> void implSetOption(SocketOption<T> name, T value) throws IOException {\n-        FileDescriptor fd = getFD();\n-\n-        if (name == StandardSocketOptions.IP_TOS) {\n-            ProtocolFamily family = Net.isIPv6Available() ?\n-                StandardProtocolFamily.INET6 : StandardProtocolFamily.INET;\n-            Net.setSocketOption(fd, family, name, value);\n-        } else if (name == StandardSocketOptions.SO_REUSEADDR && Net.useExclusiveBind()) {\n-            \/\/ SO_REUSEADDR emulated when using exclusive bind\n-            isReuseAddress = (Boolean)value;\n-        } else {\n-            Net.setSocketOption(fd, name, value);\n-        }\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    @Override\n-    <T> T implGetOption(SocketOption<T> name) throws IOException {\n-        FileDescriptor fd = getFD();\n-\n-        if (name == StandardSocketOptions.SO_REUSEADDR && Net.useExclusiveBind()) {\n-            \/\/ SO_REUSEADDR emulated when using exclusive bind\n-            return (T)Boolean.valueOf(isReuseAddress);\n-        }\n-\n-        \/\/ special handling for IP_TOS\n-        if (name == StandardSocketOptions.IP_TOS) {\n-            ProtocolFamily family = Net.isIPv6Available() ?\n-                StandardProtocolFamily.INET6 : StandardProtocolFamily.INET;\n-            return (T) Net.getSocketOption(fd, family, name);\n-        }\n-        return (T) Net.getSocketOption(fd, name);\n-    }\n-\n-    private static class DefaultOptionsHolder {\n-        static final Set<SocketOption<?>> defaultOptions = defaultOptions();\n-\n-        private static Set<SocketOption<?>> defaultOptions() {\n-            HashSet<SocketOption<?>> set = new HashSet<>();\n-            set.add(StandardSocketOptions.SO_SNDBUF);\n-            set.add(StandardSocketOptions.SO_RCVBUF);\n-            set.add(StandardSocketOptions.SO_KEEPALIVE);\n-            set.add(StandardSocketOptions.SO_REUSEADDR);\n-            if (Net.isReusePortAvailable()) {\n-                set.add(StandardSocketOptions.SO_REUSEPORT);\n-            }\n-            set.add(StandardSocketOptions.SO_LINGER);\n-            set.add(StandardSocketOptions.TCP_NODELAY);\n-            \/\/ additional options required by socket adaptor\n-            set.add(StandardSocketOptions.IP_TOS);\n-            set.add(ExtendedSocketOption.SO_OOBINLINE);\n-            set.addAll(ExtendedSocketOptions.clientSocketOptions());\n-            return Collections.unmodifiableSet(set);\n-        }\n-    }\n-\n-    @Override\n-    public final Set<SocketOption<?>> supportedOptions() {\n-        return DefaultOptionsHolder.defaultOptions;\n-    }\n-\n-    \/**\n-     * Read\/write need to be overridden for JFR\n-     *\/\n-    @Override\n-    public int read(ByteBuffer buf) throws IOException {\n-        return super.read(buf);\n-    }\n-\n-    @Override\n-    public long read(ByteBuffer[] dsts, int offset, int length)\n-        throws IOException\n-    {\n-        return super.read(dsts, offset, length);\n-    }\n-\n-    @Override\n-    public int write(ByteBuffer buf) throws IOException {\n-        return super.write(buf);\n-    }\n-\n-    @Override\n-    public long write(ByteBuffer[] srcs, int offset, int length)\n-        throws IOException\n-    {\n-        return super.write(srcs, offset, length);\n-    }\n-\n-    \/**\n-     * Returns the local address, or null if not bound\n-     *\/\n-    @Override\n-    InetSocketAddress localAddress() {\n-        return (InetSocketAddress)super.localAddress();\n-    }\n-\n-    \/**\n-     * Returns the remote address, or null if not connected\n-     *\/\n-    @Override\n-    InetSocketAddress remoteAddress() {\n-        return (InetSocketAddress)super.remoteAddress();\n-    }\n-\n-    @Override\n-    SocketAddress implBind(SocketAddress local) throws IOException {\n-        InetSocketAddress isa;\n-        if (local == null) {\n-            isa = new InetSocketAddress(Net.anyLocalAddress(family), 0);\n-        } else {\n-            isa = Net.checkAddress(local, family);\n-        }\n-        SecurityManager sm = System.getSecurityManager();\n-        if (sm != null) {\n-            sm.checkListen(isa.getPort());\n-        }\n-        FileDescriptor fd = getFD();\n-        NetHooks.beforeTcpBind(fd, isa.getAddress(), isa.getPort());\n-        Net.bind(family, fd, isa.getAddress(), isa.getPort());\n-        return Net.localAddress(fd);\n-    }\n-\n-    \/**\n-     * Checks the remote address to which this channel is to be connected.\n-     *\/\n-    @Override\n-    protected InetSocketAddress checkRemote(SocketAddress sa) throws IOException {\n-        InetSocketAddress isa = Net.checkAddress(sa, family);\n-        SecurityManager sm = System.getSecurityManager();\n-        if (sm != null) {\n-            sm.checkConnect(isa.getAddress().getHostAddress(), isa.getPort());\n-        }\n-        InetAddress address = isa.getAddress();\n-        if (address.isAnyLocalAddress()) {\n-            int port = isa.getPort();\n-            if (address instanceof Inet4Address) {\n-                return new InetSocketAddress(Net.inet4LoopbackAddress(), port);\n-            } else {\n-                assert family == StandardProtocolFamily.INET6;\n-                return new InetSocketAddress(Net.inet6LoopbackAddress(), port);\n-            }\n-        } else {\n-            return isa;\n-        }\n-    }\n-\n-    @Override\n-    Socket implSocket() {\n-        if (socket == null)\n-            socket = SocketAdaptor.create(this);\n-        return socket;\n-    }\n-\n-    @Override\n-    protected int implConnect(FileDescriptor fd, SocketAddress sa) throws IOException {\n-        InetSocketAddress isa = (InetSocketAddress)sa;\n-        return Net.connect(family, fd, isa.getAddress(), isa.getPort());\n-    }\n-\n-    @Override\n-    protected String getRevealedLocalAddressAsString(SocketAddress sa) {\n-        InetSocketAddress isa = (InetSocketAddress)sa;\n-        return Net.getRevealedLocalAddressAsString(isa);\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/InetSocketChannelImpl.java","additions":0,"deletions":272,"binary":false,"changes":272,"status":"deleted"},{"patch":"@@ -1,63 +0,0 @@\n-\/*\n- * Copyright (c) 2010, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.nio.ch;\n-\n-import java.nio.channels.SocketChannel;\n-import java.nio.channels.ServerSocketChannel;\n-import java.nio.channels.spi.SelectorProvider;\n-import java.io.FileDescriptor;\n-import java.io.IOException;\n-\n-\/**\n- * Provides access to implementation private constructors and methods.\n- *\/\n-\n-public final class Secrets {\n-    private Secrets() { }\n-\n-    private static SelectorProvider provider() {\n-        SelectorProvider p = SelectorProvider.provider();\n-        if (!(p instanceof SelectorProviderImpl))\n-            throw new UnsupportedOperationException();\n-        return p;\n-    }\n-\n-    public static SocketChannel newSocketChannel(FileDescriptor fd) {\n-        try {\n-            return new InetSocketChannelImpl(provider(), fd, false);\n-        } catch (IOException ioe) {\n-            throw new AssertionError(ioe);\n-        }\n-    }\n-\n-    public static ServerSocketChannel newServerSocketChannel(FileDescriptor fd) {\n-        try {\n-            return new InetServerSocketChannelImpl(provider(), fd, false);\n-        } catch (IOException ioe) {\n-            throw new AssertionError(ioe);\n-        }\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/Secrets.java","additions":0,"deletions":63,"binary":false,"changes":63,"status":"deleted"},{"patch":"@@ -70,1 +70,1 @@\n-        return new InetServerSocketChannelImpl(this);\n+        return new ServerSocketChannelImpl(this);\n@@ -75,1 +75,1 @@\n-        return new InetSocketChannelImpl(this);\n+        return new SocketChannelImpl(this);\n@@ -85,1 +85,1 @@\n-            return new InetSocketChannelImpl(this, family);\n+            return new SocketChannelImpl(this, family);\n@@ -88,1 +88,1 @@\n-            return new UnixDomainSocketChannelImpl(this, UnixDomainSockets.socket(), false);\n+            return new SocketChannelImpl(this, family);\n@@ -100,1 +100,1 @@\n-            return new InetServerSocketChannelImpl(this, family);\n+            return new ServerSocketChannelImpl(this, family);\n@@ -103,1 +103,1 @@\n-            return new UnixDomainServerSocketChannelImpl(this);\n+            return new ServerSocketChannelImpl(this, family);\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/SelectorProviderImpl.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,1 +59,1 @@\n-    private final InetServerSocketChannelImpl ssc;\n+    private final ServerSocketChannelImpl ssc;\n@@ -64,1 +64,1 @@\n-    static ServerSocket create(InetServerSocketChannelImpl ssc) {\n+    static ServerSocket create(ServerSocketChannelImpl ssc) {\n@@ -73,1 +73,1 @@\n-    private ServerSocketAdaptor(InetServerSocketChannelImpl ssc) {\n+    private ServerSocketAdaptor(ServerSocketChannelImpl ssc) {\n@@ -96,1 +96,1 @@\n-        InetSocketAddress local = ssc.localAddress();\n+        InetSocketAddress local = (InetSocketAddress)ssc.localAddress();\n@@ -106,1 +106,1 @@\n-        InetSocketAddress local = ssc.localAddress();\n+        InetSocketAddress local = (InetSocketAddress)ssc.localAddress();\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/ServerSocketAdaptor.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,3 @@\n+import java.net.BindException;\n+import java.net.InetSocketAddress;\n+import java.net.ProtocolFamily;\n@@ -34,0 +37,3 @@\n+import java.net.StandardProtocolFamily;\n+import java.net.StandardSocketOptions;\n+import java.net.UnixDomainSocketAddress;\n@@ -43,0 +49,6 @@\n+import java.nio.file.InvalidPathException;\n+import java.nio.file.Path;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Set;\n@@ -46,0 +58,3 @@\n+import sun.net.NetHooks;\n+import sun.net.ext.ExtendedSocketOptions;\n+\n@@ -47,1 +62,1 @@\n- * Base implementation of ServerSocketChannels\n+ * An implementation of ServerSocketChannels\n@@ -50,1 +65,1 @@\n-abstract class ServerSocketChannelImpl\n+class ServerSocketChannelImpl\n@@ -57,0 +72,3 @@\n+    \/\/ The protocol family of the socket\n+    private final ProtocolFamily family;\n+\n@@ -82,0 +100,6 @@\n+    \/\/ set true when exclusive binding is on and SO_REUSEADDR is emulated\n+    private boolean isReuseAddress;\n+\n+    \/\/ Our socket adaptor, if any\n+    private ServerSocket socket;\n+\n@@ -84,1 +108,32 @@\n-    ServerSocketChannelImpl(SelectorProvider sp, FileDescriptor fd, boolean bound)\n+    ServerSocketChannelImpl(SelectorProvider sp) throws IOException {\n+        this(sp, Net.isIPv6Available()\n+                ? StandardProtocolFamily.INET6\n+                : StandardProtocolFamily.INET);\n+    }\n+\n+    ServerSocketChannelImpl(SelectorProvider sp, ProtocolFamily family)\n+        throws IOException\n+    {\n+        super(sp);\n+        Objects.requireNonNull(family, \"'family' is null\");\n+\n+        if ((family != StandardProtocolFamily.INET) &&\n+                (family != StandardProtocolFamily.INET6) &&\n+                (family != StandardProtocolFamily.UNIX)) {\n+            throw new UnsupportedOperationException(\"Protocol family not supported\");\n+        }\n+        if (family == StandardProtocolFamily.UNIX) {\n+            this.fd = UnixDomainSockets.socket();\n+        } else {\n+            if (family == StandardProtocolFamily.INET6 && !Net.isIPv6Available()) {\n+                throw new UnsupportedOperationException(\"IPv6 not available\");\n+            }\n+            this.fd = Net.serverSocket(family, true);\n+        }\n+\n+        this.family = family;\n+        this.fdVal = IOUtil.fdVal(fd);\n+    }\n+\n+    ServerSocketChannelImpl(SelectorProvider sp, ProtocolFamily family,\n+                            FileDescriptor fd, boolean bound)\n@@ -88,1 +143,8 @@\n-        this.fd =  fd;\n+        this.fd = fd;\n+        if (family == StandardProtocolFamily.UNIX) {\n+            this.family = family;\n+        } else {\n+            this.family = Net.isIPv6Available()\n+                ? StandardProtocolFamily.INET6\n+                : StandardProtocolFamily.INET;\n+        }\n@@ -93,1 +155,5 @@\n-                localAddress = implLocalAddress(fd);\n+                if (family == StandardProtocolFamily.UNIX) {\n+                    localAddress = UnixDomainSockets.localAddress(fd);\n+                } else {\n+                    localAddress = Net.localAddress(fd);\n+                }\n@@ -107,1 +173,8 @@\n-            return implSocket();\n+            if (family == StandardProtocolFamily.UNIX) {\n+                throw new UnsupportedOperationException(\"protocol family not supported\");\n+            } else {\n+                if (socket == null) {\n+                    socket = ServerSocketAdaptor.create(this);\n+                }\n+            }\n+            return socket;\n@@ -111,5 +184,0 @@\n-    \/\/ Override when supported\n-    ServerSocket implSocket() {\n-        throw new UnsupportedOperationException(\"socket not supported\");\n-    }\n-\n@@ -120,18 +188,9 @@\n-            return (localAddress == null)\n-                ? null\n-                : getRevealedLocalAddress(localAddress);\n-        }\n-    }\n-\n-    abstract SocketAddress implLocalAddress(FileDescriptor fd) throws IOException;\n-\n-    abstract SocketAddress getRevealedLocalAddress(SocketAddress addr);\n-\n-    abstract String getRevealedLocalAddressAsString(SocketAddress addr);\n-\n-    \/**\n-     * Returns the local address, or null if not bound\n-     *\/\n-    SocketAddress localAddress() {\n-        synchronized (stateLock) {\n-            return localAddress;\n+            if (localAddress == null) {\n+                return null;\n+            }\n+            if (family == StandardProtocolFamily.UNIX) {\n+                return UnixDomainSockets.getRevealedLocalAddress(\n+                                (UnixDomainSocketAddress)localAddress);\n+            } else {\n+                return Net.getRevealedLocalAddress((InetSocketAddress)localAddress);\n+            }\n@@ -153,1 +212,10 @@\n-            implSetOption(name, value);\n+            if (family == StandardProtocolFamily.UNIX) {\n+                Net.setSocketOption(fd, Net.UNSPEC, name, value);\n+            } else {\n+                if (name == StandardSocketOptions.SO_REUSEADDR && Net.useExclusiveBind()) {\n+                    \/\/ SO_REUSEADDR emulated when using exclusive bind\n+                    isReuseAddress = (Boolean) value;\n+                } else {\n+                    Net.setSocketOption(fd, Net.UNSPEC, name, value);\n+                }\n+            }\n@@ -158,2 +226,0 @@\n-    abstract <T> void implSetOption(SocketOption<T> name, T value) throws IOException;\n-\n@@ -171,1 +237,31 @@\n-            return implGetOption(name);\n+            if (family == StandardProtocolFamily.UNIX) {\n+                return (T) Net.getSocketOption(fd, Net.UNSPEC, name);\n+            } else {\n+                if (name == StandardSocketOptions.SO_REUSEADDR && Net.useExclusiveBind()) {\n+                    \/\/ SO_REUSEADDR emulated when using exclusive bind\n+                    return (T) Boolean.valueOf(isReuseAddress);\n+                }\n+                return (T) Net.getSocketOption(fd, Net.UNSPEC, name);\n+            }\n+        }\n+    }\n+\n+    private static class DefaultOptionsHolder {\n+        static final Set<SocketOption<?>> defaultInetOptions = defaultInetOptions();\n+        static final Set<SocketOption<?>> defaultUnixOptions = defaultUnixOptions();\n+\n+        private static Set<SocketOption<?>> defaultInetOptions() {\n+            HashSet<SocketOption<?>> set = new HashSet<>();\n+            set.add(StandardSocketOptions.SO_RCVBUF);\n+            set.add(StandardSocketOptions.SO_REUSEADDR);\n+            if (Net.isReusePortAvailable()) {\n+                set.add(StandardSocketOptions.SO_REUSEPORT);\n+            }\n+            set.addAll(ExtendedSocketOptions.serverSocketOptions());\n+            return Collections.unmodifiableSet(set);\n+        }\n+\n+        private static Set<SocketOption<?>> defaultUnixOptions() {\n+            HashSet<SocketOption<?>> set = new HashSet<>();\n+            set.add(StandardSocketOptions.SO_RCVBUF);\n+            return Collections.unmodifiableSet(set);\n@@ -175,1 +271,8 @@\n-    abstract <T> T implGetOption(SocketOption<T> name) throws IOException;\n+    @Override\n+    public final Set<SocketOption<?>> supportedOptions() {\n+        if (family == StandardProtocolFamily.UNIX) {\n+            return DefaultOptionsHolder.defaultUnixOptions;\n+        } else {\n+            return DefaultOptionsHolder.defaultInetOptions;\n+        }\n+    }\n@@ -183,1 +286,5 @@\n-            localAddress = implBind(local, backlog);\n+            if (family == StandardProtocolFamily.UNIX) {\n+                localAddress = implBindUnix(local, backlog);\n+            } else {\n+                localAddress = implBindInet(local, backlog);\n+            }\n@@ -188,1 +295,43 @@\n-    abstract SocketAddress implBind(SocketAddress local, int backlog) throws IOException;\n+    private SocketAddress implBindUnix(SocketAddress local, int backlog) throws IOException {\n+        boolean found = false;\n+        UnixDomainSocketAddress usa = null;\n+\n+        UnixDomainSockets.checkPermission();\n+\n+        if (local != null) {\n+            usa = UnixDomainSockets.checkAddress(local);\n+            UnixDomainSockets.bind(fd, usa.getPath());\n+            found = true;\n+        } else {\n+            \/\/ Attempt up to 10 times to find an unused name in temp directory.\n+            \/\/ If local address supplied then bind called only once\n+            for (int i = 0; i < 10; i++) {\n+                usa = UnixDomainSockets.getTempName();\n+                try {\n+                    UnixDomainSockets.bind(fd, usa.getPath());\n+                    found = true;\n+                    break;\n+                } catch (BindException e) {}\n+            }\n+        }\n+        if (!found)\n+            throw new BindException(\"Could not bind to temporary name\");\n+        Net.listen(fd, backlog < 1 ? 50 : backlog);\n+        return UnixDomainSockets.localAddress(fd);\n+    }\n+\n+    private SocketAddress implBindInet(SocketAddress local, int backlog) throws IOException {\n+        InetSocketAddress isa;\n+        if (local == null) {\n+            isa = new InetSocketAddress(Net.anyLocalAddress(family), 0);\n+        } else {\n+            isa = Net.checkAddress(local, family);\n+        }\n+        SecurityManager sm = System.getSecurityManager();\n+        if (sm != null)\n+            sm.checkListen(isa.getPort());\n+        NetHooks.beforeTcpBind(fd, isa.getAddress(), isa.getPort());\n+        Net.bind(family, fd, isa.getAddress(), isa.getPort());\n+        Net.listen(fd, backlog < 1 ? 50 : backlog);\n+        return Net.localAddress(fd);\n+    }\n@@ -261,2 +410,9 @@\n-    protected abstract int implAccept(FileDescriptor fd, FileDescriptor newfd, SocketAddress[] sa)\n-        throws IOException;\n+    private int implAccept(FileDescriptor fd, FileDescriptor newfd, SocketAddress[] sa)\n+        throws IOException\n+    {\n+        if (family == StandardProtocolFamily.UNIX) {\n+            return implAcceptUnix(fd, newfd, sa);\n+        } else {\n+            return implAcceptInet(fd, newfd, sa);\n+        }\n+    }\n@@ -264,0 +420,20 @@\n+    private int implAcceptInet(FileDescriptor fd, FileDescriptor newfd, SocketAddress[] addrs)\n+        throws IOException\n+    {\n+        InetSocketAddress[] a = new InetSocketAddress[1];\n+        int n = Net.accept(fd, newfd, a);\n+        addrs[0] = a[0];\n+        return n;\n+    }\n+\n+    protected int implAcceptUnix(FileDescriptor fd, FileDescriptor newfd, SocketAddress[] addrs)\n+        throws IOException\n+    {\n+        UnixDomainSockets.checkPermission();\n+        String[] addrArray = new String[1];\n+        int n = UnixDomainSockets.accept(fd, newfd, addrArray);\n+        if (n > 0) {\n+            addrs[0] = UnixDomainSocketAddress.of(addrArray[0]);\n+        }\n+        return n;\n+    }\n@@ -322,1 +498,12 @@\n-            return implFinishAccept(newfd, sa);\n+            if (family == StandardProtocolFamily.UNIX) {\n+                UnixDomainSocketAddress usa = (UnixDomainSocketAddress)sa;\n+                return new SocketChannelImpl(provider(), StandardProtocolFamily.UNIX, newfd, usa);\n+            } else {\n+                InetSocketAddress isa = (InetSocketAddress)sa;\n+                \/\/ check permitted to accept connections from the remote address\n+                SecurityManager sm = System.getSecurityManager();\n+                if (sm != null) {\n+                    sm.checkAccept(isa.getAddress().getHostAddress(), isa.getPort());\n+                }\n+                return new SocketChannelImpl(provider(), family, newfd, isa);\n+            }\n@@ -329,3 +516,0 @@\n-    abstract SocketChannel implFinishAccept(FileDescriptor newfd, SocketAddress isa)\n-        throws IOException;\n-\n@@ -471,0 +655,9 @@\n+    \/**\n+     * Returns the local address, or null if not bound\n+     *\/\n+    SocketAddress localAddress() {\n+        synchronized (stateLock) {\n+            return localAddress;\n+        }\n+    }\n+\n@@ -538,1 +731,6 @@\n-                    sb.append(getRevealedLocalAddressAsString(addr));\n+                    if (family == StandardProtocolFamily.UNIX) {\n+                        sb.append(UnixDomainSockets.getRevealedLocalAddressAsString(\n+                                 (UnixDomainSocketAddress)addr));\n+                    } else {\n+                        sb.append(Net.getRevealedLocalAddressAsString((InetSocketAddress)addr));\n+                    }\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/ServerSocketChannelImpl.java","additions":242,"deletions":44,"binary":false,"changes":286,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,1 +56,1 @@\n-    private final InetSocketChannelImpl sc;\n+    private final SocketChannelImpl sc;\n@@ -61,1 +61,1 @@\n-    private SocketAdaptor(InetSocketChannelImpl sc) throws SocketException {\n+    private SocketAdaptor(SocketChannelImpl sc) throws SocketException {\n@@ -66,1 +66,1 @@\n-    static Socket create(InetSocketChannelImpl sc) {\n+    static Socket create(SocketChannelImpl sc) {\n@@ -109,1 +109,1 @@\n-        InetSocketAddress remote = sc.remoteAddress();\n+        InetSocketAddress remote = (InetSocketAddress)sc.remoteAddress();\n@@ -120,1 +120,1 @@\n-            InetSocketAddress local = sc.localAddress();\n+            InetSocketAddress local = (InetSocketAddress)sc.localAddress();\n@@ -130,1 +130,1 @@\n-        InetSocketAddress remote = sc.remoteAddress();\n+        InetSocketAddress remote = (InetSocketAddress)sc.remoteAddress();\n@@ -140,1 +140,1 @@\n-        InetSocketAddress local = sc.localAddress();\n+        InetSocketAddress local = (InetSocketAddress)sc.localAddress();\n@@ -155,1 +155,1 @@\n-        InetSocketAddress local = sc.localAddress();\n+        InetSocketAddress local = (InetSocketAddress)sc.localAddress();\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/SocketAdaptor.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -30,0 +30,2 @@\n+import java.net.InetAddress;\n+import java.net.Inet4Address;\n@@ -31,0 +33,1 @@\n+import java.net.ProtocolFamily;\n@@ -36,0 +39,1 @@\n+import java.net.StandardProtocolFamily;\n@@ -37,0 +41,1 @@\n+import java.net.UnixDomainSocketAddress;\n@@ -49,0 +54,4 @@\n+import java.nio.file.Path;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Set;\n@@ -54,0 +63,1 @@\n+import sun.net.ext.ExtendedSocketOptions;\n@@ -57,1 +67,1 @@\n- * Base implementation of SocketChannels\n+ * An implementation of SocketChannels\n@@ -60,1 +70,1 @@\n-abstract class SocketChannelImpl\n+class SocketChannelImpl\n@@ -67,0 +77,3 @@\n+    \/\/ The protocol family of the socket\n+    private final ProtocolFamily family;\n+\n@@ -90,0 +103,3 @@\n+    \/\/ set true when exclusive binding is on and SO_REUSEADDR is emulated\n+    private boolean isReuseAddress;\n+\n@@ -106,0 +122,3 @@\n+    \/\/ Socket adaptor, created on demand\n+    private Socket socket;\n+\n@@ -109,1 +128,1 @@\n-    \/\/\n+\n@@ -111,3 +130,3 @@\n-        super(sp);\n-        this.fd = Net.socket(true);\n-        this.fdVal = IOUtil.fdVal(fd);\n+        this(sp, Net.isIPv6Available()\n+                ? StandardProtocolFamily.INET6\n+                : StandardProtocolFamily.INET);\n@@ -116,3 +135,1 @@\n-    SocketChannelImpl(SelectorProvider sp, FileDescriptor fd, boolean bound)\n-        throws IOException\n-    {\n+    SocketChannelImpl(SelectorProvider sp, ProtocolFamily family) throws IOException {\n@@ -120,6 +137,5 @@\n-        this.fd = fd;\n-        this.fdVal = IOUtil.fdVal(fd);\n-        if (bound) {\n-            synchronized (stateLock) {\n-                this.localAddress = implLocalAddress(fd);\n-            }\n+        Objects.requireNonNull(family, \"'family' is null\");\n+        if ((family != StandardProtocolFamily.INET) &&\n+                (family != StandardProtocolFamily.UNIX) &&\n+                (family != StandardProtocolFamily.INET6)) {\n+            throw new UnsupportedOperationException(\"Protocol family not supported\");\n@@ -127,0 +143,9 @@\n+        if (family == StandardProtocolFamily.UNIX) {\n+            this.fd = UnixDomainSockets.socket();\n+        } else if (family == StandardProtocolFamily.INET6 && !Net.isIPv6Available()) {\n+            throw new UnsupportedOperationException(\"IPv6 not available\");\n+        } else {\n+            this.fd = Net.socket(family, true);\n+        }\n+        this.family = family;\n+        this.fdVal = IOUtil.fdVal(fd);\n@@ -131,1 +156,4 @@\n-    SocketChannelImpl(SelectorProvider sp, FileDescriptor fd, SocketAddress isa)\n+    SocketChannelImpl(SelectorProvider sp,\n+                      ProtocolFamily family,\n+                      FileDescriptor fd,\n+                      SocketAddress isa)\n@@ -135,0 +163,1 @@\n+        this.family = family;\n@@ -178,1 +207,7 @@\n-            return implSocket();\n+            if (family == StandardProtocolFamily.UNIX) {\n+                throw new UnsupportedOperationException(\"protocol family not supported\");\n+            }\n+            if (socket == null) {\n+                socket = SocketAdaptor.create(this);\n+            }\n+            return socket;\n@@ -182,5 +217,0 @@\n-    \/\/ Override when supported\n-    Socket implSocket() {\n-        throw new UnsupportedOperationException(\"socket not supported\");\n-    }\n-\n@@ -195,1 +225,7 @@\n-    abstract SocketAddress implLocalAddress(FileDescriptor fd) throws IOException;\n+    private SocketAddress implLocalAddress(FileDescriptor fd) throws IOException {\n+        if (family == StandardProtocolFamily.UNIX) {\n+            return UnixDomainSockets.localAddress(fd);\n+        } else {\n+            return Net.localAddress(fd);\n+        }\n+    }\n@@ -197,1 +233,9 @@\n-    abstract SocketAddress getRevealedLocalAddress(SocketAddress address);\n+    private SocketAddress getRevealedLocalAddress(SocketAddress sa) {\n+        if (family == StandardProtocolFamily.UNIX) {\n+            UnixDomainSocketAddress usa = (UnixDomainSocketAddress)sa;\n+            return UnixDomainSockets.getRevealedLocalAddress(usa);\n+        } else {\n+            InetSocketAddress isa = (InetSocketAddress)sa;\n+            return Net.getRevealedLocalAddress(isa);\n+        }\n+    }\n@@ -219,1 +263,14 @@\n-            implSetOption(name, value);\n+            if (family == StandardProtocolFamily.UNIX) {\n+                Net.setSocketOption(fd, name, value);\n+            } else {\n+                if (name == StandardSocketOptions.IP_TOS) {\n+                    ProtocolFamily family = Net.isIPv6Available() ?\n+                        StandardProtocolFamily.INET6 : StandardProtocolFamily.INET;\n+                    Net.setSocketOption(fd, family, name, value);\n+                } else if (name == StandardSocketOptions.SO_REUSEADDR && Net.useExclusiveBind()) {\n+                    \/\/ SO_REUSEADDR emulated when using exclusive bind\n+                    isReuseAddress = (Boolean)value;\n+                } else {\n+                    Net.setSocketOption(fd, name, value);\n+                }\n+            }\n@@ -224,2 +281,0 @@\n-    abstract <T> void implSetOption(SocketOption<T> name, T value) throws IOException;\n-\n@@ -237,1 +292,57 @@\n-            return implGetOption(name);\n+            if (family == StandardProtocolFamily.UNIX) {\n+                return (T) Net.getSocketOption(fd, name);\n+            } else {\n+                if (name == StandardSocketOptions.SO_REUSEADDR && Net.useExclusiveBind()) {\n+                    \/\/ SO_REUSEADDR emulated when using exclusive bind\n+                    return (T)Boolean.valueOf(isReuseAddress);\n+                }\n+\n+                \/\/ special handling for IP_TOS\n+                if (name == StandardSocketOptions.IP_TOS) {\n+                    ProtocolFamily family = Net.isIPv6Available() ?\n+                        StandardProtocolFamily.INET6 : StandardProtocolFamily.INET;\n+                    return (T) Net.getSocketOption(fd, family, name);\n+                }\n+                return (T) Net.getSocketOption(fd, name);\n+            }\n+        }\n+    }\n+\n+    private static class DefaultOptionsHolder {\n+        static final Set<SocketOption<?>> defaultInetOptions = defaultInetOptions();\n+        static final Set<SocketOption<?>> defaultUnixOptions = defaultUnixOptions();\n+\n+        private static Set<SocketOption<?>> defaultInetOptions() {\n+            HashSet<SocketOption<?>> set = new HashSet<>();\n+            set.add(StandardSocketOptions.SO_SNDBUF);\n+            set.add(StandardSocketOptions.SO_RCVBUF);\n+            set.add(StandardSocketOptions.SO_KEEPALIVE);\n+            set.add(StandardSocketOptions.SO_REUSEADDR);\n+            if (Net.isReusePortAvailable()) {\n+                set.add(StandardSocketOptions.SO_REUSEPORT);\n+            }\n+            set.add(StandardSocketOptions.SO_LINGER);\n+            set.add(StandardSocketOptions.TCP_NODELAY);\n+            \/\/ additional options required by socket adaptor\n+            set.add(StandardSocketOptions.IP_TOS);\n+            set.add(ExtendedSocketOption.SO_OOBINLINE);\n+            set.addAll(ExtendedSocketOptions.clientSocketOptions());\n+            return Collections.unmodifiableSet(set);\n+        }\n+\n+        private static Set<SocketOption<?>> defaultUnixOptions() {\n+            HashSet<SocketOption<?>> set = new HashSet<>();\n+            set.add(StandardSocketOptions.SO_SNDBUF);\n+            set.add(StandardSocketOptions.SO_RCVBUF);\n+            set.add(StandardSocketOptions.SO_LINGER);\n+            set.addAll(ExtendedSocketOptions.unixSocketOptions());\n+            return Collections.unmodifiableSet(set);\n+        }\n+    }\n+\n+    @Override\n+    public final Set<SocketOption<?>> supportedOptions() {\n+        if (family == StandardProtocolFamily.UNIX) {\n+            return DefaultOptionsHolder.defaultUnixOptions;\n+        } else {\n+            return DefaultOptionsHolder.defaultInetOptions;\n@@ -241,1 +352,0 @@\n-    abstract <T> T implGetOption(SocketOption<T> name) throws IOException;\n@@ -574,1 +684,5 @@\n-                    localAddress = implBind(local);\n+                    if (family == StandardProtocolFamily.UNIX) {\n+                        localAddress = implBindUnix(local);\n+                    } else {\n+                        localAddress = implBindInet(local);\n+                    }\n@@ -585,1 +699,30 @@\n-    abstract SocketAddress implBind(SocketAddress local) throws IOException;\n+    private SocketAddress implBindUnix(SocketAddress local) throws IOException {\n+        UnixDomainSockets.checkPermission();\n+        UnixDomainSocketAddress usa = UnixDomainSockets.checkAddress(local);\n+        Path path = usa == null ? null : usa.getPath();\n+        if (path != null) {\n+            \/\/ implicit bind for null address\n+            UnixDomainSockets.bind(fd, path);\n+        }\n+        if (usa == null || path.toString().equals(\"\")) {\n+            return UnixDomainSockets.UNNAMED;\n+        } else {\n+            return UnixDomainSockets.localAddress(fd);\n+        }\n+    }\n+\n+    private SocketAddress implBindInet(SocketAddress local) throws IOException {\n+        InetSocketAddress isa;\n+        if (local == null) {\n+            isa = new InetSocketAddress(Net.anyLocalAddress(family), 0);\n+        } else {\n+            isa = Net.checkAddress(local, family);\n+        }\n+        SecurityManager sm = System.getSecurityManager();\n+        if (sm != null) {\n+            sm.checkListen(isa.getPort());\n+        }\n+        NetHooks.beforeTcpBind(fd, isa.getAddress(), isa.getPort());\n+        Net.bind(family, fd, isa.getAddress(), isa.getPort());\n+        return Net.localAddress(fd);\n+    }\n@@ -661,1 +804,25 @@\n-    abstract SocketAddress checkRemote(SocketAddress sa) throws IOException;\n+    private SocketAddress checkRemote(SocketAddress sa) throws IOException {\n+        if (family == StandardProtocolFamily.UNIX) {\n+            Objects.requireNonNull(sa);\n+            UnixDomainSockets.checkPermission();\n+            UnixDomainSocketAddress usa = UnixDomainSockets.checkAddress(sa);\n+            return usa;\n+        }\n+        InetSocketAddress isa = Net.checkAddress(sa, family);\n+        SecurityManager sm = System.getSecurityManager();\n+        if (sm != null) {\n+            sm.checkConnect(isa.getAddress().getHostAddress(), isa.getPort());\n+        }\n+        InetAddress address = isa.getAddress();\n+        if (address.isAnyLocalAddress()) {\n+            int port = isa.getPort();\n+            if (address instanceof Inet4Address) {\n+                return new InetSocketAddress(Net.inet4LoopbackAddress(), port);\n+            } else {\n+                assert family == StandardProtocolFamily.INET6;\n+                return new InetSocketAddress(Net.inet6LoopbackAddress(), port);\n+            }\n+        } else {\n+            return isa;\n+        }\n+    }\n@@ -704,1 +871,9 @@\n-    abstract int implConnect(FileDescriptor fd,SocketAddress sa) throws IOException;\n+    private int implConnect(FileDescriptor fd,SocketAddress sa) throws IOException {\n+        if (family == StandardProtocolFamily.UNIX) {\n+            UnixDomainSocketAddress usa = (UnixDomainSocketAddress)sa;\n+            return UnixDomainSockets.connect(fd, usa.getPath());\n+        } else {\n+            InetSocketAddress isa = (InetSocketAddress)sa;\n+            return Net.connect(family, fd, isa.getAddress(), isa.getPort());\n+        }\n+    }\n@@ -1261,1 +1436,9 @@\n-    abstract String getRevealedLocalAddressAsString(SocketAddress sa);\n+    private String getRevealedLocalAddressAsString(SocketAddress sa) {\n+        if (family == StandardProtocolFamily.UNIX) {\n+            UnixDomainSocketAddress usa = (UnixDomainSocketAddress)sa;\n+            return UnixDomainSockets.getRevealedLocalAddressAsString(usa);\n+        } else {\n+            InetSocketAddress isa = (InetSocketAddress)sa;\n+            return Net.getRevealedLocalAddressAsString(isa);\n+        }\n+    }\n@@ -1266,1 +1449,1 @@\n-        sb.append(this.getClass().getName());\n+        sb.append(this.getClass().getSuperclass().getName());\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/SocketChannelImpl.java","additions":218,"deletions":35,"binary":false,"changes":253,"status":"modified"},{"patch":"@@ -1,200 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.nio.ch;\n-\n-import java.io.FileDescriptor;\n-import java.io.IOException;\n-import java.net.BindException;\n-import java.net.ServerSocket;\n-import java.net.SocketAddress;\n-import java.net.SocketOption;\n-import java.net.StandardSocketOptions;\n-import java.net.UnixDomainSocketAddress;\n-import java.nio.channels.SocketChannel;\n-import java.nio.channels.spi.SelectorProvider;\n-import java.nio.file.InvalidPathException;\n-import java.nio.file.Path;\n-import java.security.NoSuchAlgorithmException;\n-import java.security.SecureRandom;\n-import java.util.Collections;\n-import java.util.HashSet;\n-import java.util.Random;\n-import java.util.Set;\n-\n-\/**\n- * An implementation of ServerSocketChannels\n- *\/\n-\n-public class UnixDomainServerSocketChannelImpl\n-    extends ServerSocketChannelImpl\n-{\n-    public UnixDomainServerSocketChannelImpl(SelectorProvider sp) throws IOException {\n-        super(sp, UnixDomainSockets.socket(), false);\n-    }\n-\n-    public UnixDomainServerSocketChannelImpl(SelectorProvider sp, FileDescriptor fd, boolean bound)\n-        throws IOException\n-    {\n-        super(sp, fd, bound);\n-    }\n-\n-    @Override\n-    SocketAddress implLocalAddress(FileDescriptor fd) throws IOException {\n-        return UnixDomainSockets.localAddress(fd);\n-    }\n-\n-    @Override\n-    SocketAddress getRevealedLocalAddress(SocketAddress addr) {\n-        return UnixDomainSockets.getRevealedLocalAddress((UnixDomainSocketAddress)addr);\n-    }\n-\n-    @Override\n-    String getRevealedLocalAddressAsString(SocketAddress addr) {\n-        return UnixDomainSockets.getRevealedLocalAddressAsString((UnixDomainSocketAddress)addr);\n-    }\n-\n-    @Override\n-    public ServerSocket socket() {\n-        throw new UnsupportedOperationException(\"socket not supported\");\n-    }\n-\n-    @Override\n-    <T> void implSetOption(SocketOption<T> name, T value) throws IOException {\n-        Net.setSocketOption(getFD(), Net.UNSPEC, name, value);\n-    }\n-\n-    @Override\n-    @SuppressWarnings(\"unchecked\")\n-    <T> T implGetOption(SocketOption<T> name) throws IOException {\n-        return (T) Net.getSocketOption(getFD(), Net.UNSPEC, name);\n-    }\n-\n-    private static Set<SocketOption<?>> supportedOptions =\n-        Collections.unmodifiableSet(Set.of(StandardSocketOptions.SO_RCVBUF));\n-\n-    @Override\n-    public final Set<SocketOption<?>> supportedOptions() {\n-        return supportedOptions;\n-    }\n-\n-    @Override\n-    public SocketAddress implBind(SocketAddress local, int backlog) throws IOException {\n-        boolean found = false;\n-\n-        UnixDomainSockets.checkPermission();\n-\n-        \/\/ Attempt up to 10 times to find an unused name in temp directory.\n-        \/\/ If local address supplied then bind called only once\n-        for (int i = 0; i < 10; i++) {\n-            UnixDomainSocketAddress usa = null;\n-            if (local == null) {\n-                usa = getTempName();\n-            } else {\n-                usa = UnixDomainSockets.checkAddress(local);\n-            }\n-            try {\n-                UnixDomainSockets.bind(getFD(), usa.getPath());\n-                found = true;\n-                break;\n-            } catch (BindException e) {\n-                if (local != null) {\n-                    throw e;\n-                }\n-            }\n-        }\n-        if (!found)\n-            throw new BindException(\"Could not bind to temporary name\");\n-        Net.listen(getFD(), backlog < 1 ? 50 : backlog);\n-        return UnixDomainSockets.localAddress(getFD());\n-    }\n-\n-    private static Random getRandom() {\n-        try {\n-            return SecureRandom.getInstance(\"NativePRNGNonBlocking\");\n-        } catch (NoSuchAlgorithmException e) {\n-            return new SecureRandom(); \/\/ This should not fail\n-        }\n-    }\n-\n-    private static final Random random = getRandom();;\n-\n-    \/**\n-     * Return a possible temporary name to bind to, which is different for each call\n-     * Name is of the form <temp dir>\/socket_<random>\n-     *\/\n-    private static UnixDomainSocketAddress getTempName() throws IOException {\n-        String dir = UnixDomainSockets.tempDir;\n-        if (dir == null)\n-            throw new BindException(\"Could not locate temporary directory for sockets\");\n-        int rnd = random.nextInt(Integer.MAX_VALUE);\n-        try {\n-            Path path = Path.of(dir, \"socket_\" + Integer.toString(rnd));\n-            return UnixDomainSocketAddress.of(path);\n-        } catch (InvalidPathException e) {\n-            throw new BindException(\"Invalid temporary directory\");\n-        }\n-    }\n-\n-    @Override\n-    protected int implAccept(FileDescriptor fd, FileDescriptor newfd, SocketAddress[] addrs)\n-        throws IOException\n-    {\n-        UnixDomainSockets.checkPermission();\n-        String[] addrArray = new String[1];\n-        int n = UnixDomainSockets.accept(fd, newfd, addrArray);\n-        if (n > 0) {\n-            addrs[0] = UnixDomainSocketAddress.of(addrArray[0]);\n-        }\n-        return n;\n-    }\n-\n-    @Override\n-    SocketChannel implFinishAccept(FileDescriptor newfd, SocketAddress sa)\n-        throws IOException\n-    {\n-        UnixDomainSocketAddress usa = (UnixDomainSocketAddress)sa;\n-        return new UnixDomainSocketChannelImpl(provider(), newfd, usa);\n-    }\n-\n-    @Override\n-    public String toString() {\n-        StringBuilder sb = new StringBuilder();\n-        sb.append(this.getClass().getName());\n-        sb.append('[');\n-        if (!isOpen()) {\n-            sb.append(\"closed\");\n-        } else {\n-            UnixDomainSocketAddress addr = (UnixDomainSocketAddress) localAddress();\n-            if (addr == null) {\n-                sb.append(\"unbound\");\n-            } else {\n-                sb.append(getRevealedLocalAddressAsString(addr));\n-            }\n-        }\n-        sb.append(']');\n-        return sb.toString();\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/UnixDomainServerSocketChannelImpl.java","additions":0,"deletions":200,"binary":false,"changes":200,"status":"deleted"},{"patch":"@@ -1,170 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.nio.ch;\n-\n-import java.io.FileDescriptor;\n-import java.io.IOException;\n-import java.net.Socket;\n-import java.net.SocketAddress;\n-import java.net.SocketOption;\n-import java.net.StandardSocketOptions;\n-import java.net.UnixDomainSocketAddress;\n-import java.nio.ByteBuffer;\n-import java.nio.channels.spi.SelectorProvider;\n-import java.nio.file.Path;\n-import java.util.Collections;\n-import java.util.HashSet;\n-import java.util.Objects;\n-import java.util.Set;\n-import sun.net.ext.ExtendedSocketOptions;\n-\n-\/**\n- * An implementation of SocketChannels\n- *\/\n-\n-public class UnixDomainSocketChannelImpl extends SocketChannelImpl\n-{\n-    UnixDomainSocketChannelImpl(SelectorProvider sp, FileDescriptor fd, boolean bound)\n-        throws IOException\n-    {\n-        super(sp, fd, bound);\n-    }\n-\n-    \/\/ Constructor for sockets obtained from server sockets\n-    \/\/\n-    UnixDomainSocketChannelImpl(SelectorProvider sp, FileDescriptor fd, SocketAddress isa)\n-        throws IOException\n-    {\n-        super(sp, fd, isa);\n-    }\n-\n-    @Override\n-    SocketAddress implLocalAddress(FileDescriptor fd) throws IOException {\n-        return UnixDomainSockets.localAddress(fd);\n-    }\n-\n-    @Override\n-    SocketAddress getRevealedLocalAddress(SocketAddress address) {\n-        UnixDomainSocketAddress uaddr = (UnixDomainSocketAddress)address;\n-        return UnixDomainSockets.getRevealedLocalAddress(uaddr);\n-    }\n-\n-    @Override\n-    <T> void implSetOption(SocketOption<T> name, T value) throws IOException {\n-        Net.setSocketOption(getFD(), name, value);\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    @Override\n-    <T> T implGetOption(SocketOption<T> name) throws IOException {\n-        return (T) Net.getSocketOption(getFD(), name);\n-    }\n-\n-    private static class DefaultOptionsHolder {\n-        static final Set<SocketOption<?>> defaultOptions = defaultOptions();\n-\n-        private static Set<SocketOption<?>> defaultOptions() {\n-            HashSet<SocketOption<?>> set = new HashSet<>();\n-            set.add(StandardSocketOptions.SO_SNDBUF);\n-            set.add(StandardSocketOptions.SO_RCVBUF);\n-            set.add(StandardSocketOptions.SO_LINGER);\n-            set.addAll(ExtendedSocketOptions.unixSocketOptions());\n-            return Collections.unmodifiableSet(set);\n-        }\n-    }\n-\n-    @Override\n-    public final Set<SocketOption<?>> supportedOptions() {\n-        return DefaultOptionsHolder.defaultOptions;\n-    }\n-\n-    @Override\n-    public Socket socket() {\n-        throw new UnsupportedOperationException(\"socket not supported\");\n-    }\n-\n-    \/**\n-     * Read\/write need to be overridden for JFR\n-     *\/\n-    @Override\n-    public int read(ByteBuffer buf) throws IOException {\n-        return super.read(buf);\n-    }\n-\n-    @Override\n-    public long read(ByteBuffer[] dsts, int offset, int length)\n-        throws IOException\n-    {\n-        return super.read(dsts, offset, length);\n-    }\n-\n-    @Override\n-    public int write(ByteBuffer buf) throws IOException {\n-        return super.write(buf);\n-    }\n-\n-    @Override\n-    public long write(ByteBuffer[] srcs, int offset, int length)\n-        throws IOException\n-    {\n-        return super.write(srcs, offset, length);\n-    }\n-\n-    @Override\n-    SocketAddress implBind(SocketAddress local) throws IOException {\n-        UnixDomainSockets.checkPermission();\n-        UnixDomainSocketAddress usa = UnixDomainSockets.checkAddress(local);\n-        Path path = usa == null ? null : usa.getPath();\n-        UnixDomainSockets.bind(getFD(), path);\n-        if (usa == null || path.toString().equals(\"\")) {\n-            return UnixDomainSockets.UNNAMED;\n-        } else {\n-            return UnixDomainSockets.localAddress(getFD());\n-        }\n-    }\n-\n-    \/**\n-     * Checks the permissions required for connect\n-     *\/\n-    @Override\n-    SocketAddress checkRemote(SocketAddress sa) throws IOException {\n-        Objects.requireNonNull(sa);\n-        UnixDomainSockets.checkPermission();\n-        UnixDomainSocketAddress usa = UnixDomainSockets.checkAddress(sa);\n-        return usa;\n-    }\n-\n-    @Override\n-    int implConnect(FileDescriptor fd, SocketAddress sa) throws IOException {\n-        UnixDomainSocketAddress usa = (UnixDomainSocketAddress)sa;\n-        return UnixDomainSockets.connect(fd, usa.getPath());\n-    }\n-\n-    String getRevealedLocalAddressAsString(SocketAddress sa) {\n-        UnixDomainSocketAddress usa = (UnixDomainSocketAddress)sa;\n-        return UnixDomainSockets.getRevealedLocalAddressAsString(usa);\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/UnixDomainSocketChannelImpl.java","additions":0,"deletions":170,"binary":false,"changes":170,"status":"deleted"},{"patch":"@@ -30,0 +30,1 @@\n+import java.net.BindException;\n@@ -33,0 +34,1 @@\n+import java.nio.channels.SocketChannel;\n@@ -35,0 +37,1 @@\n+import java.nio.file.InvalidPathException;\n@@ -37,0 +40,1 @@\n+import java.security.NoSuchAlgorithmException;\n@@ -38,0 +42,2 @@\n+import java.security.SecureRandom;\n+import java.util.Random;\n@@ -102,0 +108,5 @@\n+    static boolean isUnixDomain(SocketChannel sc) {\n+        SocketChannelImpl sci = (SocketChannelImpl)sc;\n+        return sci.localAddress() instanceof UnixDomainSocketAddress;\n+    }\n+\n@@ -129,0 +140,27 @@\n+    private static Random getRandom() {\n+        try {\n+            return SecureRandom.getInstance(\"NativePRNGNonBlocking\");\n+        } catch (NoSuchAlgorithmException e) {\n+            return new SecureRandom(); \/\/ This should not fail\n+        }\n+    }\n+\n+    private static final Random random = getRandom();\n+\n+    \/**\n+     * Return a possible temporary name to bind to, which is different for each call\n+     * Name is of the form <temp dir>\/socket_<random>\n+     *\/\n+    static UnixDomainSocketAddress getTempName() throws IOException {\n+        String dir = UnixDomainSockets.tempDir;\n+        if (dir == null)\n+            throw new BindException(\"Could not locate temporary directory for sockets\");\n+        int rnd = random.nextInt(Integer.MAX_VALUE);\n+        try {\n+            Path path = Path.of(dir, \"socket_\" + Integer.toString(rnd));\n+            return UnixDomainSocketAddress.of(path);\n+        } catch (InvalidPathException e) {\n+            throw new BindException(\"Invalid temporary directory\");\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/UnixDomainSockets.java","additions":38,"deletions":0,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2020 Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/fs\/AbstractFileSystemProvider.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import java.net.SocketAddress;\n@@ -43,0 +44,1 @@\n+import static java.net.StandardProtocolFamily.UNIX;\n@@ -82,0 +84,8 @@\n+    static ProtocolFamily family(SocketAddress sa) {\n+        if (sa instanceof UnixDomainSocketAddress) {\n+            return UNIX;\n+        }\n+        InetSocketAddress isa = (InetSocketAddress)sa;\n+        return (isa.getAddress() instanceof Inet6Address) ? INET6 : INET;\n+    }\n+\n@@ -87,5 +97,1 @@\n-    public static class InheritedInetSocketChannelImpl extends InetSocketChannelImpl {\n-\n-        static ProtocolFamily family(InetSocketAddress isa) {\n-            return (isa.getAddress() instanceof Inet6Address) ? INET6 : INET;\n-        }\n+    public static class InheritedSocketChannelImpl extends SocketChannelImpl {\n@@ -93,1 +99,1 @@\n-        InheritedInetSocketChannelImpl(SelectorProvider sp,\n+        InheritedSocketChannelImpl(SelectorProvider sp,\n@@ -95,1 +101,1 @@\n-                                   InetSocketAddress remote)\n+                                   SocketAddress remote)\n@@ -107,18 +113,1 @@\n-    public static class InheritedUnixSocketChannelImpl extends UnixDomainSocketChannelImpl {\n-\n-        InheritedUnixSocketChannelImpl(SelectorProvider sp,\n-                                FileDescriptor fd,\n-                                UnixDomainSocketAddress remote )\n-            throws IOException\n-        {\n-            super(sp, fd, remote);\n-        }\n-\n-        @Override\n-        protected void implCloseSelectableChannel() throws IOException {\n-            super.implCloseSelectableChannel();\n-            detachIOStreams();\n-        }\n-    }\n-\n-    public static class InheritedUnixServerSocketChannelImpl extends UnixDomainServerSocketChannelImpl {\n+    public static class InheritedServerSocketChannelImpl extends ServerSocketChannelImpl {\n@@ -126,1 +115,1 @@\n-        InheritedUnixServerSocketChannelImpl(SelectorProvider sp, FileDescriptor fd)\n+        InheritedServerSocketChannelImpl(SelectorProvider sp, ProtocolFamily family, FileDescriptor fd)\n@@ -129,1 +118,1 @@\n-            super(sp, fd, true);\n+            super(sp, family, fd, true);\n@@ -139,17 +128,0 @@\n-    public static class InheritedInetServerSocketChannelImpl extends\n-        InetServerSocketChannelImpl {\n-\n-        InheritedInetServerSocketChannelImpl(SelectorProvider sp,\n-                                         FileDescriptor fd)\n-            throws IOException\n-        {\n-            super(sp, fd, true);\n-        }\n-\n-        protected void implCloseSelectableChannel() throws IOException {\n-            super.implCloseSelectableChannel();\n-            detachIOStreams();\n-        }\n-\n-    }\n-\n@@ -185,0 +157,8 @@\n+    static ProtocolFamily protocolFamily(int family) {\n+        return switch (family) {\n+            case AF_INET -> INET;\n+            case AF_INET6 -> INET6;\n+            case AF_UNIX -> UNIX;\n+            default -> throw new IllegalArgumentException();\n+        };\n+    }\n@@ -222,1 +202,1 @@\n-        \/\/ we see if tthere is a peer (ie: connected). If so, then we\n+        \/\/ we see if there is a peer (ie: connected). If so, then we\n@@ -234,0 +214,1 @@\n+            ProtocolFamily pfamily = protocolFamily(family);\n@@ -236,2 +217,2 @@\n-                    var sa = UnixDomainSocketAddress.of(peerAddressUnix(fdVal));\n-                    return new InheritedUnixSocketChannelImpl(provider, fd, sa);\n+                    var sa = UnixDomainSocketAddress.of(unixPeerAddress(fdVal));\n+                    return new InheritedSocketChannelImpl(provider, fd, sa);\n@@ -239,1 +220,1 @@\n-                    return new InheritedUnixServerSocketChannelImpl(provider, fd);\n+                    return new InheritedServerSocketChannelImpl(provider, pfamily, fd);\n@@ -242,1 +223,1 @@\n-            InetAddress ia = peerAddressInet(fdVal);\n+            InetAddress ia = inetPeerAddress0(fdVal);\n@@ -244,1 +225,1 @@\n-               c = new InheritedInetServerSocketChannelImpl(provider, fd);\n+               c = new InheritedServerSocketChannelImpl(provider, pfamily, fd);\n@@ -250,1 +231,1 @@\n-               c = new InheritedInetSocketChannelImpl(provider, fd, isa);\n+               c = new InheritedSocketChannelImpl(provider, fd, isa);\n@@ -284,2 +265,2 @@\n-    private static String peerAddressUnix(int fd) throws IOException {\n-        byte[] bytes = peerAddressUnix0(fd);\n+    private static String unixPeerAddress(int fd) throws IOException {\n+        byte[] bytes = unixPeerAddress0(fd);\n@@ -298,2 +279,2 @@\n-    private static native InetAddress peerAddressInet(int fd);\n-    private static native byte[] peerAddressUnix0(int fd);\n+    private static native InetAddress inetPeerAddress0(int fd);\n+    private static native byte[] unixPeerAddress0(int fd);\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/ch\/InheritedChannel.java","additions":36,"deletions":55,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import jdk.internal.util.StaticProperty;\n@@ -61,1 +62,1 @@\n-            return System.getProperty(\"java.io.tmpdir\");\n+            return StaticProperty.javaIOTmpdir();\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/ch\/UnixDomainSocketsUtil.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2020, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixFileSystemProvider.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2020, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixUserPrincipals.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,1 @@\n-static int matchFamilyInet(SOCKETADDRESS *sa) {\n+static int toInetFamily(SOCKETADDRESS *sa) {\n@@ -53,1 +53,1 @@\n-Java_sun_nio_ch_InheritedChannel_peerAddressInet(JNIEnv *env, jclass cla, jint fd)\n+Java_sun_nio_ch_InheritedChannel_inetPeerAddress0(JNIEnv *env, jclass cla, jint fd)\n@@ -61,1 +61,1 @@\n-        if (matchFamilyInet(&sa)) {\n+        if (toInetFamily(&sa)) {\n@@ -70,1 +70,1 @@\n-Java_sun_nio_ch_InheritedChannel_peerAddressUnix0(JNIEnv *env, jclass cla, jint fd)\n+Java_sun_nio_ch_InheritedChannel_unixPeerAddress0(JNIEnv *env, jclass cla, jint fd)\n@@ -92,1 +92,1 @@\n-        if (matchFamilyInet(&sa)) {\n+        if (toInetFamily(&sa)) {\n","filename":"src\/java.base\/unix\/native\/libnio\/ch\/InheritedChannel.c","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -44,6 +44,0 @@\n-#ifdef _AIX\n-#include <stdlib.h>\n-#include <sys\/utsname.h>\n-#endif\n-\n-\n@@ -87,1 +81,4 @@\n-        goto finish;\n+    } else {\n+        memcpy(sa->sun_path, pname, name_len);\n+        *len = (int)(offsetof(struct sockaddr_un, sun_path) + name_len + 1);\n+        ret = 0;\n@@ -89,4 +86,0 @@\n-    memcpy(sa->sun_path, pname, name_len);\n-    *len = (int)(offsetof(struct sockaddr_un, sun_path) + name_len + 1);\n-    ret = 0;\n-  finish:\n@@ -126,3 +119,0 @@\n-    if (path == NULL)\n-        return; \/* Rely on implicit bind: Unix *\/\n-\n@@ -165,1 +155,1 @@\n-                           jobjectArray usaa)\n+                                          jobjectArray usaa)\n","filename":"src\/java.base\/unix\/native\/libnio\/ch\/UnixDomainSockets.c","additions":5,"deletions":15,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -178,3 +178,9 @@\n-    \/\/ if buffering is false and TCP sockets being used, then TCP_NODELAY\n-    \/\/ is set on the sink channel.\n-\n+    \/**\n+     * Creates a PipeImpl using either UNIX channels if available\n+     * or INET\/6 otherwise.\n+     *\n+     * @param sp the SelectorProvider\n+     *\n+     * @param buffering if false and TCP sockets being used, then TCP_NODELAY\n+     *                  is set on the sink channel.\n+     *\/\n@@ -185,3 +191,2 @@\n-            if (!buffering && (sc instanceof InetSocketChannelImpl)) {\n-                var isc = (InetSocketChannelImpl)sc;\n-                isc.setOption(StandardSocketOptions.TCP_NODELAY, true);\n+            if (!buffering && !UnixDomainSockets.isUnixDomain(sc)) {\n+                sc.setOption(StandardSocketOptions.TCP_NODELAY, true);\n@@ -202,1 +207,1 @@\n-    private static volatile boolean noUnixDomainSockets = false;\n+    private static volatile boolean noUnixDomainSockets;\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/ch\/PipeImpl.java","additions":13,"deletions":8,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/ch\/SinkChannelImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import jdk.internal.util.StaticProperty;\n@@ -64,1 +65,1 @@\n-            return System.getProperty(\"java.io.tmpdir\");\n+            return StaticProperty.javaIOTmpdir();\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/ch\/UnixDomainSocketsUtil.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+import java.nio.channels.SelectableChannel;\n@@ -420,2 +421,3 @@\n-                if (isExceptFds &&\n-                    (sk.channel() instanceof InetSocketChannelImpl) &&\n+                SelectableChannel sc = sk.channel();\n+                if (isExceptFds && sc instanceof SocketChannelImpl &&\n+                    !UnixDomainSockets.isUnixDomain((SocketChannelImpl)sc) &&\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/ch\/WindowsSelectorImpl.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2020, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/fs\/WindowsFileSystemProvider.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2020, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/java.base\/windows\/native\/libnio\/ch\/nio_util.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,2 +33,0 @@\n-    public final static EventHandler UNIX_SOCKET_READ = Utils.getHandler(UnixSocketReadEvent.class);\n-    public final static EventHandler UNIX_SOCKET_WRITE = Utils.getHandler(UnixSocketWriteEvent.class);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/events\/Handlers.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,56 +0,0 @@\n-\/*\n- * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.jfr.events;\n-\n-import jdk.jfr.Category;\n-import jdk.jfr.Description;\n-import jdk.jfr.Label;\n-import jdk.jfr.DataAmount;\n-import jdk.jfr.Name;\n-import jdk.jfr.internal.Type;\n-\n-@Name(Type.EVENT_NAME_PREFIX + \"UnixSocketRead\")\n-@Label(\"UnixSocket Read\")\n-@Category(\"Java Application\")\n-@Description(\"Reading data from a Unix domain socket\")\n-public final class UnixSocketReadEvent extends AbstractJDKEvent {\n-\n-    \/\/ The order of these fields must be the same as the parameters in\n-    \/\/ EventHandler::write(..., String, long, boolean)\n-\n-    @Label(\"From\")\n-    @Description(\"Path to remote peer\")\n-    public String path;\n-\n-    @Label(\"Bytes Read\")\n-    @Description(\"Number of bytes read from the socket (possibly 0)\")\n-    @DataAmount\n-    public long bytesRead;\n-\n-    @Label(\"End of File\")\n-    @Description(\"If end of file was reached\")\n-    public boolean endOfFile;\n-}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/events\/UnixSocketReadEvent.java","additions":0,"deletions":56,"binary":false,"changes":56,"status":"deleted"},{"patch":"@@ -1,52 +0,0 @@\n-\/*\n- * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.jfr.events;\n-\n-import jdk.jfr.Category;\n-import jdk.jfr.Description;\n-import jdk.jfr.Label;\n-import jdk.jfr.DataAmount;\n-import jdk.jfr.Name;\n-import jdk.jfr.internal.Type;\n-\n-@Name(Type.EVENT_NAME_PREFIX + \"UnixSocketWrite\")\n-@Label(\"UnixSocket Write\")\n-@Category(\"Java Application\")\n-@Description(\"Writing data to a Unix socket\")\n-public final class UnixSocketWriteEvent extends AbstractJDKEvent {\n-\n-    \/\/ The order of these fields must be the same as the parameters in\n-    \/\/ EventHandler::write(..., String, long)\n-\n-    @Label(\"To\")\n-    @Description(\"Path to peer socket\")\n-    public String path;\n-\n-    @Label(\"Bytes Written\")\n-    @Description(\"Number of bytes written to the file\")\n-    @DataAmount\n-    public long bytesWritten;\n-}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/events\/UnixSocketWriteEvent.java","additions":0,"deletions":52,"binary":false,"changes":52,"status":"deleted"},{"patch":"@@ -1,171 +0,0 @@\n-\/*\n- * Copyright (c) 2013, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.jfr.internal.instrument;\n-\n-import java.io.IOException;\n-import java.net.InetSocketAddress;\n-import java.net.SocketAddress;\n-import java.nio.ByteBuffer;\n-import jdk.jfr.events.Handlers;\n-import jdk.jfr.internal.handlers.EventHandler;\n-\n-\/**\n- * See {@link JITracer} for an explanation of this code.\n- *\/\n-@JIInstrumentationTarget(\"sun.nio.ch.InetSocketChannelImpl\")\n-final class InetSocketChannelImplInstrumentor {\n-\n-    private InetSocketChannelImplInstrumentor() {\n-    }\n-\n-    @SuppressWarnings(\"deprecation\")\n-    @JIInstrumentationMethod\n-    public int read(ByteBuffer dst) throws IOException {\n-        EventHandler handler = Handlers.SOCKET_READ;\n-        if (!handler.isEnabled()) {\n-            return read(dst);\n-        }\n-        InetSocketAddress remoteAddress = (InetSocketAddress)getRemoteAddress();\n-        int bytesRead = 0;\n-        long start  = 0;\n-        try {\n-            start = EventHandler.timestamp();;\n-            bytesRead = read(dst);\n-        } finally {\n-            long duration = EventHandler.timestamp() - start;\n-            if (handler.shouldCommit(duration))  {\n-                String hostString  = remoteAddress.getAddress().toString();\n-                int delimiterIndex = hostString.lastIndexOf('\/');\n-\n-                String host = hostString.substring(0, delimiterIndex);\n-                String address = hostString.substring(delimiterIndex + 1);\n-                int port = remoteAddress.getPort();\n-                if (bytesRead < 0) {\n-                    handler.write(start, duration, host, address, port, 0, 0L, true);\n-                } else {\n-                    handler.write(start, duration, host, address, port, 0, bytesRead, false);\n-                }\n-            }\n-        }\n-        return bytesRead;\n-    }\n-\n-    @SuppressWarnings(\"deprecation\")\n-    @JIInstrumentationMethod\n-    public long read(ByteBuffer[] dsts, int offset, int length) throws IOException {\n-        EventHandler handler = Handlers.SOCKET_READ;\n-        if (!handler.isEnabled()) {\n-            return read(dsts, offset, length);\n-        }\n-        InetSocketAddress remoteAddress = (InetSocketAddress)getRemoteAddress();\n-\n-        long bytesRead = 0;\n-        long start = 0;\n-        try {\n-            start = EventHandler.timestamp();\n-            bytesRead = read(dsts, offset, length);\n-        } finally {\n-            long duration = EventHandler.timestamp() - start;\n-            if (handler.shouldCommit(duration)) {\n-                String hostString  = remoteAddress.getAddress().toString();\n-                int delimiterIndex = hostString.lastIndexOf('\/');\n-\n-                String host = hostString.substring(0, delimiterIndex);\n-                String address = hostString.substring(delimiterIndex + 1);\n-                int port = remoteAddress.getPort();\n-                if (bytesRead < 0) {\n-                    handler.write(start, duration, host, address, port, 0, 0L, true);\n-                } else {\n-                    handler.write(start, duration, host, address, port, 0, bytesRead, false);\n-                }\n-            }\n-        }\n-        return bytesRead;\n-    }\n-\n-    @SuppressWarnings(\"deprecation\")\n-    @JIInstrumentationMethod\n-    public int write(ByteBuffer buf) throws IOException {\n-        EventHandler handler = Handlers.SOCKET_WRITE;\n-        if (!handler.isEnabled()) {\n-            return write(buf);\n-        }\n-        InetSocketAddress remoteAddress = (InetSocketAddress)getRemoteAddress();\n-        int bytesWritten = 0;\n-        long start = 0;\n-        try {\n-            start = EventHandler.timestamp();\n-            bytesWritten = write(buf);\n-        } finally {\n-            long duration = EventHandler.timestamp() - start;\n-            if (handler.shouldCommit(duration)) {\n-                String hostString  = remoteAddress.getAddress().toString();\n-                int delimiterIndex = hostString.lastIndexOf('\/');\n-\n-                String host = hostString.substring(0, delimiterIndex);\n-                String address = hostString.substring(delimiterIndex + 1);\n-                int port = remoteAddress.getPort();\n-                long bytes = bytesWritten < 0 ? 0 : bytesWritten;\n-                handler.write(start, duration, host, address, port, bytes);\n-            }\n-        }\n-        return bytesWritten;\n-    }\n-\n-    public SocketAddress getRemoteAddress() throws IOException {\n-        \/\/ gets replaced by call to instrumented class\n-        return null;\n-    }\n-\n-    @SuppressWarnings(\"deprecation\")\n-    @JIInstrumentationMethod\n-    public long write(ByteBuffer[] srcs, int offset, int length) throws IOException {\n-        EventHandler handler = Handlers.SOCKET_WRITE;\n-        if (!handler.isEnabled()) {\n-            return write(srcs, offset, length);\n-        }\n-        InetSocketAddress remoteAddress = (InetSocketAddress)getRemoteAddress();\n-        long bytesWritten = 0;\n-        long start = 0;\n-        try {\n-            start = EventHandler.timestamp();\n-            bytesWritten = write(srcs, offset, length);\n-        } finally {\n-            long duration = EventHandler.timestamp() - start;\n-            if (handler.shouldCommit(duration)) {\n-                String hostString  = remoteAddress.getAddress().toString();\n-                int delimiterIndex = hostString.lastIndexOf('\/');\n-\n-                String host = hostString.substring(0, delimiterIndex);\n-                String address = hostString.substring(delimiterIndex + 1);\n-                int port = remoteAddress.getPort();\n-                long bytes = bytesWritten < 0 ? 0 : bytesWritten;\n-                handler.write(start, duration, host, address, port, bytes);\n-            }\n-        }\n-        return bytesWritten;\n-    }\n-}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/instrument\/InetSocketChannelImplInstrumentor.java","additions":0,"deletions":171,"binary":false,"changes":171,"status":"deleted"},{"patch":"@@ -45,2 +45,0 @@\n-import jdk.jfr.events.UnixSocketReadEvent;\n-import jdk.jfr.events.UnixSocketWriteEvent;\n@@ -73,2 +71,0 @@\n-        UnixSocketReadEvent.class,\n-        UnixSocketWriteEvent.class,\n@@ -96,2 +92,1 @@\n-        InetSocketChannelImplInstrumentor.class,\n-        UnixSocketChannelImplInstrumentor.class\n+        SocketChannelImplInstrumentor.class\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/instrument\/JDKEvents.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,208 @@\n+\/*\n+ * Copyright (c) 2013, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.internal.instrument;\n+\n+import java.io.IOException;\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.net.UnixDomainSocketAddress;\n+import java.nio.ByteBuffer;\n+import jdk.jfr.events.Handlers;\n+import jdk.jfr.internal.handlers.EventHandler;\n+\n+\/**\n+ * See {@link JITracer} for an explanation of this code.\n+ *\/\n+@JIInstrumentationTarget(\"sun.nio.ch.SocketChannelImpl\")\n+final class SocketChannelImplInstrumentor {\n+\n+    private SocketChannelImplInstrumentor() {\n+    }\n+\n+    @SuppressWarnings(\"deprecation\")\n+    @JIInstrumentationMethod\n+    public int read(ByteBuffer dst) throws IOException {\n+        EventHandler handler = Handlers.SOCKET_READ;\n+        if (!handler.isEnabled()) {\n+            return read(dst);\n+        }\n+        SocketAddress remoteAddress = getRemoteAddress();\n+        int bytesRead = 0;\n+        long start  = 0;\n+        try {\n+            start = EventHandler.timestamp();;\n+            bytesRead = read(dst);\n+        } finally {\n+            long duration = EventHandler.timestamp() - start;\n+            if (handler.shouldCommit(duration))  {\n+                if (remoteAddress instanceof InetSocketAddress) {\n+                    InetSocketAddress isa = (InetSocketAddress)remoteAddress;\n+                    String hostString  = isa.getAddress().toString();\n+                    int delimiterIndex = hostString.lastIndexOf('\/');\n+\n+                    String host = hostString.substring(0, delimiterIndex);\n+                    String address = hostString.substring(delimiterIndex + 1);\n+                    int port = isa.getPort();\n+                    if (bytesRead < 0) {\n+                        handler.write(start, duration, host, address, port, 0, 0L, true);\n+                    } else {\n+                        handler.write(start, duration, host, address, port, 0, bytesRead, false);\n+                    }\n+                } else {\n+                    UnixDomainSocketAddress usa = (UnixDomainSocketAddress)remoteAddress;\n+                    String path = \"[\" + usa.getPath().toString() + \"]\";\n+                    if (bytesRead < 0) {\n+                        handler.write(start, duration, \"Unix domain socket\", path, 0, 0, 0L, true);\n+                    } else {\n+                        handler.write(start, duration, \"Unix domain socket\", path, 0, 0, bytesRead, false);\n+                    }\n+                }\n+            }\n+        }\n+        return bytesRead;\n+    }\n+\n+    @SuppressWarnings(\"deprecation\")\n+    @JIInstrumentationMethod\n+    public long read(ByteBuffer[] dsts, int offset, int length) throws IOException {\n+        EventHandler handler = Handlers.SOCKET_READ;\n+        if (!handler.isEnabled()) {\n+            return read(dsts, offset, length);\n+        }\n+        SocketAddress remoteAddress = getRemoteAddress();\n+\n+        long bytesRead = 0;\n+        long start = 0;\n+        try {\n+            start = EventHandler.timestamp();\n+            bytesRead = read(dsts, offset, length);\n+        } finally {\n+            long duration = EventHandler.timestamp() - start;\n+            if (handler.shouldCommit(duration)) {\n+                if (remoteAddress instanceof InetSocketAddress) {\n+                    InetSocketAddress isa = (InetSocketAddress)remoteAddress;\n+                    String hostString  = isa.getAddress().toString();\n+                    int delimiterIndex = hostString.lastIndexOf('\/');\n+\n+                    String host = hostString.substring(0, delimiterIndex);\n+                    String address = hostString.substring(delimiterIndex + 1);\n+                    int port = isa.getPort();\n+                    if (bytesRead < 0) {\n+                        handler.write(start, duration, host, address, port, 0, 0L, true);\n+                    } else {\n+                        handler.write(start, duration, host, address, port, 0, bytesRead, false);\n+                    }\n+                } else {\n+                    UnixDomainSocketAddress usa = (UnixDomainSocketAddress)remoteAddress;\n+                    String path = \"[\" + usa.getPath().toString() + \"]\";\n+                    if (bytesRead < 0) {\n+                        handler.write(start, duration, \"Unix domain socket\", path, 0, 0, 0L, true);\n+                    } else {\n+                        handler.write(start, duration, \"Unix domain socket\", path, 0, 0, bytesRead, false);\n+                    }\n+                }\n+            }\n+        }\n+        return bytesRead;\n+    }\n+\n+    @SuppressWarnings(\"deprecation\")\n+    @JIInstrumentationMethod\n+    public int write(ByteBuffer buf) throws IOException {\n+        EventHandler handler = Handlers.SOCKET_WRITE;\n+        if (!handler.isEnabled()) {\n+            return write(buf);\n+        }\n+        SocketAddress remoteAddress = getRemoteAddress();\n+        int bytesWritten = 0;\n+        long start = 0;\n+        try {\n+            start = EventHandler.timestamp();\n+            bytesWritten = write(buf);\n+        } finally {\n+            long duration = EventHandler.timestamp() - start;\n+            if (handler.shouldCommit(duration)) {\n+                long bytes = bytesWritten < 0 ? 0 : bytesWritten;\n+                if (remoteAddress instanceof InetSocketAddress) {\n+                    InetSocketAddress isa = (InetSocketAddress)remoteAddress;\n+                    String hostString  = isa.getAddress().toString();\n+                    int delimiterIndex = hostString.lastIndexOf('\/');\n+\n+                    String host = hostString.substring(0, delimiterIndex);\n+                    String address = hostString.substring(delimiterIndex + 1);\n+                    int port = isa.getPort();\n+                    handler.write(start, duration, host, address, port, bytes);\n+                } else {\n+                    UnixDomainSocketAddress usa = (UnixDomainSocketAddress)remoteAddress;\n+                    String path = \"[\" + usa.getPath().toString() + \"]\";\n+                    handler.write(start, duration, \"Unix domain socket\", path, 0, bytes);\n+                }\n+            }\n+        }\n+        return bytesWritten;\n+    }\n+\n+    public SocketAddress getRemoteAddress() throws IOException {\n+        \/\/ gets replaced by call to instrumented class\n+        return null;\n+    }\n+\n+    @SuppressWarnings(\"deprecation\")\n+    @JIInstrumentationMethod\n+    public long write(ByteBuffer[] srcs, int offset, int length) throws IOException {\n+        EventHandler handler = Handlers.SOCKET_WRITE;\n+        if (!handler.isEnabled()) {\n+            return write(srcs, offset, length);\n+        }\n+        SocketAddress remoteAddress = getRemoteAddress();\n+        long bytesWritten = 0;\n+        long start = 0;\n+        try {\n+            start = EventHandler.timestamp();\n+            bytesWritten = write(srcs, offset, length);\n+        } finally {\n+            long duration = EventHandler.timestamp() - start;\n+            if (handler.shouldCommit(duration)) {\n+                long bytes = bytesWritten < 0 ? 0 : bytesWritten;\n+                if (remoteAddress instanceof InetSocketAddress) {\n+                    InetSocketAddress isa = (InetSocketAddress)remoteAddress;\n+                    String hostString  = isa.getAddress().toString();\n+                    int delimiterIndex = hostString.lastIndexOf('\/');\n+\n+                    String host = hostString.substring(0, delimiterIndex);\n+                    String address = hostString.substring(delimiterIndex + 1);\n+                    int port = isa.getPort();\n+                    handler.write(start, duration, host, address, port, bytes);\n+                } else {\n+                    UnixDomainSocketAddress usa = (UnixDomainSocketAddress)remoteAddress;\n+                    String path = \"[\" + usa.getPath().toString() + \"]\";\n+                    handler.write(start, duration, \"Unix domain socket\", path, 0, bytes);\n+                }\n+            }\n+        }\n+        return bytesWritten;\n+    }\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/instrument\/SocketChannelImplInstrumentor.java","additions":208,"deletions":0,"binary":false,"changes":208,"status":"added"},{"patch":"@@ -1,150 +0,0 @@\n-\/*\n- * Copyright (c) 2013, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.jfr.internal.instrument;\n-\n-import java.io.IOException;\n-import java.net.SocketAddress;\n-import java.net.UnixDomainSocketAddress;\n-import java.nio.ByteBuffer;\n-\n-import jdk.jfr.events.Handlers;\n-import jdk.jfr.internal.handlers.EventHandler;\n-\n-\/**\n- * See {@link JITracer} for an explanation of this code.\n- *\/\n-@JIInstrumentationTarget(\"sun.nio.ch.UnixDomainSocketChannelImpl\")\n-final class UnixSocketChannelImplInstrumentor {\n-\n-    private UnixSocketChannelImplInstrumentor() {\n-    }\n-\n-    @SuppressWarnings(\"deprecation\")\n-    @JIInstrumentationMethod\n-    public int read(ByteBuffer dst) throws IOException {\n-        EventHandler handler = Handlers.UNIX_SOCKET_READ;\n-        if (!handler.isEnabled()) {\n-            return read(dst);\n-        }\n-        UnixDomainSocketAddress remoteAddress = (UnixDomainSocketAddress)getRemoteAddress();\n-        int bytesRead = 0;\n-        long start  = 0;\n-        try {\n-            start = EventHandler.timestamp();;\n-            bytesRead = read(dst);\n-        } finally {\n-            long duration = EventHandler.timestamp() - start;\n-            if (handler.shouldCommit(duration))  {\n-                String path = remoteAddress.getPath().toString();\n-                if (bytesRead < 0) {\n-                    handler.write(start, duration, path, 0L, true);\n-                } else {\n-                    handler.write(start, duration, path, bytesRead, false);\n-                }\n-            }\n-        }\n-        return bytesRead;\n-    }\n-\n-    @SuppressWarnings(\"deprecation\")\n-    @JIInstrumentationMethod\n-    public long read(ByteBuffer[] dsts, int offset, int length) throws IOException {\n-        EventHandler handler = Handlers.UNIX_SOCKET_READ;\n-        if (!handler.isEnabled()) {\n-            return read(dsts, offset, length);\n-        }\n-        UnixDomainSocketAddress remoteAddress = (UnixDomainSocketAddress)getRemoteAddress();\n-\n-        long bytesRead = 0;\n-        long start = 0;\n-        try {\n-            start = EventHandler.timestamp();\n-            bytesRead = read(dsts, offset, length);\n-        } finally {\n-            long duration = EventHandler.timestamp() - start;\n-            if (handler.shouldCommit(duration)) {\n-                String path = remoteAddress.getPath().toString();\n-                if (bytesRead < 0) {\n-                    handler.write(start, duration, path, 0L, true);\n-                } else {\n-                    handler.write(start, duration, path, bytesRead, false);\n-                }\n-            }\n-        }\n-        return bytesRead;\n-    }\n-\n-    @SuppressWarnings(\"deprecation\")\n-    @JIInstrumentationMethod\n-    public int write(ByteBuffer buf) throws IOException {\n-        EventHandler handler = Handlers.UNIX_SOCKET_WRITE;\n-        if (!handler.isEnabled()) {\n-            return write(buf);\n-        }\n-        UnixDomainSocketAddress remoteAddress = (UnixDomainSocketAddress)getRemoteAddress();\n-        int bytesWritten = 0;\n-        long start = 0;\n-        try {\n-            start = EventHandler.timestamp();\n-            bytesWritten = write(buf);\n-        } finally {\n-            long duration = EventHandler.timestamp() - start;\n-            if (handler.shouldCommit(duration)) {\n-                String path = remoteAddress.getPath().toString();\n-                handler.write(start, duration, path, bytesWritten);\n-            }\n-        }\n-        return bytesWritten;\n-    }\n-\n-    @SuppressWarnings(\"deprecation\")\n-    @JIInstrumentationMethod\n-    public long write(ByteBuffer[] srcs, int offset, int length) throws IOException {\n-        EventHandler handler = Handlers.UNIX_SOCKET_WRITE;\n-        if (!handler.isEnabled()) {\n-            return write(srcs, offset, length);\n-        }\n-        UnixDomainSocketAddress remoteAddress = (UnixDomainSocketAddress)getRemoteAddress();\n-        long bytesWritten = 0;\n-        long start = 0;\n-        try {\n-            start = EventHandler.timestamp();\n-            bytesWritten = write(srcs, offset, length);\n-        } finally {\n-            long duration = EventHandler.timestamp() - start;\n-            if (handler.shouldCommit(duration)) {\n-                String path = remoteAddress.getPath().toString();\n-                handler.write(start, duration, path, bytesWritten);\n-            }\n-        }\n-        return bytesWritten;\n-    }\n-\n-    public SocketAddress getRemoteAddress() throws IOException {\n-        \/\/ is replaced by call to instrumented class\n-        return null;\n-    }\n-}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/instrument\/UnixSocketChannelImplInstrumentor.java","additions":0,"deletions":150,"binary":false,"changes":150,"status":"deleted"},{"patch":"@@ -672,12 +672,0 @@\n-    <event name=\"jdk.UnixSocketRead\">\n-      <setting name=\"enabled\">true<\/setting>\n-      <setting name=\"stackTrace\">true<\/setting>\n-      <setting name=\"threshold\" control=\"socket-io-threshold\">20 ms<\/setting>\n-    <\/event>\n-\n-    <event name=\"jdk.UnixSocketWrite\">\n-      <setting name=\"enabled\">true<\/setting>\n-      <setting name=\"stackTrace\">true<\/setting>\n-      <setting name=\"threshold\" control=\"socket-io-threshold\">20 ms<\/setting>\n-    <\/event>\n-\n","filename":"src\/jdk.jfr\/share\/conf\/jfr\/default.jfc","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -662,12 +662,0 @@\n-    <event name=\"jdk.UnixSocketRead\">\n-      <setting name=\"enabled\">true<\/setting>\n-      <setting name=\"stackTrace\">true<\/setting>\n-      <setting name=\"threshold\" control=\"socket-io-threshold\">10 ms<\/setting>\n-    <\/event>\n-\n-    <event name=\"jdk.UnixSocketWrite\">\n-      <setting name=\"enabled\">true<\/setting>\n-      <setting name=\"stackTrace\">true<\/setting>\n-      <setting name=\"threshold\" control=\"socket-io-threshold\">10 ms<\/setting>\n-    <\/event>\n-\n","filename":"src\/jdk.jfr\/share\/conf\/jfr\/profile.jfc","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/jdk.net\/linux\/classes\/jdk\/net\/LinuxSocketOptions.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/jdk.net\/macosx\/classes\/jdk\/net\/MacOSXSocketOptions.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/jdk.net\/macosx\/native\/libextnet\/MacOSXSocketOptions.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -162,1 +162,1 @@\n-        port = Net.localAddress(fd).getPort();\n+        port = (Net.localAddress(fd)).getPort();\n@@ -403,1 +403,2 @@\n-                                InetSocketAddress boundIsa = Net.localAddress(fd);\n+                                InetSocketAddress boundIsa =\n+                                        Net.localAddress(fd);\n@@ -509,1 +510,2 @@\n-                            InetSocketAddress boundIsa = Net.localAddress(fd);\n+                            InetSocketAddress boundIsa =\n+                                    Net.localAddress(fd);\n","filename":"src\/jdk.sctp\/unix\/classes\/sun\/nio\/ch\/sctp\/SctpChannelImpl.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,55 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8231358\n+ * @compile ..\/..\/nio\/file\/spi\/TestProvider.java AddressTest.java\n+ * @run testng\/othervm AddressTest\n+ *\/\n+\n+import java.net.UnixDomainSocketAddress;\n+import java.net.URI;\n+import java.nio.file.FileSystems;\n+import java.nio.file.spi.FileSystemProvider;\n+import java.nio.file.Path;\n+\n+import org.testng.annotations.Test;\n+\n+import static org.testng.Assert.assertThrows;\n+\n+public class AddressTest {\n+\n+    static UnixDomainSocketAddress addr;\n+\n+    \/\/ Expected exception\n+    private static final Class<IllegalArgumentException> IAE =\n+        IllegalArgumentException.class;\n+\n+    @Test\n+    public static void runTest() throws Exception {\n+        TestProvider prov = new TestProvider(FileSystems.getDefault().provider());\n+        Path path = prov.getPath(URI.create(\"file:\/\"));\n+        assertThrows(IAE, () -> UnixDomainSocketAddress.of(path));\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/UnixDomainSocketAddress\/AddressTest.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"","filename":"test\/jdk\/java\/net\/UnixDomainSocketAddress\/LengthTest.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jdk\/java\/nio\/channels\/unixdomain\/LengthTest.java","status":"renamed"},{"patch":"","filename":"test\/jdk\/java\/net\/UnixDomainSocketAddress\/UnixDomainSocketAddressSerializationTest.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jdk\/java\/nio\/channels\/unixdomain\/UnixDomainSocketAddressSerializationTest.java","status":"renamed"},{"patch":"@@ -331,8 +331,0 @@\n-    private static StandardProtocolFamily expectedFamily(StandardProtocolFamily family) {\n-        if (family == null) {\n-            return preferIPv4 ? INET : INET6;\n-        } else {\n-            return family;\n-        }\n-    }\n-\n","filename":"test\/jdk\/java\/nio\/channels\/etc\/ProtocolFamilies.java","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/java\/nio\/channels\/spi\/SelectorProvider\/inheritedChannel\/EchoTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -88,0 +88,1 @@\n+\n","filename":"test\/jdk\/java\/nio\/channels\/spi\/SelectorProvider\/inheritedChannel\/InheritedChannelTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/java\/nio\/channels\/spi\/SelectorProvider\/inheritedChannel\/StateTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,50 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @bug 8231358\n- * @build AddressTest DummyPath\n- * @run testng\/othervm AddressTest\n- *\/\n-\n-import java.net.UnixDomainSocketAddress;\n-\n-import org.testng.annotations.Test;\n-\n-import static org.testng.Assert.assertThrows;\n-\n-public class AddressTest {\n-\n-    static UnixDomainSocketAddress addr;\n-\n-    \/\/ Expected exception\n-    private static final Class<IllegalArgumentException> IAE =\n-        IllegalArgumentException.class;\n-\n-    @Test\n-    static void runTest() throws Exception {\n-        DummyPath path = new DummyPath();\n-        assertThrows(IAE, () -> UnixDomainSocketAddress.of(path));\n-    }\n-}\n","filename":"test\/jdk\/java\/nio\/channels\/unixdomain\/AddressTest.java","additions":0,"deletions":50,"binary":false,"changes":50,"status":"deleted"},{"patch":"@@ -24,0 +24,6 @@\n+\/**\n+ * @test\n+ * @bug 8231358\n+ * @run main\/othervm Bind\n+ *\/\n+\n","filename":"test\/jdk\/java\/nio\/channels\/unixdomain\/Bind.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1,187 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.io.IOException;\n-import java.net.URI;\n-import java.nio.file.*;\n-import java.nio.file.attribute.UserPrincipalLookupService;\n-import java.nio.file.spi.FileSystemProvider;\n-import java.util.Set;\n-\n-public class DummyPath implements Path {\n-\n-    FileSystem fs = new DummyFileSystem();\n-\n-    class DummyFileSystem extends FileSystem {\n-\n-        @Override\n-        public FileSystemProvider provider() {\n-            return null;\n-        }\n-\n-        @Override\n-        public void close() throws IOException {\n-\n-        }\n-\n-        @Override\n-        public boolean isOpen() {\n-            return false;\n-        }\n-\n-        @Override\n-        public boolean isReadOnly() {\n-            return false;\n-        }\n-\n-        @Override\n-        public String getSeparator() {\n-            return null;\n-        }\n-\n-        @Override\n-        public Iterable<Path> getRootDirectories() {\n-            return null;\n-        }\n-\n-        @Override\n-        public Iterable<FileStore> getFileStores() {\n-            return null;\n-        }\n-\n-        @Override\n-        public Set<String> supportedFileAttributeViews() {\n-            return null;\n-        }\n-\n-        @Override\n-        public Path getPath(String first, String... more) {\n-            return null;\n-        }\n-\n-        @Override\n-        public PathMatcher getPathMatcher(String syntaxAndPattern) {\n-            return null;\n-        }\n-\n-        @Override\n-        public UserPrincipalLookupService getUserPrincipalLookupService() {\n-            return null;\n-        }\n-\n-        @Override\n-        public WatchService newWatchService() throws IOException {\n-            return null;\n-        }\n-    }\n-\n-    @Override\n-    public FileSystem getFileSystem() {\n-        return fs;\n-    }\n-\n-    @Override\n-    public boolean isAbsolute() {\n-        return false;\n-    }\n-\n-    @Override\n-    public Path getRoot() {\n-        return null;\n-    }\n-\n-    @Override\n-    public Path getFileName() {\n-        return null;\n-    }\n-\n-    @Override\n-    public Path getParent() {\n-        return null;\n-    }\n-\n-    @Override\n-    public int getNameCount() {\n-        return 0;\n-    }\n-\n-    @Override\n-    public Path getName(int index) {\n-        return null;\n-    }\n-\n-    @Override\n-    public Path subpath(int beginIndex, int endIndex) {\n-        return null;\n-    }\n-\n-    @Override\n-    public boolean startsWith(Path other) {\n-        return false;\n-    }\n-\n-    @Override\n-    public boolean endsWith(Path other) {\n-        return false;\n-    }\n-\n-    @Override\n-    public Path normalize() {\n-        return null;\n-    }\n-\n-    @Override\n-    public Path resolve(Path other) {\n-        return null;\n-    }\n-\n-    @Override\n-    public Path relativize(Path other) {\n-        return null;\n-    }\n-\n-    @Override\n-    public URI toUri() {\n-        return null;\n-    }\n-\n-    @Override\n-    public Path toAbsolutePath() {\n-        return null;\n-    }\n-\n-    @Override\n-    public Path toRealPath(LinkOption... options) throws IOException {\n-        return null;\n-    }\n-\n-    @Override\n-    public WatchKey register(WatchService watcher, WatchEvent.Kind<?>[] events, WatchEvent.Modifier... modifiers) throws IOException {\n-        return null;\n-    }\n-\n-    @Override\n-    public int compareTo(Path other) {\n-        return 0;\n-    }\n-}\n","filename":"test\/jdk\/java\/nio\/channels\/unixdomain\/DummyPath.java","additions":0,"deletions":187,"binary":false,"changes":187,"status":"deleted"},{"patch":"@@ -24,0 +24,6 @@\n+\/**\n+ * @test\n+ * @bug 8231358\n+ * @run testng\/othervm IOExchanges\n+ *\/\n+\n","filename":"test\/jdk\/java\/nio\/channels\/unixdomain\/IOExchanges.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -24,0 +24,6 @@\n+\/**\n+ * @test\n+ * @bug 8231358\n+ * @run main\/othervm NonBlockingAccept\n+ *\/\n+\n","filename":"test\/jdk\/java\/nio\/channels\/unixdomain\/NonBlockingAccept.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1,34 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @bug 8231358\n- * @requires os.family != \"windows\"\n- * @build Bind Shutdown NonBlockingAccept SocketOptions IOExchanges\n- * @run main\/othervm Bind\n- * @run main\/othervm Shutdown\n- * @run main\/othervm NonBlockingAccept\n- * @run main\/othervm SocketOptions\n- * @run testng\/othervm IOExchanges\n- *\/\n","filename":"test\/jdk\/java\/nio\/channels\/unixdomain\/NonWindowsDriver.java","additions":0,"deletions":34,"binary":false,"changes":34,"status":"deleted"},{"patch":"@@ -27,2 +27,2 @@\n- * @run main\/othervm Security policy1\n- * @run main\/othervm Security policy2\n+ * @run main\/othervm\/java.security.policy=policy1 Security policy1\n+ * @run main\/othervm\/java.security.policy=policy2 Security policy2\n@@ -84,10 +84,4 @@\n-        switch (policy) {\n-            case \"policy1\":\n-                setSecurityManager(policy);\n-                testPolicy1();\n-                break;\n-            case \"policy2\":\n-                setSecurityManager(policy);\n-                testPolicy2();\n-                break;\n-            default:\n+        if (policy.equals(\"policy1\")) {\n+            testPolicy1();\n+        } else {\n+            testPolicy2();\n@@ -95,10 +89,0 @@\n-\n-    }\n-\n-    static void setSecurityManager(String policy) {\n-        String testSrc = System.getProperty(\"test.src\");\n-        \/\/ Three \/\/\/ required for Windows below\n-        String policyURL = \"file:\/\/\/\" + testSrc + File.separator + policy;\n-        System.out.println(\"POLICY: \" + policyURL);\n-        System.setProperty(\"java.security.policy\", policyURL);\n-        System.setSecurityManager(new SecurityManager());\n","filename":"test\/jdk\/java\/nio\/channels\/unixdomain\/Security.java","additions":6,"deletions":22,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -24,0 +24,6 @@\n+\/**\n+ * @test\n+ * @bug 8231358\n+ * @run main\/othervm Shutdown\n+ *\/\n+\n","filename":"test\/jdk\/java\/nio\/channels\/unixdomain\/Shutdown.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -24,0 +24,6 @@\n+\/**\n+ * @test\n+ * @bug 8231358\n+ * @run main\/othervm SocketOptions\n+ *\/\n+\n","filename":"test\/jdk\/java\/nio\/channels\/unixdomain\/SocketOptions.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1,35 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @bug 8231358\n- * @requires os.family == \"windows\"\n- * @build Bind Shutdown NonBlockingAccept SocketOptions\n- * @run main\/othervm Bind\n- * @run main\/othervm Shutdown\n- * @run main\/othervm NonBlockingAccept\n- * @run main\/othervm SocketOptions\n- * @run testng\/othervm IOExchanges\n- *\/\n-\n","filename":"test\/jdk\/java\/nio\/channels\/unixdomain\/WindowsDriver.java","additions":0,"deletions":35,"binary":false,"changes":35,"status":"deleted"},{"patch":"@@ -269,1 +269,1 @@\n-            Class<?> clazz = Class.forName(\"sun.nio.ch.SocketChannelImpl\");\n+            Class<?> clazz = sc.getClass();\n","filename":"test\/jdk\/jdk\/nio\/Basic.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014 Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020 Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/net\/SocketChannelCompare.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019 Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020 Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/net\/SocketChannelConnectionSetup.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014 Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020 Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/net\/UnixSocketChannelReadWrite.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}