{"files":[{"patch":"@@ -185,4 +185,2 @@\n-$(eval $(call SetupCopyFiles, COPY_NET_PROPERTIES, \\\n-    FILES := $(TOPDIR)\/src\/java.base\/share\/conf\/net.properties, \\\n-    DEST := $(CONF_DST_DIR), \\\n-))\n+NET_PROPERTIES_SRCS := $(TOPDIR)\/src\/java.base\/share\/conf\/net.properties \\\n+\t$(TOPDIR)\/src\/java.base\/$(OPENJDK_TARGET_OS_TYPE)\/conf\/net.properties\n@@ -190,1 +188,7 @@\n-TARGETS += $(COPY_NET_PROPERTIES)\n+NET_PROPERTIES_DST  := $(CONF_DST_DIR)\/net.properties\n+\n+$(NET_PROPERTIES_DST): $(NET_PROPERTIES_SRCS)\n+\t$(call MakeTargetDir)\n+\t$(CAT) $(NET_PROPERTIES_SRCS) > $@\n+\n+TARGETS += $(NET_PROPERTIES_DST)\n","filename":"make\/modules\/java.base\/Copy.gmk","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -69,0 +69,10 @@\n+ *   <th scope=\"row\">accessUnixDomainSocket<\/th>\n+ *   <td>The ability to accept, bind, connect or get the local address\n+ *   of a <i>Unix Domain<\/i> socket.\n+ *   <\/td>\n+ *   <td>Malicious code could connect to local processes using Unix domain sockets\n+ *    or impersonate local processes, by binding to the same pathnames (assuming they\n+ *    have the required Operating System permissions.<\/td>\n+ * <\/tr>\n+ *\n+ * <tr>\n","filename":"src\/java.base\/share\/classes\/java\/net\/NetPermission.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2009, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,7 @@\n-    INET6\n+    INET6,\n+\n+    \/**\n+     * Unix domain (Local) interprocess communication.\n+     * @since 16\n+     *\/\n+    UNIX\n","filename":"src\/java.base\/share\/classes\/java\/net\/StandardProtocolFamily.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,211 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.net;\n+\n+import java.io.ObjectStreamException;\n+import java.io.Serializable;\n+import java.net.SocketAddress;\n+import java.nio.channels.SocketChannel;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n+import java.nio.file.InvalidPathException;\n+import java.nio.file.Path;\n+\n+\/**\n+ * A <a href=\"package-summary.html#unixdomain\">Unix domain<\/a> socket address.\n+ * A Unix domain socket address encapsulates a file-system path that Unix domain sockets\n+ * bind or connect to.\n+ *\n+ * <p> An <a id=\"unnamed\"><\/a><i>unnamed<\/i> {@code UnixDomainSocketAddress} has\n+ * an empty path. The local address of a {@link SocketChannel} to a Unix domain socket\n+ * that is <i>automatically<\/i> or <i>implicitly<\/i> bound will be unnamed.\n+ *\n+ * <p> {@link Path} objects used to create instances of this class must be obtained\n+ * from the {@linkplain FileSystems#getDefault system-default} file system.\n+ *\n+ * @see java.nio.channels.SocketChannel\n+ * @see java.nio.channels.ServerSocketChannel\n+ * @since 16\n+ *\/\n+public final class UnixDomainSocketAddress extends SocketAddress {\n+    @java.io.Serial\n+    static final long serialVersionUID = 92902496589351288L;\n+\n+    private final transient Path path;\n+\n+    \/**\n+     * A serial proxy for all {@link UnixDomainSocketAddress} instances.\n+     * It captures the file path name and reconstructs using the public static\n+     * {@link #of(String) factory}.\n+     *\n+     * @serial include\n+     *\/\n+    private static final class Ser implements Serializable {\n+        @java.io.Serial\n+        static final long serialVersionUID = -7955684448513979814L;\n+\n+        \/**\n+         * The path name.\n+         * @serial\n+         *\/\n+        private final String pathname;\n+\n+        Ser(String pathname) {\n+            this.pathname = pathname;\n+        }\n+\n+        \/**\n+         * Creates a {@link UnixDomainSocketAddress} instance, by an invocation\n+         * of the {@link #of(String) factory} method passing the path name.\n+         * @return a UnixDomainSocketAddress\n+         *\/\n+        @java.io.Serial\n+        private Object readResolve() {\n+            return UnixDomainSocketAddress.of(pathname);\n+        }\n+    }\n+\n+    \/**\n+     * Returns a\n+     * <a href=\"{@docRoot}\/serialized-form.html#java.net.UnixDomainSocketAddress.Ser\">\n+     * Ser<\/a> containing the path name of this instance.\n+     *\n+     * @return a {@link Ser}\n+     * representing the path name of this instance\n+     *\/\n+    @java.io.Serial\n+    private Object writeReplace() throws ObjectStreamException {\n+        return new Ser(path.toString());\n+    }\n+\n+    \/**\n+     * Throws InvalidObjectException, always.\n+     * @param s the stream\n+     * @throws java.io.InvalidObjectException always\n+     *\/\n+    @java.io.Serial\n+    private void readObject(java.io.ObjectInputStream s)\n+        throws java.io.InvalidObjectException\n+    {\n+        throw new java.io.InvalidObjectException(\"Proxy required\");\n+    }\n+\n+    \/**\n+     * Throws InvalidObjectException, always.\n+     * @throws java.io.InvalidObjectException always\n+     *\/\n+    @java.io.Serial\n+    private void readObjectNoData()\n+        throws java.io.InvalidObjectException\n+    {\n+        throw new java.io.InvalidObjectException(\"Proxy required\");\n+    }\n+\n+    private UnixDomainSocketAddress(Path path) {\n+        this.path = path;\n+    }\n+\n+    \/**\n+     * Creates a UnixDomainSocketAddress from the given path string.\n+     *\n+     * @param  pathname\n+     *         The path string, which can be empty\n+     *\n+     * @return A UnixDomainSocketAddress\n+     *\n+     * @throws InvalidPathException\n+     *         If the path cannot be converted to a Path\n+     *\n+     * @throws NullPointerException if pathname is {@code null}\n+     *\/\n+    public static UnixDomainSocketAddress of(String pathname) {\n+        return of(Path.of(pathname));\n+    }\n+\n+    \/**\n+     * Creates a UnixDomainSocketAddress for the given path.\n+     *\n+     * @param  path\n+     *         The path to the socket, which can be empty\n+     *\n+     * @return A UnixDomainSocketAddress\n+     *\n+     * @throws IllegalArgumentException\n+     *         If the path is not associated with the default file system\n+     *\n+     * @throws NullPointerException if path is {@code null}\n+     *\/\n+    public static UnixDomainSocketAddress of(Path path) {\n+        FileSystem fs = path.getFileSystem();\n+        if (fs != FileSystems.getDefault()) {\n+            throw new IllegalArgumentException();\n+        }\n+        if (fs.getClass().getModule() != Object.class.getModule()) {\n+            throw new IllegalArgumentException();\n+        }\n+        return new UnixDomainSocketAddress(path);\n+    }\n+\n+    \/**\n+     * Returns this address's path.\n+     *\n+     * @return this address's path\n+     *\/\n+    public Path getPath() {\n+        return path;\n+    }\n+\n+    \/**\n+     * Returns the hash code of this {@code UnixDomainSocketAddress}\n+     *\/\n+    @Override\n+    public int hashCode() {\n+        return path.hashCode();\n+    }\n+\n+    \/**\n+     * Compares this address with another object.\n+     *\n+     * @return true if the path fields are equal\n+     *\/\n+    @Override\n+    public boolean equals(Object o) {\n+        if (!(o instanceof UnixDomainSocketAddress))\n+            return false;\n+        UnixDomainSocketAddress that = (UnixDomainSocketAddress)o;\n+        return this.path.equals(that.path);\n+    }\n+\n+    \/**\n+     * Returns a string representation of this {@code UnixDomainSocketAddress}.\n+     *\n+     * @return this address's path which may be empty for an unnamed address\n+     *\/\n+    @Override\n+    public String toString() {\n+        return path.toString();\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/net\/UnixDomainSocketAddress.java","additions":211,"deletions":0,"binary":false,"changes":211,"status":"added"},{"patch":"@@ -153,0 +153,3 @@\n+     *\n+     * @see     <a href=\"..\/..\/net\/doc-files\/net-properties.html#Ipv4IPv6\">\n+     *          java.net.preferIPv4Stack<\/a> system property\n@@ -172,0 +175,3 @@\n+     * @apiNote <a href=\"package-summary.html#unixdomain\">Unix domain<\/a> sockets\n+     * are not supported by DatagramChannel.\n+     *\n@@ -185,0 +191,3 @@\n+     * @see     <a href=\"..\/..\/net\/doc-files\/net-properties.html#Ipv4IPv6\">\n+     *          java.net.preferIPv4Stack<\/a> system property\n+     *\n@@ -632,1 +641,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/java\/nio\/channels\/DatagramChannel.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import java.net.NetPermission;\n@@ -33,0 +34,1 @@\n+import java.net.UnixDomainSocketAddress;\n@@ -40,5 +42,8 @@\n- * <p> A server-socket channel is created by invoking the {@link #open() open}\n- * method of this class.  It is not possible to create a channel for an arbitrary,\n- * pre-existing {@link ServerSocket}. A newly-created server-socket channel is\n- * open but not yet bound.  An attempt to invoke the {@link #accept() accept}\n- * method of an unbound server-socket channel will cause a {@link NotYetBoundException}\n+ * <p> A server-socket channel is created by invoking one of the {@code open}\n+ * methods of this class. The no-arg {@link #open() open} method opens a server-socket\n+ * channel for an <i>Internet protocol<\/i> socket. The {@link #open(ProtocolFamily)}\n+ * method is used to open a server-socket channel for a socket of a specified\n+ * protocol family. It is not possible to create a channel for an arbitrary,\n+ * pre-existing socket. A newly-created server-socket channel is open but not yet\n+ * bound. An attempt to invoke the {@link #accept() accept} method of an\n+ * unbound server-socket channel will cause a {@link NotYetBoundException}\n@@ -46,1 +51,1 @@\n- * {@link #bind(java.net.SocketAddress,int) bind} methods defined by this class.\n+ * {@link #bind(java.net.SocketAddress, int) bind} methods defined by this class.\n@@ -49,1 +54,2 @@\n- * setOption} method. Server-socket channels support the following options:\n+ * setOption} method. Server-socket channels for <i>Internet protocol<\/i> sockets\n+ * support the following options:\n@@ -71,1 +77,21 @@\n- * Additional (implementation specific) options may also be supported.\n+ *\n+ * <p> Server-socket channels for <i>Unix domain<\/i> sockets support:\n+ * <blockquote>\n+ * <table class=\"striped\">\n+ * <caption style=\"display:none\">Socket options<\/caption>\n+ * <thead>\n+ *   <tr>\n+ *     <th scope=\"col\">Option Name<\/th>\n+ *     <th scope=\"col\">Description<\/th>\n+ *   <\/tr>\n+ * <\/thead>\n+ * <tbody>\n+ *   <tr>\n+ *     <th scope=\"row\"> {@link java.net.StandardSocketOptions#SO_RCVBUF SO_RCVBUF} <\/th>\n+ *     <td> The size of the socket receive buffer <\/td>\n+ *   <\/tr>\n+ * <\/tbody>\n+ * <\/table>\n+ * <\/blockquote>\n+ *\n+ * <p> Additional (implementation specific) options may also be supported.\n@@ -97,1 +123,1 @@\n-     * Opens a server-socket channel.\n+     * Opens a server-socket channel for an <i>Internet protocol<\/i> socket.\n@@ -113,0 +139,3 @@\n+     *\n+     * @see     <a href=\"..\/..\/net\/doc-files\/net-properties.html#Ipv4IPv6\">\n+     *          java.net.preferIPv4Stack<\/a> system property\n@@ -119,1 +148,1 @@\n-     * Opens a server-socket channel.The {@code family} parameter specifies the\n+     * Opens a server-socket channel. The {@code family} parameter specifies the\n@@ -140,0 +169,3 @@\n+     * @see     <a href=\"..\/..\/net\/doc-files\/net-properties.html#Ipv4IPv6\">\n+     *          java.net.preferIPv4Stack<\/a> system property\n+     *\n@@ -183,2 +215,1 @@\n-     *          If a security manager has been installed and its {@link\n-     *          SecurityManager#checkListen checkListen} method denies the\n+     *          If a security manager has been installed and it denies the\n@@ -200,2 +231,2 @@\n-     * a local address. Once an association is established then the socket remains\n-     * bound until the channel is closed.\n+     * a local address. For <i>Internet protocol<\/i> sockets, once an association\n+     * is established then the socket remains bound until the channel is closed.\n@@ -210,0 +241,16 @@\n+     * @apiNote\n+     * Binding a server socket channel for a <i>Unix Domain<\/i> socket, creates a\n+     * file corresponding to the file path in the {@link UnixDomainSocketAddress}.\n+     * This file persists after the channel is closed, and must be removed before\n+     * another socket can bind to the same name. Binding to a {@code null} address\n+     * causes the socket to be <i>automatically<\/i> bound to some unique file\n+     * in a system temporary location. The associated socket file also persists\n+     * after the channel is closed. Its name can be obtained from the channel's\n+     * local socket address.\n+     *\n+     * @implNote\n+     * Each platform enforces an implementation specific, maximum length for the\n+     * name of a <i>Unix Domain<\/i> socket. This limitation is enforced when a\n+     * channel is bound. The maximum length is typically close to and generally\n+     * not less than 100 bytes.\n+     *\n@@ -211,2 +258,2 @@\n-     *          The address to bind the socket, or {@code null} to bind to an\n-     *          automatically assigned socket address\n+     *          The address to bind the socket, or {@code null} to bind to\n+     *          an automatically assigned socket address\n@@ -228,2 +275,4 @@\n-     *          SecurityManager#checkListen checkListen} method denies the\n-     *          operation\n+     *          SecurityManager#checkListen checkListen} method denies\n+     *          the operation for an <i>Internet protocol<\/i> socket address,\n+     *          or for a <i>Unix domain<\/i> socket address if it denies\n+     *          {@link NetPermission}{@code(\"accessUnixDomainSocket\")}.\n@@ -254,0 +303,3 @@\n+     *\n+     * @throws  UnsupportedOperationException\n+     *          If the channel's socket is not an <i>Internet protocol<\/i> socket\n@@ -268,7 +320,9 @@\n-     * <p> This method performs exactly the same security checks as the {@link\n-     * java.net.ServerSocket#accept accept} method of the {@link\n-     * java.net.ServerSocket} class.  That is, if a security manager has been\n-     * installed then for each new connection this method verifies that the\n-     * address and port number of the connection's remote endpoint are\n-     * permitted by the security manager's {@link\n-     * java.lang.SecurityManager#checkAccept checkAccept} method.  <\/p>\n+     * <p> If bound to an <i>Internet protocol<\/i> socket address, this method\n+     * performs exactly the same security checks as the {@link\n+     * java.net.ServerSocket#accept accept} method of the {@link java.net.ServerSocket}\n+     * class.  That is, if a security manager has been installed then for each\n+     * new connection this method verifies that the address and port number\n+     * of the connection's remote endpoint are permitted by the security\n+     * manager's {@link java.lang.SecurityManager#checkAccept checkAccept}\n+     * method. If bound to a <i>Unix Domain<\/i> socket address, this method checks\n+     * {@link NetPermission}{@code (\"accessUnixDomainSocket\")}.\n@@ -308,1 +362,1 @@\n-     * <p>\n+     *\n@@ -316,0 +370,7 @@\n+     * <p> Where the channel is bound to a <i>Unix Domain<\/i> socket address, the socket\n+     * address is a {@link UnixDomainSocketAddress}. If there is a security manager\n+     * set, its {@link SecurityManager#checkPermission(java.security.Permission)\n+     * checkPermission} method is called with {@link NetPermission}{@code\n+     * (\"accessUnixDomainSocket\")}. If the operation is not allowed an unnamed\n+     * {@link UnixDomainSocketAddress} is returned.\n+     *\n@@ -317,2 +378,2 @@\n-     *          {@code SocketAddress} representing the loopback address if\n-     *          denied by the security manager, or {@code null} if the\n+     *          {@code SocketAddress} representing the loopback address or empty\n+     *          path if denied by the security manager, or {@code null} if the\n@@ -326,1 +387,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/java\/nio\/channels\/ServerSocketChannel.java","additions":89,"deletions":29,"binary":false,"changes":118,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+import java.net.InetSocketAddress;\n+import java.net.NetPermission;\n@@ -30,0 +32,1 @@\n+import java.net.StandardProtocolFamily;\n@@ -33,0 +36,1 @@\n+import java.net.UnixDomainSocketAddress;\n@@ -41,9 +45,12 @@\n- * <p> A socket channel is created by invoking one of the {@link #open open}\n- * methods of this class.  It is not possible to create a channel for an arbitrary,\n- * pre-existing socket. A newly-created socket channel is open but not yet\n- * connected.  An attempt to invoke an I\/O operation upon an unconnected\n- * channel will cause a {@link NotYetConnectedException} to be thrown.  A\n- * socket channel can be connected by invoking its {@link #connect connect}\n- * method; once connected, a socket channel remains connected until it is\n- * closed.  Whether or not a socket channel is connected may be determined by\n- * invoking its {@link #isConnected isConnected} method.\n+ * <p> A socket channel is created by invoking one of the {@code open} methods of\n+ * this class. The no-arg {@link #open() open} method opens a socket channel\n+ * for an <i>Internet protocol<\/i> socket. The {@link #open(ProtocolFamily)}\n+ * method is used to open a socket channel for a socket of a specified protocol\n+ * family. It is not possible to create a channel for an arbitrary, pre-existing\n+ * socket. A newly-created socket channel is open but not yet connected.  An\n+ * attempt to invoke an I\/O operation upon an unconnected channel will cause a\n+ * {@link NotYetConnectedException} to be thrown.  A socket channel can be\n+ * connected by invoking its {@link #connect connect} method; once connected,\n+ * a socket channel remains connected until it is closed.  Whether or not a\n+ * socket channel is connected may be determined by invoking its {@link #isConnected()\n+ * isConnected} method.\n@@ -58,1 +65,1 @@\n- * <p> Socket channels support <i>asynchronous shutdown,<\/i> which is similar\n+ * <p> Socket channels support <i>asynchronous shutdown<\/i>, which is similar\n@@ -69,1 +76,2 @@\n- * setOption} method. Socket channels support the following options:\n+ * setOption} method. Socket channels for  <i>Internet protocol<\/i> sockets support\n+ * following options:\n@@ -108,1 +116,30 @@\n- * Additional (implementation specific) options may also be supported.\n+ *\n+ * <p> Socket channels for <i>Unix domain<\/i> sockets support:\n+ * <blockquote>\n+ * <table class=\"striped\">\n+ * <caption style=\"display:none\">Socket options<\/caption>\n+ * <thead>\n+ *   <tr>\n+ *     <th scope=\"col\">Option Name<\/th>\n+ *     <th scope=\"col\">Description<\/th>\n+ *   <\/tr>\n+ * <\/thead>\n+ * <tbody>\n+ *   <tr>\n+ *     <th scope=\"row\"> {@link java.net.StandardSocketOptions#SO_SNDBUF SO_SNDBUF} <\/th>\n+ *     <td> The size of the socket send buffer <\/td>\n+ *   <\/tr>\n+ *   <tr>\n+ *     <th scope=\"row\"> {@link java.net.StandardSocketOptions#SO_RCVBUF SO_RCVBUF} <\/th>\n+ *     <td> The size of the socket receive buffer <\/td>\n+ *   <\/tr>\n+ *   <tr>\n+ *     <th scope=\"row\"> {@link java.net.StandardSocketOptions#SO_LINGER SO_LINGER} <\/th>\n+ *     <td> Linger on close if data is present (when configured in blocking mode\n+ *          only) <\/td>\n+ *   <\/tr>\n+ * <\/tbody>\n+ * <\/table>\n+ * <\/blockquote>\n+ *\n+ * <p> Additional (implementation specific) options may also be supported.\n@@ -139,1 +176,1 @@\n-     * Opens a socket channel.\n+     * Opens a socket channel for an <i>Internet protocol<\/i> socket.\n@@ -150,0 +187,3 @@\n+     *\n+     * @see     <a href=\"..\/..\/net\/doc-files\/net-properties.html#Ipv4IPv6\">\n+     *          java.net.preferIPv4Stack<\/a> system property\n@@ -177,0 +217,3 @@\n+     * @see     <a href=\"..\/..\/net\/doc-files\/net-properties.html#Ipv4IPv6\">\n+     *          java.net.preferIPv4Stack<\/a> system property\n+     *\n@@ -186,4 +229,10 @@\n-     * <p> This convenience method works as if by invoking the {@link #open()}\n-     * method, invoking the {@link #connect(SocketAddress) connect} method upon\n-     * the resulting socket channel, passing it {@code remote}, and then\n-     * returning that channel.  <\/p>\n+     * <p> If the remote address is an {@link InetSocketAddress} then this\n+     * method works as if by invoking the {@link #open()} method, invoking the\n+     * {@link #connect(SocketAddress) connect} method upon the resulting socket\n+     * channel, passing it {@code remote}, and then returning that channel.\n+     *\n+     * <p> If the remote address is a {@link UnixDomainSocketAddress} then this\n+     * works by invoking the {@link #open(ProtocolFamily)} method with {@link\n+     * StandardProtocolFamily#UNIX} as parameter, invoking the {@link\n+     * #connect(SocketAddress) connect} method upon the resulting socket channel,\n+     * passing it {@code remote}, then returning that channel.  <\/p>\n@@ -207,1 +256,2 @@\n-     *          If the given remote address is not fully resolved\n+     *          If the given remote address is an InetSocketAddress that is not fully\n+     *          resolved\n@@ -218,0 +268,3 @@\n+     *\n+     * @see     <a href=\"..\/..\/net\/doc-files\/net-properties.html#Ipv4IPv6\">\n+     *          java.net.preferIPv4Stack<\/a> system property\n@@ -222,1 +275,9 @@\n-        SocketChannel sc = open();\n+        SocketChannel sc;\n+        requireNonNull(remote);\n+        if (remote instanceof InetSocketAddress)\n+            sc = open();\n+        else if (remote instanceof UnixDomainSocketAddress)\n+            sc = open(StandardProtocolFamily.UNIX);\n+        else\n+            throw new UnsupportedAddressTypeException();\n+\n@@ -258,0 +319,32 @@\n+     * Binds the channel's socket to a local address.\n+     *\n+     * <p> This method is used to establish an association between the socket\n+     * and a local address. For <i>Internet Protocol<\/i> sockets, once an\n+     * association is established then the socket remains bound until the\n+     * channel is closed. If the {@code local} parameter has the value {@code\n+     * null} then the socket will be bound to an address that is assigned\n+     * automatically.\n+     *\n+     * @apiNote\n+     * Binding a socket channel to a <i>Unix Domain<\/i> socket creates a file\n+     * corresponding to the file path in the {@link UnixDomainSocketAddress}. This\n+     * file persists after the channel is closed, and must be removed before\n+     * another socket can bind to the same name. If a socket channel to a Unix\n+     * Domain socket is <i>implicitly<\/i> bound by connecting it without calling\n+     * bind first, then its socket is\n+     * <a href=\"..\/..\/java\/net\/UnixDomainSocketAddress.html#unnamed\">unnamed<\/a>\n+     * with no corresponding socket file in the file-system. If a socket channel\n+     * to a Unix Domain socket is <i>automatically<\/i> bound by calling {@code\n+     * bind(null)} this results in an unnamed socket also.\n+     *\n+     * @implNote\n+     * Each platform enforces an implementation specific maximum length for the\n+     * name of a <i>Unix Domain<\/i> socket. This limitation is enforced when a\n+     * channel is bound. The maximum length is typically close to and generally\n+     * not less than 100 bytes.\n+     *\n+     * @param   local The address to bind the socket, or {@code null} to bind\n+     *          the socket to an automatically assigned socket address\n+     *\n+     * @return  This channel\n+     *\n@@ -266,3 +359,5 @@\n-     *          If a security manager has been installed and its\n-     *          {@link SecurityManager#checkListen checkListen} method denies\n-     *          the operation\n+     *          If a security manager has been installed and its {@link\n+     *          SecurityManager#checkListen checkListen} method denies\n+     *          the operation for an <i>Internet protocol<\/i> socket address,\n+     *          or for a <i>Unix domain<\/i> socket address if it denies\n+     *          {@link NetPermission}{@code(\"accessUnixDomainSocket\")}.\n@@ -332,3 +427,0 @@\n-     * <p> The returned object will not declare any public methods that are not\n-     * declared in the {@link java.net.Socket} class.  <\/p>\n-     *\n@@ -336,0 +428,3 @@\n+     *\n+     * @throws  UnsupportedOperationException\n+     *          If the channel's socket is not an <i>Internet protocol<\/i> socket\n@@ -371,2 +466,3 @@\n-     * <p> This method performs exactly the same security checks as the {@link\n-     * java.net.Socket} class.  That is, if a security manager has been\n+     * <p> For channels to <i>Internet protocol<\/i> sockets, this method performs\n+     * exactly the same security checks as the {@link java.net.Socket} class.\n+     * That is, if a security manager has been\n@@ -377,0 +473,6 @@\n+     * <p> For channels to <i>Unix Domain<\/i> sockets, this method checks\n+     * {@link java.net.NetPermission NetPermission}{@code\n+     * (\"accessUnixDomainSocket\")} with the security manager's {@link\n+     * SecurityManager#checkPermission(java.security.Permission)\n+     * checkPermission} method.\n+     *\n@@ -412,1 +514,1 @@\n-     *          If the given remote address is not fully resolved\n+     *          If the given remote address is an InetSocketAddress that is not fully resolved\n@@ -480,3 +582,6 @@\n-     * <p> Where the channel is bound and connected to an Internet Protocol\n-     * socket address then the return value from this method is of type {@link\n-     * java.net.InetSocketAddress}.\n+     * <p> Where the channel's socket is bound and connected to an <i>Internet\n+     * Protocol<\/i> socket address then the return value is of type\n+     * {@link java.net.InetSocketAddress}.\n+     *\n+     * <p> Where the channel's socket is bound and connected to a <i>Unix Domain<\/i>\n+     * socket address, the returned address is a {@link UnixDomainSocketAddress}.\n@@ -542,1 +647,1 @@\n-     * <p>\n+     *\n@@ -550,0 +655,7 @@\n+     * <p> Where the channel is bound to a Unix Domain socket address, the socket\n+     * address is a {@link UnixDomainSocketAddress}. If there is a security manager\n+     * set, its {@link SecurityManager#checkPermission(java.security.Permission)\n+     * checkPermission} method is called with {@link NetPermission}{@code\n+     * (\"accessUnixDomainSocket\")}. If the operation is not allowed an unnamed\n+     * {@link UnixDomainSocketAddress} is returned.\n+     *\n@@ -551,2 +663,2 @@\n-     *          {@code SocketAddress} representing the loopback address if\n-     *          denied by the security manager, or {@code null} if the\n+     *          {@code SocketAddress} representing the loopback address or empty\n+     *          path if denied by the security manager, or {@code null} if the\n@@ -560,1 +672,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/java\/nio\/channels\/SocketChannel.java","additions":146,"deletions":35,"binary":false,"changes":181,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -244,0 +244,22 @@\n+ * <p> {@link java.nio.channels.DatagramChannel},\n+ * {@link java.nio.channels.SocketChannel} and\n+ * {@link java.nio.channels.ServerSocketChannel}s can be created\n+ * with different {@link java.net.ProtocolFamily protocol families}. The standard\n+ * family types are specified in {@link java.net.StandardProtocolFamily}.\n+ *\n+ * <p> Channels for <i>Internet Protocol<\/i> sockets are created using the\n+ * {@link java.net.StandardProtocolFamily#INET INET} or {@link\n+ * java.net.StandardProtocolFamily#INET6 INET6} protocol families. <i>Internet\n+ * Protocol<\/i> sockets support network communication using TCP and UDP and are\n+ * addressed using {@link java.net.InetSocketAddress}es which encapsulate an IP\n+ * address and port number. <i>Internet Protocol<\/i> sockets are also the default\n+ * type created, when a protocol family is not specified in the channel factory\n+ * creation method.\n+ *\n+ * <p> Channels for <a id=\"unixdomain\"><\/a><i>Unix Domain<\/i> sockets are created\n+ * using the {@link java.net.StandardProtocolFamily#UNIX UNIX} protocol family.\n+ * <i>Unix Domain<\/i> sockets support local inter-process\n+ * communication on the same host, and are addressed using {@link\n+ * java.net.UnixDomainSocketAddress}es which encapsulate a filesystem pathname\n+ * on the local system.\n+ *\n","filename":"src\/java.base\/share\/classes\/java\/nio\/channels\/package-info.java","additions":23,"deletions":1,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -271,2 +271,2 @@\n-     * <p> In cases where the inherited channel represents a network socket\n-     * then the {@link java.nio.channels.Channel Channel} type returned\n+     * <p> In cases where the inherited channel is for an <i>Internet protocol<\/i>\n+     * socket then the {@link Channel Channel} type returned\n@@ -277,4 +277,4 @@\n-     *  <li><p> If the inherited channel represents a stream-oriented connected\n-     *  socket then a {@link java.nio.channels.SocketChannel SocketChannel} is\n-     *  returned. The socket channel is, at least initially, in blocking\n-     *  mode, bound to a socket address, and connected to a peer.\n+     *  <li><p> If the inherited channel is for a stream-oriented connected\n+     *  socket then a {@link SocketChannel SocketChannel} is returned. The\n+     *  socket channel is, at least initially, in blocking mode, bound\n+     *  to a socket address, and connected to a peer.\n@@ -283,4 +283,4 @@\n-     *  <li><p> If the inherited channel represents a stream-oriented listening\n-     *  socket then a {@link java.nio.channels.ServerSocketChannel\n-     *  ServerSocketChannel} is returned. The server-socket channel is, at\n-     *  least initially, in blocking mode, and bound to a socket address.\n+     *  <li><p> If the inherited channel is for a stream-oriented listening\n+     *  socket then a {@link ServerSocketChannel ServerSocketChannel} is returned.\n+     *  The server-socket channel is, at least initially, in blocking mode,\n+     *  and bound to a socket address.\n@@ -289,4 +289,3 @@\n-     *  <li><p> If the inherited channel is a datagram-oriented socket\n-     *  then a {@link java.nio.channels.DatagramChannel DatagramChannel} is\n-     *  returned. The datagram channel is, at least initially, in blocking\n-     *  mode, and bound to a socket address.\n+     *  <li><p> If the inherited channel is a datagram-oriented socket then a\n+     *  {@link DatagramChannel DatagramChannel} is returned. The datagram channel\n+     *  is, at least initially, in blocking mode, and bound to a socket address.\n@@ -297,2 +296,7 @@\n-     * <p> In addition to the network-oriented channels described, this method\n-     * may return other kinds of channels in the future.\n+     * <p> In cases where the inherited channel is for a <i>Unix domain<\/i>\n+     * socket then the {@link Channel} type returned is the same as for\n+     * <i>Internet protocol<\/i> sockets as described above, except that\n+     * datagram-oriented sockets are not supported.\n+     *\n+     * <p> In addition to the two types of socket just described, this method\n+     * may return other types in the future.\n","filename":"src\/java.base\/share\/classes\/java\/nio\/channels\/spi\/SelectorProvider.java","additions":20,"deletions":16,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,2 +36,1 @@\n-import sun.security.action.GetPropertyAction;\n-\n+import jdk.internal.util.StaticProperty;\n@@ -48,2 +47,1 @@\n-    private static final Path tmpdir =\n-        Path.of(GetPropertyAction.privilegedGetProperty(\"java.io.tmpdir\"));\n+    private static final Path tmpdir = Path.of(StaticProperty.javaIoTmpDir());\n","filename":"src\/java.base\/share\/classes\/java\/nio\/file\/TempFileHelper.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+    private static final String JAVA_IO_TMPDIR;\n@@ -59,0 +60,1 @@\n+        JAVA_IO_TMPDIR = getProperty(props, \"java.io.tmpdir\");\n@@ -143,0 +145,13 @@\n+    \/**\n+     * Return the {@code java.io.tmpdir} system property.\n+     *\n+     * <strong>{@link SecurityManager#checkPropertyAccess} is NOT checked\n+     * in this method. The caller of this method should take care to ensure\n+     * that the returned property is not made accessible to untrusted code.<\/strong>\n+     *\n+     * @return the {@code java.io.tmpdir} system property\n+     *\/\n+    public static String javaIoTmpDir() {\n+        return JAVA_IO_TMPDIR;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/StaticProperty.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -273,0 +273,2 @@\n+    exports sun.nio.fs to\n+        jdk.net;\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,0 +51,1 @@\n+    private final Set<SocketOption<?>> unixDomainClientOptions;\n@@ -76,0 +77,13 @@\n+    \/**\n+     * Return the, possibly empty, set of extended socket options available for\n+     * Unix domain client sockets. Note, there are no extended\n+     * Unix domain server options.\n+     *\/\n+    private final Set<SocketOption<?>> unixDomainClientOptions() {\n+        return unixDomainClientOptions;\n+    }\n+\n+    public static Set<SocketOption<?>> unixDomainSocketOptions() {\n+        return getInstance().unixDomainClientOptions();\n+    }\n+\n@@ -85,1 +99,9 @@\n-        return !option.name().startsWith(\"TCP_\");\n+        if (option.name().startsWith(\"TCP_\") || isUnixDomainOption(option)) {\n+            return false;\n+        } else {\n+            return true;\n+        }\n+    }\n+\n+    private static boolean isUnixDomainOption(SocketOption<?> option) {\n+        return option.name().equals(\"SO_PEERCRED\");\n@@ -89,1 +111,1 @@\n-        if (server && \"SO_FLOW_SLA\".equals(option.name())) {\n+        if (option.name().startsWith(\"UDP_\") || isUnixDomainOption(option)) {\n@@ -92,1 +114,1 @@\n-            return !option.name().startsWith(\"UDP_\");\n+            return true;\n@@ -125,0 +147,1 @@\n+        var unixDomainClientOptions = new HashSet<SocketOption<?>>();\n@@ -135,0 +158,3 @@\n+            if (isUnixDomainOption(option)) {\n+                unixDomainClientOptions.add(option);\n+            }\n@@ -139,0 +165,1 @@\n+        this.unixDomainClientOptions = Set.copyOf(unixDomainClientOptions);\n","filename":"src\/java.base\/share\/classes\/sun\/net\/ext\/ExtendedSocketOptions.java","additions":31,"deletions":4,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,2 @@\n+import java.net.UnixDomainSocketAddress;\n+import java.net.SocketAddress;\n@@ -54,2 +56,2 @@\n-    public static IOException of(IOException e, InetSocketAddress address) {\n-        if (!enhancedExceptionText || address == null)\n+    public static IOException of(IOException e, SocketAddress addr) {\n+        if (!enhancedExceptionText || addr == null) {\n@@ -57,2 +59,13 @@\n-        int port = address.getPort();\n-        String host = address.getHostString();\n+        }\n+        if (addr instanceof UnixDomainSocketAddress) {\n+            return ofUnixDomain(e, (UnixDomainSocketAddress)addr);\n+        } else if (addr instanceof InetSocketAddress) {\n+            return ofInet(e, (InetSocketAddress)addr);\n+        } else {\n+            return e;\n+        }\n+    }\n+\n+    private static IOException ofInet(IOException e, InetSocketAddress addr) {\n+        int port = addr.getPort();\n+        String host = addr.getHostString();\n@@ -69,0 +82,10 @@\n+    private static IOException ofUnixDomain(IOException e, UnixDomainSocketAddress addr) {\n+        String path = addr.getPath().toString();\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(e.getMessage());\n+        sb.append(\": \");\n+        sb.append(path);\n+        String enhancedMsg = sb.toString();\n+        return create(e, enhancedMsg);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/net\/util\/SocketExceptions.java","additions":28,"deletions":5,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -229,1 +229,2 @@\n-    static InetSocketAddress getRevealedLocalAddress(InetSocketAddress addr) {\n+    static InetSocketAddress getRevealedLocalAddress(SocketAddress sa) {\n+        InetSocketAddress isa = (InetSocketAddress) sa;\n@@ -231,9 +232,7 @@\n-        if (addr == null || sm == null)\n-            return addr;\n-\n-        try{\n-            sm.checkConnect(addr.getAddress().getHostAddress(), -1);\n-            \/\/ Security check passed\n-        } catch (SecurityException e) {\n-            \/\/ Return loopback address only if security check fails\n-            addr = getLoopbackAddress(addr.getPort());\n+        if (isa != null && sm != null) {\n+            try {\n+                sm.checkConnect(isa.getAddress().getHostAddress(), -1);\n+            } catch (SecurityException e) {\n+                \/\/ Return loopback address only if security check fails\n+                isa = getLoopbackAddress(isa.getPort());\n+            }\n@@ -241,1 +240,1 @@\n-        return addr;\n+        return isa;\n@@ -244,3 +243,7 @@\n-    static String getRevealedLocalAddressAsString(InetSocketAddress addr) {\n-        return System.getSecurityManager() == null ? addr.toString() :\n-                getLoopbackAddress(addr.getPort()).toString();\n+    static String getRevealedLocalAddressAsString(SocketAddress sa) {\n+        InetSocketAddress isa = (InetSocketAddress) sa;\n+        if (System.getSecurityManager() == null) {\n+            return isa.toString();\n+        } else {\n+            return getLoopbackAddress(isa.getPort()).toString();\n+        }\n@@ -250,2 +253,1 @@\n-        return new InetSocketAddress(InetAddress.getLoopbackAddress(),\n-                                     port);\n+        return new InetSocketAddress(InetAddress.getLoopbackAddress(), port);\n@@ -577,0 +579,7 @@\n+    static int connect(ProtocolFamily family, FileDescriptor fd, SocketAddress remote)\n+        throws IOException\n+    {\n+        InetSocketAddress isa = (InetSocketAddress) remote;\n+        return connect(family, fd, isa.getAddress(), isa.getPort());\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/Net.java","additions":25,"deletions":16,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -1,63 +0,0 @@\n-\/*\n- * Copyright (c) 2010, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.nio.ch;\n-\n-import java.nio.channels.SocketChannel;\n-import java.nio.channels.ServerSocketChannel;\n-import java.nio.channels.spi.SelectorProvider;\n-import java.io.FileDescriptor;\n-import java.io.IOException;\n-\n-\/**\n- * Provides access to implementation private constructors and methods.\n- *\/\n-\n-public final class Secrets {\n-    private Secrets() { }\n-\n-    private static SelectorProvider provider() {\n-        SelectorProvider p = SelectorProvider.provider();\n-        if (!(p instanceof SelectorProviderImpl))\n-            throw new UnsupportedOperationException();\n-        return p;\n-    }\n-\n-    public static SocketChannel newSocketChannel(FileDescriptor fd) {\n-        try {\n-            return new SocketChannelImpl(provider(), fd, false);\n-        } catch (IOException ioe) {\n-            throw new AssertionError(ioe);\n-        }\n-    }\n-\n-    public static ServerSocketChannel newServerSocketChannel(FileDescriptor fd) {\n-        try {\n-            return new ServerSocketChannelImpl(provider(), fd, false);\n-        } catch (IOException ioe) {\n-            throw new AssertionError(ioe);\n-        }\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/Secrets.java","additions":0,"deletions":63,"binary":false,"changes":63,"status":"deleted"},{"patch":"@@ -36,0 +36,4 @@\n+import java.util.Objects;\n+import static java.net.StandardProtocolFamily.INET;\n+import static java.net.StandardProtocolFamily.INET6;\n+import static java.net.StandardProtocolFamily.UNIX;\n@@ -78,1 +82,10 @@\n-        return new SocketChannelImpl(this, family);\n+        Objects.requireNonNull(family, \"'family' is null\");\n+        if (family == INET6 && !Net.isIPv6Available()) {\n+            throw new UnsupportedOperationException(\"IPv6 not available\");\n+        } else if (family == INET || family == INET6) {\n+            return new SocketChannelImpl(this, family);\n+        } else if (family == UNIX && UnixDomainSockets.isSupported()) {\n+            return new SocketChannelImpl(this, family);\n+        } else {\n+            throw new UnsupportedOperationException(\"Protocol family not supported\");\n+        }\n@@ -82,2 +95,11 @@\n-    public ServerSocketChannel openServerSocketChannel(ProtocolFamily family) {\n-        return new ServerSocketChannelImpl(this, family);\n+    public ServerSocketChannel openServerSocketChannel(ProtocolFamily family) throws IOException {\n+        Objects.requireNonNull(family, \"'family' is null\");\n+        if (family == INET6 && !Net.isIPv6Available()) {\n+            throw new UnsupportedOperationException(\"IPv6 not available\");\n+        } else if (family == INET || family == INET6)  {\n+            return new ServerSocketChannelImpl(this, family);\n+        } else if (family == UNIX && UnixDomainSockets.isSupported()) {\n+            return new ServerSocketChannelImpl(this, family);\n+        } else {\n+            throw new UnsupportedOperationException(\"Protocol family not supported\");\n+        }\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/SelectorProviderImpl.java","additions":25,"deletions":3,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -96,1 +96,1 @@\n-        InetSocketAddress local = ssc.localAddress();\n+        SocketAddress local = ssc.localAddress();\n@@ -106,1 +106,1 @@\n-        InetSocketAddress local = ssc.localAddress();\n+        InetSocketAddress local = (InetSocketAddress) ssc.localAddress();\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/ServerSocketAdaptor.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import java.net.BindException;\n@@ -36,1 +37,0 @@\n-import java.net.StandardProtocolFamily;\n@@ -38,0 +38,1 @@\n+import java.net.UnixDomainSocketAddress;\n@@ -47,0 +48,1 @@\n+import java.nio.file.Path;\n@@ -49,1 +51,0 @@\n-import java.util.Objects;\n@@ -51,0 +52,1 @@\n+import java.util.Objects;\n@@ -52,0 +54,3 @@\n+import static java.net.StandardProtocolFamily.INET;\n+import static java.net.StandardProtocolFamily.INET6;\n+import static java.net.StandardProtocolFamily.UNIX;\n@@ -93,1 +98,1 @@\n-    private InetSocketAddress localAddress; \/\/ null => unbound\n+    private SocketAddress localAddress; \/\/ null => unbound\n@@ -103,4 +108,2 @@\n-    ServerSocketChannelImpl(SelectorProvider sp) {\n-        this(sp, Net.isIPv6Available()\n-                ? StandardProtocolFamily.INET6\n-                : StandardProtocolFamily.INET);\n+    ServerSocketChannelImpl(SelectorProvider sp) throws IOException {\n+        this(sp, Net.isIPv6Available() ? INET6 : INET);\n@@ -109,1 +112,3 @@\n-    ServerSocketChannelImpl(SelectorProvider sp, ProtocolFamily family) {\n+    ServerSocketChannelImpl(SelectorProvider sp, ProtocolFamily family)\n+        throws IOException\n+    {\n@@ -112,3 +117,1 @@\n-\n-        if ((family != StandardProtocolFamily.INET) &&\n-                (family != StandardProtocolFamily.INET6)) {\n+        if ((family != INET) && (family != INET6) && (family != UNIX)) {\n@@ -117,1 +120,1 @@\n-        if (family == StandardProtocolFamily.INET6 && !Net.isIPv6Available()) {\n+        if (family == INET6 && !Net.isIPv6Available()) {\n@@ -122,1 +125,5 @@\n-        this.fd = Net.serverSocket(family, true);\n+        if (family == UNIX) {\n+            this.fd = UnixDomainSockets.socket();\n+        } else {\n+            this.fd = Net.serverSocket(family, true);\n+        }\n@@ -126,1 +133,4 @@\n-    ServerSocketChannelImpl(SelectorProvider sp, FileDescriptor fd, boolean bound)\n+    ServerSocketChannelImpl(SelectorProvider sp,\n+                            ProtocolFamily family,\n+                            FileDescriptor fd,\n+                            boolean bound)\n@@ -131,4 +141,6 @@\n-        this.family = Net.isIPv6Available()\n-                ? StandardProtocolFamily.INET6\n-                : StandardProtocolFamily.INET;\n-        this.fd =  fd;\n+        if (family == UNIX) {\n+            this.family = UNIX;\n+        } else {\n+            this.family = Net.isIPv6Available() ? INET6 : INET;\n+        }\n+        this.fd = fd;\n@@ -139,1 +151,5 @@\n-                localAddress = Net.localAddress(fd);\n+                if (family == UNIX) {\n+                    localAddress = UnixDomainSockets.localAddress(fd);\n+                } else {\n+                    localAddress = Net.localAddress(fd);\n+                }\n@@ -144,0 +160,14 @@\n+    \/**\n+     * Returns true if this channel is to a INET or INET6 socket.\n+     *\/\n+    private boolean isNetSocket() {\n+        return (family == INET) || (family == INET6);\n+    }\n+\n+    \/**\n+     * Returns true if this channel is to a UNIX socket.\n+     *\/\n+    boolean isUnixSocket() {\n+        return (family == UNIX);\n+    }\n+\n@@ -153,2 +183,7 @@\n-            if (socket == null)\n-                socket = ServerSocketAdaptor.create(this);\n+            if (socket == null) {\n+                if (isNetSocket()) {\n+                    socket = ServerSocketAdaptor.create(this);\n+                } else {\n+                    throw new UnsupportedOperationException(\"Not supported\");\n+                }\n+            }\n@@ -163,3 +198,5 @@\n-            return (localAddress == null)\n-                    ? null\n-                    : Net.getRevealedLocalAddress(localAddress);\n+            if (isUnixSocket()) {\n+                return UnixDomainSockets.getRevealedLocalAddress(localAddress);\n+            } else {\n+                return Net.getRevealedLocalAddress(localAddress);\n+            }\n@@ -181,2 +218,3 @@\n-\n-            if (name == StandardSocketOptions.SO_REUSEADDR && Net.useExclusiveBind()) {\n+            if (isNetSocket()\n+                    && name == StandardSocketOptions.SO_REUSEADDR\n+                    && Net.useExclusiveBind()) {\n@@ -184,1 +222,1 @@\n-                isReuseAddress = (Boolean)value;\n+                isReuseAddress = (Boolean) value;\n@@ -204,1 +242,3 @@\n-            if (name == StandardSocketOptions.SO_REUSEADDR && Net.useExclusiveBind()) {\n+            if (isNetSocket()\n+                    && name == StandardSocketOptions.SO_REUSEADDR\n+                    && Net.useExclusiveBind()) {\n@@ -206,1 +246,4 @@\n-                return (T)Boolean.valueOf(isReuseAddress);\n+                return (T) Boolean.valueOf(isReuseAddress);\n+            } else {\n+                \/\/ no options that require special handling\n+                return (T) Net.getSocketOption(fd, Net.UNSPEC, name);\n@@ -208,2 +251,0 @@\n-            \/\/ no options that require special handling\n-            return (T) Net.getSocketOption(fd, Net.UNSPEC, name);\n@@ -214,1 +255,2 @@\n-        static final Set<SocketOption<?>> defaultOptions = defaultOptions();\n+        static final Set<SocketOption<?>> defaultInetOptions = defaultInetOptions();\n+        static final Set<SocketOption<?>> defaultUnixDomainOptions = defaultUnixDomainOptions();\n@@ -216,1 +258,1 @@\n-        private static Set<SocketOption<?>> defaultOptions() {\n+        private static Set<SocketOption<?>> defaultInetOptions() {\n@@ -226,0 +268,6 @@\n+\n+        private static Set<SocketOption<?>> defaultUnixDomainOptions() {\n+            HashSet<SocketOption<?>> set = new HashSet<>();\n+            set.add(StandardSocketOptions.SO_RCVBUF);\n+            return Collections.unmodifiableSet(set);\n+        }\n@@ -230,1 +278,5 @@\n-        return DefaultOptionsHolder.defaultOptions;\n+        if (isUnixSocket()) {\n+            return DefaultOptionsHolder.defaultUnixDomainOptions;\n+        } else {\n+            return DefaultOptionsHolder.defaultInetOptions;\n+        }\n@@ -239,3 +291,2 @@\n-            InetSocketAddress isa;\n-            if (local == null) {\n-                isa = new InetSocketAddress(Net.anyLocalAddress(family), 0);\n+            if (isUnixSocket()) {\n+                localAddress = unixBind(local, backlog);\n@@ -243,1 +294,1 @@\n-                isa = Net.checkAddress(local, family);\n+                localAddress = netBind(local, backlog);\n@@ -245,7 +296,0 @@\n-            SecurityManager sm = System.getSecurityManager();\n-            if (sm != null)\n-                sm.checkListen(isa.getPort());\n-            NetHooks.beforeTcpBind(fd, isa.getAddress(), isa.getPort());\n-            Net.bind(family, fd, isa.getAddress(), isa.getPort());\n-            Net.listen(fd, backlog < 1 ? 50 : backlog);\n-            localAddress = Net.localAddress(fd);\n@@ -256,0 +300,41 @@\n+    private SocketAddress unixBind(SocketAddress local, int backlog) throws IOException {\n+        UnixDomainSockets.checkPermission();\n+        if (local == null) {\n+            \/\/ Attempt up to 10 times to find an unused name in temp directory.\n+            \/\/ If local address supplied then bind called only once\n+            boolean bound = false;\n+            int attempts = 0;\n+            while (attempts < 10 && !bound) {\n+                try {\n+                    Path path = UnixDomainSockets.generateTempName().getPath();\n+                    UnixDomainSockets.bind(fd, path);\n+                    bound = true;\n+                } catch (BindException e) { }\n+                attempts++;\n+            }\n+            if (!bound)\n+                throw new BindException(\"Could not bind to temporary name\");\n+        } else {\n+            Path path = UnixDomainSockets.checkAddress(local).getPath();\n+            UnixDomainSockets.bind(fd, path);\n+        }\n+        Net.listen(fd, backlog < 1 ? 50 : backlog);\n+        return UnixDomainSockets.localAddress(fd);\n+    }\n+\n+    private SocketAddress netBind(SocketAddress local, int backlog) throws IOException {\n+        InetSocketAddress isa;\n+        if (local == null) {\n+            isa = new InetSocketAddress(Net.anyLocalAddress(family), 0);\n+        } else {\n+            isa = Net.checkAddress(local, family);\n+        }\n+        SecurityManager sm = System.getSecurityManager();\n+        if (sm != null)\n+            sm.checkListen(isa.getPort());\n+        NetHooks.beforeTcpBind(fd, isa.getAddress(), isa.getPort());\n+        Net.bind(family, fd, isa.getAddress(), isa.getPort());\n+        Net.listen(fd, backlog < 1 ? 50 : backlog);\n+        return Net.localAddress(fd);\n+    }\n+\n@@ -298,1 +383,1 @@\n-        InetSocketAddress[] isaa = new InetSocketAddress[1];\n+        SocketAddress[] saa = new SocketAddress[1];\n@@ -305,1 +390,1 @@\n-                n = Net.accept(this.fd, newfd, isaa);\n+                n = implAccept(this.fd, newfd, saa);\n@@ -309,1 +394,1 @@\n-                        n = Net.accept(this.fd, newfd, isaa);\n+                        n = implAccept(this.fd, newfd, saa);\n@@ -321,1 +406,1 @@\n-            return finishAccept(newfd, isaa[0]);\n+            return finishAccept(newfd, saa[0]);\n@@ -327,0 +412,19 @@\n+    private int implAccept(FileDescriptor fd, FileDescriptor newfd, SocketAddress[] saa)\n+        throws IOException\n+    {\n+        if (isUnixSocket()) {\n+            UnixDomainSockets.checkPermission();\n+            String[] pa = new String[1];\n+            int n = UnixDomainSockets.accept(fd, newfd, pa);\n+            if (n > 0)\n+                saa[0] = UnixDomainSocketAddress.of(pa[0]);\n+            return n;\n+        } else {\n+            InetSocketAddress[] issa = new InetSocketAddress[1];\n+            int n = Net.accept(fd, newfd, issa);\n+            if (n > 0)\n+                saa[0] = issa[0];\n+            return n;\n+        }\n+    }\n+\n@@ -340,1 +444,1 @@\n-        InetSocketAddress[] isaa = new InetSocketAddress[1];\n+        SocketAddress[] saa = new SocketAddress[1];\n@@ -354,1 +458,1 @@\n-                    n = Net.accept(fd, newfd, isaa);\n+                    n = implAccept(fd, newfd, saa);\n@@ -361,1 +465,1 @@\n-                        n = Net.accept(fd, newfd, isaa);\n+                        n = implAccept(fd, newfd, saa);\n@@ -375,1 +479,1 @@\n-        return finishAccept(newfd, isaa[0]);\n+        return finishAccept(newfd, saa[0]);\n@@ -378,1 +482,1 @@\n-    private SocketChannel finishAccept(FileDescriptor newfd, InetSocketAddress isa)\n+    private SocketChannel finishAccept(FileDescriptor newfd, SocketAddress sa)\n@@ -386,3 +490,6 @@\n-            SecurityManager sm = System.getSecurityManager();\n-            if (sm != null) {\n-                sm.checkAccept(isa.getAddress().getHostAddress(), isa.getPort());\n+            if (isNetSocket()) {\n+                SecurityManager sm = System.getSecurityManager();\n+                if (sm != null) {\n+                    InetSocketAddress isa = (InetSocketAddress) sa;\n+                    sm.checkAccept(isa.getAddress().getHostAddress(), isa.getPort());\n+                }\n@@ -390,1 +497,1 @@\n-            return new SocketChannelImpl(provider(), family, newfd, isa);\n+            return new SocketChannelImpl(provider(), family, newfd, sa);\n@@ -539,1 +646,1 @@\n-    InetSocketAddress localAddress() {\n+    SocketAddress localAddress() {\n@@ -608,1 +715,1 @@\n-                InetSocketAddress addr = localAddress;\n+                SocketAddress addr = localAddress;\n@@ -611,0 +718,2 @@\n+                } else if (isUnixSocket()) {\n+                    sb.append(UnixDomainSockets.getRevealedLocalAddressAsString(addr));\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/ServerSocketChannelImpl.java","additions":170,"deletions":61,"binary":false,"changes":231,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -75,0 +75,8 @@\n+    private InetSocketAddress localAddress() {\n+        return (InetSocketAddress) sc.localAddress();\n+    }\n+\n+    private InetSocketAddress remoteAddress() {\n+        return (InetSocketAddress) sc.remoteAddress();\n+    }\n+\n@@ -109,1 +117,1 @@\n-        InetSocketAddress remote = sc.remoteAddress();\n+        InetSocketAddress remote = remoteAddress();\n@@ -120,1 +128,1 @@\n-            InetSocketAddress local = sc.localAddress();\n+            InetSocketAddress local = localAddress();\n@@ -130,1 +138,1 @@\n-        InetSocketAddress remote = sc.remoteAddress();\n+        InetSocketAddress remote = remoteAddress();\n@@ -140,1 +148,1 @@\n-        InetSocketAddress local = sc.localAddress();\n+        InetSocketAddress local = localAddress();\n@@ -155,6 +163,1 @@\n-        InetSocketAddress local = sc.localAddress();\n-        if (local != null) {\n-            return Net.getRevealedLocalAddress(local);\n-        } else {\n-            return null;\n-        }\n+        return Net.getRevealedLocalAddress(sc.localAddress());\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/SocketAdaptor.java","additions":14,"deletions":11,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -39,1 +39,0 @@\n-import java.net.StandardProtocolFamily;\n@@ -53,0 +52,1 @@\n+import java.nio.file.Path;\n@@ -55,1 +55,0 @@\n-import java.util.Objects;\n@@ -57,0 +56,1 @@\n+import java.util.Objects;\n@@ -58,0 +58,3 @@\n+import static java.net.StandardProtocolFamily.INET;\n+import static java.net.StandardProtocolFamily.INET6;\n+import static java.net.StandardProtocolFamily.UNIX;\n@@ -117,2 +120,2 @@\n-    private InetSocketAddress localAddress;\n-    private InetSocketAddress remoteAddress;\n+    private SocketAddress localAddress;\n+    private SocketAddress remoteAddress;\n@@ -125,2 +128,0 @@\n-    \/\/ Constructor for normal connecting sockets\n-    \/\/\n@@ -128,3 +129,1 @@\n-        this(sp, Net.isIPv6Available()\n-                ? StandardProtocolFamily.INET6\n-                : StandardProtocolFamily.INET);\n+        this(sp, Net.isIPv6Available() ? INET6 : INET);\n@@ -136,2 +135,1 @@\n-        if ((family != StandardProtocolFamily.INET) &&\n-                (family != StandardProtocolFamily.INET6)) {\n+        if ((family != INET) && (family != INET6) && (family != UNIX)) {\n@@ -140,1 +138,1 @@\n-        if (family == StandardProtocolFamily.INET6 && !Net.isIPv6Available()) {\n+        if (family == INET6 && !Net.isIPv6Available()) {\n@@ -143,4 +141,0 @@\n-        this.family = family;\n-        this.fd = Net.socket(family, true);\n-        this.fdVal = IOUtil.fdVal(fd);\n-    }\n@@ -148,14 +142,5 @@\n-    SocketChannelImpl(SelectorProvider sp, FileDescriptor fd, boolean bound)\n-        throws IOException\n-    {\n-        super(sp);\n-        this.family = Net.isIPv6Available()\n-                ? StandardProtocolFamily.INET6\n-                : StandardProtocolFamily.INET;\n-        this.fd = fd;\n-        this.fdVal = IOUtil.fdVal(fd);\n-\n-        if (bound) {\n-            synchronized (stateLock) {\n-                this.localAddress = Net.localAddress(fd);\n-            }\n+        this.family = family;\n+        if (family == UNIX) {\n+            this.fd = UnixDomainSockets.socket();\n+        } else {\n+            this.fd = Net.socket(family, true);\n@@ -163,0 +148,1 @@\n+        this.fdVal = IOUtil.fdVal(fd);\n@@ -170,1 +156,1 @@\n-                      InetSocketAddress isa)\n+                      SocketAddress remoteAddress)\n@@ -178,2 +164,6 @@\n-            this.localAddress = Net.localAddress(fd);\n-            this.remoteAddress = isa;\n+            if (family == UNIX) {\n+                this.localAddress = UnixDomainSockets.localAddress(fd);\n+            } else {\n+                this.localAddress = Net.localAddress(fd);\n+            }\n+            this.remoteAddress = remoteAddress;\n@@ -184,0 +174,14 @@\n+    \/**\n+     * Returns true if this channel is to a INET or INET6 socket.\n+     *\/\n+    boolean isNetSocket() {\n+        return (family == INET) || (family == INET6);\n+    }\n+\n+    \/**\n+     * Returns true if this channel is to a UNIX socket.\n+     *\/\n+    boolean isUnixSocket() {\n+        return (family == UNIX);\n+    }\n+\n@@ -218,2 +222,7 @@\n-            if (socket == null)\n-                socket = SocketAdaptor.create(this);\n+            if (socket == null) {\n+                if (isNetSocket()) {\n+                    socket = SocketAdaptor.create(this);\n+                } else {\n+                    throw new UnsupportedOperationException(\"Not supported\");\n+                }\n+            }\n@@ -228,1 +237,5 @@\n-            return Net.getRevealedLocalAddress(localAddress);\n+            if (isUnixSocket()) {\n+                return UnixDomainSockets.getRevealedLocalAddress(localAddress);\n+            } else {\n+                return Net.getRevealedLocalAddress(localAddress);\n+            }\n@@ -253,9 +266,11 @@\n-            if (name == StandardSocketOptions.IP_TOS) {\n-                Net.setSocketOption(fd, family, name, value);\n-                return this;\n-            }\n-\n-            if (name == StandardSocketOptions.SO_REUSEADDR && Net.useExclusiveBind()) {\n-                \/\/ SO_REUSEADDR emulated when using exclusive bind\n-                isReuseAddress = (Boolean)value;\n-                return this;\n+            if (isNetSocket()) {\n+                if (name == StandardSocketOptions.IP_TOS) {\n+                    \/\/ special handling for IP_TOS\n+                    Net.setSocketOption(fd, family, name, value);\n+                    return this;\n+                }\n+                if (name == StandardSocketOptions.SO_REUSEADDR && Net.useExclusiveBind()) {\n+                    \/\/ SO_REUSEADDR emulated when using exclusive bind\n+                    isReuseAddress = (Boolean) value;\n+                    return this;\n+                }\n@@ -282,8 +297,9 @@\n-            if (name == StandardSocketOptions.SO_REUSEADDR && Net.useExclusiveBind()) {\n-                \/\/ SO_REUSEADDR emulated when using exclusive bind\n-                return (T)Boolean.valueOf(isReuseAddress);\n-            }\n-\n-            \/\/ special handling for IP_TOS\n-            if (name == StandardSocketOptions.IP_TOS) {\n-                return (T) Net.getSocketOption(fd, family, name);\n+            if (isNetSocket()) {\n+                if (name == StandardSocketOptions.IP_TOS) {\n+                    \/\/ special handling for IP_TOS\n+                    return (T) Net.getSocketOption(fd, family, name);\n+                }\n+                if (name == StandardSocketOptions.SO_REUSEADDR && Net.useExclusiveBind()) {\n+                    \/\/ SO_REUSEADDR emulated when using exclusive bind\n+                    return (T) Boolean.valueOf(isReuseAddress);\n+                }\n@@ -298,1 +314,2 @@\n-        static final Set<SocketOption<?>> defaultOptions = defaultOptions();\n+        static final Set<SocketOption<?>> defaultInetOptions = defaultInetOptions();\n+        static final Set<SocketOption<?>> defaultUnixOptions = defaultUnixOptions();\n@@ -300,1 +317,1 @@\n-        private static Set<SocketOption<?>> defaultOptions() {\n+        private static Set<SocketOption<?>> defaultInetOptions() {\n@@ -317,0 +334,9 @@\n+\n+        private static Set<SocketOption<?>> defaultUnixOptions() {\n+            HashSet<SocketOption<?>> set = new HashSet<>();\n+            set.add(StandardSocketOptions.SO_SNDBUF);\n+            set.add(StandardSocketOptions.SO_RCVBUF);\n+            set.add(StandardSocketOptions.SO_LINGER);\n+            set.addAll(ExtendedSocketOptions.unixDomainSocketOptions());\n+            return Collections.unmodifiableSet(set);\n+        }\n@@ -321,1 +347,5 @@\n-        return DefaultOptionsHolder.defaultOptions;\n+        if (isUnixSocket()) {\n+            return DefaultOptionsHolder.defaultUnixOptions;\n+        } else {\n+            return DefaultOptionsHolder.defaultInetOptions;\n+        }\n@@ -628,1 +658,1 @@\n-    InetSocketAddress localAddress() {\n+    SocketAddress localAddress() {\n@@ -637,1 +667,1 @@\n-    InetSocketAddress remoteAddress() {\n+    SocketAddress remoteAddress() {\n@@ -655,3 +685,2 @@\n-                    InetSocketAddress isa;\n-                    if (local == null) {\n-                        isa = new InetSocketAddress(Net.anyLocalAddress(family), 0);\n+                    if (isUnixSocket()) {\n+                        localAddress = unixBind(local);\n@@ -659,5 +688,1 @@\n-                        isa = Net.checkAddress(local, family);\n-                    }\n-                    SecurityManager sm = System.getSecurityManager();\n-                    if (sm != null) {\n-                        sm.checkListen(isa.getPort());\n+                        localAddress = netBind(local);\n@@ -665,3 +690,0 @@\n-                    NetHooks.beforeTcpBind(fd, isa.getAddress(), isa.getPort());\n-                    Net.bind(family, fd, isa.getAddress(), isa.getPort());\n-                    localAddress = Net.localAddress(fd);\n@@ -678,0 +700,32 @@\n+    private SocketAddress unixBind(SocketAddress local) throws IOException {\n+        UnixDomainSockets.checkPermission();\n+        if (local == null) {\n+            return UnixDomainSockets.UNNAMED;\n+        } else {\n+            Path path = UnixDomainSockets.checkAddress(local).getPath();\n+            if (path.toString().isEmpty()) {\n+                return UnixDomainSockets.UNNAMED;\n+            } else {\n+                \/\/ bind to non-empty path\n+                UnixDomainSockets.bind(fd, path);\n+                return UnixDomainSockets.localAddress(fd);\n+            }\n+        }\n+    }\n+\n+    private SocketAddress netBind(SocketAddress local) throws IOException {\n+        InetSocketAddress isa;\n+        if (local == null) {\n+            isa = new InetSocketAddress(Net.anyLocalAddress(family), 0);\n+        } else {\n+            isa = Net.checkAddress(local, family);\n+        }\n+        SecurityManager sm = System.getSecurityManager();\n+        if (sm != null) {\n+            sm.checkListen(isa.getPort());\n+        }\n+        NetHooks.beforeTcpBind(fd, isa.getAddress(), isa.getPort());\n+        Net.bind(family, fd, isa.getAddress(), isa.getPort());\n+        return Net.localAddress(fd);\n+    }\n+\n@@ -697,1 +751,1 @@\n-    private void beginConnect(boolean blocking, InetSocketAddress isa)\n+    private void beginConnect(boolean blocking, SocketAddress sa)\n@@ -714,1 +768,2 @@\n-            if (localAddress == null)\n+            if (isNetSocket() && (localAddress == null)) {\n+                InetSocketAddress isa = (InetSocketAddress) sa;\n@@ -716,1 +771,2 @@\n-            remoteAddress = isa;\n+            }\n+            remoteAddress = sa;\n@@ -740,1 +796,5 @@\n-                    localAddress = Net.localAddress(fd);\n+                    if (isUnixSocket()) {\n+                        localAddress = UnixDomainSockets.localAddress(fd);\n+                    } else {\n+                        localAddress = Net.localAddress(fd);\n+                    }\n@@ -750,11 +810,19 @@\n-    private InetSocketAddress checkRemote(SocketAddress sa) {\n-        InetSocketAddress isa = Net.checkAddress(sa, family);\n-        SecurityManager sm = System.getSecurityManager();\n-        if (sm != null) {\n-            sm.checkConnect(isa.getAddress().getHostAddress(), isa.getPort());\n-        }\n-        InetAddress address = isa.getAddress();\n-        if (address.isAnyLocalAddress()) {\n-            int port = isa.getPort();\n-            if (address instanceof Inet4Address) {\n-                return new InetSocketAddress(Net.inet4LoopbackAddress(), port);\n+    private SocketAddress checkRemote(SocketAddress sa) {\n+        if (isUnixSocket()) {\n+            UnixDomainSockets.checkPermission();\n+            return UnixDomainSockets.checkAddress(sa);\n+        } else {\n+            InetSocketAddress isa = Net.checkAddress(sa, family);\n+            SecurityManager sm = System.getSecurityManager();\n+            if (sm != null) {\n+                sm.checkConnect(isa.getAddress().getHostAddress(), isa.getPort());\n+            }\n+            InetAddress address = isa.getAddress();\n+            if (address.isAnyLocalAddress()) {\n+                int port = isa.getPort();\n+                if (address instanceof Inet4Address) {\n+                    return new InetSocketAddress(Net.inet4LoopbackAddress(), port);\n+                } else {\n+                    assert family == INET6;\n+                    return new InetSocketAddress(Net.inet6LoopbackAddress(), port);\n+                }\n@@ -762,2 +830,1 @@\n-                assert family == StandardProtocolFamily.INET6;\n-                return new InetSocketAddress(Net.inet6LoopbackAddress(), port);\n+                return isa;\n@@ -765,2 +832,0 @@\n-        } else {\n-            return isa;\n@@ -772,1 +837,1 @@\n-        InetSocketAddress isa = checkRemote(remote);\n+        SocketAddress sa = checkRemote(remote);\n@@ -781,5 +846,7 @@\n-                        beginConnect(blocking, isa);\n-                        int n = Net.connect(family,\n-                                            fd,\n-                                            isa.getAddress(),\n-                                            isa.getPort());\n+                        beginConnect(blocking, sa);\n+                        int n;\n+                        if (isUnixSocket()) {\n+                            n = UnixDomainSockets.connect(fd, sa);\n+                        } else {\n+                            n = Net.connect(family, fd, sa);\n+                        }\n@@ -810,1 +877,1 @@\n-            throw SocketExceptions.of(ioe, isa);\n+            throw SocketExceptions.of(ioe, sa);\n@@ -851,1 +918,5 @@\n-                    localAddress = Net.localAddress(fd);\n+                    if (isUnixSocket()) {\n+                        localAddress = UnixDomainSockets.localAddress(fd);\n+                    } else {\n+                        localAddress = Net.localAddress(fd);\n+                    }\n@@ -1090,1 +1161,1 @@\n-        InetSocketAddress isa = checkRemote(remote);\n+        SocketAddress sa = checkRemote(remote);\n@@ -1100,1 +1171,1 @@\n-                        beginConnect(true, isa);\n+                        beginConnect(true, sa);\n@@ -1104,1 +1175,6 @@\n-                            int n = Net.connect(fd, isa.getAddress(), isa.getPort());\n+                            int n;\n+                            if (isUnixSocket()) {\n+                                n = UnixDomainSockets.connect(fd, sa);\n+                            } else {\n+                                n = Net.connect(family, fd, sa);\n+                            }\n@@ -1122,1 +1198,1 @@\n-            throw SocketExceptions.of(ioe, isa);\n+            throw SocketExceptions.of(ioe, sa);\n@@ -1393,1 +1469,1 @@\n-                InetSocketAddress addr = localAddress();\n+                SocketAddress addr = localAddress();\n@@ -1396,1 +1472,5 @@\n-                    sb.append(Net.getRevealedLocalAddressAsString(addr));\n+                    if (isUnixSocket()) {\n+                        sb.append(UnixDomainSockets.getRevealedLocalAddressAsString(addr));\n+                    } else {\n+                        sb.append(Net.getRevealedLocalAddressAsString(addr));\n+                    }\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/SocketChannelImpl.java","additions":182,"deletions":102,"binary":false,"changes":284,"status":"modified"},{"patch":"@@ -0,0 +1,176 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.nio.ch;\n+\n+import java.io.FileDescriptor;\n+import java.io.IOException;\n+import java.net.BindException;\n+import java.net.NetPermission;\n+import java.net.SocketAddress;\n+import java.net.UnixDomainSocketAddress;\n+import java.nio.channels.UnsupportedAddressTypeException;\n+import java.nio.file.FileSystems;\n+import java.nio.file.InvalidPathException;\n+import java.nio.file.Path;\n+import java.nio.file.spi.FileSystemProvider;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.SecureRandom;\n+import java.util.Random;\n+import sun.nio.fs.AbstractFileSystemProvider;\n+\n+class UnixDomainSockets {\n+    private UnixDomainSockets() { }\n+\n+    static final UnixDomainSocketAddress UNNAMED = UnixDomainSocketAddress.of(\"\");\n+\n+    private static final boolean supported;\n+\n+    private static final String tempDir = UnixDomainSocketsUtil.getTempDir();\n+\n+    private static final NetPermission accessUnixDomainSocket =\n+            new NetPermission(\"accessUnixDomainSocket\");\n+\n+    static boolean isSupported() {\n+        return supported;\n+    }\n+\n+    static void checkPermission() {\n+        SecurityManager sm = System.getSecurityManager();\n+        if (sm != null)\n+            sm.checkPermission(accessUnixDomainSocket);\n+    }\n+\n+    static UnixDomainSocketAddress getRevealedLocalAddress(SocketAddress sa) {\n+        UnixDomainSocketAddress addr = (UnixDomainSocketAddress) sa;\n+        try {\n+            checkPermission();\n+            \/\/ Security check passed\n+        } catch (SecurityException e) {\n+            \/\/ Return unnamed address only if security check fails\n+            addr = UNNAMED;\n+        }\n+        return addr;\n+    }\n+\n+    static UnixDomainSocketAddress localAddress(FileDescriptor fd) throws IOException {\n+        String path = new String(localAddress0(fd), UnixDomainSocketsUtil.getCharset());\n+        return UnixDomainSocketAddress.of(path);\n+    }\n+\n+    private static native byte[] localAddress0(FileDescriptor fd) throws IOException;\n+\n+    static String getRevealedLocalAddressAsString(SocketAddress sa) {\n+        return (System.getSecurityManager() != null) ? sa.toString() : \"\";\n+    }\n+\n+    static UnixDomainSocketAddress checkAddress(SocketAddress sa) {\n+        if (sa == null)\n+            throw new NullPointerException();\n+        if (!(sa instanceof UnixDomainSocketAddress))\n+            throw new UnsupportedAddressTypeException();\n+        return (UnixDomainSocketAddress) sa;\n+    }\n+\n+    static byte[] getPathBytes(Path path) {\n+        FileSystemProvider provider = FileSystems.getDefault().provider();\n+        return ((AbstractFileSystemProvider) provider).getSunPathForSocketFile(path);\n+    }\n+\n+    static FileDescriptor socket() throws IOException {\n+        return IOUtil.newFD(socket0());\n+    }\n+\n+    static void bind(FileDescriptor fd, Path addr) throws IOException {\n+        byte[] path = getPathBytes(addr);\n+        bind0(fd, path);\n+    }\n+\n+    private static Random getRandom() {\n+        try {\n+            return SecureRandom.getInstance(\"NativePRNGNonBlocking\");\n+        } catch (NoSuchAlgorithmException e) {\n+            return new SecureRandom(); \/\/ This should not fail\n+        }\n+    }\n+\n+    private static final Random random = getRandom();\n+\n+    \/**\n+     * Return a possible temporary name to bind to, which is different for each call\n+     * Name is of the form <temp dir>\/socket_<random>\n+     *\/\n+    static UnixDomainSocketAddress generateTempName() throws IOException {\n+        String dir = UnixDomainSockets.tempDir;\n+        if (dir == null)\n+            throw new BindException(\"Could not locate temporary directory for sockets\");\n+        int rnd = random.nextInt(Integer.MAX_VALUE);\n+        try {\n+            Path path = Path.of(dir, \"socket_\" + rnd);\n+            return UnixDomainSocketAddress.of(path);\n+        } catch (InvalidPathException e) {\n+            throw new BindException(\"Invalid temporary directory\");\n+        }\n+    }\n+\n+    static int connect(FileDescriptor fd, SocketAddress sa) throws IOException {\n+        return UnixDomainSockets.connect(fd, ((UnixDomainSocketAddress) sa).getPath());\n+    }\n+\n+    static int connect(FileDescriptor fd, Path path) throws IOException {\n+        return connect0(fd, getPathBytes(path));\n+    }\n+\n+    static int accept(FileDescriptor fd, FileDescriptor newfd, String[] paths)\n+        throws IOException\n+    {\n+        Object[] array  = new Object[1];\n+        int n = accept0(fd, newfd, array);\n+        if (n > 0) {\n+            byte[] bytes = (byte[]) array[0];\n+            paths[0] = new String(bytes, UnixDomainSocketsUtil.getCharset());\n+        }\n+        return n;\n+    }\n+\n+    private static native boolean socketSupported();\n+\n+    private static native int socket0() throws IOException;\n+\n+    private static native void bind0(FileDescriptor fd, byte[] path)\n+        throws IOException;\n+\n+    private static native int connect0(FileDescriptor fd, byte[] path)\n+        throws IOException;\n+\n+    private static native int accept0(FileDescriptor fd, FileDescriptor newfd, Object[] array)\n+        throws IOException;\n+\n+    static {\n+        \/\/ Load all required native libs\n+        IOUtil.load();\n+        supported = socketSupported();\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/UnixDomainSockets.java","additions":176,"deletions":0,"binary":false,"changes":176,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2020 Oracle and\/or its affiliates. All rights reserved.\n@@ -157,0 +157,6 @@\n+\n+    \/**\n+     * Returns a path name as bytes for a Unix domain socket.\n+     * Different encodings may be used for these names on some platforms.\n+     *\/\n+    public abstract byte[] getSunPathForSocketFile(Path file);\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/fs\/AbstractFileSystemProvider.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -35,0 +35,2 @@\n+import java.net.SocketAddress;\n+import java.net.UnixDomainSocketAddress;\n@@ -39,0 +41,1 @@\n+import static java.net.StandardProtocolFamily.UNIX;\n@@ -48,4 +51,4 @@\n-    private static final int AF_UNKNOWN         = -1;\n-    private static final int AF_INET            = 1;\n-    private static final int AF_INET6           = 2;\n-    private static final int AF_UNIX            = 3;\n+    static final int AF_UNKNOWN         = -1;\n+    static final int AF_INET            = 1;\n+    static final int AF_INET6           = 2;\n+    static final int AF_UNIX            = 3;\n@@ -78,0 +81,18 @@\n+    static ProtocolFamily protocolFamily(SocketAddress sa) {\n+        if (sa instanceof UnixDomainSocketAddress) {\n+            return UNIX;\n+        } else {\n+            InetSocketAddress isa = (InetSocketAddress) sa;\n+            return (isa.getAddress() instanceof Inet6Address) ? INET6 : INET;\n+        }\n+    }\n+\n+    static ProtocolFamily protocolFamily(int family) {\n+        return switch (family) {\n+            case AF_INET -> INET;\n+            case AF_INET6 -> INET6;\n+            case AF_UNIX -> UNIX;\n+            default -> throw new IllegalArgumentException();\n+        };\n+    }\n+\n@@ -85,4 +106,0 @@\n-        static ProtocolFamily family(InetSocketAddress isa) {\n-            return (isa.getAddress() instanceof Inet6Address) ? INET6 : INET;\n-        }\n-\n@@ -91,1 +108,1 @@\n-                                   InetSocketAddress remote)\n+                                   SocketAddress remote)\n@@ -94,1 +111,1 @@\n-            super(sp, family(remote), fd, remote);\n+            super(sp, protocolFamily(remote), fd, remote);\n@@ -103,16 +120,1 @@\n-    public static class InheritedUnixChannelImpl extends UnixDomainSocketChannelImpl {\n-\n-        InheritedUnixChannelImpl(FileDescriptor fd)\n-            throws IOException\n-        {\n-            super(fd);\n-        }\n-\n-        protected void implCloseSelectableChannel() throws IOException {\n-            super.implCloseChannel();\n-            detachIOStreams();\n-        }\n-    }\n-\n-    public static class InheritedServerSocketChannelImpl extends\n-        ServerSocketChannelImpl {\n+    public static class InheritedServerSocketChannelImpl extends ServerSocketChannelImpl {\n@@ -121,0 +123,1 @@\n+                                         ProtocolFamily family,\n@@ -124,1 +127,1 @@\n-            super(sp, fd, true);\n+            super(sp, family, fd, true);\n@@ -127,0 +130,1 @@\n+        @Override\n@@ -131,1 +135,0 @@\n-\n@@ -134,2 +137,1 @@\n-    public static class InheritedDatagramChannelImpl extends\n-        DatagramChannelImpl {\n+    public static class InheritedDatagramChannelImpl extends DatagramChannelImpl {\n@@ -154,1 +156,1 @@\n-    private static void checkAccess(Channel c) {\n+    private static void checkAccess() {\n@@ -157,3 +159,1 @@\n-            sm.checkPermission(\n-                new RuntimePermission(\"inheritedChannel\")\n-            );\n+            sm.checkPermission(new RuntimePermission(\"inheritedChannel\"));\n@@ -163,1 +163,0 @@\n-\n@@ -200,1 +199,1 @@\n-        \/\/ we see if tthere is a peer (ie: connected). If so, then we\n+        \/\/ we see if there is a peer (ie: connected). If so, then we\n@@ -212,0 +211,1 @@\n+            ProtocolFamily pfamily = protocolFamily(family);\n@@ -214,1 +214,2 @@\n-                    return new InheritedUnixChannelImpl(fd);\n+                    var sa = UnixDomainSocketAddress.of(unixPeerAddress(fdVal));\n+                    return new InheritedSocketChannelImpl(provider, fd, sa);\n@@ -216,2 +217,1 @@\n-                    \/\/ listener. unsupported.\n-                    return null;\n+                    return new InheritedServerSocketChannelImpl(provider, pfamily, fd);\n@@ -220,1 +220,1 @@\n-            InetAddress ia = peerAddress0(fdVal);\n+            InetAddress ia = inetPeerAddress0(fdVal);\n@@ -222,1 +222,1 @@\n-               c = new InheritedServerSocketChannelImpl(provider, fd);\n+               c = new InheritedServerSocketChannelImpl(provider, pfamily, fd);\n@@ -225,0 +225,1 @@\n+\n@@ -256,1 +257,1 @@\n-            checkAccess(channel);\n+            checkAccess();\n@@ -261,0 +262,4 @@\n+    private static String unixPeerAddress(int fd) throws IOException {\n+        byte[] bytes = unixPeerAddress0(fd);\n+        return new String(bytes);\n+    }\n@@ -271,1 +276,2 @@\n-    private static native InetAddress peerAddress0(int fd);\n+    private static native InetAddress inetPeerAddress0(int fd);\n+    private static native byte[] unixPeerAddress0(int fd);\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/ch\/InheritedChannel.java","additions":49,"deletions":43,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -1,266 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.nio.ch;\n-\n-import java.io.FileDescriptor;\n-import java.io.IOException;\n-import java.nio.ByteBuffer;\n-import java.nio.channels.AsynchronousCloseException;\n-import java.nio.channels.ByteChannel;\n-import java.nio.channels.ClosedChannelException;\n-import java.nio.channels.NotYetConnectedException;\n-import java.nio.channels.spi.AbstractInterruptibleChannel;\n-import java.util.Objects;\n-import java.util.concurrent.locks.ReentrantLock;\n-\n-import static java.util.concurrent.TimeUnit.NANOSECONDS;\n-\n-class UnixDomainSocketChannelImpl\n-    extends AbstractInterruptibleChannel\n-    implements ByteChannel\n-{\n-    \/\/ Used to make native read and write calls\n-    private static final NativeDispatcher nd = new SocketDispatcher();\n-\n-    \/\/ Our file descriptor object\n-    private final FileDescriptor fd;\n-    \/\/ Lock held by current reading or connecting thread\n-    private final ReentrantLock readLock = new ReentrantLock();\n-\n-    \/\/ Lock held by current writing or connecting thread\n-    private final ReentrantLock writeLock = new ReentrantLock();\n-\n-    \/\/ Lock for managing close state\n-    private final Object stateLock = new Object();\n-\n-    \/\/ Channel state\n-    private static final int ST_INUSE = 0;\n-    private static final int ST_CLOSING = 1;\n-    private static final int ST_CLOSED = 2;\n-    private int state;\n-\n-    \/\/ IDs of native threads doing reads and writes, for signalling\n-    private long readerThread;\n-    private long writerThread;\n-\n-    UnixDomainSocketChannelImpl(FileDescriptor fd)\n-        throws IOException\n-    {\n-        this.fd = fd;\n-    }\n-\n-    \/**\n-     * Checks that the channel is open.\n-     *\n-     * @throws ClosedChannelException if channel is closed (or closing)\n-     *\/\n-    private void ensureOpen() throws ClosedChannelException {\n-        if (!isOpen())\n-            throw new ClosedChannelException();\n-    }\n-\n-    \/**\n-     * Closes the socket if there are no I\/O operations in progress\n-     *\/\n-    private boolean tryClose() throws IOException {\n-        assert Thread.holdsLock(stateLock) && state == ST_CLOSING;\n-        if (readerThread == 0 && writerThread == 0) {\n-            state = ST_CLOSED;\n-            nd.close(fd);\n-            return true;\n-        } else {\n-            return false;\n-        }\n-    }\n-\n-    \/**\n-     * Complete closure of pre-closed socket (release the file descriptor)\n-     *\/\n-    private void tryFinishClose() {\n-        try {\n-            tryClose();\n-        } catch (IOException ignore) { }\n-    }\n-\n-    \/**\n-     * Marks the beginning of a read operation\n-     *\n-     * @throws ClosedChannelException if the channel is closed\n-     * @throws NotYetConnectedException if the channel is not yet connected\n-     *\/\n-    private void beginRead() throws ClosedChannelException {\n-        \/\/ set hook for Thread.interrupt\n-        begin();\n-        synchronized (stateLock) {\n-            ensureOpen();\n-            readerThread = NativeThread.current();\n-        }\n-    }\n-\n-    \/**\n-     * Marks the end of a read operation that may have blocked.\n-     *\n-     * @throws AsynchronousCloseException if the channel was closed due to this\n-     * thread being interrupted on a blocking read operation.\n-     *\/\n-    private void endRead(boolean completed)\n-        throws AsynchronousCloseException\n-    {\n-        synchronized (stateLock) {\n-            readerThread = 0;\n-            if (state == ST_CLOSING) {\n-                tryFinishClose();\n-            }\n-        }\n-        end(completed);\n-    }\n-\n-    @Override\n-    public int read(ByteBuffer buf) throws IOException {\n-        Objects.requireNonNull(buf);\n-\n-        readLock.lock();\n-        try {\n-            int n = 0;\n-            try {\n-                beginRead();\n-                n = IOUtil.read(fd, buf, -1, nd);\n-                while (IOStatus.okayToRetry(n) && isOpen()) {\n-                    park(Net.POLLIN, 0L);\n-                    n = IOUtil.read(fd, buf, -1, nd);\n-                }\n-            } finally {\n-                endRead(n > 0);\n-            }\n-            return n;\n-        } finally {\n-            readLock.unlock();\n-        }\n-    }\n-\n-    \/**\n-     * Marks the beginning of a write operation that might block.\n-     *\n-     * @throws ClosedChannelException if the channel is closed\n-     * @throws NotYetConnectedException if the channel is not yet connected\n-     *\/\n-    private void beginWrite() throws ClosedChannelException {\n-        begin();\n-        synchronized (stateLock) {\n-            \/\/ set hook for Thread.interrupt\n-            ensureOpen();\n-            writerThread = NativeThread.current();\n-        }\n-    }\n-\n-    \/**\n-     * Marks the end of a write operation that may have blocked.\n-     *\n-     * @throws AsynchronousCloseException if the channel was closed due to this\n-     * thread being interrupted on a blocking write operation.\n-     *\/\n-    private void endWrite(boolean completed)\n-        throws AsynchronousCloseException\n-    {\n-        synchronized (stateLock) {\n-            writerThread = 0;\n-            if (state == ST_CLOSING) {\n-                tryFinishClose();\n-            }\n-        }\n-        end(completed);\n-    }\n-\n-    void park(int event, long nanos) throws IOException {\n-        long millis;\n-        if (nanos <= 0) {\n-            millis = -1;\n-        } else {\n-            millis = NANOSECONDS.toMillis(nanos);\n-        }\n-        Net.poll(fd, event, millis);\n-    }\n-\n-    @Override\n-    public int write(ByteBuffer buf) throws IOException {\n-        Objects.requireNonNull(buf);\n-\n-        writeLock.lock();\n-        try {\n-            int n = 0;\n-            try {\n-                beginWrite();\n-                n = IOUtil.write(fd, buf, -1, nd);\n-                while (IOStatus.okayToRetry(n) && isOpen()) {\n-                    park(Net.POLLOUT, 0L);\n-                    n = IOUtil.write(fd, buf, -1, nd);\n-                }\n-            } finally {\n-                endWrite(n > 0);\n-            }\n-            return n;\n-        } finally {\n-            writeLock.unlock();\n-        }\n-    }\n-\n-    \/**\n-     * Closes this channel\n-     *\n-     * If there is an I\/O operation in progress then the socket is pre-closed\n-     * and the I\/O threads signalled, in which case the final close is deferred\n-     * until all I\/O operations complete.\n-     *\/\n-    @Override\n-    protected void implCloseChannel() throws IOException {\n-        synchronized (stateLock) {\n-            assert state == ST_INUSE;\n-            state = ST_CLOSING;\n-            if (!tryClose()) {\n-                long reader = readerThread;\n-                long writer = writerThread;\n-                if (reader != 0 || writer != 0) {\n-                    nd.preClose(fd);\n-                    if (reader != 0)\n-                        NativeThread.signal(reader);\n-                    if (writer != 0)\n-                        NativeThread.signal(writer);\n-                }\n-            }\n-        }\n-    }\n-\n-    @Override\n-    public String toString() {\n-        StringBuilder sb = new StringBuilder();\n-        sb.append(this.getClass().getSuperclass().getName());\n-        sb.append('[');\n-        if (!isOpen())\n-            sb.append(\"closed\");\n-        sb.append(']');\n-        return sb.toString();\n-    }\n-}\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/ch\/UnixDomainSocketChannelImpl.java","additions":0,"deletions":266,"binary":false,"changes":266,"status":"deleted"},{"patch":"@@ -0,0 +1,65 @@\n+\/*\n+ * Copyright (c) 2008, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.nio.ch;\n+\n+import java.nio.charset.Charset;\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n+import sun.net.NetProperties;\n+import jdk.internal.util.StaticProperty;\n+\n+\/**\n+ * Platform specific utility functions\n+ *\/\n+class UnixDomainSocketsUtil {\n+    private UnixDomainSocketsUtil() { }\n+\n+    static Charset getCharset() {\n+        return Charset.defaultCharset();\n+    }\n+\n+    \/**\n+     * Return the temp directory for storing automatically bound\n+     * server sockets.\n+     *\n+     * On UNIX we search the following directories in sequence:\n+     *\n+     * 1. ${jdk.net.unixdomain.tmpdir} if set as system property\n+     * 2. ${jdk.net.unixdomain.tmpdir} if set as net property\n+     * 3. ${java.io.tmpdir} system property\n+     *\/\n+    static String getTempDir() {\n+        PrivilegedAction<String> action = () -> {\n+            String s = NetProperties.get(\"jdk.net.unixdomain.tmpdir\");\n+            if (s != null && s.length() > 0) {\n+                return s;\n+            } else {\n+                return StaticProperty.javaIoTmpDir();\n+            }\n+        };\n+        return AccessController.doPrivileged(action);\n+    }\n+}\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/ch\/UnixDomainSocketsUtil.java","additions":65,"deletions":0,"binary":false,"changes":65,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -560,0 +560,6 @@\n+\n+    @Override\n+    public byte[] getSunPathForSocketFile(Path obj) {\n+        UnixPath file = UnixPath.toUnixPath(obj);\n+        return file.getByteArrayForSysCalls();\n+    }\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixFileSystemProvider.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-class UnixUserPrincipals {\n+public class UnixUserPrincipals {\n@@ -111,1 +111,1 @@\n-    static User fromUid(int uid) {\n+    public static User fromUid(int uid) {\n@@ -122,1 +122,1 @@\n-    static Group fromGid(int gid) {\n+    public static Group fromGid(int gid) {\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixUserPrincipals.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,15 @@\n+#\n+# Default directory where automatically bound Unix domain server\n+# sockets are stored. Sockets are automatically bound when bound\n+# with a null address.\n+#\n+# On Unix the search order to determine this directory is:\n+#\n+# 1. System property jdk.net.unixdomain.tmpdir\n+#\n+# 2. Networking property jdk.net.unixdomain.tmpdir specified\n+#    in this file (effective default)\n+#\n+# 3. System property java.io.tmpdir\n+#\n+jdk.net.unixdomain.tmpdir=\/tmp\n","filename":"src\/java.base\/unix\/conf\/net.properties","additions":15,"deletions":0,"binary":false,"changes":15,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,1 @@\n+#include \"nio_util.h\"\n@@ -40,1 +41,1 @@\n-static int matchFamily(SOCKETADDRESS *sa) {\n+static int toInetFamily(SOCKETADDRESS *sa) {\n@@ -52,1 +53,1 @@\n-Java_sun_nio_ch_InheritedChannel_peerAddress0(JNIEnv *env, jclass cla, jint fd)\n+Java_sun_nio_ch_InheritedChannel_inetPeerAddress0(JNIEnv *env, jclass cla, jint fd)\n@@ -60,1 +61,1 @@\n-        if (matchFamily(&sa)) {\n+        if (toInetFamily(&sa)) {\n@@ -68,0 +69,15 @@\n+JNIEXPORT jbyteArray JNICALL\n+Java_sun_nio_ch_InheritedChannel_unixPeerAddress0(JNIEnv *env, jclass cla, jint fd)\n+{\n+    struct sockaddr_un sa;\n+    socklen_t len = sizeof(struct sockaddr_un);\n+    jobject remote_sa = NULL;\n+\n+    if (getpeername(fd, (struct sockaddr *)&sa, &len) == 0) {\n+        if (sa.sun_family == AF_UNIX) {\n+            remote_sa = sockaddrToUnixAddressBytes(env, &sa, len);\n+        }\n+    }\n+    return remote_sa;\n+}\n+\n@@ -75,2 +91,2 @@\n-    if (getpeername(fd, &sa.sa, &len) == 0) {\n-        if (matchFamily(&sa)) {\n+    if (getpeername(fd, (struct sockaddr *)&sa.sa, &len) == 0) {\n+        if (toInetFamily(&sa)) {\n","filename":"src\/java.base\/unix\/native\/libnio\/ch\/InheritedChannel.c","additions":22,"deletions":6,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -0,0 +1,194 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <poll.h>\n+#include <sys\/types.h>\n+#include <sys\/socket.h>\n+#include <string.h>\n+#include <stddef.h>\n+#include <netinet\/in.h>\n+#include <netinet\/tcp.h>\n+#include <limits.h>\n+\n+#include \"jni.h\"\n+#include \"java_props.h\"\n+#include \"jni_util.h\"\n+#include \"jvm.h\"\n+#include \"jlong.h\"\n+#include \"sun_nio_ch_Net.h\"\n+#include \"nio_util.h\"\n+#include \"nio.h\"\n+\n+\/* Subtle platform differences in how unnamed sockets (empty path)\n+ * are returned from getsockname()\n+ *\/\n+#ifdef MACOSX\n+  #define ZERO_PATHLEN(len) (JNI_FALSE)\n+#else\n+  #define ZERO_PATHLEN(len) (len == offsetof(struct sockaddr_un, sun_path))\n+#endif\n+\n+jbyteArray sockaddrToUnixAddressBytes(JNIEnv *env, struct sockaddr_un *sa, socklen_t len)\n+{\n+    if (sa->sun_family == AF_UNIX) {\n+        int namelen;\n+        if (ZERO_PATHLEN(len)) {\n+            namelen = 0;\n+        } else {\n+            namelen = strlen(sa->sun_path);\n+        }\n+        jbyteArray name = (*env)->NewByteArray(env, namelen);\n+        if (namelen != 0) {\n+            (*env)->SetByteArrayRegion(env, name, 0, namelen, (jbyte*)sa->sun_path);\n+            if ((*env)->ExceptionOccurred(env)) {\n+                return NULL;\n+            }\n+        }\n+        return name;\n+    }\n+    return NULL;\n+}\n+\n+jint unixSocketAddressToSockaddr(JNIEnv *env, jbyteArray path, struct sockaddr_un *sa, int *len)\n+{\n+    memset(sa, 0, sizeof(struct sockaddr_un));\n+    sa->sun_family = AF_UNIX;\n+    int ret;\n+    const char* pname = (const char *)(*env)->GetByteArrayElements(env, path, NULL);\n+    if (pname == NULL) {\n+        JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\", \"Unix domain path not present\");\n+        return -1;\n+    }\n+    size_t name_len = (*env)->GetArrayLength(env, path);\n+    if (name_len > MAX_UNIX_DOMAIN_PATH_LEN) {\n+        JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\", \"Unix domain path too long\");\n+        ret = -1;\n+    } else {\n+        memcpy(sa->sun_path, pname, name_len);\n+        *len = (int)(offsetof(struct sockaddr_un, sun_path) + name_len + 1);\n+        ret = 0;\n+    }\n+    (*env)->ReleaseByteArrayElements(env, path, (jbyte *)pname, 0);\n+    return ret;\n+}\n+\n+JNIEXPORT jboolean JNICALL\n+Java_sun_nio_ch_UnixDomainSockets_socketSupported(JNIEnv *env, jclass cl)\n+{\n+    return JNI_TRUE;\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_sun_nio_ch_UnixDomainSockets_socket0(JNIEnv *env, jclass cl)\n+{\n+    int fd = socket(PF_UNIX, SOCK_STREAM, 0);\n+    if (fd < 0) {\n+        return handleSocketError(env, errno);\n+    }\n+    return fd;\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_sun_nio_ch_UnixDomainSockets_bind0(JNIEnv *env, jclass clazz, jobject fdo, jbyteArray path)\n+{\n+    struct sockaddr_un sa;\n+    int sa_len = 0;\n+    int rv = 0;\n+\n+    if (unixSocketAddressToSockaddr(env, path, &sa, &sa_len) != 0)\n+        return;\n+\n+    rv = bind(fdval(env, fdo), (struct sockaddr *)&sa, sa_len);\n+    if (rv != 0) {\n+        handleSocketError(env, errno);\n+    }\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_sun_nio_ch_UnixDomainSockets_connect0(JNIEnv *env, jclass clazz, jobject fdo, jbyteArray path)\n+{\n+    struct sockaddr_un sa;\n+    int sa_len = 0;\n+    int rv;\n+\n+    if (unixSocketAddressToSockaddr(env, path, &sa, &sa_len) != 0) {\n+        return IOS_THROWN;\n+    }\n+\n+    rv = connect(fdval(env, fdo), (struct sockaddr *)&sa, sa_len);\n+    if (rv != 0) {\n+        if (errno == EINPROGRESS) {\n+            return IOS_UNAVAILABLE;\n+        } else if (errno == EINTR) {\n+            return IOS_INTERRUPTED;\n+        }\n+        return handleSocketError(env, errno);\n+    }\n+    return 1;\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_sun_nio_ch_UnixDomainSockets_accept0(JNIEnv *env, jclass clazz, jobject fdo, jobject newfdo,\n+                                          jobjectArray array)\n+{\n+    jint fd = fdval(env, fdo);\n+    jint newfd;\n+    struct sockaddr_un sa;\n+    socklen_t sa_len = sizeof(struct sockaddr_un);\n+    jbyteArray address;\n+\n+    newfd = accept(fd, (struct sockaddr *)&sa, &sa_len);\n+    if (newfd < 0) {\n+        if (errno == EAGAIN || errno == EWOULDBLOCK)\n+            return IOS_UNAVAILABLE;\n+        if (errno == EINTR)\n+            return IOS_INTERRUPTED;\n+        JNU_ThrowIOExceptionWithLastError(env, \"Accept failed\");\n+        return IOS_THROWN;\n+    }\n+\n+    setfdval(env, newfdo, newfd);\n+\n+    address = sockaddrToUnixAddressBytes(env, &sa, sa_len);\n+    CHECK_NULL_RETURN(address, IOS_THROWN);\n+\n+    (*env)->SetObjectArrayElement(env, array, 0, address);\n+\n+    return 1;\n+}\n+\n+JNIEXPORT jbyteArray JNICALL\n+Java_sun_nio_ch_UnixDomainSockets_localAddress0(JNIEnv *env, jclass clazz, jobject fdo)\n+{\n+    struct sockaddr_un sa;\n+    socklen_t sa_len = sizeof(struct sockaddr_un);\n+    int port;\n+    if (getsockname(fdval(env, fdo), (struct sockaddr *)&sa, &sa_len) < 0) {\n+        handleSocketError(env, errno);\n+        return NULL;\n+    }\n+    return sockaddrToUnixAddressBytes(env, &sa, sa_len);\n+}\n+\n","filename":"src\/java.base\/unix\/native\/libnio\/ch\/UnixDomainSockets.c","additions":194,"deletions":0,"binary":false,"changes":194,"status":"added"},{"patch":"@@ -32,0 +32,1 @@\n+#include <sys\/un.h>\n@@ -50,0 +51,6 @@\n+\/* 2 bytes to allow for null at end of string and null at start of string\n+ * for abstract name\n+ *\/\n+#define MAX_UNIX_DOMAIN_PATH_LEN \\\n+        (int)(sizeof(((struct sockaddr_un *)0)->sun_path)-2)\n+\n@@ -65,0 +72,12 @@\n+\n+\/* Defined in UnixDomainSockets.c *\/\n+\n+jbyteArray sockaddrToUnixAddressBytes(JNIEnv *env,\n+                                      struct sockaddr_un *sa,\n+                                      socklen_t len);\n+\n+jint unixSocketAddressToSockaddr(JNIEnv *env,\n+                                jbyteArray uaddr,\n+                                struct sockaddr_un *sa,\n+                                int *len);\n+\n","filename":"src\/java.base\/unix\/native\/libnio\/ch\/nio_util.h","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,4 @@\n+import java.net.SocketAddress;\n+import java.net.UnixDomainSocketAddress;\n+import java.net.StandardProtocolFamily;\n+import java.net.StandardSocketOptions;\n@@ -36,0 +40,2 @@\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n@@ -58,2 +64,2 @@\n-    private SourceChannel source;\n-    private SinkChannel sink;\n+    private final SourceChannel source;\n+    private final SinkChannel sink;\n@@ -66,2 +72,3 @@\n-\n-        private IOException ioe = null;\n+        private IOException ioe;\n+        SourceChannelImpl source;\n+        SinkChannelImpl sink;\n@@ -106,0 +113,2 @@\n+                \/\/ Loopback address\n+                SocketAddress sa = null;\n@@ -112,4 +121,0 @@\n-                    \/\/ Loopback address\n-                    InetAddress lb = InetAddress.getLoopbackAddress();\n-                    assert(lb.isLoopbackAddress());\n-                    InetSocketAddress sa = null;\n@@ -120,3 +125,2 @@\n-                            ssc = ServerSocketChannel.open();\n-                            ssc.socket().bind(new InetSocketAddress(lb, 0));\n-                            sa = new InetSocketAddress(lb, ssc.socket().getLocalPort());\n+                            ssc = createListener();\n+                            sa = ssc.getLocalAddress();\n@@ -163,0 +167,4 @@\n+                        if (sa instanceof UnixDomainSocketAddress) {\n+                            Path path = ((UnixDomainSocketAddress) sa).getPath();\n+                            Files.deleteIfExists(path);\n+                        }\n@@ -169,1 +177,16 @@\n-    PipeImpl(final SelectorProvider sp) throws IOException {\n+    \/**\n+     * Creates a Pipe implementation that supports buffering.\n+     *\/\n+    PipeImpl(SelectorProvider sp) throws IOException {\n+        this(sp, true);\n+    }\n+\n+    \/**\n+     * Creates Pipe implementation that supports optionally buffering.\n+     *\n+     * @implNote The pipe uses Unix domain sockets where possible. It uses a\n+     * loopback connection on older editions of Windows. When buffering is\n+     * disabled then it sets TCP_NODELAY on the sink channel.\n+     *\/\n+    PipeImpl(SelectorProvider sp, boolean buffering) throws IOException {\n+        Initializer initializer = new Initializer(sp);\n@@ -171,3 +194,7 @@\n-            AccessController.doPrivileged(new Initializer(sp));\n-        } catch (PrivilegedActionException x) {\n-            throw (IOException)x.getCause();\n+            AccessController.doPrivileged(initializer);\n+            SinkChannelImpl sink = initializer.sink;\n+            if (sink.isNetSocket() && !buffering) {\n+                sink.setOption(StandardSocketOptions.TCP_NODELAY, true);\n+            }\n+        } catch (PrivilegedActionException pae) {\n+            throw (IOException) pae.getCause();\n@@ -175,0 +202,2 @@\n+        this.source = initializer.source;\n+        this.sink = initializer.sink;\n@@ -185,0 +214,21 @@\n+    private static volatile boolean noUnixDomainSockets;\n+\n+    private static ServerSocketChannel createListener() throws IOException {\n+        ServerSocketChannel listener = null;\n+        if (!noUnixDomainSockets) {\n+            try {\n+                listener = ServerSocketChannel.open(StandardProtocolFamily.UNIX);\n+                return listener.bind(null);\n+            } catch (UnsupportedOperationException | IOException e) {\n+                \/\/ IOException is most likely to be caused by the temporary directory\n+                \/\/ name being too long. Possibly should log this.\n+                noUnixDomainSockets = true;\n+                if (listener != null)\n+                    listener.close();\n+            }\n+        }\n+        listener = ServerSocketChannel.open();\n+        InetAddress lb = InetAddress.getLoopbackAddress();\n+        listener.bind(new InetSocketAddress(lb, 0));\n+        return listener;\n+    }\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/ch\/PipeImpl.java","additions":66,"deletions":16,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+import java.net.SocketOption;\n@@ -47,1 +48,1 @@\n-    final SocketChannel sc;\n+    private final SocketChannelImpl sc;\n@@ -50,1 +51,1 @@\n-        return ((SocketChannelImpl)sc).getFD();\n+        return sc.getFD();\n@@ -54,1 +55,1 @@\n-        return ((SocketChannelImpl)sc).getFDVal();\n+        return sc.getFDVal();\n@@ -59,1 +60,9 @@\n-        this.sc = sc;\n+        this.sc = (SocketChannelImpl) sc;\n+    }\n+\n+    boolean isNetSocket() {\n+        return sc.isNetSocket();\n+    }\n+\n+    <T> void setOption(SocketOption<T> name, T value) throws IOException {\n+        sc.setOption(name, value);\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/ch\/SinkChannelImpl.java","additions":14,"deletions":5,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 2002, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.nio.ch;\n+\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n+import sun.net.NetProperties;\n+import jdk.internal.util.StaticProperty;\n+\n+class UnixDomainSocketsUtil {\n+    private UnixDomainSocketsUtil() { }\n+\n+    static Charset getCharset() {\n+        return StandardCharsets.UTF_8;\n+    }\n+\n+    \/**\n+     * Return the temp directory for storing automatically bound\n+     * server sockets.\n+     *\n+     * On Windows we search the following directories in sequence:\n+     *\n+     * 1. ${jdk.net.unixdomain.tmpdir} if set as system property\n+     * 2. ${jdk.net.unixdomain.tmpdir} if set as net property\n+     * 3. %TEMP%\n+     * 4. ${java.io.tmpdir}\n+     *\/\n+    static String getTempDir() {\n+        PrivilegedAction<String> action = () -> {\n+            String s = NetProperties.get(\"jdk.net.unixdomain.tmpdir\");\n+            if (s != null) {\n+                return s;\n+            }\n+            String temp = System.getenv(\"TEMP\");\n+            if (temp != null) {\n+                return temp;\n+            }\n+            return StaticProperty.javaIoTmpDir();\n+        };\n+        return AccessController.doPrivileged(action);\n+    }\n+}\n+\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/ch\/UnixDomainSocketsUtil.java","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+import java.nio.channels.SelectableChannel;\n@@ -142,1 +143,1 @@\n-        wakeupPipe = Pipe.open();\n+        wakeupPipe = new PipeImpl(sp, false);\n@@ -147,1 +148,0 @@\n-        (sink.sc).socket().setTcpNoDelay(true);\n@@ -416,1 +416,1 @@\n-                SelectionKeyImpl sk = me.ski;\n+                SelectionKeyImpl ski = me.ski;\n@@ -421,4 +421,4 @@\n-                if (isExceptFds &&\n-                    (sk.channel() instanceof SocketChannelImpl) &&\n-                    discardUrgentData(desc))\n-                {\n+                SelectableChannel sc = ski.channel();\n+                if (isExceptFds && (sc instanceof SocketChannelImpl)\n+                        && ((SocketChannelImpl) sc).isNetSocket()\n+                        && discardUrgentData(desc)) {\n@@ -428,1 +428,1 @@\n-                int updated = processReadyEvents(rOps, sk, action);\n+                int updated = processReadyEvents(rOps, ski, action);\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/ch\/WindowsSelectorImpl.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+import java.nio.charset.StandardCharsets;\n@@ -625,0 +626,8 @@\n+\n+    @Override\n+    public byte[] getSunPathForSocketFile(Path obj) {\n+        WindowsPath file = WindowsPath.toWindowsPath(obj);\n+        String s = file.toString();\n+        return s.getBytes(StandardCharsets.UTF_8);\n+    }\n+\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/fs\/WindowsFileSystemProvider.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,19 @@\n+#\n+# Default directory where automatically bound Unix domain server\n+# sockets are stored. Sockets are automatically bound when bound\n+# with a null address.\n+#\n+# The search order for the directory on Windows is:\n+#\n+# 1. System property \"jdk.net.unixdomain.tmpdir\"\n+#\n+# 2. Networking property \"jdk.net.unixdomain.tmpdir\" specified\n+#    in this file (not set by default)\n+#\n+# 3. The TEMP environment variable (the effective default)\n+#\n+# 4. The java.io.tmpdir system property\n+#\n+#jdk.net.unixdomain.tmpdir=\n+#\n+\n","filename":"src\/java.base\/windows\/conf\/net.properties","additions":19,"deletions":0,"binary":false,"changes":19,"status":"added"},{"patch":"@@ -0,0 +1,196 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <windows.h>\n+#include <winsock2.h>\n+\n+#include \"jni.h\"\n+#include \"jni_util.h\"\n+#include \"jvm.h\"\n+#include \"jlong.h\"\n+#include \"nio.h\"\n+#include \"nio_util.h\"\n+#include \"net_util.h\"\n+\n+#include \"java_net_InetAddress.h\"\n+#include \"sun_nio_ch_Net.h\"\n+#include \"sun_nio_ch_PollArrayWrapper.h\"\n+\n+jbyteArray sockaddrToUnixAddressBytes(JNIEnv *env, struct sockaddr_un *sa, socklen_t len)\n+{\n+    if (sa->sun_family == AF_UNIX) {\n+        int namelen = (int)strlen(sa->sun_path);\n+        jbyteArray name = (*env)->NewByteArray(env, namelen);\n+        if (name != NULL) {\n+            (*env)->SetByteArrayRegion(env, name, 0, namelen, (jbyte*)sa->sun_path);\n+            if ((*env)->ExceptionOccurred(env)) {\n+                return NULL;\n+            }\n+        }\n+        return name;\n+    }\n+    return NULL;\n+}\n+\n+jint unixSocketAddressToSockaddr(JNIEnv *env, jbyteArray addr, struct sockaddr_un *sa, int *len)\n+{\n+    memset(sa, 0, sizeof(struct sockaddr_un));\n+    sa->sun_family = AF_UNIX;\n+    if (addr == 0L) {\n+        \/* Do explicit bind on Windows *\/\n+        *len = (int)(offsetof(struct sockaddr_un, sun_path));\n+        return 0;\n+    }\n+    int ret;\n+    jboolean isCopy;\n+    char *pname = (*env)->GetByteArrayElements(env, addr, &isCopy);\n+    if (pname == NULL) {\n+        JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\", \"Unix domain path not present\");\n+        return -1;\n+    }\n+\n+    size_t name_len = (size_t)(*env)->GetArrayLength(env, addr);\n+    if (name_len > MAX_UNIX_DOMAIN_PATH_LEN) {\n+        JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\", \"Unix domain path too long\");\n+        ret = -1;\n+    } else {\n+        strncpy(sa->sun_path, pname, name_len);\n+        *len = (int)(offsetof(struct sockaddr_un, sun_path) + name_len);\n+        ret = 0;\n+    }\n+    (*env)->ReleaseByteArrayElements(env, addr, pname, JNI_ABORT);\n+    return ret;\n+}\n+\n+JNIEXPORT jboolean JNICALL\n+Java_sun_nio_ch_UnixDomainSockets_socketSupported(JNIEnv *env, jclass cl)\n+{\n+    SOCKET s = socket(PF_UNIX, SOCK_STREAM, 0);\n+    if (s == INVALID_SOCKET) {\n+        return JNI_FALSE;\n+    }\n+    closesocket(s);\n+    return JNI_TRUE;\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_sun_nio_ch_UnixDomainSockets_socket0(JNIEnv *env, jclass cl)\n+{\n+    SOCKET s = socket(PF_UNIX, SOCK_STREAM, 0);\n+    if (s == INVALID_SOCKET) {\n+        return handleSocketError(env, WSAGetLastError());\n+    }\n+    SetHandleInformation((HANDLE)s, HANDLE_FLAG_INHERIT, 0);\n+    return (int)s;\n+}\n+\n+\/**\n+ * Windows does not support auto bind. So, the windows version of unixSocketAddressToSockaddr\n+ * looks out for a null 'uaddr' and handles it specially\n+ *\/\n+JNIEXPORT void JNICALL\n+Java_sun_nio_ch_UnixDomainSockets_bind0(JNIEnv *env, jclass clazz, jobject fdo, jbyteArray addr)\n+{\n+    struct sockaddr_un sa;\n+    int sa_len = 0;\n+    int rv = 0;\n+\n+    if (unixSocketAddressToSockaddr(env, addr, &sa, &sa_len) != 0)\n+        return;\n+\n+    rv = bind(fdval(env, fdo), (struct sockaddr *)&sa, sa_len);\n+    if (rv == SOCKET_ERROR) {\n+        int err = WSAGetLastError();\n+        NET_ThrowNew(env, err, \"bind\");\n+    }\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_sun_nio_ch_UnixDomainSockets_connect0(JNIEnv *env, jclass clazz, jobject fdo, jbyteArray addr)\n+{\n+    struct sockaddr_un sa;\n+    int sa_len = 0;\n+    int rv;\n+\n+    if (unixSocketAddressToSockaddr(env, addr, &sa, &sa_len) != 0) {\n+        return IOS_THROWN;\n+    }\n+\n+    rv = connect(fdval(env, fdo), (const struct sockaddr *)&sa, sa_len);\n+    if (rv != 0) {\n+        int err = WSAGetLastError();\n+        if (err == WSAEINPROGRESS || err == WSAEWOULDBLOCK) {\n+            return IOS_UNAVAILABLE;\n+        }\n+        NET_ThrowNew(env, err, \"connect\");\n+        return IOS_THROWN;\n+    }\n+    return 1;\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_sun_nio_ch_UnixDomainSockets_accept0(JNIEnv *env, jclass clazz, jobject fdo, jobject newfdo,\n+                                          jobjectArray array)\n+{\n+    jint fd = fdval(env, fdo);\n+    jint newfd;\n+    struct sockaddr_un sa;\n+    socklen_t sa_len = sizeof(sa);\n+    jbyteArray address;\n+\n+    memset((char *)&sa, 0, sizeof(sa));\n+    newfd = (jint) accept(fd, (struct sockaddr *)&sa, &sa_len);\n+    if (newfd == INVALID_SOCKET) {\n+        int theErr = (jint)WSAGetLastError();\n+        if (theErr == WSAEWOULDBLOCK) {\n+            return IOS_UNAVAILABLE;\n+        }\n+        JNU_ThrowIOExceptionWithLastError(env, \"Accept failed\");\n+        return IOS_THROWN;\n+    }\n+\n+    SetHandleInformation((HANDLE)(UINT_PTR)newfd, HANDLE_FLAG_INHERIT, 0);\n+    setfdval(env, newfdo, newfd);\n+\n+    address = sockaddrToUnixAddressBytes(env, &sa, sa_len);\n+    CHECK_NULL_RETURN(address, IOS_THROWN);\n+    (*env)->SetObjectArrayElement(env, array, 0, address);\n+\n+    return 1;\n+}\n+\n+JNIEXPORT jbyteArray JNICALL\n+Java_sun_nio_ch_UnixDomainSockets_localAddress0(JNIEnv *env, jclass clazz, jobject fdo)\n+{\n+    struct sockaddr_un sa;\n+    int sa_len = sizeof(sa);\n+\n+    if (getsockname(fdval(env, fdo), (struct sockaddr *)&sa, &sa_len) == SOCKET_ERROR) {\n+        JNU_ThrowIOExceptionWithLastError(env, \"getsockname\");\n+        return NULL;\n+    }\n+    return sockaddrToUnixAddressBytes(env, &sa, sa_len);\n+}\n+\n","filename":"src\/java.base\/windows\/native\/libnio\/ch\/UnixDomainSockets.c","additions":196,"deletions":0,"binary":false,"changes":196,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,2 @@\n+#include <ws2tcpip.h>\n+#include <afunix.h>\n@@ -38,0 +40,3 @@\n+#define MAX_UNIX_DOMAIN_PATH_LEN \\\n+        (int)(sizeof(((struct sockaddr_un *)0)->sun_path)-2)\n+\n@@ -77,0 +82,8 @@\n+\n+\/* Defined in UnixDomainSockets.c *\/\n+\n+jbyteArray sockaddrToUnixAddressBytes(JNIEnv *env, struct sockaddr_un *sa, socklen_t len);\n+\n+jint unixSocketAddressToSockaddr(JNIEnv *env, jbyteArray uaddr,\n+                                struct sockaddr_un *sa, int *len);\n+\n","filename":"src\/java.base\/windows\/native\/libnio\/ch\/nio_util.h","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -30,0 +30,2 @@\n+import java.net.SocketAddress;\n+import java.net.UnixDomainSocketAddress;\n@@ -31,1 +33,0 @@\n-\n@@ -44,2 +45,0 @@\n-    private InetSocketAddress remoteAddress;\n-\n@@ -61,2 +60,5 @@\n-                String hostString  = remoteAddress.getAddress().toString();\n-                int delimiterIndex = hostString.lastIndexOf('\/');\n+                SocketAddress remoteAddress = getRemoteAddress();\n+                if (remoteAddress instanceof InetSocketAddress) {\n+                    InetSocketAddress isa = (InetSocketAddress) remoteAddress;\n+                    String hostString  = isa.getAddress().toString();\n+                    int delimiterIndex = hostString.lastIndexOf('\/');\n@@ -64,5 +66,8 @@\n-                String host = hostString.substring(0, delimiterIndex);\n-                String address = hostString.substring(delimiterIndex + 1);\n-                int port = remoteAddress.getPort();\n-                if (bytesRead < 0) {\n-                    handler.write(start, duration, host, address, port, 0, 0L, true);\n+                    String host = hostString.substring(0, delimiterIndex);\n+                    String address = hostString.substring(delimiterIndex + 1);\n+                    int port = isa.getPort();\n+                    if (bytesRead < 0) {\n+                        handler.write(start, duration, host, address, port, 0, 0L, true);\n+                    } else {\n+                        handler.write(start, duration, host, address, port, 0, bytesRead, false);\n+                    }\n@@ -70,1 +75,7 @@\n-                    handler.write(start, duration, host, address, port, 0, bytesRead, false);\n+                    UnixDomainSocketAddress udsa = (UnixDomainSocketAddress) remoteAddress;\n+                    String path = \"[\" + udsa.getPath().toString() + \"]\";\n+                    if (bytesRead < 0) {\n+                        handler.write(start, duration, \"Unix domain socket\", path, 0, 0, 0L, true);\n+                    } else {\n+                        handler.write(start, duration, \"Unix domain socket\", path, 0, 0, bytesRead, false);\n+                    }\n@@ -84,1 +95,0 @@\n-\n@@ -93,2 +103,5 @@\n-                String hostString  = remoteAddress.getAddress().toString();\n-                int delimiterIndex = hostString.lastIndexOf('\/');\n+                SocketAddress remoteAddress = getRemoteAddress();\n+                if (remoteAddress instanceof InetSocketAddress) {\n+                    InetSocketAddress isa = (InetSocketAddress) remoteAddress;\n+                    String hostString  = isa.getAddress().toString();\n+                    int delimiterIndex = hostString.lastIndexOf('\/');\n@@ -96,5 +109,8 @@\n-                String host = hostString.substring(0, delimiterIndex);\n-                String address = hostString.substring(delimiterIndex + 1);\n-                int port = remoteAddress.getPort();\n-                if (bytesRead < 0) {\n-                    handler.write(start, duration, host, address, port, 0, 0L, true);\n+                    String host = hostString.substring(0, delimiterIndex);\n+                    String address = hostString.substring(delimiterIndex + 1);\n+                    int port = isa.getPort();\n+                    if (bytesRead < 0) {\n+                        handler.write(start, duration, host, address, port, 0, 0L, true);\n+                    } else {\n+                        handler.write(start, duration, host, address, port, 0, bytesRead, false);\n+                    }\n@@ -102,1 +118,7 @@\n-                    handler.write(start, duration, host, address, port, 0, bytesRead, false);\n+                    UnixDomainSocketAddress udsa = (UnixDomainSocketAddress) remoteAddress;\n+                    String path = \"[\" + udsa.getPath().toString() + \"]\";\n+                    if (bytesRead < 0) {\n+                        handler.write(start, duration, \"Unix domain socket\", path, 0, 0, 0L, true);\n+                    } else {\n+                        handler.write(start, duration, \"Unix domain socket\", path, 0, 0, bytesRead, false);\n+                    }\n@@ -124,6 +146,0 @@\n-                String hostString  = remoteAddress.getAddress().toString();\n-                int delimiterIndex = hostString.lastIndexOf('\/');\n-\n-                String host = hostString.substring(0, delimiterIndex);\n-                String address = hostString.substring(delimiterIndex + 1);\n-                int port = remoteAddress.getPort();\n@@ -131,1 +147,15 @@\n-                handler.write(start, duration, host, address, port, bytes);\n+                SocketAddress remoteAddress = getRemoteAddress();\n+                if (remoteAddress instanceof InetSocketAddress) {\n+                    InetSocketAddress isa = (InetSocketAddress) remoteAddress;\n+                    String hostString  = isa.getAddress().toString();\n+                    int delimiterIndex = hostString.lastIndexOf('\/');\n+\n+                    String host = hostString.substring(0, delimiterIndex);\n+                    String address = hostString.substring(delimiterIndex + 1);\n+                    int port = isa.getPort();\n+                    handler.write(start, duration, host, address, port, bytes);\n+                } else {\n+                    UnixDomainSocketAddress udsa = (UnixDomainSocketAddress) remoteAddress;\n+                    String path = \"[\" + udsa.getPath().toString() + \"]\";\n+                    handler.write(start, duration, \"Unix domain socket\", path, 0, bytes);\n+                }\n@@ -137,0 +167,5 @@\n+    public SocketAddress getRemoteAddress() throws IOException {\n+        \/\/ gets replaced by call to instrumented class\n+        return null;\n+    }\n+\n@@ -152,6 +187,0 @@\n-                String hostString  = remoteAddress.getAddress().toString();\n-                int delimiterIndex = hostString.lastIndexOf('\/');\n-\n-                String host = hostString.substring(0, delimiterIndex);\n-                String address = hostString.substring(delimiterIndex + 1);\n-                int port = remoteAddress.getPort();\n@@ -159,1 +188,15 @@\n-                handler.write(start, duration, host, address, port, bytes);\n+                SocketAddress remoteAddress = getRemoteAddress();\n+                if (remoteAddress instanceof InetSocketAddress) {\n+                    InetSocketAddress isa = (InetSocketAddress) remoteAddress;\n+                    String hostString  = isa.getAddress().toString();\n+                    int delimiterIndex = hostString.lastIndexOf('\/');\n+\n+                    String host = hostString.substring(0, delimiterIndex);\n+                    String address = hostString.substring(delimiterIndex + 1);\n+                    int port = isa.getPort();\n+                    handler.write(start, duration, host, address, port, bytes);\n+                } else {\n+                    UnixDomainSocketAddress udsa = (UnixDomainSocketAddress) remoteAddress;\n+                    String path = \"[\" + udsa.getPath().toString() + \"]\";\n+                    handler.write(start, duration, \"Unix domain socket\", path, 0, bytes);\n+                }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/instrument\/SocketChannelImplInstrumentor.java","additions":77,"deletions":34,"binary":false,"changes":111,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import java.nio.file.attribute.UserPrincipal;\n+import java.nio.file.attribute.GroupPrincipal;\n@@ -31,0 +33,1 @@\n+import sun.nio.fs.UnixUserPrincipals;\n@@ -57,0 +60,4 @@\n+    boolean peerCredentialsSupported() {\n+        return true;\n+    }\n+\n@@ -97,0 +104,10 @@\n+    @Override\n+    UnixDomainPrincipal getSoPeerCred(int fd) throws SocketException {\n+        long l = getSoPeerCred0(fd);\n+        int uid = (int)(l >> 32);\n+        int gid = (int)l;\n+        UserPrincipal user = UnixUserPrincipals.fromUid(uid);\n+        GroupPrincipal group = UnixUserPrincipals.fromGid(gid);\n+        return new UnixDomainPrincipal(user, group);\n+    }\n+\n@@ -105,0 +122,1 @@\n+    private static native long getSoPeerCred0(int fd) throws SocketException;\n","filename":"src\/jdk.net\/linux\/classes\/jdk\/net\/LinuxSocketOptions.java","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -26,0 +26,2 @@\n+#include <sys\/un.h>\n+#include <sys\/types.h>\n@@ -112,0 +114,23 @@\n+\/*\n+ * Class:     jdk_net_LinuxSocketOptions\n+ * Method:    getSoPeerCred0\n+ * Signature: (I)L\n+ *\/\n+JNIEXPORT jlong JNICALL Java_jdk_net_LinuxSocketOptions_getSoPeerCred0\n+  (JNIEnv *env, jclass clazz, jint fd) {\n+\n+    int rv;\n+    struct ucred cred;\n+    socklen_t len = sizeof(cred);\n+\n+    if ((rv=getsockopt(fd, SOL_SOCKET, SO_PEERCRED, &cred, &len)) < 0) {\n+        handleError(env, rv, \"get SO_PEERCRED failed\");\n+    } else {\n+        if ((int)cred.uid == -1) {\n+            handleError(env, -1, \"get SO_PEERCRED failed\");\n+            cred.uid = cred.gid = -1;\n+        }\n+    }\n+    return (((long)cred.uid) << 32) | (cred.gid & 0xffffffffL);\n+}\n+\n","filename":"src\/jdk.net\/linux\/native\/libextnet\/LinuxSocketOptions.c","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import java.nio.file.attribute.UserPrincipal;\n+import java.nio.file.attribute.GroupPrincipal;\n@@ -31,0 +33,1 @@\n+import sun.nio.fs.UnixUserPrincipals;\n@@ -52,0 +55,5 @@\n+    @Override\n+    boolean peerCredentialsSupported() {\n+        return true;\n+    }\n+\n@@ -72,0 +80,10 @@\n+    @Override\n+    UnixDomainPrincipal getSoPeerCred(int fd) throws SocketException {\n+        long l = getSoPeerCred0(fd);\n+        int uid = (int)(l >> 32);\n+        int gid = (int)l;\n+        UserPrincipal user = UnixUserPrincipals.fromUid(uid);\n+        GroupPrincipal group = UnixUserPrincipals.fromGid(gid);\n+        return new UnixDomainPrincipal(user, group);\n+    }\n+\n@@ -78,0 +96,1 @@\n+    private static native long getSoPeerCred0(int fd) throws SocketException;\n","filename":"src\/jdk.net\/macosx\/classes\/jdk\/net\/MacOSXSocketOptions.java","additions":20,"deletions":1,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+#include <sys\/types.h>\n@@ -126,0 +127,19 @@\n+\/*\n+ * Class:     jdk_net_MacOSXSocketOptions\n+ * Method:    getSoPeerCred0\n+ * Signature: (I)L\n+ *\/\n+JNIEXPORT jlong JNICALL Java_jdk_net_MacOSXSocketOptions_getSoPeerCred0\n+  (JNIEnv *env, jclass clazz, jint fd) {\n+\n+    jint rv;\n+    int uid, gid;\n+    rv = getpeereid(fd, (uid_t *)&uid, (gid_t *)&gid);\n+    handleError(env, rv, \"get peer eid failed\");\n+    if (rv == -1) {\n+        uid = gid = -1;\n+    }\n+    return (((long)uid) << 32) | (gid & 0xffffffffL);\n+}\n+\n+\n","filename":"src\/jdk.net\/macosx\/native\/libextnet\/MacOSXSocketOptions.c","additions":21,"deletions":1,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -183,0 +183,19 @@\n+    \/**\n+     * Unix Domain peer credentials.\n+     *\n+     * <p> The value of this socket option is a {@link UnixDomainPrincipal} that\n+     * represents the credentials of a peer connected to a Unix Domain socket.\n+     * The credentials are those that applied at the time the socket was first\n+     * connected or accepted.\n+     *\n+     * <p> The socket option is read-only and an attempt to set the socket option\n+     * will throw {@code SocketException}. {@code SocketException} is also thrown\n+     * when attempting to get the value of the socket option on an unconnected Unix\n+     * Domain socket.\n+     *\n+     * @since 16\n+     *\/\n+    public static final SocketOption<UnixDomainPrincipal> SO_PEERCRED\n+        = new ExtSocketOption<UnixDomainPrincipal>\n+            (\"SO_PEERCRED\", UnixDomainPrincipal.class);\n+\n@@ -190,0 +209,2 @@\n+    private static final boolean peerCredentialsSupported =\n+            platformSocketOptions.peerCredentialsSupported();\n@@ -205,0 +226,3 @@\n+        if (peerCredentialsSupported) {\n+            options.add(SO_PEERCRED);\n+        }\n@@ -236,0 +260,2 @@\n+                } else if (option == SO_PEERCRED) {\n+                    throw new SocketException(\"SO_PEERCRED cannot be set \");\n@@ -258,0 +284,2 @@\n+                } else if (option == SO_PEERCRED) {\n+                    return getSoPeerCred(fd);\n@@ -275,0 +303,5 @@\n+    private static Object getSoPeerCred(FileDescriptor fd)\n+            throws SocketException {\n+        return platformSocketOptions.getSoPeerCred(fdAccess.get(fd));\n+    }\n+\n@@ -348,0 +381,4 @@\n+        boolean peerCredentialsSupported() {\n+            return false;\n+        }\n+\n@@ -372,0 +409,4 @@\n+        UnixDomainPrincipal getSoPeerCred(int fd) throws SocketException {\n+            throw new UnsupportedOperationException(\"unsupported SO_PEERCRED option\");\n+        }\n+\n","filename":"src\/jdk.net\/share\/classes\/jdk\/net\/ExtendedSocketOptions.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -0,0 +1,98 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.net;\n+\n+import java.nio.file.attribute.UserPrincipal;\n+import java.nio.file.attribute.GroupPrincipal;\n+import java.util.Objects;\n+\n+\/**\n+ * Represents the credentials of a peer connected to a\n+ * <a href=\"..\/..\/..\/java.base\/java\/nio\/channels\/package-summary.html#unixdomain\">\n+ * Unix domain<\/a> socket.\n+ *\n+ * @since 16\n+ *\/\n+\n+public final class UnixDomainPrincipal {\n+    private final UserPrincipal user;\n+    private final GroupPrincipal group;\n+\n+    \/**\n+     * Creates a UnixDomainPrincipal.\n+     *\n+     * @param user the user identity\n+     *\n+     * @param group the group identity\n+     *\n+     * @throws NullPointerException if {@code user} or {@code group} are {@code null}.\n+     *\/\n+    public UnixDomainPrincipal(UserPrincipal user, GroupPrincipal group) {\n+        this.user = Objects.requireNonNull(user);\n+        this.group = Objects.requireNonNull(group);\n+    }\n+\n+    \/**\n+     * Returns true if {@code obj} is a {@code UnixDomainPrincipal}\n+     * and its user and group are equal to this user and group.\n+     *\n+     * @param obj the object to compare with\n+     * @return true if this equal to obj\n+     *\/\n+    public boolean equals(Object obj) {\n+        if (obj instanceof UnixDomainPrincipal) {\n+            UnixDomainPrincipal that = (UnixDomainPrincipal) obj;\n+            return Objects.equals(this.user, that.user)\n+                    && Objects.equals(this.group, that.group);\n+        }\n+        return false;\n+    }\n+\n+    \/**\n+     * Returns a hashcode calculated from the user and group\n+     *\/\n+    public int hashCode() {\n+        return Objects.hash(user, group);\n+    }\n+\n+    \/**\n+     * Returns this object's {@link UserPrincipal}\n+     *\n+     * @return this object's user\n+     *\/\n+    public UserPrincipal user() {\n+        return user;\n+    }\n+\n+    \/**\n+     * Returns this object's {@link GroupPrincipal}\n+     *\n+     * @return this object's user\n+     *\/\n+    public GroupPrincipal group() {\n+        return group;\n+    }\n+}\n","filename":"src\/jdk.net\/share\/classes\/jdk\/net\/UnixDomainPrincipal.java","additions":98,"deletions":0,"binary":false,"changes":98,"status":"added"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8231358\n+ * @compile ..\/..\/nio\/file\/spi\/TestProvider.java AddressTest.java\n+ * @run testng\/othervm AddressTest\n+ *\/\n+\n+import java.net.UnixDomainSocketAddress;\n+import java.net.URI;\n+import java.nio.file.FileSystems;\n+import java.nio.file.spi.FileSystemProvider;\n+import java.nio.file.Path;\n+\n+import org.testng.annotations.Test;\n+\n+import static org.testng.Assert.assertThrows;\n+\n+\/**\n+ * Verify that UnixDomainSocketAddress.of(path) throws IAE\n+ * if given a Path that does not originate from system default\n+ * file system.\n+ *\/\n+public class AddressTest {\n+\n+    \/\/ Expected exception\n+    private static final Class<IllegalArgumentException> IAE =\n+        IllegalArgumentException.class;\n+\n+    @Test\n+    public static void runTest() throws Exception {\n+        TestProvider prov = new TestProvider(FileSystems.getDefault().provider());\n+        Path path = prov.getPath(URI.create(\"file:\/\"));\n+        assertThrows(IAE, () -> UnixDomainSocketAddress.of(path));\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/UnixDomainSocketAddress\/AddressTest.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -0,0 +1,102 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Test UnixDomainSocketAddress constructor\n+ * @library \/test\/lib\n+ * @run testng\/othervm LengthTest\n+ *\/\n+\n+import org.testng.annotations.BeforeTest;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import static java.lang.System.out;\n+import static java.net.StandardProtocolFamily.UNIX;\n+import static jdk.test.lib.Asserts.assertTrue;\n+\n+import java.net.UnixDomainSocketAddress;\n+import java.io.IOException;\n+import java.nio.channels.SocketChannel;\n+import java.nio.file.Path;\n+\n+public class LengthTest {\n+    static boolean supported = true;\n+    final int namelen = 100;    \/\/ length close to max\n+\n+    @BeforeTest\n+    public void setup() {\n+        try {\n+            SocketChannel.open(UNIX);\n+        }\n+        catch (IOException | UnsupportedOperationException e) {\n+            supported = false;\n+            out.println(\"Unix domain channels not supported. Test not run.\");\n+        }\n+    }\n+\n+    @DataProvider(name = \"strings\")\n+    public Object[][] strings() {\n+        if (namelen == -1)\n+            return new Object[][] {new String[]{\"\"}};\n+\n+        return new Object[][]{\n+                {\"\"},\n+                {new String(new char[100]).replaceAll(\"\\0\", \"x\")},\n+                {new String(new char[namelen]).replaceAll(\"\\0\", \"x\")},\n+                {new String(new char[namelen-1]).replaceAll(\"\\0\", \"x\")},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"strings\")\n+    public void expectPass(String s) {\n+        if (supported) {\n+            var addr = UnixDomainSocketAddress.of(s);\n+            assertTrue(addr.getPath().toString().equals(s), \"getPathName.equals(s)\");\n+            var p = Path.of(s);\n+            addr = UnixDomainSocketAddress.of(p);\n+            assertTrue(addr.getPath().equals(p), \"getPath.equals(p)\");\n+        }\n+    }\n+\n+    @Test\n+    public void expectNPE() {\n+        if (supported) {\n+            try {\n+                String s = null;\n+                UnixDomainSocketAddress.of(s);\n+                throw new RuntimeException(\"Expected NPE\");\n+            } catch (NullPointerException npe) {\n+                out.println(\"\\tCaught expected exception: \" + npe);\n+            }\n+            try {\n+                Path p = null;\n+                UnixDomainSocketAddress.of(p);\n+                throw new RuntimeException(\"Expected NPE\");\n+            } catch (NullPointerException npe) {\n+                out.println(\"\\tCaught expected exception: \" + npe);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/UnixDomainSocketAddress\/LengthTest.java","additions":102,"deletions":0,"binary":false,"changes":102,"status":"added"},{"patch":"@@ -0,0 +1,125 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.annotations.Test;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.io.InvalidObjectException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.ObjectStreamClass;\n+import java.io.Serializable;\n+import java.net.UnixDomainSocketAddress;\n+import java.nio.file.Path;\n+import static java.io.ObjectStreamConstants.*;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertTrue;\n+import static org.testng.Assert.expectThrows;\n+\n+\/*\n+ * @test\n+ * @summary UnixDomainSocketAddress serialization test\n+ * @run testng\/othervm UnixDomainSocketAddressSerializationTest\n+ *\/\n+\n+@Test\n+public class UnixDomainSocketAddressSerializationTest {\n+    private static final UnixDomainSocketAddress addr =\n+            UnixDomainSocketAddress.of(Path.of(\"test.sock\"));\n+\n+    public static void test() throws Exception {\n+        assertTrue(addr instanceof Serializable);\n+\n+        byte[] serialized = serialize(addr);\n+        assertTrue(serialized.length > 0);\n+\n+        UnixDomainSocketAddress deserialized =\n+                deserialize(serialized, UnixDomainSocketAddress.class);\n+        assertEquals(deserialized.getPath(), addr.getPath());\n+        assertEquals(deserialized.toString(), addr.toString());\n+        assertEquals(deserialized.hashCode(), addr.hashCode());\n+        assertEquals(deserialized, addr);\n+    }\n+\n+    static final Class<InvalidObjectException> IOE = InvalidObjectException.class;\n+    static final Class<NullPointerException> NPE = NullPointerException.class;\n+\n+    \/** Tests that UnixDomainSocketAddress in the byte-stream is disallowed. *\/\n+    public static void testUnixDomainSocketAddressInStream() throws Exception {\n+        long suid = ObjectStreamClass.lookup(UnixDomainSocketAddress.class).getSerialVersionUID();\n+        byte[] bytes = byteStreamFor(UnixDomainSocketAddress.class.getName(), suid);\n+        expectThrows(IOE, () -> deserialize(bytes, UnixDomainSocketAddress.class));\n+    }\n+\n+    \/** Tests that SerialProxy with a null\/absent path value in the byte-stream is disallowed. *\/\n+    public static void testSerialProxyNoStreamValues() throws Exception {\n+        Class<?> c = Class.forName(\"java.net.UnixDomainSocketAddress$Ser\");\n+        long suid = ObjectStreamClass.lookup(c).getSerialVersionUID();\n+        byte[] bytes = byteStreamFor(c.getName(), suid);\n+        expectThrows(NPE, () -> deserialize(bytes, UnixDomainSocketAddress.class));\n+    }\n+\n+    private static <T extends Serializable> byte[] serialize(T t)\n+            throws IOException {\n+        ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+        ObjectOutputStream oos = new ObjectOutputStream(bos);\n+        oos.writeObject(t);\n+        oos.flush();\n+        oos.close();\n+        return bos.toByteArray();\n+    }\n+\n+    private static <T extends Serializable> T deserialize(byte[] b, Class<T> cl)\n+            throws IOException, ClassNotFoundException {\n+        try (ObjectInputStream ois =\n+                     new ObjectInputStream(new ByteArrayInputStream(b))) {\n+            Object o = ois.readObject();\n+            return cl.cast(o);\n+        }\n+    }\n+\n+    \/**\n+     * Returns a stream with the given classname and suid. The stream will have\n+     * no stream field values.\n+     *\/\n+    static byte[] byteStreamFor(String classname, long suid) throws Exception {\n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        DataOutputStream dos = new DataOutputStream(baos);\n+        dos.writeShort(STREAM_MAGIC);\n+        dos.writeShort(STREAM_VERSION);\n+        dos.writeByte(TC_OBJECT);\n+        dos.writeByte(TC_CLASSDESC);\n+        dos.writeUTF(classname);\n+        dos.writeLong(suid);\n+        dos.writeByte(SC_SERIALIZABLE);\n+        dos.writeShort(0);                \/\/ number of stream fields\n+        dos.writeByte(TC_ENDBLOCKDATA);   \/\/ no annotations\n+        dos.writeByte(TC_NULL);           \/\/ no superclasses\n+        dos.write(TC_ENDBLOCKDATA);       \/\/ end block - for SC_WRITE_METHOD\n+        dos.close();\n+        return baos.toByteArray();\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/UnixDomainSocketAddress\/UnixDomainSocketAddressSerializationTest.java","additions":125,"deletions":0,"binary":false,"changes":125,"status":"added"},{"patch":"@@ -38,0 +38,1 @@\n+import static org.testng.Assert.assertEquals;\n@@ -308,1 +309,1 @@\n-        return family == null ? SocketChannel.open()\n+        SocketChannel sc = family == null ? SocketChannel.open()\n@@ -310,0 +311,1 @@\n+        return sc;\n@@ -314,1 +316,1 @@\n-        return family == null ? ServerSocketChannel.open()\n+        ServerSocketChannel ssc = family == null ? ServerSocketChannel.open()\n@@ -316,0 +318,1 @@\n+        return ssc;\n@@ -320,1 +323,1 @@\n-        return family == null ? DatagramChannel.open()\n+        DatagramChannel dc = family == null ? DatagramChannel.open()\n@@ -322,0 +325,1 @@\n+        return dc;\n@@ -328,0 +332,1 @@\n+            default -> throw new RuntimeException(\"Unexpected protocol family\");\n","filename":"test\/jdk\/java\/nio\/channels\/etc\/ProtocolFamilies.java","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,1 @@\n- * service then delays\/lingers for 15 seconds before shuting down. To\n+ * service then delays\/lingers for 15 seconds before shutting down. To\n@@ -57,2 +57,1 @@\n-\n-        SocketChannel sc = Launcher.launchWithSocketChannel(\"EchoService\", service_args);\n+        SocketChannel sc = Launcher.launchWithInetSocketChannel(\"EchoService\", null, service_args);\n","filename":"test\/jdk\/java\/nio\/channels\/spi\/SelectorProvider\/inheritedChannel\/CloseTest.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -61,1 +61,1 @@\n-        SocketChannel sc = Launcher.launchWithSocketChannel(ECHO_SERVICE, null);\n+        SocketChannel sc = Launcher.launchWithInetSocketChannel(ECHO_SERVICE, null);\n","filename":"test\/jdk\/java\/nio\/channels\/spi\/SelectorProvider\/inheritedChannel\/EchoTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -88,0 +88,1 @@\n+\n","filename":"test\/jdk\/java\/nio\/channels\/spi\/SelectorProvider\/inheritedChannel\/InheritedChannelTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1,1 +0,0 @@\n-\n@@ -3,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +31,3 @@\n+import java.net.SocketAddress;\n+import java.net.StandardProtocolFamily;\n+import java.net.UnixDomainSocketAddress;\n@@ -35,0 +37,3 @@\n+import java.nio.file.Files;\n+\n+import static java.net.StandardProtocolFamily.UNIX;\n@@ -66,1 +71,0 @@\n-\n@@ -68,3 +72,3 @@\n-     * Launch 'java' with specified class using a UnixDomainSocket pair linking calling\n-     * process to the child VM. UnixDomainSocket is a simplified interface to PF_UNIX sockets\n-     * which supports byte a time reads and writes.\n+     * Launch 'java' with specified class. The launched process will inherit\n+     * a connected Unix Domain socket. The remote endpoint will be the\n+     * SocketChannel returned by this method.\n@@ -72,5 +76,15 @@\n-    public static UnixDomainSocket launchWithUnixDomainSocket(String className) throws IOException {\n-        UnixDomainSocket[] socks = UnixDomainSocket.socketpair();\n-        launch(className, null, null, socks[0].fd());\n-        socks[0].close();\n-        return socks[1];\n+    public static SocketChannel launchWithUnixSocketChannel(String className)\n+            throws IOException\n+    {\n+        UnixDomainSocketAddress addr = null;\n+        try (ServerSocketChannel ssc = ServerSocketChannel.open(UNIX)) {\n+            addr = (UnixDomainSocketAddress)ssc.bind(null).getLocalAddress();\n+            SocketChannel sc1 = SocketChannel.open(addr);\n+            try (SocketChannel sc2 = ssc.accept()) {\n+                launch(className, null, null, Util.getFD(sc2));\n+            }\n+            return sc1;\n+        } finally {\n+            if (addr != null)\n+                Files.delete(addr.getPath());\n+        }\n@@ -80,9 +94,0 @@\n-     * Launch specified class with an AF_UNIX socket created externally, and one String arg to child VM\n-     *\/\n-    public static void launchWithUnixDomainSocket(String className, UnixDomainSocket socket, String arg) throws IOException {\n-        String[] args = new String[1];\n-        args[0] = arg;\n-        launch(className, null, args, socket.fd());\n-    }\n-\n-    \/*\n@@ -93,4 +98,8 @@\n-    public static SocketChannel launchWithSocketChannel(String className, String options[], String args[]) throws IOException {\n-        ServerSocketChannel ssc = ServerSocketChannel.open();\n-        ssc.socket().bind(new InetSocketAddress(InetAddress.getLocalHost(), 0));\n-        InetSocketAddress isa = new InetSocketAddress(InetAddress.getLocalHost(),\n+    public static SocketChannel launchWithInetSocketChannel(String className,\n+                                                        String options[],\n+                                                        String... args)\n+            throws IOException\n+    {\n+        try (ServerSocketChannel ssc = ServerSocketChannel.open()) {\n+            ssc.socket().bind(new InetSocketAddress(InetAddress.getLocalHost(), 0));\n+            InetSocketAddress isa = new InetSocketAddress(InetAddress.getLocalHost(),\n@@ -98,10 +107,6 @@\n-        SocketChannel sc1 = SocketChannel.open(isa);\n-        SocketChannel sc2 = ssc.accept();\n-        launch(className, options, args, Util.getFD(sc2));\n-        sc2.close();\n-        ssc.close();\n-        return sc1;\n-    }\n-\n-    public static SocketChannel launchWithSocketChannel(String className, String args[]) throws IOException {\n-        return launchWithSocketChannel(className, null, args);\n+            SocketChannel sc1 = SocketChannel.open(isa);\n+            try (SocketChannel sc2 = ssc.accept()) {\n+                launch(className, options, args, Util.getFD(sc2));\n+            }\n+            return sc1;\n+        }\n@@ -110,2 +115,8 @@\n-    public static SocketChannel launchWithSocketChannel(String className) throws IOException {\n-        return launchWithSocketChannel(className, null);\n+    \/**\n+     * Launch specified class with a SocketChannel created externally.\n+     *\/\n+    public static void launchWithSocketChannel(String className,\n+                                               SocketChannel sc,\n+                                               String[] options,\n+                                               String... args) throws Exception {\n+        launch(className, options, args, Util.getFD(sc));\n@@ -114,1 +125,1 @@\n-    \/*\n+    \/**\n@@ -120,2 +131,4 @@\n-    public static SocketChannel launchWithServerSocketChannel(String className, String options[], String args[])\n-        throws IOException\n+    public static SocketChannel launchWithInetServerSocketChannel(String className,\n+                                                              String[] options,\n+                                                              String... args)\n+            throws IOException\n@@ -123,7 +136,7 @@\n-        ServerSocketChannel ssc = ServerSocketChannel.open();\n-        ssc.socket().bind(new InetSocketAddress(InetAddress.getLocalHost(), 0));\n-        int port = ssc.socket().getLocalPort();\n-        launch(className, options, args, Util.getFD(ssc));\n-        ssc.close();\n-        InetSocketAddress isa = new InetSocketAddress(InetAddress.getLocalHost(), port);\n-        return SocketChannel.open(isa);\n+        try (ServerSocketChannel ssc = ServerSocketChannel.open()) {\n+            ssc.socket().bind(new InetSocketAddress(InetAddress.getLocalHost(), 0));\n+            int port = ssc.socket().getLocalPort();\n+            launch(className, options, args, Util.getFD(ssc));\n+            InetSocketAddress isa = new InetSocketAddress(InetAddress.getLocalHost(), port);\n+            return SocketChannel.open(isa);\n+        }\n@@ -132,2 +145,7 @@\n-    public static SocketChannel launchWithServerSocketChannel(String className, String args[]) throws IOException {\n-        return launchWithServerSocketChannel(className, null, args);\n+    public static SocketChannel launchWithUnixServerSocketChannel(String className) throws IOException {\n+        ServerSocketChannel ssc = ServerSocketChannel.open(StandardProtocolFamily.UNIX);\n+        ssc.bind(null);\n+        var addr = ssc.getLocalAddress();\n+        launch(className, null, null, Util.getFD(ssc));\n+        ssc.close();\n+        return SocketChannel.open(addr);\n@@ -136,2 +154,9 @@\n-    public static SocketChannel launchWithServerSocketChannel(String className) throws IOException {\n-        return launchWithServerSocketChannel(className, null);\n+    \/**\n+     * Launch specified class with a ServerSocketChannel created externally.\n+     *\/\n+    public static void launchWithServerSocketChannel(String className,\n+                                                     ServerSocketChannel ssc,\n+                                                     String[] options,\n+                                                     String... args)\n+            throws Exception {\n+        launch(className, options, args, Util.getFD(ssc));\n@@ -140,1 +165,1 @@\n-    \/*\n+    \/**\n@@ -148,3 +173,4 @@\n-    public static DatagramChannel launchWithDatagramChannel(String className, String options[], String args[])\n-        throws IOException\n-    {\n+    public static DatagramChannel launchWithDatagramChannel(String className,\n+                                                            String[] options,\n+                                                            String... args)\n+            throws IOException {\n@@ -168,8 +194,0 @@\n-\n-    public static DatagramChannel launchWithDatagramChannel(String className, String args[]) throws IOException {\n-        return launchWithDatagramChannel(className, null, args);\n-    }\n-\n-    public static DatagramChannel launchWithDatagramChannel(String className) throws IOException {\n-        return launchWithDatagramChannel(className, null);\n-    }\n","filename":"test\/jdk\/java\/nio\/channels\/spi\/SelectorProvider\/inheritedChannel\/Launcher.java","additions":80,"deletions":62,"binary":false,"changes":142,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -173,2 +173,2 @@\n-        System.err.println(\"launchWithSocketChannel\");\n-        SocketChannel sc = Launcher.launchWithSocketChannel(TEST_SERVICE, options, arg);\n+        System.err.println(\"launchWithInetSocketChannel\");\n+        SocketChannel sc = Launcher.launchWithInetSocketChannel(TEST_SERVICE, options, arg);\n@@ -184,2 +184,2 @@\n-        System.err.println(\"launchWithServerSocketChannel\");\n-        sc = Launcher.launchWithServerSocketChannel(TEST_SERVICE, options, arg);\n+        System.err.println(\"launchWithInetServerSocketChannel\");\n+        sc = Launcher.launchWithInetServerSocketChannel(TEST_SERVICE, options, arg);\n","filename":"test\/jdk\/java\/nio\/channels\/spi\/SelectorProvider\/inheritedChannel\/StateTest.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n- * The test checks that the channel returned by System.inheritiedChannel\n+ * The test checks that the channel returned by System.inheritedChannel\n","filename":"test\/jdk\/java\/nio\/channels\/spi\/SelectorProvider\/inheritedChannel\/StateTestService.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,0 +24,3 @@\n+import java.io.IOException;\n+import java.net.SocketAddress;\n+import java.net.UnixDomainSocketAddress;\n@@ -26,1 +29,4 @@\n-import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+\n+import static java.net.StandardProtocolFamily.UNIX;\n@@ -30,1 +36,1 @@\n- * Make sure that System.inheritedChannel returns null when given a UNIX domain socket\n+ * Make sure that System.inheritedChannel returns the correct type\n@@ -34,0 +40,4 @@\n+    private static final UnixDomainSocketAddress SOCK_ADDR =\n+            UnixDomainSocketAddress.of(Path.of(\"foo.socket\"));\n+\n+    private static boolean passed = true;\n@@ -37,2 +47,2 @@\n-            \/\/ we just want to make sure that System.inheritedChannel either\n-            \/\/ returns a connected channel, or null if it is given a listener\n+            \/\/ we want to make sure that System.inheritedChannel either\n+            \/\/ returns a ServerSocketChannel or a SocketChannel\n@@ -42,4 +52,5 @@\n-                \/\/ socket is writeable\n-                ByteChannel bc = (ByteChannel)channel;\n-                ByteBuffer buf = ByteBuffer.wrap(result.getBytes(ISO_8859_1));\n-                bc.write(buf);\n+                if (channel instanceof SocketChannel) {\n+                    SocketChannel sc = (SocketChannel) channel;\n+                    ByteBuffer buf = ByteBuffer.wrap(result.getBytes(ISO_8859_1));\n+                    sc.write(buf);\n+                }\n@@ -47,6 +58,6 @@\n-                \/\/ in this case the socket is a listener\n-                \/\/ we can't write to it. So, use UnixDatagramSocket\n-                \/\/ to accept a writeable socket\n-                UnixDomainSocket listener = new UnixDomainSocket(0); \/\/ fd 0\n-                UnixDomainSocket sock = listener.accept();\n-                sock.write((int)result.charAt(0));\n+                if (channel instanceof ServerSocketChannel) {\n+                    ServerSocketChannel server = (ServerSocketChannel) channel;\n+                    SocketChannel sc = server.accept();\n+                    ByteBuffer buf = ByteBuffer.wrap(result.getBytes(ISO_8859_1));\n+                    sc.write(buf);\n+                }\n@@ -57,2 +68,0 @@\n-    static boolean passed = true;\n-\n@@ -67,6 +76,0 @@\n-    private static void closeAll(UnixDomainSocket... sockets) {\n-        for (UnixDomainSocket sock : sockets) {\n-            sock.close();\n-        }\n-    }\n-\n@@ -75,10 +78,18 @@\n-        UnixDomainSocket listener = new UnixDomainSocket();\n-        listener.bind(\"foo.socket\");\n-        UnixDomainSocket sock1 = new UnixDomainSocket();\n-        sock1.connect(\"foo.socket\");\n-        UnixDomainSocket sock2 = listener.accept();\n-\n-        Launcher.launchWithUnixDomainSocket(\"UnixDomainChannelTest$Child\", sock2, \"test1\");\n-        int c = sock1.read();\n-        if (c != 'Y') {\n-            System.err.printf(\"test1: failed %d d\\n\", c );\n+        ServerSocketChannel listener = ServerSocketChannel.open(UNIX);\n+        listener.bind(SOCK_ADDR);\n+        SocketChannel sock1 = SocketChannel.open(SOCK_ADDR);\n+        SocketChannel sock2 = listener.accept();\n+        System.out.println(\"test1: launching child\");\n+        Launcher.launchWithSocketChannel(\n+                \"UnixDomainChannelTest$Child\", sock2, null, \"test1\");\n+        ByteBuffer bb = ByteBuffer.allocate(10);\n+        int c = sock1.read(bb);\n+        if (c != 1) {\n+            System.err.printf(\"test1: failed \" +\n+                    \"- unexpected number of bytes read %d d\\n\", c);\n+            passed = false;\n+        }\n+        byte b = bb.get(0);\n+        if (b != 'Y') {\n+            System.err.printf(\"test1: failed \" +\n+                    \"- unexpected byte read %d d\\n\", b);\n@@ -88,0 +99,1 @@\n+        Files.deleteIfExists(SOCK_ADDR.getPath());\n@@ -92,1 +104,4 @@\n-        UnixDomainSocket[] pair = UnixDomainSocket.socketpair();\n+        ServerSocketChannel listener = ServerSocketChannel.open(UNIX);\n+        SocketAddress addr = listener.bind(null).getLocalAddress();\n+        SocketChannel sock1 = SocketChannel.open(addr);\n+        SocketChannel sock2 = listener.accept();\n@@ -94,3 +109,13 @@\n-        Launcher.launchWithUnixDomainSocket(\"UnixDomainChannelTest$Child\", pair[0], \"test2\");\n-        if (pair[1].read() != 'Y') {\n-            System.err.println(\"test2: failed\");\n+        Launcher.launchWithSocketChannel(\n+                \"UnixDomainChannelTest$Child\", sock2, null, \"test2\");\n+        ByteBuffer bb = ByteBuffer.allocate(10);\n+        int c = sock1.read(bb);\n+        if (c != 1) {\n+            System.err.printf(\"test3: failed \" +\n+                    \"- unexpected number of bytes read %d d\\n\", c);\n+            passed = false;\n+        }\n+        byte b = bb.get(0);\n+        if (b != 'Y') {\n+            System.err.printf(\"test3: failed \" +\n+                    \"- unexpected byte read %d d\\n\", b);\n@@ -99,1 +124,2 @@\n-        closeAll(pair[0], pair[1]);\n+        closeAll(listener, sock1, sock2);\n+        Files.deleteIfExists(((UnixDomainSocketAddress)addr).getPath());\n@@ -104,3 +130,3 @@\n-        UnixDomainSocket listener = new UnixDomainSocket();\n-        listener.bind(\"foo.socket\");\n-        UnixDomainSocket sock1 = new UnixDomainSocket();\n+        ServerSocketChannel listener = ServerSocketChannel.open(UNIX);\n+        listener.bind(SOCK_ADDR);\n+        SocketChannel sock1 = SocketChannel.open(UNIX);\n@@ -108,4 +134,14 @@\n-        Launcher.launchWithUnixDomainSocket(\"UnixDomainChannelTest$Child\", listener, \"test3\");\n-        sock1.connect(\"foo.socket\");\n-        if (sock1.read() != 'N') {\n-            System.err.println(\"test3: failed\");\n+        Launcher.launchWithServerSocketChannel(\n+                \"UnixDomainChannelTest$Child\", listener, null, \"test3\");\n+        sock1.connect(SOCK_ADDR);\n+        ByteBuffer bb = ByteBuffer.allocate(10);\n+        int c = sock1.read(bb);\n+        if (c != 1) {\n+            System.err.printf(\"test3: failed \" +\n+                    \"- unexpected number of bytes read %d d\\n\", c);\n+            passed = false;\n+        }\n+        byte b = bb.get(0);\n+        if (b != 'Y') {\n+            System.err.printf(\"test3: failed \" +\n+                    \"- unexpected byte read %d d\\n\", b);\n@@ -115,0 +151,1 @@\n+        Files.deleteIfExists(SOCK_ADDR.getPath());\n@@ -117,0 +154,10 @@\n+    private static void closeAll(Channel... channels) {\n+        for (Channel c : channels) {\n+            try {\n+                if (c != null)\n+                    c.close();\n+            } catch (IOException e) {\n+                throw new RuntimeException(\"Could not close channel \" + c);\n+            }\n+        }\n+    }\n","filename":"test\/jdk\/java\/nio\/channels\/spi\/SelectorProvider\/inheritedChannel\/UnixDomainChannelTest.java","additions":92,"deletions":45,"binary":false,"changes":137,"status":"modified"},{"patch":"@@ -1,101 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * A simplified Unix domain socket which can read and write bytes at a time\n- * used for simulating external launchers which use UNIX sockets to talk\n- * the VM.\n- *\/\n-\n-import java.io.IOException;\n-\n-public class UnixDomainSocket {\n-\n-    static {\n-        System.loadLibrary(\"InheritedChannel\");\n-        init();\n-    }\n-\n-    private final int fd;\n-    private volatile String name;\n-\n-    public UnixDomainSocket() throws IOException {\n-        this.fd = create();\n-    }\n-\n-    public void bind(String name) throws IOException {\n-        bind0(fd, name);\n-        this.name = name;\n-    }\n-\n-    public UnixDomainSocket accept() throws IOException {\n-        int newsock = accept0(fd);\n-        return new UnixDomainSocket(newsock);\n-    }\n-\n-    public UnixDomainSocket(int fd) {\n-        this.fd = fd;\n-    }\n-\n-    public void connect(String dest) throws IOException {\n-        connect0(fd, dest);\n-    }\n-\n-    public int read() throws IOException {\n-        return read0(fd);\n-    }\n-\n-    public String name() {\n-        return name;\n-    }\n-\n-    public void write(int w) throws IOException {\n-        write0(fd, w);\n-    }\n-\n-    public void close() {\n-        close0(fd, name); \/\/ close0 will unlink name if non-null\n-    }\n-\n-    public int fd() {\n-        return fd;\n-    }\n-\n-    public String toString() {\n-        return \"UnixDomainSocket: fd=\" + Integer.toString(fd);\n-    }\n-\n-    private static native int create() throws IOException;\n-    private static native void bind0(int fd, String name) throws IOException;\n-    private static native int accept0(int fd) throws IOException;\n-    private static native int connect0(int fd, String name) throws IOException;\n-\n-    \/* read and write bytes with UNIX domain sockets *\/\n-\n-    private static native int read0(int fd) throws IOException;\n-    private static native void write0(int fd, int w) throws IOException;\n-    private static native void close0(int fd, String name);\n-    private static native void init();\n-    public static native UnixDomainSocket[] socketpair();\n-}\n-\n","filename":"test\/jdk\/java\/nio\/channels\/spi\/SelectorProvider\/inheritedChannel\/UnixDomainSocket.java","additions":0,"deletions":101,"binary":false,"changes":101,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,8 +24,0 @@\n-\/*\n- * If the platform has IPv6 we spawn a child process simulating the\n- * effect of being launched from node.js. We check that IPv6 is available in the child\n- * and report back as appropriate.\n- *\/\n-\n-import jdk.test.lib.Utils;\n-import java.io.*;\n@@ -35,0 +27,5 @@\n+import java.net.UnixDomainSocketAddress;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.SocketChannel;\n+import java.nio.channels.ServerSocketChannel;\n+import java.nio.file.Files;\n@@ -38,0 +35,2 @@\n+import static java.net.StandardProtocolFamily.UNIX;\n+\n@@ -40,9 +39,9 @@\n-    static boolean hasIPv6() throws Exception {\n-        Enumeration<NetworkInterface> nets = NetworkInterface.getNetworkInterfaces();\n-        for (NetworkInterface netint : Collections.list(nets)) {\n-            Enumeration<InetAddress> inetAddresses = netint.getInetAddresses();\n-            for (InetAddress inetAddress : Collections.list(inetAddresses)) {\n-                if (inetAddress instanceof Inet6Address) {\n-                    return true;\n-                }\n-            }\n+    public static class Child1 {\n+        public static void main(String[] args) throws Exception {\n+            SocketChannel chan = (SocketChannel)System.inheritedChannel();\n+            ByteBuffer bb = ByteBuffer.allocate(2);\n+            bb.put((byte)'X');\n+            bb.put((byte)'Y');\n+            bb.flip();\n+            chan.write(bb);\n+            chan.close();\n@@ -50,1 +49,0 @@\n-        return false;\n@@ -53,1 +51,1 @@\n-    public static class Child {\n+    public static class Child2 {\n@@ -55,6 +53,11 @@\n-            System.out.write('X');\n-            System.out.flush();\n-            if (hasIPv6()) {\n-                System.out.println(\"Y\"); \/\/ GOOD\n-            } else\n-                System.out.println(\"N\"); \/\/ BAD\n+            ServerSocketChannel server = (ServerSocketChannel)System.inheritedChannel();\n+            SocketChannel chan = server.accept();\n+            UnixDomainSocketAddress sa = (UnixDomainSocketAddress)server.getLocalAddress();\n+            Files.delete(sa.getPath());\n+            server.close();\n+            ByteBuffer bb = ByteBuffer.allocate(2);\n+            bb.put((byte)'X');\n+            bb.put((byte)'Y');\n+            bb.flip();\n+            chan.write(bb);\n+            chan.close();\n@@ -65,3 +68,5 @@\n-\n-        if (!hasIPv6()) {\n-            return; \/\/ can only test if IPv6 is present\n+        SocketChannel sc = Launcher.launchWithUnixSocketChannel(\"UnixSocketTest$Child1\");\n+        ByteBuffer bb = ByteBuffer.allocate(10);\n+        sc.read(bb);\n+        if (bb.get(0) != 'X') {\n+            System.exit(-2);\n@@ -69,2 +74,9 @@\n-        UnixDomainSocket sock = Launcher.launchWithUnixDomainSocket(\"UnixSocketTest$Child\");\n-        if (sock.read() != 'X') {\n+        if (bb.get(1) != 'Y') {\n+            System.exit(-2);\n+        }\n+        sc.close();\n+\n+        sc = Launcher.launchWithUnixServerSocketChannel(\"UnixSocketTest$Child2\");\n+        bb.clear();\n+        sc.read(bb);\n+        if (bb.get(0) != 'X') {\n@@ -73,1 +85,1 @@\n-        if (sock.read() != 'Y') {\n+        if (bb.get(1) != 'Y') {\n","filename":"test\/jdk\/java\/nio\/channels\/spi\/SelectorProvider\/inheritedChannel\/UnixSocketTest.java","additions":44,"deletions":32,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-#include <sys\/un.h>\n@@ -43,3 +42,0 @@\n-static jclass unixSocketClass;\n-static jmethodID unixSocketCtor;\n-\n@@ -88,1 +84,0 @@\n-\n@@ -148,1 +143,1 @@\n-     * get the list of open file descriptos we read through \/proc\/self\/fd (\/dev\/fd)\n+     * get the list of open file descriptors we read through \/proc\/self\/fd (\/dev\/fd)\n@@ -187,128 +182,0 @@\n-\n-JNIEXPORT void JNICALL Java_UnixDomainSocket_init(JNIEnv *env, jclass cls) {\n-    CHECK(unixSocketClass = (*env)->FindClass(env, \"UnixDomainSocket\"));\n-    CHECK(unixSocketClass = (*env)->NewGlobalRef(env, unixSocketClass));\n-    CHECK(unixSocketCtor = (*env)->GetMethodID(env, unixSocketClass, \"<init>\", \"(I)V\"));\n-}\n-\n-\/*\n- * Class:     UnixDomainSocket\n- * Method:    socketpair\n- * Signature: ()[LUnixDomainSocket\n- *\/\n-JNIEXPORT jobjectArray JNICALL Java_UnixDomainSocket_socketpair\n-  (JNIEnv *env, jclass cls)\n-{\n-    int fds[2];\n-    jobject socket;\n-    jobjectArray result = (*env)->NewObjectArray(env, 2, unixSocketClass, 0);\n-    if (socketpair(AF_UNIX, SOCK_STREAM, 0, fds) < 0) {\n-        perror(\"socketpair\");\n-        return result;\n-    }\n-    socket = (*env)->NewObject(env, unixSocketClass, unixSocketCtor, fds[0]);\n-    (*env)->SetObjectArrayElement(env, result, 0, socket);\n-    socket = (*env)->NewObject(env, unixSocketClass, unixSocketCtor, fds[1]);\n-    (*env)->SetObjectArrayElement(env, result, 1, socket);\n-    return result;\n-}\n-\n-JNIEXPORT jint JNICALL Java_UnixDomainSocket_create\n-  (JNIEnv *env, jclass cls)\n-{\n-    int sock = socket(AF_UNIX, SOCK_STREAM, 0);\n-    if (sock == -1) {\n-        ThrowException(env, \"java\/io\/IOException\", \"socket create error\");\n-    }\n-    return sock;\n-}\n-\n-JNIEXPORT void JNICALL Java_UnixDomainSocket_bind0\n-  (JNIEnv *env, jclass cls, jint sock, jstring name)\n-{\n-    struct sockaddr_un addr;\n-    const char *nameUtf = (*env)->GetStringUTFChars(env, name, NULL);\n-    int ret = -1;\n-    int length = sizeof(addr.sun_path);\n-    unlink(nameUtf);\n-    memset(&addr, 0, sizeof(addr));\n-    addr.sun_family = AF_UNIX;\n-    strncpy(addr.sun_path, nameUtf, length);\n-    addr.sun_path[length - 1] = '\\0';\n-    ret = bind(sock, (const struct sockaddr*)&addr, sizeof(addr));\n-    if (ret == -1) {\n-        ThrowException(env, \"java\/io\/IOException\", \"socket bind error\");\n-    }\n-    ret = listen(sock, 5);\n-    if (ret == -1) {\n-        ThrowException(env, \"java\/io\/IOException\", \"socket bind error\");\n-    }\n-    (*env)->ReleaseStringUTFChars(env, name, nameUtf);\n-}\n-\n-JNIEXPORT jint JNICALL Java_UnixDomainSocket_accept0\n-  (JNIEnv *env, jclass cls, jint sock)\n-{\n-    struct sockaddr_storage addr;\n-    socklen_t len = sizeof(addr);\n-    int ret = accept(sock, (struct sockaddr *)&addr, &len);\n-    if (ret == -1)\n-        ThrowException(env, \"java\/io\/IOException\", \"socket accept error\");\n-    return ret;\n-}\n-\n-JNIEXPORT void JNICALL Java_UnixDomainSocket_connect0\n-  (JNIEnv *env, jclass cls, jint fd, jstring name)\n-{\n-    struct sockaddr_un addr;\n-    const char *nameUtf = (*env)->GetStringUTFChars(env, name, NULL);\n-    int ret = -1;\n-    int length = sizeof(addr.sun_path);\n-    memset(&addr, 0, sizeof(addr));\n-    addr.sun_family = AF_UNIX;\n-    strncpy(addr.sun_path, nameUtf, length);\n-    addr.sun_path[length - 1] = '\\0';\n-    ret = connect(fd, (const struct sockaddr*)&addr, sizeof(addr));\n-    if (ret == -1) {\n-        ThrowException(env, \"java\/io\/IOException\", \"socket connect error\");\n-    }\n-    (*env)->ReleaseStringUTFChars(env, name, nameUtf);\n-}\n-\n-\n-JNIEXPORT jint JNICALL Java_UnixDomainSocket_read0\n-  (JNIEnv *env, jclass cls, jint fd)\n-{\n-    int ret;\n-    unsigned char res;\n-    ret = read(fd, &res, 1);\n-    if (ret == 0)\n-        return -1; \/* EOF *\/\n-    else if (ret < 0) {\n-        ThrowException(env, \"java\/io\/IOException\", \"read error\");\n-        return -1;\n-    }\n-    return res;\n-}\n-\n-JNIEXPORT void JNICALL Java_UnixDomainSocket_write0\n-  (JNIEnv *env, jclass cls, jint fd, jint byte)\n-{\n-    int ret;\n-    unsigned char w = (unsigned char)byte;\n-    ret = write(fd, &w, 1);\n-    if (ret < 0) {\n-        ThrowException(env, \"java\/io\/IOException\", \"write error\");\n-    }\n-}\n-\n-JNIEXPORT void JNICALL Java_UnixDomainSocket_close0\n-  (JNIEnv *env, jclass cls, jint fd, jstring name)\n-{\n-    close(fd);\n-    if (name != NULL) {\n-        const char *nameUtf = (*env)->GetStringUTFChars(env, name, NULL);\n-        unlink(nameUtf);\n-        (*env)->ReleaseStringUTFChars(env, name, nameUtf);\n-    }\n-}\n","filename":"test\/jdk\/java\/nio\/channels\/spi\/SelectorProvider\/inheritedChannel\/libInheritedChannel.c","additions":1,"deletions":134,"binary":false,"changes":135,"status":"modified"},{"patch":"@@ -0,0 +1,331 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8245194\n+ * @run main\/othervm Bind\n+ *\/\n+\n+import java.io.IOException;\n+import java.net.*;\n+import java.nio.channels.*;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+\n+\/**\n+ * Check that all bind variations work\n+ *\/\n+public class Bind {\n+\n+    static Path spath, cpath;\n+\n+    static UnixDomainSocketAddress sAddr, cAddr, UNNAMED, nullAddr;\n+    static ServerSocketChannel server;\n+    static SocketChannel client, accept1;\n+\n+    public static void main(String args[]) throws Exception {\n+        if (!supported()) {\n+            System.out.println(\"Unix domain channels not supported\");\n+            return;\n+        }\n+        spath = Path.of(\"server.sock\");\n+        cpath = Path.of(\"client.sock\");\n+        sAddr = UnixDomainSocketAddress.of(spath);\n+        cAddr = UnixDomainSocketAddress.of(cpath);\n+        nullAddr = UnixDomainSocketAddress.of(\"\");\n+        UNNAMED = nullAddr;\n+        runTests();\n+    }\n+\n+    static boolean supported() {\n+        try {\n+            SocketChannel.open(StandardProtocolFamily.UNIX).close();\n+        } catch (UnsupportedOperationException e) {\n+            return false;\n+        } catch (Exception e) {\n+            return true; \/\/ continue test to see what problem is\n+        }\n+        return true;\n+    }\n+\n+    static interface ThrowingRunnable {\n+        public void run() throws Exception;\n+    }\n+\n+    static void init() throws IOException {\n+        Files.deleteIfExists(cpath);\n+        Files.deleteIfExists(spath);\n+        client = null; server = null; accept1 = null;\n+    }\n+\n+    static void checkNormal(ThrowingRunnable r) {\n+        try {\n+            init();\n+            r.run();\n+            System.out.println(\"PASS:\");\n+        } catch (Exception e) {\n+            throw new RuntimeException(e);\n+        } finally {\n+            cleanup();\n+        }\n+    }\n+\n+    static void checkException(Class<? extends Exception> expected, ThrowingRunnable r) {\n+        try {\n+            init();\n+            r.run();\n+            throw new RuntimeException(\"Exception expected\");\n+        } catch (Exception e) {\n+            if (!expected.isAssignableFrom(e.getClass())) {\n+                String msg = \"Expected: \" + expected + \" Got: \" + e.getClass();\n+                throw new RuntimeException(msg);\n+            }\n+            System.out.println(\"PASS: Got \" + e);\n+        } finally {\n+            cleanup();\n+        }\n+    }\n+\n+    static void cleanup() {\n+        try {\n+            if (server != null)\n+                server.close();\n+            if (client != null)\n+                client.close();\n+            if (accept1 != null)\n+                accept1.close();\n+        } catch (IOException e) {}\n+    }\n+\n+    static void assertClientAddress(SocketAddress a) {\n+        assertAddress(a, cAddr, \"client\");\n+    }\n+\n+    static void assertServerAddress(SocketAddress a) {\n+        assertAddress(a, sAddr, \"server\");\n+    }\n+\n+    static void assertAddress(SocketAddress a, UnixDomainSocketAddress a1, String s) {\n+        if (!(a instanceof UnixDomainSocketAddress)) {\n+            throw new RuntimeException(\"wrong address type\");\n+        }\n+        UnixDomainSocketAddress ua = (UnixDomainSocketAddress)a;\n+        if (!a.equals(a1))\n+            throw new RuntimeException(\"this is not the \" + s + \" address\");\n+    }\n+\n+    static void assertEquals(Object a, Object b) {\n+        if (!a.equals(b))\n+            throw new RuntimeException(\"identity check failed\");\n+    }\n+\n+    public static void runTests() throws IOException {\n+        checkNormal(() -> {\n+            client = SocketChannel.open(StandardProtocolFamily.UNIX);\n+            client.bind(cAddr);\n+        });\n+        checkNormal(() -> {\n+            server = ServerSocketChannel.open(StandardProtocolFamily.UNIX);\n+            server.bind(sAddr);\n+        });\n+        \/\/ Repeat first two to make sure they are repeatable\n+        checkNormal(() -> {\n+            client = SocketChannel.open(StandardProtocolFamily.UNIX);\n+            client.bind(cAddr);\n+        });\n+        checkNormal(() -> {\n+            server = ServerSocketChannel.open(StandardProtocolFamily.UNIX);\n+            server.bind(sAddr);\n+        });\n+        \/\/ address with space should work\n+        checkNormal(() -> {\n+            server = ServerSocketChannel.open(StandardProtocolFamily.UNIX);\n+            UnixDomainSocketAddress usa =  UnixDomainSocketAddress.of(\"with space\"); \/\/ relative to CWD\n+            Files.deleteIfExists(usa.getPath());\n+            server.bind(usa);\n+            client = SocketChannel.open(usa);\n+            Files.delete(usa.getPath());\n+            assertAddress(client.getRemoteAddress(), usa, \"address\");\n+        });\n+        \/\/ client bind to null: allowed\n+        checkNormal(() -> {\n+            client = SocketChannel.open(StandardProtocolFamily.UNIX);\n+            client.bind(null);\n+            SocketAddress a = client.getLocalAddress();\n+            assertAddress(a, nullAddr, \"null address\");\n+            assertEquals(a, UNNAMED);\n+        });\n+        \/\/ client bind to UNNAMED: allowed\n+        checkNormal(() -> {\n+            client = SocketChannel.open(StandardProtocolFamily.UNIX);\n+            client.bind(UNNAMED);\n+            SocketAddress a = client.getLocalAddress();\n+            assertAddress(a, nullAddr, \"null address\");\n+            assertEquals(a, UNNAMED);\n+        });\n+        \/\/ server bind to null: should bind to a local address\n+        checkNormal(() -> {\n+            server = ServerSocketChannel.open(StandardProtocolFamily.UNIX);\n+            server.bind(null);\n+            UnixDomainSocketAddress usa = (UnixDomainSocketAddress)server.getLocalAddress();\n+            if (usa.getPath().toString().isEmpty())\n+                throw new RuntimeException(\"expected non zero address length\");\n+            System.out.println(\"Null server address: \" + server.getLocalAddress());\n+        });\n+        \/\/ server no bind : not allowed\n+        checkException(\n+            NotYetBoundException.class, () -> {\n+                server = ServerSocketChannel.open(StandardProtocolFamily.UNIX);\n+                server.accept();\n+            }\n+        );\n+\n+        \/\/ client implicit bind and connect\n+        checkNormal(() -> {\n+            server = ServerSocketChannel.open(StandardProtocolFamily.UNIX);\n+            client = SocketChannel.open(StandardProtocolFamily.UNIX);\n+            server.bind(sAddr);\n+            client.connect(sAddr);\n+            SocketAddress cAddr = client.getLocalAddress();\n+            assertAddress(cAddr, nullAddr, \"null address\");\n+            assertEquals(cAddr, UNNAMED);\n+            assertServerAddress(server.getLocalAddress());\n+        });\n+        \/\/ client null bind and connect (check all addresses)\n+        checkNormal(() -> {\n+            server = ServerSocketChannel.open(StandardProtocolFamily.UNIX);\n+            client = SocketChannel.open(StandardProtocolFamily.UNIX);\n+            server.bind(sAddr);\n+            client.bind(null);\n+            client.connect(sAddr);\n+            assertAddress(client.getLocalAddress(), UNNAMED, \"unnamed address\");\n+            assertServerAddress(server.getLocalAddress());\n+        });\n+        \/\/ client explicit bind and connect (check all addresses)\n+        checkNormal(() -> {\n+            server = ServerSocketChannel.open(StandardProtocolFamily.UNIX);\n+            client = SocketChannel.open(StandardProtocolFamily.UNIX);\n+            server.bind(sAddr);\n+            client.bind(cAddr);\n+            client.connect(sAddr);\n+            accept1 = server.accept();\n+            assertClientAddress(client.getLocalAddress());\n+            assertServerAddress(server.getLocalAddress());\n+            assertAddress(client.getRemoteAddress(), sAddr, \"client's remote server address\");\n+            assertAddress(accept1.getLocalAddress(), sAddr, \"accepted local address (server)\");\n+            assertAddress(accept1.getRemoteAddress(), cAddr, \"accepted remote address (client)\");\n+        });\n+        \/\/ server multiple bind : not allowed\n+        checkException(\n+            AlreadyBoundException.class, () -> {\n+                server = ServerSocketChannel.open(StandardProtocolFamily.UNIX);\n+                server.bind(sAddr);\n+                server.bind(sAddr);\n+            }\n+        );\n+        \/\/ client multiple bind : not allowed\n+        checkException(\n+            AlreadyBoundException.class, () -> {\n+                client = SocketChannel.open(StandardProtocolFamily.UNIX);\n+                client.bind(cAddr);\n+                client.bind(cAddr);\n+            }\n+        );\n+        \/\/ client multiple bind to different addresses: not allowed\n+        checkException(\n+            AlreadyBoundException.class, () -> {\n+                client = SocketChannel.open(StandardProtocolFamily.UNIX);\n+                client.bind(cAddr);\n+                client.bind(sAddr);\n+            }\n+        );\n+        \/\/ client multiple bind to differnt addresses, incl null: not allowed\n+        checkException(\n+            AlreadyBoundException.class, () -> {\n+                client = SocketChannel.open(StandardProtocolFamily.UNIX);\n+                client.bind(null);\n+                client.bind(cAddr);\n+            }\n+        );\n+\n+        \/\/ server bind to existing name: not allowed\n+\n+        checkException(\n+            BindException.class, () -> {\n+                var path = Files.createFile(Path.of(\"moo.sock\"));\n+                var addr = UnixDomainSocketAddress.of(path);\n+                server = ServerSocketChannel.open(StandardProtocolFamily.UNIX);\n+                try {\n+                    server.bind(addr);\n+                } finally {\n+                    Files.deleteIfExists(path);\n+                }\n+            }\n+        );\n+\n+\n+        \/\/ client bind to existing name: not allowed\n+        checkException(\n+            BindException.class, () -> {\n+                var path = Path.of(\"temp.sock\");\n+                Files.deleteIfExists(path);\n+                Files.createFile(path);\n+                var addr = UnixDomainSocketAddress.of(path);\n+                client = SocketChannel.open(StandardProtocolFamily.UNIX);\n+                try {\n+                    client.bind(addr);\n+                } finally {\n+                    Files.deleteIfExists(path);\n+                }\n+            }\n+        );\n+\n+        \/\/ bind and connect to name of close to max size\n+        checkNormal(() -> {\n+            int len = 100;\n+            char[] chars = new char[len];\n+            Arrays.fill(chars, 'x');\n+            String name = new String(chars);\n+            UnixDomainSocketAddress address = UnixDomainSocketAddress.of(name);\n+            ServerSocketChannel server = ServerSocketChannel.open(StandardProtocolFamily.UNIX);\n+            server.bind(address);\n+            SocketChannel client = SocketChannel.open(address);\n+            assertAddress(server.getLocalAddress(), address, \"server\");\n+            assertAddress(client.getRemoteAddress(), address, \"client\");\n+            Files.delete(address.getPath());\n+        });\n+\n+        \/\/ implicit server bind\n+        checkNormal(() -> {\n+            server = ServerSocketChannel.open(StandardProtocolFamily.UNIX);\n+            server.bind(null);\n+            UnixDomainSocketAddress usa = (UnixDomainSocketAddress)server.getLocalAddress();\n+            client = SocketChannel.open(usa);\n+            accept1 = server.accept();\n+            assertAddress(client.getRemoteAddress(), usa, \"server\");\n+            Files.delete(usa.getPath());\n+        });\n+    }\n+}\n","filename":"test\/jdk\/java\/nio\/channels\/unixdomain\/Bind.java","additions":331,"deletions":0,"binary":false,"changes":331,"status":"added"},{"patch":"@@ -0,0 +1,1243 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8245194\n+ * @run testng\/othervm IOExchanges\n+ *\/\n+\n+import java.io.IOException;\n+import java.net.*;\n+import java.nio.channels.*;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Files;\n+\n+import org.testng.annotations.BeforeTest;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import static java.lang.System.out;\n+import static java.net.StandardProtocolFamily.*;\n+import static java.nio.channels.SelectionKey.OP_ACCEPT;\n+import static java.nio.channels.SelectionKey.OP_READ;\n+import static java.nio.channels.SelectionKey.OP_WRITE;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertTrue;\n+\n+public class IOExchanges {\n+    static boolean supported = true;\n+\n+\n+    @BeforeTest()\n+    public void setup() {\n+        try {\n+            SocketChannel.open(UNIX);\n+        } catch (IOException | UnsupportedOperationException e) {\n+            supported = false;\n+            out.println(\"Unix domain channels not supported\");\n+        }\n+    }\n+\n+    static SocketChannel openSocketChannel(ProtocolFamily family)\n+            throws IOException {\n+        return family == UNIX ? SocketChannel.open(family)\n+                : SocketChannel.open();\n+    }\n+\n+    static ServerSocketChannel openServerSocketChannel(ProtocolFamily family)\n+             throws IOException {\n+        return family == UNIX ? ServerSocketChannel.open(family)\n+                     : ServerSocketChannel.open();\n+    }\n+\n+    public static void deleteFile(SocketAddress addr) throws Exception {\n+        if (addr instanceof UnixDomainSocketAddress) {\n+            Files.deleteIfExists(((UnixDomainSocketAddress) addr).getPath());\n+        }\n+    }\n+\n+    \/*\n+     The following, non-exhaustive set, of tests exercise different combinations\n+     of blocking and non-blocking accept\/connect calls along with I\/O\n+     operations, that exchange a single byte. The intent it to test a reasonable\n+     set of blocking and non-blocking scenarios.\n+\n+     The individual test method names follow their test scenario.\n+        [BAccep|SELNBAccep|SPINNBAccep] - Accept either:\n+                         blocking, select-non-blocking, spinning-non-blocking\n+        [BConn|NBConn] - blocking connect \/ non-blocking connect\n+        [BIO|NBIO]     - blocking \/ non-blocking I\/O operations (read\/write)\n+        [WR|RW] - connecting thread write\/accepting thread reads first, and vice-versa\n+        [Id]    - unique test Id\n+\n+        BAccep_BConn_BIO_WR_1\n+        BAccep_BConn_BIO_RW_2\n+        SELNBAccep_BConn_BIO_WR_3\n+        SELNBAccep_BConn_BIO_RW_4\n+        SPINNBAccep_BConn_BIO_WR_5\n+        SPINNBAccep_BConn_BIO_RW_6\n+        BAccep_NBConn_BIO_WR_7\n+        BAccep_NBConn_BIO_RW_8\n+        SELNBAccep_NBConn_BIO_WR_9\n+        SELNBAccep_NBConn_BIO_RW_10\n+        SPINNBAccep_NBConn_BIO_WR_11\n+        SPINNBAccep_NBConn_BIO_RW_12\n+\n+        BAccep_BConn_NBIO_WR_1a         \/\/ Non-Blocking I\/O\n+        BAccep_BConn_NBIO_RW_2a\n+        SELNBAccep_BConn_NBIO_WR_3a\n+        SELNBAccep_BConn_NBIO_RW_4a\n+        SPINNBAccep_BConn_NBIO_WR_5a\n+        SPINNBAccep_BConn_NBIO_RW_6a\n+        BAccep_NBConn_NBIO_WR_7a\n+        BAccep_NBConn_NBIO_RW_8a\n+        SELNBAccep_NBConn_NBIO_WR_9a\n+        SELNBAccep_NBConn_NBIO_RW_10a\n+        SPINBAccep_NBConn_NBIO_WR_11a\n+        SPINBAccep_NBConn_NBIO_RW_12a\n+    *\/\n+\n+    @DataProvider(name = \"family\")\n+    public Object[][] family() {\n+        return supported ?\n+                new Object[][] {\n+                    { UNIX },\n+                    { INET }}\n+                : new Object[][] {\n+                    { INET }\n+        };\n+    }\n+\n+    @Test(dataProvider = \"family\")\n+    public void BAccep_BConn_BIO_WR_1(ProtocolFamily family)\n+            throws Throwable {\n+        try (ServerSocketChannel ssc = openServerSocketChannel(family)) {\n+            ssc.bind(null);\n+            SocketAddress addr = ssc.getLocalAddress();\n+\n+            TestThread t = TestThread.of(\"t1\", () -> {\n+                try (SocketChannel sc = openSocketChannel(family)) {\n+                    assertTrue(sc.connect(addr));\n+                    ByteBuffer bb = ByteBuffer.allocate(10).put((byte) 0x01).flip();\n+                    assertEquals(sc.write(bb), 1);\n+                    out.printf(\"wrote: 0x%x%n\", bb.get(0));\n+                    assertEquals(sc.read(bb.clear()), -1);\n+                }\n+            });\n+            t.start();\n+\n+            try (SocketChannel sc = ssc.accept()) {\n+                ByteBuffer bb = ByteBuffer.allocate(10);\n+                assertEquals(sc.read(bb), 1);\n+                out.printf(\"read:  0x%x%n\", bb.get(0));\n+                assertEquals(bb.get(0), 0x01);\n+            }\n+            t.awaitCompletion();\n+            deleteFile(addr);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"family\")\n+    public void BAccep_BConn_BIO_RW_2(ProtocolFamily family)\n+            throws Throwable {\n+        try (ServerSocketChannel ssc = openServerSocketChannel(family)) {\n+            ssc.bind(null);\n+            SocketAddress addr = ssc.getLocalAddress();\n+\n+            TestThread t = TestThread.of(\"t2\", () -> {\n+                try (SocketChannel sc = openSocketChannel(family)) {\n+                    assertTrue(sc.connect(addr));\n+                    ByteBuffer bb = ByteBuffer.allocate(10);\n+                    assertEquals(sc.read(bb), 1);\n+                    out.printf(\"read:  0x%x%n\", bb.get(0));\n+                    assertEquals(bb.get(0), 0x02);\n+                }\n+            });\n+            t.start();\n+\n+            try (SocketChannel sc = ssc.accept()) {\n+                ByteBuffer bb = ByteBuffer.allocate(10).put((byte) 0x02).flip();\n+                assertEquals(sc.write(bb), 1);\n+                out.printf(\"wrote: 0x%x%n\", bb.get(0));\n+                assertEquals(sc.read(bb.clear()), -1);\n+            }\n+            t.awaitCompletion();\n+            deleteFile(addr);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"family\")\n+    public void SELNBAccep_BConn_BIO_WR_3(ProtocolFamily family)\n+            throws Throwable {\n+        try (ServerSocketChannel ssc = openServerSocketChannel(family);\n+             Selector selector = Selector.open()) {\n+            ssc.bind(null);\n+            SocketAddress addr = ssc.getLocalAddress();\n+\n+            TestThread t = TestThread.of(\"t3\", () -> {\n+                try (SocketChannel sc = openSocketChannel(family)) {\n+                    assertTrue(sc.connect(addr));\n+                    ByteBuffer bb = ByteBuffer.allocate(10).put((byte) 0x03).flip();\n+                    assertEquals(sc.write(bb), 1);\n+                    out.printf(\"wrote: 0x%x%n\", bb.get(0));\n+                    assertEquals(sc.read(bb.clear()), -1);\n+                }\n+            });\n+            t.start();\n+\n+            ssc.configureBlocking(false).register(selector, OP_ACCEPT);\n+            assertEquals(selector.select(), 1);\n+\n+            try (SocketChannel sc = ssc.accept()) {\n+                ByteBuffer bb = ByteBuffer.allocate(10);\n+                assertEquals(sc.read(bb), 1);\n+                out.printf(\"read:  0x%x%n\", bb.get(0));\n+                assertEquals(bb.get(0), 0x03);\n+            }\n+            t.awaitCompletion();\n+            deleteFile(addr);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"family\")\n+    public void SELNBAccep_BConn_BIO_RW_4(ProtocolFamily family)\n+            throws Throwable {\n+        try (ServerSocketChannel ssc = openServerSocketChannel(family);\n+             Selector selector = Selector.open()) {\n+            ssc.bind(null);\n+            SocketAddress addr = ssc.getLocalAddress();\n+\n+            TestThread t = TestThread.of(\"t4\", () -> {\n+                try (SocketChannel sc = openSocketChannel(family)) {\n+                    assertTrue(sc.connect(addr));\n+                    ByteBuffer bb = ByteBuffer.allocate(10);\n+                    assertEquals(sc.read(bb), 1);\n+                    out.printf(\"read:  0x%x%n\", bb.get(0));\n+                    assertEquals(bb.get(0), 0x04);\n+                }\n+            });\n+            t.start();\n+\n+            ssc.configureBlocking(false).register(selector, OP_ACCEPT);\n+            assertEquals(selector.select(), 1);\n+\n+            try (SocketChannel sc = ssc.accept()) {\n+                ByteBuffer bb = ByteBuffer.allocate(10).put((byte) 0x04).flip();\n+                assertEquals(sc.write(bb), 1);\n+                out.printf(\"wrote: 0x%x%n\", bb.get(0));\n+                assertEquals(sc.read(bb.clear()), -1);\n+\n+            }\n+            t.awaitCompletion();\n+            deleteFile(addr);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"family\")\n+    public void SPINNBAccep_BConn_BIO_WR_5(ProtocolFamily family)\n+            throws Throwable {\n+        try (ServerSocketChannel ssc = openServerSocketChannel(family)) {\n+            ssc.bind(null);\n+            SocketAddress addr = ssc.getLocalAddress();\n+\n+            TestThread t = TestThread.of(\"t5\", () -> {\n+                try (SocketChannel sc = openSocketChannel(family)) {\n+                    assertTrue(sc.connect(addr));\n+                    ByteBuffer bb = ByteBuffer.allocate(10).put((byte) 0x05).flip();\n+                    assertEquals(sc.write(bb), 1);\n+                    out.printf(\"wrote: 0x%x%n\", bb.get(0));\n+                    assertEquals(sc.read(bb.clear()), -1);\n+                }\n+            });\n+            t.start();\n+\n+            SocketChannel accepted;\n+            for (; ; ) {\n+                accepted = ssc.accept();\n+                if (accepted != null) {\n+                    out.println(\"accepted new connection\");\n+                    break;\n+                }\n+                Thread.onSpinWait();\n+            }\n+\n+            try (SocketChannel sc = accepted) {\n+                ByteBuffer bb = ByteBuffer.allocate(10);\n+                assertEquals(sc.read(bb), 1);\n+                out.printf(\"read:  0x%x%n\", bb.get(0));\n+                assertEquals(bb.get(0), 0x05);\n+            }\n+            t.awaitCompletion();\n+            deleteFile(addr);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"family\")\n+    public void SPINNBAccep_BConn_BIO_RW_6(ProtocolFamily family)\n+            throws Throwable {\n+        try (ServerSocketChannel ssc = openServerSocketChannel(family)) {\n+            ssc.bind(null);\n+            SocketAddress addr = ssc.getLocalAddress();\n+\n+            TestThread t = TestThread.of(\"t6\", () -> {\n+                try (SocketChannel sc = openSocketChannel(family)) {\n+                    assertTrue(sc.connect(addr));\n+                    ByteBuffer bb = ByteBuffer.allocate(10);\n+                    assertEquals(sc.read(bb), 1);\n+                    out.printf(\"read:  0x%x%n\", bb.get(0));\n+                    assertEquals(bb.get(0), 0x06);\n+                }\n+            });\n+            t.start();\n+\n+            SocketChannel accepted;\n+            for (; ; ) {\n+                accepted = ssc.accept();\n+                if (accepted != null) {\n+                    out.println(\"accepted new connection\");\n+                    break;\n+                }\n+                Thread.onSpinWait();\n+            }\n+\n+            try (SocketChannel sc = accepted) {\n+                ByteBuffer bb = ByteBuffer.allocate(10).put((byte) 0x06).flip();\n+                assertEquals(sc.write(bb), 1);\n+                out.printf(\"wrote: 0x%x%n\", bb.get(0));\n+                assertEquals(sc.read(bb.clear()), -1);\n+\n+            }\n+            t.awaitCompletion();\n+            deleteFile(addr);\n+        }\n+    }\n+\n+    \/\/ Similar to the previous six scenarios, but with same-thread\n+    \/\/ non-blocking connect.\n+\n+    @Test(dataProvider = \"family\")\n+    public void BAccep_NBConn_BIO_WR_7(ProtocolFamily family)\n+            throws Throwable {\n+        try (ServerSocketChannel ssc = openServerSocketChannel(family)) {\n+            ssc.bind(null);\n+            SocketAddress addr = ssc.getLocalAddress();\n+\n+            try (SocketChannel sc = openSocketChannel(family)) {\n+                sc.configureBlocking(false);\n+                sc.connect(addr);\n+\n+                try (SocketChannel sc2 = ssc.accept()) {\n+                    assertTrue(sc.finishConnect());\n+                    sc.configureBlocking(true);\n+                    TestThread t = TestThread.of(\"t7\", () -> {\n+                        ByteBuffer bb = ByteBuffer.allocate(10).put((byte) 0x07).flip();\n+                        assertEquals(sc.write(bb), 1);\n+                        out.printf(\"wrote: 0x%x%n\", bb.get(0));\n+                        assertEquals(sc.read(bb.clear()), -1);\n+                    });\n+                    t.start();\n+\n+                    ByteBuffer bb = ByteBuffer.allocate(10);\n+                    assertEquals(sc2.read(bb), 1);\n+                    out.printf(\"read:  0x%x%n\", bb.get(0));\n+                    assertEquals(bb.get(0), 0x07);\n+                    sc2.shutdownOutput();\n+                    t.awaitCompletion();\n+                }\n+            }\n+            deleteFile(addr);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"family\")\n+    public void BAccep_NBConn_BIO_RW_8(ProtocolFamily family)\n+            throws Throwable {\n+        try (ServerSocketChannel ssc = openServerSocketChannel(family)) {\n+            ssc.bind(null);\n+            SocketAddress addr = ssc.getLocalAddress();\n+\n+            try (SocketChannel sc = openSocketChannel(family)) {\n+                sc.configureBlocking(false);\n+                sc.connect(addr);\n+\n+                try (SocketChannel sc2 = ssc.accept()) {\n+                    assertTrue(sc.finishConnect());\n+                    sc.configureBlocking(true);\n+                    TestThread t = TestThread.of(\"t8\", () -> {\n+                        ByteBuffer bb = ByteBuffer.allocate(10);\n+                        assertEquals(sc.read(bb), 1);\n+                        out.printf(\"read:  0x%x%n\", bb.get(0));\n+                        assertEquals(bb.get(0), 0x08);\n+                        sc.shutdownOutput();\n+                    });\n+                    t.start();\n+\n+                    ByteBuffer bb = ByteBuffer.allocate(10).put((byte) 0x08).flip();\n+                    assertEquals(sc2.write(bb), 1);\n+                    out.printf(\"wrote: 0x%x%n\", bb.get(0));\n+                    assertEquals(sc2.read(bb.clear()), -1);\n+                    t.awaitCompletion();\n+                }\n+            }\n+            deleteFile(addr);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"family\")\n+    public void SELNBAccep_NBConn_BIO_WR_9(ProtocolFamily family)\n+            throws Throwable {\n+        try (ServerSocketChannel ssc = openServerSocketChannel(family)) {\n+            ssc.bind(null);\n+            SocketAddress addr = ssc.getLocalAddress();\n+\n+            try (SocketChannel sc = openSocketChannel(family);\n+                 Selector selector = Selector.open()) {\n+                sc.configureBlocking(false);\n+                sc.connect(addr);\n+\n+                ssc.configureBlocking(false).register(selector, OP_ACCEPT);\n+                assertEquals(selector.select(), 1);\n+\n+                try (SocketChannel sc2 = ssc.accept()) {\n+                    assertTrue(sc.finishConnect());\n+                    sc.configureBlocking(true);\n+                    TestThread t = TestThread.of(\"t9\", () -> {\n+                        ByteBuffer bb = ByteBuffer.allocate(10).put((byte) 0x09).flip();\n+                        assertEquals(sc.write(bb), 1);\n+                        out.printf(\"wrote: 0x%x%n\", bb.get(0));\n+                        assertEquals(sc.read(bb.clear()), -1);\n+                    });\n+                    t.start();\n+\n+                    ByteBuffer bb = ByteBuffer.allocate(10);\n+                    assertEquals(sc2.read(bb), 1);\n+                    out.printf(\"read:  0x%x%n\", bb.get(0));\n+                    assertEquals(bb.get(0), 0x09);\n+                    sc2.shutdownOutput();\n+                    t.awaitCompletion();\n+                }\n+            }\n+            deleteFile(addr);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"family\")\n+    public void SELNBAccep_NBConn_BIO_RW_10(ProtocolFamily family)\n+            throws Throwable {\n+        try (ServerSocketChannel ssc = openServerSocketChannel(family)) {\n+            ssc.bind(null);\n+            SocketAddress addr = ssc.getLocalAddress();\n+\n+            try (SocketChannel sc = openSocketChannel(family);\n+                 Selector selector = Selector.open()) {\n+                sc.configureBlocking(false);\n+                sc.connect(addr);\n+\n+                ssc.configureBlocking(false).register(selector, OP_ACCEPT);\n+                assertEquals(selector.select(), 1);\n+\n+                try (SocketChannel sc2 = ssc.accept()) {\n+                    assertTrue(sc.finishConnect());\n+                    sc.configureBlocking(true);\n+                    TestThread t = TestThread.of(\"t10\", () -> {\n+                        ByteBuffer bb = ByteBuffer.allocate(10);\n+                        assertEquals(sc.read(bb), 1);\n+                        out.printf(\"read:  0x%x%n\", bb.get(0));\n+                        assertEquals(bb.get(0), 0x10);\n+                        sc.shutdownOutput();\n+                    });\n+                    t.start();\n+\n+                    ByteBuffer bb = ByteBuffer.allocate(10).put((byte) 0x10).flip();\n+                    assertEquals(sc2.write(bb), 1);\n+                    out.printf(\"wrote: 0x%x%n\", bb.get(0));\n+                    assertEquals(sc2.read(bb.clear()), -1);\n+                    t.awaitCompletion();\n+                }\n+            }\n+            deleteFile(addr);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"family\")\n+    public void SPINNBAccep_NBConn_BIO_WR_11(ProtocolFamily family)\n+            throws Throwable {\n+        try (ServerSocketChannel ssc = openServerSocketChannel(family)) {\n+            ssc.bind(null);\n+            SocketAddress addr = ssc.getLocalAddress();\n+\n+            try (SocketChannel sc = openSocketChannel(family)) {\n+                sc.configureBlocking(false);\n+                sc.connect(addr);\n+\n+                SocketChannel accepted;\n+                for (; ; ) {\n+                    accepted = ssc.accept();\n+                    if (accepted != null) {\n+                        out.println(\"accepted new connection\");\n+                        break;\n+                    }\n+                    Thread.onSpinWait();\n+                }\n+\n+                try (SocketChannel sc2 = accepted) {\n+                    assertTrue(sc.finishConnect());\n+                    sc.configureBlocking(true);\n+                    TestThread t = TestThread.of(\"t11\", () -> {\n+                        ByteBuffer bb = ByteBuffer.allocate(10).put((byte) 0x11).flip();\n+                        assertEquals(sc.write(bb), 1);\n+                        out.printf(\"wrote: 0x%x%n\", bb.get(0));\n+                        assertEquals(sc.read(bb.clear()), -1);\n+                    });\n+                    t.start();\n+\n+                    ByteBuffer bb = ByteBuffer.allocate(10);\n+                    assertEquals(sc2.read(bb), 1);\n+                    out.printf(\"read:  0x%x%n\", bb.get(0));\n+                    assertEquals(bb.get(0), 0x11);\n+                    sc2.shutdownOutput();\n+                    t.awaitCompletion();\n+                }\n+            }\n+            deleteFile(addr);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"family\")\n+    public void SPINNBAccep_NBConn_BIO_RW_12(ProtocolFamily family)\n+            throws Throwable {\n+        try (ServerSocketChannel ssc = openServerSocketChannel(family)) {\n+            ssc.bind(null);\n+            SocketAddress addr = ssc.getLocalAddress();\n+\n+            try (SocketChannel sc = openSocketChannel(family)) {\n+                sc.configureBlocking(false);\n+                sc.connect(addr);\n+\n+                SocketChannel accepted;\n+                for (; ; ) {\n+                    accepted = ssc.accept();\n+                    if (accepted != null) {\n+                        out.println(\"accepted new connection\");\n+                        break;\n+                    }\n+                    Thread.onSpinWait();\n+                }\n+\n+                try (SocketChannel sc2 = accepted) {\n+                    assertTrue(sc.finishConnect());\n+                    sc.configureBlocking(true);\n+                    TestThread t = TestThread.of(\"t12\", () -> {\n+                        ByteBuffer bb = ByteBuffer.allocate(10);\n+                        assertEquals(sc.read(bb), 1);\n+                        out.printf(\"read:  0x%x%n\", bb.get(0));\n+                        assertEquals(bb.get(0), 0x12);\n+                        sc.shutdownOutput();\n+                    });\n+                    t.start();\n+\n+                    ByteBuffer bb = ByteBuffer.allocate(10).put((byte) 0x12).flip();\n+                    assertEquals(sc2.write(bb), 1);\n+                    out.printf(\"wrote: 0x%x%n\", bb.get(0));\n+                    assertEquals(sc2.read(bb.clear()), -1);\n+                    t.awaitCompletion();\n+                }\n+            }\n+            deleteFile(addr);\n+        }\n+    }\n+\n+    \/\/ ---\n+    \/\/ Similar to the previous twelve scenarios but with non-blocking IO\n+    \/\/ ---\n+\n+    @Test(dataProvider = \"family\")\n+    public void BAccep_BConn_NBIO_WR_1a(ProtocolFamily family)\n+            throws Throwable {\n+        try (ServerSocketChannel ssc = openServerSocketChannel(family)) {\n+            ssc.bind(null);\n+            SocketAddress addr = ssc.getLocalAddress();\n+\n+            TestThread t = TestThread.of(\"t1a\", () -> {\n+                try (SocketChannel sc = openSocketChannel(family);\n+                     Selector selector = Selector.open()) {\n+                    assertTrue(sc.connect(addr));\n+                    ByteBuffer bb = ByteBuffer.allocate(10).put((byte) 0x1A).flip();\n+                    sc.configureBlocking(false);\n+                    SelectionKey k = sc.register(selector, OP_WRITE);\n+                    selector.select();\n+                    int c;\n+                    while ((c = sc.write(bb)) < 1) ;\n+                    assertEquals(c, 1);\n+                    out.printf(\"wrote: 0x%x%n\", bb.get(0));\n+                    k.interestOps(OP_READ);\n+                    selector.select();\n+                    bb.clear();\n+                    while ((c = sc.read(bb)) == 0) ;\n+                    assertEquals(c, -1);\n+                }\n+            });\n+            t.start();\n+\n+            try (SocketChannel sc = ssc.accept();\n+                 Selector selector = Selector.open()) {\n+                ByteBuffer bb = ByteBuffer.allocate(10);\n+                sc.configureBlocking(false);\n+                sc.register(selector, OP_READ);\n+                selector.select();\n+                int c;\n+                while ((c = sc.read(bb)) == 0) ;\n+                assertEquals(c, 1);\n+                out.printf(\"read:  0x%x%n\", bb.get(0));\n+                assertEquals(bb.get(0), 0x1A);\n+            }\n+            t.awaitCompletion();\n+            deleteFile(addr);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"family\")\n+    public void BAccep_BConn_NBIO_RW_2a(ProtocolFamily family)\n+            throws Throwable {\n+        try (ServerSocketChannel ssc = openServerSocketChannel(family)) {\n+            ssc.bind(null);\n+            SocketAddress addr = ssc.getLocalAddress();\n+\n+            TestThread t = TestThread.of(\"t2a\", () -> {\n+                try (SocketChannel sc = openSocketChannel(family);\n+                     Selector selector = Selector.open()) {\n+                    assertTrue(sc.connect(addr));\n+                    ByteBuffer bb = ByteBuffer.allocate(10);\n+                    sc.configureBlocking(false);\n+                    sc.register(selector, OP_READ);\n+                    selector.select();\n+                    int c;\n+                    while ((c = sc.read(bb)) == 0) ;\n+                    assertEquals(c, 1);\n+                    out.printf(\"read:  0x%x%n\", bb.get(0));\n+                    assertEquals(bb.get(0), 0x2A);\n+                }\n+            });\n+            t.start();\n+\n+            try (SocketChannel sc = ssc.accept();\n+                 Selector selector = Selector.open()) {\n+                ByteBuffer bb = ByteBuffer.allocate(10).put((byte) 0x2A).flip();\n+                sc.configureBlocking(false);\n+                SelectionKey k = sc.register(selector, OP_WRITE);\n+                selector.select();\n+                int c;\n+                while ((c = sc.write(bb)) < 1) ;\n+                assertEquals(c, 1);\n+                out.printf(\"wrote: 0x%x%n\", bb.get(0));\n+                k.interestOps(OP_READ);\n+                selector.select();\n+                bb.clear();\n+                while ((c = sc.read(bb)) == 0) ;\n+                assertEquals(c, -1);\n+            }\n+            t.awaitCompletion();\n+            deleteFile(addr);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"family\")\n+    public void SELNBAccep_BConn_NBIO_WR_3a(ProtocolFamily family)\n+            throws Throwable {\n+        try (ServerSocketChannel ssc = openServerSocketChannel(family);\n+             Selector aselector = Selector.open()) {\n+            ssc.bind(null);\n+            SocketAddress addr = ssc.getLocalAddress();\n+\n+            TestThread t = TestThread.of(\"t3a\", () -> {\n+                try (SocketChannel sc = openSocketChannel(family);\n+                     Selector selector = Selector.open()) {\n+                    assertTrue(sc.connect(addr));\n+                    ByteBuffer bb = ByteBuffer.allocate(10).put((byte) 0x3A).flip();\n+                    sc.configureBlocking(false);\n+                    SelectionKey k = sc.register(selector, OP_WRITE);\n+                    selector.select();\n+                    int c;\n+                    while ((c = sc.write(bb)) < 1) ;\n+                    assertEquals(c, 1);\n+                    out.printf(\"wrote: 0x%x%n\", bb.get(0));\n+                    k.interestOps(OP_READ);\n+                    selector.select();\n+                    bb.clear();\n+                    while ((c = sc.read(bb)) == 0) ;\n+                    assertEquals(c, -1);\n+                }\n+            });\n+            t.start();\n+\n+            ssc.configureBlocking(false).register(aselector, OP_ACCEPT);\n+            assertEquals(aselector.select(), 1);\n+\n+            try (SocketChannel sc = ssc.accept();\n+                 Selector selector = Selector.open()) {\n+                ByteBuffer bb = ByteBuffer.allocate(10);\n+                sc.configureBlocking(false);\n+                sc.register(selector, OP_READ);\n+                selector.select();\n+                int c;\n+                while ((c = sc.read(bb)) == 0) ;\n+                assertEquals(c, 1);\n+                out.printf(\"read:  0x%x%n\", bb.get(0));\n+                assertEquals(bb.get(0), 0x3A);\n+            }\n+            t.awaitCompletion();\n+            deleteFile(addr);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"family\")\n+    public void SELNBAccep_BConn_NBIO_RW_4a(ProtocolFamily family)\n+            throws Throwable {\n+        try (ServerSocketChannel ssc = openServerSocketChannel(family);\n+             Selector aselector = Selector.open()) {\n+            ssc.bind(null);\n+            SocketAddress addr = ssc.getLocalAddress();\n+\n+            TestThread t = TestThread.of(\"t4a\", () -> {\n+                try (SocketChannel sc = openSocketChannel(family);\n+                     Selector selector = Selector.open()) {\n+                    assertTrue(sc.connect(addr));\n+                    ByteBuffer bb = ByteBuffer.allocate(10);\n+                    sc.configureBlocking(false);\n+                    sc.register(selector, OP_READ);\n+                    selector.select();\n+                    int c;\n+                    while ((c = sc.read(bb)) == 0) ;\n+                    assertEquals(c, 1);\n+                    out.printf(\"read:  0x%x%n\", bb.get(0));\n+                    assertEquals(bb.get(0), 0x4A);\n+                }\n+            });\n+            t.start();\n+\n+            ssc.configureBlocking(false).register(aselector, OP_ACCEPT);\n+            assertEquals(aselector.select(), 1);\n+\n+            try (SocketChannel sc = ssc.accept();\n+                 Selector selector = Selector.open()) {\n+                ByteBuffer bb = ByteBuffer.allocate(10).put((byte) 0x4A).flip();\n+                sc.configureBlocking(false);\n+                SelectionKey k = sc.register(selector, OP_WRITE);\n+                selector.select();\n+                int c;\n+                while ((c = sc.write(bb)) < 1) ;\n+                assertEquals(c, 1);\n+                out.printf(\"wrote: 0x%x%n\", bb.get(0));\n+                k.interestOps(OP_READ);\n+                selector.select();\n+                bb.clear();\n+                while ((c = sc.read(bb)) == 0) ;\n+                assertEquals(c, -1);\n+            }\n+            t.awaitCompletion();\n+            deleteFile(addr);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"family\")\n+    public void SPINNBAccep_BConn_NBIO_WR_5a(ProtocolFamily family)\n+            throws Throwable {\n+        try (ServerSocketChannel ssc = openServerSocketChannel(family)) {\n+            ssc.bind(null);\n+            SocketAddress addr = ssc.getLocalAddress();\n+\n+            TestThread t = TestThread.of(\"t5a\", () -> {\n+                try (SocketChannel sc = openSocketChannel(family);\n+                     Selector selector = Selector.open()) {\n+                    assertTrue(sc.connect(addr));\n+                    ByteBuffer bb = ByteBuffer.allocate(10).put((byte) 0x5A).flip();\n+                    sc.configureBlocking(false);\n+                    SelectionKey k = sc.register(selector, OP_WRITE);\n+                    selector.select();\n+                    int c;\n+                    while ((c = sc.write(bb)) < 1) ;\n+                    assertEquals(c, 1);\n+                    out.printf(\"wrote: 0x%x%n\", bb.get(0));\n+                    k.interestOps(OP_READ);\n+                    selector.select();\n+                    bb.clear();\n+                    while ((c = sc.read(bb)) == 0) ;\n+                    assertEquals(c, -1);\n+                }\n+            });\n+            t.start();\n+\n+            SocketChannel accepted;\n+            for (; ; ) {\n+                accepted = ssc.accept();\n+                if (accepted != null) {\n+                    out.println(\"accepted new connection\");\n+                    break;\n+                }\n+                Thread.onSpinWait();\n+            }\n+\n+            try (SocketChannel sc = accepted;\n+                 Selector selector = Selector.open()) {\n+                ByteBuffer bb = ByteBuffer.allocate(10);\n+                sc.configureBlocking(false);\n+                sc.register(selector, OP_READ);\n+                selector.select();\n+                int c;\n+                while ((c = sc.read(bb)) == 0) ;\n+                assertEquals(c, 1);\n+                out.printf(\"read:  0x%x%n\", bb.get(0));\n+                assertEquals(bb.get(0), 0x5A);\n+            }\n+            t.awaitCompletion();\n+            deleteFile(addr);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"family\")\n+    public void SPINNBAccep_BConn_NBIO_RW_6a(ProtocolFamily family)\n+            throws Throwable {\n+        try (ServerSocketChannel ssc = openServerSocketChannel(family)) {\n+            ssc.bind(null);\n+            SocketAddress addr = ssc.getLocalAddress();\n+\n+            TestThread t = TestThread.of(\"t6a\", () -> {\n+                try (SocketChannel sc = openSocketChannel(family);\n+                     Selector selector = Selector.open()) {\n+                    assertTrue(sc.connect(addr));\n+                    ByteBuffer bb = ByteBuffer.allocate(10);\n+                    sc.configureBlocking(false);\n+                    sc.register(selector, OP_READ);\n+                    selector.select();\n+                    int c;\n+                    while ((c = sc.read(bb)) == 0) ;\n+                    assertEquals(c, 1);\n+                    out.printf(\"read:  0x%x%n\", bb.get(0));\n+                    assertEquals(bb.get(0), 0x6A);\n+                }\n+            });\n+            t.start();\n+\n+            SocketChannel accepted;\n+            for (; ; ) {\n+                accepted = ssc.accept();\n+                if (accepted != null) {\n+                    out.println(\"accepted new connection\");\n+                    break;\n+                }\n+                Thread.onSpinWait();\n+            }\n+\n+            try (SocketChannel sc = accepted;\n+                 Selector selector = Selector.open()) {\n+                ByteBuffer bb = ByteBuffer.allocate(10).put((byte) 0x6A).flip();\n+                sc.configureBlocking(false);\n+                SelectionKey k = sc.register(selector, OP_WRITE);\n+                selector.select();\n+                int c;\n+                while ((c = sc.write(bb)) < 1) ;\n+                assertEquals(c, 1);\n+                out.printf(\"wrote: 0x%x%n\", bb.get(0));\n+                k.interestOps(OP_READ);\n+                selector.select();\n+                bb.clear();\n+                while ((c = sc.read(bb)) == 0) ;\n+                assertEquals(c, -1);\n+\n+            }\n+            t.awaitCompletion();\n+            deleteFile(addr);\n+        }\n+    }\n+\n+    \/\/ Similar to the previous six scenarios but with same-thread\n+    \/\/ non-blocking connect.\n+\n+    @Test(dataProvider = \"family\")\n+    public void BAccep_NBConn_NBIO_WR_7a(ProtocolFamily family)\n+            throws Throwable {\n+        try (ServerSocketChannel ssc = openServerSocketChannel(family)) {\n+            ssc.bind(null);\n+            SocketAddress addr = ssc.getLocalAddress();\n+\n+            try (SocketChannel sc = openSocketChannel(family)) {\n+                sc.configureBlocking(false);\n+                sc.connect(addr);\n+\n+                try (SocketChannel sc2 = ssc.accept()) {\n+                    assertTrue(sc.finishConnect());\n+                    TestThread t = TestThread.of(\"t7a\", () -> {\n+                        try (Selector selector = Selector.open()) {\n+                            ByteBuffer bb = ByteBuffer.allocate(10).put((byte) 0x7A).flip();\n+                            sc.configureBlocking(false);\n+                            SelectionKey k = sc.register(selector, OP_WRITE);\n+                            selector.select();\n+                            int c;\n+                            while ((c = sc.write(bb)) < 1) ;\n+                            assertEquals(c, 1);\n+                            out.printf(\"wrote: 0x%x%n\", bb.get(0));\n+                            k.interestOps(OP_READ);\n+                            selector.select();\n+                            bb.clear();\n+                            while ((c = sc.read(bb)) == 0) ;\n+                            assertEquals(c, -1);\n+                        }\n+                    });\n+                    t.start();\n+\n+                    ByteBuffer bb = ByteBuffer.allocate(10);\n+                    sc2.configureBlocking(false);\n+                    try (Selector selector = Selector.open()) {\n+                        sc2.register(selector, OP_READ);\n+                        selector.select();\n+                        int c;\n+                        while ((c = sc2.read(bb)) == 0) ;\n+                        assertEquals(c, 1);\n+                        out.printf(\"read:  0x%x%n\", bb.get(0));\n+                        assertEquals(bb.get(0), 0x7A);\n+                        sc2.shutdownOutput();\n+                    }\n+                    t.awaitCompletion();\n+                }\n+            }\n+            deleteFile(addr);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"family\")\n+    public void BAccep_NBConn_NBIO_RW_8a(ProtocolFamily family)\n+            throws Throwable {\n+        try (ServerSocketChannel ssc = openServerSocketChannel(family)) {\n+            ssc.bind(null);\n+            SocketAddress addr = ssc.getLocalAddress();\n+\n+            try (SocketChannel sc = openSocketChannel(family)) {\n+                sc.configureBlocking(false);\n+                sc.connect(addr);\n+\n+                try (SocketChannel sc2 = ssc.accept()) {\n+                    assertTrue(sc.finishConnect());\n+                    TestThread t = TestThread.of(\"t8a\", () -> {\n+                        try (Selector selector = Selector.open()) {\n+                            ByteBuffer bb = ByteBuffer.allocate(10);\n+                            sc.register(selector, OP_READ);\n+                            selector.select();\n+                            int c;\n+                            while ((c = sc.read(bb)) == 0) ;\n+                            assertEquals(c, 1);\n+                            out.printf(\"read:  0x%x%n\", bb.get(0));\n+                            assertEquals(bb.get(0), (byte) 0x8A);\n+                            sc.shutdownOutput();\n+                        }\n+                    });\n+                    t.start();\n+\n+                    ByteBuffer bb = ByteBuffer.allocate(10).put((byte) 0x8A).flip();\n+                    sc2.configureBlocking(false);\n+                    try (Selector selector = Selector.open()) {\n+                        SelectionKey k = sc2.register(selector, OP_WRITE);\n+                        selector.select();\n+                        int c;\n+                        while ((c = sc2.write(bb)) < 1) ;\n+                        assertEquals(c, 1);\n+                        out.printf(\"wrote: 0x%x%n\", bb.get(0));\n+                        k.interestOps(OP_READ);\n+                        selector.select();\n+                        bb.clear();\n+                        while ((c = sc2.read(bb)) == 0) ;\n+                        assertEquals(c, -1);\n+                    }\n+                    t.awaitCompletion();\n+                }\n+            }\n+            deleteFile(addr);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"family\")\n+    public void SELNBAccep_NBConn_NBIO_WR_9a(ProtocolFamily family)\n+            throws Throwable {\n+        try (ServerSocketChannel ssc = openServerSocketChannel(family)) {\n+            ssc.bind(null);\n+            SocketAddress addr = ssc.getLocalAddress();\n+\n+            try (SocketChannel sc = openSocketChannel(family)) {\n+                sc.configureBlocking(false);\n+                sc.connect(addr);\n+\n+                Selector aselector = Selector.open();\n+                ssc.configureBlocking(false).register(aselector, OP_ACCEPT);\n+                assertEquals(aselector.select(), 1);\n+\n+                try (SocketChannel sc2 = ssc.accept()) {\n+                    assertTrue(sc.finishConnect());\n+                    TestThread t = TestThread.of(\"t9a\", () -> {\n+                        try (Selector selector = Selector.open()) {\n+                            ByteBuffer bb = ByteBuffer.allocate(10).put((byte) 0x9A).flip();\n+                            sc.configureBlocking(false);\n+                            SelectionKey k = sc.register(selector, OP_WRITE);\n+                            selector.select();\n+                            int c;\n+                            while ((c = sc.write(bb)) < 1) ;\n+                            assertEquals(c, 1);\n+                            out.printf(\"wrote: 0x%x%n\", bb.get(0));\n+                            k.interestOps(OP_READ);\n+                            selector.select();\n+                            bb.clear();\n+                            while ((c = sc.read(bb)) == 0) ;\n+                            assertEquals(c, -1);\n+                        }\n+                    });\n+                    t.start();\n+\n+                    ByteBuffer bb = ByteBuffer.allocate(10);\n+                    sc2.configureBlocking(false);\n+                    try (Selector selector = Selector.open()) {\n+                        sc2.register(selector, OP_READ);\n+                        selector.select();\n+                        int c;\n+                        while ((c = sc2.read(bb)) == 0) ;\n+                        assertEquals(c, 1);\n+                        out.printf(\"read:  0x%x%n\", bb.get(0));\n+                        assertEquals(bb.get(0), (byte) 0x9A);\n+                        sc2.shutdownOutput();\n+                    }\n+                    t.awaitCompletion();\n+                }\n+            }\n+            deleteFile(addr);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"family\")\n+    public void SELNBAccep_NBConn_NBIO_RW_10a(ProtocolFamily family)\n+            throws Throwable {\n+        try (ServerSocketChannel ssc = openServerSocketChannel(family)) {\n+            ssc.bind(null);\n+            SocketAddress addr = ssc.getLocalAddress();\n+\n+            try (SocketChannel sc = openSocketChannel(family)) {\n+                sc.configureBlocking(false);\n+                sc.connect(addr);\n+\n+                Selector aselector = Selector.open();\n+                ssc.configureBlocking(false).register(aselector, OP_ACCEPT);\n+                assertEquals(aselector.select(), 1);\n+\n+                try (SocketChannel sc2 = ssc.accept()) {\n+                    assertTrue(sc.finishConnect());\n+                    TestThread t = TestThread.of(\"t10a\", () -> {\n+                        try (Selector selector = Selector.open()) {\n+                            ByteBuffer bb = ByteBuffer.allocate(10);\n+                            sc.register(selector, OP_READ);\n+                            selector.select();\n+                            int c;\n+                            while ((c = sc.read(bb)) == 0) ;\n+                            assertEquals(c, 1);\n+                            out.printf(\"read:  0x%x%n\", bb.get(0));\n+                            assertEquals(bb.get(0), (byte) 0xAA);\n+                            sc.shutdownOutput();\n+                        }\n+                    });\n+                    t.start();\n+\n+                    ByteBuffer bb = ByteBuffer.allocate(10).put((byte) 0xAA).flip();\n+                    sc2.configureBlocking(false);\n+                    try (Selector selector = Selector.open()) {\n+                        SelectionKey k = sc2.register(selector, OP_WRITE);\n+                        selector.select();\n+                        int c;\n+                        while ((c = sc2.write(bb)) < 1) ;\n+                        assertEquals(c, 1);\n+                        out.printf(\"wrote: 0x%x%n\", bb.get(0));\n+                        k.interestOps(OP_READ);\n+                        selector.select();\n+                        bb.clear();\n+                        while ((c = sc2.read(bb)) == 0) ;\n+                        assertEquals(c, -1);\n+                    }\n+                    t.awaitCompletion();\n+                }\n+            }\n+            deleteFile(addr);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"family\")\n+    public void SPINBAccep_NBConn_NBIO_WR_11a(ProtocolFamily family)\n+            throws Throwable {\n+        try (ServerSocketChannel ssc = openServerSocketChannel(family)) {\n+            ssc.bind(null);\n+            SocketAddress addr = ssc.getLocalAddress();\n+\n+            try (SocketChannel sc = openSocketChannel(family)) {\n+                sc.configureBlocking(false);\n+                sc.connect(addr);\n+\n+                SocketChannel accepted;\n+                for (; ; ) {\n+                    accepted = ssc.accept();\n+                    if (accepted != null) {\n+                        out.println(\"accepted new connection\");\n+                        break;\n+                    }\n+                    Thread.onSpinWait();\n+                }\n+\n+                try (SocketChannel sc2 = accepted) {\n+                    assertTrue(sc.finishConnect());\n+                    TestThread t = TestThread.of(\"t11a\", () -> {\n+                        try (Selector selector = Selector.open()) {\n+                            ByteBuffer bb = ByteBuffer.allocate(10).put((byte) 0xBA).flip();\n+                            sc.configureBlocking(false);\n+                            SelectionKey k = sc.register(selector, OP_WRITE);\n+                            selector.select();\n+                            int c;\n+                            while ((c = sc.write(bb)) < 1) ;\n+                            assertEquals(c, 1);\n+                            out.printf(\"wrote: 0x%x%n\", bb.get(0));\n+                            k.interestOps(OP_READ);\n+                            selector.select();\n+                            bb.clear();\n+                            while ((c = sc.read(bb)) == 0) ;\n+                            assertEquals(c, -1);\n+                        }\n+                    });\n+                    t.start();\n+\n+                    ByteBuffer bb = ByteBuffer.allocate(10);\n+                    sc2.configureBlocking(false);\n+                    try (Selector selector = Selector.open()) {\n+                        sc2.register(selector, OP_READ);\n+                        selector.select();\n+                        int c;\n+                        while ((c = sc2.read(bb)) == 0) ;\n+                        assertEquals(c, 1);\n+                        out.printf(\"read:  0x%x%n\", bb.get(0));\n+                        assertEquals(bb.get(0), (byte) 0xBA);\n+                        sc2.shutdownOutput();\n+                    }\n+                    t.awaitCompletion();\n+                }\n+            }\n+            deleteFile(addr);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"family\")\n+    public void SPINBAccep_NBConn_NBIO_RW_12a(ProtocolFamily family)\n+            throws Throwable {\n+        try (ServerSocketChannel ssc = openServerSocketChannel(family)) {\n+            ssc.bind(null);\n+            SocketAddress addr = ssc.getLocalAddress();\n+\n+            try (SocketChannel sc = openSocketChannel(family)) {\n+                sc.configureBlocking(false);\n+                sc.connect(addr);\n+\n+                SocketChannel accepted;\n+                for (; ; ) {\n+                    accepted = ssc.accept();\n+                    if (accepted != null) {\n+                        out.println(\"accepted new connection\");\n+                        break;\n+                    }\n+                    Thread.onSpinWait();\n+                }\n+\n+                try (SocketChannel sc2 = accepted) {\n+                    assertTrue(sc.finishConnect());\n+                    TestThread t = TestThread.of(\"t10a\", () -> {\n+                        try (Selector selector = Selector.open()) {\n+                            ByteBuffer bb = ByteBuffer.allocate(10);\n+                            sc.register(selector, OP_READ);\n+                            selector.select();\n+                            int c;\n+                            while ((c = sc.read(bb)) == 0) ;\n+                            assertEquals(c, 1);\n+                            out.printf(\"read:  0x%x%n\", bb.get(0));\n+                            assertEquals(bb.get(0), (byte) 0xCA);\n+                            sc.shutdownOutput();\n+                        }\n+                    });\n+                    t.start();\n+\n+                    ByteBuffer bb = ByteBuffer.allocate(10).put((byte) 0xCA).flip();\n+                    sc2.configureBlocking(false);\n+                    try (Selector selector = Selector.open()) {\n+                        SelectionKey k = sc2.register(selector, OP_WRITE);\n+                        selector.select();\n+                        int c;\n+                        while ((c = sc2.write(bb)) < 1) ;\n+                        assertEquals(c, 1);\n+                        out.printf(\"wrote: 0x%x%n\", bb.get(0));\n+                        k.interestOps(OP_READ);\n+                        selector.select();\n+                        bb.clear();\n+                        while ((c = sc2.read(bb)) == 0) ;\n+                        assertEquals(c, -1);\n+                    }\n+                    t.awaitCompletion();\n+                }\n+            }\n+            deleteFile(addr);\n+        }\n+    }\n+\n+    \/\/ --\n+\n+    static class TestThread extends Thread {\n+        private final UncheckedRunnable runnable;\n+        private volatile Throwable throwable;\n+\n+        TestThread(UncheckedRunnable runnable, String name) {\n+            super(name);\n+            this.runnable = runnable;\n+        }\n+\n+        @Override\n+        public void run() {\n+            try {\n+                runnable.run();\n+            } catch (Throwable t) {\n+                out.printf(\"[%s] caught unexpected: %s%n\", getName(), t);\n+                throwable = t;\n+            }\n+        }\n+\n+        interface UncheckedRunnable {\n+            void run() throws Throwable;\n+        }\n+\n+        static TestThread of(String name, UncheckedRunnable runnable) {\n+            return new TestThread(runnable, name);\n+        }\n+\n+        void awaitCompletion() throws Throwable {\n+            this.join();\n+            if (throwable != null)\n+                throw throwable;\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/nio\/channels\/unixdomain\/IOExchanges.java","additions":1243,"deletions":0,"binary":false,"changes":1243,"status":"added"},{"patch":"@@ -0,0 +1,64 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8245194\n+ * @run main\/othervm NonBlockingAccept\n+ *\/\n+\n+import java.net.StandardProtocolFamily;\n+import java.nio.channels.ServerSocketChannel;\n+import java.nio.channels.SocketChannel;\n+\n+public class NonBlockingAccept {\n+\n+    static boolean supported() {\n+        try {\n+            SocketChannel.open(StandardProtocolFamily.UNIX).close();\n+        } catch (UnsupportedOperationException e) {\n+            return false;\n+        } catch (Exception e) {\n+            return true;\n+        }\n+        return true;\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        if (!supported()) {\n+            return;\n+        }\n+\n+        try (ServerSocketChannel serverSocketChannel =\n+                                 ServerSocketChannel.open(StandardProtocolFamily.UNIX)) {\n+            \/\/non blocking mode\n+            serverSocketChannel.configureBlocking(false);\n+            serverSocketChannel.bind(null);\n+            SocketChannel socketChannel = serverSocketChannel.accept();\n+            System.out.println(\"The socketChannel is : expected Null \" + socketChannel);\n+            \/\/ exception could be thrown otherwise\n+        }\n+    }\n+}\n+\n","filename":"test\/jdk\/java\/nio\/channels\/unixdomain\/NonBlockingAccept.java","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8245194\n+ * @run testng NullTest\n+ *\/\n+\n+import java.net.ProtocolFamily;\n+import java.net.SocketAddress;\n+import java.net.UnixDomainSocketAddress;\n+import java.nio.channels.*;\n+import java.nio.file.Path;\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.assertThrows;\n+\n+\/**\n+ * Check for NPE\n+ *\/\n+public class NullTest {\n+\n+    \/\/ Expected exception\n+    private static final Class<NullPointerException> NPE =\n+        NullPointerException.class;\n+\n+    @Test\n+    public static void runTest() throws Exception {\n+        assertThrows(NPE, () -> SocketChannel.open((ProtocolFamily)null));\n+        assertThrows(NPE, () -> SocketChannel.open((SocketAddress)null));\n+        assertThrows(NPE, () -> ServerSocketChannel.open((ProtocolFamily)null));\n+        assertThrows(NPE, () -> UnixDomainSocketAddress.of((Path)null));\n+        assertThrows(NPE, () -> UnixDomainSocketAddress.of((String)null));\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/nio\/channels\/unixdomain\/NullTest.java","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -0,0 +1,196 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8245194\n+ * @run main\/othervm\/java.security.policy=policy1 Security policy1\n+ * @run main\/othervm\/java.security.policy=policy2 Security policy2\n+ * @run main\/othervm Security policy3\n+ * @summary Security test for Unix Domain socket and server socket channels\n+ *\/\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.net.SocketAddress;\n+import java.net.UnixDomainSocketAddress;\n+import java.nio.channels.*;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Comparator;\n+\n+import static java.net.StandardProtocolFamily.UNIX;\n+\n+\/**\n+ * Tests required all with security manager\n+ *\/\n+\n+public class Security {\n+\n+    static interface Command {\n+        public void run() throws Exception;\n+    }\n+\n+    static <T extends Exception> void call(Command r, Class<? extends Exception> expectedException) {\n+        boolean threw = false;\n+        try {\n+            r.run();\n+        } catch (Throwable t) {\n+            if (expectedException == null) {\n+                t.printStackTrace();\n+                throw new RuntimeException(\"an exception was thrown but was not expected\");\n+            }\n+            threw = true;\n+            if (!(expectedException.isAssignableFrom(t.getClass()))) {\n+                throw new RuntimeException(\"wrong exception type thrown \" + t.toString());\n+            }\n+        }\n+        if (expectedException != null && !threw) {\n+            \/\/ should have thrown\n+            throw new RuntimeException(\"% was expected\".formatted(expectedException.getName()));\n+        }\n+    }\n+\n+\n+    public static void main(String[] args) throws Exception {\n+        try {\n+           SocketChannel.open(UNIX);\n+        } catch (UnsupportedOperationException e) {\n+            System.out.println(\"Unix domain not supported\");\n+            return;\n+        }\n+\n+        String policy = args[0];\n+        switch (policy) {\n+            case \"policy1\":\n+                testPolicy1();\n+                break;\n+            case \"policy2\":\n+                testPolicy2();\n+                break;\n+            case \"policy3\":\n+                testPolicy3();\n+                break;\n+        }\n+    }\n+\n+    static void setSecurityManager(String policy) {\n+        String testSrc = System.getProperty(\"test.src\");\n+        \/\/ Three \/\/\/ required for Windows below\n+        String policyURL = \"file:\/\/\/\" + testSrc + File.separator + policy;\n+        System.out.println(\"POLICY: \" + policyURL);\n+        System.setProperty(\"java.security.policy\", policyURL);\n+        System.setSecurityManager(new SecurityManager());\n+    }\n+\n+    static void close(NetworkChannel... channels) {\n+\n+        for (NetworkChannel chan : channels) {\n+            try {\n+                chan.close();\n+            } catch (Exception e) {\n+            }\n+        }\n+    }\n+\n+    private static final Class<SecurityException> SE = SecurityException.class;\n+    private static final Class<IOException> IOE = IOException.class;\n+\n+    \/\/ No permission\n+\n+    public static void testPolicy1() throws Exception {\n+        Path servername = Path.of(\"sock\");\n+        Files.deleteIfExists(servername);\n+        \/\/ Permission exists to bind a ServerSocketChannel\n+        final UnixDomainSocketAddress saddr = UnixDomainSocketAddress.of(servername);\n+        try (final ServerSocketChannel server = ServerSocketChannel.open(UNIX)) {\n+            try (final SocketChannel client = SocketChannel.open(UNIX)) {\n+                call(() -> {\n+                    server.bind(saddr);\n+                }, SE);\n+                call(() -> {\n+                    client.connect(saddr);\n+                }, SE);\n+            }\n+        } finally {\n+            Files.deleteIfExists(servername);\n+        }\n+    }\n+\n+    \/\/ All permissions\n+\n+    public static void testPolicy2() throws Exception {\n+        Path servername = Path.of(\"sock\");\n+        Files.deleteIfExists(servername);\n+        final UnixDomainSocketAddress saddr = UnixDomainSocketAddress.of(servername);\n+        try (final ServerSocketChannel server = ServerSocketChannel.open(UNIX)) {\n+            try (final SocketChannel client = SocketChannel.open(UNIX)) {\n+                call(() -> {\n+                    server.bind(saddr);\n+                }, null);\n+                call(() -> {\n+                    client.connect(saddr);\n+                }, null);\n+            }\n+        } finally {\n+            Files.deleteIfExists(servername);\n+        }\n+    }\n+\n+    public static void testPolicy3() throws Exception {\n+        Path sock1 = Path.of(\"sock3\");\n+        Files.deleteIfExists(sock1);\n+        final UnixDomainSocketAddress saddr = UnixDomainSocketAddress.of(sock1);\n+        try (var s1 = ServerSocketChannel.open(UNIX)) {\n+            s1.bind(saddr);\n+            try (var s2 = ServerSocketChannel.open(UNIX)) {\n+                s2.bind(null);\n+                var add2 = (UnixDomainSocketAddress)s2.getLocalAddress();\n+                saddr.getPath().toFile().deleteOnExit();\n+                add2.getPath().toFile().deleteOnExit();\n+\n+                \/\/ Now set security manager and check if we can see addresses\n+\n+                setSecurityManager(\"policy3\");\n+\n+                if (((UnixDomainSocketAddress)s1\n+                            .getLocalAddress())\n+                            .getPath()\n+                            .toString()\n+                            .length() != 0)\n+                {\n+                    throw new RuntimeException(\"address should have been empty\");\n+                }\n+\n+                if (((UnixDomainSocketAddress)s2\n+                            .getLocalAddress())\n+                            .getPath()\n+                            .toString()\n+                            .length() != 0)\n+                {\n+                    throw new RuntimeException(\"address should have been empty\");\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/nio\/channels\/unixdomain\/Security.java","additions":196,"deletions":0,"binary":false,"changes":196,"status":"added"},{"patch":"@@ -0,0 +1,123 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8245194\n+ * @run main\/othervm Shutdown\n+ *\/\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.net.*;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.*;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.util.Arrays;\n+\n+\/**\n+ * Check that half close works\n+ *\/\n+public class Shutdown {\n+\n+    public static void main(String args[]) throws Exception {\n+        if (!supported()) {\n+            System.out.println(\"Unix domain channels not supported\");\n+            return;\n+        }\n+        runTest();\n+    }\n+\n+    static boolean supported() {\n+        try {\n+            SocketChannel.open(StandardProtocolFamily.UNIX).close();\n+        } catch (UnsupportedOperationException e) {\n+            return false;\n+        } catch (Exception e) {\n+            return true; \/\/ continue test to see what problem is\n+        }\n+        return true;\n+    }\n+\n+    static void assertTrue(boolean condition, String error) {\n+        if (!condition)\n+            throw new RuntimeException(error);\n+    }\n+\n+    public static void runTest() throws IOException {\n+        ServerSocketChannel server = null;\n+        SocketChannel client = null;\n+        SocketChannel acceptee = null;\n+        UnixDomainSocketAddress usa = null;\n+\n+        try {\n+            server = ServerSocketChannel.open(StandardProtocolFamily.UNIX);\n+            server.bind(null);\n+            usa = (UnixDomainSocketAddress)server.getLocalAddress();\n+            System.out.println(\"Local address \" + usa);\n+            client = SocketChannel.open(usa);\n+            acceptee = server.accept();\n+            ByteBuffer buf = ByteBuffer.wrap(\"Hello world\".getBytes(StandardCharsets.ISO_8859_1));\n+            ByteBuffer rx = ByteBuffer.allocate(buf.capacity());\n+            client.write(buf);\n+            buf.rewind();\n+            while (rx.hasRemaining())\n+                acceptee.read(rx);\n+\n+            assertTrue(Arrays.equals(buf.array(), rx.array()), \"array contents not equal\");\n+\n+            client.shutdownOutput();\n+            try {\n+                client.write(buf);\n+                throw new RuntimeException(\"shutdown error\");\n+            } catch (ClosedChannelException e) {\n+            }\n+\n+            rx.clear();\n+            int c = acceptee.read(rx);\n+            assertTrue(c == -1, \"read after remote shutdown\");\n+\n+            client.configureBlocking(false);\n+            c = client.read(rx);\n+            assertTrue(c == 0, \"expected c == 0\");\n+            client.shutdownInput();\n+            c = client.read(rx);\n+            assertTrue(c == -1, \"expected c == -1\");\n+        } finally {\n+            close(server);\n+            close(client);\n+            close(acceptee);\n+            if (usa != null)\n+                Files.delete(usa.getPath());\n+        }\n+        System.out.println(\"OK\");\n+    }\n+\n+    static void close(Closeable c) {\n+        try {\n+            if (c != null)\n+                c.close();\n+        } catch (IOException e) {}\n+    }\n+}\n","filename":"test\/jdk\/java\/nio\/channels\/unixdomain\/Shutdown.java","additions":123,"deletions":0,"binary":false,"changes":123,"status":"added"},{"patch":"@@ -0,0 +1,139 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8245194\n+ * @run main\/othervm SocketOptions\n+ *\/\n+\n+import java.io.IOException;\n+import java.net.*;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.*;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Set;\n+import jdk.net.UnixDomainPrincipal;\n+import static jdk.net.ExtendedSocketOptions.SO_PEERCRED;\n+\n+\/**\n+ * Check that all supported options can actually be set and got\n+ *\/\n+public class SocketOptions {\n+\n+    public static void main(String args[]) throws Exception {\n+        if (!supported()) {\n+            System.out.println(\"Unix domain channels not supported\");\n+            return;\n+        }\n+        test(ServerSocketChannel.open(StandardProtocolFamily.UNIX));\n+        test(SocketChannel.open(StandardProtocolFamily.UNIX));\n+        testPeerCred();\n+    }\n+\n+    static void testPeerCred() throws Exception {\n+        UnixDomainSocketAddress addr = null;\n+        UnixDomainPrincipal p;\n+        try (ServerSocketChannel s = ServerSocketChannel.open(StandardProtocolFamily.UNIX)) {\n+            s.bind(null);\n+            addr = (UnixDomainSocketAddress)s.getLocalAddress();\n+            try (SocketChannel c = SocketChannel.open(addr)) {\n+                if (!c.supportedOptions().contains(SO_PEERCRED)) {\n+                    return;\n+                }\n+                Files.deleteIfExists(addr.getPath());\n+                p = c.getOption(SO_PEERCRED);\n+                String s1 = p.user().getName();\n+                System.out.println(s1);\n+                System.out.println(p.group().getName());\n+                String s2 = System.getProperty(\"user.name\");\n+\n+                \/\/ Check returned user name\n+\n+                if (!s1.equals(s2)) {\n+                    throw new RuntimeException(\"wrong username\");\n+                }\n+\n+                \/\/ Try setting the option: Read only\n+\n+                try {\n+                    c.setOption(SO_PEERCRED, p);\n+                    throw new RuntimeException(\"should have thrown SocketException\");\n+                } catch (SocketException e) {}\n+            }\n+        } finally {\n+            if (addr != null)\n+                Files.deleteIfExists(addr.getPath());\n+        }\n+\n+        \/\/ Try getting from unconnected socket\n+\n+        try (var c = SocketChannel.open(StandardProtocolFamily.UNIX)) {\n+            try {\n+                p = c.getOption(SO_PEERCRED);\n+                System.out.println(p.user());\n+                throw new RuntimeException(\"should have thrown SocketException\");\n+            } catch (SocketException e) {}\n+        }\n+\n+        \/\/ Try getting from ServerSocketChannel\n+\n+        try (var server = ServerSocketChannel.open(StandardProtocolFamily.UNIX)) {\n+            try {\n+                p = server.getOption(SO_PEERCRED);\n+                System.out.println(p.user());\n+                throw new RuntimeException(\"should have thrown USE\");\n+            } catch (UnsupportedOperationException e) {}\n+        }\n+    }\n+\n+    static boolean supported() {\n+        try {\n+            SocketChannel.open(StandardProtocolFamily.UNIX).close();\n+        } catch (UnsupportedOperationException e) {\n+            return false;\n+        } catch (Exception e) {\n+            return true; \/\/ continue test to see what problem is\n+        }\n+        return true;\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public static void test(NetworkChannel chan) throws IOException {\n+        System.out.println(\"Checking: \" + chan.getClass());\n+        Set<SocketOption<?>> supported = chan.supportedOptions();\n+        for (SocketOption<?> option : supported) {\n+            String name = option.name();\n+            System.out.println(\"Checking option \" + name);\n+            if (option.type() == Boolean.class) {\n+                chan.setOption((SocketOption<Boolean>)option, true);\n+                chan.setOption((SocketOption<Boolean>)option, false);\n+                chan.getOption(option);\n+            } else if (option.type() == Integer.class) {\n+                chan.setOption((SocketOption<Integer>)option, 10);\n+                chan.getOption(option);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/nio\/channels\/unixdomain\/SocketOptions.java","additions":139,"deletions":0,"binary":false,"changes":139,"status":"added"},{"patch":"@@ -0,0 +1,4 @@\n+grant {\n+    \/\/ No permission\n+    permission java.io.FilePermission \"sock\", \"delete\";\n+};\n","filename":"test\/jdk\/java\/nio\/channels\/unixdomain\/policy1","additions":4,"deletions":0,"binary":false,"changes":4,"status":"added"},{"patch":"@@ -0,0 +1,6 @@\n+grant {\n+    \/\/ permission to bind a SocketChannel in sockets directory\n+    permission java.net.NetPermission \"accessUnixDomainSocket\";\n+\n+    permission java.io.FilePermission \"sock\", \"delete\";\n+};\n","filename":"test\/jdk\/java\/nio\/channels\/unixdomain\/policy2","additions":6,"deletions":0,"binary":false,"changes":6,"status":"added"},{"patch":"@@ -0,0 +1,4 @@\n+grant {\n+    \/\/ No permission\n+    permission java.io.FilePermission \"sock\", \"delete\";\n+};\n","filename":"test\/jdk\/java\/nio\/channels\/unixdomain\/policy3","additions":4,"deletions":0,"binary":false,"changes":4,"status":"added"},{"patch":"@@ -0,0 +1,193 @@\n+\/*\n+ * Copyright (c) 2020 Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.net;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.StandardProtocolFamily;\n+import java.net.UnixDomainSocketAddress;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.ClosedChannelException;\n+import java.nio.channels.ServerSocketChannel;\n+import java.nio.channels.SocketChannel;\n+import java.nio.file.*;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.runner.Runner;\n+import org.openjdk.jmh.runner.RunnerException;\n+import org.openjdk.jmh.runner.options.Options;\n+import org.openjdk.jmh.runner.options.OptionsBuilder;\n+\n+\/**\n+ * Tests sending a 128 byte message on a second, to a thread which\n+ * echo's it back and received by the original thread.\n+ * Benchmark is performed for \"inet\" channels over TCP\/IP\n+ * and \"unix\" domain channels.\n+ *\/\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Thread)\n+public class SocketChannelCompare {\n+\n+    static final int BUFSIZE = 128; \/\/ message size sent and received\n+    private ServerSocketChannel ssc;\n+    private SocketChannel s1, s2;\n+    private EchoThread rt;\n+    private ByteBuffer bb = ByteBuffer.allocate(BUFSIZE);\n+\n+    private static volatile String tempDir;\n+    private static final AtomicInteger count = new AtomicInteger(0);\n+    private volatile Path socket;\n+\n+    @Param({\"inet\", \"unix\"})\n+    private volatile String family;\n+\n+    static {\n+        try {\n+            Path p = Files.createTempDirectory(\"readWriteTest\");\n+            tempDir = p.toString();\n+        } catch (IOException e) {\n+            tempDir = null;\n+        }\n+    }\n+\n+    private ServerSocketChannel getServerSocketChannel() throws IOException {\n+        if (family.equals(\"inet\"))\n+            return getInetServerSocketChannel();\n+        else if (family.equals(\"unix\"))\n+            return getUnixServerSocketChannel();\n+        throw new InternalError();\n+    }\n+\n+\n+    private ServerSocketChannel getInetServerSocketChannel() throws IOException {\n+        InetAddress iaddr = InetAddress.getLoopbackAddress();\n+        return ServerSocketChannel.open().bind(null);\n+    }\n+\n+    private ServerSocketChannel getUnixServerSocketChannel() throws IOException {\n+        int next = count.incrementAndGet();\n+        socket = Paths.get(tempDir, Integer.toString(next));\n+        UnixDomainSocketAddress addr = UnixDomainSocketAddress.of(socket);\n+        return ServerSocketChannel.open(StandardProtocolFamily.UNIX).bind(addr);\n+    }\n+\n+    @Setup(Level.Trial)\n+    public void beforeRun() throws IOException {\n+        ssc = getServerSocketChannel();\n+        s1 = SocketChannel.open(ssc.getLocalAddress());\n+        s2 = ssc.accept();\n+\n+        rt = new EchoThread(s2);\n+        rt.start();\n+    }\n+\n+    @TearDown(Level.Trial)\n+    public void afterRun() throws IOException, InterruptedException {\n+        s1.close();\n+        s2.close();\n+        ssc.close();\n+        if (family.equals(\"unix\")) {\n+            Files.delete(socket);\n+            Files.delete(Path.of(tempDir));\n+        }\n+        rt.join();\n+    }\n+\n+    @Benchmark\n+    public void test() throws IOException {\n+        bb.position(0).limit(BUFSIZE);\n+        s1.write(bb);\n+        bb.clear();\n+        readFully(s1, bb);\n+    }\n+\n+    \/\/ read until buf is full, or EOF. Always returns number of bytes read\n+\n+    static int readFully(SocketChannel chan, ByteBuffer buf) throws IOException {\n+        int n = buf.remaining();\n+        int count = 0;\n+        while (n > 0) {\n+            int c = chan.read(buf);\n+            if (c == -1)\n+                return count;\n+            n -= c;\n+            count += c;\n+        }\n+        return count;\n+    }\n+\n+    static class EchoThread extends Thread {\n+        private SocketChannel sc;\n+\n+        public EchoThread(SocketChannel s2) {\n+            this.sc = s2;\n+        }\n+\n+        public void run() {\n+            try {\n+                ByteBuffer bb = ByteBuffer.allocate(BUFSIZE);\n+                while (true) {\n+                    bb.clear();\n+                    int c = readFully(sc, bb);\n+                    if (c == 0) {\n+                        sc.close();\n+                        return;\n+                    }\n+                    bb.flip();\n+                    sc.write(bb);\n+                }\n+            } catch (ClosedChannelException ex) {\n+                \/\/ shutdown time\n+            } catch (IOException ioex) {\n+                ioex.printStackTrace();\n+            }\n+        }\n+    }\n+\n+    public static void main(String[] args) throws RunnerException {\n+        Options opt = new OptionsBuilder()\n+                .include(org.openjdk.bench.java.net.SocketChannelCompare.class.getSimpleName())\n+                .warmupForks(1)\n+                .warmupIterations(2)\n+                .measurementIterations(2)\n+                .forks(2)\n+                .build();\n+\n+        new Runner(opt).run();\n+\n+        opt = new OptionsBuilder()\n+                .include(org.openjdk.bench.java.net.SocketChannelCompare.class.getSimpleName())\n+                .warmupForks(1)\n+                .warmupIterations(2)\n+                .measurementIterations(2)\n+                .jvmArgsPrepend(\"-Djdk.net.useFastTcpLoopback=true\")\n+                .forks(3)\n+                .build();\n+\n+        new Runner(opt).run();\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/net\/SocketChannelCompare.java","additions":193,"deletions":0,"binary":false,"changes":193,"status":"added"},{"patch":"@@ -0,0 +1,132 @@\n+\/*\n+ * Copyright (c) 2020 Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.net;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.StandardProtocolFamily;\n+import java.net.UnixDomainSocketAddress;\n+import java.nio.channels.ClosedChannelException;\n+import java.nio.channels.ServerSocketChannel;\n+import java.nio.channels.SocketChannel;\n+import java.nio.file.*;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.runner.Runner;\n+import org.openjdk.jmh.runner.RunnerException;\n+import org.openjdk.jmh.runner.options.Options;\n+import org.openjdk.jmh.runner.options.OptionsBuilder;\n+\n+\/**\n+ * Measures connection setup times\n+ *\/\n+@BenchmarkMode(Mode.SingleShotTime)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Thread)\n+public class SocketChannelConnectionSetup {\n+\n+    private ServerSocketChannel ssc;\n+    private SocketChannel s1, s2;\n+\n+    private static volatile String tempDir;\n+    private static final AtomicInteger count = new AtomicInteger(0);\n+    private volatile Path socket;\n+\n+    @Param({\"inet\", \"unix\"})\n+    private volatile String family;\n+\n+    static {\n+        try {\n+            Path p = Files.createTempDirectory(\"readWriteTest\");\n+            tempDir = p.toString();\n+        } catch (IOException e) {\n+            tempDir = null;\n+        }\n+    }\n+\n+    private ServerSocketChannel getServerSocketChannel() throws IOException {\n+        if (family.equals(\"inet\"))\n+            return getInetServerSocketChannel();\n+        else if (family.equals(\"unix\"))\n+            return getUnixServerSocketChannel();\n+        throw new InternalError();\n+    }\n+\n+\n+    private ServerSocketChannel getInetServerSocketChannel() throws IOException {\n+        InetAddress iaddr = InetAddress.getLoopbackAddress();\n+        return ServerSocketChannel.open().bind(null);\n+    }\n+\n+    private ServerSocketChannel getUnixServerSocketChannel() throws IOException {\n+        int next = count.incrementAndGet();\n+        socket = Paths.get(tempDir, Integer.toString(next));\n+        UnixDomainSocketAddress addr = UnixDomainSocketAddress.of(socket);\n+        return ServerSocketChannel.open(StandardProtocolFamily.UNIX).bind(addr);\n+    }\n+\n+    @Setup(Level.Trial)\n+    public void beforeRun() throws IOException {\n+        ssc = getServerSocketChannel();\n+    }\n+\n+    @TearDown(Level.Trial)\n+    public void afterRun() throws IOException, InterruptedException {\n+        ssc.close();\n+        if (family.equals(\"unix\")) {\n+            Files.delete(socket);\n+            Files.delete(Path.of(tempDir));\n+        }\n+    }\n+\n+    @Benchmark\n+    @Measurement(iterations = 5, batchSize=200)\n+    public void test() throws IOException {\n+        s1 = SocketChannel.open(ssc.getLocalAddress());\n+        s2 = ssc.accept();\n+        s1.close();\n+        s2.close();\n+    }\n+\n+    public static void main(String[] args) throws RunnerException {\n+        Options opt = new OptionsBuilder()\n+                .include(org.openjdk.bench.java.net.SocketChannelConnectionSetup.class.getSimpleName())\n+                .warmupForks(1)\n+                .forks(2)\n+                .build();\n+\n+        new Runner(opt).run();\n+\n+        opt = new OptionsBuilder()\n+                .include(org.openjdk.bench.java.net.SocketChannelConnectionSetup.class.getSimpleName())\n+                .jvmArgsPrepend(\"-Djdk.net.useFastTcpLoopback=true\")\n+                .warmupForks(1)\n+                .forks(2)\n+                .build();\n+\n+        new Runner(opt).run();\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/net\/SocketChannelConnectionSetup.java","additions":132,"deletions":0,"binary":false,"changes":132,"status":"added"},{"patch":"@@ -0,0 +1,124 @@\n+\/*\n+ * Copyright (c) 2020 Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.net;\n+\n+import java.io.IOException;\n+import java.net.StandardProtocolFamily;\n+import java.net.UnixDomainSocketAddress;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.ClosedChannelException;\n+import java.nio.channels.ServerSocketChannel;\n+import java.nio.channels.SocketChannel;\n+import java.nio.file.*;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import org.openjdk.jmh.annotations.*;\n+\n+\/**\n+ * Tests the overheads of I\/O API.\n+ * This test is known to depend heavily on network conditions and paltform.\n+ *\/\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Thread)\n+public class UnixSocketChannelReadWrite {\n+\n+    private ServerSocketChannel ssc;\n+    private SocketChannel s1, s2;\n+    private ReadThread rt;\n+    private ByteBuffer bb = ByteBuffer.allocate(1);\n+\n+    private static volatile String tempDir;\n+    private static final AtomicInteger count = new AtomicInteger(0);\n+    private volatile Path socket;\n+\n+    static {\n+        try {\n+            Path p = Files.createTempDirectory(\"readWriteTest\");\n+            tempDir = p.toString();\n+        } catch (IOException e) {\n+            tempDir = null;\n+        }\n+    }\n+\n+    private ServerSocketChannel getServerSocketChannel() throws IOException {\n+        int next = count.incrementAndGet();\n+        socket = Paths.get(tempDir, Integer.toString(next));\n+        UnixDomainSocketAddress addr = UnixDomainSocketAddress.of(socket);\n+        ServerSocketChannel c = ServerSocketChannel.open(StandardProtocolFamily.UNIX);\n+        c.bind(addr);\n+        return c;\n+    }\n+\n+    @Setup(Level.Trial)\n+    public void beforeRun() throws IOException {\n+        ssc = getServerSocketChannel();\n+        s1 = SocketChannel.open(ssc.getLocalAddress());\n+        s2 = ssc.accept();\n+\n+        rt = new ReadThread(s2);\n+        rt.start();\n+\n+        bb.put((byte) 47);\n+        bb.flip();\n+    }\n+\n+    @TearDown(Level.Trial)\n+    public void afterRun() throws IOException, InterruptedException {\n+        s1.close();\n+        s2.close();\n+        ssc.close();\n+        Files.delete(socket);\n+        Files.delete(Path.of(tempDir));\n+        rt.join();\n+    }\n+\n+    @Benchmark\n+    public void test() throws IOException {\n+        s1.write(bb);\n+        bb.flip();\n+    }\n+\n+    static class ReadThread extends Thread {\n+        private SocketChannel sc;\n+\n+        public ReadThread(SocketChannel s2) {\n+            this.sc = s2;\n+        }\n+\n+        public void run() {\n+            try {\n+                ByteBuffer bb = ByteBuffer.allocate(1);\n+                while (sc.read(bb) > 0) {\n+                    bb.flip();\n+                }\n+            } catch (ClosedChannelException ex) {\n+                \/\/ shutdown time\n+            } catch (IOException e) {\n+                e.printStackTrace();\n+            }\n+        }\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/net\/UnixSocketChannelReadWrite.java","additions":124,"deletions":0,"binary":false,"changes":124,"status":"added"}]}