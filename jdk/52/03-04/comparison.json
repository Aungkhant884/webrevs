{"files":[{"patch":"@@ -30,1 +30,0 @@\n-import java.net.InetAddress;\n@@ -34,1 +33,0 @@\n-import java.net.ServerSocket;\n@@ -37,1 +35,0 @@\n-import java.net.SocketTimeoutException;\n@@ -39,7 +36,0 @@\n-import java.nio.channels.AlreadyBoundException;\n-import java.nio.channels.AsynchronousCloseException;\n-import java.nio.channels.ClosedChannelException;\n-import java.nio.channels.IllegalBlockingModeException;\n-import java.nio.channels.NotYetBoundException;\n-import java.nio.channels.SelectionKey;\n-import java.nio.channels.ServerSocketChannel;\n@@ -50,1 +40,0 @@\n-import java.util.Objects;\n@@ -52,1 +41,0 @@\n-import java.util.concurrent.locks.ReentrantLock;\n@@ -95,0 +83,1 @@\n+    @Override\n@@ -99,0 +88,18 @@\n+    @Override\n+    protected SocketAddress getRevealedLocalAddress(SocketAddress addr) {\n+        return Net.getRevealedLocalAddress((InetSocketAddress)addr);\n+    }\n+\n+    @Override\n+    protected String getRevealedLocalAddressAsString(SocketAddress addr) {\n+        return Net.getRevealedLocalAddressAsString((InetSocketAddress)addr);\n+    }\n+\n+    \/**\n+     * Returns the local address, or null if not bound\n+     *\/\n+    @Override\n+    InetSocketAddress localAddress() {\n+        return (InetSocketAddress)super.localAddress();\n+    }\n+\n@@ -156,0 +163,1 @@\n+    @Override\n@@ -165,15 +173,1 @@\n-    protected SocketAddress getRevealedLocalAddress(SocketAddress addr) {\n-        return Net.getRevealedLocalAddress((InetSocketAddress)addr);\n-    }\n-\n-    protected String getRevealedLocalAddressAsString(SocketAddress addr) {\n-        return Net.getRevealedLocalAddressAsString((InetSocketAddress)addr);\n-    }\n-\n-    \/**\n-     * Returns the local address, or null if not bound\n-     *\/\n-    InetSocketAddress localAddress() {\n-        return (InetSocketAddress)super.localAddress();\n-    }\n-\n+    @Override\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/InetServerSocketChannelImpl.java","additions":21,"deletions":27,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-import java.net.Socket;\n@@ -36,1 +35,0 @@\n-import java.net.SocketException;\n@@ -38,1 +36,0 @@\n-import java.net.SocketTimeoutException;\n@@ -42,10 +39,0 @@\n-import java.nio.channels.AlreadyBoundException;\n-import java.nio.channels.AlreadyConnectedException;\n-import java.nio.channels.AsynchronousCloseException;\n-import java.nio.channels.ClosedChannelException;\n-import java.nio.channels.ConnectionPendingException;\n-import java.nio.channels.IllegalBlockingModeException;\n-import java.nio.channels.NoConnectionPendingException;\n-import java.nio.channels.NotYetConnectedException;\n-import java.nio.channels.SelectionKey;\n-import java.nio.channels.SocketChannel;\n@@ -55,1 +42,0 @@\n-import java.util.Objects;\n@@ -57,3 +43,0 @@\n-import java.util.concurrent.locks.ReentrantLock;\n-\n-import sun.net.ConnectionResetException;\n@@ -62,1 +45,0 @@\n-import sun.net.util.SocketExceptions;\n@@ -115,13 +97,0 @@\n-    \/**\n-     * Returns the local address, or null if not bound\n-     *\/\n-    InetSocketAddress localAddress() {\n-        return (InetSocketAddress)super.localAddress();\n-    }\n-\n-    \/**\n-     * Returns the remote address, or null if not connected\n-     *\/\n-    InetSocketAddress remoteAddress() {\n-        return (InetSocketAddress)super.remoteAddress();\n-    }\n@@ -134,0 +103,15 @@\n+    @Override\n+    <T> void implSetOption(SocketOption<T> name, T value) throws IOException {\n+        FileDescriptor fd = getFD();\n+\n+        if (name == StandardSocketOptions.IP_TOS) {\n+            ProtocolFamily family = Net.isIPv6Available() ?\n+                StandardProtocolFamily.INET6 : StandardProtocolFamily.INET;\n+            Net.setSocketOption(fd, family, name, value);\n+        } else if (name == StandardSocketOptions.SO_REUSEADDR && Net.useExclusiveBind()) {\n+            \/\/ SO_REUSEADDR emulated when using exclusive bind\n+            isReuseAddress = (Boolean)value;\n+        } else {\n+            Net.setSocketOption(fd, name, value);\n+        }\n+    }\n@@ -154,16 +138,0 @@\n-    @Override\n-    <T> void implSetOption(SocketOption<T> name, T value) throws IOException {\n-        FileDescriptor fd = getFD();\n-\n-        if (name == StandardSocketOptions.IP_TOS) {\n-            ProtocolFamily family = Net.isIPv6Available() ?\n-                StandardProtocolFamily.INET6 : StandardProtocolFamily.INET;\n-            Net.setSocketOption(fd, family, name, value);\n-        } else if (name == StandardSocketOptions.SO_REUSEADDR && Net.useExclusiveBind()) {\n-            \/\/ SO_REUSEADDR emulated when using exclusive bind\n-            isReuseAddress = (Boolean)value;\n-        } else {\n-            Net.setSocketOption(fd, name, value);\n-        }\n-    }\n-\n@@ -197,0 +165,43 @@\n+    \/**\n+     * Read\/write need to be overridden for JFR\n+     *\/\n+    @Override\n+    public int read(ByteBuffer buf) throws IOException {\n+        return super.read(buf);\n+    }\n+\n+    @Override\n+    public long read(ByteBuffer[] dsts, int offset, int length)\n+        throws IOException\n+    {\n+        return super.read(dsts, offset, length);\n+    }\n+\n+    @Override\n+    public int write(ByteBuffer buf) throws IOException {\n+        return super.write(buf);\n+    }\n+\n+    @Override\n+    public long write(ByteBuffer[] srcs, int offset, int length)\n+        throws IOException\n+    {\n+        return super.write(srcs, offset, length);\n+    }\n+\n+    \/**\n+     * Returns the local address, or null if not bound\n+     *\/\n+    @Override\n+    InetSocketAddress localAddress() {\n+        return (InetSocketAddress)super.localAddress();\n+    }\n+\n+    \/**\n+     * Returns the remote address, or null if not connected\n+     *\/\n+    @Override\n+    InetSocketAddress remoteAddress() {\n+        return (InetSocketAddress)super.remoteAddress();\n+    }\n+\n@@ -215,1 +226,0 @@\n-\n@@ -246,27 +256,0 @@\n-    \/**\n-     * Read\/write need to be overridden for JFR\n-     *\/\n-    @Override\n-    public int read(ByteBuffer buf) throws IOException {\n-        return super.read(buf);\n-    }\n-\n-    @Override\n-    public int write(ByteBuffer buf) throws IOException {\n-        return super.write(buf);\n-    }\n-\n-    @Override\n-    public long write(ByteBuffer[] srcs, int offset, int length)\n-        throws IOException\n-    {\n-        return super.write(srcs, offset, length);\n-    }\n-\n-    @Override\n-    public long read(ByteBuffer[] dsts, int offset, int length)\n-        throws IOException\n-    {\n-        return super.read(dsts, offset, length);\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/InetSocketChannelImpl.java","additions":58,"deletions":75,"binary":false,"changes":133,"status":"modified"},{"patch":"@@ -60,5 +60,0 @@\n-    static {\n-        \/\/ Load all required native libs\n-        UnixDomainNet.init();\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/Net.java","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -85,2 +85,2 @@\n-        } else if (family == StandardProtocolFamily.UNIX && UnixDomainNet.isSupported()) {\n-            return new UnixDomainSocketChannelImpl(this, UnixDomainNet.socket(), false);\n+        } else if (family == StandardProtocolFamily.UNIX && UnixDomainSockets.isSupported()) {\n+            return new UnixDomainSocketChannelImpl(this, UnixDomainSockets.socket(), false);\n@@ -98,1 +98,1 @@\n-        } else if (family == StandardProtocolFamily.UNIX && UnixDomainNet.isSupported()) {\n+        } else if (family == StandardProtocolFamily.UNIX && UnixDomainSockets.isSupported()) {\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/SelectorProviderImpl.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import java.net.InetSocketAddress;\n@@ -35,1 +34,0 @@\n-import java.net.StandardSocketOptions;\n@@ -45,2 +43,0 @@\n-import java.util.Collections;\n-import java.util.HashSet;\n@@ -48,1 +44,0 @@\n-import java.util.Set;\n@@ -51,3 +46,0 @@\n-import sun.net.NetHooks;\n-import sun.net.ext.ExtendedSocketOptions;\n-\n@@ -140,3 +132,8 @@\n-    abstract <T> void implSetOption(SocketOption<T> name, T value) throws IOException;\n-\n-    abstract <T> T implGetOption(SocketOption<T> name) throws IOException;\n+    \/**\n+     * Returns the local address, or null if not bound\n+     *\/\n+    SocketAddress localAddress() {\n+        synchronized (stateLock) {\n+            return localAddress;\n+        }\n+    }\n@@ -161,0 +158,2 @@\n+    abstract <T> void implSetOption(SocketOption<T> name, T value) throws IOException;\n+\n@@ -176,0 +175,2 @@\n+    abstract <T> T implGetOption(SocketOption<T> name) throws IOException;\n+\n@@ -227,3 +228,0 @@\n-    protected abstract int implAccept(FileDescriptor fd, FileDescriptor newfd, SocketAddress[] sa)\n-        throws IOException;\n-\n@@ -263,0 +261,4 @@\n+    protected abstract int implAccept(FileDescriptor fd, FileDescriptor newfd, SocketAddress[] sa)\n+        throws IOException;\n+\n+\n@@ -314,4 +316,1 @@\n-    abstract SocketChannel implFinishAccept(FileDescriptor newfd, SocketAddress isa)\n-        throws IOException;\n-\n-    protected SocketChannel finishAccept(FileDescriptor newfd, SocketAddress sa)\n+    private SocketChannel finishAccept(FileDescriptor newfd, SocketAddress sa)\n@@ -330,0 +329,3 @@\n+    abstract SocketChannel implFinishAccept(FileDescriptor newfd, SocketAddress isa)\n+        throws IOException;\n+\n@@ -469,9 +471,0 @@\n-    \/**\n-     * Returns the local address, or null if not bound\n-     *\/\n-    SocketAddress localAddress() {\n-        synchronized (stateLock) {\n-            return localAddress;\n-        }\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/ServerSocketChannelImpl.java","additions":20,"deletions":27,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -30,2 +30,0 @@\n-import java.net.InetAddress;\n-import java.net.Inet4Address;\n@@ -33,1 +31,0 @@\n-import java.net.ProtocolFamily;\n@@ -39,1 +36,0 @@\n-import java.net.StandardProtocolFamily;\n@@ -41,1 +37,0 @@\n-import java.net.UnixDomainSocketAddress;\n@@ -54,2 +49,0 @@\n-import java.util.Collections;\n-import java.util.HashSet;\n@@ -57,1 +50,0 @@\n-import java.util.Set;\n@@ -62,1 +54,0 @@\n-import sun.net.ext.ExtendedSocketOptions;\n@@ -196,4 +187,0 @@\n-    abstract SocketAddress implLocalAddress(FileDescriptor fd) throws IOException;\n-\n-    abstract SocketAddress getRevealedLocalAddress(SocketAddress address);\n-\n@@ -208,0 +195,4 @@\n+    abstract SocketAddress implLocalAddress(FileDescriptor fd) throws IOException;\n+\n+    abstract SocketAddress getRevealedLocalAddress(SocketAddress address);\n+\n@@ -216,4 +207,0 @@\n-    abstract <T> void implSetOption(SocketOption<T> name, T value) throws IOException;\n-\n-    abstract <T> T implGetOption(SocketOption<T> name) throws IOException;\n-\n@@ -221,2 +208,1 @@\n-    @SuppressWarnings(\"unchecked\")\n-    public <T> T getOption(SocketOption<T> name)\n+    public <T> SocketChannel setOption(SocketOption<T> name, T value)\n@@ -228,0 +214,2 @@\n+        if (!name.type().isInstance(value))\n+            throw new IllegalArgumentException(\"Invalid value '\" + value + \"'\");\n@@ -231,1 +219,2 @@\n-            return implGetOption(name);\n+            implSetOption(name, value);\n+            return this;\n@@ -235,0 +224,2 @@\n+    abstract <T> void implSetOption(SocketOption<T> name, T value) throws IOException;\n+\n@@ -236,1 +227,2 @@\n-    public <T> SocketChannel setOption(SocketOption<T> name, T value)\n+    @SuppressWarnings(\"unchecked\")\n+    public <T> T getOption(SocketOption<T> name)\n@@ -242,2 +234,0 @@\n-        if (!name.type().isInstance(value))\n-            throw new IllegalArgumentException(\"Invalid value '\" + value + \"'\");\n@@ -247,2 +237,1 @@\n-            implSetOption(name, value);\n-            return this;\n+            return implGetOption(name);\n@@ -252,0 +241,2 @@\n+    abstract <T> T implGetOption(SocketOption<T> name) throws IOException;\n+\n@@ -571,2 +562,0 @@\n-    abstract SocketAddress implBind(SocketAddress local) throws IOException;\n-\n@@ -596,0 +585,2 @@\n+    abstract SocketAddress implBind(SocketAddress local) throws IOException;\n+\n@@ -672,2 +663,0 @@\n-    abstract int implConnect(FileDescriptor fd,SocketAddress sa) throws IOException;\n-\n@@ -715,0 +704,2 @@\n+    abstract int implConnect(FileDescriptor fd,SocketAddress sa) throws IOException;\n+\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/SocketChannelImpl.java","additions":20,"deletions":29,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import java.io.File;\n@@ -32,2 +31,0 @@\n-import java.net.NetPermission;\n-import java.net.ProtocolFamily;\n@@ -37,2 +34,0 @@\n-import java.net.SocketTimeoutException;\n-import java.net.StandardProtocolFamily;\n@@ -41,7 +36,0 @@\n-import java.nio.channels.AlreadyBoundException;\n-import java.nio.channels.AsynchronousCloseException;\n-import java.nio.channels.ClosedChannelException;\n-import java.nio.channels.IllegalBlockingModeException;\n-import java.nio.channels.NotYetBoundException;\n-import java.nio.channels.SelectionKey;\n-import java.nio.channels.ServerSocketChannel;\n@@ -50,3 +38,0 @@\n-import java.nio.file.InvalidPathException;\n-import java.nio.file.Path;\n-import java.security.AccessController;\n@@ -54,1 +39,0 @@\n-import java.security.PrivilegedAction;\n@@ -58,1 +42,0 @@\n-import java.util.Objects;\n@@ -61,5 +44,0 @@\n-import java.util.concurrent.atomic.AtomicInteger;\n-import java.util.concurrent.locks.ReentrantLock;\n-\n-import sun.net.NetHooks;\n-import sun.net.ext.ExtendedSocketOptions;\n@@ -75,1 +53,1 @@\n-        super(sp, UnixDomainNet.socket(), false);\n+        super(sp, UnixDomainSockets.socket(), false);\n@@ -84,0 +62,1 @@\n+    @Override\n@@ -85,1 +64,11 @@\n-        return UnixDomainNet.localAddress(fd);\n+        return UnixDomainSockets.localAddress(fd);\n+    }\n+\n+    @Override\n+    SocketAddress getRevealedLocalAddress(SocketAddress addr) {\n+        return UnixDomainSockets.getRevealedLocalAddress((UnixDomainSocketAddress)addr);\n+    }\n+\n+    @Override\n+    String getRevealedLocalAddressAsString(SocketAddress addr) {\n+        return UnixDomainSockets.getRevealedLocalAddressAsString((UnixDomainSocketAddress)addr);\n@@ -123,1 +112,1 @@\n-        UnixDomainNet.checkCapability();\n+        UnixDomainSockets.checkCapability();\n@@ -132,1 +121,1 @@\n-                usa = UnixDomainNet.checkAddress(local);\n+                usa = UnixDomainSockets.checkAddress(local);\n@@ -135,1 +124,1 @@\n-                UnixDomainNet.bind(getFD(), usa.getPath());\n+                UnixDomainSockets.bind(getFD(), usa.getPath());\n@@ -147,1 +136,1 @@\n-        return UnixDomainNet.localAddress(getFD());\n+        return UnixDomainSockets.localAddress(getFD());\n@@ -167,1 +156,1 @@\n-        sb.append(UnixDomainNet.tempDir).append(\"\/niosocket_\").append(rnd);\n+        sb.append(UnixDomainSockets.tempDir).append(\"\/niosocket_\").append(rnd);\n@@ -175,1 +164,1 @@\n-        UnixDomainNet.checkCapability();\n+        UnixDomainSockets.checkCapability();\n@@ -177,1 +166,1 @@\n-        int n = UnixDomainNet.accept(fd, newfd, addrArray);\n+        int n = UnixDomainSockets.accept(fd, newfd, addrArray);\n@@ -185,9 +174,0 @@\n-    String getRevealedLocalAddressAsString(SocketAddress addr) {\n-        return UnixDomainNet.getRevealedLocalAddressAsString((UnixDomainSocketAddress)addr);\n-    }\n-\n-    @Override\n-    SocketAddress getRevealedLocalAddress(SocketAddress addr) {\n-        return UnixDomainNet.getRevealedLocalAddress((UnixDomainSocketAddress)addr);\n-    }\n-\n@@ -201,0 +181,1 @@\n+    @Override\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/UnixDomainServerSocketChannelImpl.java","additions":21,"deletions":40,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -30,3 +30,0 @@\n-import java.io.UncheckedIOException;\n-import java.net.NetPermission;\n-import java.net.ProtocolFamily;\n@@ -35,1 +32,0 @@\n-import java.net.SocketException;\n@@ -37,2 +33,0 @@\n-import java.net.SocketTimeoutException;\n-import java.net.StandardProtocolFamily;\n@@ -42,10 +36,0 @@\n-import java.nio.channels.AlreadyBoundException;\n-import java.nio.channels.AlreadyConnectedException;\n-import java.nio.channels.AsynchronousCloseException;\n-import java.nio.channels.ClosedChannelException;\n-import java.nio.channels.ConnectionPendingException;\n-import java.nio.channels.IllegalBlockingModeException;\n-import java.nio.channels.NoConnectionPendingException;\n-import java.nio.channels.NotYetConnectedException;\n-import java.nio.channels.SelectionKey;\n-import java.nio.channels.SocketChannel;\n@@ -53,1 +37,0 @@\n-import java.nio.file.InvalidPathException;\n@@ -55,2 +38,0 @@\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n@@ -61,4 +42,0 @@\n-import java.util.concurrent.locks.ReentrantLock;\n-\n-import sun.net.ConnectionResetException;\n-import sun.net.NetHooks;\n@@ -66,1 +43,0 @@\n-import sun.net.util.SocketExceptions;\n@@ -90,1 +66,1 @@\n-        return UnixDomainNet.localAddress(fd);\n+        return UnixDomainSockets.localAddress(fd);\n@@ -96,1 +72,1 @@\n-        return UnixDomainNet.getRevealedLocalAddress(uaddr);\n+        return UnixDomainSockets.getRevealedLocalAddress(uaddr);\n@@ -99,1 +75,0 @@\n-    @SuppressWarnings(\"unchecked\")\n@@ -101,2 +76,2 @@\n-    <T> T implGetOption(SocketOption<T> name) throws IOException {\n-        return (T) Net.getSocketOption(getFD(), name);\n+    <T> void implSetOption(SocketOption<T> name, T value) throws IOException {\n+        Net.setSocketOption(getFD(), name, value);\n@@ -105,0 +80,1 @@\n+    @SuppressWarnings(\"unchecked\")\n@@ -106,2 +82,2 @@\n-    <T> void implSetOption(SocketOption<T> name, T value) throws IOException {\n-        Net.setSocketOption(getFD(), name, value);\n+    <T> T implGetOption(SocketOption<T> name) throws IOException {\n+        return (T) Net.getSocketOption(getFD(), name);\n@@ -128,13 +104,0 @@\n-    @Override\n-    SocketAddress implBind(SocketAddress local) throws IOException {\n-        UnixDomainNet.checkCapability();\n-        UnixDomainSocketAddress usa = UnixDomainNet.checkAddress(local);\n-        Path path = usa == null ? null : usa.getPath();\n-        UnixDomainNet.bind(getFD(), path);\n-        if (usa == null || path.toString().equals(\"\")) {\n-            return UnixDomainNet.UNNAMED;\n-        } else {\n-            return UnixDomainNet.localAddress(getFD());\n-        }\n-    }\n-\n@@ -146,22 +109,0 @@\n-    \/**\n-     * Checks the permissions required for connect\n-     *\/\n-    @Override\n-    SocketAddress checkRemote(SocketAddress sa) throws IOException {\n-        Objects.requireNonNull(sa);\n-        UnixDomainNet.checkCapability();\n-        UnixDomainSocketAddress usa = UnixDomainNet.checkAddress(sa);\n-        return usa;\n-    }\n-\n-    @Override\n-    int implConnect(FileDescriptor fd, SocketAddress sa) throws IOException {\n-        UnixDomainSocketAddress usa = (UnixDomainSocketAddress)sa;\n-        return UnixDomainNet.connect(fd, usa.getPath());\n-    }\n-\n-    String getRevealedLocalAddressAsString(SocketAddress sa) {\n-        UnixDomainSocketAddress usa = (UnixDomainSocketAddress)sa;\n-        return UnixDomainNet.getRevealedLocalAddressAsString(usa);\n-    }\n-\n@@ -176,0 +117,7 @@\n+    @Override\n+    public long read(ByteBuffer[] dsts, int offset, int length)\n+        throws IOException\n+    {\n+        return super.read(dsts, offset, length);\n+    }\n+\n@@ -189,4 +137,32 @@\n-    public long read(ByteBuffer[] dsts, int offset, int length)\n-        throws IOException\n-    {\n-        return super.read(dsts, offset, length);\n+    SocketAddress implBind(SocketAddress local) throws IOException {\n+        UnixDomainSockets.checkCapability();\n+        UnixDomainSocketAddress usa = UnixDomainSockets.checkAddress(local);\n+        Path path = usa == null ? null : usa.getPath();\n+        UnixDomainSockets.bind(getFD(), path);\n+        if (usa == null || path.toString().equals(\"\")) {\n+            return UnixDomainSockets.UNNAMED;\n+        } else {\n+            return UnixDomainSockets.localAddress(getFD());\n+        }\n+    }\n+\n+    \/**\n+     * Checks the permissions required for connect\n+     *\/\n+    @Override\n+    SocketAddress checkRemote(SocketAddress sa) throws IOException {\n+        Objects.requireNonNull(sa);\n+        UnixDomainSockets.checkCapability();\n+        UnixDomainSocketAddress usa = UnixDomainSockets.checkAddress(sa);\n+        return usa;\n+    }\n+\n+    @Override\n+    int implConnect(FileDescriptor fd, SocketAddress sa) throws IOException {\n+        UnixDomainSocketAddress usa = (UnixDomainSocketAddress)sa;\n+        return UnixDomainSockets.connect(fd, usa.getPath());\n+    }\n+\n+    String getRevealedLocalAddressAsString(SocketAddress sa) {\n+        UnixDomainSocketAddress usa = (UnixDomainSocketAddress)sa;\n+        return UnixDomainSockets.getRevealedLocalAddressAsString(usa);\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/UnixDomainSocketChannelImpl.java","additions":46,"deletions":70,"binary":false,"changes":116,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-import java.nio.file.InvalidPathException;\n@@ -42,1 +41,1 @@\n-class UnixDomainNet {\n+class UnixDomainSockets {\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/UnixDomainSockets.java","additions":1,"deletions":2,"binary":false,"changes":3,"previous_filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/UnixDomainNet.java","status":"renamed"},{"patch":"@@ -30,1 +30,0 @@\n-#include <stddef.h>\n@@ -36,1 +35,0 @@\n-#include \"java_props.h\"\n@@ -40,1 +38,0 @@\n-#include \"java_net_InetAddress.h\"\n@@ -434,1 +431,1 @@\n-        if (errno == ECONNRESET && sa.sa.sa_family != AF_UNIX) {\n+        if (errno == ECONNRESET) {\n","filename":"src\/java.base\/unix\/native\/libnio\/ch\/Net.c","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,232 @@\n+\/*\n+ * Copyright (c) 2001, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <poll.h>\n+#include <sys\/types.h>\n+#include <sys\/socket.h>\n+#include <string.h>\n+#include <stddef.h>\n+#include <netinet\/in.h>\n+#include <netinet\/tcp.h>\n+#include <limits.h>\n+\n+#include \"jni.h\"\n+#include \"java_props.h\"\n+#include \"jni_util.h\"\n+#include \"jvm.h\"\n+#include \"jlong.h\"\n+#include \"sun_nio_ch_Net.h\"\n+#include \"net_util.h\"\n+#include \"net_util_md.h\"\n+#include \"nio_util.h\"\n+#include \"nio.h\"\n+\n+#ifdef _AIX\n+#include <stdlib.h>\n+#include <sys\/utsname.h>\n+#endif\n+\n+\n+\/* Subtle platform differences in how unnamed sockets (empty path)\n+ * are returned from getsockname()\n+ *\/\n+#ifdef MACOSX\n+  #define ZERO_PATHLEN(len) (JNI_FALSE)\n+#else\n+  #define ZERO_PATHLEN(len) (len == offsetof(struct sockaddr_un, sun_path))\n+#endif\n+\n+JNIEXPORT jbyteArray JNICALL\n+NET_SockaddrToUnixAddressBytes(JNIEnv *env, struct sockaddr_un *sa, socklen_t len) {\n+\n+    if (sa->sun_family == AF_UNIX) {\n+        int namelen;\n+        if (ZERO_PATHLEN(len)) {\n+            namelen = 0;\n+        } else {\n+            namelen = strlen(sa->sun_path);\n+        }\n+        jbyteArray name = (*env)->NewByteArray(env, namelen);\n+        if (namelen != 0) {\n+            (*env)->SetByteArrayRegion(env, name, 0, namelen, (jbyte*)sa->sun_path);\n+        }\n+        return name;\n+    }\n+    return NULL;\n+}\n+\n+JNIEXPORT jint JNICALL\n+NET_UnixSocketAddressToSockaddr(JNIEnv *env, jbyteArray path, struct sockaddr_un *sa, int *len)\n+{\n+    memset(sa, 0, sizeof(struct sockaddr_un));\n+    sa->sun_family = AF_UNIX;\n+    int ret;\n+    const char* pname = (const char *)(*env)->GetByteArrayElements(env, path, NULL);\n+    size_t name_len = (*env)->GetArrayLength(env, path);\n+    if (name_len > MAX_UNIX_DOMAIN_PATH_LEN) {\n+        JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\", \"Unix domain path too long\");\n+        ret = 1;\n+        goto finish;\n+    }\n+    memcpy(sa->sun_path, pname, name_len);\n+    *len = (int)(offsetof(struct sockaddr_un, sun_path) + name_len + 1);\n+    ret = 0;\n+  finish:\n+    (*env)->ReleaseByteArrayElements(env, path, (jbyte *)pname, 0);\n+    return ret;\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_sun_nio_ch_UnixDomainSockets_maxNameLen0(JNIEnv *env, jclass cl)\n+{\n+    return MAX_UNIX_DOMAIN_PATH_LEN;\n+}\n+\n+JNIEXPORT jboolean JNICALL\n+Java_sun_nio_ch_UnixDomainSockets_socketSupported(JNIEnv *env, jclass cl)\n+{\n+    return JNI_TRUE;\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_sun_nio_ch_UnixDomainSockets_socket0(JNIEnv *env, jclass cl)\n+{\n+    int fd = socket(PF_UNIX, SOCK_STREAM, 0);\n+    if (fd < 0) {\n+        return handleSocketError(env, errno);\n+    }\n+    return fd;\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_sun_nio_ch_UnixDomainSockets_bind0(JNIEnv *env, jclass clazz, jobject fdo, jbyteArray path)\n+{\n+    struct sockaddr_un sa;\n+    int sa_len = 0;\n+    int rv = 0;\n+\n+    if (path == NULL)\n+        return; \/* Rely on implicit bind: Unix *\/\n+\n+    if (NET_UnixSocketAddressToSockaddr(env, path, &sa, &sa_len) != 0)\n+        return;\n+\n+    int fd = fdval(env, fdo);\n+\n+    rv = bind(fdval(env, fdo), (struct sockaddr *)&sa, sa_len);\n+    if (rv != 0) {\n+        handleSocketError(env, errno);\n+    }\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_sun_nio_ch_UnixDomainSockets_connect0(JNIEnv *env, jclass clazz, jobject fdo, jbyteArray path)\n+{\n+    struct sockaddr_un sa;\n+    int sa_len = 0;\n+    int rv;\n+\n+    if (NET_UnixSocketAddressToSockaddr(env, path, &sa, &sa_len) != 0) {\n+        return IOS_THROWN;\n+    }\n+\n+    rv = connect(fdval(env, fdo), (struct sockaddr *)&sa, sa_len);\n+    if (rv != 0) {\n+        if (errno == EINPROGRESS) {\n+            return IOS_UNAVAILABLE;\n+        } else if (errno == EINTR) {\n+            return IOS_INTERRUPTED;\n+        }\n+        return handleSocketError(env, errno);\n+    }\n+    return 1;\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_sun_nio_ch_UnixDomainSockets_accept0(JNIEnv *env, jclass clazz, jobject fdo, jobject newfdo,\n+                           jobjectArray usaa)\n+{\n+    jint fd = fdval(env, fdo);\n+    jint newfd;\n+    struct sockaddr_un sa;\n+    socklen_t sa_len = sizeof(struct sockaddr_un);\n+    jstring usa;\n+\n+    \/* accept connection but ignore ECONNABORTED *\/\n+    for (;;) {\n+        newfd = accept(fd, (struct sockaddr *)&sa, &sa_len);\n+        if (newfd >= 0) {\n+            break;\n+        }\n+        if (errno != ECONNABORTED) {\n+            break;\n+        }\n+        \/* ECONNABORTED => restart accept *\/\n+    }\n+\n+    if (newfd < 0) {\n+        if (errno == EAGAIN || errno == EWOULDBLOCK)\n+            return IOS_UNAVAILABLE;\n+        if (errno == EINTR)\n+            return IOS_INTERRUPTED;\n+        JNU_ThrowIOExceptionWithLastError(env, \"Accept failed\");\n+        return IOS_THROWN;\n+    }\n+\n+    setfdval(env, newfdo, newfd);\n+\n+    usa = NET_SockaddrToUnixAddressBytes(env, &sa, sa_len);\n+    CHECK_NULL_RETURN(usa, IOS_THROWN);\n+\n+    (*env)->SetObjectArrayElement(env, usaa, 0, usa);\n+\n+    return 1;\n+}\n+\n+JNIEXPORT jbyteArray JNICALL\n+Java_sun_nio_ch_UnixDomainSockets_localAddress0(JNIEnv *env, jclass clazz, jobject fdo)\n+{\n+    SOCKETADDRESS sa;\n+    socklen_t sa_len = sizeof(SOCKETADDRESS);\n+    int port;\n+    if (getsockname(fdval(env, fdo), &sa.sa, &sa_len) < 0) {\n+        handleSocketError(env, errno);\n+        return NULL;\n+    }\n+    return NET_SockaddrToUnixAddressBytes(env, &sa.saun, sa_len);\n+}\n+\n+JNIEXPORT jbyteArray JNICALL\n+Java_sun_nio_ch_UnixDomainSockets_remoteAddress0(JNIEnv *env, jclass clazz, jobject fdo)\n+{\n+    SOCKETADDRESS sa;\n+    socklen_t sa_len = sizeof(sa);\n+\n+    if (getpeername(fdval(env, fdo), &sa.sa, &sa_len) < 0) {\n+        handleSocketError(env, errno);\n+        return NULL;\n+    }\n+    return NET_SockaddrToUnixAddressBytes(env, &sa.saun, sa_len);\n+}\n","filename":"src\/java.base\/unix\/native\/libnio\/ch\/UnixDomainSockets.c","additions":232,"deletions":0,"binary":false,"changes":232,"status":"added"},{"patch":"@@ -1,232 +0,0 @@\n-\/*\n- * Copyright (c) 2001, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include <poll.h>\n-#include <sys\/types.h>\n-#include <sys\/socket.h>\n-#include <string.h>\n-#include <stddef.h>\n-#include <netinet\/in.h>\n-#include <netinet\/tcp.h>\n-#include <limits.h>\n-\n-#include \"jni.h\"\n-#include \"java_props.h\"\n-#include \"jni_util.h\"\n-#include \"jvm.h\"\n-#include \"jlong.h\"\n-#include \"sun_nio_ch_Net.h\"\n-#include \"net_util.h\"\n-#include \"net_util_md.h\"\n-#include \"nio_util.h\"\n-#include \"nio.h\"\n-\n-#ifdef _AIX\n-#include <stdlib.h>\n-#include <sys\/utsname.h>\n-#endif\n-\n-\n-\/* Subtle platform differences in how unnamed sockets (empty path)\n- * are returned from getsockname()\n- *\/\n-#ifdef MACOSX\n-  #define ZERO_PATHLEN(len) (JNI_FALSE)\n-#else\n-  #define ZERO_PATHLEN(len) (len == offsetof(struct sockaddr_un, sun_path))\n-#endif\n-\n-JNIEXPORT jbyteArray JNICALL\n-NET_SockaddrToUnixAddressBytes(JNIEnv *env, struct sockaddr_un *sa, socklen_t len) {\n-\n-    if (sa->sun_family == AF_UNIX) {\n-        int namelen;\n-        if (ZERO_PATHLEN(len)) {\n-            namelen = 0;\n-        } else {\n-            namelen = strlen(sa->sun_path);\n-        }\n-        jbyteArray name = (*env)->NewByteArray(env, namelen);\n-        if (namelen != 0) {\n-            (*env)->SetByteArrayRegion(env, name, 0, namelen, (jbyte*)sa->sun_path);\n-        }\n-        return name;\n-    }\n-    return NULL;\n-}\n-\n-JNIEXPORT jint JNICALL\n-NET_UnixSocketAddressToSockaddr(JNIEnv *env, jbyteArray path, struct sockaddr_un *sa, int *len)\n-{\n-    memset(sa, 0, sizeof(struct sockaddr_un));\n-    sa->sun_family = AF_UNIX;\n-    int ret;\n-    const char* pname = (const char *)(*env)->GetByteArrayElements(env, path, NULL);\n-    size_t name_len = (*env)->GetArrayLength(env, path);\n-    if (name_len > MAX_UNIX_DOMAIN_PATH_LEN) {\n-        JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\", \"Unix domain path too long\");\n-        ret = 1;\n-        goto finish;\n-    }\n-    memcpy(sa->sun_path, pname, name_len);\n-    *len = (int)(offsetof(struct sockaddr_un, sun_path) + name_len + 1);\n-    ret = 0;\n-  finish:\n-    (*env)->ReleaseByteArrayElements(env, path, (jbyte *)pname, 0);\n-    return ret;\n-}\n-\n-JNIEXPORT jint JNICALL\n-Java_sun_nio_ch_UnixDomainNet_maxNameLen0(JNIEnv *env, jclass cl)\n-{\n-    return MAX_UNIX_DOMAIN_PATH_LEN;\n-}\n-\n-JNIEXPORT jboolean JNICALL\n-Java_sun_nio_ch_UnixDomainNet_socketSupported(JNIEnv *env, jclass cl)\n-{\n-    return JNI_TRUE;\n-}\n-\n-JNIEXPORT jint JNICALL\n-Java_sun_nio_ch_UnixDomainNet_socket0(JNIEnv *env, jclass cl)\n-{\n-    int fd = socket(PF_UNIX, SOCK_STREAM, 0);\n-    if (fd < 0) {\n-        return handleSocketError(env, errno);\n-    }\n-    return fd;\n-}\n-\n-JNIEXPORT void JNICALL\n-Java_sun_nio_ch_UnixDomainNet_bind0(JNIEnv *env, jclass clazz, jobject fdo, jbyteArray path)\n-{\n-    struct sockaddr_un sa;\n-    int sa_len = 0;\n-    int rv = 0;\n-\n-    if (path == NULL)\n-        return; \/* Rely on implicit bind: Unix *\/\n-\n-    if (NET_UnixSocketAddressToSockaddr(env, path, &sa, &sa_len) != 0)\n-        return;\n-\n-    int fd = fdval(env, fdo);\n-\n-    rv = bind(fdval(env, fdo), (struct sockaddr *)&sa, sa_len);\n-    if (rv != 0) {\n-        handleSocketError(env, errno);\n-    }\n-}\n-\n-JNIEXPORT jint JNICALL\n-Java_sun_nio_ch_UnixDomainNet_connect0(JNIEnv *env, jclass clazz, jobject fdo, jbyteArray path)\n-{\n-    struct sockaddr_un sa;\n-    int sa_len = 0;\n-    int rv;\n-\n-    if (NET_UnixSocketAddressToSockaddr(env, path, &sa, &sa_len) != 0) {\n-        return IOS_THROWN;\n-    }\n-\n-    rv = connect(fdval(env, fdo), (struct sockaddr *)&sa, sa_len);\n-    if (rv != 0) {\n-        if (errno == EINPROGRESS) {\n-            return IOS_UNAVAILABLE;\n-        } else if (errno == EINTR) {\n-            return IOS_INTERRUPTED;\n-        }\n-        return handleSocketError(env, errno);\n-    }\n-    return 1;\n-}\n-\n-JNIEXPORT jint JNICALL\n-Java_sun_nio_ch_UnixDomainNet_accept0(JNIEnv *env, jclass clazz, jobject fdo, jobject newfdo,\n-                           jobjectArray usaa)\n-{\n-    jint fd = fdval(env, fdo);\n-    jint newfd;\n-    struct sockaddr_un sa;\n-    socklen_t sa_len = sizeof(struct sockaddr_un);\n-    jstring usa;\n-\n-    \/* accept connection but ignore ECONNABORTED *\/\n-    for (;;) {\n-        newfd = accept(fd, (struct sockaddr *)&sa, &sa_len);\n-        if (newfd >= 0) {\n-            break;\n-        }\n-        if (errno != ECONNABORTED) {\n-            break;\n-        }\n-        \/* ECONNABORTED => restart accept *\/\n-    }\n-\n-    if (newfd < 0) {\n-        if (errno == EAGAIN || errno == EWOULDBLOCK)\n-            return IOS_UNAVAILABLE;\n-        if (errno == EINTR)\n-            return IOS_INTERRUPTED;\n-        JNU_ThrowIOExceptionWithLastError(env, \"Accept failed\");\n-        return IOS_THROWN;\n-    }\n-\n-    setfdval(env, newfdo, newfd);\n-\n-    usa = NET_SockaddrToUnixAddressBytes(env, &sa, sa_len);\n-    CHECK_NULL_RETURN(usa, IOS_THROWN);\n-\n-    (*env)->SetObjectArrayElement(env, usaa, 0, usa);\n-\n-    return 1;\n-}\n-\n-JNIEXPORT jbyteArray JNICALL\n-Java_sun_nio_ch_UnixDomainNet_localAddress0(JNIEnv *env, jclass clazz, jobject fdo)\n-{\n-    SOCKETADDRESS sa;\n-    socklen_t sa_len = sizeof(SOCKETADDRESS);\n-    int port;\n-    if (getsockname(fdval(env, fdo), &sa.sa, &sa_len) < 0) {\n-        handleSocketError(env, errno);\n-        return NULL;\n-    }\n-    return NET_SockaddrToUnixAddressBytes(env, &sa.saun, sa_len);\n-}\n-\n-JNIEXPORT jbyteArray JNICALL\n-Java_sun_nio_ch_UnixDomainNet_remoteAddress0(JNIEnv *env, jclass clazz, jobject fdo)\n-{\n-    SOCKETADDRESS sa;\n-    socklen_t sa_len = sizeof(sa);\n-\n-    if (getpeername(fdval(env, fdo), &sa.sa, &sa_len) < 0) {\n-        handleSocketError(env, errno);\n-        return NULL;\n-    }\n-    return NET_SockaddrToUnixAddressBytes(env, &sa.saun, sa_len);\n-}\n","filename":"src\/java.base\/unix\/native\/libnio\/ch\/UnixNet.c","additions":0,"deletions":232,"binary":false,"changes":232,"status":"deleted"},{"patch":"@@ -0,0 +1,213 @@\n+\/*\n+ * Copyright (c) 2001, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <windows.h>\n+#include <winsock2.h>\n+\n+#include \"jni.h\"\n+#include \"jni_util.h\"\n+#include \"jvm.h\"\n+#include \"jlong.h\"\n+#include \"nio.h\"\n+#include \"nio_util.h\"\n+#include \"net_util.h\"\n+\n+#include \"java_net_InetAddress.h\"\n+#include \"sun_nio_ch_Net.h\"\n+#include \"sun_nio_ch_PollArrayWrapper.h\"\n+\n+JNIEXPORT jbyteArray JNICALL\n+NET_SockaddrToUnixAddressBytes(JNIEnv *env, struct sockaddr_un *sa, socklen_t len) {\n+\n+    if (sa->sun_family == AF_UNIX) {\n+        int namelen = (int)strlen(sa->sun_path);\n+        jbyteArray name = (*env)->NewByteArray(env, namelen);\n+        if (name != NULL) {\n+            (*env)->SetByteArrayRegion(env, name, 0, namelen, (jbyte*)sa->sun_path);\n+        }\n+        return name;\n+    }\n+    return NULL;\n+}\n+\n+JNIEXPORT jint JNICALL\n+NET_UnixSocketAddressToSockaddr(JNIEnv *env, jbyteArray addr, struct sockaddr_un *sa, int *len)\n+{\n+    memset(sa, 0, sizeof(struct sockaddr_un));\n+    sa->sun_family = AF_UNIX;\n+    if (addr == 0L) {\n+        \/* Do explicit bind on Windows *\/\n+        *len = (int)(offsetof(struct sockaddr_un, sun_path));\n+        return 0;\n+    }\n+    int ret;\n+    jboolean isCopy;\n+    char *pname = (*env)->GetByteArrayElements(env, addr, &isCopy);\n+\n+    size_t name_len = (size_t)(*env)->GetArrayLength(env, addr);\n+    if (name_len > MAX_UNIX_DOMAIN_PATH_LEN) {\n+        JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\", \"Unix domain path too long\");\n+        ret=1;\n+        goto finish;\n+    }\n+    strncpy(sa->sun_path, pname, name_len);\n+    *len = (int)(offsetof(struct sockaddr_un, sun_path) + name_len);\n+    ret = 0;\n+  finish:\n+    (*env)->ReleaseByteArrayElements(env, addr, pname, JNI_ABORT);\n+    return ret;\n+}\n+\n+\n+JNIEXPORT jboolean JNICALL\n+Java_sun_nio_ch_UnixDomainSockets_socketSupported(JNIEnv *env, jclass cl)\n+{\n+    SOCKET fd = socket(PF_UNIX, SOCK_STREAM, 0);\n+    if (fd == INVALID_SOCKET) {\n+        return JNI_FALSE;\n+    }\n+    closesocket(fd);\n+    return JNI_TRUE;\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_sun_nio_ch_UnixDomainSockets_maxNameLen0(JNIEnv *env, jclass cl)\n+{\n+    return MAX_UNIX_DOMAIN_PATH_LEN - 1;\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_sun_nio_ch_UnixDomainSockets_socket0(JNIEnv *env, jclass cl)\n+{\n+    SOCKET fd = socket(PF_UNIX, SOCK_STREAM, 0);\n+    if (fd == INVALID_SOCKET) {\n+        return handleSocketError(env, WSAGetLastError());\n+    }\n+    return (int)fd;\n+}\n+\n+\/**\n+ * Windows does not support auto bind. So, the windows version of NET_UnixSocketAddressToSockaddr\n+ * looks out for a null 'uaddr' and handles it specially\n+ *\/\n+JNIEXPORT void JNICALL\n+Java_sun_nio_ch_UnixDomainSockets_bind0(JNIEnv *env, jclass clazz, jobject fdo, jbyteArray addr)\n+{\n+    struct sockaddr_un sa;\n+    int sa_len = 0;\n+    int rv = 0;\n+\n+    if (NET_UnixSocketAddressToSockaddr(env, addr, &sa, &sa_len) != 0)\n+        return;\n+\n+    int fd = fdval(env, fdo);\n+\n+    rv = bind(fdval(env, fdo), (struct sockaddr *)&sa, sa_len);\n+    if (rv != 0) {\n+        int err = WSAGetLastError();\n+        NET_ThrowNew(env, err, \"bind\");\n+    }\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_sun_nio_ch_UnixDomainSockets_connect0(JNIEnv *env, jclass clazz, jobject fdo, jbyteArray addr)\n+{\n+    struct sockaddr_un sa;\n+    int sa_len = 0;\n+    int rv;\n+\n+    if (NET_UnixSocketAddressToSockaddr(env, addr, &sa, &sa_len) != 0) {\n+        return IOS_THROWN;\n+    }\n+\n+    rv = connect(fdval(env, fdo), (const struct sockaddr *)&sa, sa_len);\n+    if (rv != 0) {\n+        int err = WSAGetLastError();\n+        if (err == WSAEINPROGRESS || err == WSAEWOULDBLOCK) {\n+            return IOS_UNAVAILABLE;\n+        }\n+        NET_ThrowNew(env, err, \"connect\");\n+        return IOS_THROWN;\n+    }\n+    return 1;\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_sun_nio_ch_UnixDomainSockets_accept0(JNIEnv *env, jclass clazz, jobject fdo, jobject newfdo,\n+                           jobjectArray usaa)\n+{\n+    jint fd = fdval(env, fdo);\n+    jint newfd;\n+    struct sockaddr_un sa;\n+    socklen_t sa_len = sizeof(sa);\n+    jobject usa;\n+\n+    memset((char *)&sa, 0, sizeof(sa));\n+    newfd = (jint) accept(fd, (struct sockaddr *)&sa, &sa_len);\n+    if (newfd == INVALID_SOCKET) {\n+        int theErr = (jint)WSAGetLastError();\n+        if (theErr == WSAEWOULDBLOCK) {\n+            return IOS_UNAVAILABLE;\n+        }\n+        JNU_ThrowIOExceptionWithLastError(env, \"Accept failed\");\n+        return IOS_THROWN;\n+    }\n+\n+    SetHandleInformation((HANDLE)(UINT_PTR)newfd, HANDLE_FLAG_INHERIT, 0);\n+    setfdval(env, newfdo, newfd);\n+\n+    usa = NET_SockaddrToUnixAddressBytes(env, &sa, sa_len);\n+    CHECK_NULL_RETURN(usa, IOS_THROWN);\n+\n+    (*env)->SetObjectArrayElement(env, usaa, 0, usa);\n+\n+    return 1;\n+}\n+\n+JNIEXPORT jbyteArray JNICALL\n+Java_sun_nio_ch_UnixDomainSockets_localAddress0(JNIEnv *env, jclass clazz, jobject fdo)\n+{\n+    struct sockaddr_un sa;\n+    int sa_len = sizeof(sa);\n+\n+    if (getsockname(fdval(env, fdo), (struct sockaddr *)&sa, &sa_len) == SOCKET_ERROR) {\n+        NET_ThrowNew(env, WSAGetLastError(), \"getsockname\");\n+        return NULL;\n+    }\n+    return NET_SockaddrToUnixAddressBytes(env, &sa, sa_len);\n+}\n+\n+JNIEXPORT jbyteArray JNICALL\n+Java_sun_nio_ch_UnixDomainSockets_remoteAddress0(JNIEnv *env, jclass clazz, jobject fdo)\n+{\n+    struct sockaddr_un sa;\n+    int sa_len = sizeof(sa);\n+\n+    if (getpeername(fdval(env, fdo), (struct sockaddr *)&sa, &sa_len) == SOCKET_ERROR) {\n+        NET_ThrowNew(env, WSAGetLastError(), \"getsockname\");\n+        return NULL;\n+    }\n+    return NET_SockaddrToUnixAddressBytes(env, &sa, sa_len);\n+}\n","filename":"src\/java.base\/windows\/native\/libnio\/ch\/UnixDomainSockets.c","additions":213,"deletions":0,"binary":false,"changes":213,"status":"added"},{"patch":"@@ -1,223 +0,0 @@\n-\/*\n- * Copyright (c) 2001, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include <windows.h>\n-#include <winsock2.h>\n-\n-#include \"jni.h\"\n-#include \"jni_util.h\"\n-#include \"jvm.h\"\n-#include \"jlong.h\"\n-#include \"nio.h\"\n-#include \"nio_util.h\"\n-#include \"net_util.h\"\n-\n-#include \"java_net_InetAddress.h\"\n-#include \"sun_nio_ch_Net.h\"\n-#include \"sun_nio_ch_PollArrayWrapper.h\"\n-\n-JNIEXPORT jbyteArray JNICALL\n-NET_SockaddrToUnixAddressBytes(JNIEnv *env, struct sockaddr_un *sa, socklen_t len) {\n-\n-    if (sa->sun_family == AF_UNIX) {\n-        int namelen = (int)strlen(sa->sun_path);\n-        jbyteArray name = (*env)->NewByteArray(env, namelen);\n-        if (name != NULL) {\n-            (*env)->SetByteArrayRegion(env, name, 0, namelen, (jbyte*)sa->sun_path);\n-        }\n-        return name;\n-    }\n-    return NULL;\n-}\n-\n-JNIEXPORT jint JNICALL\n-NET_UnixSocketAddressToSockaddr(JNIEnv *env, jbyteArray addr, struct sockaddr_un *sa, int *len)\n-{\n-    memset(sa, 0, sizeof(struct sockaddr_un));\n-    sa->sun_family = AF_UNIX;\n-    if (addr == 0L) {\n-        \/* Do explicit bind on Windows *\/\n-        *len = (int)(offsetof(struct sockaddr_un, sun_path));\n-        return 0;\n-    }\n-    int ret;\n-    jboolean isCopy;\n-    char *pname = (*env)->GetByteArrayElements(env, addr, &isCopy);\n-\n-    size_t name_len = (size_t)(*env)->GetArrayLength(env, addr);\n-    if (name_len > MAX_UNIX_DOMAIN_PATH_LEN) {\n-        JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\", \"Unix domain path too long\");\n-        ret=1;\n-        goto finish;\n-    }\n-    strncpy(sa->sun_path, pname, name_len);\n-    *len = (int)(offsetof(struct sockaddr_un, sun_path) + name_len);\n-    ret = 0;\n-  finish:\n-    (*env)->ReleaseByteArrayElements(env, addr, pname, JNI_ABORT);\n-    return ret;\n-}\n-\n-\n-JNIEXPORT jboolean JNICALL\n-Java_sun_nio_ch_UnixDomainNet_socketSupported(JNIEnv *env, jclass cl)\n-{\n-    SOCKET fd = socket(PF_UNIX, SOCK_STREAM, 0);\n-    if (fd == INVALID_SOCKET) {\n-        return JNI_FALSE;\n-    }\n-    closesocket(fd);\n-    return JNI_TRUE;\n-}\n-\n-JNIEXPORT jint JNICALL\n-Java_sun_nio_ch_UnixDomainNet_maxNameLen0(JNIEnv *env, jclass cl)\n-{\n-    return MAX_UNIX_DOMAIN_PATH_LEN - 1;\n-}\n-\n-JNIEXPORT jint JNICALL\n-Java_sun_nio_ch_UnixDomainNet_socket0(JNIEnv *env, jclass cl)\n-{\n-    SOCKET fd = socket(PF_UNIX, SOCK_STREAM, 0);\n-    if (fd == INVALID_SOCKET) {\n-        return handleSocketError(env, WSAGetLastError());\n-    }\n-    return (int)fd;\n-}\n-\n-\/**\n- * Windows does not support auto bind. So, the windows version of NET_UnixSocketAddressToSockaddr\n- * looks out for a null 'uaddr' and handles it specially\n- *\/\n-JNIEXPORT void JNICALL\n-Java_sun_nio_ch_UnixDomainNet_bind0(JNIEnv *env, jclass clazz, jobject fdo, jbyteArray addr)\n-{\n-    struct sockaddr_un sa;\n-    int sa_len = 0;\n-    int rv = 0;\n-\n-    if (NET_UnixSocketAddressToSockaddr(env, addr, &sa, &sa_len) != 0)\n-        return;\n-\n-    int fd = fdval(env, fdo);\n-\n-    rv = bind(fdval(env, fdo), (struct sockaddr *)&sa, sa_len);\n-    if (rv != 0) {\n-        int err = WSAGetLastError();\n-        NET_ThrowNew(env, err, \"bind\");\n-    }\n-}\n-\n-JNIEXPORT jint JNICALL\n-Java_sun_nio_ch_UnixDomainNet_connect0(JNIEnv *env, jclass clazz, jobject fdo, jbyteArray addr)\n-{\n-    struct sockaddr_un sa;\n-    int sa_len = 0;\n-    int rv;\n-\n-    if (NET_UnixSocketAddressToSockaddr(env, addr, &sa, &sa_len) != 0) {\n-        return IOS_THROWN;\n-    }\n-\n-    rv = connect(fdval(env, fdo), (const struct sockaddr *)&sa, sa_len);\n-    if (rv != 0) {\n-        int err = WSAGetLastError();\n-        if (err == WSAEINPROGRESS || err == WSAEWOULDBLOCK) {\n-            return IOS_UNAVAILABLE;\n-        }\n-        NET_ThrowNew(env, err, \"connect\");\n-        return IOS_THROWN;\n-    }\n-    return 1;\n-}\n-\n-JNIEXPORT jint JNICALL\n-Java_sun_nio_ch_UnixDomainNet_accept0(JNIEnv *env, jclass clazz, jobject fdo, jobject newfdo,\n-                           jobjectArray usaa)\n-{\n-    jint fd = fdval(env, fdo);\n-    jint newfd;\n-    struct sockaddr_un sa;\n-    socklen_t sa_len = sizeof(sa);\n-    jobject usa;\n-\n-    memset((char *)&sa, 0, sizeof(sa));\n-    newfd = (jint) accept(fd, (struct sockaddr *)&sa, &sa_len);\n-    if (newfd == INVALID_SOCKET) {\n-        int theErr = (jint)WSAGetLastError();\n-        if (theErr == WSAEWOULDBLOCK) {\n-            return IOS_UNAVAILABLE;\n-        }\n-        JNU_ThrowIOExceptionWithLastError(env, \"Accept failed\");\n-        return IOS_THROWN;\n-    }\n-\n-    SetHandleInformation((HANDLE)(UINT_PTR)newfd, HANDLE_FLAG_INHERIT, 0);\n-    setfdval(env, newfdo, newfd);\n-\n-    usa = NET_SockaddrToUnixAddressBytes(env, &sa, sa_len);\n-    CHECK_NULL_RETURN(usa, IOS_THROWN);\n-\n-    (*env)->SetObjectArrayElement(env, usaa, 0, usa);\n-\n-    return 1;\n-}\n-\n-\/* only used here so as not to make SOCKETADDRESS too large\n- * and some buggy usages elsewhere\n- *\/\n-typedef union {\n-    struct sockaddr     sa;\n-    struct sockaddr_in  sa4;\n-    struct sockaddr_in6 sa6;\n-    struct sockaddr_un  saun;\n-} sockaddrall;\n-\n-JNIEXPORT jbyteArray JNICALL\n-Java_sun_nio_ch_UnixDomainNet_localAddress0(JNIEnv *env, jclass clazz, jobject fdo)\n-{\n-    sockaddrall sa;\n-    int sa_len = sizeof(sa);\n-\n-    if (getsockname(fdval(env, fdo), &sa.sa, &sa_len) == SOCKET_ERROR) {\n-        NET_ThrowNew(env, WSAGetLastError(), \"getsockname\");\n-        return NULL;\n-    }\n-    return NET_SockaddrToUnixAddressBytes(env, &sa.saun, sa_len);\n-}\n-\n-JNIEXPORT jbyteArray JNICALL\n-Java_sun_nio_ch_UnixDomainNet_remoteAddress0(JNIEnv *env, jclass clazz, jobject fdo)\n-{\n-    sockaddrall sa;\n-    int sa_len = sizeof(sa);\n-\n-    if (getpeername(fdval(env, fdo), &sa.sa, &sa_len) == SOCKET_ERROR) {\n-        NET_ThrowNew(env, WSAGetLastError(), \"getsockname\");\n-        return NULL;\n-    }\n-    return NET_SockaddrToUnixAddressBytes(env, &sa.saun, sa_len);\n-}\n","filename":"src\/java.base\/windows\/native\/libnio\/ch\/UnixNet.c","additions":0,"deletions":223,"binary":false,"changes":223,"status":"deleted"},{"patch":"@@ -48,1 +48,1 @@\n-        try {SocketChannel.open(); } catch (IOException e) {}\n+        try {SocketChannel.open(UNIX); } catch (IOException e) {}\n","filename":"test\/jdk\/java\/nio\/channels\/unixdomain\/IOExchanges.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import static java.net.StandardProtocolFamily.UNIX;\n@@ -48,1 +49,1 @@\n-        try {SocketChannel.open(); } catch (java.io.IOException e) {}\n+        try {SocketChannel.open(UNIX); } catch (java.io.IOException e) {}\n","filename":"test\/jdk\/java\/nio\/channels\/unixdomain\/LengthTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -75,1 +75,1 @@\n-        try {SocketChannel.open(); } catch (java.io.IOException e) {}\n+        try {SocketChannel.open(UNIX); } catch (java.io.IOException e) {}\n","filename":"test\/jdk\/java\/nio\/channels\/unixdomain\/Security.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}