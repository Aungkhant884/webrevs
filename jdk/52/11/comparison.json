{"files":[{"patch":"@@ -185,4 +185,2 @@\n-$(eval $(call SetupCopyFiles, COPY_NET_PROPERTIES, \\\n-    FILES := $(TOPDIR)\/src\/java.base\/share\/conf\/net.properties, \\\n-    DEST := $(CONF_DST_DIR), \\\n-))\n+NET_PROPERTIES_SRC := $(TOPDIR)\/src\/java.base\/share\/conf\/net.properties.common\n+NET_PROPERTIES_DST := $(CONF_DST_DIR)\/net.properties\n@@ -190,1 +188,12 @@\n-TARGETS += $(COPY_NET_PROPERTIES)\n+NET_PROPERTIES_SRC += $(TOPDIR)\/src\/java.base\/unix\/conf\/net.properties.unix\n+NET_PROPERTIES_SRC += $(TOPDIR)\/src\/java.base\/windows\/conf\/net.properties.windows\n+\n+NET_PROPERTIES_SRC_LIST := $(NET_PROPERTIES_SRC)\n+\n+$(NET_PROPERTIES_DST): $(NET_PROPERTIES_SRC_LIST)\n+\t$(call MakeTargetDir)\n+\t$(RM) $@ $@.tmp\n+\t$(foreach f,$(NET_PROPERTIES_SRC_LIST),$(CAT) $(f) >> $@.tmp;)\n+\t$(MV) $@.tmp $@\n+\n+TARGETS += $(NET_PROPERTIES_DST)\n","filename":"make\/modules\/java.base\/Copy.gmk","additions":14,"deletions":5,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -69,0 +69,10 @@\n+ *   <th scope=\"row\">accessUnixDomainSocket<\/th>\n+ *   <td>The ability to accept, bind, connect or get the local address\n+ *   of a <i>Unix Domain<\/i> socket.\n+ *   <\/td>\n+ *   <td>Malicious code could connect to local processes using Unix domain sockets\n+ *    or impersonate local processes, by binding to the same pathnames (assuming they\n+ *    have the required Operating System permissions.<\/td>\n+ * <\/tr>\n+ *\n+ * <tr>\n","filename":"src\/java.base\/share\/classes\/java\/net\/NetPermission.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -44,1 +44,7 @@\n-    INET6\n+    INET6,\n+\n+    \/**\n+     * Local (Unix domain) interprocess communication.\n+     * @since 16\n+     *\/\n+    UNIX\n","filename":"src\/java.base\/share\/classes\/java\/net\/StandardProtocolFamily.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,207 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.net;\n+\n+import java.io.ObjectStreamException;\n+import java.io.Serializable;\n+import java.net.SocketAddress;\n+import java.nio.channels.SocketChannel;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n+import java.nio.file.InvalidPathException;\n+import java.nio.file.Path;\n+\n+\/**\n+ * A <a href=\"package-summary.html#unixdomain\">Unix domain<\/a> socket address.\n+ * A Unix domain socket address encapsulates a file-system path that Unix domain sockets\n+ * bind or connect to.\n+ *\n+ * <p> An <a id=\"unnamed\"><\/a><i>unnamed<\/i> {@code UnixDomainSocketAddress} has\n+ * an empty path. The local address of a {@link SocketChannel} to a Unix domain socket\n+ * that is <i>automatically<\/i> or <i>implicitly<\/i> bound will be unnamed.\n+ *\n+ * <p> {@link Path} objects used to create instances of this class must be obtained\n+ * from the {@linkplain FileSystems#getDefault system-default} file system.\n+ *\n+ * @see java.nio.channels.SocketChannel\n+ * @see java.nio.channels.ServerSocketChannel\n+ * @since 16\n+ *\/\n+public final class UnixDomainSocketAddress extends SocketAddress {\n+    @java.io.Serial\n+    static final long serialVersionUID = 92902496589351288L;\n+\n+    private final transient Path path;\n+\n+    \/**\n+     * A serial proxy for all {@link UnixDomainSocketAddress} instances.\n+     * It captures the file path name and reconstructs using the public static\n+     * {@link #of(String) factory}.\n+     *\n+     * @serial include\n+     *\/\n+    private static final class Ser implements Serializable {\n+        @java.io.Serial\n+        static final long serialVersionUID = -7955684448513979814L;\n+\n+        \/**\n+         * The path name.\n+         * @serial\n+         *\/\n+        private final String pathname;\n+\n+        Ser(String pathname) {\n+            this.pathname = pathname;\n+        }\n+\n+        \/**\n+         * Creates a {@link UnixDomainSocketAddress} instance, by an invocation\n+         * of the {@link #of(String) factory} method passing the path name.\n+         * @return a UnixDomainSocketAddress\n+         *\/\n+        @java.io.Serial\n+        private Object readResolve() {\n+            return UnixDomainSocketAddress.of(pathname);\n+        }\n+    }\n+\n+    \/**\n+     * Returns a\n+     * <a href=\"{@docRoot}\/serialized-form.html#java.net.UnixDomainSocketAddress.Ser\">\n+     * Ser<\/a> containing the path name of this instance.\n+     *\n+     * @return a {@link Ser}\n+     * representing the path name of this instance\n+     *\/\n+    @java.io.Serial\n+    private Object writeReplace() throws ObjectStreamException {\n+        return new Ser(path.toString());\n+    }\n+\n+    \/**\n+     * Throws InvalidObjectException, always.\n+     * @param s the stream\n+     * @throws java.io.InvalidObjectException always\n+     *\/\n+    @java.io.Serial\n+    private void readObject(java.io.ObjectInputStream s)\n+        throws java.io.InvalidObjectException\n+    {\n+        throw new java.io.InvalidObjectException(\"Proxy required\");\n+    }\n+\n+    \/**\n+     * Throws InvalidObjectException, always.\n+     * @throws java.io.InvalidObjectException always\n+     *\/\n+    @java.io.Serial\n+    private void readObjectNoData()\n+        throws java.io.InvalidObjectException\n+    {\n+        throw new java.io.InvalidObjectException(\"Proxy required\");\n+    }\n+\n+    private UnixDomainSocketAddress(Path path) {\n+        FileSystem fs = path.getFileSystem();\n+        if (fs != FileSystems.getDefault()) {\n+            throw new IllegalArgumentException(); \/\/ fix message\n+        }\n+        if (fs.getClass().getModule() != Object.class.getModule()) {\n+            throw new IllegalArgumentException();  \/\/ fix message\n+        }\n+        this.path = path;\n+    }\n+\n+    \/**\n+     * Create a UnixDomainSocketAddress from the given path string.\n+     *\n+     * @param  pathname\n+     *         The path string, which can be empty\n+     *\n+     * @return A UnixDomainSocketAddress\n+     *\n+     * @throws InvalidPathException\n+     *         If the path cannot be converted to a Path\n+     *\/\n+    public static UnixDomainSocketAddress of(String pathname) {\n+        return of(Path.of(pathname));\n+    }\n+\n+    \/**\n+     * Create a UnixDomainSocketAddress for the given path.\n+     *\n+     * @param  path\n+     *         The path to the socket, which can be empty\n+     *\n+     * @return A UnixDomainSocketAddress\n+     *\n+     * @throws IllegalArgumentException\n+     *         If the path is not associated with the default file system\n+     *\/\n+    public static UnixDomainSocketAddress of(Path path) {\n+        return new UnixDomainSocketAddress(path);\n+    }\n+\n+    \/**\n+     * Return this address's path.\n+     *\n+     * @return this address's path\n+     *\/\n+    public Path getPath() {\n+        return path;\n+    }\n+\n+    \/**\n+     * Returns the hash code of this {@code UnixDomainSocketAddress}\n+     *\/\n+    @Override\n+    public int hashCode() {\n+        return path.hashCode();\n+    }\n+\n+    \/**\n+     * Compares this address with another object.\n+     *\n+     * @return true if the path fields are equal\n+     *\/\n+    @Override\n+    public boolean equals(Object o) {\n+        if (! (o instanceof UnixDomainSocketAddress))\n+            return false;\n+        UnixDomainSocketAddress that = (UnixDomainSocketAddress)o;\n+        return this.path.equals(that.path);\n+    }\n+\n+    \/**\n+     * Returns a string representation of this {@code UnixDomainSocketAddress}.\n+     *\n+     * @return this address's path which may be empty for an unnamed address\n+     *\/\n+    @Override\n+    public String toString() {\n+        return path.toString();\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/net\/UnixDomainSocketAddress.java","additions":207,"deletions":0,"binary":false,"changes":207,"status":"added"},{"patch":"@@ -153,0 +153,3 @@\n+     *\n+     * @see     <a href=\"..\/..\/net\/doc-files\/net-properties.html#Ipv4IPv6\">\n+     *          java.net.preferIPv4Stack<\/a> system property\n@@ -172,0 +175,3 @@\n+     * @apiNote <a href=\"package-summary.html#unixdomain\">Unix domain<\/a> sockets\n+     * are not supported by DatagramChannel.\n+     *\n@@ -185,0 +191,3 @@\n+     * @see     <a href=\"..\/..\/net\/doc-files\/net-properties.html#Ipv4IPv6\">\n+     *          java.net.preferIPv4Stack<\/a> system property\n+     *\n@@ -632,1 +641,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/java\/nio\/channels\/DatagramChannel.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import java.net.NetPermission;\n@@ -33,0 +34,1 @@\n+import java.net.UnixDomainSocketAddress;\n@@ -40,5 +42,8 @@\n- * <p> A server-socket channel is created by invoking the {@link #open() open}\n- * method of this class.  It is not possible to create a channel for an arbitrary,\n- * pre-existing {@link ServerSocket}. A newly-created server-socket channel is\n- * open but not yet bound.  An attempt to invoke the {@link #accept() accept}\n- * method of an unbound server-socket channel will cause a {@link NotYetBoundException}\n+ * <p> A server-socket channel is created by invoking one of the {@code open}\n+ * methods of this class. The no-arg {@link #open() open} method opens a server-socket\n+ * channel for an <i>Internet protocol<\/i> socket. The {@link #open(ProtocolFamily)}\n+ * method is used to open a server-socket channel for a socket of a specified\n+ * protocol family. It is not possible to create a channel for an arbitrary,\n+ * pre-existing socket. A newly-created server-socket channel is open but not yet\n+ * bound. An attempt to invoke the {@link #accept() accept} method of an\n+ * unbound server-socket channel will cause a {@link NotYetBoundException}\n@@ -46,1 +51,1 @@\n- * {@link #bind(java.net.SocketAddress,int) bind} methods defined by this class.\n+ * {@link #bind(java.net.SocketAddress, int) bind} methods defined by this class.\n@@ -49,1 +54,2 @@\n- * setOption} method. Server-socket channels support the following options:\n+ * setOption} method. Server-socket channels for <i>Internet protocol<\/i> sockets\n+ * support the following options:\n@@ -71,1 +77,21 @@\n- * Additional (implementation specific) options may also be supported.\n+ *\n+ * <p> Server-socket channels for <i>Unix domain<\/i> sockets support:\n+ * <blockquote>\n+ * <table class=\"striped\">\n+ * <caption style=\"display:none\">Socket options<\/caption>\n+ * <thead>\n+ *   <tr>\n+ *     <th scope=\"col\">Option Name<\/th>\n+ *     <th scope=\"col\">Description<\/th>\n+ *   <\/tr>\n+ * <\/thead>\n+ * <tbody>\n+ *   <tr>\n+ *     <th scope=\"row\"> {@link java.net.StandardSocketOptions#SO_RCVBUF SO_RCVBUF} <\/th>\n+ *     <td> The size of the socket receive buffer <\/td>\n+ *   <\/tr>\n+ * <\/tbody>\n+ * <\/table>\n+ * <\/blockquote>\n+ *\n+ * <p> Additional (implementation specific) options may also be supported.\n@@ -97,1 +123,1 @@\n-     * Opens a server-socket channel.\n+     * Opens a server-socket channel for an <i>Internet protocol<\/i> socket.\n@@ -113,0 +139,3 @@\n+     *\n+     * @see     <a href=\"..\/..\/net\/doc-files\/net-properties.html#Ipv4IPv6\">\n+     *          java.net.preferIPv4Stack<\/a> system property\n@@ -119,1 +148,1 @@\n-     * Opens a server-socket channel.The {@code family} parameter specifies the\n+     * Opens a server-socket channel. The {@code family} parameter specifies the\n@@ -140,0 +169,3 @@\n+     * @see     <a href=\"..\/..\/net\/doc-files\/net-properties.html#Ipv4IPv6\">\n+     *          java.net.preferIPv4Stack<\/a> system property\n+     *\n@@ -183,2 +215,1 @@\n-     *          If a security manager has been installed and its {@link\n-     *          SecurityManager#checkListen checkListen} method denies the\n+     *          If a security manager has been installed and it denies the\n@@ -200,2 +231,2 @@\n-     * a local address. Once an association is established then the socket remains\n-     * bound until the channel is closed.\n+     * a local address. For <i>Internet protocol<\/i> sockets, once an association\n+     * is established then the socket remains bound until the channel is closed.\n@@ -210,0 +241,16 @@\n+     * @apiNote\n+     * Binding a server socket channel for a <i>Unix Domain<\/i> socket, creates a\n+     * file corresponding to the file path in the {@link UnixDomainSocketAddress}.\n+     * This file persists after the channel is closed, and must be removed before\n+     * another socket can bind to the same name. Binding to a {@code null} address\n+     * causes the socket to be <i>automatically<\/i> bound to some unique file\n+     * in a system temporary location. The associated socket file also persists\n+     * after the channel is closed. Its name can be obtained from the channel's\n+     * local socket address.\n+     *\n+     * @implNote\n+     * Each platform enforces an implementation specific, maximum length for the\n+     * name of a <i>Unix Domain<\/i> socket. This limitation is enforced when a\n+     * channel is bound. The maximum length is typically close to and generally\n+     * not less than 100 bytes.\n+     *\n@@ -211,2 +258,2 @@\n-     *          The address to bind the socket, or {@code null} to bind to an\n-     *          automatically assigned socket address\n+     *          The address to bind the socket, or {@code null} to bind to\n+     *          an automatically assigned socket address\n@@ -228,2 +275,4 @@\n-     *          SecurityManager#checkListen checkListen} method denies the\n-     *          operation\n+     *          SecurityManager#checkListen checkListen} method denies\n+     *          the operation for an <i>Internet protocol<\/i> socket address,\n+     *          or for a <i>Unix domain<\/i> socket address if it denies\n+     *          {@link NetPermission}{@code(\"accessUnixDomainSocket\")}.\n@@ -254,0 +303,3 @@\n+     *\n+     * @throws  UnsupportedOperationException\n+     *          If the channel's socket is not an <i>Internet protocol<\/i> socket\n@@ -268,7 +320,9 @@\n-     * <p> This method performs exactly the same security checks as the {@link\n-     * java.net.ServerSocket#accept accept} method of the {@link\n-     * java.net.ServerSocket} class.  That is, if a security manager has been\n-     * installed then for each new connection this method verifies that the\n-     * address and port number of the connection's remote endpoint are\n-     * permitted by the security manager's {@link\n-     * java.lang.SecurityManager#checkAccept checkAccept} method.  <\/p>\n+     * <p> If bound to an <i>Internet protocol<\/i> socket address, this method\n+     * performs exactly the same security checks as the {@link\n+     * java.net.ServerSocket#accept accept} method of the {@link java.net.ServerSocket}\n+     * class.  That is, if a security manager has been installed then for each\n+     * new connection this method verifies that the address and port number\n+     * of the connection's remote endpoint are permitted by the security\n+     * manager's {@link java.lang.SecurityManager#checkAccept checkAccept}\n+     * method. If bound to a <i>Unix Domain<\/i> socket address, this method checks\n+     * {@link NetPermission}{@code (\"accessUnixDomainSocket\")}.\n@@ -308,1 +362,1 @@\n-     * <p>\n+     *\n@@ -316,0 +370,7 @@\n+     * <p> Where the channel is bound to a <i>Unix Domain<\/i> socket address, the socket\n+     * address is a {@link UnixDomainSocketAddress}. If there is a security manager\n+     * set, its {@link SecurityManager#checkPermission(java.security.Permission)\n+     * checkPermission} method is called with {@link NetPermission}{@code\n+     * (\"accessUnixDomainSocket\")}. If the operation is not allowed an unnamed\n+     * {@link UnixDomainSocketAddress} is returned.\n+     *\n@@ -317,2 +378,2 @@\n-     *          {@code SocketAddress} representing the loopback address if\n-     *          denied by the security manager, or {@code null} if the\n+     *          {@code SocketAddress} representing the loopback address or empty\n+     *          path if denied by the security manager, or {@code null} if the\n@@ -326,1 +387,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/java\/nio\/channels\/ServerSocketChannel.java","additions":89,"deletions":29,"binary":false,"changes":118,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+import java.net.InetSocketAddress;\n+import java.net.NetPermission;\n@@ -30,0 +32,1 @@\n+import java.net.StandardProtocolFamily;\n@@ -33,0 +36,1 @@\n+import java.net.UnixDomainSocketAddress;\n@@ -41,9 +45,12 @@\n- * <p> A socket channel is created by invoking one of the {@link #open open}\n- * methods of this class.  It is not possible to create a channel for an arbitrary,\n- * pre-existing socket. A newly-created socket channel is open but not yet\n- * connected.  An attempt to invoke an I\/O operation upon an unconnected\n- * channel will cause a {@link NotYetConnectedException} to be thrown.  A\n- * socket channel can be connected by invoking its {@link #connect connect}\n- * method; once connected, a socket channel remains connected until it is\n- * closed.  Whether or not a socket channel is connected may be determined by\n- * invoking its {@link #isConnected isConnected} method.\n+ * <p> A socket channel is created by invoking one of the {@code open} methods of\n+ * this class. The no-arg {@link #open() open} method opens a socket channel\n+ * for an <i>Internet protocol<\/i> socket. The {@link #open(ProtocolFamily)}\n+ * method is used to open a socket channel for a socket of a specified protocol\n+ * family. It is not possible to create a channel for an arbitrary, pre-existing\n+ * socket. A newly-created socket channel is open but not yet connected.  An\n+ * attempt to invoke an I\/O operation upon an unconnected channel will cause a\n+ * {@link NotYetConnectedException} to be thrown.  A socket channel can be\n+ * connected by invoking its {@link #connect connect} method; once connected,\n+ * a socket channel remains connected until it is closed.  Whether or not a\n+ * socket channel is connected may be determined by invoking its {@link #isConnected()\n+ * isConnected} method.\n@@ -58,1 +65,1 @@\n- * <p> Socket channels support <i>asynchronous shutdown,<\/i> which is similar\n+ * <p> Socket channels support <i>asynchronous shutdown<\/i>, which is similar\n@@ -69,1 +76,2 @@\n- * setOption} method. Socket channels support the following options:\n+ * setOption} method. Socket channels for  <i>Internet protocol<\/i> sockets support\n+ * following options:\n@@ -108,1 +116,30 @@\n- * Additional (implementation specific) options may also be supported.\n+ *\n+ * <p> Socket channels for <i>Unix domain<\/i> sockets support:\n+ * <blockquote>\n+ * <table class=\"striped\">\n+ * <caption style=\"display:none\">Socket options<\/caption>\n+ * <thead>\n+ *   <tr>\n+ *     <th scope=\"col\">Option Name<\/th>\n+ *     <th scope=\"col\">Description<\/th>\n+ *   <\/tr>\n+ * <\/thead>\n+ * <tbody>\n+ *   <tr>\n+ *     <th scope=\"row\"> {@link java.net.StandardSocketOptions#SO_SNDBUF SO_SNDBUF} <\/th>\n+ *     <td> The size of the socket send buffer <\/td>\n+ *   <\/tr>\n+ *   <tr>\n+ *     <th scope=\"row\"> {@link java.net.StandardSocketOptions#SO_RCVBUF SO_RCVBUF} <\/th>\n+ *     <td> The size of the socket receive buffer <\/td>\n+ *   <\/tr>\n+ *   <tr>\n+ *     <th scope=\"row\"> {@link java.net.StandardSocketOptions#SO_LINGER SO_LINGER} <\/th>\n+ *     <td> Linger on close if data is present (when configured in blocking mode\n+ *          only) <\/td>\n+ *   <\/tr>\n+ * <\/tbody>\n+ * <\/table>\n+ * <\/blockquote>\n+ *\n+ * <p> Additional (implementation specific) options may also be supported.\n@@ -139,1 +176,1 @@\n-     * Opens a socket channel.\n+     * Opens a socket channel for an <i>Internet protocol<\/i> socket.\n@@ -150,0 +187,3 @@\n+     *\n+     * @see     <a href=\"..\/..\/net\/doc-files\/net-properties.html#Ipv4IPv6\">\n+     *          java.net.preferIPv4Stack<\/a> system property\n@@ -177,0 +217,3 @@\n+     * @see     <a href=\"..\/..\/net\/doc-files\/net-properties.html#Ipv4IPv6\">\n+     *          java.net.preferIPv4Stack<\/a> system property\n+     *\n@@ -186,4 +229,10 @@\n-     * <p> This convenience method works as if by invoking the {@link #open()}\n-     * method, invoking the {@link #connect(SocketAddress) connect} method upon\n-     * the resulting socket channel, passing it {@code remote}, and then\n-     * returning that channel.  <\/p>\n+     * <p> If the remote address is an {@link InetSocketAddress} then this\n+     * method works as if by invoking the {@link #open()} method, invoking the\n+     * {@link #connect(SocketAddress) connect} method upon the resulting socket\n+     * channel, passing it {@code remote}, and then returning that channel.\n+     *\n+     * <p> If the remote address is a {@link UnixDomainSocketAddress} then this\n+     * works by invoking the {@link #open(ProtocolFamily)} method with {@link\n+     * StandardProtocolFamily#UNIX} as parameter, invoking the {@link\n+     * #connect(SocketAddress) connect} method upon the resulting socket channel,\n+     * passing it {@code remote}, then returning that channel.  <\/p>\n@@ -207,1 +256,2 @@\n-     *          If the given remote address is not fully resolved\n+     *          If the given remote address is an InetSocketAddress that is not fully\n+     *          resolved\n@@ -218,0 +268,3 @@\n+     *\n+     * @see     <a href=\"..\/..\/net\/doc-files\/net-properties.html#Ipv4IPv6\">\n+     *          java.net.preferIPv4Stack<\/a> system property\n@@ -222,1 +275,8 @@\n-        SocketChannel sc = open();\n+        SocketChannel sc;\n+        if (remote instanceof InetSocketAddress)\n+            sc = open();\n+        else if (remote instanceof UnixDomainSocketAddress)\n+            sc = open(StandardProtocolFamily.UNIX);\n+        else\n+            throw new UnsupportedAddressTypeException();\n+\n@@ -258,0 +318,32 @@\n+     * Binds the channel's socket to a local address.\n+     *\n+     * <p> This method is used to establish an association between the socket\n+     * and a local address. For <i>Internet Protocol<\/i> sockets, once an\n+     * association is established then the socket remains bound until the\n+     * channel is closed. If the {@code local} parameter has the value {@code\n+     * null} then the socket will be bound to an address that is assigned\n+     * automatically.\n+     *\n+     * @apiNote\n+     * Binding a socket channel to a <i>Unix Domain<\/i> socket creates a file\n+     * corresponding to the file path in the {@link UnixDomainSocketAddress}. This\n+     * file persists after the channel is closed, and must be removed before\n+     * another socket can bind to the same name. If a socket channel to a Unix\n+     * Domain socket is <i>implicitly<\/i> bound by connecting it without calling\n+     * bind first, then its socket is\n+     * <a href=\"..\/..\/java\/net\/UnixDomainSocketAddress.html#unnamed\">unnamed<\/a>\n+     * with no corresponding socket file in the file-system. If a socket channel\n+     * to a Unix Domain socket is <i>automatically<\/i> bound by calling {@code\n+     * bind(null)} this results in an unnamed socket also.\n+     *\n+     * @implNote\n+     * Each platform enforces an implementation specific maximum length for the\n+     * name of a <i>Unix Domain<\/i> socket. This limitation is enforced when a\n+     * channel is bound. The maximum length is typically close to and generally\n+     * not less than 100 bytes.\n+     *\n+     * @param   local The address to bind the socket, or {@code null} to bind\n+     *          the socket to an automatically assigned socket address\n+     *\n+     * @return  This channel\n+     *\n@@ -266,3 +358,5 @@\n-     *          If a security manager has been installed and its\n-     *          {@link SecurityManager#checkListen checkListen} method denies\n-     *          the operation\n+     *          If a security manager has been installed and its {@link\n+     *          SecurityManager#checkListen checkListen} method denies\n+     *          the operation for an <i>Internet protocol<\/i> socket address,\n+     *          or for a <i>Unix domain<\/i> socket address if it denies\n+     *          {@link NetPermission}{@code(\"accessUnixDomainSocket\")}.\n@@ -332,3 +426,0 @@\n-     * <p> The returned object will not declare any public methods that are not\n-     * declared in the {@link java.net.Socket} class.  <\/p>\n-     *\n@@ -336,0 +427,3 @@\n+     *\n+     * @throws  UnsupportedOperationException\n+     *          If the channel's socket is not an <i>Internet protocol<\/i> socket\n@@ -371,2 +465,3 @@\n-     * <p> This method performs exactly the same security checks as the {@link\n-     * java.net.Socket} class.  That is, if a security manager has been\n+     * <p> For channels to <i>Internet protocol<\/i> sockets, this method performs\n+     * exactly the same security checks as the {@link java.net.Socket} class.\n+     * That is, if a security manager has been\n@@ -377,0 +472,6 @@\n+     * <p> For channels to <i>Unix Domain<\/i> sockets, this method checks\n+     * {@link java.net.NetPermission NetPermission}{@code\n+     * (\"accessUnixDomainSocket\")} with the security manager's {@link\n+     * SecurityManager#checkPermission(java.security.Permission)\n+     * checkPermission} method.\n+     *\n@@ -412,1 +513,1 @@\n-     *          If the given remote address is not fully resolved\n+     *          If the given remote address is an InetSocketAddress that is not fully resolved\n@@ -480,3 +581,6 @@\n-     * <p> Where the channel is bound and connected to an Internet Protocol\n-     * socket address then the return value from this method is of type {@link\n-     * java.net.InetSocketAddress}.\n+     * <p> Where the channel's socket is bound and connected to an <i>Internet\n+     * Protocol<\/i> socket address then the return value is of type\n+     * {@link java.net.InetSocketAddress}.\n+     *\n+     * <p> Where the channel's socket is bound and connected to a <i>Unix Domain<\/i>\n+     * socket address, the returned address is a {@link UnixDomainSocketAddress}.\n@@ -542,1 +646,1 @@\n-     * <p>\n+     *\n@@ -550,0 +654,7 @@\n+     * <p> Where the channel is bound to a Unix Domain socket address, the socket\n+     * address is a {@link UnixDomainSocketAddress}. If there is a security manager\n+     * set, its {@link SecurityManager#checkPermission(java.security.Permission)\n+     * checkPermission} method is called with {@link NetPermission}{@code\n+     * (\"accessUnixDomainSocket\")}. If the operation is not allowed an unnamed\n+     * {@link UnixDomainSocketAddress} is returned.\n+     *\n@@ -551,2 +662,2 @@\n-     *          {@code SocketAddress} representing the loopback address if\n-     *          denied by the security manager, or {@code null} if the\n+     *          {@code SocketAddress} representing the loopback address or empty\n+     *          path if denied by the security manager, or {@code null} if the\n@@ -560,1 +671,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/java\/nio\/channels\/SocketChannel.java","additions":145,"deletions":35,"binary":false,"changes":180,"status":"modified"},{"patch":"@@ -244,0 +244,22 @@\n+ * <p> {@link java.nio.channels.DatagramChannel},\n+ * {@link java.nio.channels.SocketChannel} and\n+ * {@link java.nio.channels.ServerSocketChannel}s can be created\n+ * with different {@link java.net.ProtocolFamily protocol families}. The standard\n+ * family types are specified in {@link java.net.StandardProtocolFamily}.\n+ *\n+ * <p> Channels for <i>Internet Protocol<\/i> sockets are created using the\n+ * {@link java.net.StandardProtocolFamily#INET INET} or {@link\n+ * java.net.StandardProtocolFamily#INET6 INET6} protocol families. <i>Internet\n+ * Protocol<\/i> sockets support network communication using TCP and UDP and are\n+ * addressed using {@link java.net.InetSocketAddress}es which encapsulate an IP\n+ * address and port number. <i>Internet Protocol<\/i> sockets are also the default\n+ * type created, when a protocol family is not specified in the channel factory\n+ * creation method.\n+ *\n+ * <p> Channels for <a id=\"unixdomain\"><\/a><i>Unix Domain<\/i> sockets are created\n+ * using the {@link java.net.StandardProtocolFamily#UNIX UNIX} protocol family only.\n+ * <i>Unix Domain<\/i> sockets support local inter-process\n+ * communication on the same host, and are addressed using {@link\n+ * java.net.UnixDomainSocketAddress}es which encapsulate a filesystem pathname\n+ * on the local system.\n+ *\n","filename":"src\/java.base\/share\/classes\/java\/nio\/channels\/package-info.java","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -271,2 +271,2 @@\n-     * <p> In cases where the inherited channel represents a network socket\n-     * then the {@link java.nio.channels.Channel Channel} type returned\n+     * <p> In cases where the inherited channel is for an <i>Internet protocol<\/i>\n+     * socket then the {@link Channel Channel} type returned\n@@ -277,4 +277,4 @@\n-     *  <li><p> If the inherited channel represents a stream-oriented connected\n-     *  socket then a {@link java.nio.channels.SocketChannel SocketChannel} is\n-     *  returned. The socket channel is, at least initially, in blocking\n-     *  mode, bound to a socket address, and connected to a peer.\n+     *  <li><p> If the inherited channel is for a stream-oriented connected\n+     *  socket then a {@link SocketChannel SocketChannel} is returned. The\n+     *  socket channel is, at least initially, in blocking mode, bound\n+     *  to a socket address, and connected to a peer.\n@@ -283,4 +283,4 @@\n-     *  <li><p> If the inherited channel represents a stream-oriented listening\n-     *  socket then a {@link java.nio.channels.ServerSocketChannel\n-     *  ServerSocketChannel} is returned. The server-socket channel is, at\n-     *  least initially, in blocking mode, and bound to a socket address.\n+     *  <li><p> If the inherited channel is for a stream-oriented listening\n+     *  socket then a {@link ServerSocketChannel ServerSocketChannel} is returned.\n+     *  The server-socket channel is, at least initially, in blocking mode,\n+     *  and bound to a socket address.\n@@ -289,4 +289,3 @@\n-     *  <li><p> If the inherited channel is a datagram-oriented socket\n-     *  then a {@link java.nio.channels.DatagramChannel DatagramChannel} is\n-     *  returned. The datagram channel is, at least initially, in blocking\n-     *  mode, and bound to a socket address.\n+     *  <li><p> If the inherited channel is a datagram-oriented socket then a\n+     *  {@link DatagramChannel DatagramChannel} is returned. The datagram channel\n+     *  is, at least initially, in blocking mode, and bound to a socket address.\n@@ -297,2 +296,7 @@\n-     * <p> In addition to the network-oriented channels described, this method\n-     * may return other kinds of channels in the future.\n+     * <p> In cases where the inherited channel is for a <i>Unix domain<\/i>\n+     * socket then the {@link Channel} type returned is the same as for\n+     * <i>Internet protocol<\/i> sockets as described above, except that\n+     * datagram-oriented sockets are not supported.\n+     *\n+     * <p> In addition to the two types of socket just described, this method\n+     * may return other types in the future.\n","filename":"src\/java.base\/share\/classes\/java\/nio\/channels\/spi\/SelectorProvider.java","additions":20,"deletions":16,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -268,0 +268,2 @@\n+    exports sun.nio.fs to\n+        jdk.net;\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -51,0 +51,1 @@\n+    private final Set<SocketOption<?>> unixOptions;\n@@ -60,0 +61,3 @@\n+    \/** Return the, possibly empty, set of extended socket options available. *\/\n+    public final Set<SocketOption<?>> unixOptions() { return unixOptions; }\n+\n@@ -68,0 +72,4 @@\n+    public static Set<SocketOption<?>> unixSocketOptions() {\n+        return getInstance().unixOptions();\n+    }\n+\n@@ -85,1 +93,5 @@\n-        return !option.name().startsWith(\"TCP_\");\n+        return !option.name().startsWith(\"TCP_\") && !isUnixDomainOption(option);\n+    }\n+\n+    private static boolean isUnixDomainOption(SocketOption<?> option) {\n+        return option.name().equals(\"SO_PEERCRED\");\n@@ -89,1 +101,1 @@\n-        if (server && \"SO_FLOW_SLA\".equals(option.name())) {\n+        if (isUnixDomainOption(option)) {\n@@ -91,2 +103,0 @@\n-        } else {\n-            return !option.name().startsWith(\"UDP_\");\n@@ -94,0 +104,1 @@\n+        return !option.name().startsWith(\"UDP_\");\n@@ -125,0 +136,1 @@\n+        var unixOptions = new HashSet<SocketOption<?>>();\n@@ -135,0 +147,3 @@\n+            if (isUnixDomainOption(option)) {\n+                unixOptions.add(option);\n+            }\n@@ -139,0 +154,1 @@\n+        this.unixOptions = Set.copyOf(unixOptions);\n","filename":"src\/java.base\/share\/classes\/sun\/net\/ext\/ExtendedSocketOptions.java","additions":20,"deletions":4,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -31,0 +31,2 @@\n+import java.net.UnixDomainSocketAddress;\n+import java.net.SocketAddress;\n@@ -54,2 +56,6 @@\n-    public static IOException of(IOException e, InetSocketAddress address) {\n-        if (!enhancedExceptionText || address == null)\n+    public static IOException of(IOException e, SocketAddress addr) {\n+        if (addr instanceof UnixDomainSocketAddress) {\n+            return ofUnixDomain(e, (UnixDomainSocketAddress)addr);\n+        } else if (addr instanceof InetSocketAddress) {\n+            return ofInet(e, (InetSocketAddress)addr);\n+        } else {\n@@ -57,2 +63,9 @@\n-        int port = address.getPort();\n-        String host = address.getHostString();\n+        }\n+    }\n+\n+    private static IOException ofInet(IOException e, InetSocketAddress addr) {\n+        if (!enhancedExceptionText || addr == null) {\n+            return e;\n+        }\n+        int port = addr.getPort();\n+        String host = addr.getHostString();\n@@ -69,0 +82,13 @@\n+    private static IOException ofUnixDomain(IOException e, UnixDomainSocketAddress addr) {\n+        if (!enhancedExceptionText) {\n+            return e;\n+        }\n+        String path = addr.getPath().toString();\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(e.getMessage());\n+        sb.append(\": \");\n+        sb.append(path);\n+        String enhancedMsg = sb.toString();\n+        return create(e, enhancedMsg);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/net\/util\/SocketExceptions.java","additions":30,"deletions":4,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -0,0 +1,183 @@\n+\/*\n+ * Copyright (c) 2000, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.nio.ch;\n+\n+import java.io.FileDescriptor;\n+import java.io.IOException;\n+import java.net.InetSocketAddress;\n+import java.net.ProtocolFamily;\n+import java.net.StandardProtocolFamily;\n+import java.net.SocketAddress;\n+import java.net.SocketOption;\n+import java.net.StandardSocketOptions;\n+import java.nio.channels.SocketChannel;\n+import java.nio.channels.spi.SelectorProvider;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import sun.net.NetHooks;\n+import sun.net.ext.ExtendedSocketOptions;\n+\n+\/**\n+ * An implementation of ServerSocketChannels for AF_INET\/AF_INET6 sockets\n+ *\/\n+\n+class InetServerSocketChannelImpl\n+    extends ServerSocketChannelImpl\n+{\n+    \/\/ the protocol family requested by the user, or Net.UNSPEC if not specified\n+    private final ProtocolFamily family;\n+\n+    \/\/ set true when exclusive binding is on and SO_REUSEADDR is emulated\n+    private boolean isReuseAddress;\n+\n+    InetServerSocketChannelImpl(SelectorProvider sp) throws IOException {\n+        this(sp, Net.isIPv6Available()\n+                ? StandardProtocolFamily.INET6\n+                : StandardProtocolFamily.INET);\n+    }\n+\n+    InetServerSocketChannelImpl(SelectorProvider sp, ProtocolFamily family)\n+        throws IOException\n+    {\n+        super(sp, Net.serverSocket(family, true), false);\n+        this.family = family;\n+    }\n+\n+    InetServerSocketChannelImpl(SelectorProvider sp, FileDescriptor fd, boolean bound)\n+        throws IOException\n+    {\n+        super(sp, fd, bound);\n+        this.family =  Net.isIPv6Available()\n+                ? StandardProtocolFamily.INET6\n+                : StandardProtocolFamily.INET;\n+    }\n+\n+\n+    @Override\n+    InetSocketAddress implLocalAddress(FileDescriptor fd) throws IOException {\n+        return Net.localAddress(fd);\n+    }\n+\n+    @Override\n+    protected SocketAddress getRevealedLocalAddress(SocketAddress addr) {\n+        return Net.getRevealedLocalAddress((InetSocketAddress)addr);\n+    }\n+\n+    @Override\n+    protected String getRevealedLocalAddressAsString(SocketAddress addr) {\n+        return Net.getRevealedLocalAddressAsString((InetSocketAddress)addr);\n+    }\n+\n+    \/**\n+     * Returns the local address, or null if not bound\n+     *\/\n+    @Override\n+    InetSocketAddress localAddress() {\n+        return (InetSocketAddress)super.localAddress();\n+    }\n+\n+    @Override\n+    <T> void implSetOption(SocketOption<T> name, T value) throws IOException {\n+        if (name == StandardSocketOptions.SO_REUSEADDR && Net.useExclusiveBind()) {\n+            \/\/ SO_REUSEADDR emulated when using exclusive bind\n+            isReuseAddress = (Boolean) value;\n+        } else {\n+            Net.setSocketOption(getFD(), Net.UNSPEC, name, value);\n+        }\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    <T> T implGetOption(SocketOption<T> name) throws IOException {\n+        if (name == StandardSocketOptions.SO_REUSEADDR && Net.useExclusiveBind()) {\n+            \/\/ SO_REUSEADDR emulated when using exclusive bind\n+            return (T) Boolean.valueOf(isReuseAddress);\n+        }\n+        return (T) Net.getSocketOption(getFD(), Net.UNSPEC, name);\n+    }\n+\n+    private static class DefaultOptionsHolder {\n+        static final Set<SocketOption<?>> defaultOptions = defaultOptions();\n+\n+        private static Set<SocketOption<?>> defaultOptions() {\n+            HashSet<SocketOption<?>> set = new HashSet<>();\n+            set.add(StandardSocketOptions.SO_RCVBUF);\n+            set.add(StandardSocketOptions.SO_REUSEADDR);\n+            if (Net.isReusePortAvailable()) {\n+                set.add(StandardSocketOptions.SO_REUSEPORT);\n+            }\n+            set.addAll(ExtendedSocketOptions.serverSocketOptions());\n+            return Collections.unmodifiableSet(set);\n+        }\n+    }\n+\n+    @Override\n+    public final Set<SocketOption<?>> supportedOptions() {\n+        return DefaultOptionsHolder.defaultOptions;\n+    }\n+\n+    @Override\n+    SocketAddress implBind(SocketAddress local, int backlog) throws IOException {\n+        InetSocketAddress isa;\n+        if (local == null) {\n+            isa = new InetSocketAddress(Net.anyLocalAddress(family), 0);\n+        } else {\n+            isa = Net.checkAddress(local, family);\n+        }\n+        SecurityManager sm = System.getSecurityManager();\n+        if (sm != null)\n+            sm.checkListen(isa.getPort());\n+        NetHooks.beforeTcpBind(getFD(), isa.getAddress(), isa.getPort());\n+        Net.bind(family, getFD(), isa.getAddress(), isa.getPort());\n+        Net.listen(getFD(), backlog < 1 ? 50 : backlog);\n+        return Net.localAddress(getFD());\n+    }\n+\n+    @Override\n+    protected int implAccept(FileDescriptor fd, FileDescriptor newfd, SocketAddress[] addrs)\n+        throws IOException\n+    {\n+        InetSocketAddress[] a = new InetSocketAddress[1];\n+        int n = Net.accept(fd, newfd, a);\n+        addrs[0] = a[0];\n+        return n;\n+    }\n+\n+    @Override\n+    protected SocketChannel implFinishAccept(FileDescriptor newfd, SocketAddress sa)\n+        throws IOException\n+    {\n+        InetSocketAddress isa = (InetSocketAddress)sa;\n+        \/\/ check permitted to accept connections from the remote address\n+        SecurityManager sm = System.getSecurityManager();\n+        if (sm != null) {\n+            sm.checkAccept(isa.getAddress().getHostAddress(), isa.getPort());\n+        }\n+        return new InetSocketChannelImpl(provider(), family, newfd, isa);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/InetServerSocketChannelImpl.java","additions":183,"deletions":0,"binary":false,"changes":183,"status":"added"},{"patch":"@@ -0,0 +1,261 @@\n+\/*\n+ * Copyright (c) 2000, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.nio.ch;\n+\n+import java.io.FileDescriptor;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.Inet4Address;\n+import java.net.InetSocketAddress;\n+import java.net.ProtocolFamily;\n+import java.net.SocketAddress;\n+import java.net.SocketOption;\n+import java.net.StandardProtocolFamily;\n+import java.net.StandardSocketOptions;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.spi.SelectorProvider;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Set;\n+import sun.net.NetHooks;\n+import sun.net.ext.ExtendedSocketOptions;\n+\n+\/**\n+ * An implementation of SocketChannels for AF_INET\/AF_INET6 sockets\n+ *\/\n+\n+class InetSocketChannelImpl extends SocketChannelImpl\n+{\n+    \/\/ the protocol family of the socket\n+    private final ProtocolFamily family;\n+\n+    \/\/ set true when exclusive binding is on and SO_REUSEADDR is emulated\n+    private boolean isReuseAddress;\n+\n+    \/\/ Constructor for normal connecting sockets\n+    \/\/\n+    InetSocketChannelImpl(SelectorProvider sp) throws IOException {\n+        this(sp, Net.isIPv6Available()\n+                ? StandardProtocolFamily.INET6\n+                : StandardProtocolFamily.INET);\n+    }\n+\n+    InetSocketChannelImpl(SelectorProvider sp, ProtocolFamily family) throws IOException {\n+        super(sp, Net.socket(family, true), false);\n+        this.family = family;\n+    }\n+\n+    InetSocketChannelImpl(SelectorProvider sp, FileDescriptor fd, boolean bound)\n+        throws IOException\n+    {\n+        super(sp, fd, bound);\n+        this.family = Net.isIPv6Available()\n+                ? StandardProtocolFamily.INET6\n+                : StandardProtocolFamily.INET;\n+    }\n+\n+    @Override\n+    SocketAddress implLocalAddress(FileDescriptor fd) throws IOException {\n+        return Net.localAddress(fd);\n+    }\n+\n+    \/\/ Constructor for sockets obtained from server sockets\n+    \/\/\n+    InetSocketChannelImpl(SelectorProvider sp,\n+                          ProtocolFamily family,\n+                          FileDescriptor fd,\n+                          InetSocketAddress isa)\n+        throws IOException\n+    {\n+        super(sp, fd, isa);\n+        this.family = family;\n+    }\n+\n+\n+    @Override\n+    SocketAddress getRevealedLocalAddress(SocketAddress address) {\n+        return Net.getRevealedLocalAddress((InetSocketAddress)address);\n+    }\n+\n+    @Override\n+    <T> void implSetOption(SocketOption<T> name, T value) throws IOException {\n+        FileDescriptor fd = getFD();\n+\n+        if (name == StandardSocketOptions.IP_TOS) {\n+            ProtocolFamily family = Net.isIPv6Available() ?\n+                StandardProtocolFamily.INET6 : StandardProtocolFamily.INET;\n+            Net.setSocketOption(fd, family, name, value);\n+        } else if (name == StandardSocketOptions.SO_REUSEADDR && Net.useExclusiveBind()) {\n+            \/\/ SO_REUSEADDR emulated when using exclusive bind\n+            isReuseAddress = (Boolean)value;\n+        } else {\n+            Net.setSocketOption(fd, name, value);\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    <T> T implGetOption(SocketOption<T> name) throws IOException {\n+        FileDescriptor fd = getFD();\n+\n+        if (name == StandardSocketOptions.SO_REUSEADDR && Net.useExclusiveBind()) {\n+            \/\/ SO_REUSEADDR emulated when using exclusive bind\n+            return (T)Boolean.valueOf(isReuseAddress);\n+        }\n+\n+        \/\/ special handling for IP_TOS\n+        if (name == StandardSocketOptions.IP_TOS) {\n+            ProtocolFamily family = Net.isIPv6Available() ?\n+                StandardProtocolFamily.INET6 : StandardProtocolFamily.INET;\n+            return (T) Net.getSocketOption(fd, family, name);\n+        }\n+        return (T) Net.getSocketOption(fd, name);\n+    }\n+\n+    private static class DefaultOptionsHolder {\n+        static final Set<SocketOption<?>> defaultOptions = defaultOptions();\n+\n+        private static Set<SocketOption<?>> defaultOptions() {\n+            HashSet<SocketOption<?>> set = new HashSet<>();\n+            set.add(StandardSocketOptions.SO_SNDBUF);\n+            set.add(StandardSocketOptions.SO_RCVBUF);\n+            set.add(StandardSocketOptions.SO_KEEPALIVE);\n+            set.add(StandardSocketOptions.SO_REUSEADDR);\n+            if (Net.isReusePortAvailable()) {\n+                set.add(StandardSocketOptions.SO_REUSEPORT);\n+            }\n+            set.add(StandardSocketOptions.SO_LINGER);\n+            set.add(StandardSocketOptions.TCP_NODELAY);\n+            \/\/ additional options required by socket adaptor\n+            set.add(StandardSocketOptions.IP_TOS);\n+            set.add(ExtendedSocketOption.SO_OOBINLINE);\n+            set.addAll(ExtendedSocketOptions.clientSocketOptions());\n+            return Collections.unmodifiableSet(set);\n+        }\n+    }\n+\n+    @Override\n+    public final Set<SocketOption<?>> supportedOptions() {\n+        return DefaultOptionsHolder.defaultOptions;\n+    }\n+\n+    \/**\n+     * Read\/write need to be overridden for JFR\n+     *\/\n+    @Override\n+    public int read(ByteBuffer buf) throws IOException {\n+        return super.read(buf);\n+    }\n+\n+    @Override\n+    public long read(ByteBuffer[] dsts, int offset, int length)\n+        throws IOException\n+    {\n+        return super.read(dsts, offset, length);\n+    }\n+\n+    @Override\n+    public int write(ByteBuffer buf) throws IOException {\n+        return super.write(buf);\n+    }\n+\n+    @Override\n+    public long write(ByteBuffer[] srcs, int offset, int length)\n+        throws IOException\n+    {\n+        return super.write(srcs, offset, length);\n+    }\n+\n+    \/**\n+     * Returns the local address, or null if not bound\n+     *\/\n+    @Override\n+    InetSocketAddress localAddress() {\n+        return (InetSocketAddress)super.localAddress();\n+    }\n+\n+    \/**\n+     * Returns the remote address, or null if not connected\n+     *\/\n+    @Override\n+    InetSocketAddress remoteAddress() {\n+        return (InetSocketAddress)super.remoteAddress();\n+    }\n+\n+    @Override\n+    SocketAddress implBind(SocketAddress local) throws IOException {\n+        InetSocketAddress isa;\n+        if (local == null) {\n+            isa = new InetSocketAddress(Net.anyLocalAddress(family), 0);\n+        } else {\n+            isa = Net.checkAddress(local, family);\n+        }\n+        SecurityManager sm = System.getSecurityManager();\n+        if (sm != null) {\n+            sm.checkListen(isa.getPort());\n+        }\n+        FileDescriptor fd = getFD();\n+        NetHooks.beforeTcpBind(fd, isa.getAddress(), isa.getPort());\n+        Net.bind(family, fd, isa.getAddress(), isa.getPort());\n+        return Net.localAddress(fd);\n+    }\n+\n+    \/**\n+     * Checks the remote address to which this channel is to be connected.\n+     *\/\n+    @Override\n+    protected InetSocketAddress checkRemote(SocketAddress sa) throws IOException {\n+        InetSocketAddress isa = Net.checkAddress(sa, family);\n+        SecurityManager sm = System.getSecurityManager();\n+        if (sm != null) {\n+            sm.checkConnect(isa.getAddress().getHostAddress(), isa.getPort());\n+        }\n+        InetAddress address = isa.getAddress();\n+        if (address.isAnyLocalAddress()) {\n+            int port = isa.getPort();\n+            if (address instanceof Inet4Address) {\n+                return new InetSocketAddress(Net.inet4LoopbackAddress(), port);\n+            } else {\n+                assert family == StandardProtocolFamily.INET6;\n+                return new InetSocketAddress(Net.inet6LoopbackAddress(), port);\n+            }\n+        } else {\n+            return isa;\n+        }\n+    }\n+\n+    @Override\n+    protected int implConnect(FileDescriptor fd, SocketAddress sa) throws IOException {\n+        InetSocketAddress isa = (InetSocketAddress)sa;\n+        return Net.connect(family, fd, isa.getAddress(), isa.getPort());\n+    }\n+\n+    @Override\n+    protected String getRevealedLocalAddressAsString(SocketAddress sa) {\n+        InetSocketAddress isa = (InetSocketAddress)sa;\n+        return Net.getRevealedLocalAddressAsString(isa);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/InetSocketChannelImpl.java","additions":261,"deletions":0,"binary":false,"changes":261,"status":"added"},{"patch":"@@ -502,0 +502,1 @@\n+\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/Net.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-            return new SocketChannelImpl(provider(), fd, false);\n+            return new InetSocketChannelImpl(provider(), fd, false);\n@@ -58,1 +58,1 @@\n-            return new ServerSocketChannelImpl(provider(), fd, false);\n+            return new InetServerSocketChannelImpl(provider(), fd, false);\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/Secrets.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import java.net.StandardProtocolFamily;\n@@ -36,0 +37,1 @@\n+import java.util.Objects;\n@@ -68,1 +70,1 @@\n-        return new ServerSocketChannelImpl(this);\n+        return new InetServerSocketChannelImpl(this);\n@@ -73,1 +75,1 @@\n-        return new SocketChannelImpl(this);\n+        return new InetSocketChannelImpl(this);\n@@ -78,1 +80,11 @@\n-        return new SocketChannelImpl(this, family);\n+        Objects.requireNonNull(family, \"'family' is null\");\n+        if (family == StandardProtocolFamily.INET6 && !Net.isIPv6Available()) {\n+            throw new UnsupportedOperationException(\"IPv6 not available\");\n+        } else if (family == StandardProtocolFamily.INET ||\n+                   family == StandardProtocolFamily.INET6)  {\n+            return new InetSocketChannelImpl(this, family);\n+        } else if (family == StandardProtocolFamily.UNIX &&\n+                   UnixDomainSockets.isSupported()) {\n+            return new UnixDomainSocketChannelImpl(this, UnixDomainSockets.socket(), false);\n+        } else\n+            return super.openSocketChannel(family);\n@@ -82,2 +94,12 @@\n-    public ServerSocketChannel openServerSocketChannel(ProtocolFamily family) {\n-        return new ServerSocketChannelImpl(this, family);\n+    public ServerSocketChannel openServerSocketChannel(ProtocolFamily family) throws IOException {\n+        Objects.requireNonNull(family, \"'family' is null\");\n+        if (family == StandardProtocolFamily.INET6 && !Net.isIPv6Available()) {\n+            throw new UnsupportedOperationException(\"IPv6 not available\");\n+        } else if (family == StandardProtocolFamily.INET ||\n+                   family == StandardProtocolFamily.INET6)  {\n+            return new InetServerSocketChannelImpl(this, family);\n+        } else if (family == StandardProtocolFamily.UNIX &&\n+                   UnixDomainSockets.isSupported()) {\n+            return new UnixDomainServerSocketChannelImpl(this);\n+        } else\n+            return super.openServerSocketChannel(family);\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/SelectorProviderImpl.java","additions":27,"deletions":5,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-    private final ServerSocketChannelImpl ssc;\n+    private final InetServerSocketChannelImpl ssc;\n@@ -64,1 +64,1 @@\n-    static ServerSocket create(ServerSocketChannelImpl ssc) {\n+    static ServerSocket create(InetServerSocketChannelImpl ssc) {\n@@ -73,1 +73,1 @@\n-    private ServerSocketAdaptor(ServerSocketChannelImpl ssc) {\n+    private ServerSocketAdaptor(InetServerSocketChannelImpl ssc) {\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/ServerSocketAdaptor.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -30,2 +30,0 @@\n-import java.net.InetSocketAddress;\n-import java.net.ProtocolFamily;\n@@ -36,2 +34,0 @@\n-import java.net.StandardProtocolFamily;\n-import java.net.StandardSocketOptions;\n@@ -47,2 +43,0 @@\n-import java.util.Collections;\n-import java.util.HashSet;\n@@ -50,1 +44,0 @@\n-import java.util.Set;\n@@ -53,3 +46,0 @@\n-import sun.net.NetHooks;\n-import sun.net.ext.ExtendedSocketOptions;\n-\n@@ -60,1 +50,1 @@\n-class ServerSocketChannelImpl\n+abstract class ServerSocketChannelImpl\n@@ -67,3 +57,0 @@\n-    \/\/ The protocol family of the socket\n-    private final ProtocolFamily family;\n-\n@@ -93,4 +80,1 @@\n-    private InetSocketAddress localAddress; \/\/ null => unbound\n-\n-    \/\/ set true when exclusive binding is on and SO_REUSEADDR is emulated\n-    private boolean isReuseAddress;\n+    private SocketAddress localAddress; \/\/ null => unbound\n@@ -103,23 +87,0 @@\n-    ServerSocketChannelImpl(SelectorProvider sp) {\n-        this(sp, Net.isIPv6Available()\n-                ? StandardProtocolFamily.INET6\n-                : StandardProtocolFamily.INET);\n-    }\n-\n-    ServerSocketChannelImpl(SelectorProvider sp, ProtocolFamily family) {\n-        super(sp);\n-        Objects.requireNonNull(family, \"'family' is null\");\n-\n-        if ((family != StandardProtocolFamily.INET) &&\n-                (family != StandardProtocolFamily.INET6)) {\n-            throw new UnsupportedOperationException(\"Protocol family not supported\");\n-        }\n-        if (family == StandardProtocolFamily.INET6 && !Net.isIPv6Available()) {\n-            throw new UnsupportedOperationException(\"IPv6 not available\");\n-        }\n-\n-        this.family = family;\n-        this.fd = Net.serverSocket(family, true);\n-        this.fdVal = IOUtil.fdVal(fd);\n-    }\n-\n@@ -130,4 +91,0 @@\n-\n-        this.family = Net.isIPv6Available()\n-                ? StandardProtocolFamily.INET6\n-                : StandardProtocolFamily.INET;\n@@ -139,1 +96,1 @@\n-                localAddress = Net.localAddress(fd);\n+                localAddress = implLocalAddress(fd);\n@@ -154,1 +111,1 @@\n-                socket = ServerSocketAdaptor.create(this);\n+                socket = ServerSocketAdaptor.create((InetServerSocketChannelImpl)this);\n@@ -164,2 +121,17 @@\n-                    ? null\n-                    : Net.getRevealedLocalAddress(localAddress);\n+                ? null\n+                : getRevealedLocalAddress(localAddress);\n+        }\n+    }\n+\n+    abstract SocketAddress implLocalAddress(FileDescriptor fd) throws IOException;\n+\n+    abstract SocketAddress getRevealedLocalAddress(SocketAddress addr);\n+\n+    abstract String getRevealedLocalAddressAsString(SocketAddress addr);\n+\n+    \/**\n+     * Returns the local address, or null if not bound\n+     *\/\n+    SocketAddress localAddress() {\n+        synchronized (stateLock) {\n+            return localAddress;\n@@ -181,8 +153,1 @@\n-\n-            if (name == StandardSocketOptions.SO_REUSEADDR && Net.useExclusiveBind()) {\n-                \/\/ SO_REUSEADDR emulated when using exclusive bind\n-                isReuseAddress = (Boolean)value;\n-            } else {\n-                \/\/ no options that require special handling\n-                Net.setSocketOption(fd, Net.UNSPEC, name, value);\n-            }\n+            implSetOption(name, value);\n@@ -193,0 +158,2 @@\n+    abstract <T> void implSetOption(SocketOption<T> name, T value) throws IOException;\n+\n@@ -204,6 +171,1 @@\n-            if (name == StandardSocketOptions.SO_REUSEADDR && Net.useExclusiveBind()) {\n-                \/\/ SO_REUSEADDR emulated when using exclusive bind\n-                return (T)Boolean.valueOf(isReuseAddress);\n-            }\n-            \/\/ no options that require special handling\n-            return (T) Net.getSocketOption(fd, Net.UNSPEC, name);\n+            return implGetOption(name);\n@@ -213,19 +175,1 @@\n-    private static class DefaultOptionsHolder {\n-        static final Set<SocketOption<?>> defaultOptions = defaultOptions();\n-\n-        private static Set<SocketOption<?>> defaultOptions() {\n-            HashSet<SocketOption<?>> set = new HashSet<>();\n-            set.add(StandardSocketOptions.SO_RCVBUF);\n-            set.add(StandardSocketOptions.SO_REUSEADDR);\n-            if (Net.isReusePortAvailable()) {\n-                set.add(StandardSocketOptions.SO_REUSEPORT);\n-            }\n-            set.addAll(ExtendedSocketOptions.serverSocketOptions());\n-            return Collections.unmodifiableSet(set);\n-        }\n-    }\n-\n-    @Override\n-    public final Set<SocketOption<?>> supportedOptions() {\n-        return DefaultOptionsHolder.defaultOptions;\n-    }\n+    abstract <T> T implGetOption(SocketOption<T> name) throws IOException;\n@@ -239,13 +183,1 @@\n-            InetSocketAddress isa;\n-            if (local == null) {\n-                isa = new InetSocketAddress(Net.anyLocalAddress(family), 0);\n-            } else {\n-                isa = Net.checkAddress(local, family);\n-            }\n-            SecurityManager sm = System.getSecurityManager();\n-            if (sm != null)\n-                sm.checkListen(isa.getPort());\n-            NetHooks.beforeTcpBind(fd, isa.getAddress(), isa.getPort());\n-            Net.bind(family, fd, isa.getAddress(), isa.getPort());\n-            Net.listen(fd, backlog < 1 ? 50 : backlog);\n-            localAddress = Net.localAddress(fd);\n+            localAddress = implBind(local, backlog);\n@@ -256,0 +188,2 @@\n+    abstract SocketAddress implBind(SocketAddress local, int backlog) throws IOException;\n+\n@@ -298,1 +232,1 @@\n-        InetSocketAddress[] isaa = new InetSocketAddress[1];\n+        SocketAddress[] isaa = new SocketAddress[1];\n@@ -305,1 +239,1 @@\n-                n = Net.accept(this.fd, newfd, isaa);\n+                n = implAccept(this.fd, newfd, isaa);\n@@ -309,1 +243,1 @@\n-                        n = Net.accept(this.fd, newfd, isaa);\n+                        n = implAccept(this.fd, newfd, isaa);\n@@ -327,0 +261,4 @@\n+    protected abstract int implAccept(FileDescriptor fd, FileDescriptor newfd, SocketAddress[] sa)\n+        throws IOException;\n+\n+\n@@ -340,1 +278,1 @@\n-        InetSocketAddress[] isaa = new InetSocketAddress[1];\n+        SocketAddress[] isaa = new SocketAddress[1];\n@@ -354,1 +292,1 @@\n-                    n = Net.accept(fd, newfd, isaa);\n+                    n = implAccept(fd, newfd, isaa);\n@@ -361,1 +299,1 @@\n-                        n = Net.accept(fd, newfd, isaa);\n+                        n = implAccept(fd, newfd, isaa);\n@@ -378,1 +316,1 @@\n-    private SocketChannel finishAccept(FileDescriptor newfd, InetSocketAddress isa)\n+    private SocketChannel finishAccept(FileDescriptor newfd, SocketAddress sa)\n@@ -384,7 +322,1 @@\n-\n-            \/\/ check permitted to accept connections from the remote address\n-            SecurityManager sm = System.getSecurityManager();\n-            if (sm != null) {\n-                sm.checkAccept(isa.getAddress().getHostAddress(), isa.getPort());\n-            }\n-            return new SocketChannelImpl(provider(), family, newfd, isa);\n+            return implFinishAccept(newfd, sa);\n@@ -397,0 +329,3 @@\n+    abstract SocketChannel implFinishAccept(FileDescriptor newfd, SocketAddress isa)\n+        throws IOException;\n+\n@@ -536,9 +471,0 @@\n-    \/**\n-     * Returns the local address, or null if not bound\n-     *\/\n-    InetSocketAddress localAddress() {\n-        synchronized (stateLock) {\n-            return localAddress;\n-        }\n-    }\n-\n@@ -608,1 +534,1 @@\n-                InetSocketAddress addr = localAddress;\n+                SocketAddress addr = localAddress;\n@@ -612,1 +538,1 @@\n-                    sb.append(Net.getRevealedLocalAddressAsString(addr));\n+                    sb.append(getRevealedLocalAddressAsString(addr));\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/ServerSocketChannelImpl.java","additions":46,"deletions":120,"binary":false,"changes":166,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-    private final SocketChannelImpl sc;\n+    private final InetSocketChannelImpl sc;\n@@ -61,1 +61,1 @@\n-    private SocketAdaptor(SocketChannelImpl sc) throws SocketException {\n+    private SocketAdaptor(InetSocketChannelImpl sc) throws SocketException {\n@@ -66,1 +66,1 @@\n-    static Socket create(SocketChannelImpl sc) {\n+    static Socket create(InetSocketChannelImpl sc) {\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/SocketAdaptor.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -30,2 +30,0 @@\n-import java.net.InetAddress;\n-import java.net.Inet4Address;\n@@ -33,1 +31,0 @@\n-import java.net.ProtocolFamily;\n@@ -39,1 +36,0 @@\n-import java.net.StandardProtocolFamily;\n@@ -53,2 +49,0 @@\n-import java.util.Collections;\n-import java.util.HashSet;\n@@ -56,1 +50,0 @@\n-import java.util.Set;\n@@ -61,1 +54,0 @@\n-import sun.net.ext.ExtendedSocketOptions;\n@@ -68,1 +60,1 @@\n-class SocketChannelImpl\n+abstract class SocketChannelImpl\n@@ -75,3 +67,0 @@\n-    \/\/ The protocol family of the socket\n-    private final ProtocolFamily family;\n-\n@@ -101,3 +90,0 @@\n-    \/\/ set true when exclusive binding is on and SO_REUSEADDR is emulated\n-    private boolean isReuseAddress;\n-\n@@ -117,2 +103,2 @@\n-    private InetSocketAddress localAddress;\n-    private InetSocketAddress remoteAddress;\n+    private SocketAddress localAddress;\n+    private SocketAddress remoteAddress;\n@@ -128,6 +114,0 @@\n-        this(sp, Net.isIPv6Available()\n-                ? StandardProtocolFamily.INET6\n-                : StandardProtocolFamily.INET);\n-    }\n-\n-    SocketChannelImpl(SelectorProvider sp, ProtocolFamily family) throws IOException {\n@@ -135,10 +115,1 @@\n-        Objects.requireNonNull(family, \"'family' is null\");\n-        if ((family != StandardProtocolFamily.INET) &&\n-                (family != StandardProtocolFamily.INET6)) {\n-            throw new UnsupportedOperationException(\"Protocol family not supported\");\n-        }\n-        if (family == StandardProtocolFamily.INET6 && !Net.isIPv6Available()) {\n-            throw new UnsupportedOperationException(\"IPv6 not available\");\n-        }\n-        this.family = family;\n-        this.fd = Net.socket(family, true);\n+        this.fd = Net.socket(true);\n@@ -152,3 +123,0 @@\n-        this.family = Net.isIPv6Available()\n-                ? StandardProtocolFamily.INET6\n-                : StandardProtocolFamily.INET;\n@@ -157,1 +125,0 @@\n-\n@@ -160,1 +127,1 @@\n-                this.localAddress = Net.localAddress(fd);\n+                this.localAddress = implLocalAddress(fd);\n@@ -167,4 +134,1 @@\n-    SocketChannelImpl(SelectorProvider sp,\n-                      ProtocolFamily family,\n-                      FileDescriptor fd,\n-                      InetSocketAddress isa)\n+    SocketChannelImpl(SelectorProvider sp, FileDescriptor fd, SocketAddress isa)\n@@ -174,1 +138,0 @@\n-        this.family = family;\n@@ -178,1 +141,1 @@\n-            this.localAddress = Net.localAddress(fd);\n+            this.localAddress = implLocalAddress(fd);\n@@ -219,1 +182,1 @@\n-                socket = SocketAdaptor.create(this);\n+                socket = SocketAdaptor.create((InetSocketChannelImpl)this);\n@@ -228,1 +191,1 @@\n-            return Net.getRevealedLocalAddress(localAddress);\n+            return getRevealedLocalAddress(localAddress);\n@@ -232,0 +195,4 @@\n+    abstract SocketAddress implLocalAddress(FileDescriptor fd) throws IOException;\n+\n+    abstract SocketAddress getRevealedLocalAddress(SocketAddress address);\n+\n@@ -252,14 +219,1 @@\n-\n-            if (name == StandardSocketOptions.IP_TOS) {\n-                Net.setSocketOption(fd, family, name, value);\n-                return this;\n-            }\n-\n-            if (name == StandardSocketOptions.SO_REUSEADDR && Net.useExclusiveBind()) {\n-                \/\/ SO_REUSEADDR emulated when using exclusive bind\n-                isReuseAddress = (Boolean)value;\n-                return this;\n-            }\n-\n-            \/\/ no options that require special handling\n-            Net.setSocketOption(fd, name, value);\n+            implSetOption(name, value);\n@@ -270,0 +224,2 @@\n+    abstract <T> void implSetOption(SocketOption<T> name, T value) throws IOException;\n+\n@@ -281,35 +237,1 @@\n-\n-            if (name == StandardSocketOptions.SO_REUSEADDR && Net.useExclusiveBind()) {\n-                \/\/ SO_REUSEADDR emulated when using exclusive bind\n-                return (T)Boolean.valueOf(isReuseAddress);\n-            }\n-\n-            \/\/ special handling for IP_TOS\n-            if (name == StandardSocketOptions.IP_TOS) {\n-                return (T) Net.getSocketOption(fd, family, name);\n-            }\n-\n-            \/\/ no options that require special handling\n-            return (T) Net.getSocketOption(fd, name);\n-        }\n-    }\n-\n-    private static class DefaultOptionsHolder {\n-        static final Set<SocketOption<?>> defaultOptions = defaultOptions();\n-\n-        private static Set<SocketOption<?>> defaultOptions() {\n-            HashSet<SocketOption<?>> set = new HashSet<>();\n-            set.add(StandardSocketOptions.SO_SNDBUF);\n-            set.add(StandardSocketOptions.SO_RCVBUF);\n-            set.add(StandardSocketOptions.SO_KEEPALIVE);\n-            set.add(StandardSocketOptions.SO_REUSEADDR);\n-            if (Net.isReusePortAvailable()) {\n-                set.add(StandardSocketOptions.SO_REUSEPORT);\n-            }\n-            set.add(StandardSocketOptions.SO_LINGER);\n-            set.add(StandardSocketOptions.TCP_NODELAY);\n-            \/\/ additional options required by socket adaptor\n-            set.add(StandardSocketOptions.IP_TOS);\n-            set.add(ExtendedSocketOption.SO_OOBINLINE);\n-            set.addAll(ExtendedSocketOptions.clientSocketOptions());\n-            return Collections.unmodifiableSet(set);\n+            return implGetOption(name);\n@@ -319,4 +241,1 @@\n-    @Override\n-    public final Set<SocketOption<?>> supportedOptions() {\n-        return DefaultOptionsHolder.defaultOptions;\n-    }\n+    abstract <T> T implGetOption(SocketOption<T> name) throws IOException;\n@@ -628,1 +547,1 @@\n-    InetSocketAddress localAddress() {\n+    SocketAddress localAddress() {\n@@ -637,1 +556,1 @@\n-    InetSocketAddress remoteAddress() {\n+    SocketAddress remoteAddress() {\n@@ -655,13 +574,1 @@\n-                    InetSocketAddress isa;\n-                    if (local == null) {\n-                        isa = new InetSocketAddress(Net.anyLocalAddress(family), 0);\n-                    } else {\n-                        isa = Net.checkAddress(local, family);\n-                    }\n-                    SecurityManager sm = System.getSecurityManager();\n-                    if (sm != null) {\n-                        sm.checkListen(isa.getPort());\n-                    }\n-                    NetHooks.beforeTcpBind(fd, isa.getAddress(), isa.getPort());\n-                    Net.bind(family, fd, isa.getAddress(), isa.getPort());\n-                    localAddress = Net.localAddress(fd);\n+                    localAddress = implBind(local);\n@@ -678,0 +585,2 @@\n+    abstract SocketAddress implBind(SocketAddress local) throws IOException;\n+\n@@ -697,1 +606,1 @@\n-    private void beginConnect(boolean blocking, InetSocketAddress isa)\n+    private void beginConnect(boolean blocking, SocketAddress sa)\n@@ -714,1 +623,2 @@\n-            if (localAddress == null)\n+            if (localAddress == null && sa instanceof InetSocketAddress) {\n+                InetSocketAddress isa = (InetSocketAddress)sa;\n@@ -716,1 +626,2 @@\n-            remoteAddress = isa;\n+            }\n+            remoteAddress = sa;\n@@ -740,1 +651,1 @@\n-                    localAddress = Net.localAddress(fd);\n+                    localAddress = implLocalAddress(fd);\n@@ -750,19 +661,1 @@\n-    private InetSocketAddress checkRemote(SocketAddress sa) {\n-        InetSocketAddress isa = Net.checkAddress(sa, family);\n-        SecurityManager sm = System.getSecurityManager();\n-        if (sm != null) {\n-            sm.checkConnect(isa.getAddress().getHostAddress(), isa.getPort());\n-        }\n-        InetAddress address = isa.getAddress();\n-        if (address.isAnyLocalAddress()) {\n-            int port = isa.getPort();\n-            if (address instanceof Inet4Address) {\n-                return new InetSocketAddress(Net.inet4LoopbackAddress(), port);\n-            } else {\n-                assert family == StandardProtocolFamily.INET6;\n-                return new InetSocketAddress(Net.inet6LoopbackAddress(), port);\n-            }\n-        } else {\n-            return isa;\n-        }\n-    }\n+    abstract SocketAddress checkRemote(SocketAddress sa) throws IOException;\n@@ -772,1 +665,1 @@\n-        InetSocketAddress isa = checkRemote(remote);\n+        SocketAddress sa = checkRemote(remote);\n@@ -781,5 +674,2 @@\n-                        beginConnect(blocking, isa);\n-                        int n = Net.connect(family,\n-                                            fd,\n-                                            isa.getAddress(),\n-                                            isa.getPort());\n+                        beginConnect(blocking, sa);\n+                        int n = implConnect(fd, sa);\n@@ -810,1 +700,1 @@\n-            throw SocketExceptions.of(ioe, isa);\n+            throw SocketExceptions.of(ioe, sa);\n@@ -814,0 +704,2 @@\n+    abstract int implConnect(FileDescriptor fd,SocketAddress sa) throws IOException;\n+\n@@ -851,1 +743,1 @@\n-                    localAddress = Net.localAddress(fd);\n+                    localAddress = implLocalAddress(fd);\n@@ -1090,1 +982,1 @@\n-        InetSocketAddress isa = checkRemote(remote);\n+        SocketAddress sa = checkRemote(remote);\n@@ -1100,1 +992,1 @@\n-                        beginConnect(true, isa);\n+                        beginConnect(true, sa);\n@@ -1104,1 +996,1 @@\n-                            int n = Net.connect(fd, isa.getAddress(), isa.getPort());\n+                            int n = implConnect(fd, sa);\n@@ -1122,1 +1014,1 @@\n-            throw SocketExceptions.of(ioe, isa);\n+            throw SocketExceptions.of(ioe, sa);\n@@ -1369,0 +1261,2 @@\n+    abstract String getRevealedLocalAddressAsString(SocketAddress sa);\n+\n@@ -1372,1 +1266,1 @@\n-        sb.append(this.getClass().getSuperclass().getName());\n+        sb.append(this.getClass().getName());\n@@ -1393,1 +1287,1 @@\n-                InetSocketAddress addr = localAddress();\n+                SocketAddress addr = localAddress();\n@@ -1396,1 +1290,1 @@\n-                    sb.append(Net.getRevealedLocalAddressAsString(addr));\n+                    sb.append(getRevealedLocalAddressAsString(addr));\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/SocketChannelImpl.java","additions":46,"deletions":152,"binary":false,"changes":198,"status":"modified"},{"patch":"@@ -0,0 +1,199 @@\n+\/*\n+ * Copyright (c) 2000, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.nio.ch;\n+\n+import java.io.FileDescriptor;\n+import java.io.IOException;\n+import java.net.BindException;\n+import java.net.ServerSocket;\n+import java.net.SocketAddress;\n+import java.net.SocketOption;\n+import java.net.StandardSocketOptions;\n+import java.net.UnixDomainSocketAddress;\n+import java.nio.channels.SocketChannel;\n+import java.nio.channels.spi.SelectorProvider;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.SecureRandom;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Random;\n+import java.util.Set;\n+\n+\/**\n+ * An implementation of ServerSocketChannels\n+ *\/\n+\n+public class UnixDomainServerSocketChannelImpl\n+    extends ServerSocketChannelImpl\n+{\n+    public UnixDomainServerSocketChannelImpl(SelectorProvider sp) throws IOException {\n+        super(sp, UnixDomainSockets.socket(), false);\n+    }\n+\n+    public UnixDomainServerSocketChannelImpl(SelectorProvider sp, FileDescriptor fd, boolean bound)\n+        throws IOException\n+    {\n+        super(sp, fd, bound);\n+    }\n+\n+    @Override\n+    SocketAddress implLocalAddress(FileDescriptor fd) throws IOException {\n+        return UnixDomainSockets.localAddress(fd);\n+    }\n+\n+    @Override\n+    SocketAddress getRevealedLocalAddress(SocketAddress addr) {\n+        return UnixDomainSockets.getRevealedLocalAddress((UnixDomainSocketAddress)addr);\n+    }\n+\n+    @Override\n+    String getRevealedLocalAddressAsString(SocketAddress addr) {\n+        return UnixDomainSockets.getRevealedLocalAddressAsString((UnixDomainSocketAddress)addr);\n+    }\n+\n+    @Override\n+    public ServerSocket socket() {\n+        throw new UnsupportedOperationException(\"socket not supported\");\n+    }\n+\n+    @Override\n+    <T> void implSetOption(SocketOption<T> name, T value) throws IOException {\n+        Net.setSocketOption(getFD(), Net.UNSPEC, name, value);\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    <T> T implGetOption(SocketOption<T> name) throws IOException {\n+        return (T) Net.getSocketOption(getFD(), Net.UNSPEC, name);\n+    }\n+\n+    private static class DefaultOptionsHolder {\n+        static final Set<SocketOption<?>> defaultOptions = defaultOptions();\n+\n+        private static Set<SocketOption<?>> defaultOptions() {\n+            HashSet<SocketOption<?>> set = new HashSet<>();\n+            set.add(StandardSocketOptions.SO_RCVBUF);\n+            return Collections.unmodifiableSet(set);\n+        }\n+    }\n+\n+    @Override\n+    public final Set<SocketOption<?>> supportedOptions() {\n+        return DefaultOptionsHolder.defaultOptions;\n+    }\n+\n+    @Override\n+    public SocketAddress implBind(SocketAddress local, int backlog) throws IOException {\n+        boolean found = false;\n+\n+        UnixDomainSockets.checkCapability();\n+\n+        \/\/ Attempt up to 10 times to find an unused name in temp directory\n+        \/\/ Unlikely to fail\n+        for (int i = 0; i < 10; i++) {\n+            UnixDomainSocketAddress usa = null;\n+            if (local == null) {\n+                usa = getTempName();\n+            } else {\n+                usa = UnixDomainSockets.checkAddress(local);\n+            }\n+            try {\n+                UnixDomainSockets.bind(getFD(), usa.getPath());\n+                found = true;\n+                break;\n+            } catch (BindException e) {\n+                if (local != null) {\n+                    throw e;\n+                }\n+            }\n+        }\n+        if (!found)\n+            throw new IOException(\"could not bind to temporary name\");\n+        Net.listen(getFD(), backlog < 1 ? 50 : backlog);\n+        return UnixDomainSockets.localAddress(getFD());\n+    }\n+\n+    private static Random getRandom() {\n+        try {\n+            return SecureRandom.getInstance(\"NativePRNGNonBlocking\");\n+        } catch (NoSuchAlgorithmException e) {\n+            return new SecureRandom(); \/\/ This should not fail\n+        }\n+    }\n+\n+    private static final Random random = getRandom();;\n+\n+    \/**\n+     * Return a possible temporary name to bind to, which is different for each call\n+     * Name is of the form <temp dir>\/niosocket_<pid>_<random>\n+     *\/\n+    private static UnixDomainSocketAddress getTempName() throws IOException {\n+        int rnd = random.nextInt(Integer.MAX_VALUE);\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(UnixDomainSockets.tempDir).append(\"\/niosocket_\").append(rnd);\n+        return UnixDomainSocketAddress.of(sb.toString());\n+    }\n+\n+    @Override\n+    protected int implAccept(FileDescriptor fd, FileDescriptor newfd, SocketAddress[] addrs)\n+        throws IOException\n+    {\n+        UnixDomainSockets.checkCapability();\n+        String[] addrArray = new String[1];\n+        int n = UnixDomainSockets.accept(fd, newfd, addrArray);\n+        if (n > 0) {\n+            addrs[0] = UnixDomainSocketAddress.of(addrArray[0]);\n+        }\n+        return n;\n+    }\n+\n+    @Override\n+    SocketChannel implFinishAccept(FileDescriptor newfd, SocketAddress sa)\n+        throws IOException\n+    {\n+        UnixDomainSocketAddress usa = (UnixDomainSocketAddress)sa;\n+        return new UnixDomainSocketChannelImpl(provider(), newfd, usa);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(this.getClass().getName());\n+        sb.append('[');\n+        if (!isOpen()) {\n+            sb.append(\"closed\");\n+        } else {\n+            UnixDomainSocketAddress addr = (UnixDomainSocketAddress) localAddress();\n+            if (addr == null) { \/\/ TODO: ???\n+                sb.append(\"unbound\");\n+            } else {\n+                sb.append(getRevealedLocalAddressAsString(addr));\n+            }\n+        }\n+        sb.append(']');\n+        return sb.toString();\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/UnixDomainServerSocketChannelImpl.java","additions":199,"deletions":0,"binary":false,"changes":199,"status":"added"},{"patch":"@@ -0,0 +1,170 @@\n+\/*\n+ * Copyright (c) 2000, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.nio.ch;\n+\n+import java.io.FileDescriptor;\n+import java.io.IOException;\n+import java.net.Socket;\n+import java.net.SocketAddress;\n+import java.net.SocketOption;\n+import java.net.StandardSocketOptions;\n+import java.net.UnixDomainSocketAddress;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.spi.SelectorProvider;\n+import java.nio.file.Path;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Objects;\n+import java.util.Set;\n+import sun.net.ext.ExtendedSocketOptions;\n+\n+\/**\n+ * An implementation of SocketChannels\n+ *\/\n+\n+public class UnixDomainSocketChannelImpl extends SocketChannelImpl\n+{\n+    UnixDomainSocketChannelImpl(SelectorProvider sp, FileDescriptor fd, boolean bound)\n+        throws IOException\n+    {\n+        super(sp, fd, bound);\n+    }\n+\n+    \/\/ Constructor for sockets obtained from server sockets\n+    \/\/\n+    UnixDomainSocketChannelImpl(SelectorProvider sp, FileDescriptor fd, SocketAddress isa)\n+        throws IOException\n+    {\n+        super(sp, fd, isa);\n+    }\n+\n+    @Override\n+    SocketAddress implLocalAddress(FileDescriptor fd) throws IOException {\n+        return UnixDomainSockets.localAddress(fd);\n+    }\n+\n+    @Override\n+    SocketAddress getRevealedLocalAddress(SocketAddress address) {\n+        UnixDomainSocketAddress uaddr = (UnixDomainSocketAddress)address;\n+        return UnixDomainSockets.getRevealedLocalAddress(uaddr);\n+    }\n+\n+    @Override\n+    <T> void implSetOption(SocketOption<T> name, T value) throws IOException {\n+        Net.setSocketOption(getFD(), name, value);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    <T> T implGetOption(SocketOption<T> name) throws IOException {\n+        return (T) Net.getSocketOption(getFD(), name);\n+    }\n+\n+    private static class DefaultOptionsHolder {\n+        static final Set<SocketOption<?>> defaultOptions = defaultOptions();\n+\n+        private static Set<SocketOption<?>> defaultOptions() {\n+            HashSet<SocketOption<?>> set = new HashSet<>();\n+            set.add(StandardSocketOptions.SO_SNDBUF);\n+            set.add(StandardSocketOptions.SO_RCVBUF);\n+            set.add(StandardSocketOptions.SO_LINGER);\n+            set.addAll(ExtendedSocketOptions.unixSocketOptions());\n+            return Collections.unmodifiableSet(set);\n+        }\n+    }\n+\n+    @Override\n+    public final Set<SocketOption<?>> supportedOptions() {\n+        return DefaultOptionsHolder.defaultOptions;\n+    }\n+\n+    @Override\n+    public Socket socket() {\n+        throw new UnsupportedOperationException(\"socket not supported\");\n+    }\n+\n+    \/**\n+     * Read\/write need to be overridden for JFR\n+     *\/\n+    @Override\n+    public int read(ByteBuffer buf) throws IOException {\n+        return super.read(buf);\n+    }\n+\n+    @Override\n+    public long read(ByteBuffer[] dsts, int offset, int length)\n+        throws IOException\n+    {\n+        return super.read(dsts, offset, length);\n+    }\n+\n+    @Override\n+    public int write(ByteBuffer buf) throws IOException {\n+        return super.write(buf);\n+    }\n+\n+    @Override\n+    public long write(ByteBuffer[] srcs, int offset, int length)\n+        throws IOException\n+    {\n+        return super.write(srcs, offset, length);\n+    }\n+\n+    @Override\n+    SocketAddress implBind(SocketAddress local) throws IOException {\n+        UnixDomainSockets.checkCapability();\n+        UnixDomainSocketAddress usa = UnixDomainSockets.checkAddress(local);\n+        Path path = usa == null ? null : usa.getPath();\n+        UnixDomainSockets.bind(getFD(), path);\n+        if (usa == null || path.toString().equals(\"\")) {\n+            return UnixDomainSockets.UNNAMED;\n+        } else {\n+            return UnixDomainSockets.localAddress(getFD());\n+        }\n+    }\n+\n+    \/**\n+     * Checks the permissions required for connect\n+     *\/\n+    @Override\n+    SocketAddress checkRemote(SocketAddress sa) throws IOException {\n+        Objects.requireNonNull(sa);\n+        UnixDomainSockets.checkCapability();\n+        UnixDomainSocketAddress usa = UnixDomainSockets.checkAddress(sa);\n+        return usa;\n+    }\n+\n+    @Override\n+    int implConnect(FileDescriptor fd, SocketAddress sa) throws IOException {\n+        UnixDomainSocketAddress usa = (UnixDomainSocketAddress)sa;\n+        return UnixDomainSockets.connect(fd, usa.getPath());\n+    }\n+\n+    String getRevealedLocalAddressAsString(SocketAddress sa) {\n+        UnixDomainSocketAddress usa = (UnixDomainSocketAddress)sa;\n+        return UnixDomainSockets.getRevealedLocalAddressAsString(usa);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/UnixDomainSocketChannelImpl.java","additions":170,"deletions":0,"binary":false,"changes":170,"status":"added"},{"patch":"@@ -0,0 +1,185 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.nio.ch;\n+\n+import java.io.FileDescriptor;\n+import java.io.IOException;\n+import java.net.NetPermission;\n+import java.net.SocketAddress;\n+import java.net.UnixDomainSocketAddress;\n+import java.nio.channels.UnsupportedAddressTypeException;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Path;\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n+\n+import sun.nio.fs.AbstractFileSystemProvider;\n+\n+class UnixDomainSockets {\n+\n+    static {\n+        \/\/ Load all required native libs\n+        IOUtil.load();\n+    }\n+\n+    static void init() {}\n+\n+    static final UnixDomainSocketAddress UNNAMED\n+        = UnixDomainSocketAddress.of(\"\");;\n+\n+    private static final boolean supported =\n+        socketSupported();\n+\n+    static {\n+        PrivilegedAction<Void> pa = () -> {\n+            \/\/ -1 if unsupported or +ve integer otherwise. Prop set after Net initialization\n+            \/\/ Undocumented. Just use for testing\n+            System.setProperty(\"jdk.nio.channels.unixdomain.maxnamelength\",\n+                               Integer.toString(maxNameLen()));\n+            return null;\n+        };\n+        AccessController.doPrivileged(pa);\n+    }\n+\n+    private static final NetPermission np = new NetPermission(\"accessUnixDomainSocket\");\n+\n+    static void checkCapability() {\n+        SecurityManager sm = System.getSecurityManager();\n+        if (sm == null)\n+            return;\n+        sm.checkPermission(np);\n+    }\n+\n+    static UnixDomainSocketAddress getRevealedLocalAddress(UnixDomainSocketAddress addr) {\n+        try{\n+            checkCapability();\n+            \/\/ Security check passed\n+        } catch (SecurityException e) {\n+            \/\/ Return unnamed address only if security check fails\n+            addr = UNNAMED;\n+        }\n+        return addr;\n+    }\n+\n+    public static UnixDomainSocketAddress localAddress(FileDescriptor fd) throws IOException {\n+        byte[] bytes = localAddress0(fd);\n+        return UnixDomainSocketAddress.of(\n+                    new String(bytes, UnixDomainSocketsUtil.getCharset()));\n+    }\n+\n+    static native byte[] localAddress0(FileDescriptor fd)\n+        throws IOException;\n+\n+    public static UnixDomainSocketAddress remoteAddress(FileDescriptor fd) throws IOException {\n+        byte[] bytes = remoteAddress0(fd);\n+        return UnixDomainSocketAddress.of(new String(bytes,\n+                    UnixDomainSocketsUtil.getCharset()));\n+    }\n+\n+    static native byte[] remoteAddress0(FileDescriptor fd)\n+        throws IOException;\n+\n+    static String getRevealedLocalAddressAsString(UnixDomainSocketAddress addr) {\n+        return System.getSecurityManager() == null ? addr.toString() : \"\";\n+    }\n+\n+    public static UnixDomainSocketAddress checkAddress(SocketAddress sa) {\n+        if (sa == null)\n+            return null;\n+        if (!(sa instanceof UnixDomainSocketAddress))\n+            throw new UnsupportedAddressTypeException();\n+        UnixDomainSocketAddress usa = (UnixDomainSocketAddress)sa;\n+        return usa;\n+    }\n+\n+    public static boolean isSupported() {\n+        return supported;\n+    }\n+\n+    public static int maxNameLen() {\n+        return supported ? maxNameLen0() : -1;\n+    }\n+\n+    public static boolean inTempDirectory(Path path) {\n+        Path parent = AccessController.doPrivileged(\n+            (PrivilegedAction<Path>) () -> {\n+                return path\n+                    .normalize()\n+                    .toAbsolutePath()\n+                    .getParent();\n+            }\n+        );\n+        return parent.equals(tempDir);\n+    }\n+\n+    static final Path tempDir = UnixDomainSocketsUtil.getTempDir();\n+\n+    static byte[] getPathBytes(Path path) throws IOException {\n+        AbstractFileSystemProvider provider = (AbstractFileSystemProvider)\n+            FileSystems.getDefault().provider();\n+        return provider.getSunPathForSocketFile(path);\n+    }\n+\n+    public static FileDescriptor socket() throws IOException {\n+        return IOUtil.newFD(socket0());\n+    }\n+\n+    public static void bind(FileDescriptor fd, Path addr) throws IOException {\n+        byte[] path = getPathBytes(addr);\n+        bind0(fd, path);\n+    }\n+\n+    public static int connect(FileDescriptor fd, Path addr) throws IOException {\n+        byte[] path = getPathBytes(addr);\n+        return connect0(fd, path);\n+    }\n+\n+    static int accept(FileDescriptor fd, FileDescriptor newfd, String[] isaa)\n+        throws IOException\n+    {\n+        Object[] barray  = new Object[1];\n+        int ret = accept0(fd, newfd, barray);\n+        byte[] bytes = (byte[])barray[0];\n+        isaa[0] = bytes == null ? null : new String(bytes, UnixDomainSocketsUtil.getCharset());\n+        return ret;\n+    }\n+\n+    private static native int socket0();\n+\n+    private static native boolean socketSupported();\n+\n+    private static native void bind0(FileDescriptor fd, byte[] path)\n+        throws IOException;\n+\n+    private static native int connect0(FileDescriptor fd, byte[] path)\n+        throws IOException;\n+\n+    static native int accept0(FileDescriptor fd, FileDescriptor newfd, Object[] isaa)\n+        throws IOException;\n+\n+    static native int maxNameLen0();\n+\n+}\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/UnixDomainSockets.java","additions":185,"deletions":0,"binary":false,"changes":185,"status":"added"},{"patch":"@@ -157,0 +157,6 @@\n+\n+    \/**\n+     * Returns a path name as bytes for a Unix domain socket.\n+     * Different encodings may be used for these names on some platforms.\n+     *\/\n+    public abstract byte[] getSunPathForSocketFile(Path file);\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/fs\/AbstractFileSystemProvider.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"","filename":"src\/java.base\/share\/conf\/net.properties.common","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/java.base\/share\/conf\/net.properties","status":"renamed"},{"patch":"@@ -43,0 +43,6 @@\n+\/* 2 bytes to allow for null at end of string and null at start of string\n+ * for abstract name\n+ *\/\n+#define MAX_UNIX_DOMAIN_PATH_LEN \\\n+        (int)(sizeof(((struct sockaddr_un *)0)->sun_path)-2)\n+\n@@ -157,0 +163,9 @@\n+JNIEXPORT jbyteArray JNICALL\n+NET_SockaddrToUnixAddressBytes(JNIEnv *env, struct sockaddr_un *sa, socklen_t len);\n+\n+JNIEXPORT jint JNICALL\n+NET_UnixSocketAddressToSockaddr(JNIEnv *env,\n+                                jbyteArray uaddr,\n+                                struct sockaddr_un *sa,\n+                                int *len);\n+\n","filename":"src\/java.base\/share\/native\/libnet\/net_util.h","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import java.net.UnixDomainSocketAddress;\n@@ -36,0 +37,3 @@\n+import java.nio.channels.SocketChannel;\n+import java.nio.channels.ServerSocketChannel;\n+import java.nio.channels.DatagramChannel;\n@@ -48,4 +52,4 @@\n-    private static final int AF_UNKNOWN         = -1;\n-    private static final int AF_INET            = 1;\n-    private static final int AF_INET6           = 2;\n-    private static final int AF_UNIX            = 3;\n+    static final int AF_UNKNOWN         = -1;\n+    static final int AF_INET            = 1;\n+    static final int AF_INET6           = 2;\n+    static final int AF_UNIX            = 3;\n@@ -83,1 +87,1 @@\n-    public static class InheritedSocketChannelImpl extends SocketChannelImpl {\n+    public static class InheritedInetSocketChannelImpl extends InetSocketChannelImpl {\n@@ -89,1 +93,1 @@\n-        InheritedSocketChannelImpl(SelectorProvider sp,\n+        InheritedInetSocketChannelImpl(SelectorProvider sp,\n@@ -103,1 +107,1 @@\n-    public static class InheritedUnixChannelImpl extends UnixDomainSocketChannelImpl {\n+    public static class InheritedUnixSocketChannelImpl extends UnixDomainSocketChannelImpl {\n@@ -105,1 +109,3 @@\n-        InheritedUnixChannelImpl(FileDescriptor fd)\n+        InheritedUnixSocketChannelImpl(SelectorProvider sp,\n+                                FileDescriptor fd,\n+                                UnixDomainSocketAddress remote )\n@@ -108,1 +114,1 @@\n-            super(fd);\n+            super(sp, fd, remote);\n@@ -111,0 +117,1 @@\n+        @Override\n@@ -112,1 +119,1 @@\n-            super.implCloseChannel();\n+            super.implCloseSelectableChannel();\n@@ -117,2 +124,7 @@\n-    public static class InheritedServerSocketChannelImpl extends\n-        ServerSocketChannelImpl {\n+    public static class InheritedUnixServerSocketChannelImpl extends UnixDomainServerSocketChannelImpl {\n+\n+        InheritedUnixServerSocketChannelImpl(SelectorProvider sp, FileDescriptor fd)\n+            throws IOException\n+        {\n+            super(sp, fd, true);\n+        }\n@@ -120,1 +132,11 @@\n-        InheritedServerSocketChannelImpl(SelectorProvider sp,\n+        @Override\n+        protected void implCloseSelectableChannel() throws IOException {\n+            super.implCloseSelectableChannel();\n+            detachIOStreams();\n+        }\n+    }\n+\n+    public static class InheritedInetServerSocketChannelImpl extends\n+        InetServerSocketChannelImpl {\n+\n+        InheritedInetServerSocketChannelImpl(SelectorProvider sp,\n@@ -214,1 +236,2 @@\n-                    return new InheritedUnixChannelImpl(fd);\n+                    var sa = UnixDomainSocketAddress.of(peerAddressUnix(fdVal));\n+                    return new InheritedUnixSocketChannelImpl(provider, fd, sa);\n@@ -216,2 +239,1 @@\n-                    \/\/ listener. unsupported.\n-                    return null;\n+                    return new InheritedUnixServerSocketChannelImpl(provider, fd);\n@@ -220,1 +242,1 @@\n-            InetAddress ia = peerAddress0(fdVal);\n+            InetAddress ia = peerAddressInet(fdVal);\n@@ -222,1 +244,1 @@\n-               c = new InheritedServerSocketChannelImpl(provider, fd);\n+               c = new InheritedInetServerSocketChannelImpl(provider, fd);\n@@ -225,0 +247,1 @@\n+\n@@ -227,1 +250,1 @@\n-               c = new InheritedSocketChannelImpl(provider, fd, isa);\n+               c = new InheritedInetSocketChannelImpl(provider, fd, isa);\n@@ -261,0 +284,4 @@\n+    private static String peerAddressUnix(int fd) throws IOException {\n+        byte[] bytes = peerAddressUnix0(fd);\n+        return new String(bytes);\n+    }\n@@ -271,1 +298,2 @@\n-    private static native InetAddress peerAddress0(int fd);\n+    private static native InetAddress peerAddressInet(int fd);\n+    private static native byte[] peerAddressUnix0(int fd);\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/ch\/InheritedChannel.java","additions":48,"deletions":20,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -1,266 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.nio.ch;\n-\n-import java.io.FileDescriptor;\n-import java.io.IOException;\n-import java.nio.ByteBuffer;\n-import java.nio.channels.AsynchronousCloseException;\n-import java.nio.channels.ByteChannel;\n-import java.nio.channels.ClosedChannelException;\n-import java.nio.channels.NotYetConnectedException;\n-import java.nio.channels.spi.AbstractInterruptibleChannel;\n-import java.util.Objects;\n-import java.util.concurrent.locks.ReentrantLock;\n-\n-import static java.util.concurrent.TimeUnit.NANOSECONDS;\n-\n-class UnixDomainSocketChannelImpl\n-    extends AbstractInterruptibleChannel\n-    implements ByteChannel\n-{\n-    \/\/ Used to make native read and write calls\n-    private static final NativeDispatcher nd = new SocketDispatcher();\n-\n-    \/\/ Our file descriptor object\n-    private final FileDescriptor fd;\n-    \/\/ Lock held by current reading or connecting thread\n-    private final ReentrantLock readLock = new ReentrantLock();\n-\n-    \/\/ Lock held by current writing or connecting thread\n-    private final ReentrantLock writeLock = new ReentrantLock();\n-\n-    \/\/ Lock for managing close state\n-    private final Object stateLock = new Object();\n-\n-    \/\/ Channel state\n-    private static final int ST_INUSE = 0;\n-    private static final int ST_CLOSING = 1;\n-    private static final int ST_CLOSED = 2;\n-    private int state;\n-\n-    \/\/ IDs of native threads doing reads and writes, for signalling\n-    private long readerThread;\n-    private long writerThread;\n-\n-    UnixDomainSocketChannelImpl(FileDescriptor fd)\n-        throws IOException\n-    {\n-        this.fd = fd;\n-    }\n-\n-    \/**\n-     * Checks that the channel is open.\n-     *\n-     * @throws ClosedChannelException if channel is closed (or closing)\n-     *\/\n-    private void ensureOpen() throws ClosedChannelException {\n-        if (!isOpen())\n-            throw new ClosedChannelException();\n-    }\n-\n-    \/**\n-     * Closes the socket if there are no I\/O operations in progress\n-     *\/\n-    private boolean tryClose() throws IOException {\n-        assert Thread.holdsLock(stateLock) && state == ST_CLOSING;\n-        if (readerThread == 0 && writerThread == 0) {\n-            state = ST_CLOSED;\n-            nd.close(fd);\n-            return true;\n-        } else {\n-            return false;\n-        }\n-    }\n-\n-    \/**\n-     * Complete closure of pre-closed socket (release the file descriptor)\n-     *\/\n-    private void tryFinishClose() {\n-        try {\n-            tryClose();\n-        } catch (IOException ignore) { }\n-    }\n-\n-    \/**\n-     * Marks the beginning of a read operation\n-     *\n-     * @throws ClosedChannelException if the channel is closed\n-     * @throws NotYetConnectedException if the channel is not yet connected\n-     *\/\n-    private void beginRead() throws ClosedChannelException {\n-        \/\/ set hook for Thread.interrupt\n-        begin();\n-        synchronized (stateLock) {\n-            ensureOpen();\n-            readerThread = NativeThread.current();\n-        }\n-    }\n-\n-    \/**\n-     * Marks the end of a read operation that may have blocked.\n-     *\n-     * @throws AsynchronousCloseException if the channel was closed due to this\n-     * thread being interrupted on a blocking read operation.\n-     *\/\n-    private void endRead(boolean completed)\n-        throws AsynchronousCloseException\n-    {\n-        synchronized (stateLock) {\n-            readerThread = 0;\n-            if (state == ST_CLOSING) {\n-                tryFinishClose();\n-            }\n-        }\n-        end(completed);\n-    }\n-\n-    @Override\n-    public int read(ByteBuffer buf) throws IOException {\n-        Objects.requireNonNull(buf);\n-\n-        readLock.lock();\n-        try {\n-            int n = 0;\n-            try {\n-                beginRead();\n-                n = IOUtil.read(fd, buf, -1, nd);\n-                while (IOStatus.okayToRetry(n) && isOpen()) {\n-                    park(Net.POLLIN, 0L);\n-                    n = IOUtil.read(fd, buf, -1, nd);\n-                }\n-            } finally {\n-                endRead(n > 0);\n-            }\n-            return n;\n-        } finally {\n-            readLock.unlock();\n-        }\n-    }\n-\n-    \/**\n-     * Marks the beginning of a write operation that might block.\n-     *\n-     * @throws ClosedChannelException if the channel is closed\n-     * @throws NotYetConnectedException if the channel is not yet connected\n-     *\/\n-    private void beginWrite() throws ClosedChannelException {\n-        begin();\n-        synchronized (stateLock) {\n-            \/\/ set hook for Thread.interrupt\n-            ensureOpen();\n-            writerThread = NativeThread.current();\n-        }\n-    }\n-\n-    \/**\n-     * Marks the end of a write operation that may have blocked.\n-     *\n-     * @throws AsynchronousCloseException if the channel was closed due to this\n-     * thread being interrupted on a blocking write operation.\n-     *\/\n-    private void endWrite(boolean completed)\n-        throws AsynchronousCloseException\n-    {\n-        synchronized (stateLock) {\n-            writerThread = 0;\n-            if (state == ST_CLOSING) {\n-                tryFinishClose();\n-            }\n-        }\n-        end(completed);\n-    }\n-\n-    void park(int event, long nanos) throws IOException {\n-        long millis;\n-        if (nanos <= 0) {\n-            millis = -1;\n-        } else {\n-            millis = NANOSECONDS.toMillis(nanos);\n-        }\n-        Net.poll(fd, event, millis);\n-    }\n-\n-    @Override\n-    public int write(ByteBuffer buf) throws IOException {\n-        Objects.requireNonNull(buf);\n-\n-        writeLock.lock();\n-        try {\n-            int n = 0;\n-            try {\n-                beginWrite();\n-                n = IOUtil.write(fd, buf, -1, nd);\n-                while (IOStatus.okayToRetry(n) && isOpen()) {\n-                    park(Net.POLLOUT, 0L);\n-                    n = IOUtil.write(fd, buf, -1, nd);\n-                }\n-            } finally {\n-                endWrite(n > 0);\n-            }\n-            return n;\n-        } finally {\n-            writeLock.unlock();\n-        }\n-    }\n-\n-    \/**\n-     * Closes this channel\n-     *\n-     * If there is an I\/O operation in progress then the socket is pre-closed\n-     * and the I\/O threads signalled, in which case the final close is deferred\n-     * until all I\/O operations complete.\n-     *\/\n-    @Override\n-    protected void implCloseChannel() throws IOException {\n-        synchronized (stateLock) {\n-            assert state == ST_INUSE;\n-            state = ST_CLOSING;\n-            if (!tryClose()) {\n-                long reader = readerThread;\n-                long writer = writerThread;\n-                if (reader != 0 || writer != 0) {\n-                    nd.preClose(fd);\n-                    if (reader != 0)\n-                        NativeThread.signal(reader);\n-                    if (writer != 0)\n-                        NativeThread.signal(writer);\n-                }\n-            }\n-        }\n-    }\n-\n-    @Override\n-    public String toString() {\n-        StringBuilder sb = new StringBuilder();\n-        sb.append(this.getClass().getSuperclass().getName());\n-        sb.append('[');\n-        if (!isOpen())\n-            sb.append(\"closed\");\n-        sb.append(']');\n-        return sb.toString();\n-    }\n-}\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/ch\/UnixDomainSocketChannelImpl.java","additions":0,"deletions":266,"binary":false,"changes":266,"status":"deleted"},{"patch":"@@ -0,0 +1,69 @@\n+\/*\n+ * Copyright (c) 2008, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.nio.ch;\n+\n+import java.nio.charset.Charset;\n+import java.nio.file.InvalidPathException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n+import sun.net.NetProperties;\n+\n+\/**\n+ * Platform specific utility functions\n+ *\/\n+class UnixDomainSocketsUtil {\n+    static Charset getCharset() {\n+        return Charset.defaultCharset();\n+    }\n+\n+    \/**\n+     * Return the temp directory for storing automatically bound\n+     * server sockets.\n+     *\n+     * On UNIX we search the following directories in sequence:\n+     *\n+     * 1. ${jdk.nio.unixdomain.tmpdir} if set as system property\n+     * 2. ${jdk.nio.unixdomain.tmpdir} if set as net property\n+     * 3. ${java.io.tmpdir} system property\n+     *\n+     *\/\n+    static Path getTempDir() {\n+        PrivilegedAction<Path> action = () -> {\n+            try {\n+                String s = NetProperties.get(\"jdk.nio.unixdomain.tmpdir\");\n+                if (s != null && s.length() > 0) {\n+                    return Path.of(s);\n+                }\n+                return Path.of(System.getProperty(\"java.io.tmpdir\"));\n+            } catch (InvalidPathException ipe) {\n+                return null;\n+            }\n+        };\n+        return AccessController.doPrivileged(action);\n+    }\n+}\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/ch\/UnixDomainSocketsUtil.java","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"},{"patch":"@@ -560,0 +560,8 @@\n+\n+    @Override\n+    public byte[] getSunPathForSocketFile(Path obj) {\n+        if (obj == null)\n+            return null;\n+        UnixPath file = UnixPath.toUnixPath(obj);\n+        return file.getByteArrayForSysCalls();\n+    }\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixFileSystemProvider.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-class UnixUserPrincipals {\n+public class UnixUserPrincipals {\n@@ -111,1 +111,1 @@\n-    static User fromUid(int uid) {\n+    public static User fromUid(int uid) {\n@@ -122,1 +122,1 @@\n-    static Group fromGid(int gid) {\n+    public static Group fromGid(int gid) {\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixUserPrincipals.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,15 @@\n+#\n+# Default directory where automatically bound Unix domain server\n+# sockets are stored. Sockets are automatically bound when bound\n+# with a null address.\n+#\n+# On Unix the search order to determine this directory is:\n+#\n+# 1. System property jdk.nio.unixdomain.tmpdir\n+#\n+# 2. Networking property jdk.nio.unixdomain.tmpdir specified\n+#    in this file (effective default)\n+#\n+# 3. System property java.io.tmpdir\n+#\n+jdk.nio.unixdomain.tmpdir=\/tmp\n","filename":"src\/java.base\/unix\/conf\/net.properties.unix","additions":15,"deletions":0,"binary":false,"changes":15,"status":"added"},{"patch":"@@ -32,0 +32,2 @@\n+#include <sys\/types.h>\n+#include <sys\/un.h>\n@@ -72,0 +74,1 @@\n+    struct sockaddr_un  saun;\n","filename":"src\/java.base\/unix\/native\/libnet\/net_util_md.h","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-static int matchFamily(SOCKETADDRESS *sa) {\n+static int matchFamilyInet(SOCKETADDRESS *sa) {\n@@ -52,1 +52,1 @@\n-Java_sun_nio_ch_InheritedChannel_peerAddress0(JNIEnv *env, jclass cla, jint fd)\n+Java_sun_nio_ch_InheritedChannel_peerAddressInet(JNIEnv *env, jclass cla, jint fd)\n@@ -60,1 +60,1 @@\n-        if (matchFamily(&sa)) {\n+        if (matchFamilyInet(&sa)) {\n@@ -68,0 +68,15 @@\n+JNIEXPORT jbyteArray JNICALL\n+Java_sun_nio_ch_InheritedChannel_peerAddressUnix0(JNIEnv *env, jclass cla, jint fd)\n+{\n+    struct sockaddr_un sa;\n+    socklen_t len = sizeof(struct sockaddr_un);\n+    jobject remote_sa = NULL;\n+\n+    if (getpeername(fd, (struct sockaddr *)&sa, &len) == 0) {\n+        if (sa.sun_family == AF_UNIX) {\n+            remote_sa = NET_SockaddrToUnixAddressBytes(env, &sa, len);\n+        }\n+    }\n+    return remote_sa;\n+}\n+\n@@ -75,2 +90,2 @@\n-    if (getpeername(fd, &sa.sa, &len) == 0) {\n-        if (matchFamily(&sa)) {\n+    if (getpeername(fd, (struct sockaddr *)&sa.sa, &len) == 0) {\n+        if (matchFamilyInet(&sa)) {\n","filename":"src\/java.base\/unix\/native\/libnio\/ch\/InheritedChannel.c","additions":20,"deletions":5,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -0,0 +1,232 @@\n+\/*\n+ * Copyright (c) 2001, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <poll.h>\n+#include <sys\/types.h>\n+#include <sys\/socket.h>\n+#include <string.h>\n+#include <stddef.h>\n+#include <netinet\/in.h>\n+#include <netinet\/tcp.h>\n+#include <limits.h>\n+\n+#include \"jni.h\"\n+#include \"java_props.h\"\n+#include \"jni_util.h\"\n+#include \"jvm.h\"\n+#include \"jlong.h\"\n+#include \"sun_nio_ch_Net.h\"\n+#include \"net_util.h\"\n+#include \"net_util_md.h\"\n+#include \"nio_util.h\"\n+#include \"nio.h\"\n+\n+#ifdef _AIX\n+#include <stdlib.h>\n+#include <sys\/utsname.h>\n+#endif\n+\n+\n+\/* Subtle platform differences in how unnamed sockets (empty path)\n+ * are returned from getsockname()\n+ *\/\n+#ifdef MACOSX\n+  #define ZERO_PATHLEN(len) (JNI_FALSE)\n+#else\n+  #define ZERO_PATHLEN(len) (len == offsetof(struct sockaddr_un, sun_path))\n+#endif\n+\n+JNIEXPORT jbyteArray JNICALL\n+NET_SockaddrToUnixAddressBytes(JNIEnv *env, struct sockaddr_un *sa, socklen_t len) {\n+\n+    if (sa->sun_family == AF_UNIX) {\n+        int namelen;\n+        if (ZERO_PATHLEN(len)) {\n+            namelen = 0;\n+        } else {\n+            namelen = strlen(sa->sun_path);\n+        }\n+        jbyteArray name = (*env)->NewByteArray(env, namelen);\n+        if (namelen != 0) {\n+            (*env)->SetByteArrayRegion(env, name, 0, namelen, (jbyte*)sa->sun_path);\n+        }\n+        return name;\n+    }\n+    return NULL;\n+}\n+\n+JNIEXPORT jint JNICALL\n+NET_UnixSocketAddressToSockaddr(JNIEnv *env, jbyteArray path, struct sockaddr_un *sa, int *len)\n+{\n+    memset(sa, 0, sizeof(struct sockaddr_un));\n+    sa->sun_family = AF_UNIX;\n+    int ret;\n+    const char* pname = (const char *)(*env)->GetByteArrayElements(env, path, NULL);\n+    size_t name_len = (*env)->GetArrayLength(env, path);\n+    if (name_len > MAX_UNIX_DOMAIN_PATH_LEN) {\n+        JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\", \"Unix domain path too long\");\n+        ret = 1;\n+        goto finish;\n+    }\n+    memcpy(sa->sun_path, pname, name_len);\n+    *len = (int)(offsetof(struct sockaddr_un, sun_path) + name_len + 1);\n+    ret = 0;\n+  finish:\n+    (*env)->ReleaseByteArrayElements(env, path, (jbyte *)pname, 0);\n+    return ret;\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_sun_nio_ch_UnixDomainSockets_maxNameLen0(JNIEnv *env, jclass cl)\n+{\n+    return MAX_UNIX_DOMAIN_PATH_LEN;\n+}\n+\n+JNIEXPORT jboolean JNICALL\n+Java_sun_nio_ch_UnixDomainSockets_socketSupported(JNIEnv *env, jclass cl)\n+{\n+    return JNI_TRUE;\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_sun_nio_ch_UnixDomainSockets_socket0(JNIEnv *env, jclass cl)\n+{\n+    int fd = socket(PF_UNIX, SOCK_STREAM, 0);\n+    if (fd < 0) {\n+        return handleSocketError(env, errno);\n+    }\n+    return fd;\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_sun_nio_ch_UnixDomainSockets_bind0(JNIEnv *env, jclass clazz, jobject fdo, jbyteArray path)\n+{\n+    struct sockaddr_un sa;\n+    int sa_len = 0;\n+    int rv = 0;\n+\n+    if (path == NULL)\n+        return; \/* Rely on implicit bind: Unix *\/\n+\n+    if (NET_UnixSocketAddressToSockaddr(env, path, &sa, &sa_len) != 0)\n+        return;\n+\n+    int fd = fdval(env, fdo);\n+\n+    rv = bind(fdval(env, fdo), (struct sockaddr *)&sa, sa_len);\n+    if (rv != 0) {\n+        handleSocketError(env, errno);\n+    }\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_sun_nio_ch_UnixDomainSockets_connect0(JNIEnv *env, jclass clazz, jobject fdo, jbyteArray path)\n+{\n+    struct sockaddr_un sa;\n+    int sa_len = 0;\n+    int rv;\n+\n+    if (NET_UnixSocketAddressToSockaddr(env, path, &sa, &sa_len) != 0) {\n+        return IOS_THROWN;\n+    }\n+\n+    rv = connect(fdval(env, fdo), (struct sockaddr *)&sa, sa_len);\n+    if (rv != 0) {\n+        if (errno == EINPROGRESS) {\n+            return IOS_UNAVAILABLE;\n+        } else if (errno == EINTR) {\n+            return IOS_INTERRUPTED;\n+        }\n+        return handleSocketError(env, errno);\n+    }\n+    return 1;\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_sun_nio_ch_UnixDomainSockets_accept0(JNIEnv *env, jclass clazz, jobject fdo, jobject newfdo,\n+                           jobjectArray usaa)\n+{\n+    jint fd = fdval(env, fdo);\n+    jint newfd;\n+    struct sockaddr_un sa;\n+    socklen_t sa_len = sizeof(struct sockaddr_un);\n+    jstring usa;\n+\n+    \/* accept connection but ignore ECONNABORTED *\/\n+    for (;;) {\n+        newfd = accept(fd, (struct sockaddr *)&sa, &sa_len);\n+        if (newfd >= 0) {\n+            break;\n+        }\n+        if (errno != ECONNABORTED) {\n+            break;\n+        }\n+        \/* ECONNABORTED => restart accept *\/\n+    }\n+\n+    if (newfd < 0) {\n+        if (errno == EAGAIN || errno == EWOULDBLOCK)\n+            return IOS_UNAVAILABLE;\n+        if (errno == EINTR)\n+            return IOS_INTERRUPTED;\n+        JNU_ThrowIOExceptionWithLastError(env, \"Accept failed\");\n+        return IOS_THROWN;\n+    }\n+\n+    setfdval(env, newfdo, newfd);\n+\n+    usa = NET_SockaddrToUnixAddressBytes(env, &sa, sa_len);\n+    CHECK_NULL_RETURN(usa, IOS_THROWN);\n+\n+    (*env)->SetObjectArrayElement(env, usaa, 0, usa);\n+\n+    return 1;\n+}\n+\n+JNIEXPORT jbyteArray JNICALL\n+Java_sun_nio_ch_UnixDomainSockets_localAddress0(JNIEnv *env, jclass clazz, jobject fdo)\n+{\n+    SOCKETADDRESS sa;\n+    socklen_t sa_len = sizeof(SOCKETADDRESS);\n+    int port;\n+    if (getsockname(fdval(env, fdo), &sa.sa, &sa_len) < 0) {\n+        handleSocketError(env, errno);\n+        return NULL;\n+    }\n+    return NET_SockaddrToUnixAddressBytes(env, &sa.saun, sa_len);\n+}\n+\n+JNIEXPORT jbyteArray JNICALL\n+Java_sun_nio_ch_UnixDomainSockets_remoteAddress0(JNIEnv *env, jclass clazz, jobject fdo)\n+{\n+    SOCKETADDRESS sa;\n+    socklen_t sa_len = sizeof(sa);\n+\n+    if (getpeername(fdval(env, fdo), &sa.sa, &sa_len) < 0) {\n+        handleSocketError(env, errno);\n+        return NULL;\n+    }\n+    return NET_SockaddrToUnixAddressBytes(env, &sa.saun, sa_len);\n+}\n","filename":"src\/java.base\/unix\/native\/libnio\/ch\/UnixDomainSockets.c","additions":232,"deletions":0,"binary":false,"changes":232,"status":"added"},{"patch":"@@ -34,0 +34,4 @@\n+import java.net.SocketAddress;\n+import java.net.UnixDomainSocketAddress;\n+import java.net.StandardProtocolFamily;\n+import java.net.StandardSocketOptions;\n@@ -36,0 +40,2 @@\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n@@ -106,0 +112,2 @@\n+                \/\/ Loopback address\n+                SocketAddress sa = null;\n@@ -112,4 +120,0 @@\n-                    \/\/ Loopback address\n-                    InetAddress lb = InetAddress.getLoopbackAddress();\n-                    assert(lb.isLoopbackAddress());\n-                    InetSocketAddress sa = null;\n@@ -120,3 +124,2 @@\n-                            ssc = ServerSocketChannel.open();\n-                            ssc.socket().bind(new InetSocketAddress(lb, 0));\n-                            sa = new InetSocketAddress(lb, ssc.socket().getLocalPort());\n+                            ssc = createListener();\n+                            sa = ssc.getLocalAddress();\n@@ -151,0 +154,4 @@\n+                    if (sc2 instanceof InetSocketChannelImpl) {\n+                        var isc = (InetSocketChannelImpl)sc2;\n+                        isc.setOption(StandardSocketOptions.TCP_NODELAY, true);\n+                    }\n@@ -163,0 +170,2 @@\n+                        if (sa instanceof UnixDomainSocketAddress)\n+                            Files.delete(((UnixDomainSocketAddress)sa).getPath());\n@@ -185,0 +194,21 @@\n+    private static volatile boolean noUnixDomainSockets = false;\n+\n+    private static ServerSocketChannel createListener() throws IOException {\n+        ServerSocketChannel listener = null;\n+        if (!noUnixDomainSockets) {\n+            try {\n+                listener = ServerSocketChannel.open(StandardProtocolFamily.UNIX);\n+                return listener.bind(null);\n+            } catch (UnsupportedOperationException | IOException e) {\n+                \/\/ IOException is most likely to be caused by the temporary directory\n+                \/\/ name being too long. Possibly should log this.\n+                noUnixDomainSockets = true;\n+                if (listener != null)\n+                    listener.close();\n+            }\n+        }\n+        listener = ServerSocketChannel.open();\n+        InetAddress lb = InetAddress.getLoopbackAddress();\n+        listener.bind(new InetSocketAddress(lb, 0));\n+        return listener;\n+    }\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/ch\/PipeImpl.java","additions":37,"deletions":7,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-    SinkChannelImpl(SelectorProvider sp, SocketChannel sc) {\n+    SinkChannelImpl(SelectorProvider sp, SocketChannel sc) throws IOException {\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/ch\/SinkChannelImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,77 @@\n+\/*\n+ * Copyright (c) 2002, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.nio.ch;\n+\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.InvalidPathException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n+import sun.net.NetProperties;\n+\n+class UnixDomainSocketsUtil {\n+\n+    static Charset getCharset() {\n+        return StandardCharsets.UTF_8;\n+    }\n+\n+    \/**\n+     * Return the temp directory for storing automatically bound\n+     * server sockets.\n+     *\n+     * On Windows we search the following directories in sequence:\n+     *\n+     * 1. ${jdk.nio.unixdomain.tmpdir} if set as system property\n+     * 2. ${jdk.nio.unixdomain.tmpdir} if set as net property\n+     * 3. %TEMP%\n+     * 4. ${java.io.tmpdir}\n+     *\n+     *\/\n+    static Path getTempDir() {\n+        PrivilegedAction<Path> action = () -> {\n+            try {\n+                String s = NetProperties.get(\"jdk.nio.unixdomain.tmpdir\");\n+                if (s != null) {\n+                    return Path.of(s);\n+                }\n+                String temp = System.getenv(\"TEMP\");\n+                if (temp != null) {\n+                    Path p = Path.of(temp);\n+                    if (Files.exists(p)) {\n+                        return p;\n+                    }\n+                }\n+                return Path.of(System.getProperty(\"java.io.tmpdir\"));\n+            } catch (InvalidPathException ipe) {\n+                return null;\n+            }\n+        };\n+        return AccessController.doPrivileged(action);\n+    }\n+}\n+\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/ch\/UnixDomainSocketsUtil.java","additions":77,"deletions":0,"binary":false,"changes":77,"status":"added"},{"patch":"@@ -142,1 +142,1 @@\n-        wakeupPipe = Pipe.open();\n+        wakeupPipe = new PipeImpl(sp);\n@@ -147,1 +147,0 @@\n-        (sink.sc).socket().setTcpNoDelay(true);\n@@ -422,1 +421,1 @@\n-                    (sk.channel() instanceof SocketChannelImpl) &&\n+                    (sk.channel() instanceof InetSocketChannelImpl) &&\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/ch\/WindowsSelectorImpl.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.nio.charset.StandardCharsets;\n@@ -625,0 +626,10 @@\n+\n+    @Override\n+    public byte[] getSunPathForSocketFile(Path obj) {\n+        if (obj == null)\n+            return null;\n+        WindowsPath file = WindowsPath.toWindowsPath(obj);\n+        String s = file.toString();\n+        return s.getBytes(StandardCharsets.UTF_8);\n+    }\n+\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/fs\/WindowsFileSystemProvider.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,19 @@\n+#\n+# Default directory where automatically bound Unix domain server\n+# sockets are stored. Sockets are automatically bound when bound\n+# with a null address.\n+#\n+# The search order for the directory on Windows is:\n+#\n+# 1. System property \"jdk.nio.unixdomain.tmpdir\"\n+#\n+# 2. Networking property \"jdk.nio.unixdomain.tmpdir\" specified\n+#    in this file (not set by default)\n+#\n+# 3. The TEMP environment variable (the effective default)\n+#\n+# 4. The java.io.tmpdir system property\n+#\n+#jdk.nio.unixdomain.tmpdir=\n+#\n+\n","filename":"src\/java.base\/windows\/conf\/net.properties.windows","additions":19,"deletions":0,"binary":false,"changes":19,"status":"added"},{"patch":"@@ -30,0 +30,1 @@\n+#include <afunix.h>\n","filename":"src\/java.base\/windows\/native\/libnet\/net_util_md.h","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,213 @@\n+\/*\n+ * Copyright (c) 2001, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <windows.h>\n+#include <winsock2.h>\n+\n+#include \"jni.h\"\n+#include \"jni_util.h\"\n+#include \"jvm.h\"\n+#include \"jlong.h\"\n+#include \"nio.h\"\n+#include \"nio_util.h\"\n+#include \"net_util.h\"\n+\n+#include \"java_net_InetAddress.h\"\n+#include \"sun_nio_ch_Net.h\"\n+#include \"sun_nio_ch_PollArrayWrapper.h\"\n+\n+JNIEXPORT jbyteArray JNICALL\n+NET_SockaddrToUnixAddressBytes(JNIEnv *env, struct sockaddr_un *sa, socklen_t len) {\n+\n+    if (sa->sun_family == AF_UNIX) {\n+        int namelen = (int)strlen(sa->sun_path);\n+        jbyteArray name = (*env)->NewByteArray(env, namelen);\n+        if (name != NULL) {\n+            (*env)->SetByteArrayRegion(env, name, 0, namelen, (jbyte*)sa->sun_path);\n+        }\n+        return name;\n+    }\n+    return NULL;\n+}\n+\n+JNIEXPORT jint JNICALL\n+NET_UnixSocketAddressToSockaddr(JNIEnv *env, jbyteArray addr, struct sockaddr_un *sa, int *len)\n+{\n+    memset(sa, 0, sizeof(struct sockaddr_un));\n+    sa->sun_family = AF_UNIX;\n+    if (addr == 0L) {\n+        \/* Do explicit bind on Windows *\/\n+        *len = (int)(offsetof(struct sockaddr_un, sun_path));\n+        return 0;\n+    }\n+    int ret;\n+    jboolean isCopy;\n+    char *pname = (*env)->GetByteArrayElements(env, addr, &isCopy);\n+\n+    size_t name_len = (size_t)(*env)->GetArrayLength(env, addr);\n+    if (name_len > MAX_UNIX_DOMAIN_PATH_LEN) {\n+        JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\", \"Unix domain path too long\");\n+        ret=1;\n+        goto finish;\n+    }\n+    strncpy(sa->sun_path, pname, name_len);\n+    *len = (int)(offsetof(struct sockaddr_un, sun_path) + name_len);\n+    ret = 0;\n+  finish:\n+    (*env)->ReleaseByteArrayElements(env, addr, pname, JNI_ABORT);\n+    return ret;\n+}\n+\n+\n+JNIEXPORT jboolean JNICALL\n+Java_sun_nio_ch_UnixDomainSockets_socketSupported(JNIEnv *env, jclass cl)\n+{\n+    SOCKET fd = socket(PF_UNIX, SOCK_STREAM, 0);\n+    if (fd == INVALID_SOCKET) {\n+        return JNI_FALSE;\n+    }\n+    closesocket(fd);\n+    return JNI_TRUE;\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_sun_nio_ch_UnixDomainSockets_maxNameLen0(JNIEnv *env, jclass cl)\n+{\n+    return MAX_UNIX_DOMAIN_PATH_LEN - 1;\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_sun_nio_ch_UnixDomainSockets_socket0(JNIEnv *env, jclass cl)\n+{\n+    SOCKET fd = socket(PF_UNIX, SOCK_STREAM, 0);\n+    if (fd == INVALID_SOCKET) {\n+        return handleSocketError(env, WSAGetLastError());\n+    }\n+    return (int)fd;\n+}\n+\n+\/**\n+ * Windows does not support auto bind. So, the windows version of NET_UnixSocketAddressToSockaddr\n+ * looks out for a null 'uaddr' and handles it specially\n+ *\/\n+JNIEXPORT void JNICALL\n+Java_sun_nio_ch_UnixDomainSockets_bind0(JNIEnv *env, jclass clazz, jobject fdo, jbyteArray addr)\n+{\n+    struct sockaddr_un sa;\n+    int sa_len = 0;\n+    int rv = 0;\n+\n+    if (NET_UnixSocketAddressToSockaddr(env, addr, &sa, &sa_len) != 0)\n+        return;\n+\n+    int fd = fdval(env, fdo);\n+\n+    rv = bind(fdval(env, fdo), (struct sockaddr *)&sa, sa_len);\n+    if (rv != 0) {\n+        int err = WSAGetLastError();\n+        NET_ThrowNew(env, err, \"bind\");\n+    }\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_sun_nio_ch_UnixDomainSockets_connect0(JNIEnv *env, jclass clazz, jobject fdo, jbyteArray addr)\n+{\n+    struct sockaddr_un sa;\n+    int sa_len = 0;\n+    int rv;\n+\n+    if (NET_UnixSocketAddressToSockaddr(env, addr, &sa, &sa_len) != 0) {\n+        return IOS_THROWN;\n+    }\n+\n+    rv = connect(fdval(env, fdo), (const struct sockaddr *)&sa, sa_len);\n+    if (rv != 0) {\n+        int err = WSAGetLastError();\n+        if (err == WSAEINPROGRESS || err == WSAEWOULDBLOCK) {\n+            return IOS_UNAVAILABLE;\n+        }\n+        NET_ThrowNew(env, err, \"connect\");\n+        return IOS_THROWN;\n+    }\n+    return 1;\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_sun_nio_ch_UnixDomainSockets_accept0(JNIEnv *env, jclass clazz, jobject fdo, jobject newfdo,\n+                           jobjectArray usaa)\n+{\n+    jint fd = fdval(env, fdo);\n+    jint newfd;\n+    struct sockaddr_un sa;\n+    socklen_t sa_len = sizeof(sa);\n+    jobject usa;\n+\n+    memset((char *)&sa, 0, sizeof(sa));\n+    newfd = (jint) accept(fd, (struct sockaddr *)&sa, &sa_len);\n+    if (newfd == INVALID_SOCKET) {\n+        int theErr = (jint)WSAGetLastError();\n+        if (theErr == WSAEWOULDBLOCK) {\n+            return IOS_UNAVAILABLE;\n+        }\n+        JNU_ThrowIOExceptionWithLastError(env, \"Accept failed\");\n+        return IOS_THROWN;\n+    }\n+\n+    SetHandleInformation((HANDLE)(UINT_PTR)newfd, HANDLE_FLAG_INHERIT, 0);\n+    setfdval(env, newfdo, newfd);\n+\n+    usa = NET_SockaddrToUnixAddressBytes(env, &sa, sa_len);\n+    CHECK_NULL_RETURN(usa, IOS_THROWN);\n+\n+    (*env)->SetObjectArrayElement(env, usaa, 0, usa);\n+\n+    return 1;\n+}\n+\n+JNIEXPORT jbyteArray JNICALL\n+Java_sun_nio_ch_UnixDomainSockets_localAddress0(JNIEnv *env, jclass clazz, jobject fdo)\n+{\n+    struct sockaddr_un sa;\n+    int sa_len = sizeof(sa);\n+\n+    if (getsockname(fdval(env, fdo), (struct sockaddr *)&sa, &sa_len) == SOCKET_ERROR) {\n+        NET_ThrowNew(env, WSAGetLastError(), \"getsockname\");\n+        return NULL;\n+    }\n+    return NET_SockaddrToUnixAddressBytes(env, &sa, sa_len);\n+}\n+\n+JNIEXPORT jbyteArray JNICALL\n+Java_sun_nio_ch_UnixDomainSockets_remoteAddress0(JNIEnv *env, jclass clazz, jobject fdo)\n+{\n+    struct sockaddr_un sa;\n+    int sa_len = sizeof(sa);\n+\n+    if (getpeername(fdval(env, fdo), (struct sockaddr *)&sa, &sa_len) == SOCKET_ERROR) {\n+        NET_ThrowNew(env, WSAGetLastError(), \"getsockname\");\n+        return NULL;\n+    }\n+    return NET_SockaddrToUnixAddressBytes(env, &sa, sa_len);\n+}\n","filename":"src\/java.base\/windows\/native\/libnio\/ch\/UnixDomainSockets.c","additions":213,"deletions":0,"binary":false,"changes":213,"status":"added"},{"patch":"@@ -33,0 +33,2 @@\n+    public final static EventHandler UNIX_SOCKET_READ = Utils.getHandler(UnixSocketReadEvent.class);\n+    public final static EventHandler UNIX_SOCKET_WRITE = Utils.getHandler(UnixSocketWriteEvent.class);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/events\/Handlers.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.events;\n+\n+import jdk.jfr.Category;\n+import jdk.jfr.Description;\n+import jdk.jfr.Label;\n+import jdk.jfr.DataAmount;\n+import jdk.jfr.Name;\n+import jdk.jfr.internal.Type;\n+\n+@Name(Type.EVENT_NAME_PREFIX + \"UnixSocketRead\")\n+@Label(\"UnixSocket Read\")\n+@Category(\"Java Application\")\n+@Description(\"Reading data from a Unix domain socket\")\n+public final class UnixSocketReadEvent extends AbstractJDKEvent {\n+\n+    \/\/ The order of these fields must be the same as the parameters in\n+    \/\/ EventHandler::write(..., String, long, boolean)\n+\n+    @Label(\"From\")\n+    @Description(\"Path to remote peer\")\n+    public String path;\n+\n+    @Label(\"Bytes Read\")\n+    @Description(\"Number of bytes read from the socket (possibly 0)\")\n+    @DataAmount\n+    public long bytesRead;\n+\n+    @Label(\"End of File\")\n+    @Description(\"If end of file was reached\")\n+    public boolean endOfFile;\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/events\/UnixSocketReadEvent.java","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -0,0 +1,52 @@\n+\/*\n+ * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.events;\n+\n+import jdk.jfr.Category;\n+import jdk.jfr.Description;\n+import jdk.jfr.Label;\n+import jdk.jfr.DataAmount;\n+import jdk.jfr.Name;\n+import jdk.jfr.internal.Type;\n+\n+@Name(Type.EVENT_NAME_PREFIX + \"UnixSocketWrite\")\n+@Label(\"UnixSocket Write\")\n+@Category(\"Java Application\")\n+@Description(\"Writing data to a Unix socket\")\n+public final class UnixSocketWriteEvent extends AbstractJDKEvent {\n+\n+    \/\/ The order of these fields must be the same as the parameters in\n+    \/\/ EventHandler::write(..., String, long)\n+\n+    @Label(\"To\")\n+    @Description(\"Path to peer socket\")\n+    public String path;\n+\n+    @Label(\"Bytes Written\")\n+    @Description(\"Number of bytes written to the file\")\n+    @DataAmount\n+    public long bytesWritten;\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/events\/UnixSocketWriteEvent.java","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -30,0 +30,1 @@\n+import java.net.SocketAddress;\n@@ -31,1 +32,0 @@\n-\n@@ -38,2 +38,2 @@\n-@JIInstrumentationTarget(\"sun.nio.ch.SocketChannelImpl\")\n-final class SocketChannelImplInstrumentor {\n+@JIInstrumentationTarget(\"sun.nio.ch.InetSocketChannelImpl\")\n+final class InetSocketChannelImplInstrumentor {\n@@ -41,1 +41,1 @@\n-    private SocketChannelImplInstrumentor() {\n+    private InetSocketChannelImplInstrumentor() {\n@@ -44,2 +44,0 @@\n-    private InetSocketAddress remoteAddress;\n-\n@@ -53,0 +51,1 @@\n+        InetSocketAddress remoteAddress = (InetSocketAddress)getRemoteAddress();\n@@ -84,0 +83,1 @@\n+        InetSocketAddress remoteAddress = (InetSocketAddress)getRemoteAddress();\n@@ -116,0 +116,1 @@\n+        InetSocketAddress remoteAddress = (InetSocketAddress)getRemoteAddress();\n@@ -137,0 +138,5 @@\n+    public SocketAddress getRemoteAddress() throws IOException {\n+        \/\/ gets replaced by call to instrumented class\n+        return null;\n+    }\n+\n@@ -144,0 +150,1 @@\n+        InetSocketAddress remoteAddress = (InetSocketAddress)getRemoteAddress();\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/instrument\/InetSocketChannelImplInstrumentor.java","additions":13,"deletions":6,"binary":false,"changes":19,"previous_filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/instrument\/SocketChannelImplInstrumentor.java","status":"renamed"},{"patch":"@@ -45,0 +45,2 @@\n+import jdk.jfr.events.UnixSocketReadEvent;\n+import jdk.jfr.events.UnixSocketWriteEvent;\n@@ -71,0 +73,2 @@\n+        UnixSocketReadEvent.class,\n+        UnixSocketWriteEvent.class,\n@@ -92,1 +96,2 @@\n-        SocketChannelImplInstrumentor.class\n+        InetSocketChannelImplInstrumentor.class,\n+        UnixSocketChannelImplInstrumentor.class\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/instrument\/JDKEvents.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,150 @@\n+\/*\n+ * Copyright (c) 2013, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.internal.instrument;\n+\n+import java.io.IOException;\n+import java.net.SocketAddress;\n+import java.net.UnixDomainSocketAddress;\n+import java.nio.ByteBuffer;\n+\n+import jdk.jfr.events.Handlers;\n+import jdk.jfr.internal.handlers.EventHandler;\n+\n+\/**\n+ * See {@link JITracer} for an explanation of this code.\n+ *\/\n+@JIInstrumentationTarget(\"sun.nio.ch.UnixDomainSocketChannelImpl\")\n+final class UnixSocketChannelImplInstrumentor {\n+\n+    private UnixSocketChannelImplInstrumentor() {\n+    }\n+\n+    @SuppressWarnings(\"deprecation\")\n+    @JIInstrumentationMethod\n+    public int read(ByteBuffer dst) throws IOException {\n+        EventHandler handler = Handlers.UNIX_SOCKET_READ;\n+        if (!handler.isEnabled()) {\n+            return read(dst);\n+        }\n+        UnixDomainSocketAddress remoteAddress = (UnixDomainSocketAddress)getRemoteAddress();\n+        int bytesRead = 0;\n+        long start  = 0;\n+        try {\n+            start = EventHandler.timestamp();;\n+            bytesRead = read(dst);\n+        } finally {\n+            long duration = EventHandler.timestamp() - start;\n+            if (handler.shouldCommit(duration))  {\n+                String path = remoteAddress.getPath().toString();\n+                if (bytesRead < 0) {\n+                    handler.write(start, duration, path, 0L, true);\n+                } else {\n+                    handler.write(start, duration, path, bytesRead, false);\n+                }\n+            }\n+        }\n+        return bytesRead;\n+    }\n+\n+    @SuppressWarnings(\"deprecation\")\n+    @JIInstrumentationMethod\n+    public long read(ByteBuffer[] dsts, int offset, int length) throws IOException {\n+        EventHandler handler = Handlers.UNIX_SOCKET_READ;\n+        if (!handler.isEnabled()) {\n+            return read(dsts, offset, length);\n+        }\n+        UnixDomainSocketAddress remoteAddress = (UnixDomainSocketAddress)getRemoteAddress();\n+\n+        long bytesRead = 0;\n+        long start = 0;\n+        try {\n+            start = EventHandler.timestamp();\n+            bytesRead = read(dsts, offset, length);\n+        } finally {\n+            long duration = EventHandler.timestamp() - start;\n+            if (handler.shouldCommit(duration)) {\n+                String path = remoteAddress.getPath().toString();\n+                if (bytesRead < 0) {\n+                    handler.write(start, duration, path, 0L, true);\n+                } else {\n+                    handler.write(start, duration, path, bytesRead, false);\n+                }\n+            }\n+        }\n+        return bytesRead;\n+    }\n+\n+    @SuppressWarnings(\"deprecation\")\n+    @JIInstrumentationMethod\n+    public int write(ByteBuffer buf) throws IOException {\n+        EventHandler handler = Handlers.UNIX_SOCKET_WRITE;\n+        if (!handler.isEnabled()) {\n+            return write(buf);\n+        }\n+        UnixDomainSocketAddress remoteAddress = (UnixDomainSocketAddress)getRemoteAddress();\n+        int bytesWritten = 0;\n+        long start = 0;\n+        try {\n+            start = EventHandler.timestamp();\n+            bytesWritten = write(buf);\n+        } finally {\n+            long duration = EventHandler.timestamp() - start;\n+            if (handler.shouldCommit(duration)) {\n+                String path = remoteAddress.getPath().toString();\n+                handler.write(start, duration, path, bytesWritten);\n+            }\n+        }\n+        return bytesWritten;\n+    }\n+\n+    @SuppressWarnings(\"deprecation\")\n+    @JIInstrumentationMethod\n+    public long write(ByteBuffer[] srcs, int offset, int length) throws IOException {\n+        EventHandler handler = Handlers.UNIX_SOCKET_WRITE;\n+        if (!handler.isEnabled()) {\n+            return write(srcs, offset, length);\n+        }\n+        UnixDomainSocketAddress remoteAddress = (UnixDomainSocketAddress)getRemoteAddress();\n+        long bytesWritten = 0;\n+        long start = 0;\n+        try {\n+            start = EventHandler.timestamp();\n+            bytesWritten = write(srcs, offset, length);\n+        } finally {\n+            long duration = EventHandler.timestamp() - start;\n+            if (handler.shouldCommit(duration)) {\n+                String path = remoteAddress.getPath().toString();\n+                handler.write(start, duration, path, bytesWritten);\n+            }\n+        }\n+        return bytesWritten;\n+    }\n+\n+    public SocketAddress getRemoteAddress() throws IOException {\n+        \/\/ is replaced by call to instrumented class\n+        return null;\n+    }\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/instrument\/UnixSocketChannelImplInstrumentor.java","additions":150,"deletions":0,"binary":false,"changes":150,"status":"added"},{"patch":"@@ -662,0 +662,12 @@\n+    <event name=\"jdk.UnixSocketRead\">\n+      <setting name=\"enabled\">true<\/setting>\n+      <setting name=\"stackTrace\">true<\/setting>\n+      <setting name=\"threshold\" control=\"socket-io-threshold\">10 ms<\/setting>\n+    <\/event>\n+\n+    <event name=\"jdk.UnixSocketWrite\">\n+      <setting name=\"enabled\">true<\/setting>\n+      <setting name=\"stackTrace\">true<\/setting>\n+      <setting name=\"threshold\" control=\"socket-io-threshold\">10 ms<\/setting>\n+    <\/event>\n+\n","filename":"src\/jdk.jfr\/share\/conf\/jfr\/profile.jfc","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import java.nio.file.attribute.UserPrincipal;\n+import java.nio.file.attribute.GroupPrincipal;\n@@ -31,0 +33,1 @@\n+import sun.nio.fs.UnixUserPrincipals;\n@@ -57,0 +60,4 @@\n+    boolean peerCredentialsSupported() {\n+        return true;\n+    }\n+\n@@ -97,0 +104,10 @@\n+    @Override\n+    UnixDomainPrincipal getSoPeerCred(int fd) throws SocketException {\n+        long l = getSoPeerCred0(fd);\n+        int uid = (int)(l >> 32);\n+        int gid = (int)l;\n+        UserPrincipal user = UnixUserPrincipals.fromUid(uid);\n+        GroupPrincipal group = UnixUserPrincipals.fromGid(gid);\n+        return new UnixDomainPrincipal(user, group);\n+    }\n+\n@@ -105,0 +122,1 @@\n+    private static native long getSoPeerCred0(int fd) throws SocketException;\n","filename":"src\/jdk.net\/linux\/classes\/jdk\/net\/LinuxSocketOptions.java","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -26,0 +26,2 @@\n+#include <sys\/un.h>\n+#include <sys\/types.h>\n@@ -112,0 +114,23 @@\n+\/*\n+ * Class:     jdk_net_LinuxSocketOptions\n+ * Method:    getSoPeerCred0\n+ * Signature: (I)L\n+ *\/\n+JNIEXPORT jlong JNICALL Java_jdk_net_LinuxSocketOptions_getSoPeerCred0\n+  (JNIEnv *env, jclass clazz, jint fd) {\n+\n+    int rv;\n+    struct ucred cred;\n+    socklen_t len = sizeof(cred);\n+\n+    if ((rv=getsockopt(fd, SOL_SOCKET, SO_PEERCRED, &cred, &len)) < 0) {\n+        handleError(env, rv, \"get SO_PEERCRED failed\");\n+    } else {\n+        if ((int)cred.uid == -1) {\n+            handleError(env, -1, \"get SO_PEERCRED failed\");\n+            cred.uid = cred.gid = -1;\n+        }\n+    }\n+    return (((long)cred.uid) << 32) | (cred.gid & 0xffffffffL);\n+}\n+\n","filename":"src\/jdk.net\/linux\/native\/libextnet\/LinuxSocketOptions.c","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import java.nio.file.attribute.UserPrincipal;\n+import java.nio.file.attribute.GroupPrincipal;\n@@ -31,0 +33,1 @@\n+import sun.nio.fs.UnixUserPrincipals;\n@@ -52,0 +55,5 @@\n+    @Override\n+    boolean peerCredentialsSupported() {\n+        return true;\n+    }\n+\n@@ -72,0 +80,10 @@\n+    @Override\n+    UnixDomainPrincipal getSoPeerCred(int fd) throws SocketException {\n+        long l = getSoPeerCred0(fd);\n+        int uid = (int)(l >> 32);\n+        int gid = (int)l;\n+        UserPrincipal user = UnixUserPrincipals.fromUid(uid);\n+        GroupPrincipal group = UnixUserPrincipals.fromGid(gid);\n+        return new UnixDomainPrincipal(user, group);\n+    }\n+\n@@ -78,0 +96,1 @@\n+    private static native long getSoPeerCred0(int fd) throws SocketException;\n","filename":"src\/jdk.net\/macosx\/classes\/jdk\/net\/MacOSXSocketOptions.java","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include <sys\/types.h>\n@@ -126,0 +127,19 @@\n+\/*\n+ * Class:     jdk_net_MacOSXSocketOptions\n+ * Method:    getSoPeerCred0\n+ * Signature: (I)L\n+ *\/\n+JNIEXPORT jlong JNICALL Java_jdk_net_MacOSXSocketOptions_getSoPeerCred0\n+  (JNIEnv *env, jclass clazz, jint fd) {\n+\n+    jint rv;\n+    int uid, gid;\n+    rv = getpeereid(fd, (uid_t *)&uid, (gid_t *)&gid);\n+    handleError(env, rv, \"get peer eid failed\");\n+    if (rv == -1) {\n+        uid = gid = -1;\n+    }\n+    return (((long)uid) << 32) | (gid & 0xffffffffL);\n+}\n+\n+\n","filename":"src\/jdk.net\/macosx\/native\/libextnet\/MacOSXSocketOptions.c","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -183,0 +183,19 @@\n+    \/**\n+     * Unix Domain peer credentials.\n+     *\n+     * <p> The value of this socket option is a {@link UnixDomainPrincipal} that\n+     * represents the credentials of a peer connected to a Unix Domain socket.\n+     * The credentials are those that applied at the time the socket was first\n+     * connected or accepted.\n+     *\n+     * <p> The socket option is read-only and an attempt to set the socket option\n+     * will throw {@code SocketException}. {@code SocketException} is also thrown\n+     * when attempting to get the value of the socket option on an unconnected Unix\n+     * Domain socket.\n+     *\n+     * @since 16\n+     *\/\n+    public static final SocketOption<UnixDomainPrincipal> SO_PEERCRED\n+        = new ExtSocketOption<UnixDomainPrincipal>\n+            (\"SO_PEERCRED\", UnixDomainPrincipal.class);\n+\n@@ -190,0 +209,2 @@\n+    private static final boolean peerCredentialsSupported =\n+            platformSocketOptions.peerCredentialsSupported();\n@@ -205,0 +226,3 @@\n+        if (peerCredentialsSupported) {\n+            options.add(SO_PEERCRED);\n+        }\n@@ -236,0 +260,2 @@\n+                } else if (option == SO_PEERCRED) {\n+                    throw new SocketException(\"SO_PEERCRED cannot be set \");\n@@ -258,0 +284,2 @@\n+                } else if (option == SO_PEERCRED) {\n+                    return getSoPeerCred(fd);\n@@ -275,0 +303,5 @@\n+    private static Object getSoPeerCred(FileDescriptor fd)\n+            throws SocketException {\n+        return platformSocketOptions.getSoPeerCred(fdAccess.get(fd));\n+    }\n+\n@@ -348,0 +381,4 @@\n+        boolean peerCredentialsSupported() {\n+            return false;\n+        }\n+\n@@ -372,0 +409,4 @@\n+        UnixDomainPrincipal getSoPeerCred(int fd) throws SocketException {\n+            throw new UnsupportedOperationException(\"unsupported SO_PEERCRED option\");\n+        }\n+\n","filename":"src\/jdk.net\/share\/classes\/jdk\/net\/ExtendedSocketOptions.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -0,0 +1,98 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.net;\n+\n+import java.nio.file.attribute.UserPrincipal;\n+import java.nio.file.attribute.GroupPrincipal;\n+import java.util.Objects;\n+\n+\/**\n+ * Represents the credentials of a peer connected to a\n+ * <a href=\"..\/..\/..\/java.base\/java\/nio\/channels\/package-summary.html#unixdomain\">\n+ * Unix domain<\/a> socket.\n+ *\n+ * @since 16\n+ *\/\n+\n+public final class UnixDomainPrincipal {\n+    private final UserPrincipal user;\n+    private final GroupPrincipal group;\n+\n+    \/**\n+     * Creates a UnixDomainPrincipal.\n+     *\n+     * @param user the user identity\n+     *\n+     * @param group the group identity\n+     *\n+     * @throws NullPointerException if {@code user} or {@code group} are {@code null}.\n+     *\/\n+    public UnixDomainPrincipal(UserPrincipal user, GroupPrincipal group) {\n+        this.user = Objects.requireNonNull(user);\n+        this.group = Objects.requireNonNull(group);\n+    }\n+\n+    \/**\n+     * Returns true if {@code obj} is a {@code UnixDomainPrincipal}\n+     * and its user and group are equal to this user and group.\n+     *\n+     * @param obj the object to compare with\n+     * @return true if this equal to obj\n+     *\/\n+    public boolean equals(Object obj) {\n+        if (obj instanceof UnixDomainPrincipal) {\n+            UnixDomainPrincipal that = (UnixDomainPrincipal) obj;\n+            return Objects.equals(this.user, that.user)\n+                    && Objects.equals(this.group, that.group);\n+        }\n+        return false;\n+    }\n+\n+    \/**\n+     * Returns a hashcode calculated from the user and group\n+     *\/\n+    public int hashCode() {\n+        return Objects.hash(user, group);\n+    }\n+\n+    \/**\n+     * Returns this object's {@link UserPrincipal}\n+     *\n+     * @return this object's user\n+     *\/\n+    public UserPrincipal user() {\n+        return user;\n+    }\n+\n+    \/**\n+     * Returns this object's {@link GroupPrincipal}\n+     *\n+     * @return this object's user\n+     *\/\n+    public GroupPrincipal group() {\n+        return group;\n+    }\n+}\n","filename":"src\/jdk.net\/share\/classes\/jdk\/net\/UnixDomainPrincipal.java","additions":98,"deletions":0,"binary":false,"changes":98,"status":"added"},{"patch":"@@ -162,1 +162,1 @@\n-        port = (Net.localAddress(fd)).getPort();\n+        port = Net.localAddress(fd).getPort();\n@@ -403,2 +403,1 @@\n-                                InetSocketAddress boundIsa =\n-                                        Net.localAddress(fd);\n+                                InetSocketAddress boundIsa = Net.localAddress(fd);\n@@ -510,2 +509,1 @@\n-                            InetSocketAddress boundIsa =\n-                                    Net.localAddress(fd);\n+                            InetSocketAddress boundIsa = Net.localAddress(fd);\n","filename":"src\/jdk.sctp\/unix\/classes\/sun\/nio\/ch\/sctp\/SctpChannelImpl.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+import static org.testng.Assert.assertEquals;\n@@ -330,0 +331,8 @@\n+    private static StandardProtocolFamily expectedFamily(StandardProtocolFamily family) {\n+        if (family == null) {\n+            return preferIPv4 ? INET : INET6;\n+        } else {\n+            return family;\n+        }\n+    }\n+\n@@ -332,1 +341,1 @@\n-        return family == null ? SocketChannel.open()\n+        SocketChannel chan = family == null ? SocketChannel.open()\n@@ -334,0 +343,1 @@\n+        return chan;\n@@ -338,1 +348,1 @@\n-        return family == null ? ServerSocketChannel.open()\n+        ServerSocketChannel chan = family == null ? ServerSocketChannel.open()\n@@ -340,0 +350,1 @@\n+        return chan;\n@@ -344,1 +355,1 @@\n-        return family == null ? DatagramChannel.open()\n+        DatagramChannel chan = family == null ? DatagramChannel.open()\n@@ -346,0 +357,1 @@\n+        return chan;\n@@ -352,0 +364,1 @@\n+            default -> throw new RuntimeException(\"Unexpected protocol family\");\n","filename":"test\/jdk\/java\/nio\/channels\/etc\/ProtocolFamilies.java","additions":16,"deletions":3,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,1 @@\n- * service then delays\/lingers for 15 seconds before shuting down. To\n+ * service then delays\/lingers for 15 seconds before shutting down. To\n@@ -57,2 +57,1 @@\n-\n-        SocketChannel sc = Launcher.launchWithSocketChannel(\"EchoService\", service_args);\n+        SocketChannel sc = Launcher.launchWithInetSocketChannel(\"EchoService\", null, service_args);\n","filename":"test\/jdk\/java\/nio\/channels\/spi\/SelectorProvider\/inheritedChannel\/CloseTest.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -61,1 +61,1 @@\n-        SocketChannel sc = Launcher.launchWithSocketChannel(ECHO_SERVICE, null);\n+        SocketChannel sc = Launcher.launchWithInetSocketChannel(ECHO_SERVICE, null);\n","filename":"test\/jdk\/java\/nio\/channels\/spi\/SelectorProvider\/inheritedChannel\/EchoTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -78,4 +78,4 @@\n-            { \"UnixSocketTest\", List.of(UnixSocketTest.class.getName())},\n-            { \"StateTest\", List.of(StateTest.class.getName()) },\n-            { \"EchoTest\",  List.of(EchoTest.class.getName())  },\n-            { \"CloseTest\", List.of(CloseTest.class.getName()) },\n+            \/\/{ \"UnixSocketTest\", List.of(UnixSocketTest.class.getName())},\n+            \/\/{ \"StateTest\", List.of(StateTest.class.getName()) },\n+            \/\/{ \"EchoTest\",  List.of(EchoTest.class.getName())  },\n+            \/\/{ \"CloseTest\", List.of(CloseTest.class.getName()) },\n@@ -88,0 +88,1 @@\n+\/*\n@@ -99,0 +100,1 @@\n+*\/\n","filename":"test\/jdk\/java\/nio\/channels\/spi\/SelectorProvider\/inheritedChannel\/InheritedChannelTest.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1,1 +0,0 @@\n-\n@@ -3,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +28,1 @@\n+\n@@ -32,0 +32,3 @@\n+import java.net.SocketAddress;\n+import java.net.StandardProtocolFamily;\n+import java.net.UnixDomainSocketAddress;\n@@ -35,0 +38,3 @@\n+import java.nio.file.Files;\n+\n+import static java.net.StandardProtocolFamily.UNIX;\n@@ -66,1 +72,0 @@\n-\n@@ -68,3 +73,3 @@\n-     * Launch 'java' with specified class using a UnixDomainSocket pair linking calling\n-     * process to the child VM. UnixDomainSocket is a simplified interface to PF_UNIX sockets\n-     * which supports byte a time reads and writes.\n+     * Launch 'java' with specified class. The launched process will inherit\n+     * a connected Unix Domain socket. The remote endpoint will be the\n+     * SocketChannel returned by this method.\n@@ -72,5 +77,11 @@\n-    public static UnixDomainSocket launchWithUnixDomainSocket(String className) throws IOException {\n-        UnixDomainSocket[] socks = UnixDomainSocket.socketpair();\n-        launch(className, null, null, socks[0].fd());\n-        socks[0].close();\n-        return socks[1];\n+    public static SocketChannel launchWithUnixSocketChannel(String className)\n+            throws IOException {\n+        ServerSocketChannel ssc = ServerSocketChannel.open(UNIX);\n+        var addr = (UnixDomainSocketAddress)ssc.bind(null).getLocalAddress();\n+        SocketChannel sc1 = SocketChannel.open(addr);\n+        SocketChannel sc2 = ssc.accept();\n+        launch(className, null, null, Util.getFD(sc2));\n+        sc2.close();\n+        Files.delete(addr.getPath());\n+        ssc.close();\n+        return sc1;\n@@ -80,9 +91,0 @@\n-     * Launch specified class with an AF_UNIX socket created externally, and one String arg to child VM\n-     *\/\n-    public static void launchWithUnixDomainSocket(String className, UnixDomainSocket socket, String arg) throws IOException {\n-        String[] args = new String[1];\n-        args[0] = arg;\n-        launch(className, null, args, socket.fd());\n-    }\n-\n-    \/*\n@@ -93,1 +95,4 @@\n-    public static SocketChannel launchWithSocketChannel(String className, String options[], String args[]) throws IOException {\n+    public static SocketChannel launchWithInetSocketChannel(String className,\n+                                                        String options[],\n+                                                        String... args)\n+            throws IOException {\n@@ -106,6 +111,8 @@\n-    public static SocketChannel launchWithSocketChannel(String className, String args[]) throws IOException {\n-        return launchWithSocketChannel(className, null, args);\n-    }\n-\n-    public static SocketChannel launchWithSocketChannel(String className) throws IOException {\n-        return launchWithSocketChannel(className, null);\n+    \/**\n+     * Launch specified class with a SocketChannel created externally.\n+     *\/\n+    public static void launchWithSocketChannel(String className,\n+                                               SocketChannel sc,\n+                                               String[] options,\n+                                               String... args) throws Exception {\n+        launch(className, options, args, Util.getFD(sc));\n@@ -114,1 +121,1 @@\n-    \/*\n+    \/**\n@@ -120,3 +127,4 @@\n-    public static SocketChannel launchWithServerSocketChannel(String className, String options[], String args[])\n-        throws IOException\n-    {\n+    public static SocketChannel launchWithInetServerSocketChannel(String className,\n+                                                              String[] options,\n+                                                              String... args)\n+            throws IOException {\n@@ -132,2 +140,7 @@\n-    public static SocketChannel launchWithServerSocketChannel(String className, String args[]) throws IOException {\n-        return launchWithServerSocketChannel(className, null, args);\n+    public static SocketChannel launchWithUnixServerSocketChannel(String className) throws IOException {\n+        ServerSocketChannel ssc = ServerSocketChannel.open(StandardProtocolFamily.UNIX);\n+        ssc.bind(null);\n+        var addr = ssc.getLocalAddress();\n+        launch(className, null, null, Util.getFD(ssc));\n+        ssc.close();\n+        return SocketChannel.open(addr);\n@@ -136,2 +149,9 @@\n-    public static SocketChannel launchWithServerSocketChannel(String className) throws IOException {\n-        return launchWithServerSocketChannel(className, null);\n+    \/**\n+     * Launch specified class with a ServerSocketChannel created externally.\n+     *\/\n+    public static void launchWithServerSocketChannel(String className,\n+                                                     ServerSocketChannel ssc,\n+                                                     String[] options,\n+                                                     String... args)\n+            throws Exception {\n+        launch(className, options, args, Util.getFD(ssc));\n@@ -140,1 +160,1 @@\n-    \/*\n+    \/**\n@@ -148,3 +168,4 @@\n-    public static DatagramChannel launchWithDatagramChannel(String className, String options[], String args[])\n-        throws IOException\n-    {\n+    public static DatagramChannel launchWithDatagramChannel(String className,\n+                                                            String[] options,\n+                                                            String... args)\n+            throws IOException {\n@@ -168,8 +189,0 @@\n-\n-    public static DatagramChannel launchWithDatagramChannel(String className, String args[]) throws IOException {\n-        return launchWithDatagramChannel(className, null, args);\n-    }\n-\n-    public static DatagramChannel launchWithDatagramChannel(String className) throws IOException {\n-        return launchWithDatagramChannel(className, null);\n-    }\n","filename":"test\/jdk\/java\/nio\/channels\/spi\/SelectorProvider\/inheritedChannel\/Launcher.java","additions":60,"deletions":47,"binary":false,"changes":107,"status":"modified"},{"patch":"@@ -173,2 +173,2 @@\n-        System.err.println(\"launchWithSocketChannel\");\n-        SocketChannel sc = Launcher.launchWithSocketChannel(TEST_SERVICE, options, arg);\n+        System.err.println(\"launchWithInetSocketChannel\");\n+        SocketChannel sc = Launcher.launchWithInetSocketChannel(TEST_SERVICE, options, arg);\n@@ -184,2 +184,2 @@\n-        System.err.println(\"launchWithServerSocketChannel\");\n-        sc = Launcher.launchWithServerSocketChannel(TEST_SERVICE, options, arg);\n+        System.err.println(\"launchWithInetServerSocketChannel\");\n+        sc = Launcher.launchWithInetServerSocketChannel(TEST_SERVICE, options, arg);\n","filename":"test\/jdk\/java\/nio\/channels\/spi\/SelectorProvider\/inheritedChannel\/StateTest.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n- * The test checks that the channel returned by System.inheritiedChannel\n+ * The test checks that the channel returned by System.inheritedChannel\n","filename":"test\/jdk\/java\/nio\/channels\/spi\/SelectorProvider\/inheritedChannel\/StateTestService.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,0 +24,3 @@\n+import java.io.IOException;\n+import java.net.SocketAddress;\n+import java.net.UnixDomainSocketAddress;\n@@ -26,1 +29,4 @@\n-import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+\n+import static java.net.StandardProtocolFamily.UNIX;\n@@ -30,1 +36,1 @@\n- * Make sure that System.inheritedChannel returns null when given a UNIX domain socket\n+ * Make sure that System.inheritedChannel returns the correct type\n@@ -34,0 +40,4 @@\n+    private static final UnixDomainSocketAddress SOCK_ADDR =\n+            UnixDomainSocketAddress.of(Path.of(\"foo.socket\"));\n+\n+    private static boolean passed = true;\n@@ -37,2 +47,2 @@\n-            \/\/ we just want to make sure that System.inheritedChannel either\n-            \/\/ returns a connected channel, or null if it is given a listener\n+            \/\/ we want to make sure that System.inheritedChannel either\n+            \/\/ returns a ServerSocketChannel or a SocketChannel\n@@ -42,4 +52,5 @@\n-                \/\/ socket is writeable\n-                ByteChannel bc = (ByteChannel)channel;\n-                ByteBuffer buf = ByteBuffer.wrap(result.getBytes(ISO_8859_1));\n-                bc.write(buf);\n+                if (channel instanceof SocketChannel) {\n+                    SocketChannel sc = (SocketChannel) channel;\n+                    ByteBuffer buf = ByteBuffer.wrap(result.getBytes(ISO_8859_1));\n+                    sc.write(buf);\n+                }\n@@ -47,6 +58,6 @@\n-                \/\/ in this case the socket is a listener\n-                \/\/ we can't write to it. So, use UnixDatagramSocket\n-                \/\/ to accept a writeable socket\n-                UnixDomainSocket listener = new UnixDomainSocket(0); \/\/ fd 0\n-                UnixDomainSocket sock = listener.accept();\n-                sock.write((int)result.charAt(0));\n+                if (channel instanceof ServerSocketChannel) {\n+                    ServerSocketChannel server = (ServerSocketChannel) channel;\n+                    SocketChannel sc = server.accept();\n+                    ByteBuffer buf = ByteBuffer.wrap(result.getBytes(ISO_8859_1));\n+                    sc.write(buf);\n+                }\n@@ -57,2 +68,0 @@\n-    static boolean passed = true;\n-\n@@ -67,6 +76,0 @@\n-    private static void closeAll(UnixDomainSocket... sockets) {\n-        for (UnixDomainSocket sock : sockets) {\n-            sock.close();\n-        }\n-    }\n-\n@@ -75,10 +78,18 @@\n-        UnixDomainSocket listener = new UnixDomainSocket();\n-        listener.bind(\"foo.socket\");\n-        UnixDomainSocket sock1 = new UnixDomainSocket();\n-        sock1.connect(\"foo.socket\");\n-        UnixDomainSocket sock2 = listener.accept();\n-\n-        Launcher.launchWithUnixDomainSocket(\"UnixDomainChannelTest$Child\", sock2, \"test1\");\n-        int c = sock1.read();\n-        if (c != 'Y') {\n-            System.err.printf(\"test1: failed %d d\\n\", c );\n+        ServerSocketChannel listener = ServerSocketChannel.open(UNIX);\n+        listener.bind(SOCK_ADDR);\n+        SocketChannel sock1 = SocketChannel.open(SOCK_ADDR);\n+        SocketChannel sock2 = listener.accept();\n+        System.out.println(\"test1: launching child\");\n+        Launcher.launchWithSocketChannel(\n+                \"UnixDomainChannelTest$Child\", sock2, null, \"test1\");\n+        ByteBuffer bb = ByteBuffer.allocate(10);\n+        int c = sock1.read(bb);\n+        if (c != 1) {\n+            System.err.printf(\"test1: failed \" +\n+                    \"- unexpected number of bytes read %d d\\n\", c);\n+            passed = false;\n+        }\n+        byte b = bb.get(0);\n+        if (b != 'Y') {\n+            System.err.printf(\"test1: failed \" +\n+                    \"- unexpected byte read %d d\\n\", b);\n@@ -88,0 +99,1 @@\n+        Files.deleteIfExists(SOCK_ADDR.getPath());\n@@ -92,1 +104,4 @@\n-        UnixDomainSocket[] pair = UnixDomainSocket.socketpair();\n+        ServerSocketChannel listener = ServerSocketChannel.open(UNIX);\n+        SocketAddress addr = listener.bind(null).getLocalAddress();\n+        SocketChannel sock1 = SocketChannel.open(addr);\n+        SocketChannel sock2 = listener.accept();\n@@ -94,3 +109,13 @@\n-        Launcher.launchWithUnixDomainSocket(\"UnixDomainChannelTest$Child\", pair[0], \"test2\");\n-        if (pair[1].read() != 'Y') {\n-            System.err.println(\"test2: failed\");\n+        Launcher.launchWithSocketChannel(\n+                \"UnixDomainChannelTest$Child\", sock2, null, \"test2\");\n+        ByteBuffer bb = ByteBuffer.allocate(10);\n+        int c = sock1.read(bb);\n+        if (c != 1) {\n+            System.err.printf(\"test3: failed \" +\n+                    \"- unexpected number of bytes read %d d\\n\", c);\n+            passed = false;\n+        }\n+        byte b = bb.get(0);\n+        if (b != 'Y') {\n+            System.err.printf(\"test3: failed \" +\n+                    \"- unexpected byte read %d d\\n\", b);\n@@ -99,1 +124,2 @@\n-        closeAll(pair[0], pair[1]);\n+        closeAll(listener, sock1, sock2);\n+        Files.deleteIfExists(((UnixDomainSocketAddress)addr).getPath());\n@@ -104,3 +130,3 @@\n-        UnixDomainSocket listener = new UnixDomainSocket();\n-        listener.bind(\"foo.socket\");\n-        UnixDomainSocket sock1 = new UnixDomainSocket();\n+        ServerSocketChannel listener = ServerSocketChannel.open(UNIX);\n+        listener.bind(SOCK_ADDR);\n+        SocketChannel sock1 = SocketChannel.open(UNIX);\n@@ -108,4 +134,14 @@\n-        Launcher.launchWithUnixDomainSocket(\"UnixDomainChannelTest$Child\", listener, \"test3\");\n-        sock1.connect(\"foo.socket\");\n-        if (sock1.read() != 'N') {\n-            System.err.println(\"test3: failed\");\n+        Launcher.launchWithServerSocketChannel(\n+                \"UnixDomainChannelTest$Child\", listener, null, \"test3\");\n+        sock1.connect(SOCK_ADDR);\n+        ByteBuffer bb = ByteBuffer.allocate(10);\n+        int c = sock1.read(bb);\n+        if (c != 1) {\n+            System.err.printf(\"test3: failed \" +\n+                    \"- unexpected number of bytes read %d d\\n\", c);\n+            passed = false;\n+        }\n+        byte b = bb.get(0);\n+        if (b != 'Y') {\n+            System.err.printf(\"test3: failed \" +\n+                    \"- unexpected byte read %d d\\n\", b);\n@@ -115,0 +151,1 @@\n+        Files.deleteIfExists(SOCK_ADDR.getPath());\n@@ -117,0 +154,10 @@\n+    private static void closeAll(Channel... channels) {\n+        for (Channel c : channels) {\n+            try {\n+                if (c != null)\n+                    c.close();\n+            } catch (IOException e) {\n+                throw new RuntimeException(\"Could not close channel \" + c);\n+            }\n+        }\n+    }\n","filename":"test\/jdk\/java\/nio\/channels\/spi\/SelectorProvider\/inheritedChannel\/UnixDomainChannelTest.java","additions":92,"deletions":45,"binary":false,"changes":137,"status":"modified"},{"patch":"@@ -1,101 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * A simplified Unix domain socket which can read and write bytes at a time\n- * used for simulating external launchers which use UNIX sockets to talk\n- * the VM.\n- *\/\n-\n-import java.io.IOException;\n-\n-public class UnixDomainSocket {\n-\n-    static {\n-        System.loadLibrary(\"InheritedChannel\");\n-        init();\n-    }\n-\n-    private final int fd;\n-    private volatile String name;\n-\n-    public UnixDomainSocket() throws IOException {\n-        this.fd = create();\n-    }\n-\n-    public void bind(String name) throws IOException {\n-        bind0(fd, name);\n-        this.name = name;\n-    }\n-\n-    public UnixDomainSocket accept() throws IOException {\n-        int newsock = accept0(fd);\n-        return new UnixDomainSocket(newsock);\n-    }\n-\n-    public UnixDomainSocket(int fd) {\n-        this.fd = fd;\n-    }\n-\n-    public void connect(String dest) throws IOException {\n-        connect0(fd, dest);\n-    }\n-\n-    public int read() throws IOException {\n-        return read0(fd);\n-    }\n-\n-    public String name() {\n-        return name;\n-    }\n-\n-    public void write(int w) throws IOException {\n-        write0(fd, w);\n-    }\n-\n-    public void close() {\n-        close0(fd, name); \/\/ close0 will unlink name if non-null\n-    }\n-\n-    public int fd() {\n-        return fd;\n-    }\n-\n-    public String toString() {\n-        return \"UnixDomainSocket: fd=\" + Integer.toString(fd);\n-    }\n-\n-    private static native int create() throws IOException;\n-    private static native void bind0(int fd, String name) throws IOException;\n-    private static native int accept0(int fd) throws IOException;\n-    private static native int connect0(int fd, String name) throws IOException;\n-\n-    \/* read and write bytes with UNIX domain sockets *\/\n-\n-    private static native int read0(int fd) throws IOException;\n-    private static native void write0(int fd, int w) throws IOException;\n-    private static native void close0(int fd, String name);\n-    private static native void init();\n-    public static native UnixDomainSocket[] socketpair();\n-}\n-\n","filename":"test\/jdk\/java\/nio\/channels\/spi\/SelectorProvider\/inheritedChannel\/UnixDomainSocket.java","additions":0,"deletions":101,"binary":false,"changes":101,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,8 +24,0 @@\n-\/*\n- * If the platform has IPv6 we spawn a child process simulating the\n- * effect of being launched from node.js. We check that IPv6 is available in the child\n- * and report back as appropriate.\n- *\/\n-\n-import jdk.test.lib.Utils;\n-import java.io.*;\n@@ -35,0 +27,5 @@\n+import java.net.UnixDomainSocketAddress;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.SocketChannel;\n+import java.nio.channels.ServerSocketChannel;\n+import java.nio.file.Files;\n@@ -38,0 +35,2 @@\n+import static java.net.StandardProtocolFamily.UNIX;\n+\n@@ -40,9 +39,9 @@\n-    static boolean hasIPv6() throws Exception {\n-        Enumeration<NetworkInterface> nets = NetworkInterface.getNetworkInterfaces();\n-        for (NetworkInterface netint : Collections.list(nets)) {\n-            Enumeration<InetAddress> inetAddresses = netint.getInetAddresses();\n-            for (InetAddress inetAddress : Collections.list(inetAddresses)) {\n-                if (inetAddress instanceof Inet6Address) {\n-                    return true;\n-                }\n-            }\n+    public static class Child1 {\n+        public static void main(String[] args) throws Exception {\n+            SocketChannel chan = (SocketChannel)System.inheritedChannel();\n+            ByteBuffer bb = ByteBuffer.allocate(2);\n+            bb.put((byte)'X');\n+            bb.put((byte)'Y');\n+            bb.flip();\n+            chan.write(bb);\n+            chan.close();\n@@ -50,1 +49,0 @@\n-        return false;\n@@ -53,1 +51,1 @@\n-    public static class Child {\n+    public static class Child2 {\n@@ -55,6 +53,11 @@\n-            System.out.write('X');\n-            System.out.flush();\n-            if (hasIPv6()) {\n-                System.out.println(\"Y\"); \/\/ GOOD\n-            } else\n-                System.out.println(\"N\"); \/\/ BAD\n+            ServerSocketChannel server = (ServerSocketChannel)System.inheritedChannel();\n+            SocketChannel chan = server.accept();\n+            UnixDomainSocketAddress sa = (UnixDomainSocketAddress)server.getLocalAddress();\n+            Files.delete(sa.getPath());\n+            server.close();\n+            ByteBuffer bb = ByteBuffer.allocate(2);\n+            bb.put((byte)'X');\n+            bb.put((byte)'Y');\n+            bb.flip();\n+            chan.write(bb);\n+            chan.close();\n@@ -65,3 +68,5 @@\n-\n-        if (!hasIPv6()) {\n-            return; \/\/ can only test if IPv6 is present\n+        SocketChannel sc = Launcher.launchWithUnixSocketChannel(\"UnixSocketTest$Child1\");\n+        ByteBuffer bb = ByteBuffer.allocate(10);\n+        sc.read(bb);\n+        if (bb.get(0) != 'X') {\n+            System.exit(-2);\n@@ -69,2 +74,9 @@\n-        UnixDomainSocket sock = Launcher.launchWithUnixDomainSocket(\"UnixSocketTest$Child\");\n-        if (sock.read() != 'X') {\n+        if (bb.get(1) != 'Y') {\n+            System.exit(-2);\n+        }\n+        sc.close();\n+\n+        sc = Launcher.launchWithUnixServerSocketChannel(\"UnixSocketTest$Child2\");\n+        bb.clear();\n+        sc.read(bb);\n+        if (bb.get(0) != 'X') {\n@@ -73,1 +85,1 @@\n-        if (sock.read() != 'Y') {\n+        if (bb.get(1) != 'Y') {\n","filename":"test\/jdk\/java\/nio\/channels\/spi\/SelectorProvider\/inheritedChannel\/UnixSocketTest.java","additions":44,"deletions":32,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-#include <sys\/un.h>\n@@ -43,3 +42,0 @@\n-static jclass unixSocketClass;\n-static jmethodID unixSocketCtor;\n-\n@@ -88,1 +84,0 @@\n-\n@@ -148,1 +143,1 @@\n-     * get the list of open file descriptos we read through \/proc\/self\/fd (\/dev\/fd)\n+     * get the list of open file descriptors we read through \/proc\/self\/fd (\/dev\/fd)\n@@ -187,128 +182,0 @@\n-\n-JNIEXPORT void JNICALL Java_UnixDomainSocket_init(JNIEnv *env, jclass cls) {\n-    CHECK(unixSocketClass = (*env)->FindClass(env, \"UnixDomainSocket\"));\n-    CHECK(unixSocketClass = (*env)->NewGlobalRef(env, unixSocketClass));\n-    CHECK(unixSocketCtor = (*env)->GetMethodID(env, unixSocketClass, \"<init>\", \"(I)V\"));\n-}\n-\n-\/*\n- * Class:     UnixDomainSocket\n- * Method:    socketpair\n- * Signature: ()[LUnixDomainSocket\n- *\/\n-JNIEXPORT jobjectArray JNICALL Java_UnixDomainSocket_socketpair\n-  (JNIEnv *env, jclass cls)\n-{\n-    int fds[2];\n-    jobject socket;\n-    jobjectArray result = (*env)->NewObjectArray(env, 2, unixSocketClass, 0);\n-    if (socketpair(AF_UNIX, SOCK_STREAM, 0, fds) < 0) {\n-        perror(\"socketpair\");\n-        return result;\n-    }\n-    socket = (*env)->NewObject(env, unixSocketClass, unixSocketCtor, fds[0]);\n-    (*env)->SetObjectArrayElement(env, result, 0, socket);\n-    socket = (*env)->NewObject(env, unixSocketClass, unixSocketCtor, fds[1]);\n-    (*env)->SetObjectArrayElement(env, result, 1, socket);\n-    return result;\n-}\n-\n-JNIEXPORT jint JNICALL Java_UnixDomainSocket_create\n-  (JNIEnv *env, jclass cls)\n-{\n-    int sock = socket(AF_UNIX, SOCK_STREAM, 0);\n-    if (sock == -1) {\n-        ThrowException(env, \"java\/io\/IOException\", \"socket create error\");\n-    }\n-    return sock;\n-}\n-\n-JNIEXPORT void JNICALL Java_UnixDomainSocket_bind0\n-  (JNIEnv *env, jclass cls, jint sock, jstring name)\n-{\n-    struct sockaddr_un addr;\n-    const char *nameUtf = (*env)->GetStringUTFChars(env, name, NULL);\n-    int ret = -1;\n-    int length = sizeof(addr.sun_path);\n-    unlink(nameUtf);\n-    memset(&addr, 0, sizeof(addr));\n-    addr.sun_family = AF_UNIX;\n-    strncpy(addr.sun_path, nameUtf, length);\n-    addr.sun_path[length - 1] = '\\0';\n-    ret = bind(sock, (const struct sockaddr*)&addr, sizeof(addr));\n-    if (ret == -1) {\n-        ThrowException(env, \"java\/io\/IOException\", \"socket bind error\");\n-    }\n-    ret = listen(sock, 5);\n-    if (ret == -1) {\n-        ThrowException(env, \"java\/io\/IOException\", \"socket bind error\");\n-    }\n-    (*env)->ReleaseStringUTFChars(env, name, nameUtf);\n-}\n-\n-JNIEXPORT jint JNICALL Java_UnixDomainSocket_accept0\n-  (JNIEnv *env, jclass cls, jint sock)\n-{\n-    struct sockaddr_storage addr;\n-    socklen_t len = sizeof(addr);\n-    int ret = accept(sock, (struct sockaddr *)&addr, &len);\n-    if (ret == -1)\n-        ThrowException(env, \"java\/io\/IOException\", \"socket accept error\");\n-    return ret;\n-}\n-\n-JNIEXPORT void JNICALL Java_UnixDomainSocket_connect0\n-  (JNIEnv *env, jclass cls, jint fd, jstring name)\n-{\n-    struct sockaddr_un addr;\n-    const char *nameUtf = (*env)->GetStringUTFChars(env, name, NULL);\n-    int ret = -1;\n-    int length = sizeof(addr.sun_path);\n-    memset(&addr, 0, sizeof(addr));\n-    addr.sun_family = AF_UNIX;\n-    strncpy(addr.sun_path, nameUtf, length);\n-    addr.sun_path[length - 1] = '\\0';\n-    ret = connect(fd, (const struct sockaddr*)&addr, sizeof(addr));\n-    if (ret == -1) {\n-        ThrowException(env, \"java\/io\/IOException\", \"socket connect error\");\n-    }\n-    (*env)->ReleaseStringUTFChars(env, name, nameUtf);\n-}\n-\n-\n-JNIEXPORT jint JNICALL Java_UnixDomainSocket_read0\n-  (JNIEnv *env, jclass cls, jint fd)\n-{\n-    int ret;\n-    unsigned char res;\n-    ret = read(fd, &res, 1);\n-    if (ret == 0)\n-        return -1; \/* EOF *\/\n-    else if (ret < 0) {\n-        ThrowException(env, \"java\/io\/IOException\", \"read error\");\n-        return -1;\n-    }\n-    return res;\n-}\n-\n-JNIEXPORT void JNICALL Java_UnixDomainSocket_write0\n-  (JNIEnv *env, jclass cls, jint fd, jint byte)\n-{\n-    int ret;\n-    unsigned char w = (unsigned char)byte;\n-    ret = write(fd, &w, 1);\n-    if (ret < 0) {\n-        ThrowException(env, \"java\/io\/IOException\", \"write error\");\n-    }\n-}\n-\n-JNIEXPORT void JNICALL Java_UnixDomainSocket_close0\n-  (JNIEnv *env, jclass cls, jint fd, jstring name)\n-{\n-    close(fd);\n-    if (name != NULL) {\n-        const char *nameUtf = (*env)->GetStringUTFChars(env, name, NULL);\n-        unlink(nameUtf);\n-        (*env)->ReleaseStringUTFChars(env, name, nameUtf);\n-    }\n-}\n","filename":"test\/jdk\/java\/nio\/channels\/spi\/SelectorProvider\/inheritedChannel\/libInheritedChannel.c","additions":1,"deletions":134,"binary":false,"changes":135,"status":"modified"},{"patch":"@@ -0,0 +1,50 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8231358\n+ * @build AddressTest DummyPath\n+ * @run main\/othervm AddressTest\n+ *\/\n+\n+import java.net.UnixDomainSocketAddress;\n+import java.nio.channels.*;\n+import java.nio.file.InvalidPathException;\n+\n+public class AddressTest {\n+\n+    static UnixDomainSocketAddress addr;\n+\n+    public static void main(String args[]) throws Exception {\n+        runTest();\n+    }\n+\n+    static void runTest() throws Exception {\n+        DummyPath path = new DummyPath();\n+        try {\n+            addr = UnixDomainSocketAddress.of(path);\n+            throw new RuntimeException(\"Expected illegal path exception\");\n+        } catch (IllegalArgumentException e) {}\n+    }\n+}\n","filename":"test\/jdk\/java\/nio\/channels\/unixdomain\/AddressTest.java","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"},{"patch":"@@ -0,0 +1,302 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.IOException;\n+import java.net.*;\n+import java.nio.channels.*;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+\n+\/**\n+ * Check that all bind variations work\n+ *\/\n+public class Bind {\n+\n+    static Path spath, cpath;\n+\n+    static UnixDomainSocketAddress sAddr, cAddr, UNNAMED, nullAddr;\n+    static ServerSocketChannel server;\n+    static SocketChannel client, accept1;\n+\n+    public static void main(String args[]) throws Exception {\n+        if (!supported()) {\n+            System.out.println(\"Unix domain channels not supported\");\n+            return;\n+        }\n+        spath = Path.of(\"server.sock\");\n+        cpath = Path.of(\"client.sock\");\n+        sAddr = UnixDomainSocketAddress.of(spath);\n+        cAddr = UnixDomainSocketAddress.of(cpath);\n+        nullAddr = UnixDomainSocketAddress.of(\"\");\n+        UNNAMED = nullAddr;\n+        runTests();\n+    }\n+\n+    static boolean supported() {\n+        try {\n+            SocketChannel.open(StandardProtocolFamily.UNIX);\n+        } catch (UnsupportedOperationException e) {\n+            return false;\n+        } catch (Exception e) {\n+            return true; \/\/ continue test to see what problem is\n+        }\n+        return true;\n+    }\n+\n+    static interface ThrowingRunnable {\n+        public void run() throws Exception;\n+    }\n+\n+    static void init() throws IOException {\n+        Files.deleteIfExists(cpath);\n+        Files.deleteIfExists(spath);\n+        client = null; server = null; accept1 = null;\n+    }\n+\n+    static void checkNormal(ThrowingRunnable r) {\n+        try {\n+            init();\n+            r.run();\n+            System.out.println(\"PASS:\");\n+        } catch (Exception e) {\n+            throw new RuntimeException(e);\n+        } finally {\n+            cleanup();\n+        }\n+    }\n+\n+    static void checkException(Class<? extends Exception> expected, ThrowingRunnable r) {\n+        try {\n+            init();\n+            r.run();\n+            throw new RuntimeException(\"Exception expected\");\n+        } catch (Exception e) {\n+            if (!expected.isAssignableFrom(e.getClass())) {\n+                String msg = \"Expected: \" + expected + \" Got: \" + e.getClass();\n+                throw new RuntimeException(msg);\n+            }\n+            System.out.println(\"PASS: Got \" + e);\n+        } finally {\n+            cleanup();\n+        }\n+    }\n+\n+    static void cleanup() {\n+        try {\n+            if (server != null)\n+                server.close();\n+            if (client != null)\n+                client.close();\n+            if (accept1 != null)\n+                accept1.close();\n+        } catch (IOException e) {}\n+    }\n+\n+    static void assertClientAddress(SocketAddress a) {\n+        assertAddress(a, cAddr, \"client\");\n+    }\n+\n+    static void assertServerAddress(SocketAddress a) {\n+        assertAddress(a, sAddr, \"server\");\n+    }\n+\n+    static void assertAddress(SocketAddress a, UnixDomainSocketAddress a1, String s) {\n+        if (!(a instanceof UnixDomainSocketAddress)) {\n+            throw new RuntimeException(\"wrong address type\");\n+        }\n+        UnixDomainSocketAddress ua = (UnixDomainSocketAddress)a;\n+        if (!a.equals(a1))\n+            throw new RuntimeException(\"this is not the \" + s + \" address\");\n+    }\n+\n+    static void assertEquals(Object a, Object b) {\n+        if (!a.equals(b))\n+            throw new RuntimeException(\"identity check failed\");\n+    }\n+\n+    public static void runTests() throws IOException {\n+        checkNormal(() -> {\n+            client = SocketChannel.open(StandardProtocolFamily.UNIX);\n+            client.bind(cAddr);\n+        });\n+        checkNormal(() -> {\n+            server = ServerSocketChannel.open(StandardProtocolFamily.UNIX);\n+            server.bind(sAddr);\n+        });\n+        \/\/ Repeat first two to make sure they are repeatable\n+        checkNormal(() -> {\n+            client = SocketChannel.open(StandardProtocolFamily.UNIX);\n+            client.bind(cAddr);\n+        });\n+        checkNormal(() -> {\n+            server = ServerSocketChannel.open(StandardProtocolFamily.UNIX);\n+            server.bind(sAddr);\n+        });\n+        \/\/ address with space should work\n+        checkNormal(() -> {\n+            server = ServerSocketChannel.open(StandardProtocolFamily.UNIX);\n+            UnixDomainSocketAddress usa =  UnixDomainSocketAddress.of(\"with space\"); \/\/ relative to CWD\n+            Files.deleteIfExists(usa.getPath());\n+            server.bind(usa);\n+            client = SocketChannel.open(usa);\n+            Files.delete(usa.getPath());\n+            assertAddress(client.getRemoteAddress(), usa, \"address\");\n+        });\n+        \/\/ client bind to null: allowed\n+        checkNormal(() -> {\n+            client = SocketChannel.open(StandardProtocolFamily.UNIX);\n+            client.bind(null);\n+            SocketAddress a = client.getLocalAddress();\n+            assertAddress(a, nullAddr, \"null address\");\n+            assertEquals(a, UNNAMED);\n+        });\n+        \/\/ server bind to null: should bind to a local address\n+        checkNormal(() -> {\n+            server = ServerSocketChannel.open(StandardProtocolFamily.UNIX);\n+            server.bind(null);\n+            UnixDomainSocketAddress usa = (UnixDomainSocketAddress)server.getLocalAddress();\n+            if (usa.getPath().toString().length() < 1)\n+                throw new RuntimeException(\"expected non zero address length\");\n+            System.out.println(\"Null server address: \" + server.getLocalAddress());\n+        });\n+        \/\/ server no bind : not allowed\n+        checkException(\n+            NotYetBoundException.class, () -> {\n+                server = ServerSocketChannel.open(StandardProtocolFamily.UNIX);\n+                server.accept();\n+            }\n+        );\n+\n+        \/\/ client implicit bind and connect\n+        checkNormal(() -> {\n+            server = ServerSocketChannel.open(StandardProtocolFamily.UNIX);\n+            client = SocketChannel.open(StandardProtocolFamily.UNIX);\n+            server.bind(sAddr);\n+            client.connect(sAddr);\n+            SocketAddress cAddr = client.getLocalAddress();\n+            assertAddress(cAddr, nullAddr, \"null address\");\n+            assertEquals(cAddr, UNNAMED);\n+            assertServerAddress(server.getLocalAddress());\n+        });\n+        \/\/ client null bind and connect (check all addresses)\n+        checkNormal(() -> {\n+            server = ServerSocketChannel.open(StandardProtocolFamily.UNIX);\n+            client = SocketChannel.open(StandardProtocolFamily.UNIX);\n+            server.bind(sAddr);\n+            client.bind(null);\n+            client.connect(sAddr);\n+            assertAddress(client.getLocalAddress(), UNNAMED, \"unnamed address\");\n+            assertServerAddress(server.getLocalAddress());\n+        });\n+        \/\/ client explicit bind and connect (check all addresses)\n+        checkNormal(() -> {\n+            server = ServerSocketChannel.open(StandardProtocolFamily.UNIX);\n+            client = SocketChannel.open(StandardProtocolFamily.UNIX);\n+            server.bind(sAddr);\n+            client.bind(cAddr);\n+            client.connect(sAddr);\n+            accept1 = server.accept();\n+            assertClientAddress(client.getLocalAddress());\n+            assertServerAddress(server.getLocalAddress());\n+            assertAddress(client.getRemoteAddress(), sAddr, \"client's remote server address\");\n+            assertAddress(accept1.getLocalAddress(), sAddr, \"accepted local address (server)\");\n+            assertAddress(accept1.getRemoteAddress(), cAddr, \"accepted remote address (client)\");\n+        });\n+        \/\/ server multiple bind : not allowed\n+        checkException(\n+            AlreadyBoundException.class, () -> {\n+                server = ServerSocketChannel.open(StandardProtocolFamily.UNIX);\n+                server.bind(sAddr);\n+                server.bind(sAddr);\n+            }\n+        );\n+        \/\/ client multiple bind : not allowed\n+        checkException(\n+            AlreadyBoundException.class, () -> {\n+                client = SocketChannel.open(StandardProtocolFamily.UNIX);\n+                client.bind(cAddr);\n+                client.bind(cAddr);\n+            }\n+        );\n+\n+        \/\/ server bind to existing name: not allowed\n+\n+        checkException(\n+            BindException.class, () -> {\n+                var path = Files.createFile(Path.of(\"moo.sock\"));\n+                var addr = UnixDomainSocketAddress.of(path);\n+                server = ServerSocketChannel.open(StandardProtocolFamily.UNIX);\n+                try {\n+                    server.bind(addr);\n+                } finally {\n+                    Files.deleteIfExists(path);\n+                }\n+            }\n+        );\n+\n+\n+        \/\/ client bind to existing name: not allowed\n+        checkException(\n+            BindException.class, () -> {\n+                var path = Path.of(\"temp.sock\");\n+                Files.deleteIfExists(path);\n+                Files.createFile(path);\n+                var addr = UnixDomainSocketAddress.of(path);\n+                client = SocketChannel.open(StandardProtocolFamily.UNIX);\n+                try {\n+                    client.bind(addr);\n+                } finally {\n+                    Files.deleteIfExists(path);\n+                }\n+            }\n+        );\n+\n+        \/\/ bind and connect to name of max size\n+        checkNormal(() -> {\n+            int len = Integer.parseInt(System.getProperty(\"jdk.nio.channels.unixdomain.maxnamelength\"));\n+            System.out.printf(\"jdk.nio.channels.unixdomain.maxnamelength = %d\\n\", len);\n+            char[] chars = new char[len];\n+            Arrays.fill(chars, 'x');\n+            String name = new String(chars);\n+            UnixDomainSocketAddress address = UnixDomainSocketAddress.of(name);\n+            ServerSocketChannel server = ServerSocketChannel.open(StandardProtocolFamily.UNIX);\n+            server.bind(address);\n+            SocketChannel client = SocketChannel.open(address);\n+            assertAddress(server.getLocalAddress(), address, \"server\");\n+            assertAddress(client.getRemoteAddress(), address, \"client\");\n+            Files.delete(address.getPath());\n+        });\n+\n+        \/\/ implicit server bind\n+        checkNormal(() -> {\n+            server = ServerSocketChannel.open(StandardProtocolFamily.UNIX);\n+            server.bind(null);\n+            UnixDomainSocketAddress usa = (UnixDomainSocketAddress)server.getLocalAddress();\n+            client = SocketChannel.open(usa);\n+            accept1 = server.accept();\n+            assertAddress(client.getRemoteAddress(), usa, \"server\");\n+            Files.delete(usa.getPath());\n+        });\n+    }\n+}\n","filename":"test\/jdk\/java\/nio\/channels\/unixdomain\/Bind.java","additions":302,"deletions":0,"binary":false,"changes":302,"status":"added"},{"patch":"@@ -0,0 +1,187 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.nio.file.*;\n+import java.nio.file.attribute.UserPrincipalLookupService;\n+import java.nio.file.spi.FileSystemProvider;\n+import java.util.Set;\n+\n+public class DummyPath implements Path {\n+\n+    FileSystem fs = new DummyFileSystem();\n+\n+    class DummyFileSystem extends FileSystem {\n+\n+        @Override\n+        public FileSystemProvider provider() {\n+            return null;\n+        }\n+\n+        @Override\n+        public void close() throws IOException {\n+\n+        }\n+\n+        @Override\n+        public boolean isOpen() {\n+            return false;\n+        }\n+\n+        @Override\n+        public boolean isReadOnly() {\n+            return false;\n+        }\n+\n+        @Override\n+        public String getSeparator() {\n+            return null;\n+        }\n+\n+        @Override\n+        public Iterable<Path> getRootDirectories() {\n+            return null;\n+        }\n+\n+        @Override\n+        public Iterable<FileStore> getFileStores() {\n+            return null;\n+        }\n+\n+        @Override\n+        public Set<String> supportedFileAttributeViews() {\n+            return null;\n+        }\n+\n+        @Override\n+        public Path getPath(String first, String... more) {\n+            return null;\n+        }\n+\n+        @Override\n+        public PathMatcher getPathMatcher(String syntaxAndPattern) {\n+            return null;\n+        }\n+\n+        @Override\n+        public UserPrincipalLookupService getUserPrincipalLookupService() {\n+            return null;\n+        }\n+\n+        @Override\n+        public WatchService newWatchService() throws IOException {\n+            return null;\n+        }\n+    }\n+\n+    @Override\n+    public FileSystem getFileSystem() {\n+        return fs;\n+    }\n+\n+    @Override\n+    public boolean isAbsolute() {\n+        return false;\n+    }\n+\n+    @Override\n+    public Path getRoot() {\n+        return null;\n+    }\n+\n+    @Override\n+    public Path getFileName() {\n+        return null;\n+    }\n+\n+    @Override\n+    public Path getParent() {\n+        return null;\n+    }\n+\n+    @Override\n+    public int getNameCount() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public Path getName(int index) {\n+        return null;\n+    }\n+\n+    @Override\n+    public Path subpath(int beginIndex, int endIndex) {\n+        return null;\n+    }\n+\n+    @Override\n+    public boolean startsWith(Path other) {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean endsWith(Path other) {\n+        return false;\n+    }\n+\n+    @Override\n+    public Path normalize() {\n+        return null;\n+    }\n+\n+    @Override\n+    public Path resolve(Path other) {\n+        return null;\n+    }\n+\n+    @Override\n+    public Path relativize(Path other) {\n+        return null;\n+    }\n+\n+    @Override\n+    public URI toUri() {\n+        return null;\n+    }\n+\n+    @Override\n+    public Path toAbsolutePath() {\n+        return null;\n+    }\n+\n+    @Override\n+    public Path toRealPath(LinkOption... options) throws IOException {\n+        return null;\n+    }\n+\n+    @Override\n+    public WatchKey register(WatchService watcher, WatchEvent.Kind<?>[] events, WatchEvent.Modifier... modifiers) throws IOException {\n+        return null;\n+    }\n+\n+    @Override\n+    public int compareTo(Path other) {\n+        return 0;\n+    }\n+}\n","filename":"test\/jdk\/java\/nio\/channels\/unixdomain\/DummyPath.java","additions":187,"deletions":0,"binary":false,"changes":187,"status":"added"},{"patch":"@@ -0,0 +1,1238 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.IOException;\n+import java.net.*;\n+import java.nio.channels.*;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Files;\n+\n+import org.testng.annotations.BeforeTest;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import static java.lang.System.out;\n+import static java.net.StandardProtocolFamily.*;\n+import static java.nio.channels.SelectionKey.OP_ACCEPT;\n+import static java.nio.channels.SelectionKey.OP_READ;\n+import static java.nio.channels.SelectionKey.OP_WRITE;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertTrue;\n+\n+public class IOExchanges {\n+    static boolean supported = true;\n+\n+\n+    @BeforeTest()\n+    public void setup() {\n+        try {SocketChannel.open(UNIX); }\n+           catch (IOException | UnsupportedOperationException e) {}\n+        int namelen = Integer.parseInt(System.getProperty(\"jdk.nio.channels.unixdomain.maxnamelength\"));\n+        if (namelen == -1) {\n+            supported = false;\n+            out.println(\"Unix domain channels not supported\");\n+        }\n+    }\n+\n+    static SocketChannel openSocketChannel(ProtocolFamily family)\n+            throws IOException {\n+        return family == UNIX ? SocketChannel.open(family)\n+                : SocketChannel.open();\n+    }\n+\n+    static ServerSocketChannel openServerSocketChannel(ProtocolFamily family)\n+             throws IOException {\n+        return family == UNIX ? ServerSocketChannel.open(family)\n+                     : ServerSocketChannel.open();\n+    }\n+\n+    public static void deleteFile(SocketAddress addr) throws Exception {\n+        if (addr instanceof UnixDomainSocketAddress) {\n+            Files.deleteIfExists(((UnixDomainSocketAddress) addr).getPath());\n+        }\n+    }\n+\n+    \/*\n+     The following, non-exhaustive set, of tests exercise different combinations\n+     of blocking and non-blocking accept\/connect calls along with I\/O\n+     operations, that exchange a single byte. The intent it to test a reasonable\n+     set of blocking and non-blocking scenarios.\n+\n+     The individual test method names follow their test scenario.\n+        [BAccep|SELNBAccep|SPINNBAccep] - Accept either:\n+                         blocking, select-non-blocking, spinning-non-blocking\n+        [BConn|NBConn] - blocking connect \/ non-blocking connect\n+        [BIO|NBIO]     - blocking \/ non-blocking I\/O operations (read\/write)\n+        [WR|RW] - connecting thread write\/accepting thread reads first, and vice-versa\n+        [Id]    - unique test Id\n+\n+        BAccep_BConn_BIO_WR_1\n+        BAccep_BConn_BIO_RW_2\n+        SELNBAccep_BConn_BIO_WR_3\n+        SELNBAccep_BConn_BIO_RW_4\n+        SPINNBAccep_BConn_BIO_WR_5\n+        SPINNBAccep_BConn_BIO_RW_6\n+        BAccep_NBConn_BIO_WR_7\n+        BAccep_NBConn_BIO_RW_8\n+        SELNBAccep_NBConn_BIO_WR_9\n+        SELNBAccep_NBConn_BIO_RW_10\n+        SPINNBAccep_NBConn_BIO_WR_11\n+        SPINNBAccep_NBConn_BIO_RW_12\n+\n+        BAccep_BConn_NBIO_WR_1a         \/\/ Non-Blocking I\/O\n+        BAccep_BConn_NBIO_RW_2a\n+        SELNBAccep_BConn_NBIO_WR_3a\n+        SELNBAccep_BConn_NBIO_RW_4a\n+        SPINNBAccep_BConn_NBIO_WR_5a\n+        SPINNBAccep_BConn_NBIO_RW_6a\n+        BAccep_NBConn_NBIO_WR_7a\n+        BAccep_NBConn_NBIO_RW_8a\n+        SELNBAccep_NBConn_NBIO_WR_9a\n+        SELNBAccep_NBConn_NBIO_RW_10a\n+        SPINBAccep_NBConn_NBIO_WR_11a\n+        SPINBAccep_NBConn_NBIO_RW_12a\n+    *\/\n+\n+    @DataProvider(name = \"family\")\n+    public Object[][] family() {\n+        return supported ?\n+                new Object[][] {\n+                    { UNIX },\n+                    { INET }}\n+                : new Object[][] {\n+                    { INET }\n+        };\n+    }\n+\n+    @Test(dataProvider = \"family\")\n+    public void BAccep_BConn_BIO_WR_1(ProtocolFamily family)\n+            throws Throwable {\n+        try (ServerSocketChannel ssc = openServerSocketChannel(family)) {\n+            ssc.bind(null);\n+            SocketAddress addr = ssc.getLocalAddress();\n+\n+            TestThread t = TestThread.of(\"t1\", () -> {\n+                try (SocketChannel sc = openSocketChannel(family)) {\n+                    assertTrue(sc.connect(addr));\n+                    ByteBuffer bb = ByteBuffer.allocate(10).put((byte) 0x01).flip();\n+                    assertEquals(sc.write(bb), 1);\n+                    out.printf(\"wrote: 0x%x%n\", bb.get(0));\n+                    assertEquals(sc.read(bb.clear()), -1);\n+                }\n+            });\n+            t.start();\n+\n+            try (SocketChannel sc = ssc.accept()) {\n+                ByteBuffer bb = ByteBuffer.allocate(10);\n+                assertEquals(sc.read(bb), 1);\n+                out.printf(\"read:  0x%x%n\", bb.get(0));\n+                assertEquals(bb.get(0), 0x01);\n+            }\n+            t.awaitCompletion();\n+            deleteFile(addr);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"family\")\n+    public void BAccep_BConn_BIO_RW_2(ProtocolFamily family)\n+            throws Throwable {\n+        try (ServerSocketChannel ssc = openServerSocketChannel(family)) {\n+            ssc.bind(null);\n+            SocketAddress addr = ssc.getLocalAddress();\n+\n+            TestThread t = TestThread.of(\"t2\", () -> {\n+                try (SocketChannel sc = openSocketChannel(family)) {\n+                    assertTrue(sc.connect(addr));\n+                    ByteBuffer bb = ByteBuffer.allocate(10);\n+                    assertEquals(sc.read(bb), 1);\n+                    out.printf(\"read:  0x%x%n\", bb.get(0));\n+                    assertEquals(bb.get(0), 0x02);\n+                }\n+            });\n+            t.start();\n+\n+            try (SocketChannel sc = ssc.accept()) {\n+                ByteBuffer bb = ByteBuffer.allocate(10).put((byte) 0x02).flip();\n+                assertEquals(sc.write(bb), 1);\n+                out.printf(\"wrote: 0x%x%n\", bb.get(0));\n+                assertEquals(sc.read(bb.clear()), -1);\n+            }\n+            t.awaitCompletion();\n+            deleteFile(addr);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"family\")\n+    public void SELNBAccep_BConn_BIO_WR_3(ProtocolFamily family)\n+            throws Throwable {\n+        try (ServerSocketChannel ssc = openServerSocketChannel(family);\n+             Selector selector = Selector.open()) {\n+            ssc.bind(null);\n+            SocketAddress addr = ssc.getLocalAddress();\n+\n+            TestThread t = TestThread.of(\"t3\", () -> {\n+                try (SocketChannel sc = openSocketChannel(family)) {\n+                    assertTrue(sc.connect(addr));\n+                    ByteBuffer bb = ByteBuffer.allocate(10).put((byte) 0x03).flip();\n+                    assertEquals(sc.write(bb), 1);\n+                    out.printf(\"wrote: 0x%x%n\", bb.get(0));\n+                    assertEquals(sc.read(bb.clear()), -1);\n+                }\n+            });\n+            t.start();\n+\n+            ssc.configureBlocking(false).register(selector, OP_ACCEPT);\n+            assertEquals(selector.select(), 1);\n+\n+            try (SocketChannel sc = ssc.accept()) {\n+                ByteBuffer bb = ByteBuffer.allocate(10);\n+                assertEquals(sc.read(bb), 1);\n+                out.printf(\"read:  0x%x%n\", bb.get(0));\n+                assertEquals(bb.get(0), 0x03);\n+            }\n+            t.awaitCompletion();\n+            deleteFile(addr);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"family\")\n+    public void SELNBAccep_BConn_BIO_RW_4(ProtocolFamily family)\n+            throws Throwable {\n+        try (ServerSocketChannel ssc = openServerSocketChannel(family);\n+             Selector selector = Selector.open()) {\n+            ssc.bind(null);\n+            SocketAddress addr = ssc.getLocalAddress();\n+\n+            TestThread t = TestThread.of(\"t4\", () -> {\n+                try (SocketChannel sc = openSocketChannel(family)) {\n+                    assertTrue(sc.connect(addr));\n+                    ByteBuffer bb = ByteBuffer.allocate(10);\n+                    assertEquals(sc.read(bb), 1);\n+                    out.printf(\"read:  0x%x%n\", bb.get(0));\n+                    assertEquals(bb.get(0), 0x04);\n+                }\n+            });\n+            t.start();\n+\n+            ssc.configureBlocking(false).register(selector, OP_ACCEPT);\n+            assertEquals(selector.select(), 1);\n+\n+            try (SocketChannel sc = ssc.accept()) {\n+                ByteBuffer bb = ByteBuffer.allocate(10).put((byte) 0x04).flip();\n+                assertEquals(sc.write(bb), 1);\n+                out.printf(\"wrote: 0x%x%n\", bb.get(0));\n+                assertEquals(sc.read(bb.clear()), -1);\n+\n+            }\n+            t.awaitCompletion();\n+            deleteFile(addr);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"family\")\n+    public void SPINNBAccep_BConn_BIO_WR_5(ProtocolFamily family)\n+            throws Throwable {\n+        try (ServerSocketChannel ssc = openServerSocketChannel(family)) {\n+            ssc.bind(null);\n+            SocketAddress addr = ssc.getLocalAddress();\n+\n+            TestThread t = TestThread.of(\"t5\", () -> {\n+                try (SocketChannel sc = openSocketChannel(family)) {\n+                    assertTrue(sc.connect(addr));\n+                    ByteBuffer bb = ByteBuffer.allocate(10).put((byte) 0x05).flip();\n+                    assertEquals(sc.write(bb), 1);\n+                    out.printf(\"wrote: 0x%x%n\", bb.get(0));\n+                    assertEquals(sc.read(bb.clear()), -1);\n+                }\n+            });\n+            t.start();\n+\n+            SocketChannel accepted;\n+            for (; ; ) {\n+                accepted = ssc.accept();\n+                if (accepted != null) {\n+                    out.println(\"accepted new connection\");\n+                    break;\n+                }\n+                Thread.onSpinWait();\n+            }\n+\n+            try (SocketChannel sc = accepted) {\n+                ByteBuffer bb = ByteBuffer.allocate(10);\n+                assertEquals(sc.read(bb), 1);\n+                out.printf(\"read:  0x%x%n\", bb.get(0));\n+                assertEquals(bb.get(0), 0x05);\n+            }\n+            t.awaitCompletion();\n+            deleteFile(addr);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"family\")\n+    public void SPINNBAccep_BConn_BIO_RW_6(ProtocolFamily family)\n+            throws Throwable {\n+        try (ServerSocketChannel ssc = openServerSocketChannel(family)) {\n+            ssc.bind(null);\n+            SocketAddress addr = ssc.getLocalAddress();\n+\n+            TestThread t = TestThread.of(\"t6\", () -> {\n+                try (SocketChannel sc = openSocketChannel(family)) {\n+                    assertTrue(sc.connect(addr));\n+                    ByteBuffer bb = ByteBuffer.allocate(10);\n+                    assertEquals(sc.read(bb), 1);\n+                    out.printf(\"read:  0x%x%n\", bb.get(0));\n+                    assertEquals(bb.get(0), 0x06);\n+                }\n+            });\n+            t.start();\n+\n+            SocketChannel accepted;\n+            for (; ; ) {\n+                accepted = ssc.accept();\n+                if (accepted != null) {\n+                    out.println(\"accepted new connection\");\n+                    break;\n+                }\n+                Thread.onSpinWait();\n+            }\n+\n+            try (SocketChannel sc = accepted) {\n+                ByteBuffer bb = ByteBuffer.allocate(10).put((byte) 0x06).flip();\n+                assertEquals(sc.write(bb), 1);\n+                out.printf(\"wrote: 0x%x%n\", bb.get(0));\n+                assertEquals(sc.read(bb.clear()), -1);\n+\n+            }\n+            t.awaitCompletion();\n+            deleteFile(addr);\n+        }\n+    }\n+\n+    \/\/ Similar to the previous six scenarios, but with same-thread\n+    \/\/ non-blocking connect.\n+\n+    @Test(dataProvider = \"family\")\n+    public void BAccep_NBConn_BIO_WR_7(ProtocolFamily family)\n+            throws Throwable {\n+        try (ServerSocketChannel ssc = openServerSocketChannel(family)) {\n+            ssc.bind(null);\n+            SocketAddress addr = ssc.getLocalAddress();\n+\n+            try (SocketChannel sc = openSocketChannel(family)) {\n+                sc.configureBlocking(false);\n+                sc.connect(addr);\n+\n+                try (SocketChannel sc2 = ssc.accept()) {\n+                    assertTrue(sc.finishConnect());\n+                    sc.configureBlocking(true);\n+                    TestThread t = TestThread.of(\"t7\", () -> {\n+                        ByteBuffer bb = ByteBuffer.allocate(10).put((byte) 0x07).flip();\n+                        assertEquals(sc.write(bb), 1);\n+                        out.printf(\"wrote: 0x%x%n\", bb.get(0));\n+                        assertEquals(sc.read(bb.clear()), -1);\n+                    });\n+                    t.start();\n+\n+                    ByteBuffer bb = ByteBuffer.allocate(10);\n+                    assertEquals(sc2.read(bb), 1);\n+                    out.printf(\"read:  0x%x%n\", bb.get(0));\n+                    assertEquals(bb.get(0), 0x07);\n+                    sc2.shutdownOutput();\n+                    t.awaitCompletion();\n+                }\n+            }\n+            deleteFile(addr);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"family\")\n+    public void BAccep_NBConn_BIO_RW_8(ProtocolFamily family)\n+            throws Throwable {\n+        try (ServerSocketChannel ssc = openServerSocketChannel(family)) {\n+            ssc.bind(null);\n+            SocketAddress addr = ssc.getLocalAddress();\n+\n+            try (SocketChannel sc = openSocketChannel(family)) {\n+                sc.configureBlocking(false);\n+                sc.connect(addr);\n+\n+                try (SocketChannel sc2 = ssc.accept()) {\n+                    assertTrue(sc.finishConnect());\n+                    sc.configureBlocking(true);\n+                    TestThread t = TestThread.of(\"t8\", () -> {\n+                        ByteBuffer bb = ByteBuffer.allocate(10);\n+                        assertEquals(sc.read(bb), 1);\n+                        out.printf(\"read:  0x%x%n\", bb.get(0));\n+                        assertEquals(bb.get(0), 0x08);\n+                        sc.shutdownOutput();\n+                    });\n+                    t.start();\n+\n+                    ByteBuffer bb = ByteBuffer.allocate(10).put((byte) 0x08).flip();\n+                    assertEquals(sc2.write(bb), 1);\n+                    out.printf(\"wrote: 0x%x%n\", bb.get(0));\n+                    assertEquals(sc2.read(bb.clear()), -1);\n+                    t.awaitCompletion();\n+                }\n+            }\n+            deleteFile(addr);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"family\")\n+    public void SELNBAccep_NBConn_BIO_WR_9(ProtocolFamily family)\n+            throws Throwable {\n+        try (ServerSocketChannel ssc = openServerSocketChannel(family)) {\n+            ssc.bind(null);\n+            SocketAddress addr = ssc.getLocalAddress();\n+\n+            try (SocketChannel sc = openSocketChannel(family);\n+                 Selector selector = Selector.open()) {\n+                sc.configureBlocking(false);\n+                sc.connect(addr);\n+\n+                ssc.configureBlocking(false).register(selector, OP_ACCEPT);\n+                assertEquals(selector.select(), 1);\n+\n+                try (SocketChannel sc2 = ssc.accept()) {\n+                    assertTrue(sc.finishConnect());\n+                    sc.configureBlocking(true);\n+                    TestThread t = TestThread.of(\"t9\", () -> {\n+                        ByteBuffer bb = ByteBuffer.allocate(10).put((byte) 0x09).flip();\n+                        assertEquals(sc.write(bb), 1);\n+                        out.printf(\"wrote: 0x%x%n\", bb.get(0));\n+                        assertEquals(sc.read(bb.clear()), -1);\n+                    });\n+                    t.start();\n+\n+                    ByteBuffer bb = ByteBuffer.allocate(10);\n+                    assertEquals(sc2.read(bb), 1);\n+                    out.printf(\"read:  0x%x%n\", bb.get(0));\n+                    assertEquals(bb.get(0), 0x09);\n+                    sc2.shutdownOutput();\n+                    t.awaitCompletion();\n+                }\n+            }\n+            deleteFile(addr);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"family\")\n+    public void SELNBAccep_NBConn_BIO_RW_10(ProtocolFamily family)\n+            throws Throwable {\n+        try (ServerSocketChannel ssc = openServerSocketChannel(family)) {\n+            ssc.bind(null);\n+            SocketAddress addr = ssc.getLocalAddress();\n+\n+            try (SocketChannel sc = openSocketChannel(family);\n+                 Selector selector = Selector.open()) {\n+                sc.configureBlocking(false);\n+                sc.connect(addr);\n+\n+                ssc.configureBlocking(false).register(selector, OP_ACCEPT);\n+                assertEquals(selector.select(), 1);\n+\n+                try (SocketChannel sc2 = ssc.accept()) {\n+                    assertTrue(sc.finishConnect());\n+                    sc.configureBlocking(true);\n+                    TestThread t = TestThread.of(\"t10\", () -> {\n+                        ByteBuffer bb = ByteBuffer.allocate(10);\n+                        assertEquals(sc.read(bb), 1);\n+                        out.printf(\"read:  0x%x%n\", bb.get(0));\n+                        assertEquals(bb.get(0), 0x10);\n+                        sc.shutdownOutput();\n+                    });\n+                    t.start();\n+\n+                    ByteBuffer bb = ByteBuffer.allocate(10).put((byte) 0x10).flip();\n+                    assertEquals(sc2.write(bb), 1);\n+                    out.printf(\"wrote: 0x%x%n\", bb.get(0));\n+                    assertEquals(sc2.read(bb.clear()), -1);\n+                    t.awaitCompletion();\n+                }\n+            }\n+            deleteFile(addr);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"family\")\n+    public void SPINNBAccep_NBConn_BIO_WR_11(ProtocolFamily family)\n+            throws Throwable {\n+        try (ServerSocketChannel ssc = openServerSocketChannel(family)) {\n+            ssc.bind(null);\n+            SocketAddress addr = ssc.getLocalAddress();\n+\n+            try (SocketChannel sc = openSocketChannel(family)) {\n+                sc.configureBlocking(false);\n+                sc.connect(addr);\n+\n+                SocketChannel accepted;\n+                for (; ; ) {\n+                    accepted = ssc.accept();\n+                    if (accepted != null) {\n+                        out.println(\"accepted new connection\");\n+                        break;\n+                    }\n+                    Thread.onSpinWait();\n+                }\n+\n+                try (SocketChannel sc2 = accepted) {\n+                    assertTrue(sc.finishConnect());\n+                    sc.configureBlocking(true);\n+                    TestThread t = TestThread.of(\"t11\", () -> {\n+                        ByteBuffer bb = ByteBuffer.allocate(10).put((byte) 0x11).flip();\n+                        assertEquals(sc.write(bb), 1);\n+                        out.printf(\"wrote: 0x%x%n\", bb.get(0));\n+                        assertEquals(sc.read(bb.clear()), -1);\n+                    });\n+                    t.start();\n+\n+                    ByteBuffer bb = ByteBuffer.allocate(10);\n+                    assertEquals(sc2.read(bb), 1);\n+                    out.printf(\"read:  0x%x%n\", bb.get(0));\n+                    assertEquals(bb.get(0), 0x11);\n+                    sc2.shutdownOutput();\n+                    t.awaitCompletion();\n+                }\n+            }\n+            deleteFile(addr);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"family\")\n+    public void SPINNBAccep_NBConn_BIO_RW_12(ProtocolFamily family)\n+            throws Throwable {\n+        try (ServerSocketChannel ssc = openServerSocketChannel(family)) {\n+            ssc.bind(null);\n+            SocketAddress addr = ssc.getLocalAddress();\n+\n+            try (SocketChannel sc = openSocketChannel(family)) {\n+                sc.configureBlocking(false);\n+                sc.connect(addr);\n+\n+                SocketChannel accepted;\n+                for (; ; ) {\n+                    accepted = ssc.accept();\n+                    if (accepted != null) {\n+                        out.println(\"accepted new connection\");\n+                        break;\n+                    }\n+                    Thread.onSpinWait();\n+                }\n+\n+                try (SocketChannel sc2 = accepted) {\n+                    assertTrue(sc.finishConnect());\n+                    sc.configureBlocking(true);\n+                    TestThread t = TestThread.of(\"t12\", () -> {\n+                        ByteBuffer bb = ByteBuffer.allocate(10);\n+                        assertEquals(sc.read(bb), 1);\n+                        out.printf(\"read:  0x%x%n\", bb.get(0));\n+                        assertEquals(bb.get(0), 0x12);\n+                        sc.shutdownOutput();\n+                    });\n+                    t.start();\n+\n+                    ByteBuffer bb = ByteBuffer.allocate(10).put((byte) 0x12).flip();\n+                    assertEquals(sc2.write(bb), 1);\n+                    out.printf(\"wrote: 0x%x%n\", bb.get(0));\n+                    assertEquals(sc2.read(bb.clear()), -1);\n+                    t.awaitCompletion();\n+                }\n+            }\n+            deleteFile(addr);\n+        }\n+    }\n+\n+    \/\/ ---\n+    \/\/ Similar to the previous twelve scenarios but with non-blocking IO\n+    \/\/ ---\n+\n+    @Test(dataProvider = \"family\")\n+    public void BAccep_BConn_NBIO_WR_1a(ProtocolFamily family)\n+            throws Throwable {\n+        try (ServerSocketChannel ssc = openServerSocketChannel(family)) {\n+            ssc.bind(null);\n+            SocketAddress addr = ssc.getLocalAddress();\n+\n+            TestThread t = TestThread.of(\"t1a\", () -> {\n+                try (SocketChannel sc = openSocketChannel(family);\n+                     Selector selector = Selector.open()) {\n+                    assertTrue(sc.connect(addr));\n+                    ByteBuffer bb = ByteBuffer.allocate(10).put((byte) 0x1A).flip();\n+                    sc.configureBlocking(false);\n+                    SelectionKey k = sc.register(selector, OP_WRITE);\n+                    selector.select();\n+                    int c;\n+                    while ((c = sc.write(bb)) < 1) ;\n+                    assertEquals(c, 1);\n+                    out.printf(\"wrote: 0x%x%n\", bb.get(0));\n+                    k.interestOps(OP_READ);\n+                    selector.select();\n+                    bb.clear();\n+                    while ((c = sc.read(bb)) == 0) ;\n+                    assertEquals(c, -1);\n+                }\n+            });\n+            t.start();\n+\n+            try (SocketChannel sc = ssc.accept();\n+                 Selector selector = Selector.open()) {\n+                ByteBuffer bb = ByteBuffer.allocate(10);\n+                sc.configureBlocking(false);\n+                sc.register(selector, OP_READ);\n+                selector.select();\n+                int c;\n+                while ((c = sc.read(bb)) == 0) ;\n+                assertEquals(c, 1);\n+                out.printf(\"read:  0x%x%n\", bb.get(0));\n+                assertEquals(bb.get(0), 0x1A);\n+            }\n+            t.awaitCompletion();\n+            deleteFile(addr);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"family\")\n+    public void BAccep_BConn_NBIO_RW_2a(ProtocolFamily family)\n+            throws Throwable {\n+        try (ServerSocketChannel ssc = openServerSocketChannel(family)) {\n+            ssc.bind(null);\n+            SocketAddress addr = ssc.getLocalAddress();\n+\n+            TestThread t = TestThread.of(\"t2a\", () -> {\n+                try (SocketChannel sc = openSocketChannel(family);\n+                     Selector selector = Selector.open()) {\n+                    assertTrue(sc.connect(addr));\n+                    ByteBuffer bb = ByteBuffer.allocate(10);\n+                    sc.configureBlocking(false);\n+                    sc.register(selector, OP_READ);\n+                    selector.select();\n+                    int c;\n+                    while ((c = sc.read(bb)) == 0) ;\n+                    assertEquals(c, 1);\n+                    out.printf(\"read:  0x%x%n\", bb.get(0));\n+                    assertEquals(bb.get(0), 0x2A);\n+                }\n+            });\n+            t.start();\n+\n+            try (SocketChannel sc = ssc.accept();\n+                 Selector selector = Selector.open()) {\n+                ByteBuffer bb = ByteBuffer.allocate(10).put((byte) 0x2A).flip();\n+                sc.configureBlocking(false);\n+                SelectionKey k = sc.register(selector, OP_WRITE);\n+                selector.select();\n+                int c;\n+                while ((c = sc.write(bb)) < 1) ;\n+                assertEquals(c, 1);\n+                out.printf(\"wrote: 0x%x%n\", bb.get(0));\n+                k.interestOps(OP_READ);\n+                selector.select();\n+                bb.clear();\n+                while ((c = sc.read(bb)) == 0) ;\n+                assertEquals(c, -1);\n+            }\n+            t.awaitCompletion();\n+            deleteFile(addr);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"family\")\n+    public void SELNBAccep_BConn_NBIO_WR_3a(ProtocolFamily family)\n+            throws Throwable {\n+        try (ServerSocketChannel ssc = openServerSocketChannel(family);\n+             Selector aselector = Selector.open()) {\n+            ssc.bind(null);\n+            SocketAddress addr = ssc.getLocalAddress();\n+\n+            TestThread t = TestThread.of(\"t3a\", () -> {\n+                try (SocketChannel sc = openSocketChannel(family);\n+                     Selector selector = Selector.open()) {\n+                    assertTrue(sc.connect(addr));\n+                    ByteBuffer bb = ByteBuffer.allocate(10).put((byte) 0x3A).flip();\n+                    sc.configureBlocking(false);\n+                    SelectionKey k = sc.register(selector, OP_WRITE);\n+                    selector.select();\n+                    int c;\n+                    while ((c = sc.write(bb)) < 1) ;\n+                    assertEquals(c, 1);\n+                    out.printf(\"wrote: 0x%x%n\", bb.get(0));\n+                    k.interestOps(OP_READ);\n+                    selector.select();\n+                    bb.clear();\n+                    while ((c = sc.read(bb)) == 0) ;\n+                    assertEquals(c, -1);\n+                }\n+            });\n+            t.start();\n+\n+            ssc.configureBlocking(false).register(aselector, OP_ACCEPT);\n+            assertEquals(aselector.select(), 1);\n+\n+            try (SocketChannel sc = ssc.accept();\n+                 Selector selector = Selector.open()) {\n+                ByteBuffer bb = ByteBuffer.allocate(10);\n+                sc.configureBlocking(false);\n+                sc.register(selector, OP_READ);\n+                selector.select();\n+                int c;\n+                while ((c = sc.read(bb)) == 0) ;\n+                assertEquals(c, 1);\n+                out.printf(\"read:  0x%x%n\", bb.get(0));\n+                assertEquals(bb.get(0), 0x3A);\n+            }\n+            t.awaitCompletion();\n+            deleteFile(addr);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"family\")\n+    public void SELNBAccep_BConn_NBIO_RW_4a(ProtocolFamily family)\n+            throws Throwable {\n+        try (ServerSocketChannel ssc = openServerSocketChannel(family);\n+             Selector aselector = Selector.open()) {\n+            ssc.bind(null);\n+            SocketAddress addr = ssc.getLocalAddress();\n+\n+            TestThread t = TestThread.of(\"t4a\", () -> {\n+                try (SocketChannel sc = openSocketChannel(family);\n+                     Selector selector = Selector.open()) {\n+                    assertTrue(sc.connect(addr));\n+                    ByteBuffer bb = ByteBuffer.allocate(10);\n+                    sc.configureBlocking(false);\n+                    sc.register(selector, OP_READ);\n+                    selector.select();\n+                    int c;\n+                    while ((c = sc.read(bb)) == 0) ;\n+                    assertEquals(c, 1);\n+                    out.printf(\"read:  0x%x%n\", bb.get(0));\n+                    assertEquals(bb.get(0), 0x4A);\n+                }\n+            });\n+            t.start();\n+\n+            ssc.configureBlocking(false).register(aselector, OP_ACCEPT);\n+            assertEquals(aselector.select(), 1);\n+\n+            try (SocketChannel sc = ssc.accept();\n+                 Selector selector = Selector.open()) {\n+                ByteBuffer bb = ByteBuffer.allocate(10).put((byte) 0x4A).flip();\n+                sc.configureBlocking(false);\n+                SelectionKey k = sc.register(selector, OP_WRITE);\n+                selector.select();\n+                int c;\n+                while ((c = sc.write(bb)) < 1) ;\n+                assertEquals(c, 1);\n+                out.printf(\"wrote: 0x%x%n\", bb.get(0));\n+                k.interestOps(OP_READ);\n+                selector.select();\n+                bb.clear();\n+                while ((c = sc.read(bb)) == 0) ;\n+                assertEquals(c, -1);\n+            }\n+            t.awaitCompletion();\n+            deleteFile(addr);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"family\")\n+    public void SPINNBAccep_BConn_NBIO_WR_5a(ProtocolFamily family)\n+            throws Throwable {\n+        try (ServerSocketChannel ssc = openServerSocketChannel(family)) {\n+            ssc.bind(null);\n+            SocketAddress addr = ssc.getLocalAddress();\n+\n+            TestThread t = TestThread.of(\"t5a\", () -> {\n+                try (SocketChannel sc = openSocketChannel(family);\n+                     Selector selector = Selector.open()) {\n+                    assertTrue(sc.connect(addr));\n+                    ByteBuffer bb = ByteBuffer.allocate(10).put((byte) 0x5A).flip();\n+                    sc.configureBlocking(false);\n+                    SelectionKey k = sc.register(selector, OP_WRITE);\n+                    selector.select();\n+                    int c;\n+                    while ((c = sc.write(bb)) < 1) ;\n+                    assertEquals(c, 1);\n+                    out.printf(\"wrote: 0x%x%n\", bb.get(0));\n+                    k.interestOps(OP_READ);\n+                    selector.select();\n+                    bb.clear();\n+                    while ((c = sc.read(bb)) == 0) ;\n+                    assertEquals(c, -1);\n+                }\n+            });\n+            t.start();\n+\n+            SocketChannel accepted;\n+            for (; ; ) {\n+                accepted = ssc.accept();\n+                if (accepted != null) {\n+                    out.println(\"accepted new connection\");\n+                    break;\n+                }\n+                Thread.onSpinWait();\n+            }\n+\n+            try (SocketChannel sc = accepted;\n+                 Selector selector = Selector.open()) {\n+                ByteBuffer bb = ByteBuffer.allocate(10);\n+                sc.configureBlocking(false);\n+                sc.register(selector, OP_READ);\n+                selector.select();\n+                int c;\n+                while ((c = sc.read(bb)) == 0) ;\n+                assertEquals(c, 1);\n+                out.printf(\"read:  0x%x%n\", bb.get(0));\n+                assertEquals(bb.get(0), 0x5A);\n+            }\n+            t.awaitCompletion();\n+            deleteFile(addr);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"family\")\n+    public void SPINNBAccep_BConn_NBIO_RW_6a(ProtocolFamily family)\n+            throws Throwable {\n+        try (ServerSocketChannel ssc = openServerSocketChannel(family)) {\n+            ssc.bind(null);\n+            SocketAddress addr = ssc.getLocalAddress();\n+\n+            TestThread t = TestThread.of(\"t6a\", () -> {\n+                try (SocketChannel sc = openSocketChannel(family);\n+                     Selector selector = Selector.open()) {\n+                    assertTrue(sc.connect(addr));\n+                    ByteBuffer bb = ByteBuffer.allocate(10);\n+                    sc.configureBlocking(false);\n+                    sc.register(selector, OP_READ);\n+                    selector.select();\n+                    int c;\n+                    while ((c = sc.read(bb)) == 0) ;\n+                    assertEquals(c, 1);\n+                    out.printf(\"read:  0x%x%n\", bb.get(0));\n+                    assertEquals(bb.get(0), 0x6A);\n+                }\n+            });\n+            t.start();\n+\n+            SocketChannel accepted;\n+            for (; ; ) {\n+                accepted = ssc.accept();\n+                if (accepted != null) {\n+                    out.println(\"accepted new connection\");\n+                    break;\n+                }\n+                Thread.onSpinWait();\n+            }\n+\n+            try (SocketChannel sc = accepted;\n+                 Selector selector = Selector.open()) {\n+                ByteBuffer bb = ByteBuffer.allocate(10).put((byte) 0x6A).flip();\n+                sc.configureBlocking(false);\n+                SelectionKey k = sc.register(selector, OP_WRITE);\n+                selector.select();\n+                int c;\n+                while ((c = sc.write(bb)) < 1) ;\n+                assertEquals(c, 1);\n+                out.printf(\"wrote: 0x%x%n\", bb.get(0));\n+                k.interestOps(OP_READ);\n+                selector.select();\n+                bb.clear();\n+                while ((c = sc.read(bb)) == 0) ;\n+                assertEquals(c, -1);\n+\n+            }\n+            t.awaitCompletion();\n+            deleteFile(addr);\n+        }\n+    }\n+\n+    \/\/ Similar to the previous six scenarios but with same-thread\n+    \/\/ non-blocking connect.\n+\n+    @Test(dataProvider = \"family\")\n+    public void BAccep_NBConn_NBIO_WR_7a(ProtocolFamily family)\n+            throws Throwable {\n+        try (ServerSocketChannel ssc = openServerSocketChannel(family)) {\n+            ssc.bind(null);\n+            SocketAddress addr = ssc.getLocalAddress();\n+\n+            try (SocketChannel sc = openSocketChannel(family)) {\n+                sc.configureBlocking(false);\n+                sc.connect(addr);\n+\n+                try (SocketChannel sc2 = ssc.accept()) {\n+                    assertTrue(sc.finishConnect());\n+                    TestThread t = TestThread.of(\"t7a\", () -> {\n+                        try (Selector selector = Selector.open()) {\n+                            ByteBuffer bb = ByteBuffer.allocate(10).put((byte) 0x7A).flip();\n+                            sc.configureBlocking(false);\n+                            SelectionKey k = sc.register(selector, OP_WRITE);\n+                            selector.select();\n+                            int c;\n+                            while ((c = sc.write(bb)) < 1) ;\n+                            assertEquals(c, 1);\n+                            out.printf(\"wrote: 0x%x%n\", bb.get(0));\n+                            k.interestOps(OP_READ);\n+                            selector.select();\n+                            bb.clear();\n+                            while ((c = sc.read(bb)) == 0) ;\n+                            assertEquals(c, -1);\n+                        }\n+                    });\n+                    t.start();\n+\n+                    ByteBuffer bb = ByteBuffer.allocate(10);\n+                    sc2.configureBlocking(false);\n+                    try (Selector selector = Selector.open()) {\n+                        sc2.register(selector, OP_READ);\n+                        selector.select();\n+                        int c;\n+                        while ((c = sc2.read(bb)) == 0) ;\n+                        assertEquals(c, 1);\n+                        out.printf(\"read:  0x%x%n\", bb.get(0));\n+                        assertEquals(bb.get(0), 0x7A);\n+                        sc2.shutdownOutput();\n+                    }\n+                    t.awaitCompletion();\n+                }\n+            }\n+            deleteFile(addr);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"family\")\n+    public void BAccep_NBConn_NBIO_RW_8a(ProtocolFamily family)\n+            throws Throwable {\n+        try (ServerSocketChannel ssc = openServerSocketChannel(family)) {\n+            ssc.bind(null);\n+            SocketAddress addr = ssc.getLocalAddress();\n+\n+            try (SocketChannel sc = openSocketChannel(family)) {\n+                sc.configureBlocking(false);\n+                sc.connect(addr);\n+\n+                try (SocketChannel sc2 = ssc.accept()) {\n+                    assertTrue(sc.finishConnect());\n+                    TestThread t = TestThread.of(\"t8a\", () -> {\n+                        try (Selector selector = Selector.open()) {\n+                            ByteBuffer bb = ByteBuffer.allocate(10);\n+                            sc.register(selector, OP_READ);\n+                            selector.select();\n+                            int c;\n+                            while ((c = sc.read(bb)) == 0) ;\n+                            assertEquals(c, 1);\n+                            out.printf(\"read:  0x%x%n\", bb.get(0));\n+                            assertEquals(bb.get(0), (byte) 0x8A);\n+                            sc.shutdownOutput();\n+                        }\n+                    });\n+                    t.start();\n+\n+                    ByteBuffer bb = ByteBuffer.allocate(10).put((byte) 0x8A).flip();\n+                    sc2.configureBlocking(false);\n+                    try (Selector selector = Selector.open()) {\n+                        SelectionKey k = sc2.register(selector, OP_WRITE);\n+                        selector.select();\n+                        int c;\n+                        while ((c = sc2.write(bb)) < 1) ;\n+                        assertEquals(c, 1);\n+                        out.printf(\"wrote: 0x%x%n\", bb.get(0));\n+                        k.interestOps(OP_READ);\n+                        selector.select();\n+                        bb.clear();\n+                        while ((c = sc2.read(bb)) == 0) ;\n+                        assertEquals(c, -1);\n+                    }\n+                    t.awaitCompletion();\n+                }\n+            }\n+            deleteFile(addr);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"family\")\n+    public void SELNBAccep_NBConn_NBIO_WR_9a(ProtocolFamily family)\n+            throws Throwable {\n+        try (ServerSocketChannel ssc = openServerSocketChannel(family)) {\n+            ssc.bind(null);\n+            SocketAddress addr = ssc.getLocalAddress();\n+\n+            try (SocketChannel sc = openSocketChannel(family)) {\n+                sc.configureBlocking(false);\n+                sc.connect(addr);\n+\n+                Selector aselector = Selector.open();\n+                ssc.configureBlocking(false).register(aselector, OP_ACCEPT);\n+                assertEquals(aselector.select(), 1);\n+\n+                try (SocketChannel sc2 = ssc.accept()) {\n+                    assertTrue(sc.finishConnect());\n+                    TestThread t = TestThread.of(\"t9a\", () -> {\n+                        try (Selector selector = Selector.open()) {\n+                            ByteBuffer bb = ByteBuffer.allocate(10).put((byte) 0x9A).flip();\n+                            sc.configureBlocking(false);\n+                            SelectionKey k = sc.register(selector, OP_WRITE);\n+                            selector.select();\n+                            int c;\n+                            while ((c = sc.write(bb)) < 1) ;\n+                            assertEquals(c, 1);\n+                            out.printf(\"wrote: 0x%x%n\", bb.get(0));\n+                            k.interestOps(OP_READ);\n+                            selector.select();\n+                            bb.clear();\n+                            while ((c = sc.read(bb)) == 0) ;\n+                            assertEquals(c, -1);\n+                        }\n+                    });\n+                    t.start();\n+\n+                    ByteBuffer bb = ByteBuffer.allocate(10);\n+                    sc2.configureBlocking(false);\n+                    try (Selector selector = Selector.open()) {\n+                        sc2.register(selector, OP_READ);\n+                        selector.select();\n+                        int c;\n+                        while ((c = sc2.read(bb)) == 0) ;\n+                        assertEquals(c, 1);\n+                        out.printf(\"read:  0x%x%n\", bb.get(0));\n+                        assertEquals(bb.get(0), (byte) 0x9A);\n+                        sc2.shutdownOutput();\n+                    }\n+                    t.awaitCompletion();\n+                }\n+            }\n+            deleteFile(addr);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"family\")\n+    public void SELNBAccep_NBConn_NBIO_RW_10a(ProtocolFamily family)\n+            throws Throwable {\n+        try (ServerSocketChannel ssc = openServerSocketChannel(family)) {\n+            ssc.bind(null);\n+            SocketAddress addr = ssc.getLocalAddress();\n+\n+            try (SocketChannel sc = openSocketChannel(family)) {\n+                sc.configureBlocking(false);\n+                sc.connect(addr);\n+\n+                Selector aselector = Selector.open();\n+                ssc.configureBlocking(false).register(aselector, OP_ACCEPT);\n+                assertEquals(aselector.select(), 1);\n+\n+                try (SocketChannel sc2 = ssc.accept()) {\n+                    assertTrue(sc.finishConnect());\n+                    TestThread t = TestThread.of(\"t10a\", () -> {\n+                        try (Selector selector = Selector.open()) {\n+                            ByteBuffer bb = ByteBuffer.allocate(10);\n+                            sc.register(selector, OP_READ);\n+                            selector.select();\n+                            int c;\n+                            while ((c = sc.read(bb)) == 0) ;\n+                            assertEquals(c, 1);\n+                            out.printf(\"read:  0x%x%n\", bb.get(0));\n+                            assertEquals(bb.get(0), (byte) 0xAA);\n+                            sc.shutdownOutput();\n+                        }\n+                    });\n+                    t.start();\n+\n+                    ByteBuffer bb = ByteBuffer.allocate(10).put((byte) 0xAA).flip();\n+                    sc2.configureBlocking(false);\n+                    try (Selector selector = Selector.open()) {\n+                        SelectionKey k = sc2.register(selector, OP_WRITE);\n+                        selector.select();\n+                        int c;\n+                        while ((c = sc2.write(bb)) < 1) ;\n+                        assertEquals(c, 1);\n+                        out.printf(\"wrote: 0x%x%n\", bb.get(0));\n+                        k.interestOps(OP_READ);\n+                        selector.select();\n+                        bb.clear();\n+                        while ((c = sc2.read(bb)) == 0) ;\n+                        assertEquals(c, -1);\n+                    }\n+                    t.awaitCompletion();\n+                }\n+            }\n+            deleteFile(addr);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"family\")\n+    public void SPINBAccep_NBConn_NBIO_WR_11a(ProtocolFamily family)\n+            throws Throwable {\n+        try (ServerSocketChannel ssc = openServerSocketChannel(family)) {\n+            ssc.bind(null);\n+            SocketAddress addr = ssc.getLocalAddress();\n+\n+            try (SocketChannel sc = openSocketChannel(family)) {\n+                sc.configureBlocking(false);\n+                sc.connect(addr);\n+\n+                SocketChannel accepted;\n+                for (; ; ) {\n+                    accepted = ssc.accept();\n+                    if (accepted != null) {\n+                        out.println(\"accepted new connection\");\n+                        break;\n+                    }\n+                    Thread.onSpinWait();\n+                }\n+\n+                try (SocketChannel sc2 = accepted) {\n+                    assertTrue(sc.finishConnect());\n+                    TestThread t = TestThread.of(\"t11a\", () -> {\n+                        try (Selector selector = Selector.open()) {\n+                            ByteBuffer bb = ByteBuffer.allocate(10).put((byte) 0xBA).flip();\n+                            sc.configureBlocking(false);\n+                            SelectionKey k = sc.register(selector, OP_WRITE);\n+                            selector.select();\n+                            int c;\n+                            while ((c = sc.write(bb)) < 1) ;\n+                            assertEquals(c, 1);\n+                            out.printf(\"wrote: 0x%x%n\", bb.get(0));\n+                            k.interestOps(OP_READ);\n+                            selector.select();\n+                            bb.clear();\n+                            while ((c = sc.read(bb)) == 0) ;\n+                            assertEquals(c, -1);\n+                        }\n+                    });\n+                    t.start();\n+\n+                    ByteBuffer bb = ByteBuffer.allocate(10);\n+                    sc2.configureBlocking(false);\n+                    try (Selector selector = Selector.open()) {\n+                        sc2.register(selector, OP_READ);\n+                        selector.select();\n+                        int c;\n+                        while ((c = sc2.read(bb)) == 0) ;\n+                        assertEquals(c, 1);\n+                        out.printf(\"read:  0x%x%n\", bb.get(0));\n+                        assertEquals(bb.get(0), (byte) 0xBA);\n+                        sc2.shutdownOutput();\n+                    }\n+                    t.awaitCompletion();\n+                }\n+            }\n+            deleteFile(addr);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"family\")\n+    public void SPINBAccep_NBConn_NBIO_RW_12a(ProtocolFamily family)\n+            throws Throwable {\n+        try (ServerSocketChannel ssc = openServerSocketChannel(family)) {\n+            ssc.bind(null);\n+            SocketAddress addr = ssc.getLocalAddress();\n+\n+            try (SocketChannel sc = openSocketChannel(family)) {\n+                sc.configureBlocking(false);\n+                sc.connect(addr);\n+\n+                SocketChannel accepted;\n+                for (; ; ) {\n+                    accepted = ssc.accept();\n+                    if (accepted != null) {\n+                        out.println(\"accepted new connection\");\n+                        break;\n+                    }\n+                    Thread.onSpinWait();\n+                }\n+\n+                try (SocketChannel sc2 = accepted) {\n+                    assertTrue(sc.finishConnect());\n+                    TestThread t = TestThread.of(\"t10a\", () -> {\n+                        try (Selector selector = Selector.open()) {\n+                            ByteBuffer bb = ByteBuffer.allocate(10);\n+                            sc.register(selector, OP_READ);\n+                            selector.select();\n+                            int c;\n+                            while ((c = sc.read(bb)) == 0) ;\n+                            assertEquals(c, 1);\n+                            out.printf(\"read:  0x%x%n\", bb.get(0));\n+                            assertEquals(bb.get(0), (byte) 0xCA);\n+                            sc.shutdownOutput();\n+                        }\n+                    });\n+                    t.start();\n+\n+                    ByteBuffer bb = ByteBuffer.allocate(10).put((byte) 0xCA).flip();\n+                    sc2.configureBlocking(false);\n+                    try (Selector selector = Selector.open()) {\n+                        SelectionKey k = sc2.register(selector, OP_WRITE);\n+                        selector.select();\n+                        int c;\n+                        while ((c = sc2.write(bb)) < 1) ;\n+                        assertEquals(c, 1);\n+                        out.printf(\"wrote: 0x%x%n\", bb.get(0));\n+                        k.interestOps(OP_READ);\n+                        selector.select();\n+                        bb.clear();\n+                        while ((c = sc2.read(bb)) == 0) ;\n+                        assertEquals(c, -1);\n+                    }\n+                    t.awaitCompletion();\n+                }\n+            }\n+            deleteFile(addr);\n+        }\n+    }\n+\n+    \/\/ --\n+\n+    static class TestThread extends Thread {\n+        private final UncheckedRunnable runnable;\n+        private volatile Throwable throwable;\n+\n+        TestThread(UncheckedRunnable runnable, String name) {\n+            super(name);\n+            this.runnable = runnable;\n+        }\n+\n+        @Override\n+        public void run() {\n+            try {\n+                runnable.run();\n+            } catch (Throwable t) {\n+                out.printf(\"[%s] caught unexpected: %s%n\", getName(), t);\n+                throwable = t;\n+            }\n+        }\n+\n+        interface UncheckedRunnable {\n+            void run() throws Throwable;\n+        }\n+\n+        static TestThread of(String name, UncheckedRunnable runnable) {\n+            return new TestThread(runnable, name);\n+        }\n+\n+        void awaitCompletion() throws Throwable {\n+            this.join();\n+            if (throwable != null)\n+                throw throwable;\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/nio\/channels\/unixdomain\/IOExchanges.java","additions":1238,"deletions":0,"binary":false,"changes":1238,"status":"added"},{"patch":"@@ -0,0 +1,104 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Test UnixDomainSocketAddress constructor\n+ * @library \/test\/lib\n+ * @run testng\/othervm LengthTest\n+ *\/\n+\n+import org.testng.annotations.BeforeTest;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import static java.lang.System.out;\n+import static java.net.StandardProtocolFamily.UNIX;\n+import static jdk.test.lib.Asserts.assertTrue;\n+\n+import java.net.UnixDomainSocketAddress;\n+import java.io.IOException;\n+import java.nio.channels.SocketChannel;\n+import java.nio.file.Path;\n+\n+public class LengthTest {\n+    static boolean supported = true;\n+    volatile int namelen;\n+\n+    @BeforeTest\n+    public void setup() {\n+        try {\n+            SocketChannel.open(UNIX);\n+        }\n+        catch (IOException | UnsupportedOperationException e) {}\n+        namelen = Integer.parseInt(System.getProperty(\"jdk.nio.channels.unixdomain.maxnamelength\"));\n+        if (namelen == -1) {\n+            supported = false;\n+            out.println(\"Unix domain channels not supported. Test not run.\");\n+        }\n+    }\n+\n+    @DataProvider(name = \"strings\")\n+    public Object[][] strings() {\n+        if (namelen == -1)\n+            return new Object[][] {new String[]{\"\"}};\n+\n+        return new Object[][]{\n+                {\"\"},\n+                {new String(new char[100]).replaceAll(\"\\0\", \"x\")},\n+                {new String(new char[namelen]).replaceAll(\"\\0\", \"x\")},\n+                {new String(new char[namelen-1]).replaceAll(\"\\0\", \"x\")},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"strings\")\n+    public void expectPass(String s) {\n+        if (supported) {\n+            var addr = UnixDomainSocketAddress.of(s);\n+            assertTrue(addr.getPath().toString().equals(s), \"getPathName.equals(s)\");\n+            var p = Path.of(s);\n+            addr = UnixDomainSocketAddress.of(p);\n+            assertTrue(addr.getPath().equals(p), \"getPath.equals(p)\");\n+        }\n+    }\n+\n+    @Test\n+    public void expectNPE() {\n+        if (supported) {\n+            try {\n+                String s = null;\n+                UnixDomainSocketAddress.of(s);\n+                throw new RuntimeException(\"Expected NPE\");\n+            } catch (NullPointerException npe) {\n+                out.println(\"\\tCaught expected exception: \" + npe);\n+            }\n+            try {\n+                Path p = null;\n+                UnixDomainSocketAddress.of(p);\n+                throw new RuntimeException(\"Expected NPE\");\n+            } catch (NullPointerException npe) {\n+                out.println(\"\\tCaught expected exception: \" + npe);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/nio\/channels\/unixdomain\/LengthTest.java","additions":104,"deletions":0,"binary":false,"changes":104,"status":"added"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.net.StandardProtocolFamily;\n+import java.nio.channels.ServerSocketChannel;\n+import java.nio.channels.SocketChannel;\n+\n+public class NonBlockingAccept {\n+\n+    static boolean supported() {\n+        try {\n+            SocketChannel.open(StandardProtocolFamily.UNIX);\n+        } catch (UnsupportedOperationException e) {\n+            return false;\n+        } catch (Exception e) {\n+            return true;\n+        }\n+        return true;\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        if (!supported()) {\n+            return;\n+        }\n+\n+        try (ServerSocketChannel serverSocketChannel =\n+                                 ServerSocketChannel.open(StandardProtocolFamily.UNIX)) {\n+            \/\/non blocking mode\n+            serverSocketChannel.configureBlocking(false);\n+            serverSocketChannel.bind(null);\n+            SocketChannel socketChannel = serverSocketChannel.accept();\n+            System.out.println(\"The socketChannel is : expected Null \" + socketChannel);\n+            \/\/ exception could be thrown otherwise\n+        }\n+    }\n+}\n+\n","filename":"test\/jdk\/java\/nio\/channels\/unixdomain\/NonBlockingAccept.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -0,0 +1,34 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8231358\n+ * @requires os.family != \"windows\"\n+ * @build Bind Shutdown NonBlockingAccept SocketOptions IOExchanges\n+ * @run main\/othervm Bind\n+ * @run main\/othervm Shutdown\n+ * @run main\/othervm NonBlockingAccept\n+ * @run main\/othervm SocketOptions\n+ * @run testng\/othervm IOExchanges\n+ *\/\n","filename":"test\/jdk\/java\/nio\/channels\/unixdomain\/NonWindowsDriver.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"added"},{"patch":"@@ -0,0 +1,158 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8231358\n+ * @run main\/othervm Security policy1\n+ * @run main\/othervm Security policy2\n+ * @summary Security test for Unix Domain socket and server socket channels\n+ *\/\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.net.SocketAddress;\n+import java.net.UnixDomainSocketAddress;\n+import java.nio.channels.*;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Comparator;\n+\n+import static java.net.StandardProtocolFamily.UNIX;\n+\n+\/**\n+ * Tests required all with security manager\n+ *\/\n+\n+public class Security {\n+\n+    static interface Command {\n+        public void run() throws Exception;\n+    }\n+\n+    static <T extends Exception> void call(Command r, Class<? extends Exception> expectedException) {\n+        boolean threw = false;\n+        try {\n+            r.run();\n+        } catch (Throwable t) {\n+            if (expectedException == null) {\n+                t.printStackTrace();\n+                throw new RuntimeException(\"an exception was thrown but was not expected\");\n+            }\n+            threw = true;\n+            if (!(expectedException.isAssignableFrom(t.getClass()))) {\n+                throw new RuntimeException(\"wrong exception type thrown \" + t.toString());\n+            }\n+        }\n+        if (expectedException != null && !threw) {\n+            \/\/ should have thrown\n+            throw new RuntimeException(\"SecurityException was expected\");\n+        }\n+    }\n+\n+\n+    public static void main(String[] args) throws Exception {\n+        try {\n+           SocketChannel.open(UNIX);\n+       }\n+       catch (UnsupportedOperationException e) {}\n+\n+        int namelen = Integer.parseInt(System.getProperty(\"jdk.nio.channels.unixdomain.maxnamelength\"));\n+        if (namelen == -1) {\n+            System.out.println(\"Unix domain not supported\");\n+            return;\n+        }\n+        String policy = args[0];\n+        switch (policy) {\n+            case \"policy1\":\n+                setSecurityManager(policy);\n+                testPolicy1();\n+                break;\n+            case \"policy2\":\n+                setSecurityManager(policy);\n+                testPolicy2();\n+                break;\n+            default:\n+        }\n+\n+    }\n+\n+    static void setSecurityManager(String policy) {\n+        String testSrc = System.getProperty(\"test.src\");\n+        \/\/ Three \/\/\/ required for Windows below\n+        String policyURL = \"file:\/\/\/\" + testSrc + File.separator + policy;\n+        System.out.println(\"POLICY: \" + policyURL);\n+        System.setProperty(\"java.security.policy\", policyURL);\n+        System.setSecurityManager(new SecurityManager());\n+    }\n+\n+    static void close(NetworkChannel... channels) {\n+\n+        for (NetworkChannel chan : channels) {\n+            try {\n+                chan.close();\n+            } catch (Exception e) {\n+            }\n+        }\n+    }\n+\n+    private static final Class<SecurityException> SE = SecurityException.class;\n+    private static final Class<IOException> IOE = IOException.class;\n+\n+    \/\/ No permission\n+\n+    public static void testPolicy1() throws Exception {\n+        Path servername = Path.of(\"sock\");\n+        Files.deleteIfExists(servername);\n+        \/\/ Permission exists to bind a ServerSocketChannel\n+        final UnixDomainSocketAddress saddr = UnixDomainSocketAddress.of(servername);\n+        final ServerSocketChannel server = ServerSocketChannel.open(UNIX);\n+        final SocketChannel client = SocketChannel.open(UNIX);\n+        call(() -> {\n+            server.bind(saddr);\n+        }, SE);\n+        call(() -> {\n+            client.connect(saddr);\n+        }, SE);\n+        close(server, client);\n+        Files.deleteIfExists(servername);\n+    }\n+\n+    \/\/ All permissions\n+\n+    public static void testPolicy2() throws Exception {\n+        Path servername = Path.of(\"sock\");\n+        Files.deleteIfExists(servername);\n+        final UnixDomainSocketAddress saddr = UnixDomainSocketAddress.of(servername);\n+        final ServerSocketChannel server = ServerSocketChannel.open(UNIX);\n+        final SocketChannel client = SocketChannel.open(UNIX);\n+        call(() -> {\n+            server.bind(saddr);\n+        }, null);\n+        call(() -> {\n+            client.connect(saddr);\n+        }, null);\n+        close(server, client);\n+        Files.deleteIfExists(servername);\n+    }\n+}\n","filename":"test\/jdk\/java\/nio\/channels\/unixdomain\/Security.java","additions":158,"deletions":0,"binary":false,"changes":158,"status":"added"},{"patch":"@@ -0,0 +1,117 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.net.*;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.*;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.util.Arrays;\n+\n+\/**\n+ * Check that half close works\n+ *\/\n+public class Shutdown {\n+\n+    public static void main(String args[]) throws Exception {\n+        if (!supported()) {\n+            System.out.println(\"Unix domain channels not supported\");\n+            return;\n+        }\n+        runTest();\n+    }\n+\n+    static boolean supported() {\n+        try {\n+            SocketChannel.open(StandardProtocolFamily.UNIX);\n+        } catch (UnsupportedOperationException e) {\n+            return false;\n+        } catch (Exception e) {\n+            return true; \/\/ continue test to see what problem is\n+        }\n+        return true;\n+    }\n+\n+    static void assertTrue(boolean condition, String error) {\n+        if (!condition)\n+            throw new RuntimeException(error);\n+    }\n+\n+    public static void runTest() throws IOException {\n+        ServerSocketChannel server = null;\n+        SocketChannel client = null;\n+        SocketChannel acceptee = null;\n+        UnixDomainSocketAddress usa = null;\n+\n+        try {\n+            server = ServerSocketChannel.open(StandardProtocolFamily.UNIX);\n+            server.bind(null);\n+            usa = (UnixDomainSocketAddress)server.getLocalAddress();\n+            System.out.println(\"Local address \" + usa);\n+            client = SocketChannel.open(usa);\n+            acceptee = server.accept();\n+            ByteBuffer buf = ByteBuffer.wrap(\"Hello world\".getBytes(StandardCharsets.ISO_8859_1));\n+            ByteBuffer rx = ByteBuffer.allocate(buf.capacity());\n+            client.write(buf);\n+            buf.rewind();\n+            while (rx.hasRemaining())\n+                acceptee.read(rx);\n+\n+            assertTrue(Arrays.equals(buf.array(), rx.array()), \"array contents not equal\");\n+\n+            client.shutdownOutput();\n+            try {\n+                client.write(buf);\n+                throw new RuntimeException(\"shutdown error\");\n+            } catch (ClosedChannelException e) {\n+            }\n+\n+            rx.clear();\n+            int c = acceptee.read(rx);\n+            assertTrue(c == -1, \"read after remote shutdown\");\n+\n+            client.configureBlocking(false);\n+            c = client.read(rx);\n+            assertTrue(c == 0, \"expected c == 0\");\n+            client.shutdownInput();\n+            c = client.read(rx);\n+            assertTrue(c == -1, \"expected c == -1\");\n+        } finally {\n+            close(server);\n+            close(client);\n+            close(acceptee);\n+            if (usa != null)\n+                Files.delete(usa.getPath());\n+        }\n+        System.out.println(\"OK\");\n+    }\n+\n+    static void close(Closeable c) {\n+        try {\n+            if (c != null)\n+                c.close();\n+        } catch (IOException e) {}\n+    }\n+}\n","filename":"test\/jdk\/java\/nio\/channels\/unixdomain\/Shutdown.java","additions":117,"deletions":0,"binary":false,"changes":117,"status":"added"},{"patch":"@@ -0,0 +1,128 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.IOException;\n+import java.net.*;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.*;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Set;\n+import jdk.net.UnixDomainPrincipal;\n+import static jdk.net.ExtendedSocketOptions.SO_PEERCRED;\n+\n+\/**\n+ * Check that all supported options can actually be set and got\n+ *\/\n+public class SocketOptions {\n+\n+    public static void main(String args[]) throws Exception {\n+        if (!supported()) {\n+            System.out.println(\"Unix domain channels not supported\");\n+            return;\n+        }\n+        test(ServerSocketChannel.open(StandardProtocolFamily.UNIX));\n+        test(SocketChannel.open(StandardProtocolFamily.UNIX));\n+        testPeerCred();\n+    }\n+\n+    static void testPeerCred() throws Exception {\n+        ServerSocketChannel s = ServerSocketChannel.open(StandardProtocolFamily.UNIX);\n+        s.bind(null);\n+        UnixDomainSocketAddress addr = (UnixDomainSocketAddress)s.getLocalAddress();\n+        SocketChannel c = SocketChannel.open(addr);\n+        if (!c.supportedOptions().contains(SO_PEERCRED)) {\n+            return;\n+        }\n+        Files.deleteIfExists(addr.getPath());\n+        UnixDomainPrincipal p = c.getOption(SO_PEERCRED);\n+        String s1 = p.user().getName();\n+        System.out.println(s1);\n+        System.out.println(p.group().getName());\n+        String s2 = System.getProperty(\"user.name\");\n+\n+        \/\/ Check returned user name\n+\n+        if (!s1.equals(s2)) {\n+            throw new RuntimeException(\"wrong username\");\n+        }\n+\n+        \/\/ Try setting the option: Read only\n+\n+        try {\n+            c.setOption(SO_PEERCRED, p);\n+            throw new RuntimeException(\"should have thrown SocketException\");\n+        } catch (SocketException e) {}\n+\n+        c.close();\n+        s.close();\n+\n+        \/\/ Try getting from unconnected socket\n+\n+        c = SocketChannel.open(StandardProtocolFamily.UNIX);\n+        try {\n+            p = c.getOption(SO_PEERCRED);\n+            System.out.println(p.user());\n+            throw new RuntimeException(\"should have thrown SocketException\");\n+        } catch (SocketException e) {}\n+\n+        \/\/ Try getting from ServerSocketChannel\n+\n+        var server = ServerSocketChannel.open(StandardProtocolFamily.UNIX);\n+        try {\n+            p = server.getOption(SO_PEERCRED);\n+            System.out.println(p.user());\n+            throw new RuntimeException(\"should have thrown USE\");\n+        } catch (UnsupportedOperationException e) {}\n+\n+    }\n+\n+    static boolean supported() {\n+        try {\n+            SocketChannel.open(StandardProtocolFamily.UNIX);\n+        } catch (UnsupportedOperationException e) {\n+            return false;\n+        } catch (Exception e) {\n+            return true; \/\/ continue test to see what problem is\n+        }\n+        return true;\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public static void test(NetworkChannel chan) throws IOException {\n+        System.out.println(\"Checking: \" + chan.getClass());\n+        Set<SocketOption<?>> supported = chan.supportedOptions();\n+        for (SocketOption<?> option : supported) {\n+            String name = option.name();\n+            System.out.println(\"Checking option \" + name);\n+            if (option.type() == Boolean.class) {\n+                chan.setOption((SocketOption<Boolean>)option, true);\n+                chan.setOption((SocketOption<Boolean>)option, false);\n+                chan.getOption(option);\n+            } else if (option.type() == Integer.class) {\n+                chan.setOption((SocketOption<Integer>)option, 10);\n+                chan.getOption(option);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/nio\/channels\/unixdomain\/SocketOptions.java","additions":128,"deletions":0,"binary":false,"changes":128,"status":"added"},{"patch":"@@ -0,0 +1,125 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.annotations.Test;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.io.InvalidObjectException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.ObjectStreamClass;\n+import java.io.Serializable;\n+import java.net.UnixDomainSocketAddress;\n+import java.nio.file.Path;\n+import static java.io.ObjectStreamConstants.*;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertTrue;\n+import static org.testng.Assert.expectThrows;\n+\n+\/*\n+ * @test\n+ * @summary UnixDomainSocketAddress serialization test\n+ * @run testng\/othervm UnixDomainSocketAddressSerializationTest\n+ *\/\n+\n+@Test\n+public class UnixDomainSocketAddressSerializationTest {\n+    private static final UnixDomainSocketAddress addr =\n+            UnixDomainSocketAddress.of(Path.of(\"test.sock\"));\n+\n+    public static void test() throws Exception {\n+        assertTrue(addr instanceof Serializable);\n+\n+        byte[] serialized = serialize(addr);\n+        assertTrue(serialized.length > 0);\n+\n+        UnixDomainSocketAddress deserialized =\n+                deserialize(serialized, UnixDomainSocketAddress.class);\n+        assertEquals(deserialized.getPath(), addr.getPath());\n+        assertEquals(deserialized.toString(), addr.toString());\n+        assertEquals(deserialized.hashCode(), addr.hashCode());\n+        assertEquals(deserialized, addr);\n+    }\n+\n+    static final Class<InvalidObjectException> IOE = InvalidObjectException.class;\n+    static final Class<NullPointerException> NPE = NullPointerException.class;\n+\n+    \/** Tests that UnixDomainSocketAddress in the byte-stream is disallowed. *\/\n+    public static void testUnixDomainSocketAddressInStream() throws Exception {\n+        long suid = ObjectStreamClass.lookup(UnixDomainSocketAddress.class).getSerialVersionUID();\n+        byte[] bytes = byteStreamFor(UnixDomainSocketAddress.class.getName(), suid);\n+        expectThrows(IOE, () -> deserialize(bytes, UnixDomainSocketAddress.class));\n+    }\n+\n+    \/** Tests that SerialProxy with a null\/absent path value in the byte-stream is disallowed. *\/\n+    public static void testSerialProxyNoStreamValues() throws Exception {\n+        Class<?> c = Class.forName(\"java.net.UnixDomainSocketAddress$Ser\");\n+        long suid = ObjectStreamClass.lookup(c).getSerialVersionUID();\n+        byte[] bytes = byteStreamFor(c.getName(), suid);\n+        expectThrows(NPE, () -> deserialize(bytes, UnixDomainSocketAddress.class));\n+    }\n+\n+    private static <T extends Serializable> byte[] serialize(T t)\n+            throws IOException {\n+        ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+        ObjectOutputStream oos = new ObjectOutputStream(bos);\n+        oos.writeObject(t);\n+        oos.flush();\n+        oos.close();\n+        return bos.toByteArray();\n+    }\n+\n+    private static <T extends Serializable> T deserialize(byte[] b, Class<T> cl)\n+            throws IOException, ClassNotFoundException {\n+        try (ObjectInputStream ois =\n+                     new ObjectInputStream(new ByteArrayInputStream(b))) {\n+            Object o = ois.readObject();\n+            return cl.cast(o);\n+        }\n+    }\n+\n+    \/**\n+     * Returns a stream with the given classname and suid. The stream will have\n+     * no stream field values.\n+     *\/\n+    static byte[] byteStreamFor(String classname, long suid) throws Exception {\n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        DataOutputStream dos = new DataOutputStream(baos);\n+        dos.writeShort(STREAM_MAGIC);\n+        dos.writeShort(STREAM_VERSION);\n+        dos.writeByte(TC_OBJECT);\n+        dos.writeByte(TC_CLASSDESC);\n+        dos.writeUTF(classname);\n+        dos.writeLong(suid);\n+        dos.writeByte(SC_SERIALIZABLE);\n+        dos.writeShort(0);                \/\/ number of stream fields\n+        dos.writeByte(TC_ENDBLOCKDATA);   \/\/ no annotations\n+        dos.writeByte(TC_NULL);           \/\/ no superclasses\n+        dos.write(TC_ENDBLOCKDATA);       \/\/ end block - for SC_WRITE_METHOD\n+        dos.close();\n+        return baos.toByteArray();\n+    }\n+}\n","filename":"test\/jdk\/java\/nio\/channels\/unixdomain\/UnixDomainSocketAddressSerializationTest.java","additions":125,"deletions":0,"binary":false,"changes":125,"status":"added"},{"patch":"@@ -0,0 +1,35 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8231358\n+ * @requires os.family == \"windows\"\n+ * @build Bind Shutdown NonBlockingAccept SocketOptions\n+ * @run main\/othervm Bind\n+ * @run main\/othervm Shutdown\n+ * @run main\/othervm NonBlockingAccept\n+ * @run main\/othervm SocketOptions\n+ * @run testng\/othervm IOExchanges\n+ *\/\n+\n","filename":"test\/jdk\/java\/nio\/channels\/unixdomain\/WindowsDriver.java","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -0,0 +1,4 @@\n+grant {\n+    \/\/ No permission\n+    permission java.io.FilePermission \"sock\", \"delete\";\n+};\n","filename":"test\/jdk\/java\/nio\/channels\/unixdomain\/policy1","additions":4,"deletions":0,"binary":false,"changes":4,"status":"added"},{"patch":"@@ -0,0 +1,6 @@\n+grant {\n+    \/\/ permission to bind a SocketChannel in sockets directory\n+    permission java.net.NetPermission \"accessUnixDomainSocket\";\n+\n+    permission java.io.FilePermission \"sock\", \"delete\";\n+};\n","filename":"test\/jdk\/java\/nio\/channels\/unixdomain\/policy2","additions":6,"deletions":0,"binary":false,"changes":6,"status":"added"},{"patch":"@@ -268,0 +268,4 @@\n+        return getFD1(sc, sc.getClass());\n+    }\n+\n+    private static FileDescriptor getFD1(SocketChannel sc, Class<?> clazz) {\n@@ -269,1 +273,0 @@\n-            Class<?> clazz = sc.getClass();\n@@ -273,0 +276,6 @@\n+        } catch (NoSuchFieldException e1) {\n+            Class<?> superclass = clazz.getSuperclass();\n+            if (superclass == null)\n+                throw new Error(e1);\n+            else\n+                return getFD1(sc, superclass);\n","filename":"test\/jdk\/jdk\/nio\/Basic.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,193 @@\n+\/*\n+ * Copyright (c) 2014 Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.net;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.StandardProtocolFamily;\n+import java.net.UnixDomainSocketAddress;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.ClosedChannelException;\n+import java.nio.channels.ServerSocketChannel;\n+import java.nio.channels.SocketChannel;\n+import java.nio.file.*;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.runner.Runner;\n+import org.openjdk.jmh.runner.RunnerException;\n+import org.openjdk.jmh.runner.options.Options;\n+import org.openjdk.jmh.runner.options.OptionsBuilder;\n+\n+\/**\n+ * Tests sending a 128 byte message on a second, to a thread which\n+ * echo's it back and received by the original thread.\n+ * Benchmark is performed for \"inet\" channels over TCP\/IP\n+ * and \"unix\" domain channels.\n+ *\/\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Thread)\n+public class SocketChannelCompare {\n+\n+    static final int BUFSIZE = 128; \/\/ message size sent and received\n+    private ServerSocketChannel ssc;\n+    private SocketChannel s1, s2;\n+    private EchoThread rt;\n+    private ByteBuffer bb = ByteBuffer.allocate(BUFSIZE);\n+\n+    private static volatile String tempDir;\n+    private static final AtomicInteger count = new AtomicInteger(0);\n+    private volatile Path socket;\n+\n+    @Param({\"inet\", \"unix\"})\n+    private volatile String family;\n+\n+    static {\n+        try {\n+            Path p = Files.createTempDirectory(\"readWriteTest\");\n+            tempDir = p.toString();\n+        } catch (IOException e) {\n+            tempDir = null;\n+        }\n+    }\n+\n+    private ServerSocketChannel getServerSocketChannel() throws IOException {\n+        if (family.equals(\"inet\"))\n+            return getInetServerSocketChannel();\n+        else if (family.equals(\"unix\"))\n+            return getUnixServerSocketChannel();\n+        throw new InternalError();\n+    }\n+\n+\n+    private ServerSocketChannel getInetServerSocketChannel() throws IOException {\n+        InetAddress iaddr = InetAddress.getLoopbackAddress();\n+        return ServerSocketChannel.open().bind(null);\n+    }\n+\n+    private ServerSocketChannel getUnixServerSocketChannel() throws IOException {\n+        int next = count.incrementAndGet();\n+        socket = Paths.get(tempDir, Integer.toString(next));\n+        UnixDomainSocketAddress addr = UnixDomainSocketAddress.of(socket);\n+        return ServerSocketChannel.open(StandardProtocolFamily.UNIX).bind(addr);\n+    }\n+\n+    @Setup(Level.Trial)\n+    public void beforeRun() throws IOException {\n+        ssc = getServerSocketChannel();\n+        s1 = SocketChannel.open(ssc.getLocalAddress());\n+        s2 = ssc.accept();\n+\n+        rt = new EchoThread(s2);\n+        rt.start();\n+    }\n+\n+    @TearDown(Level.Trial)\n+    public void afterRun() throws IOException, InterruptedException {\n+        s1.close();\n+        s2.close();\n+        ssc.close();\n+        if (family.equals(\"unix\")) {\n+            Files.delete(socket);\n+            Files.delete(Path.of(tempDir));\n+        }\n+        rt.join();\n+    }\n+\n+    @Benchmark\n+    public void test() throws IOException {\n+        bb.position(0).limit(BUFSIZE);\n+        s1.write(bb);\n+        bb.clear();\n+        readFully(s1, bb);\n+    }\n+\n+    \/\/ read until buf is full, or EOF. Always returns number of bytes read\n+\n+    static int readFully(SocketChannel chan, ByteBuffer buf) throws IOException {\n+        int n = buf.remaining();\n+        int count = 0;\n+        while (n > 0) {\n+            int c = chan.read(buf);\n+            if (c == -1)\n+                return count;\n+            n -= c;\n+            count += c;\n+        }\n+        return count;\n+    }\n+\n+    static class EchoThread extends Thread {\n+        private SocketChannel sc;\n+\n+        public EchoThread(SocketChannel s2) {\n+            this.sc = s2;\n+        }\n+\n+        public void run() {\n+            try {\n+                ByteBuffer bb = ByteBuffer.allocate(BUFSIZE);\n+                while (true) {\n+                    bb.clear();\n+                    int c = readFully(sc, bb);\n+                    if (c == 0) {\n+                        sc.close();\n+                        return;\n+                    }\n+                    bb.flip();\n+                    sc.write(bb);\n+                }\n+            } catch (ClosedChannelException ex) {\n+                \/\/ shutdown time\n+            } catch (IOException ioex) {\n+                ioex.printStackTrace();\n+            }\n+        }\n+    }\n+\n+    public static void main(String[] args) throws RunnerException {\n+        Options opt = new OptionsBuilder()\n+                .include(org.openjdk.bench.java.net.SocketChannelCompare.class.getSimpleName())\n+                .warmupForks(1)\n+                .warmupIterations(2)\n+                .measurementIterations(2)\n+                .forks(2)\n+                .build();\n+\n+        new Runner(opt).run();\n+\n+        opt = new OptionsBuilder()\n+                .include(org.openjdk.bench.java.net.SocketChannelCompare.class.getSimpleName())\n+                .warmupForks(1)\n+                .warmupIterations(2)\n+                .measurementIterations(2)\n+                .jvmArgsPrepend(\"-Djdk.net.useFastTcpLoopback=true\")\n+                .forks(3)\n+                .build();\n+\n+        new Runner(opt).run();\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/net\/SocketChannelCompare.java","additions":193,"deletions":0,"binary":false,"changes":193,"status":"added"},{"patch":"@@ -0,0 +1,132 @@\n+\/*\n+ * Copyright (c) 2019 Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.net;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.StandardProtocolFamily;\n+import java.net.UnixDomainSocketAddress;\n+import java.nio.channels.ClosedChannelException;\n+import java.nio.channels.ServerSocketChannel;\n+import java.nio.channels.SocketChannel;\n+import java.nio.file.*;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.runner.Runner;\n+import org.openjdk.jmh.runner.RunnerException;\n+import org.openjdk.jmh.runner.options.Options;\n+import org.openjdk.jmh.runner.options.OptionsBuilder;\n+\n+\/**\n+ * Measures connection setup times\n+ *\/\n+@BenchmarkMode(Mode.SingleShotTime)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Thread)\n+public class SocketChannelConnectionSetup {\n+\n+    private ServerSocketChannel ssc;\n+    private SocketChannel s1, s2;\n+\n+    private static volatile String tempDir;\n+    private static final AtomicInteger count = new AtomicInteger(0);\n+    private volatile Path socket;\n+\n+    @Param({\"inet\", \"unix\"})\n+    private volatile String family;\n+\n+    static {\n+        try {\n+            Path p = Files.createTempDirectory(\"readWriteTest\");\n+            tempDir = p.toString();\n+        } catch (IOException e) {\n+            tempDir = null;\n+        }\n+    }\n+\n+    private ServerSocketChannel getServerSocketChannel() throws IOException {\n+        if (family.equals(\"inet\"))\n+            return getInetServerSocketChannel();\n+        else if (family.equals(\"unix\"))\n+            return getUnixServerSocketChannel();\n+        throw new InternalError();\n+    }\n+\n+\n+    private ServerSocketChannel getInetServerSocketChannel() throws IOException {\n+        InetAddress iaddr = InetAddress.getLoopbackAddress();\n+        return ServerSocketChannel.open().bind(null);\n+    }\n+\n+    private ServerSocketChannel getUnixServerSocketChannel() throws IOException {\n+        int next = count.incrementAndGet();\n+        socket = Paths.get(tempDir, Integer.toString(next));\n+        UnixDomainSocketAddress addr = UnixDomainSocketAddress.of(socket);\n+        return ServerSocketChannel.open(StandardProtocolFamily.UNIX).bind(addr);\n+    }\n+\n+    @Setup(Level.Trial)\n+    public void beforeRun() throws IOException {\n+        ssc = getServerSocketChannel();\n+    }\n+\n+    @TearDown(Level.Trial)\n+    public void afterRun() throws IOException, InterruptedException {\n+        ssc.close();\n+        if (family.equals(\"unix\")) {\n+            Files.delete(socket);\n+            Files.delete(Path.of(tempDir));\n+        }\n+    }\n+\n+    @Benchmark\n+    @Measurement(iterations = 5, batchSize=200)\n+    public void test() throws IOException {\n+        s1 = SocketChannel.open(ssc.getLocalAddress());\n+        s2 = ssc.accept();\n+        s1.close();\n+        s2.close();\n+    }\n+\n+    public static void main(String[] args) throws RunnerException {\n+        Options opt = new OptionsBuilder()\n+                .include(org.openjdk.bench.java.net.SocketChannelConnectionSetup.class.getSimpleName())\n+                .warmupForks(1)\n+                .forks(2)\n+                .build();\n+\n+        new Runner(opt).run();\n+\n+        opt = new OptionsBuilder()\n+                .include(org.openjdk.bench.java.net.SocketChannelConnectionSetup.class.getSimpleName())\n+                .jvmArgsPrepend(\"-Djdk.net.useFastTcpLoopback=true\")\n+                .warmupForks(1)\n+                .forks(2)\n+                .build();\n+\n+        new Runner(opt).run();\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/net\/SocketChannelConnectionSetup.java","additions":132,"deletions":0,"binary":false,"changes":132,"status":"added"},{"patch":"@@ -0,0 +1,124 @@\n+\/*\n+ * Copyright (c) 2014 Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.net;\n+\n+import java.io.IOException;\n+import java.net.StandardProtocolFamily;\n+import java.net.UnixDomainSocketAddress;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.ClosedChannelException;\n+import java.nio.channels.ServerSocketChannel;\n+import java.nio.channels.SocketChannel;\n+import java.nio.file.*;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import org.openjdk.jmh.annotations.*;\n+\n+\/**\n+ * Tests the overheads of I\/O API.\n+ * This test is known to depend heavily on network conditions and paltform.\n+ *\/\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Thread)\n+public class UnixSocketChannelReadWrite {\n+\n+    private ServerSocketChannel ssc;\n+    private SocketChannel s1, s2;\n+    private ReadThread rt;\n+    private ByteBuffer bb = ByteBuffer.allocate(1);\n+\n+    private static volatile String tempDir;\n+    private static final AtomicInteger count = new AtomicInteger(0);\n+    private volatile Path socket;\n+\n+    static {\n+        try {\n+            Path p = Files.createTempDirectory(\"readWriteTest\");\n+            tempDir = p.toString();\n+        } catch (IOException e) {\n+            tempDir = null;\n+        }\n+    }\n+\n+    private ServerSocketChannel getServerSocketChannel() throws IOException {\n+        int next = count.incrementAndGet();\n+        socket = Paths.get(tempDir, Integer.toString(next));\n+        UnixDomainSocketAddress addr = UnixDomainSocketAddress.of(socket);\n+        ServerSocketChannel c = ServerSocketChannel.open(StandardProtocolFamily.UNIX);\n+        c.bind(addr);\n+        return c;\n+    }\n+\n+    @Setup(Level.Trial)\n+    public void beforeRun() throws IOException {\n+        ssc = getServerSocketChannel();\n+        s1 = SocketChannel.open(ssc.getLocalAddress());\n+        s2 = ssc.accept();\n+\n+        rt = new ReadThread(s2);\n+        rt.start();\n+\n+        bb.put((byte) 47);\n+        bb.flip();\n+    }\n+\n+    @TearDown(Level.Trial)\n+    public void afterRun() throws IOException, InterruptedException {\n+        s1.close();\n+        s2.close();\n+        ssc.close();\n+        Files.delete(socket);\n+        Files.delete(Path.of(tempDir));\n+        rt.join();\n+    }\n+\n+    @Benchmark\n+    public void test() throws IOException {\n+        s1.write(bb);\n+        bb.flip();\n+    }\n+\n+    static class ReadThread extends Thread {\n+        private SocketChannel sc;\n+\n+        public ReadThread(SocketChannel s2) {\n+            this.sc = s2;\n+        }\n+\n+        public void run() {\n+            try {\n+                ByteBuffer bb = ByteBuffer.allocate(1);\n+                while (sc.read(bb) > 0) {\n+                    bb.flip();\n+                }\n+            } catch (ClosedChannelException ex) {\n+                \/\/ shutdown time\n+            } catch (IOException e) {\n+                e.printStackTrace();\n+            }\n+        }\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/net\/UnixSocketChannelReadWrite.java","additions":124,"deletions":0,"binary":false,"changes":124,"status":"added"}]}