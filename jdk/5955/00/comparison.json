{"files":[{"patch":"@@ -39,0 +39,1 @@\n+#include \"oops\/oopForwarding.hpp\"\n@@ -73,1 +74,2 @@\n-    if (obj->is_forwarded() && obj->forwardee() == obj) {\n+    OopForwarding fwd(obj);\n+    if (fwd.is_forwarded() && fwd.forwardee() == obj) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1EvacFailure.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"oops\/oopForwarding.hpp\"\n@@ -63,2 +64,2 @@\n-  HeapWord* destination = cast_from_oop<HeapWord*>(obj->forwardee());\n-  if (destination == NULL) {\n+  OopForwarding fwd(obj);\n+  if (!fwd.is_forwarded()) {\n@@ -69,0 +70,2 @@\n+  HeapWord* destination = fwd.forwardee<HeapWord*>();\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCCompactTask.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"oops\/oopForwarding.hpp\"\n@@ -105,1 +106,2 @@\n-    object->forward_to(cast_to_oop(_compaction_top));\n+    OopForwarding::forward_to(object, cast_to_oop(_compaction_top));\n+    assert(OopForwarding(object).is_forwarded(), \"must be forwarded\");\n@@ -107,14 +109,1 @@\n-    if (object->forwardee() != NULL) {\n-      \/\/ Object should not move but mark-word is used so it looks like the\n-      \/\/ object is forwarded. Need to clear the mark and it's no problem\n-      \/\/ since it will be restored by preserved marks.\n-      object->init_mark();\n-    } else {\n-      \/\/ Make sure object has the correct mark-word set or that it will be\n-      \/\/ fixed when restoring the preserved marks.\n-      assert(object->mark() == markWord::prototype() || \/\/ Correct mark\n-             object->mark_must_be_preserved(), \/\/ Will be restored by PreservedMarksSet\n-             \"should have correct prototype obj: \" PTR_FORMAT \" mark: \" PTR_FORMAT \" prototype: \" PTR_FORMAT,\n-             p2i(object), object->mark().value(), markWord::prototype().value());\n-    }\n-    assert(object->forwardee() == NULL, \"should be forwarded to NULL\");\n+    assert(!OopForwarding(object).is_forwarded(), \"must not be forwarded\");\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCCompactionPoint.cpp","additions":4,"deletions":15,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+#include \"oops\/oopForwarding.hpp\"\n@@ -80,8 +81,6 @@\n-  oop forwardee = obj->forwardee();\n-  if (forwardee == NULL) {\n-    \/\/ Not forwarded, return current reference.\n-    assert(obj->mark() == markWord::prototype() || \/\/ Correct mark\n-           obj->mark_must_be_preserved(), \/\/ Will be restored by PreservedMarksSet\n-           \"Must have correct prototype or be preserved, obj: \" PTR_FORMAT \", mark: \" PTR_FORMAT \", prototype: \" PTR_FORMAT,\n-           p2i(obj), obj->mark().value(), markWord::prototype().value());\n-    return;\n+  OopForwarding fwd(obj);\n+  if (fwd.is_forwarded()) {\n+    oop forwardee = fwd.forwardee();\n+    \/\/ Forwarded, just update.\n+    assert(G1CollectedHeap::heap()->is_in_reserved(forwardee), \"should be in object space\");\n+    RawAccess<IS_NOT_NULL>::oop_store(p, forwardee);\n@@ -90,3 +89,0 @@\n-  \/\/ Forwarded, just update.\n-  assert(G1CollectedHeap::heap()->is_in_reserved(forwardee), \"should be in object space\");\n-  RawAccess<IS_NOT_NULL>::oop_store(p, forwardee);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCOopClosures.inline.hpp","additions":7,"deletions":11,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+#include \"oops\/oopForwarding.hpp\"\n@@ -171,2 +172,2 @@\n-  oop forwarded_to = obj->forwardee();\n-  if (forwarded_to != NULL && !_current->is_in(forwarded_to)) {\n+  OopForwarding fwd(obj);\n+  if (fwd.is_forwarded() && !_current->is_in(fwd.forwardee())) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCPrepareTask.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,0 +39,1 @@\n+#include \"oops\/oopForwarding.hpp\"\n@@ -58,2 +59,1 @@\n-         (obj->is_forwarded() &&\n-         obj->forwardee() == RawAccess<>::oop_load(p)),\n+         (OopForwarding(obj).forwardee() == RawAccess<>::oop_load(p)),\n@@ -235,3 +235,3 @@\n-    markWord m = obj->mark();\n-    if (m.is_marked()) {\n-      forwardee = cast_to_oop(m.decode_pointer());\n+    OopForwarding fwd = OopForwarding(obj);\n+    if (fwd.is_forwarded()) {\n+      forwardee = fwd.forwardee();\n@@ -239,1 +239,1 @@\n-      forwardee = _par_scan_state->copy_to_survivor_space(state, obj, m);\n+      forwardee = _par_scan_state->copy_to_survivor_space(state, obj, fwd);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1OopClosures.inline.hpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+#include \"oops\/oopForwarding.hpp\"\n@@ -206,3 +207,3 @@\n-  markWord m = obj->mark();\n-  if (m.is_marked()) {\n-    obj = cast_to_oop(m.decode_pointer());\n+  OopForwarding fwd(obj);\n+  if (fwd.is_forwarded()) {\n+    obj = fwd.forwardee();\n@@ -210,1 +211,1 @@\n-    obj = do_copy_to_survivor_space(region_attr, obj, m);\n+    obj = do_copy_to_survivor_space(region_attr, obj, fwd);\n@@ -223,1 +224,2 @@\n-  assert(from_obj->is_forwarded(), \"must be forwarded\");\n+  OopForwarding fwd(from_obj);\n+  assert(fwd.is_forwarded(), \"must be forwarded\");\n@@ -225,1 +227,1 @@\n-  oop to_obj = from_obj->forwardee();\n+  oop to_obj = fwd.forwardee();\n@@ -253,2 +255,2 @@\n-  assert(from_obj->is_forwarded(), \"precondition\");\n-  assert(from_obj->forwardee() == to_obj, \"precondition\");\n+  assert(OopForwarding(from_obj).is_forwarded(), \"precondition\");\n+  assert(OopForwarding(from_obj).forwardee() == to_obj, \"precondition\");\n@@ -442,1 +444,1 @@\n-                                                    markWord const old_mark) {\n+                                                    const OopForwarding& fwd) {\n@@ -452,1 +454,1 @@\n-  G1HeapRegionAttr dest_attr = next_region_attr(region_attr, old_mark, age);\n+  G1HeapRegionAttr dest_attr = next_region_attr(region_attr, fwd.mark(), age);\n@@ -465,1 +467,1 @@\n-      return handle_evacuation_failure_par(old, old_mark, word_sz);\n+      return handle_evacuation_failure_par(old, fwd, word_sz);\n@@ -477,1 +479,1 @@\n-    return handle_evacuation_failure_par(old, old_mark, word_sz);\n+    return handle_evacuation_failure_par(old, fwd, word_sz);\n@@ -485,1 +487,1 @@\n-  const oop forward_ptr = old->forward_to_atomic(obj, old_mark, memory_order_relaxed);\n+  const oop forward_ptr = fwd.forward_to_atomic(obj, memory_order_relaxed);\n@@ -545,2 +547,2 @@\n-                                                 markWord old_mark) {\n-  return do_copy_to_survivor_space(region_attr, old, old_mark);\n+                                                 const OopForwarding& fwd) {\n+  return do_copy_to_survivor_space(region_attr, old, fwd);\n@@ -603,1 +605,1 @@\n-oop G1ParScanThreadState::handle_evacuation_failure_par(oop old, markWord m, size_t word_sz) {\n+oop G1ParScanThreadState::handle_evacuation_failure_par(oop old, const OopForwarding& fwd, size_t word_sz) {\n@@ -606,1 +608,1 @@\n-  oop forward_ptr = old->forward_to_atomic(old, m, memory_order_relaxed);\n+  oop forward_ptr = fwd.forward_to_atomic(old, memory_order_relaxed);\n@@ -615,1 +617,1 @@\n-    _preserved_marks->push_if_necessary(old, m);\n+    _preserved_marks->push_if_necessary(old, fwd.mark());\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.cpp","additions":20,"deletions":18,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+class OopForwarding;\n@@ -173,1 +174,1 @@\n-                                markWord old_mark);\n+                                const OopForwarding& fwd);\n@@ -207,1 +208,1 @@\n-  oop copy_to_survivor_space(G1HeapRegionAttr region_attr, oop obj, markWord old_mark);\n+  oop copy_to_survivor_space(G1HeapRegionAttr region_attr, oop obj, const OopForwarding& fwd);\n@@ -217,1 +218,1 @@\n-  oop handle_evacuation_failure_par(oop obj, markWord m, size_t word_sz);\n+  oop handle_evacuation_failure_par(oop obj, const OopForwarding& fwd, size_t word_sz);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.hpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"oops\/oopForwarding.hpp\"\n@@ -114,1 +115,1 @@\n-  assert(dest_attr.is_in_cset() == (obj->is_forwarded() && obj->forwardee() == obj),\n+  assert(dest_attr.is_in_cset() == (OopForwarding(obj).is_forwarded() && (OopForwarding(obj).forwardee() == obj)),\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.inline.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -60,0 +60,1 @@\n+#include \"oops\/oopForwarding.hpp\"\n@@ -859,2 +860,3 @@\n-      assert( obj->is_forwarded(), \"invariant\" );\n-      *p = obj->forwardee();\n+      OopForwarding fwd(obj);\n+      assert(fwd.is_forwarded(), \"invariant\" );\n+      *p = OopForwarding(obj).forwardee();\n@@ -862,1 +864,1 @@\n-      assert(!obj->is_forwarded(), \"invariant\" );\n+      assert(!OopForwarding(obj).is_forwarded(), \"invariant\" );\n@@ -993,1 +995,1 @@\n-  return !_g1h->is_in_cset(p) || p->is_forwarded();\n+  return !_g1h->is_in_cset(p) || OopForwarding(p).is_forwarded();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungCollector.cpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"oops\/oopForwarding.hpp\"\n@@ -44,2 +45,3 @@\n-      assert(o->is_forwarded(), \"Objects are already forwarded before weak processing\");\n-      oop new_obj = o->forwardee();\n+      OopForwarding fwd(o);\n+      assert(fwd.is_forwarded(), \"Objects are already forwarded before weak processing\");\n+      oop new_obj = fwd.forwardee();\n","filename":"src\/hotspot\/share\/gc\/parallel\/psClosure.inline.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,0 +43,1 @@\n+#include \"oops\/oopForwarding.hpp\"\n@@ -318,1 +319,1 @@\n-  assert(old->is_forwarded(), \"invariant\");\n+  assert(OopForwarding(old).is_forwarded(), \"invariant\");\n@@ -322,1 +323,1 @@\n-  oop const obj = old->forwardee();\n+  oop const obj = OopForwarding(old).forwardee();\n@@ -347,1 +348,1 @@\n-oop PSPromotionManager::oop_promotion_failed(oop obj, markWord obj_mark) {\n+oop PSPromotionManager::oop_promotion_failed(oop obj, const OopForwarding& fwd) {\n@@ -355,1 +356,2 @@\n-  if (obj->forward_to_atomic(obj, obj_mark) == NULL) {\n+  oop forwardee = fwd.forward_to_atomic(obj);\n+  if (forwardee== NULL) {\n@@ -357,1 +359,1 @@\n-    assert(obj == obj->forwardee(), \"Sanity\");\n+    assert(obj == OopForwarding(obj).forwardee(), \"Sanity\");\n@@ -363,1 +365,1 @@\n-    _preserved_marks->push_if_necessary(obj, obj_mark);\n+    _preserved_marks->push_if_necessary(obj, fwd.mark());\n@@ -366,1 +368,1 @@\n-    guarantee(obj->is_forwarded(), \"Object must be forwarded if the cas failed.\");\n+    guarantee(OopForwarding(obj).is_forwarded(), \"Object must be forwarded if the cas failed.\");\n@@ -369,1 +371,1 @@\n-    obj = obj->forwardee();\n+    obj = forwardee;\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.cpp","additions":11,"deletions":9,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+class OopForwarding;\n@@ -116,1 +117,1 @@\n-  oop copy_unmarked_to_survivor_space(oop o, markWord m);\n+  oop copy_unmarked_to_survivor_space(oop o, const OopForwarding& fwd);\n@@ -144,1 +145,1 @@\n-  oop oop_promotion_failed(oop obj, markWord obj_mark);\n+  oop oop_promotion_failed(oop obj, const OopForwarding& fwd);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+#include \"oops\/oopForwarding.hpp\"\n@@ -139,3 +140,3 @@\n-  markWord m = o->mark();\n-  if (!m.is_marked()) {\n-    return copy_unmarked_to_survivor_space<promote_immediately>(o, m);\n+  OopForwarding fwd(o);\n+  if (!fwd.is_forwarded()) {\n+    return copy_unmarked_to_survivor_space<promote_immediately>(o, fwd);\n@@ -148,1 +149,1 @@\n-    return cast_to_oop(m.decode_pointer());\n+    return fwd.forwardee();\n@@ -159,1 +160,1 @@\n-                                                               markWord test_mark) {\n+                                                               const OopForwarding& fwd) {\n@@ -167,0 +168,1 @@\n+  markWord test_mark = fwd.mark();\n@@ -202,1 +204,1 @@\n-      return oop_promotion_failed(o, test_mark);\n+      return oop_promotion_failed(o, fwd);\n@@ -245,1 +247,1 @@\n-        return oop_promotion_failed(o, test_mark);\n+        return oop_promotion_failed(o, fwd);\n@@ -257,1 +259,1 @@\n-  oop forwardee = o->forward_to_atomic(new_obj, test_mark, memory_order_release);\n+  oop forwardee = fwd.forward_to_atomic(new_obj, memory_order_release);\n@@ -260,1 +262,1 @@\n-    assert(new_obj == o->forwardee(), \"Sanity\");\n+    assert(new_obj == OopForwarding(o).forwardee(), \"Sanity\");\n@@ -297,2 +299,2 @@\n-    assert(o->is_forwarded(), \"Object must be forwarded if the cas failed.\");\n-    assert(o->forwardee() == forwardee, \"invariant\");\n+    assert(OopForwarding(o).is_forwarded(), \"Object must be forwarded if the cas failed.\");\n+    assert(OopForwarding(o).forwardee() == forwardee, \"invariant\");\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.inline.hpp","additions":13,"deletions":11,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -66,0 +66,1 @@\n+#include \"oops\/oopForwarding.hpp\"\n@@ -147,1 +148,1 @@\n-    return (!PSScavenge::is_obj_in_young(p)) || p->is_forwarded();\n+    return (!PSScavenge::is_obj_in_young(p)) || OopForwarding(p).is_forwarded();\n","filename":"src\/hotspot\/share\/gc\/parallel\/psScavenge.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -56,0 +56,1 @@\n+#include \"oops\/oopForwarding.hpp\"\n@@ -74,1 +75,1 @@\n-  return cast_from_oop<HeapWord*>(p) >= _young_gen->reserved().end() || p->is_forwarded();\n+  return cast_from_oop<HeapWord*>(p) >= _young_gen->reserved().end() || OopForwarding(p).is_forwarded();\n@@ -689,1 +690,1 @@\n-  old->forward_to(old);\n+  OopForwarding::forward_to(old,old);\n@@ -702,1 +703,1 @@\n-  assert(is_in_reserved(old) && !old->is_forwarded(),\n+  assert(is_in_reserved(old) && !OopForwarding(old).is_forwarded(),\n@@ -735,1 +736,1 @@\n-  old->forward_to(obj);\n+  OopForwarding::forward_to(old,obj);\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.cpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+#include \"oops\/oopForwarding.hpp\"\n@@ -91,7 +92,3 @@\n-    oop new_obj = cast_to_oop(obj->mark().decode_pointer());\n-\n-    assert(new_obj != NULL ||                      \/\/ is forwarding ptr?\n-           obj->mark() == markWord::prototype(), \/\/ not gc marked?\n-           \"should be forwarded\");\n-\n-    if (new_obj != NULL) {\n+    OopForwarding fwd(obj);\n+    if (fwd.is_forwarded()) {\n+      oop new_obj = fwd.forwardee();\n","filename":"src\/hotspot\/share\/gc\/serial\/markSweep.inline.hpp","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+#include \"oops\/oopForwarding.hpp\"\n@@ -59,2 +60,3 @@\n-      oop new_obj = obj->is_forwarded() ? obj->forwardee()\n-                                        : _young_gen->copy_to_survivor_space(obj);\n+      OopForwarding fwd(obj);\n+      oop new_obj = fwd.is_forwarded() ? fwd.forwardee()\n+                                       : _young_gen->copy_to_survivor_space(obj);\n@@ -125,2 +127,3 @@\n-    oop new_obj = obj->is_forwarded() ? obj->forwardee()\n-                                      : _g->copy_to_survivor_space(obj);\n+    OopForwarding fwd(obj);\n+    oop new_obj = fwd.is_forwarded() ? fwd.forwardee()\n+                                     : _g->copy_to_survivor_space(obj);\n","filename":"src\/hotspot\/share\/gc\/shared\/genOopClosures.inline.hpp","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"oops\/oopForwarding.hpp\"\n@@ -49,2 +50,3 @@\n-    if (obj->is_forwarded()) {\n-      elem->set_oop(obj->forwardee());\n+    OopForwarding fwd(obj);\n+    if (fwd.is_forwarded()) {\n+      elem->set_oop(fwd.forwardee());\n@@ -75,1 +77,1 @@\n-  if (obj->is_forwarded()) {\n+  if (OopForwarding(obj).is_forwarded()) {\n","filename":"src\/hotspot\/share\/gc\/shared\/preservedMarks.cpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+#include \"oops\/oopForwarding.hpp\"\n@@ -373,1 +374,1 @@\n-    q->forward_to(cast_to_oop(compact_top));\n+    OopForwarding::forward_to(q, cast_to_oop(compact_top));\n@@ -379,1 +380,1 @@\n-    assert(q->forwardee() == NULL, \"should be forwarded to NULL\");\n+    assert(!OopForwarding(q).is_forwarded(), \"should not be forwarded\");\n@@ -539,1 +540,2 @@\n-    if (!cast_to_oop(cur_obj)->is_gc_marked()) {\n+    OopForwarding fwd = OopForwarding(cast_to_oop(cur_obj));\n+    if (!fwd.is_forwarded()) {\n@@ -550,1 +552,1 @@\n-      HeapWord* compaction_top = cast_from_oop<HeapWord*>(cast_to_oop(cur_obj)->forwardee());\n+      HeapWord* compaction_top = fwd.forwardee<HeapWord*>();\n","filename":"src\/hotspot\/share\/gc\/shared\/space.cpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -56,0 +56,1 @@\n+#include \"oops\/oopForwarding.hpp\"\n@@ -361,1 +362,1 @@\n-    p->forward_to(cast_to_oop(_compact_point));\n+    OopForwarding::forward_to(p, cast_to_oop(_compact_point));\n@@ -469,1 +470,1 @@\n-        old_obj->forward_to(cast_to_oop(heap->get_region(start)->bottom()));\n+        OopForwarding::forward_to(old_obj, cast_to_oop(heap->get_region(start)->bottom()));\n@@ -729,2 +730,3 @@\n-      if (obj->is_forwarded()) {\n-        oop forw = obj->forwardee();\n+      OopForwarding fwd(obj);\n+      if (fwd.is_forwarded()) {\n+        oop forw = fwd.forwardee();\n@@ -838,1 +840,2 @@\n-    if (p->is_forwarded()) {\n+    OopForwarding fwd(p);\n+    if (fwd.is_forwarded()) {\n@@ -840,1 +843,1 @@\n-      HeapWord* compact_to = cast_from_oop<HeapWord*>(p->forwardee());\n+      HeapWord* compact_to = cast_from_oop<HeapWord*>(fwd.forwardee());\n@@ -940,1 +943,2 @@\n-      if (!old_obj->is_forwarded()) {\n+      OopForwarding fwd(old_obj);\n+      if (!fwd.is_forwarded()) {\n@@ -949,1 +953,1 @@\n-      size_t new_start = heap->heap_region_index_containing(old_obj->forwardee());\n+      size_t new_start = heap->heap_region_index_containing(fwd.forwardee());\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFullGC.cpp","additions":12,"deletions":8,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -950,1 +950,1 @@\n-    if (!p->is_forwarded()) {\n+    if (!ShenandoahForwarding::is_forwarded(p)) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -219,7 +219,0 @@\n-void oopDesc::verify_forwardee(oop forwardee) {\n-#if INCLUDE_CDS_JAVA_HEAP\n-  assert(!Universe::heap()->is_archived_object(forwardee) && !Universe::heap()->is_archived_object(this),\n-         \"forwarding archive object\");\n-#endif\n-}\n-\n","filename":"src\/hotspot\/share\/oops\/oop.cpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -249,15 +249,0 @@\n-  \/\/ Forward pointer operations for scavenge\n-  inline bool is_forwarded() const;\n-\n-  void verify_forwardee(oop forwardee) NOT_DEBUG_RETURN;\n-\n-  inline void forward_to(oop p);\n-\n-  \/\/ Like \"forward_to\", but inserts the forwarding pointer atomically.\n-  \/\/ Exactly one thread succeeds in inserting the forwarding pointer, and\n-  \/\/ this call returns \"NULL\" for that thread; any other thread has the\n-  \/\/ value of the forwarding pointer returned and does not modify \"this\".\n-  inline oop forward_to_atomic(oop p, markWord compare, atomic_memory_order order = memory_order_conservative);\n-\n-  inline oop forwardee() const;\n-\n","filename":"src\/hotspot\/share\/oops\/oop.hpp","additions":0,"deletions":15,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -193,1 +193,1 @@\n-             (Universe::is_gc_active() && is_objArray() && is_forwarded() && (get_UseParallelGC() || get_UseG1GC())),\n+             (Universe::is_gc_active() && is_objArray() && mark().is_marked() && (get_UseParallelGC() || get_UseG1GC())),\n@@ -261,34 +261,0 @@\n-\/\/ Used by scavengers\n-bool oopDesc::is_forwarded() const {\n-  \/\/ The extra heap check is needed since the obj might be locked, in which case the\n-  \/\/ mark would point to a stack location and have the sentinel bit cleared\n-  return mark().is_marked();\n-}\n-\n-\/\/ Used by scavengers\n-void oopDesc::forward_to(oop p) {\n-  verify_forwardee(p);\n-  markWord m = markWord::encode_pointer_as_mark(p);\n-  assert(m.decode_pointer() == p, \"encoding must be reversable\");\n-  set_mark(m);\n-}\n-\n-oop oopDesc::forward_to_atomic(oop p, markWord compare, atomic_memory_order order) {\n-  verify_forwardee(p);\n-  markWord m = markWord::encode_pointer_as_mark(p);\n-  assert(m.decode_pointer() == p, \"encoding must be reversable\");\n-  markWord old_mark = cas_set_mark(m, compare, order);\n-  if (old_mark == compare) {\n-    return NULL;\n-  } else {\n-    return cast_to_oop(old_mark.decode_pointer());\n-  }\n-}\n-\n-\/\/ Note that the forwardee is not the same thing as the displaced_mark.\n-\/\/ The forwardee is used when copying during scavenge and mark-sweep.\n-\/\/ It does need to clear the low two locking- and GC-related bits.\n-oop oopDesc::forwardee() const {\n-  return cast_to_oop(mark().decode_pointer());\n-}\n-\n@@ -297,1 +263,1 @@\n-  assert(!is_forwarded(), \"Attempt to read age from forwarded mark\");\n+  assert(!mark().is_marked(), \"Attempt to read age from forwarded mark\");\n@@ -306,1 +272,1 @@\n-  assert(!is_forwarded(), \"Attempt to increment age of forwarded mark\");\n+  assert(!mark().is_marked(), \"Attempt to increment age of forwarded mark\");\n","filename":"src\/hotspot\/share\/oops\/oop.inline.hpp","additions":3,"deletions":37,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -0,0 +1,132 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_OOPS_MARKWORDDECODER_HPP\n+#define SHARE_OOPS_MARKWORDDECODER_HPP\n+\n+#include \"gc\/shared\/collectedHeap.hpp\"\n+#include \"memory\/universe.hpp\"\n+#include \"oops\/markWord.hpp\"\n+\n+\/**\n+ * Decodes pointers that are encoded in object's mark-words. Specifically, it structures common sequences like:\n+ * if (obj->is_forwarded()) { \/\/ Load mark-word and test lowest 2 bits for 0b11\n+ *   fwd = obj->forwardee();  \/\/ Load mark-word and mask-out lowest 3 bits\n+ * } else\n+ *   fwd = ... \/\/ Something else\n+ * }\n+ *\n+ * to be most efficient.\n+ * The above structure has a number of problems:\n+ * - It loads the mark-word twice. The compiler may choose to coalesce the loads, though.\n+ * - Assuming the compiler can coalesce the loads, or it has been written better to begin with,\n+ *   the generated assembly code would typically look like this:\n+ *\n+ *   mov r, (robj)     ; Load mark-word into r\n+ *   mov rtmp, r       ; Preserve r for decoding path, requires allocation of temp register\n+ *   and rtmp, 0b11    ; Mask lowest two bits\n+ *   cmp rtmp, 0b11    ; Check if both bits set\n+ *   jne false-branch  ; Do 'Something else'\n+ *   mov rtmp, ~0b11   ; Load large immediate constant, requires several instructions on x86 other arches\n+ *   ...               ; More instructions (shifts, moves) to get immediate into rtmp\n+ *   and r, rtmp       ; Mask upper bits\n+ *   ...               ; false-branch returns here, too\n+ *\n+ * We can improve this by:\n+ * - Not loading the mark-word twice\n+ * - Not requiring a tmp register\n+ * - Avoiding large immediate constant\n+ * - Indeed, making the true-branch a no-op\n+ *\n+ * We can do so by inverting the bits that we want to test for using XOR, and test for 0. By this, we readily\n+ * get the decoded pointer in the target register:\n+ *\n+ *   mov r, (robj)     ; Load mark-word into r\n+ *   xor r, 0b11       ; Invert lowest two bits\n+ *   test r, 0b11      ; Test (mask) lowest two bits\n+ *   jne false-branch  ; Do 'Something else'\n+ *   ...               ; false-branch returns here, true-branch has result in r already\n+ *\/\n+class OopForwarding {\n+private:\n+  const oop _obj;\n+  const uintptr_t _value;\n+\n+  static void verify_forwardee(oop obj, oop forwardee) {\n+#ifdef ASSERT\n+#if INCLUDE_CDS_JAVA_HEAP\n+    assert(!Universe::heap()->is_archived_object(forwardee) && !Universe::heap()->is_archived_object(obj),\n+           \"forwarding archive object\");\n+#endif\n+#endif\n+  }\n+\n+public:\n+  explicit OopForwarding(oop obj) :\n+  _obj(obj), _value(obj->mark().value() ^ markWord::marked_value) {}\n+\n+  inline bool is_forwarded() const {\n+    return (_value & markWord::lock_mask_in_place) == 0;\n+  }\n+\n+  template <typename T>\n+  inline T forwardee() const {\n+    assert(is_forwarded(), \"only decode when encoded\");\n+    return reinterpret_cast<T>(_value);\n+  }\n+\n+  inline oop forwardee() const {\n+    return cast_to_oop(forwardee<HeapWord*>());\n+  }\n+\n+  static void forward_to(oop obj, oop fwd) {\n+    verify_forwardee(obj, fwd);\n+    markWord m = markWord::encode_pointer_as_mark(fwd);\n+    assert(m.decode_pointer() == fwd, \"encoding must be reversable\");\n+    obj->set_mark(m);\n+  }\n+\n+  \/\/ Like \"forward_to\", but inserts the forwarding pointer atomically.\n+  \/\/ Exactly one thread succeeds in inserting the forwarding pointer, and\n+  \/\/ this call returns \"NULL\" for that thread; any other thread has the\n+  \/\/ value of the forwarding pointer returned and does not modify \"this\".\n+  oop forward_to_atomic(oop p, atomic_memory_order order = memory_order_conservative) const {\n+    verify_forwardee(_obj, p);\n+    markWord compare = mark();\n+    markWord m = markWord::encode_pointer_as_mark(p);\n+    assert(m.decode_pointer() == p, \"encoding must be reversable\");\n+    markWord old_mark = _obj->cas_set_mark(m, compare, order);\n+    if (old_mark == compare) {\n+      return NULL;\n+    } else {\n+      return cast_to_oop(old_mark.decode_pointer());\n+    }\n+  }\n+\n+  markWord mark() const {\n+    return markWord(_value ^ markWord::marked_value);\n+  }\n+};\n+\n+#endif \/\/ SHARE_OOPS_MARKWORDDECODER_HPP\n","filename":"src\/hotspot\/share\/oops\/oopForwarding.hpp","additions":132,"deletions":0,"binary":false,"changes":132,"status":"added"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"oops\/oopForwarding.hpp\"\n@@ -77,2 +78,2 @@\n-  ASSERT_EQ(o1.get_oop()->forwardee(), o3.get_oop());\n-  ASSERT_EQ(o2.get_oop()->forwardee(), o4.get_oop());\n+  ASSERT_EQ(OopForwarding(o1.get_oop()).forwardee(), o3.get_oop());\n+  ASSERT_EQ(OopForwarding(o2.get_oop()).forwardee(), o4.get_oop());\n","filename":"test\/hotspot\/gtest\/gc\/shared\/test_preservedMarks.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"}]}