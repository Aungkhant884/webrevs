{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -284,34 +284,28 @@\n-\/\/------------------------------mul_ring---------------------------------------\n-\/\/ Compute the product type of two integer ranges into this node.\n-const Type *MulINode::mul_ring(const Type *t0, const Type *t1) const {\n-  const TypeInt *r0 = t0->is_int(); \/\/ Handy access\n-  const TypeInt *r1 = t1->is_int();\n-\n-  \/\/ Fetch endpoints of all ranges\n-  jint lo0 = r0->_lo;\n-  double a = (double)lo0;\n-  jint hi0 = r0->_hi;\n-  double b = (double)hi0;\n-  jint lo1 = r1->_lo;\n-  double c = (double)lo1;\n-  jint hi1 = r1->_hi;\n-  double d = (double)hi1;\n-\n-  \/\/ Compute all endpoints & check for overflow\n-  int32_t A = java_multiply(lo0, lo1);\n-  if( (double)A != a*c ) return TypeInt::INT; \/\/ Overflow?\n-  int32_t B = java_multiply(lo0, hi1);\n-  if( (double)B != a*d ) return TypeInt::INT; \/\/ Overflow?\n-  int32_t C = java_multiply(hi0, lo1);\n-  if( (double)C != b*c ) return TypeInt::INT; \/\/ Overflow?\n-  int32_t D = java_multiply(hi0, hi1);\n-  if( (double)D != b*d ) return TypeInt::INT; \/\/ Overflow?\n-\n-  if( A < B ) { lo0 = A; hi0 = B; } \/\/ Sort range endpoints\n-  else { lo0 = B; hi0 = A; }\n-  if( C < D ) {\n-    if( C < lo0 ) lo0 = C;\n-    if( D > hi0 ) hi0 = D;\n-  } else {\n-    if( D < lo0 ) lo0 = D;\n-    if( C > hi0 ) hi0 = C;\n+\/\/ Helper classes to perform mul_ring() for MulI\/MulLNode.\n+template <typename IntegerType>\n+struct OverflowType : AllStatic {\n+  static_assert(IsSame<IntegerType, TypeInt>::value, \"must be TypeInteger\");\n+  static const Type* overflow() { return TypeInt::INT; }\n+};\n+\n+template <>\n+struct OverflowType<TypeLong> : AllStatic {\n+  static const Type* overflow() { return TypeLong::LONG; }\n+};\n+\n+template<typename IntegerType>\n+class IntegerMulRing {\n+  typedef typename Conditional<IsSame<TypeInt, IntegerType>::value, jint, jlong>::type NativeType;\n+\n+  const IntegerType* _left;\n+  const IntegerType* _right;\n+  NativeType _min_value = IntegerType::MIN->_lo;\n+\n+\n+  \/\/ Check overflow by using arithmetic equality: x = a * b <=> x \/ a = b. Since a and b are integer numbers, the division\n+  \/\/ x \/ a does not underflow\/overflow since |x \/ a| <= |x|. If a * b does underflow\/overflow, then we'll get a different\n+  \/\/ result compared to a * b. Special case MIN_VALUE * -1 whose result is MIN_VALUE.\n+  bool does_overflow(const NativeType a, const NativeType b) const {\n+    NativeType x = java_multiply(a, b);\n+    return (a == -1 && b == _min_value) || \/\/ Special case 'MIN_VALUE * -1 = MIN_VALUE'.\n+           (a != 0 && x \/ a != b);\n@@ -319,1 +313,34 @@\n-  return TypeInt::make(lo0, hi0, MAX2(r0->_widen,r1->_widen));\n+\n+ public:\n+  IntegerMulRing(const IntegerType* left, const IntegerType* right) : _left(left), _right(right) {}\n+\n+  \/\/ Compute the product type by multiplying the two input type ranges. We take the minimum and maximum of all possible\n+  \/\/ values (requires 4 multiplications of all possible combinations of the two range boundary values). If any of these\n+  \/\/ multiplications overflows\/underflows, we return the bottom type (full range of values).\n+  const Type* compute() const {\n+    const NativeType lo_left = _left->_lo;\n+    const NativeType hi_left = _left->_hi;\n+    const NativeType lo_right = _right->_lo;\n+    const NativeType hi_right = _right->_hi;\n+\n+    if (does_overflow(lo_left, lo_right) ||\n+        does_overflow(lo_left, hi_right) ||\n+        does_overflow(hi_left, lo_right) ||\n+        does_overflow(hi_left, hi_right)) {\n+      return OverflowType<IntegerType>::overflow(); \/\/ Full range of values - bottom type.\n+    }\n+\n+    NativeType lo_lo_product = java_multiply(lo_left, lo_right);\n+    NativeType lo_hi_product = java_multiply(lo_left, hi_right);\n+    NativeType hi_lo_product = java_multiply(hi_left, lo_right);\n+    NativeType hi_hi_product = java_multiply(hi_left, hi_right);\n+    NativeType min = MIN4(lo_lo_product, lo_hi_product, hi_lo_product, hi_hi_product);\n+    NativeType max = MAX4(lo_lo_product, lo_hi_product, hi_lo_product, hi_hi_product);\n+    return IntegerType::make(min, max, MAX2(_left->_widen, _right->_widen));\n+  }\n+};\n+\n+\/\/ Compute the product type of two integer ranges into this node.\n+const Type* MulINode::mul_ring(const Type* type_left, const Type* type_right) const {\n+  const IntegerMulRing<TypeInt> integer_mul_ring(type_left->is_int(), type_right->is_int());\n+  return integer_mul_ring.compute();\n@@ -322,0 +349,5 @@\n+\/\/ Compute the product type of two long ranges into this node.\n+const Type* MulLNode::mul_ring(const Type* type_left, const Type* type_right) const {\n+  const IntegerMulRing<TypeLong> integer_mul_ring(type_left->is_long(), type_right->is_long());\n+  return integer_mul_ring.compute();\n+}\n@@ -380,38 +412,0 @@\n-\/\/------------------------------mul_ring---------------------------------------\n-\/\/ Compute the product type of two integer ranges into this node.\n-const Type *MulLNode::mul_ring(const Type *t0, const Type *t1) const {\n-  const TypeLong *r0 = t0->is_long(); \/\/ Handy access\n-  const TypeLong *r1 = t1->is_long();\n-\n-  \/\/ Fetch endpoints of all ranges\n-  jlong lo0 = r0->_lo;\n-  double a = (double)lo0;\n-  jlong hi0 = r0->_hi;\n-  double b = (double)hi0;\n-  jlong lo1 = r1->_lo;\n-  double c = (double)lo1;\n-  jlong hi1 = r1->_hi;\n-  double d = (double)hi1;\n-\n-  \/\/ Compute all endpoints & check for overflow\n-  jlong A = java_multiply(lo0, lo1);\n-  if( (double)A != a*c ) return TypeLong::LONG; \/\/ Overflow?\n-  jlong B = java_multiply(lo0, hi1);\n-  if( (double)B != a*d ) return TypeLong::LONG; \/\/ Overflow?\n-  jlong C = java_multiply(hi0, lo1);\n-  if( (double)C != b*c ) return TypeLong::LONG; \/\/ Overflow?\n-  jlong D = java_multiply(hi0, hi1);\n-  if( (double)D != b*d ) return TypeLong::LONG; \/\/ Overflow?\n-\n-  if( A < B ) { lo0 = A; hi0 = B; } \/\/ Sort range endpoints\n-  else { lo0 = B; hi0 = A; }\n-  if( C < D ) {\n-    if( C < lo0 ) lo0 = C;\n-    if( D > hi0 ) hi0 = D;\n-  } else {\n-    if( D < lo0 ) lo0 = D;\n-    if( C > hi0 ) hi0 = C;\n-  }\n-  return TypeLong::make(lo0, hi0, MAX2(r0->_widen,r1->_widen));\n-}\n-\n","filename":"src\/hotspot\/share\/opto\/mulnode.cpp","additions":68,"deletions":74,"binary":false,"changes":142,"status":"modified"},{"patch":"@@ -0,0 +1,155 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package compiler.c2.irTests.igvn;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.test.lib.Asserts;\n+\n+\/*\n+ * @test\n+ * @bug 8299546\n+ * @summary Test that IntegerMulRing works correctly and returns correct (and optimized) types.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.igvn.TestIntegerMulRing\n+ *\/\n+public class TestIntegerMulRing {\n+    public static int iFld, iFld2, iFld3, iFld4;\n+    public static long lFld, lFld2, lFld3, lFld4;\n+\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_I, IRNode.IF}, counts = {IRNode.STORE_L, \"2\"})\n+    public static void testLongPositive() {\n+        long l = 111111111111111111L;\n+        if (l * 81 == 1L) {\n+            iFld = 23;\n+        }\n+        if (l * 81 == 8999999999999999991L) {\n+            lFld = 23;\n+        }\n+        if (l * 83 == 1L) {\n+            iFld2 = 34;\n+        }\n+        if (l * 83 == 9222222222222222213L) {\n+            lFld2 = 23;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_I, IRNode.IF}, counts = {IRNode.STORE_L, \"2\"})\n+    public static void testLongPositive2() {\n+        long l = -111111111111111111L;\n+        if (l * -81 == 1L) {\n+            iFld = 23;\n+        }\n+        if (l * -81 == 8999999999999999991L) {\n+            lFld = 23;\n+        }\n+        if (l * -83 == 1L) {\n+            iFld2 = 34;\n+        }\n+        if (l * -83 == 9222222222222222213L) {\n+            lFld2 = 23;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_I, IRNode.IF}, counts = {IRNode.STORE_L, \"2\"})\n+    public static void testLongNegative() {\n+        long l = -111111111111111111L;\n+        if (l * 81 == 1L) {\n+            iFld = 23;\n+        }\n+        if (l * 81 == -8999999999999999991L) {\n+            lFld = 23;\n+        }\n+        if (l * 83 == 1L) {\n+            iFld2 = 34;\n+        }\n+        if (l * 83 == -9222222222222222213L) {\n+            lFld2 = 23;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_I, IRNode.IF}, counts = {IRNode.STORE_L, \"2\"})\n+    public static void testLongNegative2() {\n+        long l = 111111111111111111L;\n+        if (l * -81 == 1L) {\n+            iFld = 23;\n+        }\n+        if (l * -81 == -8999999999999999991L) {\n+            lFld = 23;\n+        }\n+        if (l * -83 == 1L) {\n+            iFld2 = 34;\n+        }\n+        if (l * -83 == -9222222222222222213L) {\n+            lFld2 = 23;\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(0)\n+    @Arguments({Argument.BOOLEAN_TOGGLE_FIRST_TRUE, Argument.BOOLEAN_TOGGLE_FIRST_FALSE})\n+    @IR(counts = {IRNode.STORE_L, \"2\", IRNode.MUL_L, \"1\"})\n+    public static void testMinValueMinus1(boolean flag, boolean flag2) {\n+        long l = flag ? -1 : Long.MIN_VALUE;\n+        int x = flag2 ? -1 : 0;\n+\n+        if (l * x != 2L) { \/\/ Type of multiplication is LONG as Long.MIN_VALUE * -1 does overflow. If cannot be removed.\n+            lFld = 23;\n+        } else {\n+            lFld = 34; \/\/ Emits StoreL since warmup is 0 and no UCT will be emitted.\n+        }\n+    }\n+\n+    \/\/ Just some sanity testing.\n+    @Test\n+    public static void test() {\n+        iFld = 1073741823 * 2;\n+        iFld2 = 1073741824 * 2; \/\/ overflow\n+        iFld3 = -1073741824 * 2;\n+        iFld4 = -1073741825 * 2; \/\/ underflow\n+        lFld = 4611686018427387903L * 2;\n+        lFld2 = 4611686018427387904L * 2; \/\/ overflow\n+        lFld3 = -4611686018427387904L * 2;\n+        lFld4 = -4611686018427387905L * 2; \/\/ underflow\n+    }\n+\n+    @Run(test = \"test\")\n+    public static void run() {\n+        test();\n+        Asserts.assertEQ(iFld, 2147483646);\n+        Asserts.assertEQ(iFld2, -2147483648);\n+        Asserts.assertEQ(iFld3, -2147483648);\n+        Asserts.assertEQ(iFld4, 2147483646);\n+        Asserts.assertEQ(lFld, 9223372036854775806L);\n+        Asserts.assertEQ(lFld2, -9223372036854775808L);\n+        Asserts.assertEQ(lFld3, -9223372036854775808L);\n+        Asserts.assertEQ(lFld4, 9223372036854775806L);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/igvn\/TestIntegerMulRing.java","additions":155,"deletions":0,"binary":false,"changes":155,"status":"added"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8299546\n+ * @summary Tests that MulL::Value() does not return bottom type and then an optimized type again in CCP.\n+ * @run main\/othervm -Xcomp -XX:CompileCommand=compileonly,compiler.ccp.TestMissingMulLOptimization::*\n+ *                   -XX:CompileCommand=dontinline,compiler.ccp.TestMissingMulLOptimization::*\n+ *                   compiler.ccp.TestMissingMulLOptimization\n+ *\/\n+package compiler.ccp;\n+\n+public class TestMissingMulLOptimization {\n+    static int N;\n+    static long x;\n+\n+    public static void main(String[] strArr) {\n+        try {\n+            test();\n+        } catch (RuntimeException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    static int test() {\n+        int i6 = 2, i10 = 3, i11, iArr[] = new int[N];\n+        long l = 3151638515L;\n+        double dArr[] = new double[N];\n+        dontInline();\n+        int i;\n+        for (i = 7; i < 221; i++) {\n+            i6 *= i6;\n+        }\n+        for (int j = 9; 83 > j; ) {\n+            for (i11 = 1; i11 < 6; ++i11) {\n+                l *= i;\n+                l += 3;\n+            }\n+        }\n+        x += i6;\n+        return 34;\n+    }\n+\n+    static int dontInline() {\n+        throw new RuntimeException();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/ccp\/TestMissingMulLOptimization.java","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"}]}