{"files":[{"patch":"@@ -284,12 +284,12 @@\n-\/\/ Helper classes to perform mul_ring() for MulI\/MulLNode.\n-template <typename IntegerType>\n-struct OverflowType : AllStatic {\n-  static_assert(IsSame<IntegerType, TypeInt>::value, \"must be TypeInteger\");\n-  static const Type* overflow() { return TypeInt::INT; }\n-};\n-\n-template <>\n-struct OverflowType<TypeLong> : AllStatic {\n-  static const Type* overflow() { return TypeLong::LONG; }\n-};\n-\n+\/\/ Classes to perform mul_ring() for MulI\/MulLNode.\n+\/\/\n+\/\/ This class checks if all cross products of the left and right input of a multiplication have the same \"overflow value\".\n+\/\/ Without overflow\/underflow:\n+\/\/ Product is positive? High signed multiplication result: 0\n+\/\/ Product is negative? High signed multiplication result: -1\n+\/\/\n+\/\/ We normalize these values (see normalize_overflow_value()) such that we get the same \"overflow value\" by adding 1 if\n+\/\/ the product is negative. This allows us to compare all the cross product \"overflow values\". If one is different,\n+\/\/ compared to the others, then we know that this multiplication has a different number of over- or underflows compared\n+\/\/ to the others. In this case, we need to use bottom type and cannot guarantee a better type. Otherwise, we can take\n+\/\/ the min und max of all computed cross products as type of this Mul node.\n@@ -298,18 +298,36 @@\n-  typedef typename Conditional<IsSame<TypeInt, IntegerType>::value, jint, jlong>::type NativeType;\n-\n-  const IntegerType* _left;\n-  const IntegerType* _right;\n-  NativeType _min_value = IntegerType::MIN->_lo;\n-\n-  \/\/ Check overflow by using arithmetic equality: x = a * b <=> x \/ a = b. Since a and b are integer numbers, the division\n-  \/\/ x \/ a does not underflow\/overflow since |x \/ a| <= |x|. If a * b does underflow\/overflow, then we'll get a different\n-  \/\/ result compared to a * b. Special case MIN_VALUE * -1 whose result is MIN_VALUE.\n-  bool does_overflow(const NativeType product_a_b, const NativeType a, const NativeType b) const {\n-    if (a == 0 || b == 0) {\n-      \/\/ Trivially no overflow.\n-      return false;\n-    } else if (a == -1 && b == _min_value) {\n-      \/\/ Special case 'MIN_VALUE * -1 = MIN_VALUE' does overflow.\n-      return true;\n-    }\n-    return product_a_b \/ a != b;\n+  using NativeType = std::conditional_t<std::is_same<TypeInt, IntegerType>::value, jint, jlong>;\n+\n+  NativeType _lo_left;\n+  NativeType _lo_right;\n+  NativeType _hi_left;\n+  NativeType _hi_right;\n+  NativeType _lo_lo_product;\n+  NativeType _lo_hi_product;\n+  NativeType _hi_lo_product;\n+  NativeType _hi_hi_product;\n+  short _widen_left;\n+  short _widen_right;\n+\n+  static const Type* overflow_type();\n+  static NativeType multiply_high_signed_overflow_value(NativeType x, NativeType y);\n+\n+  \/\/ Pre-compute cross products which are used at several places\n+  void compute_cross_products() {\n+    _lo_lo_product = java_multiply(_lo_left, _lo_right);\n+    _lo_hi_product = java_multiply(_lo_left, _hi_right);\n+    _hi_lo_product = java_multiply(_hi_left, _lo_right);\n+    _hi_hi_product = java_multiply(_hi_left, _hi_right);\n+  }\n+\n+  bool cross_products_not_same_overflow() const {\n+    const NativeType lo_lo_high_product = multiply_high_signed_overflow_value(_lo_left, _lo_right);\n+    const NativeType lo_hi_high_product = multiply_high_signed_overflow_value(_lo_left, _hi_right);\n+    const NativeType hi_lo_high_product = multiply_high_signed_overflow_value(_hi_left, _lo_right);\n+    const NativeType hi_hi_high_product = multiply_high_signed_overflow_value(_hi_left, _hi_right);\n+    return lo_lo_high_product != lo_hi_high_product ||\n+           lo_hi_high_product != hi_lo_high_product ||\n+           hi_lo_high_product != hi_hi_high_product;\n+  }\n+\n+  static NativeType normalize_overflow_value(const NativeType x, const NativeType y, NativeType result) {\n+    return java_multiply(x, y) < 0 ? result + 1 : result;\n@@ -319,1 +337,4 @@\n-  IntegerMulRing(const IntegerType* left, const IntegerType* right) : _left(left), _right(right) {}\n+  IntegerMulRing(const IntegerType* left, const IntegerType* right) : _lo_left(left->_lo), _lo_right(right->_lo),\n+    _hi_left(left->_hi), _hi_right(right->_hi), _widen_left(left->_widen), _widen_right(right->_widen)  {\n+    compute_cross_products();\n+  }\n@@ -323,1 +344,2 @@\n-  \/\/ multiplications overflows\/underflows, we return the bottom type (full range of values).\n+  \/\/ multiplications overflows\/underflows, we need to make sure that they all have the same number of overflows\/underflows\n+  \/\/ If that is not the case, we return the bottom type to cover all values due to the inconsistent overflows\/underflows).\n@@ -325,14 +347,2 @@\n-    const NativeType lo_left = _left->_lo;\n-    const NativeType hi_left = _left->_hi;\n-    const NativeType lo_right = _right->_lo;\n-    const NativeType hi_right = _right->_hi;\n-    const NativeType lo_lo_product = java_multiply(lo_left, lo_right);\n-    const NativeType lo_hi_product = java_multiply(lo_left, hi_right);\n-    const NativeType hi_lo_product = java_multiply(hi_left, lo_right);\n-    const NativeType hi_hi_product = java_multiply(hi_left, hi_right);\n-\n-    if (does_overflow(lo_lo_product, lo_left, lo_right) ||\n-        does_overflow(lo_hi_product, lo_left, hi_right) ||\n-        does_overflow(hi_lo_product, hi_left, lo_right) ||\n-        does_overflow(hi_hi_product, hi_left, hi_right)) {\n-      return OverflowType<IntegerType>::overflow(); \/\/ Full range of values - bottom type.\n+    if (cross_products_not_same_overflow()) {\n+      return overflow_type();\n@@ -340,4 +350,3 @@\n-\n-    const NativeType min = MIN4(lo_lo_product, lo_hi_product, hi_lo_product, hi_hi_product);\n-    const NativeType max = MAX4(lo_lo_product, lo_hi_product, hi_lo_product, hi_hi_product);\n-    return IntegerType::make(min, max, MAX2(_left->_widen, _right->_widen));\n+    const NativeType min = MIN4(_lo_lo_product, _lo_hi_product, _hi_lo_product, _hi_hi_product);\n+    const NativeType max = MAX4(_lo_lo_product, _lo_hi_product, _hi_lo_product, _hi_hi_product);\n+    return IntegerType::make(min, max, MAX2(_widen_left, _widen_right));\n@@ -347,0 +356,26 @@\n+\n+template <>\n+const Type* IntegerMulRing<TypeInt>::overflow_type() {\n+  return TypeInt::INT;\n+}\n+\n+template <>\n+jint IntegerMulRing<TypeInt>::multiply_high_signed_overflow_value(const jint x, const jint y) {\n+  const jlong x_64 = x;\n+  const jlong y_64 = y;\n+  const jlong product = x_64 * y_64;\n+  const jint result = (jint)((uint64_t)product >> 32u);\n+  return normalize_overflow_value(x, y, result);\n+}\n+\n+template <>\n+const Type* IntegerMulRing<TypeLong>::overflow_type() {\n+  return TypeLong::LONG;\n+}\n+\n+template <>\n+jlong IntegerMulRing<TypeLong>::multiply_high_signed_overflow_value(const jlong x, const jlong y) {\n+  const jlong result = multiply_high_signed(x, y);\n+  return normalize_overflow_value(x, y, result);\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/mulnode.cpp","additions":85,"deletions":50,"binary":false,"changes":135,"status":"modified"},{"patch":"@@ -1158,0 +1158,38 @@\n+\/\/ Right shifts with signed integers are compiler implementation specific according to the C++ standard.\n+\/\/ Use a portable version instead.\n+inline int64_t shift_right_arithmetic(int64_t value, uint8_t shift_amount) {\n+  return value < 0 ? (int64_t)(~(~(uint64_t)value >> shift_amount)) : (int64_t)((uint64_t)value >> shift_amount);\n+}\n+\n+\/\/ Taken from rom section 8-2 of Henry S. Warren, Jr., Hacker's Delight (2nd ed.) (Addison Wesley, 2013), 173-174.\n+inline uint64_t multiply_high_unsigned(const uint64_t x, const uint64_t y) {\n+  const uint64_t x1 = x >> 32u;\n+  const uint64_t x2 = x & 0xFFFFFFFF;\n+  const uint64_t y1 = y >> 32u;\n+  const uint64_t y2 = y & 0xFFFFFFFF;\n+  const uint64_t z2 = x2 * y2;\n+  const uint64_t t = x1 * y2 + (z2 >> 32u);\n+  uint64_t z1 = t & 0xFFFFFFFF;\n+  const uint64_t z0 = t >> 32u;\n+  z1 += x2 * y1;\n+\n+  return x1 * y1 + z0 + (z1 >> 32u);\n+}\n+\n+\/\/ Taken from java.lang.Math::multiplyHigh which uses the technique from section 8-2 of Henry S. Warren, Jr.,\n+\/\/ Hacker's Delight (2nd ed.) (Addison Wesley, 2013), 173-174 but adapted for signed longs.\n+inline int64_t multiply_high_signed(const int64_t x, const int64_t y) {\n+  const jlong x1 = shift_right_arithmetic(x, 32);\n+  const jlong x2 = x & 0xFFFFFFFF;\n+  const jlong y1 = shift_right_arithmetic(y, 32);\n+  const jlong y2 = y & 0xFFFFFFFF;\n+\n+  const uint64_t z2 = x2 * y2;\n+  const int64_t t = x1 * y2 + (z2 >> 32u); \/\/ Unsigned shift\n+  int64_t z1 = t & 0xFFFFFFFF;\n+  const int64_t z0 = shift_right_arithmetic(t, 32);\n+  z1 += x2 * y1;\n+\n+  return x1 * y1 + z0 + shift_right_arithmetic(z1, 32);\n+}\n+\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":38,"deletions":0,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-        TestFramework.run();\n+        TestFramework.runWithFlags(\"-XX:-SplitIfBlocks\");\n@@ -117,1 +117,1 @@\n-    @Arguments({Argument.BOOLEAN_TOGGLE_FIRST_TRUE, Argument.BOOLEAN_TOGGLE_FIRST_FALSE})\n+    @Arguments({Argument.TRUE, Argument.FALSE})\n@@ -119,1 +119,1 @@\n-    public static void testMinValueMinus1(boolean flag, boolean flag2) {\n+    public static void testLongMinValueMinus1(boolean flag, boolean flag2) {\n@@ -130,0 +130,665 @@\n+    @Test\n+    @Warmup(0)\n+    @Arguments({Argument.TRUE, Argument.FALSE})\n+    @IR(failOn = {IRNode.MUL_L, IRNode.STORE_L}, counts = {IRNode.STORE_I, \"1\"})\n+    public static void testLongMinValuePlus1(boolean flag, boolean flag2) {\n+        long l = flag ? -1 : Long.MIN_VALUE;\n+        int x = flag2 ? 1 : 0;\n+\n+        if (l * x <= 0L) {\n+            iFld = 23;\n+        } else {\n+            lFld = 34;\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(0)\n+    @Arguments({Argument.TRUE, Argument.FALSE})\n+    @IR(failOn = {IRNode.MUL_L, IRNode.STORE_L, IRNode.LSHIFT}, counts = {IRNode.STORE_I, \"1\"})\n+    public static void testLongMinValueUnderflowOnce(boolean flag, boolean flag2) {\n+        long l = flag ? Long.MIN_VALUE\/2 : Long.MIN_VALUE\/2 + 1;\n+        int x = flag2 ? 4 : 6;\n+\n+        if (l * x <= 4L) {\n+            iFld = 23;\n+        } else {\n+            lFld = 34;\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(0)\n+    @Arguments({Argument.TRUE, Argument.FALSE})\n+    @IR(counts = {IRNode.STORE_I, \"1\", IRNode.STORE_L, \"1\", IRNode.MUL_L, \"1\"})\n+    public static void testLongMinValueUnderflowOnceTwice(boolean flag, boolean flag2) {\n+        long l = flag ? Long.MIN_VALUE\/2 : Long.MIN_VALUE\/2 + 1;\n+        int x = flag2 ? 6 : 8;\n+\n+        if (l * x <= 4L) {\n+            iFld = 23;\n+        } else {\n+            lFld = 34;\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(0)\n+    @Arguments({Argument.TRUE, Argument.FALSE})\n+    @IR(failOn = {IRNode.MUL_L, IRNode.STORE_L, IRNode.LSHIFT}, counts = {IRNode.STORE_I, \"1\"})\n+    public static void testLongMinValueUnderflowTwice(boolean flag, boolean flag2) {\n+        long l = flag ? Long.MIN_VALUE\/2 : Long.MIN_VALUE\/2 + 1;\n+        int x = flag2 ? 8 : 10;\n+\n+        if (l * x <= 8L) {\n+            iFld = 23;\n+        } else {\n+            lFld = 34;\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(0)\n+    @Arguments({Argument.TRUE, Argument.FALSE})\n+    @IR(failOn = {IRNode.MUL_L, IRNode.STORE_L, IRNode.LSHIFT}, counts = {IRNode.STORE_I, \"1\"})\n+    public static void testLongMaxValueOverflowOnce(boolean flag, boolean flag2) {\n+        long l = flag2 ? Long.MAX_VALUE\/2 - 1 : Long.MAX_VALUE\/2;\n+        int x = flag ? 4 : 6;\n+\n+        if (l * x >= -8L) {\n+            iFld = 23;\n+        } else {\n+            lFld = 34;\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(0)\n+    @Arguments({Argument.TRUE, Argument.FALSE})\n+    @IR(counts = {IRNode.STORE_I, \"1\", IRNode.STORE_L, \"1\", IRNode.MUL_L, \"1\"})\n+    public static void testLongMaxValueOverflowOnceTwice(boolean flag, boolean flag2) {\n+        long l = flag2 ? Long.MAX_VALUE\/2 - 1 : Long.MAX_VALUE\/2;\n+        int x = flag ? 6 : 8;\n+\n+        if (l * x >= -8L) {\n+            iFld = 23;\n+        } else {\n+            lFld = 34;\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(0)\n+    @Arguments({Argument.TRUE, Argument.FALSE})\n+    @IR(failOn = {IRNode.MUL_L, IRNode.STORE_L, IRNode.LSHIFT}, counts = {IRNode.STORE_I, \"1\"})\n+    public static void testLongMaxValueOverflowTwice(boolean flag, boolean flag2) {\n+        long l = flag2 ? Long.MAX_VALUE\/2 - 1 : Long.MAX_VALUE\/2;\n+        int x = flag ? 8 : 10;\n+\n+        if (l * x >= -16L) {\n+            iFld = 23;\n+        } else {\n+            lFld = 34;\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(0)\n+    @Arguments({Argument.TRUE, Argument.FALSE})\n+    @IR(failOn = IRNode.MUL_L, counts = {IRNode.STORE_L, \"1\"})\n+    public static void testLongProductsOverflowOnceAtMin(boolean flag, boolean flag2) {\n+        long l = flag ? Long.MAX_VALUE\/2 + 1 : Long.MAX_VALUE\/2 + 2;\n+        int x = flag2 ? 2 : 3;\n+\n+        \/\/ [MAX_VALUE\/2 + 1, MAX_VALUE\/2 + 2] * [2,3]: All cross products overflow exactly once.\n+        \/\/ Result: [MIN_VALUE, MIN_VALUE\/2 + 3] -> 2L outside range and If can be optimized away.\n+        if (l * x != 2L) {\n+            lFld = 23;\n+        } else {\n+            lFld = 34;\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(0)\n+    @Arguments({Argument.TRUE, Argument.FALSE})\n+    @IR(failOn = IRNode.MUL_L, counts = {IRNode.STORE_L, \"1\"})\n+    public static void testLongProductsOverflowOnceAtMax(boolean flag, boolean flag2) {\n+        \/\/ 88971434439113593 * 311 = Long.MAX_VALUE*3 + 2 --cast to long--> Long.MAX_VALUE\n+        long l = flag ? 88971434439113592L : 88971434439113593L;\n+        int x = flag2 ? 310 : 311;\n+\n+        \/\/ All cross products overflow exactly once.\n+        \/\/ Result: [y, MAX_VALUE], where y > 2 -> 2L outside range and If can be optimized away.\n+        if (l * x != 2L) {\n+            lFld = 23;\n+        } else {\n+            lFld = 34;\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(0)\n+    @Arguments({Argument.TRUE, Argument.FALSE})\n+    @IR(failOn = IRNode.MUL_L, counts = {IRNode.STORE_L, \"1\"})\n+    public static void testLongProductsUnderflowOnceAtMin(boolean flag, boolean flag2) {\n+        long l = flag ? Long.MIN_VALUE\/3 - 1 : Long.MIN_VALUE\/3 - 2;\n+        int x = flag2 ? 3 : 4;\n+\n+        \/\/ [MIN_VALUE\/3 - 1, MIN_VALUE\/3 - 2] * [3,4]: All cross products underflow exactly once.\n+        \/\/ Result: [MAX_VALUE + MIN_VALUE\/3 - 5, MAX_VALUE] -> 2L outside range and If can be optimized away.\n+        if (l * x != 2L) {\n+            lFld = 23;\n+        } else {\n+            lFld = 34;\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(0)\n+    @Arguments({Argument.TRUE, Argument.FALSE})\n+    @IR(failOn = IRNode.MUL_L, counts = {IRNode.STORE_L, \"1\"})\n+    public static void testLongProductsUnderflowOnceAtMax(boolean flag, boolean flag2) {\n+        \/\/ -6917529027641081856 * 4 = Long.MIN_VALUE*3 --cast to long--> Long.MIN_VALUE\n+        long l = flag ? -6917529027641081856L : -6917529027641081855L;\n+        int x = flag2 ? 3 : 4;\n+\n+        \/\/ All cross products underflow exactly once.\n+        \/\/ Result: [MIN_VALUE, y], where y < 2 -> 2L outside range and If can be optimized away.\n+        if (l * x != 2L) {\n+            lFld = 23;\n+        } else {\n+            lFld = 34;\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(0)\n+    @Arguments({Argument.TRUE, Argument.FALSE})\n+    @IR(counts = {IRNode.STORE_L, \"2\", IRNode.MUL_L, \"1\"})\n+    public static void testLongProductsDifferentNumberOfOverflow(boolean flag, boolean flag2) {\n+        \/\/ 88971434439113593 * 311 = Long.MAX_VALUE*3 + 2 --cast to long--> Long.MAX_VALUE \/\/ Overflown once\n+        \/\/ 88971434439113594 * 311 = (Long.MAX_VALUE*3 + 311) + 2 --cast to long--> Long.MIN_VALUE + 310 \/\/ Overflown twice\n+        long l = flag ? 88971434439113593L : 88971434439113594L;\n+        int x = flag2 ? 310 : 311;\n+\n+        \/\/ Different number of overflows -> cannot optimize If away\n+        if (l * x != 2L) {\n+            lFld = 23;\n+        } else {\n+            lFld = 34;\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(0)\n+    @Arguments({Argument.TRUE, Argument.FALSE})\n+    @IR(counts = {IRNode.STORE_L, \"2\", IRNode.MUL_L, \"1\"})\n+    public static void testLongProductsDifferentNumberOfUnderflows(boolean flag, boolean flag2) {\n+        \/\/ -6917529027641081856 * 4 = Long.MIN_VALUE*3 --cast to long--> Long.MIN_VALUE \/\/ Underflown once\n+        \/\/ -6917529027641081857 * 4 = (Long.MIN_VALUE*3 - 4) --cast to long--> Long.MAX_VALUE - 3 \/\/ Underflown twice\n+        long l = flag ? -6917529027641081856L : -6917529027641081857L;\n+        int x = flag2 ? 3 : 4;\n+\n+        \/\/ Different number of underflows -> cannot optimize If away\n+        if (l * x != 2L) {\n+            lFld = 23;\n+        } else {\n+            lFld = 34;\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(0)\n+    @Arguments({Argument.TRUE, Argument.FALSE})\n+    @IR(counts = {IRNode.STORE_L, \"2\", IRNode.MUL_L, \"1\"})\n+    public static void testLongNotSameOverflow1(boolean flag, boolean flag2) {\n+        long l = flag ? 1 : Long.MAX_VALUE;\n+        int x = flag2 ? -1 : 2;\n+\n+        if (l * x != 2L) {\n+            lFld = 23;\n+        } else {\n+            lFld = 34;\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(0)\n+    @Arguments({Argument.TRUE, Argument.FALSE})\n+    @IR(counts = {IRNode.STORE_L, \"2\", IRNode.MUL_L, \"1\"})\n+    public static void testLongNotSameOverflow2(boolean flag, boolean flag2) {\n+        long l = flag ? 1 : Long.MIN_VALUE;\n+        int x = flag2 ? -1 : 2;\n+\n+        if (l * x != 2L) {\n+            lFld = 23;\n+        } else {\n+            lFld = 34;\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(0)\n+    @Arguments({Argument.TRUE, Argument.FALSE})\n+    @IR(counts = {IRNode.STORE_L, \"2\", IRNode.MUL_L, \"1\"})\n+    public static void testLongNotSameOverflow3(boolean flag, boolean flag2) {\n+        long l = flag ? -1 : Long.MIN_VALUE;\n+        long x = flag2 ? Long.MIN_VALUE : -1;\n+\n+        if (l * x != 2L) {\n+            lFld = 23;\n+        } else {\n+            lFld = 34;\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(0)\n+    @Arguments({Argument.TRUE, Argument.FALSE})\n+    @IR(counts = {IRNode.STORE_L, \"2\", IRNode.MUL_L, \"1\"})\n+    public static void testLongNotSameOverflow4(boolean flag, boolean flag2) {\n+        long l = flag ? -1 : Long.MAX_VALUE;\n+        long x = flag2 ? Long.MAX_VALUE : -1;\n+\n+        if (l * x != 2L) {\n+            lFld = 23;\n+        } else {\n+            lFld = 34;\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(0)\n+    @Arguments({Argument.TRUE, Argument.FALSE})\n+    @IR(counts = {IRNode.STORE_L, \"2\", IRNode.MUL_L, \"1\"})\n+    public static void testLongNotSameOverflow5(boolean flag, boolean flag2) {\n+        long l = flag ? Long.MIN_VALUE : Long.MAX_VALUE;\n+        long x = flag2 ? Long.MAX_VALUE : -1;\n+\n+        if (l * x != 2L) {\n+            lFld = 23;\n+        } else {\n+            lFld = 34;\n+        }\n+    }\n+\n+    \/\/ Int cases\n+    @Test\n+    @IR(failOn = IRNode.IF, counts = {IRNode.STORE_I, \"1\", IRNode.STORE_L, \"1\"})\n+    public static void testIntPositive() {\n+        int i = 26000000;\n+        if (i * 81 == 1) {\n+            iFld = 23;\n+        }\n+        if (i * 81 == 2106000000) {\n+            iFld = 34;\n+        }\n+\n+        if (i * 83 == 1) {\n+            lFld = 23;\n+        }\n+        if (i * 83 == -2136967296) {\n+            lFld = 34;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.IF, counts = {IRNode.STORE_I, \"1\", IRNode.STORE_L, \"1\"})\n+    public static void testIntPositive2() {\n+        int i = -26000000;\n+        if (i * -81 == 1) {\n+            iFld = 23;\n+        }\n+        if (i * -81 == 2106000000) {\n+            iFld = 34;\n+        }\n+\n+        if (i * -83 == 1) {\n+            lFld = 23;\n+        }\n+        if (i * -83 == -2136967296) {\n+            lFld = 34;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.IF, counts = {IRNode.STORE_I, \"1\", IRNode.STORE_L, \"1\"})\n+    public static void testIntNegative() {\n+        int i = 26000000;\n+        if (i * -81 == 1) {\n+            iFld = 23;\n+        }\n+        if (i * -81 == -2106000000) {\n+            iFld = 34;\n+        }\n+\n+        if (i * -83 == 1) {\n+            lFld = 23;\n+        }\n+        if (i * -83 == 2136967296) {\n+            lFld = 34;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.IF, counts = {IRNode.STORE_I, \"1\", IRNode.STORE_L, \"1\"})\n+    public static void testIntNegative2() {\n+        int i = -26000000;\n+        if (i * 81 == 1) {\n+            iFld = 23;\n+        }\n+        if (i * 81 == -2106000000) {\n+            iFld = 34;\n+        }\n+\n+        if (i * 83 == 1) {\n+            lFld = 23;\n+        }\n+        if (i * 83 == 2136967296) {\n+            lFld = 34;\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(0)\n+    @Arguments({Argument.TRUE, Argument.FALSE})\n+    @IR(counts = {IRNode.STORE_L, \"2\", IRNode.MUL_I, \"1\"})\n+    public static void testIntMinValueMinus1(boolean flag, boolean flag2) {\n+        int l = flag ? -1 : Integer.MIN_VALUE;\n+        int x = flag2 ? -1 : 0;\n+\n+        if (l * x != 2) { \/\/ Type of multiplication is INT as Integer.MIN_VALUE * -1 does overflow. If cannot be removed.\n+            lFld = 23;\n+        } else {\n+            lFld = 34; \/\/ Emits StoreL since warmup is 0 and no UCT will be emitted.\n+        }\n+    }\n+\n+\n+    @Test\n+    @Warmup(0)\n+    @Arguments({Argument.TRUE, Argument.FALSE})\n+    @IR(failOn = {IRNode.MUL_I, IRNode.STORE_L}, counts = {IRNode.STORE_I, \"1\"})\n+    public static void testIntMinValuePlus1(boolean flag, boolean flag2) {\n+        int l = flag ? -1 : Integer.MIN_VALUE;\n+        int x = flag2 ? 1 : 0;\n+\n+        if (l * x <= 0) {\n+            iFld = 23;\n+        } else {\n+            lFld = 34;\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(0)\n+    @Arguments({Argument.TRUE, Argument.FALSE})\n+    @IR(failOn = {IRNode.MUL_I, IRNode.STORE_L, IRNode.LSHIFT}, counts = {IRNode.STORE_I, \"1\"})\n+    public static void testIntMinValueUnderflowOnce(boolean flag, boolean flag2) {\n+        int l = flag ? Integer.MIN_VALUE\/2 : Integer.MIN_VALUE\/2 + 1;\n+        int x = flag2 ? 4 : 6;\n+\n+        if (l * x <= 4) {\n+            iFld = 23;\n+        } else {\n+            lFld = 34;\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(0)\n+    @Arguments({Argument.TRUE, Argument.FALSE})\n+    @IR(counts = {IRNode.STORE_I, \"1\", IRNode.STORE_L, \"1\", IRNode.MUL_I, \"1\"})\n+    public static void testIntMinValueUnderflowOnceTwice(boolean flag, boolean flag2) {\n+        int l = flag ? Integer.MIN_VALUE\/2 : Integer.MIN_VALUE\/2 + 1;\n+        int x = flag2 ? 6 : 8;\n+\n+        if (l * x <= 4) {\n+            iFld = 23;\n+        } else {\n+            lFld = 34;\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(0)\n+    @Arguments({Argument.TRUE, Argument.FALSE})\n+    @IR(failOn = {IRNode.MUL_I, IRNode.STORE_L, IRNode.LSHIFT}, counts = {IRNode.STORE_I, \"1\"})\n+    public static void testIntMinValueUnderflowTwice(boolean flag, boolean flag2) {\n+        int l = flag ? Integer.MIN_VALUE\/2 : Integer.MIN_VALUE\/2 + 1;\n+        int x = flag2 ? 8 : 10;\n+\n+        if (l * x <= 8) {\n+            iFld = 23;\n+        } else {\n+            lFld = 34;\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(0)\n+    @Arguments({Argument.TRUE, Argument.FALSE})\n+    @IR(failOn = {IRNode.MUL_I, IRNode.STORE_L, IRNode.LSHIFT}, counts = {IRNode.STORE_I, \"1\"})\n+    public static void testIntMaxValueOverflowOnce(boolean flag, boolean flag2) {\n+        int l = flag2 ? Integer.MAX_VALUE\/2 - 1 : Integer.MAX_VALUE\/2;\n+        int x = flag ? 4 : 6;\n+\n+        if (l * x >= -8) {\n+            iFld = 23;\n+        } else {\n+            lFld = 34;\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(0)\n+    @Arguments({Argument.TRUE, Argument.FALSE})\n+    @IR(counts = {IRNode.STORE_I, \"1\", IRNode.STORE_L, \"1\", IRNode.MUL_I, \"1\"})\n+    public static void testIntMaxValueOverflowOnceTwice(boolean flag, boolean flag2) {\n+        int l = flag2 ? Integer.MAX_VALUE\/2 - 1 : Integer.MAX_VALUE\/2;\n+        int x = flag ? 6 : 8;\n+\n+        if (l * x >= -8) {\n+            iFld = 23;\n+        } else {\n+            lFld = 34;\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(0)\n+    @Arguments({Argument.TRUE, Argument.FALSE})\n+    @IR(failOn = {IRNode.MUL_I, IRNode.STORE_L, IRNode.LSHIFT}, counts = {IRNode.STORE_I, \"1\"})\n+    public static void testIntMaxValueOverflowTwice(boolean flag, boolean flag2) {\n+        int l = flag2 ? Integer.MAX_VALUE\/2 - 1 : Integer.MAX_VALUE\/2;\n+        int x = flag ? 8 : 10;\n+\n+        if (l * x >= -16L) {\n+            iFld = 23;\n+        } else {\n+            lFld = 34;\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(0)\n+    @Arguments({Argument.TRUE, Argument.FALSE})\n+    @IR(failOn = IRNode.MUL_I, counts = {IRNode.STORE_L, \"1\"})\n+    public static void testIntProductsOverflowOnceAtMin(boolean flag, boolean flag2) {\n+        int l = flag ? Integer.MAX_VALUE\/2 + 1 : Integer.MAX_VALUE\/2 + 2;\n+        int x = flag2 ? 2 : 3;\n+\n+        \/\/ [MAX_VALUE\/2 + 1, MAX_VALUE\/2 + 2] * [2,3]: All cross products overflow exactly once.\n+        \/\/ Result: [MIN_VALUE, MIN_VALUE\/2 + 3] -> 2 outside range and If can be optimized away.\n+        if (l * x != 2) {\n+            lFld = 23;\n+        } else {\n+            lFld = 34;\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(0)\n+    @Arguments({Argument.TRUE, Argument.FALSE})\n+    @IR(failOn = IRNode.MUL_I, counts = {IRNode.STORE_L, \"1\"})\n+    public static void testIntProductsOverflowOnceAtMax(boolean flag, boolean flag2) {\n+        \/\/ 63786643 * 101 = Integer.MAX_VALUE*3 + 2 --cast to int--> Integer.MAX_VALUE\n+        int l = flag ? 63786642 : 63786643;\n+        int x = flag2 ? 100 : 101;\n+\n+        \/\/ All cross products overflow exactly once.\n+        \/\/ Result: [y, MAX_VALUE], where y > 2 -> 2 outside range and If can be optimized away.\n+        if (l * x != 2) {\n+            lFld = 23;\n+        } else {\n+            lFld = 34;\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(0)\n+    @Arguments({Argument.TRUE, Argument.FALSE})\n+    @IR(failOn = IRNode.MUL_I, counts = {IRNode.STORE_L, \"1\"})\n+    public static void testIntProductsUnderflowOnceAtMin(boolean flag, boolean flag2) {\n+        int l = flag ? Integer.MIN_VALUE\/3 - 1 : Integer.MIN_VALUE\/3 - 2;\n+        int x = flag2 ? 3 : 4;\n+\n+        \/\/ [MIN_VALUE\/3 - 1, MIN_VALUE\/3 - 2] * [3,4]: All cross products underflow exactly once.\n+        \/\/ Result: [MAX_VALUE + MIN_VALUE\/3 - 5, MAX_VALUE] -> 2 outside range and If can be optimized away.\n+        if (l * x != 2) {\n+            lFld = 23;\n+        } else {\n+            lFld = 34;\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(0)\n+    @Arguments({Argument.TRUE, Argument.FALSE})\n+    @IR(failOn = IRNode.MUL_I, counts = {IRNode.STORE_L, \"1\"})\n+    public static void testIntProductsUnderflowOnceAtMax(boolean flag, boolean flag2) {\n+        \/\/ -1610612736 * 4 = Integer.MIN_VALUE*3 --cast to int--> Integer.MIN_VALUE\n+        int l = flag ? -1610612736 : -1610612735;\n+        int x = flag2 ? 3 : 4;\n+\n+        \/\/ All cross products underflow exactly once.\n+        \/\/ Result: [MIN_VALUE, y], where y < 2 -> 2 outside range and If can be optimized away.\n+        if (l * x != 2) {\n+            lFld = 23;\n+        } else {\n+            lFld = 34;\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(0)\n+    @Arguments({Argument.TRUE, Argument.FALSE})\n+    @IR(counts = {IRNode.STORE_L, \"2\", IRNode.MUL_I, \"1\"})\n+    public static void testIntProductsDifferentNumberOfOverflow(boolean flag, boolean flag2) {\n+        \/\/ 63786643 * 101 = Integer.MAX_VALUE*3 + 2 --cast to int--> Integer.MAX_VALUE \/\/ Overflown once\n+        \/\/ 63786644 * 101 = (Integer.MAX_VALUE*3 + 101) + 2 --cast to int--> Integer.MIN_VALUE + 100 \/\/ Overflown twice\n+        int l = flag ? 63786643 : 63786644;\n+        int x = flag2 ? 100 : 101;\n+\n+        \/\/ Different number of overflows -> cannot optimize If away\n+        if (l * x != 2) {\n+            lFld = 23;\n+        } else {\n+            lFld = 34;\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(0)\n+    @Arguments({Argument.TRUE, Argument.FALSE})\n+    @IR(counts = {IRNode.STORE_L, \"2\", IRNode.MUL_I, \"1\"})\n+    public static void testIntProductsDifferentNumberOfUnderflows(boolean flag, boolean flag2) {\n+        \/\/ -1610612736 * 4 = Integer.MIN_VALUE*3 --cast to int--> Integer.MIN_VALUE \/\/ Underflown once\n+        \/\/ -1610612737 * 4 = (Integer.MIN_VALUE*3 - 4) --cast to int--> Integer.MAX_VALUE - 3 \/\/ Underflown twice\n+        int l = flag ? -1610612736 : -1610612737;\n+        int x = flag2 ? 3 : 4;\n+\n+        \/\/ Different number of underflows -> cannot optimize If away\n+        if (l * x != 2) {\n+            lFld = 23;\n+        } else {\n+            lFld = 34;\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(0)\n+    @Arguments({Argument.TRUE, Argument.FALSE})\n+    @IR(counts = {IRNode.STORE_L, \"2\", IRNode.MUL_I, \"1\"})\n+    public static void testIntNotSameOverflow1(boolean flag, boolean flag2) {\n+        int l = flag ? 1 : Integer.MAX_VALUE;\n+        int x = flag2 ? -1 : 2;\n+\n+        if (l * x != 2) {\n+            lFld = 23;\n+        } else {\n+            lFld = 34;\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(0)\n+    @Arguments({Argument.TRUE, Argument.FALSE})\n+    @IR(counts = {IRNode.STORE_L, \"2\", IRNode.MUL_I, \"1\"})\n+    public static void testIntNotSameOverflow2(boolean flag, boolean flag2) {\n+        int l = flag ? 1 : Integer.MIN_VALUE;\n+        int x = flag2 ? -1 : 2;\n+\n+        if (l * x != 2) {\n+            lFld = 23;\n+        } else {\n+            lFld = 34;\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(0)\n+    @Arguments({Argument.TRUE, Argument.FALSE})\n+    @IR(counts = {IRNode.STORE_L, \"2\", IRNode.MUL_I, \"1\"})\n+    public static void testIntNotSameOverflow3(boolean flag, boolean flag2) {\n+        int l = flag ? -1 : Integer.MIN_VALUE;\n+        int x = flag2 ? Integer.MIN_VALUE : -1;\n+\n+        if (l * x != 2) {\n+            lFld = 23;\n+        } else {\n+            lFld = 34;\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(0)\n+    @Arguments({Argument.TRUE, Argument.FALSE})\n+    @IR(counts = {IRNode.STORE_L, \"2\", IRNode.MUL_I, \"1\"})\n+    public static void testIntNotSameOverflow4(boolean flag, boolean flag2) {\n+        int l = flag ? -1 : Integer.MAX_VALUE;\n+        int x = flag2 ? Integer.MAX_VALUE : -1;\n+\n+        if (l * x != 2) {\n+            lFld = 23;\n+        } else {\n+            lFld = 34;\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(0)\n+    @Arguments({Argument.TRUE, Argument.FALSE})\n+    @IR(counts = {IRNode.STORE_L, \"2\", IRNode.MUL_I, \"1\"})\n+    public static void testIntNotSameOverflow5(boolean flag, boolean flag2) {\n+        int l = flag ? Integer.MIN_VALUE : Integer.MAX_VALUE;\n+        int x = flag2 ? Integer.MAX_VALUE : -1;\n+\n+        if (l * x != 2) {\n+            lFld = 23;\n+        } else {\n+            lFld = 34;\n+        }\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/igvn\/TestIntegerMulRing.java","additions":668,"deletions":3,"binary":false,"changes":671,"status":"modified"}]}