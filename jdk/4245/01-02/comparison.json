{"files":[{"patch":"@@ -0,0 +1,172 @@\n+\/*\n+ * Copyright (c) 2013, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Expose annotations made RUNTIME visible via Class.getAnnotation when -XX:+PreserveAllAnnotations is on\n+ * @run main\/othervm -XX:+PreserveAllAnnotations AnnotationTypeChangedToRuntimeTest\n+ *\/\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+\n+import static java.lang.annotation.RetentionPolicy.CLASS;\n+import static java.lang.annotation.RetentionPolicy.RUNTIME;\n+\n+\/**\n+ * This test simulates a situation where an existing annotation with\n+ * {@link RetentionPolicy#CLASS CLASS} retention was changed into\n+ * {@link RetentionPolicy#RUNTIME RUNTIME} and we want to read\n+ * its value during runtime with the help of \n+ * -XX:+PreserveAllAnnotations option\n+ *\/\n+public class AnnotationTypeChangedToRuntimeTest {\n+\n+    @Retention(CLASS)\n+    @AnnB\n+    public @interface AnnA_v1 {\n+    }\n+\n+    \/\/ An alternative version of AnnA_v1 with CLASS retention instead.\n+    \/\/ Used to simulate separate compilation (see AltClassLoader below).\n+    @Retention(RUNTIME)\n+    @AnnB\n+    public @interface AnnA_v2 {\n+    }\n+\n+    @Retention(RUNTIME)\n+    @AnnA_v1\n+    public @interface AnnB {\n+    }\n+\n+    @AnnA_v1\n+    public static class TestTask implements Runnable {\n+        @Override\n+        public void run() {\n+            AnnA_v1 ann1 = TestTask.class.getDeclaredAnnotation(AnnA_v1.class);\n+            if (ann1 == null) {\n+                throw new IllegalStateException(\n+                    \"@\" + AnnA_v1.class.getSimpleName() +\n+                    \" should be visible at runtime\");\n+            }\n+            AnnA_v1 ann2 = AnnB.class.getDeclaredAnnotation(AnnA_v1.class);\n+            if (ann2 != null) {\n+                throw new IllegalStateException(\n+                    \"@\" + ann2.annotationType().getSimpleName() +\n+                    \" found on: \" + AnnB.class.getName() +\n+                    \" should not be visible at runtime\");\n+            }\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        ClassLoader altLoader = new AltClassLoader(\n+            AnnotationTypeChangedToRuntimeTest.class.getClassLoader());\n+\n+        Runnable altTask = (Runnable) Class.forName(\n+            TestTask.class.getName(),\n+            true,\n+            altLoader).newInstance();\n+\n+        altTask.run();\n+    }\n+\n+    \/**\n+     * A ClassLoader implementation that loads alternative implementations of\n+     * classes. If class name ends with \"_v1\" it locates instead a class with\n+     * name ending with \"_v2\" and loads that class instead.\n+     *\/\n+    static class AltClassLoader extends ClassLoader {\n+        AltClassLoader(ClassLoader parent) {\n+            super(parent);\n+        }\n+\n+        @Override\n+        protected Class<?> loadClass(String name, boolean resolve)\n+                throws ClassNotFoundException {\n+            if (name.indexOf('.') < 0) { \/\/ root package is our class\n+                synchronized (getClassLoadingLock(name)) {\n+                    \/\/ First, check if the class has already been loaded\n+                    Class<?> c = findLoadedClass(name);\n+                    if (c == null) {\n+                        c = findClass(name);\n+                    }\n+                    if (resolve) {\n+                        resolveClass(c);\n+                    }\n+                    return c;\n+                }\n+            }\n+            else { \/\/ not our class\n+                return super.loadClass(name, resolve);\n+            }\n+        }\n+\n+        @Override\n+        protected Class<?> findClass(String name)\n+                throws ClassNotFoundException {\n+            \/\/ special class name -> replace it with alternative name\n+            if (name.endsWith(\"_v1\")) {\n+                String altName = name.substring(0, name.length() - 3) + \"_v2\";\n+                String altPath = altName.replace('.', '\/').concat(\".class\");\n+                try (InputStream is = getResourceAsStream(altPath)) {\n+                    if (is != null) {\n+                        byte[] bytes = is.readAllBytes();\n+                        \/\/ patch class bytes to contain original name\n+                        for (int i = 0; i < bytes.length - 2; i++) {\n+                            if (bytes[i] == '_' &&\n+                                bytes[i + 1] == 'v' &&\n+                                bytes[i + 2] == '2') {\n+                                bytes[i + 2] = '1';\n+                            }\n+                        }\n+                        return defineClass(name, bytes, 0, bytes.length);\n+                    }\n+                    else {\n+                        throw new ClassNotFoundException(name);\n+                    }\n+                }\n+                catch (IOException e) {\n+                    throw new ClassNotFoundException(name, e);\n+                }\n+            }\n+            else { \/\/ not special class name -> just load the class\n+                String path = name.replace('.', '\/').concat(\".class\");\n+                try (InputStream is = getResourceAsStream(path)) {\n+                    if (is != null) {\n+                        byte[] bytes = is.readAllBytes();\n+                        return defineClass(name, bytes, 0, bytes.length);\n+                    }\n+                    else {\n+                        throw new ClassNotFoundException(name);\n+                    }\n+                }\n+                catch (IOException e) {\n+                    throw new ClassNotFoundException(name, e);\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/annotation\/AnnotationType\/AnnotationTypeChangedToRuntimeTest.java","additions":172,"deletions":0,"binary":false,"changes":172,"status":"added"}]}