{"files":[{"patch":"@@ -256,0 +256,22 @@\n+class ZHeapParallelObjectIterator : public ParallelObjectIterator {\n+private:\n+  uint    _thread_num;\n+  ZHeap*  _heap;\n+  ZHeapIterator _iter;\n+public:\n+  ZHeapParallelObjectIterator(uint thread_num, ZHeap* heap) :\n+      _thread_num(thread_num), _heap(heap), _iter(_thread_num) {\n+    \/\/ prepare work queue, enqueue all roots serially.\n+    _heap->process_roots_for_par_iterate(&_iter, true \/* visit_weaks *\/);\n+  }\n+\n+  virtual void object_iterate(ObjectClosure* cl, uint worker_id) {\n+    \/\/ process references from roots.\n+    _heap->par_references_iterate(cl, &_iter, worker_id, true \/* visit_weaks*\/);\n+  }\n+};\n+\n+ParallelObjectIterator* ZCollectedHeap::parallel_object_iterator(uint thread_num) {\n+  return new ZHeapParallelObjectIterator(thread_num, &_heap);\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zCollectedHeap.cpp","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+class ZHeapParallelObjectIterator;\n@@ -100,0 +101,1 @@\n+  virtual ParallelObjectIterator* parallel_object_iterator(uint thread_num);\n","filename":"src\/hotspot\/share\/gc\/z\/zCollectedHeap.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-#include \"gc\/z\/zHeapIterator.hpp\"\n@@ -444,0 +443,11 @@\n+void ZHeap::process_roots_for_par_iterate(ZHeapIterator* iter, bool visit_weaks) {\n+  iter->enqueue_roots(visit_weaks);\n+}\n+\n+void ZHeap::par_references_iterate(ObjectClosure* cl,\n+                                   ZHeapIterator* iter,\n+                                   uint worker_id,\n+                                   bool visit_weaks) {\n+  iter->drain_queue(cl, visit_weaks, worker_id);\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zHeap.cpp","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"gc\/z\/zHeapIterator.hpp\"\n@@ -144,0 +145,3 @@\n+  void process_roots_for_par_iterate(ZHeapIterator* iter, bool visit_weaks);\n+  void par_references_iterate(ObjectClosure* cl, ZHeapIterator* iter,\n+                              uint worker_id, bool visit_weaks);\n","filename":"src\/hotspot\/share\/gc\/z\/zHeap.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -55,0 +55,4 @@\n+\n+  inline bool par_try_set_bit(size_t index) {\n+    return _map.par_set_bit(index);\n+  }\n@@ -88,1 +92,1 @@\n-template <bool VisitReferents>\n+template <bool VisitReferents, bool ParallelIter>\n@@ -93,0 +97,1 @@\n+  ZHeapIterTaskQueue*     _queue;\n@@ -103,1 +108,1 @@\n-  ZHeapIteratorOopClosure(ZHeapIterator* iter, oop base) :\n+  ZHeapIteratorOopClosure(ZHeapIterator* iter, oop base, ZHeapIterTaskQueue* q = NULL) :\n@@ -106,1 +111,2 @@\n-      _base(base) {}\n+      _base(base),\n+      _queue(q) {}\n@@ -114,1 +120,5 @@\n-    _iter->push(obj);\n+    if (ParallelIter == false) {\n+      _iter->push(obj);\n+    } else {\n+      _iter->par_enqueue(obj, _queue);\n+    }\n@@ -128,1 +138,1 @@\n-ZHeapIterator::ZHeapIterator() :\n+ZHeapIterator::ZHeapIterator(uint num_workers) :\n@@ -130,1 +140,14 @@\n-    _visit_map(ZAddressOffsetMax) {}\n+    _visit_map(ZAddressOffsetMax),\n+    _num_workers(num_workers),\n+    _map_lock(),\n+    _task_queues(NULL) {\n+  if (_num_workers > 1) {\n+    \/\/ prepare process queue.\n+    _task_queues = new ZHeapIterTaskQueueSet((int) _num_workers);\n+    for (uint i = 0; i < _num_workers; i++) {\n+      ZHeapIterTaskQueue* q = new ZHeapIterTaskQueue();\n+      q->initialize();\n+      _task_queues->register_queue(i, q);\n+    }\n+  }\n+}\n@@ -137,0 +160,12 @@\n+  \/\/ reclaim task queues\n+  if (_task_queues != NULL) {\n+    for (uint i = 0; i < _num_workers; i++) {\n+      ZHeapIterTaskQueue* q = _task_queues->queue(i);\n+      if (q != NULL) {\n+        delete q;\n+        q = NULL;\n+      }\n+    }\n+    delete _task_queues;\n+    _task_queues = NULL;\n+  }\n@@ -155,2 +190,11 @@\n-    map = new ZHeapIteratorBitMap(object_index_max());\n-    _visit_map.put(offset, map);\n+    if (_num_workers > 1) {\n+      \/\/ Parallel iterate, holding lock to update _visit_map\n+      ZLocker<ZLock> locker(&_map_lock);\n+      if (map == NULL) {\n+        map = new ZHeapIteratorBitMap(object_index_max());\n+        _visit_map.put(offset, map);\n+      }\n+    } else {\n+      map = new ZHeapIteratorBitMap(object_index_max());\n+      _visit_map.put(offset, map);\n+    }\n@@ -158,1 +202,0 @@\n-\n@@ -162,0 +205,1 @@\n+\/\/ push objects in to _visit_stack, used by RootOopClosure.\n@@ -186,3 +230,3 @@\n-template <bool VisitReferents>\n-void ZHeapIterator::push_fields(oop obj) {\n-  ZHeapIteratorOopClosure<VisitReferents> cl(this, obj);\n+template <bool VisitReferents, bool ParallelIter>\n+void ZHeapIterator::push_fields(oop obj, ZHeapIterTaskQueue* queue) {\n+  ZHeapIteratorOopClosure<VisitReferents, ParallelIter> cl(this, obj, queue);\n@@ -216,0 +260,1 @@\n+\/\/ Used only in serial iteration\n@@ -223,0 +268,54 @@\n+\n+\/\/ Parallel iteration support\n+void ZHeapIterator::enqueue_roots(bool visit_weaks) {\n+  ZStatTimerDisable disable;\n+  \/\/ Push roots to visit\n+  push_roots<ZRootsIterator,                     false \/* Concurrent *\/, false \/* Weak *\/>();\n+  push_roots<ZConcurrentRootsIteratorClaimOther, true  \/* Concurrent *\/, false \/* Weak *\/>();\n+  if (visit_weaks) {\n+    push_roots<ZWeakRootsIterator,           false \/* Concurrent *\/, true  \/* Weak *\/>();\n+    push_roots<ZConcurrentWeakRootsIterator, true  \/* Concurrent *\/, true  \/* Weak *\/>();\n+  }\n+  \/\/ Divide roots into thread queue.\n+  size_t roots_num = _visit_stack.size();\n+  for (uint i = 0; i < roots_num; i++) {\n+    uint worker_id = i % _num_workers;\n+    oop obj = _visit_stack.pop();\n+    _task_queues->queue(worker_id)->push(obj);\n+  }\n+}\n+\n+void ZHeapIterator::drain_queue(ObjectClosure* cl, bool visit_weaks, uint worker_id) {\n+  ZStatTimerDisable disable;\n+  ZHeapIterTaskQueue* q = _task_queues->queue(worker_id);\n+  assert(q != NULL, \"Heap iteration task queue must not NULL\");\n+  \/\/ Drain stack\n+  oop obj;\n+  while (q->pop_overflow(obj) || q->pop_local(obj) || _task_queues->steal(worker_id, obj)) {\n+    \/\/ Visit object\n+    cl->do_object(obj);\n+    \/\/ Push fields to visit\n+    if (visit_weaks = true) {\n+      push_fields<true, true \/* ParallelIter *\/>(obj, q);\n+    } else {\n+      push_fields<false, true \/* ParallelIter *\/>(obj, q);\n+    }\n+  }\n+}\n+\n+void ZHeapIterator::par_enqueue(oop obj, ZHeapIterTaskQueue* q) {\n+   if (obj == NULL) {\n+    \/\/ Ignore\n+    return;\n+  }\n+\n+  ZHeapIteratorBitMap* const map = object_map(obj);\n+  const size_t index = object_index(obj);\n+  if (!map->par_try_set_bit(index)) {\n+    \/\/ Already pushed\n+    return;\n+  }\n+\n+  \/\/ Push\n+  q->push(obj);\n+}\n","filename":"src\/hotspot\/share\/gc\/z\/zHeapIterator.cpp","additions":111,"deletions":12,"binary":false,"changes":123,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"gc\/shared\/taskqueue.inline.hpp\"\n@@ -28,0 +29,1 @@\n+#include \"gc\/z\/zLock.inline.hpp\"\n@@ -33,0 +35,3 @@\n+\/\/ Queue and QueueSet for parallel iteration\n+typedef OverflowTaskQueue<oop, mtGC>                     ZHeapIterTaskQueue;\n+typedef GenericTaskQueueSet<ZHeapIterTaskQueue, mtGC>    ZHeapIterTaskQueueSet;\n@@ -36,1 +41,1 @@\n-  template<bool VisitReferents> friend class ZHeapIteratorOopClosure;\n+  template<bool VisitReferents, bool ParallelIter> friend class ZHeapIteratorOopClosure;\n@@ -42,1 +47,2 @@\n-\n+  \/\/ For parallel iteration, _visit_stack only contains roots.\n+  \/\/ For serial iteration, _visit_stack contains all references reached.\n@@ -45,0 +51,4 @@\n+  \/\/ For parallel iteration\n+  uint            _num_workers;\n+  ZLock           _map_lock;\n+  ZHeapIterTaskQueueSet* _task_queues;\n@@ -50,1 +60,3 @@\n-  template <bool VisitReferents> void push_fields(oop obj);\n+  \/\/ push_fields is different for serial iterate and parallel iterate.\n+  template <bool VisitReferents, bool ParallelIter = false>\n+  void push_fields(oop obj, ZHeapIterTaskQueue* queue = NULL);\n@@ -54,1 +66,1 @@\n-  ZHeapIterator();\n+  ZHeapIterator(uint num_workers = 0);\n@@ -58,0 +70,4 @@\n+  \/\/ For parallel iteration\n+  void par_enqueue(oop obj, ZHeapIterTaskQueue* q);\n+  void enqueue_roots(bool visit_weaks);\n+  void drain_queue(ObjectClosure* cl, bool visit_weaks, uint worker_id);\n","filename":"src\/hotspot\/share\/gc\/z\/zHeapIterator.hpp","additions":20,"deletions":4,"binary":false,"changes":24,"status":"modified"}]}