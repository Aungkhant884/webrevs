{"files":[{"patch":"@@ -221,9 +221,5 @@\n-        protected void cancel(Subscription subscription) {\n-            try {\n-                super.cancel(subscription);\n-            } finally {\n-                \/\/ If the subscription is cancelled the\n-                \/\/ subscriber may or may not get completed.\n-                \/\/ Therefore we need to unregister it\n-                exchange.unregisterResponseSubscriber(this);\n-            }\n+        protected void onCancel() {\n+            \/\/ If the subscription is cancelled the\n+            \/\/ subscriber may or may not get completed.\n+            \/\/ Therefore we need to unregister it\n+            exchange.unregisterResponseSubscriber(this);\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Http1Exchange.java","additions":5,"deletions":9,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -641,1 +641,1 @@\n-        if (count == 0 && facade() == null) {\n+        if (count == 0 && facadeRef.refersTo(null)) {\n@@ -663,1 +663,1 @@\n-        if (count == 0 && facade() == null) {\n+        if (count == 0 && facadeRef.refersTo(null)) {\n@@ -685,1 +685,1 @@\n-        if (count == 0 && facade() == null) {\n+        if (count == 0 && facadeRef.refersTo(null)) {\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/HttpClientImpl.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1550,6 +1550,2 @@\n-        protected void cancel(Subscription subscription) {\n-            try {\n-                super.cancel(subscription);\n-            } finally {\n-                Stream.this.unregisterResponseSubscriber(this);\n-            }\n+        protected void onCancel() {\n+            Stream.this.unregisterResponseSubscriber(this);\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Stream.java","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -71,1 +71,1 @@\n-    class SubscriptionWrapper implements Subscription {\n+    private class SubscriptionWrapper implements Subscription {\n@@ -83,1 +83,6 @@\n-            HttpBodySubscriberWrapper.this.cancel(subscription);\n+            try {\n+                subscription.cancel();\n+                onCancel();\n+            } catch (Throwable t) {\n+                onError(t);\n+            }\n@@ -117,3 +122,7 @@\n-    protected void cancel(Subscription subscription) {\n-        subscription.cancel();\n-    }\n+    \/**\n+     * Called when the subscriber cancels its subscription.\n+     * @apiNote\n+     * This method may be used by subclasses to perform cleanup\n+     * actions after a subscription has been cancelled.\n+     *\/\n+    protected void onCancel() { }\n@@ -180,0 +189,1 @@\n+            SubscriptionWrapper subscription = this.subscription;\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/common\/HttpBodySubscriberWrapper.java","additions":15,"deletions":5,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -212,1 +212,0 @@\n-        \/\/Object[][] result = new Object[uris.length][];\n@@ -215,1 +214,0 @@\n-            \/\/if (!sameClient) continue;\n@@ -225,1 +223,1 @@\n-    private HttpClient makeNewClient(boolean shared) {\n+    private HttpClient makeNewClient() {\n@@ -232,1 +230,6 @@\n-        return shared ? client : TRACKER.track(client);\n+        \/\/ It is OK to even track the shared client here:\n+        \/\/ the test methods will verify that the client has shut down\n+        \/\/ only if it's not the shared client.\n+        \/\/ Only the teardown() method verify that the shared client\n+        \/\/ has shut down in this test.\n+        return TRACKER.track(client);\n@@ -236,1 +239,1 @@\n-        if (!share) return makeNewClient(share);\n+        if (!share) return makeNewClient();\n@@ -242,1 +245,1 @@\n-                shared = sharedClient = makeNewClient(share);\n+                shared = sharedClient = makeNewClient();\n@@ -261,0 +264,1 @@\n+            var tracker = TRACKER.getTracker(client);\n@@ -265,2 +269,1 @@\n-            Exception failed = null;\n-            List<String> lines = null;\n+            List<String> lines;\n@@ -273,1 +276,3 @@\n-                var error = TRACKER.check(500,\n+                \/\/ Only check our still alive client for outstanding operations\n+                \/\/ and outstanding subscribers here: it should have none.\n+                var error = TRACKER.check(tracker, 500,\n@@ -280,0 +285,2 @@\n+            \/\/ The shared client is only shut down at the end.\n+            \/\/ Skip shutdown check for the shared client.\n@@ -283,1 +290,1 @@\n-            var error = TRACKER.check(500);\n+            var error = TRACKER.check(tracker, 500);\n@@ -298,0 +305,1 @@\n+            var tracker = TRACKER.getTracker(client);\n@@ -310,1 +318,3 @@\n-                var error = TRACKER.check(1,\n+                \/\/ Only check our still alive client for outstanding operations\n+                \/\/ and outstanding subscribers here: it should have none.\n+                var error = TRACKER.check(tracker, 1,\n@@ -317,0 +327,2 @@\n+            \/\/ The shared client is only shut down at the end.\n+            \/\/ Skip shutdown check for the shared client.\n@@ -320,1 +332,1 @@\n-            var error = TRACKER.check(1);\n+            var error = TRACKER.check(tracker, 1);\n@@ -368,1 +380,0 @@\n-        TRACKER.track(sharedClient);\n@@ -370,0 +381,3 @@\n+        \/\/ check that the shared client (and any other client) have\n+        \/\/ properly shut down\n+        System.gc();\n@@ -402,1 +416,5 @@\n-                t.sendResponseHeaders(200, -1); \/\/ chunked\/variable\n+\n+                \/\/ we're not expecting a request body.\n+                \/\/ if we receive any, pretend we're a teapot.\n+                int status = req.length == 0 ? 200 : 418;\n+                t.sendResponseHeaders(status, -1); \/\/ chunked\/variable\n@@ -413,0 +431,1 @@\n+                        out.printf(\"Server wrote %d bytes%n\", req.length);\n@@ -418,1 +437,0 @@\n-                        out.printf(\"Server wrote %d bytes%n\", req.length);\n","filename":"test\/jdk\/java\/net\/httpclient\/CancelStreamedBodyTest.java","additions":33,"deletions":15,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import java.util.Objects;\n@@ -64,0 +65,5 @@\n+    public StringBuilder diagnose(Tracker tracker, StringBuilder warnings, Predicate<Tracker> hasOutstanding) {\n+        checkOutstandingOperations(warnings, tracker, hasOutstanding);\n+        return warnings;\n+    }\n+\n@@ -66,1 +72,1 @@\n-            checkOutstandingOperations(warnings, tracker, hasOutstanding);\n+            diagnose(tracker, warnings, hasOutstanding);\n@@ -93,0 +99,10 @@\n+    public AssertionError check(Tracker tracker, long graceDelayMs) {\n+        Predicate<Tracker> hasOperations = (t) -> t.getOutstandingOperations() > 0;\n+        Predicate<Tracker> hasSubscribers = (t) -> t.getOutstandingSubscribers() > 0;\n+        return check(tracker, graceDelayMs,\n+                hasOperations.or(hasSubscribers)\n+                        .or(Tracker::isFacadeReferenced)\n+                        .or(Tracker::isSelectorAlive),\n+                \"outstanding operations or unreleased resources\", false);\n+    }\n+\n@@ -94,1 +110,1 @@\n-        Predicate<Tracker> hasHttpOperations = (t) -> t.getOutstandingHttpOperations() > 0;\n+        Predicate<Tracker> hasOperations = (t) -> t.getOutstandingOperations() > 0;\n@@ -97,2 +113,4 @@\n-                hasHttpOperations.or(hasSubscribers),\n-                \"outstanding operations\", true);\n+                hasOperations.or(hasSubscribers)\n+                .or(Tracker::isFacadeReferenced)\n+                .or(Tracker::isSelectorAlive),\n+        \"outstanding operations or unreleased resources\", true);\n@@ -182,0 +200,43 @@\n+    public Tracker getTracker(HttpClient client) {\n+        return OperationTrackers.getTracker(Objects.requireNonNull(client));\n+    }\n+\n+    public AssertionError check(Tracker tracker,\n+                                long graceDelayMs,\n+                                Predicate<Tracker> hasOutstanding,\n+                                String description,\n+                                boolean printThreads) {\n+        AssertionError fail = null;\n+        graceDelayMs = Math.max(graceDelayMs, 100);\n+        long delay = Math.min(graceDelayMs, 10);\n+        var count = delay > 0 ? graceDelayMs \/ delay : 1;\n+        for (int i = 0; i < count; i++) {\n+            if (hasOutstanding.test(tracker)) {\n+                System.gc();\n+                try {\n+                    if (i == 0) {\n+                        System.out.println(\"Waiting for HTTP operations to terminate...\");\n+                    }\n+                    Thread.sleep(Math.min(graceDelayMs, Math.max(delay, 1)));\n+                } catch (InterruptedException x) {\n+                    \/\/ OK\n+                }\n+            } else break;\n+        }\n+        if (hasOutstanding.test(tracker)) {\n+            StringBuilder warnings = diagnose(tracker, new StringBuilder(), hasOutstanding);\n+            if (hasOutstanding.test(tracker)) {\n+                fail = new AssertionError(warnings.toString());\n+            }\n+        } else {\n+            System.out.println(\"PASSED: No \" + description + \" found in \" + tracker.getName());\n+        }\n+        if (fail != null) {\n+            if (printThreads && tracker.isSelectorAlive()) {\n+                printThreads(\"Some selector manager threads are still alive: \", System.out);\n+                printThreads(\"Some selector manager threads are still alive: \", System.err);\n+            }\n+        }\n+        return fail;\n+    }\n+\n","filename":"test\/jdk\/java\/net\/httpclient\/ReferenceTracker.java","additions":65,"deletions":4,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -24,0 +24,2 @@\n+import java.lang.ref.Reference;\n+import java.lang.ref.WeakReference;\n@@ -38,0 +40,2 @@\n+import java.util.concurrent.TimeUnit;\n+\n@@ -82,0 +86,1 @@\n+        Reference<HttpClient> reference = new WeakReference<>(client);\n@@ -154,0 +159,1 @@\n+\n@@ -157,1 +163,2 @@\n-                        HttpResponse<?> r = client.send(req, BodyHandlers.replacing(null));\n+                        HttpClient httpClient = reference.get();\n+                        HttpResponse<?> r = httpClient.send(req, BodyHandlers.replacing(null));\n@@ -177,0 +184,3 @@\n+            if (!executor.awaitTermination(500, TimeUnit.MILLISECONDS)) {\n+                throw new AssertionError(\"executor not terminated within bounds\");\n+            }\n@@ -185,0 +195,3 @@\n+            Reference.reachabilityFence(client);\n+            client = null;\n+            System.gc();\n@@ -186,1 +199,1 @@\n-                Thread.sleep(100);\n+                Thread.sleep(10);\n","filename":"test\/jdk\/java\/net\/httpclient\/SmallTimeout.java","additions":15,"deletions":2,"binary":false,"changes":17,"status":"modified"}]}