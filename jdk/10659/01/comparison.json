{"files":[{"patch":"@@ -42,0 +42,1 @@\n+import java.util.concurrent.Flow.Subscription;\n@@ -213,1 +214,1 @@\n-                exchange.responseSubscriberCompleted(this);\n+                exchange.unregisterResponseSubscriber(this);\n@@ -218,0 +219,12 @@\n+\n+        @Override\n+        protected void cancel(Subscription subscription) {\n+            try {\n+                super.cancel(subscription);\n+            } finally {\n+                \/\/ If the subscription is cancelled the\n+                \/\/ subscriber may or may not get completed.\n+                \/\/ Therefore we need to unregister it\n+                exchange.unregisterResponseSubscriber(this);\n+            }\n+        }\n@@ -267,1 +280,1 @@\n-    void registerResponseSubscriber(Http1ResponseBodySubscriber<T> subscriber) {\n+    private void registerResponseSubscriber(Http1ResponseBodySubscriber<T> subscriber) {\n@@ -282,2 +295,2 @@\n-    void responseSubscriberCompleted(HttpBodySubscriberWrapper<T> subscriber) {\n-        client.subscriberCompleted(subscriber);\n+    private void unregisterResponseSubscriber(Http1ResponseBodySubscriber<T> subscriber) {\n+        client.unregisterSubscriber(subscriber);\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Http1Exchange.java","additions":17,"deletions":4,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -399,0 +399,1 @@\n+    private final AtomicLong pendingSubscribersCount = new AtomicLong();\n@@ -551,1 +552,6 @@\n-                    subscribers.add(subscriber);\n+                    if (subscribers.add(subscriber)) {\n+                        long count = pendingSubscribersCount.incrementAndGet();\n+                        if (debug.on()) {\n+                            debug.log(\"body subscriber registered: \" + count);\n+                        }\n+                    }\n@@ -559,2 +565,7 @@\n-    public void subscriberCompleted(HttpBodySubscriberWrapper<?> subscriber) {\n-        subscribers.remove(subscriber);\n+    public void unregisterSubscriber(HttpBodySubscriberWrapper<?> subscriber) {\n+        if (subscribers.remove(subscriber)) {\n+            long count = pendingSubscribersCount.decrementAndGet();\n+            if (debug.on()) {\n+                debug.log(\"body subscriber unregistered: \" + count);\n+            }\n+        }\n@@ -700,0 +711,1 @@\n+        final AtomicLong subscribersCount;\n@@ -709,0 +721,1 @@\n+                          AtomicLong subscribers,\n@@ -718,0 +731,1 @@\n+            this.subscribersCount = subscribers;\n@@ -723,0 +737,4 @@\n+        public long getOutstandingSubscribers() {\n+            return subscribersCount.get();\n+        }\n+        @Override\n@@ -762,0 +780,1 @@\n+                pendingSubscribersCount,\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/HttpClientImpl.java","additions":22,"deletions":3,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -358,2 +358,2 @@\n-    private void subscriberCompleted(Http2StreamResponseSubscriber<?> subscriber) {\n-        client().subscriberCompleted(subscriber);\n+    private void unregisterResponseSubscriber(Http2StreamResponseSubscriber<?> subscriber) {\n+        client().unregisterSubscriber(subscriber);\n@@ -1544,1 +1544,1 @@\n-                Stream.this.subscriberCompleted(this);\n+                Stream.this.unregisterResponseSubscriber(this);\n@@ -1549,0 +1549,8 @@\n+        @Override\n+        protected void cancel(Subscription subscription) {\n+            try {\n+                super.cancel(subscription);\n+            } finally {\n+                Stream.this.unregisterResponseSubscriber(this);\n+            }\n+        }\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Stream.java","additions":11,"deletions":3,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import java.util.Objects;\n@@ -64,1 +65,1 @@\n-    volatile Subscription subscription;\n+    volatile SubscriptionWrapper subscription;\n@@ -70,0 +71,16 @@\n+    class SubscriptionWrapper implements Subscription {\n+        final Subscription subscription;\n+        SubscriptionWrapper(Subscription s) {\n+            this.subscription = Objects.requireNonNull(s);\n+        }\n+        @Override\n+        public void request(long n) {\n+            subscription.request(n);\n+        }\n+\n+        @Override\n+        public void cancel() {\n+            HttpBodySubscriberWrapper.this.cancel(subscription);\n+        }\n+    }\n+\n@@ -100,0 +117,4 @@\n+    protected void cancel(Subscription subscription) {\n+        subscription.cancel();\n+    }\n+\n@@ -140,1 +161,0 @@\n-        this.subscription = subscription;\n@@ -145,1 +165,2 @@\n-                userSubscriber.onSubscribe(subscription);\n+                SubscriptionWrapper wrapped = new SubscriptionWrapper(subscription);\n+                userSubscriber.onSubscribe(this.subscription = wrapped);\n@@ -160,1 +181,1 @@\n-                subscription.cancel();\n+                subscription.subscription.cancel();\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/common\/HttpBodySubscriberWrapper.java","additions":25,"deletions":4,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -62,0 +62,2 @@\n+        \/\/ number of body subscribers not yet completed or canceled\n+        long getOutstandingSubscribers();\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/common\/OperationTrackers.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -61,0 +61,1 @@\n+import java.lang.ref.Reference;\n@@ -380,0 +381,7 @@\n+\n+            var error = TRACKER.check(1,\n+                    (t) -> t.getOutstandingOperations() > 0 || t.getOutstandingSubscribers() > 0,\n+                    \"subscribers for testInputStream(%s)\\n\\t step [%s]\".formatted(req.uri(), i),\n+                    false);\n+            Reference.reachabilityFence(client);\n+            if (error != null) throw error;\n@@ -484,0 +492,7 @@\n+\n+            var error = TRACKER.check(1,\n+                    (t) -> t.getOutstandingOperations() > 0 || t.getOutstandingSubscribers() > 0,\n+                    \"subscribers for testInputStream(%s)\\n\\t step [%s]\".formatted(req.uri(), i),\n+                    false);\n+            Reference.reachabilityFence(client);\n+            if (error != null) throw error;\n@@ -539,0 +554,7 @@\n+\n+            var error = TRACKER.check(1,\n+                    (t) -> t.getOutstandingOperations() > 0 || t.getOutstandingSubscribers() > 0,\n+                    \"subscribers for testInputStream(%s)\\n\\t step [%s]\".formatted(req.uri(), i),\n+                    false);\n+            Reference.reachabilityFence(client);\n+            if (error != null) throw error;\n","filename":"test\/jdk\/java\/net\/httpclient\/CancelRequestTest.java","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -0,0 +1,434 @@\n+\/*\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8294916\n+ * @summary Tests that closing a streaming handler (ofInputStream()\/ofLines())\n+ *      without reading all the bytes unregisters the underlying subscriber.\n+ * @library \/test\/lib http2\/server\n+ * @build jdk.test.lib.net.SimpleSSLContext HttpServerAdapters\n+ *        ReferenceTracker CancelStreamedBodyTest\n+ * @modules java.base\/sun.net.www.http\n+ *          java.net.http\/jdk.internal.net.http.common\n+ *          java.net.http\/jdk.internal.net.http.frame\n+ *          java.net.http\/jdk.internal.net.http.hpack\n+ * @run testng\/othervm -Djdk.internal.httpclient.debug=true\n+ *                     CancelStreamedBodyTest\n+ *\/\n+import com.sun.net.httpserver.HttpServer;\n+import com.sun.net.httpserver.HttpsConfigurator;\n+import com.sun.net.httpserver.HttpsServer;\n+import jdk.internal.net.http.common.OperationTrackers.Tracker;\n+import jdk.test.lib.RandomFactory;\n+import jdk.test.lib.net.SimpleSSLContext;\n+import org.testng.ITestContext;\n+import org.testng.ITestResult;\n+import org.testng.SkipException;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.AfterTest;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.BeforeTest;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import javax.net.ssl.SSLContext;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.lang.ref.Reference;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.URI;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpConnectTimeoutException;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpResponse;\n+import java.net.http.HttpResponse.BodyHandler;\n+import java.net.http.HttpResponse.BodyHandlers;\n+import java.util.Arrays;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.concurrent.CancellationException;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static java.lang.System.arraycopy;\n+import static java.lang.System.out;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertFalse;\n+import static org.testng.Assert.assertTrue;\n+\n+public class CancelStreamedBodyTest implements HttpServerAdapters {\n+\n+    SSLContext sslContext;\n+    HttpTestServer httpTestServer;    \/\/ HTTP\/1.1    [ 4 servers ]\n+    HttpTestServer httpsTestServer;   \/\/ HTTPS\/1.1\n+    HttpTestServer http2TestServer;   \/\/ HTTP\/2 ( h2c )\n+    HttpTestServer https2TestServer;  \/\/ HTTP\/2 ( h2  )\n+    String httpURI;\n+    String httpsURI;\n+    String http2URI;\n+    String https2URI;\n+\n+    static final long SERVER_LATENCY = 75;\n+    static final int MAX_CLIENT_DELAY = 75;\n+    static final int ITERATION_COUNT = 3;\n+    \/\/ a shared executor helps reduce the amount of threads created by the test\n+    static final Executor executor = new TestExecutor(Executors.newCachedThreadPool());\n+    static final ConcurrentMap<String, Throwable> FAILURES = new ConcurrentHashMap<>();\n+    static volatile boolean tasksFailed;\n+    static final AtomicLong serverCount = new AtomicLong();\n+    static final AtomicLong clientCount = new AtomicLong();\n+    static final long start = System.nanoTime();\n+    public static String now() {\n+        long now = System.nanoTime() - start;\n+        long secs = now \/ 1000_000_000;\n+        long mill = (now % 1000_000_000) \/ 1000_000;\n+        long nan = now % 1000_000;\n+        return String.format(\"[%d s, %d ms, %d ns] \", secs, mill, nan);\n+    }\n+\n+    final ReferenceTracker TRACKER = ReferenceTracker.INSTANCE;\n+    private volatile HttpClient sharedClient;\n+\n+    static class TestExecutor implements Executor {\n+        final AtomicLong tasks = new AtomicLong();\n+        Executor executor;\n+        TestExecutor(Executor executor) {\n+            this.executor = executor;\n+        }\n+\n+        @Override\n+        public void execute(Runnable command) {\n+            long id = tasks.incrementAndGet();\n+            executor.execute(() -> {\n+                try {\n+                    command.run();\n+                } catch (Throwable t) {\n+                    tasksFailed = true;\n+                    System.out.printf(now() + \"Task %s failed: %s%n\", id, t);\n+                    System.err.printf(now() + \"Task %s failed: %s%n\", id, t);\n+                    FAILURES.putIfAbsent(\"Task \" + id, t);\n+                    throw t;\n+                }\n+            });\n+        }\n+    }\n+\n+    protected boolean stopAfterFirstFailure() {\n+        return Boolean.getBoolean(\"jdk.internal.httpclient.debug\");\n+    }\n+\n+    final AtomicReference<SkipException> skiptests = new AtomicReference<>();\n+    void checkSkip() {\n+        var skip = skiptests.get();\n+        if (skip != null) throw skip;\n+    }\n+    static String name(ITestResult result) {\n+        var params = result.getParameters();\n+        return result.getName()\n+                + (params == null ? \"()\" : Arrays.toString(result.getParameters()));\n+    }\n+\n+    @BeforeMethod\n+    void beforeMethod(ITestContext context) {\n+        if (stopAfterFirstFailure() && context.getFailedTests().size() > 0) {\n+            if (skiptests.get() == null) {\n+                SkipException skip = new SkipException(\"some tests failed\");\n+                skip.setStackTrace(new StackTraceElement[0]);\n+                skiptests.compareAndSet(null, skip);\n+            }\n+        }\n+    }\n+\n+    @AfterClass\n+    static final void printFailedTests(ITestContext context) {\n+        out.println(\"\\n=========================\");\n+        var failed = context.getFailedTests().getAllResults().stream()\n+                .collect(Collectors.toMap(r -> name(r), ITestResult::getThrowable));\n+        FAILURES.putAll(failed);\n+        try {\n+            out.printf(\"%n%sCreated %d servers and %d clients%n\",\n+                    now(), serverCount.get(), clientCount.get());\n+            if (FAILURES.isEmpty()) return;\n+            out.println(\"Failed tests: \");\n+            FAILURES.entrySet().forEach((e) -> {\n+                out.printf(\"\\t%s: %s%n\", e.getKey(), e.getValue());\n+                e.getValue().printStackTrace(out);\n+            });\n+            if (tasksFailed) {\n+                System.out.println(\"WARNING: Some tasks failed\");\n+            }\n+        } finally {\n+            out.println(\"\\n=========================\\n\");\n+        }\n+    }\n+\n+    private String[] uris() {\n+        return new String[] {\n+                httpURI,\n+                httpsURI,\n+                http2URI,\n+                https2URI,\n+        };\n+    }\n+\n+\n+    @DataProvider(name = \"urls\")\n+    public Object[][] alltests() {\n+        String[] uris = uris();\n+        Object[][] result = new Object[uris.length * 2][];\n+        \/\/Object[][] result = new Object[uris.length][];\n+        int i = 0;\n+        for (boolean sameClient : List.of(false, true)) {\n+            \/\/if (!sameClient) continue;\n+            for (String uri : uris()) {\n+                String path = sameClient ? \"same\" : \"new\";\n+                result[i++] = new Object[]{uri + path, sameClient};\n+            }\n+        }\n+        assert i == uris.length * 2;\n+        \/\/ assert i == uris.length ;\n+        return result;\n+    }\n+\n+    private HttpClient makeNewClient(boolean shared) {\n+        clientCount.incrementAndGet();\n+        var client = HttpClient.newBuilder()\n+                .proxy(HttpClient.Builder.NO_PROXY)\n+                .executor(executor)\n+                .sslContext(sslContext)\n+                .build();\n+        return shared ? client : TRACKER.track(client);\n+    }\n+\n+    HttpClient newHttpClient(boolean share) {\n+        if (!share) return makeNewClient(share);\n+        HttpClient shared = sharedClient;\n+        if (shared != null) return shared;\n+        synchronized (this) {\n+            shared = sharedClient;\n+            if (shared == null) {\n+                shared = sharedClient = makeNewClient(share);\n+            }\n+            return shared;\n+        }\n+    }\n+\n+    final static String BODY = \"Some string |\\n that ?\\n can |\\n be split ?\\n several |\\n ways.\";\n+\n+\n+    @Test(dataProvider = \"urls\")\n+    public void testAsLines(String uri, boolean sameClient)\n+            throws Exception {\n+        checkSkip();\n+        HttpClient client = null;\n+        uri = uri + \"\/testAsLines\";\n+        out.printf(\"%n%s testAsLines(%s, %b)%n\", now(), uri, sameClient);\n+        for (int i=0; i< ITERATION_COUNT; i++) {\n+            if (!sameClient || client == null)\n+                client = newHttpClient(sameClient);\n+\n+            HttpRequest req = HttpRequest.newBuilder(URI.create(uri))\n+                    .GET()\n+                    .build();\n+            Exception failed = null;\n+            List<String> lines = null;\n+            for (int j = 0; j < 2; j++) {\n+                try (Stream<String> body = client.send(req, BodyHandlers.ofLines()).body()) {\n+                    lines = body.limit(j).toList();\n+                    assertEquals(lines, BODY.replaceAll(\"\\\\||\\\\?\", \"\")\n+                            .lines().limit(j).toList());\n+                }\n+                var error = TRACKER.check(500,\n+                        (t) -> t.getOutstandingOperations() > 0 || t.getOutstandingSubscribers() > 0,\n+                        \"subscribers for testAsLines(%s)\\n\\t step [%s,%s]\".formatted(req.uri(), i,j),\n+                        false);\n+                Reference.reachabilityFence(client);\n+                if (error != null) throw error;\n+            }\n+            if (sameClient) continue;\n+            client = null;\n+            System.gc();\n+            var error = TRACKER.check(500);\n+            if (error != null) throw error;\n+        }\n+    }\n+\n+    @Test(dataProvider = \"urls\")\n+    public void testInputStream(String uri, boolean sameClient)\n+            throws Exception {\n+        checkSkip();\n+        HttpClient client = null;\n+        uri = uri + \"\/testInputStream\";\n+        out.printf(\"%n%s testInputStream(%s, %b)%n\", now(), uri, sameClient);\n+        for (int i=0; i< ITERATION_COUNT; i++) {\n+            if (!sameClient || client == null)\n+                client = newHttpClient(sameClient);\n+\n+            HttpRequest req = HttpRequest.newBuilder(URI.create(uri))\n+                    .GET()\n+                    .build();\n+            int read = -1;\n+            for (int j = 0; j < 2; j++) {\n+                try (InputStream is = client.send(req, BodyHandlers.ofInputStream()).body()) {\n+                    for (int k = 0; k < j; k++) {\n+                        read = is.read();\n+                        assertEquals(read, BODY.charAt(k));\n+                    }\n+                }\n+                var error = TRACKER.check(1,\n+                        (t) -> t.getOutstandingOperations() > 0 || t.getOutstandingSubscribers() > 0,\n+                        \"subscribers for testInputStream(%s)\\n\\t step [%s,%s]\".formatted(req.uri(), i,j),\n+                        false);\n+                Reference.reachabilityFence(client);\n+                if (error != null) throw error;\n+            }\n+            if (sameClient) continue;\n+            client = null;\n+            System.gc();\n+            var error = TRACKER.check(1);\n+            if (error != null) throw error;\n+        }\n+    }\n+\n+\n+\n+    @BeforeTest\n+    public void setup() throws Exception {\n+        sslContext = new SimpleSSLContext().get();\n+        if (sslContext == null)\n+            throw new AssertionError(\"Unexpected null sslContext\");\n+\n+        \/\/ HTTP\/1.1\n+        HttpTestHandler h1_chunkHandler = new HTTPSlowHandler();\n+        InetSocketAddress sa = new InetSocketAddress(InetAddress.getLoopbackAddress(), 0);\n+        httpTestServer = HttpTestServer.of(HttpServer.create(sa, 0));\n+        httpTestServer.addHandler(h1_chunkHandler, \"\/http1\/x\/\");\n+        httpURI = \"http:\/\/\" + httpTestServer.serverAuthority() + \"\/http1\/x\/\";\n+\n+        HttpsServer httpsServer = HttpsServer.create(sa, 0);\n+        httpsServer.setHttpsConfigurator(new HttpsConfigurator(sslContext));\n+        httpsTestServer = HttpTestServer.of(httpsServer);\n+        httpsTestServer.addHandler(h1_chunkHandler, \"\/https1\/x\/\");\n+        httpsURI = \"https:\/\/\" + httpsTestServer.serverAuthority() + \"\/https1\/x\/\";\n+\n+        \/\/ HTTP\/2\n+        HttpTestHandler h2_chunkedHandler = new HTTPSlowHandler();\n+\n+        http2TestServer = HttpTestServer.of(new Http2TestServer(\"localhost\", false, 0));\n+        http2TestServer.addHandler(h2_chunkedHandler, \"\/http2\/x\/\");\n+        http2URI = \"http:\/\/\" + http2TestServer.serverAuthority() + \"\/http2\/x\/\";\n+\n+        https2TestServer = HttpTestServer.of(new Http2TestServer(\"localhost\", true, sslContext));\n+        https2TestServer.addHandler(h2_chunkedHandler, \"\/https2\/x\/\");\n+        https2URI = \"https:\/\/\" + https2TestServer.serverAuthority() + \"\/https2\/x\/\";\n+\n+        serverCount.addAndGet(4);\n+        httpTestServer.start();\n+        httpsTestServer.start();\n+        http2TestServer.start();\n+        https2TestServer.start();\n+    }\n+\n+    @AfterTest\n+    public void teardown() throws Exception {\n+        String sharedClientName =\n+                sharedClient == null ? null : sharedClient.toString();\n+        TRACKER.track(sharedClient);\n+        sharedClient = null;\n+        Thread.sleep(100);\n+        AssertionError fail = TRACKER.check(500);\n+        try {\n+            httpTestServer.stop();\n+            httpsTestServer.stop();\n+            http2TestServer.stop();\n+            https2TestServer.stop();\n+        } finally {\n+            if (fail != null) {\n+                if (sharedClientName != null) {\n+                    System.err.println(\"Shared client name is: \" + sharedClientName);\n+                }\n+                throw fail;\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * A handler that slowly sends back a body to give time for the\n+     * the request to get cancelled before the body is fully received.\n+     *\/\n+    static class HTTPSlowHandler implements HttpTestHandler {\n+        @Override\n+        public void handle(HttpTestExchange t) throws IOException {\n+            try {\n+                out.println(\"HTTPSlowHandler received request to \" + t.getRequestURI());\n+                System.err.println(\"HTTPSlowHandler received request to \" + t.getRequestURI());\n+\n+                byte[] req;\n+                try (InputStream is = t.getRequestBody()) {\n+                    req = is.readAllBytes();\n+                }\n+                t.sendResponseHeaders(200, -1); \/\/ chunked\/variable\n+                try (OutputStream os = t.getResponseBody()) {\n+                    \/\/ lets split the response in several chunks...\n+                    String msg = (req != null && req.length != 0)\n+                            ? new String(req, UTF_8)\n+                            : BODY;\n+                    String[] str = msg.split(\"\\\\|\");\n+                    for (var s : str) {\n+                        req = s.getBytes(UTF_8);\n+                        os.write(req);\n+                        os.flush();\n+                        try {\n+                            Thread.sleep(SERVER_LATENCY);\n+                        } catch (InterruptedException x) {\n+                            \/\/ OK\n+                        }\n+                        out.printf(\"Server wrote %d bytes%n\", req.length);\n+                    }\n+                }\n+            } catch (Throwable e) {\n+                out.println(\"HTTPSlowHandler: unexpected exception: \" + e);\n+                e.printStackTrace();\n+                throw e;\n+            } finally {\n+                out.printf(\"HTTPSlowHandler reply sent: %s%n\", t.getRequestURI());\n+                System.err.printf(\"HTTPSlowHandler reply sent: %s%n\", t.getRequestURI());\n+            }\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/CancelStreamedBodyTest.java","additions":434,"deletions":0,"binary":false,"changes":434,"status":"added"},{"patch":"@@ -75,0 +75,4 @@\n+    public boolean hasOutstandingSubscribers() {\n+        return TRACKERS.stream().anyMatch(t -> t.getOutstandingSubscribers() > 0);\n+    }\n+\n@@ -90,0 +94,2 @@\n+        Predicate<Tracker> hasHttpOperations = (t) -> t.getOutstandingHttpOperations() > 0;\n+        Predicate<Tracker> hasSubscribers = (t) -> t.getOutstandingSubscribers() > 0;\n@@ -91,1 +97,1 @@\n-                (t) -> t.getOutstandingHttpOperations() > 0,\n+                hasHttpOperations.or(hasSubscribers),\n@@ -246,0 +252,1 @@\n+            warning.append(\"\\n\\tPending Subscribers: \" + tracker.getOutstandingSubscribers());\n@@ -270,0 +277,1 @@\n+        Predicate<Tracker> hasPendingSubscribers = (t) -> t.getOutstandingSubscribers() > 0;\n@@ -271,1 +279,3 @@\n-                isAlive.or(hasPendingRequests).or(hasPendingConnections),\n+                isAlive.or(hasPendingRequests)\n+                        .or(hasPendingConnections)\n+                        .or(hasPendingSubscribers),\n","filename":"test\/jdk\/java\/net\/httpclient\/ReferenceTracker.java","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"}]}