{"files":[{"patch":"@@ -4325,4 +4325,4 @@\n-  int scan_step   = itableOffsetEntry::size() * wordSize;\n-  int vte_size    = vtableEntry::size_in_bytes();\n-  int ioffset     = itableOffsetEntry::interface_offset_in_bytes();\n-  int ooffset     = itableOffsetEntry::offset_offset_in_bytes();\n+  int scan_step = itableOffsetEntry::size() * wordSize;\n+  int vte_size = vtableEntry::size_in_bytes();\n+  int ioffset = itableOffsetEntry::interface_offset_in_bytes();\n+  int ooffset = itableOffsetEntry::offset_offset_in_bytes();\n@@ -4332,3 +4332,4 @@\n-  Label loop1, loop1_postloop, loop1_internal, loop2, holder_found, last_load;\n-                                               \/\/ temp_itbl_klass = recv_klass.itable[0]\n-                                               \/\/ scan_temp = &recv_klass.itable[0] + step\n+  Label L_loop_scan_resolved_entry, L_resolved_found, L_holder_found;\n+\n+  \/\/ temp_itbl_klass = recv_klass.itable[0]\n+  \/\/ scan_temp = &recv_klass.itable[0] + step\n@@ -4337,1 +4338,1 @@\n-  lea(scan_temp,          Address(recv_klass, scan_temp, times_vte_scale, vtable_base + ioffset + scan_step));\n+  lea(scan_temp, Address(recv_klass, scan_temp, times_vte_scale, vtable_base + ioffset + scan_step));\n@@ -4340,0 +4341,4 @@\n+  \/\/ Initial checks:\n+  \/\/   - if (holder_klass != resolved_klass), go to \"scan for resolved\"\n+  \/\/   - if (itable[0] == 0), no such interface\n+  \/\/   - if (itable[0] == holder_klass), shortcut to \"holder found\"\n@@ -4341,1 +4346,1 @@\n-  jccb(Assembler::notEqual, loop1_internal);   \/\/ if (holder_klass != resolved_klass) { goto loop1; }\n+  jccb(Assembler::notEqual, L_loop_scan_resolved_entry);\n@@ -4343,1 +4348,1 @@\n-  jccb(Assembler::zero, L_no_such_interface);  \/\/ if (itable[0] == 0) goto L_no_such_interface\n+  jccb(Assembler::zero, L_no_such_interface);\n@@ -4345,29 +4350,59 @@\n-  jccb(Assembler::equal, holder_found);        \/\/ if (itable[0] == holder_klass) goto holder_found;\n-\n-  bind(loop2);                                 \/\/ { # loop2: look for holder_klass record in itable\n-  movptr(temp_itbl_klass, Address(scan_temp, 0));\n-  addptr(scan_temp, scan_step);                \/\/   index += step;\n-  cmpptr(holder_klass, temp_itbl_klass);       \/\/\n-  jccb(Assembler::equal, holder_found);        \/\/   if (itable[index] == holder_klass) goto holder_found;\n-  testptr(temp_itbl_klass, temp_itbl_klass);   \/\/\n-  jccb(Assembler::notZero, loop2);             \/\/ } while (itable[index] != 0)\n-  jmpb(L_no_such_interface);                   \/\/\n-\n-  bind(loop1);                                 \/\/ { # loop1: look for resolved_class record in itable\n-  movptr(temp_itbl_klass, Address(scan_temp, 0));\n-  addptr(scan_temp, scan_step);                \/\/    index += step;\n-  bind(loop1_internal);                        \/\/\n-  cmpptr(holder_klass, temp_itbl_klass);       \/\/    if (itable[index] == holder_klass) \/\/ also check if we have met a holder_klass\n-                                               \/\/       temp_reg = itable[index-step-ioffset];\n-  cmovl(Assembler::equal, temp_reg, Address(scan_temp, ooffset - ioffset - scan_step));\n-  cmpptr(resolved_klass, temp_itbl_klass);     \/\/\n-  jccb(Assembler::equal, loop1_postloop);      \/\/    if (itable[index] == resolved_klass) break;\n-  testptr(temp_itbl_klass, temp_itbl_klass);   \/\/\n-  jccb(Assembler::notZero, loop1);             \/\/ } while (itable[index] != 0)\n-  jmpb(L_no_such_interface);                   \/\/\n-  bind(loop1_postloop);                        \/\/ # loop1_postloop:\n-  testptr(temp_reg, temp_reg);                 \/\/ if (temp_reg == 0) \/\/ if we have not met holder_klass yet, do it in loop2\n-  jccb(Assembler::zero, loop2);                \/\/   goto loop2;\n-  jmpb(last_load);\n-\n-  bind(holder_found);\n+  jccb(Assembler::equal, L_holder_found);\n+\n+  \/\/ Loop: Look for holder_klass record in itable\n+  \/\/   do {\n+  \/\/     tmp = itable[index];\n+  \/\/     index += step;\n+  \/\/     if (tmp == holder_klass) {\n+  \/\/       goto L_holder_found; \/\/ Found!\n+  \/\/     }\n+  \/\/   } while (tmp != 0);\n+  \/\/   goto L_no_such_interface \/\/ Not found.\n+  Label L_scan_holder;\n+  bind(L_scan_holder);\n+    movptr(temp_itbl_klass, Address(scan_temp, 0));\n+    addptr(scan_temp, scan_step);\n+    cmpptr(holder_klass, temp_itbl_klass);\n+    jccb(Assembler::equal, L_holder_found);\n+    testptr(temp_itbl_klass, temp_itbl_klass);\n+    jccb(Assembler::notZero, L_scan_holder);\n+\n+  jmpb(L_no_such_interface);\n+\n+  \/\/ Loop: Look for resolved_class record in itable\n+  \/\/   do {\n+  \/\/     tmp = itable[index];\n+  \/\/     index += step;\n+  \/\/     if (tmp == holder_klass) {\n+  \/\/        \/\/ Also check if we have met a holder klass\n+  \/\/        holder_tmp = itable[index-step-ioffset];\n+  \/\/     }\n+  \/\/     if (tmp == resolved_klass) {\n+  \/\/        goto L_resolved_found;  \/\/ Found!\n+  \/\/     }\n+  \/\/   } while (tmp != 0);\n+  \/\/   goto L_no_such_interface \/\/ Not found.\n+  \/\/\n+  Label L_loop_scan_resolved;\n+  bind(L_loop_scan_resolved);\n+    movptr(temp_itbl_klass, Address(scan_temp, 0));\n+    addptr(scan_temp, scan_step);\n+    bind(L_loop_scan_resolved_entry);\n+    cmpptr(holder_klass, temp_itbl_klass);\n+    cmovl(Assembler::equal, temp_reg, Address(scan_temp, ooffset - ioffset - scan_step));\n+    cmpptr(resolved_klass, temp_itbl_klass);\n+    jccb(Assembler::equal, L_resolved_found);\n+    testptr(temp_itbl_klass, temp_itbl_klass);\n+    jccb(Assembler::notZero, L_loop_scan_resolved);\n+\n+  jmpb(L_no_such_interface);\n+\n+  Label L_ready;\n+\n+  \/\/ See if we already have a holder klass. If not, go and scan for it.\n+  bind(L_resolved_found);\n+  testptr(temp_reg, temp_reg);\n+  jccb(Assembler::zero, L_scan_holder);\n+  jmpb(L_ready);\n+\n+  bind(L_holder_found);\n@@ -4375,1 +4410,3 @@\n-  bind(last_load);                             \/\/ temp_reg contains holder_klass vtable offset\n+\n+  \/\/ Finally, temp_reg contains holder_klass vtable offset\n+  bind(L_ready);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":77,"deletions":40,"binary":false,"changes":117,"status":"modified"},{"patch":"@@ -182,1 +182,1 @@\n-  \/\/ Most registers are in use; we'll use rax, rbx, rsi, rdi\n+  \/\/ Most registers are in use; we'll use rax, rbx, rcx, rdx, rsi, rdi\n","filename":"src\/hotspot\/cpu\/x86\/vtableStubs_x86_32.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}