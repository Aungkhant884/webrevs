{"files":[{"patch":"@@ -4303,0 +4303,119 @@\n+\/\/ Look up the method for a megamorphic invokeinterface call in a single pass over itable:\n+\/\/ - check recv_klass (actual object class) is a subtype of resolved_klass from CompiledICHolder\n+\/\/ - find a holder_klass (class that implements the method) vtable offset and get the method from vtable by index\n+\/\/ The target method is determined by <holder_klass, itable_index>.\n+\/\/ The receiver klass is in recv_klass.\n+\/\/ On success, the result will be in method_result, and execution falls through.\n+\/\/ On failure, execution transfers to the given label.\n+void MacroAssembler::lookup_interface_method_stub(Register recv_klass,\n+                                                  Register holder_klass,\n+                                                  Register resolved_klass,\n+                                                  Register method_result,\n+                                                  Register scan_temp,\n+                                                  Register temp_reg2,\n+                                                  Register receiver,\n+                                                  int itable_index,\n+                                                  Label& L_no_such_interface) {\n+  assert_different_registers(recv_klass, method_result, holder_klass, resolved_klass, scan_temp, temp_reg2, receiver);\n+  Register temp_itbl_klass = method_result;\n+  Register temp_reg = (temp_reg2 == noreg ? recv_klass : temp_reg2); \/\/ reuse recv_klass register on 32-bit x86 impl\n+\n+  int vtable_base = in_bytes(Klass::vtable_start_offset());\n+  int itentry_off = itableMethodEntry::method_offset_in_bytes();\n+  int scan_step = itableOffsetEntry::size() * wordSize;\n+  int vte_size = vtableEntry::size_in_bytes();\n+  int ioffset = itableOffsetEntry::interface_offset_in_bytes();\n+  int ooffset = itableOffsetEntry::offset_offset_in_bytes();\n+  Address::ScaleFactor times_vte_scale = Address::times_ptr;\n+  assert(vte_size == wordSize, \"adjust times_vte_scale\");\n+\n+  Label L_loop_scan_resolved_entry, L_resolved_found, L_holder_found;\n+\n+  \/\/ temp_itbl_klass = recv_klass.itable[0]\n+  \/\/ scan_temp = &recv_klass.itable[0] + step\n+  movl(scan_temp, Address(recv_klass, Klass::vtable_length_offset()));\n+  movptr(temp_itbl_klass, Address(recv_klass, scan_temp, times_vte_scale, vtable_base + ioffset));\n+  lea(scan_temp, Address(recv_klass, scan_temp, times_vte_scale, vtable_base + ioffset + scan_step));\n+  xorptr(temp_reg, temp_reg);\n+\n+  \/\/ Initial checks:\n+  \/\/   - if (holder_klass != resolved_klass), go to \"scan for resolved\"\n+  \/\/   - if (itable[0] == 0), no such interface\n+  \/\/   - if (itable[0] == holder_klass), shortcut to \"holder found\"\n+  cmpptr(holder_klass, resolved_klass);\n+  jccb(Assembler::notEqual, L_loop_scan_resolved_entry);\n+  testptr(temp_itbl_klass, temp_itbl_klass);\n+  jccb(Assembler::zero, L_no_such_interface);\n+  cmpptr(holder_klass, temp_itbl_klass);\n+  jccb(Assembler::equal, L_holder_found);\n+\n+  \/\/ Loop: Look for holder_klass record in itable\n+  \/\/   do {\n+  \/\/     tmp = itable[index];\n+  \/\/     index += step;\n+  \/\/     if (tmp == holder_klass) {\n+  \/\/       goto L_holder_found; \/\/ Found!\n+  \/\/     }\n+  \/\/   } while (tmp != 0);\n+  \/\/   goto L_no_such_interface \/\/ Not found.\n+  Label L_scan_holder;\n+  bind(L_scan_holder);\n+    movptr(temp_itbl_klass, Address(scan_temp, 0));\n+    addptr(scan_temp, scan_step);\n+    cmpptr(holder_klass, temp_itbl_klass);\n+    jccb(Assembler::equal, L_holder_found);\n+    testptr(temp_itbl_klass, temp_itbl_klass);\n+    jccb(Assembler::notZero, L_scan_holder);\n+\n+  jmpb(L_no_such_interface);\n+\n+  \/\/ Loop: Look for resolved_class record in itable\n+  \/\/   do {\n+  \/\/     tmp = itable[index];\n+  \/\/     index += step;\n+  \/\/     if (tmp == holder_klass) {\n+  \/\/        \/\/ Also check if we have met a holder klass\n+  \/\/        holder_tmp = itable[index-step-ioffset];\n+  \/\/     }\n+  \/\/     if (tmp == resolved_klass) {\n+  \/\/        goto L_resolved_found;  \/\/ Found!\n+  \/\/     }\n+  \/\/   } while (tmp != 0);\n+  \/\/   goto L_no_such_interface \/\/ Not found.\n+  \/\/\n+  Label L_loop_scan_resolved;\n+  bind(L_loop_scan_resolved);\n+    movptr(temp_itbl_klass, Address(scan_temp, 0));\n+    addptr(scan_temp, scan_step);\n+    bind(L_loop_scan_resolved_entry);\n+    cmpptr(holder_klass, temp_itbl_klass);\n+    cmovl(Assembler::equal, temp_reg, Address(scan_temp, ooffset - ioffset - scan_step));\n+    cmpptr(resolved_klass, temp_itbl_klass);\n+    jccb(Assembler::equal, L_resolved_found);\n+    testptr(temp_itbl_klass, temp_itbl_klass);\n+    jccb(Assembler::notZero, L_loop_scan_resolved);\n+\n+  jmpb(L_no_such_interface);\n+\n+  Label L_ready;\n+\n+  \/\/ See if we already have a holder klass. If not, go and scan for it.\n+  bind(L_resolved_found);\n+  testptr(temp_reg, temp_reg);\n+  jccb(Assembler::zero, L_scan_holder);\n+  jmpb(L_ready);\n+\n+  bind(L_holder_found);\n+  movl(temp_reg, Address(scan_temp, ooffset - ioffset - scan_step));\n+\n+  \/\/ Finally, temp_reg contains holder_klass vtable offset\n+  bind(L_ready);\n+  assert(itableMethodEntry::size() * wordSize == wordSize, \"adjust the scaling in the code below\");\n+  if (temp_reg2 == noreg) { \/\/ recv_klass register is clobbered for 32-bit x86 impl\n+    load_klass(scan_temp, receiver, noreg);\n+    movptr(method_result, Address(scan_temp, temp_reg, Address::times_1, itable_index * wordSize + itentry_off));\n+  } else {\n+    movptr(method_result, Address(recv_klass, temp_reg, Address::times_1, itable_index * wordSize + itentry_off));\n+  }\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":119,"deletions":0,"binary":false,"changes":119,"status":"modified"},{"patch":"@@ -604,0 +604,10 @@\n+  void lookup_interface_method_stub(Register recv_klass,\n+                                    Register holder_klass,\n+                                    Register resolved_klass,\n+                                    Register method_result,\n+                                    Register scan_temp,\n+                                    Register temp_reg2,\n+                                    Register receiver,\n+                                    int itable_index,\n+                                    Label& L_no_such_interface);\n+\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -182,1 +182,1 @@\n-  \/\/ Most registers are in use; we'll use rax, rbx, rsi, rdi\n+  \/\/ Most registers are in use; we'll use rax, rbx, rcx, rdx, rsi, rdi\n@@ -186,2 +186,5 @@\n-  const Register resolved_klass_reg = rbx; \/\/ resolved interface klass (REFC)\n-  const Register temp_reg           = rdi;\n+  const Register resolved_klass_reg = rdi; \/\/ resolved interface klass (REFC)\n+  const Register temp_reg           = rdx;\n+  const Register method             = rbx;\n+  const Register icholder_reg       = rax;\n+  const Register receiver           = rcx;\n@@ -189,1 +192,0 @@\n-  const Register icholder_reg = rax;\n@@ -201,22 +203,10 @@\n-\n-  \/\/ Receiver subtype check against REFC.\n-  \/\/ Destroys recv_klass_reg value.\n-  __ lookup_interface_method(\/\/ inputs: rec. class, interface\n-                             recv_klass_reg, resolved_klass_reg, noreg,\n-                             \/\/ outputs:  scan temp. reg1, scan temp. reg2\n-                             recv_klass_reg, temp_reg,\n-                             L_no_such_interface,\n-                             \/*return_method=*\/false);\n-\n-  const ptrdiff_t  typecheckSize = __ pc() - start_pc;\n-  start_pc = __ pc();\n-\n-  \/\/ Get selected method from declaring class and itable index\n-  const Register method = rbx;\n-  __ load_klass(recv_klass_reg, rcx, noreg); \/\/ restore recv_klass_reg\n-  __ lookup_interface_method(\/\/ inputs: rec. class, interface, itable index\n-                             recv_klass_reg, holder_klass_reg, itable_index,\n-                             \/\/ outputs: method, scan temp. reg\n-                             method, temp_reg,\n-                             L_no_such_interface);\n-\n+  __ push(temp_reg);\n+  __ lookup_interface_method_stub(recv_klass_reg,\n+                                  holder_klass_reg,\n+                                  resolved_klass_reg,\n+                                  method,\n+                                  temp_reg,\n+                                  noreg,\n+                                  receiver,\n+                                  itable_index,\n+                                  L_no_such_interface);\n@@ -229,1 +219,1 @@\n-  const ptrdiff_t codesize = typecheckSize + lookupSize + index_dependent_slop;\n+  const ptrdiff_t codesize = lookupSize + index_dependent_slop;\n@@ -249,0 +239,1 @@\n+  __ pop(temp_reg);\n@@ -258,0 +249,1 @@\n+  __ pop(temp_reg);\n","filename":"src\/hotspot\/cpu\/x86\/vtableStubs_x86_32.cpp","additions":19,"deletions":27,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -178,1 +178,1 @@\n-  const Register resolved_klass_reg = rbx; \/\/ resolved interface klass (REFC)\n+  const Register resolved_klass_reg = r14; \/\/ resolved interface klass (REFC)\n@@ -180,0 +180,4 @@\n+  const Register temp_reg2          = r13;\n+  const Register method             = rbx;\n+  const Register icholder_reg       = rax;\n+  const Register receiver           = j_rarg0;\n@@ -181,1 +185,0 @@\n-  const Register icholder_reg = rax;\n@@ -194,20 +197,9 @@\n-  \/\/ Receiver subtype check against REFC.\n-  \/\/ Destroys recv_klass_reg value.\n-  __ lookup_interface_method(\/\/ inputs: rec. class, interface\n-                             recv_klass_reg, resolved_klass_reg, noreg,\n-                             \/\/ outputs:  scan temp. reg1, scan temp. reg2\n-                             recv_klass_reg, temp_reg,\n-                             L_no_such_interface,\n-                             \/*return_method=*\/false);\n-\n-  const ptrdiff_t  typecheckSize = __ pc() - start_pc;\n-  start_pc = __ pc();\n-\n-  \/\/ Get selected method from declaring class and itable index\n-  const Register method = rbx;\n-  __ load_klass(recv_klass_reg, j_rarg0, temp_reg);   \/\/ restore recv_klass_reg\n-  __ lookup_interface_method(\/\/ inputs: rec. class, interface, itable index\n-                             recv_klass_reg, holder_klass_reg, itable_index,\n-                             \/\/ outputs: method, scan temp. reg\n-                             method, temp_reg,\n-                             L_no_such_interface);\n+  __ lookup_interface_method_stub(recv_klass_reg,\n+                                  holder_klass_reg,\n+                                  resolved_klass_reg,\n+                                  method,\n+                                  temp_reg,\n+                                  temp_reg2,\n+                                  receiver,\n+                                  itable_index,\n+                                  L_no_such_interface);\n@@ -221,1 +213,1 @@\n-  const ptrdiff_t codesize = typecheckSize + lookupSize + index_dependent_slop;\n+  const ptrdiff_t codesize = lookupSize + index_dependent_slop;\n","filename":"src\/hotspot\/cpu\/x86\/vtableStubs_x86_64.cpp","additions":15,"deletions":23,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import org.openjdk.jmh.annotations.CompilerControl;\n@@ -55,0 +56,8 @@\n+    interface FirstInterfaceExt extends FirstInterface {\n+        default int getIntFirst() {return 44;}\n+    }\n+\n+    interface FirstInterfaceExtExt extends FirstInterfaceExt {\n+        default int getIntFirst() {return 45;}\n+    }\n+\n@@ -105,0 +114,70 @@\n+    class FirstClassDontInline implements FirstInterface {\n+        @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+        public int getIntFirst() {\n+            return -1;\n+        }\n+    }\n+\n+    class SecondClassDontInline implements FirstInterface {\n+        @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+        public int getIntFirst() {\n+            return -2;\n+        }\n+    }\n+\n+    class ThirdClassDontInline implements FirstInterface {\n+        @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+        public int getIntFirst() {\n+            return -3;\n+        }\n+    }\n+\n+    class FourthClassDontInline implements FirstInterface {\n+        @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+        public int getIntFirst() {\n+            return -4;\n+        }\n+    }\n+\n+    class FifthClassDontInline implements FirstInterface {\n+        @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+        public int getIntFirst() {\n+            return -5;\n+        }\n+    }\n+\n+    class FirstClassDontInlineExtExt implements FirstInterfaceExtExt {\n+        @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+        public int getIntFirst() {\n+            return -1;\n+        }\n+    }\n+\n+    class SecondClassDontInlineExtExt implements FirstInterfaceExtExt {\n+        @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+        public int getIntFirst() {\n+            return -2;\n+        }\n+    }\n+\n+    class ThirdClassDontInlineExtExt implements FirstInterfaceExtExt {\n+        @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+        public int getIntFirst() {\n+            return -3;\n+        }\n+    }\n+\n+    class FourthClassDontInlineExtExt implements FirstInterfaceExtExt {\n+        @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+        public int getIntFirst() {\n+            return -4;\n+        }\n+    }\n+\n+    class FifthClassDontInlineExtExt implements FirstInterfaceExtExt {\n+        @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+        public int getIntFirst() {\n+            return -5;\n+        }\n+    }\n+\n@@ -107,0 +186,2 @@\n+    public FirstInterface[] noninlined = new FirstInterface[5];\n+    public FirstInterfaceExtExt[] noninlinedextext = new FirstInterfaceExtExt[5];\n@@ -116,0 +197,11 @@\n+\n+        noninlined[0] = new FirstClassDontInline();\n+        noninlined[1] = new SecondClassDontInline();\n+        noninlined[2] = new ThirdClassDontInline();\n+        noninlined[3] = new FourthClassDontInline();\n+        noninlined[4] = new FifthClassDontInline();\n+        noninlinedextext[0] = new FirstClassDontInlineExtExt();\n+        noninlinedextext[1] = new SecondClassDontInlineExtExt();\n+        noninlinedextext[2] = new ThirdClassDontInlineExtExt();\n+        noninlinedextext[3] = new FourthClassDontInlineExtExt();\n+        noninlinedextext[4] = new FifthClassDontInlineExtExt();\n@@ -127,0 +219,16 @@\n+    \/** Tests single base interface method call *\/\n+    @Benchmark\n+    public void testIfaceCall(Blackhole bh) {\n+        for (int i = 0; i < noninlined.length; i++) {\n+            bh.consume(noninlined[i].getIntFirst());\n+        }\n+    }\n+\n+    \/** Tests extended interface method call *\/\n+    @Benchmark\n+    public void testIfaceExtCall(Blackhole bh) {\n+        for (int i = 0; i < noninlinedextext.length; i++) {\n+            bh.consume(noninlinedextext[i].getIntFirst());\n+        }\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/InterfaceCalls.java","additions":108,"deletions":0,"binary":false,"changes":108,"status":"modified"}]}