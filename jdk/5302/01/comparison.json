{"files":[{"patch":"@@ -3569,1 +3569,0 @@\n-  \/\/ Concurrent start needs claim bits to keep track of the marked-through CLDs.\n@@ -3572,7 +3571,0 @@\n-\n-    double start_clear_claimed_marks = os::elapsedTime();\n-\n-    ClassLoaderDataGraph::clear_claimed_marks();\n-\n-    double recorded_clear_claimed_marks_time_ms = (os::elapsedTime() - start_clear_claimed_marks) * 1000.0;\n-    phase_times()->record_clear_claimed_marks_time_ms(recorded_clear_claimed_marks_time_ms);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"gc\/g1\/g1BatchedGangTask.hpp\"\n@@ -43,0 +44,1 @@\n+#include \"gc\/g1\/heapRegionManager.hpp\"\n@@ -474,0 +476,2 @@\n+\n+  _root_regions.reset();\n@@ -732,0 +736,54 @@\n+class G1PreConcurrentStartTask : public G1BatchedGangTask {\n+  \/\/ Concurrent start needs claim bits to keep track of the marked-through CLDs.\n+  class CLDClearClaimedMarksTask;\n+  \/\/ Reset marking state.\n+  class ResetMarkingStateTask;\n+  \/\/ For each region note start of marking.\n+  class NoteStartOfMarkTask;\n+\n+public:\n+  G1PreConcurrentStartTask(GCCause::Cause cause, G1ConcurrentMark* cm);\n+};\n+\n+class G1PreConcurrentStartTask::CLDClearClaimedMarksTask : public G1AbstractSubTask {\n+public:\n+  CLDClearClaimedMarksTask() : G1AbstractSubTask(G1GCPhaseTimes::CLDClearClaimedMarks) { }\n+\n+  double worker_cost() const override { return 1.0; }\n+  void do_work(uint worker_id) override;\n+};\n+\n+class G1PreConcurrentStartTask::ResetMarkingStateTask : public G1AbstractSubTask {\n+  G1ConcurrentMark* _cm;\n+public:\n+  ResetMarkingStateTask(G1ConcurrentMark* cm) : G1AbstractSubTask(G1GCPhaseTimes::ResetMarkingState), _cm(cm) { }\n+\n+  double worker_cost() const override { return 1.0; }\n+  void do_work(uint worker_id) override;\n+};\n+\n+class G1PreConcurrentStartTask::NoteStartOfMarkTask : public G1AbstractSubTask {\n+  HeapRegionClaimer _claimer;\n+public:\n+  NoteStartOfMarkTask() : G1AbstractSubTask(G1GCPhaseTimes::NoteStartOfMark), _claimer(0) { }\n+\n+  double worker_cost() const override {\n+    \/\/ The work done per region is very small, therefore we choose this magic number to cap the number\n+    \/\/ of threads used when there are few regions.\n+    const uint regions_per_thread = 1000;\n+    return _claimer.n_regions() \/ regions_per_thread;\n+  }\n+\n+  void set_max_workers(uint max_workers) override;\n+  void do_work(uint worker_id) override;\n+};\n+\n+void G1PreConcurrentStartTask::CLDClearClaimedMarksTask::do_work(uint worker_id) {\n+  ClassLoaderDataGraph::clear_claimed_marks();\n+}\n+\n+void G1PreConcurrentStartTask::ResetMarkingStateTask::do_work(uint worker_id) {\n+  \/\/ Reset marking state.\n+  _cm->reset();\n+}\n+\n@@ -734,1 +792,1 @@\n-  bool do_heap_region(HeapRegion* r) {\n+  bool do_heap_region(HeapRegion* r) override {\n@@ -740,2 +798,4 @@\n-void G1ConcurrentMark::pre_concurrent_start(GCCause::Cause cause) {\n-  assert_at_safepoint_on_vm_thread();\n+void G1PreConcurrentStartTask::NoteStartOfMarkTask::do_work(uint worker_id) {\n+  NoteStartOfMarkHRClosure start_cl;\n+  G1CollectedHeap::heap()->heap_region_par_iterate_from_worker_offset(&start_cl, &_claimer, worker_id);\n+}\n@@ -743,2 +803,3 @@\n-  \/\/ Reset marking state.\n-  reset();\n+void G1PreConcurrentStartTask::NoteStartOfMarkTask::set_max_workers(uint max_workers) {\n+  _claimer.set_n_workers(max_workers);\n+}\n@@ -746,3 +807,6 @@\n-  \/\/ For each region note start of marking.\n-  NoteStartOfMarkHRClosure startcl;\n-  _g1h->heap_region_iterate(&startcl);\n+G1PreConcurrentStartTask::G1PreConcurrentStartTask(GCCause::Cause cause, G1ConcurrentMark* cm) :\n+  G1BatchedGangTask(\"Pre Concurrent Start\", G1CollectedHeap::heap()->phase_times()) {\n+  add_serial_task(new CLDClearClaimedMarksTask());\n+  add_serial_task(new ResetMarkingStateTask(cm));\n+  add_parallel_task(new NoteStartOfMarkTask());\n+};\n@@ -750,1 +814,5 @@\n-  _root_regions.reset();\n+void G1ConcurrentMark::pre_concurrent_start(GCCause::Cause cause) {\n+  assert_at_safepoint_on_vm_thread();\n+\n+  G1PreConcurrentStartTask cl(cause, this);\n+  G1CollectedHeap::heap()->run_batch_task(&cl);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.cpp","additions":77,"deletions":9,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -378,4 +378,0 @@\n-  \/\/ Resets the global marking data structures, as well as the\n-  \/\/ task local ones; should be called during concurrent start.\n-  void reset();\n-\n@@ -529,0 +525,4 @@\n+  \/\/ Resets the global marking data structures, as well as the\n+  \/\/ task local ones; should be called during concurrent start.\n+  void reset();\n+\n@@ -858,1 +858,0 @@\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.hpp","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -151,0 +151,4 @@\n+  _gc_par_phases[CLDClearClaimedMarks] = new WorkerDataArray<double>(\"CLDClearClaimedMarks\", \"Clear Claimed Marks (ms):\", max_gc_threads);\n+  _gc_par_phases[ResetMarkingState] = new WorkerDataArray<double>(\"ResetMarkingState\", \"Reset Marking State (ms):\", max_gc_threads);\n+  _gc_par_phases[NoteStartOfMark] = new WorkerDataArray<double>(\"NoteStartOfMark\", \"Note Start Of Mark (ms):\", max_gc_threads);\n+\n@@ -172,1 +176,0 @@\n-  _recorded_clear_claimed_marks_time_ms = 0.0;\n@@ -289,1 +292,1 @@\n-double G1GCPhaseTimes::average_time_ms(GCParPhases phase) {\n+double G1GCPhaseTimes::average_time_ms(GCParPhases phase) const {\n@@ -378,0 +381,4 @@\n+  const double pre_concurrent_start_ms = average_time_ms(CLDClearClaimedMarks) +\n+                                         average_time_ms(ResetMarkingState) +\n+                                         average_time_ms(NoteStartOfMark);\n+\n@@ -385,1 +392,1 @@\n-                        _recorded_clear_claimed_marks_time_ms;\n+                        pre_concurrent_start_ms;\n@@ -398,2 +405,5 @@\n-  if (_recorded_clear_claimed_marks_time_ms > 0.0) {\n-    debug_time(\"Clear Claimed Marks\", _recorded_clear_claimed_marks_time_ms);\n+\n+  if (pre_concurrent_start_ms > 0.0) {\n+    debug_phase(_gc_par_phases[CLDClearClaimedMarks]);\n+    debug_phase(_gc_par_phases[ResetMarkingState]);\n+    debug_phase(_gc_par_phases[NoteStartOfMark]);\n@@ -401,0 +411,1 @@\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1GCPhaseTimes.cpp","additions":16,"deletions":5,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -90,0 +90,3 @@\n+    CLDClearClaimedMarks,\n+    ResetMarkingState,\n+    NoteStartOfMark,\n@@ -183,2 +186,0 @@\n-  double _recorded_clear_claimed_marks_time_ms;\n-\n@@ -258,1 +259,1 @@\n-  double average_time_ms(GCParPhases phase);\n+  double average_time_ms(GCParPhases phase) const;\n@@ -378,4 +379,0 @@\n-  void record_clear_claimed_marks_time_ms(double recorded_clear_claimed_marks_time_ms) {\n-    _recorded_clear_claimed_marks_time_ms = recorded_clear_claimed_marks_time_ms;\n-  }\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1GCPhaseTimes.hpp","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"}]}