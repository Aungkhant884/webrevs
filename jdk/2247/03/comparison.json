{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -969,1 +969,1 @@\n-        \/\/ Call resolve_super so classcircularity is checked\n+        \/\/ Call resolve_super so class circularity is checked\n@@ -6209,1 +6209,1 @@\n-  if (_super_class_index > 0 && NULL ==_super_klass) {\n+  if (_super_class_index > 0 && NULL == _super_klass) {\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -91,1 +91,0 @@\n-PlaceholderTable*      SystemDictionary::_placeholders        = NULL;\n@@ -106,1 +105,0 @@\n-\n@@ -109,0 +107,9 @@\n+const int _loader_constraint_size = 107;                     \/\/ number of entries in constraint table\n+const int _resolution_error_size  = 107;                     \/\/ number of entries in resolution error table\n+const int _invoke_method_size     = 139;                     \/\/ number of entries in invoke method table\n+\n+\/\/ Hashtable holding placeholders for classes being loaded.\n+const int _placeholder_table_size = 1009;\n+PlaceholderTable* _placeholders   = NULL;\n+static PlaceholderTable*   placeholders() { return _placeholders; }\n+\n@@ -219,9 +226,10 @@\n-\/\/ Forwards to resolve_or_null\n-\n-Klass* SystemDictionary::resolve_or_fail(Symbol* class_name, Handle class_loader, Handle protection_domain, bool throw_error, TRAPS) {\n-  Klass* klass = resolve_or_null(class_name, class_loader, protection_domain, THREAD);\n-  if (HAS_PENDING_EXCEPTION || klass == NULL) {\n-    \/\/ can return a null klass\n-    klass = handle_resolution_exception(class_name, throw_error, klass, THREAD);\n-  }\n-  return klass;\n+#ifdef ASSERT\n+\/\/ Used to verify that class loading succeeded in adding k to the dictionary.\n+void verify_dictionary_entry(Symbol* class_name, InstanceKlass* k) {\n+  MutexLocker mu(SystemDictionary_lock);\n+  ClassLoaderData* loader_data = k->class_loader_data();\n+  Dictionary* dictionary = loader_data->dictionary();\n+  assert(class_name == k->name(), \"Must be the same\");\n+  unsigned int name_hash = dictionary->compute_hash(class_name);\n+  InstanceKlass* kk = dictionary->find_class(name_hash, class_name);\n+  assert(kk == k, \"should be present in dictionary\");\n@@ -229,0 +237,1 @@\n+#endif\n@@ -230,3 +239,1 @@\n-Klass* SystemDictionary::handle_resolution_exception(Symbol* class_name,\n-                                                     bool throw_error,\n-                                                     Klass* klass, TRAPS) {\n+static void handle_resolution_exception(Symbol* class_name, bool throw_error, TRAPS) {\n@@ -236,2 +243,1 @@\n-    \/\/ and if so convert it to a NoClassDefFoundError\n-    \/\/ And chain the original ClassNotFoundException\n+    \/\/ and convert it to a NoClassDefFoundError and chain the original ClassNotFoundException.\n@@ -240,1 +246,0 @@\n-      assert(klass == NULL, \"Should not have result with exception pending\");\n@@ -243,1 +248,1 @@\n-      THROW_MSG_CAUSE_NULL(vmSymbols::java_lang_NoClassDefFoundError(), class_name->as_C_string(), e);\n+      THROW_MSG_CAUSE(vmSymbols::java_lang_NoClassDefFoundError(), class_name->as_C_string(), e);\n@@ -245,1 +250,1 @@\n-      return NULL;\n+      return; \/\/ the caller will throw the incoming exception\n@@ -248,8 +253,7 @@\n-  \/\/ Class not found, throw appropriate error or exception depending on value of throw_error\n-  if (klass == NULL) {\n-    ResourceMark rm(THREAD);\n-    if (throw_error) {\n-      THROW_MSG_NULL(vmSymbols::java_lang_NoClassDefFoundError(), class_name->as_C_string());\n-    } else {\n-      THROW_MSG_NULL(vmSymbols::java_lang_ClassNotFoundException(), class_name->as_C_string());\n-    }\n+  \/\/ If the class is not found, ie, caller has checked that klass is NULL, throw the appropriate\n+  \/\/ error or exception depending on the value of throw_error.\n+  ResourceMark rm(THREAD);\n+  if (throw_error) {\n+    THROW_MSG(vmSymbols::java_lang_NoClassDefFoundError(), class_name->as_C_string());\n+  } else {\n+    THROW_MSG(vmSymbols::java_lang_ClassNotFoundException(), class_name->as_C_string());\n@@ -257,1 +261,0 @@\n-  return klass;\n@@ -260,0 +263,1 @@\n+\/\/ Forwards to resolve_or_null\n@@ -261,4 +265,8 @@\n-Klass* SystemDictionary::resolve_or_fail(Symbol* class_name,\n-                                           bool throw_error, TRAPS)\n-{\n-  return resolve_or_fail(class_name, Handle(), Handle(), throw_error, THREAD);\n+Klass* SystemDictionary::resolve_or_fail(Symbol* class_name, Handle class_loader, Handle protection_domain,\n+                                         bool throw_error, TRAPS) {\n+  Klass* klass = resolve_or_null(class_name, class_loader, protection_domain, THREAD);\n+  \/\/ Check for pending exception or null klass, and throw exception\n+  if (HAS_PENDING_EXCEPTION || klass == NULL) {\n+    handle_resolution_exception(class_name, throw_error, CHECK_NULL);\n+  }\n+  return klass;\n@@ -267,1 +275,0 @@\n-\n@@ -295,4 +302,0 @@\n-Klass* SystemDictionary::resolve_or_null(Symbol* class_name, TRAPS) {\n-  return resolve_or_null(class_name, Handle(), Handle(), THREAD);\n-}\n-\n@@ -331,1 +334,1 @@\n-\/\/    parse_interfaces - for defineClass & jvmtiRedefineClasses\n+\/\/    parse_interfaces - for defineClass\n@@ -333,1 +336,1 @@\n-\/\/   ClassFileParser - for defineClass & jvmtiRedefineClasses\n+\/\/   ClassFileParser - for defineClass\n@@ -360,3 +363,0 @@\n-\/\/ Must be called, even if superclass is null, since this is\n-\/\/ where the placeholder entry is created which claims this\n-\/\/ thread is loading this class\/classloader.\n@@ -366,2 +366,2 @@\n-\/\/ So be careful to not exit with a CHECK_ macro betweeen these calls.\n-InstanceKlass* SystemDictionary::resolve_super_or_fail(Symbol* child_name,\n+\/\/ So be careful to not exit with a CHECK_ macro between these calls.\n+InstanceKlass* SystemDictionary::resolve_super_or_fail(Symbol* class_name,\n@@ -377,1 +377,1 @@\n-    InstanceKlass* k = SystemDictionaryShared::dump_time_resolve_super_or_fail(child_name,\n+    InstanceKlass* k = SystemDictionaryShared::dump_time_resolve_super_or_fail(class_name,\n@@ -385,1 +385,1 @@\n-  \/\/ Double-check, if child class is already loaded, just return super-class,interface\n+  \/\/ Double-check, if klass is already loaded, just return super-class,interface\n@@ -388,1 +388,1 @@\n-  \/\/ Make sure there's a placeholder for the *child* before resolving.\n+  \/\/ Make sure there's a placeholder for the *klass* before resolving.\n@@ -394,1 +394,1 @@\n-  \/\/ We might not already have a placeholder if this child_name was\n+  \/\/ We might not already have a placeholder if this class_name was\n@@ -402,2 +402,2 @@\n-  unsigned int name_hash = dictionary->compute_hash(child_name);\n-  assert(placeholders()->compute_hash(child_name) == name_hash, \"they're the same hashcode\");\n+  unsigned int name_hash = dictionary->compute_hash(class_name);\n+  assert(placeholders()->compute_hash(class_name) == name_hash, \"they're the same hashcode\");\n@@ -408,1 +408,1 @@\n-    InstanceKlass* childk = dictionary->find_class(name_hash, child_name);\n+    InstanceKlass* klassk = dictionary->find_class(name_hash, class_name);\n@@ -410,8 +410,5 @@\n-    \/\/ to support \/\/ loading: if child done loading, just return superclass\n-    \/\/ if super_name, & class_loader don't match:\n-    \/\/ if initial define, SD update will give LinkageError\n-    \/\/ if redefine: compare_class_versions will give HIERARCHY_CHANGED\n-    \/\/ so we don't throw an exception here.\n-    \/\/ see: nsk redefclass014 & java.lang.instrument Instrument032\n-    if ((childk != NULL ) && (is_superclass) &&\n-        ((quicksuperk = childk->java_super()) != NULL) &&\n+    \/\/ To support parallel loading: if class is done loading, just return the superclass\n+    \/\/ if the super_name matches class->super()->name() and if the class loaders match.\n+    \/\/ Otherwise, a LinkageError will be thrown later.\n+    if (klassk != NULL && is_superclass &&\n+        ((quicksuperk = klassk->java_super()) != NULL) &&\n@@ -422,1 +419,1 @@\n-      PlaceholderEntry* probe = placeholders()->get_entry(name_hash, child_name, loader_data);\n+      PlaceholderEntry* probe = placeholders()->get_entry(name_hash, class_name, loader_data);\n@@ -428,2 +425,2 @@\n-      \/\/ Be careful not to exit resolve_super\n-      PlaceholderEntry* newprobe = placeholders()->find_and_add(name_hash, child_name, loader_data, PlaceholderTable::LOAD_SUPER, super_name, THREAD);\n+      \/\/ Be careful not to exit resolve_super without removing this placeholder.\n+      PlaceholderEntry* newprobe = placeholders()->find_and_add(name_hash, class_name, loader_data, PlaceholderTable::LOAD_SUPER, super_name, THREAD);\n@@ -434,1 +431,1 @@\n-      THROW_MSG_NULL(vmSymbols::java_lang_ClassCircularityError(), child_name->as_C_string());\n+      THROW_MSG_NULL(vmSymbols::java_lang_ClassCircularityError(), class_name->as_C_string());\n@@ -454,1 +451,1 @@\n-    placeholders()->find_and_remove(name_hash, child_name, loader_data, PlaceholderTable::LOAD_SUPER, THREAD);\n+    placeholders()->find_and_remove(name_hash, class_name, loader_data, PlaceholderTable::LOAD_SUPER, THREAD);\n@@ -457,0 +454,2 @@\n+\n+  \/\/ Check for pending exception or null superk, and throw exception\n@@ -458,6 +457,1 @@\n-    \/\/ can null superk\n-    Klass* k = handle_resolution_exception(super_name, true, superk, THREAD);\n-    assert(k == NULL || k == superk, \"must be\");\n-    if (k == NULL) {\n-      superk = NULL;\n-    }\n+    handle_resolution_exception(super_name, true, CHECK_NULL);\n@@ -766,11 +760,15 @@\n-    \/\/ add placeholder entry to record loading instance class\n-    \/\/ Five cases:\n-    \/\/ All cases need to prevent modifying bootclasssearchpath\n-    \/\/ in parallel with a classload of same classname\n-    \/\/ Redefineclasses uses existence of the placeholder for the duration\n-    \/\/ of the class load to prevent concurrent redefinition of not completely\n-    \/\/ defined classes.\n-    \/\/ case 1. traditional classloaders that rely on the classloader object lock\n-    \/\/   - no other need for LOAD_INSTANCE\n-    \/\/ case 2. traditional classloaders that break the classloader object lock\n-    \/\/    as a deadlock workaround. Detection of this case requires that\n+    \/\/ Add placeholder entry to record loading instance class\n+    \/\/ Three cases:\n+    \/\/ case 1. Bootstrap classloader\n+    \/\/    This classloader supports parallelism at the classloader level\n+    \/\/    but only allows a single thread to load a class\/classloader pair.\n+    \/\/    The LOAD_INSTANCE placeholder is the mechanism for mutual exclusion.\n+    \/\/ case 2. parallelCapable user level classloaders\n+    \/\/    These class loaders don't lock the object until load_instance_class is\n+    \/\/    called after this placeholder is added.\n+    \/\/    Allow parallel classloading of a class\/classloader pair where mutual\n+    \/\/    exclusion is provided by this lock in the class loader Java code.\n+    \/\/ case 3. traditional classloaders that rely on the classloader object lock\n+    \/\/    There should be no need for need for LOAD_INSTANCE\n+    \/\/    except if the traditional classloaders break the classloader object lock\n+    \/\/    as a legacy deadlock workaround. Detection of this case requires that\n@@ -781,7 +779,0 @@\n-    \/\/ case 3. Bootstrap classloader - don't own objectLocker\n-    \/\/    This classloader supports parallelism at the classloader level,\n-    \/\/    but only allows a single load of a class\/classloader pair.\n-    \/\/    No performance benefit and no deadlock issues.\n-    \/\/ case 4. parallelCapable user level classloaders - without objectLocker\n-    \/\/    Allow parallel classloading of a class\/classloader pair\n-\n@@ -823,4 +814,1 @@\n-      \/\/ All cases: add LOAD_INSTANCE holding SystemDictionary_lock\n-      \/\/ case 4: parallelCapable: allow competing threads to try\n-      \/\/ LOAD_INSTANCE in parallel\n-\n+      \/\/ All cases: add LOAD_INSTANCE while holding the SystemDictionary_lock\n@@ -904,8 +892,3 @@\n-#ifdef ASSERT\n-  {\n-    ClassLoaderData* loader_data = loaded_class->class_loader_data();\n-    MutexLocker mu(THREAD, SystemDictionary_lock);\n-    InstanceKlass* kk = find_class(name, loader_data);\n-    assert(kk == loaded_class, \"should be present in dictionary\");\n-  }\n-#endif\n+\n+  \/\/ Make sure we have the right class in the dictionary\n+  DEBUG_ONLY(verify_dictionary_entry(name, loaded_class));\n@@ -1126,1 +1109,2 @@\n-  \/\/ find_or_define_instance_class may return a different InstanceKlass\n+  \/\/ find_or_define_instance_class may return a different InstanceKlass,\n+  \/\/ in which case the old k would be deallocated\n@@ -1128,7 +1112,1 @@\n-    InstanceKlass* defined_k = find_or_define_instance_class(h_name, class_loader, k, THREAD);\n-    if (!HAS_PENDING_EXCEPTION && defined_k != k) {\n-      \/\/ If a parallel capable class loader already defined this class, register 'k' for cleanup.\n-      assert(defined_k != NULL, \"Should have a klass if there's no exception\");\n-      loader_data->add_to_deallocate_list(k);\n-      k = defined_k;\n-    }\n+    k = find_or_define_instance_class(h_name, class_loader, k, CHECK_NULL);\n@@ -1137,1 +1115,0 @@\n-  }\n@@ -1139,5 +1116,6 @@\n-  \/\/ If defining the class throws an exception register 'k' for cleanup.\n-  if (HAS_PENDING_EXCEPTION) {\n-    assert(k != NULL, \"Must have an instance klass here!\");\n-    loader_data->add_to_deallocate_list(k);\n-    return NULL;\n+    \/\/ If defining the class throws an exception register 'k' for cleanup.\n+    if (HAS_PENDING_EXCEPTION) {\n+      assert(k != NULL, \"Must have an instance klass here!\");\n+      loader_data->add_to_deallocate_list(k);\n+      return NULL;\n+    }\n@@ -1147,6 +1125,1 @@\n-  debug_only( {\n-    MutexLocker mu(THREAD, SystemDictionary_lock);\n-\n-    Klass* check = find_class(h_name, k->class_loader_data());\n-    assert(check == k, \"should be present in the dictionary\");\n-  } );\n+  DEBUG_ONLY(verify_dictionary_entry(h_name, k));\n@@ -1259,1 +1232,1 @@\n-bool SystemDictionary::check_shared_class_super_type(InstanceKlass* child, InstanceKlass* super_type,\n+bool SystemDictionary::check_shared_class_super_type(InstanceKlass* klass, InstanceKlass* super_type,\n@@ -1264,1 +1237,1 @@\n-  Klass *found = resolve_super_or_fail(child->name(), super_type->name(),\n+  Klass *found = resolve_super_or_fail(klass->name(), super_type->name(),\n@@ -1270,1 +1243,1 @@\n-    \/\/ so we cannot use the child class.\n+    \/\/ so we cannot use the class.\n@@ -1537,11 +1510,1 @@\n-      InstanceKlass* defined_k =\n-        find_or_define_instance_class(class_name, class_loader, k, THREAD);\n-      if (!HAS_PENDING_EXCEPTION && defined_k != k) {\n-        \/\/ If a parallel capable class loader already defined this class, register 'k' for cleanup.\n-        assert(defined_k != NULL, \"Should have a klass if there's no exception\");\n-        loader_data->add_to_deallocate_list(k);\n-        k = defined_k;\n-      } else if (HAS_PENDING_EXCEPTION) {\n-        loader_data->add_to_deallocate_list(k);\n-        return NULL;\n-      }\n+      k = find_or_define_instance_class(class_name, class_loader, k, CHECK_NULL);\n@@ -1616,2 +1579,2 @@\n-  \/\/ Bootstrap and other parallel classloaders don't acquire lock,\n-  \/\/ they use a placeholder token instead.\n+  \/\/ Bootstrap and other parallel classloaders don't acquire a lock,\n+  \/\/ they use placeholder token.\n@@ -1694,2 +1657,2 @@\n-InstanceKlass* SystemDictionary::find_or_define_instance_class(Symbol* class_name, Handle class_loader,\n-                                                               InstanceKlass* k, TRAPS) {\n+InstanceKlass* SystemDictionary::find_or_define_helper(Symbol* class_name, Handle class_loader,\n+                                                       InstanceKlass* k, TRAPS) {\n@@ -1757,13 +1720,1 @@\n-  return k;\n-}\n-\n-\n-\/\/ ----------------------------------------------------------------------------\n-\/\/ Lookup\n-\n-\/\/ Basic find on classes in the midst of being loaded\n-Symbol* SystemDictionary::find_placeholder(Symbol* class_name,\n-                                           ClassLoaderData* loader_data) {\n-  assert_locked_or_safepoint(SystemDictionary_lock);\n-  unsigned int name_hash = placeholders()->compute_hash(class_name);\n-  return placeholders()->find_entry(name_hash, class_name, loader_data);\n+  return HAS_PENDING_EXCEPTION ? NULL : k;\n@@ -1772,17 +1723,15 @@\n-\n-\/\/ Used for assertions and verification only\n-\/\/ Precalculating the hash and index is an optimization because there are many lookups\n-\/\/ before adding the class.\n-InstanceKlass* SystemDictionary::find_class(Symbol* class_name, ClassLoaderData* loader_data) {\n-  assert_locked_or_safepoint(SystemDictionary_lock);\n-  #ifndef ASSERT\n-  guarantee(VerifyBeforeGC      ||\n-            VerifyDuringGC      ||\n-            VerifyBeforeExit    ||\n-            VerifyDuringStartup ||\n-            VerifyAfterGC, \"too expensive\");\n-  #endif\n-\n-  Dictionary* dictionary = loader_data->dictionary();\n-  unsigned int name_hash = dictionary->compute_hash(class_name);\n-  return dictionary->find_class(name_hash, class_name);\n+\/\/ If a class loader supports parallel classloading handle parallel define requests.\n+\/\/ find_or_define_instance_class may return a different InstanceKlass\n+InstanceKlass* SystemDictionary::find_or_define_instance_class(Symbol* class_name, Handle class_loader,\n+                                                               InstanceKlass* k, TRAPS) {\n+  InstanceKlass* defined_k = find_or_define_helper(class_name, class_loader, k, THREAD);\n+  \/\/ Clean up original InstanceKlass if duplicate or error\n+  if (!HAS_PENDING_EXCEPTION && defined_k != k) {\n+    \/\/ If a parallel capable class loader already defined this class, register 'k' for cleanup.\n+    assert(defined_k != NULL, \"Should have a klass if there's no exception\");\n+    k->class_loader_data()->add_to_deallocate_list(k);\n+  } else if (HAS_PENDING_EXCEPTION) {\n+    assert(defined_k == NULL, \"Should not have a klass if there's an exception\");\n+    k->class_loader_data()->add_to_deallocate_list(k);\n+  }\n+  return defined_k;\n@@ -2072,0 +2021,13 @@\n+#ifdef ASSERT\n+\/\/ Verify that this placeholder exists since this class is in the middle of loading.\n+void verify_placeholder(Symbol* class_name, ClassLoaderData* loader_data) {\n+  \/\/ Only parallel capable class loaders use placeholder table for define class.\n+  assert_locked_or_safepoint(SystemDictionary_lock);\n+  unsigned int name_hash = placeholders()->compute_hash(class_name);\n+  Symbol* ph_check =  placeholders()->find_entry(name_hash, class_name, loader_data);\n+  assert(ph_check != NULL, \"This placeholder should exist\");\n+}\n+#endif \/\/ ASSERT\n+\n+\n+\n@@ -2100,2 +2062,0 @@\n-      \/\/ The dictionary only holds instance classes, placeholders\n-      \/\/ also hold array classes.\n@@ -2113,4 +2073,1 @@\n-#ifdef ASSERT\n-    Symbol* ph_check = find_placeholder(name, loader_data);\n-    assert(ph_check == NULL || ph_check == name, \"invalid symbol\");\n-#endif\n+    DEBUG_ONLY(if (is_parallelCapable(class_loader)) verify_placeholder(name, loader_data));\n@@ -2163,6 +2120,0 @@\n-  #ifdef ASSERT\n-    sd_check = dictionary->find_class(hash, name);\n-    assert (sd_check != NULL, \"should have entry in dictionary\");\n-    \/\/ Note: there may be a placeholder entry: for circularity testing\n-    \/\/ or for parallel defines\n-  #endif\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":131,"deletions":180,"binary":false,"changes":311,"status":"modified"},{"patch":"@@ -76,1 +76,0 @@\n-class PlaceholderTable;\n@@ -264,6 +263,3 @@\n-  static Klass* resolve_or_fail(Symbol* class_name, bool throw_error, TRAPS);\n-protected:\n-  \/\/ handle error translation for resolve_or_null results\n-  static Klass* handle_resolution_exception(Symbol* class_name, bool throw_error, Klass* klass, TRAPS);\n-\n-public:\n+  static Klass* resolve_or_fail(Symbol* class_name, bool throw_error, TRAPS) {\n+    return resolve_or_fail(class_name, Handle(), Handle(), throw_error, THREAD);\n+  }\n@@ -275,1 +271,3 @@\n-  static Klass* resolve_or_null(Symbol* class_name, TRAPS);\n+  static Klass* resolve_or_null(Symbol* class_name, TRAPS) {\n+    return resolve_or_null(class_name, Handle(), Handle(), THREAD);\n+  }\n@@ -279,3 +277,3 @@\n-  \/\/ \"child_name\" is the class whose super class or interface is being resolved.\n-  static InstanceKlass* resolve_super_or_fail(Symbol* child_name,\n-                                              Symbol* class_name,\n+  \/\/ \"class_name\" is the class whose super class or interface is being resolved.\n+  static InstanceKlass* resolve_super_or_fail(Symbol* class_name,\n+                                              Symbol* super_name,\n@@ -310,3 +308,3 @@\n-                                               Handle class_loader,\n-                                               Handle protection_domain,\n-                                               TRAPS);\n+                                             Handle class_loader,\n+                                             Handle protection_domain,\n+                                             TRAPS);\n@@ -350,3 +348,0 @@\n-  \/\/ System loader lock\n-  static oop system_loader_lock();\n-\n@@ -356,1 +351,0 @@\n-public:\n@@ -420,0 +414,2 @@\n+\n+private:\n@@ -440,6 +436,0 @@\n-protected:\n-  \/\/ Mirrors for primitive classes (created eagerly)\n-  static oop check_mirror(oop m) {\n-    assert(m != NULL, \"mirror not initialized\");\n-    return m;\n-  }\n@@ -448,5 +438,0 @@\n-  \/\/ Note:  java_lang_Class::primitive_type is the inverse of java_mirror\n-\n-  \/\/ Check class loader constraints\n-  static bool add_loader_constraint(Symbol* name, Klass* klass_being_linked,  Handle loader1,\n-                                    Handle loader2, TRAPS);\n@@ -526,10 +511,1 @@\n- protected:\n-\n-  enum Constants {\n-    _loader_constraint_size = 107,                     \/\/ number of entries in constraint table\n-    _resolution_error_size  = 107,                     \/\/ number of entries in resolution error table\n-    _invoke_method_size     = 139,                     \/\/ number of entries in invoke method table\n-    _placeholder_table_size = 1009                     \/\/ number of entries in hash table for placeholders\n-  };\n-\n-\n+ private:\n@@ -538,3 +514,0 @@\n-  \/\/ Hashtable holding placeholders for classes being loaded.\n-  static PlaceholderTable*       _placeholders;\n-\n@@ -554,0 +527,9 @@\n+  static InstanceKlass* _well_known_klasses[];\n+\n+private:\n+  \/\/ table of box klasses (int_klass, etc.)\n+  static InstanceKlass* _box_klasses[T_VOID+1];\n+\n+  static OopHandle  _java_system_loader;\n+  static OopHandle  _java_platform_loader;\n+\n@@ -559,2 +541,0 @@\n-  friend class TraversePlaceholdersClosure;\n-  static PlaceholderTable*   placeholders() { return _placeholders; }\n@@ -564,1 +544,0 @@\n-  static void post_class_load_event(EventClassLoad* event, const InstanceKlass* k, const ClassLoaderData* init_cld);\n@@ -566,0 +545,1 @@\n+private:\n@@ -571,3 +551,11 @@\n-  static InstanceKlass* resolve_instance_class_or_null(Symbol* class_name, Handle class_loader, Handle protection_domain, TRAPS);\n-  static Klass* resolve_array_class_or_null(Symbol* class_name, Handle class_loader, Handle protection_domain, TRAPS);\n-  static InstanceKlass* handle_parallel_super_load(Symbol* class_name, Symbol* supername, Handle class_loader, Handle protection_domain, Handle lockObject, TRAPS);\n+  static InstanceKlass* resolve_instance_class_or_null(Symbol* class_name,\n+                                                       Handle class_loader,\n+                                                       Handle protection_domain, TRAPS);\n+  static Klass* resolve_array_class_or_null(Symbol* class_name,\n+                                            Handle class_loader,\n+                                            Handle protection_domain, TRAPS);\n+  static InstanceKlass* handle_parallel_super_load(Symbol* class_name,\n+                                                   Symbol* supername,\n+                                                   Handle class_loader,\n+                                                   Handle protection_domain,\n+                                                   Handle lockObject, TRAPS);\n@@ -580,3 +568,8 @@\n-  static InstanceKlass* find_or_define_instance_class(Symbol* class_name,\n-                                                Handle class_loader,\n-                                                InstanceKlass* k, TRAPS);\n+  static InstanceKlass* find_or_define_helper(Symbol* class_name,\n+                                              Handle class_loader,\n+                                              InstanceKlass* k, TRAPS);\n+  static InstanceKlass* load_instance_class(Symbol* class_name, Handle class_loader, TRAPS);\n+  static bool is_parallelDefine(Handle class_loader);\n+  static Handle compute_loader_lock_object(Thread* thread, Handle class_loader);\n+  static void check_loader_lock_contention(Thread* thread, Handle loader_lock);\n+\n@@ -590,1 +583,1 @@\n-  static bool check_shared_class_super_type(InstanceKlass* child, InstanceKlass* super,\n+  static bool check_shared_class_super_type(InstanceKlass* klass, InstanceKlass* super,\n@@ -595,0 +588,8 @@\n+  \/\/ Second part of load_shared_class\n+  static void load_shared_class_misc(InstanceKlass* ik, ClassLoaderData* loader_data, TRAPS) NOT_CDS_RETURN;\n+protected:\n+  \/\/ Used by SystemDictionaryShared\n+\n+  static bool add_loader_constraint(Symbol* name, Klass* klass_being_linked,  Handle loader1,\n+                                    Handle loader2, TRAPS);\n+  static void post_class_load_event(EventClassLoad* event, const InstanceKlass* k, const ClassLoaderData* init_cld);\n@@ -606,2 +607,0 @@\n-  \/\/ Second part of load_shared_class\n-  static void load_shared_class_misc(InstanceKlass* ik, ClassLoaderData* loader_data, TRAPS) NOT_CDS_RETURN;\n@@ -611,2 +610,0 @@\n-  static InstanceKlass* load_instance_class(Symbol* class_name, Handle class_loader, TRAPS);\n-  static Handle compute_loader_lock_object(Thread* thread, Handle class_loader);\n@@ -614,2 +611,3 @@\n-  static bool is_parallelDefine(Handle class_loader);\n-\n+  static InstanceKlass* find_or_define_instance_class(Symbol* class_name,\n+                                                      Handle class_loader,\n+                                                      InstanceKlass* k, TRAPS);\n@@ -617,0 +615,3 @@\n+  \/\/ Set up link to hierarchy\n+  static void add_to_hierarchy(InstanceKlass* k);\n+\n@@ -631,10 +632,1 @@\n-  \/\/ Setup link to hierarchy\n-  static void add_to_hierarchy(InstanceKlass* k);\n-protected:\n-\n-  \/\/ Basic find on loaded classes\n-  static InstanceKlass* find_class(Symbol* class_name, ClassLoaderData* loader_data);\n-\n-  \/\/ Basic find on classes in the midst of being loaded\n-  static Symbol* find_placeholder(Symbol* name, ClassLoaderData* loader_data);\n-\n+private:\n@@ -653,9 +645,0 @@\n-  static InstanceKlass* _well_known_klasses[];\n-\n-  \/\/ table of box klasses (int_klass, etc.)\n-  static InstanceKlass* _box_klasses[T_VOID+1];\n-\n-private:\n-  static OopHandle  _java_system_loader;\n-  static OopHandle  _java_platform_loader;\n-\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.hpp","additions":60,"deletions":77,"binary":false,"changes":137,"status":"modified"},{"patch":"@@ -1049,1 +1049,1 @@\n-        define_instance_class(k, class_loader, CHECK_NULL);\n+        k = find_or_define_instance_class(name, class_loader, k, CHECK_NULL);\n@@ -1214,1 +1214,1 @@\n-\/\/ non-built-in loaders. E.g., ChildClass in the below example\n+\/\/ non-built-in loaders. E.g., SharedClass in the below example\n@@ -1219,1 +1219,1 @@\n-\/\/ ChildClass  id: 4 super: 0 interfaces: 2 source: cust.jar\n+\/\/ SharedClass  id: 4 super: 0 interfaces: 2 source: cust.jar\n@@ -1221,1 +1221,1 @@\n-    Symbol* child_name, Symbol* class_name, Handle class_loader,\n+    Symbol* class_name, Symbol* super_name, Handle class_loader,\n@@ -1231,1 +1231,1 @@\n-  if (child_name->equals(parser->current_class_name())) {\n+  if (class_name->equals(parser->current_class_name())) {\n@@ -1235,1 +1235,1 @@\n-      return parser->lookup_super_for_current_class(class_name);\n+      return parser->lookup_super_for_current_class(super_name);\n@@ -1237,1 +1237,1 @@\n-      return parser->lookup_interface_for_current_class(class_name);\n+      return parser->lookup_interface_for_current_class(super_name);\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -249,2 +249,2 @@\n-  static InstanceKlass* dump_time_resolve_super_or_fail(Symbol* child_name,\n-                                                Symbol* class_name,\n+  static InstanceKlass* dump_time_resolve_super_or_fail(Symbol* class_name,\n+                                                Symbol* super_name,\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -727,2 +727,0 @@\n-  guarantee(SystemDictionary::placeholders()->number_of_entries() == 0,\n-          \"placeholders are not saved\");\n","filename":"src\/hotspot\/share\/memory\/metaspaceShared.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"}]}