{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -969,1 +969,1 @@\n-        \/\/ Call resolve_super so classcircularity is checked\n+        \/\/ Call resolve_super so class circularity is checked\n@@ -6209,1 +6209,1 @@\n-  if (_super_class_index > 0 && NULL ==_super_klass) {\n+  if (_super_class_index > 0 && NULL == _super_klass) {\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -91,1 +91,0 @@\n-PlaceholderTable*      SystemDictionary::_placeholders        = NULL;\n@@ -106,1 +105,0 @@\n-\n@@ -109,0 +107,9 @@\n+const int _loader_constraint_size = 107;                     \/\/ number of entries in constraint table\n+const int _resolution_error_size  = 107;                     \/\/ number of entries in resolution error table\n+const int _invoke_method_size     = 139;                     \/\/ number of entries in invoke method table\n+\n+\/\/ Hashtable holding placeholders for classes being loaded.\n+const int _placeholder_table_size = 1009;\n+PlaceholderTable* _placeholders   = NULL;\n+static PlaceholderTable*   placeholders() { return _placeholders; }\n+\n@@ -219,9 +226,10 @@\n-\/\/ Forwards to resolve_or_null\n-\n-Klass* SystemDictionary::resolve_or_fail(Symbol* class_name, Handle class_loader, Handle protection_domain, bool throw_error, TRAPS) {\n-  Klass* klass = resolve_or_null(class_name, class_loader, protection_domain, THREAD);\n-  if (HAS_PENDING_EXCEPTION || klass == NULL) {\n-    \/\/ can return a null klass\n-    klass = handle_resolution_exception(class_name, throw_error, klass, THREAD);\n-  }\n-  return klass;\n+#ifdef ASSERT\n+\/\/ Used to verify that class loading succeeded in adding k to the dictionary.\n+void verify_dictionary_entry(Symbol* class_name, InstanceKlass* k) {\n+  MutexLocker mu(SystemDictionary_lock);\n+  ClassLoaderData* loader_data = k->class_loader_data();\n+  Dictionary* dictionary = loader_data->dictionary();\n+  assert(class_name == k->name(), \"Must be the same\");\n+  unsigned int name_hash = dictionary->compute_hash(class_name);\n+  InstanceKlass* kk = dictionary->find_class(name_hash, class_name);\n+  assert(kk == k, \"should be present in dictionary\");\n@@ -229,0 +237,1 @@\n+#endif\n@@ -230,3 +239,1 @@\n-Klass* SystemDictionary::handle_resolution_exception(Symbol* class_name,\n-                                                     bool throw_error,\n-                                                     Klass* klass, TRAPS) {\n+static Klass* handle_resolution_exception(Symbol* class_name, bool throw_error, Klass* klass, TRAPS) {\n@@ -234,0 +241,1 @@\n+    assert(klass == NULL, \"Should not have result with exception pending\");\n@@ -240,1 +248,0 @@\n-      assert(klass == NULL, \"Should not have result with exception pending\");\n@@ -260,0 +267,1 @@\n+\/\/ Forwards to resolve_or_null\n@@ -261,4 +269,5 @@\n-Klass* SystemDictionary::resolve_or_fail(Symbol* class_name,\n-                                           bool throw_error, TRAPS)\n-{\n-  return resolve_or_fail(class_name, Handle(), Handle(), throw_error, THREAD);\n+Klass* SystemDictionary::resolve_or_fail(Symbol* class_name, Handle class_loader, Handle protection_domain,\n+                                         bool throw_error, TRAPS) {\n+  Klass* klass = resolve_or_null(class_name, class_loader, protection_domain, THREAD);\n+  \/\/ Check for pending exception or null klass, and throw exception\n+  return handle_resolution_exception(class_name, throw_error, klass, THREAD);\n@@ -267,1 +276,0 @@\n-\n@@ -295,4 +303,0 @@\n-Klass* SystemDictionary::resolve_or_null(Symbol* class_name, TRAPS) {\n-  return resolve_or_null(class_name, Handle(), Handle(), THREAD);\n-}\n-\n@@ -331,1 +335,1 @@\n-\/\/    parse_interfaces - for defineClass & jvmtiRedefineClasses\n+\/\/    parse_interfaces - for defineClass\n@@ -333,1 +337,1 @@\n-\/\/   ClassFileParser - for defineClass & jvmtiRedefineClasses\n+\/\/   ClassFileParser - for defineClass\n@@ -360,3 +364,0 @@\n-\/\/ Must be called, even if superclass is null, since this is\n-\/\/ where the placeholder entry is created which claims this\n-\/\/ thread is loading this class\/classloader.\n@@ -366,2 +367,2 @@\n-\/\/ So be careful to not exit with a CHECK_ macro betweeen these calls.\n-InstanceKlass* SystemDictionary::resolve_super_or_fail(Symbol* child_name,\n+\/\/ So be careful to not exit with a CHECK_ macro between these calls.\n+InstanceKlass* SystemDictionary::resolve_super_or_fail(Symbol* class_name,\n@@ -377,1 +378,1 @@\n-    InstanceKlass* k = SystemDictionaryShared::dump_time_resolve_super_or_fail(child_name,\n+    InstanceKlass* k = SystemDictionaryShared::dump_time_resolve_super_or_fail(class_name,\n@@ -385,1 +386,1 @@\n-  \/\/ Double-check, if child class is already loaded, just return super-class,interface\n+  \/\/ Double-check, if klass is already loaded, just return super-class,interface\n@@ -388,1 +389,1 @@\n-  \/\/ Make sure there's a placeholder for the *child* before resolving.\n+  \/\/ Make sure there's a placeholder for the *klass* before resolving.\n@@ -394,1 +395,1 @@\n-  \/\/ We might not already have a placeholder if this child_name was\n+  \/\/ We might not already have a placeholder if this class_name was\n@@ -402,2 +403,2 @@\n-  unsigned int name_hash = dictionary->compute_hash(child_name);\n-  assert(placeholders()->compute_hash(child_name) == name_hash, \"they're the same hashcode\");\n+  unsigned int name_hash = dictionary->compute_hash(class_name);\n+  assert(placeholders()->compute_hash(class_name) == name_hash, \"they're the same hashcode\");\n@@ -408,1 +409,1 @@\n-    InstanceKlass* childk = dictionary->find_class(name_hash, child_name);\n+    InstanceKlass* klassk = dictionary->find_class(name_hash, class_name);\n@@ -410,1 +411,1 @@\n-    \/\/ to support \/\/ loading: if child done loading, just return superclass\n+    \/\/ to support \/\/ loading: if klass done loading, just return superclass\n@@ -416,2 +417,2 @@\n-    if ((childk != NULL ) && (is_superclass) &&\n-        ((quicksuperk = childk->java_super()) != NULL) &&\n+    if ((klassk != NULL ) && (is_superclass) &&\n+        ((quicksuperk = klassk->java_super()) != NULL) &&\n@@ -422,1 +423,1 @@\n-      PlaceholderEntry* probe = placeholders()->get_entry(name_hash, child_name, loader_data);\n+      PlaceholderEntry* probe = placeholders()->get_entry(name_hash, class_name, loader_data);\n@@ -429,1 +430,1 @@\n-      PlaceholderEntry* newprobe = placeholders()->find_and_add(name_hash, child_name, loader_data, PlaceholderTable::LOAD_SUPER, super_name, THREAD);\n+      PlaceholderEntry* newprobe = placeholders()->find_and_add(name_hash, class_name, loader_data, PlaceholderTable::LOAD_SUPER, super_name, THREAD);\n@@ -434,1 +435,1 @@\n-      THROW_MSG_NULL(vmSymbols::java_lang_ClassCircularityError(), child_name->as_C_string());\n+      THROW_MSG_NULL(vmSymbols::java_lang_ClassCircularityError(), class_name->as_C_string());\n@@ -454,1 +455,1 @@\n-    placeholders()->find_and_remove(name_hash, child_name, loader_data, PlaceholderTable::LOAD_SUPER, THREAD);\n+    placeholders()->find_and_remove(name_hash, class_name, loader_data, PlaceholderTable::LOAD_SUPER, THREAD);\n@@ -457,8 +458,0 @@\n-  if (HAS_PENDING_EXCEPTION || superk == NULL) {\n-    \/\/ can null superk\n-    Klass* k = handle_resolution_exception(super_name, true, superk, THREAD);\n-    assert(k == NULL || k == superk, \"must be\");\n-    if (k == NULL) {\n-      superk = NULL;\n-    }\n-  }\n@@ -466,1 +459,4 @@\n-  return superk;\n+  \/\/ Check for pending exception or null superk, and throw exception\n+  \/\/ If no exception, this returns the original InstanceKlass.\n+  Klass* k = handle_resolution_exception(super_name, true, superk, THREAD);\n+  return (k != NULL) ? superk : NULL;\n@@ -904,8 +900,3 @@\n-#ifdef ASSERT\n-  {\n-    ClassLoaderData* loader_data = loaded_class->class_loader_data();\n-    MutexLocker mu(THREAD, SystemDictionary_lock);\n-    InstanceKlass* kk = find_class(name, loader_data);\n-    assert(kk == loaded_class, \"should be present in dictionary\");\n-  }\n-#endif\n+\n+  \/\/ Make sure we have the right class in the dictionary\n+  DEBUG_ONLY(verify_dictionary_entry(name, loaded_class));\n@@ -1126,1 +1117,2 @@\n-  \/\/ find_or_define_instance_class may return a different InstanceKlass\n+  \/\/ find_or_define_instance_class may return a different InstanceKlass,\n+  \/\/ in which case the old k would be deallocated\n@@ -1128,7 +1120,1 @@\n-    InstanceKlass* defined_k = find_or_define_instance_class(h_name, class_loader, k, THREAD);\n-    if (!HAS_PENDING_EXCEPTION && defined_k != k) {\n-      \/\/ If a parallel capable class loader already defined this class, register 'k' for cleanup.\n-      assert(defined_k != NULL, \"Should have a klass if there's no exception\");\n-      loader_data->add_to_deallocate_list(k);\n-      k = defined_k;\n-    }\n+    k = find_or_define_instance_class(h_name, class_loader, k, CHECK_NULL);\n@@ -1137,1 +1123,0 @@\n-  }\n@@ -1139,5 +1124,6 @@\n-  \/\/ If defining the class throws an exception register 'k' for cleanup.\n-  if (HAS_PENDING_EXCEPTION) {\n-    assert(k != NULL, \"Must have an instance klass here!\");\n-    loader_data->add_to_deallocate_list(k);\n-    return NULL;\n+    \/\/ If defining the class throws an exception register 'k' for cleanup.\n+    if (HAS_PENDING_EXCEPTION) {\n+      assert(k != NULL, \"Must have an instance klass here!\");\n+      loader_data->add_to_deallocate_list(k);\n+      return NULL;\n+    }\n@@ -1147,6 +1133,1 @@\n-  debug_only( {\n-    MutexLocker mu(THREAD, SystemDictionary_lock);\n-\n-    Klass* check = find_class(h_name, k->class_loader_data());\n-    assert(check == k, \"should be present in the dictionary\");\n-  } );\n+  DEBUG_ONLY(verify_dictionary_entry(h_name, k));\n@@ -1259,1 +1240,1 @@\n-bool SystemDictionary::check_shared_class_super_type(InstanceKlass* child, InstanceKlass* super_type,\n+bool SystemDictionary::check_shared_class_super_type(InstanceKlass* klass, InstanceKlass* super_type,\n@@ -1264,1 +1245,1 @@\n-  Klass *found = resolve_super_or_fail(child->name(), super_type->name(),\n+  Klass *found = resolve_super_or_fail(klass->name(), super_type->name(),\n@@ -1270,1 +1251,1 @@\n-    \/\/ so we cannot use the child class.\n+    \/\/ so we cannot use the class.\n@@ -1537,11 +1518,1 @@\n-      InstanceKlass* defined_k =\n-        find_or_define_instance_class(class_name, class_loader, k, THREAD);\n-      if (!HAS_PENDING_EXCEPTION && defined_k != k) {\n-        \/\/ If a parallel capable class loader already defined this class, register 'k' for cleanup.\n-        assert(defined_k != NULL, \"Should have a klass if there's no exception\");\n-        loader_data->add_to_deallocate_list(k);\n-        k = defined_k;\n-      } else if (HAS_PENDING_EXCEPTION) {\n-        loader_data->add_to_deallocate_list(k);\n-        return NULL;\n-      }\n+      k = find_or_define_instance_class(class_name, class_loader, k, CHECK_NULL);\n@@ -1616,2 +1587,2 @@\n-  \/\/ Bootstrap and other parallel classloaders don't acquire lock,\n-  \/\/ they use a placeholder token instead.\n+  \/\/ Bootstrap and other parallel classloaders don't acquire a lock,\n+  \/\/ they use placeholder token.\n@@ -1694,2 +1665,2 @@\n-InstanceKlass* SystemDictionary::find_or_define_instance_class(Symbol* class_name, Handle class_loader,\n-                                                               InstanceKlass* k, TRAPS) {\n+InstanceKlass* SystemDictionary::find_or_define_helper(Symbol* class_name, Handle class_loader,\n+                                                       InstanceKlass* k, TRAPS) {\n@@ -1757,1 +1728,1 @@\n-  return k;\n+  return HAS_PENDING_EXCEPTION ? NULL : k;\n@@ -1760,29 +1731,15 @@\n-\n-\/\/ ----------------------------------------------------------------------------\n-\/\/ Lookup\n-\n-\/\/ Basic find on classes in the midst of being loaded\n-Symbol* SystemDictionary::find_placeholder(Symbol* class_name,\n-                                           ClassLoaderData* loader_data) {\n-  assert_locked_or_safepoint(SystemDictionary_lock);\n-  unsigned int name_hash = placeholders()->compute_hash(class_name);\n-  return placeholders()->find_entry(name_hash, class_name, loader_data);\n-}\n-\n-\n-\/\/ Used for assertions and verification only\n-\/\/ Precalculating the hash and index is an optimization because there are many lookups\n-\/\/ before adding the class.\n-InstanceKlass* SystemDictionary::find_class(Symbol* class_name, ClassLoaderData* loader_data) {\n-  assert_locked_or_safepoint(SystemDictionary_lock);\n-  #ifndef ASSERT\n-  guarantee(VerifyBeforeGC      ||\n-            VerifyDuringGC      ||\n-            VerifyBeforeExit    ||\n-            VerifyDuringStartup ||\n-            VerifyAfterGC, \"too expensive\");\n-  #endif\n-\n-  Dictionary* dictionary = loader_data->dictionary();\n-  unsigned int name_hash = dictionary->compute_hash(class_name);\n-  return dictionary->find_class(name_hash, class_name);\n+\/\/ If a class loader supports parallel classloading handle parallel define requests.\n+\/\/ find_or_define_instance_class may return a different InstanceKlass\n+InstanceKlass* SystemDictionary::find_or_define_instance_class(Symbol* class_name, Handle class_loader,\n+                                                               InstanceKlass* k, TRAPS) {\n+  InstanceKlass* defined_k = find_or_define_helper(class_name, class_loader, k, THREAD);\n+  \/\/ Clean up original InstanceKlass if duplicate or error\n+  if (!HAS_PENDING_EXCEPTION && defined_k != k) {\n+    \/\/ If a parallel capable class loader already defined this class, register 'k' for cleanup.\n+    assert(defined_k != NULL, \"Should have a klass if there's no exception\");\n+    k->class_loader_data()->add_to_deallocate_list(k);\n+  } else if (HAS_PENDING_EXCEPTION) {\n+    assert(defined_k == NULL, \"Should not have a klass if there's an exception\");\n+    k->class_loader_data()->add_to_deallocate_list(k);\n+  }\n+  return defined_k;\n@@ -2072,0 +2029,15 @@\n+#ifdef ASSERT\n+\/\/ Verify that this placeholder exists since this class is in the middle of loading.\n+void verify_placeholder(Symbol* class_name, ClassLoaderData* loader_data, bool is_parallel_capable) {\n+  \/\/ Only parallel capable class loaders use placeholder table for define class (bizarre)\n+  if (is_parallel_capable) {\n+    assert_locked_or_safepoint(SystemDictionary_lock);\n+    unsigned int name_hash = placeholders()->compute_hash(class_name);\n+    Symbol* ph_check =  placeholders()->find_entry(name_hash, class_name, loader_data);\n+    assert(ph_check != NULL, \"This placeholder should exist\");\n+  }\n+}\n+#endif \/\/ ASSERT\n+\n+\n+\n@@ -2100,2 +2072,0 @@\n-      \/\/ The dictionary only holds instance classes, placeholders\n-      \/\/ also hold array classes.\n@@ -2113,4 +2083,1 @@\n-#ifdef ASSERT\n-    Symbol* ph_check = find_placeholder(name, loader_data);\n-    assert(ph_check == NULL || ph_check == name, \"invalid symbol\");\n-#endif\n+    DEBUG_ONLY(verify_placeholder(name, loader_data, is_parallelCapable(class_loader)));\n@@ -2163,6 +2130,0 @@\n-  #ifdef ASSERT\n-    sd_check = dictionary->find_class(hash, name);\n-    assert (sd_check != NULL, \"should have entry in dictionary\");\n-    \/\/ Note: there may be a placeholder entry: for circularity testing\n-    \/\/ or for parallel defines\n-  #endif\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":103,"deletions":142,"binary":false,"changes":245,"status":"modified"},{"patch":"@@ -76,1 +76,0 @@\n-class PlaceholderTable;\n@@ -264,6 +263,3 @@\n-  static Klass* resolve_or_fail(Symbol* class_name, bool throw_error, TRAPS);\n-protected:\n-  \/\/ handle error translation for resolve_or_null results\n-  static Klass* handle_resolution_exception(Symbol* class_name, bool throw_error, Klass* klass, TRAPS);\n-\n-public:\n+  static Klass* resolve_or_fail(Symbol* class_name, bool throw_error, TRAPS) {\n+    return resolve_or_fail(class_name, Handle(), Handle(), throw_error, THREAD);\n+  }\n@@ -275,1 +271,3 @@\n-  static Klass* resolve_or_null(Symbol* class_name, TRAPS);\n+  static Klass* resolve_or_null(Symbol* class_name, TRAPS) {\n+    return resolve_or_null(class_name, Handle(), Handle(), THREAD);\n+  }\n@@ -279,3 +277,3 @@\n-  \/\/ \"child_name\" is the class whose super class or interface is being resolved.\n-  static InstanceKlass* resolve_super_or_fail(Symbol* child_name,\n-                                              Symbol* class_name,\n+  \/\/ \"class_name\" is the class whose super class or interface is being resolved.\n+  static InstanceKlass* resolve_super_or_fail(Symbol* class_name,\n+                                              Symbol* super_name,\n@@ -310,3 +308,3 @@\n-                                               Handle class_loader,\n-                                               Handle protection_domain,\n-                                               TRAPS);\n+                                             Handle class_loader,\n+                                             Handle protection_domain,\n+                                             TRAPS);\n@@ -350,3 +348,0 @@\n-  \/\/ System loader lock\n-  static oop system_loader_lock();\n-\n@@ -356,1 +351,0 @@\n-public:\n@@ -420,0 +414,2 @@\n+\n+private:\n@@ -440,6 +436,0 @@\n-protected:\n-  \/\/ Mirrors for primitive classes (created eagerly)\n-  static oop check_mirror(oop m) {\n-    assert(m != NULL, \"mirror not initialized\");\n-    return m;\n-  }\n@@ -448,5 +438,0 @@\n-  \/\/ Note:  java_lang_Class::primitive_type is the inverse of java_mirror\n-\n-  \/\/ Check class loader constraints\n-  static bool add_loader_constraint(Symbol* name, Klass* klass_being_linked,  Handle loader1,\n-                                    Handle loader2, TRAPS);\n@@ -526,10 +511,1 @@\n- protected:\n-\n-  enum Constants {\n-    _loader_constraint_size = 107,                     \/\/ number of entries in constraint table\n-    _resolution_error_size  = 107,                     \/\/ number of entries in resolution error table\n-    _invoke_method_size     = 139,                     \/\/ number of entries in invoke method table\n-    _placeholder_table_size = 1009                     \/\/ number of entries in hash table for placeholders\n-  };\n-\n-\n+ private:\n@@ -538,3 +514,0 @@\n-  \/\/ Hashtable holding placeholders for classes being loaded.\n-  static PlaceholderTable*       _placeholders;\n-\n@@ -554,0 +527,9 @@\n+  static InstanceKlass* _well_known_klasses[];\n+\n+private:\n+  \/\/ table of box klasses (int_klass, etc.)\n+  static InstanceKlass* _box_klasses[T_VOID+1];\n+\n+  static OopHandle  _java_system_loader;\n+  static OopHandle  _java_platform_loader;\n+\n@@ -559,2 +541,0 @@\n-  friend class TraversePlaceholdersClosure;\n-  static PlaceholderTable*   placeholders() { return _placeholders; }\n@@ -564,1 +544,0 @@\n-  static void post_class_load_event(EventClassLoad* event, const InstanceKlass* k, const ClassLoaderData* init_cld);\n@@ -566,0 +545,1 @@\n+private:\n@@ -571,3 +551,11 @@\n-  static InstanceKlass* resolve_instance_class_or_null(Symbol* class_name, Handle class_loader, Handle protection_domain, TRAPS);\n-  static Klass* resolve_array_class_or_null(Symbol* class_name, Handle class_loader, Handle protection_domain, TRAPS);\n-  static InstanceKlass* handle_parallel_super_load(Symbol* class_name, Symbol* supername, Handle class_loader, Handle protection_domain, Handle lockObject, TRAPS);\n+  static InstanceKlass* resolve_instance_class_or_null(Symbol* class_name,\n+                                                       Handle class_loader,\n+                                                       Handle protection_domain, TRAPS);\n+  static Klass* resolve_array_class_or_null(Symbol* class_name,\n+                                            Handle class_loader,\n+                                            Handle protection_domain, TRAPS);\n+  static InstanceKlass* handle_parallel_super_load(Symbol* class_name,\n+                                                   Symbol* supername,\n+                                                   Handle class_loader,\n+                                                   Handle protection_domain,\n+                                                   Handle lockObject, TRAPS);\n@@ -580,3 +568,8 @@\n-  static InstanceKlass* find_or_define_instance_class(Symbol* class_name,\n-                                                Handle class_loader,\n-                                                InstanceKlass* k, TRAPS);\n+  static InstanceKlass* find_or_define_helper(Symbol* class_name,\n+                                              Handle class_loader,\n+                                              InstanceKlass* k, TRAPS);\n+  static InstanceKlass* load_instance_class(Symbol* class_name, Handle class_loader, TRAPS);\n+  static bool is_parallelDefine(Handle class_loader);\n+  static Handle compute_loader_lock_object(Thread* thread, Handle class_loader);\n+  static void check_loader_lock_contention(Thread* thread, Handle loader_lock);\n+\n@@ -590,1 +583,1 @@\n-  static bool check_shared_class_super_type(InstanceKlass* child, InstanceKlass* super,\n+  static bool check_shared_class_super_type(InstanceKlass* klass, InstanceKlass* super,\n@@ -595,0 +588,8 @@\n+  \/\/ Second part of load_shared_class\n+  static void load_shared_class_misc(InstanceKlass* ik, ClassLoaderData* loader_data, TRAPS) NOT_CDS_RETURN;\n+protected:\n+  \/\/ Used by SystemDictionaryShared\n+\n+  static bool add_loader_constraint(Symbol* name, Klass* klass_being_linked,  Handle loader1,\n+                                    Handle loader2, TRAPS);\n+  static void post_class_load_event(EventClassLoad* event, const InstanceKlass* k, const ClassLoaderData* init_cld);\n@@ -606,2 +607,0 @@\n-  \/\/ Second part of load_shared_class\n-  static void load_shared_class_misc(InstanceKlass* ik, ClassLoaderData* loader_data, TRAPS) NOT_CDS_RETURN;\n@@ -611,2 +610,0 @@\n-  static InstanceKlass* load_instance_class(Symbol* class_name, Handle class_loader, TRAPS);\n-  static Handle compute_loader_lock_object(Thread* thread, Handle class_loader);\n@@ -614,2 +611,3 @@\n-  static bool is_parallelDefine(Handle class_loader);\n-\n+  static InstanceKlass* find_or_define_instance_class(Symbol* class_name,\n+                                                      Handle class_loader,\n+                                                      InstanceKlass* k, TRAPS);\n@@ -617,0 +615,3 @@\n+  \/\/ Set up link to hierarchy\n+  static void add_to_hierarchy(InstanceKlass* k);\n+\n@@ -631,10 +632,1 @@\n-  \/\/ Setup link to hierarchy\n-  static void add_to_hierarchy(InstanceKlass* k);\n-protected:\n-\n-  \/\/ Basic find on loaded classes\n-  static InstanceKlass* find_class(Symbol* class_name, ClassLoaderData* loader_data);\n-\n-  \/\/ Basic find on classes in the midst of being loaded\n-  static Symbol* find_placeholder(Symbol* name, ClassLoaderData* loader_data);\n-\n+private:\n@@ -653,9 +645,0 @@\n-  static InstanceKlass* _well_known_klasses[];\n-\n-  \/\/ table of box klasses (int_klass, etc.)\n-  static InstanceKlass* _box_klasses[T_VOID+1];\n-\n-private:\n-  static OopHandle  _java_system_loader;\n-  static OopHandle  _java_platform_loader;\n-\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.hpp","additions":60,"deletions":77,"binary":false,"changes":137,"status":"modified"},{"patch":"@@ -1049,1 +1049,1 @@\n-        define_instance_class(k, class_loader, CHECK_NULL);\n+        k = find_or_define_instance_class(name, class_loader, k, CHECK_NULL);\n@@ -1214,1 +1214,1 @@\n-\/\/ non-built-in loaders. E.g., ChildClass in the below example\n+\/\/ non-built-in loaders. E.g., SharedClass in the below example\n@@ -1219,1 +1219,1 @@\n-\/\/ ChildClass  id: 4 super: 0 interfaces: 2 source: cust.jar\n+\/\/ SharedClass  id: 4 super: 0 interfaces: 2 source: cust.jar\n@@ -1221,1 +1221,1 @@\n-    Symbol* child_name, Symbol* class_name, Handle class_loader,\n+    Symbol* class_name, Symbol* super_name, Handle class_loader,\n@@ -1231,1 +1231,1 @@\n-  if (child_name->equals(parser->current_class_name())) {\n+  if (class_name->equals(parser->current_class_name())) {\n@@ -1235,1 +1235,1 @@\n-      return parser->lookup_super_for_current_class(class_name);\n+      return parser->lookup_super_for_current_class(super_name);\n@@ -1237,1 +1237,1 @@\n-      return parser->lookup_interface_for_current_class(class_name);\n+      return parser->lookup_interface_for_current_class(super_name);\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -249,2 +249,2 @@\n-  static InstanceKlass* dump_time_resolve_super_or_fail(Symbol* child_name,\n-                                                Symbol* class_name,\n+  static InstanceKlass* dump_time_resolve_super_or_fail(Symbol* class_name,\n+                                                Symbol* super_name,\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -727,2 +727,0 @@\n-  guarantee(SystemDictionary::placeholders()->number_of_entries() == 0,\n-          \"placeholders are not saved\");\n","filename":"src\/hotspot\/share\/memory\/metaspaceShared.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"}]}