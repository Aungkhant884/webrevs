{"files":[{"patch":"@@ -36,0 +36,1 @@\n+#include \"utilities\/pair.hpp\"\n@@ -1098,12 +1099,1 @@\n-\/\/=============================================================================\n-\/\/------------------------------add_ring---------------------------------------\n-\/\/ Supplied function returns the sum of the inputs.\n-const Type *MaxINode::add_ring( const Type *t0, const Type *t1 ) const {\n-  const TypeInt *r0 = t0->is_int(); \/\/ Handy access\n-  const TypeInt *r1 = t1->is_int();\n-\n-  \/\/ Otherwise just MAX them bits.\n-  return TypeInt::make( MAX2(r0->_lo,r1->_lo), MAX2(r0->_hi,r1->_hi), MAX2(r0->_widen,r1->_widen) );\n-}\n-\n-\/\/ Check if addition of an integer with type 't' and a constant 'c' can overflow\n+\/\/ Check if addition of an integer with type 't' and a constant 'c' can overflow.\n@@ -1117,19 +1107,4 @@\n-\/\/ Return:\n-\/\/ <x, C>,       if n is of the form x + C, where 'C' is a non-TOP constant;\n-\/\/ <nullptr, _>, if n is of the form x + C, where 'C' is a TOP constant;\n-\/\/ <n, con>      otherwise.\n-static Node* constant_add_input(Node* n, jint* con) {\n-  if (n->Opcode() == Op_AddI && n->in(2)->is_Con()) {\n-    const Type* t = n->in(2)->bottom_type();\n-    if (t == Type::TOP) {\n-      return nullptr;\n-    }\n-    *con = t->is_int()->get_con();\n-    n = n->in(1);\n-  }\n-  return n;\n-}\n-\n-\/\/ Transform opcode(x + x_off, y + y_off) into x + opcode(x_off, y_off), where\n-\/\/ opcode is either MinI or MaxI, if x == y and the additions can't overflow.\n-static Node* extract_addition(PhaseGVN* phase, Node* x, jint x_off, Node* y, jint y_off, int opcode) {\n+\/\/ If x == y and neither add(x, x_off) nor add(y, y_off) overflow, return\n+\/\/ add(x, op(x_off, y_off)). Otherwise, return nullptr.\n+Node* MaxNode::extract_add(PhaseGVN* phase, Node* x, jint x_off, Node* y, jint y_off) {\n+  int opcode = Opcode();\n@@ -1147,1 +1122,23 @@\n-Node* MaxNode::IdealI(PhaseGVN* phase, bool can_reshape, int opcode) {\n+typedef const Pair<Node*, jint> ConstAddOperands;\n+\n+\/\/ If n is an integer addition of x with a non-TOP constant C, return <x, C>.\n+\/\/ Otherwise, return <nullptr, 0>.\n+static ConstAddOperands as_add_with_constant(Node* n) {\n+  ConstAddOperands null(nullptr, 0);\n+  if (n->Opcode() != Op_AddI) {\n+    return null;\n+  }\n+  Node* x = n->in(1);\n+  Node* c = n->in(2);\n+  if (!c->is_Con()) {\n+    return null;\n+  }\n+  const Type* c_type = c->bottom_type();\n+  if (c_type == Type::TOP) {\n+    return null;\n+  }\n+  return ConstAddOperands(x, c_type->is_int()->get_con());\n+}\n+\n+Node* MaxNode::IdealI(PhaseGVN* phase, bool can_reshape) {\n+  int opcode = Opcode();\n@@ -1149,15 +1146,15 @@\n-  Node* l = in(1);\n-  Node* r = in(2);\n-  jint x_off = 0;\n-  Node* x = constant_add_input(l, &x_off);\n-  if (x == nullptr) return nullptr;\n-  jint y_off = 0;\n-  Node* y = constant_add_input(r, &y_off);\n-  if (y == nullptr) return nullptr;\n-  \/\/ Try to transform opcode(x + x_off, opcode(y + y_off, z)) (in any of its\n-  \/\/ four possible permutations given by opcode's commutativity) into\n-  \/\/ opcode(x + opcode(x_off, y_off), z), where opcode is either MinI or MaxI,\n-  \/\/ if x == y and the additions can't overflow.\n-  for (uint outer_input = 1; outer_input <= 2; outer_input++) {\n-    Node* n = in(outer_input); \/\/ Inner opcode operation (opcode(y + y_off, z)).\n-    if (n->Opcode() != opcode) {\n+  \/\/ Defer handling of op(x, x) to constant\/identity propagation.\n+  if (in(1) == in(2)) {\n+    return nullptr;\n+  }\n+  \/\/ Try to transform the following pattern, in any of its four possible\n+  \/\/ permutations induced by op's commutativity:\n+  \/\/     op(op(add(inner, inner_off), inner_other), add(outer, outer_off))\n+  \/\/ into\n+  \/\/     op(add(inner, op(inner_off, outer_off)), inner_other),\n+  \/\/ where:\n+  \/\/     op is either MinI or MaxI, and\n+  \/\/     inner == outer, and\n+  \/\/     the additions cannot overflow.\n+  for (uint inner_op_index = 1; inner_op_index <= 2; inner_op_index++) {\n+    if (in(inner_op_index)->Opcode() != opcode) {\n@@ -1166,13 +1163,15 @@\n-    for (uint inner_input = 1; inner_input <= 2; inner_input++) {\n-      Node* inner_add = n->in(inner_input);      \/\/ Addition within inner opcode (y + y_off).\n-      Node* z = n->in(inner_input == 1 ? 2 : 1); \/\/ Opposite operand.\n-      if (outer_input == 1) { \/\/ Update x from left inner add.\n-        x = constant_add_input(inner_add, &x_off);\n-        if (x == nullptr) {\n-          return nullptr;\n-        }\n-      } else {                \/\/ Update y from right inner add.\n-        y = constant_add_input(inner_add, &y_off);\n-        if (y == nullptr) {\n-          return nullptr;\n-        }\n+    Node* outer_add = in(inner_op_index == 1 ? 2 : 1);\n+    ConstAddOperands outer_add_operands = as_add_with_constant(outer_add);\n+    if (outer_add_operands.first == nullptr) {\n+      continue;\n+    }\n+    Node* outer = outer_add_operands.first;\n+    jint outer_off = outer_add_operands.second;\n+    \/\/ One operand is a MinI\/MaxI and the other is an integer addition with\n+    \/\/ constant. Test the operands of the inner MinI\/MaxI.\n+    for (uint inner_add_index = 1; inner_add_index <= 2; inner_add_index++) {\n+      Node* inner_op = in(inner_op_index);\n+      Node* inner_add = inner_op->in(inner_add_index);\n+      ConstAddOperands inner_add_operands = as_add_with_constant(inner_add);\n+      if (inner_add_operands.first == nullptr) {\n+        continue;\n@@ -1180,4 +1179,5 @@\n-      \/\/ We have collected x, x_off, y, y_off, and z. Try to extract the inner\n-      \/\/ addition if x == y and the additions can't overflow.\n-      Node* result = extract_addition(phase, x, x_off, y, y_off, opcode);\n-      if (result == nullptr) {\n+      Node* inner = inner_add_operands.first;\n+      jint inner_off = inner_add_operands.second;\n+      \/\/ Try to extract the inner add.\n+      Node* add_extracted = extract_add(phase, inner, inner_off, outer, outer_off);\n+      if (add_extracted == nullptr) {\n@@ -1186,1 +1186,2 @@\n-      Node* transformed = phase->transform(result);\n+      Node* add_transformed = phase->transform(add_extracted);\n+      Node* inner_other = inner_op->in(inner_add_index == 1 ? 2 : 1);\n@@ -1188,1 +1189,1 @@\n-        return new MinINode(transformed, z);\n+        return new MinINode(add_transformed, inner_other);\n@@ -1190,1 +1191,1 @@\n-        return new MaxINode(transformed, z);\n+        return new MaxINode(add_transformed, inner_other);\n@@ -1194,2 +1195,20 @@\n-  \/\/ Try to transform opcode(x + x_off, y + y_off) into x + opcode(x_off, y_off).\n-  return extract_addition(phase, x, x_off, y, y_off, opcode);\n+  \/\/ Try to transform\n+  \/\/     op(add(x, x_off), add(y, y_off))\n+  \/\/ into\n+  \/\/     add(x, op(x_off, y_off)),\n+  \/\/ where:\n+  \/\/     op is either MinI or MaxI, and\n+  \/\/     inner == outer, and\n+  \/\/     the additions cannot overflow.\n+  ConstAddOperands xC = as_add_with_constant(in(1));\n+  ConstAddOperands yC = as_add_with_constant(in(2));\n+  if (xC.first == nullptr || yC.first == nullptr) return nullptr;\n+  return extract_add(phase, xC.first, xC.second, yC.first, yC.second);\n+}\n+\n+Node* MaxNode::IdentityI(PhaseGVN* phase) {\n+  assert(Opcode() == Op_MinI || Opcode() == Op_MaxI, \"Unexpected opcode\");\n+  if (in(1) == in(2)) {\n+    return in(1);\n+  }\n+  return MaxNode::Identity(phase);\n@@ -1200,1 +1219,16 @@\n-  return IdealI(phase, can_reshape, Op_MaxI);\n+  return IdealI(phase, can_reshape);\n+}\n+\n+Node* MaxINode::Identity(PhaseGVN* phase) {\n+  return IdentityI(phase);\n+}\n+\n+\/\/=============================================================================\n+\/\/------------------------------add_ring---------------------------------------\n+\/\/ Supplied function returns the sum of the inputs.\n+const Type *MaxINode::add_ring( const Type *t0, const Type *t1 ) const {\n+  const TypeInt *r0 = t0->is_int(); \/\/ Handy access\n+  const TypeInt *r1 = t1->is_int();\n+\n+  \/\/ Otherwise just MAX them bits.\n+  return TypeInt::make( MAX2(r0->_lo,r1->_lo), MAX2(r0->_hi,r1->_hi), MAX2(r0->_widen,r1->_widen) );\n@@ -1208,1 +1242,5 @@\n-  return IdealI(phase, can_reshape, Op_MinI);\n+  return IdealI(phase, can_reshape);\n+}\n+\n+Node* MinINode::Identity(PhaseGVN* phase) {\n+  return IdentityI(phase);\n","filename":"src\/hotspot\/share\/opto\/addnode.cpp","additions":109,"deletions":71,"binary":false,"changes":180,"status":"modified"},{"patch":"@@ -255,0 +255,1 @@\n+  Node* extract_add(PhaseGVN* phase, Node* x, jint x_off, Node* y, jint y_off);\n@@ -261,1 +262,2 @@\n-  Node* IdealI(PhaseGVN* phase, bool can_reshape, int opcode);\n+  Node* IdealI(PhaseGVN* phase, bool can_reshape);\n+  Node* IdentityI(PhaseGVN* phase);\n@@ -304,0 +306,1 @@\n+  virtual Node* Identity(PhaseGVN* phase);\n@@ -320,0 +323,1 @@\n+  virtual Node* Identity(PhaseGVN* phase);\n","filename":"src\/hotspot\/share\/opto\/addnode.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -35,0 +35,3 @@\n+import java.util.Arrays;\n+import java.util.Random;\n+import jdk.test.lib.Utils;\n@@ -37,0 +40,3 @@\n+\n+    private static final Random random = Utils.getRandomInstance();\n+\n@@ -55,1 +61,1 @@\n-        if (res == 0) {\n+        if (res == Arrays.stream(a).max().getAsInt()) {\n@@ -72,1 +78,1 @@\n-        if (res == -1023*1023) {\n+        if (res == Arrays.stream(a).min().getAsInt()) {\n@@ -81,2 +87,2 @@\n-            a[i] = -i;\n-            b[i] = i;\n+            a[i] = random.nextInt();\n+            b[i] = 1;\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/MinMaxRed_Int.java","additions":10,"deletions":4,"binary":false,"changes":14,"status":"modified"}]}