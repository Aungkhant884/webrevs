{"files":[{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2023, Alibaba Group Holding Limited. All rights reserved.\n@@ -33,0 +34,8 @@\n+import static jdk.internal.misc.Unsafe.ARRAY_BYTE_BASE_OFFSET;\n+import jdk.internal.access.JavaLangAccess;\n+import jdk.internal.access.SharedSecrets;\n+import jdk.internal.misc.Unsafe;\n+import jdk.internal.vm.annotation.Stable;\n+import java.nio.ByteOrder;\n+import java.nio.charset.CharacterCodingException;\n+import java.nio.charset.StandardCharsets;\n@@ -40,1 +49,0 @@\n-\n@@ -310,0 +318,2 @@\n+    private static final JavaLangAccess jla = SharedSecrets.getJavaLangAccess();\n+    private static final Unsafe UNSAFE = Unsafe.getUnsafe();\n@@ -416,0 +426,23 @@\n+    @Stable\n+    static final short[] PACKED_DIGITS;\n+    static {\n+        short[] shorts = new short[]{\n+                0x3030, 0x3130, 0x3230, 0x3330, 0x3430, 0x3530, 0x3630, 0x3730, 0x3830, 0x3930,\n+                0x3031, 0x3131, 0x3231, 0x3331, 0x3431, 0x3531, 0x3631, 0x3731, 0x3831, 0x3931,\n+                0x3032, 0x3132, 0x3232, 0x3332, 0x3432, 0x3532, 0x3632, 0x3732, 0x3832, 0x3932,\n+                0x3033, 0x3133, 0x3233, 0x3333, 0x3433, 0x3533, 0x3633, 0x3733, 0x3833, 0x3933,\n+                0x3034, 0x3134, 0x3234, 0x3334, 0x3434, 0x3534, 0x3634, 0x3734, 0x3834, 0x3934,\n+                0x3035, 0x3135, 0x3235, 0x3335, 0x3435, 0x3535, 0x3635, 0x3735, 0x3835, 0x3935,\n+                0x3036, 0x3136, 0x3236, 0x3336, 0x3436, 0x3536, 0x3636, 0x3736, 0x3836, 0x3936,\n+                0x3037, 0x3137, 0x3237, 0x3337, 0x3437, 0x3537, 0x3637, 0x3737, 0x3837, 0x3937,\n+                0x3038, 0x3138, 0x3238, 0x3338, 0x3438, 0x3538, 0x3638, 0x3738, 0x3838, 0x3938,\n+                0x3039, 0x3139, 0x3239, 0x3339, 0x3439, 0x3539, 0x3639, 0x3739, 0x3839, 0x3939\n+        };\n+        if (ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) {\n+            for (int i = 0; i < shorts.length; i++) {\n+                shorts[i] = Short.reverseBytes(shorts[i]);\n+            }\n+        }\n+        PACKED_DIGITS = shorts;\n+    }\n+\n@@ -3472,0 +3505,1 @@\n+    @SuppressWarnings(\"deprecation\")\n@@ -3473,6 +3507,4 @@\n-        if(scale==0) {\n-            if(intCompact!=INFLATED) {\n-                return Long.toString(intCompact);\n-            } else {\n-                return intVal.toString();\n-            }\n+        if (scale == 0) {\n+            return (intCompact != INFLATED) ?\n+                    Long.toString(intCompact) :\n+                    intVal.toString(10);\n@@ -3480,13 +3512,34 @@\n-        if(this.scale<0) { \/\/ No decimal point\n-            if(signum()==0) {\n-                return \"0\";\n-            }\n-            int trailingZeros = checkScaleNonZero((-(long)scale));\n-            StringBuilder buf;\n-            if(intCompact!=INFLATED) {\n-                buf = new StringBuilder(20+trailingZeros);\n-                buf.append(intCompact);\n-            } else {\n-                String str = intVal.toString();\n-                buf = new StringBuilder(str.length()+trailingZeros);\n-                buf.append(str);\n+\n+        if (intCompact != INFLATED) {\n+            return toPlainStringCompact(intCompact, scale);\n+        }\n+        return getValueString(intVal, scale);\n+    }\n+\n+    @SuppressWarnings(\"deprecation\")\n+    private static String getValueString(BigInteger intVal, int scale) {\n+        if (scale == 0) {\n+            return intVal.toString(10);\n+        }\n+\n+        final boolean negative;\n+        final BigInteger intValAbs;\n+        if (intVal.signum < 0) {\n+            negative = true;\n+            intValAbs = intVal.negate();\n+        } else {\n+            negative = false;\n+            intValAbs = intVal;\n+        }\n+\n+        String intValAbsString = intValAbs.toString(10);\n+\n+        int size = intValAbsString.length();\n+\n+        byte[] buf;\n+        int off = 0;\n+        if (scale < 0) {\n+            buf = new byte[size - scale + (negative ? 1 : 0)];\n+            if (negative) {\n+                buf[0] = '-';\n+                off = 1;\n@@ -3494,2 +3547,30 @@\n-            for (int i = 0; i < trailingZeros; i++) {\n-                buf.append('0');\n+            intValAbsString.getBytes(0, size, buf, off);\n+            Arrays.fill(buf, off + size, buf.length, (byte) '0');\n+        } else {\n+            int insertionPoint = size - scale;\n+            if (insertionPoint <= 0) {\n+                buf = new byte[size - insertionPoint + (negative ? 3 : 2)];\n+                if (negative) {\n+                    buf[0] = '-';\n+                    off = 1;\n+                }\n+                buf[off] = '0';\n+                buf[off + 1] = '.';\n+                off += 2;\n+\n+                for (int i = 0; i < -insertionPoint; i++) {\n+                    buf[off++] = '0';\n+                }\n+\n+                intValAbsString.getBytes(0, size, buf, off);\n+            } else { \/* We must insert zeros between point and intVal *\/\n+                buf = new byte[size + (negative ? 2 : 1)];\n+                if (negative) {\n+                    buf[0] = '-';\n+                    off = 1;\n+                }\n+\n+                intValAbsString.getBytes(0, insertionPoint, buf, off);\n+                off += insertionPoint;\n+                buf[off] = '.';\n+                intValAbsString.getBytes(insertionPoint, size, buf, off + 1);\n@@ -3497,1 +3578,0 @@\n-            return buf.toString();\n@@ -3499,3 +3579,31 @@\n-        String str ;\n-        if(intCompact!=INFLATED) {\n-            str = Long.toString(Math.abs(intCompact));\n+\n+        try {\n+            return jla.newStringNoRepl(buf, StandardCharsets.ISO_8859_1);\n+        } catch (CharacterCodingException x) {\n+            throw new Error(x);\n+        }\n+    }\n+\n+    private static String toPlainStringCompact(long intCompact, int scale) {\n+        final boolean negative;\n+        final long intCompactAbs;\n+        if (intCompact < 0) {\n+            intCompactAbs = -intCompact;\n+            negative = true;\n+        } else {\n+            intCompactAbs = intCompact;\n+            negative = false;\n+        }\n+\n+        int size = stringSize(intCompactAbs);\n+\n+        byte[] buf;\n+        int off = 0;\n+        if (scale < 0) {\n+            buf = new byte[size - scale + (negative ? 1 : 0)];\n+            if (negative) {\n+                buf[0] = '-';\n+                off = 1;\n+            }\n+            getChars(intCompactAbs, off + size, buf);\n+            Arrays.fill(buf, off + size, buf.length, (byte) '0');\n@@ -3503,22 +3611,27 @@\n-            str = intVal.abs().toString();\n-        }\n-        return getValueString(signum(), str, scale);\n-    }\n-\n-    \/* Returns a digit.digit string *\/\n-    private String getValueString(int signum, String intString, int scale) {\n-        \/* Insert decimal point *\/\n-        StringBuilder buf;\n-        int insertionPoint = intString.length() - scale;\n-        if (insertionPoint == 0) {  \/* Point goes right before intVal *\/\n-            return (signum<0 ? \"-0.\" : \"0.\") + intString;\n-        } else if (insertionPoint > 0) { \/* Point goes inside intVal *\/\n-            buf = new StringBuilder(intString);\n-            buf.insert(insertionPoint, '.');\n-            if (signum < 0)\n-                buf.insert(0, '-');\n-        } else { \/* We must insert zeros between point and intVal *\/\n-            buf = new StringBuilder(3-insertionPoint + intString.length());\n-            buf.append(signum<0 ? \"-0.\" : \"0.\");\n-            for (int i=0; i<-insertionPoint; i++) {\n-                buf.append('0');\n+            int insertionPoint = size - scale;\n+            if (insertionPoint <= 0) {\n+                buf = new byte[size - insertionPoint + (negative ? 3 : 2)];\n+                if (negative) {\n+                    buf[0] = '-';\n+                    off = 1;\n+                }\n+                buf[off] = '0';\n+                buf[off + 1] = '.';\n+\n+                for (int i = 0; i < -insertionPoint; i++) {\n+                    buf[off + i + 2] = '0';\n+                }\n+                getChars(intCompactAbs, buf.length, buf);\n+            } else {\n+                long power = POWER_TEN[scale - 1];\n+                long div = intCompactAbs \/ power;\n+                long rem = intCompactAbs - div * power;\n+                buf = new byte[size + (negative ? 2 : 1)];\n+                if (negative) {\n+                    buf[0] = '-';\n+                    off = 1;\n+                }\n+                int divOff = off + size - scale;\n+                getChars(div, divOff, buf);\n+                buf[divOff] = '.';\n+                getChars(rem, buf.length, buf);\n@@ -3526,1 +3639,0 @@\n-            buf.append(intString);\n@@ -3528,1 +3640,6 @@\n-        return buf.toString();\n+\n+        try {\n+            return jla.newStringNoRepl(buf, StandardCharsets.ISO_8859_1);\n+        } catch (CharacterCodingException x) {\n+            throw new Error(x);\n+        }\n@@ -4150,8 +4267,15 @@\n-    \/\/ Private class to build a string representation for BigDecimal object. The\n-    \/\/ StringBuilder field acts as a buffer to hold the temporary representation\n-    \/\/ of BigDecimal. The cmpCharArray holds all the characters for the compact\n-    \/\/ representation of BigDecimal (except for '-' sign' if it is negative) if\n-    \/\/ its intCompact field is not INFLATED.\n-    static class StringBuilderHelper {\n-        final StringBuilder sb;    \/\/ Placeholder for BigDecimal string\n-        final char[] cmpCharArray; \/\/ character array to place the intCompact\n+    \/**\n+     * Lay out this {@code BigDecimal} into a {@code char[]} array.\n+     * The Java 1.2 equivalent to this was called {@code getValueString}.\n+     *\n+     * @param  sci {@code true} for Scientific exponential notation;\n+     *          {@code false} for Engineering\n+     * @return string with canonical string representation of this\n+     *         {@code BigDecimal}\n+     *\/\n+    private String layoutChars(boolean sci) {\n+        if (scale == 0) {                     \/\/ zero scale is trivial\n+            return (intCompact != INFLATED) ?\n+                    Long.toString(intCompact) :\n+                    intVal.toString();\n+        }\n@@ -4159,4 +4283,30 @@\n-        StringBuilderHelper() {\n-            sb = new StringBuilder(32);\n-            \/\/ All non negative longs can be made to fit into 19 character array.\n-            cmpCharArray = new char[19];\n+        if (intCompact != INFLATED) {\n+            if (scale == 2) {\n+                long intCompactAbs;\n+                boolean negative = false;\n+                if (intCompact < 0) {\n+                    intCompactAbs = -intCompact;\n+                    negative = true;\n+                } else {\n+                    intCompactAbs = intCompact;\n+                }\n+\n+                long highInt = intCompactAbs \/ 100;\n+                short lowInt = (short) (intCompactAbs - highInt * 100);\n+                int highIntSize = stringSize(highInt) + (negative ? 1 : 0);\n+                byte[] buf = new byte[highIntSize + 3];\n+                if (negative) {\n+                    buf[0] = '-';\n+                }\n+                getChars(highInt, highIntSize, buf);\n+                buf[highIntSize] = '.';\n+                UNSAFE.putShortUnaligned(buf, Unsafe.ARRAY_BYTE_BASE_OFFSET + highIntSize + 1, PACKED_DIGITS[lowInt], false);\n+\n+                try {\n+                    return jla.newStringNoRepl(buf, StandardCharsets.ISO_8859_1);\n+                } catch (CharacterCodingException x) {\n+                    throw new Error(x);\n+                }\n+            }\n+\n+            return layoutChars(intCompact, scale, sci);\n@@ -4165,4 +4315,6 @@\n-        \/\/ Accessors.\n-        StringBuilder getStringBuilder() {\n-            sb.setLength(0);\n-            return sb;\n+       return layoutChars(intVal, scale, sci);\n+    }\n+\n+    private static String layoutChars(long intCompact, int scale, boolean sci) {\n+        if (scale == 0) {\n+            return Long.toString(intCompact);\n@@ -4171,2 +4323,7 @@\n-        char[] getCompactCharArray() {\n-            return cmpCharArray;\n+        long intCompactAbs;\n+        boolean negative = false;\n+        if (intCompact < 0) {\n+            intCompactAbs = -intCompact;\n+            negative = true;\n+        } else {\n+            intCompactAbs = intCompact;\n@@ -4175,26 +4332,26 @@\n-        \/**\n-         * Places characters representing the intCompact in {@code long} into\n-         * cmpCharArray and returns the offset to the array where the\n-         * representation starts.\n-         *\n-         * @param intCompact the number to put into the cmpCharArray.\n-         * @return offset to the array where the representation starts.\n-         * Note: intCompact must be greater or equal to zero.\n-         *\/\n-        int putIntCompact(long intCompact) {\n-            assert intCompact >= 0;\n-\n-            long q;\n-            int r;\n-            \/\/ since we start from the least significant digit, charPos points to\n-            \/\/ the last character in cmpCharArray.\n-            int charPos = cmpCharArray.length;\n-\n-            \/\/ Get 2 digits\/iteration using longs until quotient fits into an int\n-            while (intCompact > Integer.MAX_VALUE) {\n-                q = intCompact \/ 100;\n-                r = (int)(intCompact - q * 100);\n-                intCompact = q;\n-                cmpCharArray[--charPos] = DIGIT_ONES[r];\n-                cmpCharArray[--charPos] = DIGIT_TENS[r];\n-            }\n+        int coeffLen = stringSize(intCompactAbs);\n+        long adjusted = -(long) scale + (coeffLen - 1);\n+\n+        byte[] buf;\n+        int off = 0;\n+        if ((scale >= 0) && (adjusted >= -6)) {\n+            int pad = scale - coeffLen;\n+            if (pad >= 0) { \/\/ 0.xxx form\n+                buf = new byte[coeffLen + pad + (negative ? 3 : 2)];\n+                if (negative) {\n+                    buf[0] = '-';\n+                    off = 1;\n+                }\n+                buf[off] = '0';\n+                buf[off + 1] = '.';\n+                off += 2;\n+                for (int i = 0; i < pad; i++) {\n+                    buf[off++] = '0';\n+                }\n+                getChars(intCompactAbs, buf.length, buf);\n+            } else { \/\/ xx.xx form\n+                buf = new byte[coeffLen + (negative ? 2 : 1)];\n+                if (negative) {\n+                    buf[0] = '-';\n+                    off = 1;\n+                }\n@@ -4202,9 +4359,11 @@\n-            \/\/ Get 2 digits\/iteration using ints when i2 >= 100\n-            int q2;\n-            int i2 = (int)intCompact;\n-            while (i2 >= 100) {\n-                q2 = i2 \/ 100;\n-                r  = i2 - q2 * 100;\n-                i2 = q2;\n-                cmpCharArray[--charPos] = DIGIT_ONES[r];\n-                cmpCharArray[--charPos] = DIGIT_TENS[r];\n+                long power = POWER_TEN[scale - 1];\n+                long div = intCompactAbs \/ power;\n+                long rem = intCompactAbs - div * power;\n+                int remSize = stringSize(rem);\n+                getChars(div, off + coeffLen - scale, buf);\n+                off += coeffLen - scale;\n+                buf[off] = '.';\n+                for (int i = 0, end = scale - remSize; i < end; ++i) {\n+                    buf[off + 1 + i] = '0';\n+                }\n+                getChars(rem, buf.length, buf);\n@@ -4212,0 +4371,36 @@\n+        } else {\n+            if (sci) {\n+                if (coeffLen > 1) {\n+                    int adjustedSize = adjusted != 0 ? stringSize(Math.abs(adjusted)) + 2 : 0;\n+                    buf = new byte[coeffLen + adjustedSize + (negative ? 2 : 1)];\n+                    if (negative) {\n+                        buf[0] = '-';\n+                        off = 1;\n+                    }\n+                    long power = POWER_TEN[coeffLen - 2];\n+                    long div = intCompactAbs \/ power;\n+                    long rem = intCompactAbs - div * power;\n+                    int remSize = stringSize(rem);\n+                    buf[off] = (byte) (div + '0');\n+                    buf[off + 1] = '.';\n+                    for (int i = 0, end = coeffLen - remSize - 1; i < end; ++i) {\n+                        buf[off + 2 + i] = '0';\n+                    }\n+                    getChars(rem, off + coeffLen + 1, buf);\n+                    off += coeffLen + 1;\n+                } else {\n+                    int adjustedSize = adjusted != 0 ? stringSize(Math.abs(adjusted)) + 2 : 0;\n+                    buf = new byte[adjustedSize + (negative ? 2 : 1)];\n+                    if (negative) {\n+                        buf[0] = '-';\n+                        off = 1;\n+                    }\n+                    buf[off++] = (byte) (intCompactAbs + '0');\n+                }\n+            } else {\n+                int sig = (int) (adjusted % 3);\n+                if (sig < 0) {\n+                    sig += 3;                \/\/ [adjusted was negative]\n+                }\n+                adjusted -= sig;             \/\/ now a multiple of 3\n+                sig++;\n@@ -4213,3 +4408,50 @@\n-            cmpCharArray[--charPos] = DIGIT_ONES[i2];\n-            if (i2 >= 10)\n-                cmpCharArray[--charPos] = DIGIT_TENS[i2];\n+                int adjustedSize = adjusted != 0 ? stringSize(Math.abs(adjusted)) + 2 : 0;\n+                if (intCompactAbs == 0) {\n+                    switch (sig) {\n+                        case 1: {\n+                            buf = new byte[adjustedSize + 1];\n+                            buf[0] = '0'; \/\/ exponent is a multiple of three\n+                            off = 1;\n+                            break;\n+                        }\n+                        case 2: {\n+                            adjusted += 3;\n+                            adjustedSize = adjusted != 0 ? stringSize(Math.abs(adjusted)) + 2 : 0;\n+                            buf = new byte[adjustedSize + 4];\n+                            buf[0] = '0';\n+                            buf[1] = '.';\n+                            buf[2] = '0';\n+                            buf[3] = '0';\n+                            off = 4;\n+                            break;\n+                        }\n+                        case 3: {\n+                            adjusted += 3;\n+                            adjustedSize = adjusted != 0 ? stringSize(Math.abs(adjusted)) + 2 : 0;\n+                            buf = new byte[adjustedSize + 3];\n+                            buf[0] = '0';\n+                            buf[1] = '.';\n+                            buf[2] = '0';\n+                            off = 3;\n+                            break;\n+                        }\n+                        default:\n+                            throw new AssertionError(\"Unexpected sig value \" + sig);\n+                    }\n+                } else if (sig >= coeffLen) {\n+                    buf = new byte[adjustedSize + (negative ? 2 : 1) + sig - coeffLen];\n+                    if (negative) {\n+                        buf[0] = '-';\n+                        off = 1;\n+                    }\n+                    getChars(intCompactAbs, off + coeffLen, buf);\n+                    off += coeffLen;\n+                    for (int i = sig - coeffLen; i > 0; i--) {\n+                        buf[off++] = '0';\n+                    }\n+                } else {\n+                    buf = new byte[adjustedSize + (negative ? 2 : 1) + coeffLen];\n+                    if (negative) {\n+                        buf[0] = '-';\n+                        off = 1;\n+                    }\n@@ -4217,2 +4459,9 @@\n-            return charPos;\n-        }\n+                    long power = POWER_TEN[coeffLen - sig - 1];\n+                    long div = intCompactAbs \/ power;\n+                    long rem = intCompactAbs - div * power;\n+                    getChars(div, off + sig, buf);\n+                    buf[off + sig] = '.';\n+                    getChars(rem, off + coeffLen + 1, buf);\n+                    off += coeffLen + 1;\n+                }\n+            }\n@@ -4220,12 +4469,11 @@\n-        static final char[] DIGIT_TENS = {\n-            '0', '0', '0', '0', '0', '0', '0', '0', '0', '0',\n-            '1', '1', '1', '1', '1', '1', '1', '1', '1', '1',\n-            '2', '2', '2', '2', '2', '2', '2', '2', '2', '2',\n-            '3', '3', '3', '3', '3', '3', '3', '3', '3', '3',\n-            '4', '4', '4', '4', '4', '4', '4', '4', '4', '4',\n-            '5', '5', '5', '5', '5', '5', '5', '5', '5', '5',\n-            '6', '6', '6', '6', '6', '6', '6', '6', '6', '6',\n-            '7', '7', '7', '7', '7', '7', '7', '7', '7', '7',\n-            '8', '8', '8', '8', '8', '8', '8', '8', '8', '8',\n-            '9', '9', '9', '9', '9', '9', '9', '9', '9', '9',\n-        };\n+            if (adjusted != 0) {             \/\/ [!sci could have made 0]\n+                buf[off++] = 'E';\n+                if (adjusted > 0) {\n+                    buf[off] = '+';\n+                } else {\n+                    buf[off] = '-';\n+                    adjusted = -adjusted;\n+                }\n+                getChars(adjusted, buf.length, buf);\n+            }\n+        }\n@@ -4233,12 +4481,5 @@\n-        static final char[] DIGIT_ONES = {\n-            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n-            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n-            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n-            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n-            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n-            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n-            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n-            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n-            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n-            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n-        };\n+        try {\n+            return jla.newStringNoRepl(buf, StandardCharsets.ISO_8859_1);\n+        } catch (CharacterCodingException x) {\n+            throw new Error(x);\n+        }\n@@ -4247,31 +4488,11 @@\n-    \/**\n-     * Lay out this {@code BigDecimal} into a {@code char[]} array.\n-     * The Java 1.2 equivalent to this was called {@code getValueString}.\n-     *\n-     * @param  sci {@code true} for Scientific exponential notation;\n-     *          {@code false} for Engineering\n-     * @return string with canonical string representation of this\n-     *         {@code BigDecimal}\n-     *\/\n-    private String layoutChars(boolean sci) {\n-        if (scale == 0)                      \/\/ zero scale is trivial\n-            return (intCompact != INFLATED) ?\n-                Long.toString(intCompact):\n-                intVal.toString();\n-        if (scale == 2  &&\n-            intCompact >= 0 && intCompact < Integer.MAX_VALUE) {\n-            \/\/ currency fast path\n-            int lowInt = (int)intCompact % 100;\n-            int highInt = (int)intCompact \/ 100;\n-            return (Integer.toString(highInt) + '.' +\n-                    StringBuilderHelper.DIGIT_TENS[lowInt] +\n-                    StringBuilderHelper.DIGIT_ONES[lowInt]) ;\n-        }\n-\n-        StringBuilderHelper sbHelper = new StringBuilderHelper();\n-        char[] coeff;\n-        int offset;  \/\/ offset is the starting index for coeff array\n-        \/\/ Get the significand as an absolute value\n-        if (intCompact != INFLATED) {\n-            offset = sbHelper.putIntCompact(Math.abs(intCompact));\n-            coeff  = sbHelper.getCompactCharArray();\n+    private static String layoutChars(BigInteger intVal, int scale, boolean sci) {\n+        if (scale == 0) {\n+            return intVal.toString();\n+        }\n+\n+        BigInteger intValAbs;\n+        boolean negative = false;\n+        int signum = intVal.signum();\n+        if (signum < 0) {\n+            intValAbs = intVal.negate();\n+            negative = true;\n@@ -4279,20 +4500,22 @@\n-            offset = 0;\n-            coeff  = intVal.abs().toString().toCharArray();\n-        }\n-\n-        \/\/ Construct a buffer, with sufficient capacity for all cases.\n-        \/\/ If E-notation is needed, length will be: +1 if negative, +1\n-        \/\/ if '.' needed, +2 for \"E+\", + up to 10 for adjusted exponent.\n-        \/\/ Otherwise it could have +1 if negative, plus leading \"0.00000\"\n-        StringBuilder buf = sbHelper.getStringBuilder();\n-        if (signum() < 0)             \/\/ prefix '-' if negative\n-            buf.append('-');\n-        int coeffLen = coeff.length - offset;\n-        long adjusted = -(long)scale + (coeffLen -1);\n-        if ((scale >= 0) && (adjusted >= -6)) { \/\/ plain number\n-            int pad = scale - coeffLen;         \/\/ count of padding zeros\n-            if (pad >= 0) {                     \/\/ 0.xxx form\n-                buf.append('0');\n-                buf.append('.');\n-                for (; pad>0; pad--) {\n-                    buf.append('0');\n+            intValAbs = intVal;\n+        }\n+\n+        byte[] buf;\n+        int off = 0;\n+        String intValAbsString = intValAbs.toString(10);\n+        byte[] coeff = intValAbsString.getBytes(StandardCharsets.ISO_8859_1);\n+        int coeffLen = coeff.length;\n+        long adjusted = -(long) scale + (coeffLen - 1);\n+        if ((scale >= 0) && (adjusted >= -6)) {\n+            int pad = scale - coeffLen;\n+            if (pad >= 0) {\n+                buf = new byte[coeffLen + 2 + pad + (negative ? 1 : 0)];\n+                if (negative) {\n+                    buf[0] = '-';\n+                    off = 1;\n+                }\n+                buf[off] = '0';\n+                buf[off + 1] = '.';\n+                off += 2;\n+                for (int i = 0; i < pad; i++) {\n+                    buf[off++] = '0';\n@@ -4300,5 +4523,11 @@\n-                buf.append(coeff, offset, coeffLen);\n-            } else {                         \/\/ xx.xx form\n-                buf.append(coeff, offset, -pad);\n-                buf.append('.');\n-                buf.append(coeff, -pad + offset, scale);\n+                System.arraycopy(coeff, 0, buf, off, coeffLen);\n+            } else {\n+                buf = new byte[coeffLen + 1 + (negative ? 1 : 0)];\n+                if (negative) {\n+                    buf[0] = '-';\n+                    off = 1;\n+                }\n+\n+                System.arraycopy(coeff, 0, buf, off, -pad);\n+                buf[off - pad] = '.';\n+                System.arraycopy(coeff, -pad, buf, off - pad + 1, scale);\n@@ -4306,1 +4535,1 @@\n-        } else { \/\/ E-notation is needed\n+        } else {\n@@ -4308,4 +4537,19 @@\n-                buf.append(coeff[offset]);   \/\/ first character\n-                if (coeffLen > 1) {          \/\/ more to come\n-                    buf.append('.');\n-                    buf.append(coeff, offset + 1, coeffLen - 1);\n+                if (coeffLen > 1) {\n+                    int adjustedSize = adjusted != 0 ? stringSize(Math.abs(adjusted)) + 2 : 0;\n+                    buf = new byte[coeffLen + adjustedSize + 1 + (negative ? 1 : 0)];\n+                    if (negative) {\n+                        buf[0] = '-';\n+                        off = 1;\n+                    }\n+                    buf[off] = coeff[0];\n+                    buf[off + 1] = '.';\n+                    System.arraycopy(coeff, 1, buf, off + 2, coeffLen - 1);\n+                    off += coeffLen + 1;\n+                } else {\n+                    int adjustedSize = adjusted != 0 ? stringSize(Math.abs(adjusted)) + 2 : 0;\n+                    buf = new byte[adjustedSize + (negative ? 2 : 1)];\n+                    if (negative) {\n+                        buf[0] = '-';\n+                        off = 1;\n+                    }\n+                    buf[off++] = coeff[0];\n@@ -4313,3 +4557,3 @@\n-            } else {                         \/\/ Engineering notation\n-                int sig = (int)(adjusted % 3);\n-                if (sig < 0)\n+            } else { \/\/ Engineering notation\n+                int sig = (int) (adjusted % 3);\n+                if (sig < 0) {\n@@ -4317,0 +4561,1 @@\n+                }\n@@ -4319,1 +4564,3 @@\n-                if (signum() == 0) {\n+\n+                int adjustedSize = adjusted != 0 ? stringSize(Math.abs(adjusted)) + 2 : 0;\n+                if (signum == 0) {\n@@ -4321,13 +4568,29 @@\n-                    case 1:\n-                        buf.append('0'); \/\/ exponent is a multiple of three\n-                        break;\n-                    case 2:\n-                        buf.append(\"0.00\");\n-                        adjusted += 3;\n-                        break;\n-                    case 3:\n-                        buf.append(\"0.0\");\n-                        adjusted += 3;\n-                        break;\n-                    default:\n-                        throw new AssertionError(\"Unexpected sig value \" + sig);\n+                        case 1: {\n+                            buf = new byte[adjustedSize + 1];\n+                            buf[0] = '0'; \/\/ exponent is a multiple of three\n+                            off = 1;\n+                            break;\n+                        }\n+                        case 2: {\n+                            adjusted += 3;\n+                            adjustedSize = adjusted != 0 ? stringSize(Math.abs(adjusted)) + 2 : 0;\n+                            buf = new byte[adjustedSize + 4];\n+                            buf[0] = '0';\n+                            buf[1] = '.';\n+                            buf[2] = '0';\n+                            buf[3] = '0';\n+                            off = 4;\n+                            break;\n+                        }\n+                        case 3: {\n+                            adjusted += 3;\n+                            adjustedSize = adjusted != 0 ? stringSize(Math.abs(adjusted)) + 2 : 0;\n+                            buf = new byte[adjustedSize + 3];\n+                            buf[0] = '0';\n+                            buf[1] = '.';\n+                            buf[2] = '0';\n+                            off = 3;\n+                            break;\n+                        }\n+                        default:\n+                            throw new AssertionError(\"Unexpected sig value \" + sig);\n@@ -4335,2 +4598,8 @@\n-                } else if (sig >= coeffLen) {   \/\/ significand all in integer\n-                    buf.append(coeff, offset, coeffLen);\n+                } else if (sig >= coeffLen) { \/\/ significand all in integer\n+                    buf = new byte[adjustedSize + (negative ? 2 : 1) + sig - coeffLen];\n+                    if (negative) {\n+                        buf[0] = '-';\n+                        off = 1;\n+                    }\n+                    System.arraycopy(coeff, 0, buf, off, coeffLen);\n+                    off += coeffLen;\n@@ -4339,1 +4608,7 @@\n-                        buf.append('0');\n+                        buf[off++] = '0';\n+                    }\n+                } else { \/\/ xx.xxE form\n+                    buf = new byte[adjustedSize + (negative ? 2 : 1) + coeffLen];\n+                    if (negative) {\n+                        buf[0] = '-';\n+                        off = 1;\n@@ -4341,4 +4616,5 @@\n-                } else {                     \/\/ xx.xxE form\n-                    buf.append(coeff, offset, sig);\n-                    buf.append('.');\n-                    buf.append(coeff, offset + sig, coeffLen - sig);\n+\n+                    System.arraycopy(coeff, 0, buf, off, sig);\n+                    buf[off + sig] = '.';\n+                    System.arraycopy(coeff, sig, buf, off + sig + 1, coeffLen - sig);\n+                    off += coeffLen + 1;\n@@ -4348,4 +4624,8 @@\n-                buf.append('E');\n-                if (adjusted > 0)            \/\/ force sign for positive\n-                    buf.append('+');\n-                buf.append(adjusted);\n+                buf[off++] = 'E';\n+                if (adjusted > 0) { \/\/ force sign for positive\n+                    buf[off] = '+';\n+                } else {\n+                    buf[off] = '-';\n+                    adjusted = -adjusted;\n+                }\n+                getChars(adjusted, buf.length, buf);\n@@ -4354,1 +4634,6 @@\n-        return buf.toString();\n+\n+        try {\n+            return jla.newStringNoRepl(buf, StandardCharsets.ISO_8859_1);\n+        } catch (CharacterCodingException x) {\n+            throw new Error(x);\n+        }\n@@ -4361,1 +4646,1 @@\n-     * @return a {@code BigInteger} with the value (10<sup>n<\/sup>)\n+     * @return a {@code BigInteger} with the value (10<sup>n<\/sutp>)\n@@ -6099,0 +6384,70 @@\n+    @Stable\n+    static final long[] POWER_TEN = {\n+            10,\n+            100,\n+            1000,\n+            10000,\n+            100000,\n+            1000000,\n+            10000000,\n+            100000000,\n+            1000000000,\n+            10000000000L,\n+            100000000000L,\n+            1000000000000L,\n+            10000000000000L,\n+            100000000000000L,\n+            1000000000000000L,\n+            10000000000000000L,\n+            100000000000000000L,\n+            1000000000000000000L,\n+    };\n+\n+    \/\/ Requires positive x\n+    static int stringSize(long x) {\n+        long p = 10;\n+        for (int i = 1; i < 19; i++) {\n+            if (x < p) {\n+                return i;\n+            }\n+            p = 10 * p;\n+        }\n+        return 19;\n+    }\n+\n+    \/\/ Requires positive x\n+    static void getChars(long i, int index, byte[] buf) {\n+        long q;\n+        int charPos = index;\n+\n+        assert i >= 0 : \"i >= 0\";\n+\n+        \/\/ Get 2 digits\/iteration using longs until quotient fits into an int\n+        while (i > Integer.MAX_VALUE) {\n+            q = i \/ 100;\n+            charPos -= 2;\n+            assert charPos >= 0 && charPos < buf.length : \"Trusted caller missed bounds check\";\n+            UNSAFE.putShortUnaligned(buf, Unsafe.ARRAY_BYTE_BASE_OFFSET + charPos, PACKED_DIGITS[(int) (i - q * 100)], false);\n+            i = q;\n+        }\n+\n+        \/\/ Get 2 digits\/iteration using ints\n+        int q2;\n+        int i2 = (int) i;\n+        while (i2 >= 100) {\n+            q2 = i2 \/ 100;\n+            charPos -= 2;\n+            assert charPos >= 0 && charPos < buf.length : \"Trusted caller missed bounds check\";\n+            UNSAFE.putShortUnaligned(buf, Unsafe.ARRAY_BYTE_BASE_OFFSET + charPos, PACKED_DIGITS[i2 - q2 * 100], false);\n+            i2 = q2;\n+        }\n+\n+        \/\/ We know there are at most two digits left at this point.\n+        if (i2 > 9) {\n+            charPos -= 2;\n+            assert charPos >= 0 && charPos < buf.length : \"Trusted caller missed bounds check\";\n+            UNSAFE.putShortUnaligned(buf, Unsafe.ARRAY_BYTE_BASE_OFFSET + charPos, PACKED_DIGITS[i2], false);\n+        } else {\n+            buf[--charPos] = (byte) ('0' + i2);\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/math\/BigDecimal.java","additions":578,"deletions":223,"binary":false,"changes":801,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,2 @@\n+import java.nio.charset.CharacterCodingException;\n+import java.nio.charset.StandardCharsets;\n@@ -46,0 +48,2 @@\n+import jdk.internal.access.JavaLangAccess;\n+import jdk.internal.access.SharedSecrets;\n@@ -138,0 +142,2 @@\n+    private static final JavaLangAccess jla = SharedSecrets.getJavaLangAccess();\n+\n@@ -4099,0 +4105,9 @@\n+        if (mag.length <= SCHOENHAGE_BASE_CONVERSION_THRESHOLD && radix == 10) {\n+            byte[] buf = smallToString(signum < 0, abs);\n+            try {\n+                return jla.newStringNoRepl(buf, StandardCharsets.ISO_8859_1);\n+            } catch (CharacterCodingException x) {\n+                throw new Error(x);\n+            }\n+        }\n+\n@@ -4194,0 +4209,51 @@\n+    static byte[] smallToString(boolean negative, BigInteger bigInt) {\n+        \/\/ Compute upper bound on number of digit groups and allocate space\n+        int maxNumDigitGroups = (4 * bigInt.mag.length + 6) \/ 7;\n+        long[] digitGroups = new long[maxNumDigitGroups];\n+\n+        \/\/ Translate number to string, a digit group at a time\n+        BigInteger tmp = bigInt;\n+        int numGroups = 0;\n+        while (tmp.signum != 0) {\n+            MutableBigInteger q = new MutableBigInteger();\n+            MutableBigInteger a = new MutableBigInteger(tmp.mag);\n+            MutableBigInteger b = new MutableBigInteger(longRadix10Mag);\n+            digitGroups[numGroups++] = a.divideKnuth(b, q, true).toLong();\n+            tmp = q.toBigInteger(1);\n+        }\n+\n+        \/\/ Get string version of first digit group\n+        long digit = digitGroups[numGroups - 1];\n+        int digitSize = BigDecimal.stringSize(digit);\n+\n+        final int digitsPerLong = 18;\n+        int bufSize = digitSize + (negative ? 1 : 0) + digitsPerLong * (numGroups - 1);\n+\n+        byte[] buf = new byte[bufSize];\n+        int off = 0;\n+\/\/        StringBuilder buf = new StringBuilder(bufSize);\n+        if (negative) {\n+            buf[off] = '-';\n+            off = 1;\n+        }\n+\n+        \/\/ Put first digit group into result buffer\n+        BigDecimal.getChars(digit, digitSize + off, buf);\n+        off += digitSize;\n+\n+        \/\/ Append remaining digit groups each padded with leading zeros\n+        for (int i = numGroups - 2; i >= 0; i--) {\n+            \/\/ Prepend (any) leading zeros for this digit group\n+            digit = digitGroups[i];\n+            digitSize = BigDecimal.stringSize(digit);\n+            int numLeadingZeros = digitsPerLong - digitSize;\n+            for (int j = 0; j < numLeadingZeros; j++) {\n+                buf[off + j] = '0';\n+            }\n+            BigDecimal.getChars(digit, digitsPerLong + off, buf);\n+            off += digitsPerLong;\n+        }\n+\n+        return buf;\n+    }\n+\n@@ -4709,0 +4775,3 @@\n+    @Stable\n+    static final int[] longRadix10Mag = new int[]{232830643, -1486618624};\n+\n@@ -4712,0 +4781,1 @@\n+    @Stable\n@@ -4716,0 +4786,1 @@\n+    @Stable\n","filename":"src\/java.base\/share\/classes\/java\/math\/BigInteger.java","additions":72,"deletions":1,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -177,1 +177,1 @@\n-    private long toLong() {\n+    long toLong() {\n","filename":"src\/java.base\/share\/classes\/java\/math\/MutableBigInteger.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,0 +38,3 @@\n+import sun.misc.Unsafe;\n+\n+import java.lang.reflect.Field;\n@@ -145,0 +148,16 @@\n+    @Benchmark\n+    @OperationsPerInvocation(TEST_SIZE)\n+    public void testToPlainString(Blackhole bh) {\n+        for (BigDecimal s : bigDecimals) {\n+            bh.consume(s.toPlainString());\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(TEST_SIZE)\n+    public void testToEngineeringString(Blackhole bh) {\n+        for (BigDecimal s : bigDecimals) {\n+            bh.consume(s.toEngineeringString());\n+        }\n+    }\n+\n@@ -216,0 +235,16 @@\n+    @Benchmark\n+    @OperationsPerInvocation(TEST_SIZE)\n+    public void testHugeToPlainString(Blackhole bh) {\n+        for (BigDecimal s : hugeArray) {\n+            bh.consume(s.toPlainString());\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(TEST_SIZE)\n+    public void testHugeToEngineeringString(Blackhole bh) {\n+        for (BigDecimal s : hugeArray) {\n+            bh.consume(s.toEngineeringString());\n+        }\n+    }\n+\n@@ -225,0 +260,16 @@\n+    @Benchmark\n+    @OperationsPerInvocation(TEST_SIZE)\n+    public void testLargeToPlainString(Blackhole bh) {\n+        for (BigDecimal s : largeArray) {\n+            bh.consume(s.toPlainString());\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(TEST_SIZE)\n+    public void testLargeToEngineeringString(Blackhole bh) {\n+        for (BigDecimal s : largeArray) {\n+            bh.consume(s.toEngineeringString());\n+        }\n+    }\n+\n@@ -233,0 +284,16 @@\n+\n+    @Benchmark\n+    @OperationsPerInvocation(TEST_SIZE)\n+    public void testSmallToPlainString(Blackhole bh) {\n+        for (BigDecimal s : smallArray) {\n+            bh.consume(s.toPlainString());\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(TEST_SIZE)\n+    public void testSmallToEngineeringString(Blackhole bh) {\n+        for (BigDecimal s : smallArray) {\n+            bh.consume(s.toEngineeringString());\n+        }\n+    }\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/math\/BigDecimals.java","additions":68,"deletions":1,"binary":false,"changes":69,"status":"modified"}]}