{"files":[{"patch":"@@ -2486,0 +2486,12 @@\n+            public int stringSize(long i) {\n+                return Long.stringSize(i);\n+            }\n+\n+            public void getChars(long i, int index, byte[] buf) {\n+                StringLatin1.getChars(i, index, buf);\n+            }\n+\n+            public short digitPair(int i) {\n+                return StringLatin1.PACKED_DIGITS[i];\n+            }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2023, Alibaba Group Holding Limited. All rights reserved.\n@@ -33,0 +34,9 @@\n+import jdk.internal.access.JavaLangAccess;\n+import jdk.internal.access.SharedSecrets;\n+import jdk.internal.math.MathUtils;\n+import jdk.internal.misc.Unsafe;\n+import jdk.internal.util.ByteArrayLittleEndian;\n+import jdk.internal.vm.annotation.Stable;\n+import java.nio.ByteOrder;\n+import java.nio.charset.CharacterCodingException;\n+import java.nio.charset.StandardCharsets;\n@@ -40,1 +50,0 @@\n-\n@@ -310,0 +319,1 @@\n+    private static final JavaLangAccess jla = SharedSecrets.getJavaLangAccess();\n@@ -3472,0 +3482,1 @@\n+    @SuppressWarnings(\"deprecation\")\n@@ -3473,2 +3484,5 @@\n-        if(scale==0) {\n-            if(intCompact!=INFLATED) {\n+        final long intCompact = this.intCompact;\n+        final int scale = this.scale;\n+\n+        if (intCompact != INFLATED) {\n+            if (scale == 0) {\n@@ -3476,2 +3490,0 @@\n-            } else {\n-                return intVal.toString();\n@@ -3479,10 +3491,10 @@\n-        }\n-        if(this.scale<0) { \/\/ No decimal point\n-            if(signum()==0) {\n-                return \"0\";\n-            }\n-            int trailingZeros = checkScaleNonZero((-(long)scale));\n-            StringBuilder buf;\n-            if(intCompact!=INFLATED) {\n-                buf = new StringBuilder(20+trailingZeros);\n-                buf.append(intCompact);\n+\n+            final boolean negative = intCompact < 0;\n+            int size = jla.stringSize(intCompact);\n+\n+            byte[] buf;\n+            int off = 0;\n+            if (scale < 0) {\n+                buf = new byte[size - scale];\n+                jla.getChars(intCompact, off + size, buf);\n+                Arrays.fill(buf, off + size, buf.length, (byte) '0');\n@@ -3490,3 +3502,23 @@\n-                String str = intVal.toString();\n-                buf = new StringBuilder(str.length()+trailingZeros);\n-                buf.append(str);\n+                int insertionPoint = size - (negative ? 1 : 0) - scale;\n+                if (insertionPoint <= 0) {\n+                    buf = new byte[size - insertionPoint + 2];\n+                    if (negative) {\n+                        buf[0] = '-';\n+                        off = 1;\n+                    }\n+                    buf[off] = '0';\n+                    buf[off + 1] = '.';\n+\n+                    for (int i = 0; i < -insertionPoint; i++) {\n+                        buf[off + i + 2] = '0';\n+                    }\n+                    jla.getChars(Math.abs(intCompact), buf.length, buf);\n+                } else {\n+                    long power = MathUtils.pow10(scale);\n+                    long div = intCompact \/ power;\n+                    buf = new byte[size + 1];\n+                    int divOff = off + size - scale;\n+                    jla.getChars(div, divOff, buf);\n+                    buf[divOff] = '.';\n+                    jla.getChars(Math.abs(intCompact - div * power), buf.length, buf);\n+                }\n@@ -3494,2 +3526,5 @@\n-            for (int i = 0; i < trailingZeros; i++) {\n-                buf.append('0');\n+\n+            try {\n+                return jla.newStringNoRepl(buf, StandardCharsets.ISO_8859_1);\n+            } catch (CharacterCodingException e) {\n+                throw new AssertionError(e);\n@@ -3497,1 +3532,0 @@\n-            return buf.toString();\n@@ -3499,3 +3533,15 @@\n-        String str ;\n-        if(intCompact!=INFLATED) {\n-            str = Long.toString(Math.abs(intCompact));\n+\n+        return getValueString(intVal, scale);\n+    }\n+\n+    @SuppressWarnings(\"deprecation\")\n+    private static String getValueString(BigInteger intVal, int scale) {\n+        if (scale == 0) {\n+            return intVal.toString(10);\n+        }\n+\n+        final boolean negative;\n+        final BigInteger intValAbs;\n+        if (intVal.signum < 0) {\n+            negative = true;\n+            intValAbs = intVal.negate();\n@@ -3503,22 +3549,46 @@\n-            str = intVal.abs().toString();\n-        }\n-        return getValueString(signum(), str, scale);\n-    }\n-\n-    \/* Returns a digit.digit string *\/\n-    private String getValueString(int signum, String intString, int scale) {\n-        \/* Insert decimal point *\/\n-        StringBuilder buf;\n-        int insertionPoint = intString.length() - scale;\n-        if (insertionPoint == 0) {  \/* Point goes right before intVal *\/\n-            return (signum<0 ? \"-0.\" : \"0.\") + intString;\n-        } else if (insertionPoint > 0) { \/* Point goes inside intVal *\/\n-            buf = new StringBuilder(intString);\n-            buf.insert(insertionPoint, '.');\n-            if (signum < 0)\n-                buf.insert(0, '-');\n-        } else { \/* We must insert zeros between point and intVal *\/\n-            buf = new StringBuilder(3-insertionPoint + intString.length());\n-            buf.append(signum<0 ? \"-0.\" : \"0.\");\n-            for (int i=0; i<-insertionPoint; i++) {\n-                buf.append('0');\n+            negative = false;\n+            intValAbs = intVal;\n+        }\n+\n+        String intValAbsString = intValAbs.toString(10);\n+\n+        int size = intValAbsString.length();\n+\n+        byte[] buf;\n+        int off = 0;\n+        if (scale < 0) {\n+            buf = new byte[size - scale + (negative ? 1 : 0)];\n+            if (negative) {\n+                buf[0] = '-';\n+                off = 1;\n+            }\n+            intValAbsString.getBytes(0, size, buf, off);\n+            Arrays.fill(buf, off + size, buf.length, (byte) '0');\n+        } else {\n+            int insertionPoint = size - scale;\n+            if (insertionPoint <= 0) {\n+                buf = new byte[size - insertionPoint + (negative ? 3 : 2)];\n+                if (negative) {\n+                    buf[0] = '-';\n+                    off = 1;\n+                }\n+                buf[off] = '0';\n+                buf[off + 1] = '.';\n+                off += 2;\n+\n+                for (int i = 0; i < -insertionPoint; i++) {\n+                    buf[off++] = '0';\n+                }\n+\n+                intValAbsString.getBytes(0, size, buf, off);\n+            } else { \/* We must insert zeros between point and intVal *\/\n+                buf = new byte[size + (negative ? 2 : 1)];\n+                if (negative) {\n+                    buf[0] = '-';\n+                    off = 1;\n+                }\n+\n+                intValAbsString.getBytes(0, insertionPoint, buf, off);\n+                off += insertionPoint;\n+                buf[off] = '.';\n+                intValAbsString.getBytes(insertionPoint, size, buf, off + 1);\n@@ -3526,1 +3596,0 @@\n-            buf.append(intString);\n@@ -3528,1 +3597,6 @@\n-        return buf.toString();\n+\n+        try {\n+            return jla.newStringNoRepl(buf, StandardCharsets.ISO_8859_1);\n+        } catch (CharacterCodingException e) {\n+            throw new AssertionError(e);\n+        }\n@@ -4150,97 +4224,0 @@\n-    \/\/ Private class to build a string representation for BigDecimal object. The\n-    \/\/ StringBuilder field acts as a buffer to hold the temporary representation\n-    \/\/ of BigDecimal. The cmpCharArray holds all the characters for the compact\n-    \/\/ representation of BigDecimal (except for '-' sign' if it is negative) if\n-    \/\/ its intCompact field is not INFLATED.\n-    static class StringBuilderHelper {\n-        final StringBuilder sb;    \/\/ Placeholder for BigDecimal string\n-        final char[] cmpCharArray; \/\/ character array to place the intCompact\n-\n-        StringBuilderHelper() {\n-            sb = new StringBuilder(32);\n-            \/\/ All non negative longs can be made to fit into 19 character array.\n-            cmpCharArray = new char[19];\n-        }\n-\n-        \/\/ Accessors.\n-        StringBuilder getStringBuilder() {\n-            sb.setLength(0);\n-            return sb;\n-        }\n-\n-        char[] getCompactCharArray() {\n-            return cmpCharArray;\n-        }\n-\n-        \/**\n-         * Places characters representing the intCompact in {@code long} into\n-         * cmpCharArray and returns the offset to the array where the\n-         * representation starts.\n-         *\n-         * @param intCompact the number to put into the cmpCharArray.\n-         * @return offset to the array where the representation starts.\n-         * Note: intCompact must be greater or equal to zero.\n-         *\/\n-        int putIntCompact(long intCompact) {\n-            assert intCompact >= 0;\n-\n-            long q;\n-            int r;\n-            \/\/ since we start from the least significant digit, charPos points to\n-            \/\/ the last character in cmpCharArray.\n-            int charPos = cmpCharArray.length;\n-\n-            \/\/ Get 2 digits\/iteration using longs until quotient fits into an int\n-            while (intCompact > Integer.MAX_VALUE) {\n-                q = intCompact \/ 100;\n-                r = (int)(intCompact - q * 100);\n-                intCompact = q;\n-                cmpCharArray[--charPos] = DIGIT_ONES[r];\n-                cmpCharArray[--charPos] = DIGIT_TENS[r];\n-            }\n-\n-            \/\/ Get 2 digits\/iteration using ints when i2 >= 100\n-            int q2;\n-            int i2 = (int)intCompact;\n-            while (i2 >= 100) {\n-                q2 = i2 \/ 100;\n-                r  = i2 - q2 * 100;\n-                i2 = q2;\n-                cmpCharArray[--charPos] = DIGIT_ONES[r];\n-                cmpCharArray[--charPos] = DIGIT_TENS[r];\n-            }\n-\n-            cmpCharArray[--charPos] = DIGIT_ONES[i2];\n-            if (i2 >= 10)\n-                cmpCharArray[--charPos] = DIGIT_TENS[i2];\n-\n-            return charPos;\n-        }\n-\n-        static final char[] DIGIT_TENS = {\n-            '0', '0', '0', '0', '0', '0', '0', '0', '0', '0',\n-            '1', '1', '1', '1', '1', '1', '1', '1', '1', '1',\n-            '2', '2', '2', '2', '2', '2', '2', '2', '2', '2',\n-            '3', '3', '3', '3', '3', '3', '3', '3', '3', '3',\n-            '4', '4', '4', '4', '4', '4', '4', '4', '4', '4',\n-            '5', '5', '5', '5', '5', '5', '5', '5', '5', '5',\n-            '6', '6', '6', '6', '6', '6', '6', '6', '6', '6',\n-            '7', '7', '7', '7', '7', '7', '7', '7', '7', '7',\n-            '8', '8', '8', '8', '8', '8', '8', '8', '8', '8',\n-            '9', '9', '9', '9', '9', '9', '9', '9', '9', '9',\n-        };\n-\n-        static final char[] DIGIT_ONES = {\n-            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n-            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n-            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n-            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n-            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n-            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n-            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n-            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n-            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n-            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n-        };\n-    }\n-\n@@ -4257,18 +4234,1 @@\n-        if (scale == 0)                      \/\/ zero scale is trivial\n-            return (intCompact != INFLATED) ?\n-                Long.toString(intCompact):\n-                intVal.toString();\n-        if (scale == 2  &&\n-            intCompact >= 0 && intCompact < Integer.MAX_VALUE) {\n-            \/\/ currency fast path\n-            int lowInt = (int)intCompact % 100;\n-            int highInt = (int)intCompact \/ 100;\n-            return (Integer.toString(highInt) + '.' +\n-                    StringBuilderHelper.DIGIT_TENS[lowInt] +\n-                    StringBuilderHelper.DIGIT_ONES[lowInt]) ;\n-        }\n-\n-        StringBuilderHelper sbHelper = new StringBuilderHelper();\n-        char[] coeff;\n-        int offset;  \/\/ offset is the starting index for coeff array\n-        \/\/ Get the significand as an absolute value\n+        final long intCompact = this.intCompact;\n@@ -4276,15 +4236,37 @@\n-            offset = sbHelper.putIntCompact(Math.abs(intCompact));\n-            coeff  = sbHelper.getCompactCharArray();\n-        } else {\n-            offset = 0;\n-            coeff  = intVal.abs().toString().toCharArray();\n-        }\n-\n-        \/\/ Construct a buffer, with sufficient capacity for all cases.\n-        \/\/ If E-notation is needed, length will be: +1 if negative, +1\n-        \/\/ if '.' needed, +2 for \"E+\", + up to 10 for adjusted exponent.\n-        \/\/ Otherwise it could have +1 if negative, plus leading \"0.00000\"\n-        StringBuilder buf = sbHelper.getStringBuilder();\n-        if (signum() < 0)             \/\/ prefix '-' if negative\n-            buf.append('-');\n-        int coeffLen = coeff.length - offset;\n+            if (scale == 0) {\n+                return Long.toString(intCompact);\n+            }\n+\n+            if (scale == 2) {\n+                long highInt = intCompact \/ 100;\n+                boolean negative = intCompact < 0 & highInt == 0;\n+                int highIntSize = jla.stringSize(highInt) + (negative ? 1 : 0);\n+                byte[] buf = new byte[highIntSize + 3];\n+                if (negative) {\n+                    buf[0] = '-';\n+                }\n+                jla.getChars(highInt, highIntSize, buf);\n+                buf[highIntSize] = '.';\n+                ByteArrayLittleEndian.setShort(\n+                        buf,\n+                        highIntSize + 1,\n+                        jla.digitPair((int) Math.abs(intCompact - highInt * 100)));\n+\n+                try {\n+                    return jla.newStringNoRepl(buf, StandardCharsets.ISO_8859_1);\n+                } catch (CharacterCodingException e) {\n+                    throw new AssertionError(e);\n+                }\n+            }\n+\n+            return layoutCharsCompact(intCompact, scale, sci);\n+        }\n+\n+       return layoutCharsBigInt(intVal, scale, sci);\n+    }\n+\n+    private static String layoutCharsCompact(long intCompact, int scale, boolean sci) {\n+        long intCompactAbs;\n+        boolean negative = intCompact < 0;\n+\n+        int coeffLen = jla.stringSize(Math.abs(intCompact));\n@@ -4292,7 +4274,11 @@\n-        if ((scale >= 0) && (adjusted >= -6)) { \/\/ plain number\n-            int pad = scale - coeffLen;         \/\/ count of padding zeros\n-            if (pad >= 0) {                     \/\/ 0.xxx form\n-                buf.append('0');\n-                buf.append('.');\n-                for (; pad>0; pad--) {\n-                    buf.append('0');\n+\n+        byte[] buf;\n+        if ((scale >= 0) && (adjusted >= -6)) {\n+            int off = 0;\n+            int pad = scale - coeffLen;\n+            long rem;\n+            if (pad >= 0) { \/\/ 0.xxx form\n+                buf = new byte[coeffLen + pad + (negative ? 3 : 2)];\n+                if (negative) {\n+                    buf[0] = '-';\n+                    off = 1;\n@@ -4300,5 +4286,11 @@\n-                buf.append(coeff, offset, coeffLen);\n-            } else {                         \/\/ xx.xx form\n-                buf.append(coeff, offset, -pad);\n-                buf.append('.');\n-                buf.append(coeff, -pad + offset, scale);\n+                buf[off++] = '0';\n+                rem = Math.abs(intCompact);\n+            } else { \/\/ xx.xx form\n+                buf = new byte[coeffLen + (negative ? 2 : 1)];\n+                long power = MathUtils.pow10(scale);\n+                long div = intCompact \/ power;\n+                rem = Math.abs(intCompact - div * power);\n+                off += coeffLen - scale + (negative ? 1 : 0);\n+                jla.getChars(div, off, buf);\n+\n+                pad = scale - jla.stringSize(rem);\n@@ -4306,6 +4298,33 @@\n-        } else { \/\/ E-notation is needed\n-            if (sci) {                       \/\/ Scientific notation\n-                buf.append(coeff[offset]);   \/\/ first character\n-                if (coeffLen > 1) {          \/\/ more to come\n-                    buf.append('.');\n-                    buf.append(coeff, offset + 1, coeffLen - 1);\n+            buf[off] = '.';\n+            for (int i = 0; i < pad; ++i) {\n+                buf[off + i + 1] = '0';\n+            }\n+            jla.getChars(rem, buf.length, buf);\n+        } else {\n+            buf = layoutCharsCompact(sci, coeffLen, adjusted, negative, intCompact);\n+        }\n+\n+        try {\n+            return jla.newStringNoRepl(buf, StandardCharsets.ISO_8859_1);\n+        } catch (CharacterCodingException e) {\n+            throw new AssertionError(e);\n+        }\n+    }\n+\n+    private static byte[] layoutCharsCompact(\n+            boolean sci,\n+            int coeffLen,\n+            long adjusted,\n+            boolean negative,\n+            long intCompact\n+    ) {\n+        long intCompactAbs = Math.abs(intCompact);\n+        byte[] buf;\n+        int off = 0;\n+        if (sci) {\n+            if (coeffLen > 1) {\n+                int adjustedSize = adjusted != 0 ? jla.stringSize(Math.abs(adjusted)) + 2 : 0;\n+                buf = new byte[coeffLen + adjustedSize + (negative ? 2 : 1)];\n+                if (negative) {\n+                    buf[0] = '-';\n+                    off = 1;\n@@ -4313,10 +4332,35 @@\n-            } else {                         \/\/ Engineering notation\n-                int sig = (int)(adjusted % 3);\n-                if (sig < 0)\n-                    sig += 3;                \/\/ [adjusted was negative]\n-                adjusted -= sig;             \/\/ now a multiple of 3\n-                sig++;\n-                if (signum() == 0) {\n-                    switch (sig) {\n-                    case 1:\n-                        buf.append('0'); \/\/ exponent is a multiple of three\n+                long power = MathUtils.pow10(coeffLen - 1);\n+                long div = intCompactAbs \/ power;\n+                long rem = intCompactAbs - div * power;\n+                int remSize = jla.stringSize(rem);\n+                buf[off] = (byte) (div + '0');\n+                buf[off + 1] = '.';\n+                for (int i = 0, end = coeffLen - remSize - 1; i < end; ++i) {\n+                    buf[off + 2 + i] = '0';\n+                }\n+                jla.getChars(rem, off + coeffLen + 1, buf);\n+                off += coeffLen + 1;\n+            } else {\n+                int adjustedSize = adjusted != 0 ? jla.stringSize(Math.abs(adjusted)) + 2 : 0;\n+                buf = new byte[adjustedSize + (negative ? 2 : 1)];\n+                if (negative) {\n+                    buf[0] = '-';\n+                    off = 1;\n+                }\n+                buf[off++] = (byte) (intCompactAbs + '0');\n+            }\n+        } else {\n+            int sig = (int) (adjusted % 3);\n+            if (sig < 0) {\n+                sig += 3;                \/\/ [adjusted was negative]\n+            }\n+            adjusted -= sig;             \/\/ now a multiple of 3\n+            sig++;\n+\n+            int adjustedSize = adjusted != 0 ? jla.stringSize(Math.abs(adjusted)) + 2 : 0;\n+            if (intCompactAbs == 0) {\n+                switch (sig) {\n+                    case 1: {\n+                        buf = new byte[adjustedSize + 1];\n+                        buf[0] = '0'; \/\/ exponent is a multiple of three\n+                        off = 1;\n@@ -4324,2 +4368,2 @@\n-                    case 2:\n-                        buf.append(\"0.00\");\n+                    }\n+                    case 2: {\n@@ -4327,0 +4371,7 @@\n+                        adjustedSize = adjusted != 0 ? jla.stringSize(Math.abs(adjusted)) + 2 : 0;\n+                        buf = new byte[adjustedSize + 4];\n+                        buf[0] = '0';\n+                        buf[1] = '.';\n+                        buf[2] = '0';\n+                        buf[3] = '0';\n+                        off = 4;\n@@ -4328,2 +4379,2 @@\n-                    case 3:\n-                        buf.append(\"0.0\");\n+                    }\n+                    case 3: {\n@@ -4331,0 +4382,6 @@\n+                        adjustedSize = adjusted != 0 ? jla.stringSize(Math.abs(adjusted)) + 2 : 0;\n+                        buf = new byte[adjustedSize + 3];\n+                        buf[0] = '0';\n+                        buf[1] = '.';\n+                        buf[2] = '0';\n+                        off = 3;\n@@ -4332,0 +4389,1 @@\n+                    }\n@@ -4334,0 +4392,160 @@\n+                }\n+            } else if (sig >= coeffLen) {\n+                buf = new byte[adjustedSize + (negative ? 2 : 1) + sig - coeffLen];\n+                if (negative) {\n+                    buf[0] = '-';\n+                    off = 1;\n+                }\n+                jla.getChars(intCompactAbs, off + coeffLen, buf);\n+                off += coeffLen;\n+                for (int i = sig - coeffLen; i > 0; i--) {\n+                    buf[off++] = '0';\n+                }\n+            } else {\n+                buf = new byte[adjustedSize + (negative ? 2 : 1) + coeffLen];\n+                if (negative) {\n+                    buf[0] = '-';\n+                    off = 1;\n+                }\n+\n+                long power = MathUtils.pow10(coeffLen - sig);\n+                long div = intCompactAbs \/ power;\n+                long rem = intCompactAbs - div * power;\n+                jla.getChars(div, off + sig, buf);\n+                buf[off + sig] = '.';\n+                for (int i = sig, pad = coeffLen - jla.stringSize(rem) - sig + 1; i < pad; ++i) {\n+                    buf[off + sig + i] = '0';\n+                }\n+                jla.getChars(rem, off + coeffLen + 1, buf);\n+                off += coeffLen + 1;\n+            }\n+        }\n+\n+        if (adjusted != 0) {             \/\/ [!sci could have made 0]\n+            buf[off++] = 'E';\n+            if (adjusted > 0) {\n+                buf[off] = '+';\n+            } else {\n+                buf[off] = '-';\n+                adjusted = -adjusted;\n+            }\n+            jla.getChars(adjusted, buf.length, buf);\n+        }\n+        return buf;\n+    }\n+\n+    private static String layoutCharsBigInt(BigInteger intVal, int scale, boolean sci) {\n+        if (scale == 0) {\n+            return intVal.toString(10);\n+        }\n+\n+        BigInteger intValAbs;\n+        boolean negative = false;\n+        int signum = intVal.signum();\n+        if (signum < 0) {\n+            intValAbs = intVal.negate();\n+            negative = true;\n+        } else {\n+            intValAbs = intVal;\n+        }\n+\n+        byte[] buf;\n+        int off = 0;\n+        String intValAbsString = intValAbs.toString(10);\n+        byte[] coeff = intValAbsString.getBytes(StandardCharsets.ISO_8859_1);\n+        int coeffLen = coeff.length;\n+        long adjusted = -(long) scale + (coeffLen - 1);\n+        if ((scale >= 0) && (adjusted >= -6)) {\n+            int pad = scale - coeffLen;\n+            if (pad >= 0) {\n+                buf = new byte[coeffLen + 2 + pad + (negative ? 1 : 0)];\n+                if (negative) {\n+                    buf[0] = '-';\n+                    off = 1;\n+                }\n+                buf[off] = '0';\n+                buf[off + 1] = '.';\n+                off += 2;\n+                for (int i = 0; i < pad; i++) {\n+                    buf[off++] = '0';\n+                }\n+                System.arraycopy(coeff, 0, buf, off, coeffLen);\n+            } else {\n+                buf = new byte[coeffLen + 1 + (negative ? 1 : 0)];\n+                if (negative) {\n+                    buf[0] = '-';\n+                    off = 1;\n+                }\n+\n+                System.arraycopy(coeff, 0, buf, off, -pad);\n+                buf[off - pad] = '.';\n+                System.arraycopy(coeff, -pad, buf, off - pad + 1, scale);\n+            }\n+        } else {\n+            if (sci) {                       \/\/ Scientific notation\n+                if (coeffLen > 1) {\n+                    int adjustedSize = adjusted != 0 ? jla.stringSize(Math.abs(adjusted)) + 2 : 0;\n+                    buf = new byte[coeffLen + adjustedSize + 1 + (negative ? 1 : 0)];\n+                    if (negative) {\n+                        buf[0] = '-';\n+                        off = 1;\n+                    }\n+                    buf[off] = coeff[0];\n+                    buf[off + 1] = '.';\n+                    System.arraycopy(coeff, 1, buf, off + 2, coeffLen - 1);\n+                    off += coeffLen + 1;\n+                } else {\n+                    int adjustedSize = adjusted != 0 ? jla.stringSize(Math.abs(adjusted)) + 2 : 0;\n+                    buf = new byte[adjustedSize + (negative ? 2 : 1)];\n+                    if (negative) {\n+                        buf[0] = '-';\n+                        off = 1;\n+                    }\n+                    buf[off++] = coeff[0];\n+                }\n+            } else { \/\/ Engineering notation\n+                int sig = (int) (adjusted % 3);\n+                if (sig < 0) {\n+                    sig += 3;                \/\/ [adjusted was negative]\n+                }\n+                adjusted -= sig;             \/\/ now a multiple of 3\n+                sig++;\n+\n+                int adjustedSize = adjusted != 0 ? jla.stringSize(Math.abs(adjusted)) + 2 : 0;\n+                if (signum == 0) {\n+                    switch (sig) {\n+                        case 1: {\n+                            buf = new byte[adjustedSize + 1];\n+                            buf[0] = '0'; \/\/ exponent is a multiple of three\n+                            off = 1;\n+                            break;\n+                        }\n+                        case 2: {\n+                            adjusted += 3;\n+                            adjustedSize = adjusted != 0 ? jla.stringSize(Math.abs(adjusted)) + 2 : 0;\n+                            buf = new byte[adjustedSize + 4];\n+                            buf[0] = '0';\n+                            buf[1] = '.';\n+                            buf[2] = '0';\n+                            buf[3] = '0';\n+                            off = 4;\n+                            break;\n+                        }\n+                        case 3: {\n+                            adjusted += 3;\n+                            adjustedSize = adjusted != 0 ? jla.stringSize(Math.abs(adjusted)) + 2 : 0;\n+                            buf = new byte[adjustedSize + 3];\n+                            buf[0] = '0';\n+                            buf[1] = '.';\n+                            buf[2] = '0';\n+                            off = 3;\n+                            break;\n+                        }\n+                        default:\n+                            throw new AssertionError(\"Unexpected sig value \" + sig);\n+                    }\n+                } else if (sig >= coeffLen) { \/\/ significand all in integer\n+                    buf = new byte[adjustedSize + (negative ? 2 : 1) + sig - coeffLen];\n+                    if (negative) {\n+                        buf[0] = '-';\n+                        off = 1;\n@@ -4335,2 +4553,2 @@\n-                } else if (sig >= coeffLen) {   \/\/ significand all in integer\n-                    buf.append(coeff, offset, coeffLen);\n+                    System.arraycopy(coeff, 0, buf, off, coeffLen);\n+                    off += coeffLen;\n@@ -4339,1 +4557,1 @@\n-                        buf.append('0');\n+                        buf[off++] = '0';\n@@ -4341,4 +4559,11 @@\n-                } else {                     \/\/ xx.xxE form\n-                    buf.append(coeff, offset, sig);\n-                    buf.append('.');\n-                    buf.append(coeff, offset + sig, coeffLen - sig);\n+                } else { \/\/ xx.xxE form\n+                    buf = new byte[adjustedSize + (negative ? 2 : 1) + coeffLen];\n+                    if (negative) {\n+                        buf[0] = '-';\n+                        off = 1;\n+                    }\n+\n+                    System.arraycopy(coeff, 0, buf, off, sig);\n+                    buf[off + sig] = '.';\n+                    System.arraycopy(coeff, sig, buf, off + sig + 1, coeffLen - sig);\n+                    off += coeffLen + 1;\n@@ -4348,4 +4573,8 @@\n-                buf.append('E');\n-                if (adjusted > 0)            \/\/ force sign for positive\n-                    buf.append('+');\n-                buf.append(adjusted);\n+                buf[off++] = 'E';\n+                if (adjusted > 0) { \/\/ force sign for positive\n+                    buf[off] = '+';\n+                } else {\n+                    buf[off] = '-';\n+                    adjusted = -adjusted;\n+                }\n+                jla.getChars(adjusted, buf.length, buf);\n@@ -4354,1 +4583,6 @@\n-        return buf.toString();\n+\n+        try {\n+            return jla.newStringNoRepl(buf, StandardCharsets.ISO_8859_1);\n+        } catch (CharacterCodingException e) {\n+            throw new AssertionError(e);\n+        }\n@@ -4361,1 +4595,1 @@\n-     * @return a {@code BigInteger} with the value (10<sup>n<\/sup>)\n+     * @return a {@code BigInteger} with the value (10<sup>n<\/sutp>)\n@@ -6098,1 +6332,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/java\/math\/BigDecimal.java","additions":457,"deletions":224,"binary":false,"changes":681,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,2 @@\n+import java.nio.charset.CharacterCodingException;\n+import java.nio.charset.StandardCharsets;\n@@ -46,0 +48,2 @@\n+import jdk.internal.access.JavaLangAccess;\n+import jdk.internal.access.SharedSecrets;\n@@ -138,0 +142,2 @@\n+    private static final JavaLangAccess jla = SharedSecrets.getJavaLangAccess();\n+\n@@ -4099,0 +4105,8 @@\n+        if (mag.length <= SCHOENHAGE_BASE_CONVERSION_THRESHOLD && radix == 10) {\n+            try {\n+                return jla.newStringNoRepl(smallToString(signum < 0, abs), StandardCharsets.ISO_8859_1);\n+            } catch (CharacterCodingException e) {\n+                throw new AssertionError(e);\n+            }\n+        }\n+\n@@ -4194,0 +4208,49 @@\n+    static byte[] smallToString(boolean negative, BigInteger bigInt) {\n+        \/\/ Compute upper bound on number of digit groups and allocate space\n+        int maxNumDigitGroups = (4 * bigInt.mag.length + 6) \/ 7;\n+        long[] digitGroups = new long[maxNumDigitGroups];\n+\n+        \/\/ Translate number to string, a digit group at a time\n+        BigInteger tmp = bigInt;\n+        int numGroups = 0;\n+        while (tmp.signum != 0) {\n+            MutableBigInteger q = new MutableBigInteger();\n+            MutableBigInteger a = new MutableBigInteger(tmp.mag);\n+            digitGroups[numGroups++] = a.divideKnuthSmall(q).toLong();\n+            tmp = q.toBigInteger(1);\n+        }\n+\n+        \/\/ Get string version of first digit group\n+        long digit = digitGroups[numGroups - 1];\n+        int digitSize = jla.stringSize(digit);\n+\n+        final int digitsPerLong = 18;\n+        int bufSize = digitSize + (negative ? 1 : 0) + digitsPerLong * (numGroups - 1);\n+\n+        byte[] buf = new byte[bufSize];\n+        int off = 0;\n+        if (negative) {\n+            buf[off] = '-';\n+            off = 1;\n+        }\n+\n+        \/\/ Put first digit group into result buffer\n+        jla.getChars(digit, digitSize + off, buf);\n+        off += digitSize;\n+\n+        \/\/ Append remaining digit groups each padded with leading zeros\n+        for (int i = numGroups - 2; i >= 0; i--) {\n+            \/\/ Prepend (any) leading zeros for this digit group\n+            digit = digitGroups[i];\n+            digitSize = jla.stringSize(digit);\n+            int numLeadingZeros = digitsPerLong - digitSize;\n+            for (int j = 0; j < numLeadingZeros; j++) {\n+                buf[off + j] = '0';\n+            }\n+            jla.getChars(digit, digitsPerLong + off, buf);\n+            off += digitsPerLong;\n+        }\n+\n+        return buf;\n+    }\n+\n@@ -4689,1 +4752,1 @@\n-    private static BigInteger longRadix[] = {null, null,\n+    static final BigInteger longRadix[] = {null, null,\n@@ -4712,0 +4775,1 @@\n+    @Stable\n@@ -4716,0 +4780,1 @@\n+    @Stable\n","filename":"src\/java.base\/share\/classes\/java\/math\/BigInteger.java","additions":67,"deletions":2,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+import jdk.internal.vm.annotation.Stable;\n@@ -177,1 +178,1 @@\n-    private long toLong() {\n+    long toLong() {\n@@ -285,0 +286,25 @@\n+\n+    private final int compare(int[] bval) {\n+        if (intLen < bval.length) {\n+            return -1;\n+        }\n+\n+        if (intLen > bval.length) {\n+            return 1;\n+        }\n+\n+        \/\/ Add Integer.MIN_VALUE to make the comparison act as unsigned integer\n+        \/\/ comparison.\n+        for (int i = offset, j = 0; i < intLen + offset; i++, j++) {\n+            int b1 = value[i] + 0x80000000;\n+            int b2 = bval[j] + 0x80000000;\n+            if (b1 < b2) {\n+                return -1;\n+            }\n+            if (b1 > b2) {\n+                return 1;\n+            }\n+        }\n+        return 0;\n+    }\n+\n@@ -637,0 +663,10 @@\n+    private int divaddSmall(int[] result, int offset) {\n+        long sum = (RADIX_10_DIVISOR_1 & LONG_MASK) + (result[1 + offset] & LONG_MASK);\n+        result[1 + offset] = (int) sum;\n+\n+        sum = (RADIX_10_DIVISOR_0 & LONG_MASK) + (result[offset] & LONG_MASK) + (sum >>> 32);\n+        result[offset] = (int) sum;\n+\n+        return (int) sum >>> 32;\n+    }\n+\n@@ -658,0 +694,17 @@\n+    private int mulsubSmall(int[] q, int x, int offset) {\n+        long xLong = x & LONG_MASK;\n+        offset += 2;\n+\n+        long product = RADIX_10_DIVISOR_1 * xLong;\n+        long difference = q[offset] - product;\n+        q[offset--] = (int) difference;\n+        product = (RADIX_10_DIVISOR_0 & LONG_MASK) * xLong + (product >>> 32)\n+                + (((difference & LONG_MASK) >\n+                (((~(int) product) & LONG_MASK))) ? 1 : 0);\n+        difference = q[offset] - product;\n+        q[offset] = (int) difference;\n+        return (int) ((product >>> 32)\n+                + (((difference & LONG_MASK) >\n+                (((~(int) product) & LONG_MASK))) ? 1 : 0));\n+    }\n+\n@@ -1235,0 +1288,44 @@\n+    @Stable\n+    private static final int[] RADIX_10_SMALL_VALUE;\n+\n+    private static final int RADIX_10_DIVISOR_0;\n+    private static final int RADIX_10_DIVISOR_1;\n+\n+    static {\n+        RADIX_10_SMALL_VALUE = BigInteger.longRadix[10].mag;\n+\n+        int[] value = RADIX_10_SMALL_VALUE;\n+        int[] divisor = new int[value.length];\n+        int shift = Integer.numberOfLeadingZeros(value[0]);\n+        copyAndShift(value, 0, value.length, divisor, 0, shift);\n+\n+        RADIX_10_DIVISOR_0 = divisor[0];\n+        RADIX_10_DIVISOR_1 = divisor[1];\n+    }\n+\n+    MutableBigInteger divideKnuthSmall(MutableBigInteger quotient) {\n+        \/\/ Dividend is zero\n+        if (intLen == 0) {\n+            quotient.intLen = quotient.offset = 0;\n+            return new MutableBigInteger();\n+        }\n+\n+        int cmp = compare(RADIX_10_SMALL_VALUE);\n+        \/\/ Dividend less than divisor\n+        if (cmp < 0) {\n+            quotient.intLen = quotient.offset = 0;\n+            return new MutableBigInteger(this);\n+        }\n+\n+        \/\/ Dividend equal to divisor\n+        if (cmp == 0) {\n+            quotient.value[0] = quotient.intLen = 1;\n+            quotient.offset = 0;\n+            return new MutableBigInteger();\n+        }\n+\n+        quotient.clear();\n+\n+        return divideMagnitudeSmall(quotient);\n+    }\n+\n@@ -1678,0 +1775,178 @@\n+    private MutableBigInteger divideMagnitudeSmall(MutableBigInteger quotient) {\n+        \/\/ assert div.intLen > 1\n+        \/\/ D1 normalize the divisor\n+        MutableBigInteger rem; \/\/ Remainder starts as dividend with space for a leading zero\n+\n+        if (Integer.numberOfLeadingZeros(value[offset]) >= 4) {\n+            int[] remarr = new int[intLen + 1];\n+            rem = new MutableBigInteger(remarr);\n+            rem.intLen = intLen;\n+            rem.offset = 1;\n+            copyAndShift(value, offset, intLen, remarr, 1, 4);\n+        } else {\n+            int[] remarr = new int[intLen + 2];\n+            rem = new MutableBigInteger(remarr);\n+            rem.intLen = intLen + 1;\n+            rem.offset = 1;\n+            int rFrom = offset;\n+            int c = 0;\n+            int n2 = 28;\n+            for (int i = 1; i < intLen + 1; i++, rFrom++) {\n+                int b = c;\n+                c = value[rFrom];\n+                remarr[i] = (b << 4) | (c >>> n2);\n+            }\n+            remarr[intLen + 1] = c << 4;\n+        }\n+\n+        int nlen = rem.intLen;\n+\n+        \/\/ Set the quotient size\n+        final int limit = nlen - 2 + 1;\n+        if (quotient.value.length < limit) {\n+            quotient.value = new int[limit];\n+            quotient.offset = 0;\n+        }\n+        quotient.intLen = limit;\n+        int[] q = quotient.value;\n+\n+        \/\/ Insert leading 0 in rem\n+        rem.offset = 0;\n+        rem.value[0] = 0;\n+        rem.intLen++;\n+\n+        final int dh = RADIX_10_DIVISOR_0;\n+        long dhLong = dh & LONG_MASK;\n+        final int dl = RADIX_10_DIVISOR_1;\n+\n+        \/\/ D2 Initialize j\n+        for (int j = 0; j < limit - 1; j++) {\n+            \/\/ D3 Calculate qhat\n+            \/\/ estimate qhat\n+            int qhat = 0;\n+            int qrem = 0;\n+            boolean skipCorrection = false;\n+            int nh = rem.value[j + rem.offset];\n+            int nh2 = nh + 0x80000000;\n+            int nm = rem.value[j + 1 + rem.offset];\n+\n+            if (nh == dh) {\n+                qhat = ~0;\n+                qrem = nh + nm;\n+                skipCorrection = qrem + 0x80000000 < nh2;\n+            } else {\n+                long nChunk = (((long) nh) << 32) | (nm & LONG_MASK);\n+                if (nChunk >= 0) {\n+                    qhat = (int) (nChunk \/ dhLong);\n+                    qrem = (int) (nChunk - (qhat * dhLong));\n+                } else {\n+                    long tmp = divWord(nChunk, dh);\n+                    qhat = (int) (tmp & LONG_MASK);\n+                    qrem = (int) (tmp >>> 32);\n+                }\n+            }\n+\n+            if (qhat == 0) {\n+                continue;\n+            }\n+\n+            if (!skipCorrection) { \/\/ Correct qhat\n+                long nl = rem.value[j + 2 + rem.offset] & LONG_MASK;\n+                long rs = ((qrem & LONG_MASK) << 32) | nl;\n+                long estProduct = (dl & LONG_MASK) * (qhat & LONG_MASK);\n+\n+                if (unsignedLongCompare(estProduct, rs)) {\n+                    qhat--;\n+                    qrem = (int) ((qrem & LONG_MASK) + dhLong);\n+                    if ((qrem & LONG_MASK) >= dhLong) {\n+                        estProduct -= (dl & LONG_MASK);\n+                        rs = ((qrem & LONG_MASK) << 32) | nl;\n+                        if (unsignedLongCompare(estProduct, rs)) {\n+                            qhat--;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            \/\/ D4 Multiply and subtract\n+            rem.value[j + rem.offset] = 0;\n+            int borrow = mulsubSmall(rem.value, qhat, j + rem.offset);\n+\n+            \/\/ D5 Test remainder\n+            if (borrow + 0x80000000 > nh2) {\n+                \/\/ D6 Add back\n+                divaddSmall(rem.value, j + 1 + rem.offset);\n+                qhat--;\n+            }\n+\n+            \/\/ Store the quotient digit\n+            q[j] = qhat;\n+        } \/\/ D7 loop on j\n+        \/\/ D3 Calculate qhat\n+        \/\/ estimate qhat\n+        int qhat = 0;\n+        int qrem = 0;\n+        boolean skipCorrection = false;\n+        int nh = rem.value[limit - 1 + rem.offset];\n+        int nh2 = nh + 0x80000000;\n+        int nm = rem.value[limit + rem.offset];\n+\n+        if (nh == dh) {\n+            qhat = ~0;\n+            qrem = nh + nm;\n+            skipCorrection = qrem + 0x80000000 < nh2;\n+        } else {\n+            long nChunk = (((long) nh) << 32) | (nm & LONG_MASK);\n+            if (nChunk >= 0) {\n+                qhat = (int) (nChunk \/ dhLong);\n+                qrem = (int) (nChunk - (qhat * dhLong));\n+            } else {\n+                long tmp = divWord(nChunk, dh);\n+                qhat = (int) (tmp & LONG_MASK);\n+                qrem = (int) (tmp >>> 32);\n+            }\n+        }\n+        if (qhat != 0) {\n+            if (!skipCorrection) { \/\/ Correct qhat\n+                long nl = rem.value[limit + 1 + rem.offset] & LONG_MASK;\n+                long rs = ((qrem & LONG_MASK) << 32) | nl;\n+                long estProduct = (dl & LONG_MASK) * (qhat & LONG_MASK);\n+\n+                if (unsignedLongCompare(estProduct, rs)) {\n+                    qhat--;\n+                    qrem = (int) ((qrem & LONG_MASK) + dhLong);\n+                    if ((qrem & LONG_MASK) >= dhLong) {\n+                        estProduct -= (dl & LONG_MASK);\n+                        rs = ((qrem & LONG_MASK) << 32) | nl;\n+                        if (unsignedLongCompare(estProduct, rs)) {\n+                            qhat--;\n+                        }\n+                    }\n+                }\n+            }\n+\n+\n+            \/\/ D4 Multiply and subtract\n+            int borrow;\n+            rem.value[limit - 1 + rem.offset] = 0;\n+            borrow = mulsubSmall(rem.value, qhat, limit - 1 + rem.offset);\n+\n+            \/\/ D5 Test remainder\n+            if (borrow + 0x80000000 > nh2) {\n+                \/\/ D6 Add back\n+                divaddSmall(rem.value, limit - 1 + 1 + rem.offset);\n+                qhat--;\n+            }\n+\n+            \/\/ Store the quotient digit\n+            q[(limit - 1)] = qhat;\n+        }\n+\n+        \/\/ D8 Unnormalize\n+        rem.rightShift(4);\n+        rem.normalize();\n+\n+        quotient.normalize();\n+        return rem;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/math\/MutableBigInteger.java","additions":276,"deletions":1,"binary":false,"changes":277,"status":"modified"},{"patch":"@@ -336,0 +336,28 @@\n+    \/**\n+     * Returns the string representation size for a given long value.\n+     *\n+     * @param x long value\n+     * @return string size\n+     *\n+     *\/\n+    int stringSize(long i);\n+\n+    \/**\n+     * For values from 0 to 99 return a short encoding a pair of ASCII-encoded digit characters in little-endian,\n+     * e.g. 0 -> ('0' << 8 | '0'). Used for formatting\n+     *\/\n+    short digitPair(int i);\n+\n+    \/**\n+     * Places characters representing the long i into the\n+     * character array buf. The characters are placed into\n+     * the buffer backwards starting with the least significant\n+     * digit at the specified index (exclusive), and working\n+     * backwards from there.\n+     *\n+     * @param i     value to convert\n+     * @param index next index, after the least significant digit\n+     * @param buf   target buffer, Latin1-encoded\n+     *\/\n+    void getChars(long i, int index, byte[] buf);\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":28,"deletions":0,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n-final class MathUtils {\n+public final class MathUtils {\n@@ -85,0 +85,1 @@\n+        1_000_000_000_000_000_000L,\n@@ -94,1 +95,1 @@\n-    static long pow10(int e) {\n+    public static long pow10(int e) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/math\/MathUtils.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -65,1 +65,0 @@\n-\n@@ -70,0 +69,7 @@\n+            {\"9223372036854775808\", \"9223372036854775808\"},\n+            {\"12345678901234567890\", \"12345678901234567890\"},\n+            {\"12345678901234567890.45\", \"12345678901234567890.45\"},\n+            {\"123.45\", \"123.45\"},\n+            {\"325839.59583387\", \"325839.59583387\"},\n+            {\"3.575021438741279610\", \"3.575021438741279610\"},\n+            {\"1234567890000012345678900000001234567890000000123456789000000000000000000000000.45\", \"1234567890000012345678900000001234567890000000123456789000000000000000000000000.45\"},\n","filename":"test\/jdk\/java\/math\/BigDecimal\/ToPlainStringTests.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,122 @@\n+ \/*\n+  * Copyright (c) 2004, 2023, Oracle and\/or its affiliates. All rights reserved.\n+  * Copyright (c) 2023, Alibaba Group Holding Limited. All rights reserved.\n+  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+  *\n+  * This code is free software; you can redistribute it and\/or modify it\n+  * under the terms of the GNU General Public License version 2 only, as\n+  * published by the Free Software Foundation.\n+  *\n+  * This code is distributed in the hope that it will be useful, but WITHOUT\n+  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+  * version 2 for more details (a copy is included in the LICENSE file that\n+  * accompanied this code).\n+  *\n+  * You should have received a copy of the GNU General Public License version\n+  * 2 along with this work; if not, write to the Free Software Foundation,\n+  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+  *\n+  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+  * or visit www.oracle.com if you need additional information or have any\n+  * questions.\n+  *\/\n+\n+\/*\n+ * @test\n+ * @summary Basic tests of toString & toEngineeringString method\n+ * @run main ToStringTests\n+ * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:+EliminateAutoBox -XX:AutoBoxCacheMax=20000 ToStringTests\n+ * @author shaojin.wensj@alibaba-inc.com\n+ *\/\n+\n+import java.math.BigDecimal;\n+\n+public class ToStringTests {\n+    public static void main(String argv[]) {\n+        String[][] testCases = {\n+                {\"0\", \"0\", \"0\"},\n+                {\"1\", \"1\", \"1\"},\n+                {\"10\", \"10\", \"10\"},\n+                {\"2e1\", \"2E+1\", \"20\"},\n+                {\"3e2\", \"3E+2\", \"300\"},\n+                {\"4e3\", \"4E+3\", \"4E+3\"},\n+                {\"5e4\", \"5E+4\", \"50E+3\"},\n+                {\"6e5\", \"6E+5\", \"600E+3\"},\n+                {\"7e6\", \"7E+6\", \"7E+6\"},\n+                {\"8e7\", \"8E+7\", \"80E+6\"},\n+                {\"9e8\", \"9E+8\", \"900E+6\"},\n+                {\"1e9\", \"1E+9\", \"1E+9\"},\n+\n+                {\".0\", \"0.0\", \"0.0\"},\n+                {\".1\", \"0.1\", \"0.1\"},\n+                {\".10\", \"0.10\", \"0.10\"},\n+                {\"1e-1\", \"0.1\", \"0.1\"},\n+                {\"1e-1\", \"0.1\", \"0.1\"},\n+                {\"2e-2\", \"0.02\", \"0.02\"},\n+                {\"3e-3\", \"0.003\", \"0.003\"},\n+                {\"4e-4\", \"0.0004\", \"0.0004\"},\n+                {\"5e-5\", \"0.00005\", \"0.00005\"},\n+                {\"6e-6\", \"0.000006\", \"0.000006\"},\n+                {\"7e-7\", \"7E-7\", \"700E-9\"},\n+                {\"8e-8\", \"8E-8\", \"80E-9\"},\n+                {\"9e-9\", \"9E-9\", \"9E-9\"},\n+                {\"9000e-12\", \"9.000E-9\", \"9.000E-9\"},\n+\n+                {\"9000e-22\", \"9.000E-19\", \"900.0E-21\"},\n+                {\"12345678901234567890\", \"12345678901234567890\", \"12345678901234567890\"},\n+                {\"12345678901234567890e22\", \"1.2345678901234567890E+41\", \"123.45678901234567890E+39\"},\n+                {\"12345678901234567890e-22\", \"0.0012345678901234567890\", \"0.0012345678901234567890\"},\n+                {\"9223372036854775808\", \"9223372036854775808\", \"9223372036854775808\"},\n+                {\"12345678901234567890\", \"12345678901234567890\", \"12345678901234567890\"},\n+                {\"12345678901234567890.45\", \"12345678901234567890.45\", \"12345678901234567890.45\"},\n+                {\"123.45\", \"123.45\", \"123.45\"},\n+                {\"1.0E+2147483649\", \"1.0E+2147483649\", \"1.0E+2147483649\"},\n+                {\"325839.59583387\", \"325839.59583387\", \"325839.59583387\"},\n+                {\"3.575021438741279610\", \"3.575021438741279610\", \"3.575021438741279610\"},\n+                {\n+                        \"1234567890000012345678900000001234567890000000123456789000000000000000000000000.45\",\n+                        \"1234567890000012345678900000001234567890000000123456789000000000000000000000000.45\",\n+                        \"1234567890000012345678900000001234567890000000123456789000000000000000000000000.45\"\n+                }\n+        };\n+\n+        int errors = 0;\n+        for (String[] testCase : testCases) {\n+            BigDecimal bd = new BigDecimal(testCase[0]);\n+            String s;\n+\n+            if (!(s = bd.toString()).equals(testCase[1])) {\n+                errors++;\n+                System.err.println(\"Unexpected result ``\" +\n+                        s + \"'', expect ``\" + testCase[1] + \"'' from BigDecimal \" +\n+                        bd);\n+            }\n+            if (!(s = bd.toEngineeringString()).equals(testCase[2])) {\n+                errors++;\n+                System.err.println(\"Unexpected engineering result ``\" +\n+                        s + \"'', expect ``\" + testCase[2] + \"'' from BigDecimal \" +\n+                        testCase[0]);\n+            }\n+\n+            bd = new BigDecimal(\"-\" + testCase[0]);\n+            if (bd.signum() != 0 && !(s = (bd.toString())).equals(\"-\" + testCase[1])) {\n+                errors++;\n+                System.err.println(\"Unexpected result ``\" +\n+                        s + \"'', expect ``\" + testCase[1] + \"'' from BigDecimal \" +\n+                        bd);\n+            }\n+\n+            if (bd.signum() != 0 && !(s = (bd.toEngineeringString())).equals(\"-\" + testCase[2])) {\n+                errors++;\n+                System.err.println(\"Unexpected engineering result ``\" +\n+                        s + \"'', expect ``\" + testCase[2] + \"'' from BigDecimal \" +\n+                        bd);\n+            }\n+        }\n+\n+        if (errors > 0) {\n+            throw new RuntimeException(errors + \" errors during run.\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/math\/BigDecimal\/ToStringTests.java","additions":122,"deletions":0,"binary":false,"changes":122,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,0 +38,3 @@\n+import sun.misc.Unsafe;\n+\n+import java.lang.reflect.Field;\n@@ -145,0 +148,16 @@\n+    @Benchmark\n+    @OperationsPerInvocation(TEST_SIZE)\n+    public void testToPlainString(Blackhole bh) {\n+        for (BigDecimal s : bigDecimals) {\n+            bh.consume(s.toPlainString());\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(TEST_SIZE)\n+    public void testToEngineeringString(Blackhole bh) {\n+        for (BigDecimal s : bigDecimals) {\n+            bh.consume(s.toEngineeringString());\n+        }\n+    }\n+\n@@ -216,0 +235,16 @@\n+    @Benchmark\n+    @OperationsPerInvocation(TEST_SIZE)\n+    public void testHugeToPlainString(Blackhole bh) {\n+        for (BigDecimal s : hugeArray) {\n+            bh.consume(s.toPlainString());\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(TEST_SIZE)\n+    public void testHugeToEngineeringString(Blackhole bh) {\n+        for (BigDecimal s : hugeArray) {\n+            bh.consume(s.toEngineeringString());\n+        }\n+    }\n+\n@@ -225,0 +260,16 @@\n+    @Benchmark\n+    @OperationsPerInvocation(TEST_SIZE)\n+    public void testLargeToPlainString(Blackhole bh) {\n+        for (BigDecimal s : largeArray) {\n+            bh.consume(s.toPlainString());\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(TEST_SIZE)\n+    public void testLargeToEngineeringString(Blackhole bh) {\n+        for (BigDecimal s : largeArray) {\n+            bh.consume(s.toEngineeringString());\n+        }\n+    }\n+\n@@ -233,0 +284,16 @@\n+\n+    @Benchmark\n+    @OperationsPerInvocation(TEST_SIZE)\n+    public void testSmallToPlainString(Blackhole bh) {\n+        for (BigDecimal s : smallArray) {\n+            bh.consume(s.toPlainString());\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(TEST_SIZE)\n+    public void testSmallToEngineeringString(Blackhole bh) {\n+        for (BigDecimal s : smallArray) {\n+            bh.consume(s.toEngineeringString());\n+        }\n+    }\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/math\/BigDecimals.java","additions":68,"deletions":1,"binary":false,"changes":69,"status":"modified"}]}