{"files":[{"patch":"@@ -699,0 +699,7 @@\n+    static String newStringLatin1NoRepl(byte[] bytes) {\n+        if (COMPACT_STRINGS) {\n+            return new String(bytes, LATIN1);\n+        }\n+        return new String(StringLatin1.inflate(bytes, 0, bytes.length), UTF16);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/String.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2486,0 +2486,16 @@\n+            public String newStringLatin1NoRepl(byte[] bytes) {\n+                return String.newStringLatin1NoRepl(bytes);\n+            }\n+\n+            public int stringSize(long i) {\n+                return Long.stringSize(i);\n+            }\n+\n+            public void getChars(long i, int index, byte[] buf) {\n+                StringLatin1.getChars(i, index, buf);\n+            }\n+\n+            public short digit(int i) {\n+                return StringLatin1.PACKED_DIGITS[i];\n+            }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-import static jdk.internal.misc.Unsafe.ARRAY_BYTE_BASE_OFFSET;\n@@ -37,0 +36,1 @@\n+import jdk.internal.math.MathUtils;\n@@ -38,0 +38,1 @@\n+import jdk.internal.util.ByteArrayLittleEndian;\n@@ -319,1 +320,0 @@\n-    private static final Unsafe UNSAFE = Unsafe.getUnsafe();\n@@ -426,23 +426,0 @@\n-    @Stable\n-    static final short[] PACKED_DIGITS;\n-    static {\n-        short[] shorts = new short[]{\n-                0x3030, 0x3130, 0x3230, 0x3330, 0x3430, 0x3530, 0x3630, 0x3730, 0x3830, 0x3930,\n-                0x3031, 0x3131, 0x3231, 0x3331, 0x3431, 0x3531, 0x3631, 0x3731, 0x3831, 0x3931,\n-                0x3032, 0x3132, 0x3232, 0x3332, 0x3432, 0x3532, 0x3632, 0x3732, 0x3832, 0x3932,\n-                0x3033, 0x3133, 0x3233, 0x3333, 0x3433, 0x3533, 0x3633, 0x3733, 0x3833, 0x3933,\n-                0x3034, 0x3134, 0x3234, 0x3334, 0x3434, 0x3534, 0x3634, 0x3734, 0x3834, 0x3934,\n-                0x3035, 0x3135, 0x3235, 0x3335, 0x3435, 0x3535, 0x3635, 0x3735, 0x3835, 0x3935,\n-                0x3036, 0x3136, 0x3236, 0x3336, 0x3436, 0x3536, 0x3636, 0x3736, 0x3836, 0x3936,\n-                0x3037, 0x3137, 0x3237, 0x3337, 0x3437, 0x3537, 0x3637, 0x3737, 0x3837, 0x3937,\n-                0x3038, 0x3138, 0x3238, 0x3338, 0x3438, 0x3538, 0x3638, 0x3738, 0x3838, 0x3938,\n-                0x3039, 0x3139, 0x3239, 0x3339, 0x3439, 0x3539, 0x3639, 0x3739, 0x3839, 0x3939\n-        };\n-        if (ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) {\n-            for (int i = 0; i < shorts.length; i++) {\n-                shorts[i] = Short.reverseBytes(shorts[i]);\n-            }\n-        }\n-        PACKED_DIGITS = shorts;\n-    }\n-\n@@ -3507,5 +3484,2 @@\n-        if (scale == 0) {\n-            return (intCompact != INFLATED) ?\n-                    Long.toString(intCompact) :\n-                    intVal.toString(10);\n-        }\n+        final long intCompact = this.intCompact;\n+        final int scale = this.scale;\n@@ -3514,1 +3488,40 @@\n-            return toPlainStringCompact(intCompact, scale);\n+            if (scale == 0) {\n+                return Long.toString(intCompact);\n+            }\n+\n+            final boolean negative = intCompact < 0;\n+            int size = jla.stringSize(intCompact);\n+\n+            byte[] buf;\n+            int off = 0;\n+            if (scale < 0) {\n+                buf = new byte[size - scale];\n+                jla.getChars(intCompact, off + size, buf);\n+                Arrays.fill(buf, off + size, buf.length, (byte) '0');\n+            } else {\n+                int insertionPoint = size - (negative ? 1 : 0) - scale;\n+                if (insertionPoint <= 0) {\n+                    buf = new byte[size - insertionPoint + 2];\n+                    if (negative) {\n+                        buf[0] = '-';\n+                        off = 1;\n+                    }\n+                    buf[off] = '0';\n+                    buf[off + 1] = '.';\n+\n+                    for (int i = 0; i < -insertionPoint; i++) {\n+                        buf[off + i + 2] = '0';\n+                    }\n+                    jla.getChars(Math.abs(intCompact), buf.length, buf);\n+                } else {\n+                    long power = MathUtils.pow10(scale);\n+                    long div = intCompact \/ power;\n+                    buf = new byte[size + 1];\n+                    int divOff = off + size - scale;\n+                    jla.getChars(div, divOff, buf);\n+                    buf[divOff] = '.';\n+                    jla.getChars(Math.abs(intCompact - div * power), buf.length, buf);\n+                }\n+            }\n+\n+            return jla.newStringLatin1NoRepl(buf);\n@@ -3516,0 +3529,1 @@\n+\n@@ -3521,0 +3535,4 @@\n+        if (scale == 0) {\n+            return intVal.toString(10);\n+        }\n+\n@@ -3576,66 +3594,1 @@\n-        try {\n-            return jla.newStringNoRepl(buf, StandardCharsets.ISO_8859_1);\n-        } catch (CharacterCodingException x) {\n-            throw new Error(x);\n-        }\n-    }\n-\n-    private static String toPlainStringCompact(long intCompact, int scale) {\n-        final boolean negative;\n-        final long intCompactAbs;\n-        if (intCompact < 0) {\n-            intCompactAbs = -intCompact;\n-            negative = true;\n-        } else {\n-            intCompactAbs = intCompact;\n-            negative = false;\n-        }\n-\n-        int size = stringSize(intCompactAbs);\n-\n-        byte[] buf;\n-        int off = 0;\n-        if (scale < 0) {\n-            buf = new byte[size - scale + (negative ? 1 : 0)];\n-            if (negative) {\n-                buf[0] = '-';\n-                off = 1;\n-            }\n-            getChars(intCompactAbs, off + size, buf);\n-            Arrays.fill(buf, off + size, buf.length, (byte) '0');\n-        } else {\n-            int insertionPoint = size - scale;\n-            if (insertionPoint <= 0) {\n-                buf = new byte[size - insertionPoint + (negative ? 3 : 2)];\n-                if (negative) {\n-                    buf[0] = '-';\n-                    off = 1;\n-                }\n-                buf[off] = '0';\n-                buf[off + 1] = '.';\n-\n-                for (int i = 0; i < -insertionPoint; i++) {\n-                    buf[off + i + 2] = '0';\n-                }\n-                getChars(intCompactAbs, buf.length, buf);\n-            } else {\n-                long power = POWER_TEN[scale - 1];\n-                long div = intCompactAbs \/ power;\n-                long rem = intCompactAbs - div * power;\n-                buf = new byte[size + (negative ? 2 : 1)];\n-                if (negative) {\n-                    buf[0] = '-';\n-                    off = 1;\n-                }\n-                int divOff = off + size - scale;\n-                getChars(div, divOff, buf);\n-                buf[divOff] = '.';\n-                getChars(rem, buf.length, buf);\n-            }\n-        }\n-\n-        try {\n-            return jla.newStringNoRepl(buf, StandardCharsets.ISO_8859_1);\n-        } catch (CharacterCodingException x) {\n-            throw new Error(x);\n-        }\n+        return jla.newStringLatin1NoRepl(buf);\n@@ -4273,6 +4226,1 @@\n-        if (scale == 0) {                     \/\/ zero scale is trivial\n-            return (intCompact != INFLATED) ?\n-                    Long.toString(intCompact) :\n-                    intVal.toString();\n-        }\n-\n+        final long intCompact = this.intCompact;\n@@ -4280,9 +4228,3 @@\n-            if (scale == 2) {\n-                long intCompactAbs;\n-                boolean negative = false;\n-                if (intCompact < 0) {\n-                    intCompactAbs = -intCompact;\n-                    negative = true;\n-                } else {\n-                    intCompactAbs = intCompact;\n-                }\n+            if (scale == 0) {\n+                return Long.toString(intCompact);\n+            }\n@@ -4290,3 +4232,4 @@\n-                long highInt = intCompactAbs \/ 100;\n-                short lowInt = (short) (intCompactAbs - highInt * 100);\n-                int highIntSize = stringSize(highInt) + (negative ? 1 : 0);\n+            if (scale == 2) {\n+                long highInt = intCompact \/ 100;\n+                boolean negative = intCompact < 0 & highInt == 0;\n+                int highIntSize = jla.stringSize(highInt) + (negative ? 1 : 0);\n@@ -4297,1 +4240,1 @@\n-                getChars(highInt, highIntSize, buf);\n+                jla.getChars(highInt, highIntSize, buf);\n@@ -4299,1 +4242,4 @@\n-                UNSAFE.putShortUnaligned(buf, Unsafe.ARRAY_BYTE_BASE_OFFSET + highIntSize + 1, PACKED_DIGITS[lowInt], false);\n+                ByteArrayLittleEndian.setShort(\n+                        buf,\n+                        highIntSize + 1,\n+                        jla.digit((int) Math.abs(intCompact - highInt * 100)));\n@@ -4301,5 +4247,1 @@\n-                try {\n-                    return jla.newStringNoRepl(buf, StandardCharsets.ISO_8859_1);\n-                } catch (CharacterCodingException x) {\n-                    throw new Error(x);\n-                }\n+                return jla.newStringLatin1NoRepl(buf);\n@@ -4308,1 +4250,1 @@\n-            return layoutChars(intCompact, scale, sci);\n+            return layoutCharsCompact(intCompact, scale, sci);\n@@ -4311,1 +4253,1 @@\n-       return layoutChars(intVal, scale, sci);\n+       return layoutCharsBigInt(intVal, scale, sci);\n@@ -4314,5 +4256,1 @@\n-    private static String layoutChars(long intCompact, int scale, boolean sci) {\n-        if (scale == 0) {\n-            return Long.toString(intCompact);\n-        }\n-\n+    private static String layoutCharsCompact(long intCompact, int scale, boolean sci) {\n@@ -4320,7 +4258,1 @@\n-        boolean negative = false;\n-        if (intCompact < 0) {\n-            intCompactAbs = -intCompact;\n-            negative = true;\n-        } else {\n-            intCompactAbs = intCompact;\n-        }\n+        boolean negative = intCompact < 0;\n@@ -4328,2 +4260,2 @@\n-        int coeffLen = stringSize(intCompactAbs);\n-        long adjusted = -(long) scale + (coeffLen - 1);\n+        int coeffLen = jla.stringSize(Math.abs(intCompact));\n+        int adjusted = coeffLen - scale - 1;\n@@ -4332,1 +4264,0 @@\n-        int off = 0;\n@@ -4334,0 +4265,1 @@\n+            int off = 0;\n@@ -4335,0 +4267,1 @@\n+            long rem;\n@@ -4341,7 +4274,2 @@\n-                buf[off] = '0';\n-                buf[off + 1] = '.';\n-                off += 2;\n-                for (int i = 0; i < pad; i++) {\n-                    buf[off++] = '0';\n-                }\n-                getChars(intCompactAbs, buf.length, buf);\n+                buf[off++] = '0';\n+                rem = Math.abs(intCompact);\n@@ -4350,0 +4278,34 @@\n+                long power = MathUtils.pow10(scale);\n+                long div = intCompact \/ power;\n+                rem = Math.abs(intCompact - div * power);\n+                jla.getChars(div, off + coeffLen - scale, buf);\n+                off += coeffLen - scale;\n+\n+                pad = scale - jla.stringSize(rem);\n+            }\n+            buf[off] = '.';\n+            for (int i = 0; i < pad; ++i) {\n+                buf[off + i + 1] = '0';\n+            }\n+            jla.getChars(rem, buf.length, buf);\n+        } else {\n+            buf = layoutCharsCompact(sci, coeffLen, adjusted, negative, intCompact);\n+        }\n+\n+        return jla.newStringLatin1NoRepl(buf);\n+    }\n+\n+    private static byte[] layoutCharsCompact(\n+            boolean sci,\n+            int coeffLen,\n+            int adjusted,\n+            boolean negative,\n+            long intCompact\n+    ) {\n+        long intCompactAbs = Math.abs(intCompact);\n+        byte[] buf;\n+        int off = 0;\n+        if (sci) {\n+            if (coeffLen > 1) {\n+                int adjustedSize = adjusted != 0 ? jla.stringSize(Math.abs(adjusted)) + 2 : 0;\n+                buf = new byte[coeffLen + adjustedSize + (negative ? 2 : 1)];\n@@ -4354,2 +4316,1 @@\n-\n-                long power = POWER_TEN[scale - 1];\n+                long power = MathUtils.pow10(coeffLen - 1);\n@@ -4358,6 +4319,14 @@\n-                int remSize = stringSize(rem);\n-                getChars(div, off + coeffLen - scale, buf);\n-                off += coeffLen - scale;\n-                buf[off] = '.';\n-                for (int i = 0, end = scale - remSize; i < end; ++i) {\n-                    buf[off + 1 + i] = '0';\n+                int remSize = jla.stringSize(rem);\n+                buf[off] = (byte) (div + '0');\n+                buf[off + 1] = '.';\n+                for (int i = 0, end = coeffLen - remSize - 1; i < end; ++i) {\n+                    buf[off + 2 + i] = '0';\n+                }\n+                jla.getChars(rem, off + coeffLen + 1, buf);\n+                off += coeffLen + 1;\n+            } else {\n+                int adjustedSize = adjusted != 0 ? jla.stringSize(Math.abs(adjusted)) + 2 : 0;\n+                buf = new byte[adjustedSize + (negative ? 2 : 1)];\n+                if (negative) {\n+                    buf[0] = '-';\n+                    off = 1;\n@@ -4365,1 +4334,1 @@\n-                getChars(rem, buf.length, buf);\n+                buf[off++] = (byte) (intCompactAbs + '0');\n@@ -4368,6 +4337,13 @@\n-            if (sci) {\n-                if (coeffLen > 1) {\n-                    int adjustedSize = adjusted != 0 ? stringSize(Math.abs(adjusted)) + 2 : 0;\n-                    buf = new byte[coeffLen + adjustedSize + (negative ? 2 : 1)];\n-                    if (negative) {\n-                        buf[0] = '-';\n+            int sig = adjusted % 3;\n+            if (sig < 0) {\n+                sig += 3;                \/\/ [adjusted was negative]\n+            }\n+            adjusted -= sig;             \/\/ now a multiple of 3\n+            sig++;\n+\n+            int adjustedSize = adjusted != 0 ? jla.stringSize(Math.abs(adjusted)) + 2 : 0;\n+            if (intCompactAbs == 0) {\n+                switch (sig) {\n+                    case 1: {\n+                        buf = new byte[adjustedSize + 1];\n+                        buf[0] = '0'; \/\/ exponent is a multiple of three\n@@ -4375,0 +4351,1 @@\n+                        break;\n@@ -4376,8 +4353,10 @@\n-                    long power = POWER_TEN[coeffLen - 2];\n-                    long div = intCompactAbs \/ power;\n-                    long rem = intCompactAbs - div * power;\n-                    int remSize = stringSize(rem);\n-                    buf[off] = (byte) (div + '0');\n-                    buf[off + 1] = '.';\n-                    for (int i = 0, end = coeffLen - remSize - 1; i < end; ++i) {\n-                        buf[off + 2 + i] = '0';\n+                    case 2: {\n+                        adjusted += 3;\n+                        adjustedSize = adjusted != 0 ? jla.stringSize(Math.abs(adjusted)) + 2 : 0;\n+                        buf = new byte[adjustedSize + 4];\n+                        buf[0] = '0';\n+                        buf[1] = '.';\n+                        buf[2] = '0';\n+                        buf[3] = '0';\n+                        off = 4;\n+                        break;\n@@ -4385,8 +4364,9 @@\n-                    getChars(rem, off + coeffLen + 1, buf);\n-                    off += coeffLen + 1;\n-                } else {\n-                    int adjustedSize = adjusted != 0 ? stringSize(Math.abs(adjusted)) + 2 : 0;\n-                    buf = new byte[adjustedSize + (negative ? 2 : 1)];\n-                    if (negative) {\n-                        buf[0] = '-';\n-                        off = 1;\n+                    case 3: {\n+                        adjusted += 3;\n+                        adjustedSize = adjusted != 0 ? jla.stringSize(Math.abs(adjusted)) + 2 : 0;\n+                        buf = new byte[adjustedSize + 3];\n+                        buf[0] = '0';\n+                        buf[1] = '.';\n+                        buf[2] = '0';\n+                        off = 3;\n+                        break;\n@@ -4394,1 +4374,2 @@\n-                    buf[off++] = (byte) (intCompactAbs + '0');\n+                    default:\n+                        throw new AssertionError(\"Unexpected sig value \" + sig);\n@@ -4396,4 +4377,5 @@\n-            } else {\n-                int sig = (int) (adjusted % 3);\n-                if (sig < 0) {\n-                    sig += 3;                \/\/ [adjusted was negative]\n+            } else if (sig >= coeffLen) {\n+                buf = new byte[adjustedSize + (negative ? 2 : 1) + sig - coeffLen];\n+                if (negative) {\n+                    buf[0] = '-';\n+                    off = 1;\n@@ -4401,64 +4383,10 @@\n-                adjusted -= sig;             \/\/ now a multiple of 3\n-                sig++;\n-\n-                int adjustedSize = adjusted != 0 ? stringSize(Math.abs(adjusted)) + 2 : 0;\n-                if (intCompactAbs == 0) {\n-                    switch (sig) {\n-                        case 1: {\n-                            buf = new byte[adjustedSize + 1];\n-                            buf[0] = '0'; \/\/ exponent is a multiple of three\n-                            off = 1;\n-                            break;\n-                        }\n-                        case 2: {\n-                            adjusted += 3;\n-                            adjustedSize = adjusted != 0 ? stringSize(Math.abs(adjusted)) + 2 : 0;\n-                            buf = new byte[adjustedSize + 4];\n-                            buf[0] = '0';\n-                            buf[1] = '.';\n-                            buf[2] = '0';\n-                            buf[3] = '0';\n-                            off = 4;\n-                            break;\n-                        }\n-                        case 3: {\n-                            adjusted += 3;\n-                            adjustedSize = adjusted != 0 ? stringSize(Math.abs(adjusted)) + 2 : 0;\n-                            buf = new byte[adjustedSize + 3];\n-                            buf[0] = '0';\n-                            buf[1] = '.';\n-                            buf[2] = '0';\n-                            off = 3;\n-                            break;\n-                        }\n-                        default:\n-                            throw new AssertionError(\"Unexpected sig value \" + sig);\n-                    }\n-                } else if (sig >= coeffLen) {\n-                    buf = new byte[adjustedSize + (negative ? 2 : 1) + sig - coeffLen];\n-                    if (negative) {\n-                        buf[0] = '-';\n-                        off = 1;\n-                    }\n-                    getChars(intCompactAbs, off + coeffLen, buf);\n-                    off += coeffLen;\n-                    for (int i = sig - coeffLen; i > 0; i--) {\n-                        buf[off++] = '0';\n-                    }\n-                } else {\n-                    buf = new byte[adjustedSize + (negative ? 2 : 1) + coeffLen];\n-                    if (negative) {\n-                        buf[0] = '-';\n-                        off = 1;\n-                    }\n-\n-                    long power = POWER_TEN[coeffLen - sig - 1];\n-                    long div = intCompactAbs \/ power;\n-                    long rem = intCompactAbs - div * power;\n-                    getChars(div, off + sig, buf);\n-                    buf[off + sig] = '.';\n-                    for (int i = sig, end = coeffLen - stringSize(rem) - sig + 1; i < end; ++i) {\n-                        buf[off + sig + i] = '0';\n-                    }\n-                    getChars(rem, off + coeffLen + 1, buf);\n-                    off += coeffLen + 1;\n+                jla.getChars(intCompactAbs, off + coeffLen, buf);\n+                off += coeffLen;\n+                for (int i = sig - coeffLen; i > 0; i--) {\n+                    buf[off++] = '0';\n+                }\n+            } else {\n+                buf = new byte[adjustedSize + (negative ? 2 : 1) + coeffLen];\n+                if (negative) {\n+                    buf[0] = '-';\n+                    off = 1;\n@@ -4466,1 +4394,0 @@\n-            }\n@@ -4468,7 +4395,7 @@\n-            if (adjusted != 0) {             \/\/ [!sci could have made 0]\n-                buf[off++] = 'E';\n-                if (adjusted > 0) {\n-                    buf[off] = '+';\n-                } else {\n-                    buf[off] = '-';\n-                    adjusted = -adjusted;\n+                long power = MathUtils.pow10(coeffLen - sig);\n+                long div = intCompactAbs \/ power;\n+                long rem = intCompactAbs - div * power;\n+                jla.getChars(div, off + sig, buf);\n+                buf[off + sig] = '.';\n+                for (int i = sig, pad = coeffLen - jla.stringSize(rem) - sig + 1; i < pad; ++i) {\n+                    buf[off + sig + i] = '0';\n@@ -4476,1 +4403,2 @@\n-                getChars(adjusted, buf.length, buf);\n+                jla.getChars(rem, off + coeffLen + 1, buf);\n+                off += coeffLen + 1;\n@@ -4480,4 +4408,9 @@\n-        try {\n-            return jla.newStringNoRepl(buf, StandardCharsets.ISO_8859_1);\n-        } catch (CharacterCodingException x) {\n-            throw new Error(x);\n+        if (adjusted != 0) {             \/\/ [!sci could have made 0]\n+            buf[off++] = 'E';\n+            if (adjusted > 0) {\n+                buf[off] = '+';\n+            } else {\n+                buf[off] = '-';\n+                adjusted = -adjusted;\n+            }\n+            jla.getChars(adjusted, buf.length, buf);\n@@ -4485,0 +4418,1 @@\n+        return buf;\n@@ -4487,1 +4421,1 @@\n-    private static String layoutChars(BigInteger intVal, int scale, boolean sci) {\n+    private static String layoutCharsBigInt(BigInteger intVal, int scale, boolean sci) {\n@@ -4489,1 +4423,1 @@\n-            return intVal.toString();\n+            return intVal.toString(10);\n@@ -4537,1 +4471,1 @@\n-                    int adjustedSize = adjusted != 0 ? stringSize(Math.abs(adjusted)) + 2 : 0;\n+                    int adjustedSize = adjusted != 0 ? jla.stringSize(Math.abs(adjusted)) + 2 : 0;\n@@ -4548,1 +4482,1 @@\n-                    int adjustedSize = adjusted != 0 ? stringSize(Math.abs(adjusted)) + 2 : 0;\n+                    int adjustedSize = adjusted != 0 ? jla.stringSize(Math.abs(adjusted)) + 2 : 0;\n@@ -4564,1 +4498,1 @@\n-                int adjustedSize = adjusted != 0 ? stringSize(Math.abs(adjusted)) + 2 : 0;\n+                int adjustedSize = adjusted != 0 ? jla.stringSize(Math.abs(adjusted)) + 2 : 0;\n@@ -4575,1 +4509,1 @@\n-                            adjustedSize = adjusted != 0 ? stringSize(Math.abs(adjusted)) + 2 : 0;\n+                            adjustedSize = adjusted != 0 ? jla.stringSize(Math.abs(adjusted)) + 2 : 0;\n@@ -4586,1 +4520,1 @@\n-                            adjustedSize = adjusted != 0 ? stringSize(Math.abs(adjusted)) + 2 : 0;\n+                            adjustedSize = adjusted != 0 ? jla.stringSize(Math.abs(adjusted)) + 2 : 0;\n@@ -4630,1 +4564,1 @@\n-                getChars(adjusted, buf.length, buf);\n+                jla.getChars(adjusted, buf.length, buf);\n@@ -4634,5 +4568,1 @@\n-        try {\n-            return jla.newStringNoRepl(buf, StandardCharsets.ISO_8859_1);\n-        } catch (CharacterCodingException x) {\n-            throw new Error(x);\n-        }\n+        return jla.newStringLatin1NoRepl(buf);\n@@ -6382,71 +6312,0 @@\n-\n-    @Stable\n-    static final long[] POWER_TEN = {\n-            10,\n-            100,\n-            1000,\n-            10000,\n-            100000,\n-            1000000,\n-            10000000,\n-            100000000,\n-            1000000000,\n-            10000000000L,\n-            100000000000L,\n-            1000000000000L,\n-            10000000000000L,\n-            100000000000000L,\n-            1000000000000000L,\n-            10000000000000000L,\n-            100000000000000000L,\n-            1000000000000000000L,\n-    };\n-\n-    \/\/ Requires positive x\n-    static int stringSize(long x) {\n-        long p = 10;\n-        for (int i = 1; i < 19; i++) {\n-            if (x < p) {\n-                return i;\n-            }\n-            p = 10 * p;\n-        }\n-        return 19;\n-    }\n-\n-    \/\/ Requires positive x\n-    static void getChars(long i, int index, byte[] buf) {\n-        long q;\n-        int charPos = index;\n-\n-        assert i >= 0 : \"i >= 0\";\n-\n-        \/\/ Get 2 digits\/iteration using longs until quotient fits into an int\n-        while (i > Integer.MAX_VALUE) {\n-            q = i \/ 100;\n-            charPos -= 2;\n-            assert charPos >= 0 && charPos < buf.length : \"Trusted caller missed bounds check\";\n-            UNSAFE.putShortUnaligned(buf, Unsafe.ARRAY_BYTE_BASE_OFFSET + charPos, PACKED_DIGITS[(int) (i - q * 100)], false);\n-            i = q;\n-        }\n-\n-        \/\/ Get 2 digits\/iteration using ints\n-        int q2;\n-        int i2 = (int) i;\n-        while (i2 >= 100) {\n-            q2 = i2 \/ 100;\n-            charPos -= 2;\n-            assert charPos >= 0 && charPos < buf.length : \"Trusted caller missed bounds check\";\n-            UNSAFE.putShortUnaligned(buf, Unsafe.ARRAY_BYTE_BASE_OFFSET + charPos, PACKED_DIGITS[i2 - q2 * 100], false);\n-            i2 = q2;\n-        }\n-\n-        \/\/ We know there are at most two digits left at this point.\n-        if (i2 > 9) {\n-            charPos -= 2;\n-            assert charPos >= 0 && charPos < buf.length : \"Trusted caller missed bounds check\";\n-            UNSAFE.putShortUnaligned(buf, Unsafe.ARRAY_BYTE_BASE_OFFSET + charPos, PACKED_DIGITS[i2], false);\n-        } else {\n-            buf[--charPos] = (byte) ('0' + i2);\n-        }\n-    }\n","filename":"src\/java.base\/share\/classes\/java\/math\/BigDecimal.java","additions":202,"deletions":343,"binary":false,"changes":545,"status":"modified"},{"patch":"@@ -4106,6 +4106,3 @@\n-            byte[] buf = smallToString(signum < 0, abs);\n-            try {\n-                return jla.newStringNoRepl(buf, StandardCharsets.ISO_8859_1);\n-            } catch (CharacterCodingException x) {\n-                throw new Error(x);\n-            }\n+            return jla.newStringLatin1NoRepl(\n+                    smallToString(signum < 0, abs)\n+            );\n@@ -4220,2 +4217,1 @@\n-            MutableBigInteger b = new MutableBigInteger(longRadix10Mag);\n-            digitGroups[numGroups++] = a.divideKnuth(b, q, true).toLong();\n+            digitGroups[numGroups++] = a.divideKnuthSmall(q).toLong();\n@@ -4227,1 +4223,1 @@\n-        int digitSize = BigDecimal.stringSize(digit);\n+        int digitSize = jla.stringSize(digit);\n@@ -4234,1 +4230,0 @@\n-\/\/        StringBuilder buf = new StringBuilder(bufSize);\n@@ -4241,1 +4236,1 @@\n-        BigDecimal.getChars(digit, digitSize + off, buf);\n+        jla.getChars(digit, digitSize + off, buf);\n@@ -4248,1 +4243,1 @@\n-            digitSize = BigDecimal.stringSize(digit);\n+            digitSize = jla.stringSize(digit);\n@@ -4253,1 +4248,1 @@\n-            BigDecimal.getChars(digit, digitsPerLong + off, buf);\n+            jla.getChars(digit, digitsPerLong + off, buf);\n@@ -4755,1 +4750,1 @@\n-    private static BigInteger longRadix[] = {null, null,\n+    static final BigInteger longRadix[] = {null, null,\n@@ -4775,3 +4770,0 @@\n-    @Stable\n-    static final int[] longRadix10Mag = new int[]{232830643, -1486618624};\n-\n","filename":"src\/java.base\/share\/classes\/java\/math\/BigInteger.java","additions":9,"deletions":17,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+import jdk.internal.vm.annotation.Stable;\n@@ -285,0 +286,25 @@\n+\n+    private final int compare(int[] bval) {\n+        if (intLen < bval.length) {\n+            return -1;\n+        }\n+\n+        if (intLen > bval.length) {\n+            return 1;\n+        }\n+\n+        \/\/ Add Integer.MIN_VALUE to make the comparison act as unsigned integer\n+        \/\/ comparison.\n+        for (int i = offset, j = 0; i < intLen + offset; i++, j++) {\n+            int b1 = value[i] + 0x80000000;\n+            int b2 = bval[j] + 0x80000000;\n+            if (b1 < b2) {\n+                return -1;\n+            }\n+            if (b1 > b2) {\n+                return 1;\n+            }\n+        }\n+        return 0;\n+    }\n+\n@@ -637,0 +663,10 @@\n+    private int divaddSmall(int[] result, int offset) {\n+        long sum = (RADIX_10_DIVISOR_1 & LONG_MASK) + (result[1 + offset] & LONG_MASK);\n+        result[1 + offset] = (int) sum;\n+\n+        sum = (RADIX_10_DIVISOR_0 & LONG_MASK) + (result[offset] & LONG_MASK) + (sum >>> 32);\n+        result[offset] = (int) sum;\n+\n+        return (int) sum >>> 32;\n+    }\n+\n@@ -658,0 +694,17 @@\n+    private int mulsubSmall(int[] q, int x, int offset) {\n+        long xLong = x & LONG_MASK;\n+        offset += 2;\n+\n+        long product = RADIX_10_DIVISOR_1 * xLong;\n+        long difference = q[offset] - product;\n+        q[offset--] = (int) difference;\n+        product = (RADIX_10_DIVISOR_0 & LONG_MASK) * xLong + (product >>> 32)\n+                + (((difference & LONG_MASK) >\n+                (((~(int) product) & LONG_MASK))) ? 1 : 0);\n+        difference = q[offset] - product;\n+        q[offset] = (int) difference;\n+        return (int) ((product >>> 32)\n+                + (((difference & LONG_MASK) >\n+                (((~(int) product) & LONG_MASK))) ? 1 : 0));\n+    }\n+\n@@ -1235,0 +1288,44 @@\n+    @Stable\n+    private static final int[] RADIX_10_SMALL_VALUE;\n+\n+    private static final int RADIX_10_DIVISOR_0;\n+    private static final int RADIX_10_DIVISOR_1;\n+\n+    static {\n+        RADIX_10_SMALL_VALUE = BigInteger.longRadix[10].mag;\n+\n+        int[] value = RADIX_10_SMALL_VALUE;\n+        int[] divisor = new int[value.length];\n+        int shift = Integer.numberOfLeadingZeros(value[0]);\n+        copyAndShift(value, 0, value.length, divisor, 0, shift);\n+\n+        RADIX_10_DIVISOR_0 = divisor[0];\n+        RADIX_10_DIVISOR_1 = divisor[1];\n+    }\n+\n+    MutableBigInteger divideKnuthSmall(MutableBigInteger quotient) {\n+        \/\/ Dividend is zero\n+        if (intLen == 0) {\n+            quotient.intLen = quotient.offset = 0;\n+            return new MutableBigInteger();\n+        }\n+\n+        int cmp = compare(RADIX_10_SMALL_VALUE);\n+        \/\/ Dividend less than divisor\n+        if (cmp < 0) {\n+            quotient.intLen = quotient.offset = 0;\n+            return new MutableBigInteger(this);\n+        }\n+\n+        \/\/ Dividend equal to divisor\n+        if (cmp == 0) {\n+            quotient.value[0] = quotient.intLen = 1;\n+            quotient.offset = 0;\n+            return new MutableBigInteger();\n+        }\n+\n+        quotient.clear();\n+\n+        return divideMagnitudeSmall(quotient);\n+    }\n+\n@@ -1678,0 +1775,178 @@\n+    private MutableBigInteger divideMagnitudeSmall(MutableBigInteger quotient) {\n+        \/\/ assert div.intLen > 1\n+        \/\/ D1 normalize the divisor\n+        MutableBigInteger rem; \/\/ Remainder starts as dividend with space for a leading zero\n+\n+        if (Integer.numberOfLeadingZeros(value[offset]) >= 4) {\n+            int[] remarr = new int[intLen + 1];\n+            rem = new MutableBigInteger(remarr);\n+            rem.intLen = intLen;\n+            rem.offset = 1;\n+            copyAndShift(value, offset, intLen, remarr, 1, 4);\n+        } else {\n+            int[] remarr = new int[intLen + 2];\n+            rem = new MutableBigInteger(remarr);\n+            rem.intLen = intLen + 1;\n+            rem.offset = 1;\n+            int rFrom = offset;\n+            int c = 0;\n+            int n2 = 28;\n+            for (int i = 1; i < intLen + 1; i++, rFrom++) {\n+                int b = c;\n+                c = value[rFrom];\n+                remarr[i] = (b << 4) | (c >>> n2);\n+            }\n+            remarr[intLen + 1] = c << 4;\n+        }\n+\n+        int nlen = rem.intLen;\n+\n+        \/\/ Set the quotient size\n+        final int limit = nlen - 2 + 1;\n+        if (quotient.value.length < limit) {\n+            quotient.value = new int[limit];\n+            quotient.offset = 0;\n+        }\n+        quotient.intLen = limit;\n+        int[] q = quotient.value;\n+\n+        \/\/ Insert leading 0 in rem\n+        rem.offset = 0;\n+        rem.value[0] = 0;\n+        rem.intLen++;\n+\n+        final int dh = RADIX_10_DIVISOR_0;\n+        long dhLong = dh & LONG_MASK;\n+        final int dl = RADIX_10_DIVISOR_1;\n+\n+        \/\/ D2 Initialize j\n+        for (int j = 0; j < limit - 1; j++) {\n+            \/\/ D3 Calculate qhat\n+            \/\/ estimate qhat\n+            int qhat = 0;\n+            int qrem = 0;\n+            boolean skipCorrection = false;\n+            int nh = rem.value[j + rem.offset];\n+            int nh2 = nh + 0x80000000;\n+            int nm = rem.value[j + 1 + rem.offset];\n+\n+            if (nh == dh) {\n+                qhat = ~0;\n+                qrem = nh + nm;\n+                skipCorrection = qrem + 0x80000000 < nh2;\n+            } else {\n+                long nChunk = (((long) nh) << 32) | (nm & LONG_MASK);\n+                if (nChunk >= 0) {\n+                    qhat = (int) (nChunk \/ dhLong);\n+                    qrem = (int) (nChunk - (qhat * dhLong));\n+                } else {\n+                    long tmp = divWord(nChunk, dh);\n+                    qhat = (int) (tmp & LONG_MASK);\n+                    qrem = (int) (tmp >>> 32);\n+                }\n+            }\n+\n+            if (qhat == 0) {\n+                continue;\n+            }\n+\n+            if (!skipCorrection) { \/\/ Correct qhat\n+                long nl = rem.value[j + 2 + rem.offset] & LONG_MASK;\n+                long rs = ((qrem & LONG_MASK) << 32) | nl;\n+                long estProduct = (dl & LONG_MASK) * (qhat & LONG_MASK);\n+\n+                if (unsignedLongCompare(estProduct, rs)) {\n+                    qhat--;\n+                    qrem = (int) ((qrem & LONG_MASK) + dhLong);\n+                    if ((qrem & LONG_MASK) >= dhLong) {\n+                        estProduct -= (dl & LONG_MASK);\n+                        rs = ((qrem & LONG_MASK) << 32) | nl;\n+                        if (unsignedLongCompare(estProduct, rs)) {\n+                            qhat--;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            \/\/ D4 Multiply and subtract\n+            rem.value[j + rem.offset] = 0;\n+            int borrow = mulsubSmall(rem.value, qhat, j + rem.offset);\n+\n+            \/\/ D5 Test remainder\n+            if (borrow + 0x80000000 > nh2) {\n+                \/\/ D6 Add back\n+                divaddSmall(rem.value, j + 1 + rem.offset);\n+                qhat--;\n+            }\n+\n+            \/\/ Store the quotient digit\n+            q[j] = qhat;\n+        } \/\/ D7 loop on j\n+        \/\/ D3 Calculate qhat\n+        \/\/ estimate qhat\n+        int qhat = 0;\n+        int qrem = 0;\n+        boolean skipCorrection = false;\n+        int nh = rem.value[limit - 1 + rem.offset];\n+        int nh2 = nh + 0x80000000;\n+        int nm = rem.value[limit + rem.offset];\n+\n+        if (nh == dh) {\n+            qhat = ~0;\n+            qrem = nh + nm;\n+            skipCorrection = qrem + 0x80000000 < nh2;\n+        } else {\n+            long nChunk = (((long) nh) << 32) | (nm & LONG_MASK);\n+            if (nChunk >= 0) {\n+                qhat = (int) (nChunk \/ dhLong);\n+                qrem = (int) (nChunk - (qhat * dhLong));\n+            } else {\n+                long tmp = divWord(nChunk, dh);\n+                qhat = (int) (tmp & LONG_MASK);\n+                qrem = (int) (tmp >>> 32);\n+            }\n+        }\n+        if (qhat != 0) {\n+            if (!skipCorrection) { \/\/ Correct qhat\n+                long nl = rem.value[limit + 1 + rem.offset] & LONG_MASK;\n+                long rs = ((qrem & LONG_MASK) << 32) | nl;\n+                long estProduct = (dl & LONG_MASK) * (qhat & LONG_MASK);\n+\n+                if (unsignedLongCompare(estProduct, rs)) {\n+                    qhat--;\n+                    qrem = (int) ((qrem & LONG_MASK) + dhLong);\n+                    if ((qrem & LONG_MASK) >= dhLong) {\n+                        estProduct -= (dl & LONG_MASK);\n+                        rs = ((qrem & LONG_MASK) << 32) | nl;\n+                        if (unsignedLongCompare(estProduct, rs)) {\n+                            qhat--;\n+                        }\n+                    }\n+                }\n+            }\n+\n+\n+            \/\/ D4 Multiply and subtract\n+            int borrow;\n+            rem.value[limit - 1 + rem.offset] = 0;\n+            borrow = mulsubSmall(rem.value, qhat, limit - 1 + rem.offset);\n+\n+            \/\/ D5 Test remainder\n+            if (borrow + 0x80000000 > nh2) {\n+                \/\/ D6 Add back\n+                divaddSmall(rem.value, limit - 1 + 1 + rem.offset);\n+                qhat--;\n+            }\n+\n+            \/\/ Store the quotient digit\n+            q[(limit - 1)] = qhat;\n+        }\n+\n+        \/\/ D8 Unnormalize\n+        rem.rightShift(4);\n+        rem.normalize();\n+\n+        quotient.normalize();\n+        return rem;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/math\/MutableBigInteger.java","additions":275,"deletions":0,"binary":false,"changes":275,"status":"modified"},{"patch":"@@ -336,0 +336,39 @@\n+    \/**\n+     * Returns a new string by decoding from the given latin1 bytes array.\n+     *\n+     * The caller of this method shall relinquish and transfer the ownership of\n+     * the byte array to the callee since the later will not make a copy.\n+     *\n+     * @param bytes the byte array source\n+     * @return the newly created string\n+     * @throws IllegalArgumentException for malformed or unmappable bytes.\n+     *\/\n+    String newStringLatin1NoRepl(byte[] bytes);\n+\n+    \/**\n+     * Returns the string representation size for a given long value.\n+     *\n+     * @param x long value\n+     * @return string size\n+     *\n+     *\/\n+    int stringSize(long i);\n+\n+    \/**\n+     * Pack the two ascii characters corresponding to the value from 0 to 100 into a short\n+     *\/\n+    short digit(int i);\n+\n+    \/**\n+     * Places characters representing the long i into the\n+     * character array buf. The characters are placed into\n+     * the buffer backwards starting with the least significant\n+     * digit at the specified index (exclusive), and working\n+     * backwards from there.\n+     *\n+     * @param i     value to convert\n+     * @param index next index, after the least significant digit\n+     * @param buf   target buffer, Latin1-encoded\n+     *\/\n+    void getChars(long i, int index, byte[] buf);\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":39,"deletions":0,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n-final class MathUtils {\n+public final class MathUtils {\n@@ -94,1 +94,1 @@\n-    static long pow10(int e) {\n+    public static long pow10(int e) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/math\/MathUtils.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"}]}