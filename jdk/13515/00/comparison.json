{"files":[{"patch":"@@ -226,4 +226,0 @@\n-  \/\/ _is_marked_dependent can be set concurrently, thus cannot be part of the\n-  \/\/ _misc_flags right now.\n-  bool            _is_marked_dependent;     \/\/ used for marking during flushing and deoptimization\n-\n@@ -234,1 +230,1 @@\n-  \/\/ State is set while executing, eventually atomically to not disturb other state\n+  \/\/ State is set either at parse time or while executing, atomically to not disturb other state\n@@ -534,2 +530,2 @@\n-  bool is_marked_dependent() const         { return _is_marked_dependent; }\n-  void set_is_marked_dependent(bool value) { _is_marked_dependent = value; }\n+  bool is_marked_dependent() const         { return _misc_flags.is_marked_dependent(); }\n+  void set_is_marked_dependent(bool value) { _misc_flags.set_is_marked_dependent(value); }\n@@ -684,10 +680,2 @@\n-  bool is_being_redefined() const          {\n-    return _access_flags.is_being_redefined();\n-  }\n-  void set_is_being_redefined(bool value)  {\n-    if (value) {\n-      _access_flags.set_is_being_redefined();\n-    } else {\n-      _access_flags.clear_is_being_redefined();\n-    }\n-  }\n+  bool is_being_redefined() const          { return _misc_flags.is_being_redefined(); }\n+  void set_is_being_redefined(bool value)  { _misc_flags.set_is_being_redefined(value); }\n@@ -719,7 +707,2 @@\n-  bool has_resolved_methods() const {\n-    return _access_flags.has_resolved_methods();\n-  }\n-\n-  void set_has_resolved_methods() {\n-    _access_flags.set_has_resolved_methods();\n-  }\n+  bool has_resolved_methods() const { return _misc_flags.has_resolved_methods(); }\n+  void set_has_resolved_methods()   { _misc_flags.set_has_resolved_methods(true); }\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":7,"deletions":24,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"runtime\/atomic.hpp\"\n@@ -32,0 +33,21 @@\n+\/\/ This can be removed for the atomic bitset functions, when available.\n+void InstanceKlassFlags::atomic_set_bits(u1 bits) {\n+  \/\/ Atomically update the status with the bits given\n+  u1 old_status, new_status, f;\n+  do {\n+    old_status = _status;\n+    new_status = old_status | bits;\n+    f = Atomic::cmpxchg(&_status, old_status, new_status);\n+  } while(f != old_status);\n+}\n+\n+void InstanceKlassFlags::atomic_clear_bits(u1 bits) {\n+  \/\/ Atomically update the status with the bits given\n+  u1 old_status, new_status, f;\n+  do {\n+    old_status = _status;\n+    new_status = old_status & ~bits;\n+    f = Atomic::cmpxchg(&_status, old_status, new_status);\n+  } while(f != old_status);\n+}\n+\n","filename":"src\/hotspot\/share\/oops\/instanceKlassFlags.cpp","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -30,0 +30,6 @@\n+\/\/ The InstanceKlassFlags class contains the parse-time and writeable flags associated with\n+\/\/ an InstanceKlass, and their associated accessors.\n+\/\/ _flags are parse-time and constant in the InstanceKlass after that.  _status are set at runtime and\n+\/\/ require atomic access.\n+\/\/ These flags are JVM internal and not part of the AccessFlags classfile specification.\n+\n@@ -38,12 +44,9 @@\n-    flag(unused                             , 1 << 3) \/* not currently used *\/ \\\n-    flag(is_contended                       , 1 << 4) \/* marked with contended annotation *\/ \\\n-    flag(has_nonstatic_concrete_methods     , 1 << 5) \/* class\/superclass\/implemented interfaces has non-static, concrete methods *\/ \\\n-    flag(declares_nonstatic_concrete_methods, 1 << 6) \/* directly declares non-static, concrete methods *\/ \\\n-    flag(has_been_redefined                 , 1 << 7) \/* class has been redefined *\/ \\\n-    flag(shared_loading_failed              , 1 << 8) \/* class has been loaded from shared archive *\/ \\\n-    flag(is_scratch_class                   , 1 << 9) \/* class is the redefined scratch class *\/ \\\n-    flag(is_shared_boot_class               , 1 << 10) \/* defining class loader is boot class loader *\/ \\\n-    flag(is_shared_platform_class           , 1 << 11) \/* defining class loader is platform class loader *\/ \\\n-    flag(is_shared_app_class                , 1 << 12) \/* defining class loader is app class loader *\/ \\\n-    flag(has_contended_annotations          , 1 << 13) \/* has @Contended annotation *\/ \\\n-    flag(has_localvariable_table            , 1 << 14) \/* has localvariable information *\/\n+    flag(is_contended                       , 1 << 3) \/* marked with contended annotation *\/ \\\n+    flag(has_nonstatic_concrete_methods     , 1 << 4) \/* class\/superclass\/implemented interfaces has non-static, concrete methods *\/ \\\n+    flag(declares_nonstatic_concrete_methods, 1 << 5) \/* directly declares non-static, concrete methods *\/ \\\n+    flag(shared_loading_failed              , 1 << 6) \/* class has been loaded from shared archive *\/ \\\n+    flag(is_shared_boot_class               , 1 << 7) \/* defining class loader is boot class loader *\/ \\\n+    flag(is_shared_platform_class           , 1 << 8) \/* defining class loader is platform class loader *\/ \\\n+    flag(is_shared_app_class                , 1 << 9) \/* defining class loader is app class loader *\/ \\\n+    flag(has_contended_annotations          , 1 << 10) \/* has @Contended annotation *\/ \\\n+    flag(has_localvariable_table            , 1 << 11) \/* has localvariable information *\/\n@@ -57,0 +60,13 @@\n+#define IK_STATUS_DO(status)  \\\n+    status(is_being_redefined                , 1 << 0) \/* True if the klass is being redefined *\/ \\\n+    status(has_resolved_methods              , 1 << 1) \/* True if the klass has resolved MethodHandle methods *\/ \\\n+    status(has_been_redefined                , 1 << 2) \/* class has been redefined *\/ \\\n+    status(is_scratch_class                  , 1 << 3) \/* class is the redefined scratch class *\/ \\\n+    status(is_marked_dependent               , 1 << 4) \/* class is the redefined scratch class *\/\n+\n+#define IK_STATUS_ENUM_NAME(name, value)    _misc_##name = value,\n+  enum {\n+    IK_STATUS_DO(IK_STATUS_ENUM_NAME)\n+  };\n+#undef IK_STATUS_ENUM_NAME\n+\n@@ -64,0 +80,3 @@\n+  \/\/ These flags are written during execution so require atomic stores\n+  u1 _status;\n+\n@@ -90,0 +109,20 @@\n+\n+  \/\/ Create getters and setters for the status values.\n+#define IK_STATUS_GET(name, ignore)          \\\n+  bool name() const { return (_status & _misc_##name) != 0; }\n+  IK_STATUS_DO(IK_STATUS_GET)\n+#undef IK_STATUS_GET\n+\n+#define IK_STATUS_SET(name, ignore)   \\\n+  void set_##name(bool b) {         \\\n+    if (b) { \\\n+      atomic_set_bits(_misc_##name); \\\n+    } else { \\\n+      atomic_clear_bits(_misc_##name); \\\n+    } \\\n+  }\n+  IK_STATUS_DO(IK_STATUS_SET)\n+#undef IK_STATUS_SET\n+\n+  void atomic_set_bits(u1 bits);\n+  void atomic_clear_bits(u1 bits);\n","filename":"src\/hotspot\/share\/oops\/instanceKlassFlags.hpp","additions":51,"deletions":12,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -239,1 +239,0 @@\n-  nonstatic_field(InstanceKlass,               _is_marked_dependent,                          bool)                                  \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -72,2 +72,0 @@\n-  JVM_ACC_IS_BEING_REDEFINED      = 0x00100000,     \/\/ True if the klass is being redefined.\n-  JVM_ACC_HAS_RESOLVED_METHODS    = 0x00200000,     \/\/ True if the klass has resolved methods\n@@ -138,7 +136,0 @@\n-  bool is_being_redefined() const       { return (_flags & JVM_ACC_IS_BEING_REDEFINED) != 0; }\n-  void set_is_being_redefined()         { atomic_set_bits(JVM_ACC_IS_BEING_REDEFINED); }\n-  void clear_is_being_redefined()       { atomic_clear_bits(JVM_ACC_IS_BEING_REDEFINED); }\n-\n-  bool has_resolved_methods() const     { return (_flags & JVM_ACC_HAS_RESOLVED_METHODS) != 0; }\n-  void set_has_resolved_methods()       { atomic_set_bits(JVM_ACC_HAS_RESOLVED_METHODS); }\n-\n","filename":"src\/hotspot\/share\/utilities\/accessFlags.hpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -83,1 +83,0 @@\n-    isMarkedDependent    = new CIntField(type.getCIntegerField(\"_is_marked_dependent\"), 0);\n@@ -148,1 +147,0 @@\n-  private static CIntField isMarkedDependent;\n@@ -376,1 +374,0 @@\n-  public boolean   getIsMarkedDependent()   { return                isMarkedDependent.getValue(this) != 0; }\n@@ -574,1 +571,0 @@\n-      visitor.doCInt(isMarkedDependent, true);\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/InstanceKlass.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"}]}