{"files":[{"patch":"@@ -47,0 +47,1 @@\n+import static java.lang.Thread.State.*;\n@@ -57,6 +58,0 @@\n-    \/\/ long running interruptible task\n-    private static final Callable<Void> SLEEP_FOR_A_DAY = () -> {\n-        Thread.sleep(Duration.ofDays(1));\n-        return null;\n-    };\n-\n@@ -95,8 +90,0 @@\n-    \/**\n-     * Schedules a thread to be interrupted after the given delay.\n-     *\/\n-    private void scheduleInterrupt(Thread thread, Duration delay) {\n-        long millis = delay.toMillis();\n-        scheduler.schedule(thread::interrupt, millis, TimeUnit.MILLISECONDS);\n-    }\n-\n@@ -167,1 +154,1 @@\n-            Future<?> result = executor.submit(SLEEP_FOR_A_DAY);\n+            Future<Void> future = executor.submit(new LongRunningTask<Void>());\n@@ -174,1 +161,1 @@\n-                result.cancel(true);\n+                future.cancel(true);  \/\/ interrupt task\n@@ -190,1 +177,2 @@\n-            Future<?> result = executor.submit(SLEEP_FOR_A_DAY);\n+            var task = new LongRunningTask<Void>();\n+            Future<Void> future = executor.submit(task);\n@@ -192,0 +180,2 @@\n+                task.awaitStarted();\n+\n@@ -196,1 +186,1 @@\n-                Throwable e = assertThrows(ExecutionException.class, result::get);\n+                Throwable e = assertThrows(ExecutionException.class, future::get);\n@@ -202,1 +192,1 @@\n-                result.cancel(true);\n+                future.cancel(true);\n@@ -239,1 +229,1 @@\n-     * Invoke close with interrupt status set, should cancel task.\n+     * Invoke close with interrupt status set.\n@@ -244,1 +234,1 @@\n-        Future<?> future;\n+        Future<Void> future;\n@@ -246,1 +236,3 @@\n-            future = executor.submit(SLEEP_FOR_A_DAY);\n+            var task = new LongRunningTask<Void>();\n+            future = executor.submit(task);\n+            task.awaitStarted();\n@@ -251,1 +243,0 @@\n-\n@@ -254,2 +245,3 @@\n-        assertTrue(executor.awaitTermination(10,  TimeUnit.MILLISECONDS));\n-        assertThrows(ExecutionException.class, future::get);\n+        assertTrue(executor.awaitTermination(10, TimeUnit.MILLISECONDS));\n+        Throwable e = assertThrows(ExecutionException.class, future::get);\n+        assertTrue(e.getCause() instanceof InterruptedException);\n@@ -264,1 +256,1 @@\n-        Future<?> future;\n+        Future<Void> future;\n@@ -266,2 +258,4 @@\n-            future = executor.submit(SLEEP_FOR_A_DAY);\n-            scheduleInterrupt(Thread.currentThread(), Duration.ofMillis(500));\n+            var task = new LongRunningTask<Void>();\n+            future = executor.submit(task);\n+            task.awaitStarted();\n+            scheduleInterruptAt(\"java.util.concurrent.ThreadPerTaskExecutor.close\");\n@@ -273,2 +267,3 @@\n-        assertTrue(executor.awaitTermination(10,  TimeUnit.MILLISECONDS));\n-        assertThrows(ExecutionException.class, future::get);\n+        assertTrue(executor.awaitTermination(10, TimeUnit.MILLISECONDS));\n+        Throwable e = assertThrows(ExecutionException.class, future::get);\n+        assertTrue(e.getCause() instanceof InterruptedException);\n@@ -305,1 +300,1 @@\n-        Future<?> result = executor.submit(barrier::arriveAndAwaitAdvance);\n+        Future<?> future = executor.submit(barrier::arriveAndAwaitAdvance);\n@@ -312,1 +307,1 @@\n-            result.cancel(true);\n+            future.cancel(true);\n@@ -387,2 +382,0 @@\n-            AtomicBoolean task2Started = new AtomicBoolean();\n-            AtomicReference<Throwable> task2Exception = new AtomicReference<>();\n@@ -390,9 +383,1 @@\n-            Callable<String> task2 = () -> {\n-                task2Started.set(true);\n-                try {\n-                    Thread.sleep(Duration.ofDays(1));\n-                } catch (Exception e) {\n-                    task2Exception.set(e);\n-                }\n-                return \"bar\";\n-            };\n+            var task2 = new LongRunningTask<String>();\n@@ -402,7 +387,4 @@\n-            \/\/ if task2 started then the sleep should have been interrupted\n-            if (task2Started.get()) {\n-                Throwable exc;\n-                while ((exc = task2Exception.get()) == null) {\n-                    Thread.sleep(20);\n-                }\n-                assertTrue(exc instanceof InterruptedException);\n+            \/\/ if task2 started then it should be interrupted\n+            if (task2.isStarted()) {\n+                task2.awaitDone();\n+                assertTrue(task2.isInterrupted());\n@@ -513,2 +495,0 @@\n-            AtomicBoolean task2Started = new AtomicBoolean();\n-            AtomicReference<Throwable> task2Exception = new AtomicReference<>();\n@@ -516,9 +496,1 @@\n-            Callable<String> task2 = () -> {\n-                task2Started.set(true);\n-                try {\n-                    Thread.sleep(Duration.ofDays(1));\n-                } catch (Exception e) {\n-                    task2Exception.set(e);\n-                }\n-                return \"bar\";\n-            };\n+            var task2 = new LongRunningTask<String>();\n@@ -528,7 +500,4 @@\n-            \/\/ if task2 started then the sleep should have been interrupted\n-            if (task2Started.get()) {\n-                Throwable exc;\n-                while ((exc = task2Exception.get()) == null) {\n-                    Thread.sleep(20);\n-                }\n-                assertTrue(exc instanceof InterruptedException);\n+            \/\/ if task2 started then it should be interrupted\n+            if (task2.isStarted()) {\n+                task2.awaitDone();\n+                assertTrue(task2.isInterrupted());\n@@ -606,9 +575,1 @@\n-            Callable<String> task1 = () -> {\n-                Thread.sleep(Duration.ofMinutes(1));\n-                return \"foo\";\n-            };\n-            Callable<String> task2 = () -> {\n-                Thread.sleep(Duration.ofMinutes(2));\n-                return \"bar\";\n-            };\n-            scheduleInterrupt(Thread.currentThread(), Duration.ofMillis(500));\n+            var task = new LongRunningTask<Void>();\n@@ -616,1 +577,2 @@\n-                executor.invokeAny(Set.of(task1, task2));\n+                scheduleInterruptAt(\"java.util.concurrent.ThreadPerTaskExecutor.invokeAny\");\n+                executor.invokeAny(Set.of(task));\n@@ -620,0 +582,6 @@\n+\n+                \/\/ if task started then it should be interrupted\n+                if (task.isStarted()) {\n+                    task.awaitDone();\n+                    assertTrue(task.isInterrupted());\n+                }\n@@ -809,1 +777,1 @@\n-     * Test invokeAll with interrupt status set.\n+     * Test untimed-invokeAll with interrupt status set.\n@@ -820,1 +788,0 @@\n-\n@@ -859,1 +826,1 @@\n-     * Test interrupt with thread blocked in invokeAll.\n+     * Test interrupt of thread blocked in untimed-invokeAll.\n@@ -865,3 +832,1 @@\n-            Callable<String> task1 = () -> \"foo\";\n-            DelayedResult<String> task2 = new DelayedResult(\"bar\", Duration.ofMinutes(1));\n-            scheduleInterrupt(Thread.currentThread(), Duration.ofMillis(500));\n+            var task = new LongRunningTask<Void>();\n@@ -869,1 +834,2 @@\n-                executor.invokeAll(Set.of(task1, task2));\n+                scheduleInterruptAt(\"java.util.concurrent.ThreadPerTaskExecutor.invokeAll\");\n+                executor.invokeAll(Set.of(task));\n@@ -874,3 +840,4 @@\n-                \/\/ task2 should have been interrupted\n-                while (!task2.isDone()) {\n-                    Thread.sleep(Duration.ofMillis(100));\n+                \/\/ if task started then it should be interrupted\n+                if (task.isStarted()) {\n+                    task.awaitDone();\n+                    assertTrue(task.isInterrupted());\n@@ -878,1 +845,0 @@\n-                assertTrue(task2.exception() instanceof InterruptedException);\n@@ -886,1 +852,1 @@\n-     * Test interrupt with thread blocked in timed-invokeAll.\n+     * Test interrupt of thread blocked in timed-invokeAll.\n@@ -890,1 +856,1 @@\n-    void testInvokeAllInterrupt6(ExecutorService executor) throws Exception {\n+    void testInvokeAllInterrupt5(ExecutorService executor) throws Exception {\n@@ -892,3 +858,1 @@\n-            Callable<String> task1 = () -> \"foo\";\n-            DelayedResult<String> task2 = new DelayedResult(\"bar\", Duration.ofMinutes(1));\n-            scheduleInterrupt(Thread.currentThread(), Duration.ofMillis(500));\n+            var task = new LongRunningTask<Void>();\n@@ -896,1 +860,2 @@\n-                executor.invokeAll(Set.of(task1, task2), 1, TimeUnit.DAYS);\n+                scheduleInterruptAt(\"java.util.concurrent.ThreadPerTaskExecutor.invokeAll\");\n+                executor.invokeAll(Set.of(task), 1, TimeUnit.DAYS);\n@@ -901,3 +866,4 @@\n-                \/\/ task2 should have been interrupted\n-                while (!task2.isDone()) {\n-                    Thread.sleep(Duration.ofMillis(100));\n+                \/\/ if task started then it should be interrupted\n+                if (task.isStarted()) {\n+                    task.awaitDone();\n+                    assertTrue(task.isInterrupted());\n@@ -905,1 +871,0 @@\n-                assertTrue(task2.exception() instanceof InterruptedException);\n@@ -1043,12 +1008,11 @@\n-    \/\/ -- supporting classes --\n-\n-    static class DelayedResult<T> implements Callable<T> {\n-        final T result;\n-        final Duration delay;\n-        volatile boolean done;\n-        volatile Exception exception;\n-        DelayedResult(T result, Duration delay) {\n-            this.result = result;\n-            this.delay = delay;\n-        }\n-        public T call() throws Exception {\n+    \/**\n+     * Schedules the current thread to be interrupted when it waits (timed or untimed)\n+     * at the given location \"{@code c.m}\" where {@code c} is the fully qualified class\n+     * name and {@code m} is the method name.\n+     *\/\n+    private void scheduleInterruptAt(String location) {\n+        int index = location.lastIndexOf('.');\n+        String className = location.substring(0, index);\n+        String methodName = location.substring(index + 1);\n+        Thread target = Thread.currentThread();\n+        scheduler.submit(() -> {\n@@ -1056,2 +1020,12 @@\n-                Thread.sleep(delay);\n-                return result;\n+                boolean found = false;\n+                while (!found) {\n+                    Thread.State state = target.getState();\n+                    assertTrue(state != TERMINATED);\n+                    if ((state == WAITING || state == TIMED_WAITING)\n+                            && contains(target.getStackTrace(), className, methodName)) {\n+                        found = true;\n+                    } else {\n+                        Thread.sleep(20);\n+                    }\n+                }\n+                target.interrupt();\n@@ -1059,1 +1033,31 @@\n-                this.exception = e;\n+                e.printStackTrace();\n+            }\n+        });\n+    }\n+\n+    \/**\n+     * Returns true if the given stack trace contains an element for the given class\n+     * and method name.\n+     *\/\n+    private boolean contains(StackTraceElement[] stack, String className, String methodName) {\n+        return Arrays.stream(stack)\n+                .anyMatch(e -> className.equals(e.getClassName())\n+                        && methodName.equals(e.getMethodName()));\n+    }\n+\n+    \/**\n+     * Long running task with methods to test if the task has started, finished,\n+     * and interrupted.\n+     *\/\n+    private static class LongRunningTask<T> implements Callable<T> {\n+        final CountDownLatch started = new CountDownLatch(1);\n+        final CountDownLatch done = new CountDownLatch(1);\n+        volatile boolean interrupted;\n+\n+        @Override\n+        public T call() throws InterruptedException {\n+            started.countDown();\n+            try {\n+                Thread.sleep(Duration.ofDays(1));\n+            } catch (InterruptedException e) {\n+                interrupted = true;\n@@ -1062,1 +1066,1 @@\n-                done = true;\n+                done.countDown();\n@@ -1064,0 +1068,9 @@\n+            return null;\n+        }\n+\n+        \/**\n+         * Wait for the task to start execution.\n+         *\/\n+        LongRunningTask<T> awaitStarted() throws InterruptedException {\n+            started.await();\n+            return this;\n@@ -1065,2 +1078,7 @@\n-        boolean isDone() {\n-            return done;\n+\n+        \/**\n+         * Wait for the task to finish execution.\n+         *\/\n+        LongRunningTask<T> awaitDone() throws InterruptedException {\n+            done.await();\n+            return this;\n@@ -1068,2 +1086,14 @@\n-        Exception exception() {\n-            return exception;\n+\n+        \/**\n+         * Returns true if the task started execution.\n+         *\/\n+        boolean isStarted() {\n+            return started.getCount() == 0;\n+        }\n+\n+        \/**\n+         * Returns true if the task was interrupted.\n+         *\/\n+        boolean isInterrupted() {\n+            assertTrue(done.getCount() == 0);  \/\/ shouldn't call before finished\n+            return interrupted;\n","filename":"test\/jdk\/java\/util\/concurrent\/ThreadPerTaskExecutor\/ThreadPerTaskExecutorTest.java","additions":149,"deletions":119,"binary":false,"changes":268,"status":"modified"}]}