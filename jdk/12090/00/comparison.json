{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,1 +54,1 @@\n-ArchiveBuilder* ArchiveBuilder::_current = NULL;\n+ArchiveBuilder* ArchiveBuilder::_current = nullptr;\n@@ -98,1 +98,1 @@\n-  assert(*field_addr != NULL, \"should have checked\");\n+  assert(*field_addr != nullptr, \"should have checked\");\n@@ -144,3 +144,3 @@\n-  _current_dump_space(NULL),\n-  _buffer_bottom(NULL),\n-  _last_verified_top(NULL),\n+  _current_dump_space(nullptr),\n+  _buffer_bottom(nullptr),\n+  _last_verified_top(nullptr),\n@@ -149,6 +149,6 @@\n-  _requested_static_archive_bottom(NULL),\n-  _requested_static_archive_top(NULL),\n-  _requested_dynamic_archive_bottom(NULL),\n-  _requested_dynamic_archive_top(NULL),\n-  _mapped_static_archive_bottom(NULL),\n-  _mapped_static_archive_top(NULL),\n+  _requested_static_archive_bottom(nullptr),\n+  _requested_static_archive_top(nullptr),\n+  _requested_dynamic_archive_bottom(nullptr),\n+  _requested_dynamic_archive_top(nullptr),\n+  _mapped_static_archive_bottom(nullptr),\n+  _mapped_static_archive_top(nullptr),\n@@ -172,1 +172,1 @@\n-  assert(_current == NULL, \"must be\");\n+  assert(_current == nullptr, \"must be\");\n@@ -178,1 +178,1 @@\n-  _current = NULL;\n+  _current = nullptr;\n@@ -210,1 +210,1 @@\n-  if (ref->obj() == NULL) {\n+  if (ref->obj() == nullptr) {\n@@ -433,1 +433,1 @@\n-    if (ref->obj() != NULL) {\n+    if (ref->obj() != nullptr) {\n@@ -442,1 +442,1 @@\n-  if (src_obj == NULL) {\n+  if (src_obj == nullptr) {\n@@ -479,1 +479,1 @@\n-  assert(ref->obj() != NULL, \"should have checked\");\n+  assert(ref->obj() != nullptr, \"should have checked\");\n@@ -481,1 +481,1 @@\n-  if (enclosing_ref != NULL) {\n+  if (enclosing_ref != nullptr) {\n@@ -483,1 +483,1 @@\n-    if (src_info == NULL) {\n+    if (src_info == nullptr) {\n@@ -644,1 +644,1 @@\n-  if (archived_vtable != NULL) {\n+  if (archived_vtable != nullptr) {\n@@ -657,1 +657,1 @@\n-  assert(p != NULL, \"must be\");\n+  assert(p != nullptr, \"must be\");\n@@ -665,1 +665,1 @@\n-  assert(src_p != NULL && *src_p != NULL, \"must be\");\n+  assert(src_p != nullptr && *src_p != nullptr, \"must be\");\n@@ -849,1 +849,1 @@\n-\/\/   [a] NULL:\n+\/\/   [a] nullptr:\n@@ -889,1 +889,1 @@\n-    if (*p == NULL) {\n+    if (*p == nullptr) {\n@@ -1067,1 +1067,1 @@\n-        if (original_oop != NULL) {\n+        if (original_oop != nullptr) {\n@@ -1146,1 +1146,1 @@\n-    if (closed_heap_regions != NULL) {\n+    if (closed_heap_regions != nullptr) {\n@@ -1149,1 +1149,1 @@\n-    if (open_heap_regions != NULL) {\n+    if (open_heap_regions != nullptr) {\n@@ -1183,1 +1183,1 @@\n-  if (closed_heap_regions != NULL) {\n+  if (closed_heap_regions != nullptr) {\n@@ -1242,1 +1242,1 @@\n-  if (closed_heap_regions != NULL) {\n+  if (closed_heap_regions != nullptr) {\n@@ -1258,1 +1258,1 @@\n-  int arr_len = regions == NULL ? 0 : regions->length();\n+  int arr_len = regions == nullptr ? 0 : regions->length();\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.cpp","additions":31,"deletions":31,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -162,1 +162,1 @@\n-        _buffered_addr = NULL;\n+        _buffered_addr = nullptr;\n@@ -170,2 +170,2 @@\n-      assert(_buffered_addr == NULL, \"cannot be copied twice\");\n-      assert(addr != NULL, \"must be a valid copy\");\n+      assert(_buffered_addr == nullptr, \"cannot be copied twice\");\n+      assert(addr != nullptr, \"must be a valid copy\");\n@@ -425,1 +425,1 @@\n-    return (_current != NULL);\n+    return (_current != nullptr);\n@@ -430,1 +430,1 @@\n-    assert(_current != NULL, \"ArchiveBuilder must be active\");\n+    assert(_current != nullptr, \"ArchiveBuilder must be active\");\n@@ -450,1 +450,1 @@\n-    assert(klass != NULL && klass->is_klass(), \"must be\");\n+    assert(klass != nullptr && klass->is_klass(), \"must be\");\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.hpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -452,1 +452,1 @@\n-    \/\/ must be NULL, or must point to a valid object in the loaded regions.\n+    \/\/ must be null, or must point to a valid object in the loaded regions.\n@@ -543,1 +543,1 @@\n-    if (r->mapped_base() != NULL && r->has_ptrmap()) {\n+    if (r->mapped_base() != nullptr && r->has_ptrmap()) {\n","filename":"src\/hotspot\/share\/cds\/archiveHeapLoader.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -106,1 +106,1 @@\n-  inline static oop decode_from_archive(narrowOop v) NOT_CDS_JAVA_HEAP_RETURN_(NULL);\n+  inline static oop decode_from_archive(narrowOop v) NOT_CDS_JAVA_HEAP_RETURN_(nullptr);\n@@ -109,1 +109,1 @@\n-  inline static oop decode_from_mapped_archive(narrowOop v) NOT_CDS_JAVA_HEAP_RETURN_(NULL);\n+  inline static oop decode_from_mapped_archive(narrowOop v) NOT_CDS_JAVA_HEAP_RETURN_(nullptr);\n@@ -175,1 +175,1 @@\n-  inline static oop decode_from_archive_impl(narrowOop v) NOT_CDS_JAVA_HEAP_RETURN_(NULL);\n+  inline static oop decode_from_archive_impl(narrowOop v) NOT_CDS_JAVA_HEAP_RETURN_(nullptr);\n","filename":"src\/hotspot\/share\/cds\/archiveHeapLoader.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,1 +47,1 @@\n-CHeapBitMap* ArchivePtrMarker::_ptrmap = NULL;\n+CHeapBitMap* ArchivePtrMarker::_ptrmap = nullptr;\n@@ -53,1 +53,1 @@\n-  assert(_ptrmap == NULL, \"initialize only once\");\n+  assert(_ptrmap == nullptr, \"initialize only once\");\n@@ -70,1 +70,1 @@\n-  assert(_ptrmap != NULL, \"not initialized\");\n+  assert(_ptrmap != nullptr, \"not initialized\");\n@@ -77,1 +77,1 @@\n-    \/\/ to nothing (NULL) vs a pointer to an objects that happens to be at the very bottom\n+    \/\/ to nothing (null) vs a pointer to an objects that happens to be at the very bottom\n@@ -81,1 +81,1 @@\n-    if (value != NULL) {\n+    if (value != nullptr) {\n@@ -95,1 +95,1 @@\n-  assert(_ptrmap != NULL, \"not initialized\");\n+  assert(_ptrmap != nullptr, \"not initialized\");\n@@ -121,1 +121,1 @@\n-    if (ptr_value != NULL) {\n+    if (ptr_value != nullptr) {\n@@ -128,1 +128,1 @@\n-      DEBUG_ONLY(log_trace(cds, reloc)(\"Clearing pointer [\" PTR_FORMAT  \"] -> NULL @ \" SIZE_FORMAT_W(9), p2i(ptr_loc), offset));\n+      DEBUG_ONLY(log_trace(cds, reloc)(\"Clearing pointer [\" PTR_FORMAT  \"] -> null @ \" SIZE_FORMAT_W(9), p2i(ptr_loc), offset));\n@@ -256,1 +256,1 @@\n-  if (next != NULL) {\n+  if (next != nullptr) {\n@@ -265,1 +265,1 @@\n-  if (*o == NULL) {\n+  if (*o == nullptr) {\n@@ -291,1 +291,1 @@\n-  assert(*p == NULL, \"initializing previous initialized pointer.\");\n+  assert(*p == nullptr, \"initializing previous initialized pointer.\");\n@@ -320,1 +320,1 @@\n-      *p = NULL;\n+      *p = nullptr;\n@@ -329,1 +329,1 @@\n-      *p = NULL;\n+      *p = nullptr;\n","filename":"src\/hotspot\/share\/cds\/archiveUtils.cpp","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -145,1 +145,1 @@\n-    : _name(name), _base(NULL), _top(NULL), _end(NULL),\n+    : _name(name), _base(nullptr), _top(nullptr), _end(nullptr),\n@@ -160,1 +160,1 @@\n-    return !is_packed() && _base != NULL;\n+    return !is_packed() && _base != nullptr;\n@@ -168,1 +168,1 @@\n-  void pack(DumpRegion* next = NULL);\n+  void pack(DumpRegion* next = nullptr);\n","filename":"src\/hotspot\/share\/cds\/archiveUtils.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n-  assert(old_ptr != NULL, \"bits for NULL pointers should have been cleaned at dump time\");\n+  assert(old_ptr != nullptr, \"bits for null pointers should have been cleaned at dump time\");\n@@ -41,1 +41,1 @@\n-  assert(new_ptr != NULL, \"don't point to the bottom of the archive\"); \/\/ See ArchivePtrMarker::mark_pointer().\n+  assert(new_ptr != nullptr, \"don't point to the bottom of the archive\"); \/\/ See ArchivePtrMarker::mark_pointer().\n","filename":"src\/hotspot\/share\/cds\/archiveUtils.inline.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -87,1 +87,1 @@\n-# define ADD_EXCL(...) { static const char* e[] = {__VA_ARGS__, NULL}; add_exclusion(e); }\n+# define ADD_EXCL(...) { static const char* e[] = {__VA_ARGS__, nullptr}; add_exclusion(e); }\n@@ -169,1 +169,1 @@\n-    if (static_obj_field != NULL) {\n+    if (static_obj_field != nullptr) {\n@@ -171,2 +171,2 @@\n-      if (_exclusions != NULL) {\n-        for (const char** p = _exclusions; *p != NULL; p++) {\n+      if (_exclusions != nullptr) {\n+        for (const char** p = _exclusions; *p != nullptr; p++) {\n@@ -231,1 +231,1 @@\n-  if (info != NULL) {\n+  if (info != nullptr) {\n@@ -239,1 +239,1 @@\n-    trace_to_root(&ls, orig_obj, NULL, &value);\n+    trace_to_root(&ls, orig_obj, nullptr, &value);\n@@ -270,2 +270,2 @@\n-  if (info != NULL) {\n-    trace_to_root(st, orig_obj, NULL, info);\n+  if (info != nullptr) {\n+    trace_to_root(st, orig_obj, nullptr, info);\n@@ -279,1 +279,1 @@\n-  if (info->_referrer != NULL) {\n+  if (info->_referrer != nullptr) {\n@@ -281,1 +281,1 @@\n-    assert(ref != NULL, \"sanity\");\n+    assert(ref != nullptr, \"sanity\");\n@@ -291,1 +291,1 @@\n-  if (orig_field != NULL) {\n+  if (orig_field != nullptr) {\n","filename":"src\/hotspot\/share\/cds\/cdsHeapVerifier.cpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -70,1 +70,1 @@\n-    return NULL;\n+    return nullptr;\n","filename":"src\/hotspot\/share\/cds\/cdsHeapVerifier.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -61,1 +61,1 @@\n-    assert(pkg_entry != NULL, \"archived class in module image cannot be from unnamed package\");\n+    assert(pkg_entry != nullptr, \"archived class in module image cannot be from unnamed package\");\n@@ -86,1 +86,1 @@\n-    \/\/   Note that if an element of these 3 _shared_xxx arrays is NULL, it will be initialized by\n+    \/\/   Note that if an element of these 3 _shared_xxx arrays is null, it will be initialized by\n@@ -92,1 +92,1 @@\n-      if (pkg_entry == NULL || !pkg_entry->is_defined_by_cds_in_class_path(index_offset)) {\n+      if (pkg_entry == nullptr || !pkg_entry->is_defined_by_cds_in_class_path(index_offset)) {\n@@ -96,1 +96,1 @@\n-        if (pkg_entry != NULL) {\n+        if (pkg_entry != nullptr) {\n@@ -111,1 +111,1 @@\n-  if (pkg != NULL) { \/\/ Package prefix found\n+  if (pkg != nullptr) { \/\/ Package prefix found\n@@ -121,1 +121,1 @@\n-  if (MetaspaceShared::use_full_module_graph() && ik->is_shared() && pkg_entry != NULL) {\n+  if (MetaspaceShared::use_full_module_graph() && ik->is_shared() && pkg_entry != nullptr) {\n@@ -128,1 +128,1 @@\n-  if (pkg_name != NULL) {\n+  if (pkg_name != nullptr) {\n@@ -131,1 +131,1 @@\n-    pkg_entry = NULL;\n+    pkg_entry = nullptr;\n@@ -145,1 +145,1 @@\n-  \/\/ get_package_name() returns a NULL handle if the class is in unnamed package\n+  \/\/ get_package_name() returns a null handle if the class is in unnamed package\n@@ -180,1 +180,1 @@\n-  if (shared_jar_manifest(shared_path_index) == NULL) {\n+  if (shared_jar_manifest(shared_path_index) == nullptr) {\n@@ -189,1 +189,1 @@\n-    assert(src != NULL, \"No Manifest data\");\n+    assert(src != nullptr, \"No Manifest data\");\n@@ -200,1 +200,1 @@\n-  if (shared_jar_url(shared_path_index) == NULL) {\n+  if (shared_jar_url(shared_path_index) == nullptr) {\n@@ -243,1 +243,1 @@\n-  if (shared_protection_domain(shared_path_index) == NULL) {\n+  if (shared_protection_domain(shared_path_index) == nullptr) {\n@@ -260,1 +260,1 @@\n-  if (mod->shared_protection_domain() == NULL) {\n+  if (mod->shared_protection_domain() == nullptr) {\n@@ -262,1 +262,1 @@\n-    if (location != NULL) {\n+    if (location != nullptr) {\n@@ -304,1 +304,1 @@\n-  if (_shared_protection_domains.resolve() == NULL) {\n+  if (_shared_protection_domains.resolve() == nullptr) {\n@@ -316,1 +316,1 @@\n-  if (_shared_jar_urls.resolve() == NULL) {\n+  if (_shared_jar_urls.resolve() == nullptr) {\n@@ -328,1 +328,1 @@\n-  if (_shared_jar_manifests.resolve() == NULL) {\n+  if (_shared_jar_manifests.resolve() == nullptr) {\n","filename":"src\/hotspot\/share\/cds\/cdsProtectionDomain.cpp","additions":18,"deletions":18,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,1 +60,1 @@\n-  product(ccstr, SharedArchiveConfigFile, NULL,                             \\\n+  product(ccstr, SharedArchiveConfigFile, nullptr,                             \\\n@@ -70,1 +70,1 @@\n-  develop(ccstr, ArchiveHeapTestClass, NULL,                                \\\n+  develop(ccstr, ArchiveHeapTestClass, nullptr,                                \\\n@@ -75,1 +75,1 @@\n-  product(ccstr, DumpLoadedClassList, NULL,                                 \\\n+  product(ccstr, DumpLoadedClassList, nullptr,                                 \\\n@@ -79,1 +79,1 @@\n-  product(ccstr, SharedClassListFile, NULL,                                 \\\n+  product(ccstr, SharedClassListFile, nullptr,                                 \\\n@@ -82,1 +82,1 @@\n-  product(ccstr, SharedArchiveFile, NULL,                                   \\\n+  product(ccstr, SharedArchiveFile, nullptr,                                   \\\n@@ -85,1 +85,1 @@\n-  product(ccstr, ArchiveClassesAtExit, NULL,                                \\\n+  product(ccstr, ArchiveClassesAtExit, nullptr,                                \\\n@@ -88,1 +88,1 @@\n-  product(ccstr, ExtraSharedClassListFile, NULL,                            \\\n+  product(ccstr, ExtraSharedClassListFile, nullptr,                            \\\n","filename":"src\/hotspot\/share\/cds\/cds_globals.hpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,2 +54,2 @@\n-volatile Thread* ClassListParser::_parsing_thread = NULL;\n-ClassListParser* ClassListParser::_instance = NULL;\n+volatile Thread* ClassListParser::_parsing_thread = nullptr;\n+ClassListParser* ClassListParser::_instance = nullptr;\n@@ -61,1 +61,1 @@\n-  _file = NULL;\n+  _file = nullptr;\n@@ -70,1 +70,1 @@\n-  if (_file == NULL) {\n+  if (_file == nullptr) {\n@@ -81,1 +81,1 @@\n-  assert(_instance == NULL, \"must be singleton\");\n+  assert(_instance == nullptr, \"must be singleton\");\n@@ -91,1 +91,1 @@\n-  if (_file != NULL) {\n+  if (_file != nullptr) {\n@@ -94,1 +94,1 @@\n-  Atomic::store(&_parsing_thread, (Thread*)NULL);\n+  Atomic::store(&_parsing_thread, (Thread*)nullptr);\n@@ -97,1 +97,1 @@\n-  _instance = NULL;\n+  _instance = nullptr;\n@@ -133,1 +133,1 @@\n-      if (message != NULL) {\n+      if (message != nullptr) {\n@@ -144,1 +144,1 @@\n-    assert(klass != NULL, \"sanity\");\n+    assert(klass != nullptr, \"sanity\");\n@@ -168,1 +168,1 @@\n-    if (fgets(_line, sizeof(_line), _file) == NULL) {\n+    if (fgets(_line, sizeof(_line), _file) == nullptr) {\n@@ -210,1 +210,1 @@\n-  _source = NULL;\n+  _source = nullptr;\n@@ -219,1 +219,1 @@\n-  if ((_token = strchr(_line, ' ')) == NULL) {\n+  if ((_token = strchr(_line, ' ')) == nullptr) {\n@@ -245,1 +245,1 @@\n-      if (s == NULL) {\n+      if (s == nullptr) {\n@@ -287,1 +287,1 @@\n-  if ((ptr = strchr(_line, ' ')) == NULL) {\n+  if ((ptr = strchr(_line, ' ')) == nullptr) {\n@@ -448,1 +448,1 @@\n-  vm_exit_during_initialization(\"class list format error.\", NULL);\n+  vm_exit_during_initialization(\"class list format error.\", nullptr);\n@@ -547,1 +547,1 @@\n-    if (message != NULL) {\n+    if (message != nullptr) {\n@@ -643,1 +643,1 @@\n-    assert(obj != NULL, \"jdk.internal.loader.BuiltinClassLoader::loadClass never returns null\");\n+    assert(obj != nullptr, \"jdk.internal.loader.BuiltinClassLoader::loadClass never returns null\");\n@@ -651,1 +651,1 @@\n-  assert(klass != NULL, \"exception should have been thrown\");\n+  assert(klass != nullptr, \"exception should have been thrown\");\n@@ -672,1 +672,1 @@\n-  return (_source != NULL);\n+  return (_source != nullptr);\n@@ -677,1 +677,1 @@\n-  if (klass_ptr == NULL) {\n+  if (klass_ptr == nullptr) {\n@@ -680,1 +680,1 @@\n-  assert(*klass_ptr != NULL, \"must be\");\n+  assert(*klass_ptr != nullptr, \"must be\");\n@@ -687,1 +687,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -701,1 +701,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -724,1 +724,1 @@\n-  return NULL;\n+  return nullptr;\n","filename":"src\/hotspot\/share\/cds\/classListParser.cpp","additions":26,"deletions":26,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,1 @@\n-  CDSIndyInfo() : _items(NULL) {}\n+  CDSIndyInfo() : _items(nullptr) {}\n@@ -44,1 +44,1 @@\n-    if (_items == NULL) {\n+    if (_items == nullptr) {\n@@ -47,1 +47,1 @@\n-    assert(_items != NULL, \"sanity\");\n+    assert(_items != nullptr, \"sanity\");\n@@ -147,1 +147,1 @@\n-    assert(_instance != NULL, \"must be\");\n+    assert(_instance != nullptr, \"must be\");\n","filename":"src\/hotspot\/share\/cds\/classListParser.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n-fileStream* ClassListWriter::_classlist_file = NULL;\n+fileStream* ClassListWriter::_classlist_file = nullptr;\n@@ -41,2 +41,2 @@\n-  if (DumpLoadedClassList != NULL) {\n-    const char* list_name = make_log_name(DumpLoadedClassList, NULL);\n+  if (DumpLoadedClassList != nullptr) {\n+    const char* list_name = make_log_name(DumpLoadedClassList, nullptr);\n@@ -59,1 +59,1 @@\n-    DumpLoadedClassList = NULL;\n+    DumpLoadedClassList = nullptr;\n@@ -72,1 +72,1 @@\n-ClassListWriter::IDTable* ClassListWriter::_id_table = NULL;\n+ClassListWriter::IDTable* ClassListWriter::_id_table = nullptr;\n@@ -77,1 +77,1 @@\n-  if (_id_table == NULL) {\n+  if (_id_table == nullptr) {\n@@ -90,2 +90,2 @@\n-  if (_id_table != NULL) {\n-    return _id_table->get(k) != NULL;\n+  if (_id_table != nullptr) {\n+    return _id_table->get(k) != nullptr;\n@@ -99,1 +99,1 @@\n-  if (_id_table != NULL) {\n+  if (_id_table != nullptr) {\n@@ -135,1 +135,1 @@\n-    if (super != NULL && !has_id(super)) {\n+    if (super != nullptr && !has_id(super)) {\n@@ -161,1 +161,1 @@\n-    assert(super != NULL, \"must be\");\n+    assert(super != nullptr, \"must be\");\n@@ -188,1 +188,1 @@\n-  if (_classlist_file != NULL) {\n+  if (_classlist_file != nullptr) {\n","filename":"src\/hotspot\/share\/cds\/classListWriter.cpp","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,1 +55,1 @@\n-    return _classlist_file != NULL && _classlist_file->is_open();\n+    return _classlist_file != nullptr && _classlist_file->is_open();\n@@ -68,1 +68,1 @@\n-  static void write_to_stream(const InstanceKlass* k, outputStream* stream, const ClassFileStream* cfs = NULL) NOT_CDS_RETURN;\n+  static void write_to_stream(const InstanceKlass* k, outputStream* stream, const ClassFileStream* cfs = nullptr) NOT_CDS_RETURN;\n","filename":"src\/hotspot\/share\/cds\/classListWriter.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,2 +36,2 @@\n-ClassPrelinker::ClassesTable* ClassPrelinker::_processed_classes = NULL;\n-ClassPrelinker::ClassesTable* ClassPrelinker::_vm_classes = NULL;\n+ClassPrelinker::ClassesTable* ClassPrelinker::_processed_classes = nullptr;\n+ClassPrelinker::ClassesTable* ClassPrelinker::_vm_classes = nullptr;\n@@ -40,1 +40,1 @@\n-  return (_vm_classes->get(ik) != NULL);\n+  return (_vm_classes->get(ik) != nullptr);\n@@ -48,1 +48,1 @@\n-    if (super != NULL) {\n+    if (super != nullptr) {\n@@ -59,1 +59,1 @@\n-  assert(_vm_classes == NULL, \"must be\");\n+  assert(_vm_classes == nullptr, \"must be\");\n@@ -68,1 +68,1 @@\n-  assert(_vm_classes != NULL, \"must be\");\n+  assert(_vm_classes != nullptr, \"must be\");\n@@ -71,2 +71,2 @@\n-  _vm_classes = NULL;\n-  _processed_classes = NULL;\n+  _vm_classes = nullptr;\n+  _processed_classes = nullptr;\n@@ -80,1 +80,1 @@\n-  assert(resolved_klass != NULL, \"must be\");\n+  assert(resolved_klass != nullptr, \"must be\");\n@@ -118,2 +118,2 @@\n-  if (cp->cache() == NULL || cp->reference_map() == NULL) {\n-    \/\/ The cache may be NULL if the pool_holder klass fails verification\n+  if (cp->cache() == nullptr || cp->reference_map() == nullptr) {\n+    \/\/ The cache may be null if the pool_holder klass fails verification\n@@ -149,1 +149,1 @@\n-  if (k != NULL) {\n+  if (k != nullptr) {\n@@ -155,1 +155,1 @@\n-    return find_loaded_class(THREAD, NULL, name);\n+    return find_loaded_class(THREAD, nullptr, name);\n@@ -158,1 +158,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -169,1 +169,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -174,1 +174,1 @@\n-  if (resolved_klass != NULL && can_archive_resolved_klass(cp_holder, resolved_klass)) {\n+  if (resolved_klass != nullptr && can_archive_resolved_klass(cp_holder, resolved_klass)) {\n@@ -196,1 +196,1 @@\n-  if (!Thread::current()->is_VM_thread() || ArchiveBuilder::current() == NULL) {\n+  if (!Thread::current()->is_VM_thread() || ArchiveBuilder::current() == nullptr) {\n","filename":"src\/hotspot\/share\/cds\/classPrelinker.cpp","additions":18,"deletions":18,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -129,1 +129,1 @@\n-\/\/   class CppVtableTesterB: public InstanceKlass {virtual void* last_virtual_method() {return NULL}; };\n+\/\/   class CppVtableTesterB: public InstanceKlass {virtual void* last_virtual_method() {return nullptr}; };\n@@ -152,1 +152,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -215,1 +215,1 @@\n-CppVtableInfo** CppVtables::_index = NULL;\n+CppVtableInfo** CppVtables::_index = nullptr;\n@@ -280,1 +280,1 @@\n-    return NULL;\n+    return nullptr;\n","filename":"src\/hotspot\/share\/cds\/cppVtables.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,1 +58,1 @@\n-      return NULL;\n+      return nullptr;\n","filename":"src\/hotspot\/share\/cds\/dumpAllocStats.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,3 +49,3 @@\n-  _verifier_constraints = NULL;\n-  _verifier_constraint_flags = NULL;\n-  _loader_constraints = NULL;\n+  _verifier_constraints = nullptr;\n+  _verifier_constraint_flags = nullptr;\n+  _loader_constraints = nullptr;\n@@ -53,2 +53,2 @@\n-  assert(src._enum_klass_static_fields == NULL, \"This should not happen with dynamic dump.\");\n-  _enum_klass_static_fields = NULL;\n+  assert(src._enum_klass_static_fields == nullptr, \"This should not happen with dynamic dump.\");\n+  _enum_klass_static_fields = nullptr;\n@@ -80,2 +80,2 @@\n-  if (_verifier_constraints != NULL) {\n-    assert(_verifier_constraint_flags != NULL, \"must be\");\n+  if (_verifier_constraints != nullptr) {\n+    assert(_verifier_constraint_flags != nullptr, \"must be\");\n@@ -85,1 +85,1 @@\n-  if (_loader_constraints != NULL) {\n+  if (_loader_constraints != nullptr) {\n@@ -98,1 +98,1 @@\n-  if (_verifier_constraints == NULL) {\n+  if (_verifier_constraints == nullptr) {\n@@ -101,1 +101,1 @@\n-  if (_verifier_constraint_flags == NULL) {\n+  if (_verifier_constraint_flags == nullptr) {\n@@ -143,1 +143,1 @@\n-  if (_loader_constraints == NULL) {\n+  if (_loader_constraints == nullptr) {\n@@ -175,1 +175,1 @@\n-  if (_enum_klass_static_fields == NULL) {\n+  if (_enum_klass_static_fields == nullptr) {\n@@ -182,1 +182,1 @@\n-  assert(_enum_klass_static_fields != NULL, \"must be\");\n+  assert(_enum_klass_static_fields != nullptr, \"must be\");\n@@ -202,1 +202,1 @@\n-  assert(p != NULL, \"we must not see any non-shared InstanceKlass* that's \"\n+  assert(p != nullptr, \"we must not see any non-shared InstanceKlass* that's \"\n","filename":"src\/hotspot\/share\/cds\/dumpTimeClassInfo.cpp","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,1 +49,1 @@\n-    DTLoaderConstraint() : _name(NULL), _loader_type1('0'), _loader_type2('0') {}\n+    DTLoaderConstraint() : _name(nullptr), _loader_type1('0'), _loader_type2('0') {}\n@@ -87,1 +87,1 @@\n-    DTVerifierConstraint() : _name(NULL), _from_name(NULL) {}\n+    DTVerifierConstraint() : _name(nullptr), _from_name(nullptr) {}\n@@ -133,2 +133,2 @@\n-    _klass = NULL;\n-    _nest_host = NULL;\n+    _klass = nullptr;\n+    _nest_host = nullptr;\n@@ -143,4 +143,4 @@\n-    _verifier_constraints = NULL;\n-    _verifier_constraint_flags = NULL;\n-    _loader_constraints = NULL;\n-    _enum_klass_static_fields = NULL;\n+    _verifier_constraints = nullptr;\n+    _verifier_constraint_flags = nullptr;\n+    _loader_constraints = nullptr;\n+    _enum_klass_static_fields = nullptr;\n@@ -162,1 +162,1 @@\n-    if (array == NULL) {\n+    if (array == nullptr) {\n@@ -186,1 +186,1 @@\n-    if (_verifier_constraints != NULL) {\n+    if (_verifier_constraints != nullptr) {\n@@ -191,1 +191,1 @@\n-    if (_loader_constraints != NULL) {\n+    if (_loader_constraints != nullptr) {\n","filename":"src\/hotspot\/share\/cds\/dumpTimeClassInfo.hpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -204,1 +204,1 @@\n-  assert(mapinfo != NULL && _header == mapinfo->dynamic_header(), \"must be\");\n+  assert(mapinfo != nullptr && _header == mapinfo->dynamic_header(), \"must be\");\n@@ -207,1 +207,1 @@\n-  _header = NULL;\n+  _header = nullptr;\n@@ -228,1 +228,1 @@\n-  assert(ik != NULL, \"DynamicArchiveBuilder currently doesn't support dumping the base archive\");\n+  assert(ik != nullptr, \"DynamicArchiveBuilder currently doesn't support dumping the base archive\");\n@@ -234,2 +234,2 @@\n-  if (ik->java_mirror() == NULL) {\n-    \/\/ NULL mirror means this class has already been visited and methods are already sorted\n+  if (ik->java_mirror() == nullptr) {\n+    \/\/ null mirror means this class has already been visited and methods are already sorted\n@@ -260,1 +260,1 @@\n-  if (ik->methods() != NULL) {\n+  if (ik->methods() != nullptr) {\n@@ -266,1 +266,1 @@\n-  if (ik->default_methods() != NULL) {\n+  if (ik->default_methods() != nullptr) {\n@@ -275,1 +275,1 @@\n-  if (ik->default_methods() != NULL) {\n+  if (ik->default_methods() != nullptr) {\n@@ -323,1 +323,1 @@\n-  assert(dynamic_info != NULL, \"Sanity\");\n+  assert(dynamic_info != nullptr, \"Sanity\");\n@@ -326,1 +326,1 @@\n-  ArchiveBuilder::write_archive(dynamic_info, NULL, NULL, NULL, NULL);\n+  ArchiveBuilder::write_archive(dynamic_info, nullptr, nullptr, nullptr, nullptr);\n@@ -370,1 +370,1 @@\n-      vm_exit_during_initialization(\"-XX:+RecordDynamicDumpInfo\" __THEMSG, NULL);\n+      vm_exit_during_initialization(\"-XX:+RecordDynamicDumpInfo\" __THEMSG, nullptr);\n","filename":"src\/hotspot\/share\/cds\/dynamicArchive.cpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,1 +66,1 @@\n-  static bool is_mapped() { return FileMapInfo::dynamic_info() != NULL; }\n+  static bool is_mapped() { return FileMapInfo::dynamic_info() != nullptr; }\n","filename":"src\/hotspot\/share\/cds\/dynamicArchive.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -94,1 +94,1 @@\n-  vm_exit_during_initialization(\"Unable to use shared archive.\", NULL);\n+  vm_exit_during_initialization(\"Unable to use shared archive.\", nullptr);\n@@ -183,1 +183,1 @@\n-    assert(_current_info == NULL, \"must be singleton\"); \/\/ not thread safe\n+    assert(_current_info == nullptr, \"must be singleton\"); \/\/ not thread safe\n@@ -186,1 +186,1 @@\n-    assert(_dynamic_archive_info == NULL, \"must be singleton\"); \/\/ not thread safe\n+    assert(_dynamic_archive_info == nullptr, \"must be singleton\"); \/\/ not thread safe\n@@ -194,1 +194,1 @@\n-    _current_info = NULL;\n+    _current_info = nullptr;\n@@ -197,1 +197,1 @@\n-    _dynamic_archive_info = NULL;\n+    _dynamic_archive_info = nullptr;\n@@ -210,1 +210,1 @@\n-  assert(_header == NULL, \"Sanity check\");\n+  assert(_header == nullptr, \"Sanity check\");\n@@ -431,1 +431,1 @@\n-  if (ent->is_jar() && !ent->is_signed() && ent->manifest() != NULL) {\n+  if (ent->is_jar() && !ent->is_signed() && ent->manifest() != nullptr) {\n@@ -564,1 +564,1 @@\n-  assert(jrt != NULL,\n+  assert(jrt != nullptr,\n@@ -567,1 +567,1 @@\n-  if (_saved_shared_path_table_array != NULL) {\n+  if (_saved_shared_path_table_array != nullptr) {\n@@ -569,1 +569,1 @@\n-    _saved_shared_path_table_array = NULL;\n+    _saved_shared_path_table_array = nullptr;\n@@ -581,1 +581,1 @@\n-  assert(jrt != NULL,\n+  assert(jrt != nullptr,\n@@ -602,1 +602,1 @@\n-  while (cpe != NULL) {\n+  while (cpe != nullptr) {\n@@ -646,1 +646,1 @@\n-    ClassLoader::exit_with_path_failure(\"Cannot have non-empty directory in paths\", NULL);\n+    ClassLoader::exit_with_path_failure(\"Cannot have non-empty directory in paths\", nullptr);\n@@ -653,1 +653,1 @@\n-  if (_non_existent_class_paths == NULL) {\n+  if (_non_existent_class_paths == nullptr) {\n@@ -661,1 +661,1 @@\n-  if (_non_existent_class_paths != NULL) {\n+  if (_non_existent_class_paths != nullptr) {\n@@ -732,1 +732,1 @@\n-        if (value != NULL) {\n+        if (value != nullptr) {\n@@ -734,1 +734,1 @@\n-          if (strstr((char*)attr, \"-Digest\") != NULL) {\n+          if (strstr((char*)attr, \"-Digest\") != nullptr) {\n@@ -755,1 +755,1 @@\n-  if (manifest != NULL) {\n+  if (manifest != nullptr) {\n@@ -776,1 +776,1 @@\n-  if (p != NULL) {\n+  if (p != nullptr) {\n@@ -793,1 +793,1 @@\n-  if (path == NULL) {\n+  if (path == nullptr) {\n@@ -798,1 +798,1 @@\n-  while (p != NULL) {\n+  while (p != nullptr) {\n@@ -801,1 +801,1 @@\n-    if (p != NULL) {\n+    if (p != nullptr) {\n@@ -831,1 +831,1 @@\n-  while (cpe != NULL) {\n+  while (cpe != nullptr) {\n@@ -852,2 +852,2 @@\n-      if (canonical_path != NULL) {\n-        char* error_msg = NULL;\n+      if (canonical_path != nullptr) {\n+        char* error_msg = nullptr;\n@@ -855,1 +855,1 @@\n-        if (zip != NULL && error_msg == NULL) {\n+        if (zip != nullptr && error_msg == nullptr) {\n@@ -942,1 +942,1 @@\n-  if (dp_len == 0 && rp == NULL) {\n+  if (dp_len == 0 && rp == nullptr) {\n@@ -944,1 +944,1 @@\n-  } else if (dp_len == 0 && rp != NULL) {\n+  } else if (dp_len == 0 && rp != nullptr) {\n@@ -955,1 +955,1 @@\n-  } else if (dp_len > 0 && rp != NULL) {\n+  } else if (dp_len > 0 && rp != nullptr) {\n@@ -987,1 +987,1 @@\n-  assert(appcp != NULL, \"NULL app classpath\");\n+  assert(appcp != nullptr, \"null app classpath\");\n@@ -1112,1 +1112,1 @@\n-        if (_dynamic_archive_info != NULL && _dynamic_archive_info->_is_static) {\n+        if (_dynamic_archive_info != nullptr && _dynamic_archive_info->_is_static) {\n@@ -1121,1 +1121,1 @@\n-        if (_dynamic_archive_info != NULL && _dynamic_archive_info->_is_static) {\n+        if (_dynamic_archive_info != nullptr && _dynamic_archive_info->_is_static) {\n@@ -1147,1 +1147,1 @@\n-  if (_classpath_entries_for_jvmti != NULL) {\n+  if (_classpath_entries_for_jvmti != nullptr) {\n@@ -1212,1 +1212,1 @@\n-    assert(_archive_name != nullptr, \"Archive name is NULL\");\n+    assert(_archive_name != nullptr, \"Archive name is null\");\n@@ -1223,1 +1223,1 @@\n-    assert(_archive_name != nullptr, \"Archive name is NULL\");\n+    assert(_archive_name != nullptr, \"Archive name is null\");\n@@ -1361,1 +1361,1 @@\n-\/\/ true && (*base_archive_name) == NULL:\n+\/\/ true && (*base_archive_name) == nullptr:\n@@ -1363,1 +1363,1 @@\n-\/\/ true && (*base_archive_name) != NULL:\n+\/\/ true && (*base_archive_name) != nullptr:\n@@ -1368,1 +1368,1 @@\n-  *base_archive_name = NULL;\n+  *base_archive_name = nullptr;\n@@ -1568,1 +1568,1 @@\n-  _mapped_base = NULL;\n+  _mapped_base = nullptr;\n@@ -1630,1 +1630,1 @@\n-    requested_base = NULL; \/\/ always NULL for bm region\n+    requested_base = nullptr; \/\/ always null for bm region\n@@ -1633,1 +1633,1 @@\n-    requested_base = NULL;\n+    requested_base = nullptr;\n@@ -1663,1 +1663,1 @@\n-  if (base != NULL) {\n+  if (base != nullptr) {\n@@ -1691,1 +1691,1 @@\n-  if (closed_bitmaps != NULL && open_bitmaps != NULL) {\n+  if (closed_bitmaps != nullptr && open_bitmaps != nullptr) {\n@@ -1700,1 +1700,1 @@\n-  if (closed_bitmaps != NULL && open_bitmaps != NULL) {\n+  if (closed_bitmaps != nullptr && open_bitmaps != nullptr) {\n@@ -1745,1 +1745,1 @@\n-  int arr_len = regions == NULL ? 0 : regions->length();\n+  int arr_len = regions == nullptr ? 0 : regions->length();\n@@ -1756,1 +1756,1 @@\n-    char* start = NULL;\n+    char* start = nullptr;\n@@ -1853,1 +1853,1 @@\n-  if (base == NULL) {\n+  if (base == nullptr) {\n@@ -1870,1 +1870,1 @@\n-  DEBUG_ONLY(FileMapRegion* last_region = NULL);\n+  DEBUG_ONLY(FileMapRegion* last_region = nullptr);\n@@ -1884,1 +1884,1 @@\n-    DEBUG_ONLY(if (last_region != NULL) {\n+    DEBUG_ONLY(if (last_region != nullptr) {\n@@ -1933,2 +1933,2 @@\n-  assert(r->mapped_base() == NULL, \"must be not mapped yet\");\n-  assert(requested_addr != NULL, \"must be specified\");\n+  assert(r->mapped_base() == nullptr, \"must be not mapped yet\");\n+  assert(requested_addr != nullptr, \"must be specified\");\n@@ -1987,1 +1987,1 @@\n-  if (r->mapped_base() != NULL) {\n+  if (r->mapped_base() != nullptr) {\n@@ -1991,1 +1991,1 @@\n-  char* requested_addr = NULL; \/\/ allow OS to pick any location\n+  char* requested_addr = nullptr; \/\/ allow OS to pick any location\n@@ -1994,1 +1994,1 @@\n-  if (bitmap_base == NULL) {\n+  if (bitmap_base == nullptr) {\n@@ -1996,1 +1996,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -2004,1 +2004,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -2022,1 +2022,1 @@\n-  if (bitmap_base == NULL) {\n+  if (bitmap_base == nullptr) {\n@@ -2083,2 +2083,2 @@\n-static MemRegion *closed_heap_regions = NULL;\n-static MemRegion *open_heap_regions = NULL;\n+static MemRegion *closed_heap_regions = nullptr;\n+static MemRegion *open_heap_regions = nullptr;\n@@ -2099,1 +2099,1 @@\n-  address end   = NULL;\n+  address end   = nullptr;\n@@ -2119,1 +2119,1 @@\n-  assert(end != NULL, \"must have at least one used heap region\");\n+  assert(end != nullptr, \"must have at least one used heap region\");\n@@ -2322,1 +2322,1 @@\n-    if (bitmap_base == NULL) {\n+    if (bitmap_base == nullptr) {\n@@ -2350,1 +2350,1 @@\n-    assert(closed_heap_regions == NULL &&\n+    assert(closed_heap_regions == nullptr &&\n@@ -2355,1 +2355,1 @@\n-    assert(open_heap_regions == NULL && num_open_heap_regions == 0, \"sanity\");\n+    assert(open_heap_regions == nullptr && num_open_heap_regions == 0, \"sanity\");\n@@ -2416,1 +2416,1 @@\n-    if (base == NULL || base != addr) {\n+    if (base == nullptr || base != addr) {\n@@ -2466,1 +2466,1 @@\n-  assert(bitmap_base != NULL, \"must have already been mapped\");\n+  assert(bitmap_base != nullptr, \"must have already been mapped\");\n@@ -2483,1 +2483,1 @@\n-  \/\/ Note that closed_heap_regions may be non-NULL even if no regions were found.\n+  \/\/ Note that closed_heap_regions may be non-null even if no regions were found.\n@@ -2485,1 +2485,1 @@\n-    assert(closed_heap_regions != NULL,\n+    assert(closed_heap_regions != nullptr,\n@@ -2498,1 +2498,1 @@\n-    assert(open_heap_regions != NULL, \"NULL open_heap_regions array with non-zero count\");\n+    assert(open_heap_regions != nullptr, \"null open_heap_regions array with non-zero count\");\n@@ -2514,1 +2514,1 @@\n-    assert(regions != NULL, \"Null archive regions array with non-zero count\");\n+    assert(regions != nullptr, \"Null archive regions array with non-zero count\");\n@@ -2555,1 +2555,1 @@\n-  if (mapped_base != NULL) {\n+  if (mapped_base != nullptr) {\n@@ -2563,1 +2563,1 @@\n-    r->set_mapped_base(NULL);\n+    r->set_mapped_base(nullptr);\n@@ -2581,2 +2581,2 @@\n-FileMapInfo* FileMapInfo::_current_info = NULL;\n-FileMapInfo* FileMapInfo::_dynamic_archive_info = NULL;\n+FileMapInfo* FileMapInfo::_current_info = nullptr;\n+FileMapInfo* FileMapInfo::_dynamic_archive_info = nullptr;\n@@ -2586,1 +2586,1 @@\n-Array<u8>*      FileMapInfo::_saved_shared_path_table_array = NULL;\n+Array<u8>*      FileMapInfo::_saved_shared_path_table_array = nullptr;\n@@ -2589,1 +2589,1 @@\n-GrowableArray<const char*>* FileMapInfo::_non_existent_class_paths = NULL;\n+GrowableArray<const char*>* FileMapInfo::_non_existent_class_paths = nullptr;\n@@ -2682,1 +2682,1 @@\n-  if (prop != NULL) {\n+  if (prop != nullptr) {\n@@ -2760,1 +2760,1 @@\n-  MetaspaceShared::set_shared_metaspace_range(NULL, NULL, NULL);\n+  MetaspaceShared::set_shared_metaspace_range(nullptr, nullptr, nullptr);\n@@ -2782,1 +2782,1 @@\n-ClassPathEntry** FileMapInfo::_classpath_entries_for_jvmti = NULL;\n+ClassPathEntry** FileMapInfo::_classpath_entries_for_jvmti = nullptr;\n@@ -2791,1 +2791,1 @@\n-  if (ent == NULL) {\n+  if (ent == nullptr) {\n@@ -2800,1 +2800,1 @@\n-      THROW_MSG_(vmSymbols::java_io_IOException(), msg, NULL);\n+      THROW_MSG_(vmSymbols::java_io_IOException(), msg, nullptr);\n@@ -2803,1 +2803,1 @@\n-      if (ent == NULL) {\n+      if (ent == nullptr) {\n@@ -2806,1 +2806,1 @@\n-        THROW_MSG_(vmSymbols::java_io_IOException(), msg, NULL);\n+        THROW_MSG_(vmSymbols::java_io_IOException(), msg, nullptr);\n@@ -2811,1 +2811,1 @@\n-    if (_classpath_entries_for_jvmti[i] == NULL) {\n+    if (_classpath_entries_for_jvmti[i] == nullptr) {\n@@ -2829,1 +2829,1 @@\n-  assert(cpe != NULL, \"must be\");\n+  assert(cpe != nullptr, \"must be\");\n@@ -2837,1 +2837,1 @@\n-  assert(cfs != NULL, \"must be able to read the classfile data of shared classes for built-in loaders.\");\n+  assert(cfs != nullptr, \"must be able to read the classfile data of shared classes for built-in loaders.\");\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":87,"deletions":87,"binary":false,"changes":174,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -91,1 +91,1 @@\n-    return (_manifest == NULL) ? NULL : (const char*)_manifest->data();\n+    return (_manifest == nullptr) ? nullptr : (const char*)_manifest->data();\n@@ -94,1 +94,1 @@\n-    return (_manifest == NULL) ? 0 : _manifest->length();\n+    return (_manifest == nullptr) ? 0 : _manifest->length();\n@@ -118,1 +118,1 @@\n-  SharedPathTable() : _table(NULL), _size(0) {}\n+  SharedPathTable() : _table(nullptr), _size(0) {}\n@@ -129,1 +129,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -432,1 +432,1 @@\n-    NOT_CDS(return NULL;)\n+    NOT_CDS(return nullptr;)\n@@ -441,1 +441,1 @@\n-    NOT_CDS(return NULL;)\n+    NOT_CDS(return nullptr;)\n@@ -564,1 +564,1 @@\n-  char* skip_first_path_entry(const char* path) NOT_CDS_RETURN_(NULL);\n+  char* skip_first_path_entry(const char* path) NOT_CDS_RETURN_(nullptr);\n@@ -567,2 +567,2 @@\n-  GrowableArray<const char*>* create_dumptime_app_classpath_array() NOT_CDS_RETURN_(NULL);\n-  GrowableArray<const char*>* create_path_array(const char* path) NOT_CDS_RETURN_(NULL);\n+  GrowableArray<const char*>* create_dumptime_app_classpath_array() NOT_CDS_RETURN_(nullptr);\n+  GrowableArray<const char*>* create_path_array(const char* path) NOT_CDS_RETURN_(nullptr);\n@@ -593,3 +593,3 @@\n-  address heap_region_dumptime_address(FileMapRegion* r) NOT_CDS_JAVA_HEAP_RETURN_(NULL);\n-  address heap_region_requested_address(FileMapRegion* r) NOT_CDS_JAVA_HEAP_RETURN_(NULL);\n-  address heap_region_mapped_address(FileMapRegion* r) NOT_CDS_JAVA_HEAP_RETURN_(NULL);\n+  address heap_region_dumptime_address(FileMapRegion* r) NOT_CDS_JAVA_HEAP_RETURN_(nullptr);\n+  address heap_region_requested_address(FileMapRegion* r) NOT_CDS_JAVA_HEAP_RETURN_(nullptr);\n+  address heap_region_mapped_address(FileMapRegion* r) NOT_CDS_JAVA_HEAP_RETURN_(nullptr);\n","filename":"src\/hotspot\/share\/cds\/filemap.hpp","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -76,1 +76,1 @@\n-  : klass_name(k), field_name(f), klass(NULL), offset(0), type(T_ILLEGAL) {}\n+  : klass_name(k), field_name(f), klass(nullptr), offset(0), type(T_ILLEGAL) {}\n@@ -79,1 +79,1 @@\n-    return klass_name != NULL;\n+    return klass_name != nullptr;\n@@ -84,2 +84,2 @@\n-DumpedInternedStrings *HeapShared::_dumped_interned_strings = NULL;\n-GrowableArrayCHeap<Metadata**, mtClassShared>* HeapShared::_native_pointers = NULL;\n+DumpedInternedStrings *HeapShared::_dumped_interned_strings = nullptr;\n+GrowableArrayCHeap<Metadata**, mtClassShared>* HeapShared::_native_pointers = nullptr;\n@@ -94,4 +94,4 @@\n-static Array<char>* _archived_ArchiveHeapTestClass = NULL;\n-static const char* _test_class_name = NULL;\n-static const Klass* _test_class = NULL;\n-static const ArchivedKlassSubGraphInfoRecord* _test_class_record = NULL;\n+static Array<char>* _archived_ArchiveHeapTestClass = nullptr;\n+static const char* _test_class_name = nullptr;\n+static const Klass* _test_class = nullptr;\n+static const ArchivedKlassSubGraphInfoRecord* _test_class_record = nullptr;\n@@ -116,1 +116,1 @@\n-  {NULL, NULL},\n+  {nullptr, nullptr},\n@@ -126,1 +126,1 @@\n-  {NULL, NULL}, \/\/ Extra slot for -XX:ArchiveHeapTestClass\n+  {nullptr, nullptr}, \/\/ Extra slot for -XX:ArchiveHeapTestClass\n@@ -128,1 +128,1 @@\n-  {NULL, NULL},\n+  {nullptr, nullptr},\n@@ -136,1 +136,1 @@\n-  {NULL, NULL},\n+  {nullptr, nullptr},\n@@ -140,1 +140,1 @@\n-GrowableArrayCHeap<oop, mtClassShared>* HeapShared::_pending_roots = NULL;\n+GrowableArrayCHeap<oop, mtClassShared>* HeapShared::_pending_roots = nullptr;\n@@ -143,1 +143,1 @@\n-KlassToOopHandleTable* HeapShared::_scratch_java_mirror_table = NULL;\n+KlassToOopHandleTable* HeapShared::_scratch_java_mirror_table = nullptr;\n@@ -180,1 +180,1 @@\n-  while (klass != NULL) {\n+  while (klass != nullptr) {\n@@ -182,1 +182,1 @@\n-    if (method != NULL) {\n+    if (method != nullptr) {\n@@ -221,2 +221,2 @@\n-HeapShared::ArchivedObjectCache* HeapShared::_archived_object_cache = NULL;\n-HeapShared::OriginalObjectTable* HeapShared::_original_object_table = NULL;\n+HeapShared::ArchivedObjectCache* HeapShared::_archived_object_cache = nullptr;\n+HeapShared::OriginalObjectTable* HeapShared::_original_object_table = nullptr;\n@@ -227,1 +227,1 @@\n-  if (p != NULL) {\n+  if (p != nullptr) {\n@@ -230,1 +230,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -240,1 +240,1 @@\n-  if (_pending_roots == NULL) {\n+  if (_pending_roots == nullptr) {\n@@ -251,1 +251,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -258,1 +258,1 @@\n-  assert(roots != NULL, \"should have been initialized\");\n+  assert(roots != nullptr, \"should have been initialized\");\n@@ -267,1 +267,1 @@\n-    assert(_pending_roots != NULL, \"sanity\");\n+    assert(_pending_roots != nullptr, \"sanity\");\n@@ -288,1 +288,1 @@\n-    roots()->obj_at_put(index, NULL);\n+    roots()->obj_at_put(index, nullptr);\n@@ -298,1 +298,1 @@\n-  if (ao != NULL) {\n+  if (ao != nullptr) {\n@@ -307,1 +307,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -311,1 +311,1 @@\n-  if (archived_oop != NULL) {\n+  if (archived_oop != nullptr) {\n@@ -330,1 +330,1 @@\n-    if (_original_object_table != NULL) {\n+    if (_original_object_table != nullptr) {\n@@ -358,1 +358,1 @@\n-    if (handle != NULL) {\n+    if (handle != nullptr) {\n@@ -361,1 +361,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -373,1 +373,1 @@\n-    if (handle != NULL) {\n+    if (handle != nullptr) {\n@@ -416,1 +416,1 @@\n-      assert(m != NULL, \"sanity\");\n+      assert(m != nullptr, \"sanity\");\n@@ -418,1 +418,1 @@\n-      assert(archived_m != NULL, \"sanity\");\n+      assert(archived_m != nullptr, \"sanity\");\n@@ -429,1 +429,1 @@\n-  assert(klasses != NULL, \"sanity\");\n+  assert(klasses != nullptr, \"sanity\");\n@@ -433,1 +433,1 @@\n-    if (m != NULL) {\n+    if (m != nullptr) {\n@@ -436,1 +436,1 @@\n-      guarantee(archived_m != NULL, \"scratch mirrors should not point to any unachivable objects\");\n+      guarantee(archived_m != nullptr, \"scratch mirrors should not point to any unachivable objects\");\n@@ -463,1 +463,1 @@\n-  if (ptr != NULL) {\n+  if (ptr != nullptr) {\n@@ -523,1 +523,1 @@\n-        if (oop_field == NULL) {\n+        if (oop_field == nullptr) {\n@@ -548,1 +548,1 @@\n-  assert(info != NULL, \"sanity\");\n+  assert(info != nullptr, \"sanity\");\n@@ -665,1 +665,1 @@\n-  int length = _pending_roots != NULL ? _pending_roots->length() : 0;\n+  int length = _pending_roots != nullptr ? _pending_roots->length() : 0;\n@@ -692,1 +692,1 @@\n-HeapShared::DumpTimeKlassSubGraphInfoTable* HeapShared::_dump_time_subgraph_info_table = NULL;\n+HeapShared::DumpTimeKlassSubGraphInfoTable* HeapShared::_dump_time_subgraph_info_table = nullptr;\n@@ -712,1 +712,1 @@\n-  assert(info != NULL, \"must have been initialized\");\n+  assert(info != nullptr, \"must have been initialized\");\n@@ -720,1 +720,1 @@\n-  if (_subgraph_entry_fields == NULL) {\n+  if (_subgraph_entry_fields == nullptr) {\n@@ -734,1 +734,1 @@\n-  if (_subgraph_object_klasses == NULL) {\n+  if (_subgraph_object_klasses == nullptr) {\n@@ -790,1 +790,1 @@\n-    assert(ik->package() != NULL, \"classes in java.base cannot be in unnamed package\");\n+    assert(ik->package() != nullptr, \"classes in java.base cannot be in unnamed package\");\n@@ -795,1 +795,1 @@\n-  if (!ik->module()->is_named() && ik->package() == NULL) {\n+  if (!ik->module()->is_named() && ik->package() == nullptr) {\n@@ -830,2 +830,2 @@\n-  _entry_field_records = NULL;\n-  _subgraph_object_klasses = NULL;\n+  _entry_field_records = nullptr;\n+  _subgraph_object_klasses = nullptr;\n@@ -852,1 +852,1 @@\n-  if (entry_fields != NULL) {\n+  if (entry_fields != nullptr) {\n@@ -864,1 +864,1 @@\n-  if (subgraph_object_klasses != NULL) {\n+  if (subgraph_object_klasses != nullptr) {\n@@ -891,1 +891,1 @@\n-    if (info.subgraph_object_klasses() != NULL || info.subgraph_entry_fields() != NULL) {\n+    if (info.subgraph_object_klasses() != nullptr || info.subgraph_entry_fields() != nullptr) {\n@@ -925,1 +925,1 @@\n-  if (ArchiveHeapTestClass != NULL) {\n+  if (ArchiveHeapTestClass != nullptr) {\n@@ -938,1 +938,1 @@\n-  oop roots_oop = NULL;\n+  oop roots_oop = nullptr;\n@@ -944,1 +944,1 @@\n-    if (roots_oop != NULL) {\n+    if (roots_oop != nullptr) {\n@@ -959,1 +959,1 @@\n-  if (soc->reading() && _archived_ArchiveHeapTestClass != NULL) {\n+  if (soc->reading() && _archived_ArchiveHeapTestClass != nullptr) {\n@@ -1016,1 +1016,1 @@\n-    assert(k != NULL && k->is_shared_boot_class(), \"sanity\");\n+    assert(k != nullptr && k->is_shared_boot_class(), \"sanity\");\n@@ -1029,1 +1029,1 @@\n-  if (record == NULL) {\n+  if (record == nullptr) {\n@@ -1052,1 +1052,1 @@\n-  if (record != NULL) {\n+  if (record != nullptr) {\n@@ -1062,1 +1062,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1068,1 +1068,1 @@\n-  if (_test_class_name != NULL && k->name()->equals(_test_class_name) && record != NULL) {\n+  if (_test_class_name != nullptr && k->name()->equals(_test_class_name) && record != nullptr) {\n@@ -1076,1 +1076,1 @@\n-  if (record != NULL) {\n+  if (record != nullptr) {\n@@ -1083,1 +1083,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -1092,1 +1092,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -1103,1 +1103,1 @@\n-    \/\/ NULL class loader is used.\n+    \/\/ nullptr class loader is used.\n@@ -1105,1 +1105,1 @@\n-    if (klasses != NULL) {\n+    if (klasses != nullptr) {\n@@ -1109,1 +1109,1 @@\n-          return NULL;\n+          return nullptr;\n@@ -1121,1 +1121,1 @@\n-    if (k->class_loader_data() == NULL) {\n+    if (k->class_loader_data() == nullptr) {\n@@ -1126,1 +1126,1 @@\n-    assert(k->class_loader_data() != NULL, \"must have been resolved by HeapShared::resolve_classes\");\n+    assert(k->class_loader_data() != nullptr, \"must have been resolved by HeapShared::resolve_classes\");\n@@ -1144,1 +1144,1 @@\n-  if (entry_field_records != NULL) {\n+  if (entry_field_records != nullptr) {\n@@ -1170,1 +1170,1 @@\n-  if (record != NULL) {\n+  if (record != nullptr) {\n@@ -1172,1 +1172,1 @@\n-    if (entry_field_records != NULL) {\n+    if (entry_field_records != nullptr) {\n@@ -1238,1 +1238,1 @@\n-      assert(archived != NULL, \"VM should have exited with unarchivable objects for _level > 1\");\n+      assert(archived != nullptr, \"VM should have exited with unarchivable objects for _level > 1\");\n@@ -1256,1 +1256,1 @@\n-WalkOopAndArchiveClosure* WalkOopAndArchiveClosure::_current = NULL;\n+WalkOopAndArchiveClosure* WalkOopAndArchiveClosure::_current = nullptr;\n@@ -1262,2 +1262,2 @@\n-  info._subgraph_info = (walker == NULL) ? NULL : walker->subgraph_info();\n-  info._referrer = (walker == NULL) ? NULL : walker->orig_referencing_obj();\n+  info._subgraph_info = (walker == nullptr) ? nullptr : walker->subgraph_info();\n+  info._referrer = (walker == nullptr) ? nullptr : walker->orig_referencing_obj();\n@@ -1293,1 +1293,1 @@\n-  assert(orig_obj != NULL, \"must be\");\n+  assert(orig_obj != nullptr, \"must be\");\n@@ -1316,1 +1316,1 @@\n-  if (java_lang_String::is_instance(orig_obj) && archived_obj != NULL) {\n+  if (java_lang_String::is_instance(orig_obj) && archived_obj != nullptr) {\n@@ -1329,2 +1329,2 @@\n-  bool record_klasses_only = (archived_obj != NULL);\n-  if (archived_obj == NULL) {\n+  bool record_klasses_only = (archived_obj != nullptr);\n+  if (archived_obj == nullptr) {\n@@ -1333,1 +1333,1 @@\n-    if (archived_obj == NULL) {\n+    if (archived_obj == nullptr) {\n@@ -1343,1 +1343,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -1356,1 +1356,1 @@\n-      java_lang_Module::set_module_entry(archived_obj, NULL);\n+      java_lang_Module::set_module_entry(archived_obj, nullptr);\n@@ -1361,2 +1361,2 @@\n-                java_lang_ClassLoader::loader_data(orig_obj) == NULL, \"must be\");\n-      java_lang_ClassLoader::release_set_loader_data(archived_obj, NULL);\n+                java_lang_ClassLoader::loader_data(orig_obj) == nullptr, \"must be\");\n+      java_lang_ClassLoader::release_set_loader_data(archived_obj, nullptr);\n@@ -1366,1 +1366,1 @@\n-  assert(archived_obj != NULL, \"must be\");\n+  assert(archived_obj != nullptr, \"must be\");\n@@ -1439,1 +1439,1 @@\n-    if (af == NULL) {\n+    if (af == nullptr) {\n@@ -1452,1 +1452,1 @@\n-    subgraph_info->add_subgraph_entry_field(field_offset, NULL, false);\n+    subgraph_info->add_subgraph_entry_field(field_offset, nullptr, false);\n@@ -1489,1 +1489,1 @@\n-  if (archived_obj == NULL) {\n+  if (archived_obj == nullptr) {\n@@ -1516,1 +1516,1 @@\n-      assert(find_archived_heap_object(obj) == NULL, \"must be\");\n+      assert(find_archived_heap_object(obj) == nullptr, \"must be\");\n@@ -1519,1 +1519,1 @@\n-      assert(find_archived_heap_object(obj) != NULL, \"must be\");\n+      assert(find_archived_heap_object(obj) != nullptr, \"must be\");\n@@ -1553,1 +1553,1 @@\n-HeapShared::SeenObjectsTable* HeapShared::_seen_objects_table = NULL;\n+HeapShared::SeenObjectsTable* HeapShared::_seen_objects_table = nullptr;\n@@ -1565,1 +1565,1 @@\n-  return _seen_objects_table->get(obj) != NULL;\n+  return _seen_objects_table->get(obj) != nullptr;\n@@ -1630,1 +1630,1 @@\n-    bool is_test_class = (ArchiveHeapTestClass != NULL) && (strcmp(info->klass_name, ArchiveHeapTestClass) == 0);\n+    bool is_test_class = (ArchiveHeapTestClass != nullptr) && (strcmp(info->klass_name, ArchiveHeapTestClass) == 0);\n@@ -1666,1 +1666,1 @@\n-      if (ik->package() != NULL) {\n+      if (ik->package() != nullptr) {\n@@ -1715,2 +1715,2 @@\n-  assert(p[num_slots - 2].klass_name == NULL, \"must have empty slot that's patched below\");\n-  assert(p[num_slots - 1].klass_name == NULL, \"must have empty slot that marks the end of the list\");\n+  assert(p[num_slots - 2].klass_name == nullptr, \"must have empty slot that's patched below\");\n+  assert(p[num_slots - 1].klass_name == nullptr, \"must have empty slot that marks the end of the list\");\n@@ -1718,1 +1718,1 @@\n-  if (test_class_name != NULL) {\n+  if (test_class_name != nullptr) {\n@@ -1728,1 +1728,1 @@\n-  if (_test_class != NULL) {\n+  if (_test_class != nullptr) {\n@@ -1733,1 +1733,1 @@\n-    if (klasses == NULL) {\n+    if (klasses == nullptr) {\n@@ -1874,1 +1874,1 @@\n-    if ((*p) != NULL) {\n+    if ((*p) != nullptr) {\n@@ -1892,1 +1892,1 @@\n-  if (dumptime_addr == NULL || UseCompressedOops) {\n+  if (dumptime_addr == nullptr || UseCompressedOops) {\n@@ -1913,1 +1913,1 @@\n-  assert(REQUESTED_BASE != 0 && requested_addr != NULL, \"sanity\");\n+  assert(REQUESTED_BASE != 0 && requested_addr != nullptr, \"sanity\");\n@@ -1924,1 +1924,1 @@\n-  ArchiveBuilder* builder = DumpSharedSpaces ? ArchiveBuilder::current() : NULL;\n+  ArchiveBuilder* builder = DumpSharedSpaces ? ArchiveBuilder::current() : nullptr;\n@@ -1955,1 +1955,1 @@\n-      assert(*p != NULL, \"must be non-null\");\n+      assert(*p != nullptr, \"must be non-null\");\n","filename":"src\/hotspot\/share\/cds\/heapShared.cpp","additions":105,"deletions":105,"binary":false,"changes":210,"status":"modified"},{"patch":"@@ -79,2 +79,2 @@\n-    _k(k),  _subgraph_object_klasses(NULL),\n-    _subgraph_entry_fields(NULL),\n+    _k(k),  _subgraph_object_klasses(nullptr),\n+    _subgraph_entry_fields(nullptr),\n@@ -85,1 +85,1 @@\n-    if (_subgraph_object_klasses != NULL) {\n+    if (_subgraph_object_klasses != nullptr) {\n@@ -88,1 +88,1 @@\n-    if (_subgraph_entry_fields != NULL) {\n+    if (_subgraph_entry_fields != nullptr) {\n@@ -104,1 +104,1 @@\n-    return _subgraph_object_klasses == NULL ? 0 :\n+    return _subgraph_object_klasses == nullptr ? 0 :\n@@ -128,1 +128,1 @@\n-    _k(NULL), _entry_field_records(NULL), _subgraph_object_klasses(NULL) {}\n+    _k(nullptr), _entry_field_records(nullptr), _subgraph_object_klasses(nullptr) {}\n@@ -162,2 +162,2 @@\n-  static oop scratch_java_mirror(BasicType t) NOT_CDS_JAVA_HEAP_RETURN_(NULL);\n-  static oop scratch_java_mirror(Klass* k)    NOT_CDS_JAVA_HEAP_RETURN_(NULL);\n+  static oop scratch_java_mirror(BasicType t) NOT_CDS_JAVA_HEAP_RETURN_(nullptr);\n+  static oop scratch_java_mirror(Klass* k)    NOT_CDS_JAVA_HEAP_RETURN_(nullptr);\n@@ -292,1 +292,1 @@\n-    assert(_seen_objects_table == NULL, \"must be\");\n+    assert(_seen_objects_table == nullptr, \"must be\");\n@@ -296,1 +296,1 @@\n-    assert(_seen_objects_table != NULL, \"must be\");\n+    assert(_seen_objects_table != nullptr, \"must be\");\n@@ -298,1 +298,1 @@\n-    _seen_objects_table = NULL;\n+    _seen_objects_table = nullptr;\n@@ -350,1 +350,1 @@\n-      _original_object_table = NULL;\n+      _original_object_table = nullptr;\n@@ -355,2 +355,2 @@\n-    _archived_object_cache = NULL;\n-    if (_original_object_table != NULL) {\n+    _archived_object_cache = nullptr;\n+    if (_original_object_table != nullptr) {\n@@ -358,1 +358,1 @@\n-      _original_object_table = NULL;\n+      _original_object_table = nullptr;\n@@ -365,1 +365,1 @@\n-    assert(_original_object_table != NULL, \"sanity\");\n+    assert(_original_object_table != nullptr, \"sanity\");\n@@ -367,2 +367,2 @@\n-    if (r == NULL) {\n-      return NULL;\n+    if (r == nullptr) {\n+      return nullptr;\n@@ -448,1 +448,1 @@\n-  static address to_requested_address(address dumptime_addr) NOT_CDS_JAVA_HEAP_RETURN_(NULL);\n+  static address to_requested_address(address dumptime_addr) NOT_CDS_JAVA_HEAP_RETURN_(nullptr);\n","filename":"src\/hotspot\/share\/cds\/heapShared.hpp","additions":19,"deletions":19,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -74,1 +74,1 @@\n-  if (_lambdaform_lines == NULL) {\n+  if (_lambdaform_lines == nullptr) {\n@@ -121,1 +121,1 @@\n-  guarantee(cds_klass != NULL, \"jdk\/internal\/misc\/CDS must exist!\");\n+  guarantee(cds_klass != nullptr, \"jdk\/internal\/misc\/CDS must exist!\");\n@@ -164,2 +164,2 @@\n-    assert(h_name != NULL, \"Class name is NULL\");\n-    assert(h_bytes != NULL, \"Class bytes is NULL\");\n+    assert(h_name != nullptr, \"Class name is null\");\n+    assert(h_bytes != nullptr, \"Class bytes is null\");\n@@ -174,1 +174,1 @@\n-      assert(klass != NULL, \"must already be loaded\");\n+      assert(klass != nullptr, \"must already be loaded\");\n@@ -187,1 +187,1 @@\n-      ClassFileStream st((u1*)buf, len, NULL, ClassFileStream::verify);\n+      ClassFileStream st((u1*)buf, len, nullptr, ClassFileStream::verify);\n@@ -196,1 +196,1 @@\n-  assert(klass != NULL, \"must exist\");\n+  assert(klass != nullptr, \"must exist\");\n","filename":"src\/hotspot\/share\/cds\/lambdaFormInvokers.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,2 +33,2 @@\n-  _proxy_klasses = NULL;\n-  if (src._proxy_klasses != NULL && src._proxy_klasses->length() > 0) {\n+  _proxy_klasses = nullptr;\n+  if (src._proxy_klasses != nullptr && src._proxy_klasses->length() > 0) {\n@@ -44,1 +44,1 @@\n-  if (_proxy_klasses != NULL) {\n+  if (_proxy_klasses != nullptr) {\n","filename":"src\/hotspot\/share\/cds\/lambdaProxyClassDictionary.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -80,2 +80,2 @@\n-    if (sym == NULL) {\n-      \/\/ _invoked_name maybe NULL\n+    if (sym == nullptr) {\n+      \/\/ _invoked_name maybe null\n@@ -110,1 +110,1 @@\n-  DumpTimeLambdaProxyClassInfo() : _proxy_klasses(NULL) {}\n+  DumpTimeLambdaProxyClassInfo() : _proxy_klasses(nullptr) {}\n@@ -116,1 +116,1 @@\n-    if (_proxy_klasses == NULL) {\n+    if (_proxy_klasses == nullptr) {\n@@ -119,1 +119,1 @@\n-    assert(_proxy_klasses != NULL, \"sanity\");\n+    assert(_proxy_klasses != nullptr, \"sanity\");\n","filename":"src\/hotspot\/share\/cds\/lambdaProxyClassDictionary.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -93,1 +93,1 @@\n-void* MetaspaceShared::_shared_metaspace_static_top = NULL;\n+void* MetaspaceShared::_shared_metaspace_static_top = nullptr;\n@@ -188,1 +188,1 @@\n-    for (Klass* klass = cld->klasses(); klass != NULL; klass = klass->next_link()) {\n+    for (Klass* klass = cld->klasses(); klass != nullptr; klass = klass->next_link()) {\n@@ -209,1 +209,1 @@\n-  if (specified_base != NULL && aligned_base < specified_base) {\n+  if (specified_base != nullptr && aligned_base < specified_base) {\n@@ -226,1 +226,1 @@\n-  const char* err = NULL;\n+  const char* err = nullptr;\n@@ -285,1 +285,1 @@\n-        if (FileMapInfo::dynamic_info() == NULL) {\n+        if (FileMapInfo::dynamic_info() == nullptr) {\n@@ -297,2 +297,2 @@\n-static GrowableArrayCHeap<OopHandle, mtClassShared>* _extra_interned_strings = NULL;\n-static GrowableArrayCHeap<Symbol*, mtClassShared>* _extra_symbols = NULL;\n+static GrowableArrayCHeap<OopHandle, mtClassShared>* _extra_interned_strings = nullptr;\n+static GrowableArrayCHeap<Symbol*, mtClassShared>* _extra_symbols = nullptr;\n@@ -347,1 +347,1 @@\n-        assert(str != NULL, \"must succeed\");\n+        assert(str != nullptr, \"must succeed\");\n@@ -462,4 +462,4 @@\n-    _closed_heap_regions(NULL),\n-    _open_heap_regions(NULL),\n-    _closed_heap_bitmaps(NULL),\n-    _open_heap_bitmaps(NULL) {}\n+    _closed_heap_regions(nullptr),\n+    _open_heap_regions(nullptr),\n+    _closed_heap_bitmaps(nullptr),\n+    _open_heap_bitmaps(nullptr) {}\n@@ -489,1 +489,1 @@\n-    if (_extra_symbols != NULL) {\n+    if (_extra_symbols != nullptr) {\n@@ -627,1 +627,1 @@\n-    \/\/ tolerate this. (Note that unregistered classes are loaded by the NULL\n+    \/\/ tolerate this. (Note that unregistered classes are loaded by the null\n@@ -665,1 +665,1 @@\n-      for (Klass* klass = cld->klasses(); klass != NULL; klass = klass->next_link()) {\n+      for (Klass* klass = cld->klasses(); klass != nullptr; klass = klass->next_link()) {\n@@ -743,1 +743,1 @@\n-    if (end != NULL) *end = '\\0';\n+    if (end != nullptr) *end = '\\0';\n@@ -768,1 +768,1 @@\n-  if (SharedClassListFile == NULL) {\n+  if (SharedClassListFile == nullptr) {\n@@ -839,1 +839,1 @@\n-    if (ik->is_shared_unregistered_class() && ik->class_loader() == NULL) {\n+    if (ik->is_shared_unregistered_class() && ik->class_loader() == nullptr) {\n@@ -841,1 +841,1 @@\n-      \/\/ for non-system classes. Since we are using the NULL classloader\n+      \/\/ for non-system classes. Since we are using the null classloader\n@@ -886,1 +886,1 @@\n-  if (_extra_interned_strings != NULL) {\n+  if (_extra_interned_strings != nullptr) {\n@@ -936,1 +936,1 @@\n-    buffer = NULL;\n+    buffer = nullptr;\n@@ -973,1 +973,1 @@\n-  FileMapInfo* dynamic_mapinfo = NULL;\n+  FileMapInfo* dynamic_mapinfo = nullptr;\n@@ -975,1 +975,1 @@\n-  if (static_mapinfo != NULL) {\n+  if (static_mapinfo != nullptr) {\n@@ -990,1 +990,1 @@\n-    bool dynamic_mapped = (dynamic_mapinfo != NULL && dynamic_mapinfo->is_mapped());\n+    bool dynamic_mapped = (dynamic_mapinfo != nullptr && dynamic_mapinfo->is_mapped());\n@@ -1004,1 +1004,1 @@\n-    set_shared_metaspace_range(NULL, NULL, NULL);\n+    set_shared_metaspace_range(nullptr, nullptr, nullptr);\n@@ -1018,1 +1018,1 @@\n-  if (static_mapinfo != NULL && !static_mapinfo->is_mapped()) {\n+  if (static_mapinfo != nullptr && !static_mapinfo->is_mapped()) {\n@@ -1021,1 +1021,1 @@\n-  if (dynamic_mapinfo != NULL && !dynamic_mapinfo->is_mapped()) {\n+  if (dynamic_mapinfo != nullptr && !dynamic_mapinfo->is_mapped()) {\n@@ -1028,1 +1028,1 @@\n-  assert(static_archive != nullptr, \"SharedArchivePath is NULL\");\n+  assert(static_archive != nullptr, \"SharedArchivePath is nullptr\");\n@@ -1032,1 +1032,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1039,1 +1039,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1043,1 +1043,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1049,1 +1049,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1059,1 +1059,1 @@\n-  if (use_requested_addr && static_mapinfo->requested_base_address() == NULL) {\n+  if (use_requested_addr && static_mapinfo->requested_base_address() == nullptr) {\n@@ -1077,1 +1077,1 @@\n-  if (dynamic_mapinfo != NULL) {\n+  if (dynamic_mapinfo != nullptr) {\n@@ -1091,1 +1091,1 @@\n-  if (mapped_base_address == NULL) {\n+  if (mapped_base_address == nullptr) {\n@@ -1166,1 +1166,1 @@\n-        assert(dynamic_mapinfo != NULL && !dynamic_mapinfo->is_mapped(), \"must have failed\");\n+        assert(dynamic_mapinfo != nullptr && !dynamic_mapinfo->is_mapped(), \"must have failed\");\n@@ -1271,1 +1271,1 @@\n-\/\/ - On error: NULL is returned and the spaces remain unreserved.\n+\/\/ - On error: null is returned and the spaces remain unreserved.\n@@ -1279,1 +1279,1 @@\n-  address const base_address = (address) (use_archive_base_addr ? static_mapinfo->requested_base_address() : NULL);\n+  address const base_address = (address) (use_archive_base_addr ? static_mapinfo->requested_base_address() : nullptr);\n@@ -1284,1 +1284,1 @@\n-  size_t archive_end_offset  = (dynamic_mapinfo == NULL) ? static_mapinfo->mapping_end_offset() : dynamic_mapinfo->mapping_end_offset();\n+  size_t archive_end_offset  = (dynamic_mapinfo == nullptr) ? static_mapinfo->mapping_end_offset() : dynamic_mapinfo->mapping_end_offset();\n@@ -1288,1 +1288,1 @@\n-  if (base_address != NULL) {\n+  if (base_address != nullptr) {\n@@ -1303,1 +1303,1 @@\n-      assert(base_address == NULL ||\n+      assert(base_address == nullptr ||\n@@ -1309,1 +1309,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1356,1 +1356,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -1368,1 +1368,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -1372,1 +1372,1 @@\n-    assert(base_address == NULL || (address)total_space_rs.base() == base_address,\n+    assert(base_address == nullptr || (address)total_space_rs.base() == base_address,\n@@ -1399,1 +1399,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1427,1 +1427,1 @@\n-  if (mapinfo == NULL) {\n+  if (mapinfo == nullptr) {\n@@ -1457,1 +1457,1 @@\n-  if (mapinfo != NULL) {\n+  if (mapinfo != nullptr) {\n@@ -1506,1 +1506,1 @@\n-  if (dynamic_mapinfo != NULL) {\n+  if (dynamic_mapinfo != nullptr) {\n@@ -1544,1 +1544,1 @@\n-    if (FileMapInfo::current_info() == NULL || _archive_loading_failed) {\n+    if (FileMapInfo::current_info() == nullptr || _archive_loading_failed) {\n@@ -1564,1 +1564,1 @@\n-    if (FileMapInfo::dynamic_info() != NULL) {\n+    if (FileMapInfo::dynamic_info() != nullptr) {\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":52,"deletions":52,"binary":false,"changes":104,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,1 @@\n-  assert(name != NULL, \"invariant\");\n+  assert(name != nullptr, \"invariant\");\n@@ -80,1 +80,1 @@\n-static URLClassLoaderTable* _url_classloader_table = NULL;\n+static URLClassLoaderTable* _url_classloader_table = nullptr;\n@@ -104,1 +104,1 @@\n-  if (_url_classloader_table == NULL) {\n+  if (_url_classloader_table == nullptr) {\n@@ -108,1 +108,1 @@\n-  if (url_classloader_ptr != NULL) {\n+  if (url_classloader_ptr != nullptr) {\n","filename":"src\/hotspot\/share\/cds\/unregisteredClasses.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"}]}