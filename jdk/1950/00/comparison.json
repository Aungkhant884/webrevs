{"files":[{"patch":"@@ -3009,0 +3009,10 @@\n+void MacroAssembler::vpaddb(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register rscratch) {\n+  assert(UseAVX > 0, \"requires some form of AVX\");\n+  if (reachable(src)) {\n+    Assembler::vpaddb(dst, nds, as_Address(src), vector_len);\n+  } else {\n+    lea(rscratch, src);\n+    Assembler::vpaddb(dst, nds, Address(rscratch, 0), vector_len);\n+  }\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -1244,0 +1244,1 @@\n+  void vpaddb(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register rscratch);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -613,0 +613,15 @@\n+  address generate_vector_byte_shuffle_mask(const char *stub_name) {\n+    __ align(CodeEntryAlignment);\n+    StubCodeMark mark(this, \"StubRoutines\", stub_name);\n+    address start = __ pc();\n+    __ emit_data(0x70707070, relocInfo::none, 0);\n+    __ emit_data(0x70707070, relocInfo::none, 0);\n+    __ emit_data(0x70707070, relocInfo::none, 0);\n+    __ emit_data(0x70707070, relocInfo::none, 0);\n+    __ emit_data(0xF0F0F0F0, relocInfo::none, 0);\n+    __ emit_data(0xF0F0F0F0, relocInfo::none, 0);\n+    __ emit_data(0xF0F0F0F0, relocInfo::none, 0);\n+    __ emit_data(0xF0F0F0F0, relocInfo::none, 0);\n+    return start;\n+  }\n+\n@@ -3969,0 +3984,1 @@\n+    StubRoutines::x86::_vector_byte_shuffle_mask = generate_vector_byte_shuffle_mask(\"vector_byte_shuffle_mask\");\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_32.cpp","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -811,0 +811,11 @@\n+  address generate_vector_byte_shuffle_mask(const char *stub_name) {\n+    __ align(CodeEntryAlignment);\n+    StubCodeMark mark(this, \"StubRoutines\", stub_name);\n+    address start = __ pc();\n+    __ emit_data64(0x7070707070707070, relocInfo::none);\n+    __ emit_data64(0x7070707070707070, relocInfo::none);\n+    __ emit_data64(0xF0F0F0F0F0F0F0F0, relocInfo::none);\n+    __ emit_data64(0xF0F0F0F0F0F0F0F0, relocInfo::none);\n+    return start;\n+  }\n+\n@@ -6831,0 +6842,1 @@\n+    StubRoutines::x86::_vector_byte_shuffle_mask = generate_vector_byte_shuffle_mask(\"vector_byte_shuffle_mask\");\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,0 +50,1 @@\n+address StubRoutines::x86::_vector_byte_shuffle_mask = NULL;\n","filename":"src\/hotspot\/cpu\/x86\/stubRoutines_x86.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -152,0 +152,1 @@\n+  static address _vector_byte_shuffle_mask;\n@@ -283,0 +284,4 @@\n+  static address vector_byte_shuffle_mask() {\n+    return _vector_byte_shuffle_mask;\n+  }\n+\n","filename":"src\/hotspot\/cpu\/x86\/stubRoutines_x86.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-\/\/ Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -1357,0 +1357,1 @@\n+  static address vector_byte_shufflemask() { return StubRoutines::x86::vector_byte_shuffle_mask(); }\n@@ -1694,1 +1695,1 @@\n-      } else if (bt == T_BYTE && size_in_bits >= 256 && !VM_Version::supports_avx512_vbmi())  {\n+      } else if (bt == T_BYTE && size_in_bits > 256 && !VM_Version::supports_avx512_vbmi())  {\n@@ -1696,1 +1697,1 @@\n-      } else if (bt == T_SHORT && size_in_bits >= 256 && !VM_Version::supports_avx512bw())  {\n+      } else if (bt == T_SHORT && size_in_bits > 256 && !VM_Version::supports_avx512bw())  {\n@@ -7503,1 +7504,1 @@\n-instruct rearrangeB_avx(vec dst, vec src, vec shuffle) %{\n+instruct rearrangeB_avx(legVec dst, legVec src, vec shuffle, legVec vtmp1, legVec vtmp2, rRegP scratch) %{\n@@ -7507,1 +7508,2 @@\n-  format %{ \"vector_rearrange $dst, $shuffle, $src\" %}\n+  effect(TEMP dst, TEMP vtmp1, TEMP vtmp2, TEMP scratch);\n+  format %{ \"vector_rearrange $dst, $shuffle, $src\\t! using $vtmp1, $vtmp2, $scratch as TEMP\" %}\n@@ -7509,1 +7511,11 @@\n-    __ vpshufb($dst$$XMMRegister, $shuffle$$XMMRegister, $src$$XMMRegister, Assembler::AVX_256bit);\n+    assert(UseAVX >= 2, \"required\");\n+    \/\/ Swap src into vtmp1\n+    __ vperm2i128($vtmp1$$XMMRegister, $src$$XMMRegister, $src$$XMMRegister, 1);\n+    \/\/ Shuffle swapped src to get entries from other 128 bit lane\n+    __ vpshufb($vtmp1$$XMMRegister, $vtmp1$$XMMRegister, $shuffle$$XMMRegister, Assembler::AVX_256bit);\n+    \/\/ Shuffle original src to get entries from self 128 bit lane\n+    __ vpshufb($dst$$XMMRegister, $src$$XMMRegister, $shuffle$$XMMRegister, Assembler::AVX_256bit);\n+    \/\/ Create a blend mask by setting high bits for entries coming from other lane in shuffle\n+    __ vpaddb($vtmp2$$XMMRegister, $shuffle$$XMMRegister, ExternalAddress(vector_byte_shufflemask()), Assembler::AVX_256bit, $scratch$$Register);\n+    \/\/ Perform the blend\n+    __ vpblendvb($dst$$XMMRegister, $dst$$XMMRegister, $vtmp1$$XMMRegister, $vtmp2$$XMMRegister, Assembler::AVX_256bit);\n@@ -7530,1 +7542,1 @@\n-            vector_length(n) <= 8 && !VM_Version::supports_avx512bw()); \/\/ NB! aligned with rearrangeS\n+            vector_length(n) <= 16 && !VM_Version::supports_avx512bw()); \/\/ NB! aligned with rearrangeS\n@@ -7537,0 +7549,19 @@\n+    int vlen_in_bytes = vector_length_in_bytes(this);\n+    if (vlen_in_bytes <= 8) {\n+      \/\/ Multiply each shuffle by two to get byte index\n+      __ pmovzxbw($vtmp$$XMMRegister, $src$$XMMRegister);\n+      __ psllw($vtmp$$XMMRegister, 1);\n+\n+      \/\/ Duplicate to create 2 copies of byte index\n+      __ movdqu($dst$$XMMRegister, $vtmp$$XMMRegister);\n+      __ psllw($dst$$XMMRegister, 8);\n+      __ por($dst$$XMMRegister, $vtmp$$XMMRegister);\n+\n+      \/\/ Add one to get alternate byte index\n+      __ movdqu($vtmp$$XMMRegister, ExternalAddress(vector_short_shufflemask()), $scratch$$Register);\n+      __ paddb($dst$$XMMRegister, $vtmp$$XMMRegister);\n+    } else {\n+      int vlen_enc = vector_length_encoding(this);\n+      \/\/ Multiply each shuffle by two to get byte index\n+      __ vpmovzxbw($vtmp$$XMMRegister, $src$$XMMRegister, vlen_enc);\n+      __ vpsllw($vtmp$$XMMRegister, $vtmp$$XMMRegister, 1, vlen_enc);\n@@ -7538,8 +7569,3 @@\n-    \/\/ Multiply each shuffle by two to get byte index\n-    __ pmovzxbw($vtmp$$XMMRegister, $src$$XMMRegister);\n-    __ psllw($vtmp$$XMMRegister, 1);\n-\n-    \/\/ Duplicate to create 2 copies of byte index\n-    __ movdqu($dst$$XMMRegister, $vtmp$$XMMRegister);\n-    __ psllw($dst$$XMMRegister, 8);\n-    __ por($dst$$XMMRegister, $vtmp$$XMMRegister);\n+      \/\/ Duplicate to create 2 copies of byte index\n+      __ vpsllw($dst$$XMMRegister, $vtmp$$XMMRegister,  8, vlen_enc);\n+      __ vpor($dst$$XMMRegister, $dst$$XMMRegister, $vtmp$$XMMRegister, vlen_enc);\n@@ -7547,3 +7573,3 @@\n-    \/\/ Add one to get alternate byte index\n-    __ movdqu($vtmp$$XMMRegister, ExternalAddress(vector_short_shufflemask()), $scratch$$Register);\n-    __ paddb($dst$$XMMRegister, $vtmp$$XMMRegister);\n+      \/\/ Add one to get alternate byte index\n+      __ vpaddb($dst$$XMMRegister, $dst$$XMMRegister, ExternalAddress(vector_short_shufflemask()), vlen_enc, $scratch$$Register);\n+    }\n@@ -7566,0 +7592,22 @@\n+instruct rearrangeS_avx(legVec dst, legVec src, vec shuffle, legVec vtmp1, legVec vtmp2, rRegP scratch) %{\n+  predicate(vector_element_basic_type(n) == T_SHORT &&\n+            vector_length(n) == 16 && !VM_Version::supports_avx512bw());\n+  match(Set dst (VectorRearrange src shuffle));\n+  effect(TEMP dst, TEMP vtmp1, TEMP vtmp2, TEMP scratch);\n+  format %{ \"vector_rearrange $dst, $shuffle, $src\\t! using $vtmp1, $vtmp2, $scratch as TEMP\" %}\n+  ins_encode %{\n+    assert(UseAVX >= 2, \"required\");\n+    \/\/ Swap src into vtmp1\n+    __ vperm2i128($vtmp1$$XMMRegister, $src$$XMMRegister, $src$$XMMRegister, 1);\n+    \/\/ Shuffle swapped src to get entries from other 128 bit lane\n+    __ vpshufb($vtmp1$$XMMRegister, $vtmp1$$XMMRegister, $shuffle$$XMMRegister, Assembler::AVX_256bit);\n+    \/\/ Shuffle original src to get entries from self 128 bit lane\n+    __ vpshufb($dst$$XMMRegister, $src$$XMMRegister, $shuffle$$XMMRegister, Assembler::AVX_256bit);\n+    \/\/ Create a blend mask by setting high bits for entries coming from other lane in shuffle\n+    __ vpaddb($vtmp2$$XMMRegister, $shuffle$$XMMRegister, ExternalAddress(vector_byte_shufflemask()), Assembler::AVX_256bit, $scratch$$Register);\n+    \/\/ Perform the blend\n+    __ vpblendvb($dst$$XMMRegister, $dst$$XMMRegister, $vtmp1$$XMMRegister, $vtmp2$$XMMRegister, Assembler::AVX_256bit);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":66,"deletions":18,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -384,1 +384,8 @@\n-        return (Byte128Vector) super.sliceTemplate(origin, v);  \/\/ specialize\n+        if ((origin < 0) || (origin >= VLENGTH)) {\n+            throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+        } else {\n+            Byte128Shuffle Iota = iotaShuffle();\n+            VectorMask<Byte> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((byte)(VLENGTH - origin))));\n+            Iota = iotaShuffle(origin, 1, true);\n+            return ((Byte128Vector)v).rearrange(Iota).blend(this.rearrange(Iota), BlendMask);\n+        }\n@@ -390,8 +397,8 @@\n-       if ((origin < 0) || (origin >= VLENGTH)) {\n-         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n-       } else {\n-         Byte128Shuffle Iota = iotaShuffle();\n-         VectorMask<Byte> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((byte)(VLENGTH-origin))));\n-         Iota = iotaShuffle(origin, 1, true);\n-         return ZERO.blend(this.rearrange(Iota), BlendMask);\n-       }\n+        if ((origin < 0) || (origin >= VLENGTH)) {\n+            throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+        } else {\n+            Byte128Shuffle Iota = iotaShuffle();\n+            VectorMask<Byte> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((byte)(VLENGTH - origin))));\n+            Iota = iotaShuffle(origin, 1, true);\n+            return ZERO.blend(this.rearrange(Iota), BlendMask);\n+        }\n@@ -403,1 +410,9 @@\n-        return (Byte128Vector) super.unsliceTemplate(origin, w, part);  \/\/ specialize\n+        if ((origin < 0) || (origin >= VLENGTH)) {\n+            throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+        } else {\n+            Byte128Shuffle Iota = iotaShuffle();\n+            VectorMask<Byte> BlendMask = Iota.toVector().compare((part == 0) ? VectorOperators.GE : VectorOperators.LT,\n+                                                               (broadcast((byte)(origin))));\n+            Iota = iotaShuffle(-origin, 1, true);\n+            return ((Byte128Vector)w).blend(this.rearrange(Iota), BlendMask);\n+        }\n@@ -418,8 +433,8 @@\n-       if ((origin < 0) || (origin >= VLENGTH)) {\n-         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n-       } else {\n-         Byte128Shuffle Iota = iotaShuffle();\n-         VectorMask<Byte> BlendMask = Iota.toVector().compare(VectorOperators.GE, (broadcast((byte)(origin))));\n-         Iota = iotaShuffle(-origin, 1, true);\n-         return ZERO.blend(this.rearrange(Iota), BlendMask);\n-       }\n+        if ((origin < 0) || (origin >= VLENGTH)) {\n+            throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+        } else {\n+            Byte128Shuffle Iota = iotaShuffle();\n+            VectorMask<Byte> BlendMask = Iota.toVector().compare(VectorOperators.GE, (broadcast((byte)(origin))));\n+            Iota = iotaShuffle(-origin, 1, true);\n+            return ZERO.blend(this.rearrange(Iota), BlendMask);\n+        }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte128Vector.java","additions":34,"deletions":19,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -384,1 +384,8 @@\n-        return (Byte256Vector) super.sliceTemplate(origin, v);  \/\/ specialize\n+        if ((origin < 0) || (origin >= VLENGTH)) {\n+            throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+        } else {\n+            Byte256Shuffle Iota = iotaShuffle();\n+            VectorMask<Byte> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((byte)(VLENGTH - origin))));\n+            Iota = iotaShuffle(origin, 1, true);\n+            return ((Byte256Vector)v).rearrange(Iota).blend(this.rearrange(Iota), BlendMask);\n+        }\n@@ -390,8 +397,8 @@\n-       if ((origin < 0) || (origin >= VLENGTH)) {\n-         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n-       } else {\n-         Byte256Shuffle Iota = iotaShuffle();\n-         VectorMask<Byte> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((byte)(VLENGTH-origin))));\n-         Iota = iotaShuffle(origin, 1, true);\n-         return ZERO.blend(this.rearrange(Iota), BlendMask);\n-       }\n+        if ((origin < 0) || (origin >= VLENGTH)) {\n+            throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+        } else {\n+            Byte256Shuffle Iota = iotaShuffle();\n+            VectorMask<Byte> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((byte)(VLENGTH - origin))));\n+            Iota = iotaShuffle(origin, 1, true);\n+            return ZERO.blend(this.rearrange(Iota), BlendMask);\n+        }\n@@ -403,1 +410,9 @@\n-        return (Byte256Vector) super.unsliceTemplate(origin, w, part);  \/\/ specialize\n+        if ((origin < 0) || (origin >= VLENGTH)) {\n+            throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+        } else {\n+            Byte256Shuffle Iota = iotaShuffle();\n+            VectorMask<Byte> BlendMask = Iota.toVector().compare((part == 0) ? VectorOperators.GE : VectorOperators.LT,\n+                                                               (broadcast((byte)(origin))));\n+            Iota = iotaShuffle(-origin, 1, true);\n+            return ((Byte256Vector)w).blend(this.rearrange(Iota), BlendMask);\n+        }\n@@ -418,8 +433,8 @@\n-       if ((origin < 0) || (origin >= VLENGTH)) {\n-         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n-       } else {\n-         Byte256Shuffle Iota = iotaShuffle();\n-         VectorMask<Byte> BlendMask = Iota.toVector().compare(VectorOperators.GE, (broadcast((byte)(origin))));\n-         Iota = iotaShuffle(-origin, 1, true);\n-         return ZERO.blend(this.rearrange(Iota), BlendMask);\n-       }\n+        if ((origin < 0) || (origin >= VLENGTH)) {\n+            throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+        } else {\n+            Byte256Shuffle Iota = iotaShuffle();\n+            VectorMask<Byte> BlendMask = Iota.toVector().compare(VectorOperators.GE, (broadcast((byte)(origin))));\n+            Iota = iotaShuffle(-origin, 1, true);\n+            return ZERO.blend(this.rearrange(Iota), BlendMask);\n+        }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte256Vector.java","additions":34,"deletions":19,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -384,1 +384,8 @@\n-        return (Byte512Vector) super.sliceTemplate(origin, v);  \/\/ specialize\n+        if ((origin < 0) || (origin >= VLENGTH)) {\n+            throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+        } else {\n+            Byte512Shuffle Iota = iotaShuffle();\n+            VectorMask<Byte> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((byte)(VLENGTH - origin))));\n+            Iota = iotaShuffle(origin, 1, true);\n+            return ((Byte512Vector)v).rearrange(Iota).blend(this.rearrange(Iota), BlendMask);\n+        }\n@@ -390,8 +397,8 @@\n-       if ((origin < 0) || (origin >= VLENGTH)) {\n-         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n-       } else {\n-         Byte512Shuffle Iota = iotaShuffle();\n-         VectorMask<Byte> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((byte)(VLENGTH-origin))));\n-         Iota = iotaShuffle(origin, 1, true);\n-         return ZERO.blend(this.rearrange(Iota), BlendMask);\n-       }\n+        if ((origin < 0) || (origin >= VLENGTH)) {\n+            throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+        } else {\n+            Byte512Shuffle Iota = iotaShuffle();\n+            VectorMask<Byte> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((byte)(VLENGTH - origin))));\n+            Iota = iotaShuffle(origin, 1, true);\n+            return ZERO.blend(this.rearrange(Iota), BlendMask);\n+        }\n@@ -403,1 +410,9 @@\n-        return (Byte512Vector) super.unsliceTemplate(origin, w, part);  \/\/ specialize\n+        if ((origin < 0) || (origin >= VLENGTH)) {\n+            throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+        } else {\n+            Byte512Shuffle Iota = iotaShuffle();\n+            VectorMask<Byte> BlendMask = Iota.toVector().compare((part == 0) ? VectorOperators.GE : VectorOperators.LT,\n+                                                               (broadcast((byte)(origin))));\n+            Iota = iotaShuffle(-origin, 1, true);\n+            return ((Byte512Vector)w).blend(this.rearrange(Iota), BlendMask);\n+        }\n@@ -418,8 +433,8 @@\n-       if ((origin < 0) || (origin >= VLENGTH)) {\n-         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n-       } else {\n-         Byte512Shuffle Iota = iotaShuffle();\n-         VectorMask<Byte> BlendMask = Iota.toVector().compare(VectorOperators.GE, (broadcast((byte)(origin))));\n-         Iota = iotaShuffle(-origin, 1, true);\n-         return ZERO.blend(this.rearrange(Iota), BlendMask);\n-       }\n+        if ((origin < 0) || (origin >= VLENGTH)) {\n+            throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+        } else {\n+            Byte512Shuffle Iota = iotaShuffle();\n+            VectorMask<Byte> BlendMask = Iota.toVector().compare(VectorOperators.GE, (broadcast((byte)(origin))));\n+            Iota = iotaShuffle(-origin, 1, true);\n+            return ZERO.blend(this.rearrange(Iota), BlendMask);\n+        }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte512Vector.java","additions":34,"deletions":19,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -384,1 +384,8 @@\n-        return (Byte64Vector) super.sliceTemplate(origin, v);  \/\/ specialize\n+        if ((origin < 0) || (origin >= VLENGTH)) {\n+            throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+        } else {\n+            Byte64Shuffle Iota = iotaShuffle();\n+            VectorMask<Byte> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((byte)(VLENGTH - origin))));\n+            Iota = iotaShuffle(origin, 1, true);\n+            return ((Byte64Vector)v).rearrange(Iota).blend(this.rearrange(Iota), BlendMask);\n+        }\n@@ -390,8 +397,8 @@\n-       if ((origin < 0) || (origin >= VLENGTH)) {\n-         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n-       } else {\n-         Byte64Shuffle Iota = iotaShuffle();\n-         VectorMask<Byte> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((byte)(VLENGTH-origin))));\n-         Iota = iotaShuffle(origin, 1, true);\n-         return ZERO.blend(this.rearrange(Iota), BlendMask);\n-       }\n+        if ((origin < 0) || (origin >= VLENGTH)) {\n+            throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+        } else {\n+            Byte64Shuffle Iota = iotaShuffle();\n+            VectorMask<Byte> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((byte)(VLENGTH - origin))));\n+            Iota = iotaShuffle(origin, 1, true);\n+            return ZERO.blend(this.rearrange(Iota), BlendMask);\n+        }\n@@ -403,1 +410,9 @@\n-        return (Byte64Vector) super.unsliceTemplate(origin, w, part);  \/\/ specialize\n+        if ((origin < 0) || (origin >= VLENGTH)) {\n+            throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+        } else {\n+            Byte64Shuffle Iota = iotaShuffle();\n+            VectorMask<Byte> BlendMask = Iota.toVector().compare((part == 0) ? VectorOperators.GE : VectorOperators.LT,\n+                                                               (broadcast((byte)(origin))));\n+            Iota = iotaShuffle(-origin, 1, true);\n+            return ((Byte64Vector)w).blend(this.rearrange(Iota), BlendMask);\n+        }\n@@ -418,8 +433,8 @@\n-       if ((origin < 0) || (origin >= VLENGTH)) {\n-         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n-       } else {\n-         Byte64Shuffle Iota = iotaShuffle();\n-         VectorMask<Byte> BlendMask = Iota.toVector().compare(VectorOperators.GE, (broadcast((byte)(origin))));\n-         Iota = iotaShuffle(-origin, 1, true);\n-         return ZERO.blend(this.rearrange(Iota), BlendMask);\n-       }\n+        if ((origin < 0) || (origin >= VLENGTH)) {\n+            throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+        } else {\n+            Byte64Shuffle Iota = iotaShuffle();\n+            VectorMask<Byte> BlendMask = Iota.toVector().compare(VectorOperators.GE, (broadcast((byte)(origin))));\n+            Iota = iotaShuffle(-origin, 1, true);\n+            return ZERO.blend(this.rearrange(Iota), BlendMask);\n+        }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte64Vector.java","additions":34,"deletions":19,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -384,1 +384,8 @@\n-        return (ByteMaxVector) super.sliceTemplate(origin, v);  \/\/ specialize\n+        if ((origin < 0) || (origin >= VLENGTH)) {\n+            throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+        } else {\n+            ByteMaxShuffle Iota = iotaShuffle();\n+            VectorMask<Byte> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((byte)(VLENGTH - origin))));\n+            Iota = iotaShuffle(origin, 1, true);\n+            return ((ByteMaxVector)v).rearrange(Iota).blend(this.rearrange(Iota), BlendMask);\n+        }\n@@ -390,8 +397,8 @@\n-       if ((origin < 0) || (origin >= VLENGTH)) {\n-         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n-       } else {\n-         ByteMaxShuffle Iota = iotaShuffle();\n-         VectorMask<Byte> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((byte)(VLENGTH-origin))));\n-         Iota = iotaShuffle(origin, 1, true);\n-         return ZERO.blend(this.rearrange(Iota), BlendMask);\n-       }\n+        if ((origin < 0) || (origin >= VLENGTH)) {\n+            throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+        } else {\n+            ByteMaxShuffle Iota = iotaShuffle();\n+            VectorMask<Byte> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((byte)(VLENGTH - origin))));\n+            Iota = iotaShuffle(origin, 1, true);\n+            return ZERO.blend(this.rearrange(Iota), BlendMask);\n+        }\n@@ -403,1 +410,9 @@\n-        return (ByteMaxVector) super.unsliceTemplate(origin, w, part);  \/\/ specialize\n+        if ((origin < 0) || (origin >= VLENGTH)) {\n+            throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+        } else {\n+            ByteMaxShuffle Iota = iotaShuffle();\n+            VectorMask<Byte> BlendMask = Iota.toVector().compare((part == 0) ? VectorOperators.GE : VectorOperators.LT,\n+                                                               (broadcast((byte)(origin))));\n+            Iota = iotaShuffle(-origin, 1, true);\n+            return ((ByteMaxVector)w).blend(this.rearrange(Iota), BlendMask);\n+        }\n@@ -418,8 +433,8 @@\n-       if ((origin < 0) || (origin >= VLENGTH)) {\n-         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n-       } else {\n-         ByteMaxShuffle Iota = iotaShuffle();\n-         VectorMask<Byte> BlendMask = Iota.toVector().compare(VectorOperators.GE, (broadcast((byte)(origin))));\n-         Iota = iotaShuffle(-origin, 1, true);\n-         return ZERO.blend(this.rearrange(Iota), BlendMask);\n-       }\n+        if ((origin < 0) || (origin >= VLENGTH)) {\n+            throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+        } else {\n+            ByteMaxShuffle Iota = iotaShuffle();\n+            VectorMask<Byte> BlendMask = Iota.toVector().compare(VectorOperators.GE, (broadcast((byte)(origin))));\n+            Iota = iotaShuffle(-origin, 1, true);\n+            return ZERO.blend(this.rearrange(Iota), BlendMask);\n+        }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteMaxVector.java","additions":34,"deletions":19,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -1978,16 +1978,0 @@\n-    \/*package-private*\/\n-    final\n-    @ForceInline\n-    ByteVector sliceTemplate(int origin, Vector<Byte> v1) {\n-        ByteVector that = (ByteVector) v1;\n-        that.check(this);\n-        byte[] a0 = this.vec();\n-        byte[] a1 = that.vec();\n-        byte[] res = new byte[a0.length];\n-        int vlen = res.length;\n-        int firstPart = vlen - origin;\n-        System.arraycopy(a0, origin, res, 0, firstPart);\n-        System.arraycopy(a1, 0, res, firstPart, origin);\n-        return vectorFactory(res);\n-    }\n-\n@@ -2020,24 +2004,0 @@\n-    \/*package-private*\/\n-    final\n-    @ForceInline\n-    ByteVector\n-    unsliceTemplate(int origin, Vector<Byte> w, int part) {\n-        ByteVector that = (ByteVector) w;\n-        that.check(this);\n-        byte[] slice = this.vec();\n-        byte[] res = that.vec().clone();\n-        int vlen = res.length;\n-        int firstPart = vlen - origin;\n-        switch (part) {\n-        case 0:\n-            System.arraycopy(slice, 0, res, origin, firstPart);\n-            break;\n-        case 1:\n-            System.arraycopy(slice, firstPart, res, 0, origin);\n-            break;\n-        default:\n-            throw wrongPartForSlice(part);\n-        }\n-        return vectorFactory(res);\n-    }\n-\n@@ -2052,1 +2012,1 @@\n-        ByteVector slice = that.sliceTemplate(origin, that);\n+        ByteVector slice = that.slice(origin, that);\n@@ -2054,1 +2014,1 @@\n-        return slice.unsliceTemplate(origin, w, part);\n+        return slice.unslice(origin, w, part);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteVector.java","additions":3,"deletions":43,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -378,1 +378,8 @@\n-        return (Double128Vector) super.sliceTemplate(origin, v);  \/\/ specialize\n+        if ((origin < 0) || (origin >= VLENGTH)) {\n+            throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+        } else {\n+            Double128Shuffle Iota = iotaShuffle();\n+            VectorMask<Double> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((double)(VLENGTH - origin))));\n+            Iota = iotaShuffle(origin, 1, true);\n+            return ((Double128Vector)v).rearrange(Iota).blend(this.rearrange(Iota), BlendMask);\n+        }\n@@ -384,8 +391,8 @@\n-       if ((origin < 0) || (origin >= VLENGTH)) {\n-         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n-       } else {\n-         Double128Shuffle Iota = iotaShuffle();\n-         VectorMask<Double> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((double)(VLENGTH-origin))));\n-         Iota = iotaShuffle(origin, 1, true);\n-         return ZERO.blend(this.rearrange(Iota), BlendMask);\n-       }\n+        if ((origin < 0) || (origin >= VLENGTH)) {\n+            throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+        } else {\n+            Double128Shuffle Iota = iotaShuffle();\n+            VectorMask<Double> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((double)(VLENGTH - origin))));\n+            Iota = iotaShuffle(origin, 1, true);\n+            return ZERO.blend(this.rearrange(Iota), BlendMask);\n+        }\n@@ -397,1 +404,9 @@\n-        return (Double128Vector) super.unsliceTemplate(origin, w, part);  \/\/ specialize\n+        if ((origin < 0) || (origin >= VLENGTH)) {\n+            throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+        } else {\n+            Double128Shuffle Iota = iotaShuffle();\n+            VectorMask<Double> BlendMask = Iota.toVector().compare((part == 0) ? VectorOperators.GE : VectorOperators.LT,\n+                                                               (broadcast((double)(origin))));\n+            Iota = iotaShuffle(-origin, 1, true);\n+            return ((Double128Vector)w).blend(this.rearrange(Iota), BlendMask);\n+        }\n@@ -412,8 +427,8 @@\n-       if ((origin < 0) || (origin >= VLENGTH)) {\n-         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n-       } else {\n-         Double128Shuffle Iota = iotaShuffle();\n-         VectorMask<Double> BlendMask = Iota.toVector().compare(VectorOperators.GE, (broadcast((double)(origin))));\n-         Iota = iotaShuffle(-origin, 1, true);\n-         return ZERO.blend(this.rearrange(Iota), BlendMask);\n-       }\n+        if ((origin < 0) || (origin >= VLENGTH)) {\n+            throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+        } else {\n+            Double128Shuffle Iota = iotaShuffle();\n+            VectorMask<Double> BlendMask = Iota.toVector().compare(VectorOperators.GE, (broadcast((double)(origin))));\n+            Iota = iotaShuffle(-origin, 1, true);\n+            return ZERO.blend(this.rearrange(Iota), BlendMask);\n+        }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double128Vector.java","additions":34,"deletions":19,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -378,1 +378,8 @@\n-        return (Double256Vector) super.sliceTemplate(origin, v);  \/\/ specialize\n+        if ((origin < 0) || (origin >= VLENGTH)) {\n+            throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+        } else {\n+            Double256Shuffle Iota = iotaShuffle();\n+            VectorMask<Double> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((double)(VLENGTH - origin))));\n+            Iota = iotaShuffle(origin, 1, true);\n+            return ((Double256Vector)v).rearrange(Iota).blend(this.rearrange(Iota), BlendMask);\n+        }\n@@ -384,8 +391,8 @@\n-       if ((origin < 0) || (origin >= VLENGTH)) {\n-         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n-       } else {\n-         Double256Shuffle Iota = iotaShuffle();\n-         VectorMask<Double> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((double)(VLENGTH-origin))));\n-         Iota = iotaShuffle(origin, 1, true);\n-         return ZERO.blend(this.rearrange(Iota), BlendMask);\n-       }\n+        if ((origin < 0) || (origin >= VLENGTH)) {\n+            throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+        } else {\n+            Double256Shuffle Iota = iotaShuffle();\n+            VectorMask<Double> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((double)(VLENGTH - origin))));\n+            Iota = iotaShuffle(origin, 1, true);\n+            return ZERO.blend(this.rearrange(Iota), BlendMask);\n+        }\n@@ -397,1 +404,9 @@\n-        return (Double256Vector) super.unsliceTemplate(origin, w, part);  \/\/ specialize\n+        if ((origin < 0) || (origin >= VLENGTH)) {\n+            throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+        } else {\n+            Double256Shuffle Iota = iotaShuffle();\n+            VectorMask<Double> BlendMask = Iota.toVector().compare((part == 0) ? VectorOperators.GE : VectorOperators.LT,\n+                                                               (broadcast((double)(origin))));\n+            Iota = iotaShuffle(-origin, 1, true);\n+            return ((Double256Vector)w).blend(this.rearrange(Iota), BlendMask);\n+        }\n@@ -412,8 +427,8 @@\n-       if ((origin < 0) || (origin >= VLENGTH)) {\n-         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n-       } else {\n-         Double256Shuffle Iota = iotaShuffle();\n-         VectorMask<Double> BlendMask = Iota.toVector().compare(VectorOperators.GE, (broadcast((double)(origin))));\n-         Iota = iotaShuffle(-origin, 1, true);\n-         return ZERO.blend(this.rearrange(Iota), BlendMask);\n-       }\n+        if ((origin < 0) || (origin >= VLENGTH)) {\n+            throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+        } else {\n+            Double256Shuffle Iota = iotaShuffle();\n+            VectorMask<Double> BlendMask = Iota.toVector().compare(VectorOperators.GE, (broadcast((double)(origin))));\n+            Iota = iotaShuffle(-origin, 1, true);\n+            return ZERO.blend(this.rearrange(Iota), BlendMask);\n+        }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double256Vector.java","additions":34,"deletions":19,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -378,1 +378,8 @@\n-        return (Double512Vector) super.sliceTemplate(origin, v);  \/\/ specialize\n+        if ((origin < 0) || (origin >= VLENGTH)) {\n+            throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+        } else {\n+            Double512Shuffle Iota = iotaShuffle();\n+            VectorMask<Double> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((double)(VLENGTH - origin))));\n+            Iota = iotaShuffle(origin, 1, true);\n+            return ((Double512Vector)v).rearrange(Iota).blend(this.rearrange(Iota), BlendMask);\n+        }\n@@ -384,8 +391,8 @@\n-       if ((origin < 0) || (origin >= VLENGTH)) {\n-         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n-       } else {\n-         Double512Shuffle Iota = iotaShuffle();\n-         VectorMask<Double> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((double)(VLENGTH-origin))));\n-         Iota = iotaShuffle(origin, 1, true);\n-         return ZERO.blend(this.rearrange(Iota), BlendMask);\n-       }\n+        if ((origin < 0) || (origin >= VLENGTH)) {\n+            throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+        } else {\n+            Double512Shuffle Iota = iotaShuffle();\n+            VectorMask<Double> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((double)(VLENGTH - origin))));\n+            Iota = iotaShuffle(origin, 1, true);\n+            return ZERO.blend(this.rearrange(Iota), BlendMask);\n+        }\n@@ -397,1 +404,9 @@\n-        return (Double512Vector) super.unsliceTemplate(origin, w, part);  \/\/ specialize\n+        if ((origin < 0) || (origin >= VLENGTH)) {\n+            throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+        } else {\n+            Double512Shuffle Iota = iotaShuffle();\n+            VectorMask<Double> BlendMask = Iota.toVector().compare((part == 0) ? VectorOperators.GE : VectorOperators.LT,\n+                                                               (broadcast((double)(origin))));\n+            Iota = iotaShuffle(-origin, 1, true);\n+            return ((Double512Vector)w).blend(this.rearrange(Iota), BlendMask);\n+        }\n@@ -412,8 +427,8 @@\n-       if ((origin < 0) || (origin >= VLENGTH)) {\n-         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n-       } else {\n-         Double512Shuffle Iota = iotaShuffle();\n-         VectorMask<Double> BlendMask = Iota.toVector().compare(VectorOperators.GE, (broadcast((double)(origin))));\n-         Iota = iotaShuffle(-origin, 1, true);\n-         return ZERO.blend(this.rearrange(Iota), BlendMask);\n-       }\n+        if ((origin < 0) || (origin >= VLENGTH)) {\n+            throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+        } else {\n+            Double512Shuffle Iota = iotaShuffle();\n+            VectorMask<Double> BlendMask = Iota.toVector().compare(VectorOperators.GE, (broadcast((double)(origin))));\n+            Iota = iotaShuffle(-origin, 1, true);\n+            return ZERO.blend(this.rearrange(Iota), BlendMask);\n+        }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double512Vector.java","additions":34,"deletions":19,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -378,1 +378,8 @@\n-        return (Double64Vector) super.sliceTemplate(origin, v);  \/\/ specialize\n+        if ((origin < 0) || (origin >= VLENGTH)) {\n+            throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+        } else {\n+            Double64Shuffle Iota = iotaShuffle();\n+            VectorMask<Double> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((double)(VLENGTH - origin))));\n+            Iota = iotaShuffle(origin, 1, true);\n+            return ((Double64Vector)v).rearrange(Iota).blend(this.rearrange(Iota), BlendMask);\n+        }\n@@ -384,8 +391,8 @@\n-       if ((origin < 0) || (origin >= VLENGTH)) {\n-         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n-       } else {\n-         Double64Shuffle Iota = iotaShuffle();\n-         VectorMask<Double> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((double)(VLENGTH-origin))));\n-         Iota = iotaShuffle(origin, 1, true);\n-         return ZERO.blend(this.rearrange(Iota), BlendMask);\n-       }\n+        if ((origin < 0) || (origin >= VLENGTH)) {\n+            throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+        } else {\n+            Double64Shuffle Iota = iotaShuffle();\n+            VectorMask<Double> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((double)(VLENGTH - origin))));\n+            Iota = iotaShuffle(origin, 1, true);\n+            return ZERO.blend(this.rearrange(Iota), BlendMask);\n+        }\n@@ -397,1 +404,9 @@\n-        return (Double64Vector) super.unsliceTemplate(origin, w, part);  \/\/ specialize\n+        if ((origin < 0) || (origin >= VLENGTH)) {\n+            throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+        } else {\n+            Double64Shuffle Iota = iotaShuffle();\n+            VectorMask<Double> BlendMask = Iota.toVector().compare((part == 0) ? VectorOperators.GE : VectorOperators.LT,\n+                                                               (broadcast((double)(origin))));\n+            Iota = iotaShuffle(-origin, 1, true);\n+            return ((Double64Vector)w).blend(this.rearrange(Iota), BlendMask);\n+        }\n@@ -412,8 +427,8 @@\n-       if ((origin < 0) || (origin >= VLENGTH)) {\n-         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n-       } else {\n-         Double64Shuffle Iota = iotaShuffle();\n-         VectorMask<Double> BlendMask = Iota.toVector().compare(VectorOperators.GE, (broadcast((double)(origin))));\n-         Iota = iotaShuffle(-origin, 1, true);\n-         return ZERO.blend(this.rearrange(Iota), BlendMask);\n-       }\n+        if ((origin < 0) || (origin >= VLENGTH)) {\n+            throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+        } else {\n+            Double64Shuffle Iota = iotaShuffle();\n+            VectorMask<Double> BlendMask = Iota.toVector().compare(VectorOperators.GE, (broadcast((double)(origin))));\n+            Iota = iotaShuffle(-origin, 1, true);\n+            return ZERO.blend(this.rearrange(Iota), BlendMask);\n+        }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double64Vector.java","additions":34,"deletions":19,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -378,1 +378,8 @@\n-        return (DoubleMaxVector) super.sliceTemplate(origin, v);  \/\/ specialize\n+        if ((origin < 0) || (origin >= VLENGTH)) {\n+            throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+        } else {\n+            DoubleMaxShuffle Iota = iotaShuffle();\n+            VectorMask<Double> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((double)(VLENGTH - origin))));\n+            Iota = iotaShuffle(origin, 1, true);\n+            return ((DoubleMaxVector)v).rearrange(Iota).blend(this.rearrange(Iota), BlendMask);\n+        }\n@@ -384,8 +391,8 @@\n-       if ((origin < 0) || (origin >= VLENGTH)) {\n-         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n-       } else {\n-         DoubleMaxShuffle Iota = iotaShuffle();\n-         VectorMask<Double> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((double)(VLENGTH-origin))));\n-         Iota = iotaShuffle(origin, 1, true);\n-         return ZERO.blend(this.rearrange(Iota), BlendMask);\n-       }\n+        if ((origin < 0) || (origin >= VLENGTH)) {\n+            throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+        } else {\n+            DoubleMaxShuffle Iota = iotaShuffle();\n+            VectorMask<Double> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((double)(VLENGTH - origin))));\n+            Iota = iotaShuffle(origin, 1, true);\n+            return ZERO.blend(this.rearrange(Iota), BlendMask);\n+        }\n@@ -397,1 +404,9 @@\n-        return (DoubleMaxVector) super.unsliceTemplate(origin, w, part);  \/\/ specialize\n+        if ((origin < 0) || (origin >= VLENGTH)) {\n+            throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+        } else {\n+            DoubleMaxShuffle Iota = iotaShuffle();\n+            VectorMask<Double> BlendMask = Iota.toVector().compare((part == 0) ? VectorOperators.GE : VectorOperators.LT,\n+                                                               (broadcast((double)(origin))));\n+            Iota = iotaShuffle(-origin, 1, true);\n+            return ((DoubleMaxVector)w).blend(this.rearrange(Iota), BlendMask);\n+        }\n@@ -412,8 +427,8 @@\n-       if ((origin < 0) || (origin >= VLENGTH)) {\n-         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n-       } else {\n-         DoubleMaxShuffle Iota = iotaShuffle();\n-         VectorMask<Double> BlendMask = Iota.toVector().compare(VectorOperators.GE, (broadcast((double)(origin))));\n-         Iota = iotaShuffle(-origin, 1, true);\n-         return ZERO.blend(this.rearrange(Iota), BlendMask);\n-       }\n+        if ((origin < 0) || (origin >= VLENGTH)) {\n+            throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+        } else {\n+            DoubleMaxShuffle Iota = iotaShuffle();\n+            VectorMask<Double> BlendMask = Iota.toVector().compare(VectorOperators.GE, (broadcast((double)(origin))));\n+            Iota = iotaShuffle(-origin, 1, true);\n+            return ZERO.blend(this.rearrange(Iota), BlendMask);\n+        }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleMaxVector.java","additions":34,"deletions":19,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -1891,16 +1891,0 @@\n-    \/*package-private*\/\n-    final\n-    @ForceInline\n-    DoubleVector sliceTemplate(int origin, Vector<Double> v1) {\n-        DoubleVector that = (DoubleVector) v1;\n-        that.check(this);\n-        double[] a0 = this.vec();\n-        double[] a1 = that.vec();\n-        double[] res = new double[a0.length];\n-        int vlen = res.length;\n-        int firstPart = vlen - origin;\n-        System.arraycopy(a0, origin, res, 0, firstPart);\n-        System.arraycopy(a1, 0, res, firstPart, origin);\n-        return vectorFactory(res);\n-    }\n-\n@@ -1933,24 +1917,0 @@\n-    \/*package-private*\/\n-    final\n-    @ForceInline\n-    DoubleVector\n-    unsliceTemplate(int origin, Vector<Double> w, int part) {\n-        DoubleVector that = (DoubleVector) w;\n-        that.check(this);\n-        double[] slice = this.vec();\n-        double[] res = that.vec().clone();\n-        int vlen = res.length;\n-        int firstPart = vlen - origin;\n-        switch (part) {\n-        case 0:\n-            System.arraycopy(slice, 0, res, origin, firstPart);\n-            break;\n-        case 1:\n-            System.arraycopy(slice, firstPart, res, 0, origin);\n-            break;\n-        default:\n-            throw wrongPartForSlice(part);\n-        }\n-        return vectorFactory(res);\n-    }\n-\n@@ -1965,1 +1925,1 @@\n-        DoubleVector slice = that.sliceTemplate(origin, that);\n+        DoubleVector slice = that.slice(origin, that);\n@@ -1967,1 +1927,1 @@\n-        return slice.unsliceTemplate(origin, w, part);\n+        return slice.unslice(origin, w, part);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleVector.java","additions":3,"deletions":43,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -378,1 +378,8 @@\n-        return (Float128Vector) super.sliceTemplate(origin, v);  \/\/ specialize\n+        if ((origin < 0) || (origin >= VLENGTH)) {\n+            throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+        } else {\n+            Float128Shuffle Iota = iotaShuffle();\n+            VectorMask<Float> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((float)(VLENGTH - origin))));\n+            Iota = iotaShuffle(origin, 1, true);\n+            return ((Float128Vector)v).rearrange(Iota).blend(this.rearrange(Iota), BlendMask);\n+        }\n@@ -384,8 +391,8 @@\n-       if ((origin < 0) || (origin >= VLENGTH)) {\n-         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n-       } else {\n-         Float128Shuffle Iota = iotaShuffle();\n-         VectorMask<Float> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((float)(VLENGTH-origin))));\n-         Iota = iotaShuffle(origin, 1, true);\n-         return ZERO.blend(this.rearrange(Iota), BlendMask);\n-       }\n+        if ((origin < 0) || (origin >= VLENGTH)) {\n+            throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+        } else {\n+            Float128Shuffle Iota = iotaShuffle();\n+            VectorMask<Float> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((float)(VLENGTH - origin))));\n+            Iota = iotaShuffle(origin, 1, true);\n+            return ZERO.blend(this.rearrange(Iota), BlendMask);\n+        }\n@@ -397,1 +404,9 @@\n-        return (Float128Vector) super.unsliceTemplate(origin, w, part);  \/\/ specialize\n+        if ((origin < 0) || (origin >= VLENGTH)) {\n+            throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+        } else {\n+            Float128Shuffle Iota = iotaShuffle();\n+            VectorMask<Float> BlendMask = Iota.toVector().compare((part == 0) ? VectorOperators.GE : VectorOperators.LT,\n+                                                               (broadcast((float)(origin))));\n+            Iota = iotaShuffle(-origin, 1, true);\n+            return ((Float128Vector)w).blend(this.rearrange(Iota), BlendMask);\n+        }\n@@ -412,8 +427,8 @@\n-       if ((origin < 0) || (origin >= VLENGTH)) {\n-         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n-       } else {\n-         Float128Shuffle Iota = iotaShuffle();\n-         VectorMask<Float> BlendMask = Iota.toVector().compare(VectorOperators.GE, (broadcast((float)(origin))));\n-         Iota = iotaShuffle(-origin, 1, true);\n-         return ZERO.blend(this.rearrange(Iota), BlendMask);\n-       }\n+        if ((origin < 0) || (origin >= VLENGTH)) {\n+            throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+        } else {\n+            Float128Shuffle Iota = iotaShuffle();\n+            VectorMask<Float> BlendMask = Iota.toVector().compare(VectorOperators.GE, (broadcast((float)(origin))));\n+            Iota = iotaShuffle(-origin, 1, true);\n+            return ZERO.blend(this.rearrange(Iota), BlendMask);\n+        }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float128Vector.java","additions":34,"deletions":19,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -378,1 +378,8 @@\n-        return (Float256Vector) super.sliceTemplate(origin, v);  \/\/ specialize\n+        if ((origin < 0) || (origin >= VLENGTH)) {\n+            throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+        } else {\n+            Float256Shuffle Iota = iotaShuffle();\n+            VectorMask<Float> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((float)(VLENGTH - origin))));\n+            Iota = iotaShuffle(origin, 1, true);\n+            return ((Float256Vector)v).rearrange(Iota).blend(this.rearrange(Iota), BlendMask);\n+        }\n@@ -384,8 +391,8 @@\n-       if ((origin < 0) || (origin >= VLENGTH)) {\n-         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n-       } else {\n-         Float256Shuffle Iota = iotaShuffle();\n-         VectorMask<Float> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((float)(VLENGTH-origin))));\n-         Iota = iotaShuffle(origin, 1, true);\n-         return ZERO.blend(this.rearrange(Iota), BlendMask);\n-       }\n+        if ((origin < 0) || (origin >= VLENGTH)) {\n+            throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+        } else {\n+            Float256Shuffle Iota = iotaShuffle();\n+            VectorMask<Float> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((float)(VLENGTH - origin))));\n+            Iota = iotaShuffle(origin, 1, true);\n+            return ZERO.blend(this.rearrange(Iota), BlendMask);\n+        }\n@@ -397,1 +404,9 @@\n-        return (Float256Vector) super.unsliceTemplate(origin, w, part);  \/\/ specialize\n+        if ((origin < 0) || (origin >= VLENGTH)) {\n+            throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+        } else {\n+            Float256Shuffle Iota = iotaShuffle();\n+            VectorMask<Float> BlendMask = Iota.toVector().compare((part == 0) ? VectorOperators.GE : VectorOperators.LT,\n+                                                               (broadcast((float)(origin))));\n+            Iota = iotaShuffle(-origin, 1, true);\n+            return ((Float256Vector)w).blend(this.rearrange(Iota), BlendMask);\n+        }\n@@ -412,8 +427,8 @@\n-       if ((origin < 0) || (origin >= VLENGTH)) {\n-         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n-       } else {\n-         Float256Shuffle Iota = iotaShuffle();\n-         VectorMask<Float> BlendMask = Iota.toVector().compare(VectorOperators.GE, (broadcast((float)(origin))));\n-         Iota = iotaShuffle(-origin, 1, true);\n-         return ZERO.blend(this.rearrange(Iota), BlendMask);\n-       }\n+        if ((origin < 0) || (origin >= VLENGTH)) {\n+            throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+        } else {\n+            Float256Shuffle Iota = iotaShuffle();\n+            VectorMask<Float> BlendMask = Iota.toVector().compare(VectorOperators.GE, (broadcast((float)(origin))));\n+            Iota = iotaShuffle(-origin, 1, true);\n+            return ZERO.blend(this.rearrange(Iota), BlendMask);\n+        }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float256Vector.java","additions":34,"deletions":19,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -378,1 +378,8 @@\n-        return (Float512Vector) super.sliceTemplate(origin, v);  \/\/ specialize\n+        if ((origin < 0) || (origin >= VLENGTH)) {\n+            throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+        } else {\n+            Float512Shuffle Iota = iotaShuffle();\n+            VectorMask<Float> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((float)(VLENGTH - origin))));\n+            Iota = iotaShuffle(origin, 1, true);\n+            return ((Float512Vector)v).rearrange(Iota).blend(this.rearrange(Iota), BlendMask);\n+        }\n@@ -384,8 +391,8 @@\n-       if ((origin < 0) || (origin >= VLENGTH)) {\n-         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n-       } else {\n-         Float512Shuffle Iota = iotaShuffle();\n-         VectorMask<Float> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((float)(VLENGTH-origin))));\n-         Iota = iotaShuffle(origin, 1, true);\n-         return ZERO.blend(this.rearrange(Iota), BlendMask);\n-       }\n+        if ((origin < 0) || (origin >= VLENGTH)) {\n+            throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+        } else {\n+            Float512Shuffle Iota = iotaShuffle();\n+            VectorMask<Float> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((float)(VLENGTH - origin))));\n+            Iota = iotaShuffle(origin, 1, true);\n+            return ZERO.blend(this.rearrange(Iota), BlendMask);\n+        }\n@@ -397,1 +404,9 @@\n-        return (Float512Vector) super.unsliceTemplate(origin, w, part);  \/\/ specialize\n+        if ((origin < 0) || (origin >= VLENGTH)) {\n+            throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+        } else {\n+            Float512Shuffle Iota = iotaShuffle();\n+            VectorMask<Float> BlendMask = Iota.toVector().compare((part == 0) ? VectorOperators.GE : VectorOperators.LT,\n+                                                               (broadcast((float)(origin))));\n+            Iota = iotaShuffle(-origin, 1, true);\n+            return ((Float512Vector)w).blend(this.rearrange(Iota), BlendMask);\n+        }\n@@ -412,8 +427,8 @@\n-       if ((origin < 0) || (origin >= VLENGTH)) {\n-         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n-       } else {\n-         Float512Shuffle Iota = iotaShuffle();\n-         VectorMask<Float> BlendMask = Iota.toVector().compare(VectorOperators.GE, (broadcast((float)(origin))));\n-         Iota = iotaShuffle(-origin, 1, true);\n-         return ZERO.blend(this.rearrange(Iota), BlendMask);\n-       }\n+        if ((origin < 0) || (origin >= VLENGTH)) {\n+            throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+        } else {\n+            Float512Shuffle Iota = iotaShuffle();\n+            VectorMask<Float> BlendMask = Iota.toVector().compare(VectorOperators.GE, (broadcast((float)(origin))));\n+            Iota = iotaShuffle(-origin, 1, true);\n+            return ZERO.blend(this.rearrange(Iota), BlendMask);\n+        }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float512Vector.java","additions":34,"deletions":19,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -378,1 +378,8 @@\n-        return (Float64Vector) super.sliceTemplate(origin, v);  \/\/ specialize\n+        if ((origin < 0) || (origin >= VLENGTH)) {\n+            throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+        } else {\n+            Float64Shuffle Iota = iotaShuffle();\n+            VectorMask<Float> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((float)(VLENGTH - origin))));\n+            Iota = iotaShuffle(origin, 1, true);\n+            return ((Float64Vector)v).rearrange(Iota).blend(this.rearrange(Iota), BlendMask);\n+        }\n@@ -384,8 +391,8 @@\n-       if ((origin < 0) || (origin >= VLENGTH)) {\n-         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n-       } else {\n-         Float64Shuffle Iota = iotaShuffle();\n-         VectorMask<Float> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((float)(VLENGTH-origin))));\n-         Iota = iotaShuffle(origin, 1, true);\n-         return ZERO.blend(this.rearrange(Iota), BlendMask);\n-       }\n+        if ((origin < 0) || (origin >= VLENGTH)) {\n+            throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+        } else {\n+            Float64Shuffle Iota = iotaShuffle();\n+            VectorMask<Float> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((float)(VLENGTH - origin))));\n+            Iota = iotaShuffle(origin, 1, true);\n+            return ZERO.blend(this.rearrange(Iota), BlendMask);\n+        }\n@@ -397,1 +404,9 @@\n-        return (Float64Vector) super.unsliceTemplate(origin, w, part);  \/\/ specialize\n+        if ((origin < 0) || (origin >= VLENGTH)) {\n+            throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+        } else {\n+            Float64Shuffle Iota = iotaShuffle();\n+            VectorMask<Float> BlendMask = Iota.toVector().compare((part == 0) ? VectorOperators.GE : VectorOperators.LT,\n+                                                               (broadcast((float)(origin))));\n+            Iota = iotaShuffle(-origin, 1, true);\n+            return ((Float64Vector)w).blend(this.rearrange(Iota), BlendMask);\n+        }\n@@ -412,8 +427,8 @@\n-       if ((origin < 0) || (origin >= VLENGTH)) {\n-         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n-       } else {\n-         Float64Shuffle Iota = iotaShuffle();\n-         VectorMask<Float> BlendMask = Iota.toVector().compare(VectorOperators.GE, (broadcast((float)(origin))));\n-         Iota = iotaShuffle(-origin, 1, true);\n-         return ZERO.blend(this.rearrange(Iota), BlendMask);\n-       }\n+        if ((origin < 0) || (origin >= VLENGTH)) {\n+            throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+        } else {\n+            Float64Shuffle Iota = iotaShuffle();\n+            VectorMask<Float> BlendMask = Iota.toVector().compare(VectorOperators.GE, (broadcast((float)(origin))));\n+            Iota = iotaShuffle(-origin, 1, true);\n+            return ZERO.blend(this.rearrange(Iota), BlendMask);\n+        }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float64Vector.java","additions":34,"deletions":19,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -378,1 +378,8 @@\n-        return (FloatMaxVector) super.sliceTemplate(origin, v);  \/\/ specialize\n+        if ((origin < 0) || (origin >= VLENGTH)) {\n+            throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+        } else {\n+            FloatMaxShuffle Iota = iotaShuffle();\n+            VectorMask<Float> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((float)(VLENGTH - origin))));\n+            Iota = iotaShuffle(origin, 1, true);\n+            return ((FloatMaxVector)v).rearrange(Iota).blend(this.rearrange(Iota), BlendMask);\n+        }\n@@ -384,8 +391,8 @@\n-       if ((origin < 0) || (origin >= VLENGTH)) {\n-         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n-       } else {\n-         FloatMaxShuffle Iota = iotaShuffle();\n-         VectorMask<Float> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((float)(VLENGTH-origin))));\n-         Iota = iotaShuffle(origin, 1, true);\n-         return ZERO.blend(this.rearrange(Iota), BlendMask);\n-       }\n+        if ((origin < 0) || (origin >= VLENGTH)) {\n+            throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+        } else {\n+            FloatMaxShuffle Iota = iotaShuffle();\n+            VectorMask<Float> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((float)(VLENGTH - origin))));\n+            Iota = iotaShuffle(origin, 1, true);\n+            return ZERO.blend(this.rearrange(Iota), BlendMask);\n+        }\n@@ -397,1 +404,9 @@\n-        return (FloatMaxVector) super.unsliceTemplate(origin, w, part);  \/\/ specialize\n+        if ((origin < 0) || (origin >= VLENGTH)) {\n+            throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+        } else {\n+            FloatMaxShuffle Iota = iotaShuffle();\n+            VectorMask<Float> BlendMask = Iota.toVector().compare((part == 0) ? VectorOperators.GE : VectorOperators.LT,\n+                                                               (broadcast((float)(origin))));\n+            Iota = iotaShuffle(-origin, 1, true);\n+            return ((FloatMaxVector)w).blend(this.rearrange(Iota), BlendMask);\n+        }\n@@ -412,8 +427,8 @@\n-       if ((origin < 0) || (origin >= VLENGTH)) {\n-         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n-       } else {\n-         FloatMaxShuffle Iota = iotaShuffle();\n-         VectorMask<Float> BlendMask = Iota.toVector().compare(VectorOperators.GE, (broadcast((float)(origin))));\n-         Iota = iotaShuffle(-origin, 1, true);\n-         return ZERO.blend(this.rearrange(Iota), BlendMask);\n-       }\n+        if ((origin < 0) || (origin >= VLENGTH)) {\n+            throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+        } else {\n+            FloatMaxShuffle Iota = iotaShuffle();\n+            VectorMask<Float> BlendMask = Iota.toVector().compare(VectorOperators.GE, (broadcast((float)(origin))));\n+            Iota = iotaShuffle(-origin, 1, true);\n+            return ZERO.blend(this.rearrange(Iota), BlendMask);\n+        }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatMaxVector.java","additions":34,"deletions":19,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -1903,16 +1903,0 @@\n-    \/*package-private*\/\n-    final\n-    @ForceInline\n-    FloatVector sliceTemplate(int origin, Vector<Float> v1) {\n-        FloatVector that = (FloatVector) v1;\n-        that.check(this);\n-        float[] a0 = this.vec();\n-        float[] a1 = that.vec();\n-        float[] res = new float[a0.length];\n-        int vlen = res.length;\n-        int firstPart = vlen - origin;\n-        System.arraycopy(a0, origin, res, 0, firstPart);\n-        System.arraycopy(a1, 0, res, firstPart, origin);\n-        return vectorFactory(res);\n-    }\n-\n@@ -1945,24 +1929,0 @@\n-    \/*package-private*\/\n-    final\n-    @ForceInline\n-    FloatVector\n-    unsliceTemplate(int origin, Vector<Float> w, int part) {\n-        FloatVector that = (FloatVector) w;\n-        that.check(this);\n-        float[] slice = this.vec();\n-        float[] res = that.vec().clone();\n-        int vlen = res.length;\n-        int firstPart = vlen - origin;\n-        switch (part) {\n-        case 0:\n-            System.arraycopy(slice, 0, res, origin, firstPart);\n-            break;\n-        case 1:\n-            System.arraycopy(slice, firstPart, res, 0, origin);\n-            break;\n-        default:\n-            throw wrongPartForSlice(part);\n-        }\n-        return vectorFactory(res);\n-    }\n-\n@@ -1977,1 +1937,1 @@\n-        FloatVector slice = that.sliceTemplate(origin, that);\n+        FloatVector slice = that.slice(origin, that);\n@@ -1979,1 +1939,1 @@\n-        return slice.unsliceTemplate(origin, w, part);\n+        return slice.unslice(origin, w, part);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatVector.java","additions":3,"deletions":43,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -384,1 +384,8 @@\n-        return (Int128Vector) super.sliceTemplate(origin, v);  \/\/ specialize\n+        if ((origin < 0) || (origin >= VLENGTH)) {\n+            throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+        } else {\n+            Int128Shuffle Iota = iotaShuffle();\n+            VectorMask<Integer> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((int)(VLENGTH - origin))));\n+            Iota = iotaShuffle(origin, 1, true);\n+            return ((Int128Vector)v).rearrange(Iota).blend(this.rearrange(Iota), BlendMask);\n+        }\n@@ -390,8 +397,8 @@\n-       if ((origin < 0) || (origin >= VLENGTH)) {\n-         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n-       } else {\n-         Int128Shuffle Iota = iotaShuffle();\n-         VectorMask<Integer> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((int)(VLENGTH-origin))));\n-         Iota = iotaShuffle(origin, 1, true);\n-         return ZERO.blend(this.rearrange(Iota), BlendMask);\n-       }\n+        if ((origin < 0) || (origin >= VLENGTH)) {\n+            throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+        } else {\n+            Int128Shuffle Iota = iotaShuffle();\n+            VectorMask<Integer> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((int)(VLENGTH - origin))));\n+            Iota = iotaShuffle(origin, 1, true);\n+            return ZERO.blend(this.rearrange(Iota), BlendMask);\n+        }\n@@ -403,1 +410,9 @@\n-        return (Int128Vector) super.unsliceTemplate(origin, w, part);  \/\/ specialize\n+        if ((origin < 0) || (origin >= VLENGTH)) {\n+            throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+        } else {\n+            Int128Shuffle Iota = iotaShuffle();\n+            VectorMask<Integer> BlendMask = Iota.toVector().compare((part == 0) ? VectorOperators.GE : VectorOperators.LT,\n+                                                               (broadcast((int)(origin))));\n+            Iota = iotaShuffle(-origin, 1, true);\n+            return ((Int128Vector)w).blend(this.rearrange(Iota), BlendMask);\n+        }\n@@ -418,8 +433,8 @@\n-       if ((origin < 0) || (origin >= VLENGTH)) {\n-         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n-       } else {\n-         Int128Shuffle Iota = iotaShuffle();\n-         VectorMask<Integer> BlendMask = Iota.toVector().compare(VectorOperators.GE, (broadcast((int)(origin))));\n-         Iota = iotaShuffle(-origin, 1, true);\n-         return ZERO.blend(this.rearrange(Iota), BlendMask);\n-       }\n+        if ((origin < 0) || (origin >= VLENGTH)) {\n+            throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+        } else {\n+            Int128Shuffle Iota = iotaShuffle();\n+            VectorMask<Integer> BlendMask = Iota.toVector().compare(VectorOperators.GE, (broadcast((int)(origin))));\n+            Iota = iotaShuffle(-origin, 1, true);\n+            return ZERO.blend(this.rearrange(Iota), BlendMask);\n+        }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int128Vector.java","additions":34,"deletions":19,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -384,1 +384,8 @@\n-        return (Int256Vector) super.sliceTemplate(origin, v);  \/\/ specialize\n+        if ((origin < 0) || (origin >= VLENGTH)) {\n+            throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+        } else {\n+            Int256Shuffle Iota = iotaShuffle();\n+            VectorMask<Integer> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((int)(VLENGTH - origin))));\n+            Iota = iotaShuffle(origin, 1, true);\n+            return ((Int256Vector)v).rearrange(Iota).blend(this.rearrange(Iota), BlendMask);\n+        }\n@@ -390,8 +397,8 @@\n-       if ((origin < 0) || (origin >= VLENGTH)) {\n-         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n-       } else {\n-         Int256Shuffle Iota = iotaShuffle();\n-         VectorMask<Integer> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((int)(VLENGTH-origin))));\n-         Iota = iotaShuffle(origin, 1, true);\n-         return ZERO.blend(this.rearrange(Iota), BlendMask);\n-       }\n+        if ((origin < 0) || (origin >= VLENGTH)) {\n+            throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+        } else {\n+            Int256Shuffle Iota = iotaShuffle();\n+            VectorMask<Integer> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((int)(VLENGTH - origin))));\n+            Iota = iotaShuffle(origin, 1, true);\n+            return ZERO.blend(this.rearrange(Iota), BlendMask);\n+        }\n@@ -403,1 +410,9 @@\n-        return (Int256Vector) super.unsliceTemplate(origin, w, part);  \/\/ specialize\n+        if ((origin < 0) || (origin >= VLENGTH)) {\n+            throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+        } else {\n+            Int256Shuffle Iota = iotaShuffle();\n+            VectorMask<Integer> BlendMask = Iota.toVector().compare((part == 0) ? VectorOperators.GE : VectorOperators.LT,\n+                                                               (broadcast((int)(origin))));\n+            Iota = iotaShuffle(-origin, 1, true);\n+            return ((Int256Vector)w).blend(this.rearrange(Iota), BlendMask);\n+        }\n@@ -418,8 +433,8 @@\n-       if ((origin < 0) || (origin >= VLENGTH)) {\n-         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n-       } else {\n-         Int256Shuffle Iota = iotaShuffle();\n-         VectorMask<Integer> BlendMask = Iota.toVector().compare(VectorOperators.GE, (broadcast((int)(origin))));\n-         Iota = iotaShuffle(-origin, 1, true);\n-         return ZERO.blend(this.rearrange(Iota), BlendMask);\n-       }\n+        if ((origin < 0) || (origin >= VLENGTH)) {\n+            throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+        } else {\n+            Int256Shuffle Iota = iotaShuffle();\n+            VectorMask<Integer> BlendMask = Iota.toVector().compare(VectorOperators.GE, (broadcast((int)(origin))));\n+            Iota = iotaShuffle(-origin, 1, true);\n+            return ZERO.blend(this.rearrange(Iota), BlendMask);\n+        }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int256Vector.java","additions":34,"deletions":19,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -384,1 +384,8 @@\n-        return (Int512Vector) super.sliceTemplate(origin, v);  \/\/ specialize\n+        if ((origin < 0) || (origin >= VLENGTH)) {\n+            throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+        } else {\n+            Int512Shuffle Iota = iotaShuffle();\n+            VectorMask<Integer> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((int)(VLENGTH - origin))));\n+            Iota = iotaShuffle(origin, 1, true);\n+            return ((Int512Vector)v).rearrange(Iota).blend(this.rearrange(Iota), BlendMask);\n+        }\n@@ -390,8 +397,8 @@\n-       if ((origin < 0) || (origin >= VLENGTH)) {\n-         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n-       } else {\n-         Int512Shuffle Iota = iotaShuffle();\n-         VectorMask<Integer> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((int)(VLENGTH-origin))));\n-         Iota = iotaShuffle(origin, 1, true);\n-         return ZERO.blend(this.rearrange(Iota), BlendMask);\n-       }\n+        if ((origin < 0) || (origin >= VLENGTH)) {\n+            throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+        } else {\n+            Int512Shuffle Iota = iotaShuffle();\n+            VectorMask<Integer> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((int)(VLENGTH - origin))));\n+            Iota = iotaShuffle(origin, 1, true);\n+            return ZERO.blend(this.rearrange(Iota), BlendMask);\n+        }\n@@ -403,1 +410,9 @@\n-        return (Int512Vector) super.unsliceTemplate(origin, w, part);  \/\/ specialize\n+        if ((origin < 0) || (origin >= VLENGTH)) {\n+            throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+        } else {\n+            Int512Shuffle Iota = iotaShuffle();\n+            VectorMask<Integer> BlendMask = Iota.toVector().compare((part == 0) ? VectorOperators.GE : VectorOperators.LT,\n+                                                               (broadcast((int)(origin))));\n+            Iota = iotaShuffle(-origin, 1, true);\n+            return ((Int512Vector)w).blend(this.rearrange(Iota), BlendMask);\n+        }\n@@ -418,8 +433,8 @@\n-       if ((origin < 0) || (origin >= VLENGTH)) {\n-         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n-       } else {\n-         Int512Shuffle Iota = iotaShuffle();\n-         VectorMask<Integer> BlendMask = Iota.toVector().compare(VectorOperators.GE, (broadcast((int)(origin))));\n-         Iota = iotaShuffle(-origin, 1, true);\n-         return ZERO.blend(this.rearrange(Iota), BlendMask);\n-       }\n+        if ((origin < 0) || (origin >= VLENGTH)) {\n+            throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+        } else {\n+            Int512Shuffle Iota = iotaShuffle();\n+            VectorMask<Integer> BlendMask = Iota.toVector().compare(VectorOperators.GE, (broadcast((int)(origin))));\n+            Iota = iotaShuffle(-origin, 1, true);\n+            return ZERO.blend(this.rearrange(Iota), BlendMask);\n+        }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int512Vector.java","additions":34,"deletions":19,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -384,1 +384,8 @@\n-        return (Int64Vector) super.sliceTemplate(origin, v);  \/\/ specialize\n+        if ((origin < 0) || (origin >= VLENGTH)) {\n+            throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+        } else {\n+            Int64Shuffle Iota = iotaShuffle();\n+            VectorMask<Integer> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((int)(VLENGTH - origin))));\n+            Iota = iotaShuffle(origin, 1, true);\n+            return ((Int64Vector)v).rearrange(Iota).blend(this.rearrange(Iota), BlendMask);\n+        }\n@@ -390,8 +397,8 @@\n-       if ((origin < 0) || (origin >= VLENGTH)) {\n-         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n-       } else {\n-         Int64Shuffle Iota = iotaShuffle();\n-         VectorMask<Integer> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((int)(VLENGTH-origin))));\n-         Iota = iotaShuffle(origin, 1, true);\n-         return ZERO.blend(this.rearrange(Iota), BlendMask);\n-       }\n+        if ((origin < 0) || (origin >= VLENGTH)) {\n+            throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+        } else {\n+            Int64Shuffle Iota = iotaShuffle();\n+            VectorMask<Integer> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((int)(VLENGTH - origin))));\n+            Iota = iotaShuffle(origin, 1, true);\n+            return ZERO.blend(this.rearrange(Iota), BlendMask);\n+        }\n@@ -403,1 +410,9 @@\n-        return (Int64Vector) super.unsliceTemplate(origin, w, part);  \/\/ specialize\n+        if ((origin < 0) || (origin >= VLENGTH)) {\n+            throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+        } else {\n+            Int64Shuffle Iota = iotaShuffle();\n+            VectorMask<Integer> BlendMask = Iota.toVector().compare((part == 0) ? VectorOperators.GE : VectorOperators.LT,\n+                                                               (broadcast((int)(origin))));\n+            Iota = iotaShuffle(-origin, 1, true);\n+            return ((Int64Vector)w).blend(this.rearrange(Iota), BlendMask);\n+        }\n@@ -418,8 +433,8 @@\n-       if ((origin < 0) || (origin >= VLENGTH)) {\n-         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n-       } else {\n-         Int64Shuffle Iota = iotaShuffle();\n-         VectorMask<Integer> BlendMask = Iota.toVector().compare(VectorOperators.GE, (broadcast((int)(origin))));\n-         Iota = iotaShuffle(-origin, 1, true);\n-         return ZERO.blend(this.rearrange(Iota), BlendMask);\n-       }\n+        if ((origin < 0) || (origin >= VLENGTH)) {\n+            throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+        } else {\n+            Int64Shuffle Iota = iotaShuffle();\n+            VectorMask<Integer> BlendMask = Iota.toVector().compare(VectorOperators.GE, (broadcast((int)(origin))));\n+            Iota = iotaShuffle(-origin, 1, true);\n+            return ZERO.blend(this.rearrange(Iota), BlendMask);\n+        }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int64Vector.java","additions":34,"deletions":19,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -384,1 +384,8 @@\n-        return (IntMaxVector) super.sliceTemplate(origin, v);  \/\/ specialize\n+        if ((origin < 0) || (origin >= VLENGTH)) {\n+            throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+        } else {\n+            IntMaxShuffle Iota = iotaShuffle();\n+            VectorMask<Integer> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((int)(VLENGTH - origin))));\n+            Iota = iotaShuffle(origin, 1, true);\n+            return ((IntMaxVector)v).rearrange(Iota).blend(this.rearrange(Iota), BlendMask);\n+        }\n@@ -390,8 +397,8 @@\n-       if ((origin < 0) || (origin >= VLENGTH)) {\n-         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n-       } else {\n-         IntMaxShuffle Iota = iotaShuffle();\n-         VectorMask<Integer> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((int)(VLENGTH-origin))));\n-         Iota = iotaShuffle(origin, 1, true);\n-         return ZERO.blend(this.rearrange(Iota), BlendMask);\n-       }\n+        if ((origin < 0) || (origin >= VLENGTH)) {\n+            throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+        } else {\n+            IntMaxShuffle Iota = iotaShuffle();\n+            VectorMask<Integer> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((int)(VLENGTH - origin))));\n+            Iota = iotaShuffle(origin, 1, true);\n+            return ZERO.blend(this.rearrange(Iota), BlendMask);\n+        }\n@@ -403,1 +410,9 @@\n-        return (IntMaxVector) super.unsliceTemplate(origin, w, part);  \/\/ specialize\n+        if ((origin < 0) || (origin >= VLENGTH)) {\n+            throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+        } else {\n+            IntMaxShuffle Iota = iotaShuffle();\n+            VectorMask<Integer> BlendMask = Iota.toVector().compare((part == 0) ? VectorOperators.GE : VectorOperators.LT,\n+                                                               (broadcast((int)(origin))));\n+            Iota = iotaShuffle(-origin, 1, true);\n+            return ((IntMaxVector)w).blend(this.rearrange(Iota), BlendMask);\n+        }\n@@ -418,8 +433,8 @@\n-       if ((origin < 0) || (origin >= VLENGTH)) {\n-         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n-       } else {\n-         IntMaxShuffle Iota = iotaShuffle();\n-         VectorMask<Integer> BlendMask = Iota.toVector().compare(VectorOperators.GE, (broadcast((int)(origin))));\n-         Iota = iotaShuffle(-origin, 1, true);\n-         return ZERO.blend(this.rearrange(Iota), BlendMask);\n-       }\n+        if ((origin < 0) || (origin >= VLENGTH)) {\n+            throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+        } else {\n+            IntMaxShuffle Iota = iotaShuffle();\n+            VectorMask<Integer> BlendMask = Iota.toVector().compare(VectorOperators.GE, (broadcast((int)(origin))));\n+            Iota = iotaShuffle(-origin, 1, true);\n+            return ZERO.blend(this.rearrange(Iota), BlendMask);\n+        }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntMaxVector.java","additions":34,"deletions":19,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -1977,16 +1977,0 @@\n-    \/*package-private*\/\n-    final\n-    @ForceInline\n-    IntVector sliceTemplate(int origin, Vector<Integer> v1) {\n-        IntVector that = (IntVector) v1;\n-        that.check(this);\n-        int[] a0 = this.vec();\n-        int[] a1 = that.vec();\n-        int[] res = new int[a0.length];\n-        int vlen = res.length;\n-        int firstPart = vlen - origin;\n-        System.arraycopy(a0, origin, res, 0, firstPart);\n-        System.arraycopy(a1, 0, res, firstPart, origin);\n-        return vectorFactory(res);\n-    }\n-\n@@ -2019,24 +2003,0 @@\n-    \/*package-private*\/\n-    final\n-    @ForceInline\n-    IntVector\n-    unsliceTemplate(int origin, Vector<Integer> w, int part) {\n-        IntVector that = (IntVector) w;\n-        that.check(this);\n-        int[] slice = this.vec();\n-        int[] res = that.vec().clone();\n-        int vlen = res.length;\n-        int firstPart = vlen - origin;\n-        switch (part) {\n-        case 0:\n-            System.arraycopy(slice, 0, res, origin, firstPart);\n-            break;\n-        case 1:\n-            System.arraycopy(slice, firstPart, res, 0, origin);\n-            break;\n-        default:\n-            throw wrongPartForSlice(part);\n-        }\n-        return vectorFactory(res);\n-    }\n-\n@@ -2051,1 +2011,1 @@\n-        IntVector slice = that.sliceTemplate(origin, that);\n+        IntVector slice = that.slice(origin, that);\n@@ -2053,1 +2013,1 @@\n-        return slice.unsliceTemplate(origin, w, part);\n+        return slice.unslice(origin, w, part);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntVector.java","additions":3,"deletions":43,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -374,1 +374,8 @@\n-        return (Long128Vector) super.sliceTemplate(origin, v);  \/\/ specialize\n+        if ((origin < 0) || (origin >= VLENGTH)) {\n+            throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+        } else {\n+            Long128Shuffle Iota = iotaShuffle();\n+            VectorMask<Long> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((long)(VLENGTH - origin))));\n+            Iota = iotaShuffle(origin, 1, true);\n+            return ((Long128Vector)v).rearrange(Iota).blend(this.rearrange(Iota), BlendMask);\n+        }\n@@ -380,8 +387,8 @@\n-       if ((origin < 0) || (origin >= VLENGTH)) {\n-         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n-       } else {\n-         Long128Shuffle Iota = iotaShuffle();\n-         VectorMask<Long> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((long)(VLENGTH-origin))));\n-         Iota = iotaShuffle(origin, 1, true);\n-         return ZERO.blend(this.rearrange(Iota), BlendMask);\n-       }\n+        if ((origin < 0) || (origin >= VLENGTH)) {\n+            throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+        } else {\n+            Long128Shuffle Iota = iotaShuffle();\n+            VectorMask<Long> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((long)(VLENGTH - origin))));\n+            Iota = iotaShuffle(origin, 1, true);\n+            return ZERO.blend(this.rearrange(Iota), BlendMask);\n+        }\n@@ -393,1 +400,9 @@\n-        return (Long128Vector) super.unsliceTemplate(origin, w, part);  \/\/ specialize\n+        if ((origin < 0) || (origin >= VLENGTH)) {\n+            throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+        } else {\n+            Long128Shuffle Iota = iotaShuffle();\n+            VectorMask<Long> BlendMask = Iota.toVector().compare((part == 0) ? VectorOperators.GE : VectorOperators.LT,\n+                                                               (broadcast((long)(origin))));\n+            Iota = iotaShuffle(-origin, 1, true);\n+            return ((Long128Vector)w).blend(this.rearrange(Iota), BlendMask);\n+        }\n@@ -408,8 +423,8 @@\n-       if ((origin < 0) || (origin >= VLENGTH)) {\n-         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n-       } else {\n-         Long128Shuffle Iota = iotaShuffle();\n-         VectorMask<Long> BlendMask = Iota.toVector().compare(VectorOperators.GE, (broadcast((long)(origin))));\n-         Iota = iotaShuffle(-origin, 1, true);\n-         return ZERO.blend(this.rearrange(Iota), BlendMask);\n-       }\n+        if ((origin < 0) || (origin >= VLENGTH)) {\n+            throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+        } else {\n+            Long128Shuffle Iota = iotaShuffle();\n+            VectorMask<Long> BlendMask = Iota.toVector().compare(VectorOperators.GE, (broadcast((long)(origin))));\n+            Iota = iotaShuffle(-origin, 1, true);\n+            return ZERO.blend(this.rearrange(Iota), BlendMask);\n+        }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long128Vector.java","additions":34,"deletions":19,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -374,1 +374,8 @@\n-        return (Long256Vector) super.sliceTemplate(origin, v);  \/\/ specialize\n+        if ((origin < 0) || (origin >= VLENGTH)) {\n+            throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+        } else {\n+            Long256Shuffle Iota = iotaShuffle();\n+            VectorMask<Long> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((long)(VLENGTH - origin))));\n+            Iota = iotaShuffle(origin, 1, true);\n+            return ((Long256Vector)v).rearrange(Iota).blend(this.rearrange(Iota), BlendMask);\n+        }\n@@ -380,8 +387,8 @@\n-       if ((origin < 0) || (origin >= VLENGTH)) {\n-         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n-       } else {\n-         Long256Shuffle Iota = iotaShuffle();\n-         VectorMask<Long> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((long)(VLENGTH-origin))));\n-         Iota = iotaShuffle(origin, 1, true);\n-         return ZERO.blend(this.rearrange(Iota), BlendMask);\n-       }\n+        if ((origin < 0) || (origin >= VLENGTH)) {\n+            throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+        } else {\n+            Long256Shuffle Iota = iotaShuffle();\n+            VectorMask<Long> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((long)(VLENGTH - origin))));\n+            Iota = iotaShuffle(origin, 1, true);\n+            return ZERO.blend(this.rearrange(Iota), BlendMask);\n+        }\n@@ -393,1 +400,9 @@\n-        return (Long256Vector) super.unsliceTemplate(origin, w, part);  \/\/ specialize\n+        if ((origin < 0) || (origin >= VLENGTH)) {\n+            throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+        } else {\n+            Long256Shuffle Iota = iotaShuffle();\n+            VectorMask<Long> BlendMask = Iota.toVector().compare((part == 0) ? VectorOperators.GE : VectorOperators.LT,\n+                                                               (broadcast((long)(origin))));\n+            Iota = iotaShuffle(-origin, 1, true);\n+            return ((Long256Vector)w).blend(this.rearrange(Iota), BlendMask);\n+        }\n@@ -408,8 +423,8 @@\n-       if ((origin < 0) || (origin >= VLENGTH)) {\n-         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n-       } else {\n-         Long256Shuffle Iota = iotaShuffle();\n-         VectorMask<Long> BlendMask = Iota.toVector().compare(VectorOperators.GE, (broadcast((long)(origin))));\n-         Iota = iotaShuffle(-origin, 1, true);\n-         return ZERO.blend(this.rearrange(Iota), BlendMask);\n-       }\n+        if ((origin < 0) || (origin >= VLENGTH)) {\n+            throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+        } else {\n+            Long256Shuffle Iota = iotaShuffle();\n+            VectorMask<Long> BlendMask = Iota.toVector().compare(VectorOperators.GE, (broadcast((long)(origin))));\n+            Iota = iotaShuffle(-origin, 1, true);\n+            return ZERO.blend(this.rearrange(Iota), BlendMask);\n+        }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long256Vector.java","additions":34,"deletions":19,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -374,1 +374,8 @@\n-        return (Long512Vector) super.sliceTemplate(origin, v);  \/\/ specialize\n+        if ((origin < 0) || (origin >= VLENGTH)) {\n+            throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+        } else {\n+            Long512Shuffle Iota = iotaShuffle();\n+            VectorMask<Long> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((long)(VLENGTH - origin))));\n+            Iota = iotaShuffle(origin, 1, true);\n+            return ((Long512Vector)v).rearrange(Iota).blend(this.rearrange(Iota), BlendMask);\n+        }\n@@ -380,8 +387,8 @@\n-       if ((origin < 0) || (origin >= VLENGTH)) {\n-         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n-       } else {\n-         Long512Shuffle Iota = iotaShuffle();\n-         VectorMask<Long> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((long)(VLENGTH-origin))));\n-         Iota = iotaShuffle(origin, 1, true);\n-         return ZERO.blend(this.rearrange(Iota), BlendMask);\n-       }\n+        if ((origin < 0) || (origin >= VLENGTH)) {\n+            throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+        } else {\n+            Long512Shuffle Iota = iotaShuffle();\n+            VectorMask<Long> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((long)(VLENGTH - origin))));\n+            Iota = iotaShuffle(origin, 1, true);\n+            return ZERO.blend(this.rearrange(Iota), BlendMask);\n+        }\n@@ -393,1 +400,9 @@\n-        return (Long512Vector) super.unsliceTemplate(origin, w, part);  \/\/ specialize\n+        if ((origin < 0) || (origin >= VLENGTH)) {\n+            throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+        } else {\n+            Long512Shuffle Iota = iotaShuffle();\n+            VectorMask<Long> BlendMask = Iota.toVector().compare((part == 0) ? VectorOperators.GE : VectorOperators.LT,\n+                                                               (broadcast((long)(origin))));\n+            Iota = iotaShuffle(-origin, 1, true);\n+            return ((Long512Vector)w).blend(this.rearrange(Iota), BlendMask);\n+        }\n@@ -408,8 +423,8 @@\n-       if ((origin < 0) || (origin >= VLENGTH)) {\n-         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n-       } else {\n-         Long512Shuffle Iota = iotaShuffle();\n-         VectorMask<Long> BlendMask = Iota.toVector().compare(VectorOperators.GE, (broadcast((long)(origin))));\n-         Iota = iotaShuffle(-origin, 1, true);\n-         return ZERO.blend(this.rearrange(Iota), BlendMask);\n-       }\n+        if ((origin < 0) || (origin >= VLENGTH)) {\n+            throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+        } else {\n+            Long512Shuffle Iota = iotaShuffle();\n+            VectorMask<Long> BlendMask = Iota.toVector().compare(VectorOperators.GE, (broadcast((long)(origin))));\n+            Iota = iotaShuffle(-origin, 1, true);\n+            return ZERO.blend(this.rearrange(Iota), BlendMask);\n+        }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long512Vector.java","additions":34,"deletions":19,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -374,1 +374,8 @@\n-        return (Long64Vector) super.sliceTemplate(origin, v);  \/\/ specialize\n+        if ((origin < 0) || (origin >= VLENGTH)) {\n+            throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+        } else {\n+            Long64Shuffle Iota = iotaShuffle();\n+            VectorMask<Long> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((long)(VLENGTH - origin))));\n+            Iota = iotaShuffle(origin, 1, true);\n+            return ((Long64Vector)v).rearrange(Iota).blend(this.rearrange(Iota), BlendMask);\n+        }\n@@ -380,8 +387,8 @@\n-       if ((origin < 0) || (origin >= VLENGTH)) {\n-         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n-       } else {\n-         Long64Shuffle Iota = iotaShuffle();\n-         VectorMask<Long> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((long)(VLENGTH-origin))));\n-         Iota = iotaShuffle(origin, 1, true);\n-         return ZERO.blend(this.rearrange(Iota), BlendMask);\n-       }\n+        if ((origin < 0) || (origin >= VLENGTH)) {\n+            throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+        } else {\n+            Long64Shuffle Iota = iotaShuffle();\n+            VectorMask<Long> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((long)(VLENGTH - origin))));\n+            Iota = iotaShuffle(origin, 1, true);\n+            return ZERO.blend(this.rearrange(Iota), BlendMask);\n+        }\n@@ -393,1 +400,9 @@\n-        return (Long64Vector) super.unsliceTemplate(origin, w, part);  \/\/ specialize\n+        if ((origin < 0) || (origin >= VLENGTH)) {\n+            throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+        } else {\n+            Long64Shuffle Iota = iotaShuffle();\n+            VectorMask<Long> BlendMask = Iota.toVector().compare((part == 0) ? VectorOperators.GE : VectorOperators.LT,\n+                                                               (broadcast((long)(origin))));\n+            Iota = iotaShuffle(-origin, 1, true);\n+            return ((Long64Vector)w).blend(this.rearrange(Iota), BlendMask);\n+        }\n@@ -408,8 +423,8 @@\n-       if ((origin < 0) || (origin >= VLENGTH)) {\n-         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n-       } else {\n-         Long64Shuffle Iota = iotaShuffle();\n-         VectorMask<Long> BlendMask = Iota.toVector().compare(VectorOperators.GE, (broadcast((long)(origin))));\n-         Iota = iotaShuffle(-origin, 1, true);\n-         return ZERO.blend(this.rearrange(Iota), BlendMask);\n-       }\n+        if ((origin < 0) || (origin >= VLENGTH)) {\n+            throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+        } else {\n+            Long64Shuffle Iota = iotaShuffle();\n+            VectorMask<Long> BlendMask = Iota.toVector().compare(VectorOperators.GE, (broadcast((long)(origin))));\n+            Iota = iotaShuffle(-origin, 1, true);\n+            return ZERO.blend(this.rearrange(Iota), BlendMask);\n+        }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long64Vector.java","additions":34,"deletions":19,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -374,1 +374,8 @@\n-        return (LongMaxVector) super.sliceTemplate(origin, v);  \/\/ specialize\n+        if ((origin < 0) || (origin >= VLENGTH)) {\n+            throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+        } else {\n+            LongMaxShuffle Iota = iotaShuffle();\n+            VectorMask<Long> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((long)(VLENGTH - origin))));\n+            Iota = iotaShuffle(origin, 1, true);\n+            return ((LongMaxVector)v).rearrange(Iota).blend(this.rearrange(Iota), BlendMask);\n+        }\n@@ -380,8 +387,8 @@\n-       if ((origin < 0) || (origin >= VLENGTH)) {\n-         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n-       } else {\n-         LongMaxShuffle Iota = iotaShuffle();\n-         VectorMask<Long> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((long)(VLENGTH-origin))));\n-         Iota = iotaShuffle(origin, 1, true);\n-         return ZERO.blend(this.rearrange(Iota), BlendMask);\n-       }\n+        if ((origin < 0) || (origin >= VLENGTH)) {\n+            throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+        } else {\n+            LongMaxShuffle Iota = iotaShuffle();\n+            VectorMask<Long> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((long)(VLENGTH - origin))));\n+            Iota = iotaShuffle(origin, 1, true);\n+            return ZERO.blend(this.rearrange(Iota), BlendMask);\n+        }\n@@ -393,1 +400,9 @@\n-        return (LongMaxVector) super.unsliceTemplate(origin, w, part);  \/\/ specialize\n+        if ((origin < 0) || (origin >= VLENGTH)) {\n+            throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+        } else {\n+            LongMaxShuffle Iota = iotaShuffle();\n+            VectorMask<Long> BlendMask = Iota.toVector().compare((part == 0) ? VectorOperators.GE : VectorOperators.LT,\n+                                                               (broadcast((long)(origin))));\n+            Iota = iotaShuffle(-origin, 1, true);\n+            return ((LongMaxVector)w).blend(this.rearrange(Iota), BlendMask);\n+        }\n@@ -408,8 +423,8 @@\n-       if ((origin < 0) || (origin >= VLENGTH)) {\n-         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n-       } else {\n-         LongMaxShuffle Iota = iotaShuffle();\n-         VectorMask<Long> BlendMask = Iota.toVector().compare(VectorOperators.GE, (broadcast((long)(origin))));\n-         Iota = iotaShuffle(-origin, 1, true);\n-         return ZERO.blend(this.rearrange(Iota), BlendMask);\n-       }\n+        if ((origin < 0) || (origin >= VLENGTH)) {\n+            throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+        } else {\n+            LongMaxShuffle Iota = iotaShuffle();\n+            VectorMask<Long> BlendMask = Iota.toVector().compare(VectorOperators.GE, (broadcast((long)(origin))));\n+            Iota = iotaShuffle(-origin, 1, true);\n+            return ZERO.blend(this.rearrange(Iota), BlendMask);\n+        }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongMaxVector.java","additions":34,"deletions":19,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -1848,16 +1848,0 @@\n-    \/*package-private*\/\n-    final\n-    @ForceInline\n-    LongVector sliceTemplate(int origin, Vector<Long> v1) {\n-        LongVector that = (LongVector) v1;\n-        that.check(this);\n-        long[] a0 = this.vec();\n-        long[] a1 = that.vec();\n-        long[] res = new long[a0.length];\n-        int vlen = res.length;\n-        int firstPart = vlen - origin;\n-        System.arraycopy(a0, origin, res, 0, firstPart);\n-        System.arraycopy(a1, 0, res, firstPart, origin);\n-        return vectorFactory(res);\n-    }\n-\n@@ -1890,24 +1874,0 @@\n-    \/*package-private*\/\n-    final\n-    @ForceInline\n-    LongVector\n-    unsliceTemplate(int origin, Vector<Long> w, int part) {\n-        LongVector that = (LongVector) w;\n-        that.check(this);\n-        long[] slice = this.vec();\n-        long[] res = that.vec().clone();\n-        int vlen = res.length;\n-        int firstPart = vlen - origin;\n-        switch (part) {\n-        case 0:\n-            System.arraycopy(slice, 0, res, origin, firstPart);\n-            break;\n-        case 1:\n-            System.arraycopy(slice, firstPart, res, 0, origin);\n-            break;\n-        default:\n-            throw wrongPartForSlice(part);\n-        }\n-        return vectorFactory(res);\n-    }\n-\n@@ -1922,1 +1882,1 @@\n-        LongVector slice = that.sliceTemplate(origin, that);\n+        LongVector slice = that.slice(origin, that);\n@@ -1924,1 +1884,1 @@\n-        return slice.unsliceTemplate(origin, w, part);\n+        return slice.unslice(origin, w, part);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongVector.java","additions":3,"deletions":43,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -384,1 +384,8 @@\n-        return (Short128Vector) super.sliceTemplate(origin, v);  \/\/ specialize\n+        if ((origin < 0) || (origin >= VLENGTH)) {\n+            throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+        } else {\n+            Short128Shuffle Iota = iotaShuffle();\n+            VectorMask<Short> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((short)(VLENGTH - origin))));\n+            Iota = iotaShuffle(origin, 1, true);\n+            return ((Short128Vector)v).rearrange(Iota).blend(this.rearrange(Iota), BlendMask);\n+        }\n@@ -390,8 +397,8 @@\n-       if ((origin < 0) || (origin >= VLENGTH)) {\n-         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n-       } else {\n-         Short128Shuffle Iota = iotaShuffle();\n-         VectorMask<Short> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((short)(VLENGTH-origin))));\n-         Iota = iotaShuffle(origin, 1, true);\n-         return ZERO.blend(this.rearrange(Iota), BlendMask);\n-       }\n+        if ((origin < 0) || (origin >= VLENGTH)) {\n+            throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+        } else {\n+            Short128Shuffle Iota = iotaShuffle();\n+            VectorMask<Short> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((short)(VLENGTH - origin))));\n+            Iota = iotaShuffle(origin, 1, true);\n+            return ZERO.blend(this.rearrange(Iota), BlendMask);\n+        }\n@@ -403,1 +410,9 @@\n-        return (Short128Vector) super.unsliceTemplate(origin, w, part);  \/\/ specialize\n+        if ((origin < 0) || (origin >= VLENGTH)) {\n+            throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+        } else {\n+            Short128Shuffle Iota = iotaShuffle();\n+            VectorMask<Short> BlendMask = Iota.toVector().compare((part == 0) ? VectorOperators.GE : VectorOperators.LT,\n+                                                               (broadcast((short)(origin))));\n+            Iota = iotaShuffle(-origin, 1, true);\n+            return ((Short128Vector)w).blend(this.rearrange(Iota), BlendMask);\n+        }\n@@ -418,8 +433,8 @@\n-       if ((origin < 0) || (origin >= VLENGTH)) {\n-         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n-       } else {\n-         Short128Shuffle Iota = iotaShuffle();\n-         VectorMask<Short> BlendMask = Iota.toVector().compare(VectorOperators.GE, (broadcast((short)(origin))));\n-         Iota = iotaShuffle(-origin, 1, true);\n-         return ZERO.blend(this.rearrange(Iota), BlendMask);\n-       }\n+        if ((origin < 0) || (origin >= VLENGTH)) {\n+            throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+        } else {\n+            Short128Shuffle Iota = iotaShuffle();\n+            VectorMask<Short> BlendMask = Iota.toVector().compare(VectorOperators.GE, (broadcast((short)(origin))));\n+            Iota = iotaShuffle(-origin, 1, true);\n+            return ZERO.blend(this.rearrange(Iota), BlendMask);\n+        }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short128Vector.java","additions":34,"deletions":19,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -384,1 +384,8 @@\n-        return (Short256Vector) super.sliceTemplate(origin, v);  \/\/ specialize\n+        if ((origin < 0) || (origin >= VLENGTH)) {\n+            throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+        } else {\n+            Short256Shuffle Iota = iotaShuffle();\n+            VectorMask<Short> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((short)(VLENGTH - origin))));\n+            Iota = iotaShuffle(origin, 1, true);\n+            return ((Short256Vector)v).rearrange(Iota).blend(this.rearrange(Iota), BlendMask);\n+        }\n@@ -390,8 +397,8 @@\n-       if ((origin < 0) || (origin >= VLENGTH)) {\n-         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n-       } else {\n-         Short256Shuffle Iota = iotaShuffle();\n-         VectorMask<Short> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((short)(VLENGTH-origin))));\n-         Iota = iotaShuffle(origin, 1, true);\n-         return ZERO.blend(this.rearrange(Iota), BlendMask);\n-       }\n+        if ((origin < 0) || (origin >= VLENGTH)) {\n+            throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+        } else {\n+            Short256Shuffle Iota = iotaShuffle();\n+            VectorMask<Short> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((short)(VLENGTH - origin))));\n+            Iota = iotaShuffle(origin, 1, true);\n+            return ZERO.blend(this.rearrange(Iota), BlendMask);\n+        }\n@@ -403,1 +410,9 @@\n-        return (Short256Vector) super.unsliceTemplate(origin, w, part);  \/\/ specialize\n+        if ((origin < 0) || (origin >= VLENGTH)) {\n+            throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+        } else {\n+            Short256Shuffle Iota = iotaShuffle();\n+            VectorMask<Short> BlendMask = Iota.toVector().compare((part == 0) ? VectorOperators.GE : VectorOperators.LT,\n+                                                               (broadcast((short)(origin))));\n+            Iota = iotaShuffle(-origin, 1, true);\n+            return ((Short256Vector)w).blend(this.rearrange(Iota), BlendMask);\n+        }\n@@ -418,8 +433,8 @@\n-       if ((origin < 0) || (origin >= VLENGTH)) {\n-         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n-       } else {\n-         Short256Shuffle Iota = iotaShuffle();\n-         VectorMask<Short> BlendMask = Iota.toVector().compare(VectorOperators.GE, (broadcast((short)(origin))));\n-         Iota = iotaShuffle(-origin, 1, true);\n-         return ZERO.blend(this.rearrange(Iota), BlendMask);\n-       }\n+        if ((origin < 0) || (origin >= VLENGTH)) {\n+            throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+        } else {\n+            Short256Shuffle Iota = iotaShuffle();\n+            VectorMask<Short> BlendMask = Iota.toVector().compare(VectorOperators.GE, (broadcast((short)(origin))));\n+            Iota = iotaShuffle(-origin, 1, true);\n+            return ZERO.blend(this.rearrange(Iota), BlendMask);\n+        }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short256Vector.java","additions":34,"deletions":19,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -384,1 +384,8 @@\n-        return (Short512Vector) super.sliceTemplate(origin, v);  \/\/ specialize\n+        if ((origin < 0) || (origin >= VLENGTH)) {\n+            throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+        } else {\n+            Short512Shuffle Iota = iotaShuffle();\n+            VectorMask<Short> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((short)(VLENGTH - origin))));\n+            Iota = iotaShuffle(origin, 1, true);\n+            return ((Short512Vector)v).rearrange(Iota).blend(this.rearrange(Iota), BlendMask);\n+        }\n@@ -390,8 +397,8 @@\n-       if ((origin < 0) || (origin >= VLENGTH)) {\n-         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n-       } else {\n-         Short512Shuffle Iota = iotaShuffle();\n-         VectorMask<Short> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((short)(VLENGTH-origin))));\n-         Iota = iotaShuffle(origin, 1, true);\n-         return ZERO.blend(this.rearrange(Iota), BlendMask);\n-       }\n+        if ((origin < 0) || (origin >= VLENGTH)) {\n+            throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+        } else {\n+            Short512Shuffle Iota = iotaShuffle();\n+            VectorMask<Short> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((short)(VLENGTH - origin))));\n+            Iota = iotaShuffle(origin, 1, true);\n+            return ZERO.blend(this.rearrange(Iota), BlendMask);\n+        }\n@@ -403,1 +410,9 @@\n-        return (Short512Vector) super.unsliceTemplate(origin, w, part);  \/\/ specialize\n+        if ((origin < 0) || (origin >= VLENGTH)) {\n+            throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+        } else {\n+            Short512Shuffle Iota = iotaShuffle();\n+            VectorMask<Short> BlendMask = Iota.toVector().compare((part == 0) ? VectorOperators.GE : VectorOperators.LT,\n+                                                               (broadcast((short)(origin))));\n+            Iota = iotaShuffle(-origin, 1, true);\n+            return ((Short512Vector)w).blend(this.rearrange(Iota), BlendMask);\n+        }\n@@ -418,8 +433,8 @@\n-       if ((origin < 0) || (origin >= VLENGTH)) {\n-         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n-       } else {\n-         Short512Shuffle Iota = iotaShuffle();\n-         VectorMask<Short> BlendMask = Iota.toVector().compare(VectorOperators.GE, (broadcast((short)(origin))));\n-         Iota = iotaShuffle(-origin, 1, true);\n-         return ZERO.blend(this.rearrange(Iota), BlendMask);\n-       }\n+        if ((origin < 0) || (origin >= VLENGTH)) {\n+            throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+        } else {\n+            Short512Shuffle Iota = iotaShuffle();\n+            VectorMask<Short> BlendMask = Iota.toVector().compare(VectorOperators.GE, (broadcast((short)(origin))));\n+            Iota = iotaShuffle(-origin, 1, true);\n+            return ZERO.blend(this.rearrange(Iota), BlendMask);\n+        }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short512Vector.java","additions":34,"deletions":19,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -384,1 +384,8 @@\n-        return (Short64Vector) super.sliceTemplate(origin, v);  \/\/ specialize\n+        if ((origin < 0) || (origin >= VLENGTH)) {\n+            throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+        } else {\n+            Short64Shuffle Iota = iotaShuffle();\n+            VectorMask<Short> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((short)(VLENGTH - origin))));\n+            Iota = iotaShuffle(origin, 1, true);\n+            return ((Short64Vector)v).rearrange(Iota).blend(this.rearrange(Iota), BlendMask);\n+        }\n@@ -390,8 +397,8 @@\n-       if ((origin < 0) || (origin >= VLENGTH)) {\n-         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n-       } else {\n-         Short64Shuffle Iota = iotaShuffle();\n-         VectorMask<Short> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((short)(VLENGTH-origin))));\n-         Iota = iotaShuffle(origin, 1, true);\n-         return ZERO.blend(this.rearrange(Iota), BlendMask);\n-       }\n+        if ((origin < 0) || (origin >= VLENGTH)) {\n+            throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+        } else {\n+            Short64Shuffle Iota = iotaShuffle();\n+            VectorMask<Short> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((short)(VLENGTH - origin))));\n+            Iota = iotaShuffle(origin, 1, true);\n+            return ZERO.blend(this.rearrange(Iota), BlendMask);\n+        }\n@@ -403,1 +410,9 @@\n-        return (Short64Vector) super.unsliceTemplate(origin, w, part);  \/\/ specialize\n+        if ((origin < 0) || (origin >= VLENGTH)) {\n+            throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+        } else {\n+            Short64Shuffle Iota = iotaShuffle();\n+            VectorMask<Short> BlendMask = Iota.toVector().compare((part == 0) ? VectorOperators.GE : VectorOperators.LT,\n+                                                               (broadcast((short)(origin))));\n+            Iota = iotaShuffle(-origin, 1, true);\n+            return ((Short64Vector)w).blend(this.rearrange(Iota), BlendMask);\n+        }\n@@ -418,8 +433,8 @@\n-       if ((origin < 0) || (origin >= VLENGTH)) {\n-         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n-       } else {\n-         Short64Shuffle Iota = iotaShuffle();\n-         VectorMask<Short> BlendMask = Iota.toVector().compare(VectorOperators.GE, (broadcast((short)(origin))));\n-         Iota = iotaShuffle(-origin, 1, true);\n-         return ZERO.blend(this.rearrange(Iota), BlendMask);\n-       }\n+        if ((origin < 0) || (origin >= VLENGTH)) {\n+            throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+        } else {\n+            Short64Shuffle Iota = iotaShuffle();\n+            VectorMask<Short> BlendMask = Iota.toVector().compare(VectorOperators.GE, (broadcast((short)(origin))));\n+            Iota = iotaShuffle(-origin, 1, true);\n+            return ZERO.blend(this.rearrange(Iota), BlendMask);\n+        }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short64Vector.java","additions":34,"deletions":19,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -384,1 +384,8 @@\n-        return (ShortMaxVector) super.sliceTemplate(origin, v);  \/\/ specialize\n+        if ((origin < 0) || (origin >= VLENGTH)) {\n+            throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+        } else {\n+            ShortMaxShuffle Iota = iotaShuffle();\n+            VectorMask<Short> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((short)(VLENGTH - origin))));\n+            Iota = iotaShuffle(origin, 1, true);\n+            return ((ShortMaxVector)v).rearrange(Iota).blend(this.rearrange(Iota), BlendMask);\n+        }\n@@ -390,8 +397,8 @@\n-       if ((origin < 0) || (origin >= VLENGTH)) {\n-         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n-       } else {\n-         ShortMaxShuffle Iota = iotaShuffle();\n-         VectorMask<Short> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((short)(VLENGTH-origin))));\n-         Iota = iotaShuffle(origin, 1, true);\n-         return ZERO.blend(this.rearrange(Iota), BlendMask);\n-       }\n+        if ((origin < 0) || (origin >= VLENGTH)) {\n+            throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+        } else {\n+            ShortMaxShuffle Iota = iotaShuffle();\n+            VectorMask<Short> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((short)(VLENGTH - origin))));\n+            Iota = iotaShuffle(origin, 1, true);\n+            return ZERO.blend(this.rearrange(Iota), BlendMask);\n+        }\n@@ -403,1 +410,9 @@\n-        return (ShortMaxVector) super.unsliceTemplate(origin, w, part);  \/\/ specialize\n+        if ((origin < 0) || (origin >= VLENGTH)) {\n+            throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+        } else {\n+            ShortMaxShuffle Iota = iotaShuffle();\n+            VectorMask<Short> BlendMask = Iota.toVector().compare((part == 0) ? VectorOperators.GE : VectorOperators.LT,\n+                                                               (broadcast((short)(origin))));\n+            Iota = iotaShuffle(-origin, 1, true);\n+            return ((ShortMaxVector)w).blend(this.rearrange(Iota), BlendMask);\n+        }\n@@ -418,8 +433,8 @@\n-       if ((origin < 0) || (origin >= VLENGTH)) {\n-         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n-       } else {\n-         ShortMaxShuffle Iota = iotaShuffle();\n-         VectorMask<Short> BlendMask = Iota.toVector().compare(VectorOperators.GE, (broadcast((short)(origin))));\n-         Iota = iotaShuffle(-origin, 1, true);\n-         return ZERO.blend(this.rearrange(Iota), BlendMask);\n-       }\n+        if ((origin < 0) || (origin >= VLENGTH)) {\n+            throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+        } else {\n+            ShortMaxShuffle Iota = iotaShuffle();\n+            VectorMask<Short> BlendMask = Iota.toVector().compare(VectorOperators.GE, (broadcast((short)(origin))));\n+            Iota = iotaShuffle(-origin, 1, true);\n+            return ZERO.blend(this.rearrange(Iota), BlendMask);\n+        }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortMaxVector.java","additions":34,"deletions":19,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -1978,16 +1978,0 @@\n-    \/*package-private*\/\n-    final\n-    @ForceInline\n-    ShortVector sliceTemplate(int origin, Vector<Short> v1) {\n-        ShortVector that = (ShortVector) v1;\n-        that.check(this);\n-        short[] a0 = this.vec();\n-        short[] a1 = that.vec();\n-        short[] res = new short[a0.length];\n-        int vlen = res.length;\n-        int firstPart = vlen - origin;\n-        System.arraycopy(a0, origin, res, 0, firstPart);\n-        System.arraycopy(a1, 0, res, firstPart, origin);\n-        return vectorFactory(res);\n-    }\n-\n@@ -2020,24 +2004,0 @@\n-    \/*package-private*\/\n-    final\n-    @ForceInline\n-    ShortVector\n-    unsliceTemplate(int origin, Vector<Short> w, int part) {\n-        ShortVector that = (ShortVector) w;\n-        that.check(this);\n-        short[] slice = this.vec();\n-        short[] res = that.vec().clone();\n-        int vlen = res.length;\n-        int firstPart = vlen - origin;\n-        switch (part) {\n-        case 0:\n-            System.arraycopy(slice, 0, res, origin, firstPart);\n-            break;\n-        case 1:\n-            System.arraycopy(slice, firstPart, res, 0, origin);\n-            break;\n-        default:\n-            throw wrongPartForSlice(part);\n-        }\n-        return vectorFactory(res);\n-    }\n-\n@@ -2052,1 +2012,1 @@\n-        ShortVector slice = that.sliceTemplate(origin, that);\n+        ShortVector slice = that.slice(origin, that);\n@@ -2054,1 +2014,1 @@\n-        return slice.unsliceTemplate(origin, w, part);\n+        return slice.unslice(origin, w, part);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortVector.java","additions":3,"deletions":43,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -2247,16 +2247,0 @@\n-    \/*package-private*\/\n-    final\n-    @ForceInline\n-    $abstractvectortype$ sliceTemplate(int origin, Vector<$Boxtype$> v1) {\n-        $abstractvectortype$ that = ($abstractvectortype$) v1;\n-        that.check(this);\n-        $type$[] a0 = this.vec();\n-        $type$[] a1 = that.vec();\n-        $type$[] res = new $type$[a0.length];\n-        int vlen = res.length;\n-        int firstPart = vlen - origin;\n-        System.arraycopy(a0, origin, res, 0, firstPart);\n-        System.arraycopy(a1, 0, res, firstPart, origin);\n-        return vectorFactory(res);\n-    }\n-\n@@ -2289,24 +2273,0 @@\n-    \/*package-private*\/\n-    final\n-    @ForceInline\n-    $abstractvectortype$\n-    unsliceTemplate(int origin, Vector<$Boxtype$> w, int part) {\n-        $abstractvectortype$ that = ($abstractvectortype$) w;\n-        that.check(this);\n-        $type$[] slice = this.vec();\n-        $type$[] res = that.vec().clone();\n-        int vlen = res.length;\n-        int firstPart = vlen - origin;\n-        switch (part) {\n-        case 0:\n-            System.arraycopy(slice, 0, res, origin, firstPart);\n-            break;\n-        case 1:\n-            System.arraycopy(slice, firstPart, res, 0, origin);\n-            break;\n-        default:\n-            throw wrongPartForSlice(part);\n-        }\n-        return vectorFactory(res);\n-    }\n-\n@@ -2321,1 +2281,1 @@\n-        $abstractvectortype$ slice = that.sliceTemplate(origin, that);\n+        $abstractvectortype$ slice = that.slice(origin, that);\n@@ -2323,1 +2283,1 @@\n-        return slice.unsliceTemplate(origin, w, part);\n+        return slice.unslice(origin, w, part);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-Vector.java.template","additions":3,"deletions":43,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -390,1 +390,8 @@\n-        return ($vectortype$) super.sliceTemplate(origin, v);  \/\/ specialize\n+        if ((origin < 0) || (origin >= VLENGTH)) {\n+            throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+        } else {\n+            $shuffletype$ Iota = iotaShuffle();\n+            VectorMask<$Boxtype$> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast(($type$)(VLENGTH - origin))));\n+            Iota = iotaShuffle(origin, 1, true);\n+            return (($vectortype$)v).rearrange(Iota).blend(this.rearrange(Iota), BlendMask);\n+        }\n@@ -396,8 +403,8 @@\n-       if ((origin < 0) || (origin >= VLENGTH)) {\n-         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n-       } else {\n-         $shuffletype$ Iota = iotaShuffle();\n-         VectorMask<$Boxtype$> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast(($type$)(VLENGTH-origin))));\n-         Iota = iotaShuffle(origin, 1, true);\n-         return ZERO.blend(this.rearrange(Iota), BlendMask);\n-       }\n+        if ((origin < 0) || (origin >= VLENGTH)) {\n+            throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+        } else {\n+            $shuffletype$ Iota = iotaShuffle();\n+            VectorMask<$Boxtype$> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast(($type$)(VLENGTH - origin))));\n+            Iota = iotaShuffle(origin, 1, true);\n+            return ZERO.blend(this.rearrange(Iota), BlendMask);\n+        }\n@@ -409,1 +416,9 @@\n-        return ($vectortype$) super.unsliceTemplate(origin, w, part);  \/\/ specialize\n+        if ((origin < 0) || (origin >= VLENGTH)) {\n+            throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+        } else {\n+            $shuffletype$ Iota = iotaShuffle();\n+            VectorMask<$Boxtype$> BlendMask = Iota.toVector().compare((part == 0) ? VectorOperators.GE : VectorOperators.LT,\n+                                                               (broadcast(($type$)(origin))));\n+            Iota = iotaShuffle(-origin, 1, true);\n+            return (($vectortype$)w).blend(this.rearrange(Iota), BlendMask);\n+        }\n@@ -424,8 +439,8 @@\n-       if ((origin < 0) || (origin >= VLENGTH)) {\n-         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n-       } else {\n-         $shuffletype$ Iota = iotaShuffle();\n-         VectorMask<$Boxtype$> BlendMask = Iota.toVector().compare(VectorOperators.GE, (broadcast(($type$)(origin))));\n-         Iota = iotaShuffle(-origin, 1, true);\n-         return ZERO.blend(this.rearrange(Iota), BlendMask);\n-       }\n+        if ((origin < 0) || (origin >= VLENGTH)) {\n+            throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+        } else {\n+            $shuffletype$ Iota = iotaShuffle();\n+            VectorMask<$Boxtype$> BlendMask = Iota.toVector().compare(VectorOperators.GE, (broadcast(($type$)(origin))));\n+            Iota = iotaShuffle(-origin, 1, true);\n+            return ZERO.blend(this.rearrange(Iota), BlendMask);\n+        }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-VectorBits.java.template","additions":34,"deletions":19,"binary":false,"changes":53,"status":"modified"}]}