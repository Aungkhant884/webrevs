{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+import jdk.internal.misc.Blocker;\n@@ -33,0 +34,1 @@\n+import static sun.nio.fs.UnixNativeDispatcher.copyToNativeBuffer;\n@@ -117,0 +119,14 @@\n+    boolean supportsCloning() throws IOException {\n+        try (NativeBuffer fileBuffer = copyToNativeBuffer(file())) {\n+            long comp = Blocker.begin();\n+            try {\n+                return supportsCloning0(fileBuffer.address());\n+            } finally {\n+                Blocker.end(comp);\n+            }\n+        }\n+\n+    }\n+\n+    private static native boolean supportsCloning0(long fileAddress);\n+\n","filename":"src\/java.base\/macosx\/classes\/sun\/nio\/fs\/BsdFileStore.java","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import sun.nio.ch.IOStatus;\n@@ -38,0 +39,3 @@\n+import static sun.nio.fs.UnixConstants.*;\n+import static sun.nio.fs.UnixNativeDispatcher.chown;\n+\n@@ -44,0 +48,4 @@\n+    \/\/ whether file cloning is supported on this platform\n+    private static volatile boolean cloneFileNotSupported;\n+\n+\n@@ -74,0 +82,41 @@\n+    \/**\n+     * Clones the file whose path name is {@code src} to that whose path\n+     * name is {@code dst} using the {@code clonefile} system call.\n+     *\n+     * @param src the path of the source file\n+     * @param dst the path of the destination file (clone)\n+     * @param followLinks whether to follow links\n+     *\n+     * @return 0 on success, IOStatus.UNSUPPORTED_CASE if the call does not work\n+     *         with the given parameters, or IOStatus.UNSUPPORTED if cloning is\n+     *         not supported on this platform\n+     *\/\n+    private int clone(UnixPath src, UnixPath dst, boolean followLinks)\n+        throws IOException\n+    {\n+        \/\/ Do not clone unless both files are on the same volume and that\n+        \/\/ volume is indicated as supporting file cloning\n+        BsdFileStore bfs = (BsdFileStore)provider().getFileStore(src);\n+        if (!bfs.equals(provider().getFileStore(dst.getParent())) ||\n+            !bfs.supportsCloning())\n+            return IOStatus.UNSUPPORTED_CASE;\n+\n+        int flags = followLinks ? 0 : CLONE_NOFOLLOW;\n+        try {\n+            BsdNativeDispatcher.clonefile(src, dst, flags);\n+        } catch (UnixException x) {\n+            switch (x.errno()) {\n+                case ENOTSUP: \/\/ cloning not supported by filesystem\n+                    return IOStatus.UNSUPPORTED;\n+                case EXDEV:   \/\/ src and dst on different filesystems\n+                case ENOTDIR: \/\/ problematic path parameter(s)\n+                    return IOStatus.UNSUPPORTED_CASE;\n+                default:\n+                    x.rethrowAsIOException(src, dst);\n+                    return IOStatus.THROWN;\n+            }\n+        }\n+\n+        return 0;\n+    }\n+\n@@ -81,0 +130,35 @@\n+    @Override\n+    protected void copyFile(UnixPath source,\n+                            UnixFileAttributes attrs,\n+                            UnixPath target,\n+                            Flags flags,\n+                            long addressToPollForCancel)\n+        throws IOException\n+    {\n+        \/\/ Attempt to clone the source unless cloning is not supported,\n+        \/\/ cancellation is not possible, or attributes are not to be copied\n+        if (!cloneFileNotSupported && addressToPollForCancel == 0 &&\n+            flags.copyPosixAttributes) {\n+            int res = clone(source, target, flags.followLinks);\n+\n+            if (res == 0) {\n+                \/\/ copy owner (not done by clonefile)\n+                try {\n+                    chown(target, attrs.uid(), attrs.gid());\n+                } catch (UnixException x) {\n+                    if (flags.failIfUnableToCopyPosix)\n+                        x.rethrowAsIOException(target);\n+                }\n+                return;\n+            }\n+\n+            if (res == IOStatus.UNSUPPORTED) {\n+                cloneFileNotSupported = true;\n+            }\n+\n+            \/\/ fall through to superclass method\n+       }\n+\n+        super.copyFile(source, attrs, target, flags, addressToPollForCancel);\n+    }\n+\n","filename":"src\/java.base\/macosx\/classes\/sun\/nio\/fs\/BsdFileSystem.java","additions":84,"deletions":0,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -64,0 +64,20 @@\n+    \/**\n+     * int clonefile(const char * src, const char * dst, int flags);\n+     *\/\n+    static int clonefile(UnixPath src, UnixPath dst, int flags)\n+        throws UnixException\n+    {\n+        try (NativeBuffer srcBuffer = copyToNativeBuffer(src);\n+            NativeBuffer dstBuffer = copyToNativeBuffer(dst)) {\n+            long comp = Blocker.begin();\n+            try {\n+                return clonefile0(srcBuffer.address(), dstBuffer.address(),\n+                                  flags);\n+            } finally {\n+                Blocker.end(comp);\n+            }\n+        }\n+    }\n+    private static native int clonefile0(long srcAddress, long dstAddress,\n+                                         int flags);\n+\n","filename":"src\/java.base\/macosx\/classes\/sun\/nio\/fs\/BsdNativeDispatcher.java","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -0,0 +1,82 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"jni.h\"\n+#include \"jni_util.h\"\n+#include \"jlong.h\"\n+\n+#include \"nio.h\"\n+\n+#include <stdlib.h>\n+#include <strings.h>\n+#include <unistd.h>\n+#include <errno.h>\n+#include <sys\/attr.h>\n+\n+#include \"sun_nio_fs_BsdFileStore.h\"\n+\n+#define CAPABILITY(vinfo, cap) \\\n+        (((vinfo).valid[VOL_CAPABILITIES_INTERFACES]        & (cap)) && \\\n+         ((vinfo).capabilities[VOL_CAPABILITIES_INTERFACES] & (cap)))\n+\n+static void throwUnixException(JNIEnv* env, int errnum) {\n+    jobject x = JNU_NewObjectByName(env, \"sun\/nio\/fs\/UnixException\",\n+        \"(I)V\", errnum);\n+    if (x != NULL) {\n+        (*env)->Throw(env, x);\n+    }\n+}\n+\n+JNIEXPORT jboolean JNICALL\n+Java_sun_nio_fs_BsdFileStore_supportsCloning0(JNIEnv* env, jclass this,\n+    jlong fileAddress)\n+{\n+    const char* file = (const char*)jlong_to_ptr(fileAddress);\n+\n+    struct attrlist alist;\n+    bzero(&alist, sizeof(alist));\n+    alist.bitmapcount = ATTR_BIT_MAP_COUNT;\n+    alist.volattr     = ATTR_VOL_INFO | ATTR_VOL_CAPABILITIES;\n+\n+    struct volAttrsBuf {\n+        u_int32_t length;\n+        vol_capabilities_attr_t capabilities;\n+    } __attribute__((aligned(4), packed));\n+    struct volAttrsBuf volAttrs;\n+    bzero(&volAttrs, sizeof(volAttrs));\n+\n+    \/\/ ignore any error in getattrlist\n+    if (getattrlist(file, &alist, &volAttrs, sizeof(volAttrs), 0) == 0) {\n+        vol_capabilities_attr_t volCaps = volAttrs.capabilities;\n+        int supportsAttrList = CAPABILITY(volCaps, VOL_CAP_INT_ATTRLIST);\n+        if (supportsAttrList) {\n+            return CAPABILITY(volCaps, VOL_CAP_INT_CLONE) != 0 ?\n+                JNI_TRUE : JNI_FALSE;\n+        }\n+    }\n+\n+    \/\/ return false if getattrlist fails\n+    return JNI_FALSE;\n+}\n","filename":"src\/java.base\/macosx\/native\/libnio\/fs\/BsdFileStore.c","additions":82,"deletions":0,"binary":false,"changes":82,"status":"added"},{"patch":"@@ -45,0 +45,2 @@\n+#include <sys\/attr.h>\n+#include <sys\/clonefile.h>\n@@ -228,0 +230,16 @@\n+JNIEXPORT jint JNICALL\n+Java_sun_nio_fs_BsdNativeDispatcher_clonefile0(JNIEnv* env, jclass this,\n+    jlong srcAddress, jlong dstAddress, jint flags)\n+{\n+    const char* src = (const char*)jlong_to_ptr(srcAddress);\n+    const char* dst = (const char*)jlong_to_ptr(dstAddress);\n+\n+    int ret = clonefile(src, dst, flags);\n+    if (ret != 0) {\n+        throwUnixException(env, errno);\n+        return ret;\n+    }\n+\n+    return 0;\n+}\n+\n","filename":"src\/java.base\/macosx\/native\/libnio\/fs\/BsdNativeDispatcher.c","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include <sys\/clonefile.h>\n@@ -136,0 +137,4 @@\n+#ifdef _ALLBSD_SOURCE\n+    static final int PREFIX_ENOTSUP = ENOTSUP;\n+#endif\n+\n@@ -147,0 +152,4 @@\n+    \/\/ flags used with clonefile\n+    static final int PREFIX_CLONE_NOFOLLOW = CLONE_NOFOLLOW;\n+    static final int PREFIX_CLONE_NOOWNERCOPY = CLONE_NOOWNERCOPY;\n+\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixConstants.java.template","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -431,1 +431,1 @@\n-    private static class Flags {\n+    protected static class Flags {\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixFileSystem.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}