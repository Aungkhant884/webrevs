{"files":[{"patch":"@@ -36,0 +36,1 @@\n+import sun.nio.ch.IOStatus;\n@@ -38,0 +39,4 @@\n+import static sun.nio.fs.UnixConstants.*;\n+import static sun.nio.fs.UnixNativeDispatcher.chown;\n+import static sun.nio.fs.UnixNativeDispatcher.unlink;\n+\n@@ -74,0 +79,37 @@\n+    \/**\n+     * Clones the file whose path name is {@code src} to that whose path\n+     * name is {@code dst} using the {@code clonefile} system call.\n+     *\n+     * @param src the path of the source file\n+     * @param dst the path of the destination file (clone)\n+     * @param followLinks whether to follow links\n+     *\n+     * @return 0 on success, or IOStatus.UNSUPPORTED_CASE if the call\n+     *         does not work with the given parameters\n+     *\/\n+    private int clone(UnixPath src, UnixPath dst, boolean followLinks)\n+        throws IOException\n+    {\n+        int flags = followLinks ? 0 : CLONE_NOFOLLOW;\n+        try {\n+            BsdNativeDispatcher.clonefile(src, dst, flags);\n+        } catch (UnixException x) {\n+            \/\/ clone failed so roll back\n+            try {\n+                unlink(dst);\n+            } catch (UnixException ignore) { }\n+\n+            switch (x.errno()) {\n+                case ENOTSUP: \/\/ cloning not supported by filesystem\n+                case EXDEV:   \/\/ src and dst on different filesystems\n+                case ENOTDIR: \/\/ problematic path parameter(s)\n+                    return IOStatus.UNSUPPORTED_CASE;\n+                default:\n+                    x.rethrowAsIOException(src, dst);\n+                    return IOStatus.THROWN;\n+            }\n+        }\n+\n+        return 0;\n+    }\n+\n@@ -81,0 +123,30 @@\n+    @Override\n+    protected void copyFile(UnixPath source,\n+                            UnixFileAttributes attrs,\n+                            UnixPath target,\n+                            Flags flags,\n+                            long addressToPollForCancel)\n+        throws IOException\n+    {\n+        \/\/ Attempt to clone the source unless cancellation is not possible,\n+        \/\/ or attributes are not to be copied\n+        if (addressToPollForCancel == 0 && flags.copyPosixAttributes) {\n+            int res = clone(source, target, flags.followLinks);\n+\n+            if (res == 0) {\n+                \/\/ copy owner (not done by clonefile)\n+                try {\n+                    chown(target, attrs.uid(), attrs.gid());\n+                } catch (UnixException x) {\n+                    if (flags.failIfUnableToCopyPosix)\n+                        x.rethrowAsIOException(target);\n+                }\n+                return;\n+            }\n+\n+            \/\/ fall through to superclass method\n+       }\n+\n+        super.copyFile(source, attrs, target, flags, addressToPollForCancel);\n+    }\n+\n","filename":"src\/java.base\/macosx\/classes\/sun\/nio\/fs\/BsdFileSystem.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -64,0 +64,20 @@\n+    \/**\n+     * int clonefile(const char * src, const char * dst, int flags);\n+     *\/\n+    static int clonefile(UnixPath src, UnixPath dst, int flags)\n+        throws UnixException\n+    {\n+        try (NativeBuffer srcBuffer = copyToNativeBuffer(src);\n+            NativeBuffer dstBuffer = copyToNativeBuffer(dst)) {\n+            long comp = Blocker.begin();\n+            try {\n+                return clonefile0(srcBuffer.address(), dstBuffer.address(),\n+                                  flags);\n+            } finally {\n+                Blocker.end(comp);\n+            }\n+        }\n+    }\n+    private static native int clonefile0(long srcAddress, long dstAddress,\n+                                         int flags);\n+\n","filename":"src\/java.base\/macosx\/classes\/sun\/nio\/fs\/BsdNativeDispatcher.java","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -45,0 +45,2 @@\n+#include <sys\/attr.h>\n+#include <sys\/clonefile.h>\n@@ -228,0 +230,16 @@\n+JNIEXPORT jint JNICALL\n+Java_sun_nio_fs_BsdNativeDispatcher_clonefile0(JNIEnv* env, jclass this,\n+    jlong srcAddress, jlong dstAddress, jint flags)\n+{\n+    const char* src = (const char*)jlong_to_ptr(srcAddress);\n+    const char* dst = (const char*)jlong_to_ptr(dstAddress);\n+\n+    int ret = clonefile(src, dst, flags);\n+    if (ret != 0) {\n+        throwUnixException(env, errno);\n+        return ret;\n+    }\n+\n+    return 0;\n+}\n+\n","filename":"src\/java.base\/macosx\/native\/libnio\/fs\/BsdNativeDispatcher.c","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include <sys\/clonefile.h>\n@@ -136,0 +137,4 @@\n+#ifdef _ALLBSD_SOURCE\n+    static final int PREFIX_ENOTSUP = ENOTSUP;\n+#endif\n+\n@@ -147,0 +152,4 @@\n+    \/\/ flags used with clonefile\n+    static final int PREFIX_CLONE_NOFOLLOW = CLONE_NOFOLLOW;\n+    static final int PREFIX_CLONE_NOOWNERCOPY = CLONE_NOOWNERCOPY;\n+\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixConstants.java.template","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -431,1 +431,1 @@\n-    private static class Flags {\n+    protected static class Flags {\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixFileSystem.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}