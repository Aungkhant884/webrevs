{"files":[{"patch":"@@ -36,0 +36,1 @@\n+import sun.nio.ch.IOStatus;\n@@ -38,0 +39,3 @@\n+import static sun.nio.fs.UnixConstants.*;\n+import static sun.nio.fs.UnixNativeDispatcher.chown;\n+\n@@ -44,0 +48,4 @@\n+    \/\/ whether file cloning is supported on this platform\n+    private static volatile boolean cloneFileNotSupported;\n+\n+\n@@ -74,0 +82,40 @@\n+    \/**\n+     * Clones the file whose path name is {@code src} to that whose path\n+     * name is {@code dst} using the {@code clonefile} system call.\n+     *\n+     * @param src the path of the source file\n+     * @param dst the path of the destination file (clone)\n+     * @param followLinks whether to follow links\n+     *\n+     * @return 0 on success, IOStatus.UNSUPPORTED_CASE if the call does not work\n+     *         with the given parameters, or IOStatus.UNSUPPORTED if cloning is\n+     *         not supported on this platform\n+     *\/\n+    private int clone(UnixPath src, UnixPath dst, boolean followLinks)\n+        throws IOException\n+    {\n+        \/\/ Do not attempt cloning if the source volume does not support it\n+        long options = followLinks ? 0 : FSOPT_NOFOLLOW;\n+        if ((BsdNativeDispatcher.getattrlist(src, options) &\n+            VOL_CAP_INT_CLONE) == 0)\n+            return IOStatus.UNSUPPORTED_CASE;\n+\n+        int flags = followLinks ? 0 : CLONE_NOFOLLOW;\n+        try {\n+            BsdNativeDispatcher.clonefile(src, dst, flags);\n+        } catch (UnixException x) {\n+            switch (x.errno()) {\n+                case ENOTSUP: \/\/ cloning not supported by filesystem\n+                    return IOStatus.UNSUPPORTED;\n+                case EXDEV:   \/\/ src and dst on different filesystems\n+                case ENOTDIR: \/\/ problematic path parameter(s)\n+                    return IOStatus.UNSUPPORTED_CASE;\n+                default:\n+                    x.rethrowAsIOException(src, dst);\n+                    return IOStatus.THROWN;\n+            }\n+        }\n+\n+        return 0;\n+    }\n+\n@@ -81,0 +129,35 @@\n+    @Override\n+    protected void copyFile(UnixPath source,\n+                            UnixFileAttributes attrs,\n+                            UnixPath target,\n+                            Flags flags,\n+                            long addressToPollForCancel)\n+        throws IOException\n+    {\n+        \/\/ Attempt to clone the source unless cloning is not supported,\n+        \/\/ cancellation is not possible, or attributes are not to be copied\n+        if (!cloneFileNotSupported && addressToPollForCancel == 0 &&\n+            flags.copyPosixAttributes) {\n+            int res = clone(source, target, flags.followLinks);\n+\n+            if (res == 0) {\n+                \/\/ copy owner (not done by clonefile)\n+                try {\n+                    chown(target, attrs.uid(), attrs.gid());\n+                } catch (UnixException x) {\n+                    if (flags.failIfUnableToCopyPosix)\n+                        x.rethrowAsIOException(target);\n+                }\n+                return;\n+            }\n+\n+            if (res == IOStatus.UNSUPPORTED) {\n+                cloneFileNotSupported = true;\n+            }\n+\n+            \/\/ fall through to superclass method\n+       }\n+\n+        super.copyFile(source, attrs, target, flags, addressToPollForCancel);\n+    }\n+\n","filename":"src\/java.base\/macosx\/classes\/sun\/nio\/fs\/BsdFileSystem.java","additions":83,"deletions":0,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -64,0 +64,38 @@\n+    \/**\n+     * int clonefile(const char * src, const char * dst, int flags);\n+     *\/\n+    static int clonefile(UnixPath src, UnixPath dst, int flags)\n+        throws UnixException\n+    {\n+        try (NativeBuffer srcBuffer = copyToNativeBuffer(src);\n+            NativeBuffer dstBuffer = copyToNativeBuffer(dst)) {\n+            long comp = Blocker.begin();\n+            try {\n+                return clonefile0(srcBuffer.address(), dstBuffer.address(),\n+                                  flags);\n+            } finally {\n+                Blocker.end(comp);\n+            }\n+        }\n+    }\n+    private static native int clonefile0(long srcAddress, long dstAddress,\n+                                         int flags);\n+\n+    \/**\n+     * int getattrlist(const char* path, struct attrlist* attrList,\n+     *                 void* attrBuf, size_t attrBufSize,\n+     *                 unsigned long options);\n+     *\/\n+    static int getattrlist(UnixPath path, long options)\n+    {\n+        try (NativeBuffer pathBuffer = copyToNativeBuffer(path)) {\n+            long comp = Blocker.begin();\n+            try {\n+                return getattrlist0(pathBuffer.address(), options);\n+            } finally {\n+                Blocker.end(comp);\n+            }\n+        }\n+    }\n+    private static native int getattrlist0(long pathAddress, long options);\n+\n","filename":"src\/java.base\/macosx\/classes\/sun\/nio\/fs\/BsdNativeDispatcher.java","additions":38,"deletions":0,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+#include <unistd.h>\n@@ -45,0 +46,2 @@\n+#include <sys\/attr.h>\n+#include <sys\/clonefile.h>\n@@ -228,0 +231,45 @@\n+JNIEXPORT jint JNICALL\n+Java_sun_nio_fs_BsdNativeDispatcher_clonefile0(JNIEnv* env, jclass this,\n+    jlong srcAddress, jlong dstAddress, jint flags)\n+{\n+    const char* src = (const char*)jlong_to_ptr(srcAddress);\n+    const char* dst = (const char*)jlong_to_ptr(dstAddress);\n+\n+    int ret = clonefile(src, dst, flags);\n+    if (ret != 0) {\n+        throwUnixException(env, errno);\n+        return ret;\n+    }\n+\n+    return 0;\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_sun_nio_fs_BsdNativeDispatcher_getattrlist0(JNIEnv* env, jclass this,\n+    jlong pathAddress, jlong options)\n+{\n+    const char* path = (const char*)jlong_to_ptr(pathAddress);\n+\n+    struct attrlist alist;\n+    bzero(&alist, sizeof(alist));\n+    alist.bitmapcount = ATTR_BIT_MAP_COUNT;\n+    alist.volattr     = ATTR_VOL_INFO | ATTR_VOL_CAPABILITIES;\n+\n+    struct volAttrsBuf {\n+        u_int32_t length;\n+        vol_capabilities_attr_t capabilities;\n+    } __attribute__((aligned(4), packed));\n+    struct volAttrsBuf volAttrs;\n+    bzero(&volAttrs, sizeof(volAttrs));\n+\n+    if (getattrlist(path, &alist, &volAttrs, sizeof(volAttrs), options) == 0) {\n+        vol_capabilities_attr_t volCaps = volAttrs.capabilities;\n+        int index = VOL_CAPABILITIES_INTERFACES;\n+        int caps = volCaps.valid[index] & volCaps.capabilities[index];\n+        if (caps & VOL_CAP_INT_ATTRLIST)\n+            return caps;\n+    }\n+\n+    return 0;\n+}\n+\n","filename":"src\/java.base\/macosx\/native\/libnio\/fs\/BsdNativeDispatcher.c","additions":48,"deletions":0,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include <sys\/clonefile.h>\n@@ -136,0 +137,4 @@\n+#ifdef _ALLBSD_SOURCE\n+    static final int PREFIX_ENOTSUP = ENOTSUP;\n+#endif\n+\n@@ -147,0 +152,8 @@\n+    \/\/ flags used with clonefile\n+    static final int PREFIX_CLONE_NOFOLLOW = CLONE_NOFOLLOW;\n+    static final int PREFIX_CLONE_NOOWNERCOPY = CLONE_NOOWNERCOPY;\n+\n+    \/\/ flags used with getattrlist\n+    static final int PREFIX_VOL_CAPABILITIES_INTERFACES = VOL_CAPABILITIES_INTERFACES;\n+    static final int PREFIX_VOL_CAP_INT_CLONE = VOL_CAP_INT_CLONE;\n+\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixConstants.java.template","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -431,1 +431,1 @@\n-    private static class Flags {\n+    protected static class Flags {\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixFileSystem.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}