{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,0 @@\n-import jdk.internal.misc.Blocker;\n@@ -34,1 +33,0 @@\n-import static sun.nio.fs.UnixNativeDispatcher.copyToNativeBuffer;\n@@ -119,14 +117,0 @@\n-    boolean supportsCloning() throws IOException {\n-        try (NativeBuffer fileBuffer = copyToNativeBuffer(file())) {\n-            long comp = Blocker.begin();\n-            try {\n-                return supportsCloning0(fileBuffer.address());\n-            } finally {\n-                Blocker.end(comp);\n-            }\n-        }\n-\n-    }\n-\n-    private static native boolean supportsCloning0(long fileAddress);\n-\n","filename":"src\/java.base\/macosx\/classes\/sun\/nio\/fs\/BsdFileStore.java","additions":1,"deletions":17,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -97,5 +97,4 @@\n-        \/\/ Do not clone unless both files are on the same volume and that\n-        \/\/ volume is indicated as supporting file cloning\n-        BsdFileStore bfs = (BsdFileStore)provider().getFileStore(src);\n-        if (!bfs.equals(provider().getFileStore(dst.getParent())) ||\n-            !bfs.supportsCloning())\n+        \/\/ Do not attempt cloning if the source volume does not support it\n+        long options = followLinks ? 0 : FSOPT_NOFOLLOW;\n+        if ((BsdNativeDispatcher.getattrlist(src, options) &\n+            VOL_CAP_INT_CLONE) == 0)\n","filename":"src\/java.base\/macosx\/classes\/sun\/nio\/fs\/BsdFileSystem.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -84,0 +84,18 @@\n+    \/**\n+     * int getattrlist(const char* path, struct attrlist* attrList,\n+     *                 void* attrBuf, size_t attrBufSize,\n+     *                 unsigned long options);\n+     *\/\n+    static int getattrlist(UnixPath path, long options)\n+    {\n+        try (NativeBuffer pathBuffer = copyToNativeBuffer(path)) {\n+            long comp = Blocker.begin();\n+            try {\n+                return getattrlist0(pathBuffer.address(), options);\n+            } finally {\n+                Blocker.end(comp);\n+            }\n+        }\n+    }\n+    private static native int getattrlist0(long pathAddress, long options);\n+\n","filename":"src\/java.base\/macosx\/classes\/sun\/nio\/fs\/BsdNativeDispatcher.java","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -1,82 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"jni.h\"\n-#include \"jni_util.h\"\n-#include \"jlong.h\"\n-\n-#include \"nio.h\"\n-\n-#include <stdlib.h>\n-#include <strings.h>\n-#include <unistd.h>\n-#include <errno.h>\n-#include <sys\/attr.h>\n-\n-#include \"sun_nio_fs_BsdFileStore.h\"\n-\n-#define CAPABILITY(vinfo, cap) \\\n-        (((vinfo).valid[VOL_CAPABILITIES_INTERFACES]        & (cap)) && \\\n-         ((vinfo).capabilities[VOL_CAPABILITIES_INTERFACES] & (cap)))\n-\n-static void throwUnixException(JNIEnv* env, int errnum) {\n-    jobject x = JNU_NewObjectByName(env, \"sun\/nio\/fs\/UnixException\",\n-        \"(I)V\", errnum);\n-    if (x != NULL) {\n-        (*env)->Throw(env, x);\n-    }\n-}\n-\n-JNIEXPORT jboolean JNICALL\n-Java_sun_nio_fs_BsdFileStore_supportsCloning0(JNIEnv* env, jclass this,\n-    jlong fileAddress)\n-{\n-    const char* file = (const char*)jlong_to_ptr(fileAddress);\n-\n-    struct attrlist alist;\n-    bzero(&alist, sizeof(alist));\n-    alist.bitmapcount = ATTR_BIT_MAP_COUNT;\n-    alist.volattr     = ATTR_VOL_INFO | ATTR_VOL_CAPABILITIES;\n-\n-    struct volAttrsBuf {\n-        u_int32_t length;\n-        vol_capabilities_attr_t capabilities;\n-    } __attribute__((aligned(4), packed));\n-    struct volAttrsBuf volAttrs;\n-    bzero(&volAttrs, sizeof(volAttrs));\n-\n-    \/\/ ignore any error in getattrlist\n-    if (getattrlist(file, &alist, &volAttrs, sizeof(volAttrs), 0) == 0) {\n-        vol_capabilities_attr_t volCaps = volAttrs.capabilities;\n-        int supportsAttrList = CAPABILITY(volCaps, VOL_CAP_INT_ATTRLIST);\n-        if (supportsAttrList) {\n-            return CAPABILITY(volCaps, VOL_CAP_INT_CLONE) != 0 ?\n-                JNI_TRUE : JNI_FALSE;\n-        }\n-    }\n-\n-    \/\/ return false if getattrlist fails\n-    return JNI_FALSE;\n-}\n","filename":"src\/java.base\/macosx\/native\/libnio\/fs\/BsdFileStore.c","additions":0,"deletions":82,"binary":false,"changes":82,"status":"deleted"},{"patch":"@@ -42,0 +42,1 @@\n+#include <unistd.h>\n@@ -246,0 +247,29 @@\n+JNIEXPORT jint JNICALL\n+Java_sun_nio_fs_BsdNativeDispatcher_getattrlist0(JNIEnv* env, jclass this,\n+    jlong pathAddress, jlong options)\n+{\n+    const char* path = (const char*)jlong_to_ptr(pathAddress);\n+\n+    struct attrlist alist;\n+    bzero(&alist, sizeof(alist));\n+    alist.bitmapcount = ATTR_BIT_MAP_COUNT;\n+    alist.volattr     = ATTR_VOL_INFO | ATTR_VOL_CAPABILITIES;\n+\n+    struct volAttrsBuf {\n+        u_int32_t length;\n+        vol_capabilities_attr_t capabilities;\n+    } __attribute__((aligned(4), packed));\n+    struct volAttrsBuf volAttrs;\n+    bzero(&volAttrs, sizeof(volAttrs));\n+\n+    if (getattrlist(path, &alist, &volAttrs, sizeof(volAttrs), options) == 0) {\n+        vol_capabilities_attr_t volCaps = volAttrs.capabilities;\n+        int index = VOL_CAPABILITIES_INTERFACES;\n+        int caps = volCaps.valid[index] & volCaps.capabilities[index];\n+        if (caps & VOL_CAP_INT_ATTRLIST)\n+            return caps;\n+    }\n+\n+    return 0;\n+}\n+\n","filename":"src\/java.base\/macosx\/native\/libnio\/fs\/BsdNativeDispatcher.c","additions":30,"deletions":0,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -156,0 +156,4 @@\n+    \/\/ flags used with getattrlist\n+    static final int PREFIX_VOL_CAPABILITIES_INTERFACES = VOL_CAPABILITIES_INTERFACES;\n+    static final int PREFIX_VOL_CAP_INT_CLONE = VOL_CAP_INT_CLONE;\n+\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixConstants.java.template","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"}]}