{"files":[{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2012, 2020 SAP SE. All rights reserved.\n+ * Copyright (c) 2012, 2021 SAP SE. All rights reserved.\n@@ -185,2 +185,0 @@\n-static jlong    initial_time_count = 0;\n-static int      clock_tics_per_sec = 100;\n@@ -924,15 +922,0 @@\n-\/\/ Time since start-up in seconds to a fine granularity.\n-double os::elapsedTime() {\n-  return ((double)os::elapsed_counter()) \/ os::elapsed_frequency(); \/\/ nanosecond resolution\n-}\n-\n-jlong os::elapsed_counter() {\n-  return javaTimeNanos() - initial_time_count;\n-}\n-\n-jlong os::elapsed_frequency() {\n-  return NANOSECS_PER_SEC; \/\/ nanosecond resolution\n-}\n-\n-bool os::supports_vtime() { return true; }\n-\n@@ -997,43 +980,0 @@\n-void os::javaTimeNanos_info(jvmtiTimerInfo *info_ptr) {\n-  info_ptr->max_value = ALL_64_BITS;\n-  \/\/ mread_real_time() is monotonic (see 'os::javaTimeNanos()')\n-  info_ptr->may_skip_backward = false;\n-  info_ptr->may_skip_forward = false;\n-  info_ptr->kind = JVMTI_TIMER_ELAPSED;    \/\/ elapsed not CPU time\n-}\n-\n-\/\/ Return the real, user, and system times in seconds from an\n-\/\/ arbitrary fixed point in the past.\n-bool os::getTimesSecs(double* process_real_time,\n-                      double* process_user_time,\n-                      double* process_system_time) {\n-  struct tms ticks;\n-  clock_t real_ticks = times(&ticks);\n-\n-  if (real_ticks == (clock_t) (-1)) {\n-    return false;\n-  } else {\n-    double ticks_per_second = (double) clock_tics_per_sec;\n-    *process_user_time = ((double) ticks.tms_utime) \/ ticks_per_second;\n-    *process_system_time = ((double) ticks.tms_stime) \/ ticks_per_second;\n-    *process_real_time = ((double) real_ticks) \/ ticks_per_second;\n-\n-    return true;\n-  }\n-}\n-\n-char * os::local_time_string(char *buf, size_t buflen) {\n-  struct tm t;\n-  time_t long_time;\n-  time(&long_time);\n-  localtime_r(&long_time, &t);\n-  jio_snprintf(buf, buflen, \"%d-%02d-%02d %02d:%02d:%02d\",\n-               t.tm_year + 1900, t.tm_mon + 1, t.tm_mday,\n-               t.tm_hour, t.tm_min, t.tm_sec);\n-  return buf;\n-}\n-\n-struct tm* os::localtime_pd(const time_t* clock, struct tm* res) {\n-  return localtime_r(clock, res);\n-}\n-\n@@ -2405,2 +2345,0 @@\n-  clock_tics_per_sec = sysconf(_SC_CLK_TCK);\n-\n@@ -2410,2 +2348,0 @@\n-  initial_time_count = javaTimeNanos();\n-\n","filename":"src\/hotspot\/os\/aix\/os_aix.cpp","additions":1,"deletions":65,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -126,4 +126,0 @@\n-static jlong initial_time_count=0;\n-\n-static int clock_tics_per_sec = 100;\n-\n@@ -749,16 +745,0 @@\n-\n-\/\/ Time since start-up in seconds to a fine granularity.\n-double os::elapsedTime() {\n-  return ((double)os::elapsed_counter()) \/ os::elapsed_frequency();\n-}\n-\n-jlong os::elapsed_counter() {\n-  return javaTimeNanos() - initial_time_count;\n-}\n-\n-jlong os::elapsed_frequency() {\n-  return NANOSECS_PER_SEC; \/\/ nanosecond resolution\n-}\n-\n-bool os::supports_vtime() { return true; }\n-\n@@ -807,8 +787,0 @@\n-\n-void os::javaTimeNanos_info(jvmtiTimerInfo *info_ptr) {\n-  info_ptr->max_value = ALL_64_BITS;\n-  info_ptr->may_skip_backward = false;      \/\/ not subject to resetting or drifting\n-  info_ptr->may_skip_forward = false;       \/\/ not subject to resetting or drifting\n-  info_ptr->kind = JVMTI_TIMER_ELAPSED;     \/\/ elapsed not CPU time\n-}\n-\n@@ -817,36 +789,0 @@\n-\/\/ Return the real, user, and system times in seconds from an\n-\/\/ arbitrary fixed point in the past.\n-bool os::getTimesSecs(double* process_real_time,\n-                      double* process_user_time,\n-                      double* process_system_time) {\n-  struct tms ticks;\n-  clock_t real_ticks = times(&ticks);\n-\n-  if (real_ticks == (clock_t) (-1)) {\n-    return false;\n-  } else {\n-    double ticks_per_second = (double) clock_tics_per_sec;\n-    *process_user_time = ((double) ticks.tms_utime) \/ ticks_per_second;\n-    *process_system_time = ((double) ticks.tms_stime) \/ ticks_per_second;\n-    *process_real_time = ((double) real_ticks) \/ ticks_per_second;\n-\n-    return true;\n-  }\n-}\n-\n-\n-char * os::local_time_string(char *buf, size_t buflen) {\n-  struct tm t;\n-  time_t long_time;\n-  time(&long_time);\n-  localtime_r(&long_time, &t);\n-  jio_snprintf(buf, buflen, \"%d-%02d-%02d %02d:%02d:%02d\",\n-               t.tm_year + 1900, t.tm_mon + 1, t.tm_mday,\n-               t.tm_hour, t.tm_min, t.tm_sec);\n-  return buf;\n-}\n-\n-struct tm* os::localtime_pd(const time_t* clock, struct tm*  res) {\n-  return localtime_r(clock, res);\n-}\n-\n@@ -1993,2 +1929,0 @@\n-  clock_tics_per_sec = CLK_TCK;\n-\n@@ -2007,1 +1941,0 @@\n-  initial_time_count = javaTimeNanos();\n","filename":"src\/hotspot\/os\/bsd\/os_bsd.cpp","additions":0,"deletions":67,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -174,2 +174,0 @@\n-static jlong initial_time_count=0;\n-\n@@ -1269,16 +1267,0 @@\n-\n-\/\/ Time since start-up in seconds to a fine granularity.\n-double os::elapsedTime() {\n-  return ((double)os::elapsed_counter()) \/ os::elapsed_frequency(); \/\/ nanosecond resolution\n-}\n-\n-jlong os::elapsed_counter() {\n-  return javaTimeNanos() - initial_time_count;\n-}\n-\n-jlong os::elapsed_frequency() {\n-  return NANOSECS_PER_SEC; \/\/ nanosecond resolution\n-}\n-\n-bool os::supports_vtime() { return true; }\n-\n@@ -1322,36 +1304,0 @@\n-\/\/ Return the real, user, and system times in seconds from an\n-\/\/ arbitrary fixed point in the past.\n-bool os::getTimesSecs(double* process_real_time,\n-                      double* process_user_time,\n-                      double* process_system_time) {\n-  struct tms ticks;\n-  clock_t real_ticks = times(&ticks);\n-\n-  if (real_ticks == (clock_t) (-1)) {\n-    return false;\n-  } else {\n-    double ticks_per_second = (double) clock_tics_per_sec;\n-    *process_user_time = ((double) ticks.tms_utime) \/ ticks_per_second;\n-    *process_system_time = ((double) ticks.tms_stime) \/ ticks_per_second;\n-    *process_real_time = ((double) real_ticks) \/ ticks_per_second;\n-\n-    return true;\n-  }\n-}\n-\n-\n-char * os::local_time_string(char *buf, size_t buflen) {\n-  struct tm t;\n-  time_t long_time;\n-  time(&long_time);\n-  localtime_r(&long_time, &t);\n-  jio_snprintf(buf, buflen, \"%d-%02d-%02d %02d:%02d:%02d\",\n-               t.tm_year + 1900, t.tm_mon + 1, t.tm_mday,\n-               t.tm_hour, t.tm_min, t.tm_sec);\n-  return buf;\n-}\n-\n-struct tm* os::localtime_pd(const time_t* clock, struct tm*  res) {\n-  return localtime_r(clock, res);\n-}\n-\n@@ -4434,2 +4380,0 @@\n-\n-  initial_time_count = javaTimeNanos();\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":0,"deletions":56,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -63,0 +63,2 @@\n+#include <sys\/time.h>\n+#include <sys\/times.h>\n@@ -90,0 +92,8 @@\n+static jlong initial_time_count = 0;\n+\n+#if defined(_ALLBSD_SOURCE)\n+static int clock_tics_per_sec = CLK_TCK;\n+#else\n+static int clock_tics_per_sec = 100;\n+#endif\n+\n@@ -1227,1 +1237,3 @@\n-\n+#if defined(__linux__) || defined(_AIX)\n+  clock_tics_per_sec = sysconf(_SC_CLK_TCK);\n+#endif\n@@ -1259,0 +1271,2 @@\n+\n+  initial_time_count = javaTimeNanos();\n@@ -1416,0 +1430,2 @@\n+#endif \/\/ ! APPLE && !AIX\n+\n@@ -1427,1 +1443,50 @@\n-#endif \/\/ ! APPLE && !AIX\n+\/\/ Time since start-up in seconds to a fine granularity.\n+double os::elapsedTime() {\n+  return ((double)os::elapsed_counter()) \/ os::elapsed_frequency(); \/\/ nanosecond resolution\n+}\n+\n+jlong os::elapsed_counter() {\n+  return os::javaTimeNanos() - initial_time_count;\n+}\n+\n+jlong os::elapsed_frequency() {\n+  return NANOSECS_PER_SEC; \/\/ nanosecond resolution\n+}\n+\n+bool os::supports_vtime() { return true; }\n+\n+\/\/ Return the real, user, and system times in seconds from an\n+\/\/ arbitrary fixed point in the past.\n+bool os::getTimesSecs(double* process_real_time,\n+                      double* process_user_time,\n+                      double* process_system_time) {\n+  struct tms ticks;\n+  clock_t real_ticks = times(&ticks);\n+\n+  if (real_ticks == (clock_t) (-1)) {\n+    return false;\n+  } else {\n+    double ticks_per_second = (double) clock_tics_per_sec;\n+    *process_user_time = ((double) ticks.tms_utime) \/ ticks_per_second;\n+    *process_system_time = ((double) ticks.tms_stime) \/ ticks_per_second;\n+    *process_real_time = ((double) real_ticks) \/ ticks_per_second;\n+\n+    return true;\n+  }\n+}\n+\n+char * os::local_time_string(char *buf, size_t buflen) {\n+  struct tm t;\n+  time_t long_time;\n+  time(&long_time);\n+  localtime_r(&long_time, &t);\n+  jio_snprintf(buf, buflen, \"%d-%02d-%02d %02d:%02d:%02d\",\n+               t.tm_year + 1900, t.tm_mon + 1, t.tm_mday,\n+               t.tm_hour, t.tm_min, t.tm_sec);\n+  return buf;\n+}\n+\n+struct tm* os::localtime_pd(const time_t* clock, struct tm*  res) {\n+  return localtime_r(clock, res);\n+}\n+\n","filename":"src\/hotspot\/os\/posix\/os_posix.cpp","additions":67,"deletions":2,"binary":false,"changes":69,"status":"modified"}]}