{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -279,1 +279,1 @@\n-  \/\/ other calls are skipped if there are no unescaped arguments passed to them\n+  \/\/ other calls are skipped if there are no non-escaped arguments passed to them\n","filename":"src\/hotspot\/share\/ci\/bcEscapeAnalyzer.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -142,1 +142,1 @@\n-  \/\/ True iff only newly allocated unescaped objects are returned.\n+  \/\/ True iff only newly allocated non-escaped objects are returned.\n","filename":"src\/hotspot\/share\/ci\/bcEscapeAnalyzer.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2061,1 +2061,1 @@\n-    \/\/ If we are locking an unescaped object, the lock\/unlock is unnecessary\n+    \/\/ If we are locking an non-escaped object, the lock\/unlock is unnecessary\n@@ -2229,1 +2229,1 @@\n-    \/\/ If we are unlocking an unescaped object, the lock\/unlock is unnecessary.\n+    \/\/ If we are unlocking an non-escaped object, the lock\/unlock is unnecessary.\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,2 +66,0 @@\n-  _pcmp_neq = NULL; \/\/ Should be initialized\n-  _pcmp_eq  = NULL;\n@@ -76,1 +74,1 @@\n-    if (n->is_Allocate())\n+    if (n->is_Allocate()) {\n@@ -78,0 +76,1 @@\n+    }\n@@ -80,1 +79,1 @@\n-      if (!(obj->is_Parm() || obj->is_Con()))\n+      if (!(obj->is_Parm() || obj->is_Con())) {\n@@ -82,0 +81,1 @@\n+      }\n@@ -106,1 +106,1 @@\n-  if (oop_null->outcnt() == 0)\n+  if (oop_null->outcnt() == 0) {\n@@ -108,1 +108,2 @@\n-  if (noop_null->outcnt() == 0)\n+  }\n+  if (noop_null->outcnt() == 0) {\n@@ -110,0 +111,1 @@\n+  }\n@@ -124,1 +126,1 @@\n-  GrowableArray<JavaObjectNode*> non_escaped_worklist;\n+  GrowableArray<JavaObjectNode*> non_escaped_allocs_worklist;\n@@ -156,1 +158,1 @@\n-          non_escaped_worklist.append(ptn->as_JavaObject());\n+          non_escaped_allocs_worklist.append(ptn->as_JavaObject());\n@@ -196,1 +198,1 @@\n-  if (non_escaped_worklist.length() == 0) {\n+  if (non_escaped_allocs_worklist.length() == 0) {\n@@ -205,1 +207,0 @@\n-  int ptnodes_length = ptnodes_worklist.length();\n@@ -212,0 +213,1 @@\n+    int ptnodes_length = ptnodes_worklist.length();\n@@ -231,1 +233,1 @@\n-  if (!complete_connection_graph(ptnodes_worklist, non_escaped_worklist,\n+  if (!complete_connection_graph(ptnodes_worklist, non_escaped_allocs_worklist,\n@@ -241,1 +243,1 @@\n-  int non_escaped_length = non_escaped_worklist.length();\n+  int non_escaped_length = non_escaped_allocs_worklist.length();\n@@ -243,1 +245,1 @@\n-    JavaObjectNode* ptn = non_escaped_worklist.at(next);\n+    JavaObjectNode* ptn = non_escaped_allocs_worklist.at(next);\n@@ -260,1 +262,1 @@\n-    verify_connection_graph(ptnodes_worklist, non_escaped_worklist,\n+    verify_connection_graph(ptnodes_worklist, non_escaped_allocs_worklist,\n@@ -275,1 +277,1 @@\n-  bool has_non_escaping_obj = (non_escaped_worklist.length() > 0);\n+  bool has_non_escaping_obj = (non_escaped_allocs_worklist.length() > 0);\n@@ -286,1 +288,0 @@\n-  bool has_scalar_replaceable_candidates = (alloc_worklist.length() > 0);\n@@ -299,0 +300,1 @@\n+  bool has_scalar_replaceable_candidates = (alloc_worklist.length() > 0);\n@@ -311,1 +313,1 @@\n-    if(!EliminateAllocations) {\n+    if (!EliminateAllocations) {\n@@ -431,1 +433,1 @@\n-  if (n_ptn != NULL)\n+  if (n_ptn != NULL) {\n@@ -433,1 +435,1 @@\n-\n+  }\n@@ -452,1 +454,1 @@\n-        if (name != NULL && strcmp(name, \"uncommon_trap\") == 0)\n+        if (name != NULL && strcmp(name, \"uncommon_trap\") == 0) {\n@@ -454,0 +456,1 @@\n+        }\n@@ -469,1 +472,1 @@\n-  if (n_ptn == phantom_obj || n_ptn == null_obj)\n+  if (n_ptn == phantom_obj || n_ptn == null_obj) {\n@@ -471,1 +474,1 @@\n-\n+  }\n@@ -588,1 +591,1 @@\n-      \/\/ fallthrough\n+      \/\/ fall-through\n@@ -676,1 +679,1 @@\n-        if (in == NULL)\n+        if (in == NULL) {\n@@ -678,0 +681,1 @@\n+        }\n@@ -679,1 +683,1 @@\n-        if (uncast_in->is_top() || uncast_in == n)\n+        if (uncast_in->is_top() || uncast_in == n) {\n@@ -681,0 +685,1 @@\n+        }\n@@ -707,1 +712,1 @@\n-          if (in == NULL)\n+          if (in == NULL) {\n@@ -709,0 +714,1 @@\n+          }\n@@ -710,1 +716,1 @@\n-          if (uncast_in->is_top() || uncast_in == n)\n+          if (uncast_in->is_top() || uncast_in == n) {\n@@ -712,0 +718,1 @@\n+          }\n@@ -949,1 +956,1 @@\n-      \/\/ Returns a newly allocated unescaped object.\n+      \/\/ Returns a newly allocated non-escaped object.\n@@ -968,1 +975,1 @@\n-        \/\/ Returns a newly allocated unescaped object, simply\n+        \/\/ Returns a newly allocated non-escaped object, simply\n@@ -1032,1 +1039,1 @@\n-        if (arg->is_top() || !at->isa_ptr() || !aat->isa_ptr())\n+        if (arg->is_top() || !at->isa_ptr() || !aat->isa_ptr()) {\n@@ -1034,0 +1041,1 @@\n+        }\n@@ -1224,1 +1232,1 @@\n-                         GrowableArray<JavaObjectNode*>& non_escaped_worklist,\n+                         GrowableArray<JavaObjectNode*>& non_escaped_allocs_worklist,\n@@ -1232,1 +1240,1 @@\n-#define CG_BUILD_ITER_LIMIT 20\n+#define GRAPH_BUILD_ITER_LIMIT 20\n@@ -1237,1 +1245,1 @@\n-  if (!find_non_escaped_objects(ptnodes_worklist, non_escaped_worklist)) {\n+  if (!find_non_escaped_objects(ptnodes_worklist, non_escaped_allocs_worklist)) {\n@@ -1242,0 +1250,2 @@\n+  elapsedTimer build_time;\n+  build_time.start();\n@@ -1248,1 +1258,1 @@\n-           (iterations++ < CG_BUILD_ITER_LIMIT)) {\n+           (iterations++ < GRAPH_BUILD_ITER_LIMIT)) {\n@@ -1283,1 +1293,1 @@\n-        if (!find_non_escaped_objects(ptnodes_worklist, non_escaped_worklist)) {\n+        if (!find_non_escaped_objects(ptnodes_worklist, non_escaped_allocs_worklist)) {\n@@ -1293,1 +1303,1 @@\n-    if ((iterations < CG_BUILD_ITER_LIMIT) && !timeout) {\n+    if ((iterations < GRAPH_BUILD_ITER_LIMIT) && !timeout) {\n@@ -1315,0 +1325,4 @@\n+  build_time.stop();\n+  _build_time = build_time.seconds();\n+  _build_iterations = iterations;\n+\n@@ -1316,1 +1330,1 @@\n-  if ((iterations >= CG_BUILD_ITER_LIMIT) || timeout) {\n+  if ((iterations >= GRAPH_BUILD_ITER_LIMIT) || timeout) {\n@@ -1324,1 +1338,1 @@\n-           time.seconds(), iterations, nodes_size(), ptnodes_worklist.length());\n+           _build_time, _build_iterations, nodes_size(), ptnodes_worklist.length());\n@@ -1331,2 +1345,2 @@\n-    tty->print_cr(\"EA: %d iterations to build connection graph with %d nodes and worklist size %d\",\n-                  iterations, nodes_size(), ptnodes_worklist.length());\n+    tty->print_cr(\"EA: %d iterations and %f sec to build connection graph with %d nodes and worklist size %d\",\n+                  _build_iterations, _build_time, nodes_size(), ptnodes_worklist.length());\n@@ -1336,1 +1350,1 @@\n-#undef CG_BUILD_ITER_LIMIT\n+#undef GRAPH_BUILD_ITER_LIMIT\n@@ -1339,1 +1353,1 @@\n-  int non_escaped_length = non_escaped_worklist.length();\n+  int non_escaped_length = non_escaped_allocs_worklist.length();\n@@ -1341,1 +1355,1 @@\n-    JavaObjectNode* ptn = non_escaped_worklist.at(next);\n+    JavaObjectNode* ptn = non_escaped_allocs_worklist.at(next);\n@@ -1345,1 +1359,1 @@\n-      if (find_init_values(ptn, null_obj, _igvn) > 0) {\n+      if (find_init_values_null(ptn, _igvn) > 0) {\n@@ -1367,1 +1381,1 @@\n-                                               GrowableArray<JavaObjectNode*>& non_escaped_worklist) {\n+                                               GrowableArray<JavaObjectNode*>& non_escaped_allocs_worklist) {\n@@ -1430,2 +1444,2 @@\n-  for (int next = non_escaped_worklist.length()-1; next >= 0 ; --next) {\n-    JavaObjectNode* ptn = non_escaped_worklist.at(next);\n+  for (int next = non_escaped_allocs_worklist.length()-1; next >= 0 ; --next) {\n+    JavaObjectNode* ptn = non_escaped_allocs_worklist.at(next);\n@@ -1433,1 +1447,1 @@\n-      non_escaped_worklist.delete_at(next);\n+      non_escaped_allocs_worklist.delete_at(next);\n@@ -1437,1 +1451,1 @@\n-      find_init_values(ptn, phantom_obj, NULL);\n+      find_init_values_phantom(ptn);\n@@ -1440,1 +1454,1 @@\n-  return (non_escaped_worklist.length() > 0);\n+  return (non_escaped_allocs_worklist.length() > 0);\n@@ -1450,1 +1464,1 @@\n-      if (use->is_Arraycopy())\n+      if (use->is_Arraycopy()) {\n@@ -1452,0 +1466,1 @@\n+      }\n@@ -1472,1 +1487,1 @@\n-      if (jobj == null_obj) \/\/ NULL object does not have field edges\n+      if (jobj == null_obj) { \/\/ NULL object does not have field edges\n@@ -1474,0 +1489,1 @@\n+      }\n@@ -1482,1 +1498,1 @@\n-    if (!add_edge(use, jobj))\n+    if (!add_edge(use, jobj)) {\n@@ -1484,0 +1500,1 @@\n+    }\n@@ -1491,1 +1508,1 @@\n-            if (jobj == null_obj) \/\/ NULL object does not have field edges\n+            if (jobj == null_obj) { \/\/ NULL object does not have field edges\n@@ -1493,0 +1510,1 @@\n+            }\n@@ -1551,1 +1569,1 @@\n-        if (f == field || !f->as_Field()->is_oop())\n+        if (f == field || !f->as_Field()->is_oop()) {\n@@ -1553,0 +1571,1 @@\n+        }\n@@ -1574,1 +1593,1 @@\n-        if (f == field || !f->as_Field()->is_oop())\n+        if (f == field || !f->as_Field()->is_oop()) {\n@@ -1576,0 +1595,1 @@\n+        }\n@@ -1594,1 +1614,1 @@\n-      if (base->ideal_node()->is_Allocate())\n+      if (base->ideal_node()->is_Allocate()) {\n@@ -1596,0 +1616,1 @@\n+      }\n@@ -1608,1 +1629,1 @@\n-int ConnectionGraph::find_init_values(JavaObjectNode* pta, PointsToNode* init_val, PhaseTransform* phase) {\n+int ConnectionGraph::find_init_values_phantom(JavaObjectNode* pta) {\n@@ -1610,1 +1631,0 @@\n-  int new_edges = 0;\n@@ -1612,6 +1632,7 @@\n-  if (init_val == phantom_obj) {\n-    \/\/ Do nothing for Allocate nodes since its fields values are\n-    \/\/ \"known\" unless they are initialized by arraycopy\/clone.\n-    if (alloc->is_Allocate() && !pta->arraycopy_dst())\n-      return 0;\n-    assert(pta->arraycopy_dst() || alloc->as_CallStaticJava(), \"sanity\");\n+\n+  \/\/ Do nothing for Allocate nodes since its fields values are\n+  \/\/ \"known\" unless they are initialized by arraycopy\/clone.\n+  if (alloc->is_Allocate() && !pta->arraycopy_dst()) {\n+    return 0;\n+  }\n+  assert(pta->arraycopy_dst() || alloc->as_CallStaticJava(), \"sanity\");\n@@ -1619,4 +1640,4 @@\n-    if (!pta->arraycopy_dst() && alloc->as_CallStaticJava()->method() == NULL) {\n-      const char* name = alloc->as_CallStaticJava()->_name;\n-      assert(strncmp(name, \"_multianewarray\", 15) == 0, \"sanity\");\n-    }\n+  if (!pta->arraycopy_dst() && alloc->as_CallStaticJava()->method() == NULL) {\n+    const char* name = alloc->as_CallStaticJava()->_name;\n+    assert(strncmp(name, \"_multianewarray\", 15) == 0, \"sanity\");\n+  }\n@@ -1624,10 +1645,9 @@\n-    \/\/ Non-escaped allocation returned from Java or runtime call have\n-    \/\/ unknown values in fields.\n-    for (EdgeIterator i(pta); i.has_next(); i.next()) {\n-      PointsToNode* field = i.get();\n-      if (field->is_Field() && field->as_Field()->is_oop()) {\n-        if (add_edge(field, phantom_obj)) {\n-          \/\/ New edge was added\n-          new_edges++;\n-          add_field_uses_to_worklist(field->as_Field());\n-        }\n+  \/\/ Non-escaped allocation returned from Java or runtime call have unknown values in fields.\n+  int new_edges = 0;\n+  for (EdgeIterator i(pta); i.has_next(); i.next()) {\n+    PointsToNode* field = i.get();\n+    if (field->is_Field() && field->as_Field()->is_oop()) {\n+      if (add_edge(field, phantom_obj)) {\n+        \/\/ New edge was added\n+        new_edges++;\n+        add_field_uses_to_worklist(field->as_Field());\n@@ -1636,1 +1656,0 @@\n-    return new_edges;\n@@ -1638,1 +1657,7 @@\n-  assert(init_val == null_obj, \"sanity\");\n+  return new_edges;\n+}\n+\n+\/\/ Find fields initializing values for allocations.\n+int ConnectionGraph::find_init_values_null(JavaObjectNode* pta, PhaseTransform* phase) {\n+  assert(pta->escape_state() == PointsToNode::NoEscape, \"Not escaped Allocate nodes only\");\n+  Node* alloc = pta->ideal_node();\n@@ -1640,1 +1665,1 @@\n-  if (!alloc->is_Allocate())\n+  if (!alloc->is_Allocate()) {\n@@ -1642,1 +1667,1 @@\n-\n+  }\n@@ -1646,0 +1671,1 @@\n+  int new_edges = 0;\n@@ -1654,1 +1680,1 @@\n-    if (!field->is_Field() || !field->as_Field()->is_oop())\n+    if (!field->is_Field() || !field->as_Field()->is_oop()) {\n@@ -1656,0 +1682,1 @@\n+    }\n@@ -1762,3 +1789,0 @@\n-  \/\/ 1. An object is not scalar replaceable if the field into which it is\n-  \/\/ stored has unknown offset (stored into unknown element of an array).\n-  \/\/\n@@ -1773,0 +1797,2 @@\n+      \/\/ 1. An object is not scalar replaceable if the field into which it is\n+      \/\/ stored has unknown offset (stored into unknown element of an array).\n@@ -1878,1 +1904,1 @@\n-                         GrowableArray<JavaObjectNode*>& non_escaped_worklist,\n+                         GrowableArray<JavaObjectNode*>& non_escaped_allocs_worklist,\n@@ -1883,1 +1909,1 @@\n-  int non_escaped_length  = non_escaped_worklist.length();\n+  int non_escaped_length  = non_escaped_allocs_worklist.length();\n@@ -1891,3 +1917,3 @@\n-  int length = non_escaped_worklist.length();\n-  find_non_escaped_objects(ptnodes_worklist, non_escaped_worklist);\n-  assert((non_escaped_length == non_escaped_worklist.length()) &&\n+  int length = non_escaped_allocs_worklist.length();\n+  find_non_escaped_objects(ptnodes_worklist, non_escaped_allocs_worklist);\n+  assert((non_escaped_length == non_escaped_allocs_worklist.length()) &&\n@@ -1954,1 +1980,1 @@\n-    for( int i=0; i < cnt; i++ ) {\n+    for (int i = 0; i < cnt; i++) {\n@@ -1975,8 +2001,5 @@\n-    \/\/ Add ConI(#CC_GT) and ConI(#CC_EQ).\n-    _pcmp_neq = igvn->makecon(TypeInt::CC_GT);\n-    _pcmp_eq = igvn->makecon(TypeInt::CC_EQ);\n-    \/\/ Optimize objects compare.\n-    while (ptr_cmp_worklist.length() != 0) {\n-      Node *n = ptr_cmp_worklist.pop();\n-      Node *res = optimize_ptr_compare(n);\n-      if (res != NULL) {\n+    for (int i = 0; i < ptr_cmp_worklist.length(); i++) {\n+      Node *n = ptr_cmp_worklist.at(i);\n+      const TypeInt* tcmp = optimize_ptr_compare(n);\n+      if (tcmp->singleton()) {\n+        Node* cmp = igvn->makecon(tcmp);\n@@ -1985,1 +2008,1 @@\n-          tty->print_cr(\"++++ Replaced: %d %s(%d,%d) --> %s\", n->_idx, (n->Opcode() == Op_CmpP ? \"CmpP\" : \"CmpN\"), n->in(1)->_idx, n->in(2)->_idx, (res == _pcmp_eq ? \"EQ\" : \"NotEQ\"));\n+          tty->print_cr(\"++++ Replaced: %d %s(%d,%d) --> %s\", n->_idx, (n->Opcode() == Op_CmpP ? \"CmpP\" : \"CmpN\"), n->in(1)->_idx, n->in(2)->_idx, (tcmp == TypeInt::CC_EQ ? \"EQ\" : \"NotEQ\"));\n@@ -1991,1 +2014,1 @@\n-        igvn->replace_node(n, res);\n+        igvn->replace_node(n, cmp);\n@@ -1994,5 +2017,0 @@\n-    \/\/ cleanup\n-    if (_pcmp_neq->outcnt() == 0)\n-      igvn->hash_delete(_pcmp_neq);\n-    if (_pcmp_eq->outcnt()  == 0)\n-      igvn->hash_delete(_pcmp_eq);\n@@ -2004,4 +2022,4 @@\n-  while (storestore_worklist.length() != 0) {\n-    Node *n = storestore_worklist.pop();\n-    MemBarStoreStoreNode *storestore = n ->as_MemBarStoreStore();\n-    Node *alloc = storestore->in(MemBarNode::Precedent)->in(0);\n+  for (int i = 0; i < storestore_worklist.length(); i++) {\n+    Node* storestore = storestore_worklist.at(i);\n+    assert(storestore->is_MemBarStoreStore(), \"\");\n+    Node* alloc = storestore->in(MemBarNode::Precedent)->in(0);\n@@ -2010,1 +2028,1 @@\n-      mb->init_req(TypeFunc::Memory, storestore->in(TypeFunc::Memory));\n+      mb->init_req(TypeFunc::Memory,  storestore->in(TypeFunc::Memory));\n@@ -2019,1 +2037,1 @@\n-Node* ConnectionGraph::optimize_ptr_compare(Node* n) {\n+const TypeInt* ConnectionGraph::optimize_ptr_compare(Node* n) {\n@@ -2021,0 +2039,4 @@\n+  const TypeInt* EQ = TypeInt::CC_EQ; \/\/ [0] == ZERO\n+  const TypeInt* NE = TypeInt::CC_GT; \/\/ [1] == ONE\n+  const TypeInt* UNKNOWN = TypeInt::CC;    \/\/ [-1, 0,1]\n+\n@@ -2033,1 +2055,1 @@\n-        return _pcmp_eq;\n+        return EQ;\n@@ -2039,1 +2061,1 @@\n-        return _pcmp_neq; \/\/ This includes nullness check.\n+        return NE; \/\/ This includes nullness check.\n@@ -2049,1 +2071,1 @@\n-        return _pcmp_neq; \/\/ This includes nullness check.\n+        return NE; \/\/ This includes nullness check.\n@@ -2062,1 +2084,1 @@\n-      return _pcmp_eq;\n+      return EQ;\n@@ -2064,1 +2086,1 @@\n-      return _pcmp_neq;\n+      return NE;\n@@ -2068,1 +2090,1 @@\n-    return NULL; \/\/ Sets are not disjoint\n+    return UNKNOWN; \/\/ Sets are not disjoint\n@@ -2079,1 +2101,1 @@\n-    return NULL;\n+    return UNKNOWN;\n@@ -2088,1 +2110,1 @@\n-      return _pcmp_neq;\n+      return NE;\n@@ -2093,1 +2115,1 @@\n-      return _pcmp_neq;\n+      return NE;\n@@ -2096,1 +2118,1 @@\n-  return NULL;\n+  return UNKNOWN;\n@@ -2099,1 +2121,1 @@\n-\/\/ Connection Graph constuction functions.\n+\/\/ Connection Graph construction functions.\n@@ -2109,1 +2131,1 @@\n-  _nodes.at_put(n->_idx, ptadr);\n+  map_ideal_node(n, ptadr);\n@@ -2120,1 +2142,1 @@\n-  _nodes.at_put(n->_idx, ptadr);\n+  map_ideal_node(n, ptadr);\n@@ -2136,1 +2158,1 @@\n-  _nodes.at_put(n->_idx, field);\n+  map_ideal_node(n, field);\n@@ -2150,1 +2172,1 @@\n-  _nodes.at_put(n->_idx, ptadr);\n+  map_ideal_node(n, ptadr);\n@@ -2212,1 +2234,1 @@\n-  assert(!_collecting, \"should not call when contructed graph\");\n+  assert(!_collecting, \"should not call when constructed graph\");\n@@ -2280,1 +2302,1 @@\n-  if (es >= PointsToNode::GlobalEscape)\n+  if (es >= PointsToNode::GlobalEscape) {\n@@ -2282,0 +2304,1 @@\n+  }\n@@ -2288,1 +2311,1 @@\n-    if (i.get()->escape_state() >= PointsToNode::GlobalEscape)\n+    if (i.get()->escape_state() >= PointsToNode::GlobalEscape) {\n@@ -2290,0 +2313,1 @@\n+    }\n@@ -2304,1 +2328,1 @@\n-    if (i.get() == ptn)\n+    if (i.get() == ptn) {\n@@ -2306,0 +2330,1 @@\n+    }\n@@ -2324,1 +2349,1 @@\n-      if (this_e == ptn->edge(j))\n+      if (this_e == ptn->edge(j)) {\n@@ -2326,0 +2351,1 @@\n+      }\n@@ -2335,1 +2361,1 @@\n-    if (i.get() == jobj)\n+    if (i.get() == jobj) {\n@@ -2337,0 +2363,1 @@\n+    }\n@@ -2807,1 +2834,1 @@\n-  if (orig_mem == NULL)\n+  if (orig_mem == NULL) {\n@@ -2809,0 +2836,1 @@\n+  }\n@@ -2818,1 +2846,1 @@\n-    if (result == start_mem)\n+    if (result == start_mem) {\n@@ -2820,0 +2848,1 @@\n+    }\n@@ -2822,1 +2851,1 @@\n-      if (at == Type::TOP)\n+      if (at == Type::TOP) {\n@@ -2824,0 +2853,1 @@\n+      }\n@@ -2826,1 +2856,1 @@\n-      if (idx == alias_idx)\n+      if (idx == alias_idx) {\n@@ -2828,0 +2858,1 @@\n+      }\n@@ -2834,1 +2865,1 @@\n-    if (!is_instance)\n+    if (!is_instance) {\n@@ -2836,0 +2867,1 @@\n+    }\n@@ -2951,1 +2983,1 @@\n-\/\/  Convert the types of unescaped object to instance types where possible,\n+\/\/  Convert the types of non-escaped object to instance types where possible,\n@@ -2979,1 +3011,1 @@\n-\/\/ results and the allocation of node 29 is unescaped and eligible to be an\n+\/\/ results and the allocation of node 29 is non-escaped and eligible to be an\n@@ -3064,2 +3096,2 @@\n-      \/\/ see if it is unescaped.\n-      if (es != PointsToNode::NoEscape || !ptn->scalar_replaceable())\n+      \/\/ see if it is non-escaped.\n+      if (es != PointsToNode::NoEscape || !ptn->scalar_replaceable()) {\n@@ -3067,0 +3099,1 @@\n+      }\n@@ -3113,1 +3146,1 @@\n-      if (t == NULL)\n+      if (t == NULL) {\n@@ -3115,1 +3148,2 @@\n-      if (!t->klass_is_exact())\n+      }\n+      if (!t->klass_is_exact()) {\n@@ -3117,1 +3151,1 @@\n-\n+      }\n@@ -3354,1 +3388,1 @@\n-    if (visited.test_set(n->_idx))\n+    if (visited.test_set(n->_idx)) {\n@@ -3356,0 +3390,1 @@\n+    }\n@@ -3361,1 +3396,1 @@\n-      if (n == NULL)\n+      if (n == NULL) {\n@@ -3363,0 +3398,1 @@\n+      }\n@@ -3372,1 +3408,1 @@\n-      if (addr_t == Type::TOP)\n+      if (addr_t == Type::TOP) {\n@@ -3374,0 +3410,1 @@\n+      }\n@@ -3400,1 +3437,1 @@\n-        if (use->Opcode() == Op_StoreCM) \/\/ Ignore cardmark stores\n+        if (use->Opcode() == Op_StoreCM) { \/\/ Ignore cardmark stores\n@@ -3402,0 +3439,1 @@\n+        }\n@@ -3452,1 +3490,1 @@\n-      if (mem == NULL || mem->is_top())\n+      if (mem == NULL || mem->is_top()) {\n@@ -3454,0 +3492,1 @@\n+      }\n@@ -3462,1 +3501,1 @@\n-            if (cur == NULL)\n+            if (cur == NULL) {\n@@ -3464,0 +3503,1 @@\n+            }\n@@ -3510,1 +3550,1 @@\n-  \/\/ to recursively process Phi's encounted on the input memory\n+  \/\/ to recursively process Phi's encountered on the input memory\n@@ -3599,1 +3639,1 @@\n-    if (nt == PointsToNode::JavaObject && !this->scalar_replaceable())\n+    if (nt == PointsToNode::JavaObject && !this->scalar_replaceable()) {\n@@ -3601,0 +3641,1 @@\n+    }\n@@ -3604,1 +3645,1 @@\n-    if (f->is_oop())\n+    if (f->is_oop()) {\n@@ -3606,1 +3647,2 @@\n-    if (f->offset() > 0)\n+    }\n+    if (f->offset() > 0) {\n@@ -3608,0 +3650,1 @@\n+    }\n@@ -3631,1 +3674,1 @@\n-  if (_node == NULL)\n+  if (_node == NULL) {\n@@ -3633,1 +3676,1 @@\n-  else\n+  } else {\n@@ -3635,0 +3678,1 @@\n+  }\n@@ -3642,1 +3686,1 @@\n-    if (ptn == NULL || !ptn->is_JavaObject())\n+    if (ptn == NULL || !ptn->is_JavaObject()) {\n@@ -3644,0 +3688,1 @@\n+    }\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":206,"deletions":161,"binary":false,"changes":367,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -78,1 +78,1 @@\n-\/\/     Proj#5 (value returned from callnodes including allocations)\n+\/\/     Proj#5 (value returned from call nodes including allocations)\n@@ -203,2 +203,2 @@\n-  void set_scalar_replaceable(bool v) {\n-    if (v)\n+  void set_scalar_replaceable(bool set) {\n+    if (set) {\n@@ -206,1 +206,1 @@\n-    else\n+    } else {\n@@ -208,0 +208,1 @@\n+    }\n@@ -212,1 +213,1 @@\n-  bool add_edge(PointsToNode* edge)    { return _edges.append_if_missing(edge); }\n+  bool add_edge(PointsToNode* edge)   { return _edges.append_if_missing(edge); }\n@@ -216,1 +217,1 @@\n-  bool add_use(PointsToNode* use)    { return _uses.append_if_missing(use); }\n+  bool add_use(PointsToNode* use)   { return _uses.append_if_missing(use); }\n@@ -249,1 +250,1 @@\n-      if (es > NoEscape)\n+      if (es > NoEscape) {\n@@ -251,0 +252,1 @@\n+      }\n@@ -260,4 +262,1 @@\n-  FieldNode(ConnectionGraph *CG, Node* n, EscapeState es, int offs, bool is_oop):\n-    PointsToNode(CG, n, es, Field),\n-    _offset(offs), _is_oop(is_oop),\n-    _has_unknown_base(false) {}\n+  inline FieldNode(ConnectionGraph *CG, Node* n, EscapeState es, int offs, bool is_oop);\n@@ -321,1 +320,2 @@\n-  friend class PointsToNode;\n+  friend class PointsToNode; \/\/ to access _compile\n+  friend class FieldNode;\n@@ -337,2 +337,0 @@\n-  Node*             _pcmp_neq; \/\/ ConI(#CC_GT)\n-  Node*              _pcmp_eq; \/\/ ConI(#CC_EQ)\n@@ -345,0 +343,3 @@\n+  int        _build_iterations; \/\/ Number of iterations took to build graph\n+  double           _build_time; \/\/ Time (sec) took to build graph\n+\n@@ -426,1 +427,2 @@\n-  int find_init_values(JavaObjectNode* ptn, PointsToNode* init_val, PhaseTransform* phase);\n+  int find_init_values_null   (JavaObjectNode* ptn, PhaseTransform* phase);\n+  int find_init_values_phantom(JavaObjectNode* ptn);\n@@ -432,1 +434,1 @@\n-      if (ptn->escape_state() < esc)\n+      if (ptn->escape_state() < esc) {\n@@ -434,1 +436,2 @@\n-      if (ptn->fields_escape_state() < esc)\n+      }\n+      if (ptn->fields_escape_state() < esc) {\n@@ -436,0 +439,1 @@\n+      }\n@@ -441,1 +445,1 @@\n-      if (ptn->fields_escape_state() < esc)\n+      if (ptn->fields_escape_state() < esc) {\n@@ -443,0 +447,1 @@\n+      }\n@@ -458,1 +463,1 @@\n-  Node* optimize_ptr_compare(Node* n);\n+  const TypeInt* optimize_ptr_compare(Node* n);\n@@ -497,1 +502,1 @@\n-      if (to == null_obj)\n+      if (to == null_obj) {\n@@ -499,0 +504,1 @@\n+      }\n@@ -517,2 +523,1 @@\n-  \/\/ Propagate unique types created for unescaped allocated objects\n-  \/\/ through the graph\n+  \/\/ Propagate unique types created for non-escaped allocated objects through the graph\n@@ -534,1 +539,1 @@\n-  Node_Array _node_map; \/\/ used for bookeeping during type splitting\n+  Node_Array _node_map; \/\/ used for bookkeeping during type splitting\n@@ -627,0 +632,7 @@\n+inline FieldNode::FieldNode(ConnectionGraph *CG, Node* n, EscapeState es, int offs, bool is_oop):\n+  PointsToNode(CG, n, es, Field),\n+  _bases(CG->_compile->comp_arena(), 2, 0, NULL),\n+  _offset(offs), _is_oop(is_oop),\n+  _has_unknown_base(false) {\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/escape.hpp","additions":36,"deletions":24,"binary":false,"changes":60,"status":"modified"}]}