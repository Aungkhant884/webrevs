{"files":[{"patch":"@@ -896,0 +896,3 @@\n+     * <p>\n+     * The non-sequenced map view is obtained by calling the abstract view()\n+     * method for each operation.\n@@ -901,3 +904,1 @@\n-        final Collection<E> view;\n-\n-        ViewCollection(Collection<E> view) { this.view = view; }\n+        abstract Collection<E> view();\n@@ -907,19 +908,18 @@\n-        public void clear() { view.clear(); }\n-        public boolean contains(Object o) { return view.contains(o); }\n-        public boolean containsAll(Collection<?> c) { return view.containsAll(c); }\n-        public boolean equals(Object o) { return view.equals(o); }\n-        public void forEach(Consumer<? super E> c) { view.forEach(c); }\n-        public int hashCode() { return view.hashCode(); }\n-        public boolean isEmpty() { return view.isEmpty(); }\n-        public Iterator<E> iterator() { return view.iterator(); }\n-        public Stream<E> parallelStream() { return view.parallelStream(); }\n-        public boolean remove(Object o) { return view.remove(o); }\n-        public boolean removeAll(Collection<?> c) { return view.removeAll(c); }\n-        public boolean removeIf(Predicate<? super E> filter) { return view.removeIf(filter); }\n-        public boolean retainAll(Collection<?> c) { return view.retainAll(c); }\n-        public int size() { return view.size(); }\n-        public Spliterator<E> spliterator() { return view.spliterator(); }\n-        public Stream<E> stream() { return view.stream(); }\n-        public Object[] toArray() { return view.toArray(); }\n-        public <T> T[] toArray(IntFunction<T[]> generator) { return view.toArray(generator); }\n-        public <T> T[] toArray(T[] a) { return view.toArray(a); }\n+        public void clear() { view().clear(); }\n+        public boolean contains(Object o) { return view().contains(o); }\n+        public boolean containsAll(Collection<?> c) { return view().containsAll(c); }\n+        public void forEach(Consumer<? super E> c) { view().forEach(c); }\n+        public boolean isEmpty() { return view().isEmpty(); }\n+        public Iterator<E> iterator() { return view().iterator(); }\n+        public Stream<E> parallelStream() { return view().parallelStream(); }\n+        public boolean remove(Object o) { return view().remove(o); }\n+        public boolean removeAll(Collection<?> c) { return view().removeAll(c); }\n+        public boolean removeIf(Predicate<? super E> filter) { return view().removeIf(filter); }\n+        public boolean retainAll(Collection<?> c) { return view().retainAll(c); }\n+        public int size() { return view().size(); }\n+        public Spliterator<E> spliterator() { return view().spliterator(); }\n+        public Stream<E> stream() { return view().stream(); }\n+        public Object[] toArray() { return view().toArray(); }\n+        public <T> T[] toArray(IntFunction<T[]> generator) { return view().toArray(generator); }\n+        public <T> T[] toArray(T[] a) { return view().toArray(a); }\n+        public String toString() { return view().toString(); }\n","filename":"src\/java.base\/share\/classes\/java\/util\/AbstractMap.java","additions":22,"deletions":22,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -260,1 +260,1 @@\n-     * Returns a {@link SequencedSet} view of this map's keySet.\n+     * Returns a {@code SequencedSet} view of this map's {@link #keySet keySet}.\n@@ -263,5 +263,7 @@\n-     * The implementation in this interface returns a {@code SequencedSet}\n-     * implementation that delegates all operations either to this map or to this map's\n-     * {@link #keySet}, except for its {@link SequencedSet#reversed reversed} method,\n-     * which instead returns the result of calling {@code sequencedKeySet} on this map's\n-     * reverse-ordered view.\n+     * The implementation in this interface returns a {@code SequencedSet} instance\n+     * that behaves as follows. Its {@link SequencedSet#add add} and {@link\n+     * SequencedSet#addAll addAll} methods throw {@link UnsupportedOperationException}.\n+     * Its {@link SequencedSet#reversed reversed} method returns the {@link\n+     * #sequencedKeySet sequencedKeySet} view of the {@link #reversed reversed} view of\n+     * this map. Each of its other methods calls the corresponding method of the {@link\n+     * #keySet keySet} view of this map.\n@@ -269,1 +271,1 @@\n-     * @return a SequencedSet view of this map's keySet\n+     * @return a {@code SequencedSet} view of this map's {@code keySet}\n@@ -273,2 +275,2 @@\n-            SeqKeySet() {\n-                super(SequencedMap.this.keySet());\n+            Collection<K> view() {\n+                return SequencedMap.this.keySet();\n@@ -279,0 +281,6 @@\n+            public boolean equals(Object other) {\n+                return view().equals(other);\n+            }\n+            public int hashCode() {\n+                return view().hashCode();\n+            }\n@@ -284,1 +292,1 @@\n-     * Returns a {@link SequencedCollection} view of this map's values collection.\n+     * Returns a {@code SequencedCollection} view of this map's {@link #values values} collection.\n@@ -287,5 +295,8 @@\n-     * The implementation in this interface returns a {@code SequencedCollection}\n-     * implementation that delegates all operations either to this map or to this map's\n-     * {@link #values} collection, except for its {@link SequencedCollection#reversed reversed}\n-     * method, which instead returns the result of calling {@code sequencedValues} on this map's\n-     * reverse-ordered view.\n+     * The implementation in this interface returns a {@code SequencedCollection} instance\n+     * that behaves as follows. Its {@link SequencedCollection#add add} and {@link\n+     * SequencedCollection#addAll addAll} methods throw {@link UnsupportedOperationException}.\n+     * Its {@link SequencedCollection#reversed reversed} method returns the {@link\n+     * #sequencedValues sequencedValues} view of the {@link #reversed reversed} view of\n+     * this map. Its {@link Object#equals equals} and {@link Object#hashCode hashCode} methods\n+     * are inherited from {@link Object}. Each of its other methods calls the corresponding\n+     * method of the {@link #values values} view of this map.\n@@ -293,1 +304,1 @@\n-     * @return a SequencedCollection view of this map's values collection\n+     * @return a {@code SequencedCollection} view of this map's {@code values} collection\n@@ -297,2 +308,2 @@\n-            SeqValues() {\n-                super(SequencedMap.this.values());\n+            Collection<V> view() {\n+                return SequencedMap.this.values();\n@@ -308,1 +319,1 @@\n-     * Returns a {@link SequencedSet} view of this map's entrySet.\n+     * Returns a {@code SequencedSet} view of this map's {@link #entrySet entrySet}.\n@@ -311,5 +322,7 @@\n-     * The implementation in this interface returns a {@code SequencedSet}\n-     * implementation that delegates all operations either to this map or to this map's\n-     * {@link #entrySet}, except for its {@link SequencedSet#reversed reversed} method,\n-     * which instead returns the result of calling {@code sequencedEntrySet} on this map's\n-     * reverse-ordered view.\n+     * The implementation in this interface returns a {@code SequencedSet} instance\n+     * that behaves as follows. Its {@link SequencedSet#add add} and {@link\n+     * SequencedSet#addAll addAll} methods throw {@link UnsupportedOperationException}.\n+     * Its {@link SequencedSet#reversed reversed} method returns the {@link\n+     * #sequencedEntrySet sequencedEntrySet} view of the {@link #reversed reversed} view of\n+     * this map. Each of its other methods calls the corresponding method of the {@link\n+     * #entrySet entrySet} view of this map.\n@@ -317,1 +330,1 @@\n-     * @return a SequencedSet view of this map's entrySet\n+     * @return a {@code SequencedSet} view of this map's {@code entrySet}\n@@ -322,2 +335,2 @@\n-            SeqEntrySet() {\n-                super(SequencedMap.this.entrySet());\n+            Collection<Map.Entry<K, V>> view() {\n+                return SequencedMap.this.entrySet();\n@@ -328,0 +341,6 @@\n+            public boolean equals(Object other) {\n+                return view().equals(other);\n+            }\n+            public int hashCode() {\n+                return view().hashCode();\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/util\/SequencedMap.java","additions":46,"deletions":27,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -390,0 +390,14 @@\n+\n+        assertEquals(map.keySet().hashCode(), rmap.keySet().hashCode());\n+        assertEquals(map.keySet().hashCode(), map.sequencedKeySet().hashCode());\n+        assertEquals(rmap.keySet().hashCode(), rmap.sequencedKeySet().hashCode());\n+\n+        \/\/ Don't use assertEquals(), as we really want to test the equals() methods.\n+        assertTrue(map.keySet().equals(map.sequencedKeySet()));\n+        assertTrue(map.sequencedKeySet().equals(map.keySet()));\n+        assertTrue(rmap.keySet().equals(map.sequencedKeySet()));\n+        assertTrue(rmap.sequencedKeySet().equals(map.keySet()));\n+        assertTrue(map.keySet().equals(rmap.sequencedKeySet()));\n+        assertTrue(map.sequencedKeySet().equals(rmap.keySet()));\n+        assertTrue(rmap.keySet().equals(rmap.sequencedKeySet()));\n+        assertTrue(rmap.sequencedKeySet().equals(rmap.keySet()));\n@@ -415,0 +429,15 @@\n+\n+        \/\/ No assertions over hashCode(), as Collection inherits Object.hashCode\n+        \/\/ which is usually but not guaranteed to give unequal results.\n+\n+        \/\/ It's permissible for an implementation to return the same instance for values()\n+        \/\/ as for sequencedValues(). Either they're the same instance, or they must be\n+        \/\/ unequal, because distinct collections should always be unequal.\n+\n+        var v = map.values();\n+        var sv = map.sequencedValues();\n+        assertTrue((v == sv) || ! (v.equals(sv) || sv.equals(v)));\n+\n+        var rv = rmap.values();\n+        var rsv = rmap.sequencedValues();\n+        assertTrue((rv == rsv) || ! (rv.equals(rsv) || rsv.equals(rv)));\n@@ -439,0 +468,13 @@\n+\n+        assertEquals(map.entrySet().hashCode(), rmap.entrySet().hashCode());\n+        assertEquals(map.entrySet().hashCode(), map.sequencedEntrySet().hashCode());\n+        assertEquals(map.sequencedEntrySet().hashCode(), map.entrySet().hashCode());\n+\n+        assertTrue(map.entrySet().equals(map.sequencedEntrySet()));\n+        assertTrue(map.sequencedEntrySet().equals(map.entrySet()));\n+        assertTrue(rmap.entrySet().equals(map.sequencedEntrySet()));\n+        assertTrue(rmap.sequencedEntrySet().equals(map.entrySet()));\n+        assertTrue(map.entrySet().equals(rmap.sequencedEntrySet()));\n+        assertTrue(map.sequencedEntrySet().equals(rmap.entrySet()));\n+        assertTrue(rmap.entrySet().equals(rmap.sequencedEntrySet()));\n+        assertTrue(rmap.sequencedEntrySet().equals(rmap.entrySet()));\n","filename":"test\/jdk\/java\/util\/SequencedCollection\/BasicMap.java","additions":42,"deletions":0,"binary":false,"changes":42,"status":"modified"}]}