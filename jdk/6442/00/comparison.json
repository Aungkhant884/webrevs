{"files":[{"patch":"@@ -150,0 +150,1 @@\n+JVM_IsFinalizationEnabled\n","filename":"make\/data\/hotspot-symbols\/symbols-unix","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2838,1 +2838,2 @@\n-  if (name == vmSymbols::finalize_method_name() &&\n+  if (InstanceKlass::finalization_enabled() &&\n+      name == vmSymbols::finalize_method_name() &&\n@@ -4174,1 +4175,2 @@\n-  if (m != NULL && !m->is_empty_method()) {\n+  if (InstanceKlass::finalization_enabled() &&\n+      (m != NULL) && !m->is_empty_method()) {\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -762,0 +762,3 @@\n+JNIEXPORT jboolean JNICALL\n+JVM_IsFinalizationEnabled(JNIEnv *env);\n+\n","filename":"src\/hotspot\/share\/include\/jvm.h","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -144,0 +144,1 @@\n+bool InstanceKlass::_finalization_enabled = true;\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -332,0 +332,3 @@\n+  \/\/ Controls finalizer registration\n+  static bool _finalization_enabled;\n+\n@@ -333,0 +336,7 @@\n+\n+  \/\/ Queries finalization state\n+  static bool finalization_enabled() { return _finalization_enabled; }\n+\n+  \/\/ Sets finalization state\n+  static void set_finalization_enabled(bool val) { _finalization_enabled = val; }\n+\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -693,0 +693,4 @@\n+JVM_ENTRY(jboolean, JVM_IsFinalizationEnabled(JNIEnv * env))\n+return InstanceKlass::finalization_enabled() ? JNI_TRUE : JNI_FALSE;\n+JVM_END\n+\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2869,0 +2869,11 @@\n+    } else if (match_option(option, \"--finalization=\", &tail)) {\n+      if (strcmp(tail, \"enabled\") == 0) {\n+        InstanceKlass::set_finalization_enabled(true);\n+      } else if (strcmp(tail, \"disabled\") == 0) {\n+        InstanceKlass::set_finalization_enabled(false);\n+      } else {\n+        jio_fprintf(defaultStream::error_stream(),\n+                    \"Invalid finalization value '%s', must be 'disabled' or 'enabled'.\\n\",\n+                    tail);\n+        return JNI_EINVAL;\n+      }\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -64,0 +64,6 @@\n+    static class Holder {\n+        static final boolean ENABLED = isFinalizationEnabled();\n+    }\n+\n+    private static native boolean isFinalizationEnabled();\n+\n@@ -66,1 +72,5 @@\n-        new Finalizer(finalizee);\n+        if (Holder.ENABLED) {\n+            new Finalizer(finalizee);\n+        } else {\n+            throw new InternalError(\"unexpected call to Finalizer::register when finalization is disabled\");\n+        }\n@@ -133,1 +143,1 @@\n-        if (VM.initLevel() == 0) {\n+        if (VM.initLevel() == 0 || ! Holder.ENABLED) {\n@@ -185,8 +195,10 @@\n-        ThreadGroup tg = Thread.currentThread().getThreadGroup();\n-        for (ThreadGroup tgn = tg;\n-             tgn != null;\n-             tg = tgn, tgn = tg.getParent());\n-        Thread finalizer = new FinalizerThread(tg);\n-        finalizer.setPriority(Thread.MAX_PRIORITY - 2);\n-        finalizer.setDaemon(true);\n-        finalizer.start();\n+        if (Holder.ENABLED) {\n+            ThreadGroup tg = Thread.currentThread().getThreadGroup();\n+            for (ThreadGroup tgn = tg;\n+                 tgn != null;\n+                 tg = tgn, tgn = tg.getParent());\n+            Thread finalizer = new FinalizerThread(tg);\n+            finalizer.setPriority(Thread.MAX_PRIORITY - 2);\n+            finalizer.setDaemon(true);\n+            finalizer.start();\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ref\/Finalizer.java","additions":22,"deletions":10,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -197,1 +197,4 @@\n-\\                      set the version of the source in source-file mode.\\n\\n\\\n+\\                      set the version of the source in source-file mode.\\n\\\n+\\    --finalization=<value>\\n\\\n+\\                      controls finalization\\n\\\n+\\                      <value> is one of \"enabled\" or \"disabled\"\\n\\n\\\n","filename":"src\/java.base\/share\/classes\/sun\/launcher\/resources\/launcher.properties","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -35,1 +35,4 @@\n-\n+JNIEXPORT jboolean JNICALL\n+Java_java_lang_ref_Finalizer_isFinalizationEnabled(JNIEnv* env, jclass cls) {\n+    return JVM_IsFinalizationEnabled(env);\n+}\n","filename":"src\/java.base\/share\/native\/libjava\/Finalizer.c","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,122 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8276422\n+ * @summary add command-line option to disable finalization\n+ * @run main\/othervm                         FinalizationOption yes\n+ * @run main\/othervm --finalization=enabled  FinalizationOption yes\n+ * @run main\/othervm --finalization=disabled FinalizationOption no\n+ *\/\n+public class FinalizationOption {\n+    static volatile boolean finalizerWasCalled = false;\n+\n+    @SuppressWarnings(\"deprecation\")\n+    protected void finalize() {\n+        finalizerWasCalled = true;\n+    }\n+\n+    static void create() {\n+        new FinalizationOption();\n+    }\n+\n+    \/**\n+     * Checks whether the finalizer thread is or is not running. The finalizer thread\n+     * is a thread in the root thread group whose named is \"Finalizer\".\n+     * @param expected boolean indicating whether a finalizer thread should exist\n+     * @return boolean indicating whether the expectation was met\n+     *\/\n+    static boolean checkFinalizerThread(boolean expected) {\n+        ThreadGroup root = Thread.currentThread().getThreadGroup();\n+        for (ThreadGroup parent = root;\n+             parent != null;\n+             root = parent, parent = root.getParent())\n+            ;\n+\n+        int nt = 100;\n+        Thread[] threads;\n+        while (true) {\n+            threads = new Thread[nt];\n+            nt = root.enumerate(threads);\n+            if (nt < threads.length)\n+                break;\n+            threads = new Thread[nt + 100];\n+        }\n+\n+        Thread ft = null;\n+        for (int i = 0; i < nt; i++) {\n+            if (\"Finalizer\".equals(threads[i].getName())) {\n+                ft = threads[i];\n+                break;\n+            }\n+        }\n+\n+        String msg = (ft == null) ? \"(none)\" : ft.toString();\n+        boolean passed = (ft != null) == expected;\n+        System.out.printf(\"Finalizer thread.    Expected: %s   Actual: %s   %s%n\",\n+            expected, msg, passed ? \"Passed.\" : \"FAILED!\");\n+        return passed;\n+    }\n+\n+    \/**\n+     * Checks whether there was a call to the finalize() method.\n+     * @param expected boolean whether finalize() should be called\n+     * @return boolean indicating whether the expecation was met\n+     *\/\n+    static boolean checkFinalizerCalled(boolean expected) {\n+        create();\n+        for (int i = 0; i < 100; i++) {\n+            System.gc();\n+            try {\n+                Thread.sleep(10L);\n+            } catch (InterruptedException ie) {\n+                Thread.currentThread().interrupt();\n+            }\n+            if (finalizerWasCalled) {\n+                break;\n+            }\n+        }\n+        boolean passed = (expected == finalizerWasCalled);\n+        System.out.printf(\"Call to finalize().  Expected: %s   Actual: %s   %s%n\",\n+            expected, finalizerWasCalled,\n+            passed ? \"Passed.\" : \"FAILED!\");\n+        return passed;\n+    }\n+\n+    public static void main(String[] args) {\n+        boolean finalizationEnabled = switch (args[0]) {\n+            case \"yes\" -> true;\n+            case \"no\"  -> false;\n+            default -> {\n+                throw new AssertionError(\"usage: FinalizationOption yes|no\");\n+            }\n+        };\n+\n+        boolean threadPass = checkFinalizerThread(finalizationEnabled);\n+        boolean calledPass = checkFinalizerCalled(finalizationEnabled);\n+\n+        if (!threadPass || !calledPass)\n+            throw new AssertionError(\"Test failed.\");\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/Object\/FinalizationOption.java","additions":122,"deletions":0,"binary":false,"changes":122,"status":"added"},{"patch":"@@ -0,0 +1,52 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8276422\n+ * @summary Invalid\/missing values for the finalization option should be rejected\n+ * @library \/test\/lib\n+ * @run driver InvalidFinalizationOption\n+ *\/\n+\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+public class InvalidFinalizationOption {\n+    public static void main(String[] args) throws Exception {\n+        record TestData(String arg, String expected) { }\n+\n+        TestData[] testData = {\n+            new TestData(\"--finalization\",        \"Unrecognized option\"),\n+            new TestData(\"--finalization=\",       \"Invalid finalization value\"),\n+            new TestData(\"--finalization=azerty\", \"Invalid finalization value\")\n+        };\n+\n+        for (var data : testData) {\n+            ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(data.arg);\n+            OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+            output.shouldContain(data.expected);\n+            output.shouldHaveExitValue(1);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/Object\/InvalidFinalizationOption.java","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -37,0 +37,1 @@\n+ * @bug 8266936 8276422\n@@ -42,0 +43,1 @@\n+ * @run main\/othervm -Xlog:class+unload,finalizer -Xmx16m --finalization=disabled jdk.jfr.event.runtime.TestFinalizerStatisticsEvent disabled\n@@ -48,0 +50,1 @@\n+    private static boolean disabled = false;\n@@ -55,0 +58,4 @@\n+        if (args.length > 0 && \"disabled\".equals(args[0])) {\n+            disabled = true;\n+            System.out.println(\"Testing with finalization disabled\");\n+        }\n@@ -72,2 +79,6 @@\n-            verify(recording2);\n-            verify(recording1);\n+            if (disabled) {\n+                verifyDisabled(recording1);\n+            } else {\n+                verifyEnabled(recording2);\n+                verifyEnabled(recording1);\n+            }\n@@ -87,1 +98,2 @@\n-    private static void verify(Recording recording) throws Throwable {\n+    \/* Verify correct operation with finalization enabled *\/\n+    private static void verifyEnabled(Recording recording) throws Throwable {\n@@ -111,0 +123,13 @@\n+    \/* Verify no jdk.FinalizerStatistics events with finalization disabled *\/\n+    private static void verifyDisabled(Recording recording) throws Throwable {\n+        int f10nEvents = 0;\n+        List<RecordedEvent> events = Events.fromRecording(recording);\n+        for (RecordedEvent event : events) {\n+            System.out.println(\"Event:\" + event);\n+            if (\"jdk.FinalizerStatistics\".equals(event.getEventType().getName())) {\n+                f10nEvents++;\n+            }\n+        }\n+        Asserts.assertEquals(f10nEvents, 0, \"Finalization disabled, but recorded \" + f10nEvents + \" jdk.FinalizerStatistics events\");\n+    }\n+\n","filename":"test\/jdk\/jdk\/jfr\/event\/runtime\/TestFinalizerStatisticsEvent.java","additions":28,"deletions":3,"binary":false,"changes":31,"status":"modified"}]}