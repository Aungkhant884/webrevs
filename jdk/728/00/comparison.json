{"files":[{"patch":"@@ -548,5 +548,1 @@\n-int ZeroInterpreter::accessor_entry(Method* method, intptr_t UNUSED, TRAPS) {\n-  JavaThread *thread = THREAD->as_Java_thread();\n-  ZeroStack *stack = thread->zero_stack();\n-  intptr_t *locals = stack->sp();\n-\n+int ZeroInterpreter::getter_entry(Method* method, intptr_t UNUSED, TRAPS) {\n@@ -558,8 +554,1 @@\n-  \/\/ Load the object pointer and drop into the slow path\n-  \/\/ if we have a NullPointerException\n-  oop object = LOCALS_OBJECT(0);\n-  if (object == NULL) {\n-    return normal_entry(method, 0, THREAD);\n-  }\n-\n-  \/\/ Read the field index from the bytecode, which looks like this:\n+  \/\/ Read the field index from the bytecode:\n@@ -570,1 +559,2 @@\n-  \/\/  4:  ireturn\/areturn\/freturn\/lreturn\/dreturn\n+  \/\/  4:  return\n+  \/\/\n@@ -572,8 +562,3 @@\n-  u1 *code = method->code_base();\n-  assert(code[0] == Bytecodes::_aload_0 &&\n-         code[1] == Bytecodes::_getfield &&\n-         (code[4] == Bytecodes::_ireturn ||\n-          code[4] == Bytecodes::_freturn ||\n-          code[4] == Bytecodes::_lreturn ||\n-          code[4] == Bytecodes::_dreturn ||\n-          code[4] == Bytecodes::_areturn), \"should do\");\n+\n+  assert(method->is_getter(), \"Expect the particular bytecode shape\");\n+  u1* code = method->code_base();\n@@ -590,1 +575,13 @@\n-  \/\/ Get the result and push it onto the stack\n+  JavaThread* thread = THREAD->as_Java_thread();\n+  ZeroStack* stack = thread->zero_stack();\n+  intptr_t* topOfStack = stack->sp();\n+\n+  \/\/ Load the object pointer and drop into the slow path\n+  \/\/ if we have a NullPointerException\n+  oop object = STACK_OBJECT(0);\n+  if (object == NULL) {\n+    return normal_entry(method, 0, THREAD);\n+  }\n+\n+  \/\/ If needed, allocate additional slot on stack: we already have one\n+  \/\/ for receiver, and double\/long need another one.\n@@ -592,5 +589,6 @@\n-  case ltos:\n-  case dtos:\n-    stack->overflow_check(1, CHECK_0);\n-    stack->alloc(wordSize);\n-    break;\n+    case ltos:\n+    case dtos:\n+      stack->overflow_check(1, CHECK_0);\n+      stack->alloc(wordSize);\n+      topOfStack = stack->sp();\n+      break;\n@@ -598,0 +596,3 @@\n+\n+  \/\/ Read the field to stack(0)\n+  int offset = entry->f2_as_index();\n@@ -603,16 +604,27 @@\n-    case ctos:\n-      SET_LOCALS_INT(object->char_field_acquire(entry->f2_as_index()), 0);\n-      break;\n-\n-    case btos:\n-    case ztos:\n-      SET_LOCALS_INT(object->byte_field_acquire(entry->f2_as_index()), 0);\n-      break;\n-\n-    case stos:\n-      SET_LOCALS_INT(object->short_field_acquire(entry->f2_as_index()), 0);\n-      break;\n-\n-    case itos:\n-      SET_LOCALS_INT(object->int_field_acquire(entry->f2_as_index()), 0);\n-      break;\n+      case btos:\n+      case ztos: SET_STACK_INT(object->byte_field_acquire(offset),      0); break;\n+      case ctos: SET_STACK_INT(object->char_field_acquire(offset),      0); break;\n+      case stos: SET_STACK_INT(object->short_field_acquire(offset),     0); break;\n+      case itos: SET_STACK_INT(object->int_field_acquire(offset),       0); break;\n+      case ltos: SET_STACK_LONG(object->long_field_acquire(offset),     0); break;\n+      case ftos: SET_STACK_FLOAT(object->float_field_acquire(offset),   0); break;\n+      case dtos: SET_STACK_DOUBLE(object->double_field_acquire(offset), 0); break;\n+      case atos: SET_STACK_OBJECT(object->obj_field_acquire(offset),    0); break;\n+      default:\n+        ShouldNotReachHere();\n+    }\n+  } else {\n+    switch (entry->flag_state()) {\n+      case btos:\n+      case ztos: SET_STACK_INT(object->byte_field(offset),      0); break;\n+      case ctos: SET_STACK_INT(object->char_field(offset),      0); break;\n+      case stos: SET_STACK_INT(object->short_field(offset),     0); break;\n+      case itos: SET_STACK_INT(object->int_field(offset),       0); break;\n+      case ltos: SET_STACK_LONG(object->long_field(offset),     0); break;\n+      case ftos: SET_STACK_FLOAT(object->float_field(offset),   0); break;\n+      case dtos: SET_STACK_DOUBLE(object->double_field(offset), 0); break;\n+      case atos: SET_STACK_OBJECT(object->obj_field(offset),    0); break;\n+      default:\n+        ShouldNotReachHere();\n+    }\n+  }\n@@ -620,3 +632,3 @@\n-    case ltos:\n-      SET_LOCALS_LONG(object->long_field_acquire(entry->f2_as_index()), 0);\n-      break;\n+  \/\/ No deoptimized frames on the stack\n+  return 0;\n+}\n@@ -624,3 +636,5 @@\n-    case ftos:\n-      SET_LOCALS_FLOAT(object->float_field_acquire(entry->f2_as_index()), 0);\n-      break;\n+int ZeroInterpreter::setter_entry(Method* method, intptr_t UNUSED, TRAPS) {\n+  \/\/ Drop into the slow path if we need a safepoint check\n+  if (SafepointMechanism::should_process(THREAD)) {\n+    return normal_entry(method, 0, THREAD);\n+  }\n@@ -628,3 +642,9 @@\n-    case dtos:\n-      SET_LOCALS_DOUBLE(object->double_field_acquire(entry->f2_as_index()), 0);\n-      break;\n+  \/\/ Read the field index from the bytecode:\n+  \/\/  0:  aload_0\n+  \/\/  1:  *load_1\n+  \/\/  2:  putfield\n+  \/\/  3:    index\n+  \/\/  4:    index\n+  \/\/  5:  return\n+  \/\/\n+  \/\/ NB this is not raw bytecode: index is in machine order\n@@ -632,3 +652,3 @@\n-    case atos:\n-      SET_LOCALS_OBJECT(object->obj_field_acquire(entry->f2_as_index()), 0);\n-      break;\n+  assert(method->is_setter(), \"Expect the particular bytecode shape\");\n+  u1* code = method->code_base();\n+  u2 index = Bytes::get_native_u2(&code[3]);\n@@ -636,3 +656,6 @@\n-    default:\n-      ShouldNotReachHere();\n-    }\n+  \/\/ Get the entry from the constant pool cache, and drop into\n+  \/\/ the slow path if it has not been resolved\n+  ConstantPoolCache* cache = method->constants()->cache();\n+  ConstantPoolCacheEntry* entry = cache->entry_at(index);\n+  if (!entry->is_resolved(Bytecodes::_putfield)) {\n+    return normal_entry(method, 0, THREAD);\n@@ -640,5 +663,0 @@\n-  else {\n-    switch (entry->flag_state()) {\n-    case ctos:\n-      SET_LOCALS_INT(object->char_field(entry->f2_as_index()), 0);\n-      break;\n@@ -646,12 +664,3 @@\n-    case btos:\n-    case ztos:\n-      SET_LOCALS_INT(object->byte_field(entry->f2_as_index()), 0);\n-      break;\n-\n-    case stos:\n-      SET_LOCALS_INT(object->short_field(entry->f2_as_index()), 0);\n-      break;\n-\n-    case itos:\n-      SET_LOCALS_INT(object->int_field(entry->f2_as_index()), 0);\n-      break;\n+  JavaThread* thread = THREAD->as_Java_thread();\n+  ZeroStack* stack = thread->zero_stack();\n+  intptr_t* topOfStack = stack->sp();\n@@ -659,0 +668,4 @@\n+  \/\/ Figure out where the receiver is. If there is a long\/double\n+  \/\/ operand on stack top, then receiver is two slots down.\n+  oop object = NULL;\n+  switch (entry->flag_state()) {\n@@ -660,7 +673,0 @@\n-      SET_LOCALS_LONG(object->long_field(entry->f2_as_index()), 0);\n-      break;\n-\n-    case ftos:\n-      SET_LOCALS_FLOAT(object->float_field(entry->f2_as_index()), 0);\n-      break;\n-\n@@ -668,1 +674,1 @@\n-      SET_LOCALS_DOUBLE(object->double_field(entry->f2_as_index()), 0);\n+      object = STACK_OBJECT(-2);\n@@ -670,3 +676,2 @@\n-\n-    case atos:\n-      SET_LOCALS_OBJECT(object->obj_field(entry->f2_as_index()), 0);\n+    default:\n+      object = STACK_OBJECT(-1);\n@@ -674,0 +679,1 @@\n+  }\n@@ -675,2 +681,36 @@\n-    default:\n-      ShouldNotReachHere();\n+  \/\/ Load the receiver pointer and drop into the slow path\n+  \/\/ if we have a NullPointerException\n+  if (object == NULL) {\n+    return normal_entry(method, 0, THREAD);\n+  }\n+\n+  \/\/ Store the stack(0) to field\n+  int offset = entry->f2_as_index();\n+  if (entry->is_volatile()) {\n+    switch (entry->flag_state()) {\n+      case btos: object->release_byte_field_put(offset,   STACK_INT(0));     break;\n+      case ztos: object->release_byte_field_put(offset,   STACK_INT(0) & 1); break; \/\/ only store LSB\n+      case ctos: object->release_char_field_put(offset,   STACK_INT(0));     break;\n+      case stos: object->release_short_field_put(offset,  STACK_INT(0));     break;\n+      case itos: object->release_int_field_put(offset,    STACK_INT(0));     break;\n+      case ltos: object->release_long_field_put(offset,   STACK_LONG(0));    break;\n+      case ftos: object->release_float_field_put(offset,  STACK_FLOAT(0));   break;\n+      case dtos: object->release_double_field_put(offset, STACK_DOUBLE(0));  break;\n+      case atos: object->release_obj_field_put(offset,    STACK_OBJECT(0));  break;\n+      default:\n+        ShouldNotReachHere();\n+    }\n+    OrderAccess::storeload();\n+  } else {\n+    switch (entry->flag_state()) {\n+      case btos: object->byte_field_put(offset,   STACK_INT(0));     break;\n+      case ztos: object->byte_field_put(offset,   STACK_INT(0) & 1); break; \/\/ only store LSB\n+      case ctos: object->char_field_put(offset,   STACK_INT(0));     break;\n+      case stos: object->short_field_put(offset,  STACK_INT(0));     break;\n+      case itos: object->int_field_put(offset,    STACK_INT(0));     break;\n+      case ltos: object->long_field_put(offset,   STACK_LONG(0));    break;\n+      case ftos: object->float_field_put(offset,  STACK_FLOAT(0));   break;\n+      case dtos: object->double_field_put(offset, STACK_DOUBLE(0));  break;\n+      case atos: object->obj_field_put(offset,    STACK_OBJECT(0));  break;\n+      default:\n+        ShouldNotReachHere();\n@@ -680,0 +720,3 @@\n+  \/\/ Nothing is returned, pop out parameters\n+  stack->set_sp(stack->sp() + method->size_of_parameters());\n+\n","filename":"src\/hotspot\/cpu\/zero\/zeroInterpreter_zero.cpp","additions":132,"deletions":89,"binary":false,"changes":221,"status":"modified"},{"patch":"@@ -37,1 +37,2 @@\n-  static int accessor_entry(Method* method, intptr_t UNUSED, TRAPS);\n+  static int getter_entry(Method* method, intptr_t UNUSED, TRAPS);\n+  static int setter_entry(Method* method, intptr_t UNUSED, TRAPS);\n","filename":"src\/hotspot\/cpu\/zero\/zeroInterpreter_zero.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -188,1 +188,1 @@\n-  \/\/ Accessor method?\n+  \/\/ Getter method?\n@@ -190,5 +190,6 @@\n-    \/\/ TODO: We should have used ::is_accessor above, but fast accessors in Zero expect only getters.\n-    \/\/ See ZeroInterpreter::accessor_entry in zeroInterpreter_zero.cpp. This should be fixed in Zero,\n-    \/\/ then the call above updated to ::is_accessor\n-    assert(m->size_of_parameters() == 1, \"fast code for accessors assumes parameter size = 1\");\n-    return accessor;\n+    return getter;\n+  }\n+\n+  \/\/ Setter method?\n+  if (m->is_setter()) {\n+    return setter;\n@@ -295,1 +296,2 @@\n-    case accessor               : tty->print(\"accessor\"               ); break;\n+    case getter                 : tty->print(\"getter\"                 ); break;\n+    case setter                 : tty->print(\"setter\"                 ); break;\n","filename":"src\/hotspot\/share\/interpreter\/abstractInterpreter.cpp","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -63,1 +63,2 @@\n-    accessor,                                                   \/\/ accessor method (code: _aload_0, _getfield, _(a|i)return)\n+    getter,                                                     \/\/ getter method\n+    setter,                                                     \/\/ setter method\n","filename":"src\/hotspot\/share\/interpreter\/abstractInterpreter.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -195,1 +195,2 @@\n-  method_entry(accessor)\n+  method_entry(getter)\n+  method_entry(setter)\n@@ -417,1 +418,2 @@\n-  case Interpreter::accessor               : break;\n+  case Interpreter::getter                 : break;\n+  case Interpreter::setter                 : break;\n","filename":"src\/hotspot\/share\/interpreter\/templateInterpreterGenerator.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -53,1 +53,2 @@\n-    method_entry(accessor);\n+    method_entry(getter);\n+    method_entry(setter);\n@@ -93,1 +94,2 @@\n-  case Interpreter::accessor               : entry_point = generate_accessor_entry(); break;\n+  case Interpreter::getter                 : entry_point = generate_getter_entry();   break;\n+  case Interpreter::setter                 : entry_point = generate_setter_entry();   break;\n@@ -159,1 +161,1 @@\n-address ZeroInterpreterGenerator::generate_accessor_entry() {\n+address ZeroInterpreterGenerator::generate_getter_entry() {\n@@ -163,1 +165,8 @@\n-  return generate_entry((address) ZeroInterpreter::accessor_entry);\n+  return generate_entry((address) ZeroInterpreter::getter_entry);\n+}\n+\n+address ZeroInterpreterGenerator::generate_setter_entry() {\n+  if (!UseFastAccessorMethods)\n+    return NULL;\n+\n+  return generate_entry((address) ZeroInterpreter::setter_entry);\n","filename":"src\/hotspot\/share\/interpreter\/zero\/zeroInterpreterGenerator.cpp","additions":13,"deletions":4,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -47,1 +47,2 @@\n-  address generate_accessor_entry();\n+  address generate_getter_entry();\n+  address generate_setter_entry();\n","filename":"src\/hotspot\/share\/interpreter\/zero\/zeroInterpreterGenerator.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"}]}