{"files":[{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,2 @@\n-    AArch64;\n+    AArch64,\n+    MacOsAArch64;\n@@ -52,1 +53,5 @@\n-            current = AArch64;\n+            if (os.startsWith(\"Mac\")) {\n+                current = MacOsAArch64;\n+            } else {\n+                current = AArch64;\n+            }\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/CABI.java","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,1 @@\n-            case AArch64 -> aarch64;\n+            case AArch64, MacOsAArch64 -> aarch64;\n@@ -47,4 +47,5 @@\n-        if (CABI.current() == CABI.Win64) {\n-            return Win64.asVarArg(ml);\n-        }\n-        return ml;\n+        return switch (CABI.current()) {\n+            case Win64 -> Win64.asVarArg(ml);\n+            case MacOsAArch64 -> AArch64.asVarArg(ml);\n+            default -> ml;\n+        };\n@@ -162,1 +163,1 @@\n-         * The name of the layout attribute (see {@link MemoryLayout#attributes()} used to mark variadic parameters. The\n+         * The name of the layout attribute (see {@link MemoryLayout#attributes()}) used to mark variadic parameters. The\n@@ -275,0 +276,20 @@\n+\n+        \/**\n+         * The name of the layout attribute (see {@link MemoryLayout#attributes()})\n+         * used to mark variadic parameters on systems such as macOS which pass these\n+         * entirely on the stack. The attribute value must be a boolean.\n+         *\/\n+        public final static String STACK_VARARGS_ATTRIBUTE_NAME = \"abi\/aarch64\/stack_varargs\";\n+\n+        \/**\n+         * Return a new memory layout which describes a variadic parameter to be\n+         * passed to a function. This is only required on platforms such as macOS\n+         * which pass variadic parameters entirely on the stack.\n+         * @param layout the original parameter layout.\n+         * @return a layout which is the same as {@code layout}, except for\n+         * the extra attribute {@link #STACK_VARARGS_ATTRIBUTE_NAME}, which is set\n+         * to {@code true}.\n+         *\/\n+        public static MemoryLayout asVarArg(MemoryLayout layout) {\n+            return layout.withAttribute(STACK_VARARGS_ATTRIBUTE_NAME, true);\n+        }\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/PlatformLayouts.java","additions":28,"deletions":7,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,2 @@\n-import jdk.internal.foreign.abi.aarch64.AArch64Linker;\n+import jdk.internal.foreign.abi.aarch64.aapcs.AapcsLinker;\n+import jdk.internal.foreign.abi.aarch64.macos.MacOsAArch64Linker;\n@@ -244,1 +245,2 @@\n-            case AArch64 -> AArch64Linker.getInstance();\n+            case AArch64 -> AapcsLinker.getInstance();\n+            case MacOsAArch64 -> MacOsAArch64Linker.getInstance();\n@@ -301,1 +303,2 @@\n-            case AArch64 -> AArch64Linker.newVaList(actions, allocator);\n+            case AArch64 -> AapcsLinker.newVaList(actions, allocator);\n+            case MacOsAArch64 -> MacOsAArch64Linker.newVaList(actions, allocator);\n@@ -315,1 +318,2 @@\n-            case AArch64 -> AArch64Linker.newVaListOfAddress(ma);\n+            case AArch64 -> AapcsLinker.newVaListOfAddress(ma);\n+            case MacOsAArch64 -> MacOsAArch64Linker.newVaListOfAddress(ma);\n@@ -323,1 +327,2 @@\n-            case AArch64 -> AArch64Linker.emptyVaList();\n+            case AArch64 -> AapcsLinker.emptyVaList();\n+            case MacOsAArch64 -> MacOsAArch64Linker.emptyVaList();\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/SharedUtils.java","additions":11,"deletions":6,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -1,109 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2019, 2020, Arm Limited. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.internal.foreign.abi.aarch64;\n-\n-import jdk.incubator.foreign.Addressable;\n-import jdk.incubator.foreign.FunctionDescriptor;\n-import jdk.incubator.foreign.MemoryAddress;\n-import jdk.incubator.foreign.MemoryLayout;\n-import jdk.incubator.foreign.MemorySegment;\n-import jdk.incubator.foreign.CLinker;\n-import jdk.internal.foreign.abi.SharedUtils;\n-import jdk.internal.foreign.abi.UpcallStubs;\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.MethodType;\n-import java.util.Objects;\n-import java.util.function.Consumer;\n-\n-import static jdk.internal.foreign.PlatformLayouts.*;\n-\n-\/**\n- * ABI implementation based on ARM document \"Procedure Call Standard for\n- * the ARM 64-bit Architecture\".\n- *\/\n-public class AArch64Linker implements CLinker {\n-    private static AArch64Linker instance;\n-\n-    static final long ADDRESS_SIZE = 64; \/\/ bits\n-\n-    private static final MethodHandle MH_unboxVaList;\n-    private static final MethodHandle MH_boxVaList;\n-\n-    static {\n-        try {\n-            MethodHandles.Lookup lookup = MethodHandles.lookup();\n-            MH_unboxVaList = lookup.findVirtual(VaList.class, \"address\",\n-                MethodType.methodType(MemoryAddress.class));\n-            MH_boxVaList = lookup.findStatic(AArch64Linker.class, \"newVaListOfAddress\",\n-                MethodType.methodType(VaList.class, MemoryAddress.class));\n-        } catch (ReflectiveOperationException e) {\n-            throw new ExceptionInInitializerError(e);\n-        }\n-    }\n-\n-    public static AArch64Linker getInstance() {\n-        if (instance == null) {\n-            instance = new AArch64Linker();\n-        }\n-        return instance;\n-    }\n-\n-    @Override\n-    public MethodHandle downcallHandle(Addressable symbol, MethodType type, FunctionDescriptor function) {\n-        Objects.requireNonNull(symbol);\n-        Objects.requireNonNull(type);\n-        Objects.requireNonNull(function);\n-        MethodType llMt = SharedUtils.convertVaListCarriers(type, AArch64VaList.CARRIER);\n-        MethodHandle handle = CallArranger.arrangeDowncall(symbol, llMt, function);\n-        handle = SharedUtils.unboxVaLists(type, handle, MH_unboxVaList);\n-        return handle;\n-    }\n-\n-    @Override\n-    public MemorySegment upcallStub(MethodHandle target, FunctionDescriptor function) {\n-        Objects.requireNonNull(target);\n-        Objects.requireNonNull(function);\n-        target = SharedUtils.boxVaLists(target, MH_boxVaList);\n-        return UpcallStubs.upcallAddress(CallArranger.arrangeUpcall(target, target.type(), function));\n-    }\n-\n-    public static VaList newVaList(Consumer<VaList.Builder> actions, SharedUtils.Allocator allocator) {\n-        AArch64VaList.Builder builder = AArch64VaList.builder(allocator);\n-        actions.accept(builder);\n-        return builder.build();\n-    }\n-\n-    public static VaList newVaListOfAddress(MemoryAddress ma) {\n-        return AArch64VaList.ofAddress(ma);\n-    }\n-\n-    public static VaList emptyVaList() {\n-        return AArch64VaList.empty();\n-    }\n-\n-}\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/AArch64Linker.java","additions":0,"deletions":109,"binary":false,"changes":109,"status":"deleted"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2019, 2020, Arm Limited. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Arm Limited. All rights reserved.\n@@ -101,1 +101,1 @@\n-        SharedUtils.checkFunctionTypes(mt, cDesc, AArch64Linker.ADDRESS_SIZE);\n+        SharedUtils.checkFunctionTypes(mt, cDesc, AArch64.C_POINTER.bitSize());\n@@ -212,0 +212,10 @@\n+\n+        void adjustForVarArgs(MemoryLayout layout) {\n+            if (layout.attribute(AArch64.STACK_VARARGS_ATTRIBUTE_NAME)\n+                    .map(Boolean.class::cast).orElse(false)) {\n+                \/\/ This system passes all variadic parameters on the stack. Ensure\n+                \/\/ no further arguments are allocated to registers.\n+                nRegs[StorageClasses.INTEGER] = MAX_REGISTER_ARGUMENTS;\n+                nRegs[StorageClasses.VECTOR] = MAX_REGISTER_ARGUMENTS;\n+            }\n+        }\n@@ -283,0 +293,1 @@\n+            storageCalculator.adjustForVarArgs(layout);\n@@ -383,0 +394,1 @@\n+            storageCalculator.adjustForVarArgs(layout);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/CallArranger.java","additions":15,"deletions":3,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2020, Arm Limited. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Arm Limited. All rights reserved.\n@@ -34,1 +34,1 @@\n-enum TypeClass {\n+public enum TypeClass {\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/TypeClass.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,110 @@\n+\/*\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.foreign.abi.aarch64.aapcs;\n+\n+import jdk.incubator.foreign.Addressable;\n+import jdk.incubator.foreign.FunctionDescriptor;\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemoryLayout;\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.CLinker;\n+import jdk.internal.foreign.abi.SharedUtils;\n+import jdk.internal.foreign.abi.UpcallStubs;\n+import jdk.internal.foreign.abi.aarch64.CallArranger;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.util.Objects;\n+import java.util.function.Consumer;\n+\n+import static jdk.internal.foreign.PlatformLayouts.*;\n+\n+\/**\n+ * ABI implementation based on ARM document \"Procedure Call Standard for\n+ * the ARM 64-bit Architecture\".\n+ *\/\n+public class AapcsLinker implements CLinker {\n+    private static AapcsLinker instance;\n+\n+    static final long ADDRESS_SIZE = 64; \/\/ bits\n+\n+    private static final MethodHandle MH_unboxVaList;\n+    private static final MethodHandle MH_boxVaList;\n+\n+    static {\n+        try {\n+            MethodHandles.Lookup lookup = MethodHandles.lookup();\n+            MH_unboxVaList = lookup.findVirtual(VaList.class, \"address\",\n+                MethodType.methodType(MemoryAddress.class));\n+            MH_boxVaList = lookup.findStatic(AapcsLinker.class, \"newVaListOfAddress\",\n+                MethodType.methodType(VaList.class, MemoryAddress.class));\n+        } catch (ReflectiveOperationException e) {\n+            throw new ExceptionInInitializerError(e);\n+        }\n+    }\n+\n+    public static AapcsLinker getInstance() {\n+        if (instance == null) {\n+            instance = new AapcsLinker();\n+        }\n+        return instance;\n+    }\n+\n+    @Override\n+    public MethodHandle downcallHandle(Addressable symbol, MethodType type, FunctionDescriptor function) {\n+        Objects.requireNonNull(symbol);\n+        Objects.requireNonNull(type);\n+        Objects.requireNonNull(function);\n+        MethodType llMt = SharedUtils.convertVaListCarriers(type, AapcsVaList.CARRIER);\n+        MethodHandle handle = CallArranger.arrangeDowncall(symbol, llMt, function);\n+        handle = SharedUtils.unboxVaLists(type, handle, MH_unboxVaList);\n+        return handle;\n+    }\n+\n+    @Override\n+    public MemorySegment upcallStub(MethodHandle target, FunctionDescriptor function) {\n+        Objects.requireNonNull(target);\n+        Objects.requireNonNull(function);\n+        target = SharedUtils.boxVaLists(target, MH_boxVaList);\n+        return UpcallStubs.upcallAddress(CallArranger.arrangeUpcall(target, target.type(), function));\n+    }\n+\n+    public static VaList newVaList(Consumer<VaList.Builder> actions, SharedUtils.Allocator allocator) {\n+        AapcsVaList.Builder builder = AapcsVaList.builder(allocator);\n+        actions.accept(builder);\n+        return builder.build();\n+    }\n+\n+    public static VaList newVaListOfAddress(MemoryAddress ma) {\n+        return AapcsVaList.ofAddress(ma);\n+    }\n+\n+    public static VaList emptyVaList() {\n+        return AapcsVaList.empty();\n+    }\n+\n+}\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/aapcs\/AapcsLinker.java","additions":110,"deletions":0,"binary":false,"changes":110,"status":"added"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2020, Arm Limited. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Arm Limited. All rights reserved.\n@@ -26,1 +26,1 @@\n-package jdk.internal.foreign.abi.aarch64;\n+package jdk.internal.foreign.abi.aarch64.aapcs;\n@@ -32,0 +32,1 @@\n+import jdk.internal.foreign.abi.aarch64.*;\n@@ -49,1 +50,5 @@\n-public class AArch64VaList implements VaList {\n+\/**\n+ * Standard va_list implementation as defined by AAPCS document and used on\n+ * Linux. Variadic parameters may be passed in registers or on the stack.\n+ *\/\n+public class AapcsVaList implements VaList {\n@@ -109,2 +114,2 @@\n-    private AArch64VaList(MemorySegment segment, MemorySegment gpRegsArea, MemorySegment fpRegsArea,\n-                          List<MemorySegment> attachedSegments) {\n+    private AapcsVaList(MemorySegment segment, MemorySegment gpRegsArea, MemorySegment fpRegsArea,\n+                        List<MemorySegment> attachedSegments) {\n@@ -117,1 +122,1 @@\n-    private static AArch64VaList readFromSegment(MemorySegment segment) {\n+    private static AapcsVaList readFromSegment(MemorySegment segment) {\n@@ -123,1 +128,1 @@\n-        return new AArch64VaList(segment, gpRegsArea, fpRegsArea, List.of(gpRegsArea, fpRegsArea));\n+        return new AapcsVaList(segment, gpRegsArea, fpRegsArea, List.of(gpRegsArea, fpRegsArea));\n@@ -131,1 +136,1 @@\n-        cleaner.register(AArch64VaList.class, ms::close);\n+        cleaner.register(AapcsVaList.class, ms::close);\n@@ -253,1 +258,1 @@\n-        checkCompatibleType(carrier, layout, AArch64Linker.ADDRESS_SIZE);\n+        checkCompatibleType(carrier, layout, AapcsLinker.ADDRESS_SIZE);\n@@ -359,2 +364,2 @@\n-    static AArch64VaList.Builder builder(SharedUtils.Allocator allocator) {\n-        return new AArch64VaList.Builder(allocator);\n+    static AapcsVaList.Builder builder(SharedUtils.Allocator allocator) {\n+        return new AapcsVaList.Builder(allocator);\n@@ -392,1 +397,1 @@\n-        return new AArch64VaList(copy, gpRegsArea, fpRegsArea, List.of());\n+        return new AapcsVaList(copy, gpRegsArea, fpRegsArea, List.of());\n@@ -417,1 +422,1 @@\n-        return \"AArch64VaList{\"\n+        return \"AapcsVaList{\"\n@@ -469,1 +474,1 @@\n-            checkCompatibleType(carrier, layout, AArch64Linker.ADDRESS_SIZE);\n+            checkCompatibleType(carrier, layout, AapcsLinker.ADDRESS_SIZE);\n@@ -565,1 +570,1 @@\n-            return new AArch64VaList(vaListSegment, gpRegs, fpRegs, attachedSegments);\n+            return new AapcsVaList(vaListSegment, gpRegs, fpRegs, attachedSegments);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/aapcs\/AapcsVaList.java","additions":21,"deletions":16,"binary":false,"changes":37,"previous_filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/AArch64VaList.java","status":"renamed"},{"patch":"@@ -0,0 +1,110 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.foreign.abi.aarch64.macos;\n+\n+import jdk.incubator.foreign.Addressable;\n+import jdk.incubator.foreign.FunctionDescriptor;\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemoryLayout;\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.CLinker;\n+import jdk.internal.foreign.abi.SharedUtils;\n+import jdk.internal.foreign.abi.UpcallStubs;\n+import jdk.internal.foreign.abi.aarch64.CallArranger;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.util.Objects;\n+import java.util.function.Consumer;\n+\n+import static jdk.internal.foreign.PlatformLayouts.*;\n+\n+\/**\n+ * ABI implementation for macOS on Apple silicon. Based on AAPCS with\n+ * changes to va_list and passing arguments on the stack.\n+ *\/\n+public class MacOsAArch64Linker implements CLinker {\n+    private static MacOsAArch64Linker instance;\n+\n+    static final long ADDRESS_SIZE = 64; \/\/ bits\n+\n+    private static final MethodHandle MH_unboxVaList;\n+    private static final MethodHandle MH_boxVaList;\n+\n+    static {\n+        try {\n+            MethodHandles.Lookup lookup = MethodHandles.lookup();\n+            MH_unboxVaList = lookup.findVirtual(VaList.class, \"address\",\n+                MethodType.methodType(MemoryAddress.class));\n+            MH_boxVaList = lookup.findStatic(MacOsAArch64Linker.class, \"newVaListOfAddress\",\n+                MethodType.methodType(VaList.class, MemoryAddress.class));\n+        } catch (ReflectiveOperationException e) {\n+            throw new ExceptionInInitializerError(e);\n+        }\n+    }\n+\n+    public static MacOsAArch64Linker getInstance() {\n+        if (instance == null) {\n+            instance = new MacOsAArch64Linker();\n+        }\n+        return instance;\n+    }\n+\n+    @Override\n+    public MethodHandle downcallHandle(Addressable symbol, MethodType type, FunctionDescriptor function) {\n+        Objects.requireNonNull(symbol);\n+        Objects.requireNonNull(type);\n+        Objects.requireNonNull(function);\n+        MethodType llMt = SharedUtils.convertVaListCarriers(type, StackVaList.CARRIER);\n+        MethodHandle handle = CallArranger.arrangeDowncall(symbol, llMt, function);\n+        handle = SharedUtils.unboxVaLists(type, handle, MH_unboxVaList);\n+        return handle;\n+    }\n+\n+    @Override\n+    public MemorySegment upcallStub(MethodHandle target, FunctionDescriptor function) {\n+        Objects.requireNonNull(target);\n+        Objects.requireNonNull(function);\n+        target = SharedUtils.boxVaLists(target, MH_boxVaList);\n+        return UpcallStubs.upcallAddress(CallArranger.arrangeUpcall(target, target.type(), function));\n+    }\n+\n+    public static VaList newVaList(Consumer<VaList.Builder> actions, SharedUtils.Allocator allocator) {\n+        StackVaList.Builder builder = StackVaList.builder(allocator);\n+        actions.accept(builder);\n+        return builder.build();\n+    }\n+\n+    public static VaList newVaListOfAddress(MemoryAddress ma) {\n+        return StackVaList.ofAddress(ma);\n+    }\n+\n+    public static VaList emptyVaList() {\n+        return StackVaList.empty();\n+    }\n+\n+}\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/macos\/MacOsAArch64Linker.java","additions":110,"deletions":0,"binary":false,"changes":110,"status":"added"},{"patch":"@@ -0,0 +1,282 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.foreign.abi.aarch64.macos;\n+\n+import jdk.incubator.foreign.*;\n+import jdk.internal.foreign.NativeMemorySegmentImpl;\n+import jdk.internal.foreign.Utils;\n+import jdk.internal.foreign.abi.SharedUtils;\n+import jdk.internal.foreign.abi.aarch64.*;\n+import jdk.internal.misc.Unsafe;\n+\n+import java.lang.invoke.VarHandle;\n+import java.lang.ref.Cleaner;\n+import java.nio.ByteOrder;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.Stream;\n+\n+import static jdk.internal.foreign.PlatformLayouts.AArch64.C_POINTER;\n+import static jdk.incubator.foreign.CLinker.VaList;\n+import static jdk.internal.foreign.abi.SharedUtils.alignUp;\n+import static jdk.internal.foreign.abi.SharedUtils.SimpleVaArg;\n+import static jdk.internal.foreign.abi.SharedUtils.checkCompatibleType;\n+import static jdk.internal.foreign.abi.SharedUtils.vhPrimitiveOrAddress;\n+\n+\/**\n+ * Simplified va_list implementation used on macOS and Windows where all\n+ * variadic parameters are passed on the stack and the type of va_list decays to\n+ * char* instead of the structure defined in the AAPCS.\n+ *\/\n+class StackVaList implements VaList {\n+    public static final Class<?> CARRIER = MemoryAddress.class;\n+    private static final long VA_SLOT_SIZE_BYTES = 8;\n+    private static final VarHandle VH_address = MemoryHandles.asAddressVarHandle(C_POINTER.varHandle(long.class));\n+\n+    private static final VaList EMPTY = new SharedUtils.EmptyVaList(MemoryAddress.NULL);\n+\n+    private MemorySegment segment;\n+    private final List<MemorySegment> attachedSegments;\n+    private final MemorySegment livenessCheck;\n+\n+    private StackVaList(MemorySegment segment, List<MemorySegment> attachedSegments, MemorySegment livenessCheck) {\n+        this.segment = segment;\n+        this.attachedSegments = attachedSegments;\n+        this.livenessCheck = livenessCheck;\n+    }\n+\n+    public static final VaList empty() {\n+        return EMPTY;\n+    }\n+\n+    @Override\n+    public int vargAsInt(MemoryLayout layout) {\n+        return (int) read(int.class, layout);\n+    }\n+\n+    @Override\n+    public long vargAsLong(MemoryLayout layout) {\n+        return (long) read(long.class, layout);\n+    }\n+\n+    @Override\n+    public double vargAsDouble(MemoryLayout layout) {\n+        return (double) read(double.class, layout);\n+    }\n+\n+    @Override\n+    public MemoryAddress vargAsAddress(MemoryLayout layout) {\n+        return (MemoryAddress) read(MemoryAddress.class, layout);\n+    }\n+\n+    @Override\n+    public MemorySegment vargAsSegment(MemoryLayout layout) {\n+        return (MemorySegment) read(MemorySegment.class, layout);\n+    }\n+\n+    @Override\n+    public MemorySegment vargAsSegment(MemoryLayout layout, NativeScope scope) {\n+        Objects.requireNonNull(scope);\n+        return (MemorySegment) read(MemorySegment.class, layout, SharedUtils.Allocator.ofScope(scope));\n+    }\n+\n+    private Object read(Class<?> carrier, MemoryLayout layout) {\n+        return read(carrier, layout, MemorySegment::allocateNative);\n+    }\n+\n+    private Object read(Class<?> carrier, MemoryLayout layout, SharedUtils.Allocator allocator) {\n+        Objects.requireNonNull(layout);\n+        SharedUtils.checkCompatibleType(carrier, layout, MacOsAArch64Linker.ADDRESS_SIZE);\n+        Object res;\n+        if (carrier == MemorySegment.class) {\n+            TypeClass typeClass = TypeClass.classifyLayout(layout);\n+            res = switch (typeClass) {\n+                case STRUCT_REFERENCE -> {\n+                    MemoryAddress structAddr = (MemoryAddress) VH_address.get(segment);\n+                    try (MemorySegment struct = handoffIfNeeded(structAddr.asSegmentRestricted(layout.byteSize()),\n+                         segment.ownerThread())) {\n+                        MemorySegment seg = allocator.allocate(layout.byteSize());\n+                        seg.copyFrom(struct);\n+                        segment = segment.asSlice(VA_SLOT_SIZE_BYTES);\n+                        yield seg;\n+                    }\n+                }\n+                case STRUCT_REGISTER, STRUCT_HFA -> {\n+                    MemorySegment struct = allocator.allocate(layout);\n+                    struct.copyFrom(segment.asSlice(0L, layout.byteSize()));\n+                    segment = segment.asSlice(VA_SLOT_SIZE_BYTES);\n+                    yield struct;\n+                }\n+                default -> throw new IllegalStateException(\"Unexpected TypeClass: \" + typeClass);\n+            };\n+        } else {\n+            VarHandle reader = SharedUtils.vhPrimitiveOrAddress(carrier, layout);\n+            res = reader.get(segment);\n+            segment = segment.asSlice(VA_SLOT_SIZE_BYTES);\n+        }\n+        return res;\n+    }\n+\n+    @Override\n+    public void skip(MemoryLayout... layouts) {\n+        Objects.requireNonNull(layouts);\n+        Stream.of(layouts).forEach(Objects::requireNonNull);\n+        segment = segment.asSlice(layouts.length * VA_SLOT_SIZE_BYTES);\n+    }\n+\n+    static StackVaList ofAddress(MemoryAddress addr) {\n+        MemorySegment segment = addr.asSegmentRestricted(Long.MAX_VALUE);\n+        return new StackVaList(segment, List.of(segment), null);\n+    }\n+\n+    static Builder builder(SharedUtils.Allocator allocator) {\n+        return new Builder(allocator);\n+    }\n+\n+    @Override\n+    public void close() {\n+        if (livenessCheck != null)\n+            livenessCheck.close();\n+        attachedSegments.forEach(MemorySegment::close);\n+    }\n+\n+    @Override\n+    public VaList copy() {\n+        MemorySegment liveness = handoffIfNeeded(MemoryAddress.NULL.asSegmentRestricted(1),\n+                segment.ownerThread());\n+        return new StackVaList(segment, List.of(), liveness);\n+    }\n+\n+    @Override\n+    public VaList copy(NativeScope scope) {\n+        Objects.requireNonNull(scope);\n+        MemorySegment liveness = handoffIfNeeded(MemoryAddress.NULL.asSegmentRestricted(1),\n+                segment.ownerThread());\n+        liveness = liveness.handoff(scope);\n+        return new StackVaList(segment, List.of(), liveness);\n+    }\n+\n+    @Override\n+    public MemoryAddress address() {\n+        return segment.address();\n+    }\n+\n+    @Override\n+    public boolean isAlive() {\n+        if (livenessCheck != null)\n+            return livenessCheck.isAlive();\n+        return segment.isAlive();\n+    }\n+\n+    static class Builder implements VaList.Builder {\n+\n+        private final SharedUtils.Allocator allocator;\n+        private final List<SimpleVaArg> args = new ArrayList<>();\n+\n+        public Builder(SharedUtils.Allocator allocator) {\n+            this.allocator = allocator;\n+        }\n+\n+        private Builder arg(Class<?> carrier, MemoryLayout layout, Object value) {\n+            Objects.requireNonNull(layout);\n+            Objects.requireNonNull(value);\n+            SharedUtils.checkCompatibleType(carrier, layout, MacOsAArch64Linker.ADDRESS_SIZE);\n+            args.add(new SimpleVaArg(carrier, layout, value));\n+            return this;\n+        }\n+\n+        @Override\n+        public Builder vargFromInt(ValueLayout layout, int value) {\n+            return arg(int.class, layout, value);\n+        }\n+\n+        @Override\n+        public Builder vargFromLong(ValueLayout layout, long value) {\n+            return arg(long.class, layout, value);\n+        }\n+\n+        @Override\n+        public Builder vargFromDouble(ValueLayout layout, double value) {\n+            return arg(double.class, layout, value);\n+        }\n+\n+        @Override\n+        public Builder vargFromAddress(ValueLayout layout, Addressable value) {\n+            return arg(MemoryAddress.class, layout, value.address());\n+        }\n+\n+        @Override\n+        public Builder vargFromSegment(GroupLayout layout, MemorySegment value) {\n+            return arg(MemorySegment.class, layout, value);\n+        }\n+\n+        public VaList build() {\n+            if (args.isEmpty()) {\n+                return EMPTY;\n+            }\n+\n+            \/\/ Each argument may occupy up to four slots\n+            MemorySegment segment = allocator.allocate(VA_SLOT_SIZE_BYTES * args.size() * 4);\n+\n+            List<MemorySegment> attachedSegments = new ArrayList<>();\n+            attachedSegments.add(segment);\n+            MemorySegment cursor = segment;\n+\n+            for (SimpleVaArg arg : args) {\n+                if (arg.carrier == MemorySegment.class) {\n+                    MemorySegment msArg = ((MemorySegment) arg.value);\n+                    TypeClass typeClass = TypeClass.classifyLayout(arg.layout);\n+                    switch (typeClass) {\n+                        case STRUCT_REFERENCE -> {\n+                            MemorySegment copy = allocator.allocate(arg.layout);\n+                            copy.copyFrom(msArg); \/\/ by-value\n+                            attachedSegments.add(copy);\n+                            VH_address.set(cursor, copy.address());\n+                            cursor = cursor.asSlice(VA_SLOT_SIZE_BYTES);\n+                        }\n+                        case STRUCT_REGISTER, STRUCT_HFA -> {\n+                            cursor.copyFrom(msArg.asSlice(0, arg.layout.byteSize()));\n+                            cursor = cursor.asSlice(alignUp(arg.layout.byteSize(), VA_SLOT_SIZE_BYTES));\n+                        }\n+                        default -> throw new IllegalStateException(\"Unexpected TypeClass: \" + typeClass);\n+                    }\n+                } else {\n+                    VarHandle writer = arg.varHandle();\n+                    writer.set(cursor, arg.value);\n+                    cursor = cursor.asSlice(VA_SLOT_SIZE_BYTES);\n+                }\n+            }\n+\n+            return new StackVaList(segment, attachedSegments, null);\n+        }\n+    }\n+\n+    private static MemorySegment handoffIfNeeded(MemorySegment segment, Thread thread) {\n+        return segment.ownerThread() == thread ?\n+                segment : segment.handoff(thread);\n+    }\n+}\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/macos\/StackVaList.java","additions":282,"deletions":0,"binary":false,"changes":282,"status":"added"},{"patch":"@@ -548,1 +548,0 @@\n-java\/foreign\/StdLibTest.java 8263512 macosx-aarch64\n@@ -552,2 +551,0 @@\n-java\/foreign\/TestVarArgs.java 8263512 macosx-aarch64\n-java\/foreign\/valist\/VaListTest.java 8263512 macosx-aarch64\n","filename":"test\/jdk\/ProblemList.txt","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,2 @@\n- *          jdk.incubator.foreign\/jdk.internal.foreign.abi.aarch64\n+ *          jdk.incubator.foreign\/jdk.internal.foreign.abi.aarch64.aapcs\n+ *          jdk.incubator.foreign\/jdk.internal.foreign.abi.aarch64.macos\n@@ -39,1 +40,2 @@\n-import jdk.internal.foreign.abi.aarch64.AArch64Linker;\n+import jdk.internal.foreign.abi.aarch64.aapcs.AapcsLinker;\n+import jdk.internal.foreign.abi.aarch64.macos.MacOsAArch64Linker;\n@@ -115,2 +117,4 @@\n-    private static final Function<Consumer<VaList.Builder>, VaList> aarch64VaListFactory\n-            = actions -> AArch64Linker.newVaList(actions, MemorySegment::allocateNative);\n+    private static final Function<Consumer<VaList.Builder>, VaList> aapcsVaListFactory\n+            = actions -> AapcsLinker.newVaList(actions, MemorySegment::allocateNative);\n+    private static final Function<Consumer<VaList.Builder>, VaList> macAArch64VaListFactory\n+            = actions -> MacOsAArch64Linker.newVaList(actions, MemorySegment::allocateNative);\n@@ -124,2 +128,4 @@\n-    private static final BiFunction<Consumer<VaList.Builder>, NativeScope, VaList> aarch64VaListScopedFactory\n-            = (actions, scope) -> AArch64Linker.newVaList(actions, SharedUtils.Allocator.ofScope(scope));\n+    private static final BiFunction<Consumer<VaList.Builder>, NativeScope, VaList> aapcsVaListScopedFactory\n+            = (actions, scope) -> AapcsLinker.newVaList(actions, SharedUtils.Allocator.ofScope(scope));\n+    private static final BiFunction<Consumer<VaList.Builder>, NativeScope, VaList> macAArch64VaListScopedFactory\n+            = (actions, scope) -> MacOsAArch64Linker.newVaList(actions, SharedUtils.Allocator.ofScope(scope));\n@@ -137,4 +143,5 @@\n-                { winVaListFactory,      sumIntsJavaFact.apply(Win64.C_INT),   Win64.C_INT   },\n-                { sysvVaListFactory,     sumIntsJavaFact.apply(SysV.C_INT),    SysV.C_INT    },\n-                { aarch64VaListFactory,  sumIntsJavaFact.apply(AArch64.C_INT), AArch64.C_INT },\n-                { platformVaListFactory, sumIntsNative,                        C_INT         },\n+                { winVaListFactory,        sumIntsJavaFact.apply(Win64.C_INT),   Win64.C_INT   },\n+                { sysvVaListFactory,       sumIntsJavaFact.apply(SysV.C_INT),    SysV.C_INT    },\n+                { aapcsVaListFactory,      sumIntsJavaFact.apply(AArch64.C_INT), AArch64.C_INT },\n+                { macAArch64VaListFactory, sumIntsJavaFact.apply(AArch64.C_INT), AArch64.C_INT },\n+                { platformVaListFactory,   sumIntsNative,                        C_INT         },\n@@ -165,4 +172,5 @@\n-                { winVaListFactory,      sumDoublesJavaFact.apply(Win64.C_DOUBLE),   Win64.C_DOUBLE   },\n-                { sysvVaListFactory,     sumDoublesJavaFact.apply(SysV.C_DOUBLE),    SysV.C_DOUBLE    },\n-                { aarch64VaListFactory,  sumDoublesJavaFact.apply(AArch64.C_DOUBLE), AArch64.C_DOUBLE },\n-                { platformVaListFactory, sumDoublesNative,                           C_DOUBLE         },\n+                { winVaListFactory,        sumDoublesJavaFact.apply(Win64.C_DOUBLE),   Win64.C_DOUBLE   },\n+                { sysvVaListFactory,       sumDoublesJavaFact.apply(SysV.C_DOUBLE),    SysV.C_DOUBLE    },\n+                { aapcsVaListFactory,      sumDoublesJavaFact.apply(AArch64.C_DOUBLE), AArch64.C_DOUBLE },\n+                { macAArch64VaListFactory, sumDoublesJavaFact.apply(AArch64.C_DOUBLE), AArch64.C_DOUBLE },\n+                { platformVaListFactory,   sumDoublesNative,                           C_DOUBLE         },\n@@ -195,4 +203,5 @@\n-                { winVaListFactory,      getIntJavaFact.apply(Win64.C_POINTER),   Win64.C_POINTER   },\n-                { sysvVaListFactory,     getIntJavaFact.apply(SysV.C_POINTER),    SysV.C_POINTER    },\n-                { aarch64VaListFactory,  getIntJavaFact.apply(AArch64.C_POINTER), AArch64.C_POINTER },\n-                { platformVaListFactory, getIntNative,                            C_POINTER         },\n+                { winVaListFactory,        getIntJavaFact.apply(Win64.C_POINTER),   Win64.C_POINTER   },\n+                { sysvVaListFactory,       getIntJavaFact.apply(SysV.C_POINTER),    SysV.C_POINTER    },\n+                { aapcsVaListFactory,      getIntJavaFact.apply(AArch64.C_POINTER), AArch64.C_POINTER },\n+                { macAArch64VaListFactory, getIntJavaFact.apply(AArch64.C_POINTER), AArch64.C_POINTER },\n+                { platformVaListFactory,   getIntNative,                            C_POINTER         },\n@@ -248,4 +257,5 @@\n-                argsFact.apply(winVaListFactory,      Win64.C_INT,   sumStructJavaFact),\n-                argsFact.apply(sysvVaListFactory,     SysV.C_INT,    sumStructJavaFact),\n-                argsFact.apply(aarch64VaListFactory,  AArch64.C_INT, sumStructJavaFact),\n-                argsFact.apply(platformVaListFactory, C_INT,         sumStructNativeFact),\n+                argsFact.apply(winVaListFactory,        Win64.C_INT,   sumStructJavaFact),\n+                argsFact.apply(sysvVaListFactory,       SysV.C_INT,    sumStructJavaFact),\n+                argsFact.apply(aapcsVaListFactory,      AArch64.C_INT, sumStructJavaFact),\n+                argsFact.apply(macAArch64VaListFactory, AArch64.C_INT, sumStructJavaFact),\n+                argsFact.apply(platformVaListFactory,   C_INT,         sumStructNativeFact),\n@@ -299,4 +309,5 @@\n-                argsFact.apply(winVaListFactory,      Win64.C_LONG_LONG,   sumStructJavaFact),\n-                argsFact.apply(sysvVaListFactory,     SysV.C_LONG_LONG,    sumStructJavaFact),\n-                argsFact.apply(aarch64VaListFactory,  AArch64.C_LONG_LONG, sumStructJavaFact),\n-                argsFact.apply(platformVaListFactory, C_LONG_LONG,         sumStructNativeFact),\n+                argsFact.apply(winVaListFactory,        Win64.C_LONG_LONG,   sumStructJavaFact),\n+                argsFact.apply(sysvVaListFactory,       SysV.C_LONG_LONG,    sumStructJavaFact),\n+                argsFact.apply(aapcsVaListFactory,      AArch64.C_LONG_LONG, sumStructJavaFact),\n+                argsFact.apply(macAArch64VaListFactory, AArch64.C_LONG_LONG, sumStructJavaFact),\n+                argsFact.apply(platformVaListFactory,   C_LONG_LONG,         sumStructNativeFact),\n@@ -350,4 +361,5 @@\n-                argsFact.apply(winVaListFactory,      Win64.C_FLOAT,   sumStructJavaFact),\n-                argsFact.apply(sysvVaListFactory,     SysV.C_FLOAT,    sumStructJavaFact),\n-                argsFact.apply(aarch64VaListFactory,  AArch64.C_FLOAT, sumStructJavaFact),\n-                argsFact.apply(platformVaListFactory, C_FLOAT,         sumStructNativeFact),\n+                argsFact.apply(winVaListFactory,        Win64.C_FLOAT,   sumStructJavaFact),\n+                argsFact.apply(sysvVaListFactory,       SysV.C_FLOAT,    sumStructJavaFact),\n+                argsFact.apply(aapcsVaListFactory,      AArch64.C_FLOAT, sumStructJavaFact),\n+                argsFact.apply(macAArch64VaListFactory, AArch64.C_FLOAT, sumStructJavaFact),\n+                argsFact.apply(platformVaListFactory,   C_FLOAT,         sumStructNativeFact),\n@@ -410,4 +422,5 @@\n-                argsFact.apply(winVaListFactory,      Win64.C_LONG_LONG,   sumStructJavaFact),\n-                argsFact.apply(sysvVaListFactory,     SysV.C_LONG_LONG,    sumStructJavaFact),\n-                argsFact.apply(aarch64VaListFactory,  AArch64.C_LONG_LONG, sumStructJavaFact),\n-                argsFact.apply(platformVaListFactory, C_LONG_LONG,         sumStructNativeFact),\n+                argsFact.apply(winVaListFactory,        Win64.C_LONG_LONG,   sumStructJavaFact),\n+                argsFact.apply(sysvVaListFactory,       SysV.C_LONG_LONG,    sumStructJavaFact),\n+                argsFact.apply(aapcsVaListFactory,      AArch64.C_LONG_LONG, sumStructJavaFact),\n+                argsFact.apply(macAArch64VaListFactory, AArch64.C_LONG_LONG, sumStructJavaFact),\n+                argsFact.apply(platformVaListFactory,   C_LONG_LONG,         sumStructNativeFact),\n@@ -463,4 +476,5 @@\n-                { winVaListFactory,      sumStackJavaFact.apply(Win64.C_LONG_LONG, Win64.C_DOUBLE),     Win64.C_LONG_LONG,   Win64.C_DOUBLE   },\n-                { sysvVaListFactory,     sumStackJavaFact.apply(SysV.C_LONG_LONG, SysV.C_DOUBLE),       SysV.C_LONG_LONG,    SysV.C_DOUBLE    },\n-                { aarch64VaListFactory,  sumStackJavaFact.apply(AArch64.C_LONG_LONG, AArch64.C_DOUBLE), AArch64.C_LONG_LONG, AArch64.C_DOUBLE },\n-                { platformVaListFactory, sumStackNative, C_LONG_LONG,         C_DOUBLE         },\n+                { winVaListFactory,        sumStackJavaFact.apply(Win64.C_LONG_LONG, Win64.C_DOUBLE),     Win64.C_LONG_LONG,   Win64.C_DOUBLE   },\n+                { sysvVaListFactory,       sumStackJavaFact.apply(SysV.C_LONG_LONG, SysV.C_DOUBLE),       SysV.C_LONG_LONG,    SysV.C_DOUBLE    },\n+                { aapcsVaListFactory,      sumStackJavaFact.apply(AArch64.C_LONG_LONG, AArch64.C_DOUBLE), AArch64.C_LONG_LONG, AArch64.C_DOUBLE },\n+                { macAArch64VaListFactory, sumStackJavaFact.apply(AArch64.C_LONG_LONG, AArch64.C_DOUBLE), AArch64.C_LONG_LONG, AArch64.C_DOUBLE },\n+                { platformVaListFactory,   sumStackNative, C_LONG_LONG,         C_DOUBLE         },\n@@ -512,6 +526,8 @@\n-                { Windowsx64Linker.emptyVaList()      },\n-                { winVaListFactory.apply(b -> {})     },\n-                { SysVx64Linker.emptyVaList()         },\n-                { sysvVaListFactory.apply(b -> {})    },\n-                { AArch64Linker.emptyVaList()         },\n-                { aarch64VaListFactory.apply(b -> {}) },\n+                { Windowsx64Linker.emptyVaList()         },\n+                { winVaListFactory.apply(b -> {})        },\n+                { SysVx64Linker.emptyVaList()            },\n+                { sysvVaListFactory.apply(b -> {})       },\n+                { AapcsLinker.emptyVaList()              },\n+                { aapcsVaListFactory.apply(b -> {})      },\n+                { MacOsAArch64Linker.emptyVaList()       },\n+                { macAArch64VaListFactory.apply(b -> {}) },\n@@ -536,4 +552,5 @@\n-                { winVaListScopedFactory,      sumIntsJavaFact.apply(Win64.C_INT),   Win64.C_INT   },\n-                { sysvVaListScopedFactory,     sumIntsJavaFact.apply(SysV.C_INT),    SysV.C_INT    },\n-                { aarch64VaListScopedFactory,  sumIntsJavaFact.apply(AArch64.C_INT), AArch64.C_INT },\n-                { platformVaListScopedFactory, sumIntsNative,                        C_INT         },\n+                { winVaListScopedFactory,        sumIntsJavaFact.apply(Win64.C_INT),   Win64.C_INT   },\n+                { sysvVaListScopedFactory,       sumIntsJavaFact.apply(SysV.C_INT),    SysV.C_INT    },\n+                { aapcsVaListScopedFactory,      sumIntsJavaFact.apply(AArch64.C_INT), AArch64.C_INT },\n+                { macAArch64VaListScopedFactory, sumIntsJavaFact.apply(AArch64.C_INT), AArch64.C_INT },\n+                { platformVaListScopedFactory,   sumIntsNative,                        C_INT         },\n@@ -583,3 +600,4 @@\n-                { winVaListFactory,      Win64.C_INT   },\n-                { sysvVaListFactory,     SysV.C_INT    },\n-                { aarch64VaListFactory,  AArch64.C_INT },\n+                { winVaListFactory,        Win64.C_INT   },\n+                { sysvVaListFactory,       SysV.C_INT    },\n+                { aapcsVaListFactory,      AArch64.C_INT },\n+                { macAArch64VaListFactory, AArch64.C_INT },\n","filename":"test\/jdk\/java\/foreign\/valist\/VaListTest.java","additions":70,"deletions":52,"binary":false,"changes":122,"status":"modified"}]}