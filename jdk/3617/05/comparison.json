{"files":[{"patch":"@@ -33,1 +33,2 @@\n-import jdk.internal.foreign.abi.aarch64.AArch64VaList;\n+import jdk.internal.foreign.abi.aarch64.linux.LinuxAArch64VaList;\n+import jdk.internal.foreign.abi.aarch64.macos.MacOsAArch64VaList;\n@@ -526,1 +527,1 @@\n-    sealed interface VaList extends Addressable permits WinVaList, SysVVaList, AArch64VaList, SharedUtils.EmptyVaList {\n+    sealed interface VaList extends Addressable permits WinVaList, SysVVaList, LinuxAArch64VaList, MacOsAArch64VaList, SharedUtils.EmptyVaList {\n@@ -732,1 +733,1 @@\n-        sealed interface Builder permits WinVaList.Builder, SysVVaList.Builder, AArch64VaList.Builder {\n+        sealed interface Builder permits WinVaList.Builder, SysVVaList.Builder, LinuxAArch64VaList.Builder, MacOsAArch64VaList.Builder {\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/CLinker.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,2 @@\n-    AArch64;\n+    LinuxAArch64,\n+    MacOsAArch64;\n@@ -52,1 +53,6 @@\n-            current = AArch64;\n+            if (os.startsWith(\"Mac\")) {\n+                current = MacOsAArch64;\n+            } else {\n+                \/\/ The Linux ABI follows the standard AAPCS ABI\n+                current = LinuxAArch64;\n+            }\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/CABI.java","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,1 @@\n-            case AArch64 -> aarch64;\n+            case LinuxAArch64, MacOsAArch64 -> aarch64;\n@@ -46,4 +46,5 @@\n-        if (CABI.current() == CABI.Win64) {\n-            return Win64.asVarArg(ml);\n-        }\n-        return ml;\n+        return switch (CABI.current()) {\n+            case Win64 -> Win64.asVarArg(ml);\n+            case MacOsAArch64 -> AArch64.asVarArg(ml);\n+            default -> ml;\n+        };\n@@ -161,1 +162,1 @@\n-         * The name of the layout attribute (see {@link MemoryLayout#attributes()} used to mark variadic parameters. The\n+         * The name of the layout attribute (see {@link MemoryLayout#attributes()}) used to mark variadic parameters. The\n@@ -274,0 +275,20 @@\n+\n+        \/**\n+         * The name of the layout attribute (see {@link MemoryLayout#attributes()})\n+         * used to mark variadic parameters on systems such as macOS which pass these\n+         * entirely on the stack. The attribute value must be a boolean.\n+         *\/\n+        public final static String STACK_VARARGS_ATTRIBUTE_NAME = \"abi\/aarch64\/stack_varargs\";\n+\n+        \/**\n+         * Return a new memory layout which describes a variadic parameter to be\n+         * passed to a function. This is only required on platforms such as macOS\n+         * which pass variadic parameters entirely on the stack.\n+         * @param layout the original parameter layout.\n+         * @return a layout which is the same as {@code layout}, except for\n+         * the extra attribute {@link #STACK_VARARGS_ATTRIBUTE_NAME}, which is set\n+         * to {@code true}.\n+         *\/\n+        public static MemoryLayout asVarArg(MemoryLayout layout) {\n+            return layout.withAttribute(STACK_VARARGS_ATTRIBUTE_NAME, true);\n+        }\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/PlatformLayouts.java","additions":28,"deletions":7,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-        case SysV, AArch64 -> NativeLibraries.rawNativeLibraries(SystemLookup.class, false).loadLibrary(\"syslookup\");\n+        case SysV, LinuxAArch64, MacOsAArch64 -> NativeLibraries.rawNativeLibraries(SystemLookup.class, false).loadLibrary(\"syslookup\");\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/SystemLookup.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,1 +43,2 @@\n-import jdk.internal.foreign.abi.aarch64.AArch64Linker;\n+import jdk.internal.foreign.abi.aarch64.linux.LinuxAArch64Linker;\n+import jdk.internal.foreign.abi.aarch64.macos.MacOsAArch64Linker;\n@@ -272,1 +273,2 @@\n-            case AArch64 -> AArch64Linker.getInstance();\n+            case LinuxAArch64 -> LinuxAArch64Linker.getInstance();\n+            case MacOsAArch64 -> MacOsAArch64Linker.getInstance();\n@@ -457,1 +459,2 @@\n-            case AArch64 -> AArch64Linker.newVaList(actions, scope);\n+            case LinuxAArch64 -> LinuxAArch64Linker.newVaList(actions, scope);\n+            case MacOsAArch64 -> MacOsAArch64Linker.newVaList(actions, scope);\n@@ -471,1 +474,2 @@\n-            case AArch64 -> AArch64Linker.newVaListOfAddress(ma, scope);\n+            case LinuxAArch64 -> LinuxAArch64Linker.newVaListOfAddress(ma, scope);\n+            case MacOsAArch64 -> MacOsAArch64Linker.newVaListOfAddress(ma, scope);\n@@ -479,1 +483,2 @@\n-            case AArch64 -> AArch64Linker.emptyVaList();\n+            case LinuxAArch64 -> LinuxAArch64Linker.emptyVaList();\n+            case MacOsAArch64 -> MacOsAArch64Linker.emptyVaList();\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/SharedUtils.java","additions":10,"deletions":5,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -1,111 +0,0 @@\n-\/*\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2019, 2020, Arm Limited. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.internal.foreign.abi.aarch64;\n-\n-import jdk.incubator.foreign.FunctionDescriptor;\n-import jdk.incubator.foreign.MemoryAddress;\n-import jdk.incubator.foreign.MemorySegment;\n-import jdk.incubator.foreign.ResourceScope;\n-import jdk.internal.foreign.AbstractCLinker;\n-import jdk.internal.foreign.ResourceScopeImpl;\n-import jdk.internal.foreign.abi.SharedUtils;\n-import jdk.internal.foreign.abi.UpcallStubs;\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.MethodType;\n-import java.util.Objects;\n-import java.util.function.Consumer;\n-\n-\/**\n- * ABI implementation based on ARM document \"Procedure Call Standard for\n- * the ARM 64-bit Architecture\".\n- *\/\n-public final class AArch64Linker extends AbstractCLinker {\n-    private static AArch64Linker instance;\n-\n-    static final long ADDRESS_SIZE = 64; \/\/ bits\n-\n-    private static final MethodHandle MH_unboxVaList;\n-    private static final MethodHandle MH_boxVaList;\n-\n-    static {\n-        try {\n-            MethodHandles.Lookup lookup = MethodHandles.lookup();\n-            MH_unboxVaList = lookup.findVirtual(VaList.class, \"address\",\n-                MethodType.methodType(MemoryAddress.class));\n-            MH_boxVaList = MethodHandles.insertArguments(lookup.findStatic(AArch64Linker.class, \"newVaListOfAddress\",\n-                MethodType.methodType(VaList.class, MemoryAddress.class, ResourceScope.class)), 1, ResourceScope.globalScope());\n-        } catch (ReflectiveOperationException e) {\n-            throw new ExceptionInInitializerError(e);\n-        }\n-    }\n-\n-    public static AArch64Linker getInstance() {\n-        if (instance == null) {\n-            instance = new AArch64Linker();\n-        }\n-        return instance;\n-    }\n-\n-    @Override\n-    public final MethodHandle downcallHandle(MethodType type, FunctionDescriptor function) {\n-        Objects.requireNonNull(type);\n-        Objects.requireNonNull(function);\n-        MethodType llMt = SharedUtils.convertVaListCarriers(type, AArch64VaList.CARRIER);\n-        MethodHandle handle = CallArranger.arrangeDowncall(llMt, function);\n-        if (!type.returnType().equals(MemorySegment.class)) {\n-            \/\/ not returning segment, just insert a throwing allocator\n-            handle = MethodHandles.insertArguments(handle, 1, SharedUtils.THROWING_ALLOCATOR);\n-        }\n-        handle = SharedUtils.unboxVaLists(type, handle, MH_unboxVaList);\n-        return handle;\n-    }\n-\n-    @Override\n-    public final MemoryAddress upcallStub(MethodHandle target, FunctionDescriptor function, ResourceScope scope) {\n-        Objects.requireNonNull(scope);\n-        Objects.requireNonNull(target);\n-        Objects.requireNonNull(function);\n-        target = SharedUtils.boxVaLists(target, MH_boxVaList);\n-        return UpcallStubs.upcallAddress(CallArranger.arrangeUpcall(target, target.type(), function), (ResourceScopeImpl) scope);\n-    }\n-\n-    public static VaList newVaList(Consumer<VaList.Builder> actions, ResourceScope scope) {\n-        AArch64VaList.Builder builder = AArch64VaList.builder(scope);\n-        actions.accept(builder);\n-        return builder.build();\n-    }\n-\n-    public static VaList newVaListOfAddress(MemoryAddress ma, ResourceScope scope) {\n-        return AArch64VaList.ofAddress(ma, scope);\n-    }\n-\n-    public static VaList emptyVaList() {\n-        return AArch64VaList.empty();\n-    }\n-\n-}\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/AArch64Linker.java","additions":0,"deletions":111,"binary":false,"changes":111,"status":"deleted"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2019, 2020, Arm Limited. All rights reserved.\n+ * Copyright (c) 2019, 2021, Arm Limited. All rights reserved.\n@@ -99,1 +99,1 @@\n-        SharedUtils.checkFunctionTypes(mt, cDesc, AArch64Linker.ADDRESS_SIZE);\n+        SharedUtils.checkFunctionTypes(mt, cDesc, AArch64.C_POINTER.bitSize());\n@@ -210,0 +210,10 @@\n+\n+        void adjustForVarArgs(MemoryLayout layout) {\n+            if (layout.attribute(AArch64.STACK_VARARGS_ATTRIBUTE_NAME)\n+                    .map(Boolean.class::cast).orElse(false)) {\n+                \/\/ This system passes all variadic parameters on the stack. Ensure\n+                \/\/ no further arguments are allocated to registers.\n+                nRegs[StorageClasses.INTEGER] = MAX_REGISTER_ARGUMENTS;\n+                nRegs[StorageClasses.VECTOR] = MAX_REGISTER_ARGUMENTS;\n+            }\n+        }\n@@ -281,0 +291,1 @@\n+            storageCalculator.adjustForVarArgs(layout);\n@@ -383,0 +394,1 @@\n+            assert !layout.attribute(AArch64.STACK_VARARGS_ATTRIBUTE_NAME).isPresent() : \"no variadic upcalls\";\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/CallArranger.java","additions":14,"deletions":2,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2020, Arm Limited. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Arm Limited. All rights reserved.\n@@ -34,1 +34,1 @@\n-enum TypeClass {\n+public enum TypeClass {\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/TypeClass.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,112 @@\n+\/*\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.foreign.abi.aarch64.linux;\n+\n+import jdk.incubator.foreign.FunctionDescriptor;\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.internal.foreign.AbstractCLinker;\n+import jdk.internal.foreign.ResourceScopeImpl;\n+import jdk.internal.foreign.abi.SharedUtils;\n+import jdk.internal.foreign.abi.UpcallStubs;\n+import jdk.internal.foreign.abi.aarch64.CallArranger;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.util.Objects;\n+import java.util.function.Consumer;\n+\n+\/**\n+ * ABI implementation based on ARM document \"Procedure Call Standard for\n+ * the ARM 64-bit Architecture\".\n+ *\/\n+public final class LinuxAArch64Linker extends AbstractCLinker {\n+    private static LinuxAArch64Linker instance;\n+\n+    static final long ADDRESS_SIZE = 64; \/\/ bits\n+\n+    private static final MethodHandle MH_unboxVaList;\n+    private static final MethodHandle MH_boxVaList;\n+\n+    static {\n+        try {\n+            MethodHandles.Lookup lookup = MethodHandles.lookup();\n+            MH_unboxVaList = lookup.findVirtual(VaList.class, \"address\",\n+                MethodType.methodType(MemoryAddress.class));\n+            MH_boxVaList = MethodHandles.insertArguments(lookup.findStatic(LinuxAArch64Linker.class, \"newVaListOfAddress\",\n+                MethodType.methodType(VaList.class, MemoryAddress.class, ResourceScope.class)), 1, ResourceScope.globalScope());\n+        } catch (ReflectiveOperationException e) {\n+            throw new ExceptionInInitializerError(e);\n+        }\n+    }\n+\n+    public static LinuxAArch64Linker getInstance() {\n+        if (instance == null) {\n+            instance = new LinuxAArch64Linker();\n+        }\n+        return instance;\n+    }\n+\n+    @Override\n+    public final MethodHandle downcallHandle(MethodType type, FunctionDescriptor function) {\n+        Objects.requireNonNull(type);\n+        Objects.requireNonNull(function);\n+        MethodType llMt = SharedUtils.convertVaListCarriers(type, LinuxAArch64VaList.CARRIER);\n+        MethodHandle handle = CallArranger.arrangeDowncall(llMt, function);\n+        if (!type.returnType().equals(MemorySegment.class)) {\n+            \/\/ not returning segment, just insert a throwing allocator\n+            handle = MethodHandles.insertArguments(handle, 1, SharedUtils.THROWING_ALLOCATOR);\n+        }\n+        handle = SharedUtils.unboxVaLists(type, handle, MH_unboxVaList);\n+        return handle;\n+    }\n+\n+    @Override\n+    public final MemoryAddress upcallStub(MethodHandle target, FunctionDescriptor function, ResourceScope scope) {\n+        Objects.requireNonNull(scope);\n+        Objects.requireNonNull(target);\n+        Objects.requireNonNull(function);\n+        target = SharedUtils.boxVaLists(target, MH_boxVaList);\n+        return UpcallStubs.upcallAddress(CallArranger.arrangeUpcall(target, target.type(), function), (ResourceScopeImpl) scope);\n+    }\n+\n+    public static VaList newVaList(Consumer<VaList.Builder> actions, ResourceScope scope) {\n+        LinuxAArch64VaList.Builder builder = LinuxAArch64VaList.builder(scope);\n+        actions.accept(builder);\n+        return builder.build();\n+    }\n+\n+    public static VaList newVaListOfAddress(MemoryAddress ma, ResourceScope scope) {\n+        return LinuxAArch64VaList.ofAddress(ma, scope);\n+    }\n+\n+    public static VaList emptyVaList() {\n+        return LinuxAArch64VaList.empty();\n+    }\n+\n+}\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/linux\/LinuxAArch64Linker.java","additions":112,"deletions":0,"binary":false,"changes":112,"status":"added"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2020, Arm Limited. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Arm Limited. All rights reserved.\n@@ -26,1 +26,1 @@\n-package jdk.internal.foreign.abi.aarch64;\n+package jdk.internal.foreign.abi.aarch64.linux;\n@@ -31,0 +31,1 @@\n+import jdk.internal.foreign.abi.aarch64.*;\n@@ -49,1 +50,5 @@\n-public non-sealed class AArch64VaList implements VaList {\n+\/**\n+ * Standard va_list implementation as defined by AAPCS document and used on\n+ * Linux. Variadic parameters may be passed in registers or on the stack.\n+ *\/\n+public non-sealed class LinuxAArch64VaList implements VaList {\n@@ -108,1 +113,1 @@\n-    private AArch64VaList(MemorySegment segment, MemorySegment gpRegsArea, MemorySegment fpRegsArea) {\n+    private LinuxAArch64VaList(MemorySegment segment, MemorySegment gpRegsArea, MemorySegment fpRegsArea) {\n@@ -114,1 +119,1 @@\n-    private static AArch64VaList readFromSegment(MemorySegment segment) {\n+    private static LinuxAArch64VaList readFromSegment(MemorySegment segment) {\n@@ -120,1 +125,1 @@\n-        return new AArch64VaList(segment, gpRegsArea, fpRegsArea);\n+        return new LinuxAArch64VaList(segment, gpRegsArea, fpRegsArea);\n@@ -127,1 +132,1 @@\n-        cleaner.register(AArch64VaList.class, () -> ms.scope().close());\n+        cleaner.register(LinuxAArch64VaList.class, () -> ms.scope().close());\n@@ -249,1 +254,1 @@\n-        checkCompatibleType(carrier, layout, AArch64Linker.ADDRESS_SIZE);\n+        checkCompatibleType(carrier, layout, LinuxAArch64Linker.ADDRESS_SIZE);\n@@ -349,2 +354,2 @@\n-    static AArch64VaList.Builder builder(ResourceScope scope) {\n-        return new AArch64VaList.Builder(scope);\n+    static LinuxAArch64VaList.Builder builder(ResourceScope scope) {\n+        return new LinuxAArch64VaList.Builder(scope);\n@@ -366,1 +371,1 @@\n-        return new AArch64VaList(copy, gpRegsArea, fpRegsArea);\n+        return new LinuxAArch64VaList(copy, gpRegsArea, fpRegsArea);\n@@ -391,1 +396,1 @@\n-        return \"AArch64VaList{\"\n+        return \"LinuxAArch64VaList{\"\n@@ -443,1 +448,1 @@\n-            checkCompatibleType(carrier, layout, AArch64Linker.ADDRESS_SIZE);\n+            checkCompatibleType(carrier, layout, LinuxAArch64Linker.ADDRESS_SIZE);\n@@ -536,1 +541,1 @@\n-            return new AArch64VaList(vaListSegment, gpRegs, fpRegs);\n+            return new LinuxAArch64VaList(vaListSegment, gpRegs, fpRegs);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/linux\/LinuxAArch64VaList.java","additions":20,"deletions":15,"binary":false,"changes":35,"previous_filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/AArch64VaList.java","status":"renamed"},{"patch":"@@ -0,0 +1,116 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.foreign.abi.aarch64.macos;\n+\n+import jdk.incubator.foreign.Addressable;\n+import jdk.incubator.foreign.FunctionDescriptor;\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemoryLayout;\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.internal.foreign.AbstractCLinker;\n+import jdk.internal.foreign.ResourceScopeImpl;\n+import jdk.internal.foreign.abi.SharedUtils;\n+import jdk.internal.foreign.abi.UpcallStubs;\n+import jdk.internal.foreign.abi.aarch64.CallArranger;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.util.Objects;\n+import java.util.function.Consumer;\n+\n+import static jdk.internal.foreign.PlatformLayouts.*;\n+\n+\/**\n+ * ABI implementation for macOS on Apple silicon. Based on AAPCS with\n+ * changes to va_list and passing arguments on the stack.\n+ *\/\n+public final class MacOsAArch64Linker extends AbstractCLinker {\n+    private static MacOsAArch64Linker instance;\n+\n+    static final long ADDRESS_SIZE = 64; \/\/ bits\n+\n+    private static final MethodHandle MH_unboxVaList;\n+    private static final MethodHandle MH_boxVaList;\n+\n+    static {\n+        try {\n+            MethodHandles.Lookup lookup = MethodHandles.lookup();\n+            MH_unboxVaList = lookup.findVirtual(VaList.class, \"address\",\n+                MethodType.methodType(MemoryAddress.class));\n+            MH_boxVaList = MethodHandles.insertArguments(lookup.findStatic(MacOsAArch64Linker.class, \"newVaListOfAddress\",\n+                MethodType.methodType(VaList.class, MemoryAddress.class, ResourceScope.class)), 1, ResourceScope.globalScope());\n+        } catch (ReflectiveOperationException e) {\n+            throw new ExceptionInInitializerError(e);\n+        }\n+    }\n+\n+    public static MacOsAArch64Linker getInstance() {\n+        if (instance == null) {\n+            instance = new MacOsAArch64Linker();\n+        }\n+        return instance;\n+    }\n+\n+    @Override\n+    public final MethodHandle downcallHandle(MethodType type, FunctionDescriptor function) {\n+        Objects.requireNonNull(type);\n+        Objects.requireNonNull(function);\n+        MethodType llMt = SharedUtils.convertVaListCarriers(type, MacOsAArch64VaList.CARRIER);\n+        MethodHandle handle = CallArranger.arrangeDowncall(llMt, function);\n+        if (!type.returnType().equals(MemorySegment.class)) {\n+            \/\/ not returning segment, just insert a throwing allocator\n+            handle = MethodHandles.insertArguments(handle, 1, SharedUtils.THROWING_ALLOCATOR);\n+        }\n+        handle = SharedUtils.unboxVaLists(type, handle, MH_unboxVaList);\n+        return handle;\n+    }\n+\n+    @Override\n+    public final MemoryAddress upcallStub(MethodHandle target, FunctionDescriptor function, ResourceScope scope) {\n+        Objects.requireNonNull(scope);\n+        Objects.requireNonNull(target);\n+        Objects.requireNonNull(function);\n+        target = SharedUtils.boxVaLists(target, MH_boxVaList);\n+        return UpcallStubs.upcallAddress(CallArranger.arrangeUpcall(target, target.type(), function), (ResourceScopeImpl) scope);\n+    }\n+\n+    public static VaList newVaList(Consumer<VaList.Builder> actions, ResourceScope scope) {\n+        MacOsAArch64VaList.Builder builder = MacOsAArch64VaList.builder(scope);\n+        actions.accept(builder);\n+        return builder.build();\n+    }\n+\n+    public static VaList newVaListOfAddress(MemoryAddress ma, ResourceScope scope) {\n+        return MacOsAArch64VaList.ofAddress(ma, scope);\n+    }\n+\n+    public static VaList emptyVaList() {\n+        return MacOsAArch64VaList.empty();\n+    }\n+\n+}\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/macos\/MacOsAArch64Linker.java","additions":116,"deletions":0,"binary":false,"changes":116,"status":"added"},{"patch":"@@ -0,0 +1,256 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.foreign.abi.aarch64.macos;\n+\n+import jdk.incubator.foreign.*;\n+import jdk.incubator.foreign.CLinker.VaList;\n+import jdk.internal.foreign.ResourceScopeImpl;\n+import jdk.internal.foreign.abi.SharedUtils;\n+import jdk.internal.foreign.abi.SharedUtils.SimpleVaArg;\n+import jdk.internal.foreign.abi.aarch64.*;\n+\n+import java.lang.invoke.VarHandle;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+\n+import static jdk.internal.foreign.PlatformLayouts.AArch64.C_POINTER;\n+import static jdk.internal.foreign.abi.SharedUtils.alignUp;\n+\n+\/**\n+ * Simplified va_list implementation used on macOS where all variadic\n+ * parameters are passed on the stack and the type of va_list decays to\n+ * char* instead of the structure defined in the AAPCS.\n+ *\/\n+public non-sealed class MacOsAArch64VaList implements VaList {\n+    public static final Class<?> CARRIER = MemoryAddress.class;\n+    private static final long VA_SLOT_SIZE_BYTES = 8;\n+    private static final VarHandle VH_address = MemoryHandles.asAddressVarHandle(C_POINTER.varHandle(long.class));\n+\n+    private static final VaList EMPTY = new SharedUtils.EmptyVaList(MemoryAddress.NULL);\n+\n+    private MemorySegment segment;\n+    private final ResourceScope scope;\n+\n+    private MacOsAArch64VaList(MemorySegment segment, ResourceScope scope) {\n+        this.segment = segment;\n+        this.scope = scope;\n+    }\n+\n+    public static final VaList empty() {\n+        return EMPTY;\n+    }\n+\n+    @Override\n+    public int vargAsInt(MemoryLayout layout) {\n+        return (int) read(int.class, layout);\n+    }\n+\n+    @Override\n+    public long vargAsLong(MemoryLayout layout) {\n+        return (long) read(long.class, layout);\n+    }\n+\n+    @Override\n+    public double vargAsDouble(MemoryLayout layout) {\n+        return (double) read(double.class, layout);\n+    }\n+\n+    @Override\n+    public MemoryAddress vargAsAddress(MemoryLayout layout) {\n+        return (MemoryAddress) read(MemoryAddress.class, layout);\n+    }\n+\n+    @Override\n+    public MemorySegment vargAsSegment(MemoryLayout layout, SegmentAllocator allocator) {\n+        Objects.requireNonNull(allocator);\n+        return (MemorySegment) read(MemorySegment.class, layout, allocator);\n+    }\n+\n+    @Override\n+    public MemorySegment vargAsSegment(MemoryLayout layout, ResourceScope scope) {\n+        return vargAsSegment(layout, SegmentAllocator.ofScope(scope));\n+    }\n+\n+    private Object read(Class<?> carrier, MemoryLayout layout) {\n+        return read(carrier, layout, SharedUtils.THROWING_ALLOCATOR);\n+    }\n+\n+    private Object read(Class<?> carrier, MemoryLayout layout, SegmentAllocator allocator) {\n+        Objects.requireNonNull(layout);\n+        SharedUtils.checkCompatibleType(carrier, layout, MacOsAArch64Linker.ADDRESS_SIZE);\n+        Object res;\n+        if (carrier == MemorySegment.class) {\n+            TypeClass typeClass = TypeClass.classifyLayout(layout);\n+            res = switch (typeClass) {\n+                case STRUCT_REFERENCE -> {\n+                    MemoryAddress structAddr = (MemoryAddress) VH_address.get(segment);\n+                    MemorySegment struct = structAddr.asSegment(layout.byteSize(), scope());\n+                    MemorySegment seg = allocator.allocate(layout);\n+                    seg.copyFrom(struct);\n+                    segment = segment.asSlice(VA_SLOT_SIZE_BYTES);\n+                    yield seg;\n+                }\n+                case STRUCT_REGISTER, STRUCT_HFA -> {\n+                    MemorySegment struct = allocator.allocate(layout);\n+                    struct.copyFrom(segment.asSlice(0L, layout.byteSize()));\n+                    segment = segment.asSlice(alignUp(layout.byteSize(), VA_SLOT_SIZE_BYTES));\n+                    yield struct;\n+                }\n+                default -> throw new IllegalStateException(\"Unexpected TypeClass: \" + typeClass);\n+            };\n+        } else {\n+            VarHandle reader = SharedUtils.vhPrimitiveOrAddress(carrier, layout);\n+            res = reader.get(segment);\n+            segment = segment.asSlice(VA_SLOT_SIZE_BYTES);\n+        }\n+        return res;\n+    }\n+\n+    @Override\n+    public void skip(MemoryLayout... layouts) {\n+        Objects.requireNonNull(layouts);\n+\n+        for (MemoryLayout layout : layouts) {\n+            Objects.requireNonNull(layout);\n+            segment = segment.asSlice(switch (TypeClass.classifyLayout(layout)) {\n+                case STRUCT_REGISTER, STRUCT_HFA -> alignUp(layout.byteSize(), VA_SLOT_SIZE_BYTES);\n+                default -> VA_SLOT_SIZE_BYTES;\n+            });\n+        }\n+    }\n+\n+    static MacOsAArch64VaList ofAddress(MemoryAddress addr, ResourceScope scope) {\n+        MemorySegment segment = addr.asSegment(Long.MAX_VALUE, scope);\n+        return new MacOsAArch64VaList(segment, scope);\n+    }\n+\n+    static Builder builder(ResourceScope scope) {\n+        return new Builder(scope);\n+    }\n+\n+    @Override\n+    public ResourceScope scope() {\n+        return scope;\n+    }\n+\n+    @Override\n+    public VaList copy() {\n+        ((ResourceScopeImpl)scope).checkValidStateSlow();\n+        return new MacOsAArch64VaList(segment, scope);\n+    }\n+\n+    @Override\n+    public MemoryAddress address() {\n+        return segment.address();\n+    }\n+\n+    public static non-sealed class Builder implements VaList.Builder {\n+\n+        private final ResourceScope scope;\n+        private final List<SimpleVaArg> args = new ArrayList<>();\n+\n+        public Builder(ResourceScope scope) {\n+            ((ResourceScopeImpl)scope).checkValidStateSlow();\n+            this.scope = scope;\n+        }\n+\n+        private Builder arg(Class<?> carrier, MemoryLayout layout, Object value) {\n+            Objects.requireNonNull(layout);\n+            Objects.requireNonNull(value);\n+            SharedUtils.checkCompatibleType(carrier, layout, MacOsAArch64Linker.ADDRESS_SIZE);\n+            args.add(new SimpleVaArg(carrier, layout, value));\n+            return this;\n+        }\n+\n+        @Override\n+        public Builder vargFromInt(ValueLayout layout, int value) {\n+            return arg(int.class, layout, value);\n+        }\n+\n+        @Override\n+        public Builder vargFromLong(ValueLayout layout, long value) {\n+            return arg(long.class, layout, value);\n+        }\n+\n+        @Override\n+        public Builder vargFromDouble(ValueLayout layout, double value) {\n+            return arg(double.class, layout, value);\n+        }\n+\n+        @Override\n+        public Builder vargFromAddress(ValueLayout layout, Addressable value) {\n+            return arg(MemoryAddress.class, layout, value.address());\n+        }\n+\n+        @Override\n+        public Builder vargFromSegment(GroupLayout layout, MemorySegment value) {\n+            return arg(MemorySegment.class, layout, value);\n+        }\n+\n+        public VaList build() {\n+            if (args.isEmpty()) {\n+                return EMPTY;\n+            }\n+\n+            SegmentAllocator allocator = SegmentAllocator.arenaAllocator(scope);\n+\n+            \/\/ Each argument may occupy up to four slots\n+            MemorySegment segment = allocator.allocate(VA_SLOT_SIZE_BYTES * args.size() * 4);\n+\n+            List<MemorySegment> attachedSegments = new ArrayList<>();\n+            attachedSegments.add(segment);\n+            MemorySegment cursor = segment;\n+\n+            for (SimpleVaArg arg : args) {\n+                if (arg.carrier == MemorySegment.class) {\n+                    MemorySegment msArg = ((MemorySegment) arg.value);\n+                    TypeClass typeClass = TypeClass.classifyLayout(arg.layout);\n+                    switch (typeClass) {\n+                        case STRUCT_REFERENCE -> {\n+                            MemorySegment copy = allocator.allocate(arg.layout);\n+                            copy.copyFrom(msArg); \/\/ by-value\n+                            attachedSegments.add(copy);\n+                            VH_address.set(cursor, copy.address());\n+                            cursor = cursor.asSlice(VA_SLOT_SIZE_BYTES);\n+                        }\n+                        case STRUCT_REGISTER, STRUCT_HFA -> {\n+                            cursor.copyFrom(msArg.asSlice(0, arg.layout.byteSize()));\n+                            cursor = cursor.asSlice(alignUp(arg.layout.byteSize(), VA_SLOT_SIZE_BYTES));\n+                        }\n+                        default -> throw new IllegalStateException(\"Unexpected TypeClass: \" + typeClass);\n+                    }\n+                } else {\n+                    VarHandle writer = arg.varHandle();\n+                    writer.set(cursor, arg.value);\n+                    cursor = cursor.asSlice(VA_SLOT_SIZE_BYTES);\n+                }\n+            }\n+\n+            return new MacOsAArch64VaList(segment, scope);\n+        }\n+    }\n+}\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/macos\/MacOsAArch64VaList.java","additions":256,"deletions":0,"binary":false,"changes":256,"status":"added"},{"patch":"@@ -545,4 +545,0 @@\n-java\/foreign\/StdLibTest.java 8263512 macosx-aarch64\n-java\/foreign\/TestVarArgs.java 8263512 macosx-aarch64\n-java\/foreign\/valist\/VaListTest.java 8263512 macosx-aarch64\n-\n","filename":"test\/jdk\/ProblemList.txt","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,2 @@\n- *          jdk.incubator.foreign\/jdk.internal.foreign.abi.aarch64\n+ *          jdk.incubator.foreign\/jdk.internal.foreign.abi.aarch64.linux\n+ *          jdk.incubator.foreign\/jdk.internal.foreign.abi.aarch64.macos\n@@ -39,1 +40,2 @@\n-import jdk.internal.foreign.abi.aarch64.AArch64Linker;\n+import jdk.internal.foreign.abi.aarch64.linux.LinuxAArch64Linker;\n+import jdk.internal.foreign.abi.aarch64.macos.MacOsAArch64Linker;\n@@ -59,0 +61,1 @@\n+import static jdk.incubator.foreign.CLinker.C_LONG;\n@@ -116,2 +119,4 @@\n-    private static final Function<Consumer<VaList.Builder>, VaList> aarch64VaListFactory\n-            = actions -> AArch64Linker.newVaList(actions, ResourceScope.newConfinedScope());\n+    private static final Function<Consumer<VaList.Builder>, VaList> linuxAArch64VaListFactory\n+            = actions -> LinuxAArch64Linker.newVaList(actions, ResourceScope.newConfinedScope());\n+    private static final Function<Consumer<VaList.Builder>, VaList> macAArch64VaListFactory\n+            = actions -> MacOsAArch64Linker.newVaList(actions, ResourceScope.newConfinedScope());\n@@ -125,2 +130,4 @@\n-    private static final BiFunction<Consumer<VaList.Builder>, NativeScope, VaList> aarch64VaListScopedFactory\n-            = (builder, scope) -> AArch64Linker.newVaList(builder, scope.scope());\n+    private static final BiFunction<Consumer<VaList.Builder>, NativeScope, VaList> linuxAArch64VaListScopedFactory\n+            = (builder, scope) -> LinuxAArch64Linker.newVaList(builder, scope.scope());\n+    private static final BiFunction<Consumer<VaList.Builder>, NativeScope, VaList> macAArch64VaListScopedFactory\n+            = (builder, scope) -> MacOsAArch64Linker.newVaList(builder, scope.scope());\n@@ -138,4 +145,5 @@\n-                { winVaListFactory,      sumIntsJavaFact.apply(Win64.C_INT),   Win64.C_INT   },\n-                { sysvVaListFactory,     sumIntsJavaFact.apply(SysV.C_INT),    SysV.C_INT    },\n-                { aarch64VaListFactory,  sumIntsJavaFact.apply(AArch64.C_INT), AArch64.C_INT },\n-                { platformVaListFactory, sumIntsNative,                        C_INT         },\n+                { winVaListFactory,          sumIntsJavaFact.apply(Win64.C_INT),   Win64.C_INT   },\n+                { sysvVaListFactory,         sumIntsJavaFact.apply(SysV.C_INT),    SysV.C_INT    },\n+                { linuxAArch64VaListFactory, sumIntsJavaFact.apply(AArch64.C_INT), AArch64.C_INT },\n+                { macAArch64VaListFactory,   sumIntsJavaFact.apply(AArch64.C_INT), AArch64.C_INT },\n+                { platformVaListFactory,     sumIntsNative,                        C_INT         },\n@@ -166,4 +174,5 @@\n-                { winVaListFactory,      sumDoublesJavaFact.apply(Win64.C_DOUBLE),   Win64.C_DOUBLE   },\n-                { sysvVaListFactory,     sumDoublesJavaFact.apply(SysV.C_DOUBLE),    SysV.C_DOUBLE    },\n-                { aarch64VaListFactory,  sumDoublesJavaFact.apply(AArch64.C_DOUBLE), AArch64.C_DOUBLE },\n-                { platformVaListFactory, sumDoublesNative,                           C_DOUBLE         },\n+                { winVaListFactory,          sumDoublesJavaFact.apply(Win64.C_DOUBLE),   Win64.C_DOUBLE   },\n+                { sysvVaListFactory,         sumDoublesJavaFact.apply(SysV.C_DOUBLE),    SysV.C_DOUBLE    },\n+                { linuxAArch64VaListFactory, sumDoublesJavaFact.apply(AArch64.C_DOUBLE), AArch64.C_DOUBLE },\n+                { macAArch64VaListFactory,   sumDoublesJavaFact.apply(AArch64.C_DOUBLE), AArch64.C_DOUBLE },\n+                { platformVaListFactory,     sumDoublesNative,                           C_DOUBLE         },\n@@ -196,4 +205,5 @@\n-                { winVaListFactory,      getIntJavaFact.apply(Win64.C_POINTER),   Win64.C_POINTER   },\n-                { sysvVaListFactory,     getIntJavaFact.apply(SysV.C_POINTER),    SysV.C_POINTER    },\n-                { aarch64VaListFactory,  getIntJavaFact.apply(AArch64.C_POINTER), AArch64.C_POINTER },\n-                { platformVaListFactory, getIntNative,                            C_POINTER         },\n+                { winVaListFactory,          getIntJavaFact.apply(Win64.C_POINTER),   Win64.C_POINTER   },\n+                { sysvVaListFactory,         getIntJavaFact.apply(SysV.C_POINTER),    SysV.C_POINTER    },\n+                { linuxAArch64VaListFactory, getIntJavaFact.apply(AArch64.C_POINTER), AArch64.C_POINTER },\n+                { macAArch64VaListFactory,   getIntJavaFact.apply(AArch64.C_POINTER), AArch64.C_POINTER },\n+                { platformVaListFactory,     getIntNative,                            C_POINTER         },\n@@ -250,4 +260,5 @@\n-                argsFact.apply(winVaListFactory,      Win64.C_INT,   sumStructJavaFact),\n-                argsFact.apply(sysvVaListFactory,     SysV.C_INT,    sumStructJavaFact),\n-                argsFact.apply(aarch64VaListFactory,  AArch64.C_INT, sumStructJavaFact),\n-                argsFact.apply(platformVaListFactory, C_INT,         sumStructNativeFact),\n+                argsFact.apply(winVaListFactory,          Win64.C_INT,   sumStructJavaFact),\n+                argsFact.apply(sysvVaListFactory,         SysV.C_INT,    sumStructJavaFact),\n+                argsFact.apply(linuxAArch64VaListFactory, AArch64.C_INT, sumStructJavaFact),\n+                argsFact.apply(macAArch64VaListFactory,   AArch64.C_INT, sumStructJavaFact),\n+                argsFact.apply(platformVaListFactory,     C_INT,         sumStructNativeFact),\n@@ -302,4 +313,5 @@\n-                argsFact.apply(winVaListFactory,      Win64.C_LONG_LONG,   sumStructJavaFact),\n-                argsFact.apply(sysvVaListFactory,     SysV.C_LONG_LONG,    sumStructJavaFact),\n-                argsFact.apply(aarch64VaListFactory,  AArch64.C_LONG_LONG, sumStructJavaFact),\n-                argsFact.apply(platformVaListFactory, C_LONG_LONG,         sumStructNativeFact),\n+                argsFact.apply(winVaListFactory,          Win64.C_LONG_LONG,   sumStructJavaFact),\n+                argsFact.apply(sysvVaListFactory,         SysV.C_LONG_LONG,    sumStructJavaFact),\n+                argsFact.apply(linuxAArch64VaListFactory, AArch64.C_LONG_LONG, sumStructJavaFact),\n+                argsFact.apply(macAArch64VaListFactory,   AArch64.C_LONG_LONG, sumStructJavaFact),\n+                argsFact.apply(platformVaListFactory,     C_LONG_LONG,         sumStructNativeFact),\n@@ -354,4 +366,5 @@\n-                argsFact.apply(winVaListFactory,      Win64.C_FLOAT,   sumStructJavaFact),\n-                argsFact.apply(sysvVaListFactory,     SysV.C_FLOAT,    sumStructJavaFact),\n-                argsFact.apply(aarch64VaListFactory,  AArch64.C_FLOAT, sumStructJavaFact),\n-                argsFact.apply(platformVaListFactory, C_FLOAT,         sumStructNativeFact),\n+                argsFact.apply(winVaListFactory,          Win64.C_FLOAT,   sumStructJavaFact),\n+                argsFact.apply(sysvVaListFactory,         SysV.C_FLOAT,    sumStructJavaFact),\n+                argsFact.apply(linuxAArch64VaListFactory, AArch64.C_FLOAT, sumStructJavaFact),\n+                argsFact.apply(macAArch64VaListFactory,   AArch64.C_FLOAT, sumStructJavaFact),\n+                argsFact.apply(platformVaListFactory,     C_FLOAT,         sumStructNativeFact),\n@@ -415,4 +428,5 @@\n-                argsFact.apply(winVaListFactory,      Win64.C_LONG_LONG,   sumStructJavaFact),\n-                argsFact.apply(sysvVaListFactory,     SysV.C_LONG_LONG,    sumStructJavaFact),\n-                argsFact.apply(aarch64VaListFactory,  AArch64.C_LONG_LONG, sumStructJavaFact),\n-                argsFact.apply(platformVaListFactory, C_LONG_LONG,         sumStructNativeFact),\n+                argsFact.apply(winVaListFactory,          Win64.C_LONG_LONG,   sumStructJavaFact),\n+                argsFact.apply(sysvVaListFactory,         SysV.C_LONG_LONG,    sumStructJavaFact),\n+                argsFact.apply(linuxAArch64VaListFactory, AArch64.C_LONG_LONG, sumStructJavaFact),\n+                argsFact.apply(macAArch64VaListFactory,   AArch64.C_LONG_LONG, sumStructJavaFact),\n+                argsFact.apply(platformVaListFactory,     C_LONG_LONG,         sumStructNativeFact),\n@@ -469,4 +483,5 @@\n-                { winVaListFactory,      sumStackJavaFact.apply(Win64.C_LONG_LONG, Win64.C_DOUBLE),     Win64.C_LONG_LONG,   Win64.C_DOUBLE   },\n-                { sysvVaListFactory,     sumStackJavaFact.apply(SysV.C_LONG_LONG, SysV.C_DOUBLE),       SysV.C_LONG_LONG,    SysV.C_DOUBLE    },\n-                { aarch64VaListFactory,  sumStackJavaFact.apply(AArch64.C_LONG_LONG, AArch64.C_DOUBLE), AArch64.C_LONG_LONG, AArch64.C_DOUBLE },\n-                { platformVaListFactory, sumStackNative,                                                C_LONG_LONG,         C_DOUBLE         },\n+                { winVaListFactory,           sumStackJavaFact.apply(Win64.C_LONG_LONG, Win64.C_DOUBLE),     Win64.C_LONG_LONG,   Win64.C_DOUBLE   },\n+                { sysvVaListFactory,          sumStackJavaFact.apply(SysV.C_LONG_LONG, SysV.C_DOUBLE),       SysV.C_LONG_LONG,    SysV.C_DOUBLE    },\n+                { linuxAArch64VaListFactory,  sumStackJavaFact.apply(AArch64.C_LONG_LONG, AArch64.C_DOUBLE), AArch64.C_LONG_LONG, AArch64.C_DOUBLE },\n+                { macAArch64VaListFactory,    sumStackJavaFact.apply(AArch64.C_LONG_LONG, AArch64.C_DOUBLE), AArch64.C_LONG_LONG, AArch64.C_DOUBLE },\n+                { platformVaListFactory,      sumStackNative,                                                C_LONG_LONG,         C_DOUBLE         },\n@@ -522,6 +537,8 @@\n-                { Windowsx64Linker.emptyVaList()      },\n-                { winVaListFactory.apply(b -> {})     },\n-                { SysVx64Linker.emptyVaList()         },\n-                { sysvVaListFactory.apply(b -> {})    },\n-                { AArch64Linker.emptyVaList()         },\n-                { aarch64VaListFactory.apply(b -> {}) },\n+                { Windowsx64Linker.emptyVaList()           },\n+                { winVaListFactory.apply(b -> {})          },\n+                { SysVx64Linker.emptyVaList()              },\n+                { sysvVaListFactory.apply(b -> {})         },\n+                { LinuxAArch64Linker.emptyVaList()         },\n+                { linuxAArch64VaListFactory.apply(b -> {}) },\n+                { MacOsAArch64Linker.emptyVaList()         },\n+                { macAArch64VaListFactory.apply(b -> {})   },\n@@ -546,4 +563,5 @@\n-                { winVaListScopedFactory,      sumIntsJavaFact.apply(Win64.C_INT),   Win64.C_INT   },\n-                { sysvVaListScopedFactory,     sumIntsJavaFact.apply(SysV.C_INT),    SysV.C_INT    },\n-                { aarch64VaListScopedFactory,  sumIntsJavaFact.apply(AArch64.C_INT), AArch64.C_INT },\n-                { platformVaListScopedFactory, sumIntsNative,                        C_INT         },\n+                { winVaListScopedFactory,          sumIntsJavaFact.apply(Win64.C_INT),   Win64.C_INT   },\n+                { sysvVaListScopedFactory,         sumIntsJavaFact.apply(SysV.C_INT),    SysV.C_INT    },\n+                { linuxAArch64VaListScopedFactory, sumIntsJavaFact.apply(AArch64.C_INT), AArch64.C_INT },\n+                { macAArch64VaListScopedFactory,   sumIntsJavaFact.apply(AArch64.C_INT), AArch64.C_INT },\n+                { platformVaListScopedFactory,     sumIntsNative,                        C_INT         },\n@@ -594,3 +612,4 @@\n-                { winVaListFactory,      Win64.C_INT   },\n-                { sysvVaListFactory,     SysV.C_INT    },\n-                { aarch64VaListFactory,  AArch64.C_INT },\n+                { winVaListFactory,          Win64.C_INT   },\n+                { sysvVaListFactory,         SysV.C_INT    },\n+                { linuxAArch64VaListFactory, AArch64.C_INT },\n+                { macAArch64VaListFactory,   AArch64.C_INT },\n@@ -681,0 +700,11 @@\n+                { linkVaListCB(\"upcallBigStructPlusScalar\"), VaListConsumer.mh(vaList -> {\n+                    MemorySegment struct = vaList.vargAsSegment(BigPoint_LAYOUT, ResourceScope.newImplicitScope());\n+                    assertEquals((long) VH_BigPoint_x.get(struct), 8);\n+                    assertEquals((long) VH_BigPoint_y.get(struct), 16);\n+\n+                    assertEquals(vaList.vargAsLong(C_LONG_LONG), 42);\n+                })},\n+                { linkVaListCB(\"upcallBigStructPlusScalar\"), VaListConsumer.mh(vaList -> {\n+                    vaList.skip(BigPoint_LAYOUT);\n+                    assertEquals(vaList.vargAsLong(C_LONG_LONG), 42);\n+                })},\n","filename":"test\/jdk\/java\/foreign\/valist\/VaListTest.java","additions":82,"deletions":52,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -175,0 +175,7 @@\n+EXPORT void upcallBigStructPlusScalar(CB cb) {\n+    BigPoint point;\n+    point.x = 8;\n+    point.y = 16;\n+    passToUpcall(cb, 2, point, 42);\n+}\n+\n","filename":"test\/jdk\/java\/foreign\/valist\/libVaList.c","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"}]}