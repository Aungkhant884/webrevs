{"files":[{"patch":"@@ -200,47 +200,0 @@\n-class RemoveSelfForwardPtrHRClosure: public HeapRegionClosure {\n-  G1CollectedHeap* _g1h;\n-  uint _worker_id;\n-\n-  G1EvacFailureRegions* _evac_failure_regions;\n-\n-  G1GCPhaseTimes* _phase_times;\n-\n-public:\n-  RemoveSelfForwardPtrHRClosure(uint worker_id,\n-                                G1EvacFailureRegions* evac_failure_regions) :\n-    _g1h(G1CollectedHeap::heap()),\n-    _worker_id(worker_id),\n-    _evac_failure_regions(evac_failure_regions),\n-    _phase_times(G1CollectedHeap::heap()->phase_times()) {\n-  }\n-\n-  bool do_heap_region(HeapRegion *hr) {\n-    assert(!hr->is_pinned(), \"Unexpected pinned region at index %u\", hr->hrm_index());\n-    assert(hr->in_collection_set(), \"bad CS\");\n-    assert(_evac_failure_regions->contains(hr->hrm_index()), \"precondition\");\n-\n-    hr->clear_index_in_opt_cset();\n-\n-    bool during_concurrent_start = _g1h->collector_state()->in_concurrent_start_gc();\n-    bool during_concurrent_mark = _g1h->collector_state()->mark_or_rebuild_in_progress();\n-\n-    hr->note_self_forwarding_removal_start(during_concurrent_start,\n-                                           during_concurrent_mark);\n-\n-    hr->reset_bot();\n-\n-    _phase_times->record_or_add_thread_work_item(G1GCPhaseTimes::RestoreRetainedRegions,\n-                                                 _worker_id,\n-                                                 1,\n-                                                 G1GCPhaseTimes::RestoreRetainedRegionsNum);\n-\n-    hr->rem_set()->clean_strong_code_roots(hr);\n-    hr->rem_set()->clear_locked(true);\n-\n-    hr->note_self_forwarding_removal_start_2();\n-    _g1h->verifier()->check_bitmaps(\"Self-Forwarding Ptr Removal\", hr);\n-\n-    return false;\n-  }\n-};\n-\n@@ -254,1 +207,0 @@\n-  RemoveSelfForwardPtrHRClosure prepare_region_closure(worker_id, _evac_failure_regions);\n@@ -262,1 +214,1 @@\n-  _evac_failure_regions->par_iterate_chunks_in_regions(&prepare_region_closure, &chunk_closure, worker_id);\n+  _evac_failure_regions->par_iterate_chunks_in_regions(&chunk_closure, worker_id);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1EvacFailure.cpp","additions":1,"deletions":49,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -39,1 +39,3 @@\n-  _max_regions(0) {\n+  _max_regions(0),\n+  _heap(G1CollectedHeap::heap()),\n+  _phase_times(_heap->phase_times()) {\n@@ -79,2 +81,1 @@\n-void G1EvacFailureRegions::par_iterate_chunks_in_regions(HeapRegionClosure* prepare_region_closure,\n-                                                         G1HeapRegionChunkClosure* chunk_closure,\n+void G1EvacFailureRegions::par_iterate_chunks_in_regions(G1HeapRegionChunkClosure* chunk_closure,\n@@ -82,1 +83,1 @@\n-  G1ScanChunksInHeapRegionClosure closure(_chunk_claimers, prepare_region_closure, chunk_closure, worker_id);\n+  G1ScanChunksInHeapRegionClosure closure(_chunk_claimers, chunk_closure, worker_id);\n@@ -95,0 +96,22 @@\n+\n+void G1EvacFailureRegions::prepare_region(uint region_idx) {\n+  HeapRegion* hr = _heap->region_at(region_idx);\n+  assert(!hr->is_pinned(), \"Unexpected pinned region at index %u\", hr->hrm_index());\n+  assert(hr->in_collection_set(), \"bad CS\");\n+  assert(contains(hr->hrm_index()), \"precondition\");\n+\n+  hr->clear_index_in_opt_cset();\n+\n+  bool during_concurrent_start = _heap->collector_state()->in_concurrent_start_gc();\n+  bool during_concurrent_mark = _heap->collector_state()->mark_or_rebuild_in_progress();\n+\n+  hr->note_self_forwarding_removal_start(during_concurrent_start,\n+                                         during_concurrent_mark);\n+\n+  hr->reset_bot();\n+\n+  _phase_times->record_or_add_thread_work_item(G1GCPhaseTimes::RestoreRetainedRegions,\n+                                               0,\n+                                               1,\n+                                               G1GCPhaseTimes::RestoreRetainedRegionsNum);\n+}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1EvacFailureRegions.cpp","additions":27,"deletions":4,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -50,0 +50,5 @@\n+  G1CollectedHeap* _heap;\n+  G1GCPhaseTimes* _phase_times;\n+\n+  \/\/ Do necessary preparation for evacuation failure regions\n+  void prepare_region(uint region_idx);\n@@ -65,2 +70,1 @@\n-  void par_iterate_chunks_in_regions(HeapRegionClosure* prepare_region_closure,\n-                                     G1HeapRegionChunkClosure* chunk_closure,\n+  void par_iterate_chunks_in_regions(G1HeapRegionChunkClosure* chunk_closure,\n","filename":"src\/hotspot\/share\/gc\/g1\/g1EvacFailureRegions.hpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+    prepare_region(region_idx);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1EvacFailureRegions.inline.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -106,2 +106,0 @@\n-  _gc_par_phases[PrepareRetainedRegions] = new WorkerDataArray<double>(\"PrepareRetainedRegions\", \"Prepared Retained Regions (ms):\", max_gc_threads);\n-  _gc_par_phases[WaitReadyRetainedRegions] = new WorkerDataArray<double>(\"WaitReadyRetainedRegions\", \"Wait For Ready In Retained Regions (ms):\", max_gc_threads);\n@@ -119,0 +117,1 @@\n+  _gc_par_phases[VerifyAfterSelfForwardingPtrRemoval] = new WorkerDataArray<double>(\"VerifyAfterSelfForwardingPtrRemoval\", \"Verify Retained Regions (ms):\", max_gc_threads);\n@@ -495,2 +494,0 @@\n-    debug_phase(_gc_par_phases[PrepareRetainedRegions], 2);\n-    debug_phase(_gc_par_phases[WaitReadyRetainedRegions], 2);\n@@ -506,0 +503,1 @@\n+    debug_phase(_gc_par_phases[VerifyAfterSelfForwardingPtrRemoval], 1);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1GCPhaseTimes.cpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -81,2 +81,0 @@\n-    PrepareRetainedRegions,\n-    WaitReadyRetainedRegions,\n@@ -94,0 +92,1 @@\n+    VerifyAfterSelfForwardingPtrRemoval,\n","filename":"src\/hotspot\/share\/gc\/g1\/g1GCPhaseTimes.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -56,2 +56,0 @@\n-  _region_claimed(false),\n-  _region_ready(region_ready),\n@@ -66,15 +64,0 @@\n-void G1HeapRegionChunksClaimer::prepare_region(HeapRegionClosure* prepare_region_closure, uint worker_id) {\n-  G1GCPhaseTimes* p = G1CollectedHeap::heap()->phase_times();\n-  G1GCPhaseTimes::GCParPhases phase;\n-  Ticks start = Ticks::now();\n-  if (claim_prepare_region()) {\n-    phase = G1GCPhaseTimes::PrepareRetainedRegions;\n-    prepare_region_closure->do_heap_region(G1CollectedHeap::heap()->region_at(_region_idx));\n-    set_region_ready();\n-  } else {\n-    phase = G1GCPhaseTimes::WaitReadyRetainedRegions;\n-    while (!region_ready());\n-  }\n-  p->record_or_add_time_secs(phase, worker_id, (Ticks::now() - start).seconds());\n-}\n-\n@@ -82,1 +65,0 @@\n-                                                                 HeapRegionClosure* prepare_region_closure,\n@@ -86,1 +68,0 @@\n-  _prepare_region_closure(prepare_region_closure),\n@@ -93,1 +74,1 @@\n-  G1GCPhaseTimes* p = G1CollectedHeap::heap()->phase_times();\n+  G1GCPhaseTimes* phase_times = G1CollectedHeap::heap()->phase_times();\n@@ -95,1 +76,0 @@\n-  claimer->prepare_region(_prepare_region_closure, _worker_id);\n@@ -105,1 +85,1 @@\n-      p->record_or_add_time_secs(G1GCPhaseTimes::PrepareChunks, _worker_id, (Ticks::now() - start2).seconds());\n+      phase_times->record_or_add_time_secs(G1GCPhaseTimes::PrepareChunks, _worker_id, (Ticks::now() - start2).seconds());\n@@ -108,1 +88,1 @@\n-        p->record_or_add_thread_work_item(G1GCPhaseTimes::RemoveSelfForwardsInChunks, _worker_id, 1, G1GCPhaseTimes::RemoveSelfForwardEmptyChunksNum);\n+        phase_times->record_or_add_thread_work_item(G1GCPhaseTimes::RemoveSelfForwardsInChunks, _worker_id, 1, G1GCPhaseTimes::RemoveSelfForwardEmptyChunksNum);\n@@ -111,1 +91,1 @@\n-      p->record_or_add_thread_work_item(G1GCPhaseTimes::RemoveSelfForwardsInChunks, _worker_id, 1, G1GCPhaseTimes::RemoveSelfForwardChunksNum);\n+      phase_times->record_or_add_thread_work_item(G1GCPhaseTimes::RemoveSelfForwardsInChunks, _worker_id, 1, G1GCPhaseTimes::RemoveSelfForwardChunksNum);\n@@ -114,1 +94,1 @@\n-      p->record_or_add_time_secs(G1GCPhaseTimes::RemoveSelfForwardsInChunks, _worker_id, (Ticks::now() - start).seconds());\n+      phase_times->record_or_add_time_secs(G1GCPhaseTimes::RemoveSelfForwardsInChunks, _worker_id, (Ticks::now() - start).seconds());\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegionChunk.cpp","additions":5,"deletions":25,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -93,2 +93,0 @@\n-  volatile bool _region_claimed;\n-  volatile bool _region_ready;\n@@ -97,10 +95,0 @@\n-  bool claim_prepare_region() {\n-    return !Atomic::cmpxchg(&_region_claimed, false, true);\n-  }\n-  bool region_ready() {\n-    return Atomic::load(&_region_ready);\n-  }\n-  void set_region_ready() {\n-    Atomic::store(&_region_ready, true);\n-  }\n-\n@@ -118,2 +106,0 @@\n-\n-  void prepare_region(HeapRegionClosure* prepare_region_closure, uint worker_id);\n@@ -125,2 +111,0 @@\n-  \/\/ Preparation closure for a single region.\n-  HeapRegionClosure* _prepare_region_closure;\n@@ -133,1 +117,0 @@\n-                                  HeapRegionClosure* prepare_region_closure,\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegionChunk.hpp","additions":0,"deletions":17,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -70,0 +70,2 @@\n+  G1EvacFailureRegions* _evac_failure_regions;\n+\n@@ -71,1 +73,3 @@\n-  SampleCollectionSetCandidatesTask() : G1AbstractSubTask(G1GCPhaseTimes::SampleCollectionSetCandidates) { }\n+  SampleCollectionSetCandidatesTask(G1EvacFailureRegions* evac_failure_regions) :\n+    G1AbstractSubTask(G1GCPhaseTimes::SampleCollectionSetCandidates),\n+    _evac_failure_regions(evac_failure_regions) { }\n@@ -84,0 +88,1 @@\n+      G1EvacFailureRegions* _evac_failure_regions;\n@@ -87,2 +92,13 @@\n-      bool do_heap_region(HeapRegion* r) override {\n-        _total.add(r->rem_set()->card_set_memory_stats());\n+      G1SampleCollectionSetCandidatesClosure(G1EvacFailureRegions* evac_failure_regions) :\n+        _evac_failure_regions(evac_failure_regions) { }\n+\n+      bool do_heap_region(HeapRegion* hr) override {\n+        _total.add(hr->rem_set()->card_set_memory_stats());\n+\n+        \/\/ Put the clearing code here on purpose to make sure the rem set data\n+        \/\/ is cleared only after syncing.\n+        \/\/ It also avoid race condition by putting the clearing code here.\n+        if (_evac_failure_regions->contains(hr->hrm_index())) {\n+          hr->rem_set()->clean_strong_code_roots(hr);\n+          hr->rem_set()->clear_locked(true);\n+        }\n@@ -91,1 +107,1 @@\n-    } cl;\n+    } cl(_evac_failure_regions);\n@@ -129,1 +145,1 @@\n-    add_serial_task(new SampleCollectionSetCandidatesTask());\n+    add_serial_task(new SampleCollectionSetCandidatesTask(evac_failure_regions));\n@@ -360,0 +376,34 @@\n+class G1PostEvacuateCollectionSetCleanupTask2::VerifyAfterSelfForwardingPtrRemovalTask : public G1AbstractSubTask {\n+  G1EvacFailureRegions* _evac_failure_regions;\n+  HeapRegionClaimer _claimer;\n+\n+  class VerifyRegionClosure : public HeapRegionClosure {\n+  public:\n+    bool do_heap_region(HeapRegion* hr) override {\n+      G1CollectedHeap::heap()->verifier()->check_bitmaps(\"Self-Forwarding Ptr Removal\", hr);\n+      return false;\n+    }\n+  };\n+\n+public:\n+  VerifyAfterSelfForwardingPtrRemovalTask(G1EvacFailureRegions* evac_failure_regions) :\n+    G1AbstractSubTask(G1GCPhaseTimes::VerifyAfterSelfForwardingPtrRemoval),\n+    _evac_failure_regions(evac_failure_regions),\n+    _claimer(0) {\n+    assert(G1VerifyBitmaps && _evac_failure_regions->evacuation_failed(), \"precondition\");\n+  }\n+\n+  void set_max_workers(uint max_workers) override {\n+    _claimer.set_n_workers(max_workers);\n+  }\n+\n+  double worker_cost() const override {\n+    return _evac_failure_regions->num_regions_failed_evacuation();\n+  }\n+\n+  void do_work(uint worker_id) override {\n+    VerifyRegionClosure closure;\n+    _evac_failure_regions->par_iterate(&closure, &_claimer, worker_id);\n+  }\n+};\n+\n@@ -682,0 +732,3 @@\n+    if (G1VerifyBitmaps) {\n+      add_parallel_task(new VerifyAfterSelfForwardingPtrRemovalTask(evac_failure_regions));\n+    }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCPostEvacuateTasks.cpp","additions":58,"deletions":5,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -71,0 +71,1 @@\n+  class VerifyAfterSelfForwardingPtrRemovalTask;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCPostEvacuateTasks.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -282,0 +282,1 @@\n+  _prev_top_at_mark_start = top();\n@@ -298,4 +299,0 @@\n-void HeapRegion::note_self_forwarding_removal_start_2() {\n-  _prev_top_at_mark_start = top();\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.cpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -513,4 +513,3 @@\n-  \/\/ Notify the region that we have finished processing self-forwarded\n-  \/\/ objects during evac failure handling.\n-  void note_self_forwarding_removal_start_2();\n-  void note_self_forwarding_removal_end_par(size_t mared_bytes);\n+  \/\/ Notify the region that we have partially finished processing self-forwarded\n+  \/\/ objects during evacuation failure handling.\n+  void note_self_forwarding_removal_end_par(size_t marked_bytes);\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.hpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"}]}