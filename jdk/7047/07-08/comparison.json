{"files":[{"patch":"@@ -171,10 +171,2 @@\n-    if (_region_idx == _g1h->max_regions()) {\n-      _region_idx = current_region_idx;\n-      _marked_words = rspc.marked_words();\n-    } else if (_region_idx == current_region_idx) {\n-      _marked_words += rspc.marked_words();\n-    } else {\n-      _g1h->region_at(_region_idx)->note_self_forwarding_removal_end_par(_marked_words * BytesPerWord);\n-      _region_idx = current_region_idx;\n-      _marked_words = rspc.marked_words();\n-    }\n+    update_states(current_region_idx, rspc.marked_words());\n+\n@@ -191,0 +183,13 @@\n+  void update_states(uint current_region_idx, size_t marked_words) {\n+    if (_region_idx == _g1h->max_regions()) {\n+      _region_idx = current_region_idx;\n+      _marked_words = marked_words;\n+    } else if (_region_idx == current_region_idx) {\n+      _marked_words += marked_words;\n+    } else {\n+      _g1h->region_at(_region_idx)->note_self_forwarding_removal_end_par(_marked_words * BytesPerWord);\n+      _region_idx = current_region_idx;\n+      _marked_words = marked_words;\n+    }\n+  }\n+\n@@ -195,1 +200,1 @@\n-    _region_idx(),\n+    _region_idx(_g1h->max_regions()),\n@@ -214,1 +219,0 @@\n-  _hrclaimer(_g1h->workers()->active_workers()),\n@@ -218,1 +222,0 @@\n-  uint max_regions = _evac_failure_regions->max_regions();\n@@ -230,0 +233,4 @@\n+\n+void G1ParRemoveSelfForwardPtrsTask::initialize_chunks(uint active_workers) {\n+  _evac_failure_regions->initialize_chunks(active_workers);\n+}\n\\ No newline at end of file\n","filename":"src\/hotspot\/share\/gc\/g1\/g1EvacFailure.cpp","additions":20,"deletions":13,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -41,1 +41,0 @@\n-  HeapRegionClaimer _hrclaimer;\n@@ -52,0 +51,2 @@\n+\n+  void initialize_chunks(uint active_workers);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1EvacFailure.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-  _chunk_claimers(nullptr),\n+  _chunks_in_regions(nullptr),\n@@ -46,1 +46,1 @@\n-  assert(_chunk_claimers == nullptr, \"not cleaned up\");\n+  assert(_chunks_in_regions == nullptr, \"not cleaned up\");\n@@ -54,1 +54,1 @@\n-  _chunk_claimers = NEW_C_HEAP_ARRAY(G1HeapRegionChunksClaimer*, _max_regions, mtGC);\n+  _chunks_in_regions = new (NEW_C_HEAP_OBJ(G1ScanChunksInHeapRegions, mtGC)) G1ScanChunksInHeapRegions();\n@@ -60,5 +60,2 @@\n-  for (uint i = 0; i < _evac_failure_regions_cur_length; i++) {\n-    FREE_C_HEAP_OBJ(_chunk_claimers[_evac_failure_regions[i]]);\n-  }\n-  FREE_C_HEAP_ARRAY(uint, _chunk_claimers);\n-  _chunk_claimers = nullptr;\n+  FREE_C_HEAP_OBJ(_chunks_in_regions);\n+  _chunks_in_regions = nullptr;\n@@ -86,0 +83,6 @@\n+void G1EvacFailureRegions::initialize_chunks(uint num_workers) {\n+  _chunks_in_regions->initialize(_evac_failure_regions,\n+                                 Atomic::load(&_evac_failure_regions_cur_length),\n+                                 num_workers);\n+}\n+\n@@ -88,7 +91,1 @@\n-  G1ScanChunksInHeapRegionClosure closure(_chunk_claimers, chunk_closure, worker_id);\n-\n-  G1CollectedHeap::heap()->par_iterate_regions_array(&closure,\n-                                                     nullptr, \/\/ pass null, so every worker thread go through every region.\n-                                                     _evac_failure_regions,\n-                                                     Atomic::load(&_evac_failure_regions_cur_length),\n-                                                     worker_id);\n+  _chunks_in_regions->par_iterate_chunks_in_regions(chunk_closure, worker_id);\n@@ -103,1 +100,1 @@\n-    G1EvacFailureRegions* _evac_failure_regions;\n+    const G1EvacFailureRegions* _evac_failure_regions;\n@@ -105,0 +102,29 @@\n+\n+    void prepare_region(uint region_idx, uint worker_id) {\n+      G1CollectedHeap* _heap = G1CollectedHeap::heap();\n+      G1GCPhaseTimes* p = _heap->phase_times();\n+      HeapRegion* hr = _heap->region_at(region_idx);\n+      assert(!hr->is_pinned(), \"Unexpected pinned region at index %u\", hr->hrm_index());\n+      assert(hr->in_collection_set(), \"bad CS\");\n+      assert(_evac_failure_regions->contains(hr->hrm_index()), \"precondition\");\n+\n+      Ticks start = Ticks::now();\n+\n+      hr->clear_index_in_opt_cset();\n+\n+      bool during_concurrent_start = _heap->collector_state()->in_concurrent_start_gc();\n+      bool during_concurrent_mark = _heap->collector_state()->mark_or_rebuild_in_progress();\n+\n+      hr->note_self_forwarding_removal_start(during_concurrent_start,\n+                                             during_concurrent_mark);\n+\n+      p->record_or_add_thread_work_item(G1GCPhaseTimes::RestoreRetainedRegions,\n+                                        worker_id,\n+                                        1,\n+                                        G1GCPhaseTimes::RestoreRetainedRegionsNum);\n+\n+      hr->rem_set()->clean_code_roots(hr);\n+      hr->rem_set()->clear_locked(true);\n+\n+      p->record_or_add_time_secs(G1GCPhaseTimes::PrepareRetainedRegions, worker_id, (Ticks::now() - start).seconds());\n+    }\n@@ -112,1 +138,1 @@\n-      _evac_failure_regions->prepare_region(r->hrm_index(), _worker_id);\n+      prepare_region(r->hrm_index(), _worker_id);\n@@ -136,28 +162,0 @@\n-\n-void G1EvacFailureRegions::prepare_region(uint region_idx, uint worker_id) {\n-  HeapRegion* hr = _heap->region_at(region_idx);\n-  assert(!hr->is_pinned(), \"Unexpected pinned region at index %u\", hr->hrm_index());\n-  assert(hr->in_collection_set(), \"bad CS\");\n-  assert(contains(hr->hrm_index()), \"precondition\");\n-\n-  Ticks start = Ticks::now();\n-  G1GCPhaseTimes* phase_times = G1CollectedHeap::heap()->phase_times();\n-\n-  hr->clear_index_in_opt_cset();\n-\n-  bool during_concurrent_start = _heap->collector_state()->in_concurrent_start_gc();\n-  bool during_concurrent_mark = _heap->collector_state()->mark_or_rebuild_in_progress();\n-\n-  hr->note_self_forwarding_removal_start(during_concurrent_start,\n-                                         during_concurrent_mark);\n-\n-  _phase_times->record_or_add_thread_work_item(G1GCPhaseTimes::RestoreRetainedRegions,\n-                                               worker_id,\n-                                               1,\n-                                               G1GCPhaseTimes::RestoreRetainedRegionsNum);\n-\n-  hr->rem_set()->clean_code_roots(hr);\n-  hr->rem_set()->clear_locked(true);\n-\n-  phase_times->record_or_add_time_secs(G1GCPhaseTimes::PrepareRetainedRegions, worker_id, (Ticks::now() - start).seconds());\n-}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1EvacFailureRegions.cpp","additions":43,"deletions":45,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-class G1HeapRegionChunksClaimer;\n@@ -33,0 +32,1 @@\n+class G1ScanChunksInHeapRegions;\n@@ -44,2 +44,2 @@\n-  \/\/ Claims chunks in regions automatically.\n-  G1HeapRegionChunksClaimer** _chunk_claimers;\n+  \/\/ Scans chunks in evacuation failure regions\n+  G1ScanChunksInHeapRegions* _chunks_in_regions;\n@@ -66,0 +66,1 @@\n+  void initialize_chunks(uint active_workers);\n@@ -72,1 +73,0 @@\n-  void prepare_region(uint region_idx, uint worker_id);\n@@ -74,1 +74,1 @@\n-  uint max_regions() {\n+  uint max_regions() const {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1EvacFailureRegions.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -40,1 +40,0 @@\n-    _chunk_claimers[region_idx] = new (NEW_C_HEAP_OBJ(G1HeapRegionChunksClaimer, mtGC)) G1HeapRegionChunksClaimer(region_idx);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1EvacFailureRegions.inline.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -141,0 +141,1 @@\n+  _gc_par_phases[RemoveSelfForwardsInChunks]->create_thread_work_items(\"Chunks Per Region:\", RemoveSelfForwardChunksPerRegion);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1GCPhaseTimes.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -156,0 +156,1 @@\n+    RemoveSelfForwardChunksPerRegion,\n","filename":"src\/hotspot\/share\/gc\/g1\/g1GCPhaseTimes.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -52,6 +52,2 @@\n-G1HeapRegionChunksClaimer::G1HeapRegionChunksClaimer(uint region_idx, bool region_ready) :\n-  _chunk_num(G1EvacuationFailureHeapRegionChunkNum),\n-  _chunk_size(static_cast<uint>(G1HeapRegionSize \/ _chunk_num)),\n-  _region_idx(region_idx),\n-  _chunks(mtGC) {\n-  _chunks.resize(_chunk_num);\n+bool G1ScanChunksInHeapRegions::claim_chunk(uint chunk_id) {\n+  return _chunks.par_set_bit(chunk_id);\n@@ -60,3 +56,11 @@\n-bool G1HeapRegionChunksClaimer::claim_chunk(uint chunk_idx) {\n-  return _chunks.par_set_bit(chunk_idx);\n-}\n+G1ScanChunksInHeapRegions::G1ScanChunksInHeapRegions() :\n+  _bitmap(G1CollectedHeap::heap()->concurrent_mark()->prev_mark_bitmap()),\n+  _chunks(mtGC) { }\n+\n+void G1ScanChunksInHeapRegions::initialize(const uint* evac_failure_regions, uint evac_failure_regions_length, uint num_workers) {\n+  _evac_failure_regions = evac_failure_regions;\n+  _evac_failure_regions_length = evac_failure_regions_length;\n+\n+  _chunks_per_region = next_power_of_2(num_workers * G1RemoveSelfForwardPtrsThreadLoadFactor \/ evac_failure_regions_length);\n+  _chunk_size = static_cast<uint>(G1HeapRegionSize \/ _chunks_per_region);\n+  _total_chunks = _chunks_per_region * evac_failure_regions_length;\n@@ -64,7 +68,3 @@\n-G1ScanChunksInHeapRegionClosure::G1ScanChunksInHeapRegionClosure(G1HeapRegionChunksClaimer** chunk_claimers,\n-                                                                 G1HeapRegionChunkClosure* closure,\n-                                                                 uint worker_id) :\n-  _chunk_claimers(chunk_claimers),\n-  _closure(closure),\n-  _worker_id(worker_id),\n-  _bitmap(G1CollectedHeap::heap()->concurrent_mark()->prev_mark_bitmap()) {\n+  G1CollectedHeap::heap()->phase_times()->record_or_add_thread_work_item(G1GCPhaseTimes::RemoveSelfForwardsInChunks, 0, _chunks_per_region, G1GCPhaseTimes::RemoveSelfForwardChunksPerRegion);\n+\n+  _chunks.resize(_total_chunks);\n@@ -73,1 +73,1 @@\n-bool G1ScanChunksInHeapRegionClosure::do_heap_region(HeapRegion* r) {\n+void G1ScanChunksInHeapRegions::par_iterate_chunks_in_regions(G1HeapRegionChunkClosure* chunk_closure, uint worker_id) {\n@@ -75,2 +75,0 @@\n-  G1HeapRegionChunksClaimer* claimer = _chunk_claimers[r->hrm_index()];\n-\n@@ -78,2 +76,2 @@\n-  const uint start_pos = _worker_id * claimer->chunk_num() \/ total_workers;\n-  uint chunk_idx = start_pos;\n+  const uint start_pos = worker_id * _total_chunks \/ total_workers;\n+  uint chunk_id = start_pos;\n@@ -82,1 +80,1 @@\n-    if (claimer->claim_chunk(chunk_idx)) {\n+    if (claim_chunk(chunk_id)) {\n@@ -84,2 +82,4 @@\n-      G1HeapRegionChunk chunk(r, chunk_idx, claimer->chunk_size(), _bitmap);\n-      p->record_or_add_time_secs(G1GCPhaseTimes::PrepareChunks, _worker_id, (Ticks::now() - chunk_prepare_start).seconds());\n+      uint region_idx = _evac_failure_regions[chunk_id \/ _chunks_per_region];\n+      HeapRegion* r = G1CollectedHeap::heap()->region_at(region_idx);\n+      G1HeapRegionChunk chunk(r, chunk_id % _chunks_per_region, _chunk_size, _bitmap);\n+      p->record_or_add_time_secs(G1GCPhaseTimes::PrepareChunks, worker_id, (Ticks::now() - chunk_prepare_start).seconds());\n@@ -88,1 +88,1 @@\n-        p->record_or_add_thread_work_item(G1GCPhaseTimes::RemoveSelfForwardsInChunks, _worker_id, 1, G1GCPhaseTimes::RemoveSelfForwardEmptyChunksNum);\n+        p->record_or_add_thread_work_item(G1GCPhaseTimes::RemoveSelfForwardsInChunks, worker_id, 1, G1GCPhaseTimes::RemoveSelfForwardEmptyChunksNum);\n@@ -91,1 +91,1 @@\n-      p->record_or_add_thread_work_item(G1GCPhaseTimes::RemoveSelfForwardsInChunks, _worker_id, 1, G1GCPhaseTimes::RemoveSelfForwardChunksNum);\n+      p->record_or_add_thread_work_item(G1GCPhaseTimes::RemoveSelfForwardsInChunks, worker_id, 1, G1GCPhaseTimes::RemoveSelfForwardChunksNum);\n@@ -93,2 +93,2 @@\n-      _closure->do_heap_region_chunk(&chunk);\n-      p->record_or_add_time_secs(G1GCPhaseTimes::RemoveSelfForwardsInChunks, _worker_id, (Ticks::now() - start).seconds());\n+      chunk_closure->do_heap_region_chunk(&chunk);\n+      p->record_or_add_time_secs(G1GCPhaseTimes::RemoveSelfForwardsInChunks, worker_id, (Ticks::now() - start).seconds());\n@@ -97,2 +97,2 @@\n-    if (++chunk_idx == claimer->chunk_num()) {\n-      chunk_idx = 0;\n+    if (++chunk_id == _total_chunks) {\n+      chunk_id = 0;\n@@ -100,1 +100,1 @@\n-    if (chunk_idx == start_pos) break;\n+    if (chunk_id == start_pos) break;\n@@ -102,1 +102,0 @@\n-  return false;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegionChunk.cpp","additions":31,"deletions":32,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+  \/\/ chunk index in a region, zero based.\n@@ -77,4 +78,2 @@\n-class G1HeapRegionChunksClaimer {\n-  const uint _chunk_num;\n-  const uint _chunk_size;\n-  const uint _region_idx;\n+class G1ScanChunksInHeapRegions {\n+  const G1CMBitMap* const _bitmap;\n@@ -82,0 +81,5 @@\n+  const uint* _evac_failure_regions;\n+  uint _evac_failure_regions_length;\n+  uint _chunks_per_region;\n+  uint _chunk_size;\n+  uint _total_chunks;\n@@ -83,15 +87,1 @@\n-public:\n-  G1HeapRegionChunksClaimer(uint region_idx, bool region_ready = false);\n-\n-  bool claim_chunk(uint chunk_idx);\n-\n-  uint chunk_size() { return _chunk_size; }\n-  uint chunk_num() { return _chunk_num; }\n-};\n-\n-\/\/ Iterate through chunks of regions, for each region do single preparation.\n-class G1ScanChunksInHeapRegionClosure : public HeapRegionClosure {\n-  G1HeapRegionChunksClaimer** _chunk_claimers;\n-  G1HeapRegionChunkClosure* _closure;\n-  uint _worker_id;\n-  const G1CMBitMap* const _bitmap;\n+  bool claim_chunk(uint id);\n@@ -100,3 +90,2 @@\n-  G1ScanChunksInHeapRegionClosure(G1HeapRegionChunksClaimer** chunk_claimers,\n-                                  G1HeapRegionChunkClosure* closure,\n-                                  uint worker_id);\n+  G1ScanChunksInHeapRegions();\n+  void initialize(const uint* evac_failure_regions, uint evac_failure_regions_length, uint num_workers);\n@@ -104,1 +93,1 @@\n-  bool do_heap_region(HeapRegion* r) override;\n+  void par_iterate_chunks_in_regions(G1HeapRegionChunkClosure* chunk_closure, uint worker_id);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegionChunk.hpp","additions":12,"deletions":23,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -120,0 +120,4 @@\n+\n+  void initialize_chunks(uint num_workers) {\n+    _evac_failure_regions->initialize_chunks(num_workers);\n+  }\n@@ -133,0 +137,1 @@\n+  add_parallel_task(G1CollectedHeap::heap()->rem_set()->create_cleanup_after_scan_heap_roots_task());\n@@ -134,1 +139,4 @@\n-    add_parallel_task(new RemoveSelfForwardPtrsTask(evac_failure_regions));\n+    RemoveSelfForwardPtrsTask* remove_self_forward_task = new RemoveSelfForwardPtrsTask(evac_failure_regions);\n+    add_parallel_task(remove_self_forward_task);\n+    uint num_workers = MAX2(1u, MIN2(num_workers_estimate(), G1CollectedHeap::heap()->workers()->active_workers()));\n+    remove_self_forward_task->initialize_chunks(num_workers);\n@@ -136,1 +144,0 @@\n-  add_parallel_task(G1CollectedHeap::heap()->rem_set()->create_cleanup_after_scan_heap_roots_task());\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCPostEvacuateTasks.cpp","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -42,1 +42,0 @@\n-\/\/ - Remove Self Forwards (on evacuation failure)\n@@ -44,0 +43,1 @@\n+\/\/ - Remove Self Forwards (on evacuation failure)\n@@ -60,1 +60,1 @@\n-\/\/ - Verify Retained Regions\n+\/\/ - Verify Retained Regions (on evacuation failure)\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCPostEvacuateTasks.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -387,3 +387,3 @@\n-  product(uint, G1EvacuationFailureHeapRegionChunkNum, 256,                 \\\n-          \"Number of chunks per G1 region when processing evacuation \"      \\\n-          \"failed regions in parallel. \")                                   \\\n+  product(uint, G1RemoveSelfForwardPtrsThreadLoadFactor, 16,                \\\n+          \"The factor for per worker thread load to remove self forwardee \" \\\n+          \"for evecuation failure regions.\")                                \\\n","filename":"src\/hotspot\/share\/gc\/g1\/g1_globals.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"}]}