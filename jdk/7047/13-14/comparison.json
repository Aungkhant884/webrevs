{"files":[{"patch":"@@ -596,1 +596,2 @@\n-  inline bool mark_in_next_bitmap(uint worker_id, HeapRegion* const hr, oop const obj);\n+  inline bool mark_in_next_bitmap(uint worker_id, HeapRegion* const hr, oop const obj, bool mark_unconditionally = false);\n+  inline bool mark_in_next_bitmap_unconditionally(uint worker_id, oop const obj);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -64,1 +64,6 @@\n-inline bool G1ConcurrentMark::mark_in_next_bitmap(uint const worker_id, HeapRegion* const hr, oop const obj) {\n+inline bool G1ConcurrentMark::mark_in_next_bitmap_unconditionally(uint const worker_id, oop const obj) {\n+  HeapRegion* const hr = _g1h->heap_region_containing(obj);\n+  return mark_in_next_bitmap(worker_id, hr, obj, true);\n+}\n+\n+inline bool G1ConcurrentMark::mark_in_next_bitmap(uint const worker_id, HeapRegion* const hr, oop const obj, bool mark_unconditionally) {\n@@ -68,1 +73,1 @@\n-  if (hr->obj_allocated_since_next_marking(obj)) {\n+  if (!mark_unconditionally && hr->obj_allocated_since_next_marking(obj)) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.inline.hpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -100,1 +100,1 @@\n-      _cm->mark_in_next_bitmap(_worker_id, obj);\n+      _cm->mark_in_next_bitmap_unconditionally(_worker_id, obj);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1EvacFailure.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"gc\/g1\/g1BatchedTask.hpp\"\n@@ -88,1 +89,1 @@\n-class PrepareEvacFailureRegionTask : public WorkerTask {\n+class PrepareEvacFailureRegionTask : public G1AbstractSubTask {\n@@ -105,2 +106,0 @@\n-      Ticks start = Ticks::now();\n-\n@@ -109,6 +108,0 @@\n-      bool during_concurrent_start = g1h->collector_state()->in_concurrent_start_gc();\n-      bool during_concurrent_mark = g1h->collector_state()->mark_or_rebuild_in_progress();\n-\n-      hr->note_self_forwarding_removal_start(during_concurrent_start,\n-                                             during_concurrent_mark);\n-\n@@ -122,2 +115,0 @@\n-\n-      p->record_or_add_time_secs(G1GCPhaseTimes::PrepareRetainedRegions, worker_id, (Ticks::now() - start).seconds());\n@@ -140,1 +131,1 @@\n-    WorkerTask(\"Prepare Evacuation Failure Region Task\"),\n+    G1AbstractSubTask(G1GCPhaseTimes::PrepareRetainedRegions),\n@@ -146,1 +137,5 @@\n-  void work(uint worker_id) override {\n+  double worker_cost() const override {\n+    return 1.0;\n+  }\n+\n+  void do_work(uint worker_id) override {\n@@ -152,1 +147,1 @@\n-void G1EvacFailureRegions::prepare_regions() {\n+G1AbstractSubTask* G1EvacFailureRegions::create_prepare_regions_task() {\n@@ -155,2 +150,1 @@\n-  PrepareEvacFailureRegionTask task(this, num_workers);\n-  workers->run_task(&task, num_workers);\n+  return new PrepareEvacFailureRegionTask(this, num_workers);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1EvacFailureRegions.cpp","additions":10,"deletions":16,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+class G1AbstractSubTask;\n@@ -67,2 +68,2 @@\n-  \/\/ Do necessary preparation for evacuation failure regions\n-  void prepare_regions();\n+  \/\/ Return a G1AbstractSubTask which does necessary preparation for evacuation failure regions\n+  G1AbstractSubTask* create_prepare_regions_task();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1EvacFailureRegions.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -38,0 +38,6 @@\n+\n+    G1CollectedHeap* g1h = G1CollectedHeap::heap();\n+    HeapRegion* hr = g1h->region_at(region_idx);\n+    G1CollectorState* state = g1h->collector_state();\n+    hr->note_self_forwarding_removal_start(state->in_concurrent_start_gc(),\n+                                           state->mark_or_rebuild_in_progress());\n","filename":"src\/hotspot\/share\/gc\/g1\/g1EvacFailureRegions.inline.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -986,2 +986,0 @@\n-  _evac_failure_regions.prepare_regions();\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungCollector.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -141,0 +141,2 @@\n+    add_parallel_task(evac_failure_regions->create_prepare_regions_task());\n+\n@@ -143,1 +145,2 @@\n-    uint num_workers = MAX2(1u, MIN2(num_workers_estimate(), G1CollectedHeap::heap()->workers()->active_workers()));\n+\n+    uint num_workers = clamp(num_workers_estimate(), 1u, G1CollectedHeap::heap()->workers()->active_workers());\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCPostEvacuateTasks.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"}]}