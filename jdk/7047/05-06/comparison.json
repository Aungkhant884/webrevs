{"files":[{"patch":"@@ -151,5 +151,0 @@\n-    if (_chunk->include_last_obj_in_region()) {\n-      \/\/ As we have process the self forwardee in parallel,\n-      \/\/ it's necessary to update the bot threshold explicitly.\n-      _hr->update_bot_threshold();\n-    }\n@@ -206,2 +201,0 @@\n-\n-  \/\/ TODO: maybe only allocate and iterate through evacuation failed regions\n","filename":"src\/hotspot\/share\/gc\/g1\/g1EvacFailure.cpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -71,0 +71,26 @@\n+bool G1EvacFailureRegions::contains(uint region_idx) const {\n+  assert(region_idx < _max_regions, \"must be\");\n+  return _regions_failed_evacuation.par_at(region_idx, memory_order_relaxed);\n+}\n+\n+void G1EvacFailureRegions::par_iterate(HeapRegionClosure* closure,\n+                                       HeapRegionClaimer* hrclaimer,\n+                                       uint worker_id) const {\n+  G1CollectedHeap::heap()->par_iterate_regions_array(closure,\n+                                                     hrclaimer,\n+                                                     _evac_failure_regions,\n+                                                     Atomic::load(&_evac_failure_regions_cur_length),\n+                                                     worker_id);\n+}\n+\n+void G1EvacFailureRegions::par_iterate_chunks_in_regions(G1HeapRegionChunkClosure* chunk_closure,\n+                                                         uint worker_id) const {\n+  G1ScanChunksInHeapRegionClosure closure(_chunk_claimers, chunk_closure, worker_id);\n+\n+  G1CollectedHeap::heap()->par_iterate_regions_array(&closure,\n+                                                     nullptr, \/\/ pass null, so every worker thread go through every region.\n+                                                     _evac_failure_regions,\n+                                                     Atomic::load(&_evac_failure_regions_cur_length),\n+                                                     worker_id);\n+}\n+\n@@ -103,1 +129,0 @@\n-\n@@ -112,26 +137,0 @@\n-void G1EvacFailureRegions::par_iterate(HeapRegionClosure* closure,\n-                                       HeapRegionClaimer* hrclaimer,\n-                                       uint worker_id) const {\n-  G1CollectedHeap::heap()->par_iterate_regions_array(closure,\n-                                                     hrclaimer,\n-                                                     _evac_failure_regions,\n-                                                     Atomic::load(&_evac_failure_regions_cur_length),\n-                                                     worker_id);\n-}\n-\n-void G1EvacFailureRegions::par_iterate_chunks_in_regions(G1HeapRegionChunkClosure* chunk_closure,\n-                                                         uint worker_id) const {\n-  G1ScanChunksInHeapRegionClosure closure(_chunk_claimers, chunk_closure, worker_id);\n-\n-  G1CollectedHeap::heap()->par_iterate_regions_array(&closure,\n-                                                     nullptr, \/\/ pass null, so every worker thread go through every region.\n-                                                     _evac_failure_regions,\n-                                                     Atomic::load(&_evac_failure_regions_cur_length),\n-                                                     worker_id);\n-}\n-\n-bool G1EvacFailureRegions::contains(uint region_idx) const {\n-  assert(region_idx < _max_regions, \"must be\");\n-  return _regions_failed_evacuation.par_at(region_idx, memory_order_relaxed);\n-}\n-\n@@ -155,2 +154,0 @@\n-  hr->reset_bot();\n-\n@@ -162,1 +159,1 @@\n-  hr->rem_set()->clean_strong_code_roots(hr);\n+  hr->rem_set()->clean_code_roots(hr);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1EvacFailureRegions.cpp","additions":27,"deletions":30,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -71,1 +71,0 @@\n-  void prepare_region(uint region_idx, uint worker_id);\n@@ -73,0 +72,1 @@\n+  void prepare_region(uint region_idx, uint worker_id);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1EvacFailureRegions.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -103,1 +103,1 @@\n-}\n\\ No newline at end of file\n+}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegionChunk.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -123,1 +123,1 @@\n-#endif \/\/SHARE_GC_G1_G1HEAPREGIONCHUNK_HPP\n\\ No newline at end of file\n+#endif \/\/SHARE_GC_G1_G1HEAPREGIONCHUNK_HPP\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegionChunk.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-#endif \/\/SHARE_GC_G1_G1HEAPREGIONCHUNK_INLINE_HPP\n\\ No newline at end of file\n+#endif \/\/SHARE_GC_G1_G1HEAPREGIONCHUNK_INLINE_HPP\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegionChunk.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -70,1 +70,0 @@\n-  G1EvacFailureRegions* _evac_failure_regions;\n@@ -73,3 +72,2 @@\n-  SampleCollectionSetCandidatesTask(G1EvacFailureRegions* evac_failure_regions) :\n-    G1AbstractSubTask(G1GCPhaseTimes::SampleCollectionSetCandidates),\n-    _evac_failure_regions(evac_failure_regions) { }\n+  SampleCollectionSetCandidatesTask() :\n+    G1AbstractSubTask(G1GCPhaseTimes::SampleCollectionSetCandidates) { }\n@@ -88,1 +86,0 @@\n-      G1EvacFailureRegions* _evac_failure_regions;\n@@ -92,3 +89,0 @@\n-      G1SampleCollectionSetCandidatesClosure(G1EvacFailureRegions* evac_failure_regions) :\n-        _evac_failure_regions(evac_failure_regions) { }\n-\n@@ -99,1 +93,1 @@\n-    } cl(_evac_failure_regions);\n+    } cl;\n@@ -137,1 +131,1 @@\n-    add_serial_task(new SampleCollectionSetCandidatesTask(evac_failure_regions));\n+    add_serial_task(new SampleCollectionSetCandidatesTask());\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCPostEvacuateTasks.cpp","additions":4,"deletions":10,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -84,3 +84,2 @@\n-          \"The percentage of regions in the collection set starting \"       \\\n-          \"from the beginning where the forced evacuation failure \"         \\\n-          \"injection will be applied.\")                                     \\\n+          \"The factor for per region work cost to remove self forwardee \"   \\\n+          \"for evecuation failure regions.\")                                \\\n","filename":"src\/hotspot\/share\/gc\/g1\/g1_globals.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -63,15 +63,0 @@\n-void MarkBitMap::do_par_clear(MemRegion mr, bool large) {\n-  MemRegion intersection = mr.intersection(_covered);\n-  assert(!intersection.is_empty(),\n-         \"Given range from \" PTR_FORMAT \" to \" PTR_FORMAT \" is completely outside the heap\",\n-         p2i(mr.start()), p2i(mr.end()));\n-  \/\/ convert address range into offset range\n-  size_t beg = addr_to_offset(intersection.start());\n-  size_t end = addr_to_offset(intersection.end());\n-  if (large) {\n-    _bm.par_clear_range(beg, end, BitMap::large_range);\n-  } else {\n-    _bm.par_clear_range(beg, end, BitMap::small_range);\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/markBitMap.cpp","additions":0,"deletions":15,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -55,1 +55,0 @@\n-  void do_par_clear(MemRegion mr, bool large);\n@@ -101,3 +100,0 @@\n-\n-  void par_clear_range(MemRegion mr)   { do_par_clear(mr, false); }\n-  void par_clear_range_large(MemRegion mr) { do_par_clear(mr, true); }\n","filename":"src\/hotspot\/share\/gc\/shared\/markBitMap.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"}]}