{"files":[{"patch":"@@ -155,0 +155,31 @@\n+  class RegionMarkedWordsCache {\n+    G1CollectedHeap* _g1h;\n+    uint _region_idx;\n+    size_t _marked_words;\n+\n+  public:\n+    RegionMarkedWordsCache():\n+      _g1h(G1CollectedHeap::heap()),\n+      _region_idx(_g1h->max_regions()),\n+      _marked_words(0) { }\n+\n+    void add(uint region_idx, size_t marked_words) {\n+      if (_region_idx == _g1h->max_regions()) {\n+        _region_idx = region_idx;\n+        _marked_words = marked_words;\n+      } else if (_region_idx == region_idx) {\n+        _marked_words += marked_words;\n+      } else {\n+        _g1h->region_at(_region_idx)->note_self_forwarding_removal_end_par(_marked_words * BytesPerWord);\n+        _region_idx = region_idx;\n+        _marked_words = marked_words;\n+      }\n+    }\n+\n+    void flush() {\n+      if (_region_idx != _g1h->max_regions()) {\n+        _g1h->region_at(_region_idx)->note_self_forwarding_removal_end_par(_marked_words * BytesPerWord);\n+      }\n+    }\n+  };\n+\n@@ -157,2 +188,1 @@\n-  uint _region_idx;\n-  size_t _marked_words;\n+  RegionMarkedWordsCache _region_marked_words_cache;\n@@ -160,2 +190,2 @@\n-  void remove_self_forward_ptr_by_walking_chunk(G1HeapRegionChunk* chunk,\n-                                                bool during_concurrent_start) {\n+  void remove_self_forward_ptr_by_walking_chunk(G1HeapRegionChunk* chunk) {\n+    bool during_concurrent_start = _g1h->collector_state()->in_concurrent_start_gc();\n@@ -171,1 +201,1 @@\n-    update_states(current_region_idx, rspc.marked_words());\n+    _region_marked_words_cache.add(current_region_idx, rspc.marked_words());\n@@ -183,13 +213,0 @@\n-  void update_states(uint current_region_idx, size_t marked_words) {\n-    if (_region_idx == _g1h->max_regions()) {\n-      _region_idx = current_region_idx;\n-      _marked_words = marked_words;\n-    } else if (_region_idx == current_region_idx) {\n-      _marked_words += marked_words;\n-    } else {\n-      _g1h->region_at(_region_idx)->note_self_forwarding_removal_end_par(_marked_words * BytesPerWord);\n-      _region_idx = current_region_idx;\n-      _marked_words = marked_words;\n-    }\n-  }\n-\n@@ -199,3 +216,1 @@\n-    _worker_id(worker_id),\n-    _region_idx(_g1h->max_regions()),\n-    _marked_words(0) {\n+    _worker_id(worker_id) {\n@@ -205,2 +220,1 @@\n-    bool during_concurrent_start = _g1h->collector_state()->in_concurrent_start_gc();\n-    remove_self_forward_ptr_by_walking_chunk(chunk, during_concurrent_start);\n+    remove_self_forward_ptr_by_walking_chunk(chunk);\n@@ -210,3 +224,1 @@\n-    if (_region_idx != _g1h->max_regions()) {\n-      _g1h->region_at(_region_idx)->note_self_forwarding_removal_end_par(_marked_words * BytesPerWord);\n-    }\n+    _region_marked_words_cache.flush();\n@@ -233,4 +245,0 @@\n-\n-void G1ParRemoveSelfForwardPtrsTask::initialize_chunks(uint active_workers) {\n-  _evac_failure_regions->initialize_chunks(active_workers);\n-}\n\\ No newline at end of file\n","filename":"src\/hotspot\/share\/gc\/g1\/g1EvacFailure.cpp","additions":38,"deletions":30,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -51,2 +51,0 @@\n-\n-  void initialize_chunks(uint active_workers);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1EvacFailure.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -56,0 +56,18 @@\n+void G1ScanChunksInHeapRegions::process_chunk(G1HeapRegionChunkClosure* chunk_closure, uint chunk_id, uint worker_id) {\n+  G1GCPhaseTimes* p = G1CollectedHeap::heap()->phase_times();\n+  Ticks chunk_prepare_start = Ticks::now();\n+  uint region_idx = _evac_failure_regions[chunk_id \/ _chunks_per_region];\n+  HeapRegion* r = G1CollectedHeap::heap()->region_at(region_idx);\n+  G1HeapRegionChunk chunk(r, chunk_id % _chunks_per_region, _chunk_size, _bitmap);\n+  p->record_or_add_time_secs(G1GCPhaseTimes::PrepareChunks, worker_id, (Ticks::now() - chunk_prepare_start).seconds());\n+\n+  if (chunk.empty()) {\n+    p->record_or_add_thread_work_item(G1GCPhaseTimes::RemoveSelfForwardsInChunks, worker_id, 1, G1GCPhaseTimes::RemoveSelfForwardEmptyChunksNum);\n+    return;\n+  }\n+  p->record_or_add_thread_work_item(G1GCPhaseTimes::RemoveSelfForwardsInChunks, worker_id, 1, G1GCPhaseTimes::RemoveSelfForwardChunksNum);\n+  Ticks start = Ticks::now();\n+  chunk_closure->do_heap_region_chunk(&chunk);\n+  p->record_or_add_time_secs(G1GCPhaseTimes::RemoveSelfForwardsInChunks, worker_id, (Ticks::now() - start).seconds());\n+}\n+\n@@ -62,1 +80,0 @@\n-  _evac_failure_regions_length = evac_failure_regions_length;\n@@ -74,6 +91,4 @@\n-  G1GCPhaseTimes* p = G1CollectedHeap::heap()->phase_times();\n-  uint total_workers = G1CollectedHeap::heap()->workers()->active_workers();\n-  const uint start_pos = worker_id * _total_chunks \/ total_workers;\n-  uint chunk_id = start_pos;\n-\n-  while (true) {\n+  const uint total_workers = G1CollectedHeap::heap()->workers()->active_workers();\n+  const uint start_chunk_id = worker_id * _total_chunks \/ total_workers;\n+  for (uint i = 0; i < _total_chunks; i++) {\n+    const uint chunk_id = (start_chunk_id + i) % _total_chunks;\n@@ -81,18 +96,1 @@\n-      Ticks chunk_prepare_start = Ticks::now();\n-      uint region_idx = _evac_failure_regions[chunk_id \/ _chunks_per_region];\n-      HeapRegion* r = G1CollectedHeap::heap()->region_at(region_idx);\n-      G1HeapRegionChunk chunk(r, chunk_id % _chunks_per_region, _chunk_size, _bitmap);\n-      p->record_or_add_time_secs(G1GCPhaseTimes::PrepareChunks, worker_id, (Ticks::now() - chunk_prepare_start).seconds());\n-\n-      if (chunk.empty()) {\n-        p->record_or_add_thread_work_item(G1GCPhaseTimes::RemoveSelfForwardsInChunks, worker_id, 1, G1GCPhaseTimes::RemoveSelfForwardEmptyChunksNum);\n-        continue;\n-      }\n-      p->record_or_add_thread_work_item(G1GCPhaseTimes::RemoveSelfForwardsInChunks, worker_id, 1, G1GCPhaseTimes::RemoveSelfForwardChunksNum);\n-      Ticks start = Ticks::now();\n-      chunk_closure->do_heap_region_chunk(&chunk);\n-      p->record_or_add_time_secs(G1GCPhaseTimes::RemoveSelfForwardsInChunks, worker_id, (Ticks::now() - start).seconds());\n-    }\n-\n-    if (++chunk_id == _total_chunks) {\n-      chunk_id = 0;\n+      process_chunk(chunk_closure, chunk_id, worker_id);\n@@ -100,1 +98,0 @@\n-    if (chunk_id == start_pos) break;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegionChunk.cpp","additions":23,"deletions":26,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -74,1 +74,0 @@\n-  \/\/ Typically called on each region until it returns true.\n@@ -82,1 +81,0 @@\n-  uint _evac_failure_regions_length;\n@@ -88,0 +86,1 @@\n+  void process_chunk(G1HeapRegionChunkClosure* chunk_closure, uint chunk_id, uint worker_id);\n@@ -93,1 +92,1 @@\n-  void par_iterate_chunks_in_regions(G1HeapRegionChunkClosure* chunk_closure, uint worker_id);\n+  void par_iterate_chunks_in_regions(G1HeapRegionChunkClosure* chunk_closure, const uint worker_id);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegionChunk.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"}]}