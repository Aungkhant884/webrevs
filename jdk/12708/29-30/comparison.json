{"files":[{"patch":"@@ -28,6 +28,1 @@\n-import java.lang.foreign.AddressLayout;\n-import java.lang.foreign.FunctionDescriptor;\n-import java.lang.foreign.GroupLayout;\n-import java.lang.foreign.MemoryLayout;\n-import java.lang.foreign.MemorySegment;\n-import java.lang.foreign.ValueLayout;\n+import jdk.internal.foreign.Utils;\n@@ -41,1 +36,0 @@\n-import jdk.internal.foreign.abi.UpcallLinker;\n@@ -45,1 +39,0 @@\n-import jdk.internal.foreign.Utils;\n@@ -47,0 +40,6 @@\n+import java.lang.foreign.AddressLayout;\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.GroupLayout;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ValueLayout;\n@@ -49,1 +48,0 @@\n-import java.nio.ByteOrder;\n@@ -70,0 +68,1 @@\n+    private static final int MAX_COPY_SIZE = 8;\n@@ -73,2 +72,2 @@\n-    \/\/ This is derived from the 64-Bit ELF V2 ABI spec, restricted to what's\n-    \/\/ possible when calling to\/from C code.\n+    \/\/ This is derived from the 64-Bit ELF v2 ABI spec, restricted to what's\n+    \/\/ possible when calling to\/from C code. (v1 is compatible, but uses fewer output registers.)\n@@ -158,1 +157,0 @@\n-        private boolean forVarArgs = false;\n@@ -221,4 +219,4 @@\n-            \/\/ Allocate individual fields as gp slots (regs and stack).\n-            int nFields = (int) ((layout.byteSize() + 7) \/ 8);\n-            VMStorage[] result = new VMStorage[nFields];\n-            for (int i = 0; i < nFields; i++) {\n+            \/\/ Allocate enough gp slots (regs and stack) such that the struct fits in them.\n+            int numChunks = (int) Utils.alignUp(layout.byteSize(), MAX_COPY_SIZE) \/ MAX_COPY_SIZE;\n+            VMStorage[] result = new VMStorage[numChunks];\n+            for (int i = 0; i < numChunks; i++) {\n@@ -307,1 +305,0 @@\n-            forVarArgs = true;\n@@ -338,1 +335,1 @@\n-                        final long size = Math.min(layout.byteSize() - offset, 8);\n+                        final long size = Math.min(layout.byteSize() - offset, MAX_COPY_SIZE);\n@@ -416,1 +413,1 @@\n-                        final long size = Math.min(layout.byteSize() - offset, 8);\n+                        final long size = Math.min(layout.byteSize() - offset, MAX_COPY_SIZE);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/ppc64\/CallArranger.java","additions":16,"deletions":19,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n-    private static LinuxPPC64leLinker instance;\n@@ -41,2 +40,2 @@\n-        if (instance == null) {\n-            instance = new LinuxPPC64leLinker();\n+        final class Holder {\n+            private static final LinuxPPC64leLinker INSTANCE = new LinuxPPC64leLinker();\n@@ -44,1 +43,6 @@\n-        return instance;\n+\n+        return Holder.INSTANCE;\n+    }\n+\n+    private LinuxPPC64leLinker() {\n+        \/\/ Ensure there is only one instance\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/ppc64\/linux\/LinuxPPC64leLinker.java","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"}]}