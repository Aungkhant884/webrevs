{"files":[{"patch":"@@ -128,1 +128,1 @@\n-      \/\/ FP arguments can get passed in GP reg!\n+      \/\/ FP arguments can get passed in GP reg! (Only in Upcall with HFA usage.)\n@@ -132,1 +132,1 @@\n-        __ lfs(as_FloatRegister(to_reg), -8, R1_SP);\n+        __ lfs(as_FloatRegister(to_reg), -8, R1_SP); \/\/ convert to double precision format\n@@ -134,2 +134,6 @@\n-        __ std(as_Register(from_reg), -8, R1_SP);\n-        __ lfd(as_FloatRegister(to_reg), -8, R1_SP);\n+        if (VM_Version::has_mtfprd()) {\n+          __ mtfprd(as_FloatRegister(to_reg), as_Register(from_reg));\n+        } else {\n+          __ std(as_Register(from_reg), -8, R1_SP);\n+          __ lfd(as_FloatRegister(to_reg), -8, R1_SP);\n+        }\n@@ -162,1 +166,1 @@\n-      \/\/ FP arguments can get passed in GP reg!\n+      \/\/ FP arguments can get passed in GP reg! (Only for VarArgs for which we don't use FP regs.)\n@@ -165,1 +169,1 @@\n-        __ stfs(as_FloatRegister(from_reg), -8, R1_SP);\n+        __ stfs(as_FloatRegister(from_reg), -8, R1_SP); \/\/ convert to single precision format\n@@ -168,2 +172,6 @@\n-        __ stfd(as_FloatRegister(from_reg), -8, R1_SP);\n-        __ ld(as_Register(to_reg), -8, R1_SP);\n+        if (VM_Version::has_mtfprd()) {\n+          __ mffprd(as_Register(to_reg), as_FloatRegister(from_reg));\n+        } else {\n+          __ stfd(as_FloatRegister(from_reg), -8, R1_SP);\n+          __ ld(as_Register(to_reg), -8, R1_SP);\n+        }\n","filename":"src\/hotspot\/cpu\/ppc\/foreignGlobals_ppc.cpp","additions":16,"deletions":8,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -218,4 +218,2 @@\n-            \/\/ TODO: Big Endian can't pass partially used slots correctly.\n-            if (!useABIv2() && layout.byteSize() % 8 != 0) throw new UnsupportedOperationException(\n-                \"Only MemoryLayouts with size multiple of 8 supported. This layout has size \" +\n-                layout.byteSize() + \".\");\n+            \/\/ TODO: Big Endian can't pass partially used slots correctly in some cases with:\n+            \/\/ !useABIv2() && layout.byteSize() > 8 && layout.byteSize() % 8 != 0\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/ppc64\/CallArranger.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -78,0 +78,3 @@\n+    static final FunctionDescriptor fdadd_double_to_struct_after_structs = FunctionDescriptor.of(S_FFLayout,\n+        S_FFLayout, S_FFLayout, S_FFLayout, S_FFLayout, S_FFLayout, S_FFLayout,\n+        S_FFLayout, JAVA_DOUBLE);\n@@ -85,0 +88,1 @@\n+    static final FunctionDescriptor fdpass_struct_after_structs_plus_double = FunctionDescriptor.of(S_FFLayout, ADDRESS, S_FFLayout, JAVA_DOUBLE);\n@@ -93,0 +97,2 @@\n+    final static MethodHandle mhadd_double_to_struct_after_structs = abi.downcallHandle(lookup.find(\"add_double_to_struct_after_structs\").orElseThrow(),\n+        fdadd_double_to_struct_after_structs);\n@@ -102,0 +108,2 @@\n+    final static MethodHandle mhpass_struct_after_structs_plus_double = abi.downcallHandle(lookup.find(\"pass_struct_after_structs_plus_double\").orElseThrow(),\n+        fdpass_struct_after_structs_plus_double);\n@@ -175,0 +183,20 @@\n+    @Test\n+    public static void testAddDoubleToStructAfterStructs() {\n+        float p0 = 0.0f, p1 = 0.0f;\n+        try {\n+            Arena arena = Arena.ofConfined();\n+            MemorySegment s = arena.allocate(S_FFLayout);\n+            s.set(FLOAT, 0, 1.0f);\n+            s.set(FLOAT, 4, 1.0f);\n+            s = (MemorySegment)mhadd_double_to_struct_after_structs.invokeExact((SegmentAllocator)arena,\n+                 s, s, s, s, s, s,\n+                 s, 1.0d);\n+            p0 = s.get(FLOAT, 0);\n+            p1 = s.get(FLOAT, 4);\n+            System.out.println(\"S_FF(\" + p0 + \";\" + p1 + \")\");\n+        } catch (Throwable t) {\n+            t.printStackTrace();\n+        }\n+        if (p0 != 2.0f || p1 != 1.0f) throw new RuntimeException(\"add_double_to_struct_after_structs error\");\n+    }\n+\n@@ -243,0 +271,9 @@\n+    public static MemorySegment addDoubleToStructAfterStructs(\n+            MemorySegment s1, MemorySegment s2, MemorySegment s3,\n+            MemorySegment s4, MemorySegment s5, MemorySegment s6,\n+            MemorySegment s, double f) {\n+        float val = s.get(FLOAT, 0);\n+        s.set(FLOAT, 0, val + (float) f);\n+        return s;\n+    }\n+\n@@ -325,0 +362,24 @@\n+    @Test\n+    public static void testAddDoubleToStructAfterStructsUpcall() {\n+        float p0 = 0.0f, p1 = 0.0f;\n+        try {\n+            Arena arena = Arena.ofConfined();\n+            MemorySegment s = arena.allocate(S_FFLayout);\n+            s.set(FLOAT, 0, 1.0f);\n+            s.set(FLOAT, 4, 1.0f);\n+            MethodType mt = MethodType.methodType(MemorySegment.class,\n+                                                  MemorySegment.class, MemorySegment.class, MemorySegment.class,\n+                                                  MemorySegment.class, MemorySegment.class, MemorySegment.class,\n+                                                  MemorySegment.class, double.class);\n+            MemorySegment stub = abi.upcallStub(MethodHandles.lookup().findStatic(TestHFA.class, \"addDoubleToStructAfterStructs\", mt),\n+                                                fdadd_double_to_struct_after_structs, arena);\n+            s = (MemorySegment)mhpass_struct_after_structs_plus_double.invokeExact((SegmentAllocator)arena, stub, s, 1.0d);\n+            p0 = s.get(FLOAT, 0);\n+            p1 = s.get(FLOAT, 4);\n+            System.out.println(\"S_FF(\" + p0 + \";\" + p1 + \")\");\n+        } catch (Throwable t) {\n+            t.printStackTrace();\n+        }\n+        if (p0 != 2.0f || p1 != 1.0f) throw new RuntimeException(\"add_double_to_struct_after_structs (Upcall)\");\n+    }\n+\n","filename":"test\/jdk\/java\/foreign\/TestHFA.java","additions":61,"deletions":0,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -60,1 +60,10 @@\n-\/\/ Corner case on PPC64le: Pass struct S_FF partially in FP register and in GP register and on stack.\n+\/\/ Corner case on PPC64le: Pass struct S_FF partially in FP register and in GP register.\n+\/\/ Pass additional double in GP register.\n+EXPORT struct S_FF add_double_to_struct_after_structs(\n+  struct S_FF s1, struct S_FF s2, struct S_FF s3, struct S_FF s4, struct S_FF s5, struct S_FF s6,\n+  struct S_FF s, double f) {\n+  s.p0 += f;\n+  return s;\n+}\n+\n+\/\/ Corner case on PPC64le: Pass struct S_FFFFFFF partially in FP register and in GP register and on stack.\n@@ -75,3 +84,3 @@\n-                                              float, float, float, float, float,\n-                                              float, float, float, float, float,\n-                                              float, float, struct S_FF, float),\n+                                            float, float, float, float, float,\n+                                            float, float, float, float, float,\n+                                            float, float, struct S_FF, float),\n@@ -83,3 +92,3 @@\n-                                               struct S_FF, struct S_FF, struct S_FF,\n-                                               struct S_FF, struct S_FF, struct S_FF,\n-                                               struct S_FF, float),\n+                                             struct S_FF, struct S_FF, struct S_FF,\n+                                             struct S_FF, struct S_FF, struct S_FF,\n+                                             struct S_FF, float),\n@@ -92,0 +101,10 @@\n+EXPORT struct S_FF pass_struct_after_structs_plus_double(struct S_FF (*fun)(\n+                                                         struct S_FF, struct S_FF, struct S_FF,\n+                                                         struct S_FF, struct S_FF, struct S_FF,\n+                                                         struct S_FF, double),\n+                                                         struct S_FF s1, double f) {\n+  struct S_FF dummy;\n+  dummy.p0 = 1; dummy.p1 = 2;\n+  return fun(dummy, dummy, dummy, dummy, dummy, dummy, s1, f);\n+}\n+\n@@ -93,3 +112,3 @@\n-                                                          struct S_FF, struct S_FF, struct S_FF,\n-                                                          struct S_FF, struct S_FF, struct S_FF,\n-                                                          struct S_FFFFFFF, float),\n+                                                        struct S_FF, struct S_FF, struct S_FF,\n+                                                        struct S_FF, struct S_FF, struct S_FF,\n+                                                        struct S_FFFFFFF, float),\n","filename":"test\/jdk\/java\/foreign\/libTestHFA.c","additions":29,"deletions":10,"binary":false,"changes":39,"status":"modified"}]}