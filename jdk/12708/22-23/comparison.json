{"files":[{"patch":"@@ -43,2 +43,1 @@\n-    private SystemLookup() {\n-    }\n+    private SystemLookup() { }\n@@ -55,4 +54,2 @@\n-     * On POSIX systems, dlsym will allow us to lookup symbol in library\n-     * dependencies; the same trick doesn't work\n-     * on Windows. For this reason, on Windows we do not generate any side-library,\n-     * and load msvcrt.dll directly instead.\n+     * On POSIX systems, dlsym will allow us to lookup symbol in library dependencies; the same trick doesn't work\n+     * on Windows. For this reason, on Windows we do not generate any side-library, and load msvcrt.dll directly instead.\n@@ -70,4 +67,2 @@\n-            \/\/ This can happen in the event of a library loading failure - e.g. if one of\n-            \/\/ the libraries the\n-            \/\/ system lookup depends on cannot be loaded for some reason. In such extreme\n-            \/\/ cases, rather than\n+            \/\/ This can happen in the event of a library loading failure - e.g. if one of the libraries the\n+            \/\/ system lookup depends on cannot be loaded for some reason. In such extreme cases, rather than\n@@ -91,1 +86,2 @@\n-            SymbolLookup fallbackLibLookup = libLookup(libs -> libs.load(jdkLibraryPath(\"syslookup\")));\n+            SymbolLookup fallbackLibLookup =\n+                    libLookup(libs -> libs.load(jdkLibraryPath(\"syslookup\")));\n@@ -96,3 +92,2 @@\n-            Function<String, Optional<MemorySegment>> fallbackLookup = name -> Optional\n-                    .ofNullable(WindowsFallbackSymbols.valueOfOrNull(name))\n-                    .map(symbol -> funcs.getAtIndex(ADDRESS, symbol.ordinal()));\n+            Function<String, Optional<MemorySegment>> fallbackLookup = name -> Optional.ofNullable(WindowsFallbackSymbols.valueOfOrNull(name))\n+                .map(symbol -> funcs.getAtIndex(ADDRESS, symbol.ordinal()));\n@@ -116,1 +111,3 @@\n-                return addr == 0 ? Optional.empty() : Optional.of(MemorySegment.ofAddress(addr));\n+                return addr == 0 ?\n+                        Optional.empty() :\n+                        Optional.of(MemorySegment.ofAddress(addr));\n@@ -133,0 +130,1 @@\n+\n@@ -143,2 +141,1 @@\n-    \/\/ this list has to be kept in sync with the table in the companion native\n-    \/\/ library\n+    \/\/ this list has to be kept in sync with the table in the companion native library\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/SystemLookup.java","additions":14,"deletions":17,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -50,3 +50,3 @@\n-        SysVx64Linker, WindowsAArch64Linker,\n-        Windowsx64Linker, LinuxPPC64leLinker,\n-        LinuxRISCV64Linker, FallbackLinker {\n+                                                                      SysVx64Linker, WindowsAArch64Linker,\n+                                                                      Windowsx64Linker, LinuxPPC64leLinker,\n+                                                                      LinuxRISCV64Linker, FallbackLinker {\n@@ -58,3 +58,1 @@\n-    private record LinkRequest(FunctionDescriptor descriptor, LinkerOptions options) {\n-    }\n-\n+    private record LinkRequest(FunctionDescriptor descriptor, LinkerOptions options) {}\n@@ -71,1 +69,1 @@\n-        return DOWNCALL_CACHE.get(new LinkRequest(function, optionSet), linkRequest -> {\n+        return DOWNCALL_CACHE.get(new LinkRequest(function, optionSet), linkRequest ->  {\n@@ -79,3 +77,1 @@\n-\n-    protected abstract MethodHandle arrangeDowncall(MethodType inferredMethodType, FunctionDescriptor function,\n-            LinkerOptions options);\n+    protected abstract MethodHandle arrangeDowncall(MethodType inferredMethodType, FunctionDescriptor function, LinkerOptions options);\n@@ -84,2 +80,1 @@\n-    public MemorySegment upcallStub(MethodHandle target, FunctionDescriptor function, Arena arena,\n-            Linker.Option... options) {\n+    public MemorySegment upcallStub(MethodHandle target, FunctionDescriptor function, Arena arena, Linker.Option... options) {\n@@ -98,2 +93,2 @@\n-        UpcallStubFactory factory = UPCALL_CACHE.get(new LinkRequest(function, optionSet),\n-                linkRequest -> arrangeUpcall(type, linkRequest.descriptor(), linkRequest.options()));\n+        UpcallStubFactory factory = UPCALL_CACHE.get(new LinkRequest(function, optionSet), linkRequest ->\n+            arrangeUpcall(type, linkRequest.descriptor(), linkRequest.options()));\n@@ -103,2 +98,1 @@\n-    protected abstract UpcallStubFactory arrangeUpcall(MethodType targetType, FunctionDescriptor function,\n-            LinkerOptions options);\n+    protected abstract UpcallStubFactory arrangeUpcall(MethodType targetType, FunctionDescriptor function, LinkerOptions options);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/AbstractLinker.java","additions":10,"deletions":16,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -129,6 +129,3 @@\n-     * Takes a MethodHandle that takes an input buffer as a first argument (a\n-     * MemorySegment), and returns nothing,\n-     * and adapts it to return a MemorySegment, by allocating a MemorySegment for\n-     * the input\n-     * buffer, calling the target MethodHandle, and then returning the allocated\n-     * MemorySegment.\n+     * Takes a MethodHandle that takes an input buffer as a first argument (a MemorySegment), and returns nothing,\n+     * and adapts it to return a MemorySegment, by allocating a MemorySegment for the input\n+     * buffer, calling the target MethodHandle, and then returning the allocated MemorySegment.\n@@ -136,4 +133,2 @@\n-     * This allows viewing a MethodHandle that makes use of in memory return (IMR)\n-     * as a MethodHandle that just returns\n-     * a MemorySegment without requiring a pre-allocated buffer as an explicit\n-     * input.\n+     * This allows viewing a MethodHandle that makes use of in memory return (IMR) as a MethodHandle that just returns\n+     * a MemorySegment without requiring a pre-allocated buffer as an explicit input.\n@@ -142,2 +137,1 @@\n-     * @param cDesc  the function descriptor of the native function (with actual\n-     *               return layout)\n+     * @param cDesc the function descriptor of the native function (with actual return layout)\n@@ -146,2 +140,1 @@\n-    public static MethodHandle adaptDowncallForIMR(MethodHandle handle, FunctionDescriptor cDesc,\n-            CallingSequence sequence) {\n+    public static MethodHandle adaptDowncallForIMR(MethodHandle handle, FunctionDescriptor cDesc, CallingSequence sequence) {\n@@ -157,10 +150,4 @@\n-        handle = collectArguments(ret, 1, handle); \/\/ (MemorySegment, MemorySegment, SegmentAllocator, MemorySegment,\n-                                                   \/\/ ...) MemorySegment\n-        handle = mergeArguments(handle, 0, 1 + imrAddrIdx); \/\/ (MemorySegment, MemorySegment, SegmentAllocator, ...)\n-                                                            \/\/ MemorySegment\n-        handle = collectArguments(handle, 0, insertArguments(MH_ALLOC_BUFFER, 1, cDesc.returnLayout().get())); \/\/ (SegmentAllocator,\n-                                                                                                               \/\/ MemorySegment,\n-                                                                                                               \/\/ SegmentAllocator,\n-                                                                                                               \/\/ ...)\n-                                                                                                               \/\/ MemorySegment\n-        handle = mergeArguments(handle, 0, 2); \/\/ (SegmentAllocator, MemorySegment, ...) MemorySegment\n+        handle = collectArguments(ret, 1, handle); \/\/ (MemorySegment, MemorySegment, SegmentAllocator, MemorySegment, ...) MemorySegment\n+        handle = mergeArguments(handle, 0, 1 + imrAddrIdx);  \/\/ (MemorySegment, MemorySegment, SegmentAllocator, ...) MemorySegment\n+        handle = collectArguments(handle, 0, insertArguments(MH_ALLOC_BUFFER, 1, cDesc.returnLayout().get())); \/\/ (SegmentAllocator, MemorySegment, SegmentAllocator, ...) MemorySegment\n+        handle = mergeArguments(handle, 0, 2);  \/\/ (SegmentAllocator, MemorySegment, ...) MemorySegment\n@@ -172,4 +159,2 @@\n-     * Takes a MethodHandle that returns a MemorySegment, and adapts it to take an\n-     * input buffer as a first argument\n-     * (a MemorySegment), and upon invocation, copies the contents of the returned\n-     * MemorySegment into the input buffer\n+     * Takes a MethodHandle that returns a MemorySegment, and adapts it to take an input buffer as a first argument\n+     * (a MemorySegment), and upon invocation, copies the contents of the returned MemorySegment into the input buffer\n@@ -198,3 +183,2 @@\n-    public static UpcallStubFactory arrangeUpcallHelper(MethodType targetType, boolean isInMemoryReturn,\n-            boolean dropReturn,\n-            ABIDescriptor abi, CallingSequence callingSequence) {\n+    public static UpcallStubFactory arrangeUpcallHelper(MethodType targetType, boolean isInMemoryReturn, boolean dropReturn,\n+                                                        ABIDescriptor abi, CallingSequence callingSequence) {\n@@ -272,2 +256,1 @@\n-        \/\/ iterate until overflow (String can only hold a byte[], whose length can be\n-        \/\/ expressed as an int)\n+        \/\/ iterate until overflow (String can only hold a byte[], whose length can be expressed as an int)\n@@ -285,2 +268,2 @@\n-                .boxed()\n-                .collect(Collectors.toMap(i -> moves[i].storage(), i -> i));\n+                        .boxed()\n+                        .collect(Collectors.toMap(i -> moves[i].storage(), i -> i));\n@@ -312,0 +295,1 @@\n+\n@@ -316,1 +300,1 @@\n-        for (int i = 0; i < perms.length; i++) {\n+        for (int i = 0 ; i < perms.length ; i++) {\n@@ -318,4 +302,2 @@\n-            if (i == firstArg)\n-                dst = secondArg;\n-            if (i == secondArg)\n-                dst = firstArg;\n+            if (i == firstArg) dst = secondArg;\n+            if (i == secondArg) dst = firstArg;\n@@ -463,2 +445,2 @@\n-            boolean b = (boolean) o;\n-            ptr.set(JAVA_LONG_UNALIGNED, 0, b ? (long) 1 : (long) 0);\n+            boolean b = (boolean)o;\n+            ptr.set(JAVA_LONG_UNALIGNED, 0, b ? (long)1 : (long)0);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/SharedUtils.java","additions":24,"deletions":42,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -58,2 +58,1 @@\n- * to translate a C FunctionDescriptor into a CallingSequence, which can then be\n- * turned into a MethodHandle.\n+ * to translate a C FunctionDescriptor into a CallingSequence, which can then be turned into a MethodHandle.\n@@ -61,2 +60,1 @@\n- * This includes taking care of synthetic arguments like pointers to return\n- * buffers for 'in-memory' returns.\n+ * This includes taking care of synthetic arguments like pointers to return buffers for 'in-memory' returns.\n@@ -65,3 +63,2 @@\n- * which are handled in sub-classes. Clients should access these through the\n- * provided\n- * public constants CallArranger.LINUX.\n+ * which are handled in sub-classes. Clients should access these through the provided\n+ * public constants CallArranger.ABIv1\/2.\n@@ -79,10 +76,10 @@\n-            new VMStorage[] { r3, r4, r5, r6, r7, r8, r9, r10 }, \/\/ GP input\n-            new VMStorage[] { f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12, f13 }, \/\/ FP intput\n-            new VMStorage[] { r3, r4 }, \/\/ GP output\n-            new VMStorage[] { f1, f2, f3, f4, f5, f6, f7, f8 }, \/\/ FP output\n-            new VMStorage[] { r0, r2, r11, r12 }, \/\/ volatile GP (excluding argument registers)\n-            new VMStorage[] { f0 }, \/\/ volatile FP (excluding argument registers)\n-            16, \/\/ Stack is always 16 byte aligned on PPC64\n-            useABIv2() ? 32 : 48, \/\/ ABI header (excluding argument register spill slots)\n-            r11, \/\/ scratch reg\n-            r12 \/\/ target addr reg, otherwise used as scratch reg\n+        new VMStorage[] { r3, r4, r5, r6, r7, r8, r9, r10 }, \/\/ GP input\n+        new VMStorage[] { f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12, f13 }, \/\/ FP intput\n+        new VMStorage[] { r3, r4 }, \/\/ GP output\n+        new VMStorage[] { f1, f2, f3, f4, f5, f6, f7, f8 }, \/\/ FP output\n+        new VMStorage[] { r0, r2, r11, r12 }, \/\/ volatile GP (excluding argument registers)\n+        new VMStorage[] { f0 }, \/\/ volatile FP (excluding argument registers)\n+        16, \/\/ Stack is always 16 byte aligned on PPC64\n+        useABIv2() ? 32 : 48, \/\/ ABI header (excluding argument register spill slots)\n+        r11, \/\/ scratch reg\n+        r12  \/\/ target addr reg, otherwise used as scratch reg\n@@ -91,2 +88,1 @@\n-    public record Bindings(CallingSequence callingSequence, boolean isInMemoryReturn) {\n-    }\n+    public record Bindings(CallingSequence callingSequence, boolean isInMemoryReturn) {}\n@@ -94,2 +90,1 @@\n-    private record HfaRegs(VMStorage[] first, VMStorage[] second) {\n-    }\n+    private record HfaRegs(VMStorage[] first, VMStorage[] second) {}\n@@ -97,2 +92,1 @@\n-    protected CallArranger() {\n-    }\n+    protected CallArranger() {}\n@@ -147,2 +141,1 @@\n-    public UpcallStubFactory arrangeUpcall(MethodType mt, FunctionDescriptor cDesc,\n-            LinkerOptions options) {\n+    public UpcallStubFactory arrangeUpcall(MethodType mt, FunctionDescriptor cDesc, LinkerOptions options) {\n@@ -158,3 +151,3 @@\n-                .filter(GroupLayout.class::isInstance)\n-                .filter(layout -> !TypeClass.isStructHFAorReturnRegisterAggregate(layout, useABIv2()))\n-                .isPresent();\n+            .filter(GroupLayout.class::isInstance)\n+            .filter(layout -> !TypeClass.isStructHFAorReturnRegisterAggregate(layout, useABIv2()))\n+            .isPresent();\n@@ -194,2 +187,1 @@\n-            if (type == StorageType.INTEGER && nRegs[StorageType.INTEGER] + gpRegCnt > MAX_REGISTER_ARGUMENTS)\n-                return null;\n+            if (type == StorageType.INTEGER && nRegs[StorageType.INTEGER] + gpRegCnt > MAX_REGISTER_ARGUMENTS) return null;\n@@ -206,2 +198,1 @@\n-        \/\/ FP loads and stores must use the correct IEEE 754 precision format (32\/64\n-        \/\/ bit).\n+        \/\/ FP loads and stores must use the correct IEEE 754 precision format (32\/64 bit).\n@@ -218,2 +209,1 @@\n-            if (reg == null)\n-                return stack;\n+            if (reg == null) return stack;\n@@ -229,4 +219,3 @@\n-            if (!useABIv2() && layout.byteSize() % 8 != 0)\n-                throw new UnsupportedOperationException(\n-                        \"Only MemoryLayouts with size multiple of 8 supported. This layout has size \" +\n-                                layout.byteSize() + \".\");\n+            if (!useABIv2() && layout.byteSize() % 8 != 0) throw new UnsupportedOperationException(\n+                \"Only MemoryLayouts with size multiple of 8 supported. This layout has size \" +\n+                layout.byteSize() + \".\");\n@@ -271,2 +260,2 @@\n-            VMStorage[] result = new VMStorage[fpRegCnt + structSlots],\n-                    result2 = new VMStorage[fpRegCnt + structSlots]; \/\/ For overlapping.\n+            VMStorage[] result  = new VMStorage[fpRegCnt + structSlots],\n+                        result2 = new VMStorage[fpRegCnt + structSlots]; \/\/ For overlapping.\n@@ -278,1 +267,1 @@\n-                            sourceReg.indexOrOffset());\n+                                              sourceReg.indexOrOffset());\n@@ -287,2 +276,1 @@\n-            \/\/ Reserve GP regs and stack slots for the packed HFA (when using single\n-            \/\/ precision).\n+            \/\/ Reserve GP regs and stack slots for the packed HFA (when using single precision).\n@@ -290,1 +278,1 @@\n-                    : fpRegCnt;\n+                                                           : fpRegCnt;\n@@ -301,1 +289,1 @@\n-                            PPC64Architecture.REG64_MASK, allocatedGpReg.indexOrOffset());\n+                                                   PPC64Architecture.REG64_MASK, allocatedGpReg.indexOrOffset());\n@@ -304,1 +292,1 @@\n-                            (short) STACK_SLOT_SIZE, (int) stackOffset - 4);\n+                                                   (short) STACK_SLOT_SIZE, (int) stackOffset - 4);\n@@ -370,2 +358,1 @@\n-                        \/\/ Floats are 4 Bytes, Double, GP reg and stack slots 8 Bytes (except maybe last\n-                        \/\/ slot).\n+                        \/\/ Floats are 4 Bytes, Double, GP reg and stack slots 8 Bytes (except maybe last slot).\n@@ -373,1 +360,1 @@\n-                                (storage.type() == StorageType.FLOAT || layout.byteSize() - offset < 8)) ? 4 : 8;\n+                                     (storage.type() == StorageType.FLOAT || layout.byteSize() - offset < 8)) ? 4 : 8;\n@@ -449,2 +436,1 @@\n-                        \/\/ Floats are 4 Bytes, Double, GP reg and stack slots 8 Bytes (except maybe last\n-                        \/\/ slot).\n+                        \/\/ Floats are 4 Bytes, Double, GP reg and stack slots 8 Bytes (except maybe last slot).\n@@ -452,1 +438,1 @@\n-                                (storage.type() == StorageType.FLOAT || layout.byteSize() - offset < 8)) ? 4 : 8;\n+                                           (storage.type() == StorageType.FLOAT || layout.byteSize() - offset < 8)) ? 4 : 8;\n@@ -467,2 +453,1 @@\n-                    \/\/ We could use carrier != long.class for BoxBindingCalculator, but C always\n-                    \/\/ uses 64 bit slots.\n+                    \/\/ We could use carrier != long.class for BoxBindingCalculator, but C always uses 64 bit slots.\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/ppc64\/CallArranger.java","additions":39,"deletions":54,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -56,4 +56,2 @@\n-            case StorageType.INTEGER:\n-                return INTEGER_REG_SIZE;\n-            case StorageType.FLOAT:\n-                return FLOAT_REG_SIZE;\n+            case StorageType.INTEGER: return INTEGER_REG_SIZE;\n+            case StorageType.FLOAT: return FLOAT_REG_SIZE;\n@@ -74,10 +72,10 @@\n-        public static final VMStorage r0 = integerRegister(0);\n-        public static final VMStorage r1 = integerRegister(1);\n-        public static final VMStorage r2 = integerRegister(2);\n-        public static final VMStorage r3 = integerRegister(3);\n-        public static final VMStorage r4 = integerRegister(4);\n-        public static final VMStorage r5 = integerRegister(5);\n-        public static final VMStorage r6 = integerRegister(6);\n-        public static final VMStorage r7 = integerRegister(7);\n-        public static final VMStorage r8 = integerRegister(8);\n-        public static final VMStorage r9 = integerRegister(9);\n+        public static final VMStorage r0  = integerRegister(0);\n+        public static final VMStorage r1  = integerRegister(1);\n+        public static final VMStorage r2  = integerRegister(2);\n+        public static final VMStorage r3  = integerRegister(3);\n+        public static final VMStorage r4  = integerRegister(4);\n+        public static final VMStorage r5  = integerRegister(5);\n+        public static final VMStorage r6  = integerRegister(6);\n+        public static final VMStorage r7  = integerRegister(7);\n+        public static final VMStorage r8  = integerRegister(8);\n+        public static final VMStorage r9  = integerRegister(9);\n@@ -107,10 +105,10 @@\n-        public static final VMStorage f0 = floatRegister(0);\n-        public static final VMStorage f1 = floatRegister(1);\n-        public static final VMStorage f2 = floatRegister(2);\n-        public static final VMStorage f3 = floatRegister(3);\n-        public static final VMStorage f4 = floatRegister(4);\n-        public static final VMStorage f5 = floatRegister(5);\n-        public static final VMStorage f6 = floatRegister(6);\n-        public static final VMStorage f7 = floatRegister(7);\n-        public static final VMStorage f8 = floatRegister(8);\n-        public static final VMStorage f9 = floatRegister(9);\n+        public static final VMStorage f0  = floatRegister(0);\n+        public static final VMStorage f1  = floatRegister(1);\n+        public static final VMStorage f2  = floatRegister(2);\n+        public static final VMStorage f3  = floatRegister(3);\n+        public static final VMStorage f4  = floatRegister(4);\n+        public static final VMStorage f5  = floatRegister(5);\n+        public static final VMStorage f6  = floatRegister(6);\n+        public static final VMStorage f7  = floatRegister(7);\n+        public static final VMStorage f8  = floatRegister(8);\n+        public static final VMStorage f9  = floatRegister(9);\n@@ -154,8 +152,8 @@\n-            VMStorage[] inputFloatRegs,\n-            VMStorage[] outputIntRegs,\n-            VMStorage[] outputFloatRegs,\n-            VMStorage[] volatileIntRegs,\n-            VMStorage[] volatileFloatRegs,\n-            int stackAlignment,\n-            int shadowSpace,\n-            VMStorage scratch1, VMStorage scratch2) {\n+                                       VMStorage[] inputFloatRegs,\n+                                       VMStorage[] outputIntRegs,\n+                                       VMStorage[] outputFloatRegs,\n+                                       VMStorage[] volatileIntRegs,\n+                                       VMStorage[] volatileFloatRegs,\n+                                       int stackAlignment,\n+                                       int shadowSpace,\n+                                       VMStorage scratch1, VMStorage scratch2) {\n@@ -163,19 +161,19 @@\n-                INSTANCE,\n-                new VMStorage[][] {\n-                        inputIntRegs,\n-                        inputFloatRegs,\n-                },\n-                new VMStorage[][] {\n-                        outputIntRegs,\n-                        outputFloatRegs,\n-                },\n-                new VMStorage[][] {\n-                        volatileIntRegs,\n-                        volatileFloatRegs,\n-                },\n-                stackAlignment,\n-                shadowSpace,\n-                scratch1, scratch2,\n-                StubLocations.TARGET_ADDRESS.storage(StorageType.PLACEHOLDER),\n-                StubLocations.RETURN_BUFFER.storage(StorageType.PLACEHOLDER),\n-                StubLocations.CAPTURED_STATE_BUFFER.storage(StorageType.PLACEHOLDER));\n+            INSTANCE,\n+            new VMStorage[][] {\n+                inputIntRegs,\n+                inputFloatRegs,\n+            },\n+            new VMStorage[][] {\n+                outputIntRegs,\n+                outputFloatRegs,\n+            },\n+            new VMStorage[][] {\n+                volatileIntRegs,\n+                volatileFloatRegs,\n+            },\n+            stackAlignment,\n+            shadowSpace,\n+            scratch1, scratch2,\n+            StubLocations.TARGET_ADDRESS.storage(StorageType.PLACEHOLDER),\n+            StubLocations.RETURN_BUFFER.storage(StorageType.PLACEHOLDER),\n+            StubLocations.CAPTURED_STATE_BUFFER.storage(StorageType.PLACEHOLDER));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/ppc64\/PPC64Architecture.java","additions":49,"deletions":51,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -47,2 +47,1 @@\n-    protected MethodHandle arrangeDowncall(MethodType inferredMethodType, FunctionDescriptor function,\n-            LinkerOptions options) {\n+    protected MethodHandle arrangeDowncall(MethodType inferredMethodType, FunctionDescriptor function, LinkerOptions options) {\n@@ -53,2 +52,1 @@\n-    protected UpcallStubFactory arrangeUpcall(MethodType targetType, FunctionDescriptor function,\n-            LinkerOptions options) {\n+    protected UpcallStubFactory arrangeUpcall(MethodType targetType, FunctionDescriptor function, LinkerOptions options) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/ppc64\/linux\/LinuxPPC64leLinker.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"}]}