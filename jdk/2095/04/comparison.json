{"files":[{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 1997, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2012, 2015 SAP SE. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021 SAP SE. All rights reserved.\n@@ -32,0 +32,5 @@\n+#ifdef COMPILER2\n+#include \"opto\/compile.hpp\"\n+#include \"opto\/node.hpp\"\n+#include \"opto\/output.hpp\"\n+#endif\n@@ -53,0 +58,18 @@\n+\/\/ Check if estimating generated code size\n+bool Assembler::in_scratch_emit_size() {\n+#ifdef COMPILER2\n+  Thread* thread = Thread::current();\n+\n+  if (!thread->is_Compiler_thread()) {\n+    return false;\n+  }\n+\n+  AbstractCompiler* comp = ((CompilerThread *)thread)->compiler();\n+\n+  return comp->is_c2() && comp->is_initialized() &&\n+      Compile::current()->output()->in_scratch_emit_size();\n+#else\n+  return false;\n+#endif\n+}\n+\n","filename":"src\/hotspot\/cpu\/ppc\/assembler_ppc.cpp","additions":25,"deletions":2,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2012, 2020 SAP SE. All rights reserved.\n+ * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021 SAP SE. All rights reserved.\n@@ -223,0 +223,6 @@\n+\n+    \/\/ Shift counts in prefix word\n+    PRE_TYPE_SHIFT = 24u, \/\/ Prefix type in bits 24 -- 25\n+    PRE_ST1_SHIFT  = 23u, \/\/ ST1 field in bits 23 -- 23\n+    PRE_R_SHIFT    = 20u, \/\/ R-bit in bits 20 -- 20\n+    PRE_ST4_SHIFT  = 20u, \/\/ ST4 field in bits 23 -- 20\n@@ -799,0 +805,22 @@\n+  enum opcdeos_mask {\n+    \/\/ Mask for prefix primary opcode field\n+    PREFIX_OPCODE_MASK        = (63u << OPCODE_SHIFT),\n+    \/\/ Mask for prefix opcode and type fields\n+    PREFIX_OPCODE_TYPE_MASK   = (63u << OPCODE_SHIFT) | (3u << PRE_TYPE_SHIFT),\n+    \/\/ Masks for type 00\/10 and type 01\/11, including opcode, type, and st fieds\n+    PREFIX_OPCODE_TYPEx0_MASK = PREFIX_OPCODE_TYPE_MASK | ( 1u << PRE_ST1_SHIFT),\n+    PREFIX_OPCODE_TYPEx1_MASK = PREFIX_OPCODE_TYPE_MASK | (15u << PRE_ST4_SHIFT),\n+\n+    \/\/ Masks for each instructions\n+    PADDI_PREFIX_OPCODE_MASK  = PREFIX_OPCODE_TYPEx0_MASK,\n+    PADDI_SUFFIX_OPCODE_MASK  = ADDI_OPCODE_MASK,\n+  };\n+\n+  enum opcdeos {\n+    PREFIX_PRIMARY_OPCODE = (1u << OPCODE_SHIFT),\n+\n+    \/\/ Prefixed addi\/li\n+    PADDI_PREFIX_OPCODE   = PREFIX_PRIMARY_OPCODE | (2u << PRE_TYPE_SHIFT),\n+    PADDI_SUFFIX_OPCODE   = ADDI_OPCODE,\n+  };\n+\n@@ -1084,0 +1112,14 @@\n+  \/\/ For extended opcodes (prefixed instructions) introduced with Power 10\n+  static long inv_r_eo(   int x)  { return  inv_opp_u_field(x, 11, 11); }\n+  static long inv_type(   int x)  { return  inv_opp_u_field(x,  7,  6); }\n+  static long inv_st_x0(  int x)  { return  inv_opp_u_field(x,  8,  8); }\n+  static long inv_st_x1(  int x)  { return  inv_opp_u_field(x, 11,  8); }\n+\n+  \/\/  - 8LS:D\/MLS:D Formats\n+  static long inv_d0_eo( long x)  { return  inv_opp_u_field(x, 31, 14); }\n+\n+  \/\/  - 8RR:XX4\/8RR:D Formats\n+  static long inv_imm0_eo(int x)  { return  inv_opp_u_field(x, 31, 16); }\n+  static long inv_uimm_eo(int x)  { return  inv_opp_u_field(x, 31, 29); }\n+  static long inv_imm_eo( int x)  { return  inv_opp_u_field(x, 31, 24); }\n+\n@@ -1205,0 +1247,18 @@\n+  \/\/ For extended opcodes (prefixed instructions) introduced with Power 10\n+  static long r_eo(     int        x)  { return  opp_u_field(x,             11, 11); }\n+  static long type(     int        x)  { return  opp_u_field(x,              7,  6); }\n+  static long st_x0(    int        x)  { return  opp_u_field(x,              8,  8); }\n+  static long st_x1(    int        x)  { return  opp_u_field(x,             11,  8); }\n+\n+  \/\/  - 8LS:D\/MLS:D Formats\n+  static long d0_eo(    long       x)  { return  opp_u_field((x >> 16) & 0x3FFFF, 31, 14); }\n+  static long d1_eo(    long       x)  { return  opp_u_field(x & 0xFFFF,    31, 16); }\n+  static long s0_eo(    long       x)  { return  d0_eo(x); }\n+  static long s1_eo(    long       x)  { return  d1_eo(x); }\n+\n+  \/\/  - 8RR:XX4\/8RR:D Formats\n+  static long imm0_eo(  int        x)  { return  opp_u_field(x >> 16,       31, 16); }\n+  static long imm1_eo(  int        x)  { return  opp_u_field(x & 0xFFFF,    31, 16); }\n+  static long uimm_eo(  int        x)  { return  opp_u_field(x,             31, 29); }\n+  static long imm_eo(   int        x)  { return  opp_u_field(x,             31, 24); }\n+\n@@ -1248,0 +1308,16 @@\n+  static void set_imm18(int* instr, int s) {\n+    assert(PowerArchitecturePPC64 >= 10, \"Prefixed instructions are supported only in Power 10 and up\");\n+    \/\/ imm18 is in the lower 18 bits of the prefix instruction,\n+    \/\/ so this is endian-neutral. Same for the get_imm18 below.\n+    uint32_t w = *(uint32_t *)instr;\n+    *instr = (int)((w & ~0x0003FFFF) | (s & 0x0003FFFF));\n+  }\n+\n+  static int get_imm18(address a, int instruction_number) {\n+    assert(PowerArchitecturePPC64 >= 10, \"Prefixed instructions are supported only in Power 10 and up\");\n+    return (((int *)a)[instruction_number] << 14) >> 14;\n+  }\n+\n+  static inline int hi18_signed( int x) { return hi16_signed(x); }\n+  static inline int hi18_signed(long x) { return (int)((x << 30) >> 46); }\n+\n@@ -1266,0 +1342,2 @@\n+  static bool in_scratch_emit_size();\n+\n@@ -1271,0 +1349,1 @@\n+  inline void emit_prefix(int); \/\/ emit prefix word only (and a nop to skip 64-byte boundary)\n@@ -1304,0 +1383,5 @@\n+\n+  \/\/ Prefixed add immediate, introduced by POWER10\n+  inline void paddi(Register d, Register a, long si34, bool r);\n+  inline void pli(  Register d, long si34);\n+\n@@ -1307,0 +1391,1 @@\n+  inline void paddi_r0ok(Register d, Register a, long si34, bool r);\n@@ -1427,0 +1512,22 @@\n+  static bool is_paddi_prefix(int x) {\n+     return PADDI_PREFIX_OPCODE == (x & PADDI_PREFIX_OPCODE_MASK);\n+  }\n+  static bool is_paddi_suffix(int x) {\n+     return PADDI_SUFFIX_OPCODE == (x & PADDI_SUFFIX_OPCODE_MASK);\n+  }\n+  \/\/ This function can skip a nop for 64-byte alignment and check the next word for a prefix.\n+  \/\/ Since the alignement nop is uncommon case, we will keep callers of this function simple,\n+  \/\/ as they which are often assertions and complex if-statement.\n+  static int is_paddi(const int* p, bool is_pli = false) {\n+     int32_t* p_inst = (int32_t*)p;\n+\n+     if (is_aligned(reinterpret_cast<uintptr_t>(p_inst+1), 64) && is_nop(*p_inst)) {\n+        p_inst++;  \/\/ skip over nop\n+     }\n+     if (is_paddi_prefix(p_inst[0]) && is_paddi_suffix(p_inst[1])) {\n+        return !is_pli ||\n+               (inv_r_eo(p_inst[0]) == 0 && inv_ra_field(p_inst[1]) == 0);\n+     } else {\n+        return false;\n+     }\n+  }\n","filename":"src\/hotspot\/cpu\/ppc\/assembler_ppc.hpp","additions":109,"deletions":2,"binary":false,"changes":111,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2012, 2020 SAP SE. All rights reserved.\n+ * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021 SAP SE. All rights reserved.\n@@ -133,0 +133,11 @@\n+\/\/ Prefixed instructions, introduced by POWER10\n+inline void Assembler::paddi(Register d, Register a, long si34, bool r = false) {\n+  assert(a != R0 || r, \"r0 not allowed, unless R is set (CIA relative)\");\n+  paddi_r0ok( d, a, si34, r);\n+}\n+\n+inline void Assembler::paddi_r0ok(Register d, Register a, long si34, bool r = false) {\n+  emit_int32(PADDI_PREFIX_OPCODE | r_eo(r) | d0_eo(si34));\n+  emit_int32(PADDI_SUFFIX_OPCODE | rt(d)   | ra(a)   | d1_eo(si34));\n+}\n+\n@@ -171,0 +182,3 @@\n+\/\/ Prefixed instructions, introduced by POWER10\n+inline void Assembler::pli(Register d, long si34) { Assembler::paddi_r0ok( d, R0, si34, false); }\n+\n","filename":"src\/hotspot\/cpu\/ppc\/assembler_ppc.inline.hpp","additions":16,"deletions":2,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -1158,1 +1158,56 @@\n-\/\/ Currently not used on this platform.\n+\/\/ Add nop if a prefixed (two-word) instruction is going to cross a 64-byte boundary.\n+\/\/ (See Section 1.6 of Power ISA Version 3.1)\n+int loadConI32Node::compute_padding(int current_offset) const {\n+  assert(PowerArchitecturePPC64 >= 10 && (CodeEntryAlignment & 63) == 0,\n+         \"Code buffer must be aligned to a multiple of 64 byte\");\n+  if (is_aligned(current_offset + BytesPerInstWord, 64) || Assembler::in_scratch_emit_size()) {\n+    return BytesPerInstWord;\n+  }\n+  return 0;\n+}\n+\n+int loadConL34Node::compute_padding(int current_offset) const {\n+  assert(PowerArchitecturePPC64 >= 10 && (CodeEntryAlignment & 63) == 0,\n+         \"Code buffer must be aligned to a multiple of 64 byte\");\n+  if (is_aligned(current_offset + BytesPerInstWord, 64) || Assembler::in_scratch_emit_size()) {\n+    return BytesPerInstWord;\n+  }\n+  return 0;\n+}\n+\n+int addI_reg_imm32Node::compute_padding(int current_offset) const {\n+  assert(PowerArchitecturePPC64 >= 10 && (CodeEntryAlignment & 63) == 0,\n+         \"Code buffer must be aligned to a multiple of 64 byte\");\n+  if (is_aligned(current_offset + BytesPerInstWord, 64) || Assembler::in_scratch_emit_size()) {\n+    return BytesPerInstWord;\n+  }\n+  return 0;\n+}\n+\n+int addL_reg_imm34Node::compute_padding(int current_offset) const {\n+  assert(PowerArchitecturePPC64 >= 10 && (CodeEntryAlignment & 63) == 0,\n+         \"Code buffer must be aligned to a multiple of 64 byte\");\n+  if (is_aligned(current_offset + BytesPerInstWord, 64) || Assembler::in_scratch_emit_size()) {\n+    return BytesPerInstWord;\n+  }\n+  return 0;\n+}\n+\n+int addP_reg_imm34Node::compute_padding(int current_offset) const {\n+  assert(PowerArchitecturePPC64 >= 10 && (CodeEntryAlignment & 63) == 0,\n+         \"Code buffer must be aligned to a multiple of 64 byte\");\n+  if (is_aligned(current_offset + BytesPerInstWord, 64) || Assembler::in_scratch_emit_size()) {\n+    return BytesPerInstWord;\n+  }\n+  return 0;\n+}\n+\n+int cmprb_Whitespace_reg_reg_prefixedNode::compute_padding(int current_offset) const {\n+  assert(PowerArchitecturePPC64 >= 10 && (CodeEntryAlignment & 63) == 0,\n+         \"Code buffer must be aligned to a multiple of 64 byte\");\n+  if (is_aligned(current_offset + BytesPerInstWord, 64) || Assembler::in_scratch_emit_size()) {\n+    return BytesPerInstWord;\n+  }\n+  return 0;\n+}\n+\n@@ -1899,1 +1954,1 @@\n-  st->print(\"NOP \\t\/\/ %d nops to pad for loops.\", _count);\n+  st->print(\"NOP \\t\/\/ %d nops to pad for loops or prefixed instructions.\", _count);\n@@ -4044,0 +4099,9 @@\n+\/\/ Integer Immediate: 32-bit immediate for prefixed addi and load\/store.\n+operand immI32() %{\n+  predicate(PowerArchitecturePPC64 >= 10);\n+  op_cost(0);\n+  match(ConI);\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}\n+\n@@ -4285,0 +4349,9 @@\n+\/\/ Long Immediate: 34-bit, immediate field in prefixed addi and load\/store.\n+operand immL34() %{\n+  predicate(PowerArchitecturePPC64 >= 10 && Assembler::is_simm(n->get_long(), 34));\n+  match(ConL);\n+  op_cost(0);\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}\n+\n@@ -5819,0 +5892,17 @@\n+instruct loadConI32(iRegIdst dst, immI32 src) %{\n+  match(Set dst src);\n+  \/\/ This macro is valid only in Power 10 and up, but adding the following predicate here\n+  \/\/ caused build error. So we comment it out for now.\n+  \/\/ predicate(PowerArchitecturePPC64 >= 10);\n+  ins_cost(DEFAULT_COST+1);\n+\n+  format %{ \"PLI     $dst, $src\" %}\n+  size(8);\n+  ins_encode %{\n+    assert( ((intptr_t)(__ pc()) & 0x3c) != 0x3c, \"Bad alignment for prefixed instruction at \" INTPTR_FORMAT, (intptr_t)(__ pc()));\n+    __ pli($dst$$Register, $src$$constant);\n+  %}\n+  ins_pipe(pipe_class_default);\n+  ins_alignment(4);\n+%}\n+\n@@ -5890,0 +5980,18 @@\n+\/\/ Load 34-bit long constant using prefixed addi. No constant pool entries required.\n+instruct loadConL34(iRegLdst dst, immL34 src) %{\n+  match(Set dst src);\n+  \/\/ This macro is valid only in Power 10 and up, but adding the following predicate here\n+  \/\/ caused build error. So we comment it out for now.\n+  \/\/ predicate(PowerArchitecturePPC64 >= 10);\n+  ins_cost(DEFAULT_COST+1);\n+\n+  format %{ \"PLI     $dst, $src \\t\/\/ long\" %}\n+  size(8);\n+  ins_encode %{\n+    assert( ((intptr_t)(__ pc()) & 0x3c) != 0x3c, \"Bad alignment for prefixed instruction at \" INTPTR_FORMAT, (intptr_t)(__ pc()));\n+    __ pli($dst$$Register, $src$$constant);\n+  %}\n+  ins_pipe(pipe_class_default);\n+  ins_alignment(4);\n+%}\n+\n@@ -5915,1 +6023,1 @@\n-  size(4);\n+  size(12);\n@@ -8524,0 +8632,15 @@\n+\/\/ Immediate Addition using prefixed addi\n+instruct addI_reg_imm32(iRegIdst dst, iRegIsrc src1, immI32 src2) %{\n+  match(Set dst (AddI src1 src2));\n+  predicate(PowerArchitecturePPC64 >= 10);\n+  ins_cost(DEFAULT_COST+1);\n+  format %{ \"PADDI   $dst, $src1, $src2\" %}\n+  size(8);\n+  ins_encode %{\n+    assert( ((intptr_t)(__ pc()) & 0x3c) != 0x3c, \"Bad alignment for prefixed instruction at \" INTPTR_FORMAT, (intptr_t)(__ pc()));\n+    __ paddi($dst$$Register, $src1$$Register, $src2$$constant);\n+  %}\n+  ins_pipe(pipe_class_default);\n+  ins_alignment(4);\n+%}\n+\n@@ -8598,0 +8721,17 @@\n+\/\/ Long Immediate Addition using prefixed addi\n+\/\/ No constant pool entries required.\n+instruct addL_reg_imm34(iRegLdst dst, iRegLsrc src1, immL34 src2) %{\n+  match(Set dst (AddL src1 src2));\n+  predicate(PowerArchitecturePPC64 >= 10);\n+  ins_cost(DEFAULT_COST+1);\n+\n+  format %{ \"PADDI   $dst, $src1, $src2\" %}\n+  size(8);\n+  ins_encode %{\n+    assert( ((intptr_t)(__ pc()) & 0x3c) != 0x3c, \"Bad alignment for prefixed instruction at \" INTPTR_FORMAT, (intptr_t)(__ pc()));\n+    __ paddi($dst$$Register, $src1$$Register, $src2$$constant);\n+  %}\n+  ins_pipe(pipe_class_default);\n+  ins_alignment(4);\n+%}\n+\n@@ -8635,0 +8775,17 @@\n+\/\/ Pointer Immediate Addition using prefixed addi\n+\/\/ No constant pool entries required.\n+instruct addP_reg_imm34(iRegPdst dst, iRegP_N2P src1, immL34 src2) %{\n+  match(Set dst (AddP src1 src2));\n+  predicate(PowerArchitecturePPC64 >= 10);\n+  ins_cost(DEFAULT_COST+1);\n+\n+  format %{ \"PADDI    $dst, $src1, $src2\" %}\n+  size(8);\n+  ins_encode %{\n+    assert( ((intptr_t)(__ pc()) & 0x3c) != 0x3c, \"Bad alignment for prefixed instruction at \" INTPTR_FORMAT, (intptr_t)(__ pc()));\n+    __ paddi($dst$$Register, $src1$$Register, $src2$$constant);\n+  %}\n+  ins_pipe(pipe_class_default);\n+  ins_alignment(4);\n+%}\n+\n@@ -11937,0 +12094,1 @@\n+  predicate(PowerArchitecturePPC64 <= 9);\n@@ -11956,0 +12114,23 @@\n+\/\/ Power 10 version, using prefixed addi to load 32-bit constant\n+instruct cmprb_Whitespace_reg_reg_prefixed(iRegIdst dst, iRegIsrc src1, iRegIsrc src2, flagsReg crx) %{\n+  match(Set dst (Whitespace src1));\n+  predicate(PowerArchitecturePPC64 >= 10);\n+  effect(TEMP src2, TEMP crx);\n+  ins_cost(3 * DEFAULT_COST);\n+\n+  format %{ \"PLI     $src2, 0x201C0D09\\n\\t\"\n+            \"CMPRB   $crx, 1, $src1, $src2\\n\\t\"\n+            \"SETB    $dst, $crx\" %}\n+  size(16);\n+  ins_encode %{\n+    \/\/ 0x09 to 0x0D, 0x1C to 0x20\n+    assert( ((intptr_t)(__ pc()) & 0x3c) != 0x3c, \"Bad alignment for prefixed instruction at \" INTPTR_FORMAT, (intptr_t)(__ pc()));\n+    __ pli($src2$$Register, 0x201C0D09);\n+    \/\/ compare src with ranges 0x09 to 0x0D and 0x1C to 0x20\n+    __ cmprb($crx$$CondRegister, 1, $src1$$Register, $src2$$Register);\n+    __ setb($dst$$Register, $crx$$CondRegister);\n+  %}\n+  ins_pipe(pipe_class_default);\n+  ins_alignment(4);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":184,"deletions":3,"binary":false,"changes":187,"status":"modified"}]}