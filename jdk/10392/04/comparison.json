{"files":[{"patch":"@@ -239,0 +239,1 @@\n+  CodeSection* insts_section = __ code()->insts();\n@@ -240,1 +241,1 @@\n-  int consts_size = CodeSection::align_at_start(consts_section->size(), CodeBuffer::SECT_INSTS);\n+  int consts_size = insts_section->align_at_start(consts_section->size());\n","filename":"src\/hotspot\/cpu\/arm\/arm.ad","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -425,0 +425,15 @@\n+int CodeSection::alignment() const {\n+  if (_index == CodeBuffer::SECT_CONSTS) {\n+    \/\/ CodeBuffer controls the alignment of the constants section\n+    return _outer->_const_section_alignment;\n+  }\n+  if (_index == CodeBuffer::SECT_INSTS) {\n+    return (int) CodeEntryAlignment;\n+  }\n+  if (_index == CodeBuffer::SECT_STUBS) {\n+    \/\/ CodeBuffer installer expects sections to be HeapWordSize aligned\n+    return HeapWordSize;\n+  }\n+  ShouldNotReachHere();\n+  return 0;\n+}\n","filename":"src\/hotspot\/share\/asm\/codeBuffer.cpp","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"compiler\/compiler_globals.hpp\"\n@@ -259,2 +260,1 @@\n-  static int alignment(int section);\n-  int alignment() { return alignment(_index); }\n+  int alignment() const;\n@@ -265,4 +265,0 @@\n-  static csize_t align_at_start(csize_t off, int section) {\n-    return (csize_t) align_up(off, alignment(section));\n-  }\n-\n@@ -270,1 +266,1 @@\n-    return align_at_start(off, _index);\n+    return (csize_t) align_up(off, alignment());\n@@ -434,0 +430,2 @@\n+  int          _const_section_alignment;\n+\n@@ -459,0 +457,4 @@\n+    \/\/ Default is to align on 8 bytes. A compiler can change this\n+    \/\/ if larger alignment (e.g., 32-byte vector masks) is required.\n+    _const_section_alignment = (int) sizeof(jdouble);\n+\n@@ -712,0 +714,4 @@\n+  void set_const_section_alignment(int align) {\n+    _const_section_alignment = align_up(align, HeapWordSize);\n+  }\n+\n@@ -749,15 +755,0 @@\n-inline int CodeSection::alignment(int section) {\n-  if (section == CodeBuffer::SECT_CONSTS) {\n-    return (int) sizeof(jdouble);\n-  }\n-  if (section == CodeBuffer::SECT_INSTS) {\n-    return (int) CodeEntryAlignment;\n-  }\n-  if (section == CodeBuffer::SECT_STUBS) {\n-    \/\/ CodeBuffer installer expects sections to be HeapWordSize aligned\n-    return HeapWordSize;\n-  }\n-  ShouldNotReachHere();\n-  return 0;\n-}\n-\n","filename":"src\/hotspot\/share\/asm\/codeBuffer.hpp","additions":13,"deletions":22,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -690,1 +690,1 @@\n-  initialize_fields(stream, code_flags, method, JVMCI_CHECK_OK);\n+  initialize_fields(stream, code_flags, method, buffer, JVMCI_CHECK_OK);\n@@ -773,1 +773,1 @@\n-void CodeInstaller::initialize_fields(HotSpotCompiledCodeStream* stream, u1 code_flags, methodHandle& method, JVMCI_TRAPS) {\n+void CodeInstaller::initialize_fields(HotSpotCompiledCodeStream* stream, u1 code_flags, methodHandle& method, CodeBuffer& buffer, JVMCI_TRAPS) {\n@@ -800,0 +800,1 @@\n+  buffer.set_const_section_alignment(data_section_alignment);\n@@ -854,2 +855,2 @@\n-  int total_size = align_up(_constants_size, CodeSection::alignment(CodeBuffer::SECT_INSTS)) +\n-                   align_up(_code_size, CodeSection::alignment(CodeBuffer::SECT_STUBS)) +\n+  int total_size = align_up(_constants_size, buffer.insts()->alignment()) +\n+                   align_up(_code_size, buffer.stubs()->alignment()) +\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCodeInstaller.cpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -364,1 +364,1 @@\n-  void initialize_fields(HotSpotCompiledCodeStream* stream, u1 code_flags, methodHandle& method, JVMCI_TRAPS);\n+  void initialize_fields(HotSpotCompiledCodeStream* stream, u1 code_flags, methodHandle& method, CodeBuffer& buffer, JVMCI_TRAPS);\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCodeInstaller.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}