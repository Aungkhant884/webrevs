{"files":[{"patch":"@@ -474,0 +474,1 @@\n+    st->print(\"stack=[\" PTR_FORMAT \", \" PTR_FORMAT \")\", p2i(stack_end()), p2i(stack_base()));\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -120,1 +120,2 @@\n-  template(RendezvousGCThreads)\n+  template(RendezvousGCThreads)                   \\\n+  template(SystemMap)\n","filename":"src\/hotspot\/share\/runtime\/vmOperation.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -51,0 +51,1 @@\n+#include \"services\/memMapPrinter.hpp\"\n@@ -512,0 +513,4 @@\n+\n+void VM_PrintSystemMap::doit() {\n+  MemMapPrinter::print_all_mappings(_out, _human_readable);\n+}\n","filename":"src\/hotspot\/share\/runtime\/vmOperations.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -279,0 +279,13 @@\n+class VM_PrintSystemMap: public VM_Operation {\n+ private:\n+  outputStream* const _out;\n+  const bool _human_readable;\n+ public:\n+  VM_PrintSystemMap(outputStream* out, bool human_readable)\n+    : _out(out), _human_readable(human_readable) {}\n+  VMOp_Type type() const {\n+    return VMOp_SystemMap;\n+  }\n+  void doit();\n+};\n+\n","filename":"src\/hotspot\/share\/runtime\/vmOperations.hpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -1164,1 +1164,2 @@\n-  MemMapPrinter::print_all_mappings(output(), _human_readable.value());\n+  VM_PrintSystemMap op(output(), _human_readable.value());\n+  VMThread::execute(&op);\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+#include \"logging\/logAsyncWriter.hpp\"\n+#include \"gc\/shared\/collectedHeap.hpp\"\n@@ -29,0 +31,2 @@\n+#include \"memory\/universe.hpp\"\n+#include \"runtime\/nonJavaThread.hpp\"\n@@ -32,0 +36,1 @@\n+#include \"runtime\/vmThread.hpp\"\n@@ -112,5 +117,11 @@\n-    \/\/ Count if we have an intersection:\n-    \/\/ - A region in NMT may contain committed and uncommitted regions, hence may\n-    \/\/   be presented by multiple VMAs at the system level\n-    \/\/ - A VMA at system level may be the result of a folding operations, hence\n-    \/\/   may be represented by more than one mapping at NMT level\n+    \/\/ Count if we have an intersection.\n+    \/\/ Note:\n+    \/\/ A) A NMT virtual memory region may contain committed and uncommitted regions, therefore\n+    \/\/    it may span multiple VMAs on system level. That happens frequently for memory regions\n+    \/\/    that are committed on demand (e.g. Metaspace, heap etc).\n+    \/\/ B) A system-level VMA may be the result of a folding operation by the kernel. The kernel\n+    \/\/    folds adjacent memory mappings that share the same attributes into one.\n+    \/\/ Therefore there is no 1:1 relationship between VMA and NMT region. It is m:n. We deal\n+    \/\/ with (B) by returning a *set* of NMT flags associated with a single VMA. There is no need\n+    \/\/ to deal with (A) explicitly; it just means that adjacent VMAs show the same NMT flag. For\n+    \/\/ instance, one will always see multiple adjacent VMAs showing up as java heap or class space.\n@@ -142,0 +153,36 @@\n+\/\/ Given a VMA [from, to) and a thread, check if vma intersects with thread stack\n+static bool vma_touches_thread_stack(const void* from, const void* to, const Thread* t) {\n+  \/\/ Java thread stacks (and sometimes also other threads) have guard pages. Therefore they typically occupy\n+  \/\/ at least two distinct neighboring VMAs. Therefore we typically have a 1:n relationshipt between thread\n+  \/\/ stack and vma.\n+  \/\/ Very rarely however is a VMA backing a thread stack folded together with another adjacent VMA by the\n+  \/\/ kernel. That can happen, e.g., for non-java threads that don't have guard pages.\n+  \/\/ Therefore we go for the simplest way here and check for intersection between VMA and thread stack.\n+  const address min = MAX2((address)from, t->stack_end());\n+  const address max = MIN2((address)to, t->stack_base());\n+  return min < max;\n+}\n+\n+struct GCThreadClosure : public ThreadClosure {\n+  Thread* _t;\n+  const void* const _from;\n+  const void* const _to;\n+public:\n+  GCThreadClosure(const void* from, const void* to) : _t(nullptr), _from(from), _to(to) {}\n+  void do_thread(Thread* thread) override {\n+    if (_t == nullptr && thread != nullptr && vma_touches_thread_stack(_from, _to, thread)) {\n+      _t = thread;\n+    }\n+  }\n+};\n+\n+static uintx safely_get_thread_id(const Thread* t) {\n+  const OSThread* osth = t->osthread();\n+  uintx tid = 0;\n+  if (osth != nullptr) {\n+    return (uintx)(osth->thread_id());\n+  }\n+  return 0;\n+}\n+\n+\/\/ Given a region [from, to) that is supposed to represent a thread stack,\n@@ -143,9 +190,6 @@\n-  for (JavaThreadIteratorWithHandle jtiwh; JavaThread *thread = jtiwh.next(); ) {\n-    if (thread->is_in_full_stack((address)from + 10) || thread->is_in_full_stack((address)to - 10)) {\n-      const OSThread* osth = thread->osthread();\n-      uintx tid = 0;\n-      if (osth != nullptr) {\n-        tid = (uintx)(osth->thread_id());\n-      }\n-      st->print(\"(\" UINTX_FORMAT \" \\\"%s\\\")\", tid, ((const Thread*)thread)->name());\n-      break;\n+\n+  for (JavaThreadIteratorWithHandle jtiwh; JavaThread* t = jtiwh.next(); ) {\n+    const size_t len = pointer_delta(to, from, 1);\n+    if (vma_touches_thread_stack(from, to, t)) {\n+      st->print(\"(\" UINTX_FORMAT \" \\\"%s\\\")\", safely_get_thread_id(t), t->name());\n+      return;\n@@ -154,0 +198,17 @@\n+\n+#define HANDLE_THREAD(T)                                                        \\\n+  if (T != nullptr && vma_touches_thread_stack(from, to, T)) {                                   \\\n+    st->print(\"(\" UINTX_FORMAT \" \\\"%s\\\")\", safely_get_thread_id(T), ((const Thread*)T)->name()); \\\n+    return;                                                                     \\\n+  }\n+\n+  HANDLE_THREAD(VMThread::vm_thread());\n+  HANDLE_THREAD(WatcherThread::watcher_thread());\n+  HANDLE_THREAD(AsyncLogWriter::instance());\n+\n+  if (Universe::heap() != nullptr) {\n+    GCThreadClosure cl(from, to);\n+    Universe::heap()->gc_threads_do(&cl);\n+    HANDLE_THREAD(cl._t);\n+  }\n+#undef HANDLE_THREAD\n@@ -163,10 +224,6 @@\n-    \/\/ The address range we may be asked about may be the\n-    \/\/ result of a folding operation the kernel does at VMA level:\n-    \/\/ Two adjacent memory mappings that happen to have the same\n-    \/\/ property at the kernel level may belong, semantically, still\n-    \/\/ to different JVM sub systems, but the kernel folds those\n-    \/\/ together into a single mapping.\n-    \/\/ Since that can seriously confuse readers of this mapping\n-    \/\/ output, we try to find out if the mapping is used for multiple\n-    \/\/ purposes. We mark VMAs with more than one region with \"*\" and print\n-    \/\/ all region markings we know\n+    \/\/ The address range we may be asked about may be the result of VMA folding:\n+    \/\/ Two adjacent memory mappings that happen to have the same property will be folded\n+    \/\/ by the kernel into a single VMA.\n+    \/\/ Since that can seriously confuse readers of this mapping output, we try to find\n+    \/\/ out if the mapping is used for multiple purposes. We mark those VMAs with \"(*)\"\n+    \/\/ and print all NMT region markings.\n@@ -210,0 +267,1 @@\n+  assert(info->from() <= info->to(), \"Invalid VMA\");\n@@ -220,0 +278,1 @@\n+\n@@ -230,6 +289,2 @@\n-  st->print(\"Total: \" UINTX_FORMAT \" mappings with a total vsize of \", closure.total_count());\n-  if (human_readable) {\n-    st->print_cr(PROPERFMT \".\", PROPERFMTARGS(closure.total_vsize()));\n-  } else {\n-    st->print_cr(\"%zu.\", closure.total_vsize());\n-  }\n+  st->print(\"Total: \" UINTX_FORMAT \" mappings with a total vsize of %zu (\" PROPERFMT \")\",\n+            closure.total_count(), closure.total_vsize(), PROPERFMTARGS(closure.total_vsize()));\n","filename":"src\/hotspot\/share\/services\/memMapPrinter.cpp","additions":85,"deletions":30,"binary":false,"changes":115,"status":"modified"}]}