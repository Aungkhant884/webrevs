{"files":[{"patch":"@@ -28,1 +28,1 @@\n-#include \"services\/memMapPrinter.hpp\"\n+#include \"nmt\/memMapPrinter.hpp\"\n@@ -31,1 +31,1 @@\n-bool MemMapPrinter::pd_iterate_all_mappings(MappingPrintClosure& closure) { return true; }\n+void MemMapPrinter::pd_iterate_all_mappings(MappingPrintClosure& closure) {}\n","filename":"src\/hotspot\/os\/aix\/memMapPrinter_aix.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-#include \"services\/memMapPrinter.hpp\"\n+#include \"nmt\/memMapPrinter.hpp\"\n@@ -31,1 +31,1 @@\n-bool MemMapPrinter::pd_iterate_all_mappings(MappingPrintClosure& closure) { return true; }\n+void MemMapPrinter::pd_iterate_all_mappings(MappingPrintClosure& closure) {}\n","filename":"src\/hotspot\/os\/bsd\/memMapPrinter_bsd.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"services\/memMapPrinter.hpp\"\n+#include \"nmt\/memMapPrinter.hpp\"\n@@ -57,1 +57,1 @@\n-  void print_OS_specific_details_heading(outputStream* st) const override {\n+  void print_OS_specific_details(outputStream* st) const override {\n@@ -60,3 +60,2 @@\n-  void print_OS_specific_details_trailing(outputStream* st) const override {\n-    st->print_raw(_info.filename);\n-  }\n+\n+  const char* filename() const override { return _info.filename; }\n@@ -75,1 +74,1 @@\n-  st->print_cr(\"size          prot offset  VM info\");\n+  st->print_cr(\"size          prot offset  What\");\n@@ -78,1 +77,1 @@\n-bool MemMapPrinter::pd_iterate_all_mappings(MappingPrintClosure& closure) {\n+void MemMapPrinter::pd_iterate_all_mappings(MappingPrintClosure& closure) {\n@@ -80,1 +79,0 @@\n-  bool ok = true;\n@@ -84,1 +82,1 @@\n-    while(ok && fgets(line, sizeof(line), f) == line) {\n+    while(fgets(line, sizeof(line), f) == line) {\n@@ -89,1 +87,1 @@\n-        ok = closure.do_it(&mapinfo);\n+        closure.do_it(&mapinfo);\n@@ -94,1 +92,0 @@\n-  return ok;\n","filename":"src\/hotspot\/os\/linux\/memMapPrinter_linux.cpp","additions":8,"deletions":11,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-#include \"services\/memMapPrinter.hpp\"\n+#include \"nmt\/memMapPrinter.hpp\"\n@@ -31,1 +31,1 @@\n-bool MemMapPrinter::pd_iterate_all_mappings(MappingPrintClosure& closure) { return false; }\n+void MemMapPrinter::pd_iterate_all_mappings(MappingPrintClosure& closure) {}\n","filename":"src\/hotspot\/os\/windows\/memMapPrinter_windows.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -181,1 +181,0 @@\n-  const char* name() const override { return \"AsyncLog Thread\"; }\n@@ -206,0 +205,2 @@\n+\n+  const char* name() const override { return \"AsyncLog Thread\"; }\n","filename":"src\/hotspot\/share\/logging\/logAsyncWriter.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -169,0 +169,1 @@\n+\n","filename":"src\/hotspot\/share\/nmt\/mallocTracker.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,54 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_NMT_MEMFLAGBITMAP_HPP\n+#define SHARE_NMT_MEMFLAGBITMAP_HPP\n+\n+#include \"memory\/allocation.hpp\" \/\/ for mt_number_of_types\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+class MemFlagBitmap {\n+  uint32_t _v;\n+  STATIC_ASSERT(sizeof(_v) * BitsPerByte >= mt_number_of_types);\n+\n+public:\n+  MemFlagBitmap(uint32_t v = 0) : _v(v) {}\n+  MemFlagBitmap(const MemFlagBitmap& o) : _v(o._v) {}\n+\n+  uint32_t raw_value() const { return _v; }\n+\n+  void set_flag(MEMFLAGS f) {\n+    const int bitno = (int)f;\n+    _v |= nth_bit(bitno);\n+  }\n+\n+  bool has_flag(MEMFLAGS f) const {\n+    const int bitno = (int)f;\n+    return _v & nth_bit(bitno);\n+  }\n+\n+  bool has_any() const { return _v > 0; }\n+};\n+\n+#endif \/\/ SHARE_NMT_NMTUSAGE_HPP\n","filename":"src\/hotspot\/share\/nmt\/memFlagBitmap.hpp","additions":54,"deletions":0,"binary":false,"changes":54,"status":"added"},{"patch":"@@ -0,0 +1,291 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, Red Hat, Inc. and\/or its affiliates.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+\n+#include \"logging\/logAsyncWriter.hpp\"\n+#include \"gc\/shared\/collectedHeap.hpp\"\n+#include \"memory\/allocation.hpp\"\n+#include \"memory\/universe.hpp\"\n+#include \"runtime\/nonJavaThread.hpp\"\n+#include \"runtime\/osThread.hpp\"\n+#include \"runtime\/thread.hpp\"\n+#include \"runtime\/threadSMR.hpp\"\n+#include \"runtime\/vmThread.hpp\"\n+#include \"nmt\/memFlagBitmap.hpp\"\n+#include \"nmt\/memMapPrinter.hpp\"\n+#include \"nmt\/memTracker.hpp\"\n+#include \"nmt\/virtualMemoryTracker.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/growableArray.hpp\"\n+#include \"utilities\/ostream.hpp\"\n+\n+\/\/ Note: throughout this code we will use the term \"VMA\" for OS system level memory mapping\n+\n+\/\/\/ NMT mechanics\n+\n+\/\/ Short, clear, descriptive names for all possible markers. Note that we only expect to see\n+\/\/ those that have been used with mmap. Flags left out are printed with their nmt flag name.\n+#define NMT_FLAGS_DO(f) \\\n+  \/* flag, short, description *\/ \\\n+  f(mtGCCardSet,      \"CARDTBL\", \"GC Card table\") \\\n+  f(mtClassShared,    \"CDS\", \"CDS archives\") \\\n+  f(mtClass,          \"CLASS\", \"Class Space\") \\\n+  f(mtCode,           \"CODE\", \"Code Heap\") \\\n+  f(mtGC,             \"GC\", \"GC support data (e.g. bitmaps)\") \\\n+  f(mtInternal,       \"INTERN\", \"Internal\") \\\n+  f(mtJavaHeap,       \"JAVAHEAP\", \"Java Heap\") \\\n+  f(mtOther,          \"JDK\", \"allocated by JDK libraries other than VM\") \\\n+  f(mtMetaspace,      \"META\", \"Metaspace nodes (non-class)\") \\\n+  f(mtSafepoint,      \"POLL\", \"Polling pages\") \\\n+  f(mtThreadStack,    \"STACK\", \"(known) Thread Stack\") \\\n+  f(mtTest,           \"TEST\", \"JVM internal test mappings\")\n+  \/\/end\n+\n+static const char* get_shortname_for_nmt_flag(MEMFLAGS f) {\n+#define DO(flag, shortname, text) if (flag == f) return shortname;\n+  NMT_FLAGS_DO(DO)\n+#undef DO\n+  return NMTUtil::flag_to_enum_name(f);\n+}\n+\n+\/\/\/ NMT virtual memory\n+\n+static bool range_intersects(const void* from1, const void* to1, const void* from2, const void* to2) {\n+  const void* const min = MAX2(from1, from2);\n+  const void* const max = MIN2(to1, to2);\n+  return min < max;\n+}\n+\n+\/\/ A Cache that correlates range with MEMFLAG, optimized to be iterated quickly\n+\/\/ (cache friendly).\n+class CachedNMTInformation : public VirtualMemoryWalker {\n+  struct Range { const void* from; const void* to; };\n+  \/\/ Unfortunately, we need to allocate manually, raw, since we must prevent\n+  \/\/ NMT deadlocks (ThreadCritical).\n+  Range* _ranges;\n+  MEMFLAGS* _flags;\n+  uintx _count, _capacity;\n+public:\n+  CachedNMTInformation() : _ranges(nullptr), _flags(nullptr), _count(0), _capacity(0) {}\n+\n+  ~CachedNMTInformation() {\n+    ALLOW_C_FUNCTION(free, ::free(_ranges);)\n+    ALLOW_C_FUNCTION(free, ::free(_flags);)\n+  }\n+\n+  bool add(const void* from, const void* to, MEMFLAGS f) {\n+    assert(_count == 0 || (from >= _ranges[_count - 1].to), \"NMT regions unordered?\");\n+    \/\/ we can just fold two regions if they are adjacent and have the same flag.\n+    if (_count > 0 && from == _ranges[_count - 1].to && f == _flags[_count - 1]) {\n+      _ranges[_count - 1].to = to;\n+      return true;\n+    }\n+    if (_count == _capacity) {\n+      \/\/ Enlarge if needed\n+      const uintx new_capacity = MAX2((uintx)4096, 2 * _capacity);\n+      ALLOW_C_FUNCTION(realloc, _ranges = (Range*)::realloc(_ranges, new_capacity * sizeof(Range));)\n+      ALLOW_C_FUNCTION(realloc, _flags = (MEMFLAGS*)::realloc(_flags, new_capacity * sizeof(MEMFLAGS));)\n+      if (_ranges == nullptr || _flags == nullptr) {\n+        \/\/ In case of OOM lets make no fuzz. Just return.\n+        return false;\n+      }\n+      _capacity = new_capacity;\n+    }\n+    assert(_capacity > _count, \"Sanity\");\n+    _ranges[_count].from = from;\n+    _ranges[_count].to = to;\n+    _flags[_count] = f;\n+    _count++;\n+    return true;\n+  }\n+\n+  \/\/ Given a vma [from, to), find all regions that intersect with this vma and\n+  \/\/ return their collective flags.\n+  MemFlagBitmap lookup(const void* from, const void* to) const {\n+    MemFlagBitmap bm;\n+    for(uintx i = 0; i < _count; i++) {\n+      if (range_intersects(from, to, _ranges[i].from, _ranges[i].to)) {\n+        bm.set_flag(_flags[i]);\n+      } else if (from < _ranges[i].to) {\n+        break;\n+      }\n+    }\n+    return bm;\n+  }\n+\n+  bool do_allocation_site(const ReservedMemoryRegion* rgn) override {\n+    \/\/ Cancel iteration if we run out of memory (add returns false);\n+    return add(rgn->base(), rgn->end(), rgn->flag());\n+  }\n+\n+  \/\/ Iterate all NMT virtual memory regions and fill this cache.\n+  bool fill_from_nmt() {\n+    return VirtualMemoryTracker::walk_virtual_memory(this);\n+  }\n+};\n+\n+\/\/\/\/\/\/\/ Thread information \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+\/\/ Given a VMA [from, to) and a thread, check if vma intersects with thread stack\n+static bool vma_touches_thread_stack(const void* from, const void* to, const Thread* t) {\n+  \/\/ Java thread stacks (and sometimes also other threads) have guard pages. Therefore they typically occupy\n+  \/\/ at least two distinct neighboring VMAs. Therefore we typically have a 1:n relationshipt between thread\n+  \/\/ stack and vma.\n+  \/\/ Very rarely however is a VMA backing a thread stack folded together with another adjacent VMA by the\n+  \/\/ kernel. That can happen, e.g., for non-java threads that don't have guard pages.\n+  \/\/ Therefore we go for the simplest way here and check for intersection between VMA and thread stack.\n+  return range_intersects(from, to, (const void*)t->stack_end(), (const void*)t->stack_base());\n+}\n+\n+struct GCThreadClosure : public ThreadClosure {\n+  bool _found;\n+  uintx _tid;\n+  const void* const _from;\n+  const void* const _to;\n+  GCThreadClosure(const void* from, const void* to) : _found(false), _tid(0), _from(from), _to(to) {}\n+  void do_thread(Thread* t) override {\n+    if (_tid == 0 && t != nullptr && vma_touches_thread_stack(_from, _to, t)) {\n+      _found = true;\n+      _tid = t->osthread()->thread_id();\n+      \/\/ lemme stooop! No way to signal stop :(\n+    }\n+  }\n+};\n+\n+static void print_thread_details(uintx thread_id, const char* name, outputStream* st) {\n+  st->print(\"(\" UINTX_FORMAT \" \\\"%s\\\")\", (uintx)thread_id, name);\n+}\n+\n+\/\/ Given a region [from, to), if it intersects a known thread stack, print detail infos about that thread.\n+static void print_thread_details_for_supposed_stack_address(const void* from, const void* to, outputStream* st) {\n+\n+#define HANDLE_THREAD(T)                                                        \\\n+  if (T != nullptr && vma_touches_thread_stack(from, to, T)) {                  \\\n+    print_thread_details((uintx)(T->osthread()->thread_id()), T->name(), st);   \\\n+    return;                                                                     \\\n+  }\n+  for (JavaThreadIteratorWithHandle jtiwh; JavaThread* t = jtiwh.next(); ) {\n+    HANDLE_THREAD(t);\n+  }\n+  HANDLE_THREAD(VMThread::vm_thread());\n+  HANDLE_THREAD(WatcherThread::watcher_thread());\n+  HANDLE_THREAD(AsyncLogWriter::instance());\n+#undef HANDLE_THREAD\n+\n+  if (Universe::heap() != nullptr) {\n+    GCThreadClosure cl(from, to);\n+    Universe::heap()->gc_threads_do(&cl);\n+    if (cl._found) {\n+      print_thread_details(cl._tid, \"GC Thread\", st);\n+    }\n+  }\n+}\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+static void print_legend(outputStream* st) {\n+#define DO(flag, shortname, text) st->print_cr(\"%10s    %s\", shortname, text);\n+  NMT_FLAGS_DO(DO)\n+#undef DO\n+}\n+\n+MappingPrintClosure::MappingPrintClosure(outputStream* st, bool human_readable, const CachedNMTInformation& nmt_info) :\n+    _out(st), _human_readable(human_readable),\n+    _total_count(0), _total_vsize(0), _nmt_info(nmt_info)\n+{}\n+\n+void MappingPrintClosure::do_it(const MappingPrintInformation* info) {\n+\n+  _total_count++;\n+\n+  const void* const vma_from = info->from();\n+  const void* const vma_to = info->to();\n+\n+  \/\/ print from, to\n+  _out->print(PTR_FORMAT \" - \" PTR_FORMAT \" \", p2i(vma_from), p2i(vma_to));\n+  const size_t size = pointer_delta(vma_to, vma_from, 1);\n+  _total_vsize += size;\n+\n+  \/\/ print mapping size\n+  if (_human_readable) {\n+    _out->print(PROPERFMT \" \", PROPERFMTARGS(size));\n+  } else {\n+    _out->print(\"%11zu\", size);\n+  }\n+\n+  assert(info->from() <= info->to(), \"Invalid VMA\");\n+  _out->fill_to(53);\n+  info->print_OS_specific_details(_out);\n+  _out->fill_to(70);\n+\n+  \/\/ print NMT information, if available\n+  if (MemTracker::enabled()) {\n+    \/\/ Correlate vma region (from, to) with NMT region(s) we collected previously.\n+    const MemFlagBitmap flags = _nmt_info.lookup(vma_from, vma_to);\n+    if (flags.has_any()) {\n+      for (int i = 0; i < mt_number_of_types; i++) {\n+        const MEMFLAGS flag = (MEMFLAGS)i;\n+        if (flags.has_flag(flag)) {\n+          _out->print(\"%s\", get_shortname_for_nmt_flag(flag));\n+          if (flag == mtThreadStack) {\n+            print_thread_details_for_supposed_stack_address(vma_from, vma_to, _out);\n+          }\n+          _out->print(\" \");\n+        }\n+      }\n+    }\n+  }\n+\n+  \/\/ print file name, if available\n+  const char* f = info->filename();\n+  if (f != nullptr) {\n+    _out->print_raw(f);\n+  }\n+  _out->cr();\n+}\n+\n+void MemMapPrinter::print_all_mappings(outputStream* st, bool human_readable) {\n+  \/\/ First collect all NMT information\n+  CachedNMTInformation nmt_info;\n+  nmt_info.fill_from_nmt();\n+\n+  st->print_cr(\"Memory mappings:\");\n+  if (!MemTracker::enabled()) {\n+    st->cr();\n+    st->print_cr(\"Note: NMT is disabled, will not annotate mappings.\");\n+  }\n+  st->cr();\n+\n+  print_legend(st);\n+  st->print_cr(\"(*) - Mapping contains data from multiple regions\");\n+  st->cr();\n+\n+  pd_print_header(st);\n+  MappingPrintClosure closure(st, human_readable, nmt_info);\n+  pd_iterate_all_mappings(closure);\n+  st->print_cr(\"Total: \" UINTX_FORMAT \" mappings with a total vsize of %zu (\" PROPERFMT \")\",\n+               closure.total_count(), closure.total_vsize(), PROPERFMTARGS(closure.total_vsize()));\n+}\n","filename":"src\/hotspot\/share\/nmt\/memMapPrinter.cpp","additions":291,"deletions":0,"binary":false,"changes":291,"status":"added"},{"patch":"@@ -0,0 +1,70 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, Red Hat, Inc. and\/or its affiliates.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_SERVICES_MEMMAPPRINTER_HPP\n+#define SHARE_SERVICES_MEMMAPPRINTER_HPP\n+\n+#include \"memory\/allocation.hpp\"\n+#include \"memory\/allStatic.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+class outputStream;\n+class CachedNMTInformation;\n+\n+class MappingPrintInformation {\n+  const void* const _from;\n+  const void* const _to;\n+public:\n+  MappingPrintInformation(const void* from, const void* to) : _from(from), _to(to) {}\n+  const void* from() const { return _from; }\n+  const void* to() const { return _to; }\n+  \/\/ Will be called for each mapping before VM annotations are printed.\n+  virtual void print_OS_specific_details(outputStream* st) const {}\n+  \/\/ If mapping is backed by a file, the name of that file\n+  virtual const char* filename() const { return nullptr; }\n+};\n+\n+class MappingPrintClosure {\n+  outputStream* const _out;\n+  const bool _human_readable;\n+  uintx _total_count;\n+  size_t _total_vsize;\n+  const CachedNMTInformation& _nmt_info;\n+public:\n+  MappingPrintClosure(outputStream* st, bool human_readable, const CachedNMTInformation& nmt_info);\n+  void do_it(const MappingPrintInformation* info); \/\/ returns false if timeout reached.\n+  uintx total_count() const { return _total_count; }\n+  size_t total_vsize() const { return _total_vsize; }\n+};\n+\n+class MemMapPrinter : public AllStatic {\n+  static void pd_print_header(outputStream* st);\n+  static void pd_iterate_all_mappings(MappingPrintClosure& closure);\n+public:\n+  static void mark_page_malloced(const void* p, MEMFLAGS f);\n+  static void print_all_mappings(outputStream* st, bool human_readable);\n+};\n+\n+#endif \/\/ SHARE_SERVICES_MEMMAPPRINTER_HPP\n","filename":"src\/hotspot\/share\/nmt\/memMapPrinter.hpp","additions":70,"deletions":0,"binary":false,"changes":70,"status":"added"},{"patch":"@@ -51,1 +51,0 @@\n-#include \"services\/memMapPrinter.hpp\"\n@@ -513,4 +512,0 @@\n-\n-void VM_PrintSystemMap::doit() {\n-  MemMapPrinter::print_all_mappings(_out, _human_readable);\n-}\n","filename":"src\/hotspot\/share\/runtime\/vmOperations.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -279,13 +279,0 @@\n-class VM_PrintSystemMap: public VM_Operation {\n- private:\n-  outputStream* const _out;\n-  const bool _human_readable;\n- public:\n-  VM_PrintSystemMap(outputStream* out, bool human_readable)\n-    : _out(out), _human_readable(human_readable) {}\n-  VMOp_Type type() const {\n-    return VMOp_SystemMap;\n-  }\n-  void doit();\n-};\n-\n","filename":"src\/hotspot\/share\/runtime\/vmOperations.hpp","additions":0,"deletions":13,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -43,0 +43,2 @@\n+#include \"nmt\/memMapPrinter.hpp\"\n+#include \"nmt\/memTracker.hpp\"\n@@ -63,1 +65,0 @@\n-#include \"services\/memMapPrinter.hpp\"\n@@ -1159,1 +1160,2 @@\n-  _human_readable(\"-H\", \"Human readable format\", \"BOOLEAN\", false, \"false\") {\n+  _human_readable(\"-H\", \"Human readable format\", \"BOOLEAN\", false, \"false\"),\n+  _filename(\"-f\", \"file path (defaults: \\\"vm_memory_map_<pid>.txt\\\")\", \"STRING\", false) {\n@@ -1161,0 +1163,1 @@\n+  _dcmdparser.add_dcmd_option(&_filename);\n@@ -1164,2 +1167,18 @@\n-  VM_PrintSystemMap op(output(), _human_readable.value());\n-  VMThread::execute(&op);\n+  stringStream default_name;\n+  default_name.print(\"vm_memory_map_%d.txt\", os::current_process_id());\n+  const char* name = _filename.is_set() ? _filename.value() : default_name.base();\n+  fileStream fs(name);\n+  if (fs.is_open()) {\n+    if (!MemTracker::enabled()) {\n+      output()->print_cr(\"Note: NMT is disabled. Memory map will be printed without VM annotations.\");\n+    }\n+    MemMapPrinter::print_all_mappings(&fs, _human_readable.value());\n+#ifndef _WIN32\n+    char buf[4096];\n+    const char* absname = os::Posix::realpath(name, buf,  sizeof(buf));\n+    name = absname != nullptr ? absname : name;\n+#endif\n+    output()->print_cr(\"Memory map dumped to \\\"%s\\\".\", name);\n+  } else {\n+    output()->print_cr(\"Failed to open \\\"%s\\\" for writing.\", name);\n+  }\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.cpp","additions":23,"deletions":4,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -983,0 +983,1 @@\n+  DCmdArgument<char*> _filename;\n@@ -984,1 +985,1 @@\n-  static int num_arguments() { return 1; }\n+  static int num_arguments() { return 2; }\n@@ -990,1 +991,1 @@\n-    return \"Prints out an annotated memory map. Requires NMT to be enabled.\";\n+    return \"Dumps an annotated process memory map to an output file.\";\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1,303 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2023, Red Hat, Inc. and\/or its affiliates.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"precompiled.hpp\"\n-\n-#include \"logging\/logAsyncWriter.hpp\"\n-#include \"gc\/shared\/collectedHeap.hpp\"\n-#include \"memory\/allocation.hpp\"\n-#include \"memory\/universe.hpp\"\n-#include \"runtime\/nonJavaThread.hpp\"\n-#include \"runtime\/osThread.hpp\"\n-#include \"runtime\/thread.hpp\"\n-#include \"runtime\/threadSMR.hpp\"\n-#include \"runtime\/vmThread.hpp\"\n-#include \"services\/memMapPrinter.hpp\"\n-#include \"nmt\/memTracker.hpp\"\n-#include \"nmt\/virtualMemoryTracker.hpp\"\n-#include \"utilities\/globalDefinitions.hpp\"\n-#include \"utilities\/ostream.hpp\"\n-\n-\/\/ Note: throughout this code we will use the term \"VMA\" for OS system level memory mapping\n-\n-\/\/\/ NMT mechanics\n-\n-\/\/ Short, clear, descriptive names for all possible markers. Note that we only expect to see\n-\/\/ those that have been used with mmap. Others I leave at nullptr.\n-#define NMTFLAGS_DO(f) \\\n-  \/* flag, short, description *\/ \\\n-  f(mtGCCardSet,      \"CARDTBL\", \"GC Card table\") \\\n-  f(mtClassShared,    \"CDS\", \"CDS archives\") \\\n-  f(mtClass,          \"CLASS\", \"Class Space\") \\\n-  f(mtCode,           \"CODE\", \"Code Heap\") \\\n-  f(mtGC,             \"GC\", \"GC support data (e.g. bitmaps)\") \\\n-  f(mtInternal,       \"INTERN\", \"Internal\") \\\n-  f(mtJavaHeap,       \"JAVAHEAP\", \"Java Heap\") \\\n-  f(mtOther,          \"JDK\", \"allocated by JDK libraries other than VM\") \\\n-  f(mtMetaspace,      \"META\", \"Metaspace nodes (non-class)\") \\\n-  f(mtSafepoint,      \"POLL\", \"Polling pages\") \\\n-  f(mtThreadStack,    \"STACK\", \"(known) Thread Stack\")\n-  \/\/end\n-\n-static const char* get_shortname_for_nmt_flag(MEMFLAGS f) {\n-#define DO(flag, shortname, text) if (flag == f) return shortname;\n-  NMTFLAGS_DO(DO)\n-#undef DO\n-  return NMTUtil::flag_to_enum_name(f);\n-}\n-\n-class MemFlagBitmap {\n-  uint32_t _v;\n-  STATIC_ASSERT(sizeof(_v) * BitsPerByte >= mt_number_of_types);\n-\n-public:\n-  MemFlagBitmap(uint32_t v = 0) : _v(v) {}\n-  MemFlagBitmap(const MemFlagBitmap& o) : _v(o._v) {}\n-\n-  uint32_t raw_value() const { return _v; }\n-\n-  void set_flag(MEMFLAGS f) {\n-    const int bitno = (int)f;\n-    _v |= nth_bit(bitno);\n-  }\n-\n-  bool has_flag(MEMFLAGS f) const {\n-    const int bitno = (int)f;\n-    return _v & nth_bit(bitno);\n-  }\n-\n-  bool has_any() const { return _v > 0; }\n-\n-};\n-\n-\/\/\/ NMT virtual memory\n-\n-struct NMTRegionSearchWalker : public VirtualMemoryWalker {\n-\n-  const void* const _from;\n-  const void* const _to;\n-  \/\/ Number of round region associations by type\n-  MemFlagBitmap _found;\n-  enum class MatchType {\n-    exact,        \/\/ VMA is the same size as NMT region\n-    vma_superset, \/\/ VMA is a superset of the region\n-    nmt_superset, \/\/ NMT region is a superset of VMA\n-    unclear       \/\/ unclear match\n-  };\n-  MatchType _match_type;\n-\n-  NMTRegionSearchWalker(const void* from, const void* to) :\n-    _from(from), _to(to), _found(), _match_type(MatchType::unclear) {\n-  }\n-\n-  bool do_allocation_site(const ReservedMemoryRegion* rgn) {\n-\n-    \/\/ Count if we have an intersection.\n-    \/\/ Note:\n-    \/\/ A) A NMT virtual memory region may contain committed and uncommitted regions, therefore\n-    \/\/    it may span multiple VMAs on system level. That happens frequently for memory regions\n-    \/\/    that are committed on demand (e.g. Metaspace, heap etc).\n-    \/\/ B) A system-level VMA may be the result of a folding operation by the kernel. The kernel\n-    \/\/    folds adjacent memory mappings that share the same attributes into one.\n-    \/\/ Therefore there is no 1:1 relationship between VMA and NMT region. It is m:n. We deal\n-    \/\/ with (B) by returning a *set* of NMT flags associated with a single VMA. There is no need\n-    \/\/ to deal with (A) explicitly; it just means that adjacent VMAs show the same NMT flag. For\n-    \/\/ instance, one will always see multiple adjacent VMAs showing up as java heap or class space.\n-    address intersection_from = MAX2(rgn->base(), (address)_from);\n-    address intersection_to = MIN2(rgn->end(), (address)_to);\n-    if (intersection_from < intersection_to) {\n-      \/\/ we intersect\n-      const MEMFLAGS flag = rgn->flag();\n-      _found.set_flag(flag);\n-      if (_match_type == MatchType::unclear) {\n-        if (rgn->base() == (address)_from && rgn->end() == (address)_to) {\n-          _match_type = MatchType::exact;\n-        } else if (rgn->base() <= (address)_from && rgn->end() >= (address)_to) {\n-          \/\/ this will most often happen, since JVM regions are typically committed on demand,\n-          \/\/ leaving us with multiple matching VMAs at the system that differ by protectedness.\n-          _match_type = MatchType::nmt_superset;\n-        } else if ((address)_from <= rgn->base() && (address)_to >= rgn->end()) {\n-          \/\/ This can happen if mappings from different JVM subsystems are mapped adjacent\n-          \/\/ of each other and share the same properties; the kernel will fold them into\n-          \/\/ one OS-side VMA.\n-          _match_type = MatchType::vma_superset;\n-        }\n-      }\n-    }\n-    return true;\n-  }\n-};\n-\n-\/\/ Given a VMA [from, to) and a thread, check if vma intersects with thread stack\n-static bool vma_touches_thread_stack(const void* from, const void* to, const Thread* t) {\n-  \/\/ Java thread stacks (and sometimes also other threads) have guard pages. Therefore they typically occupy\n-  \/\/ at least two distinct neighboring VMAs. Therefore we typically have a 1:n relationshipt between thread\n-  \/\/ stack and vma.\n-  \/\/ Very rarely however is a VMA backing a thread stack folded together with another adjacent VMA by the\n-  \/\/ kernel. That can happen, e.g., for non-java threads that don't have guard pages.\n-  \/\/ Therefore we go for the simplest way here and check for intersection between VMA and thread stack.\n-  const address min = MAX2((address)from, t->stack_end());\n-  const address max = MIN2((address)to, t->stack_base());\n-  return min < max;\n-}\n-\n-struct GCThreadClosure : public ThreadClosure {\n-  Thread* _t;\n-  const void* const _from;\n-  const void* const _to;\n-public:\n-  GCThreadClosure(const void* from, const void* to) : _t(nullptr), _from(from), _to(to) {}\n-  void do_thread(Thread* thread) override {\n-    if (_t == nullptr && thread != nullptr && vma_touches_thread_stack(_from, _to, thread)) {\n-      _t = thread;\n-    }\n-  }\n-};\n-\n-static uintx safely_get_thread_id(const Thread* t) {\n-  const OSThread* osth = t->osthread();\n-  uintx tid = 0;\n-  if (osth != nullptr) {\n-    return (uintx)(osth->thread_id());\n-  }\n-  return 0;\n-}\n-\n-\/\/ Given a region [from, to) that is supposed to represent a thread stack,\n-static void print_thread_details_for_supposed_stack_address(const void* from, const void* to, outputStream* st) {\n-\n-  for (JavaThreadIteratorWithHandle jtiwh; JavaThread* t = jtiwh.next(); ) {\n-    const size_t len = pointer_delta(to, from, 1);\n-    if (vma_touches_thread_stack(from, to, t)) {\n-      st->print(\"(\" UINTX_FORMAT \" \\\"%s\\\")\", safely_get_thread_id(t), t->name());\n-      return;\n-    }\n-  }\n-\n-#define HANDLE_THREAD(T)                                                        \\\n-  if (T != nullptr && vma_touches_thread_stack(from, to, T)) {                                   \\\n-    st->print(\"(\" UINTX_FORMAT \" \\\"%s\\\")\", safely_get_thread_id(T), ((const Thread*)T)->name()); \\\n-    return;                                                                     \\\n-  }\n-\n-  HANDLE_THREAD(VMThread::vm_thread());\n-  HANDLE_THREAD(WatcherThread::watcher_thread());\n-  HANDLE_THREAD(AsyncLogWriter::instance());\n-\n-  if (Universe::heap() != nullptr) {\n-    GCThreadClosure cl(from, to);\n-    Universe::heap()->gc_threads_do(&cl);\n-    HANDLE_THREAD(cl._t);\n-  }\n-#undef HANDLE_THREAD\n-}\n-\n-static bool ask_nmt_about(const void* from, const void* to, outputStream* st) {\n-  if (!MemTracker::enabled()) {\n-    return false;\n-  }\n-  NMTRegionSearchWalker walker(from, to);\n-  VirtualMemoryTracker::walk_virtual_memory(&walker);\n-  if (walker._found.has_any()) {\n-    \/\/ The address range we may be asked about may be the result of VMA folding:\n-    \/\/ Two adjacent memory mappings that happen to have the same property will be folded\n-    \/\/ by the kernel into a single VMA.\n-    \/\/ Since that can seriously confuse readers of this mapping output, we try to find\n-    \/\/ out if the mapping is used for multiple purposes. We mark those VMAs with \"(*)\"\n-    \/\/ and print all NMT region markings.\n-    for (int i = 0; i < mt_number_of_types; i++) {\n-      const MEMFLAGS flag = (MEMFLAGS)i;\n-      if (walker._found.has_flag(flag)) {\n-        st->print(\"%s\", get_shortname_for_nmt_flag(flag));\n-        if (flag == mtThreadStack) {\n-          print_thread_details_for_supposed_stack_address(from, to, st);\n-        }\n-        st->print(\" \");\n-      }\n-    }\n-    if (walker._match_type == NMTRegionSearchWalker::MatchType::vma_superset) {\n-      st->print(\" (*)\");\n-    }\n-    return true;\n-  }\n-\n-  return false;\n-}\n-\n-static void print_legend(outputStream* st) {\n-#define DO(flag, shortname, text) st->print_cr(\"%10s    %s\", shortname, text);\n-  NMTFLAGS_DO(DO)\n-#undef DO\n-}\n-\n-MappingPrintClosure::MappingPrintClosure(outputStream* st, bool human_readable, jlong timeout_at) :\n-    _out(st), _human_readable(human_readable), _timeout_at(timeout_at), _total_count(0), _total_vsize(0) {}\n-\n-bool MappingPrintClosure::do_it(const MappingPrintInformation* info) {\n-  _total_count++;\n-  _out->print(PTR_FORMAT \" - \" PTR_FORMAT \" \", p2i(info->from()), p2i(info->to()));\n-  const size_t size = pointer_delta(info->to(), info->from(), 1);\n-  _total_vsize += size;\n-  if (_human_readable) {\n-    _out->print(PROPERFMT \" \", PROPERFMTARGS(size));\n-  } else {\n-    _out->print(\"%11zu\", size);\n-  }\n-  assert(info->from() <= info->to(), \"Invalid VMA\");\n-  _out->fill_to(53);\n-  info->print_OS_specific_details_heading(_out);\n-  _out->fill_to(70);\n-  ask_nmt_about(info->from(), info->to(), _out);\n-  _out->fill_to(100);\n-  info->print_OS_specific_details_trailing(_out);\n-  _out->cr();\n-\n-  return _timeout_at > os::javaTimeNanos(); \/\/ false if timeout\n-}\n-\n-void MemMapPrinter::print_all_mappings(outputStream* st, bool human_readable) {\n-\n-  st->print_cr(\"Memory mappings:\");\n-  if (!MemTracker::enabled()) {\n-    st->print_cr(\" (For full functionality, please enable Native Memory Tracking)\");\n-  }\n-  st->cr();\n-  print_legend(st);\n-  st->print_cr(\"(*) - Mapping contains data from multiple regions\");\n-  st->cr();\n-  pd_print_header(st);\n-  \/\/ Under rare circumstances the process memory map may be insanely large and\/or fragmented. We cap\n-  \/\/ the absolute runtime of printing to blocking other VM operations too long.\n-  const jlong timeout_at = os::javaTimeNanos() +\n-                           ((jlong)(SafepointTimeoutDelay * NANOSECS_PER_MILLISEC) \/ 2);\n-  MappingPrintClosure closure(st, human_readable, timeout_at);\n-  bool ok = pd_iterate_all_mappings(closure);\n-  if (!ok) {\n-    st->print_cr(\"Aborted after printing \" UINTX_FORMAT \" mappings, took too long.\", closure.total_count());\n-  } else {\n-    st->print_cr(\"Total: \" UINTX_FORMAT \" mappings with a total vsize of %zu (\" PROPERFMT \")\",\n-                 closure.total_count(), closure.total_vsize(), PROPERFMTARGS(closure.total_vsize()));\n-  }\n-}\n","filename":"src\/hotspot\/share\/services\/memMapPrinter.cpp","additions":0,"deletions":303,"binary":false,"changes":303,"status":"deleted"},{"patch":"@@ -1,72 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2023, Red Hat, Inc. and\/or its affiliates.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_SERVICES_MEMMAPPRINTER_HPP\n-#define SHARE_SERVICES_MEMMAPPRINTER_HPP\n-\n-#include \"memory\/allocation.hpp\"\n-#include \"memory\/allStatic.hpp\"\n-#include \"utilities\/globalDefinitions.hpp\"\n-\n-class outputStream;\n-\n-class MappingPrintInformation {\n-  const void* const _from;\n-  const void* const _to;\n-public:\n-  MappingPrintInformation(const void* from, const void* to) : _from(from), _to(to) {}\n-  const void* from() const { return _from; }\n-  const void* to() const { return _to; }\n-  \/\/ Will be called for each mapping before VM annotations are printed.\n-  \/\/ Platforms should print any details that should appear between the mapping addresses\n-  \/\/  and the VM annotations.\n-  virtual void print_OS_specific_details_heading(outputStream* st) const {}\n-  \/\/ Will be called for each mapping before VM annotations are printed.\n-  \/\/ Platforms should print any details that should appear at the end of the line.\n-  virtual void print_OS_specific_details_trailing(outputStream* st) const {}\n-};\n-\n-class MappingPrintClosure {\n-  outputStream* const _out;\n-  const bool _human_readable;\n-  const int64_t _timeout_at;\n-  uintx _total_count;\n-  size_t _total_vsize;\n-public:\n-  MappingPrintClosure(outputStream* st, bool human_readable, jlong timeout_ms);\n-  bool do_it(const MappingPrintInformation* info); \/\/ returns false if timeout reached.\n-  uintx total_count() const { return _total_count; }\n-  size_t total_vsize() const { return _total_vsize; }\n-};\n-\n-class MemMapPrinter : public AllStatic {\n-  static void pd_print_header(outputStream* st);\n-  static bool pd_iterate_all_mappings(MappingPrintClosure& closure);\n-public:\n-  static void mark_page_malloced(const void* p, MEMFLAGS f);\n-  static void print_all_mappings(outputStream* st, bool human_readable);\n-};\n-\n-#endif \/\/ SHARE_SERVICES_MEMMAPPRINTER_HPP\n","filename":"src\/hotspot\/share\/services\/memMapPrinter.hpp","additions":0,"deletions":72,"binary":false,"changes":72,"status":"deleted"},{"patch":"@@ -29,0 +29,6 @@\n+import java.io.*;\n+import java.util.ArrayDeque;\n+import java.util.Collections;\n+import java.util.Deque;\n+import java.util.regex.Pattern;\n+\n@@ -44,10 +50,10 @@\n-        \/\/ Only with NMT we get VM annotations\n-        boolean have_nmt = !output.getOutput().contains(\"please enable Native Memory Tracking\");\n-\n-        if (have_nmt) {\n-            String expectedMarkings[] = new String[] { \"STACK\", \"JAVAHEAP\", \"META\", \"CODE\", \"POLL\" };\n-            for (String s : expectedMarkings) {\n-                output.shouldMatch(\"0x[0-9a-fA-F]+ *- *0x[0-9a-fA-F]+ +\\\\d+.*\" + s + \".*\");\n-            }\n-        } else {\n-            output.shouldMatch(\"0x[0-9a-fA-F]+ *- *0x[0-9a-fA-F]+ +\\\\d+.*\");\n+        String filename = output.firstMatch(\"Memory map dumped to \\\"(\\\\S*vm_memory_map_\\\\d+\\\\.txt)\\\".*\", 1);\n+        if (filename == null) {\n+            throw new RuntimeException(\"Did not find dump file in output.\\n\");\n+        }\n+        File f = new File(filename);\n+        if (!f.exists()) {\n+            throw new RuntimeException(\"dump file not found.\");\n+        }\n+        if (f.length() == 0) {\n+            throw new RuntimeException(\"dump file 0.\");\n@@ -55,2 +61,0 @@\n-        output.shouldMatch(\"0x[0-9a-fA-F]+ *- *0x[0-9a-fA-F]+ +\\\\d+.*libjvm.so.*\");\n-        output.shouldMatch(\".*Total: \\\\d+ mappings with a total vsize of \\\\d+.*\");\n","filename":"test\/hotspot\/jtreg\/serviceability\/dcmd\/vm\/SystemMapTest.java","additions":16,"deletions":12,"binary":false,"changes":28,"status":"modified"}]}