{"files":[{"patch":"@@ -0,0 +1,34 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, Red Hat, Inc. and\/or its affiliates.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+\n+#include \"services\/memMapPrinter.hpp\"\n+#include \"utilities\/ostream.hpp\"\n+\n+void MemMapPrinter::pd_iterate_all_mappings(MappingPrintClosure& closure) {}\n+void MemMapPrinter::pd_print_header(outputStream* st) {\n+  st->print_cr(\"not available\");\n+}\n","filename":"src\/hotspot\/os\/aix\/memMapPrinter_aix.cpp","additions":34,"deletions":0,"binary":false,"changes":34,"status":"added"},{"patch":"@@ -0,0 +1,34 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, Red Hat, Inc. and\/or its affiliates.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+\n+#include \"services\/memMapPrinter.hpp\"\n+#include \"utilities\/ostream.hpp\"\n+\n+void MemMapPrinter::pd_iterate_all_mappings(MappingPrintClosure& closure) {}\n+void MemMapPrinter::pd_print_header(outputStream* st) {\n+  st->print_cr(\"not available\");\n+}\n","filename":"src\/hotspot\/os\/bsd\/memMapPrinter_bsd.cpp","additions":34,"deletions":0,"binary":false,"changes":34,"status":"added"},{"patch":"@@ -0,0 +1,92 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, Red Hat, Inc. and\/or its affiliates.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+\n+#include \"runtime\/os.hpp\"\n+#include \"services\/memMapPrinter.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+struct proc_maps_info_t {\n+  unsigned long long from = 0;\n+  unsigned long long to = 0;\n+  char prot[20 + 1];\n+  char offset[20 + 1];\n+  char dev[20 + 1];\n+  char inode[20 + 1];\n+  char filename[1024 + 1];\n+\n+  bool scan_proc_maps_line(const char* line) {\n+    prot[0] = offset[0] = dev[0] = inode[0] = filename[0] = '\\0';\n+    const int items_read = ::sscanf(line, \"%llx-%llx %20s %20s %20s %20s %1024s\",\n+        &from, &to, prot, offset, dev, inode, filename);\n+    if (items_read < 2) {\n+      return false;\n+    }\n+    return items_read >= 2; \/\/ need at least from and to\n+  }\n+};\n+\n+class LinuxMappingPrintInformation : public MappingPrintInformation {\n+  const proc_maps_info_t _info;\n+public:\n+\n+  LinuxMappingPrintInformation(const void* from, const void* to, const proc_maps_info_t* info) :\n+    MappingPrintInformation(from, to), _info(*info) {}\n+\n+  void print_details_1(outputStream* st) const override {\n+    st->print(\"%s %s \", _info.prot, _info.offset);\n+  }\n+  void print_details_2(outputStream* st) const override {\n+    st->print_raw(_info.filename);\n+  }\n+};\n+\n+void MemMapPrinter::pd_print_header(outputStream* st) {\n+  st->print(\n+#ifdef _LP64\n+      \"from                 to                 \"\n+#else\n+      \"from         to         \"\n+#endif\n+  );\n+  st->print_cr(\"size          prot offset  VM info\");\n+}\n+\n+void MemMapPrinter::pd_iterate_all_mappings(MappingPrintClosure& closure) {\n+  FILE* f = os::fopen(\"\/proc\/self\/maps\", \"r\");\n+  if (f != nullptr) {\n+    char line[1024];\n+    while(fgets(line, sizeof(line), f) == line) {\n+      line[sizeof(line) - 1] = '\\0';\n+      proc_maps_info_t info;\n+      if (info.scan_proc_maps_line(line)) {\n+        LinuxMappingPrintInformation mapinfo((void*)info.from, (void*)info.to, &info);\n+        closure.do_it(&mapinfo);\n+      }\n+    }\n+    ::fclose(f);\n+  }\n+}\n","filename":"src\/hotspot\/os\/linux\/memMapPrinter_linux.cpp","additions":92,"deletions":0,"binary":false,"changes":92,"status":"added"},{"patch":"@@ -0,0 +1,34 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, Red Hat, Inc. and\/or its affiliates.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+\n+#include \"services\/memMapPrinter.hpp\"\n+#include \"utilities\/ostream.hpp\"\n+\n+void MemMapPrinter::pd_iterate_all_mappings(MappingPrintClosure& closure) {}\n+void MemMapPrinter::pd_print_header(outputStream* st) {\n+  st->print_cr(\"not available\");\n+}\n","filename":"src\/hotspot\/os\/windows\/memMapPrinter_windows.cpp","additions":34,"deletions":0,"binary":false,"changes":34,"status":"added"},{"patch":"@@ -169,1 +169,0 @@\n-\n","filename":"src\/hotspot\/share\/nmt\/mallocTracker.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -474,0 +474,1 @@\n+    st->print(\"stack=[\" PTR_FORMAT \", \" PTR_FORMAT \")\", p2i(stack_end()), p2i(stack_base()));\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -120,1 +120,2 @@\n-  template(RendezvousGCThreads)\n+  template(RendezvousGCThreads)                   \\\n+  template(SystemMap)\n","filename":"src\/hotspot\/share\/runtime\/vmOperation.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -51,0 +51,1 @@\n+#include \"services\/memMapPrinter.hpp\"\n@@ -512,0 +513,4 @@\n+\n+void VM_PrintSystemMap::doit() {\n+  MemMapPrinter::print_all_mappings(_out, _human_readable);\n+}\n","filename":"src\/hotspot\/share\/runtime\/vmOperations.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -279,0 +279,13 @@\n+class VM_PrintSystemMap: public VM_Operation {\n+ private:\n+  outputStream* const _out;\n+  const bool _human_readable;\n+ public:\n+  VM_PrintSystemMap(outputStream* out, bool human_readable)\n+    : _out(out), _human_readable(human_readable) {}\n+  VMOp_Type type() const {\n+    return VMOp_SystemMap;\n+  }\n+  void doit();\n+};\n+\n","filename":"src\/hotspot\/share\/runtime\/vmOperations.hpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -63,0 +63,1 @@\n+#include \"services\/memMapPrinter.hpp\"\n@@ -136,0 +137,1 @@\n+  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<SystemMapDCmd>(full_export, true,false));\n@@ -1154,0 +1156,11 @@\n+\n+SystemMapDCmd::SystemMapDCmd(outputStream* output, bool heap) :\n+    DCmdWithParser(output, heap),\n+  _human_readable(\"-H\", \"Human readable format\", \"BOOLEAN\", false, \"false\") {\n+  _dcmdparser.add_dcmd_option(&_human_readable);\n+}\n+\n+void SystemMapDCmd::execute(DCmdSource source, TRAPS) {\n+  VM_PrintSystemMap op(output(), _human_readable.value());\n+  VMThread::execute(&op);\n+}\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.cpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -981,0 +981,22 @@\n+class SystemMapDCmd : public DCmdWithParser {\n+  DCmdArgument<bool> _human_readable;\n+public:\n+  static int num_arguments() { return 1; }\n+  SystemMapDCmd(outputStream* output, bool heap);\n+  static const char* name() {\n+    return \"System.map\";\n+  }\n+  static const char* description() {\n+    return \"Prints out an annotated memory map. Requires NMT to be enabled.\";\n+  }\n+  static const char* impact() {\n+    return \"Low\";\n+  }\n+  static const JavaPermission permission() {\n+    JavaPermission p = {\"java.lang.management.ManagementPermission\",\n+                        \"control\", nullptr};\n+    return p;\n+  }\n+  virtual void execute(DCmdSource source, TRAPS);\n+};\n+\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.hpp","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -0,0 +1,292 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, Red Hat, Inc. and\/or its affiliates.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+\n+#include \"logging\/logAsyncWriter.hpp\"\n+#include \"gc\/shared\/collectedHeap.hpp\"\n+#include \"memory\/allocation.hpp\"\n+#include \"memory\/universe.hpp\"\n+#include \"runtime\/nonJavaThread.hpp\"\n+#include \"runtime\/osThread.hpp\"\n+#include \"runtime\/thread.hpp\"\n+#include \"runtime\/threadSMR.hpp\"\n+#include \"runtime\/vmThread.hpp\"\n+#include \"services\/memMapPrinter.hpp\"\n+#include \"nmt\/memTracker.hpp\"\n+#include \"nmt\/virtualMemoryTracker.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/ostream.hpp\"\n+\n+\/\/ Note: throughout this code we will use the term \"VMA\" for OS system level memory mapping\n+\n+\/\/\/ NMT mechanics\n+\n+\/\/ Short, clear, descriptive names for all possible markers. Note that we only expect to see\n+\/\/ those that have been used with mmap. Others I leave at nullptr.\n+#define NMTFLAGS_DO(f) \\\n+  \/* flag, short, description *\/ \\\n+  f(mtGCCardSet,      \"CARDTBL\", \"GC Card table\") \\\n+  f(mtClassShared,    \"CDS\", \"CDS archives\") \\\n+  f(mtClass,          \"CLASS\", \"Class Space\") \\\n+  f(mtCode,           \"CODE\", \"Code Heap\") \\\n+  f(mtGC,             \"GC\", \"GC support data (e.g. bitmaps)\") \\\n+  f(mtInternal,       \"INTERN\", \"Internal\") \\\n+  f(mtJavaHeap,       \"JAVAHEAP\", \"Java Heap\") \\\n+  f(mtOther,          \"JDK\", \"allocated by JDK libraries other than VM\") \\\n+  f(mtMetaspace,      \"META\", \"Metaspace nodes (non-class)\") \\\n+  f(mtSafepoint,      \"POLL\", \"Polling pages\") \\\n+  f(mtThreadStack,    \"STACK\", \"(known) Thread Stack\")\n+  \/\/end\n+\n+static const char* get_shortname_for_nmt_flag(MEMFLAGS f) {\n+#define DO(flag, shortname, text) if (flag == f) return shortname;\n+  NMTFLAGS_DO(DO)\n+#undef DO\n+  return NMTUtil::flag_to_enum_name(f);\n+}\n+\n+class MemFlagBitmap {\n+  uint32_t _v;\n+  STATIC_ASSERT(sizeof(_v) * BitsPerByte >= mt_number_of_types);\n+\n+public:\n+  MemFlagBitmap(uint32_t v = 0) : _v(v) {}\n+  MemFlagBitmap(const MemFlagBitmap& o) : _v(o._v) {}\n+\n+  uint32_t raw_value() const { return _v; }\n+\n+  void set_flag(MEMFLAGS f) {\n+    const int bitno = (int)f;\n+    _v |= nth_bit(bitno);\n+  }\n+\n+  bool has_flag(MEMFLAGS f) const {\n+    const int bitno = (int)f;\n+    return _v & nth_bit(bitno);\n+  }\n+\n+  bool has_any() const { return _v > 0; }\n+\n+};\n+\n+\/\/\/ NMT virtual memory\n+\n+struct NMTRegionSearchWalker : public VirtualMemoryWalker {\n+\n+  const void* const _from;\n+  const void* const _to;\n+  \/\/ Number of round region associations by type\n+  MemFlagBitmap _found;\n+  enum class MatchType {\n+    exact,        \/\/ VMA is the same size as NMT region\n+    vma_superset, \/\/ VMA is a superset of the region\n+    nmt_superset, \/\/ NMT region is a superset of VMA\n+    unclear       \/\/ unclear match\n+  };\n+  MatchType _match_type;\n+\n+  NMTRegionSearchWalker(const void* from, const void* to) :\n+    _from(from), _to(to), _found(), _match_type(MatchType::unclear) {\n+  }\n+\n+  bool do_allocation_site(const ReservedMemoryRegion* rgn) {\n+\n+    \/\/ Count if we have an intersection.\n+    \/\/ Note:\n+    \/\/ A) A NMT virtual memory region may contain committed and uncommitted regions, therefore\n+    \/\/    it may span multiple VMAs on system level. That happens frequently for memory regions\n+    \/\/    that are committed on demand (e.g. Metaspace, heap etc).\n+    \/\/ B) A system-level VMA may be the result of a folding operation by the kernel. The kernel\n+    \/\/    folds adjacent memory mappings that share the same attributes into one.\n+    \/\/ Therefore there is no 1:1 relationship between VMA and NMT region. It is m:n. We deal\n+    \/\/ with (B) by returning a *set* of NMT flags associated with a single VMA. There is no need\n+    \/\/ to deal with (A) explicitly; it just means that adjacent VMAs show the same NMT flag. For\n+    \/\/ instance, one will always see multiple adjacent VMAs showing up as java heap or class space.\n+    address intersection_from = MAX2(rgn->base(), (address)_from);\n+    address intersection_to = MIN2(rgn->end(), (address)_to);\n+    if (intersection_from < intersection_to) {\n+      \/\/ we intersect\n+      const MEMFLAGS flag = rgn->flag();\n+      _found.set_flag(flag);\n+      if (_match_type == MatchType::unclear) {\n+        if (rgn->base() == (address)_from && rgn->end() == (address)_to) {\n+          _match_type = MatchType::exact;\n+        } else if (rgn->base() <= (address)_from && rgn->end() >= (address)_to) {\n+          \/\/ this will most often happen, since JVM regions are typically committed on demand,\n+          \/\/ leaving us with multiple matching VMAs at the system that differ by protectedness.\n+          _match_type = MatchType::nmt_superset;\n+        } else if ((address)_from <= rgn->base() && (address)_to >= rgn->end()) {\n+          \/\/ This can happen if mappings from different JVM subsystems are mapped adjacent\n+          \/\/ of each other and share the same properties; the kernel will fold them into\n+          \/\/ one OS-side VMA.\n+          _match_type = MatchType::vma_superset;\n+        }\n+      }\n+    }\n+    return true;\n+  }\n+};\n+\n+\/\/ Given a VMA [from, to) and a thread, check if vma intersects with thread stack\n+static bool vma_touches_thread_stack(const void* from, const void* to, const Thread* t) {\n+  \/\/ Java thread stacks (and sometimes also other threads) have guard pages. Therefore they typically occupy\n+  \/\/ at least two distinct neighboring VMAs. Therefore we typically have a 1:n relationshipt between thread\n+  \/\/ stack and vma.\n+  \/\/ Very rarely however is a VMA backing a thread stack folded together with another adjacent VMA by the\n+  \/\/ kernel. That can happen, e.g., for non-java threads that don't have guard pages.\n+  \/\/ Therefore we go for the simplest way here and check for intersection between VMA and thread stack.\n+  const address min = MAX2((address)from, t->stack_end());\n+  const address max = MIN2((address)to, t->stack_base());\n+  return min < max;\n+}\n+\n+struct GCThreadClosure : public ThreadClosure {\n+  Thread* _t;\n+  const void* const _from;\n+  const void* const _to;\n+public:\n+  GCThreadClosure(const void* from, const void* to) : _t(nullptr), _from(from), _to(to) {}\n+  void do_thread(Thread* thread) override {\n+    if (_t == nullptr && thread != nullptr && vma_touches_thread_stack(_from, _to, thread)) {\n+      _t = thread;\n+    }\n+  }\n+};\n+\n+static uintx safely_get_thread_id(const Thread* t) {\n+  const OSThread* osth = t->osthread();\n+  uintx tid = 0;\n+  if (osth != nullptr) {\n+    return (uintx)(osth->thread_id());\n+  }\n+  return 0;\n+}\n+\n+\/\/ Given a region [from, to) that is supposed to represent a thread stack,\n+static void print_thread_details_for_supposed_stack_address(const void* from, const void* to, outputStream* st) {\n+\n+  for (JavaThreadIteratorWithHandle jtiwh; JavaThread* t = jtiwh.next(); ) {\n+    const size_t len = pointer_delta(to, from, 1);\n+    if (vma_touches_thread_stack(from, to, t)) {\n+      st->print(\"(\" UINTX_FORMAT \" \\\"%s\\\")\", safely_get_thread_id(t), t->name());\n+      return;\n+    }\n+  }\n+\n+#define HANDLE_THREAD(T)                                                        \\\n+  if (T != nullptr && vma_touches_thread_stack(from, to, T)) {                                   \\\n+    st->print(\"(\" UINTX_FORMAT \" \\\"%s\\\")\", safely_get_thread_id(T), ((const Thread*)T)->name()); \\\n+    return;                                                                     \\\n+  }\n+\n+  HANDLE_THREAD(VMThread::vm_thread());\n+  HANDLE_THREAD(WatcherThread::watcher_thread());\n+  HANDLE_THREAD(AsyncLogWriter::instance());\n+\n+  if (Universe::heap() != nullptr) {\n+    GCThreadClosure cl(from, to);\n+    Universe::heap()->gc_threads_do(&cl);\n+    HANDLE_THREAD(cl._t);\n+  }\n+#undef HANDLE_THREAD\n+}\n+\n+static bool ask_nmt_about(const void* from, const void* to, outputStream* st) {\n+  if (!MemTracker::enabled()) {\n+    return false;\n+  }\n+  NMTRegionSearchWalker walker(from, to);\n+  VirtualMemoryTracker::walk_virtual_memory(&walker);\n+  if (walker._found.has_any()) {\n+    \/\/ The address range we may be asked about may be the result of VMA folding:\n+    \/\/ Two adjacent memory mappings that happen to have the same property will be folded\n+    \/\/ by the kernel into a single VMA.\n+    \/\/ Since that can seriously confuse readers of this mapping output, we try to find\n+    \/\/ out if the mapping is used for multiple purposes. We mark those VMAs with \"(*)\"\n+    \/\/ and print all NMT region markings.\n+    for (int i = 0; i < mt_number_of_types; i++) {\n+      const MEMFLAGS flag = (MEMFLAGS)i;\n+      if (walker._found.has_flag(flag)) {\n+        st->print(\"%s\", get_shortname_for_nmt_flag(flag));\n+        if (flag == mtThreadStack) {\n+          print_thread_details_for_supposed_stack_address(from, to, st);\n+        }\n+        st->print(\" \");\n+      }\n+    }\n+    if (walker._match_type == NMTRegionSearchWalker::MatchType::vma_superset) {\n+      st->print(\" (*)\");\n+    }\n+    return true;\n+  }\n+  return false;\n+}\n+\n+static void print_legend(outputStream* st) {\n+#define DO(flag, shortname, text) st->print_cr(\"%10s    %s\", shortname, text);\n+  NMTFLAGS_DO(DO)\n+#undef DO\n+}\n+\n+MappingPrintClosure::MappingPrintClosure(outputStream* st, bool human_readable) :\n+    _out(st), _humam_readable(human_readable), _total_count(0), _total_vsize(0) {}\n+\n+void MappingPrintClosure::do_it(const MappingPrintInformation* info) {\n+  _total_count++;\n+  _out->print(PTR_FORMAT \" - \" PTR_FORMAT \" \", p2i(info->from()), p2i(info->to()));\n+  const size_t size = pointer_delta(info->to(), info->from(), 1);\n+  _total_vsize += size;\n+  if (_humam_readable) {\n+    _out->print(PROPERFMT \" \", PROPERFMTARGS(size));\n+  } else {\n+    _out->print(\"%11zu\", size);\n+  }\n+  assert(info->from() <= info->to(), \"Invalid VMA\");\n+  _out->fill_to(53);\n+  info->print_details_1(_out);\n+  _out->fill_to(70);\n+  ask_nmt_about(info->from(), info->to(), _out);\n+  _out->fill_to(100);\n+  info->print_details_2(_out);\n+  _out->cr();\n+}\n+\n+void MemMapPrinter::print_all_mappings(outputStream* st, bool human_readable) {\n+\n+  st->print_cr(\"Memory mappings:\");\n+  if (!MemTracker::enabled()) {\n+    st->print_cr(\" (For full functionality, please enable Native Memory Tracking)\");\n+  }\n+  st->cr();\n+  print_legend(st);\n+  st->print_cr(\"(*) - Mapping contains data from multiple regions\");\n+  st->cr();\n+  pd_print_header(st);\n+  MappingPrintClosure closure(st, human_readable);\n+  pd_iterate_all_mappings(closure);\n+  st->print_cr(\"Total: \" UINTX_FORMAT \" mappings with a total vsize of %zu (\" PROPERFMT \")\",\n+            closure.total_count(), closure.total_vsize(), PROPERFMTARGS(closure.total_vsize()));\n+}\n","filename":"src\/hotspot\/share\/services\/memMapPrinter.cpp","additions":292,"deletions":0,"binary":false,"changes":292,"status":"added"},{"patch":"@@ -0,0 +1,66 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, Red Hat, Inc. and\/or its affiliates.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_SERVICES_MEMMAPPRINTER_HPP\n+#define SHARE_SERVICES_MEMMAPPRINTER_HPP\n+\n+#include \"memory\/allocation.hpp\"\n+#include \"memory\/allStatic.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+class outputStream;\n+\n+class MappingPrintInformation {\n+  const void* const _from;\n+  const void* const _to;\n+public:\n+  MappingPrintInformation(const void* from, const void* to) : _from(from), _to(to) {}\n+  const void* from() const { return _from; }\n+  const void* to() const { return _to; }\n+  virtual void print_details_1(outputStream* st) const {} \/\/ To be printed before VM annotations\n+  virtual void print_details_2(outputStream* st) const {} \/\/ To be printed before VM annotations\n+};\n+\n+class MappingPrintClosure {\n+  outputStream* const _out;\n+  const bool _humam_readable;\n+  uintx _total_count;\n+  size_t _total_vsize;\n+public:\n+  MappingPrintClosure(outputStream* st, bool human_readable);\n+  void do_it(const MappingPrintInformation* info);\n+  uintx total_count() const { return _total_count; }\n+  size_t total_vsize() const { return _total_vsize; }\n+};\n+\n+class MemMapPrinter : public AllStatic {\n+  static void pd_print_header(outputStream* st);\n+  static void pd_iterate_all_mappings(MappingPrintClosure& closure);\n+public:\n+  static void mark_page_malloced(const void* p, MEMFLAGS f);\n+  static void print_all_mappings(outputStream* st, bool human_readable);\n+};\n+\n+#endif \/\/ SHARE_SERVICES_MEMMAPPRINTER_HPP\n","filename":"src\/hotspot\/share\/services\/memMapPrinter.hpp","additions":66,"deletions":0,"binary":false,"changes":66,"status":"added"},{"patch":"@@ -0,0 +1,66 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.annotations.Test;\n+import jdk.test.lib.dcmd.CommandExecutor;\n+import jdk.test.lib.dcmd.JMXExecutor;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+\/*\n+ * @test\n+ * @summary Test of diagnostic command System.map\n+ * @library \/test\/lib\n+ * @requires (os.family==\"linux\")\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.compiler\n+ *          java.management\n+ *          jdk.internal.jvmstat\/sun.jvmstat.monitor\n+ * @run testng SystemMapTest\n+ *\/\n+public class SystemMapTest {\n+    public void run(CommandExecutor executor) {\n+        OutputAnalyzer output = executor.execute(\"System.map\");\n+        output.reportDiagnosticSummary();\n+        \/\/ Only with NMT we get VM annotations\n+        boolean have_nmt = true;\n+        if (output.getOutput().contains(\"please enable Native Memory Tracking\")) {\n+            have_nmt = false;\n+        }\n+\n+        if (have_nmt) {\n+            String expectedMarkings[] = new String[] { \"STACK\", \"JAVAHEAP\", \"META\", \"CODE\", \"POLL\" };\n+            for (String s : expectedMarkings) {\n+                output.shouldMatch(\"0x[0-9a-fA-F]+ *- *0x[0-9a-fA-F]+ +\\\\d+.*\" + s + \".*\");\n+            }\n+        } else {\n+            output.shouldMatch(\"0x[0-9a-fA-F]+ *- *0x[0-9a-fA-F]+ +\\\\d+.*\");\n+        }\n+        output.shouldMatch(\"0x[0-9a-fA-F]+ *- *0x[0-9a-fA-F]+ +\\\\d+.*libjvm.so.*\");\n+        output.shouldMatch(\".*Total: \\\\d+ mappings with a total vsize of \\\\d+.*\");\n+    }\n+\n+    @Test\n+    public void jmx() {\n+        run(new JMXExecutor());\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/dcmd\/vm\/SystemMapTest.java","additions":66,"deletions":0,"binary":false,"changes":66,"status":"added"}]}