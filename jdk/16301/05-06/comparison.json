{"files":[{"patch":"@@ -79,10 +79,11 @@\n-  if (f != nullptr) {\n-    static constexpr size_t linesize = sizeof(ProcMapsInfo);\n-    char line[linesize];\n-    while(fgets(line, sizeof(line), f) == line) {\n-      line[sizeof(line) - 1] = '\\0';\n-      ProcMapsInfo info;\n-      if (info.scan_proc_maps_line(line)) {\n-        LinuxMappingPrintInformation mapinfo(info.from, info.to, &info);\n-        closure.do_it(&mapinfo);\n-      }\n+  if (f == nullptr) {\n+    return;\n+  }\n+  constexpr size_t linesize = sizeof(ProcMapsInfo);\n+  char line[linesize];\n+  while (fgets(line, sizeof(line), f) == line) {\n+    line[sizeof(line) - 1] = '\\0';\n+    ProcMapsInfo info;\n+    if (info.scan_proc_maps_line(line)) {\n+      LinuxMappingPrintInformation mapinfo(info.from, info.to, &info);\n+      closure.do_it(&mapinfo);\n@@ -90,1 +91,0 @@\n-    ::fclose(f);\n@@ -92,0 +92,1 @@\n+  ::fclose(f);\n","filename":"src\/hotspot\/os\/linux\/memMapPrinter_linux.cpp","additions":12,"deletions":11,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -968,0 +968,4 @@\n+char* os::realpath(const char* filename, char* outbuf, size_t outbuflen) {\n+  return os::Posix::realpath(filename, outbuf, outbuflen);\n+}\n+\n","filename":"src\/hotspot\/os\/posix\/os_posix.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -6138,0 +6138,18 @@\n+\n+char* os::realpath(const char* filename, char* outbuf, size_t outbuflen) {\n+  const DWORD fattr = GetFileAttributes(filename);\n+  if (fattr == 0xffffffff) {\n+    return nullptr;\n+  }\n+  const DWORD len = GetFullPathName(filename, outbuflen, outbuf, nullptr);\n+  if (len > 0) {\n+    if (len >= outbuflen) {\n+      errno = ENAMETOOLONG;\n+      return nullptr;\n+    }\n+    return outbuf;\n+  }\n+  return nullptr;\n+}\n+\n+\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -77,3 +77,1 @@\n-  const void* const min = MAX2(from1, from2);\n-  const void* const max = MIN2(to1, to2);\n-  return min < max;\n+  return MAX2(from1, from2) < MIN2(to1, to2);\n@@ -86,2 +84,3 @@\n-  \/\/ Unfortunately, we need to allocate manually, raw, since we must prevent\n-  \/\/ NMT deadlocks (ThreadCritical).\n+  \/\/ We keep ranges apart from flags since that prevents the padding a combined\n+  \/\/ structure would have, and it allows for faster iteration of ranges since more\n+  \/\/ of them fit into a cache line.\n@@ -109,0 +108,1 @@\n+      \/\/ Unfortunately, we need to allocate manually, raw, since we must prevent NMT deadlocks (ThreadCritical).\n@@ -278,1 +278,1 @@\n-    st->print_cr(\"Note: NMT is disabled, will not annotate mappings.\");\n+    st->print_cr(\" (NMT is disabled, will not annotate mappings).\");\n","filename":"src\/hotspot\/share\/nmt\/memMapPrinter.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -976,0 +976,6 @@\n+  \/\/ Resolve a file name specifying an existing file to its absolute path.\n+  \/\/ On success it fills the absolute path into outbuf and returns outbuf.\n+  \/\/ If outbuf is too small, it leaves outbuf unchanged, sets errno to ENAMETOOLONG, and returns nullptr.\n+  \/\/ On error it leaves outbuf unchanged and returns nullptr.\n+  static char* realpath(const char* filename, char* outbuf, size_t outbuflen);\n+\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -139,0 +139,1 @@\n+  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<SystemDumpMapDCmd>(full_export, true,false));\n@@ -1160,0 +1161,10 @@\n+  _human_readable(\"-H\", \"Human readable format\", \"BOOLEAN\", false, \"false\") {\n+  _dcmdparser.add_dcmd_option(&_human_readable);\n+}\n+\n+void SystemMapDCmd::execute(DCmdSource source, TRAPS) {\n+  MemMapPrinter::print_all_mappings(output(), _human_readable.value());\n+}\n+\n+SystemDumpMapDCmd::SystemDumpMapDCmd(outputStream* output, bool heap) :\n+    DCmdWithParser(output, heap),\n@@ -1166,1 +1177,1 @@\n-void SystemMapDCmd::execute(DCmdSource source, TRAPS) {\n+void SystemDumpMapDCmd::execute(DCmdSource source, TRAPS) {\n@@ -1173,1 +1184,1 @@\n-      output()->print_cr(\"Note: NMT is disabled. Memory map will be printed without VM annotations.\");\n+      output()->print_cr(\"(NMT is disabled, will not annotate mappings).\");\n@@ -1176,0 +1187,4 @@\n+    \/\/ For the readers convenience, resolve path name.\n+    char tmp[PATH_MAX];\n+    const char* absname = os::realpath(name, tmp, sizeof(tmp));\n+    name = absname != nullptr ? absname : name;\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.cpp","additions":17,"deletions":2,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -983,1 +983,0 @@\n-  DCmdArgument<char*> _filename;\n@@ -985,1 +984,1 @@\n-  static int num_arguments() { return 2; }\n+  static int num_arguments() { return 1; }\n@@ -987,2 +986,9 @@\n-  static const char* name() {\n-    return \"System.map\";\n+  static const char* name() { return \"System.map\"; }\n+  static const char* description() {\n+    return \"Prints an annotated process memory map of the VM process.\";\n+  }\n+  static const char* impact() { return \"Low\"; }\n+  static const JavaPermission permission() {\n+    JavaPermission p = {\"java.lang.management.ManagementPermission\",\n+                        \"control\", nullptr};\n+    return p;\n@@ -990,0 +996,10 @@\n+  virtual void execute(DCmdSource source, TRAPS);\n+};\n+\n+class SystemDumpMapDCmd : public DCmdWithParser {\n+  DCmdArgument<bool> _human_readable;\n+  DCmdArgument<char*> _filename;\n+public:\n+  static int num_arguments() { return 2; }\n+  SystemDumpMapDCmd(outputStream* output, bool heap);\n+  static const char* name() { return \"System.dump_map\"; }\n@@ -993,3 +1009,1 @@\n-  static const char* impact() {\n-    return \"Low\";\n-  }\n+  static const char* impact() { return \"Low\"; }\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.hpp","additions":21,"deletions":7,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -0,0 +1,98 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, Red Hat, Inc. and\/or its affiliates.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.annotations.Test;\n+import jdk.test.lib.dcmd.CommandExecutor;\n+import jdk.test.lib.dcmd.JMXExecutor;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+import java.io.*;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.regex.Pattern;\n+\n+\/*\n+ * @test\n+ * @summary Test of diagnostic command System.map\n+ * @library \/test\/lib\n+ * @requires (os.family==\"linux\")\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.compiler\n+ *          java.management\n+ *          jdk.internal.jvmstat\/sun.jvmstat.monitor\n+ * @run testng SystemDumpMapTest\n+ *\/\n+public class SystemDumpMapTest {\n+    public void run(CommandExecutor executor) {\n+        OutputAnalyzer output = executor.execute(\"System.dump_map\");\n+        output.reportDiagnosticSummary();\n+\n+        String filename = output.firstMatch(\"Memory map dumped to \\\"(\\\\S*vm_memory_map_\\\\d+\\\\.txt)\\\".*\", 1);\n+        if (filename == null) {\n+            throw new RuntimeException(\"Did not find dump file in output.\\n\");\n+        }\n+\n+        try (BufferedReader reader = new BufferedReader(new FileReader(filename))) {\n+            boolean NMTOff = output.contains(\"NMT is disabled\");\n+            String regexBase = \".*0x\\\\p{XDigit}+ - 0x\\\\p{XDigit}+ +\\\\d+\";\n+            HashSet<Pattern> patterns = new HashSet<>();\n+            patterns.add(Pattern.compile(regexBase + \".*jvm.*\"));\n+            if (!NMTOff) { \/\/ expect VM annotations if NMT is on\n+                patterns.add(Pattern.compile(regexBase + \".*JAVAHEAP.*\"));\n+                patterns.add(Pattern.compile(regexBase + \".*META.*\"));\n+                patterns.add(Pattern.compile(regexBase + \".*CODE.*\"));\n+                patterns.add(Pattern.compile(regexBase + \".*STACK.*main.*\"));\n+            }\n+            do {\n+                String line = reader.readLine();\n+                if (line != null) {\n+                    for (Pattern pat : patterns) {\n+                        if (pat.matcher(line).matches()) {\n+                            patterns.remove(pat);\n+                            break;\n+                        }\n+                    }\n+                } else {\n+                    break;\n+                }\n+            } while (patterns.size() > 0);\n+\n+            if (patterns.size() > 0) {\n+                System.out.println(\"Missing patterns in dump:\");\n+                for (Pattern pat : patterns) {\n+                    System.out.println(pat);\n+                }\n+                throw new RuntimeException(\"Missing patterns\");\n+            }\n+\n+        } catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    @Test\n+    public void jmx() {\n+        run(new JMXExecutor());\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/dcmd\/vm\/SystemDumpMapTest.java","additions":98,"deletions":0,"binary":false,"changes":98,"status":"added"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2023, Red Hat, Inc. and\/or its affiliates.\n@@ -33,0 +34,1 @@\n+import java.util.HashSet;\n@@ -50,10 +52,9 @@\n-        String filename = output.firstMatch(\"Memory map dumped to \\\"(\\\\S*vm_memory_map_\\\\d+\\\\.txt)\\\".*\", 1);\n-        if (filename == null) {\n-            throw new RuntimeException(\"Did not find dump file in output.\\n\");\n-        }\n-        File f = new File(filename);\n-        if (!f.exists()) {\n-            throw new RuntimeException(\"dump file not found.\");\n-        }\n-        if (f.length() == 0) {\n-            throw new RuntimeException(\"dump file 0.\");\n+        boolean NMTOff = output.contains(\"NMT is disabled\");\n+\n+        String regexBase = \".*0x\\\\p{XDigit}+ - 0x\\\\p{XDigit}+ +\\\\d+\";\n+        output.shouldMatch(regexBase + \".*jvm.*\");\n+        if (!NMTOff) { \/\/ expect VM annotations if NMT is on\n+            output.shouldMatch(regexBase + \".*JAVAHEAP.*\");\n+            output.shouldMatch(regexBase + \".*META.*\");\n+            output.shouldMatch(regexBase + \".*CODE.*\");\n+            output.shouldMatch(regexBase + \".*STACK.*main.*\");\n","filename":"test\/hotspot\/jtreg\/serviceability\/dcmd\/vm\/SystemMapTest.java","additions":11,"deletions":10,"binary":false,"changes":21,"status":"modified"}]}