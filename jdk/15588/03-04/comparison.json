{"files":[{"patch":"@@ -30,0 +30,2 @@\n+import java.util.AbstractList;\n+import java.util.ArrayList;\n@@ -41,0 +43,1 @@\n+import jdk.vm.ci.meta.PrimitiveConstant;\n@@ -529,0 +532,31 @@\n+    static class CachedBSMArgs extends AbstractList<JavaConstant> {\n+        private final JavaConstant[] cache;\n+        private final HotSpotConstantPool cp;\n+        private final int bssIndex;\n+\n+        CachedBSMArgs(HotSpotConstantPool cp, int bssIndex, int size) {\n+            this.cp = cp;\n+            this.bssIndex = bssIndex;\n+            this.cache = new JavaConstant[size];\n+        }\n+\n+        @Override\n+        public JavaConstant get(int index) {\n+            JavaConstant res = cache[index];\n+            if (res == null) {\n+                int argCpi = compilerToVM().bootstrapArgumentIndexAt(cp, bssIndex, index);\n+                res = compilerToVM().lookupConstantInPool(cp, argCpi, false);\n+                if (res == null) {\n+                    res = JavaConstant.forInt(argCpi);\n+                }\n+                cache[index] = res;\n+            }\n+            return res;\n+        }\n+\n+        @Override\n+        public int size() {\n+            return cache.length;\n+        }\n+    }\n+\n@@ -586,5 +620,0 @@\n-    @Override\n-    public int bootstrapArgumentIndexAt(int cpi, int index) {\n-        return compilerToVM().bootstrapArgumentIndexAt(this, cpi, index);\n-    }\n-\n@@ -612,1 +641,3 @@\n-                    staticArgumentsList = List.of(Arrays.stream(bsciArgs).mapToObj(i -> JavaConstant.forInt(i)).toArray(JavaConstant[]::new));\n+                    int argCount = bsciArgs[0];\n+                    int bss_index = bsciArgs[1];\n+                    staticArgumentsList = new CachedBSMArgs(this, bss_index, argCount);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotConstantPool.java","additions":37,"deletions":6,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -136,18 +136,0 @@\n-     * The procedure to obtain and use a {@link BootstrapMethodInvocation} is the following:\n-     *\n-     * <pre>\n-     * bsmInvocation = constantpool.lookupBootstrapMethodInvocation(index, opcode);\n-     * staticArguments = bsmInvocation.getStaticArguments();\n-     * if staticArguments are PrimitiveConstant {\n-     *     argCount = staticArguments.get(0).asInt();\n-     *     cpi = staticArguments.get(1).asInt();\n-     *     for (int i = 0; i < argCount; ++i) {\n-     *         argCpi = constantpool.bootstrapArgumentIndexAt(cpi, i);\n-     *         arguments[i] = constantpool.lookupConstant(argCpi, resolve);\n-     *     }\n-     *     call bootstrap method with newly resolved arguments\n-     * } else {\n-     *     call bootstrap method with provided arguments\n-     * }\n-     * <\/pre>\n-     *\n@@ -186,0 +168,17 @@\n+         * An argument of type {@link PrimitiveConstant} represents a {@code CONSTANT_Dynamic_info}\n+         * entry. To resolve this entry, the corresponding bootstrap method has to be called first:\n+         *\n+         * <pre>\n+         * resolveIndyOrCondy(int index, int opcode) {\n+         *     bsmInvocation = cp.lookupBootstrapMethodInvocation(index, opcode);\n+         *     staticArguments = bsmInvocation.getStaticArguments();\n+         *     for each argument in staticArguments {\n+         *         if argument is PrimitiveArgument {\n+         *             \/\/ argument is a condy, so opcode becomes -1\n+         *             resolveIndyOrCondy(argument.asInt(), -1);\n+         *         }\n+         *     }\n+         *     call original boostrap method with resolved arguments\n+         * }\n+         * <\/pre>\n+         *\n@@ -191,16 +190,0 @@\n-    \/**\n-     * Gets the constant pool index of a static argument of a {@code CONSTANT_Dynamic_info} or\n-     * @{code CONSTANT_InvokeDynamic_info} entry. Used when the list of static arguments in the\n-     * {@link BootstrapMethodInvocation} is a {@code List<PrimitiveConstant>} of the form\n-     * {{@code arg_count}, {@code pool_index}}, meaning the arguments are not already resolved and that\n-     * the JDK has to lookup the arguments when they are needed. The {@code cpi} corresponds to\n-     * {@code pool_index} and the {@code index} has to be smaller than {@code arg_count}.\n-     *\n-     * @param cpi the index of a {@code CONSTANT_Dynamic_info} or @{code CONSTANT_InvokeDynamic_info} entry\n-     * @param index the index of the static argument in the list of static arguments\n-     * @return the constant pool index associated with the static argument\n-     *\/\n-    default int bootstrapArgumentIndexAt(int cpi, int index) {\n-        throw new UnsupportedOperationException();\n-    }\n-\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/meta\/ConstantPool.java","additions":17,"deletions":34,"binary":false,"changes":51,"status":"modified"}]}