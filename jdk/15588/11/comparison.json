{"files":[{"patch":"@@ -773,3 +773,5 @@\n-  for (int i = 0; i < cp->resolved_indy_entries_length(); i++) {\n-    if (cp->resolved_indy_entry_at(i)->constant_pool_index() == index) {\n-      indy_index = i;\n+  if (is_indy) {\n+    for (int i = 0; i < cp->resolved_indy_entries_length(); i++) {\n+      if (cp->resolved_indy_entry_at(i)->constant_pool_index() == index) {\n+        indy_index = i;\n+      }\n@@ -841,0 +843,5 @@\n+C2V_VMENTRY_0(jint, bootstrapArgumentIndexAt, (JNIEnv* env, jobject, ARGUMENT_PAIR(cp), jint cpi, jint index))\n+  constantPoolHandle cp(THREAD, UNPACK_PAIR(ConstantPool, cp));\n+  return cp->bootstrap_argument_index_at(cpi, index);\n+C2V_END\n+\n@@ -3137,0 +3144,1 @@\n+  {CC \"bootstrapArgumentIndexAt\",                     CC \"(\" HS_CONSTANT_POOL2 \"II)I\",                                                      FN_PTR(bootstrapArgumentIndexAt)},\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":11,"deletions":3,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -479,0 +479,22 @@\n+    \/**\n+     * Gets the constant pool index of a static argument of a {@code CONSTANT_Dynamic_info} or\n+     * @{code CONSTANT_InvokeDynamic_info} entry. Used when the list of static arguments in the\n+     * {@link BootstrapMethodInvocation} is a {@code List<PrimitiveConstant>} of the form\n+     * {{@code arg_count}, {@code pool_index}}, meaning the arguments are not already resolved and that\n+     * the JDK has to lookup the arguments when they are needed. The {@code cpi} corresponds to\n+     * {@code pool_index} and the {@code index} has to be smaller than {@code arg_count}.\n+     *\n+     * The behavior of this method is undefined if {@code cpi} does not denote an entry representing\n+     * a {@code CONSTANT_Dynamic_info} or a @{code CONSTANT_InvokeDynamic_info}, or if the index\n+     * is out of bounds.\n+     *\n+     * @param cpi the index of a {@code CONSTANT_Dynamic_info} or @{code CONSTANT_InvokeDynamic_info} entry\n+     * @param index the index of the static argument in the list of static arguments\n+     * @return the constant pool index associated with the static argument\n+     *\/\n+    int bootstrapArgumentIndexAt(HotSpotConstantPool constantPool, int cpi, int index) {\n+        return bootstrapArgumentIndexAt(constantPool, constantPool.getConstantPoolPointer(), cpi, index);\n+    }\n+\n+    private native int bootstrapArgumentIndexAt(HotSpotConstantPool constantPool, long constantPoolPointer, int cpi, int index);\n+\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/CompilerToVM.java","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -30,0 +30,2 @@\n+import java.util.AbstractList;\n+import java.util.ArrayList;\n@@ -41,0 +43,1 @@\n+import jdk.vm.ci.meta.PrimitiveConstant;\n@@ -529,0 +532,54 @@\n+    \/**\n+     * Represents a list of static arguments from a {@link BootstrapMethodInvocation} of the form\n+     * {{@code arg_count}, {@code pool_index}}, meaning the arguments are not already resolved\n+     * and that the JDK has to lookup the arguments when they are needed. The {@code bssIndex}\n+     * corresponds to {@code pool_index} and the {@code size} corresponds to {@code arg_count}.\n+     *\/\n+    static class CachedBSMArgs extends AbstractList<JavaConstant> {\n+        private final JavaConstant[] cache;\n+        private final HotSpotConstantPool cp;\n+        private final int bssIndex;\n+\n+        CachedBSMArgs(HotSpotConstantPool cp, int bssIndex, int size) {\n+            this.cp = cp;\n+            this.bssIndex = bssIndex;\n+            this.cache = new JavaConstant[size];\n+        }\n+\n+        \/**\n+         * Lazily resolves and caches the argument at the given index and returns it. The method\n+         * {@link CompilerToVM#bootstrapArgumentIndexAt} is used to obtain the constant pool\n+         * index of the entry and the method {@link ConstantPool#lookupConstant} is used to\n+         * resolve it. If the resolution failed, the index is returned as a\n+         * {@link PrimitiveConstant}.\n+         *\n+         * @param index index of the element to return\n+         * @return A {@link JavaConstant} corresponding to the static argument requested. A return\n+         * value of type {@link PrimitiveConstant} represents an unresolved constant pool entry\n+         *\/\n+        @Override\n+        public JavaConstant get(int index) {\n+            JavaConstant res = cache[index];\n+            if (res == null) {\n+                int argCpi = compilerToVM().bootstrapArgumentIndexAt(cp, bssIndex, index);\n+                Object object = cp.lookupConstant(argCpi, false);\n+                if (object instanceof PrimitiveConstant primitiveConstant) {\n+                    res = runtime().getReflection().boxPrimitive(primitiveConstant);\n+                } else if (object instanceof JavaConstant javaConstant) {\n+                    res = javaConstant;\n+                } else if (object instanceof JavaType type) {\n+                    res = runtime().getReflection().forObject(type);\n+                } else {\n+                    res = JavaConstant.forInt(argCpi);\n+                }\n+                cache[index] = res;\n+            }\n+            return res;\n+        }\n+\n+        @Override\n+        public int size() {\n+            return cache.length;\n+        }\n+    }\n+\n@@ -607,2 +664,3 @@\n-                    String message = String.format(\"Resolving bootstrap static arguments for %s using BootstrapCallInfo %s not supported\", method.format(\"%H.%n(%p)\"), Arrays.toString(bsciArgs));\n-                    throw new IllegalArgumentException(message);\n+                    int argCount = bsciArgs[0];\n+                    int bss_index = bsciArgs[1];\n+                    staticArgumentsList = new CachedBSMArgs(this, bss_index, argCount);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotConstantPool.java","additions":60,"deletions":2,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -134,1 +134,1 @@\n-     * or {@code CONSTANT_InvokeDynamic_info} pool entry .\n+     * or {@code CONSTANT_InvokeDynamic_info} pool entry.\n@@ -168,0 +168,23 @@\n+         * The {@linkplain JavaConstant#getJavaKind kind} of each argument will be\n+         * {@link JavaKind#Object} or {@link JavaKind#Int}. The latter represents an\n+         * unresolved {@code CONSTANT_Dynamic_info} entry. To resolve this entry, the\n+         * corresponding bootstrap method has to be called first:\n+         *\n+         * <pre>\n+         * List<JavaConstant> args = bmi.getStaticArguments();\n+         * List<JavaConstant> resolvedArgs = new ArrayList<>(args.size());\n+         * for (JavaConstant c : args) {\n+         *     JavaConstant r = c;\n+         *     if (c.getJavaKind() == JavaKind.Int) {\n+         *         \/\/ If needed, access corresponding BootstrapMethodInvocation using\n+         *         \/\/ cp.lookupBootstrapMethodInvocation(pc.asInt(), -1)\n+         *         r = cp.lookupConstant(c.asInt(), true);\n+         *     } else {\n+         *         assert c.getJavaKind() == JavaKind.Object;\n+         *     }\n+         *     resolvedArgs.append(r);\n+         * }\n+         * <\/pre>\n+         *\n+         * The other types of entries are already resolved an can be used directly.\n+         *\n@@ -185,2 +208,0 @@\n-     * @throws IllegalArgumentException if the bootstrap method invocation makes use of\n-     *             {@code java.lang.invoke.BootstrapCallInfo}\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/meta\/ConstantPool.java","additions":24,"deletions":3,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -35,0 +35,3 @@\n+ * @run testng\/othervm\n+ *      -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI -XX:-UseJVMCICompiler -XX:UseBootstrapCallInfo=3\n+ *      jdk.vm.ci.hotspot.test.TestDynamicConstant\n@@ -64,0 +67,1 @@\n+import jdk.vm.ci.meta.JavaConstant;\n@@ -89,0 +93,6 @@\n+        \/**\n+         * Condy whose bootstrap method is one of the {@code TestDynamicConstant.get<type>BSM(<type> constant, int i)}\n+         * methods with one condy arg and one int arg.\n+         *\/\n+        CALL_DIRECT_WITH_ARGS_BSM,\n+\n@@ -167,0 +177,18 @@\n+             } else if (condyType == CondyType.CALL_DIRECT_WITH_ARGS_BSM) {\n+                \/\/ Example: int TestDynamicConstant.getIntBSM(MethodHandles.Lookup l, String name,\n+                \/\/ Class<?> type, int constant, int i)\n+                String sig1 = \"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/Class;)\" + desc;\n+                String sig2 = \"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/Class;\" + desc + \"I)\" + desc;\n+\n+                Handle handle1 = new Handle(H_INVOKESTATIC, testClassInternalName, getter + \"BSM\", sig1, false);\n+                Handle handle2 = new Handle(H_INVOKESTATIC, testClassInternalName, getter + \"BSM\", sig2, false);\n+\n+                ConstantDynamic condy1 = new ConstantDynamic(\"const1\", desc, handle1);\n+                ConstantDynamic condy2 = new ConstantDynamic(\"const2\", desc, handle2, condy1, Integer.MAX_VALUE);\n+\n+                condy = condy2;\n+                MethodVisitor run = cw.visitMethod(PUBLIC_STATIC, \"run\", \"()\" + desc, null, null);\n+                run.visitLdcInsn(condy);\n+                run.visitInsn(type.getOpcode(IRETURN));\n+                run.visitMaxs(0, 0);\n+                run.visitEnd();\n@@ -312,0 +340,6 @@\n+                if (type != Object.class) {\n+                    testLookupBootstrapMethodInvocation(condyType, metaAccess, testClass, getTagAt);\n+                } else {\n+                    \/\/ StringConcatFactoryStringConcatFactory cannot accept null constants\n+                }\n+\n@@ -333,6 +367,0 @@\n-\n-                if (type != Object.class) {\n-                    testLookupBootstrapMethodInvocation(condyType, metaAccess, testClass, getTagAt);\n-                } else {\n-                    \/\/ StringConcatFactoryStringConcatFactory cannot accept null constants\n-                }\n@@ -367,1 +395,1 @@\n-                    if (condyType == CondyType.CALL_DIRECT_BSM) {\n+                    if (condyType == CondyType.CALL_DIRECT_BSM || condyType == CondyType.CALL_DIRECT_WITH_ARGS_BSM) {\n@@ -369,0 +397,11 @@\n+                        if (condyType == CondyType.CALL_DIRECT_WITH_ARGS_BSM) {\n+                            List<JavaConstant> staticArguments = bsmi.getStaticArguments();\n+                            if (staticArguments.size() > 0) {\n+                                JavaConstant primitiveConstant = staticArguments.get(0);\n+                                Assert.assertTrue(primitiveConstant instanceof PrimitiveConstant);\n+                                BootstrapMethodInvocation innerBsmi = cp.lookupBootstrapMethodInvocation(primitiveConstant.asInt(), -1);\n+                                String innerBsm = innerBsmi.getMethod().format(\"%H.%n\");\n+                                Assert.assertTrue(innerBsm.startsWith(\"jdk.vm.ci.hotspot.test.TestDynamicConstant.get\") && bsm.endsWith(\"BSM\"), bsm);\n+                                Assert.assertTrue(staticArguments.get(1) instanceof HotSpotObjectConstant);\n+                            }\n+                        }\n@@ -428,0 +467,12 @@\n+    @SuppressWarnings(\"unused\") public static boolean getBooleanBSM(MethodHandles.Lookup l, String name, Class<?> type, boolean constant, int i) { return true; }\n+    @SuppressWarnings(\"unused\") public static char    getCharBSM   (MethodHandles.Lookup l, String name, Class<?> type, char constant, int i) { return '*'; }\n+    @SuppressWarnings(\"unused\") public static short   getShortBSM  (MethodHandles.Lookup l, String name, Class<?> type, short constant, int i) { return Short.MAX_VALUE; }\n+    @SuppressWarnings(\"unused\") public static byte    getByteBSM   (MethodHandles.Lookup l, String name, Class<?> type, byte constant, int i) { return Byte.MAX_VALUE; }\n+    @SuppressWarnings(\"unused\") public static int     getIntBSM    (MethodHandles.Lookup l, String name, Class<?> type, int constant, int i) { return Integer.MAX_VALUE; }\n+    @SuppressWarnings(\"unused\") public static float   getFloatBSM  (MethodHandles.Lookup l, String name, Class<?> type, float constant, int i) { return Float.MAX_VALUE; }\n+    @SuppressWarnings(\"unused\") public static long    getLongBSM   (MethodHandles.Lookup l, String name, Class<?> type, long constant, int i) { return Long.MAX_VALUE; }\n+    @SuppressWarnings(\"unused\") public static double  getDoubleBSM (MethodHandles.Lookup l, String name, Class<?> type, double constant, int i) { return Double.MAX_VALUE; }\n+    @SuppressWarnings(\"unused\") public static String  getStringBSM (MethodHandles.Lookup l, String name, Class<?> type, String constant, int i) { return \"a string\"; }\n+    @SuppressWarnings(\"unused\") public static Object  getObjectBSM (MethodHandles.Lookup l, String name, Class<?> type, Object constant, int i) { return null; }\n+    @SuppressWarnings(\"unused\") public static List<?> getListBSM   (MethodHandles.Lookup l, String name, Class<?> type, List<?> constant, int i) { return List.of(\"element\"); }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.hotspot.test\/src\/jdk\/vm\/ci\/hotspot\/test\/TestDynamicConstant.java","additions":58,"deletions":7,"binary":false,"changes":65,"status":"modified"}]}