{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @library \/test\/lib\n@@ -34,0 +35,3 @@\n+import jdk.test.lib.format.Format;\n+import jdk.test.lib.format.ArrayCodec;\n+\n@@ -80,1 +84,0 @@\n-                Operation op = m.getAnnotation(Test.class).op();\n@@ -82,0 +85,1 @@\n+                Operation op = antn.op();\n@@ -124,4 +128,4 @@\n-                invokeAndCheck(m, (incL == 0), latin1.getBytes(\"ISO-8859-1\"), latin1Copy.getBytes(\"ISO-8859-1\"));\n-                invokeAndCheck(m, true, new byte[] {1, 2, 3}, new byte[] {1, 2, 3});\n-                invokeAndCheck(m, true, new byte[] {1}, new byte[] {1});\n-                invokeAndCheck(m, true, new byte[] {}, new byte[] {});\n+                invokeAndCompareArrays(m, (incL == 0), latin1.getBytes(\"ISO-8859-1\"), latin1Copy.getBytes(\"ISO-8859-1\"));\n+                invokeAndCompareArrays(m, true, new byte[] {1, 2, 3}, new byte[] {1, 2, 3});\n+                invokeAndCompareArrays(m, true, new byte[] {1}, new byte[] {1});\n+                invokeAndCompareArrays(m, true, new byte[] {}, new byte[] {});\n@@ -130,1 +134,1 @@\n-                invokeAndCheck(m, (incU == 0), utf16.toCharArray(), arrU);\n+                invokeAndCompareArrays(m, (incU == 0), utf16.toCharArray(), arrU);\n@@ -243,0 +247,23 @@\n+    \/**\n+     * Invokes method 'm' by passing arguments the two 'args' (which are supposed to be arrays)\n+     * checks if the returned value. In case of error and arrays being not equal, prints their difference.\n+     *\/\n+    private void invokeAndCompareArrays(Method m, boolean expectedResult, Object arg0, Object arg1) throws Exception {\n+        boolean result = (Boolean)m.invoke(null, arg0, arg1);\n+        if (expectedResult == result)\n+            return;\n+\n+        String cause = String.format(\"Result: (%b) of '%s' is not equal to expected (%b)\",\n+                        result, m.getName(), expectedResult);\n+\n+        if (expectedResult == true) {\n+            System.err.println(cause);\n+            System.err.println(Format.arrayDiff(arg0, arg1));\n+        } else {\n+            System.err.println(cause);\n+            System.err.printf(\"First array argument: %n    %s%n\", ArrayCodec.format(arg0));\n+        }\n+\n+        throw new RuntimeException(cause);\n+    }\n+\n@@ -248,7 +275,15 @@\n-        Object result = m.invoke(null, args);\n-        if (!result.equals(expectedResult)) {\n-\/\/            System.out.println(\"Expected:\");\n-\/\/            System.out.println(expectedResult);\n-\/\/            System.out.println(\"Returned:\");\n-\/\/            System.out.println(result);\n-            throw new RuntimeException(\"Result of '\" + m.getName() + \"' not equal to expected value.\");\n+        Object actualResult = m.invoke(null, args);\n+        if (!actualResult.equals(expectedResult)) {\n+            var nl = System.lineSeparator();\n+            StringBuilder msgBuilder = new StringBuilder();\n+            msgBuilder.append(\"Actual result of '\" + m.getName() + \"' is not equal to expected value.\" + nl);\n+            msgBuilder.append(\"Expected: \" + Format.asLiteral(expectedResult) + nl);\n+            msgBuilder.append(\"Actual: \" + Format.asLiteral(actualResult));\n+\n+            for (int i = 0; i < args.length; i++) {\n+                msgBuilder.append(nl + \"    Arg\" + i + \": \" + Format.asLiteral(args[i]));\n+            }\n+\n+            final String message = msgBuilder.toString();\n+            System.err.println(message);\n+            throw new RuntimeException(message);\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/string\/TestStringIntrinsics.java","additions":49,"deletions":14,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -0,0 +1,296 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.test.lib.format;\n+\n+import org.testng.annotations.Test;\n+\n+import static org.testng.Assert.assertTrue;\n+import static org.testng.Assert.assertFalse;\n+import static org.testng.Assert.assertEquals;\n+\n+\/*\n+ * @test\n+ * @summary Check ArrayDiff formatting\n+ * @library \/test\/lib\n+ * @run testng jdk.test.lib.format.ArrayDiffTest\n+ *\/\n+public class ArrayDiffTest {\n+\n+    @Test\n+    public void testEqualArrays() {\n+        char[] first = new char[]  {'a', 'b', 'c', 'd', 'e', 'f', 'g'};\n+        char[] second = new char[] {'a', 'b', 'c', 'd', 'e', 'f', 'g'};\n+\n+        assertTrue(ArrayDiff.of(first, second).areEqual());\n+    }\n+\n+    @Test\n+    public void testOutputFitsWidth() {\n+        byte[] first = new byte[]  {7, 8, 9, 10,  11, 12, 13};\n+        byte[] second = new byte[] {7, 8, 9, 10, 125, 12, 13};\n+\n+        ArrayDiff diff = ArrayDiff.of(first, second);\n+        String expected = String.format(\n+                \"Arrays differ starting from [index: 4]:%n\" +\n+                \"[7, 8, 9, 10,  11, 12, 13]%n\" +\n+                \"[7, 8, 9, 10, 125, 12, 13]%n\" +\n+                \"             ^^^^\");\n+\n+        assertFalse(diff.areEqual());\n+        assertEquals(diff.format(), expected);\n+    }\n+\n+    @Test\n+    public void testIntegers() {\n+        int[] first = new int[]  {7, 8, 10, 11, 12};\n+        int[] second = new int[] {7, 8, 9, 10, 11, 12, 13};\n+\n+        ArrayDiff diff = ArrayDiff.of(first, second);\n+        String expected = String.format(\n+                \"Arrays differ starting from [index: 2]:%n\" +\n+                \"[7, 8, 10, 11, 12]%n\" +\n+                \"[7, 8,  9, 10, 11, 12, 13]%n\" +\n+                \"      ^^^\");\n+\n+        assertFalse(diff.areEqual());\n+        assertEquals(diff.format(), expected);\n+    }\n+\n+    @Test\n+    public void testLongs() {\n+        long[] first = new long[]  {1, 2, 3, 4};\n+        long[] second = new long[] {1, 2, 3, 10};\n+\n+        ArrayDiff diff = ArrayDiff.of(first, second);\n+        String expected = String.format(\n+                \"Arrays differ starting from [index: 3]:%n\" +\n+                \"[1, 2, 3,  4]%n\" +\n+                \"[1, 2, 3, 10]%n\" +\n+                \"         ^^^\");\n+\n+        assertFalse(diff.areEqual());\n+        assertEquals(diff.format(), expected);\n+    }\n+\n+    @Test\n+    public void testFirstElementIsWrong() {\n+        byte[] first = new byte[]  {122};\n+        byte[] second = new byte[] {7, 8, 9, 10, 125, 12, 13};\n+\n+        ArrayDiff diff = ArrayDiff.of(first, second);\n+        String expected = String.format(\n+                \"Arrays differ starting from [index: 0]:%n\" +\n+                \"[122]%n\" +\n+                \"[  7, 8, 9, 10, 125, 12, 13]%n\" +\n+                \" ^^^\");\n+\n+        assertFalse(diff.areEqual());\n+        assertEquals(diff.format(), expected);\n+    }\n+\n+    @Test\n+    public void testOneElementIsEmpty() {\n+        byte[] first = new byte[]  {7, 8, 9, 10, 125, 12, 13};\n+        byte[] second = new byte[] {};\n+\n+        ArrayDiff diff = ArrayDiff.of(first, second);\n+        String expected = String.format(\n+                \"Arrays differ starting from [index: 0]:%n\" +\n+                \"[7, 8, 9, 10, 125, 12, 13]%n\" +\n+                \"[]%n\" +\n+                \" ^\");\n+\n+        assertFalse(diff.areEqual());\n+        assertEquals(diff.format(), expected);\n+    }\n+\n+    @Test\n+    public void testOutputDoesntFitWidth() {\n+        char[] first = new char[]  {'1', '2', '3', '4', '5', '6', '7'};\n+        char[] second = new char[] {'1', 'F', '3', '4', '5', '6', '7'};\n+\n+        ArrayDiff diff = ArrayDiff.of(first, second, 20, Integer.MAX_VALUE);\n+        String expected = String.format(\n+                \"Arrays differ starting from [index: 1]:%n\" +\n+                \"[1, 2, 3, 4, 5, ...%n\" +\n+                \"[1, F, 3, 4, 5, ...%n\" +\n+                \"   ^^\");\n+\n+        assertFalse(diff.areEqual());\n+        assertEquals(diff.format(), expected);\n+    }\n+\n+    @Test\n+    public void testVariableElementWidthOutputDoesntFitWidth() {\n+        byte[] first = new byte[]  {1,   2, 3, 4, 5, 6, 7};\n+        byte[] second = new byte[] {1, 112, 3, 4, 5, 6, 7};\n+\n+        ArrayDiff diff = ArrayDiff.of(first, second, 20, Integer.MAX_VALUE);\n+        String expected = String.format(\n+                \"Arrays differ starting from [index: 1]:%n\" +\n+                \"[1,   2, 3, 4, 5, ...%n\" +\n+                \"[1, 112, 3, 4, 5, ...%n\" +\n+                \"   ^^^^\");\n+\n+        assertFalse(diff.areEqual());\n+        assertEquals(diff.format(), expected);\n+    }\n+\n+    @Test\n+    public void testContextBefore() {\n+        char[] first = new char[]  {'1', '2', '3', '4', '5', '6', '7'};\n+        char[] second = new char[] {'1', '2', '3', '4', 'F', '6', '7'};\n+\n+        ArrayDiff diff = ArrayDiff.of(first, second, 20, 2);\n+        String expected = String.format(\n+                \"Arrays differ starting from [index: 4]:%n\" +\n+                \"... 3, 4, 5, 6, 7]%n\" +\n+                \"... 3, 4, F, 6, 7]%n\" +\n+                \"         ^^\");\n+\n+        assertFalse(diff.areEqual());\n+        assertEquals(diff.format(), expected);\n+    }\n+\n+    @Test\n+    public void testBoundedBytesWithDifferentWidth() {\n+        byte[] first = new byte[]  {0, 1, 2, 3, 125, 5, 6, 7};\n+        byte[] second = new byte[] {0, 1, 2, 3,   4, 5, 6, 7};\n+\n+        ArrayDiff diff = ArrayDiff.of(first, second, 24, 2);\n+        String expected = String.format(\n+                \"Arrays differ starting from [index: 4]:%n\" +\n+                \"... 2, 3, 125, 5, 6, 7]%n\" +\n+                \"... 2, 3,   4, 5, 6, 7]%n\" +\n+                \"         ^^^^\");\n+\n+        assertFalse(diff.areEqual());\n+        assertEquals(diff.format(), expected);\n+    }\n+\n+    @Test\n+    public void testBoundedFirstElementIsWrong() {\n+        byte[] first = new byte[] {101, 102, 103, 104, 105, 110};\n+        byte[] second = new byte[] {2};\n+\n+        ArrayDiff diff = ArrayDiff.of(first, second, 25, 2);\n+        String expected = String.format(\n+                \"Arrays differ starting from [index: 0]:%n\" +\n+                \"[101, 102, 103, 104, ...%n\" +\n+                \"[  2]%n\" +\n+                \" ^^^\");\n+\n+        assertFalse(diff.areEqual());\n+        assertEquals(diff.format(), expected);\n+    }\n+\n+    @Test\n+    public void testBoundedOneArchiveIsEmpty() {\n+        char[] first = new char[] {'a', 'b', 'c', 'd', 'e'};\n+        char[] second = new char[] {};\n+\n+        ArrayDiff diff = ArrayDiff.of(first, second, 10, 2);\n+        String expected = String.format(\n+                \"Arrays differ starting from [index: 0]:%n\" +\n+                \"[a, b, ...%n\" +\n+                \"[]%n\" +\n+                \" ^\");\n+\n+        assertFalse(diff.areEqual());\n+        assertEquals(diff.format(), expected);\n+    }\n+\n+    @Test\n+    public void testUnboundedOneArchiveIsEmpty() {\n+        char[] first = new char[] {'a', 'b', 'c', 'd', 'e'};\n+        char[] second = new char[] {};\n+\n+        ArrayDiff diff = ArrayDiff.of(first, second);\n+        String expected = String.format(\n+                \"Arrays differ starting from [index: 0]:%n\" +\n+                \"[a, b, c, d, e]%n\" +\n+                \"[]%n\" +\n+                \" ^\");\n+\n+        assertFalse(diff.areEqual());\n+        assertEquals(diff.format(), expected);\n+    }\n+\n+    @Test\n+    public void testUnprintableCharFormatting() {\n+        char[] first = new char[]  {0, 1, 2, 3, 4, 5, 6,   7, 8, 9, 10, 11, 12, 13, 14, 15, 16};\n+        char[] second = new char[] {0, 1, 2, 3, 4, 5, 6, 125, 8, 9, 10, 11, 12, 13, 14, 15, 16};\n+\n+        ArrayDiff diff = ArrayDiff.of(first, second);\n+\n+        \/\/ Lines in the code look like aren't aligned due to slashes taking more space than spaces.\n+        var nl = System.lineSeparator();\n+        String expected = \"Arrays differ starting from [index: 7]:\" + nl +\n+                \"... \\\\u0005, \\\\u0006, \\\\u0007, \\\\u0008, \\\\u0009, \\\\n, \\\\u000B, \\\\u000C, \\\\r, \\\\u000E, ...\" + nl +\n+                \"... \\\\u0005, \\\\u0006,      }, \\\\u0008, \\\\u0009, \\\\n, \\\\u000B, \\\\u000C, \\\\r, \\\\u000E, ...\" + nl +\n+                \"                   ^^^^^^^\";\n+        assertFalse(diff.areEqual());\n+        assertEquals(diff.format(), expected);\n+    }\n+\n+    @Test\n+    public void testStringElements() {\n+        String[] first = new String[]  {\"first\", \"second\", \"third\", \"u\\nprintable\"};\n+        String[] second = new String[] {\"first\", \"second\", \"incorrect\", \"u\\nprintable\"};\n+\n+        ArrayDiff diff = ArrayDiff.of(first, second);\n+        String expected = String.format(\n+                \"Arrays differ starting from [index: 2]:%n\" +\n+                \"[\\\"first\\\", \\\"second\\\",     \\\"third\\\", \\\"u\\\\nprintable\\\"]%n\" +\n+                \"[\\\"first\\\", \\\"second\\\", \\\"incorrect\\\", \\\"u\\\\nprintable\\\"]%n\" +\n+                \"                   ^^^^^^^^^^^^\");\n+\n+        assertFalse(diff.areEqual());\n+        assertEquals(diff.format(), expected);\n+    }\n+\n+    @Test\n+    public void testToStringableObjects() {\n+        class StrObj {\n+            private final String value;\n+            public boolean equals(Object another) { return ((StrObj)another).value.equals(value); }\n+            public StrObj(String value) { this.value = value; }\n+            public String toString() { return value; }\n+        }\n+\n+        StrObj[] first = new StrObj[]  {new StrObj(\"1\"), new StrObj(\"Unp\\rintable\"), new StrObj(\"5\")};\n+        StrObj[] second = new StrObj[]  {new StrObj(\"1\"), new StrObj(\"2\"), new StrObj(\"5\")};\n+\n+        ArrayDiff diff = ArrayDiff.of(first, second);\n+        String expected = String.format(\n+                \"Arrays differ starting from [index: 1]:%n\" +\n+                \"[1, Unp\\\\rintable, 5]%n\" +\n+                \"[1,            2, 5]%n\" +\n+                \"   ^^^^^^^^^^^^^\");\n+\n+        assertFalse(diff.areEqual());\n+        assertEquals(diff.format(), expected);\n+    }\n+\n+}\n","filename":"test\/lib-test\/jdk\/test\/lib\/format\/ArrayDiffTest.java","additions":296,"deletions":0,"binary":false,"changes":296,"status":"added"},{"patch":"@@ -0,0 +1,324 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.test.lib.format;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+\n+\/**\n+ * A codec helping representing arrays in a string form.\n+ *\n+ * Encoding can be done in a controllable fashion (allowing the user to encode two\n+ * or more arrays in a time) or as a single operation.\n+ *\/\n+public class ArrayCodec<E> {\n+    private static final String ELLIPSIS = \"...\";\n+\n+    private boolean exhausted;\n+    private StringBuilder encoded;\n+\n+    private List<E> source;\n+    private String element;\n+\n+    private boolean bounded = false;\n+    private int maxWidth;\n+    private int idx;\n+\n+    private ArrayCodec(List<E> source) {\n+        this.source = source;\n+    }\n+\n+    \/**\n+     * Creates a codec for a char array\n+     *\n+     * @param array source array\n+     * @return an ArrayCodec for the provided array\n+     *\/\n+    public static ArrayCodec<Character> of(char[] array) {\n+        var source = new ArrayList<Character>(array.length);\n+        for (char value: array) {\n+            source.add(value);\n+        }\n+        return new ArrayCodec<>(source);\n+    }\n+\n+    \/**\n+     * Creates a codec for a byte array\n+     *\n+     * @param array source array\n+     * @return an ArrayCodec for the provided array\n+     *\/\n+    public static ArrayCodec<Byte> of(byte[] array) {\n+        var source = new ArrayList<Byte>(array.length);\n+        for (byte value: array) {\n+            source.add(value);\n+        }\n+        return new ArrayCodec<>(source);\n+    }\n+\n+    \/**\n+     * Creates a codec for an int array\n+     *\n+     * @param array source array\n+     * @return an ArrayCodec for the provided array\n+     *\/\n+    public static ArrayCodec<Integer> of(int[] array) {\n+        var source = new ArrayList<Integer>(array.length);\n+        for (int value: array) {\n+            source.add(value);\n+        }\n+        return new ArrayCodec<>(source);\n+    }\n+\n+    \/**\n+     * Creates a codec for a long array\n+     *\n+     * @param array source array\n+     * @return an ArrayCodec for the provided array\n+     *\/\n+    public static ArrayCodec<Long> of(long[] array) {\n+        var source = new ArrayList<Long>(array.length);\n+        for (long value: array) {\n+            source.add(value);\n+        }\n+        return new ArrayCodec<>(source);\n+    }\n+\n+    \/**\n+     * Creates a codec for a String array\n+     *\n+     * @param array source array\n+     * @return an ArrayCodec for the provided array\n+     *\/\n+    public static ArrayCodec<String> of(String[] array) {\n+        var source = new ArrayList<String>(array.length);\n+        for (String value: array) {\n+            source.add(value);\n+        }\n+        return new ArrayCodec<>(source);\n+    }\n+\n+    \/**\n+     * Creates a codec for a generic Object array\n+     *\n+     * @param array source array\n+     * @return an ArrayCodec for the provided array\n+     *\/\n+    public static ArrayCodec<Object> of(Object[] array) {\n+        var source = new ArrayList<Object>(array.length);\n+        for (Object value: array) {\n+            source.add(value);\n+        }\n+        return new ArrayCodec<Object>(source);\n+    }\n+\n+    \/**\n+     * Creates a codec for a generic array, trying to recognize its component type\n+     *\n+     * @param array source array\n+     * @throws IllegalArgumentException if {@code array}'s component type is not supported\n+     * @return an ArrayCodec for the provided array\n+     *\/\n+    public static ArrayCodec of(Object array) {\n+        var type = array.getClass().getComponentType();\n+        if (type == byte.class) {\n+            return ArrayCodec.of((byte[])array);\n+        } else if (type == int.class) {\n+            return ArrayCodec.of((int[])array);\n+        } else if (type == long.class) {\n+            return ArrayCodec.of((long[])array);\n+        } else if (type == char.class) {\n+            return ArrayCodec.of((char[])array);\n+        } else if (type == String.class) {\n+            return ArrayCodec.of((String[])array);\n+        } else if (!type.isPrimitive() && !type.isArray()) {\n+            return ArrayCodec.of((Object[])array);\n+        }\n+\n+        throw new IllegalArgumentException(\"Unsupported array component type: \" + type);\n+    }\n+\n+    \/**\n+     * Formats an array at-once.\n+     * The array is enclosed in brackets, its elements are separated with\n+     * commas. String elements are additionally surrounded by double quotes.\n+     * Unprintable symbols are C-stye escaped.\n+     *\n+     * <p>Sample outputs:\n+     *\n+     * <pre>\n+     *   [0, 1, 2, 3, 4]\n+     *   [\"one\", \"first\", \"tree\"]\n+     *   [object1, object2, object3]\n+     *   [a, b, \\n, &#92;u0002\/, c]\n+     * <\/pre>\n+     *\n+     * @throws IllegalArgumentException if {@code array}'s component type is not supported\n+     * @return an ArrayCodec for the provided array\n+     *\/\n+    public static String format(Object array) {\n+        var codec = ArrayCodec.of(array);\n+        codec.startFormatting(0, -1);\n+        while (!codec.isExhausted()) {\n+            codec.formatNext();\n+            codec.appendFormatted();\n+        }\n+        return codec.getEncoded();\n+    }\n+\n+    \/**\n+     * Starts formatting with the given parameters.\n+     *\n+     * @param startIdx first element's index to start formattig with\n+     * @param maxWidth maximum allowed formatting width (in characters).\n+     * @return an ArrayCodec for the provided array\n+     *\/\n+    public void startFormatting(int startIdx, int maxWidth) {\n+        encoded = new StringBuilder(startIdx == 0 ? \"[\" : ELLIPSIS);\n+        exhausted = false;\n+        this.maxWidth = maxWidth;\n+        bounded = (maxWidth > 0);\n+        idx = startIdx;\n+    }\n+\n+    \/**\n+     * Format next element, store it in the internal element storage.\n+     *\/\n+    public void formatNext() {\n+        int limit = source.size();\n+\n+        String prefix = idx == 0 || idx >= limit ? \"\" : \" \";\n+        String suffix = (idx + 1 == limit) || (source.isEmpty() && idx == 0)\n+                ? \"]\"\n+                : idx >= limit ? \"\" : \",\";\n+        element = prefix +\n+                (idx >= limit ? \"\" : Format.asLiteral(source.get(idx)))\n+                + suffix;\n+    }\n+\n+    \/**\n+     * Append formatted element to internal StringBuilder.\n+     *\n+     * The formatted-so-far string can be accessed via {@link #getEncoded}\n+     * no elements in array left the method silently does nothing.\n+     *\/\n+    public void appendFormatted() {\n+        if (exhausted) {\n+            return;\n+        }\n+\n+        boolean isLast = idx == source.size() - 1;\n+        if (isLast || source.isEmpty()) {\n+            exhausted = true;\n+        }\n+\n+        if (bounded && encoded.length() + element.length() > maxWidth - ELLIPSIS.length()) {\n+            encoded.append(isLast ? element : \" \" + ELLIPSIS);\n+            exhausted = true;\n+        } else {\n+            encoded.append(element);\n+        }\n+        idx++;\n+    }\n+\n+    \/**\n+     * Aligns the element by another codec.\n+     *\n+     * If another codec's last encoded element string is longer than this\n+     * codec's, widens this codec's encoded element with spaces so the\n+     * two strings have the same length;\n+     *\n+     * @param another Another codec to compare encoded element width with\n+     *\/\n+    public void alignBy(ArrayCodec<E> another) {\n+        if (!element.equals(\"\") && !element.equals(\"]\")) {\n+            int delta = another.element.length() - element.length();\n+            if (delta > 0) {\n+                element = Format.paddingForWidth(delta) + element;\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Indicates if there are no elements left in the source array\n+     *\n+     * @return {@code true} if there are no elements left, {@code false} otherwise\n+     *\/\n+    public boolean isExhausted() {\n+        return exhausted;\n+    }\n+\n+    \/**\n+     * Returns the string encoded-so-far\n+     *\n+     * @return the string encoded-so-far\n+     *\/\n+    public String getEncoded() {\n+        return encoded.toString();\n+    }\n+\n+    \/**\n+     * Returns the length of the string encoded-so-far\n+     *\n+     * @return the length of the string encoded-so-far\n+     *\/\n+    public int getEncodedLength() {\n+        return encoded.length();\n+    }\n+\n+    \/**\n+     * Returns the length of the last encoded element\n+     *\n+     * @return the length of the last encoded element\n+     *\/\n+    public int getElementLength() {\n+        return element.length();\n+    }\n+\n+    \/**\n+     * Finds and returns the first mismatch index in another codec\n+     *\n+     * @param another a codec mismatch with whom is to be found\n+     * @return the first mismatched element's index\n+     *\/\n+    public int findMismatchIndex(ArrayCodec<E> another) {\n+        int result = 0;\n+        while ((source.size() > result) &&\n+                (another.source.size() > result) &&\n+                (source.get(result).equals(another.source.get(result)))) {\n+            result += 1;\n+        }\n+        return result;\n+    }\n+\n+    \/**\n+     * Indicates whether source array for another codec is equal to this codec's array\n+     *\n+     * @return {@code true} if source arrays are equal, {@code false} otherwise\n+     *\/\n+    public boolean equals(ArrayCodec<E> another) {\n+        return source.equals(another.source);\n+    }\n+}\n","filename":"test\/lib\/jdk\/test\/lib\/format\/ArrayCodec.java","additions":324,"deletions":0,"binary":false,"changes":324,"status":"added"},{"patch":"@@ -0,0 +1,209 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.test.lib.format;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+\n+\/**\n+ * A difference between two arrays, which can be pretty formatted.\n+ * For the calculated difference, user can request if the two arrays\n+ * are equal (in terms of {@link Object#equals Object.equals()} for their\n+ * elements). For the arrays that differ, a human-readable difference can\n+ * be provided.\n+ *\n+ * <p>The difference is represented as a four-line text block, comprising of the\n+ * first different element index, arrays printouts in the difference area,\n+ * and a difference mark. For Primitive and Object elements in the source\n+ * arrays their C-style escaped {@link String#valueOf String.valueOf()} are\n+ * printed, element in String[] arrays are additionally surrounded with quotes.\n+ * Additional formatting parameters, like maximum allowed width and number of\n+ * elements printed before difference, can be specified.\n+ *\n+ * <p>Output examples:\n+ *\n+ * <p> two int arrays: <\/p>\n+ * <pre>\n+ * Arrays differ starting from [index: 4]:\n+ *         ... 3, 4,   5, 6, 7]\n+ *         ... 3, 4, 225, 6, 7]\n+ *                  ^^^^\n+ * <\/pre>\n+ * <p> two String arrays: <\/p>\n+ * <pre>\n+ * Arrays differ starting from [index: 2]:\n+ *         [\"first\", \"second\",     \"third\", \"u\\nprintable\"]\n+ *         [\"first\", \"second\", \"incorrect\", \"u\\nprintable\"]\n+ *                            ^^^^^^^^^^^^\n+ * <\/pre>\n+ * <p> two char arrays arrays: <\/p>\n+ * <pre>\n+ * Arrays differ starting from [index: 7]:\n+ *         ... &#92;u0001, &#92;u0002, &#92;u0007, a, b, \\n, ...\n+ *         ... &#92;u0001, &#92;u0002,      }, a, b, \\n, ...\n+ *                            ^^^^^^^\n+ * <\/pre>\n+ *\/\n+public class ArrayDiff<E> implements Diff {\n+\n+    private int failureIdx;\n+    private final int maxWidth;\n+    private final int contextBefore;\n+\n+    private final ArrayCodec<E> first;\n+    private final ArrayCodec<E> second;\n+\n+    \/**\n+     * Default limits for the formatter\n+     *\/\n+    public static class Defaults {\n+        public final static int WIDTH = 80;\n+        public final static int CONTEXT_BEFORE = 2;\n+    }\n+\n+    private ArrayDiff(ArrayCodec<E> first, ArrayCodec<E> second,\n+                      int width, int getContextBefore) {\n+        this.first = first;\n+        this.second = second;\n+        this.maxWidth = width;\n+        this.contextBefore = getContextBefore;\n+        failureIdx = first.findMismatchIndex(second);\n+    }\n+\n+    \/**\n+     * Creates an ArrayDiff fom two arrays and default limits. The given arguments must be of the same\n+     * component type.\n+     *\n+     * @param first the first array\n+     * @param second the second array\n+     * @return an ArrayDiff instance for the two arrays\n+     *\/\n+    public static ArrayDiff of(Object first, Object second) {\n+        return ArrayDiff.of(first, second, Defaults.WIDTH, Defaults.CONTEXT_BEFORE);\n+    }\n+\n+    \/**\n+     * Creates an ArrayDiff fom two arrays with the given limits. The given arguments must be of the same\n+     * component type.\n+     *\n+     * @param first the first array\n+     * @param second the second array\n+     * @param width the maximum allowed width in characters for the formatting\n+     * @param contextBefore maximum number of elements to print before those that differ\n+     * @throws IllegalArgumentException if component types of arrays is not supported or are not the same\n+     * @return an ArrayDiff instance for the two arrays and formatting parameters provided\n+     *\/\n+    public static ArrayDiff of(Object first, Object second, int width, int contextBefore) {\n+        boolean bothAreArrays = first.getClass().isArray() && second.getClass().isArray();\n+        boolean componentTypesAreSame =\n+            first.getClass().getComponentType() == second.getClass().getComponentType();\n+\n+        if (!bothAreArrays || !componentTypesAreSame) {\n+            throw new IllegalArgumentException(\"Both arguments should be arrays of the same type\");\n+        }\n+\n+        return new ArrayDiff(\n+                ArrayCodec.of(first),\n+                ArrayCodec.of(second),\n+                width, contextBefore);\n+    }\n+\n+    \/**\n+     * Formats the given diff.\n+     *\n+     * @return formatted difference representation.\n+     *\/\n+    @Override\n+    public String format() {\n+        if (areEqual()) {\n+            return \"\";\n+        }\n+\n+        return format(false)\n+                .orElseGet(() -> format(true).get());\n+    }\n+\n+    \/**\n+     * Indicates whether the two source arrays are equal\n+     *\n+     * @return {@code true} if the arrays are different, {@code false} otherwise\n+     *\/\n+    @Override\n+    public boolean areEqual() {\n+        return first.equals(second);\n+    }\n+\n+    private void extractAndAlignElements() {\n+        first.formatNext();\n+        second.formatNext();\n+\n+        first.alignBy(second);\n+        second.alignBy(first);\n+    }\n+\n+    private static String failureMarkForWidth(int width) {\n+        return new String(\"^\").repeat(width);\n+    }\n+\n+    private Optional<String> format(boolean bounded) {\n+        int idx = bounded ? Math.max(0, failureIdx - contextBefore) : 0;\n+\n+        first.startFormatting(idx, bounded ? maxWidth : -1);\n+        second.startFormatting(idx, bounded ? maxWidth : -1);\n+        StringBuilder failureMark = new StringBuilder(\n+                Format.paddingForWidth(first.getEncodedLength()));\n+\n+        for (; !(first.isExhausted() && second.isExhausted()); idx++) {\n+            extractAndAlignElements();\n+\n+            first.appendFormatted();\n+            second.appendFormatted();\n+\n+            { \/\/ Process failure mark\n+                if (idx < failureIdx) {\n+                    failureMark.append(Format.paddingForWidth(first.getElementLength()));\n+                } else  if (idx == failureIdx) {\n+                    failureMark.append(failureMarkForWidth(first.getElementLength()-1));\n+                }\n+            }\n+\n+            final int maxEncodedLength = Math.max(\n+                    first.getEncodedLength(),\n+                    second.getEncodedLength());\n+            if (!bounded && maxEncodedLength > maxWidth) {\n+                return Optional.empty();\n+            }\n+        }\n+\n+        return Optional.of(String.format(\n+                \"Arrays differ starting from [index: %d]:%n%s%n%s%n%s\",\n+                failureIdx,\n+                first.getEncoded(),\n+                second.getEncoded(),\n+                failureMark.toString()));\n+    }\n+\n+}\n+\n","filename":"test\/lib\/jdk\/test\/lib\/format\/ArrayDiff.java","additions":209,"deletions":0,"binary":false,"changes":209,"status":"added"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * Represents a possible difference between two objects.\n+ *\/\n+package jdk.test.lib.format;\n+\n+\/**\n+ * An abstraction representing formattabe difference between two or more objects\n+ *\/\n+public interface Diff {\n+\n+    \/**\n+     * Formats the given diff. Different implementations can provide different\n+     * result and formatting style.\n+     *\n+     * @return formatted difference representation.\n+     *\/\n+    String format();\n+\n+    \/**\n+     * Indicates whether the two source arrays are equal. Different\n+     * implementations can treat this notion differently.\n+     *\n+     * @return {@code true} if the source objects are different, {@code false} otherwise\n+     *\/\n+    boolean areEqual();\n+}\n","filename":"test\/lib\/jdk\/test\/lib\/format\/Diff.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -0,0 +1,127 @@\n+\/*\n+ * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.test.lib.format;\n+\n+\/**\n+ * A collection of formatting utilities\n+ *\/\n+public class Format {\n+\n+    \/**\n+     * Formats character as literal, using C-style escaping for unprintable symbols\n+     *\n+     * @param c character to format\n+     * @return formatted string representation of the character\n+     *\/\n+    public static String asLiteral(char c) {\n+        StringBuilder sb = new StringBuilder();\n+        appendCharToSb(c, sb);\n+        return sb.toString();\n+    }\n+\n+    \/**\n+     * Escapes String in C-style\n+     *\n+     * @param src source string\n+     * @return C-style escaped source string\n+     *\/\n+    public static String escapeString(String src) {\n+        StringBuilder sb = new StringBuilder();\n+        src.chars().forEachOrdered(\n+                (c) -> appendCharToSb((char) c, sb));\n+        return sb.toString();\n+    }\n+\n+    \/**\n+     * Formats Object as literal, using its String representation C-style escaped.\n+     *\n+     * @param o object to format\n+     * @return C-style escaped String representation of the object\n+     *\/\n+    public static String asLiteral(Object o) {\n+        if (o instanceof String) {\n+            return '\"' + escapeString((String)o) + '\"';\n+        } else if (o instanceof Character) {\n+            return asLiteral((char) o);\n+        } else if (o instanceof Byte) {\n+            return String.valueOf(o);\n+        } else {\n+            return escapeString(String.valueOf(o));\n+        }\n+    }\n+\n+    \/**\n+     * Formats a difference between two arrays with index of the first mismatch element,\n+     * and slices of arrays necessary to understand the problem, along with a failure mark.\n+     *\n+     * @param first first array to compare\n+     * @param second second array to compare\n+     * @return the difference, generated by the {@link ArrayDiff ArrayDiff}\n+     *\/\n+    public static String arrayDiff(Object first, Object second) {\n+        return ArrayDiff.of(first, second).format();\n+    }\n+\n+    \/**\n+     * Formats a difference between two arrays with index of the first mismatch element,\n+     * and slices of arrays necessary to understand the problem, along with a failure mark.\n+     * Takes into account maximum allowed width and context (in elements) before the mismatch.\n+     *\n+     * @param first first array to compare\n+     * @param second second array to compare\n+     * @param width the maximum allowed width in characters for the formatting\n+     * @param contextBefore maximum number of elements to print before those that differ\n+     * @return the difference, generated by the {@link ArrayDiff ArrayDiff}\n+     *\/\n+    public static String arrayDiff(Object first, Object second, int width, int contextBefore) {\n+        return ArrayDiff.of(first, second, width, contextBefore).format();\n+    }\n+\n+\n+    \/**\n+     * Returns a string of spaces with length specified.\n+     *\n+     * @param width number of spaces in the resulting string\n+     * @return Padding string of spaces\n+     *\/\n+    public static String paddingForWidth(int width) {\n+        return \" \".repeat(width);\n+    }\n+\n+    private static void appendCharToSb(char c, StringBuilder sb) {\n+        if (c == 10) {\n+            sb.append(\"\\\\n\");\n+        } else if (c == 13) {\n+            sb.append(\"\\\\r\");\n+        } else if (c == 92) {\n+            sb.append(\"\\\\\\\\\");\n+        } else if (c == 34) {\n+            sb.append(\"\\\\\\\"\");\n+        } else if (c < 32 || c > 126) {\n+            sb.append(\"\\\\u\" + String.format(\"%04X\", (int) c));\n+        } else {\n+            sb.append(c);\n+        }\n+    }\n+}\n","filename":"test\/lib\/jdk\/test\/lib\/format\/Format.java","additions":127,"deletions":0,"binary":false,"changes":127,"status":"added"}]}