{"files":[{"patch":"@@ -35,1 +35,1 @@\n- *     waits for a monitor. Then the test calls java.lang.Thread.getStackTrace()\n+ *     wait on a monitor. Then the test calls java.lang.Thread.getStackTrace()\n@@ -37,6 +37,1 @@\n- *     The test fails if:\n- *     - amount of stack trace elements and stack trace elements themselves are\n- *       the same for both methods;\n- *     - there is at least one element corresponding to invocation of unexpected\n- *       method. Expected methods are Thread.sleep(), Thread.run() and the\n- *       recursive method.\n+ *     The test fails if the stacks for each thread do not match.\n@@ -58,1 +53,1 @@\n- * The test runs <code>THRD_COUNT<\/code> instances of <code>strace010Thread<\/code>,\n+ * The test runs <code>THRD_COUNT<\/code> instances of <code>strace013Thread<\/code>,\n@@ -60,1 +55,1 @@\n- * <code>DEPTH<\/code> of recursion, each thread is switched to wait a monitor.\n+ * <code>DEPTH<\/code> of recursion, each thread is switched to wait on a monitor.\n@@ -65,1 +60,1 @@\n- * for both stack traces must be corresponded to invocation of one of the methods\n+ * for both stack traces correspond to invocation of one of the methods\n@@ -67,0 +62,4 @@\n+ *\n+ * There is some leeway in the expected stack depth as a thread may not have\n+ * reached the native wait0() call when the stacktrace is taken. So we allow\n+ * a difference of 3 for the methods: wait(), wait(0), and wait0(0)\n@@ -73,1 +72,1 @@\n-            \"java.lang.Object.wait\",\n+            \"java.lang.Object.wait\", \/\/ two variants\n@@ -175,1 +174,1 @@\n-            if (count - k > 2) {\n+            if (count - k > 3) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/strace\/strace013.java","additions":11,"deletions":12,"binary":false,"changes":23,"status":"modified"}]}