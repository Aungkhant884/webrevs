{"files":[{"patch":"@@ -124,0 +124,1 @@\n+      cppVtables.cpp \\\n","filename":"make\/hotspot\/lib\/JvmFeatures.gmk","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"memory\/cppVtables.hpp\"\n@@ -482,1 +483,1 @@\n-  intptr_t* archived_vtable = MetaspaceShared::get_archived_cpp_vtable(ref->msotype(), (address)dest);\n+  intptr_t* archived_vtable = CppVtables::get_archived_cpp_vtable(ref->msotype(), (address)dest);\n","filename":"src\/hotspot\/share\/memory\/archiveBuilder.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,332 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"memory\/archiveUtils.hpp\"\n+#include \"memory\/cppVtables.hpp\"\n+#include \"memory\/metaspaceShared.hpp\"\n+#include \"oops\/instanceClassLoaderKlass.hpp\"\n+#include \"oops\/instanceMirrorKlass.hpp\"\n+#include \"oops\/instanceRefKlass.hpp\"\n+#include \"oops\/methodData.hpp\"\n+#include \"oops\/objArrayKlass.hpp\"\n+#include \"oops\/typeArrayKlass.hpp\"\n+#include \"runtime\/arguments.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+\/\/ Objects of the Metadata types (such as Klass and ConstantPool) have C++ vtables.\n+\/\/ (In GCC this is the field <Type>::_vptr, i.e., first word in the object.)\n+\/\/\n+\/\/ Addresses of the vtables and the methods may be different across JVM runs,\n+\/\/ if libjvm.so is dynamically loaded at a different base address.\n+\/\/\n+\/\/ To ensure that the Metadata objects in the CDS archive always have the correct vtable:\n+\/\/\n+\/\/ + at dump time:  we redirect the _vptr to point to our own vtables inside\n+\/\/                  the CDS image\n+\/\/ + at run time:   we clone the actual contents of the vtables from libjvm.so\n+\/\/                  into our own tables.\n+\n+\/\/ Currently, the archive contain ONLY the following types of objects that have C++ vtables.\n+#define CPP_VTABLE_PATCH_TYPES_DO(f) \\\n+  f(ConstantPool) \\\n+  f(InstanceKlass) \\\n+  f(InstanceClassLoaderKlass) \\\n+  f(InstanceMirrorKlass) \\\n+  f(InstanceRefKlass) \\\n+  f(Method) \\\n+  f(ObjArrayKlass) \\\n+  f(TypeArrayKlass)\n+\n+class CppVtableInfo {\n+  intptr_t _vtable_size;\n+  intptr_t _cloned_vtable[1];\n+public:\n+  static int num_slots(int vtable_size) {\n+    return 1 + vtable_size; \/\/ Need to add the space occupied by _vtable_size;\n+  }\n+  int vtable_size()           { return int(uintx(_vtable_size)); }\n+  void set_vtable_size(int n) { _vtable_size = intptr_t(n); }\n+  intptr_t* cloned_vtable()   { return &_cloned_vtable[0]; }\n+  void zero()                 { memset(_cloned_vtable, 0, sizeof(intptr_t) * vtable_size()); }\n+  \/\/ Returns the address of the next CppVtableInfo that can be placed immediately after this CppVtableInfo\n+  static size_t byte_size(int vtable_size) {\n+    CppVtableInfo i;\n+    return pointer_delta(&i._cloned_vtable[vtable_size], &i, sizeof(u1));\n+  }\n+};\n+\n+static inline intptr_t* vtable_of(Metadata* m) {\n+  return *((intptr_t**)m);\n+}\n+\n+static inline DumpRegion* mc_region() {\n+  return MetaspaceShared::misc_code_dump_space();\n+}\n+\n+template <class T> class CppVtableCloner : public T {\n+  static CppVtableInfo* _info;\n+\n+  static int get_vtable_length(const char* name);\n+\n+public:\n+  \/\/ Allocate and initialize the C++ vtable, starting from top, but do not go past end.\n+  static intptr_t* allocate(const char* name);\n+\n+  \/\/ Clone the vtable to ...\n+  static intptr_t* clone_vtable(const char* name, CppVtableInfo* info);\n+\n+  static void zero_vtable_clone() {\n+    assert(DumpSharedSpaces, \"dump-time only\");\n+    _info->zero();\n+  }\n+\n+  static bool is_valid_shared_object(const T* obj) {\n+    intptr_t* vptr = *(intptr_t**)obj;\n+    return vptr == _info->cloned_vtable();\n+  }\n+\n+  static void init_orig_cpp_vtptr(int kind);\n+};\n+\n+template <class T> CppVtableInfo* CppVtableCloner<T>::_info = NULL;\n+\n+template <class T>\n+intptr_t* CppVtableCloner<T>::allocate(const char* name) {\n+  assert(is_aligned(mc_region()->top(), sizeof(intptr_t)), \"bad alignment\");\n+  int n = get_vtable_length(name);\n+  _info = (CppVtableInfo*)mc_region()->allocate(CppVtableInfo::byte_size(n), sizeof(intptr_t));\n+  _info->set_vtable_size(n);\n+\n+  intptr_t* p = clone_vtable(name, _info);\n+  assert((char*)p == mc_region()->top(), \"must be\");\n+\n+  return _info->cloned_vtable();\n+}\n+\n+template <class T>\n+intptr_t* CppVtableCloner<T>::clone_vtable(const char* name, CppVtableInfo* info) {\n+  if (!DumpSharedSpaces) {\n+    assert(_info == 0, \"_info is initialized only at dump time\");\n+    _info = info; \/\/ Remember it -- it will be used by MetaspaceShared::is_valid_shared_method()\n+  }\n+  T tmp; \/\/ Allocate temporary dummy metadata object to get to the original vtable.\n+  int n = info->vtable_size();\n+  intptr_t* srcvtable = vtable_of(&tmp);\n+  intptr_t* dstvtable = info->cloned_vtable();\n+\n+  \/\/ We already checked (and, if necessary, adjusted n) when the vtables were allocated, so we are\n+  \/\/ safe to do memcpy.\n+  log_debug(cds, vtables)(\"Copying %3d vtable entries for %s\", n, name);\n+  memcpy(dstvtable, srcvtable, sizeof(intptr_t) * n);\n+  return dstvtable + n;\n+}\n+\n+\/\/ To determine the size of the vtable for each type, we use the following\n+\/\/ trick by declaring 2 subclasses:\n+\/\/\n+\/\/   class CppVtableTesterA: public InstanceKlass {virtual int   last_virtual_method() {return 1;}    };\n+\/\/   class CppVtableTesterB: public InstanceKlass {virtual void* last_virtual_method() {return NULL}; };\n+\/\/\n+\/\/ CppVtableTesterA and CppVtableTesterB's vtables have the following properties:\n+\/\/ - Their size (N+1) is exactly one more than the size of InstanceKlass's vtable (N)\n+\/\/ - The first N entries have are exactly the same as in InstanceKlass's vtable.\n+\/\/ - Their last entry is different.\n+\/\/\n+\/\/ So to determine the value of N, we just walk CppVtableTesterA and CppVtableTesterB's tables\n+\/\/ and find the first entry that's different.\n+\/\/\n+\/\/ This works on all C++ compilers supported by Oracle, but you may need to tweak it for more\n+\/\/ esoteric compilers.\n+\n+template <class T> class CppVtableTesterB: public T {\n+public:\n+  virtual int last_virtual_method() {return 1;}\n+};\n+\n+template <class T> class CppVtableTesterA : public T {\n+public:\n+  virtual void* last_virtual_method() {\n+    \/\/ Make this different than CppVtableTesterB::last_virtual_method so the C++\n+    \/\/ compiler\/linker won't alias the two functions.\n+    return NULL;\n+  }\n+};\n+\n+template <class T>\n+int CppVtableCloner<T>::get_vtable_length(const char* name) {\n+  CppVtableTesterA<T> a;\n+  CppVtableTesterB<T> b;\n+\n+  intptr_t* avtable = vtable_of(&a);\n+  intptr_t* bvtable = vtable_of(&b);\n+\n+  \/\/ Start at slot 1, because slot 0 may be RTTI (on Solaris\/Sparc)\n+  int vtable_len = 1;\n+  for (; ; vtable_len++) {\n+    if (avtable[vtable_len] != bvtable[vtable_len]) {\n+      break;\n+    }\n+  }\n+  log_debug(cds, vtables)(\"Found   %3d vtable entries for %s\", vtable_len, name);\n+\n+  return vtable_len;\n+}\n+\n+#define ALLOC_CPP_VTABLE_CLONE(c) \\\n+  _cloned_cpp_vtptrs[c##_Kind] = CppVtableCloner<c>::allocate(#c); \\\n+  ArchivePtrMarker::mark_pointer(&_cloned_cpp_vtptrs[c##_Kind]);\n+\n+#define CLONE_CPP_VTABLE(c) \\\n+  p = CppVtableCloner<c>::clone_vtable(#c, (CppVtableInfo*)p);\n+\n+#define ZERO_CPP_VTABLE(c) \\\n+ CppVtableCloner<c>::zero_vtable_clone();\n+\n+#define INIT_ORIG_CPP_VTPTRS(c) \\\n+  CppVtableCloner<c>::init_orig_cpp_vtptr(c##_Kind);\n+\n+#define DECLARE_CLONED_VTABLE_KIND(c) c ## _Kind,\n+\n+enum ClonedVtableKind {\n+  \/\/ E.g., ConstantPool_Kind == 0, InstanceKlass_Kind == 1, etc.\n+  CPP_VTABLE_PATCH_TYPES_DO(DECLARE_CLONED_VTABLE_KIND)\n+  _num_cloned_vtable_kinds\n+};\n+\n+\/\/ This is a map of all the original vtptrs. E.g., for\n+\/\/     ConstantPool *cp = new (...) ConstantPool(...) ; \/\/ a dynamically allocated constant pool\n+\/\/ the following holds true:\n+\/\/     _orig_cpp_vtptrs[ConstantPool_Kind] ==  ((intptr_t**)cp)[0]\n+static intptr_t* _orig_cpp_vtptrs[_num_cloned_vtable_kinds];\n+static bool _orig_cpp_vtptrs_inited = false;\n+\n+template <class T>\n+void CppVtableCloner<T>::init_orig_cpp_vtptr(int kind) {\n+  assert(kind < _num_cloned_vtable_kinds, \"sanity\");\n+  T tmp; \/\/ Allocate temporary dummy metadata object to get to the original vtable.\n+  intptr_t* srcvtable = vtable_of(&tmp);\n+  _orig_cpp_vtptrs[kind] = srcvtable;\n+}\n+\n+\/\/ This is the index of all the cloned vtables. E.g., for\n+\/\/     ConstantPool* cp = ....; \/\/ an archived constant pool\n+\/\/     InstanceKlass* ik = ....;\/\/ an archived class\n+\/\/ the following holds true:\n+\/\/     _cloned_cpp_vtptrs[ConstantPool_Kind]  == ((intptr_t**)cp)[0]\n+\/\/     _cloned_cpp_vtptrs[InstanceKlass_Kind] == ((intptr_t**)ik)[0]\n+static intptr_t** _cloned_cpp_vtptrs = NULL;\n+\n+void CppVtables::allocate_cloned_cpp_vtptrs() {\n+  assert(DumpSharedSpaces, \"must\");\n+  size_t vtptrs_bytes = _num_cloned_vtable_kinds * sizeof(intptr_t*);\n+  _cloned_cpp_vtptrs = (intptr_t**)mc_region()->allocate(vtptrs_bytes, sizeof(intptr_t*));\n+}\n+\n+void CppVtables::serialize_cloned_cpp_vtptrs(SerializeClosure* soc) {\n+  soc->do_ptr((void**)&_cloned_cpp_vtptrs);\n+}\n+\n+intptr_t* CppVtables::get_archived_cpp_vtable(MetaspaceObj::Type msotype, address obj) {\n+  if (!_orig_cpp_vtptrs_inited) {\n+    CPP_VTABLE_PATCH_TYPES_DO(INIT_ORIG_CPP_VTPTRS);\n+    _orig_cpp_vtptrs_inited = true;\n+  }\n+\n+  Arguments::assert_is_dumping_archive();\n+  int kind = -1;\n+  switch (msotype) {\n+  case MetaspaceObj::SymbolType:\n+  case MetaspaceObj::TypeArrayU1Type:\n+  case MetaspaceObj::TypeArrayU2Type:\n+  case MetaspaceObj::TypeArrayU4Type:\n+  case MetaspaceObj::TypeArrayU8Type:\n+  case MetaspaceObj::TypeArrayOtherType:\n+  case MetaspaceObj::ConstMethodType:\n+  case MetaspaceObj::ConstantPoolCacheType:\n+  case MetaspaceObj::AnnotationsType:\n+  case MetaspaceObj::MethodCountersType:\n+  case MetaspaceObj::RecordComponentType:\n+    \/\/ These have no vtables.\n+    break;\n+  case MetaspaceObj::MethodDataType:\n+    \/\/ We don't archive MethodData <-- should have been removed in removed_unsharable_info\n+    ShouldNotReachHere();\n+    break;\n+  default:\n+    for (kind = 0; kind < _num_cloned_vtable_kinds; kind ++) {\n+      if (vtable_of((Metadata*)obj) == _orig_cpp_vtptrs[kind]) {\n+        break;\n+      }\n+    }\n+    if (kind >= _num_cloned_vtable_kinds) {\n+      fatal(\"Cannot find C++ vtable for \" INTPTR_FORMAT \" -- you probably added\"\n+            \" a new subtype of Klass or MetaData without updating CPP_VTABLE_PATCH_TYPES_DO\",\n+            p2i(obj));\n+    }\n+  }\n+\n+  if (kind >= 0) {\n+    assert(kind < _num_cloned_vtable_kinds, \"must be\");\n+    return _cloned_cpp_vtptrs[kind];\n+  } else {\n+    return NULL;\n+  }\n+}\n+\n+\/\/ This can be called at both dump time and run time:\n+\/\/ - clone the contents of the c++ vtables into the space\n+\/\/   allocated by allocate_cpp_vtable_clones()\n+void CppVtables::clone_cpp_vtables(intptr_t* p) {\n+  assert(DumpSharedSpaces || UseSharedSpaces, \"sanity\");\n+  CPP_VTABLE_PATCH_TYPES_DO(CLONE_CPP_VTABLE);\n+}\n+\n+void CppVtables::zero_cpp_vtable_clones_for_writing() {\n+  assert(DumpSharedSpaces, \"dump-time only\");\n+  CPP_VTABLE_PATCH_TYPES_DO(ZERO_CPP_VTABLE);\n+}\n+\n+\/\/ Allocate and initialize the C++ vtables, starting from top, but do not go past end.\n+char* CppVtables::allocate_cpp_vtable_clones() {\n+  char* cloned_vtables = mc_region()->top(); \/\/ This is the beginning of all the cloned vtables\n+\n+  assert(DumpSharedSpaces, \"dump-time only\");\n+  \/\/ Layout (each slot is a intptr_t):\n+  \/\/   [number of slots in the first vtable = n1]\n+  \/\/   [ <n1> slots for the first vtable]\n+  \/\/   [number of slots in the first second = n2]\n+  \/\/   [ <n2> slots for the second vtable]\n+  \/\/   ...\n+  \/\/ The order of the vtables is the same as the CPP_VTAB_PATCH_TYPES_DO macro.\n+  CPP_VTABLE_PATCH_TYPES_DO(ALLOC_CPP_VTABLE_CLONE);\n+\n+  return cloned_vtables;\n+}\n+\n+bool CppVtables::is_valid_shared_method(const Method* m) {\n+  assert(MetaspaceShared::is_in_shared_metaspace(m), \"must be\");\n+  return CppVtableCloner<Method>::is_valid_shared_object(m);\n+}\n","filename":"src\/hotspot\/share\/memory\/cppVtables.cpp","additions":332,"deletions":0,"binary":false,"changes":332,"status":"added"},{"patch":"@@ -0,0 +1,48 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_MEMORY_CPPVTABLES_HPP\n+#define SHARE_MEMORY_CPPVTABLES_HPP\n+\n+#include \"memory\/allocation.hpp\"\n+#include \"memory\/allStatic.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+class Method;\n+class SerializeClosure;\n+\n+\/\/ Support for C++ vtables in CDS archive.\n+class CppVtables : AllStatic {\n+  static void patch_cpp_vtable_pointers();\n+public:\n+  static char* allocate_cpp_vtable_clones();\n+  static void allocate_cloned_cpp_vtptrs();\n+  static void clone_cpp_vtables(intptr_t* p);\n+  static void zero_cpp_vtable_clones_for_writing();\n+  static intptr_t* get_archived_cpp_vtable(MetaspaceObj::Type msotype, address obj);\n+  static void serialize_cloned_cpp_vtptrs(SerializeClosure* sc);\n+  static bool is_valid_shared_method(const Method* m) NOT_CDS_RETURN_(false);\n+};\n+\n+#endif \/\/ SHARE_MEMORY_CPPVTABLES_HPP\n","filename":"src\/hotspot\/share\/memory\/cppVtables.hpp","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -44,0 +44,1 @@\n+#include \"memory\/cppVtables.hpp\"\n@@ -54,1 +55,0 @@\n-#include \"oops\/instanceClassLoaderKlass.hpp\"\n@@ -56,3 +56,0 @@\n-#include \"oops\/instanceRefKlass.hpp\"\n-#include \"oops\/methodData.hpp\"\n-#include \"oops\/objArrayKlass.hpp\"\n@@ -62,1 +59,0 @@\n-#include \"oops\/typeArrayKlass.hpp\"\n@@ -507,1 +503,1 @@\n-  serialize_cloned_cpp_vtptrs(soc);\n+  CppVtables::serialize_cloned_cpp_vtptrs(soc);\n@@ -619,291 +615,0 @@\n-\/\/ Objects of the Metadata types (such as Klass and ConstantPool) have C++ vtables.\n-\/\/ (In GCC this is the field <Type>::_vptr, i.e., first word in the object.)\n-\/\/\n-\/\/ Addresses of the vtables and the methods may be different across JVM runs,\n-\/\/ if libjvm.so is dynamically loaded at a different base address.\n-\/\/\n-\/\/ To ensure that the Metadata objects in the CDS archive always have the correct vtable:\n-\/\/\n-\/\/ + at dump time:  we redirect the _vptr to point to our own vtables inside\n-\/\/                  the CDS image\n-\/\/ + at run time:   we clone the actual contents of the vtables from libjvm.so\n-\/\/                  into our own tables.\n-\n-\/\/ Currently, the archive contain ONLY the following types of objects that have C++ vtables.\n-#define CPP_VTABLE_PATCH_TYPES_DO(f) \\\n-  f(ConstantPool) \\\n-  f(InstanceKlass) \\\n-  f(InstanceClassLoaderKlass) \\\n-  f(InstanceMirrorKlass) \\\n-  f(InstanceRefKlass) \\\n-  f(Method) \\\n-  f(ObjArrayKlass) \\\n-  f(TypeArrayKlass)\n-\n-class CppVtableInfo {\n-  intptr_t _vtable_size;\n-  intptr_t _cloned_vtable[1];\n-public:\n-  static int num_slots(int vtable_size) {\n-    return 1 + vtable_size; \/\/ Need to add the space occupied by _vtable_size;\n-  }\n-  int vtable_size()           { return int(uintx(_vtable_size)); }\n-  void set_vtable_size(int n) { _vtable_size = intptr_t(n); }\n-  intptr_t* cloned_vtable()   { return &_cloned_vtable[0]; }\n-  void zero()                 { memset(_cloned_vtable, 0, sizeof(intptr_t) * vtable_size()); }\n-  \/\/ Returns the address of the next CppVtableInfo that can be placed immediately after this CppVtableInfo\n-  static size_t byte_size(int vtable_size) {\n-    CppVtableInfo i;\n-    return pointer_delta(&i._cloned_vtable[vtable_size], &i, sizeof(u1));\n-  }\n-};\n-\n-static inline intptr_t* vtable_of(Metadata* m) {\n-  return *((intptr_t**)m);\n-}\n-\n-template <class T> class CppVtableCloner : public T {\n-  static CppVtableInfo* _info;\n-\n-  static int get_vtable_length(const char* name);\n-\n-public:\n-  \/\/ Allocate and initialize the C++ vtable, starting from top, but do not go past end.\n-  static intptr_t* allocate(const char* name);\n-\n-  \/\/ Clone the vtable to ...\n-  static intptr_t* clone_vtable(const char* name, CppVtableInfo* info);\n-\n-  static void zero_vtable_clone() {\n-    assert(DumpSharedSpaces, \"dump-time only\");\n-    _info->zero();\n-  }\n-\n-  static bool is_valid_shared_object(const T* obj) {\n-    intptr_t* vptr = *(intptr_t**)obj;\n-    return vptr == _info->cloned_vtable();\n-  }\n-\n-  static void init_orig_cpp_vtptr(int kind);\n-};\n-\n-template <class T> CppVtableInfo* CppVtableCloner<T>::_info = NULL;\n-\n-template <class T>\n-intptr_t* CppVtableCloner<T>::allocate(const char* name) {\n-  assert(is_aligned(_mc_region.top(), sizeof(intptr_t)), \"bad alignment\");\n-  int n = get_vtable_length(name);\n-  _info = (CppVtableInfo*)_mc_region.allocate(CppVtableInfo::byte_size(n), sizeof(intptr_t));\n-  _info->set_vtable_size(n);\n-\n-  intptr_t* p = clone_vtable(name, _info);\n-  assert((char*)p == _mc_region.top(), \"must be\");\n-\n-  return _info->cloned_vtable();\n-}\n-\n-template <class T>\n-intptr_t* CppVtableCloner<T>::clone_vtable(const char* name, CppVtableInfo* info) {\n-  if (!DumpSharedSpaces) {\n-    assert(_info == 0, \"_info is initialized only at dump time\");\n-    _info = info; \/\/ Remember it -- it will be used by MetaspaceShared::is_valid_shared_method()\n-  }\n-  T tmp; \/\/ Allocate temporary dummy metadata object to get to the original vtable.\n-  int n = info->vtable_size();\n-  intptr_t* srcvtable = vtable_of(&tmp);\n-  intptr_t* dstvtable = info->cloned_vtable();\n-\n-  \/\/ We already checked (and, if necessary, adjusted n) when the vtables were allocated, so we are\n-  \/\/ safe to do memcpy.\n-  log_debug(cds, vtables)(\"Copying %3d vtable entries for %s\", n, name);\n-  memcpy(dstvtable, srcvtable, sizeof(intptr_t) * n);\n-  return dstvtable + n;\n-}\n-\n-\/\/ To determine the size of the vtable for each type, we use the following\n-\/\/ trick by declaring 2 subclasses:\n-\/\/\n-\/\/   class CppVtableTesterA: public InstanceKlass {virtual int   last_virtual_method() {return 1;}    };\n-\/\/   class CppVtableTesterB: public InstanceKlass {virtual void* last_virtual_method() {return NULL}; };\n-\/\/\n-\/\/ CppVtableTesterA and CppVtableTesterB's vtables have the following properties:\n-\/\/ - Their size (N+1) is exactly one more than the size of InstanceKlass's vtable (N)\n-\/\/ - The first N entries have are exactly the same as in InstanceKlass's vtable.\n-\/\/ - Their last entry is different.\n-\/\/\n-\/\/ So to determine the value of N, we just walk CppVtableTesterA and CppVtableTesterB's tables\n-\/\/ and find the first entry that's different.\n-\/\/\n-\/\/ This works on all C++ compilers supported by Oracle, but you may need to tweak it for more\n-\/\/ esoteric compilers.\n-\n-template <class T> class CppVtableTesterB: public T {\n-public:\n-  virtual int last_virtual_method() {return 1;}\n-};\n-\n-template <class T> class CppVtableTesterA : public T {\n-public:\n-  virtual void* last_virtual_method() {\n-    \/\/ Make this different than CppVtableTesterB::last_virtual_method so the C++\n-    \/\/ compiler\/linker won't alias the two functions.\n-    return NULL;\n-  }\n-};\n-\n-template <class T>\n-int CppVtableCloner<T>::get_vtable_length(const char* name) {\n-  CppVtableTesterA<T> a;\n-  CppVtableTesterB<T> b;\n-\n-  intptr_t* avtable = vtable_of(&a);\n-  intptr_t* bvtable = vtable_of(&b);\n-\n-  \/\/ Start at slot 1, because slot 0 may be RTTI (on Solaris\/Sparc)\n-  int vtable_len = 1;\n-  for (; ; vtable_len++) {\n-    if (avtable[vtable_len] != bvtable[vtable_len]) {\n-      break;\n-    }\n-  }\n-  log_debug(cds, vtables)(\"Found   %3d vtable entries for %s\", vtable_len, name);\n-\n-  return vtable_len;\n-}\n-\n-#define ALLOC_CPP_VTABLE_CLONE(c) \\\n-  _cloned_cpp_vtptrs[c##_Kind] = CppVtableCloner<c>::allocate(#c); \\\n-  ArchivePtrMarker::mark_pointer(&_cloned_cpp_vtptrs[c##_Kind]);\n-\n-#define CLONE_CPP_VTABLE(c) \\\n-  p = CppVtableCloner<c>::clone_vtable(#c, (CppVtableInfo*)p);\n-\n-#define ZERO_CPP_VTABLE(c) \\\n- CppVtableCloner<c>::zero_vtable_clone();\n-\n-#define INIT_ORIG_CPP_VTPTRS(c) \\\n-  CppVtableCloner<c>::init_orig_cpp_vtptr(c##_Kind);\n-\n-#define DECLARE_CLONED_VTABLE_KIND(c) c ## _Kind,\n-\n-enum ClonedVtableKind {\n-  \/\/ E.g., ConstantPool_Kind == 0, InstanceKlass_Kind == 1, etc.\n-  CPP_VTABLE_PATCH_TYPES_DO(DECLARE_CLONED_VTABLE_KIND)\n-  _num_cloned_vtable_kinds\n-};\n-\n-\/\/ This is a map of all the original vtptrs. E.g., for\n-\/\/     ConstantPool *cp = new (...) ConstantPool(...) ; \/\/ a dynamically allocated constant pool\n-\/\/ the following holds true:\n-\/\/     _orig_cpp_vtptrs[ConstantPool_Kind] ==  ((intptr_t**)cp)[0]\n-static intptr_t* _orig_cpp_vtptrs[_num_cloned_vtable_kinds];\n-static bool _orig_cpp_vtptrs_inited = false;\n-\n-template <class T>\n-void CppVtableCloner<T>::init_orig_cpp_vtptr(int kind) {\n-  assert(kind < _num_cloned_vtable_kinds, \"sanity\");\n-  T tmp; \/\/ Allocate temporary dummy metadata object to get to the original vtable.\n-  intptr_t* srcvtable = vtable_of(&tmp);\n-  _orig_cpp_vtptrs[kind] = srcvtable;\n-}\n-\n-\/\/ This is the index of all the cloned vtables. E.g., for\n-\/\/     ConstantPool* cp = ....; \/\/ an archived constant pool\n-\/\/     InstanceKlass* ik = ....;\/\/ an archived class\n-\/\/ the following holds true:\n-\/\/     _cloned_cpp_vtptrs[ConstantPool_Kind]  == ((intptr_t**)cp)[0]\n-\/\/     _cloned_cpp_vtptrs[InstanceKlass_Kind] == ((intptr_t**)ik)[0]\n-static intptr_t** _cloned_cpp_vtptrs = NULL;\n-\n-void MetaspaceShared::allocate_cloned_cpp_vtptrs() {\n-  assert(DumpSharedSpaces, \"must\");\n-  size_t vtptrs_bytes = _num_cloned_vtable_kinds * sizeof(intptr_t*);\n-  _cloned_cpp_vtptrs = (intptr_t**)_mc_region.allocate(vtptrs_bytes, sizeof(intptr_t*));\n-}\n-\n-void MetaspaceShared::serialize_cloned_cpp_vtptrs(SerializeClosure* soc) {\n-  soc->do_ptr((void**)&_cloned_cpp_vtptrs);\n-}\n-\n-intptr_t* MetaspaceShared::get_archived_cpp_vtable(MetaspaceObj::Type msotype, address obj) {\n-  if (!_orig_cpp_vtptrs_inited) {\n-    CPP_VTABLE_PATCH_TYPES_DO(INIT_ORIG_CPP_VTPTRS);\n-    _orig_cpp_vtptrs_inited = true;\n-  }\n-\n-  Arguments::assert_is_dumping_archive();\n-  int kind = -1;\n-  switch (msotype) {\n-  case MetaspaceObj::SymbolType:\n-  case MetaspaceObj::TypeArrayU1Type:\n-  case MetaspaceObj::TypeArrayU2Type:\n-  case MetaspaceObj::TypeArrayU4Type:\n-  case MetaspaceObj::TypeArrayU8Type:\n-  case MetaspaceObj::TypeArrayOtherType:\n-  case MetaspaceObj::ConstMethodType:\n-  case MetaspaceObj::ConstantPoolCacheType:\n-  case MetaspaceObj::AnnotationsType:\n-  case MetaspaceObj::MethodCountersType:\n-  case MetaspaceObj::RecordComponentType:\n-    \/\/ These have no vtables.\n-    break;\n-  case MetaspaceObj::MethodDataType:\n-    \/\/ We don't archive MethodData <-- should have been removed in removed_unsharable_info\n-    ShouldNotReachHere();\n-    break;\n-  default:\n-    for (kind = 0; kind < _num_cloned_vtable_kinds; kind ++) {\n-      if (vtable_of((Metadata*)obj) == _orig_cpp_vtptrs[kind]) {\n-        break;\n-      }\n-    }\n-    if (kind >= _num_cloned_vtable_kinds) {\n-      fatal(\"Cannot find C++ vtable for \" INTPTR_FORMAT \" -- you probably added\"\n-            \" a new subtype of Klass or MetaData without updating CPP_VTABLE_PATCH_TYPES_DO\",\n-            p2i(obj));\n-    }\n-  }\n-\n-  if (kind >= 0) {\n-    assert(kind < _num_cloned_vtable_kinds, \"must be\");\n-    return _cloned_cpp_vtptrs[kind];\n-  } else {\n-    return NULL;\n-  }\n-}\n-\n-\/\/ This can be called at both dump time and run time:\n-\/\/ - clone the contents of the c++ vtables into the space\n-\/\/   allocated by allocate_cpp_vtable_clones()\n-void MetaspaceShared::clone_cpp_vtables(intptr_t* p) {\n-  assert(DumpSharedSpaces || UseSharedSpaces, \"sanity\");\n-  CPP_VTABLE_PATCH_TYPES_DO(CLONE_CPP_VTABLE);\n-}\n-\n-void MetaspaceShared::zero_cpp_vtable_clones_for_writing() {\n-  assert(DumpSharedSpaces, \"dump-time only\");\n-  CPP_VTABLE_PATCH_TYPES_DO(ZERO_CPP_VTABLE);\n-}\n-\n-\/\/ Allocate and initialize the C++ vtables, starting from top, but do not go past end.\n-char* MetaspaceShared::allocate_cpp_vtable_clones() {\n-  char* cloned_vtables = _mc_region.top(); \/\/ This is the beginning of all the cloned vtables\n-\n-  assert(DumpSharedSpaces, \"dump-time only\");\n-  \/\/ Layout (each slot is a intptr_t):\n-  \/\/   [number of slots in the first vtable = n1]\n-  \/\/   [ <n1> slots for the first vtable]\n-  \/\/   [number of slots in the first second = n2]\n-  \/\/   [ <n2> slots for the second vtable]\n-  \/\/   ...\n-  \/\/ The order of the vtables is the same as the CPP_VTAB_PATCH_TYPES_DO macro.\n-  CPP_VTABLE_PATCH_TYPES_DO(ALLOC_CPP_VTABLE_CLONE);\n-\n-  return cloned_vtables;\n-}\n-\n-bool MetaspaceShared::is_valid_shared_method(const Method* m) {\n-  assert(is_in_shared_metaspace(m), \"must be\");\n-  return CppVtableCloner<Method>::is_valid_shared_object(m);\n-}\n-\n@@ -1078,1 +783,1 @@\n-  MetaspaceShared::allocate_cloned_cpp_vtptrs();\n+  CppVtables::allocate_cloned_cpp_vtptrs();\n@@ -1080,1 +785,1 @@\n-  MetaspaceShared::allocate_cpp_vtable_clones();\n+  CppVtables::allocate_cpp_vtable_clones();\n@@ -1121,1 +826,1 @@\n-  MetaspaceShared::zero_cpp_vtable_clones_for_writing();\n+  CppVtables::zero_cpp_vtable_clones_for_writing();\n@@ -2029,1 +1734,1 @@\n-  clone_cpp_vtables((intptr_t*)buffer);\n+  CppVtables::clone_cpp_vtables((intptr_t*)buffer);\n","filename":"src\/hotspot\/share\/memory\/metaspaceShared.cpp","additions":6,"deletions":301,"binary":false,"changes":307,"status":"modified"},{"patch":"@@ -171,7 +171,0 @@\n-  static char* allocate_cpp_vtable_clones();\n-  static void clone_cpp_vtables(intptr_t* p);\n-  static void zero_cpp_vtable_clones_for_writing();\n-  static void patch_cpp_vtable_pointers();\n-  static void serialize_cloned_cpp_vtptrs(SerializeClosure* sc);\n-\n-  static bool is_valid_shared_method(const Method* m) NOT_CDS_RETURN_(false);\n@@ -255,2 +248,0 @@\n-  static void allocate_cloned_cpp_vtptrs();\n-  static intptr_t* get_archived_cpp_vtable(MetaspaceObj::Type msotype, address obj);\n","filename":"src\/hotspot\/share\/memory\/metaspaceShared.hpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+#include \"memory\/cppVtables.hpp\"\n@@ -2306,1 +2307,1 @@\n-    return MetaspaceShared::is_valid_shared_method(m);\n+    return CppVtables::is_valid_shared_method(m);\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"}]}