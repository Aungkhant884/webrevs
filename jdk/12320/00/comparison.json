{"files":[{"patch":"@@ -29,1 +29,0 @@\n-import java.util.concurrent.ConcurrentHashMap;\n@@ -36,0 +35,2 @@\n+import java.lang.invoke.VarHandle;\n+import java.lang.invoke.MethodHandles;\n@@ -367,1 +368,0 @@\n-        private final ConcurrentHashMap<ForEachOrderedTask<S, T>, ForEachOrderedTask<S, T>> completionMap;\n@@ -372,0 +372,12 @@\n+        @SuppressWarnings(\"unused\") private volatile ForEachOrderedTask<S, T> next; \/\/ Only accessed through the NEXT VarHandle\n+        private static final VarHandle NEXT;\n+        static {\n+            try {\n+                MethodHandles.Lookup l = MethodHandles.lookup();\n+                NEXT = l.findVarHandle(ForEachOrderedTask.class, \"next\", ForEachOrderedTask.class);\n+            } catch (Exception e) {\n+                throw new InternalError(e);\n+            }\n+        }\n+\n+\n@@ -379,2 +391,0 @@\n-            \/\/ Size map to avoid concurrent re-sizes\n-            this.completionMap = new ConcurrentHashMap<>(Math.max(16, AbstractTask.getLeafTarget() << 1));\n@@ -392,1 +402,0 @@\n-            this.completionMap = parent.completionMap;\n@@ -420,1 +429,3 @@\n-                task.completionMap.put(leftChild, rightChild);\n+                \/\/ leftChild and rightChild were just created and not fork():ed\n+                \/\/ yet so no need for a volatile write\n+                NEXT.set(leftChild, rightChild);\n@@ -436,1 +447,1 @@\n-                    if (task.completionMap.replace(task.leftPredecessor, task, leftChild)) {\n+                    if (NEXT.compareAndSet(task.leftPredecessor, task, leftChild)) {\n@@ -502,1 +513,2 @@\n-            ForEachOrderedTask<S, T> leftDescendant = completionMap.remove(this);\n+            @SuppressWarnings(\"unchecked\")\n+            var leftDescendant = (ForEachOrderedTask<S, T>)NEXT.getAndSet(this, null);\n","filename":"src\/java.base\/share\/classes\/java\/util\/stream\/ForEachOps.java","additions":20,"deletions":8,"binary":false,"changes":28,"status":"modified"}]}