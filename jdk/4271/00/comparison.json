{"files":[{"patch":"@@ -106,1 +106,1 @@\n-Node *SubTypeCheckNode::Ideal(PhaseGVN *phase, bool can_reshape) {\n+Node *SubTypeCheckNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n@@ -137,8 +137,1 @@\n-#ifdef ASSERT\n-      const Type* obj_t = phase->type(obj);\n-      if (!obj_t->isa_oopptr() && obj_t != Type::TOP) {\n-        obj->dump();\n-        obj_t->dump(); tty->cr();\n-        fatal(\"only for oop input\");\n-      }\n-#endif\n+      assert(is_oop(phase, obj), \"only for oop input\");\n@@ -153,8 +146,1 @@\n-#ifdef ASSERT\n-      const Type* obj_or_subklass_t = phase->type(obj_or_subklass);\n-      if (!obj_or_subklass_t->isa_oopptr() && obj_or_subklass_t != Type::TOP) {\n-        obj_or_subklass->dump();\n-        obj_or_subklass_t->dump(); tty->cr();\n-        fatal(\"only for oop input\");\n-      }\n-#endif\n+    assert(is_oop(phase, obj_or_subklass), \"only for oop input\");\n@@ -167,3 +153,1 @@\n-#ifdef ASSERT\n-  ciKlass* superk = super_t->is_klassptr()->klass();\n-  ciKlass* subk   = sub_t->isa_klassptr() ? sub_t->is_klassptr()->klass() : sub_t->is_oopptr()->klass();\n+  assert(verify(phase), \"missing Value() optimization\");\n@@ -171,13 +155,8 @@\n-  if (super_t->singleton() && subk != NULL && phase->C->static_subtype_check(superk, subk) == Compile::SSC_easy_test) {\n-    Node* subklass = NULL;\n-    if (sub_t->isa_oopptr()) {\n-      Node* adr = phase->transform(new AddPNode(obj_or_subklass, obj_or_subklass, phase->MakeConX(oopDesc::klass_offset_in_bytes())));\n-      subklass = phase->transform(LoadKlassNode::make(*phase, NULL, phase->C->immutable_memory(), adr, TypeInstPtr::KLASS));\n-    } else {\n-      subklass = obj_or_subklass;\n-    }\n-    Node* res = new CmpPNode(subklass, superklass);\n-    Node* cmp = phase->transform(res);\n-    const Type* t = phase->type(cmp);\n-    if (!((Value(phase) == t) || (t != TypeInt::CC_GT && t != TypeInt::CC_EQ))) {\n-      Value(phase)->dump(); tty->cr();\n+  return NULL;\n+}\n+\n+#ifdef ASSERT\n+bool SubTypeCheckNode::is_oop(PhaseGVN* phase, Node* n) {\n+    const Type* t = phase->type(n);\n+    if (!t->isa_oopptr() && t != Type::TOP) {\n+      n->dump();\n@@ -185,10 +164,1 @@\n-      obj_or_subklass->dump();\n-      subklass->dump();\n-      superklass->dump();\n-      cmp->dump();\n-      tty->print_cr(\"==============================\");\n-      phase->C->root()->dump(9999);\n-      fatal(\"missing Value() optimization\");\n-    }\n-    if (phase->is_IterGVN()) {\n-      phase->is_IterGVN()->_worklist.push(res);\n+      return false;\n@@ -196,1 +166,28 @@\n-    return NULL;\n+    return true;\n+}\n+\n+static Node* record_for_cleanup(Node* n, PhaseGVN* phase) {\n+  if (phase->is_IterGVN()) {\n+    phase->is_IterGVN()->_worklist.push(n); \/\/ record for cleanup\n+  }\n+  return n;\n+}\n+bool SubTypeCheckNode::verify_helper(PhaseGVN* phase, Node* subklass, const Type* cached_t) {\n+  Node* cmp = phase->transform(new CmpPNode(subklass, in(SuperKlass)));\n+  record_for_cleanup(cmp, phase);\n+\n+  const Type* cmp_t = phase->type(cmp);\n+  const Type* t = Value(phase);\n+\n+  if (t == cmp_t ||\n+      t != cached_t || \/\/ previous observations don't hold anymore\n+      (cmp_t != TypeInt::CC_GT && cmp_t != TypeInt::CC_EQ)) {\n+    return true;\n+  } else {\n+    t->dump(); tty->cr();\n+    this->dump(2); tty->cr();\n+    cmp_t->dump(); tty->cr();\n+    subklass->dump(2); tty->cr();\n+    tty->print_cr(\"==============================\");\n+    phase->C->root()->dump(9999);\n+    return false;\n@@ -198,0 +195,1 @@\n+}\n@@ -199,6 +197,5 @@\n-  Node *p1 = phase->transform(new AddPNode(superklass, superklass, phase->MakeConX(in_bytes(Klass::super_check_offset_offset()))));\n-  Node* m = phase->C->immutable_memory();\n-  LoadINode* chk_off_ld = new LoadINode(NULL, m, p1, phase->type(p1)->is_ptr(), TypeInt::INT, MemNode::unordered);\n-  Node *chk_off = phase->transform(chk_off_ld);\n-  int cacheoff_con = in_bytes(Klass::secondary_super_cache_offset());\n-  bool might_be_cache = (phase->find_int_con(chk_off, cacheoff_con) == cacheoff_con);\n+\/\/ Verify that optimizing the subtype check to a simple code pattern when possible would not constant fold better.\n+bool SubTypeCheckNode::verify(PhaseGVN* phase) {\n+  Compile* C = phase->C;\n+  Node* obj_or_subklass = in(ObjOrSubKlass);\n+  Node* superklass = in(SuperKlass);\n@@ -206,6 +203,2 @@\n-  if (might_be_cache) {\n-    if (phase->is_IterGVN()) {\n-      phase->is_IterGVN()->_worklist.push(chk_off_ld);\n-    }\n-    return NULL;\n-  }\n+  const Type* sub_t = phase->type(obj_or_subklass);\n+  const Type* super_t = phase->type(superklass);\n@@ -213,1 +206,4 @@\n-  if (super_t->singleton() && subk != NULL && phase->C->static_subtype_check(superk, subk) == Compile::SSC_full_test) {\n+  ciKlass* subk = sub_t->isa_klassptr() ? sub_t->is_klassptr()->klass() : sub_t->is_oopptr()->klass(); \/\/ can be NULL for bottom[]\n+  ciKlass* superk = super_t->is_klassptr()->klass();\n+\n+  if (super_t->singleton() && subk != NULL) {\n@@ -217,1 +213,2 @@\n-      subklass = phase->transform(LoadKlassNode::make(*phase, NULL, phase->C->immutable_memory(), adr, TypeInstPtr::KLASS));\n+      subklass  = phase->transform(LoadKlassNode::make(*phase, NULL, C->immutable_memory(), adr, TypeInstPtr::KLASS));\n+      record_for_cleanup(subklass, phase);\n@@ -222,1 +219,14 @@\n-    Node *chk_off_X = chk_off;\n+    const Type* cached_t = Value(phase); \/\/ cache the type to validate consistency\n+    switch (C->static_subtype_check(superk, subk)) {\n+      case Compile::SSC_easy_test: {\n+        return verify_helper(phase, subklass, cached_t);\n+      }\n+      case Compile::SSC_full_test: {\n+        Node* p1 = phase->transform(new AddPNode(superklass, superklass, phase->MakeConX(in_bytes(Klass::super_check_offset_offset()))));\n+        Node* chk_off = phase->transform(new LoadINode(NULL, C->immutable_memory(), p1, phase->type(p1)->is_ptr(), TypeInt::INT, MemNode::unordered));\n+        record_for_cleanup(chk_off, phase);\n+\n+        int cacheoff_con = in_bytes(Klass::secondary_super_cache_offset());\n+        bool might_be_cache = (phase->find_int_con(chk_off, cacheoff_con) == cacheoff_con);\n+        if (!might_be_cache) {\n+          Node* chk_off_X = chk_off;\n@@ -224,1 +234,1 @@\n-    chk_off_X = phase->transform(new ConvI2LNode(chk_off_X));\n+          chk_off_X = phase->transform(new ConvI2LNode(chk_off_X));\n@@ -226,21 +236,12 @@\n-    Node *p2 = phase->transform(new AddPNode(subklass,subklass,chk_off_X));\n-    Node *kmem = phase->C->immutable_memory();\n-    Node *nkls = phase->transform(LoadKlassNode::make(*phase, NULL, kmem, p2, phase->type(p2)->is_ptr(), TypeKlassPtr::OBJECT_OR_NULL));\n-\n-    Node* res = new CmpPNode(superklass, nkls);\n-    Node* cmp = phase->transform(res);\n-    const Type* t = phase->type(cmp);\n-    if (!((Value(phase) == t) || (t != TypeInt::CC_GT && t != TypeInt::CC_EQ))) {\n-      Value(phase)->dump(); tty->cr();\n-      t->dump(); tty->cr();\n-      obj_or_subklass->dump();\n-      subklass->dump();\n-      superklass->dump();\n-      nkls->dump();\n-      cmp->dump();\n-      tty->print_cr(\"==============================\");\n-      phase->C->root()->dump(9999);\n-      fatal(\"missing Value() optimization\");\n-    }\n-    if (phase->is_IterGVN()) {\n-      phase->is_IterGVN()->_worklist.push(res);\n+          Node* p2 = phase->transform(new AddPNode(subklass, subklass, chk_off_X));\n+          Node* nkls = phase->transform(LoadKlassNode::make(*phase, NULL, C->immutable_memory(), p2, phase->type(p2)->is_ptr(), TypeKlassPtr::OBJECT_OR_NULL));\n+\n+          return verify_helper(phase, nkls, cached_t);\n+        }\n+        break;\n+      }\n+      case Compile::SSC_always_false:\n+      case Compile::SSC_always_true:\n+      default: {\n+        break; \/\/ nothing to do\n+      }\n@@ -248,1 +249,0 @@\n-    return NULL;\n@@ -250,1 +250,0 @@\n-#endif\n@@ -252,1 +251,1 @@\n-  return NULL;\n+  return true;\n@@ -254,0 +253,1 @@\n+#endif\n","filename":"src\/hotspot\/share\/opto\/subtypenode.cpp","additions":84,"deletions":84,"binary":false,"changes":168,"status":"modified"},{"patch":"@@ -52,0 +52,8 @@\n+\n+#ifdef ASSERT\n+private:\n+  bool verify(PhaseGVN* phase);\n+  bool verify_helper(PhaseGVN* phase, Node* subklass, const Type* cached_t);\n+\n+  static bool is_oop(PhaseGVN* phase, Node* n);\n+#endif \/\/ ASSERT\n","filename":"src\/hotspot\/share\/opto\/subtypenode.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"}]}