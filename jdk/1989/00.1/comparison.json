{"files":[{"patch":"@@ -43,0 +43,1 @@\n+#include \"runtime\/stubRoutines.hpp\"\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_32.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"ci\/ciSymbols.hpp\"\n@@ -1480,1 +1481,1 @@\n-  if (method()->name() == ciSymbol::object_initializer_name() &&\n+  if (method()->name() == ciSymbols::object_initializer_name() &&\n@@ -3823,1 +3824,1 @@\n-    if (callee->name() == ciSymbol::object_initializer_name() &&\n+    if (callee->name() == ciSymbols::object_initializer_name() &&\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"ci\/ciSymbols.hpp\"\n@@ -945,1 +946,1 @@\n-   return name() == ciSymbol::object_initializer_name();\n+   return name() == ciSymbols::object_initializer_name();\n","filename":"src\/hotspot\/share\/ci\/ciMethod.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"classfile\/vmIntrinsics.hpp\"\n@@ -78,1 +79,1 @@\n-  vmIntrinsics::ID _intrinsic_id;\n+  vmIntrinsicID _intrinsic_id;\n@@ -184,1 +185,1 @@\n-  vmIntrinsics::ID intrinsic_id() const          { check_is_loaded(); return _intrinsic_id; }\n+  vmIntrinsicID intrinsic_id() const             { check_is_loaded(); return _intrinsic_id; }\n","filename":"src\/hotspot\/share\/ci\/ciMethod.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -138,0 +138,2 @@\n+#define JAVA_17_VERSION                   61\n+\n@@ -5303,2 +5305,1 @@\n-      for (vmIntrinsicsIterator it = vmIntrinsicsRange.begin(); it != vmIntrinsicsRange.end(); ++it) {\n-        vmIntrinsicID id = *it;\n+      for (auto id : EnumRange<vmIntrinsicID>{}) {\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -576,2 +576,1 @@\n-  for (vmIntrinsicsIterator it = vmIntrinsicsRange.begin(); it != vmIntrinsicsRange.end(); ++it) {\n-    vmIntrinsicID index = *it;\n+  for (auto index : EnumRange<vmIntrinsicID>{}) {\n@@ -604,2 +603,1 @@\n-  for (vmIntrinsicsIterator it = vmIntrinsicsRange.begin(); it != vmIntrinsicsRange.end(); ++it) {\n-    vmIntrinsicID index = *it;\n+  for (auto index : EnumRange<vmIntrinsicID>{}) {\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.cpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1044,2 +1044,0 @@\n-constexpr EnumRange<vmIntrinsicID> vmIntrinsicsRange; \/\/ the default range of all valid vmIntrinsicIDs\n-using vmIntrinsicsIterator = EnumIterator<vmIntrinsicID>; \/\/ convenience\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -725,2 +725,0 @@\n-constexpr EnumRange<vmSymbolID> vmSymbolsRange; \/\/ the default range of all valid vmSymbolIDs\n-using vmSymbolsIterator = EnumIterator<vmSymbolID>; \/\/ convenience\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"compiler\/compilerDirectives.hpp\"\n@@ -298,1 +299,1 @@\n-    \/\/ Print out the succesful registration of a comile command\n+    \/\/ Print out the successful registration of a compile command\n@@ -412,1 +413,14 @@\n-static enum CompileCommand parse_option_name(const char* line, int* bytes_read, char* errorbuf, int bufsize) {\n+bool CompilerOracle::should_blackhole(const methodHandle& method) {\n+  if (!check_predicate(CompileCommand::Blackhole, method)) {\n+    return false;\n+  }\n+  guarantee(UnlockDiagnosticVMOptions, \"Checked during initial parsing\");\n+  if (method->result_type() != T_VOID) {\n+    warning(\"Blackhole compile option only works for methods with void type: %s\",\n+            method->name_and_sig_as_C_string());\n+    return false;\n+  }\n+  return true;\n+}\n+\n+static enum CompileCommand match_option_name(const char* line, int* bytes_read, char* errorbuf, int bufsize) {\n@@ -429,0 +443,19 @@\n+\/\/ match exactly and don't mess with errorbuf\n+enum CompileCommand CompilerOracle::parse_option_name(const char* line) {\n+  for (uint i = 0; i < ARRAY_SIZE(option_names); i++) {\n+    if (strcasecmp(line, option_names[i]) == 0) {\n+      return static_cast<enum CompileCommand>(i);\n+    }\n+  }\n+  return CompileCommand::Unknown;\n+}\n+\n+enum OptionType CompilerOracle::parse_option_type(const char* type_str) {\n+  for (uint i = 0; i < ARRAY_SIZE(optiontype_names); i++) {\n+    if (strcasecmp(type_str, optiontype_names[i]) == 0) {\n+      return static_cast<enum OptionType>(i);\n+    }\n+  }\n+  return OptionType::Unknown;\n+}\n+\n@@ -573,0 +606,9 @@\n+\n+      if (option == CompileCommand::ControlIntrinsic || option == CompileCommand::DisableIntrinsic) {\n+        ControlIntrinsicValidator validator(value, (option == CompileCommand::DisableIntrinsic));\n+\n+        if (!validator.is_valid()) {\n+          jio_snprintf(errorbuf, buf_size, \"Unrecognized intrinsic detected in %s: %s\", option2name(option), validator.what());\n+        }\n+      }\n+\n@@ -638,1 +680,1 @@\n-    enum CompileCommand option = parse_option_name(option_buf, &bytes_read2, errorbuf, buf_size);\n+    enum CompileCommand option = match_option_name(option_buf, &bytes_read2, errorbuf, buf_size);\n@@ -667,9 +709,0 @@\n-enum OptionType parse_option_type(const char* type_str) {\n-  for (uint i = 0; i < ARRAY_SIZE(optiontype_names); i++) {\n-    if (strcasecmp(type_str, optiontype_names[i]) == 0) {\n-      return static_cast<enum OptionType>(i);\n-    }\n-  }\n-  return OptionType::Unknown;\n-}\n-\n@@ -698,1 +731,1 @@\n-  enum CompileCommand option = parse_option_name(line, &bytes_read, error_buf, sizeof(error_buf));\n+  enum CompileCommand option = match_option_name(line, &bytes_read, error_buf, sizeof(error_buf));\n@@ -759,1 +792,1 @@\n-        enum CompileCommand option = parse_option_name(option_type, &bytes_read, error_buf, sizeof(error_buf));\n+        enum CompileCommand option = match_option_name(option_type, &bytes_read, error_buf, sizeof(error_buf));\n@@ -976,1 +1009,1 @@\n-  return parse_option_name(name, &bytes_read, errorbuf, sizeof(errorbuf));\n+  return match_option_name(name, &bytes_read, errorbuf, sizeof(errorbuf));\n","filename":"src\/hotspot\/share\/compiler\/compilerOracle.cpp","additions":48,"deletions":15,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"runtime\/stubRoutines.hpp\"\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -237,2 +237,1 @@\n-  for (vmIntrinsicsIterator it = vmIntrinsicsRange.begin(); it != vmIntrinsicsRange.end(); ++it) {\n-    vmIntrinsicID id = *it;\n+  for (auto id : EnumRange<vmIntrinsicID>{}) {\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n-#include \"classfile\/vmSymbols.hpp\"\n+#include \"classfile\/vmIntrinsics.hpp\"\n@@ -58,0 +58,1 @@\n+#include \"runtime\/stubRoutines.hpp\"\n@@ -63,1 +64,1 @@\n-  vmIntrinsics::ID id = m->intrinsic_id();\n+  vmIntrinsicID id = m->intrinsic_id();\n@@ -92,1 +93,1 @@\n-                                (vmIntrinsics::ID) id);\n+                                id);\n@@ -672,1 +673,1 @@\n-    \/\/ to the list in vmSymbols.hpp without implementing it here.\n+    \/\/ to the list in vmIntrinsics.hpp without implementing it here.\n@@ -708,1 +709,1 @@\n-    \/\/ to the list in vmSymbols.hpp without implementing it here.\n+    \/\/ to the list in vmIntrinsics.hpp without implementing it here.\n@@ -3330,1 +3331,2 @@\n-    CallJavaNode* slow_call = generate_method_call_static(vmIntrinsics::_newArray);\n+    CallJavaNode* slow_call = uninitialized ? generate_method_call_virtual(vmIntrinsics::_allocateUninitializedArray) :\n+                                              generate_method_call_static(vmIntrinsics::_newArray);\n@@ -3587,2 +3589,1 @@\n-                           SharedRuntime::get_resolve_static_call_stub(),\n-                           method, bci());\n+                           SharedRuntime::get_resolve_static_call_stub(), method);\n@@ -3604,1 +3605,1 @@\n-                          method, vtable_index, bci());\n+                          method, vtable_index);\n@@ -3608,2 +3609,1 @@\n-                                SharedRuntime::get_resolve_opt_virtual_call_stub(),\n-                                method, bci());\n+                                SharedRuntime::get_resolve_opt_virtual_call_stub(), method);\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -571,1 +571,1 @@\n-                                           jvms->bci(), no_memory_effects);\n+                                           no_memory_effects);\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+#include \"gc\/shared\/tlab_globals.hpp\"\n@@ -3055,0 +3056,2 @@\n+  } else if (size > 2 && Matcher::match_rule_supported_vector(Op_ClearArray, 4, T_LONG)) {\n+    return NULL;\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"ci\/ciSymbols.hpp\"\n@@ -43,1 +44,1 @@\n-  ciField* fd1 = ik->get_field_by_name(ciSymbol::ETYPE_name(), ciSymbol::class_signature(), \/* is_static *\/ true);\n+  ciField* fd1 = ik->get_field_by_name(ciSymbols::ETYPE_name(), ciSymbols::class_signature(), \/* is_static *\/ true);\n@@ -50,1 +51,1 @@\n-  ciField* fd2 = ik->get_field_by_name(ciSymbol::VLENGTH_name(), ciSymbol::int_signature(), \/* is_static *\/ true);\n+  ciField* fd2 = ik->get_field_by_name(ciSymbols::VLENGTH_name(), ciSymbols::int_signature(), \/* is_static *\/ true);\n@@ -370,1 +371,1 @@\n-    Node* cnt = gvn().makecon(TypeInt::make(log2_int(step_val->get_con())));\n+    Node* cnt = gvn().makecon(TypeInt::make(log2i_exact(step_val->get_con())));\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+#include \"classfile\/vmSymbols.hpp\"\n@@ -962,1 +963,0 @@\n-  c2_nonstatic_field(MachCallJavaNode,         _bci,                                          int)                                   \\\n@@ -1403,0 +1403,1 @@\n+  declare_type(VtableBlob,               BufferBlob)                      \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -5357,1 +5357,1 @@\n-            checkSerialVersionUID(tree, c);\n+            checkSerialVersionUID(tree, c, env);\n@@ -5390,1 +5390,1 @@\n-        private void checkSerialVersionUID(JCClassDecl tree, ClassSymbol c) {\n+        private void checkSerialVersionUID(JCClassDecl tree, ClassSymbol c, Env<AttrContext> env) {\n@@ -5407,0 +5407,7 @@\n+            \/\/ Check if @SuppressWarnings(\"serial\") is an annotation of serialVersionUID.\n+            \/\/ See JDK-8231622 for more information.\n+            Lint lint = env.info.lint.augment(svuid);\n+            if (lint.isSuppressed(LintCategory.SERIAL)) {\n+                return;\n+            }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -278,1 +278,0 @@\n- -runtime\/ErrorHandling\/ErrorHandler.java \\\n@@ -341,0 +340,1 @@\n+ -runtime\/cds\/appcds\/MismatchedPathTriggerMemoryRelease.java \\\n","filename":"test\/hotspot\/jtreg\/TEST.groups","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}