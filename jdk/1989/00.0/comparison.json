{"files":[{"patch":"@@ -318,0 +318,6 @@\n+    off = additional_frame_bytes - ymm_bytes;\n+    \/\/ Restore upper half of YMM registers.\n+    for (int n = 0; n < num_xmm_regs; n++) {\n+      __ vinsertf128_high(as_XMMRegister(n), Address(rsp, n*16+off));\n+    }\n+\n@@ -323,6 +329,1 @@\n-      __ addptr(rsp, zmm_bytes);\n-    }\n-    \/\/ Restore upper half of YMM registers.\n-    for (int n = 0; n < num_xmm_regs; n++) {\n-      __ vinsertf128_high(as_XMMRegister(n), Address(rsp, n*16));\n-    __ addptr(rsp, ymm_bytes);\n+    __ addptr(rsp, additional_frame_bytes);\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_32.cpp","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -3419,1 +3419,1 @@\n-      callee->check_intrinsic_candidate()) {\n+      (CheckIntrinsics ? callee->intrinsic_candidate() : true)) {\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -159,4 +159,0 @@\n-\n-  if (CompilerOracle::should_blackhole(h_m)) {\n-    h_m->set_intrinsic_id(vmIntrinsics::_blackhole);\n-  }\n","filename":"src\/hotspot\/share\/ci\/ciMethod.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -205,9 +205,0 @@\n-  bool check_intrinsic_candidate() const {\n-    if (intrinsic_id() == vmIntrinsics::_blackhole) {\n-      \/\/ This is the intrinsic without an associated method, so no intrinsic_candidate\n-      \/\/ flag is set. The intrinsic is still correct.\n-      return true;\n-    }\n-    return (CheckIntrinsics ? intrinsic_candidate() : true);\n-  }\n-\n","filename":"src\/hotspot\/share\/ci\/ciMethod.hpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -5312,5 +5312,0 @@\n-        if (vmIntrinsics::_blackhole == id) {\n-          \/\/ The _blackhole intrinsic is a special marker. No explicit method\n-          \/\/ is defined for it.\n-          continue;\n-        }\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -154,1 +154,0 @@\n-  case vmIntrinsics::_blackhole:\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -537,3 +537,0 @@\n-  \/* special marker for blackholed methods: *\/                                                                          \\\n-  do_intrinsic(_blackhole,                java_lang_Object,       blackhole_name, star_name, F_S)                       \\\n-                                                                                                                        \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -286,1 +286,0 @@\n-  template(blackhole_name,                            \"<blackhole>\")  \/*fake name*\/               \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -290,5 +290,0 @@\n-  if (option == CompileCommand::Blackhole && !UnlockDiagnosticVMOptions) {\n-    warning(\"Blackhole compile option is diagnostic and must be enabled via -XX:+UnlockDiagnosticVMOptions\");\n-    return;\n-  }\n-\n","filename":"src\/hotspot\/share\/compiler\/compilerOracle.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -679,2 +679,0 @@\n-  case vmIntrinsics::_blackhole:\n-    break;\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3563,2 +3563,0 @@\n-  case Op_Blackhole:\n-    break;\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -114,1 +114,1 @@\n-  if (callee->check_intrinsic_candidate() &&\n+  if ((CheckIntrinsics ? callee->intrinsic_candidate() : true) &&\n@@ -671,3 +671,0 @@\n-  case vmIntrinsics::_blackhole:\n-    return inline_blackhole();\n-\n@@ -6854,30 +6851,0 @@\n-\n-\/\/------------------------------- inline_blackhole --------------------------------------\n-\/\/\n-\/\/ Make sure all arguments to this node are alive.\n-\/\/ This matches methods that were requested to be blackholed through compile commands.\n-\/\/\n-bool LibraryCallKit::inline_blackhole() {\n-  \/\/ To preserve the semantics of Java call, we need to null-check the receiver,\n-  \/\/ if present. Shortcut if receiver is unconditionally null.\n-  Node* receiver = NULL;\n-  bool has_receiver = !callee()->is_static();\n-  if (has_receiver) {\n-    receiver = null_check_receiver();\n-    if (stopped()) {\n-      return true;\n-    }\n-  }\n-\n-  \/\/ Bind call arguments as blackhole arguments to keep them alive\n-  Node* bh = insert_mem_bar(Op_Blackhole);\n-  if (has_receiver) {\n-    bh->add_req(receiver);\n-  }\n-  uint nargs = callee()->arg_size();\n-  for (uint i = has_receiver ? 1 : 0; i < nargs; i++) {\n-    bh->add_req(argument(i));\n-  }\n-\n-  return true;\n-}\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":1,"deletions":34,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -4971,0 +4971,1 @@\n+      Unique_Node_List worklist;\n@@ -4972,3 +4973,1 @@\n-      Node_List worklist;\n-\n-      Node *mem = n->in(MemNode::Memory);\n+      Node* mem = n->in(MemNode::Memory);\n@@ -4979,2 +4978,2 @@\n-      while(worklist.size() != 0 && LCA != early) {\n-        Node* s = worklist.pop();\n+      for (uint i = 0; i < worklist.size() && LCA != early; i++) {\n+        Node* s = worklist.at(i);\n@@ -4982,1 +4981,2 @@\n-            (s->is_CallStaticJava() && s->as_CallStaticJava()->uncommon_trap_request() != 0)) {\n+            (s->is_CallStaticJava() && s->as_CallStaticJava()->uncommon_trap_request() != 0) ||\n+            s->is_Phi()) {\n@@ -4990,1 +4990,1 @@\n-          Node *sctrl = has_ctrl(s) ? get_ctrl(s) : s->in(0);\n+          Node* sctrl = has_ctrl(s) ? get_ctrl(s) : s->in(0);\n@@ -5014,0 +5014,16 @@\n+      \/\/ For Phis only consider Region's inputs that were reached by following the memory edges\n+      if (LCA != early) {\n+        for (uint i = 0; i < worklist.size(); i++) {\n+          Node* s = worklist.at(i);\n+          if (s->is_Phi() && C->can_alias(s->adr_type(), load_alias_idx)) {\n+            Node* r = s->in(0);\n+            for (uint j = 1; j < s->req(); j++) {\n+              Node* in = s->in(j);\n+              Node* r_in = r->in(j);\n+              if (worklist.member(in) && is_dominator(early, r_in)) {\n+                LCA = dom_lca_for_get_late_ctrl(LCA, r_in, n);\n+              }\n+            }\n+          }\n+        }\n+      }\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":23,"deletions":7,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-#include \"opto\/regalloc.hpp\"\n@@ -3228,1 +3227,0 @@\n-  case Op_Blackhole:         return new BlackholeNode(C, atp, pn);\n@@ -3463,21 +3461,0 @@\n-#ifndef PRODUCT\n-void BlackholeNode::format(PhaseRegAlloc* ra, outputStream* st) const {\n-  st->print(\"blackhole \");\n-  bool first = true;\n-  for (uint i = 0; i < req(); i++) {\n-    Node* n = in(i);\n-    if (n != NULL && OptoReg::is_valid(ra->get_reg_first(n))) {\n-      if (first) {\n-        first = false;\n-      } else {\n-        st->print(\", \");\n-      }\n-      char buf[128];\n-      ra->dump_register(n, buf);\n-      st->print(\"%s\", buf);\n-    }\n-  }\n-  st->cr();\n-}\n-#endif\n-\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":0,"deletions":23,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -1439,1 +1439,1 @@\n-      int num_elem_for_resize = MAX2(num_elem_to, Matcher::min_vector_size(elem_bt_to));\n+      int num_elem_for_resize = MAX2(num_elem_to, Matcher::min_vector_size(elem_bt_from));\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1600,1 +1600,0 @@\n-  declare_c2_type(BlackholeNode, MemBarNode)                              \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -4003,1 +4003,1 @@\n-        BindingSymbol v = new BindingSymbol(tree.var.name, tree.var.vartype.type, env.info.scope.owner);\n+        BindingSymbol v = new BindingSymbol(tree.var.mods.flags, tree.var.name, tree.var.vartype.type, env.info.scope.owner);\n@@ -4009,0 +4009,1 @@\n+        annotate.annotateLater(tree.var.mods.annotations, env, v, tree.pos());\n@@ -5771,1 +5772,1 @@\n-                that.var.sym = new BindingSymbol(that.var.name, that.var.type, syms.noSymbol);\n+                that.var.sym = new BindingSymbol(0, that.var.name, that.var.type, syms.noSymbol);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -100,1 +100,0 @@\n-  compiler\/blackhole\/ \\\n","filename":"test\/hotspot\/jtreg\/TEST.groups","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}