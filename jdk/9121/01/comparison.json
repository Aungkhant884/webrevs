{"files":[{"patch":"@@ -3905,6 +3905,6 @@\n-        long bits = Double.doubleToLongBits(m00);\n-        bits = bits * 31 + Double.doubleToLongBits(m01);\n-        bits = bits * 31 + Double.doubleToLongBits(m02);\n-        bits = bits * 31 + Double.doubleToLongBits(m10);\n-        bits = bits * 31 + Double.doubleToLongBits(m11);\n-        bits = bits * 31 + Double.doubleToLongBits(m12);\n+        long bits = hash(m00);\n+        bits = bits * 31 + hash(m01);\n+        bits = bits * 31 + hash(m02);\n+        bits = bits * 31 + hash(m10);\n+        bits = bits * 31 + hash(m11);\n+        bits = bits * 31 + hash(m12);\n@@ -3914,0 +3914,10 @@\n+    \/**\n+     * Returns a hash code for the given value, with negative zero\n+     * collapsed to the single positive zero.\n+     *\/\n+    private static long hash(double m) {\n+        long h = Double.doubleToLongBits(m);\n+        if (h == 0x8000000000000000L) h = 0;    \/\/ Replace -0 by +0.\n+        return h;\n+    }\n+\n@@ -3931,2 +3941,11 @@\n-        return ((m00 == a.m00) && (m01 == a.m01) && (m02 == a.m02) &&\n-                (m10 == a.m10) && (m11 == a.m11) && (m12 == a.m12));\n+        return equals(m00, a.m00) && equals(m01, a.m01) &&\n+               equals(m02, a.m02) && equals(m10, a.m10) &&\n+               equals(m11, a.m11) && equals(m12, a.m12);\n+    }\n+\n+    \/**\n+     * Compares the given floating point values, with negative zero\n+     * considered equals to positive zero.\n+     *\/\n+    private static boolean equals(double a, double b) {\n+        return (a == b) || (Double.isNaN(a) && Double.isNaN(b));\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/geom\/AffineTransform.java","additions":27,"deletions":8,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -0,0 +1,81 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @summary Tests that equals(Object) is consistent with hashCode(),\n+ *          in particular regarding negative versus positive zeros and\n+ *          NaN values.\n+ *\/\n+\n+import java.awt.geom.AffineTransform;\n+\n+public class EqualsAndHashCode {\n+    private static boolean failed;\n+\n+    public static void main(String arg[]) {\n+        checkReflexiveEquals();\n+        checkZeros();\n+        checkNotEqual();\n+        if (failed) {\n+            throw new RuntimeException(\"Some tests failed.\");\n+        }\n+    }\n+\n+    private static void checkReflexiveEquals() {\n+        AffineTransform t = new AffineTransform(1, 0, 0, 1, Double.NaN, 0);\n+        if (!t.equals(t)) {\n+            System.err.println(\"Transform should be equal to itself.\");\n+            failed = true;\n+        }\n+        if (!t.equals(t.clone())) {\n+            System.err.println(\"Transform should be equal to its clone.\");\n+            failed = true;\n+        }\n+    }\n+\n+    private static void checkZeros() {\n+        AffineTransform positive = new AffineTransform(2, 0, 0, 3, 0, +0.0);\n+        AffineTransform negative = new AffineTransform(2, 0, 0, 3, 0, -0.0);\n+        if (!positive.equals(negative)) {\n+            System.err.println(\"Transforms should be equal despite the sign difference in zero values.\");\n+            failed = true;\n+        } else if (positive.hashCode() != negative.hashCode()) {\n+            System.err.println(\"Equal transforms should have the same hash code value.\");\n+            failed = true;\n+        }\n+    }\n+\n+    private static void checkNotEqual() {\n+        AffineTransform t1 = new AffineTransform(2, 0, 0, 3, 2, 0);\n+        AffineTransform t2 = new AffineTransform(2, 0, 0, 3, 2, 4);\n+        if (t1.equals(t2)) {\n+            System.err.println(\"Expected non-equal transforms.\");\n+            failed = true;\n+        }\n+        if (t1.hashCode() == t2.hashCode()) {\n+            System.err.println(\"Expected different hash codes.\");\n+            failed = true;\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/geom\/AffineTransform\/EqualsAndHashCode.java","additions":81,"deletions":0,"binary":false,"changes":81,"status":"added"}]}