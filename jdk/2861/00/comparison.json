{"files":[{"patch":"@@ -243,9 +243,0 @@\n-size_t SharedRuntime::trampoline_size() {\n-  return 16;\n-}\n-\n-void SharedRuntime::generate_trampoline(MacroAssembler *masm, address destination) {\n-  __ mov(rscratch1, destination);\n-  __ br(rscratch1);\n-}\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -254,10 +254,0 @@\n-size_t SharedRuntime::trampoline_size() {\n-  return 16;\n-}\n-\n-void SharedRuntime::generate_trampoline(MacroAssembler *masm, address destination) {\n-  InlinedAddress dest(destination);\n-  __ indirect_jump(dest, Rtemp);\n-  __ bind_literal(dest);\n-}\n-\n","filename":"src\/hotspot\/cpu\/arm\/sharedRuntime_arm.cpp","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -567,11 +567,0 @@\n-size_t SharedRuntime::trampoline_size() {\n-  return Assembler::load_const_size + 8;\n-}\n-\n-void SharedRuntime::generate_trampoline(MacroAssembler *masm, address destination) {\n-  Register Rtemp = R12;\n-  __ load_const(Rtemp, destination);\n-  __ mtctr(Rtemp);\n-  __ bctr();\n-}\n-\n","filename":"src\/hotspot\/cpu\/ppc\/sharedRuntime_ppc.cpp","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -559,10 +559,0 @@\n-size_t SharedRuntime::trampoline_size() {\n-  return MacroAssembler::load_const_size() + 2;\n-}\n-\n-void SharedRuntime::generate_trampoline(MacroAssembler *masm, address destination) {\n-  \/\/ Think about using pc-relative branch.\n-  __ load_const(Z_R1_scratch, destination);\n-  __ z_br(Z_R1_scratch);\n-}\n-\n","filename":"src\/hotspot\/cpu\/s390\/sharedRuntime_s390.cpp","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -374,8 +374,0 @@\n-size_t SharedRuntime::trampoline_size() {\n-  return 16;\n-}\n-\n-void SharedRuntime::generate_trampoline(MacroAssembler *masm, address destination) {\n-  __ jump(RuntimeAddress(destination));\n-}\n-\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_32.cpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -426,8 +426,0 @@\n-size_t SharedRuntime::trampoline_size() {\n-  return 16;\n-}\n-\n-void SharedRuntime::generate_trampoline(MacroAssembler *masm, address destination) {\n-  __ jump(RuntimeAddress(destination));\n-}\n-\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -122,10 +122,0 @@\n-size_t SharedRuntime::trampoline_size() {\n-  ShouldNotCallThis();\n-  return 0;\n-}\n-\n-void SharedRuntime::generate_trampoline(MacroAssembler *masm, address destination) {\n-  ShouldNotCallThis();\n-  return;\n-}\n-\n","filename":"src\/hotspot\/cpu\/zero\/sharedRuntime_zero.cpp","additions":1,"deletions":11,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -70,6 +70,0 @@\n-    if (MetaspaceShared::is_in_trampoline_frame(addr)) {\n-      \/\/ In the middle of a trampoline call. Bail out for safety.\n-      \/\/ This happens rarely so shouldn't affect profiling.\n-      return false;\n-    }\n-\n","filename":"src\/hotspot\/os_cpu\/bsd_x86\/thread_bsd_x86.cpp","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -71,6 +71,0 @@\n-    if (MetaspaceShared::is_in_trampoline_frame(addr)) {\n-      \/\/ In the middle of a trampoline call. Bail out for safety.\n-      \/\/ This happens rarely so shouldn't affect profiling.\n-      return false;\n-    }\n-\n","filename":"src\/hotspot\/os_cpu\/linux_aarch64\/thread_linux_aarch64.cpp","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -104,6 +104,0 @@\n-    if (MetaspaceShared::is_in_trampoline_frame(addr)) {\n-      \/\/ In the middle of a trampoline call. Bail out for safety.\n-      \/\/ This happens rarely so shouldn't affect profiling.\n-      return false;\n-    }\n-\n","filename":"src\/hotspot\/os_cpu\/linux_arm\/thread_linux_arm.cpp","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -71,6 +71,0 @@\n-    if (MetaspaceShared::is_in_trampoline_frame(addr)) {\n-      \/\/ In the middle of a trampoline call. Bail out for safety.\n-      \/\/ This happens rarely so shouldn't affect profiling.\n-      return false;\n-    }\n-\n","filename":"src\/hotspot\/os_cpu\/linux_x86\/thread_linux_x86.cpp","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -72,6 +72,0 @@\n-    if (MetaspaceShared::is_in_trampoline_frame(ret_frame.pc())) {\n-      \/\/ In the middle of a trampoline call. Bail out for safety.\n-      \/\/ This happens rarely so shouldn't affect profiling.\n-      return false;\n-    }\n-\n","filename":"src\/hotspot\/os_cpu\/windows_aarch64\/thread_windows_aarch64.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -67,6 +67,0 @@\n-    if (MetaspaceShared::is_in_trampoline_frame(ret_frame.pc())) {\n-      \/\/ In the middle of a trampoline call. Bail out for safety.\n-      \/\/ This happens rarely so shouldn't affect profiling.\n-      return false;\n-    }\n-\n","filename":"src\/hotspot\/os_cpu\/windows_x86\/thread_windows_x86.cpp","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-#define NUM_CDS_REGIONS 8 \/\/ this must be the same as MetaspaceShared::n_regions\n+#define NUM_CDS_REGIONS 7 \/\/ this must be the same as MetaspaceShared::n_regions\n@@ -47,1 +47,1 @@\n-  int     _is_bitmap_region;  \/\/ Relocation bitmap for RO\/RW\/MC\/MD regions (used by SA and debug build).\n+  int     _is_bitmap_region;  \/\/ Relocation bitmap for RO\/RW regions (used by SA and debug build).\n","filename":"src\/hotspot\/share\/include\/cds.h","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -95,1 +95,0 @@\n-address    AbstractInterpreter::_cds_entry_table        [AbstractInterpreter::number_of_method_entries];\n@@ -203,36 +202,0 @@\n-#if INCLUDE_CDS\n-\n-\/\/ For a shared Method m, to improve sharing across processes, we avoid writing to m->_i2i_entry\n-\/\/ at runtime. Instead, m->_i2i_entry points to a fixed location inside the CDS archive.\n-\/\/ This location contains a trampoline (generated by generate_entry_for_cds_method)\n-\/\/ which jumps to _entry_table[kind].\n-address AbstractInterpreter::entry_for_cds_method(const methodHandle& m) {\n-  MethodKind kind = method_kind(m);\n-  assert(0 <= kind && kind < number_of_method_entries, \"illegal kind\");\n-  return entry_for_cds_method(kind);\n-}\n-\n-address AbstractInterpreter::entry_for_cds_method(AbstractInterpreter::MethodKind kind) {\n-  const size_t trampoline_size = SharedRuntime::trampoline_size();\n-  address addr = MetaspaceShared::i2i_entry_code_buffers();\n-  addr += (size_t)(kind) * trampoline_size;\n-\n-  return addr;\n-}\n-\n-void AbstractInterpreter::generate_entry_for_cds_method(AbstractInterpreter::MethodKind kind) {\n-  if (UseSharedSpaces) {\n-    address trampoline = entry_for_cds_method(kind);\n-    CodeBuffer buffer(trampoline, (int)(SharedRuntime::trampoline_size()));\n-    MacroAssembler _masm(&buffer);\n-    SharedRuntime::generate_trampoline(&_masm, _entry_table[kind]);\n-    _masm.flush();\n-\n-    if (PrintInterpreter) {\n-      Disassembler::decode(buffer.insts_begin(), buffer.insts_end());\n-    }\n-  }\n-}\n-\n-#endif\n-\n@@ -244,2 +207,0 @@\n-\n-  generate_entry_for_cds_method(kind);\n@@ -482,1 +443,0 @@\n-    Interpreter::generate_entry_for_cds_method(kind);\n","filename":"src\/hotspot\/share\/interpreter\/abstractInterpreter.cpp","additions":1,"deletions":41,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -119,1 +119,0 @@\n-  static address    _cds_entry_table[number_of_method_entries]; \/\/ entry points for methods in the CDS archive\n@@ -139,5 +138,0 @@\n-  \/\/ used by class data sharing\n-  static address    entry_for_cds_method(const methodHandle& m) NOT_CDS_RETURN_(NULL);\n-  static address    entry_for_cds_method(AbstractInterpreter::MethodKind kind) NOT_CDS_RETURN_(NULL);\n-  static void       generate_entry_for_cds_method(MethodKind kind) NOT_CDS_RETURN;\n-\n","filename":"src\/hotspot\/share\/interpreter\/abstractInterpreter.hpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -184,1 +184,0 @@\n-    Interpreter::generate_entry_for_cds_method(Interpreter::kind); \\\n","filename":"src\/hotspot\/share\/interpreter\/templateInterpreterGenerator.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -52,20 +52,0 @@\n-class AdapterHandlerEntry;\n-\n-class MethodTrampolineInfo {\n-  address _c2i_entry_trampoline;\n-  AdapterHandlerEntry** _adapter_trampoline;\n-public:\n-  address c2i_entry_trampoline() { return _c2i_entry_trampoline; }\n-  AdapterHandlerEntry** adapter_trampoline() { return _adapter_trampoline; }\n-  void set_c2i_entry_trampoline(address addr) { _c2i_entry_trampoline = addr; }\n-  void set_adapter_trampoline(AdapterHandlerEntry** entry) { _adapter_trampoline = entry; }\n-};\n-\n-class AdapterToTrampoline : public ResourceHashtable<\n-  AdapterHandlerEntry*, MethodTrampolineInfo,\n-  primitive_hash<AdapterHandlerEntry*>,\n-  primitive_equals<AdapterHandlerEntry*>,\n-  941, \/\/ prime number\n-  ResourceObj::C_HEAP> {};\n-\n-static AdapterToTrampoline* _adapter_to_trampoline = NULL;\n@@ -177,1 +157,0 @@\n-  _mc_region(\"mc\", MAX_SHARED_DELTA),\n@@ -189,2 +168,1 @@\n-  _estimated_hashtable_bytes(0),\n-  _estimated_trampoline_bytes(0)\n+  _estimated_hashtable_bytes(0)\n@@ -346,2 +324,0 @@\n-  _estimated_trampoline_bytes = collect_method_trampolines();\n-\n@@ -352,1 +328,0 @@\n-  total += _estimated_trampoline_bytes;\n@@ -360,1 +335,0 @@\n-  log_info(cds)(\"_estimated_trampoline_bytes = \" SIZE_FORMAT, _estimated_trampoline_bytes);\n@@ -383,1 +357,1 @@\n-  _current_dump_space = &_mc_region;\n+  _current_dump_space = &_rw_region;\n@@ -424,0 +398,6 @@\n+  if (DumpSharedSpaces) {\n+    \/\/ We don't want any valid object to be at the very bottom of the archive.\n+    \/\/ See ArchivePtrMarker::mark_pointer().\n+    rw_region()->allocate(16);\n+  }\n+\n@@ -602,1 +582,1 @@\n-void ArchiveBuilder::dump_rw_region() {\n+void ArchiveBuilder::dump_rw_metadata() {\n@@ -605,1 +585,0 @@\n-  start_dump_space(&_rw_region);\n@@ -618,1 +597,1 @@\n-void ArchiveBuilder::dump_ro_region() {\n+void ArchiveBuilder::dump_ro_metadata() {\n@@ -851,3 +830,7 @@\n-        assert(_builder->is_in_buffer_space(*p), \"old pointer must point inside buffer space\");\n-        *p += _buffer_to_requested_delta;\n-        assert(_builder->is_in_requested_static_archive(*p), \"new pointer must point inside requested archive\");\n+        if (!_builder->is_in_buffer_space(*p)) {\n+          tty->print_cr(\"ohashii %p %p\", p, *p);\n+        } else {\n+          assert(_builder->is_in_buffer_space(*p), \"old pointer must point inside buffer space\");\n+          *p += _buffer_to_requested_delta;\n+          assert(_builder->is_in_requested_static_archive(*p), \"new pointer must point inside requested archive\");\n+        }\n@@ -1048,1 +1031,0 @@\n-    DumpRegion* mc_region = &builder->_mc_region;\n@@ -1052,5 +1034,0 @@\n-    address mc = address(mc_region->base());\n-    address mc_end = address(mc_region->end());\n-    write_dump_region(\"mc region\", mc_region);\n-    write_data(mc, mc_end, mc + buffer_to_runtime_delta());\n-\n@@ -1079,1 +1056,1 @@\n-  _alloc_stats.print_stats(int(_ro_region.used()), int(_rw_region.used()), int(_mc_region.used()));\n+  _alloc_stats.print_stats(int(_ro_region.used()), int(_rw_region.used()));\n@@ -1087,100 +1064,0 @@\n-void ArchiveBuilder::init_mc_region() {\n-  if (DumpSharedSpaces) { \/\/ these are needed only for static archive\n-    \/\/ We don't want any valid object to be at the very bottom of the archive.\n-    \/\/ See ArchivePtrMarker::mark_pointer().\n-    mc_region()->allocate(16);\n-\n-    size_t trampoline_size = SharedRuntime::trampoline_size();\n-    size_t buf_size = (size_t)AbstractInterpreter::number_of_method_entries * trampoline_size;\n-    MetaspaceShared::set_i2i_entry_code_buffers((address)mc_region()->allocate(buf_size));\n-  }\n-\n-  allocate_method_trampolines();\n-}\n-\n-void ArchiveBuilder::allocate_method_trampolines_for(InstanceKlass* ik) {\n-  if (ik->methods() != NULL) {\n-    for (int j = 0; j < ik->methods()->length(); j++) {\n-      \/\/ Walk the methods in a deterministic order so that the trampolines are\n-      \/\/ created in a deterministic order.\n-      Method* m = ik->methods()->at(j);\n-      AdapterHandlerEntry* ent = m->adapter(); \/\/ different methods can share the same AdapterHandlerEntry\n-      MethodTrampolineInfo* info = _adapter_to_trampoline->get(ent);\n-      if (info->c2i_entry_trampoline() == NULL) {\n-        info->set_c2i_entry_trampoline(\n-          (address)mc_region()->allocate(SharedRuntime::trampoline_size()));\n-        info->set_adapter_trampoline(\n-          (AdapterHandlerEntry**)mc_region()->allocate(sizeof(AdapterHandlerEntry*)));\n-      }\n-    }\n-  }\n-}\n-\n-void ArchiveBuilder::allocate_method_trampolines() {\n-  for (int i = 0; i < _klasses->length(); i++) {\n-    Klass* k = _klasses->at(i);\n-    if (k->is_instance_klass()) {\n-      InstanceKlass* ik = InstanceKlass::cast(k);\n-      allocate_method_trampolines_for(ik);\n-    }\n-  }\n-}\n-\n-\/\/ Allocate MethodTrampolineInfo for all Methods that will be archived. Also\n-\/\/ return the total number of bytes needed by the method trampolines in the MC\n-\/\/ region.\n-size_t ArchiveBuilder::collect_method_trampolines() {\n-  size_t total = 0;\n-  size_t each_method_bytes =\n-    align_up(SharedRuntime::trampoline_size(), BytesPerWord) +\n-    align_up(sizeof(AdapterHandlerEntry*), BytesPerWord);\n-\n-  if (_adapter_to_trampoline == NULL) {\n-    _adapter_to_trampoline = new (ResourceObj::C_HEAP, mtClass)AdapterToTrampoline();\n-  }\n-  int count = 0;\n-  for (int i = 0; i < _klasses->length(); i++) {\n-    Klass* k = _klasses->at(i);\n-    if (k->is_instance_klass()) {\n-      InstanceKlass* ik = InstanceKlass::cast(k);\n-      if (ik->methods() != NULL) {\n-        for (int j = 0; j < ik->methods()->length(); j++) {\n-          Method* m = ik->methods()->at(j);\n-          AdapterHandlerEntry* ent = m->adapter(); \/\/ different methods can share the same AdapterHandlerEntry\n-          bool is_created = false;\n-          MethodTrampolineInfo* info = _adapter_to_trampoline->put_if_absent(ent, &is_created);\n-          if (is_created) {\n-            count++;\n-          }\n-        }\n-      }\n-    }\n-  }\n-  if (count == 0) {\n-    \/\/ We have nothing to archive, but let's avoid having an empty region.\n-    total = SharedRuntime::trampoline_size();\n-  } else {\n-    total = count * each_method_bytes;\n-  }\n-  return align_up(total, SharedSpaceObjectAlignment);\n-}\n-\n-void ArchiveBuilder::update_method_trampolines() {\n-  for (int i = 0; i < klasses()->length(); i++) {\n-    Klass* k = klasses()->at(i);\n-    if (k->is_instance_klass()) {\n-      InstanceKlass* ik = InstanceKlass::cast(k);\n-      Array<Method*>* methods = ik->methods();\n-      for (int j = 0; j < methods->length(); j++) {\n-        Method* m = methods->at(j);\n-        AdapterHandlerEntry* ent = m->adapter();\n-        MethodTrampolineInfo* info = _adapter_to_trampoline->get(ent);\n-        \/\/ m is the \"copy\" of the original Method, but its adapter() field is still valid because\n-        \/\/ we haven't called make_klasses_shareable() yet.\n-        m->set_from_compiled_entry(info->c2i_entry_trampoline());\n-        m->set_adapter_trampoline(info->adapter_trampoline());\n-      }\n-    }\n-  }\n-}\n-\n@@ -1196,3 +1073,0 @@\n-  \/\/ mc contains the trampoline code for method entries, which are patched at run time,\n-  \/\/ so it needs to be read\/write.\n-  write_region(mapinfo, MetaspaceShared::mc, &_mc_region, \/*read_only=*\/false,\/*allow_exec=*\/true);\n@@ -1248,1 +1122,0 @@\n-                                _mc_region.reserved()  +\n@@ -1253,1 +1126,0 @@\n-                             _mc_region.used()  +\n@@ -1259,1 +1131,0 @@\n-  _mc_region.print(total_reserved);\n@@ -1295,1 +1166,0 @@\n-  _mc_region.print_out_of_space_msg(name, needed_bytes);\n","filename":"src\/hotspot\/share\/memory\/archiveBuilder.cpp","additions":18,"deletions":148,"binary":false,"changes":166,"status":"modified"},{"patch":"@@ -54,4 +54,2 @@\n-\/\/ [3] Copy contents of the 3 \"core\" regions (mc\/rw\/ro) into the output buffer.\n-\/\/       - mc region:\n-\/\/         allocate_method_trampolines();\n-\/\/         allocate the cpp vtables (static dump only)\n+\/\/ [3] Copy contents of the 2 \"core\" regions (rw\/ro) into the output buffer.\n+\/\/       - allocate the cpp vtables in rw (static dump only)\n@@ -64,1 +62,1 @@\n-\/\/ [5] Relocate all the pointers in mc\/rw\/ro, so that the archive can be mapped to\n+\/\/ [5] Relocate all the pointers in rw\/ro, so that the archive can be mapped to\n@@ -69,1 +67,1 @@\n-  address _buffer_bottom;                      \/\/ for writing the contents of mc\/rw\/ro regions\n+  address _buffer_bottom;                      \/\/ for writing the contents of rw\/ro regions\n@@ -198,1 +196,0 @@\n-  DumpRegion _mc_region;\n@@ -266,1 +263,0 @@\n-  size_t _estimated_trampoline_bytes;    \/\/ method entry trampolines\n@@ -268,1 +264,1 @@\n-  static const int _total_dump_regions = 3;\n+  static const int _total_dump_regions = 2;\n@@ -351,1 +347,0 @@\n-  DumpRegion* mc_region() { return &_mc_region; }\n@@ -355,3 +350,0 @@\n-  static char* mc_region_alloc(size_t num_bytes) {\n-    return current()->mc_region()->allocate(num_bytes);\n-  }\n@@ -387,3 +379,2 @@\n-  void init_mc_region();\n-  void dump_rw_region();\n-  void dump_ro_region();\n+  void dump_rw_metadata();\n+  void dump_ro_metadata();\n@@ -445,6 +436,0 @@\n-\n-  \/\/ Method trampolines related functions\n-  size_t collect_method_trampolines();\n-  void allocate_method_trampolines();\n-  void allocate_method_trampolines_for(InstanceKlass* ik);\n-  void update_method_trampolines();\n","filename":"src\/hotspot\/share\/memory\/archiveBuilder.hpp","additions":7,"deletions":22,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -104,1 +104,1 @@\n-      (CppVtableInfo*)ArchiveBuilder::current()->mc_region()->allocate(CppVtableInfo::byte_size(n));\n+      (CppVtableInfo*)ArchiveBuilder::current()->rw_region()->allocate(CppVtableInfo::byte_size(n));\n@@ -218,1 +218,1 @@\n-  _index = (CppVtableInfo**)ArchiveBuilder::current()->mc_region()->allocate(vtptrs_bytes);\n+  _index = (CppVtableInfo**)ArchiveBuilder::current()->rw_region()->allocate(vtptrs_bytes);\n","filename":"src\/hotspot\/share\/memory\/cppVtables.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-void DumpAllocStats::print_stats(int ro_all, int rw_all, int mc_all) {\n+void DumpAllocStats::print_stats(int ro_all, int rw_all) {\n@@ -45,4 +45,0 @@\n-  \/\/ TODO: count things like dictionary, vtable, etc\n-  _bytes[RW][OtherType] += mc_all;\n-  rw_all += mc_all; \/\/ mc is mapped Read\/Write\n-\n@@ -69,1 +65,1 @@\n-  msg.debug(\"Detailed metadata info (excluding heap regions; rw stats include mc regions):\");\n+  msg.debug(\"Detailed metadata info (excluding heap regions):\");\n@@ -110,1 +106,1 @@\n-  assert(all_rw_bytes == rw_all, \"everything should have been counted\");\n+\/\/assert(all_rw_bytes == rw_all, \"everything should have been counted\"); FIXME!\n","filename":"src\/hotspot\/share\/memory\/dumpAllocStats.cpp","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -94,1 +94,1 @@\n-  void print_stats(int ro_all, int rw_all, int mc_all);\n+  void print_stats(int ro_all, int rw_all);\n","filename":"src\/hotspot\/share\/memory\/dumpAllocStats.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -119,3 +119,0 @@\n-    init_mc_region();\n-    verify_estimate_size(_estimated_trampoline_bytes, \"Trampolines\");\n-\n@@ -124,2 +121,2 @@\n-    dump_rw_region();\n-    dump_ro_region();\n+    dump_rw_metadata();\n+    dump_ro_metadata();\n@@ -151,1 +148,0 @@\n-    update_method_trampolines();\n","filename":"src\/hotspot\/share\/memory\/dynamicArchive.cpp","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -283,1 +283,0 @@\n-  st->print_cr(\"- i2i_entry_code_buffers_offset:  \" SIZE_FORMAT_HEX, _i2i_entry_code_buffers_offset);\n@@ -1274,1 +1273,1 @@\n-    \"mc\", \"rw\", \"ro\", \"bm\", \"ca0\", \"ca1\", \"oa0\", \"oa1\"\n+    \"rw\", \"ro\", \"bm\", \"ca0\", \"ca1\", \"oa0\", \"oa1\"\n@@ -1535,1 +1534,1 @@\n-static const char* shared_region_name[] = { \"MiscCode\", \"ReadWrite\", \"ReadOnly\", \"Bitmap\",\n+static const char* shared_region_name[] = { \"ReadWrite\", \"ReadOnly\", \"Bitmap\",\n@@ -1680,1 +1679,1 @@\n-\/\/ We relocate all pointers in the 3 core regions (mc, ro, rw).\n+\/\/ We relocate all pointers in the 2 core regions (ro, rw).\n@@ -2175,1 +2174,1 @@\n-\/\/ The 3 core spaces are MC->RW->RO\n+\/\/ The 2 core spaces are RW->RO\n@@ -2177,1 +2176,1 @@\n-  return space_at(MetaspaceShared::mc);\n+  return space_at(MetaspaceShared::rw);\n@@ -2283,2 +2282,1 @@\n-         idx == MetaspaceShared::rw ||\n-         idx == MetaspaceShared::mc, \"invalid region index\");\n+         idx == MetaspaceShared::rw, \"invalid region index\");\n","filename":"src\/hotspot\/share\/memory\/filemap.cpp","additions":6,"deletions":8,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -33,8 +33,5 @@\n-\/\/ Layout of the file:\n-\/\/  header: dump of archive instance plus versioning info, datestamp, etc.\n-\/\/   [magic # = 0xF00BABA2]\n-\/\/  ... padding to align on page-boundary\n-\/\/  read-write space\n-\/\/  read-only space\n-\/\/  misc data (block offset table, string table, symbols, dictionary, etc.)\n-\/\/  tag(666)\n+\/\/ To understand the layout of the CDS archive file:\n+\/\/\n+\/\/ java -Xlog:cds+map=info:file=cds.map:none:filesize=0\n+\/\/ java -Xlog:cds+map=debug:file=cds.map:none:filesize=0\n+\/\/ java -Xlog:cds+map=trace:file=cds.map:none:filesize=0\n@@ -205,1 +202,0 @@\n-  size_t  _i2i_entry_code_buffers_offset;\n@@ -269,1 +265,0 @@\n-  address i2i_entry_code_buffers()         const { return (address)from_mapped_offset(_i2i_entry_code_buffers_offset); }\n@@ -296,3 +291,0 @@\n-  void set_i2i_entry_code_buffers(address p) {\n-    set_as_offset((char*)p, &_i2i_entry_code_buffers_offset);\n-  }\n@@ -413,5 +405,0 @@\n-  address i2i_entry_code_buffers()            const { return header()->i2i_entry_code_buffers();  }\n-  void set_i2i_entry_code_buffers(address addr) const {\n-    header()->set_i2i_entry_code_buffers(addr);\n-  }\n-\n","filename":"src\/hotspot\/share\/memory\/filemap.hpp","additions":5,"deletions":18,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -84,1 +84,0 @@\n-address MetaspaceShared::_i2i_entry_code_buffers = NULL;\n@@ -92,1 +91,0 @@\n-\/\/     mc  - misc code (the method entry trampolines, c++ vtables)\n@@ -103,1 +101,1 @@\n-\/\/ The mc, rw, and ro regions are linearly allocated, in the order of mc->rw->ro.\n+\/\/ The rw, and ro regions are linearly allocated, in the order of rw->ro.\n@@ -106,1 +104,1 @@\n-\/\/ These 3 regions are populated in the following steps:\n+\/\/ These 2 regions are populated in the following steps:\n@@ -109,2 +107,2 @@\n-\/\/ [1] We enter a safepoint and allocate a buffer for the mc\/rw\/ro regions.\n-\/\/ [2] C++ vtables and method trampolines are copied into the mc region.\n+\/\/ [1] We enter a safepoint and allocate a buffer for the rw\/ro regions.\n+\/\/ [2] C++ vtables are copied into the rw region.\n@@ -117,1 +115,1 @@\n-\/\/ Their layout is independent of the mc\/rw\/ro regions.\n+\/\/ Their layout is independent of the rw\/ro regions.\n@@ -325,12 +323,0 @@\n-void MetaspaceShared::set_i2i_entry_code_buffers(address b) {\n-  assert(DumpSharedSpaces, \"must be\");\n-  assert(_i2i_entry_code_buffers == NULL, \"initialize only once\");\n-  _i2i_entry_code_buffers = b;\n-}\n-\n-address MetaspaceShared::i2i_entry_code_buffers() {\n-  assert(DumpSharedSpaces || UseSharedSpaces, \"must be\");\n-  assert(_i2i_entry_code_buffers != NULL, \"must already been initialized\");\n-  return _i2i_entry_code_buffers;\n-}\n-\n@@ -475,1 +461,0 @@\n-  builder.init_mc_region();\n@@ -478,2 +463,2 @@\n-  builder.dump_rw_region();\n-  builder.dump_ro_region();\n+  builder.dump_rw_metadata();\n+  builder.dump_ro_metadata();\n@@ -492,3 +477,0 @@\n-  log_info(cds)(\"Update method trampolines\");\n-  builder.update_method_trampolines();\n-\n@@ -503,1 +485,1 @@\n-  \/\/ We don't want to write these addresses into the archive. Same for i2i buffer.\n+  \/\/ We don't want to write these addresses into the archive.\n@@ -515,1 +497,0 @@\n-  mapinfo->set_i2i_entry_code_buffers(MetaspaceShared::i2i_entry_code_buffers());\n@@ -859,7 +840,0 @@\n-bool MetaspaceShared::is_in_trampoline_frame(address addr) {\n-  if (UseSharedSpaces && is_in_shared_region(addr, MetaspaceShared::mc)) {\n-    return true;\n-  }\n-  return false;\n-}\n-\n@@ -1318,4 +1292,2 @@\n-static int archive_regions[]  = {MetaspaceShared::mc,\n-                                 MetaspaceShared::rw,\n-                                 MetaspaceShared::ro};\n-static int archive_regions_count  = 3;\n+static int archive_regions[]     = { MetaspaceShared::rw, MetaspaceShared::ro };\n+static int archive_regions_count = 2;\n@@ -1368,1 +1340,0 @@\n-  _i2i_entry_code_buffers = static_mapinfo->i2i_entry_code_buffers();\n","filename":"src\/hotspot\/share\/memory\/metaspaceShared.cpp","additions":10,"deletions":39,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -53,1 +53,0 @@\n-  static address _i2i_entry_code_buffers;\n@@ -62,6 +61,5 @@\n-    mc = 0,  \/\/ miscellaneous code for method trampolines\n-    rw = 1,  \/\/ read-write shared space in the heap\n-    ro = 2,  \/\/ read-only shared space in the heap\n-    bm = 3,  \/\/ relocation bitmaps (freed after file mapping is finished)\n-    num_core_region = 3,\n-    num_non_heap_spaces = 4,\n+    rw = 0,  \/\/ read-write shared space in the heap\n+    ro = 1,  \/\/ read-only shared space in the heap\n+    bm = 2,  \/\/ relocation bitmaps (freed after file mapping is finished)\n+    num_core_region = 2,       \/\/ rw and ro\n+    num_non_heap_spaces = 3,   \/\/ rw and ro and bm\n@@ -118,2 +116,0 @@\n-  static bool is_in_trampoline_frame(address addr) NOT_CDS_RETURN_(false);\n-\n@@ -147,4 +143,0 @@\n-  static void init_misc_code_space();\n-  static address i2i_entry_code_buffers();\n-  static void set_i2i_entry_code_buffers(address b);\n-\n","filename":"src\/hotspot\/share\/memory\/metaspaceShared.hpp","additions":5,"deletions":13,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -424,10 +424,0 @@\n-  it->push_method_entry(&this_ptr, (intptr_t*)&_adapter_trampoline);\n-}\n-\n-void ConstMethod::set_adapter_trampoline(AdapterHandlerEntry** trampoline) {\n-  Arguments::assert_is_dumping_archive();\n-  if (DumpSharedSpaces) {\n-    assert(*trampoline == NULL,\n-           \"must be NULL during dump time, to be initialized at run time\");\n-  }\n-  _adapter_trampoline = trampoline;\n","filename":"src\/hotspot\/share\/oops\/constMethod.cpp","additions":1,"deletions":11,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -124,2 +124,0 @@\n-class AdapterHandlerEntry;\n-\n@@ -208,6 +206,0 @@\n-  \/\/ Adapter blob (i2c\/c2i) for this Method*. Set once when method is linked.\n-  union {\n-    AdapterHandlerEntry* _adapter;\n-    AdapterHandlerEntry** _adapter_trampoline; \/\/ see comments around Method::link_method()\n-  };\n-\n@@ -288,20 +280,0 @@\n-  \/\/ adapter\n-  void set_adapter_entry(AdapterHandlerEntry* adapter) {\n-    assert(!is_shared(),\n-           \"shared methods in archive have fixed adapter_trampoline\");\n-    _adapter = adapter;\n-  }\n-  void set_adapter_trampoline(AdapterHandlerEntry** trampoline);\n-  void update_adapter_trampoline(AdapterHandlerEntry* adapter) {\n-    assert(is_shared(), \"must be\");\n-    *_adapter_trampoline = adapter;\n-    assert(this->adapter() == adapter, \"must be\");\n-  }\n-  AdapterHandlerEntry* adapter() {\n-    if (is_shared()) {\n-      return *_adapter_trampoline;\n-    } else {\n-      return _adapter;\n-    }\n-  }\n-\n","filename":"src\/hotspot\/share\/oops\/constMethod.hpp","additions":1,"deletions":29,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -353,3 +353,0 @@\n-  it->push_method_entry(&this_ptr, (intptr_t*)&_i2i_entry);\n-  it->push_method_entry(&this_ptr, (intptr_t*)&_from_compiled_entry);\n-  it->push_method_entry(&this_ptr, (intptr_t*)&_from_interpreted_entry);\n@@ -1116,2 +1113,0 @@\n-  _code = NULL;\n-\n@@ -1119,8 +1114,5 @@\n-  \/\/ Set the values to what they should be at run time. Note that\n-  \/\/ this Method can no longer be executed during dump time.\n-  _i2i_entry = Interpreter::entry_for_cds_method(methodHandle(Thread::current(), this));\n-  _from_interpreted_entry = _i2i_entry;\n-\n-  assert(_from_compiled_entry != NULL, \"sanity\");\n-  assert(*((int*)_from_compiled_entry) == 0,\n-         \"must be NULL during dump time, to be initialized at run time\");\n+  _code = NULL;\n+  _adapter = NULL;\n+  _i2i_entry = NULL;\n+  _from_compiled_entry = NULL;\n+  _from_interpreted_entry = NULL;\n@@ -1139,71 +1131,0 @@\n-\/****************************************************************************\n-\/\/ The following illustrates how the entries work for CDS shared Methods:\n-\/\/\n-\/\/ Our goal is to delay writing into a shared Method until it's compiled.\n-\/\/ Hence, we want to determine the initial values for _i2i_entry,\n-\/\/ _from_interpreted_entry and _from_compiled_entry during CDS dump time.\n-\/\/\n-\/\/ In this example, both Methods A and B have the _i2i_entry of \"zero_locals\".\n-\/\/ They also have similar signatures so that they will share the same\n-\/\/ AdapterHandlerEntry.\n-\/\/\n-\/\/ _adapter_trampoline points to a fixed location in the RW section of\n-\/\/ the CDS archive. This location initially contains a NULL pointer. When the\n-\/\/ first of method A or B is linked, an AdapterHandlerEntry is allocated\n-\/\/ dynamically, and its c2i\/i2c entries are generated.\n-\/\/\n-\/\/ _i2i_entry and _from_interpreted_entry initially points to the same\n-\/\/ (fixed) location in the CODE section of the CDS archive. This contains\n-\/\/ an unconditional branch to the actual entry for \"zero_locals\", which is\n-\/\/ generated at run time and may be on an arbitrary address. Thus, the\n-\/\/ unconditional branch is also generated at run time to jump to the correct\n-\/\/ address.\n-\/\/\n-\/\/ Similarly, _from_compiled_entry points to a fixed address in the CODE\n-\/\/ section. This address has enough space for an unconditional branch\n-\/\/ instruction, and is initially zero-filled. After the AdapterHandlerEntry is\n-\/\/ initialized, and the address for the actual c2i_entry is known, we emit a\n-\/\/ branch instruction here to branch to the actual c2i_entry.\n-\/\/\n-\/\/ The effect of the extra branch on the i2i and c2i entries is negligible.\n-\/\/\n-\/\/ The reason for putting _adapter_trampoline in RO is many shared Methods\n-\/\/ share the same AdapterHandlerEntry, so we can save space in the RW section\n-\/\/ by having the extra indirection.\n-\n-\n-[Method A: RW]\n-  _constMethod ----> [ConstMethod: RO]\n-                       _adapter_trampoline -----------+\n-                                                      |\n-  _i2i_entry              (same value as method B)    |\n-  _from_interpreted_entry (same value as method B)    |\n-  _from_compiled_entry    (same value as method B)    |\n-                                                      |\n-                                                      |\n-[Method B: RW]                               +--------+\n-  _constMethod ----> [ConstMethod: RO]       |\n-                       _adapter_trampoline --+--->(AdapterHandlerEntry* ptr: RW)-+\n-                                                                                 |\n-                                                 +-------------------------------+\n-                                                 |\n-                                                 +----> [AdapterHandlerEntry] (allocated at run time)\n-                                                              _fingerprint\n-                                                              _c2i_entry ---------------------------------+->[c2i entry..]\n- _i2i_entry  -------------+                                   _i2c_entry ---------------+-> [i2c entry..] |\n- _from_interpreted_entry  |                                   _c2i_unverified_entry     |                 |\n-         |                |                                   _c2i_no_clinit_check_entry|                 |\n-         |                |  (_cds_entry_table: CODE)                                   |                 |\n-         |                +->[0]: jmp _entry_table[0] --> (i2i_entry_for \"zero_locals\") |                 |\n-         |                |                               (allocated at run time)       |                 |\n-         |                |  ...                           [asm code ...]               |                 |\n-         +-[not compiled]-+  [n]: jmp _entry_table[n]                                   |                 |\n-         |                                                                              |                 |\n-         |                                                                              |                 |\n-         +-[compiled]-------------------------------------------------------------------+                 |\n-                                                                                                          |\n- _from_compiled_entry------------>  (_c2i_entry_trampoline: CODE)                                         |\n-                                    [jmp c2i_entry] ------------------------------------------------------+\n-\n-***\/\n-\n@@ -1215,8 +1136,1 @@\n-  if (is_shared()) {\n-    \/\/ Can't assert that the adapters are sane, because methods get linked before\n-    \/\/ the interpreter is generated, and hence before its adapters are generated.\n-    \/\/ If you messed them up you will notice soon enough though, don't you worry.\n-    if (adapter() != NULL) {\n-      return;\n-    }\n-  } else if (_i2i_entry != NULL) {\n+  if (_i2i_entry != NULL) {\n@@ -1230,7 +1144,5 @@\n-  if (!is_shared()) {\n-    assert(adapter() == NULL, \"init'd to NULL\");\n-    address entry = Interpreter::entry_for_method(h_method);\n-    assert(entry != NULL, \"interpreter entry must be non-null\");\n-    \/\/ Sets both _i2i_entry and _from_interpreted_entry\n-    set_interpreter_entry(entry);\n-  }\n+  assert(adapter() == NULL, \"init'd to NULL\");\n+  address entry = Interpreter::entry_for_method(h_method);\n+  assert(entry != NULL, \"interpreter entry must be non-null\");\n+  \/\/ Sets both _i2i_entry and _from_interpreted_entry\n+  set_interpreter_entry(entry);\n@@ -1256,1 +1168,0 @@\n-\n@@ -1275,7 +1186,2 @@\n-  if (mh->is_shared()) {\n-    assert(mh->adapter() == adapter, \"must be\");\n-    assert(mh->_from_compiled_entry != NULL, \"must be\");\n-  } else {\n-    mh->set_adapter_entry(adapter);\n-    mh->_from_compiled_entry = adapter->get_c2i_entry();\n-  }\n+  mh->set_adapter_entry(adapter);\n+  mh->_from_compiled_entry = adapter->get_c2i_entry();\n@@ -1287,7 +1193,0 @@\n-\n-  \/\/ Since restore_unshareable_info can be called more than once for a method, don't\n-  \/\/ redo any work.\n-  if (adapter() == NULL) {\n-    methodHandle mh(THREAD, this);\n-    link_method(mh, CHECK);\n-  }\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":13,"deletions":114,"binary":false,"changes":127,"status":"modified"},{"patch":"@@ -79,0 +79,1 @@\n+  AdapterHandlerEntry* _adapter;\n@@ -467,7 +468,1 @@\n-    constMethod()->set_adapter_entry(adapter);\n-  }\n-  void set_adapter_trampoline(AdapterHandlerEntry** trampoline) {\n-    constMethod()->set_adapter_trampoline(trampoline);\n-  }\n-  void update_adapter_trampoline(AdapterHandlerEntry* adapter) {\n-    constMethod()->update_adapter_trampoline(adapter);\n+    _adapter = adapter;\n@@ -484,1 +479,1 @@\n-    return constMethod()->adapter();\n+    return _adapter;\n@@ -519,2 +514,0 @@\n-    assert(!is_shared(),\n-           \"shared method's interpreter entry should not be changed at run time\");\n","filename":"src\/hotspot\/share\/oops\/method.hpp","additions":3,"deletions":10,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2646,25 +2646,0 @@\n-  AdapterHandlerEntry* entry = get_adapter0(method);\n-  if (entry != NULL && method->is_shared()) {\n-    \/\/ See comments around Method::link_method()\n-    MutexLocker mu(AdapterHandlerLibrary_lock);\n-    if (method->adapter() == NULL) {\n-      method->update_adapter_trampoline(entry);\n-    }\n-    address trampoline = method->from_compiled_entry();\n-    if (*(int*)trampoline == 0) {\n-      CodeBuffer buffer(trampoline, (int)SharedRuntime::trampoline_size());\n-      MacroAssembler _masm(&buffer);\n-      SharedRuntime::generate_trampoline(&_masm, entry->get_c2i_entry());\n-      assert(*(int*)trampoline != 0, \"Instruction(s) for trampoline must not be encoded as zeros.\");\n-      _masm.flush();\n-\n-      if (PrintInterpreter) {\n-        Disassembler::decode(buffer.insts_begin(), buffer.insts_end());\n-      }\n-    }\n-  }\n-\n-  return entry;\n-}\n-\n-AdapterHandlerEntry* AdapterHandlerLibrary::get_adapter0(const methodHandle& method) {\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":0,"deletions":25,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -393,2 +393,0 @@\n-  static void generate_trampoline(MacroAssembler *masm, address destination);\n-\n@@ -698,1 +696,0 @@\n-  static AdapterHandlerEntry* get_adapter0(const methodHandle& method);\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,2 +40,2 @@\n-  private static Address mcRegionBaseAddress;\n-  private static Address mcRegionEndAddress;\n+  private static Address rwRegionBaseAddress;\n+  private static Address rwRegionEndAddress;\n@@ -44,1 +44,1 @@\n-  \/\/ HashMap created by mapping the vTable addresses in the mc region with\n+  \/\/ HashMap created by mapping the vTable addresses in the rw region with\n@@ -103,8 +103,8 @@\n-    \/\/ CDSFileMapRegion* mc_space = &header->_space[mc];\n-    \/\/ char* mcRegionBaseAddress = mc_space->_mapped_base;\n-    \/\/ size_t used = mc_space->_used;\n-    \/\/ char* mcRegionEndAddress = mcRegionBaseAddress + used;\n-    Address mc_space = get_CDSFileMapRegion(FileMapHeader_type, header, 0);\n-    mcRegionBaseAddress = get_AddressField(CDSFileMapRegion_type, mc_space, \"_mapped_base\");\n-    long used = get_CIntegerField(CDSFileMapRegion_type, mc_space, \"_used\");\n-    mcRegionEndAddress = mcRegionBaseAddress.addOffsetTo(used);\n+    \/\/ CDSFileMapRegion* rw_space = &header->_space[rw];\n+    \/\/ char* rwRegionBaseAddress = rw_space->_mapped_base;\n+    \/\/ size_t used = rw_space->_used;\n+    \/\/ char* rwRegionEndAddress = rwRegionBaseAddress + used;\n+    Address rw_space = get_CDSFileMapRegion(FileMapHeader_type, header, 0);\n+    rwRegionBaseAddress = get_AddressField(CDSFileMapRegion_type, rw_space, \"_mapped_base\");\n+    long used = get_CIntegerField(CDSFileMapRegion_type, rw_space, \"_used\");\n+    rwRegionEndAddress = rwRegionBaseAddress.addOffsetTo(used);\n@@ -157,2 +157,2 @@\n-      if (vptrAddress.greaterThan(mcRegionBaseAddress) &&\n-          vptrAddress.lessThanOrEqual(mcRegionEndAddress)) {\n+      if (vptrAddress.greaterThan(rwRegionBaseAddress) &&\n+          vptrAddress.lessThanOrEqual(rwRegionEndAddress)) {\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/memory\/FileMapInfo.java","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-    \/\/ For the MC\/RW\/RO regions:\n+    \/\/ For the RW\/RO regions:\n@@ -64,1 +64,1 @@\n-        \/\/ Look for output like this. The pattern will only match the first 3 regions, which is what we need to check\n+        \/\/ Look for output like this. The pattern will only match the first 2 regions, which is what we need to check\n@@ -66,1 +66,0 @@\n-        \/\/ [4.682s][debug][cds] mc  space:     24912 [  0.2% of total] out of     28672 bytes [ 86.9% used] at 0x0000000800000000\n@@ -103,2 +102,2 @@\n-        if (checked.size() != 3) {\n-          throw new RuntimeException(\"Must have 3 consecutive, fully utilized regions\"); \/\/ MC,RW,RO\n+        if (checked.size() != 2) {\n+          throw new RuntimeException(\"Must have 2 consecutive, fully utilized regions\"); \/\/ RW,RO\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/SpaceUtilizationCheck.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -73,1 +73,0 @@\n-        \"mc\",          \/\/ MiscCode\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/SharedArchiveConsistency.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-    public static String[] shared_region_name = {\"MiscCode\", \"ReadWrite\", \"ReadOnly\", \"BitMap\"};\n+    public static String[] shared_region_name = {\"ReadWrite\", \"ReadOnly\", \"BitMap\"};\n@@ -120,1 +120,1 @@\n-        for (int i = 0; i < 4; i++) {\n+        for (int i = 0; i < num_regions; i++) {\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/ArchiveConsistency.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -95,1 +95,1 @@\n-        String unmapRgn0Pattern = \".*Unmapping region #0 at base 0x.*(MiscCode)\";\n+        String unmapRgn0Pattern = \".*Unmapping region #0 at base 0x.*(ReadWrite)\";\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/DynamicArchiveRelocationTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}