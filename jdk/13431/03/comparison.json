{"files":[{"patch":"@@ -28,0 +28,1 @@\n+import java.io.Serial;\n@@ -65,0 +66,1 @@\n+        @Serial\n@@ -77,1 +79,10 @@\n-    private enum Phase { PREAMBLE, BODY, POSTAMBLE }\n+    private enum Phase {\n+        \/** The initial part of an HTML file up to and including the {@code body} and possible {@code <main>} tag. *\/\n+        PREAMBLE,\n+        \/** The initial part of a doc comment, or the rich-text content of a block tag. *\/\n+        BODY,\n+        \/** The end of an HTML file, from and including the {@code <\/main>} or {@code <\/body>} tag. *\/\n+        POSTAMBLE,\n+        \/** The rich-text content of an inline documentation comment tag. *\/\n+        INLINE\n+    }\n@@ -120,4 +131,0 @@\n-    public DocCommentParser(ParserFactory fac) {\n-        this(fac, null, null, false);\n-    }\n-\n@@ -133,2 +140,2 @@\n-        List<DCTree> preamble = isFileContent ? blockContent(Phase.PREAMBLE) : List.nil();\n-        List<DCTree> body = blockContent(Phase.BODY);\n+        List<DCTree> preamble = isFileContent ? content(Phase.PREAMBLE) : List.nil();\n+        List<DCTree> body = content(Phase.BODY);\n@@ -136,1 +143,1 @@\n-        List<DCTree> postamble = isFileContent ? blockContent(Phase.POSTAMBLE) : List.nil();\n+        List<DCTree> postamble = isFileContent ? content(Phase.POSTAMBLE) : List.nil();\n@@ -150,2 +157,1 @@\n-            case '\\f': case '\\n': case '\\r':\n-                newline = true;\n+            case '\\f', '\\n', '\\r' -> newline = true;\n@@ -160,1 +166,1 @@\n-        return blockContent(Phase.BODY);\n+        return content(Phase.BODY);\n@@ -164,3 +170,20 @@\n-     * Read block content, consisting of text, html and inline tags.\n-     * Terminated by the end of input, or the beginning of the next block tag:\n-     * that is, @ as the first non-whitespace character on a line.\n+     * Reads \"rich text\" content, consisting of text, html and inline tags,\n+     * according to the given {@code phase}.\n+     *\n+     * Inline tags are only recognized in {@code BODY} and {@code INLINE}\n+     * phases, and not in {@code PREAMBLE} and {@code POSTAMBLE} phases.\n+     *\n+     * The end of the content is dependent on the phase:\n+     *\n+     * <ul>\n+     * <li>{@code PREAMBLE}: the appearance of {@code <body>} (or {@code <main>}),\n+     *      as determined by {@link #isEndPreamble()}\n+     * <li>{@code BODY}: the beginning of a block tag, or when readung from\n+     *      an HTML file, the appearance of {@code <\/main>} (or {@code <\/body>},\n+     *       as determined by {@link #isEndBody()}\n+     * <li>{@code INLINE}: '}', after skipping any matching {@code { }}\n+     * <li>{@code PREAMBLE}: end of file\n+     * <\/ul>\n+     *\n+     *\n+     *\n@@ -168,2 +191,1 @@\n-    @SuppressWarnings(\"fallthrough\")\n-    protected List<DCTree> blockContent(Phase phase) {\n+    protected List<DCTree> content(Phase phase) {\n@@ -173,0 +195,3 @@\n+        int depth = phase == Phase.INLINE ? 1 : -1; \/\/ only used when phase is INLINE\n+        int pos = bp;                               \/\/ only used when phase is INLINE\n+\n@@ -176,2 +201,1 @@\n-                case '\\n': case '\\r': case '\\f':\n-                case ' ': case '\\t':\n+                case '\\n', '\\r', '\\f', ' ', '\\t' ->\n@@ -179,1 +203,0 @@\n-                    break;\n@@ -181,1 +204,1 @@\n-                case '&':\n+                case '&' ->\n@@ -183,1 +206,0 @@\n-                    break;\n@@ -185,1 +207,1 @@\n-                case '<':\n+                case '<' -> {\n@@ -189,1 +211,1 @@\n-                            case PREAMBLE:\n+                            case PREAMBLE -> {\n@@ -200,2 +222,2 @@\n-                                break;\n-                            case BODY:\n+                            }\n+                            case BODY -> {\n@@ -206,3 +228,3 @@\n-                                break;\n-                            default:\n-                                \/\/ fallthrough\n+                            }\n+\n+                            default -> { }\n@@ -221,1 +243,13 @@\n-                    break;\n+                }\n+\n+                case '{' -> {\n+                    switch (phase) {\n+                        case PREAMBLE, POSTAMBLE -> defaultContentCharacter();\n+                        case BODY -> inlineTag(trees);\n+                        case INLINE -> {\n+                            if (!inlineTag(trees)) {\n+                                depth++;\n+                            }\n+                        }\n+                    }\n+                }\n@@ -223,3 +257,13 @@\n-                case '{':\n-                    inlineTag(trees);\n-                    break;\n+                case '}' -> {\n+                    if (phase == Phase.INLINE) {\n+                        newline = false;\n+                        if (--depth == 0) {\n+                            addPendingText(trees, bp - 1);\n+                            nextChar();\n+                            return trees.toList();\n+                        }\n+                        nextChar();\n+                    } else {\n+                        defaultContentCharacter();\n+                    }\n+                }\n@@ -227,1 +271,1 @@\n-                case '@':\n+                case '@' -> {\n@@ -242,1 +286,1 @@\n-                        } else {\n+                        } else if (phase == Phase.BODY) {\n@@ -255,1 +299,2 @@\n-                    \/\/ fallthrough\n+                    defaultContentCharacter();\n+                }\n@@ -257,6 +302,3 @@\n-                default:\n-                    newline = false;\n-                    if (textStart == -1)\n-                        textStart = bp;\n-                    lastNonWhite = bp;\n-                    nextChar();\n+                default -> {\n+                    defaultContentCharacter();\n+                }\n@@ -269,1 +311,11 @@\n-        return trees.toList();\n+        return (phase == Phase.INLINE)\n+                ? List.of(erroneous(\"dc.unterminated.inline.tag\", pos))\n+                : trees.toList();\n+    }\n+\n+    void defaultContentCharacter() {\n+        newline = false;\n+        if (textStart == -1)\n+            textStart = bp;\n+        lastNonWhite = bp;\n+        nextChar();\n@@ -317,1 +369,15 @@\n-    protected void inlineTag(ListBuffer<DCTree> list) {\n+    \/**\n+     * Reads a possible inline tag, after finding an opening brace <code>{<\/code> character.\n+     *\n+     * If the next character is {@code @}, an opening tag is read and added to the\n+     * given {@code list}, and the result is {@code true}.\n+     *\n+     * Otherwise, the {@code list} is updated with the characters that have been read,\n+     * and the result is {@code false}. The result also indicates that a single\n+     * opening brace was read, and that a corresponding closing brace should eventually\n+     * be read.\n+     *\n+     * @param list the list of trees being accumulated\n+     * @return {@code true} if an inline tag was read, and {@code false} otherwise\n+     *\/\n+    protected boolean inlineTag(ListBuffer<DCTree> list) {\n@@ -338,0 +404,1 @@\n+                return true;\n@@ -344,0 +411,1 @@\n+        return false;\n@@ -392,2 +460,2 @@\n-     * Matching pairs of { } are skipped; the text is terminated by the first\n-     * unmatched }. It is an error if the beginning of the next tag is detected.\n+     * Matching pairs of '{' '}' are skipped; the text is terminated by the first\n+     * unmatched '}'. It is an error if the beginning of the next tag is detected.\n@@ -397,1 +465,1 @@\n-            case REMOVE_ALL:\n+            case REMOVE_ALL -> {\n@@ -399,2 +467,3 @@\n-                break;\n-            case REMOVE_FIRST_SPACE:\n+            }\n+\n+            case REMOVE_FIRST_SPACE -> {\n@@ -403,5 +472,1 @@\n-                break;\n-            case RETAIN_ALL:\n-            default:\n-                \/\/ do nothing\n-                break;\n+            }\n@@ -409,0 +474,1 @@\n+            case RETAIN_ALL -> { }\n@@ -413,1 +479,0 @@\n-        loop:\n@@ -416,3 +481,2 @@\n-                case '\\n': case '\\r': case '\\f':\n-                case ' ': case '\\t':\n-                    break;\n+                case '\\n', '\\r', '\\f', ' ', '\\t' -> {\n+                }\n@@ -420,1 +484,1 @@\n-                case '{':\n+                case '{' -> {\n@@ -424,1 +488,1 @@\n-                    break;\n+                }\n@@ -426,1 +490,1 @@\n-                case '}':\n+                case '}' -> {\n@@ -432,1 +496,1 @@\n-                    break;\n+                }\n@@ -434,1 +498,1 @@\n-                default:\n+                default -> {\n@@ -437,1 +501,1 @@\n-                    break;\n+                }\n@@ -447,1 +511,1 @@\n-     * unmatched }. It is an error if the beginning of the next tag is detected.\n+     * unmatched '}'. It is an error if the beginning of the next tag is detected.\n@@ -450,1 +514,0 @@\n-    @SuppressWarnings(\"fallthrough\")\n@@ -460,2 +523,2 @@\n-                case '\\n': case '\\r': case '\\f':\n-                case ' ': case '\\t':\n+\n+                case '\\n', '\\r', '\\f', ' ', '\\t' -> {\n@@ -464,1 +527,1 @@\n-                    break;\n+                }\n@@ -466,2 +529,1 @@\n-                case '(':\n-                case '<':\n+                case '(', '<' -> {\n@@ -470,1 +532,1 @@\n-                    break;\n+                }\n@@ -472,2 +534,1 @@\n-                case ')':\n-                case '>':\n+                case ')', '>' -> {\n@@ -476,1 +537,1 @@\n-                    break;\n+                }\n@@ -478,1 +539,1 @@\n-                case '}':\n+                case '}' -> {\n@@ -483,0 +544,1 @@\n+                }\n@@ -484,1 +546,1 @@\n-                case '@':\n+                case '@' -> {\n@@ -487,1 +549,1 @@\n-                    \/\/ fallthrough\n+                }\n@@ -489,1 +551,1 @@\n-                default:\n+                default -> {\n@@ -491,0 +553,1 @@\n+                }\n@@ -537,3 +600,1 @@\n-                case '\\n': case '\\r': case '\\f':\n-                case ' ': case '\\t':\n-                    break;\n+                case '\\n', '\\r', '\\f', ' ', '\\t' -> { }\n@@ -541,1 +602,1 @@\n-                case '\"':\n+                case '\"' -> {\n@@ -545,0 +606,1 @@\n+                }\n@@ -546,1 +608,1 @@\n-                case '@':\n+                case '@' -> {\n@@ -549,1 +611,1 @@\n-\n+                }\n@@ -566,2 +628,1 @@\n-                case '\\n':\n-                case '\\r': case '\\f': case ' ': case '\\t':\n+                case '\\n', '\\r', '\\f', ' ', '\\t' -> {\n@@ -569,0 +630,1 @@\n+                }\n@@ -570,1 +632,1 @@\n-                case '@':\n+                case '@' -> {\n@@ -573,1 +635,1 @@\n-                    break;\n+                }\n@@ -575,1 +637,1 @@\n-                case '{':\n+                case '{' -> {\n@@ -577,1 +639,1 @@\n-                    break;\n+                }\n@@ -579,1 +641,1 @@\n-                case '}':\n+                case '}' -> {\n@@ -583,1 +645,1 @@\n-                    break;\n+                }\n@@ -593,2 +655,2 @@\n-     * Matching pairs of { } are skipped; the text is terminated by the first\n-     * unmatched }. It is an error if the beginning of the next tag is detected.\n+     * Matching pairs of '{' '}' are skipped; the text is terminated by the first\n+     * unmatched '}'. It is an error if the beginning of the next tag is detected.\n@@ -596,1 +658,0 @@\n-    @SuppressWarnings(\"fallthrough\")\n@@ -598,2 +659,0 @@\n-        ListBuffer<DCTree> trees = new ListBuffer<>();\n-\n@@ -601,86 +660,1 @@\n-        int pos = bp;\n-        int depth = 1;\n-        textStart = -1;\n-\n-        loop:\n-        while (bp < buflen) {\n-\n-            switch (ch) {\n-                case '\\n': case '\\r': case '\\f':\n-                case ' ': case '\\t':\n-                    nextChar();\n-                    break;\n-\n-                case '&':\n-                    entity(trees);\n-                    break;\n-\n-                case '<':\n-                    newline = false;\n-                    addPendingText(trees, bp - 1);\n-                    trees.add(html());\n-                    textStart = bp;\n-                    lastNonWhite = -1;\n-                    break;\n-\n-                case '{':\n-                    if (textStart == -1)\n-                        textStart = bp;\n-                    newline = false;\n-                    nextChar();\n-                    if (ch == '@') {\n-                        addPendingText(trees, bp - 2);\n-                        trees.add(inlineTag());\n-                        textStart = bp;\n-                        lastNonWhite = -1;\n-                    } else {\n-                        depth++;\n-                    }\n-                    break;\n-\n-                case '}':\n-                    newline = false;\n-                    if (--depth == 0) {\n-                        addPendingText(trees, bp - 1);\n-                        nextChar();\n-                        return trees.toList();\n-                    }\n-                    nextChar();\n-                    break;\n-\n-                case '@':\n-                    \/\/ check for context-sensitive escape sequences:\n-                    \/\/   newline whitespace @@\n-                    \/\/   newline whitespace @*\n-                    \/\/   *@\/\n-                    if (newline) {\n-                        char peek = peekChar();\n-                        if (peek == '@' || peek == '*') {\n-                            addPendingText(trees, bp - 1);\n-                            nextChar();\n-                            trees.add(m.at(bp - 1).newEscapeTree(ch));\n-                            newline = false;\n-                            nextChar();\n-                            textStart = bp;\n-                            break;\n-                        }\n-                    } else if (textStart != -1 && buf[bp - 1] == '*' && peekChar() == '\/') {\n-                        addPendingText(trees, bp - 1);\n-                        nextChar();\n-                        trees.add(m.at(bp - 1).newEscapeTree('\/'));\n-                        newline = false;\n-                        nextChar();\n-                        textStart = bp;\n-                        break;\n-                    }\n-                    \/\/ fallthrough\n-\n-                default:\n-                    if (textStart == -1)\n-                        textStart = bp;\n-                    nextChar();\n-                    break;\n-            }\n-        }\n-\n-        return List.of(erroneous(\"dc.unterminated.inline.tag\", pos));\n+        return content(Phase.INLINE);\n@@ -754,1 +728,1 @@\n-                    case \"body\":\n+                    case \"body\" -> {\n@@ -780,0 +754,1 @@\n+                    }\n@@ -781,1 +756,1 @@\n-                    case \"main\":\n+                    case \"main\" -> {\n@@ -784,0 +759,1 @@\n+                    }\n@@ -811,2 +787,1 @@\n-                        case \"body\":\n-                        case \"main\":\n+                        case \"body\", \"main\" -> {\n@@ -814,0 +789,1 @@\n+                        }\n@@ -853,2 +829,10 @@\n-     * Read the start or end of an HTML tag, or an HTML comment\n-     * {@literal <identifier attrs> } or {@literal <\/identifier> }\n+     * Reads an HTML construct, beginning with {@code <}.\n+     *\n+     * <ul>\n+     * <li>start element: {@code <identifier attrs> }\n+     * <li>end element: {@code <\/identifier> }\n+     * <li>comment: {@code <!-- ... -->}\n+     * <li>doctype: {@code <!doctype ... >}\n+     * <li>cdata: {@code <![CDATA[ ... ]]>}\n+     * <\/ul>\n+     *  or\n@@ -870,2 +854,1 @@\n-                    DCTree dctree = m.at(p).newStartElementTree(name, attrs, selfClosing).setEndPos(bp);\n-                    return dctree;\n+                    return m.at(p).newStartElementTree(name, attrs, selfClosing).setEndPos(bp);\n@@ -1014,10 +997,3 @@\n-            case '&':\n-                entity(list);\n-                break;\n-\n-            case '{':\n-                inlineTag(list);\n-                break;\n-\n-            default:\n-                nextChar();\n+            case '&' -> entity(list);\n+            case '{' -> inlineTag(list);\n+            default  -> nextChar();\n@@ -1067,1 +1043,1 @@\n-                case '\\f': case '\\n': case '\\r':\n+                case '\\f', '\\n', '\\r' -> {\n@@ -1069,4 +1045,5 @@\n-                    break;\n-                case '\\t': case ' ':\n-                    break;\n-                default:\n+                }\n+\n+                case '\\t', ' ' -> { }\n+\n+                default -> {\n@@ -1074,0 +1051,1 @@\n+                }\n@@ -1149,9 +1127,5 @@\n-        switch (ch) {\n-            case '\\f': case '\\n': case '\\r': case '\\t':\n-            case ' ':\n-            case '\"': case '\\'': case '`':\n-            case '=': case '<': case '>':\n-                return true;\n-            default:\n-                return false;\n-        }\n+        return switch (ch) {\n+            case '\\f', '\\n', '\\r', '\\t', ' ',\n+                    '\"', '\\'', '`', '=', '<', '>' -> true;\n+            default -> false;\n+        };\n@@ -1405,11 +1379,5 @@\n-                    List<DCTree> description;\n-                    switch (kind) {\n-                        case BLOCK:\n-                            description = blockContent();\n-                            break;\n-                        case INLINE:\n-                            description = inlineContent();\n-                            break;\n-                        default:\n-                            throw new IllegalArgumentException(kind.toString());\n-                    }\n+                    List<DCTree> description = switch (kind) {\n+                        case BLOCK -> blockContent();\n+                        case INLINE -> inlineContent();\n+                        default -> throw new IllegalArgumentException(kind.toString());\n+                    };\n@@ -1426,1 +1394,1 @@\n-                        case '\"':\n+                        case '\"' -> {\n@@ -1435,1 +1403,1 @@\n-                            break;\n+                        }\n@@ -1437,1 +1405,1 @@\n-                        case '<':\n+                        case '<' -> {\n@@ -1441,1 +1409,1 @@\n-                            break;\n+                        }\n@@ -1443,1 +1411,1 @@\n-                        case '@':\n+                        case '@' -> {\n@@ -1446,1 +1414,1 @@\n-                            break;\n+                        }\n@@ -1448,1 +1416,1 @@\n-                        case EOI:\n+                        case EOI -> {\n@@ -1451,1 +1419,1 @@\n-                            break;\n+                        }\n@@ -1453,1 +1421,1 @@\n-                        default:\n+                        default -> {\n@@ -1459,0 +1427,1 @@\n+                        }\n@@ -1616,1 +1585,1 @@\n-                public DCTree parse(int pos) throws ParseException {\n+                public DCTree parse(int pos) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/DocCommentParser.java","additions":205,"deletions":236,"binary":false,"changes":441,"status":"modified"}]}