{"files":[{"patch":"@@ -165,1 +165,0 @@\n-JVM_IsThreadAlive\n","filename":"make\/data\/hotspot-symbols\/symbols-unix","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -269,3 +269,0 @@\n-JNIEXPORT jboolean JNICALL\n-JVM_IsThreadAlive(JNIEnv *env, jobject thread);\n-\n","filename":"src\/hotspot\/share\/include\/jvm.h","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -3023,6 +3023,0 @@\n-JVM_ENTRY(jboolean, JVM_IsThreadAlive(JNIEnv* env, jobject jthread))\n-  oop thread_oop = JNIHandles::resolve_non_null(jthread);\n-  return java_lang_Thread::is_alive(thread_oop);\n-JVM_END\n-\n-\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -11025,1 +11025,2 @@\n-            The current thread may not be a virtual thread. Otherwise, the error code\n+            An implementation is not required to support this function\n+            when the current thread is a virtual thread, in which case \n@@ -11128,1 +11129,2 @@\n-              The <code>thread<\/code> may not be a virtual thread. Otherwise, the error code\n+              An implementation is not required to support this function\n+              when the given thread is a virtual thread, in which case\n","filename":"src\/hotspot\/share\/prims\/jvmti.xml","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -742,1 +742,3 @@\n-  \/\/ to complete once we've done the notify_all below\n+  \/\/ to complete once we've done the notify_all below. Needs a release() to obey Java Memory Model\n+  \/\/ requirements.\n+  OrderAccess::release();\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2013, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,2 +41,2 @@\n-    AixFileSystem(UnixFileSystemProvider provider) {\n-        super(provider);\n+    AixFileSystem(UnixFileSystemProvider provider, String dir) {\n+        super(provider, dir);\n","filename":"src\/java.base\/aix\/classes\/sun\/nio\/fs\/AixFileSystem.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2013, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,2 +41,2 @@\n-    AixFileSystem newFileSystem() {\n-        return new AixFileSystem(this);\n+    AixFileSystem newFileSystem(String dir) {\n+        return new AixFileSystem(this, dir);\n","filename":"src\/java.base\/aix\/classes\/sun\/nio\/fs\/AixFileSystemProvider.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,2 +44,2 @@\n-    LinuxFileSystem(UnixFileSystemProvider provider) {\n-        super(provider);\n+    LinuxFileSystem(UnixFileSystemProvider provider, String dir) {\n+        super(provider, dir);\n","filename":"src\/java.base\/linux\/classes\/sun\/nio\/fs\/LinuxFileSystem.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2018, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,2 +45,2 @@\n-    LinuxFileSystem newFileSystem() {\n-        return new LinuxFileSystem(this);\n+    LinuxFileSystem newFileSystem(String dir) {\n+        return new LinuxFileSystem(this, dir);\n","filename":"src\/java.base\/linux\/classes\/sun\/nio\/fs\/LinuxFileSystemProvider.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,2 +49,2 @@\n-    BsdFileSystem(UnixFileSystemProvider provider) {\n-        super(provider);\n+    BsdFileSystem(UnixFileSystemProvider provider, String dir) {\n+        super(provider, dir);\n","filename":"src\/java.base\/macosx\/classes\/sun\/nio\/fs\/BsdFileSystem.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,2 +42,2 @@\n-    BsdFileSystem newFileSystem() {\n-        return new BsdFileSystem(this);\n+    BsdFileSystem newFileSystem(String dir) {\n+        return new BsdFileSystem(this, dir);\n","filename":"src\/java.base\/macosx\/classes\/sun\/nio\/fs\/BsdFileSystemProvider.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,2 +51,2 @@\n-    MacOSXFileSystem(UnixFileSystemProvider provider) {\n-        super(provider);\n+    MacOSXFileSystem(UnixFileSystemProvider provider, String dir) {\n+        super(provider, dir);\n","filename":"src\/java.base\/macosx\/classes\/sun\/nio\/fs\/MacOSXFileSystem.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2018, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,2 +43,2 @@\n-    MacOSXFileSystem newFileSystem() {\n-        return new MacOSXFileSystem(this);\n+    MacOSXFileSystem newFileSystem(String dir) {\n+        return new MacOSXFileSystem(this, dir);\n","filename":"src\/java.base\/macosx\/classes\/sun\/nio\/fs\/MacOSXFileSystemProvider.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -60,0 +60,2 @@\n+    private static final byte[] EMPTY = new byte[0];\n+\n@@ -73,0 +75,3 @@\n+    \/\/ initial buffer size (DEFAULT_BUFFER_SIZE or size specified to constructor)\n+    private final int initialSize;\n+\n@@ -169,2 +174,3 @@\n-     * Check to make sure that buffer has not been nulled out due to\n-     * close; if not return it;\n+     * Returns the internal buffer, optionally allocating it if empty.\n+     * @param allocateIfEmpty true to allocate if empty\n+     * @throws IOException if the stream is closed (buf is null)\n@@ -172,1 +178,1 @@\n-    private byte[] getBufIfOpen() throws IOException {\n+    private byte[] getBufIfOpen(boolean allocateIfEmpty) throws IOException {\n@@ -174,1 +180,8 @@\n-        if (buffer == null)\n+        if (allocateIfEmpty && buffer == EMPTY) {\n+            buffer = new byte[initialSize];\n+            if (!U.compareAndSetReference(this, BUF_OFFSET, EMPTY, buffer)) {\n+                \/\/ re-read buf\n+                buffer = buf;\n+            }\n+        }\n+        if (buffer == null) {\n@@ -176,0 +189,1 @@\n+        }\n@@ -179,0 +193,17 @@\n+    \/**\n+     * Returns the internal buffer, allocating it if empty.\n+     * @throws IOException if the stream is closed (buf is null)\n+     *\/\n+    private byte[] getBufIfOpen() throws IOException {\n+        return getBufIfOpen(true);\n+    }\n+\n+    \/**\n+     * Throws IOException if the stream is closed (buf is null).\n+     *\/\n+    private void ensureOpen() throws IOException {\n+        if (buf == null) {\n+            throw new IOException(\"Stream closed\");\n+        }\n+    }\n+\n@@ -208,3 +239,1 @@\n-        buf = new byte[size];\n-\n-        \/\/ use monitors when BufferedInputStream is sub-classed\n+        initialSize = size;\n@@ -212,0 +241,1 @@\n+            \/\/ use internal lock and lazily create buffer when not subclassed\n@@ -213,0 +243,1 @@\n+            buf = EMPTY;\n@@ -214,0 +245,1 @@\n+            \/\/ use monitors and eagerly create buffer when subclassed\n@@ -215,0 +247,1 @@\n+            buf = new byte[size];\n@@ -310,1 +343,2 @@\n-            if (len >= getBufIfOpen().length && markpos == -1) {\n+            int size = Math.max(getBufIfOpen(false).length, initialSize);\n+            if (len >= size && markpos == -1) {\n@@ -377,1 +411,1 @@\n-        getBufIfOpen(); \/\/ Check for closed stream\n+        ensureOpen();\n@@ -424,1 +458,1 @@\n-        getBufIfOpen(); \/\/ Check for closed stream\n+        ensureOpen();\n@@ -547,1 +581,1 @@\n-        getBufIfOpen(); \/\/ Cause exception if closed\n+        ensureOpen();\n","filename":"src\/java.base\/share\/classes\/java\/io\/BufferedInputStream.java","additions":45,"deletions":11,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -229,2 +229,9 @@\n-    \/* Reserved for exclusive use by the JVM, maybe move to FieldHolder *\/\n-    private long eetop;\n+    \/*\n+     * Reserved for exclusive use by the JVM. Cannot be moved to the FieldHolder\n+     * as it needs to be set by the VM for JNI attaching threads, before executing\n+     * the constructor that will create the FieldHolder. The historically named\n+     * `eetop` holds the address of the underlying VM JavaThread, and is set to\n+     * non-zero when the thread is started, and reset to zero when the thread terminates.\n+     * A non-zero value indicates this thread isAlive().\n+     *\/\n+    private volatile long eetop;\n@@ -1843,1 +1850,1 @@\n-        return isAlive0();\n+        return eetop != 0;\n@@ -1845,1 +1852,0 @@\n-    private native boolean isAlive0();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Thread.java","additions":11,"deletions":5,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -508,1 +508,1 @@\n-     *           entry.  This is the entry that will be removed it this\n+     *           entry.  This is the entry that will be removed if this\n","filename":"src\/java.base\/share\/classes\/java\/util\/LinkedHashMap.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -632,1 +632,1 @@\n-     * Returns a {@code Collector} that produces the sum of a integer-valued\n+     * Returns a {@code Collector} that produces the sum of an integer-valued\n","filename":"src\/java.base\/share\/classes\/java\/util\/stream\/Collectors.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,0 @@\n-    {\"isAlive0\",         \"()Z\",        (void *)&JVM_IsThreadAlive},\n","filename":"src\/java.base\/share\/native\/libjava\/Thread.c","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -55,1 +55,0 @@\n-import jdk.internal.util.StaticProperty;\n@@ -77,0 +76,1 @@\n+    private final boolean needToResolveAgainstDefaultDirectory;\n@@ -80,2 +80,1 @@\n-    UnixFileSystem(UnixFileSystemProvider provider) {\n-        String dir = StaticProperty.userDir();\n+    UnixFileSystem(UnixFileSystemProvider provider, String dir) {\n@@ -88,0 +87,22 @@\n+        \/\/ if process-wide chdir is allowed or default directory is not the\n+        \/\/ process working directory then paths must be resolved against the\n+        \/\/ default directory.\n+        String propValue = GetPropertyAction\n+                .privilegedGetProperty(\"sun.nio.fs.chdirAllowed\", \"false\");\n+        boolean chdirAllowed = propValue.isEmpty() ? true : Boolean.parseBoolean(propValue);\n+        if (chdirAllowed) {\n+            this.needToResolveAgainstDefaultDirectory = true;\n+        } else {\n+            byte[] cwd = UnixNativeDispatcher.getcwd();\n+            boolean defaultIsCwd = (cwd.length == defaultDirectory.length);\n+            if (defaultIsCwd) {\n+                for (int i=0; i<cwd.length; i++) {\n+                    if (cwd[i] != defaultDirectory[i]) {\n+                        defaultIsCwd = false;\n+                        break;\n+                    }\n+                }\n+            }\n+            this.needToResolveAgainstDefaultDirectory = !defaultIsCwd;\n+        }\n+\n@@ -97,0 +118,4 @@\n+    boolean needToResolveAgainstDefaultDirectory() {\n+        return needToResolveAgainstDefaultDirectory;\n+    }\n+\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixFileSystem.java","additions":28,"deletions":3,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -78,1 +78,1 @@\n-        theFileSystem = newFileSystem();\n+        theFileSystem = newFileSystem(StaticProperty.userDir());\n@@ -86,1 +86,1 @@\n-     * Constructs a new file system.\n+     * Constructs a new file system using the given default directory.\n@@ -88,1 +88,1 @@\n-    abstract UnixFileSystem newFileSystem();\n+    abstract UnixFileSystem newFileSystem(String dir);\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixFileSystemProvider.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,0 +55,5 @@\n+    \/**\n+     * char *getcwd(char *buf, size_t size);\n+     *\/\n+    static native byte[] getcwd();\n+\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixNativeDispatcher.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -141,2 +141,4 @@\n-        if (!isEmpty()) {\n-            return path;\n+        \/\/ resolve against default directory if required (chdir allowed or\n+        \/\/ file system default directory is not working directory)\n+        if (getFileSystem().needToResolveAgainstDefaultDirectory()) {\n+            return resolve(getFileSystem().defaultDirectory(), path);\n@@ -144,3 +146,7 @@\n-            \/\/ empty path case will access current directory\n-            byte[] here = { '.' };\n-            return here;\n+            if (!isEmpty()) {\n+                return path;\n+            } else {\n+                \/\/ empty path case will access current directory\n+                byte[] here = { '.' };\n+                return here;\n+            }\n@@ -157,1 +163,5 @@\n-        return toString();\n+        if (getFileSystem().needToResolveAgainstDefaultDirectory()) {\n+            return Util.toString(getByteArrayForSysCalls());\n+        } else {\n+            return toString();\n+        }\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixPath.java","additions":16,"deletions":6,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -327,0 +327,19 @@\n+JNIEXPORT jbyteArray JNICALL\n+Java_sun_nio_fs_UnixNativeDispatcher_getcwd(JNIEnv* env, jclass this) {\n+    jbyteArray result = NULL;\n+    char buf[PATH_MAX+1];\n+\n+    \/* EINTR not listed as a possible error *\/\n+    char* cwd = getcwd(buf, sizeof(buf));\n+    if (cwd == NULL) {\n+        throwUnixException(env, errno);\n+    } else {\n+        jsize len = (jsize)strlen(buf);\n+        result = (*env)->NewByteArray(env, len);\n+        if (result != NULL) {\n+            (*env)->SetByteArrayRegion(env, result, 0, len, (jbyte*)buf);\n+        }\n+    }\n+    return result;\n+}\n+\n","filename":"src\/java.base\/unix\/native\/libnio\/fs\/UnixNativeDispatcher.c","additions":20,"deletions":1,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-import jdk.internal.util.StaticProperty;\n@@ -46,1 +45,3 @@\n-    WindowsFileSystem(WindowsFileSystemProvider provider) {\n+    WindowsFileSystem(WindowsFileSystemProvider provider,\n+                      String dir)\n+    {\n@@ -50,1 +51,0 @@\n-        String dir = StaticProperty.userDir();\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/fs\/WindowsFileSystem.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,1 @@\n+import jdk.internal.util.StaticProperty;\n@@ -51,1 +52,1 @@\n-        theFileSystem = new WindowsFileSystem(this);\n+        theFileSystem = new WindowsFileSystem(this, StaticProperty.userDir());\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/fs\/WindowsFileSystemProvider.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.net.http.HttpResponse.BodyHandlers;\n@@ -41,0 +42,1 @@\n+import java.util.Objects;\n@@ -48,0 +50,2 @@\n+import java.util.concurrent.Flow.Subscription;\n+\n@@ -64,1 +68,5 @@\n- * sharing, for all requests sent through it.\n+ * sharing, for all requests sent through it. An {@code HttpClient} instance\n+ * typically manages its own pools of connections, which it may then reuse\n+ * as and when necessary. Connection pools are  typically not shared between\n+ * {@code HttpClient} instances. Creating a new client for each operation,\n+ * though possible, will usually prevent reusing such connections.\n@@ -122,1 +130,23 @@\n- * @implNote If an explicit {@linkplain HttpClient.Builder#executor(Executor)\n+ * @apiNote\n+ * Resources allocated by the {@code HttpClient} may be\n+ * reclaimed early by {@linkplain #close() closing} the client.\n+ *\n+ * @implNote\n+ *  <p id=\"closing\">\n+ *  The JDK built-in implementation of the {@code HttpClient} overrides\n+ * {@link #close()}, {@link #shutdown()}, {@link #shutdownNow()},\n+ * {@link #awaitTermination(Duration)}, and {@link #isTerminated()} to\n+ * provide a best effort implementation. Failing to close, cancel, or\n+ * read returned streams to exhaustion, such as streams provided when using\n+ * {@link BodyHandlers#ofInputStream()}, {@link BodyHandlers#ofLines()}, or\n+ * {@link BodyHandlers#ofPublisher()}, may prevent requests submitted\n+ * before an {@linkplain #shutdown() orderly shutdown}\n+ * to run to completion. Likewise, failing to\n+ * {@linkplain Subscription#request(long) request data} or {@linkplain\n+ * Subscription#cancel() cancel subscriptions} from a custom {@linkplain\n+ * java.net.http.HttpResponse.BodySubscriber BodySubscriber} may stop\n+ * delivery of data and {@linkplain #awaitTermination(Duration) stall an\n+ * orderly shutdown}.\n+ *\n+ * <p>\n+ * If an explicit {@linkplain HttpClient.Builder#executor(Executor)\n@@ -135,1 +165,1 @@\n-public abstract class HttpClient {\n+public abstract class HttpClient implements AutoCloseable {\n@@ -602,1 +632,2 @@\n-     * @throws IOException if an I\/O error occurs when sending or receiving\n+     * @throws IOException if an I\/O error occurs when sending or receiving, or\n+     *         the client has {@linkplain ##closing shut down}\n@@ -649,1 +680,2 @@\n-     * <li>{@link IOException} - if an I\/O error occurs when sending or receiving<\/li>\n+     * <li>{@link IOException} - if an I\/O error occurs when sending or receiving,\n+     *      or the client has {@linkplain ##closing shut down}.<\/li>\n@@ -733,0 +765,150 @@\n+\n+    \/**\n+     * Initiates an orderly shutdown in which  requests previously\n+     * submitted with {@code send} or {@code sendAsync}\n+     * are run to completion, but no new request will be accepted.\n+     * Running a request to completion may involve running several\n+     * operations in the background, including {@linkplain ##closing\n+     * waiting for responses to be delivered}, which will all have to\n+     * run to completion until the request is considered completed.\n+     *\n+     * Invocation has no additional effect if already shut down.\n+     *\n+     * <p>This method does not wait for previously submitted request\n+     * to complete execution.  Use {@link #awaitTermination(Duration)\n+     * awaitTermination} or {@link #close() close} to do that.\n+     *\n+     * @implSpec\n+     * The default implementation of this method does nothing. Subclasses should\n+     * override this method to implement the appropriate behavior.\n+     *\n+     * @see ##closing Implementation Note on closing the HttpClient\n+     *\n+     * @since 21\n+     *\/\n+    public void shutdown() { }\n+\n+    \/**\n+     * Blocks until all operations have completed execution after a shutdown\n+     * request, or the {@code duration} elapses, or the current thread is\n+     * {@linkplain Thread#interrupt() interrupted}, whichever happens first.\n+     * Operations are any tasks required to run a request previously\n+     * submitted with {@code send} or {@code sendAsync} to completion.\n+     *\n+     * <p> This method does not wait if the duration to wait is less than or\n+     * equal to zero. In this case, the method just tests if the thread has\n+     * terminated.\n+     *\n+     * @implSpec\n+     * The default implementation of this method checks for null arguments, but\n+     * otherwise does nothing and returns true.\n+     * Subclasses should override this method to implement the proper behavior.\n+     *\n+     * @param duration the maximum time to wait\n+     * @return {@code true} if this client terminated and\n+     *         {@code false} if the timeout elapsed before termination\n+     * @throws InterruptedException if interrupted while waiting\n+     *\n+     * @see ##closing Implementation Note on closing the HttpClient\n+     *\n+     * @since 21\n+     *\/\n+    public boolean awaitTermination(Duration duration) throws InterruptedException {\n+        Objects.requireNonNull(duration);\n+        return true;\n+    }\n+\n+    \/**\n+     * Returns {@code true} if all operations have completed following\n+     * a shutdown.\n+     * Operations are any tasks required to run a request previously\n+     * submitted with {@code send} or {@code sendAsync} to completion.\n+     * <p> Note that {@code isTerminated} is never {@code true} unless\n+     * either {@code shutdown} or {@code shutdownNow} was called first.\n+     *\n+     * @implSpec\n+     * The default implementation of this method does nothing and returns false.\n+     * Subclasses should override this method to implement the proper behavior.\n+     *\n+     * @return {@code true} if all tasks have completed following a shutdown\n+     *\n+     * @see ##closing Implementation Note on closing the HttpClient\n+     *\n+     * @since 21\n+     *\/\n+    public boolean isTerminated() {\n+        return false;\n+    }\n+\n+    \/**\n+     * This method attempts to initiate an immediate shutdown.\n+     * An implementation of this method may attempt to\n+     * interrupt operations that are actively running.\n+     * Operations are any tasks required to run a request previously\n+     * submitted with {@code send} or {@code sendAsync} to completion.\n+     * The behavior of actively running operations when interrupted\n+     * is undefined. In particular, there is no guarantee that\n+     * interrupted operations will terminate, or that code waiting\n+     * on these operations will ever be notified.\n+     *\n+     * @implSpec\n+     * The default implementation of this method simply calls {@link #shutdown()}.\n+     * Subclasses should override this method to implement the appropriate\n+     * behavior.\n+     *\n+     * @see ##closing Implementation Note on closing the HttpClient\n+     *\n+     * @since 21\n+     *\/\n+    public void shutdownNow() {\n+        shutdown();\n+    }\n+\n+    \/**\n+     * Initiates an orderly shutdown in which  requests previously\n+     * submitted to {@code send} or {@code sendAsync}\n+     * are run to completion, but no new request will be accepted.\n+     * Running a request to completion may involve running several\n+     * operations in the background, including {@linkplain ##closing\n+     * waiting for responses to be delivered}.\n+     * This method waits until all operations have completed execution\n+     * and the client has terminated.\n+     *\n+     * <p> If interrupted while waiting, this method may attempt to stop all\n+     * operations by calling {@link #shutdownNow()}. It then continues to wait\n+     * until all actively executing operations have completed.\n+     * The interrupt status will be re-asserted before this method returns.\n+     *\n+     * <p> If already terminated, invoking this method has no effect.\n+     *\n+     * @implSpec\n+     * The default implementation invokes {@code shutdown()} and waits for tasks\n+     * to complete execution with {@code awaitTermination}.\n+     *\n+     * @see ##closing Implementation Note on closing the HttpClient\n+     *\n+     * @since 21\n+     *\/\n+    @Override\n+    public void close() {\n+        boolean terminated = isTerminated();\n+        if (!terminated) {\n+            shutdown();\n+            boolean interrupted = false;\n+            while (!terminated) {\n+                try {\n+                    terminated = awaitTermination(Duration.ofDays(1L));\n+                } catch (InterruptedException e) {\n+                    if (!interrupted) {\n+                        interrupted = true;\n+                        shutdownNow();\n+                        if (isTerminated()) break;\n+                    }\n+                }\n+            }\n+            if (interrupted) {\n+                Thread.currentThread().interrupt();\n+            }\n+        }\n+    }\n+\n","filename":"src\/java.net.http\/share\/classes\/java\/net\/http\/HttpClient.java","additions":187,"deletions":5,"binary":false,"changes":192,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -170,0 +170,25 @@\n+    @Override\n+    public boolean isTerminated() {\n+        return impl.isTerminated();\n+    }\n+\n+    @Override\n+    public void shutdown() {\n+        impl.shutdown();\n+    }\n+\n+    @Override\n+    public void shutdownNow() {\n+        impl.shutdownNow();\n+    }\n+\n+    @Override\n+    public boolean awaitTermination(Duration duration) throws InterruptedException {\n+        return impl.awaitTermination(duration);\n+    }\n+\n+    @Override\n+    public void close() {\n+        impl.close();\n+    }\n+\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/HttpClientFacade.java","additions":26,"deletions":1,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,1 +51,0 @@\n-import java.nio.channels.SocketChannel;\n@@ -407,0 +406,1 @@\n+    private volatile boolean shutdownRequested;\n@@ -609,0 +609,23 @@\n+    @Override\n+    public void shutdown() {\n+        shutdownRequested = true;\n+        selmgr.wakeupSelector();\n+    }\n+\n+    @Override\n+    public void shutdownNow() {\n+        shutdown();\n+        selmgr.abort(new IOException(\"shutdownNow\"));\n+    }\n+\n+    @Override\n+    public boolean awaitTermination(Duration duration) throws InterruptedException {\n+        \/\/ Implicit NPE will be thrown if duration is null\n+        return selmgr.join(duration);\n+    }\n+\n+    @Override\n+    public boolean isTerminated() {\n+        return isStarted.get() && !isAlive.get();\n+    }\n+\n@@ -632,3 +655,5 @@\n-        if (openedConnections.add(plainHttpConnection)) {\n-            pendingTCPConnectionCount.incrementAndGet();\n-        }\n+        if (!finished()) {\n+            if (openedConnections.add(plainHttpConnection)) {\n+                pendingTCPConnectionCount.incrementAndGet();\n+            }\n+        } else closeConnection(plainHttpConnection);\n@@ -668,1 +693,1 @@\n-        if (count == 0 && facadeRef.refersTo(null)) {\n+        if (count == 0 && (facadeRef.refersTo(null) || shutdownRequested)) {\n@@ -690,1 +715,1 @@\n-        if (count == 0 && facadeRef.refersTo(null)) {\n+        if (count == 0 && (facadeRef.refersTo(null) || shutdownRequested)) {\n@@ -712,1 +737,1 @@\n-        if (count == 0 && facadeRef.refersTo(null)) {\n+        if (count == 0 && (facadeRef.refersTo(null) || shutdownRequested)) {\n@@ -827,1 +852,12 @@\n-    boolean isReferenced() {\n+    boolean finished() {\n+        if (referenceCount() > 0) return false;\n+        if (shutdownRequested) {\n+            synchronized (this) {\n+                \/\/ avoid race with sendAsync\n+                if (referenceCount() == 0) return true;\n+            }\n+        }\n+        return !isReferenced();\n+    }\n+\n+    private boolean isReferenced() {\n@@ -958,0 +994,4 @@\n+        if (shutdownRequested) {\n+            return MinimalFuture.failedFuture(new IOException(\"closed\"));\n+        }\n+\n@@ -975,1 +1015,6 @@\n-        requestReference();\n+        synchronized (this) {\n+            if (shutdownRequested) {\n+                return MinimalFuture.failedFuture(new IOException(\"closed\"));\n+            }\n+            requestReference();\n+        }\n@@ -1264,1 +1309,1 @@\n-                    if (!owner.isReferenced()) {\n+                    if (owner.finished()) {\n@@ -1267,1 +1312,1 @@\n-                                \"HttpClient no longer referenced. Exiting...\");\n+                                \"HttpClient finished. Exiting...\");\n@@ -1308,1 +1353,1 @@\n-                        if (!owner.isReferenced()) {\n+                        if (owner.finished()) {\n@@ -1311,1 +1356,1 @@\n-                                    \"HttpClient no longer referenced. Exiting...\");\n+                                    \"HttpClient finished. Exiting...\");\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/HttpClientImpl.java","additions":59,"deletions":14,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -143,3 +143,4 @@\n-                client().connectionOpened(PlainHttpConnection.this);\n-                \/\/ complete async since the event runs on the SelectorManager thread\n-                cf.completeAsync(() -> ConnectState.SUCCESS, client().theExecutor());\n+                if (connectionOpened()) {\n+                    \/\/ complete async since the event runs on the SelectorManager thread\n+                    cf.completeAsync(() -> ConnectState.SUCCESS, client().theExecutor());\n+                } else throw new ConnectException(\"Connection closed\");\n@@ -216,2 +217,3 @@\n-                client().connectionOpened(this);\n-                cf.complete(ConnectState.SUCCESS);\n+                if (connectionOpened()) {\n+                    cf.complete(ConnectState.SUCCESS);\n+                } else throw new ConnectException(\"connection closed\");\n@@ -239,0 +241,12 @@\n+    boolean connectionOpened() {\n+        boolean closed = this.closed;\n+        if (closed) return false;\n+        synchronized (this) {\n+            closed = this.closed;\n+            if (!closed) {\n+                client().connectionOpened(this);\n+            }\n+        }\n+        return !closed;\n+    }\n+\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/PlainHttpConnection.java","additions":19,"deletions":5,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.io.Serial;\n@@ -65,0 +66,1 @@\n+        @Serial\n@@ -77,1 +79,10 @@\n-    private enum Phase { PREAMBLE, BODY, POSTAMBLE }\n+    private enum Phase {\n+        \/** The initial part of an HTML file up to and including the {@code body} and possible {@code <main>} tag. *\/\n+        PREAMBLE,\n+        \/** The initial part of a doc comment, or the rich-text content of a block tag. *\/\n+        BODY,\n+        \/** The end of an HTML file, from and including the {@code <\/main>} or {@code <\/body>} tag. *\/\n+        POSTAMBLE,\n+        \/** The rich-text content of an inline documentation comment tag. *\/\n+        INLINE\n+    }\n@@ -120,4 +131,0 @@\n-    public DocCommentParser(ParserFactory fac) {\n-        this(fac, null, null, false);\n-    }\n-\n@@ -133,2 +140,2 @@\n-        List<DCTree> preamble = isFileContent ? blockContent(Phase.PREAMBLE) : List.nil();\n-        List<DCTree> body = blockContent(Phase.BODY);\n+        List<DCTree> preamble = isFileContent ? content(Phase.PREAMBLE) : List.nil();\n+        List<DCTree> body = content(Phase.BODY);\n@@ -136,1 +143,1 @@\n-        List<DCTree> postamble = isFileContent ? blockContent(Phase.POSTAMBLE) : List.nil();\n+        List<DCTree> postamble = isFileContent ? content(Phase.POSTAMBLE) : List.nil();\n@@ -150,2 +157,1 @@\n-            case '\\f': case '\\n': case '\\r':\n-                newline = true;\n+            case '\\f', '\\n', '\\r' -> newline = true;\n@@ -160,1 +166,1 @@\n-        return blockContent(Phase.BODY);\n+        return content(Phase.BODY);\n@@ -164,3 +170,20 @@\n-     * Read block content, consisting of text, html and inline tags.\n-     * Terminated by the end of input, or the beginning of the next block tag:\n-     * that is, @ as the first non-whitespace character on a line.\n+     * Reads \"rich text\" content, consisting of text, html and inline tags,\n+     * according to the given {@code phase}.\n+     *\n+     * Inline tags are only recognized in {@code BODY} and {@code INLINE}\n+     * phases, and not in {@code PREAMBLE} and {@code POSTAMBLE} phases.\n+     *\n+     * The end of the content is dependent on the phase:\n+     *\n+     * <ul>\n+     * <li>{@code PREAMBLE}: the appearance of {@code <body>} (or {@code <main>}),\n+     *      as determined by {@link #isEndPreamble()}\n+     * <li>{@code BODY}: the beginning of a block tag, or when readung from\n+     *      an HTML file, the appearance of {@code <\/main>} (or {@code <\/body>},\n+     *       as determined by {@link #isEndBody()}\n+     * <li>{@code INLINE}: '}', after skipping any matching {@code { }}\n+     * <li>{@code PREAMBLE}: end of file\n+     * <\/ul>\n+     *\n+     *\n+     *\n@@ -168,2 +191,1 @@\n-    @SuppressWarnings(\"fallthrough\")\n-    protected List<DCTree> blockContent(Phase phase) {\n+    protected List<DCTree> content(Phase phase) {\n@@ -173,0 +195,3 @@\n+        int depth = phase == Phase.INLINE ? 1 : -1; \/\/ only used when phase is INLINE\n+        int pos = bp;                               \/\/ only used when phase is INLINE\n+\n@@ -176,2 +201,1 @@\n-                case '\\n': case '\\r': case '\\f':\n-                case ' ': case '\\t':\n+                case '\\n', '\\r', '\\f', ' ', '\\t' ->\n@@ -179,1 +203,0 @@\n-                    break;\n@@ -181,1 +204,1 @@\n-                case '&':\n+                case '&' ->\n@@ -183,1 +206,0 @@\n-                    break;\n@@ -185,1 +207,1 @@\n-                case '<':\n+                case '<' -> {\n@@ -189,1 +211,1 @@\n-                            case PREAMBLE:\n+                            case PREAMBLE -> {\n@@ -200,2 +222,2 @@\n-                                break;\n-                            case BODY:\n+                            }\n+                            case BODY -> {\n@@ -206,3 +228,4 @@\n-                                break;\n-                            default:\n-                                \/\/ fallthrough\n+                            }\n+\n+                            default -> {\n+                            }\n@@ -221,1 +244,13 @@\n-                    break;\n+                }\n+\n+                case '{' -> {\n+                    switch (phase) {\n+                        case PREAMBLE, POSTAMBLE -> defaultContentCharacter();\n+                        case BODY -> inlineTag(trees);\n+                        case INLINE -> {\n+                            if (!inlineTag(trees)) {\n+                                depth++;\n+                            }\n+                        }\n+                    }\n+                }\n@@ -223,3 +258,13 @@\n-                case '{':\n-                    inlineTag(trees);\n-                    break;\n+                case '}' -> {\n+                    if (phase == Phase.INLINE) {\n+                        newline = false;\n+                        if (--depth == 0) {\n+                            addPendingText(trees, bp - 1);\n+                            nextChar();\n+                            return trees.toList();\n+                        }\n+                        nextChar();\n+                    } else {\n+                        defaultContentCharacter();\n+                    }\n+                }\n@@ -227,1 +272,1 @@\n-                case '@':\n+                case '@' -> {\n@@ -242,1 +287,1 @@\n-                        } else {\n+                        } else if (phase == Phase.BODY) {\n@@ -255,1 +300,2 @@\n-                    \/\/ fallthrough\n+                    defaultContentCharacter();\n+                }\n@@ -257,6 +303,3 @@\n-                default:\n-                    newline = false;\n-                    if (textStart == -1)\n-                        textStart = bp;\n-                    lastNonWhite = bp;\n-                    nextChar();\n+                default -> {\n+                    defaultContentCharacter();\n+                }\n@@ -269,1 +312,11 @@\n-        return trees.toList();\n+        return (phase == Phase.INLINE)\n+                ? List.of(erroneous(\"dc.unterminated.inline.tag\", pos))\n+                : trees.toList();\n+    }\n+\n+    void defaultContentCharacter() {\n+        newline = false;\n+        if (textStart == -1)\n+            textStart = bp;\n+        lastNonWhite = bp;\n+        nextChar();\n@@ -317,1 +370,15 @@\n-    protected void inlineTag(ListBuffer<DCTree> list) {\n+    \/**\n+     * Reads a possible inline tag, after finding an opening brace <code>{<\/code> character.\n+     *\n+     * If the next character is {@code @}, an opening tag is read and added to the\n+     * given {@code list}, and the result is {@code true}.\n+     *\n+     * Otherwise, the {@code list} is updated with the characters that have been read,\n+     * and the result is {@code false}. The result also indicates that a single\n+     * opening brace was read, and that a corresponding closing brace should eventually\n+     * be read.\n+     *\n+     * @param list the list of trees being accumulated\n+     * @return {@code true} if an inline tag was read, and {@code false} otherwise\n+     *\/\n+    protected boolean inlineTag(ListBuffer<DCTree> list) {\n@@ -338,0 +405,1 @@\n+                return true;\n@@ -344,0 +412,1 @@\n+        return false;\n@@ -392,2 +461,2 @@\n-     * Matching pairs of { } are skipped; the text is terminated by the first\n-     * unmatched }. It is an error if the beginning of the next tag is detected.\n+     * Matching pairs of '{' '}' are skipped; the text is terminated by the first\n+     * unmatched '}'. It is an error if the beginning of the next tag is detected.\n@@ -397,1 +466,1 @@\n-            case REMOVE_ALL:\n+            case REMOVE_ALL -> {\n@@ -399,2 +468,3 @@\n-                break;\n-            case REMOVE_FIRST_SPACE:\n+            }\n+\n+            case REMOVE_FIRST_SPACE -> {\n@@ -403,5 +473,1 @@\n-                break;\n-            case RETAIN_ALL:\n-            default:\n-                \/\/ do nothing\n-                break;\n+            }\n@@ -409,0 +475,1 @@\n+            case RETAIN_ALL -> { }\n@@ -413,1 +480,0 @@\n-        loop:\n@@ -416,3 +482,2 @@\n-                case '\\n': case '\\r': case '\\f':\n-                case ' ': case '\\t':\n-                    break;\n+                case '\\n', '\\r', '\\f', ' ', '\\t' -> {\n+                }\n@@ -420,1 +485,1 @@\n-                case '{':\n+                case '{' -> {\n@@ -424,1 +489,1 @@\n-                    break;\n+                }\n@@ -426,1 +491,1 @@\n-                case '}':\n+                case '}' -> {\n@@ -432,1 +497,1 @@\n-                    break;\n+                }\n@@ -434,1 +499,1 @@\n-                default:\n+                default -> {\n@@ -437,1 +502,1 @@\n-                    break;\n+                }\n@@ -447,1 +512,1 @@\n-     * unmatched }. It is an error if the beginning of the next tag is detected.\n+     * unmatched '}'. It is an error if the beginning of the next tag is detected.\n@@ -450,1 +515,0 @@\n-    @SuppressWarnings(\"fallthrough\")\n@@ -460,2 +524,2 @@\n-                case '\\n': case '\\r': case '\\f':\n-                case ' ': case '\\t':\n+\n+                case '\\n', '\\r', '\\f', ' ', '\\t' -> {\n@@ -464,1 +528,1 @@\n-                    break;\n+                }\n@@ -466,2 +530,1 @@\n-                case '(':\n-                case '<':\n+                case '(', '<' -> {\n@@ -470,1 +533,1 @@\n-                    break;\n+                }\n@@ -472,2 +535,1 @@\n-                case ')':\n-                case '>':\n+                case ')', '>' -> {\n@@ -476,1 +538,1 @@\n-                    break;\n+                }\n@@ -478,1 +540,1 @@\n-                case '}':\n+                case '}' -> {\n@@ -483,0 +545,1 @@\n+                }\n@@ -484,1 +547,1 @@\n-                case '@':\n+                case '@' -> {\n@@ -487,1 +550,1 @@\n-                    \/\/ fallthrough\n+                }\n@@ -489,1 +552,1 @@\n-                default:\n+                default -> {\n@@ -491,0 +554,1 @@\n+                }\n@@ -537,3 +601,1 @@\n-                case '\\n': case '\\r': case '\\f':\n-                case ' ': case '\\t':\n-                    break;\n+                case '\\n', '\\r', '\\f', ' ', '\\t' -> { }\n@@ -541,1 +603,1 @@\n-                case '\"':\n+                case '\"' -> {\n@@ -545,0 +607,1 @@\n+                }\n@@ -546,1 +609,1 @@\n-                case '@':\n+                case '@' -> {\n@@ -549,1 +612,1 @@\n-\n+                }\n@@ -566,2 +629,1 @@\n-                case '\\n':\n-                case '\\r': case '\\f': case ' ': case '\\t':\n+                case '\\n', '\\r', '\\f', ' ', '\\t' -> {\n@@ -569,0 +631,1 @@\n+                }\n@@ -570,1 +633,1 @@\n-                case '@':\n+                case '@' -> {\n@@ -573,1 +636,1 @@\n-                    break;\n+                }\n@@ -575,1 +638,1 @@\n-                case '{':\n+                case '{' -> {\n@@ -577,1 +640,1 @@\n-                    break;\n+                }\n@@ -579,1 +642,1 @@\n-                case '}':\n+                case '}' -> {\n@@ -583,1 +646,1 @@\n-                    break;\n+                }\n@@ -593,2 +656,2 @@\n-     * Matching pairs of { } are skipped; the text is terminated by the first\n-     * unmatched }. It is an error if the beginning of the next tag is detected.\n+     * Matching pairs of '{' '}' are skipped; the text is terminated by the first\n+     * unmatched '}'. It is an error if the beginning of the next tag is detected.\n@@ -596,1 +659,0 @@\n-    @SuppressWarnings(\"fallthrough\")\n@@ -598,2 +660,0 @@\n-        ListBuffer<DCTree> trees = new ListBuffer<>();\n-\n@@ -601,86 +661,1 @@\n-        int pos = bp;\n-        int depth = 1;\n-        textStart = -1;\n-\n-        loop:\n-        while (bp < buflen) {\n-\n-            switch (ch) {\n-                case '\\n': case '\\r': case '\\f':\n-                case ' ': case '\\t':\n-                    nextChar();\n-                    break;\n-\n-                case '&':\n-                    entity(trees);\n-                    break;\n-\n-                case '<':\n-                    newline = false;\n-                    addPendingText(trees, bp - 1);\n-                    trees.add(html());\n-                    textStart = bp;\n-                    lastNonWhite = -1;\n-                    break;\n-\n-                case '{':\n-                    if (textStart == -1)\n-                        textStart = bp;\n-                    newline = false;\n-                    nextChar();\n-                    if (ch == '@') {\n-                        addPendingText(trees, bp - 2);\n-                        trees.add(inlineTag());\n-                        textStart = bp;\n-                        lastNonWhite = -1;\n-                    } else {\n-                        depth++;\n-                    }\n-                    break;\n-\n-                case '}':\n-                    newline = false;\n-                    if (--depth == 0) {\n-                        addPendingText(trees, bp - 1);\n-                        nextChar();\n-                        return trees.toList();\n-                    }\n-                    nextChar();\n-                    break;\n-\n-                case '@':\n-                    \/\/ check for context-sensitive escape sequences:\n-                    \/\/   newline whitespace @@\n-                    \/\/   newline whitespace @*\n-                    \/\/   *@\/\n-                    if (newline) {\n-                        char peek = peekChar();\n-                        if (peek == '@' || peek == '*') {\n-                            addPendingText(trees, bp - 1);\n-                            nextChar();\n-                            trees.add(m.at(bp - 1).newEscapeTree(ch));\n-                            newline = false;\n-                            nextChar();\n-                            textStart = bp;\n-                            break;\n-                        }\n-                    } else if (textStart != -1 && buf[bp - 1] == '*' && peekChar() == '\/') {\n-                        addPendingText(trees, bp - 1);\n-                        nextChar();\n-                        trees.add(m.at(bp - 1).newEscapeTree('\/'));\n-                        newline = false;\n-                        nextChar();\n-                        textStart = bp;\n-                        break;\n-                    }\n-                    \/\/ fallthrough\n-\n-                default:\n-                    if (textStart == -1)\n-                        textStart = bp;\n-                    nextChar();\n-                    break;\n-            }\n-        }\n-\n-        return List.of(erroneous(\"dc.unterminated.inline.tag\", pos));\n+        return content(Phase.INLINE);\n@@ -754,1 +729,1 @@\n-                    case \"body\":\n+                    case \"body\" -> {\n@@ -780,0 +755,1 @@\n+                    }\n@@ -781,1 +757,1 @@\n-                    case \"main\":\n+                    case \"main\" -> {\n@@ -784,0 +760,1 @@\n+                    }\n@@ -811,2 +788,1 @@\n-                        case \"body\":\n-                        case \"main\":\n+                        case \"body\", \"main\" -> {\n@@ -814,0 +790,1 @@\n+                        }\n@@ -853,2 +830,10 @@\n-     * Read the start or end of an HTML tag, or an HTML comment\n-     * {@literal <identifier attrs> } or {@literal <\/identifier> }\n+     * Reads an HTML construct, beginning with {@code <}.\n+     *\n+     * <ul>\n+     * <li>start element: {@code <identifier attrs> }\n+     * <li>end element: {@code <\/identifier> }\n+     * <li>comment: {@code <!-- ... -->}\n+     * <li>doctype: {@code <!doctype ... >}\n+     * <li>cdata: {@code <![CDATA[ ... ]]>}\n+     * <\/ul>\n+     *  or\n@@ -870,2 +855,1 @@\n-                    DCTree dctree = m.at(p).newStartElementTree(name, attrs, selfClosing).setEndPos(bp);\n-                    return dctree;\n+                    return m.at(p).newStartElementTree(name, attrs, selfClosing).setEndPos(bp);\n@@ -1014,10 +998,3 @@\n-            case '&':\n-                entity(list);\n-                break;\n-\n-            case '{':\n-                inlineTag(list);\n-                break;\n-\n-            default:\n-                nextChar();\n+            case '&' -> entity(list);\n+            case '{' -> inlineTag(list);\n+            default  -> nextChar();\n@@ -1067,1 +1044,1 @@\n-                case '\\f': case '\\n': case '\\r':\n+                case '\\f', '\\n', '\\r' -> {\n@@ -1069,4 +1046,5 @@\n-                    break;\n-                case '\\t': case ' ':\n-                    break;\n-                default:\n+                }\n+\n+                case '\\t', ' ' -> { }\n+\n+                default -> {\n@@ -1074,0 +1052,1 @@\n+                }\n@@ -1149,9 +1128,5 @@\n-        switch (ch) {\n-            case '\\f': case '\\n': case '\\r': case '\\t':\n-            case ' ':\n-            case '\"': case '\\'': case '`':\n-            case '=': case '<': case '>':\n-                return true;\n-            default:\n-                return false;\n-        }\n+        return switch (ch) {\n+            case '\\f', '\\n', '\\r', '\\t', ' ',\n+                    '\"', '\\'', '`', '=', '<', '>' -> true;\n+            default -> false;\n+        };\n@@ -1405,11 +1380,5 @@\n-                    List<DCTree> description;\n-                    switch (kind) {\n-                        case BLOCK:\n-                            description = blockContent();\n-                            break;\n-                        case INLINE:\n-                            description = inlineContent();\n-                            break;\n-                        default:\n-                            throw new IllegalArgumentException(kind.toString());\n-                    }\n+                    List<DCTree> description = switch (kind) {\n+                        case BLOCK -> blockContent();\n+                        case INLINE -> inlineContent();\n+                        default -> throw new IllegalArgumentException(kind.toString());\n+                    };\n@@ -1426,1 +1395,1 @@\n-                        case '\"':\n+                        case '\"' -> {\n@@ -1435,1 +1404,1 @@\n-                            break;\n+                        }\n@@ -1437,1 +1406,1 @@\n-                        case '<':\n+                        case '<' -> {\n@@ -1441,1 +1410,1 @@\n-                            break;\n+                        }\n@@ -1443,1 +1412,1 @@\n-                        case '@':\n+                        case '@' -> {\n@@ -1446,1 +1415,1 @@\n-                            break;\n+                        }\n@@ -1448,1 +1417,1 @@\n-                        case EOI:\n+                        case EOI -> {\n@@ -1451,1 +1420,1 @@\n-                            break;\n+                        }\n@@ -1453,1 +1422,1 @@\n-                        default:\n+                        default -> {\n@@ -1459,0 +1428,1 @@\n+                        }\n@@ -1616,1 +1586,1 @@\n-                public DCTree parse(int pos) throws ParseException {\n+                public DCTree parse(int pos) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/DocCommentParser.java","additions":206,"deletions":236,"binary":false,"changes":442,"status":"modified"},{"patch":"@@ -140,1 +140,2 @@\n-    public VectorMask<E> andNot(VectorMask<E> m) {\n+    @ForceInline\n+    public final VectorMask<E> andNot(VectorMask<E> m) {\n@@ -144,0 +145,6 @@\n+    @Override\n+    @ForceInline\n+    public final VectorMask<E> eq(VectorMask<E> m) {\n+        return xor(m.not());\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/AbstractMask.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -680,8 +680,0 @@\n-        @Override\n-        @ForceInline\n-        public Byte128Mask eq(VectorMask<Byte> mask) {\n-            Objects.requireNonNull(mask);\n-            Byte128Mask m = (Byte128Mask)mask;\n-            return xor(m.not());\n-        }\n-\n@@ -736,0 +728,1 @@\n+        @Override\n@@ -737,2 +730,1 @@\n-        \/* package-private *\/\n-        Byte128Mask xor(VectorMask<Byte> mask) {\n+        public Byte128Mask xor(VectorMask<Byte> mask) {\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte128Vector.java","additions":2,"deletions":10,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -712,8 +712,0 @@\n-        @Override\n-        @ForceInline\n-        public Byte256Mask eq(VectorMask<Byte> mask) {\n-            Objects.requireNonNull(mask);\n-            Byte256Mask m = (Byte256Mask)mask;\n-            return xor(m.not());\n-        }\n-\n@@ -768,0 +760,1 @@\n+        @Override\n@@ -769,2 +762,1 @@\n-        \/* package-private *\/\n-        Byte256Mask xor(VectorMask<Byte> mask) {\n+        public Byte256Mask xor(VectorMask<Byte> mask) {\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte256Vector.java","additions":2,"deletions":10,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -776,8 +776,0 @@\n-        @Override\n-        @ForceInline\n-        public Byte512Mask eq(VectorMask<Byte> mask) {\n-            Objects.requireNonNull(mask);\n-            Byte512Mask m = (Byte512Mask)mask;\n-            return xor(m.not());\n-        }\n-\n@@ -832,0 +824,1 @@\n+        @Override\n@@ -833,2 +826,1 @@\n-        \/* package-private *\/\n-        Byte512Mask xor(VectorMask<Byte> mask) {\n+        public Byte512Mask xor(VectorMask<Byte> mask) {\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte512Vector.java","additions":2,"deletions":10,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -664,8 +664,0 @@\n-        @Override\n-        @ForceInline\n-        public Byte64Mask eq(VectorMask<Byte> mask) {\n-            Objects.requireNonNull(mask);\n-            Byte64Mask m = (Byte64Mask)mask;\n-            return xor(m.not());\n-        }\n-\n@@ -720,0 +712,1 @@\n+        @Override\n@@ -721,2 +714,1 @@\n-        \/* package-private *\/\n-        Byte64Mask xor(VectorMask<Byte> mask) {\n+        public Byte64Mask xor(VectorMask<Byte> mask) {\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte64Vector.java","additions":2,"deletions":10,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -650,8 +650,0 @@\n-        @Override\n-        @ForceInline\n-        public ByteMaxMask eq(VectorMask<Byte> mask) {\n-            Objects.requireNonNull(mask);\n-            ByteMaxMask m = (ByteMaxMask)mask;\n-            return xor(m.not());\n-        }\n-\n@@ -706,0 +698,1 @@\n+        @Override\n@@ -707,2 +700,1 @@\n-        \/* package-private *\/\n-        ByteMaxMask xor(VectorMask<Byte> mask) {\n+        public ByteMaxMask xor(VectorMask<Byte> mask) {\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteMaxVector.java","additions":2,"deletions":10,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -641,8 +641,0 @@\n-        @Override\n-        @ForceInline\n-        public Double128Mask eq(VectorMask<Double> mask) {\n-            Objects.requireNonNull(mask);\n-            Double128Mask m = (Double128Mask)mask;\n-            return xor(m.not());\n-        }\n-\n@@ -697,0 +689,1 @@\n+        @Override\n@@ -698,2 +691,1 @@\n-        \/* package-private *\/\n-        Double128Mask xor(VectorMask<Double> mask) {\n+        public Double128Mask xor(VectorMask<Double> mask) {\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double128Vector.java","additions":2,"deletions":10,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -645,8 +645,0 @@\n-        @Override\n-        @ForceInline\n-        public Double256Mask eq(VectorMask<Double> mask) {\n-            Objects.requireNonNull(mask);\n-            Double256Mask m = (Double256Mask)mask;\n-            return xor(m.not());\n-        }\n-\n@@ -701,0 +693,1 @@\n+        @Override\n@@ -702,2 +695,1 @@\n-        \/* package-private *\/\n-        Double256Mask xor(VectorMask<Double> mask) {\n+        public Double256Mask xor(VectorMask<Double> mask) {\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double256Vector.java","additions":2,"deletions":10,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -653,8 +653,0 @@\n-        @Override\n-        @ForceInline\n-        public Double512Mask eq(VectorMask<Double> mask) {\n-            Objects.requireNonNull(mask);\n-            Double512Mask m = (Double512Mask)mask;\n-            return xor(m.not());\n-        }\n-\n@@ -709,0 +701,1 @@\n+        @Override\n@@ -710,2 +703,1 @@\n-        \/* package-private *\/\n-        Double512Mask xor(VectorMask<Double> mask) {\n+        public Double512Mask xor(VectorMask<Double> mask) {\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double512Vector.java","additions":2,"deletions":10,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -639,8 +639,0 @@\n-        @Override\n-        @ForceInline\n-        public Double64Mask eq(VectorMask<Double> mask) {\n-            Objects.requireNonNull(mask);\n-            Double64Mask m = (Double64Mask)mask;\n-            return xor(m.not());\n-        }\n-\n@@ -695,0 +687,1 @@\n+        @Override\n@@ -696,2 +689,1 @@\n-        \/* package-private *\/\n-        Double64Mask xor(VectorMask<Double> mask) {\n+        public Double64Mask xor(VectorMask<Double> mask) {\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double64Vector.java","additions":2,"deletions":10,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -638,8 +638,0 @@\n-        @Override\n-        @ForceInline\n-        public DoubleMaxMask eq(VectorMask<Double> mask) {\n-            Objects.requireNonNull(mask);\n-            DoubleMaxMask m = (DoubleMaxMask)mask;\n-            return xor(m.not());\n-        }\n-\n@@ -694,0 +686,1 @@\n+        @Override\n@@ -695,2 +688,1 @@\n-        \/* package-private *\/\n-        DoubleMaxMask xor(VectorMask<Double> mask) {\n+        public DoubleMaxMask xor(VectorMask<Double> mask) {\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleMaxVector.java","additions":2,"deletions":10,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -645,8 +645,0 @@\n-        @Override\n-        @ForceInline\n-        public Float128Mask eq(VectorMask<Float> mask) {\n-            Objects.requireNonNull(mask);\n-            Float128Mask m = (Float128Mask)mask;\n-            return xor(m.not());\n-        }\n-\n@@ -701,0 +693,1 @@\n+        @Override\n@@ -702,2 +695,1 @@\n-        \/* package-private *\/\n-        Float128Mask xor(VectorMask<Float> mask) {\n+        public Float128Mask xor(VectorMask<Float> mask) {\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float128Vector.java","additions":2,"deletions":10,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -653,8 +653,0 @@\n-        @Override\n-        @ForceInline\n-        public Float256Mask eq(VectorMask<Float> mask) {\n-            Objects.requireNonNull(mask);\n-            Float256Mask m = (Float256Mask)mask;\n-            return xor(m.not());\n-        }\n-\n@@ -709,0 +701,1 @@\n+        @Override\n@@ -710,2 +703,1 @@\n-        \/* package-private *\/\n-        Float256Mask xor(VectorMask<Float> mask) {\n+        public Float256Mask xor(VectorMask<Float> mask) {\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float256Vector.java","additions":2,"deletions":10,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -669,8 +669,0 @@\n-        @Override\n-        @ForceInline\n-        public Float512Mask eq(VectorMask<Float> mask) {\n-            Objects.requireNonNull(mask);\n-            Float512Mask m = (Float512Mask)mask;\n-            return xor(m.not());\n-        }\n-\n@@ -725,0 +717,1 @@\n+        @Override\n@@ -726,2 +719,1 @@\n-        \/* package-private *\/\n-        Float512Mask xor(VectorMask<Float> mask) {\n+        public Float512Mask xor(VectorMask<Float> mask) {\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float512Vector.java","additions":2,"deletions":10,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -641,8 +641,0 @@\n-        @Override\n-        @ForceInline\n-        public Float64Mask eq(VectorMask<Float> mask) {\n-            Objects.requireNonNull(mask);\n-            Float64Mask m = (Float64Mask)mask;\n-            return xor(m.not());\n-        }\n-\n@@ -697,0 +689,1 @@\n+        @Override\n@@ -698,2 +691,1 @@\n-        \/* package-private *\/\n-        Float64Mask xor(VectorMask<Float> mask) {\n+        public Float64Mask xor(VectorMask<Float> mask) {\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float64Vector.java","additions":2,"deletions":10,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -638,8 +638,0 @@\n-        @Override\n-        @ForceInline\n-        public FloatMaxMask eq(VectorMask<Float> mask) {\n-            Objects.requireNonNull(mask);\n-            FloatMaxMask m = (FloatMaxMask)mask;\n-            return xor(m.not());\n-        }\n-\n@@ -694,0 +686,1 @@\n+        @Override\n@@ -695,2 +688,1 @@\n-        \/* package-private *\/\n-        FloatMaxMask xor(VectorMask<Float> mask) {\n+        public FloatMaxMask xor(VectorMask<Float> mask) {\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatMaxVector.java","additions":2,"deletions":10,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -656,8 +656,0 @@\n-        @Override\n-        @ForceInline\n-        public Int128Mask eq(VectorMask<Integer> mask) {\n-            Objects.requireNonNull(mask);\n-            Int128Mask m = (Int128Mask)mask;\n-            return xor(m.not());\n-        }\n-\n@@ -712,0 +704,1 @@\n+        @Override\n@@ -713,2 +706,1 @@\n-        \/* package-private *\/\n-        Int128Mask xor(VectorMask<Integer> mask) {\n+        public Int128Mask xor(VectorMask<Integer> mask) {\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int128Vector.java","additions":2,"deletions":10,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -664,8 +664,0 @@\n-        @Override\n-        @ForceInline\n-        public Int256Mask eq(VectorMask<Integer> mask) {\n-            Objects.requireNonNull(mask);\n-            Int256Mask m = (Int256Mask)mask;\n-            return xor(m.not());\n-        }\n-\n@@ -720,0 +712,1 @@\n+        @Override\n@@ -721,2 +714,1 @@\n-        \/* package-private *\/\n-        Int256Mask xor(VectorMask<Integer> mask) {\n+        public Int256Mask xor(VectorMask<Integer> mask) {\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int256Vector.java","additions":2,"deletions":10,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -680,8 +680,0 @@\n-        @Override\n-        @ForceInline\n-        public Int512Mask eq(VectorMask<Integer> mask) {\n-            Objects.requireNonNull(mask);\n-            Int512Mask m = (Int512Mask)mask;\n-            return xor(m.not());\n-        }\n-\n@@ -736,0 +728,1 @@\n+        @Override\n@@ -737,2 +730,1 @@\n-        \/* package-private *\/\n-        Int512Mask xor(VectorMask<Integer> mask) {\n+        public Int512Mask xor(VectorMask<Integer> mask) {\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int512Vector.java","additions":2,"deletions":10,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -652,8 +652,0 @@\n-        @Override\n-        @ForceInline\n-        public Int64Mask eq(VectorMask<Integer> mask) {\n-            Objects.requireNonNull(mask);\n-            Int64Mask m = (Int64Mask)mask;\n-            return xor(m.not());\n-        }\n-\n@@ -708,0 +700,1 @@\n+        @Override\n@@ -709,2 +702,1 @@\n-        \/* package-private *\/\n-        Int64Mask xor(VectorMask<Integer> mask) {\n+        public Int64Mask xor(VectorMask<Integer> mask) {\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int64Vector.java","additions":2,"deletions":10,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -650,8 +650,0 @@\n-        @Override\n-        @ForceInline\n-        public IntMaxMask eq(VectorMask<Integer> mask) {\n-            Objects.requireNonNull(mask);\n-            IntMaxMask m = (IntMaxMask)mask;\n-            return xor(m.not());\n-        }\n-\n@@ -706,0 +698,1 @@\n+        @Override\n@@ -707,2 +700,1 @@\n-        \/* package-private *\/\n-        IntMaxMask xor(VectorMask<Integer> mask) {\n+        public IntMaxMask xor(VectorMask<Integer> mask) {\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntMaxVector.java","additions":2,"deletions":10,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -642,8 +642,0 @@\n-        @Override\n-        @ForceInline\n-        public Long128Mask eq(VectorMask<Long> mask) {\n-            Objects.requireNonNull(mask);\n-            Long128Mask m = (Long128Mask)mask;\n-            return xor(m.not());\n-        }\n-\n@@ -698,0 +690,1 @@\n+        @Override\n@@ -699,2 +692,1 @@\n-        \/* package-private *\/\n-        Long128Mask xor(VectorMask<Long> mask) {\n+        public Long128Mask xor(VectorMask<Long> mask) {\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long128Vector.java","additions":2,"deletions":10,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -646,8 +646,0 @@\n-        @Override\n-        @ForceInline\n-        public Long256Mask eq(VectorMask<Long> mask) {\n-            Objects.requireNonNull(mask);\n-            Long256Mask m = (Long256Mask)mask;\n-            return xor(m.not());\n-        }\n-\n@@ -702,0 +694,1 @@\n+        @Override\n@@ -703,2 +696,1 @@\n-        \/* package-private *\/\n-        Long256Mask xor(VectorMask<Long> mask) {\n+        public Long256Mask xor(VectorMask<Long> mask) {\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long256Vector.java","additions":2,"deletions":10,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -654,8 +654,0 @@\n-        @Override\n-        @ForceInline\n-        public Long512Mask eq(VectorMask<Long> mask) {\n-            Objects.requireNonNull(mask);\n-            Long512Mask m = (Long512Mask)mask;\n-            return xor(m.not());\n-        }\n-\n@@ -710,0 +702,1 @@\n+        @Override\n@@ -711,2 +704,1 @@\n-        \/* package-private *\/\n-        Long512Mask xor(VectorMask<Long> mask) {\n+        public Long512Mask xor(VectorMask<Long> mask) {\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long512Vector.java","additions":2,"deletions":10,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -640,8 +640,0 @@\n-        @Override\n-        @ForceInline\n-        public Long64Mask eq(VectorMask<Long> mask) {\n-            Objects.requireNonNull(mask);\n-            Long64Mask m = (Long64Mask)mask;\n-            return xor(m.not());\n-        }\n-\n@@ -696,0 +688,1 @@\n+        @Override\n@@ -697,2 +690,1 @@\n-        \/* package-private *\/\n-        Long64Mask xor(VectorMask<Long> mask) {\n+        public Long64Mask xor(VectorMask<Long> mask) {\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long64Vector.java","additions":2,"deletions":10,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -640,8 +640,0 @@\n-        @Override\n-        @ForceInline\n-        public LongMaxMask eq(VectorMask<Long> mask) {\n-            Objects.requireNonNull(mask);\n-            LongMaxMask m = (LongMaxMask)mask;\n-            return xor(m.not());\n-        }\n-\n@@ -696,0 +688,1 @@\n+        @Override\n@@ -697,2 +690,1 @@\n-        \/* package-private *\/\n-        LongMaxMask xor(VectorMask<Long> mask) {\n+        public LongMaxMask xor(VectorMask<Long> mask) {\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongMaxVector.java","additions":2,"deletions":10,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -664,8 +664,0 @@\n-        @Override\n-        @ForceInline\n-        public Short128Mask eq(VectorMask<Short> mask) {\n-            Objects.requireNonNull(mask);\n-            Short128Mask m = (Short128Mask)mask;\n-            return xor(m.not());\n-        }\n-\n@@ -720,0 +712,1 @@\n+        @Override\n@@ -721,2 +714,1 @@\n-        \/* package-private *\/\n-        Short128Mask xor(VectorMask<Short> mask) {\n+        public Short128Mask xor(VectorMask<Short> mask) {\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short128Vector.java","additions":2,"deletions":10,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -680,8 +680,0 @@\n-        @Override\n-        @ForceInline\n-        public Short256Mask eq(VectorMask<Short> mask) {\n-            Objects.requireNonNull(mask);\n-            Short256Mask m = (Short256Mask)mask;\n-            return xor(m.not());\n-        }\n-\n@@ -736,0 +728,1 @@\n+        @Override\n@@ -737,2 +730,1 @@\n-        \/* package-private *\/\n-        Short256Mask xor(VectorMask<Short> mask) {\n+        public Short256Mask xor(VectorMask<Short> mask) {\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short256Vector.java","additions":2,"deletions":10,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -712,8 +712,0 @@\n-        @Override\n-        @ForceInline\n-        public Short512Mask eq(VectorMask<Short> mask) {\n-            Objects.requireNonNull(mask);\n-            Short512Mask m = (Short512Mask)mask;\n-            return xor(m.not());\n-        }\n-\n@@ -768,0 +760,1 @@\n+        @Override\n@@ -769,2 +762,1 @@\n-        \/* package-private *\/\n-        Short512Mask xor(VectorMask<Short> mask) {\n+        public Short512Mask xor(VectorMask<Short> mask) {\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short512Vector.java","additions":2,"deletions":10,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -656,8 +656,0 @@\n-        @Override\n-        @ForceInline\n-        public Short64Mask eq(VectorMask<Short> mask) {\n-            Objects.requireNonNull(mask);\n-            Short64Mask m = (Short64Mask)mask;\n-            return xor(m.not());\n-        }\n-\n@@ -712,0 +704,1 @@\n+        @Override\n@@ -713,2 +706,1 @@\n-        \/* package-private *\/\n-        Short64Mask xor(VectorMask<Short> mask) {\n+        public Short64Mask xor(VectorMask<Short> mask) {\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short64Vector.java","additions":2,"deletions":10,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -650,8 +650,0 @@\n-        @Override\n-        @ForceInline\n-        public ShortMaxMask eq(VectorMask<Short> mask) {\n-            Objects.requireNonNull(mask);\n-            ShortMaxMask m = (ShortMaxMask)mask;\n-            return xor(m.not());\n-        }\n-\n@@ -706,0 +698,1 @@\n+        @Override\n@@ -707,2 +700,1 @@\n-        \/* package-private *\/\n-        ShortMaxMask xor(VectorMask<Short> mask) {\n+        public ShortMaxMask xor(VectorMask<Short> mask) {\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortMaxVector.java","additions":2,"deletions":10,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -401,3 +401,2 @@\n-     * Determines logical equivalence of this mask\n-     * to a second input mask (as boolean {@code a==b}\n-     * or {@code a^~b}).\n+     * Determines logical symmetric difference\n+     * (as {@code a^b}) of this mask and a second input mask.\n@@ -405,4 +404,3 @@\n-     * This is a lane-wise binary operation tests each\n-     * corresponding pair of mask bits for equality.\n-     * It is also equivalent to a inverse {@code XOR}\n-     * operation ({@code ^~}) on the mask bits.\n+     * This is a lane-wise binary operation which applies\n+     * the logical {@code XOR} operation\n+     * ({@code ^}) to each corresponding pair of mask bits.\n@@ -411,2 +409,2 @@\n-     * @return a mask showing where the two input masks were equal\n-     * @see #equals\n+     * @return the result of logically disjunctively disjoining the two\n+     * input masks\n@@ -414,1 +412,1 @@\n-    public abstract VectorMask<E> eq(VectorMask<E> m);\n+    public abstract VectorMask<E> xor(VectorMask<E> m);\n@@ -429,0 +427,17 @@\n+    \/**\n+     * Determines logical equivalence of this mask\n+     * to a second input mask (as boolean {@code a==b}\n+     * or {@code a^~b}).\n+     * <p>\n+     * This is a lane-wise binary operation tests each\n+     * corresponding pair of mask bits for equality.\n+     * It is also equivalent to the logical {@code XNOR}\n+     * operation ({@code ^~}) to each corresponding pair\n+     * of mask bits.\n+     *\n+     * @param m the input mask\n+     * @return a mask showing where the two input masks were equal\n+     * @see #equals\n+     *\/\n+    public abstract VectorMask<E> eq(VectorMask<E> m);\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/VectorMask.java","additions":25,"deletions":10,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -923,8 +923,0 @@\n-        @Override\n-        @ForceInline\n-        public $masktype$ eq(VectorMask<$Boxtype$> mask) {\n-            Objects.requireNonNull(mask);\n-            $masktype$ m = ($masktype$)mask;\n-            return xor(m.not());\n-        }\n-\n@@ -979,0 +971,1 @@\n+        @Override\n@@ -980,2 +973,1 @@\n-        \/* package-private *\/\n-        $masktype$ xor(VectorMask<$Boxtype$> mask) {\n+        public $masktype$ xor(VectorMask<$Boxtype$> mask) {\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-VectorBits.java.template","additions":2,"deletions":10,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -44,0 +44,2 @@\n+\n+serviceability\/sa\/ClhsdbInspect.java 8283578 windows-x64\n","filename":"test\/hotspot\/jtreg\/ProblemList-Xcomp.txt","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,0 +39,1 @@\n+import jdk.test.lib.Platform;\n@@ -321,0 +322,4 @@\n+        \/\/ On ARM Thumb the stack is not walkable, so the location is not available and\n+        \/\/ \"from\" string will not be present in the output.\n+        \/\/ Disable assertion for ARM32.\n+        String fromString = Platform.isARM() ? \"\" : \"from.*\";\n@@ -323,1 +328,1 @@\n-                           + \"\\\\] committed \" + sizeString + \" from.*\");\n+                           + \"\\\\] committed \" + sizeString + \" \" + fromString);\n","filename":"test\/hotspot\/jtreg\/runtime\/NMT\/VirtualAllocCommitMerge.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -418,1 +418,2 @@\n-        ArrayList<String> cmd = opts.getRuntimePrefix();\n+        ArrayList<String> cmd = new ArrayList<String>();\n+        cmd.addAll(opts.prefix);\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/TestCommon.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -54,2 +54,0 @@\n-com\/sun\/jdi\/redefine\/RedefineTest.java 8285422 generic-all\n-com\/sun\/jdi\/redefineMethod\/RedefineTest.java 8285422 generic-all\n@@ -57,10 +55,0 @@\n-\n-####\n-# JDI SDE Tests\n-# Use custom classpath\n-\n-com\/sun\/jdi\/sde\/FilterMangleTest.java 8285423 generic-all\n-com\/sun\/jdi\/sde\/MangleTest.java 8285423 generic-all\n-com\/sun\/jdi\/sde\/MangleStepTest.java 8285423 generic-all\n-com\/sun\/jdi\/sde\/TemperatureTableTest.java 8285423 generic-all\n-com\/sun\/jdi\/sde\/SourceDebugExtensionTest.java 8285423 generic-all\n","filename":"test\/jdk\/ProblemList-svc-vthread.txt","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-java\/util\/concurrent\/locks\/Lock\/OOMEInAQS.java 8298066 windows-x64\n+java\/util\/concurrent\/locks\/Lock\/OOMEInAQS.java 8298066 linux-aarch64,windows-x64\n","filename":"test\/jdk\/ProblemList-zgc.txt","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -487,1 +487,0 @@\n-java\/lang\/invoke\/lambda\/LogGeneratedClassesTest.java            8305600 generic-all\n@@ -543,4 +542,0 @@\n-java\/nio\/channels\/AsyncCloseAndInterrupt.java                   8305596 generic-all\n-\n-java\/nio\/channels\/FileChannel\/Transfer.java                     8305596 generic-all\n-\n","filename":"test\/jdk\/ProblemList.txt","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n- * @run driver AllLineLocations RefTypes\n+ * @run driver AllLineLocations\n","filename":"test\/jdk\/com\/sun\/jdi\/AllLineLocations.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n- *  @run driver ClassesByName HelloWorld\n+ *  @run driver ClassesByName\n@@ -55,1 +55,1 @@\n-        startUp(\"ClassesByName\");\n+        startUp(\"HelloWorld\");\n","filename":"test\/jdk\/com\/sun\/jdi\/ClassesByName.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -219,2 +219,0 @@\n-        \/\/ We need the class path that contains the path to jdk.test.lib.Asserts.\n-        argList.add(0, \" -cp \" + System.getProperty(\"test.class.path\"));\n","filename":"test\/jdk\/com\/sun\/jdi\/RedefineNestmateAttr\/TestNestmateAttr.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n- * @run driver UnpreparedByName InnerTarg\n+ * @run driver UnpreparedByName\n","filename":"test\/jdk\/com\/sun\/jdi\/UnpreparedByName.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n- * @run driver UnpreparedClasses InnerTarg\n+ * @run driver UnpreparedClasses\n","filename":"test\/jdk\/com\/sun\/jdi\/UnpreparedClasses.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2008, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,4 +52,5 @@\n-        \/\/ When we run under jtreg, test.classes contains the pathname of\n-        \/\/ the dir in which the .class files will be placed.\n-        String testClasses = System.getProperty(\"test.classes\");\n-        if (testClasses == null) {\n+        \/\/ When we run under jtreg, test.class.path contains classpath\n+        \/\/ with test and testlibrary compiled classes\n+        String testClassPath = System.getProperty(\"test.class.path\");\n+\n+        if (testClassPath == null) {\n@@ -58,1 +59,1 @@\n-        retVal += \"-classpath \" + testClasses;\n+        retVal += \"-classpath \" + testClassPath;\n","filename":"test\/jdk\/com\/sun\/jdi\/VMConnection.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -0,0 +1,114 @@\n+\/*\n+ * Copyright 2023, Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug     8305425\n+ * @summary Check Thread.isAlive\n+ * @run main\/othervm\/timeout=10 IsAlive\n+ *\/\n+\n+public class IsAlive {\n+\n+    static boolean spinnerDone;\n+\n+    private static void spin() {\n+        try {\n+            while (!Thread.currentThread().isInterrupted()) {\n+                Thread.sleep(100);\n+            }\n+        } catch (InterruptedException ie) {\n+            \/\/ Do nothing, just exit\n+        }\n+        spinnerDone = true;\n+    }\n+\n+    static volatile boolean checkerReady;\n+\n+    private static void check(Thread t) {\n+        while (!t.isAlive()) {\n+            \/\/ Burn hard, without any sleeps.\n+            \/\/ Check that we discover the thread is alive eventually.\n+        }\n+\n+        checkerReady = true;\n+\n+        while (t.isAlive()) {\n+            \/\/ Burn hard, without any sleeps.\n+            \/\/ Check that we discover the thread is not alive eventually.\n+        }\n+\n+        if (!spinnerDone) {\n+            throw new RuntimeException(\"Last write of terminated thread was not seen!\");\n+        }\n+    }\n+\n+    private static void assertAlive(Thread t) {\n+        if (!t.isAlive()) {\n+            throw new IllegalStateException(\"Thread \" + t + \" is not alive, but it should be\");\n+        }\n+    }\n+\n+    private static void assertNotAlive(Thread t) {\n+        if (t.isAlive()) {\n+            throw new IllegalStateException(\"Thread \" + t + \" is alive, but it should not be\");\n+        }\n+    }\n+\n+    public static void main(String args[]) throws Exception {\n+        Thread spinner = new Thread(IsAlive::spin);\n+        spinner.setName(\"Spinner\");\n+        spinner.setDaemon(true);\n+\n+        Thread checker = new Thread(() -> check(spinner));\n+        checker.setName(\"Checker\");\n+        checker.setDaemon(true);\n+\n+        assertNotAlive(spinner);\n+        assertNotAlive(checker);\n+\n+        System.out.println(\"Starting spinner\");\n+        spinner.start();\n+        assertAlive(spinner);\n+\n+        System.out.println(\"Starting checker\");\n+        checker.start();\n+        assertAlive(checker);\n+\n+        System.out.println(\"Waiting for checker to catch up\");\n+        while (!checkerReady) {\n+            Thread.sleep(100);\n+        }\n+\n+        System.out.println(\"Interrupting and joining spinner\");\n+        spinner.interrupt();\n+        spinner.join();\n+        assertNotAlive(spinner);\n+\n+        System.out.println(\"Joining checker\");\n+        checker.join();\n+        assertNotAlive(checker);\n+\n+        System.out.println(\"Complete\");\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/Thread\/IsAlive.java","additions":114,"deletions":0,"binary":false,"changes":114,"status":"added"},{"patch":"@@ -0,0 +1,452 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8267140\n+ * @summary Test HttpClient::shutdownNow. Any running operation will\n+ *          be aborted and the client should eventually exit.\n+ *          This test tests shutdownNow, awaitTermination, and\n+ *          isTerminated.\n+ * @library \/test\/lib \/test\/jdk\/java\/net\/httpclient\/lib\n+ * @build jdk.httpclient.test.lib.http2.Http2TestServer jdk.test.lib.net.SimpleSSLContext\n+ *        ReferenceTracker\n+ * @run testng\/othervm\n+ *       -Djdk.internal.httpclient.debug=true\n+ *       -Djdk.httpclient.HttpClient.log=trace,headers,requests\n+ *       AsyncShutdownNow\n+ *\/\n+\/\/ -Djdk.internal.httpclient.debug=true\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.UncheckedIOException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.URI;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpClient.Redirect;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpResponse;\n+import java.net.http.HttpResponse.BodyHandlers;\n+import java.nio.channels.ClosedChannelException;\n+import java.nio.charset.StandardCharsets;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionException;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.RejectedExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.Function;\n+import jdk.httpclient.test.lib.common.HttpServerAdapters;\n+import jdk.httpclient.test.lib.http2.Http2TestServer;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLHandshakeException;\n+\n+import com.sun.net.httpserver.HttpServer;\n+import com.sun.net.httpserver.HttpsConfigurator;\n+import com.sun.net.httpserver.HttpsServer;\n+import jdk.test.lib.RandomFactory;\n+import jdk.test.lib.net.SimpleSSLContext;\n+import org.testng.annotations.AfterTest;\n+import org.testng.annotations.BeforeTest;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import static java.lang.System.err;\n+import static java.lang.System.out;\n+import static java.net.http.HttpClient.Builder.NO_PROXY;\n+import static java.net.http.HttpClient.Version.HTTP_1_1;\n+import static java.net.http.HttpClient.Version.HTTP_2;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertNotNull;\n+import static org.testng.Assert.assertTrue;\n+import static org.testng.Assert.fail;\n+\n+public class AsyncShutdownNow implements HttpServerAdapters {\n+\n+    static {\n+        HttpServerAdapters.enableServerLogging();\n+    }\n+    static final Random RANDOM = RandomFactory.getRandom();\n+\n+    SSLContext sslContext;\n+    HttpTestServer httpTestServer;        \/\/ HTTP\/1.1    [ 4 servers ]\n+    HttpTestServer httpsTestServer;       \/\/ HTTPS\/1.1\n+    HttpTestServer http2TestServer;       \/\/ HTTP\/2 ( h2c )\n+    HttpTestServer https2TestServer;      \/\/ HTTP\/2 ( h2  )\n+    String httpURI;\n+    String httpsURI;\n+    String http2URI;\n+    String https2URI;\n+\n+    static final String MESSAGE = \"AsyncShutdownNow message body\";\n+    static final int ITERATIONS = 3;\n+\n+    @DataProvider(name = \"positive\")\n+    public Object[][] positive() {\n+        return new Object[][] {\n+                { httpURI,    },\n+                { httpsURI,   },\n+                { http2URI,   },\n+                { https2URI,  },\n+        };\n+    }\n+\n+    static final AtomicLong requestCounter = new AtomicLong();\n+    final ReferenceTracker TRACKER = ReferenceTracker.INSTANCE;\n+\n+    static Throwable getCause(Throwable t) {\n+        while (t instanceof CompletionException || t instanceof ExecutionException) {\n+            t = t.getCause();\n+        }\n+        return t;\n+    }\n+\n+    static String readBody(InputStream in) {\n+        try {\n+            return new String(in.readAllBytes(), StandardCharsets.UTF_8);\n+        } catch (IOException io) {\n+            throw new UncheckedIOException(io);\n+        }\n+    }\n+\n+    static boolean hasExpectedMessage(IOException io) {\n+        String message = io.getMessage();\n+        if (message == null) return false;\n+        \/\/ exception from sendAsync()\n+        if (message.equals(\"closed\")) return true;\n+        \/\/ exception from selmgr.abort\n+        if (message.equals(\"shutdownNow\")) return true;\n+        return false;\n+    }\n+\n+    static void checkCause(String what, Throwable cause) {\n+        Throwable t = cause;\n+        Throwable accepted = null;\n+        while (t != null) {\n+            out.println(what + \": checking \" + t);\n+            if (t instanceof IOException io && hasExpectedMessage(io)) {\n+                out.println(what + \": Got expected message in cause: \" + io);\n+                return;\n+            } else if (t instanceof ClosedChannelException) {\n+                out.println(what + \": Accepting ClosedChannelException as a valid cause: \" + t);\n+                accepted = t;\n+            }\n+            t = t.getCause();\n+        }\n+        if (accepted != null) {\n+            out.println(what + \": Didn't find expected shutdownNow\/closed, \" +\n+                    \"but accepting \" + accepted.getClass().getSimpleName()\n+                    + \" as a valid cause: \" + accepted);\n+            return;\n+        }\n+        throw new AssertionError(what + \": Unexpected exception: \" + cause, cause);\n+    }\n+\n+    @Test(dataProvider = \"positive\")\n+    void testConcurrent(String uriString) throws Exception {\n+        out.printf(\"%n---- starting (%s) ----%n\", uriString);\n+        ExecutorService readerService = Executors.newCachedThreadPool();\n+        HttpClient client = HttpClient.newBuilder()\n+                .proxy(NO_PROXY)\n+                .followRedirects(Redirect.ALWAYS)\n+                .sslContext(sslContext)\n+                .build();\n+        TRACKER.track(client);\n+\n+        int step = RANDOM.nextInt(ITERATIONS);\n+        Throwable failed = null;\n+        try {\n+            List<CompletableFuture<String>> bodies = new ArrayList<>();\n+            for (int i = 0; i < ITERATIONS; i++) {\n+                URI uri = URI.create(uriString + \"\/concurrent\/iteration-\" + i);\n+                HttpRequest request = HttpRequest.newBuilder(uri)\n+                        .header(\"X-uuid\", \"uuid-\" + requestCounter.incrementAndGet())\n+                        .build();\n+                out.printf(\"Iteration %d request: %s%n\", i, request.uri());\n+                CompletableFuture<HttpResponse<InputStream>> responseCF;\n+                CompletableFuture<String> bodyCF;\n+                final int si = i;\n+                responseCF = client.sendAsync(request, BodyHandlers.ofInputStream())\n+                        .thenApply((response) -> {\n+                            out.println(si + \":  Got response: \" + response);\n+                            assertEquals(response.statusCode(), 200);\n+                            return response;\n+                        });\n+                bodyCF = responseCF.thenApplyAsync(HttpResponse::body, readerService)\n+                        .thenApply(AsyncShutdownNow::readBody)\n+                        .thenApply((s) -> {\n+                            assertEquals(s, MESSAGE);\n+                            return s;\n+                        });\n+                long sleep = RANDOM.nextLong(5);\n+                if (sleep > 0) {\n+                    out.printf(\"%d: sleeping %d ms%n\", i, sleep);\n+                    Thread.sleep(sleep);\n+                }\n+                if (i == step) {\n+                    out.printf(\"%d: shutting down client now%n\", i, sleep);\n+                    client.shutdownNow();\n+                }\n+                var cf = bodyCF.exceptionally((t) -> {\n+                    Throwable cause = getCause(t);\n+                    out.println(si + \": Got expected exception: \" + cause);\n+                    if (UncheckedIOException.class.isAssignableFrom(cause.getClass())) {\n+                        if (cause.getCause() != null) {\n+                            out.println(si + \": Got expected exception: \" + cause);\n+                            cause = cause.getCause();\n+                        }\n+                    }\n+                    checkCause(String.valueOf(si), cause);\n+                    return null;\n+                });\n+                bodies.add(cf);\n+            }\n+            CompletableFuture.allOf(bodies.toArray(new CompletableFuture<?>[0])).get();\n+        } catch (Throwable throwable) {\n+            failed = throwable;\n+        } finally {\n+            failed = cleanup(client, readerService, failed);\n+        }\n+        if (failed instanceof Exception ex) throw ex;\n+        if (failed instanceof Error e) throw e;\n+        assertTrue(client.isTerminated());\n+    }\n+\n+    static Throwable cleanup(HttpClient client, ExecutorService readerService, Throwable failed) {\n+        try {\n+            try {\n+                if (client.awaitTermination(Duration.ofMillis(2000))) {\n+                    out.println(\"Client terminated within expected delay\");\n+                } else {\n+                    AssertionError error = new AssertionError(\"client still running\");\n+                    if (failed != null) {\n+                        failed.addSuppressed(error);\n+                    } else failed = error;\n+                }\n+            } finally {\n+                readerService.shutdown();\n+                readerService.awaitTermination(2000, TimeUnit.MILLISECONDS);\n+            }\n+        } catch (InterruptedException ie) {\n+            if (failed != null) {\n+                failed.addSuppressed(ie);\n+            } else failed = ie;\n+        }\n+        return failed;\n+    }\n+\n+    @Test(dataProvider = \"positive\")\n+    void testSequential(String uriString) throws Exception {\n+        out.printf(\"%n---- starting (%s) ----%n\", uriString);\n+        ExecutorService readerService = Executors.newCachedThreadPool();\n+        HttpClient client = HttpClient.newBuilder()\n+                .proxy(NO_PROXY)\n+                .followRedirects(Redirect.ALWAYS)\n+                .sslContext(sslContext)\n+                .build();\n+        TRACKER.track(client);\n+\n+        int step = RANDOM.nextInt(ITERATIONS);\n+        out.printf(\"will shutdown client in step %d%n\", step);\n+        Throwable failed = null;\n+        try {\n+            for (int i = 0; i < ITERATIONS; i++) {\n+                URI uri = URI.create(uriString + \"\/sequential\/iteration-\" + i);\n+                HttpRequest request = HttpRequest.newBuilder(uri)\n+                        .header(\"X-uuid\", \"uuid-\" + requestCounter.incrementAndGet())\n+                        .build();\n+                out.printf(\"Iteration %d request: %s%n\", i, request.uri());\n+                final int si = i;\n+                CompletableFuture<HttpResponse<InputStream>> responseCF;\n+                CompletableFuture<String> bodyCF;\n+                responseCF = client.sendAsync(request, BodyHandlers.ofInputStream())\n+                        .thenApply((response) -> {\n+                            out.println(si + \":  Got response: \" + response);\n+                            assertEquals(response.statusCode(), 200);\n+                            return response;\n+                        });\n+                bodyCF = responseCF.thenApplyAsync(HttpResponse::body, readerService)\n+                        .thenApply(AsyncShutdownNow::readBody)\n+                        .thenApply((s) -> {\n+                            assertEquals(s, MESSAGE);\n+                            return s;\n+                        })\n+                        .thenApply((s) -> {\n+                            out.println(si + \":  Got body: \" + s);\n+                            return s;\n+                        });\n+                long sleep = RANDOM.nextLong(5);\n+                if (sleep > 0) {\n+                    out.printf(\"%d: sleeping %d ms%n\", i, sleep);\n+                    Thread.sleep(sleep);\n+                }\n+                if (i == step) {\n+                    out.printf(\"%d: shutting down client now%n\", i, sleep);\n+                    client.shutdownNow();\n+                }\n+                bodyCF.handle((r, t) -> {\n+                    if (t != null) {\n+                        try {\n+                            Throwable cause = getCause(t);\n+                            out.println(si + \": Got expected exception: \" + cause);\n+                            if (UncheckedIOException.class.isAssignableFrom(cause.getClass())) {\n+                                if (cause.getCause() != null) {\n+                                    out.println(si + \": Got expected exception: \" + cause);\n+                                    cause = cause.getCause();\n+                                }\n+                            }\n+                            checkCause(String.valueOf(si), cause);\n+                        } catch (Throwable ase) {\n+                            return CompletableFuture.failedFuture(ase);\n+                        }\n+                        return CompletableFuture.completedFuture(null);\n+                    } else {\n+                        return CompletableFuture.completedFuture(r);\n+                    }\n+                }).thenCompose((c) -> c).get();\n+            }\n+        } catch (Throwable throwable) {\n+            failed = throwable;\n+        } finally {\n+            failed = cleanup(client, readerService, failed);\n+        }\n+        if (failed instanceof Exception ex) throw ex;\n+        if (failed instanceof Error e) throw e;\n+        assertTrue(client.isTerminated());\n+    }\n+\n+    \/\/ -- Infrastructure\n+\n+    @BeforeTest\n+    public void setup() throws Exception {\n+        out.println(\"\\n**** Setup ****\\n\");\n+        sslContext = new SimpleSSLContext().get();\n+        if (sslContext == null)\n+            throw new AssertionError(\"Unexpected null sslContext\");\n+\n+        httpTestServer = HttpTestServer.create(HTTP_1_1);\n+        httpTestServer.addHandler(new ServerRequestHandler(), \"\/http1\/exec\/\");\n+        httpURI = \"http:\/\/\" + httpTestServer.serverAuthority() + \"\/http1\/exec\/retry\";\n+        httpsTestServer = HttpTestServer.create(HTTP_1_1, sslContext);\n+        httpsTestServer.addHandler(new ServerRequestHandler(),\"\/https1\/exec\/\");\n+        httpsURI = \"https:\/\/\" + httpsTestServer.serverAuthority() + \"\/https1\/exec\/retry\";\n+\n+        http2TestServer = HttpTestServer.create(HTTP_2);\n+        http2TestServer.addHandler(new ServerRequestHandler(), \"\/http2\/exec\/\");\n+        http2URI = \"http:\/\/\" + http2TestServer.serverAuthority() + \"\/http2\/exec\/retry\";\n+        https2TestServer = HttpTestServer.create(HTTP_2, sslContext);\n+        https2TestServer.addHandler(new ServerRequestHandler(), \"\/https2\/exec\/\");\n+        https2URI = \"https:\/\/\" + https2TestServer.serverAuthority() + \"\/https2\/exec\/retry\";\n+\n+        httpTestServer.start();\n+        httpsTestServer.start();\n+        http2TestServer.start();\n+        https2TestServer.start();\n+    }\n+\n+    @AfterTest\n+    public void teardown() throws Exception {\n+        Thread.sleep(100);\n+        AssertionError fail = TRACKER.checkShutdown(5000);\n+        try {\n+            httpTestServer.stop();\n+            httpsTestServer.stop();\n+            http2TestServer.stop();\n+            https2TestServer.stop();\n+        } finally {\n+            if (fail != null) throw fail;\n+        }\n+    }\n+\n+    static class ServerRequestHandler implements HttpTestHandler {\n+        ConcurrentHashMap<String,String> closedRequests = new ConcurrentHashMap<>();\n+\n+        @java.lang.Override\n+        public void handle(HttpTestExchange t) throws IOException {\n+            out.println(\"ServerRequestHandler for: \" + t.getRequestURI());\n+\n+            List<String> uuids = t.getRequestHeaders().get(\"X-uuid\");\n+            if (uuids == null || uuids.size() != 1) {\n+                readAllRequestData(t);\n+                try (OutputStream os = t.getResponseBody()) {\n+                    String msg = \"Incorrect uuid header values:[\" + uuids + \"]\";\n+                    (new RuntimeException(msg)).printStackTrace();\n+                    t.sendResponseHeaders(500, -1);\n+                    os.write(msg.getBytes(UTF_8));\n+                }\n+                return;\n+            }\n+\n+            String uuid = uuids.get(0);\n+            \/\/ retrying\n+            if (closedRequests.putIfAbsent(uuid, t.getRequestURI().toString()) == null) {\n+                if (t.getExchangeVersion() == HTTP_1_1) {\n+                    \/\/ Throwing an exception here only causes a retry\n+                    \/\/ with HTTP_1_1 - where it forces the server to close\n+                    \/\/ the connection.\n+                    \/\/ For HTTP\/2 then throwing an IOE would cause the server\n+                    \/\/ to close the stream, and throwing anything else would\n+                    \/\/ cause it to close the connection, but neither would\n+                    \/\/ cause the client to retry.\n+                    \/\/ So we simply do not try to retry with HTTP\/2.\n+                    out.println(\"Server will close connection, client will retry: \"\n+                            + t.getRequestURI().toString());\n+                    throw new IOException(\"Closing on first request\");\n+                }\n+            }\n+\n+            \/\/ not retrying\n+            readAllRequestData(t);\n+            try (OutputStream os = t.getResponseBody()) {\n+                byte[] bytes = MESSAGE.getBytes(UTF_8);\n+                t.sendResponseHeaders(200, bytes.length);\n+                for (int i=0; i<bytes.length; i++) {\n+                    os.write(bytes, i, 1);\n+                    os.flush();\n+                    try {\n+                        Thread.sleep(RANDOM.nextInt(5));\n+                    } catch (InterruptedException x) { }\n+                }\n+            }\n+\n+            closedRequests.remove(uuid);\n+        }\n+    }\n+\n+    static void readAllRequestData(HttpTestExchange t) throws IOException {\n+        try (InputStream is = t.getRequestBody()) {\n+            is.readAllBytes();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/AsyncShutdownNow.java","additions":452,"deletions":0,"binary":false,"changes":452,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,0 +42,1 @@\n+import java.util.Objects;\n@@ -50,0 +51,2 @@\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n@@ -75,1 +78,1 @@\n-        for (HttpClient client : clients) {\n+        for (HttpClient c : clients) {\n@@ -77,9 +80,11 @@\n-            assertFalse(client.authenticator().isPresent());\n-            assertFalse(client.cookieHandler().isPresent());\n-            assertFalse(client.connectTimeout().isPresent());\n-            assertFalse(client.executor().isPresent());\n-            assertFalse(client.proxy().isPresent());\n-            assertTrue(client.sslParameters() != null);\n-            assertTrue(client.followRedirects().equals(HttpClient.Redirect.NEVER));\n-            assertTrue(client.sslContext() == SSLContext.getDefault());\n-            assertTrue(client.version().equals(HttpClient.Version.HTTP_2));\n+            try (var client = c) {\n+                assertFalse(client.authenticator().isPresent());\n+                assertFalse(client.cookieHandler().isPresent());\n+                assertFalse(client.connectTimeout().isPresent());\n+                assertFalse(client.executor().isPresent());\n+                assertFalse(client.proxy().isPresent());\n+                assertTrue(client.sslParameters() != null);\n+                assertTrue(client.followRedirects().equals(HttpClient.Redirect.NEVER));\n+                assertTrue(client.sslContext() == SSLContext.getDefault());\n+                assertTrue(client.version().equals(HttpClient.Version.HTTP_2));\n+            }\n@@ -105,0 +110,20 @@\n+    static class Closer implements AutoCloseable {\n+        final HttpClient.Builder builder;\n+        HttpClient client;\n+        Closer(HttpClient.Builder builder) {\n+            this.builder = Objects.requireNonNull(builder);\n+        }\n+        HttpClient build() {\n+            if (client != null) client.close();\n+            return client = builder.build();\n+        }\n+        @Override\n+        public void close() {\n+            if (client != null) client.close();\n+        }\n+    }\n+\n+    static Closer closeable(HttpClient.Builder builder) {\n+        return new Closer(builder);\n+    }\n+\n@@ -110,1 +135,3 @@\n-        assertTrue(builder.build().authenticator().get() == a);\n+        try (var closer = closeable(builder)) {\n+            assertTrue(closer.build().authenticator().get() == a);\n+        }\n@@ -113,1 +140,3 @@\n-        assertTrue(builder.build().authenticator().get() == b);\n+        try (var closer = closeable(builder)) {\n+            assertTrue(closer.build().authenticator().get() == b);\n+        }\n@@ -117,1 +146,3 @@\n-        assertTrue(builder.build().authenticator().get() == c);\n+        try (var closer = closeable(builder)) {\n+            assertTrue(closer.build().authenticator().get() == c);\n+        }\n@@ -125,1 +156,3 @@\n-        assertTrue(builder.build().cookieHandler().get() == a);\n+        try (var closer = closeable(builder)) {\n+            assertTrue(closer.build().cookieHandler().get() == a);\n+        }\n@@ -128,1 +161,3 @@\n-        assertTrue(builder.build().cookieHandler().get() == b);\n+        try (var closer = closeable(builder)) {\n+            assertTrue(closer.build().cookieHandler().get() == b);\n+        }\n@@ -132,1 +167,3 @@\n-        assertTrue(builder.build().cookieHandler().get() == c);\n+        try (var closer = closeable(builder)) {\n+            assertTrue(closer.build().cookieHandler().get() == c);\n+        }\n@@ -140,1 +177,3 @@\n-        assertTrue(builder.build().connectTimeout().get() == a);\n+        try (var closer = closeable(builder)) {\n+            assertTrue(closer.build().connectTimeout().get() == a);\n+        }\n@@ -143,1 +182,3 @@\n-        assertTrue(builder.build().connectTimeout().get() == b);\n+        try (var closer = closeable(builder)) {\n+            assertTrue(closer.build().connectTimeout().get() == b);\n+        }\n@@ -147,1 +188,3 @@\n-        assertTrue(builder.build().connectTimeout().get() == c);\n+        try (var closer = closeable(builder)) {\n+            assertTrue(closer.build().connectTimeout().get() == c);\n+        }\n@@ -156,1 +199,1 @@\n-        public void execute(Runnable r) { }\n+        public void execute(Runnable r) { r.run();}\n@@ -164,1 +207,3 @@\n-        assertTrue(builder.build().executor().get() == a);\n+        try (var closer = closeable(builder)) {\n+            assertTrue(closer.build().executor().get() == a);\n+        }\n@@ -167,1 +212,3 @@\n-        assertTrue(builder.build().executor().get() == b);\n+        try (var closer = closeable(builder)) {\n+            assertTrue(closer.build().executor().get() == b);\n+        }\n@@ -171,1 +218,3 @@\n-        assertTrue(builder.build().executor().get() == c);\n+        try (var closer = closeable(builder)) {\n+            assertTrue(closer.build().executor().get() == c);\n+        }\n@@ -179,1 +228,3 @@\n-        assertTrue(builder.build().proxy().get() == a);\n+        try (var closer = closeable(builder)) {\n+            assertTrue(closer.build().proxy().get() == a);\n+        }\n@@ -182,1 +233,3 @@\n-        assertTrue(builder.build().proxy().get() == b);\n+        try (var closer = closeable(builder)) {\n+            assertTrue(closer.build().proxy().get() == b);\n+        }\n@@ -186,1 +239,3 @@\n-        assertTrue(builder.build().proxy().get() == c);\n+        try (var closer = closeable(builder)) {\n+            assertTrue(closer.build().proxy().get() == c);\n+        }\n@@ -196,2 +251,6 @@\n-        assertTrue(builder.build().sslParameters() != (a));\n-        assertTrue(builder.build().sslParameters().getCipherSuites()[0].equals(\"A\"));\n+        try (var closer = closeable(builder)) {\n+            assertTrue(closer.build().sslParameters() != (a));\n+        }\n+        try (var closer = closeable(builder)) {\n+            assertTrue(closer.build().sslParameters().getCipherSuites()[0].equals(\"A\"));\n+        }\n@@ -201,2 +260,6 @@\n-        assertTrue(builder.build().sslParameters() != b);\n-        assertTrue(builder.build().sslParameters().getEnableRetransmissions());\n+        try (var closer = closeable(builder)) {\n+            assertTrue(closer.build().sslParameters() != b);\n+        }\n+        try (var closer = closeable(builder)) {\n+            assertTrue(closer.build().sslParameters().getEnableRetransmissions());\n+        }\n@@ -208,1 +271,3 @@\n-        assertTrue(builder.build().sslParameters().getProtocols()[0].equals(\"C\"));\n+        try (var closer = closeable(builder)) {\n+            assertTrue(closer.build().sslParameters().getProtocols()[0].equals(\"C\"));\n+        }\n@@ -216,1 +281,3 @@\n-        assertTrue(builder.build().sslContext() == a);\n+        try (var closer = closeable(builder)) {\n+            assertTrue(closer.build().sslContext() == a);\n+        }\n@@ -219,1 +286,3 @@\n-        assertTrue(builder.build().sslContext() == b);\n+        try (var closer = closeable(builder)) {\n+            assertTrue(closer.build().sslContext() == b);\n+        }\n@@ -223,1 +292,3 @@\n-        assertTrue(builder.build().sslContext() == c);\n+        try (var closer = closeable(builder)) {\n+            assertTrue(closer.build().sslContext() == c);\n+        }\n@@ -230,1 +301,3 @@\n-        assertTrue(builder.build().followRedirects() == Redirect.ALWAYS);\n+        try (var closer = closeable(builder)) {\n+            assertTrue(closer.build().followRedirects() == Redirect.ALWAYS);\n+        }\n@@ -232,1 +305,3 @@\n-        assertTrue(builder.build().followRedirects() == Redirect.NEVER);\n+        try (var closer = closeable(builder)) {\n+            assertTrue(closer.build().followRedirects() == Redirect.NEVER);\n+        }\n@@ -235,1 +310,3 @@\n-        assertTrue(builder.build().followRedirects() == Redirect.NORMAL);\n+        try (var closer = closeable(builder)) {\n+            assertTrue(closer.build().followRedirects() == Redirect.NORMAL);\n+        }\n@@ -242,1 +319,3 @@\n-        assertTrue(builder.build().version() == Version.HTTP_2);\n+        try (var closer = closeable(builder)) {\n+            assertTrue(closer.build().version() == Version.HTTP_2);\n+        }\n@@ -244,1 +323,3 @@\n-        assertTrue(builder.build().version() == Version.HTTP_1_1);\n+        try (var closer = closeable(builder)) {\n+            assertTrue(closer.build().version() == Version.HTTP_1_1);\n+        }\n@@ -247,1 +328,3 @@\n-        assertTrue(builder.build().version() == Version.HTTP_2);\n+        try (var closer = closeable(builder)) {\n+            assertTrue(closer.build().version() == Version.HTTP_2);\n+        }\n@@ -249,1 +332,3 @@\n-        assertTrue(builder.build().version() == Version.HTTP_1_1);\n+        try (var closer = closeable(builder)) {\n+            assertTrue(closer.build().version() == Version.HTTP_1_1);\n+        }\n@@ -261,1 +346,1 @@\n-        builder.build();\n+        try (var httpClient = builder.build()) {}\n@@ -263,1 +348,1 @@\n-        builder.build();\n+        try (var httpClient = builder.build()) {}\n@@ -355,21 +440,22 @@\n-        HttpClient client = HttpClient.newHttpClient();\n-        HttpRequest request = HttpRequest.newBuilder(uri).build();\n-\n-        assertThrows(NPE, () -> client.send(null, BodyHandlers.discarding()));\n-        assertThrows(NPE, () -> client.send(request, null));\n-        assertThrows(NPE, () -> client.send(null, null));\n-\n-        assertThrows(NPE, () -> client.sendAsync(null, BodyHandlers.discarding()));\n-        assertThrows(NPE, () -> client.sendAsync(request, null));\n-        assertThrows(NPE, () -> client.sendAsync(null, null));\n-\n-        assertThrows(NPE, () -> client.sendAsync(null, BodyHandlers.discarding(), null));\n-        assertThrows(NPE, () -> client.sendAsync(request, null, null));\n-        assertThrows(NPE, () -> client.sendAsync(null, null, null));\n-\n-        \/\/ CONNECT is disallowed in the implementation, since it is used for\n-        \/\/ tunneling, and is handled separately for security checks.\n-        HttpRequest connectRequest = new HttpConnectRequest();\n-        assertThrows(IAE, () -> client.send(connectRequest, BodyHandlers.discarding()));\n-        assertThrows(IAE, () -> client.sendAsync(connectRequest, BodyHandlers.discarding()));\n-        assertThrows(IAE, () -> client.sendAsync(connectRequest, BodyHandlers.discarding(), null));\n+        try (HttpClient client = HttpClient.newHttpClient()) {\n+            HttpRequest request = HttpRequest.newBuilder(uri).build();\n+\n+            assertThrows(NPE, () -> client.send(null, BodyHandlers.discarding()));\n+            assertThrows(NPE, () -> client.send(request, null));\n+            assertThrows(NPE, () -> client.send(null, null));\n+\n+            assertThrows(NPE, () -> client.sendAsync(null, BodyHandlers.discarding()));\n+            assertThrows(NPE, () -> client.sendAsync(request, null));\n+            assertThrows(NPE, () -> client.sendAsync(null, null));\n+\n+            assertThrows(NPE, () -> client.sendAsync(null, BodyHandlers.discarding(), null));\n+            assertThrows(NPE, () -> client.sendAsync(request, null, null));\n+            assertThrows(NPE, () -> client.sendAsync(null, null, null));\n+\n+            \/\/ CONNECT is disallowed in the implementation, since it is used for\n+            \/\/ tunneling, and is handled separately for security checks.\n+            HttpRequest connectRequest = new HttpConnectRequest();\n+            assertThrows(IAE, () -> client.send(connectRequest, BodyHandlers.discarding()));\n+            assertThrows(IAE, () -> client.sendAsync(connectRequest, BodyHandlers.discarding()));\n+            assertThrows(IAE, () -> client.sendAsync(connectRequest, BodyHandlers.discarding(), null));\n+        }\n@@ -397,0 +483,103 @@\n+    @Test\n+    static void testDefaultShutdown() throws Exception {\n+        try (HttpClient client = new MockHttpClient()) {\n+            client.shutdown(); \/\/ does nothing\n+        }\n+    }\n+\n+    @Test\n+    static void testDefaultShutdownNow() throws Exception {\n+        try (HttpClient client = new MockHttpClient()) {\n+            client.shutdownNow(); \/\/ calls shutdown, doesn't wait\n+        }\n+\n+        AtomicInteger shutdownCalled = new AtomicInteger();\n+        HttpClient mock = new MockHttpClient() {\n+            @Override\n+            public void shutdown() {\n+                super.shutdown();\n+                shutdownCalled.incrementAndGet();\n+            }\n+        };\n+        try (HttpClient client = mock) {\n+            client.shutdownNow();  \/\/ calls shutdown, doesn't wait\n+        }\n+\n+        \/\/ once from shutdownNow(), and once from close()\n+        assertEquals(shutdownCalled.get(), 2);\n+    }\n+\n+    @Test\n+    static void testDefaultIsTerminated() throws Exception {\n+        try (HttpClient client = new MockHttpClient()) {\n+            assertFalse(client.isTerminated());\n+        }\n+    }\n+\n+    @Test\n+    static void testDefaultAwaitTermination() throws Exception {\n+        try (HttpClient client = new MockHttpClient()) {\n+            assertTrue(client.awaitTermination(Duration.ofDays(1)));\n+        }\n+        try (HttpClient client = new MockHttpClient()) {\n+            assertThrows(NullPointerException.class,\n+                    () -> client.awaitTermination(null));\n+        }\n+    }\n+\n+    @Test\n+    static void testDefaultClose() {\n+        AtomicInteger shutdownCalled = new AtomicInteger();\n+        AtomicInteger awaitTerminationCalled = new AtomicInteger();\n+        AtomicInteger shutdownNowCalled = new AtomicInteger();\n+        HttpClient mock = new MockHttpClient() {\n+            @Override\n+            public void shutdown() {\n+                super.shutdown();\n+                shutdownCalled.incrementAndGet();\n+            }\n+            @Override\n+            public void shutdownNow() {\n+                super.shutdownNow();\n+                shutdownNowCalled.incrementAndGet();\n+            }\n+\n+            @Override\n+            public boolean awaitTermination(Duration duration) throws InterruptedException {\n+                int count = awaitTerminationCalled.incrementAndGet();\n+                if (count == 1) return false;\n+                if (count == 2) return true;\n+                if (count == 3) {\n+                    Thread.currentThread().interrupt();\n+                    throw new InterruptedException();\n+                }\n+                return super.awaitTermination(duration);\n+            }\n+        };\n+\n+        \/\/ first time around:\n+        \/\/   close()\n+        \/\/      shutdown() 0->1\n+        \/\/      awaitTermination() 0->1 -> false\n+        \/\/      awaitTermination() 1->2 -> true\n+        try (HttpClient client = mock) { }\n+        assertEquals(shutdownCalled.get(), 1); \/\/ called by close()\n+        assertEquals(shutdownNowCalled.get(), 0); \/\/ not called\n+        assertEquals(awaitTerminationCalled.get(), 2); \/\/ called by close() twice\n+        assertFalse(Thread.currentThread().isInterrupted());\n+\n+        \/\/ second time around:\n+        \/\/   close()\n+        \/\/      shutdown() 1->2\n+        \/\/      awaitTermination() 2->3 -> interrupt, throws\n+        \/\/      shutdownNow() 0->1\n+        \/\/         calls shutdown() 2->3\n+        \/\/      awaitTermination() 3->4 -> true\n+        try (HttpClient client = mock) { }\n+        assertEquals(shutdownCalled.get(), 3); \/\/ called by close() and shutdownNow()\n+        assertEquals(shutdownNowCalled.get(), 1); \/\/ called by close() due to interrupt\n+        assertEquals(awaitTerminationCalled.get(), 4); \/\/ called by close twice\n+        assertTrue(Thread.currentThread().isInterrupted());\n+        assertTrue(Thread.interrupted());\n+    }\n+\n","filename":"test\/jdk\/java\/net\/httpclient\/HttpClientBuilderTest.java","additions":254,"deletions":65,"binary":false,"changes":319,"status":"modified"},{"patch":"@@ -0,0 +1,347 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8267140\n+ * @summary Test for HttpClient::close. Any running operation should\n+ *          succeed and the client should eventually exit.\n+ *          This test tests close, awaitTermination, and\n+ *          isTerminated.\n+ * @library \/test\/lib \/test\/jdk\/java\/net\/httpclient\/lib\n+ * @build jdk.httpclient.test.lib.http2.Http2TestServer jdk.test.lib.net.SimpleSSLContext\n+ *        ReferenceTracker\n+ * @run testng\/othervm\n+ *       -Djdk.internal.httpclient.debug=true\n+ *       -Djdk.httpclient.HttpClient.log=trace,headers,requests\n+ *       HttpClientClose\n+ *\/\n+\/\/ -Djdk.internal.httpclient.debug=true\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.UncheckedIOException;\n+import java.net.URI;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpClient.Redirect;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpResponse;\n+import java.net.http.HttpResponse.BodyHandlers;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import jdk.httpclient.test.lib.common.HttpServerAdapters;\n+import javax.net.ssl.SSLContext;\n+\n+import jdk.test.lib.RandomFactory;\n+import jdk.test.lib.net.SimpleSSLContext;\n+import org.testng.annotations.AfterTest;\n+import org.testng.annotations.BeforeTest;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import static java.lang.System.err;\n+import static java.lang.System.out;\n+import static java.net.http.HttpClient.Builder.NO_PROXY;\n+import static java.net.http.HttpClient.Version.HTTP_1_1;\n+import static java.net.http.HttpClient.Version.HTTP_2;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertNotNull;\n+import static org.testng.Assert.assertTrue;\n+import static org.testng.Assert.fail;\n+\n+public class HttpClientClose implements HttpServerAdapters {\n+\n+    static {\n+        HttpServerAdapters.enableServerLogging();\n+    }\n+    static final Random RANDOM = RandomFactory.getRandom();\n+\n+    SSLContext sslContext;\n+    HttpTestServer httpTestServer;        \/\/ HTTP\/1.1    [ 4 servers ]\n+    HttpTestServer httpsTestServer;       \/\/ HTTPS\/1.1\n+    HttpTestServer http2TestServer;       \/\/ HTTP\/2 ( h2c )\n+    HttpTestServer https2TestServer;      \/\/ HTTP\/2 ( h2  )\n+    String httpURI;\n+    String httpsURI;\n+    String http2URI;\n+    String https2URI;\n+\n+    static final String MESSAGE = \"HttpClientClose message body\";\n+    static final int ITERATIONS = 3;\n+\n+    @DataProvider(name = \"positive\")\n+    public Object[][] positive() {\n+        return new Object[][] {\n+                { httpURI,    },\n+                { httpsURI,   },\n+                { http2URI,   },\n+                { https2URI,  },\n+        };\n+    }\n+\n+    static final AtomicLong requestCounter = new AtomicLong();\n+    final ReferenceTracker TRACKER = ReferenceTracker.INSTANCE;\n+\n+    static String readBody(InputStream in) {\n+        try {\n+            return new String(in.readAllBytes(), StandardCharsets.UTF_8);\n+        } catch (IOException io) {\n+            throw new UncheckedIOException(io);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"positive\")\n+    void testConcurrent(String uriString) throws Exception {\n+        out.printf(\"%n---- starting (%s) ----%n\", uriString);\n+        ExecutorService readerService = Executors.newCachedThreadPool();\n+        Throwable failed = null;\n+        HttpClient toCheck = null;\n+        try (HttpClient client = toCheck = HttpClient.newBuilder()\n+                .proxy(NO_PROXY)\n+                .followRedirects(Redirect.ALWAYS)\n+                .sslContext(sslContext)\n+                .build()) {\n+            TRACKER.track(client);\n+\n+            List<CompletableFuture<String>> bodies = new ArrayList<>();\n+            for (int i = 0; i < ITERATIONS; i++) {\n+                URI uri = URI.create(uriString + \"\/concurrent\/iteration-\" + i);\n+                HttpRequest request = HttpRequest.newBuilder(uri)\n+                        .header(\"X-uuid\", \"uuid-\" + requestCounter.incrementAndGet())\n+                        .build();\n+                out.printf(\"Iteration %d request: %s%n\", i, request.uri());\n+                CompletableFuture<HttpResponse<InputStream>> responseCF;\n+                CompletableFuture<String> bodyCF;\n+                final int si = i;\n+                responseCF = client.sendAsync(request, BodyHandlers.ofInputStream())\n+                        .thenApply((response) -> {\n+                            out.println(si + \":  Got response: \" + response);\n+                            assertEquals(response.statusCode(), 200);\n+                            return response;\n+                        });\n+                bodyCF = responseCF.thenApplyAsync(HttpResponse::body, readerService)\n+                        .thenApply(HttpClientClose::readBody)\n+                        .thenApply((s) -> {\n+                            assertEquals(s, MESSAGE);\n+                            return s;\n+                        });\n+                long sleep = RANDOM.nextLong(5);\n+                if (sleep > 0) {\n+                    out.printf(\"%d: sleeping %d ms%n\", i, sleep);\n+                    Thread.sleep(sleep);\n+                }\n+                var cf = bodyCF;\n+                bodies.add(cf);\n+            }\n+            CompletableFuture.allOf(bodies.toArray(new CompletableFuture<?>[0])).get();\n+        } catch (Throwable throwable) {\n+            failed = throwable;\n+        } finally {\n+            failed = cleanup(readerService, failed);\n+        }\n+        if (failed instanceof Exception ex) throw ex;\n+        if (failed instanceof Error e) throw e;\n+        assertTrue(toCheck.isTerminated());\n+    }\n+\n+    static Throwable cleanup(ExecutorService readerService, Throwable failed) {\n+        try {\n+            readerService.shutdown();\n+            readerService.awaitTermination(2000, TimeUnit.MILLISECONDS);\n+        } catch (InterruptedException ie) {\n+            if (failed != null) {\n+                failed.addSuppressed(ie);\n+            } else failed = ie;\n+        }\n+        return failed;\n+    }\n+\n+    @Test(dataProvider = \"positive\")\n+    void testSequential(String uriString) throws Exception {\n+        out.printf(\"%n---- starting (%s) ----%n\", uriString);\n+        ExecutorService readerService = Executors.newCachedThreadPool();\n+        Throwable failed = null;\n+        HttpClient toCheck = null;\n+        try (HttpClient client = toCheck = HttpClient.newBuilder()\n+                .proxy(NO_PROXY)\n+                .followRedirects(Redirect.ALWAYS)\n+                .sslContext(sslContext)\n+                .build()) {\n+            TRACKER.track(client);\n+\n+            for (int i = 0; i < ITERATIONS; i++) {\n+                URI uri = URI.create(uriString + \"\/sequential\/iteration-\" + i);\n+                HttpRequest request = HttpRequest.newBuilder(uri)\n+                        .header(\"X-uuid\", \"uuid-\" + requestCounter.incrementAndGet())\n+                        .build();\n+                out.printf(\"Iteration %d request: %s%n\", i, request.uri());\n+                final int si = i;\n+                CompletableFuture<HttpResponse<InputStream>> responseCF;\n+                CompletableFuture<String> bodyCF;\n+                responseCF = client.sendAsync(request, BodyHandlers.ofInputStream())\n+                        .thenApply((response) -> {\n+                            out.println(si + \":  Got response: \" + response);\n+                            assertEquals(response.statusCode(), 200);\n+                            return response;\n+                        });\n+                bodyCF = responseCF.thenApplyAsync(HttpResponse::body, readerService)\n+                        .thenApply(HttpClientClose::readBody)\n+                        .thenApply((s) -> {\n+                            assertEquals(s, MESSAGE);\n+                            return s;\n+                        })\n+                        .thenApply((s) -> {\n+                            out.println(si + \":  Got body: \" + s);\n+                            return s;\n+                        });\n+                long sleep = RANDOM.nextLong(5);\n+                if (sleep > 0) {\n+                    out.printf(\"%d: sleeping %d ms%n\", i, sleep);\n+                    Thread.sleep(sleep);\n+                }\n+                bodyCF.get();\n+            }\n+        } catch (Throwable throwable) {\n+            failed = throwable;\n+        } finally {\n+            failed = cleanup(readerService, failed);\n+        }\n+        if (failed instanceof Exception ex) throw ex;\n+        if (failed instanceof Error e) throw e;\n+        assertTrue(toCheck.isTerminated());\n+    }\n+\n+    \/\/ -- Infrastructure\n+\n+    @BeforeTest\n+    public void setup() throws Exception {\n+        out.println(\"\\n**** Setup ****\\n\");\n+        sslContext = new SimpleSSLContext().get();\n+        if (sslContext == null)\n+            throw new AssertionError(\"Unexpected null sslContext\");\n+\n+        httpTestServer = HttpTestServer.create(HTTP_1_1);\n+        httpTestServer.addHandler(new ServerRequestHandler(), \"\/http1\/exec\/\");\n+        httpURI = \"http:\/\/\" + httpTestServer.serverAuthority() + \"\/http1\/exec\/retry\";\n+        httpsTestServer = HttpTestServer.create(HTTP_1_1, sslContext);\n+        httpsTestServer.addHandler(new ServerRequestHandler(),\"\/https1\/exec\/\");\n+        httpsURI = \"https:\/\/\" + httpsTestServer.serverAuthority() + \"\/https1\/exec\/retry\";\n+\n+        http2TestServer = HttpTestServer.create(HTTP_2);\n+        http2TestServer.addHandler(new ServerRequestHandler(), \"\/http2\/exec\/\");\n+        http2URI = \"http:\/\/\" + http2TestServer.serverAuthority() + \"\/http2\/exec\/retry\";\n+        https2TestServer = HttpTestServer.create(HTTP_2, sslContext);\n+        https2TestServer.addHandler(new ServerRequestHandler(), \"\/https2\/exec\/\");\n+        https2URI = \"https:\/\/\" + https2TestServer.serverAuthority() + \"\/https2\/exec\/retry\";\n+\n+        httpTestServer.start();\n+        httpsTestServer.start();\n+        http2TestServer.start();\n+        https2TestServer.start();\n+    }\n+\n+    @AfterTest\n+    public void teardown() throws Exception {\n+        Thread.sleep(100);\n+        AssertionError fail = TRACKER.checkShutdown(5000);\n+        try {\n+            httpTestServer.stop();\n+            httpsTestServer.stop();\n+            http2TestServer.stop();\n+            https2TestServer.stop();\n+        } finally {\n+            if (fail != null) throw fail;\n+        }\n+    }\n+\n+    static class ServerRequestHandler implements HttpTestHandler {\n+        ConcurrentHashMap<String,String> closedRequests = new ConcurrentHashMap<>();\n+\n+        @java.lang.Override\n+        public void handle(HttpTestExchange t) throws IOException {\n+            out.println(\"ServerRequestHandler for: \" + t.getRequestURI());\n+\n+            List<String> uuids = t.getRequestHeaders().get(\"X-uuid\");\n+            if (uuids == null || uuids.size() != 1) {\n+                readAllRequestData(t);\n+                try (OutputStream os = t.getResponseBody()) {\n+                    String msg = \"Incorrect uuid header values:[\" + uuids + \"]\";\n+                    (new RuntimeException(msg)).printStackTrace();\n+                    t.sendResponseHeaders(500, -1);\n+                    os.write(msg.getBytes(UTF_8));\n+                }\n+                return;\n+            }\n+\n+            String uuid = uuids.get(0);\n+            \/\/ retrying\n+            if (closedRequests.putIfAbsent(uuid, t.getRequestURI().toString()) == null) {\n+                if (t.getExchangeVersion() == HTTP_1_1) {\n+                    \/\/ Throwing an exception here only causes a retry\n+                    \/\/ with HTTP_1_1 - where it forces the server to close\n+                    \/\/ the connection.\n+                    \/\/ For HTTP\/2 then throwing an IOE would cause the server\n+                    \/\/ to close the stream, and throwing anything else would\n+                    \/\/ cause it to close the connection, but neither would\n+                    \/\/ cause the client to retry.\n+                    \/\/ So we simply do not try to retry with HTTP\/2.\n+                    out.println(\"Server will close connection, client will retry: \"\n+                            + t.getRequestURI().toString());\n+                    throw new IOException(\"Closing on first request\");\n+                }\n+            }\n+\n+            \/\/ not retrying\n+            readAllRequestData(t);\n+            try (OutputStream os = t.getResponseBody()) {\n+                byte[] bytes = MESSAGE.getBytes(UTF_8);\n+                t.sendResponseHeaders(200, bytes.length);\n+                for (int i=0; i<bytes.length; i++) {\n+                    os.write(bytes, i, 1);\n+                    os.flush();\n+                    try {\n+                        Thread.sleep(RANDOM.nextInt(5));\n+                    } catch (InterruptedException x) { }\n+                }\n+            }\n+\n+            closedRequests.remove(uuid);\n+        }\n+    }\n+\n+    static void readAllRequestData(HttpTestExchange t) throws IOException {\n+        try (InputStream is = t.getRequestBody()) {\n+            is.readAllBytes();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/HttpClientClose.java","additions":347,"deletions":0,"binary":false,"changes":347,"status":"added"},{"patch":"@@ -0,0 +1,476 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8267140\n+ * @summary Test for HttpClient::shutdown. Any running operation should\n+ *          succeed but new operations will be rejected. The client\n+ *          should eventually exit.\n+ *          This test tests shutdown, awaitTermination, and\n+ *          isTerminated.\n+ * @library \/test\/lib \/test\/jdk\/java\/net\/httpclient\/lib\n+ * @build jdk.httpclient.test.lib.http2.Http2TestServer jdk.test.lib.net.SimpleSSLContext\n+ *        ReferenceTracker\n+ * @run testng\/othervm\n+ *       -Djdk.internal.httpclient.debug=true\n+ *       -Djdk.httpclient.HttpClient.log=trace,headers,requests\n+ *       HttpClientShutdown\n+ *\/\n+\/\/ -Djdk.internal.httpclient.debug=true\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.UncheckedIOException;\n+import java.net.URI;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpClient.Redirect;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpResponse;\n+import java.net.http.HttpResponse.BodyHandlers;\n+import java.nio.channels.ClosedChannelException;\n+import java.nio.charset.StandardCharsets;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionException;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import jdk.httpclient.test.lib.common.HttpServerAdapters;\n+import javax.net.ssl.SSLContext;\n+\n+import jdk.test.lib.RandomFactory;\n+import jdk.test.lib.net.SimpleSSLContext;\n+import org.testng.annotations.AfterTest;\n+import org.testng.annotations.BeforeTest;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import static java.lang.System.err;\n+import static java.lang.System.out;\n+import static java.net.http.HttpClient.Builder.NO_PROXY;\n+import static java.net.http.HttpClient.Version.HTTP_1_1;\n+import static java.net.http.HttpClient.Version.HTTP_2;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertNotNull;\n+import static org.testng.Assert.assertTrue;\n+import static org.testng.Assert.fail;\n+\n+public class HttpClientShutdown implements HttpServerAdapters {\n+\n+    static {\n+        HttpServerAdapters.enableServerLogging();\n+    }\n+    static final Random RANDOM = RandomFactory.getRandom();\n+\n+    SSLContext sslContext;\n+    HttpTestServer httpTestServer;        \/\/ HTTP\/1.1    [ 4 servers ]\n+    HttpTestServer httpsTestServer;       \/\/ HTTPS\/1.1\n+    HttpTestServer http2TestServer;       \/\/ HTTP\/2 ( h2c )\n+    HttpTestServer https2TestServer;      \/\/ HTTP\/2 ( h2  )\n+    String httpURI;\n+    String httpsURI;\n+    String http2URI;\n+    String https2URI;\n+\n+    static final String MESSAGE = \"HttpClientShutdown message body\";\n+    static final int ITERATIONS = 3;\n+\n+    @DataProvider(name = \"positive\")\n+    public Object[][] positive() {\n+        return new Object[][] {\n+                { httpURI,    },\n+                { httpsURI,   },\n+                { http2URI,   },\n+                { https2URI,  },\n+        };\n+    }\n+\n+    static final AtomicLong requestCounter = new AtomicLong();\n+    final ReferenceTracker TRACKER = ReferenceTracker.INSTANCE;\n+    static volatile long start = System.nanoTime();\n+\n+    static final String now() {\n+        var duration = Duration.ofNanos(System.nanoTime() - start);\n+        var secs = duration.toSeconds();\n+        var ms = duration.toMillisPart();\n+        if (secs > 0) {\n+            return String.format(\"[%ss %sms] \", secs, ms);\n+        } else {\n+            return String.format(\"[%sms] \", ms);\n+        }\n+    }\n+\n+    static Throwable getCause(Throwable t) {\n+        while (t instanceof CompletionException || t instanceof ExecutionException) {\n+            t = t.getCause();\n+        }\n+        return t;\n+    }\n+\n+    static String readBody(InputStream in) {\n+        try {\n+            return new String(in.readAllBytes(), StandardCharsets.UTF_8);\n+        } catch (IOException io) {\n+            throw new UncheckedIOException(io);\n+        }\n+    }\n+\n+    static boolean hasExpectedMessage(IOException io) {\n+        String message = io.getMessage();\n+        if (message == null) return false;\n+        \/\/ exception from sendAsync()\n+        if (message.equals(\"closed\")) return true;\n+        return false;\n+    }\n+\n+    static void checkCause(String what, Throwable cause) {\n+        Throwable t = cause;\n+        Throwable accepted = null;\n+        while (t != null) {\n+            out.println(now() + what + \": checking \" + t);\n+            if (t instanceof IOException io && hasExpectedMessage(io)) {\n+                out.println(now() + what + \": Got expected message in cause: \" + io);\n+                return;\n+            } else if (t instanceof ClosedChannelException) {\n+                out.println(now() + what + \": Accepting ClosedChannelException as a valid cause: \" + t);\n+                accepted = t;\n+            }\n+            t = t.getCause();\n+        }\n+        if (accepted != null) {\n+            out.println(now() + what + \": Didn't find expected closed, \" +\n+                    \"but accepting \" + accepted.getClass().getSimpleName()\n+                    + \" as a valid cause: \" + accepted);\n+            return;\n+        }\n+        throw new AssertionError(what + \": Unexpected exception: \" + cause, cause);\n+    }\n+\n+    @Test(dataProvider = \"positive\")\n+    void testConcurrent(String uriString) throws Exception {\n+        out.printf(\"%n---- %sstarting (%s) ----%n\", now(), uriString);\n+        ExecutorService readerService = Executors.newCachedThreadPool();\n+        HttpClient client = HttpClient.newBuilder()\n+                .proxy(NO_PROXY)\n+                .followRedirects(Redirect.ALWAYS)\n+                .sslContext(sslContext)\n+                .build();\n+        TRACKER.track(client);\n+\n+        int step = RANDOM.nextInt(ITERATIONS);\n+        Throwable failed = null;\n+        try {\n+            List<CompletableFuture<String>> bodies = new ArrayList<>();\n+            for (int i = 0; i < ITERATIONS; i++) {\n+                URI uri = URI.create(uriString + \"\/concurrent\/iteration-\" + i);\n+                HttpRequest request = HttpRequest.newBuilder(uri)\n+                        .header(\"X-uuid\", \"uuid-\" + requestCounter.incrementAndGet())\n+                        .build();\n+                out.printf(now() + \"Iteration %d request: %s%n\", i, request.uri());\n+                CompletableFuture<HttpResponse<InputStream>> responseCF;\n+                CompletableFuture<String> bodyCF;\n+                final int si = i;\n+                responseCF = client.sendAsync(request, BodyHandlers.ofInputStream())\n+                        .thenApply((response) -> {\n+                            out.println(now() + si + \":  Got response: \" + response);\n+                            assertEquals(response.statusCode(), 200);\n+                            return response;\n+                        });\n+                bodyCF = responseCF.thenApplyAsync(HttpResponse::body, readerService)\n+                        .thenApply(HttpClientShutdown::readBody)\n+                        .thenApply((s) -> {\n+                            assertEquals(s, MESSAGE);\n+                            out.println(now() + si +\": Got expected message: \" + s);\n+                            return s;\n+                        });\n+                long sleep = RANDOM.nextLong(5);\n+                if (sleep > 0) {\n+                    out.printf(now() + \"%d: sleeping %d ms%n\", i, sleep);\n+                    Thread.sleep(sleep);\n+                }\n+                if (i < step) {\n+                    bodies.add(bodyCF);\n+                    continue;\n+                }\n+                if (i == step) {\n+                    out.printf(now() + \"%d: shutting down client%n\", i, sleep);\n+                    client.shutdown();\n+                }\n+                var cf = bodyCF.exceptionally((t) -> {\n+                    Throwable cause = getCause(t);\n+                    if (UncheckedIOException.class.isInstance(cause)) {\n+                        if (cause.getCause() != null) {\n+                            cause = cause.getCause();\n+                        }\n+                    }\n+                    out.println(now() + si + \": Got expected exception: \" + cause);\n+                    checkCause(String.valueOf(si), cause);\n+                    return null;\n+                });\n+                bodies.add(cf);\n+            }\n+            CompletableFuture.allOf(bodies.toArray(new CompletableFuture<?>[0])).get();\n+        } catch (Throwable throwable) {\n+            failed = throwable;\n+        } finally {\n+            failed = cleanup(client, readerService, failed);\n+        }\n+        if (failed instanceof Exception ex) throw ex;\n+        if (failed instanceof Error e) throw e;\n+        assertTrue(client.isTerminated());\n+    }\n+\n+    static Throwable cleanup(HttpClient client, ExecutorService readerService, Throwable failed) {\n+        try {\n+            try {\n+                out.println(now() + \"awaiting termination...\");\n+                if (client.awaitTermination(Duration.ofMillis(2000))) {\n+                    out.println(now() + \"Client terminated within expected delay\");\n+                } else {\n+                    out.println(now() + \"Client still running!\");\n+                    AssertionError error = new AssertionError(\"client still running\");\n+                    if (failed != null) {\n+                        failed.addSuppressed(error);\n+                    } else failed = error;\n+                }\n+            } finally {\n+                readerService.shutdown();\n+                readerService.awaitTermination(2000, TimeUnit.MILLISECONDS);\n+            }\n+        } catch (InterruptedException ie) {\n+            if (failed != null) {\n+                failed.addSuppressed(ie);\n+            } else failed = ie;\n+        }\n+        return failed;\n+    }\n+\n+    @Test(dataProvider = \"positive\")\n+    void testSequential(String uriString) throws Exception {\n+        out.printf(\"%n---- %sstarting (%s) ----%n\", now(), uriString);\n+        ExecutorService readerService = Executors.newCachedThreadPool();\n+        HttpClient client = HttpClient.newBuilder()\n+                .proxy(NO_PROXY)\n+                .followRedirects(Redirect.ALWAYS)\n+                .sslContext(sslContext)\n+                .build();\n+        TRACKER.track(client);\n+\n+        int step = RANDOM.nextInt(ITERATIONS);\n+        out.printf(now() + \"will shutdown client in step %d%n\", step);\n+        Throwable failed = null;\n+        try {\n+            for (int i = 0; i < ITERATIONS; i++) {\n+                URI uri = URI.create(uriString + \"\/sequential\/iteration-\" + i);\n+                HttpRequest request = HttpRequest.newBuilder(uri)\n+                        .header(\"X-uuid\", \"uuid-\" + requestCounter.incrementAndGet())\n+                        .build();\n+                out.printf(now() + \"Iteration %d request: %s%n\", i, request.uri());\n+                final int si = i;\n+                CompletableFuture<HttpResponse<InputStream>> responseCF;\n+                CompletableFuture<String> bodyCF;\n+                responseCF = client.sendAsync(request, BodyHandlers.ofInputStream())\n+                        .thenApply((response) -> {\n+                            out.println(now() + si + \":  Got response: \" + response);\n+                            assertEquals(response.statusCode(), 200);\n+                            return response;\n+                        });\n+                bodyCF = responseCF.thenApplyAsync(HttpResponse::body, readerService)\n+                        .thenApply(HttpClientShutdown::readBody)\n+                        .thenApply((s) -> {\n+                            assertEquals(s, MESSAGE);\n+                            return s;\n+                        })\n+                        .thenApply((s) -> {\n+                            out.println(now() + si + \":  Got body: \" + s);\n+                            return s;\n+                        });\n+                long sleep = RANDOM.nextLong(5);\n+                if (sleep > 0) {\n+                    out.printf(now() + \"%d: sleeping %d ms%n\", i, sleep);\n+                    Thread.sleep(sleep);\n+                }\n+                if (i < step) {\n+                    bodyCF.get();\n+                    continue;\n+                }\n+                if (i == step) {\n+                    out.printf(now() + \"%d: shutting down client%n\", i, sleep);\n+                    client.shutdown();\n+                }\n+                bodyCF.handle((r, t) -> {\n+                    if (t != null) {\n+                        try {\n+                            Throwable cause = getCause(t);\n+                            if (UncheckedIOException.class.isInstance(cause)) {\n+                                if (cause.getCause() != null) {\n+                                    cause = cause.getCause();\n+                                }\n+                            }\n+                            out.println(now() + si + \": Got expected exception: \" + cause);\n+                            checkCause(String.valueOf(si), cause);\n+                        } catch (Throwable ase) {\n+                            return CompletableFuture.failedFuture(ase);\n+                        }\n+                        return CompletableFuture.completedFuture(null);\n+                    } else {\n+                        return CompletableFuture.completedFuture(r);\n+                    }\n+                }).thenCompose((c) -> c).get();\n+            }\n+        } catch (Throwable throwable) {\n+            failed = throwable;\n+        } finally {\n+            failed = cleanup(client, readerService, failed);\n+        }\n+        if (failed instanceof Exception ex) throw ex;\n+        if (failed instanceof Error e) throw e;\n+        assertTrue(client.isTerminated());\n+    }\n+\n+    \/\/ -- Infrastructure\n+\n+    @BeforeTest\n+    public void setup() throws Exception {\n+        out.println(\"\\n**** Setup ****\\n\");\n+        sslContext = new SimpleSSLContext().get();\n+        if (sslContext == null)\n+            throw new AssertionError(\"Unexpected null sslContext\");\n+\n+        httpTestServer = HttpTestServer.create(HTTP_1_1);\n+        httpTestServer.addHandler(new ServerRequestHandler(), \"\/http1\/exec\/\");\n+        httpURI = \"http:\/\/\" + httpTestServer.serverAuthority() + \"\/http1\/exec\/retry\";\n+        httpsTestServer = HttpTestServer.create(HTTP_1_1, sslContext);\n+        httpsTestServer.addHandler(new ServerRequestHandler(),\"\/https1\/exec\/\");\n+        httpsURI = \"https:\/\/\" + httpsTestServer.serverAuthority() + \"\/https1\/exec\/retry\";\n+\n+        http2TestServer = HttpTestServer.create(HTTP_2);\n+        http2TestServer.addHandler(new ServerRequestHandler(), \"\/http2\/exec\/\");\n+        http2URI = \"http:\/\/\" + http2TestServer.serverAuthority() + \"\/http2\/exec\/retry\";\n+        https2TestServer = HttpTestServer.create(HTTP_2, sslContext);\n+        https2TestServer.addHandler(new ServerRequestHandler(), \"\/https2\/exec\/\");\n+        https2URI = \"https:\/\/\" + https2TestServer.serverAuthority() + \"\/https2\/exec\/retry\";\n+\n+        httpTestServer.start();\n+        httpsTestServer.start();\n+        http2TestServer.start();\n+        https2TestServer.start();\n+        start = System.nanoTime();\n+    }\n+\n+    @AfterTest\n+    public void teardown() throws Exception {\n+        Thread.sleep(100);\n+        AssertionError fail = TRACKER.checkShutdown(5000);\n+        try {\n+            httpTestServer.stop();\n+            httpsTestServer.stop();\n+            http2TestServer.stop();\n+            https2TestServer.stop();\n+        } finally {\n+            if (fail != null) throw fail;\n+        }\n+    }\n+\n+    static class ServerRequestHandler implements HttpTestHandler {\n+        ConcurrentHashMap<String,String> closedRequests = new ConcurrentHashMap<>();\n+\n+        @java.lang.Override\n+        public void handle(HttpTestExchange t) throws IOException {\n+            out.println(now() + \"ServerRequestHandler for: \" + t.getRequestURI());\n+\n+            List<String> uuids = t.getRequestHeaders().get(\"X-uuid\");\n+            if (uuids == null || uuids.size() != 1) {\n+                readAllRequestData(t);\n+                try (OutputStream os = t.getResponseBody()) {\n+                    String msg = \"Incorrect uuid header values:[\" + uuids + \"]\";\n+                    (new RuntimeException(msg)).printStackTrace();\n+                    t.sendResponseHeaders(500, -1);\n+                    os.write(msg.getBytes(UTF_8));\n+                }\n+                return;\n+            }\n+\n+            String uuid = uuids.get(0);\n+            \/\/ retrying\n+            if (closedRequests.putIfAbsent(uuid, t.getRequestURI().toString()) == null) {\n+                if (t.getExchangeVersion() == HTTP_1_1) {\n+                    \/\/ Throwing an exception here only causes a retry\n+                    \/\/ with HTTP_1_1 - where it forces the server to close\n+                    \/\/ the connection.\n+                    \/\/ For HTTP\/2 then throwing an IOE would cause the server\n+                    \/\/ to close the stream, and throwing anything else would\n+                    \/\/ cause it to close the connection, but neither would\n+                    \/\/ cause the client to retry.\n+                    \/\/ So we simply do not try to retry with HTTP\/2.\n+                    out.println(now() + \"Server will close connection, client will retry: \"\n+                            + t.getRequestURI().toString());\n+                    throw new IOException(\"Closing on first request\");\n+                }\n+            }\n+\n+            long previous;\n+            long begin = previous = System.nanoTime();\n+            \/\/ not retrying\n+            readAllRequestData(t);\n+            try (OutputStream os = t.getResponseBody()) {\n+                byte[] bytes = MESSAGE.getBytes(UTF_8);\n+                t.sendResponseHeaders(200, bytes.length);\n+                out.println(now() + \"Start sending body for: \" + t.getRequestURI());\n+                for (int i=0; i<bytes.length; i++) {\n+                    long now = System.nanoTime();\n+                    long sincePrevious = Duration.ofNanos(now - previous).toMillis();\n+                    long sinceBegin = Duration.ofNanos(now - begin).toMillis();\n+                    if (i > 0 && (sincePrevious > 25)) {\n+                        previous = now;\n+                        out.printf(\"%s%s\/%s bytes sent in %sms for: %s%n\", now(),\n+                                i, bytes.length, sinceBegin, t.getRequestURI());\n+                    }\n+                    os.write(bytes, i, 1);\n+                    os.flush();\n+                    try {\n+                        Thread.sleep(RANDOM.nextInt(5));\n+                    } catch (InterruptedException x) { }\n+                }\n+                out.println(now() + \"Body sent (\" + bytes.length + \" bytes) for: \" + t.getRequestURI());\n+            }\n+\n+            closedRequests.remove(uuid);\n+        }\n+    }\n+\n+    static void readAllRequestData(HttpTestExchange t) throws IOException {\n+        try (InputStream is = t.getRequestBody()) {\n+            is.readAllBytes();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/HttpClientShutdown.java","additions":476,"deletions":0,"binary":false,"changes":476,"status":"added"},{"patch":"@@ -0,0 +1,385 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8267140\n+ * @summary Test HttpClient::shutdownNow. Any running operation will\n+ *          be aborted and the client should eventually exit.\n+ *          This test tests shutdownNow, awaitTermination, and\n+ *          isTerminated.\n+ * @library \/test\/lib \/test\/jdk\/java\/net\/httpclient\/lib\n+ * @build jdk.httpclient.test.lib.http2.Http2TestServer jdk.test.lib.net.SimpleSSLContext\n+ *        ReferenceTracker\n+ * @run testng\/othervm\n+ *       -Djdk.internal.httpclient.debug=true\n+ *       -Djdk.httpclient.HttpClient.log=trace,headers,requests\n+ *       ShutdownNow\n+ *\/\n+\/\/ -Djdk.internal.httpclient.debug=true\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.URI;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpClient.Redirect;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpResponse;\n+import java.net.http.HttpResponse.BodyHandlers;\n+import java.nio.channels.ClosedChannelException;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionException;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.RejectedExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import jdk.httpclient.test.lib.common.HttpServerAdapters;\n+import jdk.httpclient.test.lib.http2.Http2TestServer;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLHandshakeException;\n+\n+import com.sun.net.httpserver.HttpServer;\n+import com.sun.net.httpserver.HttpsConfigurator;\n+import com.sun.net.httpserver.HttpsServer;\n+import jdk.test.lib.RandomFactory;\n+import jdk.test.lib.net.SimpleSSLContext;\n+import org.testng.annotations.AfterTest;\n+import org.testng.annotations.BeforeTest;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import static java.lang.System.out;\n+import static java.net.http.HttpClient.Builder.NO_PROXY;\n+import static java.net.http.HttpClient.Version.HTTP_1_1;\n+import static java.net.http.HttpClient.Version.HTTP_2;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertTrue;\n+import static org.testng.Assert.fail;\n+\n+public class ShutdownNow implements HttpServerAdapters {\n+\n+    static {\n+        HttpServerAdapters.enableServerLogging();\n+    }\n+    static final Random RANDOM = RandomFactory.getRandom();\n+\n+    SSLContext sslContext;\n+    HttpTestServer httpTestServer;        \/\/ HTTP\/1.1    [ 4 servers ]\n+    HttpTestServer httpsTestServer;       \/\/ HTTPS\/1.1\n+    HttpTestServer http2TestServer;       \/\/ HTTP\/2 ( h2c )\n+    HttpTestServer https2TestServer;      \/\/ HTTP\/2 ( h2  )\n+    String httpURI;\n+    String httpsURI;\n+    String http2URI;\n+    String https2URI;\n+\n+    static final String MESSAGE = \"ShutdownNow message body\";\n+    static final int ITERATIONS = 3;\n+\n+    @DataProvider(name = \"positive\")\n+    public Object[][] positive() {\n+        return new Object[][] {\n+                { httpURI,    },\n+                { httpsURI,   },\n+                { http2URI,   },\n+                { https2URI,  },\n+        };\n+    }\n+\n+    static final AtomicLong requestCounter = new AtomicLong();\n+    final ReferenceTracker TRACKER = ReferenceTracker.INSTANCE;\n+\n+    static Throwable getCause(Throwable t) {\n+        while (t instanceof CompletionException || t instanceof ExecutionException) {\n+            t = t.getCause();\n+        }\n+        return t;\n+    }\n+\n+    static boolean hasExpectedMessage(IOException io) {\n+        String message = io.getMessage();\n+        if (message == null) return false;\n+        \/\/ exception from sendAsync()\n+        if (message.equals(\"closed\")) return true;\n+        \/\/ exception from selmgr.abort\n+        if (message.equals(\"shutdownNow\")) return true;\n+        return false;\n+    }\n+\n+    static void checkCause(String what, Throwable cause) {\n+        Throwable t = cause;\n+        Throwable accepted = null;\n+        while (t != null) {\n+            out.println(what + \": checking \" + t);\n+            if (t instanceof IOException io && hasExpectedMessage(io)) {\n+                out.println(what + \": Got expected message in cause: \" + io);\n+                return;\n+            } else if (t instanceof ClosedChannelException) {\n+                out.println(what + \": Accepting ClosedChannelException as a valid cause: \" + t);\n+                accepted = t;\n+            }\n+            t = t.getCause();\n+        }\n+        if (accepted != null) {\n+            out.println(what + \": Didn't find expected shutdownNow\/closed, \" +\n+                    \"but accepting \" + accepted.getClass().getSimpleName()\n+                    + \" as a valid cause: \" + accepted);\n+            return;\n+        }\n+        throw new AssertionError(what + \": Unexpected exception: \" + cause, cause);\n+    }\n+\n+    @Test(dataProvider = \"positive\")\n+    void testConcurrent(String uriString) throws Exception {\n+        out.printf(\"%n---- starting (%s) ----%n\", uriString);\n+        HttpClient client = HttpClient.newBuilder()\n+                .proxy(NO_PROXY)\n+                .followRedirects(Redirect.ALWAYS)\n+                .sslContext(sslContext)\n+                .build();\n+        TRACKER.track(client);\n+\n+        int step = RANDOM.nextInt(ITERATIONS);\n+        try {\n+            List<CompletableFuture<HttpResponse<String>>> responses = new ArrayList<>();\n+            for (int i = 0; i < ITERATIONS; i++) {\n+                URI uri = URI.create(uriString + \"\/concurrent\/iteration-\" + i);\n+                HttpRequest request = HttpRequest.newBuilder(uri)\n+                        .header(\"X-uuid\", \"uuid-\" + requestCounter.incrementAndGet())\n+                        .build();\n+                out.printf(\"Iteration %d request: %s%n\", i, request.uri());\n+                CompletableFuture<HttpResponse<String>> responseCF;\n+                responseCF = client.sendAsync(request, BodyHandlers.ofString());\n+\n+                long sleep = RANDOM.nextLong(5);\n+                if (sleep > 0) {\n+                    out.printf(\"%d: sleeping %d ms%n\", i, sleep);\n+                    Thread.sleep(sleep);\n+                }\n+                if (i == step) {\n+                    out.printf(\"%d: shutting down client now%n\", i, sleep);\n+                    client.shutdownNow();\n+                }\n+                final int si = i;\n+                var cf = responseCF.thenApply((response) -> {\n+                    out.println(si + \":  Got response: \" + response);\n+                    out.println(si + \":  Got body Path: \" + response.body());\n+                    assertEquals(response.statusCode(), 200);\n+                    assertEquals(response.body(), MESSAGE);\n+                    return response;\n+                }).exceptionally((t) -> {\n+                    Throwable cause = getCause(t);\n+                    out.println(si + \": Got expected exception: \" + cause);\n+                    checkCause(String.valueOf(si), cause);\n+                    return null;\n+                });\n+                responses.add(cf);\n+            }\n+            CompletableFuture.allOf(responses.toArray(new CompletableFuture<?>[0])).get();\n+        } finally {\n+            if (client.awaitTermination(Duration.ofMillis(2000))) {\n+                out.println(\"Client terminated within expected delay\");\n+            } else {\n+                throw new AssertionError(\"client still running\");\n+            }\n+            assertTrue(client.isTerminated());\n+        }\n+    }\n+\n+    @Test(dataProvider = \"positive\")\n+    void testSequential(String uriString) throws Exception {\n+        out.printf(\"%n---- starting (%s) ----%n\", uriString);\n+        HttpClient client = HttpClient.newBuilder()\n+                .proxy(NO_PROXY)\n+                .followRedirects(Redirect.ALWAYS)\n+                .sslContext(sslContext)\n+                .build();\n+        TRACKER.track(client);\n+\n+        int step = RANDOM.nextInt(ITERATIONS);\n+        out.printf(\"will shutdown client in step %d%n\", step);\n+        try {\n+            for (int i = 0; i < ITERATIONS; i++) {\n+                URI uri = URI.create(uriString + \"\/sequential\/iteration-\" + i);\n+                HttpRequest request = HttpRequest.newBuilder(uri)\n+                            .header(\"X-uuid\", \"uuid-\" + requestCounter.incrementAndGet())\n+                            .build();\n+                out.printf(\"Iteration %d request: %s%n\", i, request.uri());\n+                CompletableFuture<HttpResponse<String>> responseCF;\n+                responseCF = client.sendAsync(request, BodyHandlers.ofString());\n+                long sleep = RANDOM.nextLong(5);\n+                if (sleep > 0) {\n+                    out.printf(\"%d: sleeping %d ms%n\", i, sleep);\n+                    Thread.sleep(sleep);\n+                }\n+                if (i == step) {\n+                    out.printf(\"%d: shutting down client now%n\", i, sleep);\n+                    client.shutdownNow();\n+                }\n+                final int si = i;\n+                responseCF.thenApply((response) -> {\n+                    out.println(si + \":  Got response: \" + response);\n+                    out.println(si + \":  Got body Path: \" + response.body());\n+                    assertEquals(response.statusCode(), 200);\n+                    assertEquals(response.body(), MESSAGE);\n+                    return response;\n+                }).handle((r,t) -> {\n+                    if (t != null) {\n+                        try {\n+                            Throwable cause = getCause(t);\n+                            out.println(si + \": Got expected exception: \" + cause);\n+                            checkCause(String.valueOf(si), cause);\n+                         } catch (Throwable ase) {\n+                            return CompletableFuture.failedFuture(ase);\n+                        }\n+                        return CompletableFuture.completedFuture(null);\n+                    } else {\n+                        return CompletableFuture.completedFuture(r);\n+                    }\n+                }).thenCompose((c) -> c).get();\n+            }\n+       } finally {\n+            if (client.awaitTermination(Duration.ofMillis(2000))) {\n+                out.println(\"Client terminated within expected delay\");\n+            } else {\n+                throw new AssertionError(\"client still running\");\n+            }\n+            assertTrue(client.isTerminated());\n+        }\n+    }\n+\n+    \/\/ -- Infrastructure\n+\n+    @BeforeTest\n+    public void setup() throws Exception {\n+        out.println(\"\\n**** Setup ****\\n\");\n+        sslContext = new SimpleSSLContext().get();\n+        if (sslContext == null)\n+            throw new AssertionError(\"Unexpected null sslContext\");\n+\n+        httpTestServer = HttpTestServer.create(HTTP_1_1);\n+        httpTestServer.addHandler(new ServerRequestHandler(), \"\/http1\/exec\/\");\n+        httpURI = \"http:\/\/\" + httpTestServer.serverAuthority() + \"\/http1\/exec\/retry\";\n+        httpsTestServer = HttpTestServer.create(HTTP_1_1, sslContext);\n+        httpsTestServer.addHandler(new ServerRequestHandler(),\"\/https1\/exec\/\");\n+        httpsURI = \"https:\/\/\" + httpsTestServer.serverAuthority() + \"\/https1\/exec\/retry\";\n+\n+        http2TestServer = HttpTestServer.create(HTTP_2);\n+        http2TestServer.addHandler(new ServerRequestHandler(), \"\/http2\/exec\/\");\n+        http2URI = \"http:\/\/\" + http2TestServer.serverAuthority() + \"\/http2\/exec\/retry\";\n+        https2TestServer = HttpTestServer.create(HTTP_2, sslContext);\n+        https2TestServer.addHandler(new ServerRequestHandler(), \"\/https2\/exec\/\");\n+        https2URI = \"https:\/\/\" + https2TestServer.serverAuthority() + \"\/https2\/exec\/retry\";\n+\n+        httpTestServer.start();\n+        httpsTestServer.start();\n+        http2TestServer.start();\n+        https2TestServer.start();\n+    }\n+\n+    @AfterTest\n+    public void teardown() throws Exception {\n+        Thread.sleep(100);\n+        AssertionError fail = TRACKER.check(5000);\n+        try {\n+            httpTestServer.stop();\n+            httpsTestServer.stop();\n+            http2TestServer.stop();\n+            https2TestServer.stop();\n+        } finally {\n+            if (fail != null) throw fail;\n+        }\n+    }\n+\n+    static class ServerRequestHandler implements HttpTestHandler {\n+        ConcurrentHashMap<String,String> closedRequests = new ConcurrentHashMap<>();\n+\n+        @java.lang.Override\n+        public void handle(HttpTestExchange t) throws IOException {\n+            out.println(\"ServerRequestHandler for: \" + t.getRequestURI());\n+\n+            List<String> uuids = t.getRequestHeaders().get(\"X-uuid\");\n+            if (uuids == null || uuids.size() != 1) {\n+                readAllRequestData(t);\n+                try (OutputStream os = t.getResponseBody()) {\n+                    String msg = \"Incorrect uuid header values:[\" + uuids + \"]\";\n+                    (new RuntimeException(msg)).printStackTrace();\n+                    t.sendResponseHeaders(500, -1);\n+                    os.write(msg.getBytes(UTF_8));\n+                }\n+                return;\n+            }\n+\n+            String uuid = uuids.get(0);\n+            \/\/ retrying\n+            if (closedRequests.putIfAbsent(uuid, t.getRequestURI().toString()) == null) {\n+                if (t.getExchangeVersion() == HTTP_1_1) {\n+                    \/\/ Throwing an exception here only causes a retry\n+                    \/\/ with HTTP_1_1 - where it forces the server to close\n+                    \/\/ the connection.\n+                    \/\/ For HTTP\/2 then throwing an IOE would cause the server\n+                    \/\/ to close the stream, and throwing anything else would\n+                    \/\/ cause it to close the connection, but neither would\n+                    \/\/ cause the client to retry.\n+                    \/\/ So we simply do not try to retry with HTTP\/2.\n+                    out.println(\"Server will close connection, client will retry: \"\n+                            + t.getRequestURI().toString());\n+                    throw new IOException(\"Closing on first request\");\n+                }\n+            }\n+\n+            \/\/ not retrying\n+            readAllRequestData(t);\n+            try (OutputStream os = t.getResponseBody()) {\n+                byte[] bytes = MESSAGE.getBytes(UTF_8);\n+                t.sendResponseHeaders(200, bytes.length);\n+                for (int i=0; i<bytes.length; i++) {\n+                    os.write(bytes, i, 1);\n+                    os.flush();\n+                    try {\n+                        Thread.sleep(RANDOM.nextInt(5));\n+                    } catch (InterruptedException x) { }\n+                }\n+            }\n+\n+            closedRequests.remove(uuid);\n+        }\n+    }\n+\n+    static void readAllRequestData(HttpTestExchange t) throws IOException {\n+        try (InputStream is = t.getRequestBody()) {\n+            is.readAllBytes();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/ShutdownNow.java","additions":385,"deletions":0,"binary":false,"changes":385,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -115,0 +115,30 @@\n+\n+    @Override\n+    public boolean isTerminated() {\n+        return client.isTerminated();\n+    }\n+\n+    @Override\n+    public void shutdown() {\n+        client.shutdown();\n+    }\n+\n+    @Override\n+    public void shutdownNow() {\n+        client.shutdownNow();\n+    }\n+\n+    @Override\n+    public boolean awaitTermination(Duration duration) throws InterruptedException {\n+        return client.awaitTermination(duration);\n+    }\n+\n+    @Override\n+    public void close() { client.close(); }\n+\n+    \/**\n+     * Invokes the default implementation of HttpClient::close\n+     * Can be invoked by subclasses if necessary.\n+     *\/\n+    protected void defaultClose() { super.close();}\n+\n","filename":"test\/jdk\/java\/net\/httpclient\/offline\/DelegatingHttpClient.java","additions":31,"deletions":1,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import java.time.Duration;\n@@ -30,0 +31,1 @@\n+import java.util.Arrays;\n@@ -32,0 +34,1 @@\n+import java.util.Objects;\n@@ -34,0 +37,2 @@\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.ExecutionException;\n@@ -43,0 +48,3 @@\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n@@ -49,0 +57,3 @@\n+ * Can delegate to an actual HttpClient created from a supplied\n+ * HttpClient.Builder if needed, by calling methods on its\n+ * DelegatingHttpClient super class.\n@@ -56,0 +67,2 @@\n+    private final ConcurrentLinkedQueue<CompletableFuture<?>> responses = new ConcurrentLinkedQueue();\n+    volatile boolean shutdownRequested;\n@@ -184,0 +197,7 @@\n+        CompletableFuture<HttpResponse<T>> cf = new CompletableFuture<>();\n+        synchronized (this) {\n+            if (shutdownRequested) {\n+                return CompletableFuture.failedFuture(new IOException(\"closed\"));\n+            }\n+            responses.add(cf);\n+        }\n@@ -204,1 +224,0 @@\n-        CompletableFuture<HttpResponse<T>> cf = new CompletableFuture<>();\n@@ -206,0 +225,1 @@\n+                    responses.remove(cf);\n@@ -243,0 +263,71 @@\n+\n+    @Override\n+    public boolean isTerminated() {\n+        \/\/ return true if this and the wrapped client are terminated\n+        synchronized (this) {\n+            if (!shutdownRequested) return false;\n+            return responses.isEmpty() && super.isTerminated();\n+        }\n+    }\n+\n+    @Override\n+    public void shutdown() {\n+        \/\/ shutdown the wrapped client\n+        super.shutdown();\n+        \/\/ mark shutdown requested\n+        shutdownRequested = true;\n+    }\n+\n+    @Override\n+    public void shutdownNow() {\n+        \/\/ shutdown the wrapped client now\n+        super.shutdownNow();\n+        \/\/ mark shutdown requested\n+        shutdownRequested = true;\n+        \/\/ cancel all completable futures\n+        CompletableFuture[] futures;\n+        synchronized (this) {\n+            if (responses.isEmpty()) return ;\n+            futures = responses.toArray(CompletableFuture[]::new);\n+            responses.removeAll(Arrays.asList(futures));\n+        }\n+        for (var op : futures) {\n+            op.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public boolean awaitTermination(Duration duration) throws InterruptedException {\n+        Objects.requireNonNull(duration);\n+        CompletableFuture[] futures = responses.toArray(CompletableFuture[]::new);\n+        if (futures.length == 0) {\n+            \/\/ nothing to do here: wait for the wrapped client\n+            return super.awaitTermination(duration) && isTerminated();\n+        }\n+\n+        \/\/ waits for our own completable futures to get completed\n+        var all = CompletableFuture.allOf(futures);\n+        Duration max = Duration.ofMillis(Long.MAX_VALUE);\n+        long timeout = duration.compareTo(max) > 0 ? Long.MAX_VALUE : duration.toMillis();\n+        try {\n+            all.exceptionally((t) -> null).get(timeout, TimeUnit.MILLISECONDS);\n+        } catch (TimeoutException te) {\n+            return isTerminated();\n+        } catch (InterruptedException ie) {\n+            throw ie;\n+        } catch (ExecutionException failed) {\n+            return isTerminated();\n+        }\n+        return isTerminated();\n+    }\n+\n+    @Override\n+    public void close() {\n+        try {\n+            \/\/ closes this client\n+            defaultClose();\n+        } finally {\n+            \/\/ closes the wrapped client (which should already be closed)\n+            super.close();\n+        }\n+    }\n","filename":"test\/jdk\/java\/net\/httpclient\/offline\/FixedResponseHttpClient.java","additions":93,"deletions":2,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -66,13 +66,15 @@\n-        HttpClient client = getClient();\n-\n-        HttpRequest request = HttpRequest.newBuilder()\n-                .uri(URI.create(\"https:\/\/openjdk.org\/\"))\n-                .build();\n-\n-        client.sendAsync(request, BodyHandlers.ofString())\n-                .thenAccept(response -> {\n-                    System.out.println(\"response: \" + response);\n-                    assertEquals(response.statusCode(), 200);\n-                    assertTrue(response.headers().firstValue(\"Server\").isPresent());\n-                    assertEquals(response.body(), \"A response message\"); } )\n-                .join();\n+        try (HttpClient client = getClient()) {\n+\n+            HttpRequest request = HttpRequest.newBuilder()\n+                    .uri(URI.create(\"https:\/\/openjdk.org\/\"))\n+                    .build();\n+\n+            client.sendAsync(request, BodyHandlers.ofString())\n+                    .thenAccept(response -> {\n+                        System.out.println(\"response: \" + response);\n+                        assertEquals(response.statusCode(), 200);\n+                        assertTrue(response.headers().firstValue(\"Server\").isPresent());\n+                        assertEquals(response.body(), \"A response message\");\n+                    })\n+                    .join();\n+        }\n@@ -83,13 +85,15 @@\n-        HttpClient client = getClient();\n-\n-        HttpRequest request = HttpRequest.newBuilder()\n-                .uri(URI.create(\"https:\/\/openjdk.org\/\"))\n-                .build();\n-\n-        client.sendAsync(request, BodyHandlers.ofByteArray())\n-                .thenAccept(response -> {\n-                    System.out.println(\"response: \" + response);\n-                    assertEquals(response.statusCode(), 200);\n-                    assertTrue(response.headers().firstValue(\"Content-Type\").isPresent());\n-                    assertEquals(response.body(), \"A response message\".getBytes(UTF_8)); } )\n-                .join();\n+        try (HttpClient client = getClient()) {\n+\n+            HttpRequest request = HttpRequest.newBuilder()\n+                    .uri(URI.create(\"https:\/\/openjdk.org\/\"))\n+                    .build();\n+\n+            client.sendAsync(request, BodyHandlers.ofByteArray())\n+                    .thenAccept(response -> {\n+                        System.out.println(\"response: \" + response);\n+                        assertEquals(response.statusCode(), 200);\n+                        assertTrue(response.headers().firstValue(\"Content-Type\").isPresent());\n+                        assertEquals(response.body(), \"A response message\".getBytes(UTF_8));\n+                    })\n+                    .join();\n+        }\n@@ -101,1 +105,1 @@\n-        HttpClient client = FixedResponseHttpClient.createClientFrom(\n+        HttpClient fixedClient = FixedResponseHttpClient.createClientFrom(\n@@ -121,8 +125,12 @@\n-        client.sendAsync(request, BodyHandlers.ofString())\n-                .thenAccept(response -> {\n-                    assertEquals(response.statusCode(), 404);\n-                    response.headers().firstValue(\"Content-Type\")\n-                            .ifPresentOrElse(type -> assertEquals(type, \"text\/html\"),\n-                                             () -> fail(\"Content-Type not present\"));\n-                    assertTrue(response.body().contains(\"404 Not Found\")); } )\n-                .join();\n+        try (var client = fixedClient) {\n+            client.sendAsync(request, BodyHandlers.ofString())\n+                    .thenAccept(response -> {\n+                        assertEquals(response.statusCode(), 404);\n+                        response.headers().firstValue(\"Content-Type\")\n+                                .ifPresentOrElse(type -> assertEquals(type, \"text\/html\"),\n+                                        () -> fail(\"Content-Type not present\"));\n+                        assertTrue(response.body().contains(\"404 Not Found\"));\n+                    })\n+                    .join();\n+        }\n+        assertTrue(fixedClient.isTerminated());\n@@ -133,1 +141,1 @@\n-        HttpClient client = FixedResponseHttpClient.createEchoClient(\n+        try (HttpClient client = FixedResponseHttpClient.createEchoClient(\n@@ -136,13 +144,15 @@\n-                headersOf(\"Connection\",  \"keep-alive\"));\n-\n-        HttpRequest request = HttpRequest.newBuilder()\n-                .uri(URI.create(\"https:\/\/openjdk.org\/echo\"))\n-                .POST(BodyPublishers.ofString(\"Hello World\"))\n-                .build();\n-\n-        client.sendAsync(request, BodyHandlers.ofString())\n-                .thenAccept(response -> {\n-                    System.out.println(\"response: \" + response);\n-                    assertEquals(response.statusCode(), 200);\n-                    assertEquals(response.body(), \"Hello World\"); } )\n-                .join();\n+                headersOf(\"Connection\",  \"keep-alive\"))) {\n+\n+            HttpRequest request = HttpRequest.newBuilder()\n+                    .uri(URI.create(\"https:\/\/openjdk.org\/echo\"))\n+                    .POST(BodyPublishers.ofString(\"Hello World\"))\n+                    .build();\n+\n+            client.sendAsync(request, BodyHandlers.ofString())\n+                    .thenAccept(response -> {\n+                        System.out.println(\"response: \" + response);\n+                        assertEquals(response.statusCode(), 200);\n+                        assertEquals(response.body(), \"Hello World\");\n+                    })\n+                    .join();\n+        }\n@@ -153,1 +163,1 @@\n-        HttpClient client = FixedResponseHttpClient.createEchoClient(\n+        try (HttpClient client = FixedResponseHttpClient.createEchoClient(\n@@ -156,1 +166,1 @@\n-                headersOf(\"Connection\",  \"keep-alive\"));\n+                headersOf(\"Connection\",  \"keep-alive\"))) {\n@@ -158,4 +168,4 @@\n-        HttpRequest request = HttpRequest.newBuilder()\n-                .uri(URI.create(\"https:\/\/openjdk.org\/echo\"))\n-                .POST(BodyPublishers.ofString(\"Hello chegar!!\"))\n-                .build();\n+            HttpRequest request = HttpRequest.newBuilder()\n+                    .uri(URI.create(\"https:\/\/openjdk.org\/echo\"))\n+                    .POST(BodyPublishers.ofString(\"Hello chegar!!\"))\n+                    .build();\n@@ -163,4 +173,5 @@\n-        HttpResponse<String> response = client.send(request, BodyHandlers.ofString());\n-        System.out.println(\"response: \" + response);\n-        assertEquals(response.statusCode(), 200);\n-        assertEquals(response.body(), \"Hello chegar!!\");\n+            HttpResponse<String> response = client.send(request, BodyHandlers.ofString());\n+            System.out.println(\"response: \" + response);\n+            assertEquals(response.statusCode(), 200);\n+            assertEquals(response.body(), \"Hello chegar!!\");\n+        }\n","filename":"test\/jdk\/java\/net\/httpclient\/offline\/OfflineTesting.java","additions":70,"deletions":59,"binary":false,"changes":129,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -472,2 +472,3 @@\n-                } else if ((test == TEST_INTR) && (op == TRANSFER_FROM)) {\n-                    \/\/ Let this case pass -- CBIE applies to other channel\n+                } else if ((test == TEST_INTR || test == TEST_PREINTR)\n+                        && (op == TRANSFER_FROM)) {\n+                    \/\/ Let these cases pass -- CBIE applies to other channel\n","filename":"test\/jdk\/java\/nio\/channels\/AsyncCloseAndInterrupt.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -98,2 +98,5 @@\n-        if (bytesWritten > 0)\n-            throw new RuntimeException(\"Wrote past file size\");\n+        if (bytesWritten > 10)\n+            throw new RuntimeException(\"Wrote too many bytes\");\n+\n+        if (sinkChannel.size() != 1000 + bytesWritten)\n+            throw new RuntimeException(\"Unexpected sink size\");\n","filename":"test\/jdk\/java\/nio\/channels\/FileChannel\/Transfer.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -5852,0 +5852,76 @@\n+    static boolean band(boolean a, boolean b) {\n+        return a & b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskAndByte128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.and(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Byte128VectorTests::band);\n+    }\n+\n+    static boolean bor(boolean a, boolean b) {\n+        return a | b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskOrByte128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.or(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Byte128VectorTests::bor);\n+    }\n+\n+    static boolean bxor(boolean a, boolean b) {\n+        return a != b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskXorByte128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.xor(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Byte128VectorTests::bxor);\n+    }\n+\n+    static boolean bandNot(boolean a, boolean b) {\n+        return a & !b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskAndNotByte128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.andNot(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Byte128VectorTests::bandNot);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte128VectorTests.java","additions":76,"deletions":0,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -5852,0 +5852,76 @@\n+    static boolean band(boolean a, boolean b) {\n+        return a & b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskAndByte256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.and(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Byte256VectorTests::band);\n+    }\n+\n+    static boolean bor(boolean a, boolean b) {\n+        return a | b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskOrByte256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.or(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Byte256VectorTests::bor);\n+    }\n+\n+    static boolean bxor(boolean a, boolean b) {\n+        return a != b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskXorByte256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.xor(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Byte256VectorTests::bxor);\n+    }\n+\n+    static boolean bandNot(boolean a, boolean b) {\n+        return a & !b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskAndNotByte256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.andNot(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Byte256VectorTests::bandNot);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte256VectorTests.java","additions":76,"deletions":0,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -5852,0 +5852,76 @@\n+    static boolean band(boolean a, boolean b) {\n+        return a & b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskAndByte512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.and(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Byte512VectorTests::band);\n+    }\n+\n+    static boolean bor(boolean a, boolean b) {\n+        return a | b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskOrByte512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.or(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Byte512VectorTests::bor);\n+    }\n+\n+    static boolean bxor(boolean a, boolean b) {\n+        return a != b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskXorByte512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.xor(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Byte512VectorTests::bxor);\n+    }\n+\n+    static boolean bandNot(boolean a, boolean b) {\n+        return a & !b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskAndNotByte512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.andNot(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Byte512VectorTests::bandNot);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte512VectorTests.java","additions":76,"deletions":0,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -5852,0 +5852,76 @@\n+    static boolean band(boolean a, boolean b) {\n+        return a & b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskAndByte64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.and(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Byte64VectorTests::band);\n+    }\n+\n+    static boolean bor(boolean a, boolean b) {\n+        return a | b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskOrByte64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.or(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Byte64VectorTests::bor);\n+    }\n+\n+    static boolean bxor(boolean a, boolean b) {\n+        return a != b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskXorByte64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.xor(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Byte64VectorTests::bxor);\n+    }\n+\n+    static boolean bandNot(boolean a, boolean b) {\n+        return a & !b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskAndNotByte64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.andNot(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Byte64VectorTests::bandNot);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte64VectorTests.java","additions":76,"deletions":0,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -5857,0 +5857,76 @@\n+    static boolean band(boolean a, boolean b) {\n+        return a & b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskAndByteMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.and(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, ByteMaxVectorTests::band);\n+    }\n+\n+    static boolean bor(boolean a, boolean b) {\n+        return a | b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskOrByteMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.or(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, ByteMaxVectorTests::bor);\n+    }\n+\n+    static boolean bxor(boolean a, boolean b) {\n+        return a != b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskXorByteMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.xor(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, ByteMaxVectorTests::bxor);\n+    }\n+\n+    static boolean bandNot(boolean a, boolean b) {\n+        return a & !b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskAndNotByteMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.andNot(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, ByteMaxVectorTests::bandNot);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ByteMaxVectorTests.java","additions":76,"deletions":0,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -4883,0 +4883,76 @@\n+    static boolean band(boolean a, boolean b) {\n+        return a & b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskAndDouble128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.and(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Double128VectorTests::band);\n+    }\n+\n+    static boolean bor(boolean a, boolean b) {\n+        return a | b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskOrDouble128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.or(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Double128VectorTests::bor);\n+    }\n+\n+    static boolean bxor(boolean a, boolean b) {\n+        return a != b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskXorDouble128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.xor(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Double128VectorTests::bxor);\n+    }\n+\n+    static boolean bandNot(boolean a, boolean b) {\n+        return a & !b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskAndNotDouble128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.andNot(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Double128VectorTests::bandNot);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double128VectorTests.java","additions":76,"deletions":0,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -4883,0 +4883,76 @@\n+    static boolean band(boolean a, boolean b) {\n+        return a & b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskAndDouble256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.and(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Double256VectorTests::band);\n+    }\n+\n+    static boolean bor(boolean a, boolean b) {\n+        return a | b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskOrDouble256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.or(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Double256VectorTests::bor);\n+    }\n+\n+    static boolean bxor(boolean a, boolean b) {\n+        return a != b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskXorDouble256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.xor(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Double256VectorTests::bxor);\n+    }\n+\n+    static boolean bandNot(boolean a, boolean b) {\n+        return a & !b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskAndNotDouble256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.andNot(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Double256VectorTests::bandNot);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double256VectorTests.java","additions":76,"deletions":0,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -4883,0 +4883,76 @@\n+    static boolean band(boolean a, boolean b) {\n+        return a & b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskAndDouble512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.and(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Double512VectorTests::band);\n+    }\n+\n+    static boolean bor(boolean a, boolean b) {\n+        return a | b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskOrDouble512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.or(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Double512VectorTests::bor);\n+    }\n+\n+    static boolean bxor(boolean a, boolean b) {\n+        return a != b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskXorDouble512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.xor(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Double512VectorTests::bxor);\n+    }\n+\n+    static boolean bandNot(boolean a, boolean b) {\n+        return a & !b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskAndNotDouble512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.andNot(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Double512VectorTests::bandNot);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double512VectorTests.java","additions":76,"deletions":0,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -4883,0 +4883,76 @@\n+    static boolean band(boolean a, boolean b) {\n+        return a & b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskAndDouble64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.and(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Double64VectorTests::band);\n+    }\n+\n+    static boolean bor(boolean a, boolean b) {\n+        return a | b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskOrDouble64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.or(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Double64VectorTests::bor);\n+    }\n+\n+    static boolean bxor(boolean a, boolean b) {\n+        return a != b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskXorDouble64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.xor(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Double64VectorTests::bxor);\n+    }\n+\n+    static boolean bandNot(boolean a, boolean b) {\n+        return a & !b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskAndNotDouble64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.andNot(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Double64VectorTests::bandNot);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double64VectorTests.java","additions":76,"deletions":0,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -4888,0 +4888,76 @@\n+    static boolean band(boolean a, boolean b) {\n+        return a & b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskAndDoubleMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.and(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, DoubleMaxVectorTests::band);\n+    }\n+\n+    static boolean bor(boolean a, boolean b) {\n+        return a | b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskOrDoubleMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.or(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, DoubleMaxVectorTests::bor);\n+    }\n+\n+    static boolean bxor(boolean a, boolean b) {\n+        return a != b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskXorDoubleMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.xor(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, DoubleMaxVectorTests::bxor);\n+    }\n+\n+    static boolean bandNot(boolean a, boolean b) {\n+        return a & !b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskAndNotDoubleMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.andNot(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, DoubleMaxVectorTests::bandNot);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/DoubleMaxVectorTests.java","additions":76,"deletions":0,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -4862,0 +4862,76 @@\n+    static boolean band(boolean a, boolean b) {\n+        return a & b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskAndFloat128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.and(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Float128VectorTests::band);\n+    }\n+\n+    static boolean bor(boolean a, boolean b) {\n+        return a | b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskOrFloat128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.or(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Float128VectorTests::bor);\n+    }\n+\n+    static boolean bxor(boolean a, boolean b) {\n+        return a != b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskXorFloat128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.xor(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Float128VectorTests::bxor);\n+    }\n+\n+    static boolean bandNot(boolean a, boolean b) {\n+        return a & !b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskAndNotFloat128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.andNot(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Float128VectorTests::bandNot);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float128VectorTests.java","additions":76,"deletions":0,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -4862,0 +4862,76 @@\n+    static boolean band(boolean a, boolean b) {\n+        return a & b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskAndFloat256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.and(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Float256VectorTests::band);\n+    }\n+\n+    static boolean bor(boolean a, boolean b) {\n+        return a | b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskOrFloat256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.or(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Float256VectorTests::bor);\n+    }\n+\n+    static boolean bxor(boolean a, boolean b) {\n+        return a != b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskXorFloat256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.xor(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Float256VectorTests::bxor);\n+    }\n+\n+    static boolean bandNot(boolean a, boolean b) {\n+        return a & !b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskAndNotFloat256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.andNot(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Float256VectorTests::bandNot);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float256VectorTests.java","additions":76,"deletions":0,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -4862,0 +4862,76 @@\n+    static boolean band(boolean a, boolean b) {\n+        return a & b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskAndFloat512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.and(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Float512VectorTests::band);\n+    }\n+\n+    static boolean bor(boolean a, boolean b) {\n+        return a | b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskOrFloat512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.or(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Float512VectorTests::bor);\n+    }\n+\n+    static boolean bxor(boolean a, boolean b) {\n+        return a != b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskXorFloat512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.xor(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Float512VectorTests::bxor);\n+    }\n+\n+    static boolean bandNot(boolean a, boolean b) {\n+        return a & !b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskAndNotFloat512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.andNot(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Float512VectorTests::bandNot);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float512VectorTests.java","additions":76,"deletions":0,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -4862,0 +4862,76 @@\n+    static boolean band(boolean a, boolean b) {\n+        return a & b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskAndFloat64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.and(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Float64VectorTests::band);\n+    }\n+\n+    static boolean bor(boolean a, boolean b) {\n+        return a | b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskOrFloat64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.or(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Float64VectorTests::bor);\n+    }\n+\n+    static boolean bxor(boolean a, boolean b) {\n+        return a != b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskXorFloat64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.xor(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Float64VectorTests::bxor);\n+    }\n+\n+    static boolean bandNot(boolean a, boolean b) {\n+        return a & !b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskAndNotFloat64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.andNot(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Float64VectorTests::bandNot);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float64VectorTests.java","additions":76,"deletions":0,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -4867,0 +4867,76 @@\n+    static boolean band(boolean a, boolean b) {\n+        return a & b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskAndFloatMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.and(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, FloatMaxVectorTests::band);\n+    }\n+\n+    static boolean bor(boolean a, boolean b) {\n+        return a | b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskOrFloatMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.or(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, FloatMaxVectorTests::bor);\n+    }\n+\n+    static boolean bxor(boolean a, boolean b) {\n+        return a != b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskXorFloatMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.xor(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, FloatMaxVectorTests::bxor);\n+    }\n+\n+    static boolean bandNot(boolean a, boolean b) {\n+        return a & !b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskAndNotFloatMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.andNot(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, FloatMaxVectorTests::bandNot);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/FloatMaxVectorTests.java","additions":76,"deletions":0,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -5885,0 +5885,76 @@\n+    static boolean band(boolean a, boolean b) {\n+        return a & b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskAndInt128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.and(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Int128VectorTests::band);\n+    }\n+\n+    static boolean bor(boolean a, boolean b) {\n+        return a | b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskOrInt128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.or(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Int128VectorTests::bor);\n+    }\n+\n+    static boolean bxor(boolean a, boolean b) {\n+        return a != b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskXorInt128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.xor(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Int128VectorTests::bxor);\n+    }\n+\n+    static boolean bandNot(boolean a, boolean b) {\n+        return a & !b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskAndNotInt128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.andNot(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Int128VectorTests::bandNot);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int128VectorTests.java","additions":76,"deletions":0,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -5885,0 +5885,76 @@\n+    static boolean band(boolean a, boolean b) {\n+        return a & b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskAndInt256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.and(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Int256VectorTests::band);\n+    }\n+\n+    static boolean bor(boolean a, boolean b) {\n+        return a | b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskOrInt256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.or(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Int256VectorTests::bor);\n+    }\n+\n+    static boolean bxor(boolean a, boolean b) {\n+        return a != b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskXorInt256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.xor(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Int256VectorTests::bxor);\n+    }\n+\n+    static boolean bandNot(boolean a, boolean b) {\n+        return a & !b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskAndNotInt256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.andNot(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Int256VectorTests::bandNot);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int256VectorTests.java","additions":76,"deletions":0,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -5885,0 +5885,76 @@\n+    static boolean band(boolean a, boolean b) {\n+        return a & b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskAndInt512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.and(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Int512VectorTests::band);\n+    }\n+\n+    static boolean bor(boolean a, boolean b) {\n+        return a | b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskOrInt512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.or(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Int512VectorTests::bor);\n+    }\n+\n+    static boolean bxor(boolean a, boolean b) {\n+        return a != b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskXorInt512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.xor(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Int512VectorTests::bxor);\n+    }\n+\n+    static boolean bandNot(boolean a, boolean b) {\n+        return a & !b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskAndNotInt512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.andNot(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Int512VectorTests::bandNot);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int512VectorTests.java","additions":76,"deletions":0,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -5885,0 +5885,76 @@\n+    static boolean band(boolean a, boolean b) {\n+        return a & b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskAndInt64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.and(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Int64VectorTests::band);\n+    }\n+\n+    static boolean bor(boolean a, boolean b) {\n+        return a | b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskOrInt64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.or(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Int64VectorTests::bor);\n+    }\n+\n+    static boolean bxor(boolean a, boolean b) {\n+        return a != b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskXorInt64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.xor(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Int64VectorTests::bxor);\n+    }\n+\n+    static boolean bandNot(boolean a, boolean b) {\n+        return a & !b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskAndNotInt64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.andNot(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Int64VectorTests::bandNot);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int64VectorTests.java","additions":76,"deletions":0,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -5890,0 +5890,76 @@\n+    static boolean band(boolean a, boolean b) {\n+        return a & b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskAndIntMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.and(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, IntMaxVectorTests::band);\n+    }\n+\n+    static boolean bor(boolean a, boolean b) {\n+        return a | b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskOrIntMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.or(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, IntMaxVectorTests::bor);\n+    }\n+\n+    static boolean bxor(boolean a, boolean b) {\n+        return a != b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskXorIntMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.xor(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, IntMaxVectorTests::bxor);\n+    }\n+\n+    static boolean bandNot(boolean a, boolean b) {\n+        return a & !b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskAndNotIntMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.andNot(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, IntMaxVectorTests::bandNot);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/IntMaxVectorTests.java","additions":76,"deletions":0,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -5771,0 +5771,76 @@\n+    static boolean band(boolean a, boolean b) {\n+        return a & b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskAndLong128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.and(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Long128VectorTests::band);\n+    }\n+\n+    static boolean bor(boolean a, boolean b) {\n+        return a | b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskOrLong128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.or(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Long128VectorTests::bor);\n+    }\n+\n+    static boolean bxor(boolean a, boolean b) {\n+        return a != b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskXorLong128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.xor(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Long128VectorTests::bxor);\n+    }\n+\n+    static boolean bandNot(boolean a, boolean b) {\n+        return a & !b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskAndNotLong128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.andNot(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Long128VectorTests::bandNot);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long128VectorTests.java","additions":76,"deletions":0,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -5771,0 +5771,76 @@\n+    static boolean band(boolean a, boolean b) {\n+        return a & b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskAndLong256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.and(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Long256VectorTests::band);\n+    }\n+\n+    static boolean bor(boolean a, boolean b) {\n+        return a | b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskOrLong256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.or(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Long256VectorTests::bor);\n+    }\n+\n+    static boolean bxor(boolean a, boolean b) {\n+        return a != b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskXorLong256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.xor(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Long256VectorTests::bxor);\n+    }\n+\n+    static boolean bandNot(boolean a, boolean b) {\n+        return a & !b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskAndNotLong256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.andNot(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Long256VectorTests::bandNot);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long256VectorTests.java","additions":76,"deletions":0,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -5771,0 +5771,76 @@\n+    static boolean band(boolean a, boolean b) {\n+        return a & b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskAndLong512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.and(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Long512VectorTests::band);\n+    }\n+\n+    static boolean bor(boolean a, boolean b) {\n+        return a | b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskOrLong512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.or(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Long512VectorTests::bor);\n+    }\n+\n+    static boolean bxor(boolean a, boolean b) {\n+        return a != b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskXorLong512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.xor(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Long512VectorTests::bxor);\n+    }\n+\n+    static boolean bandNot(boolean a, boolean b) {\n+        return a & !b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskAndNotLong512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.andNot(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Long512VectorTests::bandNot);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long512VectorTests.java","additions":76,"deletions":0,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -5771,0 +5771,76 @@\n+    static boolean band(boolean a, boolean b) {\n+        return a & b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskAndLong64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.and(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Long64VectorTests::band);\n+    }\n+\n+    static boolean bor(boolean a, boolean b) {\n+        return a | b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskOrLong64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.or(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Long64VectorTests::bor);\n+    }\n+\n+    static boolean bxor(boolean a, boolean b) {\n+        return a != b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskXorLong64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.xor(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Long64VectorTests::bxor);\n+    }\n+\n+    static boolean bandNot(boolean a, boolean b) {\n+        return a & !b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskAndNotLong64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.andNot(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Long64VectorTests::bandNot);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long64VectorTests.java","additions":76,"deletions":0,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -5776,0 +5776,76 @@\n+    static boolean band(boolean a, boolean b) {\n+        return a & b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskAndLongMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.and(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, LongMaxVectorTests::band);\n+    }\n+\n+    static boolean bor(boolean a, boolean b) {\n+        return a | b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskOrLongMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.or(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, LongMaxVectorTests::bor);\n+    }\n+\n+    static boolean bxor(boolean a, boolean b) {\n+        return a != b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskXorLongMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.xor(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, LongMaxVectorTests::bxor);\n+    }\n+\n+    static boolean bandNot(boolean a, boolean b) {\n+        return a & !b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskAndNotLongMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.andNot(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, LongMaxVectorTests::bandNot);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/LongMaxVectorTests.java","additions":76,"deletions":0,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -5832,0 +5832,76 @@\n+    static boolean band(boolean a, boolean b) {\n+        return a & b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskAndShort128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.and(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Short128VectorTests::band);\n+    }\n+\n+    static boolean bor(boolean a, boolean b) {\n+        return a | b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskOrShort128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.or(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Short128VectorTests::bor);\n+    }\n+\n+    static boolean bxor(boolean a, boolean b) {\n+        return a != b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskXorShort128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.xor(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Short128VectorTests::bxor);\n+    }\n+\n+    static boolean bandNot(boolean a, boolean b) {\n+        return a & !b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskAndNotShort128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.andNot(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Short128VectorTests::bandNot);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short128VectorTests.java","additions":76,"deletions":0,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -5832,0 +5832,76 @@\n+    static boolean band(boolean a, boolean b) {\n+        return a & b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskAndShort256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.and(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Short256VectorTests::band);\n+    }\n+\n+    static boolean bor(boolean a, boolean b) {\n+        return a | b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskOrShort256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.or(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Short256VectorTests::bor);\n+    }\n+\n+    static boolean bxor(boolean a, boolean b) {\n+        return a != b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskXorShort256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.xor(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Short256VectorTests::bxor);\n+    }\n+\n+    static boolean bandNot(boolean a, boolean b) {\n+        return a & !b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskAndNotShort256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.andNot(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Short256VectorTests::bandNot);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short256VectorTests.java","additions":76,"deletions":0,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -5832,0 +5832,76 @@\n+    static boolean band(boolean a, boolean b) {\n+        return a & b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskAndShort512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.and(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Short512VectorTests::band);\n+    }\n+\n+    static boolean bor(boolean a, boolean b) {\n+        return a | b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskOrShort512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.or(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Short512VectorTests::bor);\n+    }\n+\n+    static boolean bxor(boolean a, boolean b) {\n+        return a != b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskXorShort512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.xor(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Short512VectorTests::bxor);\n+    }\n+\n+    static boolean bandNot(boolean a, boolean b) {\n+        return a & !b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskAndNotShort512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.andNot(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Short512VectorTests::bandNot);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short512VectorTests.java","additions":76,"deletions":0,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -5832,0 +5832,76 @@\n+    static boolean band(boolean a, boolean b) {\n+        return a & b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskAndShort64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.and(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Short64VectorTests::band);\n+    }\n+\n+    static boolean bor(boolean a, boolean b) {\n+        return a | b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskOrShort64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.or(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Short64VectorTests::bor);\n+    }\n+\n+    static boolean bxor(boolean a, boolean b) {\n+        return a != b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskXorShort64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.xor(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Short64VectorTests::bxor);\n+    }\n+\n+    static boolean bandNot(boolean a, boolean b) {\n+        return a & !b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskAndNotShort64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.andNot(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Short64VectorTests::bandNot);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short64VectorTests.java","additions":76,"deletions":0,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -5837,0 +5837,76 @@\n+    static boolean band(boolean a, boolean b) {\n+        return a & b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskAndShortMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.and(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, ShortMaxVectorTests::band);\n+    }\n+\n+    static boolean bor(boolean a, boolean b) {\n+        return a | b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskOrShortMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.or(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, ShortMaxVectorTests::bor);\n+    }\n+\n+    static boolean bxor(boolean a, boolean b) {\n+        return a != b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskXorShortMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.xor(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, ShortMaxVectorTests::bxor);\n+    }\n+\n+    static boolean bandNot(boolean a, boolean b) {\n+        return a & !b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskAndNotShortMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.andNot(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, ShortMaxVectorTests::bandNot);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ShortMaxVectorTests.java","additions":76,"deletions":0,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -381,0 +381,76 @@\n+    static boolean band(boolean a, boolean b) {\n+        return a & b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskAnd$vectorteststype$SmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.and(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, $vectorteststype$::band);\n+    }\n+\n+    static boolean bor(boolean a, boolean b) {\n+        return a | b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskOr$vectorteststype$SmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.or(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, $vectorteststype$::bor);\n+    }\n+\n+    static boolean bxor(boolean a, boolean b) {\n+        return a != b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskXor$vectorteststype$SmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.xor(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, $vectorteststype$::bxor);\n+    }\n+\n+    static boolean bandNot(boolean a, boolean b) {\n+        return a & !b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskAndNot$vectorteststype$SmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.andNot(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, $vectorteststype$::bandNot);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-Miscellaneous.template","additions":76,"deletions":0,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -121,29 +121,0 @@\n-    \/\/ Call by CDSTestUtils.runWithArchive() and TestCommon.runWithArchive().\n-    \/\/\n-    \/\/ Example:\n-    \/\/  - The dumping will be done with the default G1GC so we can generate\n-    \/\/    the archived heap.\n-    \/\/  - The runtime execution will be done with the EpsilonGC, to test its\n-    \/\/    ability to load the archived heap.\n-    \/\/\n-    \/\/ jtreg -vmoptions:-Dtest.cds.runtime.options=-XX:+UnlockExperimentalVMOptions,-XX:+UseEpsilonGC \\\n-    \/\/       test\/hotspot\/jtreg\/runtime\/cds\n-    public ArrayList<String> getRuntimePrefix() {\n-        ArrayList<String> cmdline = new ArrayList<>();\n-\n-        String jtropts = System.getProperty(\"test.cds.runtime.options\");\n-        if (jtropts != null) {\n-            for (String s : jtropts.split(\",\")) {\n-                if (!disabledRuntimePrefixes.contains(s)) {\n-                    cmdline.add(s);\n-                }\n-            }\n-        }\n-\n-        for (String p : prefix) {\n-            cmdline.add(p);\n-        }\n-\n-        return cmdline;\n-    }\n-\n","filename":"test\/lib\/jdk\/test\/lib\/cds\/CDSOptions.java","additions":0,"deletions":29,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+import java.util.List;\n@@ -39,0 +40,1 @@\n+import jdk.test.lib.JDKToolFinder;\n@@ -427,1 +429,2 @@\n-        ArrayList<String> cmd = opts.getRuntimePrefix();\n+        ArrayList<String> cmd = new ArrayList<String>();\n+        cmd.addAll(opts.prefix);\n@@ -602,0 +605,66 @@\n+    \/\/ Check commandline for the last instance of Xshare to see if the process can load\n+    \/\/ a CDS archive\n+    public static boolean isRunningWithArchive(List<String> cmd) {\n+        \/\/ -Xshare only works for the java executable\n+        if (!cmd.get(0).equals(JDKToolFinder.getJDKTool(\"java\")) || cmd.size() < 2) {\n+            return false;\n+        }\n+\n+        \/\/ -Xshare options are likely at the end of the args list\n+        for (int i = cmd.size() - 1; i >= 1; i--) {\n+            String s = cmd.get(i);\n+            if (s.equals(\"-Xshare:dump\") || s.equals(\"-Xshare:off\")) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    public static boolean isGCOption(String s) {\n+        return s.startsWith(\"-XX:+Use\") && s.endsWith(\"GC\");\n+    }\n+\n+    public static boolean hasGCOption(List<String> cmd) {\n+        for (String s : cmd) {\n+            if (isGCOption(s)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    \/\/ Handle and insert test.cds.runtime.options to commandline\n+    \/\/ The test.cds.runtime.options property is used to inject extra VM options to\n+    \/\/ subprocesses launched by the CDS test cases using executeAndLog().\n+    \/\/ The injection applies only to subprocesses that:\n+    \/\/   - are launched by the standard java launcher (bin\/java)\n+    \/\/   - are not dumping the CDS archive with -Xshare:dump\n+    \/\/   - do not explicitly disable CDS via -Xshare:off\n+    \/\/\n+    \/\/ The main purpose of this property is to test the runtime loading of\n+    \/\/ the CDS \"archive heap region\" with non-default garbage collectors. E.g.,\n+    \/\/\n+    \/\/ jtreg -vmoptions:-Dtest.cds.runtime.options=-XX:+UnlockExperimentalVMOptions,-XX:+UseEpsilonGC \\\n+    \/\/       test\/hotspot\/jtreg\/runtime\/cds\n+    \/\/\n+    \/\/ Note that the injection is not applied to -Xshare:dump, so that the CDS archives\n+    \/\/ will be dumped with G1, which is the only collector that supports dumping\n+    \/\/ the archive heap region. Similarly, if a UseXxxGC option already exists in the command line,\n+    \/\/ the UseXxxGC option added in test.cds.runtime.options will be ignored.\n+    public static void handleCDSRuntimeOptions(ProcessBuilder pb) {\n+        List<String> cmd = pb.command();\n+        String jtropts = System.getProperty(\"test.cds.runtime.options\");\n+        if (jtropts != null && isRunningWithArchive(cmd)) {\n+            \/\/ There cannot be multiple GC options in the command line so some\n+            \/\/ options may be ignored\n+            ArrayList<String> cdsRuntimeOpts = new ArrayList<String>();\n+            boolean hasGCOption = hasGCOption(cmd);\n+            for (String s : jtropts.split(\",\")) {\n+                if (!CDSOptions.disabledRuntimePrefixes.contains(s) &&\n+                    !(hasGCOption && isGCOption(s))) {\n+                    cdsRuntimeOpts.add(s);\n+                }\n+            }\n+            pb.command().addAll(1, cdsRuntimeOpts);\n+        }\n+    }\n@@ -606,0 +675,3 @@\n+\n+        handleCDSRuntimeOptions(pb);\n+\n","filename":"test\/lib\/jdk\/test\/lib\/cds\/CDSTestUtils.java","additions":73,"deletions":1,"binary":false,"changes":74,"status":"modified"}]}