{"files":[{"patch":"@@ -79,1 +79,10 @@\n-    private enum Phase { PREAMBLE, BODY, POSTAMBLE }\n+    private enum Phase {\n+        \/** The initial part of an HTML file up to and including the {@code body} and possible {@code <main>} tag. *\/\n+        PREAMBLE,\n+        \/** The initial part of a doc comment, or the rich-text content of a block tag. *\/\n+        BODY,\n+        \/** The end of an HTML file, from and including the {@code <\/main>} or {@code <\/body>} tag. *\/\n+        POSTAMBLE,\n+        \/** The rich-text content of an inline documentation comment tag. *\/\n+        INLINE\n+    }\n@@ -131,2 +140,2 @@\n-        List<DCTree> preamble = isFileContent ? blockContent(Phase.PREAMBLE) : List.nil();\n-        List<DCTree> body = blockContent(Phase.BODY);\n+        List<DCTree> preamble = isFileContent ? content(Phase.PREAMBLE) : List.nil();\n+        List<DCTree> body = content(Phase.BODY);\n@@ -134,1 +143,1 @@\n-        List<DCTree> postamble = isFileContent ? blockContent(Phase.POSTAMBLE) : List.nil();\n+        List<DCTree> postamble = isFileContent ? content(Phase.POSTAMBLE) : List.nil();\n@@ -157,1 +166,1 @@\n-        return blockContent(Phase.BODY);\n+        return content(Phase.BODY);\n@@ -161,3 +170,17 @@\n-     * Read block content, consisting of text, html and inline tags.\n-     * Terminated by the end of input, or the beginning of the next block tag:\n-     * that is, @ as the first non-whitespace character on a line.\n+     * Reads \"rich text\" content, consisting of text, HTML and inline tags,\n+     * according to the given {@code phase}.\n+     *\n+     * Inline tags are only recognized in {@code BODY} and {@code INLINE}\n+     * phases, and not in {@code PREAMBLE} and {@code POSTAMBLE} phases.\n+     *\n+     * The end of the content is dependent on the phase:\n+     *\n+     * <ul>\n+     * <li>{@code PREAMBLE}: the appearance of {@code <body>} (or {@code <main>}),\n+     *      as determined by {@link #isEndPreamble()}\n+     * <li>{@code BODY}: the beginning of a block tag, or when reading from\n+     *      an HTML file, the appearance of {@code <\/main>} (or {@code <\/body>}),\n+     *       as determined by {@link #isEndBody()}\n+     * <li>{@code INLINE}: '}', after skipping any matching {@code { }}\n+     * <li>{@code POSTAMBLE}: end of file\n+     * <\/ul>\n@@ -165,2 +188,1 @@\n-    @SuppressWarnings(\"fallthrough\")\n-    protected List<DCTree> blockContent(Phase phase) {\n+    protected List<DCTree> content(Phase phase) {\n@@ -170,0 +192,3 @@\n+        int depth = phase == Phase.INLINE ? 1 : -1; \/\/ only used when phase is INLINE\n+        int pos = bp;                               \/\/ only used when phase is INLINE\n+\n@@ -173,2 +198,1 @@\n-                case '\\n': case '\\r': case '\\f':\n-                case ' ': case '\\t':\n+                case '\\n', '\\r', '\\f', ' ', '\\t' ->\n@@ -176,1 +200,0 @@\n-                    break;\n@@ -178,1 +201,1 @@\n-                case '&':\n+                case '&' ->\n@@ -180,1 +203,0 @@\n-                    break;\n@@ -182,1 +204,1 @@\n-                case '<':\n+                case '<' -> {\n@@ -218,1 +240,1 @@\n-                    break;\n+                }\n@@ -220,3 +242,25 @@\n-                case '{':\n-                    inlineTag(trees);\n-                    break;\n+                case '{' -> {\n+                    switch (phase) {\n+                        case PREAMBLE, POSTAMBLE -> defaultContentCharacter();\n+                        case BODY -> inlineTag(trees);\n+                        case INLINE -> {\n+                            if (!inlineTag(trees)) {\n+                                depth++;\n+                            }\n+                        }\n+                    }\n+                }\n+\n+                case '}' -> {\n+                    if (phase == Phase.INLINE) {\n+                        newline = false;\n+                        if (--depth == 0) {\n+                            addPendingText(trees, bp - 1);\n+                            nextChar();\n+                            return trees.toList();\n+                        }\n+                        nextChar();\n+                    } else {\n+                        defaultContentCharacter();\n+                    }\n+                }\n@@ -224,1 +268,1 @@\n-                case '@':\n+                case '@' -> {\n@@ -239,1 +283,1 @@\n-                        } else {\n+                        } else if (phase == Phase.BODY) {\n@@ -252,1 +296,2 @@\n-                    \/\/ fallthrough\n+                    defaultContentCharacter();\n+                }\n@@ -254,6 +299,3 @@\n-                default:\n-                    newline = false;\n-                    if (textStart == -1)\n-                        textStart = bp;\n-                    lastNonWhite = bp;\n-                    nextChar();\n+                default -> {\n+                    defaultContentCharacter();\n+                }\n@@ -266,1 +308,11 @@\n-        return trees.toList();\n+        return (phase == Phase.INLINE)\n+                ? List.of(erroneous(\"dc.unterminated.inline.tag\", pos))\n+                : trees.toList();\n+    }\n+\n+    void defaultContentCharacter() {\n+        newline = false;\n+        if (textStart == -1)\n+            textStart = bp;\n+        lastNonWhite = bp;\n+        nextChar();\n@@ -314,1 +366,15 @@\n-    protected void inlineTag(ListBuffer<DCTree> list) {\n+    \/**\n+     * Reads a possible inline tag, after finding an opening brace <code>{<\/code> character.\n+     *\n+     * If the next character is {@code @}, an opening tag is read and added to the\n+     * given {@code list}, and the result is {@code true}.\n+     *\n+     * Otherwise, the {@code list} is updated with the characters that have been read,\n+     * and the result is {@code false}. The result also indicates that a single\n+     * opening brace was read, and that a corresponding closing brace should eventually\n+     * be read.\n+     *\n+     * @param list the list of trees being accumulated\n+     * @return {@code true} if an inline tag was read, and {@code false} otherwise\n+     *\/\n+    protected boolean inlineTag(ListBuffer<DCTree> list) {\n@@ -335,0 +401,1 @@\n+                return true;\n@@ -341,0 +408,1 @@\n+        return false;\n@@ -587,1 +655,0 @@\n-    @SuppressWarnings(\"fallthrough\")\n@@ -589,2 +656,0 @@\n-        ListBuffer<DCTree> trees = new ListBuffer<>();\n-\n@@ -592,86 +657,1 @@\n-        int pos = bp;\n-        int depth = 1;\n-        textStart = -1;\n-\n-        loop:\n-        while (bp < buflen) {\n-\n-            switch (ch) {\n-                case '\\n': case '\\r': case '\\f':\n-                case ' ': case '\\t':\n-                    nextChar();\n-                    break;\n-\n-                case '&':\n-                    entity(trees);\n-                    break;\n-\n-                case '<':\n-                    newline = false;\n-                    addPendingText(trees, bp - 1);\n-                    trees.add(html());\n-                    textStart = bp;\n-                    lastNonWhite = -1;\n-                    break;\n-\n-                case '{':\n-                    if (textStart == -1)\n-                        textStart = bp;\n-                    newline = false;\n-                    nextChar();\n-                    if (ch == '@') {\n-                        addPendingText(trees, bp - 2);\n-                        trees.add(inlineTag());\n-                        textStart = bp;\n-                        lastNonWhite = -1;\n-                    } else {\n-                        depth++;\n-                    }\n-                    break;\n-\n-                case '}':\n-                    newline = false;\n-                    if (--depth == 0) {\n-                        addPendingText(trees, bp - 1);\n-                        nextChar();\n-                        return trees.toList();\n-                    }\n-                    nextChar();\n-                    break;\n-\n-                case '@':\n-                    \/\/ check for context-sensitive escape sequences:\n-                    \/\/   newline whitespace @@\n-                    \/\/   newline whitespace @*\n-                    \/\/   *@\/\n-                    if (newline) {\n-                        char peek = peekChar();\n-                        if (peek == '@' || peek == '*') {\n-                            addPendingText(trees, bp - 1);\n-                            nextChar();\n-                            trees.add(m.at(bp - 1).newEscapeTree(ch));\n-                            newline = false;\n-                            nextChar();\n-                            textStart = bp;\n-                            break;\n-                        }\n-                    } else if (textStart != -1 && buf[bp - 1] == '*' && peekChar() == '\/') {\n-                        addPendingText(trees, bp - 1);\n-                        nextChar();\n-                        trees.add(m.at(bp - 1).newEscapeTree('\/'));\n-                        newline = false;\n-                        nextChar();\n-                        textStart = bp;\n-                        break;\n-                    }\n-                    \/\/ fallthrough\n-\n-                default:\n-                    if (textStart == -1)\n-                        textStart = bp;\n-                    nextChar();\n-                    break;\n-            }\n-        }\n-\n-        return List.of(erroneous(\"dc.unterminated.inline.tag\", pos));\n+        return content(Phase.INLINE);\n@@ -846,2 +826,9 @@\n-     * Read the start or end of an HTML tag, or an HTML comment\n-     * {@literal <identifier attrs> } or {@literal <\/identifier> }\n+     * Reads an HTML construct, beginning with {@code <}.\n+     *\n+     * <ul>\n+     * <li>start element: {@code <identifier attrs> }\n+     * <li>end element: {@code <\/identifier> }\n+     * <li>comment: {@code <!-- ... -->}\n+     * <li>doctype: {@code <!doctype ... >}\n+     * <li>cdata: {@code <![CDATA[ ... ]]>}\n+     * <\/ul>\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/DocCommentParser.java","additions":109,"deletions":122,"binary":false,"changes":231,"status":"modified"}]}