{"files":[{"patch":"@@ -3590,4 +3590,0 @@\n-  \/\/ Minimum size must be empty loop\n-  if (_body.size() > EMPTY_LOOP_SIZE) {\n-    return false;\n-  }\n@@ -3597,0 +3593,3 @@\n+  if (!empty_loop_candidate(phase)) {\n+    return false;\n+  }\n@@ -3598,2 +3597,5 @@\n-  if (!cl->is_valid_counted_loop(T_INT)) {\n-    return false;   \/\/ Malformed loop\n+#ifdef ASSERT\n+  \/\/ Call collect_loop_core_nodes to exercise the assert that check that it finds the right number of nodes\n+  if (empty_loop_with_extra_nodes_candidate(phase)) {\n+    Unique_Node_List wq;\n+    collect_loop_core_nodes(phase, wq);\n@@ -3601,2 +3603,8 @@\n-  if (!phase->is_member(this, phase->get_ctrl(cl->loopexit()->in(CountedLoopEndNode::TestValue)))) {\n-    return false;   \/\/ Infinite loop\n+#endif\n+  \/\/ Minimum size must be empty loop\n+  if (_body.size() > EMPTY_LOOP_SIZE) {\n+    \/\/ This loop has more nodes than an empty loop but, maybe they are only kept alive by the outer strip mined loop's\n+    \/\/ safepoint. If they go away once the safepoint is removed, that loop is empty.\n+    if (!empty_loop_with_data_nodes(phase)) {\n+      return false;\n+    }\n@@ -3700,0 +3708,131 @@\n+bool IdealLoopTree::empty_loop_candidate(PhaseIdealLoop* phase) const {\n+  CountedLoopNode *cl = _head->as_CountedLoop();\n+  if (!cl->is_valid_counted_loop(T_INT)) {\n+    return false;   \/\/ Malformed loop\n+  }\n+  if (!phase->is_member(this, phase->get_ctrl(cl->loopexit()->in(CountedLoopEndNode::TestValue)))) {\n+    return false;   \/\/ Infinite loop\n+  }\n+  return true;\n+}\n+\n+bool IdealLoopTree::empty_loop_with_data_nodes(PhaseIdealLoop* phase) const {\n+  CountedLoopNode* cl = _head->as_CountedLoop();\n+  if (!cl->is_strip_mined() || !empty_loop_with_extra_nodes_candidate(phase)) {\n+    return false;\n+  }\n+  Unique_Node_List empty_loop_nodes;\n+  Unique_Node_List wq;\n+\n+  \/\/ Start from all data nodes in the loop body that are not one of the EMPTY_LOOP_SIZE nodes expected in an empty body\n+  enqueue_data_nodes(phase, empty_loop_nodes, wq);\n+  \/\/ and now follow uses\n+  for (uint i = 0; i < wq.size(); ++i) {\n+    Node* n = wq.at(i);\n+    for (DUIterator_Fast jmax, j = n->fast_outs(jmax); j < jmax; j++) {\n+      Node* u = n->fast_out(j);\n+      if (u->Opcode() == Op_SafePoint) {\n+        \/\/ found a safepoint. Maybe this loop's safepoint or another loop safepoint.\n+        if (!process_safepoint(phase, empty_loop_nodes, wq, u)) {\n+          return false;\n+        }\n+      } else {\n+        const Type* u_t = phase->_igvn.type(u);\n+        if (u_t == Type::CONTROL || u_t == Type::MEMORY || u_t == Type::ABIO) {\n+          \/\/ found a side effect\n+          return false;\n+        }\n+        wq.push(u);\n+      }\n+    }\n+  }\n+  \/\/ Nodes (ignoring the EMPTY_LOOP_SIZE nodes of the \"core\" of the loop) are kept alive by otherwise empty loops'\n+  \/\/ safepoints: kill them.\n+  for (uint i = 0; i < wq.size(); ++i) {\n+    Node* n = wq.at(i);\n+    phase->_igvn.replace_node(n, phase->C->top());\n+  }\n+\n+#ifdef ASSERT\n+  for (uint i = 0; i < _body.size(); ++i) {\n+    Node* n = _body.at(i);\n+    assert(wq.member(n) || empty_loop_nodes.member(n), \"missed a node in the body?\");\n+  }\n+#endif\n+\n+  return true;\n+}\n+\n+bool IdealLoopTree::process_safepoint(PhaseIdealLoop* phase, Unique_Node_List& empty_loop_nodes, Unique_Node_List& wq,\n+                                      Node* sfpt) const {\n+  CountedLoopNode* cl = _head->as_CountedLoop();\n+  if (cl->outer_safepoint() == sfpt) {\n+    \/\/ the current loop's safepoint\n+    return true;\n+  }\n+\n+  \/\/ Some other loop's safepoint. Maybe that loop is empty too.\n+  IdealLoopTree* sfpt_loop = phase->get_loop(sfpt);\n+  if (!sfpt_loop->_head->is_OuterStripMinedLoop()) {\n+    return false;\n+  }\n+  IdealLoopTree* sfpt_inner_loop = sfpt_loop->_child;\n+  CountedLoopNode* sfpt_cl = sfpt_inner_loop->_head->as_CountedLoop();\n+  assert(sfpt_cl->is_strip_mined(), \"inconsistent\");\n+\n+  if (empty_loop_nodes.member(sfpt_cl)) {\n+    \/\/ already taken care of\n+    return true;\n+  }\n+\n+  if (!sfpt_inner_loop->empty_loop_candidate(phase) || !sfpt_inner_loop->empty_loop_with_extra_nodes_candidate(phase)) {\n+    return false;\n+  }\n+\n+  \/\/ Enqueue the nodes of that loop for processing too\n+  sfpt_inner_loop->enqueue_data_nodes(phase, empty_loop_nodes, wq);\n+  return true;\n+}\n+\n+bool IdealLoopTree::empty_loop_with_extra_nodes_candidate(PhaseIdealLoop* phase) const {\n+  CountedLoopNode *cl = _head->as_CountedLoop();\n+  \/\/ No other control flow node in the loop body\n+  if (cl->loopexit()->in(0) != cl) {\n+    return false;\n+  }\n+\n+  if (phase->is_member(this, phase->get_ctrl(cl->limit()))) {\n+    return false;\n+  }\n+  return true;\n+}\n+\n+void IdealLoopTree::enqueue_data_nodes(PhaseIdealLoop* phase, Unique_Node_List& empty_loop_nodes,\n+                                       Unique_Node_List& wq) const {\n+  collect_loop_core_nodes(phase, empty_loop_nodes);\n+  for (uint i = 0; i < _body.size(); ++i) {\n+    Node* n = _body.at(i);\n+    if (!empty_loop_nodes.member(n)) {\n+      wq.push(n);\n+    }\n+  }\n+}\n+\n+\/\/ This collects the node that would be left if this body was empty\n+void IdealLoopTree::collect_loop_core_nodes(PhaseIdealLoop* phase, Unique_Node_List& wq) const {\n+  uint before = wq.size();\n+  wq.push(_head->in(LoopNode::LoopBackControl));\n+  for (uint i = 0; i < wq.size(); ++i) {\n+    Node* n = wq.at(i);\n+    for (uint j = 0; j < n->req(); ++j) {\n+      Node* in = n->in(j);\n+      if (in != NULL) {\n+        if (phase->get_loop(phase->ctrl_or_self(in)) == this) {\n+          wq.push(in);\n+        }\n+      }\n+    }\n+  }\n+  assert(wq.size() - before == EMPTY_LOOP_SIZE, \"expect the EMPTY_LOOP_SIZE nodes of this body if empty\");\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":147,"deletions":8,"binary":false,"changes":155,"status":"modified"},{"patch":"@@ -798,0 +798,13 @@\n+\n+  void collect_loop_core_nodes(PhaseIdealLoop* phase, Unique_Node_List& wq) const;\n+\n+  bool empty_loop_with_data_nodes(PhaseIdealLoop* phase) const;\n+\n+  void enqueue_data_nodes(PhaseIdealLoop* phase, Unique_Node_List& empty_loop_nodes, Unique_Node_List& wq) const;\n+\n+  bool process_safepoint(PhaseIdealLoop* phase, Unique_Node_List& empty_loop_nodes, Unique_Node_List& wq,\n+                         Node* sfpt) const;\n+\n+  bool empty_loop_candidate(PhaseIdealLoop* phase) const;\n+\n+  bool empty_loop_with_extra_nodes_candidate(PhaseIdealLoop* phase) const;\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -0,0 +1,139 @@\n+\/*\n+ * Copyright (c) 2022, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.c2.irTests;\n+\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @library \/test\/lib \/\n+ * @requires vm.compiler2.enabled\n+ * @run driver compiler.c2.irTests.TestLSMMissedEmptyLoop\n+ *\/\n+\n+public class TestLSMMissedEmptyLoop {\n+    public static void main(String[] args) {\n+        TestFramework.runWithFlags(\"-XX:LoopMaxUnroll=0\");\n+        TestFramework.runWithFlags(\"-XX:-UseCountedLoopSafepoints\", \"-XX:LoopMaxUnroll=0\");\n+        TestFramework.run();\n+        TestFramework.runWithFlags(\"-XX:-UseCountedLoopSafepoints\");\n+    }\n+\n+    static double doubleField;\n+\n+    @ForceInline\n+    public static void testHelper(int i, double d) {\n+        if (i != 42) {\n+            doubleField = d;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.COUNTED_LOOP, IRNode.LOOP })\n+    public static void test1() {\n+        double d = 1;\n+        for (int i = 0; i < 1000; i++) {\n+            d = d * 2;\n+        }\n+        int i = 0;\n+        for (i = 0; i < 42; i++) {\n+        }\n+        testHelper(i, d);\n+    }\n+\n+    @Run(test = \"test1\")\n+    private void test1_runner() {\n+        testHelper(-42, 42);\n+        test1();\n+    }\n+\n+    @Test\n+    @IR(applyIf = { \"LoopStripMiningIter\", \"0\" }, failOn = {IRNode.COUNTED_LOOP, IRNode.LOOP })\n+    @IR(applyIf = { \"LoopStripMiningIter\", \"> 0\" }, counts = {IRNode.COUNTED_LOOP, \">= 2\" })\n+    public static void test2() {\n+        double d = 1;\n+        for (int j = 0; j < 10; j++) {\n+            for (int i = 0; i < 1000; i++) {\n+                d = d * 2;\n+            }\n+        }\n+        int i = 0;\n+        for (i = 0; i < 42; i++) {\n+        }\n+        testHelper(i, d);\n+    }\n+\n+    @Run(test = \"test2\")\n+    private void test2_runner() {\n+        testHelper(-42, 42);\n+        test2();\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.COUNTED_LOOP, IRNode.LOOP })\n+    public static void test3() {\n+        double d = 1;\n+        for (int i = 0; i < 1000; i++) {\n+            d = d * 2;\n+        }\n+        for (int i = 0; i < 1000; i++) {\n+            d = d * 2;\n+        }\n+        int i = 0;\n+        for (i = 0; i < 42; i++) {\n+        }\n+        testHelper(i, d);\n+    }\n+\n+    @Run(test = \"test3\")\n+    private void test3_runner() {\n+        testHelper(-42, 42);\n+        test1();\n+    }\n+\n+    @Test\n+    @IR(applyIf = { \"LoopStripMiningIter\", \"0\" }, failOn = {IRNode.COUNTED_LOOP, IRNode.LOOP })\n+    @IR(applyIf = { \"LoopStripMiningIter\", \"> 0\" }, counts = {IRNode.COUNTED_LOOP, \">= 3\" })\n+    public static void test4() {\n+        double d = 1;\n+        for (int j = 0; j < 10; j++) {\n+            for (int i = 0; i < 1000; i++) {\n+                d = d * 2;\n+            }\n+            for (int i = 0; i < 1000; i++) {\n+                d = d * 2;\n+            }\n+        }\n+        int i = 0;\n+        for (i = 0; i < 42; i++) {\n+        }\n+        testHelper(i, d);\n+    }\n+\n+    @Run(test = \"test4\")\n+    private void test4_runner() {\n+        testHelper(-42, 42);\n+        test4();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestLSMMissedEmptyLoop.java","additions":139,"deletions":0,"binary":false,"changes":139,"status":"added"}]}