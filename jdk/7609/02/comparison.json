{"files":[{"patch":"@@ -197,0 +197,34 @@\n+  if (res == Type::TOP) {\n+    return Type::TOP;\n+  }\n+  assert(res->isa_int(), \"res must be int\");\n+\n+  \/\/ Similar to ConvI2LNode::Value() for the same reasons\n+  \/\/ see if we can remove type assertion after loop opts\n+  \/\/ But here we have to pay extra attention:\n+  \/\/ Do not narrow the type of range check dependent CastIINodes to\n+  \/\/ avoid corruption of the graph if a CastII is replaced by TOP but\n+  \/\/ the corresponding range check is not removed.\n+  if (!_range_check_dependency && phase->C->post_loop_opts_phase()) {\n+    const TypeInt* this_type = res->is_int();\n+    const TypeInt* in_type = phase->type(in(1))->isa_int();\n+    if (in_type != NULL &&\n+        (in_type->_lo != this_type->_lo ||\n+         in_type->_hi != this_type->_hi)) {\n+      jint lo1 = this_type->_lo;\n+      jint hi1 = this_type->_hi;\n+      int w1 = this_type->_widen;\n+      if (lo1 >= 0) {\n+        \/\/ Keep a range assertion of >=0.\n+        lo1 = 0;        hi1 = max_jint;\n+      } else if (hi1 < 0) {\n+        \/\/ Keep a range assertion of <0.\n+        lo1 = min_jint; hi1 = -1;\n+      } else {\n+        lo1 = min_jint; hi1 = max_jint;\n+      }\n+      res = TypeInt::make(MAX2(in_type->_lo, lo1),\n+                          MIN2(in_type->_hi, hi1),\n+                          MAX2((int)in_type->_widen, w1));\n+    }\n+  }\n@@ -251,1 +285,0 @@\n-\n@@ -277,2 +310,5 @@\n-\n-  PhaseIterGVN *igvn = phase->is_IterGVN();\n+  if (can_reshape && !_range_check_dependency && !phase->C->post_loop_opts_phase()) {\n+    \/\/ makes sure we run ::Value to potentially remove type assertion after loop opts\n+    phase->C->record_for_post_loop_opts_igvn(this);\n+  }\n+  PhaseIterGVN* igvn = phase->is_IterGVN();\n@@ -303,37 +339,0 @@\n-\n-  \/\/ Similar to ConvI2LNode::Ideal() for the same reasons\n-  \/\/ Do not narrow the type of range check dependent CastIINodes to\n-  \/\/ avoid corruption of the graph if a CastII is replaced by TOP but\n-  \/\/ the corresponding range check is not removed.\n-  if (can_reshape && !_range_check_dependency) {\n-    if (phase->C->post_loop_opts_phase()) {\n-      const TypeInt* this_type = this->type()->is_int();\n-      const TypeInt* in_type = phase->type(in(1))->isa_int();\n-      if (in_type != NULL && this_type != NULL &&\n-          (in_type->_lo != this_type->_lo ||\n-           in_type->_hi != this_type->_hi)) {\n-        jint lo1 = this_type->_lo;\n-        jint hi1 = this_type->_hi;\n-        int w1  = this_type->_widen;\n-\n-        if (lo1 >= 0) {\n-          \/\/ Keep a range assertion of >=0.\n-          lo1 = 0;        hi1 = max_jint;\n-        } else if (hi1 < 0) {\n-          \/\/ Keep a range assertion of <0.\n-          lo1 = min_jint; hi1 = -1;\n-        } else {\n-          lo1 = min_jint; hi1 = max_jint;\n-        }\n-        const TypeInt* wtype = TypeInt::make(MAX2(in_type->_lo, lo1),\n-                                             MIN2(in_type->_hi, hi1),\n-                                             MAX2((int)in_type->_widen, w1));\n-        if (wtype != type()) {\n-          set_type(wtype);\n-          return this;\n-        }\n-      }\n-    } else {\n-      phase->C->record_for_post_loop_opts_igvn(this);\n-    }\n-  }\n","filename":"src\/hotspot\/share\/opto\/castnode.cpp","additions":39,"deletions":40,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -255,1 +255,3 @@\n-  if( t == Type::TOP ) return Type::TOP;\n+  if (t == Type::TOP) {\n+    return Type::TOP;\n+  }\n@@ -260,1 +262,34 @@\n-  return tl;\n+  if (!tl->isa_long()) {\n+    return tl;\n+  }\n+  const TypeLong* this_type = tl->is_long();\n+  \/\/ Do NOT remove this node's type assertion until no more loop ops can happen.\n+  if (phase->C->post_loop_opts_phase()) {\n+    const TypeInt* in_type = phase->type(in(1))->isa_int();\n+    if (in_type != NULL &&\n+        (in_type->_lo != this_type->_lo ||\n+         in_type->_hi != this_type->_hi)) {\n+      \/\/ Although this WORSENS the type, it increases GVN opportunities,\n+      \/\/ because I2L nodes with the same input will common up, regardless\n+      \/\/ of slightly differing type assertions.  Such slight differences\n+      \/\/ arise routinely as a result of loop unrolling, so this is a\n+      \/\/ post-unrolling graph cleanup.  Choose a type which depends only\n+      \/\/ on my input.  (Exception:  Keep a range assertion of >=0 or <0.)\n+      jlong lo1 = this_type->_lo;\n+      jlong hi1 = this_type->_hi;\n+      int   w1  = this_type->_widen;\n+      if (lo1 >= 0) {\n+        \/\/ Keep a range assertion of >=0.\n+        lo1 = 0;        hi1 = max_jint;\n+      } else if (hi1 < 0) {\n+        \/\/ Keep a range assertion of <0.\n+        lo1 = min_jint; hi1 = -1;\n+      } else {\n+        lo1 = min_jint; hi1 = max_jint;\n+      }\n+      return TypeLong::make(MAX2((jlong)in_type->_lo, lo1),\n+                            MIN2((jlong)in_type->_hi, hi1),\n+                            MAX2((int)in_type->_widen, w1));\n+    }\n+  }\n+  return this_type;\n@@ -362,1 +397,0 @@\n-  PhaseIterGVN *igvn = phase->is_IterGVN();\n@@ -364,44 +398,3 @@\n-  Node* this_changed = NULL;\n-\n-  if (igvn != NULL) {\n-    \/\/ Do NOT remove this node's type assertion until no more loop ops can happen.\n-    if (phase->C->post_loop_opts_phase()) {\n-      const TypeInt* in_type = phase->type(in(1))->isa_int();\n-      if (in_type != NULL && this_type != NULL &&\n-          (in_type->_lo != this_type->_lo ||\n-           in_type->_hi != this_type->_hi)) {\n-        \/\/ Although this WORSENS the type, it increases GVN opportunities,\n-        \/\/ because I2L nodes with the same input will common up, regardless\n-        \/\/ of slightly differing type assertions.  Such slight differences\n-        \/\/ arise routinely as a result of loop unrolling, so this is a\n-        \/\/ post-unrolling graph cleanup.  Choose a type which depends only\n-        \/\/ on my input.  (Exception:  Keep a range assertion of >=0 or <0.)\n-        jlong lo1 = this_type->_lo;\n-        jlong hi1 = this_type->_hi;\n-        int   w1  = this_type->_widen;\n-        if (lo1 != (jint)lo1 ||\n-            hi1 != (jint)hi1 ||\n-            lo1 > hi1) {\n-          \/\/ Overflow leads to wraparound, wraparound leads to range saturation.\n-          lo1 = min_jint; hi1 = max_jint;\n-        } else if (lo1 >= 0) {\n-          \/\/ Keep a range assertion of >=0.\n-          lo1 = 0;        hi1 = max_jint;\n-        } else if (hi1 < 0) {\n-          \/\/ Keep a range assertion of <0.\n-          lo1 = min_jint; hi1 = -1;\n-        } else {\n-          lo1 = min_jint; hi1 = max_jint;\n-        }\n-        const TypeLong* wtype = TypeLong::make(MAX2((jlong)in_type->_lo, lo1),\n-                                               MIN2((jlong)in_type->_hi, hi1),\n-                                               MAX2((int)in_type->_widen, w1));\n-        if (wtype != type()) {\n-          set_type(wtype);\n-          \/\/ Note: this_type still has old type value, for the logic below.\n-          this_changed = this;\n-        }\n-      }\n-    } else {\n-      phase->C->record_for_post_loop_opts_igvn(this);\n-    }\n+  if (can_reshape && !phase->C->post_loop_opts_phase()) {\n+    \/\/ makes sure we run ::Value to potentially remove type assertion after loop opts\n+    phase->C->record_for_post_loop_opts_igvn(this);\n@@ -431,1 +424,1 @@\n-\n+  PhaseIterGVN* igvn = phase->is_IterGVN();\n@@ -440,1 +433,1 @@\n-      return this_changed;\n+      return NULL;\n@@ -456,1 +449,1 @@\n-  return this_changed;\n+  return NULL;\n","filename":"src\/hotspot\/share\/opto\/convertnode.cpp","additions":43,"deletions":50,"binary":false,"changes":93,"status":"modified"}]}