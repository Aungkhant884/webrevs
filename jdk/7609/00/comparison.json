{"files":[{"patch":"@@ -197,0 +197,36 @@\n+  if(res == Type::TOP) { return res; }\n+  assert(res->isa_int(), \"res must be int\");\n+\n+  \/\/ Similar to ConvI2LNode::Value() for the same reasons\n+  \/\/ see if we can remove type assertion after loop opts\n+  \/\/ But here we have to pay extra attention:\n+  \/\/ Do not narrow the type of range check dependent CastIINodes to\n+  \/\/ avoid corruption of the graph if a CastII is replaced by TOP but\n+  \/\/ the corresponding range check is not removed.\n+  if (!_range_check_dependency) {\n+    if (phase->C->post_loop_opts_phase()) {\n+      const TypeInt* this_type = res->is_int();\n+      const TypeInt* in_type = phase->type(in(1))->isa_int();\n+      if (in_type != NULL && this_type != NULL &&\n+          (in_type->_lo != this_type->_lo ||\n+           in_type->_hi != this_type->_hi)) {\n+        jint lo1 = this_type->_lo;\n+        jint hi1 = this_type->_hi;\n+        int w1  = this_type->_widen;\n+\n+        if (lo1 >= 0) {\n+          \/\/ Keep a range assertion of >=0.\n+          lo1 = 0;        hi1 = max_jint;\n+        } else if (hi1 < 0) {\n+          \/\/ Keep a range assertion of <0.\n+          lo1 = min_jint; hi1 = -1;\n+        } else {\n+          lo1 = min_jint; hi1 = max_jint;\n+        }\n+        const TypeInt* wtype = TypeInt::make(MAX2(in_type->_lo, lo1),\n+                                             MIN2(in_type->_hi, hi1),\n+                                             MAX2((int)in_type->_widen, w1));\n+        res = wtype;\n+      }\n+    }\n+  }\n@@ -251,1 +287,0 @@\n-\n@@ -303,5 +338,0 @@\n-\n-  \/\/ Similar to ConvI2LNode::Ideal() for the same reasons\n-  \/\/ Do not narrow the type of range check dependent CastIINodes to\n-  \/\/ avoid corruption of the graph if a CastII is replaced by TOP but\n-  \/\/ the corresponding range check is not removed.\n@@ -309,28 +339,2 @@\n-    if (phase->C->post_loop_opts_phase()) {\n-      const TypeInt* this_type = this->type()->is_int();\n-      const TypeInt* in_type = phase->type(in(1))->isa_int();\n-      if (in_type != NULL && this_type != NULL &&\n-          (in_type->_lo != this_type->_lo ||\n-           in_type->_hi != this_type->_hi)) {\n-        jint lo1 = this_type->_lo;\n-        jint hi1 = this_type->_hi;\n-        int w1  = this_type->_widen;\n-\n-        if (lo1 >= 0) {\n-          \/\/ Keep a range assertion of >=0.\n-          lo1 = 0;        hi1 = max_jint;\n-        } else if (hi1 < 0) {\n-          \/\/ Keep a range assertion of <0.\n-          lo1 = min_jint; hi1 = -1;\n-        } else {\n-          lo1 = min_jint; hi1 = max_jint;\n-        }\n-        const TypeInt* wtype = TypeInt::make(MAX2(in_type->_lo, lo1),\n-                                             MIN2(in_type->_hi, hi1),\n-                                             MAX2((int)in_type->_widen, w1));\n-        if (wtype != type()) {\n-          set_type(wtype);\n-          return this;\n-        }\n-      }\n-    } else {\n+    if (!phase->C->post_loop_opts_phase()) {\n+      \/\/ makes sure we run ::Value to potentially remove type assertion after loop opts\n","filename":"src\/hotspot\/share\/opto\/castnode.cpp","additions":38,"deletions":34,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -260,1 +260,43 @@\n-  return tl;\n+  if(!tl->isa_long()) return tl;\n+  const TypeLong* this_type = tl->is_long();\n+  PhaseIterGVN *igvn = phase->is_IterGVN();\n+  if (igvn != NULL) {\n+    \/\/ Do NOT remove this node's type assertion until no more loop ops can happen.\n+    if (phase->C->post_loop_opts_phase()) {\n+      const TypeInt* in_type = phase->type(in(1))->isa_int();\n+      if (in_type != NULL && this_type != NULL &&\n+          (in_type->_lo != this_type->_lo ||\n+           in_type->_hi != this_type->_hi)) {\n+        \/\/ Although this WORSENS the type, it increases GVN opportunities,\n+        \/\/ because I2L nodes with the same input will common up, regardless\n+        \/\/ of slightly differing type assertions.  Such slight differences\n+        \/\/ arise routinely as a result of loop unrolling, so this is a\n+        \/\/ post-unrolling graph cleanup.  Choose a type which depends only\n+        \/\/ on my input.  (Exception:  Keep a range assertion of >=0 or <0.)\n+        jlong lo1 = this_type->_lo;\n+        jlong hi1 = this_type->_hi;\n+        assert(lo1 <= hi1, \"valid Long range\");\n+        assert(in_type->_lo <= in_type->_hi, \"valid Int range\");\n+        int   w1  = this_type->_widen;\n+        if (lo1 != (jint)lo1 ||\n+            hi1 != (jint)hi1 ||\n+            lo1 > hi1) {\n+          \/\/ Overflow leads to wraparound, wraparound leads to range saturation.\n+          lo1 = min_jint; hi1 = max_jint;\n+        } else if (lo1 >= 0) {\n+          \/\/ Keep a range assertion of >=0.\n+          lo1 = 0;        hi1 = max_jint;\n+        } else if (hi1 < 0) {\n+          \/\/ Keep a range assertion of <0.\n+          lo1 = min_jint; hi1 = -1;\n+        } else {\n+          lo1 = min_jint; hi1 = max_jint;\n+        }\n+        const TypeLong* wtype = TypeLong::make(MAX2((jlong)in_type->_lo, lo1),\n+                                               MIN2((jlong)in_type->_hi, hi1),\n+                                               MAX2((int)in_type->_widen, w1));\n+        return wtype;\n+      }\n+    }\n+  }\n+  return this_type;\n@@ -364,1 +406,0 @@\n-  Node* this_changed = NULL;\n@@ -366,42 +407,3 @@\n-  if (igvn != NULL) {\n-    \/\/ Do NOT remove this node's type assertion until no more loop ops can happen.\n-    if (phase->C->post_loop_opts_phase()) {\n-      const TypeInt* in_type = phase->type(in(1))->isa_int();\n-      if (in_type != NULL && this_type != NULL &&\n-          (in_type->_lo != this_type->_lo ||\n-           in_type->_hi != this_type->_hi)) {\n-        \/\/ Although this WORSENS the type, it increases GVN opportunities,\n-        \/\/ because I2L nodes with the same input will common up, regardless\n-        \/\/ of slightly differing type assertions.  Such slight differences\n-        \/\/ arise routinely as a result of loop unrolling, so this is a\n-        \/\/ post-unrolling graph cleanup.  Choose a type which depends only\n-        \/\/ on my input.  (Exception:  Keep a range assertion of >=0 or <0.)\n-        jlong lo1 = this_type->_lo;\n-        jlong hi1 = this_type->_hi;\n-        int   w1  = this_type->_widen;\n-        if (lo1 != (jint)lo1 ||\n-            hi1 != (jint)hi1 ||\n-            lo1 > hi1) {\n-          \/\/ Overflow leads to wraparound, wraparound leads to range saturation.\n-          lo1 = min_jint; hi1 = max_jint;\n-        } else if (lo1 >= 0) {\n-          \/\/ Keep a range assertion of >=0.\n-          lo1 = 0;        hi1 = max_jint;\n-        } else if (hi1 < 0) {\n-          \/\/ Keep a range assertion of <0.\n-          lo1 = min_jint; hi1 = -1;\n-        } else {\n-          lo1 = min_jint; hi1 = max_jint;\n-        }\n-        const TypeLong* wtype = TypeLong::make(MAX2((jlong)in_type->_lo, lo1),\n-                                               MIN2((jlong)in_type->_hi, hi1),\n-                                               MAX2((int)in_type->_widen, w1));\n-        if (wtype != type()) {\n-          set_type(wtype);\n-          \/\/ Note: this_type still has old type value, for the logic below.\n-          this_changed = this;\n-        }\n-      }\n-    } else {\n-      phase->C->record_for_post_loop_opts_igvn(this);\n-    }\n+  if (igvn != NULL && !phase->C->post_loop_opts_phase()) {\n+    \/\/ makes sure we run ::Value to potentially remove type assertion after loop opts\n+    phase->C->record_for_post_loop_opts_igvn(this);\n@@ -440,1 +442,1 @@\n-      return this_changed;\n+      return NULL;\n@@ -456,1 +458,1 @@\n-  return this_changed;\n+  return NULL;\n","filename":"src\/hotspot\/share\/opto\/convertnode.cpp","additions":48,"deletions":46,"binary":false,"changes":94,"status":"modified"}]}