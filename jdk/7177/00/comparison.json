{"files":[{"patch":"@@ -77,1 +77,0 @@\n-  _next_offset_threshold(NULL),\n@@ -207,1 +206,1 @@\n-\/\/              threshold_\n+\/\/              cur_card_boundary\n@@ -214,1 +213,1 @@\n-\/\/         block-start\n+\/\/         blk_start\n@@ -216,1 +215,1 @@\n-void G1BlockOffsetTablePart::alloc_block_work(HeapWord** threshold_, HeapWord* blk_start,\n+void G1BlockOffsetTablePart::alloc_block_work(HeapWord* blk_start,\n@@ -218,3 +217,2 @@\n-  \/\/ For efficiency, do copy-in\/copy-out.\n-  HeapWord* threshold = *threshold_;\n-  size_t    index =  _bot->index_for_raw(threshold);\n+  HeapWord* const cur_card_boundary = align_up_by_card_size(blk_start);\n+  size_t const index =  _bot->index_for_raw(cur_card_boundary);\n@@ -224,3 +222,3 @@\n-  assert(blk_end > threshold, \"should be past threshold\");\n-  assert(blk_start <= threshold, \"blk_start should be at or before threshold\");\n-  assert(pointer_delta(threshold, blk_start) < BOTConstants::card_size_in_words(),\n+  assert(blk_end > cur_card_boundary, \"should be past cur_card_boundary\");\n+  assert(blk_start <= cur_card_boundary, \"blk_start should be at or before cur_card_boundary\");\n+  assert(pointer_delta(cur_card_boundary, blk_start) < BOTConstants::card_size_in_words(),\n@@ -230,1 +228,1 @@\n-  assert(G1CollectedHeap::heap()->is_in_reserved(blk_end-1),\n+  assert(G1CollectedHeap::heap()->is_in_reserved(blk_end - 1),\n@@ -232,2 +230,2 @@\n-  assert(threshold == _bot->_reserved.start() + index*BOTConstants::card_size_in_words(),\n-         \"index must agree with threshold\");\n+  assert(cur_card_boundary == _bot->_reserved.start() + index*BOTConstants::card_size_in_words(),\n+         \"index must agree with cur_card_boundary\");\n@@ -235,1 +233,2 @@\n-  DEBUG_ONLY(size_t orig_index = index;)\n+  \/\/ Mark the card that holds the offset into the block.\n+  _bot->set_offset_array(index, cur_card_boundary, blk_start);\n@@ -237,4 +236,1 @@\n-  \/\/ Mark the card that holds the offset into the block.  Note\n-  \/\/ that _next_offset_threshold is not updated until the end\n-  \/\/ of this method.\n-  _bot->set_offset_array(index, threshold, blk_start);\n+  \/\/ We need to now mark the subsequent cards that this block spans.\n@@ -242,4 +238,2 @@\n-  \/\/ We need to now mark the subsequent cards that this blk spans.\n-\n-  \/\/ Index of card on which blk ends.\n-  size_t end_index   = _bot->index_for(blk_end - 1);\n+  \/\/ Index of card on which the block ends.\n+  size_t end_index = _bot->index_for(blk_end - 1);\n@@ -256,1 +250,2 @@\n-  \/\/ Calculate threshold_ this way because end_index\n+#ifdef ASSERT\n+  \/\/ Calculate new_card_boundary this way because end_index\n@@ -258,2 +253,2 @@\n-  threshold = _bot->address_for_index(end_index) + BOTConstants::card_size_in_words();\n-  assert(threshold >= blk_end, \"Incorrect offset threshold\");\n+  HeapWord* new_card_boundary = _bot->address_for_index(end_index) + BOTConstants::card_size_in_words();\n+  assert(new_card_boundary >= blk_end, \"postcondition\");\n@@ -261,3 +256,0 @@\n-  *threshold_ = threshold;\n-\n-#ifdef ASSERT\n@@ -268,2 +260,2 @@\n-  assert((_bot->offset_array(orig_index) == 0 && blk_start == boundary) ||\n-         (_bot->offset_array(orig_index) > 0 && _bot->offset_array(orig_index) < BOTConstants::card_size_in_words()),\n+  assert((_bot->offset_array(index) == 0 && blk_start == boundary) ||\n+         (_bot->offset_array(index) > 0 && _bot->offset_array(index) < BOTConstants::card_size_in_words()),\n@@ -271,1 +263,1 @@\n-         \"orig_index offset: %u, \"\n+         \"index offset: %u, \"\n@@ -274,1 +266,1 @@\n-         (uint)_bot->offset_array(orig_index),\n+         (uint)_bot->offset_array(index),\n@@ -276,1 +268,1 @@\n-  for (size_t j = orig_index + 1; j <= end_index; j++) {\n+  for (size_t j = index + 1; j <= end_index; j++) {\n@@ -292,2 +284,0 @@\n-  \/\/ Do not verify beyond the BOT allocation threshold.\n-  assert(_hr->top() <= _next_offset_threshold, \"invariant\");\n@@ -344,1 +334,0 @@\n-  out->print_cr(\"  next offset threshold: \" PTR_FORMAT, p2i(_next_offset_threshold));\n@@ -348,8 +337,0 @@\n-void G1BlockOffsetTablePart::reset_bot() {\n-  _next_offset_threshold = _hr->bottom();\n-}\n-\n-bool G1BlockOffsetTablePart::is_empty() const {\n-  return _next_offset_threshold == _hr->bottom();\n-}\n-\n@@ -357,1 +338,0 @@\n-  assert(is_empty(), \"first obj\");\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BlockOffsetTable.cpp","additions":25,"deletions":45,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -114,3 +114,0 @@\n-  \/\/ allocation boundary at which offset array must be updated\n-  HeapWord* _next_offset_threshold;\n-\n@@ -143,9 +140,2 @@\n-  \/\/ Requires that \"*threshold_\" be the first array entry boundary at or\n-  \/\/ above \"blk_start\".  If the block starts at or crosses \"*threshold_\", records\n-  \/\/ \"blk_start\" as the appropriate block start for the array index\n-  \/\/ starting at \"*threshold_\", and for any other indices crossed by the\n-  \/\/ block.  Updates \"*threshold_\" to correspond to the first index after\n-  \/\/ the block end.\n-  void alloc_block_work(HeapWord** threshold_,\n-                        HeapWord* blk_start,\n-                        HeapWord* blk_end);\n+  \/\/ Update BOT entries corresponding to the mem range [blk_start, blk_end).\n+  void alloc_block_work(HeapWord* blk_start, HeapWord* blk_end);\n@@ -156,0 +146,11 @@\n+  static HeapWord* align_up_by_card_size(HeapWord* const addr) {\n+    return align_up(addr, BOTConstants::card_size());\n+  }\n+\n+  static bool is_crossing_card_boundary(HeapWord* const obj_start,\n+                                        HeapWord* const obj_end) {\n+    HeapWord* cur_card_boundary = align_up_by_card_size(obj_start);\n+    \/\/ strictly greater-than\n+    return obj_end > cur_card_boundary;\n+  }\n+\n@@ -163,2 +164,0 @@\n-  inline HeapWord* align_up_by_card_size(HeapWord* const addr) const;\n-\n@@ -171,3 +170,0 @@\n-  \/\/ Same as above, but does not have any of the possible side effects\n-  \/\/ discussed above.\n-  inline HeapWord* block_start_const(const void* addr) const;\n@@ -175,18 +171,0 @@\n-  \/\/ Reset bot to be empty.\n-  void reset_bot();\n-\n-  bool is_empty() const;\n-\n-  \/\/ Return the next threshold, the point at which the table should be\n-  \/\/ updated.\n-  HeapWord* threshold() const { return _next_offset_threshold; }\n-\n-  \/\/ Sets the threshold explicitly to keep it consistent with what has been\n-  \/\/ updated. This needs to be done when the threshold is not used for updating\n-  \/\/ the bot, for example when promoting to old in young collections.\n-  void set_threshold(HeapWord* threshold) { _next_offset_threshold = threshold; }\n-\n-  \/\/ These must be guaranteed to work properly (i.e., do nothing)\n-  \/\/ when \"blk_start\" (\"blk\" for second version) is \"NULL\".  In this\n-  \/\/ implementation, that's true because NULL is represented as 0, and thus\n-  \/\/ never exceeds the \"_next_offset_threshold\".\n@@ -194,2 +172,2 @@\n-    if (blk_end > _next_offset_threshold) {\n-      alloc_block_work(&_next_offset_threshold, blk_start, blk_end);\n+    if (is_crossing_card_boundary(blk_start, blk_end)) {\n+      alloc_block_work(blk_start, blk_end);\n@@ -198,2 +176,3 @@\n-  void alloc_block(HeapWord* blk, size_t size) {\n-    alloc_block(blk, blk+size);\n+\n+  void alloc_block(HeapWord* blk_start, size_t size) {\n+    alloc_block(blk_start, blk_start + size);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BlockOffsetTable.hpp","additions":18,"deletions":39,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -33,5 +33,1 @@\n-\n-inline HeapWord* G1BlockOffsetTablePart::align_up_by_card_size(HeapWord* const addr) const {\n-  assert(addr >= _hr->bottom() && addr < _hr->top(), \"invalid address\");\n-  return align_up(addr, BOTConstants::card_size());\n-}\n+#include \"oops\/oop.inline.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BlockOffsetTable.inline.hpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -3298,1 +3298,0 @@\n-    alloc_region->update_bot_threshold();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -190,2 +190,0 @@\n-    hr->reset_bot();\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1EvacFailure.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -50,3 +50,0 @@\n-  if (init_threshold) {\n-    _current_region->initialize_bot_threshold();\n-  }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCCompactionPoint.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -440,1 +440,1 @@\n-  region->update_bot_if_crossing_boundary(obj_start, word_sz);\n+  region->update_bot_for_obj(obj_start, word_sz);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -263,1 +263,0 @@\n-  reset_bot();\n@@ -783,1 +782,0 @@\n-  reset_bot();\n@@ -792,4 +790,0 @@\n-void HeapRegion::initialize_bot_threshold() {\n-  _bot_part.reset_bot();\n-}\n-\n@@ -813,1 +807,1 @@\n-    update_bot_if_crossing_boundary(address, word_size);\n+    update_bot_for_obj(address, word_size);\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.cpp","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -166,1 +166,1 @@\n-  inline void update_bot_if_crossing_boundary(HeapWord* obj_start, size_t obj_size);\n+  inline void update_bot_for_obj(HeapWord* obj_start, size_t obj_size);\n@@ -170,1 +170,0 @@\n-  void initialize_bot_threshold();\n@@ -195,4 +194,0 @@\n-  void reset_bot() {\n-    _bot_part.reset_bot();\n-  }\n-\n@@ -203,4 +198,0 @@\n-  void update_bot_threshold() {\n-    _bot_part.set_threshold(top());\n-  }\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.hpp","additions":1,"deletions":10,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -186,4 +186,0 @@\n-  if (is_empty()) {\n-    reset_bot();\n-  }\n-\n@@ -234,1 +230,1 @@\n-inline void HeapRegion::update_bot_if_crossing_boundary(HeapWord* obj_start, size_t obj_size) {\n+inline void HeapRegion::update_bot_for_obj(HeapWord* obj_start, size_t obj_size) {\n@@ -237,1 +233,1 @@\n-  HeapWord* obj_end   = obj_start + obj_size;\n+  HeapWord* obj_end = obj_start + obj_size;\n@@ -244,12 +240,1 @@\n-  HeapWord* cur_card_boundary = _bot_part.align_up_by_card_size(obj_start);\n-\n-  \/\/ strictly greater-than\n-  bool cross_card_boundary = (obj_end > cur_card_boundary);\n-\n-  if (cross_card_boundary) {\n-    \/\/ Creating a dummy variable inside this `if` as the arg of `&`; this\n-    \/\/ avoids unnecessary loads in the assembly code on the fast path (the\n-    \/\/ bot-not-updating case).\n-    HeapWord* dummy = cur_card_boundary;\n-    _bot_part.alloc_block_work(&dummy, obj_start, obj_end);\n-  }\n+  _bot_part.alloc_block(obj_start, obj_end);\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.inline.hpp","additions":3,"deletions":18,"binary":false,"changes":21,"status":"modified"}]}