{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -354,2 +354,1 @@\n-                             getLocalGraphicsEnvironment()).\n-                                displayChanged();\n+                             getLocalGraphicsEnvironment()).rebuildDevices();\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/X11\/XToolkit.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -332,9 +332,2 @@\n-    public Rectangle getBounds() {\n-        Rectangle rect = pGetBounds(device.getScreen());\n-        if (getScale() != 1) {\n-            rect.x = scaleDown(rect.x);\n-            rect.y = scaleDown(rect.y);\n-            rect.width = scaleDown(rect.width);\n-            rect.height = scaleDown(rect.height);\n-        }\n-        return rect;\n+    public final Rectangle getBounds() {\n+        return device.getBounds();\n@@ -343,2 +336,0 @@\n-    private native Rectangle pGetBounds(int screenNum);\n-\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/X11GraphicsConfig.java","additions":3,"deletions":12,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+import sun.java2d.pipe.Region;\n@@ -56,1 +57,5 @@\n-    int screen;\n+    \/**\n+     * X11 screen number. This identifier can become non-valid at any time\n+     * therefore methods, which is using this id should be ready to it.\n+     *\/\n+    private volatile int screen;\n@@ -108,0 +113,19 @@\n+    public int scaleUp(int x) {\n+        return Region.clipRound(x * (double)getScaleFactor());\n+    }\n+\n+    public int scaleDown(int x) {\n+        return Region.clipRound(x \/ (double)getScaleFactor());\n+    }\n+\n+    public Rectangle getBounds() {\n+        Rectangle rect = pGetBounds(getScreen());\n+        if (getScaleFactor() != 1) {\n+            rect.x = scaleDown(rect.x);\n+            rect.y = scaleDown(rect.y);\n+            rect.width = scaleDown(rect.width);\n+            rect.height = scaleDown(rect.height);\n+        }\n+        return rect;\n+    }\n+\n@@ -168,2 +192,2 @@\n-                        ret[i] = XRGraphicsConfig.getConfig(this, visNum, depth,                                getConfigColormap(i, screen),\n-                                doubleBuffer);\n+                        ret[i] = XRGraphicsConfig.getConfig(this, visNum, depth,\n+                                getConfigColormap(i, screen), doubleBuffer);\n@@ -274,1 +298,0 @@\n-    private static native void resetNativeData(int screen);\n@@ -276,0 +299,1 @@\n+    private native Rectangle pGetBounds(int screenNum);\n@@ -517,1 +541,0 @@\n-        isXrandrExtensionSupported();\n@@ -547,0 +570,4 @@\n+\n+    public void invalidate(X11GraphicsDevice device) {\n+        screen = device.screen;\n+    }\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/X11GraphicsDevice.java","additions":32,"deletions":5,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import java.lang.ref.WeakReference;\n@@ -34,0 +35,1 @@\n+import java.util.ArrayList;\n@@ -35,0 +37,4 @@\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.Map;\n@@ -36,0 +42,1 @@\n+import sun.awt.X11.XToolkit;\n@@ -40,1 +47,0 @@\n-import sun.util.logging.PlatformLogger;\n@@ -52,5 +58,0 @@\n-    private static final PlatformLogger log = PlatformLogger.getLogger(\"sun.awt.X11GraphicsEnvironment\");\n-    private static final PlatformLogger screenLog = PlatformLogger.getLogger(\"sun.awt.screen.X11GraphicsEnvironment\");\n-\n-    private static Boolean xinerState;\n-\n@@ -172,0 +173,11 @@\n+    \/** Available X11 screens. *\/\n+    private final Map<Integer, X11GraphicsDevice> devices = new HashMap<>(5);\n+\n+    \/**\n+     * The key in the {@link #devices} for the main screen.\n+     *\/\n+    private int mainScreen;\n+\n+    \/\/ list of invalidated graphics devices (those which were removed)\n+    private List<WeakReference<X11GraphicsDevice>> oldDevices = new ArrayList<>();\n+\n@@ -178,0 +190,4 @@\n+    protected native int getNumScreens();\n+\n+    private native int getDefaultScreenNum();\n+\n@@ -179,0 +195,6 @@\n+        if (isHeadless()) {\n+            return;\n+        }\n+\n+        \/* Populate the device table *\/\n+        rebuildDevices();\n@@ -181,1 +203,4 @@\n-    protected native int getNumScreens();\n+    \/**\n+     * Initialize the native list of devices.\n+     *\/\n+    private static native void initNativeData();\n@@ -183,2 +208,12 @@\n-    protected GraphicsDevice makeScreenDevice(int screennum) {\n-        return new X11GraphicsDevice(screennum);\n+    \/**\n+     * Updates the list of devices and notify listeners.\n+     *\/\n+    public void rebuildDevices() {\n+        XToolkit.awtLock();\n+        try {\n+            initNativeData();\n+            initDevices();\n+        } finally {\n+            XToolkit.awtUnlock();\n+        }\n+        displayChanged();\n@@ -187,1 +222,0 @@\n-    private native int getDefaultScreenNum();\n@@ -189,1 +223,1 @@\n-     * Returns the default screen graphics device.\n+     * (Re)create all X11GraphicsDevices, reuses a devices if it is possible.\n@@ -191,3 +225,6 @@\n-    public GraphicsDevice getDefaultScreenDevice() {\n-        GraphicsDevice[] screens = getScreenDevices();\n-        if (screens.length == 0) {\n+    private synchronized void initDevices() {\n+        Map<Integer, X11GraphicsDevice> old = new HashMap<>(devices);\n+        devices.clear();\n+\n+        int numScreens = getNumScreens();\n+        if (numScreens == 0) {\n@@ -197,1 +234,42 @@\n-        return screens[0 < index && index < screens.length ? index : 0];\n+        mainScreen = 0 < index && index < screens.length ? index : 0;\n+\n+        for (int id = 0; id < numScreens; ++id) {\n+            devices.put(id, old.containsKey(id) ? old.remove(id) :\n+                                                  new X11GraphicsDevice(id));\n+        }\n+        \/\/ if a device was not reused it should be invalidated\n+        for (X11GraphicsDevice gd : old.values()) {\n+            oldDevices.add(new WeakReference<>(gd));\n+        }\n+        \/\/ Need to notify old devices, in case the user hold the reference to it\n+        for (ListIterator<WeakReference<X11GraphicsDevice>> it =\n+             oldDevices.listIterator(); it.hasNext(); ) {\n+            X11GraphicsDevice gd = it.next().get();\n+            if (gd != null) {\n+                gd.invalidate(devices.get(mainScreen));\n+                gd.displayChanged();\n+            } else {\n+                \/\/ no more references to this device, remove it\n+                it.remove();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public synchronized GraphicsDevice getDefaultScreenDevice() {\n+        return devices.get(mainScreen);\n+    }\n+\n+    @Override\n+    public synchronized GraphicsDevice[] getScreenDevices() {\n+        return devices.values().toArray(new X11GraphicsDevice[0]);\n+    }\n+\n+    public synchronized GraphicsDevice getScreenDevice(int screen) {\n+        return devices.get(screen);\n+    }\n+\n+    @Override\n+    protected GraphicsDevice makeScreenDevice(int screennum) {\n+        throw new UnsupportedOperationException(\"This method is unused and\" +\n+                \"should not be called in this implementation\");\n@@ -292,9 +370,1 @@\n-        if (xinerState == null) {\n-            \/\/ pRunningXinerama() simply returns a global boolean variable,\n-            \/\/ so there is no need to synchronize here\n-            xinerState = Boolean.valueOf(pRunningXinerama());\n-            if (screenLog.isLoggable(PlatformLogger.Level.FINER)) {\n-                screenLog.finer(\"Running Xinerama: \" + xinerState);\n-            }\n-        }\n-        return xinerState.booleanValue();\n+        return pRunningXinerama();\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/X11GraphicsEnvironment.java","additions":95,"deletions":25,"binary":false,"changes":120,"status":"modified"},{"patch":"@@ -61,1 +61,1 @@\n-AwtScreenDataPtr x11Screens;\n+AwtScreenDataPtr x11Screens; \/\/ should be guarded by AWT_LOCK()\/AWT_UNLOCK()\n@@ -594,2 +594,0 @@\n-    int32_t locNumScr = 0;\n-    XineramaScreenInfo *xinInfo;\n@@ -625,17 +623,0 @@\n-        } else {\n-            DTRACE_PRINTLN(\"calling XineramaQueryScreens func\");\n-            xinInfo = (*XineramaQueryScreens)(awt_display, &locNumScr);\n-            if (xinInfo != NULL) {\n-                if (locNumScr > XScreenCount(awt_display)) {\n-                    DTRACE_PRINTLN(\"Enabling Xinerama support\");\n-                    usingXinerama = True;\n-                    \/* set global number of screens *\/\n-                    DTRACE_PRINTLN1(\" num screens = %i\\n\", locNumScr);\n-                    awt_numScreens = locNumScr;\n-                } else {\n-                    DTRACE_PRINTLN(\"XineramaQueryScreens <= XScreenCount\");\n-                }\n-                XFree(xinInfo);\n-            } else {\n-                DTRACE_PRINTLN(\"calling XineramaQueryScreens didn't work\");\n-            }\n@@ -648,0 +629,80 @@\n+static void resetNativeData(int screen) {\n+    \/*\n+     * Reset references to the various configs; the actual native config data\n+     * will be free'd later by the Disposer mechanism when the Java-level\n+     * X11GraphicsConfig objects go away.  By setting these values to NULL,\n+     * we ensure that they will be reinitialized as necessary (for example,\n+     * see the getNumConfigs() method).\n+     *\/\n+    if (x11Screens[screen].configs) {\n+        free(x11Screens[screen].configs);\n+        x11Screens[screen].configs = NULL;\n+    }\n+    x11Screens[screen].defaultConfig = NULL;\n+    x11Screens[screen].numConfigs = 0;\n+}\n+\n+\/*\n+ * Class:     sun_awt_X11GraphicsEnvironment\n+ * Method:    initDevices\n+ * Signature: (Z)V\n+ *\/\n+JNIEXPORT void JNICALL\n+Java_sun_awt_X11GraphicsEnvironment_initNativeData(JNIEnv *env, jobject this) {\n+    usingXinerama = False;\n+    if (x11Screens) {\n+        for (int i = 0; i < awt_numScreens; ++i) {\n+            resetNativeData(i);\n+        }\n+        free((void *)x11Screens);\n+        x11Screens = NULL;\n+        awt_numScreens = 0;\n+    }\n+\n+    \/\/ will try xinerama first\n+    if (XineramaQueryScreens) {\n+        int32_t locNumScr = 0;\n+        XineramaScreenInfo *xinInfo;\n+        DTRACE_PRINTLN(\"calling XineramaQueryScreens func\");\n+        xinInfo = (*XineramaQueryScreens)(awt_display, &locNumScr);\n+        if (xinInfo != NULL) {\n+            if (locNumScr > XScreenCount(awt_display)) {\n+                DTRACE_PRINTLN(\"Enabling Xinerama support\");\n+                usingXinerama = True;\n+                \/* set global number of screens *\/\n+                DTRACE_PRINTLN1(\" num screens = %i\\n\", locNumScr);\n+                awt_numScreens = locNumScr;\n+            } else {\n+                DTRACE_PRINTLN(\"XineramaQueryScreens <= XScreenCount\");\n+            }\n+            XFree(xinInfo);\n+        } else {\n+            DTRACE_PRINTLN(\"calling XineramaQueryScreens didn't work\");\n+        }\n+    }\n+    \/\/ if xinerama is not enabled or does not work will use X11\n+    if (!usingXinerama) {\n+        awt_numScreens =  XScreenCount(awt_display);\n+    }\n+    DTRACE_PRINTLN1(\"allocating %i screens\\n\", awt_numScreens);\n+    \/* Allocate screen data structure array *\/\n+    x11Screens = calloc(awt_numScreens, sizeof(AwtScreenData));\n+    if (x11Screens == NULL) {\n+        JNU_ThrowOutOfMemoryError((JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2),\n+                                  NULL);\n+        return;\n+    }\n+\n+    for (int i = 0; i < awt_numScreens; i++) {\n+        if (usingXinerama) {\n+            \/* All Xinerama screens use the same X11 root for now *\/\n+            x11Screens[i].root = RootWindow(awt_display, 0);\n+        }\n+        else {\n+            x11Screens[i].root = RootWindow(awt_display, i);\n+        }\n+        x11Screens[i].defaultConfig = makeDefaultConfig(env, i);\n+        JNU_CHECK_EXCEPTION(env);\n+    }\n+}\n+\n@@ -695,26 +756,0 @@\n-\n-    if (!usingXinerama) {\n-        awt_numScreens =  XScreenCount(awt_display);\n-    }\n-\n-    DTRACE_PRINTLN1(\"allocating %i screens\\n\", awt_numScreens);\n-    \/* Allocate screen data structure array *\/\n-    x11Screens = calloc(awt_numScreens, sizeof(AwtScreenData));\n-    if (x11Screens == NULL) {\n-        JNU_ThrowOutOfMemoryError((JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2),\n-                                  NULL);\n-        return NULL;\n-    }\n-\n-    for (i = 0; i < awt_numScreens; i++) {\n-        if (usingXinerama) {\n-            \/* All Xinerama screens use the same X11 root for now *\/\n-            x11Screens[i].root = RootWindow(awt_display, 0);\n-        }\n-        else {\n-            x11Screens[i].root = RootWindow(awt_display, i);\n-        }\n-        x11Screens[i].defaultConfig = makeDefaultConfig(env, i);\n-        JNU_CHECK_EXCEPTION_RETURN(env, NULL);\n-    }\n-\n@@ -940,0 +975,1 @@\n+    AWT_LOCK();\n@@ -941,1 +977,3 @@\n-    return x11Screens[screen].numConfigs;\n+    int configs = x11Screens[screen].numConfigs;\n+    AWT_UNLOCK();\n+    return configs;\n@@ -954,1 +992,1 @@\n-\n+    AWT_LOCK();\n@@ -956,5 +994,4 @@\n-    if (index == 0) {\n-        return ((jint)x11Screens[screen].defaultConfig->awt_visInfo.visualid);\n-    } else {\n-        return ((jint)x11Screens[screen].configs[index]->awt_visInfo.visualid);\n-    }\n+    jint id = (jint) (index == 0 ? x11Screens[screen].defaultConfig\n+                                 : x11Screens[screen].configs[index])->awt_visInfo.visualid;\n+    AWT_UNLOCK();\n+    return id;\n@@ -973,1 +1010,1 @@\n-\n+    AWT_LOCK();\n@@ -975,5 +1012,4 @@\n-    if (index == 0) {\n-        return ((jint)x11Screens[screen].defaultConfig->awt_visInfo.depth);\n-    } else {\n-        return ((jint)x11Screens[screen].configs[index]->awt_visInfo.depth);\n-    }\n+    jint depth = (jint) (index == 0 ? x11Screens[screen].defaultConfig\n+                                    : x11Screens[screen].configs[index])->awt_visInfo.depth;\n+    AWT_UNLOCK();\n+    return depth;\n@@ -992,1 +1028,1 @@\n-\n+    AWT_LOCK();\n@@ -994,5 +1030,4 @@\n-    if (index == 0) {\n-        return ((jint)x11Screens[screen].defaultConfig->awt_cmap);\n-    } else {\n-        return ((jint)x11Screens[screen].configs[index]->awt_cmap);\n-    }\n+    jint colormap = (jint) (index == 0 ? x11Screens[screen].defaultConfig\n+                                       : x11Screens[screen].configs[index])->awt_cmap;\n+    AWT_UNLOCK();\n+    return colormap;\n@@ -1001,23 +1036,0 @@\n-\/*\n- * Class:     sun_awt_X11GraphicsDevice\n- * Method:    resetNativeData\n- * Signature: (I)V\n- *\/\n-JNIEXPORT void JNICALL\n-Java_sun_awt_X11GraphicsDevice_resetNativeData\n-    (JNIEnv *env, jclass x11gd, jint screen)\n-{\n-    \/*\n-     * Reset references to the various configs; the actual native config data\n-     * will be free'd later by the Disposer mechanism when the Java-level\n-     * X11GraphicsConfig objects go away.  By setting these values to NULL,\n-     * we ensure that they will be reinitialized as necessary (for example,\n-     * see the getNumConfigs() method).\n-     *\/\n-    if (x11Screens[screen].configs) {\n-        free(x11Screens[screen].configs);\n-        x11Screens[screen].configs = NULL;\n-    }\n-    x11Screens[screen].defaultConfig = NULL;\n-    x11Screens[screen].numConfigs = 0;\n-}\n@@ -1131,0 +1143,1 @@\n+    AWT_LOCK();\n@@ -1152,0 +1165,1 @@\n+        AWT_UNLOCK();\n@@ -1170,0 +1184,1 @@\n+    AWT_UNLOCK();\n@@ -1213,1 +1228,1 @@\n- * Class:     sun_awt_X11GraphicsConfig\n+ * Class:     sun_awt_X11GraphicsDevice\n@@ -1218,1 +1233,1 @@\n-Java_sun_awt_X11GraphicsConfig_pGetBounds(JNIEnv *env, jobject this, jint screen)\n+Java_sun_awt_X11GraphicsDevice_pGetBounds(JNIEnv *env, jobject this, jint screen)\n@@ -1223,1 +1238,0 @@\n-    AwtGraphicsConfigDataPtr adata;\n@@ -1227,3 +1241,0 @@\n-    adata = (AwtGraphicsConfigDataPtr)\n-        JNU_GetLongFieldAsPtr(env, this, x11GraphicsConfigIDs.aData);\n-\n@@ -1264,2 +1275,1 @@\n-            XGetWindowAttributes(awt_display,\n-                    RootWindow(awt_display, adata->awt_visInfo.screen),\n+            XGetWindowAttributes(awt_display, RootWindow(awt_display, screen),\n","filename":"src\/java.desktop\/unix\/native\/libawt_xawt\/awt\/awt_GraphicsEnv.c","additions":106,"deletions":96,"binary":false,"changes":202,"status":"modified"},{"patch":"@@ -123,0 +123,1 @@\n+    AWT_LOCK();\n@@ -125,1 +126,1 @@\n-\n+    AWT_UNLOCK();\n@@ -148,0 +149,1 @@\n+    AWT_LOCK();\n@@ -151,0 +153,1 @@\n+    AWT_UNLOCK();\n","filename":"src\/java.desktop\/unix\/native\/libawt_xawt\/xawt\/XToolkit.c","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"}]}