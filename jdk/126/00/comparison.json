{"files":[{"patch":"@@ -60,2 +60,2 @@\n-      (align_up_(sizeof(BytecodeInterpreter),\n-                 wordSize) >> LogBytesPerWord) - 1,\n+      (align_up(sizeof(BytecodeInterpreter),\n+                wordSize) >> LogBytesPerWord) - 1,\n","filename":"src\/hotspot\/cpu\/zero\/interpreterFrame_zero.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -116,2 +116,2 @@\n-  \/\/ C++11: is_power_of_2 is not (yet) constexpr.\n-  STATIC_ASSERT((N >= 2) && ((N & (N - 1)) == 0));\n+  STATIC_ASSERT(N >= 2);\n+  STATIC_ASSERT(is_power_of_2(N));\n","filename":"src\/hotspot\/share\/gc\/shared\/taskqueue.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n-  ((alignment) + align_up_(sizeof(type), (alignment)))\n+  ((alignment) + align_up(sizeof(type), (alignment)))\n@@ -72,1 +72,1 @@\n-#define PADDED_END_SIZE(type, alignment) (align_up_(sizeof(type), (alignment)) - sizeof(type))\n+#define PADDED_END_SIZE(type, alignment) (align_up(sizeof(type), (alignment)) - sizeof(type))\n","filename":"src\/hotspot\/share\/memory\/padded.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,1 @@\n-  STATIC_ASSERT(is_aligned_(sizeof(PaddedEnd<T>), alignment));\n+  STATIC_ASSERT(is_aligned(sizeof(PaddedEnd<T>), alignment));\n","filename":"src\/hotspot\/share\/memory\/padded.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-#define ScaleForWordSize(x) align_down_((x) * 13 \/ 10, HeapWordSize)\n+#define ScaleForWordSize(x) align_down((x) * 13 \/ 10, HeapWordSize)\n","filename":"src\/hotspot\/share\/runtime\/globals_shared.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,1 @@\n-#define CALC_OBJ_SIZE_IN_TYPE(obj, type) (align_up_(sizeof(obj), sizeof(type))\/sizeof(type))\n+#define CALC_OBJ_SIZE_IN_TYPE(obj, type) (align_up(sizeof(obj), sizeof(type))\/sizeof(type))\n","filename":"src\/hotspot\/share\/services\/nmtCommon.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+#include \"metaprogramming\/enableIf.hpp\"\n+#include \"utilities\/debug.hpp\"\n@@ -30,30 +32,10 @@\n-\n-\/\/ Signed variants of alignment helpers.  There are two versions of each, a macro\n-\/\/ for use in places like enum definitions that require compile-time constant\n-\/\/ expressions and a function for all other places so as to get type checking.\n-\n-\/\/ Using '(what) & ~align_mask(alignment)' to align 'what' down is broken when\n-\/\/ 'alignment' is an unsigned int and 'what' is a wider type. The & operation\n-\/\/ will widen the inverted mask, and not sign extend it, leading to a mask with\n-\/\/ zeros in the most significant bits. The use of align_mask_widened() solves\n-\/\/ this problem.\n-#define align_mask(alignment) ((alignment) - 1)\n-#define widen_to_type_of(what, type_carrier) (true ? (what) : (type_carrier))\n-#define align_mask_widened(alignment, type_carrier) widen_to_type_of(align_mask(alignment), (type_carrier))\n-\n-#define align_down_(size, alignment) ((size) & ~align_mask_widened((alignment), (size)))\n-\n-#define align_up_(size, alignment) (align_down_((size) + align_mask(alignment), (alignment)))\n-\n-#define is_aligned_(size, alignment) (((size) & align_mask(alignment)) == 0)\n-\n-\/\/ Helpers to align sizes and check for alignment\n-\n-template <typename T, typename A>\n-inline T align_up(T size, A alignment) {\n-  assert(is_power_of_2(alignment), \"must be a power of 2: \" UINT64_FORMAT, (uint64_t)alignment);\n-\n-  T ret = align_up_(size, alignment);\n-  assert(is_aligned_(ret, alignment), \"must be aligned: \" UINT64_FORMAT, (uint64_t)ret);\n-\n-  return ret;\n+#include <type_traits>\n+\n+\/\/ Compute mask to use for aligning to or testing alignment.\n+\/\/ The alignment must be a power of 2. Returns alignment - 1, which is\n+\/\/ a mask with all bits set below alignment's single bit.\n+template<typename T, ENABLE_IF(std::is_integral<T>::value)>\n+static constexpr T alignment_mask(T alignment) {\n+  assert(is_power_of_2(alignment),\n+         \"must be a power of 2: \" UINT64_FORMAT, (uint64_t)alignment);\n+  return alignment - 1;\n@@ -62,3 +44,5 @@\n-template <typename T, typename A>\n-inline T align_down(T size, A alignment) {\n-  assert(is_power_of_2(alignment), \"must be a power of 2: \" UINT64_FORMAT, (uint64_t)alignment);\n+\/\/ Some \"integral\" constant alignments are defined via enum.\n+template<typename T, ENABLE_IF(std::is_enum<T>::value)>\n+static constexpr auto alignment_mask(T alignment) {\n+  return alignment_mask(static_cast<std::underlying_type_t<T>>(alignment));\n+}\n@@ -66,2 +50,5 @@\n-  T ret = align_down_(size, alignment);\n-  assert(is_aligned_(ret, alignment), \"must be aligned: \" UINT64_FORMAT, (uint64_t)ret);\n+\/\/ Align integers and check for alignment.\n+\/\/ The is_integral filtering here is not for disambiguation with the T*\n+\/\/ overloads; if those match then they are a better match.  Rather, the\n+\/\/ is_integral filtering is to prevent back-sliding on the use of enums\n+\/\/ as \"integral\" constants that need aligning.\n@@ -69,1 +56,3 @@\n-  return ret;\n+template<typename T, typename A, ENABLE_IF(std::is_integral<T>::value)>\n+constexpr bool is_aligned(T size, A alignment) {\n+  return (size & alignment_mask(alignment)) == 0;\n@@ -72,3 +61,10 @@\n-template <typename T, typename A>\n-inline bool is_aligned(T size, A alignment) {\n-  assert(is_power_of_2(alignment), \"must be a power of 2: \" UINT64_FORMAT, (uint64_t)alignment);\n+template<typename T, typename A, ENABLE_IF(std::is_integral<T>::value)>\n+constexpr T align_down(T size, A alignment) {\n+  \/\/ Convert mask to T before lognot.  Otherwise, if alignment is unsigned\n+  \/\/ and smaller than T, the result of the lognot will be zero-extended\n+  \/\/ by integral promotion, and upper bits of size will be discarded.\n+  T result = size & ~T(alignment_mask(alignment));\n+  assert(is_aligned(result, alignment),\n+         \"must be aligned: \" UINT64_FORMAT, (uint64_t)result);\n+  return result;\n+}\n@@ -76,1 +72,4 @@\n-  return is_aligned_(size, alignment);\n+template<typename T, typename A, ENABLE_IF(std::is_integral<T>::value)>\n+constexpr T align_up(T size, A alignment) {\n+  T adjusted = size + alignment_mask(alignment);\n+  return align_down(adjusted, alignment);\n@@ -81,3 +80,3 @@\n-inline T align_down_bounded(T size, A alignment) {\n-  A aligned_size = align_down(size, alignment);\n-  return aligned_size > 0 ? aligned_size : alignment;\n+constexpr T align_down_bounded(T size, A alignment) {\n+  T aligned_size = align_down(size, alignment);\n+  return (aligned_size > 0) ? aligned_size : T(alignment);\n@@ -86,1 +85,1 @@\n-\/\/ Helpers to align pointers and check for alignment.\n+\/\/ Align pointers and check for alignment.\n@@ -125,1 +124,1 @@\n-inline T align_object_offset(T offset) {\n+constexpr T align_object_offset(T offset) {\n","filename":"src\/hotspot\/share\/utilities\/align.hpp","additions":45,"deletions":46,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -29,2 +29,0 @@\n-#include \"metaprogramming\/isIntegral.hpp\"\n-#include \"metaprogramming\/isSigned.hpp\"\n@@ -34,0 +32,2 @@\n+#include <limits>\n+#include <type_traits>\n@@ -37,2 +37,3 @@\n-template <typename T>\n-bool is_power_of_2(T x) {\n+\/\/ Returns true iff there exists integer i such that (T(1) << i) == x.\n+template <typename T, ENABLE_IF(std::is_integral<T>::value)>\n+constexpr bool is_power_of_2(T x) {\n@@ -58,7 +59,4 @@\n-\/\/ Round down to the closest power of two greater to or equal to the given\n-\/\/ value.\n-\n-\/\/ Signed version: 0 is an invalid input, negative values are invalid\n-template <typename T>\n-inline typename EnableIf<IsSigned<T>::value, T>::type round_down_power_of_2(T value) {\n-  STATIC_ASSERT(IsIntegral<T>::value);\n+\/\/ Round down to the closest power of two less than or equal to the given value.\n+\/\/ precondition: value > 0.\n+template<typename T, ENABLE_IF(std::is_integral<T>::value)>\n+inline T round_down_power_of_2(T value) {\n@@ -67,11 +65,0 @@\n-  assert(lz < sizeof(T) * BitsPerByte, \"Sanity\");\n-  return T(1) << (sizeof(T) * BitsPerByte - 1 - lz);\n-}\n-\n-\/\/ Unsigned version: 0 is an invalid input\n-template <typename T>\n-inline typename EnableIf<!IsSigned<T>::value, T>::type round_down_power_of_2(T value) {\n-  STATIC_ASSERT(IsIntegral<T>::value);\n-  assert(value != 0, \"Invalid value\");\n-  uint32_t lz = count_leading_zeros(value);\n-  assert(lz < sizeof(T) * BitsPerByte, \"Sanity\");\n@@ -81,10 +68,5 @@\n-\/\/ Round up to the closest power of two greater to or equal to\n-\/\/ the given value.\n-\n-\/\/ Signed version: 0 is an invalid input, negative values are invalid,\n-\/\/ overflows with assert if value is larger than 2^30 or 2^62 for 32- and\n-\/\/ 64-bit integers, respectively\n-template <typename T>\n-inline typename EnableIf<IsSigned<T>::value, T>::type round_up_power_of_2(T value) {\n-  STATIC_ASSERT(IsIntegral<T>::value);\n-  STATIC_ASSERT(IsSigned<T>::value);\n+\/\/ Round up to the closest power of two greater to or equal to the given value.\n+\/\/ precondition: value > 0.\n+\/\/ precondition: value <= maximum power of two representable by T.\n+template<typename T, ENABLE_IF(std::is_integral<T>::value)>\n+inline T round_up_power_of_2(T value) {\n@@ -92,0 +74,2 @@\n+  const T max_value = std::numeric_limits<T>::max();\n+  assert(value <= (max_value - (max_value >> 1)), \"Overflow\");\n@@ -96,18 +80,0 @@\n-  assert(lz < sizeof(T) * BitsPerByte, \"Sanity\");\n-  assert(lz > 1, \"Will overflow\");\n-  return T(1) << (sizeof(T) * BitsPerByte - lz);\n-}\n-\n-\/\/ Unsigned version: 0 is an invalid input, overflows with assert if value\n-\/\/ is larger than 2^31 or 2^63 for 32- and 64-bit integers, respectively\n-template <typename T>\n-inline typename EnableIf<!IsSigned<T>::value, T>::type round_up_power_of_2(T value) {\n-  STATIC_ASSERT(IsIntegral<T>::value);\n-  STATIC_ASSERT(!IsSigned<T>::value);\n-  assert(value != 0, \"Invalid value\");\n-  if (is_power_of_2(value)) {\n-    return value;\n-  }\n-  uint32_t lz = count_leading_zeros(value);\n-  assert(lz < sizeof(T) * BitsPerByte, \"Sanity\");\n-  assert(lz > 0, \"Will overflow\");\n@@ -117,21 +83,0 @@\n-\/\/ Helper function to get the maximum positive value. Implemented here\n-\/\/ since using std::numeric_limits<T>::max() seems problematic on some\n-\/\/ platforms.\n-\n-template <typename T> T max_value() {\n-  if (IsSigned<T>::value) {\n-    \/\/ Highest positive power of two expressible in the type\n-    uint64_t val = static_cast<T>(1) << (sizeof(T) * BitsPerByte - 2);\n-    \/\/ Fill lower bits with ones\n-    val |= val >> 1;\n-    val |= val >> 2;\n-    val |= val >> 4;\n-    if (sizeof(T) >= 2)  val |= val >> 8;\n-    if (sizeof(T) >= 4)  val |= val >> 16;\n-    if (sizeof(T) == 8)  val |= val >> 32;\n-    return (T)val;\n-  } else {\n-    return ~(static_cast<T>(0));\n-  }\n-}\n-\n@@ -139,5 +84,3 @@\n-\n-\/\/ Accepts 0 (returns 1), overflows with assert if value is larger than\n-\/\/ or equal to 2^31 (signed: 2^30) or 2^63 (signed: 2^62), for 32-\n-\/\/ and 64-bit integers, respectively\n-template <typename T>\n+\/\/ precondition: if signed, value >= 0.\n+\/\/ precondition: value < maximum power of two representable by T.\n+template <typename T, ENABLE_IF(std::is_integral<T>::value)>\n@@ -145,1 +88,1 @@\n-  assert(value != max_value<T>(), \"Overflow\");\n+  assert(value < std::numeric_limits<T>::max(), \"Overflow\");\n","filename":"src\/hotspot\/share\/utilities\/powerOfTwo.hpp","additions":20,"deletions":77,"binary":false,"changes":97,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -156,1 +156,1 @@\n-  julong julong_ret = align_up_(small_xss_input, K) \/ K;\n+  julong julong_ret = align_up(small_xss_input, K) \/ K;\n","filename":"test\/hotspot\/gtest\/runtime\/test_arguments.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,0 @@\n-#include \"unittest.hpp\"\n-\n@@ -31,0 +29,1 @@\n+#include \"unittest.hpp\"\n@@ -33,1 +32,1 @@\n-static uint64_t values[] = {1, 3, 10, 345, 1023, 1024, 1025, 23909034, INT_MAX, uint64_t(-1) \/ 2, uint64_t(-1) \/ 2 + 100, uint64_t(-1)};\n+static constexpr uint64_t values[] = {1, 3, 10, 345, 1023, 1024, 1025, 23909034, INT_MAX, uint64_t(-1) \/ 2, uint64_t(-1) \/ 2 + 100, uint64_t(-1)};\n@@ -36,1 +35,1 @@\n-static T max_alignment() {\n+static constexpr T max_alignment() {\n@@ -43,0 +42,62 @@\n+struct StaticTestAlignmentsResult {\n+  uint64_t _value;\n+  uint64_t _alignment;\n+  int _status;            \/\/ 0: success, > 0 indicates which failure case\n+  constexpr StaticTestAlignmentsResult(uint64_t value, uint64_t alignment, int status) :\n+    _value(value), _alignment(alignment), _status(status) {}\n+};\n+\n+\/\/ Structure copied from test_alignments runtime test (below).\n+template<typename T, typename A>\n+static constexpr StaticTestAlignmentsResult\n+static_test_alignments_aux(A alignment) {\n+  using Result = StaticTestAlignmentsResult;\n+\n+  for ( ; alignment > 0; alignment >>= 1) {\n+    for (size_t i = 0; i < ARRAY_SIZE(values); ++i) {\n+      \/\/ Test align up\n+      uint64_t up = align_up(values[i], alignment);\n+      if (0 < up && up < uint64_t(std::numeric_limits<T>::max())) {\n+        T value = T(values[i]);\n+        if (align_up(uint64_t(value), alignment) != up) {\n+          return Result(values[i], alignment, 1);\n+        } else if (align_up(value, alignment) < value) {\n+          return Result(values[i], alignment, 2);\n+        }\n+      }\n+\n+      \/\/ Test align down\n+      uint64_t down = align_down(values[i], alignment);\n+      if (down <= uint64_t(std::numeric_limits<T>::max())) {\n+        T value = T(values[i]);\n+        if (uint64_t(align_down(value, alignment)) != down) {\n+          return Result(values[i], alignment, 3);\n+        } else if (align_down(value, alignment) > value) {\n+          return Result(values[i], alignment, 4);\n+        }\n+      }\n+\n+      \/\/ Test is aligned\n+      bool is = is_aligned(values[i], alignment);\n+      if (values[i] <= uint64_t(std::numeric_limits<T>::max())) {\n+        T value = T(values[i]);\n+        if (is_aligned(value, alignment) != is) {\n+          return Result(values[i], alignment, 5);\n+        }\n+      }\n+    }\n+  }\n+  return Result(T(), A(), 0);\n+}\n+\n+template<typename T, typename A>\n+static void static_test_alignments() {\n+  constexpr StaticTestAlignmentsResult result\n+    = static_test_alignments_aux<T>(max_alignment<A>());\n+\n+  EXPECT_EQ(0, result._status)\n+    << \"value = \" << result._value\n+    << \", alignment = \" << result._alignment\n+    << \", status = \" << result._status;\n+}\n+\n@@ -57,1 +118,1 @@\n-      const uint64_t up = align_up_(values[i], (uint64_t)alignment);\n+      const uint64_t up = align_up(values[i], alignment);\n@@ -65,2 +126,0 @@\n-        \/\/ Check inline function vs macro\n-        ASSERT_EQ(align_up(value, alignment), align_up_(value, alignment));\n@@ -72,1 +131,1 @@\n-      const uint64_t down = align_down_(values[i], (uint64_t)alignment);\n+      const uint64_t down = align_down(values[i], alignment);\n@@ -80,2 +139,0 @@\n-        \/\/ Check inline function vs macro\n-        ASSERT_EQ(align_down(value, alignment), align_down_(value, alignment));\n@@ -87,1 +144,1 @@\n-      const bool is = is_aligned_(values[i], (uint64_t)alignment);\n+      const bool is = is_aligned(values[i], alignment);\n@@ -95,2 +152,0 @@\n-        \/\/ Check inline function vs macro\n-        ASSERT_EQ(is_aligned(value, alignment), is_aligned_(value, alignment));\n@@ -100,0 +155,2 @@\n+\n+  static_test_alignments<T, A>();\n@@ -102,1 +159,1 @@\n-TEST(Align, functions_and_macros) {\n+TEST(Align, alignments) {\n","filename":"test\/hotspot\/gtest\/utilities\/test_align.cpp","additions":72,"deletions":15,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+#include <limits>\n@@ -54,2 +55,2 @@\n-void sparse() {\n-  const T max_val = max_value<T>();\n+static void sparse() {\n+  const T max_val = std::numeric_limits<T>::max();\n@@ -98,1 +99,1 @@\n-}\n\\ No newline at end of file\n+}\n","filename":"test\/hotspot\/gtest\/utilities\/test_population_count.cpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+#include <limits>\n+#include <type_traits>\n@@ -30,2 +32,2 @@\n-template <typename T> T max_pow2() {\n-  T max_val = max_value<T>();\n+template <typename T> static constexpr T max_pow2() {\n+  T max_val = std::numeric_limits<T>::max();\n@@ -35,0 +37,32 @@\n+struct StaticTestIsPowerOf2Result {\n+  uint64_t _value;\n+  int _status;            \/\/ 0: success, > 0 indicates which failure case\n+  constexpr StaticTestIsPowerOf2Result(uint64_t value, int status) :\n+    _value(value), _status(status) {}\n+};\n+\n+\/\/ Structure copied from test_is_power_of_2 runtime test (below).\n+template<typename T>\n+static constexpr StaticTestIsPowerOf2Result static_test_is_power_of_2_aux(T v) {\n+  using Result = StaticTestIsPowerOf2Result;\n+  for ( ; v > 0; v >>= 1) {\n+    if (!is_power_of_2(v)) {\n+      return Result(v, 1);\n+    } else if ((v > 2) && is_power_of_2(T(v - 1))) {\n+      return Result(v, 2);\n+    } else if ((v > 1) && is_power_of_2(T(v + 1))) {\n+      return Result(v, 3);\n+    }\n+  }\n+  return Result(v, 0);\n+}\n+\n+template<typename T>\n+static void static_test_is_power_of_2() {\n+  constexpr StaticTestIsPowerOf2Result result\n+    = static_test_is_power_of_2_aux(max_pow2<T>());\n+\n+  EXPECT_EQ(0, result._status)\n+    << \"value = \" << result._value << \", status = \" << result._status;\n+}\n+\n@@ -39,3 +73,6 @@\n-  if (IsSigned<T>::value) {\n-    EXPECT_FALSE(is_power_of_2(std::numeric_limits<T>::min()));\n-  }\n+  static_assert(!is_power_of_2(T(0)), \"\");\n+  static_assert(!is_power_of_2(~T(0)), \"\");\n+\n+  \/\/ Should be false regardless of whether T is signed or unsigned.\n+  EXPECT_FALSE(is_power_of_2(std::numeric_limits<T>::min()));\n+  static_assert(!is_power_of_2(std::numeric_limits<T>::min()), \"\");\n@@ -57,0 +94,2 @@\n+\n+  static_test_is_power_of_2<T>();\n","filename":"test\/hotspot\/gtest\/utilities\/test_powerOfTwo.cpp","additions":45,"deletions":6,"binary":false,"changes":51,"status":"modified"}]}