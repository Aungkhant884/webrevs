{"files":[{"patch":"@@ -73,1 +73,1 @@\n-        int setPaddingBytes(byte[] paddingBuffer, int padLen);\n+        int setPaddingBytes(byte[] paddingBuffer, int startOff, int padLen);\n@@ -94,2 +94,2 @@\n-        public int setPaddingBytes(byte[] paddingBuffer, int padLen) {\n-            Arrays.fill(paddingBuffer, 0, padLen, (byte) (padLen & 0x007f));\n+        public int setPaddingBytes(byte[] paddingBuffer, int startOff, int padLen) {\n+            Arrays.fill(paddingBuffer, startOff, startOff + padLen, (byte) (padLen & 0x007f));\n@@ -172,0 +172,8 @@\n+    \/\/ Indicates whether the underlying PKCS#11 library requires block-sized\n+    \/\/ updates during multi-part operations. In such case, we buffer data in\n+    \/\/ padBuffer up to a block-size. This may be needed only if padding is\n+    \/\/ applied on the Java side. An example of the previous is when the\n+    \/\/ CKM_AES_ECB mechanism is used and the PKCS#11 library is NSS. See more\n+    \/\/ on JDK-8261355.\n+    private boolean reqBlockUpdates = false;\n+\n@@ -255,0 +263,4 @@\n+                char[] tokenLabel = token.tokenInfo.label;\n+                \/\/ NSS requires block-sized updates in multi-part operations.\n+                reqBlockUpdates = ((tokenLabel[0] == 'N' && tokenLabel[1] == 'S'\n+                        && tokenLabel[2] == 'S') ? true : false);\n@@ -590,20 +602,12 @@\n-            if (encrypt) {\n-                k = token.p11.C_EncryptUpdate(session.id(), 0, in, inOfs, inLen,\n-                        0, out, outOfs, outLen);\n-            } else {\n-                int newPadBufferLen = 0;\n-                if (paddingObj != null) {\n-                    if (padBufferLen != 0) {\n-                        \/\/ NSS throws up when called with data not in multiple\n-                        \/\/ of blocks. Try to work around this by holding the\n-                        \/\/ extra data in padBuffer.\n-                        if (padBufferLen != padBuffer.length) {\n-                            int bufCapacity = padBuffer.length - padBufferLen;\n-                            if (inLen > bufCapacity) {\n-                                bufferInputBytes(in, inOfs, bufCapacity);\n-                                inOfs += bufCapacity;\n-                                inLen -= bufCapacity;\n-                            } else {\n-                                bufferInputBytes(in, inOfs, inLen);\n-                                return 0;\n-                            }\n+            int newPadBufferLen = 0;\n+            if (paddingObj != null && (!encrypt || reqBlockUpdates)) {\n+                if (padBufferLen != 0) {\n+                    if (padBufferLen != padBuffer.length) {\n+                        int bufCapacity = padBuffer.length - padBufferLen;\n+                        if (inLen > bufCapacity) {\n+                            bufferInputBytes(in, inOfs, bufCapacity);\n+                            inOfs += bufCapacity;\n+                            inLen -= bufCapacity;\n+                        } else {\n+                            bufferInputBytes(in, inOfs, inLen);\n+                            return 0;\n@@ -611,0 +615,6 @@\n+                    }\n+                    if (encrypt) {\n+                        k = token.p11.C_EncryptUpdate(session.id(),\n+                                0, padBuffer, 0, padBufferLen,\n+                                0, out, outOfs, outLen);\n+                    } else {\n@@ -614,1 +624,0 @@\n-                        padBufferLen = 0;\n@@ -616,5 +625,10 @@\n-                    newPadBufferLen = inLen & (blockSize - 1);\n-                    if (newPadBufferLen == 0) {\n-                        newPadBufferLen = padBuffer.length;\n-                    }\n-                    inLen -= newPadBufferLen;\n+                    padBufferLen = 0;\n+                }\n+                newPadBufferLen = inLen & (blockSize - 1);\n+                if (!encrypt && newPadBufferLen == 0) {\n+                    \/\/ While decrypting with implUpdate, the last encrypted block\n+                    \/\/ is always held in a buffer. If it's the final one (unknown\n+                    \/\/ at this point), it may contain padding bytes and need further\n+                    \/\/ processing. In implDoFinal (where we know it's the final one)\n+                    \/\/ the buffer is decrypted, unpadded and returned.\n+                    newPadBufferLen = padBuffer.length;\n@@ -622,1 +636,7 @@\n-                if (inLen > 0) {\n+                inLen -= newPadBufferLen;\n+            }\n+            if (inLen > 0) {\n+                if (encrypt) {\n+                    k += token.p11.C_EncryptUpdate(session.id(), 0, in, inOfs,\n+                            inLen, 0, out, (outOfs + k), (outLen - k));\n+                } else {\n@@ -626,4 +646,4 @@\n-                \/\/ update 'padBuffer' if using our own padding impl.\n-                if (paddingObj != null) {\n-                    bufferInputBytes(in, inOfs + inLen, newPadBufferLen);\n-                }\n+            }\n+            \/\/ update 'padBuffer' if using our own padding impl.\n+            if (paddingObj != null && newPadBufferLen > 0) {\n+                bufferInputBytes(in, inOfs + inLen, newPadBufferLen);\n@@ -690,27 +710,12 @@\n-            if (encrypt) {\n-                if (inAddr == 0 && inArray == null) {\n-                    inArray = new byte[inLen];\n-                    inBuffer.get(inArray);\n-                } else {\n-                    inBuffer.position(origPos + inLen);\n-                }\n-                k = token.p11.C_EncryptUpdate(session.id(),\n-                        inAddr, inArray, inOfs, inLen,\n-                        outAddr, outArray, outOfs, outLen);\n-            } else {\n-                int newPadBufferLen = 0;\n-                if (paddingObj != null) {\n-                    if (padBufferLen != 0) {\n-                        \/\/ NSS throws up when called with data not in multiple\n-                        \/\/ of blocks. Try to work around this by holding the\n-                        \/\/ extra data in padBuffer.\n-                        if (padBufferLen != padBuffer.length) {\n-                            int bufCapacity = padBuffer.length - padBufferLen;\n-                            if (inLen > bufCapacity) {\n-                                bufferInputBytes(inBuffer, bufCapacity);\n-                                inOfs += bufCapacity;\n-                                inLen -= bufCapacity;\n-                            } else {\n-                                bufferInputBytes(inBuffer, inLen);\n-                                return 0;\n-                            }\n+            int newPadBufferLen = 0;\n+            if (paddingObj != null  && (!encrypt || reqBlockUpdates)) {\n+                if (padBufferLen != 0) {\n+                    if (padBufferLen != padBuffer.length) {\n+                        int bufCapacity = padBuffer.length - padBufferLen;\n+                        if (inLen > bufCapacity) {\n+                            bufferInputBytes(inBuffer, bufCapacity);\n+                            inOfs += bufCapacity;\n+                            inLen -= bufCapacity;\n+                        } else {\n+                            bufferInputBytes(inBuffer, inLen);\n+                            return 0;\n@@ -718,0 +723,6 @@\n+                    }\n+                    if (encrypt) {\n+                        k = token.p11.C_EncryptUpdate(session.id(), 0,\n+                                padBuffer, 0, padBufferLen, outAddr, outArray,\n+                                outOfs, outLen);\n+                    } else {\n@@ -721,1 +732,0 @@\n-                        padBufferLen = 0;\n@@ -723,5 +733,1 @@\n-                    newPadBufferLen = inLen & (blockSize - 1);\n-                    if (newPadBufferLen == 0) {\n-                        newPadBufferLen = padBuffer.length;\n-                    }\n-                    inLen -= newPadBufferLen;\n+                    padBufferLen = 0;\n@@ -729,7 +735,23 @@\n-                if (inLen > 0) {\n-                    if (inAddr == 0 && inArray == null) {\n-                        inArray = new byte[inLen];\n-                        inBuffer.get(inArray);\n-                    } else {\n-                        inBuffer.position(inBuffer.position() + inLen);\n-                    }\n+                newPadBufferLen = inLen & (blockSize - 1);\n+                if (!encrypt && newPadBufferLen == 0) {\n+                    \/\/ While decrypting with implUpdate, the last encrypted block\n+                    \/\/ is always held in a buffer. If it's the final one (unknown\n+                    \/\/ at this point), it may contain padding bytes and need further\n+                    \/\/ processing. In implDoFinal (where we know it's the final one)\n+                    \/\/ the buffer is decrypted, unpadded and returned.\n+                    newPadBufferLen = padBuffer.length;\n+                }\n+                inLen -= newPadBufferLen;\n+            }\n+            if (inLen > 0) {\n+                if (inAddr == 0 && inArray == null) {\n+                    inArray = new byte[inLen];\n+                    inBuffer.get(inArray);\n+                } else {\n+                    inBuffer.position(inBuffer.position() + inLen);\n+                }\n+                if (encrypt) {\n+                    k += token.p11.C_EncryptUpdate(session.id(), inAddr,\n+                            inArray, inOfs, inLen, outAddr, outArray,\n+                            (outOfs + k), (outLen - k));\n+                } else {\n@@ -740,4 +762,4 @@\n-                \/\/ update 'padBuffer' if using our own padding impl.\n-                if (paddingObj != null && newPadBufferLen != 0) {\n-                    bufferInputBytes(inBuffer, newPadBufferLen);\n-                }\n+            }\n+            \/\/ update 'padBuffer' if using our own padding impl.\n+            if (paddingObj != null && newPadBufferLen > 0) {\n+                bufferInputBytes(inBuffer, newPadBufferLen);\n@@ -782,0 +804,4 @@\n+                    int startOff = 0;\n+                    if (reqBlockUpdates) {\n+                        startOff = padBufferLen;\n+                    }\n@@ -783,1 +809,1 @@\n-                            requiredOutLen - bytesBuffered);\n+                            startOff, requiredOutLen - bytesBuffered);\n@@ -785,1 +811,1 @@\n-                            0, padBuffer, 0, actualPadLen,\n+                            0, padBuffer, 0, startOff + actualPadLen,\n@@ -866,0 +892,4 @@\n+                    int startOff = 0;\n+                    if (reqBlockUpdates) {\n+                        startOff = padBufferLen;\n+                    }\n@@ -867,1 +897,1 @@\n-                            requiredOutLen - bytesBuffered);\n+                            startOff, requiredOutLen - bytesBuffered);\n@@ -869,1 +899,1 @@\n-                            0, padBuffer, 0, actualPadLen,\n+                            0, padBuffer, 0, startOff + actualPadLen,\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11Cipher.java","additions":112,"deletions":82,"binary":false,"changes":194,"status":"modified"},{"patch":"@@ -0,0 +1,104 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8261355\n+ * @library \/test\/lib ..\n+ * @run main\/othervm EncryptionPadding\n+ *\/\n+\n+import java.nio.ByteBuffer;\n+import java.security.Key;\n+import java.security.Provider;\n+import java.util.Arrays;\n+import javax.crypto.Cipher;\n+import javax.crypto.spec.SecretKeySpec;\n+\n+public class EncryptionPadding extends PKCS11Test {\n+\n+    private static String transformation = \"AES\/ECB\/PKCS5Padding\";\n+    private static Key key = new SecretKeySpec(new byte[16], \"AES\");\n+\n+    public static void main(String[] args) throws Exception {\n+        main(new EncryptionPadding(), args);\n+    }\n+\n+    @Override\n+    public void main(Provider p) throws Exception {\n+        testWithInputSize(p, 1);\n+        testWithInputSize(p, 15);\n+        testWithInputSize(p, 16);\n+        testWithInputSize(p, 17);\n+        System.out.println(\"TEST PASS - OK\");\n+    }\n+\n+    private static void testWithInputSize(Provider p, int inputSize)\n+            throws Exception {\n+        testWithInputSize(p, inputSize, false);\n+        testWithInputSize(p, inputSize, true);\n+    }\n+\n+    private static void testWithInputSize(Provider p, int inputSize,\n+            boolean isByteBuffer) throws Exception {\n+        byte[] plainText = new byte[inputSize];\n+        Arrays.fill(plainText, (byte)(inputSize & 0xFF));\n+        ByteBuffer cipherText =\n+                ByteBuffer.allocate(((inputSize \/ 16 ) + 1) * 16);\n+        byte[] tmp;\n+\n+        Cipher sunPKCS11cipher = Cipher.getInstance(transformation, p);\n+        sunPKCS11cipher.init(Cipher.ENCRYPT_MODE, key);\n+        for (int i = 0; i < ((inputSize - 1) \/ 16) + 1; i++) {\n+            int updateLength = Math.min(inputSize - (16 * i), 16);\n+            if (!isByteBuffer) {\n+                tmp = sunPKCS11cipher.update(plainText, i * 16,\n+                        updateLength);\n+                if (tmp != null) {\n+                    cipherText.put(tmp);\n+                }\n+            } else {\n+                ByteBuffer bb = ByteBuffer.allocate(updateLength);\n+                bb.put(plainText, i * 16, updateLength);\n+                bb.flip();\n+                sunPKCS11cipher.update(bb, cipherText);\n+            }\n+        }\n+        if (!isByteBuffer) {\n+            tmp = sunPKCS11cipher.doFinal();\n+            if (tmp != null) {\n+                cipherText.put(tmp);\n+            }\n+        } else {\n+            sunPKCS11cipher.doFinal(ByteBuffer.allocate(0), cipherText);\n+        }\n+\n+        Cipher sunJCECipher = Cipher.getInstance(transformation, \"SunJCE\");\n+        sunJCECipher.init(Cipher.DECRYPT_MODE, key);\n+        byte[] sunJCEPlain = sunJCECipher.doFinal(cipherText.array());\n+\n+        if (!Arrays.equals(plainText, sunJCEPlain)) {\n+            throw new Exception(\"Cross-provider cipher test failed.\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Cipher\/EncryptionPadding.java","additions":104,"deletions":0,"binary":false,"changes":104,"status":"added"}]}