{"files":[{"patch":"@@ -590,20 +590,15 @@\n-            if (encrypt) {\n-                k = token.p11.C_EncryptUpdate(session.id(), 0, in, inOfs, inLen,\n-                        0, out, outOfs, outLen);\n-            } else {\n-                int newPadBufferLen = 0;\n-                if (paddingObj != null) {\n-                    if (padBufferLen != 0) {\n-                        \/\/ NSS throws up when called with data not in multiple\n-                        \/\/ of blocks. Try to work around this by holding the\n-                        \/\/ extra data in padBuffer.\n-                        if (padBufferLen != padBuffer.length) {\n-                            int bufCapacity = padBuffer.length - padBufferLen;\n-                            if (inLen > bufCapacity) {\n-                                bufferInputBytes(in, inOfs, bufCapacity);\n-                                inOfs += bufCapacity;\n-                                inLen -= bufCapacity;\n-                            } else {\n-                                bufferInputBytes(in, inOfs, inLen);\n-                                return 0;\n-                            }\n+            int newPadBufferLen = 0;\n+            if (paddingObj != null) {\n+                if (padBufferLen != 0) {\n+                    \/\/ NSS throws up when called with data not in multiple\n+                    \/\/ of blocks. Try to work around this by holding the\n+                    \/\/ extra data in padBuffer.\n+                    if (padBufferLen != padBuffer.length) {\n+                        int bufCapacity = padBuffer.length - padBufferLen;\n+                        if (inLen > bufCapacity) {\n+                            bufferInputBytes(in, inOfs, bufCapacity);\n+                            inOfs += bufCapacity;\n+                            inLen -= bufCapacity;\n+                        } else {\n+                            bufferInputBytes(in, inOfs, inLen);\n+                            return 0;\n@@ -611,0 +606,6 @@\n+                    }\n+                    if (encrypt) {\n+                        k = token.p11.C_EncryptUpdate(session.id(),\n+                                0, padBuffer, 0, padBufferLen,\n+                                0, out, outOfs, outLen);\n+                    } else {\n@@ -614,5 +615,0 @@\n-                        padBufferLen = 0;\n-                    }\n-                    newPadBufferLen = inLen & (blockSize - 1);\n-                    if (newPadBufferLen == 0) {\n-                        newPadBufferLen = padBuffer.length;\n@@ -620,1 +616,14 @@\n-                    inLen -= newPadBufferLen;\n+                    padBufferLen = 0;\n+                }\n+                newPadBufferLen = inLen & (blockSize - 1);\n+                if (!encrypt && newPadBufferLen == 0) {\n+                    \/\/ While decrypting with implUpdate, a block-sized buffer with\n+                    \/\/ encrypted data is always held instead of being unencrypted\n+                    \/\/ and returned to the caller. This is because the block may\n+                    \/\/ contain padding bytes, in case it's the last one (unknown\n+                    \/\/ at this point). In implDoFinal, where we know it's the\n+                    \/\/ last one, this buffer is unencrypted and unpadded before\n+                    \/\/ returned to the caller. None of this is necessary for\n+                    \/\/ encryption: encrypted data can be safely returned upon a\n+                    \/\/ implUpdate call.\n+                    newPadBufferLen = padBuffer.length;\n@@ -622,1 +631,7 @@\n-                if (inLen > 0) {\n+                inLen -= newPadBufferLen;\n+            }\n+            if (inLen > 0) {\n+                if (encrypt) {\n+                    k += token.p11.C_EncryptUpdate(session.id(), 0, in, inOfs,\n+                            inLen, 0, out, (outOfs + k), (outLen - k));\n+                } else {\n@@ -626,4 +641,4 @@\n-                \/\/ update 'padBuffer' if using our own padding impl.\n-                if (paddingObj != null) {\n-                    bufferInputBytes(in, inOfs + inLen, newPadBufferLen);\n-                }\n+            }\n+            \/\/ update 'padBuffer' if using our own padding impl.\n+            if (paddingObj != null) {\n+                bufferInputBytes(in, inOfs + inLen, newPadBufferLen);\n@@ -690,27 +705,15 @@\n-            if (encrypt) {\n-                if (inAddr == 0 && inArray == null) {\n-                    inArray = new byte[inLen];\n-                    inBuffer.get(inArray);\n-                } else {\n-                    inBuffer.position(origPos + inLen);\n-                }\n-                k = token.p11.C_EncryptUpdate(session.id(),\n-                        inAddr, inArray, inOfs, inLen,\n-                        outAddr, outArray, outOfs, outLen);\n-            } else {\n-                int newPadBufferLen = 0;\n-                if (paddingObj != null) {\n-                    if (padBufferLen != 0) {\n-                        \/\/ NSS throws up when called with data not in multiple\n-                        \/\/ of blocks. Try to work around this by holding the\n-                        \/\/ extra data in padBuffer.\n-                        if (padBufferLen != padBuffer.length) {\n-                            int bufCapacity = padBuffer.length - padBufferLen;\n-                            if (inLen > bufCapacity) {\n-                                bufferInputBytes(inBuffer, bufCapacity);\n-                                inOfs += bufCapacity;\n-                                inLen -= bufCapacity;\n-                            } else {\n-                                bufferInputBytes(inBuffer, inLen);\n-                                return 0;\n-                            }\n+            int newPadBufferLen = 0;\n+            if (paddingObj != null) {\n+                if (padBufferLen != 0) {\n+                    \/\/ NSS throws up when called with data not in multiple\n+                    \/\/ of blocks. Try to work around this by holding the\n+                    \/\/ extra data in padBuffer.\n+                    if (padBufferLen != padBuffer.length) {\n+                        int bufCapacity = padBuffer.length - padBufferLen;\n+                        if (inLen > bufCapacity) {\n+                            bufferInputBytes(inBuffer, bufCapacity);\n+                            inOfs += bufCapacity;\n+                            inLen -= bufCapacity;\n+                        } else {\n+                            bufferInputBytes(inBuffer, inLen);\n+                            return 0;\n@@ -718,0 +721,6 @@\n+                    }\n+                    if (encrypt) {\n+                        k = token.p11.C_EncryptUpdate(session.id(), 0,\n+                                padBuffer, 0, padBufferLen, outAddr, outArray,\n+                                outOfs, outLen);\n+                    } else {\n@@ -721,5 +730,0 @@\n-                        padBufferLen = 0;\n-                    }\n-                    newPadBufferLen = inLen & (blockSize - 1);\n-                    if (newPadBufferLen == 0) {\n-                        newPadBufferLen = padBuffer.length;\n@@ -727,1 +731,1 @@\n-                    inLen -= newPadBufferLen;\n+                    padBufferLen = 0;\n@@ -729,7 +733,27 @@\n-                if (inLen > 0) {\n-                    if (inAddr == 0 && inArray == null) {\n-                        inArray = new byte[inLen];\n-                        inBuffer.get(inArray);\n-                    } else {\n-                        inBuffer.position(inBuffer.position() + inLen);\n-                    }\n+                newPadBufferLen = inLen & (blockSize - 1);\n+                if (!encrypt && newPadBufferLen == 0) {\n+                    \/\/ While decrypting with implUpdate, a block-sized buffer with\n+                    \/\/ encrypted data is always held instead of being unencrypted\n+                    \/\/ and returned to the caller. This is because the block may\n+                    \/\/ contain padding bytes, in case it's the last one (unknown\n+                    \/\/ at this point). In implDoFinal, where we know it's the\n+                    \/\/ last one, this buffer is unencrypted and unpadded before\n+                    \/\/ returned to the caller. None of this is necessary for\n+                    \/\/ encryption: encrypted data can be safely returned upon a\n+                    \/\/ implUpdate call.\n+                    newPadBufferLen = padBuffer.length;\n+                }\n+                inLen -= newPadBufferLen;\n+            }\n+            if (inLen > 0) {\n+                if (inAddr == 0 && inArray == null) {\n+                    inArray = new byte[inLen];\n+                    inBuffer.get(inArray);\n+                } else {\n+                    inBuffer.position(inBuffer.position() + inLen);\n+                }\n+                if (encrypt) {\n+                    k += token.p11.C_EncryptUpdate(session.id(), inAddr,\n+                            inArray, inOfs, inLen, outAddr, outArray,\n+                            (outOfs + k), (outLen - k));\n+                } else {\n@@ -740,4 +764,4 @@\n-                \/\/ update 'padBuffer' if using our own padding impl.\n-                if (paddingObj != null && newPadBufferLen != 0) {\n-                    bufferInputBytes(inBuffer, newPadBufferLen);\n-                }\n+            }\n+            \/\/ update 'padBuffer' if using our own padding impl.\n+            if (paddingObj != null && newPadBufferLen != 0) {\n+                bufferInputBytes(inBuffer, newPadBufferLen);\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11Cipher.java","additions":99,"deletions":75,"binary":false,"changes":174,"status":"modified"},{"patch":"@@ -0,0 +1,54 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8261355\n+ * @library \/test\/lib ..\n+ * @run main\/othervm EncryptionPadding\n+ *\/\n+\n+import java.nio.ByteBuffer;\n+import java.security.Provider;\n+import javax.crypto.Cipher;\n+import javax.crypto.spec.SecretKeySpec;\n+\n+public class EncryptionPadding extends PKCS11Test {\n+\n+    public static void main(String[] args) throws Exception {\n+        main(new EncryptionPadding(), args);\n+    }\n+\n+    @Override\n+    public void main(Provider p) throws Exception {\n+\n+        Cipher cipher = Cipher.getInstance(\"AES\/ECB\/PKCS5Padding\", p);\n+        cipher.init(Cipher.ENCRYPT_MODE,\n+                new SecretKeySpec(new byte[16], \"AES\"));\n+\n+        cipher.update(new byte[1], 0, 1);\n+        cipher.update(ByteBuffer.allocate(1), ByteBuffer.allocate(16));\n+\n+        System.out.println(\"TEST PASS - OK\");\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Cipher\/EncryptionPadding.java","additions":54,"deletions":0,"binary":false,"changes":54,"status":"added"}]}