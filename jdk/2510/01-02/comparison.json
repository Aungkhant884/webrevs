{"files":[{"patch":"@@ -173,4 +173,5 @@\n-    \/\/ updates during multi-part operations. This may be needed only if\n-    \/\/ padding is applied on the Java side. An example of the previous is when\n-    \/\/ the CKM_AES_ECB mechanism is used and the PKCS#11 library is NSS. See\n-    \/\/ more on JDK-8261355.\n+    \/\/ updates during multi-part operations. In such case, we buffer data in\n+    \/\/ padBuffer up to a block-size. This may be needed only if padding is\n+    \/\/ applied on the Java side. An example of the previous is when the\n+    \/\/ CKM_AES_ECB mechanism is used and the PKCS#11 library is NSS. See more\n+    \/\/ on JDK-8261355.\n@@ -604,3 +605,0 @@\n-                    \/\/ NSS throws up when called with data not in multiple\n-                    \/\/ of blocks. Try to work around this by holding the\n-                    \/\/ extra data in padBuffer.\n@@ -631,9 +629,5 @@\n-                    \/\/ While decrypting with implUpdate, a block-sized buffer with\n-                    \/\/ encrypted data is always held instead of being unencrypted\n-                    \/\/ and returned to the caller. This is because the block may\n-                    \/\/ contain padding bytes, in case it's the last one (unknown\n-                    \/\/ at this point). In implDoFinal, where we know it's the\n-                    \/\/ last one, this buffer is unencrypted and unpadded before\n-                    \/\/ returned to the caller. None of this is necessary for\n-                    \/\/ encryption: encrypted data can be safely returned upon a\n-                    \/\/ implUpdate call.\n+                    \/\/ While decrypting with implUpdate, the current encrypted block\n+                    \/\/ is always held in a buffer. If it's the last one (unknown\n+                    \/\/ at this point), it may contain padding bytes and need further\n+                    \/\/ processing. In implDoFinal (where we know it's the last one)\n+                    \/\/ the buffer is decrypted, unpadded and returned.\n@@ -654,1 +648,1 @@\n-            if (paddingObj != null) {\n+            if (paddingObj != null && newPadBufferLen > 0) {\n@@ -719,3 +713,0 @@\n-                    \/\/ NSS throws up when called with data not in multiple\n-                    \/\/ of blocks. Try to work around this by holding the\n-                    \/\/ extra data in padBuffer.\n@@ -746,9 +737,5 @@\n-                    \/\/ While decrypting with implUpdate, a block-sized buffer with\n-                    \/\/ encrypted data is always held instead of being unencrypted\n-                    \/\/ and returned to the caller. This is because the block may\n-                    \/\/ contain padding bytes, in case it's the last one (unknown\n-                    \/\/ at this point). In implDoFinal, where we know it's the\n-                    \/\/ last one, this buffer is unencrypted and unpadded before\n-                    \/\/ returned to the caller. None of this is necessary for\n-                    \/\/ encryption: encrypted data can be safely returned upon a\n-                    \/\/ implUpdate call.\n+                    \/\/ While decrypting with implUpdate, the current encrypted block\n+                    \/\/ is always held in a buffer. If it's the last one (unknown\n+                    \/\/ at this point), it may contain padding bytes and need further\n+                    \/\/ processing. In implDoFinal (where we know it's the last one)\n+                    \/\/ the buffer is decrypted, unpadded and returned.\n@@ -777,1 +764,1 @@\n-            if (paddingObj != null && newPadBufferLen != 0) {\n+            if (paddingObj != null && newPadBufferLen > 0) {\n@@ -819,5 +806,1 @@\n-                        startOff = bytesBuffered;\n-                        assert(startOff >= 0 &&\n-                                startOff < padBuffer.length);\n-                        assert(requiredOutLen - bytesBuffered +\n-                                startOff == padBuffer.length);\n+                        startOff = padBufferLen;\n@@ -909,0 +892,4 @@\n+                    int startOff = 0;\n+                    if (reqBlockUpdates) {\n+                        startOff = padBufferLen;\n+                    }\n@@ -910,1 +897,1 @@\n-                            0, requiredOutLen - bytesBuffered);\n+                            startOff, requiredOutLen - bytesBuffered);\n@@ -912,1 +899,1 @@\n-                            0, padBuffer, 0, actualPadLen,\n+                            0, padBuffer, 0, startOff + actualPadLen,\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11Cipher.java","additions":24,"deletions":37,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -68,1 +68,1 @@\n-        byte[] tmp = new byte[16];\n+        byte[] tmp;\n@@ -77,1 +77,1 @@\n-                if (tmp != null)\n+                if (tmp != null) {\n@@ -79,0 +79,1 @@\n+                }\n@@ -86,3 +87,8 @@\n-        tmp = sunPKCS11cipher.doFinal();\n-        if (tmp != null)\n-            cipherText.put(tmp);\n+        if (!isByteBuffer) {\n+            tmp = sunPKCS11cipher.doFinal();\n+            if (tmp != null) {\n+                cipherText.put(tmp);\n+            }\n+        } else {\n+            sunPKCS11cipher.doFinal(ByteBuffer.allocate(0), cipherText);\n+        }\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Cipher\/EncryptionPadding.java","additions":11,"deletions":5,"binary":false,"changes":16,"status":"modified"}]}