{"files":[{"patch":"@@ -1027,7 +1027,9 @@\n-  void set_rounding(int mode) {\n-    \/\/ fesetround is broken on windows\n-    NOT_WINDOWS(fesetround(mode);)\n-  }\n-\n-  void check_frequency(float f) {\n-    NOT_WINDOWS(assert(f <= 1 && f >= 0, \"Incorrect frequency\");)\n+  float check_and_truncate_frequency(float f) {\n+    assert(f >= 0, \"Incorrect frequency\");\n+    \/\/ We do not perform an exact (f <= 1) check\n+    \/\/ this would be error prone with rounding of floats.\n+    \/\/ Performing a check like (f <= 1+eps) would be of benefit,\n+    \/\/ however, it is not evident how to determine such an eps,\n+    \/\/ given that an arbitrary number of add\/mul operations\n+    \/\/ are performed on these frequencies.\n+    return (f > 1) ? 1 : f;\n@@ -1043,1 +1045,0 @@\n-    set_rounding(FE_TOWARDZERO); \/\/ make sure rounding doesn't push frequency above 1\n@@ -1070,1 +1071,0 @@\n-              set_rounding(FE_UPWARD);  \/\/ make sure rounding doesn't push frequency above 1\n@@ -1077,1 +1077,0 @@\n-              set_rounding(FE_TOWARDZERO);\n@@ -1097,1 +1096,1 @@\n-              check_frequency(this_exit_f);\n+              this_exit_f = check_and_truncate_frequency(this_exit_f);\n@@ -1099,1 +1098,1 @@\n-              check_frequency(f);\n+              f = check_and_truncate_frequency(f);\n@@ -1112,1 +1111,1 @@\n-              check_frequency(f);\n+              f = check_and_truncate_frequency(f);\n@@ -1120,1 +1119,1 @@\n-            check_frequency(f);\n+            f = check_and_truncate_frequency(f);\n@@ -1133,2 +1132,1 @@\n-          set_rounding(FE_TONEAREST);\n-          check_frequency(f);\n+          f = check_and_truncate_frequency(f);\n","filename":"src\/hotspot\/share\/opto\/loopPredicate.cpp","additions":14,"deletions":16,"binary":false,"changes":30,"status":"modified"}]}