{"files":[{"patch":"@@ -527,1 +527,1 @@\n-void ShenandoahControlThread::handle_alloc_failure(ShenandoahAllocRequest& req) {\n+void ShenandoahControlThread::handle_alloc_failure(ShenandoahAllocRequest& req, bool block) {\n@@ -542,3 +542,6 @@\n-  MonitorLocker ml(&_alloc_failure_waiters_lock);\n-  while (is_alloc_failure_gc()) {\n-    ml.wait();\n+\n+  if (block) {\n+    MonitorLocker ml(&_alloc_failure_waiters_lock);\n+    while (is_alloc_failure_gc()) {\n+      ml.wait();\n+    }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahControlThread.cpp","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -124,3 +124,5 @@\n-  \/\/ Handle allocation failure from normal allocation.\n-  \/\/ Blocks until memory is available.\n-  void handle_alloc_failure(ShenandoahAllocRequest& req);\n+  \/\/ Handle allocation failure from a mutator allocation.\n+  \/\/ Optionally blocks while collector is handling the failure. If the GC\n+  \/\/ threshold has been exceeded, the mutator allocation will not block so\n+  \/\/ that the out of memory error can be raised promptly.\n+  void handle_alloc_failure(ShenandoahAllocRequest& req, bool block = true);\n@@ -129,1 +131,0 @@\n-  \/\/ Optionally blocks while collector is handling the failure.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahControlThread.hpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -506,0 +506,1 @@\n+  _gc_no_progress_count(0),\n@@ -876,12 +877,35 @@\n-    \/\/ Allocation failed, block until control thread reacted, then retry allocation.\n-    \/\/\n-    \/\/ It might happen that one of the threads requesting allocation would unblock\n-    \/\/ way later after GC happened, only to fail the second allocation, because\n-    \/\/ other threads have already depleted the free storage. In this case, a better\n-    \/\/ strategy is to try again, as long as GC makes progress (or until at least\n-    \/\/ one full GC has completed).\n-    size_t original_count = shenandoah_policy()->full_gc_count();\n-    while (result == nullptr\n-        && (_progress_last_gc.is_set() || original_count == shenandoah_policy()->full_gc_count())) {\n-      control_thread()->handle_alloc_failure(req);\n-      result = allocate_memory_under_lock(req, in_new_region);\n+\n+    if (result == nullptr) {\n+      \/\/ Allocation failed.\n+\n+      \/\/ Check that gc overhead is not exceeded.\n+      \/\/\n+      \/\/ Shenandoah will grind along for quite a while allocating one\n+      \/\/ object at a time using shared (non-tlab) allocations. This check\n+      \/\/ is testing that the GC overhead limit has not been exceeded.\n+      \/\/ This will notify the collector to start a cycle, but will raise\n+      \/\/ an OOME to the mutator if the last Full GCs have not made progress.\n+      if (!req.is_lab_alloc() && get_gc_no_progress_count() > ShenandoahNoProgressThreshold) {\n+        control_thread()->handle_alloc_failure(req, false);\n+        return nullptr;\n+      }\n+\n+      \/\/ Block until control thread reacted, then retry allocation.\n+      \/\/\n+      \/\/ It might happen that one of the threads requesting allocation would unblock\n+      \/\/ way later after GC happened, only to fail the second allocation, because\n+      \/\/ other threads have already depleted the free storage. In this case, a better\n+      \/\/ strategy is to try again, as long as GC makes progress (or until at least\n+      \/\/ one full GC completes).\n+      size_t original_count = shenandoah_policy()->full_gc_count();\n+      while (result == nullptr\n+          && (get_gc_no_progress_count() == 0 || original_count == shenandoah_policy()->full_gc_count())) {\n+        control_thread()->handle_alloc_failure(req);\n+        result = allocate_memory_under_lock(req, in_new_region);\n+      }\n+\n+      if (log_is_enabled(Debug, gc, alloc)) {\n+        ResourceMark rm;\n+        log_debug(gc, alloc)(\"Thread: %s, Result: \" PTR_FORMAT \", Request: %s, Size: \" SIZE_FORMAT \", Original: \" SIZE_FORMAT \", Latest: \" SIZE_FORMAT,\n+                             Thread::current()->name(), p2i(result), req.type_string(), req.size(), original_count, get_gc_no_progress_count());\n+      }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":36,"deletions":12,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -290,1 +290,0 @@\n-  ShenandoahSharedFlag   _progress_last_gc;\n@@ -293,0 +292,2 @@\n+  size_t _gc_no_progress_count;\n+\n@@ -373,2 +374,3 @@\n-  void notify_gc_progress()    { _progress_last_gc.set();   }\n-  void notify_gc_no_progress() { _progress_last_gc.unset(); }\n+  void notify_gc_progress();\n+  void notify_gc_no_progress();\n+  size_t get_gc_no_progress_count() const;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -76,0 +76,12 @@\n+inline void ShenandoahHeap::notify_gc_progress() {\n+  Atomic::store(&_gc_no_progress_count, (size_t) 0);\n+\n+}\n+inline void ShenandoahHeap::notify_gc_no_progress() {\n+  Atomic::inc(&_gc_no_progress_count);\n+}\n+\n+inline size_t ShenandoahHeap::get_gc_no_progress_count() const {\n+  return Atomic::load(&_gc_no_progress_count);\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.inline.hpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -297,0 +297,5 @@\n+  product(uintx, ShenandoahNoProgressThreshold, 5, EXPERIMENTAL,            \\\n+          \"After this number of consecutive Full GCs fail to make \"         \\\n+          \"progress, Shenandoah will raise out of memory errors. Note \"     \\\n+          \"that progress is determined by ShenandoahCriticalFreeThreshold\") \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoah_globals.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -275,0 +275,1 @@\n+        public final boolean ShenandoahGCIsSelected;\n@@ -290,0 +291,2 @@\n+            val = testCaseBaseTargetClass.getValue(testCaseBaseTargetClass.fieldByName(\"ShenandoahGCIsSelected\"));\n+            ShenandoahGCIsSelected = ((PrimitiveValue) val).booleanValue();\n@@ -776,0 +779,1 @@\n+    public static final boolean ShenandoahGCIsSelected = GC.Shenandoah.isSelected();\n@@ -2453,2 +2457,2 @@\n-                \/\/ With ZGC the OOME is not always thrown as expected\n-                env.targetVMOptions.ZGCIsSelected ||\n+                \/\/ With ZGC or Shenandoah the OOME is not always thrown as expected\n+                env.targetVMOptions.ZGCIsSelected || env.targetVMOptions.ShenandoahGCIsSelected ||\n@@ -2498,2 +2502,2 @@\n-                \/\/ With ZGC the OOME is not always thrown as expected\n-                ZGCIsSelected ||\n+                \/\/ With ZGC or Shenandoah the OOME is not always thrown as expected\n+                ZGCIsSelected || ShenandoahGCIsSelected ||\n@@ -2551,2 +2555,2 @@\n-                \/\/ With ZGC the OOME is not always thrown as expected\n-                env.targetVMOptions.ZGCIsSelected ||\n+                \/\/ With ZGC or Shenandoah the OOME is not always thrown as expected\n+                env.targetVMOptions.ZGCIsSelected || env.targetVMOptions.ShenandoahGCIsSelected ||\n@@ -2612,2 +2616,2 @@\n-                \/\/ With ZGC the OOME is not always thrown as expected\n-                ZGCIsSelected ||\n+                \/\/ With ZGC or Shenandoah the OOME is not always thrown as expected\n+                ZGCIsSelected || ShenandoahGCIsSelected ||\n@@ -2818,2 +2822,2 @@\n-                \/\/ With ZGC the OOME is not always thrown as expected\n-                env.targetVMOptions.ZGCIsSelected ||\n+                \/\/ With ZGC or Shenandoah the OOME is not always thrown as expected\n+                env.targetVMOptions.ZGCIsSelected || env.targetVMOptions.ShenandoahGCIsSelected ||\n@@ -2880,2 +2884,2 @@\n-                \/\/ With ZGC the OOME is not always thrown as expected\n-                ZGCIsSelected ||\n+                \/\/ With ZGC or Shenandoah the OOME is not always thrown as expected\n+                ZGCIsSelected || ShenandoahGCIsSelected ||\n","filename":"test\/jdk\/com\/sun\/jdi\/EATests.java","additions":16,"deletions":12,"binary":false,"changes":28,"status":"modified"}]}