{"files":[{"patch":"@@ -527,1 +527,1 @@\n-void ShenandoahControlThread::handle_alloc_failure(ShenandoahAllocRequest& req) {\n+void ShenandoahControlThread::handle_alloc_failure(ShenandoahAllocRequest& req, bool block) {\n@@ -542,3 +542,6 @@\n-  MonitorLocker ml(&_alloc_failure_waiters_lock);\n-  while (is_alloc_failure_gc()) {\n-    ml.wait();\n+\n+  if (block) {\n+    MonitorLocker ml(&_alloc_failure_waiters_lock);\n+    while (is_alloc_failure_gc()) {\n+      ml.wait();\n+    }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahControlThread.cpp","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -125,2 +125,2 @@\n-  \/\/ Blocks until memory is available.\n-  void handle_alloc_failure(ShenandoahAllocRequest& req);\n+  \/\/ Optionally blocks while collector is handling the failure.\n+  void handle_alloc_failure(ShenandoahAllocRequest& req, bool block = true);\n@@ -129,1 +129,0 @@\n-  \/\/ Optionally blocks while collector is handling the failure.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahControlThread.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -506,0 +506,1 @@\n+  _no_gc_progress_count(0),\n@@ -883,3 +884,2 @@\n-    size_t original_count = shenandoah_policy()->full_gc_count();\n-    while (result == nullptr\n-        && (_progress_last_gc.is_set() || original_count == shenandoah_policy()->full_gc_count())) {\n+    size_t original_count = get_gc_no_progress_count() + 1;\n+    while (result == nullptr && original_count > get_gc_no_progress_count()) {\n@@ -889,0 +889,6 @@\n+\n+    if (log_is_enabled(Debug, gc, alloc)) {\n+      ResourceMark rm;\n+      log_debug(gc, alloc)(\"Thread: %s, Result: \" PTR_FORMAT \", Shared: %s, Size: \" SIZE_FORMAT \", Original: \" SIZE_FORMAT \", Latest: \" SIZE_FORMAT,\n+                           Thread::current()->name(), p2i(result), BOOL_TO_STR(!req.is_lab_alloc()), req.size(), original_count, get_gc_no_progress_count());\n+    }\n@@ -932,0 +938,1 @@\n+  *gc_overhead_limit_was_exceeded = false;\n@@ -933,0 +940,11 @@\n+  if (get_gc_no_progress_count() > ShenandoahNoProgressThreshold) {\n+    \/\/ Shenandoah will grind along for quite a while allocating one\n+    \/\/ object at a time using non-tlab allocations. This will notify\n+    \/\/ the collector to start a cycle, but will raise an OOME to the\n+    \/\/ mutator if the last Full GCs have not made progress.\n+    control_thread()->handle_alloc_failure(req, false);\n+    notify_gc_progress();\n+    *gc_overhead_limit_was_exceeded = true;\n+    return nullptr;\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":21,"deletions":3,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -290,1 +290,0 @@\n-  ShenandoahSharedFlag   _progress_last_gc;\n@@ -293,0 +292,2 @@\n+  size_t _no_gc_progress_count;\n+\n@@ -376,2 +377,3 @@\n-  void notify_gc_progress()    { _progress_last_gc.set();   }\n-  void notify_gc_no_progress() { _progress_last_gc.unset(); }\n+  void notify_gc_progress();\n+  void notify_gc_no_progress();\n+  size_t get_gc_no_progress_count() const;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -76,0 +76,12 @@\n+inline void ShenandoahHeap::notify_gc_progress() {\n+  Atomic::store(&_no_gc_progress_count, (size_t) 0);\n+\n+}\n+inline void ShenandoahHeap::notify_gc_no_progress() {\n+  Atomic::inc(&_no_gc_progress_count);\n+}\n+\n+inline size_t ShenandoahHeap::get_gc_no_progress_count() const {\n+  return Atomic::load(&_no_gc_progress_count);\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.inline.hpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -297,0 +297,5 @@\n+  product(uintx, ShenandoahNoProgressThreshold, 3, EXPERIMENTAL,            \\\n+          \"After this number of consecutive Full GCs fail to make \"         \\\n+          \"progress, Shenandoah will raise out of memory errors. Note \"     \\\n+          \"that progress is determined by ShenandoahCriticalFreeThreshold\") \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoah_globals.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"}]}