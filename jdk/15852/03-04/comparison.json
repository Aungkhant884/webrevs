{"files":[{"patch":"@@ -877,7 +877,1 @@\n-    \/\/ Allocation failed, block until control thread reacted, then retry allocation.\n-    \/\/\n-    \/\/ It might happen that one of the threads requesting allocation would unblock\n-    \/\/ way later after GC happened, only to fail the second allocation, because\n-    \/\/ other threads have already depleted the free storage. In this case, a better\n-    \/\/ strategy is to try again, as long as GC makes progress (or until at least\n-    \/\/ one full GC has completed).\n+\n@@ -885,10 +879,24 @@\n-      size_t original_count = get_gc_no_progress_count() + 1;\n-      while (result == nullptr && original_count > get_gc_no_progress_count()) {\n-        if (!req.is_lab_alloc() && get_gc_no_progress_count() > ShenandoahNoProgressThreshold) {\n-          \/\/ Shenandoah will grind along for quite a while allocating one\n-          \/\/ object at a time using shared (non-tlab) allocations. This will notify\n-          \/\/ the collector to start a cycle, but will raise an OOME to the\n-          \/\/ mutator if the last Full GCs have not made progress.\n-          control_thread()->handle_alloc_failure(req, false);\n-          break;\n-        }\n+      \/\/ Allocation failed.\n+\n+      \/\/ Check that gc overhead is not exceeded.\n+      \/\/\n+      \/\/ Shenandoah will grind along for quite a while allocating one\n+      \/\/ object at a time using shared (non-tlab) allocations. This check\n+      \/\/ is testing that the GC overhead limit has not been exceeded.\n+      \/\/ This will notify the collector to start a cycle, but will raise\n+      \/\/ an OOME to the mutator if the last Full GCs have not made progress.\n+      if (!req.is_lab_alloc() && get_gc_no_progress_count() > ShenandoahNoProgressThreshold) {\n+        control_thread()->handle_alloc_failure(req, false);\n+        return nullptr;\n+      }\n+\n+      \/\/ Block until control thread reacted, then retry allocation.\n+      \/\/\n+      \/\/ It might happen that one of the threads requesting allocation would unblock\n+      \/\/ way later after GC happened, only to fail the second allocation, because\n+      \/\/ other threads have already depleted the free storage. In this case, a better\n+      \/\/ strategy is to try again, as long as GC makes progress (or until at least\n+      \/\/ one full GC completes).\n+      size_t original_count = shenandoah_policy()->full_gc_count();\n+      while (result == nullptr\n+          && (get_gc_no_progress_count() == 0 || original_count == shenandoah_policy()->full_gc_count())) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":25,"deletions":17,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -274,1 +274,2 @@\n-        public final boolean ConcurrentGCIsSelected;\n+        public final boolean ZGCIsSelected;\n+        public final boolean ShenandoahGCIsSelected;\n@@ -288,2 +289,4 @@\n-            val = testCaseBaseTargetClass.getValue(testCaseBaseTargetClass.fieldByName(\"ConcurrentGCIsSelected\"));\n-            ConcurrentGCIsSelected = ((PrimitiveValue) val).booleanValue();\n+            val = testCaseBaseTargetClass.getValue(testCaseBaseTargetClass.fieldByName(\"ZGCIsSelected\"));\n+            ZGCIsSelected = ((PrimitiveValue) val).booleanValue();\n+            val = testCaseBaseTargetClass.getValue(testCaseBaseTargetClass.fieldByName(\"ShenandoahGCIsSelected\"));\n+            ShenandoahGCIsSelected = ((PrimitiveValue) val).booleanValue();\n@@ -775,1 +778,2 @@\n-    public static final boolean ConcurrentGCIsSelected = GC.Z.isSelected() || GC.Shenandoah.isSelected();\n+    public static final boolean ZGCIsSelected = GC.Z.isSelected();\n+    public static final boolean ShenandoahGCIsSelected = GC.Shenandoah.isSelected();\n@@ -2454,1 +2458,1 @@\n-                env.targetVMOptions.ConcurrentGCIsSelected ||\n+                env.targetVMOptions.ZGCIsSelected || env.targetVMOptions.ShenandoahGCIsSelected ||\n@@ -2499,1 +2503,1 @@\n-                ConcurrentGCIsSelected ||\n+                ZGCIsSelected || ShenandoahGCIsSelected ||\n@@ -2552,1 +2556,1 @@\n-                env.targetVMOptions.ConcurrentGCIsSelected ||\n+                env.targetVMOptions.ZGCIsSelected || env.targetVMOptions.ShenandoahGCIsSelected ||\n@@ -2613,1 +2617,1 @@\n-                ConcurrentGCIsSelected ||\n+                ZGCIsSelected || ShenandoahGCIsSelected ||\n@@ -2819,1 +2823,1 @@\n-                env.targetVMOptions.ConcurrentGCIsSelected ||\n+                env.targetVMOptions.ZGCIsSelected || env.targetVMOptions.ShenandoahGCIsSelected ||\n@@ -2881,1 +2885,1 @@\n-                ConcurrentGCIsSelected ||\n+                ZGCIsSelected || ShenandoahGCIsSelected ||\n","filename":"test\/jdk\/com\/sun\/jdi\/EATests.java","additions":14,"deletions":10,"binary":false,"changes":24,"status":"modified"}]}