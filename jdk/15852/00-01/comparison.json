{"files":[{"patch":"@@ -124,2 +124,4 @@\n-  \/\/ Handle allocation failure from normal allocation.\n-  \/\/ Optionally blocks while collector is handling the failure.\n+  \/\/ Handle allocation failure from a mutator allocation.\n+  \/\/ Optionally blocks while collector is handling the failure. If the GC\n+  \/\/ threshold has been exceeded, the mutator allocation will not block so\n+  \/\/ that the out of memory error can be raised promptly.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahControlThread.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -506,1 +506,1 @@\n-  _no_gc_progress_count(0),\n+  _gc_no_progress_count(0),\n@@ -877,0 +877,9 @@\n+    if (result == nullptr && !req.is_lab_alloc() && get_gc_no_progress_count() > ShenandoahNoProgressThreshold) {\n+      \/\/ Shenandoah will grind along for quite a while allocating one\n+      \/\/ object at a time using non-tlab allocations. This will notify\n+      \/\/ the collector to start a cycle, but will raise an OOME to the\n+      \/\/ mutator if the last Full GCs have not made progress.\n+      control_thread()->handle_alloc_failure(req, false);\n+      return nullptr;\n+    }\n+\n@@ -938,1 +947,0 @@\n-  *gc_overhead_limit_was_exceeded = false;\n@@ -940,11 +948,0 @@\n-  if (get_gc_no_progress_count() > ShenandoahNoProgressThreshold) {\n-    \/\/ Shenandoah will grind along for quite a while allocating one\n-    \/\/ object at a time using non-tlab allocations. This will notify\n-    \/\/ the collector to start a cycle, but will raise an OOME to the\n-    \/\/ mutator if the last Full GCs have not made progress.\n-    control_thread()->handle_alloc_failure(req, false);\n-    notify_gc_progress();\n-    *gc_overhead_limit_was_exceeded = true;\n-    return nullptr;\n-  }\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":10,"deletions":13,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -292,1 +292,1 @@\n-  size_t _no_gc_progress_count;\n+  size_t _gc_no_progress_count;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -77,1 +77,1 @@\n-  Atomic::store(&_no_gc_progress_count, (size_t) 0);\n+  Atomic::store(&_gc_no_progress_count, (size_t) 0);\n@@ -81,1 +81,1 @@\n-  Atomic::inc(&_no_gc_progress_count);\n+  Atomic::inc(&_gc_no_progress_count);\n@@ -85,1 +85,1 @@\n-  return Atomic::load(&_no_gc_progress_count);\n+  return Atomic::load(&_gc_no_progress_count);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.inline.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -297,1 +297,1 @@\n-  product(uintx, ShenandoahNoProgressThreshold, 3, EXPERIMENTAL,            \\\n+  product(uintx, ShenandoahNoProgressThreshold, 5, EXPERIMENTAL,            \\\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoah_globals.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -611,0 +611,5 @@\n+hotspot_oome = \\\n+  runtime\/reflect\/ReflectOutOfMemoryError.java \\\n+  gc\/InfiniteList.java \\\n+  runtime\/ClassInitErrors\/TestOutOfMemoryDuringInit.java\n+\n","filename":"test\/hotspot\/jtreg\/TEST.groups","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"}]}