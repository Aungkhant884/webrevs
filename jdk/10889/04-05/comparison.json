{"files":[{"patch":"@@ -0,0 +1,204 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.runtime;\n+\n+import java.lang.invoke.CallSite;\n+import java.lang.invoke.ConstantCallSite;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.template.ProcessorLinkage;\n+import java.lang.template.StringTemplate;\n+import java.lang.template.ValidatingProcessor;\n+import java.util.List;\n+import java.util.Objects;\n+\n+import jdk.internal.access.JavaUtilCollectionAccess;\n+import jdk.internal.access.SharedSecrets;\n+import jdk.internal.javac.PreviewFeature;\n+\n+\/**\n+ * Manages the template creation and bootstrapping.\n+ *\/\n+@PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n+public final class TemplateSupport {\n+    \/**\n+     * {@link MethodHandle} to {@link TemplateBootstrap#defaultProcess}.\n+     *\/\n+    private static final MethodHandle DEFAULT_PROCESS_MH;\n+\n+    \/**\n+     * {@link MethodHandles.Lookup} passed to the bootstrap method.\n+     *\/\n+    private final MethodHandles.Lookup lookup;\n+\n+    \/**\n+     * Name passed to the bootstrap method (\"process\").\n+     *\/\n+    private final String name;\n+\n+    \/**\n+     * {@link MethodType} passed to the bootstrap method.\n+     *\/\n+    private final MethodType type;\n+\n+    \/**\n+     * Fragments from string template.\n+     *\/\n+    private final List<String> fragments;\n+\n+    \/**\n+     * Static final processor.\n+     *\/\n+    private final ValidatingProcessor<?, ?> processor;\n+\n+    private static final JavaUtilCollectionAccess JUCA = SharedSecrets.getJavaUtilCollectionAccess();\n+\n+    \/**\n+     * Initialize {@link MethodHandle MethodHandles}.\n+     *\/\n+    static {\n+        try {\n+            MethodHandles.Lookup lookup = MethodHandles.lookup();\n+\n+            MethodType mt = MethodType.methodType(Object.class,\n+                    List.class, ValidatingProcessor.class, Object[].class);\n+            DEFAULT_PROCESS_MH = lookup.findStatic(TemplateSupport.class, \"defaultProcess\", mt);\n+        } catch (ReflectiveOperationException ex) {\n+            throw new AssertionError(\"string bootstrap fail\", ex);\n+        }\n+    }\n+\n+    \/**\n+     * Constructor.\n+     *\n+     * @param lookup    method lookup\n+     * @param name      method name\n+     * @param type      method type\n+     * @param fragments fragments from string template\n+     * @param processor static final processor\n+     *\/\n+    TemplateSupport(MethodHandles.Lookup lookup, String name, MethodType type,\n+                    List<String> fragments,\n+                    ValidatingProcessor<?, ?> processor) {\n+        this.lookup = lookup;\n+        this.name = name;\n+        this.type = type;\n+        this.fragments = fragments;\n+        this.processor = processor;\n+\n+    }\n+\n+    \/**\n+     * Templated string bootstrap method.\n+     *\n+     * @param lookup          method lookup\n+     * @param name            method name\n+     * @param type            method type\n+     * @param processorGetter {@link MethodHandle} to get static final processor\n+     * @param fragments       fragments from string template\n+     * @return {@link CallSite} to handle templated string processing\n+     * @throws NullPointerException if any of the arguments is null\n+     * @throws Throwable            if linkage fails\n+     *\/\n+    public static CallSite stringTemplateBSM(\n+            MethodHandles.Lookup lookup,\n+            String name,\n+            MethodType type,\n+            MethodHandle processorGetter,\n+            String... fragments) throws Throwable {\n+        Objects.requireNonNull(lookup, \"lookup is null\");\n+        Objects.requireNonNull(name, \"name is null\");\n+        Objects.requireNonNull(type, \"type is null\");\n+        Objects.requireNonNull(processorGetter, \"processorGetter is null\");\n+        Objects.requireNonNull(fragments, \"fragments is null\");\n+\n+        MethodType processorGetterType = MethodType.methodType(ValidatingProcessor.class);\n+        ValidatingProcessor<?, ?> processor =\n+                (ValidatingProcessor<?, ?>)processorGetter.asType(processorGetterType).invokeExact();\n+        TemplateSupport support = new TemplateSupport(lookup, name, type, List.of(fragments), processor);\n+\n+        return support.processWithProcessor();\n+    }\n+\n+    \/**\n+     * Create callsite to invoke specialized processor process method.\n+     *\n+     * @return {@link CallSite} for processing templated strings.\n+     * @throws Throwable if linkage fails\n+     *\/\n+    CallSite processWithProcessor() throws Throwable {\n+        MethodHandle mh = processor instanceof ProcessorLinkage processorLinkage ?\n+                processorLinkage.linkage(fragments, type) : defaultProcessMethodHandle();\n+\n+        return new ConstantCallSite(mh);\n+    }\n+\n+    \/**\n+     * Creates a simple {@link StringTemplate} and then invokes the processor's process method.\n+     *\n+     * @param fragments fragments from string template\n+     * @param processor {@link ValidatingProcessor} to process\n+     * @param values    array of expression values\n+     * @return\n+     *\/\n+    private static Object defaultProcess(List<String> fragments,\n+                                         ValidatingProcessor<Object, Throwable> processor,\n+                                         Object[] values) throws Throwable {\n+        return processor.process(\n+            StringTemplate.of(fragments, toList(values)));\n+    }\n+\n+    \/**\n+     * Generate a {@link MethodHandle} which is effectively invokes\n+     * {@code processor.process(new StringTemplate(fragments, values...)}.\n+     *\n+     * @return default process {@link MethodHandle}\n+     *\/\n+    private MethodHandle defaultProcessMethodHandle() {\n+        MethodHandle mh = MethodHandles.insertArguments(DEFAULT_PROCESS_MH, 0, fragments, processor);\n+        mh = mh.withVarargs(true);\n+        mh = mh.asType(type);\n+\n+        return mh;\n+    }\n+\n+    \/**\n+     * Collect nullable elements from an array into a unmodifiable list.\n+     *\n+     * @param elements  elements to place in list\n+     *\n+     * @return unmodifiable list.\n+     *\n+     * @param <E>  type of elements\n+     *\/\n+    @SuppressWarnings(\"unchecked\")\n+    public static <E> List<E> toList(E... elements) {\n+        return JUCA.listFromTrustedArrayNullsAllowed(elements);\n+    }\n+\n+}\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/TemplateSupport.java","additions":204,"deletions":0,"binary":false,"changes":204,"status":"added"},{"patch":"@@ -28,1 +28,4 @@\n-import java.lang.invoke.*;\n+import java.lang.invoke.CallSite;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n@@ -31,1 +34,4 @@\n-import java.util.*;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Objects;\n@@ -46,1 +52,1 @@\n-public final class TemplateRuntime {\n+final class TemplateRuntime {\n@@ -74,144 +80,0 @@\n-    \/**\n-     * Templated string bootstrap method.\n-     *\n-     * @param lookup          method lookup\n-     * @param name            method name\n-     * @param type            method type\n-     * @param processorGetter {@link MethodHandle} to get static final processor\n-     * @param fragments       fragments from string template\n-     * @return {@link CallSite} to handle templated string processing\n-     * @throws NullPointerException if any of the arguments is null\n-     * @throws Throwable            if linkage fails\n-     *\/\n-    public static CallSite stringTemplateBSM(\n-            MethodHandles.Lookup lookup,\n-            String name,\n-            MethodType type,\n-            MethodHandle processorGetter,\n-            String... fragments) throws Throwable {\n-        Objects.requireNonNull(lookup, \"lookup is null\");\n-        Objects.requireNonNull(name, \"name is null\");\n-        Objects.requireNonNull(type, \"type is null\");\n-        Objects.requireNonNull(processorGetter, \"processorGetter is null\");\n-        Objects.requireNonNull(fragments, \"fragments is null\");\n-\n-        MethodType processorGetterType = MethodType.methodType(ValidatingProcessor.class);\n-        ValidatingProcessor<?, ?> processor =\n-                (ValidatingProcessor<?, ?>)processorGetter.asType(processorGetterType).invokeExact();\n-        TemplateBootstrap bootstrap = new TemplateBootstrap(lookup, name, type, List.of(fragments), processor);\n-\n-        return bootstrap.processWithProcessor();\n-    }\n-\n-    \/**\n-     * Manages the boostrapping of {@link ProcessorLinkage} callsites.\n-     *\/\n-    private static final class TemplateBootstrap {\n-        \/**\n-         * {@link MethodHandle} to {@link TemplateBootstrap#defaultProcess}.\n-         *\/\n-        private static final MethodHandle DEFAULT_PROCESS_MH;\n-\n-        \/**\n-         * {@link MethodHandles.Lookup} passed to the bootstrap method.\n-         *\/\n-        private final MethodHandles.Lookup lookup;\n-\n-        \/**\n-         * Name passed to the bootstrap method (\"process\").\n-         *\/\n-        private final String name;\n-\n-        \/**\n-         * {@link MethodType} passed to the bootstrap method.\n-         *\/\n-        private final MethodType type;\n-\n-        \/**\n-         * Fragments from string template.\n-         *\/\n-        private final List<String> fragments;\n-\n-        \/**\n-         * Static final processor.\n-         *\/\n-        private final ValidatingProcessor<?, ?> processor;\n-\n-        \/**\n-         * Initialize {@link MethodHandle MethodHandles}.\n-         *\/\n-        static {\n-            try {\n-                MethodHandles.Lookup lookup = MethodHandles.lookup();\n-\n-                MethodType mt = MethodType.methodType(Object.class,\n-                        List.class, ValidatingProcessor.class, Object[].class);\n-                DEFAULT_PROCESS_MH = lookup.findStatic(TemplateBootstrap.class, \"defaultProcess\", mt);\n-            } catch (ReflectiveOperationException ex) {\n-                throw new AssertionError(\"string bootstrap fail\", ex);\n-            }\n-        }\n-\n-        \/**\n-         * Constructor.\n-         *\n-         * @param lookup    method lookup\n-         * @param name      method name\n-         * @param type      method type\n-         * @param fragments fragments from string template\n-         * @param processor static final processor\n-         *\/\n-        private TemplateBootstrap(MethodHandles.Lookup lookup, String name, MethodType type,\n-                                  List<String> fragments,\n-                                  ValidatingProcessor<?, ?> processor) {\n-            this.lookup = lookup;\n-            this.name = name;\n-            this.type = type;\n-            this.fragments = fragments;\n-            this.processor = processor;\n-\n-        }\n-\n-        \/**\n-         * Create callsite to invoke specialized processor process method.\n-         *\n-         * @return {@link CallSite} for processing templated strings.\n-         * @throws Throwable if linkage fails\n-         *\/\n-        private CallSite processWithProcessor() throws Throwable {\n-            MethodHandle mh = processor instanceof ProcessorLinkage processorLinkage ?\n-                    processorLinkage.linkage(fragments, type) : defaultProcessMethodHandle();\n-\n-            return new ConstantCallSite(mh);\n-        }\n-\n-        \/**\n-         * Creates a simple {@link StringTemplate} and then invokes the processor's process method.\n-         *\n-         * @param fragments fragments from string template\n-         * @param processor {@link ValidatingProcessor} to process\n-         * @param values    array of expression values\n-         * @return\n-         *\/\n-        private static Object defaultProcess(List<String> fragments,\n-                                             ValidatingProcessor<Object, Throwable> processor,\n-                                             Object[] values) throws Throwable {\n-            return processor.process(new SimpleStringTemplate(fragments, List.of(values)));\n-        }\n-\n-        \/**\n-         * Generate a {@link MethodHandle} which is effectively invokes\n-         * {@code processor.process(new StringTemplate(fragments, values...)}.\n-         *\n-         * @return default process {@link MethodHandle}\n-         *\/\n-        private MethodHandle defaultProcessMethodHandle() {\n-            MethodHandle mh = MethodHandles.insertArguments(DEFAULT_PROCESS_MH, 0, fragments, processor);\n-            mh = mh.withVarargs(true);\n-            mh = mh.asType(type);\n-\n-            return mh;\n-        }\n-\n-    }\n-\n@@ -232,3 +94,0 @@\n-     *\n-     * @implNote Intended for use by {@link StringTemplate} implementations.\n-     * Other usage may lead to undesired effects.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/template\/TemplateRuntime.java","additions":9,"deletions":150,"binary":false,"changes":159,"status":"modified"},{"patch":"@@ -239,1 +239,1 @@\n-    public final Type templateRuntimeType;\n+    public final Type templateSupportType;\n@@ -630,1 +630,1 @@\n-        templateRuntimeType = enterClass(\"java.lang.template.TemplateRuntime\");\n+        templateSupportType = enterClass(\"java.lang.runtime.TemplateSupport\");\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symtab.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -299,1 +299,1 @@\n-            JCMethodInvocation toListApplied = createApply(syms.templateRuntimeType, names.toList, list)\n+            JCMethodInvocation toListApplied = createApply(syms.templateSupportType, names.toList, list)\n@@ -497,1 +497,1 @@\n-                    syms.templateRuntimeType, bootstrapName, staticArgsTypes, List.nil());\n+                    syms.templateSupportType, bootstrapName, staticArgsTypes, List.nil());\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TransLiterals.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}