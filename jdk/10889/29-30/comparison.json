{"files":[{"patch":"@@ -31,1 +31,0 @@\n-import java.lang.invoke.MethodHandles.Lookup;\n@@ -35,4 +34,0 @@\n-import java.lang.template.ValidatingProcessor;\n-import java.util.List;\n-import java.util.Locale;\n-import java.util.Objects;\n@@ -40,1 +35,0 @@\n-import java.util.regex.Pattern;\n@@ -45,3 +39,4 @@\n- * This {@linkplain StringProcessor template processor} constructs a {@link String}\n- * result using {@link Formatter}. Unlike {@link Formatter}, {@link FormatProcessor} uses\n- * the value from the embedded expression that follows immediately after the\n+ * This {@link StringProcessor} constructs a {@link String} result using\n+ * {@link Formatter} specifications and values found in the {@link StringTemplate}.\n+ * Unlike {@link Formatter}, {@link FormatProcessor} uses the value from the\n+ * embedded expression that immediately follows, no whitespace, after the\n@@ -49,2 +44,1 @@\n- * StringTemplate expressions without a preceding specifier, use \"%s\" by\n- * default. Example:\n+ * For example:\n@@ -52,0 +46,1 @@\n+ * FormatProcessor fmt = new FormatProcessor(Locale.ROOT);\n@@ -54,1 +49,1 @@\n- * String result = FMT.\"%05d\\{x} + %05d\\{y} = %05d\\{x + y}\";\n+ * String result = fmt.\"%05d\\{x} + %05d\\{y} = %05d\\{x + y}\";\n@@ -56,9 +51,42 @@\n- * result is: <code>00010 + 00020 = 00030<\/code>\n- *\n- * @implNote When used in conjunction with a runtime instances of {@link\n- * StringTemplate} representing string templates this {@link StringProcessor}\n- * will use the format specifiers in the fragments and types of the values in\n- * the value list to produce a more performant formatter.\n- *\n- * @implSpec Since, values are found within the string template, argument indexing\n- * specifiers are unsupported.\n+ * In the above example, the value of {@code result} will be {@code \"00010 + 00020 = 00030\"}.\n+ * <p>\n+ * Embedded expressions without a preceeding format specifier, use {@code %s}\n+ * by default.\n+ * {@snippet :\n+ * FormatProcessor fmt = new FormatProcessor(Locale.ROOT);\n+ * int x = 10;\n+ * int y = 20;\n+ * String result1 = fmt.\"\\{x} + \\{y} = \\{x + y}\";\n+ * String result2 = fmt.\"%s\\{x} + %s\\{y} = %s\\{x + y}\";\n+ * }\n+ * In the above example, the value of {@code result1} and {@code result2} will\n+ * both be {@code \"10 + 20 = 30\"}.\n+ * <p>\n+ * {@link FormatProcessor}  format specification uses and exceptions are the same as\n+ * those of {@link Formatter}.\n+ * <p>\n+ * However, there are two significant differences related to the position of arguments.\n+ * An explict {@code n$} and relative {@code <} index will cause an exception due to\n+ * a missing argument list.\n+ * Whitespace appearing between the specification and the embedded expression will\n+ * also cause an exception.\n+ * <p>\n+ * {@link FormatProcessor} allows the use of different locales. For example:\n+ * {@snippet :\n+ * Locale locale = Locale.forLanguageTag(\"th-TH-u-nu-thai\");\n+ * FormatProcessor thaiFMT = new FormatProcessor(locale);\n+ * int x = 10;\n+ * int y = 20;\n+ * String result = thaiFMT.\"%d\\{x} + %d\\{y} = %d\\{x + y}\";\n+ * }\n+ * In the above example, the value of {@code result} will be\n+ * {@code \"\\u0E51\\u0E50 + \\u0E52\\u0E50 = \\u0E53\\u0E50\"}.\n+ * <p>\n+ * For day to day use, the predefined {@link FormatProcessor#FMT} {@link FormatProcessor}\n+ * is available. {@link FormatProcessor#FMT} is defined using the {@link Locale#ROOT}.\n+ * Example: {@snippet :\n+ * int x = 10;\n+ * int y = 20;\n+ * String result = FMT.\"0x%04x\\{x} + 0x%04x\\{y} = 0x%04x\\{x + y}\"; \/\/ @highlight substring=\"FMT\"\n+ * }\n+ * In the above example, the value of {@code result} will be {@code \"0x000a + 0x0014 = 0x001E\"}.\n@@ -67,0 +95,2 @@\n+ *\n+ * @see java.lang.template.StringProcessor\n@@ -85,1 +115,14 @@\n-     * {@inheritDoc}\n+     * Constructs a {@link String} based on the fragments, format\n+     * specifications found in the fragments and values in the\n+     * supplied {@link StringTemplate} object. This method constructs a\n+     * format string from the fragments, gathers up the values and\n+     * evaluates the expression\n+     * {@code new Formatter(locale).format(format, values).toString()}.\n+     * <p>\n+     * If an embedded expression is not immediately preceded by a\n+     * specifier then a {@code %s} is inserted in the format.\n+     *\n+     * @param stringTemplate  a {@link StringTemplate} instance\n+     *\n+     * @return constructed {@link String}\n+\n@@ -87,1 +130,1 @@\n-     *          If a format string contains an illegal syntax, a format\n+     *          If a format specifier contains an illegal syntax, a format\n@@ -89,2 +132,6 @@\n-     *          insufficient arguments given the format string, or other\n-     *          illegal conditions.\n+     *          a specifier not followed immediately by an embedded expression or\n+     *          other illegal conditions. For specification of all possible\n+     *          formatting errors, see the\n+     *          <a href=\"..\/util\/Formatter.html#detail\">details<\/a>\n+     *          section of the formatter class specification.\n+     *\n@@ -103,1 +150,21 @@\n-     * {@inheritDoc}\n+     * Constructs a {@link MethodHandle} that when supplied with the values from\n+     * a {@link StringTemplate} will produce a result equivalent to that provided by\n+     * {@link FormatProcessor#process(StringTemplate)}. This {@link MethodHandle}\n+     * is used by {@link FormatProcessor#FMT} and the ilk to perform a more\n+     * specialized composition of a result. This is specialization is done by\n+     * prescanning the fragments and value types of a {@link StringTemplate}.\n+     * <p>\n+     * Process template expressions can be specialized  when the processor is\n+     * of type {@link ProcessorLinkage} and fetched from a static constant as is\n+     * {@link FormatProcessor#FMT} ({@code static final FormatProcessor}).\n+     * <p>\n+     * Other {@link FormatProcessor} can be specialized if stored as static final.\n+     * For example:\n+     * {@snippet :\n+     * FormatProcessor THAI_FMT = new FormatProcessor(Locale.forLanguageTag(\"th-TH-u-nu-thai\"));\n+     * }\n+     * {@code THAI_FMT} will now produce specialized {@link MethodHandle MethodHandles} by way\n+     * of {@link FormatProcessor#linkage(List, MethodType)}.\n+     *\n+     * See {@link FormatProcessor#process(StringTemplate)} for more information.\n+     *\n@@ -105,1 +172,1 @@\n-     *          If a format string contains an illegal syntax, a format\n+     *          If a format specifier contains an illegal syntax, a format\n@@ -107,2 +174,6 @@\n-     *          insufficient arguments given the format string, or other\n-     *          illegal conditions.\n+     *          a specifier not followed immediately by an embedded expression or\n+     *          other illegal conditions. For specification of all possible\n+     *          formatting errors, see the\n+     *          <a href=\"..\/util\/Formatter.html#detail\">details<\/a>\n+     *          section of the formatter class specification.\n+     *\n@@ -123,6 +194,0 @@\n-    \/\/ %[argument_index$][flags][width][.precision][t]conversion\n-    private static final String FORMAT_SPECIFIER\n-            = \"%(\\\\d+\\\\$)?([-#+ 0,(\\\\<]*)?(\\\\d+)?(\\\\.\\\\d+)?([tT])?([a-zA-Z%])\";\n-\n-    private static final Pattern FORMAT_SPECIFIER_PATTERN = Pattern.compile(FORMAT_SPECIFIER);\n-\n@@ -140,1 +205,1 @@\n-        Matcher matcher = FORMAT_SPECIFIER_PATTERN.matcher(fragment);\n+        Matcher matcher = Formatter.FORMAT_SPECIFIER_PATTERN.matcher(fragment);\n@@ -151,1 +216,2 @@\n-                throw new MissingFormatArgumentException(group);\n+                throw new MissingFormatArgumentException(group +\n+                        \" is not immediately followed by an embedded expression\");\n@@ -191,5 +257,2 @@\n-     * This predefined FormatProcessor instance constructs a String result using {@link\n-     * Formatter}. Unlike {@link Formatter}, FormatProcessor uses the value from\n-     * the embedded expression that follows immediately after the\n-     * <a href=\"..\/..\/util\/Formatter.html#syntax\">format specifier<\/a>.\n-     * StringTemplate expressions without a preceeding specifier, use \"%s\" by\n+     * This predefined {@link FormatProcessor} instance constructs a {@link String} result using\n+     * the Locale.ROOT {@link Locale}. See {@link FormatProcessor} for more details.\n@@ -197,3 +260,3 @@\n-     * int x = 123;\n-     * int y = 987;\n-     * String result = FMT.\"%3d\\{x} + %3d\\{y} = %4d\\{x + y}\"; \/\/ @highlight substring=\"FMT\"\n+     * int x = 10;\n+     * int y = 20;\n+     * String result = FMT.\"0x%04x\\{x} + 0x%04x\\{y} = 0x%04x\\{x + y}\"; \/\/ @highlight substring=\"FMT\"\n@@ -201,1 +264,3 @@\n-     * {@link FMT} uses the Locale.ROOT {@link Locale}.\n+     * In the above example, the value of {@code result} will be {@code \"0x000a + 0x0014 = 0x001E\"}.\n+     *\n+     * @see java.util.FormatProcessor\n","filename":"src\/java.base\/share\/classes\/java\/util\/FormatProcessor.java","additions":111,"deletions":46,"binary":false,"changes":157,"status":"modified"},{"patch":"@@ -2799,1 +2799,1 @@\n-    private static final String formatSpecifier\n+    static final String FORMAT_SPECIFIER\n@@ -2802,1 +2802,1 @@\n-    private static final Pattern fsPattern = Pattern.compile(formatSpecifier);\n+    static final Pattern FORMAT_SPECIFIER_PATTERN = Pattern.compile(FORMAT_SPECIFIER);\n@@ -2835,1 +2835,1 @@\n-                    m = fsPattern.matcher(s);\n+                    m = FORMAT_SPECIFIER_PATTERN.matcher(s);\n","filename":"src\/java.base\/share\/classes\/java\/util\/Formatter.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -450,1 +450,1 @@\n-                    throw new MissingFormatArgumentException(fs.toString());\n+                    throw new IllegalFormatFlagsException(\"Indexing not allowed: \" + fs.toString());\n","filename":"src\/java.base\/share\/classes\/java\/util\/FormatterBuilder.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}