{"files":[{"patch":"@@ -1,230 +1,230 @@\n-\/*\r\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\r\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\r\n- *\r\n- * This code is free software; you can redistribute it and\/or modify it\r\n- * under the terms of the GNU General Public License version 2 only, as\r\n- * published by the Free Software Foundation.  Oracle designates this\r\n- * particular file as subject to the \"Classpath\" exception as provided\r\n- * by Oracle in the LICENSE file that accompanied this code.\r\n- *\r\n- * This code is distributed in the hope that it will be useful, but WITHOUT\r\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\r\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\r\n- * version 2 for more details (a copy is included in the LICENSE file that\r\n- * accompanied this code).\r\n- *\r\n- * You should have received a copy of the GNU General Public License version\r\n- * 2 along with this work; if not, write to the Free Software Foundation,\r\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\r\n- *\r\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\r\n- * or visit www.oracle.com if you need additional information or have any\r\n- * questions.\r\n- *\/\r\n-\r\n-package java.lang.template;\r\n-\r\n-import java.lang.ref.Reference;\r\n-import java.lang.ref.ReferenceQueue;\r\n-import java.lang.ref.SoftReference;\r\n-import java.lang.ref.WeakReference;\r\n-import java.util.Objects;\r\n-\r\n-import jdk.internal.javac.PreviewFeature;\r\n-\r\n-\/**\r\n- * View\/wrapper of keys used by the backing {@link ReferencedKeyMap}.\r\n- * There are two style of keys; one for entries in the backing map and\r\n- * one for queries to the backing map. This second style avoids the\r\n- * overhead of a {@link Reference} object.\r\n- *\r\n- * @param <T> key type\r\n- *\r\n- * @since 20\r\n- *\/\r\n-@PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\r\n-interface ReferenceKey<T> {\r\n-    \/**\r\n-     * {@return the value of the unwrapped key.}\r\n-     *\/\r\n-    T get();\r\n-\r\n-    \/**\r\n-     * Cleanup unused key.\r\n-     *\/\r\n-    void unused();\r\n-\r\n-    \/**\r\n-     * {@link WeakReference} wrapper key for entries in the backing map.\r\n-     *\r\n-     * @param <T> key type\r\n-     *\r\n-     * @since 20\r\n-     *\/\r\n-    class WeakKey<T> extends WeakReference<T> implements ReferenceKey<T> {\r\n-        \/**\r\n-         * Saved hashcode of the key. Used when {@link WeakReference} is\r\n-         * null.\r\n-         *\/\r\n-        int hashcode;\r\n-\r\n-        \/**\r\n-         * Private constructor.\r\n-         *\r\n-         * @param key   unwrapped key value\r\n-         * @param queue reference queue\r\n-         *\/\r\n-        WeakKey(T key, ReferenceQueue<T> queue) {\r\n-            super(key, queue);\r\n-            this.hashcode = Objects.hashCode(key);\r\n-        }\r\n-\r\n-        \/**\r\n-         * Cleanup unused key. No need to enqueue since the key did not make it\r\n-         * into the map.\r\n-         *\/\r\n-        @Override\r\n-        public void unused() {\r\n-            clear();\r\n-        }\r\n-\r\n-        @Override\r\n-        public boolean equals(Object obj) {\r\n-            \/\/ Necessary when removing a null reference\r\n-            if (obj == this) {\r\n-                return true;\r\n-            }\r\n-            \/\/ Necessary when comparing an unwrapped key\r\n-            if (obj instanceof ReferenceKey<?> key) {\r\n-                obj = key.get();\r\n-            }\r\n-            return Objects.equals(get(), obj);\r\n-        }\r\n-\r\n-        @Override\r\n-        public int hashCode() {\r\n-            \/\/ Use saved hashcode\r\n-            return hashcode;\r\n-        }\r\n-\r\n-        @Override\r\n-        public String toString() {\r\n-            return \"java.util.WeakKey#\" + System.identityHashCode(this);\r\n-        }\r\n-    }\r\n-\r\n-    \/**\r\n-     * {@link SoftReference} wrapper key for entries in the backing map.\r\n-     *\r\n-     * @param <T> key type\r\n-     *\r\n-     * @since 20\r\n-     *\/\r\n-    class SoftKey<T> extends SoftReference<T> implements ReferenceKey<T> {\r\n-        \/**\r\n-         * Saved hashcode of the key. Used when {@link SoftReference} is\r\n-         * null.\r\n-         *\/\r\n-        int hashcode;\r\n-\r\n-        \/**\r\n-         * Private constructor.\r\n-         *\r\n-         * @param key   unwrapped key value\r\n-         * @param queue reference queue\r\n-         *\/\r\n-        SoftKey(T key, ReferenceQueue<T> queue) {\r\n-            super(key, queue);\r\n-            this.hashcode = Objects.hashCode(key);\r\n-        }\r\n-\r\n-        \/**\r\n-         * Cleanup unused key. No need to enqueue since the key did not make it\r\n-         * into the map.\r\n-         *\/\r\n-        @Override\r\n-        public void unused() {\r\n-            clear();\r\n-        }\r\n-\r\n-        @Override\r\n-        public boolean equals(Object obj) {\r\n-            \/\/ Necessary when removing a null reference\r\n-            if (obj == this) {\r\n-                return true;\r\n-            }\r\n-            \/\/ Necessary when comparing an unwrapped key\r\n-            if (obj instanceof ReferenceKey<?> key) {\r\n-                obj = key.get();\r\n-            }\r\n-            return Objects.equals(get(), obj);\r\n-        }\r\n-\r\n-        @Override\r\n-        public int hashCode() {\r\n-            \/\/ Use saved hashcode\r\n-            return hashcode;\r\n-        }\r\n-\r\n-        @Override\r\n-        public String toString() {\r\n-            return \"java.util.SoftKey#\" + System.identityHashCode(this);\r\n-        }\r\n-    }\r\n-\r\n-    \/**\r\n-     * Wrapper for querying the backing map. Avoids the overhead of an\r\n-     * {@link Reference} object.\r\n-     *\r\n-     * @param <T> key type\r\n-     *\r\n-     * @since 20\r\n-     *\/\r\n-    class StrongKey<T> implements ReferenceKey<T> {\r\n-        T key;\r\n-\r\n-        \/**\r\n-         * Private constructor.\r\n-         *\r\n-         * @param key unwrapped key value\r\n-         *\/\r\n-        StrongKey(T key) {\r\n-            this.key = key;\r\n-        }\r\n-\r\n-        \/**\r\n-         * {@return the unwrapped key}\r\n-         *\/\r\n-        @Override\r\n-        public T get() {\r\n-            return key;\r\n-        }\r\n-\r\n-        @Override\r\n-        public void unused() {\r\n-            key = null;\r\n-        }\r\n-\r\n-        @Override\r\n-        public boolean equals(Object obj) {\r\n-            \/\/ Necessary when comparing an unwrapped key\r\n-            if (obj instanceof ReferenceKey<?> key) {\r\n-                obj = key.get();\r\n-            }\r\n-            return Objects.equals(get(), obj);\r\n-        }\r\n-\r\n-        @Override\r\n-        public int hashCode() {\r\n-            \/\/ Use unwrapped key hash code\r\n-            return get().hashCode();\r\n-        }\r\n-\r\n-        @Override\r\n-        public String toString() {\r\n-            return \"java.util.StrongKey#\" + System.identityHashCode(this);\r\n-        }\r\n-    }\r\n-\r\n-}\r\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.template;\n+\n+import java.lang.ref.Reference;\n+import java.lang.ref.ReferenceQueue;\n+import java.lang.ref.SoftReference;\n+import java.lang.ref.WeakReference;\n+import java.util.Objects;\n+\n+import jdk.internal.javac.PreviewFeature;\n+\n+\/**\n+ * View\/wrapper of keys used by the backing {@link ReferencedKeyMap}.\n+ * There are two style of keys; one for entries in the backing map and\n+ * one for queries to the backing map. This second style avoids the\n+ * overhead of a {@link Reference} object.\n+ *\n+ * @param <T> key type\n+ *\n+ * @since 20\n+ *\/\n+@PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n+interface ReferenceKey<T> {\n+    \/**\n+     * {@return the value of the unwrapped key.}\n+     *\/\n+    T get();\n+\n+    \/**\n+     * Cleanup unused key.\n+     *\/\n+    void unused();\n+\n+    \/**\n+     * {@link WeakReference} wrapper key for entries in the backing map.\n+     *\n+     * @param <T> key type\n+     *\n+     * @since 20\n+     *\/\n+    class WeakKey<T> extends WeakReference<T> implements ReferenceKey<T> {\n+        \/**\n+         * Saved hashcode of the key. Used when {@link WeakReference} is\n+         * null.\n+         *\/\n+        int hashcode;\n+\n+        \/**\n+         * Private constructor.\n+         *\n+         * @param key   unwrapped key value\n+         * @param queue reference queue\n+         *\/\n+        WeakKey(T key, ReferenceQueue<T> queue) {\n+            super(key, queue);\n+            this.hashcode = Objects.hashCode(key);\n+        }\n+\n+        \/**\n+         * Cleanup unused key. No need to enqueue since the key did not make it\n+         * into the map.\n+         *\/\n+        @Override\n+        public void unused() {\n+            clear();\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            \/\/ Necessary when removing a null reference\n+            if (obj == this) {\n+                return true;\n+            }\n+            \/\/ Necessary when comparing an unwrapped key\n+            if (obj instanceof ReferenceKey<?> key) {\n+                obj = key.get();\n+            }\n+            return Objects.equals(get(), obj);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            \/\/ Use saved hashcode\n+            return hashcode;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"java.util.WeakKey#\" + System.identityHashCode(this);\n+        }\n+    }\n+\n+    \/**\n+     * {@link SoftReference} wrapper key for entries in the backing map.\n+     *\n+     * @param <T> key type\n+     *\n+     * @since 20\n+     *\/\n+    class SoftKey<T> extends SoftReference<T> implements ReferenceKey<T> {\n+        \/**\n+         * Saved hashcode of the key. Used when {@link SoftReference} is\n+         * null.\n+         *\/\n+        int hashcode;\n+\n+        \/**\n+         * Private constructor.\n+         *\n+         * @param key   unwrapped key value\n+         * @param queue reference queue\n+         *\/\n+        SoftKey(T key, ReferenceQueue<T> queue) {\n+            super(key, queue);\n+            this.hashcode = Objects.hashCode(key);\n+        }\n+\n+        \/**\n+         * Cleanup unused key. No need to enqueue since the key did not make it\n+         * into the map.\n+         *\/\n+        @Override\n+        public void unused() {\n+            clear();\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            \/\/ Necessary when removing a null reference\n+            if (obj == this) {\n+                return true;\n+            }\n+            \/\/ Necessary when comparing an unwrapped key\n+            if (obj instanceof ReferenceKey<?> key) {\n+                obj = key.get();\n+            }\n+            return Objects.equals(get(), obj);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            \/\/ Use saved hashcode\n+            return hashcode;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"java.util.SoftKey#\" + System.identityHashCode(this);\n+        }\n+    }\n+\n+    \/**\n+     * Wrapper for querying the backing map. Avoids the overhead of an\n+     * {@link Reference} object.\n+     *\n+     * @param <T> key type\n+     *\n+     * @since 20\n+     *\/\n+    class StrongKey<T> implements ReferenceKey<T> {\n+        T key;\n+\n+        \/**\n+         * Private constructor.\n+         *\n+         * @param key unwrapped key value\n+         *\/\n+        StrongKey(T key) {\n+            this.key = key;\n+        }\n+\n+        \/**\n+         * {@return the unwrapped key}\n+         *\/\n+        @Override\n+        public T get() {\n+            return key;\n+        }\n+\n+        @Override\n+        public void unused() {\n+            key = null;\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            \/\/ Necessary when comparing an unwrapped key\n+            if (obj instanceof ReferenceKey<?> key) {\n+                obj = key.get();\n+            }\n+            return Objects.equals(get(), obj);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            \/\/ Use unwrapped key hash code\n+            return get().hashCode();\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"java.util.StrongKey#\" + System.identityHashCode(this);\n+        }\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/template\/ReferenceKey.java","additions":230,"deletions":230,"binary":false,"changes":460,"status":"modified"}]}