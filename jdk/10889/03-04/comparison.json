{"files":[{"patch":"@@ -32,1 +32,2 @@\n-import java.util.*;\n+import java.util.Arrays;\n+import java.util.Spliterator;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/AbstractStringBuilder.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -36,1 +36,5 @@\n-import java.util.*;\n+import java.util.ArrayList;\n+import java.util.FormatConcatItem;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Objects;\n@@ -496,1 +500,1 @@\n-            ptypes[i] = promoteIntType(ptypes[i]);\n+            ptypes[i] = promoteToIntType(ptypes[i]);\n@@ -999,1 +1003,1 @@\n-    private static Class<?> promoteIntType(Class<?> t) {\n+    private static Class<?> promoteToIntType(Class<?> t) {\n@@ -1062,0 +1066,1 @@\n+        ptypes = List.copyOf(ptypes);\n@@ -1086,1 +1091,1 @@\n-            Class<?> ttype = isSpecialized ? promoteIntType(ptype) :\n+            Class<?> ttype = isSpecialized ? promoteToIntType(ptype) :\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/StringConcatFactory.java","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -1,38 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package java.lang.template;\n-\n-import java.util.List;\n-\n-\/**\n- * Generic StringTemplate.\n- *\n- * @param fragments  immutable list of string fragments from string template\n- * @param values     immutable list of expression values\n- *\/\n-record SimpleStringTemplate(List<String> fragments,\n-                             List<Object> values\n-) implements StringTemplate {}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/template\/SimpleStringTemplate.java","additions":0,"deletions":38,"binary":false,"changes":38,"status":"deleted"},{"patch":"@@ -29,1 +29,0 @@\n-import java.util.*;\n@@ -31,0 +30,4 @@\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n@@ -100,1 +103,1 @@\n- * String result = TemplateRuntime.interpolate(fragments, values);;\n+ * String result = StringTemplate.interpolate(fragments, values);;\n@@ -150,1 +153,1 @@\n-        return TemplateRuntime.interpolate(fragments(), values());\n+        return StringTemplate.interpolate(fragments(), values());\n@@ -175,1 +178,2 @@\n-    default <R, E extends Throwable> R process(ValidatingProcessor<R, E> processor) throws E {\n+    default <R, E extends Throwable> R\n+    process(ValidatingProcessor<? extends R, ? extends E> processor) throws E {\n@@ -190,1 +194,1 @@\n-    default public List<Class<?>> valueTypes() {\n+    default List<Class<?>> valueTypes() {\n@@ -204,2 +208,2 @@\n-    default public List<MethodHandle> valueGetters() {\n-        return TemplateRuntime.valueGetters(this);\n+    default List<MethodHandle> valueAccessors() {\n+        return TemplateRuntime.valueAccessors(this);\n@@ -277,1 +281,1 @@\n-        return new SimpleStringTemplate(List.of(string), List.of());\n+        return new TemplateRuntime.SimpleStringTemplate(List.of(string), List.of());\n@@ -304,6 +308,3 @@\n-        for (String fragment : fragments) {\n-            Objects.requireNonNull(fragment, \"fragments elements must be non-null\");\n-        }\n-        fragments = Collections.unmodifiableList(new ArrayList<>(fragments));\n-        values = Collections.unmodifiableList(new ArrayList<>(values));\n-        return new SimpleStringTemplate(fragments, values);\n+        fragments = List.copyOf(fragments);\n+        values = TemplateRuntime.toList(values.toArray());\n+        return new TemplateRuntime.SimpleStringTemplate(fragments, values);\n@@ -324,1 +325,8 @@\n-        return TemplateRuntime.interpolate(fragments, values);\n+        Objects.requireNonNull(fragments, \"fragments must not be null\");\n+        Objects.requireNonNull(values, \"values must not be null\");\n+        int fragmentsSize = fragments.size();\n+        int valuesSize = values.size();\n+        if (fragmentsSize != valuesSize + 1) {\n+            throw new RuntimeException(\"fragments must have one more element than values\");\n+        }\n+        return TemplateRuntime.interpolate(List.copyOf(fragments), TemplateRuntime.toList(values.toArray()));\n@@ -354,1 +362,1 @@\n-    public static final StringProcessor STR = st -> st.interpolate();\n+    public static final StringProcessor STR = StringTemplate::interpolate;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/template\/StringTemplate.java","additions":24,"deletions":16,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import jdk.internal.access.JavaUtilCollectionAccess;\n@@ -46,0 +47,20 @@\n+\n+    \/**\n+     * {@link MethodHandle} to {@link TemplateRuntime#getValue(int, StringTemplate)}.\n+     *\/\n+    private static final MethodHandle GET_VALUE_MH;\n+\n+    \/**\n+     * Initialize {@link MethodHandle MethodHandles}.\n+     *\/\n+    static {\n+        try {\n+            MethodHandles.Lookup lookup = MethodHandles.lookup();\n+\n+            MethodType mt = MethodType.methodType(Object.class, int.class, StringTemplate.class);\n+            GET_VALUE_MH = lookup.findStatic(TemplateRuntime.class, \"getValue\", mt);\n+        } catch (ReflectiveOperationException | SecurityException ex) {\n+            throw new AssertionError(\"template runtime init fail\", ex);\n+        }\n+    }\n+\n@@ -78,2 +99,2 @@\n-        ValidatingProcessor<?, ? extends Throwable> processor =\n-                (ValidatingProcessor<?, ? extends Throwable>)processorGetter.asType(processorGetterType).invokeExact();\n+        ValidatingProcessor<?, ?> processor =\n+                (ValidatingProcessor<?, ?>)processorGetter.asType(processorGetterType).invokeExact();\n@@ -88,1 +109,1 @@\n-    private static class TemplateBootstrap {\n+    private static final class TemplateBootstrap {\n@@ -117,1 +138,1 @@\n-        private final ValidatingProcessor<?, ? extends Throwable> processor;\n+        private final ValidatingProcessor<?, ?> processor;\n@@ -130,1 +151,1 @@\n-                throw new AssertionError(\"templated string bootstrap fail\", ex);\n+                throw new AssertionError(\"string bootstrap fail\", ex);\n@@ -145,1 +166,1 @@\n-                                  ValidatingProcessor<?, ? extends Throwable> processor) {\n+                                  ValidatingProcessor<?, ?> processor) {\n@@ -197,0 +218,6 @@\n+    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();\n+\n+    private static final JavaLangInvokeAccess JLIA = SharedSecrets.getJavaLangInvokeAccess();\n+\n+    private static final JavaUtilCollectionAccess JUCA = SharedSecrets.getJavaUtilCollectionAccess();\n+\n@@ -211,1 +238,1 @@\n-        return Collections.unmodifiableList(Arrays.asList(elements));\n+        return JUCA.listFromTrustedArrayNullsAllowed(elements);\n@@ -214,4 +241,0 @@\n-    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();\n-\n-    private static final JavaLangInvokeAccess JLIA = SharedSecrets.getJavaLangInvokeAccess();\n-\n@@ -269,1 +292,1 @@\n-    static List<MethodHandle> valueGetters(StringTemplate st) {\n+    static List<MethodHandle> valueAccessors(StringTemplate st) {\n@@ -277,1 +300,3 @@\n-                    result.add(JLIA.unreflectField(field, false));\n+                    MethodHandle mh = JLIA.unreflectField(field, false);\n+                    mh = mh.asType(mh.type().changeParameterType(0, StringTemplate.class));\n+                    result.add(mh);\n@@ -288,3 +313,0 @@\n-            MethodHandles.Lookup lookup = MethodHandles.lookup();\n-            MethodHandle getter = lookup.findStatic(TemplateRuntime.class, \"getValue\",\n-                MethodType.methodType(Object.class, int.class, StringTemplate.class));\n@@ -293,1 +315,1 @@\n-                result.add(MethodHandles.insertArguments(getter, 0, index));\n+                result.add(MethodHandles.insertArguments(GET_VALUE_MH, 0, index));\n@@ -296,1 +318,1 @@\n-        } catch (ReflectiveOperationException | SecurityException ex) {\n+        } catch (SecurityException ex) {\n@@ -302,1 +324,1 @@\n-     * Private ethod used by {@link TemplateRuntime#valueGetters(StringTemplate)}\n+     * Private method used by {@link TemplateRuntime#valueAccessors(StringTemplate)}\n@@ -314,0 +336,10 @@\n+    \/**\n+     * Generic StringTemplate.\n+     *\n+     * @param fragments  immutable list of string fragments from string template\n+     * @param values     immutable list of expression values\n+     *\/\n+    record SimpleStringTemplate(List<String> fragments,\n+                                 List<Object> values\n+    ) implements StringTemplate {}\n+\n@@ -322,2 +354,0 @@\n-     *\n-     * @throws NullPointerException fragments or values is null or if any of the fragments is null\n@@ -326,2 +356,0 @@\n-        Objects.requireNonNull(fragments, \"fragments must not be null\");\n-        Objects.requireNonNull(values, \"values must not be null\");\n@@ -330,3 +358,0 @@\n-        if (fragmentsSize != valuesSize + 1) {\n-            throw new RuntimeException(\"fragments must have one more element than values\");\n-        }\n@@ -334,1 +359,0 @@\n-            String fragment = Objects.requireNonNull(fragments.get(0), \"fragments must not have null elements\");\n@@ -342,1 +366,1 @@\n-            strings[i++] = Objects.requireNonNull(fragmentsIter.next(), \"fragments must not have null elements\");\n+            strings[i++] = fragmentsIter.next();\n@@ -345,1 +369,1 @@\n-        strings[i++] = Objects.requireNonNull(fragmentsIter.next(), \"fragments must not have null elements\");\n+        strings[i++] = fragmentsIter.next();\n@@ -389,1 +413,1 @@\n-        return new SimpleStringTemplate(java.lang.template.TemplateRuntime.toList(fragments), java.lang.template.TemplateRuntime.toList(values));\n+        return new SimpleStringTemplate(TemplateRuntime.toList(fragments), TemplateRuntime.toList(values));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/template\/TemplateRuntime.java","additions":54,"deletions":30,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -196,1 +196,1 @@\n-     * {@link FMT} uses the Locale.US {@link Locale}.\n+     * {@link FMT} uses the Locale.ROOT {@link Locale}.\n@@ -198,1 +198,1 @@\n-    public static final FormatProcessor FMT = new FormatProcessor(Locale.US);\n+    public static final FormatProcessor FMT = new FormatProcessor(Locale.ROOT);\n","filename":"src\/java.base\/share\/classes\/java\/util\/FormatProcessor.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -470,1 +470,0 @@\n-        Formatter.parse(format);\n","filename":"src\/java.base\/share\/classes\/java\/util\/FormatterBuilder.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -240,1 +240,1 @@\n-    public final Type templateProcessorType;\n+    public final Type validatingProcessorType;\n@@ -631,1 +631,1 @@\n-        templateProcessorType = enterClass(\"java.lang.template.ValidatingProcessor\");\n+        validatingProcessorType = enterClass(\"java.lang.template.ValidatingProcessor\");\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symtab.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -106,1 +106,0 @@\n-    private final Types types;\n@@ -131,1 +130,0 @@\n-        types = Types.instance(context);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/ArgumentAttr.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4134,1 +4134,1 @@\n-        Type interfaceType = types.asSuper(processorType, syms.templateProcessorType.tsym);\n+        Type interfaceType = types.asSuper(processorType, syms.validatingProcessorType.tsym);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1514,1 +1514,1 @@\n-                Type interfaceType = types.asSuper(processor.type, syms.templateProcessorType.tsym);\n+                Type interfaceType = types.asSuper(processor.type, syms.validatingProcessorType.tsym);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Flow.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -506,1 +506,1 @@\n-            JCFieldAccess qualifier = make.Select(make.Type(syms.templateProcessorType), dynSym.name);\n+            JCFieldAccess qualifier = make.Select(make.Type(syms.validatingProcessorType), dynSym.name);\n@@ -516,1 +516,1 @@\n-                    syms.templateProcessorType, List.of(syms.stringTemplateType));\n+                    syms.validatingProcessorType, List.of(syms.stringTemplateType));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TransLiterals.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -665,1 +665,2 @@\n-            log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.ProcessorMissingFromStringTemplateExpression);\n+            log.error(DiagnosticFlag.SYNTAX, token.pos,\n+                    Errors.ProcessorMissingFromStringTemplateExpression);\n@@ -674,1 +675,1 @@\n-        List<String> fragments = List.of(stringToken.stringVal());\n+        List<String> fragments = List.of(string);\n@@ -682,1 +683,1 @@\n-                fragments = fragments.append(stringToken.stringVal());\n+                fragments = fragments.append(string);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -432,3 +432,3 @@\n-            ASSERT(src.valueGetters().get(0).invoke(src), 10);\n-            ASSERT(src.valueGetters().get(1).invoke(src), 20);\n-            ASSERT(src.valueGetters().get(2).invoke(src), 30);\n+            ASSERT(src.valueAccessors().get(0).invoke(src), 10);\n+            ASSERT(src.valueAccessors().get(1).invoke(src), 20);\n+            ASSERT(src.valueAccessors().get(2).invoke(src), 30);\n","filename":"test\/jdk\/java\/lang\/template\/Basic.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -237,1 +237,2 @@\n-            import static java.util.FormatProcessor.FMT;\n+            import java.util.FormatProcessor;\n+            import java.util.Locale;\n@@ -240,0 +241,1 @@\n+                static final FormatProcessor FMT = new FormatProcessor(Locale.US);\n@@ -306,1 +308,1 @@\n-}\n\\ No newline at end of file\n+}\n","filename":"test\/jdk\/java\/lang\/template\/StringTemplateTest.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"}]}