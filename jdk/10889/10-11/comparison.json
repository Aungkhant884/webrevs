{"files":[{"patch":"@@ -1116,0 +1116,1 @@\n+            \/\/ (long,byte[],ttype) -> long\n@@ -1118,0 +1119,1 @@\n+            \/\/ (byte[],long,ttypes...) -> String (unchanged)\n@@ -1125,0 +1127,1 @@\n+        \/\/ (long,ttypes...) -> String\n@@ -1131,0 +1134,1 @@\n+            \/\/ (long,ttype) -> long\n@@ -1135,0 +1139,1 @@\n+                \/\/ (ttype) -> long\n@@ -1136,0 +1141,1 @@\n+                \/\/ (ttypes...) -> String\n@@ -1140,0 +1146,1 @@\n+                \/\/ (long,ttypes...) -> String\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/StringConcatFactory.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -103,1 +103,1 @@\n- * String result = StringTemplate.interpolate(fragments, values);;\n+ * String result = StringTemplate.interpolate(fragments, values);\n@@ -188,27 +188,0 @@\n-    \/**\n-     * Return the types of this {@link StringTemplate StringTemplate's} values.\n-     *\n-     * @return list of value types\n-     *\n-     * @implNote The default method determines if the {@link StringTemplate}\n-     * was synthesized by the compiler, then the types are precisely those of the\n-     * embedded expressions, otherwise this method returns the values list types.\n-     *\/\n-    default List<Class<?>> valueTypes() {\n-        return TemplateRuntime.valueTypes(this);\n-    }\n-\n-    \/**\n-     * Return {@link MethodHandle MethodHandles} to access this\n-     * {@link StringTemplate StringTemplate's} values.\n-     *\n-     * @return list of value types\n-     *\n-     * @implNote The default method determines if the {@link java.lang.template.StringTemplate}\n-     * was synthesized by the compiler, then the MethodHandles are precisely those of the\n-     * embedded expressions fields, otherwise this method returns getters for the values list.\n-     *\/\n-    default List<MethodHandle> valueAccessors() {\n-        return TemplateRuntime.valueAccessors(this);\n-    }\n-\n@@ -248,2 +221,1 @@\n-        return Objects.hashCode(stringTemplate.fragments()) ^\n-               Objects.hashCode(stringTemplate.values());\n+        return Objects.hash(stringTemplate.fragments(), stringTemplate.values());\n","filename":"src\/java.base\/share\/classes\/java\/lang\/template\/StringTemplate.java","additions":2,"deletions":30,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -56,19 +56,0 @@\n-    \/**\n-     * {@link MethodHandle} to {@link TemplateRuntime#getValue(int, StringTemplate)}.\n-     *\/\n-    private static final MethodHandle GET_VALUE_MH;\n-\n-    \/**\n-     * Initialize {@link MethodHandle MethodHandles}.\n-     *\/\n-    static {\n-        try {\n-            MethodHandles.Lookup lookup = MethodHandles.lookup();\n-\n-            MethodType mt = MethodType.methodType(Object.class, int.class, StringTemplate.class);\n-            GET_VALUE_MH = lookup.findStatic(TemplateRuntime.class, \"getValue\", mt);\n-        } catch (ReflectiveOperationException | SecurityException ex) {\n-            throw new AssertionError(\"template runtime init fail\", ex);\n-        }\n-    }\n-\n@@ -84,2 +65,0 @@\n-    private static final JavaLangInvokeAccess JLIA = SharedSecrets.getJavaLangInvokeAccess();\n-\n@@ -103,95 +82,0 @@\n-    \/**\n-     * Return the types of a {@link StringTemplate StringTemplate's} values.\n-     *\n-     * @param st  StringTemplate to examine\n-     *\n-     * @return list of value types\n-     *\n-     * @throws NullPointerException if st is null\n-     *\n-     * @implNote The default method determines if the {@link StringTemplate}\n-     * was synthesized by the compiler, then the types are precisely those of the\n-     * embedded expressions, otherwise this method returns a list of\n-     * {@code Object.class}.\n-     *\/\n-    static List<Class<?>> valueTypes(StringTemplate st) {\n-        Objects.requireNonNull(st, \"st must not be null\");\n-        Class<?> tsClass = st.getClass();\n-        if (tsClass.isSynthetic()) {\n-            List<Class<?>> result = new ArrayList<>();\n-            try {\n-                for (int i = 0; ; i++) {\n-                    Field field = tsClass.getDeclaredField(\"x\" + i);\n-                    result.add(field.getType());\n-                }\n-            } catch (NoSuchFieldException ex) {\n-                \/\/ End of fields\n-            } catch (SecurityException ex) {\n-                throw new InternalError(ex);\n-            }\n-            return result;\n-        }\n-        int size = st.values().size();\n-        Class<?>[] types = new Class<?>[size];\n-        Arrays.fill(types, Object.class);\n-        return List.of(types);\n-    }\n-\n-    \/**\n-     * Return {@link MethodHandle MethodHandles} to access a\n-     * {@link StringTemplate StringTemplate's} values.\n-     *\n-     * @param st  StringTemplate to examine\n-     *\n-     * @return list of {@link MethodHandle MethodHandles}\n-     *\n-     * @throws NullPointerException if st is null\n-     *\n-     * @implNote The default method determines if the {@link StringTemplate}\n-     * was synthesized by the compiler, then the MethodHandles are precisely those of the\n-     * embedded expressions fields, otherwise this method returns getters for the values list.\n-     *\/\n-    static List<MethodHandle> valueAccessors(StringTemplate st) {\n-        Objects.requireNonNull(st, \"st must not be null\");\n-        List<MethodHandle> result = new ArrayList<>();\n-        Class<?> tsClass = st.getClass();\n-        if (tsClass.isSynthetic()) {\n-            try {\n-                for (int i = 0; ; i++) {\n-                    Field field = tsClass.getDeclaredField(\"x\" + i);\n-                    MethodHandle mh = JLIA.unreflectField(field, false);\n-                    mh = mh.asType(mh.type().changeParameterType(0, StringTemplate.class));\n-                    result.add(mh);\n-                }\n-            } catch (NoSuchFieldException ex) {\n-                \/\/ End of fields\n-            } catch (ReflectiveOperationException | SecurityException ex) {\n-                throw new InternalError(ex);\n-            }\n-\n-            return result;\n-        }\n-        try {\n-            int size = st.values().size();\n-            for (int index = 0; index < size; index++) {\n-                result.add(MethodHandles.insertArguments(GET_VALUE_MH, 0, index));\n-            }\n-            return result;\n-        } catch (SecurityException ex) {\n-            throw new InternalError(ex);\n-        }\n-    }\n-\n-    \/**\n-     * Private method used by {@link TemplateRuntime#valueAccessors(StringTemplate)}\n-     * to access values.\n-     *\n-     * @param index values index\n-     * @param st    the {@link StringTemplate}\n-     *\n-     * @return value at index\n-     *\/\n-    private static Object getValue(int index, StringTemplate st) {\n-        return st.values().get(index);\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/template\/TemplateRuntime.java","additions":0,"deletions":116,"binary":false,"changes":116,"status":"modified"},{"patch":"@@ -76,1 +76,1 @@\n-     * Static final processor that triggered the BSM generation.\n+     * The static final processor that triggered the BSM generation.\n@@ -141,3 +141,1 @@\n-        MethodType processorGetterType = MethodType.methodType(ValidatingProcessor.class);\n-        ValidatingProcessor<?, ?> processor =\n-                (ValidatingProcessor<?, ?>)processorGetter.asType(processorGetterType).invokeExact();\n+        ValidatingProcessor<?, ?> processor = (ValidatingProcessor<?, ?>)processorGetter.invoke();\n@@ -185,4 +183,1 @@\n-        mh = mh.withVarargs(true);\n-        mh = mh.asType(type);\n-\n-        return mh;\n+        return mh.asCollector(Object[].class, type.parameterCount()).asType(type);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/template\/TemplateSupport.java","additions":3,"deletions":8,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -427,11 +427,0 @@\n-        ASSERT(src.valueTypes().get(0), int.class);\n-        ASSERT(src.valueTypes().get(1), int.class);\n-        ASSERT(src.valueTypes().get(2), int.class);\n-\n-        try {\n-            ASSERT(src.valueAccessors().get(0).invoke(src), 10);\n-            ASSERT(src.valueAccessors().get(1).invoke(src), 20);\n-            ASSERT(src.valueAccessors().get(2).invoke(src), 30);\n-        } catch (Throwable ex) {\n-            throw new RuntimeException(ex);\n-        }\n","filename":"test\/jdk\/java\/lang\/template\/Basic.java","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"}]}