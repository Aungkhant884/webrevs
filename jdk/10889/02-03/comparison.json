{"files":[{"patch":"@@ -1,4223 +0,0 @@\n-\/*\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.tools.javac.comp;\n-\n-import java.util.*;\n-import java.util.stream.Collectors;\n-\n-import com.sun.tools.javac.code.*;\n-import com.sun.tools.javac.code.Kinds.KindSelector;\n-import com.sun.tools.javac.code.Scope.WriteableScope;\n-import com.sun.tools.javac.jvm.*;\n-import com.sun.tools.javac.jvm.PoolConstant.LoadableConstant;\n-import com.sun.tools.javac.main.Option.PkgInfo;\n-import com.sun.tools.javac.resources.CompilerProperties.Fragments;\n-import com.sun.tools.javac.tree.*;\n-import com.sun.tools.javac.util.*;\n-import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;\n-import com.sun.tools.javac.util.List;\n-\n-import com.sun.tools.javac.code.Symbol.*;\n-import com.sun.tools.javac.code.Symbol.OperatorSymbol.AccessCode;\n-import com.sun.tools.javac.resources.CompilerProperties.Errors;\n-import com.sun.tools.javac.tree.JCTree.*;\n-import com.sun.tools.javac.code.Type.*;\n-\n-import com.sun.tools.javac.jvm.Target;\n-import com.sun.tools.javac.tree.EndPosTable;\n-\n-import static com.sun.tools.javac.code.Flags.*;\n-import static com.sun.tools.javac.code.Flags.BLOCK;\n-import static com.sun.tools.javac.code.Scope.LookupKind.NON_RECURSIVE;\n-import static com.sun.tools.javac.code.TypeTag.*;\n-import static com.sun.tools.javac.code.Kinds.Kind.*;\n-import static com.sun.tools.javac.jvm.ByteCodes.*;\n-import com.sun.tools.javac.tree.JCTree.JCBreak;\n-import com.sun.tools.javac.tree.JCTree.JCCase;\n-import com.sun.tools.javac.tree.JCTree.JCExpression;\n-import com.sun.tools.javac.tree.JCTree.JCExpressionStatement;\n-import static com.sun.tools.javac.tree.JCTree.JCOperatorExpression.OperandPos.LEFT;\n-import com.sun.tools.javac.tree.JCTree.JCSwitchExpression;\n-import static com.sun.tools.javac.tree.JCTree.Tag.*;\n-\n-\/** This pass translates away some syntactic sugar: inner classes,\n- *  class literals, assertions, foreach loops, etc.\n- *\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-public class Lower extends TreeTranslator {\n-    protected static final Context.Key<Lower> lowerKey = new Context.Key<>();\n-\n-    public static Lower instance(Context context) {\n-        Lower instance = context.get(lowerKey);\n-        if (instance == null)\n-            instance = new Lower(context);\n-        return instance;\n-    }\n-\n-    private final Names names;\n-    private final Log log;\n-    private final Symtab syms;\n-    private final Resolve rs;\n-    private final Operators operators;\n-    private final Check chk;\n-    private final Attr attr;\n-    private TreeMaker make;\n-    private DiagnosticPosition make_pos;\n-    private final ConstFold cfolder;\n-    private final Target target;\n-    private final TypeEnvs typeEnvs;\n-    private final Name dollarAssertionsDisabled;\n-    private final Types types;\n-    private final TransTypes transTypes;\n-    private final boolean debugLower;\n-    private final boolean disableProtectedAccessors; \/\/ experimental\n-    private final PkgInfo pkginfoOpt;\n-    private final boolean optimizeOuterThis;\n-\n-    protected Lower(Context context) {\n-        context.put(lowerKey, this);\n-        names = Names.instance(context);\n-        log = Log.instance(context);\n-        syms = Symtab.instance(context);\n-        rs = Resolve.instance(context);\n-        operators = Operators.instance(context);\n-        chk = Check.instance(context);\n-        attr = Attr.instance(context);\n-        make = TreeMaker.instance(context);\n-        cfolder = ConstFold.instance(context);\n-        target = Target.instance(context);\n-        typeEnvs = TypeEnvs.instance(context);\n-        dollarAssertionsDisabled = names.\n-            fromString(target.syntheticNameChar() + \"assertionsDisabled\");\n-\n-        types = Types.instance(context);\n-        transTypes = TransTypes.instance(context);\n-        Options options = Options.instance(context);\n-        debugLower = options.isSet(\"debuglower\");\n-        pkginfoOpt = PkgInfo.get(options);\n-        optimizeOuterThis =\n-            target.optimizeOuterThis() ||\n-            options.getBoolean(\"optimizeOuterThis\", false);\n-        disableProtectedAccessors = options.isSet(\"disableProtectedAccessors\");\n-    }\n-\n-    \/** The currently enclosing class.\n-     *\/\n-    ClassSymbol currentClass;\n-\n-    \/** A queue of all translated classes.\n-     *\/\n-    ListBuffer<JCTree> translated;\n-\n-    \/** Environment for symbol lookup, set by translateTopLevelClass.\n-     *\/\n-    Env<AttrContext> attrEnv;\n-\n-    \/** A hash table mapping syntax trees to their ending source positions.\n-     *\/\n-    EndPosTable endPosTable;\n-\n-\/**************************************************************************\n- * Global mappings\n- *************************************************************************\/\n-\n-    \/** A hash table mapping local classes to their definitions.\n-     *\/\n-    Map<ClassSymbol, JCClassDecl> classdefs;\n-\n-    \/** A hash table mapping local classes to a list of pruned trees.\n-     *\/\n-    public Map<ClassSymbol, List<JCTree>> prunedTree = new WeakHashMap<>();\n-\n-    \/** A hash table mapping virtual accessed symbols in outer subclasses\n-     *  to the actually referred symbol in superclasses.\n-     *\/\n-    Map<Symbol,Symbol> actualSymbols;\n-\n-    \/** The current method definition.\n-     *\/\n-    JCMethodDecl currentMethodDef;\n-\n-    \/** The current method symbol.\n-     *\/\n-    MethodSymbol currentMethodSym;\n-\n-    \/** The currently enclosing outermost class definition.\n-     *\/\n-    JCClassDecl outermostClassDef;\n-\n-    \/** The currently enclosing outermost member definition.\n-     *\/\n-    JCTree outermostMemberDef;\n-\n-    \/** A map from local variable symbols to their translation (as per LambdaToMethod).\n-     * This is required when a capturing local class is created from a lambda (in which\n-     * case the captured symbols should be replaced with the translated lambda symbols).\n-     *\/\n-    Map<Symbol, Symbol> lambdaTranslationMap = null;\n-\n-    \/** A navigator class for assembling a mapping from local class symbols\n-     *  to class definition trees.\n-     *  There is only one case; all other cases simply traverse down the tree.\n-     *\/\n-    class ClassMap extends TreeScanner {\n-\n-        \/** All encountered class defs are entered into classdefs table.\n-         *\/\n-        public void visitClassDef(JCClassDecl tree) {\n-            classdefs.put(tree.sym, tree);\n-            super.visitClassDef(tree);\n-        }\n-    }\n-    ClassMap classMap = new ClassMap();\n-\n-    \/** Map a class symbol to its definition.\n-     *  @param c    The class symbol of which we want to determine the definition.\n-     *\/\n-    JCClassDecl classDef(ClassSymbol c) {\n-        \/\/ First lookup the class in the classdefs table.\n-        JCClassDecl def = classdefs.get(c);\n-        if (def == null && outermostMemberDef != null) {\n-            \/\/ If this fails, traverse outermost member definition, entering all\n-            \/\/ local classes into classdefs, and try again.\n-            classMap.scan(outermostMemberDef);\n-            def = classdefs.get(c);\n-        }\n-        if (def == null) {\n-            \/\/ If this fails, traverse outermost class definition, entering all\n-            \/\/ local classes into classdefs, and try again.\n-            classMap.scan(outermostClassDef);\n-            def = classdefs.get(c);\n-        }\n-        return def;\n-    }\n-\n-    \/** A hash table mapping class symbols to lists of free variables.\n-     *  accessed by them. Only free variables of the method immediately containing\n-     *  a class are associated with that class.\n-     *\/\n-    Map<ClassSymbol,List<VarSymbol>> freevarCache;\n-\n-    \/** A navigator class for collecting the free variables accessed\n-     *  from a local class. There is only one case; all other cases simply\n-     *  traverse down the tree. This class doesn't deal with the specific\n-     *  of Lower - it's an abstract visitor that is meant to be reused in\n-     *  order to share the local variable capture logic.\n-     *\/\n-    abstract class BasicFreeVarCollector extends TreeScanner {\n-\n-        \/** Add all free variables of class c to fvs list\n-         *  unless they are already there.\n-         *\/\n-        abstract void addFreeVars(ClassSymbol c);\n-\n-        \/** If tree refers to a variable in owner of local class, add it to\n-         *  free variables list.\n-         *\/\n-        public void visitIdent(JCIdent tree) {\n-            visitSymbol(tree.sym);\n-        }\n-        \/\/ where\n-        abstract void visitSymbol(Symbol _sym);\n-\n-        \/** If tree refers to a class instance creation expression\n-         *  add all free variables of the freshly created class.\n-         *\/\n-        public void visitNewClass(JCNewClass tree) {\n-            ClassSymbol c = (ClassSymbol)tree.constructor.owner;\n-            addFreeVars(c);\n-            super.visitNewClass(tree);\n-        }\n-\n-        \/** If tree refers to a superclass constructor call,\n-         *  add all free variables of the superclass.\n-         *\/\n-        public void visitApply(JCMethodInvocation tree) {\n-            if (TreeInfo.name(tree.meth) == names._super) {\n-                addFreeVars((ClassSymbol) TreeInfo.symbol(tree.meth).owner);\n-            }\n-            super.visitApply(tree);\n-        }\n-\n-        @Override\n-        public void visitYield(JCYield tree) {\n-            scan(tree.value);\n-        }\n-\n-    }\n-\n-    \/**\n-     * Lower-specific subclass of {@code BasicFreeVarCollector}.\n-     *\/\n-    class FreeVarCollector extends BasicFreeVarCollector {\n-\n-        \/** The owner of the local class.\n-         *\/\n-        Symbol owner;\n-\n-        \/** The local class.\n-         *\/\n-        ClassSymbol clazz;\n-\n-        \/** The list of owner's variables accessed from within the local class,\n-         *  without any duplicates.\n-         *\/\n-        List<VarSymbol> fvs;\n-\n-        FreeVarCollector(ClassSymbol clazz) {\n-            this.clazz = clazz;\n-            this.owner = clazz.owner;\n-            this.fvs = List.nil();\n-        }\n-\n-        \/** Add free variable to fvs list unless it is already there.\n-         *\/\n-        private void addFreeVar(VarSymbol v) {\n-            for (List<VarSymbol> l = fvs; l.nonEmpty(); l = l.tail)\n-                if (l.head == v) return;\n-            fvs = fvs.prepend(v);\n-        }\n-\n-        @Override\n-        void addFreeVars(ClassSymbol c) {\n-            List<VarSymbol> fvs = freevarCache.get(c);\n-            if (fvs != null) {\n-                for (List<VarSymbol> l = fvs; l.nonEmpty(); l = l.tail) {\n-                    addFreeVar(l.head);\n-                }\n-            }\n-        }\n-\n-        @Override\n-        void visitSymbol(Symbol _sym) {\n-            Symbol sym = _sym;\n-            if (sym.kind == VAR || sym.kind == MTH) {\n-                if (sym != null && sym.owner != owner)\n-                    sym = proxies.get(sym);\n-                if (sym != null && sym.owner == owner) {\n-                    VarSymbol v = (VarSymbol)sym;\n-                    if (v.getConstValue() == null) {\n-                        addFreeVar(v);\n-                    }\n-                } else {\n-                    if (outerThisStack.head != null &&\n-                        outerThisStack.head != _sym)\n-                        visitSymbol(outerThisStack.head);\n-                }\n-            }\n-        }\n-\n-        \/** If tree refers to a class instance creation expression\n-         *  add all free variables of the freshly created class.\n-         *\/\n-        public void visitNewClass(JCNewClass tree) {\n-            ClassSymbol c = (ClassSymbol)tree.constructor.owner;\n-            if (tree.encl == null &&\n-                c.hasOuterInstance() &&\n-                outerThisStack.head != null)\n-                visitSymbol(outerThisStack.head);\n-            super.visitNewClass(tree);\n-        }\n-\n-        \/** If tree refers to a qualified this or super expression\n-         *  for anything but the current class, add the outer this\n-         *  stack as a free variable.\n-         *\/\n-        public void visitSelect(JCFieldAccess tree) {\n-            if ((tree.name == names._this || tree.name == names._super) &&\n-                tree.selected.type.tsym != clazz &&\n-                outerThisStack.head != null)\n-                visitSymbol(outerThisStack.head);\n-            super.visitSelect(tree);\n-        }\n-\n-        \/** If tree refers to a superclass constructor call,\n-         *  add all free variables of the superclass.\n-         *\/\n-        public void visitApply(JCMethodInvocation tree) {\n-            if (TreeInfo.name(tree.meth) == names._super) {\n-                Symbol constructor = TreeInfo.symbol(tree.meth);\n-                ClassSymbol c = (ClassSymbol)constructor.owner;\n-                if (c.hasOuterInstance() &&\n-                    !tree.meth.hasTag(SELECT) &&\n-                    outerThisStack.head != null)\n-                    visitSymbol(outerThisStack.head);\n-            }\n-            super.visitApply(tree);\n-        }\n-\n-    }\n-\n-    ClassSymbol ownerToCopyFreeVarsFrom(ClassSymbol c) {\n-        if (!c.isDirectlyOrIndirectlyLocal()) {\n-            return null;\n-        }\n-        Symbol currentOwner = c.owner;\n-        while (currentOwner.owner.kind.matches(KindSelector.TYP) && currentOwner.isDirectlyOrIndirectlyLocal()) {\n-            currentOwner = currentOwner.owner;\n-        }\n-        if (currentOwner.owner.kind.matches(KindSelector.VAL_MTH) && c.isSubClass(currentOwner, types)) {\n-            return (ClassSymbol)currentOwner;\n-        }\n-        return null;\n-    }\n-\n-    \/** Return the variables accessed from within a local class, which\n-     *  are declared in the local class' owner.\n-     *  (in reverse order of first access).\n-     *\/\n-    List<VarSymbol> freevars(ClassSymbol c)  {\n-        List<VarSymbol> fvs = freevarCache.get(c);\n-        if (fvs != null) {\n-            return fvs;\n-        }\n-        if (c.owner.kind.matches(KindSelector.VAL_MTH) && !c.isStatic()) {\n-            FreeVarCollector collector = new FreeVarCollector(c);\n-            collector.scan(classDef(c));\n-            fvs = collector.fvs;\n-            freevarCache.put(c, fvs);\n-            return fvs;\n-        } else {\n-            ClassSymbol owner = ownerToCopyFreeVarsFrom(c);\n-            if (owner != null) {\n-                fvs = freevarCache.get(owner);\n-                freevarCache.put(c, fvs);\n-                return fvs;\n-            } else {\n-                return List.nil();\n-            }\n-        }\n-    }\n-\n-    Map<TypeSymbol,EnumMapping> enumSwitchMap = new LinkedHashMap<>();\n-\n-    EnumMapping mapForEnum(DiagnosticPosition pos, TypeSymbol enumClass) {\n-        EnumMapping map = enumSwitchMap.get(enumClass);\n-        if (map == null)\n-            enumSwitchMap.put(enumClass, map = new EnumMapping(pos, enumClass));\n-        return map;\n-    }\n-\n-    \/** This map gives a translation table to be used for enum\n-     *  switches.\n-     *\n-     *  <p>For each enum that appears as the type of a switch\n-     *  expression, we maintain an EnumMapping to assist in the\n-     *  translation, as exemplified by the following example:\n-     *\n-     *  <p>we translate\n-     *  <pre>\n-     *          switch(colorExpression) {\n-     *          case red: stmt1;\n-     *          case green: stmt2;\n-     *          }\n-     *  <\/pre>\n-     *  into\n-     *  <pre>\n-     *          switch(Outer$0.$EnumMap$Color[colorExpression.ordinal()]) {\n-     *          case 1: stmt1;\n-     *          case 2: stmt2\n-     *          }\n-     *  <\/pre>\n-     *  with the auxiliary table initialized as follows:\n-     *  <pre>\n-     *          class Outer$0 {\n-     *              synthetic final int[] $EnumMap$Color = new int[Color.values().length];\n-     *              static {\n-     *                  try { $EnumMap$Color[red.ordinal()] = 1; } catch (NoSuchFieldError ex) {}\n-     *                  try { $EnumMap$Color[green.ordinal()] = 2; } catch (NoSuchFieldError ex) {}\n-     *              }\n-     *          }\n-     *  <\/pre>\n-     *  class EnumMapping provides mapping data and support methods for this translation.\n-     *\/\n-    class EnumMapping {\n-        EnumMapping(DiagnosticPosition pos, TypeSymbol forEnum) {\n-            this.forEnum = forEnum;\n-            this.values = new LinkedHashMap<>();\n-            this.pos = pos;\n-            Name varName = names\n-                .fromString(target.syntheticNameChar() +\n-                            \"SwitchMap\" +\n-                            target.syntheticNameChar() +\n-                            names.fromUtf(ClassWriter.externalize(forEnum.type.tsym.flatName())).toString()\n-                            .replace('\/', '.')\n-                            .replace('.', target.syntheticNameChar()));\n-            ClassSymbol outerCacheClass = outerCacheClass();\n-            this.mapVar = new VarSymbol(STATIC | SYNTHETIC | FINAL,\n-                                        varName,\n-                                        new ArrayType(syms.intType, syms.arrayClass),\n-                                        outerCacheClass);\n-            enterSynthetic(pos, mapVar, outerCacheClass.members());\n-        }\n-\n-        DiagnosticPosition pos = null;\n-\n-        \/\/ the next value to use\n-        int next = 1; \/\/ 0 (unused map elements) go to the default label\n-\n-        \/\/ the enum for which this is a map\n-        final TypeSymbol forEnum;\n-\n-        \/\/ the field containing the map\n-        final VarSymbol mapVar;\n-\n-        \/\/ the mapped values\n-        final Map<VarSymbol,Integer> values;\n-\n-        JCLiteral forConstant(VarSymbol v) {\n-            Integer result = values.get(v);\n-            if (result == null)\n-                values.put(v, result = next++);\n-            return make.Literal(result);\n-        }\n-\n-        \/\/ generate the field initializer for the map\n-        void translate() {\n-            boolean prevAllowProtectedAccess = attrEnv.info.allowProtectedAccess;\n-            try {\n-                make.at(pos.getStartPosition());\n-                attrEnv.info.allowProtectedAccess = true;\n-                JCClassDecl owner = classDef((ClassSymbol)mapVar.owner);\n-\n-                \/\/ synthetic static final int[] $SwitchMap$Color = new int[Color.values().length];\n-                MethodSymbol valuesMethod = lookupMethod(pos,\n-                                                         names.values,\n-                                                         forEnum.type,\n-                                                         List.nil());\n-                JCExpression size = make \/\/ Color.values().length\n-                    .Select(make.App(make.QualIdent(valuesMethod)),\n-                            syms.lengthVar);\n-                JCExpression mapVarInit = make\n-                    .NewArray(make.Type(syms.intType), List.of(size), null)\n-                    .setType(new ArrayType(syms.intType, syms.arrayClass));\n-\n-                \/\/ try { $SwitchMap$Color[red.ordinal()] = 1; } catch (java.lang.NoSuchFieldError ex) {}\n-                ListBuffer<JCStatement> stmts = new ListBuffer<>();\n-                Symbol ordinalMethod = lookupMethod(pos,\n-                                                    names.ordinal,\n-                                                    forEnum.type,\n-                                                    List.nil());\n-                List<JCCatch> catcher = List.<JCCatch>nil()\n-                    .prepend(make.Catch(make.VarDef(new VarSymbol(PARAMETER, names.ex,\n-                                                                  syms.noSuchFieldErrorType,\n-                                                                  syms.noSymbol),\n-                                                    null),\n-                                        make.Block(0, List.nil())));\n-                for (Map.Entry<VarSymbol,Integer> e : values.entrySet()) {\n-                    VarSymbol enumerator = e.getKey();\n-                    Integer mappedValue = e.getValue();\n-                    JCExpression assign = make\n-                        .Assign(make.Indexed(mapVar,\n-                                             make.App(make.Select(make.QualIdent(enumerator),\n-                                                                  ordinalMethod))),\n-                                make.Literal(mappedValue))\n-                        .setType(syms.intType);\n-                    JCStatement exec = make.Exec(assign);\n-                    JCStatement _try = make.Try(make.Block(0, List.of(exec)), catcher, null);\n-                    stmts.append(_try);\n-                }\n-\n-                owner.defs = owner.defs\n-                    .prepend(make.Block(STATIC, stmts.toList()))\n-                    .prepend(make.VarDef(mapVar, mapVarInit));\n-            } finally {\n-                attrEnv.info.allowProtectedAccess = prevAllowProtectedAccess;\n-            }\n-        }\n-    }\n-\n-\n-\/**************************************************************************\n- * Tree building blocks\n- *************************************************************************\/\n-\n-    \/** Equivalent to make.at(pos.getStartPosition()) with side effect of caching\n-     *  pos as make_pos, for use in diagnostics.\n-     **\/\n-    TreeMaker make_at(DiagnosticPosition pos) {\n-        make_pos = pos;\n-        return make.at(pos);\n-    }\n-\n-    \/** Make an attributed tree representing a literal. This will be an\n-     *  Ident node in the case of boolean literals, a Literal node in all\n-     *  other cases.\n-     *  @param type       The literal's type.\n-     *  @param value      The literal's value.\n-     *\/\n-    JCExpression makeLit(Type type, Object value) {\n-        return make.Literal(type.getTag(), value).setType(type.constType(value));\n-    }\n-\n-    \/** Make an attributed tree representing null.\n-     *\/\n-    JCExpression makeNull() {\n-        return makeLit(syms.botType, null);\n-    }\n-\n-    \/** Make an attributed class instance creation expression.\n-     *  @param ctype    The class type.\n-     *  @param args     The constructor arguments.\n-     *\/\n-    JCNewClass makeNewClass(Type ctype, List<JCExpression> args) {\n-        JCNewClass tree = make.NewClass(null,\n-            null, make.QualIdent(ctype.tsym), args, null);\n-        tree.constructor = rs.resolveConstructor(\n-            make_pos, attrEnv, ctype, TreeInfo.types(args), List.nil());\n-        tree.type = ctype;\n-        return tree;\n-    }\n-\n-    \/** Make an attributed unary expression.\n-     *  @param optag    The operators tree tag.\n-     *  @param arg      The operator's argument.\n-     *\/\n-    JCUnary makeUnary(JCTree.Tag optag, JCExpression arg) {\n-        JCUnary tree = make.Unary(optag, arg);\n-        tree.operator = operators.resolveUnary(tree, optag, arg.type);\n-        tree.type = tree.operator.type.getReturnType();\n-        return tree;\n-    }\n-\n-    \/** Make an attributed binary expression.\n-     *  @param optag    The operators tree tag.\n-     *  @param lhs      The operator's left argument.\n-     *  @param rhs      The operator's right argument.\n-     *\/\n-    JCBinary makeBinary(JCTree.Tag optag, JCExpression lhs, JCExpression rhs) {\n-        JCBinary tree = make.Binary(optag, lhs, rhs);\n-        tree.operator = operators.resolveBinary(tree, optag, lhs.type, rhs.type);\n-        tree.type = tree.operator.type.getReturnType();\n-        return tree;\n-    }\n-\n-    \/** Make an attributed assignop expression.\n-     *  @param optag    The operators tree tag.\n-     *  @param lhs      The operator's left argument.\n-     *  @param rhs      The operator's right argument.\n-     *\/\n-    JCAssignOp makeAssignop(JCTree.Tag optag, JCTree lhs, JCTree rhs) {\n-        JCAssignOp tree = make.Assignop(optag, lhs, rhs);\n-        tree.operator = operators.resolveBinary(tree, tree.getTag().noAssignOp(), lhs.type, rhs.type);\n-        tree.type = lhs.type;\n-        return tree;\n-    }\n-\n-    \/** Convert tree into string object, unless it has already a\n-     *  reference type..\n-     *\/\n-    JCExpression makeString(JCExpression tree) {\n-        if (!tree.type.isPrimitiveOrVoid()) {\n-            return tree;\n-        } else {\n-            Symbol valueOfSym = lookupMethod(tree.pos(),\n-                                             names.valueOf,\n-                                             syms.stringType,\n-                                             List.of(tree.type));\n-            return make.App(make.QualIdent(valueOfSym), List.of(tree));\n-        }\n-    }\n-\n-    \/** Create an empty anonymous class definition and enter and complete\n-     *  its symbol. Return the class definition's symbol.\n-     *  and create\n-     *  @param flags    The class symbol's flags\n-     *  @param owner    The class symbol's owner\n-     *\/\n-    JCClassDecl makeEmptyClass(long flags, ClassSymbol owner) {\n-        return makeEmptyClass(flags, owner, null, true);\n-    }\n-\n-    JCClassDecl makeEmptyClass(long flags, ClassSymbol owner, Name flatname,\n-            boolean addToDefs) {\n-        \/\/ Create class symbol.\n-        ClassSymbol c = syms.defineClass(names.empty, owner);\n-        if (flatname != null) {\n-            c.flatname = flatname;\n-        } else {\n-            c.flatname = chk.localClassName(c);\n-        }\n-        c.sourcefile = owner.sourcefile;\n-        c.completer = Completer.NULL_COMPLETER;\n-        c.members_field = WriteableScope.create(c);\n-        c.flags_field = flags;\n-        ClassType ctype = (ClassType) c.type;\n-        ctype.supertype_field = syms.objectType;\n-        ctype.interfaces_field = List.nil();\n-\n-        JCClassDecl odef = classDef(owner);\n-\n-        \/\/ Enter class symbol in owner scope and compiled table.\n-        enterSynthetic(odef.pos(), c, owner.members());\n-        chk.putCompiled(c);\n-\n-        \/\/ Create class definition tree.\n-        JCClassDecl cdef = make.ClassDef(\n-            make.Modifiers(flags), names.empty,\n-            List.nil(),\n-            null, List.nil(), List.nil());\n-        cdef.sym = c;\n-        cdef.type = c.type;\n-\n-        \/\/ Append class definition tree to owner's definitions.\n-        if (addToDefs) odef.defs = odef.defs.prepend(cdef);\n-        return cdef;\n-    }\n-\n-\/**************************************************************************\n- * Symbol manipulation utilities\n- *************************************************************************\/\n-\n-    \/** Enter a synthetic symbol in a given scope, but complain if there was already one there.\n-     *  @param pos           Position for error reporting.\n-     *  @param sym           The symbol.\n-     *  @param s             The scope.\n-     *\/\n-    private void enterSynthetic(DiagnosticPosition pos, Symbol sym, WriteableScope s) {\n-        s.enter(sym);\n-    }\n-\n-    \/** Create a fresh synthetic name within a given scope - the unique name is\n-     *  obtained by appending '$' chars at the end of the name until no match\n-     *  is found.\n-     *\n-     * @param name base name\n-     * @param s scope in which the name has to be unique\n-     * @return fresh synthetic name\n-     *\/\n-    private Name makeSyntheticName(Name name, Scope s) {\n-        do {\n-            name = name.append(\n-                    target.syntheticNameChar(),\n-                    names.empty);\n-        } while (lookupSynthetic(name, s) != null);\n-        return name;\n-    }\n-\n-    \/** Check whether synthetic symbols generated during lowering conflict\n-     *  with user-defined symbols.\n-     *\n-     *  @param translatedTrees lowered class trees\n-     *\/\n-    void checkConflicts(List<JCTree> translatedTrees) {\n-        for (JCTree t : translatedTrees) {\n-            t.accept(conflictsChecker);\n-        }\n-    }\n-\n-    JCTree.Visitor conflictsChecker = new TreeScanner() {\n-\n-        TypeSymbol currentClass;\n-\n-        @Override\n-        public void visitMethodDef(JCMethodDecl that) {\n-            checkConflicts(that.pos(), that.sym, currentClass);\n-            super.visitMethodDef(that);\n-        }\n-\n-        @Override\n-        public void visitVarDef(JCVariableDecl that) {\n-            if (that.sym.owner.kind == TYP) {\n-                checkConflicts(that.pos(), that.sym, currentClass);\n-            }\n-            super.visitVarDef(that);\n-        }\n-\n-        @Override\n-        public void visitClassDef(JCClassDecl that) {\n-            TypeSymbol prevCurrentClass = currentClass;\n-            currentClass = that.sym;\n-            try {\n-                super.visitClassDef(that);\n-            }\n-            finally {\n-                currentClass = prevCurrentClass;\n-            }\n-        }\n-\n-        void checkConflicts(DiagnosticPosition pos, Symbol sym, TypeSymbol c) {\n-            for (Type ct = c.type; ct != Type.noType ; ct = types.supertype(ct)) {\n-                for (Symbol sym2 : ct.tsym.members().getSymbolsByName(sym.name, NON_RECURSIVE)) {\n-                    \/\/ VM allows methods and variables with differing types\n-                    if (sym.kind == sym2.kind &&\n-                        types.isSameType(types.erasure(sym.type), types.erasure(sym2.type)) &&\n-                        sym != sym2 &&\n-                        (sym.flags() & Flags.SYNTHETIC) != (sym2.flags() & Flags.SYNTHETIC) &&\n-                        (sym.flags() & BRIDGE) == 0 && (sym2.flags() & BRIDGE) == 0) {\n-                        syntheticError(pos, (sym2.flags() & SYNTHETIC) == 0 ? sym2 : sym);\n-                        return;\n-                    }\n-                }\n-            }\n-        }\n-\n-        \/** Report a conflict between a user symbol and a synthetic symbol.\n-         *\/\n-        private void syntheticError(DiagnosticPosition pos, Symbol sym) {\n-            if (!sym.type.isErroneous()) {\n-                log.error(pos, Errors.CannotGenerateClass(sym.location(), Fragments.SyntheticNameConflict(sym, sym.location())));\n-            }\n-        }\n-    };\n-\n-    \/** Look up a synthetic name in a given scope.\n-     *  @param s            The scope.\n-     *  @param name         The name.\n-     *\/\n-    private Symbol lookupSynthetic(Name name, Scope s) {\n-        Symbol sym = s.findFirst(name);\n-        return (sym==null || (sym.flags()&SYNTHETIC)==0) ? null : sym;\n-    }\n-\n-    \/** Look up a method in a given scope.\n-     *\/\n-    private MethodSymbol lookupMethod(DiagnosticPosition pos, Name name, Type qual, List<Type> args) {\n-        return rs.resolveInternalMethod(pos, attrEnv, qual, name, args, List.nil());\n-    }\n-\n-    \/** Anon inner classes are used as access constructor tags.\n-     * accessConstructorTag will use an existing anon class if one is available,\n-     * and synthesize a class (with makeEmptyClass) if one is not available.\n-     * However, there is a small possibility that an existing class will not\n-     * be generated as expected if it is inside a conditional with a constant\n-     * expression. If that is found to be the case, create an empty class tree here.\n-     *\/\n-    private void checkAccessConstructorTags() {\n-        for (List<ClassSymbol> l = accessConstrTags; l.nonEmpty(); l = l.tail) {\n-            ClassSymbol c = l.head;\n-            if (isTranslatedClassAvailable(c))\n-                continue;\n-            \/\/ Create class definition tree.\n-            JCClassDecl cdec = makeEmptyClass(STATIC | SYNTHETIC,\n-                    c.outermostClass(), c.flatname, false);\n-            swapAccessConstructorTag(c, cdec.sym);\n-            translated.append(cdec);\n-        }\n-    }\n-    \/\/ where\n-    private boolean isTranslatedClassAvailable(ClassSymbol c) {\n-        for (JCTree tree: translated) {\n-            if (tree.hasTag(CLASSDEF)\n-                    && ((JCClassDecl) tree).sym == c) {\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n-\n-    void swapAccessConstructorTag(ClassSymbol oldCTag, ClassSymbol newCTag) {\n-        for (MethodSymbol methodSymbol : accessConstrs.values()) {\n-            Assert.check(methodSymbol.type.hasTag(METHOD));\n-            MethodType oldMethodType =\n-                    (MethodType)methodSymbol.type;\n-            if (oldMethodType.argtypes.head.tsym == oldCTag)\n-                methodSymbol.type =\n-                    types.createMethodTypeWithParameters(oldMethodType,\n-                        oldMethodType.getParameterTypes().tail\n-                            .prepend(newCTag.erasure(types)));\n-        }\n-    }\n-\n-\/**************************************************************************\n- * Access methods\n- *************************************************************************\/\n-\n-    \/** A mapping from symbols to their access numbers.\n-     *\/\n-    private Map<Symbol,Integer> accessNums;\n-\n-    \/** A mapping from symbols to an array of access symbols, indexed by\n-     *  access code.\n-     *\/\n-    private Map<Symbol,MethodSymbol[]> accessSyms;\n-\n-    \/** A mapping from (constructor) symbols to access constructor symbols.\n-     *\/\n-    private Map<Symbol,MethodSymbol> accessConstrs;\n-\n-    \/** A list of all class symbols used for access constructor tags.\n-     *\/\n-    private List<ClassSymbol> accessConstrTags;\n-\n-    \/** A queue for all accessed symbols.\n-     *\/\n-    private ListBuffer<Symbol> accessed;\n-\n-    \/** return access code for identifier,\n-     *  @param tree     The tree representing the identifier use.\n-     *  @param enclOp   The closest enclosing operation node of tree,\n-     *                  null if tree is not a subtree of an operation.\n-     *\/\n-    private static int accessCode(JCTree tree, JCTree enclOp) {\n-        if (enclOp == null)\n-            return AccessCode.DEREF.code;\n-        else if (enclOp.hasTag(ASSIGN) &&\n-                 tree == TreeInfo.skipParens(((JCAssign) enclOp).lhs))\n-            return AccessCode.ASSIGN.code;\n-        else if ((enclOp.getTag().isIncOrDecUnaryOp() || enclOp.getTag().isAssignop()) &&\n-                tree == TreeInfo.skipParens(((JCOperatorExpression) enclOp).getOperand(LEFT)))\n-            return (((JCOperatorExpression) enclOp).operator).getAccessCode(enclOp.getTag());\n-        else\n-            return AccessCode.DEREF.code;\n-    }\n-\n-    \/** Return binary operator that corresponds to given access code.\n-     *\/\n-    private OperatorSymbol binaryAccessOperator(int acode, Tag tag) {\n-        return operators.lookupBinaryOp(op -> op.getAccessCode(tag) == acode);\n-    }\n-\n-    \/** Return tree tag for assignment operation corresponding\n-     *  to given binary operator.\n-     *\/\n-    private static JCTree.Tag treeTag(OperatorSymbol operator) {\n-        switch (operator.opcode) {\n-        case ByteCodes.ior: case ByteCodes.lor:\n-            return BITOR_ASG;\n-        case ByteCodes.ixor: case ByteCodes.lxor:\n-            return BITXOR_ASG;\n-        case ByteCodes.iand: case ByteCodes.land:\n-            return BITAND_ASG;\n-        case ByteCodes.ishl: case ByteCodes.lshl:\n-        case ByteCodes.ishll: case ByteCodes.lshll:\n-            return SL_ASG;\n-        case ByteCodes.ishr: case ByteCodes.lshr:\n-        case ByteCodes.ishrl: case ByteCodes.lshrl:\n-            return SR_ASG;\n-        case ByteCodes.iushr: case ByteCodes.lushr:\n-        case ByteCodes.iushrl: case ByteCodes.lushrl:\n-            return USR_ASG;\n-        case ByteCodes.iadd: case ByteCodes.ladd:\n-        case ByteCodes.fadd: case ByteCodes.dadd:\n-        case ByteCodes.string_add:\n-            return PLUS_ASG;\n-        case ByteCodes.isub: case ByteCodes.lsub:\n-        case ByteCodes.fsub: case ByteCodes.dsub:\n-            return MINUS_ASG;\n-        case ByteCodes.imul: case ByteCodes.lmul:\n-        case ByteCodes.fmul: case ByteCodes.dmul:\n-            return MUL_ASG;\n-        case ByteCodes.idiv: case ByteCodes.ldiv:\n-        case ByteCodes.fdiv: case ByteCodes.ddiv:\n-            return DIV_ASG;\n-        case ByteCodes.imod: case ByteCodes.lmod:\n-        case ByteCodes.fmod: case ByteCodes.dmod:\n-            return MOD_ASG;\n-        default:\n-            throw new AssertionError();\n-        }\n-    }\n-\n-    \/** The name of the access method with number `anum' and access code `acode'.\n-     *\/\n-    Name accessName(int anum, int acode) {\n-        return names.fromString(\n-            \"access\" + target.syntheticNameChar() + anum + acode \/ 10 + acode % 10);\n-    }\n-\n-    \/** Return access symbol for a private or protected symbol from an inner class.\n-     *  @param sym        The accessed private symbol.\n-     *  @param tree       The accessing tree.\n-     *  @param enclOp     The closest enclosing operation node of tree,\n-     *                    null if tree is not a subtree of an operation.\n-     *  @param protAccess Is access to a protected symbol in another\n-     *                    package?\n-     *  @param refSuper   Is access via a (qualified) C.super?\n-     *\/\n-    MethodSymbol accessSymbol(Symbol sym, JCTree tree, JCTree enclOp,\n-                              boolean protAccess, boolean refSuper) {\n-        ClassSymbol accOwner = refSuper && protAccess\n-            \/\/ For access via qualified super (T.super.x), place the\n-            \/\/ access symbol on T.\n-            ? (ClassSymbol)((JCFieldAccess) tree).selected.type.tsym\n-            \/\/ Otherwise pretend that the owner of an accessed\n-            \/\/ protected symbol is the enclosing class of the current\n-            \/\/ class which is a subclass of the symbol's owner.\n-            : accessClass(sym, protAccess, tree);\n-\n-        Symbol vsym = sym;\n-        if (sym.owner != accOwner) {\n-            vsym = sym.clone(accOwner);\n-            actualSymbols.put(vsym, sym);\n-        }\n-\n-        Integer anum              \/\/ The access number of the access method.\n-            = accessNums.get(vsym);\n-        if (anum == null) {\n-            anum = accessed.length();\n-            accessNums.put(vsym, anum);\n-            accessSyms.put(vsym, new MethodSymbol[AccessCode.numberOfAccessCodes]);\n-            accessed.append(vsym);\n-            \/\/ System.out.println(\"accessing \" + vsym + \" in \" + vsym.location());\n-        }\n-\n-        int acode;                \/\/ The access code of the access method.\n-        List<Type> argtypes;      \/\/ The argument types of the access method.\n-        Type restype;             \/\/ The result type of the access method.\n-        List<Type> thrown;        \/\/ The thrown exceptions of the access method.\n-        switch (vsym.kind) {\n-        case VAR:\n-            acode = accessCode(tree, enclOp);\n-            if (acode >= AccessCode.FIRSTASGOP.code) {\n-                OperatorSymbol operator = binaryAccessOperator(acode, enclOp.getTag());\n-                if (operator.opcode == string_add)\n-                    argtypes = List.of(syms.objectType);\n-                else\n-                    argtypes = operator.type.getParameterTypes().tail;\n-            } else if (acode == AccessCode.ASSIGN.code)\n-                argtypes = List.of(vsym.erasure(types));\n-            else\n-                argtypes = List.nil();\n-            restype = vsym.erasure(types);\n-            thrown = List.nil();\n-            break;\n-        case MTH:\n-            acode = AccessCode.DEREF.code;\n-            argtypes = vsym.erasure(types).getParameterTypes();\n-            restype = vsym.erasure(types).getReturnType();\n-            thrown = vsym.type.getThrownTypes();\n-            break;\n-        default:\n-            throw new AssertionError();\n-        }\n-\n-        \/\/ For references via qualified super, increment acode by one,\n-        \/\/ making it odd.\n-        if (protAccess && refSuper) acode++;\n-\n-        \/\/ Instance access methods get instance as first parameter.\n-        \/\/ For protected symbols this needs to be the instance as a member\n-        \/\/ of the type containing the accessed symbol, not the class\n-        \/\/ containing the access method.\n-        if ((vsym.flags() & STATIC) == 0) {\n-            argtypes = argtypes.prepend(vsym.owner.erasure(types));\n-        }\n-        MethodSymbol[] accessors = accessSyms.get(vsym);\n-        MethodSymbol accessor = accessors[acode];\n-        if (accessor == null) {\n-            accessor = new MethodSymbol(\n-                STATIC | SYNTHETIC | (accOwner.isInterface() ? PUBLIC : 0),\n-                accessName(anum.intValue(), acode),\n-                new MethodType(argtypes, restype, thrown, syms.methodClass),\n-                accOwner);\n-            enterSynthetic(tree.pos(), accessor, accOwner.members());\n-            accessors[acode] = accessor;\n-        }\n-        return accessor;\n-    }\n-\n-    \/** The qualifier to be used for accessing a symbol in an outer class.\n-     *  This is either C.sym or C.this.sym, depending on whether or not\n-     *  sym is static.\n-     *  @param sym   The accessed symbol.\n-     *\/\n-    JCExpression accessBase(DiagnosticPosition pos, Symbol sym) {\n-        return (sym.flags() & STATIC) != 0\n-            ? access(make.at(pos.getStartPosition()).QualIdent(sym.owner))\n-            : makeOwnerThis(pos, sym, true);\n-    }\n-\n-    \/** Do we need an access method to reference private symbol?\n-     *\/\n-    boolean needsPrivateAccess(Symbol sym) {\n-        if (target.hasNestmateAccess()) {\n-            return false;\n-        }\n-        if ((sym.flags() & PRIVATE) == 0 || sym.owner == currentClass) {\n-            return false;\n-        } else if (sym.name == names.init && sym.owner.isDirectlyOrIndirectlyLocal()) {\n-            \/\/ private constructor in local class: relax protection\n-            sym.flags_field &= ~PRIVATE;\n-            return false;\n-        } else {\n-            return true;\n-        }\n-    }\n-\n-    \/** Do we need an access method to reference symbol in other package?\n-     *\/\n-    boolean needsProtectedAccess(Symbol sym, JCTree tree) {\n-        if (disableProtectedAccessors) return false;\n-        if ((sym.flags() & PROTECTED) == 0 ||\n-            sym.owner.owner == currentClass.owner || \/\/ fast special case\n-            sym.packge() == currentClass.packge())\n-            return false;\n-        if (!currentClass.isSubClass(sym.owner, types))\n-            return true;\n-        if ((sym.flags() & STATIC) != 0 ||\n-            !tree.hasTag(SELECT) ||\n-            TreeInfo.name(((JCFieldAccess) tree).selected) == names._super)\n-            return false;\n-        return !((JCFieldAccess) tree).selected.type.tsym.isSubClass(currentClass, types);\n-    }\n-\n-    \/** The class in which an access method for given symbol goes.\n-     *  @param sym        The access symbol\n-     *  @param protAccess Is access to a protected symbol in another\n-     *                    package?\n-     *\/\n-    ClassSymbol accessClass(Symbol sym, boolean protAccess, JCTree tree) {\n-        if (protAccess) {\n-            Symbol qualifier = null;\n-            ClassSymbol c = currentClass;\n-            if (tree.hasTag(SELECT) && (sym.flags() & STATIC) == 0) {\n-                qualifier = ((JCFieldAccess) tree).selected.type.tsym;\n-                while (!qualifier.isSubClass(c, types)) {\n-                    c = c.owner.enclClass();\n-                }\n-                return c;\n-            } else {\n-                while (!c.isSubClass(sym.owner, types)) {\n-                    c = c.owner.enclClass();\n-                }\n-            }\n-            return c;\n-        } else {\n-            \/\/ the symbol is private\n-            return sym.owner.enclClass();\n-        }\n-    }\n-\n-    private void addPrunedInfo(JCTree tree) {\n-        List<JCTree> infoList = prunedTree.get(currentClass);\n-        infoList = (infoList == null) ? List.of(tree) : infoList.prepend(tree);\n-        prunedTree.put(currentClass, infoList);\n-    }\n-\n-    \/** Ensure that identifier is accessible, return tree accessing the identifier.\n-     *  @param sym      The accessed symbol.\n-     *  @param tree     The tree referring to the symbol.\n-     *  @param enclOp   The closest enclosing operation node of tree,\n-     *                  null if tree is not a subtree of an operation.\n-     *  @param refSuper Is access via a (qualified) C.super?\n-     *\/\n-    JCExpression access(Symbol sym, JCExpression tree, JCExpression enclOp, boolean refSuper) {\n-        \/\/ Access a free variable via its proxy, or its proxy's proxy\n-        while (sym.kind == VAR && sym.owner.kind == MTH &&\n-            sym.owner.enclClass() != currentClass) {\n-            \/\/ A constant is replaced by its constant value.\n-            Object cv = ((VarSymbol)sym).getConstValue();\n-            if (cv != null) {\n-                make.at(tree.pos);\n-                return makeLit(sym.type, cv);\n-            }\n-            if (lambdaTranslationMap != null && lambdaTranslationMap.get(sym) != null) {\n-                return make.at(tree.pos).Ident(lambdaTranslationMap.get(sym));\n-            } else {\n-                \/\/ Otherwise replace the variable by its proxy.\n-                sym = proxies.get(sym);\n-                Assert.check(sym != null && (sym.flags_field & FINAL) != 0);\n-                tree = make.at(tree.pos).Ident(sym);\n-            }\n-        }\n-        JCExpression base = (tree.hasTag(SELECT)) ? ((JCFieldAccess) tree).selected : null;\n-        switch (sym.kind) {\n-        case TYP:\n-            if (sym.owner.kind != PCK) {\n-                \/\/ Convert type idents to\n-                \/\/ <flat name> or <package name> . <flat name>\n-                Name flatname = Convert.shortName(sym.flatName());\n-                while (base != null &&\n-                       TreeInfo.symbol(base) != null &&\n-                       TreeInfo.symbol(base).kind != PCK) {\n-                    base = (base.hasTag(SELECT))\n-                        ? ((JCFieldAccess) base).selected\n-                        : null;\n-                }\n-                if (tree.hasTag(IDENT)) {\n-                    ((JCIdent) tree).name = flatname;\n-                } else if (base == null) {\n-                    tree = make.at(tree.pos).Ident(sym);\n-                    ((JCIdent) tree).name = flatname;\n-                } else {\n-                    ((JCFieldAccess) tree).selected = base;\n-                    ((JCFieldAccess) tree).name = flatname;\n-                }\n-            }\n-            break;\n-        case MTH: case VAR:\n-            if (sym.owner.kind == TYP) {\n-\n-                \/\/ Access methods are required for\n-                \/\/  - private members,\n-                \/\/  - protected members in a superclass of an\n-                \/\/    enclosing class contained in another package.\n-                \/\/  - all non-private members accessed via a qualified super.\n-                boolean protAccess = refSuper && !needsPrivateAccess(sym)\n-                    || needsProtectedAccess(sym, tree);\n-                boolean accReq = protAccess || needsPrivateAccess(sym);\n-\n-                \/\/ A base has to be supplied for\n-                \/\/  - simple identifiers accessing variables in outer classes.\n-                boolean baseReq =\n-                    base == null &&\n-                    sym.owner != syms.predefClass &&\n-                    !sym.isMemberOf(currentClass, types);\n-\n-                if (accReq || baseReq) {\n-                    make.at(tree.pos);\n-\n-                    \/\/ Constants are replaced by their constant value.\n-                    if (sym.kind == VAR) {\n-                        Object cv = ((VarSymbol)sym).getConstValue();\n-                        if (cv != null) {\n-                            addPrunedInfo(tree);\n-                            return makeLit(sym.type, cv);\n-                        }\n-                    }\n-\n-                    \/\/ Private variables and methods are replaced by calls\n-                    \/\/ to their access methods.\n-                    if (accReq) {\n-                        List<JCExpression> args = List.nil();\n-                        if ((sym.flags() & STATIC) == 0) {\n-                            \/\/ Instance access methods get instance\n-                            \/\/ as first parameter.\n-                            if (base == null)\n-                                base = makeOwnerThis(tree.pos(), sym, true);\n-                            args = args.prepend(base);\n-                            base = null;   \/\/ so we don't duplicate code\n-                        }\n-                        Symbol access = accessSymbol(sym, tree,\n-                                                     enclOp, protAccess,\n-                                                     refSuper);\n-                        JCExpression receiver = make.Select(\n-                            base != null ? base : make.QualIdent(access.owner),\n-                            access);\n-                        return make.App(receiver, args);\n-\n-                    \/\/ Other accesses to members of outer classes get a\n-                    \/\/ qualifier.\n-                    } else if (baseReq) {\n-                        return make.at(tree.pos).Select(\n-                            accessBase(tree.pos(), sym), sym).setType(tree.type);\n-                    }\n-                }\n-            } else if (sym.owner.kind == MTH && lambdaTranslationMap != null) {\n-                \/\/sym is a local variable - check the lambda translation map to\n-                \/\/see if sym has been translated to something else in the current\n-                \/\/scope (by LambdaToMethod)\n-                Symbol translatedSym = lambdaTranslationMap.get(sym.baseSymbol());\n-                if (translatedSym != null) {\n-                    tree = make.at(tree.pos).Ident(translatedSym);\n-                }\n-            }\n-        }\n-        return tree;\n-    }\n-\n-    \/** Ensure that identifier is accessible, return tree accessing the identifier.\n-     *  @param tree     The identifier tree.\n-     *\/\n-    JCExpression access(JCExpression tree) {\n-        Symbol sym = TreeInfo.symbol(tree);\n-        return sym == null ? tree : access(sym, tree, null, false);\n-    }\n-\n-    \/** Return access constructor for a private constructor,\n-     *  or the constructor itself, if no access constructor is needed.\n-     *  @param pos       The position to report diagnostics, if any.\n-     *  @param constr    The private constructor.\n-     *\/\n-    Symbol accessConstructor(DiagnosticPosition pos, Symbol constr) {\n-        if (needsPrivateAccess(constr)) {\n-            ClassSymbol accOwner = constr.owner.enclClass();\n-            MethodSymbol aconstr = accessConstrs.get(constr);\n-            if (aconstr == null) {\n-                List<Type> argtypes = constr.type.getParameterTypes();\n-                if ((accOwner.flags_field & ENUM) != 0)\n-                    argtypes = argtypes\n-                        .prepend(syms.intType)\n-                        .prepend(syms.stringType);\n-                aconstr = new MethodSymbol(\n-                    SYNTHETIC,\n-                    names.init,\n-                    new MethodType(\n-                        argtypes.append(\n-                            accessConstructorTag().erasure(types)),\n-                        constr.type.getReturnType(),\n-                        constr.type.getThrownTypes(),\n-                        syms.methodClass),\n-                    accOwner);\n-                enterSynthetic(pos, aconstr, accOwner.members());\n-                accessConstrs.put(constr, aconstr);\n-                accessed.append(constr);\n-            }\n-            return aconstr;\n-        } else {\n-            return constr;\n-        }\n-    }\n-\n-    \/** Return an anonymous class nested in this toplevel class.\n-     *\/\n-    ClassSymbol accessConstructorTag() {\n-        ClassSymbol topClass = currentClass.outermostClass();\n-        ModuleSymbol topModle = topClass.packge().modle;\n-        for (int i = 1; ; i++) {\n-            Name flatname = names.fromString(\"\" + topClass.getQualifiedName() +\n-                                            target.syntheticNameChar() +\n-                                            i);\n-            ClassSymbol ctag = chk.getCompiled(topModle, flatname);\n-            if (ctag == null)\n-                ctag = makeEmptyClass(STATIC | SYNTHETIC, topClass).sym;\n-            else if (!ctag.isAnonymous())\n-                continue;\n-            \/\/ keep a record of all tags, to verify that all are generated as required\n-            accessConstrTags = accessConstrTags.prepend(ctag);\n-            return ctag;\n-        }\n-    }\n-\n-    \/** Add all required access methods for a private symbol to enclosing class.\n-     *  @param sym       The symbol.\n-     *\/\n-    void makeAccessible(Symbol sym) {\n-        JCClassDecl cdef = classDef(sym.owner.enclClass());\n-        if (cdef == null) Assert.error(\"class def not found: \" + sym + \" in \" + sym.owner);\n-        if (sym.name == names.init) {\n-            cdef.defs = cdef.defs.prepend(\n-                accessConstructorDef(cdef.pos, sym, accessConstrs.get(sym)));\n-        } else {\n-            MethodSymbol[] accessors = accessSyms.get(sym);\n-            for (int i = 0; i < AccessCode.numberOfAccessCodes; i++) {\n-                if (accessors[i] != null)\n-                    cdef.defs = cdef.defs.prepend(\n-                        accessDef(cdef.pos, sym, accessors[i], i));\n-            }\n-        }\n-    }\n-\n-    \/** Construct definition of an access method.\n-     *  @param pos        The source code position of the definition.\n-     *  @param vsym       The private or protected symbol.\n-     *  @param accessor   The access method for the symbol.\n-     *  @param acode      The access code.\n-     *\/\n-    JCTree accessDef(int pos, Symbol vsym, MethodSymbol accessor, int acode) {\n-\/\/      System.err.println(\"access \" + vsym + \" with \" + accessor);\/\/DEBUG\n-        currentClass = vsym.owner.enclClass();\n-        make.at(pos);\n-        JCMethodDecl md = make.MethodDef(accessor, null);\n-\n-        \/\/ Find actual symbol\n-        Symbol sym = actualSymbols.get(vsym);\n-        if (sym == null) sym = vsym;\n-\n-        JCExpression ref;           \/\/ The tree referencing the private symbol.\n-        List<JCExpression> args;    \/\/ Any additional arguments to be passed along.\n-        if ((sym.flags() & STATIC) != 0) {\n-            ref = make.Ident(sym);\n-            args = make.Idents(md.params);\n-        } else {\n-            JCExpression site = make.Ident(md.params.head);\n-            if (acode % 2 != 0) {\n-                \/\/odd access codes represent qualified super accesses - need to\n-                \/\/emit reference to the direct superclass, even if the referred\n-                \/\/member is from an indirect superclass (JLS 13.1)\n-                site.setType(types.erasure(types.supertype(vsym.owner.enclClass().type)));\n-            }\n-            ref = make.Select(site, sym);\n-            args = make.Idents(md.params.tail);\n-        }\n-        JCStatement stat;          \/\/ The statement accessing the private symbol.\n-        if (sym.kind == VAR) {\n-            \/\/ Normalize out all odd access codes by taking floor modulo 2:\n-            int acode1 = acode - (acode & 1);\n-\n-            JCExpression expr;      \/\/ The access method's return value.\n-            AccessCode aCode = AccessCode.getFromCode(acode1);\n-            switch (aCode) {\n-            case DEREF:\n-                expr = ref;\n-                break;\n-            case ASSIGN:\n-                expr = make.Assign(ref, args.head);\n-                break;\n-            case PREINC: case POSTINC: case PREDEC: case POSTDEC:\n-                expr = makeUnary(aCode.tag, ref);\n-                break;\n-            default:\n-                expr = make.Assignop(\n-                    treeTag(binaryAccessOperator(acode1, JCTree.Tag.NO_TAG)), ref, args.head);\n-                ((JCAssignOp) expr).operator = binaryAccessOperator(acode1, JCTree.Tag.NO_TAG);\n-            }\n-            stat = make.Return(expr.setType(sym.type));\n-        } else {\n-            stat = make.Call(make.App(ref, args));\n-        }\n-        md.body = make.Block(0, List.of(stat));\n-\n-        \/\/ Make sure all parameters, result types and thrown exceptions\n-        \/\/ are accessible.\n-        for (List<JCVariableDecl> l = md.params; l.nonEmpty(); l = l.tail)\n-            l.head.vartype = access(l.head.vartype);\n-        md.restype = access(md.restype);\n-        for (List<JCExpression> l = md.thrown; l.nonEmpty(); l = l.tail)\n-            l.head = access(l.head);\n-\n-        return md;\n-    }\n-\n-    \/** Construct definition of an access constructor.\n-     *  @param pos        The source code position of the definition.\n-     *  @param constr     The private constructor.\n-     *  @param accessor   The access method for the constructor.\n-     *\/\n-    JCTree accessConstructorDef(int pos, Symbol constr, MethodSymbol accessor) {\n-        make.at(pos);\n-        JCMethodDecl md = make.MethodDef(accessor,\n-                                      accessor.externalType(types),\n-                                      null);\n-        JCIdent callee = make.Ident(names._this);\n-        callee.sym = constr;\n-        callee.type = constr.type;\n-        md.body =\n-            make.Block(0, List.of(\n-                make.Call(\n-                    make.App(\n-                        callee,\n-                        make.Idents(md.params.reverse().tail.reverse())))));\n-        return md;\n-    }\n-\n-\/**************************************************************************\n- * Free variables proxies and this$n\n- *************************************************************************\/\n-\n-    \/** A map which allows to retrieve the translated proxy variable for any given symbol of an\n-     *  enclosing scope that is accessed (the accessed symbol could be the synthetic 'this$n' symbol).\n-     *  Inside a constructor, the map temporarily overrides entries corresponding to proxies and any\n-     *  'this$n' symbols, where they represent the constructor parameters.\n-     *\/\n-    Map<Symbol, Symbol> proxies;\n-\n-    \/** A scope containing all unnamed resource variables\/saved\n-     *  exception variables for translated TWR blocks\n-     *\/\n-    WriteableScope twrVars;\n-\n-    \/** A stack containing the this$n field of the currently translated\n-     *  classes (if needed) in innermost first order.\n-     *  Inside a constructor, proxies and any this$n symbol are duplicated\n-     *  in an additional innermost scope, where they represent the constructor\n-     *  parameters.\n-     *\/\n-    List<VarSymbol> outerThisStack;\n-\n-    \/** The name of a free variable proxy.\n-     *\/\n-    Name proxyName(Name name, int index) {\n-        Name proxyName = names.fromString(\"val\" + target.syntheticNameChar() + name);\n-        if (index > 0) {\n-            proxyName = proxyName.append(names.fromString(\"\" + target.syntheticNameChar() + index));\n-        }\n-        return proxyName;\n-    }\n-\n-    \/** Proxy definitions for all free variables in given list, in reverse order.\n-     *  @param pos        The source code position of the definition.\n-     *  @param freevars   The free variables.\n-     *  @param owner      The class in which the definitions go.\n-     *\/\n-    List<JCVariableDecl> freevarDefs(int pos, List<VarSymbol> freevars, Symbol owner) {\n-        return freevarDefs(pos, freevars, owner, 0);\n-    }\n-\n-    List<JCVariableDecl> freevarDefs(int pos, List<VarSymbol> freevars, Symbol owner,\n-            long additionalFlags) {\n-        long flags = FINAL | SYNTHETIC | additionalFlags;\n-        List<JCVariableDecl> defs = List.nil();\n-        Set<Name> proxyNames = new HashSet<>();\n-        for (List<VarSymbol> l = freevars; l.nonEmpty(); l = l.tail) {\n-            VarSymbol v = l.head;\n-            int index = 0;\n-            Name proxyName;\n-            do {\n-                proxyName = proxyName(v.name, index++);\n-            } while (!proxyNames.add(proxyName));\n-            VarSymbol proxy = new VarSymbol(\n-                flags, proxyName, v.erasure(types), owner);\n-            proxies.put(v, proxy);\n-            JCVariableDecl vd = make.at(pos).VarDef(proxy, null);\n-            vd.vartype = access(vd.vartype);\n-            defs = defs.prepend(vd);\n-        }\n-        return defs;\n-    }\n-\n-    \/** The name of a this$n field\n-     *  @param type   The class referenced by the this$n field\n-     *\/\n-    Name outerThisName(Type type, Symbol owner) {\n-        Type t = type.getEnclosingType();\n-        int nestingLevel = 0;\n-        while (t.hasTag(CLASS)) {\n-            t = t.getEnclosingType();\n-            nestingLevel++;\n-        }\n-        Name result = names.fromString(\"this\" + target.syntheticNameChar() + nestingLevel);\n-        while (owner.kind == TYP && ((ClassSymbol)owner).members().findFirst(result) != null)\n-            result = names.fromString(result.toString() + target.syntheticNameChar());\n-        return result;\n-    }\n-\n-    private VarSymbol makeOuterThisVarSymbol(Symbol owner, long flags) {\n-        Type target = types.erasure(owner.enclClass().type.getEnclosingType());\n-        \/\/ Set NOOUTERTHIS for all synthetic outer instance variables, and unset\n-        \/\/ it when the variable is accessed. If the variable is never accessed,\n-        \/\/ we skip creating an outer instance field and saving the constructor\n-        \/\/ parameter to it.\n-        VarSymbol outerThis =\n-            new VarSymbol(flags | NOOUTERTHIS, outerThisName(target, owner), target, owner);\n-        outerThisStack = outerThisStack.prepend(outerThis);\n-        return outerThis;\n-    }\n-\n-    private JCVariableDecl makeOuterThisVarDecl(int pos, VarSymbol sym) {\n-        JCVariableDecl vd = make.at(pos).VarDef(sym, null);\n-        vd.vartype = access(vd.vartype);\n-        return vd;\n-    }\n-\n-    \/** Definition for this$n field.\n-     *  @param pos        The source code position of the definition.\n-     *  @param owner      The method in which the definition goes.\n-     *\/\n-    JCVariableDecl outerThisDef(int pos, MethodSymbol owner) {\n-        ClassSymbol c = owner.enclClass();\n-        boolean isMandated =\n-            \/\/ Anonymous constructors\n-            (owner.isConstructor() && owner.isAnonymous()) ||\n-            \/\/ Constructors of non-private inner member classes\n-            (owner.isConstructor() && c.isInner() &&\n-             !c.isPrivate() && !c.isStatic());\n-        long flags =\n-            FINAL | (isMandated ? MANDATED : SYNTHETIC) | PARAMETER;\n-        VarSymbol outerThis = makeOuterThisVarSymbol(owner, flags);\n-        owner.extraParams = owner.extraParams.prepend(outerThis);\n-        return makeOuterThisVarDecl(pos, outerThis);\n-    }\n-\n-    \/** Definition for this$n field.\n-     *  @param pos        The source code position of the definition.\n-     *  @param owner      The class in which the definition goes.\n-     *\/\n-    JCVariableDecl outerThisDef(int pos, ClassSymbol owner) {\n-        VarSymbol outerThis = makeOuterThisVarSymbol(owner, FINAL | SYNTHETIC);\n-        return makeOuterThisVarDecl(pos, outerThis);\n-    }\n-\n-    \/** Return a list of trees that load the free variables in given list,\n-     *  in reverse order.\n-     *  @param pos          The source code position to be used for the trees.\n-     *  @param freevars     The list of free variables.\n-     *\/\n-    List<JCExpression> loadFreevars(DiagnosticPosition pos, List<VarSymbol> freevars) {\n-        List<JCExpression> args = List.nil();\n-        for (List<VarSymbol> l = freevars; l.nonEmpty(); l = l.tail)\n-            args = args.prepend(loadFreevar(pos, l.head));\n-        return args;\n-    }\n-\/\/where\n-        JCExpression loadFreevar(DiagnosticPosition pos, VarSymbol v) {\n-            return access(v, make.at(pos).Ident(v), null, false);\n-        }\n-\n-    \/** Construct a tree simulating the expression {@code C.this}.\n-     *  @param pos           The source code position to be used for the tree.\n-     *  @param c             The qualifier class.\n-     *\/\n-    JCExpression makeThis(DiagnosticPosition pos, TypeSymbol c) {\n-        if (currentClass == c) {\n-            \/\/ in this case, `this' works fine\n-            return make.at(pos).This(c.erasure(types));\n-        } else {\n-            \/\/ need to go via this$n\n-            return makeOuterThis(pos, c);\n-        }\n-    }\n-\n-    \/**\n-     * Optionally replace a try statement with the desugaring of a\n-     * try-with-resources statement.  The canonical desugaring of\n-     *\n-     * try ResourceSpecification\n-     *   Block\n-     *\n-     * is\n-     *\n-     * {\n-     *   final VariableModifiers_minus_final R #resource = Expression;\n-     *\n-     *   try ResourceSpecificationtail\n-     *     Block\n-     *   } body-only-finally {\n-     *     if (#resource != null) \/\/nullcheck skipped if Expression is provably non-null\n-     *         #resource.close();\n-     *   } catch (Throwable #primaryException) {\n-     *       if (#resource != null) \/\/nullcheck skipped if Expression is provably non-null\n-     *           try {\n-     *               #resource.close();\n-     *           } catch (Throwable #suppressedException) {\n-     *              #primaryException.addSuppressed(#suppressedException);\n-     *           }\n-     *       throw #primaryException;\n-     *   }\n-     * }\n-     *\n-     * @param tree  The try statement to inspect.\n-     * @return a desugared try-with-resources tree, or the original\n-     * try block if there are no resources to manage.\n-     *\/\n-    JCTree makeTwrTry(JCTry tree) {\n-        make_at(tree.pos());\n-        twrVars = twrVars.dup();\n-        JCBlock twrBlock = makeTwrBlock(tree.resources, tree.body, 0);\n-        if (tree.catchers.isEmpty() && tree.finalizer == null)\n-            result = translate(twrBlock);\n-        else\n-            result = translate(make.Try(twrBlock, tree.catchers, tree.finalizer));\n-        twrVars = twrVars.leave();\n-        return result;\n-    }\n-\n-    private JCBlock makeTwrBlock(List<JCTree> resources, JCBlock block, int depth) {\n-        if (resources.isEmpty())\n-            return block;\n-\n-        \/\/ Add resource declaration or expression to block statements\n-        ListBuffer<JCStatement> stats = new ListBuffer<>();\n-        JCTree resource = resources.head;\n-        JCExpression resourceUse;\n-        boolean resourceNonNull;\n-        if (resource instanceof JCVariableDecl variableDecl) {\n-            resourceUse = make.Ident(variableDecl.sym).setType(resource.type);\n-            resourceNonNull = variableDecl.init != null && TreeInfo.skipParens(variableDecl.init).hasTag(NEWCLASS);\n-            stats.add(variableDecl);\n-        } else {\n-            Assert.check(resource instanceof JCExpression);\n-            VarSymbol syntheticTwrVar =\n-            new VarSymbol(SYNTHETIC | FINAL,\n-                          makeSyntheticName(names.fromString(\"twrVar\" +\n-                                           depth), twrVars),\n-                          (resource.type.hasTag(BOT)) ?\n-                          syms.autoCloseableType : resource.type,\n-                          currentMethodSym);\n-            twrVars.enter(syntheticTwrVar);\n-            JCVariableDecl syntheticTwrVarDecl =\n-                make.VarDef(syntheticTwrVar, (JCExpression)resource);\n-            resourceUse = (JCExpression)make.Ident(syntheticTwrVar);\n-            resourceNonNull = false;\n-            stats.add(syntheticTwrVarDecl);\n-        }\n-\n-        \/\/create (semi-) finally block that will be copied into the main try body:\n-        int oldPos = make.pos;\n-        make.at(TreeInfo.endPos(block));\n-\n-        \/\/ if (#resource != null) { #resource.close(); }\n-        JCStatement bodyCloseStatement = makeResourceCloseInvocation(resourceUse);\n-\n-        if (!resourceNonNull) {\n-            bodyCloseStatement = make.If(makeNonNullCheck(resourceUse),\n-                                         bodyCloseStatement,\n-                                         null);\n-        }\n-\n-        JCBlock finallyClause = make.Block(BODY_ONLY_FINALIZE, List.of(bodyCloseStatement));\n-        make.at(oldPos);\n-\n-        \/\/ Create catch clause that saves exception, closes the resource and then rethrows the exception:\n-        VarSymbol primaryException =\n-            new VarSymbol(FINAL|SYNTHETIC,\n-                          names.fromString(\"t\" +\n-                                           target.syntheticNameChar()),\n-                          syms.throwableType,\n-                          currentMethodSym);\n-        JCVariableDecl primaryExceptionDecl = make.VarDef(primaryException, null);\n-\n-        \/\/ close resource:\n-        \/\/ try {\n-        \/\/     #resource.close();\n-        \/\/ } catch (Throwable #suppressedException) {\n-        \/\/     #primaryException.addSuppressed(#suppressedException);\n-        \/\/ }\n-        VarSymbol suppressedException =\n-            new VarSymbol(SYNTHETIC, make.paramName(2),\n-                          syms.throwableType,\n-                          currentMethodSym);\n-        JCStatement addSuppressedStatement =\n-            make.Exec(makeCall(make.Ident(primaryException),\n-                               names.addSuppressed,\n-                               List.of(make.Ident(suppressedException))));\n-        JCBlock closeResourceTryBlock =\n-            make.Block(0L, List.of(makeResourceCloseInvocation(resourceUse)));\n-        JCVariableDecl catchSuppressedDecl = make.VarDef(suppressedException, null);\n-        JCBlock catchSuppressedBlock = make.Block(0L, List.of(addSuppressedStatement));\n-        List<JCCatch> catchSuppressedClauses =\n-                List.of(make.Catch(catchSuppressedDecl, catchSuppressedBlock));\n-        JCTry closeResourceTry = make.Try(closeResourceTryBlock, catchSuppressedClauses, null);\n-        closeResourceTry.finallyCanCompleteNormally = true;\n-\n-        JCStatement exceptionalCloseStatement = closeResourceTry;\n-\n-        if (!resourceNonNull) {\n-            \/\/ if (#resource != null) {  }\n-            exceptionalCloseStatement = make.If(makeNonNullCheck(resourceUse),\n-                                                exceptionalCloseStatement,\n-                                                null);\n-        }\n-\n-        JCStatement exceptionalRethrow = make.Throw(make.Ident(primaryException));\n-        JCBlock exceptionalCloseBlock = make.Block(0L, List.of(exceptionalCloseStatement, exceptionalRethrow));\n-        JCCatch exceptionalCatchClause = make.Catch(primaryExceptionDecl, exceptionalCloseBlock);\n-\n-        \/\/create the main try statement with the close:\n-        JCTry outerTry = make.Try(makeTwrBlock(resources.tail, block, depth + 1),\n-                                  List.of(exceptionalCatchClause),\n-                                  finallyClause);\n-\n-        outerTry.finallyCanCompleteNormally = true;\n-        stats.add(outerTry);\n-\n-        JCBlock newBlock = make.Block(0L, stats.toList());\n-        return newBlock;\n-    }\n-\n-    private JCStatement makeResourceCloseInvocation(JCExpression resource) {\n-        \/\/ convert to AutoCloseable if needed\n-        if (types.asSuper(resource.type, syms.autoCloseableType.tsym) == null) {\n-            resource = convert(resource, syms.autoCloseableType);\n-        }\n-\n-        \/\/ create resource.close() method invocation\n-        JCExpression resourceClose = makeCall(resource,\n-                                              names.close,\n-                                              List.nil());\n-        return make.Exec(resourceClose);\n-    }\n-\n-    private JCExpression makeNonNullCheck(JCExpression expression) {\n-        return makeBinary(NE, expression, makeNull());\n-    }\n-\n-    \/** Construct a tree that represents the outer instance\n-     *  {@code C.this}. Never pick the current `this'.\n-     *  @param pos           The source code position to be used for the tree.\n-     *  @param c             The qualifier class.\n-     *\/\n-    JCExpression makeOuterThis(DiagnosticPosition pos, TypeSymbol c) {\n-        List<VarSymbol> ots = outerThisStack;\n-        if (ots.isEmpty()) {\n-            log.error(pos, Errors.NoEnclInstanceOfTypeInScope(c));\n-            Assert.error();\n-            return makeNull();\n-        }\n-        VarSymbol ot = ots.head;\n-        JCExpression tree = access(make.at(pos).Ident(ot));\n-        ot.flags_field &= ~NOOUTERTHIS;\n-        TypeSymbol otc = ot.type.tsym;\n-        while (otc != c) {\n-            do {\n-                ots = ots.tail;\n-                if (ots.isEmpty()) {\n-                    log.error(pos, Errors.NoEnclInstanceOfTypeInScope(c));\n-                    Assert.error(); \/\/ should have been caught in Attr\n-                    return tree;\n-                }\n-                ot = ots.head;\n-            } while (ot.owner != otc);\n-            if (otc.owner.kind != PCK && !otc.hasOuterInstance()) {\n-                chk.earlyRefError(pos, c);\n-                Assert.error(); \/\/ should have been caught in Attr\n-                return makeNull();\n-            }\n-            tree = access(make.at(pos).Select(tree, ot));\n-            ot.flags_field &= ~NOOUTERTHIS;\n-            otc = ot.type.tsym;\n-        }\n-        return tree;\n-    }\n-\n-    \/** Construct a tree that represents the closest outer instance\n-     *  {@code C.this} such that the given symbol is a member of C.\n-     *  @param pos           The source code position to be used for the tree.\n-     *  @param sym           The accessed symbol.\n-     *  @param preciseMatch  should we accept a type that is a subtype of\n-     *                       sym's owner, even if it doesn't contain sym\n-     *                       due to hiding, overriding, or non-inheritance\n-     *                       due to protection?\n-     *\/\n-    JCExpression makeOwnerThis(DiagnosticPosition pos, Symbol sym, boolean preciseMatch) {\n-        Symbol c = sym.owner;\n-        if (preciseMatch ? sym.isMemberOf(currentClass, types)\n-                         : currentClass.isSubClass(sym.owner, types)) {\n-            \/\/ in this case, `this' works fine\n-            return make.at(pos).This(c.erasure(types));\n-        } else {\n-            \/\/ need to go via this$n\n-            return makeOwnerThisN(pos, sym, preciseMatch);\n-        }\n-    }\n-\n-    \/**\n-     * Similar to makeOwnerThis but will never pick \"this\".\n-     *\/\n-    JCExpression makeOwnerThisN(DiagnosticPosition pos, Symbol sym, boolean preciseMatch) {\n-        Symbol c = sym.owner;\n-        List<VarSymbol> ots = outerThisStack;\n-        if (ots.isEmpty()) {\n-            log.error(pos, Errors.NoEnclInstanceOfTypeInScope(c));\n-            Assert.error();\n-            return makeNull();\n-        }\n-        VarSymbol ot = ots.head;\n-        JCExpression tree = access(make.at(pos).Ident(ot));\n-        ot.flags_field &= ~NOOUTERTHIS;\n-        TypeSymbol otc = ot.type.tsym;\n-        while (!(preciseMatch ? sym.isMemberOf(otc, types) : otc.isSubClass(sym.owner, types))) {\n-            do {\n-                ots = ots.tail;\n-                if (ots.isEmpty()) {\n-                    log.error(pos, Errors.NoEnclInstanceOfTypeInScope(c));\n-                    Assert.error();\n-                    return tree;\n-                }\n-                ot = ots.head;\n-            } while (ot.owner != otc);\n-            tree = access(make.at(pos).Select(tree, ot));\n-            ot.flags_field &= ~NOOUTERTHIS;\n-            otc = ot.type.tsym;\n-        }\n-        return tree;\n-    }\n-\n-    \/** Return tree simulating the assignment {@code this.name = name}, where\n-     *  name is the name of a free variable.\n-     *\/\n-    JCStatement initField(int pos, Symbol rhs, Symbol lhs) {\n-        Assert.check(rhs.owner.kind == MTH);\n-        Assert.check(rhs.owner.owner == lhs.owner);\n-        make.at(pos);\n-        return\n-            make.Exec(\n-                make.Assign(\n-                    make.Select(make.This(lhs.owner.erasure(types)), lhs),\n-                    make.Ident(rhs)).setType(lhs.erasure(types)));\n-    }\n-\n-    \/** Return tree simulating the assignment {@code this.this$n = this$n}.\n-     *\/\n-    JCStatement initOuterThis(int pos, VarSymbol rhs) {\n-        Assert.check(rhs.owner.kind == MTH);\n-        VarSymbol lhs = outerThisStack.head;\n-        Assert.check(rhs.owner.owner == lhs.owner);\n-        make.at(pos);\n-        return\n-            make.Exec(\n-                make.Assign(\n-                    make.Select(make.This(lhs.owner.erasure(types)), lhs),\n-                    make.Ident(rhs)).setType(lhs.erasure(types)));\n-    }\n-\n-\/**************************************************************************\n- * Code for .class\n- *************************************************************************\/\n-\n-    \/** Return the symbol of a class to contain a cache of\n-     *  compiler-generated statics such as class$ and the\n-     *  $assertionsDisabled flag.  We create an anonymous nested class\n-     *  (unless one already exists) and return its symbol.  However,\n-     *  for backward compatibility in 1.4 and earlier we use the\n-     *  top-level class itself.\n-     *\/\n-    private ClassSymbol outerCacheClass() {\n-        ClassSymbol clazz = outermostClassDef.sym;\n-        Scope s = clazz.members();\n-        for (Symbol sym : s.getSymbols(NON_RECURSIVE))\n-            if (sym.kind == TYP &&\n-                sym.name == names.empty &&\n-                (sym.flags() & INTERFACE) == 0) return (ClassSymbol) sym;\n-        return makeEmptyClass(STATIC | SYNTHETIC, clazz).sym;\n-    }\n-\n-    \/** Create an attributed tree of the form left.name(). *\/\n-    private JCMethodInvocation makeCall(JCExpression left, Name name, List<JCExpression> args) {\n-        Assert.checkNonNull(left.type);\n-        Symbol funcsym = lookupMethod(make_pos, name, left.type,\n-                                      TreeInfo.types(args));\n-        return make.App(make.Select(left, funcsym), args);\n-    }\n-\n-    \/** The tree simulating a T.class expression.\n-     *  @param clazz      The tree identifying type T.\n-     *\/\n-    private JCExpression classOf(JCTree clazz) {\n-        return classOfType(clazz.type, clazz.pos());\n-    }\n-\n-    private JCExpression classOfType(Type type, DiagnosticPosition pos) {\n-        switch (type.getTag()) {\n-        case BYTE: case SHORT: case CHAR: case INT: case LONG: case FLOAT:\n-        case DOUBLE: case BOOLEAN: case VOID:\n-            \/\/ replace with <BoxedClass>.TYPE\n-            ClassSymbol c = types.boxedClass(type);\n-            Symbol typeSym =\n-                rs.accessBase(\n-                    rs.findIdentInType(pos, attrEnv, c.type, names.TYPE, KindSelector.VAR),\n-                    pos, c.type, names.TYPE, true);\n-            if (typeSym.kind == VAR)\n-                ((VarSymbol)typeSym).getConstValue(); \/\/ ensure initializer is evaluated\n-            return make.QualIdent(typeSym);\n-        case CLASS: case ARRAY:\n-                VarSymbol sym = new VarSymbol(\n-                        STATIC | PUBLIC | FINAL, names._class,\n-                        syms.classType, type.tsym);\n-                return make_at(pos).Select(make.Type(type), sym);\n-        default:\n-            throw new AssertionError();\n-        }\n-    }\n-\n-\/**************************************************************************\n- * Code for enabling\/disabling assertions.\n- *************************************************************************\/\n-\n-    private ClassSymbol assertionsDisabledClassCache;\n-\n-    \/**Used to create an auxiliary class to hold $assertionsDisabled for interfaces.\n-     *\/\n-    private ClassSymbol assertionsDisabledClass() {\n-        if (assertionsDisabledClassCache != null) return assertionsDisabledClassCache;\n-\n-        assertionsDisabledClassCache = makeEmptyClass(STATIC | SYNTHETIC, outermostClassDef.sym).sym;\n-\n-        return assertionsDisabledClassCache;\n-    }\n-\n-    \/\/ This code is not particularly robust if the user has\n-    \/\/ previously declared a member named '$assertionsDisabled'.\n-    \/\/ The same faulty idiom also appears in the translation of\n-    \/\/ class literals above.  We should report an error if a\n-    \/\/ previous declaration is not synthetic.\n-\n-    private JCExpression assertFlagTest(DiagnosticPosition pos) {\n-        \/\/ Outermost class may be either true class or an interface.\n-        ClassSymbol outermostClass = outermostClassDef.sym;\n-\n-        \/\/only classes can hold a non-public field, look for a usable one:\n-        ClassSymbol container = !currentClass.isInterface() ? currentClass :\n-                assertionsDisabledClass();\n-\n-        VarSymbol assertDisabledSym =\n-            (VarSymbol)lookupSynthetic(dollarAssertionsDisabled,\n-                                       container.members());\n-        if (assertDisabledSym == null) {\n-            assertDisabledSym =\n-                new VarSymbol(STATIC | FINAL | SYNTHETIC,\n-                              dollarAssertionsDisabled,\n-                              syms.booleanType,\n-                              container);\n-            enterSynthetic(pos, assertDisabledSym, container.members());\n-            Symbol desiredAssertionStatusSym = lookupMethod(pos,\n-                                                            names.desiredAssertionStatus,\n-                                                            types.erasure(syms.classType),\n-                                                            List.nil());\n-            JCClassDecl containerDef = classDef(container);\n-            make_at(containerDef.pos());\n-            JCExpression notStatus = makeUnary(NOT, make.App(make.Select(\n-                    classOfType(types.erasure(outermostClass.type),\n-                                containerDef.pos()),\n-                    desiredAssertionStatusSym)));\n-            JCVariableDecl assertDisabledDef = make.VarDef(assertDisabledSym,\n-                                                   notStatus);\n-            containerDef.defs = containerDef.defs.prepend(assertDisabledDef);\n-\n-            if (currentClass.isInterface()) {\n-                \/\/need to load the assertions enabled\/disabled state while\n-                \/\/initializing the interface:\n-                JCClassDecl currentClassDef = classDef(currentClass);\n-                make_at(currentClassDef.pos());\n-                JCStatement dummy = make.If(make.QualIdent(assertDisabledSym), make.Skip(), null);\n-                JCBlock clinit = make.Block(STATIC, List.of(dummy));\n-                currentClassDef.defs = currentClassDef.defs.prepend(clinit);\n-            }\n-        }\n-        make_at(pos);\n-        return makeUnary(NOT, make.Ident(assertDisabledSym));\n-    }\n-\n-\n-\/**************************************************************************\n- * Building blocks for let expressions\n- *************************************************************************\/\n-\n-    interface TreeBuilder {\n-        JCExpression build(JCExpression arg);\n-    }\n-\n-    \/** Construct an expression using the builder, with the given rval\n-     *  expression as an argument to the builder.  However, the rval\n-     *  expression must be computed only once, even if used multiple\n-     *  times in the result of the builder.  We do that by\n-     *  constructing a \"let\" expression that saves the rvalue into a\n-     *  temporary variable and then uses the temporary variable in\n-     *  place of the expression built by the builder.  The complete\n-     *  resulting expression is of the form\n-     *  <pre>\n-     *    (let <b>TYPE<\/b> <b>TEMP<\/b> = <b>RVAL<\/b>;\n-     *     in (<b>BUILDER<\/b>(<b>TEMP<\/b>)))\n-     *  <\/pre>\n-     *  where <code><b>TEMP<\/b><\/code> is a newly declared variable\n-     *  in the let expression.\n-     *\/\n-    JCExpression abstractRval(JCExpression rval, Type type, TreeBuilder builder) {\n-        rval = TreeInfo.skipParens(rval);\n-        switch (rval.getTag()) {\n-        case LITERAL:\n-            return builder.build(rval);\n-        case IDENT:\n-            JCIdent id = (JCIdent) rval;\n-            if ((id.sym.flags() & FINAL) != 0 && id.sym.owner.kind == MTH)\n-                return builder.build(rval);\n-        }\n-        Name name = TreeInfo.name(rval);\n-        if (name == names._super || name == names._this)\n-            return builder.build(rval);\n-        VarSymbol var =\n-            new VarSymbol(FINAL|SYNTHETIC,\n-                          names.fromString(\n-                                          target.syntheticNameChar()\n-                                          + \"\" + rval.hashCode()),\n-                                      type,\n-                                      currentMethodSym);\n-        rval = convert(rval,type);\n-        JCVariableDecl def = make.VarDef(var, rval); \/\/ XXX cast\n-        JCExpression built = builder.build(make.Ident(var));\n-        JCExpression res = make.LetExpr(def, built);\n-        res.type = built.type;\n-        return res;\n-    }\n-\n-    \/\/ same as above, with the type of the temporary variable computed\n-    JCExpression abstractRval(JCExpression rval, TreeBuilder builder) {\n-        return abstractRval(rval, rval.type, builder);\n-    }\n-\n-    \/\/ same as above, but for an expression that may be used as either\n-    \/\/ an rvalue or an lvalue.  This requires special handling for\n-    \/\/ Select expressions, where we place the left-hand-side of the\n-    \/\/ select in a temporary, and for Indexed expressions, where we\n-    \/\/ place both the indexed expression and the index value in temps.\n-    JCExpression abstractLval(JCExpression lval, final TreeBuilder builder) {\n-        lval = TreeInfo.skipParens(lval);\n-        switch (lval.getTag()) {\n-        case IDENT:\n-            return builder.build(lval);\n-        case SELECT: {\n-            final JCFieldAccess s = (JCFieldAccess)lval;\n-            Symbol lid = TreeInfo.symbol(s.selected);\n-            if (lid != null && lid.kind == TYP) return builder.build(lval);\n-            return abstractRval(s.selected, selected -> builder.build(make.Select(selected, s.sym)));\n-        }\n-        case INDEXED: {\n-            final JCArrayAccess i = (JCArrayAccess)lval;\n-            return abstractRval(i.indexed, indexed -> abstractRval(i.index, syms.intType, index -> {\n-                JCExpression newLval = make.Indexed(indexed, index);\n-                newLval.setType(i.type);\n-                return builder.build(newLval);\n-            }));\n-        }\n-        case TYPECAST: {\n-            return abstractLval(((JCTypeCast)lval).expr, builder);\n-        }\n-        }\n-        throw new AssertionError(lval);\n-    }\n-\n-    \/\/ evaluate and discard the first expression, then evaluate the second.\n-    JCExpression makeComma(final JCExpression expr1, final JCExpression expr2) {\n-        JCExpression res = make.LetExpr(List.of(make.Exec(expr1)), expr2);\n-        res.type = expr2.type;\n-        return res;\n-    }\n-\n-\/**************************************************************************\n- * Translation methods\n- *************************************************************************\/\n-\n-    \/** Visitor argument: enclosing operator node.\n-     *\/\n-    private JCExpression enclOp;\n-\n-    \/** Visitor method: Translate a single node.\n-     *  Attach the source position from the old tree to its replacement tree.\n-     *\/\n-    @Override\n-    public <T extends JCTree> T translate(T tree) {\n-        if (tree == null) {\n-            return null;\n-        } else {\n-            make_at(tree.pos());\n-            T result = super.translate(tree);\n-            if (endPosTable != null && result != tree) {\n-                endPosTable.replaceTree(tree, result);\n-            }\n-            return result;\n-        }\n-    }\n-\n-    \/** Visitor method: Translate a single node, boxing or unboxing if needed.\n-     *\/\n-    public <T extends JCExpression> T translate(T tree, Type type) {\n-        return (tree == null) ? null : boxIfNeeded(translate(tree), type);\n-    }\n-\n-    \/** Visitor method: Translate tree.\n-     *\/\n-    public <T extends JCTree> T translate(T tree, JCExpression enclOp) {\n-        JCExpression prevEnclOp = this.enclOp;\n-        this.enclOp = enclOp;\n-        T res = translate(tree);\n-        this.enclOp = prevEnclOp;\n-        return res;\n-    }\n-\n-    \/** Visitor method: Translate list of trees.\n-     *\/\n-    public <T extends JCExpression> List<T> translate(List<T> trees, Type type) {\n-        if (trees == null) return null;\n-        for (List<T> l = trees; l.nonEmpty(); l = l.tail)\n-            l.head = translate(l.head, type);\n-        return trees;\n-    }\n-\n-    public void visitPackageDef(JCPackageDecl tree) {\n-        if (!needPackageInfoClass(tree))\n-                        return;\n-\n-        long flags = Flags.ABSTRACT | Flags.INTERFACE;\n-        \/\/ package-info is marked SYNTHETIC in JDK 1.6 and later releases\n-        flags = flags | Flags.SYNTHETIC;\n-        ClassSymbol c = tree.packge.package_info;\n-        c.setAttributes(tree.packge);\n-        c.flags_field |= flags;\n-        ClassType ctype = (ClassType) c.type;\n-        ctype.supertype_field = syms.objectType;\n-        ctype.interfaces_field = List.nil();\n-        createInfoClass(tree.annotations, c);\n-    }\n-    \/\/ where\n-    private boolean needPackageInfoClass(JCPackageDecl pd) {\n-        switch (pkginfoOpt) {\n-            case ALWAYS:\n-                return true;\n-            case LEGACY:\n-                return pd.getAnnotations().nonEmpty();\n-            case NONEMPTY:\n-                for (Attribute.Compound a :\n-                         pd.packge.getDeclarationAttributes()) {\n-                    Attribute.RetentionPolicy p = types.getRetention(a);\n-                    if (p != Attribute.RetentionPolicy.SOURCE)\n-                        return true;\n-                }\n-                return false;\n-        }\n-        throw new AssertionError();\n-    }\n-\n-    public void visitModuleDef(JCModuleDecl tree) {\n-        ModuleSymbol msym = tree.sym;\n-        ClassSymbol c = msym.module_info;\n-        c.setAttributes(msym);\n-        c.flags_field |= Flags.MODULE;\n-        createInfoClass(List.nil(), tree.sym.module_info);\n-    }\n-\n-    private void createInfoClass(List<JCAnnotation> annots, ClassSymbol c) {\n-        long flags = Flags.ABSTRACT | Flags.INTERFACE;\n-        JCClassDecl infoClass =\n-                make.ClassDef(make.Modifiers(flags, annots),\n-                    c.name, List.nil(),\n-                    null, List.nil(), List.nil());\n-        infoClass.sym = c;\n-        translated.append(infoClass);\n-    }\n-\n-    public void visitClassDef(JCClassDecl tree) {\n-        Env<AttrContext> prevEnv = attrEnv;\n-        ClassSymbol currentClassPrev = currentClass;\n-        MethodSymbol currentMethodSymPrev = currentMethodSym;\n-\n-        currentClass = tree.sym;\n-        currentMethodSym = null;\n-        attrEnv = typeEnvs.remove(currentClass);\n-        if (attrEnv == null)\n-            attrEnv = prevEnv;\n-\n-        classdefs.put(currentClass, tree);\n-\n-        Map<Symbol, Symbol> prevProxies = proxies;\n-        proxies = new HashMap<>(proxies);\n-        List<VarSymbol> prevOuterThisStack = outerThisStack;\n-\n-        \/\/ If this is an enum definition\n-        if ((tree.mods.flags & ENUM) != 0 &&\n-            (types.supertype(currentClass.type).tsym.flags() & ENUM) == 0)\n-            visitEnumDef(tree);\n-\n-        if ((tree.mods.flags & RECORD) != 0) {\n-            visitRecordDef(tree);\n-        }\n-\n-        \/\/ If this is a nested class, define a this$n field for\n-        \/\/ it and add to proxies.\n-        JCVariableDecl otdef = null;\n-        if (currentClass.hasOuterInstance())\n-            otdef = outerThisDef(tree.pos, currentClass);\n-\n-        \/\/ If this is a local class, define proxies for all its free variables.\n-        List<JCVariableDecl> fvdefs = freevarDefs(\n-            tree.pos, freevars(currentClass), currentClass);\n-\n-        \/\/ Recursively translate superclass, interfaces.\n-        tree.extending = translate(tree.extending);\n-        tree.implementing = translate(tree.implementing);\n-\n-        if (currentClass.isDirectlyOrIndirectlyLocal()) {\n-            ClassSymbol encl = currentClass.owner.enclClass();\n-            if (encl.trans_local == null) {\n-                encl.trans_local = List.nil();\n-            }\n-            encl.trans_local = encl.trans_local.prepend(currentClass);\n-        }\n-\n-        \/\/ Recursively translate members, taking into account that new members\n-        \/\/ might be created during the translation and prepended to the member\n-        \/\/ list `tree.defs'.\n-        List<JCTree> seen = List.nil();\n-        while (tree.defs != seen) {\n-            List<JCTree> unseen = tree.defs;\n-            for (List<JCTree> l = unseen; l.nonEmpty() && l != seen; l = l.tail) {\n-                JCTree outermostMemberDefPrev = outermostMemberDef;\n-                if (outermostMemberDefPrev == null) outermostMemberDef = l.head;\n-                l.head = translate(l.head);\n-                outermostMemberDef = outermostMemberDefPrev;\n-            }\n-            seen = unseen;\n-        }\n-\n-        \/\/ Convert a protected modifier to public, mask static modifier.\n-        if ((tree.mods.flags & PROTECTED) != 0) tree.mods.flags |= PUBLIC;\n-        tree.mods.flags &= ClassFlags;\n-\n-        \/\/ Convert name to flat representation, replacing '.' by '$'.\n-        tree.name = Convert.shortName(currentClass.flatName());\n-\n-        \/\/ Add free variables proxy definitions to class.\n-\n-        for (List<JCVariableDecl> l = fvdefs; l.nonEmpty(); l = l.tail) {\n-            tree.defs = tree.defs.prepend(l.head);\n-            enterSynthetic(tree.pos(), l.head.sym, currentClass.members());\n-        }\n-        \/\/ If this$n was accessed, add the field definition and\n-        \/\/ update initial constructors to initialize it\n-        if (currentClass.hasOuterInstance() && shouldEmitOuterThis(currentClass)) {\n-            tree.defs = tree.defs.prepend(otdef);\n-            enterSynthetic(tree.pos(), otdef.sym, currentClass.members());\n-\n-           for (JCTree def : tree.defs) {\n-                if (TreeInfo.isInitialConstructor(def)) {\n-                  JCMethodDecl mdef = (JCMethodDecl) def;\n-                  mdef.body.stats = mdef.body.stats.prepend(\n-                      initOuterThis(mdef.body.pos, mdef.params.head.sym));\n-                }\n-            }\n-        }\n-\n-        proxies = prevProxies;\n-        outerThisStack = prevOuterThisStack;\n-\n-        \/\/ Append translated tree to `translated' queue.\n-        translated.append(tree);\n-\n-        attrEnv = prevEnv;\n-        currentClass = currentClassPrev;\n-        currentMethodSym = currentMethodSymPrev;\n-\n-        \/\/ Return empty block {} as a placeholder for an inner class.\n-        result = make_at(tree.pos()).Block(SYNTHETIC, List.nil());\n-    }\n-\n-    private boolean shouldEmitOuterThis(ClassSymbol sym) {\n-      if (!optimizeOuterThis) {\n-        \/\/ Optimization is disabled\n-        return true;\n-      }\n-      if ((outerThisStack.head.flags_field & NOOUTERTHIS) == 0)  {\n-        \/\/ Enclosing instance field is used\n-        return true;\n-      }\n-      if (rs.isSerializable(sym.type)) {\n-        \/\/ Class is serializable\n-        return true;\n-      }\n-      return false;\n-    }\n-\n-    List<JCTree> generateMandatedAccessors(JCClassDecl tree) {\n-        List<JCVariableDecl> fields = TreeInfo.recordFields(tree);\n-        return tree.sym.getRecordComponents().stream()\n-                .filter(rc -> (rc.accessor.flags() & Flags.GENERATED_MEMBER) != 0)\n-                .map(rc -> {\n-                    \/\/ we need to return the field not the record component\n-                    JCVariableDecl field = fields.stream().filter(f -> f.name == rc.name).findAny().get();\n-                    make_at(tree.pos());\n-                    return make.MethodDef(rc.accessor, make.Block(0,\n-                            List.of(make.Return(make.Ident(field)))));\n-                }).collect(List.collector());\n-    }\n-\n-    \/** Translate an enum class. *\/\n-    private void visitEnumDef(JCClassDecl tree) {\n-        make_at(tree.pos());\n-\n-        \/\/ add the supertype, if needed\n-        if (tree.extending == null)\n-            tree.extending = make.Type(types.supertype(tree.type));\n-\n-        \/\/ classOfType adds a cache field to tree.defs\n-        JCExpression e_class = classOfType(tree.sym.type, tree.pos()).\n-            setType(types.erasure(syms.classType));\n-\n-        \/\/ process each enumeration constant, adding implicit constructor parameters\n-        int nextOrdinal = 0;\n-        ListBuffer<JCExpression> values = new ListBuffer<>();\n-        ListBuffer<JCTree> enumDefs = new ListBuffer<>();\n-        ListBuffer<JCTree> otherDefs = new ListBuffer<>();\n-        for (List<JCTree> defs = tree.defs;\n-             defs.nonEmpty();\n-             defs=defs.tail) {\n-            if (defs.head.hasTag(VARDEF) && (((JCVariableDecl) defs.head).mods.flags & ENUM) != 0) {\n-                JCVariableDecl var = (JCVariableDecl)defs.head;\n-                visitEnumConstantDef(var, nextOrdinal++);\n-                values.append(make.QualIdent(var.sym));\n-                enumDefs.append(var);\n-            } else {\n-                otherDefs.append(defs.head);\n-            }\n-        }\n-\n-        \/\/ synthetic private static T[] $values() { return new T[] { a, b, c }; }\n-        \/\/ synthetic private static final T[] $VALUES = $values();\n-        Name valuesName = syntheticName(tree, \"VALUES\");\n-        Type arrayType = new ArrayType(types.erasure(tree.type), syms.arrayClass);\n-        VarSymbol valuesVar = new VarSymbol(PRIVATE|FINAL|STATIC|SYNTHETIC,\n-                                            valuesName,\n-                                            arrayType,\n-                                            tree.type.tsym);\n-        JCNewArray newArray = make.NewArray(make.Type(types.erasure(tree.type)),\n-                                          List.nil(),\n-                                          values.toList());\n-        newArray.type = arrayType;\n-\n-        MethodSymbol valuesMethod = new MethodSymbol(PRIVATE|STATIC|SYNTHETIC,\n-                syntheticName(tree, \"values\"),\n-                new MethodType(List.nil(), arrayType, List.nil(), tree.type.tsym),\n-                tree.type.tsym);\n-        enumDefs.append(make.MethodDef(valuesMethod, make.Block(0, List.of(make.Return(newArray)))));\n-        tree.sym.members().enter(valuesMethod);\n-\n-        enumDefs.append(make.VarDef(valuesVar, make.App(make.QualIdent(valuesMethod))));\n-        tree.sym.members().enter(valuesVar);\n-\n-        MethodSymbol valuesSym = lookupMethod(tree.pos(), names.values,\n-                                        tree.type, List.nil());\n-        List<JCStatement> valuesBody;\n-        if (useClone()) {\n-            \/\/ return (T[]) $VALUES.clone();\n-            JCTypeCast valuesResult =\n-                make.TypeCast(valuesSym.type.getReturnType(),\n-                              make.App(make.Select(make.Ident(valuesVar),\n-                                                   syms.arrayCloneMethod)));\n-            valuesBody = List.of(make.Return(valuesResult));\n-        } else {\n-            \/\/ template: T[] $result = new T[$values.length];\n-            Name resultName = syntheticName(tree, \"result\");\n-            VarSymbol resultVar = new VarSymbol(FINAL|SYNTHETIC,\n-                                                resultName,\n-                                                arrayType,\n-                                                valuesSym);\n-            JCNewArray resultArray = make.NewArray(make.Type(types.erasure(tree.type)),\n-                                  List.of(make.Select(make.Ident(valuesVar), syms.lengthVar)),\n-                                  null);\n-            resultArray.type = arrayType;\n-            JCVariableDecl decl = make.VarDef(resultVar, resultArray);\n-\n-            \/\/ template: System.arraycopy($VALUES, 0, $result, 0, $VALUES.length);\n-            if (systemArraycopyMethod == null) {\n-                systemArraycopyMethod =\n-                    new MethodSymbol(PUBLIC | STATIC,\n-                                     names.fromString(\"arraycopy\"),\n-                                     new MethodType(List.of(syms.objectType,\n-                                                            syms.intType,\n-                                                            syms.objectType,\n-                                                            syms.intType,\n-                                                            syms.intType),\n-                                                    syms.voidType,\n-                                                    List.nil(),\n-                                                    syms.methodClass),\n-                                     syms.systemType.tsym);\n-            }\n-            JCStatement copy =\n-                make.Exec(make.App(make.Select(make.Ident(syms.systemType.tsym),\n-                                               systemArraycopyMethod),\n-                          List.of(make.Ident(valuesVar), make.Literal(0),\n-                                  make.Ident(resultVar), make.Literal(0),\n-                                  make.Select(make.Ident(valuesVar), syms.lengthVar))));\n-\n-            \/\/ template: return $result;\n-            JCStatement ret = make.Return(make.Ident(resultVar));\n-            valuesBody = List.of(decl, copy, ret);\n-        }\n-\n-        JCMethodDecl valuesDef =\n-             make.MethodDef(valuesSym, make.Block(0, valuesBody));\n-\n-        enumDefs.append(valuesDef);\n-\n-        if (debugLower)\n-            System.err.println(tree.sym + \".valuesDef = \" + valuesDef);\n-\n-        \/** The template for the following code is:\n-         *\n-         *     public static E valueOf(String name) {\n-         *         return (E)Enum.valueOf(E.class, name);\n-         *     }\n-         *\n-         *  where E is tree.sym\n-         *\/\n-        MethodSymbol valueOfSym = lookupMethod(tree.pos(),\n-                         names.valueOf,\n-                         tree.sym.type,\n-                         List.of(syms.stringType));\n-        Assert.check((valueOfSym.flags() & STATIC) != 0);\n-        VarSymbol nameArgSym = valueOfSym.params.head;\n-        JCIdent nameVal = make.Ident(nameArgSym);\n-        JCStatement enum_ValueOf =\n-            make.Return(make.TypeCast(tree.sym.type,\n-                                      makeCall(make.Ident(syms.enumSym),\n-                                               names.valueOf,\n-                                               List.of(e_class, nameVal))));\n-        JCMethodDecl valueOf = make.MethodDef(valueOfSym,\n-                                           make.Block(0, List.of(enum_ValueOf)));\n-        nameVal.sym = valueOf.params.head.sym;\n-        if (debugLower)\n-            System.err.println(tree.sym + \".valueOf = \" + valueOf);\n-        enumDefs.append(valueOf);\n-\n-        enumDefs.appendList(otherDefs.toList());\n-        tree.defs = enumDefs.toList();\n-    }\n-        \/\/ where\n-        private MethodSymbol systemArraycopyMethod;\n-        private boolean useClone() {\n-            try {\n-                return syms.objectType.tsym.members().findFirst(names.clone) != null;\n-            }\n-            catch (CompletionFailure e) {\n-                return false;\n-            }\n-        }\n-\n-        private Name syntheticName(JCClassDecl tree, String baseName) {\n-            Name valuesName = names.fromString(target.syntheticNameChar() + baseName);\n-            while (tree.sym.members().findFirst(valuesName) != null) \/\/ avoid name clash\n-                valuesName = names.fromString(valuesName + \"\" + target.syntheticNameChar());\n-            return valuesName;\n-        }\n-\n-    \/** Translate an enumeration constant and its initializer. *\/\n-    private void visitEnumConstantDef(JCVariableDecl var, int ordinal) {\n-        JCNewClass varDef = (JCNewClass)var.init;\n-        varDef.args = varDef.args.\n-            prepend(makeLit(syms.intType, ordinal)).\n-            prepend(makeLit(syms.stringType, var.name.toString()));\n-    }\n-\n-    private List<VarSymbol> recordVars(Type t) {\n-        List<VarSymbol> vars = List.nil();\n-        while (!t.hasTag(NONE)) {\n-            if (t.hasTag(CLASS)) {\n-                for (Symbol s : t.tsym.members().getSymbols(s -> s.kind == VAR && (s.flags() & RECORD) != 0)) {\n-                    vars = vars.prepend((VarSymbol)s);\n-                }\n-            }\n-            t = types.supertype(t);\n-        }\n-        return vars;\n-    }\n-\n-    \/** Translate a record. *\/\n-    private void visitRecordDef(JCClassDecl tree) {\n-        make_at(tree.pos());\n-        List<VarSymbol> vars = recordVars(tree.type);\n-        MethodHandleSymbol[] getterMethHandles = new MethodHandleSymbol[vars.size()];\n-        int index = 0;\n-        for (VarSymbol var : vars) {\n-            if (var.owner != tree.sym) {\n-                var = new VarSymbol(var.flags_field, var.name, var.type, tree.sym);\n-            }\n-            getterMethHandles[index] = var.asMethodHandle(true);\n-            index++;\n-        }\n-\n-        tree.defs = tree.defs.appendList(generateMandatedAccessors(tree));\n-        tree.defs = tree.defs.appendList(List.of(\n-                generateRecordMethod(tree, names.toString, vars, getterMethHandles),\n-                generateRecordMethod(tree, names.hashCode, vars, getterMethHandles),\n-                generateRecordMethod(tree, names.equals, vars, getterMethHandles)\n-        ));\n-    }\n-\n-    JCTree generateRecordMethod(JCClassDecl tree, Name name, List<VarSymbol> vars, MethodHandleSymbol[] getterMethHandles) {\n-        make_at(tree.pos());\n-        boolean isEquals = name == names.equals;\n-        MethodSymbol msym = lookupMethod(tree.pos(),\n-                name,\n-                tree.sym.type,\n-                isEquals ? List.of(syms.objectType) : List.nil());\n-        \/\/ compiler generated methods have the record flag set, user defined ones dont\n-        if ((msym.flags() & RECORD) != 0) {\n-            \/* class java.lang.runtime.ObjectMethods provides a common bootstrap that provides a customized implementation\n-             * for methods: toString, hashCode and equals. Here we just need to generate and indy call to:\n-             * java.lang.runtime.ObjectMethods::bootstrap and provide: the record class, the record component names and\n-             * the accessors.\n-             *\/\n-            Name bootstrapName = names.bootstrap;\n-            LoadableConstant[] staticArgsValues = new LoadableConstant[2 + getterMethHandles.length];\n-            staticArgsValues[0] = (ClassType)tree.sym.type;\n-            String concatNames = vars.stream()\n-                    .map(v -> v.name)\n-                    .collect(Collectors.joining(\";\", \"\", \"\"));\n-            staticArgsValues[1] = LoadableConstant.String(concatNames);\n-            int index = 2;\n-            for (MethodHandleSymbol mho : getterMethHandles) {\n-                staticArgsValues[index] = mho;\n-                index++;\n-            }\n-\n-            List<Type> staticArgTypes = List.of(syms.classType,\n-                    syms.stringType,\n-                    new ArrayType(syms.methodHandleType, syms.arrayClass));\n-\n-            JCFieldAccess qualifier = makeIndyQualifier(syms.objectMethodsType, tree, msym,\n-                    List.of(syms.methodHandleLookupType,\n-                            syms.stringType,\n-                            syms.typeDescriptorType).appendList(staticArgTypes),\n-                    staticArgsValues, bootstrapName, name, false);\n-\n-            VarSymbol _this = new VarSymbol(SYNTHETIC, names._this, tree.sym.type, tree.sym);\n-\n-            JCMethodInvocation proxyCall;\n-            if (!isEquals) {\n-                proxyCall = make.Apply(List.nil(), qualifier, List.of(make.Ident(_this)));\n-            } else {\n-                VarSymbol o = msym.params.head;\n-                o.adr = 0;\n-                proxyCall = make.Apply(List.nil(), qualifier, List.of(make.Ident(_this), make.Ident(o)));\n-            }\n-            proxyCall.type = qualifier.type;\n-            return make.MethodDef(msym, make.Block(0, List.of(make.Return(proxyCall))));\n-        } else {\n-            return make.Block(SYNTHETIC, List.nil());\n-        }\n-    }\n-\n-    private String argsTypeSig(List<Type> typeList) {\n-        LowerSignatureGenerator sg = new LowerSignatureGenerator();\n-        sg.assembleSig(typeList);\n-        return sg.toString();\n-    }\n-\n-    \/**\n-     * Signature Generation\n-     *\/\n-    private class LowerSignatureGenerator extends Types.SignatureGenerator {\n-\n-        \/**\n-         * An output buffer for type signatures.\n-         *\/\n-        StringBuilder sb = new StringBuilder();\n-\n-        LowerSignatureGenerator() {\n-            super(types);\n-        }\n-\n-        @Override\n-        protected void append(char ch) {\n-            sb.append(ch);\n-        }\n-\n-        @Override\n-        protected void append(byte[] ba) {\n-            sb.append(new String(ba));\n-        }\n-\n-        @Override\n-        protected void append(Name name) {\n-            sb.append(name.toString());\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return sb.toString();\n-        }\n-    }\n-\n-    \/**\n-     * Creates an indy qualifier, helpful to be part of an indy invocation\n-     * @param site                the site\n-     * @param tree                a class declaration tree\n-     * @param msym                the method symbol\n-     * @param staticArgTypes      the static argument types\n-     * @param staticArgValues     the static argument values\n-     * @param bootstrapName       the bootstrap name to look for\n-     * @param argName             normally bootstraps receives a method name as second argument, if you want that name\n-     *                            to be different to that of the bootstrap name pass a different name here\n-     * @param isStatic            is it static or not\n-     * @return                    a field access tree\n-     *\/\n-    JCFieldAccess makeIndyQualifier(\n-            Type site,\n-            JCClassDecl tree,\n-            MethodSymbol msym,\n-            List<Type> staticArgTypes,\n-            LoadableConstant[] staticArgValues,\n-            Name bootstrapName,\n-            Name argName,\n-            boolean isStatic) {\n-        MethodSymbol bsm = rs.resolveInternalMethod(tree.pos(), attrEnv, site,\n-                bootstrapName, staticArgTypes, List.nil());\n-\n-        MethodType indyType = msym.type.asMethodType();\n-        indyType = new MethodType(\n-                isStatic ? List.nil() : indyType.argtypes.prepend(tree.sym.type),\n-                indyType.restype,\n-                indyType.thrown,\n-                syms.methodClass\n-        );\n-        DynamicMethodSymbol dynSym = new DynamicMethodSymbol(argName,\n-                syms.noSymbol,\n-                bsm.asHandle(),\n-                indyType,\n-                staticArgValues);\n-        JCFieldAccess qualifier = make.Select(make.QualIdent(site.tsym), argName);\n-        qualifier.sym = dynSym;\n-        qualifier.type = msym.type.asMethodType().restype;\n-        return qualifier;\n-    }\n-\n-    public void visitMethodDef(JCMethodDecl tree) {\n-        if (tree.name == names.init && (currentClass.flags_field&ENUM) != 0) {\n-            \/\/ Add \"String $enum$name, int $enum$ordinal\" to the beginning of the\n-            \/\/ argument list for each constructor of an enum.\n-            JCVariableDecl nameParam = make_at(tree.pos()).\n-                Param(names.fromString(target.syntheticNameChar() +\n-                                       \"enum\" + target.syntheticNameChar() + \"name\"),\n-                      syms.stringType, tree.sym);\n-            nameParam.mods.flags |= SYNTHETIC; nameParam.sym.flags_field |= SYNTHETIC;\n-            JCVariableDecl ordParam = make.\n-                Param(names.fromString(target.syntheticNameChar() +\n-                                       \"enum\" + target.syntheticNameChar() +\n-                                       \"ordinal\"),\n-                      syms.intType, tree.sym);\n-            ordParam.mods.flags |= SYNTHETIC; ordParam.sym.flags_field |= SYNTHETIC;\n-\n-            MethodSymbol m = tree.sym;\n-            tree.params = tree.params.prepend(ordParam).prepend(nameParam);\n-\n-            m.extraParams = m.extraParams.prepend(ordParam.sym);\n-            m.extraParams = m.extraParams.prepend(nameParam.sym);\n-            Type olderasure = m.erasure(types);\n-            m.erasure_field = new MethodType(\n-                olderasure.getParameterTypes().prepend(syms.intType).prepend(syms.stringType),\n-                olderasure.getReturnType(),\n-                olderasure.getThrownTypes(),\n-                syms.methodClass);\n-        }\n-\n-        JCMethodDecl prevMethodDef = currentMethodDef;\n-        MethodSymbol prevMethodSym = currentMethodSym;\n-        try {\n-            currentMethodDef = tree;\n-            currentMethodSym = tree.sym;\n-            visitMethodDefInternal(tree);\n-        } finally {\n-            currentMethodDef = prevMethodDef;\n-            currentMethodSym = prevMethodSym;\n-        }\n-    }\n-\n-    private void visitMethodDefInternal(JCMethodDecl tree) {\n-        if (tree.name == names.init &&\n-            !currentClass.isStatic() &&\n-            (currentClass.isInner() || currentClass.isDirectlyOrIndirectlyLocal())) {\n-            \/\/ We are seeing a constructor of an inner class.\n-            MethodSymbol m = tree.sym;\n-\n-            \/\/ Push a new proxy scope for constructor parameters.\n-            \/\/ and create definitions for any this$n and proxy parameters.\n-            Map<Symbol, Symbol> prevProxies = proxies;\n-            proxies = new HashMap<>(proxies);\n-            List<VarSymbol> prevOuterThisStack = outerThisStack;\n-            List<VarSymbol> fvs = freevars(currentClass);\n-            JCVariableDecl otdef = null;\n-            if (currentClass.hasOuterInstance())\n-                otdef = outerThisDef(tree.pos, m);\n-            List<JCVariableDecl> fvdefs = freevarDefs(tree.pos, fvs, m, PARAMETER);\n-\n-            \/\/ Recursively translate result type, parameters and thrown list.\n-            tree.restype = translate(tree.restype);\n-            tree.params = translateVarDefs(tree.params);\n-            tree.thrown = translate(tree.thrown);\n-\n-            \/\/ when compiling stubs, don't process body\n-            if (tree.body == null) {\n-                result = tree;\n-                return;\n-            }\n-\n-            \/\/ Add this$n (if needed) in front of and free variables behind\n-            \/\/ constructor parameter list.\n-            tree.params = tree.params.appendList(fvdefs);\n-            if (currentClass.hasOuterInstance()) {\n-                tree.params = tree.params.prepend(otdef);\n-            }\n-\n-            \/\/ If this is an initial constructor, i.e., it does not start with\n-            \/\/ this(...), insert initializers for this$n and proxies\n-            \/\/ before (pre-1.4, after) the call to superclass constructor.\n-            JCStatement selfCall = translate(tree.body.stats.head);\n-\n-            List<JCStatement> added = List.nil();\n-            if (fvs.nonEmpty()) {\n-                List<Type> addedargtypes = List.nil();\n-                for (List<VarSymbol> l = fvs; l.nonEmpty(); l = l.tail) {\n-                    m.capturedLocals =\n-                        m.capturedLocals.prepend((VarSymbol)\n-                                                (proxies.get(l.head)));\n-                    if (TreeInfo.isInitialConstructor(tree)) {\n-                        added = added.prepend(\n-                          initField(tree.body.pos, proxies.get(l.head), prevProxies.get(l.head)));\n-                    }\n-                    addedargtypes = addedargtypes.prepend(l.head.erasure(types));\n-                }\n-                Type olderasure = m.erasure(types);\n-                m.erasure_field = new MethodType(\n-                    olderasure.getParameterTypes().appendList(addedargtypes),\n-                    olderasure.getReturnType(),\n-                    olderasure.getThrownTypes(),\n-                    syms.methodClass);\n-            }\n-\n-            \/\/ pop local variables from proxy stack\n-            proxies = prevProxies;\n-\n-            \/\/ recursively translate following local statements and\n-            \/\/ combine with this- or super-call\n-            List<JCStatement> stats = translate(tree.body.stats.tail);\n-            tree.body.stats = stats.prepend(selfCall).prependList(added);\n-            outerThisStack = prevOuterThisStack;\n-        } else {\n-            Map<Symbol, Symbol> prevLambdaTranslationMap =\n-                    lambdaTranslationMap;\n-            try {\n-                lambdaTranslationMap = (tree.sym.flags() & SYNTHETIC) != 0 &&\n-                        tree.sym.name.startsWith(names.lambda) ?\n-                        makeTranslationMap(tree) : null;\n-                super.visitMethodDef(tree);\n-            } finally {\n-                lambdaTranslationMap = prevLambdaTranslationMap;\n-            }\n-        }\n-        if (tree.name == names.init && (tree.sym.flags_field & Flags.COMPACT_RECORD_CONSTRUCTOR) != 0) {\n-            \/\/ lets find out if there is any field waiting to be initialized\n-            ListBuffer<VarSymbol> fields = new ListBuffer<>();\n-            for (Symbol sym : currentClass.getEnclosedElements()) {\n-                if (sym.kind == Kinds.Kind.VAR && ((sym.flags() & RECORD) != 0))\n-                    fields.append((VarSymbol) sym);\n-            }\n-            for (VarSymbol field: fields) {\n-                if ((field.flags_field & Flags.UNINITIALIZED_FIELD) != 0) {\n-                    VarSymbol param = tree.params.stream().filter(p -> p.name == field.name).findFirst().get().sym;\n-                    make.at(tree.pos);\n-                    tree.body.stats = tree.body.stats.append(\n-                            make.Exec(\n-                                    make.Assign(\n-                                            make.Select(make.This(field.owner.erasure(types)), field),\n-                                            make.Ident(param)).setType(field.erasure(types))));\n-                    \/\/ we don't need the flag at the field anymore\n-                    field.flags_field &= ~Flags.UNINITIALIZED_FIELD;\n-                }\n-            }\n-        }\n-        result = tree;\n-    }\n-    \/\/where\n-        private Map<Symbol, Symbol> makeTranslationMap(JCMethodDecl tree) {\n-            Map<Symbol, Symbol> translationMap = new HashMap<>();\n-            for (JCVariableDecl vd : tree.params) {\n-                Symbol p = vd.sym;\n-                if (p != p.baseSymbol()) {\n-                    translationMap.put(p.baseSymbol(), p);\n-                }\n-            }\n-            return translationMap;\n-        }\n-\n-    public void visitTypeCast(JCTypeCast tree) {\n-        tree.clazz = translate(tree.clazz);\n-        if (tree.type.isPrimitive() != tree.expr.type.isPrimitive())\n-            tree.expr = translate(tree.expr, tree.type);\n-        else\n-            tree.expr = translate(tree.expr);\n-        result = tree;\n-    }\n-\n-    public void visitNewClass(JCNewClass tree) {\n-        ClassSymbol c = (ClassSymbol)tree.constructor.owner;\n-\n-        \/\/ Box arguments, if necessary\n-        boolean isEnum = (tree.constructor.owner.flags() & ENUM) != 0;\n-        List<Type> argTypes = tree.constructor.type.getParameterTypes();\n-        if (isEnum) argTypes = argTypes.prepend(syms.intType).prepend(syms.stringType);\n-        tree.args = boxArgs(argTypes, tree.args, tree.varargsElement);\n-        tree.varargsElement = null;\n-\n-        \/\/ If created class is local, add free variables after\n-        \/\/ explicit constructor arguments.\n-        if (c.isDirectlyOrIndirectlyLocal() && !c.isStatic()) {\n-            tree.args = tree.args.appendList(loadFreevars(tree.pos(), freevars(c)));\n-        }\n-\n-        \/\/ If an access constructor is used, append null as a last argument.\n-        Symbol constructor = accessConstructor(tree.pos(), tree.constructor);\n-        if (constructor != tree.constructor) {\n-            tree.args = tree.args.append(makeNull());\n-            tree.constructor = constructor;\n-        }\n-\n-        \/\/ If created class has an outer instance, and new is qualified, pass\n-        \/\/ qualifier as first argument. If new is not qualified, pass the\n-        \/\/ correct outer instance as first argument.\n-        if (c.hasOuterInstance()) {\n-            JCExpression thisArg;\n-            if (tree.encl != null) {\n-                thisArg = attr.makeNullCheck(translate(tree.encl));\n-                thisArg.type = tree.encl.type;\n-            } else if (c.isDirectlyOrIndirectlyLocal()) {\n-                \/\/ local class\n-                thisArg = makeThis(tree.pos(), c.type.getEnclosingType().tsym);\n-            } else {\n-                \/\/ nested class\n-                thisArg = makeOwnerThis(tree.pos(), c, false);\n-            }\n-            tree.args = tree.args.prepend(thisArg);\n-        }\n-        tree.encl = null;\n-\n-        \/\/ If we have an anonymous class, create its flat version, rather\n-        \/\/ than the class or interface following new.\n-        if (tree.def != null) {\n-            Map<Symbol, Symbol> prevLambdaTranslationMap = lambdaTranslationMap;\n-            try {\n-                lambdaTranslationMap = null;\n-                translate(tree.def);\n-            } finally {\n-                lambdaTranslationMap = prevLambdaTranslationMap;\n-            }\n-\n-            tree.clazz = access(make_at(tree.clazz.pos()).Ident(tree.def.sym));\n-            tree.def = null;\n-        } else {\n-            tree.clazz = access(c, tree.clazz, enclOp, false);\n-        }\n-        result = tree;\n-    }\n-\n-    \/\/ Simplify conditionals with known constant controlling expressions.\n-    \/\/ This allows us to avoid generating supporting declarations for\n-    \/\/ the dead code, which will not be eliminated during code generation.\n-    \/\/ Note that Flow.isFalse and Flow.isTrue only return true\n-    \/\/ for constant expressions in the sense of JLS 15.27, which\n-    \/\/ are guaranteed to have no side-effects.  More aggressive\n-    \/\/ constant propagation would require that we take care to\n-    \/\/ preserve possible side-effects in the condition expression.\n-\n-    \/\/ One common case is equality expressions involving a constant and null.\n-    \/\/ Since null is not a constant expression (because null cannot be\n-    \/\/ represented in the constant pool), equality checks involving null are\n-    \/\/ not captured by Flow.isTrue\/isFalse.\n-    \/\/ Equality checks involving a constant and null, e.g.\n-    \/\/     \"\" == null\n-    \/\/ are safe to simplify as no side-effects can occur.\n-\n-    private boolean isTrue(JCTree exp) {\n-        if (exp.type.isTrue())\n-            return true;\n-        Boolean b = expValue(exp);\n-        return b == null ? false : b;\n-    }\n-    private boolean isFalse(JCTree exp) {\n-        if (exp.type.isFalse())\n-            return true;\n-        Boolean b = expValue(exp);\n-        return b == null ? false : !b;\n-    }\n-    \/* look for (in)equality relations involving null.\n-     * return true - if expression is always true\n-     *       false - if expression is always false\n-     *        null - if expression cannot be eliminated\n-     *\/\n-    private Boolean expValue(JCTree exp) {\n-        while (exp.hasTag(PARENS))\n-            exp = ((JCParens)exp).expr;\n-\n-        boolean eq;\n-        switch (exp.getTag()) {\n-        case EQ: eq = true;  break;\n-        case NE: eq = false; break;\n-        default:\n-            return null;\n-        }\n-\n-        \/\/ we have a JCBinary(EQ|NE)\n-        \/\/ check if we have two literals (constants or null)\n-        JCBinary b = (JCBinary)exp;\n-        if (b.lhs.type.hasTag(BOT)) return expValueIsNull(eq, b.rhs);\n-        if (b.rhs.type.hasTag(BOT)) return expValueIsNull(eq, b.lhs);\n-        return null;\n-    }\n-    private Boolean expValueIsNull(boolean eq, JCTree t) {\n-        if (t.type.hasTag(BOT)) return Boolean.valueOf(eq);\n-        if (t.hasTag(LITERAL))  return Boolean.valueOf(!eq);\n-        return null;\n-    }\n-\n-    \/** Visitor method for conditional expressions.\n-     *\/\n-    @Override\n-    public void visitConditional(JCConditional tree) {\n-        JCTree cond = tree.cond = translate(tree.cond, syms.booleanType);\n-        if (isTrue(cond)) {\n-            result = convert(translate(tree.truepart, tree.type), tree.type);\n-            addPrunedInfo(cond);\n-        } else if (isFalse(cond)) {\n-            result = convert(translate(tree.falsepart, tree.type), tree.type);\n-            addPrunedInfo(cond);\n-        } else {\n-            \/\/ Condition is not a compile-time constant.\n-            tree.truepart = translate(tree.truepart, tree.type);\n-            tree.falsepart = translate(tree.falsepart, tree.type);\n-            result = tree;\n-        }\n-    }\n-\/\/where\n-    private JCExpression convert(JCExpression tree, Type pt) {\n-        if (tree.type == pt || tree.type.hasTag(BOT))\n-            return tree;\n-        JCExpression result = make_at(tree.pos()).TypeCast(make.Type(pt), tree);\n-        result.type = (tree.type.constValue() != null) ? cfolder.coerce(tree.type, pt)\n-                                                       : pt;\n-        return result;\n-    }\n-\n-    \/** Visitor method for if statements.\n-     *\/\n-    public void visitIf(JCIf tree) {\n-        JCTree cond = tree.cond = translate(tree.cond, syms.booleanType);\n-        if (isTrue(cond)) {\n-            result = translate(tree.thenpart);\n-            addPrunedInfo(cond);\n-        } else if (isFalse(cond)) {\n-            if (tree.elsepart != null) {\n-                result = translate(tree.elsepart);\n-            } else {\n-                result = make.Skip();\n-            }\n-            addPrunedInfo(cond);\n-        } else {\n-            \/\/ Condition is not a compile-time constant.\n-            tree.thenpart = translate(tree.thenpart);\n-            tree.elsepart = translate(tree.elsepart);\n-            result = tree;\n-        }\n-    }\n-\n-    \/** Visitor method for assert statements. Translate them away.\n-     *\/\n-    public void visitAssert(JCAssert tree) {\n-        tree.cond = translate(tree.cond, syms.booleanType);\n-        if (!tree.cond.type.isTrue()) {\n-            JCExpression cond = assertFlagTest(tree.pos());\n-            List<JCExpression> exnArgs = (tree.detail == null) ?\n-                List.nil() : List.of(translate(tree.detail));\n-            if (!tree.cond.type.isFalse()) {\n-                cond = makeBinary\n-                    (AND,\n-                     cond,\n-                     makeUnary(NOT, tree.cond));\n-            }\n-            result =\n-                make.If(cond,\n-                        make_at(tree).\n-                           Throw(makeNewClass(syms.assertionErrorType, exnArgs)),\n-                        null);\n-        } else {\n-            result = make.Skip();\n-        }\n-    }\n-\n-    public void visitApply(JCMethodInvocation tree) {\n-        Symbol meth = TreeInfo.symbol(tree.meth);\n-        List<Type> argtypes = meth.type.getParameterTypes();\n-        if (meth.name == names.init && meth.owner == syms.enumSym)\n-            argtypes = argtypes.tail.tail;\n-        tree.args = boxArgs(argtypes, tree.args, tree.varargsElement);\n-        tree.varargsElement = null;\n-        Name methName = TreeInfo.name(tree.meth);\n-        if (meth.name==names.init) {\n-            \/\/ We are seeing a this(...) or super(...) constructor call.\n-            \/\/ If an access constructor is used, append null as a last argument.\n-            Symbol constructor = accessConstructor(tree.pos(), meth);\n-            if (constructor != meth) {\n-                tree.args = tree.args.append(makeNull());\n-                TreeInfo.setSymbol(tree.meth, constructor);\n-            }\n-\n-            \/\/ If we are calling a constructor of a local class, add\n-            \/\/ free variables after explicit constructor arguments.\n-            ClassSymbol c = (ClassSymbol)constructor.owner;\n-            if (c.isDirectlyOrIndirectlyLocal() && !c.isStatic()) {\n-                tree.args = tree.args.appendList(loadFreevars(tree.pos(), freevars(c)));\n-            }\n-\n-            \/\/ If we are calling a constructor of an enum class, pass\n-            \/\/ along the name and ordinal arguments\n-            if ((c.flags_field&ENUM) != 0 || c.getQualifiedName() == names.java_lang_Enum) {\n-                List<JCVariableDecl> params = currentMethodDef.params;\n-                if (currentMethodSym.owner.hasOuterInstance())\n-                    params = params.tail; \/\/ drop this$n\n-                tree.args = tree.args\n-                    .prepend(make_at(tree.pos()).Ident(params.tail.head.sym)) \/\/ ordinal\n-                    .prepend(make.Ident(params.head.sym)); \/\/ name\n-            }\n-\n-            \/\/ If we are calling a constructor of a class with an outer\n-            \/\/ instance, and the call\n-            \/\/ is qualified, pass qualifier as first argument in front of\n-            \/\/ the explicit constructor arguments. If the call\n-            \/\/ is not qualified, pass the correct outer instance as\n-            \/\/ first argument.\n-            if (c.hasOuterInstance()) {\n-                JCExpression thisArg;\n-                if (tree.meth.hasTag(SELECT)) {\n-                    thisArg = attr.\n-                        makeNullCheck(translate(((JCFieldAccess) tree.meth).selected));\n-                    tree.meth = make.Ident(constructor);\n-                    ((JCIdent) tree.meth).name = methName;\n-                } else if (c.isDirectlyOrIndirectlyLocal() || methName == names._this){\n-                    \/\/ local class or this() call\n-                    thisArg = makeThis(tree.meth.pos(), c.type.getEnclosingType().tsym);\n-                } else {\n-                    \/\/ super() call of nested class - never pick 'this'\n-                    thisArg = makeOwnerThisN(tree.meth.pos(), c, false);\n-                }\n-                tree.args = tree.args.prepend(thisArg);\n-            }\n-        } else {\n-            \/\/ We are seeing a normal method invocation; translate this as usual.\n-            tree.meth = translate(tree.meth);\n-\n-            \/\/ If the translated method itself is an Apply tree, we are\n-            \/\/ seeing an access method invocation. In this case, append\n-            \/\/ the method arguments to the arguments of the access method.\n-            if (tree.meth.hasTag(APPLY)) {\n-                JCMethodInvocation app = (JCMethodInvocation)tree.meth;\n-                app.args = tree.args.prependList(app.args);\n-                result = app;\n-                return;\n-            }\n-        }\n-        result = tree;\n-    }\n-\n-    List<JCExpression> boxArgs(List<Type> parameters, List<JCExpression> _args, Type varargsElement) {\n-        List<JCExpression> args = _args;\n-        if (parameters.isEmpty()) return args;\n-        boolean anyChanges = false;\n-        ListBuffer<JCExpression> result = new ListBuffer<>();\n-        while (parameters.tail.nonEmpty()) {\n-            JCExpression arg = translate(args.head, parameters.head);\n-            anyChanges |= (arg != args.head);\n-            result.append(arg);\n-            args = args.tail;\n-            parameters = parameters.tail;\n-        }\n-        Type parameter = parameters.head;\n-        if (varargsElement != null) {\n-            anyChanges = true;\n-            ListBuffer<JCExpression> elems = new ListBuffer<>();\n-            while (args.nonEmpty()) {\n-                JCExpression arg = translate(args.head, varargsElement);\n-                elems.append(arg);\n-                args = args.tail;\n-            }\n-            JCNewArray boxedArgs = make.NewArray(make.Type(varargsElement),\n-                                               List.nil(),\n-                                               elems.toList());\n-            boxedArgs.type = new ArrayType(varargsElement, syms.arrayClass);\n-            result.append(boxedArgs);\n-        } else {\n-            if (args.length() != 1) throw new AssertionError(args);\n-            JCExpression arg = translate(args.head, parameter);\n-            anyChanges |= (arg != args.head);\n-            result.append(arg);\n-            if (!anyChanges) return _args;\n-        }\n-        return result.toList();\n-    }\n-\n-    \/** Expand a boxing or unboxing conversion if needed. *\/\n-    @SuppressWarnings(\"unchecked\") \/\/ XXX unchecked\n-    <T extends JCExpression> T boxIfNeeded(T tree, Type type) {\n-        boolean havePrimitive = tree.type.isPrimitive();\n-        if (havePrimitive == type.isPrimitive())\n-            return tree;\n-        if (havePrimitive) {\n-            Type unboxedTarget = types.unboxedType(type);\n-            if (!unboxedTarget.hasTag(NONE)) {\n-                if (!types.isSubtype(tree.type, unboxedTarget)) \/\/e.g. Character c = 89;\n-                    tree.type = unboxedTarget.constType(tree.type.constValue());\n-                return (T)boxPrimitive(tree, types.erasure(type));\n-            } else {\n-                tree = (T)boxPrimitive(tree);\n-            }\n-        } else {\n-            tree = (T)unbox(tree, type);\n-        }\n-        return tree;\n-    }\n-\n-    \/** Box up a single primitive expression. *\/\n-    JCExpression boxPrimitive(JCExpression tree) {\n-        return boxPrimitive(tree, types.boxedClass(tree.type).type);\n-    }\n-\n-    \/** Box up a single primitive expression. *\/\n-    JCExpression boxPrimitive(JCExpression tree, Type box) {\n-        make_at(tree.pos());\n-        Symbol valueOfSym = lookupMethod(tree.pos(),\n-                                         names.valueOf,\n-                                         box,\n-                                         List.<Type>nil()\n-                                         .prepend(tree.type));\n-        return make.App(make.QualIdent(valueOfSym), List.of(tree));\n-    }\n-\n-    \/** Unbox an object to a primitive value. *\/\n-    JCExpression unbox(JCExpression tree, Type primitive) {\n-        Type unboxedType = types.unboxedType(tree.type);\n-        if (unboxedType.hasTag(NONE)) {\n-            unboxedType = primitive;\n-            if (!unboxedType.isPrimitive())\n-                throw new AssertionError(unboxedType);\n-            make_at(tree.pos());\n-            tree = make.TypeCast(types.boxedClass(unboxedType).type, tree);\n-        } else {\n-            \/\/ There must be a conversion from unboxedType to primitive.\n-            if (!types.isSubtype(unboxedType, primitive))\n-                throw new AssertionError(tree);\n-        }\n-        make_at(tree.pos());\n-        Symbol valueSym = lookupMethod(tree.pos(),\n-                                       unboxedType.tsym.name.append(names.Value), \/\/ x.intValue()\n-                                       tree.type,\n-                                       List.nil());\n-        return make.App(make.Select(tree, valueSym));\n-    }\n-\n-    \/** Visitor method for parenthesized expressions.\n-     *  If the subexpression has changed, omit the parens.\n-     *\/\n-    public void visitParens(JCParens tree) {\n-        JCTree expr = translate(tree.expr);\n-        result = ((expr == tree.expr) ? tree : expr);\n-    }\n-\n-    public void visitIndexed(JCArrayAccess tree) {\n-        tree.indexed = translate(tree.indexed);\n-        tree.index = translate(tree.index, syms.intType);\n-        result = tree;\n-    }\n-\n-    public void visitAssign(JCAssign tree) {\n-        tree.lhs = translate(tree.lhs, tree);\n-        tree.rhs = translate(tree.rhs, tree.lhs.type);\n-\n-        \/\/ If translated left hand side is an Apply, we are\n-        \/\/ seeing an access method invocation. In this case, append\n-        \/\/ right hand side as last argument of the access method.\n-        if (tree.lhs.hasTag(APPLY)) {\n-            JCMethodInvocation app = (JCMethodInvocation)tree.lhs;\n-            app.args = List.of(tree.rhs).prependList(app.args);\n-            result = app;\n-        } else {\n-            result = tree;\n-        }\n-    }\n-\n-    public void visitAssignop(final JCAssignOp tree) {\n-        final boolean boxingReq = !tree.lhs.type.isPrimitive() &&\n-            tree.operator.type.getReturnType().isPrimitive();\n-\n-        AssignopDependencyScanner depScanner = new AssignopDependencyScanner(tree);\n-        depScanner.scan(tree.rhs);\n-\n-        if (boxingReq || depScanner.dependencyFound) {\n-            \/\/ boxing required; need to rewrite as x = (unbox typeof x)(x op y);\n-            \/\/ or if x == (typeof x)z then z = (unbox typeof x)((typeof x)z op y)\n-            \/\/ (but without recomputing x)\n-            JCTree newTree = abstractLval(tree.lhs, lhs -> {\n-                Tag newTag = tree.getTag().noAssignOp();\n-                \/\/ Erasure (TransTypes) can change the type of\n-                \/\/ tree.lhs.  However, we can still get the\n-                \/\/ unerased type of tree.lhs as it is stored\n-                \/\/ in tree.type in Attr.\n-                OperatorSymbol newOperator = operators.resolveBinary(tree,\n-                                                              newTag,\n-                                                              tree.type,\n-                                                              tree.rhs.type);\n-                \/\/Need to use the \"lhs\" at two places, once on the future left hand side\n-                \/\/and once in the future binary operator. But further processing may change\n-                \/\/the components of the tree in place (see visitSelect for e.g. <Class>.super.<ident>),\n-                \/\/so cloning the tree to avoid interference between the uses:\n-                JCExpression expr = (JCExpression) lhs.clone();\n-                if (expr.type != tree.type)\n-                    expr = make.TypeCast(tree.type, expr);\n-                JCBinary opResult = make.Binary(newTag, expr, tree.rhs);\n-                opResult.operator = newOperator;\n-                opResult.type = newOperator.type.getReturnType();\n-                JCExpression newRhs = boxingReq ?\n-                    make.TypeCast(types.unboxedType(tree.type), opResult) :\n-                    opResult;\n-                return make.Assign(lhs, newRhs).setType(tree.type);\n-            });\n-            result = translate(newTree);\n-            return;\n-        }\n-        tree.lhs = translate(tree.lhs, tree);\n-        tree.rhs = translate(tree.rhs, tree.operator.type.getParameterTypes().tail.head);\n-\n-        \/\/ If translated left hand side is an Apply, we are\n-        \/\/ seeing an access method invocation. In this case, append\n-        \/\/ right hand side as last argument of the access method.\n-        if (tree.lhs.hasTag(APPLY)) {\n-            JCMethodInvocation app = (JCMethodInvocation)tree.lhs;\n-            \/\/ if operation is a += on strings,\n-            \/\/ make sure to convert argument to string\n-            JCExpression rhs = tree.operator.opcode == string_add\n-              ? makeString(tree.rhs)\n-              : tree.rhs;\n-            app.args = List.of(rhs).prependList(app.args);\n-            result = app;\n-        } else {\n-            result = tree;\n-        }\n-    }\n-\n-    class AssignopDependencyScanner extends TreeScanner {\n-\n-        Symbol sym;\n-        boolean dependencyFound = false;\n-\n-        AssignopDependencyScanner(JCAssignOp tree) {\n-            this.sym = TreeInfo.symbol(tree.lhs);\n-        }\n-\n-        @Override\n-        public void scan(JCTree tree) {\n-            if (tree != null && sym != null) {\n-                tree.accept(this);\n-            }\n-        }\n-\n-        @Override\n-        public void visitAssignop(JCAssignOp tree) {\n-            if (TreeInfo.symbol(tree.lhs) == sym) {\n-                dependencyFound = true;\n-                return;\n-            }\n-            super.visitAssignop(tree);\n-        }\n-\n-        @Override\n-        public void visitUnary(JCUnary tree) {\n-            if (TreeInfo.symbol(tree.arg) == sym) {\n-                dependencyFound = true;\n-                return;\n-            }\n-            super.visitUnary(tree);\n-        }\n-    }\n-\n-    \/** Lower a tree of the form e++ or e-- where e is an object type *\/\n-    JCExpression lowerBoxedPostop(final JCUnary tree) {\n-        \/\/ translate to tmp1=lval(e); tmp2=tmp1; tmp1 OP 1; tmp2\n-        \/\/ or\n-        \/\/ translate to tmp1=lval(e); tmp2=tmp1; (typeof tree)tmp1 OP 1; tmp2\n-        \/\/ where OP is += or -=\n-        final boolean cast = TreeInfo.skipParens(tree.arg).hasTag(TYPECAST);\n-        return abstractLval(tree.arg, tmp1 -> abstractRval(tmp1, tree.arg.type, tmp2 -> {\n-            Tag opcode = (tree.hasTag(POSTINC))\n-                ? PLUS_ASG : MINUS_ASG;\n-            \/\/\"tmp1\" and \"tmp2\" may refer to the same instance\n-            \/\/(for e.g. <Class>.super.<ident>). But further processing may\n-            \/\/change the components of the tree in place (see visitSelect),\n-            \/\/so cloning the tree to avoid interference between the two uses:\n-            JCExpression lhs = (JCExpression)tmp1.clone();\n-            lhs = cast\n-                ? make.TypeCast(tree.arg.type, lhs)\n-                : lhs;\n-            JCExpression update = makeAssignop(opcode,\n-                                         lhs,\n-                                         make.Literal(1));\n-            return makeComma(update, tmp2);\n-        }));\n-    }\n-\n-    public void visitUnary(JCUnary tree) {\n-        boolean isUpdateOperator = tree.getTag().isIncOrDecUnaryOp();\n-        if (isUpdateOperator && !tree.arg.type.isPrimitive()) {\n-            switch(tree.getTag()) {\n-            case PREINC:            \/\/ ++ e\n-                    \/\/ translate to e += 1\n-            case PREDEC:            \/\/ -- e\n-                    \/\/ translate to e -= 1\n-                {\n-                    JCTree.Tag opcode = (tree.hasTag(PREINC))\n-                        ? PLUS_ASG : MINUS_ASG;\n-                    JCAssignOp newTree = makeAssignop(opcode,\n-                                                    tree.arg,\n-                                                    make.Literal(1));\n-                    result = translate(newTree, tree.type);\n-                    return;\n-                }\n-            case POSTINC:           \/\/ e ++\n-            case POSTDEC:           \/\/ e --\n-                {\n-                    result = translate(lowerBoxedPostop(tree), tree.type);\n-                    return;\n-                }\n-            }\n-            throw new AssertionError(tree);\n-        }\n-\n-        tree.arg = boxIfNeeded(translate(tree.arg, tree), tree.type);\n-\n-        if (tree.hasTag(NOT) && tree.arg.type.constValue() != null) {\n-            tree.type = cfolder.fold1(bool_not, tree.arg.type);\n-        }\n-\n-        \/\/ If translated left hand side is an Apply, we are\n-        \/\/ seeing an access method invocation. In this case, return\n-        \/\/ that access method invocation as result.\n-        if (isUpdateOperator && tree.arg.hasTag(APPLY)) {\n-            result = tree.arg;\n-        } else {\n-            result = tree;\n-        }\n-    }\n-\n-    public void visitBinary(JCBinary tree) {\n-        List<Type> formals = tree.operator.type.getParameterTypes();\n-        JCTree lhs = tree.lhs = translate(tree.lhs, formals.head);\n-        switch (tree.getTag()) {\n-        case OR:\n-            if (isTrue(lhs)) {\n-                result = lhs;\n-                return;\n-            }\n-            if (isFalse(lhs)) {\n-                result = translate(tree.rhs, formals.tail.head);\n-                return;\n-            }\n-            break;\n-        case AND:\n-            if (isFalse(lhs)) {\n-                result = lhs;\n-                return;\n-            }\n-            if (isTrue(lhs)) {\n-                result = translate(tree.rhs, formals.tail.head);\n-                return;\n-            }\n-            break;\n-        }\n-        tree.rhs = translate(tree.rhs, formals.tail.head);\n-        result = tree;\n-    }\n-\n-    public void visitIdent(JCIdent tree) {\n-        result = access(tree.sym, tree, enclOp, false);\n-    }\n-\n-    \/** Translate away the foreach loop.  *\/\n-    public void visitForeachLoop(JCEnhancedForLoop tree) {\n-        if (types.elemtype(tree.expr.type) == null)\n-            visitIterableForeachLoop(tree);\n-        else\n-            visitArrayForeachLoop(tree);\n-    }\n-        \/\/ where\n-        \/**\n-         * A statement of the form\n-         *\n-         * <pre>\n-         *     for ( T v : arrayexpr ) stmt;\n-         * <\/pre>\n-         *\n-         * (where arrayexpr is of an array type) gets translated to\n-         *\n-         * <pre>{@code\n-         *     for ( { arraytype #arr = arrayexpr;\n-         *             int #len = array.length;\n-         *             int #i = 0; };\n-         *           #i < #len; i$++ ) {\n-         *         T v = arr$[#i];\n-         *         stmt;\n-         *     }\n-         * }<\/pre>\n-         *\n-         * where #arr, #len, and #i are freshly named synthetic local variables.\n-         *\/\n-        private void visitArrayForeachLoop(JCEnhancedForLoop tree) {\n-            make_at(tree.expr.pos());\n-            VarSymbol arraycache = new VarSymbol(SYNTHETIC,\n-                                                 names.fromString(\"arr\" + target.syntheticNameChar()),\n-                                                 tree.expr.type,\n-                                                 currentMethodSym);\n-            JCStatement arraycachedef = make.VarDef(arraycache, tree.expr);\n-            VarSymbol lencache = new VarSymbol(SYNTHETIC,\n-                                               names.fromString(\"len\" + target.syntheticNameChar()),\n-                                               syms.intType,\n-                                               currentMethodSym);\n-            JCStatement lencachedef = make.\n-                VarDef(lencache, make.Select(make.Ident(arraycache), syms.lengthVar));\n-            VarSymbol index = new VarSymbol(SYNTHETIC,\n-                                            names.fromString(\"i\" + target.syntheticNameChar()),\n-                                            syms.intType,\n-                                            currentMethodSym);\n-\n-            JCVariableDecl indexdef = make.VarDef(index, make.Literal(INT, 0));\n-            indexdef.init.type = indexdef.type = syms.intType.constType(0);\n-\n-            List<JCStatement> loopinit = List.of(arraycachedef, lencachedef, indexdef);\n-            JCBinary cond = makeBinary(LT, make.Ident(index), make.Ident(lencache));\n-\n-            JCExpressionStatement step = make.Exec(makeUnary(PREINC, make.Ident(index)));\n-\n-            Type elemtype = types.elemtype(tree.expr.type);\n-            JCExpression loopvarinit = make.Indexed(make.Ident(arraycache),\n-                                                    make.Ident(index)).setType(elemtype);\n-            JCVariableDecl loopvardef = (JCVariableDecl)make.VarDef(tree.var.mods,\n-                                                  tree.var.name,\n-                                                  tree.var.vartype,\n-                                                  loopvarinit).setType(tree.var.type);\n-            loopvardef.sym = tree.var.sym;\n-            JCBlock body = make.\n-                Block(0, List.of(loopvardef, tree.body));\n-\n-            result = translate(make.\n-                               ForLoop(loopinit,\n-                                       cond,\n-                                       List.of(step),\n-                                       body));\n-            patchTargets(body, tree, result);\n-        }\n-        \/** Patch up break and continue targets. *\/\n-        private void patchTargets(JCTree body, final JCTree src, final JCTree dest) {\n-            class Patcher extends TreeScanner {\n-                public void visitBreak(JCBreak tree) {\n-                    if (tree.target == src)\n-                        tree.target = dest;\n-                }\n-                public void visitYield(JCYield tree) {\n-                    if (tree.target == src)\n-                        tree.target = dest;\n-                    scan(tree.value);\n-                }\n-                public void visitContinue(JCContinue tree) {\n-                    if (tree.target == src)\n-                        tree.target = dest;\n-                }\n-                public void visitClassDef(JCClassDecl tree) {}\n-            }\n-            new Patcher().scan(body);\n-        }\n-        \/**\n-         * A statement of the form\n-         *\n-         * <pre>\n-         *     for ( T v : coll ) stmt ;\n-         * <\/pre>\n-         *\n-         * (where coll implements {@code Iterable<? extends T>}) gets translated to\n-         *\n-         * <pre>{@code\n-         *     for ( Iterator<? extends T> #i = coll.iterator(); #i.hasNext(); ) {\n-         *         T v = (T) #i.next();\n-         *         stmt;\n-         *     }\n-         * }<\/pre>\n-         *\n-         * where #i is a freshly named synthetic local variable.\n-         *\/\n-        private void visitIterableForeachLoop(JCEnhancedForLoop tree) {\n-            make_at(tree.expr.pos());\n-            Type iteratorTarget = syms.objectType;\n-            Type iterableType = types.asSuper(types.cvarUpperBound(tree.expr.type),\n-                                              syms.iterableType.tsym);\n-            if (iterableType.getTypeArguments().nonEmpty())\n-                iteratorTarget = types.erasure(iterableType.getTypeArguments().head);\n-            tree.expr.type = types.erasure(types.skipTypeVars(tree.expr.type, false));\n-            tree.expr = transTypes.coerce(attrEnv, tree.expr, types.erasure(iterableType));\n-            Symbol iterator = lookupMethod(tree.expr.pos(),\n-                                           names.iterator,\n-                                           tree.expr.type,\n-                                           List.nil());\n-            Assert.check(types.isSameType(types.erasure(types.asSuper(iterator.type.getReturnType(), syms.iteratorType.tsym)), types.erasure(syms.iteratorType)));\n-            VarSymbol itvar = new VarSymbol(SYNTHETIC, names.fromString(\"i\" + target.syntheticNameChar()),\n-                                            types.erasure(syms.iteratorType),\n-                                            currentMethodSym);\n-\n-             JCStatement init = make.\n-                VarDef(itvar, make.App(make.Select(tree.expr, iterator)\n-                     .setType(types.erasure(iterator.type))));\n-\n-            Symbol hasNext = lookupMethod(tree.expr.pos(),\n-                                          names.hasNext,\n-                                          itvar.type,\n-                                          List.nil());\n-            JCMethodInvocation cond = make.App(make.Select(make.Ident(itvar), hasNext));\n-            Symbol next = lookupMethod(tree.expr.pos(),\n-                                       names.next,\n-                                       itvar.type,\n-                                       List.nil());\n-            JCExpression vardefinit = make.App(make.Select(make.Ident(itvar), next));\n-            if (tree.var.type.isPrimitive())\n-                vardefinit = make.TypeCast(types.cvarUpperBound(iteratorTarget), vardefinit);\n-            else\n-                vardefinit = make.TypeCast(tree.var.type, vardefinit);\n-            JCVariableDecl indexDef = (JCVariableDecl)make.VarDef(tree.var.mods,\n-                                                  tree.var.name,\n-                                                  tree.var.vartype,\n-                                                  vardefinit).setType(tree.var.type);\n-            indexDef.sym = tree.var.sym;\n-            JCBlock body = make.Block(0, List.of(indexDef, tree.body));\n-            body.endpos = TreeInfo.endPos(tree.body);\n-            result = translate(make.\n-                ForLoop(List.of(init),\n-                        cond,\n-                        List.nil(),\n-                        body));\n-            patchTargets(body, tree, result);\n-        }\n-\n-    public void visitVarDef(JCVariableDecl tree) {\n-        MethodSymbol oldMethodSym = currentMethodSym;\n-        tree.mods = translate(tree.mods);\n-        tree.vartype = translate(tree.vartype);\n-        if (currentMethodSym == null) {\n-            \/\/ A class or instance field initializer.\n-            currentMethodSym =\n-                new MethodSymbol((tree.mods.flags&STATIC) | BLOCK,\n-                                 names.empty, null,\n-                                 currentClass);\n-        }\n-        if (tree.init != null) tree.init = translate(tree.init, tree.type);\n-        result = tree;\n-        currentMethodSym = oldMethodSym;\n-    }\n-\n-    public void visitBlock(JCBlock tree) {\n-        MethodSymbol oldMethodSym = currentMethodSym;\n-        if (currentMethodSym == null) {\n-            \/\/ Block is a static or instance initializer.\n-            currentMethodSym =\n-                new MethodSymbol(tree.flags | BLOCK,\n-                                 names.empty, null,\n-                                 currentClass);\n-        }\n-        super.visitBlock(tree);\n-        currentMethodSym = oldMethodSym;\n-    }\n-\n-    public void visitDoLoop(JCDoWhileLoop tree) {\n-        tree.body = translate(tree.body);\n-        tree.cond = translate(tree.cond, syms.booleanType);\n-        result = tree;\n-    }\n-\n-    public void visitWhileLoop(JCWhileLoop tree) {\n-        tree.cond = translate(tree.cond, syms.booleanType);\n-        tree.body = translate(tree.body);\n-        result = tree;\n-    }\n-\n-    public void visitForLoop(JCForLoop tree) {\n-        tree.init = translate(tree.init);\n-        if (tree.cond != null)\n-            tree.cond = translate(tree.cond, syms.booleanType);\n-        tree.step = translate(tree.step);\n-        tree.body = translate(tree.body);\n-        result = tree;\n-    }\n-\n-    public void visitReturn(JCReturn tree) {\n-        if (tree.expr != null)\n-            tree.expr = translate(tree.expr,\n-                                  types.erasure(currentMethodDef\n-                                                .restype.type));\n-        result = tree;\n-    }\n-\n-    public void visitSwitch(JCSwitch tree) {\n-        boolean matchException = tree.patternSwitch && !tree.wasEnumSelector;\n-        List<JCCase> cases = tree.patternSwitch ? addDefaultIfNeeded(matchException, tree.cases)\n-                                                : tree.cases;\n-        handleSwitch(tree, tree.selector, cases);\n-    }\n-\n-    @Override\n-    public void visitSwitchExpression(JCSwitchExpression tree) {\n-        boolean matchException = tree.patternSwitch && !tree.wasEnumSelector;\n-        List<JCCase> cases = addDefaultIfNeeded(matchException, tree.cases);\n-        handleSwitch(tree, tree.selector, cases);\n-    }\n-\n-    private List<JCCase> addDefaultIfNeeded(boolean matchException, List<JCCase> cases) {\n-        if (cases.stream().flatMap(c -> c.labels.stream()).noneMatch(p -> p.hasTag(Tag.DEFAULTCASELABEL))) {\n-            Type exception = matchException ? syms.matchExceptionType\n-                                            : syms.incompatibleClassChangeErrorType;\n-            List<JCExpression> params = matchException ? List.of(makeNull(), makeNull())\n-                                                       : List.nil();\n-            JCThrow thr = make.Throw(makeNewClass(exception, params));\n-            JCCase c = make.Case(JCCase.STATEMENT, List.of(make.DefaultCaseLabel()), List.of(thr), null);\n-            cases = cases.prepend(c);\n-        }\n-\n-        return cases;\n-    }\n-\n-    private void handleSwitch(JCTree tree, JCExpression selector, List<JCCase> cases) {\n-        \/\/expand multiple label cases:\n-        ListBuffer<JCCase> convertedCases = new ListBuffer<>();\n-\n-        for (JCCase c : cases) {\n-            switch (c.labels.size()) {\n-                case 0: \/\/default\n-                case 1: \/\/single label\n-                    convertedCases.append(c);\n-                    break;\n-                default: \/\/multiple labels, expand:\n-                    \/\/case C1, C2, C3: ...\n-                    \/\/=>\n-                    \/\/case C1:\n-                    \/\/case C2:\n-                    \/\/case C3: ...\n-                    List<JCCaseLabel> patterns = c.labels;\n-                    while (patterns.tail.nonEmpty()) {\n-                        convertedCases.append(make_at(c.pos()).Case(JCCase.STATEMENT,\n-                                                           List.of(patterns.head),\n-                                                           List.nil(),\n-                                                           null));\n-                        patterns = patterns.tail;\n-                    }\n-                    c.labels = patterns;\n-                    convertedCases.append(c);\n-                    break;\n-            }\n-        }\n-\n-        for (JCCase c : convertedCases) {\n-            if (c.caseKind == JCCase.RULE && c.completesNormally) {\n-                JCBreak b = make.at(TreeInfo.endPos(c.stats.last())).Break(null);\n-                b.target = tree;\n-                c.stats = c.stats.append(b);\n-            }\n-        }\n-\n-        cases = convertedCases.toList();\n-\n-        Type selsuper = types.supertype(selector.type);\n-        boolean enumSwitch = selsuper != null &&\n-            (selector.type.tsym.flags() & ENUM) != 0;\n-        boolean stringSwitch = selsuper != null &&\n-            types.isSameType(selector.type, syms.stringType);\n-        boolean boxedSwitch = !enumSwitch && !stringSwitch && !selector.type.isPrimitive();\n-        selector = translate(selector, selector.type);\n-        cases = translateCases(cases);\n-        if (tree.hasTag(SWITCH)) {\n-            ((JCSwitch) tree).selector = selector;\n-            ((JCSwitch) tree).cases = cases;\n-        } else if (tree.hasTag(SWITCH_EXPRESSION)) {\n-            ((JCSwitchExpression) tree).selector = selector;\n-            ((JCSwitchExpression) tree).cases = cases;\n-        } else {\n-            Assert.error();\n-        }\n-        if (enumSwitch) {\n-            result = visitEnumSwitch(tree, selector, cases);\n-        } else if (stringSwitch) {\n-            result = visitStringSwitch(tree, selector, cases);\n-        } else if (boxedSwitch) {\n-            \/\/An switch over boxed primitive. Pattern matching switches are already translated\n-            \/\/by TransPatterns, so all non-primitive types are only boxed primitives:\n-            result = visitBoxedPrimitiveSwitch(tree, selector, cases);\n-        } else {\n-            result = tree;\n-        }\n-    }\n-\n-    public JCTree visitEnumSwitch(JCTree tree, JCExpression selector, List<JCCase> cases) {\n-        TypeSymbol enumSym = selector.type.tsym;\n-        EnumMapping map = mapForEnum(tree.pos(), enumSym);\n-        make_at(tree.pos());\n-        Symbol ordinalMethod = lookupMethod(tree.pos(),\n-                                            names.ordinal,\n-                                            selector.type,\n-                                            List.nil());\n-        JCExpression newSelector;\n-\n-        if (cases.stream().anyMatch(c -> TreeInfo.isNullCaseLabel(c.labels.head))) {\n-            \/\/for enum switches with case null, do:\n-            \/\/switch ($selector != null ? $mapVar[$selector.ordinal()] : -1) {...}\n-            \/\/replacing case null with case -1:\n-            VarSymbol dollar_s = new VarSymbol(FINAL|SYNTHETIC,\n-                                               names.fromString(\"s\" + tree.pos + this.target.syntheticNameChar()),\n-                                               selector.type,\n-                                               currentMethodSym);\n-            JCStatement var = make.at(tree.pos()).VarDef(dollar_s, selector).setType(dollar_s.type);\n-            newSelector = make.Indexed(map.mapVar,\n-                    make.App(make.Select(make.Ident(dollar_s),\n-                            ordinalMethod)));\n-            newSelector =\n-                    make.LetExpr(List.of(var),\n-                                 make.Conditional(makeBinary(NE, make.Ident(dollar_s), makeNull()),\n-                                                  newSelector,\n-                                                  makeLit(syms.intType, -1))\n-                                     .setType(newSelector.type))\n-                        .setType(newSelector.type);\n-        } else {\n-            newSelector = make.Indexed(map.mapVar,\n-                    make.App(make.Select(selector,\n-                            ordinalMethod)));\n-        }\n-        ListBuffer<JCCase> newCases = new ListBuffer<>();\n-        for (JCCase c : cases) {\n-            if (c.labels.head.hasTag(CONSTANTCASELABEL)) {\n-                JCExpression pat;\n-                if (TreeInfo.isNullCaseLabel(c.labels.head)) {\n-                    pat = makeLit(syms.intType, -1);\n-                } else {\n-                    VarSymbol label = (VarSymbol)TreeInfo.symbol(((JCConstantCaseLabel) c.labels.head).expr);\n-                    pat = map.forConstant(label);\n-                }\n-                newCases.append(make.Case(JCCase.STATEMENT, List.of(make.ConstantCaseLabel(pat)), c.stats, null));\n-            } else {\n-                newCases.append(c);\n-            }\n-        }\n-        JCTree enumSwitch;\n-        if (tree.hasTag(SWITCH)) {\n-            enumSwitch = make.Switch(newSelector, newCases.toList());\n-        } else if (tree.hasTag(SWITCH_EXPRESSION)) {\n-            enumSwitch = make.SwitchExpression(newSelector, newCases.toList());\n-            enumSwitch.setType(tree.type);\n-        } else {\n-            Assert.error();\n-            throw new AssertionError();\n-        }\n-        patchTargets(enumSwitch, tree, enumSwitch);\n-        return enumSwitch;\n-    }\n-\n-    public JCTree visitStringSwitch(JCTree tree, JCExpression selector, List<JCCase> caseList) {\n-        int alternatives = caseList.size();\n-\n-        if (alternatives == 0) { \/\/ Strange but legal possibility (only legal for switch statement)\n-            return make.at(tree.pos()).Exec(attr.makeNullCheck(selector));\n-        } else {\n-            \/*\n-             * The general approach used is to translate a single\n-             * string switch statement into a series of two chained\n-             * switch statements: the first a synthesized statement\n-             * switching on the argument string's hash value and\n-             * computing a string's position in the list of original\n-             * case labels, if any, followed by a second switch on the\n-             * computed integer value.  The second switch has the same\n-             * code structure as the original string switch statement\n-             * except that the string case labels are replaced with\n-             * positional integer constants starting at 0.\n-             *\n-             * The first switch statement can be thought of as an\n-             * inlined map from strings to their position in the case\n-             * label list.  An alternate implementation would use an\n-             * actual Map for this purpose, as done for enum switches.\n-             *\n-             * With some additional effort, it would be possible to\n-             * use a single switch statement on the hash code of the\n-             * argument, but care would need to be taken to preserve\n-             * the proper control flow in the presence of hash\n-             * collisions and other complications, such as\n-             * fallthroughs.  Switch statements with one or two\n-             * alternatives could also be specially translated into\n-             * if-then statements to omit the computation of the hash\n-             * code.\n-             *\n-             * The generated code assumes that the hashing algorithm\n-             * of String is the same in the compilation environment as\n-             * in the environment the code will run in.  The string\n-             * hashing algorithm in the SE JDK has been unchanged\n-             * since at least JDK 1.2.  Since the algorithm has been\n-             * specified since that release as well, it is very\n-             * unlikely to be changed in the future.\n-             *\n-             * Different hashing algorithms, such as the length of the\n-             * strings or a perfect hashing algorithm over the\n-             * particular set of case labels, could potentially be\n-             * used instead of String.hashCode.\n-             *\/\n-\n-            ListBuffer<JCStatement> stmtList = new ListBuffer<>();\n-\n-            \/\/ Map from String case labels to their original position in\n-            \/\/ the list of case labels.\n-            Map<String, Integer> caseLabelToPosition = new LinkedHashMap<>(alternatives + 1, 1.0f);\n-\n-            \/\/ Map of hash codes to the string case labels having that hashCode.\n-            Map<Integer, Set<String>> hashToString = new LinkedHashMap<>(alternatives + 1, 1.0f);\n-\n-            int casePosition = 0;\n-            JCCase nullCase = null;\n-            int nullCaseLabel = -1;\n-\n-            for(JCCase oneCase : caseList) {\n-                if (oneCase.labels.head.hasTag(CONSTANTCASELABEL)) {\n-                    if (TreeInfo.isNullCaseLabel(oneCase.labels.head)) {\n-                        nullCase = oneCase;\n-                        nullCaseLabel = casePosition;\n-                    } else {\n-                        JCExpression expression = ((JCConstantCaseLabel) oneCase.labels.head).expr;\n-                        String labelExpr = (String) expression.type.constValue();\n-                        Integer mapping = caseLabelToPosition.put(labelExpr, casePosition);\n-                        Assert.checkNull(mapping);\n-                        int hashCode = labelExpr.hashCode();\n-\n-                        Set<String> stringSet = hashToString.get(hashCode);\n-                        if (stringSet == null) {\n-                            stringSet = new LinkedHashSet<>(1, 1.0f);\n-                            stringSet.add(labelExpr);\n-                            hashToString.put(hashCode, stringSet);\n-                        } else {\n-                            boolean added = stringSet.add(labelExpr);\n-                            Assert.check(added);\n-                        }\n-                    }\n-                }\n-                casePosition++;\n-            }\n-\n-            \/\/ Synthesize a switch statement that has the effect of\n-            \/\/ mapping from a string to the integer position of that\n-            \/\/ string in the list of case labels.  This is done by\n-            \/\/ switching on the hashCode of the string followed by an\n-            \/\/ if-then-else chain comparing the input for equality\n-            \/\/ with all the case labels having that hash value.\n-\n-            \/*\n-             * s$ = top of stack;\n-             * tmp$ = -1;\n-             * switch($s.hashCode()) {\n-             *     case caseLabel.hashCode:\n-             *         if (s$.equals(\"caseLabel_1\")\n-             *           tmp$ = caseLabelToPosition(\"caseLabel_1\");\n-             *         else if (s$.equals(\"caseLabel_2\"))\n-             *           tmp$ = caseLabelToPosition(\"caseLabel_2\");\n-             *         ...\n-             *         break;\n-             * ...\n-             * }\n-             *\/\n-\n-            VarSymbol dollar_s = new VarSymbol(FINAL|SYNTHETIC,\n-                                               names.fromString(\"s\" + tree.pos + target.syntheticNameChar()),\n-                                               syms.stringType,\n-                                               currentMethodSym);\n-            stmtList.append(make.at(tree.pos()).VarDef(dollar_s, selector).setType(dollar_s.type));\n-\n-            VarSymbol dollar_tmp = new VarSymbol(SYNTHETIC,\n-                                                 names.fromString(\"tmp\" + tree.pos + target.syntheticNameChar()),\n-                                                 syms.intType,\n-                                                 currentMethodSym);\n-            JCVariableDecl dollar_tmp_def =\n-                (JCVariableDecl)make.VarDef(dollar_tmp, make.Literal(INT, -1)).setType(dollar_tmp.type);\n-            dollar_tmp_def.init.type = dollar_tmp.type = syms.intType;\n-            stmtList.append(dollar_tmp_def);\n-            ListBuffer<JCCase> caseBuffer = new ListBuffer<>();\n-            \/\/ hashCode will trigger nullcheck on original switch expression\n-            JCMethodInvocation hashCodeCall = makeCall(make.Ident(dollar_s),\n-                                                       names.hashCode,\n-                                                       List.nil()).setType(syms.intType);\n-            JCSwitch switch1 = make.Switch(hashCodeCall,\n-                                        caseBuffer.toList());\n-            for(Map.Entry<Integer, Set<String>> entry : hashToString.entrySet()) {\n-                int hashCode = entry.getKey();\n-                Set<String> stringsWithHashCode = entry.getValue();\n-                Assert.check(stringsWithHashCode.size() >= 1);\n-\n-                JCStatement elsepart = null;\n-                for(String caseLabel : stringsWithHashCode ) {\n-                    JCMethodInvocation stringEqualsCall = makeCall(make.Ident(dollar_s),\n-                                                                   names.equals,\n-                                                                   List.of(make.Literal(caseLabel)));\n-                    elsepart = make.If(stringEqualsCall,\n-                                       make.Exec(make.Assign(make.Ident(dollar_tmp),\n-                                                             make.Literal(caseLabelToPosition.get(caseLabel))).\n-                                                 setType(dollar_tmp.type)),\n-                                       elsepart);\n-                }\n-\n-                ListBuffer<JCStatement> lb = new ListBuffer<>();\n-                JCBreak breakStmt = make.Break(null);\n-                breakStmt.target = switch1;\n-                lb.append(elsepart).append(breakStmt);\n-\n-                caseBuffer.append(make.Case(JCCase.STATEMENT,\n-                                            List.of(make.ConstantCaseLabel(make.Literal(hashCode))),\n-                                            lb.toList(),\n-                                            null));\n-            }\n-\n-            switch1.cases = caseBuffer.toList();\n-\n-            if (nullCase != null) {\n-                stmtList.append(make.If(makeBinary(NE, make.Ident(dollar_s), makeNull()), switch1, make.Exec(make.Assign(make.Ident(dollar_tmp),\n-                                                             make.Literal(nullCaseLabel)).\n-                                                 setType(dollar_tmp.type))).setType(syms.intType));\n-            } else {\n-                stmtList.append(switch1);\n-            }\n-\n-            \/\/ Make isomorphic switch tree replacing string labels\n-            \/\/ with corresponding integer ones from the label to\n-            \/\/ position map.\n-\n-            ListBuffer<JCCase> lb = new ListBuffer<>();\n-            for(JCCase oneCase : caseList ) {\n-                boolean isDefault = !oneCase.labels.head.hasTag(CONSTANTCASELABEL);\n-                JCExpression caseExpr;\n-                if (isDefault)\n-                    caseExpr = null;\n-                else if (oneCase == nullCase) {\n-                    caseExpr = make.Literal(nullCaseLabel);\n-                } else {\n-                    JCExpression expression = ((JCConstantCaseLabel) oneCase.labels.head).expr;\n-                    String name = (String) TreeInfo.skipParens(expression)\n-                                                   .type.constValue();\n-                    caseExpr = make.Literal(caseLabelToPosition.get(name));\n-                }\n-\n-                lb.append(make.Case(JCCase.STATEMENT, caseExpr == null ? List.of(make.DefaultCaseLabel())\n-                                                                       : List.of(make.ConstantCaseLabel(caseExpr)),\n-                                    oneCase.stats, null));\n-            }\n-\n-            if (tree.hasTag(SWITCH)) {\n-                JCSwitch switch2 = make.Switch(make.Ident(dollar_tmp), lb.toList());\n-                \/\/ Rewire up old unlabeled break statements to the\n-                \/\/ replacement switch being created.\n-                patchTargets(switch2, tree, switch2);\n-\n-                stmtList.append(switch2);\n-\n-                JCBlock res = make.Block(0L, stmtList.toList());\n-                res.endpos = TreeInfo.endPos(tree);\n-                return res;\n-            } else {\n-                JCSwitchExpression switch2 = make.SwitchExpression(make.Ident(dollar_tmp), lb.toList());\n-\n-                \/\/ Rewire up old unlabeled break statements to the\n-                \/\/ replacement switch being created.\n-                patchTargets(switch2, tree, switch2);\n-\n-                switch2.setType(tree.type);\n-\n-                LetExpr res = make.LetExpr(stmtList.toList(), switch2);\n-\n-                res.needsCond = true;\n-                res.setType(tree.type);\n-\n-                return res;\n-            }\n-        }\n-    }\n-\n-    private JCTree visitBoxedPrimitiveSwitch(JCTree tree, JCExpression selector, List<JCCase> cases) {\n-        JCExpression newSelector;\n-\n-        if (cases.stream().anyMatch(c -> TreeInfo.isNullCaseLabel(c.labels.head))) {\n-            \/\/a switch over a boxed primitive, with a null case. Pick two constants that are\n-            \/\/not used by any branch in the case (c1 and c2), close to other constants that are\n-            \/\/used in the switch. Then do:\n-            \/\/switch ($selector != null ? $selector != c1 ? $selector : c2 : c1) {...}\n-            \/\/replacing case null with case c1\n-            Set<Integer> constants = new LinkedHashSet<>();\n-            JCCase nullCase = null;\n-\n-            for (JCCase c : cases) {\n-                if (TreeInfo.isNullCaseLabel(c.labels.head)) {\n-                    nullCase = c;\n-                } else if (!c.labels.head.hasTag(DEFAULTCASELABEL)) {\n-                    constants.add((int) ((JCConstantCaseLabel) c.labels.head).expr.type.constValue());\n-                }\n-            }\n-\n-            Assert.checkNonNull(nullCase);\n-\n-            int nullValue = constants.isEmpty() ? 0 : constants.iterator().next();\n-\n-            while (constants.contains(nullValue)) nullValue++;\n-\n-            constants.add(nullValue);\n-            nullCase.labels.head = make.ConstantCaseLabel(makeLit(syms.intType, nullValue));\n-\n-            int replacementValue = nullValue;\n-\n-            while (constants.contains(replacementValue)) replacementValue++;\n-\n-            VarSymbol dollar_s = new VarSymbol(FINAL|SYNTHETIC,\n-                                               names.fromString(\"s\" + tree.pos + this.target.syntheticNameChar()),\n-                                               selector.type,\n-                                               currentMethodSym);\n-            JCStatement var = make.at(tree.pos()).VarDef(dollar_s, selector).setType(dollar_s.type);\n-            JCExpression nullValueReplacement =\n-                    make.Conditional(makeBinary(NE,\n-                                                 unbox(make.Ident(dollar_s), syms.intType),\n-                                                 makeLit(syms.intType, nullValue)),\n-                                     unbox(make.Ident(dollar_s), syms.intType),\n-                                     makeLit(syms.intType, replacementValue))\n-                        .setType(syms.intType);\n-            JCExpression nullCheck =\n-                    make.Conditional(makeBinary(NE, make.Ident(dollar_s), makeNull()),\n-                                     nullValueReplacement,\n-                                     makeLit(syms.intType, nullValue))\n-                        .setType(syms.intType);\n-            newSelector = make.LetExpr(List.of(var), nullCheck).setType(syms.intType);\n-        } else {\n-            newSelector = unbox(selector, syms.intType);\n-        }\n-\n-        if (tree.hasTag(SWITCH)) {\n-            ((JCSwitch) tree).selector = newSelector;\n-        } else {\n-            ((JCSwitchExpression) tree).selector = newSelector;\n-        }\n-\n-        return tree;\n-    }\n-\n-    @Override\n-    public void visitBreak(JCBreak tree) {\n-        result = tree;\n-    }\n-\n-    @Override\n-    public void visitYield(JCYield tree) {\n-        tree.value = translate(tree.value, tree.target.type);\n-        result = tree;\n-    }\n-\n-    public void visitNewArray(JCNewArray tree) {\n-        tree.elemtype = translate(tree.elemtype);\n-        for (List<JCExpression> t = tree.dims; t.tail != null; t = t.tail)\n-            if (t.head != null) t.head = translate(t.head, syms.intType);\n-        tree.elems = translate(tree.elems, types.elemtype(tree.type));\n-        result = tree;\n-    }\n-\n-    public void visitSelect(JCFieldAccess tree) {\n-        \/\/ need to special case-access of the form C.super.x\n-        \/\/ these will always need an access method, unless C\n-        \/\/ is a default interface subclassed by the current class.\n-        boolean qualifiedSuperAccess =\n-            tree.selected.hasTag(SELECT) &&\n-            TreeInfo.name(tree.selected) == names._super &&\n-            !types.isDirectSuperInterface(((JCFieldAccess)tree.selected).selected.type.tsym, currentClass);\n-        tree.selected = translate(tree.selected);\n-        if (tree.name == names._class) {\n-            result = classOf(tree.selected);\n-        }\n-        else if (tree.name == names._super &&\n-                types.isDirectSuperInterface(tree.selected.type.tsym, currentClass)) {\n-            \/\/default super call!! Not a classic qualified super call\n-            TypeSymbol supSym = tree.selected.type.tsym;\n-            Assert.checkNonNull(types.asSuper(currentClass.type, supSym));\n-            result = tree;\n-        }\n-        else if (tree.name == names._this || tree.name == names._super) {\n-            result = makeThis(tree.pos(), tree.selected.type.tsym);\n-        }\n-        else\n-            result = access(tree.sym, tree, enclOp, qualifiedSuperAccess);\n-    }\n-\n-    public void visitLetExpr(LetExpr tree) {\n-        tree.defs = translate(tree.defs);\n-        tree.expr = translate(tree.expr, tree.type);\n-        result = tree;\n-    }\n-\n-    \/\/ There ought to be nothing to rewrite here;\n-    \/\/ we don't generate code.\n-    public void visitAnnotation(JCAnnotation tree) {\n-        result = tree;\n-    }\n-\n-    @Override\n-    public void visitTry(JCTry tree) {\n-        if (tree.resources.nonEmpty()) {\n-            result = makeTwrTry(tree);\n-            return;\n-        }\n-\n-        boolean hasBody = tree.body.getStatements().nonEmpty();\n-        boolean hasCatchers = tree.catchers.nonEmpty();\n-        boolean hasFinally = tree.finalizer != null &&\n-                tree.finalizer.getStatements().nonEmpty();\n-\n-        if (!hasCatchers && !hasFinally) {\n-            result = translate(tree.body);\n-            return;\n-        }\n-\n-        if (!hasBody) {\n-            if (hasFinally) {\n-                result = translate(tree.finalizer);\n-            } else {\n-                result = translate(tree.body);\n-            }\n-            return;\n-        }\n-\n-        \/\/ no optimizations possible\n-        super.visitTry(tree);\n-    }\n-\n-\/**************************************************************************\n- * main method\n- *************************************************************************\/\n-\n-    \/** Translate a toplevel class and return a list consisting of\n-     *  the translated class and translated versions of all inner classes.\n-     *  @param env   The attribution environment current at the class definition.\n-     *               We need this for resolving some additional symbols.\n-     *  @param cdef  The tree representing the class definition.\n-     *\/\n-    public List<JCTree> translateTopLevelClass(Env<AttrContext> env, JCTree cdef, TreeMaker make) {\n-        ListBuffer<JCTree> translated = null;\n-        try {\n-            attrEnv = env;\n-            this.make = make;\n-            endPosTable = env.toplevel.endPositions;\n-            currentClass = null;\n-            currentMethodDef = null;\n-            outermostClassDef = (cdef.hasTag(CLASSDEF)) ? (JCClassDecl)cdef : null;\n-            outermostMemberDef = null;\n-            this.translated = new ListBuffer<>();\n-            classdefs = new HashMap<>();\n-            actualSymbols = new HashMap<>();\n-            freevarCache = new HashMap<>();\n-            proxies = new HashMap<>();\n-            twrVars = WriteableScope.create(syms.noSymbol);\n-            outerThisStack = List.nil();\n-            accessNums = new HashMap<>();\n-            accessSyms = new HashMap<>();\n-            accessConstrs = new HashMap<>();\n-            accessConstrTags = List.nil();\n-            accessed = new ListBuffer<>();\n-            translate(cdef, (JCExpression)null);\n-            for (List<Symbol> l = accessed.toList(); l.nonEmpty(); l = l.tail)\n-                makeAccessible(l.head);\n-            for (EnumMapping map : enumSwitchMap.values())\n-                map.translate();\n-            checkConflicts(this.translated.toList());\n-            checkAccessConstructorTags();\n-            translated = this.translated;\n-        } finally {\n-            \/\/ note that recursive invocations of this method fail hard\n-            attrEnv = null;\n-            this.make = null;\n-            endPosTable = null;\n-            currentClass = null;\n-            currentMethodDef = null;\n-            outermostClassDef = null;\n-            outermostMemberDef = null;\n-            this.translated = null;\n-            classdefs = null;\n-            actualSymbols = null;\n-            freevarCache = null;\n-            proxies = null;\n-            outerThisStack = null;\n-            accessNums = null;\n-            accessSyms = null;\n-            accessConstrs = null;\n-            accessConstrTags = null;\n-            accessed = null;\n-            enumSwitchMap.clear();\n-            assertionsDisabledClassCache = null;\n-        }\n-        return translated.toList();\n-    }\n-}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Lower.java.orig","additions":0,"deletions":4223,"binary":false,"changes":4223,"status":"deleted"}]}