{"files":[{"patch":"@@ -32,2 +32,1 @@\n-import java.util.Arrays;\n-import java.util.Spliterator;\n+import java.util.*;\n@@ -1824,0 +1823,20 @@\n+\n+    \/\/ Used by StringConcatHelper via JLA.\n+    long mix(long lengthCoder) {\n+        return (lengthCoder + count) | ((long)coder << 32);\n+    }\n+\n+    \/\/ Used by StringConcatHelper via JLA.\n+    long prepend(long lengthCoder, byte[] buffer) {\n+        lengthCoder -= count;\n+\n+        if (lengthCoder < ((long)UTF16 << 32)) {\n+            System.arraycopy(value, 0, buffer, (int)lengthCoder, count);\n+        } else if (coder == LATIN1) {\n+            StringUTF16.inflate(value, 0, buffer, (int)lengthCoder, count);\n+        } else {\n+            System.arraycopy(value, 0, buffer, (int)lengthCoder << 1, count << 1);\n+        }\n+\n+        return lengthCoder;\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/AbstractStringBuilder.java","additions":21,"deletions":2,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.internal.javac.PreviewFeature;\n@@ -34,0 +35,1 @@\n+import java.util.FormatConcatItem;\n@@ -46,0 +48,9 @@\n+    \/**\n+     * Return the coder for the character.\n+     * @param value character\n+     * @return      coder\n+     *\/\n+    static long coder(char value) {\n+        return StringLatin1.canEncode(value) ? LATIN1 : UTF16;\n+    }\n+\n@@ -79,1 +90,1 @@\n-        return checkOverflow(lengthCoder + 1) | (StringLatin1.canEncode(value) ? 0 : UTF16);\n+        return checkOverflow(lengthCoder + 1) | coder(value);\n@@ -119,0 +130,15 @@\n+    \/**\n+     * Mix value length and coder into current length and coder.\n+     * @param lengthCoder String length with coder packed into higher bits\n+     *                    the upper word.\n+     * @param value       value to mix in\n+     * @return            new length and coder\n+     * @since 19\n+     *\/\n+    @PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n+    static long mix(long lengthCoder, FormatConcatItem value) {\n+        lengthCoder = value.mix(lengthCoder);\n+\n+        return checkOverflow(lengthCoder);\n+    }\n+\n@@ -322,0 +348,41 @@\n+    \/**\n+     * Prepends the stringly representation of FormatConcatItem value into buffer,\n+     * given the coder and final index. Index is measured in chars, not in bytes!\n+     *\n+     * @param indexCoder final char index in the buffer, along with coder packed\n+     *                   into higher bits.\n+     * @param buf        buffer to append to\n+     * @param value      String value to encode\n+     * @return           updated index (coder value retained)\n+     * @since 19\n+     *\/\n+    @PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n+    private static long prepend(long indexCoder, byte[] buf,\n+                                FormatConcatItem value) {\n+        try {\n+            return value.prepend(indexCoder, buf);\n+        } catch (Throwable ex) {\n+            throw new AssertionError(\"FormatConcatItem prepend error\", ex);\n+        }\n+    }\n+\n+    \/**\n+     * Prepends constant and the stringly representation of value into buffer,\n+     * given the coder and final index. Index is measured in chars, not in bytes!\n+     *\n+     * @param indexCoder final char index in the buffer, along with coder packed\n+     *                   into higher bits.\n+     * @param buf        buffer to append to\n+     * @param value      boolean value to encode\n+     * @param prefix     a constant to prepend before value\n+     * @return           updated index (coder value retained)\n+     * @since 19\n+     *\/\n+    @PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n+    static long prepend(long indexCoder, byte[] buf,\n+                        FormatConcatItem value, String prefix) {\n+        indexCoder = prepend(indexCoder, buf, value);\n+        if (prefix != null) indexCoder = prepend(indexCoder, buf, prefix);\n+        return indexCoder;\n+    }\n+\n@@ -335,1 +402,2 @@\n-            throw new InternalError(\"Storage is not completely initialized, \" + (int)indexCoder + \" bytes left\");\n+            throw new InternalError(\"Storage is not completely initialized, \" +\n+                    (int)indexCoder + \" bytes left\");\n@@ -449,0 +517,65 @@\n+    \/*\n+     * Initialize after phase1.\n+     *\/\n+    static class LateInit {\n+        static final MethodHandle GETCHAR_LATIN1_MH;\n+\n+        static final MethodHandle GETCHAR_UTF16_MH;\n+\n+        static final MethodHandle PUTCHAR_LATIN1_MH;\n+\n+        static final MethodHandle PUTCHAR_UTF16_MH;\n+\n+        static {\n+            MethodType getCharMT =\n+                MethodType.methodType(char.class,\n+                        byte[].class, int.class);\n+            MethodType putCharMT =\n+                MethodType.methodType(void.class,\n+                        byte[].class, int.class, int.class);\n+            GETCHAR_LATIN1_MH = lookupStatic(\"getCharLatin1\", getCharMT);\n+            GETCHAR_UTF16_MH = lookupStatic(\"getCharUTF16\", getCharMT);\n+            PUTCHAR_LATIN1_MH = lookupStatic(\"putCharLatin1\", putCharMT);\n+            PUTCHAR_UTF16_MH = lookupStatic(\"putCharUTF16\", putCharMT);\n+        }\n+\n+    }\n+\n+    @ForceInline\n+    @PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n+    static char getCharLatin1(byte[] buffer, int index) {\n+        return (char)buffer[index];\n+    }\n+\n+    @ForceInline\n+    @PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n+    static char getCharUTF16(byte[] buffer, int index) {\n+        return StringUTF16.getChar(buffer, index);\n+    }\n+\n+    @ForceInline\n+    @PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n+    static void putCharLatin1(byte[] buffer, int index, int ch) {\n+        buffer[index] = (byte)ch;\n+    }\n+\n+    @ForceInline\n+    @PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n+    static void putCharUTF16(byte[] buffer, int index, int ch) {\n+        StringUTF16.putChar(buffer, index, ch);\n+    }\n+\n+    @ForceInline\n+    @PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n+    static MethodHandle selectGetChar(long indexCoder) {\n+        return indexCoder < UTF16 ? LateInit.GETCHAR_LATIN1_MH :\n+                                    LateInit.GETCHAR_UTF16_MH;\n+    }\n+\n+    @ForceInline\n+    @PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n+    static MethodHandle selectPutChar(long indexCoder) {\n+        return indexCoder < UTF16 ? LateInit.PUTCHAR_LATIN1_MH :\n+                                    LateInit.PUTCHAR_UTF16_MH;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StringConcatHelper.java","additions":135,"deletions":2,"binary":false,"changes":137,"status":"modified"},{"patch":"@@ -80,1 +80,1 @@\n-import jdk.internal.misc.VM;\n+import jdk.internal.javac.PreviewFeature;\n@@ -84,0 +84,1 @@\n+import jdk.internal.misc.VM;\n@@ -2501,0 +2502,17 @@\n+            @PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n+            public long stringConcatCoder(char value) {\n+                return StringConcatHelper.coder(value);\n+            }\n+\n+            @PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n+            public long stringBuilderConcatMix(long lengthCoder,\n+                                               StringBuilder sb) {\n+                return sb.mix(lengthCoder);\n+            }\n+\n+            @PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n+            public long stringBuilderConcatPrepend(long lengthCoder, byte[] buf,\n+                                                   StringBuilder sb) {\n+                return sb.prepend(lengthCoder, buf);\n+            }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.javac.PreviewFeature;\n@@ -34,1 +35,2 @@\n-import java.util.Objects;\n+import java.lang.template.StringTemplate;\n+import java.util.*;\n@@ -113,0 +115,2 @@\n+     *\n+     * @since 20\n@@ -114,1 +118,1 @@\n-    private static final int MAX_INDY_CONCAT_ARG_SLOTS = 200;\n+    public static final int MAX_INDY_CONCAT_ARG_SLOTS = 200;\n@@ -324,0 +328,1 @@\n+        Objects.requireNonNull(recipe, \"Recipe is null\");\n@@ -491,3 +496,1 @@\n-            if (cl == byte.class || cl == short.class) {\n-                ptypes[i] = int.class;\n-            }\n+            ptypes[i] = promoteIntType(ptypes[i]);\n@@ -498,1 +501,1 @@\n-            else if (cl == Object.class) {\n+            if (cl == Object.class) {\n@@ -667,1 +670,0 @@\n-\n@@ -713,0 +715,3 @@\n+            if (idx == STRING_CONCAT_ITEM) {\n+                cl = FormatConcatItem.class;\n+            }\n@@ -725,1 +730,2 @@\n-            TYPE_COUNT = 5;\n+            STRING_CONCAT_ITEM = 5,\n+            TYPE_COUNT = 6;\n@@ -727,5 +733,6 @@\n-        if (cl == String.class)  return STRING_IDX;\n-        if (cl == int.class)     return INT_IDX;\n-        if (cl == boolean.class) return BOOLEAN_IDX;\n-        if (cl == char.class)    return CHAR_IDX;\n-        if (cl == long.class)    return LONG_IDX;\n+        if (cl == String.class)                          return STRING_IDX;\n+        if (cl == int.class)                             return INT_IDX;\n+        if (cl == boolean.class)                         return BOOLEAN_IDX;\n+        if (cl == char.class)                            return CHAR_IDX;\n+        if (cl == long.class)                            return LONG_IDX;\n+        if (FormatConcatItem.class.isAssignableFrom(cl)) return STRING_CONCAT_ITEM;\n@@ -989,0 +996,27 @@\n+    \/**\n+     * Promote integral types to int.\n+     *\/\n+    private static Class<?> promoteIntType(Class<?> t) {\n+        \/\/ use int for subword integral types; still need special mixers\n+        \/\/ and prependers for char, boolean\n+        return t == byte.class || t == short.class ? int.class : t;\n+    }\n+\n+    \/**\n+     * Returns a stringifier for references and floats\/doubles only.\n+     * Always returns null for other primitives.\n+     *\n+     * @param t class to stringify\n+     * @return stringifier; null, if not available\n+     *\/\n+    private static MethodHandle stringifierFor(Class<?> t) {\n+        if (t == Object.class) {\n+            return objectStringifier();\n+        } else if (t == float.class) {\n+            return floatStringifier();\n+        } else if (t == double.class) {\n+            return doubleStringifier();\n+        }\n+        return null;\n+    }\n+\n@@ -1001,0 +1035,289 @@\n+\n+    \/**\n+     * Simplified concatenation method to facilitate {@link StringTemplate}\n+     * concatenation. This method returns a single concatenation method that\n+     * interleaves fragments and values. fragment|value|fragment|value|...|value|fragment.\n+     * The number of fragments must be one more that the number of ptypes.\n+     * The total number of slots used by the ptypes must be less than or equal\n+     * to MAX_INDY_CONCAT_ARG_SLOTS.\n+     *\n+     * @param fragments list of string fragments\n+     * @param ptypes    list of expression types\n+     *\n+     * @return {@link MethodHandle}\n+     *\n+     * @throws StringConcatException If any of the linkage invariants are violated.\n+     * @throws NullPointerException If any of the incoming arguments is null.\n+     *\n+     * @since 20\n+     *\/\n+    @PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n+    public static MethodHandle makeConcatWithTemplate(\n+            List<String> fragments,\n+            List<Class<?>> ptypes)\n+            throws StringConcatException\n+    {\n+        Objects.requireNonNull(fragments, \"fragments is null\");\n+        Objects.requireNonNull(ptypes, \"ptypes is null\");\n+\n+        if (fragments.size() != ptypes.size() + 1) {\n+            throw new StringConcatException(\"fragments size not equal ptypes size plus one\");\n+        }\n+\n+        if (ptypes.isEmpty()) {\n+            return MethodHandles.constant(String.class, fragments.get(0));\n+        }\n+\n+        Class<?>[] ttypes = new Class<?>[ptypes.size()];\n+        MethodHandle[] filters = new MethodHandle[ptypes.size()];\n+        int slots = 0;\n+\n+        int pos = 0;\n+        for (Class<?> ptype : ptypes) {\n+            slots += ptype == long.class || ptype == double.class ? 2 : 1;\n+\n+            if (MAX_INDY_CONCAT_ARG_SLOTS < slots) {\n+                throw new StringConcatException(\"Too many concat argument slots: \" +\n+                        slots + \", can only accept \" + MAX_INDY_CONCAT_ARG_SLOTS);\n+            }\n+\n+            boolean isSpecialized = ptype.isPrimitive();\n+            boolean isFormatConcatItem = FormatConcatItem.class.isAssignableFrom(ptype);\n+            Class<?> ttype = isSpecialized ? promoteIntType(ptype) :\n+                             isFormatConcatItem ? FormatConcatItem.class : Object.class;\n+            MethodHandle filter = isFormatConcatItem ? null : stringifierFor(ttype);\n+\n+            if (filter != null) {\n+                filters[pos] = filter;\n+                ttype = String.class;\n+            }\n+\n+            ttypes[pos++] = ttype;\n+        }\n+\n+        MethodHandle mh = MethodHandles.dropArguments(newString(), 2, ttypes);\n+\n+        long initialLengthCoder = INITIAL_CODER;\n+        String lastFragment = \"\";\n+        pos = 0;\n+        for (String fragment : fragments) {\n+            lastFragment = fragment;\n+\n+            if (ttypes.length <= pos) {\n+                break;\n+            }\n+\n+            Class<?> ttype = ttypes[pos];\n+            MethodHandle prepender = prepender(lastFragment.isEmpty() ? null : fragment, ttype);\n+            initialLengthCoder = JLA.stringConcatMix(initialLengthCoder, fragment);\n+            mh = MethodHandles.filterArgumentsWithCombiner(mh, 1, prepender,1, 0, 2 + pos);\n+\n+            pos++;\n+        }\n+\n+        MethodHandle newArrayCombinator = lastFragment.isEmpty() ? newArray() :\n+                newArrayWithSuffix(lastFragment);\n+        mh = MethodHandles.foldArgumentsWithCombiner(mh, 0, newArrayCombinator,\n+                1 \/\/ index\n+        );\n+\n+        pos = 0;\n+        for (Class<?> ttype : ttypes) {\n+            MethodHandle mix = mixer(ttypes[pos]);\n+            boolean lastPType = pos == ttypes.length - 1;\n+\n+            if (lastPType) {\n+                mix = MethodHandles.insertArguments(mix, 0, initialLengthCoder);\n+                mh = MethodHandles.foldArgumentsWithCombiner(mh, 0, mix,\n+                        1 + pos \/\/ selected argument\n+                );\n+            } else {\n+                mh = MethodHandles.filterArgumentsWithCombiner(mh, 0, mix,\n+                        0, \/\/ old-index\n+                        1 + pos \/\/ selected argument\n+                );\n+            }\n+\n+            pos++;\n+        }\n+\n+        mh = MethodHandles.filterArguments(mh, 0, filters);\n+        MethodType mt = MethodType.methodType(String.class, ptypes);\n+        mh = mh.viewAsType(mt, true);\n+\n+        return mh;\n+    }\n+\n+    \/**\n+     * This method breaks up large concatenations into separate\n+     * {@link MethodHandle MethodHandles} based on the number of slots required\n+     * per {@link MethodHandle}. Each {@link MethodHandle} after the first will\n+     * have an extra {@link String} slot for the result from the previous\n+     * {@link MethodHandle}.\n+     * {@link java.lang.invoke.StringConcatFactory#makeConcatWithTemplate}\n+     * is used to construct the {@link MethodHandle MethodHandles}. The total\n+     * number of slots used by the ptypes is open ended. However, care must\n+     * be given when combining the {@link MethodHandle MethodHandles} so that\n+     * the combine total does not exceed the 255 slot limit.\n+     *\n+     * @param fragments list of string fragments\n+     * @param ptypes    list of expression types\n+     * @param maxSlots  maximum number of slots per {@link MethodHandle}.\n+     *\n+     * @return List of {@link MethodHandle MethodHandles}\n+     *\n+     * @throws IllegalArgumentException If maxSlots is not between 1 and\n+     *                                  MAX_INDY_CONCAT_ARG_SLOTS.\n+     * @throws StringConcatException If any of the linkage invariants are violated.\n+     * @throws NullPointerException If any of the incoming arguments is null.\n+     *\n+     * @since 20\n+     *\/\n+    @PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n+    public static List<MethodHandle> makeConcatWithTemplateCluster(\n+            List<String> fragments,\n+            List<Class<?>> ptypes,\n+            int maxSlots)\n+            throws StringConcatException\n+    {\n+        Objects.requireNonNull(fragments, \"fragments is null\");\n+        Objects.requireNonNull(ptypes, \"ptypes is null\");\n+\n+        if (fragments.size() != ptypes.size() + 1) {\n+            throw new StringConcatException(\"fragments size not equal ptypes size plus one\");\n+        }\n+\n+        if (maxSlots < 1 || MAX_INDY_CONCAT_ARG_SLOTS < maxSlots) {\n+            throw new StringConcatException(\"maxSlots must be between 1 and \" +\n+                    MAX_INDY_CONCAT_ARG_SLOTS);\n+\n+        }\n+\n+        if (ptypes.isEmpty()) {\n+            return List.of(MethodHandles.constant(String.class, fragments.get(0)));\n+        }\n+\n+        List<MethodHandle> mhs = new ArrayList<>();\n+        List<String> fragmentsSection = new ArrayList<>();\n+        List<Class<?>> ptypeSection = new ArrayList<>();\n+        int slots = 0;\n+\n+        int pos = 0;\n+        for (Class<?> ptype : ptypes) {\n+            boolean lastPType = pos == ptypes.size() - 1;\n+            fragmentsSection.add(fragments.get(pos));\n+            ptypeSection.add(ptype);\n+\n+            slots += ptype == long.class || ptype == double.class ? 2 : 1;\n+\n+            if (maxSlots <= slots || lastPType) {\n+                fragmentsSection.add(lastPType ? fragments.get(pos + 1) : \"\");\n+                MethodHandle mh = makeConcatWithTemplate(fragmentsSection,\n+                        ptypeSection);\n+                mhs.add(mh);\n+                fragmentsSection.clear();\n+                fragmentsSection.add(\"\");\n+                ptypeSection.clear();\n+                ptypeSection.add(String.class);\n+                slots = 1;\n+            }\n+\n+            pos++;\n+        }\n+\n+        return mhs;\n+    }\n+\n+    \/**\n+     * This method creates a {@link MethodHandle} expecting one input, the\n+     * receiver of the supplied getters. This method uses\n+     * {@link java.lang.invoke.StringConcatFactory#makeConcatWithTemplateCluster}\n+     * to create the intermediate {@link MethodHandle MethodHandles}.\n+     *\n+     * @param fragments list of string fragments\n+     * @param getters   list of getter {@link MethodHandle MethodHandles}\n+     * @param maxSlots  maximum number of slots per {@link MethodHandle} in\n+     *                  cluster.\n+     *\n+     * @return {@link MethodHandle}\n+     *\n+     * @throws IllegalArgumentException If maxSlots is not between 1 and\n+     *                                  MAX_INDY_CONCAT_ARG_SLOTS or if the\n+     *                                  getters don't use the same argument type\n+     * @throws StringConcatException If any of the linkage invariants are violated\n+     * @throws NullPointerException If any of the incoming arguments is null\n+     *\n+     * @since 20\n+     *\/\n+    @PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n+    public static MethodHandle makeConcatWithTemplateGetters(\n+            List<String> fragments,\n+            List<MethodHandle> getters,\n+            int maxSlots)\n+            throws StringConcatException\n+    {\n+        Objects.requireNonNull(fragments, \"fragments is null\");\n+        Objects.requireNonNull(getters, \"getters is null\");\n+\n+        if (fragments.size() != getters.size() + 1) {\n+            throw new StringConcatException(\"fragments size not equal getters size plus one\");\n+        }\n+\n+        if (maxSlots < 1 || MAX_INDY_CONCAT_ARG_SLOTS < maxSlots) {\n+            throw new StringConcatException(\"maxSlots must be between 1 and \" +\n+                    MAX_INDY_CONCAT_ARG_SLOTS);\n+\n+        }\n+\n+        if (getters.size() == 0) {\n+            throw new StringConcatException(\"no getters supplied\");\n+        }\n+\n+        Class<?> receiverType = null;\n+        List<Class<?>> ptypes = new ArrayList<>();\n+\n+        for (MethodHandle getter : getters) {\n+            MethodType mt = getter.type();\n+            Class<?> returnType = mt.returnType();\n+\n+            if (returnType == void.class || mt.parameterCount() != 1) {\n+                throw new StringConcatException(\"not a getter \" + mt);\n+            }\n+\n+            if (receiverType == null) {\n+                receiverType = mt.parameterType(0);\n+            } else if (receiverType != mt.parameterType(0)) {\n+                throw new StringConcatException(\"not the same receiever type \" +\n+                        mt + \" needs \" + receiverType);\n+            }\n+\n+            ptypes.add(returnType);\n+        }\n+\n+        MethodType resultType = MethodType.methodType(String.class, receiverType);\n+        List<MethodHandle> clusters = makeConcatWithTemplateCluster(fragments, ptypes,\n+                maxSlots);\n+\n+        MethodHandle mh = null;\n+        Iterator<MethodHandle> getterIterator = getters.iterator();\n+\n+        for (MethodHandle cluster : clusters) {\n+            MethodType mt = cluster.type();\n+            MethodHandle[] filters = new MethodHandle[mt.parameterCount()];\n+            int pos = 0;\n+\n+            if (mh != null) {\n+                filters[pos++] = mh;\n+            }\n+\n+            while (pos < filters.length) {\n+                filters[pos++] = getterIterator.next();\n+            }\n+\n+            cluster = MethodHandles.filterArguments(cluster, 0, filters);\n+            mh = MethodHandles.permuteArguments(cluster, resultType,\n+                    new int[filters.length]);\n+        }\n+\n+        return mh;\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/StringConcatFactory.java","additions":336,"deletions":13,"binary":false,"changes":349,"status":"modified"},{"patch":"@@ -0,0 +1,61 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.template;\n+\n+import java.util.List;\n+import java.lang.invoke.CallSite;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodType;\n+import java.util.FormatProcessor;\n+\n+import jdk.internal.javac.PreviewFeature;\n+\n+\/**\n+ * Policies using this additional interface have the flexibility to specialize\n+ * the composition of the templated string by returning a customized\n+ * {@link MethodHandle} from {@link ProcessorLinkage#linkage linkage}.\n+ * These specializations are typically implemented to improve performance;\n+ * specializing value types or avoiding boxing and vararg arrays.\n+ *\n+ * @implNote This interface is sealed to only allow standard processors.\n+ *\n+ * @since 20\n+ *\/\n+@PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n+public sealed interface ProcessorLinkage permits FormatProcessor {\n+    \/**\n+     * Construct a {@link MethodHandle} that constructs a result based on the\n+     * bootstrap method information.\n+     *\n+     * @param fragments  string template fragments\n+     * @param type       method type\n+     *\n+     * @return {@link MethodHandle} for the processor applied to template\n+     *\n+     * @throws NullPointerException if any of the arguments are null\n+     *\/\n+    MethodHandle linkage(List<String> fragments, MethodType type);\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/template\/ProcessorLinkage.java","additions":61,"deletions":0,"binary":false,"changes":61,"status":"added"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.template;\n+\n+import java.util.List;\n+\n+\/**\n+ * Generic StringTemplate.\n+ *\n+ * @param fragments  immutable list of string fragments from string template\n+ * @param values     immutable list of expression values\n+ *\/\n+record SimpleStringTemplate(List<String> fragments,\n+                             List<Object> values\n+) implements StringTemplate {}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/template\/SimpleStringTemplate.java","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -0,0 +1,45 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.template;\n+\n+import java.util.Arrays;\n+import java.util.Objects;\n+\n+import jdk.internal.javac.PreviewFeature;\n+\n+\/**\n+ * This interface simplifies declaration of\n+ * {@linkplain ValidatingProcessor template processors}\n+ * that do not throw checked exceptions and have a result type of {@link String}. For example:\n+ * {@snippet :\n+ * StringProcessor processor = st -> st.interpolate();\n+ * }\n+ *\n+ * @since 20\n+ *\/\n+@PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n+@FunctionalInterface\n+public interface StringProcessor extends TemplateProcessor<String> {}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/template\/StringProcessor.java","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -0,0 +1,368 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.template;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.util.*;\n+import java.util.stream.Collectors;\n+\n+import jdk.internal.javac.PreviewFeature;\n+\n+\/**\n+ * The Java compiler produces implementations of {@link StringTemplate} to\n+ * represent string templates and text block templates. Libraries may produce\n+ * {@link StringTemplate} instances as long as they conform to the requirements\n+ * of this interface. Like {@link String}, instances of {@link StringTemplate}\n+ * implementations are considered immutable.\n+ * <p>\n+ * Implementations of this interface must minimally implement the methods\n+ * {@link StringTemplate#fragments()} and {@link StringTemplate#values()}.\n+ * <p>\n+ * The {@link StringTemplate#fragments()} method must return an immutable\n+ * {@code List<String>} consistent with the string template body. The list\n+ * contains the string of characters preceeding each of the embedded expressions\n+ * plus the string of characters following the last embedded expression. The order\n+ * of the strings is left to right as they appear in the string template.\n+ * For example; {@snippet :\n+ * StringTemplate st = RAW.\"The \\{name} and \\{address} of the resident.\";\n+ * List<String> fragments = st.fragments();\n+ * }\n+ * {@code fragments} will be equivalent to <code>List.of(\"The \", \" and \", \" of the resident.\")<\/code>.\n+ * <p>\n+ * The {@link StringTemplate#values()} method returns an immutable {@code\n+ * List<Object>} of values accumulated by evaluating embedded expressions prior\n+ * to instantiating the {@link StringTemplate}. The values are accumulated left\n+ * to right. The first element of the list is the result of the leftmost\n+ * embedded expression. The last element of the list is the result of the\n+ * rightmost embedded expression.\n+ * For example,\n+ * {@snippet :\n+ * int x = 10;\n+ * int y = 20;\n+ * StringTemplate st = RAW.\"\\{x} + \\{y} = \\{x + y}\";\n+ * List<Object> values = st.values();\n+ * }\n+ * {@code values} will be the equivalent of <code>List.of(x, y, x + y)<\/code>.\n+ * <p>\n+ * {@link StringTemplate StringTemplates} are primarily used in conjuction\n+ * with {@linkplain  ValidatingProcessor template processors} to produce meaningful\n+ * results. For example, if a user wants string interpolation, then they can use a string template\n+ * expression with the standard {@link StringTemplate#STR} processor.\n+ * {@snippet :\n+ * int x = 10;\n+ * int y = 20;\n+ * String result = STR.\"\\{x} + \\{y} = \\{x + y}\";\n+ * }\n+ * {@code result} will be equivalent to <code>\"10 + 20 = 30\"<\/code>.\n+ * <p>\n+ * The {@link StringTemplate#process(ValidatingProcessor)} method supplies an\n+ * alternative to using string template expressions.\n+ * {@snippet :\n+ * String result = RAW.\"\\{x} + \\{y} = \\{x + y}\".process(STR);\n+ * }\n+ * In addition to string template expressions, the factory methods\n+ * {@link StringTemplate#of(String)} and {@link StringTemplate#of(List, List)}\n+ * can be used to construct {@link StringTemplate StringTemplates}.\n+ * <p>\n+ * The {@link StringTemplate#interpolate()} method provides a simple way to produce a\n+ * string interpolation of the {@link StringTemplate}.\n+ * <p>\n+ * {@linkplain ValidatingProcessor Template processors} typically use the following code\n+ * pattern to perform composition:\n+ * {@snippet :\n+ * List<String> fragments = st.fragments();\n+ * List<Object> values = st.values();\n+ * \/\/ check or manipulate the fragments and\/or values\n+ * ...\n+ * String result = TemplateRuntime.interpolate(fragments, values);;\n+ * }\n+ *\n+ * @implSpec An instance of {@link StringTemplate} is immutatble. Also, the\n+ * fragment list size must be one more than the values list size.\n+ *\n+ * @see ValidatingProcessor\n+ * @see TemplateProcessor\n+ * @see StringProcessor\n+ * @see java.util.FormatProcessor\n+ *\n+ * @since 20\n+ *\/\n+@PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n+public interface StringTemplate {\n+    \/**\n+     * Returns an immutable list of string fragments consisting of the string\n+     * of characters preceeding each of the embedded expressions plus the\n+     * string of characters following the last embedded expression. In the\n+     * example: {@snippet :\n+     * StringTemplate st = RAW.\"The student \\{student} is in \\{teacher}'s class room.\";\n+     * List<String> fragments = st.fragments(); \/\/ @highlight substring=\"fragments()\"\n+     * }\n+     * <code>fragments<\/code> will be equivalent to\n+     * <code>List.of(\"The student \", \" is in \", \"'s class room.\")<\/code>\n+     *\n+     * @return list of string fragments\n+     *\n+     * @implSpec The list returned is immutable.\n+     *\/\n+    List<String> fragments();\n+\n+    \/**\n+     * Returns an immutable list of embedded expression results. In the example:\n+     * {@snippet :\n+     * StringTemplate st = RAW.\"\\{x} + \\{y} = \\{x + y}\";\n+     * List<Object> values = st.values(); \/\/ @highlight substring=\"values()\"\n+     * }\n+     * <code>values<\/code> will be equivalent to <code>List.of(x, y, x + y)<\/code>\n+     *\n+     * @return list of expression values\n+     *\n+     * @implSpec The list returned is immutable.\n+     *\/\n+    List<Object> values();\n+\n+    \/**\n+     * {@return the interpolation of the StringTemplate}\n+     *\/\n+    default String interpolate() {\n+        return TemplateRuntime.interpolate(fragments(), values());\n+    }\n+\n+    \/**\n+     * Returns the result of applying the specified processor to this {@link StringTemplate}.\n+     * This method can be used as an alternative to string template expressions. For example,\n+     * {@snippet :\n+     * String result1 = STR.\"\\{x} + \\{y} = \\{x + y}\";\n+     * String result2 = RAW.\"\\{x} + \\{y} = \\{x + y}\".process(STR); \/\/ @highlight substring=\"process\"\n+     * }\n+     * produces an equivalent result for both {@code result1} and {@code result2}.\n+     *\n+     * @param processor the {@link ValidatingProcessor} instance to process\n+     *\n+     * @param <R>  Processor's process result type.\n+     * @param <E>  Exception thrown type.\n+     *\n+     * @return constructed object of type R\n+     *\n+     * @throws E exception thrown by the template processor when validation fails\n+     * @throws NullPointerException if processor is null\n+     *\n+     * @implNote The default implementation simply invokes the processor's process\n+     * method {@code processor.process(this)}.\n+     *\/\n+    default <R, E extends Throwable> R process(ValidatingProcessor<R, E> processor) throws E {\n+        Objects.requireNonNull(processor, \"processor should not be null\");\n+\n+        return processor.process(this);\n+    }\n+\n+    \/**\n+     * Return the types of this {@link StringTemplate StringTemplate's} values.\n+     *\n+     * @return list of value types\n+     *\n+     * @implNote The default method determines if the {@link StringTemplate}\n+     * was synthesized by the compiler, then the types are precisely those of the\n+     * embedded expressions, otherwise this method returns the values list types.\n+     *\/\n+    default public List<Class<?>> valueTypes() {\n+        return TemplateRuntime.valueTypes(this);\n+    }\n+\n+    \/**\n+     * Return {@link MethodHandle MethodHandles} to access this\n+     * {@link StringTemplate StringTemplate's} values.\n+     *\n+     * @return list of value types\n+     *\n+     * @implNote The default method determines if the {@link java.lang.template.StringTemplate}\n+     * was synthesized by the compiler, then the MethodHandles are precisely those of the\n+     * embedded expressions fields, otherwise this method returns getters for the values list.\n+     *\/\n+    default public List<MethodHandle> valueGetters() {\n+        return TemplateRuntime.valueGetters(this);\n+    }\n+\n+    \/**\n+     * Produces a diagnostic string representing the supplied\n+     * {@link StringTemplate}.\n+     *\n+     * @param stringTemplate  the {@link StringTemplate} to represent\n+     *\n+     * @return diagnostic string representing the supplied templated string\n+     *\n+     * @throws NullPointerException if stringTemplate is null\n+     *\/\n+    public static String toString(StringTemplate stringTemplate) {\n+        Objects.requireNonNull(stringTemplate, \"stringTemplate should not be null\");\n+        return \"StringTemplate{ fragments = [ \\\"\" +\n+                String.join(\"\\\", \\\"\", stringTemplate.fragments()) +\n+                \"\\\" ], values = \" +\n+                stringTemplate.values() +\n+                \" }\";\n+    }\n+\n+    \/**\n+     * Produces a hash code for the supplied {@link StringTemplate}.\n+     *\n+     * @param stringTemplate the {@link StringTemplate} to hash\n+     *\n+     * @return hash code for the supplied {@link StringTemplate}\n+     *\n+     * @throws NullPointerException if stringTemplate is null\n+     *\n+     * @implSpec The hashCode is the bit XOR of the fragments hash code and\n+     * the values hash code.\n+     *\/\n+    public static int hashCode(StringTemplate stringTemplate) {\n+        Objects.requireNonNull(stringTemplate, \"stringTemplate should not be null\");\n+        return Objects.hashCode(stringTemplate.fragments()) ^\n+               Objects.hashCode(stringTemplate.values());\n+    }\n+\n+    \/**\n+     * Tests for equality of two {@link StringTemplate}.\n+     *\n+     * @param a  first {@link StringTemplate}\n+     * @param b  second {@link StringTemplate}\n+     *\n+     * @return true if the two {@link StringTemplate StringTemplates} are equivalent\n+     *\n+     * @throws NullPointerException if either @link StringTemplate} is null\n+     *\n+     * @implSpec Equality is determined by testing equality of the fragments and\n+     * the values.\n+     *\/\n+    public static boolean equals(Object a, Object b) {\n+        Objects.requireNonNull(a, \"StringTemplate a should not be null\");\n+        Objects.requireNonNull(b, \"StringTemplate b should not be null\");\n+        return a instanceof StringTemplate aST && b instanceof StringTemplate bST &&\n+               Objects.equals(aST.fragments(), bST.fragments()) &&\n+               Objects.equals(aST.values(), bST.values());\n+    }\n+\n+    \/**\n+     * Returns a StringTemplate composed from a string.\n+     *\n+     * @param string  single string fragment\n+     *\n+     * @return StringTemplate composed from string\n+     *\n+     * @throws NullPointerException if string is null\n+     *\/\n+    public static StringTemplate of(String string) {\n+        Objects.requireNonNull(string, \"string must not be null\");\n+        return new SimpleStringTemplate(List.of(string), List.of());\n+    }\n+\n+    \/**\n+     * Returns a StringTemplate composed from fragments and values.\n+     *\n+     * @implSpec The {@code fragments} list size must be one more that the\n+     * {@code values} list size.\n+     *\n+     * @param fragments list of string fragments\n+     * @param values    list of expression values\n+     *\n+     * @return StringTemplate composed from string\n+     *\n+     * @throws IllegalArgumentException if fragments list size is not one more\n+     *         than values list size\n+     * @throws NullPointerException if fragments is null or values is null or if any fragment is null.\n+     *\n+     * @implNote Contents of both lists are copied to construct immutable lists.\n+     *\/\n+    public static StringTemplate of(List<String> fragments, List<Object> values) {\n+        Objects.requireNonNull(fragments, \"fragments must not be null\");\n+        Objects.requireNonNull(values, \"values must not be null\");\n+        if (values.size() + 1 != fragments.size()) {\n+            throw new IllegalArgumentException(\n+                    \"fragments list size is not one more than values list size\");\n+        }\n+        for (String fragment : fragments) {\n+            Objects.requireNonNull(fragment, \"fragments elements must be non-null\");\n+        }\n+        fragments = Collections.unmodifiableList(new ArrayList<>(fragments));\n+        values = Collections.unmodifiableList(new ArrayList<>(values));\n+        return new SimpleStringTemplate(fragments, values);\n+    }\n+\n+     \/**\n+     * Creates a string that interleaves the elements of values between the\n+     * elements of fragments.\n+     *\n+     * @param fragments  list of String fragments\n+     * @param values     list of expression values\n+     *\n+     * @return String interpolation of fragments and values\n+     *\n+     * @throws NullPointerException fragments or values is null or if any of the fragments is null\n+     *\/\n+    public static String interpolate(List<String> fragments, List<Object> values) {\n+        return TemplateRuntime.interpolate(fragments, values);\n+    }\n+\n+    \/**\n+      * Combine one or more {@link StringTemplate StringTemplates} to produce a combined {@link StringTemplate}.\n+      * {@snippet :\n+      * StringTemplate st = StringTemplate.combine(RAW.\"\\{a}\", RAW.\"\\{b}\", RAW.\"\\{c}\");\n+      * assert st.interpolate().equals(RAW.\"\\{a}\\{b}\\{c}\");\n+      * }\n+      *\n+      * @param sts  one or more {@link StringTemplate}\n+      *\n+      * @return combined {@link StringTemplate}\n+      *\n+      * @throws NullPointerException if sts is null or if any of the elements are null\n+      * @throws RuntimeException if sts has zero elements\n+      *\/\n+    public static StringTemplate combine(StringTemplate... sts) {\n+        return TemplateRuntime.combine(sts);\n+    }\n+\n+    \/**\n+     * Interpolation template processor instance.\n+     * Example: {@snippet :\n+     * int x = 10;\n+     * int y = 20;\n+     * String result = STR.\"\\{x} + \\{y} = \\{x + y}\"; \/\/ @highlight substring=\"STR\"\n+     * }\n+     * @implNote The result of interpolation is not interned.\n+     *\/\n+    public static final StringProcessor STR = st -> st.interpolate();\n+\n+    \/**\n+     * No-op template processor. Used to highlight that non-processing of the StringTemplate\n+     * was intentional.\n+     * {@snippet :\n+     * \/\/ The string template before interpolation\n+     * System.out.println(RAW.\"\\{x} = \\{y} = \\{x + y}\");\n+     * \/\/ The string template after interpolation\n+     * System.out.println(STR.\"\\{x} = \\{y} = \\{x + y}\");\n+     * }\n+     *\/\n+    public static final TemplateProcessor<StringTemplate> RAW = st -> st;\n+\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/template\/StringTemplate.java","additions":368,"deletions":0,"binary":false,"changes":368,"status":"added"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.template;\n+\n+import java.util.Arrays;\n+import java.util.Objects;\n+\n+import jdk.internal.javac.PreviewFeature;\n+\n+\/**\n+ * This interface simplifies declaration of\n+ * {@linkplain ValidatingProcessor template processors}\n+ * that do not throw checked exceptions. For example:\n+ * {@snippet :\n+ * TemplateProcessor<String> processor = st -> {\n+ *     List<String> fragments = st.fragments();\n+ *     List<Object> values = st.values();\n+ *     \/\/ check or manipulate the fragments and\/or values\n+ *     ...\n+ *     return StringTemplate.interpolate(fragments, values);\n+ * };\n+ * }\n+ *\n+ * @param <R>  Processor's process result type.\n+ *\n+ * @since 20\n+ *\/\n+@PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n+@FunctionalInterface\n+public interface TemplateProcessor<R> extends ValidatingProcessor<R, RuntimeException> {}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/template\/TemplateProcessor.java","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -0,0 +1,392 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.template;\n+\n+import java.lang.invoke.*;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Modifier;\n+import java.util.*;\n+\n+import jdk.internal.access.JavaLangAccess;\n+import jdk.internal.access.JavaLangInvokeAccess;\n+import jdk.internal.access.SharedSecrets;\n+import jdk.internal.javac.PreviewFeature;\n+\n+\/**\n+ * This class provides runtime support for string templates. The methods within\n+ * are intended for internal use only.\n+ *\n+ * @since 20\n+ *\/\n+@PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n+public final class TemplateRuntime {\n+    \/**\n+     * Private constructor.\n+     *\/\n+    private TemplateRuntime() {\n+        throw new AssertionError(\"private constructor\");\n+    }\n+\n+    \/**\n+     * Templated string bootstrap method.\n+     *\n+     * @param lookup          method lookup\n+     * @param name            method name\n+     * @param type            method type\n+     * @param processorGetter {@link MethodHandle} to get static final processor\n+     * @param fragments       fragments from string template\n+     * @return {@link CallSite} to handle templated string processing\n+     * @throws NullPointerException if any of the arguments is null\n+     * @throws Throwable            if linkage fails\n+     *\/\n+    public static CallSite stringTemplateBSM(\n+            MethodHandles.Lookup lookup,\n+            String name,\n+            MethodType type,\n+            MethodHandle processorGetter,\n+            String... fragments) throws Throwable {\n+        Objects.requireNonNull(lookup, \"lookup is null\");\n+        Objects.requireNonNull(name, \"name is null\");\n+        Objects.requireNonNull(type, \"type is null\");\n+        Objects.requireNonNull(processorGetter, \"processorGetter is null\");\n+        Objects.requireNonNull(fragments, \"fragments is null\");\n+\n+        MethodType processorGetterType = MethodType.methodType(ValidatingProcessor.class);\n+        ValidatingProcessor<?, ? extends Throwable> processor =\n+                (ValidatingProcessor<?, ? extends Throwable>)processorGetter.asType(processorGetterType).invokeExact();\n+        TemplateBootstrap bootstrap = new TemplateBootstrap(lookup, name, type, List.of(fragments), processor);\n+\n+        return bootstrap.processWithProcessor();\n+    }\n+\n+    \/**\n+     * Manages the boostrapping of {@link ProcessorLinkage} callsites.\n+     *\/\n+    private static class TemplateBootstrap {\n+        \/**\n+         * {@link MethodHandle} to {@link TemplateBootstrap#defaultProcess}.\n+         *\/\n+        private static final MethodHandle DEFAULT_PROCESS_MH;\n+\n+        \/**\n+         * {@link MethodHandles.Lookup} passed to the bootstrap method.\n+         *\/\n+        private final MethodHandles.Lookup lookup;\n+\n+        \/**\n+         * Name passed to the bootstrap method (\"process\").\n+         *\/\n+        private final String name;\n+\n+        \/**\n+         * {@link MethodType} passed to the bootstrap method.\n+         *\/\n+        private final MethodType type;\n+\n+        \/**\n+         * Fragments from string template.\n+         *\/\n+        private final List<String> fragments;\n+\n+        \/**\n+         * Static final processor.\n+         *\/\n+        private final ValidatingProcessor<?, ? extends Throwable> processor;\n+\n+        \/**\n+         * Initialize {@link MethodHandle MethodHandles}.\n+         *\/\n+        static {\n+            try {\n+                MethodHandles.Lookup lookup = MethodHandles.lookup();\n+\n+                MethodType mt = MethodType.methodType(Object.class,\n+                        List.class, ValidatingProcessor.class, Object[].class);\n+                DEFAULT_PROCESS_MH = lookup.findStatic(TemplateBootstrap.class, \"defaultProcess\", mt);\n+            } catch (ReflectiveOperationException ex) {\n+                throw new AssertionError(\"templated string bootstrap fail\", ex);\n+            }\n+        }\n+\n+        \/**\n+         * Constructor.\n+         *\n+         * @param lookup    method lookup\n+         * @param name      method name\n+         * @param type      method type\n+         * @param fragments fragments from string template\n+         * @param processor static final processor\n+         *\/\n+        private TemplateBootstrap(MethodHandles.Lookup lookup, String name, MethodType type,\n+                                  List<String> fragments,\n+                                  ValidatingProcessor<?, ? extends Throwable> processor) {\n+            this.lookup = lookup;\n+            this.name = name;\n+            this.type = type;\n+            this.fragments = fragments;\n+            this.processor = processor;\n+\n+        }\n+\n+        \/**\n+         * Create callsite to invoke specialized processor process method.\n+         *\n+         * @return {@link CallSite} for processing templated strings.\n+         * @throws Throwable if linkage fails\n+         *\/\n+        private CallSite processWithProcessor() throws Throwable {\n+            MethodHandle mh = processor instanceof ProcessorLinkage processorLinkage ?\n+                    processorLinkage.linkage(fragments, type) : defaultProcessMethodHandle();\n+\n+            return new ConstantCallSite(mh);\n+        }\n+\n+        \/**\n+         * Creates a simple {@link StringTemplate} and then invokes the processor's process method.\n+         *\n+         * @param fragments fragments from string template\n+         * @param processor {@link ValidatingProcessor} to process\n+         * @param values    array of expression values\n+         * @return\n+         *\/\n+        private static Object defaultProcess(List<String> fragments,\n+                                             ValidatingProcessor<Object, Throwable> processor,\n+                                             Object[] values) throws Throwable {\n+            return processor.process(new SimpleStringTemplate(fragments, List.of(values)));\n+        }\n+\n+        \/**\n+         * Generate a {@link MethodHandle} which is effectively invokes\n+         * {@code processor.process(new StringTemplate(fragments, values...)}.\n+         *\n+         * @return default process {@link MethodHandle}\n+         *\/\n+        private MethodHandle defaultProcessMethodHandle() {\n+            MethodHandle mh = MethodHandles.insertArguments(DEFAULT_PROCESS_MH, 0, fragments, processor);\n+            mh = mh.withVarargs(true);\n+            mh = mh.asType(type);\n+\n+            return mh;\n+        }\n+\n+    }\n+\n+    \/**\n+     * Collect nullable elements from an array into a unmodifiable list.\n+     *\n+     * @param elements  elements to place in list\n+     *\n+     * @return unmodifiable list.\n+     *\n+     * @param <E>  type of elements\n+     *\n+     * @implNote Intended for use by {@link StringTemplate} implementations.\n+     * Other usage may lead to undesired effects.\n+     *\/\n+    @SuppressWarnings(\"unchecked\")\n+    public static <E> List<E> toList(E... elements) {\n+        return Collections.unmodifiableList(Arrays.asList(elements));\n+    }\n+\n+    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();\n+\n+    private static final JavaLangInvokeAccess JLIA = SharedSecrets.getJavaLangInvokeAccess();\n+\n+    \/**\n+     * Return the types of a {@link StringTemplate StringTemplate's} values.\n+     *\n+     * @param st  StringTemplate to examine\n+     *\n+     * @return list of value types\n+     *\n+     * @throws NullPointerException if st is null\n+     *\n+     * @implNote The default method determines if the {@link StringTemplate}\n+     * was synthesized by the compiler, then the types are precisely those of the\n+     * embedded expressions, otherwise this method returns the values list types.\n+     *\/\n+    static List<Class<?>> valueTypes(StringTemplate st) {\n+        Objects.requireNonNull(st, \"st must not be null\");\n+        List<Class<?>> result = new ArrayList<>();\n+        Class<?> tsClass = st.getClass();\n+        if (tsClass.isSynthetic()) {\n+            try {\n+                for (int i = 0; ; i++) {\n+                    Field field = tsClass.getDeclaredField(\"x\" + i);\n+                    result.add(field.getType());\n+                }\n+            } catch (NoSuchFieldException ex) {\n+                \/\/ End of fields\n+            } catch (SecurityException ex) {\n+                throw new InternalError(ex);\n+            }\n+\n+            return result;\n+        }\n+        for (Object value : st.values()) {\n+            result.add(value == null ? Object.class : value.getClass());\n+        }\n+        return result;\n+    }\n+\n+    \/**\n+     * Return {@link MethodHandle MethodHandles} to access a\n+     * {@link StringTemplate StringTemplate's} values.\n+     *\n+     * @param st  StringTemplate to examine\n+     *\n+     * @return list of {@link MethodHandle MethodHandles}\n+     *\n+     * @throws NullPointerException if st is null\n+     *\n+     * @implNote The default method determines if the {@link StringTemplate}\n+     * was synthesized by the compiler, then the MethodHandles are precisely those of the\n+     * embedded expressions fields, otherwise this method returns getters for the values list.\n+     *\/\n+    static List<MethodHandle> valueGetters(StringTemplate st) {\n+        Objects.requireNonNull(st, \"st must not be null\");\n+        List<MethodHandle> result = new ArrayList<>();\n+        Class<?> tsClass = st.getClass();\n+        if (tsClass.isSynthetic()) {\n+            try {\n+                for (int i = 0; ; i++) {\n+                    Field field = tsClass.getDeclaredField(\"x\" + i);\n+                    result.add(JLIA.unreflectField(field, false));\n+                }\n+            } catch (NoSuchFieldException ex) {\n+                \/\/ End of fields\n+            } catch (ReflectiveOperationException | SecurityException ex) {\n+                throw new InternalError(ex);\n+            }\n+\n+            return result;\n+        }\n+        try {\n+            MethodHandles.Lookup lookup = MethodHandles.lookup();\n+            MethodHandle getter = lookup.findStatic(TemplateRuntime.class, \"getValue\",\n+                MethodType.methodType(Object.class, int.class, StringTemplate.class));\n+            int size = st.values().size();\n+            for (int index = 0; index < size; index++) {\n+                result.add(MethodHandles.insertArguments(getter, 0, index));\n+            }\n+            return result;\n+        } catch (ReflectiveOperationException | SecurityException ex) {\n+            throw new InternalError(ex);\n+        }\n+    }\n+\n+    \/**\n+     * Private ethod used by {@link TemplateRuntime#valueGetters(StringTemplate)}\n+     * to access values.\n+     *\n+     * @param index values index\n+     * @param st    the {@link StringTemplate}\n+     *\n+     * @return value at index\n+     *\/\n+    private static Object getValue(int index, StringTemplate st) {\n+        return st.values().get(index);\n+    }\n+\n+    \/**\n+     * Creates a string that interleaves the elements of values between the\n+     * elements of fragments.\n+     *\n+     * @param fragments  list of String fragments\n+     * @param values     list of expression values\n+     *\n+     * @return String interpolation of fragments and values\n+     *\n+     * @throws NullPointerException fragments or values is null or if any of the fragments is null\n+     *\/\n+    static String interpolate(List<String> fragments, List<Object> values) {\n+        Objects.requireNonNull(fragments, \"fragments must not be null\");\n+        Objects.requireNonNull(values, \"values must not be null\");\n+        int fragmentsSize = fragments.size();\n+        int valuesSize = values.size();\n+        if (fragmentsSize != valuesSize + 1) {\n+            throw new RuntimeException(\"fragments must have one more element than values\");\n+        }\n+        if (fragmentsSize == 1) {\n+            String fragment = Objects.requireNonNull(fragments.get(0), \"fragments must not have null elements\");\n+            return fragments.get(0);\n+        }\n+        int size = fragmentsSize + valuesSize;\n+        String[] strings = new String[size];\n+        Iterator<String> fragmentsIter = fragments.iterator();\n+        int i = 0;\n+        for (Object value : values) {\n+            strings[i++] = Objects.requireNonNull(fragmentsIter.next(), \"fragments must not have null elements\");\n+            strings[i++] = String.valueOf(value);\n+        }\n+        strings[i++] = Objects.requireNonNull(fragmentsIter.next(), \"fragments must not have null elements\");\n+        return JLA.join(\"\", \"\", \"\", strings, size);\n+    }\n+\n+    \/**\n+     * Combine one or more {@link StringTemplate StringTemplates} to produce a combined {@link StringTemplate}.\n+     * {@snippet :\n+     * StringTemplate st = StringTemplate.combine(\"\\{a}\", \"\\{b}\", \"\\{c}\");\n+     * assert st.interpolate().equals(\"\\{a}\\{b}\\{c}\");\n+     * }\n+     *\n+     * @param sts  one or more {@link StringTemplate}\n+     *\n+     * @return combined {@link StringTemplate}\n+     *\n+     * @throws NullPointerException if sts is null or if any element of sts is null\n+     *\/\n+    static StringTemplate combine(StringTemplate... sts) {\n+        Objects.requireNonNull(sts, \"sts must not be null\");\n+        if (sts.length == 0) {\n+            return StringTemplate.of(\"\");\n+        } else if (sts.length == 1) {\n+            return Objects.requireNonNull(sts[0], \"string templates should not be null\");\n+        }\n+        int size = 0;\n+        for (StringTemplate st : sts) {\n+            Objects.requireNonNull(st, \"string templates should not be null\");\n+            size += st.values().size();\n+        }\n+        String[] fragments = new String[size + 1];\n+        Object[] values = new Object[size];\n+        int i = 0, j = 0;\n+        fragments[0] = \"\";\n+        for (StringTemplate st : sts) {\n+            Iterator<String> fragmentIter = st.fragments().iterator();\n+            fragments[i++] += fragmentIter.next();\n+            while (fragmentIter.hasNext()) {\n+                fragments[i++] = fragmentIter.next();\n+            }\n+            i--;\n+            for (Object value : st.values()) {\n+                values[j++] = value;\n+            }\n+        }\n+        return new SimpleStringTemplate(java.lang.template.TemplateRuntime.toList(fragments), java.lang.template.TemplateRuntime.toList(values));\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/template\/TemplateRuntime.java","additions":392,"deletions":0,"binary":false,"changes":392,"status":"added"},{"patch":"@@ -0,0 +1,163 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.template;\n+\n+import java.util.Objects;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.FutureTask;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+import jdk.internal.javac.PreviewFeature;\n+\n+\/**\n+ * This interface describes the methods provided by a generalized string template processor. The\n+ * primary method {@link ValidatingProcessor#process(StringTemplate)} is used to validate\n+ * and compose a result using a {@link StringTemplate StringTemplate's} fragments and values lists.\n+ * For example:\n+ * {@snippet :\n+ * class MyProcessor implements ValidatingProcessor<String, IllegalArgumentException> {\n+ *     @Override\n+ *     public String process(StringTemplate st) throws IllegalArgumentException {\n+ *          StringBuilder sb = new StringBuilder();\n+ *          Iterator<String> fragmentsIter = st.fragments().iterator();\n+ *\n+ *          for (Object value : st.values()) {\n+ *              sb.append(fragmentsIter.next());\n+ *\n+ *              if (value instanceof Boolean) {\n+ *                  throw new IllegalArgumentException(\"I don't like Booleans\");\n+ *              }\n+ *\n+ *              sb.append(value);\n+ *          }\n+ *\n+ *          sb.append(fragmentsIter.next());\n+ *\n+ *          return sb.toString();\n+ *     }\n+ * }\n+ *\n+ * MyProcessor myProcessor = new MyProcessor();\n+ * try {\n+ *     int x = 10;\n+ *     int y = 20;\n+ *     String result = myProcessor.\"\\{x} + \\{y} = \\{x + y}\";\n+ *     ...\n+ * } catch (IllegalArgumentException ex) {\n+ *     ...\n+ * }\n+ * }\n+ * Implementations of this interface may provide, but are not limited to, validating\n+ * inputs, composing inputs into a result, and transforming an intermediate string\n+ * result to a non-string value before delivering the final result.\n+ * <p>\n+ * The user has the option of validating inputs used in composition. For example an SQL\n+ * processor could prevent injection vulnerabilities by sanitizing inputs or throwing an\n+ * exception of type {@code E} if an SQL statement is a potential vulnerability.\n+ * <p>\n+ * Composing allows user control over how the result is assembled. Most often, a\n+ * user will construct a new string from the template string, with placeholders\n+ * replaced by stringified objects from the values list.\n+ * <p>\n+ * Transforming allows the processor to return something other than a string. For\n+ * instance, a JSON processor could return a JSON object, by parsing the string created\n+ * by composition, instead of the composed string.\n+ * <p>\n+ * {@link ValidatingProcessor} is a {@link FunctionalInterface}. This permits\n+ * declaration of a processor using lambda expressions;\n+ * {@snippet :\n+ * ValidatingProcessor<String, RuntimeException> processor = st -> {\n+ *     List<String> fragments = st.fragments();\n+ *     List<Object> values = st.values();\n+ *     \/\/ check or manipulate the fragments and\/or values\n+ *     ...\n+ *     return StringTemplate.interpolate(fragments, values);;\n+ * };\n+ * }\n+ * The {@link FunctionalInterface} {@link TemplateProcessor} is supplied to avoid\n+ * the use of checked exceptions;\n+ * {@snippet :\n+ * TemplateProcessor<String> processor = st -> {\n+ *     List<String> fragments = st.fragments();\n+ *     List<Object> values = st.values();\n+ *     \/\/ check or manipulate the fragments and\/or values\n+ *     ...\n+ *     return StringTemplate.interpolate(fragments, values);\n+ * };\n+ * }\n+ * The {@link FunctionalInterface} {@link StringProcessor} is supplied if\n+ * the processor returns {@link String};\n+ * {@snippet :\n+ * StringProcessor processor = st -> {\n+ *     List<String> fragments = st.fragments();\n+ *     List<Object> values = st.values();\n+ *     \/\/ check or manipulate the fragments and\/or values\n+ *     ...\n+ *     return StringTemplate.interpolate(fragments, values);\n+ * };\n+ * }\n+ * The {@link StringTemplate#interpolate()} method is available for those processors\n+ * that just need to work with the interpolatation;\n+ * {@snippet :\n+ * StringProcessor processor = StringTemplate::interpolate;\n+ * }\n+ * or simply transform the interpolatation into something other than\n+ * {@link String};\n+ * {@snippet :\n+ * TemplateProcessor<JSONObject> jsonProcessor = st -> new JSONObject(st.interpolate());\n+ * }\n+ * @implNote The Java compiler automatically imports {@link StringTemplate#STR}\n+ *\n+ * @param <R>  Processor's process result type\n+ * @param <E>  Exception thrown type\n+ *\n+ * @see java.lang.template.StringTemplate\n+ * @see java.lang.template.TemplateProcessor\n+ * @see java.lang.template.StringProcessor\n+ * @see java.util.FormatProcessor\n+ *\n+ * @since 20\n+ *\/\n+@PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n+@FunctionalInterface\n+public interface ValidatingProcessor<R, E extends Throwable> {\n+\n+    \/**\n+     * Constructs a result based on the template string and values in the\n+     * supplied {@link StringTemplate stringTemplate} object.\n+     *\n+     * @param stringTemplate  a {@link StringTemplate} instance\n+     *\n+     * @return constructed object of type R\n+     *\n+     * @throws E exception thrown by the template processor when validation fails\n+     *\/\n+    R process(StringTemplate stringTemplate) throws E;\n+\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/template\/ValidatingProcessor.java","additions":163,"deletions":0,"binary":false,"changes":163,"status":"added"},{"patch":"@@ -0,0 +1,31 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * Provides support for string templates and template processors.\n+ *\n+ * @since 20\n+ *\/\n+package java.lang.template;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/template\/package-info.java","additions":31,"deletions":0,"binary":false,"changes":31,"status":"added"},{"patch":"@@ -0,0 +1,84 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.util;\n+\n+import java.util.FormatItem.FormatItemDecimal;\n+import java.util.FormatItem.FormatItemHexadecimal;\n+import java.util.FormatItem.FormatItemOctal;\n+import java.util.FormatItem.FormatItemBoolean;\n+import java.util.FormatItem.FormatItemCharacter;\n+import java.util.FormatItem.FormatItemString;\n+import java.util.FormatItem.FormatItemFormatSpecifier;\n+import java.util.FormatItem.FormatItemModifier;\n+import java.util.FormatItem.FormatItemFillLeft;\n+import java.util.FormatItem.FormatItemFillRight;\n+import java.util.FormatItem.FormatItemUpper;\n+import java.util.FormatItem.FormatItemNull;\n+\n+import jdk.internal.javac.PreviewFeature;\n+\n+\/**\n+ * Implementations of this class provide information necessary to\n+ * assist {@link java.lang.invoke.StringConcatFactory} perform optimal\n+ * insertion.\n+ *\n+ * @since 20\n+ *\/\n+@PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n+public sealed interface FormatConcatItem\n+    permits FormatItemDecimal,\n+            FormatItemHexadecimal,\n+            FormatItemOctal,\n+            FormatItemBoolean,\n+            FormatItemCharacter,\n+            FormatItemString,\n+            FormatItemFormatSpecifier,\n+            FormatItemModifier,\n+            FormatItemFillLeft,\n+            FormatItemFillRight,\n+            FormatItemUpper,\n+            FormatItemNull\n+{\n+    \/**\n+     * Calculate the length of the insertion.\n+     *\n+     * @param lengthCoder current value of the length + coder\n+     * @return adjusted value of the length + coder\n+     *\/\n+    long mix(long lengthCoder);\n+\n+    \/**\n+     * Insert content into buffer prior to the current length.\n+     *\n+     * @param lengthCoder current value of the length + coder\n+     * @param buffer      buffer to right into\n+     *\n+     * @return adjusted value of the length + coder\n+     *\n+     * @throws Throwable if fails to prepend value (unusual).\n+     *\/\n+    long prepend(long lengthCoder, byte[] buffer) throws Throwable;\n+}\n","filename":"src\/java.base\/share\/classes\/java\/util\/FormatConcatItem.java","additions":84,"deletions":0,"binary":false,"changes":84,"status":"added"},{"patch":"@@ -0,0 +1,569 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.util;\n+\n+import java.io.IOException;\n+import java.lang.invoke.*;\n+import java.lang.invoke.MethodHandles.Lookup;\n+import java.nio.ByteOrder;\n+import java.nio.charset.StandardCharsets;\n+import java.text.DecimalFormatSymbols;\n+import java.util.Formatter.FormatSpecifier;\n+\n+import jdk.internal.access.JavaLangAccess;\n+import jdk.internal.access.SharedSecrets;\n+import jdk.internal.javac.PreviewFeature;\n+import jdk.internal.util.Digits;\n+import jdk.internal.util.Digits.*;\n+\n+import static java.lang.invoke.MethodType.methodType;\n+\n+\/**\n+ * A specialized objects used by FormatterBuilder that knows how to insert\n+ * themselves into a concatenation performed by StringConcatFactory.\n+ *\n+ * @since 19\n+ *\/\n+@PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n+class FormatItem {\n+    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();\n+\n+    private static final MethodHandle CHAR_MIX =\n+            JLA.stringConcatHelper(\"mix\",\n+                    MethodType.methodType(long.class, long.class,char.class));\n+\n+    private static final MethodHandle STRING_PREPEND =\n+            JLA.stringConcatHelper(\"prepend\",\n+                    MethodType.methodType(long.class, long.class, byte[].class,\n+                            String.class, String.class));\n+\n+    private static final MethodHandle SELECT_GETCHAR_MH =\n+            JLA.stringConcatHelper(\"selectGetChar\",\n+                    MethodType.methodType(MethodHandle.class, long.class));\n+\n+    private static final MethodHandle SELECT_PUTCHAR_MH =\n+            JLA.stringConcatHelper(\"selectPutChar\",\n+                    MethodType.methodType(MethodHandle.class, long.class));\n+\n+    private static final long charMix(long lengthCoder, char value) {\n+        try {\n+            return (long)CHAR_MIX.invokeExact(lengthCoder, value);\n+        } catch (RuntimeException ex) {\n+            throw ex;\n+        } catch (Throwable ex) {\n+            throw new RuntimeException(ex);\n+        }\n+    }\n+\n+    private static final long stringMix(long lengthCoder, String value) {\n+        return JLA.stringConcatMix(lengthCoder, value);\n+    }\n+\n+    private static final long stringPrepend(long lengthCoder, byte[] buffer,\n+                                            String value) throws Throwable {\n+        return (long)STRING_PREPEND.invokeExact(lengthCoder, buffer, value,\n+                (String)null);\n+    }\n+\n+    private static MethodHandle selectGetChar(long indexCoder) throws Throwable {\n+        return (MethodHandle)SELECT_GETCHAR_MH.invokeExact(indexCoder);\n+    }\n+\n+    private static MethodHandle selectPutChar(long indexCoder) throws Throwable {\n+        return (MethodHandle)SELECT_PUTCHAR_MH.invokeExact(indexCoder);\n+    }\n+\n+    private static final MethodHandle PUT_CHAR_DIGIT;\n+\n+    static {\n+        try {\n+            Lookup lookup = MethodHandles.lookup();\n+            PUT_CHAR_DIGIT = lookup.findStatic(FormatItem.class, \"putByte\",\n+                    MethodType.methodType(void.class,\n+                            byte[].class, int.class, int.class));\n+        } catch (ReflectiveOperationException ex) {\n+            throw new AssertionError(\"putByte lookup failed\", ex);\n+        }\n+    }\n+\n+    private static void putByte(byte[] buffer, int index, int ch) {\n+        buffer[index] = (byte)ch;\n+    }\n+\n+    private FormatItem() {\n+        throw new AssertionError(\"private constructor\");\n+    }\n+\n+    \/**\n+     * Decimal value format item.\n+     *\/\n+    static final class FormatItemDecimal implements FormatConcatItem {\n+        private final char groupingSeparator;\n+        private final char zeroDigit;\n+        private final char minusSign;\n+        private final int digitOffset;\n+        private final byte[] digits;\n+        private final int length;\n+        private final boolean isNegative;\n+        private final int width;\n+        private final byte prefixSign;\n+        private final int groupSize;\n+        private final long value;\n+        private final boolean parentheses;\n+\n+        FormatItemDecimal(DecimalFormatSymbols dfs, int width, char sign,\n+                          boolean parentheses, int groupSize, long value) throws Throwable {\n+            this.groupingSeparator = dfs.getGroupingSeparator();\n+            this.zeroDigit = dfs.getZeroDigit();\n+            this.minusSign = dfs.getMinusSign();\n+            this.digitOffset = this.zeroDigit - '0';\n+            int length = DecimalDigits.INSTANCE.size(value);\n+            this.digits = new byte[length];\n+            DecimalDigits.INSTANCE.digits(value, this.digits, length, PUT_CHAR_DIGIT);\n+            this.isNegative = value < 0L;\n+            this.length = this.isNegative ? length - 1 : length;\n+            this.width = width;\n+            this.groupSize = groupSize;\n+            this.value = value;\n+            this.parentheses = parentheses && isNegative;\n+            this.prefixSign = (byte)(isNegative ? (parentheses ? '\\0' : minusSign) : sign);\n+        }\n+\n+        private int signLength() {\n+            return (prefixSign != '\\0' ? 1 : 0) + (parentheses ? 2 : 0);\n+        }\n+\n+        private int groupLength() {\n+            return 0 < groupSize ? (length - 1) \/ groupSize : 0;\n+        }\n+\n+        @Override\n+        public long mix(long lengthCoder) {\n+            return JLA.stringConcatCoder(zeroDigit) |\n+                    (lengthCoder +\n+                     Integer.max(length + signLength() + groupLength(), width));\n+        }\n+\n+        @Override\n+        public long prepend(long lengthCoder, byte[] buffer) throws Throwable {\n+            MethodHandle putCharMH = selectPutChar(lengthCoder);\n+\n+            if (parentheses) {\n+                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)')');\n+            }\n+\n+            if (0 < groupSize) {\n+                int groupIndex = groupSize;\n+\n+                for (int i = 1; i <= length; i++) {\n+                    if (groupIndex-- == 0) {\n+                        putCharMH.invokeExact(buffer, (int)--lengthCoder,\n+                                (int)groupingSeparator);\n+                        groupIndex = groupSize - 1;\n+                    }\n+\n+                    putCharMH.invokeExact(buffer, (int)--lengthCoder,\n+                            digits[digits.length - i] + digitOffset);\n+                }\n+            } else {\n+                for (int i = 1; i <= length; i++) {\n+                    putCharMH.invokeExact(buffer, (int)--lengthCoder,\n+                            digits[digits.length - i] + digitOffset);\n+                }\n+            }\n+\n+            for (int i = length + signLength() + groupLength(); i < width; i++) {\n+                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'0');\n+            }\n+\n+            if (parentheses) {\n+                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'(');\n+            }\n+            if (prefixSign != '\\0') {\n+                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)prefixSign);\n+            }\n+\n+            return lengthCoder;\n+        }\n+    }\n+\n+    \/**\n+     * Hexadecimal format item.\n+     *\/\n+    static final class FormatItemHexadecimal implements FormatConcatItem {\n+        private final int width;\n+        private final boolean hasPrefix;\n+        private final long value;\n+        private final int length;\n+\n+        FormatItemHexadecimal(int width, boolean hasPrefix, long value) {\n+            this.width = width;\n+            this.hasPrefix = hasPrefix;\n+            this.value = value;\n+            this.length = HexDigits.INSTANCE.size(value);\n+        }\n+\n+        private int prefixLength() {\n+            return hasPrefix ? 2 : 0;\n+        }\n+\n+        private int zeroesLength() {\n+            return Integer.max(0, width - length - prefixLength());\n+        }\n+\n+        @Override\n+        public long mix(long lengthCoder) {\n+            return lengthCoder + length + prefixLength() + zeroesLength();\n+        }\n+\n+        @Override\n+        public long prepend(long lengthCoder, byte[] buffer) throws Throwable {\n+            MethodHandle putCharMH = selectPutChar(lengthCoder);\n+            HexDigits.INSTANCE.digits(value, buffer, (int)lengthCoder, putCharMH);\n+            lengthCoder -= length;\n+\n+            for (int i = 0; i < zeroesLength(); i++) {\n+                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'0');\n+            }\n+\n+            if (hasPrefix) {\n+                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'x');\n+                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'0');\n+            }\n+\n+            return lengthCoder;\n+        }\n+    }\n+\n+    \/**\n+     * Hexadecimal format item.\n+     *\/\n+    static final class FormatItemOctal implements FormatConcatItem {\n+        private final int width;\n+        private final boolean hasPrefix;\n+        private final long value;\n+        private final int length;\n+\n+        FormatItemOctal(int width, boolean hasPrefix, long value) {\n+            this.width = width;\n+            this.hasPrefix = hasPrefix;\n+            this.value = value;\n+            this.length = OctalDigits.INSTANCE.size(value);\n+        }\n+\n+        private int prefixLength() {\n+            return hasPrefix && value != 0 ? 1 : 0;\n+        }\n+\n+        private int zeroesLength() {\n+            return Integer.max(0, width - length - prefixLength());\n+        }\n+\n+        @Override\n+        public long mix(long lengthCoder) {\n+            return lengthCoder + length + prefixLength() + zeroesLength();\n+        }\n+\n+        @Override\n+        public long prepend(long lengthCoder, byte[] buffer) throws Throwable {\n+            MethodHandle putCharMH = selectPutChar(lengthCoder);\n+            OctalDigits.INSTANCE.digits(value, buffer, (int)lengthCoder, putCharMH);\n+            lengthCoder -= length;\n+\n+            for (int i = 0; i < zeroesLength(); i++) {\n+                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'0');\n+            }\n+\n+            if (hasPrefix && value != 0) {\n+                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'0');\n+            }\n+\n+            return lengthCoder;\n+        }\n+    }\n+\n+    \/**\n+     * Boolean format item.\n+     *\/\n+    static final class FormatItemBoolean implements FormatConcatItem {\n+        private final boolean value;\n+\n+        FormatItemBoolean(boolean value) {\n+            this.value = value;\n+        }\n+\n+        @Override\n+        public long mix(long lengthCoder) {\n+            return lengthCoder + (value ? \"true\".length() : \"false\".length());\n+        }\n+\n+        @Override\n+        public long prepend(long lengthCoder, byte[] buffer) throws Throwable {\n+            MethodHandle putCharMH = selectPutChar(lengthCoder);\n+\n+            if (value) {\n+                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'e');\n+                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'u');\n+                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'r');\n+                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'t');\n+            } else {\n+                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'e');\n+                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'s');\n+                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'l');\n+                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'a');\n+                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'f');\n+            }\n+\n+            return lengthCoder;\n+         }\n+    }\n+\n+    \/**\n+     * Character format item.\n+     *\/\n+    static final class FormatItemCharacter implements FormatConcatItem {\n+        private final char value;\n+\n+        FormatItemCharacter(char value) {\n+            this.value = value;\n+        }\n+\n+        @Override\n+        public long mix(long lengthCoder) {\n+            return charMix(lengthCoder, value);\n+        }\n+\n+        @Override\n+        public long prepend(long lengthCoder, byte[] buffer) throws Throwable {\n+            MethodHandle putCharMH = selectPutChar(lengthCoder);\n+            putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)value);\n+\n+            return lengthCoder;\n+        }\n+    }\n+\n+    \/**\n+     * String format item.\n+     *\/\n+    static final class FormatItemString implements FormatConcatItem {\n+        private String value;\n+\n+        FormatItemString(String value) {\n+            this.value = value;\n+        }\n+\n+        @Override\n+        public long mix(long lengthCoder) {\n+            return stringMix(lengthCoder, value);\n+        }\n+\n+        @Override\n+        public long prepend(long lengthCoder, byte[] buffer) throws Throwable {\n+            return stringPrepend(lengthCoder, buffer, value);\n+        }\n+    }\n+\n+    \/**\n+     * FormatSpecifier format item.\n+     *\/\n+    static final class FormatItemFormatSpecifier implements FormatConcatItem {\n+        private StringBuilder sb;\n+\n+        FormatItemFormatSpecifier(FormatSpecifier fs, Locale locale, Object value) {\n+            this.sb = new StringBuilder(64);\n+            Formatter formatter = new Formatter(this.sb, locale);\n+\n+            try {\n+                fs.print(formatter, value, locale);\n+            } catch (IOException ex) {\n+                throw new AssertionError(\"FormatItemFormatSpecifier IOException\", ex);\n+            }\n+        }\n+\n+        FormatItemFormatSpecifier(Locale locale,\n+                                  int flags, int width, int precision,\n+                                  Formattable formattable) {\n+            this.sb = new StringBuilder(64);\n+            Formatter formatter = new Formatter(this.sb, locale);\n+            formattable.formatTo(formatter, flags, width, precision);\n+        }\n+\n+        @Override\n+        public long mix(long lengthCoder) {\n+            return JLA.stringBuilderConcatMix(lengthCoder, sb);\n+        }\n+\n+        @Override\n+        public long prepend(long lengthCoder, byte[] buffer) throws Throwable {\n+            return JLA.stringBuilderConcatPrepend(lengthCoder, buffer, sb);\n+        }\n+    }\n+\n+    protected static abstract sealed class FormatItemModifier implements FormatConcatItem\n+        permits FormatItemFillLeft,\n+                FormatItemFillRight,\n+                FormatItemUpper\n+    {\n+        private final long itemLengthCoder;\n+        protected final FormatConcatItem item;\n+\n+        FormatItemModifier(FormatConcatItem item) {\n+            this.itemLengthCoder = item.mix(0L);\n+            this.item = item;\n+        }\n+\n+        int length() {\n+            return (int)itemLengthCoder;\n+        }\n+\n+        long coder() {\n+            return itemLengthCoder & ~Integer.MAX_VALUE;\n+        }\n+\n+        @Override\n+        public abstract long mix(long lengthCoder);\n+\n+        @Override\n+        public abstract long prepend(long lengthCoder, byte[] buffer) throws Throwable;\n+    }\n+\n+    \/**\n+     * Fill left format item.\n+     *\/\n+    static final class FormatItemFillLeft extends FormatItemModifier\n+            implements FormatConcatItem {\n+        private final int width;\n+\n+        FormatItemFillLeft(int width, FormatConcatItem item) {\n+            super(item);\n+            this.width = Integer.max(length(), width);\n+        }\n+\n+        @Override\n+        public long mix(long lengthCoder) {\n+            return (lengthCoder | coder()) + width;\n+        }\n+\n+        @Override\n+        public long prepend(long lengthCoder, byte[] buffer) throws Throwable {\n+            MethodHandle putCharMH = selectPutChar(lengthCoder);\n+            lengthCoder = item.prepend(lengthCoder, buffer);\n+\n+            for (int i = length(); i < width; i++) {\n+                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)' ');\n+            }\n+\n+            return lengthCoder;\n+        }\n+    }\n+\n+    \/**\n+     * Fill right format item.\n+     *\/\n+    static final class FormatItemFillRight extends FormatItemModifier\n+            implements FormatConcatItem {\n+        private final int width;\n+\n+        FormatItemFillRight(int width, FormatConcatItem item) {\n+            super(item);\n+            this.width = Integer.max(length(), width);\n+        }\n+\n+        @Override\n+        public long mix(long lengthCoder) {\n+            return (lengthCoder | coder()) + width;\n+        }\n+\n+        @Override\n+        public long prepend(long lengthCoder, byte[] buffer) throws Throwable {\n+            MethodHandle putCharMH = selectPutChar(lengthCoder);\n+\n+            for (int i = length(); i < width; i++) {\n+                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)' ');\n+            }\n+\n+            lengthCoder = item.prepend(lengthCoder, buffer);\n+\n+            return lengthCoder;\n+        }\n+    }\n+\n+\n+    \/**\n+     * To upper case format item.\n+     *\/\n+    static final class FormatItemUpper extends FormatItemModifier\n+            implements FormatConcatItem {\n+        FormatItemUpper(FormatConcatItem item) {\n+            super(item);\n+        }\n+\n+        @Override\n+        public long mix(long lengthCoder) {\n+            return (lengthCoder | coder()) + length();\n+        }\n+\n+        @Override\n+        public long prepend(long lengthCoder, byte[] buffer) throws Throwable {\n+            MethodHandle getCharMH = selectGetChar(lengthCoder);\n+            MethodHandle putCharMH = selectPutChar(lengthCoder);\n+            lengthCoder = item.prepend(lengthCoder, buffer);\n+            int start = (int)lengthCoder;\n+\n+            for (int i = 0; i < length(); i++) {\n+                char ch = (char)getCharMH.invokeExact(buffer, start + i);\n+                putCharMH.invokeExact(buffer, start + i, (int)Character.toUpperCase(ch));\n+            }\n+\n+            return lengthCoder;\n+        }\n+    }\n+\n+    \/**\n+     * Null format item.\n+     *\/\n+    static final class FormatItemNull implements FormatConcatItem {\n+        FormatItemNull() {\n+        }\n+\n+        @Override\n+        public long mix(long lengthCoder) {\n+            return lengthCoder + \"null\".length();\n+        }\n+\n+        @Override\n+        public long prepend(long lengthCoder, byte[] buffer) throws Throwable {\n+            MethodHandle putCharMH = selectPutChar(lengthCoder);\n+\n+            putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'l');\n+            putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'l');\n+            putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'u');\n+            putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'n');\n+\n+            return lengthCoder;\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/util\/FormatItem.java","additions":569,"deletions":0,"binary":false,"changes":569,"status":"added"},{"patch":"@@ -0,0 +1,200 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.util;\n+\n+import java.lang.invoke.*;\n+import java.lang.invoke.MethodHandles.Lookup;\n+import java.lang.template.*;\n+import java.util.*;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import jdk.internal.javac.PreviewFeature;\n+\n+\/**\n+ * This {@linkplain ValidatingProcessor yemplate processor} constructs a String\n+ * result using {@link Formatter}. Unlike {@link Formatter}, FormatProcessor uses the value from\n+ * the embedded expression that follows immediately after the\n+ * <a href=\"..\/util\/Formatter.html#syntax\">format specifier<\/a>.\n+ * StringTemplate expressions without a preceeding specifier, use \"%s\" by\n+ * default. Example:\n+ * {@snippet :\n+ * int x = 10;\n+ * int y = 20;\n+ * String result = FMT.\"%05d\\{x} + %05d\\{y} = %05d\\{x + y}\";\n+ * }\n+ * result is: <code>00010 + 00020 = 00030<\/code>\n+ *\n+ * @implNote When used in conjunction with a compiler generated {@link\n+ * StringTemplate} this {@link ValidatingProcessor} will use the format\n+ * specifiers in the fragments and types of the values in the value list\n+ * to produce a more performant formatter.\n+ *\n+ * @implSpec Since, values are in situ, argument indexing is unsupported.\n+ *\n+ * @since 20\n+ *\/\n+@PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n+public final class FormatProcessor implements StringProcessor, ProcessorLinkage {\n+    \/**\n+     * {@link Locale} used to format\n+     *\/\n+    private final Locale locale;\n+\n+    \/**\n+     * Constructor.\n+     *\n+     * @param locale  {@link Locale} used to format\n+     *\/\n+    public FormatProcessor(Locale locale) {\n+        this.locale = locale;\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     * @throws  IllegalFormatException\n+     *          If a format string contains an illegal syntax, a format\n+     *          specifier that is incompatible with the given arguments,\n+     *          insufficient arguments given the format string, or other\n+     *          illegal conditions.  For specification of all possible\n+     *          formatting errors.\n+     * @see java.util.Formatter\n+     *\/\n+    @Override\n+    public final String process(StringTemplate stringTemplate) {\n+        Objects.requireNonNull(stringTemplate);\n+        String format = stringTemplateFormat(stringTemplate.fragments());\n+        Object[] values = stringTemplate.values().toArray(new Object[0]);\n+\n+        return new Formatter(locale).format(format, values).toString();\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     * @throws  IllegalFormatException\n+     *          If a format string contains an illegal syntax, a format\n+     *          specifier that is incompatible with the given arguments,\n+     *          insufficient arguments given the format string, or other\n+     *          illegal conditions.  For specification of all possible\n+     *          formatting errors.\n+     * @see java.util.Formatter\n+     *\/\n+    @Override\n+    public MethodHandle linkage(List<String> fragments, MethodType type) {\n+        Objects.requireNonNull(fragments);\n+        Objects.requireNonNull(type);\n+        String format = stringTemplateFormat(fragments);\n+        Class<?>[] ptypes = type.dropParameterTypes(0, 1).parameterArray();\n+        MethodHandle mh = new FormatterBuilder(format, locale, ptypes).build();\n+        mh = MethodHandles.dropArguments(mh, 0, type.parameterType(0));\n+\n+        return mh;\n+    }\n+\n+    \/\/ %[argument_index$][flags][width][.precision][t]conversion\n+    private static final String formatSpecifier\n+            = \"%(\\\\d+\\\\$)?([-#+ 0,(\\\\<]*)?(\\\\d+)?(\\\\.\\\\d+)?([tT])?([a-zA-Z%])\";\n+\n+    private static final Pattern fsPattern = Pattern.compile(formatSpecifier);\n+\n+    \/**\n+     * Find a format specification at the end of a fragment.\n+     *\n+     * @param fragment  fragment to check\n+     * @param needed    if the specification is needed\n+     *\n+     * @return true if the specification is found and needed\n+     *\n+     * @throws MissingFormatArgumentException if not at end or found and not needed\n+     *\/\n+    private static boolean findFormat(String fragment, boolean needed) {\n+        Matcher matcher = fsPattern.matcher(fragment);\n+        String group;\n+\n+        while (matcher.find()) {\n+            group = matcher.group();\n+\n+            if (!group.equals(\"%%\") && !group.equals(\"%n\")) {\n+                if (matcher.end() == fragment.length() && needed) {\n+                    return true;\n+                }\n+\n+                throw new MissingFormatArgumentException(group);\n+            }\n+        }\n+\n+        return false;\n+    }\n+\n+    \/**\n+     * Convert a {@link StringTemplate} fragments, containing format specifications,\n+     * to a form that can be passed on to {@link Formatter}. The method scans each fragment,\n+     * matching up formatter specifications with the following expression. If no\n+     * specification is found, the method inserts \"%s\".\n+     *\n+     * @param fragments  string template fragments\n+     *\n+     * @return  format string\n+     *\/\n+    private static String stringTemplateFormat(List<String> fragments) {\n+        StringBuilder sb = new StringBuilder();\n+        int lastIndex = fragments.size() - 1;\n+        List<String> formats = fragments.subList(0, lastIndex);\n+        String last = fragments.get(lastIndex);\n+\n+        for (String format : formats) {\n+            if (findFormat(format, true)) {\n+                sb.append(format);\n+            } else {\n+                sb.append(format);\n+                sb.append(\"%s\");\n+            }\n+        }\n+\n+        if (!findFormat(last, false)) {\n+            sb.append(last);\n+        }\n+\n+        return sb.toString();\n+    }\n+\n+    \/**\n+     * This predefined FormatProcessor instance constructs a String result using {@link\n+     * Formatter}. Unlike {@link Formatter}, FormatProcessor uses the value from\n+     * the embedded expression that follows immediately after the\n+     * <a href=\"..\/..\/util\/Formatter.html#syntax\">format specifier<\/a>.\n+     * StringTemplate expressions without a preceeding specifier, use \"%s\" by\n+\n+     * Example: {@snippet :\n+     * int x = 123;\n+     * int y = 987;\n+     * String result = FMT.\"%3d\\{x} + %3d\\{y} = %4d\\{x + y}\"; \/\/ @highlight substring=\"FMT\"\n+     * }\n+     * {@link FMT} uses the Locale.US {@link Locale}.\n+     *\/\n+    public static final FormatProcessor FMT = new FormatProcessor(Locale.US);\n+\n+}\n","filename":"src\/java.base\/share\/classes\/java\/util\/FormatProcessor.java","additions":200,"deletions":0,"binary":false,"changes":200,"status":"added"},{"patch":"@@ -39,0 +39,1 @@\n+import java.lang.invoke.MethodHandle;\n@@ -63,0 +64,1 @@\n+import jdk.internal.javac.PreviewFeature;\n@@ -2764,2 +2766,1 @@\n-        for (int i = 0; i < fsa.size(); i++) {\n-            var fs = fsa.get(i);\n+        for (FormatString fs : fsa) {\n@@ -2783,1 +2784,1 @@\n-                    default -> {  \/\/ explicit index\n+                    default -> { \/\/ explicit index\n@@ -2806,1 +2807,1 @@\n-    private List<FormatString> parse(String s) {\n+    static List<FormatString> parse(String s) {\n@@ -2849,1 +2850,1 @@\n-    private interface FormatString {\n+    interface FormatString {\n@@ -2885,1 +2886,2 @@\n-    private static class FormatSpecifier implements FormatString {\n+    static class FormatSpecifier implements FormatString {\n+        private static final double SCALEUP = Math.scalb(1.0, 54);\n@@ -2887,6 +2889,6 @@\n-        private int index = 0;\n-        private int flags = Flags.NONE;\n-        private int width = -1;\n-        private int precision = -1;\n-        private boolean dt = false;\n-        private char c;\n+        int index = 0;\n+        int flags = Flags.NONE;\n+        int width = -1;\n+        int precision = -1;\n+        boolean dt = false;\n+        char c;\n@@ -3545,1 +3547,0 @@\n-                localizedMagnitude(fmt, sb, mant, 0, flags, newW, l);\n@@ -3547,0 +3548,1 @@\n+                localizedMagnitude(fmt, sb, mant, 0, flags, newW, l);\n@@ -3718,2 +3720,1 @@\n-                    double scaleUp = Math.scalb(1.0, 54);\n-                    d *= scaleUp;\n+                    d *= SCALEUP;\n@@ -4623,1 +4624,1 @@\n-    private static class Flags {\n+    static class Flags {\n@@ -4701,1 +4702,1 @@\n-    private static class Conversion {\n+    static class Conversion {\n@@ -4826,1 +4827,1 @@\n-    private static class DateTime {\n+    static class DateTime {\n@@ -4877,0 +4878,1 @@\n+\n","filename":"src\/java.base\/share\/classes\/java\/util\/Formatter.java","additions":20,"deletions":18,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -0,0 +1,491 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.util;\n+\n+import java.io.IOException;\n+import java.lang.invoke.*;\n+import java.lang.invoke.MethodHandles.Lookup;\n+import java.text.DecimalFormat;\n+import java.text.DecimalFormatSymbols;\n+import java.text.NumberFormat;\n+import java.text.spi.NumberFormatProvider;\n+import java.util.FormatItem.*;\n+import java.util.Formatter.*;\n+\n+import jdk.internal.javac.PreviewFeature;\n+\n+import sun.invoke.util.Wrapper;\n+import sun.util.locale.provider.LocaleProviderAdapter;\n+import sun.util.locale.provider.ResourceBundleBasedAdapter;\n+\n+import static java.util.Formatter.Conversion.*;\n+import static java.util.Formatter.Flags.*;\n+import static java.lang.invoke.MethodHandles.*;\n+import static java.lang.invoke.MethodType.*;\n+\n+\/**\n+ * This package private class supports the construction of the {@link MethodHandle}\n+ * returned by {@Link Formatter#formatFactory}.\n+ *\n+ * @since 20\n+ *\/\n+@PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n+final class FormatterBuilder {\n+    private static final Lookup LOOKUP = lookup();\n+\n+    private final String format;\n+    private final Locale locale;\n+    private final Class<?>[] ptypes;\n+    private final DecimalFormatSymbols dfs;\n+    private final boolean isGenericDFS;\n+\n+    FormatterBuilder(String format, Locale locale, Class<?>[] ptypes) {\n+        this.format = format;\n+        this.locale = locale;\n+        this.ptypes = ptypes;\n+        this.dfs = DecimalFormatSymbols.getInstance(locale);\n+        this.isGenericDFS = isGenericDFS(this.dfs);\n+    }\n+\n+    private static boolean isGenericDFS(DecimalFormatSymbols dfs) {\n+        return dfs.getZeroDigit() == '0' &&\n+               dfs.getDecimalSeparator() == '.' &&\n+               dfs.getGroupingSeparator() == ',' &&\n+               dfs.getMinusSign() == '-';\n+    }\n+\n+    private static Class<?> mapType(Class<?> type) {\n+        return type.isPrimitive() || type == String.class ? type : Object.class;\n+    }\n+\n+    private static MethodHandle findStringConcatItemConstructor(Class<?> cls,\n+                                          Class<?>... ptypes) {\n+        MethodType methodType = methodType(void.class, ptypes);\n+\n+        try {\n+            MethodHandle mh = LOOKUP.findConstructor(cls, methodType);\n+\n+            return mh.asType(mh.type().changeReturnType(FormatConcatItem.class));\n+        } catch (ReflectiveOperationException e) {\n+            throw new AssertionError(\"Missing constructor in \" +\n+                    cls + \": \" + methodType);\n+        }\n+    }\n+\n+    private static MethodHandle findMethod(Class<?> cls, String name,\n+                                           Class<?> rType, Class<?>... ptypes) {\n+        MethodType methodType = methodType(rType, ptypes);\n+\n+        try {\n+            return LOOKUP.findVirtual(cls, name, methodType);\n+        } catch (ReflectiveOperationException e) {\n+            throw new AssertionError(\"Missing method in \" +\n+                    cls + \": \" + name + \" \" + methodType);\n+        }\n+    }\n+\n+    private static MethodHandle findStaticMethod(Class<?> cls, String name,\n+                                                 Class<?> rType, Class<?>... ptypes) {\n+        MethodType methodType = methodType(rType, ptypes);\n+\n+        try {\n+            return LOOKUP.findStatic(cls, name, methodType);\n+        } catch (ReflectiveOperationException e) {\n+            throw new AssertionError(\"Missing static method in \" +\n+                    cls + \": \" + name + \" \" + methodType);\n+        }\n+    }\n+\n+    private static final MethodHandle FIDecimal_MH =\n+            findStringConcatItemConstructor(FormatItemDecimal.class,\n+                    DecimalFormatSymbols.class, int.class, char.class, boolean.class,\n+                    int.class, long.class);\n+\n+    private static final MethodHandle FIHexadecimal_MH =\n+            findStringConcatItemConstructor(FormatItemHexadecimal.class,\n+                    int.class, boolean.class, long.class);\n+\n+    private static final MethodHandle FIOctal_MH =\n+            findStringConcatItemConstructor(FormatItemOctal.class,\n+                    int.class, boolean.class, long.class);\n+\n+    private static final MethodHandle FIBoolean_MH =\n+            findStringConcatItemConstructor(FormatItemBoolean.class,\n+                    boolean.class);\n+\n+    private static final MethodHandle FICharacter_MH =\n+            findStringConcatItemConstructor(FormatItemCharacter.class,\n+                    char.class);\n+\n+    private static final MethodHandle FIString_MH =\n+            findStringConcatItemConstructor(FormatItemString.class,\n+                    String.class);\n+\n+    private static final MethodHandle FIFormatSpecifier_MH =\n+            findStringConcatItemConstructor(FormatItemFormatSpecifier.class,\n+                    FormatSpecifier.class, Locale.class, Object.class);\n+\n+    private static final MethodHandle FIFormattable_MH =\n+            findStringConcatItemConstructor(FormatItemFormatSpecifier.class,\n+                    Locale.class, int.class, int.class, int.class,\n+                    Formattable.class);\n+\n+    private static final MethodHandle FIFillLeft_MH =\n+             findStringConcatItemConstructor(FormatItemFillLeft.class,\n+                    int.class, FormatConcatItem.class);\n+\n+    private static final MethodHandle FIFillRight_MH =\n+            findStringConcatItemConstructor(FormatItemFillRight.class,\n+                     int.class, FormatConcatItem.class);\n+\n+    private static final MethodHandle FIUpper_MH =\n+            findStringConcatItemConstructor(FormatItemUpper.class,\n+                    FormatConcatItem.class);\n+\n+    private static final MethodHandle FINull_MH =\n+            findStringConcatItemConstructor(FormatItemNull.class);\n+\n+    private static final MethodHandle NullCheck_MH =\n+            findStaticMethod(FormatterBuilder.class, \"nullCheck\", boolean.class,\n+                    Object.class);\n+\n+    private static final MethodHandle FormattableCheck_MH =\n+            findStaticMethod(FormatterBuilder.class, \"formattableCheck\", boolean.class,\n+                    Object.class);\n+\n+    private static final MethodHandle ToLong_MH =\n+            findStaticMethod(java.util.FormatterBuilder.class, \"toLong\", long.class,\n+                    int.class);\n+\n+    private static final MethodHandle ToString_MH =\n+            findStaticMethod(String.class, \"valueOf\", String.class,\n+                    Object.class);\n+\n+    private static final MethodHandle HashCode_MH =\n+            findStaticMethod(Objects.class, \"hashCode\", int.class,\n+                    Object.class);\n+\n+    private static boolean nullCheck(Object object) {\n+        return object == null;\n+    }\n+\n+    private static boolean formattableCheck(Object object) {\n+        return Formattable.class.isAssignableFrom(object.getClass());\n+    }\n+\n+    private static long toLong(int value) {\n+        return (long)value & 0xFFFFFFFFL;\n+    }\n+\n+    private static boolean isFlag(int value, int flags) {\n+        return (value & flags) != 0;\n+    }\n+\n+    private static boolean validFlags(int value, int flags) {\n+        return (value & ~flags) == 0;\n+    }\n+\n+    private static int groupSize(Locale locale, DecimalFormatSymbols dfs) {\n+        if (isGenericDFS(dfs)) {\n+            return 3;\n+        }\n+\n+        DecimalFormat df;\n+        NumberFormat nf = NumberFormat.getNumberInstance(locale);\n+\n+        if (nf instanceof DecimalFormat) {\n+            df = (DecimalFormat)nf;\n+        } else {\n+            LocaleProviderAdapter adapter = LocaleProviderAdapter\n+                    .getAdapter(NumberFormatProvider.class, locale);\n+\n+            if (!(adapter instanceof ResourceBundleBasedAdapter)) {\n+                adapter = LocaleProviderAdapter.getResourceBundleBased();\n+            }\n+\n+            String[] all = adapter.getLocaleResources(locale)\n+                    .getNumberPatterns();\n+\n+            df = new DecimalFormat(all[0], dfs);\n+        }\n+\n+        return df.isGroupingUsed() ? df.getGroupingSize() : 0;\n+    }\n+\n+    private MethodHandle formatSpecifier(FormatSpecifier fs, Class<?> ptype) {\n+        boolean isPrimitive = ptype.isPrimitive();\n+        MethodHandle mh = identity(ptype);\n+        MethodType mt = mh.type();\n+\n+\/\/cannot cast to primitive types as it breaks null values formatting\n+\/\/        if (ptype == byte.class || ptype == short.class ||\n+\/\/            ptype == Byte.class || ptype == Short.class ||\n+\/\/            ptype == Integer.class) {\n+\/\/            mt = mt.changeReturnType(int.class);\n+\/\/        } else if (ptype == Long.class) {\n+\/\/            mt = mt.changeReturnType(long.class);\n+\/\/        } else if (ptype == float.class || ptype == Float.class ||\n+\/\/                   ptype == Double.class) {\n+\/\/            mt = mt.changeReturnType(double.class);\n+\/\/        } else if (ptype == Boolean.class) {\n+\/\/            mt = mt.changeReturnType(boolean.class);\n+\/\/        } else if (ptype == Character.class) {\n+\/\/            mt = mt.changeReturnType(char.class);\n+\/\/        }\n+\n+        Class<?> itype = mt.returnType();\n+\n+        if (itype != ptype) {\n+            mh = explicitCastArguments(mh, mt);\n+        }\n+\n+        boolean handled = false;\n+        int flags = fs.flags;\n+        int width = fs.width;\n+        int precision = fs.precision;\n+        Character conv = fs.dt ? 't' : fs.c;\n+\n+        switch (Character.toLowerCase(conv)) {\n+            case BOOLEAN -> {\n+                if (itype == boolean.class && precision == -1) {\n+                    if (flags == 0 && width == -1 && isPrimitive) {\n+                        return null;\n+                    }\n+\n+                    if (validFlags(flags, LEFT_JUSTIFY | UPPERCASE)) {\n+                        handled = true;\n+                        mh = filterReturnValue(mh, FIBoolean_MH);\n+                    }\n+                }\n+            }\n+            case STRING -> {\n+                if (flags == 0 && width == -1 && precision == -1) {\n+                    if (isPrimitive || ptype == String.class) {\n+                        return null;\n+                    } else if (itype.isPrimitive()) {\n+                        return mh;\n+                    }\n+                }\n+\n+                if (validFlags(flags, LEFT_JUSTIFY | UPPERCASE) && precision == -1) {\n+                    if (itype == String.class) {\n+                        handled = true;\n+                        mh = filterReturnValue(mh, FIString_MH);\n+                    } else if (!itype.isPrimitive()) {\n+                        handled = true;\n+                        MethodHandle test = FormattableCheck_MH;\n+                        test = test.asType(test.type().changeParameterType(0, ptype));\n+                        MethodHandle pass = insertArguments(FIFormattable_MH,\n+                                0, locale, flags, width, precision);\n+                        pass = pass.asType(pass.type().changeParameterType(0, ptype));\n+                        MethodHandle fail = ToString_MH;\n+                        fail = filterReturnValue(fail, FIString_MH);\n+                        fail = fail.asType(fail.type().changeParameterType(0, ptype));\n+                        mh = guardWithTest(test, pass, fail);\n+                    }\n+                }\n+            }\n+            case CHARACTER -> {\n+                if (itype == char.class && precision == -1) {\n+                    if (flags == 0 && width == -1) {\n+                        return isPrimitive ? null : mh;\n+                    }\n+\n+                    if (validFlags(flags, LEFT_JUSTIFY | UPPERCASE)) {\n+                        handled = true;\n+                        mh = filterReturnValue(mh, FICharacter_MH);\n+                    }\n+                }\n+            }\n+            case DECIMAL_INTEGER -> {\n+                if ((itype == int.class || itype == long.class) && precision == -1) {\n+                    if (itype == int.class) {\n+                        mh = explicitCastArguments(mh,\n+                                mh.type().changeReturnType(long.class));\n+                    }\n+\n+                    if (flags == 0 && isGenericDFS && width == -1) {\n+                        return mh;\n+                    } else if (validFlags(flags, PLUS | LEADING_SPACE |\n+                                                 ZERO_PAD | GROUP |\n+                                                 PARENTHESES)) {\n+                        handled = true;\n+                        int zeroPad = isFlag(flags, ZERO_PAD) ? width : -1;\n+                        char sign = isFlag(flags, PLUS)          ? '+' :\n+                                    isFlag(flags, LEADING_SPACE) ? ' ' : '\\0';\n+                        boolean parentheses = isFlag(flags, PARENTHESES);\n+                        int groupSize = isFlag(flags, GROUP) ?\n+                                groupSize(locale, dfs) : 0;\n+                        mh = filterReturnValue(mh,\n+                                insertArguments(FIDecimal_MH, 0, dfs, zeroPad,\n+                                        sign, parentheses, groupSize));\n+                    }\n+                }\n+            }\n+            case OCTAL_INTEGER -> {\n+                if ((itype == int.class || itype == long.class) &&\n+                         precision == -1 &&\n+                         validFlags(flags, ZERO_PAD | ALTERNATE)) {\n+                    handled = true;\n+\n+                    if (itype == int.class) {\n+                        mh = filterReturnValue(mh, ToLong_MH);\n+                    }\n+\n+                    int zeroPad = isFlag(flags, ZERO_PAD) ? width : -1;\n+                    boolean hasPrefix = isFlag(flags, ALTERNATE);\n+                    mh = filterReturnValue(mh,\n+                            insertArguments(FIOctal_MH, 0, zeroPad, hasPrefix));\n+                }\n+            }\n+            case HEXADECIMAL_INTEGER -> {\n+                if ((itype == int.class || itype == long.class) &&\n+                        precision == -1 &&\n+                        validFlags(flags, ZERO_PAD | ALTERNATE)) {\n+                    handled = true;\n+\n+                    if (itype == int.class) {\n+                        mh = filterReturnValue(mh, ToLong_MH);\n+                    }\n+\n+                    int zeroPad = isFlag(flags, ZERO_PAD) ? width : -1;\n+                    boolean hasPrefix = isFlag(flags, ALTERNATE);\n+                    mh = filterReturnValue(mh,\n+                            insertArguments(FIHexadecimal_MH, 0, zeroPad, hasPrefix));\n+                }\n+            }\n+        }\n+\n+        if (handled) {\n+            if (!isPrimitive) {\n+                MethodHandle test = NullCheck_MH.asType(\n+                        NullCheck_MH.type().changeParameterType(0, ptype));\n+                MethodHandle pass = dropArguments(FINull_MH, 0, ptype);\n+                mh = guardWithTest(test, pass, mh);\n+            }\n+\n+            if (0 < width) {\n+                if (isFlag(flags, LEFT_JUSTIFY)) {\n+                    mh = filterReturnValue(mh,\n+                            insertArguments(FIFillRight_MH, 0, width));\n+                } else {\n+                    mh = filterReturnValue(mh,\n+                            insertArguments(FIFillLeft_MH, 0, width));\n+                }\n+            }\n+\n+            if (isFlag(flags, UPPERCASE)) {\n+                mh = filterReturnValue(mh, FIUpper_MH);\n+            }\n+\n+            return mh;\n+        }\n+\n+        mh = insertArguments(FIFormatSpecifier_MH, 0, fs, locale);\n+        mh = mh.asType(mh.type().changeParameterType(0, ptype));\n+\n+        return mh;\n+    }\n+\n+    \/**\n+     * Construct concat {@link MethodHandle} for based on format.\n+     *\n+     * @param fsa  list of specifiers\n+     *\n+     * @return concat {@link MethodHandle} for based on format\n+     *\/\n+    private MethodHandle buildFilters(List<FormatString> fsa,\n+                                      List<String> segments,\n+                                      MethodHandle[] filters) {\n+        MethodHandle mh = null;\n+        int iParam = 0;\n+        StringBuilder segment = new StringBuilder();\n+\n+        for (FormatString fs : fsa) {\n+            int index = fs.index();\n+\n+            switch (index) {\n+                case -2:  \/\/ fixed string, \"%n\", or \"%%\"\n+                    String string = fs.toString();\n+\n+                    if (\"%%\".equals(string)) {\n+                        segment.append('%');\n+                    } else if (\"%n\".equals(string)) {\n+                        segment.append(System.lineSeparator());\n+                    } else {\n+                        segment.append(string);\n+                    }\n+                    break;\n+                case 0:  \/\/ ordinary index\n+                    segments.add(segment.toString());\n+                    segment.setLength(0);\n+\n+                    if (iParam < ptypes.length) {\n+                        Class<?> ptype = ptypes[iParam];\n+                        filters[iParam++] = formatSpecifier((FormatSpecifier)fs, ptype);\n+                    } else {\n+                        throw new MissingFormatArgumentException(fs.toString());\n+                    }\n+                    break;\n+                case -1:  \/\/ relative index\n+                default:  \/\/ explicit index\n+                    throw new MissingFormatArgumentException(fs.toString());\n+            }\n+        }\n+\n+        segments.add(segment.toString());\n+\n+        return mh;\n+    }\n+\n+    \/**\n+     * Build a {@link MethodHandle} to format arguments.\n+     *\n+     * @return new {@link MethodHandle} to format arguments\n+     *\/\n+    MethodHandle build() {\n+        Formatter.parse(format);\n+        List<String> segments = new ArrayList<>();\n+        MethodHandle[] filters = new MethodHandle[ptypes.length];\n+        buildFilters(Formatter.parse(format), segments, filters);\n+        Class<?>[] ftypes = new Class<?>[filters.length];\n+\n+        for (int i = 0; i < filters.length; i++) {\n+            MethodHandle filter = filters[i];\n+            ftypes[i] = filter == null ? ptypes[i] : filter.type().returnType();\n+        }\n+\n+        try {\n+            MethodHandle mh = StringConcatFactory.makeConcatWithTemplate(segments,\n+                    List.of(ftypes));\n+            mh = filterArguments(mh, 0, filters);\n+\n+            return mh;\n+        } catch (StringConcatException ex) {\n+            throw new AssertionError(\"concat fail\", ex);\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/util\/FormatterBuilder.java","additions":491,"deletions":0,"binary":false,"changes":491,"status":"added"},{"patch":"@@ -34,0 +34,1 @@\n+import java.lang.template.StringTemplate;\n@@ -47,0 +48,1 @@\n+import jdk.internal.javac.PreviewFeature;\n@@ -400,0 +402,18 @@\n+   \/**\n+    * Get the coder for the supplied character.\n+    *\/\n+   @PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n+   long stringConcatCoder(char value);\n+\n+   \/**\n+    * Update lengthCoder for StringBuilder.\n+    *\/\n+   @PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n+   long stringBuilderConcatMix(long lengthCoder, StringBuilder sb);\n+\n+    \/**\n+     * Prepend StringBuilder content.\n+     *\/\n+    @PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n+   long stringBuilderConcatPrepend(long lengthCoder, byte[] buf, StringBuilder sb);\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -75,0 +75,2 @@\n+        @JEP(number=430, title=\"String Templates\", status=\"First Preview\")\n+        STRING_TEMPLATES,\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/javac\/PreviewFeature.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,281 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.util;\n+\n+import jdk.internal.javac.PreviewFeature;\n+\n+import java.lang.invoke.MethodHandle;\n+\n+\/**\n+ * Digits provides a fast methodology for converting integers and longs to\n+ * ASCII strings.\n+ *\n+ * @since 19\n+ *\/\n+@PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n+public interface Digits {\n+    \/**\n+     * Insert digits for long value in buffer from high index to low index.\n+     *\n+     * @param value      value to convert\n+     * @param buffer     byte buffer to copy into\n+     * @param index      insert point + 1\n+     * @param putCharMH  method to put character\n+     *\n+     * @return the last index used\n+     *\n+     * @throws Throwable if putCharMH fails (unusual).\n+     *\/\n+    int digits(long value, byte[] buffer, int index,\n+               MethodHandle putCharMH) throws Throwable;\n+\n+    \/**\n+     * Calculate the number of digits required to represent the long.\n+     *\n+     * @param value value to convert\n+     *\n+     * @return number of digits\n+     *\/\n+    int size(long value);\n+\n+    \/**\n+     * Digits class for decimal digits.\n+     *\/\n+    public final class DecimalDigits implements Digits {\n+        private static final short[] DIGITS;\n+\n+        \/**\n+         * Singleton instance of DecimalDigits.\n+         *\/\n+        public static final Digits INSTANCE = new DecimalDigits();\n+\n+        static {\n+            short[] digits = new short[10 * 10];\n+\n+            for (int i = 0; i < 10; i++) {\n+                short hi = (short) ((i + '0') << 8);\n+\n+                for (int j = 0; j < 10; j++) {\n+                    short lo = (short) (j + '0');\n+                    digits[i * 10 + j] = (short) (hi | lo);\n+                }\n+            }\n+\n+            DIGITS = digits;\n+        }\n+\n+        \/**\n+         * Constructor.\n+         *\/\n+        private DecimalDigits() {\n+        }\n+\n+        @Override\n+        public int digits(long value, byte[] buffer, int index,\n+                          MethodHandle putCharMH) throws Throwable {\n+            boolean negative = value < 0;\n+            if (!negative) {\n+                value = -value;\n+            }\n+\n+            long q;\n+            int r;\n+            while (value <= Integer.MIN_VALUE) {\n+                q = value \/ 100;\n+                r = (int)((q * 100) - value);\n+                value = q;\n+                int digits = DIGITS[r];\n+\n+                putCharMH.invokeExact(buffer, --index, digits & 0xFF);\n+                putCharMH.invokeExact(buffer, --index, digits >> 8);\n+            }\n+\n+            int iq, ivalue = (int)value;\n+            while (ivalue <= -100) {\n+                iq = ivalue \/ 100;\n+                r = (iq * 100) - ivalue;\n+                ivalue = iq;\n+                int digits = DIGITS[r];\n+                putCharMH.invokeExact(buffer, --index, digits & 0xFF);\n+                putCharMH.invokeExact(buffer, --index, digits >> 8);\n+            }\n+\n+            if (ivalue < 0) {\n+                ivalue = -ivalue;\n+            }\n+\n+            int digits = DIGITS[ivalue];\n+            putCharMH.invokeExact(buffer, --index, digits & 0xFF);\n+\n+            if (9 < ivalue) {\n+                putCharMH.invokeExact(buffer, --index, digits >> 8);\n+            }\n+\n+            if (negative) {\n+                putCharMH.invokeExact(buffer, --index, (int)'-');\n+            }\n+\n+            return index;\n+        }\n+\n+        @Override\n+        public int size(long value) {\n+            boolean negative = value < 0;\n+            int sign = negative ? 1 : 0;\n+\n+            if (!negative) {\n+                value = -value;\n+            }\n+\n+            long precision = -10;\n+            for (int i = 1; i < 19; i++) {\n+                if (value > precision)\n+                    return i + sign;\n+\n+                precision = 10 * precision;\n+            }\n+\n+            return 19 + sign;\n+        }\n+    }\n+\n+    \/**\n+     * Digits class for hexadecimal digits.\n+     *\/\n+    public final class HexDigits implements Digits {\n+        private static final short[] DIGITS;\n+\n+        \/**\n+         * Singleton instance of HexDigits.\n+         *\/\n+        public static final Digits INSTANCE = new HexDigits();\n+\n+        static {\n+            short[] digits = new short[16 * 16];\n+\n+            for (int i = 0; i < 16; i++) {\n+                short hi = (short) ((i < 10 ? i + '0' : i - 10 + 'a') << 8);\n+\n+                for (int j = 0; j < 16; j++) {\n+                    short lo = (short) (j < 10 ? j + '0' : j - 10 + 'a');\n+                    digits[(i << 4) + j] = (short) (hi | lo);\n+                }\n+            }\n+\n+            DIGITS = digits;\n+        }\n+\n+        \/**\n+         * Constructor.\n+         *\/\n+        private HexDigits() {\n+        }\n+\n+        @Override\n+        public int digits(long value, byte[] buffer, int index,\n+                          MethodHandle putCharMH) throws Throwable {\n+            while ((value & ~0xFF) != 0) {\n+                int digits = DIGITS[(int) (value & 0xFF)];\n+                value >>>= 8;\n+                putCharMH.invokeExact(buffer, --index, digits & 0xFF);\n+                putCharMH.invokeExact(buffer, --index, digits >> 8);\n+            }\n+\n+            int digits = DIGITS[(int) (value & 0xFF)];\n+            putCharMH.invokeExact(buffer, --index, digits & 0xFF);\n+\n+            if (0xF < value) {\n+                putCharMH.invokeExact(buffer, --index, digits >> 8);\n+            }\n+\n+            return index;\n+        }\n+\n+        @Override\n+        public int size(long value) {\n+            return value == 0 ? 1 :\n+                    67 - Long.numberOfLeadingZeros(value) >> 2;\n+        }\n+    }\n+\n+    \/**\n+     * Digits class for octal digits.\n+     *\/\n+    public final class OctalDigits implements Digits {\n+        private static final short[] DIGITS;\n+\n+        \/**\n+         * Singleton instance of HexDigits.\n+         *\/\n+        public static final Digits INSTANCE = new OctalDigits();\n+\n+        static {\n+            short[] digits = new short[8 * 8];\n+\n+            for (int i = 0; i < 8; i++) {\n+                short hi = (short) ((i + '0') << 8);\n+\n+                for (int j = 0; j < 8; j++) {\n+                    short lo = (short) (j + '0');\n+                    digits[(i << 3) + j] = (short) (hi | lo);\n+                }\n+            }\n+\n+            DIGITS = digits;\n+        }\n+\n+        \/**\n+         * Constructor.\n+         *\/\n+        private OctalDigits() {\n+        }\n+\n+        @Override\n+        public int digits(long value, byte[] buffer, int index,\n+                          MethodHandle putCharMH) throws Throwable {\n+            while ((value & ~0x3F) != 0) {\n+                int digits = DIGITS[(int) (value & 0x3F)];\n+                value >>>= 6;\n+                putCharMH.invokeExact(buffer, --index, digits & 0xFF);\n+                putCharMH.invokeExact(buffer, --index, digits >> 8);\n+            }\n+\n+            int digits = DIGITS[(int) (value & 0x3F)];\n+            putCharMH.invokeExact(buffer, --index, digits & 0xFF);\n+\n+            if (7 < value) {\n+                putCharMH.invokeExact(buffer, --index, digits >> 8);\n+            }\n+\n+            return index;\n+        }\n+\n+        @Override\n+        public int size(long value) {\n+            return (66 - Long.numberOfLeadingZeros(value)) \/ 3;\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/Digits.java","additions":281,"deletions":0,"binary":false,"changes":281,"status":"added"},{"patch":"@@ -89,0 +89,1 @@\n+    exports java.lang.template;\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import java.util.Collections;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/ClassTree.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.source.tree;\n+\n+import java.util.List;\n+\n+import jdk.internal.javac.PreviewFeature;\n+\n+\/**\n+ * A tree node for a string template expression.\n+ *\n+ *\/\n+@PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES, reflective=true)\n+public interface StringTemplateTree extends ExpressionTree {\n+    \/**\n+     * Returns templated string processor (may be qualified) or null.\n+     *\n+     * @return templated string processor\n+     *\/\n+    ExpressionTree getProcessor();\n+\n+    \/**\n+     * Returns string fragments.\n+     *\n+     * @return string fragments\n+     *\/\n+    List<String> getFragments();\n+\n+    \/**\n+     * Returns list of expressions.\n+     *\n+     * @return list of expressions\n+     *\/\n+    List<? extends ExpressionTree> getExpressions();\n+}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/StringTemplateTree.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -178,0 +178,6 @@\n+        \/**\n+         * Used for instances of {@link StringTemplateTree}.\n+         *\/\n+        @PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES, reflective=true)\n+        TEMPLATE(StringTemplateTree.class),\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/Tree.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -262,0 +262,9 @@\n+    \/**\n+     * Visits a StringTemplateTree node.\n+     * @param node the node being visited\n+     * @param p a parameter value\n+     * @return a result value\n+     *\/\n+    @PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES, reflective=true)\n+    R visitStringTemplate(StringTemplateTree node, P p);\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/TreeVisitor.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -631,0 +631,13 @@\n+    \/**\n+     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     *\n+     * @param node {@inheritDoc}\n+     * @param p {@inheritDoc}\n+     * @return  the result of {@code defaultAction}\n+     *\/\n+    @Override\n+    @PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES, reflective=true)\n+    public R visitStringTemplate(StringTemplateTree node, P p) {\n+        return defaultAction(node, p);\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/util\/SimpleTreeVisitor.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -762,0 +762,17 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n+     *\n+     * @param node  {@inheritDoc}\n+     * @param p  {@inheritDoc}\n+     * @return the result of scanning\n+     *\/\n+    @Override\n+    @PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES, reflective=true)\n+    public R visitStringTemplate(StringTemplateTree node, P p) {\n+        R r = scan(node.getProcessor(), p);\n+        r = scanAndReduce(node.getExpressions(), p, r);\n+        return r;\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/util\/TreeScanner.java","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -214,0 +214,1 @@\n+            case STRING_TEMPLATES -> true;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Preview.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -231,0 +231,1 @@\n+        STRING_TEMPLATES(JDK20, Fragments.FeatureStringTemplates, DiagKind.PLURAL),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Source.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -177,0 +177,1 @@\n+    public final Type methodHandlesType;\n@@ -236,0 +237,6 @@\n+    \/\/ For string templates\n+    public final Type stringTemplateType;\n+    public final Type templateRuntimeType;\n+    public final Type templateProcessorType;\n+    public final Type processorLinkage;\n+\n@@ -544,0 +551,1 @@\n+        methodHandlesType = enterClass(\"java.lang.invoke.MethodHandles\");\n@@ -610,1 +618,0 @@\n-\n@@ -621,0 +628,6 @@\n+        \/\/ For string templates\n+        stringTemplateType = enterClass(\"java.lang.template.StringTemplate\");\n+        templateRuntimeType = enterClass(\"java.lang.template.TemplateRuntime\");\n+        templateProcessorType = enterClass(\"java.lang.template.ValidatingProcessor\");\n+        processorLinkage = enterClass(\"java.lang.template.ProcessorLinkage\");\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symtab.java","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -77,0 +77,1 @@\n+import com.sun.tools.javac.code.Types;\n@@ -105,0 +106,1 @@\n+    private final Types types;\n@@ -129,0 +131,1 @@\n+        types = Types.instance(context);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/ArgumentAttr.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -4968,0 +4968,21 @@\n+    public void visitStringTemplate(JCStringTemplate tree) {\n+        JCExpression processor = tree.processor;\n+        Type resultType = syms.stringTemplateType;\n+\n+        if (processor != null) {\n+            resultType = attribTree(processor, env, new ResultInfo(KindSelector.VAL, Type.noType));\n+            resultType = chk.checkProcessorType(processor, resultType, env);\n+        }\n+\n+        Env<AttrContext> localEnv = env.dup(tree, env.info.dup());\n+\n+        for (JCExpression arg : tree.expressions) {\n+            chk.checkNonVoid(arg.pos(), attribExpr(arg, localEnv));\n+        }\n+\n+        tree.type = resultType;\n+        result = resultType;\n+\n+        check(tree, resultType, KindSelector.VAL, resultInfo);\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -110,0 +110,2 @@\n+    public boolean disablePreviewCheck;\n+\n@@ -147,0 +149,2 @@\n+        disablePreviewCheck = false;\n+\n@@ -3610,1 +3614,1 @@\n-        if ((s.flags() & PREVIEW_API) != 0 && !preview.participatesInPreview(syms, other, s)) {\n+        if ((s.flags() & PREVIEW_API) != 0 && !preview.participatesInPreview(syms, other, s) && !disablePreviewCheck) {\n@@ -4128,0 +4132,21 @@\n+    public Type checkProcessorType(JCExpression processor, Type resultType, Env<AttrContext> env) {\n+        Type processorType = processor.type;\n+        Type interfaceType = types.asSuper(processorType, syms.templateProcessorType.tsym);\n+\n+        if (interfaceType != null) {\n+            List<Type> typeArguments = interfaceType.getTypeArguments();\n+\n+            if (typeArguments.size() == 2) {\n+                resultType = typeArguments.head;\n+            } else {\n+                log.error(DiagnosticFlag.RESOLVE_ERROR, processor.pos,\n+                        Errors.RawTemplateProcessorType(processorType.tsym));\n+            }\n+        } else {\n+            log.error(DiagnosticFlag.RESOLVE_ERROR, processor.pos,\n+                    Errors.NotTemplateProcessorType(processorType.tsym));\n+        }\n+\n+        return resultType;\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":26,"deletions":1,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -62,4 +62,5 @@\n-        TRANSPATTERNS(7),\n-        UNLAMBDA(8),\n-        LOWER(9),\n-        GENERATE(10);\n+        TRANSLITERALS(7),\n+        TRANSPATTERNS(8),\n+        UNLAMBDA(9),\n+        LOWER(10),\n+        GENERATE(11);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/CompileStates.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1508,0 +1508,24 @@\n+        @Override\n+        public void visitStringTemplate(JCStringTemplate tree) {\n+            JCExpression processor = tree.processor;\n+\n+            if (processor != null) {\n+                scan(processor);\n+                Type interfaceType = types.asSuper(processor.type, syms.templateProcessorType.tsym);\n+\n+                if (interfaceType != null) {\n+                    List<Type> typeArguments = interfaceType.getTypeArguments();\n+\n+                    if (typeArguments.size() == 2) {\n+                        Type throwType = typeArguments.tail.head;\n+\n+                        if (throwType != null) {\n+                            markThrown(tree, throwType);\n+                        }\n+                    }\n+                }\n+            }\n+\n+            scan(tree.expressions);\n+        }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Flow.java","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -34,0 +34,3 @@\n+import com.sun.tools.javac.code.Symbol.*;\n+import com.sun.tools.javac.code.Symbol.OperatorSymbol.AccessCode;\n+import com.sun.tools.javac.code.Type.*;\n@@ -37,0 +40,1 @@\n+import com.sun.tools.javac.resources.CompilerProperties.Errors;\n@@ -39,0 +43,1 @@\n+import com.sun.tools.javac.tree.JCTree.*;\n@@ -40,1 +45,0 @@\n-import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;\n@@ -42,9 +46,1 @@\n-\n-import com.sun.tools.javac.code.Symbol.*;\n-import com.sun.tools.javac.code.Symbol.OperatorSymbol.AccessCode;\n-import com.sun.tools.javac.resources.CompilerProperties.Errors;\n-import com.sun.tools.javac.tree.JCTree.*;\n-import com.sun.tools.javac.code.Type.*;\n-\n-import com.sun.tools.javac.jvm.Target;\n-import com.sun.tools.javac.tree.EndPosTable;\n+import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;\n@@ -54,0 +50,1 @@\n+import static com.sun.tools.javac.code.Kinds.Kind.*;\n@@ -56,1 +53,0 @@\n-import static com.sun.tools.javac.code.Kinds.Kind.*;\n@@ -58,4 +54,0 @@\n-import com.sun.tools.javac.tree.JCTree.JCBreak;\n-import com.sun.tools.javac.tree.JCTree.JCCase;\n-import com.sun.tools.javac.tree.JCTree.JCExpression;\n-import com.sun.tools.javac.tree.JCTree.JCExpressionStatement;\n@@ -63,1 +55,0 @@\n-import com.sun.tools.javac.tree.JCTree.JCSwitchExpression;\n@@ -2610,1 +2601,1 @@\n-     * @param tree                a class declaration tree\n+     * @param tree                an expression tree\n@@ -2622,1 +2613,1 @@\n-            JCClassDecl tree,\n+            JCTree tree,\n@@ -2634,1 +2625,2 @@\n-                isStatic ? List.nil() : indyType.argtypes.prepend(tree.sym.type),\n+                isStatic ? indyType.argtypes\n+                         : indyType.argtypes.prepend(TreeInfo.symbol(tree).type),\n@@ -2876,0 +2868,1 @@\n+\n@@ -3128,0 +3121,1 @@\n+\n@@ -4171,0 +4165,1 @@\n+\n@@ -4222,0 +4217,1 @@\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Lower.java","additions":15,"deletions":19,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2773,2 +2773,1 @@\n-        if (tree.name == names.init && ((tree.sym.flags_field & Flags.COMPACT_RECORD_CONSTRUCTOR) != 0 ||\n-                (tree.sym.flags_field & (GENERATEDCONSTR | RECORD)) == (GENERATEDCONSTR | RECORD))) {\n+        if (tree.name == names.init && (tree.sym.flags_field & Flags.COMPACT_RECORD_CONSTRUCTOR) != 0) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Lower.java.orig","additions":1,"deletions":2,"binary":false,"changes":3,"previous_filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Lower.java","status":"copied"},{"patch":"@@ -0,0 +1,639 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.tools.javac.comp;\n+\n+import com.sun.tools.javac.code.Flags;\n+import com.sun.tools.javac.code.Preview;\n+import com.sun.tools.javac.code.Scope.WriteableScope;\n+import com.sun.tools.javac.code.Symbol;\n+import com.sun.tools.javac.code.Symbol.ClassSymbol;\n+import com.sun.tools.javac.code.Symbol.Completer;\n+import com.sun.tools.javac.code.Symbol.DynamicMethodSymbol;\n+import com.sun.tools.javac.code.Symbol.MethodSymbol;\n+import com.sun.tools.javac.code.Symbol.VarSymbol;\n+import com.sun.tools.javac.code.Symtab;\n+import com.sun.tools.javac.code.Type;\n+import com.sun.tools.javac.code.Type.*;\n+import com.sun.tools.javac.code.Types;\n+import com.sun.tools.javac.jvm.PoolConstant.LoadableConstant;\n+import com.sun.tools.javac.jvm.Target;\n+import com.sun.tools.javac.tree.JCTree;\n+import com.sun.tools.javac.tree.JCTree.*;\n+import com.sun.tools.javac.tree.TreeInfo;\n+import com.sun.tools.javac.tree.TreeMaker;\n+import com.sun.tools.javac.tree.TreeTranslator;\n+import com.sun.tools.javac.util.Context;\n+import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;\n+import com.sun.tools.javac.util.JCDiagnostic.SimpleDiagnosticPosition;\n+import com.sun.tools.javac.util.List;\n+import com.sun.tools.javac.util.Name;\n+import com.sun.tools.javac.util.Names;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.stream.Collectors;\n+\n+import static com.sun.tools.javac.code.Flags.*;\n+import static com.sun.tools.javac.code.Scope.LookupKind.NON_RECURSIVE;\n+import static com.sun.tools.javac.tree.JCTree.Tag.*;\n+\n+\/** This pass translates constructed literals (string templates, ...) to conventional Java.\n+ *\n+ *  <p><b>This is NOT part of any supported API.\n+ *  If you write code that depends on this, you do so at your own risk.\n+ *  This code and its internal interfaces are subject to change or\n+ *  deletion without notice.<\/b>\n+ *\/\n+public final class TransLiterals extends TreeTranslator {\n+    \/**\n+     * The context key for the TransTypes phase.\n+     *\/\n+    protected static final Context.Key<TransLiterals> transLiteralsKey = new Context.Key<>();\n+    private final char SYNTHETIC_NAME_CHAR;\n+\n+    \/**\n+     * Get the instance for this context.\n+     *\/\n+    public static TransLiterals instance(Context context) {\n+        TransLiterals instance = context.get(transLiteralsKey);\n+        if (instance == null)\n+            instance = new TransLiterals(context);\n+        return instance;\n+    }\n+\n+    private final Symtab syms;\n+    private final Attr attr;\n+    private final Resolve rs;\n+    private final Types types;\n+    private final Check chk;\n+    private final Operators operators;\n+    private final Names names;\n+    private final Target target;\n+    private final Preview preview;\n+    private TreeMaker make = null;\n+    private Env<AttrContext> env = null;\n+    private ClassSymbol currentClass = null;\n+    private MethodSymbol currentMethodSym = null;\n+\n+    protected TransLiterals(Context context) {\n+        context.put(transLiteralsKey, this);\n+        syms = Symtab.instance(context);\n+        attr = Attr.instance(context);\n+        rs = Resolve.instance(context);\n+        make = TreeMaker.instance(context);\n+        types = Types.instance(context);\n+        chk = Check.instance(context);\n+        operators = Operators.instance(context);\n+        names = Names.instance(context);\n+        target = Target.instance(context);\n+        preview = Preview.instance(context);\n+\n+        SYNTHETIC_NAME_CHAR = target.syntheticNameChar();\n+    }\n+\n+    JCExpression makeLit(Type type, Object value) {\n+        return make.Literal(type.getTag(), value).setType(type.constType(value));\n+    }\n+\n+    JCExpression makeString(String string) {\n+        return makeLit(syms.stringType, string);\n+    }\n+\n+    List<JCExpression> makeStringList(List<String> strings) {\n+        List<JCExpression> exprs = List.nil();\n+        for (String string : strings) {\n+            exprs = exprs.append(makeString(string));\n+        }\n+        return exprs;\n+    }\n+\n+    Type makeListType(Type elemType) {\n+         return new ClassType(syms.listType.getEnclosingType(), List.of(elemType), syms.listType.tsym);\n+    }\n+\n+    JCBinary makeBinary(JCTree.Tag optag, JCExpression lhs, JCExpression rhs) {\n+        JCBinary tree = make.Binary(optag, lhs, rhs);\n+        tree.operator = operators.resolveBinary(tree, optag, lhs.type, rhs.type);\n+        tree.type = tree.operator.type.getReturnType();\n+        return tree;\n+    }\n+\n+    JCVariableDecl makeField(JCClassDecl cls, long flags, Name name, Type type, JCExpression init) {\n+        VarSymbol sym = new VarSymbol(flags | FINAL | SYNTHETIC, name, type, cls.sym);\n+        JCVariableDecl var = make.VarDef(sym, init);\n+        cls.defs = cls.defs.append(var);\n+        cls.sym.members().enter(var.sym);\n+\n+        return var;\n+    }\n+\n+    MethodType makeMethodType(Type returnType, List<Type> argTypes) {\n+        return new MethodType(argTypes, returnType, List.nil(), syms.methodClass);\n+    }\n+\n+    JCFieldAccess makeThisFieldSelect(Type owner, JCVariableDecl field) {\n+        JCFieldAccess select = make.Select(make.This(owner), field.name);\n+        select.type = field.type;\n+        select.sym = field.sym;\n+        return select;\n+    }\n+\n+    JCIdent makeParamIdent(List<JCVariableDecl> params, Name name) {\n+        VarSymbol param = params.stream()\n+                .filter(p -> p.name == name)\n+                .findFirst()\n+                .get().sym;\n+        JCIdent ident = make.Ident(name);\n+        ident.type = param.type;\n+        ident.sym = param;\n+        return ident;\n+    }\n+\n+    JCFieldAccess makeSelect(Symbol sym, Name name) {\n+        return make.Select(make.QualIdent(sym), name);\n+    }\n+\n+    JCMethodInvocation makeApply(JCFieldAccess method, List<JCExpression> args) {\n+        return make.Apply(List.nil(), method, args);\n+    }\n+\n+    Symbol findMember(ClassSymbol classSym, Name name) {\n+        return classSym.members().getSymbolsByName(name, NON_RECURSIVE).iterator().next();\n+    }\n+\n+    JCFieldAccess makeFieldAccess(JCClassDecl owner, Name name) {\n+        Symbol sym = findMember(owner.sym, name);\n+        JCFieldAccess access = makeSelect(owner.sym, name);\n+        access.type = sym.type;\n+        access.sym = sym;\n+        return access;\n+    }\n+\n+    MethodSymbol lookupMethod(DiagnosticPosition pos, Name name, Type qual, List<Type> args) {\n+        return rs.resolveInternalMethod(pos, env, qual, name, args, List.nil());\n+    }\n+\n+    @Override\n+    public void visitClassDef(JCClassDecl tree) {\n+        ClassSymbol prevCurrentClass = currentClass;\n+        try {\n+            currentClass = tree.sym;\n+            super.visitClassDef(tree);\n+        } finally {\n+            currentClass = prevCurrentClass;\n+        }\n+    }\n+\n+    @Override\n+    public void visitMethodDef(JCMethodDecl tree) {\n+        MethodSymbol prevMethodSym = currentMethodSym;\n+        try {\n+            currentMethodSym = tree.sym;\n+            super.visitMethodDef(tree);\n+        } finally {\n+            currentMethodSym = prevMethodSym;\n+        }\n+    }\n+\n+    record MethodInfo(MethodType type, MethodSymbol sym, JCMethodDecl decl) {\n+        void addStatement(JCStatement statement) {\n+            JCBlock body = decl.body;\n+            body.stats = body.stats.append(statement);\n+        }\n+    }\n+\n+    class TransStringTemplate {\n+        JCStringTemplate tree;\n+        JCExpression processor;\n+        List<String> fragments;\n+        List<JCExpression> expressions;\n+        List<Type> expressionTypes;\n+        boolean useValuesList;\n+        JCClassDecl stringTemplateClass;\n+        JCVariableDecl fragmentsVar;\n+        JCVariableDecl valuesVar;\n+        List<JCVariableDecl> fields;\n+        MethodInfo interpolateMethod;\n+\n+        TransStringTemplate(JCStringTemplate tree) {\n+            this.tree = tree;\n+            this.processor = tree.processor;\n+            this.fragments = tree.fragments;\n+            this.expressions = translate(tree.expressions);\n+            this.expressionTypes = expressions.stream()\n+                    .map(arg -> arg.type == syms.botType ? syms.objectType : arg.type)\n+                    .collect(List.collector());\n+            int slots = expressionTypes.stream()\n+                    .mapToInt(t -> types.isSameType(t, syms.longType) ||\n+                            types.isSameType(t, syms.doubleType) ? 2 : 1).sum();\n+            this.useValuesList = 200 < slots; \/\/ StringConcatFactory.MAX_INDY_CONCAT_ARG_SLOTS\n+            this.stringTemplateClass = null;\n+            this.fragmentsVar = null;\n+            this.valuesVar = null;\n+            this.fields = List.nil();\n+            this.interpolateMethod = null;\n+        }\n+\n+        JCExpression concatExpression(List<String> fragments, List<JCExpression> expressions) {\n+            JCExpression expr = null;\n+            Iterator<JCExpression> iterator = expressions.iterator();\n+            for (String fragment : fragments) {\n+                expr = expr == null ? makeString(fragment)\n+                        : makeBinary(PLUS, expr, makeString(fragment));\n+                if (iterator.hasNext()) {\n+                    JCExpression expression = iterator.next();\n+                    Type expressionType = expression.type;\n+                    expr = makeBinary(PLUS, expr, expression.setType(expressionType));\n+                }\n+            }\n+            return expr;\n+        }\n+\n+        JCMethodInvocation createApply(Type owner, Name name, List<JCExpression> args, JCFieldAccess method) {\n+            List<Type> argTypes = TreeInfo.types(args);\n+            MethodSymbol methodSym = lookupMethod(tree.pos(), name, owner, argTypes);\n+            method.sym = methodSym;\n+            method.type = types.erasure(methodSym.type);\n+            JCMethodInvocation process = makeApply(method, args);\n+            process.type = methodSym.getReturnType();\n+            return process;\n+        }\n+\n+        JCMethodInvocation createApply(Type owner, Name name, List<JCExpression> args) {\n+            JCFieldAccess method = makeSelect(owner.tsym, name);\n+            return createApply(owner, name, args, method);\n+        }\n+\n+        JCMethodInvocation createApply(Symbol receiver, Name name, List<JCExpression> args) {\n+            Type owner = receiver.type;\n+            JCFieldAccess method = makeSelect(receiver, name);\n+            return createApply(owner, name, args, method);\n+        }\n+\n+        JCMethodInvocation createApplyToList(List<JCExpression> list, Type argType) {\n+            Type listType = makeListType(argType == null ? syms.objectType : argType);\n+            JCMethodInvocation toListApplied = createApply(syms.templateRuntimeType, names.toList, list)\n+                    .setType(listType);\n+            toListApplied.varargsElement = argType;\n+            return toListApplied;\n+        }\n+\n+        JCMethodInvocation createApplyExprMethod(JCMethodDecl exprMethod) {\n+            return createApply(stringTemplateClass.sym, exprMethod.name, List.nil());\n+        }\n+\n+        MethodInfo createMethod(long flags, Name name, Type returnType, List<Type> argTypes, JCClassDecl owner) {\n+            MethodType type = makeMethodType(returnType, argTypes);\n+            MethodSymbol sym = new MethodSymbol(flags, name, type, owner.sym);\n+            JCMethodDecl decl = make.MethodDef(sym, type, make.Block(0, List.nil()));\n+            owner.defs = owner.defs.append(decl);\n+            owner.sym.members().enter(sym);\n+            return new MethodInfo(type, sym, decl);\n+        }\n+\n+        void createFields() {\n+            int i = 0;\n+            for (JCExpression expression : expressions) {\n+\n+\n+                Type type = expression.type == syms.botType ? syms.objectType : expression.type;\n+                JCVariableDecl fieldVar = makeField(stringTemplateClass, PRIVATE, make.paramName(i++),\n+                        type, null);\n+                fields = fields.append(fieldVar);\n+            }\n+        }\n+\n+        void createFragmentsListAndMethod() {\n+            List<JCExpression> fragmentArgs = makeStringList(fragments);\n+            Type stringListType = makeListType(syms.stringType);\n+            fragmentsVar = makeField(stringTemplateClass, PRIVATE | STATIC,\n+                    names.fragmentsUpper, stringListType,\n+                    createApplyToList(fragmentArgs, syms.stringType));\n+            TransLiterals.MethodInfo method = createMethod(SYNTHETIC | PUBLIC, names.fragments,\n+                    stringListType, List.nil(), stringTemplateClass);\n+            method.addStatement(make.Return(make.QualIdent(fragmentsVar.sym)));\n+        }\n+\n+        void createValuesListAndMethod() {\n+            Type listType = makeListType(syms.objectType);\n+            valuesVar = makeField(stringTemplateClass, SYNTHETIC | PRIVATE, names.valuesUpper,\n+                    listType, null);\n+            MethodInfo method = createMethod(SYNTHETIC | PUBLIC, names.values,\n+                    listType, List.nil(), stringTemplateClass);\n+            JCExpression returnValues = make.QualIdent(valuesVar.sym);\n+            returnValues.type = listType;\n+            method.addStatement(make.Return(returnValues));\n+        }\n+\n+        List<JCExpression> createAccessors() {\n+            return fields.stream()\n+                    .map(f -> make.QualIdent(f.sym))\n+                    .collect(List.collector());\n+        }\n+\n+        void createInitMethod() {\n+            long flags = useValuesList ? PUBLIC | VARARGS\n+                                       : PUBLIC;\n+            List<Type> types = useValuesList ?\n+                    List.of(new ArrayType(syms.objectType, syms.arrayClass)) : expressionTypes;\n+            MethodInfo method = createMethod(flags, names.init,\n+                    syms.voidType, types, stringTemplateClass);\n+            JCIdent superIdent = make.Ident(names._super);\n+            superIdent.sym = lookupMethod(tree.pos(), names.init, syms.objectType, List.nil());\n+            superIdent.type = superIdent.sym.type;\n+            JCMethodInvocation superApply = make.Apply(List.nil(), translate(superIdent), List.nil());\n+            superApply.type = syms.voidType;\n+            method.addStatement(make.Exec(superApply));\n+            List<JCVariableDecl> params = method.decl.params;\n+\n+            if (useValuesList) {\n+                JCFieldAccess select = makeThisFieldSelect(stringTemplateClass.type, valuesVar);\n+                JCIdent ident = makeParamIdent(params, params.head.name);\n+                JCAssign assign = make.Assign(select, createApplyToList(List.of(ident), null));\n+                assign.type = ident.type;\n+                method.addStatement(make.Exec(assign));\n+            } else {\n+                for (JCVariableDecl field : fields) {\n+                    JCFieldAccess select = makeThisFieldSelect(stringTemplateClass.type, field);\n+                    JCIdent ident = makeParamIdent(params, field.name);\n+                    JCAssign assign = make.Assign(select, ident);\n+                    assign.type = ident.type;\n+                    method.addStatement(make.Exec(assign));\n+                }\n+            }\n+        }\n+\n+        void createValuesMethod() {\n+            Type objectListType = makeListType(syms.objectType);\n+            MethodInfo method = createMethod(SYNTHETIC | PUBLIC, names.values,\n+                    objectListType, List.nil(), stringTemplateClass);\n+            method.addStatement(make.Return(createApplyToList(createAccessors(), syms.objectType)));\n+        }\n+\n+        void createInterpolateMethod() {\n+            interpolateMethod = createMethod(SYNTHETIC | PUBLIC, names.interpolate,\n+                    syms.stringType, List.nil(), stringTemplateClass);\n+            interpolateMethod.addStatement(make.Return(concatExpression(fragments, createAccessors())));\n+        }\n+\n+        void createToStringMethod() {\n+            MethodInfo toStringMethod = createMethod(PUBLIC, names.toString,\n+                    syms.stringType, List.nil(), stringTemplateClass);\n+            JCExpression applytoString = this.createApply(syms.stringTemplateType, names.toString,\n+                    List.of(make.This(stringTemplateClass.type)));\n+            toStringMethod.addStatement(make.Return(applytoString));\n+        }\n+\n+        void createHashCodeMethod() {\n+            MethodInfo toHashCodeMethod = createMethod(PUBLIC, names.hashCode,\n+                    syms.intType, List.nil(), stringTemplateClass);\n+            JCExpression applyHashCode = this.createApply(syms.stringTemplateType, names.hashCode,\n+                    List.of(make.This(stringTemplateClass.type)));\n+            toHashCodeMethod.addStatement(make.Return(applyHashCode));\n+        }\n+\n+        void createEqualsMethod() {\n+            MethodInfo toEqualsMethod = createMethod(PUBLIC, names.equals,\n+                    syms.booleanType, List.of(syms.objectType), stringTemplateClass);\n+            List<JCVariableDecl> params = toEqualsMethod.decl.params;\n+            JCIdent ident = makeParamIdent(params, params.head.name);\n+            JCExpression applyEquals = this.createApply(syms.stringTemplateType, names.equals,\n+                    List.of(make.TypeCast(syms.objectType, make.This(stringTemplateClass.type)), ident));\n+            toEqualsMethod.addStatement(make.Return(applyEquals));\n+        }\n+\n+        private JCClassDecl newStringTemplateClass() {\n+            long flags = PUBLIC | FINAL | SYNTHETIC;\n+\n+            if (currentMethodSym.isStatic()) {\n+                flags |= NOOUTERTHIS;\n+            }\n+\n+            Name name = chk.localClassName(syms.defineClass(names.empty, currentClass));\n+            JCClassDecl cDecl =  make.ClassDef(make.Modifiers(flags), name, List.nil(), null, List.nil(), List.nil());\n+            ClassSymbol cSym = syms.defineClass(name, currentMethodSym);\n+            cSym.sourcefile = currentClass.sourcefile;\n+            cSym.completer = Completer.NULL_COMPLETER;\n+            cSym.members_field = WriteableScope.create(cSym);\n+            cSym.flags_field = flags;\n+            ClassType cType = (ClassType)cSym.type;\n+            cType.supertype_field = syms.objectType;\n+            cType.interfaces_field = List.of(syms.stringTemplateType);\n+            cType.all_interfaces_field = List.of(syms.stringTemplateType);\n+            cType.setEnclosingType(currentClass.type);\n+            cDecl.sym = cSym;\n+            cDecl.type = cType;\n+            cSym.complete();\n+\n+            return cDecl;\n+        }\n+\n+        void createStringTemplateClass() {\n+            ClassSymbol saveCurrentClass = currentClass;\n+\n+            try {\n+                Type stringTemplateType = syms.stringTemplateType;\n+                stringTemplateClass = newStringTemplateClass();\n+                currentClass = stringTemplateClass.sym;\n+                createFragmentsListAndMethod();\n+                createToStringMethod();\n+                createHashCodeMethod();\n+                createEqualsMethod();\n+\n+                if (useValuesList) {\n+                    createValuesListAndMethod();\n+                } else {\n+                    createFields();\n+                    createValuesMethod();\n+                    createInterpolateMethod();\n+                }\n+\n+                createInitMethod();\n+                saveCurrentClass.members().enter(stringTemplateClass.sym);\n+            } finally {\n+                currentClass = saveCurrentClass;\n+            }\n+        }\n+\n+        JCExpression createBSMProcessorPerformMethodCall() {\n+            List<JCExpression> args = expressions.prepend(processor);\n+            List<Type> argTypes = expressionTypes.prepend(processor.type);\n+            Name bootstrapName = names.stringTemplateBSM;\n+            Name methodName = names.process;\n+            VarSymbol processorSym = (VarSymbol)TreeInfo.symbol(processor);\n+            List<LoadableConstant> staticArgValues = List.of(processorSym.asMethodHandle(true));\n+            List<Type> staticArgsTypes =\n+                    List.of(syms.methodHandleLookupType, syms.stringType,\n+                            syms.methodTypeType, syms.methodHandleType);\n+            for (String fragment : fragments) {\n+                staticArgValues = staticArgValues.append(LoadableConstant.String(fragment));\n+                staticArgsTypes = staticArgsTypes.append(syms.stringType);\n+            }\n+            Symbol bsm = rs.resolveQualifiedMethod(tree.pos(), env,\n+                    syms.templateRuntimeType, bootstrapName, staticArgsTypes, List.nil());\n+            MethodType indyType = new MethodType(argTypes, tree.type, List.nil(), syms.methodClass);\n+            DynamicMethodSymbol dynSym = new DynamicMethodSymbol(\n+                    methodName,\n+                    syms.noSymbol,\n+                    ((MethodSymbol)bsm).asHandle(),\n+                    indyType,\n+                    staticArgValues.toArray(new LoadableConstant[0])\n+            );\n+            JCFieldAccess qualifier = make.Select(make.Type(syms.templateProcessorType), dynSym.name);\n+            qualifier.sym = dynSym;\n+            qualifier.type = tree.type;\n+            JCExpression process = make.Apply(List.nil(), qualifier, args);\n+            process.type = tree.type;\n+            return process;\n+        }\n+\n+        JCExpression createProcessorPerformMethodCall(JCExpression stringTemplate) {\n+            MethodSymbol appyMeth = lookupMethod(tree.pos(), names.process,\n+                    syms.templateProcessorType, List.of(syms.stringTemplateType));\n+            JCExpression applySelect = make.Select(processor, appyMeth);\n+            JCExpression process = make.Apply(null, applySelect, List.of(stringTemplate))\n+                    .setType(syms.objectType);\n+            JCTypeCast cast = make.TypeCast(tree.type, process);\n+            return cast;\n+        }\n+\n+        JCExpression newStringTemplate() {\n+            createStringTemplateClass();\n+            List<JCExpression> args = expressions;\n+            List<Type> argTypes = expressionTypes;\n+            JCExpression encl = currentMethodSym.isStatic() ? null :\n+                    make.This(currentMethodSym.owner.type);\n+            JCNewClass newClass = make.NewClass(encl,\n+                    null, make.QualIdent(stringTemplateClass.type.tsym), args, stringTemplateClass);\n+            newClass.constructor = rs.resolveConstructor(\n+                    new SimpleDiagnosticPosition(make.pos), env, stringTemplateClass.type, argTypes, List.nil());\n+            newClass.type = stringTemplateClass.type;\n+            newClass.varargsElement = useValuesList ? syms.objectType : null;\n+\n+            return newClass;\n+        }\n+\n+        boolean isProcessor(Name name) {\n+            if (processor instanceof JCIdent ident && ident.sym instanceof VarSymbol varSym) {\n+                if (varSym.flags() == (PUBLIC | FINAL | STATIC) &&\n+                        varSym.name == name &&\n+                        types.isSameType(varSym.owner.type, syms.stringTemplateType)) {\n+                    return true;\n+                }\n+            }\n+            return false;\n+        }\n+\n+        boolean isSTRProcessor() {\n+            if (processor instanceof JCIdent ident && ident.sym instanceof VarSymbol varSym) {\n+                if (varSym.flags() == (PUBLIC | FINAL | STATIC) &&\n+                        varSym.name == names.str &&\n+                        types.isSameType(varSym.owner.type, syms.stringTemplateType)) {\n+                    return true;\n+                }\n+            }\n+            return false;\n+        }\n+\n+        boolean isLinkageProcessor() {\n+            return processor != null &&\n+                   !useValuesList &&\n+                   types.isSubtype(processor.type, syms.processorLinkage) &&\n+                   processor.type.isFinal() &&\n+                   TreeInfo.symbol(processor) instanceof VarSymbol varSymbol &&\n+                   varSymbol.isStatic() &&\n+                   varSymbol.isFinal();\n+        }\n+\n+        JCExpression visit() {\n+            JCExpression result;\n+            make.at(tree.pos);\n+\n+            if (processor == null) {\n+                result = newStringTemplate();\n+            } else if (isSTRProcessor()) {\n+                result = concatExpression(fragments, expressions);\n+            } else if (isLinkageProcessor()) {\n+                result = createBSMProcessorPerformMethodCall();\n+            } else {\n+                result = createProcessorPerformMethodCall(newStringTemplate());\n+            }\n+\n+            return result;\n+        }\n+    }\n+\n+    public void visitStringTemplate(JCStringTemplate tree) {\n+        int prevPos = make.pos;\n+        try {\n+            tree.processor = translate(tree.processor);\n+            tree.expressions = translate(tree.expressions);\n+\n+            TransStringTemplate transStringTemplate = new TransStringTemplate(tree);\n+\n+            result = transStringTemplate.visit();\n+        } catch (Throwable ex) {\n+            ex.printStackTrace();\n+            throw ex;\n+        } finally {\n+            make.at(prevPos);\n+        }\n+    }\n+\n+    public void visitVarDef(JCVariableDecl tree) {\n+        MethodSymbol prevMethodSym = currentMethodSym;\n+        try {\n+            tree.mods = translate(tree.mods);\n+            tree.vartype = translate(tree.vartype);\n+            if (currentMethodSym == null) {\n+                \/\/ A class or instance field initializer.\n+                currentMethodSym =\n+                        new MethodSymbol((tree.mods.flags& Flags.STATIC) | Flags.BLOCK,\n+                                names.empty, null,\n+                                currentClass);\n+            }\n+            if (tree.init != null) tree.init = translate(tree.init);\n+            result = tree;\n+        } finally {\n+            currentMethodSym = prevMethodSym;\n+        }\n+    }\n+\n+    public JCTree translateTopLevelClass(Env<AttrContext> env, JCTree cdef, TreeMaker make) {\n+        try {\n+            this.make = make;\n+            this.env = env;\n+            translate(cdef);\n+        } finally {\n+            this.make = null;\n+            this.env = null;\n+        }\n+\n+        return cdef;\n+    }\n+\n+}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TransLiterals.java","additions":639,"deletions":0,"binary":false,"changes":639,"status":"added"},{"patch":"@@ -839,0 +839,7 @@\n+\n+    public void visitStringTemplate(JCStringTemplate tree) {\n+        tree.expressions = tree.expressions.stream()\n+                .map(e -> translate(e, erasure(e.type))).collect(List.collector());\n+        tree.type = erasure(tree.type);\n+        result = tree;\n+    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TransTypes.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import java.util.ArrayList;\n@@ -32,1 +31,0 @@\n-import java.util.stream.Collectors;\n@@ -39,0 +37,1 @@\n+import com.sun.tools.javac.code.Scope.ImportScope;\n@@ -44,0 +43,2 @@\n+import com.sun.tools.javac.parser.Parser;\n+import com.sun.tools.javac.parser.ParserFactory;\n@@ -116,0 +117,1 @@\n+    private final ParserFactory parserFactory;\n@@ -143,0 +145,1 @@\n+        parserFactory = ParserFactory.instance(context);\n@@ -328,0 +331,33 @@\n+        private void importJavaLang(JCCompilationUnit tree, Env<AttrContext> env, ImportFilter typeImportFilter) {\n+            \/\/ Import-on-demand java.lang.\n+            PackageSymbol javaLang = syms.enterPackage(syms.java_base, names.java_lang);\n+            if (javaLang.members().isEmpty() && !javaLang.exists()) {\n+                log.error(Errors.NoJavaLang);\n+                throw new Abort();\n+            }\n+            importAll(make.at(tree.pos()).Import(make.QualIdent(javaLang), false), javaLang, env); \/\/ alternative\n+        }\n+\n+        private void staticImports(JCCompilationUnit tree, Env<AttrContext> env, ImportFilter staticImportFilter) {\n+             if (preview.isEnabled() && preview.isPreview(Feature.STRING_TEMPLATES)) {\n+                Lint prevLint = chk.setLint(lint.suppress(LintCategory.DEPRECATION, LintCategory.REMOVAL, LintCategory.PREVIEW));\n+                boolean prevPreviewCheck = chk.disablePreviewCheck;\n+\n+                try {\n+                    chk.disablePreviewCheck = true;\n+                    String autoImports = \"\"\"\n+                            import static java.lang.template.StringTemplate.STR;\n+                            \"\"\";\n+                    Parser parser = parserFactory.newParser(autoImports, false, false, false, false);\n+                    JCCompilationUnit importTree = parser.parseCompilationUnit();\n+\n+                    for (JCImport imp : importTree.getImports()) {\n+                        doImport(imp);\n+                    }\n+                } finally {\n+                    chk.setLint(prevLint);\n+                    chk.disablePreviewCheck = prevPreviewCheck;\n+                }\n+            }\n+        }\n+\n@@ -350,7 +386,2 @@\n-                \/\/ Import-on-demand java.lang.\n-                PackageSymbol javaLang = syms.enterPackage(syms.java_base, names.java_lang);\n-                if (javaLang.members().isEmpty() && !javaLang.exists()) {\n-                    log.error(Errors.NoJavaLang);\n-                    throw new Abort();\n-                }\n-                importAll(make.at(tree.pos()).Import(make.QualIdent(javaLang), false), javaLang, env);\n+                importJavaLang(tree, env, typeImportFilter);\n+                staticImports(tree, env, staticImportFilter);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TypeEnter.java","additions":40,"deletions":9,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -1551,0 +1551,6 @@\n+            if (shouldStop(CompileState.TRANSLITERALS))\n+                return;\n+\n+            env.tree = TransLiterals.instance(context).translateTopLevelClass(env, env.tree, localMake);\n+            compileStates.put(env, CompileState.TRANSLITERALS);\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/main\/JavaCompiler.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,0 +41,1 @@\n+import java.util.Iterator;\n@@ -42,1 +43,0 @@\n-import java.util.regex.Pattern;\n@@ -65,1 +65,1 @@\n-    private int NOT_FOUND = -1;\n+    private final static int NOT_FOUND = -1;\n@@ -70,1 +70,1 @@\n-    private Source source;\n+    private final Source source;\n@@ -75,1 +75,1 @@\n-    private Preview preview;\n+    private final Preview preview;\n@@ -92,0 +92,20 @@\n+    \/**\n+     * Origin scanner factory.\n+     *\/\n+    protected final ScannerFactory fac;\n+\n+    \/**\n+     * Buffer for building literals, used by nextToken().\n+     *\/\n+    protected final StringBuilder sb;\n+\n+    \/**\n+     * Tokens pending to be read from string template embedded expressions.\n+     *\/\n+    protected List<Token> pendingTokens;\n+\n+    \/**\n+     * String template fragment ranges; end-endPos pairs.\n+     *\/\n+    protected List<Integer> fragmentRanges;\n+\n@@ -123,6 +143,1 @@\n-     * Buffer for building literals, used by nextToken().\n-     *\/\n-    protected StringBuilder sb;\n-\n-    \/**\n-     * Origin scanner factory.\n+     * true if contains templated string escape sequences, set by nextToken().\n@@ -130,1 +145,1 @@\n-    protected ScannerFactory fac;\n+    protected boolean isStringTemplate;\n@@ -137,1 +152,1 @@\n-    protected Lint lint;\n+    protected final Lint lint;\n@@ -152,3 +167,3 @@\n-     * @param fac     the factory which created this Scanner\n-     * @param array   the input character array.\n-     * @param length  The length of the meaningful content in the array.\n+     * @param fac      factory which created this Scanner\n+     * @param array    input character array\n+     * @param length   length of the meaningful content in the array\n@@ -166,0 +181,2 @@\n+        this.pendingTokens = List.nil();\n+        this.fragmentRanges = List.nil();\n@@ -329,0 +346,65 @@\n+    \/**\n+     * Scan the content of a string template expression.\n+     *\n+     * @param pos     start of literal\n+     * @param endPos  start of embedded expression\n+     *\/\n+    private void scanEmbeddedExpression(int pos, int endPos) {\n+        \/\/ If first embedded expression.\n+        if (!isStringTemplate) {\n+            checkSourceLevel(pos, Feature.STRING_TEMPLATES);\n+            fragmentRanges = fragmentRanges.append(pos);\n+            isStringTemplate = true;\n+        }\n+        \/\/ Track end of previous fragment.\n+        fragmentRanges = fragmentRanges.append(endPos);\n+        \/\/ Keep backslash and add rest of placeholder.\n+        sb.append(\"{}\");\n+\n+        \/\/ Separate tokenizer for the embedded expression.\n+        JavaTokenizer tokenizer = new JavaTokenizer(fac, buffer(), length());\n+        tokenizer.reset(position());\n+\n+        \/\/ Track brace depth.\n+        int braceCount = 0;\n+\n+        \/\/ Accumulate tokens.\n+        List<Token> tokens = List.nil();\n+\n+        \/\/ Stash first left brace.\n+        Token token = tokenizer.readToken();\n+        tokens = tokens.append(token);\n+\n+        while (isAvailable()) {\n+            \/\/ Read and stash next token.\n+            token = tokenizer.readToken();\n+            tokens = tokens.append(token);\n+\n+            if (token.kind == TokenKind.RBRACE) {\n+                \/\/ Potential closing brace.\n+                if (braceCount == 0) {\n+                    break;\n+                }\n+\n+                braceCount--;\n+            } else if (token.kind == TokenKind.LBRACE) {\n+                \/\/ Nesting deeper.\n+                braceCount++;\n+            } else if (token.kind == TokenKind.STRINGFRAGMENT) {\n+                tokens = tokens.appendList(tokenizer.pendingTokens);\n+                tokenizer.pendingTokens = List.nil();\n+            }\n+        }\n+\n+        \/\/ If no closing brace will be picked up as an unterminated string.\n+\n+        \/\/ Set main tokenizer to continue at next position.\n+        reset(tokenizer.position());\n+\n+        \/\/ Track start of next fragment.\n+        fragmentRanges = fragmentRanges.append(position());\n+\n+        \/\/ Pend the expression tokens after the STRINGFRAGMENT.\n+        pendingTokens = pendingTokens.appendList(tokens);\n+    }\n+\n@@ -331,2 +413,3 @@\n-     * character is a backslash then the next character is validated as a proper\n-     * escape character. Conversion of escape sequences takes place at end of nextToken().\n+     * character is a backslash then the next character is assumed to be a proper\n+     * escape character. Actual conversion of escape sequences takes place\n+     * during at the end of readToken.\n@@ -334,1 +417,1 @@\n-     * @param pos position of the first character in literal.\n+     * @param pos          position of the first character in literal.\n@@ -337,0 +420,1 @@\n+        int backslash = position();\n@@ -339,1 +423,0 @@\n-\n@@ -341,2 +424,8 @@\n-                case '0': case '1': case '2': case '3':\n-                case '4': case '5': case '6': case '7':\n+                case '0':\n+                case '1':\n+                case '2':\n+                case '3':\n+                case '4':\n+                case '5':\n+                case '6':\n+                case '7':\n@@ -382,0 +471,4 @@\n+                case '{':\n+                    scanEmbeddedExpression(pos, backslash);\n+                    break;\n+\n@@ -397,2 +490,0 @@\n-        \/\/ Assume the best.\n-        tk = Tokens.TokenKind.STRINGLITERAL;\n@@ -401,0 +492,2 @@\n+        tk = TokenKind.STRINGLITERAL;\n+\n@@ -422,0 +515,4 @@\n+                    if (isStringTemplate && tk == TokenKind.STRINGLITERAL) {\n+                        tk = TokenKind.STRINGFRAGMENT;\n+                    }\n+\n@@ -446,0 +543,3 @@\n+                    if (isStringTemplate && tk == TokenKind.STRINGLITERAL) {\n+                        tk = TokenKind.STRINGFRAGMENT;\n+                    }\n@@ -461,1 +561,7 @@\n-        lexError(pos, isTextBlock ? Errors.UnclosedTextBlock : Errors.UnclosedStrLit);\n+        if (isStringTemplate) {\n+            lexError(pos, isTextBlock ? Errors.UnclosedTextBlockTemplate\n+                                      : Errors.UnclosedStringTemplate);\n+        } else {\n+            lexError(pos, isTextBlock ? Errors.UnclosedTextBlock\n+                                      : Errors.UnclosedStrLit);\n+        }\n@@ -784,0 +890,6 @@\n+        if (pendingTokens.nonEmpty()) {\n+            Token token = pendingTokens.head;\n+            pendingTokens = pendingTokens.tail;\n+            return token;\n+        }\n+\n@@ -789,0 +901,2 @@\n+        isStringTemplate = false;\n+        fragmentRanges = List.nil();\n@@ -983,0 +1097,1 @@\n+                        int errorPos = position();\n@@ -992,1 +1107,0 @@\n-\n@@ -1029,2 +1143,2 @@\n-                                arg = (32 < ch && ch < 127) ? String.format(\"%s\", ch) :\n-                                                              String.format(\"\\\\u%04x\", (int) ch);\n+                                arg = (32 < ch && ch < 127) ? String.valueOf(ch) :\n+                                                              \"\\\\u%04x\".formatted((int) ch);\n@@ -1043,0 +1157,5 @@\n+            \/\/ Track end of final fragment.\n+            if (isStringTemplate) {\n+                fragmentRanges = fragmentRanges.append(endPos);\n+            }\n+\n@@ -1074,0 +1193,5 @@\n+                if (isStringTemplate) {\n+                    \/\/ Break string into fragments and then return the first of the framents.\n+                    return getFragments(string, comments);\n+                }\n+\n@@ -1103,0 +1227,60 @@\n+    \/**\n+     * Convert the string into a list of pending tokens to precede embedded\n+     * expressions.\n+     *\n+     * @param string    string to fragment\n+     * @param comments  comments for first token\n+     *\n+     * @return first pending token.\n+     *\/\n+    private Token getFragments(String string, List<Comment> comments) {\n+        List<Token> tokens = List.nil();\n+        Iterator<Integer> rangeIter = fragmentRanges.iterator();\n+        for (String fragment : fragment(string)) {\n+            fragment = fragment.translateEscapes();\n+            int fragmentPos = rangeIter.next();\n+            int fragmentEndPos = rangeIter.next();\n+            Token token = new StringToken(TokenKind.STRINGFRAGMENT,\n+                    fragmentPos, fragmentEndPos, fragment, comments);\n+            comments = null;\n+            tokens = tokens.append(token);\n+        }\n+        pendingTokens = tokens.appendList(pendingTokens);\n+        Token first = pendingTokens.head;\n+        pendingTokens = pendingTokens.tail;\n+        return first;\n+    }\n+\n+    \/**\n+     * Break string template up into fragments. \"\\{}\" indicates where\n+     * embedded expressions occur.\n+     *\n+     * @param string string template\n+     *\n+     * @return list of fragment strings\n+     *\/\n+    List<String> fragment(String string) {\n+        List<String> fragments = List.nil();\n+        StringBuilder sb = new StringBuilder();\n+        int length = string.length();\n+        for (int i = 0; i < length; i++) {\n+            char ch = string.charAt(i);\n+            if (ch != '\\\\') {\n+                sb.append(ch);\n+            } else if (i + 2 < length && string.charAt(i + 1) == '{'\n+                    && string.charAt(i + 2) == '}') {\n+                fragments = fragments.append(sb.toString());\n+                sb.setLength(0);\n+                i += 2;\n+            } else if (i + 1 < length){\n+                sb.append('\\\\');\n+                sb.append(string.charAt(i + 1));\n+                i++;\n+            } else {\n+                \/\/ Error already reported.\n+            }\n+        }\n+        fragments = fragments.append(sb.toString());\n+        return fragments;\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavaTokenizer.java","additions":212,"deletions":28,"binary":false,"changes":240,"status":"modified"},{"patch":"@@ -0,0 +1,1 @@\n+\/*\n@@ -237,12 +238,28 @@\n-     *     mode = EXPR        : an expression\n-     *     mode = TYPE        : a type\n-     *     mode = NOPARAMS    : no parameters allowed for type\n-     *     mode = TYPEARG     : type argument\n-     *     mode |= NOLAMBDA   : lambdas are not allowed\n-     *\/\n-    protected static final int EXPR = 0x1;\n-    protected static final int TYPE = 0x2;\n-    protected static final int NOPARAMS = 0x4;\n-    protected static final int TYPEARG = 0x8;\n-    protected static final int DIAMOND = 0x10;\n-    protected static final int NOLAMBDA = 0x20;\n+     *     mode = EXPR          : an expression\n+     *     mode = TYPE          : a type\n+     *     mode = NOPARAMS      : no parameters allowed for type\n+     *     mode = TYPEARG       : type argument\n+     *     mode |= NOLAMBDA     : lambdas are not allowed\n+     *\/\n+    protected static final int EXPR          = 1 << 0;\n+    protected static final int TYPE          = 1 << 1;\n+    protected static final int NOPARAMS      = 1 << 2;\n+    protected static final int TYPEARG       = 1 << 3;\n+    protected static final int DIAMOND       = 1 << 4;\n+    protected static final int NOLAMBDA      = 1 << 5;\n+\n+    protected void setMode(int mode) {\n+        this.mode = mode;\n+    }\n+\n+    protected void setLastMode(int mode) {\n+        lastmode = mode;\n+    }\n+\n+    protected boolean isMode(int mode) {\n+        return (this.mode & mode) != 0;\n+    }\n+\n+    protected boolean wasTypeMode() {\n+        return (lastmode & TYPE) != 0;\n+    }\n@@ -251,1 +268,1 @@\n-        mode = (mode & NOLAMBDA) | EXPR;\n+        setMode((mode & NOLAMBDA) | EXPR);\n@@ -255,1 +272,1 @@\n-        mode = (mode & NOLAMBDA) | TYPE;\n+        setMode((mode & NOLAMBDA) | TYPE);\n@@ -479,1 +496,1 @@\n-        if ((mode & EXPR) != 0)\n+        if (isMode(EXPR))\n@@ -636,0 +653,52 @@\n+    \/**\n+     * StringTemplate =\n+     *    [STRINGFRAGMENT] [EmbeddedExpression]\n+     *  | STRINGLITERAL\n+     *\n+     * EmbeddedExpression =\n+     *  LBRACE term RBRACE\n+     *\/\n+    JCExpression stringTemplate(JCExpression processor) {\n+        checkSourceLevel(Feature.STRING_TEMPLATES);\n+        \/\/ Disable standalone string templates\n+        if (processor == null) {\n+            log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.ProcessorMissingFromStringTemplateExpression);\n+        }\n+        int oldmode = mode;\n+        selectExprMode();\n+        Token stringToken = token;\n+        int pos = stringToken.pos;\n+        int endPos = stringToken.endPos;\n+        TokenKind kind = stringToken.kind;\n+        String string = token.stringVal();\n+        List<String> fragments = List.of(stringToken.stringVal());\n+        List<JCExpression> expressions = List.nil();\n+        nextToken();\n+        if (kind != STRINGLITERAL) {\n+            while (token.kind == STRINGFRAGMENT) {\n+                stringToken = token;\n+                endPos = stringToken.endPos;\n+                string = stringToken.stringVal();\n+                fragments = fragments.append(stringToken.stringVal());\n+                nextToken();\n+             }\n+            while (token.pos < endPos && token.kind != DEFAULT && token.kind != ERROR) {\n+                accept(LBRACE);\n+                JCExpression expression = token.kind == RBRACE ? F.at(pos).Literal(TypeTag.BOT, null)\n+                                                               : term(EXPR);\n+                expressions = expressions.append(expression);\n+                if (token.kind != ERROR) {\n+                    accept(RBRACE);\n+                }\n+            }\n+            \/\/ clean up remaining expression tokens if error\n+            while (token.pos < endPos && token.kind != DEFAULT) {\n+                nextToken();\n+            }\n+            S.setPrevToken(stringToken);\n+        }\n+        JCExpression t = F.at(pos).StringTemplate(processor, fragments, expressions);\n+        setMode(oldmode);\n+        return t;\n+    }\n+\n@@ -871,1 +940,1 @@\n-        mode = newmode;\n+        setMode(newmode);\n@@ -873,2 +942,2 @@\n-        lastmode = mode;\n-        mode = prevmode;\n+        setLastMode(mode);\n+        setMode(prevmode);\n@@ -893,1 +962,1 @@\n-        if ((mode & EXPR) != 0 &&\n+        if (isMode(EXPR) &&\n@@ -937,1 +1006,1 @@\n-        if ((mode & EXPR) != 0 && token.kind == QUES) {\n+        if (isMode(EXPR) && token.kind == QUES) {\n@@ -966,1 +1035,1 @@\n-        if ((mode & EXPR) != 0 && prec(token.kind) >= TreeInfo.orPrec) {\n+        if (isMode(EXPR) && prec(token.kind) >= TreeInfo.orPrec) {\n@@ -1191,1 +1260,1 @@\n-            if ((mode & TYPE) != 0 && (mode & (TYPEARG|NOPARAMS)) == TYPEARG) {\n+            if (isMode(TYPE) && isMode(TYPEARG) && !isMode(NOPARAMS)) {\n@@ -1197,1 +1266,1 @@\n-            if (typeArgs == null && (mode & EXPR) != 0) {\n+            if (typeArgs == null && isMode(EXPR)) {\n@@ -1213,1 +1282,1 @@\n-            if (typeArgs == null && (mode & EXPR) != 0) {\n+            if (typeArgs == null && isMode(EXPR)) {\n@@ -1249,1 +1318,1 @@\n-            if ((mode & EXPR) != 0) {\n+            if (isMode(EXPR)) {\n@@ -1261,1 +1330,1 @@\n-            if ((mode & EXPR) != 0) {\n+            if (isMode(EXPR)) {\n@@ -1271,1 +1340,1 @@\n-            if (typeArgs == null && (mode & EXPR) != 0) {\n+            if (typeArgs == null && isMode(EXPR)) {\n@@ -1276,0 +1345,8 @@\n+         case STRINGFRAGMENT:\n+             if (typeArgs == null && isMode(EXPR)) {\n+                 selectExprMode();\n+                 t = stringTemplate(null);\n+             } else {\n+                 return illegal();\n+             }\n+             break;\n@@ -1278,1 +1355,1 @@\n-            if ((mode & EXPR) != 0) {\n+            if (isMode(EXPR)) {\n@@ -1296,1 +1373,1 @@\n-            if ((mode & TYPE) == 0) {\n+            if (!isMode(TYPE)) {\n@@ -1326,1 +1403,1 @@\n-            if ((mode & EXPR) != 0 && (mode & NOLAMBDA) == 0 && peekToken(ARROW)) {\n+            if (isMode(EXPR) && !isMode(NOLAMBDA) && peekToken(ARROW)) {\n@@ -1351,1 +1428,1 @@\n-                            if ((mode & EXPR) != 0) {\n+                            if (isMode(EXPR)) {\n@@ -1361,1 +1438,1 @@\n-                        if ((mode & EXPR) != 0) {\n+                        if (isMode(EXPR)) {\n@@ -1373,1 +1450,1 @@\n-                        int oldmode = mode;\n+                        int prevmode = mode;\n@@ -1376,2 +1453,2 @@\n-                        mode = oldmode;\n-                        if ((mode & EXPR) != 0) {\n+                        setMode(prevmode);\n+                        if (isMode(EXPR)) {\n@@ -1406,0 +1483,6 @@\n+                            case STRINGFRAGMENT:\n+                            case STRINGLITERAL:\n+                                if (typeArgs != null) return illegal();\n+                                t = stringTemplate(t);\n+                                typeArgs = null;\n+                                break loop;\n@@ -1410,1 +1493,1 @@\n-                        if ((mode & TYPE) != 0 && token.kind == MONKEYS_AT) {\n+                        if (isMode(TYPE) && token.kind == MONKEYS_AT) {\n@@ -1436,1 +1519,1 @@\n-                        if ((mode & TYPE) == 0 && isUnboundMemberRef()) {\n+                        if (!isMode(TYPE) && isUnboundMemberRef()) {\n@@ -1479,1 +1562,1 @@\n-            if ((mode & EXPR) != 0) {\n+            if (isMode(EXPR)) {\n@@ -1523,0 +1606,1 @@\n+            \/\/ Not reachable.\n@@ -1584,2 +1668,2 @@\n-                if ((mode & TYPE) != 0) {\n-                    int oldmode = mode;\n+                if (isMode(TYPE)) {\n+                    int prevmode = mode;\n@@ -1600,1 +1684,1 @@\n-                    mode = oldmode;\n+                    setMode(prevmode);\n@@ -1602,1 +1686,1 @@\n-                if ((mode & EXPR) != 0) {\n+                if (isMode(EXPR)) {\n@@ -1611,1 +1695,1 @@\n-                if (token.kind == SUPER && (mode & EXPR) != 0) {\n+                if (token.kind == SUPER && isMode(EXPR)) {\n@@ -1617,1 +1701,1 @@\n-                } else if (token.kind == NEW && (mode & EXPR) != 0) {\n+                } else if (token.kind == NEW && isMode(EXPR)) {\n@@ -1625,1 +1709,10 @@\n-                } else {\n+                } else if (token.kind == TokenKind.STRINGFRAGMENT ||\n+                           token.kind == TokenKind.STRINGLITERAL) {\n+                    if (typeArgs != null) {\n+                        return illegal();\n+                    }\n+                    t = stringTemplate(t);\n+                    typeArgs = null;\n+                    \/\/ Uncomment to not allow follow on DOT\n+                    \/\/ return t;\n+                 } else {\n@@ -1627,1 +1720,1 @@\n-                    if ((mode & TYPE) != 0 && token.kind == MONKEYS_AT) {\n+                    if (isMode(TYPE) && token.kind == MONKEYS_AT) {\n@@ -1645,1 +1738,1 @@\n-            } else if ((mode & EXPR) != 0 && token.kind == COLCOL) {\n+            } else if (isMode(EXPR) && token.kind == COLCOL) {\n@@ -1660,1 +1753,1 @@\n-        while ((token.kind == PLUSPLUS || token.kind == SUBSUB) && (mode & EXPR) != 0) {\n+        while ((token.kind == PLUSPLUS || token.kind == SUBSUB) && isMode(EXPR)) {\n@@ -1784,0 +1877,1 @@\n+                        case STRINGFRAGMENT:\n@@ -1802,1 +1896,1 @@\n-                        return (mode & NOLAMBDA) == 0 ? ParensResult.IMPLICIT_LAMBDA\n+                        return !isMode(NOLAMBDA) ? ParensResult.IMPLICIT_LAMBDA\n@@ -2052,1 +2146,1 @@\n-        if ((mode & EXPR) != 0 && token.kind == LPAREN || typeArgs != null) {\n+        if (isMode(EXPR) && token.kind == LPAREN || typeArgs != null) {\n@@ -2107,2 +2201,2 @@\n-            (mode & TYPE) != 0 &&\n-            (mode & NOPARAMS) == 0) {\n+            isMode(TYPE) &&\n+            !isMode(NOPARAMS)) {\n@@ -2121,2 +2215,2 @@\n-            if ((mode & useMode) == 0 ||\n-                (mode & NOPARAMS) != 0) {\n+            if (!isMode(useMode) ||\n+                isMode(NOPARAMS)) {\n@@ -2125,1 +2219,1 @@\n-            mode = useMode;\n+            setMode(useMode);\n@@ -2145,1 +2239,1 @@\n-                args.append(((mode & EXPR) == 0) ? typeArgument() : parseType());\n+                args.append(!isMode(EXPR) ? typeArgument() : parseType());\n@@ -2148,1 +2242,1 @@\n-                    args.append(((mode & EXPR) == 0) ? typeArgument() : parseType());\n+                    args.append(!isMode(EXPR) ? typeArgument() : parseType());\n@@ -2269,1 +2363,1 @@\n-        if ((mode & EXPR) != 0 && token.kind == DOT) {\n+        if (isMode(EXPR) && token.kind == DOT) {\n@@ -2293,1 +2387,1 @@\n-        } else if ((mode & TYPE) != 0) {\n+        } else if (isMode(TYPE)) {\n@@ -2352,1 +2446,1 @@\n-        int oldmode = mode;\n+        int prevmode = mode;\n@@ -2359,1 +2453,1 @@\n-            diamondFound = (mode & DIAMOND) != 0;\n+            diamondFound = isMode(DIAMOND);\n@@ -2378,1 +2472,1 @@\n-                diamondFound = (mode & DIAMOND) != 0;\n+                diamondFound = isMode(DIAMOND);\n@@ -2381,1 +2475,1 @@\n-        mode = oldmode;\n+        setMode(prevmode);\n@@ -2433,1 +2527,1 @@\n-            int oldmode = mode;\n+            int prevmode = mode;\n@@ -2435,1 +2529,1 @@\n-            mode = oldmode;\n+            setMode(prevmode);\n@@ -2701,0 +2795,1 @@\n+                    case STRINGFRAGMENT:\n@@ -2768,1 +2863,1 @@\n-            } else if ((lastmode & TYPE) != 0 && LAX_IDENTIFIER.test(token.kind)) {\n+            } else if (wasTypeMode() && LAX_IDENTIFIER.test(token.kind)) {\n@@ -3216,1 +3311,1 @@\n-            if ((lastmode & TYPE) != 0 && LAX_IDENTIFIER.test(token.kind)) {\n+            if (wasTypeMode() && LAX_IDENTIFIER.test(token.kind)) {\n@@ -3218,1 +3313,1 @@\n-            } else if ((lastmode & TYPE) != 0 && token.kind == COLON) {\n+            } else if (wasTypeMode() && token.kind == COLON) {\n@@ -3248,2 +3343,2 @@\n-        lastmode = mode;\n-        mode = prevmode;\n+        setLastMode(mode);\n+        setMode(prevmode);\n@@ -3671,1 +3766,1 @@\n-        if ((lastmode & TYPE) != 0 && LAX_IDENTIFIER.test(token.kind)) {\n+        if (wasTypeMode() && LAX_IDENTIFIER.test(token.kind)) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":166,"deletions":71,"binary":false,"changes":237,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,0 +62,5 @@\n+    \/**\n+     * Sets the previous token.\n+     *\/\n+    void setPrevToken(Token prevToken);\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/Lexer.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,2 +33,0 @@\n-import com.sun.tools.javac.parser.JavaTokenizer.*;\n-\n@@ -47,1 +45,1 @@\n-    private Tokens tokens;\n+    private final Tokens tokens;\n@@ -59,1 +57,1 @@\n-    private List<Token> savedTokens = new ArrayList<>();\n+    private final List<Token> savedTokens = new ArrayList<>();\n@@ -61,1 +59,1 @@\n-    private JavaTokenizer tokenizer;\n+    private final JavaTokenizer tokenizer;\n@@ -101,2 +99,3 @@\n-            for (int i = savedTokens.size() ; i < lookahead ; i ++) {\n-                savedTokens.add(tokenizer.readToken());\n+            for (int i = savedTokens.size() ; i < lookahead ; i++) {\n+                Token ahead = tokenizer.readToken();\n+                savedTokens.add(ahead);\n@@ -110,0 +109,4 @@\n+    public void setPrevToken(Token prevToken) {\n+        this.prevToken = prevToken;\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/Scanner.java","additions":11,"deletions":8,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -154,0 +154,1 @@\n+        STRINGFRAGMENT(Tag.STRING),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/Tokens.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -119,0 +119,9 @@\n+    \/**\n+     * Returns the character buffer.\n+     *\n+     * @return character buffer.\n+     *\/\n+    protected char[] buffer() {\n+        return buffer;\n+    }\n+\n@@ -382,0 +391,3 @@\n+    protected boolean isOneOf(char ch1, char ch2, char ch3, char ch4) {\n+        return is(ch1) || is(ch2) || is(ch3) || is(ch4);\n+    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/UnicodeReader.java","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1290,0 +1290,17 @@\n+compiler.err.unclosed.string.template=\\\n+    unclosed string template\n+\n+compiler.err.unclosed.text.block.template=\\\n+    unclosed text block template\n+\n+compiler.err.processor.missing.from.string.template.expression=\\\n+    processor missing from string template expression\n+\n+# 0: symbol\n+compiler.err.raw.template.processor.type=\\\n+    raw template processor type: {0}\n+\n+# 0: symbol\n+compiler.err.not.template.processor.type=\\\n+    not a template processor type: {0}\n+\n@@ -3070,0 +3087,3 @@\n+compiler.misc.feature.string.templates=\\\n+    string templates\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -272,0 +272,4 @@\n+        \/** String template expression.\n+         *\/\n+        STRING_TEMPLATE,\n+\n@@ -2485,0 +2489,52 @@\n+    \/**\n+     * String template expression.\n+     *\/\n+    public static class JCStringTemplate extends JCExpression implements StringTemplateTree {\n+        public JCExpression processor;\n+        public List<String> fragments;\n+        public List<JCExpression> expressions;\n+\n+        protected JCStringTemplate(JCExpression processor,\n+                                   List<String> fragments,\n+                                   List<JCExpression> expressions) {\n+            this.processor = processor;\n+            this.fragments = fragments;\n+            this.expressions = expressions;\n+        }\n+\n+        @Override\n+        public ExpressionTree getProcessor() {\n+            return processor;\n+        }\n+\n+        @Override\n+        public List<String> getFragments() {\n+            return fragments;\n+        }\n+\n+        @Override\n+        public List<? extends ExpressionTree> getExpressions() {\n+            return expressions;\n+        }\n+\n+        @Override @DefinedBy(Api.COMPILER_TREE)\n+        public Kind getKind() {\n+            return Kind.TEMPLATE;\n+        }\n+\n+        @Override @DefinedBy(Api.COMPILER_TREE)\n+        public Tag getTag() {\n+            return STRING_TEMPLATE;\n+        }\n+\n+        @Override @DefinedBy(Api.COMPILER_TREE)\n+        public void accept(Visitor v) {\n+            v.visitStringTemplate(this);\n+        }\n+\n+        @Override @DefinedBy(Api.COMPILER_TREE)\n+        public <R, D> R accept(TreeVisitor<R, D> v, D d) {\n+            return v.visitStringTemplate(this, d);\n+        }\n+    }\n+\n@@ -3464,0 +3520,3 @@\n+        JCStringTemplate StringTemplate(JCExpression processor,\n+                                        List<String> fragments,\n+                                        List<JCExpression> expressions);\n@@ -3535,0 +3594,1 @@\n+        public void visitStringTemplate(JCStringTemplate that) { visitTree(that); }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/JCTree.java","additions":60,"deletions":0,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import java.util.stream.Collectors;\n@@ -1449,0 +1450,17 @@\n+            throw new UncheckedIOException(e);\n+        }\n+    }\n+\n+    public void visitStringTemplate(JCStringTemplate tree) {\n+        try {\n+            JCExpression processor = tree.processor;\n+            print(\"[\");\n+            if (processor != null) {\n+                printExpr(processor);\n+            }\n+            print(\"]\");\n+            print(\"\\\"\" + tree.fragments.stream().collect(Collectors.joining(\"\\\\{}\")) + \"\\\"\");\n+            print(\"(\");\n+            printExprs(tree.expressions);\n+            print(\")\");\n+        } catch (IOException e) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/Pretty.java","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -285,0 +285,8 @@\n+    @DefinedBy(Api.COMPILER_TREE)\n+    public JCTree visitStringTemplate(StringTemplateTree node, P p) {\n+        JCStringTemplate t = (JCStringTemplate) node;\n+        JCExpression processor = copy(t.processor, p);\n+        List<JCExpression> expressions = copy(t.expressions, p);\n+        return M.at(t.pos).StringTemplate(processor, t.fragments, expressions);\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeCopier.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -331,0 +331,1 @@\n+            case STRING_TEMPLATE:\n@@ -546,0 +547,8 @@\n+            case STRING_TEMPLATE: {\n+                JCStringTemplate node = (JCStringTemplate) tree;\n+                if (node.processor == null) {\n+                    return node.pos;\n+                } else {\n+                    return getStartPos(node.processor);\n+                }\n+            }\n@@ -959,0 +968,2 @@\n+        case CLASSDEF:\n+            return ((JCClassDecl) tree).sym;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeInfo.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -553,0 +553,8 @@\n+    public JCStringTemplate StringTemplate(JCExpression processor,\n+                                           List<String> fragments,\n+                                           List<JCExpression> expressions) {\n+        JCStringTemplate tree = new JCStringTemplate(processor, fragments, expressions);\n+        tree.pos = pos;\n+        return tree;\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeMaker.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -359,0 +359,5 @@\n+    public void visitStringTemplate(JCStringTemplate tree) {\n+        scan(tree.processor);\n+        scan(tree.expressions);\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeScanner.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -414,0 +414,7 @@\n+    public void visitStringTemplate(JCStringTemplate tree) {\n+        tree.processor = translate(tree.processor);\n+        tree.expressions = translate(tree.expressions);\n+\n+        result = tree;\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeTranslator.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -225,0 +225,10 @@\n+    \/\/ templated string\n+    public final Name process;\n+    public final Name interpolate;\n+    public final Name fragments;\n+    public final Name fragmentsUpper;\n+    public final Name valuesUpper;\n+    public final Name toList;\n+    public final Name str;\n+    public final Name stringTemplateBSM;\n+\n@@ -398,0 +408,10 @@\n+        \/\/ templated string\n+        process = fromString(\"process\");\n+        interpolate = fromString(\"interpolate\");\n+        fragments = fromString(\"fragments\");\n+        fragmentsUpper = fromString(\"FRAGMENTS\");\n+        valuesUpper = fromString(\"VALUES\");\n+        toList = fromString(\"toList\");\n+        str = fromString(\"STR\");\n+        stringTemplateBSM = fromString(\"stringTemplateBSM\");\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/Names.java","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n-\n","filename":"src\/jdk.incubator.concurrent\/share\/classes\/module-info.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -275,0 +275,1 @@\n+        STRINGFRAGMENT(TokenKind.STRINGFRAGMENT, XEXPR1|XTERM),\n@@ -482,2 +483,10 @@\n-            scanner.nextToken();\n-            current = scanner.token();\n+            if (current != null && current.kind == TokenKind.STRINGFRAGMENT) {\n+                int endPos = current.endPos;\n+                do {\n+                    scanner.nextToken();\n+                    current = scanner.token();\n+                } while (current != null && current.endPos <= endPos);\n+            } else {\n+                scanner.nextToken();\n+                current = scanner.token();\n+            }\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/CompletenessAnalyzer.java","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -0,0 +1,136 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.invoke.*;\n+import java.util.*;\n+\n+\/**\n+ * @test\n+ * @summary Test StringConcatFactory.makeConcatWithTemplate... methods.\n+ * @compile --enable-preview -source ${jdk.version} MakeConcatWithTemplate.java\n+ * @run main\/othervm --enable-preview MakeConcatWithTemplate\n+ *\/\n+\n+public class MakeConcatWithTemplate {\n+    public static void main(String... args) {\n+        makeConcatWithTemplate();\n+        makeConcatWithTemplateCluster();\n+        makeConcatWithTemplateGetters();\n+    }\n+\n+    static List<String> fragments(int n) {\n+        String[] array = new String[n];\n+        Arrays.fill(array, \"abc\");\n+        return Arrays.asList(array);\n+    }\n+\n+    static List<Class<?>> types(int n) {\n+        Class<?>[] array = new Class<?>[n];\n+        Arrays.fill(array, int.class);\n+        return Arrays.asList(array);\n+    }\n+\n+    static List<Integer> values(int n) {\n+        Integer[] array = new Integer[n];\n+        Arrays.fill(array, 123);\n+        return Arrays.asList(array);\n+    }\n+\n+    static List<MethodHandle> getters(int n) {\n+        MethodHandle[] array = new MethodHandle[n];\n+        MethodHandle m = MethodHandles.dropArguments(MethodHandles.constant(int.class, 123), 0, Object.class);\n+        Arrays.fill(array, m);\n+        return Arrays.asList(array);\n+    }\n+\n+    static void makeConcatWithTemplate() {\n+        try {\n+            int n = StringConcatFactory.MAX_INDY_CONCAT_ARG_SLOTS - 1;\n+            MethodHandle m = StringConcatFactory.makeConcatWithTemplate(fragments(n + 1), types(n));\n+            m.invokeWithArguments(values(n));\n+        } catch (Throwable e) {\n+            throw new RuntimeException(e);\n+        }\n+\n+        try {\n+            int n = StringConcatFactory.MAX_INDY_CONCAT_ARG_SLOTS;\n+            MethodHandle m = StringConcatFactory.makeConcatWithTemplate(fragments(n + 1), types(n));\n+            m.invokeWithArguments(values(n));\n+        } catch (Throwable e) {\n+            throw new RuntimeException(e);\n+        }\n+\n+        boolean threw = false;\n+        try {\n+            int n = StringConcatFactory.MAX_INDY_CONCAT_ARG_SLOTS + 1;\n+            MethodHandle m = StringConcatFactory.makeConcatWithTemplate(fragments(n + 1), types(n));\n+            m.invokeWithArguments(values(n));\n+        } catch (Throwable e) {\n+            threw = true;\n+        }\n+\n+        if (!threw) {\n+            throw new RuntimeException(\"Exception expected - makeConcatWithTemplate\");\n+        }\n+    }\n+\n+    static void makeConcatWithTemplateCluster() {\n+        int n = StringConcatFactory.MAX_INDY_CONCAT_ARG_SLOTS;\n+        int c = 3;\n+        try {\n+            List<MethodHandle> ms = StringConcatFactory.makeConcatWithTemplateCluster(fragments(c * n + 1), types(c * n), n);\n+            MethodHandle m0 = ms.get(0);\n+            MethodHandle m1 = ms.get(1);\n+            MethodHandle m2 = ms.get(2);\n+            MethodHandle m3 = ms.get(3);\n+\n+            String s = (String)m0.invokeWithArguments(values(n));\n+            List<Object> args = new ArrayList<>();\n+            args.add(s);\n+            args.addAll(values(n - 1)); \/\/ one less for carry over string\n+            s = (String)m1.invokeWithArguments(args);\n+            args.clear();\n+            args.add(s);\n+            args.addAll(values(n - 1)); \/\/ one less for carry over string\n+            s = (String)m2.invokeWithArguments(args);\n+            args.clear();\n+            args.add(s);\n+            args.addAll(values(2)); \/\/ two remaining carry overs\n+            s = (String)m3.invokeWithArguments(args);\n+        } catch (Throwable e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    static void makeConcatWithTemplateGetters() {\n+        int n = StringConcatFactory.MAX_INDY_CONCAT_ARG_SLOTS;\n+        int c = 3;\n+        try {\n+            MethodHandle m = StringConcatFactory.makeConcatWithTemplateGetters(fragments(c * n + 1), getters(c * n), n);\n+            String s = (String)m.invoke(null);\n+        } catch (Throwable e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/lang\/String\/concat\/MakeConcatWithTemplate.java","additions":136,"deletions":0,"binary":false,"changes":136,"status":"added"},{"patch":"@@ -0,0 +1,512 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 0000000\n+ * @summary Exercise runtime handing of templated strings.\n+ * @compile --enable-preview -source ${jdk.version} Basic.java\n+ * @run main\/othervm --enable-preview Basic\n+ *\/\n+\n+import java.lang.template.*;\n+import java.util.*;\n+import java.util.concurrent.*;\n+import java.util.function.*;\n+\n+import static java.lang.template.StringTemplate.RAW;\n+\n+public class Basic {\n+    public static void main(String... arg) {\n+        equalsHashCode();\n+        concatenationTests();\n+        componentTests();\n+        limitsTests();\n+        processorTests();\n+        stringTemplateCoverage();\n+        templateProcessorCoverage();\n+    }\n+\n+    static void ASSERT(String a, String b) {\n+        if (!Objects.equals(a, b)) {\n+            System.out.println(a);\n+            System.out.println(b);\n+            throw new RuntimeException(\"Test failed\");\n+        }\n+    }\n+\n+    static void ASSERT(Object a, Object b) {\n+        if (!Objects.deepEquals(a, b)) {\n+            System.out.println(a);\n+            System.out.println(b);\n+            throw new RuntimeException(\"Test failed\");\n+        }\n+    }\n+\n+    \/*\n+     * equals and hashCode tests.\n+     *\/\n+    static void equalsHashCode() {\n+        int x = 10;\n+        int y = 20;\n+        int a = 10;\n+        int b = 20;\n+\n+        StringTemplate st0 = RAW.\"\\{x} + \\{y} = \\{x + y}\";\n+        StringTemplate st1 = RAW.\"\\{a} + \\{b} = \\{a + b}\";\n+        StringTemplate st2 = RAW.\"\\{x} + \\{y} = \\{x + y}!\";\n+        x++;\n+        StringTemplate st3 = RAW.\"\\{x} + \\{y} = \\{x + y}\";\n+\n+        if (!st0.equals(st1)) throw new RuntimeException(\"st0 != st1\");\n+        if (st0.equals(st2)) throw new RuntimeException(\"st0 == st2\");\n+        if (st0.equals(st3)) throw new RuntimeException(\"st0 == st3\");\n+\n+        if (st0.hashCode() != st1.hashCode()) throw new RuntimeException(\"st0.hashCode() != st1.hashCode()\");\n+    }\n+\n+    \/*\n+     * Concatenation tests.\n+     *\/\n+    static void concatenationTests() {\n+        int x = 10;\n+        int y = 20;\n+\n+        ASSERT(STR.\"\\{x} \\{y}\", x + \" \" + y);\n+        ASSERT(STR.\"\\{x + y}\", \"\" + (x + y));\n+        ASSERT(STR.process(RAW.\"\\{x} \\{y}\"), x + \" \" + y);\n+        ASSERT(STR.process(RAW.\"\\{x + y}\"), \"\" + (x + y));\n+        ASSERT((RAW.\"\\{x} \\{y}\").process(STR), x + \" \" + y);\n+        ASSERT((RAW.\"\\{x + y}\").process(STR), \"\" + (x + y));\n+    }\n+\n+    \/*\n+     * Component tests.\n+     *\/\n+    static void componentTests() {\n+        int x = 10;\n+        int y = 20;\n+\n+        StringTemplate st = RAW.\"\\{x} + \\{y} = \\{x + y}\";\n+        ASSERT(st.values(), List.of(x, y, x + y));\n+        ASSERT(st.fragments(), List.of(\"\", \" + \", \" = \", \"\"));\n+        ASSERT(st.interpolate(), x + \" + \" + y + \" = \" + (x + y));\n+    }\n+\n+    \/*\n+     * Limits tests.\n+     *\/\n+    static void limitsTests() {\n+        int x = 9;\n+\n+        StringTemplate ts250 = RAW.\"\"\"\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \"\"\";\n+        ASSERT(ts250.values().size(), 250);\n+        ASSERT(ts250.interpolate(), \"\"\"\n+               9999999999 9999999999\n+               9999999999 9999999999\n+               9999999999 9999999999\n+               9999999999 9999999999\n+               9999999999 9999999999\n+\n+               9999999999 9999999999\n+               9999999999 9999999999\n+               9999999999 9999999999\n+               9999999999 9999999999\n+               9999999999 9999999999\n+\n+               9999999999 9999999999\n+               9999999999 9999999999\n+               9999999999\n+               \"\"\");\n+\n+        StringTemplate ts251 = RAW.\"\"\"\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\n+             \"\"\";\n+        ASSERT(ts251.values().size(), 251);\n+        ASSERT(ts251.interpolate(), \"\"\"\n+               9999999999 9999999999\n+               9999999999 9999999999\n+               9999999999 9999999999\n+               9999999999 9999999999\n+               9999999999 9999999999\n+\n+               9999999999 9999999999\n+               9999999999 9999999999\n+               9999999999 9999999999\n+               9999999999 9999999999\n+               9999999999 9999999999\n+\n+               9999999999 9999999999\n+               9999999999 9999999999\n+               9999999999 9\n+               \"\"\");\n+\n+        StringTemplate ts252 = RAW.\"\"\"\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\n+             \"\"\";\n+        ASSERT(ts252.values().size(), 252);\n+        ASSERT(ts252.interpolate(), \"\"\"\n+               9999999999 9999999999\n+               9999999999 9999999999\n+               9999999999 9999999999\n+               9999999999 9999999999\n+               9999999999 9999999999\n+\n+               9999999999 9999999999\n+               9999999999 9999999999\n+               9999999999 9999999999\n+               9999999999 9999999999\n+               9999999999 9999999999\n+\n+               9999999999 9999999999\n+               9999999999 9999999999\n+               9999999999 99\n+               \"\"\");\n+\n+        StringTemplate ts253 = RAW.\"\"\"\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\n+             \"\"\";\n+        ASSERT(ts253.values().size(), 253);\n+        ASSERT(ts253.interpolate(), \"\"\"\n+               9999999999 9999999999\n+               9999999999 9999999999\n+               9999999999 9999999999\n+               9999999999 9999999999\n+               9999999999 9999999999\n+\n+               9999999999 9999999999\n+               9999999999 9999999999\n+               9999999999 9999999999\n+               9999999999 9999999999\n+               9999999999 9999999999\n+\n+               9999999999 9999999999\n+               9999999999 9999999999\n+               9999999999 999\n+               \"\"\");\n+\n+        StringTemplate ts254 = RAW.\"\"\"\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\n+             \"\"\";\n+        ASSERT(ts254.values().size(), 254);\n+        ASSERT(ts254.interpolate(), \"\"\"\n+               9999999999 9999999999\n+               9999999999 9999999999\n+               9999999999 9999999999\n+               9999999999 9999999999\n+               9999999999 9999999999\n+\n+               9999999999 9999999999\n+               9999999999 9999999999\n+               9999999999 9999999999\n+               9999999999 9999999999\n+               9999999999 9999999999\n+\n+               9999999999 9999999999\n+               9999999999 9999999999\n+               9999999999 9999\n+               \"\"\");\n+\n+        StringTemplate ts255 = RAW.\"\"\"\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\n+             \"\"\";\n+        ASSERT(ts255.values().size(), 255);\n+        ASSERT(ts255.interpolate(), \"\"\"\n+               9999999999 9999999999\n+               9999999999 9999999999\n+               9999999999 9999999999\n+               9999999999 9999999999\n+               9999999999 9999999999\n+\n+               9999999999 9999999999\n+               9999999999 9999999999\n+               9999999999 9999999999\n+               9999999999 9999999999\n+               9999999999 9999999999\n+\n+               9999999999 9999999999\n+               9999999999 9999999999\n+               9999999999 99999\n+               \"\"\");\n+\n+        StringTemplate ts256 = RAW.\"\"\"\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \"\"\";\n+        ASSERT(ts256.values().size(), 256);\n+        ASSERT(ts256.interpolate(), \"\"\"\n+               9999999999 9999999999\n+               9999999999 9999999999\n+               9999999999 9999999999\n+               9999999999 9999999999\n+               9999999999 9999999999\n+\n+               9999999999 9999999999\n+               9999999999 9999999999\n+               9999999999 9999999999\n+               9999999999 9999999999\n+               9999999999 9999999999\n+\n+               9999999999 9999999999\n+               9999999999 9999999999\n+               9999999999 999999\n+               \"\"\");\n+\n+    }\n+\n+    \/*\n+     * Processor tests.\n+     *\/\n+    public static final TemplateProcessor<StringTemplate> STRINGIFY = st -> {\n+        List<Object> values = st.values()\n+                .stream()\n+                .map(v -> (Object)String.valueOf(v))\n+                .toList();\n+\n+        return StringTemplate.of(st.fragments(), values);\n+    };\n+\n+    public static final TemplateProcessor<StringTemplate> UPPER = st -> {\n+        List<String> fragments = st.fragments()\n+                .stream()\n+                .map(String::toUpperCase)\n+                .toList();\n+\n+        return StringTemplate.of(fragments, st.values());\n+    };\n+\n+    public static final StringProcessor CHAIN = st -> {\n+        st = STRINGIFY.process(st);\n+        st = UPPER.process(st);\n+        return STR.process(st);\n+    };\n+\n+    static void processorTests() {\n+        String name = \"Joan\";\n+        int age = 25;\n+        ASSERT(CHAIN.\"\\{name} is \\{age} years old\", \"Joan IS 25 YEARS OLD\");\n+    }\n+\n+    \/*\n+     *  StringTemplate coverage\n+     *\/\n+    static void stringTemplateCoverage() {\n+        StringTemplate tsNoValues = StringTemplate.of(\"No Values\");\n+\n+        ASSERT(tsNoValues.values(), List.of());\n+        ASSERT(tsNoValues.fragments(), List.of(\"No Values\"));\n+        ASSERT(tsNoValues.interpolate(), STR.\"No Values\");\n+\n+        int x = 10, y = 20;\n+        StringTemplate src = RAW.\"\\{x} + \\{y} = \\{x + y}\";\n+        StringTemplate tsValues = StringTemplate.of(src.fragments(), src.values());\n+        ASSERT(tsValues.fragments(), List.of(\"\", \" + \", \" = \", \"\"));\n+        ASSERT(tsValues.values(), List.of(x, y, x + y));\n+        ASSERT(tsValues.interpolate(), x + \" + \" + y + \" = \" + (x + y));\n+        ASSERT(StringTemplate.combine(src, src).interpolate(),\n+                RAW.\"\\{x} + \\{y} = \\{x + y}\\{x} + \\{y} = \\{x + y}\".interpolate());\n+        ASSERT(src.valueTypes().get(0), int.class);\n+        ASSERT(src.valueTypes().get(1), int.class);\n+        ASSERT(src.valueTypes().get(2), int.class);\n+\n+        try {\n+            ASSERT(src.valueGetters().get(0).invoke(src), 10);\n+            ASSERT(src.valueGetters().get(1).invoke(src), 20);\n+            ASSERT(src.valueGetters().get(2).invoke(src), 30);\n+        } catch (Throwable ex) {\n+            throw new RuntimeException(ex);\n+        }\n+    }\n+\n+    \/*\n+     * TemplateProcessor coverage.\n+     *\/\n+\n+    static class Processor0 implements ValidatingProcessor<String, IllegalArgumentException> {\n+        @Override\n+        public String process(StringTemplate stringTemplate) throws IllegalArgumentException {\n+            StringBuilder sb = new StringBuilder();\n+            Iterator<String> fragmentsIter = stringTemplate.fragments().iterator();\n+\n+            for (Object value : stringTemplate.values()) {\n+                sb.append(fragmentsIter.next());\n+\n+                if (value instanceof Boolean) {\n+                    throw new IllegalArgumentException(\"I don't like Booleans\");\n+                }\n+\n+                sb.append(value);\n+            }\n+\n+            sb.append(fragmentsIter.next());\n+\n+            return sb.toString();\n+        }\n+    }\n+\n+    static Processor0 processor0 = new Processor0();\n+\n+    static ValidatingProcessor<String, RuntimeException> processor1 =\n+        st -> st.interpolate();\n+\n+    static TemplateProcessor<String> processor2 = st -> st.interpolate();\n+\n+    static StringProcessor processor3 = st -> st.interpolate();\n+\n+    static StringProcessor processor4 = st ->\n+        StringTemplate.interpolate(st.fragments(), st.values());\n+\n+\n+    static void templateProcessorCoverage() {\n+        try {\n+            int x = 10;\n+            int y = 20;\n+            ASSERT(processor0.\"\\{x} + \\{y} = \\{x + y}\", \"10 + 20 = 30\");\n+            ASSERT(processor1.\"\\{x} + \\{y} = \\{x + y}\", \"10 + 20 = 30\");\n+            ASSERT(processor2.\"\\{x} + \\{y} = \\{x + y}\", \"10 + 20 = 30\");\n+            ASSERT(processor3.\"\\{x} + \\{y} = \\{x + y}\", \"10 + 20 = 30\");\n+            ASSERT(processor4.\"\\{x} + \\{y} = \\{x + y}\", \"10 + 20 = 30\");\n+        } catch (IllegalArgumentException ex) {\n+            throw new RuntimeException(\"processor fail\");\n+        }\n+    }\n+\n+    static String justify(String string, int width) {\n+        boolean leftJustify = width < 0;\n+        int length = string.length();\n+        width = Math.abs(width);\n+        int diff = width - length;\n+\n+        if (diff < 0) {\n+            string = \"*\".repeat(width);\n+        } else if (0 < diff) {\n+            if (leftJustify) {\n+                string += \" \".repeat(diff);\n+            } else {\n+                string = \" \".repeat(diff) + string;\n+            }\n+        }\n+\n+        return string;\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/lang\/template\/Basic.java","additions":512,"deletions":0,"binary":false,"changes":512,"status":"added"},{"patch":"@@ -0,0 +1,915 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 0000000\n+ * @summary Exercise format builder.\n+ * @compile --enable-preview -source ${jdk.version} FormatterBuilder.java\n+ * @run main\/othervm --enable-preview FormatterBuilder\n+ *\/\n+\n+import java.lang.template.*;\n+import java.util.*;\n+\n+import static java.util.FormatProcessor.FMT;\n+\n+public class FormatterBuilder {\n+    public static void main(String... args) {\n+        Locale.setDefault(Locale.US);\n+        suite(FMT);\n+        Locale thai = Locale.forLanguageTag(\"th-TH-u-nu-thai\");\n+        FormatProcessor thaiFormat = new FormatProcessor(thai);\n+        Locale.setDefault(thai);\n+        suite(thaiFormat);\n+    }\n+\n+    static void test(String a, String b) {\n+        if (!Objects.equals(a, b)) {\n+            throw new RuntimeException(\"format and FMT do not match: \" + a + \" : \" + b);\n+        }\n+    }\n+\n+    static void suite(ValidatingProcessor<String, RuntimeException> fmt) {\n+        Object nullObject = null;\n+        test(String.format(\"%b\", false), fmt.\"%b\\{false}\");\n+        test(String.format(\"%b\", true), fmt.\"%b\\{true}\");\n+        test(String.format(\"%10b\", false), fmt.\"%10b\\{false}\");\n+        test(String.format(\"%10b\", true), fmt.\"%10b\\{true}\");\n+        test(String.format(\"%-10b\", false), fmt.\"%-10b\\{false}\");\n+        test(String.format(\"%-10b\", true), fmt.\"%-10b\\{true}\");\n+        test(String.format(\"%B\", false), fmt.\"%B\\{false}\");\n+        test(String.format(\"%B\", true), fmt.\"%B\\{true}\");\n+        test(String.format(\"%10B\", false), fmt.\"%10B\\{false}\");\n+        test(String.format(\"%10B\", true), fmt.\"%10B\\{true}\");\n+        test(String.format(\"%-10B\", false), fmt.\"%-10B\\{false}\");\n+        test(String.format(\"%-10B\", true), fmt.\"%-10B\\{true}\");\n+\n+        test(String.format(\"%h\", 12345), fmt.\"%h\\{12345}\");\n+        test(String.format(\"%h\", 0xABCDE), fmt.\"%h\\{0xABCDE}\");\n+        test(String.format(\"%10h\", 12345), fmt.\"%10h\\{12345}\");\n+        test(String.format(\"%10h\", 0xABCDE), fmt.\"%10h\\{0xABCDE}\");\n+        test(String.format(\"%-10h\", 12345), fmt.\"%-10h\\{12345}\");\n+        test(String.format(\"%-10h\", 0xABCDE), fmt.\"%-10h\\{0xABCDE}\");\n+        test(String.format(\"%H\", 12345), fmt.\"%H\\{12345}\");\n+        test(String.format(\"%H\", 0xABCDE), fmt.\"%H\\{0xABCDE}\");\n+        test(String.format(\"%10H\", 12345), fmt.\"%10H\\{12345}\");\n+        test(String.format(\"%10H\", 0xABCDE), fmt.\"%10H\\{0xABCDE}\");\n+        test(String.format(\"%-10H\", 12345), fmt.\"%-10H\\{12345}\");\n+        test(String.format(\"%-10H\", 0xABCDE), fmt.\"%-10H\\{0xABCDE}\");\n+\n+        test(String.format(\"%s\", (byte)0xFF), fmt.\"%s\\{(byte)0xFF}\");\n+        test(String.format(\"%s\", (short)0xFFFF), fmt.\"%s\\{(short)0xFFFF}\");\n+        test(String.format(\"%s\", 12345), fmt.\"%s\\{12345}\");\n+        test(String.format(\"%s\", 12345L), fmt.\"%s\\{12345L}\");\n+        test(String.format(\"%s\", 1.33f), fmt.\"%s\\{1.33f}\");\n+        test(String.format(\"%s\", 1.33), fmt.\"%s\\{1.33}\");\n+        test(String.format(\"%s\", \"abcde\"), fmt.\"%s\\{\"abcde\"}\");\n+        test(String.format(\"%s\", nullObject), fmt.\"%s\\{nullObject}\");\n+        test(String.format(\"%10s\", (byte)0xFF), fmt.\"%10s\\{(byte)0xFF}\");\n+        test(String.format(\"%10s\", (short)0xFFFF), fmt.\"%10s\\{(short)0xFFFF}\");\n+        test(String.format(\"%10s\", 12345), fmt.\"%10s\\{12345}\");\n+        test(String.format(\"%10s\", 12345L), fmt.\"%10s\\{12345L}\");\n+        test(String.format(\"%10s\", 1.33f), fmt.\"%10s\\{1.33f}\");\n+        test(String.format(\"%10s\", 1.33), fmt.\"%10s\\{1.33}\");\n+        test(String.format(\"%10s\", \"abcde\"), fmt.\"%10s\\{\"abcde\"}\");\n+        test(String.format(\"%10s\", nullObject), fmt.\"%10s\\{nullObject}\");\n+        test(String.format(\"%-10s\", (byte)0xFF), fmt.\"%-10s\\{(byte)0xFF}\");\n+        test(String.format(\"%-10s\", (short)0xFFFF), fmt.\"%-10s\\{(short)0xFFFF}\");\n+        test(String.format(\"%-10s\", 12345), fmt.\"%-10s\\{12345}\");\n+        test(String.format(\"%-10s\", 12345L), fmt.\"%-10s\\{12345L}\");\n+        test(String.format(\"%-10s\", 1.33f), fmt.\"%-10s\\{1.33f}\");\n+        test(String.format(\"%-10s\", 1.33), fmt.\"%-10s\\{1.33}\");\n+        test(String.format(\"%-10s\", \"abcde\"), fmt.\"%-10s\\{\"abcde\"}\");\n+        test(String.format(\"%-10s\", nullObject), fmt.\"%-10s\\{nullObject}\");\n+        test(String.format(\"%S\", (byte)0xFF), fmt.\"%S\\{(byte)0xFF}\");\n+        test(String.format(\"%S\", (short)0xFFFF), fmt.\"%S\\{(short)0xFFFF}\");\n+        test(String.format(\"%S\", 12345), fmt.\"%S\\{12345}\");\n+        test(String.format(\"%S\", 12345L), fmt.\"%S\\{12345L}\");\n+        test(String.format(\"%S\", 1.33f), fmt.\"%S\\{1.33f}\");\n+        test(String.format(\"%S\", 1.33), fmt.\"%S\\{1.33}\");\n+        test(String.format(\"%S\", \"abcde\"), fmt.\"%S\\{\"abcde\"}\");\n+        test(String.format(\"%S\", nullObject), fmt.\"%S\\{nullObject}\");\n+        test(String.format(\"%10S\", (byte)0xFF), fmt.\"%10S\\{(byte)0xFF}\");\n+        test(String.format(\"%10S\", (short)0xFFFF), fmt.\"%10S\\{(short)0xFFFF}\");\n+        test(String.format(\"%10S\", 12345), fmt.\"%10S\\{12345}\");\n+        test(String.format(\"%10S\", 12345L), fmt.\"%10S\\{12345L}\");\n+        test(String.format(\"%10S\", 1.33f), fmt.\"%10S\\{1.33f}\");\n+        test(String.format(\"%10S\", 1.33), fmt.\"%10S\\{1.33}\");\n+        test(String.format(\"%10S\", \"abcde\"), fmt.\"%10S\\{\"abcde\"}\");\n+        test(String.format(\"%10S\", nullObject), fmt.\"%10S\\{nullObject}\");\n+        test(String.format(\"%-10S\", (byte)0xFF), fmt.\"%-10S\\{(byte)0xFF}\");\n+        test(String.format(\"%-10S\", (short)0xFFFF), fmt.\"%-10S\\{(short)0xFFFF}\");\n+        test(String.format(\"%-10S\", 12345), fmt.\"%-10S\\{12345}\");\n+        test(String.format(\"%-10S\", 12345L), fmt.\"%-10S\\{12345L}\");\n+        test(String.format(\"%-10S\", 1.33f), fmt.\"%-10S\\{1.33f}\");\n+        test(String.format(\"%-10S\", 1.33), fmt.\"%-10S\\{1.33}\");\n+        test(String.format(\"%-10S\", \"abcde\"), fmt.\"%-10S\\{\"abcde\"}\");\n+        test(String.format(\"%-10S\", nullObject), fmt.\"%-10S\\{nullObject}\");\n+\n+        test(String.format(\"%c\", 'a'), fmt.\"%c\\{'a'}\");\n+        test(String.format(\"%10c\", 'a'), fmt.\"%10c\\{'a'}\");\n+        test(String.format(\"%-10c\", 'a'), fmt.\"%-10c\\{'a'}\");\n+        test(String.format(\"%C\", 'a'), fmt.\"%C\\{'a'}\");\n+        test(String.format(\"%10C\", 'a'), fmt.\"%10C\\{'a'}\");\n+        test(String.format(\"%-10C\", 'a'), fmt.\"%-10C\\{'a'}\");\n+\n+        test(String.format(\"%d\", -12345), fmt.\"%d\\{-12345}\");\n+        test(String.format(\"%d\", 0), fmt.\"%d\\{0}\");\n+        test(String.format(\"%d\", 12345), fmt.\"%d\\{12345}\");\n+        test(String.format(\"%10d\", -12345), fmt.\"%10d\\{-12345}\");\n+        test(String.format(\"%10d\", 0), fmt.\"%10d\\{0}\");\n+        test(String.format(\"%10d\", 12345), fmt.\"%10d\\{12345}\");\n+        test(String.format(\"%-10d\", -12345), fmt.\"%-10d\\{-12345}\");\n+        test(String.format(\"%-10d\", 0), fmt.\"%-10d\\{0}\");\n+        test(String.format(\"%-10d\", 12345), fmt.\"%-10d\\{12345}\");\n+        test(String.format(\"%,d\", -12345), fmt.\"%,d\\{-12345}\");\n+        test(String.format(\"%,d\", 0), fmt.\"%,d\\{0}\");\n+        test(String.format(\"%,d\", 12345), fmt.\"%,d\\{12345}\");\n+        test(String.format(\"%,10d\", -12345), fmt.\"%,10d\\{-12345}\");\n+        test(String.format(\"%,10d\", 0), fmt.\"%,10d\\{0}\");\n+        test(String.format(\"%,10d\", 12345), fmt.\"%,10d\\{12345}\");\n+        test(String.format(\"%,-10d\", -12345), fmt.\"%,-10d\\{-12345}\");\n+        test(String.format(\"%,-10d\", 0), fmt.\"%,-10d\\{0}\");\n+        test(String.format(\"%,-10d\", 12345), fmt.\"%,-10d\\{12345}\");\n+        test(String.format(\"%010d\", -12345), fmt.\"%010d\\{-12345}\");\n+        test(String.format(\"%010d\", 0), fmt.\"%010d\\{0}\");\n+        test(String.format(\"%010d\", 12345), fmt.\"%010d\\{12345}\");\n+        test(String.format(\"%,010d\", -12345), fmt.\"%,010d\\{-12345}\");\n+        test(String.format(\"%,010d\", 0), fmt.\"%,010d\\{0}\");\n+        test(String.format(\"%,010d\", 12345), fmt.\"%,010d\\{12345}\");\n+\n+        test(String.format(\"%d\", -12345), fmt.\"%d\\{-12345}\");\n+        test(String.format(\"%d\", 0), fmt.\"%d\\{0}\");\n+        test(String.format(\"%d\", 12345), fmt.\"%d\\{12345}\");\n+        test(String.format(\"%10d\", -12345), fmt.\"%10d\\{-12345}\");\n+        test(String.format(\"%10d\", 0), fmt.\"%10d\\{0}\");\n+        test(String.format(\"%10d\", 12345), fmt.\"%10d\\{12345}\");\n+        test(String.format(\"%-10d\", -12345), fmt.\"%-10d\\{-12345}\");\n+        test(String.format(\"%-10d\", 0), fmt.\"%-10d\\{0}\");\n+        test(String.format(\"%-10d\", 12345), fmt.\"%-10d\\{12345}\");\n+        test(String.format(\"%,d\", -12345), fmt.\"%,d\\{-12345}\");\n+        test(String.format(\"%,d\", 0), fmt.\"%,d\\{0}\");\n+        test(String.format(\"%,d\", 12345), fmt.\"%,d\\{12345}\");\n+        test(String.format(\"%,10d\", -12345), fmt.\"%,10d\\{-12345}\");\n+        test(String.format(\"%,10d\", 0), fmt.\"%,10d\\{0}\");\n+        test(String.format(\"%,10d\", 12345), fmt.\"%,10d\\{12345}\");\n+        test(String.format(\"%,-10d\", -12345), fmt.\"%,-10d\\{-12345}\");\n+        test(String.format(\"%,-10d\", 0), fmt.\"%,-10d\\{0}\");\n+        test(String.format(\"%,-10d\", 12345), fmt.\"%,-10d\\{12345}\");\n+        test(String.format(\"% d\", -12345), fmt.\"% d\\{-12345}\");\n+        test(String.format(\"% d\", 0), fmt.\"% d\\{0}\");\n+        test(String.format(\"% d\", 12345), fmt.\"% d\\{12345}\");\n+        test(String.format(\"% 10d\", -12345), fmt.\"% 10d\\{-12345}\");\n+        test(String.format(\"% 10d\", 0), fmt.\"% 10d\\{0}\");\n+        test(String.format(\"% 10d\", 12345), fmt.\"% 10d\\{12345}\");\n+        test(String.format(\"% -10d\", -12345), fmt.\"% -10d\\{-12345}\");\n+        test(String.format(\"% -10d\", 0), fmt.\"% -10d\\{0}\");\n+        test(String.format(\"% -10d\", 12345), fmt.\"% -10d\\{12345}\");\n+        test(String.format(\"%, d\", -12345), fmt.\"%, d\\{-12345}\");\n+        test(String.format(\"%, d\", 0), fmt.\"%, d\\{0}\");\n+        test(String.format(\"%, d\", 12345), fmt.\"%, d\\{12345}\");\n+        test(String.format(\"%, 10d\", -12345), fmt.\"%, 10d\\{-12345}\");\n+        test(String.format(\"%, 10d\", 0), fmt.\"%, 10d\\{0}\");\n+        test(String.format(\"%, 10d\", 12345), fmt.\"%, 10d\\{12345}\");\n+        test(String.format(\"%, -10d\", -12345), fmt.\"%, -10d\\{-12345}\");\n+        test(String.format(\"%, -10d\", 0), fmt.\"%, -10d\\{0}\");\n+        test(String.format(\"%, -10d\", 12345), fmt.\"%, -10d\\{12345}\");\n+        test(String.format(\"%010d\", -12345), fmt.\"%010d\\{-12345}\");\n+        test(String.format(\"%010d\", 0), fmt.\"%010d\\{0}\");\n+        test(String.format(\"%010d\", 12345), fmt.\"%010d\\{12345}\");\n+        test(String.format(\"%,010d\", -12345), fmt.\"%,010d\\{-12345}\");\n+        test(String.format(\"%,010d\", 0), fmt.\"%,010d\\{0}\");\n+        test(String.format(\"%,010d\", 12345), fmt.\"%,010d\\{12345}\");\n+        test(String.format(\"% 010d\", -12345), fmt.\"% 010d\\{-12345}\");\n+        test(String.format(\"% 010d\", 0), fmt.\"% 010d\\{0}\");\n+        test(String.format(\"% 010d\", 12345), fmt.\"% 010d\\{12345}\");\n+        test(String.format(\"%, 010d\", -12345), fmt.\"%, 010d\\{-12345}\");\n+        test(String.format(\"%, 010d\", 0), fmt.\"%, 010d\\{0}\");\n+        test(String.format(\"%, 010d\", 12345), fmt.\"%, 010d\\{12345}\");\n+\n+        test(String.format(\"%d\", -12345), fmt.\"%d\\{-12345}\");\n+        test(String.format(\"%d\", 0), fmt.\"%d\\{0}\");\n+        test(String.format(\"%d\", 12345), fmt.\"%d\\{12345}\");\n+        test(String.format(\"%10d\", -12345), fmt.\"%10d\\{-12345}\");\n+        test(String.format(\"%10d\", 0), fmt.\"%10d\\{0}\");\n+        test(String.format(\"%10d\", 12345), fmt.\"%10d\\{12345}\");\n+        test(String.format(\"%-10d\", -12345), fmt.\"%-10d\\{-12345}\");\n+        test(String.format(\"%-10d\", 0), fmt.\"%-10d\\{0}\");\n+        test(String.format(\"%-10d\", 12345), fmt.\"%-10d\\{12345}\");\n+        test(String.format(\"%,d\", -12345), fmt.\"%,d\\{-12345}\");\n+        test(String.format(\"%,d\", 0), fmt.\"%,d\\{0}\");\n+        test(String.format(\"%,d\", 12345), fmt.\"%,d\\{12345}\");\n+        test(String.format(\"%,10d\", -12345), fmt.\"%,10d\\{-12345}\");\n+        test(String.format(\"%,10d\", 0), fmt.\"%,10d\\{0}\");\n+        test(String.format(\"%,10d\", 12345), fmt.\"%,10d\\{12345}\");\n+        test(String.format(\"%,-10d\", -12345), fmt.\"%,-10d\\{-12345}\");\n+        test(String.format(\"%,-10d\", 0), fmt.\"%,-10d\\{0}\");\n+        test(String.format(\"%,-10d\", 12345), fmt.\"%,-10d\\{12345}\");\n+        test(String.format(\"%+d\", -12345), fmt.\"%+d\\{-12345}\");\n+        test(String.format(\"%+d\", 0), fmt.\"%+d\\{0}\");\n+        test(String.format(\"%+d\", 12345), fmt.\"%+d\\{12345}\");\n+        test(String.format(\"%+10d\", -12345), fmt.\"%+10d\\{-12345}\");\n+        test(String.format(\"%+10d\", 0), fmt.\"%+10d\\{0}\");\n+        test(String.format(\"%+10d\", 12345), fmt.\"%+10d\\{12345}\");\n+        test(String.format(\"%+-10d\", -12345), fmt.\"%+-10d\\{-12345}\");\n+        test(String.format(\"%+-10d\", 0), fmt.\"%+-10d\\{0}\");\n+        test(String.format(\"%+-10d\", 12345), fmt.\"%+-10d\\{12345}\");\n+        test(String.format(\"%,+d\", -12345), fmt.\"%,+d\\{-12345}\");\n+        test(String.format(\"%,+d\", 0), fmt.\"%,+d\\{0}\");\n+        test(String.format(\"%,+d\", 12345), fmt.\"%,+d\\{12345}\");\n+        test(String.format(\"%,+10d\", -12345), fmt.\"%,+10d\\{-12345}\");\n+        test(String.format(\"%,+10d\", 0), fmt.\"%,+10d\\{0}\");\n+        test(String.format(\"%,+10d\", 12345), fmt.\"%,+10d\\{12345}\");\n+        test(String.format(\"%,+-10d\", -12345), fmt.\"%,+-10d\\{-12345}\");\n+        test(String.format(\"%,+-10d\", 0), fmt.\"%,+-10d\\{0}\");\n+        test(String.format(\"%,+-10d\", 12345), fmt.\"%,+-10d\\{12345}\");\n+        test(String.format(\"%010d\", -12345), fmt.\"%010d\\{-12345}\");\n+        test(String.format(\"%010d\", 0), fmt.\"%010d\\{0}\");\n+        test(String.format(\"%010d\", 12345), fmt.\"%010d\\{12345}\");\n+        test(String.format(\"%,010d\", -12345), fmt.\"%,010d\\{-12345}\");\n+        test(String.format(\"%,010d\", 0), fmt.\"%,010d\\{0}\");\n+        test(String.format(\"%,010d\", 12345), fmt.\"%,010d\\{12345}\");\n+        test(String.format(\"%+010d\", -12345), fmt.\"%+010d\\{-12345}\");\n+        test(String.format(\"%+010d\", 0), fmt.\"%+010d\\{0}\");\n+        test(String.format(\"%+010d\", 12345), fmt.\"%+010d\\{12345}\");\n+        test(String.format(\"%,+010d\", -12345), fmt.\"%,+010d\\{-12345}\");\n+        test(String.format(\"%,+010d\", 0), fmt.\"%,+010d\\{0}\");\n+        test(String.format(\"%,+010d\", 12345), fmt.\"%,+010d\\{12345}\");\n+\n+        test(String.format(\"%d\", -12345), fmt.\"%d\\{-12345}\");\n+        test(String.format(\"%d\", 0), fmt.\"%d\\{0}\");\n+        test(String.format(\"%d\", 12345), fmt.\"%d\\{12345}\");\n+        test(String.format(\"%10d\", -12345), fmt.\"%10d\\{-12345}\");\n+        test(String.format(\"%10d\", 0), fmt.\"%10d\\{0}\");\n+        test(String.format(\"%10d\", 12345), fmt.\"%10d\\{12345}\");\n+        test(String.format(\"%-10d\", -12345), fmt.\"%-10d\\{-12345}\");\n+        test(String.format(\"%-10d\", 0), fmt.\"%-10d\\{0}\");\n+        test(String.format(\"%-10d\", 12345), fmt.\"%-10d\\{12345}\");\n+        test(String.format(\"%,d\", -12345), fmt.\"%,d\\{-12345}\");\n+        test(String.format(\"%,d\", 0), fmt.\"%,d\\{0}\");\n+        test(String.format(\"%,d\", 12345), fmt.\"%,d\\{12345}\");\n+        test(String.format(\"%,10d\", -12345), fmt.\"%,10d\\{-12345}\");\n+        test(String.format(\"%,10d\", 0), fmt.\"%,10d\\{0}\");\n+        test(String.format(\"%,10d\", 12345), fmt.\"%,10d\\{12345}\");\n+        test(String.format(\"%,-10d\", -12345), fmt.\"%,-10d\\{-12345}\");\n+        test(String.format(\"%,-10d\", 0), fmt.\"%,-10d\\{0}\");\n+        test(String.format(\"%,-10d\", 12345), fmt.\"%,-10d\\{12345}\");\n+        test(String.format(\"%(d\", -12345), fmt.\"%(d\\{-12345}\");\n+        test(String.format(\"%(d\", 0), fmt.\"%(d\\{0}\");\n+        test(String.format(\"%(d\", 12345), fmt.\"%(d\\{12345}\");\n+        test(String.format(\"%(10d\", -12345), fmt.\"%(10d\\{-12345}\");\n+        test(String.format(\"%(10d\", 0), fmt.\"%(10d\\{0}\");\n+        test(String.format(\"%(10d\", 12345), fmt.\"%(10d\\{12345}\");\n+        test(String.format(\"%(-10d\", -12345), fmt.\"%(-10d\\{-12345}\");\n+        test(String.format(\"%(-10d\", 0), fmt.\"%(-10d\\{0}\");\n+        test(String.format(\"%(-10d\", 12345), fmt.\"%(-10d\\{12345}\");\n+        test(String.format(\"%,(d\", -12345), fmt.\"%,(d\\{-12345}\");\n+        test(String.format(\"%,(d\", 0), fmt.\"%,(d\\{0}\");\n+        test(String.format(\"%,(d\", 12345), fmt.\"%,(d\\{12345}\");\n+        test(String.format(\"%,(10d\", -12345), fmt.\"%,(10d\\{-12345}\");\n+        test(String.format(\"%,(10d\", 0), fmt.\"%,(10d\\{0}\");\n+        test(String.format(\"%,(10d\", 12345), fmt.\"%,(10d\\{12345}\");\n+        test(String.format(\"%,(-10d\", -12345), fmt.\"%,(-10d\\{-12345}\");\n+        test(String.format(\"%,(-10d\", 0), fmt.\"%,(-10d\\{0}\");\n+        test(String.format(\"%,(-10d\", 12345), fmt.\"%,(-10d\\{12345}\");\n+        test(String.format(\"%010d\", -12345), fmt.\"%010d\\{-12345}\");\n+        test(String.format(\"%010d\", 0), fmt.\"%010d\\{0}\");\n+        test(String.format(\"%010d\", 12345), fmt.\"%010d\\{12345}\");\n+        test(String.format(\"%,010d\", -12345), fmt.\"%,010d\\{-12345}\");\n+        test(String.format(\"%,010d\", 0), fmt.\"%,010d\\{0}\");\n+        test(String.format(\"%,010d\", 12345), fmt.\"%,010d\\{12345}\");\n+        test(String.format(\"%(010d\", -12345), fmt.\"%(010d\\{-12345}\");\n+        test(String.format(\"%(010d\", 0), fmt.\"%(010d\\{0}\");\n+        test(String.format(\"%(010d\", 12345), fmt.\"%(010d\\{12345}\");\n+        test(String.format(\"%,(010d\", -12345), fmt.\"%,(010d\\{-12345}\");\n+        test(String.format(\"%,(010d\", 0), fmt.\"%,(010d\\{0}\");\n+        test(String.format(\"%,(010d\", 12345), fmt.\"%,(010d\\{12345}\");\n+\n+        test(String.format(\"%o\", -12345), fmt.\"%o\\{-12345}\");\n+        test(String.format(\"%o\", 0), fmt.\"%o\\{0}\");\n+        test(String.format(\"%o\", 12345), fmt.\"%o\\{12345}\");\n+        test(String.format(\"%10o\", -12345), fmt.\"%10o\\{-12345}\");\n+        test(String.format(\"%10o\", 0), fmt.\"%10o\\{0}\");\n+        test(String.format(\"%10o\", 12345), fmt.\"%10o\\{12345}\");\n+        test(String.format(\"%-10o\", -12345), fmt.\"%-10o\\{-12345}\");\n+        test(String.format(\"%-10o\", 0), fmt.\"%-10o\\{0}\");\n+        test(String.format(\"%-10o\", 12345), fmt.\"%-10o\\{12345}\");\n+        test(String.format(\"%#o\", -12345), fmt.\"%#o\\{-12345}\");\n+        test(String.format(\"%#o\", 0), fmt.\"%#o\\{0}\");\n+        test(String.format(\"%#o\", 12345), fmt.\"%#o\\{12345}\");\n+        test(String.format(\"%#10o\", -12345), fmt.\"%#10o\\{-12345}\");\n+        test(String.format(\"%#10o\", 0), fmt.\"%#10o\\{0}\");\n+        test(String.format(\"%#10o\", 12345), fmt.\"%#10o\\{12345}\");\n+        test(String.format(\"%#-10o\", -12345), fmt.\"%#-10o\\{-12345}\");\n+        test(String.format(\"%#-10o\", 0), fmt.\"%#-10o\\{0}\");\n+        test(String.format(\"%#-10o\", 12345), fmt.\"%#-10o\\{12345}\");\n+        test(String.format(\"%010o\", -12345), fmt.\"%010o\\{-12345}\");\n+        test(String.format(\"%010o\", 0), fmt.\"%010o\\{0}\");\n+        test(String.format(\"%010o\", 12345), fmt.\"%010o\\{12345}\");\n+        test(String.format(\"%#010o\", -12345), fmt.\"%#010o\\{-12345}\");\n+        test(String.format(\"%#010o\", 0), fmt.\"%#010o\\{0}\");\n+        test(String.format(\"%#010o\", 12345), fmt.\"%#010o\\{12345}\");\n+\n+        test(String.format(\"%x\", -12345), fmt.\"%x\\{-12345}\");\n+        test(String.format(\"%x\", 0), fmt.\"%x\\{0}\");\n+        test(String.format(\"%x\", 12345), fmt.\"%x\\{12345}\");\n+        test(String.format(\"%10x\", -12345), fmt.\"%10x\\{-12345}\");\n+        test(String.format(\"%10x\", 0), fmt.\"%10x\\{0}\");\n+        test(String.format(\"%10x\", 12345), fmt.\"%10x\\{12345}\");\n+        test(String.format(\"%-10x\", -12345), fmt.\"%-10x\\{-12345}\");\n+        test(String.format(\"%-10x\", 0), fmt.\"%-10x\\{0}\");\n+        test(String.format(\"%-10x\", 12345), fmt.\"%-10x\\{12345}\");\n+        test(String.format(\"%X\", -12345), fmt.\"%X\\{-12345}\");\n+        test(String.format(\"%X\", 0), fmt.\"%X\\{0}\");\n+        test(String.format(\"%X\", 12345), fmt.\"%X\\{12345}\");\n+        test(String.format(\"%10X\", -12345), fmt.\"%10X\\{-12345}\");\n+        test(String.format(\"%10X\", 0), fmt.\"%10X\\{0}\");\n+        test(String.format(\"%10X\", 12345), fmt.\"%10X\\{12345}\");\n+        test(String.format(\"%-10X\", -12345), fmt.\"%-10X\\{-12345}\");\n+        test(String.format(\"%-10X\", 0), fmt.\"%-10X\\{0}\");\n+        test(String.format(\"%-10X\", 12345), fmt.\"%-10X\\{12345}\");\n+        test(String.format(\"%#x\", -12345), fmt.\"%#x\\{-12345}\");\n+        test(String.format(\"%#x\", 0), fmt.\"%#x\\{0}\");\n+        test(String.format(\"%#x\", 12345), fmt.\"%#x\\{12345}\");\n+        test(String.format(\"%#10x\", -12345), fmt.\"%#10x\\{-12345}\");\n+        test(String.format(\"%#10x\", 0), fmt.\"%#10x\\{0}\");\n+        test(String.format(\"%#10x\", 12345), fmt.\"%#10x\\{12345}\");\n+        test(String.format(\"%#-10x\", -12345), fmt.\"%#-10x\\{-12345}\");\n+        test(String.format(\"%#-10x\", 0), fmt.\"%#-10x\\{0}\");\n+        test(String.format(\"%#-10x\", 12345), fmt.\"%#-10x\\{12345}\");\n+        test(String.format(\"%#X\", -12345), fmt.\"%#X\\{-12345}\");\n+        test(String.format(\"%#X\", 0), fmt.\"%#X\\{0}\");\n+        test(String.format(\"%#X\", 12345), fmt.\"%#X\\{12345}\");\n+        test(String.format(\"%#10X\", -12345), fmt.\"%#10X\\{-12345}\");\n+        test(String.format(\"%#10X\", 0), fmt.\"%#10X\\{0}\");\n+        test(String.format(\"%#10X\", 12345), fmt.\"%#10X\\{12345}\");\n+        test(String.format(\"%#-10X\", -12345), fmt.\"%#-10X\\{-12345}\");\n+        test(String.format(\"%#-10X\", 0), fmt.\"%#-10X\\{0}\");\n+        test(String.format(\"%#-10X\", 12345), fmt.\"%#-10X\\{12345}\");\n+        test(String.format(\"%010x\", -12345), fmt.\"%010x\\{-12345}\");\n+        test(String.format(\"%010x\", 0), fmt.\"%010x\\{0}\");\n+        test(String.format(\"%010x\", 12345), fmt.\"%010x\\{12345}\");\n+        test(String.format(\"%010X\", -12345), fmt.\"%010X\\{-12345}\");\n+        test(String.format(\"%010X\", 0), fmt.\"%010X\\{0}\");\n+        test(String.format(\"%010X\", 12345), fmt.\"%010X\\{12345}\");\n+        test(String.format(\"%#010x\", -12345), fmt.\"%#010x\\{-12345}\");\n+        test(String.format(\"%#010x\", 0), fmt.\"%#010x\\{0}\");\n+        test(String.format(\"%#010x\", 12345), fmt.\"%#010x\\{12345}\");\n+        test(String.format(\"%#010X\", -12345), fmt.\"%#010X\\{-12345}\");\n+        test(String.format(\"%#010X\", 0), fmt.\"%#010X\\{0}\");\n+        test(String.format(\"%#010X\", 12345), fmt.\"%#010X\\{12345}\");\n+\n+        test(String.format(\"%f\", -12345.6), fmt.\"%f\\{-12345.6}\");\n+        test(String.format(\"%f\", 0.0), fmt.\"%f\\{0.0}\");\n+        test(String.format(\"%f\", 12345.6), fmt.\"%f\\{12345.6}\");\n+        test(String.format(\"%10f\", -12345.6), fmt.\"%10f\\{-12345.6}\");\n+        test(String.format(\"%10f\", 0.0), fmt.\"%10f\\{0.0}\");\n+        test(String.format(\"%10f\", 12345.6), fmt.\"%10f\\{12345.6}\");\n+        test(String.format(\"%-10f\", -12345.6), fmt.\"%-10f\\{-12345.6}\");\n+        test(String.format(\"%-10f\", 0.0), fmt.\"%-10f\\{0.0}\");\n+        test(String.format(\"%-10f\", 12345.6), fmt.\"%-10f\\{12345.6}\");\n+        test(String.format(\"%,f\", -12345.6), fmt.\"%,f\\{-12345.6}\");\n+        test(String.format(\"%,f\", 0.0), fmt.\"%,f\\{0.0}\");\n+        test(String.format(\"%,f\", 12345.6), fmt.\"%,f\\{12345.6}\");\n+        test(String.format(\"%,10f\", -12345.6), fmt.\"%,10f\\{-12345.6}\");\n+        test(String.format(\"%,10f\", 0.0), fmt.\"%,10f\\{0.0}\");\n+        test(String.format(\"%,10f\", 12345.6), fmt.\"%,10f\\{12345.6}\");\n+        test(String.format(\"%,-10f\", -12345.6), fmt.\"%,-10f\\{-12345.6}\");\n+        test(String.format(\"%,-10f\", 0.0), fmt.\"%,-10f\\{0.0}\");\n+        test(String.format(\"%,-10f\", 12345.6), fmt.\"%,-10f\\{12345.6}\");\n+\n+        test(String.format(\"%f\", -12345.6), fmt.\"%f\\{-12345.6}\");\n+        test(String.format(\"%f\", 0.0), fmt.\"%f\\{0.0}\");\n+        test(String.format(\"%f\", 12345.6), fmt.\"%f\\{12345.6}\");\n+        test(String.format(\"%10f\", -12345.6), fmt.\"%10f\\{-12345.6}\");\n+        test(String.format(\"%10f\", 0.0), fmt.\"%10f\\{0.0}\");\n+        test(String.format(\"%10f\", 12345.6), fmt.\"%10f\\{12345.6}\");\n+        test(String.format(\"%-10f\", -12345.6), fmt.\"%-10f\\{-12345.6}\");\n+        test(String.format(\"%-10f\", 0.0), fmt.\"%-10f\\{0.0}\");\n+        test(String.format(\"%-10f\", 12345.6), fmt.\"%-10f\\{12345.6}\");\n+        test(String.format(\"%,f\", -12345.6), fmt.\"%,f\\{-12345.6}\");\n+        test(String.format(\"%,f\", 0.0), fmt.\"%,f\\{0.0}\");\n+        test(String.format(\"%,f\", 12345.6), fmt.\"%,f\\{12345.6}\");\n+        test(String.format(\"%,10f\", -12345.6), fmt.\"%,10f\\{-12345.6}\");\n+        test(String.format(\"%,10f\", 0.0), fmt.\"%,10f\\{0.0}\");\n+        test(String.format(\"%,10f\", 12345.6), fmt.\"%,10f\\{12345.6}\");\n+        test(String.format(\"%,-10f\", -12345.6), fmt.\"%,-10f\\{-12345.6}\");\n+        test(String.format(\"%,-10f\", 0.0), fmt.\"%,-10f\\{0.0}\");\n+        test(String.format(\"%,-10f\", 12345.6), fmt.\"%,-10f\\{12345.6}\");\n+        test(String.format(\"% f\", -12345.6), fmt.\"% f\\{-12345.6}\");\n+        test(String.format(\"% f\", 0.0), fmt.\"% f\\{0.0}\");\n+        test(String.format(\"% f\", 12345.6), fmt.\"% f\\{12345.6}\");\n+        test(String.format(\"% 10f\", -12345.6), fmt.\"% 10f\\{-12345.6}\");\n+        test(String.format(\"% 10f\", 0.0), fmt.\"% 10f\\{0.0}\");\n+        test(String.format(\"% 10f\", 12345.6), fmt.\"% 10f\\{12345.6}\");\n+        test(String.format(\"% -10f\", -12345.6), fmt.\"% -10f\\{-12345.6}\");\n+        test(String.format(\"% -10f\", 0.0), fmt.\"% -10f\\{0.0}\");\n+        test(String.format(\"% -10f\", 12345.6), fmt.\"% -10f\\{12345.6}\");\n+        test(String.format(\"%, f\", -12345.6), fmt.\"%, f\\{-12345.6}\");\n+        test(String.format(\"%, f\", 0.0), fmt.\"%, f\\{0.0}\");\n+        test(String.format(\"%, f\", 12345.6), fmt.\"%, f\\{12345.6}\");\n+        test(String.format(\"%, 10f\", -12345.6), fmt.\"%, 10f\\{-12345.6}\");\n+        test(String.format(\"%, 10f\", 0.0), fmt.\"%, 10f\\{0.0}\");\n+        test(String.format(\"%, 10f\", 12345.6), fmt.\"%, 10f\\{12345.6}\");\n+        test(String.format(\"%, -10f\", -12345.6), fmt.\"%, -10f\\{-12345.6}\");\n+        test(String.format(\"%, -10f\", 0.0), fmt.\"%, -10f\\{0.0}\");\n+        test(String.format(\"%, -10f\", 12345.6), fmt.\"%, -10f\\{12345.6}\");\n+\n+        test(String.format(\"%f\", -12345.6), fmt.\"%f\\{-12345.6}\");\n+        test(String.format(\"%f\", 0.0), fmt.\"%f\\{0.0}\");\n+        test(String.format(\"%f\", 12345.6), fmt.\"%f\\{12345.6}\");\n+        test(String.format(\"%10f\", -12345.6), fmt.\"%10f\\{-12345.6}\");\n+        test(String.format(\"%10f\", 0.0), fmt.\"%10f\\{0.0}\");\n+        test(String.format(\"%10f\", 12345.6), fmt.\"%10f\\{12345.6}\");\n+        test(String.format(\"%-10f\", -12345.6), fmt.\"%-10f\\{-12345.6}\");\n+        test(String.format(\"%-10f\", 0.0), fmt.\"%-10f\\{0.0}\");\n+        test(String.format(\"%-10f\", 12345.6), fmt.\"%-10f\\{12345.6}\");\n+        test(String.format(\"%,f\", -12345.6), fmt.\"%,f\\{-12345.6}\");\n+        test(String.format(\"%,f\", 0.0), fmt.\"%,f\\{0.0}\");\n+        test(String.format(\"%,f\", 12345.6), fmt.\"%,f\\{12345.6}\");\n+        test(String.format(\"%,10f\", -12345.6), fmt.\"%,10f\\{-12345.6}\");\n+        test(String.format(\"%,10f\", 0.0), fmt.\"%,10f\\{0.0}\");\n+        test(String.format(\"%,10f\", 12345.6), fmt.\"%,10f\\{12345.6}\");\n+        test(String.format(\"%,-10f\", -12345.6), fmt.\"%,-10f\\{-12345.6}\");\n+        test(String.format(\"%,-10f\", 0.0), fmt.\"%,-10f\\{0.0}\");\n+        test(String.format(\"%,-10f\", 12345.6), fmt.\"%,-10f\\{12345.6}\");\n+        test(String.format(\"%+f\", -12345.6), fmt.\"%+f\\{-12345.6}\");\n+        test(String.format(\"%+f\", 0.0), fmt.\"%+f\\{0.0}\");\n+        test(String.format(\"%+f\", 12345.6), fmt.\"%+f\\{12345.6}\");\n+        test(String.format(\"%+10f\", -12345.6), fmt.\"%+10f\\{-12345.6}\");\n+        test(String.format(\"%+10f\", 0.0), fmt.\"%+10f\\{0.0}\");\n+        test(String.format(\"%+10f\", 12345.6), fmt.\"%+10f\\{12345.6}\");\n+        test(String.format(\"%+-10f\", -12345.6), fmt.\"%+-10f\\{-12345.6}\");\n+        test(String.format(\"%+-10f\", 0.0), fmt.\"%+-10f\\{0.0}\");\n+        test(String.format(\"%+-10f\", 12345.6), fmt.\"%+-10f\\{12345.6}\");\n+        test(String.format(\"%,+f\", -12345.6), fmt.\"%,+f\\{-12345.6}\");\n+        test(String.format(\"%,+f\", 0.0), fmt.\"%,+f\\{0.0}\");\n+        test(String.format(\"%,+f\", 12345.6), fmt.\"%,+f\\{12345.6}\");\n+        test(String.format(\"%,+10f\", -12345.6), fmt.\"%,+10f\\{-12345.6}\");\n+        test(String.format(\"%,+10f\", 0.0), fmt.\"%,+10f\\{0.0}\");\n+        test(String.format(\"%,+10f\", 12345.6), fmt.\"%,+10f\\{12345.6}\");\n+        test(String.format(\"%,+-10f\", -12345.6), fmt.\"%,+-10f\\{-12345.6}\");\n+        test(String.format(\"%,+-10f\", 0.0), fmt.\"%,+-10f\\{0.0}\");\n+        test(String.format(\"%,+-10f\", 12345.6), fmt.\"%,+-10f\\{12345.6}\");\n+\n+        test(String.format(\"%f\", -12345.6), fmt.\"%f\\{-12345.6}\");\n+        test(String.format(\"%f\", 0.0), fmt.\"%f\\{0.0}\");\n+        test(String.format(\"%f\", 12345.6), fmt.\"%f\\{12345.6}\");\n+        test(String.format(\"%10f\", -12345.6), fmt.\"%10f\\{-12345.6}\");\n+        test(String.format(\"%10f\", 0.0), fmt.\"%10f\\{0.0}\");\n+        test(String.format(\"%10f\", 12345.6), fmt.\"%10f\\{12345.6}\");\n+        test(String.format(\"%-10f\", -12345.6), fmt.\"%-10f\\{-12345.6}\");\n+        test(String.format(\"%-10f\", 0.0), fmt.\"%-10f\\{0.0}\");\n+        test(String.format(\"%-10f\", 12345.6), fmt.\"%-10f\\{12345.6}\");\n+        test(String.format(\"%,f\", -12345.6), fmt.\"%,f\\{-12345.6}\");\n+        test(String.format(\"%,f\", 0.0), fmt.\"%,f\\{0.0}\");\n+        test(String.format(\"%,f\", 12345.6), fmt.\"%,f\\{12345.6}\");\n+        test(String.format(\"%,10f\", -12345.6), fmt.\"%,10f\\{-12345.6}\");\n+        test(String.format(\"%,10f\", 0.0), fmt.\"%,10f\\{0.0}\");\n+        test(String.format(\"%,10f\", 12345.6), fmt.\"%,10f\\{12345.6}\");\n+        test(String.format(\"%,-10f\", -12345.6), fmt.\"%,-10f\\{-12345.6}\");\n+        test(String.format(\"%,-10f\", 0.0), fmt.\"%,-10f\\{0.0}\");\n+        test(String.format(\"%,-10f\", 12345.6), fmt.\"%,-10f\\{12345.6}\");\n+        test(String.format(\"%(f\", -12345.6), fmt.\"%(f\\{-12345.6}\");\n+        test(String.format(\"%(f\", 0.0), fmt.\"%(f\\{0.0}\");\n+        test(String.format(\"%(f\", 12345.6), fmt.\"%(f\\{12345.6}\");\n+        test(String.format(\"%(10f\", -12345.6), fmt.\"%(10f\\{-12345.6}\");\n+        test(String.format(\"%(10f\", 0.0), fmt.\"%(10f\\{0.0}\");\n+        test(String.format(\"%(10f\", 12345.6), fmt.\"%(10f\\{12345.6}\");\n+        test(String.format(\"%(-10f\", -12345.6), fmt.\"%(-10f\\{-12345.6}\");\n+        test(String.format(\"%(-10f\", 0.0), fmt.\"%(-10f\\{0.0}\");\n+        test(String.format(\"%(-10f\", 12345.6), fmt.\"%(-10f\\{12345.6}\");\n+        test(String.format(\"%,(f\", -12345.6), fmt.\"%,(f\\{-12345.6}\");\n+        test(String.format(\"%,(f\", 0.0), fmt.\"%,(f\\{0.0}\");\n+        test(String.format(\"%,(f\", 12345.6), fmt.\"%,(f\\{12345.6}\");\n+        test(String.format(\"%,(10f\", -12345.6), fmt.\"%,(10f\\{-12345.6}\");\n+        test(String.format(\"%,(10f\", 0.0), fmt.\"%,(10f\\{0.0}\");\n+        test(String.format(\"%,(10f\", 12345.6), fmt.\"%,(10f\\{12345.6}\");\n+        test(String.format(\"%,(-10f\", -12345.6), fmt.\"%,(-10f\\{-12345.6}\");\n+        test(String.format(\"%,(-10f\", 0.0), fmt.\"%,(-10f\\{0.0}\");\n+        test(String.format(\"%,(-10f\", 12345.6), fmt.\"%,(-10f\\{12345.6}\");\n+        test(String.format(\"%+f\", -12345.6), fmt.\"%+f\\{-12345.6}\");\n+        test(String.format(\"%+f\", 0.0), fmt.\"%+f\\{0.0}\");\n+        test(String.format(\"%+f\", 12345.6), fmt.\"%+f\\{12345.6}\");\n+        test(String.format(\"%+10f\", -12345.6), fmt.\"%+10f\\{-12345.6}\");\n+        test(String.format(\"%+10f\", 0.0), fmt.\"%+10f\\{0.0}\");\n+        test(String.format(\"%+10f\", 12345.6), fmt.\"%+10f\\{12345.6}\");\n+        test(String.format(\"%+-10f\", -12345.6), fmt.\"%+-10f\\{-12345.6}\");\n+        test(String.format(\"%+-10f\", 0.0), fmt.\"%+-10f\\{0.0}\");\n+        test(String.format(\"%+-10f\", 12345.6), fmt.\"%+-10f\\{12345.6}\");\n+        test(String.format(\"%,+f\", -12345.6), fmt.\"%,+f\\{-12345.6}\");\n+        test(String.format(\"%,+f\", 0.0), fmt.\"%,+f\\{0.0}\");\n+        test(String.format(\"%,+f\", 12345.6), fmt.\"%,+f\\{12345.6}\");\n+        test(String.format(\"%,+10f\", -12345.6), fmt.\"%,+10f\\{-12345.6}\");\n+        test(String.format(\"%,+10f\", 0.0), fmt.\"%,+10f\\{0.0}\");\n+        test(String.format(\"%,+10f\", 12345.6), fmt.\"%,+10f\\{12345.6}\");\n+        test(String.format(\"%,+-10f\", -12345.6), fmt.\"%,+-10f\\{-12345.6}\");\n+        test(String.format(\"%,+-10f\", 0.0), fmt.\"%,+-10f\\{0.0}\");\n+        test(String.format(\"%,+-10f\", 12345.6), fmt.\"%,+-10f\\{12345.6}\");\n+        test(String.format(\"%(+f\", -12345.6), fmt.\"%(+f\\{-12345.6}\");\n+        test(String.format(\"%(+f\", 0.0), fmt.\"%(+f\\{0.0}\");\n+        test(String.format(\"%(+f\", 12345.6), fmt.\"%(+f\\{12345.6}\");\n+        test(String.format(\"%(+10f\", -12345.6), fmt.\"%(+10f\\{-12345.6}\");\n+        test(String.format(\"%(+10f\", 0.0), fmt.\"%(+10f\\{0.0}\");\n+        test(String.format(\"%(+10f\", 12345.6), fmt.\"%(+10f\\{12345.6}\");\n+        test(String.format(\"%(+-10f\", -12345.6), fmt.\"%(+-10f\\{-12345.6}\");\n+        test(String.format(\"%(+-10f\", 0.0), fmt.\"%(+-10f\\{0.0}\");\n+        test(String.format(\"%(+-10f\", 12345.6), fmt.\"%(+-10f\\{12345.6}\");\n+        test(String.format(\"%,(+f\", -12345.6), fmt.\"%,(+f\\{-12345.6}\");\n+        test(String.format(\"%,(+f\", 0.0), fmt.\"%,(+f\\{0.0}\");\n+        test(String.format(\"%,(+f\", 12345.6), fmt.\"%,(+f\\{12345.6}\");\n+        test(String.format(\"%,(+10f\", -12345.6), fmt.\"%,(+10f\\{-12345.6}\");\n+        test(String.format(\"%,(+10f\", 0.0), fmt.\"%,(+10f\\{0.0}\");\n+        test(String.format(\"%,(+10f\", 12345.6), fmt.\"%,(+10f\\{12345.6}\");\n+        test(String.format(\"%,(+-10f\", -12345.6), fmt.\"%,(+-10f\\{-12345.6}\");\n+        test(String.format(\"%,(+-10f\", 0.0), fmt.\"%,(+-10f\\{0.0}\");\n+        test(String.format(\"%,(+-10f\", 12345.6), fmt.\"%,(+-10f\\{12345.6}\");\n+\n+        test(String.format(\"%e\", -12345.6), fmt.\"%e\\{-12345.6}\");\n+        test(String.format(\"%e\", 0.0), fmt.\"%e\\{0.0}\");\n+        test(String.format(\"%e\", 12345.6), fmt.\"%e\\{12345.6}\");\n+        test(String.format(\"%10e\", -12345.6), fmt.\"%10e\\{-12345.6}\");\n+        test(String.format(\"%10e\", 0.0), fmt.\"%10e\\{0.0}\");\n+        test(String.format(\"%10e\", 12345.6), fmt.\"%10e\\{12345.6}\");\n+        test(String.format(\"%-10e\", -12345.6), fmt.\"%-10e\\{-12345.6}\");\n+        test(String.format(\"%-10e\", 0.0), fmt.\"%-10e\\{0.0}\");\n+        test(String.format(\"%-10e\", 12345.6), fmt.\"%-10e\\{12345.6}\");\n+        test(String.format(\"%E\", -12345.6), fmt.\"%E\\{-12345.6}\");\n+        test(String.format(\"%E\", 0.0), fmt.\"%E\\{0.0}\");\n+        test(String.format(\"%E\", 12345.6), fmt.\"%E\\{12345.6}\");\n+        test(String.format(\"%10E\", -12345.6), fmt.\"%10E\\{-12345.6}\");\n+        test(String.format(\"%10E\", 0.0), fmt.\"%10E\\{0.0}\");\n+        test(String.format(\"%10E\", 12345.6), fmt.\"%10E\\{12345.6}\");\n+        test(String.format(\"%-10E\", -12345.6), fmt.\"%-10E\\{-12345.6}\");\n+        test(String.format(\"%-10E\", 0.0), fmt.\"%-10E\\{0.0}\");\n+        test(String.format(\"%-10E\", 12345.6), fmt.\"%-10E\\{12345.6}\");\n+\n+        test(String.format(\"%g\", -12345.6), fmt.\"%g\\{-12345.6}\");\n+        test(String.format(\"%g\", 0.0), fmt.\"%g\\{0.0}\");\n+        test(String.format(\"%g\", 12345.6), fmt.\"%g\\{12345.6}\");\n+        test(String.format(\"%10g\", -12345.6), fmt.\"%10g\\{-12345.6}\");\n+        test(String.format(\"%10g\", 0.0), fmt.\"%10g\\{0.0}\");\n+        test(String.format(\"%10g\", 12345.6), fmt.\"%10g\\{12345.6}\");\n+        test(String.format(\"%-10g\", -12345.6), fmt.\"%-10g\\{-12345.6}\");\n+        test(String.format(\"%-10g\", 0.0), fmt.\"%-10g\\{0.0}\");\n+        test(String.format(\"%-10g\", 12345.6), fmt.\"%-10g\\{12345.6}\");\n+        test(String.format(\"%G\", -12345.6), fmt.\"%G\\{-12345.6}\");\n+        test(String.format(\"%G\", 0.0), fmt.\"%G\\{0.0}\");\n+        test(String.format(\"%G\", 12345.6), fmt.\"%G\\{12345.6}\");\n+        test(String.format(\"%10G\", -12345.6), fmt.\"%10G\\{-12345.6}\");\n+        test(String.format(\"%10G\", 0.0), fmt.\"%10G\\{0.0}\");\n+        test(String.format(\"%10G\", 12345.6), fmt.\"%10G\\{12345.6}\");\n+        test(String.format(\"%-10G\", -12345.6), fmt.\"%-10G\\{-12345.6}\");\n+        test(String.format(\"%-10G\", 0.0), fmt.\"%-10G\\{0.0}\");\n+        test(String.format(\"%-10G\", 12345.6), fmt.\"%-10G\\{12345.6}\");\n+        test(String.format(\"%,g\", -12345.6), fmt.\"%,g\\{-12345.6}\");\n+        test(String.format(\"%,g\", 0.0), fmt.\"%,g\\{0.0}\");\n+        test(String.format(\"%,g\", 12345.6), fmt.\"%,g\\{12345.6}\");\n+        test(String.format(\"%,10g\", -12345.6), fmt.\"%,10g\\{-12345.6}\");\n+        test(String.format(\"%,10g\", 0.0), fmt.\"%,10g\\{0.0}\");\n+        test(String.format(\"%,10g\", 12345.6), fmt.\"%,10g\\{12345.6}\");\n+        test(String.format(\"%,-10g\", -12345.6), fmt.\"%,-10g\\{-12345.6}\");\n+        test(String.format(\"%,-10g\", 0.0), fmt.\"%,-10g\\{0.0}\");\n+        test(String.format(\"%,-10g\", 12345.6), fmt.\"%,-10g\\{12345.6}\");\n+        test(String.format(\"%,G\", -12345.6), fmt.\"%,G\\{-12345.6}\");\n+        test(String.format(\"%,G\", 0.0), fmt.\"%,G\\{0.0}\");\n+        test(String.format(\"%,G\", 12345.6), fmt.\"%,G\\{12345.6}\");\n+        test(String.format(\"%,10G\", -12345.6), fmt.\"%,10G\\{-12345.6}\");\n+        test(String.format(\"%,10G\", 0.0), fmt.\"%,10G\\{0.0}\");\n+        test(String.format(\"%,10G\", 12345.6), fmt.\"%,10G\\{12345.6}\");\n+        test(String.format(\"%,-10G\", -12345.6), fmt.\"%,-10G\\{-12345.6}\");\n+        test(String.format(\"%,-10G\", 0.0), fmt.\"%,-10G\\{0.0}\");\n+        test(String.format(\"%,-10G\", 12345.6), fmt.\"%,-10G\\{12345.6}\");\n+\n+        test(String.format(\"%g\", -12345.6), fmt.\"%g\\{-12345.6}\");\n+        test(String.format(\"%g\", 0.0), fmt.\"%g\\{0.0}\");\n+        test(String.format(\"%g\", 12345.6), fmt.\"%g\\{12345.6}\");\n+        test(String.format(\"%10g\", -12345.6), fmt.\"%10g\\{-12345.6}\");\n+        test(String.format(\"%10g\", 0.0), fmt.\"%10g\\{0.0}\");\n+        test(String.format(\"%10g\", 12345.6), fmt.\"%10g\\{12345.6}\");\n+        test(String.format(\"%-10g\", -12345.6), fmt.\"%-10g\\{-12345.6}\");\n+        test(String.format(\"%-10g\", 0.0), fmt.\"%-10g\\{0.0}\");\n+        test(String.format(\"%-10g\", 12345.6), fmt.\"%-10g\\{12345.6}\");\n+        test(String.format(\"%G\", -12345.6), fmt.\"%G\\{-12345.6}\");\n+        test(String.format(\"%G\", 0.0), fmt.\"%G\\{0.0}\");\n+        test(String.format(\"%G\", 12345.6), fmt.\"%G\\{12345.6}\");\n+        test(String.format(\"%10G\", -12345.6), fmt.\"%10G\\{-12345.6}\");\n+        test(String.format(\"%10G\", 0.0), fmt.\"%10G\\{0.0}\");\n+        test(String.format(\"%10G\", 12345.6), fmt.\"%10G\\{12345.6}\");\n+        test(String.format(\"%-10G\", -12345.6), fmt.\"%-10G\\{-12345.6}\");\n+        test(String.format(\"%-10G\", 0.0), fmt.\"%-10G\\{0.0}\");\n+        test(String.format(\"%-10G\", 12345.6), fmt.\"%-10G\\{12345.6}\");\n+        test(String.format(\"%,g\", -12345.6), fmt.\"%,g\\{-12345.6}\");\n+        test(String.format(\"%,g\", 0.0), fmt.\"%,g\\{0.0}\");\n+        test(String.format(\"%,g\", 12345.6), fmt.\"%,g\\{12345.6}\");\n+        test(String.format(\"%,10g\", -12345.6), fmt.\"%,10g\\{-12345.6}\");\n+        test(String.format(\"%,10g\", 0.0), fmt.\"%,10g\\{0.0}\");\n+        test(String.format(\"%,10g\", 12345.6), fmt.\"%,10g\\{12345.6}\");\n+        test(String.format(\"%,-10g\", -12345.6), fmt.\"%,-10g\\{-12345.6}\");\n+        test(String.format(\"%,-10g\", 0.0), fmt.\"%,-10g\\{0.0}\");\n+        test(String.format(\"%,-10g\", 12345.6), fmt.\"%,-10g\\{12345.6}\");\n+        test(String.format(\"%,G\", -12345.6), fmt.\"%,G\\{-12345.6}\");\n+        test(String.format(\"%,G\", 0.0), fmt.\"%,G\\{0.0}\");\n+        test(String.format(\"%,G\", 12345.6), fmt.\"%,G\\{12345.6}\");\n+        test(String.format(\"%,10G\", -12345.6), fmt.\"%,10G\\{-12345.6}\");\n+        test(String.format(\"%,10G\", 0.0), fmt.\"%,10G\\{0.0}\");\n+        test(String.format(\"%,10G\", 12345.6), fmt.\"%,10G\\{12345.6}\");\n+        test(String.format(\"%,-10G\", -12345.6), fmt.\"%,-10G\\{-12345.6}\");\n+        test(String.format(\"%,-10G\", 0.0), fmt.\"%,-10G\\{0.0}\");\n+        test(String.format(\"%,-10G\", 12345.6), fmt.\"%,-10G\\{12345.6}\");\n+        test(String.format(\"% g\", -12345.6), fmt.\"% g\\{-12345.6}\");\n+        test(String.format(\"% g\", 0.0), fmt.\"% g\\{0.0}\");\n+        test(String.format(\"% g\", 12345.6), fmt.\"% g\\{12345.6}\");\n+        test(String.format(\"% 10g\", -12345.6), fmt.\"% 10g\\{-12345.6}\");\n+        test(String.format(\"% 10g\", 0.0), fmt.\"% 10g\\{0.0}\");\n+        test(String.format(\"% 10g\", 12345.6), fmt.\"% 10g\\{12345.6}\");\n+        test(String.format(\"% -10g\", -12345.6), fmt.\"% -10g\\{-12345.6}\");\n+        test(String.format(\"% -10g\", 0.0), fmt.\"% -10g\\{0.0}\");\n+        test(String.format(\"% -10g\", 12345.6), fmt.\"% -10g\\{12345.6}\");\n+        test(String.format(\"% G\", -12345.6), fmt.\"% G\\{-12345.6}\");\n+        test(String.format(\"% G\", 0.0), fmt.\"% G\\{0.0}\");\n+        test(String.format(\"% G\", 12345.6), fmt.\"% G\\{12345.6}\");\n+        test(String.format(\"% 10G\", -12345.6), fmt.\"% 10G\\{-12345.6}\");\n+        test(String.format(\"% 10G\", 0.0), fmt.\"% 10G\\{0.0}\");\n+        test(String.format(\"% 10G\", 12345.6), fmt.\"% 10G\\{12345.6}\");\n+        test(String.format(\"% -10G\", -12345.6), fmt.\"% -10G\\{-12345.6}\");\n+        test(String.format(\"% -10G\", 0.0), fmt.\"% -10G\\{0.0}\");\n+        test(String.format(\"% -10G\", 12345.6), fmt.\"% -10G\\{12345.6}\");\n+        test(String.format(\"%, g\", -12345.6), fmt.\"%, g\\{-12345.6}\");\n+        test(String.format(\"%, g\", 0.0), fmt.\"%, g\\{0.0}\");\n+        test(String.format(\"%, g\", 12345.6), fmt.\"%, g\\{12345.6}\");\n+        test(String.format(\"%, 10g\", -12345.6), fmt.\"%, 10g\\{-12345.6}\");\n+        test(String.format(\"%, 10g\", 0.0), fmt.\"%, 10g\\{0.0}\");\n+        test(String.format(\"%, 10g\", 12345.6), fmt.\"%, 10g\\{12345.6}\");\n+        test(String.format(\"%, -10g\", -12345.6), fmt.\"%, -10g\\{-12345.6}\");\n+        test(String.format(\"%, -10g\", 0.0), fmt.\"%, -10g\\{0.0}\");\n+        test(String.format(\"%, -10g\", 12345.6), fmt.\"%, -10g\\{12345.6}\");\n+        test(String.format(\"%, G\", -12345.6), fmt.\"%, G\\{-12345.6}\");\n+        test(String.format(\"%, G\", 0.0), fmt.\"%, G\\{0.0}\");\n+        test(String.format(\"%, G\", 12345.6), fmt.\"%, G\\{12345.6}\");\n+        test(String.format(\"%, 10G\", -12345.6), fmt.\"%, 10G\\{-12345.6}\");\n+        test(String.format(\"%, 10G\", 0.0), fmt.\"%, 10G\\{0.0}\");\n+        test(String.format(\"%, 10G\", 12345.6), fmt.\"%, 10G\\{12345.6}\");\n+        test(String.format(\"%, -10G\", -12345.6), fmt.\"%, -10G\\{-12345.6}\");\n+        test(String.format(\"%, -10G\", 0.0), fmt.\"%, -10G\\{0.0}\");\n+        test(String.format(\"%, -10G\", 12345.6), fmt.\"%, -10G\\{12345.6}\");\n+\n+        test(String.format(\"%g\", -12345.6), fmt.\"%g\\{-12345.6}\");\n+        test(String.format(\"%g\", 0.0), fmt.\"%g\\{0.0}\");\n+        test(String.format(\"%g\", 12345.6), fmt.\"%g\\{12345.6}\");\n+        test(String.format(\"%10g\", -12345.6), fmt.\"%10g\\{-12345.6}\");\n+        test(String.format(\"%10g\", 0.0), fmt.\"%10g\\{0.0}\");\n+        test(String.format(\"%10g\", 12345.6), fmt.\"%10g\\{12345.6}\");\n+        test(String.format(\"%-10g\", -12345.6), fmt.\"%-10g\\{-12345.6}\");\n+        test(String.format(\"%-10g\", 0.0), fmt.\"%-10g\\{0.0}\");\n+        test(String.format(\"%-10g\", 12345.6), fmt.\"%-10g\\{12345.6}\");\n+        test(String.format(\"%G\", -12345.6), fmt.\"%G\\{-12345.6}\");\n+        test(String.format(\"%G\", 0.0), fmt.\"%G\\{0.0}\");\n+        test(String.format(\"%G\", 12345.6), fmt.\"%G\\{12345.6}\");\n+        test(String.format(\"%10G\", -12345.6), fmt.\"%10G\\{-12345.6}\");\n+        test(String.format(\"%10G\", 0.0), fmt.\"%10G\\{0.0}\");\n+        test(String.format(\"%10G\", 12345.6), fmt.\"%10G\\{12345.6}\");\n+        test(String.format(\"%-10G\", -12345.6), fmt.\"%-10G\\{-12345.6}\");\n+        test(String.format(\"%-10G\", 0.0), fmt.\"%-10G\\{0.0}\");\n+        test(String.format(\"%-10G\", 12345.6), fmt.\"%-10G\\{12345.6}\");\n+        test(String.format(\"%,g\", -12345.6), fmt.\"%,g\\{-12345.6}\");\n+        test(String.format(\"%,g\", 0.0), fmt.\"%,g\\{0.0}\");\n+        test(String.format(\"%,g\", 12345.6), fmt.\"%,g\\{12345.6}\");\n+        test(String.format(\"%,10g\", -12345.6), fmt.\"%,10g\\{-12345.6}\");\n+        test(String.format(\"%,10g\", 0.0), fmt.\"%,10g\\{0.0}\");\n+        test(String.format(\"%,10g\", 12345.6), fmt.\"%,10g\\{12345.6}\");\n+        test(String.format(\"%,-10g\", -12345.6), fmt.\"%,-10g\\{-12345.6}\");\n+        test(String.format(\"%,-10g\", 0.0), fmt.\"%,-10g\\{0.0}\");\n+        test(String.format(\"%,-10g\", 12345.6), fmt.\"%,-10g\\{12345.6}\");\n+        test(String.format(\"%,G\", -12345.6), fmt.\"%,G\\{-12345.6}\");\n+        test(String.format(\"%,G\", 0.0), fmt.\"%,G\\{0.0}\");\n+        test(String.format(\"%,G\", 12345.6), fmt.\"%,G\\{12345.6}\");\n+        test(String.format(\"%,10G\", -12345.6), fmt.\"%,10G\\{-12345.6}\");\n+        test(String.format(\"%,10G\", 0.0), fmt.\"%,10G\\{0.0}\");\n+        test(String.format(\"%,10G\", 12345.6), fmt.\"%,10G\\{12345.6}\");\n+        test(String.format(\"%,-10G\", -12345.6), fmt.\"%,-10G\\{-12345.6}\");\n+        test(String.format(\"%,-10G\", 0.0), fmt.\"%,-10G\\{0.0}\");\n+        test(String.format(\"%,-10G\", 12345.6), fmt.\"%,-10G\\{12345.6}\");\n+        test(String.format(\"%+g\", -12345.6), fmt.\"%+g\\{-12345.6}\");\n+        test(String.format(\"%+g\", 0.0), fmt.\"%+g\\{0.0}\");\n+        test(String.format(\"%+g\", 12345.6), fmt.\"%+g\\{12345.6}\");\n+        test(String.format(\"%+10g\", -12345.6), fmt.\"%+10g\\{-12345.6}\");\n+        test(String.format(\"%+10g\", 0.0), fmt.\"%+10g\\{0.0}\");\n+        test(String.format(\"%+10g\", 12345.6), fmt.\"%+10g\\{12345.6}\");\n+        test(String.format(\"%+-10g\", -12345.6), fmt.\"%+-10g\\{-12345.6}\");\n+        test(String.format(\"%+-10g\", 0.0), fmt.\"%+-10g\\{0.0}\");\n+        test(String.format(\"%+-10g\", 12345.6), fmt.\"%+-10g\\{12345.6}\");\n+        test(String.format(\"%+G\", -12345.6), fmt.\"%+G\\{-12345.6}\");\n+        test(String.format(\"%+G\", 0.0), fmt.\"%+G\\{0.0}\");\n+        test(String.format(\"%+G\", 12345.6), fmt.\"%+G\\{12345.6}\");\n+        test(String.format(\"%+10G\", -12345.6), fmt.\"%+10G\\{-12345.6}\");\n+        test(String.format(\"%+10G\", 0.0), fmt.\"%+10G\\{0.0}\");\n+        test(String.format(\"%+10G\", 12345.6), fmt.\"%+10G\\{12345.6}\");\n+        test(String.format(\"%+-10G\", -12345.6), fmt.\"%+-10G\\{-12345.6}\");\n+        test(String.format(\"%+-10G\", 0.0), fmt.\"%+-10G\\{0.0}\");\n+        test(String.format(\"%+-10G\", 12345.6), fmt.\"%+-10G\\{12345.6}\");\n+        test(String.format(\"%,+g\", -12345.6), fmt.\"%,+g\\{-12345.6}\");\n+        test(String.format(\"%,+g\", 0.0), fmt.\"%,+g\\{0.0}\");\n+        test(String.format(\"%,+g\", 12345.6), fmt.\"%,+g\\{12345.6}\");\n+        test(String.format(\"%,+10g\", -12345.6), fmt.\"%,+10g\\{-12345.6}\");\n+        test(String.format(\"%,+10g\", 0.0), fmt.\"%,+10g\\{0.0}\");\n+        test(String.format(\"%,+10g\", 12345.6), fmt.\"%,+10g\\{12345.6}\");\n+        test(String.format(\"%,+-10g\", -12345.6), fmt.\"%,+-10g\\{-12345.6}\");\n+        test(String.format(\"%,+-10g\", 0.0), fmt.\"%,+-10g\\{0.0}\");\n+        test(String.format(\"%,+-10g\", 12345.6), fmt.\"%,+-10g\\{12345.6}\");\n+        test(String.format(\"%,+G\", -12345.6), fmt.\"%,+G\\{-12345.6}\");\n+        test(String.format(\"%,+G\", 0.0), fmt.\"%,+G\\{0.0}\");\n+        test(String.format(\"%,+G\", 12345.6), fmt.\"%,+G\\{12345.6}\");\n+        test(String.format(\"%,+10G\", -12345.6), fmt.\"%,+10G\\{-12345.6}\");\n+        test(String.format(\"%,+10G\", 0.0), fmt.\"%,+10G\\{0.0}\");\n+        test(String.format(\"%,+10G\", 12345.6), fmt.\"%,+10G\\{12345.6}\");\n+        test(String.format(\"%,+-10G\", -12345.6), fmt.\"%,+-10G\\{-12345.6}\");\n+        test(String.format(\"%,+-10G\", 0.0), fmt.\"%,+-10G\\{0.0}\");\n+        test(String.format(\"%,+-10G\", 12345.6), fmt.\"%,+-10G\\{12345.6}\");\n+\n+        test(String.format(\"%g\", -12345.6), fmt.\"%g\\{-12345.6}\");\n+        test(String.format(\"%g\", 0.0), fmt.\"%g\\{0.0}\");\n+        test(String.format(\"%g\", 12345.6), fmt.\"%g\\{12345.6}\");\n+        test(String.format(\"%10g\", -12345.6), fmt.\"%10g\\{-12345.6}\");\n+        test(String.format(\"%10g\", 0.0), fmt.\"%10g\\{0.0}\");\n+        test(String.format(\"%10g\", 12345.6), fmt.\"%10g\\{12345.6}\");\n+        test(String.format(\"%-10g\", -12345.6), fmt.\"%-10g\\{-12345.6}\");\n+        test(String.format(\"%-10g\", 0.0), fmt.\"%-10g\\{0.0}\");\n+        test(String.format(\"%-10g\", 12345.6), fmt.\"%-10g\\{12345.6}\");\n+        test(String.format(\"%G\", -12345.6), fmt.\"%G\\{-12345.6}\");\n+        test(String.format(\"%G\", 0.0), fmt.\"%G\\{0.0}\");\n+        test(String.format(\"%G\", 12345.6), fmt.\"%G\\{12345.6}\");\n+        test(String.format(\"%10G\", -12345.6), fmt.\"%10G\\{-12345.6}\");\n+        test(String.format(\"%10G\", 0.0), fmt.\"%10G\\{0.0}\");\n+        test(String.format(\"%10G\", 12345.6), fmt.\"%10G\\{12345.6}\");\n+        test(String.format(\"%-10G\", -12345.6), fmt.\"%-10G\\{-12345.6}\");\n+        test(String.format(\"%-10G\", 0.0), fmt.\"%-10G\\{0.0}\");\n+        test(String.format(\"%-10G\", 12345.6), fmt.\"%-10G\\{12345.6}\");\n+        test(String.format(\"%,g\", -12345.6), fmt.\"%,g\\{-12345.6}\");\n+        test(String.format(\"%,g\", 0.0), fmt.\"%,g\\{0.0}\");\n+        test(String.format(\"%,g\", 12345.6), fmt.\"%,g\\{12345.6}\");\n+        test(String.format(\"%,10g\", -12345.6), fmt.\"%,10g\\{-12345.6}\");\n+        test(String.format(\"%,10g\", 0.0), fmt.\"%,10g\\{0.0}\");\n+        test(String.format(\"%,10g\", 12345.6), fmt.\"%,10g\\{12345.6}\");\n+        test(String.format(\"%,-10g\", -12345.6), fmt.\"%,-10g\\{-12345.6}\");\n+        test(String.format(\"%,-10g\", 0.0), fmt.\"%,-10g\\{0.0}\");\n+        test(String.format(\"%,-10g\", 12345.6), fmt.\"%,-10g\\{12345.6}\");\n+        test(String.format(\"%,G\", -12345.6), fmt.\"%,G\\{-12345.6}\");\n+        test(String.format(\"%,G\", 0.0), fmt.\"%,G\\{0.0}\");\n+        test(String.format(\"%,G\", 12345.6), fmt.\"%,G\\{12345.6}\");\n+        test(String.format(\"%,10G\", -12345.6), fmt.\"%,10G\\{-12345.6}\");\n+        test(String.format(\"%,10G\", 0.0), fmt.\"%,10G\\{0.0}\");\n+        test(String.format(\"%,10G\", 12345.6), fmt.\"%,10G\\{12345.6}\");\n+        test(String.format(\"%,-10G\", -12345.6), fmt.\"%,-10G\\{-12345.6}\");\n+        test(String.format(\"%,-10G\", 0.0), fmt.\"%,-10G\\{0.0}\");\n+        test(String.format(\"%,-10G\", 12345.6), fmt.\"%,-10G\\{12345.6}\");\n+        test(String.format(\"%(g\", -12345.6), fmt.\"%(g\\{-12345.6}\");\n+        test(String.format(\"%(g\", 0.0), fmt.\"%(g\\{0.0}\");\n+        test(String.format(\"%(g\", 12345.6), fmt.\"%(g\\{12345.6}\");\n+        test(String.format(\"%(10g\", -12345.6), fmt.\"%(10g\\{-12345.6}\");\n+        test(String.format(\"%(10g\", 0.0), fmt.\"%(10g\\{0.0}\");\n+        test(String.format(\"%(10g\", 12345.6), fmt.\"%(10g\\{12345.6}\");\n+        test(String.format(\"%(-10g\", -12345.6), fmt.\"%(-10g\\{-12345.6}\");\n+        test(String.format(\"%(-10g\", 0.0), fmt.\"%(-10g\\{0.0}\");\n+        test(String.format(\"%(-10g\", 12345.6), fmt.\"%(-10g\\{12345.6}\");\n+        test(String.format(\"%(G\", -12345.6), fmt.\"%(G\\{-12345.6}\");\n+        test(String.format(\"%(G\", 0.0), fmt.\"%(G\\{0.0}\");\n+        test(String.format(\"%(G\", 12345.6), fmt.\"%(G\\{12345.6}\");\n+        test(String.format(\"%(10G\", -12345.6), fmt.\"%(10G\\{-12345.6}\");\n+        test(String.format(\"%(10G\", 0.0), fmt.\"%(10G\\{0.0}\");\n+        test(String.format(\"%(10G\", 12345.6), fmt.\"%(10G\\{12345.6}\");\n+        test(String.format(\"%(-10G\", -12345.6), fmt.\"%(-10G\\{-12345.6}\");\n+        test(String.format(\"%(-10G\", 0.0), fmt.\"%(-10G\\{0.0}\");\n+        test(String.format(\"%(-10G\", 12345.6), fmt.\"%(-10G\\{12345.6}\");\n+        test(String.format(\"%,(g\", -12345.6), fmt.\"%,(g\\{-12345.6}\");\n+        test(String.format(\"%,(g\", 0.0), fmt.\"%,(g\\{0.0}\");\n+        test(String.format(\"%,(g\", 12345.6), fmt.\"%,(g\\{12345.6}\");\n+        test(String.format(\"%,(10g\", -12345.6), fmt.\"%,(10g\\{-12345.6}\");\n+        test(String.format(\"%,(10g\", 0.0), fmt.\"%,(10g\\{0.0}\");\n+        test(String.format(\"%,(10g\", 12345.6), fmt.\"%,(10g\\{12345.6}\");\n+        test(String.format(\"%,(-10g\", -12345.6), fmt.\"%,(-10g\\{-12345.6}\");\n+        test(String.format(\"%,(-10g\", 0.0), fmt.\"%,(-10g\\{0.0}\");\n+        test(String.format(\"%,(-10g\", 12345.6), fmt.\"%,(-10g\\{12345.6}\");\n+        test(String.format(\"%,(G\", -12345.6), fmt.\"%,(G\\{-12345.6}\");\n+        test(String.format(\"%,(G\", 0.0), fmt.\"%,(G\\{0.0}\");\n+        test(String.format(\"%,(G\", 12345.6), fmt.\"%,(G\\{12345.6}\");\n+        test(String.format(\"%,(10G\", -12345.6), fmt.\"%,(10G\\{-12345.6}\");\n+        test(String.format(\"%,(10G\", 0.0), fmt.\"%,(10G\\{0.0}\");\n+        test(String.format(\"%,(10G\", 12345.6), fmt.\"%,(10G\\{12345.6}\");\n+        test(String.format(\"%,(-10G\", -12345.6), fmt.\"%,(-10G\\{-12345.6}\");\n+        test(String.format(\"%,(-10G\", 0.0), fmt.\"%,(-10G\\{0.0}\");\n+        test(String.format(\"%,(-10G\", 12345.6), fmt.\"%,(-10G\\{12345.6}\");\n+        test(String.format(\"%+g\", -12345.6), fmt.\"%+g\\{-12345.6}\");\n+        test(String.format(\"%+g\", 0.0), fmt.\"%+g\\{0.0}\");\n+        test(String.format(\"%+g\", 12345.6), fmt.\"%+g\\{12345.6}\");\n+        test(String.format(\"%+10g\", -12345.6), fmt.\"%+10g\\{-12345.6}\");\n+        test(String.format(\"%+10g\", 0.0), fmt.\"%+10g\\{0.0}\");\n+        test(String.format(\"%+10g\", 12345.6), fmt.\"%+10g\\{12345.6}\");\n+        test(String.format(\"%+-10g\", -12345.6), fmt.\"%+-10g\\{-12345.6}\");\n+        test(String.format(\"%+-10g\", 0.0), fmt.\"%+-10g\\{0.0}\");\n+        test(String.format(\"%+-10g\", 12345.6), fmt.\"%+-10g\\{12345.6}\");\n+        test(String.format(\"%+G\", -12345.6), fmt.\"%+G\\{-12345.6}\");\n+        test(String.format(\"%+G\", 0.0), fmt.\"%+G\\{0.0}\");\n+        test(String.format(\"%+G\", 12345.6), fmt.\"%+G\\{12345.6}\");\n+        test(String.format(\"%+10G\", -12345.6), fmt.\"%+10G\\{-12345.6}\");\n+        test(String.format(\"%+10G\", 0.0), fmt.\"%+10G\\{0.0}\");\n+        test(String.format(\"%+10G\", 12345.6), fmt.\"%+10G\\{12345.6}\");\n+        test(String.format(\"%+-10G\", -12345.6), fmt.\"%+-10G\\{-12345.6}\");\n+        test(String.format(\"%+-10G\", 0.0), fmt.\"%+-10G\\{0.0}\");\n+        test(String.format(\"%+-10G\", 12345.6), fmt.\"%+-10G\\{12345.6}\");\n+        test(String.format(\"%,+g\", -12345.6), fmt.\"%,+g\\{-12345.6}\");\n+        test(String.format(\"%,+g\", 0.0), fmt.\"%,+g\\{0.0}\");\n+        test(String.format(\"%,+g\", 12345.6), fmt.\"%,+g\\{12345.6}\");\n+        test(String.format(\"%,+10g\", -12345.6), fmt.\"%,+10g\\{-12345.6}\");\n+        test(String.format(\"%,+10g\", 0.0), fmt.\"%,+10g\\{0.0}\");\n+        test(String.format(\"%,+10g\", 12345.6), fmt.\"%,+10g\\{12345.6}\");\n+        test(String.format(\"%,+-10g\", -12345.6), fmt.\"%,+-10g\\{-12345.6}\");\n+        test(String.format(\"%,+-10g\", 0.0), fmt.\"%,+-10g\\{0.0}\");\n+        test(String.format(\"%,+-10g\", 12345.6), fmt.\"%,+-10g\\{12345.6}\");\n+        test(String.format(\"%,+G\", -12345.6), fmt.\"%,+G\\{-12345.6}\");\n+        test(String.format(\"%,+G\", 0.0), fmt.\"%,+G\\{0.0}\");\n+        test(String.format(\"%,+G\", 12345.6), fmt.\"%,+G\\{12345.6}\");\n+        test(String.format(\"%,+10G\", -12345.6), fmt.\"%,+10G\\{-12345.6}\");\n+        test(String.format(\"%,+10G\", 0.0), fmt.\"%,+10G\\{0.0}\");\n+        test(String.format(\"%,+10G\", 12345.6), fmt.\"%,+10G\\{12345.6}\");\n+        test(String.format(\"%,+-10G\", -12345.6), fmt.\"%,+-10G\\{-12345.6}\");\n+        test(String.format(\"%,+-10G\", 0.0), fmt.\"%,+-10G\\{0.0}\");\n+        test(String.format(\"%,+-10G\", 12345.6), fmt.\"%,+-10G\\{12345.6}\");\n+        test(String.format(\"%(+g\", -12345.6), fmt.\"%(+g\\{-12345.6}\");\n+        test(String.format(\"%(+g\", 0.0), fmt.\"%(+g\\{0.0}\");\n+        test(String.format(\"%(+g\", 12345.6), fmt.\"%(+g\\{12345.6}\");\n+        test(String.format(\"%(+10g\", -12345.6), fmt.\"%(+10g\\{-12345.6}\");\n+        test(String.format(\"%(+10g\", 0.0), fmt.\"%(+10g\\{0.0}\");\n+        test(String.format(\"%(+10g\", 12345.6), fmt.\"%(+10g\\{12345.6}\");\n+        test(String.format(\"%(+-10g\", -12345.6), fmt.\"%(+-10g\\{-12345.6}\");\n+        test(String.format(\"%(+-10g\", 0.0), fmt.\"%(+-10g\\{0.0}\");\n+        test(String.format(\"%(+-10g\", 12345.6), fmt.\"%(+-10g\\{12345.6}\");\n+        test(String.format(\"%(+G\", -12345.6), fmt.\"%(+G\\{-12345.6}\");\n+        test(String.format(\"%(+G\", 0.0), fmt.\"%(+G\\{0.0}\");\n+        test(String.format(\"%(+G\", 12345.6), fmt.\"%(+G\\{12345.6}\");\n+        test(String.format(\"%(+10G\", -12345.6), fmt.\"%(+10G\\{-12345.6}\");\n+        test(String.format(\"%(+10G\", 0.0), fmt.\"%(+10G\\{0.0}\");\n+        test(String.format(\"%(+10G\", 12345.6), fmt.\"%(+10G\\{12345.6}\");\n+        test(String.format(\"%(+-10G\", -12345.6), fmt.\"%(+-10G\\{-12345.6}\");\n+        test(String.format(\"%(+-10G\", 0.0), fmt.\"%(+-10G\\{0.0}\");\n+        test(String.format(\"%(+-10G\", 12345.6), fmt.\"%(+-10G\\{12345.6}\");\n+        test(String.format(\"%,(+g\", -12345.6), fmt.\"%,(+g\\{-12345.6}\");\n+        test(String.format(\"%,(+g\", 0.0), fmt.\"%,(+g\\{0.0}\");\n+        test(String.format(\"%,(+g\", 12345.6), fmt.\"%,(+g\\{12345.6}\");\n+        test(String.format(\"%,(+10g\", -12345.6), fmt.\"%,(+10g\\{-12345.6}\");\n+        test(String.format(\"%,(+10g\", 0.0), fmt.\"%,(+10g\\{0.0}\");\n+        test(String.format(\"%,(+10g\", 12345.6), fmt.\"%,(+10g\\{12345.6}\");\n+        test(String.format(\"%,(+-10g\", -12345.6), fmt.\"%,(+-10g\\{-12345.6}\");\n+        test(String.format(\"%,(+-10g\", 0.0), fmt.\"%,(+-10g\\{0.0}\");\n+        test(String.format(\"%,(+-10g\", 12345.6), fmt.\"%,(+-10g\\{12345.6}\");\n+        test(String.format(\"%,(+G\", -12345.6), fmt.\"%,(+G\\{-12345.6}\");\n+        test(String.format(\"%,(+G\", 0.0), fmt.\"%,(+G\\{0.0}\");\n+        test(String.format(\"%,(+G\", 12345.6), fmt.\"%,(+G\\{12345.6}\");\n+        test(String.format(\"%,(+10G\", -12345.6), fmt.\"%,(+10G\\{-12345.6}\");\n+        test(String.format(\"%,(+10G\", 0.0), fmt.\"%,(+10G\\{0.0}\");\n+        test(String.format(\"%,(+10G\", 12345.6), fmt.\"%,(+10G\\{12345.6}\");\n+        test(String.format(\"%,(+-10G\", -12345.6), fmt.\"%,(+-10G\\{-12345.6}\");\n+        test(String.format(\"%,(+-10G\", 0.0), fmt.\"%,(+-10G\\{0.0}\");\n+        test(String.format(\"%,(+-10G\", 12345.6), fmt.\"%,(+-10G\\{12345.6}\");\n+\n+        test(String.format(\"%a\", -12345.6), fmt.\"%a\\{-12345.6}\");\n+        test(String.format(\"%a\", 0.0), fmt.\"%a\\{0.0}\");\n+        test(String.format(\"%a\", 12345.6), fmt.\"%a\\{12345.6}\");\n+        test(String.format(\"%10a\", -12345.6), fmt.\"%10a\\{-12345.6}\");\n+        test(String.format(\"%10a\", 0.0), fmt.\"%10a\\{0.0}\");\n+        test(String.format(\"%10a\", 12345.6), fmt.\"%10a\\{12345.6}\");\n+        test(String.format(\"%-10a\", -12345.6), fmt.\"%-10a\\{-12345.6}\");\n+        test(String.format(\"%-10a\", 0.0), fmt.\"%-10a\\{0.0}\");\n+        test(String.format(\"%-10a\", 12345.6), fmt.\"%-10a\\{12345.6}\");\n+        test(String.format(\"%A\", -12345.6), fmt.\"%A\\{-12345.6}\");\n+        test(String.format(\"%A\", 0.0), fmt.\"%A\\{0.0}\");\n+        test(String.format(\"%A\", 12345.6), fmt.\"%A\\{12345.6}\");\n+        test(String.format(\"%10A\", -12345.6), fmt.\"%10A\\{-12345.6}\");\n+        test(String.format(\"%10A\", 0.0), fmt.\"%10A\\{0.0}\");\n+        test(String.format(\"%10A\", 12345.6), fmt.\"%10A\\{12345.6}\");\n+        test(String.format(\"%-10A\", -12345.6), fmt.\"%-10A\\{-12345.6}\");\n+        test(String.format(\"%-10A\", 0.0), fmt.\"%-10A\\{0.0}\");\n+        test(String.format(\"%-10A\", 12345.6), fmt.\"%-10A\\{12345.6}\");\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/template\/FormatterBuilder.java","additions":915,"deletions":0,"binary":false,"changes":915,"status":"added"},{"patch":"@@ -0,0 +1,306 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 0000000\n+ * @summary Exercise runtime handing of templated strings.\n+ * @enablePreview true\n+ *\/\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.FilterOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.net.URI;\n+import java.util.*;\n+import java.util.function.Supplier;\n+import javax.tools.FileObject;\n+import javax.tools.ForwardingJavaFileManager;\n+import javax.tools.JavaFileManager;\n+import javax.tools.JavaFileObject;\n+import javax.tools.SimpleJavaFileObject;\n+import static javax.tools.StandardLocation.CLASS_OUTPUT;\n+import javax.tools.ToolProvider;\n+\n+public class StringTemplateTest {\n+    enum Category{GENERAL, CHARACTER, INTEGRAL, BIG_INT, FLOATING, BIG_FLOAT, DATE};\n+\n+    static final String[] GENERAL = {\"true\", \"false\", \"(Object)null\", \"STR\", \"BO\", \"BOOL\", \"(Boolean)null\"};\n+    static final String[] CHARS = {\"C\", \"CHAR\", \"(Character)null\"};\n+    static final String[] INTS = {\"L\", \"LONG\", \"I\", \"INT\", \"S\", \"SHORT\", \"BY\", \"BYTE\", \"Long.MAX_VALUE\", \"Long.MIN_VALUE\", \"(Long)null\", \"(Integer)null\", \"(Short)null\", \"(Byte)null\"};\n+    static final String[] BIGINTS = {};\n+    static final String[] FLOATS = {\"F\", \"FLOAT\", \"D\", \"DOUBLE\", \"Double.NEGATIVE_INFINITY\", \"Double.NaN\", \"Double.MAX_VALUE\", \"(Double)null\", \"(Float)null\"};\n+    static final String[] BIGFLOATS = {};\n+    static final String[] DATES = {};\n+\n+    final Random r = new Random(1);\n+\n+    String randomValue(Category category) {\n+        return switch (category) {\n+            case GENERAL -> randomChoice(\n+                    GENERAL,\n+                    () -> randomValue(Category.CHARACTER),\n+                    () -> randomValue(Category.INTEGRAL),\n+                    () -> randomValue(Category.BIG_INT),\n+                    () -> randomValue(Category.FLOATING),\n+                    () -> randomValue(Category.BIG_FLOAT),\n+                    () -> randomValue(Category.DATE),\n+                    () -> \"\\\"\" + randomString(r.nextInt(10)) + \"\\\"\");\n+            case CHARACTER -> randomChoice(\n+                    CHARS,\n+                    () -> \"\\'\" + randomString(1) + \"\\'\");\n+            case INTEGRAL -> randomChoice(\n+                    INTS,\n+                    () -> \"(byte)\" + String.valueOf(r.nextInt(Byte.MIN_VALUE, Byte.MAX_VALUE)),\n+                    () -> \"(short)\" + String.valueOf(r.nextInt(Short.MIN_VALUE, Short.MAX_VALUE)),\n+                    () -> String.valueOf(r.nextInt()),\n+                    () -> r.nextLong() + \"l\");\n+            case BIG_INT -> randomChoice(\n+                    BIGINTS,\n+                    () -> \"new java.math.BigInteger(\\\"\" + r.nextLong() + \"\\\")\");\n+            case FLOATING -> randomChoice(\n+                    FLOATS,\n+                    () -> String.valueOf(r.nextDouble()),\n+                    () -> r.nextFloat() + \"f\");\n+            case BIG_FLOAT -> randomChoice(\n+                    BIGFLOATS,\n+                    () -> \"new java.math.BigDecimal(\" + r.nextDouble() + \")\");\n+            case DATE -> randomChoice(\n+                    DATES,\n+                    () -> \"new java.util.Date(\" + r.nextLong() + \"l)\",\n+                    () -> r.nextLong() + \"l\");\n+        };\n+    }\n+\n+    String randomChoice(Supplier<String>... suppl) {\n+        return suppl[r.nextInt(suppl.length)].get();\n+    }\n+\n+    String randomChoice(String... values) {\n+        return values[r.nextInt(values.length)];\n+    }\n+\n+    String randomChoice(String[] values, Supplier<String>... suppl) {\n+        int i = r.nextInt(values.length + suppl.length);\n+        return i < values.length ? values[i] : suppl[i - values.length].get();\n+    }\n+\n+    String randomString(int length) {\n+        var sb = new StringBuilder(length << 2);\n+        while (length-- > 0) {\n+            char ch = (char)r.nextInt(9, 128);\n+            var s = switch (ch) {\n+                case '\\t' -> \"\\\\t\";\n+                case '\\'' -> \"\\\\\\'\";\n+                case '\"' -> \"\\\\\\\"\";\n+                case '\\r' -> \"\\\\r\";\n+                case '\\\\' -> \"\\\\\\\\\";\n+                case '\\n' -> \"\\\\n\";\n+                case '\\f' -> \"\\\\f\";\n+                case '\\b' -> \"\\\\b\";\n+                default -> ch + \"\";\n+            };\n+            sb.append(s);\n+        }\n+        return sb.toString();\n+    }\n+\n+    String randomFormat(Category category) {\n+        char c;\n+        return \"%\" + switch (category) {\n+            case GENERAL -> randomWidth(\"-\") + randomPrecision() + randomChar(\"bBhHsS\");\n+            case CHARACTER -> randomWidth(\"-\") + randomChar(\"cC\");\n+            case INTEGRAL -> switch (c = randomChar(\"doxX\")) {\n+                case 'd' -> randomFlags(\"+ ,(\");\n+                default -> randomFlags(\"\");\n+            } + randomWidth(\"-0\") + c;\n+            case BIG_INT -> switch (c = randomChar(\"doxX\")) {\n+                case 'd' -> randomFlags(\"+ ,(\");\n+                default -> randomFlags(\"+ (\");\n+            } + randomWidth(\"-0\") + c;\n+            case FLOATING -> switch (c = randomChar(\"eEfaAgG\")) {\n+                case 'a', 'A' -> randomFlags(\"+ \") + randomWidth(\"-0\");\n+                case 'e', 'E' -> randomFlags(\"+ (\") + randomWidth(\"-0\") + randomPrecision();\n+                default -> randomFlags(\"+ ,(\") + randomWidth(\"-0\") + randomPrecision();\n+            } + c;\n+            case BIG_FLOAT -> switch (c = randomChar(\"eEfgG\")) {\n+                case 'e', 'E' -> randomFlags(\"+ (\") + randomWidth(\"-0\") + randomPrecision();\n+                default -> randomFlags(\"+ ,(\") + randomWidth(\"-0\") + randomPrecision();\n+            } + c;\n+            case DATE ->  randomWidth(\"-\") + randomChar(\"tT\") + randomChar(\"BbhAaCYyjmdeRTrDFc\");\n+        };\n+    }\n+\n+    String randomFlags(String flags) {\n+        var sb = new StringBuilder(flags.length());\n+        for (var f : flags.toCharArray()) {\n+            if (r.nextBoolean() && (f != ' ' || sb.length() == 0 || sb.charAt(sb.length() - 1) != '+')) sb.append(f);\n+        }\n+        return sb.toString();\n+    }\n+\n+    char randomChar(String chars) {\n+        return chars.charAt(r.nextInt(chars.length()));\n+    }\n+\n+    String randomWidth(String flags) {\n+        var f = r.nextInt(flags.length() + 1);\n+        return r.nextBoolean() ? (r.nextBoolean() ? flags.charAt(r.nextInt(flags.length())) : \"\") + String.valueOf(r.nextInt(10) + 1) : \"\";\n+    }\n+\n+    String randomPrecision() {\n+        return r.nextBoolean() ? '.' + String.valueOf(r.nextInt(10) + 1) : \"\";\n+    }\n+\n+    public Class<?> compile() throws Exception {\n+        var classes = new HashMap<String, byte[]>();\n+        var fileManager = new ForwardingJavaFileManager(ToolProvider.getSystemJavaCompiler().getStandardFileManager(null, null, null)) {\n+            @Override\n+            public ClassLoader getClassLoader(JavaFileManager.Location location) {\n+                return new ClassLoader() {\n+                    @Override\n+                    public Class<?> loadClass(String name) throws ClassNotFoundException {\n+                        try {\n+                            return super.loadClass(name);\n+                        } catch (ClassNotFoundException e) {\n+                            byte[] classData = classes.get(name);\n+                            return defineClass(name, classData, 0, classData.length);\n+                        }\n+                    }\n+                };\n+            }\n+            @Override\n+            public JavaFileObject getJavaFileForOutput(JavaFileManager.Location location, String name, JavaFileObject.Kind kind, FileObject originatingSource) throws UnsupportedOperationException {\n+                return new SimpleJavaFileObject(URI.create(name + \".class\"), JavaFileObject.Kind.CLASS) {\n+                    @Override\n+                    public OutputStream openOutputStream() {\n+                        return new FilterOutputStream(new ByteArrayOutputStream()) {\n+                            @Override\n+                            public void close() throws IOException {\n+                                classes.put(name, ((ByteArrayOutputStream)out).toByteArray());\n+                            }\n+                        };\n+                    }\n+                };\n+            }\n+        };\n+        var source = genSource();\n+\/\/        System.out.println(source);\n+        if (ToolProvider.getSystemJavaCompiler().getTask(null, fileManager, null,\n+                List.of(\"--enable-preview\", \"-source\", String.valueOf(Runtime.version().feature())), null,\n+                List.of(new SimpleJavaFileObject(URI.create(\"StringTemplateTest$.java\"), JavaFileObject.Kind.SOURCE) {\n+            @Override\n+            public CharSequence getCharContent(boolean ignoreEncodingErrors) {\n+                return source;\n+            }\n+        })).call()) {\n+            return fileManager.getClassLoader(CLASS_OUTPUT).loadClass(\"StringTemplateTest$\");\n+        } else {\n+            throw new AssertionError(\"compilation failed\");\n+        }\n+    }\n+\n+    String genFragments(Category c) {\n+        var fragments = new LinkedList<String>();\n+        for (int i = 0; i < 1500; i++) {\n+            var format = randomFormat(c);\n+            var value = randomValue(c);\n+            var qValue = value.replace(\"\\\\\", \"\\\\\\\\\").replace(\"\\\"\", \"\\\\\\\"\");\n+            fragments.add(STR.\"test(FMT.\\\"\\{format}\\\\{\\{value}}\\\", \\\"\\{format}\\\", \\\"\\{qValue}\\\", \\{value}, log);\");\n+        }\n+        return String.join(\"\\n        \", fragments);\n+    }\n+\n+    String genSource() {\n+        return STR.\"\"\"\n+            import static java.util.FormatProcessor.FMT;\n+\n+            public class StringTemplateTest$ {\n+                static String STR = \"this is static String\";\n+                static char C = 'c';\n+                static Character CHAR = 'C';\n+                static long L = -12345678910l;\n+                static Long LONG = 9876543210l;\n+                static int I = 42;\n+                static Integer INT = -49;\n+                static boolean BO = true;\n+                static Boolean BOOL = false;\n+                static short S = 13;\n+                static Short SHORT = -17;\n+                static byte BY = -3;\n+                static Byte BYTE = 12;\n+                static float F = 4.789f;\n+                static Float FLOAT = -0.000006f;\n+                static double D = 6545745.6734654563;\n+                static Double DOUBLE = -4323.7645676574;\n+\n+                public static void run(java.util.List<String> log) {\n+                    runGeneral(log);\n+                    runCharacter(log);\n+                    runIntegral(log);\n+                    runBigInt(log);\n+                    runFloating(log);\n+                    runBigFloat(log);\n+                    runDate(log);\n+                }\n+                public static void runGeneral(java.util.List<String> log) {\n+                    \\{genFragments(Category.GENERAL)}\n+                }\n+                public static void runCharacter(java.util.List<String> log) {\n+                    \\{genFragments(Category.CHARACTER)}\n+                }\n+                public static void runIntegral(java.util.List<String> log) {\n+                    \\{genFragments(Category.INTEGRAL)}\n+                }\n+                public static void runBigInt(java.util.List<String> log) {\n+                    \\{genFragments(Category.BIG_INT)}\n+                }\n+                public static void runFloating(java.util.List<String> log) {\n+                    \\{genFragments(Category.FLOATING)}\n+                }\n+                public static void runBigFloat(java.util.List<String> log) {\n+                    \\{genFragments(Category.BIG_FLOAT)}\n+                }\n+                public static void runDate(java.util.List<String> log) {\n+                    \\{genFragments(Category.DATE)}\n+                }\n+                static void test(String fmt, String format, String expression, Object value, java.util.List<String> log) {\n+                    var formatted = String.format(java.util.Locale.US, format, value);\n+                    if (!fmt.equals(formatted)) {\n+                        log.add(\"  format: '%s' expression: '%s' value: '%s' expected: '%s' found: '%s'\".formatted(format, expression, value, formatted, fmt));\n+                    }\n+                }\n+            }\n+            \"\"\";\n+    }\n+\n+    public static void main(String... args) throws Exception {\n+        var log = new LinkedList<String>();\n+        new StringTemplateTest().compile().getMethod(\"run\", List.class).invoke(null, log);\n+        if (!log.isEmpty()) {\n+            log.forEach(System.out::println);\n+            throw new AssertionError(STR.\"failed \\{log.size()} tests\");\n+        }\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/java\/lang\/template\/StringTemplateTest.java","additions":306,"deletions":0,"binary":false,"changes":306,"status":"added"},{"patch":"@@ -106,1 +106,1 @@\n-        check(numAllMembers, \"#allMembers\", 52);\n+        check(numAllMembers, \"#allMembers\", 58);\n","filename":"test\/langtools\/tools\/javac\/api\/TestJavacTaskScanner.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+ \/\/ key: compiler.misc.feature.string.templates\n+ \/\/ key: compiler.warn.preview.feature.use.plural\n+ \/\/ options: --enable-preview -source 20  -Xlint:preview\n+\n+class StringTemplate {\n+    String m() {\n+        int x = 10, y = 20;\n+        return STR.\"\\{x} + \\{y} = \\{x + y}\";\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/StringTemplate.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"},{"patch":"@@ -0,0 +1,34 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+ \/\/ key: compiler.err.processor.missing.from.string.template.expression\n+ \/\/ key: compiler.misc.feature.string.templates\n+ \/\/ key: compiler.warn.preview.feature.use.plural\n+ \/\/ options: --enable-preview -source 20  -Xlint:preview\n+\n+class StringTemplateNoProcessor {\n+    String m() {\n+        int x = 10, y = 20;\n+        return \"\\{x} + \\{y} = \\{x + y}\";\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/StringTemplateNoProcessor.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"added"},{"patch":"@@ -0,0 +1,37 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+ \/\/ key: compiler.note.preview.filename\n+ \/\/ key: compiler.note.preview.recompile\n+ \/\/ key: compiler.err.not.template.processor.type\n+ \/\/ options: --enable-preview  -source 20\n+\n+import java.lang.template.*;\n+\n+class StringTemplateNotProcessor {\n+    String m() {\n+        String processor = \"\";\n+        int x = 10, y = 20;\n+        return processor.\"\\{x} + \\{y} = \\{x + y}\";\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/StringTemplateNotProcessor.java","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"},{"patch":"@@ -0,0 +1,43 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+ \/\/ key: compiler.note.preview.filename\n+ \/\/ key: compiler.note.preview.recompile\n+ \/\/ key: compiler.misc.unexpected.ret.val\n+ \/\/ key: compiler.err.prob.found.req\n+ \/\/ key: compiler.err.raw.template.processor.type\n+ \/\/ options: --enable-preview -source 20\n+\n+import java.lang.template.*;\n+\n+class StringTemplateRawProcessor {\n+    void m() {\n+        TemplateProcessor processor = ts -> ts.interpolate();\n+        try {\n+            int x = 10, y = 20;\n+            return processor.\"\\{x} + \\{y} = \\{x + y}\";\n+        } catch (Throwable x) {\n+            throw new RuntimeException(x);\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/StringTemplateRawProcessor.java","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -0,0 +1,39 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+ \/\/ key: compiler.note.preview.filename\n+ \/\/ key: compiler.note.preview.recompile\n+ \/\/ key: compiler.err.unclosed.str.lit\n+ \/\/ key: compiler.err.unclosed.string.template\n+ \/\/ key: compiler.err.not.stmt\n+ \/\/ key: compiler.err.premature.eof\n+ \/\/ options: --enable-preview -source 20\n+\n+import java.lang.template.*;\n+\n+class StringTemplateUnclosedString {\n+    String m() {\n+        int x = 10;\n+        return STR.\"\\{x\";\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/StringTemplateUnclosedString.java","additions":39,"deletions":0,"binary":false,"changes":39,"status":"added"},{"patch":"@@ -0,0 +1,45 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+ \/\/ key: compiler.note.preview.filename\n+ \/\/ key: compiler.note.preview.recompile\n+ \/\/ key: compiler.err.unclosed.text.block\n+ \/\/ key: compiler.err.unclosed.text.block.template\n+ \/\/ key: compiler.err.not.stmt\n+ \/\/ key: compiler.err.expected\n+ \/\/ key: compiler.err.illegal.char\n+ \/\/ key: compiler.err.premature.eof\n+ \/\/ options: --enable-preview -source 20\n+\n+import java.lang.template.*;\n+\n+class StringTemplateUnclosedTextBlock {\n+    String m() {\n+        int x = 10;\n+        return STR.\"\"\"\n+                aaa\n+                \\{x\n+                \"\"\"\n+        ;\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/StringTemplateUnclosedTextBlock.java","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -1911,0 +1911,46 @@\n+    @Test\n+    void testStringTemplate1() throws IOException {\n+        String code = \"\"\"\n+                      package test;\n+                      public class Test {\n+                           Test(int a) {\n+                               String s = \"prefix \\\\{a} suffix\";\n+                           }\n+                      }\n+                      \"\"\";\n+\n+        JavacTaskImpl ct = (JavacTaskImpl) tool.getTask(null, fm, null,\n+                null, null, Arrays.asList(new MyFileObject(code)));\n+        CompilationUnitTree cut = ct.parse().iterator().next();\n+        ClassTree clazz = (ClassTree) cut.getTypeDecls().get(0);\n+        MethodTree constr = (MethodTree) clazz.getMembers().get(0);\n+        VariableTree decl = (VariableTree) constr.getBody().getStatements().get(0);\n+        SourcePositions sp = Trees.instance(ct).getSourcePositions();\n+        int initStart = (int) sp.getStartPosition(cut, decl.getInitializer());\n+        int initEnd   = (int) sp.getEndPosition(cut, decl.getInitializer());\n+        assertEquals(\"correct templated String span expected\", code.substring(initStart, initEnd), \"\\\"prefix \\\\{a} suffix\\\"\");\n+    }\n+\n+    @Test\n+    void testStringTemplate2() throws IOException {\n+        String code = \"\"\"\n+                      package test;\n+                      public class Test {\n+                           Test(int a) {\n+                               String s = STR.\"prefix \\\\{a} suffix\";\n+                           }\n+                      }\n+                      \"\"\";\n+\n+        JavacTaskImpl ct = (JavacTaskImpl) tool.getTask(null, fm, null,\n+                null, null, Arrays.asList(new MyFileObject(code)));\n+        CompilationUnitTree cut = ct.parse().iterator().next();\n+        ClassTree clazz = (ClassTree) cut.getTypeDecls().get(0);\n+        MethodTree constr = (MethodTree) clazz.getMembers().get(0);\n+        VariableTree decl = (VariableTree) constr.getBody().getStatements().get(0);\n+        SourcePositions sp = Trees.instance(ct).getSourcePositions();\n+        int initStart = (int) sp.getStartPosition(cut, decl.getInitializer());\n+        int initEnd   = (int) sp.getEndPosition(cut, decl.getInitializer());\n+        assertEquals(\"correct templated String span expected\", code.substring(initStart, initEnd), \"STR.\\\"prefix \\\\{a} suffix\\\"\");\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/parser\/JavacParserTest.java","additions":47,"deletions":1,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -0,0 +1,240 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 0000000\n+ * @summary Exercise javac handing of templated strings.\n+ * @library \/tools\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ * @build toolbox.ToolBox toolbox.JavacTask\n+ * @run main Basic\n+ *\/\n+\n+\n+import toolbox.JavacTask;\n+import toolbox.JavaTask;\n+import toolbox.Task;\n+import toolbox.ToolBox;\n+\n+public class Basic {\n+    private static ToolBox TOOLBOX = new ToolBox();\n+    private static final String JAVA_VERSION = System.getProperty(\"java.specification.version\");\n+\n+    public static void main(String... arg) {\n+        primitivesTest();\n+        missingPartsTest();\n+        expressionsTest();\n+        invalidExpressionsTest();\n+        processorTest();\n+    }\n+\n+    \/*\n+     * Primitive types test.\n+     *\/\n+    static void primitivesTest() {\n+        for (String type : new String[] {\n+            \"byte\",\n+            \"short\",\n+            \"int\",\n+            \"long\",\n+            \"float\",\n+            \"double\"\n+        }) {\n+            compPass(type + \" x = 10; \" + type + \"  y = 20; StringTemplate result = RAW.\\\"\\\\{x} + \\\\{y} = \\\\{x + y}\\\";\");\n+        }\n+    }\n+\n+    \/*\n+     * Missing parts test.\n+     *\/\n+    static void missingPartsTest() {\n+        compFail(\"\"\"\n+            int x = 10;\n+            StringTemplate result = RAW.\"\\\\{x\";\n+        \"\"\");\n+        compFail(\"\"\"\n+            int x = 10;\n+            StringTemplate result = RAW.\"\\\\{{x}\";\n+        \"\"\");\n+        compFail(\"\"\"\n+            int x = 10;\n+            StringTemplate result = RAW.\"\\\\{x + }\";\n+        \"\"\");\n+        compFail(\"\"\"\n+            int x = 10;\n+            StringTemplate result = RAW.\"\\\\{ * x }\";\n+        \"\"\");\n+        compFail(\"\"\"\n+            int x = 10;\n+            StringTemplate result = RAW.\"\\\\{ (x + x }\";\n+        \"\"\");\n+    }\n+\n+    \/*\n+     * Expressions test.\n+     *\/\n+    static void expressionsTest() {\n+        compPass(\"\"\"\n+            int x = 10;\n+            int[] y = new int[] { 10, 20, 30 };\n+            StringTemplate result1 = RAW.\"\\\\{x + 1}\";\n+            StringTemplate result2 = RAW.\"\\\\{x + x}\";\n+            StringTemplate result3 = RAW.\"\\\\{x - x}\";\n+            StringTemplate result4 = RAW.\"\\\\{x * x}\";\n+            StringTemplate result5 = RAW.\"\\\\{x \/ x}\";\n+            StringTemplate result6 = RAW.\"\\\\{x % x}\";\n+            StringTemplate result7 = RAW.\"\\\\{x + (x + x)}\";\n+            StringTemplate result8 = RAW.\"\\\\{y[x - 9]}\";\n+            StringTemplate result9 = RAW.\"\\\\{System.out}\";\n+            StringTemplate result10 = RAW.\\\"\"\"\n+                    \\\\{ \"a string\" }\n+                    \\\"\"\";\n+                    \"\"\");\n+        compPass(\"\"\"\n+            StringTemplate result = RAW.\\\"\"\"\n+                 \\\\{\n+                     new Collection<String>() {\n+                          @Override public int size() { return 0; }\n+                          @Override public boolean isEmpty() { return false; }\n+                          @Override public boolean contains(Object o) { return false; }\n+                          @Override public Iterator<String> iterator() { return null; }\n+                          @Override public Object[] toArray() { return new Object[0]; }\n+                          @Override public <T> T[] toArray(T[] a) { return null; }\n+                          @Override public boolean add(String s) { return false; }\n+                          @Override public boolean remove(Object o) { return false; }\n+                          @Override public boolean containsAll(Collection<?> c) { return false; }\n+                          @Override public boolean addAll(Collection<? extends String> c) { return false; }\n+                          @Override public boolean removeAll(Collection<?> c) { return false; }\n+                          @Override public boolean retainAll(Collection<?> c) { return false; }\n+                          @Override public void clear() { }\n+                      }\n+                 }\n+                 \\\"\"\";\n+         \"\"\");\n+    }\n+\n+    \/*\n+     * Invalid expressions test.\n+     *\/\n+    static void invalidExpressionsTest() {\n+        compFail(\"\"\"\n+            int x = 10;\n+            StringTemplate result = RAW.\"\\\\{ (x == x }\";\n+        \"\"\");\n+        compFail(\"\"\"\n+            int x = 10;\n+            StringTemplate result = RAW.\"\\\\{ true ?  : x - 1 }\";\n+        \"\"\");\n+        compFail(\"\"\"\n+             String result = RAW.\"\\\\{ 'a }\";\n+        \"\"\");\n+        compFail(\"\"\"\n+            int x = 10;\n+            StringTemplate result = RAW.\"\\\\{ Math.min(, x - 1) }\";\n+        \"\"\");\n+        compFail(\"\"\"\n+            int x = 10;\n+            StringTemplate result = RAW.\"\\\\{ \\\\tx }\";\n+        \"\"\");\n+    }\n+\n+    \/*\n+     * Processor test.\n+     *\/\n+    static void processorTest() {\n+        compPass(\"\"\"\n+         int x = 10, y = 20;\n+         String string = STR.\"\\\\{x} + \\\\{y} = \\\\{x + y}\";\n+         \"\"\");\n+        compFail(\"\"\"\n+         int x = 10, y = 20;\n+         String processor = \"abc\";\n+         String string = processor.\"\\\\{x} + \\\\{y} = \\\\{x + y}\";\n+         \"\"\");\n+        compFail(\"\"\"\n+         int x = 10, y = 20;\n+         long processor = 100;\n+         String string = processor.\"\\\\{x} + \\\\{y} = \\\\{x + y}\";\n+         \"\"\");\n+    }\n+\n+    \/*\n+     * Test source for successful compile.\n+     *\/\n+    static void compPass(String code) {\n+        String source = \"\"\"\n+            import java.lang.template.*;\n+            import java.util.*;\n+            import static java.lang.template.StringTemplate.RAW;\n+            public class TEST {\n+                public static void main(String... arg) {\n+            \"\"\" +\n+            code.indent(8) +\n+            \"\"\"\n+                }\n+            }\n+            \"\"\";\n+        String output = new JavacTask(TOOLBOX)\n+                .sources(source)\n+                .classpath(\".\")\n+                .options(\"-encoding\", \"utf8\", \"--enable-preview\", \"-source\", JAVA_VERSION)\n+                .run()\n+                .writeAll()\n+                .getOutput(Task.OutputKind.DIRECT);\n+\n+        if (output.contains(\"compiler.err\")) {\n+            throw new RuntimeException(\"Error detected\");\n+        }\n+    }\n+\n+    \/*\n+     * Test source for unsuccessful compile and specific error.\n+     *\/\n+    static void compFail(String code) {\n+        String source = \"\"\"\n+            import java.lang.template.*;\n+            import java.util.*;\n+            import static java.lang.template.StringTemplate.RAW;\n+            public class TEST {\n+                public static void main(String... arg) {\n+            \"\"\" +\n+            code.indent(8) +\n+            \"\"\"\n+                }\n+            }\n+            \"\"\";\n+        String errors = new JavacTask(TOOLBOX)\n+                .sources(source)\n+                .classpath(\".\")\n+                .options(\"-XDrawDiagnostics\", \"-encoding\", \"utf8\", \"--enable-preview\", \"-source\", JAVA_VERSION)\n+                .run(Task.Expect.FAIL)\n+                .writeAll()\n+                .getOutput(Task.OutputKind.DIRECT);\n+\n+        if (!errors.contains(\"compiler.err\")) {\n+            throw new RuntimeException(\"No error detected\");\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/template\/Basic.java","additions":240,"deletions":0,"binary":false,"changes":240,"status":"added"},{"patch":"@@ -0,0 +1,107 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Verify proper behavior of TreeScanner w.r.t. templated Strings\n+ * @modules jdk.compiler\n+ *\/\n+\n+import java.io.*;\n+import java.util.*;\n+import javax.tools.*;\n+import com.sun.source.tree.*;\n+import com.sun.source.util.*;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+\n+public class TreeScannerTest {\n+    private static final String JAVA_VERSION = System.getProperty(\"java.specification.version\");\n+\n+    public static void main(String... args) throws Exception {\n+        JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();\n+        String code = \"\"\"\n+                      public class Test {\n+                          private void test(int a) {\n+                              String s1 = TEST.\"p\\\\{a}s\";\n+                              String s2 = \"p\\\\{a}s\";\n+                          }\n+                      }\n+                      \"\"\";\n+        JavacTask task = (JavacTask) compiler.getTask(null, null, null,\n+            List.of(\"--enable-preview\", \"-source\", JAVA_VERSION), null, List.of(new TestJFO(code)));\n+        StringBuilder output = new StringBuilder();\n+        TreeScanner<Void,Void> checker = new TreeScanner<Void, Void>() {\n+            private boolean log;\n+\n+            @Override\n+            public Void visitStringTemplate(StringTemplateTree node, Void p) {\n+                boolean prevLog = log;\n+                try {\n+                    log = true;\n+                    return super.visitStringTemplate(node, p);\n+                } finally {\n+                    log = prevLog;\n+                }\n+            }\n+\n+            @Override\n+            public Void scan(Tree tree, Void p) {\n+                if (log) {\n+                    output.append(\"(\");\n+                    output.append(tree != null ? tree.getKind() : \"null\");\n+                    try {\n+                        return super.scan(tree, p);\n+                    } finally {\n+                        output.append(\")\");\n+                    }\n+                } else {\n+                    return super.scan(tree, p);\n+                }\n+            }\n+\n+        };\n+\n+        checker.scan(task.parse(), null);\n+\n+        String expected = \"(IDENTIFIER)(IDENTIFIER)(null)(IDENTIFIER)\";\n+        if (!expected.equals(output.toString())) {\n+            throw new AssertionError(\"expected output not found, found: \" + output);\n+        }\n+    }\n+\n+    private static final class TestJFO extends SimpleJavaFileObject {\n+        private final String code;\n+\n+        public TestJFO(String code) throws URISyntaxException, IOException {\n+            super(new URI(\"mem:\/\/Test.java\"), Kind.SOURCE);\n+            this.code = code;\n+        }\n+\n+        @Override\n+        public CharSequence getCharContent(boolean ignoreEncodingErrors) throws IOException {\n+            return code;\n+        }\n+\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/template\/TreeScannerTest.java","additions":107,"deletions":0,"binary":false,"changes":107,"status":"added"},{"patch":"@@ -126,0 +126,4 @@\n+            case TEMPLATE:\n+                ok = ok & verify(k, i, i == StringTemplateTree.class);\n+                break;\n+\n","filename":"test\/langtools\/tools\/javac\/tree\/TreeKindTest.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,78 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang.template;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import static java.util.FormatProcessor.FMT;\n+\n+\/*\n+ * This benchmark measures StringTemplate.FMT FormatProcessor performance;\n+ * exactly mirroring {@link org.openjdk.bench.java.lang.StringFormat} benchmark\n+ *\/\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 3, jvmArgsAppend = \"--enable-preview\")\n+public class StringTemplateFMT {\n+\n+    public String s = \"str\";\n+    public int i = 17;\n+\n+    @Benchmark\n+    public String stringFormat() {\n+        return FMT.\"%s\\{s}\";\n+    }\n+\n+    @Benchmark\n+    public String stringIntFormat() {\n+        return FMT.\"%s\\{s} %d\\{i}\";\n+    }\n+\n+    @Benchmark\n+    public String widthStringFormat() {\n+        return FMT.\"%3s\\{s}\";\n+    }\n+\n+    @Benchmark\n+    public String widthStringIntFormat() {\n+        return FMT.\"%3s\\{s} %d\\{i}\";\n+    }\n+\n+    @Benchmark\n+    public String complexFormat() {\n+        return FMT.\"%3s\\{s} %10d\\{i} %4S\\{s} %04X\\{i} %4S\\{s} %04X\\{i} %4S\\{s} %04X\\{i}\";\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/template\/StringTemplateFMT.java","additions":78,"deletions":0,"binary":false,"changes":78,"status":"added"}]}