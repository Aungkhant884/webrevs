{"files":[{"patch":"@@ -122,0 +122,1 @@\n+    @PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/StringConcatFactory.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -171,0 +171,3 @@\n+     *\n+     * @implSpec The default implementation returns the result of invoking\n+     * {@code StringTemplate.interpolate(this.fragments(), this.values())}.\n@@ -197,1 +200,3 @@\n-     * @implNote The default implementation invokes {@code processor.process(this)}.\n+     * @implSpec The default implementation returns the result of invoking\n+     * {@code processor.process(this)}. If the invocation throws an exception that\n+     * exception is forwarded to the caller.\n@@ -311,1 +316,2 @@\n-     * @throws NullPointerException if stringTemplates is null or if any of the elements are null\n+     * @throws NullPointerException if stringTemplates is null or if any of the\n+     * {@code stringTemplates} are null\n@@ -322,0 +328,30 @@\n+    \/**\n+     * Combine a list of {@link StringTemplate StringTemplates} into a single\n+     * {@link StringTemplate}.\n+     * {@snippet :\n+     * StringTemplate st = StringTemplate.combine(List.of(RAW.\"\\{a}\", RAW.\"\\{b}\", RAW.\"\\{c}\"));\n+     * assert st.interpolate().equals(RAW.\"\\{a}\\{b}\\{c}\");\n+     * }\n+     * Fragment lists from each {@link StringTemplate} are merged such that the last fragment\n+     * from the previous {@link StringTemplate} is concatenated with the first fragment of the next\n+     * {@link StringTemplate}. Values lists are simply concatenated to produce a single values list.\n+     * The result is a well-formed {@link StringTemplate} with n+1 fragments and n values, where\n+     * n is the total of number of values across all the supplied\n+     * {@link StringTemplate StringTemplates}.\n+     *\n+     * @param stringTemplates  list of {@link StringTemplate}\n+     *\n+     * @return combined {@link StringTemplate}\n+     *\n+     * @throws NullPointerException if stringTemplates is null or if any of the\n+     * its elements are null\n+     *\n+     * @implNote If {@code stringTemplates.size() == 0} then a {@link StringTemplate} with\n+     * an empty fragment and no values is returned, as if invoking\n+     * <code>StringTemplate.of(\"\")<\/code> . If only {@code stringTemplates.size() == 1}\n+     * then that element is returned unchanged.\n+     *\/\n+    static StringTemplate combine(List<StringTemplate> stringTemplates) {\n+        return TemplateSupport.combine(stringTemplates.toArray(new StringTemplate[0]));\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/template\/StringTemplate.java","additions":38,"deletions":2,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n- * FormatProcessor fmt = new FormatProcessor(Locale.ROOT);\n+ * FormatProcessor fmt = FormatProcessor.create(Locale.ROOT);\n@@ -56,1 +56,1 @@\n- * FormatProcessor fmt = new FormatProcessor(Locale.ROOT);\n+ * FormatProcessor fmt = FormatProcessor.create(Locale.ROOT);\n@@ -77,1 +77,1 @@\n- * FormatProcessor thaiFMT = new FormatProcessor(locale);\n+ * FormatProcessor thaiFMT = FormatProcessor.create(locale);\n@@ -110,1 +110,1 @@\n-    public FormatProcessor(Locale locale) {\n+    private FormatProcessor(Locale locale) {\n@@ -114,0 +114,14 @@\n+    \/**\n+     * Create a new {@link FormatProcessor} using the specified locale.\n+     *\n+     * @param locale {@link Locale} used to format\n+     *\n+     * @return a new instance of {@link FormatProcessor}\n+     *\n+     * @throws java.lang.NullPointerException if locale is null\n+     *\/\n+    public static FormatProcessor create(Locale locale) {\n+        Objects.requireNonNull(locale);\n+        return new FormatProcessor(locale);\n+    }\n+\n@@ -164,1 +178,1 @@\n-     * FormatProcessor THAI_FMT = new FormatProcessor(Locale.forLanguageTag(\"th-TH-u-nu-thai\"));\n+     * FormatProcessor THAI_FMT = FormatProcessor.create(Locale.forLanguageTag(\"th-TH-u-nu-thai\"));\n@@ -268,1 +282,1 @@\n-    public static final FormatProcessor FMT = new FormatProcessor(Locale.ROOT);\n+    public static final FormatProcessor FMT = FormatProcessor.create(Locale.ROOT);\n","filename":"src\/java.base\/share\/classes\/java\/util\/FormatProcessor.java","additions":20,"deletions":6,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -426,0 +426,4 @@\n+        ASSERT(StringTemplate.combine(src), src);\n+        ASSERT(StringTemplate.combine().interpolate(), \"\");\n+        ASSERT(StringTemplate.combine(List.of(src, src)).interpolate(),\n+                RAW.\"\\{x} + \\{y} = \\{x + y}\\{x} + \\{y} = \\{x + y}\".interpolate());\n","filename":"test\/jdk\/java\/lang\/template\/Basic.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-        FormatProcessor thaiFormat = new FormatProcessor(thai);\n+        FormatProcessor thaiFormat = FormatProcessor.create(thai);\n","filename":"test\/jdk\/java\/lang\/template\/FormatterBuilder.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -241,1 +241,1 @@\n-                static final FormatProcessor FMT = new FormatProcessor(Locale.US);\n+                static final FormatProcessor FMT = FormatProcessor.create(Locale.US);\n","filename":"test\/jdk\/java\/lang\/template\/StringTemplateTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}