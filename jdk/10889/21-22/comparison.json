{"files":[{"patch":"@@ -34,5 +34,2 @@\n- * {@link StringTemplate StringTemplates} are runtime representations of\n- * Java string templates and text block templates. Libraries may produce\n- * {@link StringTemplate} instances as long as they conform to the requirements\n- * of this interface. Like {@link String}, instances of {@link StringTemplate}\n- * implementations are considered immutable.\n+ * {@link StringTemplate StringTemplates} is the run-time representation of a\n+ * string template or text block template in a template expression.\n@@ -40,2 +37,7 @@\n- * Implementations of this interface must minimally implement the methods\n- * {@link StringTemplate#fragments()} and {@link StringTemplate#values()}.\n+ * In the source code of a Java program, a string template or text block template\n+ * contains an interleaved succession of <em>fragment literals<\/em> and <em>embedded\n+ * expressions<\/em>. The {@link StringTemplate#fragments()} method returns the\n+ * fragment literals, and the {@link StringTemplate#values()} method returns the\n+ * results of evaluating the embedded expressions. {@link StringTemplate} does not\n+ * provide access to the source code of the embedded expressions themselves; it is\n+ * not a compile-time representation of a string template or text block template.\n@@ -43,10 +45,5 @@\n- * The {@link StringTemplate#fragments()} method must return an immutable\n- * {@code List<String>} consistent with the string template body. The list\n- * contains the string of characters preceding each of the embedded expressions\n- * plus the string of characters following the last embedded expression. The order\n- * of the strings is left to right as they appear in the string template.\n- * For example; {@snippet :\n- * StringTemplate st = RAW.\"The \\{name} and \\{address} of the resident.\";\n- * List<String> fragments = st.fragments();\n- * }\n- * {@code fragments} will be equivalent to <code>List.of(\"The \", \" and \", \" of the resident.\")<\/code>.\n+ * {@link StringTemplate} is primarily used in conjunction with a template processor\n+ * to produce a string or other meaningful value. Evaluation of a template expression\n+ * first produces an instance of {@link StringTemplate}, representing the template\n+ * of the template expression, and then passes the instance to the template processor\n+ * given by the template expression.\n@@ -54,7 +51,2 @@\n- * The {@link StringTemplate#values()} method returns an immutable {@code\n- * List<Object>} of values accumulated by evaluating embedded expressions prior\n- * to instantiating the {@link StringTemplate}. The values are accumulated left\n- * to right. The first element of the list is the result of the leftmost\n- * embedded expression. The last element of the list is the result of the\n- * rightmost embedded expression.\n- * For example,\n+ * For example, the following code contains a template expression that uses the template\n+ * processor {@code RAW}, which simply yields the {@link StringTemplate} passed to it:\n@@ -65,0 +57,1 @@\n+ * List<String> fragments = st.fragments();\n@@ -67,1 +60,2 @@\n- * {@code values} will be the equivalent of <code>List.of(x, y, x + y)<\/code>.\n+ * {@code fragments} will be equivalent to {@code List.of(\"\", \" + \", \" = \", \"\")}\n+ * and {@code values} will be the equivalent of {@code List.of(10, 20, 30)}.\n@@ -69,4 +63,2 @@\n- * {@link StringTemplate StringTemplates} are primarily used in conjunction\n- * with {@linkplain  ValidatingProcessor template processors} to produce meaningful\n- * results. For example, if a user wants string interpolation, then they can use a string template\n- * expression with the standard {@link StringTemplate#STR} processor.\n+ * The following code contains a template expression with the same template but a\n+ * different template processor:\n@@ -76,8 +68,1 @@\n- * String result = STR.\"\\{x} + \\{y} = \\{x + y}\";\n- * }\n- * {@code result} will be equivalent to <code>\"10 + 20 = 30\"<\/code>.\n- * <p>\n- * The {@link StringTemplate#process(ValidatingProcessor)} method supplies an\n- * alternative to using string template expressions.\n- * {@snippet :\n- * String result = RAW.\"\\{x} + \\{y} = \\{x + y}\".process(STR);\n+ * String s = STR.\"\\{x} + \\{y} = \\{x + y}\";\n@@ -85,3 +70,5 @@\n- * In addition to string template expressions, the factory methods\n- * {@link StringTemplate#of(String)} and {@link StringTemplate#of(List, List)}\n- * can be used to construct {@link StringTemplate StringTemplates}.\n+ * When the template expression is evaluated, an instance of {@link StringTemplate} is\n+ * produced that returns the same lists from {@link StringTemplate#fragments()} and\n+ * {@link StringTemplate#values()} as shown above. The {@code STR} template processor\n+ * uses these lists to yield an interpolated string. {@code s} will be equivalent to\n+ * {@code \"10 + 20 = 30\"}.\n@@ -89,5 +76,2 @@\n- * The {@link StringTemplate#interpolate()} method provides a simple way to produce a\n- * string interpolation of the {@link StringTemplate}.\n- * <p>\n- * {@linkplain ValidatingProcessor Template processors} typically use the following code\n- * pattern to perform composition:\n+ * The {@code interpolate()} method provides a direct way to perform string interpolation\n+ * of a {@link StringTemplate}. Template processors can use the following code pattern:\n@@ -96,3 +80,2 @@\n- * List<Object> values = st.values();\n- * \/\/ check or manipulate the fragments and\/or values\n- * ...\n+ * List<Object> values    = st.values();\n+ * ... check or manipulate the fragments and\/or values ...\n@@ -101,0 +84,8 @@\n+ * The {@link StringTemplate#process(ValidatingProcessor)} method provides an\n+ * alternative to using string template expressions.\n+ * {@snippet :\n+ * StringTemplate st = RAW.\"\\{x} + \\{y} = \\{x + y}\";\n+ * String result = st.process(STR);\n+ * }\n+ * The factory methods {@link StringTemplate#of(String)} and\n+ * {@link StringTemplate#of(List, List)} can be used to construct a {@link StringTemplate}.\n@@ -102,2 +93,1 @@\n- * @implSpec An instance of {@link StringTemplate} is immutable. Also, the\n- * fragment list size must be one more than the values list size.\n+ * @jls 15.8.6\n@@ -110,0 +100,9 @@\n+ * @implNote Libraries may produce {@link StringTemplate} instances as long as they\n+ * conform to the requirements of this interface.\n+ * Implementations of {@link StringTemplate} must minimally implement the\n+ * methods {@link StringTemplate#fragments()} and {@link StringTemplate#values()}.\n+ * Instances of {@link StringTemplate} are considered immutable. To preserve the\n+ * semantics of string templates and text block templates, the list returned by\n+ * {@link StringTemplate#fragments()} must be one element larger than the list returned\n+ * by {@link StringTemplate#values()}.\n+ *\n@@ -124,2 +123,2 @@\n-     * <code>fragments<\/code> will be equivalent to\n-     * <code>List.of(\"The student \", \" is in \", \"'s class room.\")<\/code>\n+     * {@code fragments} will be equivalent to\n+     * {@code List.of(\"The student \", \" is in \", \"'s class room.\")}\n@@ -142,1 +141,1 @@\n-     * <code>values<\/code> will be equivalent to <code>List.of(student, teacher)<\/code>\n+     * {@code values} will be equivalent to {@code List.of(student, teacher)}\n@@ -160,1 +159,1 @@\n-     * <code>string<\/code> will be equivalent to <code>\"The student Mary is in Johnson's class room.\"<\/code>\n+     * {@code string} will be equivalent to {@code \"The student Mary is in Johnson's class room.\"}\n@@ -184,1 +183,1 @@\n-     * @return constructed object of type <code>R<\/code>\n+     * @return constructed object of type {@code R}\n@@ -220,1 +219,1 @@\n-     * <code>StringTemplate.of(List.of(string), List.of())<\/code>.\n+     * {@code StringTemplate.of(List.of(string), List.of())}.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/template\/StringTemplate.java","additions":55,"deletions":56,"binary":false,"changes":111,"status":"modified"},{"patch":"@@ -77,1 +77,0 @@\n-import com.sun.tools.javac.code.Types;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/ArgumentAttr.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -34,3 +34,0 @@\n-import com.sun.tools.javac.code.Symbol.*;\n-import com.sun.tools.javac.code.Symbol.OperatorSymbol.AccessCode;\n-import com.sun.tools.javac.code.Type.*;\n@@ -40,1 +37,0 @@\n-import com.sun.tools.javac.resources.CompilerProperties.Errors;\n@@ -43,1 +39,0 @@\n-import com.sun.tools.javac.tree.JCTree.*;\n@@ -45,1 +40,0 @@\n-import com.sun.tools.javac.util.List;\n@@ -47,0 +41,10 @@\n+import com.sun.tools.javac.util.List;\n+\n+import com.sun.tools.javac.code.Symbol.*;\n+import com.sun.tools.javac.code.Symbol.OperatorSymbol.AccessCode;\n+import com.sun.tools.javac.resources.CompilerProperties.Errors;\n+import com.sun.tools.javac.tree.JCTree.*;\n+import com.sun.tools.javac.code.Type.*;\n+\n+import com.sun.tools.javac.jvm.Target;\n+import com.sun.tools.javac.tree.EndPosTable;\n@@ -50,1 +54,0 @@\n-import static com.sun.tools.javac.code.Kinds.Kind.*;\n@@ -53,0 +56,1 @@\n+import static com.sun.tools.javac.code.Kinds.Kind.*;\n@@ -54,0 +58,4 @@\n+import com.sun.tools.javac.tree.JCTree.JCBreak;\n+import com.sun.tools.javac.tree.JCTree.JCCase;\n+import com.sun.tools.javac.tree.JCTree.JCExpression;\n+import com.sun.tools.javac.tree.JCTree.JCExpressionStatement;\n@@ -55,0 +63,1 @@\n+import com.sun.tools.javac.tree.JCTree.JCSwitchExpression;\n@@ -2601,1 +2610,1 @@\n-     * @param tree                an expression tree\n+     * @param tree                a class declaration tree\n@@ -2613,1 +2622,1 @@\n-            JCTree tree,\n+            JCClassDecl tree,\n@@ -2625,2 +2634,1 @@\n-                isStatic ? indyType.argtypes\n-                         : indyType.argtypes.prepend(TreeInfo.symbol(tree).type),\n+                isStatic ? List.nil() : indyType.argtypes.prepend(tree.sym.type),\n@@ -2868,1 +2876,0 @@\n-\n@@ -3121,1 +3128,0 @@\n-\n@@ -4165,1 +4171,0 @@\n-\n@@ -4217,1 +4222,0 @@\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Lower.java","additions":19,"deletions":15,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -700,1 +700,1 @@\n-        JCExpression t = F.at(pos).StringTemplate(processor, fragments, expressions);\n+        JCExpression t = toP(F.at(pos).StringTemplate(processor, fragments, expressions));\n@@ -1715,4 +1715,1 @@\n-                    typeArgs = null;\n-                    \/\/ Uncomment to not allow follow on DOT\n-                    \/\/ return t;\n-                 } else {\n+                } else {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"}]}