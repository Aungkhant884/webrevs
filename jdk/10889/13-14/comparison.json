{"files":[{"patch":"@@ -136,1 +136,1 @@\n-     * @since 19\n+     * @since 20\n@@ -357,1 +357,1 @@\n-     * @since 19\n+     * @since 20\n@@ -379,1 +379,1 @@\n-     * @since 19\n+     * @since 20\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StringConcatHelper.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,253 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.runtime;\n+\n+import java.lang.invoke.CallSite;\n+import java.lang.invoke.ConstantCallSite;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.template.ProcessorLinkage;\n+import java.lang.template.StringTemplate;\n+import java.lang.template.ValidatingProcessor;\n+import java.util.List;\n+import java.util.Objects;\n+\n+import jdk.internal.access.JavaTemplateAccess;\n+import jdk.internal.access.JavaUtilCollectionAccess;\n+import jdk.internal.access.SharedSecrets;\n+import jdk.internal.javac.PreviewFeature;\n+\n+\/**\n+ * Manages string template bootstrapping and creation. These methods may be used, for example,\n+ * by Java compiler implementations to implement the bodies of methods for {@link StringTemplate}\n+ * objects.\n+ * <p>\n+ * Bootstraps in the form of {@code (Lookup, String, MethodType)(String[], Object[])} are used\n+ * to create {@link StringTemplate StringTemplates} that have more than\n+ * {@link java.lang.invoke.StringConcatFactory#MAX_INDY_CONCAT_ARG_SLOTS} values.\n+ * <p>\n+ * Bootstraps in the form of {@code (Lookup, String, MethodType, String...)(...)} are used to create\n+ * optimized {@link StringTemplate StringTemplates} based on StringTemplateImpl.\n+ * <p>\n+ * Bootstraps in the for of (Lookup, String, MethodType, MethodHandle, String...)\n+ * (VerifyingProcessor, ...) are used to implement specialized processors for\n+ * {@link ProcessorLinkage} implementing processors.\n+ *\n+ * @since 20\n+ *\/\n+@PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n+public final class TemplateRuntime {\n+    private static final JavaTemplateAccess JTA = SharedSecrets.getJavaTemplateAccess();\n+    private static final JavaUtilCollectionAccess JUCA = SharedSecrets.getJavaUtilCollectionAccess();\n+\n+    \/**\n+     * {@link MethodHandle} to {@link TemplateRuntime#defaultProcess}.\n+     *\/\n+    private static final MethodHandle DEFAULT_PROCESS_MH;\n+\n+    \/**\n+     * {@link MethodHandle} to {@link TemplateRuntime#fromArrays}.\n+     *\/\n+    private static final MethodHandle FROM_ARRAYS;\n+\n+    \/**\n+     * Initialize {@link MethodHandle MethodHandles}.\n+     *\/\n+    static {\n+        try {\n+            MethodHandles.Lookup lookup = MethodHandles.lookup();\n+\n+            MethodType mt = MethodType.methodType(Object.class,\n+                    List.class, ValidatingProcessor.class, Object[].class);\n+            DEFAULT_PROCESS_MH = lookup.findStatic(TemplateRuntime.class, \"defaultProcess\", mt);\n+\n+            mt = MethodType.methodType(StringTemplate.class, String[].class, Object[].class);\n+            FROM_ARRAYS = lookup.findStatic(TemplateRuntime.class, \"fromArrays\", mt);\n+        } catch (ReflectiveOperationException ex) {\n+            throw new AssertionError(\"string bootstrap fail\", ex);\n+        }\n+    }\n+\n+    \/**\n+     * Private constructor.\n+     *\/\n+    private TemplateRuntime() {\n+        throw new AssertionError(\"private constructor\");\n+    }\n+\n+    \/**\n+     * String template bootstrap method for creating large string templates.\n+     *\n+     * @param lookup          method lookup\n+     * @param name            method name\n+     * @param type            method type\n+     *\n+     * @return {@link CallSite} to handle create large string template\n+     *\n+     * @throws NullPointerException if any of the arguments is null\n+     * @throws Throwable            if linkage fails\n+     *\/\n+    public static CallSite stringTemplateBSM(\n+            MethodHandles.Lookup lookup,\n+            String name,\n+            MethodType type\n+    ) throws Throwable {\n+        Objects.requireNonNull(lookup, \"lookup is null\");\n+        Objects.requireNonNull(name, \"name is null\");\n+        Objects.requireNonNull(type, \"type is null\");\n+\n+        return new ConstantCallSite(FROM_ARRAYS.asType(type));\n+    }\n+\n+    \/**\n+     * String template bootstrap method for creating string templates.\n+     *\n+     * @param lookup          method lookup\n+     * @param name            method name\n+     * @param type            method type\n+     * @param fragments       fragments from string template\n+     *\n+     * @return {@link CallSite} to handle create string template\n+     *\n+     * @throws NullPointerException if any of the arguments is null\n+     * @throws Throwable            if linkage fails\n+     *\/\n+    public static CallSite stringTemplateBSM(\n+            MethodHandles.Lookup lookup,\n+            String name,\n+            MethodType type,\n+            String... fragments\n+    ) throws Throwable {\n+        Objects.requireNonNull(lookup, \"lookup is null\");\n+        Objects.requireNonNull(name, \"name is null\");\n+        Objects.requireNonNull(type, \"type is null\");\n+        Objects.requireNonNull(fragments, \"fragments is null\");\n+\n+        MethodHandle mh = JTA\n+                .createStringTemplateImplMH(List.of(fragments), type).asType(type);\n+\n+        return new ConstantCallSite(mh);\n+    }\n+\n+    \/**\n+     * String template bootstrap method for static final processors.\n+     *\n+     * @param lookup          method lookup\n+     * @param name            method name\n+     * @param type            method type\n+     * @param processorGetter {@link MethodHandle} to get static final processor\n+     * @param fragments       fragments from string template\n+     *\n+     * @return {@link CallSite} to handle string template processing\n+     *\n+     * @throws NullPointerException if any of the arguments is null\n+     * @throws Throwable            if linkage fails\n+     *\/\n+    public static CallSite stringTemplateBSM(\n+            MethodHandles.Lookup lookup,\n+            String name,\n+            MethodType type,\n+            MethodHandle processorGetter,\n+            String... fragments\n+    ) throws Throwable {\n+        Objects.requireNonNull(lookup, \"lookup is null\");\n+        Objects.requireNonNull(name, \"name is null\");\n+        Objects.requireNonNull(type, \"type is null\");\n+        Objects.requireNonNull(processorGetter, \"processorGetter is null\");\n+        Objects.requireNonNull(fragments, \"fragments is null\");\n+\n+        ValidatingProcessor<?, ?> processor = (ValidatingProcessor<?, ?>)processorGetter.invoke();\n+        MethodHandle mh = processor instanceof ProcessorLinkage processorLinkage\n+                ? processorLinkage.linkage(List.of(fragments), type)\n+                : defaultProcessMethodHandle(type, processor, List.of(fragments));\n+\n+        return new ConstantCallSite(mh);\n+    }\n+\n+    \/**\n+     * Creates a simple {@link StringTemplate} and then invokes the processor's process method.\n+     *\n+     * @param fragments fragments from string template\n+     * @param processor {@link ValidatingProcessor} to process\n+     * @param values    array of expression values\n+     *\n+     * @return result of processing the string template\n+     *\/\n+    private static Object defaultProcess(\n+            List<String> fragments,\n+            ValidatingProcessor<?, ?> processor,\n+            Object[] values\n+    ) throws Throwable {\n+        return processor.process(\n+            StringTemplate.of(fragments, JUCA.listFromTrustedArrayNullsAllowed(values)));\n+    }\n+\n+    \/**\n+     * Generate a {@link MethodHandle} which is effectively invokes\n+     * {@code processor.process(new StringTemplate(fragments, values...)}.\n+     *\n+     * @return default process {@link MethodHandle}\n+     *\/\n+    private static MethodHandle defaultProcessMethodHandle(\n+            MethodType type,\n+            ValidatingProcessor<?, ?> processor,\n+            List<String> fragments\n+    ) {\n+        MethodHandle mh = MethodHandles.insertArguments(DEFAULT_PROCESS_MH, 0, fragments, processor);\n+        return mh.asCollector(Object[].class, type.parameterCount()).asType(type);\n+    }\n+\n+    \/**\n+     * A {@link StringTemplate} where number of value slots exceeds\n+     * {@link java.lang.invoke.StringConcatFactory#MAX_INDY_CONCAT_ARG_SLOTS}.\n+     *\n+     * @param fragments  immutable list of string fragments from string template\n+     * @param values     immutable list of expression values\n+     *\/\n+    private record LargeStringTemplate(List<String> fragments, List<Object> values)\n+            implements StringTemplate {\n+        @Override\n+        public java.lang.String toString() {\n+            return StringTemplate.toString(this);\n+        }\n+    }\n+\n+    \/**\n+     * Used to create a {@link StringTemplate} when number of value slots exceeds\n+     * {@link java.lang.invoke.StringConcatFactory#MAX_INDY_CONCAT_ARG_SLOTS}.\n+     *\n+     * @param fragments  array of string fragments\n+     * @param values     array of values\n+     *\n+     * @return new {@link StringTemplate}\n+     *\/\n+    private static StringTemplate fromArrays(String[] fragments, Object[] values) {\n+        return new LargeStringTemplate(List.of(fragments),\n+                                       JUCA.listFromTrustedArrayNullsAllowed(values));\n+    }\n+}\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/TemplateRuntime.java","additions":253,"deletions":0,"binary":false,"changes":253,"status":"added"},{"patch":"@@ -0,0 +1,1008 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.template;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodHandles.Lookup;\n+import java.lang.invoke.MethodType;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import jdk.internal.javac.PreviewFeature;\n+import jdk.internal.misc.Unsafe;\n+import jdk.internal.vm.annotation.Stable;\n+\n+import static java.lang.invoke.MethodType.methodType;\n+\n+\/**\n+ * A <em>carrier<\/em> is an opaque object that can be used to store component values\n+ * while avoiding primitive boxing associated with collection objects. Component values\n+ * can be primitive or Object.\n+ * <p>\n+ * Clients can create new carrier instances by describing a carrier <em>shape<\/em>, that\n+ * is, a {@linkplain MethodType method type} whose parameter types describe the types of\n+ * the carrier component values, or by providing the parameter types directly.\n+ *\n+ * {@snippet :\n+ * \/\/ Create a carrier for a string and an integer\n+ * CarrierElements elements = CarrierFactory.of(String.class, int.class);\n+ * \/\/ Fetch the carrier constructor MethodHandle\n+ * MethodHandle initializingConstructor = elements.initializingConstructor();\n+ * \/\/ Fetch the list of carrier component MethodHandles\n+ * List<MethodHandle> components = elements.components();\n+ *\n+ * \/\/ Create an instance of the carrier with a string and an integer\n+ * Object carrier = initializingConstructor.invokeExact(\"abc\", 10);\n+ * \/\/ Extract the first component, type string\n+ * String string = (String)components.get(0).invokeExact(carrier);\n+ * \/\/ Extract the second component, type int\n+ * int i = (int)components.get(1).invokeExact(carrier);\n+ * }\n+ *\n+ * Alternatively, the client can use static methods when the carrier use is scattered.\n+ * This is possible since {@link Carriers} ensures that the same underlying carrier\n+ * class is used when the same component types are provided.\n+ *\n+ * {@snippet :\n+ * \/\/ Describe carrier using a MethodType\n+ * MethodType mt = MethodType.methodType(Object.class, String.class, int.class);\n+ * \/\/ Fetch the carrier constructor MethodHandle\n+ * MethodHandle constructor = Carriers.constructor(mt);\n+ * \/\/ Fetch the list of carrier component MethodHandles\n+ * List<MethodHandle> components = Carriers.components(mt);\n+ * }\n+ *\n+ * @implNote The strategy for storing components is deliberately left unspecified\n+ * so that future improvements will not be hampered by issues of backward compatibility.\n+ *\n+ * @since 20\n+ *\/\n+@PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n+final class Carriers {\n+    \/**\n+     * Maximum number of components in a carrier (based on the maximum\n+     * number of args to a constructor.)\n+     *\/\n+    public static final int MAX_COMPONENTS = 255 - \/* this *\/ 1;\n+\n+    \/**\n+     * Number of integer slots used by a long.\n+     *\/\n+    static final int LONG_SLOTS = Long.SIZE \/ Integer.SIZE;\n+\n+    \/*\n+     * Initialize {@link MethodHandle} constants.\n+     *\/\n+    static {\n+        try {\n+            Lookup lookup = MethodHandles.lookup();\n+            FLOAT_TO_INT = lookup.findStatic(Float.class, \"floatToRawIntBits\",\n+                    methodType(int.class, float.class));\n+            INT_TO_FLOAT = lookup.findStatic(Float.class, \"intBitsToFloat\",\n+                    methodType(float.class, int.class));\n+            DOUBLE_TO_LONG = lookup.findStatic(Double.class, \"doubleToRawLongBits\",\n+                    methodType(long.class, double.class));\n+            LONG_TO_DOUBLE = lookup.findStatic(Double.class, \"longBitsToDouble\",\n+                    methodType(double.class, long.class));\n+        } catch (ReflectiveOperationException ex) {\n+            throw new AssertionError(\"carrier static init fail\", ex);\n+        }\n+    }\n+\n+    \/*\n+     * float\/double conversions.\n+     *\/\n+    private static final MethodHandle FLOAT_TO_INT;\n+    private static final MethodHandle INT_TO_FLOAT;\n+    private static final MethodHandle DOUBLE_TO_LONG;\n+    private static final MethodHandle LONG_TO_DOUBLE;\n+\n+    \/**\n+     * Given an initializer {@link MethodHandle} recast and reorder arguments to\n+     * match shape.\n+     *\n+     * @param carrierShape  carrier shape\n+     * @param initializer   carrier constructor to reshape\n+     *\n+     * @return constructor with arguments recasted and reordered\n+     *\/\n+    static MethodHandle reshapeInitializer(CarrierShape carrierShape,\n+                                           MethodHandle initializer) {\n+        int count = carrierShape.count();\n+        Class<?>[] ptypes = carrierShape.ptypes();\n+        int objectIndex = carrierShape.objectOffset() + 1;\n+        int intIndex = carrierShape.intOffset() + 1;\n+        int longIndex = carrierShape.longOffset() + 1;\n+        int[] reorder = new int[count + 1];\n+        Class<?>[] permutePTypes = new Class<?>[count + 1];\n+        MethodHandle[] filters = new MethodHandle[count + 1];\n+        boolean hasFilters = false;\n+        permutePTypes[0] = CarrierObject.class;\n+        reorder[0] = 0;\n+        int index = 1;\n+\n+        for (Class<?> ptype : ptypes) {\n+            MethodHandle filter = null;\n+            int from;\n+\n+            if (!ptype.isPrimitive()) {\n+                from = objectIndex++;\n+                ptype = Object.class;\n+            } else if (ptype == double.class) {\n+                from = longIndex++;\n+                filter = DOUBLE_TO_LONG;\n+            } else if (ptype == float.class) {\n+                from = intIndex++;\n+                filter = FLOAT_TO_INT;\n+            } else if (ptype == long.class) {\n+                from = longIndex++;\n+            } else {\n+                from = intIndex++;\n+                ptype = int.class;\n+            }\n+\n+            permutePTypes[index] = ptype;\n+            reorder[from] = index++;\n+\n+            if (filter != null) {\n+                filters[from] = filter;\n+                hasFilters = true;\n+            }\n+        }\n+\n+        if (hasFilters) {\n+            initializer = MethodHandles.filterArguments(initializer, 0, filters);\n+        }\n+\n+        MethodType permutedMethodType =\n+                methodType(initializer.type().returnType(), permutePTypes);\n+        initializer = MethodHandles.permuteArguments(initializer,\n+                permutedMethodType, reorder);\n+        initializer = MethodHandles.explicitCastArguments(initializer,\n+                methodType(CarrierObject.class, ptypes).insertParameterTypes(0, CarrierObject.class));\n+\n+        return initializer;\n+    }\n+\n+    \/**\n+     * Given components array, recast and reorder components to match shape.\n+     *\n+     * @param carrierShape  carrier reshape\n+     * @param components    carrier components to reshape\n+     *\n+     * @return list of components reshaped\n+     *\/\n+    static List<MethodHandle> reshapeComponents(CarrierShape carrierShape,\n+                                                MethodHandle[] components) {\n+        int count = carrierShape.count();\n+        Class<?>[] ptypes = carrierShape.ptypes();\n+        MethodHandle[] reorder = new MethodHandle[count];\n+        int objectIndex = carrierShape.objectOffset();\n+        int intIndex = carrierShape.intOffset();\n+        int longIndex = carrierShape.longOffset();\n+        int index = 0;\n+\n+        for (Class<?> ptype : ptypes) {\n+            MethodHandle component;\n+\n+            if (!ptype.isPrimitive()) {\n+                component = components[objectIndex++];\n+            } else if (ptype == double.class) {\n+                component = MethodHandles.filterReturnValue(\n+                        components[longIndex++], LONG_TO_DOUBLE);\n+            } else if (ptype == float.class) {\n+                component = MethodHandles.filterReturnValue(\n+                        components[intIndex++], INT_TO_FLOAT);\n+            } else if (ptype == long.class) {\n+                component = components[longIndex++];\n+            } else {\n+                component = components[intIndex++];\n+            }\n+\n+            MethodType methodType = methodType(ptype, CarrierObject.class);\n+            reorder[index++] =\n+                    MethodHandles.explicitCastArguments(component, methodType);\n+        }\n+\n+        return List.of(reorder);\n+    }\n+\n+    \/**\n+     * Factory for carriers that are backed by long[] and Object[].\n+     *\/\n+    static final class CarrierObjectFactory {\n+        \/**\n+         * Unsafe access.\n+         *\/\n+        private static final Unsafe UNSAFE;\n+\n+        \/*\n+         * Constructor accessor MethodHandles.\n+         *\/\n+        private static final MethodHandle CONSTRUCTOR;\n+        private static final MethodHandle GET_LONG;\n+        private static final MethodHandle PUT_LONG;\n+        private static final MethodHandle GET_INTEGER;\n+        private static final MethodHandle PUT_INTEGER;\n+        private static final MethodHandle GET_OBJECT;\n+        private static final MethodHandle PUT_OBJECT;\n+\n+        static {\n+            try {\n+                UNSAFE = Unsafe.getUnsafe();\n+                Lookup lookup = MethodHandles.lookup();\n+                CONSTRUCTOR = lookup.findConstructor(CarrierObject.class,\n+                        methodType(void.class, int.class, int.class));\n+                GET_LONG = lookup.findVirtual(CarrierObject.class, \"getLong\",\n+                        methodType(long.class, int.class));\n+                PUT_LONG = lookup.findVirtual(CarrierObject.class, \"putLong\",\n+                        methodType(CarrierObject.class, int.class, long.class));\n+                GET_INTEGER = lookup.findVirtual(CarrierObject.class, \"getInteger\",\n+                        methodType(int.class, int.class));\n+                PUT_INTEGER = lookup.findVirtual(CarrierObject.class, \"putInteger\",\n+                        methodType(CarrierObject.class, int.class, int.class));\n+                GET_OBJECT = lookup.findVirtual(CarrierObject.class, \"getObject\",\n+                        methodType(Object.class, int.class));\n+                PUT_OBJECT = lookup.findVirtual(CarrierObject.class, \"putObject\",\n+                        methodType(CarrierObject.class, int.class, Object.class));\n+            } catch (ReflectiveOperationException ex) {\n+                throw new AssertionError(\"carrier static init fail\", ex);\n+            }\n+        }\n+\n+        \/**\n+         * Constructor builder.\n+         *\n+         * @param carrierShape  carrier object shape\n+         *\n+         * @return {@link MethodHandle} to generic carrier constructor.\n+         *\/\n+        MethodHandle constructor(CarrierShape carrierShape) {\n+            int longCount = carrierShape.longCount();\n+            int intCount = carrierShape.intCount();\n+            int objectCount = carrierShape.objectCount();\n+            int primitiveCount = carrierShape.primitiveCount();\n+\n+            MethodHandle constructor = MethodHandles.insertArguments(CONSTRUCTOR,\n+                    0, primitiveCount, objectCount);\n+\n+            return constructor;\n+        }\n+\n+        \/**\n+         * Adds constructor arguments for each of the allocated slots.\n+         *\n+         * @param carrierShape  carrier object shape\n+         *\n+         * @return {@link MethodHandle} to specific carrier constructor.\n+         *\/\n+        MethodHandle initializer(CarrierShape carrierShape) {\n+            int longCount = carrierShape.longCount();\n+            int intCount = carrierShape.intCount();\n+            int objectCount = carrierShape.objectCount();\n+            MethodHandle initializer = MethodHandles.identity(CarrierObject.class);\n+\n+            \/\/ long array index\n+            int index = 0;\n+            for (int i = 0; i < longCount; i++) {\n+                MethodHandle put = MethodHandles.insertArguments(PUT_LONG, 1, index++);\n+                initializer = MethodHandles.collectArguments(put, 0, initializer);\n+            }\n+\n+            \/\/ transition to int array index (double number of longs)\n+            index *= LONG_SLOTS;\n+            for (int i = 0; i < intCount; i++) {\n+                MethodHandle put = MethodHandles.insertArguments(PUT_INTEGER, 1, index++);\n+                initializer = MethodHandles.collectArguments(put, 0, initializer);\n+            }\n+\n+            for (int i = 0; i < objectCount; i++) {\n+                MethodHandle put = MethodHandles.insertArguments(PUT_OBJECT, 1, i);\n+                initializer = MethodHandles.collectArguments(put, 0, initializer);\n+            }\n+\n+            return initializer;\n+        }\n+\n+        \/**\n+         * Utility to construct the basic accessors from the components.\n+         *\n+         * @param carrierShape  carrier object shape\n+         *\n+         * @return array of carrier accessors\n+         *\/\n+        MethodHandle[] createComponents(CarrierShape carrierShape) {\n+            int longCount = carrierShape.longCount();\n+            int intCount = carrierShape.intCount();\n+            int objectCount = carrierShape.objectCount();\n+            MethodHandle[] components =\n+                    new MethodHandle[carrierShape.ptypes().length];\n+\n+            \/\/ long array index\n+            int index = 0;\n+            \/\/ component index\n+            int comIndex = 0;\n+            for (int i = 0; i < longCount; i++) {\n+                components[comIndex++] = MethodHandles.insertArguments(GET_LONG, 1, index++);\n+            }\n+\n+            \/\/ transition to int array index (double number of longs)\n+            index *= LONG_SLOTS;\n+            for (int i = 0; i < intCount; i++) {\n+                components[comIndex++] = MethodHandles.insertArguments(GET_INTEGER, 1, index++);\n+            }\n+\n+            for (int i = 0; i < objectCount; i++) {\n+                components[comIndex++] = MethodHandles.insertArguments(GET_OBJECT, 1, i);\n+            }\n+            return components;\n+        }\n+\n+        \/**\n+         * Cache mapping {@link MethodType} to previously defined {@link CarrierElements}.\n+         *\/\n+        private static Map<MethodType, CarrierElements>\n+                methodTypeCache = ReferencedKeyMap.create(() -> new ConcurrentHashMap<>());\n+\n+        \/**\n+         * Permute a raw constructor and component accessor {@link MethodHandle MethodHandles} to\n+         * match the order and types of the parameter types.\n+         *\n+         * @param carrierShape  carrier object shape\n+         *\n+         * @return {@link CarrierElements} instance\n+         *\/\n+        CarrierElements carrier(CarrierShape carrierShape) {\n+            return methodTypeCache.computeIfAbsent(carrierShape.methodType, (mt) -> {\n+                MethodHandle constructor = constructor(carrierShape);\n+                MethodHandle initializer = initializer(carrierShape);\n+                MethodHandle[] components = createComponents(carrierShape);\n+                return new CarrierElements(\n+                        carrierShape,\n+                        CarrierObject.class,\n+                        constructor,\n+                        reshapeInitializer(carrierShape, initializer),\n+                        reshapeComponents(carrierShape, components));\n+            });\n+        }\n+    }\n+\n+    \/**\n+     * Wrapper object for carrier data. Instances types are stored in the {@code objects}\n+     * array, while primitive types are recast to {@code int\/long} and stored in the\n+     * {@code primitives} array. Primitive byte, short, char, boolean and int are stored as\n+     * integers. Longs and doubles are stored as longs.  Longs take up the first part of the\n+     * primitives array using normal indices. Integers follow using int[] indices offset beyond\n+     * the longs using unsafe getInt\/putInt.\n+     *\/\n+    static class CarrierObject {\n+        \/**\n+         * Carrier for primitive values.\n+         *\/\n+        @Stable\n+        private final long[] primitives;\n+\n+        \/**\n+         * Carrier for objects;\n+         *\/\n+        @Stable\n+        private final Object[] objects;\n+\n+        \/**\n+         * Constructor.\n+         *\n+         * @param primitiveCount  slot count required for primitives\n+         * @param objectCount     slot count required for objects\n+         *\/\n+        protected CarrierObject(int primitiveCount, int objectCount) {\n+            this.primitives = createPrimitivesArray(primitiveCount );\n+            this.objects = createObjectsArray(objectCount);\n+        }\n+\n+        \/**\n+         * Create a primitives array of an appropriate length.\n+         *\n+         * @param primitiveCount  slot count required for primitives\n+         *\n+         * @return primitives array of an appropriate length.\n+         *\/\n+        private long[] createPrimitivesArray(int primitiveCount) {\n+            return primitiveCount != 0 ? new long[(primitiveCount + 1) \/ LONG_SLOTS] : null;\n+        }\n+\n+        \/**\n+         * Create a objects array of an appropriate length.\n+         *\n+         * @param objectCount  slot count required for objects\n+         *\n+         * @return objects array of an appropriate length.\n+         *\/\n+        private Object[] createObjectsArray(int objectCount) {\n+            return objectCount != 0 ? new Object[objectCount] : null;\n+        }\n+\n+        \/**\n+         * Compute offset for unsafe access to long.\n+         *\n+         * @param i  index in primitive[]\n+         *\n+         * @return offset for unsafe access\n+         *\/\n+        private static long offsetToLong(int i) {\n+            return Unsafe.ARRAY_LONG_BASE_OFFSET +\n+                    (long)i * Unsafe.ARRAY_LONG_INDEX_SCALE;\n+        }\n+\n+        \/**\n+         * Compute offset for unsafe access to int.\n+         *\n+         * @param i  index in primitive[]\n+         *\n+         * @return offset for unsafe access\n+         *\/\n+        private static long offsetToInt(int i) {\n+            return Unsafe.ARRAY_LONG_BASE_OFFSET +\n+                    (long)i * Unsafe.ARRAY_INT_INDEX_SCALE;\n+        }\n+\n+        \/**\n+         * Compute offset for unsafe access to object.\n+         *\n+         * @param i  index in objects[]\n+         *\n+         * @return offset for unsafe access\n+         *\/\n+        private static long offsetToObject(int i) {\n+            return Unsafe.ARRAY_OBJECT_BASE_OFFSET +\n+                    (long)i * Unsafe.ARRAY_OBJECT_INDEX_SCALE;\n+        }\n+\n+        \/**\n+         * {@return long value at index}\n+         *\n+         * @param i  array index\n+         *\/\n+        private long getLong(int i) {\n+            return CarrierObjectFactory.UNSAFE.getLong(primitives, offsetToLong(i));\n+        }\n+\n+        \/**\n+         * Put a long value into the primitive[].\n+         *\n+         * @param i      array index\n+         * @param value  long value to store\n+         *\n+         * @return this object\n+         *\/\n+        private CarrierObject putLong(int i, long value) {\n+            CarrierObjectFactory.UNSAFE.putLong(primitives, offsetToLong(i), value);\n+\n+            return this;\n+        }\n+\n+        \/**\n+         * {@return int value at index}\n+         *\n+         * @param i  array index\n+         *\/\n+        private int getInteger(int i) {\n+            return CarrierObjectFactory.UNSAFE.getInt(primitives, offsetToInt(i));\n+        }\n+\n+        \/**\n+         * Put a int value into the int[].\n+         *\n+         * @param i      array index\n+         * @param value  int value to store\n+         *\n+         * @return this object\n+         *\/\n+        private CarrierObject putInteger(int i, int value) {\n+            CarrierObjectFactory.UNSAFE.putInt(primitives, offsetToInt(i), value);\n+\n+            return this;\n+        }\n+\n+        \/**\n+         * {@return Object value at index}\n+         *\n+         * @param i  array index\n+         *\/\n+        private Object getObject(int i) {\n+            return CarrierObjectFactory.UNSAFE.getReference(objects, offsetToObject(i));\n+        }\n+\n+        \/**\n+         * Put a object value into the objects[].\n+         *\n+         * @param i      array index\n+         * @param value  object value to store\n+         *\n+         * @return this object\n+         *\/\n+        private CarrierObject putObject(int i, Object value) {\n+            CarrierObjectFactory.UNSAFE.putReference(objects, offsetToObject(i), value);\n+\n+            return this;\n+        }\n+    }\n+\n+    \/**\n+     * Class used to tally ahd track the number of ints, longs and objects.\n+     *\n+     * @param longCount    number of longs and doubles\n+     * @param intCount     number of byte, short, int, chars and booleans\n+     * @param objectCount  number of objects\n+     *\/\n+    private record CarrierCounts(int longCount, int intCount, int objectCount) {\n+        \/**\n+         * Count the number of fields required in each of Object, int and long.\n+         *\n+         * @param ptypes  parameter types\n+         *\n+         * @return a {@link CarrierCounts} instance containing counts\n+         *\/\n+        static CarrierCounts tally(Class<?>[] ptypes) {\n+            return tally(ptypes, ptypes.length);\n+        }\n+\n+        \/**\n+         * Count the number of fields required in each of Object, int and long\n+         * limited to the first {@code n} parameters.\n+         *\n+         * @param ptypes  parameter types\n+         * @param n       number of parameters to check\n+         *\n+         * @return a {@link CarrierCounts} instance containing counts\n+         *\/\n+        private static CarrierCounts tally(Class<?>[] ptypes, int n) {\n+            int longCount = 0;\n+            int intCount = 0;\n+            int objectCount = 0;\n+\n+            for (int i = 0; i < n; i++) {\n+                Class<?> ptype = ptypes[i];\n+\n+                if (!ptype.isPrimitive()) {\n+                    objectCount++;\n+                } else if (ptype == long.class || ptype == double.class) {\n+                    longCount++;\n+                } else {\n+                    intCount++;\n+                }\n+            }\n+\n+            return new CarrierCounts(longCount, intCount, objectCount);\n+        }\n+\n+        \/**\n+         * {@return total number of components}\n+         *\/\n+        private int count() {\n+            return longCount + intCount + objectCount;\n+        }\n+\n+        \/**\n+         * {@return total number of slots}\n+         *\/\n+        private int slotCount() {\n+            return longCount * LONG_SLOTS + intCount + objectCount;\n+        }\n+\n+    }\n+\n+    \/**\n+     * Constructor\n+     *\/\n+    private Carriers() {\n+        throw new AssertionError(\"private constructor\");\n+    }\n+\n+    \/**\n+     * Shape of carrier based on counts of each of the three fundamental data\n+     * types.\n+     *\/\n+    private static class CarrierShape {\n+        \/**\n+         * {@link MethodType} providing types for the carrier's components.\n+         *\/\n+        final MethodType methodType;\n+\n+        \/**\n+         * Counts of different parameter types.\n+         *\/\n+        final CarrierCounts counts;\n+\n+        \/**\n+         * Constructor.\n+         *\n+         * @param methodType  {@link MethodType} providing types for the\n+         *                    carrier's components\n+         *\/\n+        public CarrierShape(MethodType methodType) {\n+            this.methodType = methodType;\n+            this.counts = CarrierCounts.tally(methodType.parameterArray());\n+        }\n+\n+        \/**\n+         * {@return number of long fields needed}\n+         *\/\n+        int longCount() {\n+            return counts.longCount();\n+        }\n+\n+        \/**\n+         * {@return number of int fields needed}\n+         *\/\n+        int intCount() {\n+            return counts.intCount();\n+        }\n+\n+        \/**\n+         * {@return number of object fields needed}\n+         *\/\n+        int objectCount() {\n+            return counts.objectCount();\n+        }\n+\n+        \/**\n+         * {@return slot count required for primitives}\n+         *\/\n+        int primitiveCount() {\n+            return counts.longCount() * LONG_SLOTS + counts.intCount();\n+        }\n+\n+        \/**\n+         * {@return array of parameter types}\n+         *\/\n+        Class<?>[] ptypes() {\n+            return methodType.parameterArray();\n+        }\n+\n+        \/**\n+         * {@return number of components}\n+         *\/\n+        int count() {\n+            return counts.count();\n+        }\n+\n+        \/**\n+         * {@return number of slots used}\n+         *\/\n+        int slotCount() {\n+            return counts.slotCount();\n+        }\n+\n+        \/**\n+         * {@return index of first long component}\n+         *\/\n+        int longOffset() {\n+            return 0;\n+        }\n+\n+        \/**\n+         * {@return index of first int component}\n+         *\/\n+        int intOffset() {\n+            return longCount();\n+        }\n+\n+        \/**\n+         * {@return index of first object component}\n+         *\/\n+        int objectOffset() {\n+            return longCount() + intCount();\n+        }\n+    }\n+\n+    \/**\n+     * This factory class generates {@link CarrierElements} instances containing the\n+     * {@link MethodHandle MethodHandles} to the constructor and accessors of a carrier\n+     * object.\n+     * <p>\n+     * Clients can create instances by describing a carrier <em>shape<\/em>, that\n+     * is, a {@linkplain MethodType method type} whose parameter types describe the types of\n+     * the carrier component values, or by providing the parameter types directly.\n+     *\/\n+    static final class CarrierFactory {\n+        \/**\n+         * Constructor\n+         *\/\n+        private CarrierFactory() {\n+            throw new AssertionError(\"private constructor\");\n+        }\n+\n+        private static final CarrierObjectFactory FACTORY = new CarrierObjectFactory();\n+\n+        \/**\n+         * Factory method to return a {@link CarrierElements} instance that matches the shape of\n+         * the supplied {@link MethodType}. The return type of the {@link MethodType} is ignored.\n+         *\n+         * @param methodType  {@link MethodType} whose parameter types supply the\n+         *                    the shape of the carrier's components\n+         *\n+         * @return {@link CarrierElements} instance\n+         *\n+         * @throws NullPointerException is methodType is null\n+         * @throws IllegalArgumentException if number of component slots exceeds maximum\n+         *\/\n+        static CarrierElements of(MethodType methodType) {\n+            Objects.requireNonNull(methodType, \"methodType must not be null\");\n+            MethodType constructorMT = methodType.changeReturnType(Object.class);\n+            CarrierShape carrierShape = new CarrierShape(constructorMT);\n+            int slotCount = carrierShape.slotCount();\n+\n+            if (MAX_COMPONENTS < slotCount) {\n+                throw new IllegalArgumentException(\"Exceeds maximum number of component slots\");\n+            }\n+\n+            return FACTORY.carrier(carrierShape);\n+        }\n+\n+        \/**\n+         * Factory method to return  a {@link CarrierElements} instance that matches the shape of\n+         * the supplied parameter types.\n+         *\n+         * @param ptypes   parameter types that supply the shape of the carrier's components\n+         *\n+         * @return {@link CarrierElements} instance\n+         *\n+         * @throws NullPointerException is ptypes is null\n+         * @throws IllegalArgumentException if number of component slots exceeds maximum\n+         *\/\n+        static CarrierElements of(Class < ? >...ptypes) {\n+            Objects.requireNonNull(ptypes, \"ptypes must not be null\");\n+            return of(methodType(Object.class, ptypes));\n+        }\n+    }\n+\n+    \/**\n+     * Instances of this class provide the {@link MethodHandle MethodHandles} to the\n+     * constructor and accessors of a carrier object. The original component types can be\n+     * gleaned from the parameter types of the constructor {@link MethodHandle} or by the\n+     * return types of the components' {@link MethodHandle MethodHandles}.\n+     *\/\n+    static final class CarrierElements {\n+        \/**\n+         * Slot count required for objects.\n+         *\/\n+        private final int objectCount;\n+\n+        \/**\n+         * Slot count required for primitives.\n+         *\/\n+        private final int primitiveCount;\n+\n+        \/**\n+         * Underlying carrier class.\n+         *\/\n+        private final Class<?> carrierClass;\n+\n+        \/**\n+         * Constructor {@link MethodHandle}.\n+         *\/\n+        private final MethodHandle constructor;\n+\n+        \/**\n+         * Initializer {@link MethodHandle}.\n+         *\/\n+        private final MethodHandle initializer;\n+\n+        \/**\n+         * List of component {@link MethodHandle MethodHandles}\n+         *\/\n+        private final List<MethodHandle> components;\n+\n+        \/**\n+         * Constructor\n+         *\/\n+        private CarrierElements() {\n+            throw new AssertionError(\"private constructor\");\n+        }\n+\n+        \/**\n+         * Constructor\n+         *\/\n+        CarrierElements(CarrierShape carrierShape,\n+                        Class<?> carrierClass,\n+                        MethodHandle constructor,\n+                        MethodHandle initializer,\n+                        List<MethodHandle> components) {\n+            this.objectCount = carrierShape.objectCount();\n+            this.primitiveCount = carrierShape.primitiveCount();\n+            this.carrierClass = carrierClass;\n+            this.constructor = constructor;\n+            this.initializer = initializer;\n+            this.components = components;\n+        }\n+\n+        \/**\n+         * {@return slot count required for objects}\n+         *\/\n+        int objectCount() {\n+            return objectCount;\n+        }\n+\n+        \/**\n+         * {@return slot count required for primitives}\n+         *\/\n+        int primitiveCount() {\n+            return primitiveCount;\n+        }\n+\n+        \/**\n+         * {@return the underlying carrier class}\n+         *\/\n+        Class<?> carrierClass() {\n+            return carrierClass;\n+        }\n+\n+        \/**\n+         * {@return the constructor {@link MethodHandle} for the carrier. The\n+         * carrier constructor will always have a return type of {@link Object} }\n+         *\/\n+        MethodHandle constructor() {\n+            return constructor;\n+        }\n+\n+        \/**\n+         * {@return the initializer {@link MethodHandle} for the carrier}\n+         *\/\n+        MethodHandle initializer() {\n+            return initializer;\n+        }\n+\n+        \/**\n+         * Return the constructor plus initializer {@link MethodHandle} for the carrier.\n+         * The {@link MethodHandle} will always have a return type of {@link Object}.\n+         * @return the constructor plus initializer {@link MethodHandle}\n+         *\/\n+        MethodHandle initializingConstructor() {\n+            return MethodHandles.foldArguments(initializer, 0, constructor);\n+        }\n+\n+        \/**\n+         * {@return immutable list of component accessor {@link MethodHandle MethodHandles}\n+         * for all the carrier's components. The receiver type of the accessors\n+         * will always be {@link Object} }\n+         *\/\n+        List<MethodHandle> components() {\n+            return components;\n+        }\n+\n+        \/**\n+         * {@return a component accessor {@link MethodHandle} for component {@code i}.\n+         * The receiver type of the accessor will be {@link Object} }\n+         *\n+         * @param i  component index\n+         *\n+         * @throws IllegalArgumentException if {@code i} is out of bounds\n+         *\/\n+        MethodHandle component(int i) {\n+            if (i < 0 || components.size() <= i) {\n+                throw new IllegalArgumentException(\"i is out of bounds \" + i +\n+                        \" of \" + components.size());\n+            }\n+\n+            return components.get(i);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"Carrier\" + constructor.type().parameterList();\n+        }\n+    }\n+\n+    \/**\n+     * {@return the underlying carrier class of the carrier representing {@code methodType} }\n+     *\n+     * @param methodType  {@link MethodType} whose parameter types supply the shape of the\n+     *                    carrier's components\n+     *\/\n+    static Class<?> carrierClass(MethodType methodType) {\n+        return CarrierFactory.of(methodType).carrierClass();\n+    }\n+\n+    \/**\n+     * {@return the constructor {@link MethodHandle} for the carrier representing {@code\n+     * methodType}. The carrier constructor will always have a return type of {@link Object} }\n+     *\n+     * @param methodType  {@link MethodType} whose parameter types supply the shape of the\n+     *                    carrier's components\n+     *\/\n+    static MethodHandle constructor(MethodType methodType) {\n+        MethodHandle constructor = CarrierFactory.of(methodType).constructor();\n+        constructor = constructor.asType(constructor.type().changeReturnType(Object.class));\n+        return constructor;\n+    }\n+\n+    \/**\n+     * {@return the initializer {@link MethodHandle} for the carrier representing {@code\n+     * methodType}. The carrier initializer will always take an {@link Object} along with\n+     * component values and a return type of {@link Object} }\n+     *\n+     * @param methodType  {@link MethodType} whose parameter types supply the shape of the\n+     *                    carrier's components\n+     *\/\n+    static MethodHandle initializer(MethodType methodType) {\n+        MethodHandle initializer = CarrierFactory.of(methodType).initializer();\n+        initializer = initializer.asType(initializer.type()\n+                .changeReturnType(Object.class).changeParameterType(0, Object.class));\n+        return initializer;\n+    }\n+\n+    \/**\n+     * {@return the combination {@link MethodHandle} of the constructor and initializer\n+     * for the carrier representing {@code methodType}. The carrier constructor\/initializer\n+     * will always take the component values and a return type of {@link Object} }\n+     *\n+     * @param methodType  {@link MethodType} whose parameter types supply the shape of the\n+     *                    carrier's components\n+     *\/\n+    static MethodHandle initializingConstructor(MethodType methodType) {\n+        MethodHandle constructor = CarrierFactory.of(methodType).initializingConstructor();\n+        constructor = constructor.asType(constructor.type().changeReturnType(Object.class));\n+        return constructor;\n+    }\n+\n+    \/**\n+     * {@return immutable list of component accessor {@link MethodHandle MethodHandles} for\n+     * all the components of the carrier representing {@code methodType}. The receiver type of\n+     * the accessors will always be {@link Object} }\n+     *\n+     * @param methodType  {@link MethodType} whose parameter types supply the shape of the\n+     *                    carrier's components\n+     *\/\n+    static List<MethodHandle> components(MethodType methodType) {\n+        return CarrierFactory\n+                .of(methodType)\n+                .components()\n+                .stream()\n+                .map(c -> c.asType(c.type().changeParameterType(0, Object.class)))\n+                .toList();\n+    }\n+\n+    \/**\n+     * {@return a component accessor {@link MethodHandle} for component {@code i} of the\n+     * carrier representing {@code methodType}. The receiver type of the accessor will always\n+     * be {@link Object} }\n+     *\n+     * @param methodType  {@link MethodType} whose parameter types supply the shape of the\n+     *                    carrier's components\n+     * @param i           component index\n+     *\n+     * @throws IllegalArgumentException if {@code i} is out of bounds\n+     *\/\n+    static MethodHandle component(MethodType methodType, int i) {\n+        MethodHandle component = CarrierFactory.of(methodType).component(i);\n+        component = component.asType(component.type().changeParameterType(0, Object.class));\n+        return component;\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/template\/Carriers.java","additions":1008,"deletions":0,"binary":false,"changes":1008,"status":"added"},{"patch":"@@ -0,0 +1,230 @@\n+\/*\r\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\r\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\r\n+ *\r\n+ * This code is free software; you can redistribute it and\/or modify it\r\n+ * under the terms of the GNU General Public License version 2 only, as\r\n+ * published by the Free Software Foundation.  Oracle designates this\r\n+ * particular file as subject to the \"Classpath\" exception as provided\r\n+ * by Oracle in the LICENSE file that accompanied this code.\r\n+ *\r\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\r\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\r\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\r\n+ * version 2 for more details (a copy is included in the LICENSE file that\r\n+ * accompanied this code).\r\n+ *\r\n+ * You should have received a copy of the GNU General Public License version\r\n+ * 2 along with this work; if not, write to the Free Software Foundation,\r\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\r\n+ *\r\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\r\n+ * or visit www.oracle.com if you need additional information or have any\r\n+ * questions.\r\n+ *\/\r\n+\r\n+package java.lang.template;\r\n+\r\n+import java.lang.ref.Reference;\r\n+import java.lang.ref.ReferenceQueue;\r\n+import java.lang.ref.SoftReference;\r\n+import java.lang.ref.WeakReference;\r\n+import java.util.Objects;\r\n+\r\n+import jdk.internal.javac.PreviewFeature;\r\n+\r\n+\/**\r\n+ * View\/wrapper of keys used by the backing {@link ReferencedKeyMap}.\r\n+ * There are two style of keys; one for entries in the backing map and\r\n+ * one for queries to the backing map. This second style avoids the\r\n+ * overhead of a {@link Reference} object.\r\n+ *\r\n+ * @param <T> key type\r\n+ *\r\n+ * @since 20\r\n+ *\/\r\n+@PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\r\n+interface ReferenceKey<T> {\r\n+    \/**\r\n+     * {@return the value of the unwrapped key.}\r\n+     *\/\r\n+    T get();\r\n+\r\n+    \/**\r\n+     * Cleanup unused key.\r\n+     *\/\r\n+    void unused();\r\n+\r\n+    \/**\r\n+     * {@link WeakReference} wrapper key for entries in the backing map.\r\n+     *\r\n+     * @param <T> key type\r\n+     *\r\n+     * @since 20\r\n+     *\/\r\n+    class WeakKey<T> extends WeakReference<T> implements ReferenceKey<T> {\r\n+        \/**\r\n+         * Saved hashcode of the key. Used when {@link WeakReference} is\r\n+         * null.\r\n+         *\/\r\n+        int hashcode;\r\n+\r\n+        \/**\r\n+         * Private constructor.\r\n+         *\r\n+         * @param key   unwrapped key value\r\n+         * @param queue reference queue\r\n+         *\/\r\n+        WeakKey(T key, ReferenceQueue<T> queue) {\r\n+            super(key, queue);\r\n+            this.hashcode = Objects.hashCode(key);\r\n+        }\r\n+\r\n+        \/**\r\n+         * Cleanup unused key. No need to enqueue since the key did not make it\r\n+         * into the map.\r\n+         *\/\r\n+        @Override\r\n+        public void unused() {\r\n+            clear();\r\n+        }\r\n+\r\n+        @Override\r\n+        public boolean equals(Object obj) {\r\n+            \/\/ Necessary when removing a null reference\r\n+            if (obj == this) {\r\n+                return true;\r\n+            }\r\n+            \/\/ Necessary when comparing an unwrapped key\r\n+            if (obj instanceof ReferenceKey<?> key) {\r\n+                obj = key.get();\r\n+            }\r\n+            return Objects.equals(get(), obj);\r\n+        }\r\n+\r\n+        @Override\r\n+        public int hashCode() {\r\n+            \/\/ Use saved hashcode\r\n+            return hashcode;\r\n+        }\r\n+\r\n+        @Override\r\n+        public String toString() {\r\n+            return \"java.util.WeakKey#\" + System.identityHashCode(this);\r\n+        }\r\n+    }\r\n+\r\n+    \/**\r\n+     * {@link SoftReference} wrapper key for entries in the backing map.\r\n+     *\r\n+     * @param <T> key type\r\n+     *\r\n+     * @since 20\r\n+     *\/\r\n+    class SoftKey<T> extends SoftReference<T> implements ReferenceKey<T> {\r\n+        \/**\r\n+         * Saved hashcode of the key. Used when {@link SoftReference} is\r\n+         * null.\r\n+         *\/\r\n+        int hashcode;\r\n+\r\n+        \/**\r\n+         * Private constructor.\r\n+         *\r\n+         * @param key   unwrapped key value\r\n+         * @param queue reference queue\r\n+         *\/\r\n+        SoftKey(T key, ReferenceQueue<T> queue) {\r\n+            super(key, queue);\r\n+            this.hashcode = Objects.hashCode(key);\r\n+        }\r\n+\r\n+        \/**\r\n+         * Cleanup unused key. No need to enqueue since the key did not make it\r\n+         * into the map.\r\n+         *\/\r\n+        @Override\r\n+        public void unused() {\r\n+            clear();\r\n+        }\r\n+\r\n+        @Override\r\n+        public boolean equals(Object obj) {\r\n+            \/\/ Necessary when removing a null reference\r\n+            if (obj == this) {\r\n+                return true;\r\n+            }\r\n+            \/\/ Necessary when comparing an unwrapped key\r\n+            if (obj instanceof ReferenceKey<?> key) {\r\n+                obj = key.get();\r\n+            }\r\n+            return Objects.equals(get(), obj);\r\n+        }\r\n+\r\n+        @Override\r\n+        public int hashCode() {\r\n+            \/\/ Use saved hashcode\r\n+            return hashcode;\r\n+        }\r\n+\r\n+        @Override\r\n+        public String toString() {\r\n+            return \"java.util.SoftKey#\" + System.identityHashCode(this);\r\n+        }\r\n+    }\r\n+\r\n+    \/**\r\n+     * Wrapper for querying the backing map. Avoids the overhead of an\r\n+     * {@link Reference} object.\r\n+     *\r\n+     * @param <T> key type\r\n+     *\r\n+     * @since 20\r\n+     *\/\r\n+    class StrongKey<T> implements ReferenceKey<T> {\r\n+        T key;\r\n+\r\n+        \/**\r\n+         * Private constructor.\r\n+         *\r\n+         * @param key unwrapped key value\r\n+         *\/\r\n+        StrongKey(T key) {\r\n+            this.key = key;\r\n+        }\r\n+\r\n+        \/**\r\n+         * {@return the unwrapped key}\r\n+         *\/\r\n+        @Override\r\n+        public T get() {\r\n+            return key;\r\n+        }\r\n+\r\n+        @Override\r\n+        public void unused() {\r\n+            key = null;\r\n+        }\r\n+\r\n+        @Override\r\n+        public boolean equals(Object obj) {\r\n+            \/\/ Necessary when comparing an unwrapped key\r\n+            if (obj instanceof ReferenceKey<?> key) {\r\n+                obj = key.get();\r\n+            }\r\n+            return Objects.equals(get(), obj);\r\n+        }\r\n+\r\n+        @Override\r\n+        public int hashCode() {\r\n+            \/\/ Use unwrapped key hash code\r\n+            return get().hashCode();\r\n+        }\r\n+\r\n+        @Override\r\n+        public String toString() {\r\n+            return \"java.util.StrongKey#\" + System.identityHashCode(this);\r\n+        }\r\n+    }\r\n+\r\n+}\r\n","filename":"src\/java.base\/share\/classes\/java\/lang\/template\/ReferenceKey.java","additions":230,"deletions":0,"binary":false,"changes":230,"status":"added"},{"patch":"@@ -0,0 +1,336 @@\n+\/*\r\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\r\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\r\n+ *\r\n+ * This code is free software; you can redistribute it and\/or modify it\r\n+ * under the terms of the GNU General Public License version 2 only, as\r\n+ * published by the Free Software Foundation.  Oracle designates this\r\n+ * particular file as subject to the \"Classpath\" exception as provided\r\n+ * by Oracle in the LICENSE file that accompanied this code.\r\n+ *\r\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\r\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\r\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\r\n+ * version 2 for more details (a copy is included in the LICENSE file that\r\n+ * accompanied this code).\r\n+ *\r\n+ * You should have received a copy of the GNU General Public License version\r\n+ * 2 along with this work; if not, write to the Free Software Foundation,\r\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\r\n+ *\r\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\r\n+ * or visit www.oracle.com if you need additional information or have any\r\n+ * questions.\r\n+ *\/\r\n+\r\n+package java.lang.template;\r\n+\r\n+import java.lang.ref.Reference;\r\n+import java.lang.ref.ReferenceQueue;\r\n+import java.lang.ref.SoftReference;\r\n+import java.lang.ref.WeakReference;\r\n+import java.util.AbstractMap;\r\n+import java.util.Collection;\r\n+import java.util.HashMap;\r\n+import java.util.Objects;\r\n+import java.util.Map;\r\n+import java.util.Set;\r\n+import java.util.concurrent.ConcurrentHashMap;\r\n+import java.util.function.Supplier;\r\n+import java.util.stream.Collectors;\r\n+import java.util.stream.Stream;\r\n+\r\n+import jdk.internal.javac.PreviewFeature;\r\n+\r\n+\/**\r\n+ * This class provides management of {@link Map maps} where it is desirable to\r\n+ * remove entries automatically when the key is garbage collected. This is\r\n+ * accomplished by using a backing map where the keys are either a\r\n+ * {@link WeakReference} or a {@link SoftReference}.\r\n+ * <p>\r\n+ * To create a {@link ReferencedKeyMap} the user must provide a {@link Supplier}\r\n+ * of the backing map and whether {@link WeakReference} or\r\n+ * {@link SoftReference} is to be used.\r\n+ *\r\n+ * {@snippet :\r\n+ * \/\/ Use HashMap and WeakReference\r\n+ * Map<Long, String> map = ReferencedKeyMap.create(false, HashMap::new);\r\n+ * map.put(10_000_000L, \"a\");\r\n+ * map.put(10_000_001L, \"b\");\r\n+ * map.put(10_000_002L, \"c\");\r\n+ * map.put(10_000_003L, \"d\");\r\n+ * map.put(10_000_004L, \"e\");\r\n+ *\r\n+ * \/\/ Use ConcurrentHashMap and SoftReference\r\n+ * map = ReferencedKeyMap.create(true, ConcurrentHashMap::new);\r\n+ * map.put(20_000_000L, \"v\");\r\n+ * map.put(20_000_001L, \"w\");\r\n+ * map.put(20_000_002L, \"x\");\r\n+ * map.put(20_000_003L, \"y\");\r\n+ * map.put(20_000_004L, \"z\");\r\n+ * }\r\n+ *\r\n+ * @implNote Care must be given that the backing map does replacement by\r\n+ * replacing the value in the map entry instead of deleting the old entry and\r\n+ * adding a new entry, otherwise replaced entries may end up with a strongly\r\n+ * referenced key. {@link HashMap} and {@link ConcurrentHashMap} are known\r\n+ * to be safe.\r\n+ *\r\n+ * @param <K> the type of keys maintained by this map\r\n+ * @param <V> the type of mapped values\r\n+ *\/\r\n+@PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\r\n+final class ReferencedKeyMap<K, V> implements Map<K, V> {\r\n+    \/**\r\n+     * true if {@link SoftReference} keys are to be used,\r\n+     * {@link WeakReference} otherwise.\r\n+     *\/\r\n+    private final boolean isSoft;\r\n+\r\n+    \/**\r\n+     * Backing {@link Map}.\r\n+     *\/\r\n+    private final Map<ReferenceKey<K>, V> map;\r\n+\r\n+    \/**\r\n+     * {@link ReferenceQueue} for cleaning up {@link ReferenceKey.WeakKey EntryKeys}.\r\n+     *\/\r\n+    private final ReferenceQueue<K> stale;\r\n+\r\n+    \/**\r\n+     * Private constructor.\r\n+     *\r\n+     * @param isSoft  true if {@link SoftReference} keys are to\r\n+     *                be used, {@link WeakReference} otherwise.\r\n+     * @param map     backing map\r\n+     *\/\r\n+    private ReferencedKeyMap(boolean isSoft, Map<ReferenceKey<K>, V> map) {\r\n+        this.isSoft = isSoft;\r\n+        this.map = map;\r\n+        this.stale = new ReferenceQueue<>();\r\n+    }\r\n+\r\n+    \/**\r\n+     * Create a new {@link ReferencedKeyMap} map.\r\n+     *\r\n+     * @param isSoft    true if {@link SoftReference} keys are to\r\n+     *                  be used, {@link WeakReference} otherwise.\r\n+     * @param supplier  {@link Supplier} of the backing map\r\n+     *\r\n+     * @return a new map with {@link Reference} keys\r\n+     *\r\n+     * @param <K> the type of keys maintained by the new map\r\n+     * @param <V> the type of mapped values\r\n+     *\/\r\n+    @SuppressWarnings(\"unchecked\")\r\n+    static <K, V> ReferencedKeyMap<K, V>\r\n+    create(boolean isSoft, Supplier<Map<?, ?>> supplier) {\r\n+        return new ReferencedKeyMap<K, V>(isSoft,\r\n+                (Map<ReferenceKey<K>, V>)supplier.get());\r\n+    }\r\n+\r\n+    \/**\r\n+     * Create a new {@link ReferencedKeyMap} map using\r\n+     * {@link WeakReference} keys.\r\n+     *\r\n+     * @param supplier  {@link Supplier} of the backing map\r\n+     *\r\n+     * @return a new map with {@link Reference} keys\r\n+     *\r\n+     * @param <K> the type of keys maintained by the new map\r\n+     * @param <V> the type of mapped values\r\n+     *\/\r\n+    @SuppressWarnings(\"unchecked\")\r\n+    static <K, V> ReferencedKeyMap<K, V>\r\n+    create(Supplier<Map<?, ?>> supplier) {\r\n+        return new ReferencedKeyMap<K, V>(false,\r\n+                (Map<ReferenceKey<K>, V>)supplier.get());\r\n+    }\r\n+\r\n+    \/**\r\n+     * {@return a key suitable for a map entry}\r\n+     *\r\n+     * @param key unwrapped key\r\n+     *\/\r\n+    @SuppressWarnings(\"unchecked\")\r\n+    private ReferenceKey<K> entryKey(Object key) {\r\n+        if (isSoft) {\r\n+            return new ReferenceKey.SoftKey<>((K)key, stale);\r\n+        } else {\r\n+            return new ReferenceKey.WeakKey<>((K)key, stale);\r\n+        }\r\n+    }\r\n+\r\n+    \/**\r\n+     * {@return a key suitable for lookup}\r\n+     *\r\n+     * @param key unwrapped key\r\n+     *\/\r\n+    @SuppressWarnings(\"unchecked\")\r\n+    private ReferenceKey<K> lookupKey(Object key) {\r\n+        return new ReferenceKey.StrongKey<>((K)key);\r\n+    }\r\n+\r\n+    @Override\r\n+    public int size() {\r\n+        removeStaleReferences();\r\n+        return map.size();\r\n+    }\r\n+\r\n+    @Override\r\n+    public boolean isEmpty() {\r\n+        removeStaleReferences();\r\n+        return map.isEmpty();\r\n+    }\r\n+\r\n+    @Override\r\n+    public boolean containsKey(Object key) {\r\n+        Objects.requireNonNull(key, \"key must not be null\");\r\n+        removeStaleReferences();\r\n+        return map.containsKey(lookupKey(key));\r\n+    }\r\n+\r\n+    @Override\r\n+    public boolean containsValue(Object value) {\r\n+        Objects.requireNonNull(value, \"value must not be null\");\r\n+        removeStaleReferences();\r\n+        return map.containsValue(value);\r\n+    }\r\n+\r\n+    @Override\r\n+    public V get(Object key) {\r\n+        Objects.requireNonNull(key, \"key must not be null\");\r\n+        removeStaleReferences();\r\n+        return map.get(lookupKey(key));\r\n+    }\r\n+\r\n+    @Override\r\n+    public V put(K key, V newValue) {\r\n+        Objects.requireNonNull(key, \"key must not be null\");\r\n+        Objects.requireNonNull(newValue, \"value must not be null\");\r\n+        removeStaleReferences();\r\n+        ReferenceKey<K> entryKey = entryKey(key);\r\n+        \/\/ If {@code put} returns non-null then was actually a {@code replace}\r\n+        \/\/ and older key was used. In that case the new key was not used and the\r\n+        \/\/ reference marked stale.\r\n+        V oldValue = map.put(entryKey, newValue);\r\n+        if (oldValue != null) {\r\n+            entryKey.unused();\r\n+        }\r\n+        return oldValue;\r\n+    }\r\n+\r\n+    @Override\r\n+    public V remove(Object key) {\r\n+        \/\/ Rely on gc to clean up old key.\r\n+        return map.remove(lookupKey(key));\r\n+    }\r\n+\r\n+    @Override\r\n+    public void putAll(Map<? extends K, ? extends V> m) {\r\n+        removeStaleReferences();\r\n+        for (Entry<? extends K, ? extends V> entry : m.entrySet()) {\r\n+            K key = entry.getKey();\r\n+            V value = entry.getValue();\r\n+            put(key, value);\r\n+        }\r\n+    }\r\n+\r\n+    @Override\r\n+    public void clear() {\r\n+        removeStaleReferences();\r\n+        \/\/ Rely on gc to clean up old keys.\r\n+        map.clear();\r\n+    }\r\n+\r\n+    \/**\r\n+     * Common routine for collecting the current set of keys.\r\n+     *\r\n+     * @return {@link Stream} of valid keys (unwrapped)\r\n+     *\/\r\n+    private Stream<K> filterKeySet() {\r\n+        return map.keySet()\r\n+                .stream()\r\n+                .map(ReferenceKey::get)\r\n+                .filter(Objects::nonNull);\r\n+    }\r\n+\r\n+    @Override\r\n+    public Set<K> keySet() {\r\n+        removeStaleReferences();\r\n+        return filterKeySet().collect(Collectors.toSet());\r\n+    }\r\n+\r\n+    @Override\r\n+    public Collection<V> values() {\r\n+        removeStaleReferences();\r\n+        return map.values();\r\n+    }\r\n+\r\n+    @Override\r\n+    public Set<Entry<K, V>> entrySet() {\r\n+        removeStaleReferences();\r\n+        return filterKeySet()\r\n+                .map(k -> new AbstractMap.SimpleEntry<>(k, get(k)))\r\n+                .collect(Collectors.toSet());\r\n+    }\r\n+\r\n+    @Override\r\n+    public V putIfAbsent(K key, V newValue) {\r\n+        removeStaleReferences();\r\n+        ReferenceKey<K> entryKey = entryKey(key);\r\n+        \/\/ If {@code putIfAbsent} returns non-null then was actually a\r\n+        \/\/ {@code replace}  and older key was used. In that case the new key was\r\n+        \/\/ not used and the reference marked stale.\r\n+        V oldValue = map.putIfAbsent(entryKey, newValue);\r\n+        if (oldValue != null) {\r\n+            entryKey.unused();\r\n+        }\r\n+        return oldValue;\r\n+    }\r\n+\r\n+    @Override\r\n+    public boolean remove(Object key, Object value) {\r\n+        \/\/ Rely on gc to clean up old key.\r\n+        return map.remove(lookupKey(key), value);\r\n+    }\r\n+\r\n+    @Override\r\n+    public boolean replace(K key, V oldValue, V newValue) {\r\n+        removeStaleReferences();\r\n+        \/\/ If replace is successful then the older key will be used and the\r\n+        \/\/ lookup key will suffice.\r\n+        return map.replace(lookupKey(key), oldValue, newValue);\r\n+    }\r\n+\r\n+    @Override\r\n+    public V replace(K key, V value) {\r\n+        removeStaleReferences();\r\n+        \/\/ If replace is successful then the older key will be used and the\r\n+        \/\/ lookup key will suffice.\r\n+        return map.replace(lookupKey(key), value);\r\n+    }\r\n+\r\n+    @Override\r\n+    public String toString() {\r\n+        removeStaleReferences();\r\n+        return filterKeySet()\r\n+                .map(k -> k + \"=\" + get(k))\r\n+                .collect(Collectors.joining(\", \", \"{\", \"}\"));\r\n+    }\r\n+\r\n+    \/**\r\n+     * Removes enqueued weak references from map.\r\n+     *\/\r\n+    @SuppressWarnings(\"unchecked\")\r\n+    public void removeStaleReferences() {\r\n+        while (true) {\r\n+            ReferenceKey.WeakKey<K> key = (ReferenceKey.WeakKey<K>)stale.poll();\r\n+            if (key == null) {\r\n+                break;\r\n+            }\r\n+            map.remove(key);\r\n+        }\r\n+    }\r\n+\r\n+}\r\n","filename":"src\/java.base\/share\/classes\/java\/lang\/template\/ReferencedKeyMap.java","additions":336,"deletions":0,"binary":false,"changes":336,"status":"added"},{"patch":"@@ -28,3 +28,0 @@\n-import java.util.Arrays;\n-import java.util.Objects;\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/template\/StringProcessor.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -207,38 +207,0 @@\n-    \/**\n-     * Produces a hash code for the supplied {@link StringTemplate}.\n-     *\n-     * @param stringTemplate the {@link StringTemplate} to hash\n-     *\n-     * @return hash code for the supplied {@link StringTemplate}\n-     *\n-     * @throws NullPointerException if stringTemplate is null\n-     *\n-     * @implSpec The hashCode is the bit XOR of the fragments hash code and\n-     * the values hash code.\n-     *\/\n-    public static int hashCode(StringTemplate stringTemplate) {\n-        Objects.requireNonNull(stringTemplate, \"stringTemplate should not be null\");\n-        return Objects.hash(stringTemplate.fragments(), stringTemplate.values());\n-    }\n-\n-    \/**\n-     * Tests equality of two {@link StringTemplate}.\n-     *\n-     * @param a  first {@link StringTemplate}\n-     * @param b  second {@link StringTemplate}\n-     *\n-     * @return true if the two {@link StringTemplate StringTemplates} are equivalent\n-     *\n-     * @throws NullPointerException if either @link StringTemplate} is null\n-     *\n-     * @implSpec Equality is determined by testing equality of the fragments and\n-     * the values.\n-     *\/\n-    public static boolean equals(Object a, Object b) {\n-        Objects.requireNonNull(a, \"StringTemplate a should not be null\");\n-        Objects.requireNonNull(b, \"StringTemplate b should not be null\");\n-        return a instanceof StringTemplate aST && b instanceof StringTemplate bST &&\n-                Objects.equals(aST.fragments(), bST.fragments()) &&\n-                Objects.equals(aST.values(), bST.values());\n-    }\n-\n@@ -256,1 +218,1 @@\n-        return new TemplateRuntime.SimpleStringTemplate(List.of(string), List.of());\n+        return new TemplateSupport.SimpleStringTemplate(List.of(string), List.of());\n@@ -284,2 +246,2 @@\n-        values = TemplateRuntime.toList(values.toArray().clone());\n-        return new TemplateRuntime.SimpleStringTemplate(fragments, values);\n+        values = TemplateSupport.toList(values.toArray().clone());\n+        return new TemplateSupport.SimpleStringTemplate(fragments, values);\n@@ -297,0 +259,2 @@\n+     * @throws IllegalArgumentException if fragments list size is not one more\n+     *         than values list size\n@@ -305,1 +269,1 @@\n-            throw new RuntimeException(\"fragments must have one more element than values\");\n+            throw new IllegalArgumentException(\"fragments must have one more element than values\");\n@@ -307,1 +271,1 @@\n-        return TemplateRuntime.interpolate(List.copyOf(fragments), TemplateRuntime.toList(values.toArray()));\n+        return TemplateSupport.interpolate(List.copyOf(fragments), TemplateSupport.toList(values.toArray()));\n@@ -325,1 +289,1 @@\n-        return TemplateRuntime.combine(sts);\n+        return TemplateSupport.combine(sts);\n@@ -337,1 +301,1 @@\n-    public static final StringProcessor STR = StringTemplate::interpolate;\n+    public static final StringProcessor STR = TemplateSupport.basicInterpolate();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/template\/StringTemplate.java","additions":9,"deletions":45,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -0,0 +1,133 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.template;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.util.List;\n+import java.util.Objects;\n+\n+import jdk.internal.javac.PreviewFeature;\n+import jdk.internal.vm.annotation.Stable;\n+\n+\/**\n+ * This class implements specialized {@link StringTemplate StringTemplates} produced by\n+ * string template BSM callsites generated by the compiler.\n+ * <p>\n+ * Values are stored by subclassing {@link Carriers.CarrierObject}. This allows specializations\n+ * and sharing of value shapes without creating a new class for each shape.\n+ * <p>\n+ * {@link StringTemplate} fragments are shared via binding to the\n+ * {@link java.lang.invoke.CallSite CallSite's} {@link MethodHandle}.\n+ * <p>\n+ * The {@link StringTemplateImpl} instance also carries\n+ * specialized {@link MethodHandle MethodHandles} for producing the values list and interpolation.\n+ * These {@link MethodHandle MethodHandles} are  also shared by binding to the\n+ * {@link java.lang.invoke.CallSite CallSite}.\n+ *\n+ * @since 20\n+ *\/\n+@PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n+final class StringTemplateImpl extends Carriers.CarrierObject implements StringTemplate {\n+    \/**\n+     * List of string fragments for the string template. This value of this list is shared by\n+     * all instances created at the {@link java.lang.invoke.CallSite CallSite}.\n+     *\/\n+    @Stable\n+    private final List<String> fragments;\n+\n+    \/**\n+     * Specialized {@link MethodHandle} used to implement the {@link StringTemplate StringTemplate's}\n+     * {@code values} method. This {@link MethodHandle} is shared by all instances created at the\n+     * {@link java.lang.invoke.CallSite CallSite}.\n+     *\/\n+    @Stable\n+    private final MethodHandle valuesMH;\n+\n+    \/**\n+     * Specialized {@link MethodHandle} used to implement the {@link StringTemplate StringTemplate's}\n+     * {@code interpolate} method. This {@link MethodHandle} is shared by all instances created at the\n+     * {@link java.lang.invoke.CallSite CallSite}.\n+     *\/\n+    @Stable\n+    private final MethodHandle interpolateMH;\n+\n+    \/**\n+     * Constructor.\n+     *\n+     * @param primitiveCount  number of primitive slots required (bound at callsite)\n+     * @param objectCount     number of object slots required (bound at callsite)\n+     * @param fragments       list of string fragments (bound in (bound at callsite)\n+     * @param valuesMH        {@link MethodHandle} to produce list of values (bound at callsite)\n+     * @param interpolateMH   {@link MethodHandle} to produce interpolation (bound at callsite)\n+     *\/\n+    StringTemplateImpl(int primitiveCount, int objectCount,\n+                       List<String> fragments, MethodHandle valuesMH, MethodHandle interpolateMH) {\n+        super(primitiveCount, objectCount);\n+        this.fragments = fragments;\n+        this.valuesMH = valuesMH;\n+        this.interpolateMH = interpolateMH;\n+    }\n+\n+    @Override\n+    public List<String> fragments() {\n+        return fragments;\n+    }\n+\n+    @Override\n+    public List<Object> values() {\n+        try {\n+            return (List<Object>)valuesMH.invokeExact(this);\n+        } catch (Throwable ex) {\n+            throw new RuntimeException(\"string template values failure\", ex);\n+        }\n+    }\n+\n+    @Override\n+    public String interpolate() {\n+        try {\n+            return (String)interpolateMH.invokeExact(this);\n+        } catch (Throwable ex) {\n+            throw new RuntimeException(\"string template interpolate failure\", ex);\n+        }\n+    }\n+\n+    @Override\n+    public boolean equals(Object other) {\n+        return other instanceof StringTemplate st &&\n+                Objects.equals(fragments(), st.fragments()) &&\n+                Objects.equals(values(), st.values());\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(fragments(), values());\n+    }\n+\n+    @java.lang.Override\n+    public java.lang.String toString() {\n+        return StringTemplate.toString(this);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/template\/StringTemplateImpl.java","additions":133,"deletions":0,"binary":false,"changes":133,"status":"added"},{"patch":"@@ -0,0 +1,154 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.template;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.invoke.StringConcatException;\n+import java.lang.invoke.StringConcatFactory;\n+import java.util.List;\n+\n+import jdk.internal.access.JavaTemplateAccess;\n+import jdk.internal.access.JavaUtilCollectionAccess;\n+import jdk.internal.access.SharedSecrets;\n+import jdk.internal.javac.PreviewFeature;\n+\n+import static java.lang.invoke.MethodType.methodType;\n+\n+\/**\n+ * This class synthesizes {@link StringTemplate StringTemplates} based on\n+ * fragments and bootstrap method type.\n+ *\n+ * @since 20\n+ *\/\n+@PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n+final class StringTemplateImplFactory implements JavaTemplateAccess {\n+\n+    \/**\n+     * Private constructor.\n+     *\/\n+    StringTemplateImplFactory() {\n+    }\n+\n+    \/*\n+     * {@link StringTemplateImpl} constructor MethodHandle.\n+     *\/\n+    private static final MethodHandle CONSTRUCTOR;\n+\n+    \/**\n+     * List (for nullable) of MethodHandle;\n+     *\/\n+    private static final MethodHandle TO_LIST;\n+\n+    \/**\n+     * Access to nullible form of {@code List.of}\n+     *\/\n+    private static final JavaUtilCollectionAccess JUCA = SharedSecrets.getJavaUtilCollectionAccess();\n+\n+    \/**\n+     * Collect nullable elements from an array into a unmodifiable list.\n+     *\n+     * @param elements  elements to place in list\n+     *\n+     * @return unmodifiable list.\n+     *\n+     * @param <E>  type of elements\n+     *\/\n+    @SafeVarargs\n+    @SuppressWarnings({\"unchecked\", \"varargs\"})\n+    private static <E> List<E> toList(E... elements) {\n+        return JUCA.listFromTrustedArrayNullsAllowed(elements);\n+    }\n+\n+    static {\n+        try {\n+            MethodHandles.Lookup lookup = MethodHandles.lookup();\n+\n+            MethodType mt = methodType(void.class, int.class, int.class, List.class,\n+                    MethodHandle.class, MethodHandle.class);\n+            CONSTRUCTOR = lookup.findConstructor(StringTemplateImpl.class, mt)\n+                    .asType(mt.changeReturnType(Carriers.CarrierObject.class));\n+\n+            mt = methodType(List.class, Object[].class);\n+            TO_LIST = lookup.findStatic(StringTemplateImplFactory.class, \"toList\", mt);\n+        } catch(ReflectiveOperationException ex) {\n+            throw new AssertionError(\"carrier static init fail\", ex);\n+        }\n+    }\n+\n+    \/**\n+     * Create a new {@link StringTemplateImpl} constructor.\n+     *\n+     * @param fragments  string template fragments\n+     * @param type       method type\n+     *\n+     * @return {@link MethodHandle} that can construct a {@link StringTemplateImpl} with arguments\n+     * used as values.\n+     *\/\n+    public  MethodHandle createStringTemplateImplMH(List<String> fragments, MethodType type) {\n+        Carriers.CarrierElements elements = Carriers.CarrierFactory.of(type);\n+        MethodHandle[] components = elements\n+                .components()\n+                .stream()\n+                .map(c -> c.asType(c.type().changeParameterType(0, StringTemplateImpl.class)))\n+                .toArray(MethodHandle[]::new);\n+        Class<?>[] ptypes = elements\n+                .components()\n+                .stream()\n+                .map(c -> c.type().returnType())\n+                .toArray(Class<?>[]::new);\n+        int[] permute = new int[ptypes.length];\n+\n+        MethodHandle interpolateMH;\n+        MethodType mt;\n+        try {\n+            interpolateMH = StringConcatFactory.makeConcatWithTemplate(fragments, List.of(ptypes));\n+        } catch (StringConcatException ex) {\n+            throw new RuntimeException(\"constructing internal string template\", ex);\n+        }\n+        interpolateMH = MethodHandles.filterArguments(interpolateMH, 0, components);\n+        mt = methodType(String.class, StringTemplateImpl.class);\n+        interpolateMH = MethodHandles.permuteArguments(interpolateMH, mt, permute);\n+\n+        mt = methodType(List.class, ptypes);\n+        MethodHandle valuesMH = TO_LIST.asCollector(Object[].class, components.length).asType(mt);\n+        valuesMH = MethodHandles.filterArguments(valuesMH, 0, components);\n+        mt = methodType(List.class, StringTemplateImpl.class);\n+        valuesMH = MethodHandles.permuteArguments(valuesMH, mt, permute);\n+\n+        MethodHandle constructor = MethodHandles.insertArguments(CONSTRUCTOR,0,\n+                elements.primitiveCount(), elements.objectCount(),\n+                fragments, valuesMH, interpolateMH);\n+        constructor = MethodHandles.foldArguments(elements.initializer(), 0, constructor);\n+\n+        mt = methodType(StringTemplate.class, ptypes);\n+        constructor = constructor.asType(mt);\n+\n+        return constructor;\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/template\/StringTemplateImplFactory.java","additions":154,"deletions":0,"binary":false,"changes":154,"status":"added"},{"patch":"@@ -28,3 +28,0 @@\n-import java.util.Arrays;\n-import java.util.Objects;\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/template\/TemplateProcessor.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,162 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package java.lang.template;\n-\n-import java.lang.invoke.CallSite;\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.MethodType;\n-import java.lang.reflect.Array;\n-import java.lang.reflect.Field;\n-import java.lang.reflect.Modifier;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Iterator;\n-import java.util.List;\n-import java.util.Objects;\n-\n-import jdk.internal.access.JavaLangAccess;\n-import jdk.internal.access.JavaLangInvokeAccess;\n-import jdk.internal.access.JavaUtilCollectionAccess;\n-import jdk.internal.access.SharedSecrets;\n-import jdk.internal.javac.PreviewFeature;\n-\n-\/**\n- * This class provides runtime support for string templates. The methods within\n- * are intended for internal use only.\n- *\n- * @since 20\n- *\/\n-@PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n-final class TemplateRuntime {\n-\n-    \/**\n-     * Private constructor.\n-     *\/\n-    private TemplateRuntime() {\n-        throw new AssertionError(\"private constructor\");\n-    }\n-\n-    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();\n-\n-    private static final JavaUtilCollectionAccess JUCA = SharedSecrets.getJavaUtilCollectionAccess();\n-\n-    \/**\n-     * Collect nullable elements from an array into a unmodifiable list.\n-     *\n-     * @param elements  elements to place in list\n-     *\n-     * @return unmodifiable list.\n-     *\n-     * @param <E>  type of elements\n-     *\/\n-    @SafeVarargs\n-    @SuppressWarnings({\"unchecked\", \"varargs\"})\n-    static <E> List<E> toList(E... elements) {\n-        return JUCA.listFromTrustedArrayNullsAllowed(elements);\n-    }\n-\n-    \/**\n-     * Generic StringTemplate.\n-     *\n-     * @param fragments  immutable list of string fragments from string template\n-     * @param values     immutable list of expression values\n-     *\/\n-    record SimpleStringTemplate(List<String> fragments,\n-                                 List<Object> values\n-    ) implements StringTemplate {}\n-\n-    \/**\n-     * Creates a string that interleaves the elements of values between the\n-     * elements of fragments.\n-     *\n-     * @param fragments  list of String fragments\n-     * @param values     list of expression values\n-     *\n-     * @return String interpolation of fragments and values\n-     *\/\n-    static String interpolate(List<String> fragments, List<Object> values) {\n-        int fragmentsSize = fragments.size();\n-        int valuesSize = values.size();\n-        if (fragmentsSize == 1) {\n-            return fragments.get(0);\n-        }\n-        int size = fragmentsSize + valuesSize;\n-        String[] strings = new String[size];\n-        Iterator<String> fragmentsIter = fragments.iterator();\n-        int i = 0;\n-        for (Object value : values) {\n-            strings[i++] = fragmentsIter.next();\n-            strings[i++] = String.valueOf(value);\n-        }\n-        strings[i++] = fragmentsIter.next();\n-        return JLA.join(\"\", \"\", \"\", strings, size);\n-    }\n-\n-    \/**\n-     * Combine one or more {@link StringTemplate StringTemplates} to produce a combined {@link StringTemplate}.\n-     * {@snippet :\n-     * StringTemplate st = StringTemplate.combine(\"\\{a}\", \"\\{b}\", \"\\{c}\");\n-     * assert st.interpolate().equals(\"\\{a}\\{b}\\{c}\");\n-     * }\n-     *\n-     * @param sts  one or more {@link StringTemplate}\n-     *\n-     * @return combined {@link StringTemplate}\n-     *\n-     * @throws NullPointerException if sts is null or if any element of sts is null\n-     *\/\n-    static StringTemplate combine(StringTemplate... sts) {\n-        Objects.requireNonNull(sts, \"sts must not be null\");\n-        if (sts.length == 0) {\n-            return StringTemplate.of(\"\");\n-        } else if (sts.length == 1) {\n-            return Objects.requireNonNull(sts[0], \"string templates should not be null\");\n-        }\n-        int size = 0;\n-        for (StringTemplate st : sts) {\n-            Objects.requireNonNull(st, \"string templates should not be null\");\n-            size += st.values().size();\n-        }\n-        String[] fragments = new String[size + 1];\n-        Object[] values = new Object[size];\n-        int i = 0, j = 0;\n-        fragments[0] = \"\";\n-        for (StringTemplate st : sts) {\n-            Iterator<String> fragmentIter = st.fragments().iterator();\n-            fragments[i++] += fragmentIter.next();\n-            while (fragmentIter.hasNext()) {\n-                fragments[i++] = fragmentIter.next();\n-            }\n-            i--;\n-            for (Object value : st.values()) {\n-                values[j++] = value;\n-            }\n-        }\n-        return new SimpleStringTemplate(TemplateRuntime.toList(fragments), TemplateRuntime.toList(values));\n-    }\n-\n-}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/template\/TemplateRuntime.java","additions":0,"deletions":162,"binary":false,"changes":162,"status":"deleted"},{"patch":"@@ -0,0 +1,179 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.template;\n+\n+import java.lang.invoke.CallSite;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.reflect.Array;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Objects;\n+\n+import jdk.internal.access.JavaLangAccess;\n+import jdk.internal.access.JavaLangInvokeAccess;\n+import jdk.internal.access.JavaTemplateAccess;\n+import jdk.internal.access.JavaUtilCollectionAccess;\n+import jdk.internal.access.SharedSecrets;\n+import jdk.internal.javac.PreviewFeature;\n+\n+\/**\n+ * This class provides runtime support for string templates. The methods within\n+ * are intended for internal use only.\n+ *\n+ * @since 20\n+ *\/\n+@PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n+final class TemplateSupport {\n+\n+    \/**\n+     * Private constructor.\n+     *\/\n+    private TemplateSupport() {\n+        throw new AssertionError(\"private constructor\");\n+    }\n+\n+    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();\n+\n+    private static final JavaUtilCollectionAccess JUCA = SharedSecrets.getJavaUtilCollectionAccess();\n+\n+    \/**\n+     * Collect nullable elements from an array into a unmodifiable list.\n+     *\n+     * @param elements  elements to place in list\n+     *\n+     * @return unmodifiable list.\n+     *\n+     * @param <E>  type of elements\n+     *\/\n+    @SafeVarargs\n+    @SuppressWarnings({\"unchecked\", \"varargs\"})\n+    static <E> List<E> toList(E... elements) {\n+        return JUCA.listFromTrustedArrayNullsAllowed(elements);\n+    }\n+\n+    \/**\n+     * Generic {@link StringTemplate}.\n+     *\n+     * @param fragments  immutable list of string fragments from string template\n+     * @param values     immutable list of expression values\n+     *\/\n+    record SimpleStringTemplate(List<String> fragments, List<Object> values)\n+            implements StringTemplate {\n+        @Override\n+        public java.lang.String toString() {\n+            return StringTemplate.toString(this);\n+        }\n+    }\n+\n+    \/**\n+     * Creates a string that interleaves the elements of values between the\n+     * elements of fragments.\n+     *\n+     * @param fragments  list of String fragments\n+     * @param values     list of expression values\n+     *\n+     * @return String interpolation of fragments and values\n+     *\/\n+    static String interpolate(List<String> fragments, List<Object> values) {\n+        int fragmentsSize = fragments.size();\n+        int valuesSize = values.size();\n+        if (fragmentsSize == 1) {\n+            return fragments.get(0);\n+        }\n+        int size = fragmentsSize + valuesSize;\n+        String[] strings = new String[size];\n+        Iterator<String> fragmentsIter = fragments.iterator();\n+        int i = 0;\n+        for (Object value : values) {\n+            strings[i++] = fragmentsIter.next();\n+            strings[i++] = String.valueOf(value);\n+        }\n+        strings[i++] = fragmentsIter.next();\n+        return JLA.join(\"\", \"\", \"\", strings, size);\n+    }\n+\n+    \/**\n+     * Combine one or more {@link StringTemplate StringTemplates} to produce a combined {@link StringTemplate}.\n+     * {@snippet :\n+     * StringTemplate st = StringTemplate.combine(\"\\{a}\", \"\\{b}\", \"\\{c}\");\n+     * assert st.interpolate().equals(\"\\{a}\\{b}\\{c}\");\n+     * }\n+     *\n+     * @param sts  one or more {@link StringTemplate}\n+     *\n+     * @return combined {@link StringTemplate}\n+     *\n+     * @throws NullPointerException if sts is null or if any element of sts is null\n+     *\/\n+    static StringTemplate combine(StringTemplate... sts) {\n+        Objects.requireNonNull(sts, \"sts must not be null\");\n+        if (sts.length == 0) {\n+            return StringTemplate.of(\"\");\n+        } else if (sts.length == 1) {\n+            return Objects.requireNonNull(sts[0], \"string templates should not be null\");\n+        }\n+        int size = 0;\n+        for (StringTemplate st : sts) {\n+            Objects.requireNonNull(st, \"string templates should not be null\");\n+            size += st.values().size();\n+        }\n+        String[] combinedFragments = new String[size + 1];\n+        Object[] combinedValues = new Object[size];\n+        int i = 0, j = 0;\n+        String last = \"\";\n+        for (StringTemplate st : sts) {\n+            List<String> fragments = st.fragments();\n+            combinedFragments[i++] = last + fragments.get(0);\n+            int k = 1, sizem1 = fragments.size() - 1;\n+            for(; k < sizem1; k++) {\n+                combinedFragments[i++] = fragments.get(k);\n+            }\n+            last = fragments.get(k);\n+            for (Object value : st.values()) {\n+                combinedValues[j++] = value;\n+            }\n+        }\n+        combinedFragments[i] = last;\n+        return new SimpleStringTemplate(TemplateSupport.toList(combinedFragments), TemplateSupport.toList(combinedValues));\n+    }\n+\n+    \/**\n+     * Return the basic string interpolate process, and, initialize the SharedSecret.\n+     *\n+     * @return basic string interpolate process\n+     *\/\n+    static StringProcessor basicInterpolate() {\n+        SharedSecrets.setJavaTemplateAccess(new StringTemplateImplFactory());\n+        return StringTemplate::interpolate;\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/template\/TemplateSupport.java","additions":179,"deletions":0,"binary":false,"changes":179,"status":"added"},{"patch":"@@ -100,1 +100,1 @@\n- *     return StringTemplate.interpolate(fragments, values);;\n+ *     return StringTemplate.interpolate(fragments, values);\n@@ -126,1 +126,1 @@\n- * that just need to work with the interpolatation;\n+ * that just need to work with the interpolation;\n@@ -130,1 +130,1 @@\n- * or simply transform the interpolatation into something other than\n+ * or simply transform the interpolation into something other than\n","filename":"src\/java.base\/share\/classes\/java\/lang\/template\/ValidatingProcessor.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -26,3 +26,1 @@\n-package jdk.internal.util;\n-\n-import jdk.internal.javac.PreviewFeature;\n+package java.util;\n@@ -32,0 +30,2 @@\n+import jdk.internal.javac.PreviewFeature;\n+\n@@ -36,1 +36,1 @@\n- * @since 19\n+ * @since 20\n@@ -39,1 +39,1 @@\n-public interface Digits {\n+interface Digits {\n@@ -67,1 +67,1 @@\n-    public final class DecimalDigits implements Digits {\n+    final class DecimalDigits implements Digits {\n@@ -73,1 +73,1 @@\n-        public static final Digits INSTANCE = new DecimalDigits();\n+        static final Digits INSTANCE = new DecimalDigits();\n@@ -168,1 +168,1 @@\n-    public final class HexDigits implements Digits {\n+    final class HexDigits implements Digits {\n@@ -174,1 +174,1 @@\n-        public static final Digits INSTANCE = new HexDigits();\n+        static final Digits INSTANCE = new HexDigits();\n@@ -227,1 +227,1 @@\n-    public final class OctalDigits implements Digits {\n+    final class OctalDigits implements Digits {\n@@ -233,1 +233,1 @@\n-        public static final Digits INSTANCE = new OctalDigits();\n+        static final Digits INSTANCE = new OctalDigits();\n","filename":"src\/java.base\/share\/classes\/java\/util\/Digits.java","additions":11,"deletions":11,"binary":false,"changes":22,"previous_filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/Digits.java","status":"renamed"},{"patch":"@@ -34,0 +34,1 @@\n+import java.util.Digits.*;\n@@ -39,2 +40,0 @@\n-import jdk.internal.util.Digits;\n-import jdk.internal.util.Digits.*;\n@@ -49,1 +48,1 @@\n- * @since 19\n+ * @since 20\n@@ -75,1 +74,1 @@\n-        } catch (RuntimeException ex) {\n+        } catch (Error | RuntimeException ex) {\n@@ -428,2 +427,1 @@\n-                FormatItemFillRight,\n-                FormatItemUpper\n+                FormatItemFillRight\n@@ -516,30 +514,0 @@\n-    \/**\n-     * To upper case format item.\n-     *\/\n-    static final class FormatItemUpper extends FormatItemModifier\n-            implements FormatConcatItem {\n-        FormatItemUpper(FormatConcatItem item) {\n-            super(item);\n-        }\n-\n-        @Override\n-        public long mix(long lengthCoder) {\n-            return (lengthCoder | coder()) + length();\n-        }\n-\n-        @Override\n-        public long prepend(long lengthCoder, byte[] buffer) throws Throwable {\n-            MethodHandle getCharMH = selectGetChar(lengthCoder);\n-            MethodHandle putCharMH = selectPutChar(lengthCoder);\n-            lengthCoder = item.prepend(lengthCoder, buffer);\n-            int start = (int)lengthCoder;\n-\n-            for (int i = 0; i < length(); i++) {\n-                char ch = (char)getCharMH.invokeExact(buffer, start + i);\n-                putCharMH.invokeExact(buffer, start + i, (int)Character.toUpperCase(ch));\n-            }\n-\n-            return lengthCoder;\n-        }\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/util\/FormatItem.java","additions":4,"deletions":36,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n- * This {@linkplain ValidatingProcessor yemplate processor} constructs a String\n+ * This {@linkplain ValidatingProcessor template processor} constructs a String\n@@ -56,1 +56,2 @@\n- * @implSpec Since, values are in situ, argument indexing is unsupported.\n+ * @implSpec Since, values are found with in the string template, argument indexing\n+ * specifiers are unsupported.\n","filename":"src\/java.base\/share\/classes\/java\/util\/FormatProcessor.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -165,4 +165,0 @@\n-    private static final MethodHandle FIUpper_MH =\n-            findStringConcatItemConstructor(FormatItemUpper.class,\n-                    FormatConcatItem.class);\n-\n@@ -279,1 +275,1 @@\n-                    if (validFlags(flags, LEFT_JUSTIFY | UPPERCASE)) {\n+                    if (validFlags(flags, LEFT_JUSTIFY)) {\n@@ -294,1 +290,1 @@\n-                if (validFlags(flags, LEFT_JUSTIFY | UPPERCASE) && precision == -1) {\n+                if (validFlags(flags, LEFT_JUSTIFY) && precision == -1) {\n@@ -318,1 +314,1 @@\n-                    if (validFlags(flags, LEFT_JUSTIFY | UPPERCASE)) {\n+                    if (validFlags(flags, LEFT_JUSTIFY)) {\n@@ -401,2 +397,2 @@\n-            if (isFlag(flags, UPPERCASE)) {\n-                mh = filterReturnValue(mh, FIUpper_MH);\n+            if (!isFlag(flags, UPPERCASE)) {\n+                return mh;\n@@ -404,2 +400,0 @@\n-\n-            return mh;\n","filename":"src\/java.base\/share\/classes\/java\/util\/FormatterBuilder.java","additions":5,"deletions":11,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -0,0 +1,43 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.access;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodType;\n+import java.util.List;\n+\n+public interface JavaTemplateAccess {\n+\n+    \/\/ Create a new {@link StringTemplateImpl} constructor.\n+    \/\/\n+    \/\/ @param fragments  string template fragments\n+    \/\/ @param type       method type\n+    \/\/\n+    \/\/ @return {@link MethodHandle} that can construct a {@link StringTemplateImpl} with arguments\n+    \/\/ used as values.\n+    public MethodHandle createStringTemplateImplMH(List<String> fragments, MethodType type);\n+}\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaTemplateAccess.java","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -33,0 +33,1 @@\n+import java.lang.template.StringTemplate;\n@@ -92,0 +93,1 @@\n+    private static JavaTemplateAccess javaTemplateAccess;\n@@ -519,0 +521,13 @@\n+    public static void setJavaTemplateAccess(JavaTemplateAccess jta) {\n+        javaTemplateAccess = jta;\n+    }\n+\n+    public static JavaTemplateAccess getJavaTemplateAccess() {\n+        var access = javaTemplateAccess;\n+        if (access == null) {\n+            ensureClassInitialized(StringTemplate.class);\n+            access = javaTemplateAccess;\n+        }\n+        return access;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/SharedSecrets.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -1,202 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.internal.template;\n-\n-import java.lang.invoke.CallSite;\n-import java.lang.invoke.ConstantCallSite;\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.MethodType;\n-import java.lang.template.ProcessorLinkage;\n-import java.lang.template.StringTemplate;\n-import java.lang.template.ValidatingProcessor;\n-import java.util.List;\n-import java.util.Objects;\n-\n-import jdk.internal.access.JavaUtilCollectionAccess;\n-import jdk.internal.access.SharedSecrets;\n-import jdk.internal.javac.PreviewFeature;\n-\n-\/**\n- * Manages the template creation and bootstrapping. These methods may be used, for example,\n- * by Java compiler implementations to implement the bodies of Object methods for\n- * {@link StringTemplate} classes.\n- *\/\n-@PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n-public final class TemplateSupport {\n-    \/**\n-     * {@link MethodHandle} to {@link TemplateBootstrap#defaultProcess}.\n-     *\/\n-    private static final MethodHandle DEFAULT_PROCESS_MH;\n-\n-    \/**\n-     * {@link MethodHandles.Lookup} passed to the bootstrap method.\n-     *\/\n-    private final MethodHandles.Lookup lookup;\n-\n-    \/**\n-     * Name passed to the bootstrap method (\"process\").\n-     *\/\n-    private final String name;\n-\n-    \/**\n-     * {@link MethodType} passed to the bootstrap method.\n-     *\/\n-    private final MethodType type;\n-\n-    \/**\n-     * Fragments from string template.\n-     *\/\n-    private final List<String> fragments;\n-\n-    \/**\n-     * The static final processor that triggered the BSM generation.\n-     *\/\n-    private final ValidatingProcessor<?, ?> processor;\n-\n-    private static final JavaUtilCollectionAccess JUCA = SharedSecrets.getJavaUtilCollectionAccess();\n-\n-    \/**\n-     * Initialize {@link MethodHandle MethodHandles}.\n-     *\/\n-    static {\n-        try {\n-            MethodHandles.Lookup lookup = MethodHandles.lookup();\n-\n-            MethodType mt = MethodType.methodType(Object.class,\n-                    List.class, ValidatingProcessor.class, Object[].class);\n-            DEFAULT_PROCESS_MH = lookup.findStatic(TemplateSupport.class, \"defaultProcess\", mt);\n-        } catch (ReflectiveOperationException ex) {\n-            throw new AssertionError(\"string bootstrap fail\", ex);\n-        }\n-    }\n-\n-    \/**\n-     * Constructor.\n-     *\n-     * @param lookup    method lookup\n-     * @param name      method name\n-     * @param type      method type\n-     * @param fragments fragments from string template\n-     * @param processor static final processor\n-     *\/\n-    TemplateSupport(MethodHandles.Lookup lookup, String name, MethodType type,\n-                    List<String> fragments,\n-                    ValidatingProcessor<?, ?> processor) {\n-        this.lookup = lookup;\n-        this.name = name;\n-        this.type = type;\n-        this.fragments = fragments;\n-        this.processor = processor;\n-\n-    }\n-\n-    \/**\n-     * Templated string bootstrap method.\n-     *\n-     * @param lookup          method lookup\n-     * @param name            method name\n-     * @param type            method type\n-     * @param processorGetter {@link MethodHandle} to get static final processor\n-     * @param fragments       fragments from string template\n-     * @return {@link CallSite} to handle templated string processing\n-     * @throws NullPointerException if any of the arguments is null\n-     * @throws Throwable            if linkage fails\n-     *\/\n-    public static CallSite stringTemplateBSM(\n-            MethodHandles.Lookup lookup,\n-            String name,\n-            MethodType type,\n-            MethodHandle processorGetter,\n-            String... fragments) throws Throwable {\n-        Objects.requireNonNull(lookup, \"lookup is null\");\n-        Objects.requireNonNull(name, \"name is null\");\n-        Objects.requireNonNull(type, \"type is null\");\n-        Objects.requireNonNull(processorGetter, \"processorGetter is null\");\n-        Objects.requireNonNull(fragments, \"fragments is null\");\n-\n-        ValidatingProcessor<?, ?> processor = (ValidatingProcessor<?, ?>)processorGetter.invoke();\n-        TemplateSupport support = new TemplateSupport(lookup, name, type, List.of(fragments), processor);\n-\n-        return support.processWithProcessor();\n-    }\n-\n-    \/**\n-     * Create callsite to invoke specialized processor process method.\n-     *\n-     * @return {@link CallSite} for processing templated strings.\n-     * @throws Throwable if linkage fails\n-     *\/\n-    CallSite processWithProcessor() throws Throwable {\n-        MethodHandle mh = processor instanceof ProcessorLinkage processorLinkage ?\n-                processorLinkage.linkage(fragments, type) : defaultProcessMethodHandle();\n-\n-        return new ConstantCallSite(mh);\n-    }\n-\n-    \/**\n-     * Creates a simple {@link StringTemplate} and then invokes the processor's process method.\n-     *\n-     * @param fragments fragments from string template\n-     * @param processor {@link ValidatingProcessor} to process\n-     * @param values    array of expression values\n-     * @return\n-     *\/\n-    private static Object defaultProcess(List<String> fragments,\n-                                         ValidatingProcessor<Object, Throwable> processor,\n-                                         Object[] values) throws Throwable {\n-        return processor.process(\n-            StringTemplate.of(fragments, JUCA.listFromTrustedArrayNullsAllowed(values)));\n-    }\n-\n-    \/**\n-     * Generate a {@link MethodHandle} which is effectively invokes\n-     * {@code processor.process(new StringTemplate(fragments, values...)}.\n-     *\n-     * @return default process {@link MethodHandle}\n-     *\/\n-    private MethodHandle defaultProcessMethodHandle() {\n-        MethodHandle mh = MethodHandles.insertArguments(DEFAULT_PROCESS_MH, 0, fragments, processor);\n-        return mh.asCollector(Object[].class, type.parameterCount()).asType(type);\n-    }\n-\n-    \/**\n-     * Collect nullable elements from an array into a unmodifiable list.\n-     *\n-     * @param elements  elements to place in list\n-     *\n-     * @return unmodifiable list.\n-     *\n-     * @param <E>  type of elements\n-     *\/\n-    @SafeVarargs\n-    @SuppressWarnings({\"unchecked\", \"varargs\"})\n-    public static <E> List<E> toList(E... elements) {\n-        return JUCA.listFromTrustedArrayNullsAllowed(elements);\n-    }\n-\n-}\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/template\/TemplateSupport.java","additions":0,"deletions":202,"binary":false,"changes":202,"status":"deleted"},{"patch":"@@ -204,1 +204,0 @@\n-    exports jdk.internal.template;\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -239,1 +239,1 @@\n-    public final Type templateSupportType;\n+    public final Type templateRuntimeType;\n@@ -630,1 +630,1 @@\n-        templateSupportType = enterClass(\"jdk.internal.template.TemplateSupport\");\n+        templateRuntimeType = enterClass(\"java.lang.runtime.TemplateRuntime\");\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symtab.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import com.sun.tools.javac.code.Scope.WriteableScope;\n@@ -33,1 +32,0 @@\n-import com.sun.tools.javac.code.Symbol.Completer;\n@@ -50,1 +48,0 @@\n-import com.sun.tools.javac.util.JCDiagnostic.SimpleDiagnosticPosition;\n@@ -55,2 +52,0 @@\n-import java.util.Arrays;\n-import java.util.Collections;\n@@ -58,1 +53,0 @@\n-import java.util.stream.Collectors;\n@@ -76,1 +70,0 @@\n-    private final char SYNTHETIC_NAME_CHAR;\n@@ -114,2 +107,0 @@\n-\n-        SYNTHETIC_NAME_CHAR = target.syntheticNameChar();\n@@ -276,220 +267,5 @@\n-        JCMethodInvocation createApply(Type owner, Name name, List<JCExpression> args, JCFieldAccess method) {\n-            List<Type> argTypes = TreeInfo.types(args);\n-            MethodSymbol methodSym = lookupMethod(tree.pos(), name, owner, argTypes);\n-            method.sym = methodSym;\n-            method.type = types.erasure(methodSym.type);\n-            JCMethodInvocation process = makeApply(method, args);\n-            process.type = methodSym.getReturnType();\n-            return process;\n-        }\n-\n-        JCMethodInvocation createApply(Type owner, Name name, List<JCExpression> args) {\n-            JCFieldAccess method = makeSelect(owner.tsym, name);\n-            return createApply(owner, name, args, method);\n-        }\n-\n-        JCMethodInvocation createApply(Symbol receiver, Name name, List<JCExpression> args) {\n-            Type owner = receiver.type;\n-            JCFieldAccess method = makeSelect(receiver, name);\n-            return createApply(owner, name, args, method);\n-        }\n-\n-        JCMethodInvocation createApplyToList(List<JCExpression> list, Type argType) {\n-            Type listType = makeListType(argType == null ? syms.objectType : argType);\n-            JCMethodInvocation toListApplied = createApply(syms.templateSupportType, names.toList, list)\n-                    .setType(listType);\n-            toListApplied.varargsElement = argType;\n-            return toListApplied;\n-        }\n-\n-        JCMethodInvocation createApplyExprMethod(JCMethodDecl exprMethod) {\n-            return createApply(stringTemplateClass.sym, exprMethod.name, List.nil());\n-        }\n-\n-        MethodInfo createMethod(long flags, Name name, Type returnType, List<Type> argTypes, JCClassDecl owner) {\n-            MethodType type = makeMethodType(returnType, argTypes);\n-            MethodSymbol sym = new MethodSymbol(flags, name, type, owner.sym);\n-            JCMethodDecl decl = make.MethodDef(sym, type, make.Block(0, List.nil()));\n-            owner.defs = owner.defs.append(decl);\n-            owner.sym.members().enter(sym);\n-            return new MethodInfo(type, sym, decl);\n-        }\n-\n-        void createFields() {\n-            int i = 0;\n-            for (JCExpression expression : expressions) {\n-\n-\n-                Type type = expression.type == syms.botType ? syms.objectType : expression.type;\n-                JCVariableDecl fieldVar = makeField(stringTemplateClass, PRIVATE, make.paramName(i++),\n-                        type, null);\n-                fields = fields.append(fieldVar);\n-            }\n-        }\n-\n-        void createFragmentsListAndMethod() {\n-            List<JCExpression> fragmentArgs = makeStringList(fragments);\n-            Type stringListType = makeListType(syms.stringType);\n-            fragmentsVar = makeField(stringTemplateClass, PRIVATE | STATIC,\n-                    names.fragmentsUpper, stringListType,\n-                    createApplyToList(fragmentArgs, syms.stringType));\n-            TransLiterals.MethodInfo method = createMethod(SYNTHETIC | PUBLIC, names.fragments,\n-                    stringListType, List.nil(), stringTemplateClass);\n-            method.addStatement(make.Return(make.QualIdent(fragmentsVar.sym)));\n-        }\n-\n-        void createValuesListAndMethod() {\n-            Type listType = makeListType(syms.objectType);\n-            valuesVar = makeField(stringTemplateClass, SYNTHETIC | PRIVATE, names.valuesUpper,\n-                    listType, null);\n-            MethodInfo method = createMethod(SYNTHETIC | PUBLIC, names.values,\n-                    listType, List.nil(), stringTemplateClass);\n-            JCExpression returnValues = make.QualIdent(valuesVar.sym);\n-            returnValues.type = listType;\n-            method.addStatement(make.Return(returnValues));\n-        }\n-\n-        List<JCExpression> createAccessors() {\n-            return fields.stream()\n-                    .map(f -> make.QualIdent(f.sym))\n-                    .collect(List.collector());\n-        }\n-\n-        void createInitMethod() {\n-            long flags = useValuesList ? PUBLIC | VARARGS\n-                                       : PUBLIC;\n-            List<Type> types = useValuesList ?\n-                    List.of(new ArrayType(syms.objectType, syms.arrayClass)) : expressionTypes;\n-            MethodInfo method = createMethod(flags, names.init,\n-                    syms.voidType, types, stringTemplateClass);\n-            JCIdent superIdent = make.Ident(names._super);\n-            superIdent.sym = lookupMethod(tree.pos(), names.init, syms.objectType, List.nil());\n-            superIdent.type = superIdent.sym.type;\n-            JCMethodInvocation superApply = make.Apply(List.nil(), translate(superIdent), List.nil());\n-            superApply.type = syms.voidType;\n-            method.addStatement(make.Exec(superApply));\n-            List<JCVariableDecl> params = method.decl.params;\n-\n-            if (useValuesList) {\n-                JCFieldAccess select = makeThisFieldSelect(stringTemplateClass.type, valuesVar);\n-                JCIdent ident = makeParamIdent(params, params.head.name);\n-                JCAssign assign = make.Assign(select, createApplyToList(List.of(ident), null));\n-                assign.type = ident.type;\n-                method.addStatement(make.Exec(assign));\n-            } else {\n-                for (JCVariableDecl field : fields) {\n-                    JCFieldAccess select = makeThisFieldSelect(stringTemplateClass.type, field);\n-                    JCIdent ident = makeParamIdent(params, field.name);\n-                    JCAssign assign = make.Assign(select, ident);\n-                    assign.type = ident.type;\n-                    method.addStatement(make.Exec(assign));\n-                }\n-            }\n-        }\n-\n-        void createValuesMethod() {\n-            Type objectListType = makeListType(syms.objectType);\n-            MethodInfo method = createMethod(SYNTHETIC | PUBLIC, names.values,\n-                    objectListType, List.nil(), stringTemplateClass);\n-            method.addStatement(make.Return(createApplyToList(createAccessors(), syms.objectType)));\n-        }\n-\n-        void createInterpolateMethod() {\n-            interpolateMethod = createMethod(SYNTHETIC | PUBLIC, names.interpolate,\n-                    syms.stringType, List.nil(), stringTemplateClass);\n-            interpolateMethod.addStatement(make.Return(concatExpression(fragments, createAccessors())));\n-        }\n-\n-        void createToStringMethod() {\n-            MethodInfo toStringMethod = createMethod(PUBLIC, names.toString,\n-                    syms.stringType, List.nil(), stringTemplateClass);\n-            JCExpression applytoString = this.createApply(syms.stringTemplateType, names.toString,\n-                    List.of(make.This(stringTemplateClass.type)));\n-            toStringMethod.addStatement(make.Return(applytoString));\n-        }\n-\n-        void createHashCodeMethod() {\n-            MethodInfo toHashCodeMethod = createMethod(PUBLIC, names.hashCode,\n-                    syms.intType, List.nil(), stringTemplateClass);\n-            JCExpression applyHashCode = this.createApply(syms.stringTemplateType, names.hashCode,\n-                    List.of(make.This(stringTemplateClass.type)));\n-            toHashCodeMethod.addStatement(make.Return(applyHashCode));\n-        }\n-\n-        void createEqualsMethod() {\n-            MethodInfo toEqualsMethod = createMethod(PUBLIC, names.equals,\n-                    syms.booleanType, List.of(syms.objectType), stringTemplateClass);\n-            List<JCVariableDecl> params = toEqualsMethod.decl.params;\n-            JCIdent ident = makeParamIdent(params, params.head.name);\n-            JCExpression applyEquals = this.createApply(syms.stringTemplateType, names.equals,\n-                    List.of(make.TypeCast(syms.objectType, make.This(stringTemplateClass.type)), ident));\n-            toEqualsMethod.addStatement(make.Return(applyEquals));\n-        }\n-\n-        private JCClassDecl newStringTemplateClass() {\n-            long flags = PUBLIC | FINAL | SYNTHETIC;\n-\n-            if (currentMethodSym.isStatic()) {\n-                flags |= NOOUTERTHIS;\n-            }\n-\n-            Name name = chk.localClassName(syms.defineClass(names.empty, currentClass));\n-            JCClassDecl cDecl =  make.ClassDef(make.Modifiers(flags), name, List.nil(), null, List.nil(), List.nil());\n-            ClassSymbol cSym = syms.defineClass(name, currentMethodSym);\n-            cSym.sourcefile = currentClass.sourcefile;\n-            cSym.completer = Completer.NULL_COMPLETER;\n-            cSym.members_field = WriteableScope.create(cSym);\n-            cSym.flags_field = flags;\n-            ClassType cType = (ClassType)cSym.type;\n-            cType.supertype_field = syms.objectType;\n-            cType.interfaces_field = List.of(syms.stringTemplateType);\n-            cType.all_interfaces_field = List.of(syms.stringTemplateType);\n-            cType.setEnclosingType(currentClass.type);\n-            cDecl.sym = cSym;\n-            cDecl.type = cType;\n-            cSym.complete();\n-\n-            return cDecl;\n-        }\n-\n-        void createStringTemplateClass() {\n-            ClassSymbol saveCurrentClass = currentClass;\n-\n-            try {\n-                Type stringTemplateType = syms.stringTemplateType;\n-                stringTemplateClass = newStringTemplateClass();\n-                currentClass = stringTemplateClass.sym;\n-                createFragmentsListAndMethod();\n-                createToStringMethod();\n-                createHashCodeMethod();\n-                createEqualsMethod();\n-\n-                if (useValuesList) {\n-                    createValuesListAndMethod();\n-                } else {\n-                    createFields();\n-                    createValuesMethod();\n-                    createInterpolateMethod();\n-                }\n-\n-                createInitMethod();\n-                saveCurrentClass.members().enter(stringTemplateClass.sym);\n-            } finally {\n-                currentClass = saveCurrentClass;\n-            }\n-        }\n-\n-        JCExpression createBSMProcessorPerformMethodCall() {\n-            List<JCExpression> args = expressions.prepend(processor);\n-            List<Type> argTypes = expressionTypes.prepend(processor.type);\n-            Name bootstrapName = names.stringTemplateBSM;\n-            Name methodName = names.process;\n-            VarSymbol processorSym = (VarSymbol)TreeInfo.symbol(processor);\n-            List<LoadableConstant> staticArgValues = List.of(processorSym.asMethodHandle(true));\n-            List<Type> staticArgsTypes =\n-                    List.of(syms.methodHandleLookupType, syms.stringType,\n-                            syms.methodTypeType, syms.methodHandleType);\n-            for (String fragment : fragments) {\n-                staticArgValues = staticArgValues.append(LoadableConstant.String(fragment));\n-                staticArgsTypes = staticArgsTypes.append(syms.stringType);\n-            }\n+        JCExpression bsmCall(Name name, Name bootstrapName, Type type,\n+                             List<JCExpression> args,\n+                             List<Type> argTypes,\n+                             List<LoadableConstant> staticArgValues,\n+                             List<Type> staticArgsTypes) {\n@@ -497,2 +273,2 @@\n-                    syms.templateSupportType, bootstrapName, staticArgsTypes, List.nil());\n-            MethodType indyType = new MethodType(argTypes, tree.type, List.nil(), syms.methodClass);\n+                    syms.templateRuntimeType, bootstrapName, staticArgsTypes, List.nil());\n+            MethodType indyType = new MethodType(argTypes, type, List.nil(), syms.methodClass);\n@@ -500,1 +276,1 @@\n-                    methodName,\n+                    name,\n@@ -508,4 +284,4 @@\n-            qualifier.type = tree.type;\n-            JCExpression process = make.Apply(List.nil(), qualifier, args);\n-            process.type = tree.type;\n-            return process;\n+            qualifier.type = type;\n+            JCMethodInvocation apply = make.Apply(List.nil(), qualifier, args);\n+            apply.type = type;\n+            return apply;\n@@ -514,1 +290,1 @@\n-        JCExpression createProcessorPerformMethodCall(JCExpression stringTemplate) {\n+        JCExpression processCall(JCExpression stringTemplate) {\n@@ -525,13 +301,42 @@\n-            createStringTemplateClass();\n-            List<JCExpression> args = expressions;\n-            List<Type> argTypes = expressionTypes;\n-            JCExpression encl = currentMethodSym.isStatic() ? null :\n-                    make.This(currentMethodSym.owner.type);\n-            JCNewClass newClass = make.NewClass(encl,\n-                    null, make.QualIdent(stringTemplateClass.type.tsym), args, stringTemplateClass);\n-            newClass.constructor = rs.resolveConstructor(\n-                    new SimpleDiagnosticPosition(make.pos), env, stringTemplateClass.type, argTypes, List.nil());\n-            newClass.type = stringTemplateClass.type;\n-            newClass.varargsElement = useValuesList ? syms.objectType : null;\n-\n-            return newClass;\n+            List<LoadableConstant> staticArgValues = List.nil();\n+            List<Type> staticArgsTypes =\n+                    List.of(syms.methodHandleLookupType, syms.stringType,\n+                            syms.methodTypeType);\n+            if (useValuesList) {\n+                JCNewArray fragmentArray = make.NewArray(make.Type(syms.stringType),\n+                        List.nil(), makeStringList(fragments));\n+                fragmentArray.type = new ArrayType(syms.stringType, syms.arrayClass);\n+\n+                JCNewArray valuesArray = make.NewArray(make.Type(syms.objectType),\n+                        List.nil(), expressions);\n+                valuesArray.type = new ArrayType(syms.objectType, syms.arrayClass);\n+                return bsmCall(names.process, names.stringTemplateBSM, syms.stringTemplateType,\n+                        List.of(fragmentArray, valuesArray),\n+                        List.of(fragmentArray.type, valuesArray.type),\n+                        staticArgValues, staticArgsTypes);\n+            } else {\n+                VarSymbol processorSym = (VarSymbol)TreeInfo.symbol(processor);\n+                for (String fragment : fragments) {\n+                    staticArgValues = staticArgValues.append(LoadableConstant.String(fragment));\n+                    staticArgsTypes = staticArgsTypes.append(syms.stringType);\n+                }\n+                return bsmCall(names.process, names.stringTemplateBSM, syms.stringTemplateType,\n+                        expressions, expressionTypes, staticArgValues, staticArgsTypes);\n+            }\n+        }\n+\n+        JCExpression bsmProcessCall() {\n+            List<JCExpression> args = expressions.prepend(processor);\n+            List<Type> argTypes = expressionTypes.prepend(processor.type);\n+\n+            VarSymbol processorSym = (VarSymbol)TreeInfo.symbol(processor);\n+            List<LoadableConstant> staticArgValues = List.of(processorSym.asMethodHandle(true));\n+            List<Type> staticArgsTypes =\n+                    List.of(syms.methodHandleLookupType, syms.stringType,\n+                            syms.methodTypeType, syms.methodHandleType);\n+            for (String fragment : fragments) {\n+                staticArgValues = staticArgValues.append(LoadableConstant.String(fragment));\n+                staticArgsTypes = staticArgsTypes.append(syms.stringType);\n+            }\n+            return bsmCall(names.process, names.stringTemplateBSM, tree.type,\n+                    args, argTypes, staticArgValues, staticArgsTypes);\n@@ -540,1 +345,1 @@\n-        boolean isSTRProcessor() {\n+        boolean isNamedProcessor(Name name) {\n@@ -543,1 +348,1 @@\n-                        varSym.name == names.str &&\n+                        varSym.name == name &&\n@@ -565,1 +370,1 @@\n-            if (processor == null) {\n+            if (processor == null || isNamedProcessor(names.raw)) {\n@@ -567,1 +372,1 @@\n-            } else if (isSTRProcessor()) {\n+            } else if (isNamedProcessor(names.str)) {\n@@ -570,1 +375,1 @@\n-                result = createBSMProcessorPerformMethodCall();\n+                result = bsmProcessCall();\n@@ -572,1 +377,1 @@\n-                result = createProcessorPerformMethodCall(newStringTemplate());\n+                result = processCall(newStringTemplate());\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TransLiterals.java","additions":61,"deletions":256,"binary":false,"changes":317,"status":"modified"},{"patch":"@@ -1,1 +0,0 @@\n-\/*\n@@ -238,5 +237,5 @@\n-     *     mode = EXPR          : an expression\n-     *     mode = TYPE          : a type\n-     *     mode = NOPARAMS      : no parameters allowed for type\n-     *     mode = TYPEARG       : type argument\n-     *     mode |= NOLAMBDA     : lambdas are not allowed\n+     *     mode = EXPR        : an expression\n+     *     mode = TYPE        : a type\n+     *     mode = NOPARAMS    : no parameters allowed for type\n+     *     mode = TYPEARG     : type argument\n+     *     mode |= NOLAMBDA   : lambdas are not allowed\n@@ -1898,1 +1897,1 @@\n-                                                      : ParensResult.PARENS;\n+                                                 : ParensResult.PARENS;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -227,5 +227,0 @@\n-    public final Name interpolate;\n-    public final Name fragments;\n-    public final Name fragmentsUpper;\n-    public final Name valuesUpper;\n-    public final Name toList;\n@@ -233,0 +228,1 @@\n+    public final Name raw;\n@@ -410,5 +406,0 @@\n-        interpolate = fromString(\"interpolate\");\n-        fragments = fromString(\"fragments\");\n-        fragmentsUpper = fromString(\"FRAGMENTS\");\n-        valuesUpper = fromString(\"VALUES\");\n-        toList = fromString(\"toList\");\n@@ -416,0 +407,1 @@\n+        raw = fromString(\"RAW\");\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/Names.java","additions":2,"deletions":10,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -24,2 +24,6 @@\n-import java.lang.invoke.*;\n-import java.util.*;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.StringConcatFactory;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n@@ -30,2 +34,1 @@\n- * @compile --enable-preview -source ${jdk.version} MakeConcatWithTemplate.java\n- * @run main\/othervm --enable-preview MakeConcatWithTemplate\n+ * @enablePreview true\n","filename":"test\/jdk\/java\/lang\/String\/concat\/MakeConcatWithTemplate.java","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -28,2 +28,1 @@\n- * @compile --enable-preview -source ${jdk.version} Basic.java\n- * @run main\/othervm --enable-preview Basic\n+ * @enablePreview true\n","filename":"test\/jdk\/java\/lang\/template\/Basic.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,166 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Test features provided by the Carriers class.\n+ * @modules java.base\/java.lang.template\n+ * @enablePreview true\n+ * @compile --patch-module java.base=${test.src} CarriersTest.java\n+ * @run main\/othervm --patch-module java.base=${test.class.path} java.lang.template.CarriersTest\n+ *\/\n+\n+package java.lang.template;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodType;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+public class CarriersTest {\n+    public static void main(String[] args) throws Throwable {\n+        primitivesTest();\n+        primitivesTestLarge();\n+        limitsTest();\n+    }\n+\n+    static void assertTrue(boolean test, String message) {\n+        if (!test) {\n+            throw new RuntimeException(message);\n+        }\n+    }\n+\n+    static final int MAX_COMPONENTS = 254;\n+\n+    static void primitivesTest() throws Throwable {\n+        MethodType methodType =\n+                MethodType.methodType(Object.class, byte.class, short.class,\n+                        char.class, int.class, long.class,\n+                        float.class, double.class,\n+                        boolean.class, String.class);\n+        MethodHandle constructor = Carriers.initializingConstructor(methodType);\n+        Object object = (Object)constructor.invokeExact((byte)0xFF, (short)0xFFFF,\n+                'C', 0xFFFFFFFF, 0xFFFFFFFFFFFFFFFFL,\n+                1.0f \/ 3.0f, 1.0 \/ 3.0,\n+                true, \"abcde\");\n+        List<MethodHandle> components = Carriers.components(methodType);\n+        assertTrue((byte)components.get(0).invokeExact(object) == (byte)0xFF,\n+                \"primitive byte test failure\");\n+        assertTrue((short)components.get(1).invokeExact(object) == (short)0xFFFF,\n+                \"primitive short test failure\");\n+        assertTrue((char)components.get(2).invokeExact(object) == 'C',\n+                \"primitive char test failure\");\n+        assertTrue((int)components.get(3).invokeExact(object) == 0xFFFFFFFF,\n+                \"primitive int test failure\");\n+        assertTrue((long)components.get(4).invokeExact(object) == 0xFFFFFFFFFFFFFFFFL,\n+                \"primitive long test failure\");\n+        assertTrue((float)components.get(5).invokeExact(object) == 1.0f \/ 3.0f,\n+                \"primitive float test failure\");\n+        assertTrue((double)components.get(6).invokeExact(object) == 1.0 \/ 3.0,\n+                \"primitive double test failure\");\n+        assertTrue((boolean)components.get(7).invokeExact(object),\n+                \"primitive boolean test failure\");\n+        assertTrue(\"abcde\".equals((String)components.get(8).invokeExact(object)),\n+                \"primitive String test failure\");\n+    }\n+\n+    static void primitivesTestLarge() throws Throwable {\n+        MethodType methodType =\n+                MethodType.methodType(Object.class, byte.class, short.class,\n+                        char.class, int.class, long.class,\n+                        float.class, double.class,\n+                        boolean.class, String.class,\n+                        Object.class, Object.class,Object.class,Object.class,\n+                        Object.class, Object.class,Object.class,Object.class,\n+                        Object.class, Object.class,Object.class,Object.class,\n+                        Object.class, Object.class,Object.class,Object.class,\n+                        Object.class, Object.class,Object.class,Object.class,\n+                        Object.class, Object.class,Object.class,Object.class,\n+                        Object.class, Object.class,Object.class,Object.class\n+                );\n+        MethodHandle constructor = Carriers.initializingConstructor(methodType);\n+        Object object = (Object)constructor.invokeExact((byte)0xFF, (short)0xFFFF,\n+                'C', 0xFFFFFFFF, 0xFFFFFFFFFFFFFFFFL,\n+                1.0f \/ 3.0f, 1.0 \/ 3.0,\n+                true, \"abcde\",\n+                (Object)null, (Object)null, (Object)null, (Object)null,\n+                (Object)null, (Object)null, (Object)null, (Object)null,\n+                (Object)null, (Object)null, (Object)null, (Object)null,\n+                (Object)null, (Object)null, (Object)null, (Object)null,\n+                (Object)null, (Object)null, (Object)null, (Object)null,\n+                (Object)null, (Object)null, (Object)null, (Object)null,\n+                (Object)null, (Object)null, (Object)null, (Object)null\n+        );\n+        List<MethodHandle> components = Carriers.components(methodType);\n+        assertTrue((byte)components.get(0).invokeExact(object) == (byte)0xFF,\n+                \"large primitive byte test failure\");\n+        assertTrue((short)components.get(1).invokeExact(object) == (short)0xFFFF,\n+                \"large primitive short test failure\");\n+        assertTrue((char)components.get(2).invokeExact(object) == 'C',\n+                \"large primitive char test failure\");\n+        assertTrue((int)components.get(3).invokeExact(object) == 0xFFFFFFFF,\n+                \"large primitive int test failure\");\n+        assertTrue((long)components.get(4).invokeExact(object) == 0xFFFFFFFFFFFFFFFFL,\n+                \"large primitive long test failure\");\n+        assertTrue((float)components.get(5).invokeExact(object) == 1.0f \/ 3.0f,\n+                \"large primitive float test failure\");\n+        assertTrue((double)components.get(6).invokeExact(object) == 1.0 \/ 3.0,\n+                \"large primitive double test failure\");\n+        assertTrue((boolean)components.get(7).invokeExact(object),\n+                \"large primitive boolean test failure\");\n+        assertTrue(\"abcde\".equals((String)components.get(8).invokeExact(object)),\n+                \"large primitive String test failure\");\n+    }\n+\n+    static void limitsTest() {\n+        boolean passed;\n+\n+        passed = false;\n+        try {\n+            Class<?>[] ptypes = new Class<?>[MAX_COMPONENTS + 1];\n+            Arrays.fill(ptypes, Object.class);\n+            MethodType methodType = MethodType.methodType(Object.class, ptypes);\n+            MethodHandle constructor = Carriers.constructor(methodType);\n+        } catch (IllegalArgumentException ex) {\n+            passed = true;\n+        }\n+\n+        if (!passed) {\n+            throw new RuntimeException(\"failed to report too many components \");\n+        }\n+\n+        passed = false;\n+        try {\n+            Class<?>[] ptypes = new Class<?>[MAX_COMPONENTS \/ 2 + 1];\n+            Arrays.fill(ptypes, long.class);\n+            MethodType methodType = MethodType.methodType(Object.class, ptypes);\n+            MethodHandle constructor = Carriers.constructor(methodType);\n+        } catch (IllegalArgumentException ex) {\n+            passed = true;\n+        }\n+\n+        if (!passed) {\n+            throw new RuntimeException(\"failed to report too many components \");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/template\/CarriersTest.java","additions":166,"deletions":0,"binary":false,"changes":166,"status":"added"},{"patch":"@@ -28,2 +28,1 @@\n- * @compile --enable-preview -source ${jdk.version} FormatterBuilder.java\n- * @run main\/othervm --enable-preview FormatterBuilder\n+ * @enablePreview true\n@@ -32,2 +31,5 @@\n-import java.lang.template.*;\n-import java.util.*;\n+import java.lang.template.StringTemplate;\n+import java.lang.template.StringProcessor;\n+import java.util.FormatProcessor;\n+import java.util.Objects;\n+import java.util.Locale;\n@@ -53,1 +55,1 @@\n-    static void suite(ValidatingProcessor<String, RuntimeException> fmt) {\n+    static void suite(StringProcessor fmt) {\n","filename":"test\/jdk\/java\/lang\/template\/FormatterBuilder.java","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,109 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Test features provided by the ReferencedKeyMap class.\n+ * @modules java.base\/java.lang.template\n+ * @enablePreview\n+ * @compile --patch-module java.base=${test.src} ReferencedKeyTest.java\n+ * @run main\/othervm --patch-module java.base=${test.class.path} java.lang.template.ReferencedKeyTest\n+ *\/\n+\n+package java.lang.template;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.Supplier;\n+\n+public class ReferencedKeyTest {\n+    static long BASE_KEY = 10_000_000L;\n+\n+    public static void main(String[] args) throws Throwable {\n+        mapTest(false, HashMap::new);\n+        mapTest(true, HashMap::new);\n+        mapTest(false, ConcurrentHashMap::new);\n+        mapTest(true, ConcurrentHashMap::new);\n+    }\n+\n+    static void assertTrue(boolean test, String message) {\n+        if (!test) {\n+            throw new RuntimeException(message);\n+        }\n+    }\n+\n+    static void  mapTest(boolean isSoft, Supplier<Map<?, ?>> supplier) {\n+        Map<Long, String> map = ReferencedKeyMap.create(isSoft, supplier);\n+        populate(map);\n+        collect();\n+        \/\/ assertTrue(map.isEmpty() || isSoft, \"Weak not collecting\");\n+        populate(map);\n+        methods(map);\n+    }\n+\n+    static void methods(Map<Long, String> map) {\n+        assertTrue(map.size() == 26, \"missing key\");\n+        assertTrue(map.containsKey(BASE_KEY + 'a' -'a'), \"missing key\");\n+        assertTrue(map.get(BASE_KEY + 'b' -'a').equals(\"b\"), \"wrong key\");\n+        assertTrue(map.containsValue(\"c\"), \"missing value\");\n+        map.remove(BASE_KEY + 'd' -'a');\n+        assertTrue(map.get(BASE_KEY + 'd' -'a') == null, \"not removed\");\n+        map.putAll(Map.of(1L, \"A\", 2L, \"B\"));\n+        assertTrue(map.get(2L).equals(\"B\"), \"collection not added\");\n+        assertTrue(map.keySet().contains(1L), \"key missing\");\n+        assertTrue(map.values().contains(\"A\"), \"key missing\");\n+        assertTrue(map.entrySet().contains(Map.entry(1L, \"A\")), \"key missing\");\n+        map.putIfAbsent(3L, \"C\");\n+        assertTrue(map.get(3L).equals(\"C\"), \"key missing\");\n+        map.putIfAbsent(2L, \"D\");\n+        assertTrue(map.get(2L).equals(\"B\"), \"key replaced\");\n+        map.remove(3L);\n+        assertTrue(map.get(3L) == null, \"key not removed\");\n+        map.replace(2L, \"D\");\n+        assertTrue(map.get(2L).equals(\"D\"), \"key not replaced\");\n+        map.replace(2L, \"B\", \"E\");\n+        assertTrue(map.get(2L).equals(\"D\"), \"key replaced\");\n+    }\n+\n+    static void collect() {\n+        System.gc();\n+        sleep();\n+    }\n+\n+    static void sleep() {\n+        try {\n+            Thread.sleep(100L);\n+        } catch (InterruptedException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    static void populate(Map<Long, String> map) {\n+        for (int i = 0; i < 26; i++) {\n+            Long key = BASE_KEY + i;\n+            String value = String.valueOf((char) ('a' + i));\n+            map.put(key, value);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/template\/ReferencedKeyTest.java","additions":109,"deletions":0,"binary":false,"changes":109,"status":"added"}]}