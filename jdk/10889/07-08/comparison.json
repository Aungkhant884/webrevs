{"files":[{"patch":"@@ -44,1 +44,3 @@\n- * Manages the template creation and bootstrapping.\n+ * Manages the template creation and bootstrapping. These methods may be used, for example,\n+ * by Java compiler implementations to implement the bodies of Object methods for\n+ * {@link StringTemplate} classes.\n@@ -172,1 +174,1 @@\n-            StringTemplate.of(fragments, toList(values)));\n+            StringTemplate.of(fragments, JUCA.listFromTrustedArrayNullsAllowed(values)));\n@@ -199,1 +201,1 @@\n-    @SuppressWarnings(\"unchecked\")\n+    @SuppressWarnings({\"unchecked\", \"varargs\"})\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/TemplateSupport.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -151,0 +151,3 @@\n+     *\n+     * @implNote Compiler generated {@link StringTemplate StringTemplates} create a specialized\n+     * optimal version of interpolate for each string template expression.\n@@ -266,2 +269,2 @@\n-               Objects.equals(aST.fragments(), bST.fragments()) &&\n-               Objects.equals(aST.values(), bST.values());\n+                Objects.equals(aST.fragments(), bST.fragments()) &&\n+                Objects.equals(aST.values(), bST.values());\n@@ -309,1 +312,1 @@\n-        values = TemplateRuntime.toList(values.toArray());\n+        values = TemplateRuntime.toList(values.toArray().clone());\n@@ -313,1 +316,1 @@\n-     \/**\n+    \/**\n","filename":"src\/java.base\/share\/classes\/java\/lang\/template\/StringTemplate.java","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import java.lang.reflect.Array;\n@@ -35,0 +36,1 @@\n+import java.util.Arrays;\n@@ -96,2 +98,2 @@\n-    @SuppressWarnings(\"unchecked\")\n-    private static <E> List<E> toList(E... elements) {\n+    @SuppressWarnings({\"unchecked\", \"varargs\"})\n+    static <E> List<E> toList(E... elements) {\n@@ -112,1 +114,2 @@\n-     * embedded expressions, otherwise this method returns the values list types.\n+     * embedded expressions, otherwise this method returns a list of\n+     * {@code Object.class}.\n@@ -116,1 +119,0 @@\n-        List<Class<?>> result = new ArrayList<>();\n@@ -119,0 +121,1 @@\n+            List<Class<?>> result = new ArrayList<>();\n@@ -129,1 +132,0 @@\n-\n@@ -132,4 +134,4 @@\n-        for (Object value : st.values()) {\n-            result.add(value == null ? Object.class : value.getClass());\n-        }\n-        return result;\n+        int size = st.values().size();\n+        Class<?>[] types = new Class<?>[size];\n+        Arrays.fill(types, Object.class);\n+        return List.of(types);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/template\/TemplateRuntime.java","additions":11,"deletions":9,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -396,0 +396,2 @@\n+            } else if (token.kind == TokenKind.EOF) {\n+                break;\n@@ -562,0 +564,1 @@\n+            TokenKind prevTK = tk;\n@@ -564,0 +567,3 @@\n+            if (prevTK == TokenKind.STRINGLITERAL) {\n+                tk = TokenKind.STRINGFRAGMENT;\n+            }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavaTokenizer.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -488,1 +488,1 @@\n-                } while (current != null && current.endPos <= endPos);\n+                } while (current != null && current.endPos <= endPos && current.kind != TokenKind.EOF);\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/CompletenessAnalyzer.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -92,1 +92,2 @@\n-        \"record.length()\"\n+        \"record.length()\",\n+        \"\\\"\\\\{0}\\\"\"\n@@ -235,1 +236,6 @@\n-        \"new ;\"\n+        \"new ;\",\n+        \"\\\"\",\n+        \"\\\"\\\\\",\n+        \"\\\"\\\\{\",\n+        \"\\\"\\\\{0\",\n+        \"\\\"\\\\{0}\",\n@@ -372,0 +378,1 @@\n+        assertStatus(\"\\\"\\\"\\\"\\n\", DEFINITELY_INCOMPLETE, null);\n@@ -379,0 +386,4 @@\n+        assertStatus(\"\\\"\\\"\\\"\\n\\\\\", DEFINITELY_INCOMPLETE, null);\n+        assertStatus(\"\\\"\\\"\\\"\\n\\\\{\", DEFINITELY_INCOMPLETE, null);\n+        assertStatus(\"\\\"\\\"\\\"\\n\\\\{0\", DEFINITELY_INCOMPLETE, null);\n+        assertStatus(\"\\\"\\\"\\\"\\n\\\\{0}\", DEFINITELY_INCOMPLETE, null);\n","filename":"test\/langtools\/jdk\/jshell\/CompletenessTest.java","additions":13,"deletions":2,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -88,0 +88,2 @@\n+import com.sun.tools.javac.api.JavacTaskPool;\n+import com.sun.tools.javac.api.JavacTaskPool.Worker;\n@@ -2038,0 +2040,57 @@\n+    @Test\n+    void testIncompleteStringTemplate() throws IOException {\n+        String template = \"\\\"\\\\{o.toString()}\\\"\";\n+        String prefix = \"\"\"\n+                      package t;\n+                      class Test {\n+                          void test(Object o) {\n+                              String s = STR.\"\"\";\n+\n+        Worker<Void> verifyParseable = task -> {\n+            try {\n+                task.parse().iterator().next();\n+                return null;\n+            } catch (IOException ex) {\n+                throw new AssertionError(ex);\n+            }\n+        };\n+        JavacTaskPool pool = new JavacTaskPool(1);\n+        DiagnosticListener<JavaFileObject> dl = d -> {};\n+        List<String> options = List.of(\"--enable-preview\",\n+                                       \"-source\", System.getProperty(\"java.specification.version\"));\n+        for (int i = 0; i < template.length(); i++) {\n+            pool.getTask(null, fm, dl, options,\n+                    null, Arrays.asList(new MyFileObject(prefix + template.substring(0, i))),\n+                    verifyParseable\n+            );\n+        }\n+        for (int i = 0; i < template.length() - 1; i++) {\n+            pool.getTask(null, fm, dl, options,\n+                    null, Arrays.asList(new MyFileObject(prefix + template.substring(0, i) + \"\\\"\")),\n+                    verifyParseable);\n+        }\n+        String incomplete = prefix + \"\\\"\\\\{o.\";\n+        pool.getTask(null, fm, dl, options,\n+                null, Arrays.asList(new MyFileObject(incomplete)), task -> {\n+            try {\n+                CompilationUnitTree cut = task.parse().iterator().next();\n+                String result = cut.toString().replaceAll(\"\\\\R\", \"\\n\");\n+                assertEquals(\"incorrect AST\",\n+                             result,\n+                             \"\"\"\n+                             package t;\n+\n+                             class Test {\n+                                 \\n\\\n+                                 void test(Object o) {\n+                                     String s = [STR]\"\\\\{}\"(o.<error>);\n+                                 }\n+                             }\"\"\");\n+                return null;\n+            } catch (IOException ex) {\n+                throw new AssertionError(ex);\n+\n+            }\n+        });\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/parser\/JavacParserTest.java","additions":59,"deletions":0,"binary":false,"changes":59,"status":"modified"}]}