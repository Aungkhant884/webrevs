{"files":[{"patch":"@@ -28,1 +28,0 @@\n-import java.lang.invoke.CallSite;\n@@ -136,0 +135,2 @@\n+     *\n+     * @implSpec the list returned is immutable\n@@ -151,0 +152,2 @@\n+     *\n+     * @implSpec the list returned is immutable\n@@ -574,1 +577,1 @@\n-         * @param <R>  Processor's process result type\n+         * @param <T>  Processor's process result type\n@@ -576,1 +579,1 @@\n-        static <R> Processor<R, RuntimeException> of(Function<? super StringTemplate, ? extends R> process) {\n+        static <T> Processor<T, RuntimeException> of(Function<? super StringTemplate, ? extends T> process) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StringTemplate.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1056,0 +1056,1 @@\n+     * @throws IllegalArgumentException If the number of value slots exceed {@link #MAX_INDY_CONCAT_ARG_SLOTS}.\n@@ -1186,0 +1187,1 @@\n+     * @throws IllegalArgumentException If the number of value slots exceed {@link #MAX_INDY_CONCAT_ARG_SLOTS}.\n@@ -1262,0 +1264,1 @@\n+     * @throws IllegalArgumentException If the number of value slots exceed {@link #MAX_INDY_CONCAT_ARG_SLOTS}.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/StringConcatFactory.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -46,13 +46,49 @@\n- * Manages string template bootstrapping and creation. These methods may be used, for example,\n- * by Java compiler implementations to implement the bodies of methods for {@link StringTemplate}\n- * objects.\n- * <p>\n- * The {@link TemplateRuntime#newLargeStringTemplate} bootstrap method is used to create\n- * {@link StringTemplate StringTemplates} that have more than\n- * {@link java.lang.invoke.StringConcatFactory#MAX_INDY_CONCAT_ARG_SLOTS} values.\n- * <p>\n- * The {@link TemplateRuntime#newStringTemplate} bootstrap method is used to create\n- * optimized {@link StringTemplate StringTemplates}.\n- * <p>\n- * The {@link TemplateRuntime#newLargeStringTemplate} bootstrap method is used\n- * to bind to specialized processors that implement {@link Linkage}.\n+ * Manages string template bootstrap methods. These methods may be used, for example,\n+ * by Java compiler implementations to create {@link StringTemplate} instances. For example,\n+ * the java compiler will translate the following code;\n+ * {@snippet :\n+ * int x = 10;\n+ * int y = 20;\n+ * StringTemplate st = RAW.\"\\{x} + \\{y} = \\{x + y}\";\n+ * }\n+ * to byte code that invokes the {@link java.lang.runtime.TemplateRuntime#newStringTemplate}\n+ * bootstrap method to construct a {@link CallSite} that accepts two integers and produces a new\n+ * {@link StringTemplate} instance.\n+ * {@snippet :\n+ * MethodHandles.Lookup lookup = MethodHandles.lookup();\n+ * MethodType mt = MethodType.methodType(StringTemplate.class, int.class, int.class);\n+ * CallSite cs = TemplateRuntime.newStringTemplate(lookup, \"\", mt, \"\", \" + \", \" = \", \"\");\n+ * ...\n+ * int x = 10;\n+ * int y = 20;\n+ * StringTemplate st = (StringTemplate)cs.getTarget().invokeExact(x, y);\n+ * }\n+ * If the string template requires more than\n+ * {@link java.lang.invoke.StringConcatFactory#MAX_INDY_CONCAT_ARG_SLOTS} value slots,\n+ * then the java compiler will use the\n+ * {@link java.lang.runtime.TemplateRuntime#newLargeStringTemplate} bootstrap method\n+ * instead. For example, the java compiler will translate the following code;\n+ * {@snippet :\n+ * int[] a = new int[1000], b = new int[1000];\n+ * ...\n+ * StringTemplate st = \"\"\"\n+ *      \\{a[0]} - \\{b[0]}\n+ *      \\{a[1]} - \\{b[1]}\n+ *      ...\n+ *      \\{a[999]} - \\{b[999]}\n+ *      \"\"\";\n+ * }\n+ * to byte code that invokes the {@link java.lang.runtime.TemplateRuntime#newLargeStringTemplate}\n+ * bootstrap method to construct a {@link CallSite} that accepts an array of integers and produces a new\n+ * {@link StringTemplate} instance.\n+ * {@snippet :\n+ * MethodType mt = MethodType.methodType(StringTemplate.class, String[].class, Object[].class);\n+ * CallSite cs = TemplateRuntime.newStringTemplate(lookup, \"\", mt);\n+ * ...\n+ * int[] a = new int[1000], b = new int[1000];\n+ * ...\n+ * StringTemplate st = (StringTemplate)cs.getTarget().invokeExact(\n+ *         new String[] { \"\", \" - \", \"\\n\", \" - \", \"\\n\", ... \" - \", \"\\n\" },\n+ *         new Object[] { a[0], b[0], a[1], b[1], ..., a[999], b[999]}\n+ *         );\n+ * }\n@@ -103,26 +139,0 @@\n-    \/**\n-     * String template bootstrap method for creating large string templates,\n-     * i.e., when the number of value slots exceeds\n-     * {@link java.lang.invoke.StringConcatFactory#MAX_INDY_CONCAT_ARG_SLOTS}.\n-     * The non-static arguments are the fragments array and values array.\n-     *\n-     * @param lookup          method lookup\n-     * @param name            method name - not used\n-     * @param type            method type\n-     *                        (String[], Object[]) -> StringTemplate\n-     *\n-     * @return {@link CallSite} to handle create large string template\n-     *\n-     * @throws NullPointerException if any of the arguments is null\n-     * @throws Throwable            if linkage fails\n-     *\/\n-    public static CallSite newLargeStringTemplate(MethodHandles.Lookup lookup,\n-                                                  String name,\n-                                                  MethodType type) throws Throwable {\n-        Objects.requireNonNull(lookup, \"lookup is null\");\n-        Objects.requireNonNull(name, \"name is null\");\n-        Objects.requireNonNull(type, \"type is null\");\n-\n-        return new ConstantCallSite(NEW_TRUSTED_STRING_TEMPLATE.asType(type));\n-    }\n-\n@@ -134,1 +144,1 @@\n-     * @param lookup          method lookup\n+     * @param lookup          method lookup from call site\n@@ -160,0 +170,26 @@\n+    \/**\n+     * String template bootstrap method for creating large string templates,\n+     * i.e., when the number of value slots exceeds\n+     * {@link java.lang.invoke.StringConcatFactory#MAX_INDY_CONCAT_ARG_SLOTS}.\n+     * The non-static arguments are the fragments array and values array.\n+     *\n+     * @param lookup          method lookup from call site\n+     * @param name            method name - not used\n+     * @param type            method type\n+     *                        (String[], Object[]) -> StringTemplate\n+     *\n+     * @return {@link CallSite} to handle create large string template\n+     *\n+     * @throws NullPointerException if any of the arguments is null\n+     * @throws Throwable            if linkage fails\n+     *\/\n+    public static CallSite newLargeStringTemplate(MethodHandles.Lookup lookup,\n+                                                  String name,\n+                                                  MethodType type) throws Throwable {\n+        Objects.requireNonNull(lookup, \"lookup is null\");\n+        Objects.requireNonNull(name, \"name is null\");\n+        Objects.requireNonNull(type, \"type is null\");\n+\n+        return new ConstantCallSite(NEW_TRUSTED_STRING_TEMPLATE.asType(type));\n+    }\n+\n@@ -166,1 +202,1 @@\n-     * @param lookup          method lookup\n+     * @param lookup          method lookup from call site\n@@ -177,0 +213,2 @@\n+     *\n+     * @implNote this method is likely to be revamped before exiting preview.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/TemplateRuntime.java","additions":79,"deletions":41,"binary":false,"changes":120,"status":"modified"}]}