{"files":[{"patch":"@@ -1,336 +1,336 @@\n-\/*\r\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\r\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\r\n- *\r\n- * This code is free software; you can redistribute it and\/or modify it\r\n- * under the terms of the GNU General Public License version 2 only, as\r\n- * published by the Free Software Foundation.  Oracle designates this\r\n- * particular file as subject to the \"Classpath\" exception as provided\r\n- * by Oracle in the LICENSE file that accompanied this code.\r\n- *\r\n- * This code is distributed in the hope that it will be useful, but WITHOUT\r\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\r\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\r\n- * version 2 for more details (a copy is included in the LICENSE file that\r\n- * accompanied this code).\r\n- *\r\n- * You should have received a copy of the GNU General Public License version\r\n- * 2 along with this work; if not, write to the Free Software Foundation,\r\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\r\n- *\r\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\r\n- * or visit www.oracle.com if you need additional information or have any\r\n- * questions.\r\n- *\/\r\n-\r\n-package java.lang.template;\r\n-\r\n-import java.lang.ref.Reference;\r\n-import java.lang.ref.ReferenceQueue;\r\n-import java.lang.ref.SoftReference;\r\n-import java.lang.ref.WeakReference;\r\n-import java.util.AbstractMap;\r\n-import java.util.Collection;\r\n-import java.util.HashMap;\r\n-import java.util.Objects;\r\n-import java.util.Map;\r\n-import java.util.Set;\r\n-import java.util.concurrent.ConcurrentHashMap;\r\n-import java.util.function.Supplier;\r\n-import java.util.stream.Collectors;\r\n-import java.util.stream.Stream;\r\n-\r\n-import jdk.internal.javac.PreviewFeature;\r\n-\r\n-\/**\r\n- * This class provides management of {@link Map maps} where it is desirable to\r\n- * remove entries automatically when the key is garbage collected. This is\r\n- * accomplished by using a backing map where the keys are either a\r\n- * {@link WeakReference} or a {@link SoftReference}.\r\n- * <p>\r\n- * To create a {@link ReferencedKeyMap} the user must provide a {@link Supplier}\r\n- * of the backing map and whether {@link WeakReference} or\r\n- * {@link SoftReference} is to be used.\r\n- *\r\n- * {@snippet :\r\n- * \/\/ Use HashMap and WeakReference\r\n- * Map<Long, String> map = ReferencedKeyMap.create(false, HashMap::new);\r\n- * map.put(10_000_000L, \"a\");\r\n- * map.put(10_000_001L, \"b\");\r\n- * map.put(10_000_002L, \"c\");\r\n- * map.put(10_000_003L, \"d\");\r\n- * map.put(10_000_004L, \"e\");\r\n- *\r\n- * \/\/ Use ConcurrentHashMap and SoftReference\r\n- * map = ReferencedKeyMap.create(true, ConcurrentHashMap::new);\r\n- * map.put(20_000_000L, \"v\");\r\n- * map.put(20_000_001L, \"w\");\r\n- * map.put(20_000_002L, \"x\");\r\n- * map.put(20_000_003L, \"y\");\r\n- * map.put(20_000_004L, \"z\");\r\n- * }\r\n- *\r\n- * @implNote Care must be given that the backing map does replacement by\r\n- * replacing the value in the map entry instead of deleting the old entry and\r\n- * adding a new entry, otherwise replaced entries may end up with a strongly\r\n- * referenced key. {@link HashMap} and {@link ConcurrentHashMap} are known\r\n- * to be safe.\r\n- *\r\n- * @param <K> the type of keys maintained by this map\r\n- * @param <V> the type of mapped values\r\n- *\/\r\n-@PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\r\n-final class ReferencedKeyMap<K, V> implements Map<K, V> {\r\n-    \/**\r\n-     * true if {@link SoftReference} keys are to be used,\r\n-     * {@link WeakReference} otherwise.\r\n-     *\/\r\n-    private final boolean isSoft;\r\n-\r\n-    \/**\r\n-     * Backing {@link Map}.\r\n-     *\/\r\n-    private final Map<ReferenceKey<K>, V> map;\r\n-\r\n-    \/**\r\n-     * {@link ReferenceQueue} for cleaning up {@link ReferenceKey.WeakKey EntryKeys}.\r\n-     *\/\r\n-    private final ReferenceQueue<K> stale;\r\n-\r\n-    \/**\r\n-     * Private constructor.\r\n-     *\r\n-     * @param isSoft  true if {@link SoftReference} keys are to\r\n-     *                be used, {@link WeakReference} otherwise.\r\n-     * @param map     backing map\r\n-     *\/\r\n-    private ReferencedKeyMap(boolean isSoft, Map<ReferenceKey<K>, V> map) {\r\n-        this.isSoft = isSoft;\r\n-        this.map = map;\r\n-        this.stale = new ReferenceQueue<>();\r\n-    }\r\n-\r\n-    \/**\r\n-     * Create a new {@link ReferencedKeyMap} map.\r\n-     *\r\n-     * @param isSoft    true if {@link SoftReference} keys are to\r\n-     *                  be used, {@link WeakReference} otherwise.\r\n-     * @param supplier  {@link Supplier} of the backing map\r\n-     *\r\n-     * @return a new map with {@link Reference} keys\r\n-     *\r\n-     * @param <K> the type of keys maintained by the new map\r\n-     * @param <V> the type of mapped values\r\n-     *\/\r\n-    @SuppressWarnings(\"unchecked\")\r\n-    static <K, V> ReferencedKeyMap<K, V>\r\n-    create(boolean isSoft, Supplier<Map<?, ?>> supplier) {\r\n-        return new ReferencedKeyMap<K, V>(isSoft,\r\n-                (Map<ReferenceKey<K>, V>)supplier.get());\r\n-    }\r\n-\r\n-    \/**\r\n-     * Create a new {@link ReferencedKeyMap} map using\r\n-     * {@link WeakReference} keys.\r\n-     *\r\n-     * @param supplier  {@link Supplier} of the backing map\r\n-     *\r\n-     * @return a new map with {@link Reference} keys\r\n-     *\r\n-     * @param <K> the type of keys maintained by the new map\r\n-     * @param <V> the type of mapped values\r\n-     *\/\r\n-    @SuppressWarnings(\"unchecked\")\r\n-    static <K, V> ReferencedKeyMap<K, V>\r\n-    create(Supplier<Map<?, ?>> supplier) {\r\n-        return new ReferencedKeyMap<K, V>(false,\r\n-                (Map<ReferenceKey<K>, V>)supplier.get());\r\n-    }\r\n-\r\n-    \/**\r\n-     * {@return a key suitable for a map entry}\r\n-     *\r\n-     * @param key unwrapped key\r\n-     *\/\r\n-    @SuppressWarnings(\"unchecked\")\r\n-    private ReferenceKey<K> entryKey(Object key) {\r\n-        if (isSoft) {\r\n-            return new ReferenceKey.SoftKey<>((K)key, stale);\r\n-        } else {\r\n-            return new ReferenceKey.WeakKey<>((K)key, stale);\r\n-        }\r\n-    }\r\n-\r\n-    \/**\r\n-     * {@return a key suitable for lookup}\r\n-     *\r\n-     * @param key unwrapped key\r\n-     *\/\r\n-    @SuppressWarnings(\"unchecked\")\r\n-    private ReferenceKey<K> lookupKey(Object key) {\r\n-        return new ReferenceKey.StrongKey<>((K)key);\r\n-    }\r\n-\r\n-    @Override\r\n-    public int size() {\r\n-        removeStaleReferences();\r\n-        return map.size();\r\n-    }\r\n-\r\n-    @Override\r\n-    public boolean isEmpty() {\r\n-        removeStaleReferences();\r\n-        return map.isEmpty();\r\n-    }\r\n-\r\n-    @Override\r\n-    public boolean containsKey(Object key) {\r\n-        Objects.requireNonNull(key, \"key must not be null\");\r\n-        removeStaleReferences();\r\n-        return map.containsKey(lookupKey(key));\r\n-    }\r\n-\r\n-    @Override\r\n-    public boolean containsValue(Object value) {\r\n-        Objects.requireNonNull(value, \"value must not be null\");\r\n-        removeStaleReferences();\r\n-        return map.containsValue(value);\r\n-    }\r\n-\r\n-    @Override\r\n-    public V get(Object key) {\r\n-        Objects.requireNonNull(key, \"key must not be null\");\r\n-        removeStaleReferences();\r\n-        return map.get(lookupKey(key));\r\n-    }\r\n-\r\n-    @Override\r\n-    public V put(K key, V newValue) {\r\n-        Objects.requireNonNull(key, \"key must not be null\");\r\n-        Objects.requireNonNull(newValue, \"value must not be null\");\r\n-        removeStaleReferences();\r\n-        ReferenceKey<K> entryKey = entryKey(key);\r\n-        \/\/ If {@code put} returns non-null then was actually a {@code replace}\r\n-        \/\/ and older key was used. In that case the new key was not used and the\r\n-        \/\/ reference marked stale.\r\n-        V oldValue = map.put(entryKey, newValue);\r\n-        if (oldValue != null) {\r\n-            entryKey.unused();\r\n-        }\r\n-        return oldValue;\r\n-    }\r\n-\r\n-    @Override\r\n-    public V remove(Object key) {\r\n-        \/\/ Rely on gc to clean up old key.\r\n-        return map.remove(lookupKey(key));\r\n-    }\r\n-\r\n-    @Override\r\n-    public void putAll(Map<? extends K, ? extends V> m) {\r\n-        removeStaleReferences();\r\n-        for (Entry<? extends K, ? extends V> entry : m.entrySet()) {\r\n-            K key = entry.getKey();\r\n-            V value = entry.getValue();\r\n-            put(key, value);\r\n-        }\r\n-    }\r\n-\r\n-    @Override\r\n-    public void clear() {\r\n-        removeStaleReferences();\r\n-        \/\/ Rely on gc to clean up old keys.\r\n-        map.clear();\r\n-    }\r\n-\r\n-    \/**\r\n-     * Common routine for collecting the current set of keys.\r\n-     *\r\n-     * @return {@link Stream} of valid keys (unwrapped)\r\n-     *\/\r\n-    private Stream<K> filterKeySet() {\r\n-        return map.keySet()\r\n-                .stream()\r\n-                .map(ReferenceKey::get)\r\n-                .filter(Objects::nonNull);\r\n-    }\r\n-\r\n-    @Override\r\n-    public Set<K> keySet() {\r\n-        removeStaleReferences();\r\n-        return filterKeySet().collect(Collectors.toSet());\r\n-    }\r\n-\r\n-    @Override\r\n-    public Collection<V> values() {\r\n-        removeStaleReferences();\r\n-        return map.values();\r\n-    }\r\n-\r\n-    @Override\r\n-    public Set<Entry<K, V>> entrySet() {\r\n-        removeStaleReferences();\r\n-        return filterKeySet()\r\n-                .map(k -> new AbstractMap.SimpleEntry<>(k, get(k)))\r\n-                .collect(Collectors.toSet());\r\n-    }\r\n-\r\n-    @Override\r\n-    public V putIfAbsent(K key, V newValue) {\r\n-        removeStaleReferences();\r\n-        ReferenceKey<K> entryKey = entryKey(key);\r\n-        \/\/ If {@code putIfAbsent} returns non-null then was actually a\r\n-        \/\/ {@code replace}  and older key was used. In that case the new key was\r\n-        \/\/ not used and the reference marked stale.\r\n-        V oldValue = map.putIfAbsent(entryKey, newValue);\r\n-        if (oldValue != null) {\r\n-            entryKey.unused();\r\n-        }\r\n-        return oldValue;\r\n-    }\r\n-\r\n-    @Override\r\n-    public boolean remove(Object key, Object value) {\r\n-        \/\/ Rely on gc to clean up old key.\r\n-        return map.remove(lookupKey(key), value);\r\n-    }\r\n-\r\n-    @Override\r\n-    public boolean replace(K key, V oldValue, V newValue) {\r\n-        removeStaleReferences();\r\n-        \/\/ If replace is successful then the older key will be used and the\r\n-        \/\/ lookup key will suffice.\r\n-        return map.replace(lookupKey(key), oldValue, newValue);\r\n-    }\r\n-\r\n-    @Override\r\n-    public V replace(K key, V value) {\r\n-        removeStaleReferences();\r\n-        \/\/ If replace is successful then the older key will be used and the\r\n-        \/\/ lookup key will suffice.\r\n-        return map.replace(lookupKey(key), value);\r\n-    }\r\n-\r\n-    @Override\r\n-    public String toString() {\r\n-        removeStaleReferences();\r\n-        return filterKeySet()\r\n-                .map(k -> k + \"=\" + get(k))\r\n-                .collect(Collectors.joining(\", \", \"{\", \"}\"));\r\n-    }\r\n-\r\n-    \/**\r\n-     * Removes enqueued weak references from map.\r\n-     *\/\r\n-    @SuppressWarnings(\"unchecked\")\r\n-    public void removeStaleReferences() {\r\n-        while (true) {\r\n-            ReferenceKey.WeakKey<K> key = (ReferenceKey.WeakKey<K>)stale.poll();\r\n-            if (key == null) {\r\n-                break;\r\n-            }\r\n-            map.remove(key);\r\n-        }\r\n-    }\r\n-\r\n-}\r\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.template;\n+\n+import java.lang.ref.Reference;\n+import java.lang.ref.ReferenceQueue;\n+import java.lang.ref.SoftReference;\n+import java.lang.ref.WeakReference;\n+import java.util.AbstractMap;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Objects;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import jdk.internal.javac.PreviewFeature;\n+\n+\/**\n+ * This class provides management of {@link Map maps} where it is desirable to\n+ * remove entries automatically when the key is garbage collected. This is\n+ * accomplished by using a backing map where the keys are either a\n+ * {@link WeakReference} or a {@link SoftReference}.\n+ * <p>\n+ * To create a {@link ReferencedKeyMap} the user must provide a {@link Supplier}\n+ * of the backing map and whether {@link WeakReference} or\n+ * {@link SoftReference} is to be used.\n+ *\n+ * {@snippet :\n+ * \/\/ Use HashMap and WeakReference\n+ * Map<Long, String> map = ReferencedKeyMap.create(false, HashMap::new);\n+ * map.put(10_000_000L, \"a\");\n+ * map.put(10_000_001L, \"b\");\n+ * map.put(10_000_002L, \"c\");\n+ * map.put(10_000_003L, \"d\");\n+ * map.put(10_000_004L, \"e\");\n+ *\n+ * \/\/ Use ConcurrentHashMap and SoftReference\n+ * map = ReferencedKeyMap.create(true, ConcurrentHashMap::new);\n+ * map.put(20_000_000L, \"v\");\n+ * map.put(20_000_001L, \"w\");\n+ * map.put(20_000_002L, \"x\");\n+ * map.put(20_000_003L, \"y\");\n+ * map.put(20_000_004L, \"z\");\n+ * }\n+ *\n+ * @implNote Care must be given that the backing map does replacement by\n+ * replacing the value in the map entry instead of deleting the old entry and\n+ * adding a new entry, otherwise replaced entries may end up with a strongly\n+ * referenced key. {@link HashMap} and {@link ConcurrentHashMap} are known\n+ * to be safe.\n+ *\n+ * @param <K> the type of keys maintained by this map\n+ * @param <V> the type of mapped values\n+ *\/\n+@PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n+final class ReferencedKeyMap<K, V> implements Map<K, V> {\n+    \/**\n+     * true if {@link SoftReference} keys are to be used,\n+     * {@link WeakReference} otherwise.\n+     *\/\n+    private final boolean isSoft;\n+\n+    \/**\n+     * Backing {@link Map}.\n+     *\/\n+    private final Map<ReferenceKey<K>, V> map;\n+\n+    \/**\n+     * {@link ReferenceQueue} for cleaning up {@link ReferenceKey.WeakKey EntryKeys}.\n+     *\/\n+    private final ReferenceQueue<K> stale;\n+\n+    \/**\n+     * Private constructor.\n+     *\n+     * @param isSoft  true if {@link SoftReference} keys are to\n+     *                be used, {@link WeakReference} otherwise.\n+     * @param map     backing map\n+     *\/\n+    private ReferencedKeyMap(boolean isSoft, Map<ReferenceKey<K>, V> map) {\n+        this.isSoft = isSoft;\n+        this.map = map;\n+        this.stale = new ReferenceQueue<>();\n+    }\n+\n+    \/**\n+     * Create a new {@link ReferencedKeyMap} map.\n+     *\n+     * @param isSoft    true if {@link SoftReference} keys are to\n+     *                  be used, {@link WeakReference} otherwise.\n+     * @param supplier  {@link Supplier} of the backing map\n+     *\n+     * @return a new map with {@link Reference} keys\n+     *\n+     * @param <K> the type of keys maintained by the new map\n+     * @param <V> the type of mapped values\n+     *\/\n+    @SuppressWarnings(\"unchecked\")\n+    static <K, V> ReferencedKeyMap<K, V>\n+    create(boolean isSoft, Supplier<Map<?, ?>> supplier) {\n+        return new ReferencedKeyMap<K, V>(isSoft,\n+                (Map<ReferenceKey<K>, V>)supplier.get());\n+    }\n+\n+    \/**\n+     * Create a new {@link ReferencedKeyMap} map using\n+     * {@link WeakReference} keys.\n+     *\n+     * @param supplier  {@link Supplier} of the backing map\n+     *\n+     * @return a new map with {@link Reference} keys\n+     *\n+     * @param <K> the type of keys maintained by the new map\n+     * @param <V> the type of mapped values\n+     *\/\n+    @SuppressWarnings(\"unchecked\")\n+    static <K, V> ReferencedKeyMap<K, V>\n+    create(Supplier<Map<?, ?>> supplier) {\n+        return new ReferencedKeyMap<K, V>(false,\n+                (Map<ReferenceKey<K>, V>)supplier.get());\n+    }\n+\n+    \/**\n+     * {@return a key suitable for a map entry}\n+     *\n+     * @param key unwrapped key\n+     *\/\n+    @SuppressWarnings(\"unchecked\")\n+    private ReferenceKey<K> entryKey(Object key) {\n+        if (isSoft) {\n+            return new ReferenceKey.SoftKey<>((K)key, stale);\n+        } else {\n+            return new ReferenceKey.WeakKey<>((K)key, stale);\n+        }\n+    }\n+\n+    \/**\n+     * {@return a key suitable for lookup}\n+     *\n+     * @param key unwrapped key\n+     *\/\n+    @SuppressWarnings(\"unchecked\")\n+    private ReferenceKey<K> lookupKey(Object key) {\n+        return new ReferenceKey.StrongKey<>((K)key);\n+    }\n+\n+    @Override\n+    public int size() {\n+        removeStaleReferences();\n+        return map.size();\n+    }\n+\n+    @Override\n+    public boolean isEmpty() {\n+        removeStaleReferences();\n+        return map.isEmpty();\n+    }\n+\n+    @Override\n+    public boolean containsKey(Object key) {\n+        Objects.requireNonNull(key, \"key must not be null\");\n+        removeStaleReferences();\n+        return map.containsKey(lookupKey(key));\n+    }\n+\n+    @Override\n+    public boolean containsValue(Object value) {\n+        Objects.requireNonNull(value, \"value must not be null\");\n+        removeStaleReferences();\n+        return map.containsValue(value);\n+    }\n+\n+    @Override\n+    public V get(Object key) {\n+        Objects.requireNonNull(key, \"key must not be null\");\n+        removeStaleReferences();\n+        return map.get(lookupKey(key));\n+    }\n+\n+    @Override\n+    public V put(K key, V newValue) {\n+        Objects.requireNonNull(key, \"key must not be null\");\n+        Objects.requireNonNull(newValue, \"value must not be null\");\n+        removeStaleReferences();\n+        ReferenceKey<K> entryKey = entryKey(key);\n+        \/\/ If {@code put} returns non-null then was actually a {@code replace}\n+        \/\/ and older key was used. In that case the new key was not used and the\n+        \/\/ reference marked stale.\n+        V oldValue = map.put(entryKey, newValue);\n+        if (oldValue != null) {\n+            entryKey.unused();\n+        }\n+        return oldValue;\n+    }\n+\n+    @Override\n+    public V remove(Object key) {\n+        \/\/ Rely on gc to clean up old key.\n+        return map.remove(lookupKey(key));\n+    }\n+\n+    @Override\n+    public void putAll(Map<? extends K, ? extends V> m) {\n+        removeStaleReferences();\n+        for (Entry<? extends K, ? extends V> entry : m.entrySet()) {\n+            K key = entry.getKey();\n+            V value = entry.getValue();\n+            put(key, value);\n+        }\n+    }\n+\n+    @Override\n+    public void clear() {\n+        removeStaleReferences();\n+        \/\/ Rely on gc to clean up old keys.\n+        map.clear();\n+    }\n+\n+    \/**\n+     * Common routine for collecting the current set of keys.\n+     *\n+     * @return {@link Stream} of valid keys (unwrapped)\n+     *\/\n+    private Stream<K> filterKeySet() {\n+        return map.keySet()\n+                .stream()\n+                .map(ReferenceKey::get)\n+                .filter(Objects::nonNull);\n+    }\n+\n+    @Override\n+    public Set<K> keySet() {\n+        removeStaleReferences();\n+        return filterKeySet().collect(Collectors.toSet());\n+    }\n+\n+    @Override\n+    public Collection<V> values() {\n+        removeStaleReferences();\n+        return map.values();\n+    }\n+\n+    @Override\n+    public Set<Entry<K, V>> entrySet() {\n+        removeStaleReferences();\n+        return filterKeySet()\n+                .map(k -> new AbstractMap.SimpleEntry<>(k, get(k)))\n+                .collect(Collectors.toSet());\n+    }\n+\n+    @Override\n+    public V putIfAbsent(K key, V newValue) {\n+        removeStaleReferences();\n+        ReferenceKey<K> entryKey = entryKey(key);\n+        \/\/ If {@code putIfAbsent} returns non-null then was actually a\n+        \/\/ {@code replace}  and older key was used. In that case the new key was\n+        \/\/ not used and the reference marked stale.\n+        V oldValue = map.putIfAbsent(entryKey, newValue);\n+        if (oldValue != null) {\n+            entryKey.unused();\n+        }\n+        return oldValue;\n+    }\n+\n+    @Override\n+    public boolean remove(Object key, Object value) {\n+        \/\/ Rely on gc to clean up old key.\n+        return map.remove(lookupKey(key), value);\n+    }\n+\n+    @Override\n+    public boolean replace(K key, V oldValue, V newValue) {\n+        removeStaleReferences();\n+        \/\/ If replace is successful then the older key will be used and the\n+        \/\/ lookup key will suffice.\n+        return map.replace(lookupKey(key), oldValue, newValue);\n+    }\n+\n+    @Override\n+    public V replace(K key, V value) {\n+        removeStaleReferences();\n+        \/\/ If replace is successful then the older key will be used and the\n+        \/\/ lookup key will suffice.\n+        return map.replace(lookupKey(key), value);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        removeStaleReferences();\n+        return filterKeySet()\n+                .map(k -> k + \"=\" + get(k))\n+                .collect(Collectors.joining(\", \", \"{\", \"}\"));\n+    }\n+\n+    \/**\n+     * Removes enqueued weak references from map.\n+     *\/\n+    @SuppressWarnings(\"unchecked\")\n+    public void removeStaleReferences() {\n+        while (true) {\n+            ReferenceKey.WeakKey<K> key = (ReferenceKey.WeakKey<K>)stale.poll();\n+            if (key == null) {\n+                break;\n+            }\n+            map.remove(key);\n+        }\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/template\/ReferencedKeyMap.java","additions":336,"deletions":336,"binary":false,"changes":672,"status":"modified"}]}