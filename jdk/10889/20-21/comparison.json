{"files":[{"patch":"@@ -115,1 +115,1 @@\n-    public static CallSite stringTemplateBSM(\n+    public static CallSite newLargeStringTemplate(\n@@ -140,1 +140,1 @@\n-    public static CallSite stringTemplateBSM(\n+    public static CallSite newStringTemplate(\n@@ -171,1 +171,1 @@\n-    public static CallSite stringTemplateBSM(\n+    public static CallSite processStringTemplate(\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/TemplateRuntime.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n- * This interface simplifies declaration of\n+ * This interface simplifies the declaration of\n","filename":"src\/java.base\/share\/classes\/java\/lang\/template\/StringProcessor.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,4 +28,0 @@\n-import java.lang.invoke.MethodHandle;\n-import java.util.stream.Collectors;\n-import java.util.ArrayList;\n-import java.util.Collections;\n@@ -38,2 +34,2 @@\n- * The Java compiler produces implementations of {@link StringTemplate} to\n- * represent string templates and text block templates. Libraries may produce\n+ * {@link StringTemplate StringTemplates} are runtime representations of\n+ * Java string templates and text block templates. Libraries may produce\n@@ -49,1 +45,1 @@\n- * contains the string of characters preceeding each of the embedded expressions\n+ * contains the string of characters preceding each of the embedded expressions\n@@ -73,1 +69,1 @@\n- * {@link StringTemplate StringTemplates} are primarily used in conjuction\n+ * {@link StringTemplate StringTemplates} are primarily used in conjunction\n@@ -106,1 +102,1 @@\n- * @implSpec An instance of {@link StringTemplate} is immutatble. Also, the\n+ * @implSpec An instance of {@link StringTemplate} is immutable. Also, the\n@@ -119,4 +115,6 @@\n-     * Returns an immutable list of string fragments consisting of the string\n-     * of characters preceeding each of the embedded expressions plus the\n-     * string of characters following the last embedded expression. In the\n-     * example: {@snippet :\n+     * Returns this {@link StringTemplate StringTemplate's} immutable list of string\n+     * fragments consisting of the string of characters preceding each of the embedded\n+     * expressions plus the string of characters following the last embedded expression.\n+     * In the example: {@snippet :\n+     * String student = \"Mary\";\n+     * String teacher = \"Johnson\";\n@@ -136,1 +134,2 @@\n-     * Returns an immutable list of embedded expression results. In the example:\n+     * Returns this {@link StringTemplate StringTemplate's} immutable list of embedded\n+     * expression results. In the example:\n@@ -138,1 +137,3 @@\n-     * StringTemplate st = RAW.\"\\{x} + \\{y} = \\{x + y}\";\n+     * String student = \"Mary\";\n+     * String teacher = \"Johnson\";\n+     * StringTemplate st = RAW.\"The student \\{student} is in \\{teacher}'s class room.\";\n@@ -141,1 +142,1 @@\n-     * <code>values<\/code> will be equivalent to <code>List.of(x, y, x + y)<\/code>\n+     * <code>values<\/code> will be equivalent to <code>List.of(student, teacher)<\/code>\n@@ -150,1 +151,10 @@\n-     * {@return the interpolation of the StringTemplate}\n+     * Returns the interpolation of this {@link StringTemplate StringTemplate's}.\n+     * fragments and values.\n+     *\n+     * {@snippet :\n+     * String student = \"Mary\";\n+     * String teacher = \"Johnson\";\n+     * StringTemplate st = RAW.\"The student \\{student} is in \\{teacher}'s class room.\";\n+     * String string = st.interpolation(); \/\/ @highlight substring=\"interpolation()\"\n+     * }\n+     * <code>string<\/code> will be equivalent to <code>\"The student Mary is in Johnson's class room.\"<\/code>\n@@ -152,2 +162,1 @@\n-     * @implNote Compiler generated {@link StringTemplate StringTemplates} create a specialized\n-     * optimal version of interpolate for each string template expression.\n+     * @return interpolation of this {@link StringTemplate}\n@@ -163,2 +172,4 @@\n-     * String result1 = STR.\"\\{x} + \\{y} = \\{x + y}\";\n-     * String result2 = RAW.\"\\{x} + \\{y} = \\{x + y}\".process(STR); \/\/ @highlight substring=\"process\"\n+     * String student = \"Mary\";\n+     * String teacher = \"Johnson\";\n+     * String result1 = STR.\"The student \\{student} is in \\{teacher}'s class room.\";\n+     * String result2 = RAW.\"The student \\{student} is in \\{teacher}'s class room.\".process(STR); \/\/ @highlight substring=\"process\"\n@@ -173,1 +184,1 @@\n-     * @return constructed object of type R\n+     * @return constructed object of type <code>R<\/code>\n@@ -178,1 +189,1 @@\n-     * @implNote The default implementation simply invokes the processor's process\n+     * @implNote The default implementation invokes the processor's process\n@@ -198,1 +209,1 @@\n-    public static String toString(StringTemplate stringTemplate) {\n+    static String toString(StringTemplate stringTemplate) {\n@@ -208,1 +219,2 @@\n-     * Returns a StringTemplate composed from a string.\n+     * Returns a StringTemplate as if constructed by invoking\n+     * <code>StringTemplate.of(List.of(string), List.of())<\/code>.\n@@ -216,1 +228,1 @@\n-    public static StringTemplate of(String string) {\n+    static StringTemplate of(String string) {\n@@ -222,1 +234,1 @@\n-     * Returns a StringTemplate composed from fragments and values.\n+     * Returns a StringTemplate with the given fragments and values.\n@@ -238,1 +250,1 @@\n-    public static StringTemplate of(List<String> fragments, List<?> values) {\n+    static StringTemplate of(List<String> fragments, List<?> values) {\n@@ -261,1 +273,1 @@\n-    public static String interpolate(List<String> fragments, List<?> values) {\n+    static String interpolate(List<String> fragments, List<?> values) {\n@@ -273,14 +285,17 @@\n-      * Combine one or more {@link StringTemplate StringTemplates} to produce a combined {@link StringTemplate}.\n-      * {@snippet :\n-      * StringTemplate st = StringTemplate.combine(RAW.\"\\{a}\", RAW.\"\\{b}\", RAW.\"\\{c}\");\n-      * assert st.interpolate().equals(RAW.\"\\{a}\\{b}\\{c}\");\n-      * }\n-      *\n-      * @param sts  one or more {@link StringTemplate}\n-      *\n-      * @return combined {@link StringTemplate}\n-      *\n-      * @throws NullPointerException if sts is null or if any of the elements are null\n-      * @throws RuntimeException if sts has zero elements\n-      *\/\n-    public static StringTemplate combine(StringTemplate... sts) {\n+     * Combine one or more {@link StringTemplate StringTemplates} into a single {@link StringTemplate}.\n+     * {@snippet :\n+     * StringTemplate st = StringTemplate.combine(RAW.\"\\{a}\", RAW.\"\\{b}\", RAW.\"\\{c}\");\n+     * assert st.interpolate().equals(RAW.\"\\{a}\\{b}\\{c}\");\n+     * }\n+     * Fragment lists from each {@link StringTemplate} are merged such that the last fragment\n+     * from the previous {@link StringTemplate} is concatenated with the first fragment of the next\n+     * {@link StringTemplate}. Values lists are simply concatenated to produce a single values list.\n+     *\n+     * @param sts  one or more {@link StringTemplate}\n+     *\n+     * @return combined {@link StringTemplate}\n+     *\n+     * @throws NullPointerException if sts is null or if any of the elements are null\n+     * @throws RuntimeException if sts has zero elements\n+     *\/\n+    static StringTemplate combine(StringTemplate... sts) {\n@@ -299,1 +314,1 @@\n-    public static final StringProcessor STR = StringTemplate::interpolate;\n+    static final StringProcessor STR = StringTemplate::interpolate;\n@@ -311,1 +326,1 @@\n-    public static final TemplateProcessor<StringTemplate> RAW = st -> st;\n+    static final TemplateProcessor<StringTemplate> RAW = st -> st;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/template\/StringTemplate.java","additions":60,"deletions":45,"binary":false,"changes":105,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n-import jdk.internal.access.JavaUtilCollectionAccess;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/template\/StringTemplateImplFactory.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n- * This interface simplifies declaration of\n+ * This interface simplifies the declaration of\n","filename":"src\/java.base\/share\/classes\/java\/lang\/template\/TemplateProcessor.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,10 +28,0 @@\n-import java.lang.invoke.CallSite;\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.MethodType;\n-import java.lang.reflect.Array;\n-import java.lang.reflect.Field;\n-import java.lang.reflect.Modifier;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Iterator;\n@@ -42,1 +32,0 @@\n-import jdk.internal.access.JavaLangInvokeAccess;\n@@ -44,1 +33,0 @@\n-import jdk.internal.access.JavaUtilCollectionAccess;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/template\/TemplateSupport.java","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -28,5 +28,0 @@\n-import java.util.Objects;\n-import java.util.concurrent.ExecutionException;\n-import java.util.concurrent.Future;\n-import java.util.concurrent.FutureTask;\n-import java.util.function.BiFunction;\n@@ -34,1 +29,0 @@\n-import java.util.function.Supplier;\n@@ -85,2 +79,3 @@\n- * user will construct a new string from the template string, with placeholders\n- * replaced by stringified objects from the values list.\n+ * user will construct a new string from the string template, with placeholders\n+ * replaced by string representations of value list elements. These string\n+ * representations are created as if invoking {@link String#valueOf}.\n@@ -126,1 +121,1 @@\n- * that just need to work with the interpolation;\n+ * that just need to work with the string interpolation;\n@@ -130,1 +125,1 @@\n- * or simply transform the interpolation into something other than\n+ * or simply transform the string interpolation into something other than\n","filename":"src\/java.base\/share\/classes\/java\/lang\/template\/ValidatingProcessor.java","additions":5,"deletions":10,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -28,1 +28,3 @@\n-import java.lang.invoke.*;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n@@ -30,2 +32,7 @@\n-import java.lang.template.*;\n-import java.util.*;\n+import java.lang.template.ProcessorLinkage;\n+import java.lang.template.StringProcessor;\n+import java.lang.template.StringTemplate;\n+import java.lang.template.ValidatingProcessor;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Objects;\n@@ -38,3 +45,3 @@\n- * This {@linkplain ValidatingProcessor template processor} constructs a String\n- * result using {@link Formatter}. Unlike {@link Formatter}, FormatProcessor uses the value from\n- * the embedded expression that follows immediately after the\n+ * This {@linkplain ValidatingProcessor template processor} constructs a {@link String}\n+ * result using {@link Formatter}. Unlike {@link Formatter}, {@link FormatProcessor} uses\n+ * the value from the embedded expression that follows immediately after the\n@@ -42,1 +49,1 @@\n- * StringTemplate expressions without a preceeding specifier, use \"%s\" by\n+ * StringTemplate expressions without a preceding specifier, use \"%s\" by\n@@ -51,4 +58,4 @@\n- * @implNote When used in conjunction with a compiler generated {@link\n- * StringTemplate} this {@link ValidatingProcessor} will use the format\n- * specifiers in the fragments and types of the values in the value list\n- * to produce a more performant formatter.\n+ * @implNote When used in conjunction with a runtime instances of {@link\n+ * StringTemplate} representing string templates this {@link StringProcessor}\n+ * will use the format specifiers in the fragments and types of the values in\n+ * the value list to produce a more performant formatter.\n@@ -56,1 +63,1 @@\n- * @implSpec Since, values are found with in the string template, argument indexing\n+ * @implSpec Since, values are found within the string template, argument indexing\n","filename":"src\/java.base\/share\/classes\/java\/util\/FormatProcessor.java","additions":19,"deletions":12,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -4149,1 +4149,1 @@\n-                        Errors.RawTemplateProcessorType(processorType.tsym));\n+                        Errors.TemplateProcessorTypeCannotBeARawType(processorType.tsym));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import com.sun.tools.javac.code.Preview;\n@@ -40,1 +39,0 @@\n-import com.sun.tools.javac.jvm.Target;\n@@ -54,4 +52,0 @@\n-import static com.sun.tools.javac.code.Flags.*;\n-import static com.sun.tools.javac.code.Scope.LookupKind.NON_RECURSIVE;\n-import static com.sun.tools.javac.tree.JCTree.Tag.*;\n-\n@@ -82,1 +76,0 @@\n-    private final Attr attr;\n@@ -85,1 +78,0 @@\n-    private final Check chk;\n@@ -88,2 +80,0 @@\n-    private final Target target;\n-    private final Preview preview;\n@@ -98,1 +88,0 @@\n-        attr = Attr.instance(context);\n@@ -102,1 +91,0 @@\n-        chk = Check.instance(context);\n@@ -105,2 +93,0 @@\n-        target = Target.instance(context);\n-        preview = Preview.instance(context);\n@@ -125,4 +111,0 @@\n-    Type makeListType(Type elemType) {\n-         return new ClassType(syms.listType.getEnclosingType(), List.of(elemType), syms.listType.tsym);\n-    }\n-\n@@ -136,51 +118,0 @@\n-    JCVariableDecl makeField(JCClassDecl cls, long flags, Name name, Type type, JCExpression init) {\n-        VarSymbol sym = new VarSymbol(flags | FINAL | SYNTHETIC, name, type, cls.sym);\n-        JCVariableDecl var = make.VarDef(sym, init);\n-        cls.defs = cls.defs.append(var);\n-        cls.sym.members().enter(var.sym);\n-\n-        return var;\n-    }\n-\n-    MethodType makeMethodType(Type returnType, List<Type> argTypes) {\n-        return new MethodType(argTypes, returnType, List.nil(), syms.methodClass);\n-    }\n-\n-    JCFieldAccess makeThisFieldSelect(Type owner, JCVariableDecl field) {\n-        JCFieldAccess select = make.Select(make.This(owner), field.name);\n-        select.type = field.type;\n-        select.sym = field.sym;\n-        return select;\n-    }\n-\n-    JCIdent makeParamIdent(List<JCVariableDecl> params, Name name) {\n-        VarSymbol param = params.stream()\n-                .filter(p -> p.name == name)\n-                .findFirst()\n-                .get().sym;\n-        JCIdent ident = make.Ident(name);\n-        ident.type = param.type;\n-        ident.sym = param;\n-        return ident;\n-    }\n-\n-    JCFieldAccess makeSelect(Symbol sym, Name name) {\n-        return make.Select(make.QualIdent(sym), name);\n-    }\n-\n-    JCMethodInvocation makeApply(JCFieldAccess method, List<JCExpression> args) {\n-        return make.Apply(List.nil(), method, args);\n-    }\n-\n-    Symbol findMember(ClassSymbol classSym, Name name) {\n-        return classSym.members().getSymbolsByName(name, NON_RECURSIVE).iterator().next();\n-    }\n-\n-    JCFieldAccess makeFieldAccess(JCClassDecl owner, Name name) {\n-        Symbol sym = findMember(owner.sym, name);\n-        JCFieldAccess access = makeSelect(owner.sym, name);\n-        access.type = sym.type;\n-        access.sym = sym;\n-        return access;\n-    }\n-\n@@ -213,7 +144,0 @@\n-    record MethodInfo(MethodType type, MethodSymbol sym, JCMethodDecl decl) {\n-        void addStatement(JCStatement statement) {\n-            JCBlock body = decl.body;\n-            body.stats = body.stats.append(statement);\n-        }\n-    }\n-\n@@ -221,11 +145,6 @@\n-        JCStringTemplate tree;\n-        JCExpression processor;\n-        List<String> fragments;\n-        List<JCExpression> expressions;\n-        List<Type> expressionTypes;\n-        boolean useValuesList;\n-        JCClassDecl stringTemplateClass;\n-        JCVariableDecl fragmentsVar;\n-        JCVariableDecl valuesVar;\n-        List<JCVariableDecl> fields;\n-        MethodInfo interpolateMethod;\n+        final JCStringTemplate tree;\n+        final JCExpression processor;\n+        final List<String> fragments;\n+        final List<JCExpression> expressions;\n+        final List<Type> expressionTypes;\n+        final boolean useValuesList;\n@@ -245,6 +164,1 @@\n-            this.stringTemplateClass = null;\n-            this.fragmentsVar = null;\n-            this.valuesVar = null;\n-            this.fields = List.nil();\n-            this.interpolateMethod = null;\n-        }\n+         }\n@@ -257,1 +171,1 @@\n-                        : makeBinary(PLUS, expr, makeString(fragment));\n+                        : makeBinary(Tag.PLUS, expr, makeString(fragment));\n@@ -261,1 +175,1 @@\n-                    expr = makeBinary(PLUS, expr, expression.setType(expressionType));\n+                    expr = makeBinary(Tag.PLUS, expr, expression.setType(expressionType));\n@@ -309,1 +223,0 @@\n-\n@@ -313,1 +226,1 @@\n-                return bsmCall(names.process, names.stringTemplateBSM, syms.stringTemplateType,\n+                return bsmCall(names.process, names.newLargeStringTemplate, syms.stringTemplateType,\n@@ -318,1 +231,0 @@\n-                VarSymbol processorSym = (VarSymbol)TreeInfo.symbol(processor);\n@@ -323,1 +235,1 @@\n-                return bsmCall(names.process, names.stringTemplateBSM, syms.stringTemplateType,\n+                return bsmCall(names.process, names.newStringTemplate, syms.stringTemplateType,\n@@ -331,1 +243,0 @@\n-\n@@ -341,1 +252,1 @@\n-            return bsmCall(names.process, names.stringTemplateBSM, tree.type,\n+            return bsmCall(names.process, names.processStringTemplate, tree.type,\n@@ -347,1 +258,1 @@\n-                if (varSym.flags() == (PUBLIC | FINAL | STATIC) &&\n+                if (varSym.flags() == (Flags.PUBLIC | Flags.FINAL | Flags.STATIC) &&\n@@ -370,1 +281,1 @@\n-            if (processor == null || isNamedProcessor(names.raw)) {\n+            if (processor == null || isNamedProcessor(names.RAW)) {\n@@ -372,1 +283,1 @@\n-            } else if (isNamedProcessor(names.str)) {\n+            } else if (isNamedProcessor(names.STR)) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TransLiterals.java","additions":15,"deletions":104,"binary":false,"changes":119,"status":"modified"},{"patch":"@@ -1300,2 +1300,2 @@\n-compiler.err.raw.template.processor.type=\\\n-    raw template processor type: {0}\n+compiler.err.template.processor.type.cannot.be.a.raw.type=\\\n+    template processor type cannot be a raw type: {0}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -227,3 +227,5 @@\n-    public final Name str;\n-    public final Name raw;\n-    public final Name stringTemplateBSM;\n+    public final Name STR;\n+    public final Name RAW;\n+    public final Name newStringTemplate;\n+    public final Name newLargeStringTemplate;\n+    public final Name processStringTemplate;\n@@ -406,3 +408,5 @@\n-        str = fromString(\"STR\");\n-        raw = fromString(\"RAW\");\n-        stringTemplateBSM = fromString(\"stringTemplateBSM\");\n+        STR = fromString(\"STR\");\n+        RAW = fromString(\"RAW\");\n+        newStringTemplate = fromString(\"newStringTemplate\");\n+        newLargeStringTemplate = fromString(\"newLargeStringTemplate\");\n+        processStringTemplate = fromString(\"processStringTemplate\");\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/Names.java","additions":10,"deletions":6,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n- \/\/ key: compiler.err.raw.template.processor.type\n+ \/\/ key: compiler.err.template.processor.type.cannot.be.a.raw.type\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/StringTemplateRawProcessor.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}