{"files":[{"patch":"@@ -30,1 +30,1 @@\n- * @bug 8235638 8235739\n+ * @bug 8235638 8235739 8285094\n@@ -47,0 +47,5 @@\n+        \/*\n+         * This test needs to give the desktop time to recover to avoid\n+         * destabilising other tests.\n+         *\/\n+        Thread.sleep(10000);\n","filename":"test\/jdk\/java\/awt\/Frame\/GetGraphicsStressTest\/GetGraphicsStressTest.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n-  @bug 7154177\n+  @bug 7154177 8285094\n@@ -29,3 +29,0 @@\n-  @author anthony.petrov@oracle.com: area=awt.toplevel\n-  @library ..\/..\/regtesthelpers\n-  @build Util\n@@ -35,4 +32,10 @@\n-import java.awt.*;\n-import java.awt.event.*;\n-import java.util.*;\n-import test.java.awt.regtesthelpers.Util;\n+import java.awt.Color;\n+import java.awt.EventQueue;\n+import java.awt.Frame;\n+import java.awt.Rectangle;\n+import java.awt.Robot;\n+import java.awt.Toolkit;\n+import java.awt.Window;\n+import java.awt.event.InputEvent;\n+import java.awt.event.MouseAdapter;\n+import java.awt.event.MouseEvent;\n@@ -41,0 +44,1 @@\n+\n@@ -44,1 +48,9 @@\n-    private static final int F_X = 40, F_Y = 40, F_W = 200, F_H = 200;\n+    private static final int F_X = 200, F_Y = 200, F_W = 200, F_H = 200;\n+    private static final int H_X = F_X - 10, H_Y = F_Y - 10, H_W = F_W + 20, H_H = F_H + 20;\n+    private static final int C_X = F_X + F_W \/ 2, C_Y = F_Y + F_H \/ 2;\n+    static final Color helperFrameBgColor = Color.blue;\n+    static final Color invisibleFrameBgColor = Color.green;\n+    static Frame invisibleFrame;\n+    static Frame helperFrame;\n+    static Window ownedWindow;\n+    static Robot robot;\n@@ -46,5 +58,11 @@\n-    public static void main(String[] args) throws AWTException {\n-        \/\/ A background frame to compare a pixel color against\n-        Frame helperFrame = new Frame(\"Background frame\");\n-        helperFrame.setBackground(Color.BLUE);\n-        helperFrame.setBounds(F_X - 10, F_Y - 10, F_W + 20, F_H + 20);\n+    static void createUI() {\n+        \/* A background frame to compare a pixel color against\n+         * It should be centered in the same location as the invisible\n+         * frame but extend beyond its bounds.\n+         *\/\n+        helperFrame = new Frame(\"Background frame\");\n+        helperFrame.setBackground(helperFrameBgColor);\n+        helperFrame.setLocation(H_X, H_Y);\n+        helperFrame.setSize(H_W, H_H);\n+        System.out.println(\"Helper requested bounds : x=\" +\n+                           H_X + \" y=\"+ H_Y +\" w=\"+ H_W +\" h=\"+ H_H);\n@@ -54,1 +72,2 @@\n-                backgroundClicked= true;\n+                System.out.println(\"Background helper frame clicked\");\n+                backgroundClicked = true;\n@@ -59,6 +78,8 @@\n-        \/\/ An owner frame that should stay invisible\n-        Frame frame = new Frame(\"Invisible Frame\");\n-        frame.setBackground(Color.GREEN);\n-        frame.setLocation(F_X, F_Y);\n-        frame.setSize(F_W, F_H);\n-        frame.addMouseListener(new MouseAdapter() {\n+        \/* An owner frame that should stay invisible but theoretical\n+         * bounds are within the helper frame.\n+         *\/\n+        invisibleFrame = new Frame(\"Invisible Frame\");\n+        invisibleFrame.setBackground(invisibleFrameBgColor);\n+        invisibleFrame.setLocation(F_X, F_Y);\n+        invisibleFrame.setSize(F_W, F_H);\n+        invisibleFrame.addMouseListener(new MouseAdapter() {\n@@ -67,0 +88,1 @@\n+                System.out.println(\"Invisible owner clicked\");\n@@ -71,7 +93,9 @@\n-        \/\/ An owned window\n-        final Window window = new Window(frame);\n-        window.setBackground(Color.RED);\n-        window.setSize(200, 200);\n-        window.setLocation(300, 300);\n-        window.setVisible(true);\n-        try { Thread.sleep(1000); } catch (Exception ex) {}\n+        \/* An owned window of the invisible frame that is located\n+         * such that it does not overlap either the helper or\n+         * the invisisible frame.\n+         *\/\n+        ownedWindow = new Window(invisibleFrame);\n+        ownedWindow.setBackground(Color.RED);\n+        ownedWindow.setLocation(H_X+H_W+100, H_Y+H_W+100);\n+        ownedWindow.setSize(100, 100);\n+        ownedWindow.setVisible(true);\n@@ -79,1 +103,2 @@\n-        Robot robot = new Robot();\n+        Toolkit.getDefaultToolkit().sync();\n+    }\n@@ -81,3 +106,6 @@\n-        \/\/ Clicking the owned window shouldn't make its owner visible\n-        Util.clickOnComp(window, robot);\n-        try { Thread.sleep(500); } catch (Exception ex) {}\n+    static void captureScreen() throws Exception {\n+        System.out.println(\"Writing screen capture\");\n+        Rectangle screenRect = helperFrame.getGraphicsConfiguration().getBounds();\n+        java.awt.image.BufferedImage bi = robot.createScreenCapture(screenRect);\n+        javax.imageio.ImageIO.write(bi, \"png\", new java.io.File(\"screen_IO.png\"));\n+    }\n@@ -85,0 +113,1 @@\n+    public static void main(String[] args) throws Exception {\n@@ -86,3 +115,6 @@\n-        \/\/ Assume the location and size are applied to the frame as expected.\n-        \/\/ This should work fine on the Mac. We can't call getLocationOnScreen()\n-        \/\/ since from Java perspective the frame is invisible anyway.\n+        try {\n+            EventQueue.invokeAndWait(() -> createUI());\n+            robot = new Robot();\n+            robot.waitForIdle();\n+            robot.setAutoDelay(100);\n+            robot.setAutoWaitForIdle(true);\n@@ -90,12 +122,6 @@\n-        \/\/ 1. Check the color at the center of the owner frame\n-        Color c = robot.getPixelColor(F_X + F_W \/ 2, F_Y + F_H \/ 2);\n-        System.err.println(\"Pixel color: \" + c);\n-        if (c == null) {\n-            throw new RuntimeException(\"Robot.getPixelColor() failed\");\n-        }\n-        if (c.equals(frame.getBackground())) {\n-            throw new RuntimeException(\"The invisible frame has become visible\");\n-        }\n-        if (!c.equals(helperFrame.getBackground())) {\n-            throw new RuntimeException(\"The background helper frame has been covered by something unexpected\");\n-        }\n+            Rectangle helperBounds = helperFrame.getBounds();\n+            System.out.println(\"helperFrame bounds = \" + helperBounds);\n+            if (!helperBounds.contains(C_X, C_Y)) {\n+                System.out.println(\"Helper not positioned where it needs to be\");\n+                return;\n+            }\n@@ -103,5 +129,7 @@\n-        \/\/ 2. Try to click it\n-        robot.mouseMove(F_X + F_W \/ 2, F_Y + F_H \/ 2);\n-        robot.mousePress(InputEvent.BUTTON1_MASK);\n-        robot.mouseRelease(InputEvent.BUTTON1_MASK);\n-        try { Thread.sleep(500); } catch (Exception ex) {}\n+            \/\/ Clicking the owned window shouldn't make its owner visible\n+            Rectangle ownedWindowBounds = ownedWindow.getBounds();\n+            robot.mouseMove(ownedWindowBounds.x + ownedWindowBounds.width \/ 2,\n+                            ownedWindowBounds.y + ownedWindowBounds.height \/ 2);\n+            robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+            robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+            robot.delay(1000);\n@@ -109,4 +137,17 @@\n-        \/\/ Cleanup\n-        window.dispose();\n-        frame.dispose();\n-        helperFrame.dispose();\n+            \/\/ 1. Check the color at the center of the invisible & helper frame location\n+            Color c = robot.getPixelColor(C_X, C_Y);\n+            System.out.println(\"Sampled pixel at \" + C_X +\",\" + C_Y);\n+            System.out.println(\"Pixel color: \" + c);\n+            if (c == null) {\n+                captureScreen();\n+                throw new RuntimeException(\"Robot.getPixelColor() failed\");\n+            }\n+            if (c.equals(invisibleFrameBgColor)) {\n+                captureScreen();\n+                throw new RuntimeException(\"The invisible frame has become visible\");\n+            }\n+            if (!c.equals(helperFrameBgColor)) {\n+                captureScreen();\n+                throw new RuntimeException(\n+                    \"Background frame was covered by something unexpected\");\n+            }\n@@ -114,6 +155,23 @@\n-        \/\/ Final checks\n-        if (invisibleOwnerClicked) {\n-            throw new RuntimeException(\"An invisible owner frame got clicked. Looks like it became visible.\");\n-        }\n-        if (!backgroundClicked) {\n-            throw new RuntimeException(\"The background helper frame hasn't been clciked\");\n+            \/\/ 2. Try to click it - event should be delivered to the\n+            \/\/ helper frame, not the invisible frame.\n+            robot.mouseMove(C_X, C_Y);\n+            robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+            robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+            robot.delay(1000);\n+\n+            if (invisibleOwnerClicked) {\n+                captureScreen();\n+                throw new RuntimeException(\n+                    \"The invisible owner frame got clicked. Looks like it became visible.\");\n+            }\n+            if (!backgroundClicked) {\n+                captureScreen();\n+                throw new RuntimeException(\n+                    \"The background helper frame hasn't been clicked\");\n+            }\n+        } finally {\n+            EventQueue.invokeAndWait(() -> {\n+                if (ownedWindow != null) ownedWindow.dispose();\n+                if (invisibleFrame != null) invisibleFrame.dispose();\n+                if (helperFrame != null) helperFrame.dispose();\n+            });\n@@ -121,0 +179,1 @@\n+\n","filename":"test\/jdk\/java\/awt\/Frame\/InvisibleOwner\/InvisibleOwner.java","additions":122,"deletions":63,"binary":false,"changes":185,"status":"modified"}]}