{"files":[{"patch":"@@ -33,0 +33,1 @@\n+import sun.security.jca.GetInstance;\n@@ -179,1 +180,2 @@\n-    throws NoSuchAlgorithmException {\n+        throws NoSuchAlgorithmException\n+    {\n@@ -181,21 +183,10 @@\n-        try {\n-            MessageDigest md;\n-            Object[] objs = Security.getImpl(algorithm, \"MessageDigest\",\n-                                             (String)null);\n-            if (objs[0] instanceof MessageDigest) {\n-                md = (MessageDigest)objs[0];\n-                md.provider = (Provider)objs[1];\n-            } else {\n-                md = Delegate.of((MessageDigestSpi)objs[0], algorithm,\n-                    (Provider) objs[1]);\n-            }\n-\n-            if (!skipDebug && pdebug != null) {\n-                pdebug.println(\"MessageDigest.\" + algorithm +\n-                    \" algorithm from: \" + md.provider.getName());\n-            }\n-\n-            return md;\n-\n-        } catch(NoSuchProviderException e) {\n-            throw new NoSuchAlgorithmException(algorithm + \" not found\");\n+        MessageDigest md;\n+\n+        GetInstance.Instance instance = GetInstance.getInstance(\"MessageDigest\",\n+                MessageDigestSpi.class, algorithm);\n+        if (instance.impl instanceof MessageDigest messageDigest) {\n+            md = messageDigest;\n+            md.provider = instance.provider;\n+        } else {\n+            md = Delegate.of((MessageDigestSpi)instance.impl, algorithm,\n+                instance.provider);\n@@ -203,0 +194,7 @@\n+\n+        if (!skipDebug && pdebug != null) {\n+            pdebug.println(\"MessageDigest.\" + algorithm +\n+                \" algorithm from: \" + md.provider.getName());\n+        }\n+\n+        return md;\n","filename":"src\/java.base\/share\/classes\/java\/security\/MessageDigest.java","additions":20,"deletions":22,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -150,38 +150,1 @@\n-    private static Object newInstanceUtil(final Class<?> clazz,\n-        final Class<?> ctrParamClz, final Object ctorParamObj)\n-        throws Exception {\n-        if (ctrParamClz == null) {\n-            Constructor<?> con = clazz.getConstructor();\n-            return con.newInstance();\n-        } else {\n-            \/\/ Looking for the constructor with a params first and fallback\n-            \/\/ to one without if not found. This is to support the enhanced\n-            \/\/ SecureRandom where both styles of constructors are supported.\n-            \/\/ Before jdk9, there was no params support (only getInstance(alg))\n-            \/\/ and an impl only had the params-less constructor. Since jdk9,\n-            \/\/ there is getInstance(alg,params) and an impl can contain\n-            \/\/ an Impl(params) constructor.\n-            try {\n-                Constructor<?> con = clazz.getConstructor(ctrParamClz);\n-                return con.newInstance(ctorParamObj);\n-            } catch (NoSuchMethodException nsme) {\n-                \/\/ For pre-jdk9 SecureRandom implementations, they only\n-                \/\/ have params-less constructors which still works when\n-                \/\/ the input ctorParamObj is null.\n-                \/\/\n-                \/\/ For other primitives using params, ctorParamObj should not\n-                \/\/ be null and nsme is thrown, just like before.\n-                if (ctorParamObj == null) {\n-                    try {\n-                        Constructor<?> con = clazz.getConstructor();\n-                        return con.newInstance();\n-                    } catch (NoSuchMethodException nsme2) {\n-                        nsme.addSuppressed(nsme2);\n-                        throw nsme;\n-                    }\n-                } else {\n-                    throw nsme;\n-                }\n-            }\n-        }\n-    }\n+    private static final Object[] EMPTY = new Object[0];\n@@ -1109,1 +1072,1 @@\n-            return Objects.hash(type, algorithm);\n+            return type.hashCode() ^ algorithm.hashCode();\n@@ -1115,1 +1078,1 @@\n-            if (!(obj instanceof ServiceKey)) {\n+            if (!(obj instanceof ServiceKey other)) {\n@@ -1118,1 +1081,0 @@\n-            ServiceKey other = (ServiceKey)obj;\n@@ -1195,3 +1157,1 @@\n-                s = new Service(this);\n-                s.type = type;\n-                s.algorithm = stdAlg;\n+                s = new Service(this, type, stdAlg);\n@@ -1216,3 +1176,1 @@\n-                    s = new Service(this);\n-                    s.type = type;\n-                    s.algorithm = stdAlg;\n+                    s = new Service(this, type, stdAlg);\n@@ -1241,3 +1199,1 @@\n-                    s = new Service(this);\n-                    s.type = type;\n-                    s.algorithm = stdAlg;\n+                    s = new Service(this, type, stdAlg);\n@@ -1676,2 +1632,3 @@\n-\n-        private String type, algorithm, className;\n+        private final String type;\n+        private final String algorithm;\n+        private String className;\n@@ -1681,0 +1638,7 @@\n+        private final EngineDescription engineDescription;\n+\n+        \/\/ Reference to the cached implementation Class object.\n+        \/\/ Will be a Class if this service is loaded from the built-in\n+        \/\/ classloader (unloading not possible), otherwise a WeakReference to a\n+        \/\/ Class\n+        private Object classCache;\n@@ -1682,2 +1646,4 @@\n-        \/\/ Reference to the cached implementation Class object\n-        private volatile Reference<Class<?>> classRef;\n+        \/\/ Will be a Constructor if this service is loaded from the built-in\n+        \/\/ classloader (unloading not possible), otherwise a WeakReference to\n+        \/\/ a Constructor\n+        private Object constructorCache;\n@@ -1705,1 +1671,1 @@\n-        private Service(Provider provider) {\n+        private Service(Provider provider, String type, String algorithm) {\n@@ -1707,0 +1673,3 @@\n+            this.type = type;\n+            this.algorithm = algorithm;\n+            engineDescription = knownEngines.get(type);\n@@ -1752,0 +1721,1 @@\n+            engineDescription = knownEngines.get(type);\n@@ -1866,1 +1836,1 @@\n-                EngineDescription cap = knownEngines.get(type);\n+                EngineDescription cap = engineDescription;\n@@ -1893,1 +1863,1 @@\n-                return newInstanceUtil(getImplClass(), ctrParamClz, constructorParameter);\n+                return newInstanceUtil(ctrParamClz, constructorParameter);\n@@ -1909,0 +1879,42 @@\n+        private Object newInstanceOf() throws Exception {\n+            Constructor<?> con = getDefaultConstructor();\n+            return con.newInstance(EMPTY);\n+        }\n+\n+        private Object newInstanceUtil(Class<?> ctrParamClz, Object ctorParamObj)\n+                throws Exception\n+        {\n+            if (ctrParamClz == null) {\n+                return newInstanceOf();\n+            } else {\n+                \/\/ Looking for the constructor with a params first and fallback\n+                \/\/ to one without if not found. This is to support the enhanced\n+                \/\/ SecureRandom where both styles of constructors are supported.\n+                \/\/ Before jdk9, there was no params support (only getInstance(alg))\n+                \/\/ and an impl only had the params-less constructor. Since jdk9,\n+                \/\/ there is getInstance(alg,params) and an impl can contain\n+                \/\/ an Impl(params) constructor.\n+                try {\n+                    Constructor<?> con = getImplClass().getConstructor(ctrParamClz);\n+                    return con.newInstance(ctorParamObj);\n+                } catch (NoSuchMethodException nsme) {\n+                    \/\/ For pre-jdk9 SecureRandom implementations, they only\n+                    \/\/ have params-less constructors which still works when\n+                    \/\/ the input ctorParamObj is null.\n+                    \/\/\n+                    \/\/ For other primitives using params, ctorParamObj should not\n+                    \/\/ be null and nsme is thrown, just like before.\n+                    if (ctorParamObj == null) {\n+                        try {\n+                            return newInstanceOf();\n+                        } catch (NoSuchMethodException nsme2) {\n+                            nsme.addSuppressed(nsme2);\n+                            throw nsme;\n+                        }\n+                    } else {\n+                        throw nsme;\n+                    }\n+                }\n+            }\n+        }\n+\n@@ -1912,2 +1924,8 @@\n-                Reference<Class<?>> ref = classRef;\n-                Class<?> clazz = (ref == null) ? null : ref.get();\n+                Object cache = classCache;\n+                if (cache instanceof Class<?> clazz) {\n+                    return clazz;\n+                }\n+                Class<?> clazz = null;\n+                if (cache instanceof WeakReference<?> ref){\n+                    clazz = (ref == null) ? null : (Class<?>)ref.get();\n+                }\n@@ -1926,1 +1944,1 @@\n-                    classRef = new WeakReference<>(clazz);\n+                    classCache = (cl == null) ? clazz : new WeakReference<Class<?>>(clazz);\n@@ -1936,0 +1954,20 @@\n+        private Constructor<?> getDefaultConstructor()\n+            throws NoSuchAlgorithmException, NoSuchMethodException\n+        {\n+            Object cache = constructorCache;\n+            if (cache instanceof Constructor<?> con) {\n+                return con;\n+            }\n+            Constructor<?> con = null;\n+            if (cache instanceof WeakReference<?> ref){\n+                con = (ref == null) ? null : (Constructor<?>)ref.get();\n+            }\n+            if (con == null) {\n+                Class<?> clazz = getImplClass();\n+                con = clazz.getConstructor();\n+                constructorCache = (clazz.getClassLoader() == null)\n+                        ? con : new WeakReference<Constructor<?>>(con);\n+            }\n+            return con;\n+        }\n+\n@@ -1963,1 +2001,1 @@\n-            EngineDescription cap = knownEngines.get(type);\n+            EngineDescription cap = engineDescription;\n","filename":"src\/java.base\/share\/classes\/java\/security\/Provider.java","additions":99,"deletions":61,"binary":false,"changes":160,"status":"modified"},{"patch":"@@ -163,1 +163,1 @@\n-    synchronized Provider getProvider() {\n+    Provider getProvider() {\n@@ -169,3 +169,9 @@\n-        if (shouldLoad() == false) {\n-            return null;\n-        }\n+        \/\/ DCL\n+        synchronized (ProviderConfig.class) {\n+            p = provider;\n+            if (p != null) {\n+                return p;\n+            }\n+            if (shouldLoad() == false) {\n+                return null;\n+            }\n@@ -173,20 +179,27 @@\n-        \/\/ Create providers which are in java.base directly\n-        if (provName.equals(\"SUN\") || provName.equals(\"sun.security.provider.Sun\")) {\n-            p = new sun.security.provider.Sun();\n-        } else if (provName.equals(\"SunRsaSign\") || provName.equals(\"sun.security.rsa.SunRsaSign\")) {\n-            p = new sun.security.rsa.SunRsaSign();\n-        } else if (provName.equals(\"SunJCE\") || provName.equals(\"com.sun.crypto.provider.SunJCE\")) {\n-            p = new com.sun.crypto.provider.SunJCE();\n-        } else if (provName.equals(\"SunJSSE\")) {\n-            p = new sun.security.ssl.SunJSSE();\n-        } else if (provName.equals(\"Apple\") || provName.equals(\"apple.security.AppleProvider\")) {\n-            \/\/ need to use reflection since this class only exists on MacOsx\n-            p = AccessController.doPrivileged(new PrivilegedAction<Provider>() {\n-                public Provider run() {\n-                    try {\n-                        Class<?> c = Class.forName(\"apple.security.AppleProvider\");\n-                        if (Provider.class.isAssignableFrom(c)) {\n-                            @SuppressWarnings(\"deprecation\")\n-                            Object tmp = c.newInstance();\n-                            return (Provider) tmp;\n-                        } else {\n+            \/\/ Create providers which are in java.base directly\n+            if (provName.equals(\"SUN\") || provName.equals(\"sun.security.provider.Sun\")) {\n+                p = new sun.security.provider.Sun();\n+            } else if (provName.equals(\"SunRsaSign\") || provName.equals(\"sun.security.rsa.SunRsaSign\")) {\n+                p = new sun.security.rsa.SunRsaSign();\n+            } else if (provName.equals(\"SunJCE\") || provName.equals(\"com.sun.crypto.provider.SunJCE\")) {\n+                p = new com.sun.crypto.provider.SunJCE();\n+            } else if (provName.equals(\"SunJSSE\")) {\n+                p = new sun.security.ssl.SunJSSE();\n+            } else if (provName.equals(\"Apple\") || provName.equals(\"apple.security.AppleProvider\")) {\n+                \/\/ need to use reflection since this class only exists on MacOsx\n+                p = AccessController.doPrivileged(new PrivilegedAction<Provider>() {\n+                    public Provider run() {\n+                        try {\n+                            Class<?> c = Class.forName(\"apple.security.AppleProvider\");\n+                            if (Provider.class.isAssignableFrom(c)) {\n+                                @SuppressWarnings(\"deprecation\")\n+                                Object tmp = c.newInstance();\n+                                return (Provider) tmp;\n+                            } else {\n+                                return null;\n+                            }\n+                        } catch (Exception ex) {\n+                            if (debug != null) {\n+                                debug.println(\"Error loading provider Apple\");\n+                                ex.printStackTrace();\n+                            }\n@@ -195,4 +208,9 @@\n-                    } catch (Exception ex) {\n-                        if (debug != null) {\n-                        debug.println(\"Error loading provider Apple\");\n-                        ex.printStackTrace();\n+                    }\n+                });\n+            } else {\n+                if (isLoading) {\n+                    \/\/ because this method is synchronized, this can only\n+                    \/\/ happen if there is recursion.\n+                    if (debug != null) {\n+                        debug.println(\"Recursion loading provider: \" + this);\n+                        new Exception(\"Call trace\").printStackTrace();\n@@ -202,9 +220,6 @@\n-             }\n-             });\n-        } else {\n-            if (isLoading) {\n-                \/\/ because this method is synchronized, this can only\n-                \/\/ happen if there is recursion.\n-                if (debug != null) {\n-                    debug.println(\"Recursion loading provider: \" + this);\n-                    new Exception(\"Call trace\").printStackTrace();\n+                try {\n+                    isLoading = true;\n+                    tries++;\n+                    p = doLoadProvider();\n+                } finally {\n+                    isLoading = false;\n@@ -212,8 +227,0 @@\n-                return null;\n-            }\n-            try {\n-                isLoading = true;\n-                tries++;\n-                p = doLoadProvider();\n-            } finally {\n-                isLoading = false;\n@@ -221,0 +228,1 @@\n+            provider = p;\n@@ -222,1 +230,0 @@\n-        provider = p;\n","filename":"src\/java.base\/share\/classes\/sun\/security\/jca\/ProviderConfig.java","additions":53,"deletions":46,"binary":false,"changes":99,"status":"modified"},{"patch":"@@ -0,0 +1,78 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.security;\n+\n+import java.security.DigestException;\n+import java.security.MessageDigest;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.NoSuchProviderException;\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+\/**\n+ * Micros for speed of looking up and instantiating MessageDigests.\n+ *\/\n+@State(Scope.Thread)\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 10, time = 1)\n+@Fork(value = 3)\n+public class GetMessageDigest {\n+\n+    @Param({\"md5\", \"SHA-1\", \"SHA-256\"})\n+    private String digesterName;\n+\n+    private MessageDigest messageDigest;\n+\n+    @Setup\n+    public void setupMessageDigestForCloning() throws NoSuchAlgorithmException {\n+        messageDigest = MessageDigest.getInstance(digesterName);\n+    }\n+\n+    @Benchmark\n+    public MessageDigest getInstance() throws NoSuchAlgorithmException {\n+        return MessageDigest.getInstance(digesterName);\n+    }\n+\n+    @Benchmark\n+    public MessageDigest cloneInstance() throws NoSuchAlgorithmException, CloneNotSupportedException {\n+        return (MessageDigest)messageDigest.clone();\n+    }\n+\n+    @Benchmark\n+    public MessageDigest getInstanceWithProvider() throws NoSuchAlgorithmException, NoSuchProviderException {\n+        return MessageDigest.getInstance(digesterName, \"SUN\");\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/security\/GetMessageDigest.java","additions":78,"deletions":0,"binary":false,"changes":78,"status":"added"}]}