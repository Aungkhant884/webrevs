{"files":[{"patch":"@@ -33,0 +33,1 @@\n+import sun.security.jca.GetInstance;\n@@ -179,1 +180,2 @@\n-    throws NoSuchAlgorithmException {\n+        throws NoSuchAlgorithmException\n+    {\n@@ -181,21 +183,10 @@\n-        try {\n-            MessageDigest md;\n-            Object[] objs = Security.getImpl(algorithm, \"MessageDigest\",\n-                                             (String)null);\n-            if (objs[0] instanceof MessageDigest) {\n-                md = (MessageDigest)objs[0];\n-                md.provider = (Provider)objs[1];\n-            } else {\n-                md = Delegate.of((MessageDigestSpi)objs[0], algorithm,\n-                    (Provider) objs[1]);\n-            }\n-\n-            if (!skipDebug && pdebug != null) {\n-                pdebug.println(\"MessageDigest.\" + algorithm +\n-                    \" algorithm from: \" + md.provider.getName());\n-            }\n-\n-            return md;\n-\n-        } catch(NoSuchProviderException e) {\n-            throw new NoSuchAlgorithmException(algorithm + \" not found\");\n+        MessageDigest md;\n+\n+        GetInstance.Instance instance = GetInstance.getInstance(\"MessageDigest\",\n+                MessageDigestSpi.class, algorithm);\n+        if (instance.impl instanceof MessageDigest messageDigest) {\n+            md = messageDigest;\n+            md.provider = instance.provider;\n+        } else {\n+            md = Delegate.of((MessageDigestSpi)instance.impl, algorithm,\n+                instance.provider);\n@@ -203,0 +194,7 @@\n+\n+        if (!skipDebug && pdebug != null) {\n+            pdebug.println(\"MessageDigest.\" + algorithm +\n+                \" algorithm from: \" + md.provider.getName());\n+        }\n+\n+        return md;\n","filename":"src\/java.base\/share\/classes\/java\/security\/MessageDigest.java","additions":20,"deletions":22,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -150,15 +150,0 @@\n-    \/\/ Cache default constructors used by newInstanceUtil. This ensures proper\n-    \/\/ reuse of the Constructor objects (which are thread-safe and safe to share\n-    \/\/ as long as they're not passed to external code). This avoids copying and\n-    \/\/ access checking.\n-    private static final ClassValue<Constructor<?>> DEFAULT_CONSTRUCTORS =\n-            new ClassValue<>() {\n-                @Override\n-                protected Constructor<?> computeValue(Class<?> clazz) {\n-                    try {\n-                        return clazz.getConstructor();\n-                    } catch (NoSuchMethodException e) {\n-                        throw new RuntimeException(e);\n-                    }\n-                }\n-            };\n@@ -167,48 +152,0 @@\n-    private static Object newInstanceOf(Class<?> clazz) throws Exception {\n-        try {\n-            return DEFAULT_CONSTRUCTORS.get(clazz).newInstance(EMPTY);\n-        } catch (RuntimeException re) {\n-            if (re.getCause() instanceof NoSuchMethodException nsme) {\n-                throw nsme;\n-            }\n-            throw re;\n-        }\n-    }\n-\n-    private static Object newInstanceUtil(final Class<?> clazz,\n-        final Class<?> ctrParamClz, final Object ctorParamObj)\n-        throws Exception {\n-        if (ctrParamClz == null) {\n-            return newInstanceOf(clazz);\n-        } else {\n-            \/\/ Looking for the constructor with a params first and fallback\n-            \/\/ to one without if not found. This is to support the enhanced\n-            \/\/ SecureRandom where both styles of constructors are supported.\n-            \/\/ Before jdk9, there was no params support (only getInstance(alg))\n-            \/\/ and an impl only had the params-less constructor. Since jdk9,\n-            \/\/ there is getInstance(alg,params) and an impl can contain\n-            \/\/ an Impl(params) constructor.\n-            try {\n-                Constructor<?> con = clazz.getConstructor(ctrParamClz);\n-                return con.newInstance(ctorParamObj);\n-            } catch (NoSuchMethodException nsme) {\n-                \/\/ For pre-jdk9 SecureRandom implementations, they only\n-                \/\/ have params-less constructors which still works when\n-                \/\/ the input ctorParamObj is null.\n-                \/\/\n-                \/\/ For other primitives using params, ctorParamObj should not\n-                \/\/ be null and nsme is thrown, just like before.\n-                if (ctorParamObj == null) {\n-                    try {\n-                        return newInstanceOf(clazz);\n-                    } catch (NoSuchMethodException nsme2) {\n-                        nsme.addSuppressed(nsme2);\n-                        throw nsme;\n-                    }\n-                } else {\n-                    throw nsme;\n-                }\n-            }\n-        }\n-    }\n-\n@@ -1135,1 +1072,1 @@\n-            return Objects.hash(type, algorithm);\n+            return type.hashCode() ^ algorithm.hashCode();\n@@ -1141,1 +1078,1 @@\n-            if (!(obj instanceof ServiceKey)) {\n+            if (!(obj instanceof ServiceKey other)) {\n@@ -1144,1 +1081,0 @@\n-            ServiceKey other = (ServiceKey)obj;\n@@ -1221,3 +1157,1 @@\n-                s = new Service(this);\n-                s.type = type;\n-                s.algorithm = stdAlg;\n+                s = new Service(this, type, stdAlg);\n@@ -1242,3 +1176,1 @@\n-                    s = new Service(this);\n-                    s.type = type;\n-                    s.algorithm = stdAlg;\n+                    s = new Service(this, type, stdAlg);\n@@ -1267,3 +1199,1 @@\n-                    s = new Service(this);\n-                    s.type = type;\n-                    s.algorithm = stdAlg;\n+                    s = new Service(this, type, stdAlg);\n@@ -1702,2 +1632,3 @@\n-\n-        private String type, algorithm, className;\n+        private final String type;\n+        private final String algorithm;\n+        private String className;\n@@ -1707,0 +1638,7 @@\n+        private final EngineDescription engineDescription;\n+\n+        \/\/ Reference to the cached implementation Class object.\n+        \/\/ Will be a Class if this service is loaded from the built-in\n+        \/\/ classloader (unloading not possible), otherwise a WeakReference to a\n+        \/\/ Class\n+        private Object classCache;\n@@ -1708,2 +1646,4 @@\n-        \/\/ Reference to the cached implementation Class object\n-        private volatile Reference<Class<?>> classRef;\n+        \/\/ Will be a Constructor if this service is loaded from the built-in\n+        \/\/ classloader (unloading not possible), otherwise a WeakReference to\n+        \/\/ a Constructor\n+        private Object constructorCache;\n@@ -1731,1 +1671,1 @@\n-        private Service(Provider provider) {\n+        private Service(Provider provider, String type, String algorithm) {\n@@ -1733,0 +1673,3 @@\n+            this.type = type;\n+            this.algorithm = algorithm;\n+            engineDescription = knownEngines.get(type);\n@@ -1778,0 +1721,1 @@\n+            engineDescription = knownEngines.get(type);\n@@ -1892,1 +1836,1 @@\n-                EngineDescription cap = knownEngines.get(type);\n+                EngineDescription cap = engineDescription;\n@@ -1919,1 +1863,1 @@\n-                return newInstanceUtil(getImplClass(), ctrParamClz, constructorParameter);\n+                return newInstanceUtil(ctrParamClz, constructorParameter);\n@@ -1935,0 +1879,42 @@\n+        private Object newInstanceOf() throws Exception {\n+            Constructor<?> con = getDefaultConstructor();\n+            return con.newInstance(EMPTY);\n+        }\n+\n+        private Object newInstanceUtil(Class<?> ctrParamClz, Object ctorParamObj)\n+                throws Exception\n+        {\n+            if (ctrParamClz == null) {\n+                return newInstanceOf();\n+            } else {\n+                \/\/ Looking for the constructor with a params first and fallback\n+                \/\/ to one without if not found. This is to support the enhanced\n+                \/\/ SecureRandom where both styles of constructors are supported.\n+                \/\/ Before jdk9, there was no params support (only getInstance(alg))\n+                \/\/ and an impl only had the params-less constructor. Since jdk9,\n+                \/\/ there is getInstance(alg,params) and an impl can contain\n+                \/\/ an Impl(params) constructor.\n+                try {\n+                    Constructor<?> con = getImplClass().getConstructor(ctrParamClz);\n+                    return con.newInstance(ctorParamObj);\n+                } catch (NoSuchMethodException nsme) {\n+                    \/\/ For pre-jdk9 SecureRandom implementations, they only\n+                    \/\/ have params-less constructors which still works when\n+                    \/\/ the input ctorParamObj is null.\n+                    \/\/\n+                    \/\/ For other primitives using params, ctorParamObj should not\n+                    \/\/ be null and nsme is thrown, just like before.\n+                    if (ctorParamObj == null) {\n+                        try {\n+                            return newInstanceOf();\n+                        } catch (NoSuchMethodException nsme2) {\n+                            nsme.addSuppressed(nsme2);\n+                            throw nsme;\n+                        }\n+                    } else {\n+                        throw nsme;\n+                    }\n+                }\n+            }\n+        }\n+\n@@ -1938,2 +1924,8 @@\n-                Reference<Class<?>> ref = classRef;\n-                Class<?> clazz = (ref == null) ? null : ref.get();\n+                Object cache = classCache;\n+                if (cache instanceof Class<?> clazz) {\n+                    return clazz;\n+                }\n+                Class<?> clazz = null;\n+                if (cache instanceof WeakReference<?> ref){\n+                    clazz = (ref == null) ? null : (Class<?>)ref.get();\n+                }\n@@ -1952,1 +1944,1 @@\n-                    classRef = new WeakReference<>(clazz);\n+                    classCache = (cl == null) ? clazz : new WeakReference<Class<?>>(clazz);\n@@ -1962,0 +1954,20 @@\n+        private Constructor<?> getDefaultConstructor()\n+            throws NoSuchAlgorithmException, NoSuchMethodException\n+        {\n+            Object cache = constructorCache;\n+            if (cache instanceof Constructor<?> con) {\n+                return con;\n+            }\n+            Constructor<?> con = null;\n+            if (cache instanceof WeakReference<?> ref){\n+                con = (ref == null) ? null : (Constructor<?>)ref.get();\n+            }\n+            if (con == null) {\n+                Class<?> clazz = getImplClass();\n+                con = clazz.getConstructor();\n+                constructorCache = (clazz.getClassLoader() == null)\n+                        ? con : new WeakReference<Constructor<?>>(con);\n+            }\n+            return con;\n+        }\n+\n@@ -1989,1 +2001,1 @@\n-            EngineDescription cap = knownEngines.get(type);\n+            EngineDescription cap = engineDescription;\n","filename":"src\/java.base\/share\/classes\/java\/security\/Provider.java","additions":98,"deletions":86,"binary":false,"changes":184,"status":"modified"},{"patch":"@@ -163,1 +163,1 @@\n-    synchronized Provider getProvider() {\n+    Provider getProvider() {\n@@ -169,3 +169,9 @@\n-        if (shouldLoad() == false) {\n-            return null;\n-        }\n+        \/\/ DCL\n+        synchronized (ProviderConfig.class) {\n+            p = provider;\n+            if (p != null) {\n+                return p;\n+            }\n+            if (shouldLoad() == false) {\n+                return null;\n+            }\n@@ -173,20 +179,27 @@\n-        \/\/ Create providers which are in java.base directly\n-        if (provName.equals(\"SUN\") || provName.equals(\"sun.security.provider.Sun\")) {\n-            p = new sun.security.provider.Sun();\n-        } else if (provName.equals(\"SunRsaSign\") || provName.equals(\"sun.security.rsa.SunRsaSign\")) {\n-            p = new sun.security.rsa.SunRsaSign();\n-        } else if (provName.equals(\"SunJCE\") || provName.equals(\"com.sun.crypto.provider.SunJCE\")) {\n-            p = new com.sun.crypto.provider.SunJCE();\n-        } else if (provName.equals(\"SunJSSE\")) {\n-            p = new sun.security.ssl.SunJSSE();\n-        } else if (provName.equals(\"Apple\") || provName.equals(\"apple.security.AppleProvider\")) {\n-            \/\/ need to use reflection since this class only exists on MacOsx\n-            p = AccessController.doPrivileged(new PrivilegedAction<Provider>() {\n-                public Provider run() {\n-                    try {\n-                        Class<?> c = Class.forName(\"apple.security.AppleProvider\");\n-                        if (Provider.class.isAssignableFrom(c)) {\n-                            @SuppressWarnings(\"deprecation\")\n-                            Object tmp = c.newInstance();\n-                            return (Provider) tmp;\n-                        } else {\n+            \/\/ Create providers which are in java.base directly\n+            if (provName.equals(\"SUN\") || provName.equals(\"sun.security.provider.Sun\")) {\n+                p = new sun.security.provider.Sun();\n+            } else if (provName.equals(\"SunRsaSign\") || provName.equals(\"sun.security.rsa.SunRsaSign\")) {\n+                p = new sun.security.rsa.SunRsaSign();\n+            } else if (provName.equals(\"SunJCE\") || provName.equals(\"com.sun.crypto.provider.SunJCE\")) {\n+                p = new com.sun.crypto.provider.SunJCE();\n+            } else if (provName.equals(\"SunJSSE\")) {\n+                p = new sun.security.ssl.SunJSSE();\n+            } else if (provName.equals(\"Apple\") || provName.equals(\"apple.security.AppleProvider\")) {\n+                \/\/ need to use reflection since this class only exists on MacOsx\n+                p = AccessController.doPrivileged(new PrivilegedAction<Provider>() {\n+                    public Provider run() {\n+                        try {\n+                            Class<?> c = Class.forName(\"apple.security.AppleProvider\");\n+                            if (Provider.class.isAssignableFrom(c)) {\n+                                @SuppressWarnings(\"deprecation\")\n+                                Object tmp = c.newInstance();\n+                                return (Provider) tmp;\n+                            } else {\n+                                return null;\n+                            }\n+                        } catch (Exception ex) {\n+                            if (debug != null) {\n+                                debug.println(\"Error loading provider Apple\");\n+                                ex.printStackTrace();\n+                            }\n@@ -195,4 +208,9 @@\n-                    } catch (Exception ex) {\n-                        if (debug != null) {\n-                        debug.println(\"Error loading provider Apple\");\n-                        ex.printStackTrace();\n+                    }\n+                });\n+            } else {\n+                if (isLoading) {\n+                    \/\/ because this method is synchronized, this can only\n+                    \/\/ happen if there is recursion.\n+                    if (debug != null) {\n+                        debug.println(\"Recursion loading provider: \" + this);\n+                        new Exception(\"Call trace\").printStackTrace();\n@@ -202,9 +220,6 @@\n-             }\n-             });\n-        } else {\n-            if (isLoading) {\n-                \/\/ because this method is synchronized, this can only\n-                \/\/ happen if there is recursion.\n-                if (debug != null) {\n-                    debug.println(\"Recursion loading provider: \" + this);\n-                    new Exception(\"Call trace\").printStackTrace();\n+                try {\n+                    isLoading = true;\n+                    tries++;\n+                    p = doLoadProvider();\n+                } finally {\n+                    isLoading = false;\n@@ -212,8 +227,0 @@\n-                return null;\n-            }\n-            try {\n-                isLoading = true;\n-                tries++;\n-                p = doLoadProvider();\n-            } finally {\n-                isLoading = false;\n@@ -221,0 +228,1 @@\n+            provider = p;\n@@ -222,1 +230,0 @@\n-        provider = p;\n","filename":"src\/java.base\/share\/classes\/sun\/security\/jca\/ProviderConfig.java","additions":53,"deletions":46,"binary":false,"changes":99,"status":"modified"}]}