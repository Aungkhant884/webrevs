{"files":[{"patch":"@@ -134,1 +134,6 @@\n-    public void invalidate(final int defaultDisplayID) {\n+    \/**\n+     * Invalidates this device so it will point to some other \"new\" device.\n+     *\n+     * @param  device the new device, usually the main screen\n+     *\/\n+    public void invalidate(CGraphicsDevice device) {\n@@ -136,1 +141,1 @@\n-        displayID = defaultDisplayID;\n+        displayID = device.displayID;\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/awt\/CGraphicsDevice.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import java.awt.AWTError;\n@@ -115,1 +114,1 @@\n-        initDevices();\n+        rebuildDevices();\n@@ -124,0 +123,8 @@\n+    \/**\n+     * Updates the list of devices and notify listeners.\n+     *\/\n+    private void rebuildDevices() {\n+        initDevices();\n+        displayChanged();\n+    }\n+\n@@ -130,21 +137,7 @@\n-    void _displayReconfiguration(final int displayId, final boolean removed) {\n-        synchronized (this) {\n-            if (removed && devices.containsKey(displayId)) {\n-                final CGraphicsDevice gd = devices.remove(displayId);\n-                oldDevices.add(new WeakReference<>(gd));\n-            }\n-        }\n-        initDevices();\n-\n-        \/\/ Need to notify old devices, in case the user hold the reference to it\n-        for (ListIterator<WeakReference<CGraphicsDevice>> it =\n-             oldDevices.listIterator(); it.hasNext(); ) {\n-            CGraphicsDevice gd = it.next().get();\n-            if (gd != null) {\n-                gd.invalidate(mainDisplayID);\n-                gd.displayChanged();\n-            } else {\n-                \/\/ no more references to this device, remove it\n-                it.remove();\n-            }\n-        }\n+    void _displayReconfiguration(int displayId, boolean removed) {\n+        \/\/ we ignore the passed parameters and check removed devices ourself\n+        \/\/ Note that it is possible that this callback is called when the\n+        \/\/ monitors are not added nor removed, but when the video card is\n+        \/\/ switched to\/from the discrete video card, so we should try to map the\n+        \/\/ old to the new devices.\n+        rebuildDevices();\n@@ -166,14 +159,51 @@\n-    private void initDevices() {\n-        synchronized (this) {\n-            final Map<Integer, CGraphicsDevice> old = new HashMap<>(devices);\n-            devices.clear();\n-\n-            mainDisplayID = getMainDisplayID();\n-\n-            \/\/ initialization of the graphics device may change\n-            \/\/ list of displays on hybrid systems via an activation\n-            \/\/ of discrete video.\n-            \/\/ So, we initialize the main display first, and then\n-            \/\/ retrieve actual list of displays.\n-            if (!old.containsKey(mainDisplayID)) {\n-                old.put(mainDisplayID, new CGraphicsDevice(mainDisplayID));\n+    private synchronized void initDevices() {\n+        Map<Integer, CGraphicsDevice> old = new HashMap<>(devices);\n+        devices.clear();\n+        mainDisplayID = getMainDisplayID();\n+\n+        \/\/ initialization of the graphics device may change list of displays on\n+        \/\/ hybrid systems via an activation of discrete video.\n+        \/\/ So, we initialize the main display first, then retrieve actual list\n+        \/\/ of displays, and then recheck the main display again.\n+        if (!old.containsKey(mainDisplayID)) {\n+            old.put(mainDisplayID, new CGraphicsDevice(mainDisplayID));\n+        }\n+\n+        int[] displayIDs = getDisplayIDs();\n+        if (displayIDs.length == 0) {\n+            \/\/ we could throw AWTError in this case.\n+            displayIDs = new int[]{mainDisplayID};\n+        }\n+        for (int id : displayIDs) {\n+            devices.put(id, old.containsKey(id) ? old.remove(id)\n+                                                : new CGraphicsDevice(id));\n+        }\n+        \/\/ fetch the main display again, the old value might be outdated\n+        mainDisplayID = getMainDisplayID();\n+\n+        \/\/ unlikely but make sure the main screen is in the list of screens,\n+        \/\/ most probably one more \"displayReconfiguration\" is on the road if not\n+        if (!devices.containsKey(mainDisplayID)) {\n+            mainDisplayID = displayIDs[0]; \/\/ best we can do\n+        }\n+        \/\/ if a device was not reused it should be invalidated\n+        for (CGraphicsDevice gd : old.values()) {\n+            oldDevices.add(new WeakReference<>(gd));\n+        }\n+        \/\/ Need to notify old devices, in case the user hold the reference to it\n+        for (ListIterator<WeakReference<CGraphicsDevice>> it =\n+             oldDevices.listIterator(); it.hasNext(); ) {\n+            CGraphicsDevice gd = it.next().get();\n+            if (gd != null) {\n+                \/\/ If the old device has the same bounds as some new device\n+                \/\/ then map that old device to the new, or to the main screen.\n+                CGraphicsDevice similarDevice = getSimilarDevice(gd);\n+                if (similarDevice == null) {\n+                    gd.invalidate(devices.get(mainDisplayID));\n+                } else {\n+                    gd.invalidate(similarDevice);\n+                }\n+                gd.displayChanged();\n+            } else {\n+                \/\/ no more references to this device, remove it\n+                it.remove();\n@@ -181,0 +211,2 @@\n+        }\n+    }\n@@ -182,3 +214,5 @@\n-            for (final int id : getDisplayIDs()) {\n-                devices.put(id, old.containsKey(id) ? old.get(id)\n-                                                    : new CGraphicsDevice(id));\n+    private CGraphicsDevice getSimilarDevice(CGraphicsDevice old) {\n+        for (CGraphicsDevice device : devices.values()) {\n+            if (device.getBounds().equals(old.getBounds())) {\n+                \/\/ for now we will use the bounds only\n+                return device;\n@@ -187,1 +221,1 @@\n-        displayChanged();\n+        return null;\n@@ -192,12 +226,1 @@\n-        CGraphicsDevice d = devices.get(mainDisplayID);\n-        if (d == null) {\n-            \/\/ we do not expect that this may happen, the only response\n-            \/\/ is to re-initialize the list of devices\n-            initDevices();\n-\n-            d = devices.get(mainDisplayID);\n-            if (d == null) {\n-                throw new AWTError(\"no screen devices\");\n-            }\n-        }\n-        return d;\n+        return devices.get(mainDisplayID);\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/awt\/CGraphicsEnvironment.java","additions":77,"deletions":54,"binary":false,"changes":131,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n- * @bug 4836241 6364134 8232200\n+ * @bug 4836241 6364134 8232200 8252133\n","filename":"test\/jdk\/java\/awt\/GraphicsDevice\/DisplayModes\/CycleDMImage.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}