{"files":[{"patch":"@@ -491,0 +491,19 @@\n+\n+void VM_Version::initialize_cpu_information(void) {\n+  \/\/ do nothing if cpu info has been initialized\n+  if (_initialized) {\n+    return;\n+  }\n+\n+  _no_of_cores  = os::processor_count();\n+  _no_of_threads = _no_of_cores;\n+  _no_of_sockets = _no_of_cores;\n+  snprintf(_cpu_name, CPU_TYPE_DESC_BUF_SIZE - 1, \"AArch64\");\n+\n+  int desc_len = snprintf(_cpu_desc, CPU_DETAILED_DESC_BUF_SIZE, \"AArch64 \");\n+  get_compatible_board(_cpu_desc + desc_len, CPU_DETAILED_DESC_BUF_SIZE - desc_len);\n+  desc_len = (int)strlen(_cpu_desc);\n+  snprintf(_cpu_desc + desc_len, CPU_DETAILED_DESC_BUF_SIZE - desc_len, \" %s\", _features_string);\n+\n+  _initialized = true;\n+}\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.cpp","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -156,0 +156,3 @@\n+\n+  static void initialize_cpu_information(void);\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,96 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"precompiled.hpp\"\n-#include \"memory\/allocation.hpp\"\n-#include \"memory\/allocation.inline.hpp\"\n-#include \"runtime\/os.inline.hpp\"\n-#include \"vm_version_ext_aarch64.hpp\"\n-\n-\/\/ VM_Version_Ext statics\n-int VM_Version_Ext::_no_of_threads = 0;\n-int VM_Version_Ext::_no_of_cores = 0;\n-int VM_Version_Ext::_no_of_sockets = 0;\n-bool VM_Version_Ext::_initialized = false;\n-char VM_Version_Ext::_cpu_name[CPU_TYPE_DESC_BUF_SIZE] = {0};\n-char VM_Version_Ext::_cpu_desc[CPU_DETAILED_DESC_BUF_SIZE] = {0};\n-\n-void VM_Version_Ext::initialize_cpu_information(void) {\n-  \/\/ do nothing if cpu info has been initialized\n-  if (_initialized) {\n-    return;\n-  }\n-\n-  int core_id = -1;\n-  int chip_id = -1;\n-  int len = 0;\n-  char* src_string = NULL;\n-\n-  _no_of_cores  = os::processor_count();\n-  _no_of_threads = _no_of_cores;\n-  _no_of_sockets = _no_of_cores;\n-  snprintf(_cpu_name, CPU_TYPE_DESC_BUF_SIZE - 1, \"AArch64\");\n-\n-  int desc_len = snprintf(_cpu_desc, CPU_DETAILED_DESC_BUF_SIZE, \"AArch64 \");\n-  VM_Version::get_compatible_board(_cpu_desc + desc_len, CPU_DETAILED_DESC_BUF_SIZE - desc_len);\n-  desc_len = (int)strlen(_cpu_desc);\n-  snprintf(_cpu_desc + desc_len, CPU_DETAILED_DESC_BUF_SIZE - desc_len, \" %s\", _features_string);\n-\n-  _initialized = true;\n-}\n-\n-int VM_Version_Ext::number_of_threads(void) {\n-  initialize_cpu_information();\n-  return _no_of_threads;\n-}\n-\n-int VM_Version_Ext::number_of_cores(void) {\n-  initialize_cpu_information();\n-  return _no_of_cores;\n-}\n-\n-int VM_Version_Ext::number_of_sockets(void) {\n-  initialize_cpu_information();\n-  return _no_of_sockets;\n-}\n-\n-const char* VM_Version_Ext::cpu_name(void) {\n-  initialize_cpu_information();\n-  char* tmp = NEW_C_HEAP_ARRAY_RETURN_NULL(char, CPU_TYPE_DESC_BUF_SIZE, mtTracing);\n-  if (NULL == tmp) {\n-    return NULL;\n-  }\n-  strncpy(tmp, _cpu_name, CPU_TYPE_DESC_BUF_SIZE);\n-  return tmp;\n-}\n-\n-const char* VM_Version_Ext::cpu_description(void) {\n-  initialize_cpu_information();\n-  char* tmp = NEW_C_HEAP_ARRAY_RETURN_NULL(char, CPU_DETAILED_DESC_BUF_SIZE, mtTracing);\n-  if (NULL == tmp) {\n-    return NULL;\n-  }\n-  strncpy(tmp, _cpu_desc, CPU_DETAILED_DESC_BUF_SIZE);\n-  return tmp;\n-}\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_ext_aarch64.cpp","additions":0,"deletions":96,"binary":false,"changes":96,"status":"deleted"},{"patch":"@@ -1,54 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef CPU_AARCH64_VM_VERSION_EXT_AARCH64_HPP\n-#define CPU_AARCH64_VM_VERSION_EXT_AARCH64_HPP\n-\n-#include \"runtime\/vm_version.hpp\"\n-#include \"utilities\/macros.hpp\"\n-\n-class VM_Version_Ext : public VM_Version {\n- private:\n-  static const size_t      CPU_TYPE_DESC_BUF_SIZE = 256;\n-  static const size_t      CPU_DETAILED_DESC_BUF_SIZE = 4096;\n-\n-  static int               _no_of_threads;\n-  static int               _no_of_cores;\n-  static int               _no_of_sockets;\n-  static bool              _initialized;\n-  static char              _cpu_name[CPU_TYPE_DESC_BUF_SIZE];\n-  static char              _cpu_desc[CPU_DETAILED_DESC_BUF_SIZE];\n-\n- public:\n-  static int number_of_threads(void);\n-  static int number_of_cores(void);\n-  static int number_of_sockets(void);\n-\n-  static const char* cpu_name(void);\n-  static const char* cpu_description(void);\n-  static void initialize_cpu_information(void);\n-\n-};\n-\n-#endif \/\/ CPU_AARCH64_VM_VERSION_EXT_AARCH64_HPP\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_ext_aarch64.hpp","additions":0,"deletions":54,"binary":false,"changes":54,"status":"deleted"},{"patch":"@@ -109,0 +109,1 @@\n+  static void initialize_cpu_information(void);\n","filename":"src\/hotspot\/cpu\/arm\/vm_version_arm.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -350,0 +350,14 @@\n+\n+void VM_Version::initialize_cpu_information(void) {\n+  \/\/ do nothing if cpu info has been initialized\n+  if (_initialized) {\n+    return;\n+  }\n+\n+  _no_of_cores  = os::processor_count();\n+  _no_of_threads = _no_of_cores;\n+  _no_of_sockets = _no_of_cores;\n+  snprintf(_cpu_name, CPU_TYPE_DESC_BUF_SIZE - 1, \"ARM%d\", _arm_arch);\n+  snprintf(_cpu_desc, CPU_DETAILED_DESC_BUF_SIZE, \"%s\", _features_string);\n+  _initialized = true;\n+}\n","filename":"src\/hotspot\/cpu\/arm\/vm_version_arm_32.cpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1,90 +0,0 @@\n-\/*\n- * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"memory\/allocation.hpp\"\n-#include \"memory\/allocation.inline.hpp\"\n-#include \"runtime\/os.inline.hpp\"\n-#include \"vm_version_ext_arm.hpp\"\n-\n-\/\/ VM_Version_Ext statics\n-int VM_Version_Ext::_no_of_threads = 0;\n-int VM_Version_Ext::_no_of_cores = 0;\n-int VM_Version_Ext::_no_of_sockets = 0;\n-bool VM_Version_Ext::_initialized = false;\n-char VM_Version_Ext::_cpu_name[CPU_TYPE_DESC_BUF_SIZE] = {0};\n-char VM_Version_Ext::_cpu_desc[CPU_DETAILED_DESC_BUF_SIZE] = {0};\n-\n-void VM_Version_Ext::initialize_cpu_information(void) {\n-  \/\/ do nothing if cpu info has been initialized\n-  if (_initialized) {\n-    return;\n-  }\n-\n-  int core_id = -1;\n-  int chip_id = -1;\n-  int len = 0;\n-  char* src_string = NULL;\n-\n-  _no_of_cores  = os::processor_count();\n-  _no_of_threads = _no_of_cores;\n-  _no_of_sockets = _no_of_cores;\n-  snprintf(_cpu_name, CPU_TYPE_DESC_BUF_SIZE - 1, \"ARM%d\", _arm_arch);\n-  snprintf(_cpu_desc, CPU_DETAILED_DESC_BUF_SIZE, \"%s\", _features_string);\n-  _initialized = true;\n-}\n-\n-int VM_Version_Ext::number_of_threads(void) {\n-  initialize_cpu_information();\n-  return _no_of_threads;\n-}\n-\n-int VM_Version_Ext::number_of_cores(void) {\n-  initialize_cpu_information();\n-  return _no_of_cores;\n-}\n-\n-int VM_Version_Ext::number_of_sockets(void) {\n-  initialize_cpu_information();\n-  return _no_of_sockets;\n-}\n-\n-const char* VM_Version_Ext::cpu_name(void) {\n-  initialize_cpu_information();\n-  char* tmp = NEW_C_HEAP_ARRAY_RETURN_NULL(char, CPU_TYPE_DESC_BUF_SIZE, mtTracing);\n-  if (NULL == tmp) {\n-    return NULL;\n-  }\n-  strncpy(tmp, _cpu_name, CPU_TYPE_DESC_BUF_SIZE);\n-  return tmp;\n-}\n-\n-const char* VM_Version_Ext::cpu_description(void) {\n-  initialize_cpu_information();\n-  char* tmp = NEW_C_HEAP_ARRAY_RETURN_NULL(char, CPU_DETAILED_DESC_BUF_SIZE, mtTracing);\n-  if (NULL == tmp) {\n-    return NULL;\n-  }\n-  strncpy(tmp, _cpu_desc, CPU_DETAILED_DESC_BUF_SIZE);\n-  return tmp;\n-}\n","filename":"src\/hotspot\/cpu\/arm\/vm_version_ext_arm.cpp","additions":0,"deletions":90,"binary":false,"changes":90,"status":"deleted"},{"patch":"@@ -1,54 +0,0 @@\n-\/*\n- * Copyright (c) 2013, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef CPU_ARM_VM_VERSION_EXT_ARM_HPP\n-#define CPU_ARM_VM_VERSION_EXT_ARM_HPP\n-\n-#include \"runtime\/vm_version.hpp\"\n-#include \"utilities\/macros.hpp\"\n-\n-class VM_Version_Ext : public VM_Version {\n- private:\n-  static const size_t      CPU_TYPE_DESC_BUF_SIZE = 256;\n-  static const size_t      CPU_DETAILED_DESC_BUF_SIZE = 4096;\n-\n-  static int               _no_of_threads;\n-  static int               _no_of_cores;\n-  static int               _no_of_sockets;\n-  static bool              _initialized;\n-  static char              _cpu_name[CPU_TYPE_DESC_BUF_SIZE];\n-  static char              _cpu_desc[CPU_DETAILED_DESC_BUF_SIZE];\n-\n- public:\n-  static int number_of_threads(void);\n-  static int number_of_cores(void);\n-  static int number_of_sockets(void);\n-\n-  static const char* cpu_name(void);\n-  static const char* cpu_description(void);\n-  static void initialize_cpu_information(void);\n-\n-};\n-\n-#endif \/\/ CPU_ARM_VM_VERSION_EXT_ARM_HPP\n","filename":"src\/hotspot\/cpu\/arm\/vm_version_ext_arm.hpp","additions":0,"deletions":54,"binary":false,"changes":54,"status":"deleted"},{"patch":"@@ -1,87 +0,0 @@\n-\/*\n- * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"jvm.h\"\n-#include \"memory\/allocation.hpp\"\n-#include \"memory\/allocation.inline.hpp\"\n-#include \"runtime\/vm_version.hpp\"\n-#include \"vm_version_ext_ppc.hpp\"\n-\n-\/\/ VM_Version_Ext statics\n-int   VM_Version_Ext::_no_of_threads = 0;\n-int   VM_Version_Ext::_no_of_cores = 0;\n-int   VM_Version_Ext::_no_of_sockets = 0;\n-bool  VM_Version_Ext::_initialized = false;\n-char  VM_Version_Ext::_cpu_name[CPU_TYPE_DESC_BUF_SIZE] = {0};\n-char  VM_Version_Ext::_cpu_desc[CPU_DETAILED_DESC_BUF_SIZE] = {0};\n-\n-\/\/ get cpu information.\n-void VM_Version_Ext::initialize_cpu_information(void) {\n-  \/\/ do nothing if cpu info has been initialized\n-  if (_initialized) {\n-    return;\n-  }\n-\n-  _no_of_cores  = os::processor_count();\n-  _no_of_threads = _no_of_cores;\n-  _no_of_sockets = _no_of_cores;\n-  snprintf(_cpu_name, CPU_TYPE_DESC_BUF_SIZE, \"PowerPC POWER%lu\", PowerArchitecturePPC64);\n-  snprintf(_cpu_desc, CPU_DETAILED_DESC_BUF_SIZE, \"PPC %s\", features_string());\n-  _initialized = true;\n-}\n-\n-int VM_Version_Ext::number_of_threads(void) {\n-  initialize_cpu_information();\n-  return _no_of_threads;\n-}\n-\n-int VM_Version_Ext::number_of_cores(void) {\n-  initialize_cpu_information();\n-  return _no_of_cores;\n-}\n-\n-int VM_Version_Ext::number_of_sockets(void) {\n-  initialize_cpu_information();\n-  return _no_of_sockets;\n-}\n-\n-const char* VM_Version_Ext::cpu_name(void) {\n-  initialize_cpu_information();\n-  char* tmp = NEW_C_HEAP_ARRAY_RETURN_NULL(char, CPU_TYPE_DESC_BUF_SIZE, mtTracing);\n-  if (NULL == tmp) {\n-    return NULL;\n-  }\n-  strncpy(tmp, _cpu_name, CPU_TYPE_DESC_BUF_SIZE);\n-  return tmp;\n-}\n-\n-const char* VM_Version_Ext::cpu_description(void) {\n-  initialize_cpu_information();\n-  char* tmp = NEW_C_HEAP_ARRAY_RETURN_NULL(char, CPU_DETAILED_DESC_BUF_SIZE, mtTracing);\n-  if (NULL == tmp) {\n-    return NULL;\n-  }\n-  strncpy(tmp, _cpu_desc, CPU_DETAILED_DESC_BUF_SIZE);\n-  return tmp;\n-}\n","filename":"src\/hotspot\/cpu\/ppc\/vm_version_ext_ppc.cpp","additions":0,"deletions":87,"binary":false,"changes":87,"status":"deleted"},{"patch":"@@ -1,62 +0,0 @@\n-\/*\n- * Copyright (c) 2013, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef CPU_PPC_VM_VERSION_EXT_PPC_HPP\n-#define CPU_PPC_VM_VERSION_EXT_PPC_HPP\n-\n-#include \"runtime\/vm_version.hpp\"\n-#include \"utilities\/macros.hpp\"\n-\n-#define CPU_INFO        \"cpu_info\"\n-#define CPU_TYPE        \"fpu_type\"\n-#define CPU_DESCRIPTION \"implementation\"\n-#define CHIP_ID         \"chip_id\"\n-#define CORE_ID         \"core_id\"\n-\n-class VM_Version_Ext : public VM_Version {\n- private:\n-\n-  static const size_t      CPU_TYPE_DESC_BUF_SIZE = 256;\n-  static const size_t      CPU_DETAILED_DESC_BUF_SIZE = 4096;\n-\n-  static int               _no_of_threads;\n-  static int               _no_of_cores;\n-  static int               _no_of_sockets;\n-  static bool              _initialized;\n-  static char              _cpu_name[CPU_TYPE_DESC_BUF_SIZE];\n-  static char              _cpu_desc[CPU_DETAILED_DESC_BUF_SIZE];\n-\n-  static void initialize_cpu_information(void);\n-\n- public:\n-\n-  static int number_of_threads(void);\n-  static int number_of_cores(void);\n-  static int number_of_sockets(void);\n-\n-  static const char* cpu_name(void);\n-  static const char* cpu_description(void);\n-};\n-\n-#endif \/\/ CPU_PPC_VM_VERSION_EXT_PPC_HPP\n","filename":"src\/hotspot\/cpu\/ppc\/vm_version_ext_ppc.hpp","additions":0,"deletions":62,"binary":false,"changes":62,"status":"deleted"},{"patch":"@@ -770,0 +770,15 @@\n+\n+\/\/ get cpu information.\n+void VM_Version::initialize_cpu_information(void) {\n+  \/\/ do nothing if cpu info has been initialized\n+  if (_initialized) {\n+    return;\n+  }\n+\n+  _no_of_cores  = os::processor_count();\n+  _no_of_threads = _no_of_cores;\n+  _no_of_sockets = _no_of_cores;\n+  snprintf(_cpu_name, CPU_TYPE_DESC_BUF_SIZE, \"PowerPC POWER%lu\", PowerArchitecturePPC64);\n+  snprintf(_cpu_desc, CPU_DETAILED_DESC_BUF_SIZE, \"PPC %s\", features_string());\n+  _initialized = true;\n+}\n","filename":"src\/hotspot\/cpu\/ppc\/vm_version_ppc.cpp","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -131,0 +131,2 @@\n+\n+  static void initialize_cpu_information(void);\n","filename":"src\/hotspot\/cpu\/ppc\/vm_version_ppc.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,86 +0,0 @@\n-\/*\n- * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"jvm.h\"\n-#include \"memory\/allocation.hpp\"\n-#include \"memory\/allocation.inline.hpp\"\n-#include \"vm_version_ext_s390.hpp\"\n-\n-\/\/ VM_Version_Ext statics\n-int   VM_Version_Ext::_no_of_threads = 0;\n-int   VM_Version_Ext::_no_of_cores = 0;\n-int   VM_Version_Ext::_no_of_sockets = 0;\n-bool  VM_Version_Ext::_initialized = false;\n-char  VM_Version_Ext::_cpu_name[CPU_TYPE_DESC_BUF_SIZE] = {0};\n-char  VM_Version_Ext::_cpu_desc[CPU_DETAILED_DESC_BUF_SIZE] = {0};\n-\n-\/\/ get cpu information.\n-void  VM_Version_Ext::initialize_cpu_information(void) {\n-  \/\/ do nothing if cpu info has been initialized\n-  if (_initialized) {\n-    return;\n-  }\n-\n-  _no_of_cores  = os::processor_count();\n-  _no_of_threads = _no_of_cores;\n-  _no_of_sockets = _no_of_cores;\n-  snprintf(_cpu_name, CPU_TYPE_DESC_BUF_SIZE, \"s390 %s\", VM_Version::get_model_string());\n-  snprintf(_cpu_desc, CPU_DETAILED_DESC_BUF_SIZE, \"s390 %s\", features_string());\n-  _initialized = true;\n-}\n-\n-int VM_Version_Ext::number_of_threads(void) {\n-  initialize_cpu_information();\n-  return _no_of_threads;\n-}\n-\n-int VM_Version_Ext::number_of_cores(void) {\n-  initialize_cpu_information();\n-  return _no_of_cores;\n-}\n-\n-int VM_Version_Ext::number_of_sockets(void) {\n-  initialize_cpu_information();\n-  return _no_of_sockets;\n-}\n-\n-const char* VM_Version_Ext::cpu_name(void) {\n-  initialize_cpu_information();\n-  char* tmp = NEW_C_HEAP_ARRAY_RETURN_NULL(char, CPU_TYPE_DESC_BUF_SIZE, mtTracing);\n-  if (NULL == tmp) {\n-    return NULL;\n-  }\n-  strncpy(tmp, _cpu_name, CPU_TYPE_DESC_BUF_SIZE);\n-  return tmp;\n-}\n-\n-const char* VM_Version_Ext::cpu_description(void) {\n-  initialize_cpu_information();\n-  char* tmp = NEW_C_HEAP_ARRAY_RETURN_NULL(char, CPU_DETAILED_DESC_BUF_SIZE, mtTracing);\n-  if (NULL == tmp) {\n-    return NULL;\n-  }\n-  strncpy(tmp, _cpu_desc, CPU_DETAILED_DESC_BUF_SIZE);\n-  return tmp;\n-}\n","filename":"src\/hotspot\/cpu\/s390\/vm_version_ext_s390.cpp","additions":0,"deletions":86,"binary":false,"changes":86,"status":"deleted"},{"patch":"@@ -1,62 +0,0 @@\n-\/*\n- * Copyright (c) 2013, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef CPU_S390_VM_VERSION_EXT_S390_HPP\n-#define CPU_S390_VM_VERSION_EXT_S390_HPP\n-\n-#include \"runtime\/vm_version.hpp\"\n-#include \"utilities\/macros.hpp\"\n-\n-#define CPU_INFO        \"cpu_info\"\n-#define CPU_TYPE        \"fpu_type\"\n-#define CPU_DESCRIPTION \"implementation\"\n-#define CHIP_ID         \"chip_id\"\n-#define CORE_ID         \"core_id\"\n-\n-class VM_Version_Ext : public VM_Version {\n- private:\n-\n-  static const size_t      CPU_TYPE_DESC_BUF_SIZE = 256;\n-  static const size_t      CPU_DETAILED_DESC_BUF_SIZE = 4096;\n-\n-  static int               _no_of_threads;\n-  static int               _no_of_cores;\n-  static int               _no_of_sockets;\n-  static bool              _initialized;\n-  static char              _cpu_name[CPU_TYPE_DESC_BUF_SIZE];\n-  static char              _cpu_desc[CPU_DETAILED_DESC_BUF_SIZE];\n-\n-  static void initialize_cpu_information(void);\n-\n- public:\n-\n-  static int number_of_threads(void);\n-  static int number_of_cores(void);\n-  static int number_of_sockets(void);\n-\n-  static const char* cpu_name(void);\n-  static const char* cpu_description(void);\n-};\n-\n-#endif \/\/ CPU_S390_VM_VERSION_EXT_S390_HPP\n","filename":"src\/hotspot\/cpu\/s390\/vm_version_ext_s390.hpp","additions":0,"deletions":62,"binary":false,"changes":62,"status":"deleted"},{"patch":"@@ -1493,0 +1493,16 @@\n+\n+\n+\/\/ get cpu information.\n+void VM_Version::initialize_cpu_information(void) {\n+  \/\/ do nothing if cpu info has been initialized\n+  if (_initialized) {\n+    return;\n+  }\n+\n+  _no_of_cores  = os::processor_count();\n+  _no_of_threads = _no_of_cores;\n+  _no_of_sockets = _no_of_cores;\n+  snprintf(_cpu_name, CPU_TYPE_DESC_BUF_SIZE, \"s390 %s\", VM_Version::get_model_string());\n+  snprintf(_cpu_desc, CPU_DETAILED_DESC_BUF_SIZE, \"s390 %s\", features_string());\n+  _initialized = true;\n+}\n","filename":"src\/hotspot\/cpu\/s390\/vm_version_s390.cpp","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -536,0 +536,2 @@\n+\n+  static void initialize_cpu_information(void);\n","filename":"src\/hotspot\/cpu\/s390\/vm_version_s390.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n-#include \"vm_version_ext_x86.hpp\"\n+#include \"vm_version_x86.hpp\"\n@@ -104,1 +104,1 @@\n-  if (VM_Version_Ext::supports_tscinv_ext()) {\n+  if (VM_Version::supports_tscinv_ext()) {\n@@ -106,1 +106,1 @@\n-    tsc_freq = (double)VM_Version_Ext::maximum_qualified_cpu_frequency();\n+    tsc_freq = (double)VM_Version::maximum_qualified_cpu_frequency();\n@@ -174,1 +174,1 @@\n-  return VM_Version_Ext::supports_tscinv_ext();\n+  return VM_Version::supports_tscinv_ext();\n@@ -201,1 +201,1 @@\n-    VM_Version_Ext::initialize();\n+    VM_Version::initialize_tsc();\n","filename":"src\/hotspot\/cpu\/x86\/rdtsc_x86.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1,982 +0,0 @@\n-\/*\n- * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"precompiled.hpp\"\n-#include \"jvm.h\"\n-#include \"utilities\/macros.hpp\"\n-#include \"asm\/macroAssembler.hpp\"\n-#include \"asm\/macroAssembler.inline.hpp\"\n-#include \"code\/codeBlob.hpp\"\n-#include \"memory\/allocation.inline.hpp\"\n-#include \"memory\/resourceArea.hpp\"\n-#include \"runtime\/java.hpp\"\n-#include \"runtime\/stubCodeGenerator.hpp\"\n-#include \"vm_version_ext_x86.hpp\"\n-\n-typedef enum {\n-   CPU_FAMILY_8086_8088  = 0,\n-   CPU_FAMILY_INTEL_286  = 2,\n-   CPU_FAMILY_INTEL_386  = 3,\n-   CPU_FAMILY_INTEL_486  = 4,\n-   CPU_FAMILY_PENTIUM    = 5,\n-   CPU_FAMILY_PENTIUMPRO = 6,    \/\/ Same family several models\n-   CPU_FAMILY_PENTIUM_4  = 0xF\n-} FamilyFlag;\n-\n-typedef enum {\n-  RDTSCP_FLAG  = 0x08000000, \/\/ bit 27\n-  INTEL64_FLAG = 0x20000000  \/\/ bit 29\n-} _featureExtendedEdxFlag;\n-\n-#define CPUID_STANDARD_FN   0x0\n-#define CPUID_STANDARD_FN_1 0x1\n-#define CPUID_STANDARD_FN_4 0x4\n-#define CPUID_STANDARD_FN_B 0xb\n-\n-#define CPUID_EXTENDED_FN   0x80000000\n-#define CPUID_EXTENDED_FN_1 0x80000001\n-#define CPUID_EXTENDED_FN_2 0x80000002\n-#define CPUID_EXTENDED_FN_3 0x80000003\n-#define CPUID_EXTENDED_FN_4 0x80000004\n-#define CPUID_EXTENDED_FN_7 0x80000007\n-#define CPUID_EXTENDED_FN_8 0x80000008\n-\n-typedef enum {\n-   FPU_FLAG     = 0x00000001,\n-   VME_FLAG     = 0x00000002,\n-   DE_FLAG      = 0x00000004,\n-   PSE_FLAG     = 0x00000008,\n-   TSC_FLAG     = 0x00000010,\n-   MSR_FLAG     = 0x00000020,\n-   PAE_FLAG     = 0x00000040,\n-   MCE_FLAG     = 0x00000080,\n-   CX8_FLAG     = 0x00000100,\n-   APIC_FLAG    = 0x00000200,\n-   SEP_FLAG     = 0x00000800,\n-   MTRR_FLAG    = 0x00001000,\n-   PGE_FLAG     = 0x00002000,\n-   MCA_FLAG     = 0x00004000,\n-   CMOV_FLAG    = 0x00008000,\n-   PAT_FLAG     = 0x00010000,\n-   PSE36_FLAG   = 0x00020000,\n-   PSNUM_FLAG   = 0x00040000,\n-   CLFLUSH_FLAG = 0x00080000,\n-   DTS_FLAG     = 0x00200000,\n-   ACPI_FLAG    = 0x00400000,\n-   MMX_FLAG     = 0x00800000,\n-   FXSR_FLAG    = 0x01000000,\n-   SSE_FLAG     = 0x02000000,\n-   SSE2_FLAG    = 0x04000000,\n-   SS_FLAG      = 0x08000000,\n-   HTT_FLAG     = 0x10000000,\n-   TM_FLAG      = 0x20000000\n-} FeatureEdxFlag;\n-\n-static BufferBlob* cpuid_brand_string_stub_blob;\n-static const int   cpuid_brand_string_stub_size = 550;\n-\n-extern \"C\" {\n-  typedef void (*getCPUIDBrandString_stub_t)(void*);\n-}\n-\n-static getCPUIDBrandString_stub_t getCPUIDBrandString_stub = NULL;\n-\n-class VM_Version_Ext_StubGenerator: public StubCodeGenerator {\n- public:\n-\n-  VM_Version_Ext_StubGenerator(CodeBuffer *c) : StubCodeGenerator(c) {}\n-\n-  address generate_getCPUIDBrandString(void) {\n-    \/\/ Flags to test CPU type.\n-    const uint32_t HS_EFL_AC           = 0x40000;\n-    const uint32_t HS_EFL_ID           = 0x200000;\n-    \/\/ Values for when we don't have a CPUID instruction.\n-    const int      CPU_FAMILY_SHIFT = 8;\n-    const uint32_t CPU_FAMILY_386   = (3 << CPU_FAMILY_SHIFT);\n-    const uint32_t CPU_FAMILY_486   = (4 << CPU_FAMILY_SHIFT);\n-\n-    Label detect_486, cpu486, detect_586, done, ext_cpuid;\n-\n-    StubCodeMark mark(this, \"VM_Version_Ext\", \"getCPUIDNameInfo_stub\");\n-#   define __ _masm->\n-\n-    address start = __ pc();\n-\n-    \/\/\n-    \/\/ void getCPUIDBrandString(VM_Version::CpuidInfo* cpuid_info);\n-    \/\/\n-    \/\/ LP64: rcx and rdx are first and second argument registers on windows\n-\n-    __ push(rbp);\n-#ifdef _LP64\n-    __ mov(rbp, c_rarg0); \/\/ cpuid_info address\n-#else\n-    __ movptr(rbp, Address(rsp, 8)); \/\/ cpuid_info address\n-#endif\n-    __ push(rbx);\n-    __ push(rsi);\n-    __ pushf();          \/\/ preserve rbx, and flags\n-    __ pop(rax);\n-    __ push(rax);\n-    __ mov(rcx, rax);\n-    \/\/\n-    \/\/ if we are unable to change the AC flag, we have a 386\n-    \/\/\n-    __ xorl(rax, HS_EFL_AC);\n-    __ push(rax);\n-    __ popf();\n-    __ pushf();\n-    __ pop(rax);\n-    __ cmpptr(rax, rcx);\n-    __ jccb(Assembler::notEqual, detect_486);\n-\n-    __ movl(rax, CPU_FAMILY_386);\n-    __ jmp(done);\n-\n-    \/\/\n-    \/\/ If we are unable to change the ID flag, we have a 486 which does\n-    \/\/ not support the \"cpuid\" instruction.\n-    \/\/\n-    __ bind(detect_486);\n-    __ mov(rax, rcx);\n-    __ xorl(rax, HS_EFL_ID);\n-    __ push(rax);\n-    __ popf();\n-    __ pushf();\n-    __ pop(rax);\n-    __ cmpptr(rcx, rax);\n-    __ jccb(Assembler::notEqual, detect_586);\n-\n-    __ bind(cpu486);\n-    __ movl(rax, CPU_FAMILY_486);\n-    __ jmp(done);\n-\n-    \/\/\n-    \/\/ At this point, we have a chip which supports the \"cpuid\" instruction\n-    \/\/\n-    __ bind(detect_586);\n-    __ xorl(rax, rax);\n-    __ cpuid();\n-    __ orl(rax, rax);\n-    __ jcc(Assembler::equal, cpu486);   \/\/ if cpuid doesn't support an input\n-                                        \/\/ value of at least 1, we give up and\n-                                        \/\/ assume a 486\n-\n-    \/\/\n-    \/\/ Extended cpuid(0x80000000) for processor brand string detection\n-    \/\/\n-    __ bind(ext_cpuid);\n-    __ movl(rax, CPUID_EXTENDED_FN);\n-    __ cpuid();\n-    __ cmpl(rax, CPUID_EXTENDED_FN_4);\n-    __ jcc(Assembler::below, done);\n-\n-    \/\/\n-    \/\/ Extended cpuid(0x80000002)  \/\/ first 16 bytes in brand string\n-    \/\/\n-    __ movl(rax, CPUID_EXTENDED_FN_2);\n-    __ cpuid();\n-    __ lea(rsi, Address(rbp, in_bytes(VM_Version_Ext::proc_name_0_offset())));\n-    __ movl(Address(rsi, 0), rax);\n-    __ lea(rsi, Address(rbp, in_bytes(VM_Version_Ext::proc_name_1_offset())));\n-    __ movl(Address(rsi, 0), rbx);\n-    __ lea(rsi, Address(rbp, in_bytes(VM_Version_Ext::proc_name_2_offset())));\n-    __ movl(Address(rsi, 0), rcx);\n-    __ lea(rsi, Address(rbp, in_bytes(VM_Version_Ext::proc_name_3_offset())));\n-    __ movl(Address(rsi,0), rdx);\n-\n-    \/\/\n-    \/\/ Extended cpuid(0x80000003) \/\/ next 16 bytes in brand string\n-    \/\/\n-    __ movl(rax, CPUID_EXTENDED_FN_3);\n-    __ cpuid();\n-    __ lea(rsi, Address(rbp, in_bytes(VM_Version_Ext::proc_name_4_offset())));\n-    __ movl(Address(rsi, 0), rax);\n-    __ lea(rsi, Address(rbp, in_bytes(VM_Version_Ext::proc_name_5_offset())));\n-    __ movl(Address(rsi, 0), rbx);\n-    __ lea(rsi, Address(rbp, in_bytes(VM_Version_Ext::proc_name_6_offset())));\n-    __ movl(Address(rsi, 0), rcx);\n-    __ lea(rsi, Address(rbp, in_bytes(VM_Version_Ext::proc_name_7_offset())));\n-    __ movl(Address(rsi,0), rdx);\n-\n-    \/\/\n-    \/\/ Extended cpuid(0x80000004) \/\/ last 16 bytes in brand string\n-    \/\/\n-    __ movl(rax, CPUID_EXTENDED_FN_4);\n-    __ cpuid();\n-    __ lea(rsi, Address(rbp, in_bytes(VM_Version_Ext::proc_name_8_offset())));\n-    __ movl(Address(rsi, 0), rax);\n-    __ lea(rsi, Address(rbp, in_bytes(VM_Version_Ext::proc_name_9_offset())));\n-    __ movl(Address(rsi, 0), rbx);\n-    __ lea(rsi, Address(rbp, in_bytes(VM_Version_Ext::proc_name_10_offset())));\n-    __ movl(Address(rsi, 0), rcx);\n-    __ lea(rsi, Address(rbp, in_bytes(VM_Version_Ext::proc_name_11_offset())));\n-    __ movl(Address(rsi,0), rdx);\n-\n-    \/\/\n-    \/\/ return\n-    \/\/\n-    __ bind(done);\n-    __ popf();\n-    __ pop(rsi);\n-    __ pop(rbx);\n-    __ pop(rbp);\n-    __ ret(0);\n-\n-#   undef __\n-\n-    return start;\n-  };\n-};\n-\n-\n-\/\/ VM_Version_Ext statics\n-const size_t VM_Version_Ext::VENDOR_LENGTH = 13;\n-const size_t VM_Version_Ext::CPU_EBS_MAX_LENGTH = (3 * 4 * 4 + 1);\n-const size_t VM_Version_Ext::CPU_TYPE_DESC_BUF_SIZE = 256;\n-const size_t VM_Version_Ext::CPU_DETAILED_DESC_BUF_SIZE = 4096;\n-char* VM_Version_Ext::_cpu_brand_string = NULL;\n-int64_t VM_Version_Ext::_max_qualified_cpu_frequency = 0;\n-\n-int VM_Version_Ext::_no_of_threads = 0;\n-int VM_Version_Ext::_no_of_cores = 0;\n-int VM_Version_Ext::_no_of_packages = 0;\n-\n-void VM_Version_Ext::initialize(void) {\n-  ResourceMark rm;\n-\n-  cpuid_brand_string_stub_blob = BufferBlob::create(\"getCPUIDBrandString_stub\", cpuid_brand_string_stub_size);\n-  if (cpuid_brand_string_stub_blob == NULL) {\n-    vm_exit_during_initialization(\"Unable to allocate getCPUIDBrandString_stub\");\n-  }\n-  CodeBuffer c(cpuid_brand_string_stub_blob);\n-  VM_Version_Ext_StubGenerator g(&c);\n-  getCPUIDBrandString_stub = CAST_TO_FN_PTR(getCPUIDBrandString_stub_t,\n-                                   g.generate_getCPUIDBrandString());\n-}\n-\n-const char* VM_Version_Ext::cpu_model_description(void) {\n-  uint32_t cpu_family = extended_cpu_family();\n-  uint32_t cpu_model = extended_cpu_model();\n-  const char* model = NULL;\n-\n-  if (cpu_family == CPU_FAMILY_PENTIUMPRO) {\n-    for (uint32_t i = 0; i <= cpu_model; i++) {\n-      model = _model_id_pentium_pro[i];\n-      if (model == NULL) {\n-        break;\n-      }\n-    }\n-  }\n-  return model;\n-}\n-\n-const char* VM_Version_Ext::cpu_brand_string(void) {\n-  if (_cpu_brand_string == NULL) {\n-    _cpu_brand_string = NEW_C_HEAP_ARRAY_RETURN_NULL(char, CPU_EBS_MAX_LENGTH, mtInternal);\n-    if (NULL == _cpu_brand_string) {\n-      return NULL;\n-    }\n-    int ret_val = cpu_extended_brand_string(_cpu_brand_string, CPU_EBS_MAX_LENGTH);\n-    if (ret_val != OS_OK) {\n-      FREE_C_HEAP_ARRAY(char, _cpu_brand_string);\n-      _cpu_brand_string = NULL;\n-    }\n-  }\n-  return _cpu_brand_string;\n-}\n-\n-const char* VM_Version_Ext::cpu_brand(void) {\n-  const char*  brand  = NULL;\n-\n-  if ((_cpuid_info.std_cpuid1_ebx.value & 0xFF) > 0) {\n-    int brand_num = _cpuid_info.std_cpuid1_ebx.value & 0xFF;\n-    brand = _brand_id[0];\n-    for (int i = 0; brand != NULL && i <= brand_num; i += 1) {\n-      brand = _brand_id[i];\n-    }\n-  }\n-  return brand;\n-}\n-\n-bool VM_Version_Ext::cpu_is_em64t(void) {\n-  return ((_cpuid_info.ext_cpuid1_edx.value & INTEL64_FLAG) == INTEL64_FLAG);\n-}\n-\n-bool VM_Version_Ext::is_netburst(void) {\n-  return (is_intel() && (extended_cpu_family() == CPU_FAMILY_PENTIUM_4));\n-}\n-\n-bool VM_Version_Ext::supports_tscinv_ext(void) {\n-  if (!supports_tscinv_bit()) {\n-    return false;\n-  }\n-\n-  if (is_intel()) {\n-    return true;\n-  }\n-\n-  if (is_amd()) {\n-    return !is_amd_Barcelona();\n-  }\n-\n-  if (is_hygon()) {\n-    return true;\n-  }\n-\n-  return false;\n-}\n-\n-void VM_Version_Ext::resolve_cpu_information_details(void) {\n-\n-  \/\/ in future we want to base this information on proper cpu\n-  \/\/ and cache topology enumeration such as:\n-  \/\/ Intel 64 Architecture Processor Topology Enumeration\n-  \/\/ which supports system cpu and cache topology enumeration\n-  \/\/ either using 2xAPICIDs or initial APICIDs\n-\n-  \/\/ currently only rough cpu information estimates\n-  \/\/ which will not necessarily reflect the exact configuration of the system\n-\n-  \/\/ this is the number of logical hardware threads\n-  \/\/ visible to the operating system\n-  _no_of_threads = os::processor_count();\n-\n-  \/\/ find out number of threads per cpu package\n-  int threads_per_package = threads_per_core() * cores_per_cpu();\n-\n-  \/\/ use amount of threads visible to the process in order to guess number of sockets\n-  _no_of_packages = _no_of_threads \/ threads_per_package;\n-\n-  \/\/ process might only see a subset of the total number of threads\n-  \/\/ from a single processor package. Virtualization\/resource management for example.\n-  \/\/ If so then just write a hard 1 as num of pkgs.\n-  if (0 == _no_of_packages) {\n-    _no_of_packages = 1;\n-  }\n-\n-  \/\/ estimate the number of cores\n-  _no_of_cores = cores_per_cpu() * _no_of_packages;\n-}\n-\n-int VM_Version_Ext::number_of_threads(void) {\n-  if (_no_of_threads == 0) {\n-   resolve_cpu_information_details();\n-  }\n-  return _no_of_threads;\n-}\n-\n-int VM_Version_Ext::number_of_cores(void) {\n-  if (_no_of_cores == 0) {\n-    resolve_cpu_information_details();\n-  }\n-  return _no_of_cores;\n-}\n-\n-int VM_Version_Ext::number_of_sockets(void) {\n-  if (_no_of_packages == 0) {\n-    resolve_cpu_information_details();\n-  }\n-  return _no_of_packages;\n-}\n-\n-const char* VM_Version_Ext::cpu_family_description(void) {\n-  int cpu_family_id = extended_cpu_family();\n-  if (is_amd()) {\n-    if (cpu_family_id < ExtendedFamilyIdLength_AMD) {\n-      return _family_id_amd[cpu_family_id];\n-    }\n-  }\n-  if (is_intel()) {\n-    if (cpu_family_id == CPU_FAMILY_PENTIUMPRO) {\n-      return cpu_model_description();\n-    }\n-    if (cpu_family_id < ExtendedFamilyIdLength_INTEL) {\n-      return _family_id_intel[cpu_family_id];\n-    }\n-  }\n-  if (is_hygon()) {\n-    return \"Dhyana\";\n-  }\n-  return \"Unknown x86\";\n-}\n-\n-int VM_Version_Ext::cpu_type_description(char* const buf, size_t buf_len) {\n-  assert(buf != NULL, \"buffer is NULL!\");\n-  assert(buf_len >= CPU_TYPE_DESC_BUF_SIZE, \"buffer len should at least be == CPU_TYPE_DESC_BUF_SIZE!\");\n-\n-  const char* cpu_type = NULL;\n-  const char* x64 = NULL;\n-\n-  if (is_intel()) {\n-    cpu_type = \"Intel\";\n-    x64 = cpu_is_em64t() ? \" Intel64\" : \"\";\n-  } else if (is_amd()) {\n-    cpu_type = \"AMD\";\n-    x64 = cpu_is_em64t() ? \" AMD64\" : \"\";\n-  } else if (is_hygon()) {\n-    cpu_type = \"Hygon\";\n-    x64 = cpu_is_em64t() ? \" AMD64\" : \"\";\n-  } else {\n-    cpu_type = \"Unknown x86\";\n-    x64 = cpu_is_em64t() ? \" x86_64\" : \"\";\n-  }\n-\n-  jio_snprintf(buf, buf_len, \"%s %s%s SSE SSE2%s%s%s%s%s%s%s%s\",\n-    cpu_type,\n-    cpu_family_description(),\n-    supports_ht() ? \" (HT)\" : \"\",\n-    supports_sse3() ? \" SSE3\" : \"\",\n-    supports_ssse3() ? \" SSSE3\" : \"\",\n-    supports_sse4_1() ? \" SSE4.1\" : \"\",\n-    supports_sse4_2() ? \" SSE4.2\" : \"\",\n-    supports_sse4a() ? \" SSE4A\" : \"\",\n-    is_netburst() ? \" Netburst\" : \"\",\n-    is_intel_family_core() ? \" Core\" : \"\",\n-    x64);\n-\n-  return OS_OK;\n-}\n-\n-int VM_Version_Ext::cpu_extended_brand_string(char* const buf, size_t buf_len) {\n-  assert(buf != NULL, \"buffer is NULL!\");\n-  assert(buf_len >= CPU_EBS_MAX_LENGTH, \"buffer len should at least be == CPU_EBS_MAX_LENGTH!\");\n-  assert(getCPUIDBrandString_stub != NULL, \"not initialized\");\n-\n-  \/\/ invoke newly generated asm code to fetch CPU Brand String\n-  getCPUIDBrandString_stub(&_cpuid_info);\n-\n-  \/\/ fetch results into buffer\n-  *((uint32_t*) &buf[0])  = _cpuid_info.proc_name_0;\n-  *((uint32_t*) &buf[4])  = _cpuid_info.proc_name_1;\n-  *((uint32_t*) &buf[8])  = _cpuid_info.proc_name_2;\n-  *((uint32_t*) &buf[12]) = _cpuid_info.proc_name_3;\n-  *((uint32_t*) &buf[16]) = _cpuid_info.proc_name_4;\n-  *((uint32_t*) &buf[20]) = _cpuid_info.proc_name_5;\n-  *((uint32_t*) &buf[24]) = _cpuid_info.proc_name_6;\n-  *((uint32_t*) &buf[28]) = _cpuid_info.proc_name_7;\n-  *((uint32_t*) &buf[32]) = _cpuid_info.proc_name_8;\n-  *((uint32_t*) &buf[36]) = _cpuid_info.proc_name_9;\n-  *((uint32_t*) &buf[40]) = _cpuid_info.proc_name_10;\n-  *((uint32_t*) &buf[44]) = _cpuid_info.proc_name_11;\n-\n-  return OS_OK;\n-}\n-\n-size_t VM_Version_Ext::cpu_write_support_string(char* const buf, size_t buf_len) {\n-  guarantee(buf != NULL, \"buffer is NULL!\");\n-  guarantee(buf_len > 0, \"buffer len not enough!\");\n-\n-  unsigned int flag = 0;\n-  unsigned int fi = 0;\n-  size_t       written = 0;\n-  const char*  prefix = \"\";\n-\n-#define WRITE_TO_BUF(string)                                                          \\\n-  {                                                                                   \\\n-    int res = jio_snprintf(&buf[written], buf_len - written, \"%s%s\", prefix, string); \\\n-    if (res < 0) {                                                                    \\\n-      return buf_len - 1;                                                             \\\n-    }                                                                                 \\\n-    written += res;                                                                   \\\n-    if (prefix[0] == '\\0') {                                                          \\\n-      prefix = \", \";                                                                  \\\n-    }                                                                                 \\\n-  }\n-\n-  for (flag = 1, fi = 0; flag <= 0x20000000 ; flag <<= 1, fi++) {\n-    if (flag == HTT_FLAG && (((_cpuid_info.std_cpuid1_ebx.value >> 16) & 0xff) <= 1)) {\n-      continue; \/* no hyperthreading *\/\n-    } else if (flag == SEP_FLAG && (cpu_family() == CPU_FAMILY_PENTIUMPRO && ((_cpuid_info.std_cpuid1_eax.value & 0xff) < 0x33))) {\n-      continue; \/* no fast system call *\/\n-    }\n-    if ((_cpuid_info.std_cpuid1_edx.value & flag) && strlen(_feature_edx_id[fi]) > 0) {\n-      WRITE_TO_BUF(_feature_edx_id[fi]);\n-    }\n-  }\n-\n-  for (flag = 1, fi = 0; flag <= 0x20000000; flag <<= 1, fi++) {\n-    if ((_cpuid_info.std_cpuid1_ecx.value & flag) && strlen(_feature_ecx_id[fi]) > 0) {\n-      WRITE_TO_BUF(_feature_ecx_id[fi]);\n-    }\n-  }\n-\n-  for (flag = 1, fi = 0; flag <= 0x20000000 ; flag <<= 1, fi++) {\n-    if ((_cpuid_info.ext_cpuid1_ecx.value & flag) && strlen(_feature_extended_ecx_id[fi]) > 0) {\n-      WRITE_TO_BUF(_feature_extended_ecx_id[fi]);\n-    }\n-  }\n-\n-  for (flag = 1, fi = 0; flag <= 0x20000000; flag <<= 1, fi++) {\n-    if ((_cpuid_info.ext_cpuid1_edx.value & flag) && strlen(_feature_extended_edx_id[fi]) > 0) {\n-      WRITE_TO_BUF(_feature_extended_edx_id[fi]);\n-    }\n-  }\n-\n-  if (supports_tscinv_bit()) {\n-      WRITE_TO_BUF(\"Invariant TSC\");\n-  }\n-\n-  return written;\n-}\n-\n-\/**\n- * Write a detailed description of the cpu to a given buffer, including\n- * feature set.\n- *\/\n-int VM_Version_Ext::cpu_detailed_description(char* const buf, size_t buf_len) {\n-  assert(buf != NULL, \"buffer is NULL!\");\n-  assert(buf_len >= CPU_DETAILED_DESC_BUF_SIZE, \"buffer len should at least be == CPU_DETAILED_DESC_BUF_SIZE!\");\n-\n-  static const char* unknown = \"<unknown>\";\n-  char               vendor_id[VENDOR_LENGTH];\n-  const char*        family = NULL;\n-  const char*        model = NULL;\n-  const char*        brand = NULL;\n-  int                outputLen = 0;\n-\n-  family = cpu_family_description();\n-  if (family == NULL) {\n-    family = unknown;\n-  }\n-\n-  model = cpu_model_description();\n-  if (model == NULL) {\n-    model = unknown;\n-  }\n-\n-  brand = cpu_brand_string();\n-\n-  if (brand == NULL) {\n-    brand = cpu_brand();\n-    if (brand == NULL) {\n-      brand = unknown;\n-    }\n-  }\n-\n-  *((uint32_t*) &vendor_id[0]) = _cpuid_info.std_vendor_name_0;\n-  *((uint32_t*) &vendor_id[4]) = _cpuid_info.std_vendor_name_2;\n-  *((uint32_t*) &vendor_id[8]) = _cpuid_info.std_vendor_name_1;\n-  vendor_id[VENDOR_LENGTH-1] = '\\0';\n-\n-  outputLen = jio_snprintf(buf, buf_len, \"Brand: %s, Vendor: %s\\n\"\n-    \"Family: %s (0x%x), Model: %s (0x%x), Stepping: 0x%x\\n\"\n-    \"Ext. family: 0x%x, Ext. model: 0x%x, Type: 0x%x, Signature: 0x%8.8x\\n\"\n-    \"Features: ebx: 0x%8.8x, ecx: 0x%8.8x, edx: 0x%8.8x\\n\"\n-    \"Ext. features: eax: 0x%8.8x, ebx: 0x%8.8x, ecx: 0x%8.8x, edx: 0x%8.8x\\n\"\n-    \"Supports: \",\n-    brand,\n-    vendor_id,\n-    family,\n-    extended_cpu_family(),\n-    model,\n-    extended_cpu_model(),\n-    cpu_stepping(),\n-    _cpuid_info.std_cpuid1_eax.bits.ext_family,\n-    _cpuid_info.std_cpuid1_eax.bits.ext_model,\n-    _cpuid_info.std_cpuid1_eax.bits.proc_type,\n-    _cpuid_info.std_cpuid1_eax.value,\n-    _cpuid_info.std_cpuid1_ebx.value,\n-    _cpuid_info.std_cpuid1_ecx.value,\n-    _cpuid_info.std_cpuid1_edx.value,\n-    _cpuid_info.ext_cpuid1_eax,\n-    _cpuid_info.ext_cpuid1_ebx,\n-    _cpuid_info.ext_cpuid1_ecx,\n-    _cpuid_info.ext_cpuid1_edx);\n-\n-  if (outputLen < 0 || (size_t) outputLen >= buf_len - 1) {\n-    if (buf_len > 0) { buf[buf_len-1] = '\\0'; }\n-    return OS_ERR;\n-  }\n-\n-  cpu_write_support_string(&buf[outputLen], buf_len - outputLen);\n-\n-  return OS_OK;\n-}\n-\n-const char* VM_Version_Ext::cpu_name(void) {\n-  char cpu_type_desc[CPU_TYPE_DESC_BUF_SIZE];\n-  size_t cpu_desc_len = sizeof(cpu_type_desc);\n-\n-  cpu_type_description(cpu_type_desc, cpu_desc_len);\n-  char* tmp = NEW_C_HEAP_ARRAY_RETURN_NULL(char, cpu_desc_len, mtTracing);\n-  if (NULL == tmp) {\n-    return NULL;\n-  }\n-  strncpy(tmp, cpu_type_desc, cpu_desc_len);\n-  return tmp;\n-}\n-\n-const char* VM_Version_Ext::cpu_description(void) {\n-  char cpu_detailed_desc_buffer[CPU_DETAILED_DESC_BUF_SIZE];\n-  size_t cpu_detailed_desc_len = sizeof(cpu_detailed_desc_buffer);\n-\n-  cpu_detailed_description(cpu_detailed_desc_buffer, cpu_detailed_desc_len);\n-\n-  char* tmp = NEW_C_HEAP_ARRAY_RETURN_NULL(char, cpu_detailed_desc_len, mtTracing);\n-\n-  if (NULL == tmp) {\n-    return NULL;\n-  }\n-\n-  strncpy(tmp, cpu_detailed_desc_buffer, cpu_detailed_desc_len);\n-  return tmp;\n-}\n-\n-\/**\n- *  For information about extracting the frequency from the cpu brand string, please see:\n- *\n- *    Intel Processor Identification and the CPUID Instruction\n- *    Application Note 485\n- *    May 2012\n- *\n- * The return value is the frequency in Hz.\n- *\/\n-int64_t VM_Version_Ext::max_qualified_cpu_freq_from_brand_string(void) {\n-  const char* const brand_string = cpu_brand_string();\n-  if (brand_string == NULL) {\n-    return 0;\n-  }\n-  const int64_t MEGA = 1000000;\n-  int64_t multiplier = 0;\n-  int64_t frequency = 0;\n-  uint8_t idx = 0;\n-  \/\/ The brand string buffer is at most 48 bytes.\n-  \/\/ -2 is to prevent buffer overrun when looking for y in yHz, as z is +2 from y.\n-  for (; idx < 48-2; ++idx) {\n-    \/\/ Format is either \"x.xxyHz\" or \"xxxxyHz\", where y=M, G, T and x are digits.\n-    \/\/ Search brand string for \"yHz\" where y is M, G, or T.\n-    if (brand_string[idx+1] == 'H' && brand_string[idx+2] == 'z') {\n-      if (brand_string[idx] == 'M') {\n-        multiplier = MEGA;\n-      } else if (brand_string[idx] == 'G') {\n-        multiplier = MEGA * 1000;\n-      } else if (brand_string[idx] == 'T') {\n-        multiplier = MEGA * MEGA;\n-      }\n-      break;\n-    }\n-  }\n-  if (multiplier > 0) {\n-    \/\/ Compute freqency (in Hz) from brand string.\n-    if (brand_string[idx-3] == '.') { \/\/ if format is \"x.xx\"\n-      frequency =  (brand_string[idx-4] - '0') * multiplier;\n-      frequency += (brand_string[idx-2] - '0') * multiplier \/ 10;\n-      frequency += (brand_string[idx-1] - '0') * multiplier \/ 100;\n-    } else { \/\/ format is \"xxxx\"\n-      frequency =  (brand_string[idx-4] - '0') * 1000;\n-      frequency += (brand_string[idx-3] - '0') * 100;\n-      frequency += (brand_string[idx-2] - '0') * 10;\n-      frequency += (brand_string[idx-1] - '0');\n-      frequency *= multiplier;\n-    }\n-  }\n-  return frequency;\n-}\n-\n-\n-int64_t VM_Version_Ext::maximum_qualified_cpu_frequency(void) {\n-  if (_max_qualified_cpu_frequency == 0) {\n-    _max_qualified_cpu_frequency = max_qualified_cpu_freq_from_brand_string();\n-  }\n-  return _max_qualified_cpu_frequency;\n-}\n-\n-const char* const VM_Version_Ext::_family_id_intel[ExtendedFamilyIdLength_INTEL] = {\n-  \"8086\/8088\",\n-  \"\",\n-  \"286\",\n-  \"386\",\n-  \"486\",\n-  \"Pentium\",\n-  \"Pentium Pro\",   \/\/or Pentium-M\/Woodcrest depeding on model\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"Pentium 4\"\n-};\n-\n-const char* const VM_Version_Ext::_family_id_amd[ExtendedFamilyIdLength_AMD] = {\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"5x86\",\n-  \"K5\/K6\",\n-  \"Athlon\/AthlonXP\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"Opteron\/Athlon64\",\n-  \"Opteron QC\/Phenom\",  \/\/ Barcelona et.al.\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"Zen\"\n-};\n-\/\/ Partially from Intel 64 and IA-32 Architecture Software Developer's Manual,\n-\/\/ September 2013, Vol 3C Table 35-1\n-const char* const VM_Version_Ext::_model_id_pentium_pro[] = {\n-  \"\",\n-  \"Pentium Pro\",\n-  \"\",\n-  \"Pentium II model 3\",\n-  \"\",\n-  \"Pentium II model 5\/Xeon\/Celeron\",\n-  \"Celeron\",\n-  \"Pentium III\/Pentium III Xeon\",\n-  \"Pentium III\/Pentium III Xeon\",\n-  \"Pentium M model 9\",    \/\/ Yonah\n-  \"Pentium III, model A\",\n-  \"Pentium III, model B\",\n-  \"\",\n-  \"Pentium M model D\",    \/\/ Dothan\n-  \"\",\n-  \"Core 2\",               \/\/ 0xf Woodcrest\/Conroe\/Merom\/Kentsfield\/Clovertown\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"Celeron\",              \/\/ 0x16 Celeron 65nm\n-  \"Core 2\",               \/\/ 0x17 Penryn \/ Harpertown\n-  \"\",\n-  \"\",\n-  \"Core i7\",              \/\/ 0x1A CPU_MODEL_NEHALEM_EP\n-  \"Atom\",                 \/\/ 0x1B Z5xx series Silverthorn\n-  \"\",\n-  \"Core 2\",               \/\/ 0x1D Dunnington (6-core)\n-  \"Nehalem\",              \/\/ 0x1E CPU_MODEL_NEHALEM\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"Westmere\",             \/\/ 0x25 CPU_MODEL_WESTMERE\n-  \"\",\n-  \"\",\n-  \"\",                     \/\/ 0x28\n-  \"\",\n-  \"Sandy Bridge\",         \/\/ 0x2a \"2nd Generation Intel Core i7, i5, i3\"\n-  \"\",\n-  \"Westmere-EP\",          \/\/ 0x2c CPU_MODEL_WESTMERE_EP\n-  \"Sandy Bridge-EP\",      \/\/ 0x2d CPU_MODEL_SANDYBRIDGE_EP\n-  \"Nehalem-EX\",           \/\/ 0x2e CPU_MODEL_NEHALEM_EX\n-  \"Westmere-EX\",          \/\/ 0x2f CPU_MODEL_WESTMERE_EX\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"Ivy Bridge\",           \/\/ 0x3a\n-  \"\",\n-  \"Haswell\",              \/\/ 0x3c \"4th Generation Intel Core Processor\"\n-  \"\",                     \/\/ 0x3d \"Next Generation Intel Core Processor\"\n-  \"Ivy Bridge-EP\",        \/\/ 0x3e \"Next Generation Intel Xeon Processor E7 Family\"\n-  \"\",                     \/\/ 0x3f \"Future Generation Intel Xeon Processor\"\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"Haswell\",              \/\/ 0x45 \"4th Generation Intel Core Processor\"\n-  \"Haswell\",              \/\/ 0x46 \"4th Generation Intel Core Processor\"\n-  NULL\n-};\n-\n-\/* Brand ID is for back compability\n- * Newer CPUs uses the extended brand string *\/\n-const char* const VM_Version_Ext::_brand_id[] = {\n-  \"\",\n-  \"Celeron processor\",\n-  \"Pentium III processor\",\n-  \"Intel Pentium III Xeon processor\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"Intel Pentium 4 processor\",\n-  NULL\n-};\n-\n-\n-const char* const VM_Version_Ext::_feature_edx_id[] = {\n-  \"On-Chip FPU\",\n-  \"Virtual Mode Extensions\",\n-  \"Debugging Extensions\",\n-  \"Page Size Extensions\",\n-  \"Time Stamp Counter\",\n-  \"Model Specific Registers\",\n-  \"Physical Address Extension\",\n-  \"Machine Check Exceptions\",\n-  \"CMPXCHG8B Instruction\",\n-  \"On-Chip APIC\",\n-  \"\",\n-  \"Fast System Call\",\n-  \"Memory Type Range Registers\",\n-  \"Page Global Enable\",\n-  \"Machine Check Architecture\",\n-  \"Conditional Mov Instruction\",\n-  \"Page Attribute Table\",\n-  \"36-bit Page Size Extension\",\n-  \"Processor Serial Number\",\n-  \"CLFLUSH Instruction\",\n-  \"\",\n-  \"Debug Trace Store feature\",\n-  \"ACPI registers in MSR space\",\n-  \"Intel Architecture MMX Technology\",\n-  \"Fast Float Point Save and Restore\",\n-  \"Streaming SIMD extensions\",\n-  \"Streaming SIMD extensions 2\",\n-  \"Self-Snoop\",\n-  \"Hyper Threading\",\n-  \"Thermal Monitor\",\n-  \"\",\n-  \"Pending Break Enable\"\n-};\n-\n-const char* const VM_Version_Ext::_feature_extended_edx_id[] = {\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"SYSCALL\/SYSRET\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"Execute Disable Bit\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"RDTSCP\",\n-  \"\",\n-  \"Intel 64 Architecture\",\n-  \"\",\n-  \"\"\n-};\n-\n-const char* const VM_Version_Ext::_feature_ecx_id[] = {\n-  \"Streaming SIMD Extensions 3\",\n-  \"PCLMULQDQ\",\n-  \"64-bit DS Area\",\n-  \"MONITOR\/MWAIT instructions\",\n-  \"CPL Qualified Debug Store\",\n-  \"Virtual Machine Extensions\",\n-  \"Safer Mode Extensions\",\n-  \"Enhanced Intel SpeedStep technology\",\n-  \"Thermal Monitor 2\",\n-  \"Supplemental Streaming SIMD Extensions 3\",\n-  \"L1 Context ID\",\n-  \"\",\n-  \"Fused Multiply-Add\",\n-  \"CMPXCHG16B\",\n-  \"xTPR Update Control\",\n-  \"Perfmon and Debug Capability\",\n-  \"\",\n-  \"Process-context identifiers\",\n-  \"Direct Cache Access\",\n-  \"Streaming SIMD extensions 4.1\",\n-  \"Streaming SIMD extensions 4.2\",\n-  \"x2APIC\",\n-  \"MOVBE\",\n-  \"Popcount instruction\",\n-  \"TSC-Deadline\",\n-  \"AESNI\",\n-  \"XSAVE\",\n-  \"OSXSAVE\",\n-  \"AVX\",\n-  \"F16C\",\n-  \"RDRAND\",\n-  \"\"\n-};\n-\n-const char* const VM_Version_Ext::_feature_extended_ecx_id[] = {\n-  \"LAHF\/SAHF instruction support\",\n-  \"Core multi-processor legacy mode\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"Advanced Bit Manipulations: LZCNT\",\n-  \"SSE4A: MOVNTSS, MOVNTSD, EXTRQ, INSERTQ\",\n-  \"Misaligned SSE mode\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"\"\n-};\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_ext_x86.cpp","additions":0,"deletions":982,"binary":false,"changes":982,"status":"deleted"},{"patch":"@@ -1,107 +0,0 @@\n-\/*\n- * Copyright (c) 2013, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef CPU_X86_VM_VERSION_EXT_X86_HPP\n-#define CPU_X86_VM_VERSION_EXT_X86_HPP\n-\n-#include \"runtime\/vm_version.hpp\"\n-#include \"utilities\/macros.hpp\"\n-#include \"utilities\/sizes.hpp\"\n-\n-class VM_Version_Ext : public VM_Version {\n-\n-  enum {\n-    ExtendedFamilyIdLength_INTEL = 16,\n-    ExtendedFamilyIdLength_AMD   = 24\n-  };\n-\n- private:\n-  static const size_t      VENDOR_LENGTH;\n-  static const size_t      CPU_EBS_MAX_LENGTH;\n-  static const size_t      CPU_TYPE_DESC_BUF_SIZE;\n-  static const size_t      CPU_DETAILED_DESC_BUF_SIZE;\n-\n-  static const char* const _family_id_intel[ExtendedFamilyIdLength_INTEL];\n-  static const char* const _family_id_amd[ExtendedFamilyIdLength_AMD];\n-  static const char* const _brand_id[];\n-  static const char* const _model_id_pentium_pro[];\n-\n-  static const char* const _feature_edx_id[];\n-  static const char* const _feature_extended_edx_id[];\n-  static const char* const _feature_ecx_id[];\n-  static const char* const _feature_extended_ecx_id[];\n-\n-  static int               _no_of_threads;\n-  static int               _no_of_cores;\n-  static int               _no_of_packages;\n-  static char*             _cpu_brand_string;\n-  static int64_t           _max_qualified_cpu_frequency;\n-\n-  static const char* cpu_family_description(void);\n-  static const char* cpu_model_description(void);\n-  static const char* cpu_brand(void);\n-  static const char* cpu_brand_string(void);\n-\n-  static int cpu_type_description(char* const buf, size_t buf_len);\n-  static int cpu_detailed_description(char* const buf, size_t buf_len);\n-  static int cpu_extended_brand_string(char* const buf, size_t buf_len);\n-\n-  static bool cpu_is_em64t(void);\n-  static bool is_netburst(void);\n-\n-  \/\/ Returns bytes written excluding termninating null byte.\n-  static size_t cpu_write_support_string(char* const buf, size_t buf_len);\n-  static void resolve_cpu_information_details(void);\n-  static int64_t max_qualified_cpu_freq_from_brand_string(void);\n-\n- public:\n-  \/\/ Offsets for cpuid asm stub brand string\n-  static ByteSize proc_name_0_offset() { return byte_offset_of(CpuidInfo, proc_name_0); }\n-  static ByteSize proc_name_1_offset() { return byte_offset_of(CpuidInfo, proc_name_1); }\n-  static ByteSize proc_name_2_offset() { return byte_offset_of(CpuidInfo, proc_name_2); }\n-  static ByteSize proc_name_3_offset() { return byte_offset_of(CpuidInfo, proc_name_3); }\n-  static ByteSize proc_name_4_offset() { return byte_offset_of(CpuidInfo, proc_name_4); }\n-  static ByteSize proc_name_5_offset() { return byte_offset_of(CpuidInfo, proc_name_5); }\n-  static ByteSize proc_name_6_offset() { return byte_offset_of(CpuidInfo, proc_name_6); }\n-  static ByteSize proc_name_7_offset() { return byte_offset_of(CpuidInfo, proc_name_7); }\n-  static ByteSize proc_name_8_offset() { return byte_offset_of(CpuidInfo, proc_name_8); }\n-  static ByteSize proc_name_9_offset() { return byte_offset_of(CpuidInfo, proc_name_9); }\n-  static ByteSize proc_name_10_offset() { return byte_offset_of(CpuidInfo, proc_name_10); }\n-  static ByteSize proc_name_11_offset() { return byte_offset_of(CpuidInfo, proc_name_11); }\n-\n-  static int number_of_threads(void);\n-  static int number_of_cores(void);\n-  static int number_of_sockets(void);\n-\n-  static int64_t maximum_qualified_cpu_frequency(void);\n-\n-  static bool supports_tscinv_ext(void);\n-\n-  static const char* cpu_name(void);\n-  static const char* cpu_description(void);\n-\n-  static void initialize();\n-};\n-\n-#endif \/\/ CPU_X86_VM_VERSION_EXT_X86_HPP\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_ext_x86.hpp","additions":0,"deletions":107,"binary":false,"changes":107,"status":"deleted"},{"patch":"@@ -86,0 +86,13 @@\n+#define CPUID_STANDARD_FN   0x0\n+#define CPUID_STANDARD_FN_1 0x1\n+#define CPUID_STANDARD_FN_4 0x4\n+#define CPUID_STANDARD_FN_B 0xb\n+\n+#define CPUID_EXTENDED_FN   0x80000000\n+#define CPUID_EXTENDED_FN_1 0x80000001\n+#define CPUID_EXTENDED_FN_2 0x80000002\n+#define CPUID_EXTENDED_FN_3 0x80000003\n+#define CPUID_EXTENDED_FN_4 0x80000004\n+#define CPUID_EXTENDED_FN_7 0x80000007\n+#define CPUID_EXTENDED_FN_8 0x80000008\n+\n@@ -629,0 +642,143 @@\n+#   undef __\n+\n+    return start;\n+  };\n+\n+\n+  address generate_getCPUIDBrandString(void) {\n+    \/\/ Flags to test CPU type.\n+    const uint32_t HS_EFL_AC           = 0x40000;\n+    const uint32_t HS_EFL_ID           = 0x200000;\n+    \/\/ Values for when we don't have a CPUID instruction.\n+    const int      CPU_FAMILY_SHIFT = 8;\n+    const uint32_t CPU_FAMILY_386   = (3 << CPU_FAMILY_SHIFT);\n+    const uint32_t CPU_FAMILY_486   = (4 << CPU_FAMILY_SHIFT);\n+\n+    Label detect_486, cpu486, detect_586, done, ext_cpuid;\n+\n+    StubCodeMark mark(this, \"VM_Version\", \"getCPUIDNameInfo_stub\");\n+#   define __ _masm->\n+\n+    address start = __ pc();\n+\n+    \/\/\n+    \/\/ void getCPUIDBrandString(VM_Version::CpuidInfo* cpuid_info);\n+    \/\/\n+    \/\/ LP64: rcx and rdx are first and second argument registers on windows\n+\n+    __ push(rbp);\n+#ifdef _LP64\n+    __ mov(rbp, c_rarg0); \/\/ cpuid_info address\n+#else\n+    __ movptr(rbp, Address(rsp, 8)); \/\/ cpuid_info address\n+#endif\n+    __ push(rbx);\n+    __ push(rsi);\n+    __ pushf();          \/\/ preserve rbx, and flags\n+    __ pop(rax);\n+    __ push(rax);\n+    __ mov(rcx, rax);\n+    \/\/\n+    \/\/ if we are unable to change the AC flag, we have a 386\n+    \/\/\n+    __ xorl(rax, HS_EFL_AC);\n+    __ push(rax);\n+    __ popf();\n+    __ pushf();\n+    __ pop(rax);\n+    __ cmpptr(rax, rcx);\n+    __ jccb(Assembler::notEqual, detect_486);\n+\n+    __ movl(rax, CPU_FAMILY_386);\n+    __ jmp(done);\n+\n+    \/\/\n+    \/\/ If we are unable to change the ID flag, we have a 486 which does\n+    \/\/ not support the \"cpuid\" instruction.\n+    \/\/\n+    __ bind(detect_486);\n+    __ mov(rax, rcx);\n+    __ xorl(rax, HS_EFL_ID);\n+    __ push(rax);\n+    __ popf();\n+    __ pushf();\n+    __ pop(rax);\n+    __ cmpptr(rcx, rax);\n+    __ jccb(Assembler::notEqual, detect_586);\n+\n+    __ bind(cpu486);\n+    __ movl(rax, CPU_FAMILY_486);\n+    __ jmp(done);\n+\n+    \/\/\n+    \/\/ At this point, we have a chip which supports the \"cpuid\" instruction\n+    \/\/\n+    __ bind(detect_586);\n+    __ xorl(rax, rax);\n+    __ cpuid();\n+    __ orl(rax, rax);\n+    __ jcc(Assembler::equal, cpu486);   \/\/ if cpuid doesn't support an input\n+                                        \/\/ value of at least 1, we give up and\n+                                        \/\/ assume a 486\n+\n+    \/\/\n+    \/\/ Extended cpuid(0x80000000) for processor brand string detection\n+    \/\/\n+    __ bind(ext_cpuid);\n+    __ movl(rax, CPUID_EXTENDED_FN);\n+    __ cpuid();\n+    __ cmpl(rax, CPUID_EXTENDED_FN_4);\n+    __ jcc(Assembler::below, done);\n+\n+    \/\/\n+    \/\/ Extended cpuid(0x80000002)  \/\/ first 16 bytes in brand string\n+    \/\/\n+    __ movl(rax, CPUID_EXTENDED_FN_2);\n+    __ cpuid();\n+    __ lea(rsi, Address(rbp, in_bytes(VM_Version::proc_name_0_offset())));\n+    __ movl(Address(rsi, 0), rax);\n+    __ lea(rsi, Address(rbp, in_bytes(VM_Version::proc_name_1_offset())));\n+    __ movl(Address(rsi, 0), rbx);\n+    __ lea(rsi, Address(rbp, in_bytes(VM_Version::proc_name_2_offset())));\n+    __ movl(Address(rsi, 0), rcx);\n+    __ lea(rsi, Address(rbp, in_bytes(VM_Version::proc_name_3_offset())));\n+    __ movl(Address(rsi,0), rdx);\n+\n+    \/\/\n+    \/\/ Extended cpuid(0x80000003) \/\/ next 16 bytes in brand string\n+    \/\/\n+    __ movl(rax, CPUID_EXTENDED_FN_3);\n+    __ cpuid();\n+    __ lea(rsi, Address(rbp, in_bytes(VM_Version::proc_name_4_offset())));\n+    __ movl(Address(rsi, 0), rax);\n+    __ lea(rsi, Address(rbp, in_bytes(VM_Version::proc_name_5_offset())));\n+    __ movl(Address(rsi, 0), rbx);\n+    __ lea(rsi, Address(rbp, in_bytes(VM_Version::proc_name_6_offset())));\n+    __ movl(Address(rsi, 0), rcx);\n+    __ lea(rsi, Address(rbp, in_bytes(VM_Version::proc_name_7_offset())));\n+    __ movl(Address(rsi,0), rdx);\n+\n+    \/\/\n+    \/\/ Extended cpuid(0x80000004) \/\/ last 16 bytes in brand string\n+    \/\/\n+    __ movl(rax, CPUID_EXTENDED_FN_4);\n+    __ cpuid();\n+    __ lea(rsi, Address(rbp, in_bytes(VM_Version::proc_name_8_offset())));\n+    __ movl(Address(rsi, 0), rax);\n+    __ lea(rsi, Address(rbp, in_bytes(VM_Version::proc_name_9_offset())));\n+    __ movl(Address(rsi, 0), rbx);\n+    __ lea(rsi, Address(rbp, in_bytes(VM_Version::proc_name_10_offset())));\n+    __ movl(Address(rsi, 0), rcx);\n+    __ lea(rsi, Address(rbp, in_bytes(VM_Version::proc_name_11_offset())));\n+    __ movl(Address(rsi,0), rdx);\n+\n+    \/\/\n+    \/\/ return\n+    \/\/\n+    __ bind(done);\n+    __ popf();\n+    __ pop(rsi);\n+    __ pop(rbx);\n+    __ pop(rbp);\n+    __ ret(0);\n+\n@@ -1915,0 +2071,751 @@\n+\n+typedef enum {\n+   CPU_FAMILY_8086_8088  = 0,\n+   CPU_FAMILY_INTEL_286  = 2,\n+   CPU_FAMILY_INTEL_386  = 3,\n+   CPU_FAMILY_INTEL_486  = 4,\n+   CPU_FAMILY_PENTIUM    = 5,\n+   CPU_FAMILY_PENTIUMPRO = 6,    \/\/ Same family several models\n+   CPU_FAMILY_PENTIUM_4  = 0xF\n+} FamilyFlag;\n+\n+typedef enum {\n+  RDTSCP_FLAG  = 0x08000000, \/\/ bit 27\n+  INTEL64_FLAG = 0x20000000  \/\/ bit 29\n+} _featureExtendedEdxFlag;\n+\n+typedef enum {\n+   FPU_FLAG     = 0x00000001,\n+   VME_FLAG     = 0x00000002,\n+   DE_FLAG      = 0x00000004,\n+   PSE_FLAG     = 0x00000008,\n+   TSC_FLAG     = 0x00000010,\n+   MSR_FLAG     = 0x00000020,\n+   PAE_FLAG     = 0x00000040,\n+   MCE_FLAG     = 0x00000080,\n+   CX8_FLAG     = 0x00000100,\n+   APIC_FLAG    = 0x00000200,\n+   SEP_FLAG     = 0x00000800,\n+   MTRR_FLAG    = 0x00001000,\n+   PGE_FLAG     = 0x00002000,\n+   MCA_FLAG     = 0x00004000,\n+   CMOV_FLAG    = 0x00008000,\n+   PAT_FLAG     = 0x00010000,\n+   PSE36_FLAG   = 0x00020000,\n+   PSNUM_FLAG   = 0x00040000,\n+   CLFLUSH_FLAG = 0x00080000,\n+   DTS_FLAG     = 0x00200000,\n+   ACPI_FLAG    = 0x00400000,\n+   MMX_FLAG     = 0x00800000,\n+   FXSR_FLAG    = 0x01000000,\n+   SSE_FLAG     = 0x02000000,\n+   SSE2_FLAG    = 0x04000000,\n+   SS_FLAG      = 0x08000000,\n+   HTT_FLAG     = 0x10000000,\n+   TM_FLAG      = 0x20000000\n+} FeatureEdxFlag;\n+\n+static BufferBlob* cpuid_brand_string_stub_blob;\n+static const int   cpuid_brand_string_stub_size = 550;\n+\n+extern \"C\" {\n+  typedef void (*getCPUIDBrandString_stub_t)(void*);\n+}\n+\n+static getCPUIDBrandString_stub_t getCPUIDBrandString_stub = NULL;\n+\n+\/\/ VM_Version statics\n+enum {\n+  ExtendedFamilyIdLength_INTEL = 16,\n+  ExtendedFamilyIdLength_AMD   = 24\n+};\n+\n+const size_t VENDOR_LENGTH = 13;\n+const size_t CPU_EBS_MAX_LENGTH = (3 * 4 * 4 + 1);\n+static char* _cpu_brand_string = NULL;\n+static int64_t _max_qualified_cpu_frequency = 0;\n+\n+static int _no_of_threads = 0;\n+static int _no_of_cores = 0;\n+\n+const char* const _family_id_intel[ExtendedFamilyIdLength_INTEL] = {\n+  \"8086\/8088\",\n+  \"\",\n+  \"286\",\n+  \"386\",\n+  \"486\",\n+  \"Pentium\",\n+  \"Pentium Pro\",   \/\/or Pentium-M\/Woodcrest depeding on model\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"Pentium 4\"\n+};\n+\n+const char* const _family_id_amd[ExtendedFamilyIdLength_AMD] = {\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"5x86\",\n+  \"K5\/K6\",\n+  \"Athlon\/AthlonXP\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"Opteron\/Athlon64\",\n+  \"Opteron QC\/Phenom\",  \/\/ Barcelona et.al.\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"Zen\"\n+};\n+\/\/ Partially from Intel 64 and IA-32 Architecture Software Developer's Manual,\n+\/\/ September 2013, Vol 3C Table 35-1\n+const char* const _model_id_pentium_pro[] = {\n+  \"\",\n+  \"Pentium Pro\",\n+  \"\",\n+  \"Pentium II model 3\",\n+  \"\",\n+  \"Pentium II model 5\/Xeon\/Celeron\",\n+  \"Celeron\",\n+  \"Pentium III\/Pentium III Xeon\",\n+  \"Pentium III\/Pentium III Xeon\",\n+  \"Pentium M model 9\",    \/\/ Yonah\n+  \"Pentium III, model A\",\n+  \"Pentium III, model B\",\n+  \"\",\n+  \"Pentium M model D\",    \/\/ Dothan\n+  \"\",\n+  \"Core 2\",               \/\/ 0xf Woodcrest\/Conroe\/Merom\/Kentsfield\/Clovertown\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"Celeron\",              \/\/ 0x16 Celeron 65nm\n+  \"Core 2\",               \/\/ 0x17 Penryn \/ Harpertown\n+  \"\",\n+  \"\",\n+  \"Core i7\",              \/\/ 0x1A CPU_MODEL_NEHALEM_EP\n+  \"Atom\",                 \/\/ 0x1B Z5xx series Silverthorn\n+  \"\",\n+  \"Core 2\",               \/\/ 0x1D Dunnington (6-core)\n+  \"Nehalem\",              \/\/ 0x1E CPU_MODEL_NEHALEM\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"Westmere\",             \/\/ 0x25 CPU_MODEL_WESTMERE\n+  \"\",\n+  \"\",\n+  \"\",                     \/\/ 0x28\n+  \"\",\n+  \"Sandy Bridge\",         \/\/ 0x2a \"2nd Generation Intel Core i7, i5, i3\"\n+  \"\",\n+  \"Westmere-EP\",          \/\/ 0x2c CPU_MODEL_WESTMERE_EP\n+  \"Sandy Bridge-EP\",      \/\/ 0x2d CPU_MODEL_SANDYBRIDGE_EP\n+  \"Nehalem-EX\",           \/\/ 0x2e CPU_MODEL_NEHALEM_EX\n+  \"Westmere-EX\",          \/\/ 0x2f CPU_MODEL_WESTMERE_EX\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"Ivy Bridge\",           \/\/ 0x3a\n+  \"\",\n+  \"Haswell\",              \/\/ 0x3c \"4th Generation Intel Core Processor\"\n+  \"\",                     \/\/ 0x3d \"Next Generation Intel Core Processor\"\n+  \"Ivy Bridge-EP\",        \/\/ 0x3e \"Next Generation Intel Xeon Processor E7 Family\"\n+  \"\",                     \/\/ 0x3f \"Future Generation Intel Xeon Processor\"\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"Haswell\",              \/\/ 0x45 \"4th Generation Intel Core Processor\"\n+  \"Haswell\",              \/\/ 0x46 \"4th Generation Intel Core Processor\"\n+  NULL\n+};\n+\n+\/* Brand ID is for back compability\n+ * Newer CPUs uses the extended brand string *\/\n+const char* const _brand_id[] = {\n+  \"\",\n+  \"Celeron processor\",\n+  \"Pentium III processor\",\n+  \"Intel Pentium III Xeon processor\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"Intel Pentium 4 processor\",\n+  NULL\n+};\n+\n+\n+const char* const _feature_edx_id[] = {\n+  \"On-Chip FPU\",\n+  \"Virtual Mode Extensions\",\n+  \"Debugging Extensions\",\n+  \"Page Size Extensions\",\n+  \"Time Stamp Counter\",\n+  \"Model Specific Registers\",\n+  \"Physical Address Extension\",\n+  \"Machine Check Exceptions\",\n+  \"CMPXCHG8B Instruction\",\n+  \"On-Chip APIC\",\n+  \"\",\n+  \"Fast System Call\",\n+  \"Memory Type Range Registers\",\n+  \"Page Global Enable\",\n+  \"Machine Check Architecture\",\n+  \"Conditional Mov Instruction\",\n+  \"Page Attribute Table\",\n+  \"36-bit Page Size Extension\",\n+  \"Processor Serial Number\",\n+  \"CLFLUSH Instruction\",\n+  \"\",\n+  \"Debug Trace Store feature\",\n+  \"ACPI registers in MSR space\",\n+  \"Intel Architecture MMX Technology\",\n+  \"Fast Float Point Save and Restore\",\n+  \"Streaming SIMD extensions\",\n+  \"Streaming SIMD extensions 2\",\n+  \"Self-Snoop\",\n+  \"Hyper Threading\",\n+  \"Thermal Monitor\",\n+  \"\",\n+  \"Pending Break Enable\"\n+};\n+\n+const char* const _feature_extended_edx_id[] = {\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"SYSCALL\/SYSRET\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"Execute Disable Bit\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"RDTSCP\",\n+  \"\",\n+  \"Intel 64 Architecture\",\n+  \"\",\n+  \"\"\n+};\n+\n+const char* const _feature_ecx_id[] = {\n+  \"Streaming SIMD Extensions 3\",\n+  \"PCLMULQDQ\",\n+  \"64-bit DS Area\",\n+  \"MONITOR\/MWAIT instructions\",\n+  \"CPL Qualified Debug Store\",\n+  \"Virtual Machine Extensions\",\n+  \"Safer Mode Extensions\",\n+  \"Enhanced Intel SpeedStep technology\",\n+  \"Thermal Monitor 2\",\n+  \"Supplemental Streaming SIMD Extensions 3\",\n+  \"L1 Context ID\",\n+  \"\",\n+  \"Fused Multiply-Add\",\n+  \"CMPXCHG16B\",\n+  \"xTPR Update Control\",\n+  \"Perfmon and Debug Capability\",\n+  \"\",\n+  \"Process-context identifiers\",\n+  \"Direct Cache Access\",\n+  \"Streaming SIMD extensions 4.1\",\n+  \"Streaming SIMD extensions 4.2\",\n+  \"x2APIC\",\n+  \"MOVBE\",\n+  \"Popcount instruction\",\n+  \"TSC-Deadline\",\n+  \"AESNI\",\n+  \"XSAVE\",\n+  \"OSXSAVE\",\n+  \"AVX\",\n+  \"F16C\",\n+  \"RDRAND\",\n+  \"\"\n+};\n+\n+const char* const _feature_extended_ecx_id[] = {\n+  \"LAHF\/SAHF instruction support\",\n+  \"Core multi-processor legacy mode\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"Advanced Bit Manipulations: LZCNT\",\n+  \"SSE4A: MOVNTSS, MOVNTSD, EXTRQ, INSERTQ\",\n+  \"Misaligned SSE mode\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"\"\n+};\n+\n+void VM_Version::initialize_tsc(void) {\n+  ResourceMark rm;\n+\n+  cpuid_brand_string_stub_blob = BufferBlob::create(\"getCPUIDBrandString_stub\", cpuid_brand_string_stub_size);\n+  if (cpuid_brand_string_stub_blob == NULL) {\n+    vm_exit_during_initialization(\"Unable to allocate getCPUIDBrandString_stub\");\n+  }\n+  CodeBuffer c(cpuid_brand_string_stub_blob);\n+  VM_Version_StubGenerator g(&c);\n+  getCPUIDBrandString_stub = CAST_TO_FN_PTR(getCPUIDBrandString_stub_t,\n+                                   g.generate_getCPUIDBrandString());\n+}\n+\n+const char* VM_Version::cpu_model_description(void) {\n+  uint32_t cpu_family = extended_cpu_family();\n+  uint32_t cpu_model = extended_cpu_model();\n+  const char* model = NULL;\n+\n+  if (cpu_family == CPU_FAMILY_PENTIUMPRO) {\n+    for (uint32_t i = 0; i <= cpu_model; i++) {\n+      model = _model_id_pentium_pro[i];\n+      if (model == NULL) {\n+        break;\n+      }\n+    }\n+  }\n+  return model;\n+}\n+\n+const char* VM_Version::cpu_brand_string(void) {\n+  if (_cpu_brand_string == NULL) {\n+    _cpu_brand_string = NEW_C_HEAP_ARRAY_RETURN_NULL(char, CPU_EBS_MAX_LENGTH, mtInternal);\n+    if (NULL == _cpu_brand_string) {\n+      return NULL;\n+    }\n+    int ret_val = cpu_extended_brand_string(_cpu_brand_string, CPU_EBS_MAX_LENGTH);\n+    if (ret_val != OS_OK) {\n+      FREE_C_HEAP_ARRAY(char, _cpu_brand_string);\n+      _cpu_brand_string = NULL;\n+    }\n+  }\n+  return _cpu_brand_string;\n+}\n+\n+const char* VM_Version::cpu_brand(void) {\n+  const char*  brand  = NULL;\n+\n+  if ((_cpuid_info.std_cpuid1_ebx.value & 0xFF) > 0) {\n+    int brand_num = _cpuid_info.std_cpuid1_ebx.value & 0xFF;\n+    brand = _brand_id[0];\n+    for (int i = 0; brand != NULL && i <= brand_num; i += 1) {\n+      brand = _brand_id[i];\n+    }\n+  }\n+  return brand;\n+}\n+\n+bool VM_Version::cpu_is_em64t(void) {\n+  return ((_cpuid_info.ext_cpuid1_edx.value & INTEL64_FLAG) == INTEL64_FLAG);\n+}\n+\n+bool VM_Version::is_netburst(void) {\n+  return (is_intel() && (extended_cpu_family() == CPU_FAMILY_PENTIUM_4));\n+}\n+\n+bool VM_Version::supports_tscinv_ext(void) {\n+  if (!supports_tscinv_bit()) {\n+    return false;\n+  }\n+\n+  if (is_intel()) {\n+    return true;\n+  }\n+\n+  if (is_amd()) {\n+    return !is_amd_Barcelona();\n+  }\n+\n+  if (is_hygon()) {\n+    return true;\n+  }\n+\n+  return false;\n+}\n+\n+void VM_Version::resolve_cpu_information_details(void) {\n+\n+  \/\/ in future we want to base this information on proper cpu\n+  \/\/ and cache topology enumeration such as:\n+  \/\/ Intel 64 Architecture Processor Topology Enumeration\n+  \/\/ which supports system cpu and cache topology enumeration\n+  \/\/ either using 2xAPICIDs or initial APICIDs\n+\n+  \/\/ currently only rough cpu information estimates\n+  \/\/ which will not necessarily reflect the exact configuration of the system\n+\n+  \/\/ this is the number of logical hardware threads\n+  \/\/ visible to the operating system\n+  _no_of_threads = os::processor_count();\n+\n+  \/\/ find out number of threads per cpu package\n+  int threads_per_package = threads_per_core() * cores_per_cpu();\n+\n+  \/\/ use amount of threads visible to the process in order to guess number of sockets\n+  _no_of_sockets = _no_of_threads \/ threads_per_package;\n+\n+  \/\/ process might only see a subset of the total number of threads\n+  \/\/ from a single processor package. Virtualization\/resource management for example.\n+  \/\/ If so then just write a hard 1 as num of pkgs.\n+  if (0 == _no_of_sockets) {\n+    _no_of_sockets = 1;\n+  }\n+\n+  \/\/ estimate the number of cores\n+  _no_of_cores = cores_per_cpu() * _no_of_sockets;\n+}\n+\n+\n+const char* VM_Version::cpu_family_description(void) {\n+  int cpu_family_id = extended_cpu_family();\n+  if (is_amd()) {\n+    if (cpu_family_id < ExtendedFamilyIdLength_AMD) {\n+      return _family_id_amd[cpu_family_id];\n+    }\n+  }\n+  if (is_intel()) {\n+    if (cpu_family_id == CPU_FAMILY_PENTIUMPRO) {\n+      return cpu_model_description();\n+    }\n+    if (cpu_family_id < ExtendedFamilyIdLength_INTEL) {\n+      return _family_id_intel[cpu_family_id];\n+    }\n+  }\n+  if (is_hygon()) {\n+    return \"Dhyana\";\n+  }\n+  return \"Unknown x86\";\n+}\n+\n+int VM_Version::cpu_type_description(char* const buf, size_t buf_len) {\n+  assert(buf != NULL, \"buffer is NULL!\");\n+  assert(buf_len >= CPU_TYPE_DESC_BUF_SIZE, \"buffer len should at least be == CPU_TYPE_DESC_BUF_SIZE!\");\n+\n+  const char* cpu_type = NULL;\n+  const char* x64 = NULL;\n+\n+  if (is_intel()) {\n+    cpu_type = \"Intel\";\n+    x64 = cpu_is_em64t() ? \" Intel64\" : \"\";\n+  } else if (is_amd()) {\n+    cpu_type = \"AMD\";\n+    x64 = cpu_is_em64t() ? \" AMD64\" : \"\";\n+  } else if (is_hygon()) {\n+    cpu_type = \"Hygon\";\n+    x64 = cpu_is_em64t() ? \" AMD64\" : \"\";\n+  } else {\n+    cpu_type = \"Unknown x86\";\n+    x64 = cpu_is_em64t() ? \" x86_64\" : \"\";\n+  }\n+\n+  jio_snprintf(buf, buf_len, \"%s %s%s SSE SSE2%s%s%s%s%s%s%s%s\",\n+    cpu_type,\n+    cpu_family_description(),\n+    supports_ht() ? \" (HT)\" : \"\",\n+    supports_sse3() ? \" SSE3\" : \"\",\n+    supports_ssse3() ? \" SSSE3\" : \"\",\n+    supports_sse4_1() ? \" SSE4.1\" : \"\",\n+    supports_sse4_2() ? \" SSE4.2\" : \"\",\n+    supports_sse4a() ? \" SSE4A\" : \"\",\n+    is_netburst() ? \" Netburst\" : \"\",\n+    is_intel_family_core() ? \" Core\" : \"\",\n+    x64);\n+\n+  return OS_OK;\n+}\n+\n+int VM_Version::cpu_extended_brand_string(char* const buf, size_t buf_len) {\n+  assert(buf != NULL, \"buffer is NULL!\");\n+  assert(buf_len >= CPU_EBS_MAX_LENGTH, \"buffer len should at least be == CPU_EBS_MAX_LENGTH!\");\n+  assert(getCPUIDBrandString_stub != NULL, \"not initialized\");\n+\n+  \/\/ invoke newly generated asm code to fetch CPU Brand String\n+  getCPUIDBrandString_stub(&_cpuid_info);\n+\n+  \/\/ fetch results into buffer\n+  *((uint32_t*) &buf[0])  = _cpuid_info.proc_name_0;\n+  *((uint32_t*) &buf[4])  = _cpuid_info.proc_name_1;\n+  *((uint32_t*) &buf[8])  = _cpuid_info.proc_name_2;\n+  *((uint32_t*) &buf[12]) = _cpuid_info.proc_name_3;\n+  *((uint32_t*) &buf[16]) = _cpuid_info.proc_name_4;\n+  *((uint32_t*) &buf[20]) = _cpuid_info.proc_name_5;\n+  *((uint32_t*) &buf[24]) = _cpuid_info.proc_name_6;\n+  *((uint32_t*) &buf[28]) = _cpuid_info.proc_name_7;\n+  *((uint32_t*) &buf[32]) = _cpuid_info.proc_name_8;\n+  *((uint32_t*) &buf[36]) = _cpuid_info.proc_name_9;\n+  *((uint32_t*) &buf[40]) = _cpuid_info.proc_name_10;\n+  *((uint32_t*) &buf[44]) = _cpuid_info.proc_name_11;\n+\n+  return OS_OK;\n+}\n+\n+size_t VM_Version::cpu_write_support_string(char* const buf, size_t buf_len) {\n+  guarantee(buf != NULL, \"buffer is NULL!\");\n+  guarantee(buf_len > 0, \"buffer len not enough!\");\n+\n+  unsigned int flag = 0;\n+  unsigned int fi = 0;\n+  size_t       written = 0;\n+  const char*  prefix = \"\";\n+\n+#define WRITE_TO_BUF(string)                                                          \\\n+  {                                                                                   \\\n+    int res = jio_snprintf(&buf[written], buf_len - written, \"%s%s\", prefix, string); \\\n+    if (res < 0) {                                                                    \\\n+      return buf_len - 1;                                                             \\\n+    }                                                                                 \\\n+    written += res;                                                                   \\\n+    if (prefix[0] == '\\0') {                                                          \\\n+      prefix = \", \";                                                                  \\\n+    }                                                                                 \\\n+  }\n+\n+  for (flag = 1, fi = 0; flag <= 0x20000000 ; flag <<= 1, fi++) {\n+    if (flag == HTT_FLAG && (((_cpuid_info.std_cpuid1_ebx.value >> 16) & 0xff) <= 1)) {\n+      continue; \/* no hyperthreading *\/\n+    } else if (flag == SEP_FLAG && (cpu_family() == CPU_FAMILY_PENTIUMPRO && ((_cpuid_info.std_cpuid1_eax.value & 0xff) < 0x33))) {\n+      continue; \/* no fast system call *\/\n+    }\n+    if ((_cpuid_info.std_cpuid1_edx.value & flag) && strlen(_feature_edx_id[fi]) > 0) {\n+      WRITE_TO_BUF(_feature_edx_id[fi]);\n+    }\n+  }\n+\n+  for (flag = 1, fi = 0; flag <= 0x20000000; flag <<= 1, fi++) {\n+    if ((_cpuid_info.std_cpuid1_ecx.value & flag) && strlen(_feature_ecx_id[fi]) > 0) {\n+      WRITE_TO_BUF(_feature_ecx_id[fi]);\n+    }\n+  }\n+\n+  for (flag = 1, fi = 0; flag <= 0x20000000 ; flag <<= 1, fi++) {\n+    if ((_cpuid_info.ext_cpuid1_ecx.value & flag) && strlen(_feature_extended_ecx_id[fi]) > 0) {\n+      WRITE_TO_BUF(_feature_extended_ecx_id[fi]);\n+    }\n+  }\n+\n+  for (flag = 1, fi = 0; flag <= 0x20000000; flag <<= 1, fi++) {\n+    if ((_cpuid_info.ext_cpuid1_edx.value & flag) && strlen(_feature_extended_edx_id[fi]) > 0) {\n+      WRITE_TO_BUF(_feature_extended_edx_id[fi]);\n+    }\n+  }\n+\n+  if (supports_tscinv_bit()) {\n+      WRITE_TO_BUF(\"Invariant TSC\");\n+  }\n+\n+  return written;\n+}\n+\n+\/**\n+ * Write a detailed description of the cpu to a given buffer, including\n+ * feature set.\n+ *\/\n+int VM_Version::cpu_detailed_description(char* const buf, size_t buf_len) {\n+  assert(buf != NULL, \"buffer is NULL!\");\n+  assert(buf_len >= CPU_DETAILED_DESC_BUF_SIZE, \"buffer len should at least be == CPU_DETAILED_DESC_BUF_SIZE!\");\n+\n+  static const char* unknown = \"<unknown>\";\n+  char               vendor_id[VENDOR_LENGTH];\n+  const char*        family = NULL;\n+  const char*        model = NULL;\n+  const char*        brand = NULL;\n+  int                outputLen = 0;\n+\n+  family = cpu_family_description();\n+  if (family == NULL) {\n+    family = unknown;\n+  }\n+\n+  model = cpu_model_description();\n+  if (model == NULL) {\n+    model = unknown;\n+  }\n+\n+  brand = cpu_brand_string();\n+\n+  if (brand == NULL) {\n+    brand = cpu_brand();\n+    if (brand == NULL) {\n+      brand = unknown;\n+    }\n+  }\n+\n+  *((uint32_t*) &vendor_id[0]) = _cpuid_info.std_vendor_name_0;\n+  *((uint32_t*) &vendor_id[4]) = _cpuid_info.std_vendor_name_2;\n+  *((uint32_t*) &vendor_id[8]) = _cpuid_info.std_vendor_name_1;\n+  vendor_id[VENDOR_LENGTH-1] = '\\0';\n+\n+  outputLen = jio_snprintf(buf, buf_len, \"Brand: %s, Vendor: %s\\n\"\n+    \"Family: %s (0x%x), Model: %s (0x%x), Stepping: 0x%x\\n\"\n+    \"Ext. family: 0x%x, Ext. model: 0x%x, Type: 0x%x, Signature: 0x%8.8x\\n\"\n+    \"Features: ebx: 0x%8.8x, ecx: 0x%8.8x, edx: 0x%8.8x\\n\"\n+    \"Ext. features: eax: 0x%8.8x, ebx: 0x%8.8x, ecx: 0x%8.8x, edx: 0x%8.8x\\n\"\n+    \"Supports: \",\n+    brand,\n+    vendor_id,\n+    family,\n+    extended_cpu_family(),\n+    model,\n+    extended_cpu_model(),\n+    cpu_stepping(),\n+    _cpuid_info.std_cpuid1_eax.bits.ext_family,\n+    _cpuid_info.std_cpuid1_eax.bits.ext_model,\n+    _cpuid_info.std_cpuid1_eax.bits.proc_type,\n+    _cpuid_info.std_cpuid1_eax.value,\n+    _cpuid_info.std_cpuid1_ebx.value,\n+    _cpuid_info.std_cpuid1_ecx.value,\n+    _cpuid_info.std_cpuid1_edx.value,\n+    _cpuid_info.ext_cpuid1_eax,\n+    _cpuid_info.ext_cpuid1_ebx,\n+    _cpuid_info.ext_cpuid1_ecx,\n+    _cpuid_info.ext_cpuid1_edx);\n+\n+  if (outputLen < 0 || (size_t) outputLen >= buf_len - 1) {\n+    if (buf_len > 0) { buf[buf_len-1] = '\\0'; }\n+    return OS_ERR;\n+  }\n+\n+  cpu_write_support_string(&buf[outputLen], buf_len - outputLen);\n+\n+  return OS_OK;\n+}\n+\n+\n+\/\/ Fill in Abstract_VM_Version statics\n+void VM_Version::initialize_cpu_information() {\n+  assert(!_initialized, \"shouldn't be initialized yet\");\n+  resolve_cpu_information_details();\n+\n+  \/\/ initialize cpu_name and cpu_desc\n+  cpu_type_description(_cpu_name, CPU_TYPE_DESC_BUF_SIZE);\n+  cpu_detailed_description(_cpu_desc, CPU_DETAILED_DESC_BUF_SIZE);\n+  _initialized = true;\n+}\n+\n+\/**\n+ *  For information about extracting the frequency from the cpu brand string, please see:\n+ *\n+ *    Intel Processor Identification and the CPUID Instruction\n+ *    Application Note 485\n+ *    May 2012\n+ *\n+ * The return value is the frequency in Hz.\n+ *\/\n+int64_t VM_Version::max_qualified_cpu_freq_from_brand_string(void) {\n+  const char* const brand_string = cpu_brand_string();\n+  if (brand_string == NULL) {\n+    return 0;\n+  }\n+  const int64_t MEGA = 1000000;\n+  int64_t multiplier = 0;\n+  int64_t frequency = 0;\n+  uint8_t idx = 0;\n+  \/\/ The brand string buffer is at most 48 bytes.\n+  \/\/ -2 is to prevent buffer overrun when looking for y in yHz, as z is +2 from y.\n+  for (; idx < 48-2; ++idx) {\n+    \/\/ Format is either \"x.xxyHz\" or \"xxxxyHz\", where y=M, G, T and x are digits.\n+    \/\/ Search brand string for \"yHz\" where y is M, G, or T.\n+    if (brand_string[idx+1] == 'H' && brand_string[idx+2] == 'z') {\n+      if (brand_string[idx] == 'M') {\n+        multiplier = MEGA;\n+      } else if (brand_string[idx] == 'G') {\n+        multiplier = MEGA * 1000;\n+      } else if (brand_string[idx] == 'T') {\n+        multiplier = MEGA * MEGA;\n+      }\n+      break;\n+    }\n+  }\n+  if (multiplier > 0) {\n+    \/\/ Compute freqency (in Hz) from brand string.\n+    if (brand_string[idx-3] == '.') { \/\/ if format is \"x.xx\"\n+      frequency =  (brand_string[idx-4] - '0') * multiplier;\n+      frequency += (brand_string[idx-2] - '0') * multiplier \/ 10;\n+      frequency += (brand_string[idx-1] - '0') * multiplier \/ 100;\n+    } else { \/\/ format is \"xxxx\"\n+      frequency =  (brand_string[idx-4] - '0') * 1000;\n+      frequency += (brand_string[idx-3] - '0') * 100;\n+      frequency += (brand_string[idx-2] - '0') * 10;\n+      frequency += (brand_string[idx-1] - '0');\n+      frequency *= multiplier;\n+    }\n+  }\n+  return frequency;\n+}\n+\n+\n+int64_t VM_Version::maximum_qualified_cpu_frequency(void) {\n+  if (_max_qualified_cpu_frequency == 0) {\n+    _max_qualified_cpu_frequency = max_qualified_cpu_freq_from_brand_string();\n+  }\n+  return _max_qualified_cpu_frequency;\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":907,"deletions":0,"binary":false,"changes":907,"status":"modified"},{"patch":"@@ -374,1 +374,1 @@\n-enum Extended_Family {\n+  enum Extended_Family {\n@@ -1056,0 +1056,39 @@\n+\n+  static const char* cpu_family_description(void);\n+  static const char* cpu_model_description(void);\n+  static const char* cpu_brand(void);\n+  static const char* cpu_brand_string(void);\n+\n+  static int cpu_type_description(char* const buf, size_t buf_len);\n+  static int cpu_detailed_description(char* const buf, size_t buf_len);\n+  static int cpu_extended_brand_string(char* const buf, size_t buf_len);\n+\n+  static bool cpu_is_em64t(void);\n+  static bool is_netburst(void);\n+\n+  \/\/ Returns bytes written excluding termninating null byte.\n+  static size_t cpu_write_support_string(char* const buf, size_t buf_len);\n+  static void resolve_cpu_information_details(void);\n+  static int64_t max_qualified_cpu_freq_from_brand_string(void);\n+\n+ public:\n+  \/\/ Offsets for cpuid asm stub brand string\n+  static ByteSize proc_name_0_offset() { return byte_offset_of(CpuidInfo, proc_name_0); }\n+  static ByteSize proc_name_1_offset() { return byte_offset_of(CpuidInfo, proc_name_1); }\n+  static ByteSize proc_name_2_offset() { return byte_offset_of(CpuidInfo, proc_name_2); }\n+  static ByteSize proc_name_3_offset() { return byte_offset_of(CpuidInfo, proc_name_3); }\n+  static ByteSize proc_name_4_offset() { return byte_offset_of(CpuidInfo, proc_name_4); }\n+  static ByteSize proc_name_5_offset() { return byte_offset_of(CpuidInfo, proc_name_5); }\n+  static ByteSize proc_name_6_offset() { return byte_offset_of(CpuidInfo, proc_name_6); }\n+  static ByteSize proc_name_7_offset() { return byte_offset_of(CpuidInfo, proc_name_7); }\n+  static ByteSize proc_name_8_offset() { return byte_offset_of(CpuidInfo, proc_name_8); }\n+  static ByteSize proc_name_9_offset() { return byte_offset_of(CpuidInfo, proc_name_9); }\n+  static ByteSize proc_name_10_offset() { return byte_offset_of(CpuidInfo, proc_name_10); }\n+  static ByteSize proc_name_11_offset() { return byte_offset_of(CpuidInfo, proc_name_11); }\n+\n+  static int64_t maximum_qualified_cpu_frequency(void);\n+\n+  static bool supports_tscinv_ext(void);\n+\n+  static void initialize_tsc();\n+  static void initialize_cpu_information(void);\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.hpp","additions":40,"deletions":1,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -1,90 +0,0 @@\n-\/*\n- * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"memory\/allocation.hpp\"\n-#include \"memory\/allocation.inline.hpp\"\n-#include \"runtime\/os.hpp\"\n-#include \"vm_version_ext_zero.hpp\"\n-\n-\/\/ VM_Version_Ext statics\n-int VM_Version_Ext::_no_of_threads = 0;\n-int VM_Version_Ext::_no_of_cores = 0;\n-int VM_Version_Ext::_no_of_sockets = 0;\n-bool VM_Version_Ext::_initialized = false;\n-char VM_Version_Ext::_cpu_name[CPU_TYPE_DESC_BUF_SIZE] = {0};\n-char VM_Version_Ext::_cpu_desc[CPU_DETAILED_DESC_BUF_SIZE] = {0};\n-\n-void VM_Version_Ext::initialize_cpu_information(void) {\n-  \/\/ do nothing if cpu info has been initialized\n-  if (_initialized) {\n-    return;\n-  }\n-\n-  int core_id = -1;\n-  int chip_id = -1;\n-  int len = 0;\n-  char* src_string = NULL;\n-\n-  _no_of_cores  = os::processor_count();\n-  _no_of_threads = _no_of_cores;\n-  _no_of_sockets = _no_of_cores;\n-  snprintf(_cpu_name, CPU_TYPE_DESC_BUF_SIZE - 1, \"Zero VM\");\n-  snprintf(_cpu_desc, CPU_DETAILED_DESC_BUF_SIZE, \"%s\", _features_string);\n-  _initialized = true;\n-}\n-\n-int VM_Version_Ext::number_of_threads(void) {\n-  initialize_cpu_information();\n-  return _no_of_threads;\n-}\n-\n-int VM_Version_Ext::number_of_cores(void) {\n-  initialize_cpu_information();\n-  return _no_of_cores;\n-}\n-\n-int VM_Version_Ext::number_of_sockets(void) {\n-  initialize_cpu_information();\n-  return _no_of_sockets;\n-}\n-\n-const char* VM_Version_Ext::cpu_name(void) {\n-  initialize_cpu_information();\n-  char* tmp = NEW_C_HEAP_ARRAY_RETURN_NULL(char, CPU_TYPE_DESC_BUF_SIZE, mtTracing);\n-  if (NULL == tmp) {\n-    return NULL;\n-  }\n-  strncpy(tmp, _cpu_name, CPU_TYPE_DESC_BUF_SIZE);\n-  return tmp;\n-}\n-\n-const char* VM_Version_Ext::cpu_description(void) {\n-  initialize_cpu_information();\n-  char* tmp = NEW_C_HEAP_ARRAY_RETURN_NULL(char, CPU_DETAILED_DESC_BUF_SIZE, mtTracing);\n-  if (NULL == tmp) {\n-    return NULL;\n-  }\n-  strncpy(tmp, _cpu_desc, CPU_DETAILED_DESC_BUF_SIZE);\n-  return tmp;\n-}\n","filename":"src\/hotspot\/cpu\/zero\/vm_version_ext_zero.cpp","additions":0,"deletions":90,"binary":false,"changes":90,"status":"deleted"},{"patch":"@@ -1,54 +0,0 @@\n-\/*\n- * Copyright (c) 2013, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef CPU_ZERO_VM_VERSION_EXT_ZERO_HPP\n-#define CPU_ZERO_VM_VERSION_EXT_ZERO_HPP\n-\n-#include \"runtime\/vm_version.hpp\"\n-#include \"utilities\/macros.hpp\"\n-\n-class VM_Version_Ext : public VM_Version {\n- private:\n-  static const size_t      CPU_TYPE_DESC_BUF_SIZE = 256;\n-  static const size_t      CPU_DETAILED_DESC_BUF_SIZE = 4096;\n-\n-  static int               _no_of_threads;\n-  static int               _no_of_cores;\n-  static int               _no_of_sockets;\n-  static bool              _initialized;\n-  static char              _cpu_name[CPU_TYPE_DESC_BUF_SIZE];\n-  static char              _cpu_desc[CPU_DETAILED_DESC_BUF_SIZE];\n-\n- public:\n-  static int number_of_threads(void);\n-  static int number_of_cores(void);\n-  static int number_of_sockets(void);\n-\n-  static const char* cpu_name(void);\n-  static const char* cpu_description(void);\n-  static void initialize_cpu_information(void);\n-\n-};\n-\n-#endif \/\/ CPU_ZERO_VM_VERSION_EXT_ZERO_HPP\n","filename":"src\/hotspot\/cpu\/zero\/vm_version_ext_zero.hpp","additions":0,"deletions":54,"binary":false,"changes":54,"status":"deleted"},{"patch":"@@ -124,0 +124,14 @@\n+\n+void VM_Version::initialize_cpu_information(void) {\n+  \/\/ do nothing if cpu info has been initialized\n+  if (_initialized) {\n+    return;\n+  }\n+\n+  _no_of_cores  = os::processor_count();\n+  _no_of_threads = _no_of_cores;\n+  _no_of_sockets = _no_of_cores;\n+  snprintf(_cpu_name, CPU_TYPE_DESC_BUF_SIZE - 1, \"Zero VM\");\n+  snprintf(_cpu_desc, CPU_DETAILED_DESC_BUF_SIZE, \"%s\", _features_string);\n+  _initialized = true;\n+}\n","filename":"src\/hotspot\/cpu\/zero\/vm_version_zero.cpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,2 @@\n+\n+  static void initialize_cpu_information(void);\n","filename":"src\/hotspot\/cpu\/zero\/vm_version_zero.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+#include \"runtime\/vm_version.hpp\"\n@@ -33,2 +34,0 @@\n-#include CPU_HEADER(vm_version_ext)\n-\n@@ -866,5 +865,6 @@\n-  _cpu_info->set_number_of_hardware_threads(VM_Version_Ext::number_of_threads());\n-  _cpu_info->set_number_of_cores(VM_Version_Ext::number_of_cores());\n-  _cpu_info->set_number_of_sockets(VM_Version_Ext::number_of_sockets());\n-  _cpu_info->set_cpu_name(VM_Version_Ext::cpu_name());\n-  _cpu_info->set_cpu_description(VM_Version_Ext::cpu_description());\n+  VM_Version::initialize_cpu_information();\n+  _cpu_info->set_number_of_hardware_threads(VM_Version::number_of_threads());\n+  _cpu_info->set_number_of_cores(VM_Version::number_of_cores());\n+  _cpu_info->set_number_of_sockets(VM_Version::number_of_sockets());\n+  _cpu_info->set_cpu_name(VM_Version::cpu_name());\n+  _cpu_info->set_cpu_description(VM_Version::cpu_description());\n","filename":"src\/hotspot\/os\/aix\/os_perf_aix.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"runtime\/vm_version.hpp\"\n@@ -30,1 +31,0 @@\n-#include CPU_HEADER(vm_version_ext)\n@@ -374,5 +374,6 @@\n-  _cpu_info->set_number_of_hardware_threads(VM_Version_Ext::number_of_threads());\n-  _cpu_info->set_number_of_cores(VM_Version_Ext::number_of_cores());\n-  _cpu_info->set_number_of_sockets(VM_Version_Ext::number_of_sockets());\n-  _cpu_info->set_cpu_name(VM_Version_Ext::cpu_name());\n-  _cpu_info->set_cpu_description(VM_Version_Ext::cpu_description());\n+  VM_Version::initialize_cpu_information();\n+  _cpu_info->set_number_of_hardware_threads(VM_Version::number_of_threads());\n+  _cpu_info->set_number_of_cores(VM_Version::number_of_cores());\n+  _cpu_info->set_number_of_sockets(VM_Version::number_of_sockets());\n+  _cpu_info->set_cpu_name(VM_Version::cpu_name());\n+  _cpu_info->set_cpu_description(VM_Version::cpu_description());\n","filename":"src\/hotspot\/os\/bsd\/os_perf_bsd.cpp","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+#include \"runtime\/vm_version.hpp\"\n@@ -33,2 +34,0 @@\n-#include CPU_HEADER(vm_version_ext)\n-\n@@ -930,5 +929,6 @@\n-  _cpu_info->set_number_of_hardware_threads(VM_Version_Ext::number_of_threads());\n-  _cpu_info->set_number_of_cores(VM_Version_Ext::number_of_cores());\n-  _cpu_info->set_number_of_sockets(VM_Version_Ext::number_of_sockets());\n-  _cpu_info->set_cpu_name(VM_Version_Ext::cpu_name());\n-  _cpu_info->set_cpu_description(VM_Version_Ext::cpu_description());\n+  VM_Version::initialize_cpu_information();\n+  _cpu_info->set_number_of_hardware_threads(VM_Version::number_of_threads());\n+  _cpu_info->set_number_of_cores(VM_Version::number_of_cores());\n+  _cpu_info->set_number_of_sockets(VM_Version::number_of_sockets());\n+  _cpu_info->set_cpu_name(VM_Version::cpu_name());\n+  _cpu_info->set_cpu_description(VM_Version::cpu_description());\n","filename":"src\/hotspot\/os\/linux\/os_perf_linux.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"runtime\/vm_version.hpp\"\n@@ -37,1 +38,0 @@\n-#include CPU_HEADER(vm_version_ext)\n@@ -1437,5 +1437,6 @@\n-  _cpu_info->set_number_of_hardware_threads(VM_Version_Ext::number_of_threads());\n-  _cpu_info->set_number_of_cores(VM_Version_Ext::number_of_cores());\n-  _cpu_info->set_number_of_sockets(VM_Version_Ext::number_of_sockets());\n-  _cpu_info->set_cpu_name(VM_Version_Ext::cpu_name());\n-  _cpu_info->set_cpu_description(VM_Version_Ext::cpu_description());\n+  VM_Version::initialize_cpu_information();\n+  _cpu_info->set_number_of_hardware_threads(VM_Version::number_of_threads());\n+  _cpu_info->set_number_of_cores(VM_Version::number_of_cores());\n+  _cpu_info->set_number_of_sockets(VM_Version::number_of_sockets());\n+  _cpu_info->set_cpu_name(VM_Version::cpu_name());\n+  _cpu_info->set_cpu_description(VM_Version::cpu_description());\n","filename":"src\/hotspot\/os\/windows\/os_perf_windows.cpp","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -3651,2 +3651,2 @@\n-    const char* release = Abstract_VM_Version::vm_release();\n-    const char* dbg_level = Abstract_VM_Version::jdk_debug_level();\n+    const char* release = VM_Version::vm_release();\n+    const char* dbg_level = VM_Version::jdk_debug_level();\n@@ -3657,4 +3657,4 @@\n-    seed += (jlong)Abstract_VM_Version::vm_major_version();\n-    seed += (jlong)Abstract_VM_Version::vm_minor_version();\n-    seed += (jlong)Abstract_VM_Version::vm_security_version();\n-    seed += (jlong)Abstract_VM_Version::vm_patch_version();\n+    seed += (jlong)VM_Version::vm_major_version();\n+    seed += (jlong)VM_Version::vm_minor_version();\n+    seed += (jlong)VM_Version::vm_security_version();\n+    seed += (jlong)VM_Version::vm_patch_version();\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -361,1 +361,1 @@\n-      if (major < 13 || major > Abstract_VM_Version::vm_major_version()) {\n+      if (major < 13 || major > VM_Version::vm_major_version()) {\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -340,0 +340,43 @@\n+\n+\/\/ Abstract_VM_Version statics\n+int   Abstract_VM_Version::_no_of_threads = 0;\n+int   Abstract_VM_Version::_no_of_cores = 0;\n+int   Abstract_VM_Version::_no_of_sockets = 0;\n+bool  Abstract_VM_Version::_initialized = false;\n+char  Abstract_VM_Version::_cpu_name[CPU_TYPE_DESC_BUF_SIZE] = {0};\n+char  Abstract_VM_Version::_cpu_desc[CPU_DETAILED_DESC_BUF_SIZE] = {0};\n+\n+int Abstract_VM_Version::number_of_threads(void) {\n+  assert(_initialized, \"should be initialized\");\n+  return _no_of_threads;\n+}\n+\n+int Abstract_VM_Version::number_of_cores(void) {\n+  assert(_initialized, \"should be initialized\");\n+  return _no_of_cores;\n+}\n+\n+int Abstract_VM_Version::number_of_sockets(void) {\n+  assert(_initialized, \"should be initialized\");\n+  return _no_of_sockets;\n+}\n+\n+const char* Abstract_VM_Version::cpu_name(void) {\n+  assert(_initialized, \"should be initialized\");\n+  char* tmp = NEW_C_HEAP_ARRAY_RETURN_NULL(char, CPU_TYPE_DESC_BUF_SIZE, mtTracing);\n+  if (NULL == tmp) {\n+    return NULL;\n+  }\n+  strncpy(tmp, _cpu_name, CPU_TYPE_DESC_BUF_SIZE);\n+  return tmp;\n+}\n+\n+const char* Abstract_VM_Version::cpu_description(void) {\n+  assert(_initialized, \"should be initialized\");\n+  char* tmp = NEW_C_HEAP_ARRAY_RETURN_NULL(char, CPU_DETAILED_DESC_BUF_SIZE, mtTracing);\n+  if (NULL == tmp) {\n+    return NULL;\n+  }\n+  strncpy(tmp, _cpu_desc, CPU_DETAILED_DESC_BUF_SIZE);\n+  return tmp;\n+}\n","filename":"src\/hotspot\/share\/runtime\/abstract_vm_version.cpp","additions":43,"deletions":0,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -189,0 +189,20 @@\n+\n+ protected:\n+  \/\/ VM_Version statics\n+  static const size_t      CPU_TYPE_DESC_BUF_SIZE = 256;\n+  static const size_t      CPU_DETAILED_DESC_BUF_SIZE = 4096;\n+\n+  static int   _no_of_threads;\n+  static int   _no_of_cores;\n+  static int   _no_of_sockets;\n+  static bool  _initialized;\n+  static char  _cpu_name[CPU_TYPE_DESC_BUF_SIZE];\n+  static char  _cpu_desc[CPU_DETAILED_DESC_BUF_SIZE];\n+\n+ public:\n+  static int number_of_threads(void);\n+  static int number_of_cores(void);\n+  static int number_of_sockets(void);\n+\n+  static const char* cpu_name(void);\n+  static const char* cpu_description(void);\n","filename":"src\/hotspot\/share\/runtime\/abstract_vm_version.hpp","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"}]}