{"files":[{"patch":"@@ -737,1 +737,1 @@\n-              if (!wq.member(u) && !u->as_Proj()->is_uncommon_trap_proj(Deoptimization::Reason_none)) {\n+              if (!wq.member(u) && !u->as_Proj()->is_uncommon_trap_proj()) {\n@@ -746,1 +746,1 @@\n-        if (c->as_Proj()->is_uncommon_trap_if_pattern(Deoptimization::Reason_none) != nullptr) {\n+        if (c->as_Proj()->is_uncommon_trap_if_pattern() != nullptr) {\n@@ -1141,1 +1141,1 @@\n-            u->in(0)->as_Proj()->is_uncommon_trap_if_pattern(Deoptimization::Reason_none) &&\n+            u->in(0)->as_Proj()->is_uncommon_trap_if_pattern() &&\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahSupport.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -464,0 +464,1 @@\n+  bool _useless; \/\/ If the associated loop dies, this parse predicate becomes useless and can be cleaned up by Value().\n@@ -465,1 +466,1 @@\n-  ParsePredicateNode(Node* control, Node* bol, Deoptimization::DeoptReason deopt_reason);\n+  ParsePredicateNode(Node* control, Deoptimization::DeoptReason deopt_reason, PhaseGVN* gvn);\n@@ -473,0 +474,12 @@\n+  bool is_useless() const {\n+    return _useless;\n+  }\n+\n+  void mark_useless() {\n+    _useless = true;\n+  }\n+\n+  void mark_useful() {\n+    _useless = false;\n+  }\n+\n@@ -475,0 +488,5 @@\n+  Node* Ideal(PhaseGVN* phase, bool can_reshape) {\n+    return nullptr; \/\/ Don't optimize\n+  }\n+\n+  const Type* Value(PhaseGVN* phase) const;\n","filename":"src\/hotspot\/share\/opto\/cfgnode.hpp","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -363,1 +363,2 @@\n-void Compile::remove_useless_nodes(GrowableArray<Node*>& node_list, Unique_Node_List& useful) {\n+template<typename N, ENABLE_IF_SDEFN(std::is_base_of<Node, N>::value)>\n+void Compile::remove_useless_nodes(GrowableArray<N*>& node_list, Unique_Node_List& useful) {\n@@ -365,2 +366,2 @@\n-    Node* n = node_list.at(i);\n-    if (!useful.member(n)) {\n+    N* node = node_list.at(i);\n+    if (!useful.member(node)) {\n@@ -392,0 +393,3 @@\n+  if (dead->is_ParsePredicate()) {\n+    remove_parse_predicate(dead->as_ParsePredicate());\n+  }\n@@ -439,1 +443,1 @@\n-  remove_useless_nodes(_parse_predicate_opaqs, useful); \/\/ remove useless Parse Predicate opaque nodes\n+  remove_useless_nodes(_parse_predicates,   useful); \/\/ remove useless Parse Predicate nodes\n@@ -634,1 +638,1 @@\n-                  _parse_predicate_opaqs (comp_arena(), 8, 0, nullptr),\n+                  _parse_predicates  (comp_arena(), 8, 0, nullptr),\n@@ -1810,3 +1814,3 @@\n-\/\/ Remove the opaque nodes that protect the Parse Predicates so that all unused\n-\/\/ checks and uncommon_traps will be eliminated from the ideal graph.\n-void Compile::cleanup_parse_predicates(PhaseIterGVN& igvn) const {\n+\/\/ Mark all ParsePredicateNodes as useless. They will later be removed from the graph in IGVN together with their\n+\/\/ uncommon traps if no Runtime Predicates were created from the Parse Predicates.\n+void Compile::mark_parse_predicate_nodes_useless(PhaseIterGVN& igvn) {\n@@ -1816,4 +1820,4 @@\n-  for (int i = parse_predicate_count(); i > 0; i--) {\n-    Node* n = parse_predicate_opaque1_node(i - 1);\n-    assert(n->Opcode() == Op_Opaque1, \"must be\");\n-    igvn.replace_node(n, n->in(1));\n+  for (int i = 0; i < parse_predicate_count(); i++) {\n+    ParsePredicateNode* parse_predicate = _parse_predicates.at(i);\n+    parse_predicate->mark_useless();\n+    igvn._worklist.push(parse_predicate);\n@@ -1821,1 +1825,1 @@\n-  assert(parse_predicate_count() == 0, \"should be clean!\");\n+  _parse_predicates.clear();\n@@ -1854,0 +1858,1 @@\n+    assert(C->parse_predicate_count() == 0, \"all parse predicates should have been removed now\");\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":18,"deletions":13,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -72,0 +72,1 @@\n+class ParsePredicateNode;\n@@ -360,1 +361,1 @@\n-  GrowableArray<Node*>  _parse_predicate_opaqs; \/\/ List of Opaque1 nodes for the Parse Predicates.\n+  GrowableArray<ParsePredicateNode*> _parse_predicates; \/\/ List of Parse Predicates.\n@@ -706,1 +707,1 @@\n-  int           parse_predicate_count()   const { return _parse_predicate_opaqs.length(); }\n+  int           parse_predicate_count()   const { return _parse_predicates.length(); }\n@@ -712,1 +713,1 @@\n-  Node*         parse_predicate_opaque1_node(int idx) const { return _parse_predicate_opaqs.at(idx); }\n+  ParsePredicateNode* parse_predicate(int idx) const { return _parse_predicates.at(idx); }\n@@ -731,4 +732,0 @@\n-    \/\/ remove from _parse_predicate_opaqs list also if it is there\n-    if (parse_predicate_count() > 0) {\n-      _parse_predicate_opaqs.remove_if_existing(n);\n-    }\n@@ -744,4 +741,10 @@\n-  void add_parse_predicate_opaq(Node* n) {\n-    assert(!_parse_predicate_opaqs.contains(n), \"duplicate entry in Parse Predicate opaque1 list\");\n-    assert(_macro_nodes.contains(n), \"should have already been in macro list\");\n-    _parse_predicate_opaqs.append(n);\n+\n+  void add_parse_predicate(ParsePredicateNode* n) {\n+    assert(!_parse_predicates.contains(n), \"duplicate entry in Parse Predicate list\");\n+    _parse_predicates.append(n);\n+  }\n+\n+  void remove_parse_predicate(ParsePredicateNode* n) {\n+    if (parse_predicate_count() > 0) {\n+      _parse_predicates.remove_if_existing(n);\n+    }\n@@ -749,0 +752,1 @@\n+\n@@ -754,0 +758,1 @@\n+\n@@ -778,6 +783,1 @@\n-  \/\/ Remove the opaque nodes that protect the Parse Predicates so that the unused checks and\n-  \/\/ uncommon traps will be eliminated from the graph.\n-  void cleanup_parse_predicates(PhaseIterGVN &igvn) const;\n-  bool is_predicate_opaq(Node* n) const {\n-    return _parse_predicate_opaqs.contains(n);\n-  }\n+  void mark_parse_predicate_nodes_useless(PhaseIterGVN& igvn);\n@@ -1024,1 +1024,2 @@\n-  void remove_useless_nodes       (GrowableArray<Node*>&        node_list, Unique_Node_List &useful);\n+  template<typename N, ENABLE_IF(std::is_base_of<Node, N>::value)>\n+  void remove_useless_nodes(GrowableArray<N*>& node_list, Unique_Node_List& useful);\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":19,"deletions":18,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -3999,5 +3999,1 @@\n-  Node* cont = _gvn.intcon(1);\n-  Node* opaq = _gvn.transform(new Opaque1Node(C, cont));\n-  C->add_parse_predicate_opaq(opaq);\n-  Node* bol = _gvn.transform(new Conv2BNode(opaq));\n-  ParsePredicateNode* parse_predicate = new ParsePredicateNode(control(), bol, reason);\n+  ParsePredicateNode* parse_predicate = new ParsePredicateNode(control(), reason, &_gvn);\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -803,1 +803,1 @@\n-    call = proj_out(i)->is_uncommon_trap_proj(Deoptimization::Reason_none);\n+    call = proj_out(i)->is_uncommon_trap_proj();\n@@ -814,1 +814,1 @@\n-  CallStaticJavaNode* dom_unc = otherproj->is_uncommon_trap_proj(Deoptimization::Reason_none);\n+  CallStaticJavaNode* dom_unc = otherproj->is_uncommon_trap_proj();\n@@ -1079,2 +1079,2 @@\n-  CallStaticJavaNode* unc = success->is_uncommon_trap_proj(Deoptimization::Reason_none);\n-  CallStaticJavaNode* dom_unc = otherproj->is_uncommon_trap_proj(Deoptimization::Reason_none);\n+  CallStaticJavaNode* unc = success->is_uncommon_trap_proj();\n+  CallStaticJavaNode* dom_unc = otherproj->is_uncommon_trap_proj();\n@@ -1244,1 +1244,1 @@\n-  CallStaticJavaNode* unc = proj->is_uncommon_trap_if_pattern(Deoptimization::Reason_none);\n+  CallStaticJavaNode* unc = proj->is_uncommon_trap_if_pattern();\n@@ -1249,2 +1249,2 @@\n-      CallStaticJavaNode* unc = proj->is_uncommon_trap_if_pattern(Deoptimization::Reason_none);\n-      CallStaticJavaNode* dom_unc = proj->in(0)->in(0)->as_Proj()->is_uncommon_trap_if_pattern(Deoptimization::Reason_none);\n+      CallStaticJavaNode* unc = proj->is_uncommon_trap_if_pattern();\n+      CallStaticJavaNode* dom_unc = proj->in(0)->in(0)->as_Proj()->is_uncommon_trap_if_pattern();\n@@ -1281,1 +1281,1 @@\n-  CallStaticJavaNode* dom_unc = dom_proj->is_uncommon_trap_if_pattern(Deoptimization::Reason_none);\n+  CallStaticJavaNode* dom_unc = dom_proj->is_uncommon_trap_if_pattern();\n@@ -1283,1 +1283,1 @@\n-  CallStaticJavaNode* unc = proj->is_uncommon_trap_if_pattern(Deoptimization::Reason_none);\n+  CallStaticJavaNode* unc = proj->is_uncommon_trap_if_pattern();\n@@ -1978,3 +1978,4 @@\n-ParsePredicateNode::ParsePredicateNode(Node* control, Node* bol, Deoptimization::DeoptReason deopt_reason)\n-    : IfNode(control, bol, PROB_MAX, COUNT_UNKNOWN),\n-      _deopt_reason(deopt_reason) {\n+ParsePredicateNode::ParsePredicateNode(Node* control, Deoptimization::DeoptReason deopt_reason, PhaseGVN* gvn)\n+    : IfNode(control, gvn->intcon(1), PROB_MAX, COUNT_UNKNOWN),\n+      _deopt_reason(deopt_reason),\n+      _useless(false) {\n@@ -1982,1 +1983,2 @@\n-  assert(bol->Opcode() == Op_Conv2B && bol->in(1) != nullptr && bol->in(1)->is_Opaque1(), \"wrong boolean input\");\n+  gvn->C->add_parse_predicate(this);\n+  gvn->C->record_for_post_loop_opts_igvn(this);\n@@ -2002,0 +2004,12 @@\n+\/\/ Fold this node away once it becomes useless or at latest in post loop opts IGVN.\n+const Type* ParsePredicateNode::Value(PhaseGVN* phase) const {\n+  if (phase->type(in(0)) == Type::TOP) {\n+    return Type::TOP;\n+  }\n+  if (_useless || phase->C->post_loop_opts_phase()) {\n+    return TypeTuple::IFTRUE;\n+  } else {\n+    return bottom_type();\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/ifnode.cpp","additions":27,"deletions":13,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -102,1 +102,1 @@\n-IfProjNode* PhaseIdealLoop::create_new_if_for_predicate(IfProjNode* cont_proj, Node* new_entry,\n+IfProjNode* PhaseIdealLoop::create_new_if_for_predicate(ParsePredicateSuccessProj* parse_predicate_proj, Node* new_entry,\n@@ -105,2 +105,2 @@\n-  assert(cont_proj->is_uncommon_trap_if_pattern(reason), \"must be a uct if pattern!\");\n-  IfNode* iff = cont_proj->in(0)->as_If();\n+  assert(parse_predicate_proj->is_uncommon_trap_if_pattern(reason), \"must be a uct if pattern!\");\n+  ParsePredicateNode* parse_predicate = parse_predicate_proj->in(0)->as_ParsePredicate();\n@@ -108,3 +108,3 @@\n-  ProjNode *uncommon_proj = iff->proj_out(1 - cont_proj->_con);\n-  Node     *rgn   = uncommon_proj->unique_ctrl_out();\n-  assert(rgn->is_Region() || rgn->is_Call(), \"must be a region or call uct\");\n+  ProjNode* uncommon_proj = parse_predicate->proj_out(false);\n+  Node* uct_region = uncommon_proj->unique_ctrl_out();\n+  assert(uct_region->is_Region() || uct_region->is_Call(), \"must be a region or call uct\");\n@@ -113,3 +113,3 @@\n-  if (!rgn->is_Region()) { \/\/ create a region to guard the call\n-    assert(rgn->is_Call(), \"must be call uct\");\n-    CallNode* call = rgn->as_Call();\n+  if (!uct_region->is_Region()) { \/\/ create a region to guard the call\n+    assert(uct_region->is_Call(), \"must be call uct\");\n+    CallNode* call = uct_region->as_Call();\n@@ -117,1 +117,1 @@\n-    rgn = new RegionNode(1);\n+    uct_region = new RegionNode(1);\n@@ -120,4 +120,4 @@\n-    register_control(uncommon_proj, loop, iff);\n-    rgn->add_req(uncommon_proj);\n-    register_control(rgn, loop, uncommon_proj);\n-    _igvn.replace_input_of(call, 0, rgn);\n+    register_control(uncommon_proj, loop, parse_predicate);\n+    uct_region->add_req(uncommon_proj);\n+    register_control(uct_region, loop, uncommon_proj);\n+    _igvn.replace_input_of(call, 0, uct_region);\n@@ -126,1 +126,1 @@\n-      set_idom(call, rgn, dom_depth(rgn));\n+      set_idom(call, uct_region, dom_depth(uct_region));\n@@ -130,1 +130,1 @@\n-    lazy_replace(uncommon_proj_orig, rgn);\n+    lazy_replace(uncommon_proj_orig, uct_region);\n@@ -133,3 +133,3 @@\n-    for (; proj_index < rgn->req(); proj_index++)\n-      if (rgn->in(proj_index) == uncommon_proj) break;\n-    assert(proj_index < rgn->req(), \"sanity\");\n+    for (; proj_index < uct_region->req(); proj_index++)\n+      if (uct_region->in(proj_index) == uncommon_proj) break;\n+    assert(proj_index < uct_region->req(), \"sanity\");\n@@ -138,1 +138,1 @@\n-  Node* entry = iff->in(0);\n+  Node* entry = parse_predicate->in(0);\n@@ -148,1 +148,1 @@\n-      new_iff = new IfNode(entry, iff->in(1), iff->_prob, iff->_fcnt);\n+      new_iff = new IfNode(entry, parse_predicate->in(1), parse_predicate->_prob, parse_predicate->_fcnt);\n@@ -151,1 +151,1 @@\n-      new_iff = new RangeCheckNode(entry, iff->in(1), iff->_prob, iff->_fcnt);\n+      new_iff = new RangeCheckNode(entry, parse_predicate->in(1), parse_predicate->_prob, parse_predicate->_fcnt);\n@@ -154,1 +154,1 @@\n-      new_iff = new ParsePredicateNode(entry, iff->in(1), reason);\n+      new_iff = new ParsePredicateNode(entry, reason, &_igvn);\n@@ -163,4 +163,0 @@\n-  if (cont_proj->is_IfFalse()) {\n-    \/\/ Swap\n-    IfProjNode* tmp = if_uct; if_uct = if_cont; if_cont = tmp;\n-  }\n@@ -168,1 +164,1 @@\n-  register_control(if_uct, get_loop(rgn), new_iff);\n+  register_control(if_uct, get_loop(uct_region), new_iff);\n@@ -170,1 +166,1 @@\n-  _igvn.add_input_to(rgn, if_uct);\n+  _igvn.add_input_to(uct_region, if_uct);\n@@ -174,1 +170,1 @@\n-  assert(rgn->in(rgn->req() -1) == if_uct, \"new edge should be last\");\n+  assert(uct_region->in(uct_region->req() - 1) == if_uct, \"new edge should be last\");\n@@ -176,2 +172,2 @@\n-  for (DUIterator_Fast imax, i = rgn->fast_outs(imax); i < imax; i++) {\n-    Node* use = rgn->fast_out(i);\n+  for (DUIterator_Fast imax, i = uct_region->fast_outs(imax); i < imax; i++) {\n+    Node* use = uct_region->fast_out(i);\n@@ -179,1 +175,1 @@\n-      assert(use->in(0) == rgn, \"\");\n+      assert(use->in(0) == uct_region, \"\");\n@@ -200,1 +196,1 @@\n-  assert(!has_phi || rgn->req() > 3, \"no phis when region is created\");\n+  assert(!has_phi || uct_region->req() > 3, \"no phis when region is created\");\n@@ -204,1 +200,1 @@\n-    _igvn.replace_input_of(iff, 0, if_cont);\n+    _igvn.replace_input_of(parse_predicate, 0, if_cont);\n@@ -206,1 +202,1 @@\n-      set_idom(iff, if_cont, dom_depth(iff));\n+      set_idom(parse_predicate, if_cont, dom_depth(parse_predicate));\n@@ -212,1 +208,1 @@\n-    Node* ridom = idom(rgn);\n+    Node* ridom = idom(uct_region);\n@@ -214,1 +210,1 @@\n-    set_idom(rgn, nrdom, dom_depth(rgn));\n+    set_idom(uct_region, nrdom, dom_depth(uct_region));\n@@ -306,1 +302,1 @@\n-IfProjNode* PhaseIdealLoop::clone_parse_predicate_to_unswitched_loop(ParsePredicateSuccessProj* predicate_proj,\n+IfProjNode* PhaseIdealLoop::clone_parse_predicate_to_unswitched_loop(ParsePredicateSuccessProj* parse_predicate_proj,\n@@ -310,1 +306,1 @@\n-  IfProjNode* new_predicate_proj = create_new_if_for_predicate(predicate_proj, new_entry, reason, Op_ParsePredicate,\n+  IfProjNode* new_predicate_proj = create_new_if_for_predicate(parse_predicate_proj, new_entry, reason, Op_ParsePredicate,\n@@ -312,12 +308,2 @@\n-  IfNode* iff = new_predicate_proj->in(0)->as_If();\n-  Node* ctrl  = iff->in(0);\n-\n-  \/\/ Match original condition since predicate's projections could be swapped.\n-  assert(predicate_proj->in(0)->in(1)->in(1)->Opcode()==Op_Opaque1, \"must be\");\n-  Node* opq = new Opaque1Node(C, predicate_proj->in(0)->in(1)->in(1)->in(1));\n-  C->add_parse_predicate_opaq(opq);\n-  Node* bol = new Conv2BNode(opq);\n-  register_new_node(opq, ctrl);\n-  register_new_node(bol, ctrl);\n-  _igvn.hash_delete(iff);\n-  iff->set_req(1, bol);\n+  assert(new_predicate_proj->is_IfTrue(), \"the success projection of a Parse Predicate is a true projection\");\n+  ParsePredicateNode* parse_predicate = new_predicate_proj->in(0)->as_ParsePredicate();\n@@ -332,3 +318,5 @@\n-                                                                   IfProjNode* old_predicate_proj, IfProjNode* iffast_pred,\n-                                                                   IfProjNode* ifslow_pred) {\n-  assert(iffast_pred->in(0)->is_If() && ifslow_pred->in(0)->is_If(), \"sanity check\");\n+                                                                   IfProjNode* old_predicate_proj,\n+                                                                   ParsePredicateSuccessProj* fast_loop_parse_predicate_proj,\n+                                                                   ParsePredicateSuccessProj* slow_loop_parse_predicate_proj) {\n+  assert(fast_loop_parse_predicate_proj->in(0)->is_ParsePredicate() &&\n+         slow_loop_parse_predicate_proj->in(0)->is_ParsePredicate(), \"sanity check\");\n@@ -353,1 +341,1 @@\n-    IfProjNode* fast_proj = clone_assertion_predicate_for_unswitched_loops(iff, predicate_proj, reason, iffast_pred);\n+    IfProjNode* fast_proj = clone_assertion_predicate_for_unswitched_loops(iff, predicate_proj, reason, fast_loop_parse_predicate_proj);\n@@ -355,1 +343,1 @@\n-    IfProjNode* slow_proj = clone_assertion_predicate_for_unswitched_loops(iff, predicate_proj, reason, ifslow_pred);\n+    IfProjNode* slow_proj = clone_assertion_predicate_for_unswitched_loops(iff, predicate_proj, reason, slow_loop_parse_predicate_proj);\n@@ -381,2 +369,2 @@\n-  IfNode* iff = predicate->in(0)->as_If();\n-  ProjNode* uncommon_proj = iff->proj_out(1 - predicate->as_Proj()->_con);\n+  ParsePredicateNode* parse_predicate = predicate->in(0)->as_ParsePredicate();\n+  ProjNode* uncommon_proj = parse_predicate->proj_out(1 - predicate->as_Proj()->_con);\n@@ -385,2 +373,1 @@\n-  assert(iff->in(1)->in(1)->Opcode() == Op_Opaque1, \"unexpected predicate shape\");\n-  predicate = iff->in(0);\n+  predicate = parse_predicate->in(0);\n@@ -388,1 +375,1 @@\n-    iff = predicate->in(0)->as_If();\n+    IfNode* iff = predicate->in(0)->as_If();\n@@ -411,3 +398,3 @@\n-                                                                           IfProjNode* output_proj) {\n-  Node* bol = create_bool_from_template_assertion_predicate(iff, nullptr, nullptr, output_proj);\n-  IfProjNode* if_proj = create_new_if_for_predicate(output_proj, nullptr, reason, iff->Opcode(), false);\n+                                                                           ParsePredicateSuccessProj* parse_predicate_proj) {\n+  Node* bol = create_bool_from_template_assertion_predicate(iff, nullptr, nullptr, parse_predicate_proj);\n+  IfProjNode* if_proj = create_new_if_for_predicate(parse_predicate_proj, nullptr, reason, iff->Opcode(), false);\n@@ -415,2 +402,2 @@\n-  _igvn.replace_input_of(output_proj->in(0), 0, if_proj);\n-  set_idom(output_proj->in(0), if_proj, dom_depth(if_proj));\n+  _igvn.replace_input_of(parse_predicate_proj->in(0), 0, if_proj);\n+  set_idom(parse_predicate_proj->in(0), if_proj, dom_depth(if_proj));\n@@ -449,0 +436,2 @@\n+    \/\/ We currently only clone Assertion Predicates if there are Parse Predicates. This is not entirely correct and will\n+    \/\/ be changed with the complete fix for Assertion Predicates.\n@@ -450,0 +439,2 @@\n+    assert(iffast_pred->in(0)->is_ParsePredicate() && ifslow_pred->in(0)->is_ParsePredicate(),\n+           \"must be success projections of the cloned Parse Predicates\");\n@@ -451,1 +442,1 @@\n-                                                  iffast_pred, ifslow_pred);\n+                                                  iffast_pred->as_IfTrue(), ifslow_pred->as_IfTrue());\n@@ -1159,1 +1150,1 @@\n-                   in->as_Proj()->is_uncommon_trap_if_pattern(Deoptimization::Reason_none) &&\n+                   in->as_Proj()->is_uncommon_trap_if_pattern() &&\n@@ -1308,2 +1299,3 @@\n-                                                             IfProjNode* predicate_proj, IfProjNode* upper_bound_proj,\n-                                                             int scale, Node* offset, Node* init, Node* limit, jint stride,\n+                                                             ParsePredicateSuccessProj* parse_predicate_proj,\n+                                                             IfProjNode* upper_bound_proj, const int scale, Node* offset,\n+                                                             Node* init, Node* limit, const jint stride,\n@@ -1314,1 +1306,1 @@\n-  bool negate = (if_proj->_con != predicate_proj->_con);\n+  bool negate = (if_proj->_con != parse_predicate_proj->_con);\n@@ -1320,1 +1312,1 @@\n-  IfProjNode* new_proj = create_new_if_for_predicate(predicate_proj, nullptr, reason, overflow ? Op_If : iff->Opcode());\n+  IfProjNode* new_proj = create_new_if_for_predicate(parse_predicate_proj, nullptr, reason, overflow ? Op_If : iff->Opcode());\n@@ -1336,1 +1328,1 @@\n-  register_new_node(max_value, predicate_proj);\n+  register_new_node(max_value, parse_predicate_proj);\n@@ -1343,1 +1335,1 @@\n-  new_proj = create_new_if_for_predicate(predicate_proj, nullptr, reason, overflow ? Op_If : iff->Opcode());\n+  new_proj = create_new_if_for_predicate(parse_predicate_proj, nullptr, reason, overflow ? Op_If : iff->Opcode());\n@@ -1353,7 +1345,1 @@\n-bool PhaseIdealLoop::loop_predication_impl(IdealLoopTree *loop) {\n-  if (!UseLoopPredicate) return false;\n-\n-  if (!loop->_head->is_Loop()) {\n-    \/\/ Could be a simple region when irreducible loops are present.\n-    return false;\n-  }\n+bool PhaseIdealLoop::loop_predication_impl(IdealLoopTree* loop) {\n@@ -1439,1 +1425,1 @@\n-      CallStaticJavaNode* call = if_proj->is_uncommon_trap_if_pattern(Deoptimization::Reason_none);\n+      CallStaticJavaNode* call = if_proj->is_uncommon_trap_if_pattern();\n@@ -1477,1 +1463,1 @@\n-      if (if_proj->as_Proj()->is_uncommon_trap_if_pattern(Deoptimization::Reason_none) &&\n+      if (if_proj->as_Proj()->is_uncommon_trap_if_pattern() &&\n@@ -1549,1 +1535,1 @@\n-  if (!_irreducible && !tail()->is_top()) {\n+  if (can_apply_loop_predication()) {\n@@ -1559,0 +1545,4 @@\n+\n+bool IdealLoopTree::can_apply_loop_predication() {\n+  return _head->is_Loop() && !_irreducible && !tail()->is_top();\n+}\n","filename":"src\/hotspot\/share\/opto\/loopPredicate.cpp","additions":75,"deletions":85,"binary":false,"changes":160,"status":"modified"},{"patch":"@@ -180,1 +180,1 @@\n-      if (!ctl->in(1)->as_Proj()->is_uncommon_trap_if_pattern(Deoptimization::Reason_none)) {\n+      if (!ctl->in(1)->as_Proj()->is_uncommon_trap_if_pattern()) {\n@@ -194,1 +194,1 @@\n-        if (!ctl->as_Proj()->is_uncommon_trap_if_pattern(Deoptimization::Reason_none)) {\n+        if (!ctl->as_Proj()->is_uncommon_trap_if_pattern()) {\n@@ -353,5 +353,0 @@\n-  assert(iff->Opcode() == Op_If, \"bad graph shape\");\n-  Node* conv = iff->in(1);\n-  assert(conv->Opcode() == Op_Conv2B, \"bad graph shape\");\n-  Node* opaq = conv->in(1);\n-  assert(opaq->Opcode() == Op_Opaque1, \"bad graph shape\");\n@@ -567,13 +562,6 @@\n-    Node* cont = _igvn.intcon(1);\n-    Node* opaq = new Opaque1Node(C, cont);\n-    _igvn.register_new_node_with_optimizer(opaq);\n-    Node* bol = new Conv2BNode(opaq);\n-    _igvn.register_new_node_with_optimizer(bol);\n-    set_subtree_ctrl(bol, false);\n-    ParsePredicateNode* iff = new ParsePredicateNode(inner_head->in(LoopNode::EntryControl), bol, reason);\n-    register_control(iff, loop, inner_head->in(LoopNode::EntryControl));\n-    Node* if_false = new IfFalseNode(iff);\n-    register_control(if_false, _ltree_root, iff);\n-    Node* if_true = new IfTrueNode(iff);\n-    register_control(if_true, loop, iff);\n-    C->add_parse_predicate_opaq(opaq);\n+    ParsePredicateNode* parse_predicate = new ParsePredicateNode(inner_head->in(LoopNode::EntryControl), reason, &_igvn);\n+    register_control(parse_predicate, loop, inner_head->in(LoopNode::EntryControl));\n+    Node* if_false = new IfFalseNode(parse_predicate);\n+    register_control(if_false, _ltree_root, parse_predicate);\n+    Node* if_true = new IfTrueNode(parse_predicate);\n+    register_control(if_true, loop, parse_predicate);\n@@ -1096,1 +1084,1 @@\n-      CallStaticJavaNode* call = if_proj->is_uncommon_trap_if_pattern(Deoptimization::Reason_none);\n+      CallStaticJavaNode* call = if_proj->is_uncommon_trap_if_pattern();\n@@ -4059,6 +4047,5 @@\n-\/\/---------------------collect_potentially_useful_predicates-----------------------\n-\/\/ Helper function to collect potentially useful predicates to prevent them from\n-\/\/ being eliminated by PhaseIdealLoop::eliminate_useless_predicates\n-void PhaseIdealLoop::collect_potentially_useful_predicates(IdealLoopTree* loop, Unique_Node_List &useful_predicates) {\n-  if (loop->_child) { \/\/ child\n-    collect_potentially_useful_predicates(loop->_child, useful_predicates);\n+\/\/ Eliminate all Parse and Template Assertion Predicates that are not associated with a loop anymore. The eliminated\n+\/\/ predicates will be removed during the next round of IGVN.\n+void PhaseIdealLoop::eliminate_useless_predicates() {\n+  if (C->parse_predicate_count() == 0 && C->template_assertion_predicate_count() == 0) {\n+    return; \/\/ No predicates left.\n@@ -4067,21 +4054,3 @@\n-  \/\/ self (only loops that we can apply loop predication may use their predicates)\n-  if (loop->_head->is_Loop() &&\n-      !loop->_irreducible    &&\n-      !loop->tail()->is_top()) {\n-    LoopNode* lpn = loop->_head->as_Loop();\n-    Node* entry = lpn->in(LoopNode::EntryControl);\n-    const Predicates predicates(entry);\n-    const PredicateBlock* loop_limit_check_predicate_block = predicates.loop_limit_check_predicate_block();\n-    if (loop_limit_check_predicate_block->has_parse_predicate()) { \/\/ right pattern that can be used by loop predication\n-      IfProjNode* parse_predicate_proj = loop_limit_check_predicate_block->parse_predicate_success_proj();\n-      assert(parse_predicate_proj->in(0)->in(1)->in(1)->Opcode() == Op_Opaque1, \"must be\");\n-      useful_predicates.push(parse_predicate_proj->in(0)->in(1)->in(1)); \/\/ good one\n-    }\n-    if (UseProfiledLoopPredicate) {\n-      const PredicateBlock* profiled_loop_predicate_block = predicates.profiled_loop_predicate_block();\n-      if (profiled_loop_predicate_block->has_parse_predicate()) { \/\/ right pattern that can be used by loop predication\n-        IfProjNode* parse_predicate_proj = profiled_loop_predicate_block->parse_predicate_success_proj();\n-        useful_predicates.push(parse_predicate_proj->in(0)->in(1)->in(1)); \/\/ good one\n-        get_assertion_predicates(parse_predicate_proj, useful_predicates, true);\n-      }\n-    }\n+  eliminate_useless_parse_predicates();\n+  eliminate_useless_template_assertion_predicates();\n+}\n@@ -4089,7 +4058,21 @@\n-    if (UseLoopPredicate) {\n-      const PredicateBlock* loop_predicate_block = predicates.loop_predicate_block();\n-      if (loop_predicate_block->has_parse_predicate()) { \/\/ right pattern that can be used by loop predication\n-        IfProjNode* parse_predicate_proj = loop_predicate_block->parse_predicate_success_proj();\n-        useful_predicates.push(parse_predicate_proj->in(0)->in(1)->in(1)); \/\/ good one\n-        get_assertion_predicates(parse_predicate_proj, useful_predicates, true);\n-      }\n+\/\/ Eliminate all Parse Predicates that do not belong to a loop anymore by marking them useless. These will be removed\n+\/\/ during the next round of IGVN.\n+void PhaseIdealLoop::eliminate_useless_parse_predicates() {\n+  mark_all_parse_predicates_useless();\n+  if (C->has_loops()) {\n+    mark_loop_associated_parse_predicates_useful();\n+  }\n+  add_useless_parse_predicates_to_igvn_worklist();\n+}\n+\n+void PhaseIdealLoop::mark_all_parse_predicates_useless() const {\n+  for (int i = 0; i < C->parse_predicate_count(); i++) {\n+    C->parse_predicate(i)->mark_useless();\n+  }\n+}\n+\n+void PhaseIdealLoop::mark_loop_associated_parse_predicates_useful() {\n+  for (LoopTreeIterator iterator(_ltree_root); !iterator.done(); iterator.next()) {\n+    IdealLoopTree* loop = iterator.current();\n+    if (loop->can_apply_loop_predication()) {\n+      mark_useful_parse_predicates_for_loop(loop);\n@@ -4098,0 +4081,1 @@\n+}\n@@ -4099,2 +4083,6 @@\n-  if (loop->_next) { \/\/ sibling\n-    collect_potentially_useful_predicates(loop->_next, useful_predicates);\n+void PhaseIdealLoop::mark_useful_parse_predicates_for_loop(IdealLoopTree* loop) {\n+  Node* entry = loop->_head->in(LoopNode::EntryControl);\n+  const Predicates predicates(entry);\n+  ParsePredicateIterator iterator(predicates);\n+  while (iterator.has_next()) {\n+    iterator.next()->mark_useful();\n@@ -4104,7 +4092,6 @@\n-\/\/------------------------eliminate_useless_predicates-----------------------------\n-\/\/ Eliminate all inserted predicates if they could not be used by loop predication.\n-\/\/ Note: it will also eliminates loop limits check predicate since it also uses\n-\/\/ Opaque1 node (see Parse::add_predicate()).\n-void PhaseIdealLoop::eliminate_useless_predicates() {\n-  if (C->parse_predicate_count() == 0 && C->template_assertion_predicate_count() == 0) {\n-    return; \/\/ no predicate left\n+void PhaseIdealLoop::add_useless_parse_predicates_to_igvn_worklist() {\n+  for (int i = 0; i < C->parse_predicate_count(); i++) {\n+    ParsePredicateNode* parse_predicate_node = C->parse_predicate(i);\n+    if (parse_predicate_node->is_useless()) {\n+      _igvn._worklist.push(parse_predicate_node);\n+    }\n@@ -4112,0 +4099,1 @@\n+}\n@@ -4113,1 +4101,5 @@\n-  Unique_Node_List useful_predicates; \/\/ to store useful predicates\n+\n+\/\/ Eliminate all Template Assertion Predicates that do not belong to their originally associated loop anymore by\n+\/\/ replacing the Opaque4 node of the If node with true. These nodes will be removed during the next round of IGVN.\n+void PhaseIdealLoop::eliminate_useless_template_assertion_predicates() {\n+  Unique_Node_List useful_predicates;\n@@ -4115,1 +4107,1 @@\n-    collect_potentially_useful_predicates(_ltree_root->_child, useful_predicates);\n+    collect_useful_template_assertion_predicates(useful_predicates);\n@@ -4117,0 +4109,2 @@\n+  eliminate_useless_template_assertion_predicates(useful_predicates);\n+}\n@@ -4118,6 +4112,6 @@\n-  for (int i = C->parse_predicate_count(); i > 0; i--) {\n-     Node* n = C->parse_predicate_opaque1_node(i - 1);\n-     assert(n->Opcode() == Op_Opaque1, \"must be\");\n-     if (!useful_predicates.member(n)) { \/\/ not in the useful list\n-       _igvn.replace_node(n, n->in(1));\n-     }\n+void PhaseIdealLoop::collect_useful_template_assertion_predicates(Unique_Node_List& useful_predicates) {\n+  for (LoopTreeIterator iterator(_ltree_root); !iterator.done(); iterator.next()) {\n+    IdealLoopTree* loop = iterator.current();\n+    if (loop->can_apply_loop_predication()) {\n+      collect_useful_template_assertion_predicates_for_loop(loop, useful_predicates);\n+    }\n@@ -4125,0 +4119,22 @@\n+}\n+\n+void PhaseIdealLoop::collect_useful_template_assertion_predicates_for_loop(IdealLoopTree* loop,\n+                                                                           Unique_Node_List &useful_predicates) {\n+  Node* entry = loop->_head->in(LoopNode::EntryControl);\n+  const Predicates predicates(entry);\n+  if (UseProfiledLoopPredicate) {\n+    const PredicateBlock* profiled_loop_predicate_block = predicates.profiled_loop_predicate_block();\n+    if (profiled_loop_predicate_block->has_parse_predicate()) {\n+      IfProjNode* parse_predicate_proj = profiled_loop_predicate_block->parse_predicate_success_proj();\n+      get_assertion_predicates(parse_predicate_proj, useful_predicates, true);\n+    }\n+  }\n+\n+  if (UseLoopPredicate) {\n+    const PredicateBlock* loop_predicate_block = predicates.loop_predicate_block();\n+    if (loop_predicate_block->has_parse_predicate()) {\n+      IfProjNode* parse_predicate_proj = loop_predicate_block->parse_predicate_success_proj();\n+      get_assertion_predicates(parse_predicate_proj, useful_predicates, true);\n+    }\n+  }\n+}\n@@ -4126,5 +4142,6 @@\n-  for (int i = C->template_assertion_predicate_count(); i > 0; i--) {\n-    Node* n = C->template_assertion_predicate_opaq_node(i - 1);\n-    assert(n->Opcode() == Op_Opaque4, \"must be\");\n-    if (!useful_predicates.member(n)) { \/\/ not in the useful list\n-      _igvn.replace_node(n, n->in(2));\n+void PhaseIdealLoop::eliminate_useless_template_assertion_predicates(Unique_Node_List& useful_predicates) {\n+  for (int i = 0; i < C->template_assertion_predicate_count(); i++) {\n+    Node* opaque4 = C->template_assertion_predicate_opaq_node(i);\n+    assert(opaque4->Opcode() == Op_Opaque4, \"must be\");\n+    if (!useful_predicates.member(opaque4)) { \/\/ not in the useful list\n+      _igvn.replace_node(opaque4, opaque4->in(2));\n@@ -4568,1 +4585,1 @@\n-  if (C->has_loops() && !C->major_progress() && (C->parse_predicate_count() > 0)) {\n+  if (UseLoopPredicate && C->has_loops() && !C->major_progress() && (C->parse_predicate_count() > 0)) {\n@@ -4621,1 +4638,2 @@\n-     C->cleanup_parse_predicates(_igvn);\n+    C->mark_parse_predicate_nodes_useless(_igvn);\n+    assert(C->parse_predicate_count() == 0, \"should be zero now\");\n@@ -6103,1 +6121,1 @@\n-      CallStaticJavaNode* call = new_ctrl->as_Proj()->is_uncommon_trap_if_pattern(Deoptimization::Reason_none);\n+      CallStaticJavaNode* call = new_ctrl->as_Proj()->is_uncommon_trap_if_pattern();\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":98,"deletions":80,"binary":false,"changes":178,"status":"modified"},{"patch":"@@ -649,0 +649,1 @@\n+  bool can_apply_loop_predication();\n@@ -1333,2 +1334,3 @@\n-  IfProjNode* create_new_if_for_predicate(IfProjNode* cont_proj, Node* new_entry, Deoptimization::DeoptReason reason,\n-                                          int opcode, bool rewire_uncommon_proj_phi_inputs = false);\n+  IfProjNode* create_new_if_for_predicate(ParsePredicateSuccessProj* parse_predicate_proj, Node* new_entry,\n+                                          Deoptimization::DeoptReason reason, int opcode,\n+                                          bool rewire_uncommon_proj_phi_inputs = false);\n@@ -1365,1 +1367,2 @@\n-  IfProjNode* add_template_assertion_predicate(IfNode* iff, IdealLoopTree* loop, IfProjNode* if_proj, IfProjNode* predicate_proj,\n+  IfProjNode* add_template_assertion_predicate(IfNode* iff, IdealLoopTree* loop, IfProjNode* if_proj,\n+                                               ParsePredicateSuccessProj* parse_predicate_proj,\n@@ -1372,1 +1375,0 @@\n-  void collect_potentially_useful_predicates(IdealLoopTree *loop, Unique_Node_List &predicate_opaque1);\n@@ -1374,0 +1376,12 @@\n+\n+  void eliminate_useless_parse_predicates();\n+  void mark_all_parse_predicates_useless() const;\n+  void mark_loop_associated_parse_predicates_useful();\n+  static void mark_useful_parse_predicates_for_loop(IdealLoopTree* loop);\n+  void add_useless_parse_predicates_to_igvn_worklist();\n+\n+  void eliminate_useless_template_assertion_predicates();\n+  void collect_useful_template_assertion_predicates(Unique_Node_List& useful_predicates);\n+  static void collect_useful_template_assertion_predicates_for_loop(IdealLoopTree* loop, Unique_Node_List& useful_predicates);\n+  void eliminate_useless_template_assertion_predicates(Unique_Node_List& useful_predicates);\n+\n@@ -1624,1 +1638,1 @@\n-  IfProjNode* clone_parse_predicate_to_unswitched_loop(ParsePredicateSuccessProj* predicate_proj, Node* new_entry,\n+  IfProjNode* clone_parse_predicate_to_unswitched_loop(ParsePredicateSuccessProj* parse_predicate_proj, Node* new_entry,\n@@ -1628,1 +1642,2 @@\n-                                                     IfProjNode* iffast_pred, IfProjNode* ifslow_pred);\n+                                                     ParsePredicateSuccessProj* fast_loop_parse_predicate_proj,\n+                                                     ParsePredicateSuccessProj* slow_loop_parse_predicate_proj);\n@@ -1631,1 +1646,1 @@\n-                                                             IfProjNode* output_proj);\n+                                                             ParsePredicateSuccessProj* parse_predicate_proj);\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":22,"deletions":7,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2063,1 +2063,1 @@\n-      if (use->is_If() || use->is_CMove() || C->is_predicate_opaq(use) || use->Opcode() == Op_Opaque4 ||\n+      if (use->is_If() || use->is_CMove() || use->Opcode() == Op_Opaque4 ||\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -540,1 +540,1 @@\n-      if (sfpt_ctl->is_Proj() && sfpt_ctl->as_Proj()->is_uncommon_trap_proj(Deoptimization::Reason_none)) {\n+      if (sfpt_ctl->is_Proj() && sfpt_ctl->as_Proj()->is_uncommon_trap_proj()) {\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -187,3 +187,3 @@\n-CallStaticJavaNode* ProjNode::is_uncommon_trap_proj(Deoptimization::DeoptReason reason) {\n-  int path_limit = 10;\n-  Node* out = this;\n+CallStaticJavaNode* ProjNode::is_uncommon_trap_proj(Deoptimization::DeoptReason reason) const {\n+  const int path_limit = 10;\n+  const Node* out = this;\n@@ -216,15 +216,6 @@\n-\/\/ null otherwise\n-\/\/ \"must_reason_predicate\" means the uct reason must be Reason_predicate\n-CallStaticJavaNode* ProjNode::is_uncommon_trap_if_pattern(Deoptimization::DeoptReason reason) {\n-  Node *in0 = in(0);\n-  if (!in0->is_If()) return nullptr;\n-  \/\/ Variation of a dead If node.\n-  if (in0->outcnt() < 2)  return nullptr;\n-  IfNode* iff = in0->as_If();\n-\n-  \/\/ we need \"If(Conv2B(Opaque1(...)))\" pattern for reason_predicate\n-  if (reason != Deoptimization::Reason_none) {\n-    if (iff->in(1)->Opcode() != Op_Conv2B ||\n-       iff->in(1)->in(1)->Opcode() != Op_Opaque1) {\n-      return nullptr;\n-    }\n+\/\/ or null otherwise.\n+CallStaticJavaNode* ProjNode::is_uncommon_trap_if_pattern(Deoptimization::DeoptReason reason) const {\n+  Node* iff = in(0);\n+  if (!iff->is_If() || iff->outcnt() < 2) {\n+    \/\/ Not a projection of an If or variation of a dead If node.\n+    return nullptr;\n@@ -232,9 +223,1 @@\n-\n-  ProjNode* other_proj = iff->proj_out(1-_con);\n-  CallStaticJavaNode* call = other_proj->is_uncommon_trap_proj(reason);\n-  if (call != nullptr) {\n-    assert(reason == Deoptimization::Reason_none ||\n-           Compile::current()->is_predicate_opaq(iff->in(1)->in(1)), \"should be on the list\");\n-    return call;\n-  }\n-  return nullptr;\n+  return other_if_proj()->is_uncommon_trap_proj(reason);\n","filename":"src\/hotspot\/share\/opto\/multnode.cpp","additions":10,"deletions":27,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -96,1 +96,1 @@\n-  CallStaticJavaNode* is_uncommon_trap_proj(Deoptimization::DeoptReason reason);\n+  CallStaticJavaNode* is_uncommon_trap_proj(Deoptimization::DeoptReason reason = Deoptimization::Reason_none) const;\n@@ -102,1 +102,1 @@\n-  CallStaticJavaNode* is_uncommon_trap_if_pattern(Deoptimization::DeoptReason reason);\n+  CallStaticJavaNode* is_uncommon_trap_if_pattern(Deoptimization::DeoptReason reason = Deoptimization::Reason_none) const;\n","filename":"src\/hotspot\/share\/opto\/multnode.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -511,0 +511,4 @@\n+  if (n->is_ParsePredicate()) {\n+    C->add_parse_predicate(n->as_ParsePredicate());\n+  }\n+\n@@ -612,0 +616,3 @@\n+  if (is_ParsePredicate()) {\n+    compile->remove_parse_predicate(as_ParsePredicate());\n+  }\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -72,1 +72,1 @@\n-    CallStaticJavaNode* uct_call = if_proj->is_uncommon_trap_if_pattern(Deoptimization::Reason_none);\n+    CallStaticJavaNode* uct_call = if_proj->is_uncommon_trap_if_pattern();\n@@ -87,0 +87,24 @@\n+ParsePredicateIterator::ParsePredicateIterator(const Predicates& predicates) : _current_index(0) {\n+  const PredicateBlock* loop_limit_check_predicate_block = predicates.loop_limit_check_predicate_block();\n+  if (loop_limit_check_predicate_block->has_parse_predicate()) {\n+    _parse_predicates.push(loop_limit_check_predicate_block->parse_predicate());\n+  }\n+  if (UseProfiledLoopPredicate) {\n+    const PredicateBlock* profiled_loop_predicate_block = predicates.profiled_loop_predicate_block();\n+    if (profiled_loop_predicate_block->has_parse_predicate()) {\n+      _parse_predicates.push(profiled_loop_predicate_block->parse_predicate());\n+    }\n+  }\n+  if (UseLoopPredicate) {\n+    const PredicateBlock* loop_predicate_block = predicates.loop_predicate_block();\n+    if (loop_predicate_block->has_parse_predicate()) {\n+      _parse_predicates.push(loop_predicate_block->parse_predicate());\n+    }\n+  }\n+}\n+\n+ParsePredicateNode* ParsePredicateIterator::next() {\n+  assert(has_next(), \"always check has_next() first\");\n+  return _parse_predicates.at(_current_index++);\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/predicates.cpp","additions":25,"deletions":1,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -358,0 +358,15 @@\n+\n+\/\/ This class iterates over the Parse Predicates of a loop.\n+class ParsePredicateIterator : public StackObj {\n+  GrowableArray<ParsePredicateNode*> _parse_predicates;\n+  int _current_index;\n+\n+ public:\n+  ParsePredicateIterator(const Predicates& predicates);\n+\n+  bool has_next() const {\n+    return _current_index < _parse_predicates.length();\n+  }\n+\n+  ParsePredicateNode* next();\n+};\n","filename":"src\/hotspot\/share\/opto\/predicates.hpp","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"}]}