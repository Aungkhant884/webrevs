{"files":[{"patch":"@@ -464,0 +464,1 @@\n+  bool _useless; \/\/ If the associated loop dies, this parse predicate becomes useless and can be cleaned up by Value().\n@@ -465,1 +466,1 @@\n-  ParsePredicateNode(Node* control, Node* bol, Deoptimization::DeoptReason deopt_reason);\n+  ParsePredicateNode(Node* control, Deoptimization::DeoptReason deopt_reason, PhaseGVN* gvn);\n@@ -473,0 +474,12 @@\n+  bool is_useless() const {\n+    return _useless;\n+  }\n+\n+  void mark_useless() {\n+    _useless = true;\n+  }\n+\n+  void mark_useful() {\n+    _useless = false;\n+  }\n+\n@@ -475,0 +488,5 @@\n+  Node* Ideal(PhaseGVN* phase, bool can_reshape) {\n+    return nullptr; \/\/ Don't optimize\n+  }\n+\n+  const Type* Value(PhaseGVN* phase) const;\n","filename":"src\/hotspot\/share\/opto\/cfgnode.hpp","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -363,1 +363,2 @@\n-void Compile::remove_useless_nodes(GrowableArray<Node*>& node_list, Unique_Node_List& useful) {\n+template<typename N, ENABLE_IF_SDEFN(std::is_base_of<Node, N>::value)>\n+void Compile::remove_useless_nodes(GrowableArray<N*>& node_list, Unique_Node_List& useful) {\n@@ -365,2 +366,2 @@\n-    Node* n = node_list.at(i);\n-    if (!useful.member(n)) {\n+    N* node = node_list.at(i);\n+    if (!useful.member(node)) {\n@@ -392,0 +393,3 @@\n+  if (dead->is_ParsePredicate()) {\n+    remove_parse_predicate(dead->as_ParsePredicate());\n+  }\n@@ -439,1 +443,1 @@\n-  remove_useless_nodes(_parse_predicate_opaqs, useful); \/\/ remove useless Parse Predicate opaque nodes\n+  remove_useless_nodes(_parse_predicates,   useful); \/\/ remove useless Parse Predicate nodes\n@@ -634,1 +638,1 @@\n-                  _parse_predicate_opaqs (comp_arena(), 8, 0, nullptr),\n+                  _parse_predicates  (comp_arena(), 8, 0, nullptr),\n@@ -1810,3 +1814,3 @@\n-\/\/ Remove the opaque nodes that protect the Parse Predicates so that all unused\n-\/\/ checks and uncommon_traps will be eliminated from the ideal graph.\n-void Compile::cleanup_parse_predicates(PhaseIterGVN& igvn) const {\n+\/\/ Mark all ParsePredicateNodes as useless. They will later be removed from the graph in IGVN together with their\n+\/\/ uncommon traps if no Runtime Predicates were created from the Parse Predicates.\n+void Compile::mark_parse_predicate_nodes_useless(PhaseIterGVN& igvn) {\n@@ -1816,4 +1820,4 @@\n-  for (int i = parse_predicate_count(); i > 0; i--) {\n-    Node* n = parse_predicate_opaque1_node(i - 1);\n-    assert(n->Opcode() == Op_Opaque1, \"must be\");\n-    igvn.replace_node(n, n->in(1));\n+  for (int i = 0; i < parse_predicate_count(); i++) {\n+    ParsePredicateNode* parse_predicate = _parse_predicates.at(i);\n+    parse_predicate->mark_useless();\n+    igvn._worklist.push(parse_predicate);\n@@ -1821,1 +1825,1 @@\n-  assert(parse_predicate_count() == 0, \"should be clean!\");\n+  _parse_predicates.clear();\n@@ -1854,0 +1858,1 @@\n+    assert(C->parse_predicate_count() == 0, \"all parse predicates should have been removed now\");\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":18,"deletions":13,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -72,0 +72,1 @@\n+class ParsePredicateNode;\n@@ -360,1 +361,1 @@\n-  GrowableArray<Node*>  _parse_predicate_opaqs; \/\/ List of Opaque1 nodes for the Parse Predicates.\n+  GrowableArray<ParsePredicateNode*> _parse_predicates; \/\/ List of Parse Predicates.\n@@ -706,1 +707,1 @@\n-  int           parse_predicate_count()   const { return _parse_predicate_opaqs.length(); }\n+  int           parse_predicate_count()   const { return _parse_predicates.length(); }\n@@ -712,1 +713,1 @@\n-  Node*         parse_predicate_opaque1_node(int idx) const { return _parse_predicate_opaqs.at(idx); }\n+  ParsePredicateNode* parse_predicate(int idx) const { return _parse_predicates.at(idx); }\n@@ -731,4 +732,0 @@\n-    \/\/ remove from _parse_predicate_opaqs list also if it is there\n-    if (parse_predicate_count() > 0) {\n-      _parse_predicate_opaqs.remove_if_existing(n);\n-    }\n@@ -744,4 +741,10 @@\n-  void add_parse_predicate_opaq(Node* n) {\n-    assert(!_parse_predicate_opaqs.contains(n), \"duplicate entry in Parse Predicate opaque1 list\");\n-    assert(_macro_nodes.contains(n), \"should have already been in macro list\");\n-    _parse_predicate_opaqs.append(n);\n+\n+  void add_parse_predicate(ParsePredicateNode* n) {\n+    assert(!_parse_predicates.contains(n), \"duplicate entry in Parse Predicate list\");\n+    _parse_predicates.append(n);\n+  }\n+\n+  void remove_parse_predicate(ParsePredicateNode* n) {\n+    if (parse_predicate_count() > 0) {\n+      _parse_predicates.remove_if_existing(n);\n+    }\n@@ -749,0 +752,1 @@\n+\n@@ -754,0 +758,1 @@\n+\n@@ -778,6 +783,1 @@\n-  \/\/ Remove the opaque nodes that protect the Parse Predicates so that the unused checks and\n-  \/\/ uncommon traps will be eliminated from the graph.\n-  void cleanup_parse_predicates(PhaseIterGVN &igvn) const;\n-  bool is_predicate_opaq(Node* n) const {\n-    return _parse_predicate_opaqs.contains(n);\n-  }\n+  void mark_parse_predicate_nodes_useless(PhaseIterGVN& igvn);\n@@ -1024,1 +1024,2 @@\n-  void remove_useless_nodes       (GrowableArray<Node*>&        node_list, Unique_Node_List &useful);\n+  template<typename N, ENABLE_IF(std::is_base_of<Node, N>::value)>\n+  void remove_useless_nodes(GrowableArray<N*>& node_list, Unique_Node_List& useful);\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":19,"deletions":18,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -3999,5 +3999,1 @@\n-  Node* cont = _gvn.intcon(1);\n-  Node* opaq = _gvn.transform(new Opaque1Node(C, cont));\n-  C->add_parse_predicate_opaq(opaq);\n-  Node* bol = _gvn.transform(new Conv2BNode(opaq));\n-  ParsePredicateNode* parse_predicate = new ParsePredicateNode(control(), bol, reason);\n+  ParsePredicateNode* parse_predicate = new ParsePredicateNode(control(), reason, &_gvn);\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1978,3 +1978,4 @@\n-ParsePredicateNode::ParsePredicateNode(Node* control, Node* bol, Deoptimization::DeoptReason deopt_reason)\n-    : IfNode(control, bol, PROB_MAX, COUNT_UNKNOWN),\n-      _deopt_reason(deopt_reason) {\n+ParsePredicateNode::ParsePredicateNode(Node* control, Deoptimization::DeoptReason deopt_reason, PhaseGVN* gvn)\n+    : IfNode(control, gvn->intcon(1), PROB_MAX, COUNT_UNKNOWN),\n+      _deopt_reason(deopt_reason),\n+      _useless(false) {\n@@ -1982,1 +1983,2 @@\n-  assert(bol->Opcode() == Op_Conv2B && bol->in(1) != nullptr && bol->in(1)->is_Opaque1(), \"wrong boolean input\");\n+  gvn->C->add_parse_predicate(this);\n+  gvn->C->record_for_post_loop_opts_igvn(this);\n@@ -2002,0 +2004,12 @@\n+\/\/ Fold this node away once it becomes useless or at latest in post loop opts IGVN.\n+const Type* ParsePredicateNode::Value(PhaseGVN* phase) const {\n+  if (phase->type(in(0)) == Type::TOP) {\n+    return Type::TOP;\n+  }\n+  if (_useless || phase->C->post_loop_opts_phase()) {\n+    return TypeTuple::IFTRUE;\n+  } else {\n+    return bottom_type();\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/ifnode.cpp","additions":18,"deletions":4,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -154,1 +154,1 @@\n-      new_iff = new ParsePredicateNode(entry, iff->in(1), reason);\n+      new_iff = new ParsePredicateNode(entry, reason, &_igvn);\n@@ -312,12 +312,2 @@\n-  IfNode* iff = new_predicate_proj->in(0)->as_If();\n-  Node* ctrl  = iff->in(0);\n-\n-  \/\/ Match original condition since predicate's projections could be swapped.\n-  assert(predicate_proj->in(0)->in(1)->in(1)->Opcode()==Op_Opaque1, \"must be\");\n-  Node* opq = new Opaque1Node(C, predicate_proj->in(0)->in(1)->in(1)->in(1));\n-  C->add_parse_predicate_opaq(opq);\n-  Node* bol = new Conv2BNode(opq);\n-  register_new_node(opq, ctrl);\n-  register_new_node(bol, ctrl);\n-  _igvn.hash_delete(iff);\n-  iff->set_req(1, bol);\n+  assert(new_predicate_proj->is_IfTrue(), \"the success projection of a Parse Predicate is a true projection\");\n+  ParsePredicateNode* parse_predicate = new_predicate_proj->in(0)->as_ParsePredicate();\n@@ -381,2 +371,2 @@\n-  IfNode* iff = predicate->in(0)->as_If();\n-  ProjNode* uncommon_proj = iff->proj_out(1 - predicate->as_Proj()->_con);\n+  ParsePredicateNode* parse_predicate = predicate->in(0)->as_ParsePredicate();\n+  ProjNode* uncommon_proj = parse_predicate->proj_out(1 - predicate->as_Proj()->_con);\n@@ -385,2 +375,1 @@\n-  assert(iff->in(1)->in(1)->Opcode() == Op_Opaque1, \"unexpected predicate shape\");\n-  predicate = iff->in(0);\n+  predicate = parse_predicate->in(0);\n@@ -388,1 +377,1 @@\n-    iff = predicate->in(0)->as_If();\n+    IfNode* iff = predicate->in(0)->as_If();\n@@ -1353,7 +1342,1 @@\n-bool PhaseIdealLoop::loop_predication_impl(IdealLoopTree *loop) {\n-  if (!UseLoopPredicate) return false;\n-\n-  if (!loop->_head->is_Loop()) {\n-    \/\/ Could be a simple region when irreducible loops are present.\n-    return false;\n-  }\n+bool PhaseIdealLoop::loop_predication_impl(IdealLoopTree* loop) {\n@@ -1549,1 +1532,1 @@\n-  if (!_irreducible && !tail()->is_top()) {\n+  if (can_apply_loop_predication()) {\n@@ -1559,0 +1542,4 @@\n+\n+bool IdealLoopTree::can_apply_loop_predication() {\n+  return _head->is_Loop() && !_irreducible && !tail()->is_top();\n+}\n","filename":"src\/hotspot\/share\/opto\/loopPredicate.cpp","additions":13,"deletions":26,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -353,5 +353,0 @@\n-  assert(iff->Opcode() == Op_If, \"bad graph shape\");\n-  Node* conv = iff->in(1);\n-  assert(conv->Opcode() == Op_Conv2B, \"bad graph shape\");\n-  Node* opaq = conv->in(1);\n-  assert(opaq->Opcode() == Op_Opaque1, \"bad graph shape\");\n@@ -567,13 +562,6 @@\n-    Node* cont = _igvn.intcon(1);\n-    Node* opaq = new Opaque1Node(C, cont);\n-    _igvn.register_new_node_with_optimizer(opaq);\n-    Node* bol = new Conv2BNode(opaq);\n-    _igvn.register_new_node_with_optimizer(bol);\n-    set_subtree_ctrl(bol, false);\n-    ParsePredicateNode* iff = new ParsePredicateNode(inner_head->in(LoopNode::EntryControl), bol, reason);\n-    register_control(iff, loop, inner_head->in(LoopNode::EntryControl));\n-    Node* if_false = new IfFalseNode(iff);\n-    register_control(if_false, _ltree_root, iff);\n-    Node* if_true = new IfTrueNode(iff);\n-    register_control(if_true, loop, iff);\n-    C->add_parse_predicate_opaq(opaq);\n+    ParsePredicateNode* parse_predicate = new ParsePredicateNode(inner_head->in(LoopNode::EntryControl), reason, &_igvn);\n+    register_control(parse_predicate, loop, inner_head->in(LoopNode::EntryControl));\n+    Node* if_false = new IfFalseNode(parse_predicate);\n+    register_control(if_false, _ltree_root, parse_predicate);\n+    Node* if_true = new IfTrueNode(parse_predicate);\n+    register_control(if_true, loop, parse_predicate);\n@@ -4059,29 +4047,6 @@\n-\/\/---------------------collect_potentially_useful_predicates-----------------------\n-\/\/ Helper function to collect potentially useful predicates to prevent them from\n-\/\/ being eliminated by PhaseIdealLoop::eliminate_useless_predicates\n-void PhaseIdealLoop::collect_potentially_useful_predicates(IdealLoopTree* loop, Unique_Node_List &useful_predicates) {\n-  if (loop->_child) { \/\/ child\n-    collect_potentially_useful_predicates(loop->_child, useful_predicates);\n-  }\n-\n-  \/\/ self (only loops that we can apply loop predication may use their predicates)\n-  if (loop->_head->is_Loop() &&\n-      !loop->_irreducible    &&\n-      !loop->tail()->is_top()) {\n-    LoopNode* lpn = loop->_head->as_Loop();\n-    Node* entry = lpn->in(LoopNode::EntryControl);\n-    const Predicates predicates(entry);\n-    const PredicateBlock* loop_limit_check_predicate_block = predicates.loop_limit_check_predicate_block();\n-    if (loop_limit_check_predicate_block->has_parse_predicate()) { \/\/ right pattern that can be used by loop predication\n-      IfProjNode* parse_predicate_proj = loop_limit_check_predicate_block->parse_predicate_success_proj();\n-      assert(parse_predicate_proj->in(0)->in(1)->in(1)->Opcode() == Op_Opaque1, \"must be\");\n-      useful_predicates.push(parse_predicate_proj->in(0)->in(1)->in(1)); \/\/ good one\n-    }\n-    if (UseProfiledLoopPredicate) {\n-      const PredicateBlock* profiled_loop_predicate_block = predicates.profiled_loop_predicate_block();\n-      if (profiled_loop_predicate_block->has_parse_predicate()) { \/\/ right pattern that can be used by loop predication\n-        IfProjNode* parse_predicate_proj = profiled_loop_predicate_block->parse_predicate_success_proj();\n-        useful_predicates.push(parse_predicate_proj->in(0)->in(1)->in(1)); \/\/ good one\n-        get_assertion_predicates(parse_predicate_proj, useful_predicates, true);\n-      }\n-    }\n+\/\/ Eliminate all Parse and Template Assertion Predicates that are not associated with a loop anymore. The eliminated\n+\/\/ predicates will be removed during the next round of IGVN.\n+void PhaseIdealLoop::eliminate_useless_predicates() {\n+  if (C->parse_predicate_count() == 0 && C->template_assertion_predicate_count() == 0) {\n+    return; \/\/ No predicates left.\n+  }\n@@ -4089,7 +4054,25 @@\n-    if (UseLoopPredicate) {\n-      const PredicateBlock* loop_predicate_block = predicates.loop_predicate_block();\n-      if (loop_predicate_block->has_parse_predicate()) { \/\/ right pattern that can be used by loop predication\n-        IfProjNode* parse_predicate_proj = loop_predicate_block->parse_predicate_success_proj();\n-        useful_predicates.push(parse_predicate_proj->in(0)->in(1)->in(1)); \/\/ good one\n-        get_assertion_predicates(parse_predicate_proj, useful_predicates, true);\n-      }\n+  eliminate_useless_parse_predicates();\n+  eliminate_useless_template_assertion_predicates();\n+}\n+\n+\/\/ Eliminate all Parse Predicates that do not belong to a loop anymore by marking them useless. These will be removed\n+\/\/ during the next round of IGVN.\n+void PhaseIdealLoop::eliminate_useless_parse_predicates() {\n+  mark_all_parse_predicates_useless();\n+  if (C->has_loops()) {\n+    mark_loop_associated_parse_predicates_useful();\n+  }\n+  add_useless_parse_predicates_to_igvn_worklist();\n+}\n+\n+void PhaseIdealLoop::mark_all_parse_predicates_useless() const {\n+  for (int i = 0; i < C->parse_predicate_count(); i++) {\n+    C->parse_predicate(i)->mark_useless();\n+  }\n+}\n+\n+void PhaseIdealLoop::mark_loop_associated_parse_predicates_useful() {\n+  for (LoopTreeIterator iterator(_ltree_root); !iterator.done(); iterator.next()) {\n+    IdealLoopTree* loop = iterator.current();\n+    if (loop->can_apply_loop_predication()) {\n+      mark_useful_parse_predicates_for_loop(loop);\n@@ -4098,0 +4081,1 @@\n+}\n@@ -4099,2 +4083,6 @@\n-  if (loop->_next) { \/\/ sibling\n-    collect_potentially_useful_predicates(loop->_next, useful_predicates);\n+void PhaseIdealLoop::mark_useful_parse_predicates_for_loop(IdealLoopTree* loop) {\n+  Node* entry = loop->_head->in(LoopNode::EntryControl);\n+  const Predicates predicates(entry);\n+  ParsePredicateIterator iterator(predicates);\n+  while (iterator.has_next()) {\n+    iterator.next()->mark_useful();\n@@ -4104,7 +4092,6 @@\n-\/\/------------------------eliminate_useless_predicates-----------------------------\n-\/\/ Eliminate all inserted predicates if they could not be used by loop predication.\n-\/\/ Note: it will also eliminates loop limits check predicate since it also uses\n-\/\/ Opaque1 node (see Parse::add_predicate()).\n-void PhaseIdealLoop::eliminate_useless_predicates() {\n-  if (C->parse_predicate_count() == 0 && C->template_assertion_predicate_count() == 0) {\n-    return; \/\/ no predicate left\n+void PhaseIdealLoop::add_useless_parse_predicates_to_igvn_worklist() {\n+  for (int i = 0; i < C->parse_predicate_count(); i++) {\n+    ParsePredicateNode* parse_predicate_node = C->parse_predicate(i);\n+    if (parse_predicate_node->is_useless()) {\n+      _igvn._worklist.push(parse_predicate_node);\n+    }\n@@ -4112,0 +4099,2 @@\n+}\n+\n@@ -4113,1 +4102,4 @@\n-  Unique_Node_List useful_predicates; \/\/ to store useful predicates\n+\/\/ Eliminate all Template Assertion Predicates that do not belong to their originally associated loop anymore by\n+\/\/ replacing the Opaque4 node of the If node with true. These nodes will be removed during the next round of IGVN.\n+void PhaseIdealLoop::eliminate_useless_template_assertion_predicates() {\n+  Unique_Node_List useful_predicates;\n@@ -4115,1 +4107,1 @@\n-    collect_potentially_useful_predicates(_ltree_root->_child, useful_predicates);\n+    collect_useful_template_assertion_predicates(useful_predicates);\n@@ -4117,0 +4109,2 @@\n+  eliminate_useless_template_assertion_predicates(useful_predicates);\n+}\n@@ -4118,6 +4112,6 @@\n-  for (int i = C->parse_predicate_count(); i > 0; i--) {\n-     Node* n = C->parse_predicate_opaque1_node(i - 1);\n-     assert(n->Opcode() == Op_Opaque1, \"must be\");\n-     if (!useful_predicates.member(n)) { \/\/ not in the useful list\n-       _igvn.replace_node(n, n->in(1));\n-     }\n+void PhaseIdealLoop::collect_useful_template_assertion_predicates(Unique_Node_List& useful_predicates) {\n+  for (LoopTreeIterator iterator(_ltree_root); !iterator.done(); iterator.next()) {\n+    IdealLoopTree* loop = iterator.current();\n+    if (loop->can_apply_loop_predication()) {\n+      collect_useful_template_assertion_predicates_for_loop(loop, useful_predicates);\n+    }\n@@ -4125,0 +4119,22 @@\n+}\n+\n+void PhaseIdealLoop::collect_useful_template_assertion_predicates_for_loop(IdealLoopTree* loop,\n+                                                                           Unique_Node_List &useful_predicates) {\n+  Node* entry = loop->_head->in(LoopNode::EntryControl);\n+  const Predicates predicates(entry);\n+  if (UseProfiledLoopPredicate) {\n+    const PredicateBlock* profiled_loop_predicate_block = predicates.profiled_loop_predicate_block();\n+    if (profiled_loop_predicate_block->has_parse_predicate()) {\n+      IfProjNode* parse_predicate_proj = profiled_loop_predicate_block->parse_predicate_success_proj();\n+      get_assertion_predicates(parse_predicate_proj, useful_predicates, true);\n+    }\n+  }\n+\n+  if (UseLoopPredicate) {\n+    const PredicateBlock* loop_predicate_block = predicates.loop_predicate_block();\n+    if (loop_predicate_block->has_parse_predicate()) {\n+      IfProjNode* parse_predicate_proj = loop_predicate_block->parse_predicate_success_proj();\n+      get_assertion_predicates(parse_predicate_proj, useful_predicates, true);\n+    }\n+  }\n+}\n@@ -4126,5 +4142,6 @@\n-  for (int i = C->template_assertion_predicate_count(); i > 0; i--) {\n-    Node* n = C->template_assertion_predicate_opaq_node(i - 1);\n-    assert(n->Opcode() == Op_Opaque4, \"must be\");\n-    if (!useful_predicates.member(n)) { \/\/ not in the useful list\n-      _igvn.replace_node(n, n->in(2));\n+void PhaseIdealLoop::eliminate_useless_template_assertion_predicates(Unique_Node_List& useful_predicates) {\n+  for (int i = 0; i < C->template_assertion_predicate_count(); i++) {\n+    Node* opaque4 = C->template_assertion_predicate_opaq_node(i);\n+    assert(opaque4->Opcode() == Op_Opaque4, \"must be\");\n+    if (!useful_predicates.member(opaque4)) { \/\/ not in the useful list\n+      _igvn.replace_node(opaque4, opaque4->in(2));\n@@ -4568,1 +4585,1 @@\n-  if (C->has_loops() && !C->major_progress() && (C->parse_predicate_count() > 0)) {\n+  if (UseLoopPredicate && C->has_loops() && !C->major_progress() && (C->parse_predicate_count() > 0)) {\n@@ -4621,1 +4638,2 @@\n-     C->cleanup_parse_predicates(_igvn);\n+    C->mark_parse_predicate_nodes_useless(_igvn);\n+    assert(C->parse_predicate_count() == 0, \"should be zero now\");\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":96,"deletions":78,"binary":false,"changes":174,"status":"modified"},{"patch":"@@ -649,0 +649,1 @@\n+  bool can_apply_loop_predication();\n@@ -1372,1 +1373,0 @@\n-  void collect_potentially_useful_predicates(IdealLoopTree *loop, Unique_Node_List &predicate_opaque1);\n@@ -1374,0 +1374,12 @@\n+\n+  void eliminate_useless_parse_predicates();\n+  void mark_all_parse_predicates_useless() const;\n+  void mark_loop_associated_parse_predicates_useful();\n+  static void mark_useful_parse_predicates_for_loop(IdealLoopTree* loop);\n+  void add_useless_parse_predicates_to_igvn_worklist();\n+\n+  void eliminate_useless_template_assertion_predicates();\n+  void collect_useful_template_assertion_predicates(Unique_Node_List& useful_predicates);\n+  static void collect_useful_template_assertion_predicates_for_loop(IdealLoopTree* loop, Unique_Node_List& useful_predicates);\n+  void eliminate_useless_template_assertion_predicates(Unique_Node_List& useful_predicates);\n+\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2063,1 +2063,1 @@\n-      if (use->is_If() || use->is_CMove() || C->is_predicate_opaq(use) || use->Opcode() == Op_Opaque4 ||\n+      if (use->is_If() || use->is_CMove() || use->Opcode() == Op_Opaque4 ||\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -225,6 +225,3 @@\n-  \/\/ we need \"If(Conv2B(Opaque1(...)))\" pattern for reason_predicate\n-  if (reason != Deoptimization::Reason_none) {\n-    if (iff->in(1)->Opcode() != Op_Conv2B ||\n-       iff->in(1)->in(1)->Opcode() != Op_Opaque1) {\n-      return nullptr;\n-    }\n+  \/\/ we need a ParsePredicate node for predicate reasons\n+  if (reason != Deoptimization::Reason_none && !iff->is_ParsePredicate()) {\n+    return nullptr;\n@@ -236,2 +233,1 @@\n-    assert(reason == Deoptimization::Reason_none ||\n-           Compile::current()->is_predicate_opaq(iff->in(1)->in(1)), \"should be on the list\");\n+    assert(reason == Deoptimization::Reason_none || iff->is_ParsePredicate(), \"sanity check\");\n","filename":"src\/hotspot\/share\/opto\/multnode.cpp","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -511,0 +511,4 @@\n+  if (n->is_ParsePredicate()) {\n+    C->add_parse_predicate(n->as_ParsePredicate());\n+  }\n+\n@@ -612,0 +616,3 @@\n+  if (is_ParsePredicate()) {\n+    compile->remove_parse_predicate(as_ParsePredicate());\n+  }\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -87,0 +87,24 @@\n+ParsePredicateIterator::ParsePredicateIterator(const Predicates& predicates) : _current_index(0) {\n+  const PredicateBlock* loop_limit_check_predicate_block = predicates.loop_limit_check_predicate_block();\n+  if (loop_limit_check_predicate_block->has_parse_predicate()) {\n+    _parse_predicates.push(loop_limit_check_predicate_block->parse_predicate());\n+  }\n+  if (UseProfiledLoopPredicate) {\n+    const PredicateBlock* profiled_loop_predicate_block = predicates.profiled_loop_predicate_block();\n+    if (profiled_loop_predicate_block->has_parse_predicate()) {\n+      _parse_predicates.push(profiled_loop_predicate_block->parse_predicate());\n+    }\n+  }\n+  if (UseLoopPredicate) {\n+    const PredicateBlock* loop_predicate_block = predicates.loop_predicate_block();\n+    if (loop_predicate_block->has_parse_predicate()) {\n+      _parse_predicates.push(loop_predicate_block->parse_predicate());\n+    }\n+  }\n+}\n+\n+ParsePredicateNode* ParsePredicateIterator::next() {\n+  assert(has_next(), \"always check has_next() first\");\n+  return _parse_predicates.at(_current_index++);\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/predicates.cpp","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -358,0 +358,15 @@\n+\n+\/\/ This class iterates over the Parse Predicates of a loop.\n+class ParsePredicateIterator : public StackObj {\n+  GrowableArray<ParsePredicateNode*> _parse_predicates;\n+  int _current_index;\n+\n+ public:\n+  ParsePredicateIterator(const Predicates& predicates);\n+\n+  bool has_next() const {\n+    return _current_index < _parse_predicates.length();\n+  }\n+\n+  ParsePredicateNode* next();\n+};\n","filename":"src\/hotspot\/share\/opto\/predicates.hpp","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"}]}