{"files":[{"patch":"@@ -367,0 +367,4 @@\n+\n+void Thread::unregister_thread_stack_with_NMT() {\n+  MemTracker::release_thread_stack(stack_end(), stack_size());\n+}\n@@ -432,13 +436,0 @@\n-  \/\/ stack_base can be NULL if the thread is never started or exited before\n-  \/\/ record_stack_base_and_size called. Although, we would like to ensure\n-  \/\/ that all started threads do call record_stack_base_and_size(), there is\n-  \/\/ not proper way to enforce that.\n-#if INCLUDE_NMT\n-  if (_stack_base != NULL) {\n-    MemTracker::release_thread_stack(stack_end(), stack_size());\n-#ifdef ASSERT\n-    set_stack_base(NULL);\n-#endif\n-  }\n-#endif \/\/ INCLUDE_NMT\n-\n@@ -1348,0 +1339,4 @@\n+  unregister_thread_stack_with_NMT();\n+  set_stack_base(NULL);\n+  set_stack_size(0);\n+\n@@ -2021,0 +2016,1 @@\n+  this->unregister_thread_stack_with_NMT();\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":9,"deletions":13,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -762,1 +762,5 @@\n-  address stack_base() const           { assert(_stack_base != NULL,\"Sanity check\"); return _stack_base; }\n+  address stack_base() const {\n+    assert(_stack_base  != NULL || Thread::current() != this, \"Sanity check\");\n+    return _stack_base;\n+  }\n+\n@@ -769,0 +773,1 @@\n+  void    unregister_thread_stack_with_NMT() NOT_NMT_RETURN;\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -350,1 +350,5 @@\n-    if (reserved_rgn->same_region(base_addr, size)) {\n+    \/\/ Deal with recursive reservation\n+    \/\/ os::reserve_memory() -> pd_reserve_memory() -> os::reserve_memory()\n+    \/\/ See JDK-8198226.\n+    if (reserved_rgn->same_region(base_addr, size) &&\n+        reserved_rgn->flag() == flag) {\n","filename":"src\/hotspot\/share\/services\/virtualMemoryTracker.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"}]}