{"files":[{"patch":"@@ -8565,1 +8565,1 @@\n-    __ mov($tmp$$FloatRegister, __ T1D, 0, $src$$Register);\n+    __ mov($tmp$$FloatRegister, __ D, 0, $src$$Register);\n@@ -8568,1 +8568,1 @@\n-    __ mov($dst$$Register, $tmp$$FloatRegister, __ T1D, 0);\n+    __ mov($dst$$Register, $tmp$$FloatRegister, __ D, 0);\n@@ -8590,1 +8590,1 @@\n-    __ mov($dst$$Register, $tmp$$FloatRegister, __ T1D, 0);\n+    __ mov($dst$$Register, $tmp$$FloatRegister, __ D, 0);\n@@ -8608,1 +8608,1 @@\n-    __ mov($tmp$$FloatRegister, __ T1D, 0, $src$$Register);\n+    __ mov($tmp$$FloatRegister, __ D, 0, $src$$Register);\n@@ -8611,1 +8611,1 @@\n-    __ mov($dst$$Register, $tmp$$FloatRegister, __ T1D, 0);\n+    __ mov($dst$$Register, $tmp$$FloatRegister, __ D, 0);\n@@ -8633,1 +8633,1 @@\n-    __ mov($dst$$Register, $tmp$$FloatRegister, __ T1D, 0);\n+    __ mov($dst$$Register, $tmp$$FloatRegister, __ D, 0);\n@@ -17018,1 +17018,2 @@\n-  effect(TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, USE_KILL src, USE_KILL dst, USE_KILL len, KILL cr);\n+  effect(TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4,\n+         USE_KILL src, USE_KILL dst, USE len, KILL cr);\n@@ -17020,1 +17021,1 @@\n-  format %{ \"String Compress $src,$dst -> $result    \/\/ KILL R1, R2, R3, R4\" %}\n+  format %{ \"String Compress $src,$dst,$len -> $result  \/\/ KILL $src,$dst\" %}\n@@ -17023,0 +17024,1 @@\n+                           $result$$Register,\n@@ -17024,2 +17026,1 @@\n-                           $tmp3$$FloatRegister, $tmp4$$FloatRegister,\n-                           $result$$Register);\n+                           $tmp3$$FloatRegister, $tmp4$$FloatRegister);\n@@ -17027,1 +17028,1 @@\n-  ins_pipe( pipe_slow );\n+  ins_pipe(pipe_slow);\n@@ -17052,2 +17053,2 @@\n-                          vRegD_V0 Vtmp1, vRegD_V1 Vtmp2,\n-                          vRegD_V2 Vtmp3, vRegD_V3 Vtmp4,\n+                          vRegD_V0 vtmp0, vRegD_V1 vtmp1,\n+                          vRegD_V2 vtmp2, vRegD_V3 vtmp3,\n@@ -17058,2 +17059,2 @@\n-  effect(USE_KILL src, USE_KILL dst, USE_KILL len,\n-         KILL Vtmp1, KILL Vtmp2, KILL Vtmp3, KILL Vtmp4, KILL cr);\n+  effect(USE_KILL src, USE_KILL dst, USE len,\n+         KILL vtmp0, KILL vtmp1, KILL vtmp2, KILL vtmp3, KILL cr);\n@@ -17061,1 +17062,1 @@\n-  format %{ \"Encode array $src,$dst,$len -> $result\" %}\n+  format %{ \"Encode ISO array $src,$dst,$len -> $result\" %}\n@@ -17064,2 +17065,3 @@\n-         $result$$Register, $Vtmp1$$FloatRegister,  $Vtmp2$$FloatRegister,\n-         $Vtmp3$$FloatRegister,  $Vtmp4$$FloatRegister);\n+                        $result$$Register, false,\n+                        $vtmp0$$FloatRegister, $vtmp1$$FloatRegister,\n+                        $vtmp2$$FloatRegister, $vtmp3$$FloatRegister);\n@@ -17067,1 +17069,21 @@\n-  ins_pipe( pipe_class_memory );\n+  ins_pipe(pipe_class_memory);\n+%}\n+\n+instruct encode_ascii_array(iRegP_R2 src, iRegP_R1 dst, iRegI_R3 len,\n+                            vRegD_V0 vtmp0, vRegD_V1 vtmp1,\n+                            vRegD_V2 vtmp2, vRegD_V3 vtmp3,\n+                            iRegI_R0 result, rFlagsReg cr)\n+%{\n+  predicate(((EncodeISOArrayNode*)n)->is_ascii());\n+  match(Set result (EncodeISOArray src (Binary dst len)));\n+  effect(USE_KILL src, USE_KILL dst, USE len,\n+         KILL vtmp0, KILL vtmp1, KILL vtmp2, KILL vtmp3, KILL cr);\n+\n+  format %{ \"Encode ASCII array $src,$dst,$len -> $result\" %}\n+  ins_encode %{\n+    __ encode_iso_array($src$$Register, $dst$$Register, $len$$Register,\n+                        $result$$Register, true,\n+                        $vtmp0$$FloatRegister, $vtmp1$$FloatRegister,\n+                        $vtmp2$$FloatRegister, $vtmp3$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_class_memory);\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":41,"deletions":19,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -3374,1 +3374,1 @@\n-      mov(v16, T4S, 0, crc);\n+      mov(v16, S, 0, crc);\n@@ -3478,1 +3478,1 @@\n-      mov(tmp, v0, T1D, 0);\n+      mov(tmp, v0, D, 0);\n@@ -3481,1 +3481,1 @@\n-      mov(tmp, v0, T1D, 1);\n+      mov(tmp, v0, D, 1);\n@@ -3484,1 +3484,1 @@\n-      mov(tmp, v1, T1D, 0);\n+      mov(tmp, v1, D, 0);\n@@ -3487,1 +3487,1 @@\n-      mov(tmp, v1, T1D, 1);\n+      mov(tmp, v1, D, 1);\n@@ -4930,2 +4930,18 @@\n-\/\/ Intrinsic for sun\/nio\/cs\/ISO_8859_1$Encoder.implEncodeISOArray and\n-\/\/ java\/lang\/StringUTF16.compress.\n+\/\/ Intrinsic for\n+\/\/\n+\/\/ - sun\/nio\/cs\/ISO_8859_1$Encoder.implEncodeISOArray\n+\/\/     return the number of characters copied.\n+\/\/ - java\/lang\/StringUTF16.compress\n+\/\/     return zero (0) if copy fails, otherwise 'len'.\n+\/\/\n+\/\/ This version always returns the number of characters copied, and does not\n+\/\/ clobber the 'len' register. A successful copy will complete with the post-\n+\/\/ condition: 'res' == 'len', while an unsuccessful copy will exit with the\n+\/\/ post-condition: 0 <= 'res' < 'len'.\n+\/\/\n+\/\/ NOTE: Attempts to use 'ld2' (and 'umaxv' in the ISO part) has proven to\n+\/\/       degrade performance (on Ampere Altra - Neoverse N1), to an extent\n+\/\/       beyond the acceptable, even though the footprint would be smaller.\n+\/\/       Using 'umaxv' in the ASCII-case comes with a small penalty but does\n+\/\/       avoid additional bloat.\n+\/\/\n@@ -4933,3 +4949,3 @@\n-                      Register len, Register result,\n-                      FloatRegister Vtmp1, FloatRegister Vtmp2,\n-                      FloatRegister Vtmp3, FloatRegister Vtmp4)\n+                                      Register len, Register res, bool ascii,\n+                                      FloatRegister vtmp0, FloatRegister vtmp1,\n+                                      FloatRegister vtmp2, FloatRegister vtmp3)\n@@ -4937,97 +4953,8 @@\n-    Label DONE, SET_RESULT, NEXT_32, NEXT_32_PRFM, LOOP_8, NEXT_8, LOOP_1, NEXT_1,\n-        NEXT_32_START, NEXT_32_PRFM_START;\n-    Register tmp1 = rscratch1, tmp2 = rscratch2;\n-\n-      mov(result, len); \/\/ Save initial len\n-\n-      cmp(len, (u1)8); \/\/ handle shortest strings first\n-      br(LT, LOOP_1);\n-      cmp(len, (u1)32);\n-      br(LT, NEXT_8);\n-      \/\/ The following code uses the SIMD 'uzp1' and 'uzp2' instructions\n-      \/\/ to convert chars to bytes\n-      if (SoftwarePrefetchHintDistance >= 0) {\n-        ld1(Vtmp1, Vtmp2, Vtmp3, Vtmp4, T8H, src);\n-        subs(tmp2, len, SoftwarePrefetchHintDistance\/2 + 16);\n-        br(LE, NEXT_32_START);\n-        b(NEXT_32_PRFM_START);\n-        BIND(NEXT_32_PRFM);\n-          ld1(Vtmp1, Vtmp2, Vtmp3, Vtmp4, T8H, src);\n-        BIND(NEXT_32_PRFM_START);\n-          prfm(Address(src, SoftwarePrefetchHintDistance));\n-          orr(v4, T16B, Vtmp1, Vtmp2);\n-          orr(v5, T16B, Vtmp3, Vtmp4);\n-          uzp1(Vtmp1, T16B, Vtmp1, Vtmp2);\n-          uzp1(Vtmp3, T16B, Vtmp3, Vtmp4);\n-          uzp2(v5, T16B, v4, v5); \/\/ high bytes\n-          umov(tmp2, v5, D, 1);\n-          fmovd(tmp1, v5);\n-          orr(tmp1, tmp1, tmp2);\n-          cbnz(tmp1, LOOP_8);\n-          stpq(Vtmp1, Vtmp3, dst);\n-          sub(len, len, 32);\n-          add(dst, dst, 32);\n-          add(src, src, 64);\n-          subs(tmp2, len, SoftwarePrefetchHintDistance\/2 + 16);\n-          br(GE, NEXT_32_PRFM);\n-          cmp(len, (u1)32);\n-          br(LT, LOOP_8);\n-        BIND(NEXT_32);\n-          ld1(Vtmp1, Vtmp2, Vtmp3, Vtmp4, T8H, src);\n-        BIND(NEXT_32_START);\n-      } else {\n-        BIND(NEXT_32);\n-          ld1(Vtmp1, Vtmp2, Vtmp3, Vtmp4, T8H, src);\n-      }\n-      prfm(Address(src, SoftwarePrefetchHintDistance));\n-      uzp1(v4, T16B, Vtmp1, Vtmp2);\n-      uzp1(v5, T16B, Vtmp3, Vtmp4);\n-      orr(Vtmp1, T16B, Vtmp1, Vtmp2);\n-      orr(Vtmp3, T16B, Vtmp3, Vtmp4);\n-      uzp2(Vtmp1, T16B, Vtmp1, Vtmp3); \/\/ high bytes\n-      umov(tmp2, Vtmp1, D, 1);\n-      fmovd(tmp1, Vtmp1);\n-      orr(tmp1, tmp1, tmp2);\n-      cbnz(tmp1, LOOP_8);\n-      stpq(v4, v5, dst);\n-      sub(len, len, 32);\n-      add(dst, dst, 32);\n-      add(src, src, 64);\n-      cmp(len, (u1)32);\n-      br(GE, NEXT_32);\n-      cbz(len, DONE);\n-\n-    BIND(LOOP_8);\n-      cmp(len, (u1)8);\n-      br(LT, LOOP_1);\n-    BIND(NEXT_8);\n-      ld1(Vtmp1, T8H, src);\n-      uzp1(Vtmp2, T16B, Vtmp1, Vtmp1); \/\/ low bytes\n-      uzp2(Vtmp3, T16B, Vtmp1, Vtmp1); \/\/ high bytes\n-      fmovd(tmp1, Vtmp3);\n-      cbnz(tmp1, NEXT_1);\n-      strd(Vtmp2, dst);\n-\n-      sub(len, len, 8);\n-      add(dst, dst, 8);\n-      add(src, src, 16);\n-      cmp(len, (u1)8);\n-      br(GE, NEXT_8);\n-\n-    BIND(LOOP_1);\n-\n-    cbz(len, DONE);\n-    BIND(NEXT_1);\n-      ldrh(tmp1, Address(post(src, 2)));\n-      tst(tmp1, 0xff00);\n-      br(NE, SET_RESULT);\n-      strb(tmp1, Address(post(dst, 1)));\n-      subs(len, len, 1);\n-      br(GT, NEXT_1);\n-\n-    BIND(SET_RESULT);\n-      sub(result, result, len); \/\/ Return index where we stopped\n-                                \/\/ Return len == 0 if we processed all\n-                                \/\/ characters\n-    BIND(DONE);\n-}\n+  Register cnt = res;\n+  Register max = rscratch1;\n+  Register chk = rscratch2;\n+\n+  prfm(Address(src), PLDL1STRM);\n+  movw(cnt, len);\n+\n+#define ASCII(insn) do { if (ascii) { insn; } } while (0)\n@@ -5035,0 +4962,80 @@\n+  Label LOOP_32, DONE_32, FAIL_32;\n+\n+  BIND(LOOP_32);\n+  {\n+    cmpw(cnt, 32);\n+    br(LT, DONE_32);\n+    ld1(vtmp0, vtmp1, vtmp2, vtmp3, T8H, Address(post(src, 64)));\n+    \/\/ Extract lower bytes.\n+    FloatRegister vlo0 = v4;\n+    FloatRegister vlo1 = v5;\n+    uzp1(vlo0, T16B, vtmp0, vtmp1);\n+    uzp1(vlo1, T16B, vtmp2, vtmp3);\n+    \/\/ Merge bits...\n+    orr(vtmp0, T16B, vtmp0, vtmp1);\n+    orr(vtmp2, T16B, vtmp2, vtmp3);\n+    \/\/ Extract merged upper bytes.\n+    FloatRegister vhix = vtmp0;\n+    uzp2(vhix, T16B, vtmp0, vtmp2);\n+    \/\/ ISO-check on hi-parts (all zero).\n+    \/\/                          ASCII-check on lo-parts (no sign).\n+    FloatRegister vlox = vtmp1; \/\/ Merge lower bytes.\n+                                ASCII(orr(vlox, T16B, vlo0, vlo1));\n+    umov(chk, vhix, D, 1);      ASCII(cmlt(vlox, T16B, vlox));\n+    fmovd(max, vhix);           ASCII(umaxv(vlox, T16B, vlox));\n+    orr(chk, chk, max);         ASCII(umov(max, vlox, B, 0));\n+                                ASCII(orr(chk, chk, max));\n+    cbnz(chk, FAIL_32);\n+    subw(cnt, cnt, 32);\n+    st1(vlo0, vlo1, T16B, Address(post(dst, 32)));\n+    b(LOOP_32);\n+  }\n+  BIND(FAIL_32);\n+  sub(src, src, 64);\n+  BIND(DONE_32);\n+\n+  Label LOOP_8, SKIP_8;\n+\n+  BIND(LOOP_8);\n+  {\n+    cmpw(cnt, 8);\n+    br(LT, SKIP_8);\n+    FloatRegister vhi = vtmp0;\n+    FloatRegister vlo = vtmp1;\n+    ld1(vtmp3, T8H, src);\n+    uzp1(vlo, T16B, vtmp3, vtmp3);\n+    uzp2(vhi, T16B, vtmp3, vtmp3);\n+    \/\/ ISO-check on hi-parts (all zero).\n+    \/\/                          ASCII-check on lo-parts (no sign).\n+                                ASCII(cmlt(vtmp2, T16B, vlo));\n+    fmovd(chk, vhi);            ASCII(umaxv(vtmp2, T16B, vtmp2));\n+                                ASCII(umov(max, vtmp2, B, 0));\n+                                ASCII(orr(chk, chk, max));\n+    cbnz(chk, SKIP_8);\n+\n+    strd(vlo, Address(post(dst, 8)));\n+    subw(cnt, cnt, 8);\n+    add(src, src, 16);\n+    b(LOOP_8);\n+  }\n+  BIND(SKIP_8);\n+\n+#undef ASCII\n+\n+  Label LOOP, DONE;\n+\n+  cbz(cnt, DONE);\n+  BIND(LOOP);\n+  {\n+    Register chr = rscratch1;\n+    ldrh(chr, Address(post(src, 2)));\n+    tst(chr, ascii ? 0xff80 : 0xff00);\n+    br(NE, DONE);\n+    strb(chr, Address(post(dst, 1)));\n+    subs(cnt, cnt, 1);\n+    br(GT, LOOP);\n+  }\n+  BIND(DONE);\n+  \/\/ Return index where we stopped.\n+  subw(res, len, cnt);\n+}\n@@ -5143,7 +5150,7 @@\n-                                         FloatRegister tmp1Reg, FloatRegister tmp2Reg,\n-                                         FloatRegister tmp3Reg, FloatRegister tmp4Reg,\n-                                         Register result) {\n-  encode_iso_array(src, dst, len, result,\n-                   tmp1Reg, tmp2Reg, tmp3Reg, tmp4Reg);\n-  cmp(len, zr);\n-  csel(result, result, zr, EQ);\n+                                         Register res,\n+                                         FloatRegister tmp0, FloatRegister tmp1,\n+                                         FloatRegister tmp2, FloatRegister tmp3) {\n+  encode_iso_array(src, dst, len, res, false, tmp0, tmp1, tmp2, tmp3);\n+  \/\/ Adjust result: res == len ? len : 0\n+  cmp(len, res);\n+  csel(res, res, zr, EQ);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":121,"deletions":114,"binary":false,"changes":235,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"metaprogramming\/enableIf.hpp\"\n@@ -496,6 +497,2 @@\n-  inline void mov(Register dst, int imm64)                { mov_immediate64(dst, (uint64_t)imm64); }\n-  inline void mov(Register dst, long imm64)               { mov_immediate64(dst, (uint64_t)imm64); }\n-  inline void mov(Register dst, long long imm64)          { mov_immediate64(dst, (uint64_t)imm64); }\n-  inline void mov(Register dst, unsigned int imm64)       { mov_immediate64(dst, (uint64_t)imm64); }\n-  inline void mov(Register dst, unsigned long imm64)      { mov_immediate64(dst, (uint64_t)imm64); }\n-  inline void mov(Register dst, unsigned long long imm64) { mov_immediate64(dst, (uint64_t)imm64); }\n+  template<typename T, ENABLE_IF(std::is_integral<T>::value)>\n+  inline void mov(Register dst, T o)                      { mov_immediate64(dst, (uint64_t)o); }\n@@ -503,4 +500,1 @@\n-  inline void movw(Register dst, uint32_t imm32)\n-  {\n-    mov_immediate32(dst, imm32);\n-  }\n+  inline void movw(Register dst, uint32_t imm32)          { mov_immediate32(dst, imm32); }\n@@ -1263,3 +1257,3 @@\n-                           FloatRegister tmp1Reg, FloatRegister tmp2Reg,\n-                           FloatRegister tmp3Reg, FloatRegister tmp4Reg,\n-                           Register result);\n+                           Register res,\n+                           FloatRegister vtmp0, FloatRegister vtmp1,\n+                           FloatRegister vtmp2, FloatRegister vtmp3);\n@@ -1268,3 +1262,4 @@\n-                        Register len, Register result,\n-                        FloatRegister Vtmp1, FloatRegister Vtmp2,\n-                        FloatRegister Vtmp3, FloatRegister Vtmp4);\n+                        Register len, Register res, bool ascii,\n+                        FloatRegister vtmp0, FloatRegister vtmp1,\n+                        FloatRegister vtmp2, FloatRegister vtmp3);\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":11,"deletions":16,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -3096,1 +3096,1 @@\n-  \/\/ necesary if std_entry is also a backward branch target because\n+  \/\/ necessary if std_entry is also a backward branch target because\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -142,0 +142,2 @@\n+#define JAVA_19_VERSION                   63\n+\n@@ -4531,1 +4533,0 @@\n-  const bool major_gte_14  = _major_version >= JAVA_14_VERSION;\n@@ -4787,1 +4788,1 @@\n-\/\/ be taken as a fieldname. Allow '\/' if slash_ok is true.\n+\/\/ be taken as a fieldname. Allow non-trailing '\/'s if slash_ok is true.\n@@ -4861,1 +4862,1 @@\n-  return (not_first_ch) ? p : NULL;\n+  return (not_first_ch && !last_is_slash) ? p : NULL;\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -160,1 +160,1 @@\n-        if (OAEPParameterSpec.class.isAssignableFrom(paramSpec)) {\n+        if (paramSpec.isAssignableFrom(OAEPParameterSpec.class)) {\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/OAEPParameters.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n-import java.io.ObjectStreamClass.WeakClassKey;\n@@ -33,1 +32,0 @@\n-import java.lang.ref.ReferenceQueue;\n@@ -46,4 +44,0 @@\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.concurrent.ConcurrentMap;\n-\n-import static java.io.ObjectStreamClass.processQueue;\n@@ -285,6 +279,7 @@\n-        static final ConcurrentMap<WeakClassKey,Boolean> subclassAudits =\n-            new ConcurrentHashMap<>();\n-\n-        \/** queue for WeakReferences to audited subclasses *\/\n-        static final ReferenceQueue<Class<?>> subclassAuditsQueue =\n-            new ReferenceQueue<>();\n+        static final ClassValue<Boolean> subclassAudits =\n+            new ClassValue<>() {\n+                @Override\n+                protected Boolean computeValue(Class<?> type) {\n+                    return auditSubclass(type);\n+                }\n+            };\n@@ -746,1 +741,1 @@\n-     * @param   prio controls the order of callbacks;zero is a good default.\n+     * @param   prio controls the order of callbacks; zero is a good default.\n@@ -1643,7 +1638,1 @@\n-        processQueue(Caches.subclassAuditsQueue, Caches.subclassAudits);\n-        WeakClassKey key = new WeakClassKey(cl, Caches.subclassAuditsQueue);\n-        Boolean result = Caches.subclassAudits.get(key);\n-        if (result == null) {\n-            result = auditSubclass(cl);\n-            Caches.subclassAudits.putIfAbsent(key, result);\n-        }\n+        boolean result = Caches.subclassAudits.get(cl);\n","filename":"src\/java.base\/share\/classes\/java\/io\/ObjectInputStream.java","additions":10,"deletions":21,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -1798,0 +1798,2 @@\n+                } else if (cursor == patternLength + 1 && temp[patternLength - 1] == '\\\\') {\n+                    throw error(\"Unescaped trailing backslash\");\n","filename":"src\/java.base\/share\/classes\/java\/util\/regex\/Pattern.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -188,1 +188,1 @@\n-        if (PSSParameterSpec.class.isAssignableFrom(paramSpec)) {\n+        if (paramSpec.isAssignableFrom(PSSParameterSpec.class)) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/rsa\/PSSParameters.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -672,10 +672,2 @@\n-        InputStream iis = new InflaterInputStream(bais);\n-        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n-\n-        int c;\n-        try {\n-            while ((c = iis.read()) != -1) {\n-                baos.write(c);\n-            }\n-        } finally {\n-            iis.close();\n+        try (InputStream iis = new InflaterInputStream(bais)) {\n+            return iis.readAllBytes();\n@@ -683,1 +675,0 @@\n-        return baos.toByteArray();\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/imageio\/plugins\/png\/PNGImageReader.java","additions":2,"deletions":11,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -149,7 +149,5 @@\n-        InputStream urlStream = url.openStream(); \/\/ throws IOException\n-        BufferedInputStream bis = new BufferedInputStream( urlStream, bisBufferSize );\n-        MidiFileFormat fileFormat = null;\n-        try {\n-            fileFormat = getMidiFileFormat( bis ); \/\/ throws InvalidMidiDataException\n-        } finally {\n-            bis.close();\n+        try (InputStream urlStream = url.openStream(); \/\/ throws IOException\n+             BufferedInputStream bis = new BufferedInputStream(urlStream, bisBufferSize))\n+        {\n+            MidiFileFormat fileFormat = getMidiFileFormat(bis); \/\/ throws InvalidMidiDataException\n+            return fileFormat;\n@@ -157,1 +155,0 @@\n-        return fileFormat;\n@@ -162,13 +159,10 @@\n-        FileInputStream fis = new FileInputStream(file); \/\/ throws IOException\n-        BufferedInputStream bis = new BufferedInputStream(fis, bisBufferSize);\n-\n-        \/\/ $$fb 2002-04-17: part of fix for 4635286: MidiSystem.getMidiFileFormat() returns format having invalid length\n-        long length = file.length();\n-        if (length > Integer.MAX_VALUE) {\n-            length = MidiFileFormat.UNKNOWN_LENGTH;\n-        }\n-        MidiFileFormat fileFormat = null;\n-        try {\n-            fileFormat = getMidiFileFormatFromStream(bis, (int) length, null);\n-        } finally {\n-            bis.close();\n+        try (FileInputStream fis = new FileInputStream(file); \/\/ throws IOException\n+             BufferedInputStream bis = new BufferedInputStream(fis, bisBufferSize))\n+        {\n+            \/\/ $$fb 2002-04-17: part of fix for 4635286: MidiSystem.getMidiFileFormat() returns format having invalid length\n+            long length = file.length();\n+            if (length > Integer.MAX_VALUE) {\n+                length = MidiFileFormat.UNKNOWN_LENGTH;\n+            }\n+            MidiFileFormat fileFormat = getMidiFileFormatFromStream(bis, (int) length, null);\n+            return fileFormat;\n@@ -176,1 +170,0 @@\n-        return fileFormat;\n@@ -207,7 +200,5 @@\n-        InputStream is = url.openStream();  \/\/ throws IOException\n-        is = new BufferedInputStream(is, bisBufferSize);\n-        Sequence seq = null;\n-        try {\n-            seq = getSequence(is);\n-        } finally {\n-            is.close();\n+        try (InputStream is = url.openStream(); \/\/ throws IOException\n+             BufferedInputStream bis = new BufferedInputStream(is, bisBufferSize))\n+        {\n+            Sequence seq = getSequence(bis);\n+            return seq;\n@@ -215,1 +206,0 @@\n-        return seq;\n@@ -220,7 +210,5 @@\n-        InputStream is = new FileInputStream(file); \/\/ throws IOException\n-        is = new BufferedInputStream(is, bisBufferSize);\n-        Sequence seq = null;\n-        try {\n-            seq = getSequence(is);\n-        } finally {\n-            is.close();\n+        try (InputStream is = new FileInputStream(file); \/\/ throws IOException\n+             BufferedInputStream bis = new BufferedInputStream(is, bisBufferSize))\n+        {\n+            Sequence seq = getSequence(bis);\n+            return seq;\n@@ -228,1 +216,0 @@\n-        return seq;\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/media\/sound\/StandardMidiFileReader.java","additions":26,"deletions":39,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -524,0 +524,12 @@\n+\n+            if (dispatcherThread == Thread.currentThread()) {\n+                try {\n+                    \/\/ call selector to process cancelled keys\n+                    selector.selectNow();\n+                } catch (IOException ioe) {\n+                    logger.log(Level.DEBUG, \"processing of cancelled keys failed: closing\");\n+                    closeConnection(connection);\n+                    return;\n+                }\n+            }\n+\n","filename":"src\/jdk.httpserver\/share\/classes\/sun\/net\/httpserver\/ServerImpl.java","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"}]}