{"files":[{"patch":"@@ -61,1 +61,0 @@\n-  _gc_par_phases[ObjectSynchronizerRoots] = new WorkerDataArray<double>(\"ObjectSynchronizerRoots\", \"ObjectSynchronizer Roots (ms):\", max_gc_threads);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1GCPhaseTimes.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -51,1 +51,0 @@\n-    ObjectSynchronizerRoots,\n","filename":"src\/hotspot\/share\/gc\/g1\/g1GCPhaseTimes.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -183,7 +183,0 @@\n-  {\n-    G1GCParPhaseTimesTracker x(phase_times, G1GCPhaseTimes::ObjectSynchronizerRoots, worker_id);\n-    if (_process_strong_tasks.try_claim_task(G1RP_PS_ObjectSynchronizer_oops_do)) {\n-      ObjectSynchronizer::oops_do(strong_roots);\n-    }\n-  }\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RootProcessor.cpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -57,1 +57,0 @@\n-    G1RP_PS_ObjectSynchronizer_oops_do,\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RootProcessor.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2013,4 +2013,0 @@\n-    case ParallelRootType::object_synchronizer:\n-      ObjectSynchronizer::oops_do(&mark_and_push_closure);\n-      break;\n-\n@@ -2227,1 +2223,0 @@\n-  ObjectSynchronizer::oops_do(&oop_closure);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-    object_synchronizer,\n","filename":"src\/hotspot\/share\/gc\/parallel\/psRootType.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -95,4 +95,0 @@\n-    case ParallelRootType::object_synchronizer:\n-      ObjectSynchronizer::oops_do(&roots_closure);\n-      break;\n-\n","filename":"src\/hotspot\/share\/gc\/parallel\/psScavenge.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -820,3 +820,0 @@\n-  if (_process_strong_tasks->try_claim_task(GCH_PS_ObjectSynchronizer_oops_do)) {\n-    ObjectSynchronizer::oops_do(strong_roots);\n-  }\n","filename":"src\/hotspot\/share\/gc\/shared\/genCollectedHeap.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -108,1 +108,0 @@\n-    GCH_PS_ObjectSynchronizer_oops_do,\n","filename":"src\/hotspot\/share\/gc\/shared\/genCollectedHeap.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-  static const uint weak_count = 4 JFR_ONLY(+ 1);\n+  static const uint weak_count = 5 JFR_ONLY(+ 1);\n","filename":"src\/hotspot\/share\/gc\/shared\/oopStorageSet.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -166,4 +166,0 @@\n-    assert(!space->scanned_block_is_obj(cur_obj) ||\n-           oop(cur_obj)->mark_raw().is_marked() || oop(cur_obj)->mark_raw().is_unlocked() ||\n-           oop(cur_obj)->mark_raw().has_bias_pattern(),\n-           \"these are the only valid states during a mark sweep\");\n@@ -178,0 +174,3 @@\n+      assert(!space->scanned_block_is_obj(cur_obj) || oop(cur_obj)->mark_raw().is_unlocked() ||\n+             oop(cur_obj)->mark_raw().has_bias_pattern() || oop(cur_obj)->mark_raw().has_monitor(),\n+             \"these are the only valid states during a mark sweep\");\n","filename":"src\/hotspot\/share\/gc\/shared\/space.inline.hpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -42,1 +42,0 @@\n-  f(CNT_PREFIX ## ObjectSynchronizerRoots,  DESC_PREFIX \"Synchronizer Roots\")          \\\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahPhaseTimings.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -42,20 +42,0 @@\n-ShenandoahSerialRoot::ShenandoahSerialRoot(ShenandoahSerialRoot::OopsDo oops_do,\n-  ShenandoahPhaseTimings::Phase phase, ShenandoahPhaseTimings::ParPhase par_phase) :\n-  _oops_do(oops_do), _phase(phase), _par_phase(par_phase) {\n-}\n-\n-void ShenandoahSerialRoot::oops_do(OopClosure* cl, uint worker_id) {\n-  if (_claimed.try_set()) {\n-    ShenandoahWorkerTimingsTracker timer(_phase, _par_phase, worker_id);\n-    _oops_do(cl);\n-  }\n-}\n-\n-ShenandoahSerialRoots::ShenandoahSerialRoots(ShenandoahPhaseTimings::Phase phase) :\n-  _object_synchronizer_root(&ObjectSynchronizer::oops_do, phase, ShenandoahPhaseTimings::ObjectSynchronizerRoots) {\n-}\n-\n-void ShenandoahSerialRoots::oops_do(OopClosure* cl, uint worker_id) {\n-  _object_synchronizer_root.oops_do(cl, worker_id);\n-}\n-\n@@ -185,1 +165,0 @@\n-  _serial_roots(phase),\n@@ -214,1 +193,0 @@\n-\n@@ -216,5 +194,0 @@\n-\n-  \/\/ Process serial-claiming roots first\n-  _serial_roots.oops_do(oops, worker_id);\n-\n-  \/\/ Process heavy-weight\/fully parallel roots the last\n@@ -227,1 +200,0 @@\n-\n@@ -229,5 +201,0 @@\n-\n-  \/\/ Process serial-claiming roots first\n-  _serial_roots.oops_do(oops, worker_id);\n-\n-  \/\/ Process heavy-weight\/fully parallel roots the last\n@@ -242,1 +209,0 @@\n-  _serial_roots(phase),\n@@ -263,1 +229,0 @@\n-  _serial_roots.oops_do(oops, worker_id);\n@@ -288,1 +253,0 @@\n-  _serial_roots(phase),\n@@ -300,1 +264,0 @@\n-  _serial_roots(phase),\n@@ -321,1 +284,0 @@\n-  _serial_roots.oops_do(oops, worker_id);\n@@ -337,1 +299,0 @@\n-   _serial_roots(ShenandoahPhaseTimings::heap_iteration_roots),\n@@ -358,1 +319,0 @@\n-   _serial_roots.oops_do(oops, 0);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahRootProcessor.cpp","additions":0,"deletions":40,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -52,8 +52,0 @@\n-class ShenandoahSerialRoots {\n-private:\n-  ShenandoahSerialRoot  _object_synchronizer_root;\n-public:\n-  ShenandoahSerialRoots(ShenandoahPhaseTimings::Phase phase);\n-  void oops_do(OopClosure* cl, uint worker_id);\n-};\n-\n@@ -202,1 +194,0 @@\n-  ShenandoahSerialRoots                                     _serial_roots;\n@@ -241,1 +232,0 @@\n-  ShenandoahSerialRoots                                    _serial_roots;\n@@ -260,1 +250,0 @@\n-  ShenandoahSerialRoots                                     _serial_roots;\n@@ -281,1 +270,0 @@\n-  ShenandoahSerialRoots                                     _serial_roots;\n@@ -301,1 +289,0 @@\n-  ShenandoahSerialRoots                                     _serial_roots;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahRootProcessor.hpp","additions":0,"deletions":13,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -201,1 +201,0 @@\n-  _serial_roots.oops_do(keep_alive, worker_id);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahRootProcessor.inline.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -77,1 +77,0 @@\n-    ObjectSynchronizer::oops_do(oops);\n@@ -121,1 +120,0 @@\n-  ObjectSynchronizer::oops_do(oops);\n@@ -146,1 +144,0 @@\n-  ObjectSynchronizer::oops_do(oops);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahRootVerifier.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -57,1 +57,0 @@\n-static const ZStatSubPhase ZSubPhasePauseRootsObjectSynchronizer(\"Pause Roots ObjectSynchronizer\");\n@@ -187,1 +186,0 @@\n-    _object_synchronizer(this),\n@@ -214,5 +212,0 @@\n-void ZRootsIterator::do_object_synchronizer(ZRootsIteratorClosure* cl) {\n-  ZStatTimer timer(ZSubPhasePauseRootsObjectSynchronizer);\n-  ObjectSynchronizer::oops_do(cl);\n-}\n-\n@@ -244,1 +237,0 @@\n-  _object_synchronizer.oops_do(cl);\n","filename":"src\/hotspot\/share\/gc\/z\/zRootsIterator.cpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -113,1 +113,0 @@\n-  void do_object_synchronizer(ZRootsIteratorClosure* cl);\n@@ -119,1 +118,0 @@\n-  ZSerialOopsDo<ZRootsIterator, &ZRootsIterator::do_object_synchronizer> _object_synchronizer;\n","filename":"src\/hotspot\/share\/gc\/z\/zRootsIterator.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -74,1 +74,0 @@\n-  ObjectSynchronizer::oops_do(this);\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/chains\/rootSetClosure.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -98,1 +98,0 @@\n-  bool do_object_synchronizer_roots();\n@@ -132,7 +131,0 @@\n-bool ReferenceToRootClosure::do_object_synchronizer_roots() {\n-  assert(!complete(), \"invariant\");\n-  ReferenceLocateClosure rlc(_callback, OldObjectRoot::_object_synchronizer, OldObjectRoot::_type_undetermined, NULL);\n-  ObjectSynchronizer::oops_do(&rlc);\n-  return rlc.complete();\n-}\n-\n@@ -174,5 +166,0 @@\n-  if (do_object_synchronizer_roots()) {\n-   _complete = true;\n-    return true;\n-  }\n-\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/checkpoint\/rootResolver.cpp","additions":0,"deletions":13,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -57,2 +57,0 @@\n-    case _object_synchronizer:\n-      return \"Object Monitor\";\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/utilities\/rootType.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,1 +39,0 @@\n-    _object_synchronizer,\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/utilities\/rootType.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -34,2 +34,5 @@\n-    _obj(storage->allocate()) {\n-  assert(obj() != NULL, \"no need to create weak null oop\");\n+    WeakHandle(storage, obj()) {}\n+\n+WeakHandle::WeakHandle(OopStorage* storage, oop obj) :\n+  _obj(storage->allocate()) {\n+  assert(obj != NULL, \"no need to create weak null oop\");\n@@ -43,1 +46,1 @@\n-  NativeAccess<ON_PHANTOM_OOP_REF>::oop_store(_obj, obj());\n+  NativeAccess<ON_PHANTOM_OOP_REF>::oop_store(_obj, obj);\n","filename":"src\/hotspot\/share\/oops\/weakHandle.cpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -51,0 +51,1 @@\n+  WeakHandle(OopStorage* storage, oop obj);\n","filename":"src\/hotspot\/share\/oops\/weakHandle.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3020,7 +3020,0 @@\n-  \/\/ Inflated monitors\n-  blk.set_kind(JVMTI_HEAP_REFERENCE_MONITOR);\n-  ObjectSynchronizer::oops_do(&blk);\n-  if (blk.stopped()) {\n-    return false;\n-  }\n-\n","filename":"src\/hotspot\/share\/prims\/jvmtiTagMap.cpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+#include \"gc\/shared\/oopStorage.hpp\"\n+#include \"gc\/shared\/oopStorageSet.hpp\"\n@@ -117,0 +119,2 @@\n+OopStorage* ObjectMonitor::_oop_storage = NULL;\n+\n@@ -240,0 +244,43 @@\n+\/\/ Check that object() and set_object() are called from the right context:\n+static void check_object_context() {\n+  Thread* self = Thread::current();\n+  \/\/ ThreadService::get_current_contended_monitor() can call here via\n+  \/\/ the VMThread so sanity check it.\n+  guarantee(self->is_Java_thread() || self->is_VM_thread(), \"must be\");\n+  if (self->is_Java_thread()) {\n+    JavaThread* jt = self->as_Java_thread();\n+    switch (jt->thread_state()) {\n+    case _thread_in_vm:    \/\/ the usual case\n+    case _thread_in_Java:  \/\/ during deopt\n+      break;\n+    default:\n+      fatal(\"called from an unsafe thread state\");\n+    }\n+    guarantee(jt->is_active_Java_thread(), \"must be active JavaThread\");\n+  }\n+}\n+\n+oop ObjectMonitor::object() const {\n+  check_object_context();\n+  if (_object.is_null()) {\n+    return NULL;\n+  }\n+  return _object.resolve();\n+}\n+\n+oop ObjectMonitor::object_peek() const {\n+  if (_object.is_null()) {\n+    return NULL;\n+  }\n+  return _object.peek();\n+}\n+\n+void ObjectMonitor::set_object(oop obj) {\n+  check_object_context();\n+  if (_object.is_null()) {\n+    _object = WeakHandle(_oop_storage, obj);\n+  } else {\n+    _object.replace(obj);\n+  }\n+}\n+\n@@ -449,1 +496,1 @@\n-  const oop l_object = object();\n+  const oop l_object = object_peek();\n@@ -452,1 +499,1 @@\n-    \/\/ deflation so we're done here.\n+    \/\/ deflation or GC so we're done here.\n@@ -706,1 +753,0 @@\n-  assert(object() != NULL, \"invariant\");\n@@ -2058,0 +2104,2 @@\n+  _oop_storage = OopStorageSet::create_weak(\"ObjectSynchronizer Weak\");\n+\n@@ -2106,1 +2154,1 @@\n-  st->print_cr(\"  _object = \" INTPTR_FORMAT, p2i(object()));\n+  st->print_cr(\"  _object = \" INTPTR_FORMAT, p2i(object_peek()));\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.cpp","additions":52,"deletions":4,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"oops\/weakHandle.hpp\"\n@@ -135,0 +136,2 @@\n+  static OopStorage* _oop_storage;\n+\n@@ -138,1 +141,1 @@\n-  void* volatile _object;           \/\/ backward object pointer - strong root\n+  WeakHandle _object;               \/\/ backward object pointer\n@@ -142,1 +145,2 @@\n-    Old\n+    Old,\n+    ChainMarker\n@@ -151,1 +155,1 @@\n-                        sizeof(void* volatile) + sizeof(AllocationState));\n+                        sizeof(WeakHandle) + sizeof(AllocationState));\n@@ -332,0 +336,1 @@\n+  oop       object_peek() const;\n@@ -341,0 +346,1 @@\n+  bool      is_chainmarker() const;\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.hpp","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -95,1 +95,0 @@\n-  assert(object() != NULL, \"must be non-NULL\");\n@@ -101,4 +100,0 @@\n-inline oop ObjectMonitor::object() const {\n-  return (oop)_object;\n-}\n-\n@@ -109,4 +104,0 @@\n-inline void ObjectMonitor::set_object(oop obj) {\n-  _object = (void*)obj;\n-}\n-\n@@ -226,0 +217,4 @@\n+inline bool ObjectMonitor::is_chainmarker() const {\n+  return _allocation_state == ChainMarker;\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.inline.hpp","additions":4,"deletions":9,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -162,2 +162,0 @@\n-#define CHAINMARKER (cast_to_oop<intptr_t>(-1))\n-\n@@ -513,2 +511,2 @@\n-    \/\/ An async deflation can race us before we manage to make the\n-    \/\/ ObjectMonitor busy by setting the owner below. If we detect\n+    \/\/ An async deflation or GC can race us before we manage to make\n+    \/\/ the ObjectMonitor busy by setting the owner below. If we detect\n@@ -516,1 +514,1 @@\n-    if (m->object() == NULL) {\n+    if (m->object_peek() == NULL) {\n@@ -1317,1 +1315,1 @@\n-    assert(block->object() == CHAINMARKER, \"must be a block header\");\n+    assert(block->is_chainmarker(), \"must be a block header\");\n@@ -1320,1 +1318,1 @@\n-      if (mid->object() != NULL) {\n+      if (mid->object_peek() != NULL) {\n@@ -1405,28 +1403,0 @@\n-void ObjectSynchronizer::oops_do(OopClosure* f) {\n-  \/\/ We only scan the global used list here (for moribund threads), and\n-  \/\/ the thread-local monitors in Thread::oops_do().\n-  global_used_oops_do(f);\n-}\n-\n-void ObjectSynchronizer::global_used_oops_do(OopClosure* f) {\n-  assert(SafepointSynchronize::is_at_safepoint(), \"must be at safepoint\");\n-  \/\/ Acquire semantics not needed since we're at a safepoint.\n-  list_oops_do(Atomic::load(&om_list_globals._in_use_list), f);\n-}\n-\n-void ObjectSynchronizer::thread_local_used_oops_do(Thread* thread, OopClosure* f) {\n-  assert(SafepointSynchronize::is_at_safepoint(), \"must be at safepoint\");\n-  list_oops_do(thread->om_in_use_list, f);\n-}\n-\n-void ObjectSynchronizer::list_oops_do(ObjectMonitor* list, OopClosure* f) {\n-  assert(SafepointSynchronize::is_at_safepoint(), \"must be at safepoint\");\n-  \/\/ The oops_do() phase does not overlap with monitor deflation\n-  \/\/ so no need to lock ObjectMonitors for the list traversal.\n-  for (ObjectMonitor* mid = list; mid != NULL; mid = unmarked_next(mid)) {\n-    if (mid->object() != NULL) {\n-      f->do_oop(mid->object_addr());\n-    }\n-  }\n-}\n-\n@@ -1470,1 +1440,1 @@\n-      guarantee(m->object() == NULL, \"invariant\");\n+      guarantee(m->object_peek() == NULL, \"invariant\");\n@@ -1491,1 +1461,1 @@\n-        guarantee(take->object() == NULL, \"invariant\");\n+        guarantee(take->object_peek() == NULL, \"invariant\");\n@@ -1553,1 +1523,1 @@\n-    temp[0].set_object(CHAINMARKER);\n+    temp[0].set_allocation_state(ObjectMonitor::ChainMarker);\n@@ -1578,1 +1548,1 @@\n-  guarantee(m->object() == NULL, \"invariant\");\n+  guarantee(m->object_peek() == NULL, \"invariant\");\n@@ -1689,4 +1659,1 @@\n-\/\/ mutator. In particular, this ensures that the thread's in-use\n-\/\/ monitors are scanned by a GC safepoint, either via Thread::oops_do()\n-\/\/ (before om_flush() is called) or via ObjectSynchronizer::oops_do()\n-\/\/ (after om_flush() is called).\n+\/\/ mutator.\n@@ -1736,2 +1703,3 @@\n-      if (cur_om->object() == NULL) {\n-        \/\/ cur_om was deflated and the object ref was cleared while it\n+      if (cur_om->object_peek() == NULL) {\n+        \/\/ Two reasons for object() to be NULL here:\n+        \/\/ 1) cur_om was deflated and the object ref was cleared while it\n@@ -1739,4 +1707,14 @@\n-        \/\/ (and added to the free list). Refetch the possibly changed\n-        \/\/ next field and try again.\n-        cur_om = unmarked_next(in_use_tail);\n-        continue;\n+        \/\/ (and added to the free list).\n+        \/\/ 2) The object has been GC'ed so the association with object is\n+        \/\/ already broken, but we don't want to do the deflation work now.\n+\n+        \/\/ Refetch the possibly changed next field:\n+        ObjectMonitor* in_use_next = unmarked_next(in_use_tail);\n+        if (cur_om != in_use_next) {\n+          \/\/ The NULL is because of async deflation so try again:\n+          cur_om = in_use_next;\n+          continue;\n+        }\n+        \/\/ Implied else: The NULL is because of GC, but we leave the\n+        \/\/ node on the in-use list to be deflated after it has been\n+        \/\/ moved to the global in-use list.\n@@ -1788,1 +1766,1 @@\n-      guarantee(s->object() == NULL, \"invariant\");\n+      guarantee(s->object_peek() == NULL, \"invariant\");\n@@ -2104,8 +2082,1 @@\n-  \/\/ Set a NULL owner to DEFLATER_MARKER to force any contending thread\n-  \/\/ through the slow path. This is just the first part of the async\n-  \/\/ deflation dance.\n-  if (mid->try_set_owner_from(NULL, DEFLATER_MARKER) != NULL) {\n-    \/\/ The owner field is no longer NULL so we lost the race since the\n-    \/\/ ObjectMonitor is now busy.\n-    return false;\n-  }\n+  const oop obj = mid->object_peek();\n@@ -2113,8 +2084,13 @@\n-  if (mid->contentions() > 0 || mid->_waiters != 0) {\n-    \/\/ Another thread has raced to enter the ObjectMonitor after\n-    \/\/ mid->is_busy() above or has already entered and waited on\n-    \/\/ it which makes it busy so no deflation. Restore owner to\n-    \/\/ NULL if it is still DEFLATER_MARKER.\n-    if (mid->try_set_owner_from(DEFLATER_MARKER, NULL) != DEFLATER_MARKER) {\n-      \/\/ Deferred decrement for the JT EnterI() that cancelled the async deflation.\n-      mid->add_to_contentions(-1);\n+  if (obj == NULL) {\n+    \/\/ If the object died, we can recycle the monitor without racing with\n+    \/\/ Java threads. The GC already broke the association with the object.\n+    mid->set_owner_from(NULL, DEFLATER_MARKER);\n+    mid->_contentions = -max_jint;\n+  } else {\n+    \/\/ Set a NULL owner to DEFLATER_MARKER to force any contending thread\n+    \/\/ through the slow path. This is just the first part of the async\n+    \/\/ deflation dance.\n+    if (mid->try_set_owner_from(NULL, DEFLATER_MARKER) != NULL) {\n+      \/\/ The owner field is no longer NULL so we lost the race since the\n+      \/\/ ObjectMonitor is now busy.\n+      return false;\n@@ -2122,2 +2098,0 @@\n-    return false;\n-  }\n@@ -2125,9 +2099,23 @@\n-  \/\/ Make a zero contentions field negative to force any contending threads\n-  \/\/ to retry. This is the second part of the async deflation dance.\n-  if (Atomic::cmpxchg(&mid->_contentions, (jint)0, -max_jint) != 0) {\n-    \/\/ Contentions was no longer 0 so we lost the race since the\n-    \/\/ ObjectMonitor is now busy. Restore owner to NULL if it is\n-    \/\/ still DEFLATER_MARKER:\n-    if (mid->try_set_owner_from(DEFLATER_MARKER, NULL) != DEFLATER_MARKER) {\n-      \/\/ Deferred decrement for the JT EnterI() that cancelled the async deflation.\n-      mid->add_to_contentions(-1);\n+    if (mid->contentions() > 0 || mid->_waiters != 0) {\n+      \/\/ Another thread has raced to enter the ObjectMonitor after\n+      \/\/ mid->is_busy() above or has already entered and waited on\n+      \/\/ it which makes it busy so no deflation. Restore owner to\n+      \/\/ NULL if it is still DEFLATER_MARKER.\n+      if (mid->try_set_owner_from(DEFLATER_MARKER, NULL) != DEFLATER_MARKER) {\n+        \/\/ Deferred decrement for the JT EnterI() that cancelled the async deflation.\n+        mid->add_to_contentions(-1);\n+      }\n+      return false;\n+    }\n+\n+    \/\/ Make a zero contentions field negative to force any contending threads\n+    \/\/ to retry. This is the second part of the async deflation dance.\n+    if (Atomic::cmpxchg(&mid->_contentions, (jint)0, -max_jint) != 0) {\n+      \/\/ Contentions was no longer 0 so we lost the race since the\n+      \/\/ ObjectMonitor is now busy. Restore owner to NULL if it is\n+      \/\/ still DEFLATER_MARKER:\n+      if (mid->try_set_owner_from(DEFLATER_MARKER, NULL) != DEFLATER_MARKER) {\n+        \/\/ Deferred decrement for the JT EnterI() that cancelled the async deflation.\n+        mid->add_to_contentions(-1);\n+      }\n+      return false;\n@@ -2135,1 +2123,0 @@\n-    return false;\n@@ -2149,9 +2136,9 @@\n-  const oop obj = mid->object();\n-  if (log_is_enabled(Trace, monitorinflation)) {\n-    ResourceMark rm;\n-    log_trace(monitorinflation)(\"deflate_monitor_using_JT: \"\n-                                \"object=\" INTPTR_FORMAT \", mark=\"\n-                                INTPTR_FORMAT \", type='%s'\",\n-                                p2i(obj), obj->mark().value(),\n-                                obj->klass()->external_name());\n-  }\n+  if (obj != NULL) {\n+    if (log_is_enabled(Trace, monitorinflation)) {\n+      ResourceMark rm;\n+      log_trace(monitorinflation)(\"deflate_monitor_using_JT: \"\n+                                  \"object=\" INTPTR_FORMAT \", mark=\"\n+                                  INTPTR_FORMAT \", type='%s'\",\n+                                  p2i(obj), obj->mark().value(),\n+                                  obj->klass()->external_name());\n+    }\n@@ -2159,2 +2146,3 @@\n-  \/\/ Install the old mark word if nobody else has already done it.\n-  mid->install_displaced_markword_in_object(obj);\n+    \/\/ Install the old mark word if nobody else has already done it.\n+    mid->install_displaced_markword_in_object(obj);\n+  }\n@@ -2163,2 +2151,2 @@\n-  assert(mid->object() == NULL, \"must be NULL: object=\" INTPTR_FORMAT,\n-         p2i(mid->object()));\n+  assert(mid->object_peek() == NULL, \"must be NULL: object=\" INTPTR_FORMAT,\n+         p2i(mid->object_peek()));\n@@ -2259,4 +2247,3 @@\n-    \/\/ Only try to deflate if there is an associated Java object and if\n-    \/\/ mid is old (is not newly allocated and is not newly freed).\n-    if (mid->object() != NULL && mid->is_old() &&\n-        deflate_monitor_using_JT(mid, free_head_p, free_tail_p)) {\n+    \/\/ Only try to deflate if mid is old (is not newly allocated and\n+    \/\/ is not newly freed).\n+    if (mid->is_old() && deflate_monitor_using_JT(mid, free_head_p, free_tail_p)) {\n@@ -2293,3 +2280,2 @@\n-      \/\/ mid is considered in-use if it does not have an associated\n-      \/\/ Java object or mid is not old or deflation did not succeed.\n-      \/\/ A mid->is_new() node can be seen here when it is freshly\n+      \/\/ mid is considered in-use if mid is not old or deflation did not\n+      \/\/ succeed. A mid->is_new() node can be seen here when it is freshly\n@@ -2720,1 +2706,1 @@\n-  if (n->object() != NULL) {\n+  if (n->object_peek() != NULL) {\n@@ -2725,1 +2711,1 @@\n-                    p2i(n->object()));\n+                    p2i(n->object_peek()));\n@@ -2729,1 +2715,1 @@\n-                    p2i(n), p2i(n->object()));\n+                    p2i(n), p2i(n->object_peek()));\n@@ -2859,24 +2845,16 @@\n-  if (n->object() == NULL) {\n-    if (jt != NULL) {\n-      out->print_cr(\"ERROR: jt=\" INTPTR_FORMAT \", monitor=\" INTPTR_FORMAT\n-                    \": in-use per-thread monitor must have non-NULL _object \"\n-                    \"field.\", p2i(jt), p2i(n));\n-    } else {\n-      out->print_cr(\"ERROR: monitor=\" INTPTR_FORMAT \": in-use global monitor \"\n-                    \"must have non-NULL _object field.\", p2i(n));\n-    }\n-    *error_cnt_p = *error_cnt_p + 1;\n-  }\n-  const oop obj = n->object();\n-  const markWord mark = obj->mark();\n-  if (!mark.has_monitor()) {\n-    if (jt != NULL) {\n-      out->print_cr(\"ERROR: jt=\" INTPTR_FORMAT \", monitor=\" INTPTR_FORMAT\n-                    \": in-use per-thread monitor's object does not think \"\n-                    \"it has a monitor: obj=\" INTPTR_FORMAT \", mark=\"\n-                    INTPTR_FORMAT,  p2i(jt), p2i(n), p2i(obj), mark.value());\n-    } else {\n-      out->print_cr(\"ERROR: monitor=\" INTPTR_FORMAT \": in-use global \"\n-                    \"monitor's object does not think it has a monitor: obj=\"\n-                    INTPTR_FORMAT \", mark=\" INTPTR_FORMAT, p2i(n),\n-                    p2i(obj), mark.value());\n+  const oop obj = n->object_peek();\n+  if (obj != NULL) {\n+    const markWord mark = obj->mark();\n+    if (!mark.has_monitor()) {\n+      if (jt != NULL) {\n+        out->print_cr(\"ERROR: jt=\" INTPTR_FORMAT \", monitor=\" INTPTR_FORMAT\n+                      \": in-use per-thread monitor's object does not think \"\n+                      \"it has a monitor: obj=\" INTPTR_FORMAT \", mark=\"\n+                      INTPTR_FORMAT,  p2i(jt), p2i(n), p2i(obj), mark.value());\n+      } else {\n+        out->print_cr(\"ERROR: monitor=\" INTPTR_FORMAT \": in-use global \"\n+                      \"monitor's object does not think it has a monitor: obj=\"\n+                      INTPTR_FORMAT \", mark=\" INTPTR_FORMAT, p2i(n),\n+                      p2i(obj), mark.value());\n+      }\n+      *error_cnt_p = *error_cnt_p + 1;\n@@ -2884,15 +2862,15 @@\n-    *error_cnt_p = *error_cnt_p + 1;\n-  }\n-  ObjectMonitor* const obj_mon = mark.monitor();\n-  if (n != obj_mon) {\n-    if (jt != NULL) {\n-      out->print_cr(\"ERROR: jt=\" INTPTR_FORMAT \", monitor=\" INTPTR_FORMAT\n-                    \": in-use per-thread monitor's object does not refer \"\n-                    \"to the same monitor: obj=\" INTPTR_FORMAT \", mark=\"\n-                    INTPTR_FORMAT \", obj_mon=\" INTPTR_FORMAT, p2i(jt),\n-                    p2i(n), p2i(obj), mark.value(), p2i(obj_mon));\n-    } else {\n-      out->print_cr(\"ERROR: monitor=\" INTPTR_FORMAT \": in-use global \"\n-                    \"monitor's object does not refer to the same monitor: obj=\"\n-                    INTPTR_FORMAT \", mark=\" INTPTR_FORMAT \", obj_mon=\"\n-                    INTPTR_FORMAT, p2i(n), p2i(obj), mark.value(), p2i(obj_mon));\n+    ObjectMonitor* const obj_mon = mark.monitor();\n+    if (n != obj_mon) {\n+      if (jt != NULL) {\n+        out->print_cr(\"ERROR: jt=\" INTPTR_FORMAT \", monitor=\" INTPTR_FORMAT\n+                      \": in-use per-thread monitor's object does not refer \"\n+                      \"to the same monitor: obj=\" INTPTR_FORMAT \", mark=\"\n+                      INTPTR_FORMAT \", obj_mon=\" INTPTR_FORMAT, p2i(jt),\n+                      p2i(n), p2i(obj), mark.value(), p2i(obj_mon));\n+      } else {\n+        out->print_cr(\"ERROR: monitor=\" INTPTR_FORMAT \": in-use global \"\n+                      \"monitor's object does not refer to the same monitor: obj=\"\n+                      INTPTR_FORMAT \", mark=\" INTPTR_FORMAT \", obj_mon=\"\n+                      INTPTR_FORMAT, p2i(n), p2i(obj), mark.value(), p2i(obj_mon));\n+      }\n+      *error_cnt_p = *error_cnt_p + 1;\n@@ -2900,1 +2878,0 @@\n-    *error_cnt_p = *error_cnt_p + 1;\n@@ -2980,1 +2957,1 @@\n-        const oop obj = cur->object();\n+        const oop obj = cur->object_peek();\n@@ -2985,1 +2962,1 @@\n-                   p2i(obj), obj->klass()->external_name());\n+                   p2i(obj), obj == NULL ? \"\" : obj->klass()->external_name());\n@@ -3010,1 +2987,1 @@\n-        const oop obj = cur->object();\n+        const oop obj = cur->object_peek();\n@@ -3016,1 +2993,1 @@\n-                   obj->klass()->external_name());\n+                   obj == NULL ? \"\" : obj->klass()->external_name());\n@@ -3072,1 +3049,1 @@\n-    assert(block->object() == CHAINMARKER, \"must be a block header\");\n+    assert(block->is_chainmarker(), \"must be a block header\");\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":123,"deletions":146,"binary":false,"changes":269,"status":"modified"},{"patch":"@@ -153,3 +153,0 @@\n-  static void oops_do(OopClosure* f);\n-  \/\/ Process oops in thread local used monitors\n-  static void thread_local_used_oops_do(Thread* thread, OopClosure* f);\n@@ -193,5 +190,0 @@\n-  \/\/ Process oops in all global used monitors (i.e. moribund thread's monitors)\n-  static void global_used_oops_do(OopClosure* f);\n-  \/\/ Process oops in monitors on the given list\n-  static void list_oops_do(ObjectMonitor* list, OopClosure* f);\n-\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.hpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -892,4 +892,0 @@\n-\n-  \/\/ We scan thread local monitor lists here, and the remaining global\n-  \/\/ monitors in ObjectSynchronizer::oops_do().\n-  ObjectSynchronizer::thread_local_used_oops_do(this, f);\n@@ -2220,5 +2216,0 @@\n-  \/\/ We must flush any deferred card marks and other various GC barrier\n-  \/\/ related buffers (e.g. G1 SATB buffer and G1 dirty card queue buffer)\n-  \/\/ before removing a thread from the list of active threads.\n-  BarrierSet::barrier_set()->on_thread_detach(this);\n-\n@@ -2272,2 +2263,0 @@\n-  BarrierSet::barrier_set()->on_thread_detach(this);\n-\n@@ -4598,0 +4587,7 @@\n+  \/\/ We must flush any deferred card marks and other various GC barrier\n+  \/\/ related buffers (e.g. G1 SATB buffer and G1 dirty card queue buffer)\n+  \/\/ before removing a thread from the list of active threads.\n+  \/\/ This must be done after ObjectSynchronizer::om_flush(), as GC barriers\n+  \/\/ are used in om_flush().\n+  BarrierSet::barrier_set()->on_thread_detach(p);\n+\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":7,"deletions":11,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -1382,21 +1382,0 @@\n-\n-\/\/ Support class used to generate HPROF_GC_ROOT_MONITOR_USED records\n-\n-class MonitorUsedDumper : public OopClosure {\n- private:\n-  DumpWriter* _writer;\n-  DumpWriter* writer() const                { return _writer; }\n- public:\n-  MonitorUsedDumper(DumpWriter* writer) {\n-    _writer = writer;\n-  }\n-  void do_oop(oop* obj_p) {\n-    u4 size = 1 + sizeof(address);\n-    writer()->start_sub_record(HPROF_GC_ROOT_MONITOR_USED, size);\n-    writer()->write_objectID(*obj_p);\n-    writer()->end_sub_record();\n-  }\n-  void do_oop(narrowOop* obj_p) { ShouldNotReachHere(); }\n-};\n-\n-\n@@ -1855,4 +1834,0 @@\n-  \/\/ HPROF_GC_ROOT_MONITOR_USED\n-  MonitorUsedDumper mon_dumper(writer());\n-  ObjectSynchronizer::oops_do(&mon_dumper);\n-\n","filename":"src\/hotspot\/share\/services\/heapDumper.cpp","additions":0,"deletions":25,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -95,1 +95,5 @@\n-    return addr.getOopHandleAt(objectFieldOffset);\n+    Address objAddr = addr.getAddressAt(objectFieldOffset);\n+    if (objAddr == null) {\n+      return null;\n+    }\n+    return objAddr.getOopHandleAt(0);\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/ObjectMonitor.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -124,1 +124,0 @@\n-        new LogMessageWithLevel(\"ObjectSynchronizer Roots\", Level.TRACE),\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestGCLogMessages.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -206,4 +206,0 @@\n-        boolean did_deflation = WB.deflateIdleMonitors();\n-        Asserts.assertEQ(did_deflation, true,\n-                         \"deflateIdleMonitors() should have worked.\");\n-\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/humongousObjects\/TestHumongousClassLoader.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -94,1 +94,0 @@\n-            \"ObjectSynchronizerRoots\",\n","filename":"test\/jdk\/jdk\/jfr\/event\/gc\/collection\/TestG1ParallelPhases.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}