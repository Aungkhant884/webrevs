{"files":[{"patch":"@@ -1894,3 +1894,0 @@\n-  \/\/ Ensure class is linked\n-  iklass->link_class(CHECK_NULL);\n-\n@@ -1924,3 +1921,0 @@\n-  \/\/ Ensure class is linked\n-  iklass->link_class(CHECK_NULL);\n-\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,0 +48,3 @@\n+        if (!method.getDeclaringClass().isLinked()) {\n+            throw new IllegalArgumentException(method.format(\"%H.%n(%p) must be linked\"));\n+        }\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HotSpotProfilingInfo.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -259,1 +259,5 @@\n-        return UNSAFE.getChar(getConstMethod() + config().constMethodCodeSizeOffset);\n+        int codeSize = UNSAFE.getChar(getConstMethod() + config().constMethodCodeSizeOffset);\n+        if (codeSize > 0 && !getDeclaringClass().isLinked()) {\n+            return -1;\n+        }\n+        return codeSize;\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HotSpotResolvedJavaMethodImpl.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -982,0 +982,9 @@\n+        link();\n+        return runtime().compilerToVm.getDeclaredConstructors(this);\n+    }\n+\n+    @Override\n+    public ResolvedJavaMethod[] getDeclaredConstructors(boolean forceLink) {\n+        if (forceLink) {\n+            link();\n+        }\n@@ -987,0 +996,8 @@\n+        return getDeclaredMethods(true);\n+    }\n+\n+    @Override\n+    public ResolvedJavaMethod[] getDeclaredMethods(boolean forceLink) {\n+        if (forceLink) {\n+            link();\n+        }\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HotSpotResolvedObjectTypeImpl.java","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,4 +39,3 @@\n-     * Returns the bytecode of this method, if the method has code. The returned byte array does not\n-     * contain breakpoints or non-Java bytecodes. This may return null if the\n-     * {@linkplain #getDeclaringClass() declaring class} is not\n-     * {@linkplain ResolvedJavaType#isLinked() linked}.\n+     * Returns the method's bytecode. The returned bytecode does not contain breakpoints or non-Java\n+     * bytecodes. This will return {@code null} if {@link #getCodeSize()} returns {@code <= 0} or if\n+     * {@link #hasBytecodes()} returns {@code false}.\n@@ -44,1 +43,1 @@\n-     * The contained constant pool indices may not be the ones found in the original class file but\n+     * The contained constant pool indexes may not be the ones found in the original class file but\n@@ -47,2 +46,2 @@\n-     * @return the bytecode of the method, or {@code null} if {@code getCodeSize() == 0} or if the\n-     *         code is not ready.\n+     * @return {@code null} if {@code getLinkedCodeSize() <= 0} otherwise the bytecode of the method\n+     *         whose length is guaranteed to be {@code > 0}\n@@ -53,2 +52,2 @@\n-     * Returns the size of the bytecode of this method, if the method has code. This is equivalent\n-     * to {@link #getCode()}. {@code length} if the method has code.\n+     * Returns the size of the method's bytecode. If this method returns a value {@code > 0} then\n+     * {@link #getCode()} will not return {@code null}.\n@@ -56,1 +55,4 @@\n-     * @return the size of the bytecode in bytes, or 0 if no bytecode is available\n+     * @return 0 if the method has no bytecode, {@code -1} if the method does have bytecode but its\n+     *         {@linkplain #getDeclaringClass() declaring class} is not\n+     *         {@linkplain ResolvedJavaType#isLinked() linked} otherwise the size of the bytecode in\n+     *         bytes (guaranteed to be {@code > 0})\n@@ -440,6 +442,2 @@\n-     * Checks whether the method has bytecodes associated with it. Note that even if this method\n-     * returns {@code true}, {@link #getCode} can return {@code null} if\n-     * {@linkplain #getDeclaringClass() declaring class} is not\n-     * {@linkplain ResolvedJavaType#isLinked() linked}.\n-     *\n-     * @return {@code this.getCodeSize() != 0}\n+     * @see #getCodeSize()\n+     * @return {@code getCodeSize() > 0}\n@@ -448,1 +446,1 @@\n-        return getCodeSize() != 0;\n+        return getCodeSize() > 0;\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.meta\/src\/jdk\/vm\/ci\/meta\/ResolvedJavaMethod.java","additions":16,"deletions":18,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -342,0 +342,10 @@\n+    \/**\n+     * Returns an array reflecting all the constructors declared by this type. This method is\n+     * similar to {@link Class#getDeclaredConstructors()} in terms of returned constructors.\n+     *\n+     * @param forceLink if {@code true}, forces this type to be {@link #link linked}\n+     *\/\n+    default ResolvedJavaMethod[] getDeclaredConstructors(boolean forceLink) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n@@ -349,0 +359,10 @@\n+    \/**\n+     * Returns an array reflecting all the methods declared by this type. This method is similar to\n+     * {@link Class#getDeclaredMethods()} in terms of returned methods.\n+     *\n+     * @param forceLink if {@code true}, forces this type to be {@link #link linked}\n+     *\/\n+    default ResolvedJavaMethod[] getDeclaredMethods(boolean forceLink) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.meta\/src\/jdk\/vm\/ci\/meta\/ResolvedJavaType.java","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -0,0 +1,145 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.vm.ci.hotspot.test;\n+\n+import static java.lang.reflect.Modifier.FINAL;\n+import static java.lang.reflect.Modifier.PRIVATE;\n+import static java.lang.reflect.Modifier.PROTECTED;\n+import static java.lang.reflect.Modifier.PUBLIC;\n+import static java.lang.reflect.Modifier.STATIC;\n+import static java.lang.reflect.Modifier.TRANSIENT;\n+import static java.lang.reflect.Modifier.VOLATILE;\n+\n+import java.lang.reflect.Field;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+import jdk.vm.ci.hotspot.HotSpotJVMCIRuntime;\n+import jdk.vm.ci.hotspot.HotSpotResolvedJavaField;\n+import jdk.vm.ci.hotspot.HotSpotVMConfigAccess;\n+import jdk.vm.ci.meta.JavaType;\n+import jdk.vm.ci.meta.MetaAccessProvider;\n+import jdk.vm.ci.meta.ResolvedJavaField;\n+import jdk.vm.ci.meta.ResolvedJavaType;\n+import jdk.vm.ci.runtime.JVMCI;\n+\n+\/**\n+ * Tests {@link HotSpotResolvedJavaField} functionality.\n+ *\/\n+public class HotSpotResolvedJavaFieldTest {\n+\n+    private static final Class<?>[] classesWithInternalFields = {Class.class, ClassLoader.class};\n+\n+    private static final Method createFieldMethod;\n+    private static final Field indexField;\n+\n+    static {\n+        Method m = null;\n+        Field f = null;\n+        try {\n+            Class<?> typeImpl = Class.forName(\"jdk.vm.ci.hotspot.HotSpotResolvedObjectTypeImpl\");\n+            m = typeImpl.getDeclaredMethod(\"createField\", JavaType.class, long.class, int.class, int.class);\n+            m.setAccessible(true);\n+            Class<?> fieldImpl = Class.forName(\"jdk.vm.ci.hotspot.HotSpotResolvedJavaFieldImpl\");\n+            f = fieldImpl.getDeclaredField(\"index\");\n+            f.setAccessible(true);\n+        } catch (Exception e) {\n+            throw new AssertionError(e);\n+        }\n+\n+        createFieldMethod = m;\n+        indexField = f;\n+    }\n+\n+    \/**\n+     * Same as {@code HotSpotModifiers.jvmFieldModifiers()} but works when using a JVMCI version\n+     * prior to the introduction of that method.\n+     *\/\n+    private int jvmFieldModifiers() {\n+        HotSpotJVMCIRuntime runtime = runtime();\n+        HotSpotVMConfigAccess access = new HotSpotVMConfigAccess(runtime.getConfigStore());\n+        int accEnum = access.getConstant(\"JVM_ACC_ENUM\", Integer.class, 0x4000);\n+        int accSynthetic = access.getConstant(\"JVM_ACC_SYNTHETIC\", Integer.class, 0x1000);\n+        return PUBLIC | PRIVATE | PROTECTED | STATIC | FINAL | VOLATILE | TRANSIENT | accEnum | accSynthetic;\n+    }\n+\n+    HotSpotJVMCIRuntime runtime() {\n+        return (HotSpotJVMCIRuntime) JVMCI.getRuntime();\n+    }\n+\n+    MetaAccessProvider getMetaAccess() {\n+        return runtime().getHostJVMCIBackend().getMetaAccess();\n+    }\n+\n+    \/**\n+     * Tests that {@link HotSpotResolvedJavaField#getModifiers()} only includes the modifiers\n+     * returned by {@link Field#getModifiers()}. Namely, it must not include\n+     * {@code HotSpotResolvedJavaField#FIELD_INTERNAL_FLAG}.\n+     *\/\n+    @Test\n+    public void testModifiersForInternal() {\n+        for (Class<?> c : classesWithInternalFields) {\n+            ResolvedJavaType type = getMetaAccess().lookupJavaType(c);\n+            for (ResolvedJavaField field : type.getInstanceFields(false)) {\n+                if (field.isInternal()) {\n+                    Assert.assertEquals(0, ~jvmFieldModifiers() & field.getModifiers());\n+                }\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Tests that {@code HotSpotResolvedObjectTypeImpl#createField(String, JavaType, long, int)}\n+     * always returns an {@linkplain ResolvedJavaField#equals(Object) equivalent} object for an\n+     * internal field.\n+     *\n+     * @throws InvocationTargetException\n+     * @throws IllegalArgumentException\n+     * @throws IllegalAccessException\n+     *\/\n+    @Test\n+    public void testEquivalenceForInternalFields() throws IllegalAccessException, IllegalArgumentException, InvocationTargetException {\n+        for (Class<?> c : classesWithInternalFields) {\n+            ResolvedJavaType type = getMetaAccess().lookupJavaType(c);\n+            for (ResolvedJavaField field : type.getInstanceFields(false)) {\n+                if (field.isInternal()) {\n+                    HotSpotResolvedJavaField expected = (HotSpotResolvedJavaField) field;\n+                    int index = indexField.getInt(expected);\n+                    ResolvedJavaField actual = (ResolvedJavaField) createFieldMethod.invoke(type, expected.getType(), expected.getOffset(), expected.getModifiers(), index);\n+                    Assert.assertEquals(expected, actual);\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testIsInObject() {\n+        for (Field f : String.class.getDeclaredFields()) {\n+            HotSpotResolvedJavaField rf = (HotSpotResolvedJavaField) getMetaAccess().lookupJavaField(f);\n+            Assert.assertEquals(rf.toString(), rf.isInObject(runtime().getHostJVMCIBackend().getConstantReflection().forString(\"a string\")), !rf.isStatic());\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.hotspot.test\/src\/jdk\/vm\/ci\/hotspot\/test\/HotSpotResolvedJavaFieldTest.java","additions":145,"deletions":0,"binary":false,"changes":145,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,0 +48,1 @@\n+import java.lang.reflect.Executable;\n@@ -52,0 +53,1 @@\n+import java.util.ArrayList;\n@@ -55,0 +57,1 @@\n+import java.util.List;\n@@ -80,2 +83,2 @@\n-        for (Map.Entry<Method, ResolvedJavaMethod> e : methods.entrySet()) {\n-            ResolvedJavaMethod m = e.getValue();\n+        for (ResolvedJavaMethod m : joinValues(methods, constructors)) {\n+            String ms = m.toString();\n@@ -84,1 +87,1 @@\n-                assertTrue(m.getCodeSize() == 0);\n+                assertEquals(ms, m.getCodeSize(), 0);\n@@ -86,5 +89,1 @@\n-                if (m.isAbstract()) {\n-                    assertTrue(code.length == 0);\n-                } else if (!m.isNative()) {\n-                    assertTrue(code.length > 0);\n-                }\n+                assertTrue(ms, code.length > 0);\n@@ -100,2 +99,3 @@\n-        for (Map.Entry<Method, ResolvedJavaMethod> e : methods.entrySet()) {\n-            ResolvedJavaMethod m = e.getValue();\n+        ResolvedJavaType unlinkedType = metaAccess.lookupJavaType(UnlinkedType.class);\n+        assertTrue(!unlinkedType.isLinked());\n+        for (ResolvedJavaMethod m : addExecutables(joinValues(methods, constructors), unlinkedType, false)) {\n@@ -103,4 +103,7 @@\n-            if (m.isAbstract()) {\n-                assertTrue(codeSize == 0);\n-            } else if (!m.isNative()) {\n-                assertTrue(codeSize > 0);\n+            String ms = m.toString();\n+            if (m.isAbstract() || m.isNative()) {\n+                assertEquals(ms, codeSize, 0);\n+            } else if (!m.getDeclaringClass().isLinked()) {\n+                assertEquals(ms, -1, codeSize);\n+            } else {\n+                assertTrue(ms, codeSize > 0);\n@@ -109,0 +112,1 @@\n+        assertTrue(!unlinkedType.isLinked());\n@@ -113,2 +117,3 @@\n-        for (ResolvedJavaMethod m : methods.values()) {\n-            for (ResolvedJavaMethod that : methods.values()) {\n+        List<ResolvedJavaMethod> executables = joinValues(methods, constructors);\n+        for (ResolvedJavaMethod m : executables) {\n+            for (ResolvedJavaMethod that : executables) {\n@@ -124,7 +129,1 @@\n-        for (Map.Entry<Method, ResolvedJavaMethod> e : methods.entrySet()) {\n-            ResolvedJavaMethod m = e.getValue();\n-            int expected = e.getKey().getModifiers();\n-            int actual = m.getModifiers();\n-            assertEquals(String.format(\"%s: 0x%x != 0x%x\", m, expected, actual), expected, actual);\n-        }\n-        for (Map.Entry<Constructor<?>, ResolvedJavaMethod> e : constructors.entrySet()) {\n+        for (Map.Entry<Executable, ResolvedJavaMethod> e : join(methods, constructors).entrySet()) {\n@@ -143,1 +142,1 @@\n-        for (Map.Entry<Method, ResolvedJavaMethod> e : methods.entrySet()) {\n+        for (Map.Entry<Executable, ResolvedJavaMethod> e : join(methods, constructors).entrySet()) {\n@@ -148,4 +147,0 @@\n-        for (Map.Entry<Constructor<?>, ResolvedJavaMethod> e : constructors.entrySet()) {\n-            ResolvedJavaMethod m = e.getValue();\n-            assertFalse(m.isClassInitializer());\n-        }\n@@ -168,5 +163,1 @@\n-        for (Map.Entry<Method, ResolvedJavaMethod> e : methods.entrySet()) {\n-            ResolvedJavaMethod m = e.getValue();\n-            assertEquals(e.getKey().isSynthetic(), m.isSynthetic());\n-        }\n-        for (Map.Entry<Constructor<?>, ResolvedJavaMethod> e : constructors.entrySet()) {\n+        for (Map.Entry<Executable, ResolvedJavaMethod> e : join(methods, constructors).entrySet()) {\n@@ -192,5 +183,1 @@\n-        for (Map.Entry<Method, ResolvedJavaMethod> e : methods.entrySet()) {\n-            ResolvedJavaMethod m = e.getValue();\n-            assertEquals(e.getKey().isVarArgs(), m.isVarArgs());\n-        }\n-        for (Map.Entry<Constructor<?>, ResolvedJavaMethod> e : constructors.entrySet()) {\n+        for (Map.Entry<Executable, ResolvedJavaMethod> e : join(methods, constructors).entrySet()) {\n@@ -204,5 +191,1 @@\n-        for (Map.Entry<Method, ResolvedJavaMethod> e : methods.entrySet()) {\n-            ResolvedJavaMethod m = e.getValue();\n-            assertEquals(Modifier.isSynchronized(e.getKey().getModifiers()), m.isSynchronized());\n-        }\n-        for (Map.Entry<Constructor<?>, ResolvedJavaMethod> e : constructors.entrySet()) {\n+        for (Map.Entry<Executable, ResolvedJavaMethod> e : join(methods, constructors).entrySet()) {\n@@ -231,5 +214,5 @@\n-                Modifier.isPrivate(modifiers) ||\n-                Modifier.isStatic(modifiers) ||\n-                method instanceof Constructor ||\n-                Modifier.isFinal(method.getDeclaringClass().getModifiers())) &&\n-                !Modifier.isAbstract(modifiers);\n+                        Modifier.isPrivate(modifiers) ||\n+                        Modifier.isStatic(modifiers) ||\n+                        method instanceof Constructor ||\n+                        Modifier.isFinal(method.getDeclaringClass().getModifiers())) &&\n+                        !Modifier.isAbstract(modifiers);\n@@ -282,1 +265,1 @@\n-        for (Map.Entry<Method, ResolvedJavaMethod> e : methods.entrySet()) {\n+        for (Map.Entry<Executable, ResolvedJavaMethod> e : join(methods, constructors).entrySet()) {\n@@ -419,0 +402,6 @@\n+    public static List<ResolvedJavaMethod> addExecutables(List<ResolvedJavaMethod> to, ResolvedJavaType declaringType, boolean forceLink) {\n+        to.addAll(List.of(declaringType.getDeclaredMethods(forceLink)));\n+        to.addAll(List.of(declaringType.getDeclaredConstructors(forceLink)));\n+        return to;\n+    }\n+\n@@ -421,7 +410,6 @@\n-        for (Map.Entry<Method, ResolvedJavaMethod> e : methods.entrySet()) {\n-            ResolvedJavaMethod m = e.getValue();\n-            assertTrue(m.hasBytecodes() == (m.isConcrete() && !m.isNative()));\n-        }\n-        for (Map.Entry<Constructor<?>, ResolvedJavaMethod> e : constructors.entrySet()) {\n-            ResolvedJavaMethod m = e.getValue();\n-            assertTrue(m.hasBytecodes());\n+        ResolvedJavaType unlinkedType = metaAccess.lookupJavaType(UnlinkedType.class);\n+        assertTrue(!unlinkedType.isLinked());\n+        for (ResolvedJavaMethod m : addExecutables(joinValues(methods, constructors), unlinkedType, false)) {\n+            boolean expect = m.getDeclaringClass().isLinked() && m.isConcrete() && !m.isNative();\n+            boolean actual = m.hasBytecodes();\n+            assertEquals(m.toString(), expect, actual);\n@@ -429,0 +417,1 @@\n+        assertTrue(!unlinkedType.isLinked());\n@@ -450,1 +439,7 @@\n-    static class UnlinkedType {\n+    abstract static class UnlinkedType {\n+        abstract void abstractMethod();\n+\n+        void concreteMethod() {\n+        }\n+\n+        native void nativeMethod();\n@@ -533,0 +528,18 @@\n+\n+    @SafeVarargs\n+    public static <K, V> Map<K, V> join(Map<? extends K, V>... maps) {\n+        Map<K, V> res = new HashMap<>();\n+        for (Map<? extends K, V> e : maps) {\n+            res.putAll(e);\n+        }\n+        return res;\n+    }\n+\n+    @SafeVarargs\n+    public static <V> List<V> joinValues(Map<?, V>... maps) {\n+        List<V> res = new ArrayList<>();\n+        for (Map<?, V> e : maps) {\n+            res.addAll(e.values());\n+        }\n+        return res;\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.runtime.test\/src\/jdk\/vm\/ci\/runtime\/test\/TestResolvedJavaMethod.java","additions":71,"deletions":58,"binary":false,"changes":129,"status":"modified"}]}