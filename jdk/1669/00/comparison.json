{"files":[{"patch":"@@ -173,5 +173,4 @@\n-        try {\n-            String p = toAbsolutePath().path;\n-            if (!p.startsWith(\"\/modules\") || p.contains(\"..\")) {\n-                throw new IOError(new RuntimeException(p + \" cannot be represented as URI\"));\n-            }\n+        String p = toAbsolutePath().path;\n+        if (!p.startsWith(\"\/modules\") || p.contains(\"..\")) {\n+            throw new IOError(new RuntimeException(p + \" cannot be represented as URI\"));\n+        }\n@@ -179,7 +178,3 @@\n-            p = p.substring(\"\/modules\".length());\n-            if (p.isEmpty()) {\n-                p = \"\/\";\n-            }\n-            return new URI(\"jrt\", p, null);\n-        } catch (URISyntaxException ex) {\n-            throw new AssertionError(ex);\n+        p = p.substring(\"\/modules\".length());\n+        if (p.isEmpty()) {\n+            p = \"\/\";\n@@ -187,0 +182,1 @@\n+        return toUri(p);\n@@ -828,0 +824,131 @@\n+\n+    \/\/ adopted from sun.nio.fs.UnixUriUtils\n+    private static URI toUri(String str) {\n+        char[] path = str.toCharArray();\n+        assert path[0] == '\/';\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(path[0]);\n+        for (int i = 1; i < path.length; i++) {\n+            char c = (char)(path[i] & 0xff);\n+            if (match(c, L_PATH, H_PATH)) {\n+                sb.append(c);\n+            } else {\n+                sb.append('%');\n+                sb.append(hexDigits[(c >> 4) & 0x0f]);\n+                sb.append(hexDigits[(c) & 0x0f]);\n+            }\n+        }\n+\n+        try {\n+            return new URI(\"jrt:\" + sb.toString());\n+        } catch (URISyntaxException x) {\n+            throw new AssertionError(x);  \/\/ should not happen\n+        }\n+    }\n+\n+    \/\/ The following is copied from java.net.URI\n+\n+    \/\/ Compute the low-order mask for the characters in the given string\n+    private static long lowMask(String chars) {\n+        int n = chars.length();\n+        long m = 0;\n+        for (int i = 0; i < n; i++) {\n+            char c = chars.charAt(i);\n+            if (c < 64)\n+                m |= (1L << c);\n+        }\n+        return m;\n+    }\n+\n+    \/\/ Compute the high-order mask for the characters in the given string\n+    private static long highMask(String chars) {\n+        int n = chars.length();\n+        long m = 0;\n+        for (int i = 0; i < n; i++) {\n+            char c = chars.charAt(i);\n+            if ((c >= 64) && (c < 128))\n+                m |= (1L << (c - 64));\n+        }\n+        return m;\n+    }\n+\n+    \/\/ Compute a low-order mask for the characters\n+    \/\/ between first and last, inclusive\n+    private static long lowMask(char first, char last) {\n+        long m = 0;\n+        int f = Math.max(Math.min(first, 63), 0);\n+        int l = Math.max(Math.min(last, 63), 0);\n+        for (int i = f; i <= l; i++)\n+            m |= 1L << i;\n+        return m;\n+    }\n+\n+    \/\/ Compute a high-order mask for the characters\n+    \/\/ between first and last, inclusive\n+    private static long highMask(char first, char last) {\n+        long m = 0;\n+        int f = Math.max(Math.min(first, 127), 64) - 64;\n+        int l = Math.max(Math.min(last, 127), 64) - 64;\n+        for (int i = f; i <= l; i++)\n+            m |= 1L << i;\n+        return m;\n+    }\n+\n+    \/\/ Tell whether the given character is permitted by the given mask pair\n+    private static boolean match(char c, long lowMask, long highMask) {\n+        if (c < 64)\n+            return ((1L << c) & lowMask) != 0;\n+        if (c < 128)\n+            return ((1L << (c - 64)) & highMask) != 0;\n+        return false;\n+    }\n+\n+    \/\/ digit    = \"0\" | \"1\" | \"2\" | \"3\" | \"4\" | \"5\" | \"6\" | \"7\" |\n+    \/\/            \"8\" | \"9\"\n+    private static final long L_DIGIT = lowMask('0', '9');\n+    private static final long H_DIGIT = 0L;\n+\n+    \/\/ upalpha  = \"A\" | \"B\" | \"C\" | \"D\" | \"E\" | \"F\" | \"G\" | \"H\" | \"I\" |\n+    \/\/            \"J\" | \"K\" | \"L\" | \"M\" | \"N\" | \"O\" | \"P\" | \"Q\" | \"R\" |\n+    \/\/            \"S\" | \"T\" | \"U\" | \"V\" | \"W\" | \"X\" | \"Y\" | \"Z\"\n+    private static final long L_UPALPHA = 0L;\n+    private static final long H_UPALPHA = highMask('A', 'Z');\n+\n+    \/\/ lowalpha = \"a\" | \"b\" | \"c\" | \"d\" | \"e\" | \"f\" | \"g\" | \"h\" | \"i\" |\n+    \/\/            \"j\" | \"k\" | \"l\" | \"m\" | \"n\" | \"o\" | \"p\" | \"q\" | \"r\" |\n+    \/\/            \"s\" | \"t\" | \"u\" | \"v\" | \"w\" | \"x\" | \"y\" | \"z\"\n+    private static final long L_LOWALPHA = 0L;\n+    private static final long H_LOWALPHA = highMask('a', 'z');\n+\n+    \/\/ alpha         = lowalpha | upalpha\n+    private static final long L_ALPHA = L_LOWALPHA | L_UPALPHA;\n+    private static final long H_ALPHA = H_LOWALPHA | H_UPALPHA;\n+\n+    \/\/ alphanum      = alpha | digit\n+    private static final long L_ALPHANUM = L_DIGIT | L_ALPHA;\n+    private static final long H_ALPHANUM = H_DIGIT | H_ALPHA;\n+\n+    \/\/ mark          = \"-\" | \"_\" | \".\" | \"!\" | \"~\" | \"*\" | \"'\" |\n+    \/\/                 \"(\" | \")\"\n+    private static final long L_MARK = lowMask(\"-_.!~*'()\");\n+    private static final long H_MARK = highMask(\"-_.!~*'()\");\n+\n+    \/\/ unreserved    = alphanum | mark\n+    private static final long L_UNRESERVED = L_ALPHANUM | L_MARK;\n+    private static final long H_UNRESERVED = H_ALPHANUM | H_MARK;\n+\n+    \/\/ pchar         = unreserved | escaped |\n+    \/\/                 \":\" | \"@\" | \"&\" | \"=\" | \"+\" | \"$\" | \",\"\n+    private static final long L_PCHAR\n+        = L_UNRESERVED | lowMask(\":@&=+$,\");\n+    private static final long H_PCHAR\n+        = H_UNRESERVED | highMask(\":@&=+$,\");\n+\n+   \/\/ All valid path characters\n+   private static final long L_PATH = L_PCHAR | lowMask(\";\/\");\n+   private static final long H_PATH = H_PCHAR | highMask(\";\/\");\n+\n+   private static final char[] hexDigits = {\n+        '0', '1', '2', '3', '4', '5', '6', '7',\n+        '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'\n+    };\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/jrtfs\/JrtPath.java","additions":139,"deletions":12,"binary":false,"changes":151,"status":"modified"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8242258\n+ * @summary (jrtfs) Path::toUri throws AssertionError for malformed input\n+ * @run testng Test8242258\n+ *\/\n+\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Path;\n+import java.net.URI;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.assertEquals;\n+\n+public class Test8242258 {\n+    private FileSystem theFileSystem;\n+\n+    @BeforeClass\n+    public void setup() {\n+       theFileSystem = FileSystems.getFileSystem(URI.create(\"jrt:\/\"));\n+    }\n+\n+    @DataProvider(name = \"problemStrings\")\n+    private Object[][] problemStrings() {\n+        return new Object[][] {\n+            { \"[\", \"jrt:\/%5B\" },\n+            { \"]\", \"jrt:\/%5D\" },\n+            { \"{\", \"jrt:\/%7B\" },\n+            { \"}\", \"jrt:\/%7D\" },\n+            { \"`\", \"jrt:\/%60\" },\n+            { \"%\", \"jrt:\/%25\" },\n+            { \" xyz\", \"jrt:\/%20xyz\" },\n+            { \"xyz \", \"jrt:\/xyz%20\" },\n+            { \"xy z\", \"jrt:\/xy%20z\" },\n+        };\n+    }\n+\n+    @Test(dataProvider = \"problemStrings\")\n+    public void testPathToURI(String pathSuffix, String uriStr) {\n+        URI uri = theFileSystem.getPath(\"\/modules\/\" + pathSuffix).toUri();\n+        assertEquals(uri.toString(), uriStr);\n+    }\n+\n+    @Test(dataProvider = \"problemStrings\")\n+    public void testURIToPath(String pathSuffix, String uriStr) {\n+        Path path = theFileSystem.provider().getPath(URI.create(uriStr));\n+        assertEquals(path.toString(), \"\/modules\/\" + pathSuffix);\n+    }\n+}\n","filename":"test\/jdk\/jdk\/internal\/jrtfs\/Test8242258.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"}]}