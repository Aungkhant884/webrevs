{"files":[{"patch":"@@ -55,0 +55,96 @@\n+ * <h2><a id=equivalenceRelation>Floating-point Equality, Equivalence,\n+ * and Comparison<\/a><\/h2>\n+ *\n+ * IEEE 754 floating-point values include finite nonzero values,\n+ * signed zeros ({@code +0.0} and {@code -0.0}), signed infinities\n+ * {@linkplain Double#POSITIVE_INFINITY positive infinity} and\n+ * {@linkplain Double#NEGATIVE_INFINITY negative infinity}), and\n+ * {@linkplain Double#NaN NaN} (not-a-number).\n+ *\n+ * <p>An <em>equivalence relation<\/em> on a set of values is a boolean\n+ * relation on pairs of values that is reflexive, symmetric, and\n+ * transitive. For more discussion of equivalence relations and object\n+ * equality, see the {@link Object#equals Object.equals}\n+ * specification. An equivalence relation partitions the values it\n+ * operates over into sets called <i>equivalence classes<\/i>. All the\n+ * members of the equivalence class are equal to each other under the\n+ * relation. At least for some purposes, all the members of the\n+ * equivalence classes are substitutable for each other.  In\n+ * particular, in a numeric expression equivalent values can be\n+ * <em>substituted<\/em> for one another without changing the result of\n+ * the expression, meaning changing the equivalence class of the result\n+ * of the expression.\n+ * \n+ * <p>Notably, the\n+ * built-in {@code ==} operation on floating-point values does\n+ * <em>not<\/em> implement an equivalence relation. Despite not\n+ * defining an equivalence relation, the semantics of the IEEE 754\n+ * {@code ==} operator were deliberately designed to meet other needs\n+ * of numerical computation. There are two exceptions where the\n+ * properties of an equivalence relations are not satisfied by {@code\n+ * ==} on floating-point values:\n+ *\n+ * <ul>\n+ *\n+ * <li>If {@code v1} and {@code v2} are both NaN, then {@code v1\n+ * == v2} has the value {@code false}. Therefore, for two NaN\n+ * arguments the <em>reflexive<\/em> property of an equivalence\n+ * relation is <em>not<\/em> satisfied by the {@code ==} operator.\n+ *\n+ * <li>If {@code v1} represents {@code +0.0} while {@code v2}\n+ * represents {@code -0.0}, or vice versa, then {@code v1 == v2} has\n+ * the value {@code true} even though {@code +0.0} and {@code -0.0}\n+ * are distinguishable under various floating-point operations. For\n+ * example, {@code 1.0\/+0.0} evaluates to positive infinity while\n+ * {@code 1.0\/-0.0} evaluates to <em>negative<\/em> infinity and\n+ * positive infinity and negative infinity are neither equal to each\n+ * other nor equivalent to each other. Thus, while a signed zero input\n+ * most commonly determines the sign of a zero result, because of\n+ * dividing by zero, {@code +0.0} and {@code -0.0} may not be\n+ * substituted for each other in general. The sign of a zero input\n+ * also has a non-substitutable effect on the result of some math\n+ * library methods.\n+ *\n+ * <\/ul>\n+ *\n+ * <p>For ordered comparisons using the built-in comparison operators\n+ * ({@code <}, {@code <=}, etc.), NaN values have another anomalous\n+ * situation: a NaN is neither less than, nor greater than, nor equal\n+ * to any value, including itself. This means the <i>trichotomy of\n+ * comparison<\/i> does <em>not<\/em> hold.\n+ * \n+ * <p>To provide the appropriate semantics for {@code equals} and {@code\n+ * compareTo} methods, those methods cannot simply to wrappers around\n+ * {@code ==} or ordered comparison operations. Instead, {@link\n+ * Double#equals equals} defines NaN arguments to be equal to each\n+ * other and defines {@code +0.0} to <em>not<\/em> be equal to {@code\n+ * -0.0}, restoring reflexivity. For comparisons, {@link\n+ * Double#compareTo compareTo} defines a total order where {@code\n+ * -0.0} is less than {@code +0.0} and where a NaN is equal to itself\n+ * and considered greater than positive infinity.\n+ *\n+ * <p>The operational semantics of {@code equals} and {@code\n+ * compareTo} are expressed in terms of {@linkplain #doubleToLongBits\n+ * bit-wise converting} the floating-point values to integral values.\n+ *\n+ * <p>The <em>natural ordering<\/em> implemented by {@link #compareTo\n+ * compareTo} is {@linkplain Comparable consistent with equals}. That\n+ * is, two objects are reported as equal by {@code equals} if and only\n+ * if {@code compareTo} on those objects returns zero.\n+ * \n+ * <p>The adjusted behaviors defined for {@code equals} and {@code\n+ * compareTo} allow instances of wrapper classes to work properly with\n+ * conventional data structures. For example, defining NaN\n+ * values to be {@code equals} to one another allows NaN to be used as\n+ * an element of a {@link java.util.HashSet HashSet} or as the key of\n+ * a {@link java.util.HashMap HashMap}. Similarly, defining {@code\n+ * compareTo} as a total ordering, including {@code +0.0}, {@code\n+ * -0.0}, and NaN, allows instances of wrapper classes to be used as\n+ * elements of a {@link java.util.SortedSet SortedSet} or as keys of a\n+ * {@link java.util.SortedMap SortedMap}.\n+ *\n+ * @jls 4.2.3 Floating-Point Types, Formats, and Values\n+ * @jls 4.2.4. Floating-Point Operations\n+ * @jls 15.21.1 Numerical Equality Operators == and !=\n+ * @jls 15.20.1 Numerical Comparison Operators {@code <}, {@code <=}, {@code >}, and {@code >=}\n+ *\n@@ -806,6 +902,3 @@\n-     * relation must be implemented.\n-     *\n-     * However, in most cases, for two instances of class\n-     * {@code Double}, {@code d1} and {@code d2}, the\n-     * value of {@code d1.equals(d2)} is {@code true} if and\n-     * only if\n+     * relation must be implemented; see <a\n+     * href=\"#equivalenceRelation\">this discussion<\/a> for details of\n+     * floating-point equality and equivalence.\n@@ -813,43 +906,0 @@\n-     * <blockquote>\n-     *  {@code d1.doubleValue() == d2.doubleValue()}\n-     * <\/blockquote>\n-     *\n-     * <p>also has the value {@code true}. However, there are two\n-     * exceptions where the properties of an equivalence relations are\n-     * not satisfied by {@code ==}:\n-     * <ul>\n-     * <li>If {@code d1} and {@code d2} both represent\n-     *     {@code Double.NaN}, then the {@code equals} method\n-     *     returns {@code true}, even though\n-     *     {@code Double.NaN==Double.NaN} has the value\n-     *     {@code false}. Therefore, for two NaN arguments the\n-     *     <em>reflexive<\/em> property of an equivalence relation is\n-     *     <em>not<\/em> satisfied by the {@code ==} operator.\n-     *\n-     * <li>If {@code d1} represents {@code +0.0} while\n-     *     {@code d2} represents {@code -0.0}, or vice versa,\n-     *     the {@code equals} method returns the value {@code false},\n-     *     even though {@code +0.0==-0.0} has the value {@code true}.\n-     *\n-     *     In other words, while {@code +0.0} and {@code -0.0} compare\n-     *     as equal under the {@code ==} operator, they are\n-     *     <em>not<\/em> equivalent values because signed zeros can be\n-     *     distinguished under other floating-point operations. For\n-     *     example, {@code 1.0\/+0.0} evaluates to positive infinity\n-     *     while {@code 1.0\/-0.0} evaluates to <em>negative<\/em>\n-     *     infinity and positive infinity and negative infinity are\n-     *     neither equal to each other nor equivalent to each other.\n-     * <\/ul>\n-     *\n-     * Despite not defining an equivalence relation, the semantics of\n-     * the IEEE 754 {@code ==} operator were deliberately designed to\n-     * meet other needs of numerical computation.\n-     *\n-     * By defining an equivalence relation largely consistent with the\n-     * {@code ==} operator, this method allows hash tables on {@code\n-     * Double} objects to operate properly while reducing surprising\n-     * behavior.\n-     *\n-     * @param   obj   the object to compare with.\n-     * @return  {@code true} if the objects are the same;\n-     *          {@code false} otherwise.\n@@ -857,2 +907,0 @@\n-     * @jls 4.2.3 Floating-Point Types, Formats, and Values\n-     * @jls 4.2.4. Floating-Point Operations\n@@ -1018,5 +1066,0 @@\n-     * There are two ways in which comparisons performed by this\n-     * method differ from those performed by the Java language\n-     * numerical comparison operators when applied to primitive {@code\n-     * double} values:\n-     *\n@@ -1032,2 +1075,2 @@\n-     *      This method chooses to define positive zero ({@code\n-     *      0.0d}), to be greater than negative zero({@code -0.0d}).\n+     *      This method chooses to define positive zero ({@code +0.0d}),\n+     *      to be greater than negative zero ({@code -0.0d}).\n@@ -1035,3 +1078,6 @@\n-     * This ensures that the <i>natural ordering<\/i> of\n-     * {@code Double} objects imposed by this method is <i>consistent\n-     * with equals<\/i>.\n+     \n+     * This ensures that the <i>natural ordering<\/i> of {@code Double}\n+     * objects imposed by this method is <i>consistent with\n+     * equals<\/i>; see <a href=\"#equivalenceRelation\">this\n+     * discussion<\/a> for details of floating-point comparison and\n+     * ordering.\n@@ -1048,3 +1094,0 @@\n-     * @since   1.2\n-     * @jls 4.2.3 Floating-Point Types, Formats, and Values\n-     * @jls 4.2.4. Floating-Point Operations\n@@ -1052,1 +1095,1 @@\n-     * @jls 15.21.1 Numerical Equality Operators == and !=\n+     * @since   1.2\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Double.java","additions":108,"deletions":65,"binary":false,"changes":173,"status":"modified"}]}