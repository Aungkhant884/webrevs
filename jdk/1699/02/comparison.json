{"files":[{"patch":"@@ -55,0 +55,96 @@\n+ * <h2><a id=equivalenceRelation>Floating-point Equality, Equivalence,\n+ * and Comparison<\/a><\/h2>\n+ *\n+ * IEEE 754 floating-point values include finite nonzero values,\n+ * signed zeros ({@code +0.0} and {@code -0.0}), signed infinities\n+ * {@linkplain Double#POSITIVE_INFINITY positive infinity} and\n+ * {@linkplain Double#NEGATIVE_INFINITY negative infinity}), and\n+ * {@linkplain Double#NaN NaN} (not-a-number).\n+ *\n+ * <p>An <em>equivalence relation<\/em> on a set of values is a boolean\n+ * relation on pairs of values that is reflexive, symmetric, and\n+ * transitive. For more discussion of equivalence relations and object\n+ * equality, see the {@link Object#equals Object.equals}\n+ * specification. An equivalence relation partitions the values it\n+ * operates over into sets called <i>equivalence classes<\/i>. All the\n+ * members of the equivalence class are equal to each other under the\n+ * relation. At least for some purposes, all the members of the\n+ * equivalence classes are substitutable for each other.  In\n+ * particular, in a numeric expression equivalent values can be\n+ * <em>substituted<\/em> for one another without changing the result of\n+ * the expression, meaning changing the equivalence class of the result\n+ * of the expression.\n+ * \n+ * <p>Notably, the\n+ * built-in {@code ==} operation on floating-point values does\n+ * <em>not<\/em> implement an equivalence relation. Despite not\n+ * defining an equivalence relation, the semantics of the IEEE 754\n+ * {@code ==} operator were deliberately designed to meet other needs\n+ * of numerical computation. There are two exceptions where the\n+ * properties of an equivalence relations are not satisfied by {@code\n+ * ==} on floating-point values:\n+ *\n+ * <ul>\n+ *\n+ * <li>If {@code v1} and {@code v2} are both NaN, then {@code v1\n+ * == v2} has the value {@code false}. Therefore, for two NaN\n+ * arguments the <em>reflexive<\/em> property of an equivalence\n+ * relation is <em>not<\/em> satisfied by the {@code ==} operator.\n+ *\n+ * <li>If {@code v1} represents {@code +0.0} while {@code v2}\n+ * represents {@code -0.0}, or vice versa, then {@code v1 == v2} has\n+ * the value {@code true} even though {@code +0.0} and {@code -0.0}\n+ * are distinguishable under various floating-point operations. For\n+ * example, {@code 1.0\/+0.0} evaluates to positive infinity while\n+ * {@code 1.0\/-0.0} evaluates to <em>negative<\/em> infinity and\n+ * positive infinity and negative infinity are neither equal to each\n+ * other nor equivalent to each other. Thus, while a signed zero input\n+ * most commonly determines the sign of a zero result, because of\n+ * dividing by zero, {@code +0.0} and {@code -0.0} may not be\n+ * substituted for each other in general. The sign of a zero input\n+ * also has a non-substitutable effect on the result of some math\n+ * library methods.\n+ *\n+ * <\/ul>\n+ *\n+ * <p>For ordered comparisons using the built-in comparison operators\n+ * ({@code <}, {@code <=}, etc.), NaN values have another anomalous\n+ * situation: a NaN is neither less than, nor greater than, nor equal\n+ * to any value, including itself. This means the <i>trichotomy of\n+ * comparison<\/i> does <em>not<\/em> hold.\n+ * \n+ * <p>To provide the appropriate semantics for {@code equals} and {@code\n+ * compareTo} methods, those methods cannot simply to wrappers around\n+ * {@code ==} or ordered comparison operations. Instead, {@link\n+ * Double#equals equals} defines NaN arguments to be equal to each\n+ * other and defines {@code +0.0} to <em>not<\/em> be equal to {@code\n+ * -0.0}, restoring reflexivity. For comparisons, {@link\n+ * Double#compareTo compareTo} defines a total order where {@code\n+ * -0.0} is less than {@code +0.0} and where a NaN is equal to itself\n+ * and considered greater than positive infinity.\n+ *\n+ * <p>The operational semantics of {@code equals} and {@code\n+ * compareTo} are expressed in terms of {@linkplain #doubleToLongBits\n+ * bit-wise converting} the floating-point values to integral values.\n+ *\n+ * <p>The <em>natural ordering<\/em> implemented by {@link #compareTo\n+ * compareTo} is {@linkplain Comparable consistent with equals}. That\n+ * is, two objects are reported as equal by {@code equals} if and only\n+ * if {@code compareTo} on those objects returns zero.\n+ * \n+ * <p>The adjusted behaviors defined for {@code equals} and {@code\n+ * compareTo} allow instances of wrapper classes to work properly with\n+ * conventional data structures. For example, defining NaN\n+ * values to be {@code equals} to one another allows NaN to be used as\n+ * an element of a {@link java.util.HashSet HashSet} or as the key of\n+ * a {@link java.util.HashMap HashMap}. Similarly, defining {@code\n+ * compareTo} as a total ordering, including {@code +0.0}, {@code\n+ * -0.0}, and NaN, allows instances of wrapper classes to be used as\n+ * elements of a {@link java.util.SortedSet SortedSet} or as keys of a\n+ * {@link java.util.SortedMap SortedMap}.\n+ *\n+ * @jls 4.2.3 Floating-Point Types, Formats, and Values\n+ * @jls 4.2.4. Floating-Point Operations\n+ * @jls 15.21.1 Numerical Equality Operators == and !=\n+ * @jls 15.20.1 Numerical Comparison Operators {@code <}, {@code <=}, {@code >}, and {@code >=}\n+ *\n@@ -800,4 +896,9 @@\n-     * <p>Note that in most cases, for two instances of class\n-     * {@code Double}, {@code d1} and {@code d2}, the\n-     * value of {@code d1.equals(d2)} is {@code true} if and\n-     * only if\n+     * @apiNote\n+     * This method is defined in terms of {@link\n+     * #doubleToLongBits(double)} rather than the {@code ==} operator\n+     * on {@code double} values since the {@code ==} operator does\n+     * <em>not<\/em> define an equivalence relation and to satisfy the\n+     * {@linkplain Object#equals equals contract} an equivalence\n+     * relation must be implemented; see <a\n+     * href=\"#equivalenceRelation\">this discussion<\/a> for details of\n+     * floating-point equality and equivalence.\n@@ -805,21 +906,0 @@\n-     * <blockquote>\n-     *  {@code d1.doubleValue() == d2.doubleValue()}\n-     * <\/blockquote>\n-     *\n-     * <p>also has the value {@code true}. However, there are two\n-     * exceptions:\n-     * <ul>\n-     * <li>If {@code d1} and {@code d2} both represent\n-     *     {@code Double.NaN}, then the {@code equals} method\n-     *     returns {@code true}, even though\n-     *     {@code Double.NaN==Double.NaN} has the value\n-     *     {@code false}.\n-     * <li>If {@code d1} represents {@code +0.0} while\n-     *     {@code d2} represents {@code -0.0}, or vice versa,\n-     *     the {@code equal} test has the value {@code false},\n-     *     even though {@code +0.0==-0.0} has the value {@code true}.\n-     * <\/ul>\n-     * This definition allows hash tables to operate properly.\n-     * @param   obj   the object to compare with.\n-     * @return  {@code true} if the objects are the same;\n-     *          {@code false} otherwise.\n@@ -827,0 +907,1 @@\n+     * @jls 15.21.1 Numerical Equality Operators == and !=\n@@ -978,13 +1059,18 @@\n-     * Compares two {@code Double} objects numerically.  There\n-     * are two ways in which comparisons performed by this method\n-     * differ from those performed by the Java language numerical\n-     * comparison operators ({@code <, <=, ==, >=, >})\n-     * when applied to primitive {@code double} values:\n-     * <ul><li>\n-     *          {@code Double.NaN} is considered by this method\n-     *          to be equal to itself and greater than all other\n-     *          {@code double} values (including\n-     *          {@code Double.POSITIVE_INFINITY}).\n-     * <li>\n-     *          {@code 0.0d} is considered by this method to be greater\n-     *          than {@code -0.0d}.\n+     * Compares two {@code Double} objects numerically.\n+\n+     * This method imposes a total order on {@code Double} objects\n+     * with two differences compared to the incomplete order defined the\n+     * by Java language numerical comparison operators ({@code <, <=,\n+     * ==, >=, >}) on {@code double} values.\n+\n+     * <ul><li> A NaN is <em>unordered<\/em> with respect to other\n+     *          values and unequal to itself under the comparison\n+     *          operators.  This method chooses to define {@code\n+     *          Double.NaN} to be equal to itself and greater than all\n+     *          other {@code double} values (including {@code\n+     *          Double.POSITIVE_INFINITY}).\n+     *\n+     *      <li> Positive zero and negative zero compare equal\n+     *      numerically, but are distinct and distinguishable values.\n+     *      This method chooses to define positive zero ({@code +0.0d}),\n+     *      to be greater than negative zero ({@code -0.0d}).\n@@ -992,3 +1078,6 @@\n-     * This ensures that the <i>natural ordering<\/i> of\n-     * {@code Double} objects imposed by this method is <i>consistent\n-     * with equals<\/i>.\n+     \n+     * This ensures that the <i>natural ordering<\/i> of {@code Double}\n+     * objects imposed by this method is <i>consistent with\n+     * equals<\/i>; see <a href=\"#equivalenceRelation\">this\n+     * discussion<\/a> for details of floating-point comparison and\n+     * ordering.\n@@ -1005,0 +1094,1 @@\n+     * @jls 15.20.1 Numerical Comparison Operators {@code <}, {@code <=}, {@code >}, and {@code >=}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Double.java","additions":131,"deletions":41,"binary":false,"changes":172,"status":"modified"}]}