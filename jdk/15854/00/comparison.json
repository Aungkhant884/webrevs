{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,2 +27,3 @@\n-import java.nio.Buffer;\n-import java.nio.ByteBuffer;\n+import jdk.internal.access.JavaNioAccess;\n+import jdk.internal.access.SharedSecrets;\n+import jdk.internal.misc.ScopedMemoryAccess;\n@@ -37,3 +38,0 @@\n-    \/\/ Buffer.address\n-    static final long BUFFER_ADDRESS\n-            = UNSAFE.objectFieldOffset(Buffer.class, \"address\");\n@@ -41,7 +39,1 @@\n-    \/\/ Buffer.limit\n-    static final long BUFFER_LIMIT\n-            = UNSAFE.objectFieldOffset(Buffer.class, \"limit\");\n-\n-    \/\/ ByteBuffer.hb\n-    static final long BYTE_BUFFER_HB\n-            = UNSAFE.objectFieldOffset(ByteBuffer.class, \"hb\");\n+    static final boolean BE = UNSAFE.isBigEndian();\n@@ -49,3 +41,1 @@\n-    \/\/ ByteBuffer.isReadOnly\n-    static final long BYTE_BUFFER_IS_READ_ONLY\n-            = UNSAFE.objectFieldOffset(ByteBuffer.class, \"isReadOnly\");\n+    static final JavaNioAccess NIO_ACCESS = SharedSecrets.getJavaNioAccess();\n@@ -53,1 +43,1 @@\n-    static final boolean BE = UNSAFE.isBigEndian();\n+    static final ScopedMemoryAccess SCOPED_MEMORY_ACCESS = ScopedMemoryAccess.getScopedMemoryAccess();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/VarHandleByteArrayBase.java","additions":7,"deletions":17,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,8 @@\n+import jdk.internal.foreign.AbstractMemorySegmentImpl;\n+import jdk.internal.misc.ScopedMemoryAccess;\n+import jdk.internal.vm.annotation.ForceInline;\n+\n+import java.util.Objects;\n+\n+import static java.lang.invoke.MethodHandleStatics.UNSAFE;\n+\n@@ -40,0 +48,4 @@\n+    static final boolean BE = UNSAFE.isBigEndian();\n+\n+    static final ScopedMemoryAccess SCOPED_MEMORY_ACCESS = ScopedMemoryAccess.getScopedMemoryAccess();\n+\n@@ -56,0 +68,18 @@\n+    @ForceInline\n+    static AbstractMemorySegmentImpl checkAddress(Object obb, long offset, long length, boolean ro) {\n+        AbstractMemorySegmentImpl oo = (AbstractMemorySegmentImpl) Objects.requireNonNull(obb);\n+        oo.checkAccess(offset, length, ro);\n+        return oo;\n+    }\n+\n+    @ForceInline\n+    static long offsetNoVMAlignCheck(AbstractMemorySegmentImpl bb, long offset, long alignmentMask) {\n+        long base = bb.unsafeGetOffset();\n+        long address = base + offset;\n+        long maxAlignMask = bb.maxAlignMask();\n+        if (((address | maxAlignMask) & alignmentMask) != 0) {\n+            throw VarHandleSegmentViewBase.newIllegalArgumentExceptionForMisalignedAccess(address);\n+        }\n+        return address;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/VarHandleSegmentViewBase.java","additions":31,"deletions":1,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import java.lang.invoke.VarHandle.VarHandleDesc;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/X-VarHandle.java.template","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,2 +27,0 @@\n-import jdk.internal.access.JavaNioAccess;\n-import jdk.internal.access.SharedSecrets;\n@@ -31,1 +29,0 @@\n-import jdk.internal.misc.ScopedMemoryAccess;\n@@ -39,1 +36,0 @@\n-import java.util.List;\n@@ -41,1 +37,0 @@\n-import java.util.function.BiFunction;\n@@ -49,2 +44,0 @@\n-    static final JavaNioAccess NIO_ACCESS = SharedSecrets.getJavaNioAccess();\n-\n@@ -52,2 +45,0 @@\n-    \n-    static final ScopedMemoryAccess SCOPED_MEMORY_ACCESS = ScopedMemoryAccess.getScopedMemoryAccess();\n@@ -611,2 +602,1 @@\n-            MemorySegment segment = NIO_ACCESS.bufferSegment(bb);\n-            return Preconditions.checkIndex(index, UNSAFE.getInt(bb, BUFFER_LIMIT) - ALIGN, null);\n+            return Preconditions.checkIndex(index, bb.limit() - ALIGN, null);\n@@ -624,1 +614,1 @@\n-            if (UNSAFE.getBoolean(bb, BYTE_BUFFER_IS_READ_ONLY))\n+            if (bb.isReadOnly())\n@@ -631,1 +621,1 @@\n-            long address = ((long) index) + UNSAFE.getLong(bb, BUFFER_ADDRESS);\n+            long address = ((long) index) + NIO_ACCESS.getBufferAddress(bb);\n@@ -643,2 +633,2 @@\n-                    UNSAFE.getReference(bb, BYTE_BUFFER_HB),\n-                    ((long) index(bb, index)) + UNSAFE.getLong(bb, BUFFER_ADDRESS),\n+                    NIO_ACCESS.getBufferBase(bb),\n+                    ((long) index(bb, index)) + NIO_ACCESS.getBufferAddress(bb),\n@@ -649,2 +639,2 @@\n-                    UNSAFE.getReference(bb, BYTE_BUFFER_HB),\n-                    ((long) index(bb, index)) + UNSAFE.getLong(bb, BUFFER_ADDRESS),\n+                    NIO_ACCESS.getBufferBase(bb),\n+                    ((long) index(bb, index)) + NIO_ACCESS.getBufferAddress(bb),\n@@ -661,2 +651,2 @@\n-                    UNSAFE.getReference(bb, BYTE_BUFFER_HB),\n-                    ((long) indexRO(bb, index)) + UNSAFE.getLong(bb, BUFFER_ADDRESS),\n+                    NIO_ACCESS.getBufferBase(bb),\n+                    ((long) indexRO(bb, index)) + NIO_ACCESS.getBufferAddress(bb),\n@@ -667,2 +657,2 @@\n-                    UNSAFE.getReference(bb, BYTE_BUFFER_HB),\n-                    ((long) indexRO(bb, index)) + UNSAFE.getLong(bb, BUFFER_ADDRESS),\n+                    NIO_ACCESS.getBufferBase(bb),\n+                    ((long) indexRO(bb, index)) + NIO_ACCESS.getBufferAddress(bb),\n@@ -680,1 +670,1 @@\n-                                      UNSAFE.getReference(bb, BYTE_BUFFER_HB),\n+                                      NIO_ACCESS.getBufferBase(bb),\n@@ -689,1 +679,1 @@\n-                    UNSAFE.getReference(bb, BYTE_BUFFER_HB),\n+                    NIO_ACCESS.getBufferBase(bb),\n@@ -700,1 +690,1 @@\n-                                      UNSAFE.getReference(bb, BYTE_BUFFER_HB),\n+                                      NIO_ACCESS.getBufferBase(bb),\n@@ -709,1 +699,1 @@\n-                    UNSAFE.getReference(bb, BYTE_BUFFER_HB),\n+                    NIO_ACCESS.getBufferBase(bb),\n@@ -720,1 +710,1 @@\n-                                      UNSAFE.getReference(bb, BYTE_BUFFER_HB),\n+                                      NIO_ACCESS.getBufferBase(bb),\n@@ -729,1 +719,1 @@\n-                    UNSAFE.getReference(bb, BYTE_BUFFER_HB),\n+                    NIO_ACCESS.getBufferBase(bb),\n@@ -741,1 +731,1 @@\n-                    UNSAFE.getReference(bb, BYTE_BUFFER_HB),\n+                    NIO_ACCESS.getBufferBase(bb),\n@@ -746,1 +736,1 @@\n-                    UNSAFE.getReference(bb, BYTE_BUFFER_HB),\n+                    NIO_ACCESS.getBufferBase(bb),\n@@ -758,1 +748,1 @@\n-                                      UNSAFE.getReference(bb, BYTE_BUFFER_HB),\n+                                      NIO_ACCESS.getBufferBase(bb),\n@@ -769,1 +759,1 @@\n-                                      UNSAFE.getReference(bb, BYTE_BUFFER_HB),\n+                                      NIO_ACCESS.getBufferBase(bb),\n@@ -780,1 +770,1 @@\n-                                      UNSAFE.getReference(bb, BYTE_BUFFER_HB),\n+                                      NIO_ACCESS.getBufferBase(bb),\n@@ -790,1 +780,1 @@\n-                    UNSAFE.getReference(bb, BYTE_BUFFER_HB),\n+                    NIO_ACCESS.getBufferBase(bb),\n@@ -800,1 +790,1 @@\n-                    UNSAFE.getReference(bb, BYTE_BUFFER_HB),\n+                    NIO_ACCESS.getBufferBase(bb),\n@@ -810,1 +800,1 @@\n-                    UNSAFE.getReference(bb, BYTE_BUFFER_HB),\n+                    NIO_ACCESS.getBufferBase(bb),\n@@ -820,1 +810,1 @@\n-                    UNSAFE.getReference(bb, BYTE_BUFFER_HB),\n+                    NIO_ACCESS.getBufferBase(bb),\n@@ -832,1 +822,1 @@\n-                                      UNSAFE.getReference(bb, BYTE_BUFFER_HB),\n+                                      NIO_ACCESS.getBufferBase(bb),\n@@ -838,1 +828,1 @@\n-                                      UNSAFE.getReference(bb, BYTE_BUFFER_HB),\n+                                      NIO_ACCESS.getBufferBase(bb),\n@@ -850,1 +840,1 @@\n-                                      UNSAFE.getReference(bb, BYTE_BUFFER_HB),\n+                                      NIO_ACCESS.getBufferBase(bb),\n@@ -861,1 +851,1 @@\n-                                      UNSAFE.getReference(bb, BYTE_BUFFER_HB),\n+                                      NIO_ACCESS.getBufferBase(bb),\n@@ -874,1 +864,1 @@\n-                        UNSAFE.getReference(bb, BYTE_BUFFER_HB),\n+                        NIO_ACCESS.getBufferBase(bb),\n@@ -888,1 +878,1 @@\n-                        UNSAFE.getReference(bb, BYTE_BUFFER_HB),\n+                        NIO_ACCESS.getBufferBase(bb),\n@@ -902,1 +892,1 @@\n-                        UNSAFE.getReference(bb, BYTE_BUFFER_HB),\n+                        NIO_ACCESS.getBufferBase(bb),\n@@ -913,1 +903,1 @@\n-            Object base = UNSAFE.getReference(bb, BYTE_BUFFER_HB);\n+            Object base = NIO_ACCESS.getBufferBase(bb);\n@@ -931,1 +921,1 @@\n-                        UNSAFE.getReference(bb, BYTE_BUFFER_HB),\n+                        NIO_ACCESS.getBufferBase(bb),\n@@ -945,1 +935,1 @@\n-                        UNSAFE.getReference(bb, BYTE_BUFFER_HB),\n+                        NIO_ACCESS.getBufferBase(bb),\n@@ -959,1 +949,1 @@\n-                        UNSAFE.getReference(bb, BYTE_BUFFER_HB),\n+                        NIO_ACCESS.getBufferBase(bb),\n@@ -970,1 +960,1 @@\n-            Object base = UNSAFE.getReference(bb, BYTE_BUFFER_HB);\n+            Object base = NIO_ACCESS.getBufferBase(bb);\n@@ -986,1 +976,1 @@\n-                        UNSAFE.getReference(bb, BYTE_BUFFER_HB),\n+                        NIO_ACCESS.getBufferBase(bb),\n@@ -1000,1 +990,1 @@\n-                        UNSAFE.getReference(bb, BYTE_BUFFER_HB),\n+                        NIO_ACCESS.getBufferBase(bb),\n@@ -1014,1 +1004,1 @@\n-                        UNSAFE.getReference(bb, BYTE_BUFFER_HB),\n+                        NIO_ACCESS.getBufferBase(bb),\n@@ -1025,1 +1015,1 @@\n-            Object base = UNSAFE.getReference(bb, BYTE_BUFFER_HB);\n+            Object base = NIO_ACCESS.getBufferBase(bb);\n@@ -1042,1 +1032,1 @@\n-                        UNSAFE.getReference(bb, BYTE_BUFFER_HB),\n+                        NIO_ACCESS.getBufferBase(bb),\n@@ -1056,1 +1046,1 @@\n-                        UNSAFE.getReference(bb, BYTE_BUFFER_HB),\n+                        NIO_ACCESS.getBufferBase(bb),\n@@ -1070,1 +1060,1 @@\n-                        UNSAFE.getReference(bb, BYTE_BUFFER_HB),\n+                        NIO_ACCESS.getBufferBase(bb),\n@@ -1081,1 +1071,1 @@\n-            Object base = UNSAFE.getReference(bb, BYTE_BUFFER_HB);\n+            Object base = NIO_ACCESS.getBufferBase(bb);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/X-VarHandleByteArrayView.java.template","additions":47,"deletions":57,"binary":false,"changes":104,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import jdk.internal.misc.ScopedMemoryAccess;\n@@ -32,5 +31,0 @@\n-import java.lang.ref.Reference;\n-\n-import java.util.Objects;\n-\n-import static java.lang.invoke.MethodHandleStatics.UNSAFE;\n@@ -42,4 +36,0 @@\n-    static final boolean BE = UNSAFE.isBigEndian();\n-\n-    static final ScopedMemoryAccess SCOPED_MEMORY_ACCESS = ScopedMemoryAccess.getScopedMemoryAccess();\n-\n@@ -99,7 +89,0 @@\n-    @ForceInline\n-    static AbstractMemorySegmentImpl checkAddress(Object obb, long offset, long length, boolean ro) {\n-        AbstractMemorySegmentImpl oo = (AbstractMemorySegmentImpl)Objects.requireNonNull(obb);\n-        oo.checkAccess(offset, length, ro);\n-        return oo;\n-    }\n-\n@@ -115,11 +98,0 @@\n-    @ForceInline\n-    static long offsetNoVMAlignCheck(AbstractMemorySegmentImpl bb, long offset, long alignmentMask) {\n-        long base = bb.unsafeGetOffset();\n-        long address = base + offset;\n-        long maxAlignMask = bb.maxAlignMask();\n-        if (((address | maxAlignMask) & alignmentMask) != 0) {\n-            throw VarHandleSegmentViewBase.newIllegalArgumentExceptionForMisalignedAccess(address);\n-        }\n-        return address;\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/X-VarHandleSegmentView.java.template","additions":1,"deletions":29,"binary":false,"changes":30,"status":"modified"}]}