{"files":[{"patch":"@@ -0,0 +1,106 @@\n+#\n+# Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+#\n+# Redistribution and use in source and binary forms, with or without\n+# modification, are permitted provided that the following conditions\n+# are met:\n+#\n+#   - Redistributions of source code must retain the above copyright\n+#     notice, this list of conditions and the following disclaimer.\n+#\n+#   - Redistributions in binary form must reproduce the above copyright\n+#     notice, this list of conditions and the following disclaimer in the\n+#     documentation and\/or other materials provided with the distribution.\n+#\n+#   - Neither the name of Oracle nor the names of its\n+#     contributors may be used to endorse or promote products derived\n+#     from this software without specific prior written permission.\n+#\n+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\n+# IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n+# THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n+# PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n+# CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n+# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n+# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n+# PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n+# LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n+# NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n+# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+#\n+\n+SOURCEPATH=src\n+CLASSES=build\n+DIST=dist\n+RESOURCES=resources\n+\n+SWINGMARK_CLASSES = \\\n+\t$(CLASSES)\/AbstractSwingTest.class \\\n+\t$(CLASSES)\/AdvancedTextAreaTest.class \\\n+\t$(CLASSES)\/InternalFrameTest.class \\\n+\t$(CLASSES)\/JMTest_01.class \\\n+\t$(CLASSES)\/JMTest_02.class \\\n+\t$(CLASSES)\/JMTest_03.class \\\n+\t$(CLASSES)\/JMTest_04.class \\\n+\t$(CLASSES)\/JMTest_05.class \\\n+\t$(CLASSES)\/LabelTest.class \\\n+\t$(CLASSES)\/ListTest.class \\\n+\t$(CLASSES)\/MenuTest.class \\\n+\t$(CLASSES)\/NullRunnable.class \\\n+\t$(CLASSES)\/SliderTest.class \\\n+\t$(CLASSES)\/SwingMark.class \\\n+\t$(CLASSES)\/SwingMarkPanel.class \\\n+\t$(CLASSES)\/TableColMoveTest.class \\\n+\t$(CLASSES)\/TableColTest.class \\\n+\t$(CLASSES)\/TableRowTest.class \\\n+\t$(CLASSES)\/TableScrollTest.class \\\n+\t$(CLASSES)\/TextAreaTest.class \\\n+\t$(CLASSES)\/TextPaneTest.class \\\n+\t$(CLASSES)\/TreeTest.class \\\n+\t$(CLASSES)\/TypingTest.class \\\n+        $(CLASSES)\/resources\/TableRowTest.class \\\n+        $(CLASSES)\/resources\/TableRowTest_ja.class\n+\n+SWINGMARK_RESOURCES = \\\n+\t$(CLASSES)\/resources\/TestList.txt \\\n+\t$(CLASSES)\/resources\/JMTest_04.properties \\\n+\t$(CLASSES)\/resources\/JMTest_04_ja.properties \\\n+\t$(CLASSES)\/resources\/ListTest.properties \\\n+\t$(CLASSES)\/resources\/ListTest_ja.properties \\\n+\t$(CLASSES)\/resources\/TextAreaTest.properties \\\n+\t$(CLASSES)\/resources\/TextAreaTest_ja.properties\n+\n+all: mkdirs SwingMark.jar\n+\n+run: mkdirs SwingMark.jar\n+\tcd $(DIST) && java -jar SwingMark.jar -q\n+\n+SwingMark.jar: \\\n+\t$(SWINGMARK_CLASSES) \\\n+\t$(SWINGMARK_RESOURCES) \\\n+\t$(CLASSES)\/swingmark.manifest\n+\tjar cvmf $(CLASSES)\/swingmark.manifest $(DIST)\/SwingMark.jar -C $(CLASSES) .\n+\n+$(CLASSES)\/swingmark.manifest:\n+\techo \"Main-Class: SwingMark\" > $@\n+\n+$(DIST):\n+\tmkdir $(DIST)\n+\n+$(CLASSES):\n+\tmkdir $(CLASSES)\n+\n+mkdirs: $(DIST) $(CLASSES)\n+\n+$(CLASSES)\/%.class: $(SOURCEPATH)\/%.java\n+\tjavac -d $(CLASSES) -sourcepath $(SOURCEPATH) $<\n+\n+$(CLASSES)\/resources\/%.properties: $(SOURCEPATH)\/resources\/%.properties\n+\tcp -r $< $@\n+\n+$(CLASSES)\/resources\/TestList.txt: $(SOURCEPATH)\/resources\/TestList.txt\n+\tcp -r $< $@\n+\t\n+clean:\n+\trm -rf $(CLASSES)\n+\trm -rf $(DIST)\n","filename":"test\/jdk\/performance\/client\/SwingMark\/Makefile","additions":106,"deletions":0,"binary":false,"changes":106,"status":"added"},{"patch":"@@ -0,0 +1,112 @@\n+A Basic Performance Benchmark for Swing components.\n+==================================================\n+\n+Introduction\n+------------\n+SwingMark is a small suite of automated benchmark tests created to test\n+the speed of the Swing components. It is designed to be extensible so that\n+it is easy to add new tests. Each test can be run inside the SwingMarkPanel\n+test harness, or as a stand alone application.\n+\n+Getting Started\n+---------------\n+\n+To build and run, add make, java and javac to your PATH and just type\n+% make run\n+\n+This will build if needed, then execute\n+\n+% java -jar dist\/SwingMark.jar -q\n+\n+Results will be output to the console.\n+The \"-q\" causes SwingMark to exit when it is finished.\n+\n+If you run directly as below without -q you can click on the close item of the SwingMark window.\n+\n+% java -jar dist\/SwingMark.jar\n+\n+In addition the tests can be run individually.\n+For example, you could type the following:\n+\n+% java -cp SwingMark.jar SliderTest\n+\n+This will run the SliderTest as a stand alone application.\n+\n+Command Line Options\n+====================\n+\n+There are several command line options you can use to control the harness.\n+These include:\n+\n+* Repeat (-r)\n+-------------\n+The repeat option can be used to run the test suite multiple times inside the\n+same VM invocation. For example:\n+\n+% java -jar SwingMark.jar -r 5\n+\n+will run the suite 5 times in succession.\n+\n+* LookAndFeel (-lf)\n+-----------------\n+\n+You can use the -lf option to choose the Swing L&F with which to run the test.\n+For example:\n+\n+% java SwingMark -lf com.sun.java.swing.plaf.motif.MotifLookAndFeel\n+\n+will run the suite using the Motif L&F.\n+\n+Quit (-q)\n+------------\n+\n+The -q option will cause the suite to automatically exit when the run is completed.\n+\n+Version (-version)\n+------------------\n+\n+The -version option will cause a string to be printed to the console\n+which indicates the version of the suite you are running.\n+\n+Generate Report File (-f)\n+-------------------------\n+\n+The -f option will cause a text file to be generate containing information\n+about the time it took to execute each test.\n+This is a simple XML file which contains run times for each test.\n+For example:\n+% java -jar SwingMark.jar -f TestTimes.txt\n+\n+Generate Memory Report (-m)\n+--------------------------\n+\n+The -m option will cause a text file to be generate containing information\n+the amount of memory used during the test.\n+For example:\n+% java -jar SwingMark.jar -m MemoryData.txt\n+\n+Note that all these options can be combined in any order desired.\n+For example:\n+% java SwingMark -q -r 4 -lf com.me.MyLookAndFeel -f Test.txt\n+\n+Test Selection\n+==============\n+\n+A file called TestList.txt in the CWD can be used to over-ride which sets of tests are run.\n+A default file is built-in to SwingMark as a resource.\n+\n+The default file content looks like this :-\n+JMTest_04\n+TextAreaTest\n+SliderTest\n+ListTest\n+TableRowTest\n+TreeTest\n+\n+Creating New Tests\n+==================\n+\n+To create a new test, you'll need to extend AbstractSwingTest.\n+See the JavaDoc for details on what each method does.\n+Then add the name of your class to the \"TestList.txt\" file.\n+This makes it easy to run arbitrary combinations of tests.\n","filename":"test\/jdk\/performance\/client\/SwingMark\/README","additions":112,"deletions":0,"binary":false,"changes":112,"status":"added"},{"patch":"@@ -0,0 +1,226 @@\n+\/*\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ *   - Redistributions of source code must retain the above copyright\n+ *     notice, this list of conditions and the following disclaimer.\n+ *\n+ *   - Redistributions in binary form must reproduce the above copyright\n+ *     notice, this list of conditions and the following disclaimer in the\n+ *     documentation and\/or other materials provided with the distribution.\n+ *\n+ *   - Neither the name of Oracle nor the names of its\n+ *     contributors may be used to endorse or promote products derived\n+ *     from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\n+ * IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+\n+import java.awt.ActiveEvent;\n+import java.awt.Component;\n+import java.awt.EventQueue;\n+import java.awt.Rectangle;\n+import java.awt.Toolkit;\n+import java.awt.event.PaintEvent;\n+import java.awt.event.WindowAdapter;\n+import java.awt.event.WindowEvent;\n+import javax.swing.JComponent;\n+import javax.swing.JFrame;\n+import javax.swing.JPanel;\n+\n+\/**\n+  * Derive from this abstract base class when ever\n+  * you want to create a new benchmark test which\n+  * will be run in the SwingMark harness\n+  *.\n+  * The SwingMarkPanel class requires that tests subclass AbstractSwingTest.\n+  *\n+  * @see SwingMarkPanel\n+  *\n+  *\/\n+\n+public abstract class AbstractSwingTest {\n+\n+   public int paintCount = 0;\n+\n+        \/**\n+          * Override this when subclassing AbstractSwingTest.\n+          *\n+          * @return A very short description of the test\n+          *\/\n+        public abstract String getTestName();\n+\n+        \/**\n+          * Override this when subclassing AbstractSwingTest.\n+          * Here you create and initialize the component, or\n+          * group of components, which will be exercised by\n+          * your test.\n+          *\n+          * Typically you will create a JPanel and insert\n+          * components into the panel.\n+          *\n+          * @return The JComponent which will be made visible for your test\n+          *\/\n+        public abstract JComponent getTestComponent();\n+\n+        \/**\n+          * Override this when subclassing AbstractSwingTest.\n+          * Here you create the code to automate your test,\n+          * This code can be written in many ways.  For example, you\n+          * could directly modify the component, or its' model.\n+          * You could also post events to the EventQueue.\n+          * It's up to you\n+          *\/\n+        public abstract void runTest();\n+\n+        \/**\n+          * This method is used to determine if a test can be run from within\n+          * an applet.  If your test will cause security exceptions when run as\n+          * an applet then you should return false from this method.\n+          *\/\n+        public boolean canRunInApplet() {\n+                return true;\n+        }\n+\n+   public int getPaintCount() {\n+      return paintCount;\n+   }\n+        \/**\n+          * This static method is used to run your test as a stand-alone\n+          * application.  Just pass an instance of your test to this function.\n+          * This is especially useful when you're developing your test, or\n+          * when you want to concentrate on a single area.\n+          *\n+          * To allow your test to be run stand-alone, you need to add a main() that\n+          * looks like this\n+          *\n+          * public static void main(String[] args) {\n+          *     runStandAloneTest( new MyTestName() );\n+          * }\n+          *\/\n+        @SuppressWarnings(\"deprecation\")\n+        public static void runStandAloneTest(AbstractSwingTest test) {\n+            long startTime = System.currentTimeMillis();\n+            JFrame f = new JFrame();\n+            f.addWindowListener( new WindowAdapter(){\n+                            public void windowClosing(WindowEvent e){\n+                            System.exit(0);}} );\n+            f.getContentPane().add( test.getTestComponent() );\n+            f.pack();\n+            f.show();\n+            rest();\n+            syncRam();\n+            long endStartup = System.currentTimeMillis();\n+            test.runTest();\n+            rest();\n+            long endTests = System.currentTimeMillis();\n+            System.out.println(\"Startup Time: \" + (endStartup - startTime));\n+            System.out.println(\"Test Time: \" + (endTests - endStartup));\n+\n+            if (test.getPaintCount() > 0) {\n+               System.out.println(\"Called Paint: \" + test.getPaintCount() + \" times\");\n+            } else {\n+               System.out.println(\"Painting calls not counted.\");\n+            }\n+\n+        }\n+\n+        @SuppressWarnings(\"removal\")\n+        public static void syncRam() {\n+            System.gc();\n+            System.runFinalization();\n+            System.gc();\n+            try {\n+                Thread.sleep(100);\n+            } catch (Exception e) {\n+                System.out.println( \"failed sleeping \" + e);\n+            }\n+        }\n+\n+        private static Component BOGUS_COMPONENT = new JPanel();\n+        private static EventQueue Q = Toolkit.getDefaultToolkit().getSystemEventQueue();\n+\n+        \/\/ Invoked during tests to wait until the current event has finished\n+        \/\/ processing.  At the time of this writing AWT's EventQueue has 3\n+        \/\/ queues: LOW, NORMAL and HIGH.  Swing's repaint events end up on\n+        \/\/ the NORMAL queue, AWT's paint events end up on the LOW queue.  Runnable\n+        \/\/ events end up on the NORMAL queue.  The code to rest blocks until ALL\n+        \/\/ queues are empty.  This is accomplished by adding an event\n+        \/\/ (NotifyingPaintEvent) to the EventQueue.  When the event is dispatched\n+        \/\/ the EventQueue is checked, if the EQ is empty rest exits, otherwise\n+        \/\/ rest loops through adding another event to the EQ.\n+\n+        public static void rest() {\n+            Thread.yield();\n+            boolean qEmpty = false;\n+            while (!qEmpty) {\n+                NotifyingPaintEvent e = new NotifyingPaintEvent(BOGUS_COMPONENT);\n+                Q.postEvent(e);\n+                synchronized(e) {\n+                    \/\/ Wait until the event has been dispatched\n+                    while (!e.isDispatched()) {\n+                        try {\n+                            e.wait();\n+                    } catch (InterruptedException ie) {\n+                        System.out.println(\"IE: \" + ie);\n+                    }\n+                }\n+                \/\/ Check if the q is empty\n+                qEmpty = e.qEmpty();\n+            }\n+        }\n+        Toolkit.getDefaultToolkit().sync();\n+    }\n+\n+\n+    private static class NotifyingPaintEvent extends PaintEvent\n+                                 implements ActiveEvent {\n+        private static int nextLocation;\n+\n+        boolean dispatched = false;\n+        boolean qEmpty;\n+        private int location;\n+\n+        NotifyingPaintEvent(Component x) {\n+            super(x, PaintEvent.UPDATE, null);\n+            synchronized(NotifyingPaintEvent.class) {\n+                location = nextLocation++;\n+            }\n+        }\n+\n+        \/\/ 1.3 uses this for coalescing.  To avoid having these events\n+        \/\/ coalesce return a new location for each event.\n+        public Rectangle getUpdateRect() {\n+            return new Rectangle(location, location, 1, 1);\n+        }\n+\n+        public synchronized boolean isDispatched() {\n+            return dispatched;\n+        }\n+\n+        public synchronized boolean qEmpty() {\n+            return qEmpty;\n+        }\n+\n+        public void dispatch() {\n+            qEmpty = (Q.peekEvent() == null);\n+            synchronized(this) {\n+                dispatched = true;\n+                notifyAll();\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/performance\/client\/SwingMark\/src\/AbstractSwingTest.java","additions":226,"deletions":0,"binary":false,"changes":226,"status":"added"},{"patch":"@@ -0,0 +1,244 @@\n+\/*\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ *   - Redistributions of source code must retain the above copyright\n+ *     notice, this list of conditions and the following disclaimer.\n+ *\n+ *   - Redistributions in binary form must reproduce the above copyright\n+ *     notice, this list of conditions and the following disclaimer in the\n+ *     documentation and\/or other materials provided with the distribution.\n+ *\n+ *   - Neither the name of Oracle nor the names of its\n+ *     contributors may be used to endorse or promote products derived\n+ *     from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\n+ * IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+\n+import java.util.Random;\n+import java.awt.Color;\n+import java.awt.Font;\n+import java.awt.Toolkit;\n+import javax.swing.JComponent;\n+import javax.swing.JPanel;\n+import javax.swing.JScrollPane;\n+import javax.swing.JTextArea;\n+import javax.swing.SwingUtilities;\n+\n+\/**\n+  * This test is mean to isolate the speed of the JTextArea\n+  * It creates a JTextArea and then perform the following\n+  * behavios :\n+  * (1) Append text\n+  * (2) Change Font with random size and type\n+  * (3) Cut with random selection\n+  * (4) Copy with random selection\n+  * (5) Paste with random selection\n+  *\n+  *\/\n+\n+public class AdvancedTextAreaTest extends AbstractSwingTest {\n+\n+    JTextArea textArea1;\n+    final int repeat = 100;\n+\n+    public JComponent getTestComponent() {\n+        JPanel panel = new JPanel();\n+        textArea1 = new JTextArea(10, 30);\n+        textArea1.setLineWrap(true);\n+        JScrollPane scroller = new JScrollPane(textArea1);\n+        panel.add(scroller);\n+        return panel;\n+    }\n+\n+    public String getTestName() {\n+        return \"Adv TextArea\";\n+    }\n+\n+    public void runTest() {\n+        testTextArea(textArea1, \"Swing is Fast!  \");\n+    }\n+\n+    public void testTextArea(JTextArea currentTextArea, String appendThis) {\n+        TextAppender appender = new TextAppender(currentTextArea, appendThis);\n+        TextSelector selector = new TextSelector(currentTextArea);\n+        TextCutter cutter = new TextCutter (currentTextArea);\n+        TextPaster paster = new TextPaster (currentTextArea);\n+        CaretSetter caretSetter = new CaretSetter(currentTextArea);\n+        TextCopier copier = new TextCopier(currentTextArea);\n+        TextFontSetter fonter = new TextFontSetter(currentTextArea);\n+\n+        for (int i = 0; i < repeat; i++) {\n+            try {\n+                SwingUtilities.invokeLater(appender);\n+                currentTextArea.repaint();\n+                rest();\n+            } catch (Exception e) {System.out.println(e);}\n+        }\n+\n+\n+        for (int i = 0; i < repeat; i++) {\n+            try {\n+                \/\/ Change font\n+                SwingUtilities.invokeAndWait(fonter);\n+\n+                \/\/ Cut\n+                selector.setSelection();\n+                SwingUtilities.invokeAndWait(selector);\n+                SwingUtilities.invokeAndWait(cutter);\n+\n+                \/\/ Copy\n+                caretSetter.setCaretPosition();\n+                SwingUtilities.invokeAndWait(caretSetter);\n+                SwingUtilities.invokeAndWait(copier);\n+\n+                \/\/ Paste\n+                caretSetter.setCaretPosition();\n+                SwingUtilities.invokeAndWait(caretSetter);\n+                SwingUtilities.invokeAndWait(paster);\n+\n+        } catch (Exception e) {System.out.println(e);}\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        runStandAloneTest(new AdvancedTextAreaTest());\n+    }\n+\n+    static class TextAppender implements Runnable {\n+        JTextArea area;\n+        String appendString;\n+\n+\n+        public TextAppender(JTextArea textArea, String appendThis) {\n+            area = textArea;\n+            appendString = appendThis;\n+        }\n+\n+        public void run() {\n+            area.append(appendString);\n+        }\n+    }\n+\n+    static class TextCutter implements Runnable {\n+        JTextArea area;\n+\n+        public TextCutter(JTextArea textArea) {\n+            area = textArea;\n+        }\n+\n+        public void run() {\n+            area.cut();\n+        }\n+    }\n+\n+    static class TextCopier implements Runnable {\n+        JTextArea area;\n+\n+        public TextCopier(JTextArea textArea) {\n+                area = textArea;\n+        }\n+\n+        public void run() {\n+                area.copy();\n+        }\n+    }\n+\n+    static class TextFontSetter implements Runnable {\n+        JTextArea area;\n+        String[] fonts;\n+        Random random;\n+        int index = 0;\n+\n+        @SuppressWarnings(\"deprecation\")\n+        public TextFontSetter(JTextArea textArea) {\n+            area = textArea;\n+            random = new Random();\n+            fonts = Toolkit.getDefaultToolkit().getFontList();\n+        }\n+\n+        public void run() {\n+            area.setFont(new Font( fonts[index],\n+                         Math.abs(random.nextInt()) % 3,\n+                         Math.abs(random.nextInt()) % 20));\n+            area.repaint();\n+            index ++ ;\n+            index = index % fonts.length ;\n+        }\n+    }\n+\n+    static class TextPaster implements Runnable {\n+        JTextArea area;\n+\n+        public TextPaster(JTextArea textArea) {\n+            area = textArea;\n+        }\n+\n+        public void run() {\n+            area.paste();\n+        }\n+    }\n+\n+    static class TextSelector implements Runnable {\n+        JTextArea area;\n+        int start;\n+        int end;\n+        Random random;\n+\n+        public TextSelector(JTextArea textArea) {\n+            area = textArea;\n+            random = new Random();\n+        }\n+\n+        public void setSelection() {\n+            int length = area.getText().length();\n+            start = Math.abs( random.nextInt()) % length;\n+            end = start +  50;\n+\n+            if ( end >= length ) {\n+                end = length - 1 ;\n+            }\n+       }\n+\n+        public void run() {\n+            area.setSelectionStart(start);\n+            area.setSelectionEnd(end);\n+            area.setSelectionColor(new Color(Math.abs(random.nextInt()) % 256,\n+                                   Math.abs(random.nextInt()) % 256,\n+                                   Math.abs(random.nextInt()) % 256));\n+        }\n+    }\n+\n+    static class CaretSetter implements Runnable {\n+        JTextArea area;\n+        int position;\n+        Random random;\n+\n+        public CaretSetter(JTextArea textArea) {\n+            area = textArea;\n+            random = new Random();\n+        }\n+\n+        public void setCaretPosition() {\n+            position =Math.abs( random.nextInt()) % area.getText().length();\n+        }\n+\n+        public void run() {\n+            area.setCaretPosition(position);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/performance\/client\/SwingMark\/src\/AdvancedTextAreaTest.java","additions":244,"deletions":0,"binary":false,"changes":244,"status":"added"},{"patch":"@@ -0,0 +1,331 @@\n+\/*\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ *   - Redistributions of source code must retain the above copyright\n+ *     notice, this list of conditions and the following disclaimer.\n+ *\n+ *   - Redistributions in binary form must reproduce the above copyright\n+ *     notice, this list of conditions and the following disclaimer in the\n+ *     documentation and\/or other materials provided with the distribution.\n+ *\n+ *   - Neither the name of Oracle nor the names of its\n+ *     contributors may be used to endorse or promote products derived\n+ *     from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\n+ * IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+\n+import java.awt.Container;\n+import java.awt.Dimension;\n+import java.awt.FlowLayout;\n+import java.awt.Rectangle;\n+import javax.swing.JButton;\n+import javax.swing.JCheckBox;\n+import javax.swing.JComponent;\n+import javax.swing.JDesktopPane;\n+import javax.swing.JFrame;\n+import javax.swing.JInternalFrame;\n+import javax.swing.JLabel;\n+import javax.swing.JLayeredPane;\n+import javax.swing.JTextField;\n+import javax.swing.SwingUtilities;\n+import javax.swing.UIManager;\n+\n+\/**\n+ * A SwingMark to test two different aspects of InternalFrames.\n+ *   -repaint Brings each internal frame to the front of the\n+ *            other internal frames and message each widget to repaint.\n+ *   -move    Moves each of the internal frames around the desktop.\n+ *\n+ * If you you do not specify one the default is to do both.\n+ * The following options are also available:\n+ *   -numLevels          Number of levels to create, default is 1.\n+ *   -numInternalFrames  Number of internal frames to create per level,\n+                         default is 10.\n+ *   -numButtons         Number of widgets to create, default is 10.\n+ *   -laf                Look and feel to use, default is metal.\n+ *\n+ *\/\n+\n+public class InternalFrameTest extends AbstractSwingTest {\n+\n+    JDesktopPane        desktop;\n+    JFrame              frame;\n+    int                 numInternalFrames;\n+    int                 numButtons;\n+    int                 numLevels;\n+    JInternalFrame[][]  frames;\n+    int                 whatTest;\n+\n+    JComponent          widget;\n+\n+    public InternalFrameTest(int numLevels, int numInternalFrames,\n+                             int numButtons, int whatTest) {\n+        this.numLevels = numLevels;\n+        this.numInternalFrames = numInternalFrames;\n+        this.numButtons = numButtons;\n+        this.whatTest = whatTest;\n+        frames = new JInternalFrame[numLevels][];\n+        createDesktopPane();\n+        createInternalFrames();\n+    }\n+\n+    public InternalFrameTest() {\n+        this( 1, 10, 10, 3);\n+    }\n+\n+    public String getTestName() {\n+        return \"InternalFrame\";\n+    }\n+\n+    public JComponent getTestComponent() {\n+        return desktop;\n+    }\n+\n+    public void runTest() {\n+        if ((whatTest & 1) != 0) {\n+            testMove();\n+        }\n+        if ((whatTest & 2) != 0) {\n+            testRepaint();\n+        }\n+    }\n+\n+    protected void createDesktopPane() {\n+        desktop = new JDesktopPane();\n+        desktop.setPreferredSize(new Dimension(425, 425));\n+        desktop.setMinimumSize(new Dimension(425, 425));\n+    }\n+\n+    protected void createInternalFrames() {\n+        Container       parent = desktop;\n+\n+        for (int counter = 0; counter < numLevels; counter++) {\n+            Integer      level = Integer.valueOf(JLayeredPane.DEFAULT_LAYER.\n+                                             intValue() + counter);\n+\n+            frames[counter] = new JInternalFrame[numInternalFrames];\n+            for (int iCounter = 0; iCounter < numInternalFrames; iCounter++) {\n+                JInternalFrame       internalFrame;\n+\n+                internalFrame = createInternalFrame(level, iCounter);\n+                parent.add(internalFrame);\n+                frames[counter][iCounter] = internalFrame;\n+            }\n+        }\n+    }\n+\n+    protected JInternalFrame createInternalFrame(Integer id, int number) {\n+        JInternalFrame       jif;\n+\n+        jif = new JInternalFrame(\"Internal Frame \" + id + \" \" + number,\n+                                 true, true, true, true);\n+        createWidgets(jif);\n+\n+        jif.setBounds((number * 50) % 220, (number * 50) % 220,\n+                     100 + (number * 50) % 125,\n+                     100 + (number * 25) % 125);\n+\n+        return jif;\n+    }\n+\n+    protected void createWidgets(JInternalFrame jif) {\n+        Container         parent = jif.getContentPane();\n+        JComponent        child = null;\n+\n+        parent.setLayout(new FlowLayout());\n+        for (int counter = 0; counter < numButtons; counter++) {\n+            switch (counter % 4) {\n+            case 0:\n+                child = new JButton(\"Button \" + counter);\n+                break;\n+            case 1:\n+                child = new JCheckBox(\"CheckBox \" + counter);\n+                break;\n+            case 2:\n+                child = new JTextField(\"TF \" + counter);\n+                break;\n+            case 3:\n+                child = new JLabel(\"Label \" + counter);\n+                break;\n+            }\n+            parent.add(child);\n+        }\n+        if (widget == null) {\n+            widget = child;\n+        }\n+    }\n+\n+    protected void slide(MoveRunnable mv, JInternalFrame frame,\n+                         int x, int y, int newX, int newY) {\n+        int        xInc = (newX - x) \/ 10;\n+        int        yInc = (newY - y) \/ 10;\n+\n+        mv.jif = frame;\n+        mv.moveToFront = true;\n+        if (xInc != 0 || yInc != 0) {\n+            mv.jif = frame;\n+            for (int counter = 0; counter < 10; counter++) {\n+                x += xInc;\n+                y += yInc;\n+                mv.newX = x;\n+                mv.newY = y;\n+                try {\n+                    SwingUtilities.invokeLater(mv);\n+                    rest();\n+                }\n+                catch (Exception ex) {\n+                    System.out.println(\"--> \" + ex);\n+                }\n+            }\n+        }\n+    }\n+\n+    protected void testMove() {\n+        Rectangle              tempRect = new Rectangle();\n+        int                    width = desktop.getWidth();\n+        int                    height = desktop.getHeight();\n+        int                    tempWidth;\n+        int                    tempHeight;\n+        MoveRunnable           mv = new MoveRunnable();\n+\n+\n+        for (int counter = frames.length - 1; counter >= 0; counter--) {\n+            for (int iCounter = frames[counter].length - 1; iCounter >= 0;\n+                iCounter--) {\n+                JInternalFrame       iFrame = frames[counter][iCounter];\n+\n+                iFrame.getBounds(tempRect);\n+                tempWidth = width - tempRect.width;\n+                tempHeight = height - tempRect.height;\n+                \/\/ Slide to origin\n+                slide(mv, iFrame, tempRect.x, tempRect.y, 0, 0);\n+                \/\/ Slide to the right\n+                slide(mv, iFrame, 0, 0, tempWidth, 0);\n+                \/\/ Slide down\n+                slide(mv, iFrame, tempWidth, 0, tempWidth, tempHeight);\n+                \/\/ Slide to the left\n+                slide(mv, iFrame, tempWidth, tempHeight, 0, tempHeight);\n+                \/\/ Slide to original spot.\n+                slide(mv, iFrame, 0, tempHeight, tempRect.x, tempRect.y);\n+            }\n+        }\n+    }\n+\n+    public void testRepaint() {\n+        MoveRunnable      mr = new MoveRunnable();\n+        Rectangle         tempRect = new Rectangle();\n+\n+        for (int counter = frames.length - 1; counter >= 0; counter--) {\n+            for (int iCounter = frames[counter].length - 1; iCounter >= 0;\n+                iCounter--) {\n+                JInternalFrame       iFrame = frames[counter][iCounter];\n+                Container            c = iFrame.getContentPane();\n+\n+                iFrame.getBounds(tempRect);\n+\n+                mr.moveToFront = true;\n+                mr.newX = tempRect.x;\n+                mr.newY = tempRect.y;\n+                mr.jif = iFrame;\n+                try {\n+                    SwingUtilities.invokeLater(mr);\n+                    rest();\n+                }\n+                catch (Exception ex) {\n+                    System.out.println(\"--> \" + ex);\n+                }\n+\n+                iFrame.repaint();\n+                rest();\n+                for (int cCounter = c.getComponentCount() - 1;\n+                    cCounter >= 0; cCounter--) {\n+                    JComponent     comp = (JComponent)c.getComponent(cCounter);\n+\n+                    comp.getBounds(tempRect);\n+                    comp.repaint();\n+                    rest();\n+                }\n+            }\n+        }\n+    }\n+\n+    public static void main(String args[]) {\n+        int                 whatTest = 0;\n+        int                 numInternalFrames = 10;\n+        int                 numButtons = 10;\n+        int                 numLevels = 1;\n+\n+        for (int counter = args.length - 1; counter >= 0; counter--) {\n+            if (args[counter].equals(\"-repaint\")) {\n+                whatTest |= 2;\n+            }\n+            else if (args[counter].equals(\"-move\")) {\n+                whatTest |= 1;\n+            }\n+            else if (args[counter].equals(\"-numButtons\")) {\n+                try {\n+                    numButtons = Integer.parseInt(args[counter + 1]);\n+                }\n+                catch (NumberFormatException nfe) {}\n+            }\n+            else if (args[counter].equals(\"-numInternalFrames\")) {\n+                try {\n+                    numInternalFrames =Integer.parseInt(args[counter + 1]);\n+                }\n+                catch (NumberFormatException nfe) {}\n+            }\n+            else if (args[counter].equals(\"-numLevels\")) {\n+                try {\n+                    numLevels = Integer.parseInt(args[counter + 1]);\n+                }\n+                catch (NumberFormatException nfe) {}\n+            }\n+            else if (args[counter].equals(\"-laf\")) {\n+                try {\n+                    UIManager.setLookAndFeel(args[counter + 1]);\n+                }\n+                catch (Exception lafEX) {\n+                    System.out.println(\"Couldn't laf: \" + lafEX);\n+                }\n+            }\n+        }\n+        if (whatTest == 0) {\n+            whatTest = 3;\n+        }\n+        final InternalFrameTest test =\n+            new InternalFrameTest(numLevels, numInternalFrames, numButtons, whatTest);\n+\n+        runStandAloneTest(test);\n+        System.exit(1);\n+    }\n+\n+    static class MoveRunnable implements Runnable {\n+        int             newX;\n+        int             newY;\n+        JInternalFrame  jif;\n+        boolean         moveToFront;\n+\n+        public void run() {\n+            if (moveToFront) {\n+                moveToFront = false;\n+                jif.moveToFront();\n+            }\n+            jif.setLocation(newX, newY);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/performance\/client\/SwingMark\/src\/InternalFrameTest.java","additions":331,"deletions":0,"binary":false,"changes":331,"status":"added"},{"patch":"@@ -0,0 +1,195 @@\n+\/*\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ *   - Redistributions of source code must retain the above copyright\n+ *     notice, this list of conditions and the following disclaimer.\n+ *\n+ *   - Redistributions in binary form must reproduce the above copyright\n+ *     notice, this list of conditions and the following disclaimer in the\n+ *     documentation and\/or other materials provided with the distribution.\n+ *\n+ *   - Neither the name of Oracle nor the names of its\n+ *     contributors may be used to endorse or promote products derived\n+ *     from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\n+ * IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+\n+import java.util.Date;\n+import java.awt.BorderLayout;\n+import java.awt.EventQueue;\n+import java.awt.Font;\n+import java.awt.Toolkit;\n+import java.awt.event.KeyEvent;\n+import javax.swing.DefaultListModel;\n+import javax.swing.JComponent;\n+import javax.swing.JList;\n+import javax.swing.JMenu;\n+import javax.swing.JMenuBar;\n+import javax.swing.JMenuItem;\n+import javax.swing.JPanel;\n+import javax.swing.JScrollPane;\n+import javax.swing.event.MenuEvent;\n+import javax.swing.event.MenuListener;\n+\n+\/**\n+  * This tests Swing Menus by posting key events to the EventQueue\n+  * Each time a menu is selected ActionEvent\/MenuEvent is generated\n+  * and that event causes the menu text to be appended to a JList\n+  *\n+  *\/\n+\n+public class JMTest_01 extends AbstractSwingTest {\n+\n+    JList           list;\n+    JMenuBar        jmenubar = null;\n+\n+    int             nMenuCount = 2;\n+    int             nMenuItemCount = 4;\n+    int             ENTER = 10;\n+    int             LEFT = 37;\n+    int             RIGHT = 39;\n+    int             DOWN = 40;\n+    int             UP = 38;\n+\n+    \/**\n+    * This test cannot run as an applet because it\n+    * posts events to the event queue\n+    *\/\n+    public boolean canRunInApplet() {\n+            return false;\n+    }\n+\n+    public JComponent getTestComponent() {\n+        JPanel panel = new JPanel();\n+\n+        JMenu           jmenu;\n+        JMenuItem       jmenuitem;\n+\n+        panel.setLayout(new BorderLayout());\n+\n+        jmenubar = new JMenuBar();\n+        for (int i = 0; i < nMenuCount; i ++) {\n+            jmenu = new JMenu(\"JMenu\" + i);\n+            jmenu.setMnemonic('0' + i);\n+            jmenu.addMenuListener(new MyMenuListener());\n+            jmenubar.add(jmenu);\n+\n+            for (int j = 0; j < nMenuItemCount; j ++) {\n+                jmenuitem = new JMenuItem(\"JMenuItem\" + i + j);\n+                jmenuitem.setMnemonic('0' + j);\n+                jmenu.add(jmenuitem);\n+            }\n+        }\n+\n+        panel.add(\"North\", jmenubar);\n+\n+        list = new JList(new DefaultListModel());\n+        list.setFont(new Font(\"Serif\", Font.BOLD, 14));\n+        JScrollPane scrollPane = new JScrollPane(list);\n+        panel.add(\"Center\", scrollPane);\n+\n+        return panel;\n+    }\n+\n+    public String getTestName() {\n+        return \"JMTest_01\";\n+    }\n+\n+    public void runTest() {\n+        for (int i = 0; i < 10; i++) {\n+            testMenu();\n+        }\n+    }\n+\n+    @SuppressWarnings(\"deprecation\")\n+    public void testMenu() {\n+        JMenu menu;\n+        KeyEvent key;\n+        EventQueue queue = Toolkit.getDefaultToolkit().getSystemEventQueue();\n+        int direction = RIGHT;\n+\n+        int nCount = jmenubar.getMenuCount();\n+\n+        menu = jmenubar.getMenu(0);\n+        int firstMnem = menu.getMnemonic();\n+\n+        key = new KeyEvent(menu, KeyEvent.KEY_PRESSED,\n+                            new Date().getTime(), KeyEvent.ALT_DOWN_MASK, firstMnem);\n+        queue.postEvent(key);\n+\n+        for (int i = 1; i < nCount; i ++) {\n+            key = new KeyEvent(menu, KeyEvent.KEY_PRESSED,\n+                               new Date().getTime(), 0, direction);\n+            queue.postEvent(key);\n+            rest();\n+\n+            menu = jmenubar.getMenu(i);\n+\n+            try {\n+                Thread.sleep(10);\n+            } catch (Exception e) {\n+                System.out.println(e);\n+            }\n+        }\n+\n+        direction = LEFT;\n+        for (int i = 1; i < nCount; i ++) {\n+            key = new KeyEvent(menu, KeyEvent.KEY_PRESSED,\n+                               new Date().getTime(), 0, direction);\n+            queue.postEvent(key);\n+            try {\n+                Thread.sleep(10);\n+            } catch (Exception e) {\n+                System.out.println(e);\n+            }\n+\n+            menu = jmenubar.getMenu(i);\n+\n+            try {\n+                Thread.sleep(10);\n+            } catch (Exception e) {\n+                System.out.println(e);\n+            }\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        runStandAloneTest(new JMTest_01());\n+    }\n+\n+    public class MyMenuListener implements MenuListener {\n+        public void menuCanceled(MenuEvent e) {\n+        }\n+\n+        public void menuDeselected(MenuEvent e) {\n+        }\n+\n+        public void menuSelected(MenuEvent e) {\n+            JMenu comp = (JMenu) e.getSource();\n+            Display(comp.getText());\n+        }\n+    }\n+\n+    public void Display(String str) {\n+        DefaultListModel  lm = (DefaultListModel) list.getModel();\n+        lm.addElement(str);\n+        int nSize = lm.getSize();\n+        list.setSelectedIndex(nSize - 1);\n+        list.requestFocus();\n+    }\n+}\n","filename":"test\/jdk\/performance\/client\/SwingMark\/src\/JMTest_01.java","additions":195,"deletions":0,"binary":false,"changes":195,"status":"added"},{"patch":"@@ -0,0 +1,185 @@\n+\/*\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ *   - Redistributions of source code must retain the above copyright\n+ *     notice, this list of conditions and the following disclaimer.\n+ *\n+ *   - Redistributions in binary form must reproduce the above copyright\n+ *     notice, this list of conditions and the following disclaimer in the\n+ *     documentation and\/or other materials provided with the distribution.\n+ *\n+ *   - Neither the name of Oracle nor the names of its\n+ *     contributors may be used to endorse or promote products derived\n+ *     from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\n+ * IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+\n+import java.util.Date;\n+import java.awt.BorderLayout;\n+import java.awt.EventQueue;\n+import java.awt.Font;\n+import java.awt.Toolkit;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.ActionListener;\n+import java.awt.event.KeyEvent;\n+import javax.swing.DefaultListModel;\n+import javax.swing.AbstractButton;\n+import javax.swing.JComponent;\n+import javax.swing.JList;\n+import javax.swing.JMenu;\n+import javax.swing.JMenuBar;\n+import javax.swing.JMenuItem;\n+import javax.swing.JPanel;\n+import javax.swing.JScrollPane;\n+\n+\/**\n+  * This tests Swing Menus by posting key events to the EventQueue\n+  * Each time a menu is selected ActionEvent\/MenuEvent is generated\n+  * and that event causes the menu text to be appended to a JList\n+  *\/\n+\n+public class JMTest_02 extends AbstractSwingTest {\n+    JList           list;\n+    JMenuBar        jmenubar = null;\n+\n+    int             nMenuCount = 3;\n+    int             nMenuItemCount = 4;\n+    int             ENTER = 10;\n+    int             LEFT = 37;\n+    int             RIGHT = 39;\n+    int             DOWN = 40;\n+    int             UP = 38;\n+\n+    int      repeat = 15;\n+\n+    \/**\n+      * This test cannot run as an applet because it\n+      * posts events to the event queue\n+      *\/\n+    public boolean canRunInApplet() {\n+        return false;\n+    }\n+\n+    public JComponent getTestComponent() {\n+        JPanel panel = new JPanel();\n+\n+        JMenu           jmenu;\n+        JMenuItem       jmenuitem;\n+\n+        panel.setLayout(new BorderLayout());\n+\n+        jmenubar = new JMenuBar();\n+        for (int i = 0; i < nMenuCount; i ++) {\n+            jmenu = new JMenu(\"JMenu\" + i);\n+            jmenu.setMnemonic('0' + i);\n+            jmenubar.add(jmenu);\n+\n+            for (int j = 0; j < nMenuItemCount; j ++) {\n+                jmenuitem = new JMenuItem(\"JMenuItem\" + i + j);\n+                jmenuitem.setMnemonic('0' + j);\n+                jmenuitem.addActionListener(new MyActionListener());\n+                jmenu.add(jmenuitem);\n+            }\n+        }\n+\n+        panel.add(\"North\", jmenubar);\n+\n+        list = new JList(new DefaultListModel());\n+        list.setFont(new Font(\"Serif\", Font.BOLD, 14));\n+        JScrollPane scrollPane = new JScrollPane(list);\n+        panel.add(\"Center\", scrollPane);\n+\n+        return panel;\n+    }\n+\n+    public String getTestName() {\n+        return \"Menus\";\n+    }\n+\n+    public void runTest() {\n+        for (int i = 0; i < repeat; i++) {\n+            testMenu();\n+        }\n+    }\n+\n+    public void testMenu() {\n+        int direction = DOWN;\n+        FireEvents(direction);\n+    }\n+\n+    @SuppressWarnings(\"deprecation\")\n+    public void FireEvents(int direction) {\n+        int nCount = jmenubar.getMenuCount();\n+        JMenuItem menuitem;\n+        KeyEvent key;\n+        int firstMnem;\n+        JMenu   menu;\n+\n+        EventQueue queue = Toolkit.getDefaultToolkit().getSystemEventQueue();\n+        for (int i = 0; i < nCount; i++) {\n+            menu = jmenubar.getMenu(i);\n+            int nItemCount = menu.getItemCount();\n+\n+            for (int j = 0; j < nItemCount; j ++) {\n+                firstMnem = menu.getMnemonic();\n+                key = new KeyEvent(menu, KeyEvent.KEY_PRESSED,\n+                                   new Date().getTime(), KeyEvent.ALT_MASK, firstMnem);\n+                queue.postEvent(key);\n+                rest();\n+\n+                for (int k = 0; k < j; k++) {\n+                    key = new KeyEvent(menu, KeyEvent.KEY_PRESSED,\n+                                       new Date().getTime(), 0, direction);\n+                    queue.postEvent(key);\n+                    try {\n+                        Thread.sleep(10);\n+                    } catch (Exception e) {\n+                        System.out.println(e);\n+                    }\n+                }\n+\n+                key = new KeyEvent(menu, KeyEvent.KEY_PRESSED, new Date().getTime(), 0, ENTER);\n+                queue.postEvent(key);\n+                try {\n+                    Thread.sleep(10);\n+                } catch (Exception e) {\n+                    System.out.println(e);\n+                }\n+            }\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        runStandAloneTest(new JMTest_02());\n+    }\n+\n+    public class MyActionListener implements ActionListener {\n+        public void actionPerformed(ActionEvent e) {\n+                AbstractButton comp = (AbstractButton) e.getSource();\n+                Display(comp.getText());\n+        }\n+    }\n+\n+    public void Display(String str) {\n+        DefaultListModel  lm = (DefaultListModel) list.getModel();\n+        lm.addElement(str);\n+        int nSize = lm.getSize();\n+        list.setSelectedIndex(nSize - 1);\n+        list.requestFocus();\n+    }\n+}\n","filename":"test\/jdk\/performance\/client\/SwingMark\/src\/JMTest_02.java","additions":185,"deletions":0,"binary":false,"changes":185,"status":"added"},{"patch":"@@ -0,0 +1,172 @@\n+\/*\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ *   - Redistributions of source code must retain the above copyright\n+ *     notice, this list of conditions and the following disclaimer.\n+ *\n+ *   - Redistributions in binary form must reproduce the above copyright\n+ *     notice, this list of conditions and the following disclaimer in the\n+ *     documentation and\/or other materials provided with the distribution.\n+ *\n+ *   - Neither the name of Oracle nor the names of its\n+ *     contributors may be used to endorse or promote products derived\n+ *     from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\n+ * IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+\n+import java.util.Date;\n+import java.awt.BorderLayout;\n+import java.awt.EventQueue;\n+import java.awt.Font;\n+import java.awt.Toolkit;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.ActionListener;\n+import java.awt.event.KeyEvent;\n+import javax.swing.AbstractButton;\n+import javax.swing.DefaultListModel;\n+import javax.swing.JComponent;\n+import javax.swing.JList;\n+import javax.swing.JMenu;\n+import javax.swing.JMenuBar;\n+import javax.swing.JMenuItem;\n+import javax.swing.JPanel;\n+import javax.swing.JScrollPane;\n+\n+\/**\n+  * This tests Swing Menus by posting key events to the EventQueue\n+  * Each time a menu is selected ActionEvent\/MenuEvent is generated\n+  * and that event causes the menu text to be appended to a JList\n+  *\/\n+\n+public class JMTest_03 extends AbstractSwingTest {\n+    JList           list;\n+    JMenuBar        jmenubar = null;\n+\n+    int             nMenuCount = 2;\n+    int             nMenuItemCount = 4;\n+    int             ENTER = 10;\n+    int             LEFT = 37;\n+    int             RIGHT = 39;\n+    int             DOWN = 40;\n+    int             UP = 38;\n+\n+    \/**\n+     * This test cannot run as an applet because it\n+     * posts events to the event queue\n+     *\/\n+    public boolean canRunInApplet() {\n+        return false;\n+    }\n+\n+    public JComponent getTestComponent() {\n+        JPanel panel = new JPanel();\n+\n+        JMenu           jmenu;\n+        JMenuItem       jmenuitem;\n+\n+        panel.setLayout(new BorderLayout());\n+\n+        jmenubar = new JMenuBar();\n+        for (int i = 0; i < nMenuCount; i ++) {\n+            jmenu = new JMenu(\"JMenu\" + i);\n+            jmenu.setMnemonic('0' + i);\n+            jmenubar.add(jmenu);\n+\n+            for (int j = 0; j < nMenuItemCount; j ++) {\n+                jmenuitem = new JMenuItem(\"JMenuItem\" + i + j);\n+                jmenuitem.setMnemonic('0' + j);\n+                jmenuitem.addActionListener(new MyActionListener());\n+                jmenu.add(jmenuitem);\n+            }\n+        }\n+\n+        panel.add(\"North\", jmenubar);\n+\n+        list = new JList(new DefaultListModel());\n+        list.setFont(new Font(\"Serif\", Font.BOLD, 14));\n+        JScrollPane scrollPane = new JScrollPane(list);\n+        panel.add(\"Center\", scrollPane);\n+        return panel;\n+    }\n+\n+    public String getTestName() {\n+        return \"JMTest_03\";\n+    }\n+\n+    public void runTest() {\n+        for (int i = 0; i < 10; i++) {\n+            testMenu();\n+        }\n+    }\n+\n+    public void testMenu() {\n+        FireEvents();\n+    }\n+\n+    @SuppressWarnings(\"deprecation\")\n+    public void FireEvents() {\n+        int nCount = jmenubar.getMenuCount();\n+        JMenuItem menuitem;\n+        KeyEvent key;\n+        int firstMnem;\n+        JMenu   menu;\n+\n+        EventQueue queue = Toolkit.getDefaultToolkit().getSystemEventQueue();\n+        for (int i = 0; i < nCount; i++) {\n+            menu = jmenubar.getMenu(i);\n+            int nItemCount = menu.getItemCount();\n+\n+            for (int j = 0; j < nItemCount; j ++) {\n+                firstMnem = menu.getMnemonic();\n+                key = new KeyEvent(menu, KeyEvent.KEY_PRESSED,\n+                                   new Date().getTime(), KeyEvent.ALT_DOWN_MASK, firstMnem);\n+                queue.postEvent(key);\n+                rest();\n+\n+                int mnem = menu.getItem(j).getMnemonic();\n+\n+                key = new KeyEvent(menu, KeyEvent.KEY_PRESSED, new Date().getTime(), 0, mnem);\n+                queue.postEvent(key);\n+                try {\n+                    Thread.sleep(10);\n+                } catch (Exception e) {\n+                    System.out.println(e);\n+                }\n+            }\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        runStandAloneTest(new JMTest_03());\n+    }\n+\n+    public class MyActionListener implements ActionListener {\n+        public void actionPerformed(ActionEvent e) {\n+            AbstractButton comp = (AbstractButton) e.getSource();\n+            Display(comp.getText());\n+        }\n+    }\n+\n+    public void Display(String str) {\n+        DefaultListModel  lm = (DefaultListModel) list.getModel();\n+        lm.addElement(str);\n+        int nSize = lm.getSize();\n+        list.setSelectedIndex(nSize - 1);\n+        list.requestFocus();\n+    }\n+}\n","filename":"test\/jdk\/performance\/client\/SwingMark\/src\/JMTest_03.java","additions":172,"deletions":0,"binary":false,"changes":172,"status":"added"},{"patch":"@@ -0,0 +1,226 @@\n+import java.util.Date;\n+\/*\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ *   - Redistributions of source code must retain the above copyright\n+ *     notice, this list of conditions and the following disclaimer.\n+ *\n+ *   - Redistributions in binary form must reproduce the above copyright\n+ *     notice, this list of conditions and the following disclaimer in the\n+ *     documentation and\/or other materials provided with the distribution.\n+ *\n+ *   - Neither the name of Oracle nor the names of its\n+ *     contributors may be used to endorse or promote products derived\n+ *     from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\n+ * IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+\n+import java.util.ResourceBundle;\n+import java.awt.BorderLayout;\n+import java.awt.EventQueue;\n+import java.awt.Font;\n+import java.awt.Toolkit;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.ActionListener;\n+import java.awt.event.KeyEvent;\n+import javax.swing.AbstractButton;\n+import javax.swing.DefaultListModel;\n+import javax.swing.JComponent;\n+import javax.swing.JList;\n+import javax.swing.JMenu;\n+import javax.swing.JMenuBar;\n+import javax.swing.JMenuItem;\n+import javax.swing.JPanel;\n+import javax.swing.JScrollPane;\n+\n+\/**\n+  * This tests Swing Menus by posting key events to the EventQueue\n+  * Each time a menu is selected ActionEvent\/MenuEvent is generated\n+  * and that event causes the menu text to be appended to a JList\n+  *\/\n+\n+public class JMTest_04 extends AbstractSwingTest {\n+    JList       list;\n+    JMenuBar    jmenubar = null;\n+\n+    int     nMenuCount = 2;\n+    int     nMenuItemCount = 4;\n+    int     ENTER = 10;\n+    int     LEFT = 37;\n+    int     RIGHT = 39;\n+    int     DOWN = 40;\n+    int     UP = 38;\n+\n+    String MENU_STRING =  \"JMenu\";\n+    String MENU_ITEM_STRING =  \"JMenuItem\";\n+    String SUB_MENU_STRING =  \"SubMenu\";\n+\n+    \/**\n+     * This test cannot run as an applet because it\n+     * posts events to the event queue\n+     *\/\n+    public boolean canRunInApplet() {\n+        return false;\n+    }\n+\n+    public JComponent getTestComponent() {\n+        loadBundle();\n+        JPanel panel = new JPanel();\n+\n+        JMenu       jmenu;\n+        JMenuItem   jmenuitem;\n+        JMenu       jsubmenu;\n+\n+        panel.setLayout(new BorderLayout());\n+\n+        jmenubar = new JMenuBar();\n+        for (int i = 0; i < nMenuCount; i ++) {\n+            jmenu = new JMenu(MENU_STRING + i);\n+            jmenu.setMnemonic('0' + i);\n+            jmenubar.add(jmenu);\n+\n+            for (int j = 0; j < nMenuItemCount; j ++) {\n+                int mn = 'A';\n+                mn = mn + j;\n+                jsubmenu = new JMenu(SUB_MENU_STRING + String.valueOf((char) mn));\n+                jsubmenu.setMnemonic('A' + j);\n+                jmenu.add(jsubmenu);\n+                for (int k = 0; k <= j; k ++) {\n+                    jmenuitem = new JMenuItem(SUB_MENU_STRING+\" - \"+MENU_ITEM_STRING + i + (char) mn + k);\n+                    jmenuitem.setMnemonic('0' + k);\n+                    jmenuitem.addActionListener(new MyActionListener());\n+                    jsubmenu.add(jmenuitem);\n+                }\n+            }\n+        }\n+\n+\n+        panel.add(\"North\", jmenubar);\n+\n+        list = new JList(new DefaultListModel());\n+        list.setFont(new Font(\"Serif\", Font.BOLD, 14));\n+        JScrollPane scrollPane = new JScrollPane(list);\n+        panel.add(\"Center\", scrollPane);\n+\n+        return panel;\n+    }\n+\n+    private void loadBundle() {\n+        ResourceBundle bundle = ResourceBundle.getBundle(\"resources.JMTest_04\");\n+        MENU_STRING =  bundle.getString(\"MenuString\");\n+        MENU_ITEM_STRING =  bundle.getString(\"MenuItemString\");\n+        SUB_MENU_STRING =  bundle.getString(\"SubMenuString\");\n+    }\n+\n+    public String getTestName() {\n+        return \"Sub-Menus\";\n+    }\n+\n+    public void runTest() {\n+        for (int i = 0; i < 4; i++) {\n+            testMenu();\n+        }\n+    }\n+\n+    public void testMenu() {\n+        FireEvents();\n+    }\n+\n+\n+   @SuppressWarnings(\"deprecation\")\n+    public void FireEvents() {\n+        int nMenuCount = jmenubar.getMenuCount();\n+\n+        KeyEvent key;\n+        int firstMnem;\n+        int direction;\n+\n+        EventQueue queue = Toolkit.getDefaultToolkit().getSystemEventQueue();\n+        jmenubar.requestFocus();\n+        for (int i = 0; i < nMenuCount; i ++) {\n+            JMenu currentmenu = jmenubar.getMenu(i);\n+            int currentmenuMnem = currentmenu.getMnemonic();\n+\n+            int nMenuItemCount = currentmenu.getItemCount();\n+\n+            for (int j = 0; j < nMenuItemCount; j ++) {\n+                JMenuItem tempmenuitem = currentmenu.getItem(j);\n+                if (tempmenuitem instanceof JMenu) {\n+                    JMenu targetmenu = (JMenu) tempmenuitem;\n+                    int iTargetMenuCount = targetmenu.getItemCount();\n+\n+                    for (int k = 0; k < iTargetMenuCount; k ++) {\n+                        key = new KeyEvent(currentmenu, KeyEvent.KEY_PRESSED,\n+                             new Date().getTime(), KeyEvent.ALT_MASK, currentmenuMnem);\n+                        queue.postEvent(key);\n+\n+                        rest();\n+\n+                        direction = DOWN;\n+                        for (int iTemp = 0; iTemp < j; iTemp ++) {\n+                            key = new KeyEvent(currentmenu, KeyEvent.KEY_PRESSED,\n+                                new Date().getTime(), 0, direction);\n+                            queue.postEvent(key);\n+                            rest();\n+                        }\n+\n+\n+                        direction = RIGHT;\n+                        key = new KeyEvent(currentmenu, KeyEvent.KEY_PRESSED,\n+                                           new Date().getTime(), 0, direction);\n+                        queue.postEvent(key);\n+                        rest();\n+\n+                        direction = DOWN;\n+                        for (int iTemp = 0; iTemp < k; iTemp ++) {\n+                            key = new KeyEvent(targetmenu, KeyEvent.KEY_PRESSED,\n+                                                new Date().getTime(), 0, direction);\n+                            queue.postEvent(key);\n+                            rest();\n+                        }\n+\n+                        key = new KeyEvent(targetmenu, KeyEvent.KEY_PRESSED,\n+                                           new Date().getTime(), 0, ENTER);\n+                        queue.postEvent(key);\n+                        rest();\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+\n+    public static void main(String[] args) {\n+        runStandAloneTest(new JMTest_04());\n+    }\n+\n+    public class MyActionListener implements ActionListener {\n+        public void actionPerformed(ActionEvent e) {\n+            AbstractButton comp = (AbstractButton) e.getSource();\n+            Display(comp.getText());\n+        }\n+    }\n+\n+    public void Display(String str) {\n+        DefaultListModel  lm = (DefaultListModel) list.getModel();\n+        lm.addElement(str);\n+        int nSize = lm.getSize();\n+        list.setSelectedIndex(nSize - 1);\n+        list.requestFocus();\n+    }\n+}\n","filename":"test\/jdk\/performance\/client\/SwingMark\/src\/JMTest_04.java","additions":226,"deletions":0,"binary":false,"changes":226,"status":"added"},{"patch":"@@ -0,0 +1,203 @@\n+\/*\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ *   - Redistributions of source code must retain the above copyright\n+ *     notice, this list of conditions and the following disclaimer.\n+ *\n+ *   - Redistributions in binary form must reproduce the above copyright\n+ *     notice, this list of conditions and the following disclaimer in the\n+ *     documentation and\/or other materials provided with the distribution.\n+ *\n+ *   - Neither the name of Oracle nor the names of its\n+ *     contributors may be used to endorse or promote products derived\n+ *     from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\n+ * IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+\n+import java.util.Date;\n+import java.awt.BorderLayout;\n+import java.awt.EventQueue;\n+import java.awt.Font;\n+import java.awt.Toolkit;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.ActionListener;\n+import java.awt.event.KeyEvent;\n+import javax.swing.AbstractButton;\n+import javax.swing.DefaultListModel;\n+import javax.swing.JComponent;\n+import javax.swing.JList;\n+import javax.swing.JMenu;\n+import javax.swing.JMenuBar;\n+import javax.swing.JMenuItem;\n+import javax.swing.JPanel;\n+import javax.swing.JScrollPane;\n+\n+\/**\n+  * This tests Swing Menus by posting key events to the EventQueue\n+  * Each time a menu is selected ActionEvent\/MenuEvent is generated\n+  * and that event causes the menu text to be appended to a JList\n+  *\/\n+\n+public class JMTest_05 extends AbstractSwingTest {\n+    JList           list;\n+    JMenuBar        jmenubar = null;\n+\n+    int             nMenuCount = 2;\n+    int             nMenuItemCount = 4;\n+    int             ENTER = 10;\n+    int             LEFT = 37;\n+    int             RIGHT = 39;\n+    int             DOWN = 40;\n+    int             UP = 38;\n+\n+    \/**\n+     * This test cannot run as an applet because it\n+     * posts events to the event queue\n+     *\/\n+    public boolean canRunInApplet() {\n+        return false;\n+    }\n+\n+    public JComponent getTestComponent() {\n+        JPanel panel = new JPanel();\n+\n+        JMenu           jmenu;\n+        JMenuItem       jmenuitem;\n+        JMenu           jsubmenu;\n+\n+        panel.setLayout(new BorderLayout());\n+\n+        jmenubar = new JMenuBar();\n+\n+        for (int i = 0; i < nMenuCount; i ++) {\n+            jmenu = new JMenu(\"JMenu\" + i);\n+            jmenu.setMnemonic('0' + i);\n+            jmenubar.add(jmenu);\n+\n+            for (int j = 0; j < nMenuItemCount; j ++) {\n+                int mn = 'A';\n+                mn = mn + j;\n+                jsubmenu = new JMenu(\"SubMenu\" + String.valueOf((char) mn));\n+                jsubmenu.setMnemonic('A' + j);\n+                jmenu.add(jsubmenu);\n+                for (int k = 0; k <= j; k ++) {\n+                    jmenuitem = new JMenuItem(\"SubMenu - JMenuItem\" + i + (char) mn + k);\n+                    jmenuitem.setMnemonic('0' + k);\n+                    jmenuitem.addActionListener(new MyActionListener());\n+                    jsubmenu.add(jmenuitem);\n+                }\n+            }\n+        }\n+        panel.add(\"North\", jmenubar);\n+        list = new JList(new DefaultListModel());\n+        list.setFont(new Font(\"Serif\", Font.BOLD, 14));\n+        JScrollPane scrollPane = new JScrollPane(list);\n+        panel.add(\"Center\", scrollPane);\n+\n+        return panel;\n+    }\n+\n+    public String getTestName() {\n+        return \"JMTest_05\";\n+    }\n+\n+    public void runTest() {\n+        for (int i = 0; i < 10; i++) {\n+            testMenu();\n+        }\n+    }\n+\n+    public void testMenu() {\n+        FireEvents();\n+    }\n+\n+   @SuppressWarnings(\"deprecation\")\n+    public void FireEvents() {\n+        int nCount = jmenubar.getMenuCount();\n+        int mnem;\n+        JMenuItem menuitem;\n+        KeyEvent key;\n+        int firstMnem;\n+        JMenu   menu;\n+\n+        EventQueue queue = Toolkit.getDefaultToolkit().getSystemEventQueue();\n+        for (int i = 0; i < nCount; i++) {\n+            menu = jmenubar.getMenu(i);\n+            int nItemCount = menu.getItemCount();\n+\n+            for (int j = 0; j < nItemCount; j ++) {\n+                JMenuItem mi = menu.getItem(j);\n+\n+                if (mi instanceof JMenu) {\n+                    JMenu targetmenu = (JMenu) mi;\n+\n+                    int nC = targetmenu.getItemCount();\n+                    for (int k = 0; k < nC; k ++) {\n+                        firstMnem = menu.getMnemonic();\n+                        key = new KeyEvent(menu, KeyEvent.KEY_PRESSED,\n+                                           new Date().getTime(), KeyEvent.ALT_DOWN_MASK, firstMnem);\n+                        queue.postEvent(key);\n+                        rest();\n+\n+                        mnem = mi.getMnemonic();\n+                        key = new KeyEvent(menu, KeyEvent.KEY_PRESSED,\n+                                           new Date().getTime(), 0, mnem);\n+                        queue.postEvent(key);\n+                        try {\n+                                Thread.sleep(10);\n+                        } catch (Exception e) {\n+                                System.out.println(e);\n+                        }\n+\n+                        JMenuItem menui = targetmenu.getItem(k);\n+                        mnem = menui.getMnemonic();\n+                        key = new KeyEvent(targetmenu, KeyEvent.KEY_PRESSED,\n+                                           new Date().getTime(), 0, mnem);\n+\n+                        queue.postEvent(key);\n+                        try {\n+                                Thread.sleep(10);\n+                        } catch (Exception e) {\n+                                System.out.println(e);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+\n+    public static void main(String[] args) {\n+        runStandAloneTest(new JMTest_05());\n+    }\n+\n+    public class MyActionListener implements ActionListener {\n+        public void actionPerformed(ActionEvent e) {\n+            AbstractButton comp = (AbstractButton) e.getSource();\n+            Display(comp.getText());\n+        }\n+    }\n+\n+    public void Display(String str) {\n+        DefaultListModel  lm = (DefaultListModel) list.getModel();\n+        lm.addElement(str);\n+        int nSize = lm.getSize();\n+        list.setSelectedIndex(nSize - 1);\n+        list.requestFocus();\n+    }\n+}\n","filename":"test\/jdk\/performance\/client\/SwingMark\/src\/JMTest_05.java","additions":203,"deletions":0,"binary":false,"changes":203,"status":"added"},{"patch":"@@ -0,0 +1,126 @@\n+\/*\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ *   - Redistributions of source code must retain the above copyright\n+ *     notice, this list of conditions and the following disclaimer.\n+ *\n+ *   - Redistributions in binary form must reproduce the above copyright\n+ *     notice, this list of conditions and the following disclaimer in the\n+ *     documentation and\/or other materials provided with the distribution.\n+ *\n+ *   - Neither the name of Oracle nor the names of its\n+ *     contributors may be used to endorse or promote products derived\n+ *     from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\n+ * IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+\n+import java.awt.Color;\n+import java.awt.Graphics;\n+import java.awt.GridLayout;\n+import javax.swing.JComponent;\n+import javax.swing.JLabel;\n+import javax.swing.JPanel;\n+import javax.swing.SwingUtilities;\n+import javax.swing.UIManager;\n+\n+\/**\n+  * This test is mean to isolate the speed of JLabel painting\n+  * It creates a grid of JLabels (some with icons) and\n+  * proceeds to change their color and repaint them.\n+  *\/\n+\n+public class LabelTest extends AbstractSwingTest {\n+\n+   JLabel[] labels;\n+   final int repeat = 255;\n+   final int gridDimension = 6;\n+   JPanel panel;\n+\n+   public JComponent getTestComponent() {\n+      panel = new JPanel();\n+      panel.setLayout(new GridLayout( gridDimension, gridDimension) );\n+      labels = new JLabel[gridDimension*gridDimension];\n+      for (int i = 0; i < labels.length; i++) {\n+         labels[i] = new CounterLabel( \"Label #\" + i);\n+         if (i % 2 == 0) {\n+            labels[i].setOpaque(true);\n+         } else {\n+            labels[i].setOpaque(false);\n+         }\n+         panel.add(labels[i]);\n+      }\n+      labels[0].setIcon(UIManager.getIcon(\"Tree.openIcon\"));\n+      labels[5].setIcon(UIManager.getIcon(\"Tree.closedIcon\"));\n+      labels[10].setIcon(UIManager.getIcon(\"Tree.leafIcon\"));\n+      labels[15].setIcon(UIManager.getIcon(\"Tree.expandedIcon\"));\n+      labels[20].setIcon(UIManager.getIcon(\"Tree.collapsedIcon\"));\n+\n+      return panel;\n+   }\n+\n+   public String getTestName() {\n+      return \"Labels\";\n+   }\n+\n+        public void runTest() {\n+      LabelChanger changer = new LabelChanger(labels);\n+      for (int i = 0; i < repeat; i++) {\n+         try {\n+            changer.setColor( new Color( i,i,i) );\n+            SwingUtilities.invokeLater(changer);\n+            \/\/panel.repaint();\n+            rest();\n+         } catch (Exception e) {System.out.println(e);}\n+      }\n+   }\n+\n+   public static void main(String[] args) {\n+      runStandAloneTest(new LabelTest());\n+   }\n+\n+\n+   class CounterLabel extends JLabel {\n+      CounterLabel(String s) {\n+         super(s);\n+      }\n+      public void paint(Graphics g) {\n+         paintCount++;\n+         super.paint(g);\n+      }\n+   }\n+}\n+\n+class LabelChanger implements Runnable {\n+   JLabel[] labels;\n+   Color color;\n+\n+\n+   public LabelChanger(JLabel[] labelsToChange) {\n+      labels = labelsToChange;\n+   }\n+\n+   public void setColor(Color newColor) {\n+      color = newColor;\n+   }\n+\n+   public void run() {\n+      for (int i = 0; i < labels.length; i++) {\n+          labels[i].setForeground(color);\n+      }\n+   }\n+}\n","filename":"test\/jdk\/performance\/client\/SwingMark\/src\/LabelTest.java","additions":126,"deletions":0,"binary":false,"changes":126,"status":"added"},{"patch":"@@ -0,0 +1,125 @@\n+\/*\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ *   - Redistributions of source code must retain the above copyright\n+ *     notice, this list of conditions and the following disclaimer.\n+ *\n+ *   - Redistributions in binary form must reproduce the above copyright\n+ *     notice, this list of conditions and the following disclaimer in the\n+ *     documentation and\/or other materials provided with the distribution.\n+ *\n+ *   - Neither the name of Oracle nor the names of its\n+ *     contributors may be used to endorse or promote products derived\n+ *     from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\n+ * IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+\n+import java.util.ResourceBundle;\n+import java.awt.Graphics;\n+import javax.swing.JComponent;\n+import javax.swing.JList;\n+import javax.swing.JPanel;\n+import javax.swing.JScrollPane;\n+import javax.swing.SwingUtilities;\n+\n+\/**\n+  * This test is mean to isolate the speed of the JList.\n+  * It creates a JList and adds many items to it.  It then\n+  * scrolls through the list.\n+  *\/\n+\n+public class ListTest extends AbstractSwingTest {\n+    JList list1;\n+    final int list1ItemCount = 250;\n+    String DISPLAY_STRING = \"List Item \";\n+\n+    public JComponent getTestComponent() {\n+        loadBundle();\n+        JPanel panel = new JPanel();\n+        String[] list1Data = new String[list1ItemCount];\n+        for ( int i = 0; i < list1ItemCount; i++) {\n+           list1Data[i] = DISPLAY_STRING+\" \" + i;\n+        }\n+        list1 = new CountList(list1Data);\n+        JScrollPane scrollPane = new JScrollPane(list1);\n+        if (SwingMark.useBlitScrolling) {\n+           scrollPane.getViewport().putClientProperty(\"EnableWindowBlit\", Boolean.TRUE);\n+        }\n+        panel.add(scrollPane);\n+        return panel;\n+     }\n+\n+     private void loadBundle() {\n+         ResourceBundle bundle = ResourceBundle.getBundle(\"resources.ListTest\");\n+         DISPLAY_STRING = bundle.getString(\"DisplayString\");\n+     }\n+\n+     public String getTestName() {\n+         return \"Lists\";\n+     }\n+\n+     public void runTest() {\n+         testList(list1, 1);\n+     }\n+\n+     public void testList(JList currentList, int scrollBy) {\n+         ListScroller scroll = new ListScroller(currentList, scrollBy);\n+         for (int i = currentList.getSelectedIndex() ;\n+              i < currentList.getModel().getSize();\n+              i++) {\n+           try {\n+              SwingUtilities.invokeLater(scroll);\n+              rest();\n+           } catch (Exception e) {System.out.println(e);}\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        runStandAloneTest(new ListTest());\n+    }\n+\n+    class CountList extends JList {\n+        public CountList(String[] s) {\n+           super(s);\n+        }\n+\n+        public void paint(Graphics g) {\n+           super.paint(g);\n+           paintCount++;\n+        }\n+    }\n+\n+}\n+\n+\n+class ListScroller implements Runnable {\n+   JList list;\n+   int scrollAmount = 1;\n+\n+\n+   public ListScroller(JList listToScroll, int scrollBy) {\n+      list = listToScroll;\n+      scrollAmount = scrollBy;\n+   }\n+\n+   public void run() {\n+                int currentVal = list.getSelectedIndex();\n+      list.setSelectedIndex(currentVal+scrollAmount);\n+                list.ensureIndexIsVisible(currentVal+scrollAmount);\n+   }\n+}\n","filename":"test\/jdk\/performance\/client\/SwingMark\/src\/ListTest.java","additions":125,"deletions":0,"binary":false,"changes":125,"status":"added"},{"patch":"@@ -0,0 +1,169 @@\n+\/*\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ *   - Redistributions of source code must retain the above copyright\n+ *     notice, this list of conditions and the following disclaimer.\n+ *\n+ *   - Redistributions in binary form must reproduce the above copyright\n+ *     notice, this list of conditions and the following disclaimer in the\n+ *     documentation and\/or other materials provided with the distribution.\n+ *\n+ *   - Neither the name of Oracle nor the names of its\n+ *     contributors may be used to endorse or promote products derived\n+ *     from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\n+ * IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+\n+import java.util.Date;\n+import java.awt.BorderLayout;\n+import java.awt.EventQueue;\n+import java.awt.Toolkit;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.ActionListener;\n+import java.awt.event.KeyEvent;\n+import javax.swing.JComponent;\n+import javax.swing.JList;\n+import javax.swing.JMenu;\n+import javax.swing.JMenuBar;\n+import javax.swing.JMenuItem;\n+import javax.swing.JPanel;\n+import javax.swing.JScrollPane;\n+import javax.swing.JTextArea;\n+\n+\/**\n+  * This tests Swing Menus by posting key events to the EventQueue\n+  * Each time a menu is selected and ActionEvent is generated\n+  * and that event causes some text to be appended to a JTextArea\n+  *\n+  * note: this test has been replaced by JMTest_02\n+  *\/\n+\n+public class MenuTest extends AbstractSwingTest {\n+\n+   JMenuBar menuBar;\n+   JMenu menu1;\n+   JMenu menu2;\n+   JMenu menu3;\n+   JMenu menu4;\n+\n+   JMenu subMenu;\n+\n+   JTextArea textArea;\n+\n+   ActionListener listener;\n+\n+   int repeat = 50;\n+\n+   \/**\n+     * This test cannot run as an applet because it\n+     * posts events to the event queue\n+     *\/\n+   public boolean canRunInApplet() {\n+      return false;\n+   }\n+\n+   public JComponent getTestComponent() {\n+      listener = new MyListener();\n+\n+      JPanel panel = new JPanel();\n+      panel.setLayout( new BorderLayout() );\n+      menuBar = new JMenuBar();\n+      panel.add(menuBar, BorderLayout.NORTH);\n+\n+      menu1 = new JMenu(\"Menu1\");\n+      menu1.setMnemonic('M');\n+      menuBar.add(menu1);\n+      loadMenu(menu1, 5);\n+\n+      menu2 = new JMenu(\"Menu2\");\n+      menu2.setMnemonic('e');\n+      menuBar.add(menu2);\n+      loadMenu(menu2, 4);\n+\n+      menu3 = new JMenu(\"Menu3\");\n+      menu3.setMnemonic('n');\n+      menuBar.add(menu3);\n+      loadMenu(menu3, 6);\n+\n+      menu4 = new JMenu(\"Menu4\");\n+      menu4.setMnemonic('u');\n+      menuBar.add(menu4);\n+\n+      textArea = new JTextArea(10,10);\n+      textArea.setLineWrap(true);\n+      JScrollPane scroll = new JScrollPane(textArea);\n+      panel.add(scroll, BorderLayout.CENTER);\n+      return panel;\n+   }\n+\n+    private void loadMenu(JMenu menu, int numItems) {\n+       for (int i = 0; i < numItems; i++) {\n+          JMenuItem item = new JMenuItem(\"Item \" + i, String.valueOf(i).toCharArray()[0]);\n+          menu.add(item);\n+          item.addActionListener(listener);\n+       }\n+    }\n+\n+    public String getTestName() {\n+        return \"Menus\";\n+    }\n+\n+    public void runTest() {\n+       for (int i = 0; i < repeat; i++) {\n+           testMenu(menu1);\n+           testMenu(menu2);\n+           testMenu(menu3);\n+       }\n+   }\n+\n+   @SuppressWarnings(\"deprecation\")\n+   public void testMenu(JMenu currentMenu) {\n+       int c = currentMenu.getMnemonic();\n+       EventQueue queue = Toolkit.getDefaultToolkit().getSystemEventQueue();\n+\n+       for (int i = 0; i < currentMenu.getItemCount(); i++) {\n+\n+          KeyEvent key = new KeyEvent(currentMenu,\n+                    KeyEvent.KEY_PRESSED,\n+                    new Date().getTime(),\n+                    KeyEvent.ALT_DOWN_MASK,\n+                    c);\n+          queue.postEvent(key);\n+\n+          rest();\n+          key = new KeyEvent(currentMenu,\n+                    KeyEvent.KEY_PRESSED,\n+                    new Date().getTime(),\n+                    0,\n+                    currentMenu.getItem(i).getMnemonic() );\n+          queue.postEvent(key);\n+\n+       }\n+   }\n+\n+   public static void main(String[] args) {\n+      runStandAloneTest(new MenuTest());\n+   }\n+\n+   class MyListener implements ActionListener {\n+      public void actionPerformed(ActionEvent e) {\n+         JMenuItem item = (JMenuItem)e.getSource();\n+         textArea.append(item.getText() + \" \");\n+      }\n+   }\n+}\n","filename":"test\/jdk\/performance\/client\/SwingMark\/src\/MenuTest.java","additions":169,"deletions":0,"binary":false,"changes":169,"status":"added"},{"patch":"@@ -0,0 +1,42 @@\n+\/*\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ *   - Redistributions of source code must retain the above copyright\n+ *     notice, this list of conditions and the following disclaimer.\n+ *\n+ *   - Redistributions in binary form must reproduce the above copyright\n+ *     notice, this list of conditions and the following disclaimer in the\n+ *     documentation and\/or other materials provided with the distribution.\n+ *\n+ *   - Neither the name of Oracle nor the names of its\n+ *     contributors may be used to endorse or promote products derived\n+ *     from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\n+ * IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+\n+\/** This is a simple class to be used as a \"do nothing\"\n+  * it is part of the timing system.\n+  *\n+  * @see SwingMarkPanel#runTests\n+  *\/\n+\n+class NullRunnable implements Runnable {\n+   static NullRunnable singleton = new NullRunnable();\n+   public void run() {\n+   }\n+}\n","filename":"test\/jdk\/performance\/client\/SwingMark\/src\/NullRunnable.java","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -0,0 +1,111 @@\n+\/*\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ *   - Redistributions of source code must retain the above copyright\n+ *     notice, this list of conditions and the following disclaimer.\n+ *\n+ *   - Redistributions in binary form must reproduce the above copyright\n+ *     notice, this list of conditions and the following disclaimer in the\n+ *     documentation and\/or other materials provided with the distribution.\n+ *\n+ *   - Neither the name of Oracle nor the names of its\n+ *     contributors may be used to endorse or promote products derived\n+ *     from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\n+ * IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+\n+import java.awt.Graphics;\n+import javax.swing.JComponent;\n+import javax.swing.JPanel;\n+import javax.swing.JSlider;\n+import javax.swing.SwingUtilities;\n+\n+\/**\n+  * This test is mean to isolate the speed of JSlider painting\n+  * It creates a JList and then changes its value while repainting.\n+  *\n+  *\/\n+\n+public class SliderTest extends AbstractSwingTest {\n+\n+    JSlider slider1;\n+    int values = 500;\n+\n+    public SliderTest() {\n+    }\n+\n+    public JComponent getTestComponent() {\n+        JPanel panel = new JPanel();\n+        slider1 = new CountSlider(JSlider.HORIZONTAL, 0, values, 0);\n+        slider1.setMajorTickSpacing(values \/ 5);\n+        slider1.setMinorTickSpacing(values \/ 10);\n+        slider1.setPaintTicks(true);\n+        slider1.setPaintLabels(true);\n+        panel.add(slider1);\n+        return panel;\n+    }\n+\n+    public String getTestName() {\n+        return \"Sliders\";\n+    }\n+\n+    public void runTest() {\n+        testSlider(slider1, 1);  \/\/ increment this slider by ones\n+    }\n+\n+    public void testSlider(JSlider currentSlider, int incrementBy) {\n+            SliderInc inc = new SliderInc(currentSlider, incrementBy);\n+            for (int i = currentSlider.getValue() ; i < currentSlider.getMaximum(); i++) {\n+            try {\n+                SwingUtilities.invokeLater(inc);\n+                rest();\n+            } catch (Exception e) {System.out.println(e);}\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        runStandAloneTest(new SliderTest());\n+    }\n+\n+    class CountSlider extends JSlider {\n+\n+        public CountSlider(int ori, int min, int max, int curr) {\n+           super(ori, min, max, curr);\n+        }\n+\n+        public void paint(Graphics g) {\n+            super.paint(g);\n+            paintCount++;\n+            }\n+        }\n+    }\n+\n+class SliderInc implements Runnable {\n+    JSlider slider;\n+    int incAmount = 1;\n+\n+    public SliderInc(JSlider sliderToIncrement, int incrementBy) {\n+        slider = sliderToIncrement;\n+        incAmount = incrementBy;\n+    }\n+\n+    public void run() {\n+        int currentVal = slider.getValue();\n+            slider.setValue(currentVal+incAmount);\n+    }\n+}\n","filename":"test\/jdk\/performance\/client\/SwingMark\/src\/SliderTest.java","additions":111,"deletions":0,"binary":false,"changes":111,"status":"added"},{"patch":"@@ -0,0 +1,311 @@\n+\/*\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ *   - Redistributions of source code must retain the above copyright\n+ *     notice, this list of conditions and the following disclaimer.\n+ *\n+ *   - Redistributions in binary form must reproduce the above copyright\n+ *     notice, this list of conditions and the following disclaimer in the\n+ *     documentation and\/or other materials provided with the distribution.\n+ *\n+ *   - Neither the name of Oracle nor the names of its\n+ *     contributors may be used to endorse or promote products derived\n+ *     from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\n+ * IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+\n+import java.io.FileWriter;\n+import java.io.PrintWriter;\n+import java.util.Date;\n+import java.awt.Toolkit;\n+import java.awt.event.WindowAdapter;\n+import java.awt.event.WindowEvent;\n+import javax.swing.JFrame;\n+import javax.swing.RepaintManager;\n+import javax.swing.UIManager;\n+\n+\/**\n+  * This class runs the SwingMark benchmarks as an application\n+  * Simply invoke this class' main() to run the test suite.\n+  * Optionally you can use the name of a subclass of LookAndFeel\n+  * as an arguement to main().  This will use that L&F for the test.\n+  *\/\n+\n+public class SwingMark {\n+\n+   static SwingMarkPanel mainPanel;\n+   static Date startTime;\n+   static Date startupCompleteTime;\n+   static Date endTime;\n+   static int numRepeats = 1;\n+   static boolean autoQuit = false;\n+   static boolean sleepBetweenRuns = false;\n+   static boolean useBlitScrolling = false;\n+\n+   static long[][] timeReport;\n+   static long[][] memoryReport;\n+\n+   static String reportFileName = null;\n+   static String memoryReportFileName = null;\n+\n+\n+   @SuppressWarnings(\"deprecation\")\n+   public static void initFrame(JFrame frame) {\n+      mainPanel = new SwingMarkPanel();\n+      prepReports();\n+      frame.getContentPane().add(mainPanel);\n+      frame.pack();\n+      frame.show();\n+   }\n+\n+   protected static void prepReports() {\n+      if (timeReport == null) {\n+         timeReport = new long[numRepeats][mainPanel.tests.length];\n+      }\n+      if (memoryReport == null) {\n+         memoryReport = new long[numRepeats][2];\n+      }\n+   }\n+\n+   public static void main(String[] args) {\n+\n+      System.out.println(\"Starting SwingMark\");\n+      startTime = new Date();\n+      System.out.println(\"SwingMark Test started at \" + startTime);\n+\n+      parseArgs(args);\n+\n+      JFrame f = new JFrame(\"SwingMarks\");\n+      Thread.currentThread().setPriority(Thread.NORM_PRIORITY-1);\n+      f.addWindowListener( new Closer() );\n+\n+      initFrame(f);\n+      Date startupCompleteTime = new Date();\n+      long elapsedTime = startupCompleteTime.getTime() - startTime.getTime();\n+      System.out.println(\"Startup Time: \"+elapsedTime);\n+\n+\n+      \/\/int repeat = 15;\n+      for (int i = 0; i < numRepeats; i++) {\n+         mainPanel.runTests(i);\n+         if (i < numRepeats - 1) {\n+            f.setVisible(false);\n+            f.dispose();\n+            AbstractSwingTest.rest();\n+            f = new JFrame(\"SwingMarks \" + (i+2));\n+            initFrame(f);\n+            f.addWindowListener( new Closer() );\n+            System.out.println(\" **** Starting run \" + (i+2) + \"****\");\n+            maybeSleep();\n+         }\n+      }\n+\n+      Date endTime = new Date();\n+      elapsedTime = endTime.getTime() - startTime.getTime();\n+      System.out.println(\"Score: \"+elapsedTime);\n+\n+      writeReport();\n+      writeMemoryReport();\n+\n+      if (autoQuit) {\n+         System.exit(0);\n+      }\n+   }\n+\n+   static void maybeSleep() {\n+      if (sleepBetweenRuns) {\n+         for (int i = 0; i < 10; i++) {\n+            Toolkit.getDefaultToolkit().beep();\n+            try {\n+               AbstractSwingTest.syncRam();\n+               Thread.sleep(900);\n+            } catch (Exception e) {\n+               e.printStackTrace();\n+            }\n+         }\n+      }\n+   }\n+   static class Closer extends WindowAdapter {\n+      public void windowClosing(WindowEvent e) {\n+         System.exit(0);\n+      }\n+   }\n+\n+   @SuppressWarnings(\"deprecation\")\n+   private static void parseArgs(String[] args) {\n+      String lafName = UIManager.getCrossPlatformLookAndFeelClassName();\n+      int lfOpts = 0;\n+      int nOpts = 0;\n+\n+      for (int i = 0; i < args.length; i++) {\n+\n+         if (args[i].indexOf(\"-lf\") == 0) {\n+            lafName = args[i+1];\/\/.substring(3);\n+            lfOpts = 1;\n+            i++;\n+         } else if (args[i].indexOf(\"-n\") == 0) {\n+            \/\/ use native look and feel\n+            lafName = UIManager.getSystemLookAndFeelClassName();\n+            nOpts++;\n+         } else if (args[i].indexOf(\"-r\") == 0) {\n+            String repeatString = args[i+1];\/\/.substring(2);\n+            numRepeats = Integer.parseInt(repeatString);\n+            System.out.println(\"Will run test \" + numRepeats + \" times in the same VM\");\n+            i++;\n+         } else if (args[i].equals(\"-q\")) {\n+            autoQuit = true;\n+            System.out.println(\"Program will automatically terminate after last run\");\n+         } else if (args[i].equals(\"-f\")) {\n+            reportFileName = args[i+1];\n+            if (reportFileName.indexOf(\"-mmdd\") != -1) {\n+               Date date = new Date();\n+               int startpos = reportFileName.indexOf(\"-mmdd\");\n+               reportFileName =\n+               reportFileName.substring(0,startpos)+(date.getMonth()+1)+\"-\"+\n+                     date.getDate()+reportFileName.substring(startpos+5);\n+            }\n+            i++;\n+            System.out.println(\"Will write test report to file: \"+ reportFileName);\n+         } else if (args[i].equals(\"-m\")) {\n+            memoryReportFileName = args[i+1];\n+            i++;\n+            System.out.println(\"Will write memory report to file: \"+ memoryReportFileName);\n+         } else if (args[i].equals(\"-db=off\")) {\n+            RepaintManager.currentManager(null).setDoubleBufferingEnabled(false);\n+            System.out.println(\"Will run without double buffering\");\n+         } else if (args[i].equals(\"-sleep\")) {\n+            sleepBetweenRuns = true;\n+            System.out.println(\"Will sleep for 5 seconds between runs\");\n+         } else if (args[i].equals(\"-blit\")) {\n+            useBlitScrolling = true;\n+            System.out.println(\"Will use fast window blitting\");\n+         } else if (args[i].equals(\"-version\")) {\n+            System.out.println(\"SwingMark build Oct 28, 2005\");\n+         } else {\n+            System.out.println(\"Unexpected Argument: \" + args[i]);\n+            System.exit(1);\n+         }\n+      }\n+      if (lfOpts + nOpts > 1) {\n+        System.out.println(\"-lf and -n are mutually exclusive\\n\");\n+        System.exit(1);\n+      }\n+      switchLookAndFeel(lafName);\n+   }\n+\n+   private static void switchLookAndFeel(String lafName) {\n+      try {\n+         System.out.println(\"Setting L&F to: \"+ lafName);\n+         UIManager.setLookAndFeel(lafName);\n+\n+      } catch (Exception e) {\n+         System.out.println(e);\n+         System.exit(1);\n+      }\n+   }\n+\n+   protected static void writeReportHeader(PrintWriter writer) {\n+      writer.println(\"<REPORT>\");\n+\n+      writer.println(\"<NAME>SwingMark<\/NAME>\");\n+      writer.println();\n+      writer.println(\"<DATE>\" + startTime + \"<\/DATE>\");\n+      writer.println(\"<VERSION>\" + System.getProperty(\"java.version\") + \"<\/VERSION>\");\n+      writer.println(\"<VENDOR>\" + System.getProperty(\"java.vendor\") + \"<\/VENDOR>\");\n+      writer.println(\"<DIRECTORY>\" + System.getProperty(\"java.home\") + \"<\/DIRECTORY>\");\n+\n+      String vmName = System.getProperty(\"java.vm.name\");\n+      String vmVersion = System.getProperty(\"java.vm.info\");\n+\n+      String vmString = \"Undefined\";\n+      if (vmName != null && vmVersion != null) {\n+         vmString = vmName + \" \" + vmVersion;\n+      }\n+      writer.println(\"<VM_INFO>\" + vmString + \"<\/VM_INFO>\");\n+\n+      writer.print(\"<OS>\" + System.getProperty(\"os.name\") );\n+      writer.println(\" version \" + System.getProperty(\"os.version\")+ \"<\/OS>\");\n+\n+      int bits = java.awt.Toolkit.getDefaultToolkit().getColorModel().getPixelSize();\n+      writer.println(\"<BIT_DEPTH>\" + bits + \"<\/BIT_DEPTH>\");\n+\n+      writer.println();\n+   }\n+\n+   protected static void writeReportFooter(PrintWriter writer) {\n+      writer.println(\"<\/REPORT>\");\n+   }\n+\n+   protected static void writeReport() {\n+      if (reportFileName != null) {\n+         try {\n+            System.out.println(\"Writing report to file: \"+ reportFileName);\n+            FileWriter fileWriter = new FileWriter(reportFileName);\n+            PrintWriter writer = new PrintWriter(fileWriter);\n+\n+            writeReportHeader(writer);\n+\n+            writer.println(\"<DATA RUNS=\\\"\" +numRepeats+\n+                           \"\\\" TESTS=\\\"\" + mainPanel.tests.length + \"\\\" >\");\n+            for (int testNumber =0; testNumber < mainPanel.tests.length; testNumber++) {\n+               writer.print(mainPanel.tests[testNumber].getTestName() + \"\\t\");\n+               for (int runNumber = 0; runNumber < numRepeats; runNumber++) {\n+                  writer.print(timeReport[runNumber][testNumber]);\n+                  if (runNumber < numRepeats -1) {\n+                     writer.print(\"\\t\");\n+                  }\n+               }\n+               writer.println();\n+            }\n+\n+            writer.println(\"<\/DATA>\");\n+\n+            writer.println();\n+            writeReportFooter(writer);\n+\n+            writer.close();\n+            fileWriter.close();\n+         } catch (Exception e) {\n+            e.printStackTrace();\n+         }\n+      }\n+   }\n+\n+   protected static void writeMemoryReport() {\n+      if (memoryReportFileName != null) {\n+         try {\n+            System.out.println(\"Writing memory report to file: \"+ memoryReportFileName);\n+            FileWriter fileWriter = new FileWriter(memoryReportFileName);\n+            PrintWriter writer = new PrintWriter(fileWriter);\n+            writeReportHeader(writer);\n+            writer.println(\"Used Memory\\tHeapSize\");\n+            for (int runNumber = 0; runNumber < numRepeats; runNumber++) {\n+               writer.print(memoryReport[runNumber][0]);\n+               writer.print(\"\\t\");\n+               writer.println(memoryReport[runNumber][1]);\n+            }\n+            writer.println();\n+            writeReportFooter(writer);\n+            writer.close();\n+            fileWriter.close();\n+         } catch (Exception e) {\n+            e.printStackTrace();\n+         }\n+      }\n+   }\n+}\n","filename":"test\/jdk\/performance\/client\/SwingMark\/src\/SwingMark.java","additions":311,"deletions":0,"binary":false,"changes":311,"status":"added"},{"patch":"@@ -0,0 +1,168 @@\n+\/*\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ *   - Redistributions of source code must retain the above copyright\n+ *     notice, this list of conditions and the following disclaimer.\n+ *\n+ *   - Redistributions in binary form must reproduce the above copyright\n+ *     notice, this list of conditions and the following disclaimer in the\n+ *     documentation and\/or other materials provided with the distribution.\n+ *\n+ *   - Neither the name of Oracle nor the names of its\n+ *     contributors may be used to endorse or promote products derived\n+ *     from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\n+ * IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+\n+import java.io.FileNotFoundException;\n+import java.io.FileReader;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.LineNumberReader;\n+import java.util.Date;\n+import java.util.Vector;\n+import javax.swing.JTabbedPane;\n+import javax.swing.SwingUtilities;\n+\n+\/**\n+  * This class is the center point for running the automated\n+  * test suite.\n+  * It creates a number of instances of AbstractSwingTest. It\n+  * gets a component from each test and inserts it into a JTabbedPane.\n+  * It then sequentially selects each tab and runs the coresponding test\n+  *\/\n+\n+public class SwingMarkPanel extends JTabbedPane {\n+\n+   AbstractSwingTest[] tests;\n+\n+   public SwingMarkPanel() {\n+      tests = getTests();\n+      for (int i = 0; i < tests.length; i++) {\n+         addTab(tests[i].getTestName(), tests[i].getTestComponent() );\n+      }\n+      setSelectedIndex(0);\n+   }\n+\n+   \/**\n+     * add new tests to the suite by adding objects\n+     * to the array returned by this function\n+     *\/\n+   @SuppressWarnings(\"deprecation\")\n+   public AbstractSwingTest[] getTests() {\n+\n+      Vector testVector = new Vector();\n+      try {\n+\n+         String testList = \"TestList.txt\";\n+\n+         FileReader file = null;\n+         LineNumberReader reader = null;\n+\n+         try {\n+             file = new FileReader(testList);\n+             reader = new LineNumberReader(file);\n+         } catch (FileNotFoundException e) {\n+             InputStream is = getClass().getResourceAsStream(\"\/resources\/\" + testList);\n+             reader = new LineNumberReader(new InputStreamReader(is));\n+         }\n+\n+         String testName = reader.readLine();;\n+\n+         while (testName != null ) {\n+\n+            if (testName.indexOf(\"\/\/\") != 0) {\n+\n+               try {\n+                  Class testClass = Class.forName(testName);\n+                  AbstractSwingTest test = (AbstractSwingTest)testClass.newInstance();\n+                  testVector.addElement(test);\n+               } catch (Exception e) {\n+                  System.out.println(\"Error instantiating test: \" + testName);\n+                  System.out.println(\"Test must be subclass of AbstractSwingTest.\");\n+                  e.printStackTrace();\n+               }\n+               testName = reader.readLine();\n+            }\n+         }\n+         reader.close();\n+\n+      } catch (Exception e) {\n+         e.printStackTrace();\n+      }\n+\n+      AbstractSwingTest[] tests = new AbstractSwingTest[testVector.size()];\n+      testVector.copyInto(tests);\n+      return tests;\n+   }\n+\n+   \/**\n+     * run each test and print the elapsed time\n+     *\/\n+   public void runTests(int runNumber) {\n+      TabSelecter selecter = new TabSelecter();\n+      for (int testNumber = 0; testNumber < tests.length; testNumber++) {\n+         selecter.setSelection(testNumber);\n+         try {\n+            \/\/ select the next tab\n+            SwingUtilities.invokeAndWait(selecter);\n+            AbstractSwingTest.rest();\n+         } catch (Exception e) {\n+            System.out.println(e);\n+         }\n+         Date start = new Date();  \/\/ mark the start time\n+         tests[testNumber].runTest();\n+         try {\n+            \/\/ wait for event queue to clear\n+            SwingUtilities.invokeAndWait(NullRunnable.singleton);\n+            AbstractSwingTest.syncRam();\n+            AbstractSwingTest.rest();\n+         } catch (Exception e) {\n+            System.out.println(e);\n+         }\n+         Date end = new Date();  \/\/ mark the completion time\n+         long elapsedTime = end.getTime() - start.getTime();\n+\n+         Runtime runtime = Runtime.getRuntime();\n+         long heapSize = runtime.totalMemory();\n+         long freeMemory = runtime.freeMemory();\n+         long usedMemory = heapSize - freeMemory;\n+         SwingMark.memoryReport[runNumber][0] = usedMemory;\n+         SwingMark.memoryReport[runNumber][1] = heapSize;\n+\n+         SwingMark.timeReport[runNumber][testNumber] = elapsedTime;\n+\n+         System.out.println(tests[testNumber].getTestName() +\n+                            \" = \" + elapsedTime +\n+                            \"   (Paint = \" + tests[testNumber].getPaintCount() + \")\");\n+      }\n+   }\n+\n+   class TabSelecter implements Runnable {\n+      int selection;\n+\n+      void setSelection(int tabToSelect) {\n+         selection = tabToSelect;\n+      }\n+\n+      public void run() {\n+         SwingMarkPanel.this.setSelectedIndex(selection);\n+         SwingMarkPanel.this.repaint();\n+      }\n+   }\n+}\n","filename":"test\/jdk\/performance\/client\/SwingMark\/src\/SwingMarkPanel.java","additions":168,"deletions":0,"binary":false,"changes":168,"status":"added"},{"patch":"@@ -0,0 +1,103 @@\n+\/*\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ *   - Redistributions of source code must retain the above copyright\n+ *     notice, this list of conditions and the following disclaimer.\n+ *\n+ *   - Redistributions in binary form must reproduce the above copyright\n+ *     notice, this list of conditions and the following disclaimer in the\n+ *     documentation and\/or other materials provided with the distribution.\n+ *\n+ *   - Neither the name of Oracle nor the names of its\n+ *     contributors may be used to endorse or promote products derived\n+ *     from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\n+ * IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+\n+import java.awt.Rectangle;\n+import javax.swing.JComponent;\n+import javax.swing.JPanel;\n+import javax.swing.JScrollPane;\n+import javax.swing.JTable;\n+import javax.swing.table.DefaultTableModel;\n+import javax.swing.table.TableModel;\n+import javax.swing.SwingUtilities;\n+\n+\/**\n+  * This test is mean to isolate the speed of the JTable.\n+  * It creates a JTable and moves columns.\n+  *\/\n+\n+public class TableColMoveTest extends AbstractSwingTest {\n+   JTable table;\n+\n+   public JComponent getTestComponent() {\n+       JPanel panel = new JPanel();\n+       TableModel dataModel = new DefaultTableModel() {\n+         public int getColumnCount(){ return 25; }\n+         public int getRowCount() { return 20;}\n+         public Object getValueAt(int row, int col) { return Integer.valueOf(col) ;}\n+       };\n+\n+       table = new JTable(dataModel);\n+       JScrollPane scrollPane = new JScrollPane(table);\n+       panel.add(scrollPane);\n+       return panel;\n+    }\n+\n+    public String getTestName() {\n+       return \"Table Column Move Test\";\n+    }\n+\n+    public void runTest() {\n+       testTable(table, 1);\n+    }\n+\n+    public void testTable(JTable currentTable, int scrollBy) {\n+\n+      TableColMover colmover = new TableColMover(currentTable);\n+      \/\/ Column Selection Test\n+      currentTable.clearSelection();\n+\n+      for (int i = 0 ; i < currentTable.getColumnCount(); i++) {\n+        try {\n+          SwingUtilities.invokeAndWait(colmover);\n+        } catch (Exception e) {System.out.println(e);}\n+      }\n+   }\n+\n+   public static void main(String[] args) {\n+      runStandAloneTest(new TableColMoveTest());\n+   }\n+}\n+\n+\n+class TableColMover implements Runnable {\n+    JTable table;\n+\n+    public TableColMover(JTable table) {\n+        this.table = table;\n+    }\n+\n+    public void run() {\n+       table.moveColumn(0, table.getColumnCount()-1 );\n+       Rectangle cellBound = table.getCellRect(0, table.getColumnCount()-1, true);\n+       table.scrollRectToVisible(cellBound);\n+       table.repaint();\n+    }\n+}\n","filename":"test\/jdk\/performance\/client\/SwingMark\/src\/TableColMoveTest.java","additions":103,"deletions":0,"binary":false,"changes":103,"status":"added"},{"patch":"@@ -0,0 +1,210 @@\n+\/*\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ *   - Redistributions of source code must retain the above copyright\n+ *     notice, this list of conditions and the following disclaimer.\n+ *\n+ *   - Redistributions in binary form must reproduce the above copyright\n+ *     notice, this list of conditions and the following disclaimer in the\n+ *     documentation and\/or other materials provided with the distribution.\n+ *\n+ *   - Neither the name of Oracle nor the names of its\n+ *     contributors may be used to endorse or promote products derived\n+ *     from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\n+ * IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+\n+import java.awt.Rectangle;\n+import javax.swing.JComponent;\n+import javax.swing.JPanel;\n+import javax.swing.JScrollPane;\n+import javax.swing.JTable;\n+import javax.swing.ListSelectionModel;\n+import javax.swing.table.DefaultTableModel;\n+import javax.swing.table.TableColumn;\n+import javax.swing.table.TableModel;\n+import javax.swing.SwingUtilities;\n+\n+\/**\n+  * This test is mean to isolate the speed of the JTable.\n+  * It creates a JTable and performs the following scenarios :\n+  * 1) Remove columns\n+  * 2) Add columns\n+  * 3) Select columns\n+  *    -Single Selection mode\n+  *    -Single Selection Interval\n+  *    -Multiple Selection Intervas\n+  *\/\n+\n+public class TableColTest extends AbstractSwingTest {\n+   JTable table;\n+   TableModel dataModel;\n+\n+   public JComponent getTestComponent() {\n+       JPanel panel = new JPanel();\n+       dataModel = new DefaultTableModel() {\n+         public int getColumnCount(){ return 30; }\n+         public int getRowCount() { return 40;}\n+         public Object getValueAt(int row, int col) { return Integer.valueOf(col) ;}\n+       };\n+\n+       table = new JTable(dataModel);\n+       table.setAutoResizeMode(JTable.AUTO_RESIZE_OFF);\n+       JScrollPane scrollPane = new JScrollPane(table);\n+       panel.add(scrollPane);\n+       return panel;\n+    }\n+\n+    public String getTestName() {\n+       return \"Table Column Test\";\n+    }\n+\n+    public void runTest() {\n+       testTable(table, 1);\n+    }\n+\n+    public void testTable(JTable currentTable, int scrollBy) {\n+      currentTable.setColumnSelectionAllowed(true);\n+\n+      \/\/ remove column\n+      System.out.println(\"1)Removing Columns\");\n+      TableColAdder colRemover = new TableColAdder(currentTable,false);\n+      while(currentTable.getColumnCount() > 0 ) {\n+        try {\n+            SwingUtilities.invokeAndWait(colRemover);\n+        } catch (Exception e) {System.out.println(e);}\n+      }\n+\n+      \/\/ add row\n+      System.out.println(\"2)Adding Columns\");\n+      TableColAdder colAdder = new TableColAdder(currentTable,true);\n+      for ( int i = 0 ; i < dataModel.getColumnCount(); i++ ) {\n+\n+        try {\n+            colAdder.setModelIndex(i);\n+            SwingUtilities.invokeAndWait(colAdder);\n+        } catch (Exception e) {System.out.println(e);}\n+      }\n+\n+\n+\n+      \/\/ Selection Mode test\n+      System.out.println(\"3)Selection Mode Test\");\n+      for ( int m = 0 ; m < 3 ; m ++ ) { \/\/ m represents selection mode\n+          System.out.println(\"  --------- Selection Mode :\" + m );\n+\n+          TableColScroller colScroll = new TableColScroller(currentTable, scrollBy, m);\n+\n+          \/\/ Column Selection Test\n+          currentTable.clearSelection();\n+\n+          for (int i = 0 ;\n+               i <= currentTable.getColumnCount();\n+               i= currentTable.getSelectedColumn()) {\n+              try {\n+                  SwingUtilities.invokeAndWait(colScroll);\n+              } catch (Exception e) {System.out.println(e);}\n+          }\n+      }\n+   }\n+\n+   public static void main(String[] args) {\n+      runStandAloneTest(new TableColTest());\n+   }\n+\n+}\n+\n+\n+class TableColScroller implements Runnable {\n+    JTable table;\n+    int scrollAmount = 1;\n+    int currentColSelection = 0;\n+\n+    public TableColScroller(JTable tableToScroll, int scrollBy, int selectionMode) {\n+      table =  tableToScroll;\n+      scrollAmount = scrollBy;\n+      table.setSelectionMode( selectionMode);\n+    }\n+\n+    public void run() {\n+\n+        int endInterval = 0;\n+\n+        switch ( table.getSelectionModel().getSelectionMode() ) {\n+\n+           case ListSelectionModel.SINGLE_SELECTION:\n+               endInterval = currentColSelection;\n+               table.addColumnSelectionInterval(currentColSelection, endInterval);\n+               currentColSelection ++;\n+               break;\n+\n+           case ListSelectionModel.SINGLE_INTERVAL_SELECTION:\n+               endInterval = ((currentColSelection + 2) >= table.getColumnCount()-1 ) ?\n+                 table.getColumnCount()-1 : currentColSelection+2 ;\n+               table.addColumnSelectionInterval(currentColSelection, endInterval);\n+               currentColSelection++;\n+               break;\n+\n+           case ListSelectionModel.MULTIPLE_INTERVAL_SELECTION:\n+               endInterval = (currentColSelection >= table.getColumnCount()-1 ) ?\n+                 table.getColumnCount()-1 :currentColSelection+1;\n+\n+               table.addColumnSelectionInterval(currentColSelection, endInterval);\n+               currentColSelection += 3;\n+               break;\n+\n+           default:\n+               break;\n+     }\n+\n+     Rectangle cellBound = table.getCellRect(0, endInterval, true);\n+     table.scrollRectToVisible(cellBound);\n+     table.repaint();\n+    }\n+}\n+\n+class TableColAdder implements Runnable {\n+  JTable table;\n+  int currentRowSelection = 0;\n+  int index = 0;\n+  boolean add = true; \/\/ false for \"remove\"\n+  int rowCount=40;\n+\n+\n+  public TableColAdder(JTable table, boolean add) {\n+     this.table =  table;\n+     this.add = add;\n+  }\n+\n+  public void setModelIndex(int i) {\n+    this.index = i ;\n+  }\n+\n+  public void run() {\n+     Rectangle cellBound;\n+\n+     if (add) {\n+       table.addColumn( new TableColumn(index));\n+       cellBound = table.getCellRect(0,table.getColumnCount()-1,true);\n+     } else {\n+       table.removeColumn( table.getColumn( table.getColumnName(0)));\n+       cellBound = table.getCellRect(0,0,true);\n+     }\n+     table.scrollRectToVisible(cellBound);\n+  }\n+}\n","filename":"test\/jdk\/performance\/client\/SwingMark\/src\/TableColTest.java","additions":210,"deletions":0,"binary":false,"changes":210,"status":"added"},{"patch":"@@ -0,0 +1,234 @@\n+\/*\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ *   - Redistributions of source code must retain the above copyright\n+ *     notice, this list of conditions and the following disclaimer.\n+ *\n+ *   - Redistributions in binary form must reproduce the above copyright\n+ *     notice, this list of conditions and the following disclaimer in the\n+ *     documentation and\/or other materials provided with the distribution.\n+ *\n+ *   - Neither the name of Oracle nor the names of its\n+ *     contributors may be used to endorse or promote products derived\n+ *     from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\n+ * IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+\n+import java.util.ResourceBundle;\n+import java.util.Vector;\n+import java.awt.Graphics;\n+import java.awt.Rectangle;\n+import javax.swing.JComponent;\n+import javax.swing.JPanel;\n+import javax.swing.JScrollPane;\n+import javax.swing.JTable;\n+import javax.swing.ListSelectionModel;\n+import javax.swing.table.DefaultTableModel;\n+import javax.swing.table.TableColumn;\n+import javax.swing.table.TableModel;\n+import javax.swing.SwingUtilities;\n+\n+\/**\n+  * This test is mean to isolate the speed of the JTable.\n+  * It creates a JTable and performs the following scenarios :\n+  * 1) Remove rows\n+  * 2) Add rows\n+  * 3) Select rows\n+  *    -Single Selection mode\n+  *    -Single Selection Interval\n+  *    -Multiple Selection Intervas\n+  *\/\n+\n+public class TableRowTest extends AbstractSwingTest {\n+\n+    JTable table;\n+    DefaultTableModel dataModel;\n+    static boolean backingStoreEnabled = true;\n+\n+    final String[] names = {\"First Name\", \"Last Name\", \"Favorite Color\",\n+        \"Favorite Number\", \"Vegetarian\"};\n+\n+    Object[][] data = {{}};\n+\n+    public JComponent getTestComponent() {\n+       loadBundle();\n+        JPanel panel = new JPanel();\n+        dataModel = new DefaultTableModel(data, names);\n+\n+        table = new CountTable(dataModel);\n+        JScrollPane scrollPane = new JScrollPane(table);\n+\n+        if (SwingMark.useBlitScrolling) {\n+           scrollPane.getViewport().putClientProperty(\"EnableWindowBlit\", Boolean.TRUE);\n+        }\n+\n+        panel.add(scrollPane);\n+        return panel;\n+    }\n+\n+    private void loadBundle() {\n+      ResourceBundle bundle = ResourceBundle.getBundle(\"resources.TableRowTest\");\n+      data = (Object[][])bundle.getObject(\"TableData\");\n+    }\n+\n+    public String getTestName() {\n+        return \"Table Rows\";\n+    }\n+\n+    public void runTest() {\n+        testTable(table, 1);\n+    }\n+\n+    public void testTable(JTable currentTable, int scrollBy) {\n+        \/\/ remove row\n+        TableRowAdder rowRemover = new TableRowAdder(currentTable, data, false);\n+        while (dataModel.getRowCount() > 0 ) {\n+            try {\n+                SwingUtilities.invokeLater(rowRemover);\n+                rest();\n+            }\n+            catch (Exception e) {e.printStackTrace();}\n+        }\n+\n+        \/\/ add row\n+        TableRowAdder rowAdder = new TableRowAdder(currentTable, data, true);\n+        while (dataModel.getRowCount() < data.length ) {\n+            try {\n+                SwingUtilities.invokeAndWait(rowAdder);\n+            }\n+            catch (Exception e) {e.printStackTrace();}\n+        }\n+\n+\n+\n+        \/\/ Selection Test\n+        for ( int m = 0 ; m < 3 ; m ++ ) { \/\/ m represents selection mode\n+            \/\/  System.out.println(\"  --------- Selection Mode :\" + m );\n+\n+            TableScroller scroll = new TableScroller(currentTable, scrollBy, m);\n+\n+            currentTable.clearSelection();\n+            for (int i = 0 ; i < currentTable.getRowCount()-1; i++ ) {\n+                try {\n+                    SwingUtilities.invokeAndWait(scroll);\n+                }\n+                catch (Exception e) {e.printStackTrace();}\n+            }\n+        }\n+\n+    }\n+\n+    public static void main(String[] args) {\n+       if (args.length > 0) {\n+          if (args[0].equals(\"-bs=off\")) {\n+             backingStoreEnabled = false;\n+             System.out.println(\"BackingStore is off\");\n+          }\n+       }\n+        runStandAloneTest(new TableRowTest());\n+    }\n+\n+    class CountTable extends JTable {\n+        public CountTable(TableModel tm) {\n+            super(tm);\n+        }\n+        public void paint(Graphics g) {\n+            super.paint(g);\n+            paintCount++;\n+        }\n+    }\n+\n+}\n+\n+\n+class TableScroller implements Runnable {\n+    JTable table;\n+    int scrollAmount = 1;\n+    int currentRowSelection = 0;\n+\n+\n+    public TableScroller(JTable tableToScroll, int scrollBy, int selectionMode) {\n+        table = tableToScroll;\n+        scrollAmount = scrollBy;\n+        table.setSelectionMode( selectionMode);\n+    }\n+\n+    public void run() {\n+        int ensureToSeeRow = 0;\n+\n+        switch ( table.getSelectionModel().getSelectionMode() ) {\n+            case ListSelectionModel.SINGLE_SELECTION:\n+                table.addRowSelectionInterval(currentRowSelection, currentRowSelection);\n+                currentRowSelection++;\n+                ensureToSeeRow = currentRowSelection;\n+                break;\n+            case ListSelectionModel.SINGLE_INTERVAL_SELECTION:\n+                currentRowSelection = Math.min(currentRowSelection, table.getRowCount()-1);\n+                int maxRow = table.getRowCount()-1;\n+                table.addRowSelectionInterval(currentRowSelection,\n+                           Math.min(currentRowSelection+5, maxRow));\n+                currentRowSelection++;\n+                ensureToSeeRow = table.getSelectionModel().getAnchorSelectionIndex() + 4;\n+                break;\n+            case ListSelectionModel.MULTIPLE_INTERVAL_SELECTION:\n+                table.addRowSelectionInterval(Math.min(currentRowSelection, table.getRowCount()-1),\n+                                              Math.min(currentRowSelection+3, table.getRowCount()-1));\n+                currentRowSelection = currentRowSelection + 5;\n+                ensureToSeeRow = table.getSelectionModel().getAnchorSelectionIndex() + 3;\n+                break;\n+            default:\n+                break;\n+        }\n+\n+        Rectangle cellBound = table.getCellRect(ensureToSeeRow, 0, true);\n+        table.scrollRectToVisible(cellBound);\n+    }\n+}\n+\n+class TableRowAdder implements Runnable {\n+    JTable table;\n+    int currentRowSelection = 0;\n+    Vector dataVector;\n+    int index = 0;\n+    Object [][] data;\n+    boolean add = true; \/\/ false for \"remove\"\n+\n+\n+    public TableRowAdder(JTable table, Object[][] data, boolean add) {\n+        this.table = table;\n+        this.data = data;\n+        this.add = add;\n+    }\n+\n+    public void run() {\n+        DefaultTableModel model = (DefaultTableModel)table.getModel();\n+        Rectangle cellBound;\n+\n+        if ( add ) {\n+            model.addRow(data[index]);\n+            index++;\n+            cellBound = table.getCellRect(table.getRowCount()-1, 0, true);\n+        }\n+        else {\n+            model.removeRow(0 );\n+            cellBound = table.getCellRect(0,0,true);\n+        }\n+\n+        table.scrollRectToVisible(cellBound);\n+    }\n+}\n","filename":"test\/jdk\/performance\/client\/SwingMark\/src\/TableRowTest.java","additions":234,"deletions":0,"binary":false,"changes":234,"status":"added"},{"patch":"@@ -0,0 +1,149 @@\n+\/*\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ *   - Redistributions of source code must retain the above copyright\n+ *     notice, this list of conditions and the following disclaimer.\n+ *\n+ *   - Redistributions in binary form must reproduce the above copyright\n+ *     notice, this list of conditions and the following disclaimer in the\n+ *     documentation and\/or other materials provided with the distribution.\n+ *\n+ *   - Neither the name of Oracle nor the names of its\n+ *     contributors may be used to endorse or promote products derived\n+ *     from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\n+ * IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+\n+import java.awt.Graphics;\n+import java.awt.Rectangle;\n+import javax.swing.JComponent;\n+import javax.swing.JScrollPane;\n+import javax.swing.JTable;\n+import javax.swing.JViewport;\n+import javax.swing.table.AbstractTableModel;\n+import javax.swing.table.DefaultTableCellRenderer;\n+import javax.swing.table.TableCellRenderer;\n+import javax.swing.table.TableModel;\n+import javax.swing.SwingUtilities;\n+\n+public class TableScrollTest extends AbstractSwingTest {\n+\n+   static JTable table;\n+   TableScroller tableScroller;\n+   JScrollPane scroller;\n+   static boolean backingStoreEnabled = true;\n+   static int rendererCount = 0;\n+\n+   public JComponent getTestComponent() {\n+\n+      TableModel model = new AbstractTableModel() {\n+         String[] data = { \"1\", \"2\", \"3\", \"4\", \"5\", \"6\",\n+            \"8\", \"9\", \"10\", \"11\" };\n+\n+         public int getColumnCount() { return 10;}\n+         public int getRowCount() { return 1000;}\n+         public Object getValueAt(int row, int col) {\n+            return data[(row*col)%data.length];\n+         }\n+      };\n+\n+      table = new CountTable(model);\n+      scroller = new JScrollPane(table);\n+      tableScroller = new TableScroller(table, 1);\n+\n+      return scroller;\n+   }\n+\n+   public String getTestName() {\n+      return \"Table Scroll\";\n+   }\n+\n+   public void runTest() {\n+      for (int i = 0; i < 200; i++) {\n+         try {\n+            SwingUtilities.invokeLater( tableScroller );\n+            rest();\n+         } catch (Exception e) {\n+            e.printStackTrace();\n+         }\n+      }\n+   }\n+\n+   @SuppressWarnings(\"deprecation\")\n+   public static void main(String[] args) {\n+       if (args.length > 0) {\n+          if (args[0].equals(\"-bs=off\")) {\n+              backingStoreEnabled = false;\n+              System.out.println(\"BackingStore is off\");\n+          }\n+       }\n+\n+       runStandAloneTest(new TableScrollTest());\n+       System.out.println(\"Renderer painted :\" + rendererCount);\n+       System.out.println( \"Backing store is:\" + ((JViewport)table.getParent()).isBackingStoreEnabled() );\n+   }\n+\n+   class TableScroller implements Runnable {\n+\n+      JTable table;\n+      int scrollAmount = 1;\n+      int currentVis = 10;\n+\n+      public TableScroller(JTable tableToScroll, int scrollBy) {\n+         table =  tableToScroll;\n+         scrollAmount = scrollBy;\n+      }\n+\n+      public void run() {\n+         int ensureToSeeRow = currentVis += scrollAmount;\n+         Rectangle cellBound = table.getCellRect(ensureToSeeRow, 0, true);\n+         table.scrollRectToVisible(cellBound);\n+      }\n+   }\n+\n+   static class CountRenderer extends DefaultTableCellRenderer {\n+\n+      public void paint(Graphics g) {\n+          super.paint(g);\n+          TableScrollTest.rendererCount++;\n+      }\n+   }\n+\n+   class CountTable extends JTable {\n+      TableCellRenderer rend = new CountRenderer();\n+\n+      public CountTable(TableModel tm) {\n+         super(tm);\n+      }\n+\n+      public void paint(Graphics g) {\n+         super.paint(g);\n+         paintCount++;\n+      }\n+\n+      public TableCellRenderer getCellRenderer(int row, int column) {\n+         return rend;\n+      }\n+\n+      @SuppressWarnings(\"deprecation\")\n+      public void addNotify() {\n+         super.addNotify();\n+         ((JViewport)getParent()).setBackingStoreEnabled(backingStoreEnabled);\n+      }\n+   }\n+}\n","filename":"test\/jdk\/performance\/client\/SwingMark\/src\/TableScrollTest.java","additions":149,"deletions":0,"binary":false,"changes":149,"status":"added"},{"patch":"@@ -0,0 +1,131 @@\n+\/*\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ *   - Redistributions of source code must retain the above copyright\n+ *     notice, this list of conditions and the following disclaimer.\n+ *\n+ *   - Redistributions in binary form must reproduce the above copyright\n+ *     notice, this list of conditions and the following disclaimer in the\n+ *     documentation and\/or other materials provided with the distribution.\n+ *\n+ *   - Neither the name of Oracle nor the names of its\n+ *     contributors may be used to endorse or promote products derived\n+ *     from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\n+ * IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+\n+import java.util.Date;\n+import java.util.ResourceBundle;\n+import java.awt.EventQueue;\n+import java.awt.Graphics;\n+import java.awt.event.KeyEvent;\n+import javax.swing.JComponent;\n+import javax.swing.JPanel;\n+import javax.swing.JScrollPane;\n+import javax.swing.JTextArea;\n+import javax.swing.SwingUtilities;\n+\n+\/**\n+  * This test is mean to isolate the speed of the JTextArea\n+  * It creates a JTextArea and then continuously appends text\n+  * to that string.\n+  *\/\n+\n+public class TextAreaTest extends AbstractSwingTest {\n+\n+   JTextArea textArea1;\n+   final int repeat = 300;\n+   final int breakIncrement = 12;\n+\n+   String DISPLAY_STRING = \"Swing is Fast!  \";\n+\n+   public JComponent getTestComponent() {\n+       loadBundle();\n+       JPanel panel = new JPanel();\n+       textArea1 = new CountTextArea(10, 30);\n+       textArea1.setLineWrap(true);\n+       JScrollPane scroller = new JScrollPane(textArea1);\n+\n+       if (SwingMark.useBlitScrolling) {\n+           scroller.getViewport().putClientProperty(\"EnableWindowBlit\", Boolean.TRUE);\n+       }\n+\n+       panel.add(scroller);\n+       return panel;\n+   }\n+\n+   public String getTestName() {\n+       return \"TextArea\";\n+   }\n+\n+   public void runTest() {\n+       testTextArea(textArea1, DISPLAY_STRING);\n+   }\n+\n+   private void loadBundle() {\n+       ResourceBundle bundle = ResourceBundle.getBundle(\"resources.TextAreaTest\");\n+       DISPLAY_STRING = bundle.getString(\"DisplayString\");\n+   }\n+\n+\n+   public void testTextArea(JTextArea currentTextArea, String appendThis) {\n+\n+       TextAppender appender = new TextAppender(currentTextArea, appendThis);\n+       for (int i = 0; i < repeat; i++) {\n+          appender.appendString = appendThis;\n+          if ( i % breakIncrement == breakIncrement -1) {\n+             appender.appendString = appendThis + \"\\n\";\n+          }\n+          try {\n+              SwingUtilities.invokeLater(appender);\n+              rest();\n+          } catch (Exception e) {System.out.println(e);}\n+       }\n+   }\n+\n+   public static void main(String[] args) {\n+       runStandAloneTest(new TextAreaTest());\n+   }\n+\n+   class CountTextArea extends JTextArea {\n+\n+       public CountTextArea(int h, int w) {\n+           super(h, w);\n+       }\n+\n+       public void paint(Graphics g) {\n+           super.paint(g);\n+           paintCount++;\n+       }\n+   }\n+}\n+\n+class TextAppender implements Runnable {\n+\n+    JTextArea area;\n+    String appendString;\n+\n+    public TextAppender(JTextArea textArea, String appendThis) {\n+        area = textArea;\n+        appendString = appendThis;\n+    }\n+\n+    public void run() {\n+        area.append(appendString);\n+    }\n+}\n","filename":"test\/jdk\/performance\/client\/SwingMark\/src\/TextAreaTest.java","additions":131,"deletions":0,"binary":false,"changes":131,"status":"added"},{"patch":"@@ -0,0 +1,114 @@\n+\/*\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ *   - Redistributions of source code must retain the above copyright\n+ *     notice, this list of conditions and the following disclaimer.\n+ *\n+ *   - Redistributions in binary form must reproduce the above copyright\n+ *     notice, this list of conditions and the following disclaimer in the\n+ *     documentation and\/or other materials provided with the distribution.\n+ *\n+ *   - Neither the name of Oracle nor the names of its\n+ *     contributors may be used to endorse or promote products derived\n+ *     from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\n+ * IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+\n+import java.awt.BorderLayout;\n+import java.awt.Dimension;\n+import java.awt.Graphics;\n+import javax.swing.JComponent;\n+import javax.swing.JPanel;\n+import javax.swing.JScrollPane;\n+import javax.swing.JTextPane;\n+import javax.swing.SwingUtilities;\n+import javax.swing.text.Document;\n+\n+\/**\n+  * This test is mean to isolate the speed of the JTextArea\n+  * It creates a JTextArea and then continuously appends text\n+  * to that string.\n+  *\n+  *\/\n+\n+public class TextPaneTest extends AbstractSwingTest {\n+\n+    JTextPane textArea1;\n+    final int repeat = 250;\n+\n+    public JComponent getTestComponent() {\n+        JPanel panel = new JPanel();\n+        panel.setPreferredSize(new Dimension(200,200));\n+        panel.setLayout(new BorderLayout());\n+        textArea1 = new CountTextArea(10, 30);\n+        JScrollPane scroller = new JScrollPane(textArea1);\n+        panel.add(scroller, BorderLayout.CENTER);\n+        return panel;\n+    }\n+\n+    public String getTestName() {\n+        return \"TextPane\";\n+    }\n+\n+    public void runTest() {\n+        testTextArea(textArea1, \"Swing is Fast!  \");\n+    }\n+\n+    public void testTextArea(JTextPane currentTextArea, String appendThis) {\n+        TextAppender appender = new TextAppender(currentTextArea, appendThis);\n+        for (int i = 0; i < repeat; i++) {\n+            try {\n+                SwingUtilities.invokeLater(appender);\n+                rest();\n+            } catch (Exception e) {System.out.println(e);}\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        runStandAloneTest(new TextPaneTest());\n+    }\n+\n+    class CountTextArea extends JTextPane {\n+        public CountTextArea(int h, int w) {\n+            super();\n+        }\n+\n+        public void paint(Graphics g) {\n+            super.paint(g);\n+            paintCount++;\n+        }\n+    }\n+\n+    static class TextAppender implements Runnable {\n+        JTextPane area;\n+        String appendString;\n+\n+        public TextAppender(JTextPane textArea, String appendThis) {\n+            area = textArea;\n+            appendString = appendThis;\n+        }\n+\n+        public void run() {\n+            try {\n+                Document doc = area.getDocument();\n+                doc.insertString(doc.getLength(), appendString, null);\n+            } catch (Exception e) {\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/performance\/client\/SwingMark\/src\/TextPaneTest.java","additions":114,"deletions":0,"binary":false,"changes":114,"status":"added"},{"patch":"@@ -0,0 +1,388 @@\n+\/*\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ *   - Redistributions of source code must retain the above copyright\n+ *     notice, this list of conditions and the following disclaimer.\n+ *\n+ *   - Redistributions in binary form must reproduce the above copyright\n+ *     notice, this list of conditions and the following disclaimer in the\n+ *     documentation and\/or other materials provided with the distribution.\n+ *\n+ *   - Neither the name of Oracle nor the names of its\n+ *     contributors may be used to endorse or promote products derived\n+ *     from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\n+ * IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+\n+import java.util.Enumeration;\n+import java.util.Vector;\n+import java.awt.BorderLayout;\n+import java.awt.Graphics;\n+import javax.swing.JComponent;\n+import javax.swing.JPanel;\n+import javax.swing.JScrollPane;\n+import javax.swing.JTree;\n+import javax.swing.tree.DefaultMutableTreeNode;\n+import javax.swing.tree.DefaultTreeModel;\n+import javax.swing.tree.DefaultTreeSelectionModel;\n+import javax.swing.tree.TreeSelectionModel;\n+import javax.swing.tree.TreeModel;\n+import javax.swing.tree.TreePath;\n+import javax.swing.SwingUtilities;\n+\n+\/**\n+  * This test is mean to isolate the speed of the JTree.\n+  * It creates a JTree and performs the following scenarios :\n+  * 1) Recursively adding node to the tree\n+  * 2) Recursively expand all nodes\n+  * 3) Selection Test\n+  *    -SINGLE_TREE_SELECTION mode\n+  *    -CONTIGUOUS_TREE_SELECTION mode\n+  *    -DISCONTIGUOUS_TREE_SELECTION mode\n+  * 4) Collapse all nodes\n+  * 5) Recursively Remove all the nodes\n+  *\/\n+\n+public class TreeTest extends AbstractSwingTest {\n+   JTree tree;\n+   int totalChildCount = 0;\n+   int targetChildCount = 200;\n+   int interval = 5;\n+   boolean useLargeModel = false;\n+   boolean debug = false;\n+\n+   public JComponent getTestComponent() {\n+      JPanel panel = new JPanel();\n+      panel.setLayout(new BorderLayout());\n+\n+      DefaultMutableTreeNode top =\n+      new DefaultMutableTreeNode(Integer.valueOf(0));\n+      totalChildCount ++;\n+\n+      DefaultTreeModel model = new DefaultTreeModel(top);\n+\n+      tree = new CountTree(model);\n+      tree.setLargeModel(useLargeModel);\n+      if (useLargeModel) {\n+         tree.setRowHeight(18);\n+      }\n+      JScrollPane scroller = new JScrollPane(tree);\n+\n+      if (SwingMark.useBlitScrolling) {\n+         scroller.getViewport().putClientProperty(\"EnableWindowBlit\", Boolean.TRUE);\n+      }\n+\n+      panel.add(scroller, BorderLayout.CENTER);\n+\n+      return panel;\n+   }\n+\n+   public String getTestName() {\n+      return \"Tree\";\n+   }\n+\n+   public void runTest() {\n+      testTree();\n+   }\n+\n+   public void testTree() {\n+      \/\/ Recursively add Nodes to the tree\n+      if (debug) {\n+         System.out.println(\"(1)Adding nodes...\");\n+      }\n+\n+      TreeNodeAdder adder =\n+      new TreeNodeAdder( (DefaultTreeModel)tree.getModel(), true );\n+      Vector nodeList = new Vector();\n+      nodeList.addElement(tree.getModel().getRoot());\n+\n+      addChild(nodeList, adder);\n+\n+      \/\/ Recursively Expend all nodes\n+      if (debug) {\n+         System.out.println(\"(2)Recursively Expending all nodes...\");\n+      }\n+\n+      TreeExpender expender = new TreeExpender(tree, true);\n+      TreePath path = tree.getPathForRow(0);\n+      DefaultMutableTreeNode root =\n+      (DefaultMutableTreeNode)path.getLastPathComponent();\n+      expandNodes(root, expender);\n+\n+      \/\/ Selection Test\n+\n+      \/\/ 1) SINGLE_TREE_SELECTION\n+      if (debug) {\n+         System.out.println(\"(3)Selection Test .....\");\n+         System.out.println(\"   -SINGLE_TREE_SELECTION .....\");\n+\n+      }\n+      TreeSelector selector =\n+      new TreeSelector(tree,TreeSelectionModel.SINGLE_TREE_SELECTION);\n+      int [] rows = new int[1];\n+\n+      for (int i=0; i < tree.getRowCount() ; i ++ ) {\n+         rows[0] = i;\n+         selector.addSelectionRows(rows);\n+         try {\n+            SwingUtilities.invokeLater(selector);\n+            rest();\n+         } catch (Exception e) {System.out.println(e);}\n+      }\n+\n+\n+      \/\/ 2) CONTIGUOUS_TREE_SELECTION\n+      if (debug) {\n+         System.out.println(\"   -CONTIGUOUS_TREE_SELECTION .....\");\n+      }\n+\n+      selector =\n+      new TreeSelector(tree,TreeSelectionModel.CONTIGUOUS_TREE_SELECTION);\n+      rows = new int[3];\n+      int count = tree.getRowCount()\/4 ;\n+\n+      for (int i=0; i < count ;i ++) {\n+         rows[0]=i*4; rows[1] = rows[0]+1; rows[2] = rows[0]+2;\n+         selector.addSelectionRows(rows);\n+         try {\n+            SwingUtilities.invokeAndWait(selector);\n+         } catch (Exception e) {System.out.println(e);}\n+      }\n+\n+      \/\/ 3) CONTIGUOUS_TREE_SELECTION\n+      if (debug) {\n+         System.out.println(\"   -DISCONTIGUOUS_TREE_SELECTION .....\");\n+      }\n+      new TreeSelector(tree,TreeSelectionModel.DISCONTIGUOUS_TREE_SELECTION);\n+      count = tree.getRowCount()\/5 ;\n+\n+      for (int i=0; i < count ; i ++) {\n+         rows[0]=i*5; rows[1] = rows[0]+1; rows[2] = rows[0]+2;\n+         selector.addSelectionRows(rows);\n+         try {\n+            SwingUtilities.invokeAndWait(selector);\n+         } catch (Exception e) {System.out.println(e);}\n+      }\n+\n+      \/\/\n+      \/\/ Collapse all the nodes\n+      \/\/\n+      if (debug) {\n+         System.out.println(\"(4)Collapsing all nodes .....\");\n+\n+      }\n+      TreeExpender collapser = new TreeExpender(tree, false);\n+      TreePath[] paths = new TreePath[ tree.getRowCount()];\n+\n+      for ( int rowcount = 0 ; rowcount < tree.getRowCount() ; rowcount ++ ) {\n+         paths[rowcount] = tree.getPathForRow(rowcount );\n+      }\n+\n+      for ( int i = paths.length - 1 ; i >=0 ; i-- ) {\n+         try {\n+            collapser.setPath(paths[i]);\n+            SwingUtilities.invokeAndWait(collapser);\n+         } catch (Exception e) {System.out.println(e);}\n+      }\n+\n+      \/\/ Recursively remove Nodes from the tree\n+      \/\/\n+      if (debug) {\n+         System.out.println(\"(5)Removing nodes...\");\n+      }\n+\n+      TreeNodeAdder remover =\n+      new TreeNodeAdder( (DefaultTreeModel)tree.getModel(), false);\n+\n+      removeNodes((DefaultMutableTreeNode)tree.getModel().getRoot(),remover);\n+      tree.repaint();\n+   }\n+\n+\n+   public void addChild(Vector nodeList, TreeNodeAdder adder){\n+      DefaultMutableTreeNode node;\n+      Vector newVec = new Vector();\n+\n+      for ( int i=0; i < nodeList.size() ; i++ ) {\n+\n+         node = (DefaultMutableTreeNode)nodeList.elementAt(i);\n+\n+         while ( node.getChildCount() < interval ) {\n+            if ( totalChildCount >= targetChildCount ) return;\n+\n+            adder.setNode(node, totalChildCount);\n+            try {\n+               SwingUtilities.invokeAndWait(adder);\n+               totalChildCount ++;\n+            } catch (Exception e) {System.out.println(e);}\n+\n+            newVec.addElement(node.getChildAt(node.getChildCount()-1));\n+         }\n+      }\n+      addChild(newVec, adder);\n+   }\n+\n+   public void expandNodes(DefaultMutableTreeNode node, TreeExpender expender){\n+      try {\n+         expender.setPath(new TreePath ( node.getPath()));\n+         SwingUtilities.invokeAndWait(expender);\n+      } catch (Exception e) {System.out.println(e);}\n+\n+      for (Enumeration e = node.children() ; e.hasMoreElements() ;) {\n+         DefaultMutableTreeNode childNode =\n+         (DefaultMutableTreeNode)e.nextElement();\n+         expandNodes(childNode, expender);\n+      }\n+   }\n+\n+   public void removeNodes(DefaultMutableTreeNode node, TreeNodeAdder remover){\n+      Vector nodeList = new Vector();\n+      for (Enumeration e = node.depthFirstEnumeration() ; e.hasMoreElements() ;) {\n+         nodeList.addElement(e.nextElement());\n+      }\n+\n+      for ( int i=0; i < nodeList.size(); i ++ ) {\n+         DefaultMutableTreeNode nodeToRemove =\n+         (DefaultMutableTreeNode)nodeList.elementAt(i);\n+\n+         try {\n+            remover.setNode(nodeToRemove, -1);\n+            SwingUtilities.invokeAndWait(remover);\n+         } catch (Exception exp) {System.out.println(exp);\n+         }\n+      }\n+   }\n+\n+   public static void main(String[] args) {\n+      TreeTest test = new TreeTest();\n+      test.debug = true;\n+      if (args.length > 0) {\n+         test.targetChildCount = Integer.parseInt(args[0]);\n+         System.out.println(\"Setting nodes to: \" + test.targetChildCount);\n+      }\n+      if (args.length > 1) {\n+         if (args[1].equals(\"-l\")) {\n+            System.out.println(\"Large Model On\");\n+            test.useLargeModel = true;\n+         }\n+      }\n+      runStandAloneTest(test);\n+   }\n+\n+   class CountTree extends JTree {\n+      public CountTree(TreeModel tm) {\n+         super(tm);\n+      }\n+      public void paint(Graphics g) {\n+         super.paint(g);\n+         paintCount++;\n+      }\n+   }\n+}\n+\n+class TreeNodeAdder implements Runnable {\n+   DefaultTreeModel treeModel;\n+   DefaultMutableTreeNode currentNode;\n+   int totalChildCount = 0;\n+   boolean add = true;\n+\n+   public TreeNodeAdder(DefaultTreeModel treeModel, boolean add ) {\n+      this.treeModel = treeModel;\n+      this.add = add;\n+   }\n+\n+   public void setNode(DefaultMutableTreeNode node, int totalCount){\n+      currentNode = node;\n+      totalChildCount = totalCount;\n+   }\n+\n+   public void run() {\n+      if ( add ) {\n+         \/\/ add a new node to the currentNode's child list\n+         DefaultMutableTreeNode newNode =\n+         new DefaultMutableTreeNode(Integer.valueOf(totalChildCount));\n+         treeModel.insertNodeInto(newNode, currentNode, currentNode.getChildCount());\n+      } else {\n+         \/\/ remove the current Node from its parent\n+         if ( currentNode.getParent() != null ) {\n+            treeModel.removeNodeFromParent(currentNode);\n+         }\n+      }\n+   }\n+}\n+\n+class TreeExpender implements Runnable {\n+   JTree tree;\n+   boolean expand = true;\n+   TreePath currentPath;\n+\n+   public TreeExpender(JTree tree, boolean expand ) {\n+      this.tree = tree;\n+      this.expand = expand;\n+   }\n+\n+   public void setPath(TreePath path){\n+      currentPath = path;\n+   }\n+\n+   public void run() {\n+      if ( expand ) {\n+         \/\/ Expand the current Path\n+         if ( tree.isExpanded(currentPath)) tree.expandPath(currentPath);\n+         tree.scrollPathToVisible(currentPath);\n+      } else {\n+         \/\/ Collapse the node\n+         if ( !tree.isCollapsed(currentPath) ) {\n+            tree.scrollPathToVisible(currentPath);\n+            tree.collapsePath(currentPath);\n+         }\n+      }\n+   }\n+}\n+\n+class TreeSelector implements Runnable {\n+   JTree tree;\n+   DefaultMutableTreeNode currentNode ;\n+   TreePath currentPath;\n+   int selectionMode = 0;\n+   int [] rows;\n+\n+   public TreeSelector(JTree tree, int mode ) {\n+      this.tree = tree;\n+\n+      selectionMode = mode;\n+      DefaultTreeSelectionModel selectionModel = new DefaultTreeSelectionModel();\n+      selectionModel.setSelectionMode(mode);\n+      tree.setSelectionModel( selectionModel );\n+      int [] rows;\n+   }\n+\n+   public void addSelectionRows( int[] rows ){\n+      this.rows = rows;\n+   }\n+\n+   public void setNode(TreePath path ) {\n+      currentPath = path;\n+      currentNode = (DefaultMutableTreeNode)path.getLastPathComponent();\n+   }\n+\n+   public void run() {\n+      tree.addSelectionRows(rows);\n+      tree.scrollRowToVisible( rows[ rows.length -1 ]);\n+   }\n+}\n","filename":"test\/jdk\/performance\/client\/SwingMark\/src\/TreeTest.java","additions":388,"deletions":0,"binary":false,"changes":388,"status":"added"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ *   - Redistributions of source code must retain the above copyright\n+ *     notice, this list of conditions and the following disclaimer.\n+ *\n+ *   - Redistributions in binary form must reproduce the above copyright\n+ *     notice, this list of conditions and the following disclaimer in the\n+ *     documentation and\/or other materials provided with the distribution.\n+ *\n+ *   - Neither the name of Oracle nor the names of its\n+ *     contributors may be used to endorse or promote products derived\n+ *     from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\n+ * IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+\n+import java.util.Date;\n+import java.awt.EventQueue;\n+import java.awt.Toolkit;\n+import java.awt.event.KeyEvent;\n+import javax.swing.JComponent;\n+import javax.swing.JPanel;\n+import javax.swing.JScrollPane;\n+import javax.swing.JTextArea;\n+\n+public class TypingTest extends AbstractSwingTest {\n+\n+    JTextArea textArea1;\n+    final int repeat = 100;\n+\n+    public JComponent getTestComponent() {\n+        JPanel panel = new JPanel();\n+        textArea1 = new JTextArea(10, 30);\n+        textArea1.setLineWrap(true);\n+        JScrollPane scroller = new JScrollPane(textArea1);\n+        panel.add(scroller);\n+        return panel;\n+    }\n+\n+    public boolean canRunInApplet() {\n+        return false;\n+    }\n+\n+    public String getTestName() {\n+        return \"Typing\";\n+    }\n+\n+    public void runTest() {\n+        testTyping(textArea1, \"Write once, run anywhere!  \");\n+    }\n+\n+    public void testTyping(JTextArea currentTextArea, String stuff) {\n+        EventQueue queue = Toolkit.getDefaultToolkit().getSystemEventQueue();\n+\n+        int n = stuff.length();\n+        for (int i = 0; i < repeat; i++)\n+            for (int j = 0; j < n; j++) {\n+                char c = stuff.charAt(j);\n+                KeyEvent key = new KeyEvent(currentTextArea,\n+                                    KeyEvent.KEY_TYPED, new Date().getTime(),\n+                                    0, KeyEvent.VK_UNDEFINED, c);\n+                queue.postEvent(key);\n+                rest();\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        runStandAloneTest(new TypingTest());\n+    }\n+}\n","filename":"test\/jdk\/performance\/client\/SwingMark\/src\/TypingTest.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"@@ -0,0 +1,34 @@\n+#\n+# Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+#\n+# Redistribution and use in source and binary forms, with or without\n+# modification, are permitted provided that the following conditions\n+# are met:\n+#\n+#   - Redistributions of source code must retain the above copyright\n+#     notice, this list of conditions and the following disclaimer.\n+#\n+#   - Redistributions in binary form must reproduce the above copyright\n+#     notice, this list of conditions and the following disclaimer in the\n+#     documentation and\/or other materials provided with the distribution.\n+#\n+#   - Neither the name of Oracle nor the names of its\n+#     contributors may be used to endorse or promote products derived\n+#     from this software without specific prior written permission.\n+#\n+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\n+# IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n+# THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n+# PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n+# CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n+# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n+# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n+# PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n+# LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n+# NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n+# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+#\n+# Resource bundle for Menu Test\n+MenuString=JMenu\n+SubMenuString=SubMenu\n+MenuItemString=JMenuItem\n","filename":"test\/jdk\/performance\/client\/SwingMark\/src\/resources\/JMTest_04.properties","additions":34,"deletions":0,"binary":false,"changes":34,"status":"added"},{"patch":"@@ -0,0 +1,34 @@\n+#\n+# Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+#\n+# Redistribution and use in source and binary forms, with or without\n+# modification, are permitted provided that the following conditions\n+# are met:\n+#\n+#   - Redistributions of source code must retain the above copyright\n+#     notice, this list of conditions and the following disclaimer.\n+#\n+#   - Redistributions in binary form must reproduce the above copyright\n+#     notice, this list of conditions and the following disclaimer in the\n+#     documentation and\/or other materials provided with the distribution.\n+#\n+#   - Neither the name of Oracle nor the names of its\n+#     contributors may be used to endorse or promote products derived\n+#     from this software without specific prior written permission.\n+#\n+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\n+# IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n+# THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n+# PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n+# CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n+# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n+# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n+# PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n+# LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n+# NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n+# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+#\n+# Resource bundle for Menu Test\n+MenuString=\\uff2a\\uff2d\\uff45\\uff4e\\uff55\n+SubMenuString=\\uff33\\uff55\\uff42\\uff2d\\uff45\\uff4e\\uff55\n+MenuItemString=\\uff2a\\uff2d\\uff45\\uff4e\\uff55\\uff29\\uff54\\uff45\\uff4d\n","filename":"test\/jdk\/performance\/client\/SwingMark\/src\/resources\/JMTest_04_ja.properties","additions":34,"deletions":0,"binary":false,"changes":34,"status":"added"},{"patch":"@@ -0,0 +1,32 @@\n+#\n+# Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+#\n+# Redistribution and use in source and binary forms, with or without\n+# modification, are permitted provided that the following conditions\n+# are met:\n+#\n+#   - Redistributions of source code must retain the above copyright\n+#     notice, this list of conditions and the following disclaimer.\n+#\n+#   - Redistributions in binary form must reproduce the above copyright\n+#     notice, this list of conditions and the following disclaimer in the\n+#     documentation and\/or other materials provided with the distribution.\n+#\n+#   - Neither the name of Oracle nor the names of its\n+#     contributors may be used to endorse or promote products derived\n+#     from this software without specific prior written permission.\n+#\n+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\n+# IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n+# THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n+# PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n+# CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n+# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n+# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n+# PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n+# LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n+# NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n+# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+#\n+# Resource bundle for List Test\n+DisplayString=ListItem\n","filename":"test\/jdk\/performance\/client\/SwingMark\/src\/resources\/ListTest.properties","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -0,0 +1,32 @@\n+#\n+# Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+#\n+# Redistribution and use in source and binary forms, with or without\n+# modification, are permitted provided that the following conditions\n+# are met:\n+#\n+#   - Redistributions of source code must retain the above copyright\n+#     notice, this list of conditions and the following disclaimer.\n+#\n+#   - Redistributions in binary form must reproduce the above copyright\n+#     notice, this list of conditions and the following disclaimer in the\n+#     documentation and\/or other materials provided with the distribution.\n+#\n+#   - Neither the name of Oracle nor the names of its\n+#     contributors may be used to endorse or promote products derived\n+#     from this software without specific prior written permission.\n+#\n+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\n+# IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n+# THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n+# PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n+# CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n+# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n+# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n+# PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n+# LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n+# NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n+# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+#\n+# Resource bundle for List Test\n+DisplayString=\\uff2c\\uff49\\uff53\\uff54\\uff29\\uff54\\uff45\\uff4d\n","filename":"test\/jdk\/performance\/client\/SwingMark\/src\/resources\/ListTest_ja.properties","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -0,0 +1,94 @@\n+\/*\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ *   - Redistributions of source code must retain the above copyright\n+ *     notice, this list of conditions and the following disclaimer.\n+ *\n+ *   - Redistributions in binary form must reproduce the above copyright\n+ *     notice, this list of conditions and the following disclaimer in the\n+ *     documentation and\/or other materials provided with the distribution.\n+ *\n+ *   - Neither the name of Oracle nor the names of its\n+ *     contributors may be used to endorse or promote products derived\n+ *     from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\n+ * IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+\n+package resources;\n+\n+import java.util.ListResourceBundle;\n+\n+\n+ public class TableRowTest extends ListResourceBundle {\n+  public Object[][] getContents() {\n+      return contents;\n+  }\n+\n+  \/\/ LOCALIZE THIS\n+  \/\/ note: probably don't need to localize integers and booleans\n+  static Object[][] data = {\n+      {\"Mark\", \"Andrews\", \"Red\", Integer.valueOf(2), Boolean.valueOf(true)},\n+      {\"Tom\", \"Ball\", \"Blue\", Integer.valueOf(99), Boolean.valueOf(false)},\n+      {\"Alan\", \"Chung\", \"Green\", Integer.valueOf(838), Boolean.valueOf(false)},\n+      {\"Jeff\", \"Dinkins\", \"Turquois\", Integer.valueOf(8), Boolean.valueOf(true)},\n+      {\"Amy\", \"Fowler\", \"Yellow\", Integer.valueOf(3), Boolean.valueOf(false)},\n+      {\"Brian\", \"Gerhold\", \"Green\", Integer.valueOf(0), Boolean.valueOf(false)},\n+      {\"James\", \"Gosling\", \"Pink\", Integer.valueOf(21), Boolean.valueOf(false)},\n+      {\"David\", \"Karlton\", \"Red\", Integer.valueOf(1), Boolean.valueOf(false)},\n+      {\"Dave\", \"Kloba\", \"Yellow\", Integer.valueOf(14), Boolean.valueOf(false)},\n+      {\"Peter\", \"Korn\", \"Purple\", Integer.valueOf(12), Boolean.valueOf(false)},\n+      {\"Phil\", \"Milne\", \"Purple\", Integer.valueOf(3), Boolean.valueOf(false)},\n+      {\"Dave\", \"Moore\", \"Green\", Integer.valueOf(88), Boolean.valueOf(false)},\n+      {\"Hans\", \"Muller\", \"Maroon\", Integer.valueOf(5), Boolean.valueOf(false)},\n+      {\"Rick\", \"Levenson\", \"Blue\", Integer.valueOf(2), Boolean.valueOf(false)},\n+      {\"Tim\", \"Prinzing\", \"Blue\", Integer.valueOf(22), Boolean.valueOf(false)},\n+      {\"Chester\", \"Rose\", \"Black\", Integer.valueOf(0), Boolean.valueOf(false)},\n+      {\"Ray\", \"Ryan\", \"Gray\", Integer.valueOf(77), Boolean.valueOf(false)},\n+      {\"Georges\", \"Saab\", \"Red\", Integer.valueOf(4), Boolean.valueOf(false)},\n+      {\"Willie\", \"Walker\", \"Phthalo Blue\", Integer.valueOf(4), Boolean.valueOf(false)},\n+      {\"Kathy\", \"Walrath\", \"Blue\", Integer.valueOf(8), Boolean.valueOf(false)},\n+      {\"Arnaud\", \"Weber\", \"Green\", Integer.valueOf(44), Boolean.valueOf(false)},\n+      {\"Mark\", \"Andrews\", \"Red\", Integer.valueOf(2), Boolean.valueOf(true)},\n+      {\"Tom\", \"Ball\", \"Blue\", Integer.valueOf(99), Boolean.valueOf(false)},\n+      {\"Alan\", \"Chung\", \"Green\", Integer.valueOf(838), Boolean.valueOf(false)},\n+      {\"Jeff\", \"Dinkins\", \"Turquois\", Integer.valueOf(8), Boolean.valueOf(true)},\n+      {\"Amy\", \"Fowler\", \"Yellow\", Integer.valueOf(3), Boolean.valueOf(false)},\n+      {\"Brian\", \"Gerhold\", \"Green\", Integer.valueOf(0), Boolean.valueOf(false)},\n+      {\"James\", \"Gosling\", \"Pink\", Integer.valueOf(21), Boolean.valueOf(false)},\n+      {\"David\", \"Karlton\", \"Red\", Integer.valueOf(1), Boolean.valueOf(false)},\n+      {\"Dave\", \"Kloba\", \"Yellow\", Integer.valueOf(14), Boolean.valueOf(false)},\n+      {\"Peter\", \"Korn\", \"Purple\", Integer.valueOf(12), Boolean.valueOf(false)},\n+      {\"Phil\", \"Milne\", \"Purple\", Integer.valueOf(3), Boolean.valueOf(false)},\n+      {\"Dave\", \"Moore\", \"Green\", Integer.valueOf(88), Boolean.valueOf(false)},\n+      {\"Hans\", \"Muller\", \"Maroon\", Integer.valueOf(5), Boolean.valueOf(false)},\n+      {\"Rick\", \"Levenson\", \"Blue\", Integer.valueOf(2), Boolean.valueOf(false)},\n+      {\"Tim\", \"Prinzing\", \"Blue\", Integer.valueOf(22), Boolean.valueOf(false)},\n+      {\"Chester\", \"Rose\", \"Black\", Integer.valueOf(0), Boolean.valueOf(false)},\n+      {\"Ray\", \"Ryan\", \"Gray\", Integer.valueOf(77), Boolean.valueOf(false)},\n+      {\"Georges\", \"Saab\", \"Red\", Integer.valueOf(4), Boolean.valueOf(false)},\n+      {\"Willie\", \"Walker\", \"Phthalo Blue\", Integer.valueOf(4), Boolean.valueOf(false)},\n+      {\"Kathy\", \"Walrath\", \"Blue\", Integer.valueOf(8), Boolean.valueOf(false)},\n+      {\"Arnaud\", \"Weber\", \"Green\", Integer.valueOf(44), Boolean.valueOf(false)}\n+  };\n+  \/\/ END OF MATERIAL TO LOCALIZE\n+\n+  static final Object[][] contents = {\n+      {\"TableData\", data }        \/\/ array for table data\n+  };\n+ }\n+\n","filename":"test\/jdk\/performance\/client\/SwingMark\/src\/resources\/TableRowTest.java","additions":94,"deletions":0,"binary":false,"changes":94,"status":"added"},{"patch":"@@ -0,0 +1,90 @@\n+\/*\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ *   - Redistributions of source code must retain the above copyright\n+ *     notice, this list of conditions and the following disclaimer.\n+ *\n+ *   - Redistributions in binary form must reproduce the above copyright\n+ *     notice, this list of conditions and the following disclaimer in the\n+ *     documentation and\/or other materials provided with the distribution.\n+ *\n+ *   - Neither the name of Oracle nor the names of its\n+ *     contributors may be used to endorse or promote products derived\n+ *     from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\n+ * IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+\n+package resources;\n+\n+import java.util.ListResourceBundle;\n+\n+public class TableRowTest_ja extends ListResourceBundle {\n+\n+  public Object[][] getContents() {\n+      return contents;\n+  }\n+\n+  static Object[][] data = {\n+      {\"\\uff2d\\uff41\\uff52\\uff4b\", \"\\uff21\\uff4e\\uff44\\uff52\\uff45\\uff57\\uff53\", \"\\uff32\\uff45\\uff44\", Integer.valueOf(2), Boolean.valueOf(true)},\n+      {\"\\uff34\\uff4f\\uff4d\", \"\\uff22\\uff41\\uff4c\\uff4c\", \"\\uff22\\uff4c\\uff55\\uff45\", Integer.valueOf(99), Boolean.valueOf(false)},\n+      {\"\\uff21\\uff4c\\uff41\\uff4e\", \"\\uff23\\uff48\\uff55\\uff4e\\uff47\", \"\\uff27\\uff52\\uff45\\uff45\\uff4e\", Integer.valueOf(838), Boolean.valueOf(false)},\n+      {\"\\uff2a\\uff45\\uff46\\uff46\", \"\\uff24\\uff49\\uff4e\\uff4b\\uff49\\uff4e\\uff53\", \"\\uff34\\uff55\\uff52\\uff51\\uff55\\uff4f\\uff49\\uff53\", Integer.valueOf(8), Boolean.valueOf(true)},\n+      {\"\\uff21\\uff4d\\uff59\", \"\\uff26\\uff4f\\uff57\\uff4c\\uff45\\uff52\", \"\\uff39\\uff45\\uff4c\\uff4c\\uff4f\\uff57\", Integer.valueOf(3), Boolean.valueOf(false)},\n+      {\"\\uff22\\uff52\\uff49\\uff41\\uff4e\", \"\\uff27\\uff45\\uff52\\uff48\\uff4f\\uff4c\\uff44\", \"\\uff27\\uff52\\uff45\\uff45\\uff4e\", Integer.valueOf(0), Boolean.valueOf(false)},\n+      {\"\\uff2a\\uff41\\uff4d\\uff45\\uff53\", \"\\uff27\\uff4f\\uff53\\uff4c\\uff49\\uff4e\\uff47\", \"\\uff30\\uff49\\uff4e\\uff4b\", Integer.valueOf(21), Boolean.valueOf(false)},\n+      {\"\\uff24\\uff41\\uff56\\uff49\\uff44\", \"\\uff2b\\uff41\\uff52\\uff4c\\uff54\\uff4f\\uff4e\", \"\\uff32\\uff45\\uff44\", Integer.valueOf(1), Boolean.valueOf(false)},\n+      {\"\\uff24\\uff41\\uff56\\uff45\", \"\\uff2b\\uff4c\\uff4f\\uff42\\uff41\", \"\\uff39\\uff45\\uff4c\\uff4c\\uff4f\\uff57\", Integer.valueOf(14), Boolean.valueOf(false)},\n+      {\"\\uff30\\uff45\\uff54\\uff45\\uff52\", \"\\uff2b\\uff4f\\uff52\\uff4e\", \"\\uff30\\uff55\\uff52\\uff50\\uff4c\\uff45\", Integer.valueOf(12), Boolean.valueOf(false)},\n+      {\"\\uff30\\uff48\\uff49\\uff4c\", \"\\uff2d\\uff49\\uff4c\\uff4e\\uff45\", \"\\uff30\\uff55\\uff52\\uff50\\uff4c\\uff45\", Integer.valueOf(3), Boolean.valueOf(false)},\n+      {\"\\uff24\\uff41\\uff56\\uff45\", \"\\uff2d\\uff4f\\uff4f\\uff52\\uff45\", \"\\uff27\\uff52\\uff45\\uff45\\uff4e\", Integer.valueOf(88), Boolean.valueOf(false)},\n+      {\"\\uff28\\uff41\\uff4e\\uff53\", \"\\uff2d\\uff55\\uff4c\\uff4c\\uff45\\uff52\", \"\\uff2d\\uff41\\uff52\\uff4f\\uff4f\\uff4e\", Integer.valueOf(5), Boolean.valueOf(false)},\n+      {\"\\uff32\\uff49\\uff43\\uff4b\", \"\\uff2c\\uff45\\uff56\\uff45\\uff4e\\uff53\\uff4f\\uff4e\", \"\\uff22\\uff4c\\uff55\\uff45\", Integer.valueOf(2), Boolean.valueOf(false)},\n+      {\"\\uff34\\uff49\\uff4d\", \"\\uff30\\uff52\\uff49\\uff4e\\uff5a\\uff49\\uff4e\\uff47\", \"\\uff22\\uff4c\\uff55\\uff45\", Integer.valueOf(22), Boolean.valueOf(false)},\n+      {\"\\uff23\\uff48\\uff45\\uff53\\uff54\\uff45\\uff52\", \"\\uff32\\uff4f\\uff53\\uff45\", \"\\uff22\\uff4c\\uff41\\uff43\\uff4b\", Integer.valueOf(0), Boolean.valueOf(false)},\n+      {\"\\uff32\\uff41\\uff59\", \"\\uff32\\uff59\\uff41\\uff4e\", \"\\uff27\\uff52\\uff41\\uff59\", Integer.valueOf(77), Boolean.valueOf(false)},\n+      {\"\\uff27\\uff45\\uff4f\\uff52\\uff47\\uff45\\uff53\", \"\\uff33\\uff41\\uff41\\uff42\", \"\\uff32\\uff45\\uff44\", Integer.valueOf(4), Boolean.valueOf(false)},\n+      {\"\\uff37\\uff49\\uff4c\\uff4c\\uff49\\uff45\", \"\\uff37\\uff41\\uff4c\\uff4b\\uff45\\uff52\", \"\\uff30\\uff48\\uff54\\uff48\\uff41\\uff4c\\uff4f\\u3000\\uff42\\uff4c\\uff55\\uff45\", Integer.valueOf(4), Boolean.valueOf(false)},\n+      {\"\\uff2b\\uff41\\uff54\\uff48\\uff59\", \"\\uff37\\uff41\\uff4c\\uff52\\uff41\\uff54\\uff48\", \"\\uff22\\uff4c\\uff55\\uff45\", Integer.valueOf(8), Boolean.valueOf(false)},\n+      {\"\\uff21\\uff52\\uff4e\\uff41\\uff55\\uff44\", \"\\uff37\\uff45\\uff42\\uff45\\uff52\", \"\\uff27\\uff52\\uff45\\uff45\\uff4e\", Integer.valueOf(44), Boolean.valueOf(false)},\n+      {\"\\uff2d\\uff41\\uff52\\uff4b\", \"\\uff21\\uff4e\\uff44\\uff52\\uff45\\uff57\\uff53\", \"\\uff32\\uff45\\uff44\", Integer.valueOf(2), Boolean.valueOf(true)},\n+      {\"\\uff34\\uff4f\\uff4d\", \"\\uff22\\uff41\\uff4c\\uff4c\", \"\\uff22\\uff4c\\uff55\\uff45\", Integer.valueOf(99), Boolean.valueOf(false)},\n+      {\"\\uff21\\uff4c\\uff41\\uff4e\", \"\\uff23\\uff48\\uff55\\uff4e\\uff47\", \"\\uff27\\uff52\\uff45\\uff45\\uff4e\", Integer.valueOf(838), Boolean.valueOf(false)},\n+      {\"\\uff2a\\uff45\\uff46\\uff46\", \"\\uff24\\uff49\\uff4e\\uff4b\\uff49\\uff4e\\uff53\", \"\\uff34\\uff55\\uff52\\uff51\\uff55\\uff4f\\uff49\\uff53\", Integer.valueOf(8), Boolean.valueOf(true)},\n+      {\"\\uff21\\uff4d\\uff59\", \"\\uff26\\uff4f\\uff57\\uff4c\\uff45\\uff52\", \"\\uff39\\uff45\\uff4c\\uff4c\\uff4f\\uff57\", Integer.valueOf(3), Boolean.valueOf(false)},\n+      {\"\\uff22\\uff52\\uff49\\uff41\\uff4e\", \"\\uff27\\uff45\\uff52\\uff48\\uff4f\\uff4c\\uff44\", \"\\uff27\\uff52\\uff45\\uff45\\uff4e\", Integer.valueOf(0), Boolean.valueOf(false)},\n+      {\"\\uff2a\\uff41\\uff4d\\uff45\\uff53\", \"\\uff27\\uff4f\\uff53\\uff4c\\uff49\\uff4e\\uff47\", \"\\uff30\\uff49\\uff4e\\uff4b\", Integer.valueOf(21), Boolean.valueOf(false)},\n+      {\"\\uff24\\uff41\\uff56\\uff49\\uff44\", \"\\uff2b\\uff41\\uff52\\uff4c\\uff54\\uff4f\\uff4e\", \"\\uff32\\uff45\\uff44\", Integer.valueOf(1), Boolean.valueOf(false)},\n+      {\"\\uff24\\uff41\\uff56\\uff45\", \"\\uff2b\\uff4c\\uff4f\\uff42\\uff41\", \"\\uff39\\uff45\\uff4c\\uff4c\\uff4f\\uff57\", Integer.valueOf(14), Boolean.valueOf(false)},\n+      {\"\\uff30\\uff45\\uff54\\uff45\\uff52\", \"\\uff2b\\uff4f\\uff52\\uff4e\", \"\\uff30\\uff55\\uff52\\uff50\\uff4c\\uff45\", Integer.valueOf(12), Boolean.valueOf(false)},\n+      {\"\\uff30\\uff48\\uff49\\uff4c\", \"\\uff2d\\uff49\\uff4c\\uff4e\\uff45\", \"\\uff30\\uff55\\uff52\\uff50\\uff4c\\uff45\", Integer.valueOf(3), Boolean.valueOf(false)},\n+      {\"\\uff24\\uff41\\uff56\\uff45\", \"\\uff2d\\uff4f\\uff4f\\uff52\\uff45\", \"\\uff27\\uff52\\uff45\\uff45\\uff4e\", Integer.valueOf(88), Boolean.valueOf(false)},\n+      {\"\\uff28\\uff41\\uff4e\\uff53\", \"\\uff2d\\uff55\\uff4c\\uff4c\\uff45\\uff52\", \"\\uff2d\\uff41\\uff52\\uff4f\\uff4f\\uff4e\", Integer.valueOf(5), Boolean.valueOf(false)},\n+      {\"\\uff32\\uff49\\uff43\\uff4b\", \"\\uff2c\\uff45\\uff56\\uff45\\uff4e\\uff53\\uff4f\\uff4e\", \"\\uff22\\uff4c\\uff55\\uff45\", Integer.valueOf(2), Boolean.valueOf(false)},\n+      {\"\\uff34\\uff49\\uff4d\", \"\\uff30\\uff52\\uff49\\uff4e\\uff5a\\uff49\\uff4e\\uff47\", \"\\uff22\\uff4c\\uff55\\uff45\", Integer.valueOf(22), Boolean.valueOf(false)},\n+      {\"\\uff23\\uff48\\uff45\\uff53\\uff54\\uff45\\uff52\", \"\\uff32\\uff4f\\uff53\\uff45\", \"\\uff22\\uff4c\\uff41\\uff43\\uff4b\", Integer.valueOf(0), Boolean.valueOf(false)},\n+      {\"\\uff32\\uff41\\uff59\", \"\\uff32\\uff59\\uff41\\uff4e\", \"\\uff27\\uff52\\uff41\\uff59\", Integer.valueOf(77), Boolean.valueOf(false)},\n+      {\"\\uff27\\uff45\\uff4f\\uff52\\uff47\\uff45\\uff53\", \"\\uff33\\uff41\\uff41\\uff42\", \"\\uff32\\uff45\\uff44\", Integer.valueOf(4), Boolean.valueOf(false)},\n+      {\"\\uff37\\uff49\\uff4c\\uff4c\\uff49\\uff45\", \"\\uff37\\uff41\\uff4c\\uff4b\\uff45\\uff52\", \"\\uff30\\uff48\\uff54\\uff48\\uff41\\uff4c\\uff4f\\u3000\\uff42\\uff4c\\uff55\\uff45\", Integer.valueOf(4), Boolean.valueOf(false)},\n+      {\"\\uff2b\\uff41\\uff54\\uff48\\uff59\", \"\\uff37\\uff41\\uff4c\\uff52\\uff41\\uff54\\uff48\", \"\\uff22\\uff4c\\uff55\\uff45\", Integer.valueOf(8), Boolean.valueOf(false)},\n+      {\"\\uff21\\uff52\\uff4e\\uff41\\uff55\\uff44\", \"\\uff37\\uff45\\uff42\\uff45\\uff52\", \"\\uff27\\uff52\\uff45\\uff45\\uff4e\", Integer.valueOf(44), Boolean.valueOf(false)}\n+  };\n+\n+  static final Object[][] contents = {\n+      {\"TableData\", data }        \/\/ array for table data\n+  };\n+}\n","filename":"test\/jdk\/performance\/client\/SwingMark\/src\/resources\/TableRowTest_ja.java","additions":90,"deletions":0,"binary":false,"changes":90,"status":"added"},{"patch":"@@ -0,0 +1,6 @@\n+JMTest_04\n+TextAreaTest\n+SliderTest\n+ListTest\n+TableRowTest\n+TreeTest\n","filename":"test\/jdk\/performance\/client\/SwingMark\/src\/resources\/TestList.txt","additions":6,"deletions":0,"binary":false,"changes":6,"status":"added"},{"patch":"@@ -0,0 +1,32 @@\n+#\n+# Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+#\n+# Redistribution and use in source and binary forms, with or without\n+# modification, are permitted provided that the following conditions\n+# are met:\n+#\n+#   - Redistributions of source code must retain the above copyright\n+#     notice, this list of conditions and the following disclaimer.\n+#\n+#   - Redistributions in binary form must reproduce the above copyright\n+#     notice, this list of conditions and the following disclaimer in the\n+#     documentation and\/or other materials provided with the distribution.\n+#\n+#   - Neither the name of Oracle nor the names of its\n+#     contributors may be used to endorse or promote products derived\n+#     from this software without specific prior written permission.\n+#\n+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\n+# IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n+# THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n+# PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n+# CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n+# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n+# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n+# PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n+# LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n+# NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n+# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+#\n+# Resource bundle for Menu Test\n+DisplayString=Swing is Fast!!!   \n","filename":"test\/jdk\/performance\/client\/SwingMark\/src\/resources\/TextAreaTest.properties","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -0,0 +1,32 @@\n+#\n+# Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+#\n+# Redistribution and use in source and binary forms, with or without\n+# modification, are permitted provided that the following conditions\n+# are met:\n+#\n+#   - Redistributions of source code must retain the above copyright\n+#     notice, this list of conditions and the following disclaimer.\n+#\n+#   - Redistributions in binary form must reproduce the above copyright\n+#     notice, this list of conditions and the following disclaimer in the\n+#     documentation and\/or other materials provided with the distribution.\n+#\n+#   - Neither the name of Oracle nor the names of its\n+#     contributors may be used to endorse or promote products derived\n+#     from this software without specific prior written permission.\n+#\n+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\n+# IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n+# THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n+# PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n+# CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n+# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n+# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n+# PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n+# LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n+# NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n+# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+#\n+# Resource bundle for Menu Test\n+DisplayString=\\uff33\\uff57\\uff49\\uff4e\\uff47\\u3000\\uff49\\uff53\\u3000\\uff26\\uff41\\uff53\\uff54\\uff01\\uff01\\uff01\\u3000\\u3000\\u3000\n","filename":"test\/jdk\/performance\/client\/SwingMark\/src\/resources\/TextAreaTest_ja.properties","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"}]}