{"files":[{"patch":"@@ -48,0 +48,1 @@\n+import java.util.Objects;\n@@ -108,0 +109,10 @@\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (!(o instanceof HttpTestRequestHeaders other)) return false;\n+            return Objects.equals(entrySet(), other.entrySet());\n+        }\n+        @Override\n+        public int hashCode() {\n+            return Objects.hashCode(entrySet());\n+        }\n@@ -141,0 +152,4 @@\n+            @Override\n+            public String toString() {\n+                return String.valueOf(headers);\n+            }\n@@ -163,0 +178,4 @@\n+            @Override\n+            public String toString() {\n+                return String.valueOf(headers);\n+            }\n","filename":"test\/jdk\/java\/net\/httpclient\/HttpServerAdapters.java","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,0 +50,4 @@\n+import org.testng.ITestContext;\n+import org.testng.ITestResult;\n+import org.testng.SkipException;\n+import org.testng.annotations.AfterClass;\n@@ -51,0 +55,1 @@\n+import org.testng.annotations.BeforeMethod;\n@@ -73,0 +78,1 @@\n+import java.util.Objects;\n@@ -74,0 +80,8 @@\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n@@ -75,0 +89,3 @@\n+import java.util.stream.Collectors;\n+\n+import static java.lang.System.err;\n@@ -143,0 +160,136 @@\n+    \/\/ a shared executor helps reduce the amount of threads created by the test\n+    static final TestExecutor executor = new TestExecutor(Executors.newCachedThreadPool());\n+    static final ConcurrentMap<String, Throwable> FAILURES = new ConcurrentHashMap<>();\n+    static volatile boolean tasksFailed;\n+    static final AtomicLong serverCount = new AtomicLong();\n+    static final AtomicLong clientCount = new AtomicLong();\n+    static final long start = System.nanoTime();\n+    public static String now() {\n+        long now = System.nanoTime() - start;\n+        long secs = now \/ 1000_000_000;\n+        long mill = (now % 1000_000_000) \/ 1000_000;\n+        long nan = now % 1000_000;\n+        return String.format(\"[%d s, %d ms, %d ns] \", secs, mill, nan);\n+    }\n+\n+    final ReferenceTracker TRACKER = ReferenceTracker.INSTANCE;\n+    private volatile HttpClient sharedClient;\n+\n+    static class TestExecutor implements Executor {\n+        final AtomicLong tasks = new AtomicLong();\n+        Executor executor;\n+        TestExecutor(Executor executor) {\n+            this.executor = executor;\n+        }\n+\n+        @Override\n+        public void execute(Runnable command) {\n+            long id = tasks.incrementAndGet();\n+            executor.execute(() -> {\n+                try {\n+                    command.run();\n+                } catch (Throwable t) {\n+                    tasksFailed = true;\n+                    out.printf(now() + \"Task %s failed: %s%n\", id, t);\n+                    err.printf(now() + \"Task %s failed: %s%n\", id, t);\n+                    FAILURES.putIfAbsent(\"Task \" + id, t);\n+                    throw t;\n+                }\n+            });\n+        }\n+\n+        public void shutdown() throws InterruptedException {\n+            if (executor instanceof ExecutorService service) {\n+                service.shutdown();\n+                service.awaitTermination(1000, TimeUnit.MILLISECONDS);\n+            }\n+        }\n+\n+\n+    }\n+\n+    protected boolean stopAfterFirstFailure() {\n+        return Boolean.getBoolean(\"jdk.internal.httpclient.debug\");\n+    }\n+\n+    final AtomicReference<SkipException> skiptests = new AtomicReference<>();\n+    void checkSkip() {\n+        var skip = skiptests.get();\n+        if (skip != null) throw skip;\n+    }\n+    static String name(ITestResult result) {\n+        var params = result.getParameters();\n+        return result.getName()\n+                + (params == null ? \"()\" : Arrays.toString(result.getParameters()));\n+    }\n+\n+    @BeforeMethod\n+    void beforeMethod(ITestContext context) {\n+        if (stopAfterFirstFailure() && context.getFailedTests().size() > 0) {\n+            if (skiptests.get() == null) {\n+                SkipException skip = new SkipException(\"some tests failed\");\n+                skip.setStackTrace(new StackTraceElement[0]);\n+                skiptests.compareAndSet(null, skip);\n+            }\n+        }\n+    }\n+\n+    @AfterClass\n+    static final void printFailedTests(ITestContext context) {\n+        out.println(\"\\n=========================\");\n+        var failed = context.getFailedTests().getAllResults().stream()\n+                .collect(Collectors.toMap(r -> name(r), ITestResult::getThrowable));\n+        FAILURES.putAll(failed);\n+        try {\n+            out.printf(\"%n%sCreated %d servers and %d clients%n\",\n+                    now(), serverCount.get(), clientCount.get());\n+            if (FAILURES.isEmpty()) return;\n+            out.println(\"Failed tests: \");\n+            FAILURES.entrySet().forEach((e) -> {\n+                out.printf(\"\\t%s: %s%n\", e.getKey(), e.getValue());\n+                e.getValue().printStackTrace(out);\n+            });\n+            if (tasksFailed) {\n+                out.println(\"WARNING: Some tasks failed\");\n+            }\n+        } finally {\n+            out.println(\"\\n=========================\\n\");\n+        }\n+    }\n+\n+    private HttpClient makeNewClient() {\n+        clientCount.incrementAndGet();\n+        return HttpClient.newBuilder()\n+                .proxy(NO_PROXY)\n+                .executor(executor)\n+                .sslContext(sslContext)\n+                .build();\n+    }\n+\n+    static volatile String lastMethod;\n+    HttpClient newHttpClient(String method, boolean share) {\n+        if (!share) return TRACKER.track(makeNewClient());\n+        HttpClient shared = sharedClient;\n+        String last = lastMethod;\n+        if (shared != null && Objects.equals(last, method)) return shared;\n+        synchronized (this) {\n+            shared = sharedClient;\n+            last = lastMethod;\n+            if (!Objects.equals(last, method)) {\n+                \/\/ reset sharedClient to avoid side effects\n+                \/\/ between methods. This is needed to keep the test\n+                \/\/ expectation that the first HTTP\/2 clear request\n+                \/\/ will be an upgrade\n+                if (shared != null) {\n+                    TRACKER.track(shared);\n+                    shared = sharedClient = null;\n+                }\n+            }\n+            if (shared == null) {\n+                shared = sharedClient = makeNewClient();\n+                last = lastMethod = method;\n+            }\n+            return shared;\n+        }\n+    }\n+\n@@ -170,40 +323,31 @@\n-            if (!sameClient || client == null)\n-                client = HttpClient.newBuilder()\n-                        .proxy(NO_PROXY)\n-                        .sslContext(sslContext)\n-                        .build();\n-\n-            HttpRequest.Builder requestBuilder = HttpRequest.newBuilder(uri);\n-            if (!useDefault) {\n-                requestBuilder.header(name, value);\n-            }\n-            HttpRequest request = requestBuilder.build();\n-            HttpResponse<String> resp = client.send(request, BodyHandlers.ofString());\n-\n-            out.println(\"Got response: \" + resp);\n-            out.println(\"Got body: \" + resp.body());\n-            assertEquals(resp.statusCode(), 200,\n-                    \"Expected 200, got:\" + resp.statusCode());\n-\n-            boolean isInitialRequest = i == 0;\n-            boolean isSecure = uri.getScheme().equalsIgnoreCase(\"https\");\n-            boolean isHTTP2 = resp.version() == HTTP_2;\n-            boolean isNotH2CUpgrade = isSecure || (sameClient == true && !isInitialRequest);\n-            boolean isDefaultHostHeader = name.equalsIgnoreCase(\"host\") && useDefault;\n-\n-            \/\/ By default, HTTP\/2 sets the `:authority:` pseudo-header, instead\n-            \/\/ of the `Host` header. Therefore, there should be no \"X-Host\"\n-            \/\/ header in the response, except the response to the h2c Upgrade\n-            \/\/ request which will have been sent through HTTP\/1.1.\n-\n-            if (isDefaultHostHeader && isHTTP2 && isNotH2CUpgrade) {\n-                assertTrue(resp.headers().firstValue(\"X-\" + key).isEmpty());\n-                assertTrue(resp.headers().allValues(\"X-\" + key).isEmpty());\n-                out.println(\"No X-\" + key + \" header received, as expected\");\n-            } else {\n-                String receivedHeaderString = value == null ? null\n-                        : resp.headers().firstValue(\"X-\"+key).get();\n-                out.println(\"Got X-\" + key + \": \" + resp.headers().allValues(\"X-\"+key));\n-                if (value != null) {\n-                    assertEquals(receivedHeaderString, value);\n-                    assertEquals(resp.headers().allValues(\"X-\"+key), List.of(value));\n+            try {\n+                if (!sameClient || client == null)\n+                    client = newHttpClient(\"test\", sameClient);\n+\n+                HttpRequest.Builder requestBuilder = HttpRequest.newBuilder(uri);\n+                if (!useDefault) {\n+                    requestBuilder.header(name, value);\n+                }\n+                HttpRequest request = requestBuilder.build();\n+                HttpResponse<String> resp = client.send(request, BodyHandlers.ofString());\n+\n+                out.println(\"Got response: \" + resp);\n+                out.println(\"Got body: \" + resp.body());\n+                assertEquals(resp.statusCode(), 200,\n+                        \"Expected 200, got:\" + resp.statusCode());\n+\n+                boolean isInitialRequest = i == 0;\n+                boolean isSecure = uri.getScheme().equalsIgnoreCase(\"https\");\n+                boolean isHTTP2 = resp.version() == HTTP_2;\n+                boolean isNotH2CUpgrade = isSecure || (sameClient == true && !isInitialRequest);\n+                boolean isDefaultHostHeader = name.equalsIgnoreCase(\"host\") && useDefault;\n+\n+                \/\/ By default, HTTP\/2 sets the `:authority:` pseudo-header, instead\n+                \/\/ of the `Host` header. Therefore, there should be no \"X-Host\"\n+                \/\/ header in the response, except the response to the h2c Upgrade\n+                \/\/ request which will have been sent through HTTP\/1.1.\n+\n+                if (isDefaultHostHeader && isHTTP2 && isNotH2CUpgrade) {\n+                    assertTrue(resp.headers().firstValue(\"X-\" + key).isEmpty());\n+                    assertTrue(resp.headers().allValues(\"X-\" + key).isEmpty());\n+                    out.println(\"No X-\" + key + \" header received, as expected\");\n@@ -211,1 +355,16 @@\n-                    assertEquals(resp.headers().allValues(\"X-\"+key).size(), 0);\n+                    String receivedHeaderString = value == null ? null\n+                            : resp.headers().firstValue(\"X-\" + key).orElse(null);\n+                    out.println(\"Got X-\" + key + \": \" + resp.headers().allValues(\"X-\" + key));\n+                    if (value != null) {\n+                        assertEquals(receivedHeaderString, value);\n+                        assertEquals(resp.headers().allValues(\"X-\" + key), List.of(value));\n+                    } else {\n+                        assertEquals(resp.headers().allValues(\"X-\" + key).size(), 0);\n+                    }\n+                }\n+            } finally {\n+                if (!sameClient) {\n+                    client = null;\n+                    System.gc();\n+                    var error = TRACKER.check(500);\n+                    if (error != null) throw error;\n@@ -226,4 +385,1 @@\n-        HttpClient client = HttpClient.newBuilder()\n-                .proxy(NO_PROXY)\n-                .sslContext(sslContext)\n-                .build();\n+        HttpClient client = newHttpClient(\"testHomeMadeIllegalHeader\", sameClient);\n@@ -231,19 +387,45 @@\n-        \/\/ Test a request which contains an illegal header created\n-        HttpRequest req = new HttpRequest() {\n-            @Override public Optional<BodyPublisher> bodyPublisher() {\n-                return Optional.of(BodyPublishers.noBody());\n-            }\n-            @Override public String method() {\n-                return \"GET\";\n-            }\n-            @Override public Optional<Duration> timeout() {\n-                return Optional.empty();\n-            }\n-            @Override public boolean expectContinue() {\n-                return false;\n-            }\n-            @Override public URI uri() {\n-                return uri;\n-            }\n-            @Override public Optional<HttpClient.Version> version() {\n-                return Optional.empty();\n+        try {\n+            \/\/ Test a request which contains an illegal header created\n+            HttpRequest req = new HttpRequest() {\n+                @Override\n+                public Optional<BodyPublisher> bodyPublisher() {\n+                    return Optional.of(BodyPublishers.noBody());\n+                }\n+\n+                @Override\n+                public String method() {\n+                    return \"GET\";\n+                }\n+\n+                @Override\n+                public Optional<Duration> timeout() {\n+                    return Optional.empty();\n+                }\n+\n+                @Override\n+                public boolean expectContinue() {\n+                    return false;\n+                }\n+\n+                @Override\n+                public URI uri() {\n+                    return uri;\n+                }\n+\n+                @Override\n+                public Optional<HttpClient.Version> version() {\n+                    return Optional.empty();\n+                }\n+\n+                @Override\n+                public HttpHeaders headers() {\n+                    Map<String, List<String>> map = Map.of(\"upgrade\", List.of(\"http:\/\/foo.com\"));\n+                    return HttpHeaders.of(map, (x, y) -> true);\n+                }\n+            };\n+\n+            try {\n+                HttpResponse<String> response = client.send(req, BodyHandlers.ofString());\n+                Assert.fail(\"Unexpected reply: \" + response);\n+            } catch (IllegalArgumentException ee) {\n+                out.println(\"Got IAE as expected\");\n@@ -251,3 +433,6 @@\n-            @Override public HttpHeaders headers() {\n-                Map<String, List<String>> map = Map.of(\"upgrade\", List.of(\"http:\/\/foo.com\"));\n-                return HttpHeaders.of(map, (x, y) -> true);\n+        } finally {\n+            if (!sameClient) {\n+                client = null;\n+                System.gc();\n+                var error = TRACKER.check(500);\n+                if (error != null) throw error;\n@@ -255,7 +440,0 @@\n-        };\n-\n-        try {\n-            HttpResponse<String> response = client.send(req, BodyHandlers.ofString());\n-            Assert.fail(\"Unexpected reply: \" + response);\n-        } catch (IllegalArgumentException ee) {\n-            out.println(\"Got IAE as expected\");\n@@ -279,40 +457,32 @@\n-            if (!sameClient || client == null)\n-                client = HttpClient.newBuilder()\n-                        .proxy(NO_PROXY)\n-                        .sslContext(sslContext)\n-                        .build();\n-\n-            HttpRequest.Builder requestBuilder = HttpRequest.newBuilder(uri);\n-            if (!useDefault) {\n-                requestBuilder.header(name, value);\n-            }\n-            HttpRequest request = requestBuilder.build();\n-\n-            boolean isInitialRequest = i == 0;\n-            boolean isSecure = uri.getScheme().equalsIgnoreCase(\"https\");\n-            boolean isNotH2CUpgrade = isSecure || (sameClient == true && !isInitialRequest);\n-            boolean isDefaultHostHeader = name.equalsIgnoreCase(\"host\") && useDefault;\n-\n-            client.sendAsync(request, BodyHandlers.ofString())\n-                    .thenApply(response -> {\n-                        out.println(\"Got response: \" + response);\n-                        out.println(\"Got body: \" + response.body());\n-                        assertEquals(response.statusCode(), 200);\n-                        return response;})\n-                    .thenAccept(resp -> {\n-                        \/\/ By default, HTTP\/2 sets the `:authority:` pseudo-header, instead\n-                        \/\/ of the `Host` header. Therefore, there should be no \"X-Host\"\n-                        \/\/ header in the response, except the response to the h2c Upgrade\n-                        \/\/ request which will have been sent through HTTP\/1.1.\n-\n-                        if (isDefaultHostHeader && resp.version() == HTTP_2 && isNotH2CUpgrade) {\n-                            assertTrue(resp.headers().firstValue(\"X-\" + key).isEmpty());\n-                            assertTrue(resp.headers().allValues(\"X-\" + key).isEmpty());\n-                            out.println(\"No X-\" + key + \" header received, as expected\");\n-                        } else {\n-                            String receivedHeaderString = value == null ? null\n-                                    : resp.headers().firstValue(\"X-\"+key).get();\n-                            out.println(\"Got X-\" + key + \": \" + resp.headers().allValues(\"X-\"+key));\n-                            if (value != null) {\n-                                assertEquals(receivedHeaderString, value);\n-                                assertEquals(resp.headers().allValues(\"X-\" + key), List.of(value));\n+            try {\n+                if (!sameClient || client == null)\n+                    client = newHttpClient(\"testAsync\", sameClient);\n+\n+                HttpRequest.Builder requestBuilder = HttpRequest.newBuilder(uri);\n+                if (!useDefault) {\n+                    requestBuilder.header(name, value);\n+                }\n+                HttpRequest request = requestBuilder.build();\n+\n+                boolean isInitialRequest = i == 0;\n+                boolean isSecure = uri.getScheme().equalsIgnoreCase(\"https\");\n+                boolean isNotH2CUpgrade = isSecure || (sameClient == true && !isInitialRequest);\n+                boolean isDefaultHostHeader = name.equalsIgnoreCase(\"host\") && useDefault;\n+\n+                client.sendAsync(request, BodyHandlers.ofString())\n+                        .thenApply(response -> {\n+                            out.println(\"Got response: \" + response);\n+                            out.println(\"Got body: \" + response.body());\n+                            assertEquals(response.statusCode(), 200);\n+                            return response;\n+                        })\n+                        .thenAccept(resp -> {\n+                            \/\/ By default, HTTP\/2 sets the `:authority:` pseudo-header, instead\n+                            \/\/ of the `Host` header. Therefore, there should be no \"X-Host\"\n+                            \/\/ header in the response, except the response to the h2c Upgrade\n+                            \/\/ request which will have been sent through HTTP\/1.1.\n+\n+                            if (isDefaultHostHeader && resp.version() == HTTP_2 && isNotH2CUpgrade) {\n+                                assertTrue(resp.headers().firstValue(\"X-\" + key).isEmpty());\n+                                assertTrue(resp.headers().allValues(\"X-\" + key).isEmpty());\n+                                out.println(\"No X-\" + key + \" header received, as expected\");\n@@ -320,1 +490,9 @@\n-                                assertEquals(resp.headers().allValues(\"X-\" + key).size(), 1);\n+                                String receivedHeaderString = value == null ? null\n+                                        : resp.headers().firstValue(\"X-\" + key).orElse(null);\n+                                out.println(\"Got X-\" + key + \": \" + resp.headers().allValues(\"X-\" + key));\n+                                if (value != null) {\n+                                    assertEquals(receivedHeaderString, value);\n+                                    assertEquals(resp.headers().allValues(\"X-\" + key), List.of(value));\n+                                } else {\n+                                    assertEquals(resp.headers().allValues(\"X-\" + key).size(), 1);\n+                                }\n@@ -322,3 +500,10 @@\n-                        }\n-                    })\n-                    .join();\n+                        })\n+                        .join();\n+            } finally {\n+                if (!sameClient) {\n+                    client = null;\n+                    System.gc();\n+                    var error = TRACKER.check(500);\n+                    if (error != null) throw error;\n+                }\n+            }\n@@ -367,4 +552,21 @@\n-        httpTestServer.stop();\n-        httpsTestServer.stop();\n-        http2TestServer.stop();\n-        https2TestServer.stop();\n+        HttpClient shared = sharedClient;\n+        String sharedClientName =\n+                shared == null ? null : shared.toString();\n+        if (shared != null) TRACKER.track(shared);\n+        shared = sharedClient = null;\n+        Thread.sleep(100);\n+        AssertionError fail = TRACKER.check(500);\n+        try {\n+            httpTestServer.stop();\n+            httpsTestServer.stop();\n+            http2TestServer.stop();\n+            https2TestServer.stop();\n+            executor.shutdown();\n+        } finally {\n+            if (fail != null) {\n+                if (sharedClientName != null) {\n+                    err.println(\"Shared client name is: \" + sharedClientName);\n+                }\n+                throw fail;\n+            }\n+        }\n@@ -382,1 +584,1 @@\n-            out.println(\"Http1UriStringHandler received, uri: \" + uriString);\n+            out.println(\"HttpUriStringHandler received, uri: \" + uriString);\n@@ -385,0 +587,2 @@\n+            out.println(\"HttpUriStringHandler received, headerName: \" + headerName\n+                    + \"\\n\\theaders: \" + t.getRequestHeaders());\n","filename":"test\/jdk\/java\/net\/httpclient\/SpecialHeadersTest.java","additions":328,"deletions":124,"binary":false,"changes":452,"status":"modified"}]}