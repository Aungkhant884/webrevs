{"files":[{"patch":"@@ -7259,0 +7259,26 @@\n+\/\/ Float.isFinite\n+instruct isFiniteF_reg_reg(iRegINoSp dst, fRegF src)\n+%{\n+  match(Set dst (IsFiniteF src));\n+  format %{ \"isFinite $dst, $src\" %}\n+  ins_encode %{\n+    __ fclass_s(as_Register($dst$$reg), as_FloatRegister($src$$reg));\n+    __ andi(as_Register($dst$$reg), as_Register($dst$$reg), 0b0001111110);\n+    __ slt(as_Register($dst$$reg), zr, as_Register($dst$$reg));\n+  %}\n+  ins_pipe(fp_dop_reg_reg_s);\n+%}\n+\n+\/\/ Double.isFinite\n+instruct isFiniteD_reg_reg(iRegINoSp dst, fRegD src)\n+%{\n+  match(Set dst (IsFiniteD src));\n+  format %{ \"isFinite $dst, $src\" %}\n+  ins_encode %{\n+    __ fclass_d(as_Register($dst$$reg), as_FloatRegister($src$$reg));\n+    __ andi(as_Register($dst$$reg), as_Register($dst$$reg), 0b0001111110);\n+    __ slt(as_Register($dst$$reg), zr, as_Register($dst$$reg));\n+  %}\n+  ins_pipe(fp_dop_reg_reg_d);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -209,1 +209,3 @@\n-   do_name(     isInfinite_name,                                 \"isInfinite\")                                          \\\n+   do_name(     isInfinite_name,                                  \"isInfinite\")                                         \\\n+  do_intrinsic(_floatIsFinite,            java_lang_Float,        isFinite_name,      float_bool_signature,      F_S)   \\\n+   do_name(     isFinite_name,                                    \"isFinite\")                                           \\\n@@ -211,0 +213,1 @@\n+  do_intrinsic(_doubleIsFinite,           java_lang_Double,       isFinite_name,      double_bool_signature,     F_S)   \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -545,0 +545,3 @@\n+  case vmIntrinsics::_floatIsFinite:\n+    if (!Matcher::match_rule_supported(Op_IsFiniteF)) return false;\n+    break;\n@@ -548,0 +551,3 @@\n+  case vmIntrinsics::_doubleIsFinite:\n+    if (!Matcher::match_rule_supported(Op_IsFiniteD)) return false;\n+    break;\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -250,0 +250,1 @@\n+macro(IsFiniteF)\n@@ -251,0 +252,1 @@\n+macro(IsFiniteD)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -310,0 +310,18 @@\n+\/\/---------- IsFiniteFNode -----------------------------------------------------\n+class IsFiniteFNode : public Node {\n+  public:\n+  IsFiniteFNode(Node* in1) : Node(0, in1) {}\n+  virtual int   Opcode() const;\n+  const Type* bottom_type() const { return TypeInt::BOOL; }\n+  virtual uint ideal_reg() const { return Op_RegI; }\n+};\n+\n+\/\/---------- IsFiniteDNode -----------------------------------------------------\n+class IsFiniteDNode : public Node {\n+  public:\n+  IsFiniteDNode(Node* in1) : Node(0, in1) {}\n+  virtual int   Opcode() const;\n+  const Type* bottom_type() const { return TypeInt::BOOL; }\n+  virtual uint ideal_reg() const { return Op_RegI; }\n+};\n+\n","filename":"src\/hotspot\/share\/opto\/intrinsicnode.hpp","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -519,0 +519,1 @@\n+  case vmIntrinsics::_floatIsFinite:\n@@ -520,0 +521,1 @@\n+  case vmIntrinsics::_doubleIsFinite:\n@@ -4540,0 +4542,3 @@\n+  case vmIntrinsics::_floatIsFinite:\n+    result = new IsFiniteFNode(arg);\n+    break;\n@@ -4543,0 +4548,3 @@\n+  case vmIntrinsics::_doubleIsFinite:\n+    result = new IsFiniteDNode(arg);\n+    break;\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1846,0 +1846,2 @@\n+  declare_c2_type(IsFiniteFNode, Node)                                    \\\n+  declare_c2_type(IsFiniteDNode, Node)                                    \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -785,0 +785,1 @@\n+    @IntrinsicCandidate\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Double.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -607,0 +607,1 @@\n+     @IntrinsicCandidate\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Float.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -24,8 +24,0 @@\n-\/**\n-* @test\n-* @summary Test intrinsics for Double methods isNaN, isFinite, isInfinite.\n-* @requires vm.cpu.features ~= \".*avx512dq.*\" | os.arch == \"riscv64\"\n-* @library \/test\/lib \/\n-* @run driver compiler.intrinsics.TestDoubleClassCheck\n-*\/\n-\n@@ -33,1 +25,0 @@\n-import compiler.lib.ir_framework.*;\n@@ -43,4 +34,0 @@\n-    public static void main(String args[]) {\n-        TestFramework.run(TestDoubleClassCheck.class);\n-    }\n-\n@@ -62,11 +49,0 @@\n-    @Test \/\/ needs to be run in (fast) debug mode\n-    @Warmup(10000)\n-    @IR(counts = {\"IsInfiniteD\", \">= 1\"}) \/\/ Atleast one IsInfiniteD node is generated if intrinsic is used\n-    public void testIsInfinite() {\n-        for (int i = 0; i < BUFFER_SIZE; i++) {\n-            outputs[i] = Double.isInfinite(inputs[i]);\n-        }\n-        checkResult(\"isInfinite\");\n-    }\n-\n-\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/TestDoubleClassCheck.java","additions":0,"deletions":24,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -0,0 +1,50 @@\n+\/*\n+ * Copyright (c) 2022, BELLSOFT. All rights reserved.\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+* @test\n+* @summary Test intrinsic for Double.isFinite.\n+* @requires os.arch == \"riscv64\"\n+* @library \/test\/lib \/\n+* @run driver compiler.intrinsics.TestDoubleIsFinite\n+*\/\n+\n+package compiler.intrinsics;\n+import compiler.lib.ir_framework.*;\n+\n+public class TestDoubleIsFinite extends TestDoubleClassCheck {\n+    public static void main(String args[]) {\n+        TestFramework.run(TestDoubleIsFinite.class);\n+    }\n+\n+    @Test \/\/ needs to be run in (fast) debug mode\n+    @Warmup(10000)\n+    @IR(counts = {\"IsFiniteD\", \">= 1\"}) \/\/ At least one IsFiniteD node is generated if intrinsic is used\n+    public void testIsFinite() {\n+        for (int i = 0; i < BUFFER_SIZE; i++) {\n+            outputs[i] = Double.isFinite(inputs[i]);\n+        }\n+        checkResult(\"isFinite\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/TestDoubleIsFinite.java","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"},{"patch":"@@ -0,0 +1,50 @@\n+\/*\n+ * Copyright (c) 2022, BELLSOFT. All rights reserved.\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+* @test\n+* @summary Test intrinsic for Double.isInfinite.\n+* @requires vm.cpu.features ~= \".*avx512dq.*\" | os.arch == \"riscv64\"\n+* @library \/test\/lib \/\n+* @run driver compiler.intrinsics.TestDoubleIsInfinite\n+*\/\n+\n+package compiler.intrinsics;\n+import compiler.lib.ir_framework.*;\n+\n+public class TestDoubleIsInfinite extends TestDoubleClassCheck {\n+    public static void main(String args[]) {\n+        TestFramework.run(TestDoubleIsInfinite.class);\n+    }\n+\n+    @Test \/\/ needs to be run in (fast) debug mode\n+    @Warmup(10000)\n+    @IR(counts = {\"IsInfiniteD\", \">= 1\"}) \/\/ At least one IsInfiniteD node is generated if intrinsic is used\n+    public void testIsInfinite() {\n+        for (int i = 0; i < BUFFER_SIZE; i++) {\n+            outputs[i] = Double.isInfinite(inputs[i]);\n+        }\n+        checkResult(\"isInfinite\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/TestDoubleIsInfinite.java","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"},{"patch":"@@ -24,8 +24,0 @@\n-\/**\n-* @test\n-* @summary Test intrinsics for Float methods isNaN, isFinite, isInfinite.\n-* @requires vm.cpu.features ~= \".*avx512dq.*\" | os.arch == \"riscv64\"\n-* @library \/test\/lib \/\n-* @run driver compiler.intrinsics.TestFloatClassCheck\n-*\/\n-\n@@ -33,1 +25,0 @@\n-import compiler.lib.ir_framework.*;\n@@ -43,4 +34,0 @@\n-    public static void main(String args[]) {\n-        TestFramework.run(TestFloatClassCheck.class);\n-    }\n-\n@@ -62,10 +49,0 @@\n-    @Test \/\/ needs to be run in (fast) debug mode\n-    @Warmup(10000)\n-    @IR(counts = {\"IsInfiniteF\", \">= 1\"}) \/\/ Atleast one IsInfiniteF node is generated if intrinsic is used\n-    public void testIsInfinite() {\n-        for (int i = 0; i < BUFFER_SIZE; i++) {\n-            outputs[i] = Float.isInfinite(inputs[i]);\n-        }\n-        checkResult(\"isInfinite\");\n-    }\n-\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/TestFloatClassCheck.java","additions":0,"deletions":23,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -0,0 +1,50 @@\n+\/*\n+ * Copyright (c) 2022, BELLSOFT. All rights reserved.\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+* @test\n+* @summary Test intrinsics for Float.isFinite.\n+* @requires os.arch == \"riscv64\"\n+* @library \/test\/lib \/\n+* @run driver compiler.intrinsics.TestFloatIsFinite\n+*\/\n+\n+package compiler.intrinsics;\n+import compiler.lib.ir_framework.*;\n+\n+public class TestFloatIsFinite extends TestFloatClassCheck {\n+    public static void main(String args[]) {\n+        TestFramework.run(TestFloatIsFinite.class);\n+    }\n+\n+    @Test \/\/ needs to be run in (fast) debug mode\n+    @Warmup(10000)\n+    @IR(counts = {\"IsFiniteF\", \">= 1\"}) \/\/ At least one IsFiniteF node is generated if intrinsic is used\n+    public void testIsFinite() {\n+        for (int i = 0; i < BUFFER_SIZE; i++) {\n+            outputs[i] = Float.isFinite(inputs[i]);\n+        }\n+        checkResult(\"isFinite\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/TestFloatIsFinite.java","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"},{"patch":"@@ -0,0 +1,50 @@\n+\/*\n+ * Copyright (c) 2022, BELLSOFT. All rights reserved.\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+* @test\n+* @summary Test intrinsics for Float.isInfinite.\n+* @requires vm.cpu.features ~= \".*avx512dq.*\" | os.arch == \"riscv64\"\n+* @library \/test\/lib \/\n+* @run driver compiler.intrinsics.TestFloatIsInfinite\n+*\/\n+\n+package compiler.intrinsics;\n+import compiler.lib.ir_framework.*;\n+\n+public class TestFloatIsInfinite extends TestFloatClassCheck {\n+    public static void main(String args[]) {\n+        TestFramework.run(TestFloatIsInfinite.class);\n+    }\n+\n+    @Test \/\/ needs to be run in (fast) debug mode\n+    @Warmup(10000)\n+    @IR(counts = {\"IsInfiniteF\", \">= 1\"}) \/\/ At least one IsInfiniteF node is generated if intrinsic is used\n+    public void testIsInfinite() {\n+        for (int i = 0; i < BUFFER_SIZE; i++) {\n+            outputs[i] = Float.isInfinite(inputs[i]);\n+        }\n+        checkResult(\"isInfinite\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/TestFloatIsInfinite.java","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"},{"patch":"@@ -105,0 +105,25 @@\n+    @Benchmark\n+    @OperationsPerInvocation(BUFFER_SIZE)\n+    public void testIsFiniteStore() {\n+        for (int i = 0; i < BUFFER_SIZE; i++) {\n+            storeOutputs[i] = Double.isFinite(inputs[i]);\n+        }\n+    }\n+\n+\n+    @Benchmark\n+    @OperationsPerInvocation(BUFFER_SIZE)\n+    public void testIsFiniteCMov() {\n+        for (int i = 0; i < BUFFER_SIZE; i++) {\n+            cmovOutputs[i] = Double.isFinite(inputs[i]) ? 9 : 7;\n+        }\n+    }\n+\n+\n+    @Benchmark\n+    @OperationsPerInvocation(BUFFER_SIZE)\n+    public void testIsFiniteBranch() {\n+        for (int i = 0; i < BUFFER_SIZE; i++) {\n+            cmovOutputs[i] = Double.isFinite(inputs[i]) ? call() : 7;\n+        }\n+    }\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/DoubleClassCheck.java","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -109,0 +109,23 @@\n+    @Benchmark\n+    @OperationsPerInvocation(BUFFER_SIZE)\n+    public void testIsFiniteStore() {\n+        for (int i = 0; i < BUFFER_SIZE; i++) {\n+            storeOutputs[i] = Float.isFinite(inputs[i]);\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(BUFFER_SIZE)\n+    public void testIsFiniteCMov() {\n+        for (int i = 0; i < BUFFER_SIZE; i++) {\n+            cmovOutputs[i] = Float.isFinite(inputs[i]) ? 9 : 7;\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(BUFFER_SIZE)\n+    public void testIsFiniteBranch() {\n+        for (int i = 0; i < BUFFER_SIZE; i++) {\n+            cmovOutputs[i] = Float.isFinite(inputs[i]) ? call() : 7;\n+        }\n+    }\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/FloatClassCheck.java","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"}]}