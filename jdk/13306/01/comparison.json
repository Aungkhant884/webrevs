{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -266,0 +266,6 @@\n+            if (contentLen == 0) {\n+                \/\/ From RFC 8446: \"Implementations MUST NOT send zero-length fragments\n+                \/\/ of Handshake types, even if those fragments contain padding.\"\n+                throw new SSLProtocolException(\"Handshake packets must not be zero-length\");\n+            }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLEngineInputRecord.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -287,0 +287,6 @@\n+            if (contentLen == 0) {\n+                \/\/ From RFC 8446: \"Implementations MUST NOT send zero-length fragments\n+                \/\/ of Handshake types, even if those fragments contain padding.\"\n+                throw new SSLProtocolException(\"Handshake fragments must not be zero length.\");\n+            }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLSocketInputRecord.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,268 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8182621\n+ * @summary Verify the SSLEngine rejects empty Handshake, Alert, and ChangeCipherSpec messages.\n+ * @library \/javax\/net\/ssl\/templates\n+ * @run main SSLEngineEmptyFragments\n+ *\/\n+import java.nio.ByteBuffer;\n+import java.security.NoSuchAlgorithmException;\n+import javax.net.ssl.*;\n+\n+public class SSLEngineEmptyFragments extends SSLContextTemplate {\n+    private static final byte HANDSHAKE_TYPE = 22;\n+    private static final byte ALERT_TYPE = 21;\n+    private static final byte CHANGE_CIPHERSPEC_TYPE = 20;\n+    private static final String TLSv12 = \"TLSv1.2\";\n+    private static final String TLSv13 = \"TLSv1.3\";\n+\n+    private SSLEngine serverEngine;\n+    private SSLEngine clientEngine;\n+    private ByteBuffer clientIn;\n+    private ByteBuffer serverIn;\n+    private ByteBuffer clientToServer;\n+    private ByteBuffer serverToClient;\n+    private ByteBuffer clientOut;\n+    private ByteBuffer serverOut;\n+\n+    private final String protocol;\n+\n+    public SSLEngineEmptyFragments(String protocol) {\n+        this.protocol = protocol;\n+    }\n+\n+    private void initialize() throws Exception {\n+        initialize(null);\n+    }\n+\n+    private void initialize(String [] protocols) throws Exception {\n+        serverEngine = createServerSSLContext().createSSLEngine();\n+        clientEngine = createClientSSLContext().createSSLEngine();\n+\n+        serverEngine.setUseClientMode(false);\n+        clientEngine.setUseClientMode(true);\n+\n+        if (protocols != null) {\n+            clientEngine.setEnabledProtocols(protocols);\n+            serverEngine.setEnabledProtocols(protocols);\n+        }\n+\n+        \/\/ do one legitimate handshake packet, then send a zero-length alert.\n+        SSLSession session = clientEngine.getSession();\n+        int appBufferMax = session.getApplicationBufferSize();\n+        int netBufferMax = session.getPacketBufferSize();\n+\n+        \/\/ We'll make the input buffers a bit bigger than the max needed\n+        \/\/ size, so that unwrap()s following a successful data transfer\n+        \/\/ won't generate BUFFER_OVERFLOWS.\n+        \/\/\n+        \/\/ We'll use a mix of direct and indirect ByteBuffers for\n+        \/\/ tutorial purposes only.  In reality, only use direct\n+        \/\/ ByteBuffers when they give a clear performance enhancement.\n+        clientIn = ByteBuffer.allocate(appBufferMax + 50);\n+        serverIn = ByteBuffer.allocate(appBufferMax + 50);\n+\n+        clientToServer = ByteBuffer.allocateDirect(netBufferMax);\n+        serverToClient = ByteBuffer.allocateDirect(netBufferMax);\n+\n+        clientOut = ByteBuffer.wrap(\"Hi Server, I'm Client\".getBytes());\n+        serverOut = ByteBuffer.wrap(\"Hello Client, I'm Server\".getBytes());\n+    }\n+\n+    private void testAlertPacketNotHandshaking() throws Exception {\n+        log(\"**** Empty alert packet\/not handshaking\");\n+        initialize();\n+\n+        ByteBuffer alert = ByteBuffer.allocate(5);\n+        alert.put(new byte[]{ALERT_TYPE, 3, 3, 0, 0});\n+        alert.flip();\n+\n+        try {\n+            unwrap(serverEngine, alert, serverIn);\n+            throw new RuntimeException(\"Expected exception was not thrown.\");\n+        } catch (SSLHandshakeException exc) {\n+            log(\"Got the exception I wanted.\");\n+        }\n+    }\n+\n+    private void testAlertPacketMidHandshake() throws Exception {\n+        log(\"**** Empty alert packet during handshake.\");\n+        initialize(new String[]{protocol});\n+\n+        wrap(clientEngine, clientOut, clientToServer);\n+        runDelegatedTasks(clientEngine);\n+        clientToServer.flip();\n+\n+        unwrap(serverEngine, clientToServer, serverIn);\n+        runDelegatedTasks(serverEngine);\n+\n+        while(serverEngine.getHandshakeStatus() == SSLEngineResult.HandshakeStatus.NEED_WRAP) {\n+            wrap(serverEngine, serverOut, serverToClient);\n+            runDelegatedTasks(serverEngine);\n+            serverToClient.flip();\n+        }\n+\n+        ByteBuffer alert = ByteBuffer.allocate(5);\n+        alert.put(new byte[]{ALERT_TYPE, 3, 3, 0, 0});\n+        alert.flip();\n+\n+        try {\n+            unwrap(serverEngine, alert, serverIn);\n+            log(\"Server unwrap was successful when it should have failed.\");\n+            throw new RuntimeException(\"Expected exception was not thrown.\");\n+        } catch (SSLHandshakeException exc) {\n+            log(\"Got the exception I wanted.\");\n+        }\n+    }\n+\n+    private void testHandshakePacket() throws NoSuchAlgorithmException, SSLException {\n+        log(\"**** Empty handshake package.\");\n+        SSLContext ctx = SSLContext.getDefault();\n+        SSLEngine engine = ctx.createSSLEngine();\n+        engine.setUseClientMode(false);\n+\n+        try {\n+            ByteBuffer bb = ByteBuffer.allocate(5);\n+            bb.put(new byte[]{HANDSHAKE_TYPE, 3, 3, 0, 0});\n+            bb.flip();\n+            ByteBuffer out = ByteBuffer.allocate(engine.getSession().getPacketBufferSize());\n+            engine.unwrap(bb, out);\n+            throw new RuntimeException(\"SSLEngine did not throw an exception for a zero-length fragment.\");\n+        } catch (SSLProtocolException exc) {\n+            log(\"Received expected exception\");\n+        }\n+    }\n+\n+    private void testEmptyChangeCipherSpec() throws Exception {\n+        initialize(new String[]{protocol});\n+\n+        boolean foundCipherSpecMsg = false;\n+        do {\n+            log(\"Client wrap\");\n+            wrap(clientEngine, clientOut, clientToServer);\n+            runDelegatedTasks(clientEngine);\n+\n+            if(clientToServer.get(0) == CHANGE_CIPHERSPEC_TYPE) {\n+                foundCipherSpecMsg = true;\n+                break;\n+            }\n+\n+            log(\"server wrap\");\n+            wrap(serverEngine, serverOut, serverToClient);\n+            runDelegatedTasks(serverEngine);\n+\n+            clientToServer.flip();\n+            serverToClient.flip();\n+\n+            log(\"client unwrap\");\n+            unwrap(clientEngine, serverToClient, clientIn);\n+            runDelegatedTasks(clientEngine);\n+\n+            log(\"server unwrap\");\n+            unwrap(serverEngine, clientToServer, serverIn);\n+            runDelegatedTasks(serverEngine);\n+\n+            clientToServer.compact();\n+            serverToClient.compact();\n+        } while(clientEngine.getHandshakeStatus() != SSLEngineResult.HandshakeStatus.FINISHED\n+            && serverEngine.getHandshakeStatus() != SSLEngineResult.HandshakeStatus.FINISHED);\n+\n+        if (!foundCipherSpecMsg) {\n+            \/\/ performed TLS handshaking but didn't catch change-cipherspec message.\n+            throw new RuntimeException(\"Did not intercept ChangeCipherSpec message.\");\n+        }\n+\n+        ByteBuffer changeCipher = ByteBuffer.allocate(5);\n+        changeCipher.put(new byte[]{CHANGE_CIPHERSPEC_TYPE, 3, 3, 0, 0});\n+        changeCipher.flip();\n+        try {\n+            unwrap(serverEngine, changeCipher, serverIn);\n+            throw new RuntimeException(\"Didn't get the expected SSL exception\");\n+        } catch (SSLProtocolException exc) {\n+            log(\"Received expected exception.\");\n+        }\n+    }\n+\n+    private SSLEngineResult wrap(SSLEngine engine, ByteBuffer src, ByteBuffer dst) throws SSLException {\n+        SSLEngineResult result = engine.wrap(src, dst);\n+        logEngineStatus(engine, result);\n+        return result;\n+    }\n+\n+    private SSLEngineResult unwrap(SSLEngine engine, ByteBuffer src, ByteBuffer dst) throws SSLException {\n+        SSLEngineResult result = engine.unwrap(src, dst);\n+        logEngineStatus(engine, result);\n+        return result;\n+    }\n+\n+    protected void runDelegatedTasks(SSLEngine engine) throws Exception {\n+        if (engine.getHandshakeStatus() == SSLEngineResult.HandshakeStatus.NEED_TASK) {\n+            Runnable runnable;\n+            while ((runnable = engine.getDelegatedTask()) != null) {\n+                log(\"    running delegated task...\");\n+                runnable.run();\n+            }\n+            SSLEngineResult.HandshakeStatus hsStatus = engine.getHandshakeStatus();\n+            if (hsStatus == SSLEngineResult.HandshakeStatus.NEED_TASK) {\n+                throw new Exception(\n+                        \"handshake shouldn't need additional tasks\");\n+            }\n+            logEngineStatus(engine);\n+        }\n+    }\n+\n+    private void logEngineStatus(SSLEngine engine) {\n+        log(\"\\tCurrent HS State: \" + engine.getHandshakeStatus());\n+        log(\"\\tisInboundDone() : \" + engine.isInboundDone());\n+        log(\"\\tisOutboundDone(): \" + engine.isOutboundDone());\n+    }\n+\n+    private void logEngineStatus(\n+            SSLEngine engine, SSLEngineResult result) {\n+        log(\"\\tResult Status    : \" + result.getStatus());\n+        log(\"\\tResult HS Status : \" + result.getHandshakeStatus());\n+        log(\"\\tEngine HS Status : \" + engine.getHandshakeStatus());\n+        log(\"\\tisInboundDone()  : \" + engine.isInboundDone());\n+        log(\"\\tisOutboundDone() : \" + engine.isOutboundDone());\n+        log(\"\\tMore Result      : \" + result);\n+    }\n+\n+    private void log(String message) {\n+        System.err.println(message);\n+    }\n+\n+    public static void main(String [] args) throws Exception {\n+        SSLEngineEmptyFragments tests = new SSLEngineEmptyFragments(TLSv12);\n+        tests.testHandshakePacket();\n+        tests.testAlertPacketNotHandshaking();\n+        tests.testAlertPacketMidHandshake();\n+        tests.testEmptyChangeCipherSpec();\n+\n+        tests = new SSLEngineEmptyFragments(TLSv13);\n+        tests.testHandshakePacket();\n+        tests.testAlertPacketNotHandshaking();\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/ssl\/SSLEngineImpl\/SSLEngineEmptyFragments.java","additions":268,"deletions":0,"binary":false,"changes":268,"status":"added"},{"patch":"@@ -0,0 +1,366 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8182621\n+ * @summary Verify JSSE rejects empty Handshake, Alert, and ChangeCipherSpec messages.\n+ * @library \/javax\/net\/ssl\/templates\n+ * @run main SSLSocketEmptyFragments\n+ *\/\n+\n+import javax.net.ssl.*;\n+import java.io.*;\n+import java.net.InetAddress;\n+import java.net.Socket;\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.*;\n+import java.util.function.Consumer;\n+\n+public class SSLSocketEmptyFragments extends SSLContextTemplate {\n+    private static final boolean DEBUG = Boolean.getBoolean(\"test.debug\");\n+    private static final byte HANDSHAKE_TYPE = 22;\n+    private static final byte ALERT_TYPE = 21;\n+    private static final byte CHANGE_CIPHERSPEC_TYPE = 20;\n+\n+    private static final byte[] INVALID_ALERT = {ALERT_TYPE, 3, 3, 0, 0};\n+\n+    private static final byte[] INVALID_HANDSHAKE = {HANDSHAKE_TYPE, 3, 3, 0, 0};\n+    private static final int SERVER_WAIT_SEC = 5;\n+    private static final String TLSv13 = \"TLSv1.3\";\n+    private static final String TLSv12 = \"TLSv1.2\";\n+\n+    private final String protocol;\n+\n+    public SSLSocketEmptyFragments(String protocol) {\n+        this.protocol = protocol;\n+    }\n+\n+\n+    private void testEmptyHandshakeRecord(Socket client) {\n+        log(\"Sending bad handshake packet to server...\");\n+\n+        try {\n+            OutputStream os = client.getOutputStream();\n+            os.write(INVALID_HANDSHAKE);\n+            os.flush();\n+        } catch (IOException exc) {\n+            throw new RuntimeException(\"Unexpected IOException thrown by socket operations\", exc);\n+        }\n+    }\n+\n+\n+    private void testEmptyAlertNotHandshaking(Socket client) {\n+        log(\"Sending empty alert packet before handshaking starts.\");\n+\n+        try {\n+            OutputStream os = client.getOutputStream();\n+            os.write(INVALID_ALERT);\n+            os.flush();\n+        } catch (IOException exc) {\n+            throw new RuntimeException(\"Unexpected IOException thrown by socket operations.\", exc);\n+        }\n+    }\n+\n+    \/**\n+     * Runs a test where the server -- in a separate thread -- accepts a connection\n+     * and attempts to read from the remote side. Tests are successful if the\n+     * server thread returns true.\n+     *\n+     * @param clientConsumer Client-side test code that injects bad packets into the TLS handshake.\n+     * @param expectedException The exception that should be thrown by the server\n+     *\/\n+    private void executeTest(Consumer<Socket> clientConsumer,\n+                             final Class<?> expectedException) throws Exception {\n+        SSLContext serverContext = createServerSSLContext();\n+        SSLServerSocketFactory factory = serverContext.getServerSocketFactory();\n+\n+        try(ExecutorService threadPool = Executors.newFixedThreadPool(1);\n+            SSLServerSocket serverSocket = (SSLServerSocket) factory.createServerSocket()) {\n+            serverSocket.bind(null);\n+            int port = serverSocket.getLocalPort();\n+            InetAddress address = serverSocket.getInetAddress();\n+\n+            Future<Boolean> serverThread = threadPool.submit(() -> {\n+                try (SSLSocket socket = (SSLSocket) serverSocket.accept()) {\n+                    log(\"Server reading data from client.\");\n+                    socket.getInputStream().read();\n+                    log(\"The expected exception was not thrown.\");\n+                    return false;\n+\n+                } catch (Exception exc) {\n+                    if (expectedException.isAssignableFrom(exc.getClass())) {\n+                        log(\"Server thread received expected exception: \" + expectedException.getName());\n+                        return true;\n+                    } else {\n+                        log(\"Server thread threw an unexpected exception: \" + exc);\n+                        throw exc;\n+                    }\n+                }\n+            });\n+\n+            try(Socket socket = new Socket(address, port)) {\n+                clientConsumer.accept(socket);\n+                log(\"waiting for server to exit.\");\n+\n+                \/\/ wait for the server to exit, which should be quick if the test passes.\n+                if (!serverThread.get(SERVER_WAIT_SEC, TimeUnit.SECONDS)) {\n+                    throw new RuntimeException(\n+                            \"The server side of the connection did not throw the expected exception\");\n+                }\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Performs the client side of the TLS handshake, sending and receiving\n+     * packets over the given socket.\n+     * @param socket Connected socket to the server side.\n+     * @throws IOException\n+     *\/\n+    private void testEmptyAlertDuringHandshake(Socket socket) {\n+        log(\"**** Testing empty alert during handshake\");\n+\n+        try {\n+            SSLEngine engine = createClientSSLContext().createSSLEngine();\n+            engine.setUseClientMode(true);\n+            SSLSession session = engine.getSession();\n+\n+            int appBufferMax = session.getApplicationBufferSize();\n+            int netBufferMax = session.getPacketBufferSize();\n+\n+            ByteBuffer clientIn = ByteBuffer.allocate(appBufferMax + 50);\n+            ByteBuffer clientToServer = ByteBuffer.allocate(appBufferMax + 50);\n+            ByteBuffer clientOut = ByteBuffer.wrap(\"Hi Server, I'm Client\".getBytes());\n+\n+            wrap(engine, clientOut, clientToServer);\n+            runDelegatedTasks(engine);\n+            clientToServer.flip();\n+\n+            OutputStream socketOut = socket.getOutputStream();\n+            byte [] outbound = new byte[netBufferMax];\n+            clientToServer.get(outbound, 0, clientToServer.limit());\n+            socketOut.write(outbound, 0, clientToServer.limit());\n+            socketOut.flush();\n+\n+            processServerResponse(engine, clientIn, socket.getInputStream());\n+\n+            log(\"Sending invalid alert packet!\");\n+            socketOut.write(new byte[]{ALERT_TYPE, 3, 3, 0, 0});\n+            socketOut.flush();\n+\n+        } catch (Exception exc){\n+            throw new RuntimeException(\"An error occurred running the test.\", exc);\n+        }\n+    }\n+\n+    \/**\n+     * Performs TLS handshake until the client (this method) needs to send the\n+     * ChangeCipherSpec message. Then we send a packet with a zero-length fragment.\n+     *\/\n+    private void testEmptyChangeCipherSpecMessage(Socket socket) {\n+        log(\"**** Testing invalid ChangeCipherSpec message\");\n+\n+        try {\n+            socket.setSoTimeout(500);\n+            SSLEngine engine = createClientSSLContext().createSSLEngine();\n+            engine.setUseClientMode(true);\n+            SSLSession session = engine.getSession();\n+            int appBufferMax = session.getApplicationBufferSize();\n+\n+            ByteBuffer clientIn = ByteBuffer.allocate(appBufferMax + 50);\n+            ByteBuffer clientToServer = ByteBuffer.allocate(appBufferMax + 50);\n+\n+            ByteBuffer clientOut = ByteBuffer.wrap(\"Hi Server, I'm Client\".getBytes());\n+\n+            OutputStream outputStream = socket.getOutputStream();\n+\n+            boolean foundCipherSpecMsg = false;\n+\n+            byte[] outbound = new byte[8192];\n+            do {\n+                wrap(engine, clientOut, clientToServer);\n+                runDelegatedTasks(engine);\n+                clientToServer.flip();\n+\n+                if(clientToServer.get(0) == CHANGE_CIPHERSPEC_TYPE) {\n+                    foundCipherSpecMsg = true;\n+                    break;\n+                }\n+                clientToServer.get(outbound, 0, clientToServer.limit());\n+                debug(\"Writing \" + clientToServer.limit() + \" bytes to the server.\");\n+                outputStream.write(outbound, 0, clientToServer.limit());\n+                outputStream.flush();\n+\n+                processServerResponse(engine, clientIn, socket.getInputStream());\n+\n+                clientToServer.clear();\n+\n+            } while(engine.getHandshakeStatus() != SSLEngineResult.HandshakeStatus.FINISHED);\n+\n+            if (!foundCipherSpecMsg) {\n+                throw new RuntimeException(\"Didn't intercept the ChangeCipherSpec message.\");\n+            } else {\n+                log(\"Sending invalid ChangeCipherSpec message\");\n+                outputStream.write(new byte[]{CHANGE_CIPHERSPEC_TYPE, 3, 3, 0, 0});\n+                outputStream.flush();\n+            }\n+\n+        } catch (Exception exc) {\n+            throw new RuntimeException(\"An error occurred running the test.\", exc);\n+        }\n+    }\n+\n+    \/**\n+     * Processes TLS handshake messages received from the server.\n+     *\/\n+    private static void processServerResponse(SSLEngine engine, ByteBuffer clientIn,\n+                                      InputStream inputStream) throws IOException {\n+        byte [] inbound = new byte[8192];\n+        ByteBuffer serverToClient = ByteBuffer.allocate(\n+                engine.getSession().getApplicationBufferSize() + 50);\n+\n+        while(engine.getHandshakeStatus() == SSLEngineResult.HandshakeStatus.NEED_UNWRAP) {\n+            log(\"reading data from server.\");\n+            int len = inputStream.read(inbound);\n+            if (len == -1) {\n+                throw new IOException(\"Could not read from server.\");\n+            }\n+\n+            dumpBytes(inbound, len);\n+\n+            serverToClient.put(inbound, 0, len);\n+            serverToClient.flip();\n+\n+            \/\/ unwrap packets in a loop because we sometimes get multiple\n+            \/\/ TLS messages in one read() operation.\n+            do {\n+                unwrap(engine, serverToClient, clientIn);\n+                runDelegatedTasks(engine);\n+                log(\"Status after running tasks: \" + engine.getHandshakeStatus());\n+            } while (serverToClient.hasRemaining());\n+            serverToClient.compact();\n+        }\n+    }\n+\n+    private static SSLEngineResult wrap(SSLEngine engine, ByteBuffer src, ByteBuffer dst) throws SSLException {\n+        debug(\"Wrapping...\");\n+        SSLEngineResult result = engine.wrap(src, dst);\n+        logEngineStatus(engine, result);\n+        return result;\n+    }\n+\n+    private static SSLEngineResult unwrap(SSLEngine engine, ByteBuffer src, ByteBuffer dst) throws SSLException {\n+        debug(\"Unwrapping\");\n+        SSLEngineResult result = engine.unwrap(src, dst);\n+        logEngineStatus(engine, result);\n+        return result;\n+    }\n+\n+    protected static void runDelegatedTasks(SSLEngine engine) {\n+        if (engine.getHandshakeStatus() == SSLEngineResult.HandshakeStatus.NEED_TASK) {\n+            Runnable runnable;\n+            while ((runnable = engine.getDelegatedTask()) != null) {\n+                debug(\"    running delegated task...\");\n+                runnable.run();\n+            }\n+            SSLEngineResult.HandshakeStatus hsStatus = engine.getHandshakeStatus();\n+            if (hsStatus == SSLEngineResult.HandshakeStatus.NEED_TASK) {\n+                throw new RuntimeException(\n+                        \"handshake shouldn't need additional tasks\");\n+            }\n+        }\n+    }\n+\n+\n+    @Override\n+    protected ContextParameters getClientContextParameters() {\n+        return getContextParameters();\n+    }\n+\n+    @Override\n+    protected ContextParameters getServerContextParameters() {\n+        return getContextParameters();\n+    }\n+\n+    private ContextParameters getContextParameters() {\n+        return new ContextParameters(protocol, \"PKIX\", \"NewSunX509\");\n+    }\n+\n+    private static void log(String message) {\n+        System.out.println(message);\n+        System.out.flush();\n+    }\n+\n+    private static void dumpBytes(byte[] buffer, int length) {\n+        int totalLength = Math.min(buffer.length, length);\n+        StringBuffer sb = new StringBuffer();\n+        int counter = 0;\n+        for (int idx = 0; idx < totalLength ; ++idx) {\n+            sb.append(String.format(\"%02x \", buffer[idx]));\n+            if (++counter == 16) {\n+                sb.append(\"\\n\");\n+                counter = 0;\n+            }\n+        }\n+        debug(sb.toString());\n+    }\n+\n+    private static void debug(String message) {\n+        if (DEBUG) {\n+            log(message);\n+        }\n+    }\n+\n+    private static FileWriter fw;\n+\n+    private static void logEngineStatus(\n+            SSLEngine engine, SSLEngineResult result) {\n+        debug(\"\\tResult Status    : \" + result.getStatus());\n+        debug(\"\\tResult HS Status : \" + result.getHandshakeStatus());\n+        debug(\"\\tEngine HS Status : \" + engine.getHandshakeStatus());\n+        debug(\"\\tisInboundDone()  : \" + engine.isInboundDone());\n+        debug(\"\\tisOutboundDone() : \" + engine.isOutboundDone());\n+        debug(\"\\tMore Result      : \" + result);\n+    }\n+\n+\n+    public static void main(String [] args) throws Exception {\n+        SSLSocketEmptyFragments tests = new SSLSocketEmptyFragments(TLSv12);\n+\n+        tests.executeTest(\n+                tests::testEmptyHandshakeRecord, SSLProtocolException.class);\n+        tests.executeTest(\n+                tests::testEmptyAlertNotHandshaking, SSLHandshakeException.class);\n+        tests.executeTest(\n+                tests::testEmptyAlertDuringHandshake, SSLHandshakeException.class);\n+        tests.executeTest(\n+                tests::testEmptyChangeCipherSpecMessage, SSLProtocolException.class);\n+\n+        tests = new SSLSocketEmptyFragments(TLSv13);\n+        tests.executeTest(\n+                tests::testEmptyHandshakeRecord, SSLProtocolException.class);\n+        tests.executeTest(\n+                tests::testEmptyAlertNotHandshaking, SSLHandshakeException.class);\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/ssl\/SSLSocketImpl\/SSLSocketEmptyFragments.java","additions":366,"deletions":0,"binary":false,"changes":366,"status":"added"}]}