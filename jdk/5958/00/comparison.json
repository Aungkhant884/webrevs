{"files":[{"patch":"@@ -34,0 +34,1 @@\n+#include \"runtime\/threadCritical.hpp\"\n@@ -270,0 +271,18 @@\n+static GrowableArray<Mutex*>* _mutex_array = NULL;\n+\n+static void add_mutex(Mutex* var) {\n+  \/\/ This is at startup so doesn't need sync.\n+  if (_mutex_array == NULL) {\n+    _mutex_array = new (ResourceObj::C_HEAP, mtThread) GrowableArray<Mutex*>(128, mtThread);\n+  }\n+  ThreadCritical tc;\n+  _mutex_array->push(var);\n+}\n+\n+static void remove_mutex(Mutex* var) {\n+  ThreadCritical tc;\n+  int i = _mutex_array->find_from_end(var);\n+  assert(i != -1, \"Mutex not in list\");\n+  _mutex_array->remove_at(i);\n+}\n+\n@@ -271,0 +290,1 @@\n+  remove_mutex(this);\n@@ -291,0 +311,1 @@\n+  add_mutex(this);\n@@ -303,0 +324,20 @@\n+\/\/ Print all mutexes\/monitors that are currently owned by a thread; called\n+\/\/ by fatal error handler.\n+void Mutex::print_owned_locks_on_error(outputStream* st) {\n+  st->print(\"VM Mutex\/Monitor currently owned by a thread: \");\n+  bool none = true;\n+  for (int i = 0; i < _mutex_array->length(); i++) {\n+     \/\/ see if it has an owner\n+     if (_mutex_array->at(i)->owner() != NULL) {\n+       if (none) {\n+          \/\/ print format used by Mutex::print_on_error()\n+          st->print_cr(\" ([mutex\/lock_event])\");\n+          none = false;\n+       }\n+       _mutex_array->at(i)->print_on_error(st);\n+       st->cr();\n+     }\n+  }\n+  if (none) st->print_cr(\"None\");\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/mutex.cpp","additions":41,"deletions":0,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -193,0 +193,5 @@\n+\n+  \/\/ Print all mutexes\/monitors that are currently owned by a thread; called\n+  \/\/ by fatal error handler.\n+  static void print_owned_locks_on_error(outputStream* st);\n+\n","filename":"src\/hotspot\/share\/runtime\/mutex.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -160,5 +160,0 @@\n-\n-#define MAX_NUM_MUTEX 128\n-static Mutex* _mutex_array[MAX_NUM_MUTEX];\n-static int _num_mutex;\n-\n@@ -197,5 +192,0 @@\n-static void add_mutex(Mutex* var) {\n-  assert(_num_mutex < MAX_NUM_MUTEX, \"increase MAX_NUM_MUTEX\");\n-  _mutex_array[_num_mutex++] = var;\n-}\n-\n@@ -204,1 +194,0 @@\n-  add_mutex(var);                             \\\n@@ -211,1 +200,0 @@\n-  add_mutex(var);                                      \\\n@@ -216,1 +204,0 @@\n-  add_mutex(var);                                      \\\n@@ -383,20 +370,0 @@\n-\n-\/\/ Print all mutexes\/monitors that are currently owned by a thread; called\n-\/\/ by fatal error handler.\n-void print_owned_locks_on_error(outputStream* st) {\n-  st->print(\"VM Mutex\/Monitor currently owned by a thread: \");\n-  bool none = true;\n-  for (int i = 0; i < _num_mutex; i++) {\n-     \/\/ see if it has an owner\n-     if (_mutex_array[i]->owner() != NULL) {\n-       if (none) {\n-          \/\/ print format used by Mutex::print_on_error()\n-          st->print_cr(\" ([mutex\/lock_event])\");\n-          none = false;\n-       }\n-       _mutex_array[i]->print_on_error(st);\n-       st->cr();\n-     }\n-  }\n-  if (none) st->print_cr(\"None\");\n-}\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.cpp","additions":0,"deletions":33,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -172,6 +172,0 @@\n-\/\/ Print all mutexes\/monitors that are currently owned by a thread; called\n-\/\/ by fatal error handler.\n-void print_owned_locks_on_error(outputStream* st);\n-\n-char *lock_name(Mutex *mutex);\n-\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.hpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1018,1 +1018,1 @@\n-       print_owned_locks_on_error(st);\n+       Mutex::print_owned_locks_on_error(st);\n@@ -1916,0 +1916,6 @@\n+    case 3: {\n+      Mutex* ErrorTest_lock = new Mutex(Mutex::nosafepoint, \"ErrorTest_lock\");\n+      MutexLocker ml(ErrorTest_lock, Mutex::_no_safepoint_check_flag);\n+      assert(how == 0, \"test assert with lock\");\n+      break;\n+    }\n","filename":"src\/hotspot\/share\/utilities\/vmError.cpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,72 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+\/*\n+ * @test\n+ * @bug 8274794\n+ * @summary Test that locks are printed in the Error file.\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ * @requires (vm.debug == true)\n+ * @run driver ErrorFileLocksTest\n+ *\/\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+import java.io.*;\n+import java.util.regex.Pattern;\n+\n+public class ErrorFileLocksTest {\n+\n+  public static void do_test() throws Exception {\n+\n+    ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(\n+            \"-Xmx64M\",\n+            \"-XX:-CreateCoredumpOnCrash\",\n+            \"-XX:ErrorHandlerTest=3\",\n+            \"-version\");\n+\n+    OutputAnalyzer output_detail = new OutputAnalyzer(pb.start());\n+    output_detail.shouldMatch(\"# A fatal error has been detected by the Java Runtime Environment:.*\");\n+\n+    File f = ErrorFileScanner.findHsErrorFileInOutput(output_detail);\n+    System.out.println(\"Found hs error file at \" + f.getAbsolutePath());\n+\n+    ErrorFileScanner.scanHsErrorFileForContent(f, new Pattern[] {\n+            Pattern.compile(\"# *Internal Error.*\"),\n+            Pattern.compile(\".*VM Mutex\/Monitor currently owned by a thread:.*\"),\n+            Pattern.compile(\".*Threads_lock - owner thread:.*\"),\n+            Pattern.compile(\".*ErrorTest_lock - owner thread:.*\")\n+    });\n+  }\n+\n+  public static void main(String[] args) throws Exception {\n+    do_test();\n+  }\n+\n+}\n+\n+\n+\n","filename":"test\/hotspot\/jtreg\/runtime\/ErrorHandling\/ErrorFileLocksTest.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,40 +45,0 @@\n-  private static File findHsErrorFileInOutput(OutputAnalyzer output) {\n-\n-    String hs_err_file = output.firstMatch(\"# *(\\\\S*hs_err_pid.*\\\\.log)\", 1);\n-    if(hs_err_file ==null) {\n-      throw new RuntimeException(\"Did not find hs-err file in output.\\n\");\n-    }\n-\n-    File f = new File(hs_err_file);\n-    if (!f.exists()) {\n-      throw new RuntimeException(\"hs-err file missing at \"\n-              + f.getAbsolutePath() + \".\\n\");\n-    }\n-\n-    return f;\n-\n-  }\n-\n-  private static void scanHsErrorFileForContent(File f, Pattern[] pattern) throws IOException {\n-    FileInputStream fis = new FileInputStream(f);\n-    BufferedReader br = new BufferedReader(new InputStreamReader(fis));\n-    String line = null;\n-\n-    int currentPattern = 0;\n-\n-    String lastLine = null;\n-    while ((line = br.readLine()) != null && currentPattern < pattern.length) {\n-      if (pattern[currentPattern].matcher(line).matches()) {\n-        System.out.println(\"Found: \" + line + \".\");\n-        currentPattern++;\n-      }\n-      lastLine = line;\n-    }\n-    br.close();\n-\n-    if (currentPattern < pattern.length) {\n-      throw new RuntimeException(\"hs-err file incomplete (first missing pattern: \" +  pattern[currentPattern] + \")\");\n-    }\n-\n-  }\n-\n@@ -113,1 +73,1 @@\n-    File f = findHsErrorFileInOutput(output_detail);\n+    File f = ErrorFileScanner.findHsErrorFileInOutput(output_detail);\n@@ -116,1 +76,1 @@\n-    scanHsErrorFileForContent(f, new Pattern[] {\n+    ErrorFileScanner.scanHsErrorFileForContent(f, new Pattern[] {\n@@ -139,1 +99,1 @@\n-    File f2 = findHsErrorFileInOutput(output_detail);\n+    File f2 = ErrorFileScanner.findHsErrorFileInOutput(output_detail);\n@@ -148,1 +108,1 @@\n-    scanHsErrorFileForContent(f2, new Pattern[] {\n+    ErrorFileScanner.scanHsErrorFileForContent(f2, new Pattern[] {\n","filename":"test\/hotspot\/jtreg\/runtime\/ErrorHandling\/ErrorFileOverwriteTest.java","additions":5,"deletions":45,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -0,0 +1,75 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.InputStreamReader;\n+import java.io.IOException;\n+\n+import java.util.regex.Pattern;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+public class ErrorFileScanner {\n+\n+  public static File findHsErrorFileInOutput(OutputAnalyzer output) {\n+\n+    String hs_err_file = output.firstMatch(\"# *(\\\\S*hs_err_pid.*\\\\.log)\", 1);\n+    if(hs_err_file ==null) {\n+      throw new RuntimeException(\"Did not find hs-err file in output.\\n\");\n+    }\n+\n+    File f = new File(hs_err_file);\n+    if (!f.exists()) {\n+      throw new RuntimeException(\"hs-err file missing at \"\n+              + f.getAbsolutePath() + \".\\n\");\n+    }\n+\n+    return f;\n+\n+  }\n+\n+  public static void scanHsErrorFileForContent(File f, Pattern[] pattern) throws IOException {\n+    FileInputStream fis = new FileInputStream(f);\n+    BufferedReader br = new BufferedReader(new InputStreamReader(fis));\n+    String line = null;\n+\n+    int currentPattern = 0;\n+\n+    String lastLine = null;\n+    while ((line = br.readLine()) != null && currentPattern < pattern.length) {\n+      if (pattern[currentPattern].matcher(line).matches()) {\n+        System.out.println(\"Found: \" + line + \".\");\n+        currentPattern++;\n+      }\n+      lastLine = line;\n+    }\n+    br.close();\n+\n+    if (currentPattern < pattern.length) {\n+      throw new RuntimeException(\"hs-err file incomplete (first missing pattern: \" +  pattern[currentPattern] + \")\");\n+    }\n+\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/ErrorHandling\/ErrorFileScanner.java","additions":75,"deletions":0,"binary":false,"changes":75,"status":"added"}]}