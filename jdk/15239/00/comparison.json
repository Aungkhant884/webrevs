{"files":[{"patch":"@@ -165,1 +165,2 @@\n-    private final Runnable barrierCommand;\n+    \/\/remove finalï¼Œlet the barrierCommand could be  set  a new Runnable\n+    private Runnable barrierCommand;\n@@ -457,1 +458,47 @@\n-\n+    \/**\n+     * Set new barrierCommand under a new generation.\n+     *\n+     * <p>Only if there are no threads have reached the common barrier\n+     * point can we set a new barrierCommand.\n+     * eg:5 individuals in the first round of written exams,\n+     * ending with a ranking based on everyone's score points;\n+     * and a second round of interviews, with a ranking based on\n+     * the average of the three interviewers' scores;The two rounds of\n+     * ranking methods are the barrierCommand, and they are different\n+     *\n+     * @param newBarrierCommand new barrierCommand\n+     *\n+     * @return {@code true} if there are no threads have reached the\n+     *          common barrier point,this time the count==parties.\n+     *         The count has been modified {@code false} otherwise.\n+     * @throws InterruptedException if the current thread was interrupted\n+     *         while waiting* @throws TimeoutException if the specified timeout elapses.\n+     *         In this case the barrier will be broken.\n+     * @throws BrokenBarrierException if <em>another<\/em> thread was\n+     *         interrupted or timed out while the current thread was\n+     *         waiting, or the barrier was reset, or the barrier was broken\n+     *         when {@code await} was called, or the barrier action (if\n+     *         present) failed due to an exception\n+     *\/\n+    public boolean setBarrierCommand (Runnable newBarrierCommand) throws BrokenBarrierException,InterruptedException {\n+        final ReentrantLock lock = this.lock;\n+        lock.lock();\n+        try {\n+            if (Thread.interrupted()) {\n+                breakBarrier();\n+                throw new InterruptedException();\n+            }\n+            if(generation.broken)\n+                throw new BrokenBarrierException();\n+            \/\/Only if there are no threads have reached the common barrier point\n+            \/\/can we set a new barrierCommand.\n+            if(parties == count){\n+                this.barrierCommand = newBarrierCommand;\n+                return true;\n+            }else{\n+                return false;\n+            }\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/CyclicBarrier.java","additions":49,"deletions":2,"binary":false,"changes":51,"status":"modified"}]}