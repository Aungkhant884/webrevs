{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,1 +60,1 @@\n- : _output(NULL),\n+ : _output(nullptr),\n@@ -212,1 +212,1 @@\n-  while (cur != NULL) {\n+  while (cur != nullptr) {\n@@ -236,1 +236,1 @@\n-  print(\"to_bci %d\", (block->end() == NULL ? -1 : block->end()->printable_bci()));\n+  print(\"to_bci %d\", (block->end() == nullptr ? -1 : block->end()->printable_bci()));\n@@ -248,1 +248,1 @@\n-  if (block->end() != NULL) {\n+  if (block->end() != nullptr) {\n@@ -275,1 +275,1 @@\n-  if (block->dominator() != NULL) {\n+  if (block->dominator() != nullptr) {\n@@ -327,1 +327,1 @@\n-    if (intervals->at(i) != NULL) {\n+    if (intervals->at(i) != nullptr) {\n","filename":"src\/hotspot\/share\/c1\/c1_CFGPrinter.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,1 +58,1 @@\n-    void block_do(BlockBegin* block) { if (block != NULL) Compilation::current()->cfg_printer_output()->print_block(block); }\n+    void block_do(BlockBegin* block) { if (block != nullptr) Compilation::current()->cfg_printer_output()->print_block(block); }\n@@ -61,1 +61,1 @@\n-  outputStream* output() { assert(_output != NULL, \"\"); return _output; }\n+  outputStream* output() { assert(_output != nullptr, \"\"); return _output; }\n","filename":"src\/hotspot\/share\/c1\/c1_CFGPrinter.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,1 @@\n-  assert(x != NULL, \"value must exist\");\n+  assert(x != nullptr, \"value must exist\");\n@@ -203,1 +203,1 @@\n-  while (max_distance > 0 && v != NULL && v->as_BlockEnd() == NULL) {\n+  while (max_distance > 0 && v != nullptr && v->as_BlockEnd() == nullptr) {\n@@ -207,1 +207,1 @@\n-  return v == NULL;\n+  return v == nullptr;\n@@ -216,1 +216,1 @@\n-    Value value = NULL;\n+    Value value = nullptr;\n@@ -225,1 +225,1 @@\n-    if (value != NULL && in_current_block(conv)) {\n+    if (value != nullptr && in_current_block(conv)) {\n@@ -239,1 +239,1 @@\n-  if ((na = x->array()->as_NewArray()) != NULL) {\n+  if ((na = x->array()->as_NewArray()) != nullptr) {\n@@ -246,3 +246,3 @@\n-    if (na->length() != NULL &&\n-        (length = na->length()->as_Constant()) != NULL) {\n-      assert(length->type()->as_IntConstant() != NULL, \"array length must be integer\");\n+    if (na->length() != nullptr &&\n+        (length = na->length()->as_Constant()) != nullptr) {\n+      assert(length->type()->as_IntConstant() != nullptr, \"array length must be integer\");\n@@ -250,3 +250,3 @@\n-    } else if ((nma = x->array()->as_NewMultiArray()) != NULL &&\n-               (length = nma->dims()->at(0)->as_Constant()) != NULL) {\n-      assert(length->type()->as_IntConstant() != NULL, \"array length must be integer\");\n+    } else if ((nma = x->array()->as_NewMultiArray()) != nullptr &&\n+               (length = nma->dims()->at(0)->as_Constant()) != nullptr) {\n+      assert(length->type()->as_IntConstant() != nullptr, \"array length must be integer\");\n@@ -256,1 +256,1 @@\n-  } else if ((ct = x->array()->as_Constant()) != NULL) {\n+  } else if ((ct = x->array()->as_Constant()) != nullptr) {\n@@ -259,1 +259,1 @@\n-    if (cnst != NULL) {\n+    if (cnst != nullptr) {\n@@ -263,1 +263,1 @@\n-  } else if ((lf = x->array()->as_LoadField()) != NULL) {\n+  } else if ((lf = x->array()->as_LoadField()) != nullptr) {\n@@ -281,1 +281,1 @@\n-  assert(array == NULL || FoldStableValues, \"not enabled\");\n+  assert(array == nullptr || FoldStableValues, \"not enabled\");\n@@ -284,1 +284,1 @@\n-  if (!x->mismatched() && array != NULL && index != NULL) {\n+  if (!x->mismatched() && array != nullptr && index != nullptr) {\n@@ -295,1 +295,1 @@\n-      ValueType* value = NULL;\n+      ValueType* value = nullptr;\n@@ -315,1 +315,1 @@\n-    Value value = NULL;\n+    Value value = nullptr;\n@@ -324,1 +324,1 @@\n-    if (value != NULL && in_current_block(conv)) {\n+    if (value != nullptr && in_current_block(conv)) {\n@@ -482,1 +482,1 @@\n-    if (c != NULL) {\n+    if (c != nullptr) {\n@@ -491,1 +491,1 @@\n-    if (c != NULL) {\n+    if (c != nullptr) {\n@@ -500,1 +500,1 @@\n-    if (c != NULL) {\n+    if (c != nullptr) {\n@@ -509,1 +509,1 @@\n-    if (c != NULL) {\n+    if (c != nullptr) {\n@@ -520,2 +520,2 @@\n-    if (c != NULL && !c->value()->is_null_object()) {\n-      \/\/ ciInstance::java_mirror_type() returns non-NULL only for Java mirrors\n+    if (c != nullptr && !c->value()->is_null_object()) {\n+      \/\/ ciInstance::java_mirror_type() returns non-null only for Java mirrors\n@@ -543,1 +543,1 @@\n-    if (c != NULL && !c->value()->is_null_object()) {\n+    if (c != nullptr && !c->value()->is_null_object()) {\n@@ -554,1 +554,1 @@\n-    if (c != NULL && !c->value()->is_null_object()) {\n+    if (c != nullptr && !c->value()->is_null_object()) {\n@@ -643,1 +643,1 @@\n-  if (x->obj()->as_NewArray() != NULL || x->obj()->as_NewInstance() != NULL) {\n+  if (x->obj()->as_NewArray() != nullptr || x->obj()->as_NewInstance() != nullptr) {\n@@ -669,1 +669,1 @@\n-    if (klass == NULL) {\n+    if (klass == nullptr) {\n@@ -672,1 +672,1 @@\n-    if (klass != NULL && klass->is_loaded()) {\n+    if (klass != nullptr && klass->is_loaded()) {\n@@ -692,1 +692,1 @@\n-    if (exact != NULL && exact->is_loaded() && (obj->as_NewInstance() || obj->as_NewArray())) {\n+    if (exact != nullptr && exact->is_loaded() && (obj->as_NewInstance() || obj->as_NewArray())) {\n@@ -740,1 +740,1 @@\n-    BlockBegin* sux = NULL;\n+    BlockBegin* sux = nullptr;\n@@ -756,1 +756,1 @@\n-    if (x->x()->as_Constant() != NULL) {\n+    if (x->x()->as_Constant() != nullptr) {\n@@ -761,1 +761,1 @@\n-      if (sux != NULL) {\n+      if (sux != nullptr) {\n@@ -766,1 +766,1 @@\n-  } else if (rt->as_IntConstant() != NULL) {\n+  } else if (rt->as_IntConstant() != nullptr) {\n@@ -769,1 +769,1 @@\n-    if (l->as_CompareOp() != NULL) {\n+    if (l->as_CompareOp() != nullptr) {\n@@ -787,2 +787,2 @@\n-        BlockBegin* tsux = NULL;\n-        BlockBegin* fsux = NULL;\n+        BlockBegin* tsux = nullptr;\n+        BlockBegin* fsux = nullptr;\n","filename":"src\/hotspot\/share\/c1\/c1_Canonicalizer.cpp","additions":40,"deletions":40,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-  virtual CodeEmitInfo* info() const             { return NULL; }\n+  virtual CodeEmitInfo* info() const             { return nullptr; }\n@@ -173,1 +173,1 @@\n-    assert(info != NULL, \"must have info\");\n+    assert(info != nullptr, \"must have info\");\n@@ -181,1 +181,1 @@\n-    assert(info != NULL, \"must have info\");\n+    assert(info != nullptr, \"must have info\");\n@@ -426,1 +426,1 @@\n-    , _info(NULL)\n+    , _info(nullptr)\n","filename":"src\/hotspot\/share\/c1\/c1_CodeStubs.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -86,1 +86,1 @@\n-    _log(NULL), _timer(timer)\n+    _log(nullptr), _timer(timer)\n@@ -88,1 +88,1 @@\n-    if (Compilation::current() != NULL) {\n+    if (Compilation::current() != nullptr) {\n@@ -92,1 +92,1 @@\n-    if (_log != NULL) {\n+    if (_log != nullptr) {\n@@ -100,1 +100,1 @@\n-    if (_log != NULL)\n+    if (_log != nullptr)\n@@ -111,1 +111,1 @@\n-  if (_current_instruction != NULL && _last_instruction_printed != _current_instruction) {\n+  if (_current_instruction != nullptr && _last_instruction_printed != _current_instruction) {\n@@ -145,1 +145,1 @@\n-  if (log != NULL) {\n+  if (log != nullptr) {\n@@ -215,1 +215,1 @@\n-    if (_hir->osr_entry() == NULL) {\n+    if (_hir->osr_entry() == nullptr) {\n@@ -485,1 +485,1 @@\n-  if (log() != NULL) \/\/ Print code cache state into compiler log\n+  if (log() != nullptr) \/\/ Print code cache state into compiler log\n@@ -564,1 +564,1 @@\n-, _hir(NULL)\n+, _hir(nullptr)\n@@ -566,2 +566,2 @@\n-, _frame_map(NULL)\n-, _masm(NULL)\n+, _frame_map(nullptr)\n+, _masm(nullptr)\n@@ -577,3 +577,3 @@\n-, _bailout_msg(NULL)\n-, _exception_info_list(NULL)\n-, _allocator(NULL)\n+, _bailout_msg(nullptr)\n+, _exception_info_list(nullptr)\n+, _allocator(nullptr)\n@@ -584,1 +584,1 @@\n-, _current_instruction(NULL)\n+, _current_instruction(nullptr)\n@@ -586,2 +586,2 @@\n-, _last_instruction_printed(NULL)\n-, _cfg_printer_output(NULL)\n+, _last_instruction_printed(nullptr)\n+, _cfg_printer_output(nullptr)\n@@ -610,1 +610,1 @@\n-    if (md != NULL) {\n+    if (md != nullptr) {\n@@ -620,1 +620,1 @@\n-  _env->set_compiler_data(NULL);\n+  _env->set_compiler_data(nullptr);\n@@ -640,1 +640,1 @@\n-  assert(msg != NULL, \"bailout message must exist\");\n+  assert(msg != nullptr, \"bailout message must exist\");\n@@ -649,1 +649,1 @@\n-  if (type != NULL && type->is_loaded() && type->is_instance_klass()) {\n+  if (type != nullptr && type->is_loaded() && type->is_instance_klass()) {\n@@ -651,1 +651,1 @@\n-    assert(ik->exact_klass() == NULL, \"no cha for final klass\");\n+    assert(ik->exact_klass() == nullptr, \"no cha for final klass\");\n@@ -657,1 +657,1 @@\n-  return NULL;\n+  return nullptr;\n","filename":"src\/hotspot\/share\/c1\/c1_Compilation.cpp","additions":23,"deletions":23,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -201,1 +201,1 @@\n-    guarantee(_cfg_printer_output != NULL, \"CFG printer output not initialized\");\n+    guarantee(_cfg_printer_output != nullptr, \"CFG printer output not initialized\");\n@@ -208,1 +208,1 @@\n-  bool bailed_out() const                        { return _bailout_msg != NULL; }\n+  bool bailed_out() const                        { return _bailout_msg != nullptr; }\n","filename":"src\/hotspot\/share\/c1\/c1_Compilation.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -68,1 +68,1 @@\n-    if (buffer_blob == NULL) {\n+    if (buffer_blob == nullptr) {\n@@ -86,1 +86,1 @@\n-  assert (CompilerThread::current()->get_buffer_blob() == NULL, \"Should initialize only once\");\n+  assert (CompilerThread::current()->get_buffer_blob() == nullptr, \"Should initialize only once\");\n@@ -91,1 +91,1 @@\n-  if (buffer_blob != NULL) {\n+  if (buffer_blob != nullptr) {\n@@ -247,1 +247,1 @@\n-  assert(buffer_blob != NULL, \"Must exist\");\n+  assert(buffer_blob != nullptr, \"Must exist\");\n","filename":"src\/hotspot\/share\/c1\/c1_Compiler.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -121,1 +121,1 @@\n-  intptr_t out_preserve = SharedRuntime::c_calling_convention(sig_bt, regs, NULL, sizeargs);\n+  intptr_t out_preserve = SharedRuntime::c_calling_convention(sig_bt, regs, nullptr, sizeargs);\n@@ -241,1 +241,1 @@\n-  if (second != NULL) {\n+  if (second != nullptr) {\n","filename":"src\/hotspot\/share\/c1\/c1_FrameMap.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -229,1 +229,1 @@\n-                            Location* loc, Location* second = NULL) const;\n+                            Location* loc, Location* second = nullptr) const;\n","filename":"src\/hotspot\/share\/c1\/c1_FrameMap.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -120,1 +120,1 @@\n- , _bci2block(new BlockList(scope->method()->code_size(), NULL))\n+ , _bci2block(new BlockList(scope->method()->code_size(), nullptr))\n@@ -151,2 +151,2 @@\n-  BlockBegin* std_entry = make_block_at(0, NULL);\n-  if (scope()->caller() == NULL) {\n+  BlockBegin* std_entry = make_block_at(0, nullptr);\n+  if (scope()->caller() == nullptr) {\n@@ -156,1 +156,1 @@\n-    BlockBegin* osr_entry = make_block_at(osr_bci, NULL);\n+    BlockBegin* osr_entry = make_block_at(osr_bci, nullptr);\n@@ -165,1 +165,1 @@\n-    BlockBegin* entry = make_block_at(h->handler_bci(), NULL);\n+    BlockBegin* entry = make_block_at(h->handler_bci(), nullptr);\n@@ -176,1 +176,1 @@\n-  if (block == NULL) {\n+  if (block == nullptr) {\n@@ -183,1 +183,1 @@\n-    assert(predecessor == NULL || predecessor->bci() < cur_bci, \"targets for backward branches must already exist\");\n+    assert(predecessor == nullptr || predecessor->bci() < cur_bci, \"targets for backward branches must already exist\");\n@@ -186,1 +186,1 @@\n-  if (predecessor != NULL) {\n+  if (predecessor != nullptr) {\n@@ -218,1 +218,1 @@\n-      assert(entry != NULL && entry == _bci2block->at(h->handler_bci()), \"entry must be set\");\n+      assert(entry != nullptr && entry == _bci2block->at(h->handler_bci()), \"entry must be set\");\n@@ -249,1 +249,1 @@\n-  BlockBegin* current = NULL;\n+  BlockBegin* current = nullptr;\n@@ -266,1 +266,1 @@\n-    assert(current != NULL, \"must have current block\");\n+    assert(current != nullptr, \"must have current block\");\n@@ -310,1 +310,1 @@\n-        current = NULL;\n+        current = nullptr;\n@@ -333,1 +333,1 @@\n-        current = NULL;\n+        current = nullptr;\n@@ -338,1 +338,1 @@\n-        current = NULL;\n+        current = nullptr;\n@@ -343,1 +343,1 @@\n-        current = NULL;\n+        current = nullptr;\n@@ -348,1 +348,1 @@\n-        current = NULL;\n+        current = nullptr;\n@@ -353,1 +353,1 @@\n-        current = NULL;\n+        current = nullptr;\n@@ -364,1 +364,1 @@\n-        current = NULL;\n+        current = nullptr;\n@@ -376,1 +376,1 @@\n-        current = NULL;\n+        current = nullptr;\n@@ -579,1 +579,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -586,1 +586,1 @@\n-    _values.at_put_grow(offset, value, NULL);\n+    _values.at_put_grow(offset, value, nullptr);\n@@ -631,1 +631,1 @@\n-        if (buf->at(field) == NULL && is_default_value(value)) {\n+        if (buf->at(field) == nullptr && is_default_value(value)) {\n@@ -638,1 +638,1 @@\n-          return NULL;\n+          return nullptr;\n@@ -643,1 +643,1 @@\n-        _objects.at_put_grow(offset, object, NULL);\n+        _objects.at_put_grow(offset, object, nullptr);\n@@ -695,1 +695,1 @@\n-      Value result = NULL;\n+      Value result = nullptr;\n@@ -699,1 +699,1 @@\n-      } else if (_objects.at_grow(offset, NULL) == object) {\n+      } else if (_objects.at_grow(offset, nullptr) == object) {\n@@ -702,1 +702,1 @@\n-      if (result != NULL) {\n+      if (result != nullptr) {\n@@ -720,1 +720,1 @@\n-    if (_fields.at_grow(index, NULL) == NULL) {\n+    if (_fields.at_grow(index, nullptr) == nullptr) {\n@@ -754,2 +754,2 @@\n-  , _bci2block(NULL)\n-  , _scope(NULL)\n+  , _bci2block(nullptr)\n+  , _scope(nullptr)\n@@ -757,2 +757,2 @@\n-  , _stream(NULL)\n-  , _work_list(NULL)\n+  , _stream(nullptr)\n+  , _work_list(nullptr)\n@@ -760,1 +760,1 @@\n-  , _continuation(NULL)\n+  , _continuation(nullptr)\n@@ -762,1 +762,1 @@\n-  , _jsr_xhandlers(NULL)\n+  , _jsr_xhandlers(nullptr)\n@@ -764,3 +764,3 @@\n-  , _cleanup_block(NULL)\n-  , _cleanup_return_prev(NULL)\n-  , _cleanup_state(NULL)\n+  , _cleanup_block(nullptr)\n+  , _cleanup_return_prev(nullptr)\n+  , _cleanup_state(nullptr)\n@@ -769,1 +769,1 @@\n-  if (parent != NULL) {\n+  if (parent != nullptr) {\n@@ -795,1 +795,1 @@\n-    if (block != NULL && block == parent()->bci2block()->at(bci)) {\n+    if (block != nullptr && block == parent()->bci2block()->at(bci)) {\n@@ -826,1 +826,1 @@\n-  if (_jsr_xhandlers == NULL) {\n+  if (_jsr_xhandlers == nullptr) {\n@@ -838,1 +838,1 @@\n-  if (parent() != NULL) {\n+  if (parent() != nullptr) {\n@@ -855,1 +855,1 @@\n-  if (_work_list == NULL) {\n+  if (_work_list == nullptr) {\n@@ -900,1 +900,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -907,1 +907,1 @@\n-  return (_work_list == NULL || _work_list->length() == 0);\n+  return (_work_list == nullptr || _work_list->length() == 0);\n@@ -956,1 +956,1 @@\n-    ValueStack* patch_state = NULL;\n+    ValueStack* patch_state = nullptr;\n@@ -989,1 +989,1 @@\n-    if (patch_state != NULL) {\n+    if (patch_state != nullptr) {\n@@ -1000,1 +1000,1 @@\n-    if (patch_state != NULL) {\n+    if (patch_state != nullptr) {\n@@ -1024,1 +1024,1 @@\n-  assert(x != NULL && !x->type()->is_illegal(), \"access of illegal local variable\");\n+  assert(x != nullptr && !x->type()->is_illegal(), \"access of illegal local variable\");\n@@ -1048,1 +1048,1 @@\n-           cur_scope_data != NULL && cur_scope_data->parsing_jsr() && cur_scope_data->scope() == scope();\n+           cur_scope_data != nullptr && cur_scope_data->parsing_jsr() && cur_scope_data->scope() == scope();\n@@ -1069,1 +1069,1 @@\n-  Value length = NULL;\n+  Value length = nullptr;\n@@ -1071,1 +1071,1 @@\n-      (array->as_Constant() != NULL) ||\n+      (array->as_Constant() != nullptr) ||\n@@ -1088,1 +1088,1 @@\n-  Value length = NULL;\n+  Value length = nullptr;\n@@ -1090,1 +1090,1 @@\n-      (array->as_Constant() != NULL) ||\n+      (array->as_Constant() != nullptr) ||\n@@ -1098,1 +1098,1 @@\n-  if (array_type != NULL) {\n+  if (array_type != nullptr) {\n@@ -1232,1 +1232,1 @@\n-    if (s1 != NULL) {\n+    if (s1 != nullptr) {\n@@ -1235,1 +1235,1 @@\n-      if (l != NULL && l->op() == Bytecodes::_ishl) {\n+      if (l != nullptr && l->op() == Bytecodes::_ishl) {\n@@ -1238,1 +1238,1 @@\n-        if (s0 != NULL) {\n+        if (s0 != nullptr) {\n@@ -1314,1 +1314,1 @@\n-  Instruction *i = append(new If(x, cond, false, y, tsux, fsux, (is_bb || compilation()->is_optimistic()) ? state_before : NULL, is_bb));\n+  Instruction *i = append(new If(x, cond, false, y, tsux, fsux, (is_bb || compilation()->is_optimistic()) ? state_before : nullptr, is_bb));\n@@ -1316,1 +1316,1 @@\n-  assert(i->as_Goto() == NULL ||\n+  assert(i->as_Goto() == nullptr ||\n@@ -1323,1 +1323,1 @@\n-    if (if_node != NULL) {\n+    if (if_node != nullptr) {\n@@ -1341,1 +1341,1 @@\n-    if (goto_node != NULL) {\n+    if (goto_node != nullptr) {\n@@ -1392,1 +1392,1 @@\n-       cur_scope_data != NULL && cur_scope_data->parsing_jsr() && cur_scope_data->scope() == scope();\n+       cur_scope_data != nullptr && cur_scope_data->parsing_jsr() && cur_scope_data->scope() == scope();\n@@ -1435,1 +1435,1 @@\n-    BlockList* sux = new BlockList(l + 1, NULL);\n+    BlockList* sux = new BlockList(l + 1, nullptr);\n@@ -1481,1 +1481,1 @@\n-    BlockList* sux = new BlockList(l + 1, NULL);\n+    BlockList* sux = new BlockList(l + 1, nullptr);\n@@ -1516,1 +1516,1 @@\n-  assert(receiver != NULL, \"must have a receiver\");\n+  assert(receiver != nullptr, \"must have a receiver\");\n@@ -1519,1 +1519,1 @@\n-  if (exact_type == NULL &&\n+  if (exact_type == nullptr &&\n@@ -1536,1 +1536,1 @@\n-  if (exact_type != NULL) {\n+  if (exact_type != nullptr) {\n@@ -1538,1 +1538,1 @@\n-  } else if (declared_type != NULL) {\n+  } else if (declared_type != nullptr) {\n@@ -1606,1 +1606,1 @@\n-  if (continuation() != NULL) {\n+  if (continuation() != nullptr) {\n@@ -1610,1 +1610,1 @@\n-    if (x != NULL  && !ignore_return) {\n+    if (x != nullptr  && !ignore_return) {\n@@ -1615,1 +1615,1 @@\n-        if (declared_ret_type->is_klass() && x->exact_type() == NULL &&\n+        if (declared_ret_type->is_klass() && x->exact_type() == nullptr &&\n@@ -1646,1 +1646,1 @@\n-    if (x != NULL) {\n+    if (x != nullptr) {\n@@ -1691,1 +1691,1 @@\n-  if (!field_value.is_valid())  return NULL;\n+  if (!field_value.is_valid())  return nullptr;\n@@ -1710,1 +1710,1 @@\n-      return NULL; \/\/ Not a constant.\n+      return nullptr; \/\/ Not a constant.\n@@ -1727,1 +1727,1 @@\n-  ValueStack* state_before = NULL;\n+  ValueStack* state_before = nullptr;\n@@ -1734,1 +1734,1 @@\n-  Value obj = NULL;\n+  Value obj = nullptr;\n@@ -1736,1 +1736,1 @@\n-    if (state_before != NULL) {\n+    if (state_before != nullptr) {\n@@ -1759,1 +1759,1 @@\n-      Value constant = NULL;\n+      Value constant = nullptr;\n@@ -1766,1 +1766,1 @@\n-      if (constant != NULL) {\n+      if (constant != nullptr) {\n@@ -1769,1 +1769,1 @@\n-        if (state_before == NULL) {\n+        if (state_before == nullptr) {\n@@ -1779,1 +1779,1 @@\n-      if (state_before == NULL) {\n+      if (state_before == nullptr) {\n@@ -1791,1 +1791,1 @@\n-      Value constant = NULL;\n+      Value constant = nullptr;\n@@ -1811,1 +1811,1 @@\n-      if (constant != NULL) {\n+      if (constant != nullptr) {\n@@ -1814,1 +1814,1 @@\n-        if (state_before == NULL) {\n+        if (state_before == nullptr) {\n@@ -1848,1 +1848,1 @@\n-      if (state_before == NULL) {\n+      if (state_before == nullptr) {\n@@ -1857,1 +1857,1 @@\n-      if (store != NULL) {\n+      if (store != nullptr) {\n@@ -1881,1 +1881,1 @@\n-    if (data != NULL && (data->is_CallTypeData() || data->is_VirtualCallTypeData())) {\n+    if (data != nullptr && (data->is_CallTypeData() || data->is_VirtualCallTypeData())) {\n@@ -1886,2 +1886,2 @@\n-  if (profile_parameters() && target != NULL) {\n-    if (target->method_data() != NULL && target->method_data()->parameters_type_data() != NULL) {\n+  if (profile_parameters() && target != nullptr) {\n+    if (target->method_data() != nullptr && target->method_data()->parameters_type_data() != nullptr) {\n@@ -1897,1 +1897,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1903,1 +1903,1 @@\n-  ciSignature* declared_signature = NULL;\n+  ciSignature* declared_signature = nullptr;\n@@ -1913,2 +1913,2 @@\n-  if (obj_args == NULL) {\n-    return NULL;\n+  if (obj_args == nullptr) {\n+    return nullptr;\n@@ -1930,1 +1930,1 @@\n-  ciSignature* declared_signature = NULL;\n+  ciSignature* declared_signature = nullptr;\n@@ -1934,1 +1934,1 @@\n-  assert(declared_signature != NULL, \"cannot be null\");\n+  assert(declared_signature != nullptr, \"cannot be null\");\n@@ -1947,1 +1947,1 @@\n-  if (log != NULL)\n+  if (log != nullptr)\n@@ -2013,3 +2013,3 @@\n-  ciMethod* cha_monomorphic_target = NULL;\n-  ciMethod* exact_target = NULL;\n-  Value better_receiver = NULL;\n+  ciMethod* cha_monomorphic_target = nullptr;\n+  ciMethod* exact_target = nullptr;\n+  Value better_receiver = nullptr;\n@@ -2021,2 +2021,2 @@\n-    Value receiver = NULL;\n-    ciInstanceKlass* receiver_klass = NULL;\n+    Value receiver = nullptr;\n+    ciInstanceKlass* receiver_klass = nullptr;\n@@ -2029,1 +2029,1 @@\n-      if (type != NULL && type->is_loaded() &&\n+      if (type != nullptr && type->is_loaded() &&\n@@ -2034,1 +2034,1 @@\n-      if (type == NULL) {\n+      if (type == nullptr) {\n@@ -2036,1 +2036,1 @@\n-        if (type != NULL && type->is_loaded() &&\n+        if (type != nullptr && type->is_loaded() &&\n@@ -2048,1 +2048,1 @@\n-    if (receiver_klass != NULL && type_is_exact &&\n+    if (receiver_klass != nullptr && type_is_exact &&\n@@ -2053,1 +2053,1 @@\n-      if (exact_target != NULL) {\n+      if (exact_target != nullptr) {\n@@ -2058,1 +2058,1 @@\n-    if (receiver_klass != NULL &&\n+    if (receiver_klass != nullptr &&\n@@ -2068,1 +2068,1 @@\n-    } else if (code == Bytecodes::_invokeinterface && callee_holder->is_loaded() && receiver != NULL) {\n+    } else if (code == Bytecodes::_invokeinterface && callee_holder->is_loaded() && receiver != nullptr) {\n@@ -2086,1 +2086,1 @@\n-      if (singleton != NULL) {\n+      if (singleton != nullptr) {\n@@ -2089,1 +2089,1 @@\n-        if (cha_monomorphic_target != NULL) {\n+        if (cha_monomorphic_target != nullptr) {\n@@ -2105,1 +2105,1 @@\n-            cha_monomorphic_target = NULL; \/\/ subtype check against Object is useless\n+            cha_monomorphic_target = nullptr; \/\/ subtype check against Object is useless\n@@ -2112,1 +2112,1 @@\n-  if (cha_monomorphic_target != NULL) {\n+  if (cha_monomorphic_target != nullptr) {\n@@ -2136,2 +2136,2 @@\n-      ciMethod* inline_target = (cha_monomorphic_target != NULL) ? cha_monomorphic_target : target;\n-      bool holder_known = (cha_monomorphic_target != NULL) || (exact_target != NULL);\n+      ciMethod* inline_target = (cha_monomorphic_target != nullptr) ? cha_monomorphic_target : target;\n+      bool holder_known = (cha_monomorphic_target != nullptr) || (exact_target != nullptr);\n@@ -2180,1 +2180,1 @@\n-  Value recv = has_receiver ? apop() : NULL;\n+  Value recv = has_receiver ? apop() : nullptr;\n@@ -2199,1 +2199,1 @@\n-    if (recv != NULL) {\n+    if (recv != nullptr) {\n@@ -2208,3 +2208,3 @@\n-        assert(cha_monomorphic_target == NULL || exact_target == NULL, \"both can not be set\");\n-        ciKlass* target_klass = NULL;\n-        if (cha_monomorphic_target != NULL) {\n+        assert(cha_monomorphic_target == nullptr || exact_target == nullptr, \"both can not be set\");\n+        ciKlass* target_klass = nullptr;\n+        if (cha_monomorphic_target != nullptr) {\n@@ -2212,1 +2212,1 @@\n-        } else if (exact_target != NULL) {\n+        } else if (exact_target != nullptr) {\n@@ -2215,1 +2215,1 @@\n-        profile_call(target, recv, target_klass, collect_args_for_profiling(args, NULL, false), false);\n+        profile_call(target, recv, target_klass, collect_args_for_profiling(args, nullptr, false), false);\n@@ -2333,1 +2333,1 @@\n-  Values* dims = new Values(dimensions, dimensions, NULL);\n+  Values* dims = new Values(dimensions, dimensions, nullptr);\n@@ -2363,3 +2363,3 @@\n-          fp_value->as_Constant() == NULL &&\n-          fp_value->as_Local() == NULL &&       \/\/ method parameters need no rounding\n-          fp_value->as_RoundFP() == NULL) {\n+          fp_value->as_Constant() == nullptr &&\n+          fp_value->as_Local() == nullptr &&       \/\/ method parameters need no rounding\n+          fp_value->as_RoundFP() == nullptr) {\n@@ -2400,1 +2400,1 @@\n-  assert(i1->next() == NULL, \"shouldn't already be linked\");\n+  assert(i1->next() == nullptr, \"shouldn't already be linked\");\n@@ -2422,1 +2422,1 @@\n-  if (s != NULL) {\n+  if (s != nullptr) {\n@@ -2425,1 +2425,1 @@\n-      if (s->as_Invoke() != NULL || (intrinsic && !intrinsic->preserves_state())) {\n+      if (s->as_Invoke() != nullptr || (intrinsic && !intrinsic->preserves_state())) {\n@@ -2435,1 +2435,1 @@\n-    assert(i1->exception_state() != NULL || !i1->needs_exception_state() || bailed_out(), \"handle_exception must set exception state\");\n+    assert(i1->exception_state() != nullptr || !i1->needs_exception_state() || bailed_out(), \"handle_exception must set exception state\");\n@@ -2442,1 +2442,1 @@\n-  assert(instr->as_StateSplit() == NULL || instr->as_BlockEnd() != NULL, \"wrong append used\");\n+  assert(instr->as_StateSplit() == nullptr || instr->as_BlockEnd() != nullptr, \"wrong append used\");\n@@ -2453,1 +2453,1 @@\n-  if (value->as_NewArray() != NULL || value->as_NewInstance() != NULL) {\n+  if (value->as_NewArray() != nullptr || value->as_NewInstance() != nullptr) {\n@@ -2473,2 +2473,2 @@\n-  if (!has_handler() && (!instruction->needs_exception_state() || instruction->exception_state() != NULL)) {\n-    assert(instruction->exception_state() == NULL\n+  if (!has_handler() && (!instruction->needs_exception_state() || instruction->exception_state() != nullptr)) {\n+    assert(instruction->exception_state() == nullptr\n@@ -2484,1 +2484,1 @@\n-  ValueStack* prev_state = NULL;\n+  ValueStack* prev_state = nullptr;\n@@ -2487,1 +2487,1 @@\n-  assert(cur_state != NULL, \"state_before must be set\");\n+  assert(cur_state != nullptr, \"state_before must be set\");\n@@ -2514,1 +2514,1 @@\n-        assert(entry->state() == NULL || cur_state->total_locks_size() == entry->state()->total_locks_size(), \"locks do not match\");\n+        assert(entry->state() == nullptr || cur_state->total_locks_size() == entry->state()->total_locks_size(), \"locks do not match\");\n@@ -2520,1 +2520,1 @@\n-        if (instruction->exception_state() == NULL) {\n+        if (instruction->exception_state() == nullptr) {\n@@ -2572,1 +2572,1 @@\n-      if (prev_state != NULL) {\n+      if (prev_state != nullptr) {\n@@ -2575,1 +2575,1 @@\n-      if (instruction->exception_state() == NULL) {\n+      if (instruction->exception_state() == nullptr) {\n@@ -2596,1 +2596,1 @@\n-  } while (cur_scope_data != NULL);\n+  } while (cur_scope_data != nullptr);\n@@ -2623,1 +2623,1 @@\n-  if (phi == NULL) {\n+  if (phi == nullptr) {\n@@ -2644,1 +2644,1 @@\n-    Value subst = NULL;\n+    Value subst = nullptr;\n@@ -2648,1 +2648,1 @@\n-      assert(opd != NULL, \"Operand must exist!\");\n+      assert(opd != nullptr, \"Operand must exist!\");\n@@ -2658,1 +2658,1 @@\n-      assert(new_opd != NULL, \"Simplified operand must exist!\");\n+      assert(new_opd != nullptr, \"Simplified operand must exist!\");\n@@ -2661,1 +2661,1 @@\n-        if (subst == NULL) {\n+        if (subst == nullptr) {\n@@ -2673,1 +2673,1 @@\n-    assert(subst != NULL, \"illegal phi function\");\n+    assert(subst != nullptr, \"illegal phi function\");\n@@ -2702,1 +2702,1 @@\n-    assert(phi == NULL || phi->block() != b, \"must not have phi function to simplify in caller state\");\n+    assert(phi == nullptr || phi->block() != b, \"must not have phi function to simplify in caller state\");\n@@ -2737,1 +2737,1 @@\n-  assert(state() != NULL, \"ValueStack missing!\");\n+  assert(state() != nullptr, \"ValueStack missing!\");\n@@ -2747,1 +2747,1 @@\n-  if (block()->is_set(BlockBegin::exception_entry_flag) && block()->next() == NULL) {\n+  if (block()->is_set(BlockBegin::exception_entry_flag) && block()->next() == nullptr) {\n@@ -2754,1 +2754,1 @@\n-  while (!bailed_out() && last()->as_BlockEnd() == NULL &&\n+  while (!bailed_out() && last()->as_BlockEnd() == nullptr &&\n@@ -2756,1 +2756,1 @@\n-         (block_at(s.cur_bci()) == NULL || block_at(s.cur_bci()) == block())) {\n+         (block_at(s.cur_bci()) == nullptr || block_at(s.cur_bci()) == block())) {\n@@ -2759,1 +2759,1 @@\n-    if (log != NULL)\n+    if (log != nullptr)\n@@ -2954,1 +2954,1 @@\n-      case Bytecodes::_return         : method_return(NULL  , ignore_return); break;\n+      case Bytecodes::_return         : method_return(nullptr, ignore_return); break;\n@@ -2979,1 +2979,1 @@\n-      case Bytecodes::_breakpoint     : BAILOUT_(\"concurrent setting of breakpoint\", NULL);\n+      case Bytecodes::_breakpoint     : BAILOUT_(\"concurrent setting of breakpoint\", nullptr);\n@@ -2983,1 +2983,1 @@\n-    if (log != NULL)\n+    if (log != nullptr)\n@@ -2990,1 +2990,1 @@\n-  CHECK_BAILOUT_(NULL);\n+  CHECK_BAILOUT_(nullptr);\n@@ -2999,1 +2999,1 @@\n-  if (end == NULL) {\n+  if (end == nullptr) {\n@@ -3006,2 +3006,2 @@\n-  assert(end->state() != NULL, \"state must already be present\");\n-  assert(end->as_Return() == NULL || end->as_Throw() == NULL || end->state()->stack_size() == 0, \"stack not needed for return and throw\");\n+  assert(end->state() != nullptr, \"state must already be present\");\n+  assert(end->as_Return() == nullptr || end->as_Throw() == nullptr || end->state()->stack_size() == 0, \"stack not needed for return and throw\");\n@@ -3017,1 +3017,1 @@\n-    if (!sux->try_merge(end->state(), compilation()->has_irreducible_loops())) BAILOUT_(\"block join failed\", NULL);\n+    if (!sux->try_merge(end->state(), compilation()->has_irreducible_loops())) BAILOUT_(\"block join failed\", nullptr);\n@@ -3021,1 +3021,1 @@\n-  scope_data()->set_stream(NULL);\n+  scope_data()->set_stream(nullptr);\n@@ -3035,1 +3035,1 @@\n-      while ((b = scope_data()->remove_from_work_list()) != NULL) {\n+      while ((b = scope_data()->remove_from_work_list()) != nullptr) {\n@@ -3169,1 +3169,1 @@\n-  if (base->std_entry()->state() == NULL) {\n+  if (base->std_entry()->state() == nullptr) {\n@@ -3174,1 +3174,1 @@\n-  assert(base->std_entry()->state() != NULL, \"\");\n+  assert(base->std_entry()->state() != nullptr, \"\");\n@@ -3193,1 +3193,1 @@\n-  assert(target != NULL && target->is_set(BlockBegin::osr_entry_flag), \"must be there\");\n+  assert(target != nullptr && target->is_set(BlockBegin::osr_entry_flag), \"must be there\");\n@@ -3249,1 +3249,1 @@\n-  assert(state->caller_state() == NULL, \"should be top scope\");\n+  assert(state->caller_state() == nullptr, \"should be top scope\");\n@@ -3256,1 +3256,1 @@\n-  scope_data()->set_stream(NULL);\n+  scope_data()->set_stream(nullptr);\n@@ -3261,1 +3261,1 @@\n-  ValueStack* state = new ValueStack(scope(), NULL);\n+  ValueStack* state = new ValueStack(scope(), nullptr);\n@@ -3285,1 +3285,1 @@\n-    state->lock(NULL);\n+    state->lock(nullptr);\n@@ -3293,1 +3293,1 @@\n-  : _scope_data(NULL)\n+  : _scope_data(nullptr)\n@@ -3296,1 +3296,1 @@\n-  , _inline_bailout_msg(NULL)\n+  , _inline_bailout_msg(nullptr)\n@@ -3298,1 +3298,1 @@\n-  , _osr_entry(NULL)\n+  , _osr_entry(nullptr)\n@@ -3421,1 +3421,1 @@\n-  \/\/All blocks reachable from start_block have _end != NULL\n+  \/\/ For all blocks reachable from start_block: _end must be non-null\n@@ -3428,2 +3428,2 @@\n-      assert(current != NULL, \"Should not happen.\");\n-      assert(current->end() != NULL, \"All blocks reachable from start_block should have end() != NULL.\");\n+      assert(current != nullptr, \"Should not happen.\");\n+      assert(current->end() != nullptr, \"All blocks reachable from start_block should have end() != nullptr.\");\n@@ -3481,1 +3481,1 @@\n-  if (!has_handler()) return NULL;\n+  if (!has_handler()) return nullptr;\n@@ -3487,1 +3487,1 @@\n-  if (s == NULL) {\n+  if (s == nullptr) {\n@@ -3499,1 +3499,1 @@\n-  for (IRScope* s = scope(); s != NULL; s = s->caller()) {\n+  for (IRScope* s = scope(); s != nullptr; s = s->caller()) {\n@@ -3509,1 +3509,1 @@\n-  const char* msg = NULL;\n+  const char* msg = nullptr;\n@@ -3516,1 +3516,1 @@\n-  if (msg != NULL) {\n+  if (msg != nullptr) {\n@@ -3547,1 +3547,1 @@\n-  if (msg != NULL) {\n+  if (msg != nullptr) {\n@@ -3577,1 +3577,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -3580,1 +3580,1 @@\n-\/\/ negative filter: should callee NOT be inlined?  returns NULL, ok to inline, or rejection msg\n+\/\/ negative filter: should callee NOT be inlined?  returns null, ok to inline, or rejection msg\n@@ -3584,1 +3584,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -3665,1 +3665,1 @@\n-        Value recv = NULL;\n+        Value recv = nullptr;\n@@ -3670,1 +3670,1 @@\n-        profile_call(callee, recv, NULL, collect_args_for_profiling(args, callee, true), true);\n+        profile_call(callee, recv, nullptr, collect_args_for_profiling(args, callee, true), true);\n@@ -3719,1 +3719,1 @@\n-  assert(cont != NULL, \"continuation must exist (BlockListBuilder starts a new block after a jsr\");\n+  assert(cont != nullptr, \"continuation must exist (BlockListBuilder starts a new block after a jsr\");\n@@ -3732,1 +3732,1 @@\n-  assert(jsr_start_block != NULL, \"jsr start block must exist\");\n+  assert(jsr_start_block != nullptr, \"jsr start block must exist\");\n@@ -3736,1 +3736,1 @@\n-  assert(jsr_start_block->state() == NULL, \"should have fresh jsr starting block\");\n+  assert(jsr_start_block->state() == nullptr, \"should have fresh jsr starting block\");\n@@ -3743,1 +3743,1 @@\n-  scope_data()->set_stream(NULL);\n+  scope_data()->set_stream(nullptr);\n@@ -3758,1 +3758,1 @@\n-  if (cont->state() != NULL) {\n+  if (cont->state() != nullptr) {\n@@ -3786,1 +3786,1 @@\n-  assert(lock != NULL && sync_handler != NULL, \"lock or handler missing\");\n+  assert(lock != nullptr && sync_handler != nullptr, \"lock or handler missing\");\n@@ -3789,1 +3789,1 @@\n-  assert(_last->as_MonitorEnter() != NULL, \"monitor enter expected\");\n+  assert(_last->as_MonitorEnter() != nullptr, \"monitor enter expected\");\n@@ -3814,1 +3814,1 @@\n-  assert(sync_handler != NULL, \"handler missing\");\n+  assert(sync_handler != nullptr, \"handler missing\");\n@@ -3817,1 +3817,1 @@\n-  assert(lock != NULL || default_handler, \"lock or handler missing\");\n+  assert(lock != nullptr || default_handler, \"lock or handler missing\");\n@@ -3893,1 +3893,1 @@\n-  Value recv = NULL;\n+  Value recv = nullptr;\n@@ -3931,1 +3931,1 @@\n-      while (top->caller() != NULL) {\n+      while (top->caller() != nullptr) {\n@@ -3970,1 +3970,1 @@\n-      if (obj_args != NULL) {\n+      if (obj_args != nullptr) {\n@@ -3982,1 +3982,1 @@\n-      profile_call(callee, recv, holder_known ? callee->holder() : NULL, obj_args, true);\n+      profile_call(callee, recv, holder_known ? callee->holder() : nullptr, obj_args, true);\n@@ -3993,1 +3993,1 @@\n-  if (cont == NULL) {\n+  if (cont == nullptr) {\n@@ -4035,2 +4035,2 @@\n-  Value lock = NULL;\n-  BlockBegin* sync_handler = NULL;\n+  Value lock = nullptr;\n+  BlockBegin* sync_handler = nullptr;\n@@ -4057,1 +4057,1 @@\n-  if (callee_start_block != NULL) {\n+  if (callee_start_block != nullptr) {\n@@ -4072,1 +4072,1 @@\n-  scope_data()->set_stream(NULL);\n+  scope_data()->set_stream(nullptr);\n@@ -4076,1 +4076,1 @@\n-  if (log != NULL) log->head(\"parse method='%d'\", log->identify(callee));\n+  if (log != nullptr) log->head(\"parse method='%d'\", log->identify(callee));\n@@ -4080,1 +4080,1 @@\n-  iterate_all_blocks(callee_start_block == NULL);\n+  iterate_all_blocks(callee_start_block == nullptr);\n@@ -4082,1 +4082,1 @@\n-  if (log != NULL) log->done(\"parse\");\n+  if (log != nullptr) log->done(\"parse\");\n@@ -4131,1 +4131,1 @@\n-  if (callee->is_synchronized() && sync_handler->state() != NULL) {\n+  if (callee->is_synchronized() && sync_handler->state() != nullptr) {\n@@ -4208,1 +4208,1 @@\n-            if (obj->exact_type() == NULL &&\n+            if (obj->exact_type() == nullptr &&\n@@ -4221,1 +4221,1 @@\n-              if (obj->exact_type() == NULL &&\n+              if (obj->exact_type() == nullptr &&\n@@ -4260,1 +4260,1 @@\n-  assert(msg != NULL, \"inline bailout msg must exist\");\n+  assert(msg != nullptr, \"inline bailout msg must exist\");\n@@ -4266,1 +4266,1 @@\n-  _inline_bailout_msg = NULL;\n+  _inline_bailout_msg = nullptr;\n@@ -4271,1 +4271,1 @@\n-  ScopeData* data = new ScopeData(NULL);\n+  ScopeData* data = new ScopeData(nullptr);\n@@ -4289,1 +4289,1 @@\n-    blb.bci2block()->at_put(0, NULL);\n+    blb.bci2block()->at_put(0, nullptr);\n@@ -4414,1 +4414,1 @@\n-    Instruction* store = append(new StoreIndexed(array, index, NULL, T_CHAR, value, state_before, false, true));\n+    Instruction* store = append(new StoreIndexed(array, index, nullptr, T_CHAR, value, state_before, false, true));\n@@ -4418,1 +4418,1 @@\n-    Instruction* load = append(new LoadIndexed(array, index, NULL, T_CHAR, state_before, true));\n+    Instruction* load = append(new LoadIndexed(array, index, nullptr, T_CHAR, state_before, true));\n@@ -4426,2 +4426,2 @@\n-  if (log != NULL) {\n-    assert(msg != NULL, \"inlining msg should not be null!\");\n+  if (log != nullptr) {\n+    assert(msg != nullptr, \"inlining msg should not be null!\");\n@@ -4471,1 +4471,1 @@\n-  assert(known_holder == NULL || (known_holder->is_instance_klass() &&\n+  assert(known_holder == nullptr || (known_holder->is_instance_klass() &&\n@@ -4474,2 +4474,2 @@\n-  if (known_holder != NULL) {\n-    if (known_holder->exact_klass() == NULL) {\n+  if (known_holder != nullptr) {\n+    if (known_holder->exact_klass() == nullptr) {\n@@ -4484,2 +4484,2 @@\n-  assert((m == NULL) == (invoke_bci < 0), \"invalid method and invalid bci together\");\n-  if (m == NULL) {\n+  assert((m == nullptr) == (invoke_bci < 0), \"invalid method and invalid bci together\");\n+  if (m == nullptr) {\n@@ -4493,1 +4493,1 @@\n-  if (data != NULL && (data->is_CallTypeData() || data->is_VirtualCallTypeData())) {\n+  if (data != nullptr && (data->is_CallTypeData() || data->is_VirtualCallTypeData())) {\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.cpp","additions":224,"deletions":224,"binary":false,"changes":448,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -131,1 +131,1 @@\n-    \/\/ How to remove the next block to be parsed; returns NULL if none left\n+    \/\/ How to remove the next block to be parsed; returns null if none left\n@@ -240,1 +240,1 @@\n-  void arithmetic_op(ValueType* type, Bytecodes::Code code, ValueStack* state_before = NULL);\n+  void arithmetic_op(ValueType* type, Bytecodes::Code code, ValueStack* state_before = nullptr);\n@@ -312,1 +312,1 @@\n-  ValueStack* copy_state_if_bb(bool is_bb) { return (is_bb || compilation()->is_optimistic()) ? copy_state_before() : NULL; }\n+  ValueStack* copy_state_if_bb(bool is_bb) { return (is_bb || compilation()->is_optimistic()) ? copy_state_before() : nullptr; }\n@@ -353,1 +353,1 @@\n-  bool try_inline(           ciMethod* callee, bool holder_known, bool ignore_return, Bytecodes::Code bc = Bytecodes::_illegal, Value receiver = NULL);\n+  bool try_inline(           ciMethod* callee, bool holder_known, bool ignore_return, Bytecodes::Code bc = Bytecodes::_illegal, Value receiver = nullptr);\n@@ -355,1 +355,1 @@\n-  bool try_inline_full(      ciMethod* callee, bool holder_known, bool ignore_return, Bytecodes::Code bc = Bytecodes::_illegal, Value receiver = NULL);\n+  bool try_inline_full(      ciMethod* callee, bool holder_known, bool ignore_return, Bytecodes::Code bc = Bytecodes::_illegal, Value receiver = nullptr);\n@@ -386,1 +386,1 @@\n-  void profile_return_type(Value ret, ciMethod* callee, ciMethod* m = NULL, int bci = -1);\n+  void profile_return_type(Value ret, ciMethod* callee, ciMethod* m = nullptr, int bci = -1);\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.hpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -105,1 +105,1 @@\n-  if (others == NULL) return false;\n+  if (others == nullptr) return false;\n@@ -130,1 +130,1 @@\n-  if (compilation->bailed_out()) return NULL;\n+  if (compilation->bailed_out()) return nullptr;\n@@ -141,1 +141,1 @@\n-  _level              = caller == NULL ?  0 : caller->level() + 1;\n+  _level              = caller == nullptr ?  0 : caller->level() + 1;\n@@ -149,1 +149,1 @@\n-  _start              = NULL;\n+  _start              = nullptr;\n@@ -176,1 +176,1 @@\n-  if (cur_method != NULL && cur_bci != SynchronizationEntryBCI) {\n+  if (cur_method != nullptr && cur_bci != SynchronizationEntryBCI) {\n@@ -188,1 +188,1 @@\n-  : _scope_debug_info(NULL)\n+  : _scope_debug_info(nullptr)\n@@ -191,1 +191,1 @@\n-  , _oop_map(NULL)\n+  , _oop_map(nullptr)\n@@ -196,1 +196,1 @@\n-  assert(_stack != NULL, \"must be non null\");\n+  assert(_stack != nullptr, \"must be non null\");\n@@ -201,1 +201,1 @@\n-  : _scope_debug_info(NULL)\n+  : _scope_debug_info(nullptr)\n@@ -203,3 +203,3 @@\n-  , _exception_handlers(NULL)\n-  , _oop_map(NULL)\n-  , _stack(stack == NULL ? info->_stack : stack)\n+  , _exception_handlers(nullptr)\n+  , _oop_map(nullptr)\n+  , _stack(stack == nullptr ? info->_stack : stack)\n@@ -211,1 +211,1 @@\n-  if (info->_exception_handlers != NULL) {\n+  if (info->_exception_handlers != nullptr) {\n@@ -227,1 +227,1 @@\n-  assert(_oop_map != NULL, \"oop map must already exist\");\n+  assert(_oop_map != nullptr, \"oop map must already exist\");\n@@ -244,1 +244,1 @@\n-  while (state != NULL) {\n+  while (state != nullptr) {\n@@ -273,2 +273,2 @@\n-  _top_scope   = new IRScope(compilation, NULL, -1, method, osr_bci, true);\n-  _code        = NULL;\n+  _top_scope   = new IRScope(compilation, nullptr, -1, method, osr_bci, true);\n+  _code        = nullptr;\n@@ -339,1 +339,1 @@\n-    BlockPair* last_pair = NULL;\n+    BlockPair* last_pair = nullptr;\n@@ -343,1 +343,1 @@\n-      if (last_pair != NULL && pair->is_same(last_pair)) continue;\n+      if (last_pair != nullptr && pair->is_same(last_pair)) continue;\n@@ -400,1 +400,1 @@\n-      if ((*n)->as_BlockEnd() != NULL) {\n+      if ((*n)->as_BlockEnd() != nullptr) {\n@@ -413,1 +413,1 @@\n-    for (Instruction* n = b; n != NULL; n = n->next()) {\n+    for (Instruction* n = b; n != nullptr; n = n->next()) {\n@@ -534,1 +534,1 @@\n-  _linear_scan_order(NULL), \/\/ initialized later with correct size\n+  _linear_scan_order(nullptr), \/\/ initialized later with correct size\n@@ -546,1 +546,1 @@\n-  count_edges(start_block, NULL);\n+  count_edges(start_block, nullptr);\n@@ -552,1 +552,1 @@\n-      assert(md != NULL, \"Sanity\");\n+      assert(md != nullptr, \"Sanity\");\n@@ -577,2 +577,2 @@\n-  TRACE_LINEAR_SCAN(3, tty->print_cr(\"Enter count_edges for block B%d coming from B%d\", cur->block_id(), parent != NULL ? parent->block_id() : -1));\n-  assert(cur->dominator() == NULL, \"dominator already initialized\");\n+  TRACE_LINEAR_SCAN(3, tty->print_cr(\"Enter count_edges for block B%d coming from B%d\", cur->block_id(), parent != nullptr ? parent->block_id() : -1));\n+  assert(cur->dominator() == nullptr, \"dominator already initialized\");\n@@ -583,1 +583,1 @@\n-    assert(parent != NULL, \"must have parent\");\n+    assert(parent != nullptr, \"must have parent\");\n@@ -760,1 +760,1 @@\n-  assert(a != NULL && b != NULL, \"must have input blocks\");\n+  assert(a != nullptr && b != nullptr, \"must have input blocks\");\n@@ -763,1 +763,1 @@\n-  while (a != NULL) {\n+  while (a != nullptr) {\n@@ -765,1 +765,1 @@\n-    assert(a->dominator() != NULL || a == _linear_scan_order->at(0), \"dominator must be initialized\");\n+    assert(a->dominator() != nullptr || a == _linear_scan_order->at(0), \"dominator must be initialized\");\n@@ -768,2 +768,2 @@\n-  while (b != NULL && !_dominator_blocks.at(b->block_id())) {\n-    assert(b->dominator() != NULL || b == _linear_scan_order->at(0), \"dominator must be initialized\");\n+  while (b != nullptr && !_dominator_blocks.at(b->block_id())) {\n+    assert(b->dominator() != nullptr || b == _linear_scan_order->at(0), \"dominator must be initialized\");\n@@ -773,1 +773,1 @@\n-  assert(b != NULL, \"could not find dominator\");\n+  assert(b != nullptr, \"could not find dominator\");\n@@ -786,1 +786,1 @@\n-  if (cur->dominator() == NULL) {\n+  if (cur->dominator() == nullptr) {\n@@ -812,1 +812,1 @@\n-  BlockBegin* single_sux = NULL;\n+  BlockBegin* single_sux = nullptr;\n@@ -840,2 +840,2 @@\n-  INC_WEIGHT_IF(cur->end()->as_Throw() == NULL  && (single_sux == NULL || single_sux->end()->as_Throw()  == NULL));\n-  INC_WEIGHT_IF(cur->end()->as_Return() == NULL && (single_sux == NULL || single_sux->end()->as_Return() == NULL));\n+  INC_WEIGHT_IF(cur->end()->as_Throw() == nullptr  && (single_sux == nullptr || single_sux->end()->as_Throw()  == nullptr));\n+  INC_WEIGHT_IF(cur->end()->as_Return() == nullptr && (single_sux == nullptr || single_sux->end()->as_Return() == nullptr));\n@@ -883,1 +883,1 @@\n-  _work_list.append(NULL); \/\/ provide space for new element\n+  _work_list.append(nullptr); \/\/ provide space for new element\n@@ -921,1 +921,1 @@\n-  assert(start_block->end()->as_Base() != NULL, \"start block must end with Base-instruction\");\n+  assert(start_block->end()->as_Base() != nullptr, \"start block must end with Base-instruction\");\n@@ -925,2 +925,2 @@\n-  BlockBegin* sux_of_osr_entry = NULL;\n-  if (osr_entry != NULL) {\n+  BlockBegin* sux_of_osr_entry = nullptr;\n+  if (osr_entry != nullptr) {\n@@ -986,1 +986,1 @@\n-  assert(_linear_scan_order->at(0)->dominator() == NULL, \"must not have dominator\");\n+  assert(_linear_scan_order->at(0)->dominator() == nullptr, \"must not have dominator\");\n@@ -1080,1 +1080,1 @@\n-      if (cur->dominator() != NULL) {\n+      if (cur->dominator() != nullptr) {\n@@ -1083,1 +1083,1 @@\n-        tty->print(\"    dom: NULL \");\n+        tty->print(\"    dom: null \");\n@@ -1159,1 +1159,1 @@\n-      assert(cur->dominator() == NULL, \"first block has no dominator\");\n+      assert(cur->dominator() == nullptr, \"first block has no dominator\");\n@@ -1161,1 +1161,1 @@\n-      assert(cur->dominator() != NULL, \"all but first block must have dominator\");\n+      assert(cur->dominator() != nullptr, \"all but first block must have dominator\");\n@@ -1272,1 +1272,1 @@\n-    assert(block->end() != NULL, \"Expect block end to exist.\");\n+    assert(block->end() != nullptr, \"Expect block end to exist.\");\n@@ -1307,1 +1307,1 @@\n-    _predecessors = new BlockListList(BlockBegin::number_of_blocks(), BlockBegin::number_of_blocks(), NULL);\n+    _predecessors = new BlockListList(BlockBegin::number_of_blocks(), BlockBegin::number_of_blocks(), nullptr);\n@@ -1311,1 +1311,1 @@\n-    if (hir->code() != NULL) {\n+    if (hir->code() != nullptr) {\n@@ -1340,2 +1340,2 @@\n-    BlockList* preds = _predecessors->at_grow(sux->block_id(), NULL);\n-    if (preds == NULL) {\n+    BlockList* preds = _predecessors->at_grow(sux->block_id(), nullptr);\n+    if (preds == nullptr) {\n@@ -1350,1 +1350,1 @@\n-    if (preds == NULL) {\n+    if (preds == nullptr) {\n@@ -1373,1 +1373,1 @@\n-    for (Instruction* cur = block; cur != NULL; cur = cur->next()) {\n+    for (Instruction* cur = block; cur != nullptr; cur = cur->next()) {\n@@ -1391,2 +1391,2 @@\n-      assert(block->pred_at(i) != NULL, \"Predecessor must exist\");\n-      assert(block->pred_at(i)->end() != NULL, \"Predecessor end must exist\");\n+      assert(block->pred_at(i) != nullptr, \"Predecessor must exist\");\n+      assert(block->pred_at(i)->end() != nullptr, \"Predecessor end must exist\");\n@@ -1477,2 +1477,2 @@\n-  Instruction* last = NULL;\n-  for (Instruction* n = block; n != NULL;) {\n+  Instruction* last = nullptr;\n+  for (Instruction* n = block; n != nullptr;) {\n@@ -1482,1 +1482,1 @@\n-      guarantee(last != NULL, \"must have last\");\n+      guarantee(last != nullptr, \"must have last\");\n","filename":"src\/hotspot\/share\/c1\/c1_IR.cpp","additions":59,"deletions":59,"binary":false,"changes":118,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,2 +54,2 @@\n-    , _entry_block(NULL)\n-    , _entry_code(NULL)\n+    , _entry_block(nullptr)\n+    , _entry_code(nullptr)\n@@ -140,1 +140,1 @@\n-  IRScope*      _caller;                         \/\/ the caller scope, or NULL\n+  IRScope*      _caller;                         \/\/ the caller scope, or null\n@@ -172,1 +172,1 @@\n-  bool          is_top_scope() const             { return _caller == NULL; }\n+  bool          is_top_scope() const             { return _caller == nullptr; }\n@@ -178,1 +178,1 @@\n-  bool          is_valid() const                 { return start() != NULL; }\n+  bool          is_valid() const                 { return start() != nullptr; }\n@@ -236,1 +236,1 @@\n-    if (caller() != NULL) {\n+    if (caller() != nullptr) {\n@@ -276,1 +276,1 @@\n-  CodeEmitInfo(CodeEmitInfo* info, ValueStack* stack = NULL);\n+  CodeEmitInfo(CodeEmitInfo* info, ValueStack* stack = nullptr);\n@@ -334,1 +334,1 @@\n-  BlockList* linear_scan_order() {  assert(_code != NULL, \"not computed\"); return _code; }\n+  BlockList* linear_scan_order() {  assert(_code != nullptr, \"not computed\"); return _code; }\n","filename":"src\/hotspot\/share\/c1\/c1_IR.hpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -79,1 +79,1 @@\n-  if (state != NULL && (state->kind() == ValueStack::EmptyExceptionState || state->kind() == ValueStack::ExceptionState)) {\n+  if (state != nullptr && (state->kind() == ValueStack::EmptyExceptionState || state->kind() == ValueStack::ExceptionState)) {\n@@ -83,1 +83,1 @@\n-    _exception_state = NULL;\n+    _exception_state = nullptr;\n@@ -89,1 +89,1 @@\n-  Instruction* p = NULL;\n+  Instruction* p = nullptr;\n@@ -92,1 +92,1 @@\n-    assert(q != NULL, \"this is not in the block's instruction list\");\n+    assert(q != nullptr, \"this is not in the block's instruction list\");\n@@ -100,1 +100,1 @@\n-  if (state_before() != NULL) {\n+  if (state_before() != nullptr) {\n@@ -103,1 +103,1 @@\n-  if (exception_state() != NULL){\n+  if (exception_state() != nullptr) {\n@@ -110,1 +110,1 @@\n-  if (t != NULL && t->is_klass()) {\n+  if (t != nullptr && t->is_klass()) {\n@@ -113,1 +113,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -119,1 +119,1 @@\n-  if (state != NULL) {\n+  if (state != nullptr) {\n@@ -171,1 +171,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -176,1 +176,1 @@\n-  if (array_type != NULL) {\n+  if (array_type != nullptr) {\n@@ -193,2 +193,2 @@\n-  if (array_type == NULL || !array_type->is_loaded()) {\n-    return NULL;\n+  if (array_type == nullptr || !array_type->is_loaded()) {\n+    return nullptr;\n@@ -307,1 +307,1 @@\n-  if (state() != NULL) state()->values_do(f);\n+  if (state() != nullptr) state()->values_do(f);\n@@ -336,1 +336,1 @@\n-  assert(args != NULL, \"args must exist\");\n+  assert(args != nullptr, \"args must exist\");\n@@ -357,2 +357,2 @@\n-  if (state_before() != NULL) state_before()->values_do(f);\n-  if (state()        != NULL) state()->values_do(f);\n+  if (state_before() != nullptr) state_before()->values_do(f);\n+  if (state()        != nullptr) state()->values_do(f);\n@@ -370,1 +370,1 @@\n-  if (state_before() == NULL) {\n+  if (state_before() == nullptr) {\n@@ -402,1 +402,1 @@\n-  if (v->as_Constant() == NULL) return false;\n+  if (v->as_Constant() == nullptr) return false;\n@@ -409,1 +409,1 @@\n-        return (t1 != NULL && t2 != NULL &&\n+        return (t1 != nullptr && t2 != nullptr &&\n@@ -416,1 +416,1 @@\n-        return (t1 != NULL && t2 != NULL &&\n+        return (t1 != nullptr && t2 != nullptr &&\n@@ -423,1 +423,1 @@\n-        return (t1 != NULL && t2 != NULL &&\n+        return (t1 != nullptr && t2 != nullptr &&\n@@ -430,1 +430,1 @@\n-        return (t1 != NULL && t2 != NULL &&\n+        return (t1 != nullptr && t2 != nullptr &&\n@@ -437,1 +437,1 @@\n-        return (t1 != NULL && t2 != NULL &&\n+        return (t1 != nullptr && t2 != nullptr &&\n@@ -445,1 +445,1 @@\n-        return (t1 != NULL && t2 != NULL &&\n+        return (t1 != nullptr && t2 != nullptr &&\n@@ -457,1 +457,1 @@\n-  if (rc == NULL) return not_comparable;\n+  if (rc == nullptr) return not_comparable;\n@@ -495,1 +495,1 @@\n-    assert(xvalue != NULL && yvalue != NULL, \"not constants\");\n+    assert(xvalue != nullptr && yvalue != nullptr, \"not constants\");\n@@ -508,1 +508,1 @@\n-    assert(xvalue != NULL && yvalue != NULL, \"not constants\");\n+    assert(xvalue != nullptr && yvalue != nullptr, \"not constants\");\n@@ -528,1 +528,1 @@\n-  assert(new_end != NULL, \"Should not reset block new_end to NULL\");\n+  assert(new_end != nullptr, \"Should not reset block new_end to null\");\n@@ -532,1 +532,1 @@\n-  if (_end != NULL) {\n+  if (_end != nullptr) {\n@@ -659,1 +659,1 @@\n-  assert(b != NULL && (b->is_set(exception_entry_flag)), \"exception handler must exist\");\n+  assert(b != nullptr && (b->is_set(exception_entry_flag)), \"exception handler must exist\");\n@@ -666,1 +666,1 @@\n-  if (_exception_states == NULL) {\n+  if (_exception_states == nullptr) {\n@@ -711,1 +711,1 @@\n-  for (Instruction* n = this; n != NULL; n = n->next()) n->values_do(f);\n+  for (Instruction* n = this; n != nullptr; n = n->next()) n->values_do(f);\n@@ -730,1 +730,1 @@\n-  if (existing_state == NULL) {\n+  if (existing_state == nullptr) {\n@@ -792,1 +792,1 @@\n-        if (new_value == NULL || new_value->type()->tag() != existing_value->type()->tag()) {\n+        if (new_value == nullptr || new_value->type()->tag() != existing_value->type()->tag()) {\n@@ -794,1 +794,1 @@\n-          if (existing_phi == NULL) {\n+          if (existing_phi == nullptr) {\n@@ -805,1 +805,1 @@\n-        if (existing_value != new_state->local_at(index) && existing_value->as_Phi() == NULL) {\n+        if (existing_value != new_state->local_at(index) && existing_value->as_Phi() == nullptr) {\n@@ -814,1 +814,1 @@\n-        assert(existing_value->as_Phi() != NULL && existing_value->as_Phi()->block() == this, \"phi function required\");\n+        assert(existing_value->as_Phi() != nullptr && existing_value->as_Phi()->block() == this, \"phi function required\");\n@@ -817,1 +817,1 @@\n-        assert(existing_value == new_state->local_at(index) || (existing_value->as_Phi() != NULL && existing_value->as_Phi()->as_Phi()->block() == this), \"phi function required\");\n+        assert(existing_value == new_state->local_at(index) || (existing_value->as_Phi() != nullptr && existing_value->as_Phi()->as_Phi()->block() == this), \"phi function required\");\n@@ -829,1 +829,1 @@\n-        if (new_value != existing_value && (existing_phi == NULL || existing_phi->block() != this)) {\n+        if (new_value != existing_value && (existing_phi == nullptr || existing_phi->block() != this)) {\n@@ -840,1 +840,1 @@\n-        if (new_value == NULL || new_value->type()->tag() != existing_value->type()->tag()) {\n+        if (new_value == nullptr || new_value->type()->tag() != existing_value->type()->tag()) {\n@@ -843,1 +843,1 @@\n-        } else if (new_value != existing_value && (existing_phi == NULL || existing_phi->block() != this)) {\n+        } else if (new_value != existing_value && (existing_phi == nullptr || existing_phi->block() != this)) {\n@@ -875,1 +875,1 @@\n-  for (Instruction* n = next(); n != NULL; n = n->next()) {\n+  for (Instruction* n = next(); n != nullptr; n = n->next()) {\n@@ -937,1 +937,1 @@\n-  assert(state != NULL, \"\");\n+  assert(state != nullptr, \"\");\n@@ -989,1 +989,1 @@\n-  if (state() != NULL) state()->values_do(f);\n+  if (state() != nullptr) state()->values_do(f);\n","filename":"src\/hotspot\/share\/c1\/c1_Instruction.cpp","additions":46,"deletions":46,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -239,1 +239,1 @@\n-    if (_v == NULL  ) return false;                   \\\n+    if (_v == nullptr) return false;                  \\\n@@ -252,1 +252,1 @@\n-    if (_v == NULL  ) return false;                   \\\n+    if (_v == nullptr) return false;                  \\\n@@ -266,1 +266,1 @@\n-    if (_v == NULL  ) return false;                   \\\n+    if (_v == nullptr) return false;                  \\\n@@ -285,1 +285,1 @@\n-  Instruction* _next;                            \/\/ the next instruction if any (NULL for BlockEnd instructions)\n+  Instruction* _next;                            \/\/ the next instruction if any (null for BlockEnd instructions)\n@@ -290,1 +290,1 @@\n-  ValueStack*  _state_before;                    \/\/ Copy of state with input operands still on stack (or NULL)\n+  ValueStack*  _state_before;                    \/\/ Copy of state with input operands still on stack (or null)\n@@ -302,1 +302,1 @@\n-    assert(type != NULL, \"type must exist\");\n+    assert(type != nullptr, \"type must exist\");\n@@ -398,1 +398,1 @@\n-  Instruction(ValueType* type, ValueStack* state_before = NULL, bool type_is_constant = false)\n+  Instruction(ValueType* type, ValueStack* state_before = nullptr, bool type_is_constant = false)\n@@ -406,2 +406,2 @@\n-  , _next(NULL)\n-  , _subst(NULL)\n+  , _next(nullptr)\n+  , _subst(nullptr)\n@@ -411,2 +411,2 @@\n-  , _exception_handlers(NULL)\n-  , _block(NULL)\n+  , _exception_handlers(nullptr)\n+  , _block(nullptr)\n@@ -415,1 +415,1 @@\n-    assert(type != NULL && (!type->is_constant() || type_is_constant), \"type must exist\");\n+    assert(type != nullptr && (!type->is_constant() || type_is_constant), \"type must exist\");\n@@ -434,2 +434,2 @@\n-  bool has_subst() const                         { return _subst != NULL; }\n-  Instruction* subst()                           { return _subst == NULL ? this : _subst->subst(); }\n+  bool has_subst() const                         { return _subst != nullptr; }\n+  Instruction* subst()                           { return _subst == nullptr ? this : _subst->subst(); }\n@@ -441,1 +441,1 @@\n-  bool can_be_linked()                           { return as_Local() == NULL && as_Phi() == NULL; }\n+  bool can_be_linked()                           { return as_Local() == nullptr && as_Phi() == nullptr; }\n@@ -443,1 +443,1 @@\n-  bool is_null_obj()                             { return as_Constant() != NULL && type()->as_ObjectType()->constant_value()->is_null_object(); }\n+  bool is_null_obj()                             { return as_Constant() != nullptr && type()->as_ObjectType()->constant_value()->is_null_object(); }\n@@ -459,2 +459,2 @@\n-    assert(next != NULL, \"must not be NULL\");\n-    assert(as_BlockEnd() == NULL, \"BlockEnd instructions must have no next\");\n+    assert(next != nullptr, \"must not be null\");\n+    assert(as_BlockEnd() == nullptr, \"BlockEnd instructions must have no next\");\n@@ -502,1 +502,1 @@\n-    assert(subst == NULL ||\n+    assert(subst == nullptr ||\n@@ -517,50 +517,50 @@\n-  virtual Phi*              as_Phi()             { return NULL; }\n-  virtual Local*            as_Local()           { return NULL; }\n-  virtual Constant*         as_Constant()        { return NULL; }\n-  virtual AccessField*      as_AccessField()     { return NULL; }\n-  virtual LoadField*        as_LoadField()       { return NULL; }\n-  virtual StoreField*       as_StoreField()      { return NULL; }\n-  virtual AccessArray*      as_AccessArray()     { return NULL; }\n-  virtual ArrayLength*      as_ArrayLength()     { return NULL; }\n-  virtual AccessIndexed*    as_AccessIndexed()   { return NULL; }\n-  virtual LoadIndexed*      as_LoadIndexed()     { return NULL; }\n-  virtual StoreIndexed*     as_StoreIndexed()    { return NULL; }\n-  virtual NegateOp*         as_NegateOp()        { return NULL; }\n-  virtual Op2*              as_Op2()             { return NULL; }\n-  virtual ArithmeticOp*     as_ArithmeticOp()    { return NULL; }\n-  virtual ShiftOp*          as_ShiftOp()         { return NULL; }\n-  virtual LogicOp*          as_LogicOp()         { return NULL; }\n-  virtual CompareOp*        as_CompareOp()       { return NULL; }\n-  virtual IfOp*             as_IfOp()            { return NULL; }\n-  virtual Convert*          as_Convert()         { return NULL; }\n-  virtual NullCheck*        as_NullCheck()       { return NULL; }\n-  virtual OsrEntry*         as_OsrEntry()        { return NULL; }\n-  virtual StateSplit*       as_StateSplit()      { return NULL; }\n-  virtual Invoke*           as_Invoke()          { return NULL; }\n-  virtual NewInstance*      as_NewInstance()     { return NULL; }\n-  virtual NewArray*         as_NewArray()        { return NULL; }\n-  virtual NewTypeArray*     as_NewTypeArray()    { return NULL; }\n-  virtual NewObjectArray*   as_NewObjectArray()  { return NULL; }\n-  virtual NewMultiArray*    as_NewMultiArray()   { return NULL; }\n-  virtual TypeCheck*        as_TypeCheck()       { return NULL; }\n-  virtual CheckCast*        as_CheckCast()       { return NULL; }\n-  virtual InstanceOf*       as_InstanceOf()      { return NULL; }\n-  virtual TypeCast*         as_TypeCast()        { return NULL; }\n-  virtual AccessMonitor*    as_AccessMonitor()   { return NULL; }\n-  virtual MonitorEnter*     as_MonitorEnter()    { return NULL; }\n-  virtual MonitorExit*      as_MonitorExit()     { return NULL; }\n-  virtual Intrinsic*        as_Intrinsic()       { return NULL; }\n-  virtual BlockBegin*       as_BlockBegin()      { return NULL; }\n-  virtual BlockEnd*         as_BlockEnd()        { return NULL; }\n-  virtual Goto*             as_Goto()            { return NULL; }\n-  virtual If*               as_If()              { return NULL; }\n-  virtual TableSwitch*      as_TableSwitch()     { return NULL; }\n-  virtual LookupSwitch*     as_LookupSwitch()    { return NULL; }\n-  virtual Return*           as_Return()          { return NULL; }\n-  virtual Throw*            as_Throw()           { return NULL; }\n-  virtual Base*             as_Base()            { return NULL; }\n-  virtual RoundFP*          as_RoundFP()         { return NULL; }\n-  virtual ExceptionObject*  as_ExceptionObject() { return NULL; }\n-  virtual UnsafeOp*         as_UnsafeOp()        { return NULL; }\n-  virtual ProfileInvoke*    as_ProfileInvoke()   { return NULL; }\n-  virtual RangeCheckPredicate* as_RangeCheckPredicate() { return NULL; }\n+  virtual Phi*              as_Phi()             { return nullptr; }\n+  virtual Local*            as_Local()           { return nullptr; }\n+  virtual Constant*         as_Constant()        { return nullptr; }\n+  virtual AccessField*      as_AccessField()     { return nullptr; }\n+  virtual LoadField*        as_LoadField()       { return nullptr; }\n+  virtual StoreField*       as_StoreField()      { return nullptr; }\n+  virtual AccessArray*      as_AccessArray()     { return nullptr; }\n+  virtual ArrayLength*      as_ArrayLength()     { return nullptr; }\n+  virtual AccessIndexed*    as_AccessIndexed()   { return nullptr; }\n+  virtual LoadIndexed*      as_LoadIndexed()     { return nullptr; }\n+  virtual StoreIndexed*     as_StoreIndexed()    { return nullptr; }\n+  virtual NegateOp*         as_NegateOp()        { return nullptr; }\n+  virtual Op2*              as_Op2()             { return nullptr; }\n+  virtual ArithmeticOp*     as_ArithmeticOp()    { return nullptr; }\n+  virtual ShiftOp*          as_ShiftOp()         { return nullptr; }\n+  virtual LogicOp*          as_LogicOp()         { return nullptr; }\n+  virtual CompareOp*        as_CompareOp()       { return nullptr; }\n+  virtual IfOp*             as_IfOp()            { return nullptr; }\n+  virtual Convert*          as_Convert()         { return nullptr; }\n+  virtual NullCheck*        as_NullCheck()       { return nullptr; }\n+  virtual OsrEntry*         as_OsrEntry()        { return nullptr; }\n+  virtual StateSplit*       as_StateSplit()      { return nullptr; }\n+  virtual Invoke*           as_Invoke()          { return nullptr; }\n+  virtual NewInstance*      as_NewInstance()     { return nullptr; }\n+  virtual NewArray*         as_NewArray()        { return nullptr; }\n+  virtual NewTypeArray*     as_NewTypeArray()    { return nullptr; }\n+  virtual NewObjectArray*   as_NewObjectArray()  { return nullptr; }\n+  virtual NewMultiArray*    as_NewMultiArray()   { return nullptr; }\n+  virtual TypeCheck*        as_TypeCheck()       { return nullptr; }\n+  virtual CheckCast*        as_CheckCast()       { return nullptr; }\n+  virtual InstanceOf*       as_InstanceOf()      { return nullptr; }\n+  virtual TypeCast*         as_TypeCast()        { return nullptr; }\n+  virtual AccessMonitor*    as_AccessMonitor()   { return nullptr; }\n+  virtual MonitorEnter*     as_MonitorEnter()    { return nullptr; }\n+  virtual MonitorExit*      as_MonitorExit()     { return nullptr; }\n+  virtual Intrinsic*        as_Intrinsic()       { return nullptr; }\n+  virtual BlockBegin*       as_BlockBegin()      { return nullptr; }\n+  virtual BlockEnd*         as_BlockEnd()        { return nullptr; }\n+  virtual Goto*             as_Goto()            { return nullptr; }\n+  virtual If*               as_If()              { return nullptr; }\n+  virtual TableSwitch*      as_TableSwitch()     { return nullptr; }\n+  virtual LookupSwitch*     as_LookupSwitch()    { return nullptr; }\n+  virtual Return*           as_Return()          { return nullptr; }\n+  virtual Throw*            as_Throw()           { return nullptr; }\n+  virtual Base*             as_Base()            { return nullptr; }\n+  virtual RoundFP*          as_RoundFP()         { return nullptr; }\n+  virtual ExceptionObject*  as_ExceptionObject() { return nullptr; }\n+  virtual UnsafeOp*         as_UnsafeOp()        { return nullptr; }\n+  virtual ProfileInvoke*    as_ProfileInvoke()   { return nullptr; }\n+  virtual RangeCheckPredicate* as_RangeCheckPredicate() { return nullptr; }\n@@ -569,1 +569,1 @@\n-  virtual Assert*           as_Assert()          { return NULL; }\n+  virtual Assert*           as_Assert()          { return nullptr; }\n@@ -582,1 +582,1 @@\n-  virtual ciType* declared_type() const          { return NULL; }\n+  virtual ciType* declared_type() const          { return nullptr; }\n@@ -618,1 +618,1 @@\n-  void visit(Value* x)             { assert((*x) != NULL, \"value must exist\"); }\n+  void visit(Value* x)             { assert((*x) != nullptr, \"value must exist\"); }\n@@ -717,1 +717,1 @@\n-      Instruction(type, NULL, \/*type_is_constant*\/ true)\n+      Instruction(type, nullptr, \/*type_is_constant*\/ true)\n@@ -725,1 +725,1 @@\n-    assert(state_before != NULL, \"only used for constants which need patching\");\n+    assert(state_before != nullptr, \"only used for constants which need patching\");\n@@ -732,1 +732,1 @@\n-  virtual bool can_trap() const                  { return state_before() != NULL; }\n+  virtual bool can_trap() const                  { return state_before() != nullptr; }\n@@ -749,1 +749,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -756,1 +756,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -777,1 +777,1 @@\n-  , _explicit_null_check(NULL)\n+  , _explicit_null_check(nullptr)\n@@ -887,1 +887,1 @@\n-  , _explicit_null_check(NULL) {}\n+  , _explicit_null_check(nullptr) {}\n@@ -927,1 +927,1 @@\n-  void clear_length()                            { _length = NULL; }\n+  void clear_length()                            { _length = nullptr; }\n@@ -932,1 +932,1 @@\n-  virtual void input_values_do(ValueVisitor* f)   { AccessArray::input_values_do(f); f->visit(&_index); if (_length != NULL) f->visit(&_length); }\n+  virtual void input_values_do(ValueVisitor* f)   { AccessArray::input_values_do(f); f->visit(&_index); if (_length != nullptr) f->visit(&_length); }\n@@ -944,1 +944,1 @@\n-  , _explicit_null_check(NULL) {}\n+  , _explicit_null_check(nullptr) {}\n@@ -974,1 +974,1 @@\n-  , _value(value), _profiled_method(NULL), _profiled_bci(0), _check_boolean(check_boolean)\n+  , _value(value), _profiled_method(nullptr), _profiled_bci(0), _check_boolean(check_boolean)\n@@ -1025,1 +1025,1 @@\n-  Op2(ValueType* type, Bytecodes::Code op, Value x, Value y, ValueStack* state_before = NULL)\n+  Op2(ValueType* type, Bytecodes::Code op, Value x, Value y, ValueStack* state_before = nullptr)\n@@ -1210,1 +1210,1 @@\n-  StateSplit(ValueType* type, ValueStack* state_before = NULL)\n+  StateSplit(ValueType* type, ValueStack* state_before = nullptr)\n@@ -1212,1 +1212,1 @@\n-  , _state(NULL)\n+  , _state(nullptr)\n@@ -1222,1 +1222,1 @@\n-  void set_state(ValueStack* state)              { assert(_state == NULL, \"overwriting existing state\"); check_state(state); _state = state; }\n+  void set_state(ValueStack* state)              { assert(_state == nullptr, \"overwriting existing state\"); check_state(state); _state = state; }\n@@ -1246,1 +1246,1 @@\n-  bool has_receiver() const                      { return receiver() != NULL; }\n+  bool has_receiver() const                      { return receiver() != nullptr; }\n@@ -1310,1 +1310,1 @@\n-    \/\/ Do not ASSERT_VALUES since length is NULL for NewMultiArray\n+    \/\/ Do not ASSERT_VALUES since length is null for NewMultiArray\n@@ -1318,1 +1318,1 @@\n-  ciType* exact_type() const                     { return NULL; }\n+  ciType* exact_type() const                     { return nullptr; }\n@@ -1365,1 +1365,1 @@\n-  NewMultiArray(ciKlass* klass, Values* dims, ValueStack* state_before) : NewArray(NULL, state_before), _klass(klass), _dims(dims) {\n+  NewMultiArray(ciKlass* klass, Values* dims, ValueStack* state_before) : NewArray(nullptr, state_before), _klass(klass), _dims(dims) {\n@@ -1400,1 +1400,1 @@\n-    _profiled_method(NULL), _profiled_bci(0) {\n+    _profiled_method(nullptr), _profiled_bci(0) {\n@@ -1408,1 +1408,1 @@\n-  bool is_loaded() const                         { return klass() != NULL; }\n+  bool is_loaded() const                         { return klass() != nullptr; }\n@@ -1471,1 +1471,1 @@\n-  AccessMonitor(Value obj, int monitor_no, ValueStack* state_before = NULL)\n+  AccessMonitor(Value obj, int monitor_no, ValueStack* state_before = nullptr)\n@@ -1507,1 +1507,1 @@\n-  : AccessMonitor(obj, monitor_no, NULL)\n+  : AccessMonitor(obj, monitor_no, nullptr)\n@@ -1539,1 +1539,1 @@\n-  , _recv(NULL)\n+  , _recv(nullptr)\n@@ -1541,1 +1541,1 @@\n-    assert(args != NULL, \"args must exist\");\n+    assert(args != nullptr, \"args must exist\");\n@@ -1561,1 +1561,1 @@\n-  bool has_receiver() const                      { return (_recv != NULL); }\n+  bool has_receiver() const                      { return (_recv != nullptr); }\n@@ -1655,2 +1655,2 @@\n-  , _dominator(NULL)\n-  , _end(NULL)\n+  , _dominator(nullptr)\n+  , _end(nullptr)\n@@ -1658,1 +1658,1 @@\n-  , _exception_states(NULL)\n+  , _exception_states(nullptr)\n@@ -1660,1 +1660,1 @@\n-  , _lir(NULL)\n+  , _lir(nullptr)\n@@ -1666,1 +1666,1 @@\n-  , _fpu_stack_state(NULL)\n+  , _fpu_stack_state(nullptr)\n@@ -1742,1 +1742,1 @@\n-  int number_of_exception_states()               { assert(is_set(exception_entry_flag), \"only for xhandlers\"); return _exception_states == NULL ? 0 : _exception_states->length(); }\n+  int number_of_exception_states()               { assert(is_set(exception_entry_flag), \"only for xhandlers\"); return _exception_states == nullptr ? 0 : _exception_states->length(); }\n@@ -1804,2 +1804,2 @@\n-    assert(sux != NULL, \"sux must exist\");\n-    for (int i = sux->length() - 1; i >= 0; i--) assert(sux->at(i) != NULL, \"sux must exist\");\n+    assert(sux != nullptr, \"sux must exist\");\n+    for (int i = sux->length() - 1; i >= 0; i--) assert(sux->at(i) != nullptr, \"sux must exist\");\n@@ -1814,1 +1814,1 @@\n-  , _sux(NULL)\n+  , _sux(nullptr)\n@@ -1829,1 +1829,1 @@\n-  int number_of_sux() const                      { return _sux != NULL ? _sux->length() : 0; }\n+  int number_of_sux() const                      { return _sux != nullptr ? _sux->length() : 0; }\n@@ -1831,1 +1831,1 @@\n-  bool is_sux(BlockBegin* sux) const             { return _sux == NULL ? false : _sux->contains(sux); }\n+  bool is_sux(BlockBegin* sux) const             { return _sux == nullptr ? false : _sux->contains(sux); }\n@@ -1851,1 +1851,1 @@\n-    , _profiled_method(NULL)\n+    , _profiled_method(nullptr)\n@@ -1859,2 +1859,2 @@\n-  Goto(BlockBegin* sux, bool is_safepoint) : BlockEnd(illegalType, NULL, is_safepoint)\n-                                           , _profiled_method(NULL)\n+  Goto(BlockBegin* sux, bool is_safepoint) : BlockEnd(illegalType, nullptr, is_safepoint)\n+                                           , _profiled_method(nullptr)\n@@ -1931,1 +1931,1 @@\n-    _x = _y = NULL;\n+    _x = _y = nullptr;\n@@ -1941,1 +1941,1 @@\n-  void always_fail()                             { _x = _y = NULL; }\n+  void always_fail()                             { _x = _y = nullptr; }\n@@ -1965,1 +1965,1 @@\n-  , _profiled_method(NULL)\n+  , _profiled_method(nullptr)\n@@ -2056,1 +2056,1 @@\n-    assert(keys != NULL, \"keys must exist\");\n+    assert(keys != nullptr, \"keys must exist\");\n@@ -2072,1 +2072,1 @@\n-    BlockEnd(result == NULL ? voidType : result->type()->base(), NULL, true),\n+    BlockEnd(result == nullptr ? voidType : result->type()->base(), nullptr, true),\n@@ -2077,1 +2077,1 @@\n-  bool has_result() const                        { return result() != NULL; }\n+  bool has_result() const                        { return result() != nullptr; }\n@@ -2109,1 +2109,1 @@\n-  Base(BlockBegin* std_entry, BlockBegin* osr_entry) : BlockEnd(illegalType, NULL, false) {\n+  Base(BlockBegin* std_entry, BlockBegin* osr_entry) : BlockEnd(illegalType, nullptr, false) {\n@@ -2111,1 +2111,1 @@\n-    assert(osr_entry == NULL || osr_entry->is_set(BlockBegin::osr_entry_flag), \"osr entry must be flagged\");\n+    assert(osr_entry == nullptr || osr_entry->is_set(BlockBegin::osr_entry_flag), \"osr entry must be flagged\");\n@@ -2113,1 +2113,1 @@\n-    if (osr_entry != NULL) s->append(osr_entry);\n+    if (osr_entry != nullptr) s->append(osr_entry);\n@@ -2120,1 +2120,1 @@\n-  BlockBegin* osr_entry() const                  { return number_of_sux() < 2 ? NULL : sux_at(0); }\n+  BlockBegin* osr_entry() const                  { return number_of_sux() < 2 ? nullptr : sux_at(0); }\n@@ -2299,1 +2299,1 @@\n-  int nb_profiled_args()         const { return _obj_args == NULL ? 0 : _obj_args->length(); }\n+  int nb_profiled_args()         const { return _obj_args == nullptr ? 0 : _obj_args->length(); }\n@@ -2311,1 +2311,1 @@\n-    if (_recv != NULL) {\n+    if (_recv != nullptr) {\n@@ -2346,1 +2346,1 @@\n-    if (_ret != NULL) {\n+    if (_ret != nullptr) {\n@@ -2439,2 +2439,2 @@\n-inline int         BlockBegin::number_of_sux() const            { assert(_end != NULL, \"need end\"); return _end->number_of_sux(); }\n-inline BlockBegin* BlockBegin::sux_at(int i) const              { assert(_end != NULL , \"need end\"); return _end->sux_at(i); }\n+inline int         BlockBegin::number_of_sux() const            { assert(_end != nullptr, \"need end\"); return _end->number_of_sux(); }\n+inline BlockBegin* BlockBegin::sux_at(int i) const              { assert(_end != nullptr , \"need end\"); return _end->sux_at(i); }\n","filename":"src\/hotspot\/share\/c1\/c1_Instruction.hpp","additions":128,"deletions":128,"binary":false,"changes":256,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n-  if (n == NULL || type > T_VOID) {\n+  if (n == nullptr || type > T_VOID) {\n@@ -57,1 +57,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -105,1 +105,1 @@\n-  Phi* phi = v ? v->as_Phi() : NULL;\n+  Phi* phi = v ? v->as_Phi() : nullptr;\n@@ -114,1 +114,1 @@\n-  Phi* phi = v ? v->as_Phi() : NULL;\n+  Phi* phi = v ? v->as_Phi() : nullptr;\n@@ -126,1 +126,1 @@\n-  if (type->as_ObjectConstant() != NULL) {\n+  if (type->as_ObjectConstant() != nullptr) {\n@@ -137,1 +137,1 @@\n-  } else if (type->as_InstanceConstant() != NULL) {\n+  } else if (type->as_InstanceConstant() != nullptr) {\n@@ -146,1 +146,1 @@\n-  } else if (type->as_ArrayConstant() != NULL) {\n+  } else if (type->as_ArrayConstant() != nullptr) {\n@@ -148,1 +148,1 @@\n-  } else if (type->as_ClassConstant() != NULL) {\n+  } else if (type->as_ClassConstant() != nullptr) {\n@@ -155,1 +155,1 @@\n-  } else if (type->as_MethodConstant() != NULL) {\n+  } else if (type->as_MethodConstant() != nullptr) {\n@@ -180,1 +180,1 @@\n-  if (indexed->length() != NULL) {\n+  if (indexed->length() != nullptr) {\n@@ -203,2 +203,2 @@\n-  if (value == NULL) {\n-    output()->print(\"NULL\");\n+  if (value == nullptr) {\n+    output()->print(\"null\");\n@@ -228,1 +228,1 @@\n-      if (phi != NULL) {\n+      if (phi != nullptr) {\n@@ -247,1 +247,1 @@\n-      if (t == NULL) {\n+      if (t == nullptr) {\n@@ -283,1 +283,1 @@\n-      else output()->print(\"NULL\");\n+      else output()->print(\"null\");\n@@ -327,1 +327,1 @@\n-  if (split != NULL && split->state() != NULL && !split->state()->stack_is_empty()) {\n+  if (split != nullptr && split->state() != nullptr && !split->state()->stack_is_empty()) {\n@@ -467,1 +467,1 @@\n-  if (x->receiver() != NULL) {\n+  if (x->receiver() != nullptr) {\n@@ -535,2 +535,2 @@\n-  if (strchr(name, '_') == NULL) {\n-    kname = NULL;\n+  if (strchr(name, '_') == nullptr) {\n+    kname = nullptr;\n@@ -539,1 +539,1 @@\n-    if (kptr != NULL)  kname = kptr + 1;\n+    if (kptr != nullptr)  kname = kptr + 1;\n@@ -541,1 +541,1 @@\n-  if (kname == NULL)\n+  if (kname == nullptr)\n@@ -591,1 +591,1 @@\n-  output()->print(\"[%d, %d]\", x->bci(), (end == NULL ? -1 : end->printable_bci()));\n+  output()->print(\"[%d, %d]\", x->bci(), (end == nullptr ? -1 : end->printable_bci()));\n@@ -594,1 +594,1 @@\n-  if (end != NULL && end->number_of_sux() > 0) {\n+  if (end != nullptr && end->number_of_sux() > 0) {\n@@ -611,1 +611,1 @@\n-  if (x->dominator() != NULL) {\n+  if (x->dominator() != nullptr) {\n@@ -648,1 +648,1 @@\n-    } while (state != NULL);\n+    } while (state != nullptr);\n@@ -670,1 +670,1 @@\n-    } while (state != NULL);\n+    } while (state != nullptr);\n@@ -751,1 +751,1 @@\n-  if (x->result() == NULL) {\n+  if (x->result() == nullptr) {\n@@ -810,1 +810,1 @@\n-  if (x->x() != NULL && x->y() != NULL) {\n+  if (x->x() != nullptr && x->y() != nullptr) {\n@@ -834,1 +834,1 @@\n-  if (x->known_holder() != NULL) {\n+  if (x->known_holder() != nullptr) {\n","filename":"src\/hotspot\/share\/c1\/c1_InstructionPrinter.cpp","additions":30,"deletions":30,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -56,3 +56,3 @@\n-    if (c != NULL && !c->value()->is_loaded()) {\n-      return LIR_OprFact::metadataConst(NULL);\n-    } else if (c != NULL) {\n+    if (c != nullptr && !c->value()->is_loaded()) {\n+      return LIR_OprFact::metadataConst(nullptr);\n+    } else if (c != nullptr) {\n@@ -62,1 +62,1 @@\n-      assert (m != NULL, \"not a class or a method?\");\n+      assert (m != nullptr, \"not a class or a method?\");\n@@ -239,1 +239,1 @@\n-  : LIR_Op2(lir_branch, cond, LIR_OprFact::illegalOpr, LIR_OprFact::illegalOpr, (CodeEmitInfo*)NULL)\n+  : LIR_Op2(lir_branch, cond, LIR_OprFact::illegalOpr, LIR_OprFact::illegalOpr, (CodeEmitInfo*)nullptr)\n@@ -242,2 +242,2 @@\n-  , _ublock(NULL)\n-  , _stub(NULL) {\n+  , _ublock(nullptr)\n+  , _stub(nullptr) {\n@@ -247,1 +247,1 @@\n-  LIR_Op2(lir_branch, cond, LIR_OprFact::illegalOpr, LIR_OprFact::illegalOpr, (CodeEmitInfo*)NULL)\n+  LIR_Op2(lir_branch, cond, LIR_OprFact::illegalOpr, LIR_OprFact::illegalOpr, (CodeEmitInfo*)nullptr)\n@@ -249,2 +249,2 @@\n-  , _block(NULL)\n-  , _ublock(NULL)\n+  , _block(nullptr)\n+  , _ublock(nullptr)\n@@ -255,1 +255,1 @@\n-  : LIR_Op2(lir_cond_float_branch, cond, LIR_OprFact::illegalOpr, LIR_OprFact::illegalOpr, (CodeEmitInfo*)NULL)\n+  : LIR_Op2(lir_cond_float_branch, cond, LIR_OprFact::illegalOpr, LIR_OprFact::illegalOpr, (CodeEmitInfo*)nullptr)\n@@ -259,1 +259,1 @@\n-  , _stub(NULL)\n+  , _stub(nullptr)\n@@ -264,1 +264,1 @@\n-  assert(_block != NULL, \"must have old block\");\n+  assert(_block != nullptr, \"must have old block\");\n@@ -272,1 +272,1 @@\n-  assert(_ublock != NULL, \"must have old block\");\n+  assert(_ublock != nullptr, \"must have old block\");\n@@ -294,1 +294,1 @@\n-  : LIR_Op(code, result, NULL)\n+  : LIR_Op(code, result, nullptr)\n@@ -305,1 +305,1 @@\n-  , _profiled_method(NULL)\n+  , _profiled_method(nullptr)\n@@ -310,1 +310,1 @@\n-    assert(info_for_exception != NULL, \"checkcast throws exceptions\");\n+    assert(info_for_exception != nullptr, \"checkcast throws exceptions\");\n@@ -312,1 +312,1 @@\n-    assert(info_for_exception == NULL, \"instanceof throws no exceptions\");\n+    assert(info_for_exception == nullptr, \"instanceof throws no exceptions\");\n@@ -321,1 +321,1 @@\n-  : LIR_Op(code, LIR_OprFact::illegalOpr, NULL)\n+  : LIR_Op(code, LIR_OprFact::illegalOpr, nullptr)\n@@ -324,1 +324,1 @@\n-  , _klass(NULL)\n+  , _klass(nullptr)\n@@ -329,1 +329,1 @@\n-  , _info_for_patch(NULL)\n+  , _info_for_patch(nullptr)\n@@ -331,2 +331,2 @@\n-  , _stub(NULL)\n-  , _profiled_method(NULL)\n+  , _stub(nullptr)\n+  , _profiled_method(nullptr)\n@@ -338,1 +338,1 @@\n-    assert(info_for_exception != NULL, \"store_check throws exceptions\");\n+    assert(info_for_exception != nullptr, \"store_check throws exceptions\");\n@@ -360,1 +360,1 @@\n-  : LIR_Op(lir_updatecrc32, res, NULL)\n+  : LIR_Op(lir_updatecrc32, res, nullptr)\n@@ -412,2 +412,2 @@\n-      assert(op->as_Op0() != NULL, \"must be\");\n-      assert(op->_info == NULL, \"info not used by this instruction\");\n+      assert(op->as_Op0() != nullptr, \"must be\");\n+      assert(op->_info == nullptr, \"info not used by this instruction\");\n@@ -423,2 +423,2 @@\n-      assert(op->as_Op0() != NULL, \"must be\");\n-      if (op->_info != NULL)           do_info(op->_info);\n+      assert(op->as_Op0() != nullptr, \"must be\");\n+      if (op->_info != nullptr)           do_info(op->_info);\n@@ -433,2 +433,2 @@\n-      assert(op->as_OpLabel() != NULL, \"must be\");\n-      assert(op->_info == NULL, \"info not used by this instruction\");\n+      assert(op->as_OpLabel() != nullptr, \"must be\");\n+      assert(op->_info == nullptr, \"info not used by this instruction\");\n@@ -450,1 +450,1 @@\n-      assert(op->as_Op1() != NULL, \"must be\");\n+      assert(op->as_Op1() != nullptr, \"must be\");\n@@ -462,1 +462,1 @@\n-      assert(op->as_OpReturn() != NULL, \"must be\");\n+      assert(op->as_OpReturn() != nullptr, \"must be\");\n@@ -468,1 +468,1 @@\n-      if (op_ret->stub() != NULL)      do_stub(op_ret->stub());\n+      if (op_ret->stub() != nullptr)      do_stub(op_ret->stub());\n@@ -475,1 +475,1 @@\n-      assert(op->as_Op1() != NULL, \"must be\");\n+      assert(op->as_Op1() != nullptr, \"must be\");\n@@ -478,1 +478,1 @@\n-      assert(op1->_info != NULL, \"\");  do_info(op1->_info);\n+      assert(op1->_info != nullptr, \"\");  do_info(op1->_info);\n@@ -488,1 +488,1 @@\n-      assert(op->as_OpConvert() != NULL, \"must be\");\n+      assert(op->as_OpConvert() != nullptr, \"must be\");\n@@ -491,1 +491,1 @@\n-      assert(opConvert->_info == NULL, \"must be\");\n+      assert(opConvert->_info == nullptr, \"must be\");\n@@ -503,1 +503,1 @@\n-      assert(op->as_OpBranch() != NULL, \"must be\");\n+      assert(op->as_OpBranch() != nullptr, \"must be\");\n@@ -513,1 +513,1 @@\n-      if (opBranch->_info != NULL)     do_info(opBranch->_info);\n+      if (opBranch->_info != nullptr)  do_info(opBranch->_info);\n@@ -515,1 +515,1 @@\n-      if (opBranch->_stub != NULL)     opBranch->stub()->visit(this);\n+      if (opBranch->_stub != nullptr)  opBranch->stub()->visit(this);\n@@ -524,1 +524,1 @@\n-      assert(op->as_OpAllocObj() != NULL, \"must be\");\n+      assert(op->as_OpAllocObj() != nullptr, \"must be\");\n@@ -543,1 +543,1 @@\n-      assert(op->as_OpRoundFP() != NULL, \"must be\");\n+      assert(op->as_OpRoundFP() != nullptr, \"must be\");\n@@ -546,1 +546,1 @@\n-      assert(op->_info == NULL, \"info not used by this instruction\");\n+      assert(op->_info == nullptr, \"info not used by this instruction\");\n@@ -578,1 +578,1 @@\n-      assert(op->as_Op2() != NULL, \"must be\");\n+      assert(op->as_Op2() != nullptr, \"must be\");\n@@ -603,1 +603,1 @@\n-      assert(op->as_Op4() != NULL, \"must be\");\n+      assert(op->as_Op4() != nullptr, \"must be\");\n@@ -606,1 +606,1 @@\n-      assert(op4->_info == NULL && op4->_tmp1->is_illegal() && op4->_tmp2->is_illegal() &&\n+      assert(op4->_info == nullptr && op4->_tmp1->is_illegal() && op4->_tmp2->is_illegal() &&\n@@ -626,1 +626,1 @@\n-      assert(op->as_Op2() != NULL, \"must be\");\n+      assert(op->as_Op2() != nullptr, \"must be\");\n@@ -629,1 +629,1 @@\n-      assert(op2->_info == NULL, \"not used\");\n+      assert(op2->_info == nullptr, \"not used\");\n@@ -645,1 +645,1 @@\n-      assert(op->as_Op2() != NULL, \"must be\");\n+      assert(op->as_Op2() != nullptr, \"must be\");\n@@ -659,1 +659,1 @@\n-      assert(op->as_Op1() != NULL, \"must be\");\n+      assert(op->as_Op1() != nullptr, \"must be\");\n@@ -662,1 +662,1 @@\n-      assert(op1->_info == NULL, \"no info\");\n+      assert(op1->_info == nullptr, \"no info\");\n@@ -672,1 +672,1 @@\n-      assert(op->as_Op3() != NULL, \"must be\");\n+      assert(op->as_Op3() != nullptr, \"must be\");\n@@ -691,1 +691,1 @@\n-      assert(op->as_Op3() != NULL, \"must be\");\n+      assert(op->as_Op3() != nullptr, \"must be\");\n@@ -693,1 +693,1 @@\n-      assert(op3->_info == NULL, \"no info\");\n+      assert(op3->_info == nullptr, \"no info\");\n@@ -707,1 +707,1 @@\n-      assert(opJavaCall != NULL, \"must be\");\n+      assert(opJavaCall != nullptr, \"must be\");\n@@ -734,1 +734,1 @@\n-      assert(op->as_OpRTCall() != NULL, \"must be\");\n+      assert(op->as_OpRTCall() != nullptr, \"must be\");\n@@ -755,1 +755,1 @@\n-      assert(op->as_OpArrayCopy() != NULL, \"must be\");\n+      assert(op->as_OpArrayCopy() != nullptr, \"must be\");\n@@ -776,1 +776,1 @@\n-      assert(op->as_OpUpdateCRC32() != NULL, \"must be\");\n+      assert(op->as_OpUpdateCRC32() != nullptr, \"must be\");\n@@ -782,1 +782,1 @@\n-      assert(opUp->_info == NULL, \"no info for LIR_OpUpdateCRC32\");\n+      assert(opUp->_info == nullptr, \"no info for LIR_OpUpdateCRC32\");\n@@ -791,1 +791,1 @@\n-      assert(op->as_OpLock() != NULL, \"must be\");\n+      assert(op->as_OpLock() != nullptr, \"must be\");\n@@ -813,1 +813,1 @@\n-      assert(op->as_OpDelay() != NULL, \"must be\");\n+      assert(op->as_OpDelay() != nullptr, \"must be\");\n@@ -824,1 +824,1 @@\n-      assert(op->as_OpTypeCheck() != NULL, \"must be\");\n+      assert(op->as_OpTypeCheck() != nullptr, \"must be\");\n@@ -846,1 +846,1 @@\n-      assert(op->as_OpCompareAndSwap() != NULL, \"must be\");\n+      assert(op->as_OpCompareAndSwap() != nullptr, \"must be\");\n@@ -866,1 +866,1 @@\n-      assert(op->as_OpAllocArray() != NULL, \"must be\");\n+      assert(op->as_OpAllocArray() != nullptr, \"must be\");\n@@ -889,1 +889,1 @@\n-      assert(opLoadKlass != NULL, \"must be\");\n+      assert(opLoadKlass != nullptr, \"must be\");\n@@ -900,1 +900,1 @@\n-      assert(op->as_OpProfileCall() != NULL, \"must be\");\n+      assert(op->as_OpProfileCall() != nullptr, \"must be\");\n@@ -911,1 +911,1 @@\n-      assert(op->as_OpProfileType() != NULL, \"must be\");\n+      assert(op->as_OpProfileType() != nullptr, \"must be\");\n@@ -929,1 +929,1 @@\n-  if (stub != NULL) {\n+  if (stub != nullptr) {\n@@ -935,1 +935,1 @@\n-  XHandlers* result = NULL;\n+  XHandlers* result = nullptr;\n@@ -939,1 +939,1 @@\n-    if (info_at(i)->exception_handlers() != NULL) {\n+    if (info_at(i)->exception_handlers() != nullptr) {\n@@ -947,1 +947,1 @@\n-    assert(info_at(i)->exception_handlers() == NULL ||\n+    assert(info_at(i)->exception_handlers() == nullptr ||\n@@ -953,1 +953,1 @@\n-  if (result != NULL) {\n+  if (result != nullptr) {\n@@ -978,2 +978,2 @@\n-    LIR_Op1(lir_return, opr, (CodeEmitInfo*)NULL \/* info *\/),\n-    _stub(NULL) {\n+    LIR_Op1(lir_return, opr, (CodeEmitInfo*)nullptr \/* info *\/),\n+    _stub(nullptr) {\n@@ -1031,1 +1031,1 @@\n-  if (stub() != NULL) {\n+  if (stub() != nullptr) {\n@@ -1101,1 +1101,1 @@\n-  , _file(NULL)\n+  , _file(nullptr)\n@@ -1114,2 +1114,2 @@\n-  if (f == NULL) f = strrchr(file, '\\\\');\n-  if (f == NULL) {\n+  if (f == nullptr) f = strrchr(file, '\\\\');\n+  if (f == nullptr) {\n@@ -1164,1 +1164,1 @@\n-    _operations.at_grow(n + buffer->number_of_ops() - 1, NULL);\n+    _operations.at_grow(n + buffer->number_of_ops() - 1, nullptr);\n@@ -1429,1 +1429,1 @@\n-                    NULL));\n+                    nullptr));\n@@ -1446,1 +1446,1 @@\n-  if (profiled_method != NULL) {\n+  if (profiled_method != nullptr) {\n@@ -1455,2 +1455,2 @@\n-  LIR_OpTypeCheck* c = new LIR_OpTypeCheck(lir_instanceof, result, object, klass, tmp1, tmp2, tmp3, fast_check, NULL, info_for_patch, NULL);\n-  if (profiled_method != NULL) {\n+  LIR_OpTypeCheck* c = new LIR_OpTypeCheck(lir_instanceof, result, object, klass, tmp1, tmp2, tmp3, fast_check, nullptr, info_for_patch, nullptr);\n+  if (profiled_method != nullptr) {\n@@ -1468,1 +1468,1 @@\n-  if (profiled_method != NULL) {\n+  if (profiled_method != nullptr) {\n@@ -1480,1 +1480,1 @@\n-    cmp(lir_cond_equal, opr, LIR_OprFact::oopConst(NULL));\n+    cmp(lir_cond_equal, opr, LIR_OprFact::oopConst(nullptr));\n@@ -1621,1 +1621,1 @@\n-  tty->print(\"[%d, %d] \", x->bci(), (end == NULL ? -1 : end->printable_bci()));\n+  tty->print(\"[%d, %d] \", x->bci(), (end == nullptr ? -1 : end->printable_bci()));\n@@ -1631,1 +1631,1 @@\n-  if (end != NULL && x->number_of_sux() > 0) {\n+  if (end != nullptr && x->number_of_sux() > 0) {\n@@ -1677,1 +1677,1 @@\n-  if (info() != NULL) out->print(\" [bci:%d]\", info()->stack()->bci());\n+  if (info() != nullptr) out->print(\" [bci:%d]\", info()->stack()->bci());\n@@ -1679,1 +1679,1 @@\n-  if (Verbose && _file != NULL) {\n+  if (Verbose && _file != nullptr) {\n@@ -1686,1 +1686,1 @@\n-  const char* s = NULL;\n+  const char* s = nullptr;\n@@ -1889,1 +1889,1 @@\n-  if (block() != NULL) {\n+  if (block() != nullptr) {\n@@ -1891,1 +1891,1 @@\n-  } else if (stub() != NULL) {\n+  } else if (stub() != nullptr) {\n@@ -1895,1 +1895,1 @@\n-    if (stub()->info() != NULL) out->print(\" [bci:%d]\", stub()->info()->stack()->bci());\n+    if (stub()->info() != nullptr) out->print(\" [bci:%d]\", stub()->info()->stack()->bci());\n@@ -1899,1 +1899,1 @@\n-  if (ublock() != NULL) {\n+  if (ublock() != nullptr) {\n@@ -2008,1 +2008,1 @@\n-  if (info_for_exception() != NULL) out->print(\" [bci:%d]\", info_for_exception()->stack()->bci());\n+  if (info_for_exception() != nullptr) out->print(\" [bci:%d]\", info_for_exception()->stack()->bci());\n@@ -2074,1 +2074,1 @@\n-  if  (exact_klass() == NULL) {\n+  if (exact_klass() == nullptr) {\n","filename":"src\/hotspot\/share\/c1\/c1_LIR.cpp","additions":97,"deletions":97,"binary":false,"changes":194,"status":"modified"},{"patch":"@@ -71,2 +71,2 @@\n-  virtual LIR_Const*  as_constant()              { return NULL; }\n-  virtual LIR_Address* as_address()              { return NULL; }\n+  virtual LIR_Const*  as_constant()              { return nullptr; }\n+  virtual LIR_Address* as_address()              { return nullptr; }\n@@ -387,2 +387,2 @@\n-  bool is_constant() const     { return is_pointer() && pointer()->as_constant() != NULL; }\n-  bool is_address() const      { return is_pointer() && pointer()->as_address() != NULL; }\n+  bool is_constant() const     { return is_pointer() && pointer()->as_constant() != nullptr; }\n+  bool is_address() const      { return is_pointer() && pointer()->as_address() != nullptr; }\n@@ -1088,1 +1088,1 @@\n-      _file(NULL)\n+      _file(nullptr)\n@@ -1094,1 +1094,1 @@\n-    , _info(NULL)\n+    , _info(nullptr)\n@@ -1097,1 +1097,1 @@\n-    , _source(NULL) {}\n+    , _source(nullptr) {}\n@@ -1102,1 +1102,1 @@\n-      _file(NULL)\n+      _file(nullptr)\n@@ -1111,1 +1111,1 @@\n-    , _source(NULL) {}\n+    , _source(nullptr) {}\n@@ -1144,24 +1144,24 @@\n-  virtual LIR_OpCall* as_OpCall() { return NULL; }\n-  virtual LIR_OpJavaCall* as_OpJavaCall() { return NULL; }\n-  virtual LIR_OpLabel* as_OpLabel() { return NULL; }\n-  virtual LIR_OpDelay* as_OpDelay() { return NULL; }\n-  virtual LIR_OpLock* as_OpLock() { return NULL; }\n-  virtual LIR_OpAllocArray* as_OpAllocArray() { return NULL; }\n-  virtual LIR_OpAllocObj* as_OpAllocObj() { return NULL; }\n-  virtual LIR_OpRoundFP* as_OpRoundFP() { return NULL; }\n-  virtual LIR_OpBranch* as_OpBranch() { return NULL; }\n-  virtual LIR_OpReturn* as_OpReturn() { return NULL; }\n-  virtual LIR_OpRTCall* as_OpRTCall() { return NULL; }\n-  virtual LIR_OpConvert* as_OpConvert() { return NULL; }\n-  virtual LIR_Op0* as_Op0() { return NULL; }\n-  virtual LIR_Op1* as_Op1() { return NULL; }\n-  virtual LIR_Op2* as_Op2() { return NULL; }\n-  virtual LIR_Op3* as_Op3() { return NULL; }\n-  virtual LIR_Op4* as_Op4() { return NULL; }\n-  virtual LIR_OpArrayCopy* as_OpArrayCopy() { return NULL; }\n-  virtual LIR_OpUpdateCRC32* as_OpUpdateCRC32() { return NULL; }\n-  virtual LIR_OpTypeCheck* as_OpTypeCheck() { return NULL; }\n-  virtual LIR_OpCompareAndSwap* as_OpCompareAndSwap() { return NULL; }\n-  virtual LIR_OpLoadKlass* as_OpLoadKlass() { return NULL; }\n-  virtual LIR_OpProfileCall* as_OpProfileCall() { return NULL; }\n-  virtual LIR_OpProfileType* as_OpProfileType() { return NULL; }\n+  virtual LIR_OpCall* as_OpCall() { return nullptr; }\n+  virtual LIR_OpJavaCall* as_OpJavaCall() { return nullptr; }\n+  virtual LIR_OpLabel* as_OpLabel() { return nullptr; }\n+  virtual LIR_OpDelay* as_OpDelay() { return nullptr; }\n+  virtual LIR_OpLock* as_OpLock() { return nullptr; }\n+  virtual LIR_OpAllocArray* as_OpAllocArray() { return nullptr; }\n+  virtual LIR_OpAllocObj* as_OpAllocObj() { return nullptr; }\n+  virtual LIR_OpRoundFP* as_OpRoundFP() { return nullptr; }\n+  virtual LIR_OpBranch* as_OpBranch() { return nullptr; }\n+  virtual LIR_OpReturn* as_OpReturn() { return nullptr; }\n+  virtual LIR_OpRTCall* as_OpRTCall() { return nullptr; }\n+  virtual LIR_OpConvert* as_OpConvert() { return nullptr; }\n+  virtual LIR_Op0* as_Op0() { return nullptr; }\n+  virtual LIR_Op1* as_Op1() { return nullptr; }\n+  virtual LIR_Op2* as_Op2() { return nullptr; }\n+  virtual LIR_Op3* as_Op3() { return nullptr; }\n+  virtual LIR_Op4* as_Op4() { return nullptr; }\n+  virtual LIR_OpArrayCopy* as_OpArrayCopy() { return nullptr; }\n+  virtual LIR_OpUpdateCRC32* as_OpUpdateCRC32() { return nullptr; }\n+  virtual LIR_OpTypeCheck* as_OpTypeCheck() { return nullptr; }\n+  virtual LIR_OpCompareAndSwap* as_OpCompareAndSwap() { return nullptr; }\n+  virtual LIR_OpLoadKlass* as_OpLoadKlass() { return nullptr; }\n+  virtual LIR_OpProfileCall* as_OpProfileCall() { return nullptr; }\n+  virtual LIR_OpProfileType* as_OpProfileType() { return nullptr; }\n@@ -1169,1 +1169,1 @@\n-  virtual LIR_OpAssert* as_OpAssert() { return NULL; }\n+  virtual LIR_OpAssert* as_OpAssert() { return nullptr; }\n@@ -1184,1 +1184,1 @@\n-             LIR_OprList* arguments, CodeEmitInfo* info = NULL)\n+             LIR_OprList* arguments, CodeEmitInfo* info = nullptr)\n@@ -1253,1 +1253,1 @@\n-   : LIR_Op(lir_label, LIR_OprFact::illegalOpr, NULL)\n+   : LIR_Op(lir_label, LIR_OprFact::illegalOpr, nullptr)\n@@ -1340,2 +1340,2 @@\n-   : LIR_Op(code, LIR_OprFact::illegalOpr, NULL)  { assert(is_in_range(code, begin_op0, end_op0), \"code check\"); }\n-  LIR_Op0(LIR_Code code, LIR_Opr result, CodeEmitInfo* info = NULL)\n+   : LIR_Op(code, LIR_OprFact::illegalOpr, nullptr)  { assert(is_in_range(code, begin_op0, end_op0), \"code check\"); }\n+  LIR_Op0(LIR_Code code, LIR_Opr result, CodeEmitInfo* info = nullptr)\n@@ -1370,1 +1370,1 @@\n-  LIR_Op1(LIR_Code code, LIR_Opr opr, LIR_Opr result = LIR_OprFact::illegalOpr, BasicType type = T_ILLEGAL, LIR_PatchCode patch = lir_patch_none, CodeEmitInfo* info = NULL)\n+  LIR_Op1(LIR_Code code, LIR_Opr opr, LIR_Opr result = LIR_OprFact::illegalOpr, BasicType type = T_ILLEGAL, LIR_PatchCode patch = lir_patch_none, CodeEmitInfo* info = nullptr)\n@@ -1420,1 +1420,1 @@\n-               LIR_Opr result, LIR_OprList* arguments, CodeEmitInfo* info = NULL)\n+               LIR_Opr result, LIR_OprList* arguments, CodeEmitInfo* info = nullptr)\n@@ -1581,1 +1581,1 @@\n-  virtual bool is_patching() { return _info_for_patch != NULL; }\n+  virtual bool is_patching() { return _info_for_patch != nullptr; }\n@@ -1607,1 +1607,1 @@\n-  LIR_Op2(LIR_Code code, LIR_Condition condition, LIR_Opr opr1, LIR_Opr opr2, CodeEmitInfo* info = NULL, BasicType type = T_ILLEGAL)\n+  LIR_Op2(LIR_Code code, LIR_Condition condition, LIR_Opr opr1, LIR_Opr opr2, CodeEmitInfo* info = nullptr, BasicType type = T_ILLEGAL)\n@@ -1623,1 +1623,1 @@\n-    : LIR_Op(code, result, NULL)\n+    : LIR_Op(code, result, nullptr)\n@@ -1639,1 +1639,1 @@\n-          CodeEmitInfo* info = NULL, BasicType type = T_ILLEGAL)\n+          CodeEmitInfo* info = nullptr, BasicType type = T_ILLEGAL)\n@@ -1656,1 +1656,1 @@\n-    : LIR_Op(code, result, NULL)\n+    : LIR_Op(code, result, nullptr)\n@@ -1707,1 +1707,1 @@\n-    : LIR_Op2(lir_branch, cond, LIR_OprFact::illegalOpr, LIR_OprFact::illegalOpr, (CodeEmitInfo*) NULL)\n+    : LIR_Op2(lir_branch, cond, LIR_OprFact::illegalOpr, LIR_OprFact::illegalOpr, (CodeEmitInfo*) nullptr)\n@@ -1709,3 +1709,3 @@\n-    , _block(NULL)\n-    , _ublock(NULL)\n-    , _stub(NULL) { }\n+    , _block(nullptr)\n+    , _ublock(nullptr)\n+    , _stub(nullptr) { }\n@@ -1756,1 +1756,1 @@\n-    : LIR_Op(lir_alloc_array, result, NULL)\n+    : LIR_Op(lir_alloc_array, result, nullptr)\n@@ -1790,1 +1790,1 @@\n-  LIR_Op3(LIR_Code code, LIR_Opr opr1, LIR_Opr opr2, LIR_Opr opr3, LIR_Opr result, CodeEmitInfo* info = NULL)\n+  LIR_Op3(LIR_Code code, LIR_Opr opr1, LIR_Opr opr2, LIR_Opr opr3, LIR_Opr result, CodeEmitInfo* info = nullptr)\n@@ -1822,1 +1822,1 @@\n-    : LIR_Op(code, result, NULL)\n+    : LIR_Op(code, result, nullptr)\n@@ -1977,1 +1977,1 @@\n-    : LIR_Op(code, result, NULL)  \/\/ no result, no info\n+    : LIR_Op(code, result, nullptr)  \/\/ no result, no info\n@@ -2011,1 +2011,1 @@\n-    : LIR_Op(lir_profile_call, LIR_OprFact::illegalOpr, NULL)  \/\/ no result, no info\n+    : LIR_Op(lir_profile_call, LIR_OprFact::illegalOpr, nullptr)  \/\/ no result, no info\n@@ -2047,1 +2047,1 @@\n-  ciKlass*     _exact_klass;   \/\/ non NULL if we know the klass statically (no need to load it from _obj)\n+  ciKlass*     _exact_klass;   \/\/ non null if we know the klass statically (no need to load it from _obj)\n@@ -2050,1 +2050,1 @@\n-  bool         _no_conflict;   \/\/ true if we're profling parameters, _exact_klass is not NULL and we know\n+  bool         _no_conflict;   \/\/ true if we're profling parameters, _exact_klass is not null and we know\n@@ -2056,1 +2056,1 @@\n-    : LIR_Op(lir_profile_type, LIR_OprFact::illegalOpr, NULL)  \/\/ no result, no info\n+    : LIR_Op(lir_profile_type, LIR_OprFact::illegalOpr, nullptr)  \/\/ no result, no info\n@@ -2107,1 +2107,1 @@\n-    if (op->source() == NULL)\n+    if (op->source() == nullptr)\n@@ -2127,1 +2127,1 @@\n-    _file = NULL;\n+    _file = nullptr;\n@@ -2132,1 +2132,1 @@\n-  LIR_List(Compilation* compilation, BlockBegin* block = NULL);\n+  LIR_List(Compilation* compilation, BlockBegin* block = nullptr);\n@@ -2198,1 +2198,1 @@\n-  void leal(LIR_Opr from, LIR_Opr result_reg, LIR_PatchCode patch_code = lir_patch_none, CodeEmitInfo* info = NULL) { append(new LIR_Op1(lir_leal, from, result_reg, T_ILLEGAL, patch_code, info)); }\n+  void leal(LIR_Opr from, LIR_Opr result_reg, LIR_PatchCode patch_code = lir_patch_none, CodeEmitInfo* info = nullptr) { append(new LIR_Op1(lir_leal, from, result_reg, T_ILLEGAL, patch_code, info)); }\n@@ -2203,4 +2203,4 @@\n-  void move(LIR_Opr src, LIR_Opr dst, CodeEmitInfo* info = NULL) { append(new LIR_Op1(lir_move, src, dst, dst->type(), lir_patch_none, info)); }\n-  void move(LIR_Address* src, LIR_Opr dst, CodeEmitInfo* info = NULL) { append(new LIR_Op1(lir_move, LIR_OprFact::address(src), dst, src->type(), lir_patch_none, info)); }\n-  void move(LIR_Opr src, LIR_Address* dst, CodeEmitInfo* info = NULL) { append(new LIR_Op1(lir_move, src, LIR_OprFact::address(dst), dst->type(), lir_patch_none, info)); }\n-  void move_wide(LIR_Address* src, LIR_Opr dst, CodeEmitInfo* info = NULL) {\n+  void move(LIR_Opr src, LIR_Opr dst, CodeEmitInfo* info = nullptr) { append(new LIR_Op1(lir_move, src, dst, dst->type(), lir_patch_none, info)); }\n+  void move(LIR_Address* src, LIR_Opr dst, CodeEmitInfo* info = nullptr) { append(new LIR_Op1(lir_move, LIR_OprFact::address(src), dst, src->type(), lir_patch_none, info)); }\n+  void move(LIR_Opr src, LIR_Address* dst, CodeEmitInfo* info = nullptr) { append(new LIR_Op1(lir_move, src, LIR_OprFact::address(dst), dst->type(), lir_patch_none, info)); }\n+  void move_wide(LIR_Address* src, LIR_Opr dst, CodeEmitInfo* info = nullptr) {\n@@ -2213,1 +2213,1 @@\n-  void move_wide(LIR_Opr src, LIR_Address* dst, CodeEmitInfo* info = NULL) {\n+  void move_wide(LIR_Opr src, LIR_Address* dst, CodeEmitInfo* info = nullptr) {\n@@ -2220,1 +2220,1 @@\n-  void volatile_move(LIR_Opr src, LIR_Opr dst, BasicType type, CodeEmitInfo* info = NULL, LIR_PatchCode patch_code = lir_patch_none) { append(new LIR_Op1(lir_move, src, dst, type, patch_code, info, lir_move_volatile)); }\n+  void volatile_move(LIR_Opr src, LIR_Opr dst, BasicType type, CodeEmitInfo* info = nullptr, LIR_PatchCode patch_code = lir_patch_none) { append(new LIR_Op1(lir_move, src, dst, type, patch_code, info, lir_move_volatile)); }\n@@ -2231,1 +2231,1 @@\n-  void convert(Bytecodes::Code code, LIR_Opr left, LIR_Opr dst, ConversionStub* stub = NULL\/*, bool is_32bit = false*\/) { append(new LIR_OpConvert(code, left, dst, stub)); }\n+  void convert(Bytecodes::Code code, LIR_Opr left, LIR_Opr dst, ConversionStub* stub = nullptr\/*, bool is_32bit = false*\/) { append(new LIR_OpConvert(code, left, dst, stub)); }\n@@ -2248,1 +2248,1 @@\n-  void cmp(LIR_Condition condition, LIR_Opr left, LIR_Opr right, CodeEmitInfo* info = NULL) {\n+  void cmp(LIR_Condition condition, LIR_Opr left, LIR_Opr right, CodeEmitInfo* info = nullptr) {\n@@ -2251,1 +2251,1 @@\n-  void cmp(LIR_Condition condition, LIR_Opr left, int right, CodeEmitInfo* info = NULL) {\n+  void cmp(LIR_Condition condition, LIR_Opr left, int right, CodeEmitInfo* info = nullptr) {\n@@ -2281,1 +2281,1 @@\n-  void sub (LIR_Opr left, LIR_Opr right, LIR_Opr res, CodeEmitInfo* info = NULL) { append(new LIR_Op2(lir_sub, left, right, res, info)); }\n+  void sub (LIR_Opr left, LIR_Opr right, LIR_Opr res, CodeEmitInfo* info = nullptr) { append(new LIR_Op2(lir_sub, left, right, res, info)); }\n@@ -2284,1 +2284,1 @@\n-  void div (LIR_Opr left, LIR_Opr right, LIR_Opr res, CodeEmitInfo* info = NULL)      { append(new LIR_Op2(lir_div, left, right, res, info)); }\n+  void div (LIR_Opr left, LIR_Opr right, LIR_Opr res, CodeEmitInfo* info = nullptr)      { append(new LIR_Op2(lir_div, left, right, res, info)); }\n@@ -2286,1 +2286,1 @@\n-  void rem (LIR_Opr left, LIR_Opr right, LIR_Opr res, CodeEmitInfo* info = NULL)      { append(new LIR_Op2(lir_rem, left, right, res, info)); }\n+  void rem (LIR_Opr left, LIR_Opr right, LIR_Opr res, CodeEmitInfo* info = nullptr)      { append(new LIR_Op2(lir_rem, left, right, res, info)); }\n@@ -2291,1 +2291,1 @@\n-  void load(LIR_Address* addr, LIR_Opr src, CodeEmitInfo* info = NULL, LIR_PatchCode patch_code = lir_patch_none);\n+  void load(LIR_Address* addr, LIR_Opr src, CodeEmitInfo* info = nullptr, LIR_PatchCode patch_code = lir_patch_none);\n@@ -2295,1 +2295,1 @@\n-  void store(LIR_Opr src, LIR_Address* addr, CodeEmitInfo* info = NULL, LIR_PatchCode patch_code = lir_patch_none);\n+  void store(LIR_Opr src, LIR_Address* addr, CodeEmitInfo* info = nullptr, LIR_PatchCode patch_code = lir_patch_none);\n@@ -2389,1 +2389,1 @@\n-  LIR_List*   _lir;   \/\/ the lir list where ops of this buffer should be inserted later (NULL when uninitialized)\n+  LIR_List*   _lir;   \/\/ the lir list where ops of this buffer should be inserted later (null when uninitialized)\n@@ -2407,1 +2407,1 @@\n-  LIR_InsertionBuffer() : _lir(NULL), _index_and_count(8), _ops(8) { }\n+  LIR_InsertionBuffer() : _lir(nullptr), _index_and_count(8), _ops(8) { }\n@@ -2411,1 +2411,1 @@\n-  bool initialized() const  { return _lir != NULL; }\n+  bool initialized() const  { return _lir != nullptr; }\n@@ -2413,1 +2413,1 @@\n-  void finish()             { _lir = NULL; }\n+  void finish()             { _lir = nullptr; }\n@@ -2428,1 +2428,1 @@\n-  void move(int index, LIR_Opr src, LIR_Opr dst, CodeEmitInfo* info = NULL) { append(index, new LIR_Op1(lir_move, src, dst, dst->type(), lir_patch_none, info)); }\n+  void move(int index, LIR_Opr src, LIR_Opr dst, CodeEmitInfo* info = nullptr) { append(index, new LIR_Op1(lir_move, src, dst, dst->type(), lir_patch_none, info)); }\n@@ -2477,1 +2477,1 @@\n-      if (address != NULL) {\n+      if (address != nullptr) {\n@@ -2505,1 +2505,1 @@\n-    assert(info != NULL, \"should not call this otherwise\");\n+    assert(info != nullptr, \"should not call this otherwise\");\n@@ -2520,1 +2520,1 @@\n-    _op = NULL;\n+    _op = nullptr;\n","filename":"src\/hotspot\/share\/c1\/c1_LIR.hpp","additions":83,"deletions":83,"binary":false,"changes":166,"status":"modified"},{"patch":"@@ -109,2 +109,2 @@\n- , _current_block(NULL)\n- , _pending_non_safepoint(NULL)\n+ , _current_block(nullptr)\n+ , _pending_non_safepoint(nullptr)\n@@ -198,1 +198,1 @@\n-      assert(handler->entry_code() == NULL ||\n+      assert(handler->entry_code() == nullptr ||\n@@ -204,1 +204,1 @@\n-        if (handler->entry_code() != NULL && handler->entry_code()->instructions_list()->length() > 1) {\n+        if (handler->entry_code() != nullptr && handler->entry_code()->instructions_list()->length() > 1) {\n@@ -258,1 +258,1 @@\n-  assert(block->lir() != NULL, \"must have LIR\");\n+  assert(block->lir() != nullptr, \"must have LIR\");\n@@ -338,1 +338,1 @@\n-  if (info->exception_handlers() != NULL) {\n+  if (info->exception_handlers() != nullptr) {\n@@ -347,1 +347,1 @@\n-  if (cinfo->exception_handlers() != NULL) {\n+  if (cinfo->exception_handlers() != nullptr) {\n@@ -354,1 +354,1 @@\n-  if (ss != NULL) return ss->state();\n+  if (ss != nullptr) return ss->state();\n@@ -360,1 +360,1 @@\n-  if (src == NULL)  return;\n+  if (src == nullptr)  return;\n@@ -367,2 +367,2 @@\n-  if (vstack == NULL)  return;\n-  if (_pending_non_safepoint != NULL) {\n+  if (vstack == nullptr)  return;\n+  if (_pending_non_safepoint != nullptr) {\n@@ -377,1 +377,1 @@\n-    _pending_non_safepoint = NULL;\n+    _pending_non_safepoint = nullptr;\n@@ -387,1 +387,1 @@\n-\/\/ Return NULL if n is too large.\n+\/\/ Return null if n is too large.\n@@ -392,1 +392,1 @@\n-    if (t == NULL)  break;\n+    if (t == nullptr)  break;\n@@ -395,1 +395,1 @@\n-  if (t == NULL)  return NULL;\n+  if (t == nullptr)  return nullptr;\n@@ -398,1 +398,1 @@\n-    if (tc == NULL)  return s;\n+    if (tc == nullptr)  return s;\n@@ -419,1 +419,1 @@\n-    if (s == NULL)  break;\n+    if (s == nullptr)  break;\n@@ -531,1 +531,1 @@\n-      assert(op->as_OpReturn() != NULL, \"sanity\");\n+      assert(op->as_OpReturn() != nullptr, \"sanity\");\n@@ -534,1 +534,1 @@\n-      if (ret_op->stub() != NULL) {\n+      if (ret_op->stub() != nullptr) {\n@@ -601,1 +601,1 @@\n-      assert(op->info() == NULL, \"not supported\");\n+      assert(op->info() == nullptr, \"not supported\");\n@@ -686,1 +686,1 @@\n-      if (op->info() != NULL) {\n+      if (op->info() != nullptr) {\n@@ -793,1 +793,1 @@\n-      assert(patch_code == lir_patch_none && info == NULL, \"no patching and info allowed here\");\n+      assert(patch_code == lir_patch_none && info == nullptr, \"no patching and info allowed here\");\n@@ -796,1 +796,1 @@\n-      assert(patch_code == lir_patch_none && info == NULL, \"no patching and info allowed here\");\n+      assert(patch_code == lir_patch_none && info == nullptr, \"no patching and info allowed here\");\n@@ -805,1 +805,1 @@\n-    assert(patch_code == lir_patch_none && info == NULL, \"no patching and info allowed here\");\n+    assert(patch_code == lir_patch_none && info == nullptr, \"no patching and info allowed here\");\n@@ -818,1 +818,1 @@\n-      assert(patch_code == lir_patch_none && info == NULL, \"no patching and info allowed here\");\n+      assert(patch_code == lir_patch_none && info == nullptr, \"no patching and info allowed here\");\n","filename":"src\/hotspot\/share\/c1\/c1_LIRAssembler.cpp","additions":25,"deletions":25,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,1 +63,1 @@\n-    if (_pending_non_safepoint != NULL) {\n+    if (_pending_non_safepoint != nullptr) {\n@@ -66,1 +66,1 @@\n-      _pending_non_safepoint = NULL;\n+      _pending_non_safepoint = nullptr;\n@@ -240,1 +240,1 @@\n-  void leal(LIR_Opr src, LIR_Opr dest, LIR_PatchCode patch_code = lir_patch_none, CodeEmitInfo* info = NULL);\n+  void leal(LIR_Opr src, LIR_Opr dest, LIR_PatchCode patch_code = lir_patch_none, CodeEmitInfo* info = nullptr);\n","filename":"src\/hotspot\/share\/c1\/c1_LIRAssembler.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -111,1 +111,1 @@\n-\/\/ Call graph: move(NULL, c) -> move(c, b) -> move(b, a)\n+\/\/ Call graph: move(null, c) -> move(c, b) -> move(b, a)\n@@ -114,1 +114,1 @@\n-\/\/ Call graph: move(NULL, a) -> move(a, b) -> move(b, a)\n+\/\/ Call graph: move(null, a) -> move(a, b) -> move(b, a)\n@@ -124,1 +124,1 @@\n-    assert(_loop == NULL, \"only one loop valid!\");\n+    assert(_loop == nullptr, \"only one loop valid!\");\n@@ -134,1 +134,1 @@\n-    } else if (src != NULL) {\n+    } else if (src != nullptr) {\n@@ -148,2 +148,2 @@\n-      _loop = NULL;\n-      move(NULL, node);\n+      _loop = nullptr;\n+      move(nullptr, node);\n@@ -169,3 +169,3 @@\n-    node = vreg_table().at_grow(vreg_num, NULL);\n-    assert(node == NULL || node->operand() == opr, \"\");\n-    if (node == NULL) {\n+    node = vreg_table().at_grow(vreg_num, nullptr);\n+    assert(node == nullptr || node->operand() == opr, \"\");\n+    if (node == nullptr) {\n@@ -207,1 +207,1 @@\n-    _gen->_instruction_for_operand.at_put_grow(opr->vreg_number(), value(), NULL);\n+    _gen->_instruction_for_operand.at_put_grow(opr->vreg_number(), value(), nullptr);\n@@ -262,1 +262,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -267,2 +267,2 @@\n-  assert(is_constant() && value() != NULL, \"\");\n-  assert(type()->as_IntConstant() != NULL, \"type check\");\n+  assert(is_constant() && value() != nullptr, \"\");\n+  assert(type()->as_IntConstant() != nullptr, \"type check\");\n@@ -274,2 +274,2 @@\n-  assert(is_constant() && value() != NULL, \"\");\n-  assert(type()->as_AddressConstant() != NULL, \"type check\");\n+  assert(is_constant() && value() != nullptr, \"\");\n+  assert(type()->as_AddressConstant() != nullptr, \"type check\");\n@@ -281,2 +281,2 @@\n-  assert(is_constant() && value() != NULL, \"\");\n-  assert(type()->as_FloatConstant() != NULL, \"type check\");\n+  assert(is_constant() && value() != nullptr, \"\");\n+  assert(type()->as_FloatConstant() != nullptr, \"type check\");\n@@ -288,2 +288,2 @@\n-  assert(is_constant() && value() != NULL, \"\");\n-  assert(type()->as_DoubleConstant() != NULL, \"type check\");\n+  assert(is_constant() && value() != nullptr, \"\");\n+  assert(type()->as_DoubleConstant() != nullptr, \"type check\");\n@@ -295,2 +295,2 @@\n-  assert(is_constant() && value() != NULL, \"\");\n-  assert(type()->as_LongConstant() != NULL, \"type check\");\n+  assert(is_constant() && value() != nullptr, \"\");\n+  assert(type()->as_LongConstant() != nullptr, \"type check\");\n@@ -313,1 +313,1 @@\n-  assert(block->lir() == NULL, \"LIR list already computed for this block\");\n+  assert(block->lir() == nullptr, \"LIR list already computed for this block\");\n@@ -354,1 +354,1 @@\n-  for (Instruction* instr = block; instr != NULL; instr = instr->next()) {\n+  for (Instruction* instr = block; instr != nullptr; instr = instr->next()) {\n@@ -358,1 +358,1 @@\n-  set_block(NULL);\n+  set_block(nullptr);\n@@ -377,1 +377,1 @@\n-         instr->as_Constant() != NULL || bailed_out(), \"invalid item set\");\n+         instr->as_Constant() != nullptr || bailed_out(), \"invalid item set\");\n@@ -385,2 +385,2 @@\n-  if ((instr->is_pinned() && instr->as_Phi() == NULL) || instr->operand()->is_valid()) {\n-    assert(instr->operand() != LIR_OprFact::illegalOpr || instr->as_Constant() != NULL, \"this root has not yet been visited\");\n+  if ((instr->is_pinned() && instr->as_Phi() == nullptr) || instr->operand()->is_valid()) {\n+    assert(instr->operand() != LIR_OprFact::illegalOpr || instr->as_Constant() != nullptr, \"this root has not yet been visited\");\n@@ -390,1 +390,1 @@\n-    \/\/ assert(instr->use_count() > 0 || instr->as_Phi() != NULL, \"leaf instruction must have a use\");\n+    \/\/ assert(instr->use_count() > 0 || instr->as_Phi() != nullptr, \"leaf instruction must have a use\");\n@@ -396,1 +396,1 @@\n-  assert(state != NULL, \"state must be defined\");\n+  assert(state != nullptr, \"state must be defined\");\n@@ -413,1 +413,1 @@\n-      if (!value->is_pinned() && value->as_Constant() == NULL && value->as_Local() == NULL) {\n+      if (!value->is_pinned() && value->as_Constant() == nullptr && value->as_Local() == nullptr) {\n@@ -440,1 +440,1 @@\n-          if (!value->is_pinned() && value->as_Constant() == NULL && value->as_Local() == NULL) {\n+          if (!value->is_pinned() && value->as_Constant() == nullptr && value->as_Local() == nullptr) {\n@@ -445,1 +445,1 @@\n-          \/\/ NULL out this local so that linear scan can assume that all non-NULL values are live.\n+          \/\/ null out this local so that linear scan can assume that all non-null values are live.\n@@ -452,1 +452,1 @@\n-  return new CodeEmitInfo(state, ignore_xhandler ? NULL : x->exception_handlers(), x->check_flag(Instruction::DeoptimizeOnException));\n+  return new CodeEmitInfo(state, ignore_xhandler ? nullptr : x->exception_handlers(), x->check_flag(Instruction::DeoptimizeOnException));\n@@ -466,2 +466,2 @@\n-    assert(info != NULL, \"info must be set if class is not loaded\");\n-    __ klass2reg_patch(NULL, r, info);\n+    assert(info != nullptr, \"info must be set if class is not loaded\");\n+    __ klass2reg_patch(nullptr, r, info);\n@@ -682,1 +682,1 @@\n-  if (type != NULL && type->is_array_klass() && type->is_loaded()) {\n+  if (type != nullptr && type->is_array_klass() && type->is_loaded()) {\n@@ -685,1 +685,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -691,2 +691,2 @@\n-  if (t == NULL) {\n-    return NULL;\n+  if (t == nullptr) {\n+    return nullptr;\n@@ -696,1 +696,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -710,1 +710,1 @@\n-  ciArrayKlass* expected_type = NULL;\n+  ciArrayKlass* expected_type = nullptr;\n@@ -716,1 +716,1 @@\n-    if (src_declared_type == NULL && (phi = src->as_Phi()) != NULL) {\n+    if (src_declared_type == nullptr && (phi = src->as_Phi()) != nullptr) {\n@@ -721,1 +721,1 @@\n-    if (dst_declared_type == NULL && (phi = dst->as_Phi()) != NULL) {\n+    if (dst_declared_type == nullptr && (phi = dst->as_Phi()) != nullptr) {\n@@ -725,1 +725,1 @@\n-    if (src_exact_type != NULL && src_exact_type == dst_exact_type) {\n+    if (src_exact_type != nullptr && src_exact_type == dst_exact_type) {\n@@ -729,1 +729,1 @@\n-    } else if (dst_exact_type != NULL && dst_exact_type->is_obj_array_klass()) {\n+    } else if (dst_exact_type != nullptr && dst_exact_type->is_obj_array_klass()) {\n@@ -731,2 +731,2 @@\n-      ciArrayKlass* src_type = NULL;\n-      if (src_exact_type != NULL && src_exact_type->is_obj_array_klass()) {\n+      ciArrayKlass* src_type = nullptr;\n+      if (src_exact_type != nullptr && src_exact_type->is_obj_array_klass()) {\n@@ -734,1 +734,1 @@\n-      } else if (src_declared_type != NULL && src_declared_type->is_obj_array_klass()) {\n+      } else if (src_declared_type != nullptr && src_declared_type->is_obj_array_klass()) {\n@@ -737,1 +737,1 @@\n-      if (src_type != NULL) {\n+      if (src_type != nullptr) {\n@@ -745,3 +745,3 @@\n-    if (expected_type == NULL) expected_type = dst_exact_type;\n-    if (expected_type == NULL) expected_type = src_declared_type;\n-    if (expected_type == NULL) expected_type = dst_declared_type;\n+    if (expected_type == nullptr) expected_type = dst_exact_type;\n+    if (expected_type == nullptr) expected_type = src_declared_type;\n+    if (expected_type == nullptr) expected_type = dst_declared_type;\n@@ -768,2 +768,2 @@\n-  if (expected_type != NULL) {\n-    Value length_limit = NULL;\n+  if (expected_type != nullptr) {\n+    Value length_limit = nullptr;\n@@ -772,1 +772,1 @@\n-    if (ifop != NULL) {\n+    if (ifop != nullptr) {\n@@ -784,1 +784,1 @@\n-    if (src_array != NULL) {\n+    if (src_array != nullptr) {\n@@ -786,1 +786,1 @@\n-      if (length_limit != NULL &&\n+      if (length_limit != nullptr &&\n@@ -794,1 +794,1 @@\n-    if (dst_array != NULL) {\n+    if (dst_array != nullptr) {\n@@ -796,1 +796,1 @@\n-      if (length_limit != NULL &&\n+      if (length_limit != nullptr &&\n@@ -814,1 +814,1 @@\n-    if (al != NULL) {\n+    if (al != nullptr) {\n@@ -843,1 +843,1 @@\n-    if (expected_type != NULL) {\n+    if (expected_type != nullptr) {\n@@ -911,1 +911,1 @@\n-    assert(method != NULL, \"method should be set if branch is profiled\");\n+    assert(method != nullptr, \"method should be set if branch is profiled\");\n@@ -913,1 +913,1 @@\n-    assert(md != NULL, \"Sanity\");\n+    assert(md != nullptr, \"Sanity\");\n@@ -915,1 +915,1 @@\n-    assert(data != NULL, \"must have profiling data\");\n+    assert(data != nullptr, \"must have profiling data\");\n@@ -966,1 +966,1 @@\n-  if (phi != NULL && cur_val != NULL && cur_val != phi && !phi->is_illegal()) {\n+  if (phi != nullptr && cur_val != nullptr && cur_val != phi && !phi->is_illegal()) {\n@@ -970,1 +970,1 @@\n-        if (op != NULL && op->type()->is_illegal()) {\n+        if (op != nullptr && op->type()->is_illegal()) {\n@@ -976,1 +976,1 @@\n-    if (cur_phi != NULL && cur_phi->is_illegal()) {\n+    if (cur_phi != nullptr && cur_phi->is_illegal()) {\n@@ -985,1 +985,1 @@\n-      assert(cur_val->as_Constant() != NULL || cur_val->as_Local() != NULL,\n+      assert(cur_val->as_Constant() != nullptr || cur_val->as_Local() != nullptr,\n@@ -1084,1 +1084,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1100,1 +1100,1 @@\n-  __ move_wide(LIR_OprFact::oopConst(NULL),\n+  __ move_wide(LIR_OprFact::oopConst(nullptr),\n@@ -1102,1 +1102,1 @@\n-  __ move_wide(LIR_OprFact::oopConst(NULL),\n+  __ move_wide(LIR_OprFact::oopConst(nullptr),\n@@ -1129,1 +1129,1 @@\n-  if (x->state_before() != NULL) {\n+  if (x->state_before() != nullptr) {\n@@ -1133,1 +1133,1 @@\n-    __ oop2reg_patch(NULL, reg, info);\n+    __ oop2reg_patch(nullptr, reg, info);\n@@ -1176,1 +1176,1 @@\n-    call_runtime(&signature, args, CAST_FROM_FN_PTR(address, SharedRuntime::dtrace_method_exit), voidType, NULL);\n+    call_runtime(&signature, args, CAST_FROM_FN_PTR(address, SharedRuntime::dtrace_method_exit), voidType, nullptr);\n@@ -1203,1 +1203,1 @@\n-  CodeEmitInfo* info = NULL;\n+  CodeEmitInfo* info = nullptr;\n@@ -1239,1 +1239,1 @@\n-                                     NULL); \/\/ NULL CodeEmitInfo results in a leaf call\n+                                     nullptr); \/\/ null CodeEmitInfo results in a leaf call\n@@ -1257,1 +1257,1 @@\n-  CodeEmitInfo* info = NULL;\n+  CodeEmitInfo* info = nullptr;\n@@ -1279,1 +1279,1 @@\n-  CodeEmitInfo* info = NULL;\n+  CodeEmitInfo* info = nullptr;\n@@ -1297,1 +1297,1 @@\n-  CodeEmitInfo* info = NULL;\n+  CodeEmitInfo* info = nullptr;\n@@ -1333,1 +1333,1 @@\n-  load_klass(value.result(), klass, NULL);\n+  load_klass(value.result(), klass, nullptr);\n@@ -1476,1 +1476,1 @@\n-    if (c != NULL) {\n+    if (c != nullptr) {\n@@ -1479,1 +1479,1 @@\n-      assert(x->as_Phi() || x->as_Local() != NULL, \"only for Phi and Local\");\n+      assert(x->as_Phi() || x->as_Local() != nullptr, \"only for Phi and Local\");\n@@ -1482,1 +1482,1 @@\n-      _instruction_for_operand.at_put_grow(x->operand()->vreg_number(), x, NULL);\n+      _instruction_for_operand.at_put_grow(x->operand()->vreg_number(), x, nullptr);\n@@ -1493,1 +1493,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1501,1 +1501,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1616,1 +1616,1 @@\n-  CodeEmitInfo* info = NULL;\n+  CodeEmitInfo* info = nullptr;\n@@ -1618,1 +1618,1 @@\n-    assert(x->explicit_null_check() == NULL, \"can't fold null check into patching field access\");\n+    assert(x->explicit_null_check() == nullptr, \"can't fold null check into patching field access\");\n@@ -1622,1 +1622,1 @@\n-    if (nc == NULL) {\n+    if (nc == nullptr) {\n@@ -1661,1 +1661,1 @@\n-    \/\/ If the class is not loaded and the object is NULL, we need to deoptimize to throw a\n+    \/\/ If the class is not loaded and the object is null, we need to deoptimize to throw a\n@@ -1675,1 +1675,1 @@\n-                  value.result(), info != NULL ? new CodeEmitInfo(info) : NULL, info);\n+                  value.result(), info != nullptr ? new CodeEmitInfo(info) : nullptr, info);\n@@ -1681,1 +1681,1 @@\n-  bool use_length = x->length() != NULL;\n+  bool use_length = x->length() != nullptr;\n@@ -1683,1 +1683,1 @@\n-  bool needs_store_check = obj_store && (x->value()->as_Constant() == NULL ||\n+  bool needs_store_check = obj_store && (x->value()->as_Constant() == nullptr ||\n@@ -1712,1 +1712,1 @@\n-  CodeEmitInfo* null_check_info = NULL;\n+  CodeEmitInfo* null_check_info = nullptr;\n@@ -1724,1 +1724,1 @@\n-      null_check_info = NULL;\n+      null_check_info = nullptr;\n@@ -1739,1 +1739,1 @@\n-                  NULL, null_check_info);\n+                  nullptr, null_check_info);\n@@ -1825,1 +1825,1 @@\n-  CodeEmitInfo* info = NULL;\n+  CodeEmitInfo* info = nullptr;\n@@ -1827,1 +1827,1 @@\n-    assert(x->explicit_null_check() == NULL, \"can't fold null check into patching field access\");\n+    assert(x->explicit_null_check() == nullptr, \"can't fold null check into patching field access\");\n@@ -1831,1 +1831,1 @@\n-    if (nc == NULL) {\n+    if (nc == nullptr) {\n@@ -1857,1 +1857,1 @@\n-      __ move(LIR_OprFact::oopConst(NULL), obj);\n+      __ move(LIR_OprFact::oopConst(nullptr), obj);\n@@ -1860,1 +1860,1 @@\n-    \/\/ If the class is not loaded and the object is NULL, we need to deoptimize to throw a\n+    \/\/ If the class is not loaded and the object is null, we need to deoptimize to throw a\n@@ -1876,1 +1876,1 @@\n-                 info ? new CodeEmitInfo(info) : NULL, info);\n+                 info ? new CodeEmitInfo(info) : nullptr, info);\n@@ -1952,1 +1952,1 @@\n-  CodeEmitInfo* info = NULL;\n+  CodeEmitInfo* info = nullptr;\n@@ -1955,1 +1955,1 @@\n-    if (nc == NULL) {\n+    if (nc == nullptr) {\n@@ -1962,1 +1962,1 @@\n-      __ move(LIR_OprFact::oopConst(NULL), obj);\n+      __ move(LIR_OprFact::oopConst(nullptr), obj);\n@@ -1971,1 +1971,1 @@\n-  bool use_length = x->length() != NULL;\n+  bool use_length = x->length() != nullptr;\n@@ -1991,1 +1991,1 @@\n-  CodeEmitInfo* null_check_info = NULL;\n+  CodeEmitInfo* null_check_info = nullptr;\n@@ -1994,1 +1994,1 @@\n-    if (nc != NULL) {\n+    if (nc != nullptr) {\n@@ -2001,1 +2001,1 @@\n-      __ move(LIR_OprFact::oopConst(NULL), obj);\n+      __ move(LIR_OprFact::oopConst(nullptr), obj);\n@@ -2017,1 +2017,1 @@\n-      null_check_info = NULL;\n+      null_check_info = nullptr;\n@@ -2026,1 +2026,1 @@\n-                 NULL, null_check_info);\n+                 nullptr, null_check_info);\n@@ -2070,1 +2070,1 @@\n-    if (throw_type == NULL) {\n+    if (throw_type == nullptr) {\n@@ -2074,1 +2074,1 @@\n-    if (throw_type != NULL && throw_type->is_instance_klass()) {\n+    if (throw_type != nullptr && throw_type->is_instance_klass()) {\n@@ -2084,1 +2084,1 @@\n-  if (x->exception()->as_NewInstance() == NULL && x->exception()->as_ExceptionObject() == NULL) {\n+  if (x->exception()->as_NewInstance() == nullptr && x->exception()->as_ExceptionObject() == nullptr) {\n@@ -2322,1 +2322,1 @@\n-    assert(md != NULL, \"Sanity\");\n+    assert(md != nullptr, \"Sanity\");\n@@ -2324,1 +2324,1 @@\n-    assert(data != NULL, \"must have profiling data\");\n+    assert(data != nullptr, \"must have profiling data\");\n@@ -2380,1 +2380,1 @@\n-    assert(md != NULL, \"Sanity\");\n+    assert(md != nullptr, \"Sanity\");\n@@ -2382,1 +2382,1 @@\n-    assert(data != NULL, \"must have profiling data\");\n+    assert(data != nullptr, \"must have profiling data\");\n@@ -2448,1 +2448,1 @@\n-    assert(method != NULL, \"method should be set if branch is profiled\");\n+    assert(method != nullptr, \"method should be set if branch is profiled\");\n@@ -2450,1 +2450,1 @@\n-    assert(md != NULL, \"Sanity\");\n+    assert(md != nullptr, \"Sanity\");\n@@ -2452,1 +2452,1 @@\n-    assert(data != NULL, \"must have profiling data\");\n+    assert(data != nullptr, \"must have profiling data\");\n@@ -2497,1 +2497,1 @@\n-  ciKlass* result = NULL;\n+  ciKlass* result = nullptr;\n@@ -2506,1 +2506,1 @@\n-  ciKlass* exact_klass = NULL;\n+  ciKlass* exact_klass = nullptr;\n@@ -2512,1 +2512,1 @@\n-    if (type == NULL) {\n+    if (type == nullptr) {\n@@ -2516,2 +2516,2 @@\n-    assert(type == NULL || type->is_klass(), \"type should be class\");\n-    exact_klass = (type != NULL && type->is_loaded()) ? (ciKlass*)type : NULL;\n+    assert(type == nullptr || type->is_klass(), \"type should be class\");\n+    exact_klass = (type != nullptr && type->is_loaded()) ? (ciKlass*)type : nullptr;\n@@ -2519,1 +2519,1 @@\n-    do_update = exact_klass == NULL || ciTypeEntries::valid_ciklass(profiled_k) != exact_klass;\n+    do_update = exact_klass == nullptr || ciTypeEntries::valid_ciklass(profiled_k) != exact_klass;\n@@ -2526,1 +2526,1 @@\n-  ciKlass* exact_signature_k = NULL;\n+  ciKlass* exact_signature_k = nullptr;\n@@ -2530,1 +2530,1 @@\n-    if (exact_signature_k == NULL) {\n+    if (exact_signature_k == nullptr) {\n@@ -2538,1 +2538,1 @@\n-    \/\/ exact_klass and exact_signature_k can be both non NULL but\n+    \/\/ exact_klass and exact_signature_k can be both non null but\n@@ -2541,1 +2541,1 @@\n-    if (exact_klass == NULL && exact_signature_k != NULL && exact_klass != exact_signature_k) {\n+    if (exact_klass == nullptr && exact_signature_k != nullptr && exact_klass != exact_signature_k) {\n@@ -2546,1 +2546,1 @@\n-    if (callee_signature_k != NULL &&\n+    if (callee_signature_k != nullptr &&\n@@ -2549,1 +2549,1 @@\n-      if (improved_klass == NULL) {\n+      if (improved_klass == nullptr) {\n@@ -2552,1 +2552,1 @@\n-      if (exact_klass == NULL && improved_klass != NULL && exact_klass != improved_klass) {\n+      if (exact_klass == nullptr && improved_klass != nullptr && exact_klass != improved_klass) {\n@@ -2556,1 +2556,1 @@\n-    do_update = exact_klass == NULL || ciTypeEntries::valid_ciklass(profiled_k) != exact_klass;\n+    do_update = exact_klass == nullptr || ciTypeEntries::valid_ciklass(profiled_k) != exact_klass;\n@@ -2575,1 +2575,1 @@\n-                  value.result(), exact_klass, profiled_k, new_pointer_register(), not_null, exact_signature_k != NULL);\n+                  value.result(), exact_klass, profiled_k, new_pointer_register(), not_null, exact_signature_k != nullptr);\n@@ -2584,1 +2584,1 @@\n-    assert(md != NULL, \"Sanity\");\n+    assert(md != nullptr, \"Sanity\");\n@@ -2586,1 +2586,1 @@\n-    if (md->parameters_type_data() != NULL) {\n+    if (md->parameters_type_data() != nullptr) {\n@@ -2599,1 +2599,1 @@\n-                                        profiled_k, local, mdp, false, local->declared_type()->as_klass(), NULL);\n+                                        profiled_k, local, mdp, false, local->declared_type()->as_klass(), nullptr);\n@@ -2601,1 +2601,1 @@\n-          if (exact != NULL) {\n+          if (exact != nullptr) {\n@@ -2641,1 +2641,1 @@\n-    assert(local != NULL, \"Locals for incoming arguments must have been created\");\n+    assert(local != nullptr, \"Locals for incoming arguments must have been created\");\n@@ -2647,1 +2647,1 @@\n-    _instruction_for_operand.at_put_grow(dest->vreg_number(), local, NULL);\n+    _instruction_for_operand.at_put_grow(dest->vreg_number(), local, nullptr);\n@@ -2660,1 +2660,1 @@\n-    call_runtime(&signature, args, CAST_FROM_FN_PTR(address, SharedRuntime::dtrace_method_entry), voidType, NULL);\n+    call_runtime(&signature, args, CAST_FROM_FN_PTR(address, SharedRuntime::dtrace_method_entry), voidType, nullptr);\n@@ -2670,1 +2670,1 @@\n-      assert(receiver != NULL, \"must already exist\");\n+      assert(receiver != nullptr, \"must already exist\");\n@@ -2679,1 +2679,1 @@\n-      CodeEmitInfo* info = new CodeEmitInfo(scope()->start()->state()->copy(ValueStack::StateBefore, SynchronizationEntryBCI), NULL, x->check_flag(Instruction::DeoptimizeOnException));\n+      CodeEmitInfo* info = new CodeEmitInfo(scope()->start()->state()->copy(ValueStack::StateBefore, SynchronizationEntryBCI), nullptr, x->check_flag(Instruction::DeoptimizeOnException));\n@@ -2682,2 +2682,2 @@\n-      \/\/ receiver is guaranteed non-NULL so don't need CodeEmitInfo\n-      __ lock_object(syncTempOpr(), obj, lock, new_register(T_OBJECT), slow_path, NULL);\n+      \/\/ receiver is guaranteed non-null so don't need CodeEmitInfo\n+      __ lock_object(syncTempOpr(), obj, lock, new_register(T_OBJECT), slow_path, nullptr);\n@@ -2689,1 +2689,1 @@\n-    CodeEmitInfo* info = new CodeEmitInfo(scope()->start()->state()->copy(ValueStack::StateBefore, SynchronizationEntryBCI), NULL, false);\n+    CodeEmitInfo* info = new CodeEmitInfo(scope()->start()->state()->copy(ValueStack::StateBefore, SynchronizationEntryBCI), nullptr, false);\n@@ -3035,1 +3035,1 @@\n-    assert(md != NULL, \"Sanity\");\n+    assert(md != nullptr, \"Sanity\");\n@@ -3037,1 +3037,1 @@\n-    if (data != NULL) {\n+    if (data != nullptr) {\n@@ -3056,1 +3056,1 @@\n-        ciSignatureStream callee_signature_stream(callee_signature, has_receiver ? x->callee()->holder() : NULL);\n+        ciSignatureStream callee_signature_stream(callee_signature, has_receiver ? x->callee()->holder() : nullptr);\n@@ -3059,1 +3059,1 @@\n-        ciSignature* signature_at_call = NULL;\n+        ciSignature* signature_at_call = nullptr;\n@@ -3070,1 +3070,1 @@\n-          if (exact != NULL) {\n+          if (exact != nullptr) {\n@@ -3091,1 +3091,1 @@\n-    if (md != NULL) {\n+    if (md != nullptr) {\n@@ -3093,1 +3093,1 @@\n-      if (parameters_type_data != NULL) {\n+      if (parameters_type_data != nullptr) {\n@@ -3098,1 +3098,1 @@\n-        ciSignatureStream sig_stream(sig, has_receiver ? x->callee()->holder() : NULL);\n+        ciSignatureStream sig_stream(sig, has_receiver ? x->callee()->holder() : nullptr);\n@@ -3107,1 +3107,1 @@\n-        if (arg == NULL || !Bytecodes::has_receiver(bc)) {\n+        if (arg == nullptr || !Bytecodes::has_receiver(bc)) {\n@@ -3117,1 +3117,1 @@\n-                                        profiled_k, arg, mdp, not_null, sig_stream.next_klass(), NULL);\n+                                        profiled_k, arg, mdp, not_null, sig_stream.next_klass(), nullptr);\n@@ -3119,1 +3119,1 @@\n-          if (exact != NULL) {\n+          if (exact != nullptr) {\n@@ -3128,1 +3128,1 @@\n-                x->recv() != NULL && Bytecodes::has_receiver(bc)) {\n+                x->recv() != nullptr && Bytecodes::has_receiver(bc)) {\n@@ -3156,1 +3156,1 @@\n-  if (x->recv() != NULL || x->nb_profiled_args() > 0) {\n+  if (x->recv() != nullptr || x->nb_profiled_args() > 0) {\n@@ -3160,1 +3160,1 @@\n-  if (x->recv() != NULL) {\n+  if (x->recv() != nullptr) {\n@@ -3172,1 +3172,1 @@\n-  assert(md != NULL, \"Sanity\");\n+  assert(md != nullptr, \"Sanity\");\n@@ -3174,1 +3174,1 @@\n-  if (data != NULL) {\n+  if (data != nullptr) {\n@@ -3180,1 +3180,1 @@\n-    ciSignature* signature_at_call = NULL;\n+    ciSignature* signature_at_call = nullptr;\n@@ -3191,1 +3191,1 @@\n-    if (exact != NULL) {\n+    if (exact != nullptr) {\n@@ -3263,1 +3263,1 @@\n-    if (counters_adr == NULL) {\n+    if (counters_adr == nullptr) {\n@@ -3276,1 +3276,1 @@\n-    assert(md != NULL, \"Sanity\");\n+    assert(md != nullptr, \"Sanity\");\n@@ -3330,1 +3330,1 @@\n-  LIR_Opr result = call_runtime(signature, args, x->entry(), x->type(), NULL);\n+  LIR_Opr result = call_runtime(signature, args, x->entry(), x->type(), nullptr);\n@@ -3562,1 +3562,1 @@\n-  null_check_info = NULL;\n+  null_check_info = nullptr;\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":169,"deletions":169,"binary":false,"changes":338,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -227,1 +227,1 @@\n-      _instruction_for_operand.at_put_grow(opr->vreg_number(), x, NULL);\n+      _instruction_for_operand.at_put_grow(opr->vreg_number(), x, nullptr);\n@@ -292,1 +292,1 @@\n-                       CodeEmitInfo* patch_info = NULL, CodeEmitInfo* store_emit_info = NULL);\n+                       CodeEmitInfo* patch_info = nullptr, CodeEmitInfo* store_emit_info = nullptr);\n@@ -296,1 +296,1 @@\n-                      CodeEmitInfo* patch_info = NULL, CodeEmitInfo* load_emit_info = NULL);\n+                      CodeEmitInfo* patch_info = nullptr, CodeEmitInfo* load_emit_info = nullptr);\n@@ -346,1 +346,1 @@\n-  void arithmetic_op(Bytecodes::Code code, LIR_Opr result, LIR_Opr left, LIR_Opr right, LIR_Opr tmp, CodeEmitInfo* info = NULL);\n+  void arithmetic_op(Bytecodes::Code code, LIR_Opr result, LIR_Opr left, LIR_Opr right, LIR_Opr tmp, CodeEmitInfo* info = nullptr);\n@@ -358,1 +358,1 @@\n-  void arithmetic_op_long (Bytecodes::Code code, LIR_Opr result, LIR_Opr left, LIR_Opr right, CodeEmitInfo* info = NULL);\n+  void arithmetic_op_long (Bytecodes::Code code, LIR_Opr result, LIR_Opr left, LIR_Opr right, CodeEmitInfo* info = nullptr);\n@@ -623,1 +623,1 @@\n-    set_instruction(NULL);\n+    set_instruction(nullptr);\n@@ -629,1 +629,1 @@\n-    if (_value != NULL) {\n+    if (_value != nullptr) {\n@@ -669,1 +669,1 @@\n-  bool is_constant() const { return value()->as_Constant() != NULL; }\n+  bool is_constant() const { return value()->as_Constant() != nullptr; }\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.hpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -86,2 +86,2 @@\n- , _new_intervals_from_allocation(NULL)\n- , _sorted_intervals(NULL)\n+ , _new_intervals_from_allocation(nullptr)\n+ , _sorted_intervals(nullptr)\n@@ -96,1 +96,1 @@\n- , _fpu_stack_allocator(NULL)\n+ , _fpu_stack_allocator(nullptr)\n@@ -99,4 +99,4 @@\n-  assert(this->ir() != NULL,          \"check if valid\");\n-  assert(this->compilation() != NULL, \"check if valid\");\n-  assert(this->gen() != NULL,         \"check if valid\");\n-  assert(this->frame_map() != NULL,   \"check if valid\");\n+  assert(this->ir() != nullptr,          \"check if valid\");\n+  assert(this->compilation() != nullptr, \"check if valid\");\n+  assert(this->gen() != nullptr,         \"check if valid\");\n+  assert(this->frame_map() != nullptr,   \"check if valid\");\n@@ -271,1 +271,1 @@\n-  assert(_intervals.at(reg_num) == NULL, \"overwriting existing interval\");\n+  assert(_intervals.at(reg_num) == nullptr, \"overwriting existing interval\");\n@@ -289,1 +289,1 @@\n-  if (new_intervals == NULL) {\n+  if (new_intervals == nullptr) {\n@@ -396,1 +396,1 @@\n-  create_unhandled_lists(&interval, &temp_list, must_store_at_definition, NULL);\n+  create_unhandled_lists(&interval, &temp_list, must_store_at_definition, nullptr);\n@@ -399,1 +399,1 @@\n-  Interval* prev = NULL;\n+  Interval* prev = nullptr;\n@@ -403,1 +403,1 @@\n-    if (prev != NULL) {\n+    if (prev != nullptr) {\n@@ -435,1 +435,1 @@\n-        assert(op->as_Op1() != NULL, \"move must be LIR_Op1\");\n+        assert(op->as_Op1() != nullptr, \"move must be LIR_Op1\");\n@@ -444,1 +444,1 @@\n-          instructions->at_put(j, NULL); \/\/ NULL-instructions are deleted by assign_reg_num\n+          instructions->at_put(j, nullptr); \/\/ null-instructions are deleted by assign_reg_num\n@@ -501,2 +501,2 @@\n-  _lir_ops = LIR_OpArray(num_instructions, num_instructions, NULL);\n-  _block_of_op = BlockBeginArray(num_instructions, num_instructions, NULL);\n+  _lir_ops = LIR_OpArray(num_instructions, num_instructions, nullptr);\n+  _block_of_op = BlockBeginArray(num_instructions, num_instructions, nullptr);\n@@ -543,2 +543,2 @@\n-  assert(con == NULL || opr->is_virtual() || opr->is_constant() || opr->is_illegal(), \"assumption: Constant instructions have only constant operands\");\n-  assert(con != NULL || opr->is_virtual(), \"assumption: non-Constant instructions have only virtual operands\");\n+  assert(con == nullptr || opr->is_virtual() || opr->is_constant() || opr->is_illegal(), \"assumption: Constant instructions have only constant operands\");\n+  assert(con != nullptr || opr->is_virtual(), \"assumption: non-Constant instructions have only virtual operands\");\n@@ -546,1 +546,1 @@\n-  if ((con == NULL || con->is_pinned()) && opr->is_register()) {\n+  if ((con == nullptr || con->is_pinned()) && opr->is_register()) {\n@@ -842,1 +842,1 @@\n-        tty->print_cr(\"* vreg %d (HIR instruction %c%d)\", i, instr == NULL ? ' ' : instr->type()->tchar(), instr == NULL ? 0 : instr->id());\n+        tty->print_cr(\"* vreg %d (HIR instruction %c%d)\", i, instr == nullptr ? ' ' : instr->type()->tchar(), instr == nullptr ? 0 : instr->id());\n@@ -873,1 +873,1 @@\n-  if ((con == NULL || con->is_pinned()) && opr->is_register()) {\n+  if ((con == nullptr || con->is_pinned()) && opr->is_register()) {\n@@ -943,1 +943,1 @@\n-  if (interval != NULL) {\n+  if (interval != nullptr) {\n@@ -988,1 +988,1 @@\n-  if (interval == NULL) {\n+  if (interval == nullptr) {\n@@ -1003,1 +1003,1 @@\n-  if (interval == NULL) {\n+  if (interval == nullptr) {\n@@ -1022,1 +1022,1 @@\n-    assert(op->as_Op1() != NULL, \"lir_move must be LIR_Op1\");\n+    assert(op->as_Op1() != nullptr, \"lir_move must be LIR_Op1\");\n@@ -1058,1 +1058,1 @@\n-    assert(op->as_Op1() != NULL, \"lir_move must be LIR_Op1\");\n+    assert(op->as_Op1() != nullptr, \"lir_move must be LIR_Op1\");\n@@ -1103,1 +1103,1 @@\n-          assert(op->as_Op2() != NULL, \"must be LIR_Op2\");\n+          assert(op->as_Op2() != nullptr, \"must be LIR_Op2\");\n@@ -1121,1 +1121,1 @@\n-          assert(op->as_Op2() != NULL, \"must be LIR_Op2\");\n+          assert(op->as_Op2() != nullptr, \"must be LIR_Op2\");\n@@ -1145,1 +1145,1 @@\n-        assert(op->as_Op2() != NULL, \"must be LIR_Op2\");\n+        assert(op->as_Op2() != nullptr, \"must be LIR_Op2\");\n@@ -1169,1 +1169,1 @@\n-    assert(op->as_Op1() != NULL, \"must be LIR_Op1\");\n+    assert(op->as_Op1() != nullptr, \"must be LIR_Op1\");\n@@ -1205,1 +1205,1 @@\n-    assert(op->as_Op1() != NULL, \"must be LIR_Op1\");\n+    assert(op->as_Op1() != nullptr, \"must be LIR_Op1\");\n@@ -1210,1 +1210,1 @@\n-      if (address != NULL) {\n+      if (address != nullptr) {\n@@ -1226,1 +1226,1 @@\n-      assert(op->as_Op1() != NULL, \"lir_move, lir_convert must be LIR_Op1\");\n+      assert(op->as_Op1() != nullptr, \"lir_move, lir_convert must be LIR_Op1\");\n@@ -1235,1 +1235,1 @@\n-        if (from != NULL && to != NULL) {\n+        if (from != nullptr && to != nullptr) {\n@@ -1243,1 +1243,1 @@\n-      assert(op->as_Op4() != NULL, \"lir_cmove must be LIR_Op4\");\n+      assert(op->as_Op4() != nullptr, \"lir_cmove must be LIR_Op4\");\n@@ -1252,1 +1252,1 @@\n-        if (from != NULL && to != NULL) {\n+        if (from != nullptr && to != nullptr) {\n@@ -1272,1 +1272,1 @@\n-  _intervals.at_put_grow(num_virtual_regs() - 1, NULL, NULL);\n+  _intervals.at_put_grow(num_virtual_regs() - 1, nullptr, nullptr);\n@@ -1424,1 +1424,1 @@\n-    if (interval != NULL) {\n+    if (interval != nullptr) {\n@@ -1434,2 +1434,2 @@\n-  if (*a != NULL) {\n-    if (*b != NULL) {\n+  if (*a != nullptr) {\n+    if (*b != nullptr) {\n@@ -1441,1 +1441,1 @@\n-    if (*b != NULL) {\n+    if (*b != nullptr) {\n@@ -1494,1 +1494,1 @@\n-    if (it != NULL) {\n+    if (it != nullptr) {\n@@ -1508,1 +1508,1 @@\n-    if (interval != NULL) {\n+    if (interval != nullptr) {\n@@ -1516,1 +1516,1 @@\n-      \"Sorted list should contain the same amount of non-NULL intervals as unsorted list\");\n+      \"Sorted list should contain the same amount of non-null intervals as unsorted list\");\n@@ -1523,1 +1523,1 @@\n-  if (*prev != NULL) {\n+  if (*prev != nullptr) {\n@@ -1536,2 +1536,2 @@\n-  Interval* list1_prev = NULL;\n-  Interval* list2_prev = NULL;\n+  Interval* list1_prev = nullptr;\n+  Interval* list2_prev = nullptr;\n@@ -1543,1 +1543,1 @@\n-    if (v == NULL) continue;\n+    if (v == nullptr) continue;\n@@ -1547,1 +1547,1 @@\n-    } else if (is_list2 == NULL || is_list2(v)) {\n+    } else if (is_list2 == nullptr || is_list2(v)) {\n@@ -1552,2 +1552,2 @@\n-  if (list1_prev != NULL) list1_prev->set_next(Interval::end());\n-  if (list2_prev != NULL) list2_prev->set_next(Interval::end());\n+  if (list1_prev != nullptr) list1_prev->set_next(Interval::end());\n+  if (list2_prev != nullptr) list2_prev->set_next(Interval::end());\n@@ -1555,2 +1555,2 @@\n-  assert(list1_prev == NULL || list1_prev->next() == Interval::end(), \"linear list ends not with sentinel\");\n-  assert(list2_prev == NULL || list2_prev->next() == Interval::end(), \"linear list ends not with sentinel\");\n+  assert(list1_prev == nullptr || list1_prev->next() == Interval::end(), \"linear list ends not with sentinel\");\n+  assert(list2_prev == nullptr || list2_prev->next() == Interval::end(), \"linear list ends not with sentinel\");\n@@ -1578,1 +1578,1 @@\n-  \/\/ calc number of items for sorted list (sorted list must not contain NULL values)\n+  \/\/ calc number of items for sorted list (sorted list must not contain null values)\n@@ -1580,1 +1580,1 @@\n-    if (unsorted_list->at(unsorted_idx) != NULL) {\n+    if (unsorted_list->at(unsorted_idx) != nullptr) {\n@@ -1584,1 +1584,1 @@\n-  IntervalArray* sorted_list = new IntervalArray(sorted_len, sorted_len, NULL);\n+  IntervalArray* sorted_list = new IntervalArray(sorted_len, sorted_len, nullptr);\n@@ -1591,1 +1591,1 @@\n-    if (cur_interval != NULL) {\n+    if (cur_interval != nullptr) {\n@@ -1625,1 +1625,1 @@\n-  int new_len = new_list == NULL ? 0 : new_list->length();\n+  int new_len = new_list == nullptr ? 0 : new_list->length();\n@@ -1638,1 +1638,1 @@\n-  IntervalArray* combined_list = new IntervalArray(combined_list_len, combined_list_len, NULL);\n+  IntervalArray* combined_list = new IntervalArray(combined_list_len, combined_list_len, nullptr);\n@@ -1701,1 +1701,1 @@\n-\/\/ instead of returning NULL\n+\/\/ instead of returning null\n@@ -1704,1 +1704,1 @@\n-  if (result != NULL) {\n+  if (result != nullptr) {\n@@ -1712,1 +1712,1 @@\n-  BAILOUT_(\"LinearScan: interval is NULL\", result);\n+  BAILOUT_(\"LinearScan: interval is null\", result);\n@@ -1718,1 +1718,1 @@\n-  assert(interval_at(reg_num) != NULL, \"no interval found\");\n+  assert(interval_at(reg_num) != nullptr, \"no interval found\");\n@@ -1725,1 +1725,1 @@\n-  assert(interval_at(reg_num) != NULL, \"no interval found\");\n+  assert(interval_at(reg_num) != nullptr, \"no interval found\");\n@@ -1732,1 +1732,1 @@\n-  assert(interval_at(reg_num) != NULL, \"no interval found\");\n+  assert(interval_at(reg_num) != nullptr, \"no interval found\");\n@@ -1766,1 +1766,1 @@\n-    if (branch != NULL) {\n+    if (branch != nullptr) {\n@@ -1777,1 +1777,1 @@\n-    assert(from_block->lir()->instructions_list()->at(0)->as_OpLabel() != NULL, \"block does not start with a label\");\n+    assert(from_block->lir()->instructions_list()->at(0)->as_OpLabel() != nullptr, \"block does not start with a label\");\n@@ -1863,1 +1863,1 @@\n-  if (interval_at(reg_num) == NULL) {\n+  if (interval_at(reg_num) == nullptr) {\n@@ -1936,1 +1936,1 @@\n-  if (interval_at(reg_num) == NULL) {\n+  if (interval_at(reg_num) == nullptr) {\n@@ -1946,1 +1946,1 @@\n-  if (phi != NULL) {\n+  if (phi != nullptr) {\n@@ -1958,1 +1958,1 @@\n-    if (con != NULL && (!con->is_pinned() || con->operand()->is_constant())) {\n+    if (con != nullptr && (!con->is_pinned() || con->operand()->is_constant())) {\n@@ -1986,1 +1986,1 @@\n-  assert(handler->entry_code() == NULL, \"code already present\");\n+  assert(handler->entry_code() == nullptr, \"code already present\");\n@@ -1992,1 +1992,1 @@\n-    resolve_exception_edge(handler, throwing_op_id, r, NULL, move_resolver);\n+    resolve_exception_edge(handler, throwing_op_id, r, nullptr, move_resolver);\n@@ -2218,1 +2218,1 @@\n-  assert(interval != NULL, \"interval must exist\");\n+  assert(interval != nullptr, \"interval must exist\");\n@@ -2228,1 +2228,1 @@\n-      if (branch != NULL) {\n+      if (branch != nullptr) {\n@@ -2268,1 +2268,1 @@\n-  if (values == NULL) {\n+  if (values == nullptr) {\n@@ -2283,1 +2283,1 @@\n-  if (values == NULL) {\n+  if (values == nullptr) {\n@@ -2332,2 +2332,2 @@\n-  if (d1->locals() != NULL) {\n-    assert(d1->locals() != NULL && d2->locals() != NULL, \"not equal\");\n+  if (d1->locals() != nullptr) {\n+    assert(d1->locals() != nullptr && d2->locals() != nullptr, \"not equal\");\n@@ -2339,1 +2339,1 @@\n-    assert(d1->locals() == NULL && d2->locals() == NULL, \"not equal\");\n+    assert(d1->locals() == nullptr && d2->locals() == nullptr, \"not equal\");\n@@ -2342,2 +2342,2 @@\n-  if (d1->expressions() != NULL) {\n-    assert(d1->expressions() != NULL && d2->expressions() != NULL, \"not equal\");\n+  if (d1->expressions() != nullptr) {\n+    assert(d1->expressions() != nullptr && d2->expressions() != nullptr, \"not equal\");\n@@ -2349,1 +2349,1 @@\n-    assert(d1->expressions() == NULL && d2->expressions() == NULL, \"not equal\");\n+    assert(d1->expressions() == nullptr && d2->expressions() == nullptr, \"not equal\");\n@@ -2352,2 +2352,2 @@\n-  if (d1->monitors() != NULL) {\n-    assert(d1->monitors() != NULL && d2->monitors() != NULL, \"not equal\");\n+  if (d1->monitors() != nullptr) {\n+    assert(d1->monitors() != nullptr && d2->monitors() != nullptr, \"not equal\");\n@@ -2359,1 +2359,1 @@\n-    assert(d1->monitors() == NULL && d2->monitors() == NULL, \"not equal\");\n+    assert(d1->monitors() == nullptr && d2->monitors() == nullptr, \"not equal\");\n@@ -2362,2 +2362,2 @@\n-  if (d1->caller() != NULL) {\n-    assert(d1->caller() != NULL && d2->caller() != NULL, \"not equal\");\n+  if (d1->caller() != nullptr) {\n+    assert(d1->caller() != nullptr && d2->caller() != nullptr, \"not equal\");\n@@ -2366,1 +2366,1 @@\n-    assert(d1->caller() == NULL && d2->caller() == NULL, \"not equal\");\n+    assert(d1->caller() == nullptr && d2->caller() == nullptr, \"not equal\");\n@@ -2406,1 +2406,1 @@\n-  create_unhandled_lists(&oop_intervals, &non_oop_intervals, is_oop_interval, NULL);\n+  create_unhandled_lists(&oop_intervals, &non_oop_intervals, is_oop_interval, nullptr);\n@@ -2467,1 +2467,1 @@\n-  assert(info->stack() != NULL, \"CodeEmitInfo must always have a stack\");\n+  assert(info->stack() != nullptr, \"CodeEmitInfo must always have a stack\");\n@@ -2499,1 +2499,1 @@\n-    if (info->_oop_map == NULL) {\n+    if (info->_oop_map == nullptr) {\n@@ -2516,1 +2516,1 @@\n-ConstantOopWriteValue* LinearScan::_oop_null_scope_value = new (mtCompiler) ConstantOopWriteValue(NULL);\n+ConstantOopWriteValue* LinearScan::_oop_null_scope_value = new (mtCompiler) ConstantOopWriteValue(nullptr);\n@@ -2527,1 +2527,1 @@\n-  _scope_value_cache = ScopeValueArray(cache_size, cache_size, NULL);\n+  _scope_value_cache = ScopeValueArray(cache_size, cache_size, nullptr);\n@@ -2560,1 +2560,1 @@\n-      if (value == NULL) {\n+      if (value == nullptr) {\n@@ -2620,1 +2620,1 @@\n-    if (sv == NULL) {\n+    if (sv == nullptr) {\n@@ -2638,1 +2638,1 @@\n-    if (sv == NULL) {\n+    if (sv == nullptr) {\n@@ -2666,1 +2666,1 @@\n-    assert(_fpu_stack_allocator != NULL, \"must be present\");\n+    assert(_fpu_stack_allocator != nullptr, \"must be present\");\n@@ -2713,1 +2713,1 @@\n-      if (!frame_map()->locations_for_slot(opr->double_stack_ix(), loc_type, &loc1, NULL)) {\n+      if (!frame_map()->locations_for_slot(opr->double_stack_ix(), loc_type, &loc1, nullptr)) {\n@@ -2779,1 +2779,1 @@\n-      assert(_fpu_stack_allocator != NULL, \"must be present\");\n+      assert(_fpu_stack_allocator != nullptr, \"must be present\");\n@@ -2811,2 +2811,2 @@\n-      first = NULL;\n-      second = NULL;\n+      first = nullptr;\n+      second = nullptr;\n@@ -2815,1 +2815,1 @@\n-    assert(first != NULL && second != NULL, \"must be set\");\n+    assert(first != nullptr && second != nullptr, \"must be set\");\n@@ -2830,1 +2830,1 @@\n-  if (value != NULL) {\n+  if (value != nullptr) {\n@@ -2834,2 +2834,2 @@\n-    assert(con == NULL || opr->is_virtual() || opr->is_constant() || opr->is_illegal(), \"assumption: Constant instructions have only constant operands (or illegal if constant is optimized away)\");\n-    assert(con != NULL || opr->is_virtual(), \"assumption: non-Constant instructions have only virtual operands\");\n+    assert(con == nullptr || opr->is_virtual() || opr->is_constant() || opr->is_illegal(), \"assumption: Constant instructions have only constant operands (or illegal if constant is optimized away)\");\n+    assert(con != nullptr || opr->is_virtual(), \"assumption: non-Constant instructions have only virtual operands\");\n@@ -2837,1 +2837,1 @@\n-    if (con != NULL && !con->is_pinned() && !opr->is_constant()) {\n+    if (con != nullptr && !con->is_pinned() && !opr->is_constant()) {\n@@ -2855,1 +2855,1 @@\n-        if (block->lir()->instructions_list()->last()->as_OpBranch() != NULL) {\n+        if (block->lir()->instructions_list()->last()->as_OpBranch() != nullptr) {\n@@ -2873,1 +2873,1 @@\n-      assert(value->as_Constant() != NULL, \"all other instructions have only virtual operands\");\n+      assert(value->as_Constant() != nullptr, \"all other instructions have only virtual operands\");\n@@ -2887,1 +2887,1 @@\n-  IRScopeDebugInfo* caller_debug_info = NULL;\n+  IRScopeDebugInfo* caller_debug_info = nullptr;\n@@ -2890,1 +2890,1 @@\n-  if (caller_state != NULL) {\n+  if (caller_state != nullptr) {\n@@ -2898,3 +2898,3 @@\n-  GrowableArray<ScopeValue*>*   locals      = NULL;\n-  GrowableArray<ScopeValue*>*   expressions = NULL;\n-  GrowableArray<MonitorValue*>* monitors    = NULL;\n+  GrowableArray<ScopeValue*>*   locals      = nullptr;\n+  GrowableArray<ScopeValue*>*   expressions = nullptr;\n+  GrowableArray<MonitorValue*>* monitors    = nullptr;\n@@ -2945,1 +2945,1 @@\n-    int lock_offset = cur_state->caller_state() != NULL ? cur_state->caller_state()->total_locks_size() : 0;\n+    int lock_offset = cur_state->caller_state() != nullptr ? cur_state->caller_state()->total_locks_size() : 0;\n@@ -2962,1 +2962,1 @@\n-  assert(innermost_scope != NULL && innermost_state != NULL, \"why is it missing?\");\n+  assert(innermost_scope != nullptr && innermost_state != nullptr, \"why is it missing?\");\n@@ -2966,1 +2966,1 @@\n-  if (info->_scope_debug_info == NULL) {\n+  if (info->_scope_debug_info == nullptr) {\n@@ -2983,1 +2983,1 @@\n-    if (op == NULL) {  \/\/ this can happen when spill-moves are removed in eliminate_spill_moves\n+    if (op == nullptr) { \/\/ this can happen when spill-moves are removed in eliminate_spill_moves\n@@ -3010,2 +3010,2 @@\n-          if (handler->entry_code() != NULL) {\n-            assign_reg_num(handler->entry_code()->instructions_list(), NULL);\n+          if (handler->entry_code() != nullptr) {\n+            assign_reg_num(handler->entry_code()->instructions_list(), nullptr);\n@@ -3019,1 +3019,1 @@\n-      assert(iw != NULL, \"needed for compute_oop_map\");\n+      assert(iw != nullptr, \"needed for compute_oop_map\");\n@@ -3042,1 +3042,1 @@\n-      assert(op->as_Op1() != NULL, \"move must be LIR_Op1\");\n+      assert(op->as_Op1() != nullptr, \"move must be LIR_Op1\");\n@@ -3049,1 +3049,1 @@\n-        instructions->at_put(j, NULL);\n+        instructions->at_put(j, nullptr);\n@@ -3060,1 +3060,1 @@\n-      if (op != NULL) {\n+      if (op != nullptr) {\n@@ -3183,1 +3183,1 @@\n-      if (interval != NULL) {\n+      if (interval != nullptr) {\n@@ -3257,1 +3257,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -3291,1 +3291,1 @@\n-    if (i1 == NULL) continue;\n+    if (i1 == nullptr) continue;\n@@ -3338,1 +3338,1 @@\n-      if (i2 == NULL || (i2->from() == 1 && i2->to() == 2)) continue;\n+      if (i2 == nullptr || (i2->from() == 1 && i2->to() == 2)) continue;\n@@ -3360,1 +3360,1 @@\n-  create_unhandled_lists(&fixed_intervals, &other_intervals, is_precolored_cpu_interval, NULL);\n+  create_unhandled_lists(&fixed_intervals, &other_intervals, is_precolored_cpu_interval, nullptr);\n@@ -3388,1 +3388,1 @@\n-        if (branch != NULL && branch->stub() != NULL && branch->stub()->is_exception_throw_stub()) {\n+        if (branch != nullptr && branch->stub() != nullptr && branch->stub()->is_exception_throw_stub()) {\n@@ -3441,1 +3441,1 @@\n-              assert(interval != NULL, \"no interval\");\n+              assert(interval != nullptr, \"no interval\");\n@@ -3480,1 +3480,1 @@\n-      assert(value != NULL, \"all intervals live across block boundaries must have Value\");\n+      assert(value != nullptr, \"all intervals live across block boundaries must have Value\");\n@@ -3483,1 +3483,1 @@\n-      \/\/ TKR assert(value->as_Constant() == NULL || value->is_pinned(), \"only pinned constants can be alive across block boundaries\");\n+      \/\/ TKR assert(value->as_Constant() == nullptr || value->is_pinned(), \"only pinned constants can be alive across block boundaries\");\n@@ -3523,1 +3523,1 @@\n-    , _saved_states(BlockBegin::number_of_blocks(), BlockBegin::number_of_blocks(), NULL)\n+    , _saved_states(BlockBegin::number_of_blocks(), BlockBegin::number_of_blocks(), nullptr)\n@@ -3540,1 +3540,1 @@\n-  IntervalList* input_state = new IntervalList(input_state_len, input_state_len, NULL);\n+  IntervalList* input_state = new IntervalList(input_state_len, input_state_len, nullptr);\n@@ -3578,1 +3578,1 @@\n-      if (input_state->at(i) != NULL) {\n+      if (input_state->at(i) != nullptr) {\n@@ -3603,1 +3603,1 @@\n-  if (xhandler->entry_code() != NULL) {\n+  if (xhandler->entry_code() != nullptr) {\n@@ -3612,1 +3612,1 @@\n-  if (saved_state != NULL) {\n+  if (saved_state != nullptr) {\n@@ -3621,1 +3621,1 @@\n-        if (saved_state->at(i) != NULL) {\n+        if (saved_state->at(i) != nullptr) {\n@@ -3626,1 +3626,1 @@\n-          saved_state->at_put(i, NULL);\n+          saved_state->at_put(i, nullptr);\n@@ -3660,1 +3660,1 @@\n-    if (interval != NULL) {\n+    if (interval != nullptr) {\n@@ -3662,2 +3662,2 @@\n-    } else if (input_state->at(reg) != NULL) {\n-      TRACE_LINEAR_SCAN(4, tty->print_cr(\"        reg[%d] = NULL\", reg));\n+    } else if (input_state->at(reg) != nullptr) {\n+      TRACE_LINEAR_SCAN(4, tty->print_cr(\"        reg[%d] = null\", reg));\n@@ -3708,2 +3708,2 @@\n-          state_put(input_state, interval->assigned_reg(),   NULL);\n-          state_put(input_state, interval->assigned_regHi(), NULL);\n+          state_put(input_state, interval->assigned_reg(),   nullptr);\n+          state_put(input_state, interval->assigned_regHi(), nullptr);\n@@ -3717,1 +3717,1 @@\n-        state_put(input_state, reg_num(FrameMap::caller_save_cpu_reg_at(j)), NULL);\n+        state_put(input_state, reg_num(FrameMap::caller_save_cpu_reg_at(j)), nullptr);\n@@ -3720,1 +3720,1 @@\n-        state_put(input_state, reg_num(FrameMap::caller_save_fpu_reg_at(j)), NULL);\n+        state_put(input_state, reg_num(FrameMap::caller_save_fpu_reg_at(j)), nullptr);\n@@ -3726,1 +3726,1 @@\n-        state_put(input_state, reg_num(FrameMap::caller_save_xmm_reg_at(j)), NULL);\n+        state_put(input_state, reg_num(FrameMap::caller_save_xmm_reg_at(j)), nullptr);\n@@ -3738,1 +3738,1 @@\n-    \/\/ set temp operands (some operations use temp operands also as output operands, so can't set them NULL)\n+    \/\/ set temp operands (some operations use temp operands also as output operands, so can't set them null)\n@@ -3779,1 +3779,1 @@\n-  _insert_list(NULL),\n+  _insert_list(nullptr),\n@@ -3807,1 +3807,1 @@\n-  assert(_insert_list != NULL && _insert_idx != -1, \"insert position not set\");\n+  assert(_insert_list != nullptr && _insert_idx != -1, \"insert position not set\");\n@@ -3813,1 +3813,1 @@\n-        assert(_mapping_from.at(i) == NULL || _mapping_from.at(i) != _mapping_from.at(j), \"cannot read from same interval twice\");\n+        assert(_mapping_from.at(i) == nullptr || _mapping_from.at(i) != _mapping_from.at(j), \"cannot read from same interval twice\");\n@@ -3829,1 +3829,1 @@\n-      if (it != NULL) {\n+      if (it != nullptr) {\n@@ -3856,1 +3856,1 @@\n-    if (it != NULL && it->assigned_reg() >= LinearScan::nof_regs) {\n+    if (it != nullptr && it->assigned_reg() >= LinearScan::nof_regs) {\n@@ -3901,1 +3901,1 @@\n-  if (from != NULL) {\n+  if (from != nullptr) {\n@@ -3934,1 +3934,1 @@\n-  _insert_list = NULL;\n+  _insert_list = nullptr;\n@@ -3941,1 +3941,1 @@\n-  assert(_insert_list != NULL && _insert_idx != -1, \"must setup insert position first\");\n+  assert(_insert_list != nullptr && _insert_idx != -1, \"must setup insert position first\");\n@@ -3960,1 +3960,1 @@\n-  assert(_insert_list != NULL && _insert_idx != -1, \"must setup insert position first\");\n+  assert(_insert_list != nullptr && _insert_idx != -1, \"must setup insert position first\");\n@@ -3986,1 +3986,1 @@\n-  TRACE_LINEAR_SCAN(4, tty->print_cr(\"MoveResolver: resolving mappings for Block B%d, index %d\", _insert_list->block() != NULL ? _insert_list->block()->block_id() : -1, _insert_idx));\n+  TRACE_LINEAR_SCAN(4, tty->print_cr(\"MoveResolver: resolving mappings for Block B%d, index %d\", _insert_list->block() != nullptr ? _insert_list->block()->block_id() : -1, _insert_idx));\n@@ -3995,1 +3995,1 @@\n-    if (from_interval != NULL) {\n+    if (from_interval != nullptr) {\n@@ -4010,1 +4010,1 @@\n-        if (from_interval != NULL) {\n+        if (from_interval != nullptr) {\n@@ -4021,1 +4021,1 @@\n-      } else if (from_interval != NULL && from_interval->assigned_reg() < LinearScan::nof_regs) {\n+      } else if (from_interval != nullptr && from_interval->assigned_reg() < LinearScan::nof_regs) {\n@@ -4071,2 +4071,2 @@\n-  TRACE_LINEAR_SCAN(4, tty->print_cr(\"MoveResolver: setting insert position to Block B%d, index %d\", insert_list->block() != NULL ? insert_list->block()->block_id() : -1, insert_idx));\n-  assert(_insert_list == NULL && _insert_idx == -1, \"use move_insert_position instead of set_insert_position when data already set\");\n+  TRACE_LINEAR_SCAN(4, tty->print_cr(\"MoveResolver: setting insert position to Block B%d, index %d\", insert_list->block() != nullptr ? insert_list->block()->block_id() : -1, insert_idx));\n+  assert(_insert_list == nullptr && _insert_idx == -1, \"use move_insert_position instead of set_insert_position when data already set\");\n@@ -4080,1 +4080,1 @@\n-  TRACE_LINEAR_SCAN(4, tty->print_cr(\"MoveResolver: moving insert position to Block B%d, index %d\", insert_list->block() != NULL ? insert_list->block()->block_id() : -1, insert_idx));\n+  TRACE_LINEAR_SCAN(4, tty->print_cr(\"MoveResolver: moving insert position to Block B%d, index %d\", insert_list->block() != nullptr ? insert_list->block()->block_id() : -1, insert_idx));\n@@ -4082,1 +4082,1 @@\n-  if (_insert_list != NULL && (insert_list != _insert_list || insert_idx != _insert_idx)) {\n+  if (_insert_list != nullptr && (insert_list != _insert_list || insert_idx != _insert_idx)) {\n@@ -4111,1 +4111,1 @@\n-  _mapping_from.append(NULL);\n+  _mapping_from.append(nullptr);\n@@ -4135,1 +4135,1 @@\n-Range* Range::_end = NULL;\n+Range* Range::_end = nullptr;\n@@ -4139,1 +4139,1 @@\n-  _end = ::new(static_cast<void*>(end_storage)) Range(max_jint, max_jint, NULL);\n+  _end = ::new(static_cast<void*>(end_storage)) Range(max_jint, max_jint, nullptr);\n@@ -4145,1 +4145,1 @@\n-  assert(r1 != NULL && r2 != NULL, \"null ranges not allowed\");\n+  assert(r1 != nullptr && r2 != nullptr, \"null ranges not allowed\");\n@@ -4184,1 +4184,1 @@\n-Interval* Interval::_end = NULL;\n+Interval* Interval::_end = nullptr;\n@@ -4205,1 +4205,1 @@\n-  _split_children(NULL),\n+  _split_children(nullptr),\n@@ -4210,1 +4210,1 @@\n-  _register_hint(NULL)\n+  _register_hint(nullptr)\n@@ -4230,1 +4230,1 @@\n-  if (_split_children != NULL && _split_children->length() > 0) {\n+  if (_split_children != nullptr && _split_children->length() > 0) {\n@@ -4262,1 +4262,1 @@\n-  if (_register_hint != NULL) {\n+  if (_register_hint != nullptr) {\n@@ -4268,1 +4268,1 @@\n-    } else if (_register_hint->_split_children != NULL && _register_hint->_split_children->length() > 0) {\n+    } else if (_register_hint->_split_children != nullptr && _register_hint->_split_children->length() > 0) {\n@@ -4282,1 +4282,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -4291,1 +4291,1 @@\n-  if (_split_children == NULL || _split_children->length() == 0) {\n+  if (_split_children == nullptr || _split_children->length() == 0) {\n@@ -4294,1 +4294,1 @@\n-    result = NULL;\n+    result = nullptr;\n@@ -4329,1 +4329,1 @@\n-  assert(result != NULL, \"no matching interval found\");\n+  assert(result != nullptr, \"no matching interval found\");\n@@ -4341,1 +4341,1 @@\n-  Interval* result = NULL;\n+  Interval* result = nullptr;\n@@ -4343,1 +4343,1 @@\n-  assert(parent->_split_children != NULL, \"no split children available\");\n+  assert(parent->_split_children != nullptr, \"no split children available\");\n@@ -4349,1 +4349,1 @@\n-    if (cur->to() <= op_id && (result == NULL || result->to() < cur->to())) {\n+    if (cur->to() <= op_id && (result == nullptr || result->to() < cur->to())) {\n@@ -4354,1 +4354,1 @@\n-  assert(result != NULL, \"no split child found\");\n+  assert(result != nullptr, \"no split child found\");\n@@ -4463,1 +4463,1 @@\n-  if (parent->_split_children == NULL) {\n+  if (parent->_split_children == nullptr) {\n@@ -4491,1 +4491,1 @@\n-  Range* prev = NULL;\n+  Range* prev = nullptr;\n@@ -4505,1 +4505,1 @@\n-    assert(prev != NULL, \"split before start of first range\");\n+    assert(prev != nullptr, \"split before start of first range\");\n@@ -4626,1 +4626,1 @@\n-  if (interval->_split_children != NULL) {\n+  if (interval->_split_children != nullptr) {\n@@ -4670,1 +4670,1 @@\n-  out->print(\"%d %d \", split_parent()->reg_num(), (register_hint(false) != NULL ? register_hint(false)->reg_num() : -1));\n+  out->print(\"%d %d \", split_parent()->reg_num(), (register_hint(false) != nullptr ? register_hint(false)->reg_num() : -1));\n@@ -4677,1 +4677,1 @@\n-    assert(cur != NULL, \"range list not closed with range sentinel\");\n+    assert(cur != nullptr, \"range list not closed with range sentinel\");\n@@ -4704,1 +4704,1 @@\n-  if (_split_children == NULL) {\n+  if (_split_children == nullptr) {\n@@ -4732,1 +4732,1 @@\n-  _current = NULL;\n+  _current = nullptr;\n@@ -4739,1 +4739,1 @@\n-  Interval* prev = NULL;\n+  Interval* prev = nullptr;\n@@ -4744,1 +4744,1 @@\n-  if (prev == NULL) {\n+  if (prev == nullptr) {\n@@ -4755,1 +4755,1 @@\n-  Interval* prev = NULL;\n+  Interval* prev = nullptr;\n@@ -4760,1 +4760,1 @@\n-  if (prev == NULL) {\n+  if (prev == nullptr) {\n@@ -4865,1 +4865,1 @@\n-    _current = NULL; return;\n+    _current = nullptr; return;\n@@ -4877,1 +4877,1 @@\n-  while (current() != NULL) {\n+  while (current() != nullptr) {\n@@ -5303,1 +5303,1 @@\n-    while (parent != NULL && parent->is_split_child()) {\n+    while (parent != nullptr && parent->is_split_child()) {\n@@ -5313,1 +5313,1 @@\n-          parent = NULL;\n+          parent = nullptr;\n@@ -5483,1 +5483,1 @@\n-  if (register_hint != NULL) {\n+  if (register_hint != nullptr) {\n@@ -5799,1 +5799,1 @@\n-  assert(op->as_Op1() != NULL, \"move must be LIR_Op1\");\n+  assert(op->as_Op1() != nullptr, \"move must be LIR_Op1\");\n@@ -5815,1 +5815,1 @@\n-  if (register_hint == NULL) {\n+  if (register_hint == nullptr) {\n@@ -5922,1 +5922,1 @@\n-    assert(cur->current_split_child() != NULL, \"must be\");\n+    assert(cur->current_split_child() != nullptr, \"must be\");\n@@ -5979,1 +5979,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -5996,1 +5996,1 @@\n-  if (op1 == NULL || op2 == NULL) {\n+  if (op1 == nullptr || op2 == nullptr) {\n@@ -6002,2 +6002,2 @@\n-    assert(op1->as_Op1() != NULL, \"move must be LIR_Op1\");\n-    assert(op2->as_Op1() != NULL, \"move must be LIR_Op1\");\n+    assert(op1->as_Op1() != nullptr, \"move must be LIR_Op1\");\n+    assert(op2->as_Op1() != nullptr, \"move must be LIR_Op1\");\n@@ -6012,2 +6012,2 @@\n-    assert(op1->as_Op1() != NULL, \"fxch must be LIR_Op1\");\n-    assert(op2->as_Op1() != NULL, \"fxch must be LIR_Op1\");\n+    assert(op1->as_Op1() != nullptr, \"fxch must be LIR_Op1\");\n+    assert(op2->as_Op1() != nullptr, \"fxch must be LIR_Op1\");\n@@ -6058,1 +6058,1 @@\n-    assert(pred_instructions->last()->as_OpBranch() != NULL, \"branch must be LIR_OpBranch\");\n+    assert(pred_instructions->last()->as_OpBranch() != nullptr, \"branch must be LIR_OpBranch\");\n@@ -6061,1 +6061,1 @@\n-    if (pred_instructions->last()->info() != NULL) {\n+    if (pred_instructions->last()->info() != nullptr) {\n@@ -6105,1 +6105,1 @@\n-  assert(cur_instructions->last()->as_OpBranch() != NULL, \"branch must be LIR_OpBranch\");\n+  assert(cur_instructions->last()->as_OpBranch() != nullptr, \"branch must be LIR_OpBranch\");\n@@ -6108,1 +6108,1 @@\n-  if (cur_instructions->last()->info() != NULL) {\n+  if (cur_instructions->last()->info() != nullptr) {\n@@ -6114,1 +6114,1 @@\n-  if (branch->info() != NULL || (branch->code() != lir_branch && branch->code() != lir_cond_float_branch)) {\n+  if (branch->info() != nullptr || (branch->code() != lir_branch && branch->code() != lir_cond_float_branch)) {\n@@ -6129,1 +6129,1 @@\n-    if ((op->code() == lir_branch || op->code() == lir_cond_float_branch) && ((LIR_OpBranch*)op)->block() != NULL) {\n+    if ((op->code() == lir_branch || op->code() == lir_cond_float_branch) && ((LIR_OpBranch*)op)->block() != nullptr) {\n@@ -6258,1 +6258,1 @@\n-  assert(instructions->last()->as_OpBranch() != NULL, \"last instruction must always be a branch\");\n+  assert(instructions->last()->as_OpBranch() != nullptr, \"last instruction must always be a branch\");\n@@ -6264,1 +6264,1 @@\n-  if (instructions->length() == 2 && instructions->last()->info() == NULL) {\n+  if (instructions->length() == 2 && instructions->last()->info() == nullptr) {\n@@ -6281,1 +6281,1 @@\n-      assert(op->as_OpBranch() != NULL, \"branch must be of type LIR_OpBranch\");\n+      assert(op->as_OpBranch() != nullptr, \"branch must be of type LIR_OpBranch\");\n@@ -6350,1 +6350,1 @@\n-      assert(last_op->as_OpBranch() != NULL, \"branch must be of type LIR_OpBranch\");\n+      assert(last_op->as_OpBranch() != nullptr, \"branch must be of type LIR_OpBranch\");\n@@ -6353,1 +6353,1 @@\n-      assert(last_branch->block() != NULL, \"last branch must always have a block as target\");\n+      assert(last_branch->block() != nullptr, \"last branch must always have a block as target\");\n@@ -6356,1 +6356,1 @@\n-      if (last_branch->info() == NULL) {\n+      if (last_branch->info() == nullptr) {\n@@ -6367,1 +6367,1 @@\n-            assert(prev_op->as_OpBranch() != NULL, \"branch must be of type LIR_OpBranch\");\n+            assert(prev_op->as_OpBranch() != nullptr, \"branch must be of type LIR_OpBranch\");\n@@ -6370,1 +6370,1 @@\n-            if (prev_branch->stub() == NULL) {\n+            if (prev_branch->stub() == nullptr) {\n@@ -6372,1 +6372,1 @@\n-              LIR_Op2* prev_cmp = NULL;\n+              LIR_Op2* prev_cmp = nullptr;\n@@ -6376,1 +6376,1 @@\n-              LIR_Op4* prev_cmove = NULL;\n+              LIR_Op4* prev_cmove = nullptr;\n@@ -6378,1 +6378,1 @@\n-              for(int j = instructions->length() - 3; j >= 0 && prev_cmp == NULL; j--) {\n+              for(int j = instructions->length() - 3; j >= 0 && prev_cmp == nullptr; j--) {\n@@ -6382,1 +6382,1 @@\n-                  assert(prev_op->as_Op4() != NULL, \"cmove must be of type LIR_Op4\");\n+                  assert(prev_op->as_Op4() != nullptr, \"cmove must be of type LIR_Op4\");\n@@ -6387,1 +6387,1 @@\n-                  assert(prev_op->as_Op2() != NULL, \"branch must be of type LIR_Op2\");\n+                  assert(prev_op->as_Op2() != nullptr, \"branch must be of type LIR_Op2\");\n@@ -6393,2 +6393,2 @@\n-              guarantee(prev_cmp != NULL, \"should have found comp instruction for branch\");\n-              if (prev_branch->block() == code->at(i + 1) && prev_branch->info() == NULL) {\n+              guarantee(prev_cmp != nullptr, \"should have found comp instruction for branch\");\n+              if (prev_branch->block() == code->at(i + 1) && prev_branch->info() == nullptr) {\n@@ -6404,1 +6404,1 @@\n-                if (prev_cmove != NULL) {\n+                if (prev_cmove != nullptr) {\n@@ -6441,1 +6441,1 @@\n-      assert(cur_last_op->info() == NULL, \"return instructions do not have debug information\");\n+      assert(cur_last_op->info() == nullptr, \"return instructions do not have debug information\");\n@@ -6446,1 +6446,1 @@\n-      assert(cur_last_op->as_Op1() != NULL, \"return must be LIR_Op1\");\n+      assert(cur_last_op->as_Op1() != nullptr, \"return must be LIR_Op1\");\n@@ -6455,1 +6455,1 @@\n-          assert(pred_last_op->as_OpBranch() != NULL, \"branch must be LIR_OpBranch\");\n+          assert(pred_last_op->as_OpBranch() != nullptr, \"branch must be LIR_OpBranch\");\n@@ -6458,1 +6458,1 @@\n-          if (pred_last_branch->block() == block && pred_last_branch->cond() == lir_cond_always && pred_last_branch->info() == NULL) {\n+          if (pred_last_branch->block() == block && pred_last_branch->cond() == lir_cond_always && pred_last_branch->info() == nullptr) {\n@@ -6483,3 +6483,3 @@\n-      if (op_branch != NULL) {\n-        assert(op_branch->block() == NULL || code->find(op_branch->block()) != -1, \"branch target not valid\");\n-        assert(op_branch->ublock() == NULL || code->find(op_branch->ublock()) != -1, \"branch target not valid\");\n+      if (op_branch != nullptr) {\n+        assert(op_branch->block() == nullptr || code->find(op_branch->block()) != -1, \"branch target not valid\");\n+        assert(op_branch->ublock() == nullptr || code->find(op_branch->ublock()) != -1, \"branch target not valid\");\n@@ -6633,1 +6633,1 @@\n-    if (cur != NULL) {\n+    if (cur != nullptr) {\n@@ -6720,1 +6720,1 @@\n-          if (branch->block() == NULL) {\n+          if (branch->block() == nullptr) {\n","filename":"src\/hotspot\/share\/c1\/c1_LinearScan.cpp","additions":241,"deletions":241,"binary":false,"changes":482,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,1 +59,1 @@\n-    if (log != NULL)\n+    if (log != nullptr)\n@@ -65,1 +65,1 @@\n-    if (log != NULL)\n+    if (log != nullptr)\n@@ -99,1 +99,1 @@\n-  if (if_ == NULL) return;\n+  if (if_ == nullptr) return;\n@@ -114,3 +114,3 @@\n-  Value t_const = NULL;\n-  Value f_const = NULL;\n-  if (t_cur->as_Constant() != NULL && !t_cur->can_trap()) {\n+  Value t_const = nullptr;\n+  Value f_const = nullptr;\n+  if (t_cur->as_Constant() != nullptr && !t_cur->can_trap()) {\n@@ -120,1 +120,1 @@\n-  if (f_cur->as_Constant() != NULL && !f_cur->can_trap()) {\n+  if (f_cur->as_Constant() != nullptr && !f_cur->can_trap()) {\n@@ -127,1 +127,1 @@\n-  if (t_goto == NULL) return;\n+  if (t_goto == nullptr) return;\n@@ -129,1 +129,1 @@\n-  if (f_goto == NULL) return;\n+  if (f_goto == nullptr) return;\n@@ -142,1 +142,1 @@\n-      assert(if_state != NULL, \"states do not match up\");\n+      assert(if_state != nullptr, \"states do not match up\");\n@@ -147,1 +147,1 @@\n-      assert(sux_state != NULL, \"states do not match up\");\n+      assert(sux_state != nullptr, \"states do not match up\");\n@@ -156,1 +156,1 @@\n-  if (sux_phi == NULL || sux_phi->as_Phi() == NULL || sux_phi->as_Phi()->block() != sux) return;\n+  if (sux_phi == nullptr || sux_phi->as_Phi() == nullptr || sux_phi->as_Phi()->block() != sux) return;\n@@ -222,1 +222,1 @@\n-  assert(result != NULL, \"make_ifop must return a non-null instruction\");\n+  assert(result != nullptr, \"make_ifop must return a non-null instruction\");\n@@ -292,1 +292,1 @@\n-  if (y_const != NULL) {\n+  if (y_const != nullptr) {\n@@ -294,1 +294,1 @@\n-    if (x_ifop != NULL) {                 \/\/ x is an ifop, y is a constant\n+    if (x_ifop != nullptr) {                 \/\/ x is an ifop, y is a constant\n@@ -298,1 +298,1 @@\n-      if (x_tval_const != NULL && x_fval_const != NULL) {\n+      if (x_tval_const != nullptr && x_fval_const != nullptr) {\n@@ -319,1 +319,1 @@\n-      if (x_const != NULL) {         \/\/ x and y are constants\n+      if (x_const != nullptr) { \/\/ x and y are constants\n@@ -363,1 +363,1 @@\n-    if (log != NULL)\n+    if (log != nullptr)\n@@ -369,1 +369,1 @@\n-    if (log != NULL)\n+    if (log != nullptr)\n@@ -375,1 +375,1 @@\n-    if (end->as_Goto() == NULL) return false;\n+    if (end->as_Goto() == nullptr) return false;\n@@ -407,1 +407,1 @@\n-      if (sux_phi != NULL && sux_phi->is_illegal()) continue;\n+      if (sux_phi != nullptr && sux_phi->is_illegal()) continue;\n@@ -422,1 +422,1 @@\n-    assert(prev->as_BlockEnd() == NULL, \"must not be a BlockEnd\");\n+    assert(prev->as_BlockEnd() == nullptr, \"must not be a BlockEnd\");\n@@ -475,1 +475,1 @@\n-          \/\/ becomes NULL In such (rare) cases it is not\n+          \/\/ becomes null In such (rare) cases it is not\n@@ -478,1 +478,1 @@\n-          while (prev != NULL && prev->next() != if_) {\n+          while (prev != nullptr && prev->next() != if_) {\n@@ -482,1 +482,1 @@\n-          if (prev != NULL) {\n+          if (prev != nullptr) {\n@@ -610,1 +610,1 @@\n-    assert(_visitable_instructions != NULL, \"check\");\n+    assert(_visitable_instructions != nullptr, \"check\");\n@@ -614,1 +614,1 @@\n-    assert(_visitable_instructions != NULL, \"check\");\n+    assert(_visitable_instructions != nullptr, \"check\");\n@@ -618,1 +618,1 @@\n-    assert(_visitable_instructions != NULL, \"check\");\n+    assert(_visitable_instructions != nullptr, \"check\");\n@@ -622,1 +622,1 @@\n-    assert(_visitable_instructions != NULL, \"check\");\n+    assert(_visitable_instructions != nullptr, \"check\");\n@@ -631,3 +631,3 @@\n-  bool set_contains(Value x)                      { assert(_set != NULL, \"check\"); return _set->contains(x); }\n-  void set_put     (Value x)                      { assert(_set != NULL, \"check\"); _set->put(x); }\n-  void set_remove  (Value x)                      { assert(_set != NULL, \"check\"); _set->remove(x); }\n+  bool set_contains(Value x)                      { assert(_set != nullptr, \"check\"); return _set->contains(x); }\n+  void set_put     (Value x)                      { assert(_set != nullptr, \"check\"); _set->put(x); }\n+  void set_remove  (Value x)                      { assert(_set != nullptr, \"check\"); _set->remove(x); }\n@@ -654,2 +654,2 @@\n-    , _block_states(BlockBegin::number_of_blocks(), BlockBegin::number_of_blocks(), NULL)\n-    , _last_explicit_null_check(NULL) {\n+    , _block_states(BlockBegin::number_of_blocks(), BlockBegin::number_of_blocks(), nullptr)\n+    , _last_explicit_null_check(nullptr) {\n@@ -659,1 +659,1 @@\n-    if (log != NULL)\n+    if (log != nullptr)\n@@ -665,1 +665,1 @@\n-    if (log != NULL)\n+    if (log != nullptr)\n@@ -688,1 +688,1 @@\n-                                                                         : NULL); }\n+                                                                         : nullptr); }\n@@ -694,1 +694,1 @@\n-  void        clear_last_explicit_null_check()               { _last_explicit_null_check = NULL; }\n+  void        clear_last_explicit_null_check()               { _last_explicit_null_check = nullptr; }\n@@ -782,1 +782,1 @@\n-  assert(*p != NULL, \"should not find NULL instructions\");\n+  assert(*p != nullptr, \"should not find null instructions\");\n@@ -791,1 +791,1 @@\n-  if (state == NULL) {\n+  if (state == nullptr) {\n@@ -815,1 +815,1 @@\n-  set_last_explicit_null_check(NULL);\n+  set_last_explicit_null_check(nullptr);\n@@ -826,1 +826,1 @@\n-  if (state_for(block) == NULL) {\n+  if (state_for(block) == nullptr) {\n@@ -836,1 +836,1 @@\n-      assert(local0 != NULL, \"must be\");\n+      assert(local0 != nullptr, \"must be\");\n@@ -839,1 +839,1 @@\n-      if (local0 != NULL) {\n+      if (local0 != nullptr) {\n@@ -861,1 +861,1 @@\n-  assert(e != NULL, \"incomplete graph\");\n+  assert(e != nullptr, \"incomplete graph\");\n@@ -879,1 +879,1 @@\n-  for (Instruction* instr = block; instr != NULL; instr = instr->next()) {\n+  for (Instruction* instr = block; instr != nullptr; instr = instr->next()) {\n@@ -885,1 +885,1 @@\n-    if (instr->is_pinned() || instr->can_trap() || (instr->as_NullCheck() != NULL)) {\n+    if (instr->is_pinned() || instr->can_trap() || (instr->as_NullCheck() != nullptr)) {\n@@ -911,1 +911,1 @@\n-    if (x->as_LoadField() != NULL) {\n+    if (x->as_LoadField() != nullptr) {\n@@ -947,1 +947,1 @@\n-      x->set_explicit_null_check(NULL);\n+      x->set_explicit_null_check(nullptr);\n@@ -960,1 +960,1 @@\n-    x->set_explicit_null_check(NULL);\n+    x->set_explicit_null_check(nullptr);\n@@ -978,1 +978,1 @@\n-      x->set_explicit_null_check(NULL);\n+      x->set_explicit_null_check(nullptr);\n@@ -991,1 +991,1 @@\n-    x->set_explicit_null_check(NULL);\n+    x->set_explicit_null_check(nullptr);\n@@ -1009,1 +1009,1 @@\n-      x->set_explicit_null_check(NULL);\n+      x->set_explicit_null_check(nullptr);\n@@ -1022,1 +1022,1 @@\n-    x->set_explicit_null_check(NULL);\n+    x->set_explicit_null_check(nullptr);\n","filename":"src\/hotspot\/share\/c1\/c1_Optimizer.cpp","additions":55,"deletions":55,"binary":false,"changes":110,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,2 +59,2 @@\n-  _bounds(Instruction::number_of_instructions(), Instruction::number_of_instructions(), NULL),\n-  _access_indexed_info(Instruction::number_of_instructions(), Instruction::number_of_instructions(), NULL)\n+  _bounds(Instruction::number_of_instructions(), Instruction::number_of_instructions(), nullptr),\n+  _access_indexed_info(Instruction::number_of_instructions(), Instruction::number_of_instructions(), nullptr)\n@@ -95,1 +95,1 @@\n-  calc_bounds(ir->start(), NULL);\n+  calc_bounds(ir->start(), nullptr);\n@@ -106,1 +106,1 @@\n-  if (ic != NULL) {\n+  if (ic != nullptr) {\n@@ -108,1 +108,1 @@\n-    _bound = new Bound(value, NULL, value, NULL);\n+    _bound = new Bound(value, nullptr, value, nullptr);\n@@ -117,1 +117,1 @@\n-    if (c != NULL) {\n+    if (c != nullptr) {\n@@ -123,1 +123,1 @@\n-      _bound = new Bound(0, NULL, constant, NULL);\n+      _bound = new Bound(0, nullptr, constant, nullptr);\n@@ -137,1 +137,1 @@\n-  Bound *bound = NULL;\n+  Bound* bound = nullptr;\n@@ -147,1 +147,1 @@\n-    if (op2 != NULL) {\n+    if (op2 != nullptr) {\n@@ -156,1 +156,1 @@\n-        if (ao != NULL && ao->op() == Bytecodes::_iadd) {\n+        if (ao != nullptr && ao->op() == Bytecodes::_iadd) {\n@@ -160,1 +160,1 @@\n-            if (c != NULL) {\n+            if (c != nullptr) {\n@@ -187,1 +187,1 @@\n-      cur_value = NULL;\n+      cur_value = nullptr;\n@@ -202,1 +202,1 @@\n-      bound = NULL;\n+      bound = nullptr;\n@@ -229,2 +229,2 @@\n-    if (x_bound->lower() >= 0 && x_bound->lower_instr() == NULL && y->as_ArrayLength() != NULL) {\n-      _bound = new Bound(0, NULL, -1, y);\n+    if (x_bound->lower() >= 0 && x_bound->lower_instr() == nullptr && y->as_ArrayLength() != nullptr) {\n+      _bound = new Bound(0, nullptr, -1, y);\n@@ -245,1 +245,1 @@\n-        _bound = new Bound(0, NULL, y->type()->as_IntConstant()->value() - 1, NULL);\n+        _bound = new Bound(0, nullptr, y->type()->as_IntConstant()->value() - 1, nullptr);\n@@ -295,1 +295,1 @@\n-          _bound = new Bound(Instruction::geq, NULL, bound->lower());\n+          _bound = new Bound(Instruction::geq, nullptr, bound->lower());\n@@ -318,1 +318,1 @@\n-    _bound = new Bound(min, NULL, max, NULL);\n+    _bound = new Bound(min, nullptr, max, nullptr);\n@@ -324,2 +324,2 @@\n-  \/\/ Wrong type or NULL -> No bound\n-  if (!v || (!v->type()->as_IntType() && !v->type()->as_ObjectType())) return NULL;\n+  \/\/ Wrong type or null -> No bound\n+  if (!v || (!v->type()->as_IntType() && !v->type()->as_ObjectType())) return nullptr;\n@@ -368,1 +368,1 @@\n-  for (BlockBegin *d = loop_header->dominator(); d != NULL; d = d->dominator()) {\n+  for (BlockBegin* d = loop_header->dominator(); d != nullptr; d = d->dominator()) {\n@@ -386,1 +386,1 @@\n-  Bound *top = NULL;\n+  Bound* top = nullptr;\n@@ -401,1 +401,1 @@\n-  if (aii == NULL) {\n+  if (aii == nullptr) {\n@@ -441,1 +441,1 @@\n-      if (c != NULL) {\n+      if (c != nullptr) {\n@@ -458,1 +458,1 @@\n-        while (ao != NULL && (ao->x()->as_Constant() || ao->y()->as_Constant()) && (ao->op() == Bytecodes::_iadd || ao->op() == Bytecodes::_isub)) {\n+        while (ao != nullptr && (ao->x()->as_Constant() || ao->y()->as_Constant()) && (ao->op() == Bytecodes::_iadd || ao->op() == Bytecodes::_isub)) {\n@@ -491,1 +491,1 @@\n-        assert(info != NULL, \"Info must not be null\");\n+        assert(info != nullptr, \"Info must not be null\");\n@@ -510,1 +510,1 @@\n-          Constant *min_constant = NULL;\n+          Constant *min_constant = nullptr;\n@@ -518,1 +518,1 @@\n-          Constant *max_constant = NULL;\n+          Constant *max_constant = nullptr;\n@@ -538,1 +538,1 @@\n-            ArithmeticOp *ao = new ArithmeticOp(Bytecodes::_iadd, min_constant, lower_compare, NULL);\n+            ArithmeticOp *ao = new ArithmeticOp(Bytecodes::_iadd, min_constant, lower_compare, nullptr);\n@@ -546,1 +546,1 @@\n-            ArithmeticOp *ao = new ArithmeticOp(Bytecodes::_iadd, max_constant, upper_compare, NULL);\n+            ArithmeticOp *ao = new ArithmeticOp(Bytecodes::_iadd, max_constant, upper_compare, nullptr);\n@@ -591,1 +591,1 @@\n-      _access_indexed_info.at_put(index_instruction->id(), NULL);\n+      _access_indexed_info.at_put(index_instruction->id(), nullptr);\n@@ -602,1 +602,1 @@\n-    process |= (cur->as_AccessIndexed() != NULL);\n+    process |= (cur->as_AccessIndexed() != nullptr);\n@@ -668,1 +668,1 @@\n-  ArithmeticOp *ao = new ArithmeticOp(Bytecodes::_iadd, constant, left, NULL);\n+  ArithmeticOp *ao = new ArithmeticOp(Bytecodes::_iadd, constant, left, nullptr);\n@@ -757,1 +757,1 @@\n-  if (c != NULL) {\n+  if (c != nullptr) {\n@@ -759,2 +759,2 @@\n-    instr_value = NULL;\n-  } else if (ao != NULL &&  (!ao->x()->as_Constant() || !ao->y()->as_Constant()) && ((ao->op() == Bytecodes::_isub && ao->y()->as_Constant()) || ao->op() == Bytecodes::_iadd)) {\n+    instr_value = nullptr;\n+  } else if (ao != nullptr &&  (!ao->x()->as_Constant() || !ao->y()->as_Constant()) && ((ao->op() == Bytecodes::_isub && ao->y()->as_Constant()) || ao->op() == Bytecodes::_iadd)) {\n@@ -764,1 +764,1 @@\n-    if (c != NULL) {\n+    if (c != nullptr) {\n@@ -769,1 +769,1 @@\n-      if (c != NULL) {\n+      if (c != nullptr) {\n@@ -811,1 +811,1 @@\n-    tty->print_cr(\"Access indexed: index=%d length=%d\", ai->index()->id(), (ai->length() != NULL ? ai->length()->id() :-1 ))\n+    tty->print_cr(\"Access indexed: index=%d length=%d\", ai->index()->id(), (ai->length() != nullptr ? ai->length()->id() :-1 ))\n@@ -894,1 +894,1 @@\n-        length_instr = NULL;\n+        length_instr = nullptr;\n@@ -903,1 +903,1 @@\n-      assert(pred_block != NULL, \"Every loop header has a dominator!\");\n+      assert(pred_block != nullptr, \"Every loop header has a dominator!\");\n@@ -907,1 +907,1 @@\n-      if (pred_block_end->as_Goto() && state == NULL) state = pred_block_end->state();\n+      if (pred_block_end->as_Goto() && state == nullptr) state = pred_block_end->state();\n@@ -952,1 +952,1 @@\n-      cur_value = NULL;\n+      cur_value = nullptr;\n@@ -954,1 +954,1 @@\n-    Bound *new_index_bound = new Bound(0, NULL, cur_constant, cur_value);\n+    Bound* new_index_bound = new Bound(0, nullptr, cur_constant, cur_value);\n@@ -974,1 +974,1 @@\n-  if (parent != NULL) {\n+  if (parent != nullptr) {\n@@ -976,1 +976,1 @@\n-    if (cond != NULL) {\n+    if (cond != nullptr) {\n@@ -991,1 +991,1 @@\n-      if (ai != NULL) {\n+      if (ai != nullptr) {\n@@ -1000,1 +1000,1 @@\n-          update_bound(pushed, ai->index(), Instruction::geq, NULL, 0);\n+          update_bound(pushed, ai->index(), Instruction::geq, nullptr, 0);\n@@ -1005,1 +1005,1 @@\n-            update_bound(pushed, ai->index(), Instruction::lss, NULL, value);\n+            update_bound(pushed, ai->index(), Instruction::lss, nullptr, value);\n@@ -1009,1 +1009,1 @@\n-            if (instr == NULL) instr = ai->array();\n+            if (instr == nullptr) instr = ai->array();\n@@ -1101,2 +1101,2 @@\n-      BlockBegin *sux = block->sux_at(i);\n-      BlockBegin *pred = NULL;\n+      BlockBegin* sux = block->sux_at(i);\n+      BlockBegin* pred = nullptr;\n@@ -1105,1 +1105,1 @@\n-        assert(cur != NULL, \"Predecessor must not be null\");\n+        assert(cur != nullptr, \"Predecessor must not be null\");\n@@ -1224,1 +1224,1 @@\n-bool RangeCheckEliminator::Verification::can_reach(BlockBegin *start, BlockBegin *end, BlockBegin *dont_use \/* = NULL *\/) {\n+bool RangeCheckEliminator::Verification::can_reach(BlockBegin* start, BlockBegin* end, BlockBegin* dont_use \/* = nullptr *\/) {\n@@ -1263,1 +1263,1 @@\n-      assert(sux != NULL, \"Successor must not be NULL!\");\n+      assert(sux != nullptr, \"Successor must not be null!\");\n@@ -1287,2 +1287,2 @@\n-  this->_lower_instr = NULL;\n-  this->_upper_instr = NULL;\n+  this->_lower_instr = nullptr;\n+  this->_upper_instr = nullptr;\n@@ -1314,3 +1314,3 @@\n-    _lower_instr = NULL;\n-    _upper_instr = NULL;\n-    if (v == NULL) {\n+    _lower_instr = nullptr;\n+    _upper_instr = nullptr;\n+    if (v == nullptr) {\n@@ -1328,1 +1328,1 @@\n-    _upper_instr = NULL;\n+    _upper_instr = nullptr;\n@@ -1331,1 +1331,1 @@\n-    _lower_instr = NULL;\n+    _lower_instr = nullptr;\n@@ -1364,1 +1364,1 @@\n-    _lower_instr = NULL;\n+    _lower_instr = nullptr;\n@@ -1371,1 +1371,1 @@\n-    _upper_instr = NULL;\n+    _upper_instr = nullptr;\n@@ -1386,1 +1386,1 @@\n-    if (_lower_instr != NULL && b->_lower_instr != NULL) {\n+    if (_lower_instr != nullptr && b->_lower_instr != nullptr) {\n@@ -1400,1 +1400,1 @@\n-    if (_upper_instr != NULL && b->_upper_instr != NULL) {\n+    if (_upper_instr != nullptr && b->_upper_instr != nullptr) {\n@@ -1412,1 +1412,1 @@\n-  return _upper_instr != NULL || _upper < max_jint;\n+  return _upper_instr != nullptr || _upper < max_jint;\n@@ -1425,1 +1425,1 @@\n-  return _lower_instr != NULL || _lower > min_jint;\n+  return _lower_instr != nullptr || _lower > min_jint;\n@@ -1431,3 +1431,3 @@\n-  assert(array != NULL, \"Must not be null!\");\n-  assert(bound != NULL, \"Must not be null!\");\n-  if (bound->lower() >=0 && bound->lower_instr() == NULL && bound->upper() < 0 && bound->upper_instr() != NULL) {\n+  assert(array != nullptr, \"Must not be null!\");\n+  assert(bound != nullptr, \"Must not be null!\");\n+  if (bound->lower() >=0 && bound->lower_instr() == nullptr && bound->upper() < 0 && bound->upper_instr() != nullptr) {\n@@ -1435,1 +1435,1 @@\n-    if (bound->upper_instr() == array || (len != NULL && len->array() == array)) {\n+    if (bound->upper_instr() == array || (len != nullptr && len->array() == array)) {\n@@ -1445,1 +1445,1 @@\n-  _lower_instr = NULL;\n+  _lower_instr = nullptr;\n@@ -1451,1 +1451,1 @@\n-  _upper_instr = NULL;\n+  _upper_instr = nullptr;\n@@ -1521,3 +1521,3 @@\n-  Instruction *result = position;\n-  Instruction *compare_with = NULL;\n-  ValueStack *state = position->state_before();\n+  Instruction* result = position;\n+  Instruction* compare_with = nullptr;\n+  ValueStack* state = position->state_before();\n@@ -1527,1 +1527,1 @@\n-  Instruction *instruction_before = position->prev();\n+  Instruction* instruction_before = position->prev();\n@@ -1533,1 +1533,1 @@\n-  Constant *constant = NULL;\n+  Constant* constant = nullptr;\n@@ -1557,1 +1557,1 @@\n-      ArithmeticOp *ao = new ArithmeticOp(Bytecodes::_iadd, constant, op, NULL);\n+      ArithmeticOp* ao = new ArithmeticOp(Bytecodes::_iadd, constant, op, nullptr);\n@@ -1564,2 +1564,2 @@\n-  assert(compare_with != NULL, \"You have to compare with something!\");\n-  assert(instruction != NULL, \"Instruction must not be null!\");\n+  assert(compare_with != nullptr, \"You have to compare with something!\");\n+  assert(instruction != nullptr, \"Instruction must not be null!\");\n","filename":"src\/hotspot\/share\/c1\/c1_RangeCheckElimination.cpp","additions":83,"deletions":83,"binary":false,"changes":166,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,1 +55,1 @@\n-    bool can_reach(BlockBegin *start, BlockBegin *end, BlockBegin *dont_use = NULL);\n+    bool can_reach(BlockBegin *start, BlockBegin *end, BlockBegin *dont_use = nullptr);\n@@ -118,1 +118,1 @@\n-    void clear_bound() { _bound = NULL; }\n+    void clear_bound() { _bound = nullptr; }\n","filename":"src\/hotspot\/share\/c1\/c1_RangeCheckElimination.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -158,1 +158,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -218,1 +218,1 @@\n-  assert(oop_maps == NULL || sasm->frame_size() != no_frame_size,\n+  assert(oop_maps == nullptr || sasm->frame_size() != no_frame_size,\n@@ -220,1 +220,1 @@\n-  assert(!expect_oop_map || oop_maps != NULL, \"must have an oopmap\");\n+  assert(!expect_oop_map || oop_maps != nullptr, \"must have an oopmap\");\n@@ -236,1 +236,1 @@\n-  assert(blob != NULL, \"blob must exist\");\n+  assert(blob != nullptr, \"blob must exist\");\n@@ -275,1 +275,1 @@\n-      if (_blobs[id]->oop_maps() != NULL) {\n+      if (_blobs[id]->oop_maps() != nullptr) {\n@@ -445,1 +445,1 @@\n-  nmethod* osr_nm = NULL;\n+  nmethod* osr_nm = nullptr;\n@@ -454,1 +454,1 @@\n-  assert(nm!= NULL && nm->is_nmethod(), \"Sanity check\");\n+  assert(nm!= nullptr && nm->is_nmethod(), \"Sanity check\");\n@@ -489,1 +489,1 @@\n-    if (osr_nm != NULL) {\n+    if (osr_nm != nullptr) {\n@@ -498,1 +498,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -536,1 +536,1 @@\n-  assert(nm != NULL, \"this is not an nmethod\");\n+  assert(nm != nullptr, \"this is not an nmethod\");\n@@ -548,1 +548,1 @@\n-  assert(exception.not_null(), \"NULL exceptions should be handled by throw_exception\");\n+  assert(exception.not_null(), \"null exceptions should be handled by throw_exception\");\n@@ -558,1 +558,1 @@\n-    assert(nm->method() != NULL, \"Unexpected NULL method()\");\n+    assert(nm->method() != nullptr, \"Unexpected null method()\");\n@@ -600,1 +600,1 @@\n-    if (fast_continuation != NULL) {\n+    if (fast_continuation != nullptr) {\n@@ -609,2 +609,2 @@\n-  \/\/ skip the exception cache update (i.e., just leave continuation==NULL).\n-  address continuation = NULL;\n+  \/\/ skip the exception cache update (i.e., just leave continuation as null).\n+  address continuation = nullptr;\n@@ -633,1 +633,1 @@\n-    if (continuation != NULL && !recursive_exception) {\n+    if (continuation != nullptr && !recursive_exception) {\n@@ -662,2 +662,2 @@\n-  nmethod* nm = NULL;\n-  address continuation = NULL;\n+  nmethod* nm = nullptr;\n+  address continuation = nullptr;\n@@ -673,1 +673,1 @@\n-  if (nm != NULL && caller_is_deopted(current)) {\n+  if (nm != nullptr && caller_is_deopted(current)) {\n@@ -677,1 +677,1 @@\n-  assert(continuation != NULL, \"no handler found\");\n+  assert(continuation != nullptr, \"no handler found\");\n@@ -774,1 +774,1 @@\n-  assert(oopDesc::is_oop(obj), \"must be NULL or an object\");\n+  assert(oopDesc::is_oop(obj), \"must be null or an object\");\n@@ -789,1 +789,1 @@\n-  assert(nm != NULL, \"Sanity check\");\n+  assert(nm != nullptr, \"Sanity check\");\n@@ -799,1 +799,1 @@\n-        if (trap_mdo != NULL) {\n+        if (trap_mdo != nullptr) {\n@@ -894,1 +894,1 @@\n-\/\/ NULL, so the next thread to execute this code will fail the test,\n+\/\/ null, so the next thread to execute this code will fail the test,\n@@ -957,4 +957,4 @@\n-  Klass* init_klass = NULL; \/\/ klass needed by load_klass_patching code\n-  Klass* load_klass = NULL; \/\/ klass needed by load_klass_patching code\n-  Handle mirror(current, NULL);                    \/\/ oop needed by load_mirror_patching code\n-  Handle appendix(current, NULL);                  \/\/ oop needed by appendix_patching code\n+  Klass* init_klass = nullptr; \/\/ klass needed by load_klass_patching code\n+  Klass* load_klass = nullptr; \/\/ klass needed by load_klass_patching code\n+  Handle mirror(current, nullptr); \/\/ oop needed by load_mirror_patching code\n+  Handle appendix(current, nullptr); \/\/ oop needed by appendix_patching code\n@@ -1000,1 +1000,1 @@\n-    Klass* k = NULL;\n+    Klass* k = nullptr;\n@@ -1091,1 +1091,1 @@\n-    if (nm != NULL) {\n+    if (nm != nullptr) {\n@@ -1137,1 +1137,1 @@\n-          assert(caller_code != NULL, \"nmethod not found\");\n+          assert(caller_code != nullptr, \"nmethod not found\");\n@@ -1143,1 +1143,1 @@\n-          assert(map != NULL, \"null check\");\n+          assert(map != nullptr, \"null check\");\n@@ -1178,1 +1178,1 @@\n-              assert(load_klass != NULL, \"klass not set\");\n+              assert(load_klass != nullptr, \"klass not set\");\n@@ -1211,2 +1211,2 @@\n-            address addr = NULL;\n-            assert(nm != NULL, \"invalid nmethod_pc\");\n+            address addr = nullptr;\n+            assert(nm != nullptr, \"invalid nmethod_pc\");\n@@ -1228,1 +1228,1 @@\n-            assert(addr != NULL, \"metadata relocation must exist\");\n+            assert(addr != nullptr, \"metadata relocation must exist\");\n@@ -1252,1 +1252,1 @@\n-            assert(nm != NULL, \"invalid nmethod_pc\");\n+            assert(nm != nullptr, \"invalid nmethod_pc\");\n@@ -1275,1 +1275,1 @@\n-    guarantee(nm != NULL, \"only nmethods can contain non-perm oops\");\n+    guarantee(nm != nullptr, \"only nmethods can contain non-perm oops\");\n@@ -1343,1 +1343,1 @@\n-    if (nm != NULL) {\n+    if (nm != nullptr) {\n@@ -1455,1 +1455,1 @@\n-  assert(mirror != NULL, \"should null-check on mirror before calling\");\n+  assert(mirror != nullptr, \"should null-check on mirror before calling\");\n@@ -1457,1 +1457,1 @@\n-  return (k != NULL && obj != NULL && obj->is_a(k)) ? 1 : 0;\n+  return (k != nullptr && obj != nullptr && obj->is_a(k)) ? 1 : 0;\n@@ -1471,1 +1471,1 @@\n-  assert (nm != NULL, \"no more nmethod?\");\n+  assert (nm != nullptr, \"no more nmethod?\");\n@@ -1477,1 +1477,1 @@\n-  if (mdo == NULL && !HAS_PENDING_EXCEPTION) {\n+  if (mdo == nullptr && !HAS_PENDING_EXCEPTION) {\n@@ -1489,1 +1489,1 @@\n-  if (mdo != NULL) {\n+  if (mdo != nullptr) {\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.cpp","additions":44,"deletions":44,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-  , _entries(ValueMapInitialSize, ValueMapInitialSize, NULL)\n+  , _entries(ValueMapInitialSize, ValueMapInitialSize, nullptr)\n@@ -59,1 +59,1 @@\n-  , _entries(old->_entries.length(), old->_entries.length(), NULL)\n+  , _entries(old->_entries.length(), old->_entries.length(), nullptr)\n@@ -75,1 +75,1 @@\n-  ValueMapEntryArray new_entries(new_size, new_size, NULL);\n+  ValueMapEntryArray new_entries(new_size, new_size, nullptr);\n@@ -82,1 +82,1 @@\n-    for (entry = entry_at(i); entry != NULL; entry = entry->next()) {\n+    for (entry = entry_at(i); entry != nullptr; entry = entry->next()) {\n@@ -96,1 +96,1 @@\n-        entry = new ValueMapEntry(entry->hash(), entry->value(), entry->nesting(), NULL);\n+        entry = new ValueMapEntry(entry->hash(), entry->value(), entry->nesting(), nullptr);\n@@ -115,1 +115,1 @@\n-    for (ValueMapEntry* entry = entry_at(entry_index(hash, size())); entry != NULL; entry = entry->next()) {\n+    for (ValueMapEntry* entry = entry_at(entry_index(hash, size())); entry != nullptr; entry = entry->next()) {\n@@ -123,1 +123,1 @@\n-          if (entry->nesting() != nesting() && f->as_Constant() == NULL) {\n+          if (entry->nesting() != nesting() && f->as_Constant() == nullptr) {\n@@ -155,2 +155,2 @@\n-    ValueMapEntry* prev_entry = NULL;                                                    \\\n-    for (ValueMapEntry* entry = entry_at(i); entry != NULL; entry = entry->next()) {     \\\n+    ValueMapEntry* prev_entry = nullptr;                                                 \\\n+    for (ValueMapEntry* entry = entry_at(i); entry != nullptr; entry = entry->next()) {  \\\n@@ -164,1 +164,1 @@\n-        if (prev_entry == NULL) {                                                        \\\n+        if (prev_entry == nullptr) {                                                     \\\n@@ -182,1 +182,1 @@\n-  bool must_kill = value->as_LoadField() != NULL || value->as_LoadIndexed() != NULL;\n+  bool must_kill = value->as_LoadField() != nullptr || value->as_LoadIndexed() != nullptr;\n@@ -185,1 +185,1 @@\n-  bool must_kill = value->as_LoadIndexed() != NULL                                       \\\n+  bool must_kill = value->as_LoadIndexed() != nullptr                                    \\\n@@ -191,1 +191,1 @@\n-  bool must_kill = lf != NULL                                                            \\\n+  bool must_kill = lf != nullptr                                                         \\\n@@ -216,1 +216,1 @@\n-    _entries.at_put(i, NULL);\n+    _entries.at_put(i, nullptr);\n@@ -229,1 +229,1 @@\n-    if (entry_at(i) != NULL) {\n+    if (entry_at(i) != nullptr) {\n@@ -231,1 +231,1 @@\n-      for (ValueMapEntry* entry = entry_at(i); entry != NULL; entry = entry->next()) {\n+      for (ValueMapEntry* entry = entry_at(i); entry != nullptr; entry = entry->next()) {\n@@ -236,1 +236,1 @@\n-      tty->print_cr(\"NULL\");\n+      tty->print_cr(\"null\");\n@@ -330,1 +330,1 @@\n-  : _gvn(gvn), _short_loop_optimizer(slo), _insertion_point(NULL), _state(NULL), _insert_is_pred(false) {\n+  : _gvn(gvn), _short_loop_optimizer(slo), _insertion_point(nullptr), _state(nullptr), _insert_is_pred(false) {\n@@ -340,1 +340,1 @@\n-  assert(insertion_block->end()->as_Base() == NULL, \"cannot insert into entry block\");\n+  assert(insertion_block->end()->as_Base() == nullptr, \"cannot insert into entry block\");\n@@ -368,1 +368,1 @@\n-  while (cur != NULL) {\n+  while (cur != nullptr) {\n@@ -373,1 +373,1 @@\n-    if (cur->as_Constant() != NULL) {\n+    if (cur->as_Constant() != nullptr) {\n@@ -375,2 +375,2 @@\n-    } else if (cur->as_ArithmeticOp() != NULL || cur->as_LogicOp() != NULL || cur->as_ShiftOp() != NULL) {\n-      assert(cur->as_Op2() != NULL, \"must be Op2\");\n+    } else if (cur->as_ArithmeticOp() != nullptr || cur->as_LogicOp() != nullptr || cur->as_ShiftOp() != nullptr) {\n+      assert(cur->as_Op2() != nullptr, \"must be Op2\");\n@@ -379,1 +379,1 @@\n-    } else if (cur->as_LoadField() != NULL) {\n+    } else if (cur->as_LoadField() != nullptr) {\n@@ -383,1 +383,1 @@\n-    } else if (cur->as_ArrayLength() != NULL) {\n+    } else if (cur->as_ArrayLength() != nullptr) {\n@@ -386,1 +386,1 @@\n-    } else if (cur->as_LoadIndexed() != NULL) {\n+    } else if (cur->as_LoadIndexed() != nullptr) {\n@@ -389,1 +389,1 @@\n-    } else if (cur->as_NegateOp() != NULL) {\n+    } else if (cur->as_NegateOp() != nullptr) {\n@@ -392,1 +392,1 @@\n-    } else if (cur->as_Convert() != NULL) {\n+    } else if (cur->as_Convert() != nullptr) {\n@@ -401,1 +401,1 @@\n-      if (cur->as_Constant() == NULL) {\n+      if (cur->as_Constant() == nullptr) {\n@@ -416,1 +416,1 @@\n-      cur->set_exception_handlers(NULL);\n+      cur->set_exception_handlers(nullptr);\n@@ -421,1 +421,1 @@\n-      if (cur->state_before() != NULL) {\n+      if (cur->state_before() != nullptr) {\n@@ -424,1 +424,1 @@\n-      if (cur->exception_state() != NULL) {\n+      if (cur->exception_state() != nullptr) {\n@@ -461,1 +461,1 @@\n-      if (pred_map != NULL) {\n+      if (pred_map != nullptr) {\n@@ -472,1 +472,1 @@\n-    for (Value instr = block->next(); instr != NULL; instr = instr->next()) {\n+    for (Value instr = block->next(); instr != nullptr; instr = instr->next()) {\n@@ -493,2 +493,2 @@\n-  , _current_map(NULL)\n-  , _value_maps(ir->linear_scan_order()->length(), ir->linear_scan_order()->length(), NULL)\n+  , _current_map(nullptr)\n+  , _value_maps(ir->linear_scan_order()->length(), ir->linear_scan_order()->length(), nullptr)\n@@ -505,2 +505,2 @@\n-  assert(start_block == ir->start() && start_block->number_of_preds() == 0 && start_block->dominator() == NULL, \"must be start block\");\n-  assert(start_block->next()->as_Base() != NULL && start_block->next()->next() == NULL, \"start block must not have instructions\");\n+  assert(start_block == ir->start() && start_block->number_of_preds() == 0 && start_block->dominator() == nullptr, \"must be start block\");\n+  assert(start_block->next()->as_Base() != nullptr && start_block->next()->next() == nullptr, \"start block must not have instructions\");\n@@ -510,1 +510,1 @@\n-     assert(value->as_Local() != NULL, \"only method parameters allowed\");\n+     assert(value->as_Local() != nullptr, \"only method parameters allowed\");\n@@ -525,2 +525,2 @@\n-    assert(dominator != NULL, \"dominator must exist\");\n-    assert(value_map_of(dominator) != NULL, \"value map of dominator must exist\");\n+    assert(dominator != nullptr, \"dominator must exist\");\n+    assert(value_map_of(dominator) != nullptr, \"value map of dominator must exist\");\n@@ -549,1 +549,1 @@\n-        if (pred_map != NULL) {\n+        if (pred_map != nullptr) {\n@@ -568,1 +568,1 @@\n-    for (Value instr = block->next(); instr != NULL; instr = instr->next()) {\n+    for (Value instr = block->next(); instr != nullptr; instr = instr->next()) {\n","filename":"src\/hotspot\/share\/c1\/c1_ValueMap.cpp","additions":43,"deletions":43,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -246,1 +246,1 @@\n-  void          set_value_map_of(BlockBegin* block, ValueMap* map)   { assert(value_map_of(block) == NULL, \"\"); _value_maps.at_put(block->linear_scan_number(), map); }\n+  void          set_value_map_of(BlockBegin* block, ValueMap* map) { assert(value_map_of(block) == nullptr, \"\"); _value_maps.at_put(block->linear_scan_number(), map); }\n","filename":"src\/hotspot\/share\/c1\/c1_ValueMap.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n-, _locals(scope->method()->max_locals(), scope->method()->max_locals(), NULL)\n+, _locals(scope->method()->max_locals(), scope->method()->max_locals(), nullptr)\n@@ -40,1 +40,1 @@\n-, _locks(NULL)\n+, _locks(nullptr)\n@@ -52,1 +52,1 @@\n-  , _locks(copy_from->locks_size() == 0 ? NULL : new Values(copy_from->locks_size()))\n+  , _locks(copy_from->locks_size() == 0 ? nullptr : new Values(copy_from->locks_size()))\n@@ -106,1 +106,1 @@\n-    if (value != NULL && value != s->lock_at(i)) {\n+    if (value != nullptr && value != s->lock_at(i)) {\n@@ -115,1 +115,1 @@\n-    _locals.at_put(i, NULL);\n+    _locals.at_put(i, nullptr);\n@@ -122,1 +122,1 @@\n-    if (v->as_Constant() == NULL && v->as_Local() == NULL) {\n+    if (v->as_Constant() == nullptr && v->as_Local() == nullptr) {\n@@ -134,1 +134,1 @@\n-    if (v0 != NULL && !v0->type()->is_illegal()) {\n+    if (v0 != nullptr && !v0->type()->is_illegal()) {\n@@ -139,1 +139,1 @@\n-      assert(!v1->type()->is_double_word() || list.at(i + 1) == NULL, \"hi-word of doubleword value must be NULL\");\n+      assert(!v1->type()->is_double_word() || list.at(i + 1) == nullptr, \"hi-word of doubleword value must be null\");\n@@ -152,1 +152,1 @@\n-    if (state->_locks != NULL) {\n+    if (state->_locks != nullptr) {\n@@ -179,1 +179,1 @@\n-  if (_locks == NULL) {\n+  if (_locks == nullptr) {\n@@ -197,1 +197,1 @@\n-  assert(stack_at(index)->as_Phi() == NULL || stack_at(index)->as_Phi()->block() != b, \"phi function already created\");\n+  assert(stack_at(index)->as_Phi() == nullptr || stack_at(index)->as_Phi()->block() != b, \"phi function already created\");\n@@ -203,1 +203,1 @@\n-  assert(!t->is_double_word() || _stack.at(index + 1) == NULL, \"hi-word of doubleword value must be NULL\");\n+  assert(!t->is_double_word() || _stack.at(index + 1) == nullptr, \"hi-word of doubleword value must be null\");\n@@ -207,1 +207,1 @@\n-  assert(local_at(index)->as_Phi() == NULL || local_at(index)->as_Phi()->block() != b, \"phi function already created\");\n+  assert(local_at(index)->as_Phi() == nullptr || local_at(index)->as_Phi()->block() != b, \"phi function already created\");\n@@ -236,1 +236,1 @@\n-      if (t == NULL) {\n+      if (t == nullptr) {\n@@ -250,1 +250,1 @@\n-      if (l == NULL) {\n+      if (l == nullptr) {\n@@ -262,1 +262,1 @@\n-  if (caller_state() != NULL) {\n+  if (caller_state() != nullptr) {\n@@ -269,2 +269,2 @@\n-  assert(scope() != NULL, \"scope must exist\");\n-  if (caller_state() != NULL) {\n+  assert(scope() != nullptr, \"scope must exist\");\n+  if (caller_state() != nullptr) {\n@@ -287,2 +287,2 @@\n-    if (v == NULL) {\n-      assert(_stack.at(i - 1)->type()->is_double_word(), \"only hi-words are NULL on stack\");\n+    if (v == nullptr) {\n+      assert(_stack.at(i - 1)->type()->is_double_word(), \"only hi-words are null on stack\");\n@@ -290,1 +290,1 @@\n-      assert(_stack.at(i + 1) == NULL, \"hi-word must be NULL\");\n+      assert(_stack.at(i + 1) == nullptr, \"hi-word must be null\");\n@@ -296,2 +296,2 @@\n-    if (v != NULL && v->type()->is_double_word()) {\n-      assert(_locals.at(i + 1) == NULL, \"hi-word must be NULL\");\n+    if (v != nullptr && v->type()->is_double_word()) {\n+      assert(_locals.at(i + 1) == nullptr, \"hi-word must be null\");\n@@ -302,1 +302,1 @@\n-    assert(v != NULL, \"just test if state-iteration succeeds\");\n+    assert(v != nullptr, \"just test if state-iteration succeeds\");\n","filename":"src\/hotspot\/share\/c1\/c1_ValueStack.cpp","additions":25,"deletions":25,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,1 +58,1 @@\n-    assert(h == NULL, \"hi-word of doubleword value must be NULL\");\n+    assert(h == nullptr, \"hi-word of doubleword value must be null\");\n@@ -95,1 +95,1 @@\n-  int locks_size() const                         { return _locks == NULL ? 0 : _locks->length(); }\n+  int locks_size() const                         { return _locks == nullptr ? 0 : _locks->length(); }\n@@ -97,1 +97,1 @@\n-  bool no_active_locks() const                   { return _locks == NULL || _locks->is_empty(); }\n+  bool no_active_locks() const                   { return _locks == nullptr || _locks->is_empty(); }\n@@ -101,1 +101,1 @@\n-  void clear_locals();                           \/\/ sets all locals to NULL;\n+  void clear_locals();                           \/\/ sets all locals to null;\n@@ -105,2 +105,2 @@\n-           _locals.at(i + 1) == NULL, \"hi-word of doubleword value must be NULL\");\n-    _locals.at_put(i, NULL);\n+           _locals.at(i + 1) == nullptr, \"hi-word of doubleword value must be null\");\n+    _locals.at_put(i, nullptr);\n@@ -111,2 +111,2 @@\n-    assert(x == NULL || !x->type()->is_double_word() ||\n-           _locals.at(i + 1) == NULL, \"hi-word of doubleword value must be NULL\");\n+    assert(x == nullptr || !x->type()->is_double_word() ||\n+           _locals.at(i + 1) == nullptr, \"hi-word of doubleword value must be null\");\n@@ -121,2 +121,2 @@\n-      if (prev != NULL && prev->type()->is_double_word()) {\n-        _locals.at_put(i - 1, NULL);\n+      if (prev != nullptr && prev->type()->is_double_word()) {\n+        _locals.at_put(i - 1, nullptr);\n@@ -128,2 +128,2 @@\n-      \/\/ hi-word of doubleword value is always NULL\n-      _locals.at_put(i + 1, NULL);\n+      \/\/ hi-word of doubleword value is always null\n+      _locals.at_put(i + 1, nullptr);\n@@ -137,1 +137,1 @@\n-           _stack.at(i + 1) == NULL, \"hi-word of doubleword value must be NULL\");\n+           _stack.at(i + 1) == nullptr, \"hi-word of doubleword value must be null\");\n@@ -167,2 +167,2 @@\n-  void lpush(Value t)                            { _stack.push(check(longTag   , t)); _stack.push(NULL); }\n-  void dpush(Value t)                            { _stack.push(check(doubleTag , t)); _stack.push(NULL); }\n+  void lpush(Value t)                            { _stack.push(check(longTag   , t)); _stack.push(nullptr); }\n+  void dpush(Value t)                            { _stack.push(check(doubleTag , t)); _stack.push(nullptr); }\n@@ -197,1 +197,1 @@\n-      default        : ShouldNotReachHere(); return NULL;\n+      default        : ShouldNotReachHere(); return nullptr;\n@@ -240,1 +240,1 @@\n-\/\/ as an invariant, state is NULL now\n+\/\/ as an invariant, state is null now\n@@ -249,1 +249,1 @@\n-  for (; state != NULL; state = state->caller_state())\n+  for (; state != nullptr; state = state->caller_state())\n@@ -255,2 +255,2 @@\n-       index += (value == NULL || value->type()->is_illegal() ? 1 : value->type()->size()))    \\\n-    if (value != NULL)\n+       index += (value == nullptr || value->type()->is_illegal() ? 1 : value->type()->size())) \\\n+    if (value != nullptr)\n@@ -271,1 +271,1 @@\n-    if (value != NULL)\n+    if (value != nullptr)\n@@ -321,1 +321,1 @@\n-      if (v_phi != NULL && v_phi->block() == v_block) {                                        \\\n+      if (v_phi != nullptr && v_phi->block() == v_block) {                                     \\\n@@ -329,1 +329,1 @@\n-      if (v_phi != NULL && v_phi->block() == v_block) {                                        \\\n+      if (v_phi != nullptr && v_phi->block() == v_block) {                                     \\\n","filename":"src\/hotspot\/share\/c1\/c1_ValueStack.hpp","additions":24,"deletions":24,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,11 +34,11 @@\n-VoidType*       voidType     = NULL;\n-IntType*        intType      = NULL;\n-LongType*       longType     = NULL;\n-FloatType*      floatType    = NULL;\n-DoubleType*     doubleType   = NULL;\n-ObjectType*     objectType   = NULL;\n-ArrayType*      arrayType    = NULL;\n-InstanceType*   instanceType = NULL;\n-ClassType*      classType    = NULL;\n-AddressType*    addressType  = NULL;\n-IllegalType*    illegalType  = NULL;\n+VoidType*       voidType     = nullptr;\n+IntType*        intType      = nullptr;\n+LongType*       longType     = nullptr;\n+FloatType*      floatType    = nullptr;\n+DoubleType*     doubleType   = nullptr;\n+ObjectType*     objectType   = nullptr;\n+ArrayType*      arrayType    = nullptr;\n+InstanceType*   instanceType = nullptr;\n+ClassType*      classType    = nullptr;\n+AddressType*    addressType  = nullptr;\n+IllegalType*    illegalType  = nullptr;\n@@ -48,3 +48,3 @@\n-IntConstant*    intZero      = NULL;\n-IntConstant*    intOne       = NULL;\n-ObjectConstant* objectNull   = NULL;\n+IntConstant*    intZero      = nullptr;\n+IntConstant*    intOne       = nullptr;\n+ObjectConstant* objectNull   = nullptr;\n@@ -92,1 +92,1 @@\n-  return (c != NULL && !c->is_null_object()) ? c->klass() : NULL;\n+  return (c != nullptr && !c->is_null_object()) ? c->klass() : nullptr;\n@@ -96,1 +96,1 @@\n-  return (c != NULL && !c->is_null_object()) ? c->klass() : NULL;\n+  return (c != nullptr && !c->is_null_object()) ? c->klass() : nullptr;\n@@ -100,1 +100,1 @@\n-  return (c != NULL && !c->is_null_object()) ? c->klass() : NULL;\n+  return (c != nullptr && !c->is_null_object()) ? c->klass() : nullptr;\n","filename":"src\/hotspot\/share\/c1\/c1_ValueType.cpp","additions":18,"deletions":18,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -127,6 +127,6 @@\n-  bool is_object()                               { return as_ObjectType()   != NULL; }\n-  bool is_array()                                { return as_ArrayType()    != NULL; }\n-  bool is_instance()                             { return as_InstanceType() != NULL; }\n-  bool is_class()                                { return as_ClassType()    != NULL; }\n-  bool is_method()                               { return as_MethodType()   != NULL; }\n-  bool is_address()                              { return as_AddressType()  != NULL; }\n+  bool is_object()                               { return as_ObjectType()   != nullptr; }\n+  bool is_array()                                { return as_ArrayType()    != nullptr; }\n+  bool is_instance()                             { return as_InstanceType() != nullptr; }\n+  bool is_class()                                { return as_ClassType()    != nullptr; }\n+  bool is_method()                               { return as_MethodType()   != nullptr; }\n+  bool is_address()                              { return as_AddressType()  != nullptr; }\n@@ -143,24 +143,24 @@\n-  virtual VoidType*         as_VoidType()        { return NULL; }\n-  virtual IntType*          as_IntType()         { return NULL; }\n-  virtual LongType*         as_LongType()        { return NULL; }\n-  virtual FloatType*        as_FloatType()       { return NULL; }\n-  virtual DoubleType*       as_DoubleType()      { return NULL; }\n-  virtual ObjectType*       as_ObjectType()      { return NULL; }\n-  virtual ArrayType*        as_ArrayType()       { return NULL; }\n-  virtual InstanceType*     as_InstanceType()    { return NULL; }\n-  virtual ClassType*        as_ClassType()       { return NULL; }\n-  virtual MetadataType*     as_MetadataType()    { return NULL; }\n-  virtual MethodType*       as_MethodType()      { return NULL; }\n-  virtual AddressType*      as_AddressType()     { return NULL; }\n-  virtual IllegalType*      as_IllegalType()     { return NULL; }\n-  virtual IntConstant*      as_IntConstant()     { return NULL; }\n-  virtual LongConstant*     as_LongConstant()    { return NULL; }\n-  virtual FloatConstant*    as_FloatConstant()   { return NULL; }\n-  virtual DoubleConstant*   as_DoubleConstant()  { return NULL; }\n-  virtual ObjectConstant*   as_ObjectConstant()  { return NULL; }\n-  virtual InstanceConstant* as_InstanceConstant(){ return NULL; }\n-  virtual ClassConstant*    as_ClassConstant()   { return NULL; }\n-  virtual MethodConstant*   as_MethodConstant()  { return NULL; }\n-  virtual ArrayConstant*    as_ArrayConstant()   { return NULL; }\n-  virtual StableArrayConstant* as_StableArrayConstant()   { return NULL; }\n-  virtual AddressConstant*  as_AddressConstant() { return NULL; }\n+  virtual VoidType*         as_VoidType()        { return nullptr; }\n+  virtual IntType*          as_IntType()         { return nullptr; }\n+  virtual LongType*         as_LongType()        { return nullptr; }\n+  virtual FloatType*        as_FloatType()       { return nullptr; }\n+  virtual DoubleType*       as_DoubleType()      { return nullptr; }\n+  virtual ObjectType*       as_ObjectType()      { return nullptr; }\n+  virtual ArrayType*        as_ArrayType()       { return nullptr; }\n+  virtual InstanceType*     as_InstanceType()    { return nullptr; }\n+  virtual ClassType*        as_ClassType()       { return nullptr; }\n+  virtual MetadataType*     as_MetadataType()    { return nullptr; }\n+  virtual MethodType*       as_MethodType()      { return nullptr; }\n+  virtual AddressType*      as_AddressType()     { return nullptr; }\n+  virtual IllegalType*      as_IllegalType()     { return nullptr; }\n+  virtual IntConstant*      as_IntConstant()     { return nullptr; }\n+  virtual LongConstant*     as_LongConstant()    { return nullptr; }\n+  virtual FloatConstant*    as_FloatConstant()   { return nullptr; }\n+  virtual DoubleConstant*   as_DoubleConstant()  { return nullptr; }\n+  virtual ObjectConstant*   as_ObjectConstant()  { return nullptr; }\n+  virtual InstanceConstant* as_InstanceConstant(){ return nullptr; }\n+  virtual ClassConstant*    as_ClassConstant()   { return nullptr; }\n+  virtual MethodConstant*   as_MethodConstant()  { return nullptr; }\n+  virtual ArrayConstant*    as_ArrayConstant()   { return nullptr; }\n+  virtual StableArrayConstant* as_StableArrayConstant()   { return nullptr; }\n+  virtual AddressConstant*  as_AddressConstant() { return nullptr; }\n@@ -289,2 +289,2 @@\n-  virtual ciObject* constant_value() const       { ShouldNotReachHere(); return NULL; }\n-  virtual ciType* exact_type() const             { return NULL; }\n+  virtual ciObject* constant_value() const       { ShouldNotReachHere(); return nullptr; }\n+  virtual ciType* exact_type() const             { return nullptr; }\n@@ -379,1 +379,1 @@\n-  virtual ciMetadata* constant_value() const            { ShouldNotReachHere(); return NULL;  }\n+  virtual ciMetadata* constant_value() const            { ShouldNotReachHere(); return nullptr;  }\n","filename":"src\/hotspot\/share\/c1\/c1_ValueType.hpp","additions":34,"deletions":34,"binary":false,"changes":68,"status":"modified"}]}