{"files":[{"patch":"@@ -27,2 +27,1 @@\n- * @library ..\/..\/\n- * @library \/test\/lib\n+ * @library \/test\/lib \/javax\/net\/ssl\/templates ..\/..\/\n@@ -42,0 +41,1 @@\n+import javax.net.ssl.HostnameVerifier;\n@@ -43,3 +43,1 @@\n-import javax.net.ssl.SSLContext;\n-import javax.net.ssl.SSLServerSocket;\n-import javax.net.ssl.SSLServerSocketFactory;\n+import javax.net.ssl.SSLSession;\n@@ -47,1 +45,4 @@\n-import java.io.PrintStream;\n+import java.io.BufferedReader;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n@@ -49,2 +50,0 @@\n-import java.net.InetSocketAddress;\n-import java.net.Proxy;\n@@ -53,7 +52,1 @@\n-public class LoggingFormatConsistency {\n-    \/*\n-     * Should we run the client or server in a separate thread?\n-     * Both sides can throw exceptions, but do you have a preference\n-     * as to which side should be the main thread.\n-     *\/\n-    static boolean separateServerThread = true;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n@@ -61,1 +54,1 @@\n-    static char[] passphrase = \"passphrase\".toCharArray();\n+public class LoggingFormatConsistency extends SSLSocketTemplate {\n@@ -63,27 +56,4 @@\n-    \/*\n-     * Is the server ready to serve?\n-     *\/\n-    volatile static boolean serverReady = false;\n-\n-    \/*\n-     * Is the connection ready to close?\n-     *\/\n-    volatile static boolean closeReady = false;\n-\n-    \/*\n-     * Turn on SSL debugging?\n-     *\/\n-\n-    \/\/ use any free port by default\n-    volatile int serverPort = 0;\n-\n-    volatile Exception serverException = null;\n-    volatile Exception clientException = null;\n-\n-    Thread clientThread = null;\n-    Thread serverThread = null;\n-\n-    private static final String pathToStores = \"..\/..\/..\/..\/javax\/net\/ssl\/etc\";\n-    private static final String keyStoreFile = \"keystore\";\n-    private static final String trustStoreFile = \"truststore\";\n-    private static final String password = \"passphrase\";\n+    LoggingFormatConsistency () {\n+        serverAddress = InetAddress.getLoopbackAddress();\n+        SecurityUtils.removeFromDisabledTlsAlgs(\"TLSv1\", \"TLSv1.1\");\n+    }\n@@ -99,2 +69,2 @@\n-            \/\/ JVM properties (keyStore, trustStore, tls protocols, etc.)\n-            new LoggingFormatConsistency();\n+            \/\/ properties passed to the test JVM - debug flags, tls version, etc.\n+            new LoggingFormatConsistency().run();\n@@ -102,9 +72,1 @@\n-            \/\/ We are in the main JVM that the test is being ran in.\n-            var keyStoreFileName = System.getProperty(\"test.src\", \".\/\") + \"\/\" + pathToStores + \"\/\" + keyStoreFile;\n-            var trustStoreFileName = System.getProperty(\"test.src\", \".\/\") + \"\/\" + pathToStores + \"\/\" + trustStoreFile;\n-\n-            \/\/ Setting up JVM system properties\n-            var keyStoreArg = \"-Djavax.net.ssl.keyStore=\" + keyStoreFileName;\n-            var keyStorePassword = \"-Djavax.net.ssl.keyStorePassword=\" + password;\n-            var trustStoreArg = \"-Djavax.net.ssl.trustStore=\" + trustStoreFileName;\n-            var trustStorePassword = \"-Djavax.net.ssl.trustStorePassword=\" + password;\n+            \/\/ We are in the test JVM that the test is being ran in.\n@@ -117,3 +79,3 @@\n-            for (int i = 0; i < correctTlsVersionsFormat.length; i++) {\n-                String expectedTLSVersion = correctTlsVersionsFormat[i];\n-                String incorrectTLSVersion = incorrectTLSVersionsFormat[i];\n+            for (var i = 0; i < correctTlsVersionsFormat.length; i++) {\n+                var expectedTLSVersion = correctTlsVersionsFormat[i];\n+                var incorrectTLSVersion = incorrectTLSVersionsFormat[i];\n@@ -122,1 +84,1 @@\n-                String activeTLSProtocol = \"-Djdk.tls.client.protocols=\" + expectedTLSVersion;\n+                var activeTLSProtocol = \"-Djdk.tls.client.protocols=\" + expectedTLSVersion;\n@@ -125,4 +87,0 @@\n-                        keyStoreArg,\n-                        keyStorePassword,\n-                        trustStoreArg,\n-                        trustStorePassword,\n@@ -132,1 +90,5 @@\n-                        \"runTest\"); \/\/ Ensuring args.length is greater than 0\n+                        \"runTest\"); \/\/ Ensuring args.length is greater than 0 when test JVM starts\n+\n+                if (output.getExitValue() != 0) {\n+                    throw new RuntimeException(\"Test JVM process failed. JVM stderr= \" + output.getStderr());\n+                }\n@@ -140,67 +102,2 @@\n-    \/*\n-     * Primary constructor, used to drive remainder of the test.\n-     *\n-     * Fork off the other side, then do your work.\n-     *\/\n-    LoggingFormatConsistency() throws Exception {\n-        \/\/ Test depends on these being enabled\n-        SecurityUtils.removeFromDisabledTlsAlgs(\"TLSv1\", \"TLSv1.1\");\n-        if (separateServerThread) {\n-            startServer(true);\n-            startClient(false);\n-        } else {\n-            startClient(true);\n-            startServer(false);\n-        }\n-\n-        \/*\n-         * Wait for other side to close down.\n-         *\/\n-        if (separateServerThread) {\n-            serverThread.join();\n-        } else {\n-            clientThread.join();\n-        }\n-\n-        \/*\n-         * When we get here, the test is pretty much over.\n-         *\n-         * If the main thread excepted, that propagates back\n-         * immediately.  If the other thread threw an exception, we\n-         * should report back.\n-         *\/\n-        if (serverException != null) {\n-            throw serverException;\n-        }\n-        if (clientException != null) {\n-            throw clientException;\n-        }\n-    }\n-\n-    \/*\n-     * Define the server side of the test.\n-     *\n-     * If the server prematurely exits, serverReady will be set to true\n-     * to avoid infinite hangs.\n-     *\/\n-    void doServerSide() throws Exception {\n-\n-        SSLServerSocketFactory sslServerSocketFactory = SSLContext.getDefault().getServerSocketFactory();\n-\n-        InetAddress localHost = InetAddress.getByName(\"localhost\");\n-        InetSocketAddress address = new InetSocketAddress(localHost, serverPort);\n-\n-        SSLServerSocket sslServerSocket = (SSLServerSocket) sslServerSocketFactory.createServerSocket();\n-        sslServerSocket.bind(address);\n-        serverPort = sslServerSocket.getLocalPort();\n-\n-        \/*\n-         * Signal Client, we're ready for its connect.\n-         *\/\n-        serverReady = true;\n-\n-        SSLSocket sslSocket = (SSLSocket) sslServerSocket.accept();\n-        sslSocket.setNeedClientAuth(true);\n-\n-        PrintStream out =\n-                new PrintStream(sslSocket.getOutputStream());\n+    @Override\n+    protected boolean isCustomizedClientConnection() { return true; }\n@@ -208,0 +105,4 @@\n+    @Override\n+    protected void runServerApplication(SSLSocket socket) throws Exception {\n+        var response = \"Hello World!\";\n+        var out = new DataOutputStream(socket.getOutputStream());\n@@ -209,8 +110,13 @@\n-            \/\/ ignore request data\n-\n-            \/\/ send the response\n-            out.print(\"HTTP\/1.1 200 OK\\r\\n\");\n-            out.print(\"Content-Type: text\/html; charset=iso-8859-1\\r\\n\");\n-            out.print(\"Content-Length: \"+ 9 +\"\\r\\n\");\n-            out.print(\"\\r\\n\");\n-            out.print(\"Testing\\r\\n\");\n+            \/\/ We don't need to process the data from the socket\n+            \/\/ Simply sending a response right away is sufficient\n+            \/\/ to generate the desired debug output\n+            var responseBytes = response.getBytes(UTF_8);\n+\n+            out.writeBytes(\"HTTP\/1.0 200 OK\\r\\n\");\n+            out.writeBytes(\"Content-Length: \" + responseBytes.length + \"\\r\\n\");\n+            out.writeBytes(\"Content-Type: text\/html\\r\\n\\r\\n\");\n+            out.write(responseBytes);\n+            out.flush();\n+        } catch (IOException e) {\n+            out.writeBytes(\"HTTP\/1.0 400 \" + e.getMessage() + \"\\r\\n\");\n+            out.writeBytes(\"Content-Type: text\/html\\r\\n\\r\\n\");\n@@ -218,39 +124,0 @@\n-        } finally {\n-            \/\/ close the socket\n-            while (!closeReady) {\n-                Thread.sleep(50);\n-            }\n-\n-            System.out.println(\"Server closing socket\");\n-            sslSocket.close();\n-            serverReady = false;\n-        }\n-    }\n-\n-    \/*\n-     * Define the client side of the test.\n-     *\n-     * If the server prematurely exits, serverReady will be set to true\n-     * to avoid infinite hangs.\n-     *\/\n-    void doClientSide() throws Exception {\n-        while (!serverReady) {\n-            Thread.sleep(50);\n-        }\n-\n-        HttpsURLConnection http = null;\n-\n-        \/* establish http connection to server *\/\n-        URL url = new URL(\"https:\/\/localhost:\" + serverPort+\"\/\");\n-        System.out.println(\"url is \"+url.toString());\n-\n-        try {\n-            http = (HttpsURLConnection)url.openConnection(Proxy.NO_PROXY);\n-\n-            int responseCode = http.getResponseCode();\n-            System.out.println(\"respCode = \" + responseCode);\n-        } finally {\n-            if (http != null) {\n-                http.disconnect();\n-            }\n-            closeReady = true;\n@@ -260,19 +127,15 @@\n-    void startServer(boolean newThread) throws Exception {\n-        if (newThread) {\n-            serverThread = new Thread(() -> {\n-                try {\n-                    doServerSide();\n-                } catch (Exception e) {\n-                    \/*\n-                     * Our server thread just died.\n-                     *\n-                     * Release the client, if not active already...\n-                     *\/\n-                    System.err.println(\"Server died...\");\n-                    serverReady = true;\n-                    serverException = e;\n-                }\n-            });\n-            serverThread.start();\n-        } else {\n-            doServerSide();\n+    @Override\n+    protected void runClientApplication(int serverPort) throws Exception {\n+        var context = createClientSSLContext();\n+        HttpsURLConnection.setDefaultSSLSocketFactory(context.getSocketFactory());\n+        HttpsURLConnection.setDefaultHostnameVerifier(new NameVerifier());\n+\n+        var host = serverAddress == null ? \"localhost\" : serverAddress.getHostAddress();\n+        var url = new URL(\"https:\/\/\" + host + \":\" + serverPort + \"\/\");\n+        var httpsConnection = (HttpsURLConnection) url.openConnection();\n+        httpsConnection.disconnect();\n+        try (var in = new BufferedReader(new InputStreamReader(httpsConnection.getInputStream()))) {\n+            \/\/ Getting the input stream from the BufferedReader is sufficient to generate the desired debug output\n+            \/\/ We don't need to process the data\n+        } catch (IOException e) {\n+            throw new RuntimeException(e);\n@@ -282,16 +145,4 @@\n-    void startClient(boolean newThread) throws Exception {\n-        if (newThread) {\n-            clientThread = new Thread(() -> {\n-                try {\n-                    doClientSide();\n-                } catch (Exception e) {\n-                    \/*\n-                     * Our client thread just died.\n-                     *\/\n-                    System.err.println(\"Client died...\");\n-                    clientException = e;\n-                }\n-            });\n-            clientThread.start();\n-        } else {\n-            doClientSide();\n+    private static class NameVerifier implements HostnameVerifier {\n+        @Override\n+        public boolean verify(String s, SSLSession sslSession) {\n+            return true;\n","filename":"test\/jdk\/sun\/security\/ssl\/SSLLogger\/LoggingFormatConsistency.java","additions":63,"deletions":212,"binary":false,"changes":275,"status":"modified"}]}