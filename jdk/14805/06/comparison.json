{"files":[{"patch":"@@ -519,0 +519,105 @@\n+    \/**\n+     * Resolves a path against this path, and then iteratively resolves any\n+     * additional paths.\n+     *\n+     * <p> If {@code more} does not specify any {@code Path}s,\n+     * then the result is {@link #resolve(Path) resolve(first)}. If\n+     * {@code more} specifies one or more {@code Path}s, then {@code first}\n+     * is resolved against this path and then the additional paths in\n+     * {@code more} are iteratively resolved.\n+     *\n+     * If {@code first} and {@code more} specify only empty paths, then this\n+     * method returns this path. If any of the paths in {@code first} and\n+     * {@code more} is absolute, then the result will be as if the paths\n+     * after the last absolute path in the sequence were resolved iteratively\n+     * against that last absolute path.\n+     *\n+     * <p> The result of this method is the same as would be obtained\n+     * by resolving the first parameter path against this path, and then\n+     * repeating the same procedure for each path in the sequence. Each\n+     * single resolution in the chain behaves as specified by {@link\n+     * #resolve(Path) resolve}.\n+     *\n+     * @implSpec\n+     * The default implementation is equivalent for this path to:\n+     * {@snippet lang=java :\n+     * Path result = resolve(first);\n+     * for (Path p : more) {\n+     *     result = result.resolve(p);\n+     * }\n+     * }\n+     *\n+     * @param   first\n+     *          the first path to resolve against this path\n+     *\n+     * @param   more\n+     *          additional paths to be iteratively resolved\n+     *\n+     * @return  the resulting path\n+     *\n+     * @see #resolve(Path)\n+     *\n+     * @since 22\n+     *\/\n+    default Path resolve(Path first, Path... more) {\n+        Path result = resolve(first);\n+        for (Path p : more) {\n+            result = result.resolve(p);\n+        }\n+        return result;\n+    }\n+\n+    \/**\n+     * Converts a path string to a path, resolves it against this path, and\n+     * then iteratively converts and resolves any additional path strings.\n+     *\n+     * <p> If {@code more} does not\n+     * specify any path strings, then the result is {@link #resolve(String)\n+     * resolve(first)}. If {@code more} specifies one or more path strings,\n+     * then {@code first} is converted to a {@code Path}, resolved against\n+     * this path, and then the additional path strings in {@code more} are\n+     * iteratively converted to {@code Path}s and resolved. Path strings which\n+     * convert to empty or absolute paths are handled as specified by\n+     * {@link #resolve(Path,Path...)}.\n+     *\n+     * <p> The result of this method is the same as would be obtained by\n+     * resolving the path converted from the first path string against\n+     * this path, and then repeating the same procedure for each path\n+     * string in the sequence. Each single resolution in the chain\n+     * behaves as specified by {@link #resolve(String) resolve}.\n+     *\n+     * @implSpec\n+     * The default implementation is equivalent for this path to:\n+     * {@snippet lang=java :\n+     * Path result = resolve(first);\n+     * for (String s : more) {\n+     *     result = result.resolve(s);\n+     * }\n+     * }\n+     *\n+     * @param   first\n+     *          the first path string to convert to a path and\n+     *          resolve against this path\n+     *\n+     * @param   more\n+     *          additional path strings to be iteratively converted to\n+     *          paths and resolved\n+     *\n+     * @return  the resulting path\n+     *\n+     * @throws  InvalidPathException\n+     *          if a path string cannot be converted to a Path.\n+     *\n+     * @see #resolve(Path,Path...)\n+     * @see #resolve(String)\n+     *\n+     * @since 22\n+     *\/\n+    default Path resolve(String first, String... more) {\n+        Path result = resolve(first);\n+        for (String s : more) {\n+            result = result.resolve(s);\n+        }\n+        return result;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/nio\/file\/Path.java","additions":105,"deletions":0,"binary":false,"changes":105,"status":"modified"},{"patch":"@@ -398,0 +398,77 @@\n+   private static final byte[] resolve(byte[] base, byte[]... children) {\n+       \/\/ 'start' is either zero, indicating the base, or indicates which\n+       \/\/ child is that last one which is an absolute path\n+       int start = 0;\n+       int resultLength = base.length;\n+\n+       \/\/ Locate the last child which is an absolute path and calculate\n+       \/\/ the total number of bytes in the resolved path\n+       final int count = children.length;\n+       if (count > 0) {\n+           for (int i = 0; i < count; i++) {\n+               byte[] b = children[i];\n+               if (b.length > 0) {\n+                   if (b[0] == '\/') {\n+                       start = i + 1;\n+                       resultLength = b.length;\n+                   } else {\n+                       if (resultLength > 0)\n+                           resultLength++;\n+                       resultLength += b.length;\n+                   }\n+               }\n+           }\n+       }\n+\n+       \/\/ If the base is not being superseded by a child which is an\n+       \/\/ absolute path, then if at least one child is non-empty and\n+       \/\/ the base consists only of a '\/', then decrement resultLength to\n+       \/\/ account for an extra '\/' added in the resultLength computation.\n+       if (start == 0 && resultLength > base.length && base.length == 1 && base[0] == '\/')\n+           resultLength--;\n+\n+       \/\/ Allocate the result array and return if empty.\n+       byte[] result = new byte[resultLength];\n+       if (result.length == 0)\n+           return result;\n+\n+       \/\/ Prepend the base if it is non-empty and would not later be\n+       \/\/ overwritten by an absolute child\n+       int offset = 0;\n+       if (start == 0 && base.length > 0) {\n+           System.arraycopy(base, 0, result, 0, base.length);\n+           offset += base.length;\n+       }\n+\n+       \/\/ Append children starting with the last one which is an\n+       \/\/ absolute path\n+       if (count > 0) {\n+           int idx = Math.max(0, start - 1);\n+           for (int i = idx; i < count; i++) {\n+               byte[] b = children[i];\n+               if (b.length > 0) {\n+                   if (offset > 0 && result[offset - 1] != '\/')\n+                       result[offset++] = '\/';\n+                   System.arraycopy(b, 0, result, offset, b.length);\n+                   offset += b.length;\n+               }\n+           }\n+       }\n+\n+       return result;\n+   }\n+\n+    @Override\n+    public UnixPath resolve(Path first, Path... more) {\n+        if (more.length == 0)\n+            return resolve(first);\n+\n+        byte[][] children = new byte[1 + more.length][];\n+        children[0] = toUnixPath(first).path;\n+        for (int i = 0; i < more.length; i++)\n+            children[i + 1] = toUnixPath(more[i]).path;\n+\n+        byte[] result = resolve(path, children);\n+        return new UnixPath(getFileSystem(), result);\n+    }\n+\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixPath.java","additions":77,"deletions":0,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -25,1 +25,2 @@\n- * @bug 4313887 6838333 6925932 7006126 8037945 8072495 8140449 8254876 8298478\n+ * @bug 4313887 6838333 6925932 7006126 8037945 8072495 8140449 8254876 8262742\n+ *      8298478\n@@ -185,0 +186,13 @@\n+    \/\/ Note: \"expected\" is first parameter here\n+    PathOps resolve(String expected, String first, String... more) {\n+        out.format(\"test resolve %s varargs\\n\", path());\n+        checkPath();\n+        Path[] others = new Path[more.length];\n+        int i = 0;\n+        for (String s : more) {\n+            others[i++] = Path.of(s);\n+        }\n+        check(path.resolve(Path.of(first), others), expected);\n+        return this;\n+    }\n+\n@@ -546,0 +560,29 @@\n+        \/\/ resolve - varargs\n+        test(\"C:\\\\tmp\")\n+            .resolve(\"C:\\\\tmp\\\\foo\\\\bar\\\\gus\", \"foo\", \"bar\", \"gus\")\n+            .resolve(\"C:\\\\gus\", \"\\\\foo\", \"bar\", \"\\\\gus\")\n+            .resolve(\"C:\\\\tmp\\\\baz\", \"\", \"\", \"baz\");\n+        test(\"C:\\\\tmp\\\\foo\")\n+            .resolve(\"C:\\\\tmp\\\\foo\\\\bar\\\\gus\", \"\", \"bar\\\\gus\", \"\")\n+            .resolve(\"C:\\\\tmp\\\\foo\\\\bar\\\\gus\\\\foo\\\\baz\",\n+                     \"\", \"bar\\\\gus\", \"foo\\\\baz\")\n+            .resolve(\"C:\\\\bar\\\\gus\\\\baz\", \"\", \"C::\\\\bar\\\\gus\", \"baz\")\n+            .resolve(\"C:\\\\tmp\\\\bar\", \"C:\\\\bar\\\\gus\", \"baz\", \"C:\\\\tmp\\\\bar\");\n+        test(\"tmp\")\n+            .resolve(\"tmp\\\\foo\\\\bar\\\\gus\", \"foo\", \"bar\", \"gus\")\n+            .resolve(\"\\\\gus\", \"\\\\foo\", \"bar\", \"\\\\gus\")\n+            .resolve(\"tmp\\\\baz\", \"\", \"\", \"baz\");\n+        test(\"\")\n+            .resolve(\"\", \"\", \"\")\n+            .resolve(\"\\\\bar\", \"foo\", \"\\\\bar\", \"\")\n+            .resolve(\"foo\\\\bar\\\\gus\", \"foo\", \"bar\", \"gus\")\n+            .resolve(\"baz\", \"\", \"\", \"baz\");\n+        test(\"\\\\\")\n+            .resolve(\"\\\\foo\", \"foo\", \"\")\n+            .resolve(\"\\\\foo\", \"\", \"foo\")\n+            .resolve(\"\\\\bar\", \"foo\", \"\", \"\\\\bar\");\n+        test(\"C:\")\n+            .resolve(\"C:foo\\\\bar\\\\gus\", \"foo\", \"bar\", \"gus\")\n+            .resolve(\"C:baz\", \"\", \"baz\")\n+            .resolve(\"C:\", \"\", \"\");\n+\n@@ -1672,0 +1715,25 @@\n+        \/\/ resolve - varargs\n+        test(\"\/tmp\")\n+            .resolve(\"\/tmp\/foo\/bar\/gus\", \"foo\", \"bar\", \"gus\")\n+            .resolve(\"\/gus\", \"\/foo\", \"bar\", \"\/gus\")\n+            .resolve(\"\/tmp\/baz\", \"\", \"\", \"baz\");\n+        test(\"\/tmp\/foo\")\n+            .resolve(\"\/tmp\/foo\/bar\/gus\", \"\", \"bar\/gus\", \"\")\n+            .resolve(\"\/tmp\/foo\/bar\/gus\/foo\/baz\", \"\", \"bar\/gus\", \"foo\/baz\")\n+            .resolve(\"\/bar\/gus\/baz\", \"\", \"\/bar\/gus\", \"baz\")\n+            .resolve(\"\/tmp\/bar\", \"\/bar\/gus\", \"baz\", \"\/tmp\/bar\");\n+        test(\"tmp\")\n+            .resolve(\"tmp\/foo\/bar\/gus\", \"foo\", \"bar\", \"gus\")\n+            .resolve(\"\/gus\", \"\/foo\", \"bar\", \"\/gus\")\n+            .resolve(\"tmp\/baz\", \"\", \"\", \"baz\");\n+        test(\"\")\n+            .resolve(\"\", \"\", \"\")\n+            .resolve(\"\/bar\", \"foo\", \"\/bar\", \"\")\n+            .resolve(\"foo\/bar\/gus\", \"foo\", \"bar\", \"gus\")\n+            .resolve(\"baz\", \"\", \"\", \"baz\");\n+        test(\"\/\")\n+            .resolve(\"\/foo\", \"\", \"\", \"foo\", \"\")\n+            .resolve(\"\/foo\", \"foo\", \"\")\n+            .resolve(\"\/foo\", \"\", \"foo\")\n+            .resolve(\"\/bar\", \"foo\", \"\", \"\/bar\");\n+\n@@ -2080,1 +2148,1 @@\n-            Path.of(\"foo\", null);\n+            Path.of(\"foo\", (String[])null);\n","filename":"test\/jdk\/java\/nio\/file\/Path\/PathOps.java","additions":70,"deletions":2,"binary":false,"changes":72,"status":"modified"}]}