{"files":[{"patch":"@@ -519,0 +519,84 @@\n+    \/**\n+     * Resolves a path against this path, and then iteratively resolves any\n+     * additional paths.\n+     *\n+     * <p> This method resolves {@code first} against this {@code Path} as if\n+     * by calling {@link #resolve(Path)}. If {@code more} has one or more\n+     * elements then it resolves the first element against the result, then\n+     * iteratively resolves all subsequent elements. This method returns the\n+     * result from the final resolve.\n+     *\n+     * @implSpec\n+     * The default implementation is equivalent to the result obtained with:\n+     * {@snippet lang=java :\n+     *     Path result = resolve(first);\n+     *     for (Path p : more) {\n+     *         result = result.resolve(p);\n+     *     }\n+     * }\n+     *\n+     * @param   first\n+     *          the first path to resolve against this path\n+     * @param   more\n+     *          additional paths to iteratively resolve\n+     *\n+     * @return  the resulting path\n+     *\n+     * @see #resolve(Path)\n+     * @since 22\n+     *\/\n+    default Path resolve(Path first, Path... more) {\n+        Path result = resolve(first);\n+        for (Path p : more) {\n+            result = result.resolve(p);\n+        }\n+        return result;\n+    }\n+\n+    \/**\n+     * Converts a path string to a path, resolves that path against this path,\n+     * and then iteratively performs the same procedure for any additional\n+     * path strings.\n+     *\n+     * <p> This method converts {@code first} to a {@code Path} and resolves\n+     * that {@code Path} against this {@code Path} as if by calling\n+     * {@link #resolve(String)}. If {@code more} has one or more elements\n+     * then it converts the first element to a path, resolves that path against\n+     * the result, then iteratively converts and resolves all subsequent\n+     * elements. This method returns the result from the final resolve.\n+     *\n+     * @implSpec\n+     * The default implementation is equivalent to the result obtained with:\n+     * {@snippet lang=java :\n+     * Path result = resolve(first);\n+     * for (String s : more) {\n+     *     result = result.resolve(s);\n+     * }\n+     * }\n+     *\n+     * @param   first\n+     *          the first path string to convert to a path and\n+     *          resolve against this path\n+     *\n+     * @param   more\n+     *          additional path strings to be iteratively converted to\n+     *          paths and resolved\n+     *\n+     * @return  the resulting path\n+     *\n+     * @throws  InvalidPathException\n+     *          if a path string cannot be converted to a Path.\n+     *\n+     * @see #resolve(Path,Path...)\n+     * @see #resolve(String)\n+     *\n+     * @since 22\n+     *\/\n+    default Path resolve(String first, String... more) {\n+        Path result = resolve(first);\n+        for (String s : more) {\n+            result = result.resolve(s);\n+        }\n+        return result;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/nio\/file\/Path.java","additions":84,"deletions":0,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -398,0 +398,77 @@\n+   private static final byte[] resolve(byte[] base, byte[]... children) {\n+       \/\/ 'start' is either zero, indicating the base, or indicates which\n+       \/\/ child is that last one which is an absolute path\n+       int start = 0;\n+       int resultLength = base.length;\n+\n+       \/\/ Locate the last child which is an absolute path and calculate\n+       \/\/ the total number of bytes in the resolved path\n+       final int count = children.length;\n+       if (count > 0) {\n+           for (int i = 0; i < count; i++) {\n+               byte[] b = children[i];\n+               if (b.length > 0) {\n+                   if (b[0] == '\/') {\n+                       start = i + 1;\n+                       resultLength = b.length;\n+                   } else {\n+                       if (resultLength > 0)\n+                           resultLength++;\n+                       resultLength += b.length;\n+                   }\n+               }\n+           }\n+       }\n+\n+       \/\/ If the base is not being superseded by a child which is an\n+       \/\/ absolute path, then if at least one child is non-empty and\n+       \/\/ the base consists only of a '\/', then decrement resultLength to\n+       \/\/ account for an extra '\/' added in the resultLength computation.\n+       if (start == 0 && resultLength > base.length && base.length == 1 && base[0] == '\/')\n+           resultLength--;\n+\n+       \/\/ Allocate the result array and return if empty.\n+       byte[] result = new byte[resultLength];\n+       if (result.length == 0)\n+           return result;\n+\n+       \/\/ Prepend the base if it is non-empty and would not later be\n+       \/\/ overwritten by an absolute child\n+       int offset = 0;\n+       if (start == 0 && base.length > 0) {\n+           System.arraycopy(base, 0, result, 0, base.length);\n+           offset += base.length;\n+       }\n+\n+       \/\/ Append children starting with the last one which is an\n+       \/\/ absolute path\n+       if (count > 0) {\n+           int idx = Math.max(0, start - 1);\n+           for (int i = idx; i < count; i++) {\n+               byte[] b = children[i];\n+               if (b.length > 0) {\n+                   if (offset > 0 && result[offset - 1] != '\/')\n+                       result[offset++] = '\/';\n+                   System.arraycopy(b, 0, result, offset, b.length);\n+                   offset += b.length;\n+               }\n+           }\n+       }\n+\n+       return result;\n+   }\n+\n+    @Override\n+    public UnixPath resolve(Path first, Path... more) {\n+        if (more.length == 0)\n+            return resolve(first);\n+\n+        byte[][] children = new byte[1 + more.length][];\n+        children[0] = toUnixPath(first).path;\n+        for (int i = 0; i < more.length; i++)\n+            children[i + 1] = toUnixPath(more[i]).path;\n+\n+        byte[] result = resolve(path, children);\n+        return new UnixPath(getFileSystem(), result);\n+    }\n+\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixPath.java","additions":77,"deletions":0,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -25,1 +25,2 @@\n- * @bug 4313887 6838333 6925932 7006126 8037945 8072495 8140449 8254876 8298478\n+ * @bug 4313887 6838333 6925932 7006126 8037945 8072495 8140449 8254876 8262742\n+ *      8298478\n@@ -185,0 +186,21 @@\n+    \/\/ Note: \"expected\" is first parameter here\n+    PathOps resolve(String expected, String first, String... more) {\n+        out.format(\"test resolve %s varargs (String)\\n\", path());\n+        checkPath();\n+        check(path.resolve(first, more), expected);\n+        Path[] others = new Path[more.length];\n+        int i = 0;\n+        for (String s : more) {\n+            others[i++] = Path.of(s);\n+        }\n+        return resolve(expected, Path.of(first), others);\n+    }\n+\n+    \/\/ Note: \"expected\" is first parameter here\n+    PathOps resolve(String expected, Path first, Path... more) {\n+        out.format(\"test resolve %s varargs (Path)\\n\", path());\n+        checkPath();\n+        check(path.resolve(first, more), expected);\n+        return this;\n+    }\n+\n@@ -546,0 +568,29 @@\n+        \/\/ resolve - varargs\n+        test(\"C:\\\\tmp\")\n+            .resolve(\"C:\\\\tmp\\\\foo\\\\bar\\\\gus\", \"foo\", \"bar\", \"gus\")\n+            .resolve(\"C:\\\\gus\", \"\\\\foo\", \"bar\", \"\\\\gus\")\n+            .resolve(\"C:\\\\tmp\\\\baz\", \"\", \"\", \"baz\");\n+        test(\"C:\\\\tmp\\\\foo\")\n+            .resolve(\"C:\\\\tmp\\\\foo\\\\bar\\\\gus\", \"\", \"bar\\\\gus\", \"\")\n+            .resolve(\"C:\\\\tmp\\\\foo\\\\bar\\\\gus\\\\foo\\\\baz\",\n+                     \"\", \"bar\\\\gus\", \"foo\\\\baz\")\n+            .resolve(\"C:\\\\bar\\\\gus\\\\baz\", \"\", \"C:\\\\bar\\\\gus\", \"baz\")\n+            .resolve(\"C:\\\\tmp\\\\bar\", \"C:\\\\bar\\\\gus\", \"baz\", \"C:\\\\tmp\\\\bar\");\n+        test(\"tmp\")\n+            .resolve(\"tmp\\\\foo\\\\bar\\\\gus\", \"foo\", \"bar\", \"gus\")\n+            .resolve(\"\\\\gus\", \"\\\\foo\", \"bar\", \"\\\\gus\")\n+            .resolve(\"tmp\\\\baz\", \"\", \"\", \"baz\");\n+        test(\"\")\n+            .resolve(\"\", \"\", \"\")\n+            .resolve(\"\\\\bar\", \"foo\", \"\\\\bar\", \"\")\n+            .resolve(\"foo\\\\bar\\\\gus\", \"foo\", \"bar\", \"gus\")\n+            .resolve(\"baz\", \"\", \"\", \"baz\");\n+        test(\"\\\\\")\n+            .resolve(\"\\\\foo\", \"foo\", \"\")\n+            .resolve(\"\\\\foo\", \"\", \"foo\")\n+            .resolve(\"\\\\bar\", \"foo\", \"\", \"\\\\bar\");\n+        test(\"C:\")\n+            .resolve(\"C:foo\\\\bar\\\\gus\", \"foo\", \"bar\", \"gus\")\n+            .resolve(\"C:baz\", \"\", \"baz\")\n+            .resolve(\"C:\", \"\", \"\");\n+\n@@ -1672,0 +1723,25 @@\n+        \/\/ resolve - varargs\n+        test(\"\/tmp\")\n+            .resolve(\"\/tmp\/foo\/bar\/gus\", \"foo\", \"bar\", \"gus\")\n+            .resolve(\"\/gus\", \"\/foo\", \"bar\", \"\/gus\")\n+            .resolve(\"\/tmp\/baz\", \"\", \"\", \"baz\");\n+        test(\"\/tmp\/foo\")\n+            .resolve(\"\/tmp\/foo\/bar\/gus\", \"\", \"bar\/gus\", \"\")\n+            .resolve(\"\/tmp\/foo\/bar\/gus\/foo\/baz\", \"\", \"bar\/gus\", \"foo\/baz\")\n+            .resolve(\"\/bar\/gus\/baz\", \"\", \"\/bar\/gus\", \"baz\")\n+            .resolve(\"\/tmp\/bar\", \"\/bar\/gus\", \"baz\", \"\/tmp\/bar\");\n+        test(\"tmp\")\n+            .resolve(\"tmp\/foo\/bar\/gus\", \"foo\", \"bar\", \"gus\")\n+            .resolve(\"\/gus\", \"\/foo\", \"bar\", \"\/gus\")\n+            .resolve(\"tmp\/baz\", \"\", \"\", \"baz\");\n+        test(\"\")\n+            .resolve(\"\", \"\", \"\")\n+            .resolve(\"\/bar\", \"foo\", \"\/bar\", \"\")\n+            .resolve(\"foo\/bar\/gus\", \"foo\", \"bar\", \"gus\")\n+            .resolve(\"baz\", \"\", \"\", \"baz\");\n+        test(\"\/\")\n+            .resolve(\"\/foo\", \"\", \"\", \"foo\", \"\")\n+            .resolve(\"\/foo\", \"foo\", \"\")\n+            .resolve(\"\/foo\", \"\", \"foo\")\n+            .resolve(\"\/bar\", \"foo\", \"\", \"\/bar\");\n+\n@@ -2080,1 +2156,1 @@\n-            Path.of(\"foo\", null);\n+            Path.of(\"foo\", (String[])null);\n","filename":"test\/jdk\/java\/nio\/file\/Path\/PathOps.java","additions":78,"deletions":2,"binary":false,"changes":80,"status":"modified"}]}