{"files":[{"patch":"@@ -519,0 +519,80 @@\n+    \/**\n+     * Resolves a path or a sequence of paths against this path.\n+     *\n+     * <p> The result of this method is the same as would be obtained\n+     * by resolving the first parameter path against this path, then\n+     * resolving the second parameter path against the derived path,\n+     * and so on until all parameters have been processed. Each single\n+     * resolution in the chain behaves as specified by {@linkplain\n+     * #resolve(Path) resolve}.\n+     *\n+     * @implSpec\n+     * The default implementation is equivalent for this path to:\n+     * {@snippet lang=java :\n+     * Path result = resolve(first);\n+     * for (Path p : more) {\n+     *     result = result.resolve(p);\n+     * }\n+     * }\n+     *\n+     * @param first the first path to resolve against this path\n+     *\n+     * @param more additional paths to be joined to form the path\n+     *\n+     * @return the resulting path\n+     *\n+     * @see #resolve(Path)\n+     *\n+     * @since 22\n+     *\/\n+    default Path resolve(Path first, Path... more) {\n+        Path result = resolve(first);\n+        for (Path p : more) {\n+            result = result.resolve(p);\n+        }\n+        return result;\n+    }\n+\n+    \/**\n+     * Converts a path string or a sequence of path strings into one or more\n+     * {@code Path}s and resolves them against this {@code Path} in exactly\n+     * the same manner specified by the {@link #resolve(Path,Path...) resolve}\n+     * method.\n+     *\n+     * <p> The result of this method is the same as would be obtained\n+     * by resolving the first parameter path string against this path, then\n+     * resolving the second parameter path string against the derived path,\n+     * and so on until all parameters have been processed. Each single\n+     * resolution in the chain behaves as specified by {@linkplain\n+     * #resolve(String) resolve}.\n+     *\n+     * @implSpec\n+     * The default implementation is equivalent for this path to:\n+     * {@snippet lang=java :\n+     * Path result = resolve(first);\n+     * for (String s : more) {\n+     *     result = result.resolve(s);\n+     * }\n+     * }\n+     *\n+     * @param first the first path string to resolve against this path\n+     *\n+     * @param more additional path strings to be joined to form the path\n+     *\n+     * @return the resulting path\n+     *\n+     * @throws  InvalidPathException\n+     *          if the path string cannot be converted to a Path.\n+     *\n+     * @see #resolve(String)\n+     *\n+     * @since 22\n+     *\/\n+    default Path resolve(String first, String... more) {\n+        Path result = resolve(first);\n+        for (String s : more) {\n+            result = result.resolve(s);\n+        }\n+        return result;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/nio\/file\/Path.java","additions":80,"deletions":0,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -398,0 +398,78 @@\n+   private static final byte[] resolve(byte[] base, byte[]... descendants) {\n+       \/\/ 'start' is either zero, indicating the base, or indicates which\n+       \/\/ descendant is that last one which is an absolute path\n+       int start = 0;\n+       int length = base.length;\n+\n+       \/\/ Locate the last descendant which is an absolute path and calculate\n+       \/\/ the total number of bytes in the resolved path\n+       final int count = descendants.length;\n+       if (count > 0) {\n+           for (int i = 0; i < count; i++) {\n+               byte[] b = descendants[i];\n+               if (b.length > 0) {\n+                   if (b[0] == '\/') {\n+                       start = i + 1;\n+                       length = b.length;\n+                   } else {\n+                       if (length > 0)\n+                           length++;\n+                       length += b.length;\n+                   }\n+               }\n+           }\n+       }\n+\n+       \/\/ If the base is not being superseded by a descendant which is an\n+       \/\/ absolute path, then if at least one descendant is non-empty and\n+       \/\/ the base consists only of a '\/', then decrement the length to\n+       \/\/ account for an extra '\/' added in the length computation.\n+       if (start == 0 && length > base.length &&\n+           base.length == 1 && base[0] == '\/')\n+           length--;\n+\n+       \/\/ Allocate the result array and return if empty.\n+       byte[] result = new byte[length];\n+       if (result.length == 0)\n+           return result;\n+\n+       \/\/ Prepend the base if it is non-empty and would not later be\n+       \/\/ overwritten by an absolute descendant\n+       int offset = 0;\n+       if (start == 0 && base.length > 0) {\n+           System.arraycopy(base, 0, result, 0, base.length);\n+           offset += base.length;\n+       }\n+\n+       \/\/ Append descendants starting with the last one which is an\n+       \/\/ absolute path\n+       if (count > 0) {\n+           int idx = Math.max(0, start - 1);\n+           for (int i = idx; i < count; i++) {\n+               byte[] b = descendants[i];\n+               if (b.length > 0) {\n+                   if (offset > 0 && result[offset - 1] != '\/')\n+                       result[offset++] = '\/';\n+                   System.arraycopy(b, 0, result, offset, b.length);\n+                   offset += b.length;\n+               }\n+           }\n+       }\n+\n+       return result;\n+   }\n+\n+    @Override\n+    public UnixPath resolve(Path first, Path... more) {\n+        if (more.length == 0)\n+            return resolve(first);\n+\n+        byte[][] descendants = new byte[1 + more.length][];\n+        descendants[0] = toUnixPath(first).path;\n+        for (int i = 0; i < more.length; i++)\n+            descendants[i + 1] = toUnixPath(more[i]).path;\n+\n+        byte[] result = resolve(path, descendants);\n+        return new UnixPath(getFileSystem(), result);\n+    }\n+\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixPath.java","additions":78,"deletions":0,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -25,1 +25,2 @@\n- * @bug 4313887 6838333 6925932 7006126 8037945 8072495 8140449 8254876 8298478\n+ * @bug 4313887 6838333 6925932 7006126 8037945 8072495 8140449 8254876 8262742\n+ *      8298478\n@@ -185,0 +186,13 @@\n+    \/\/ Note: \"expected\" is first parameter here\n+    PathOps resolve(String expected, String first, String... more) {\n+        out.format(\"test resolve %s varargs\\n\", path());\n+        checkPath();\n+        Path[] others = new Path[more.length];\n+        int i = 0;\n+        for (String s : more) {\n+            others[i++] = Path.of(s);\n+        }\n+        check(path.resolve(Path.of(first), others), expected);\n+        return this;\n+    }\n+\n@@ -546,0 +560,23 @@\n+        \/\/ resolve - varargs\n+        test(\"C:\\\\tmp\")\n+            .resolve(\"C:\\\\tmp\\\\foo\\\\bar\\\\gus\", \"foo\", \"bar\", \"gus\")\n+            .resolve(\"C:\\\\gus\", \"\\\\foo\", \"bar\", \"\\\\gus\")\n+            .resolve(\"C:\\\\tmp\\\\baz\", \"\", \"\", \"baz\");\n+        test(\"tmp\")\n+            .resolve(\"tmp\\\\foo\\\\bar\\\\gus\", \"foo\", \"bar\", \"gus\")\n+            .resolve(\"\\\\gus\", \"\\\\foo\", \"bar\", \"\\\\gus\")\n+            .resolve(\"tmp\\\\baz\", \"\", \"\", \"baz\");\n+        test(\"\")\n+            .resolve(\"\", \"\", \"\")\n+            .resolve(\"\\\\bar\", \"foo\", \"\\\\bar\", \"\")\n+            .resolve(\"foo\\\\bar\\\\gus\", \"foo\", \"bar\", \"gus\")\n+            .resolve(\"baz\", \"\", \"\", \"baz\");\n+        test(\"\\\\\")\n+            .resolve(\"\\\\foo\", \"foo\", \"\")\n+            .resolve(\"\\\\foo\", \"\", \"foo\")\n+            .resolve(\"\\\\bar\", \"foo\", \"\", \"\\\\bar\");\n+        test(\"C:\")\n+            .resolve(\"C:foo\\\\bar\\\\gus\", \"foo\", \"bar\", \"gus\")\n+            .resolve(\"C:baz\", \"\", \"baz\")\n+            .resolve(\"C:\", \"\", \"\");\n+\n@@ -1672,0 +1709,20 @@\n+        \/\/ resolve - varargs\n+        test(\"\/tmp\")\n+            .resolve(\"\/tmp\/foo\/bar\/gus\", \"foo\", \"bar\", \"gus\")\n+            .resolve(\"\/gus\", \"\/foo\", \"bar\", \"\/gus\")\n+            .resolve(\"\/tmp\/baz\", \"\", \"\", \"baz\");\n+        test(\"tmp\")\n+            .resolve(\"tmp\/foo\/bar\/gus\", \"foo\", \"bar\", \"gus\")\n+            .resolve(\"\/gus\", \"\/foo\", \"bar\", \"\/gus\")\n+            .resolve(\"tmp\/baz\", \"\", \"\", \"baz\");\n+        test(\"\")\n+            .resolve(\"\", \"\", \"\")\n+            .resolve(\"\/bar\", \"foo\", \"\/bar\", \"\")\n+            .resolve(\"foo\/bar\/gus\", \"foo\", \"bar\", \"gus\")\n+            .resolve(\"baz\", \"\", \"\", \"baz\");\n+        test(\"\/\")\n+            .resolve(\"\/foo\", \"\", \"\", \"foo\", \"\")\n+            .resolve(\"\/foo\", \"foo\", \"\")\n+            .resolve(\"\/foo\", \"\", \"foo\")\n+            .resolve(\"\/bar\", \"foo\", \"\", \"\/bar\");\n+\n","filename":"test\/jdk\/java\/nio\/file\/Path\/PathOps.java","additions":58,"deletions":1,"binary":false,"changes":59,"status":"modified"}]}