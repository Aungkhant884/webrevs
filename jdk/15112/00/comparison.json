{"files":[{"patch":"@@ -28,1 +28,6 @@\n- * @modules jdk.jdeps\/com.sun.tools.classfile\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.classfile.instruction\n+ *          java.base\/jdk.internal.classfile.components\n+ *          java.base\/jdk.internal.classfile.impl\n@@ -31,3 +36,3 @@\n-import com.sun.tools.classfile.Attribute;\n-import com.sun.tools.classfile.ClassFile;\n-import com.sun.tools.classfile.SourceFile_attribute;\n+import jdk.internal.classfile.*;\n+import jdk.internal.classfile.Attributes;\n+import jdk.internal.classfile.attribute.*;\n@@ -110,3 +115,3 @@\n-            ClassFile cf = ClassFile.read(f);\n-            SourceFile_attribute sfa = (SourceFile_attribute) cf.getAttribute(Attribute.SourceFile);\n-            String found = sfa.getSourceFile(cf.constant_pool);\n+            ClassModel cf = Classfile.of().parse(f.toPath());\n+            SourceFileAttribute sfa = cf.findAttribute(Attributes.SOURCE_FILE).orElseThrow();\n+            String found = sfa.sourceFile().stringValue();\n","filename":"test\/langtools\/tools\/javac\/4241573\/T4241573.java","additions":12,"deletions":7,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -28,1 +28,6 @@\n- * @modules jdk.jdeps\/com.sun.tools.classfile\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.classfile.instruction\n+ *          java.base\/jdk.internal.classfile.components\n+ *          java.base\/jdk.internal.classfile.impl\n@@ -34,4 +39,2 @@\n-import com.sun.tools.classfile.Attribute;\n-import com.sun.tools.classfile.ClassFile;\n-import com.sun.tools.classfile.InnerClasses_attribute;\n-import com.sun.tools.classfile.ConstantPool.*;\n+import jdk.internal.classfile.*;\n+import jdk.internal.classfile.attribute.*;\n@@ -162,1 +165,1 @@\n-                ClassFile cf = ClassFile.read(compiledTest);\n+                ClassModel cf = Classfile.of().parse(compiledTest.toPath());\n@@ -167,1 +170,1 @@\n-                InnerClasses_attribute innerClasses = (InnerClasses_attribute)cf.getAttribute(Attribute.InnerClasses);\n+                InnerClassesAttribute innerClasses = cf.findAttribute(Attributes.INNER_CLASSES).orElse(null);\n@@ -171,2 +174,2 @@\n-                    for (InnerClasses_attribute.Info info : innerClasses.classes) {\n-                        String foundSig = info.getInnerClassInfo(cf.constant_pool).getName();\n+                    for (InnerClassInfo info : innerClasses.classes()) {\n+                        String foundSig = info.innerClass().asInternalName();\n@@ -190,1 +193,1 @@\n-                                    \"found \" + innerClasses.number_of_classes + \"\\n\" +\n+                                    \"found \" + (innerClasses == null? 0: innerClasses.classes().size()) + \"\\n\" +\n","filename":"test\/langtools\/tools\/javac\/7003595\/T7003595.java","additions":13,"deletions":10,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -28,1 +28,6 @@\n- * @modules jdk.jdeps\/com.sun.tools.classfile\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.classfile.instruction\n+ *          java.base\/jdk.internal.classfile.components\n+ *          java.base\/jdk.internal.classfile.impl\n@@ -33,4 +38,3 @@\n-import com.sun.tools.classfile.ClassFile;\n-import com.sun.tools.classfile.ConstantPool.CONSTANT_Class_info;\n-import com.sun.tools.classfile.ConstantPool.CPInfo;\n-import com.sun.tools.classfile.ConstantPoolException;\n+import jdk.internal.classfile.*;\n+import jdk.internal.classfile.constantpool.ClassEntry;\n+import jdk.internal.classfile.constantpool.PoolEntry;\n@@ -69,1 +73,1 @@\n-    void checkReferences() throws IOException, ConstantPoolException {\n+    void checkReferences() throws IOException {\n@@ -73,1 +77,1 @@\n-        ClassFile classFile = ClassFile.read(file);\n+        ClassModel classFile = Classfile.of().parse(file.toPath());\n@@ -75,5 +79,5 @@\n-        CPInfo cpInfo;\n-        while (i < classFile.constant_pool.size()) {\n-            cpInfo = classFile.constant_pool.get(i);\n-            if (cpInfo instanceof CONSTANT_Class_info) {\n-                checkClassName(((CONSTANT_Class_info)cpInfo).getName());\n+        PoolEntry cpInfo;\n+        while (i < classFile.constantPool().entryCount()) {\n+            cpInfo = classFile.constantPool().entryByIndex(i);\n+            if (cpInfo instanceof ClassEntry classEntry) {\n+                checkClassName(classEntry.asInternalName());\n@@ -81,1 +85,1 @@\n-            i += cpInfo.size();\n+            i += cpInfo.width();\n","filename":"test\/langtools\/tools\/javac\/7153958\/CPoolRefClassContainingInlinedCts.java","additions":17,"deletions":13,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -28,1 +28,6 @@\n- * @modules jdk.jdeps\/com.sun.tools.classfile\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.classfile.instruction\n+ *          java.base\/jdk.internal.classfile.components\n+ *          java.base\/jdk.internal.classfile.impl\n@@ -37,7 +42,1 @@\n-import com.sun.tools.classfile.ClassFile;\n-import com.sun.tools.classfile.ConstantPoolException;\n-import com.sun.tools.classfile.Descriptor;\n-import com.sun.tools.classfile.Descriptor.InvalidDescriptor;\n-import com.sun.tools.classfile.Method;\n-\n-import static com.sun.tools.classfile.AccessFlags.ACC_STRICT;\n+import jdk.internal.classfile.*;\n@@ -68,2 +67,1 @@\n-    public static void main(String[] args)\n-            throws IOException, ConstantPoolException, InvalidDescriptor {\n+    public static void main(String[] args) throws IOException {\n@@ -73,2 +71,1 @@\n-    private void run()\n-            throws IOException, ConstantPoolException, InvalidDescriptor {\n+    private void run() throws IOException {\n@@ -89,5 +86,1 @@\n-    void check(String dir, String... fileNames)\n-        throws\n-            IOException,\n-            ConstantPoolException,\n-            Descriptor.InvalidDescriptor {\n+    void check(String dir, String... fileNames) throws IOException{\n@@ -95,1 +88,1 @@\n-            ClassFile classFileToCheck = ClassFile.read(new File(dir, fileName));\n+            ClassModel classFileToCheck = Classfile.of().parse(new File(dir, fileName).toPath());\n@@ -97,2 +90,2 @@\n-            for (Method method : classFileToCheck.methods) {\n-                if ((method.access_flags.flags & ACC_STRICT) == 0) {\n+            for (MethodModel method : classFileToCheck.methods()) {\n+                if ((method.flags().flagsMask() & Classfile.ACC_STRICT) == 0) {\n@@ -100,2 +93,2 @@\n-                            method.getName(classFileToCheck.constant_pool),\n-                            classFileToCheck.getName()));\n+                            method.methodName().stringValue(),\n+                            classFileToCheck.thisClass().asInternalName()));\n","filename":"test\/langtools\/tools\/javac\/7166455\/CheckACC_STRICTFlagOnclinitTest.java","additions":15,"deletions":22,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -28,1 +28,6 @@\n- * @modules jdk.jdeps\/com.sun.tools.classfile\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.classfile.instruction\n+ *          java.base\/jdk.internal.classfile.components\n+ *          java.base\/jdk.internal.classfile.impl\n@@ -40,2 +45,1 @@\n-import com.sun.tools.classfile.ClassFile;\n-import com.sun.tools.classfile.ConstantPoolException;\n+import jdk.internal.classfile.*;\n@@ -88,1 +92,1 @@\n-    private void check(CompilationKind ck) throws IOException, ConstantPoolException {\n+    private void check(CompilationKind ck) throws IOException {\n@@ -91,1 +95,1 @@\n-            ClassFile classFile = ClassFile.read(file);\n+            ClassModel classFile = Classfile.of().parse(file.toPath());\n@@ -96,3 +100,3 @@\n-                    classFile.getSuperclassName().equals(\"java\/lang\/Object\");\n-            boolean implementsNoInterface = classFile.interfaces.length == 0;\n-            boolean noMethods = classFile.methods.length == 0;\n+                    classFile.superclass().orElseThrow().asInternalName().equals(\"java\/lang\/Object\");\n+            boolean implementsNoInterface = classFile.interfaces().size() == 0;\n+            boolean noMethods = classFile.methods().size() == 0;\n","filename":"test\/langtools\/tools\/javac\/7199823\/InnerClassCannotBeVerified.java","additions":12,"deletions":8,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -29,1 +29,6 @@\n- * @modules jdk.jdeps\/com.sun.tools.classfile\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.classfile.instruction\n+ *          java.base\/jdk.internal.classfile.components\n+ *          java.base\/jdk.internal.classfile.impl\n@@ -34,2 +39,2 @@\n-import com.sun.tools.classfile.ClassFile;\n-import com.sun.tools.classfile.ConstantPoolException;\n+import jdk.internal.classfile.*;\n+import jdk.internal.classfile.constantpool.ConstantPool;\n@@ -90,1 +95,1 @@\n-    void checkReference() throws IOException, ConstantPoolException {\n+    void checkReference() throws IOException {\n@@ -92,1 +97,2 @@\n-        ClassFile classFile = ClassFile.read(file);\n+        ClassModel classFile = Classfile.of().parse(file.toPath());\n+        ConstantPool constantPool = classFile.constantPool();\n@@ -94,7 +100,7 @@\n-                i < classFile.constant_pool.size() - 1;\n-                i += classFile.constant_pool.get(i).size()) {\n-            for (int j = i + classFile.constant_pool.get(i).size();\n-                    j < classFile.constant_pool.size();\n-                    j += classFile.constant_pool.get(j).size()) {\n-                if (classFile.constant_pool.get(i).toString().\n-                        equals(classFile.constant_pool.get(j).toString())) {\n+                i < constantPool.entryCount() - 1;\n+                i += constantPool.entryByIndex(i).width()) {\n+            for (int j = i + constantPool.entryByIndex(i).width();\n+                    j < constantPool.entryCount();\n+                    j += constantPool.entryByIndex(j).width()) {\n+                if (constantPool.entryByIndex(i).toString().\n+                        equals(constantPool.entryByIndex(j).toString())) {\n","filename":"test\/langtools\/tools\/javac\/8000518\/DuplicateConstantPoolEntry.java","additions":18,"deletions":12,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -28,1 +28,6 @@\n- * @modules jdk.jdeps\/com.sun.tools.classfile\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.classfile.components\n+ *          java.base\/jdk.internal.classfile.instruction\n+ *          java.base\/jdk.internal.classfile.impl\n@@ -43,7 +48,1 @@\n-import com.sun.tools.classfile.ClassFile;\n-import com.sun.tools.classfile.ConstantPoolException;\n-import com.sun.tools.classfile.Descriptor;\n-import com.sun.tools.classfile.Descriptor.InvalidDescriptor;\n-import com.sun.tools.classfile.Method;\n-\n-import static com.sun.tools.classfile.AccessFlags.ACC_STRICT;\n+import jdk.internal.classfile.*;\n@@ -65,2 +64,1 @@\n-    public static void main(String[] args)\n-            throws IOException, ConstantPoolException, InvalidDescriptor {\n+    public static void main(String[] args) throws IOException {\n@@ -71,2 +69,1 @@\n-    private void run(JavaCompiler comp)\n-            throws IOException, ConstantPoolException, InvalidDescriptor {\n+    private void run(JavaCompiler comp) throws IOException {\n@@ -98,6 +95,2 @@\n-    void check()\n-        throws\n-            IOException,\n-            ConstantPoolException,\n-            Descriptor.InvalidDescriptor {\n-        ClassFile classFileToCheck = ClassFile.read(new File(\"Test.class\"));\n+    void check() throws IOException {\n+        ClassModel classFileToCheck = Classfile.of().parse(new File(\"Test.class\").toPath());\n@@ -105,2 +98,2 @@\n-        for (Method method : classFileToCheck.methods) {\n-            if ((method.access_flags.flags & ACC_STRICT) == 0) {\n+        for (MethodModel method : classFileToCheck.methods()) {\n+            if ((method.flags().flagsMask() & Classfile.ACC_STRICT) == 0) {\n@@ -108,2 +101,2 @@\n-                        method.getName(classFileToCheck.constant_pool),\n-                        classFileToCheck.getName()));\n+                        method.methodName().stringValue(),\n+                        classFileToCheck.thisClass().asInternalName()));\n","filename":"test\/langtools\/tools\/javac\/8005931\/CheckACC_STRICTFlagOnPkgAccessClassTest.java","additions":15,"deletions":22,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -28,1 +28,6 @@\n- * @modules jdk.jdeps\/com.sun.tools.classfile\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.classfile.instruction\n+ *          java.base\/jdk.internal.classfile.components\n+ *          java.base\/jdk.internal.classfile.impl\n@@ -36,2 +41,3 @@\n-import com.sun.tools.classfile.*;\n-import static com.sun.tools.classfile.AccessFlags.*;\n+import jdk.internal.classfile.*;\n+import jdk.internal.classfile.attribute.InnerClassInfo;\n+import jdk.internal.classfile.attribute.InnerClassesAttribute;\n@@ -92,1 +98,1 @@\n-        ClassFile outerClass = ClassFile.read(outerFile);\n+        ClassModel outerClass = Classfile.of().parse(outerFile);\n@@ -95,1 +101,1 @@\n-            ClassFile innerClass = ClassFile.read(innerFile);\n+            ClassModel innerClass = Classfile.of().parse(innerFile);\n@@ -104,5 +110,5 @@\n-    static void assertClassFlags(ClassFile classFile, String name, int expected) {\n-        int mask = ACC_PUBLIC | ACC_FINAL | ACC_INTERFACE | ACC_ABSTRACT |\n-                   ACC_SYNTHETIC | ACC_ANNOTATION | ACC_ENUM;\n-        int classExpected = (expected & mask) | ACC_SUPER;\n-        int classActual = classFile.access_flags.flags;\n+    static void assertClassFlags(ClassModel classFile, String name, int expected) {\n+        int mask = Classfile.ACC_PUBLIC | Classfile.ACC_FINAL | Classfile.ACC_INTERFACE | Classfile.ACC_ABSTRACT |\n+                   Classfile.ACC_SYNTHETIC | Classfile.ACC_ANNOTATION | Classfile.ACC_ENUM;\n+        int classExpected = (expected & mask) | Classfile.ACC_SUPER;\n+        int classActual = classFile.flags().flagsMask();\n@@ -116,2 +122,2 @@\n-    static void assertInnerFlags(ClassFile classFile, String name, int expected) throws ConstantPoolException {\n-        int innerActual = lookupInnerFlags(classFile, name).flags;\n+    static void assertInnerFlags(ClassModel classFile, String name, int expected) {\n+        int innerActual = lookupInnerFlags(classFile, name);\n@@ -120,1 +126,1 @@\n-                                     \" in class \" + classFile.getName() +\n+                                     \" in class \" + classFile.thisClass().asInternalName() +\n@@ -125,2 +131,2 @@\n-    private static AccessFlags lookupInnerFlags(ClassFile classFile, String innerName) throws ConstantPoolException {\n-        InnerClasses_attribute inners = (InnerClasses_attribute) classFile.getAttribute(\"InnerClasses\");\n+    private static int lookupInnerFlags(ClassModel classFile, String innerName) {\n+        InnerClassesAttribute inners = classFile.findAttribute(Attributes.INNER_CLASSES).orElse(null);\n@@ -128,1 +134,1 @@\n-            throw new AssertionError(\"InnerClasses attribute missing in class \" + classFile.getName());\n+            throw new AssertionError(\"InnerClasses attribute missing in class \" + classFile.thisClass().asInternalName());\n@@ -130,2 +136,2 @@\n-        for (InnerClasses_attribute.Info info : inners.classes) {\n-            String entryName = info.getInnerClassInfo(classFile.constant_pool).getName();\n+        for (InnerClassInfo info: inners.classes()) {\n+            String entryName = info.innerClass().asInternalName();\n@@ -133,1 +139,1 @@\n-                return info.inner_class_access_flags;\n+                return info.flagsMask();\n@@ -136,1 +142,1 @@\n-        throw new AssertionError(\"No InnerClasses entry in class \" + classFile.getName() + \" for class \" + innerName);\n+        throw new AssertionError(\"No InnerClasses entry in class \" + classFile.thisClass().asInternalName() + \" for class \" + innerName);\n","filename":"test\/langtools\/tools\/javac\/AnonymousClass\/AnonymousClassFlags.java","additions":26,"deletions":20,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -28,1 +28,6 @@\n- * @modules jdk.jdeps\/com.sun.tools.classfile\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.classfile.instruction\n+ *          java.base\/jdk.internal.classfile.components\n+ *          java.base\/jdk.internal.classfile.impl\n","filename":"test\/langtools\/tools\/javac\/MethodParameters\/AnnotationTest.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -28,1 +28,6 @@\n- * @modules jdk.jdeps\/com.sun.tools.classfile\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.classfile.instruction\n+ *          java.base\/jdk.internal.classfile.components\n+ *          java.base\/jdk.internal.classfile.impl\n","filename":"test\/langtools\/tools\/javac\/MethodParameters\/AnonymousClass.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1,69 +0,0 @@\n-\/*\n- * Copyright (c) 2013, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import com.sun.tools.classfile.*;\n-\n-\/**\n- * Trivial {@code Attribute.Visitor} implementation, to make it easy to\n- * write visitors for specific attributes.\n- *\/\n-class AttributeVisitor<R, P> implements Attribute.Visitor<R, P> {\n-    public R visitBootstrapMethods(BootstrapMethods_attribute attr, P p) { return null; }\n-    public R visitDefault(DefaultAttribute attr, P p) { return null; }\n-    public R visitAnnotationDefault(AnnotationDefault_attribute attr, P p) { return null; }\n-    public R visitCharacterRangeTable(CharacterRangeTable_attribute attr, P p) { return null; }\n-    public R visitCode(Code_attribute attr, P p) { return null; }\n-    public R visitCompilationID(CompilationID_attribute attr, P p) { return null; }\n-    public R visitConstantValue(ConstantValue_attribute attr, P p) { return null; }\n-    public R visitDeprecated(Deprecated_attribute attr, P p) { return null; }\n-    public R visitEnclosingMethod(EnclosingMethod_attribute attr, P p) { return null; }\n-    public R visitExceptions(Exceptions_attribute attr, P p) { return null; }\n-    public R visitInnerClasses(InnerClasses_attribute attr, P p) { return null; }\n-    public R visitLineNumberTable(LineNumberTable_attribute attr, P p) { return null; }\n-    public R visitLocalVariableTable(LocalVariableTable_attribute attr, P p) { return null; }\n-    public R visitLocalVariableTypeTable(LocalVariableTypeTable_attribute attr, P p) { return null; }\n-    public R visitNestHost(NestHost_attribute attr, P p) { return null; }\n-    public R visitMethodParameters(MethodParameters_attribute attr, P p) { return null; }\n-    public R visitModule(Module_attribute attr, P p) { return null; }\n-    public R visitModuleHashes(ModuleHashes_attribute attr, P p) { return null; }\n-    public R visitModuleMainClass(ModuleMainClass_attribute attr, P p) { return null; }\n-    public R visitModulePackages(ModulePackages_attribute attr, P p) { return null; }\n-    public R visitModuleResolution(ModuleResolution_attribute attr, P p) { return null; }\n-    public R visitModuleTarget(ModuleTarget_attribute attr, P p) { return null; }\n-    public R visitNestMembers(NestMembers_attribute attr, P p) { return null; }\n-    public R visitRuntimeVisibleAnnotations(RuntimeVisibleAnnotations_attribute attr, P p) { return null; }\n-    public R visitRuntimeInvisibleAnnotations(RuntimeInvisibleAnnotations_attribute attr, P p) { return null; }\n-    public R visitRuntimeVisibleParameterAnnotations(RuntimeVisibleParameterAnnotations_attribute attr, P p) { return null; }\n-    public R visitRuntimeInvisibleParameterAnnotations(RuntimeInvisibleParameterAnnotations_attribute attr, P p) { return null; }\n-    public R visitRuntimeVisibleTypeAnnotations(RuntimeVisibleTypeAnnotations_attribute attr, P p) { return null; }\n-    public R visitRuntimeInvisibleTypeAnnotations(RuntimeInvisibleTypeAnnotations_attribute attr, P p) { return null; }\n-    public R visitSignature(Signature_attribute attr, P p) { return null; }\n-    public R visitSourceDebugExtension(SourceDebugExtension_attribute attr, P p) { return null; }\n-    public R visitSourceFile(SourceFile_attribute attr, P p) { return null; }\n-    public R visitSourceID(SourceID_attribute attr, P p) { return null; }\n-    public R visitStackMap(StackMap_attribute attr, P p) { return null; }\n-    public R visitStackMapTable(StackMapTable_attribute attr, P p) { return null; }\n-    public R visitSynthetic(Synthetic_attribute attr, P p) { return null; }\n-    public R visitPermittedSubclasses(PermittedSubclasses_attribute attr, P p) { return null; }\n-    public R visitRecord(Record_attribute attr, P p) { return null; }\n-}\n","filename":"test\/langtools\/tools\/javac\/MethodParameters\/AttributeVisitor.java","additions":0,"deletions":69,"binary":false,"changes":69,"status":"deleted"},{"patch":"@@ -24,0 +24,3 @@\n+import jdk.internal.classfile.*;\n+import jdk.internal.classfile.attribute.*;\n+import jdk.internal.classfile.constantpool.Utf8Entry;\n@@ -25,1 +28,1 @@\n-import com.sun.tools.classfile.*;\n+import java.lang.constant.MethodTypeDesc;\n@@ -29,1 +32,1 @@\n- * {@code com.sun.tools.classfile} library. It iterates over the methods\n+ * {@code jdk.internal.classfile} library. It iterates over the methods\n@@ -66,1 +69,1 @@\n-    public ClassFile classFile;\n+    public ClassModel classFile;\n@@ -87,4 +90,4 @@\n-        classFile = ClassFile.read(cfile);\n-        isEnum = classFile.access_flags.is(AccessFlags.ACC_ENUM);\n-        isInterface = classFile.access_flags.is(AccessFlags.ACC_INTERFACE);\n-        isPublic = classFile.access_flags.is(AccessFlags.ACC_PUBLIC);\n+        classFile = Classfile.of().parse(cfile.toPath());\n+        isEnum = (classFile.flags().flagsMask() & Classfile.ACC_ENUM) != 0;\n+        isInterface = (classFile.flags().flagsMask() & Classfile.ACC_INTERFACE) != 0;\n+        isPublic = (classFile.flags().flagsMask() & Classfile.ACC_PUBLIC) != 0;\n@@ -95,2 +98,1 @@\n-        Attribute attr = classFile.getAttribute(\"InnerClasses\");\n-        if (attr != null) attr.accept(new InnerClassVisitor(), null);\n+        classFile.findAttribute(Attributes.INNER_CLASSES).ifPresent(this::visitInnerClasses);\n@@ -108,1 +110,1 @@\n-        for (Method method : classFile.methods) {\n+        for (MethodModel method : classFile.methods()) {\n@@ -114,1 +116,1 @@\n-     * Used to visit InnerClasses_attribute of a class,\n+     * Used to visit InnerClassesAttribute of a class,\n@@ -120,14 +122,10 @@\n-    class InnerClassVisitor extends AttributeVisitor<Void, Void> {\n-        public Void visitInnerClasses(InnerClasses_attribute iattr, Void v) {\n-            try{\n-                for (InnerClasses_attribute.Info info : iattr.classes) {\n-                    if (info.getInnerClassInfo(classFile.constant_pool) == null) continue;\n-                    String in = info.getInnerClassInfo(classFile.constant_pool).getName();\n-                    if (in == null || !cname.equals(in)) continue;\n-                    isInner = true;\n-                    isAnon = null == info.getInnerName(classFile.constant_pool);\n-                    isStatic = info.inner_class_access_flags.is(AccessFlags.ACC_STATIC);\n-                    break;\n-                }\n-            } catch(Exception e) {\n-                throw new IllegalStateException(e);\n+    void visitInnerClasses(InnerClassesAttribute iattr) {\n+        try{\n+            for (InnerClassInfo info : iattr.classes()) {\n+                if (info.innerClass() == null) continue;\n+                String in = info.innerClass().name().stringValue();\n+                if (!cname.equals(in)) continue;\n+                isInner = true;\n+                isAnon = null == info.innerName().orElse(null);\n+                isStatic = (info.flagsMask() & Classfile.ACC_STATIC) != 0;\n+                break;\n@@ -135,1 +133,2 @@\n-            return null;\n+        } catch(Exception e) {\n+            throw new IllegalStateException(e);\n@@ -142,1 +141,1 @@\n-    class MethodVisitor extends AttributeVisitor<Void, StringBuilder> {\n+    class MethodVisitor {\n@@ -145,1 +144,1 @@\n-        public Descriptor mDesc;\n+        public MethodTypeDesc mDesc;\n@@ -156,1 +155,1 @@\n-        void visitMethod(Method method, StringBuilder sb) throws Exception {\n+        void visitMethod(MethodModel method, StringBuilder sb) {\n@@ -158,4 +157,4 @@\n-            mName = method.getName(classFile.constant_pool);\n-            mDesc = method.descriptor;\n-            mParams =  mDesc.getParameterCount(classFile.constant_pool);\n-            mAttrs = method.attributes.attrs.length;\n+            mName = method.methodName().stringValue();\n+            mDesc = method.methodTypeSymbol();\n+            mParams =  mDesc.parameterCount();\n+            mAttrs = method.attributes().size();\n@@ -163,1 +162,1 @@\n-            mSynthetic = method.access_flags.is(AccessFlags.ACC_SYNTHETIC);\n+            mSynthetic = (method.flags().flagsMask() & Classfile.ACC_SYNTHETIC) != 0;\n@@ -167,1 +166,1 @@\n-            mIsBridge = method.access_flags.is(AccessFlags.ACC_BRIDGE);\n+            mIsBridge = (method.flags().flagsMask() & Classfile.ACC_BRIDGE) != 0;\n@@ -174,2 +173,3 @@\n-            for (Attribute a : method.attributes) {\n-                a.accept(this, sb);\n+            for (Attribute<?> a : method.attributes()) {\n+                if (a instanceof MethodParametersAttribute pa)\n+                    visitMethodParameters(pa, sb);\n@@ -202,1 +202,1 @@\n-        public Void visitMethodParameters(MethodParameters_attribute mp,\n+        public void visitMethodParameters(MethodParametersAttribute mp,\n@@ -208,1 +208,1 @@\n-                return null;\n+                return;\n@@ -211,1 +211,1 @@\n-            mNumParams = mp.method_parameter_table_length;\n+            mNumParams = mp.parameters().size();\n@@ -216,1 +216,1 @@\n-                return null;\n+                return;\n@@ -223,1 +223,1 @@\n-                return null;\n+                return;\n@@ -235,1 +235,1 @@\n-                isFinal = (mp.method_parameter_table[x].flags & AccessFlags.ACC_FINAL) != 0;\n+                isFinal = (mp.parameters().get(x).flagsMask() & Classfile.ACC_FINAL) != 0;\n@@ -237,2 +237,2 @@\n-                int cpi = mp.method_parameter_table[x].name_index;\n-                if (cpi == 0) {\n+                Utf8Entry paramEntry = mp.parameters().get(x).name().orElse(null);\n+                if (paramEntry == null) {\n@@ -240,15 +240,1 @@\n-                    return null;\n-                }\n-\n-                \/\/ SPEC: a non 0 index, must be valid!\n-                String param = null;\n-                try {\n-                    param = classFile.constant_pool.getUTF8Value(cpi);\n-                    if (isFinal)\n-                        param = \"final \" + param;\n-                    sb.append(sep).append(param);\n-                    sep = \", \";\n-                } catch(ConstantPoolException e) {\n-                    error(prefix + \"invalid index \" + cpi + \" for param[\"\n-                          + x + \"]\");\n-                    return null;\n+                    return;\n@@ -256,1 +242,5 @@\n-\n+                String param = paramEntry.stringValue();\n+                if (isFinal)\n+                    param = \"final \" + paramEntry.stringValue();\n+                sb.append(sep).append(param);\n+                sep = \", \";\n@@ -261,1 +251,1 @@\n-                    return null;\n+                    return;\n@@ -285,1 +275,1 @@\n-                    return null;\n+                    return;\n@@ -293,1 +283,0 @@\n-            return null;\n@@ -303,1 +292,1 @@\n-        int checkParam(MethodParameters_attribute mp, String param, int index,\n+        int checkParam(MethodParametersAttribute mp, String param, int index,\n@@ -306,4 +295,4 @@\n-            boolean synthetic = (mp.method_parameter_table[index].flags\n-                                 & AccessFlags.ACC_SYNTHETIC) != 0;\n-            boolean mandated = (mp.method_parameter_table[index].flags\n-                                & AccessFlags.ACC_MANDATED) != 0;\n+            boolean synthetic = (mp.parameters().get(index).flagsMask()\n+                                 & Classfile.ACC_SYNTHETIC) != 0;\n+            boolean mandated = (mp.parameters().get(index).flagsMask()\n+                                & Classfile.ACC_MANDATED) != 0;\n@@ -365,1 +354,1 @@\n-                \/*  you can't expect an special name for bridges' parameters.\n+                \/*  you can't expect a special name for bridges' parameters.\n","filename":"test\/langtools\/tools\/javac\/MethodParameters\/ClassFileVisitor.java","additions":59,"deletions":70,"binary":false,"changes":129,"status":"modified"},{"patch":"@@ -28,1 +28,6 @@\n- * @modules jdk.jdeps\/com.sun.tools.classfile\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.classfile.instruction\n+ *          java.base\/jdk.internal.classfile.components\n+ *          java.base\/jdk.internal.classfile.impl\n","filename":"test\/langtools\/tools\/javac\/MethodParameters\/Constructors.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -28,1 +28,6 @@\n- * @modules jdk.jdeps\/com.sun.tools.classfile\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.classfile.instruction\n+ *          java.base\/jdk.internal.classfile.components\n+ *          java.base\/jdk.internal.classfile.impl\n","filename":"test\/langtools\/tools\/javac\/MethodParameters\/EnumTest.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -28,1 +28,6 @@\n- * @modules jdk.jdeps\/com.sun.tools.classfile\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.classfile.instruction\n+ *          java.base\/jdk.internal.classfile.components\n+ *          java.base\/jdk.internal.classfile.impl\n","filename":"test\/langtools\/tools\/javac\/MethodParameters\/InstanceMethods.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -28,1 +28,6 @@\n- * @modules jdk.jdeps\/com.sun.tools.classfile\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.classfile.instruction\n+ *          java.base\/jdk.internal.classfile.components\n+ *          java.base\/jdk.internal.classfile.impl\n","filename":"test\/langtools\/tools\/javac\/MethodParameters\/LambdaTest.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -28,1 +28,6 @@\n- * @modules jdk.jdeps\/com.sun.tools.classfile\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.classfile.instruction\n+ *          java.base\/jdk.internal.classfile.components\n+ *          java.base\/jdk.internal.classfile.impl\n@@ -33,4 +38,3 @@\n-import com.sun.tools.classfile.ClassFile;\n-import com.sun.tools.classfile.Method;\n-import com.sun.tools.classfile.MethodParameters_attribute;\n-import com.sun.tools.classfile.MethodParameters_attribute.Entry;\n+import jdk.internal.classfile.*;\n+import jdk.internal.classfile.attribute.MethodParameterInfo;\n+import jdk.internal.classfile.attribute.MethodParametersAttribute;\n@@ -43,0 +47,1 @@\n+import java.util.Objects;\n@@ -93,4 +98,3 @@\n-        ClassFile classFile = ClassFile.read(Paths.get(\"Test.class\"));\n-        Method method = getMethod(classFile, \"f\");\n-        MethodParameters_attribute attribute =\n-                (MethodParameters_attribute) method.attributes.get(\"MethodParameters\");\n+        ClassModel classFile = Classfile.of().parse(Paths.get(\"Test.class\"));\n+        MethodModel method = getMethod(classFile, \"f\");\n+        MethodParametersAttribute attribute = method.findAttribute(Attributes.METHOD_PARAMETERS).orElse(null);\n@@ -101,2 +105,2 @@\n-        for (Entry e : attribute.method_parameter_table) {\n-            parameterNames.add(classFile.constant_pool.getUTF8Value(e.name_index));\n+        for (MethodParameterInfo e : attribute.parameters()) {\n+            parameterNames.add(e.name().orElseThrow().stringValue());\n@@ -107,3 +111,3 @@\n-    private static Method getMethod(ClassFile classFile, String name) throws Exception {\n-        for (Method method : classFile.methods) {\n-            if (classFile.constant_pool.getUTF8Value(method.name_index).equals(name)) {\n+    private static MethodModel getMethod(ClassModel classFile, String name) throws Exception {\n+        for (MethodModel method : classFile.methods()) {\n+            if (method.methodName().equalsString(name)) {\n","filename":"test\/langtools\/tools\/javac\/MethodParameters\/LegacyOutputTest\/LegacyOutputTest.java","additions":18,"deletions":14,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -28,1 +28,6 @@\n- * @modules jdk.jdeps\/com.sun.tools.classfile\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.classfile.instruction\n+ *          java.base\/jdk.internal.classfile.components\n+ *          java.base\/jdk.internal.classfile.impl\n","filename":"test\/langtools\/tools\/javac\/MethodParameters\/LocalClassTest.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -28,1 +28,6 @@\n- * @modules jdk.jdeps\/com.sun.tools.classfile\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.classfile.instruction\n+ *          java.base\/jdk.internal.classfile.components\n+ *          java.base\/jdk.internal.classfile.impl\n","filename":"test\/langtools\/tools\/javac\/MethodParameters\/MemberClassTest.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -28,1 +28,6 @@\n- * @modules jdk.jdeps\/com.sun.tools.classfile\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.classfile.instruction\n+ *          java.base\/jdk.internal.classfile.components\n+ *          java.base\/jdk.internal.classfile.impl\n","filename":"test\/langtools\/tools\/javac\/MethodParameters\/StaticMethods.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -28,1 +28,6 @@\n- * @modules jdk.jdeps\/com.sun.tools.classfile\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.classfile.instruction\n+ *          java.base\/jdk.internal.classfile.components\n+ *          java.base\/jdk.internal.classfile.impl\n","filename":"test\/langtools\/tools\/javac\/MethodParameters\/UncommonParamNames.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -28,1 +28,6 @@\n- * @modules jdk.jdeps\/com.sun.tools.classfile\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.classfile.instruction\n+ *          java.base\/jdk.internal.classfile.components\n+ *          java.base\/jdk.internal.classfile.impl\n@@ -37,1 +42,2 @@\n-import com.sun.tools.classfile.*;\n+import jdk.internal.classfile.*;\n+import jdk.internal.classfile.attribute.*;\n@@ -46,0 +52,1 @@\n+import java.nio.file.Files;\n@@ -150,2 +157,1 @@\n-            if (e instanceof ExecutableElement) {\n-                final ExecutableElement ee = (ExecutableElement) e;\n+            if (e instanceof ExecutableElement ee) {\n@@ -168,6 +174,1 @@\n-        final ClassFile baz = ClassFile.read(Baz_class);\n-        final int ind = baz.constant_pool.getUTF8Index(\"baz\");\n-        MethodParameters_attribute mpattr = null;\n-        int mpind = 0;\n-        Code_attribute cattr = null;\n-        int cind = 0;\n+        final ClassModel baz = Classfile.of().parse(Baz_class.toPath());\n@@ -175,2 +176,2 @@\n-        \/\/ Find the indexes of the MethodParameters and the Code attributes\n-        if (baz.methods.length != 1)\n+        \/\/ Find MethodParameters and the Code attributes\n+        if (baz.methods().size() != 1)\n@@ -178,1 +179,1 @@\n-        if (!baz.methods[0].getName(baz.constant_pool).equals(\"<init>\"))\n+        if (!baz.methods().get(0).methodName().equalsString(\"<init>\"))\n@@ -180,13 +181,3 @@\n-                                baz.methods[0].getName(baz.constant_pool));\n-        for (int i = 0; i < baz.methods[0].attributes.attrs.length; i++) {\n-            if (baz.methods[0].attributes.attrs[i] instanceof\n-                MethodParameters_attribute) {\n-                mpattr = (MethodParameters_attribute)\n-                    baz.methods[0].attributes.attrs[i];\n-                mpind = i;\n-            } else if (baz.methods[0].attributes.attrs[i] instanceof\n-                       Code_attribute) {\n-                cattr = (Code_attribute) baz.methods[0].attributes.attrs[i];\n-                cind = i;\n-            }\n-        }\n+                                baz.methods().get(0).methodName().stringValue());\n+        MethodParametersAttribute mpattr = baz.methods().get(0).findAttribute(Attributes.METHOD_PARAMETERS).orElse(null);\n+        CodeAttribute cattr = baz.methods().get(0).findAttribute(Attributes.CODE).orElse(null);;\n@@ -198,2 +189,0 @@\n-        int flags = mpattr.method_parameter_table[0].flags;\n-\n@@ -201,32 +190,6 @@\n-        \/\/ the parameter from i to baz.  This requires Black Magic...\n-        \/\/\n-        \/\/ The (well-designed) classfile library (correctly) does not\n-        \/\/ allow us to mess around with the attribute data structures,\n-        \/\/ or arbitrarily generate new ones.\n-        \/\/\n-        \/\/ Instead, we install a new subclass of Attribute that\n-        \/\/ hijacks the Visitor pattern and outputs the sequence of\n-        \/\/ bytes that we want.  This only works in this particular\n-        \/\/ instance, because we know we'll only every see one kind of\n-        \/\/ visitor.\n-        \/\/\n-        \/\/ If anyone ever changes the makeup of the Baz class, or\n-        \/\/ tries to install some kind of visitor that gets run prior\n-        \/\/ to serialization, this will break.\n-        baz.methods[0].attributes.attrs[mpind] =\n-            new Attribute(mpattr.attribute_name_index,\n-                          mpattr.attribute_length) {\n-                public <R, D> R accept(Visitor<R, D> visitor, D data) {\n-                    if (data instanceof ByteArrayOutputStream) {\n-                        ByteArrayOutputStream out =\n-                            (ByteArrayOutputStream) data;\n-                        out.write(1);\n-                        out.write((ind >> 8) & 0xff);\n-                        out.write(ind & 0xff);\n-                        out.write((flags >> 24) & 0xff);\n-                        out.write((flags >> 16) & 0xff);\n-                        out.write((flags >> 8) & 0xff);\n-                        out.write(flags & 0xff);\n-                    } else\n-                        throw new RuntimeException(\"Output stream is of type \" + data.getClass() + \", which is not handled by this test.  Update the test and it should work.\");\n-                    return null;\n+        \/\/ the parameter from i to baz.\n+        byte[] bazBytes = Classfile.of().transform(baz, ClassTransform.transformingMethods((methodBuilder, methodElement) -> {\n+            if (methodElement instanceof MethodParametersAttribute a) {\n+                List<MethodParameterInfo> newParameterInfos = new ArrayList<>();\n+                for (MethodParameterInfo info : a.parameters()) {\n+                    newParameterInfos.add(MethodParameterInfo.ofParameter(\"baz\".describeConstable(), info.flagsMask()));\n@@ -234,1 +197,6 @@\n-            };\n+                a = MethodParametersAttribute.of(newParameterInfos);\n+                methodBuilder.with(a);\n+            } else {\n+                methodBuilder.with(methodElement);\n+            }\n+        }));\n@@ -236,1 +204,1 @@\n-        \/\/ Flip the code and method attributes.  This is for checking\n+        \/\/ Flip the code and method attributes().  This is for checking\n@@ -239,2 +207,9 @@\n-            baz.methods[0].attributes.attrs[mpind] = cattr;\n-            baz.methods[0].attributes.attrs[cind] = mpattr;\n+            bazBytes = Classfile.of().transform(baz, ClassTransform.transformingMethods((methodBuilder, methodElement) -> {\n+                if (methodElement instanceof MethodParametersAttribute) {\n+                    methodBuilder.with(cattr);\n+                } else if (methodElement instanceof CodeAttribute){\n+                    methodBuilder.with(mpattr);\n+                } else {\n+                    methodBuilder.with(methodElement);\n+                }\n+            }));\n@@ -242,2 +217,1 @@\n-\n-        new ClassWriter().write(baz, Baz_class);\n+        Files.write(Baz_class.toPath(), bazBytes);\n@@ -249,10 +223,6 @@\n-        final ClassFile foo = ClassFile.read(Foo_class);\n-        for (int i = 0; i < foo.methods.length; i++) {\n-            System.err.println(\"Examine method Foo.\" + foo.methods[i].getName(foo.constant_pool));\n-            if (foo.methods[i].getName(foo.constant_pool).equals(\"foo2\")) {\n-                for (int j = 0; j < foo.methods[i].attributes.attrs.length; j++)\n-                    if (foo.methods[i].attributes.attrs[j] instanceof\n-                        MethodParameters_attribute) {\n-                        MethodParameters_attribute mp =\n-                            (MethodParameters_attribute)\n-                            foo.methods[i].attributes.attrs[j];\n+        final ClassModel foo = Classfile.of().parse(Foo_class.toPath());\n+        for (int i = 0; i < foo.methods().size(); i++) {\n+            System.err.println(\"Examine method Foo.\" + foo.methods().get(i).methodName());\n+            if (foo.methods().get(i).methodName().equalsString(\"foo2\")) {\n+                for (int j = 0; j < foo.methods().get(i).attributes().size(); j++)\n+                    if (foo.methods().get(i).attributes().get(j) instanceof  MethodParametersAttribute mp) {\n@@ -260,1 +230,1 @@\n-                        if (2 != mp.method_parameter_table_length)\n+                        if (2 != mp.parameters().size())\n@@ -262,2 +232,2 @@\n-                                  mp.method_parameter_table_length);\n-                        else if (!foo.constant_pool.getUTF8Value(mp.method_parameter_table[0].name_index).equals(\"j\"))\n+                                  mp.parameters().size());\n+                        else if (!mp.parameters().get(0).name().orElseThrow().equalsString(\"j\"))\n@@ -265,1 +235,1 @@\n-                                  foo.constant_pool.getUTF8Value(mp.method_parameter_table[0].name_index) +\n+                                  mp.parameters().get(0).name().orElseThrow().stringValue() +\n@@ -267,1 +237,1 @@\n-                        else if  (!foo.constant_pool.getUTF8Value(mp.method_parameter_table[1].name_index).equals(\"k\"))\n+                        else if  (!mp.parameters().get(1).name().orElseThrow().equalsString(\"k\"))\n@@ -269,1 +239,1 @@\n-                                  foo.constant_pool.getUTF8Value(mp.method_parameter_table[1].name_index) +\n+                                 mp.parameters().get(1).name().orElseThrow() +\n@@ -273,4 +243,4 @@\n-            else if (foo.methods[i].getName(foo.constant_pool).equals(\"<init>\")) {\n-                for (int j = 0; j < foo.methods[i].attributes.attrs.length; j++) {\n-                    if (foo.methods[i].attributes.attrs[j] instanceof\n-                        MethodParameters_attribute)\n+            else if (foo.methods().get(i).methodName().equalsString(\"<init>\")) {\n+                for (int j = 0; j < foo.methods().get(i).attributes().size(); j++) {\n+                    if (foo.methods().get(i).attributes().get(j) instanceof\n+                        MethodParametersAttribute)\n@@ -280,4 +250,4 @@\n-            else if (foo.methods[i].getName(foo.constant_pool).equals(\"foo0\")) {\n-                for (int j = 0; j < foo.methods[i].attributes.attrs.length; j++)\n-                    if (foo.methods[i].attributes.attrs[j] instanceof\n-                        MethodParameters_attribute)\n+            else if (foo.methods().get(i).methodName().equalsString(\"foo0\")) {\n+                for (int j = 0; j < foo.methods().get(i).attributes().size(); j++)\n+                    if (foo.methods().get(i).attributes().get(j) instanceof\n+                        MethodParametersAttribute)\n@@ -287,1 +257,1 @@\n-                error(\"Unknown method \" + foo.methods[i].getName(foo.constant_pool) + \" showed up in class Foo\");\n+                error(\"Unknown method \" + foo.methods().get(i).methodName() + \" showed up in class Foo\");\n@@ -294,10 +264,7 @@\n-        final ClassFile bar = ClassFile.read(Bar_class);\n-        for (int i = 0; i < bar.methods.length; i++) {\n-            System.err.println(\"Examine method Bar.\" + bar.methods[i].getName(bar.constant_pool));\n-            if (bar.methods[i].getName(bar.constant_pool).equals(\"<init>\")) {\n-                for (int j = 0; j < bar.methods[i].attributes.attrs.length; j++)\n-                    if (bar.methods[i].attributes.attrs[j] instanceof\n-                        MethodParameters_attribute) {\n-                        MethodParameters_attribute mp =\n-                            (MethodParameters_attribute)\n-                            bar.methods[i].attributes.attrs[j];\n+        final ClassModel bar = Classfile.of().parse(Bar_class.toPath());\n+        for (int i = 0; i < bar.methods().size(); i++) {\n+            System.err.println(\"Examine method Bar.\" + bar.methods().get(i).methodName());\n+            if (bar.methods().get(i).methodName().equalsString(\"<init>\")) {\n+                for (int j = 0; j < bar.methods().get(i).attributes().size(); j++)\n+                    if (bar.methods().get(i).attributes().get(j) instanceof\n+                        MethodParametersAttribute mp) {\n@@ -305,1 +272,1 @@\n-                        if (1 != mp.method_parameter_table_length)\n+                        if (1 != mp.parameters().size())\n@@ -307,2 +274,2 @@\n-                                  mp.method_parameter_table_length);\n-                        else if (!bar.constant_pool.getUTF8Value(mp.method_parameter_table[0].name_index).equals(\"i\"))\n+                                  mp.parameters().size());\n+                        else if (!mp.parameters().get(0).name().orElseThrow().equalsString(\"i\"))\n@@ -310,1 +277,1 @@\n-                                  bar.constant_pool.getUTF8Value(mp.method_parameter_table[0].name_index) +\n+                                  mp.parameters().get(0).name().orElseThrow() +\n@@ -314,4 +281,4 @@\n-            else if (bar.methods[i].getName(bar.constant_pool).equals(\"foo\")) {\n-                for (int j = 0; j < bar.methods[i].attributes.attrs.length; j++) {\n-                    if (bar.methods[i].attributes.attrs[j] instanceof\n-                        MethodParameters_attribute)\n+            else if (bar.methods().get(i).methodName().equalsString(\"foo\")) {\n+                for (int j = 0; j < bar.methods().get(i).attributes().size(); j++) {\n+                    if (bar.methods().get(i).attributes().get(j) instanceof\n+                        MethodParametersAttribute)\n","filename":"test\/langtools\/tools\/javac\/MethodParametersTest.java","additions":76,"deletions":109,"binary":false,"changes":185,"status":"modified"},{"patch":"@@ -28,1 +28,6 @@\n- * @modules jdk.jdeps\/com.sun.tools.classfile\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.classfile.instruction\n+ *          java.base\/jdk.internal.classfile.components\n+ *          java.base\/jdk.internal.classfile.impl\n@@ -34,2 +39,2 @@\n-import com.sun.tools.classfile.*;\n-import com.sun.tools.classfile.ConstantPool.CONSTANT_Methodref_info;\n+import jdk.internal.classfile.*;\n+import jdk.internal.classfile.constantpool.*;\n@@ -65,1 +70,1 @@\n-                \"com.sun.tools.classfile\",\n+                \"jdk.internal.classfile\",\n@@ -106,5 +111,5 @@\n-            ClassFile cf = ClassFile.read(in);\n-            for (ConstantPool.CPInfo cpinfo: cf.constant_pool.entries()) {\n-                if (cpinfo.getTag() == ConstantPool.CONSTANT_Methodref) {\n-                    CONSTANT_Methodref_info ref = (CONSTANT_Methodref_info) cpinfo;\n-                    String methodDesc = ref.getClassInfo().getName() + \".\" + ref.getNameAndTypeInfo().getName() + \":\" + ref.getNameAndTypeInfo().getType();\n+            ClassModel cf = Classfile.of().parse(in.readAllBytes());\n+            ConstantPool cp = cf.constantPool();\n+            for (int i = 1; i < cp.entryCount(); i += cp.entryByIndex(i).width()) {\n+                if (cp.entryByIndex(i) instanceof MethodRefEntry ref) {\n+                    String methodDesc = ref.owner().name().stringValue() + \".\" + ref.name().stringValue() + \":\" + ref.type().stringValue();\n","filename":"test\/langtools\/tools\/javac\/NoStringToLower.java","additions":14,"deletions":9,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -32,1 +32,6 @@\n- *          jdk.jdeps\/com.sun.tools.classfile\n+ *          java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.classfile.instruction\n+ *          java.base\/jdk.internal.classfile.components\n+ *          java.base\/jdk.internal.classfile.impl\n@@ -36,3 +41,3 @@\n-import com.sun.tools.classfile.ClassFile;\n-import com.sun.tools.classfile.ConstantPoolException;\n-import com.sun.tools.classfile.MethodParameters_attribute;\n+import jdk.internal.classfile.*;\n+import jdk.internal.classfile.attribute.MethodParameterInfo;\n+import jdk.internal.classfile.attribute.MethodParametersAttribute;\n@@ -53,0 +58,1 @@\n+import java.util.List;\n@@ -55,1 +61,1 @@\n-    private static final int CHECKED_FLAGS = Flags.MANDATED | Flags.SYNTHETIC;\n+    private static final int CHECKED_FLAGS = Classfile.ACC_MANDATED | Classfile.ACC_SYNTHETIC;\n@@ -124,1 +130,1 @@\n-    private ClassFile readClassFile(Path classes, Method method) {\n+    private ClassModel readClassFile(Path classes, Method method) {\n@@ -127,2 +133,2 @@\n-            return ClassFile.read(classes.resolve(\"Outer$\" + className + \".class\"));\n-        } catch (IOException | ConstantPoolException e) {\n+            return Classfile.of().parse(classes.resolve(\"Outer$\" + className + \".class\"));\n+        } catch (IOException e) {\n@@ -140,2 +146,2 @@\n-    public void testInnerClassConstructor(ClassFile classFile) {\n-        checkParameters(classFile.methods[0], Flags.MANDATED, 0);\n+    public void testInnerClassConstructor(ClassModel classFile) {\n+        checkParameters(classFile.methods().get(0), Classfile.ACC_MANDATED, 0);\n@@ -146,4 +152,4 @@\n-    public void testLocalClassConstructor(ClassFile classFile) throws ConstantPoolException {\n-        for (com.sun.tools.classfile.Method method : classFile.methods) {\n-            if (method.getName(classFile.constant_pool).equals(ConstantDescs.INIT_NAME)) {\n-                checkParameters(method, Flags.MANDATED, NO_FLAGS, Flags.SYNTHETIC);\n+    public void testLocalClassConstructor(ClassModel classFile) {\n+        for (MethodModel method : classFile.methods()) {\n+            if (method.methodName().equalsString(ConstantDescs.INIT_NAME)) {\n+                checkParameters(method, Classfile.ACC_MANDATED, NO_FLAGS, Classfile.ACC_SYNTHETIC);\n@@ -157,2 +163,2 @@\n-    public void testAnonymousClassExtendingInnerClassConstructor(ClassFile classFile) {\n-        checkParameters(classFile.methods[0], Flags.MANDATED, NO_FLAGS, NO_FLAGS);\n+    public void testAnonymousClassExtendingInnerClassConstructor(ClassModel classFile) {\n+        checkParameters(classFile.methods().get(0), Classfile.ACC_MANDATED, NO_FLAGS, NO_FLAGS);\n@@ -163,2 +169,2 @@\n-    public void testAnonymousClassConstructor(ClassFile classFile) {\n-        checkParameters(classFile.methods[0], Flags.MANDATED);\n+    public void testAnonymousClassConstructor(ClassModel classFile) {\n+        checkParameters(classFile.methods().get(0), Classfile.ACC_MANDATED);\n@@ -169,4 +175,4 @@\n-    public void testValueOfInEnum(ClassFile classFile) throws ConstantPoolException {\n-        for (com.sun.tools.classfile.Method method : classFile.methods) {\n-            if (method.getName(classFile.constant_pool).equals(\"valueOf\")) {\n-                checkParameters(method, Flags.MANDATED);\n+    public void testValueOfInEnum(ClassModel classFile) {\n+        for (MethodModel method : classFile.methods()) {\n+            if (method.methodName().equalsString(\"valueOf\")) {\n+                checkParameters(method, Classfile.ACC_MANDATED);\n@@ -180,4 +186,4 @@\n-    public void testEnumClassConstructor(ClassFile classFile) throws ConstantPoolException {\n-        for (com.sun.tools.classfile.Method method : classFile.methods) {\n-            if (method.getName(classFile.constant_pool).equals(ConstantDescs.INIT_NAME)) {\n-                checkParameters(method, Flags.SYNTHETIC, Flags.SYNTHETIC, NO_FLAGS, NO_FLAGS);\n+    public void testEnumClassConstructor(ClassModel classFile) {\n+        for (MethodModel method : classFile.methods()) {\n+            if (method.methodName().equalsString(ConstantDescs.INIT_NAME)) {\n+                checkParameters(method, Classfile.ACC_SYNTHETIC, Classfile.ACC_SYNTHETIC, NO_FLAGS, NO_FLAGS);\n@@ -191,2 +197,2 @@\n-    public void testCompactConstructor(ClassFile classFile) {\n-        checkParameters(classFile.methods[0], Flags.MANDATED, Flags.MANDATED);\n+    public void testCompactConstructor(ClassModel classFile) {\n+        checkParameters(classFile.methods().get(0), Classfile.ACC_MANDATED, Classfile.ACC_MANDATED);\n@@ -195,2 +201,2 @@\n-    private void checkParameters(com.sun.tools.classfile.Method method, int... parametersFlags) {\n-        MethodParameters_attribute methodParameters = (MethodParameters_attribute) method.attributes.get(\"MethodParameters\");\n+    private void checkParameters(MethodModel method, int... parametersFlags) {\n+        MethodParametersAttribute methodParameters = method.findAttribute(Attributes.METHOD_PARAMETERS).orElseThrow();\n@@ -198,5 +204,5 @@\n-        MethodParameters_attribute.Entry[] table = methodParameters.method_parameter_table;\n-        Assert.check(table.length == parametersFlags.length, () -> \"Expected \" + parametersFlags.length\n-                + \" MethodParameters entries, found \" + table.length);\n-        for (int i = 0; i < methodParameters.method_parameter_table_length; i++) {\n-            int foundFlags = table[i].flags & CHECKED_FLAGS;\n+        List<MethodParameterInfo> table = methodParameters.parameters();\n+        Assert.check(table.size() == parametersFlags.length, () -> \"Expected \" + parametersFlags.length\n+                + \" MethodParameters entries, found \" + table.size());\n+        for (int i = 0; i < methodParameters.parameters().size(); i++) {\n+            int foundFlags = table.get(i).flagsMask() & CHECKED_FLAGS;\n@@ -210,1 +216,1 @@\n-        return ((flags & Flags.MANDATED) == Flags.MANDATED) + \" and \" + ((flags & Flags.SYNTHETIC) == Flags.SYNTHETIC);\n+        return ((flags & Classfile.ACC_MANDATED) == Classfile.ACC_MANDATED) + \" and \" + ((flags & Classfile.ACC_SYNTHETIC) == Classfile.ACC_SYNTHETIC);\n","filename":"test\/langtools\/tools\/javac\/RequiredParameterFlags\/ImplicitParameters.java","additions":42,"deletions":36,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -24,4 +24,5 @@\n-import com.sun.tools.classfile.*;\n-import com.sun.tools.classfile.BootstrapMethods_attribute.BootstrapMethodSpecifier;\n-import com.sun.tools.classfile.ConstantPool.CONSTANT_InvokeDynamic_info;\n-import com.sun.tools.classfile.ConstantPool.CONSTANT_MethodHandle_info;\n+import jdk.internal.classfile.*;\n+import jdk.internal.classfile.attribute.*;\n+import jdk.internal.classfile.constantpool.InvokeDynamicEntry;\n+import jdk.internal.classfile.constantpool.MethodHandleEntry;\n+import jdk.internal.classfile.instruction.InvokeDynamicInstruction;\n@@ -35,1 +36,6 @@\n- * @modules jdk.jdeps\/com.sun.tools.classfile\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.classfile.instruction\n+ *          java.base\/jdk.internal.classfile.components\n+ *          java.base\/jdk.internal.classfile.impl\n@@ -62,1 +68,1 @@\n-        boolean expected = Boolean.valueOf(args[0]);\n+        boolean expected = Boolean.parseBoolean(args[0]);\n@@ -70,3 +76,2 @@\n-        ClassFile classFile = ClassFile.read(new File(System.getProperty(\"test.classes\", \".\"),\n-                TestIndyStringConcat.class.getName() + \".class\"));\n-        ConstantPool constantPool = classFile.constant_pool;\n+        ClassModel classFile = Classfile.of().parse(new File(System.getProperty(\"test.classes\", \".\"),\n+                TestIndyStringConcat.class.getName() + \".class\").toPath());\n@@ -74,20 +79,9 @@\n-        BootstrapMethods_attribute bsm_attr =\n-                (BootstrapMethods_attribute)classFile\n-                        .getAttribute(Attribute.BootstrapMethods);\n-\n-        for (Method method : classFile.methods) {\n-            if (method.getName(constantPool).equals(methodName)) {\n-                Code_attribute code = (Code_attribute) method.attributes\n-                        .get(Attribute.Code);\n-                for (Instruction i : code.getInstructions()) {\n-                    if (i.getOpcode() == Opcode.INVOKEDYNAMIC) {\n-                        CONSTANT_InvokeDynamic_info indyInfo =\n-                                (CONSTANT_InvokeDynamic_info) constantPool.get(i.getUnsignedShort(1));\n-\n-                        BootstrapMethodSpecifier bsmSpec =\n-                                bsm_attr.bootstrap_method_specifiers[indyInfo.bootstrap_method_attr_index];\n-\n-                        CONSTANT_MethodHandle_info bsmInfo =\n-                                (CONSTANT_MethodHandle_info) constantPool.get(bsmSpec.bootstrap_method_ref);\n-\n-                        if (bsmInfo.getCPRefInfo().getClassName().equals(\"java\/lang\/invoke\/StringConcatFactory\")) {\n+        for (MethodModel method : classFile.methods()) {\n+            if (method.methodName().equalsString(methodName)) {\n+                CodeAttribute code = method.findAttribute(Attributes.CODE).orElseThrow();\n+                for (CodeElement i : code.elementList()) {\n+                    if (i instanceof InvokeDynamicInstruction) {\n+                        InvokeDynamicInstruction indy = (InvokeDynamicInstruction) i;\n+                        BootstrapMethodEntry bsmSpec = indy.invokedynamic().bootstrap();\n+                        MethodHandleEntry bsmInfo = bsmSpec.bootstrapMethod();\n+                        if (bsmInfo.reference().owner().asInternalName().equals(\"java\/lang\/invoke\/StringConcatFactory\")) {\n","filename":"test\/langtools\/tools\/javac\/StringConcat\/TestIndyStringConcat.java","additions":23,"deletions":29,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -24,2 +24,4 @@\n-import com.sun.tools.classfile.*;\n-import com.sun.tools.classfile.ConstantPool.*;\n+import jdk.internal.classfile.*;\n+import jdk.internal.classfile.attribute.CodeAttribute;\n+import jdk.internal.classfile.constantpool.NameAndTypeEntry;\n+import jdk.internal.classfile.instruction.InvokeDynamicInstruction;\n@@ -35,1 +37,6 @@\n- * @modules jdk.jdeps\/com.sun.tools.classfile\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.classfile.instruction\n+ *          java.base\/jdk.internal.classfile.components\n+ *          java.base\/jdk.internal.classfile.impl\n@@ -97,2 +104,1 @@\n-        ClassFile classFile =\n-                ClassFile.read(\n+        ClassModel classFile = Classfile.of().parse(\n@@ -101,2 +107,1 @@\n-                                WellKnownTypeSignatures.class.getName() + \".class\"));\n-        ConstantPool constantPool = classFile.constant_pool;\n+                                WellKnownTypeSignatures.class.getName() + \".class\").toPath());\n@@ -104,10 +109,8 @@\n-        for (Method method : classFile.methods) {\n-            if (method.getName(constantPool).equals(\"main\")) {\n-                Code_attribute code = (Code_attribute) method.attributes.get(Attribute.Code);\n-                for (Instruction i : code.getInstructions()) {\n-                    if (i.getOpcode() == Opcode.INVOKEDYNAMIC) {\n-                        CONSTANT_InvokeDynamic_info indyInfo =\n-                                (CONSTANT_InvokeDynamic_info)\n-                                        constantPool.get(i.getUnsignedShort(1));\n-                        CONSTANT_NameAndType_info natInfo = indyInfo.getNameAndTypeInfo();\n-                        actualTypes.add(natInfo.getType());\n+        for (MethodModel method : classFile.methods()) {\n+            if (method.methodName().equalsString(\"main\")) {\n+                CodeAttribute code = method.findAttribute(Attributes.CODE).orElseThrow();\n+                for (CodeElement i : code.elementList()) {\n+                    if (i instanceof InvokeDynamicInstruction) {\n+                        InvokeDynamicInstruction indy = (InvokeDynamicInstruction) i;\n+                        NameAndTypeEntry natInfo = indy.invokedynamic().nameAndType();\n+                        actualTypes.add(natInfo.type().stringValue());\n","filename":"test\/langtools\/tools\/javac\/StringConcat\/WellKnownTypeSignatures.java","additions":20,"deletions":17,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -24,2 +24,4 @@\n-import com.sun.tools.classfile.*;\n-import com.sun.tools.classfile.ConstantPool.*;\n+import jdk.internal.classfile.*;\n+import jdk.internal.classfile.attribute.CodeAttribute;\n+import jdk.internal.classfile.constantpool.*;\n+import jdk.internal.classfile.instruction.InvokeDynamicInstruction;\n@@ -35,1 +37,5 @@\n- * @modules jdk.jdeps\/com.sun.tools.classfile\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.classfile.instruction\n+ *          java.base\/jdk.internal.classfile.components\n@@ -178,13 +184,11 @@\n-        ClassFile classFile = ClassFile.read(new File(System.getProperty(\"test.classes\", \".\"),\n-                    Test.class.getName() + \".class\"));\n-        ConstantPool constantPool = classFile.constant_pool;\n-\n-        for (Method method : classFile.methods) {\n-            if (method.getName(constantPool).equals(\"main\")) {\n-                Code_attribute code = (Code_attribute) method.attributes\n-                        .get(Attribute.Code);\n-                for (Instruction i : code.getInstructions()) {\n-                    if (i.getOpcode() == Opcode.INVOKEDYNAMIC) {\n-                        CONSTANT_InvokeDynamic_info indyInfo = (CONSTANT_InvokeDynamic_info) constantPool.get(i.getUnsignedShort(1));\n-                        CONSTANT_NameAndType_info natInfo = indyInfo.getNameAndTypeInfo();\n-                        actualTypes.add(natInfo.getType());\n+        ClassModel classFile = Classfile.of().parse(new File(System.getProperty(\"test.classes\", \".\"),\n+                    Test.class.getName() + \".class\").toPath());\n+\n+        for (MethodModel method : classFile.methods()) {\n+            if (method.methodName().equalsString(\"main\")) {\n+                CodeAttribute code = method.findAttribute(Attributes.CODE).orElseThrow();\n+                for (CodeElement i : code.elementList()) {\n+                    if (i instanceof InvokeDynamicInstruction) {\n+                        InvokeDynamicEntry indyInfo = ((InvokeDynamicInstruction) i).invokedynamic();\n+                        NameAndTypeEntry natInfo = indyInfo.nameAndType();\n+                        actualTypes.add(natInfo.type().stringValue());\n","filename":"test\/langtools\/tools\/javac\/StringConcat\/access\/Test.java","additions":20,"deletions":16,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -29,1 +29,6 @@\n- * @modules jdk.jdeps\/com.sun.tools.classfile\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.classfile.instruction\n+ *          java.base\/jdk.internal.classfile.components\n+ *          java.base\/jdk.internal.classfile.impl\n@@ -43,5 +48,2 @@\n-import com.sun.tools.classfile.AccessFlags;\n-import com.sun.tools.classfile.Attribute;\n-import com.sun.tools.classfile.Attributes;\n-import com.sun.tools.classfile.ClassFile;\n-import com.sun.tools.classfile.Method;\n+import jdk.internal.classfile.*;\n+import jdk.internal.classfile.attribute.*;\n@@ -64,9 +66,8 @@\n-    void checkClassFile(final Path cfilePath) throws Exception {\n-        ClassFile classFile = ClassFile.read(\n-                new BufferedInputStream(Files.newInputStream(cfilePath)));\n-        for (Method method : classFile.methods) {\n-            if (method.access_flags.is(AccessFlags.ACC_BRIDGE)) {\n-                checkForAttr(method.attributes,\n-                        \"Annotations hasn't been copied to bridge method\",\n-                        Attribute.RuntimeVisibleAnnotations,\n-                        Attribute.RuntimeVisibleParameterAnnotations);\n+    <A extends Attribute<A>> void checkClassFile(final Path cfilePath) throws Exception {\n+        ClassModel classFile = Classfile.of().parse(cfilePath);\n+        for (MethodModel method : classFile.methods()) {\n+            if ((method.flags().flagsMask() & Classfile.ACC_BRIDGE) != 0) {\n+                Assert.checkNonNull(method.findAttribute(Attributes.RUNTIME_VISIBLE_ANNOTATIONS),\n+                        \"Annotations hasn't been copied to bridge method\");\n+                Assert.checkNonNull(method.findAttribute(Attributes.RUNTIME_VISIBLE_PARAMETER_ANNOTATIONS),\n+                        \"Annotations hasn't been copied to bridge method\");\n@@ -77,6 +78,0 @@\n-    void checkForAttr(Attributes attrs, String errorMsg, String... attrNames) {\n-        for (String attrName : attrNames) {\n-            Assert.checkNonNull(attrs.get(attrName), errorMsg);\n-        }\n-    }\n-\n","filename":"test\/langtools\/tools\/javac\/T6695379\/AnnotationsAreNotCopiedToBridgeMethodsTest.java","additions":16,"deletions":21,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -29,1 +29,6 @@\n- * @modules jdk.jdeps\/com.sun.tools.classfile\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.classfile.instruction\n+ *          java.base\/jdk.internal.classfile.components\n+ *          java.base\/jdk.internal.classfile.impl\n@@ -41,4 +46,2 @@\n-import com.sun.tools.classfile.ClassFile;\n-import com.sun.tools.classfile.Code_attribute;\n-import com.sun.tools.classfile.LineNumberTable_attribute;\n-import com.sun.tools.classfile.Method;\n+import jdk.internal.classfile.*;\n+import jdk.internal.classfile.attribute.*;\n@@ -93,1 +96,1 @@\n-        ClassFile classFile = ClassFile.read(cfile);\n+        ClassModel classFile = Classfile.of().parse(cfile.toPath());\n@@ -95,2 +98,2 @@\n-        for (Method method : classFile.methods) {\n-            if (method.getName(classFile.constant_pool).equals(methodToFind)) {\n+        for (MethodModel m : classFile.methods()) {\n+            if (m.methodName().equalsString(methodToFind)) {\n@@ -98,4 +101,3 @@\n-                Code_attribute code = (Code_attribute) method.attributes.get(\"Code\");\n-                LineNumberTable_attribute lnt =\n-                        (LineNumberTable_attribute) code.attributes.get(\"LineNumberTable\");\n-                Assert.check(lnt.line_number_table_length == expectedLNT.length,\n+                CodeAttribute code = m.findAttribute(Attributes.CODE).orElseThrow();\n+                LineNumberTableAttribute lnt = code.findAttribute(Attributes.LINE_NUMBER_TABLE).orElseThrow();\n+                Assert.check(lnt.lineNumbers().size() == expectedLNT.length,\n@@ -104,3 +106,3 @@\n-                for (LineNumberTable_attribute.Entry entry: lnt.line_number_table) {\n-                    Assert.check(entry.line_number == expectedLNT[i][0] &&\n-                            entry.start_pc == expectedLNT[i][1],\n+                for (LineNumberInfo entry: lnt.lineNumbers()) {\n+                    Assert.check(entry.lineNumber() == expectedLNT[i][0] &&\n+                            entry.startPc() == expectedLNT[i][1],\n@@ -108,1 +110,1 @@\n-                            \"Found \" + entry.line_number + \":\" + entry.start_pc +\n+                            \"Found \" + entry.lineNumber() + \":\" + entry.startPc() +\n","filename":"test\/langtools\/tools\/javac\/T6970173\/DebugPointerAtBadPositionTest.java","additions":18,"deletions":16,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -29,1 +29,6 @@\n- * @modules jdk.jdeps\/com.sun.tools.classfile\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.classfile.instruction\n+ *          java.base\/jdk.internal.classfile.components\n+ *          java.base\/jdk.internal.classfile.impl\n@@ -41,4 +46,2 @@\n-import com.sun.tools.classfile.ClassFile;\n-import com.sun.tools.classfile.Code_attribute;\n-import com.sun.tools.classfile.LineNumberTable_attribute;\n-import com.sun.tools.classfile.Method;\n+import jdk.internal.classfile.*;\n+import jdk.internal.classfile.attribute.*;\n@@ -100,1 +103,1 @@\n-        ClassFile classFile = ClassFile.read(cfile);\n+        ClassModel classFile = Classfile.of().parse(cfile.toPath());\n@@ -102,2 +105,2 @@\n-        for (Method method : classFile.methods) {\n-            if (method.getName(classFile.constant_pool).equals(methodToFind)) {\n+        for (MethodModel m : classFile.methods()) {\n+            if (m.methodName().equalsString(methodToFind)) {\n@@ -105,4 +108,3 @@\n-                Code_attribute code = (Code_attribute) method.attributes.get(\"Code\");\n-                LineNumberTable_attribute lnt =\n-                        (LineNumberTable_attribute) code.attributes.get(\"LineNumberTable\");\n-                Assert.check(lnt.line_number_table_length == expectedLNT.length,\n+                CodeAttribute code = m.findAttribute(Attributes.CODE).orElseThrow();\n+                LineNumberTableAttribute lnt = code.findAttribute(Attributes.LINE_NUMBER_TABLE).orElseThrow();\n+                Assert.check(lnt.lineNumbers().size() == expectedLNT.length,\n@@ -111,3 +113,3 @@\n-                for (LineNumberTable_attribute.Entry entry: lnt.line_number_table) {\n-                    Assert.check(entry.line_number == expectedLNT[i][0] &&\n-                            entry.start_pc == expectedLNT[i][1],\n+                for (LineNumberInfo entry: lnt.lineNumbers()) {\n+                    Assert.check(entry.lineNumber() == expectedLNT[i][0] &&\n+                            entry.startPc() == expectedLNT[i][1],\n@@ -115,1 +117,1 @@\n-                            \"Found \" + entry.line_number + \":\" + entry.start_pc +\n+                            \"Found \" + entry.lineNumber() + \":\" + entry.startPc() +\n","filename":"test\/langtools\/tools\/javac\/T7008643\/InlinedFinallyConfuseDebuggersTest.java","additions":18,"deletions":16,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -28,1 +28,6 @@\n- * @modules jdk.jdeps\/com.sun.tools.classfile\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.classfile.instruction\n+ *          java.base\/jdk.internal.classfile.components\n+ *          java.base\/jdk.internal.classfile.impl\n@@ -35,1 +40,5 @@\n-import com.sun.tools.classfile.*;\n+import java.util.Objects;\n+import jdk.internal.classfile.*;\n+import jdk.internal.classfile.attribute.CodeAttribute;\n+import jdk.internal.classfile.constantpool.ClassEntry;\n+import jdk.internal.classfile.instruction.TypeCheckInstruction;\n@@ -58,2 +67,2 @@\n-        ClassFile cls = ClassFile.read(DoubleCastTest.class.getResourceAsStream(\"DoubleCastTest$C.class\"));\n-        for (Method m: cls.methods)\n+        ClassModel cls = Classfile.of().parse(Objects.requireNonNull(DoubleCastTest.class.getResourceAsStream(\"DoubleCastTest$C.class\")).readAllBytes());\n+        for (MethodModel m: cls.methods())\n@@ -63,1 +72,1 @@\n-    static void check(Method m) throws Exception {\n+    static void check(MethodModel m) throws Exception {\n@@ -65,4 +74,5 @@\n-        int last_ref = 0;\n-        Code_attribute ea = (Code_attribute)m.attributes.get(Attribute.Code);\n-        for (Instruction i : ea.getInstructions()) {\n-            if (i.getOpcode() == Opcode.CHECKCAST) {\n+        ClassEntry last_ref = null;\n+        CodeAttribute ea = m.findAttribute(Attributes.CODE).orElseThrow();\n+        for (int i = 0; i < ea.elementList().size(); ++i) {\n+            CodeElement ce = ea.elementList().get(i);\n+            if (ce instanceof TypeCheckInstruction ins && ins.opcode() == Opcode.CHECKCAST) {\n@@ -70,1 +80,1 @@\n-                    (!(last_is_cast && last_ref == i.getUnsignedShort(1)),\n+                    (!(last_is_cast && last_ref == ins.type()),\n@@ -73,1 +83,1 @@\n-                last_ref = i.getUnsignedShort(1);\n+                last_ref = ins.type();\n","filename":"test\/langtools\/tools\/javac\/T7053059\/DoubleCastTest.java","additions":21,"deletions":11,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -30,1 +30,6 @@\n- * @modules jdk.jdeps\/com.sun.tools.classfile\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.classfile.instruction\n+ *          java.base\/jdk.internal.classfile.components\n+ *          java.base\/jdk.internal.classfile.impl\n@@ -41,5 +46,3 @@\n-import com.sun.tools.classfile.Attribute;\n-import com.sun.tools.classfile.ClassFile;\n-import com.sun.tools.classfile.Code_attribute;\n-import com.sun.tools.classfile.ConstantPoolException;\n-import com.sun.tools.classfile.Method;\n+import jdk.internal.classfile.*;\n+import jdk.internal.classfile.attribute.CodeAttribute;\n+import jdk.internal.classfile.constantpool.ClassEntry;\n@@ -152,1 +155,1 @@\n-            ClassFile cf = ClassFile.read(is);\n+            ClassModel cf = Classfile.of().parse(is.readAllBytes());\n@@ -158,3 +161,3 @@\n-            Method test_method = null;\n-            for (Method m : cf.methods) {\n-                if (m.getName(cf.constant_pool).equals(\"test\")) {\n+            MethodModel test_method = null;\n+            for (MethodModel m : cf.methods()) {\n+                if (m.methodName().equalsString(\"test\")) {\n@@ -171,7 +174,1 @@\n-            Code_attribute code = null;\n-            for (Attribute a : test_method.attributes) {\n-                if (a.getName(cf.constant_pool).equals(Attribute.Code)) {\n-                    code = (Code_attribute)a;\n-                    break;\n-                }\n-            }\n+            CodeAttribute code = test_method.findAttribute(Attributes.CODE).orElse(null);\n@@ -185,3 +182,3 @@\n-            for (int i = 0; i < code.exception_table_length ; i++) {\n-                int catchType = code.exception_table[i].catch_type;\n-                if (catchType == 0) { \/\/any\n+            for (int i = 0; i < code.exceptionHandlers().size() ; i++) {\n+                ClassEntry catchType = code.exceptionHandlers().get(i).catchType().orElse(null);\n+                if (catchType == null) { \/\/any\n@@ -197,1 +194,0 @@\n-                return;\n@@ -199,1 +195,1 @@\n-        } catch (IOException | ConstantPoolException e) {\n+        } catch (IOException e) {\n","filename":"test\/langtools\/tools\/javac\/T7093325.java","additions":18,"deletions":22,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -28,1 +28,6 @@\n- * @modules jdk.jdeps\/com.sun.tools.classfile\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.classfile.instruction\n+ *          java.base\/jdk.internal.classfile.components\n+ *          java.base\/jdk.internal.classfile.impl\n@@ -33,0 +38,1 @@\n+import jdk.internal.classfile.*;\n@@ -53,5 +59,0 @@\n-import com.sun.tools.classfile.ClassFile;\n-import com.sun.tools.classfile.ConstantPoolException;\n-import com.sun.tools.classfile.Descriptor;\n-import com.sun.tools.classfile.Descriptor.InvalidDescriptor;\n-import com.sun.tools.classfile.Field;\n@@ -61,3 +62,0 @@\n-import static com.sun.tools.classfile.AccessFlags.ACC_ENUM;\n-import static com.sun.tools.classfile.AccessFlags.ACC_FINAL;\n-import static com.sun.tools.classfile.AccessFlags.ACC_STATIC;\n@@ -78,1 +76,6 @@\n-        \"com.sun.tools.classfile\",\n+        \"jdk.internal.classfile\",\n+        \"jdk.internal.classfile.attribute\",\n+        \"jdk.internal.classfile.constantpool\",\n+        \"jdk.internal.classfile.instruction\",\n+        \"jdk.internal.classfile.components\",\n+        \"jdk.internal.classfile.impl\",\n@@ -93,1 +96,0 @@\n-        ignore(\"com\/sun\/tools\/classfile\/Dependencies$DefaultFilter\", \"instance\");\n@@ -135,6 +137,1 @@\n-    private void run()\n-        throws\n-            IOException,\n-            ConstantPoolException,\n-            InvalidDescriptor,\n-            URISyntaxException {\n+    private void run() throws IOException {\n@@ -167,5 +164,1 @@\n-    void analyzeModule(StandardJavaFileManager fm, String moduleName)\n-        throws\n-            IOException,\n-            ConstantPoolException,\n-            InvalidDescriptor {\n+    void analyzeModule(StandardJavaFileManager fm, String moduleName) throws IOException {\n@@ -182,1 +175,1 @@\n-                ClassFile classFile;\n+                ClassModel classFile;\n@@ -184,1 +177,1 @@\n-                    classFile = ClassFile.read(input);\n+                    classFile = Classfile.of().parse(input.readAllBytes());\n@@ -204,5 +197,1 @@\n-    void analyzeClassFile(ClassFile classFileToCheck)\n-        throws\n-            IOException,\n-            ConstantPoolException,\n-            Descriptor.InvalidDescriptor {\n+    void analyzeClassFile(ClassModel classFileToCheck) {\n@@ -210,1 +199,1 @@\n-                (classFileToCheck.access_flags.flags & ACC_ENUM) != 0;\n+                (classFileToCheck.flags().flagsMask() & Classfile.ACC_ENUM) != 0;\n@@ -215,1 +204,1 @@\n-                classFieldsToIgnoreMap.get(classFileToCheck.getName());\n+                classFieldsToIgnoreMap.get(classFileToCheck.thisClass().asInternalName());\n@@ -217,2 +206,2 @@\n-        for (Field field : classFileToCheck.fields) {\n-            if (ignoreField(field.getName(classFileToCheck.constant_pool))) {\n+        for (FieldModel field : classFileToCheck.fields()) {\n+            if (ignoreField(field.fieldName().stringValue())) {\n@@ -222,1 +211,1 @@\n-                    (field.access_flags.flags & (ACC_ENUM | ACC_FINAL)) == 0;\n+                    (field.flags().flagsMask() & (Classfile.ACC_ENUM | Classfile.ACC_FINAL)) == 0;\n@@ -224,2 +213,2 @@\n-                    (field.access_flags.flags & ACC_STATIC) != 0 &&\n-                    (field.access_flags.flags & ACC_FINAL) == 0;\n+                    (field.flags().flagsMask() & Classfile.ACC_STATIC) != 0 &&\n+                    (field.flags().flagsMask() & Classfile.ACC_FINAL) == 0;\n@@ -228,1 +217,1 @@\n-                        field.getName(classFileToCheck.constant_pool) +\n+                        field.fieldName().stringValue() +\n@@ -230,1 +219,1 @@\n-                        classFileToCheck.getName());\n+                        classFileToCheck.thisClass().asInternalName());\n","filename":"test\/langtools\/tools\/javac\/T8003967\/DetectMutableStaticFields.java","additions":27,"deletions":38,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -29,1 +29,6 @@\n- * @modules jdk.jdeps\/com.sun.tools.classfile\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.classfile.instruction\n+ *          java.base\/jdk.internal.classfile.components\n+ *          java.base\/jdk.internal.classfile.impl\n@@ -54,2 +59,0 @@\n-import com.sun.tools.classfile.ClassFile;\n-import com.sun.tools.classfile.Method;\n@@ -66,0 +69,1 @@\n+import jdk.internal.classfile.*;\n@@ -115,1 +119,1 @@\n-        ClassFile classFile = ClassFile.read(cfile);\n+        ClassModel classFile = Classfile.of().parse(cfile.toPath());\n@@ -117,2 +121,2 @@\n-        for (Method method : classFile.methods) {\n-            if (method.getName(classFile.constant_pool).equals(\"<init>\")) {\n+        for (MethodModel method : classFile.methods()) {\n+            if (method.methodName().equalsString(\"<init>\")) {\n@@ -146,2 +150,6 @@\n-                \"--add-modules\", \"jdk.jdeps\",\n-                \"--add-exports\", \"jdk.jdeps\/com.sun.tools.classfile=ALL-UNNAMED\",\n+                \"--add-exports\", \"java.base\/jdk.internal.classfile=ALL-UNNAMED\",\n+                \"--add-exports\", \"java.base\/jdk.internal.classfile.attribute=ALL-UNNAMED\",\n+                \"--add-exports\", \"java.base\/jdk.internal.classfile.constantpool=ALL-UNNAMED\",\n+                \"--add-exports\", \"java.base\/jdk.internal.classfile.instruction=ALL-UNNAMED\",\n+                \"--add-exports\", \"java.base\/jdk.internal.classfile.components=ALL-UNNAMED\",\n+                \"--add-exports\", \"java.base\/jdk.internal.classfile.impl=ALL-UNNAMED\",\n","filename":"test\/langtools\/tools\/javac\/T8010737\/ParameterNamesAreNotCopiedToAnonymousInitTest.java","additions":16,"deletions":8,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -32,1 +32,6 @@\n- *          jdk.jdeps\/com.sun.tools.classfile\n+ *          java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.classfile.instruction\n+ *          java.base\/jdk.internal.classfile.components\n+ *          java.base\/jdk.internal.classfile.impl\n@@ -40,4 +45,0 @@\n-import com.sun.tools.classfile.ClassFile;\n-import com.sun.tools.classfile.Code_attribute;\n-import com.sun.tools.classfile.LineNumberTable_attribute;\n-import com.sun.tools.classfile.Method;\n@@ -46,0 +47,2 @@\n+import jdk.internal.classfile.*;\n+import jdk.internal.classfile.attribute.*;\n@@ -162,1 +165,1 @@\n-        ClassFile classFile = ClassFile.read(cfile);\n+        ClassModel classFile = Classfile.of().parse(cfile.toPath());\n@@ -164,2 +167,2 @@\n-        for (Method method : classFile.methods) {\n-            if (method.getName(classFile.constant_pool).equals(methodToFind)) {\n+        for (MethodModel method : classFile.methods()) {\n+            if (method.methodName().equalsString(methodToFind)) {\n@@ -167,4 +170,3 @@\n-                Code_attribute code = (Code_attribute) method.attributes.get(\"Code\");\n-                LineNumberTable_attribute lnt =\n-                        (LineNumberTable_attribute) code.attributes.get(\"LineNumberTable\");\n-                Assert.check(lnt.line_number_table_length == expectedLNT.length,\n+                CodeAttribute code = method.findAttribute(Attributes.CODE).orElseThrow();\n+                LineNumberTableAttribute lnt = code.findAttribute(Attributes.LINE_NUMBER_TABLE).orElseThrow();\n+                Assert.check(lnt.lineNumbers().size() == expectedLNT.length,\n@@ -173,3 +175,3 @@\n-                for (LineNumberTable_attribute.Entry entry: lnt.line_number_table) {\n-                    Assert.check(entry.line_number == expectedLNT[i][0] &&\n-                            entry.start_pc == expectedLNT[i][1],\n+                for (LineNumberInfo entry: lnt.lineNumbers()) {\n+                    Assert.check(entry.lineNumber() == expectedLNT[i][0] &&\n+                            entry.startPc() == expectedLNT[i][1],\n@@ -177,1 +179,1 @@\n-                            \"Found \" + entry.line_number + \":\" + entry.start_pc +\n+                            \"Found \" + entry.lineNumber() + \":\" + entry.startPc() +\n","filename":"test\/langtools\/tools\/javac\/T8019486\/WrongLNTForLambdaTest.java","additions":18,"deletions":16,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -28,1 +28,6 @@\n- * @modules jdk.jdeps\/com.sun.tools.classfile\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.classfile.instruction\n+ *          java.base\/jdk.internal.classfile.components\n+ *          java.base\/jdk.internal.classfile.impl\n@@ -32,11 +37,4 @@\n-import com.sun.tools.classfile.Attribute;\n-import com.sun.tools.classfile.ClassFile;\n-import com.sun.tools.classfile.Code_attribute;\n-import com.sun.tools.classfile.ConstantPool;\n-import com.sun.tools.classfile.ConstantPool.CONSTANT_String_info;\n-import com.sun.tools.classfile.ConstantPool.CPInfo;\n-import com.sun.tools.classfile.ConstantPool.InvalidIndex;\n-import com.sun.tools.classfile.Instruction;\n-import com.sun.tools.classfile.Instruction.KindVisitor;\n-import com.sun.tools.classfile.Instruction.TypeKind;\n-import com.sun.tools.classfile.Method;\n+import jdk.internal.classfile.*;\n+import jdk.internal.classfile.attribute.CodeAttribute;\n+import jdk.internal.classfile.constantpool.*;\n+import jdk.internal.classfile.instruction.InvokeInstruction;\n@@ -68,10 +66,9 @@\n-        ClassFile classFile = ClassFile.read(\n-                new BufferedInputStream(Files.newInputStream(path)));\n-        constantPool = classFile.constant_pool;\n-        utf8Index = constantPool.getUTF8Index(\"STR_TO_LOOK_FOR\");\n-        for (Method method: classFile.methods) {\n-            if (method.getName(constantPool).equals(\"methodToLookFor\")) {\n-                Code_attribute codeAtt = (Code_attribute)method.attributes.get(Attribute.Code);\n-                for (Instruction inst: codeAtt.getInstructions()) {\n-                    inst.accept(codeVisitor, null);\n-                }\n+        ClassModel classFile = Classfile.of().parse(\n+                new BufferedInputStream(Files.newInputStream(path)).readAllBytes());\n+        constantPool = classFile.constantPool();\n+        for (MethodModel method: classFile.methods()) {\n+            if (method.methodName().equalsString(\"methodToLookFor\")) {\n+                CodeAttribute codeAtt = method.findAttribute(Attributes.CODE).orElseThrow();\n+                codeAtt.elementList().stream()\n+                        .filter(ce -> ce instanceof Instruction)\n+                        .forEach(ins -> checkIndirectRefToString((Instruction) ins));\n@@ -83,16 +80,5 @@\n-\n-    CodeVisitor codeVisitor = new CodeVisitor();\n-\n-    class CodeVisitor implements KindVisitor<Void, Void> {\n-\n-        void checkIndirectRefToString(int cp_index) {\n-            try {\n-                CPInfo cInfo = constantPool.get(cp_index);\n-                if (cInfo instanceof CONSTANT_String_info) {\n-                    CONSTANT_String_info strInfo = (CONSTANT_String_info)cInfo;\n-                    if (strInfo.string_index == utf8Index) {\n-                        numberOfRefToStr++;\n-                    }\n-                }\n-            } catch (InvalidIndex ex) {\n-                throw new AssertionError(\"invalid constant pool index at \" + cp_index);\n+    void checkIndirectRefToString(Instruction instruction) {\n+        if (instruction instanceof InvokeInstruction invokeInstruction) {\n+            MemberRefEntry refEntry = invokeInstruction.method();\n+            if (constantPool.entryByIndex(refEntry.type().index()) instanceof Utf8Entry) {\n+                numberOfRefToStr++;\n@@ -101,58 +87,0 @@\n-\n-        @Override\n-        public Void visitNoOperands(Instruction instr, Void p) {\n-            return null;\n-        }\n-\n-        @Override\n-        public Void visitArrayType(Instruction instr, TypeKind kind, Void p) {\n-            return null;\n-        }\n-\n-        @Override\n-        public Void visitBranch(Instruction instr, int offset, Void p) {\n-            return null;\n-        }\n-\n-        @Override\n-        public Void visitConstantPoolRef(Instruction instr, int index, Void p) {\n-            checkIndirectRefToString(index);\n-            return null;\n-        }\n-\n-        @Override\n-        public Void visitConstantPoolRefAndValue(Instruction instr, int index, int value, Void p) {\n-            checkIndirectRefToString(index);\n-            return null;\n-        }\n-\n-        @Override\n-        public Void visitLocal(Instruction instr, int index, Void p) {\n-            return null;\n-        }\n-\n-        @Override\n-        public Void visitLocalAndValue(Instruction instr, int index, int value, Void p) {\n-            return null;\n-        }\n-\n-        @Override\n-        public Void visitLookupSwitch(Instruction instr, int default_, int npairs, int[] matches, int[] offsets, Void p) {\n-            return null;\n-        }\n-\n-        @Override\n-        public Void visitTableSwitch(Instruction instr, int default_, int low, int high, int[] offsets, Void p) {\n-            return null;\n-        }\n-\n-        @Override\n-        public Void visitValue(Instruction instr, int value, Void p) {\n-            return null;\n-        }\n-\n-        @Override\n-        public Void visitUnknown(Instruction instr, Void p) {\n-            return null;\n-        }\n-\n","filename":"test\/langtools\/tools\/javac\/T8022186\/DeadCodeGeneratedForEmptyTryTest.java","additions":24,"deletions":96,"binary":false,"changes":120,"status":"modified"},{"patch":"@@ -32,1 +32,6 @@\n- *          jdk.jdeps\/com.sun.tools.classfile\n+ *          java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.classfile.instruction\n+ *          java.base\/jdk.internal.classfile.components\n+ *          java.base\/jdk.internal.classfile.impl\n@@ -40,4 +45,0 @@\n-import com.sun.tools.classfile.ClassFile;\n-import com.sun.tools.classfile.Code_attribute;\n-import com.sun.tools.classfile.Code_attribute.Exception_data;\n-import com.sun.tools.classfile.Method;\n@@ -46,0 +47,3 @@\n+import jdk.internal.classfile.*;\n+import jdk.internal.classfile.attribute.CodeAttribute;\n+import jdk.internal.classfile.instruction.ExceptionCatch;\n@@ -103,1 +107,1 @@\n-        ClassFile classFile = ClassFile.read(cfile);\n+        ClassModel classFile = Classfile.of().parse(cfile.toPath());\n@@ -106,2 +110,2 @@\n-            for (Method method : classFile.methods) {\n-                if (method.getName(classFile.constant_pool).equals(methodToFind)) {\n+            for (MethodModel m : classFile.methods()) {\n+                if (m.methodName().equalsString(methodToFind)) {\n@@ -109,2 +113,2 @@\n-                    Code_attribute code = (Code_attribute) method.attributes.get(\"Code\");\n-                    Assert.check(code.exception_table_length == expectedExceptionTable.length,\n+                    CodeAttribute code = m.findAttribute(Attributes.CODE).orElseThrow();\n+                    Assert.check(code.exceptionHandlers().size() == expectedExceptionTable.length,\n@@ -113,5 +117,5 @@\n-                    for (Exception_data entry: code.exception_table) {\n-                        Assert.check(entry.start_pc == expectedExceptionTable[i][0] &&\n-                                entry.end_pc == expectedExceptionTable[i][1] &&\n-                                entry.handler_pc == expectedExceptionTable[i][2] &&\n-                                entry.catch_type == expectedExceptionTable[i][3],\n+                    for (ExceptionCatch entry: code.exceptionHandlers()) {\n+                        Assert.check(code.labelToBci(entry.tryStart()) == expectedExceptionTable[i][0] &&\n+                                     code.labelToBci(entry.tryEnd()) == expectedExceptionTable[i][1] &&\n+                                     code.labelToBci(entry.handler()) == expectedExceptionTable[i][2] &&\n+                                     (entry.catchType().isPresent()? entry.catchType().get().index(): 0)== expectedExceptionTable[i][3],\n","filename":"test\/langtools\/tools\/javac\/T8024039\/NoDeadCodeGenerationOnTrySmtTest.java","additions":19,"deletions":15,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -28,1 +28,6 @@\n- * @modules jdk.jdeps\/com.sun.tools.classfile\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.classfile.instruction\n+ *          java.base\/jdk.internal.classfile.components\n+ *          java.base\/jdk.internal.classfile.impl\n@@ -45,1 +50,0 @@\n-import com.sun.tools.classfile.*;\n@@ -55,0 +59,2 @@\n+import jdk.internal.classfile.*;\n+import jdk.internal.classfile.attribute.*;\n@@ -90,5 +96,5 @@\n-        ClassFile classFile = ClassFile.read(file);\n-        for (Method m : classFile.methods) {\n-            if (classFile.constant_pool.getUTF8Value(m.name_index).equals(\"foo\")) {\n-                Code_attribute code = (Code_attribute)m.attributes.get(Attribute.Code);\n-                LineNumberTable_attribute lnt = (LineNumberTable_attribute)code.attributes.get(Attribute.LineNumberTable);\n+        ClassModel classFile = Classfile.of().parse(file.toPath());\n+        for (MethodModel m : classFile.methods()) {\n+            if (m.methodName().equalsString(\"foo\")) {\n+                CodeAttribute code = m.findAttribute(Attributes.CODE).orElseThrow();\n+                LineNumberTableAttribute lnt = code.findAttribute(Attributes.LINE_NUMBER_TABLE).orElseThrow();\n@@ -100,3 +106,3 @@\n-    void checkLNT(LineNumberTable_attribute lnt, int lineToCheckFor) {\n-        for (LineNumberTable_attribute.Entry e: lnt.line_number_table) {\n-            if (e.line_number == lineToCheckFor) {\n+    void checkLNT(LineNumberTableAttribute lnt, int lineToCheckFor) {\n+        for (LineNumberInfo e: lnt.lineNumbers()) {\n+            if (e.lineNumber() == lineToCheckFor) {\n","filename":"test\/langtools\/tools\/javac\/T8180141\/MissingLNTEntryForBreakContinueTest.java","additions":16,"deletions":10,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -28,1 +28,6 @@\n- * @modules jdk.jdeps\/com.sun.tools.classfile\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.classfile.instruction\n+ *          java.base\/jdk.internal.classfile.components\n+ *          java.base\/jdk.internal.classfile.impl\n@@ -45,1 +50,0 @@\n-import com.sun.tools.classfile.*;\n@@ -56,0 +60,2 @@\n+import jdk.internal.classfile.*;\n+import jdk.internal.classfile.attribute.*;\n@@ -86,5 +92,5 @@\n-        ClassFile classFile = ClassFile.read(file);\n-        for (Method m : classFile.methods) {\n-            if (classFile.constant_pool.getUTF8Value(m.name_index).equals(\"foo\")) {\n-                Code_attribute code = (Code_attribute)m.attributes.get(Attribute.Code);\n-                LineNumberTable_attribute lnt = (LineNumberTable_attribute)code.attributes.get(Attribute.LineNumberTable);\n+        ClassModel classFile = Classfile.of().parse(file.toPath());\n+        for (MethodModel m : classFile.methods()) {\n+            if (m.methodName().equalsString(\"foo\")) {\n+                CodeAttribute code = m.findAttribute(Attributes.CODE).orElseThrow();\n+                LineNumberTableAttribute lnt = code.findAttribute(Attributes.LINE_NUMBER_TABLE).orElseThrow();\n@@ -96,3 +102,3 @@\n-    void checkLNT(LineNumberTable_attribute lnt, int lineToCheckFor) {\n-        for (LineNumberTable_attribute.Entry e: lnt.line_number_table) {\n-            if (e.line_number == lineToCheckFor) {\n+    void checkLNT(LineNumberTableAttribute lnt, int lineToCheckFor) {\n+        for (LineNumberInfo e: lnt.lineNumbers()) {\n+            if (e.lineNumber() == lineToCheckFor) {\n","filename":"test\/langtools\/tools\/javac\/T8180660\/MissingLNTEntryForFinalizerTest.java","additions":16,"deletions":10,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -27,1 +27,6 @@\n- * @modules jdk.jdeps\/com.sun.tools.classfile\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.classfile.instruction\n+ *          java.base\/jdk.internal.classfile.components\n+ *          java.base\/jdk.internal.classfile.impl\n@@ -32,2 +37,0 @@\n-import com.sun.tools.classfile.*;\n-\n@@ -40,4 +43,3 @@\n-import com.sun.tools.classfile.Attribute;\n-import com.sun.tools.classfile.RuntimeVisibleTypeAnnotations_attribute;\n-import com.sun.tools.classfile.TypeAnnotation;\n-import com.sun.tools.classfile.TypeAnnotation.Position;\n+import jdk.internal.classfile.*;\n+import jdk.internal.classfile.attribute.CodeAttribute;\n+import jdk.internal.classfile.attribute.RuntimeVisibleTypeAnnotationsAttribute;\n@@ -72,8 +74,7 @@\n-        ClassFile classFile = ClassFile.read(file);\n-        for (Method m : classFile.methods) {\n-            if (m.getName(classFile.constant_pool).equals(\"something\")) {\n-                for (Attribute a : m.attributes) {\n-                    if (a.getName(classFile.constant_pool).equals(\"Code\")) {\n-                        Code_attribute code = (Code_attribute)a;\n-                        for (Attribute codeAttrs : code.attributes) {\n-                            if (codeAttrs.getName(classFile.constant_pool).equals(\"RuntimeVisibleTypeAnnotations\")) {\n+        ClassModel classFile = Classfile.of().parse(file.toPath());\n+        for (MethodModel m : classFile.methods()) {\n+            if (m.methodName().equalsString(\"something\")) {\n+                for (Attribute<?> a : m.attributes()) {\n+                    if (a instanceof CodeAttribute code) {\n+                        for (Attribute<?> codeAttrs : code.attributes()) {\n+                            if (codeAttrs instanceof RuntimeVisibleTypeAnnotationsAttribute) {\n","filename":"test\/langtools\/tools\/javac\/T8187805\/BogusRTTAForUnusedVarTest.java","additions":16,"deletions":15,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -28,1 +28,6 @@\n- * @modules jdk.jdeps\/com.sun.tools.classfile\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.classfile.instruction\n+ *          java.base\/jdk.internal.classfile.components\n+ *          java.base\/jdk.internal.classfile.impl\n@@ -40,5 +45,3 @@\n-import com.sun.tools.classfile.Attribute;\n-import com.sun.tools.classfile.BootstrapMethods_attribute;\n-import com.sun.tools.classfile.BootstrapMethods_attribute.BootstrapMethodSpecifier;\n-import com.sun.tools.classfile.ClassFile;\n-import com.sun.tools.classfile.ConstantPool.*;\n+import jdk.internal.classfile.*;\n+import jdk.internal.classfile.attribute.*;\n+import jdk.internal.classfile.constantpool.*;\n@@ -83,10 +86,9 @@\n-        ClassFile classFile = ClassFile.read(cfile);\n-        for (Attribute attr : classFile.attributes) {\n-            if (attr.getName(classFile.constant_pool).equals(\"BootstrapMethods\")) {\n-                BootstrapMethods_attribute bsmAttr = (BootstrapMethods_attribute)attr;\n-                BootstrapMethodSpecifier bsmSpecifier = bsmAttr.bootstrap_method_specifiers[0];\n-                Assert.check(classFile.constant_pool.get(bsmSpecifier.bootstrap_arguments[0]) instanceof CONSTANT_MethodType_info);\n-                Assert.check(classFile.constant_pool.get(bsmSpecifier.bootstrap_arguments[1]) instanceof CONSTANT_MethodHandle_info);\n-                Assert.check(classFile.constant_pool.get(bsmSpecifier.bootstrap_arguments[2]) instanceof CONSTANT_MethodType_info);\n-                Assert.check(classFile.constant_pool.get(bsmSpecifier.bootstrap_arguments[3]) instanceof CONSTANT_Integer_info);\n-                Assert.check(classFile.constant_pool.get(bsmSpecifier.bootstrap_arguments[4]) instanceof CONSTANT_Integer_info);\n+        ClassModel classFile = Classfile.of().parse(cfile.toPath());\n+        for (Attribute<?> attr : classFile.attributes()) {\n+            if (attr instanceof BootstrapMethodsAttribute bsmAttr) {\n+                BootstrapMethodEntry bsmSpecifier = bsmAttr.bootstrapMethods().getFirst();\n+                Assert.check(bsmSpecifier.arguments().get(0) instanceof MethodTypeEntry);\n+                Assert.check(bsmSpecifier.arguments().get(1) instanceof MethodHandleEntry);\n+                Assert.check(bsmSpecifier.arguments().get(2) instanceof MethodTypeEntry);\n+                Assert.check(bsmSpecifier.arguments().get(3) instanceof IntegerEntry);\n+                Assert.check(bsmSpecifier.arguments().get(4) instanceof IntegerEntry);\n","filename":"test\/langtools\/tools\/javac\/T8203892\/CheckTargetIsNotAddedAsMarkerInterfaceTest.java","additions":18,"deletions":16,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -29,1 +29,6 @@\n- * @modules jdk.jdeps\/com.sun.tools.classfile\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.classfile.instruction\n+ *          java.base\/jdk.internal.classfile.components\n+ *          java.base\/jdk.internal.classfile.impl\n","filename":"test\/langtools\/tools\/javac\/T8209173\/CodeCompletionExceptTest.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -29,1 +29,6 @@\n- * @modules jdk.jdeps\/com.sun.tools.classfile\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.classfile.instruction\n+ *          java.base\/jdk.internal.classfile.components\n+ *          java.base\/jdk.internal.classfile.impl\n@@ -43,0 +48,1 @@\n+import javax.lang.model.type.TypeKind;\n@@ -50,8 +56,4 @@\n-import com.sun.tools.classfile.Attribute;\n-import com.sun.tools.classfile.BootstrapMethods_attribute;\n-import com.sun.tools.classfile.ClassFile;\n-import com.sun.tools.classfile.Code_attribute;\n-import com.sun.tools.classfile.ConstantPool.*;\n-import com.sun.tools.classfile.Instruction;\n-import com.sun.tools.classfile.LineNumberTable_attribute;\n-import com.sun.tools.classfile.Method;\n+import jdk.internal.classfile.*;\n+import jdk.internal.classfile.attribute.*;\n+import jdk.internal.classfile.constantpool.*;\n+import jdk.internal.classfile.instruction.ConstantInstruction;\n@@ -77,0 +79,2 @@\n+import static java.lang.invoke.MethodHandleInfo.REF_invokeStatic;\n+\n@@ -175,4 +179,4 @@\n-            ClassFile cf = ClassFile.read(is);\n-            Method testMethod = null;\n-            for (Method m : cf.methods) {\n-                if (m.getName(cf.constant_pool).equals(\"test\")) {\n+            ClassModel cf = Classfile.of().parse(is.readAllBytes());\n+            MethodModel testMethod = null;\n+            for (MethodModel m : cf.methods()) {\n+                if (m.methodName().equalsString(\"test\")) {\n@@ -187,3 +191,2 @@\n-            Code_attribute ea =\n-                    (Code_attribute)testMethod.attributes.get(Attribute.Code);\n-            if (testMethod == null) {\n+            CodeAttribute ea = testMethod.findAttribute(Attributes.CODE).orElse(null);\n+            if (ea == null) {\n@@ -194,1 +197,1 @@\n-            int bsmIdx = -1;\n+            BootstrapMethodEntry bootstrapMethodEntry = null;\n@@ -196,7 +199,7 @@\n-            for (Instruction i : ea.getInstructions()) {\n-                if (i.getMnemonic().equals(\"ldc\")) {\n-                    CONSTANT_Dynamic_info condyInfo = (CONSTANT_Dynamic_info)cf.constant_pool.get(i.getByte(1));\n-                    bsmIdx = condyInfo.bootstrap_method_attr_index;\n-                    System.out.println(\"condyInfo.getNameAndTypeInfo().getType() \" + condyInfo.getNameAndTypeInfo().getType());\n-                    if (!condyInfo.getNameAndTypeInfo().getType().equals(type.bytecodeTypeStr)) {\n-                        fail(\"type mismatch for CONSTANT_Dynamic_info\");\n+            for (CodeElement i : ea.elementList()) {\n+                if (i instanceof ConstantInstruction.LoadConstantInstruction lci) {\n+                    ConstantDynamicEntry condyInfo = (ConstantDynamicEntry)lci.constantEntry();\n+                    bootstrapMethodEntry = condyInfo.bootstrap();\n+                    System.out.println(\"condyInfo.getNameAndTypeInfo().getType() \" + condyInfo.type().stringValue());\n+                    if (!condyInfo.type().equalsString(type.bytecodeTypeStr)) {\n+                        fail(\"type mismatch for ConstantDynamicEntry\");\n@@ -209,1 +212,1 @@\n-            if (bsmIdx == -1) {\n+            if (bootstrapMethodEntry == null) {\n@@ -214,4 +217,2 @@\n-            BootstrapMethods_attribute bsm_attr =\n-                    (BootstrapMethods_attribute)cf\n-                    .getAttribute(Attribute.BootstrapMethods);\n-            if (bsm_attr.bootstrap_method_specifiers.length != 1) {\n+            BootstrapMethodsAttribute bsm_attr = cf.findAttribute(Attributes.BOOTSTRAP_METHODS).orElseThrow();\n+            if (bsm_attr.bootstrapMethods().size() != 1) {\n@@ -222,2 +223,2 @@\n-            BootstrapMethods_attribute.BootstrapMethodSpecifier bsm_spec =\n-                    bsm_attr.bootstrap_method_specifiers[0];\n+            BootstrapMethodEntry bsm_spec =\n+                    bsm_attr.bootstrapMethods().getFirst();\n@@ -225,3 +226,1 @@\n-            CONSTANT_MethodHandle_info bsm_handle =\n-                    (CONSTANT_MethodHandle_info)cf.constant_pool\n-                    .get(bsm_spec.bootstrap_method_ref);\n+            MethodHandleEntry bsm_handle = bsm_spec.bootstrapMethod();\n@@ -229,1 +228,1 @@\n-            if (bsm_handle.reference_kind != RefKind.REF_invokeStatic) {\n+            if (bsm_handle.kind() != REF_invokeStatic) {\n@@ -234,3 +233,1 @@\n-            CONSTANT_Methodref_info bsm_ref =\n-                    (CONSTANT_Methodref_info)cf.constant_pool\n-                    .get(bsm_handle.reference_index);\n+            MemberRefEntry bsm_ref = bsm_handle.reference();\n@@ -238,1 +235,1 @@\n-            if (!bsm_ref.getClassInfo().getName().equals(\"Test\")) {\n+            if (!bsm_ref.owner().name().equalsString(\"Test\")) {\n@@ -243,1 +240,1 @@\n-            if (!bsm_ref.getNameAndTypeInfo().getName().equals(\"bsm\")) {\n+            if (!bsm_ref.name().equalsString(\"bsm\")) {\n@@ -248,2 +245,1 @@\n-            if (!bsm_ref.getNameAndTypeInfo()\n-                    .getType().equals(asBSMSignatureString())) {\n+            if (!bsm_ref.type().equalsString(asBSMSignatureString())) {\n@@ -251,1 +247,1 @@\n-                        bsm_ref.getNameAndTypeInfo().getType() + \" \" +\n+                        bsm_ref.type() + \" \" +\n@@ -256,2 +252,1 @@\n-            LineNumberTable_attribute lnt =\n-                    (LineNumberTable_attribute)ea.attributes.get(Attribute.LineNumberTable);\n+            LineNumberTableAttribute lnt = ea.findAttribute(Attributes.LINE_NUMBER_TABLE).orElse(null);\n@@ -263,1 +258,1 @@\n-            if (lnt.line_number_table_length != 2) {\n+            if (lnt.lineNumbers().size() != 2) {\n@@ -265,1 +260,0 @@\n-                return;\n@@ -270,1 +264,0 @@\n-            return;\n","filename":"test\/langtools\/tools\/javac\/T8222949\/TestConstantDynamic.java","additions":41,"deletions":48,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -29,1 +29,6 @@\n- * @modules jdk.jdeps\/com.sun.tools.classfile\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.classfile.instruction\n+ *          java.base\/jdk.internal.classfile.components\n+ *          java.base\/jdk.internal.classfile.impl\n@@ -55,8 +60,4 @@\n-import com.sun.tools.classfile.Attribute;\n-import com.sun.tools.classfile.ClassFile;\n-import com.sun.tools.classfile.Code_attribute;\n-import com.sun.tools.classfile.ConstantPool.CONSTANT_Methodref_info;\n-import com.sun.tools.classfile.ConstantPool.CONSTANT_NameAndType_info;\n-import com.sun.tools.classfile.Instruction;\n-import com.sun.tools.classfile.Method;\n-import com.sun.tools.classfile.Opcode;\n+import jdk.internal.classfile.*;\n+import jdk.internal.classfile.attribute.CodeAttribute;\n+import jdk.internal.classfile.constantpool.MemberRefEntry;\n+import jdk.internal.classfile.instruction.InvokeInstruction;\n@@ -104,11 +105,8 @@\n-            ClassFile cf = ClassFile.read(new ByteArrayInputStream(data));\n-\n-            for (Method m : cf.methods) {\n-                Code_attribute codeAttr = (Code_attribute) m.attributes.map.get(Attribute.Code);\n-                for (Instruction i : codeAttr.getInstructions()) {\n-                    if (i.getOpcode() == Opcode.INVOKEVIRTUAL) {\n-                        CONSTANT_Methodref_info method =\n-                                (CONSTANT_Methodref_info) cf.constant_pool.get(i.getShort(1));\n-                        CONSTANT_NameAndType_info nameAndType =\n-                                cf.constant_pool.getNameAndTypeInfo(method.name_and_type_index);\n-                        if (\"close\".equals(nameAndType.getName())) {\n+            ClassModel cf = Classfile.of().parse(new ByteArrayInputStream(data).readAllBytes());\n+\n+            for (MethodModel m : cf.methods()) {\n+                CodeAttribute codeAttr = m.findAttribute(Attributes.CODE).orElseThrow();\n+                for (CodeElement ce : codeAttr.elementList()) {\n+                    if (ce instanceof InvokeInstruction ins && ins.opcode() == Opcode.INVOKEVIRTUAL) {\n+                        MemberRefEntry method = ins.method();\n+                        if (method.name().equalsString(\"close\")) {\n","filename":"test\/langtools\/tools\/javac\/TryWithResources\/TwrSimpleClose.java","additions":18,"deletions":20,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -30,1 +30,6 @@\n- *          jdk.jdeps\/com.sun.tools.classfile\n+ *          java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.classfile.instruction\n+ *          java.base\/jdk.internal.classfile.components\n+ *          java.base\/jdk.internal.classfile.impl\n@@ -33,1 +38,1 @@\n-import com.sun.tools.classfile.*;\n+import jdk.internal.classfile.*;\n@@ -37,0 +42,1 @@\n+import java.util.Objects;\n@@ -57,4 +63,4 @@\n-            ClassFile cf = ClassFile.read(in);\n-            Assert.check(cf.methods.length > 5);\n-            for (Method m : cf.methods) {\n-                String methodName = m.getName(cf.constant_pool);\n+            ClassModel cm = Classfile.of().parse(Objects.requireNonNull(in).readAllBytes());\n+            Assert.check(cm.methods().size() > 5);\n+            for (MethodModel mm : cm.methods()) {\n+                String methodName = mm.methodName().stringValue();\n@@ -64,2 +70,2 @@\n-                    var paAnnos = ((RuntimeVisibleParameterAnnotations_attribute) m.attributes.get(Attribute.RuntimeVisibleParameterAnnotations)).parameter_annotations;\n-                    Assert.check(paAnnos.length > 0);\n+                    var paAnnos = mm.findAttribute(Attributes.RUNTIME_VISIBLE_PARAMETER_ANNOTATIONS).orElseThrow().parameterAnnotations();\n+                    Assert.check(paAnnos.size() > 0);\n@@ -67,2 +73,2 @@\n-                        Assert.check(pa.length == 1);\n-                        Assert.check(cf.constant_pool.getUTF8Value(pa[0].type_index).equals(\"LParameterAnnotation;\"));\n+                        Assert.check(pa.size() == 1);\n+                        Assert.check(Objects.equals(pa.get(0).classSymbol().descriptorString(), \"LParameterAnnotation;\"));\n@@ -71,3 +77,3 @@\n-                    var annos = ((RuntimeAnnotations_attribute) m.attributes.get(Attribute.RuntimeVisibleAnnotations)).annotations;\n-                    Assert.check(annos.length == 1);\n-                    Assert.check(cf.constant_pool.getUTF8Value(annos[0].type_index).equals(\"LMethodAnnotation;\"));\n+                    var annos = mm.findAttribute(Attributes.RUNTIME_VISIBLE_ANNOTATIONS).orElseThrow().annotations();\n+                    Assert.check(annos.size() == 1);\n+                    Assert.check(Objects.equals(annos.get(0).classSymbol().descriptorString(), \"LMethodAnnotation;\"));\n@@ -76,5 +82,5 @@\n-            Assert.check(cf.fields.length > 0);\n-            for (Field field : cf.fields) {\n-                var annos = ((RuntimeAnnotations_attribute) field.attributes.get(Attribute.RuntimeVisibleAnnotations)).annotations;\n-                Assert.check(annos.length == 1);\n-                Assert.check(cf.constant_pool.getUTF8Value(annos[0].type_index).equals(\"LFieldAnnotation;\"));\n+            Assert.check(cm.fields().size() > 0);\n+            for (FieldModel fm : cm.fields()) {\n+                var annos = fm.findAttribute(Attributes.RUNTIME_VISIBLE_ANNOTATIONS).orElseThrow().annotations();\n+                Assert.check(annos.size() == 1);\n+                Assert.check(Objects.equals(annos.getFirst().classSymbol().descriptorString(), \"LFieldAnnotation;\"));\n","filename":"test\/langtools\/tools\/javac\/annotations\/ApplicableAnnotationsOnRecords.java","additions":24,"deletions":18,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,6 @@\n- *      jdk.jdeps\/com.sun.tools.classfile\n+ *      java.base\/jdk.internal.classfile\n+ *      java.base\/jdk.internal.classfile.attribute\n+ *      java.base\/jdk.internal.classfile.constantpool\n+ *      java.base\/jdk.internal.classfile.instruction\n+ *      java.base\/jdk.internal.classfile.components\n+ *      java.base\/jdk.internal.classfile.impl\n@@ -48,1 +53,2 @@\n-import com.sun.tools.classfile.*;\n+import jdk.internal.classfile.*;\n+import jdk.internal.classfile.attribute.*;\n@@ -112,1 +118,1 @@\n-        ClassFile classFile = ClassFile.read(cfile);\n+        ClassModel classFile = Classfile.of().parse(cfile.toPath());\n@@ -115,2 +121,2 @@\n-        for (Method method : classFile.methods) {\n-            String methodName = method.getName(classFile.constant_pool);\n+        for (MethodModel method : classFile.methods()) {\n+            String methodName = method.methodName().stringValue();\n@@ -141,1 +147,1 @@\n-    void checkConstructor(ClassFile classFile, Method method, int... positions) throws Exception {\n+    void checkConstructor(ClassModel classFile, MethodModel method, int... positions) throws Exception {\n@@ -148,2 +154,3 @@\n-            Assert.check(ta.position.type.toString().equals(\"METHOD_FORMAL_PARAMETER\"));\n-            Assert.check(ta.position.parameter_index == pos);\n+            Assert.check(ta.targetInfo().targetType().name().equals(\"METHOD_FORMAL_PARAMETER\"));\n+            assert ta.targetInfo() instanceof TypeAnnotation.FormalParameterTarget;\n+            Assert.check(((TypeAnnotation.FormalParameterTarget)ta.targetInfo()).formalParameterIndex() == pos);\n@@ -158,1 +165,1 @@\n-    void checkAccessor(ClassFile classFile, Method method) {\n+    void checkAccessor(ClassModel classFile, MethodModel method) {\n@@ -163,1 +170,1 @@\n-        Assert.check(ta.position.type.toString().equals(\"METHOD_RETURN\"));\n+        Assert.check(ta.targetInfo().targetType().name().equals(\"METHOD_RETURN\"));\n@@ -170,1 +177,1 @@\n-    void checkFields(ClassFile classFile, int... positions) {\n+    void checkFields(ClassModel classFile, int... positions) {\n@@ -176,1 +183,1 @@\n-            for (Field field : classFile.fields) {\n+            for (FieldModel field : classFile.fields()) {\n@@ -184,1 +191,1 @@\n-                    Assert.check(ta.position.type.toString().equals(\"FIELD\"));\n+                    Assert.check(ta.targetInfo().targetType().name().equals(\"FIELD\"));\n@@ -196,3 +203,3 @@\n-    void findAnnotations(ClassFile cf, Method m, List<TypeAnnotation> annos) {\n-        findAnnotations(cf, m, Attribute.RuntimeVisibleTypeAnnotations, annos);\n-        findAnnotations(cf, m, Attribute.RuntimeInvisibleTypeAnnotations, annos);\n+    void findAnnotations(ClassModel cm, AttributedElement m, List<TypeAnnotation> annos) {\n+        findAnnotations(cm, m, Attributes.RUNTIME_VISIBLE_TYPE_ANNOTATIONS, annos);\n+        findAnnotations(cm, m, Attributes.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS, annos);\n@@ -201,25 +208,8 @@\n-    void findAnnotations(ClassFile cf, Field m, List<TypeAnnotation> annos) {\n-        findAnnotations(cf, m, Attribute.RuntimeVisibleTypeAnnotations, annos);\n-        findAnnotations(cf, m, Attribute.RuntimeInvisibleTypeAnnotations, annos);\n-    }\n-\n-    void findAnnotations(ClassFile cf, Method m, String name, List<TypeAnnotation> annos) {\n-        int index = m.attributes.getIndex(cf.constant_pool, name);\n-        if (index != -1) {\n-            Attribute attr = m.attributes.get(index);\n-            assert attr instanceof RuntimeTypeAnnotations_attribute;\n-            RuntimeTypeAnnotations_attribute tAttr = (RuntimeTypeAnnotations_attribute)attr;\n-            annos.addAll(Arrays.asList(tAttr.annotations));\n-        }\n-\n-        int cindex = m.attributes.getIndex(cf.constant_pool, Attribute.Code);\n-        if (cindex != -1) {\n-            Attribute cattr = m.attributes.get(cindex);\n-            assert cattr instanceof Code_attribute;\n-            Code_attribute cAttr = (Code_attribute)cattr;\n-            index = cAttr.attributes.getIndex(cf.constant_pool, name);\n-            if (index != -1) {\n-                Attribute attr = cAttr.attributes.get(index);\n-                assert attr instanceof RuntimeTypeAnnotations_attribute;\n-                RuntimeTypeAnnotations_attribute tAttr = (RuntimeTypeAnnotations_attribute)attr;\n-                annos.addAll(Arrays.asList(tAttr.annotations));\n+    <T extends Attribute<T>> void findAnnotations(ClassModel cf, AttributedElement m, AttributeMapper<T> attrName, List<TypeAnnotation> annos) {\n+        Attribute<T> attr = m.findAttribute(attrName).orElse(null);\n+        addAnnos(annos, attr);\n+        if (m instanceof MethodModel) {\n+            CodeAttribute cattr = m.findAttribute(Attributes.CODE).orElse(null);\n+            if (cattr != null) {\n+                attr = cattr.findAttribute(attrName).orElse(null);\n+                addAnnos(annos, attr);\n@@ -230,7 +220,13 @@\n-    void findAnnotations(ClassFile cf, Field m, String name, List<TypeAnnotation> annos) {\n-        int index = m.attributes.getIndex(cf.constant_pool, name);\n-        if (index != -1) {\n-            Attribute attr = m.attributes.get(index);\n-            assert attr instanceof RuntimeTypeAnnotations_attribute;\n-            RuntimeTypeAnnotations_attribute tAttr = (RuntimeTypeAnnotations_attribute)attr;\n-            annos.addAll(Arrays.asList(tAttr.annotations));\n+    private <T extends Attribute<T>> void addAnnos(List<TypeAnnotation> annos, Attribute<T> attr) {\n+        if (attr != null) {\n+            switch (attr) {\n+                case RuntimeVisibleTypeAnnotationsAttribute vanno -> {\n+                    annos.addAll(vanno.annotations());\n+                }\n+                case RuntimeInvisibleTypeAnnotationsAttribute ivanno -> {\n+                    annos.addAll(ivanno.annotations());\n+                }\n+                default -> {\n+                    throw new AssertionError();\n+                }\n+            }\n","filename":"test\/langtools\/tools\/javac\/annotations\/typeAnnotations\/TypeAnnotationsPositionsOnRecords.java","additions":45,"deletions":49,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,6 @@\n- *      jdk.jdeps\/com.sun.tools.classfile\n+ *      java.base\/jdk.internal.classfile\n+ *      java.base\/jdk.internal.classfile.attribute\n+ *      java.base\/jdk.internal.classfile.constantpool\n+ *      java.base\/jdk.internal.classfile.instruction\n+ *      java.base\/jdk.internal.classfile.components\n+ *      java.base\/jdk.internal.classfile.impl\n@@ -48,1 +53,2 @@\n-import com.sun.tools.classfile.*;\n+import jdk.internal.classfile.*;\n+import jdk.internal.classfile.attribute.*;\n@@ -100,1 +106,1 @@\n-        ClassFile classFile = ClassFile.read(cfile);\n+        ClassModel classFile = Classfile.of().parse(cfile.toPath());\n@@ -102,1 +108,1 @@\n-        for (Method method : classFile.methods) {\n+        for (MethodModel method : classFile.methods()) {\n@@ -104,1 +110,1 @@\n-            String methodName = method.getName(classFile.constant_pool);\n+            String methodName = method.methodName().stringValue();\n@@ -110,3 +116,3 @@\n-    void findAnnotations(ClassFile cf, Method m, List<TypeAnnotation> annos) {\n-        findAnnotations(cf, m, Attribute.RuntimeVisibleTypeAnnotations, annos);\n-        findAnnotations(cf, m, Attribute.RuntimeInvisibleTypeAnnotations, annos);\n+    void findAnnotations(ClassModel cf, MethodModel m, List<TypeAnnotation> annos) {\n+        findAnnotations(cf, m, Attributes.RUNTIME_VISIBLE_TYPE_ANNOTATIONS, annos);\n+        findAnnotations(cf, m, Attributes.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS, annos);\n@@ -115,7 +121,9 @@\n-    void findAnnotations(ClassFile cf, Method m, String name, List<TypeAnnotation> annos) {\n-        int index = m.attributes.getIndex(cf.constant_pool, name);\n-        if (index != -1) {\n-            Attribute attr = m.attributes.get(index);\n-            assert attr instanceof RuntimeTypeAnnotations_attribute;\n-            RuntimeTypeAnnotations_attribute tAttr = (RuntimeTypeAnnotations_attribute)attr;\n-            annos.addAll(Arrays.asList(tAttr.annotations));\n+    <T extends Attribute<T>> void findAnnotations(ClassModel cf, AttributedElement m, AttributeMapper<T> attrName, List<TypeAnnotation> annos) {\n+        Attribute<T> attr = m.findAttribute(attrName).orElse(null);\n+        addAnnos(annos, attr);\n+        if (m instanceof MethodModel) {\n+            CodeAttribute cattr = m.findAttribute(Attributes.CODE).orElse(null);\n+            if (cattr != null) {\n+                attr = cattr.findAttribute(attrName).orElse(null);\n+                addAnnos(annos, attr);\n+            }\n@@ -123,0 +131,1 @@\n+    }\n@@ -124,11 +133,12 @@\n-        int cindex = m.attributes.getIndex(cf.constant_pool, Attribute.Code);\n-        if (cindex != -1) {\n-            Attribute cattr = m.attributes.get(cindex);\n-            assert cattr instanceof Code_attribute;\n-            Code_attribute cAttr = (Code_attribute)cattr;\n-            index = cAttr.attributes.getIndex(cf.constant_pool, name);\n-            if (index != -1) {\n-                Attribute attr = cAttr.attributes.get(index);\n-                assert attr instanceof RuntimeTypeAnnotations_attribute;\n-                RuntimeTypeAnnotations_attribute tAttr = (RuntimeTypeAnnotations_attribute)attr;\n-                annos.addAll(Arrays.asList(tAttr.annotations));\n+    private <T extends Attribute<T>> void addAnnos(List<TypeAnnotation> annos, Attribute<T> attr) {\n+        if (attr != null) {\n+            switch (attr) {\n+                case RuntimeVisibleTypeAnnotationsAttribute vanno -> {\n+                    annos.addAll(vanno.annotations());\n+                }\n+                case RuntimeInvisibleTypeAnnotationsAttribute ivanno -> {\n+                    annos.addAll(ivanno.annotations());\n+                }\n+                default -> {\n+                    throw new AssertionError();\n+                }\n","filename":"test\/langtools\/tools\/javac\/annotations\/typeAnnotations\/VariablesDeclaredWithVarTest.java","additions":37,"deletions":27,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-import static com.sun.tools.classfile.TypeAnnotation.TargetType.*;\n+import static jdk.internal.classfile.TypeAnnotation.TargetType.*;\n@@ -30,1 +30,6 @@\n- * @modules jdk.jdeps\/com.sun.tools.classfile\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.classfile.instruction\n+ *          java.base\/jdk.internal.classfile.components\n+ *          java.base\/jdk.internal.classfile.impl\n","filename":"test\/langtools\/tools\/javac\/annotations\/typeAnnotations\/referenceinfos\/ClassExtends.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-import static com.sun.tools.classfile.TypeAnnotation.TargetType.*;\n+import static jdk.internal.classfile.TypeAnnotation.TargetType.*;\n@@ -30,1 +30,6 @@\n- * @modules jdk.jdeps\/com.sun.tools.classfile\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.classfile.instruction\n+ *          java.base\/jdk.internal.classfile.components\n+ *          java.base\/jdk.internal.classfile.impl\n","filename":"test\/langtools\/tools\/javac\/annotations\/typeAnnotations\/referenceinfos\/ClassTypeParam.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -28,1 +28,6 @@\n- * @modules jdk.jdeps\/com.sun.tools.classfile\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.classfile.instruction\n+ *          java.base\/jdk.internal.classfile.components\n+ *          java.base\/jdk.internal.classfile.impl\n@@ -33,1 +38,1 @@\n-import static com.sun.tools.classfile.TypeAnnotation.TargetType.CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT;\n+import static jdk.internal.classfile.TypeAnnotation.TargetType.CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT;\n","filename":"test\/langtools\/tools\/javac\/annotations\/typeAnnotations\/referenceinfos\/ConstructorInvocationTypeArgument.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -28,1 +28,6 @@\n- * @modules jdk.jdeps\/com.sun.tools.classfile\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.classfile.instruction\n+ *          java.base\/jdk.internal.classfile.components\n+ *          java.base\/jdk.internal.classfile.impl\n@@ -33,1 +38,1 @@\n-import static com.sun.tools.classfile.TypeAnnotation.TargetType.*;\n+import static jdk.internal.classfile.TypeAnnotation.TargetType.*;\n","filename":"test\/langtools\/tools\/javac\/annotations\/typeAnnotations\/referenceinfos\/Constructors.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -24,0 +24,1 @@\n+import jdk.internal.classfile.*;\n@@ -32,10 +33,2 @@\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-\n-import com.sun.tools.classfile.ClassFile;\n-import com.sun.tools.classfile.TypeAnnotation;\n-import com.sun.tools.classfile.TypeAnnotation.TargetType;\n+import java.util.*;\n+import java.util.stream.Collectors;\n@@ -56,1 +49,1 @@\n-        if (args.length == 0 || args.length > 1)\n+        if (args.length != 1)\n@@ -77,1 +70,1 @@\n-                Map<String, TypeAnnotation.Position> expected = expectedOf(method);\n+                Map<String, ReferenceInfoUtil.TAD> expected = expectedOf(method);\n@@ -87,1 +80,1 @@\n-                    String fullFile = wrap(compact, new HashMap<String, String>() {{\n+                    String fullFile = wrap(compact, new HashMap<>() {{\n@@ -93,3 +86,3 @@\n-                            ClassFile cf = compileAndReturn(fullFile, testClass, extraParams);\n-                            List<TypeAnnotation> actual = ReferenceInfoUtil.extendedAnnotationsOf(cf);\n-                            ReferenceInfoUtil.compare(expected, actual, cf);\n+                            ClassModel cm = compileAndReturn(fullFile, testClass, extraParams);\n+                            List<ReferenceInfoUtil.TAD> actual = ReferenceInfoUtil.extendedAnnotationsOf(cm);\n+                            ReferenceInfoUtil.compare(expected, actual);\n@@ -109,1 +102,1 @@\n-                out.println(\"    \" + e.toString());\n+                out.println(\"    \" + e);\n@@ -125,1 +118,1 @@\n-    private Map<String, TypeAnnotation.Position> expectedOf(Method m) {\n+    private Map<String, ReferenceInfoUtil.TAD> expectedOf(Method m) {\n@@ -132,1 +125,1 @@\n-        Map<String, TypeAnnotation.Position> result =\n+        Map<String, ReferenceInfoUtil.TAD> result =\n@@ -136,1 +129,1 @@\n-            result.putAll(expectedOf(ta));\n+            result.put(ta.annotation(), wrapTADescription(ta));\n@@ -140,1 +133,1 @@\n-                result.putAll(expectedOf(a));\n+                result.put(a.annotation(), wrapTADescription(a));\n@@ -146,34 +139,8 @@\n-\n-    private Map<String, TypeAnnotation.Position> expectedOf(TADescription d) {\n-        String annoName = d.annotation();\n-\n-        TypeAnnotation.Position p = new TypeAnnotation.Position();\n-        p.type = d.type();\n-        if (d.offset() != NOT_SET)\n-            p.offset = d.offset();\n-        if (d.lvarOffset().length != 0)\n-            p.lvarOffset = d.lvarOffset();\n-        if (d.lvarLength().length != 0)\n-            p.lvarLength = d.lvarLength();\n-        if (d.lvarIndex().length != 0)\n-            p.lvarIndex = d.lvarIndex();\n-        if (d.boundIndex() != NOT_SET)\n-            p.bound_index = d.boundIndex();\n-        if (d.paramIndex() != NOT_SET)\n-            p.parameter_index = d.paramIndex();\n-        if (d.typeIndex() != NOT_SET)\n-            p.type_index = d.typeIndex();\n-        if (d.exceptionIndex() != NOT_SET)\n-            p.exception_index = d.exceptionIndex();\n-        if (d.genericLocation().length != 0) {\n-            p.location = TypeAnnotation.Position.getTypePathFromBinary(wrapIntArray(d.genericLocation()));\n-        }\n-\n-        return Collections.singletonMap(annoName, p);\n-    }\n-\n-    private List<Integer> wrapIntArray(int[] ints) {\n-        List<Integer> list = new ArrayList<>(ints.length);\n-        for (int i : ints)\n-            list.add(i);\n-        return list;\n+    private ReferenceInfoUtil.TAD wrapTADescription(TADescription taD) {\n+        List<Integer> genericLocation = Arrays.stream(taD.genericLocation()).boxed().collect(Collectors.toList());\n+        List<Integer> lvarIndex = Arrays.stream(taD.lvarIndex()).boxed().collect(Collectors.toList());\n+        List<Integer> lvarLength = Arrays.stream(taD.lvarLength()).boxed().collect(Collectors.toList());\n+        List<Integer> lvarOffset = Arrays.stream(taD.lvarOffset()).boxed().collect(Collectors.toList());\n+        return new ReferenceInfoUtil.TAD(taD.annotation(), taD.type(), taD.typeIndex(),\n+                taD.paramIndex(), taD.boundIndex(), taD.exceptionIndex(), taD.offset(),\n+                lvarOffset, lvarLength, lvarIndex, genericLocation);\n@@ -196,1 +163,1 @@\n-    private ClassFile compileAndReturn(String fullFile, String testClass, String... extraParams) throws Exception {\n+    private ClassModel compileAndReturn(String fullFile, String testClass, String... extraParams) throws Exception {\n@@ -199,1 +166,1 @@\n-        return ClassFile.read(clazzFile);\n+        return Classfile.of().parse(clazzFile.toPath());\n@@ -211,1 +178,1 @@\n-        return System.getProperty(\"test.classes\", Driver.class.getResource(\".\").getPath());\n+        return System.getProperty(\"test.classes\", Objects.requireNonNull(Driver.class.getResource(\".\")).getPath());\n@@ -215,2 +182,1 @@\n-        List<String> options = new ArrayList<>();\n-        options.addAll(Arrays.asList(extraParams));\n+        List<String> options = new ArrayList<>(Arrays.asList(extraParams));\n@@ -218,1 +184,1 @@\n-        int rc = com.sun.tools.javac.Main.compile(options.toArray(new String[options.size()]));\n+        int rc = com.sun.tools.javac.Main.compile(options.toArray(new String[0]));\n@@ -355,1 +321,1 @@\n-    public static final int NOT_SET = -888;\n+    public static final int NOT_SET = Integer.MIN_VALUE;\n@@ -365,1 +331,1 @@\n-    TargetType type();\n+    TypeAnnotation.TargetType type();\n","filename":"test\/langtools\/tools\/javac\/annotations\/typeAnnotations\/referenceinfos\/Driver.java","additions":29,"deletions":63,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-import static com.sun.tools.classfile.TypeAnnotation.TargetType.*;\n+import static jdk.internal.classfile.TypeAnnotation.TargetType.*;\n@@ -31,1 +31,6 @@\n- * @modules jdk.jdeps\/com.sun.tools.classfile\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.classfile.instruction\n+ *          java.base\/jdk.internal.classfile.components\n+ *          java.base\/jdk.internal.classfile.impl\n","filename":"test\/langtools\/tools\/javac\/annotations\/typeAnnotations\/referenceinfos\/ExceptionParameters.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -28,1 +28,6 @@\n- * @modules jdk.jdeps\/com.sun.tools.classfile\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.classfile.instruction\n+ *          java.base\/jdk.internal.classfile.components\n+ *          java.base\/jdk.internal.classfile.impl\n@@ -33,1 +38,1 @@\n-import static com.sun.tools.classfile.TypeAnnotation.TargetType.*;\n+import static jdk.internal.classfile.TypeAnnotation.TargetType.*;\n","filename":"test\/langtools\/tools\/javac\/annotations\/typeAnnotations\/referenceinfos\/Fields.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-import static com.sun.tools.classfile.TypeAnnotation.TargetType.*;\n+import static jdk.internal.classfile.TypeAnnotation.TargetType.*;\n@@ -30,1 +30,6 @@\n- * @modules jdk.jdeps\/com.sun.tools.classfile\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.classfile.instruction\n+ *          java.base\/jdk.internal.classfile.components\n+ *          java.base\/jdk.internal.classfile.impl\n","filename":"test\/langtools\/tools\/javac\/annotations\/typeAnnotations\/referenceinfos\/FromSpecification.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-import static com.sun.tools.classfile.TypeAnnotation.TargetType.*;\n+import static jdk.internal.classfile.TypeAnnotation.TargetType.*;\n@@ -31,1 +31,6 @@\n- * @modules jdk.jdeps\/com.sun.tools.classfile\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.classfile.instruction\n+ *          java.base\/jdk.internal.classfile.components\n+ *          java.base\/jdk.internal.classfile.impl\n","filename":"test\/langtools\/tools\/javac\/annotations\/typeAnnotations\/referenceinfos\/Initializers.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -29,1 +29,6 @@\n- * @modules jdk.jdeps\/com.sun.tools.classfile\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.classfile.instruction\n+ *          java.base\/jdk.internal.classfile.components\n+ *          java.base\/jdk.internal.classfile.impl\n@@ -36,1 +41,1 @@\n-import static com.sun.tools.classfile.TypeAnnotation.TargetType.*;\n+import static jdk.internal.classfile.TypeAnnotation.TargetType.*;\n","filename":"test\/langtools\/tools\/javac\/annotations\/typeAnnotations\/referenceinfos\/Lambda.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -28,1 +28,6 @@\n- * @modules jdk.jdeps\/com.sun.tools.classfile\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.classfile.instruction\n+ *          java.base\/jdk.internal.classfile.components\n+ *          java.base\/jdk.internal.classfile.impl\n@@ -33,1 +38,1 @@\n-import static com.sun.tools.classfile.TypeAnnotation.TargetType.METHOD_INVOCATION_TYPE_ARGUMENT;\n+import static jdk.internal.classfile.TypeAnnotation.TargetType.METHOD_INVOCATION_TYPE_ARGUMENT;\n","filename":"test\/langtools\/tools\/javac\/annotations\/typeAnnotations\/referenceinfos\/MethodInvocationTypeArgument.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-import static com.sun.tools.classfile.TypeAnnotation.TargetType.*;\n+import static jdk.internal.classfile.TypeAnnotation.TargetType.*;\n@@ -30,1 +30,6 @@\n- * @modules jdk.jdeps\/com.sun.tools.classfile\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.classfile.instruction\n+ *          java.base\/jdk.internal.classfile.components\n+ *          java.base\/jdk.internal.classfile.impl\n","filename":"test\/langtools\/tools\/javac\/annotations\/typeAnnotations\/referenceinfos\/MethodParameters.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-import static com.sun.tools.classfile.TypeAnnotation.TargetType.*;\n+import static jdk.internal.classfile.TypeAnnotation.TargetType.*;\n@@ -30,1 +30,6 @@\n- * @modules jdk.jdeps\/com.sun.tools.classfile\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.classfile.instruction\n+ *          java.base\/jdk.internal.classfile.components\n+ *          java.base\/jdk.internal.classfile.impl\n","filename":"test\/langtools\/tools\/javac\/annotations\/typeAnnotations\/referenceinfos\/MethodReceivers.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-import static com.sun.tools.classfile.TypeAnnotation.TargetType.*;\n+import static jdk.internal.classfile.TypeAnnotation.TargetType.*;\n@@ -30,1 +30,6 @@\n- * @modules jdk.jdeps\/com.sun.tools.classfile\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.classfile.instruction\n+ *          java.base\/jdk.internal.classfile.components\n+ *          java.base\/jdk.internal.classfile.impl\n","filename":"test\/langtools\/tools\/javac\/annotations\/typeAnnotations\/referenceinfos\/MethodReturns.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-import static com.sun.tools.classfile.TypeAnnotation.TargetType.*;\n+import static jdk.internal.classfile.TypeAnnotation.TargetType.*;\n@@ -30,1 +30,6 @@\n- * @modules jdk.jdeps\/com.sun.tools.classfile\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.classfile.instruction\n+ *          java.base\/jdk.internal.classfile.components\n+ *          java.base\/jdk.internal.classfile.impl\n","filename":"test\/langtools\/tools\/javac\/annotations\/typeAnnotations\/referenceinfos\/MethodThrows.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-import static com.sun.tools.classfile.TypeAnnotation.TargetType.*;\n+import static jdk.internal.classfile.TypeAnnotation.TargetType.*;\n@@ -31,1 +31,6 @@\n- * @modules jdk.jdeps\/com.sun.tools.classfile\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.classfile.instruction\n+ *          java.base\/jdk.internal.classfile.components\n+ *          java.base\/jdk.internal.classfile.impl\n","filename":"test\/langtools\/tools\/javac\/annotations\/typeAnnotations\/referenceinfos\/MethodTypeParam.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-import static com.sun.tools.classfile.TypeAnnotation.TargetType.*;\n+import static jdk.internal.classfile.TypeAnnotation.TargetType.*;\n@@ -31,1 +31,6 @@\n- * @modules jdk.jdeps\/com.sun.tools.classfile\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.classfile.instruction\n+ *          java.base\/jdk.internal.classfile.components\n+ *          java.base\/jdk.internal.classfile.impl\n","filename":"test\/langtools\/tools\/javac\/annotations\/typeAnnotations\/referenceinfos\/MultiCatch.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-import static com.sun.tools.classfile.TypeAnnotation.TargetType.*;\n+import static jdk.internal.classfile.TypeAnnotation.TargetType.*;\n@@ -30,1 +30,6 @@\n- * @modules jdk.jdeps\/com.sun.tools.classfile\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.classfile.instruction\n+ *          java.base\/jdk.internal.classfile.components\n+ *          java.base\/jdk.internal.classfile.impl\n","filename":"test\/langtools\/tools\/javac\/annotations\/typeAnnotations\/referenceinfos\/NestedTypes.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-import static com.sun.tools.classfile.TypeAnnotation.TargetType.*;\n+import static jdk.internal.classfile.TypeAnnotation.TargetType.*;\n@@ -30,1 +30,6 @@\n- * @modules jdk.jdeps\/com.sun.tools.classfile\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.classfile.instruction\n+ *          java.base\/jdk.internal.classfile.components\n+ *          java.base\/jdk.internal.classfile.impl\n","filename":"test\/langtools\/tools\/javac\/annotations\/typeAnnotations\/referenceinfos\/NewObjects.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -24,14 +24,3 @@\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.List;\n-import java.util.Map;\n-\n-import com.sun.tools.classfile.Attribute;\n-import com.sun.tools.classfile.ClassFile;\n-import com.sun.tools.classfile.Code_attribute;\n-import com.sun.tools.classfile.TypeAnnotation;\n-import com.sun.tools.classfile.Field;\n-import com.sun.tools.classfile.Method;\n-import com.sun.tools.classfile.RuntimeTypeAnnotations_attribute;\n-import com.sun.tools.classfile.ConstantPool.InvalidIndex;\n-import com.sun.tools.classfile.ConstantPool.UnexpectedEntry;\n+import jdk.internal.classfile.*;\n+import jdk.internal.classfile.attribute.*;\n+import java.util.*;\n@@ -41,1 +30,1 @@\n-    public static final int IGNORE_VALUE = -321;\n+    public static final int IGNORE_VALUE = Integer.MIN_VALUE;\n@@ -43,3 +32,3 @@\n-    public static List<TypeAnnotation> extendedAnnotationsOf(ClassFile cf) {\n-        List<TypeAnnotation> annos = new ArrayList<>();\n-        findAnnotations(cf, annos);\n+    public static List<TAD> extendedAnnotationsOf(ClassModel cm) {\n+        List<TAD> annos = new ArrayList<>();\n+        findAnnotations(cm, annos);\n@@ -50,3 +39,3 @@\n-    private static void findAnnotations(ClassFile cf, List<TypeAnnotation> annos) {\n-        findAnnotations(cf, Attribute.RuntimeVisibleTypeAnnotations, annos);\n-        findAnnotations(cf, Attribute.RuntimeInvisibleTypeAnnotations, annos);\n+    private static void findAnnotations(ClassModel cm, List<TAD> annos) {\n+        findAnnotations(cm, Attributes.RUNTIME_VISIBLE_TYPE_ANNOTATIONS, annos);\n+        findAnnotations(cm, Attributes.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS, annos);\n@@ -54,2 +43,2 @@\n-        for (Field f : cf.fields) {\n-            findAnnotations(cf, f, annos);\n+        for (FieldModel f : cm.fields()) {\n+            findAnnotations(f, annos);\n@@ -57,2 +46,2 @@\n-        for (Method m: cf.methods) {\n-            findAnnotations(cf, m, annos);\n+        for (MethodModel m: cm.methods()) {\n+            findAnnotations(m, annos);\n@@ -62,8 +51,3 @@\n-    private static void findAnnotations(ClassFile cf, Method m, List<TypeAnnotation> annos) {\n-        findAnnotations(cf, m, Attribute.RuntimeVisibleTypeAnnotations, annos);\n-        findAnnotations(cf, m, Attribute.RuntimeInvisibleTypeAnnotations, annos);\n-    }\n-\n-    private static void findAnnotations(ClassFile cf, Field m, List<TypeAnnotation> annos) {\n-        findAnnotations(cf, m, Attribute.RuntimeVisibleTypeAnnotations, annos);\n-        findAnnotations(cf, m, Attribute.RuntimeInvisibleTypeAnnotations, annos);\n+    private static void findAnnotations(AttributedElement ae, List<TAD> annos) {\n+        findAnnotations(ae, Attributes.RUNTIME_VISIBLE_TYPE_ANNOTATIONS, annos);\n+        findAnnotations(ae, Attributes.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS, annos);\n@@ -74,7 +58,8 @@\n-    private static void findAnnotations(ClassFile cf, String name, List<TypeAnnotation> annos) {\n-        int index = cf.attributes.getIndex(cf.constant_pool, name);\n-        if (index != -1) {\n-            Attribute attr = cf.attributes.get(index);\n-            assert attr instanceof RuntimeTypeAnnotations_attribute;\n-            RuntimeTypeAnnotations_attribute tAttr = (RuntimeTypeAnnotations_attribute)attr;\n-            annos.addAll(Arrays.asList(tAttr.annotations));\n+    private static <T extends Attribute<T>> void findAnnotations(ClassModel cm, AttributeMapper<T> attrName, List<TAD> annos) {\n+        Attribute<T> attr = cm.findAttribute(attrName).orElse(null);\n+        if (attr != null) {\n+            if (attr instanceof RuntimeVisibleTypeAnnotationsAttribute tAttr) {\n+                annos.addAll(Objects.requireNonNull(generateTADList(tAttr.annotations(), null)));\n+            } else if (attr instanceof RuntimeInvisibleTypeAnnotationsAttribute tAttr) {\n+                annos.addAll(Objects.requireNonNull(generateTADList(tAttr.annotations(), null)));\n+            } else throw new AssertionError();\n@@ -86,7 +71,8 @@\n-    private static void findAnnotations(ClassFile cf, Method m, String name, List<TypeAnnotation> annos) {\n-        int index = m.attributes.getIndex(cf.constant_pool, name);\n-        if (index != -1) {\n-            Attribute attr = m.attributes.get(index);\n-            assert attr instanceof RuntimeTypeAnnotations_attribute;\n-            RuntimeTypeAnnotations_attribute tAttr = (RuntimeTypeAnnotations_attribute)attr;\n-            annos.addAll(Arrays.asList(tAttr.annotations));\n+    private static <T extends Attribute<T>> void findAnnotations(AttributedElement m, AttributeMapper<T> attrName, List<TAD> annos) {\n+        Attribute<T> attr = m.findAttribute(attrName).orElse(null);\n+        if (attr != null) {\n+            if (attr instanceof RuntimeVisibleTypeAnnotationsAttribute tAttr) {\n+                annos.addAll(Objects.requireNonNull(generateTADList(tAttr.annotations(), null)));\n+            } else if (attr instanceof RuntimeInvisibleTypeAnnotationsAttribute tAttr) {\n+                annos.addAll(Objects.requireNonNull(generateTADList(tAttr.annotations(), null)));\n+            } else throw new AssertionError();\n@@ -94,12 +80,11 @@\n-\n-        int cindex = m.attributes.getIndex(cf.constant_pool, Attribute.Code);\n-        if (cindex != -1) {\n-            Attribute cattr = m.attributes.get(cindex);\n-            assert cattr instanceof Code_attribute;\n-            Code_attribute cAttr = (Code_attribute)cattr;\n-            index = cAttr.attributes.getIndex(cf.constant_pool, name);\n-            if (index != -1) {\n-                Attribute attr = cAttr.attributes.get(index);\n-                assert attr instanceof RuntimeTypeAnnotations_attribute;\n-                RuntimeTypeAnnotations_attribute tAttr = (RuntimeTypeAnnotations_attribute)attr;\n-                annos.addAll(Arrays.asList(tAttr.annotations));\n+        if (m instanceof MethodModel mm) {\n+            CodeAttribute cAttr = mm.findAttribute(Attributes.CODE).orElse(null);\n+            if (cAttr != null) {\n+                Attribute<T> attr2 = cAttr.findAttribute(attrName).orElse(null);;\n+                if (attr2 != null) {\n+                    if (attr2 instanceof RuntimeVisibleTypeAnnotationsAttribute tAttr2) {\n+                        annos.addAll(Objects.requireNonNull(generateTADList(tAttr2.annotations(), cAttr)));\n+                    } else if (attr2 instanceof RuntimeInvisibleTypeAnnotationsAttribute tAttr2) {\n+                        annos.addAll(Objects.requireNonNull(generateTADList(tAttr2.annotations(), cAttr)));\n+                    } else throw new AssertionError();\n+                }\n@@ -110,9 +95,47 @@\n-    \/\/ test the result of Attributes.getIndex according to expectations\n-    \/\/ encoded in the method's name\n-    private static void findAnnotations(ClassFile cf, Field m, String name, List<TypeAnnotation> annos) {\n-        int index = m.attributes.getIndex(cf.constant_pool, name);\n-        if (index != -1) {\n-            Attribute attr = m.attributes.get(index);\n-            assert attr instanceof RuntimeTypeAnnotations_attribute;\n-            RuntimeTypeAnnotations_attribute tAttr = (RuntimeTypeAnnotations_attribute)attr;\n-            annos.addAll(Arrays.asList(tAttr.annotations));\n+    \/\/ get each target information and wrap with TAD (corresponding with TADescription in driver class)\n+    private static List<TAD> generateTADList(List<TypeAnnotation> annos, CodeAttribute cAttr) {\n+        List<TAD> result = new ArrayList<>();\n+        for (TypeAnnotation anno: annos) {\n+            TAD tad = new TAD();\n+            tad.annotation = anno.className().stringValue();\n+            tad.type = anno.targetInfo().targetType();\n+            switch (anno.targetInfo().targetType()) {\n+                case CAST, CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT, METHOD_INVOCATION_TYPE_ARGUMENT -> {\n+                    if (cAttr == null) throw new AssertionError(\"Invalid Annotation\");\n+                    tad.typeIndex = ((TypeAnnotation.TypeArgumentTarget) anno.targetInfo()).typeArgumentIndex();\n+                    tad.offset = cAttr.labelToBci(((TypeAnnotation.TypeArgumentTarget) anno.targetInfo()).target());\n+                }\n+                case CLASS_EXTENDS -> tad.typeIndex = ((TypeAnnotation.SupertypeTarget) anno.targetInfo()).supertypeIndex();\n+                case CLASS_TYPE_PARAMETER, METHOD_TYPE_PARAMETER -> tad.paramIndex = ((TypeAnnotation.TypeParameterTarget) anno.targetInfo()).typeParameterIndex();\n+                case CLASS_TYPE_PARAMETER_BOUND, METHOD_TYPE_PARAMETER_BOUND -> {\n+                    tad.paramIndex = ((TypeAnnotation.TypeParameterBoundTarget) anno.targetInfo()).typeParameterIndex();\n+                    tad.boundIndex = ((TypeAnnotation.TypeParameterBoundTarget) anno.targetInfo()).boundIndex();\n+                }\n+                case EXCEPTION_PARAMETER -> tad.exceptionIndex = ((TypeAnnotation.CatchTarget) anno.targetInfo()).exceptionTableIndex();\n+                case INSTANCEOF, NEW -> {\n+                    if (cAttr == null) throw new AssertionError(\"Invalid Annotation\");\n+                    tad.offset = cAttr.labelToBci(((TypeAnnotation.OffsetTarget) anno.targetInfo()).target());\n+                }\n+                case LOCAL_VARIABLE, RESOURCE_VARIABLE -> {\n+                    if (cAttr == null) throw new AssertionError(\"Invalid Annotation\");\n+                    TypeAnnotation.LocalVarTarget localTarget = (TypeAnnotation.LocalVarTarget) anno.targetInfo();\n+                    for (TypeAnnotation.LocalVarTargetInfo localInfo : localTarget.table()) {\n+                        tad.lvarIndex.add(localInfo.index());\n+                        tad.lvarOffset.add(cAttr.labelToBci(localInfo.startLabel()));\n+                        tad.lvarLength.add(cAttr.labelToBci(localInfo.endLabel()) - cAttr.labelToBci(localInfo.startLabel()));\n+                    }\n+                }\n+                case METHOD_FORMAL_PARAMETER -> tad.paramIndex = ((TypeAnnotation.FormalParameterTarget) anno.targetInfo()).formalParameterIndex();\n+                case THROWS -> tad.typeIndex = ((TypeAnnotation.ThrowsTarget) anno.targetInfo()).throwsTargetIndex();\n+                default -> {}\n+            }\n+            for (TypeAnnotation.TypePathComponent pathComponent : anno.targetPath()) {\n+                switch (pathComponent.typePathKind()) {\n+                    case ARRAY -> tad.genericLocation.add(0);\n+                    case INNER_TYPE -> tad.genericLocation.add(1);\n+                    case WILDCARD -> tad.genericLocation.add(2);\n+                    case TYPE_ARGUMENT -> tad.genericLocation.add(3);\n+                }\n+                tad.genericLocation.add(pathComponent.typeArgumentIndex());\n+            }\n+            result.add(tad);\n@@ -120,0 +143,1 @@\n+        return result;\n@@ -127,1 +151,1 @@\n-    private static boolean areEquals(int[] a, int[] a2) {\n+    private static boolean areEquals(List<Integer> a, List<Integer> a2) {\n@@ -133,2 +157,2 @@\n-        int length = a.length;\n-        if (a2.length != length)\n+        int length = a.size();\n+        if (a2.size() != length)\n@@ -138,1 +162,1 @@\n-            if (a[i] != a2[i] && a[i] != IGNORE_VALUE && a2[i] != IGNORE_VALUE)\n+            if (!Objects.equals(a.get(i), a2.get(i)) && a.get(i) != IGNORE_VALUE && a2.get(i) != IGNORE_VALUE)\n@@ -144,1 +168,1 @@\n-    public static boolean areEquals(TypeAnnotation.Position p1, TypeAnnotation.Position p2) {\n+    public static boolean areEquals(TAD p1, TAD p2) {\n@@ -147,1 +171,1 @@\n-                (p1.location.equals(p2.location)) &&\n+                areEquals(p1.genericLocation, p2.genericLocation) &&\n@@ -152,4 +176,4 @@\n-                areEquals(p1.bound_index, p2.bound_index) &&\n-                areEquals(p1.parameter_index, p2.parameter_index) &&\n-                areEquals(p1.type_index, p2.type_index) &&\n-                areEquals(p1.exception_index, p2.exception_index);\n+                areEquals(p1.boundIndex, p2.boundIndex) &&\n+                areEquals(p1.paramIndex, p2.paramIndex) &&\n+                areEquals(p1.typeIndex, p2.typeIndex) &&\n+                areEquals(p1.exceptionIndex, p2.exceptionIndex);\n@@ -159,1 +183,1 @@\n-    private static TypeAnnotation findAnnotation(String name, List<TypeAnnotation> annotations, ClassFile cf) throws InvalidIndex, UnexpectedEntry {\n+    private static TAD findAnnotation(String name, List<TAD> annotations) {\n@@ -161,2 +185,2 @@\n-        for (TypeAnnotation anno : annotations) {\n-            String actualName = cf.constant_pool.getUTF8Value(anno.annotation.type_index);\n+        for (TAD anno : annotations) {\n+            String actualName = anno.annotation;\n@@ -169,2 +193,2 @@\n-    public static boolean compare(Map<String, TypeAnnotation.Position> expectedAnnos,\n-            List<TypeAnnotation> actualAnnos, ClassFile cf) throws InvalidIndex, UnexpectedEntry {\n+    public static boolean compare(Map<String, TAD> expectedAnnos,\n+            List<TAD> actualAnnos) {\n@@ -177,5 +201,5 @@\n-        for (Map.Entry<String, TypeAnnotation.Position> e : expectedAnnos.entrySet()) {\n-            String aName = e.getKey();\n-            TypeAnnotation.Position expected = e.getValue();\n-            TypeAnnotation actual = findAnnotation(aName, actualAnnos, cf);\n-            if (actual == null)\n+        for (Map.Entry<String, TAD> expectedAno : expectedAnnos.entrySet()) {\n+            String aName = expectedAno.getKey();\n+            TAD expectedTAD = expectedAno.getValue();\n+            TAD actualTAD = findAnnotation(aName, actualAnnos);\n+            if (actualTAD == null)\n@@ -184,1 +208,1 @@\n-            if (!areEquals(expected, actual.position)) {\n+            if (!areEquals(expectedTAD, actualTAD)) {\n@@ -186,2 +210,2 @@\n-                        \"\\n  Expected: \" + expected.toString() +\n-                        \"\\n  Found: \" + actual.position.toString());\n+                        \"\\n  Expected: \" + expectedTAD +\n+                        \"\\n  Found: \" + actualTAD);\n@@ -192,0 +216,14 @@\n+    public static class TAD {\n+        String annotation;\n+        TypeAnnotation.TargetType type;\n+        int typeIndex = IGNORE_VALUE, paramIndex = IGNORE_VALUE, boundIndex = IGNORE_VALUE, exceptionIndex = IGNORE_VALUE, offset = IGNORE_VALUE;\n+        List<Integer> lvarOffset = new ArrayList<>(), lvarLength = new ArrayList<>(), lvarIndex = new ArrayList<>(), genericLocation = new ArrayList<>();\n+        public TAD(String a, TypeAnnotation.TargetType t, int tIdx, int pIndx, int bIdx, int eIdx,\n+                   int ofs, List<Integer> lvarOfs, List<Integer> lvarLen, List<Integer> lvarIdx, List<Integer> genericLoc) {\n+            annotation = a; type = t; typeIndex = tIdx;\n+            paramIndex = pIndx; boundIndex = bIdx; exceptionIndex = eIdx;\n+            offset = ofs; lvarOffset = lvarOfs; lvarLength = lvarLen; lvarIndex = lvarIdx;\n+            genericLocation = genericLoc;\n+        }\n+        public TAD() {}\n+    }\n@@ -197,2 +235,2 @@\n-    public final Map<String, TypeAnnotation.Position> expected;\n-    public final List<TypeAnnotation> found;\n+    public final Map<String, ReferenceInfoUtil.TAD> expected;\n+    public final List<ReferenceInfoUtil.TAD> found;\n@@ -204,1 +242,1 @@\n-    public ComparisionException(String message, Map<String, TypeAnnotation.Position> expected, List<TypeAnnotation> found) {\n+    public ComparisionException(String message, Map<String, ReferenceInfoUtil.TAD> expected, List<ReferenceInfoUtil.TAD> found) {\n","filename":"test\/langtools\/tools\/javac\/annotations\/typeAnnotations\/referenceinfos\/ReferenceInfoUtil.java","additions":132,"deletions":94,"binary":false,"changes":226,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-import static com.sun.tools.classfile.TypeAnnotation.TargetType.*;\n+import static jdk.internal.classfile.TypeAnnotation.TargetType.*;\n@@ -29,1 +29,6 @@\n- * @modules jdk.jdeps\/com.sun.tools.classfile\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.classfile.instruction\n+ *          java.base\/jdk.internal.classfile.components\n+ *          java.base\/jdk.internal.classfile.impl\n","filename":"test\/langtools\/tools\/javac\/annotations\/typeAnnotations\/referenceinfos\/RepeatingTypeAnnotations.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -28,1 +28,6 @@\n- * @modules jdk.jdeps\/com.sun.tools.classfile\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.classfile.instruction\n+ *          java.base\/jdk.internal.classfile.components\n+ *          java.base\/jdk.internal.classfile.impl\n@@ -33,1 +38,1 @@\n-import static com.sun.tools.classfile.TypeAnnotation.TargetType.RESOURCE_VARIABLE;\n+import static jdk.internal.classfile.TypeAnnotation.TargetType.RESOURCE_VARIABLE;\n","filename":"test\/langtools\/tools\/javac\/annotations\/typeAnnotations\/referenceinfos\/ResourceVariable.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-import static com.sun.tools.classfile.TypeAnnotation.TargetType.*;\n+import static jdk.internal.classfile.TypeAnnotation.TargetType.*;\n@@ -30,1 +30,6 @@\n- * @modules jdk.jdeps\/com.sun.tools.classfile\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.classfile.instruction\n+ *          java.base\/jdk.internal.classfile.components\n+ *          java.base\/jdk.internal.classfile.impl\n","filename":"test\/langtools\/tools\/javac\/annotations\/typeAnnotations\/referenceinfos\/TypeCasts.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-import static com.sun.tools.classfile.TypeAnnotation.TargetType.*;\n+import static jdk.internal.classfile.TypeAnnotation.TargetType.*;\n@@ -30,1 +30,6 @@\n- * @modules jdk.jdeps\/com.sun.tools.classfile\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.classfile.instruction\n+ *          java.base\/jdk.internal.classfile.components\n+ *          java.base\/jdk.internal.classfile.impl\n","filename":"test\/langtools\/tools\/javac\/annotations\/typeAnnotations\/referenceinfos\/TypeTests.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -32,1 +32,6 @@\n- *          jdk.jdeps\/com.sun.tools.classfile\n+ *          java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.classfile.instruction\n+ *          java.base\/jdk.internal.classfile.components\n+ *          java.base\/jdk.internal.classfile.impl\n@@ -40,6 +45,4 @@\n-import com.sun.tools.classfile.ClassFile;\n-import com.sun.tools.classfile.Method;\n-import com.sun.tools.classfile.Attribute;\n-import com.sun.tools.classfile.Code_attribute;\n-import com.sun.tools.classfile.Instruction;\n-import com.sun.tools.classfile.ConstantPool.CONSTANT_Class_info;\n+import jdk.internal.classfile.*;\n+import jdk.internal.classfile.attribute.*;\n+import jdk.internal.classfile.constantpool.ClassEntry;\n+import jdk.internal.classfile.instruction.*;\n@@ -53,1 +56,1 @@\n-    ClassFile cf;\n+    ClassModel cf;\n@@ -100,1 +103,1 @@\n-        cf = ClassFile.read(curPath.resolve(\"IntersectionTypeTest.class\"));\n+        cf = Classfile.of().parse(curPath.resolve(\"IntersectionTypeTest.class\"));\n@@ -102,5 +105,5 @@\n-        for (Method method : cf.methods) {\n-            if (\"test\".equals(method.getName(cf.constant_pool))) {\n-                Code_attribute code_attribute = (Code_attribute) method.attributes.get(Attribute.Code);\n-                for (Instruction instruction : code_attribute.getInstructions()) {\n-                    if (\"checkcast\".equals(instruction.getMnemonic())) {\n+        for (MethodModel method : cf.methods()) {\n+            if (method.methodName().equalsString(\"test\")) {\n+                CodeAttribute code_attribute = method.findAttribute(Attributes.CODE).orElseThrow();\n+                for (CodeElement ce : code_attribute.elementList()) {\n+                    if (ce instanceof Instruction instruction && Opcode.CHECKCAST == instruction.opcode()) {\n@@ -120,4 +123,6 @@\n-    public void checkClassName(Instruction ins, String expected) throws Exception {\n-        int classIndex = ins.getUnsignedShort(1);\n-        CONSTANT_Class_info classInfo = cf.constant_pool.getClassInfo(classIndex);\n-        String className = classInfo.getName();\n+    public void checkClassName(Instruction ins, String expected) {\n+        String className = \"\";\n+        if (ins instanceof TypeCheckInstruction typeCheckInstruction) {\n+            ClassEntry classInfo = typeCheckInstruction.type();\n+            className = classInfo.asInternalName();\n+        }\n","filename":"test\/langtools\/tools\/javac\/cast\/intersection\/DuplicatedCheckcastTest.java","additions":23,"deletions":18,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -28,1 +28,6 @@\n- *  @modules jdk.jdeps\/com.sun.tools.classfile\n+ *  @modules java.base\/jdk.internal.classfile\n+ *           java.base\/jdk.internal.classfile.attribute\n+ *           java.base\/jdk.internal.classfile.constantpool\n+ *           java.base\/jdk.internal.classfile.instruction\n+ *           java.base\/jdk.internal.classfile.components\n+ *           java.base\/jdk.internal.classfile.impl\n@@ -35,1 +40,2 @@\n-import com.sun.tools.classfile.*;\n+import jdk.internal.classfile.*;\n+import jdk.internal.classfile.attribute.*;\n@@ -39,1 +45,1 @@\n-    public static void main(String[] args) throws IOException, ConstantPoolException {\n+    public static void main(String[] args) throws IOException {\n@@ -43,1 +49,1 @@\n-    private void run() throws IOException, ConstantPoolException {\n+    private void run() throws IOException {\n@@ -45,5 +51,4 @@\n-        for (File classFile : testClasses.listFiles(f -> f.getName().endsWith(\".class\"))) {\n-            ClassFile cf = ClassFile.read(classFile);\n-            if (cf.getName().matches(\".*\\\\$[0-9]+\")) {\n-                EnclosingMethod_attribute encl =\n-                        (EnclosingMethod_attribute) cf.getAttribute(Attribute.EnclosingMethod);\n+        for (File classFile : Objects.requireNonNull(testClasses.listFiles(f -> f.getName().endsWith(\".class\")))) {\n+            ClassModel cf = Classfile.of().parse(classFile.toPath());\n+            if (cf.thisClass().asInternalName().matches(\".*\\\\$[0-9]+\")) {\n+                EnclosingMethodAttribute encl = cf.findAttribute(Attributes.ENCLOSING_METHOD).orElse(null);\n@@ -51,3 +56,3 @@\n-                    if (encl.method_index != 0)\n-                        throw new IllegalStateException(\"Invalid EnclosingMethod.method_index: \" +\n-                                                        encl.method_index + \".\");\n+                    if (encl.enclosingMethodName().isPresent())\n+                        throw new IllegalStateException(\"Invalid EnclosingMethod.method: \" +\n+                                                        encl.enclosingMethodName().get().stringValue() + \".\");\n@@ -56,2 +61,1 @@\n-            InnerClasses_attribute attr =\n-                    (InnerClasses_attribute) cf.getAttribute(Attribute.InnerClasses);\n+            InnerClassesAttribute attr = cf.findAttribute(Attributes.INNER_CLASSES).orElse(null);\n@@ -59,2 +63,2 @@\n-                for (InnerClasses_attribute.Info info : attr.classes) {\n-                    if (cf.major_version < 51)\n+                for (InnerClassInfo info : attr.classes()) {\n+                    if (cf.majorVersion() < 51)\n@@ -62,5 +66,4 @@\n-                    if (info.inner_name_index == 0 && info.outer_class_info_index != 0)\n-                        throw new IllegalStateException(\"Invalid outer_class_info_index=\" +\n-                                                        info.outer_class_info_index +\n-                                                        \"; inner_name_index=\" +\n-                                                        info.inner_name_index + \".\");\n+                    if (info.innerName().isEmpty() && info.outerClass().isPresent() )\n+                        throw new IllegalStateException(\"Invalid outer_class_info: \" +\n+                                                        info.outerClass().get().asInternalName() +\n+                                                        \"; inner_name is empty\");\n","filename":"test\/langtools\/tools\/javac\/classfiles\/InnerClasses\/SyntheticClasses.java","additions":24,"deletions":21,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -31,1 +31,6 @@\n- *          jdk.jdeps\/com.sun.tools.classfile\n+ *          java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.classfile.instruction\n+ *          java.base\/jdk.internal.classfile.components\n+ *          java.base\/jdk.internal.classfile.impl\n@@ -38,3 +43,2 @@\n-import com.sun.tools.classfile.ClassFile;\n-import com.sun.tools.classfile.ConstantPool;\n-import com.sun.tools.classfile.ConstantPool.*;\n+import jdk.internal.classfile.*;\n+import jdk.internal.classfile.constantpool.*;\n@@ -78,2 +82,2 @@\n-        ClassFile cf = ClassFile.read(curPath.resolve(\"Test.class\"));\n-        ConstantPool cp = cf.constant_pool;\n+        ClassModel cf = Classfile.of().parse(curPath.resolve(\"Test.class\"));\n+        ConstantPool cp = cf.constantPool();\n@@ -81,13 +85,8 @@\n-        for (CPInfo cpInfo : cp.entries()) {\n-            if (cpInfo instanceof CONSTANT_Methodref_info) {\n-                int class_index = ((CONSTANT_Methodref_info) cpInfo).class_index;\n-                int name_and_type_index = ((CONSTANT_Methodref_info) cpInfo).name_and_type_index;\n-                int class_name_index = ((CONSTANT_Class_info)\n-                        cp.getClassInfo(class_index)).name_index;\n-                int method_name_index = ((CONSTANT_NameAndType_info)\n-                        cp.getNameAndTypeInfo(name_and_type_index)).name_index;\n-                int method_type_name_index = ((CONSTANT_NameAndType_info)\n-                        cp.getNameAndTypeInfo(name_and_type_index)).type_index;\n-                if (\"[Ljava\/lang\/Object;\".equals(cp.getUTF8Value(class_name_index)) &&\n-                        \"clone\".equals(cp.getUTF8Value(method_name_index)) &&\n-                        \"()Ljava\/lang\/Object;\".equals(cp.getUTF8Value(method_type_name_index))) {\n+        for (int i = 1; i < cp.entryCount(); i += cp.entryByIndex(i).width()) {\n+            if (cp.entryByIndex(i) instanceof MethodRefEntry methodRefEntry) {\n+                String class_name = methodRefEntry.owner().asInternalName();\n+                String method_name = methodRefEntry.name().stringValue();\n+                String method_type = methodRefEntry.type().stringValue();\n+                if (\"[Ljava\/lang\/Object;\".equals(class_name) &&\n+                        \"clone\".equals(method_name) &&\n+                        \"()Ljava\/lang\/Object;\".equals(method_type)) {\n","filename":"test\/langtools\/tools\/javac\/classfiles\/T8255757\/T8255757.java","additions":18,"deletions":19,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -28,1 +28,6 @@\n- * @modules jdk.jdeps\/com.sun.tools.classfile\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.classfile.instruction\n+ *          java.base\/jdk.internal.classfile.components\n+ *          java.base\/jdk.internal.classfile.impl\n@@ -38,3 +43,1 @@\n-import com.sun.tools.classfile.ClassFile;\n-import com.sun.tools.classfile.ClassWriter;\n-import com.sun.tools.classfile.Field;\n+import jdk.internal.classfile.*;\n@@ -48,5 +51,2 @@\n-import java.io.File;\n-import java.io.FileWriter;\n-import java.io.IOException;\n-import java.io.PrintWriter;\n-import java.io.StringWriter;\n+import java.io.*;\n+import java.nio.file.Files;\n@@ -188,10 +188,11 @@\n-        ClassFile cf = ClassFile.read(file);\n-        Field a = cf.fields[0];\n-        Field b = cf.fields[1];\n-        Field[] fields = {\n-            new Field(b.access_flags, b.name_index, b.descriptor, a.attributes),\n-        };\n-        cf = new ClassFile(cf.magic, Target.JDK1_7.minorVersion, Target.JDK1_7.majorVersion,\n-                cf.constant_pool, cf.access_flags, cf.this_class, cf.super_class, cf.interfaces,\n-                fields, cf.methods, cf.attributes);\n-        new ClassWriter().write(cf, file);\n+        ClassModel cf = Classfile.of().parse(file.toPath());\n+        FieldModel a = cf.fields().getFirst();\n+        FieldModel b = cf.fields().get(1);\n+        byte[] Bytes = Classfile.of().transform(cf, ClassTransform\n+                .dropping(ce -> ce instanceof ClassfileVersion || ce instanceof FieldModel)\n+                .andThen(ClassTransform.endHandler(classBuilder -> classBuilder\n+                        .withField(b.fieldName(), b.fieldType(), fieldBuilder -> {\n+                            fieldBuilder.withFlags(b.flags().flagsMask());\n+                            a.attributes().forEach(e -> fieldBuilder.with((FieldElement) e));})\n+                        .withVersion(Target.JDK1_7.majorVersion, Target.JDK1_7.minorVersion))));\n+        Files.write(file.toPath(), Bytes);\n","filename":"test\/langtools\/tools\/javac\/classreader\/8171132\/BadConstantValue.java","additions":20,"deletions":19,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -37,1 +37,6 @@\n- *          jdk.jdeps\/com.sun.tools.classfile\n+ *          java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.classfile.instruction\n+ *          java.base\/jdk.internal.classfile.components\n+ *          java.base\/jdk.internal.classfile.impl\n@@ -57,7 +62,4 @@\n-import com.sun.tools.classfile.Attribute;\n-import com.sun.tools.classfile.BootstrapMethods_attribute;\n-import com.sun.tools.classfile.ClassFile;\n-import com.sun.tools.classfile.Code_attribute;\n-import com.sun.tools.classfile.ConstantPool.CONSTANT_InvokeDynamic_info;\n-import com.sun.tools.classfile.ConstantPool.CONSTANT_NameAndType_info;\n-import com.sun.tools.classfile.Instruction;\n+import jdk.internal.classfile.*;\n+import jdk.internal.classfile.attribute.*;\n+import jdk.internal.classfile.constantpool.*;\n+import jdk.internal.classfile.instruction.*;\n@@ -169,4 +171,3 @@\n-        ClassFile cf = ClassFile.read(testClass);\n-        BootstrapMethods_attribute bootAttr =\n-                (BootstrapMethods_attribute) cf.attributes.get(Attribute.BootstrapMethods);\n-        if (bootAttr.bootstrap_method_specifiers.length != 1) {\n+        ClassModel cf = Classfile.of().parse(testClass);\n+        BootstrapMethodsAttribute bootAttr = cf.findAttribute(Attributes.BOOTSTRAP_METHODS).orElseThrow();\n+        if (bootAttr.bootstrapMethodsSize() != 1) {\n@@ -174,1 +175,1 @@\n-                                     bootAttr.bootstrap_method_specifiers.length);\n+                                     bootAttr.bootstrapMethodsSize());\n@@ -176,4 +177,3 @@\n-        Code_attribute codeAttr =\n-                (Code_attribute) cf.methods[1].attributes.get(Attribute.Code);\n-        Set<Integer> seenBootstraps = new HashSet<>();\n-        Set<Integer> seenNameAndTypes = new HashSet<>();\n+        CodeAttribute codeAttr = cf.methods().get(1).findAttribute(Attributes.CODE).orElseThrow();\n+        Set<BootstrapMethodEntry> seenBootstraps = new HashSet<>();\n+        Set<NameAndTypeEntry> seenNameAndTypes = new HashSet<>();\n@@ -181,11 +181,13 @@\n-        for (Instruction i : codeAttr.getInstructions()) {\n-            switch (i.getOpcode()) {\n-                case INVOKEDYNAMIC -> {\n-                    int idx = i.getUnsignedShort(1);\n-                    CONSTANT_InvokeDynamic_info dynamicInfo =\n-                            (CONSTANT_InvokeDynamic_info) cf.constant_pool.get(idx);\n-                    seenBootstraps.add(dynamicInfo.bootstrap_method_attr_index);\n-                    seenNameAndTypes.add(dynamicInfo.name_and_type_index);\n-                    CONSTANT_NameAndType_info nameAndTypeInfo =\n-                            cf.constant_pool.getNameAndTypeInfo(dynamicInfo.name_and_type_index);\n-                    seenNames.add(nameAndTypeInfo.getName());\n+        for (CodeElement i : codeAttr.elementList()) {\n+            if (i instanceof Instruction instruction) {\n+                switch (instruction ) {\n+                    case InvokeDynamicInstruction indy -> {\n+                        InvokeDynamicEntry dynamicInfo = indy.invokedynamic();\n+                        seenBootstraps.add(dynamicInfo.bootstrap());\n+                        seenNameAndTypes.add(dynamicInfo.nameAndType());\n+                        NameAndTypeEntry nameAndTypeInfo = dynamicInfo.nameAndType();\n+                        seenNames.add(nameAndTypeInfo.name().stringValue());\n+                    }\n+                    case ReturnInstruction returnInstruction -> {\n+                    }\n+                    default -> throw new AssertionError(\"Unexpected instruction: \" + instruction.opcode());\n@@ -193,3 +195,0 @@\n-                case RETURN -> {}\n-                default -> throw new AssertionError(\"Unexpected instruction: \" + i.getOpcode());\n-            }\n@@ -197,0 +196,1 @@\n+        }\n","filename":"test\/langtools\/tools\/javac\/classwriter\/IndyCorrectInvocationName.java","additions":31,"deletions":31,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -37,1 +37,6 @@\n- *          jdk.jdeps\/com.sun.tools.classfile\n+ *          java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.classfile.instruction\n+ *          java.base\/jdk.internal.classfile.components\n+ *          java.base\/jdk.internal.classfile.impl\n@@ -56,5 +61,2 @@\n-import com.sun.tools.classfile.Attribute;\n-import com.sun.tools.classfile.ClassFile;\n-import com.sun.tools.classfile.Code_attribute;\n-import com.sun.tools.classfile.Instruction;\n-import com.sun.tools.classfile.Opcode;\n+import jdk.internal.classfile.*;\n+import jdk.internal.classfile.attribute.CodeAttribute;\n@@ -137,3 +139,2 @@\n-        ClassFile cf = ClassFile.read(testClass);\n-        Code_attribute codeAttr =\n-                (Code_attribute) cf.methods[1].attributes.get(Attribute.Code);\n+        ClassModel cf = Classfile.of().parse(testClass);\n+        CodeAttribute codeAttr = cf.methods().get(1).findAttribute(Attributes.CODE).orElseThrow();\n@@ -141,2 +142,2 @@\n-        for (Instruction i : codeAttr.getInstructions()) {\n-            if (i.getOpcode() == Opcode.I2C) {\n+        for (CodeElement i : codeAttr.elementList()) {\n+            if (i instanceof Instruction ins && ins.opcode() == Opcode.I2C) {\n","filename":"test\/langtools\/tools\/javac\/code\/CharImmediateValue.java","additions":12,"deletions":11,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -29,1 +29,6 @@\n- * @modules jdk.jdeps\/com.sun.tools.classfile\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.classfile.instruction\n+ *          java.base\/jdk.internal.classfile.components\n+ *          java.base\/jdk.internal.classfile.impl\n@@ -40,1 +45,1 @@\n-import com.sun.tools.classfile.*;\n+import jdk.internal.classfile.*;\n@@ -62,9 +67,3 @@\n-        ClassFile cf = ClassFile.read(classfile);\n-\n-        cf = new ClassFile(cf.magic, Target.JDK1_7.minorVersion,\n-                 Target.JDK1_7.majorVersion, cf.constant_pool, cf.access_flags,\n-                cf.this_class, cf.super_class, cf.interfaces, cf.fields,\n-                cf.methods, cf.attributes);\n-\n-        new ClassWriter().write(cf, classfile);\n-\n+        ClassModel cf = Classfile.of().parse(classfile.toPath());\n+        Classfile.of().transform(cf, ClassTransform.dropping(ce -> ce instanceof ClassfileVersion)\n+                .andThen(ClassTransform.endHandler(classBuilder -> classBuilder.withVersion(Target.JDK1_7.majorVersion, Target.JDK1_7.minorVersion))));\n","filename":"test\/langtools\/tools\/javac\/defaultMethods\/BadClassfile.java","additions":10,"deletions":11,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -28,1 +28,6 @@\n- * @modules jdk.jdeps\/com.sun.tools.classfile\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.classfile.instruction\n+ *          java.base\/jdk.internal.classfile.components\n+ *          java.base\/jdk.internal.classfile.impl\n@@ -33,2 +38,1 @@\n-import java.util.ArrayList;\n-import java.util.List;\n+import jdk.internal.classfile.*;\n@@ -37,8 +41,2 @@\n-\n-import com.sun.tools.classfile.ClassFile;\n-import com.sun.tools.classfile.ConstantPoolException;\n-import com.sun.tools.classfile.Descriptor;\n-import com.sun.tools.classfile.Descriptor.InvalidDescriptor;\n-import com.sun.tools.classfile.Method;\n-\n-import static com.sun.tools.classfile.AccessFlags.ACC_STRICT;\n+import java.util.ArrayList;\n+import java.util.List;\n@@ -55,2 +53,1 @@\n-    public static void main(String[] args)\n-            throws IOException, ConstantPoolException, InvalidDescriptor {\n+    public static void main(String[] args) throws IOException {\n@@ -60,2 +57,1 @@\n-    private void run()\n-            throws IOException, ConstantPoolException, InvalidDescriptor {\n+    private void run() throws IOException {\n@@ -73,5 +69,1 @@\n-    void check(String dir, String... fileNames)\n-        throws\n-            IOException,\n-            ConstantPoolException,\n-            Descriptor.InvalidDescriptor {\n+    void check(String dir, String... fileNames) throws IOException {\n@@ -79,1 +71,1 @@\n-            ClassFile classFileToCheck = ClassFile.read(new File(dir, fileName));\n+            ClassModel classFileToCheck = Classfile.of().parse(new File(dir, fileName).toPath());\n@@ -81,2 +73,2 @@\n-            for (Method method : classFileToCheck.methods) {\n-                if ((method.access_flags.flags & ACC_STRICT) == 0) {\n+            for (MethodModel method : classFileToCheck.methods()) {\n+                if ((method.flags().flagsMask() & Classfile.ACC_STRICT) == 0) {\n@@ -84,2 +76,2 @@\n-                            method.getName(classFileToCheck.constant_pool),\n-                            classFileToCheck.getName()));\n+                            method.methodName().stringValue(),\n+                            classFileToCheck.thisClass().asInternalName()));\n","filename":"test\/langtools\/tools\/javac\/defaultMethods\/CheckACC_STRICTFlagOnDefaultMethodTest.java","additions":17,"deletions":25,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -28,1 +28,6 @@\n- * @modules jdk.jdeps\/com.sun.tools.classfile\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.classfile.instruction\n+ *          java.base\/jdk.internal.classfile.components\n+ *          java.base\/jdk.internal.classfile.impl\n@@ -31,9 +36,4 @@\n-import com.sun.tools.classfile.AccessFlags;\n-import com.sun.tools.classfile.Attribute;\n-import com.sun.tools.classfile.ClassFile;\n-import com.sun.tools.classfile.ConstantPool.*;\n-import com.sun.tools.classfile.Code_attribute;\n-import com.sun.tools.classfile.Instruction;\n-import com.sun.tools.classfile.Method;\n-\n-import com.sun.tools.classfile.Opcode;\n+import jdk.internal.classfile.*;\n+import jdk.internal.classfile.attribute.CodeAttribute;\n+import jdk.internal.classfile.constantpool.MemberRefEntry;\n+import jdk.internal.classfile.instruction.InvokeInstruction;\n@@ -70,6 +70,6 @@\n-            ClassFile cf = ClassFile.read(f);\n-            Method testMethod = null;\n-            Code_attribute codeAttr = null;\n-            for (Method m : cf.methods) {\n-                codeAttr = (Code_attribute)m.attributes.get(Attribute.Code);\n-                String mname = m.getName(cf.constant_pool);\n+            ClassModel cf = Classfile.of().parse(f.toPath());\n+            MethodModel testMethod = null;\n+            CodeAttribute codeAttr = null;\n+            for (MethodModel m : cf.methods()) {\n+                codeAttr = m.findAttribute(Attributes.CODE).orElse(null);\n+                String mname = m.methodName().stringValue();\n@@ -86,1 +86,1 @@\n-            if (testMethod.access_flags.is(AccessFlags.ACC_ABSTRACT)) {\n+            if ((testMethod.flags().flagsMask() & Classfile.ACC_ABSTRACT) != 0) {\n@@ -94,2 +94,2 @@\n-            for (Instruction instr : codeAttr.getInstructions()) {\n-                if (instr.getOpcode() == Opcode.INVOKESTATIC) {\n+            for (CodeElement instr : codeAttr.elementList()) {\n+                if (instr instanceof InvokeInstruction ins && ins.opcode() == Opcode.INVOKESTATIC) {\n@@ -97,5 +97,4 @@\n-                    int pc_index = instr.getShort(1);\n-                    CONSTANT_Methodref_info mref = (CONSTANT_Methodref_info)cf.constant_pool.get(pc_index);\n-                    String className = mref.getClassName();\n-                    String targetName = mref.getNameAndTypeInfo().getName();\n-                    String targetType = mref.getNameAndTypeInfo().getType();\n+                    MemberRefEntry mref = ins.method();\n+                    String className = mref.owner().asInternalName();\n+                    String targetName = mref.name().stringValue();\n+                    String targetType = mref.type().stringValue();\n","filename":"test\/langtools\/tools\/javac\/defaultMethods\/TestDefaultBody.java","additions":23,"deletions":24,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -28,1 +28,6 @@\n- * @modules jdk.jdeps\/com.sun.tools.classfile\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.classfile.instruction\n+ *          java.base\/jdk.internal.classfile.components\n+ *          java.base\/jdk.internal.classfile.impl\n@@ -31,3 +36,1 @@\n-import com.sun.tools.classfile.ClassFile;\n-import com.sun.tools.classfile.ConstantPool.*;\n-import com.sun.tools.classfile.Method;\n+import jdk.internal.classfile.*;\n@@ -74,3 +77,3 @@\n-            ClassFile cf = ClassFile.read(f);\n-            for (Method m : cf.methods) {\n-                String mname = m.getName(cf.constant_pool);\n+            ClassModel cf = Classfile.of().parse(f.toPath());\n+            for (MethodModel m : cf.methods()) {\n+                String mname = m.methodName().stringValue();\n","filename":"test\/langtools\/tools\/javac\/defaultMethods\/TestNoBridgeOnDefaults.java","additions":10,"deletions":7,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -28,1 +28,6 @@\n- * @modules jdk.jdeps\/com.sun.tools.classfile\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.classfile.instruction\n+ *          java.base\/jdk.internal.classfile.components\n+ *          java.base\/jdk.internal.classfile.impl\n@@ -34,7 +39,4 @@\n-import com.sun.tools.classfile.Attribute;\n-import com.sun.tools.classfile.ClassFile;\n-import com.sun.tools.classfile.Code_attribute;\n-import com.sun.tools.classfile.ConstantPool.CPRefInfo;\n-import com.sun.tools.classfile.Instruction;\n-import com.sun.tools.classfile.Method;\n-import com.sun.tools.classfile.Opcode;\n+import jdk.internal.classfile.*;\n+import jdk.internal.classfile.attribute.CodeAttribute;\n+import jdk.internal.classfile.constantpool.MemberRefEntry;\n+import jdk.internal.classfile.instruction.InvokeInstruction;\n@@ -89,8 +91,7 @@\n-            final ClassFile cf = ClassFile.read(file);\n-            for (Method m : cf.methods) {\n-                Code_attribute codeAttr = (Code_attribute)m.attributes.get(Attribute.Code);\n-                for (Instruction instr : codeAttr.getInstructions()) {\n-                    if (instr.getOpcode() == Opcode.INVOKESPECIAL) {\n-                        int pc_index = instr.getShort(1);\n-                        CPRefInfo ref = (CPRefInfo)cf.constant_pool.get(pc_index);\n-                        String className = ref.getClassName();\n+            final ClassModel cf = Classfile.of().parse(file.toPath());\n+            for (MethodModel m : cf.methods()) {\n+                CodeAttribute codeAttr = m.findAttribute(Attributes.CODE).orElseThrow();\n+                for (CodeElement ce : codeAttr.elementList()) {\n+                    if (ce instanceof InvokeInstruction instr && instr.opcode() == Opcode.INVOKESPECIAL) {\n+                        MemberRefEntry ref = instr.method();\n+                        String className = ref.owner().asInternalName();\n","filename":"test\/langtools\/tools\/javac\/defaultMethods\/super\/TestDirectSuperInterfaceInvoke.java","additions":17,"deletions":16,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -30,1 +30,6 @@\n- *          jdk.jdeps\/com.sun.tools.classfile\n+ *          java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.classfile.instruction\n+ *          java.base\/jdk.internal.classfile.components\n+ *          java.base\/jdk.internal.classfile.impl\n@@ -37,1 +42,2 @@\n-import com.sun.tools.classfile.*;\n+import jdk.internal.classfile.*;\n+import jdk.internal.classfile.constantpool.*;\n@@ -493,4 +499,4 @@\n-            ClassFile cf = ClassFile.read(in);\n-            for (ConstantPool.CPInfo cpinfo: cf.constant_pool.entries()) {\n-                if (cpinfo.getTag() == ConstantPool.CONSTANT_Utf8) {\n-                    String v = ((ConstantPool.CONSTANT_Utf8_info) cpinfo).value;\n+            ClassModel cm = Classfile.of().parse(in.readAllBytes());\n+            for (int i = 1; i < cm.constantPool().entryCount(); ++i) {\n+                if (cm.constantPool().entryByIndex(i) instanceof Utf8Entry entry) {\n+                    String v = entry.stringValue();\n","filename":"test\/langtools\/tools\/javac\/diags\/CheckResourceKeys.java","additions":12,"deletions":6,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -300,2 +300,6 @@\n-                    pOpts.add(\"--add-modules=jdk.jdeps\");\n-                    pOpts.add(\"--add-exports=jdk.jdeps\/com.sun.tools.classfile=ALL-UNNAMED\");\n+                    pOpts.add(\"--add-exports=java.base\/jdk.internal.classfile=ALL-UNNAMED\");\n+                    pOpts.add(\"--add-exports=java.base\/jdk.internal.classfile.attribute=ALL-UNNAMED\");\n+                    pOpts.add(\"--add-exports=java.base\/jdk.internal.classfile.constantpool=ALL-UNNAMED\");\n+                    pOpts.add(\"--add-exports=java.base\/jdk.internal.classfile.instruction=ALL-UNNAMED\");\n+                    pOpts.add(\"--add-exports=java.base\/jdk.internal.classfile.components=ALL-UNNAMED\");\n+                    pOpts.add(\"--add-exports=java.base\/jdk.internal.classfile.impl=ALL-UNNAMED\");\n","filename":"test\/langtools\/tools\/javac\/diags\/Example.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-\/\/ run: exec --add-exports jdk.jdeps\/com.sun.tools.classfile=ALL-UNNAMED\n+\/\/ run: exec --add-exports java.base\/jdk.internal.classfile=ALL-UNNAMED --add-exports java.base\/jdk.internal.classfile.attribute=ALL-UNNAMED --add-exports java.base\/jdk.internal.classfile.constantpool=ALL-UNNAMED  --add-exports java.base\/jdk.internal.classfile.instruction=ALL-UNNAMED --add-exports java.base\/jdk.internal.classfile.components=ALL-UNNAMED\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/BadConstantValueType\/BadConstantValueType.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,0 +25,4 @@\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.ConstantDesc;\n+import java.lang.constant.ConstantDescs;\n+import java.lang.constant.MethodTypeDesc;\n@@ -30,0 +34,1 @@\n+import java.lang.reflect.AccessFlag;\n@@ -31,4 +36,2 @@\n-import com.sun.tools.classfile.*;\n-import com.sun.tools.classfile.ConstantPool.CONSTANT_Class_info;\n-import com.sun.tools.classfile.ConstantPool.CONSTANT_Utf8_info;\n-import com.sun.tools.classfile.ConstantPool.CPInfo;\n+import jdk.internal.classfile.Classfile;\n+import jdk.internal.classfile.attribute.ConstantValueAttribute;\n@@ -43,9 +46,10 @@\n-            ConstantPool cp = new ConstantPool(new CPInfo[] {\n-                new CONSTANT_Utf8_info(\"\"),                     \/\/0\n-                new CONSTANT_Utf8_info(\"Test\"),                 \/\/1\n-                new CONSTANT_Class_info(null, 1),               \/\/2\n-                new CONSTANT_Utf8_info(\"java\/lang\/Object\"),     \/\/3\n-                new CONSTANT_Class_info(null, 3),               \/\/4\n-                new CONSTANT_Utf8_info(\"test\"),                 \/\/5\n-                new CONSTANT_Utf8_info(\"Ljava\/lang\/Object;\"),   \/\/6\n-                new CONSTANT_Utf8_info(\"ConstantValue\"),        \/\/7\n+            byte[] bytes = Classfile.of().build(ClassDesc.of(\"Test\"), cb -> {\n+                cb.withSuperclass(ConstantDescs.CD_Object);\n+                cb.withVersion(51, 0);\n+                cb.withFlags(AccessFlag.ABSTRACT ,\n+                        AccessFlag.INTERFACE ,\n+                        AccessFlag.PUBLIC);\n+                cb.withField(\"test\", ConstantDescs.CD_Object, fieldBuilder -> {\n+                    fieldBuilder.withFlags(AccessFlag.PUBLIC, AccessFlag.STATIC, AccessFlag.FINAL);\n+                    fieldBuilder.with(ConstantValueAttribute.of(\"ConstantValue\"));\n+                });\n@@ -53,22 +57,0 @@\n-            ClassFile cf = new ClassFile(0xCAFEBABE,\n-                          0,\n-                          51,\n-                          cp,\n-                          new AccessFlags(AccessFlags.ACC_ABSTRACT |\n-                                          AccessFlags.ACC_INTERFACE |\n-                                          AccessFlags.ACC_PUBLIC),\n-                          2,\n-                          4,\n-                          new int[0],\n-                          new Field[] {\n-                              new Field(new AccessFlags(AccessFlags.ACC_PUBLIC |\n-                                                        AccessFlags.ACC_STATIC |\n-                                                        AccessFlags.ACC_FINAL),\n-                                        5,\n-                                      new Descriptor(6),\n-                                      new Attributes(cp, new Attribute[] {\n-                                          new ConstantValue_attribute(7, 6)\n-                                      }))\n-                          },\n-                          new Method[0],\n-                          new Attributes(cp, new Attribute[0]));\n@@ -78,1 +60,1 @@\n-                    new ClassWriter().write(cf, out);\n+                    out.write(bytes);\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/BadConstantValueType\/processors\/CreateBadClassFile.java","additions":18,"deletions":36,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-\/\/ run: exec --add-exports jdk.jdeps\/com.sun.tools.classfile=ALL-UNNAMED\n+\/\/ run: exec --add-exports java.base\/jdk.internal.classfile=ALL-UNNAMED --add-exports java.base\/jdk.internal.classfile.attribute=ALL-UNNAMED --add-exports java.base\/jdk.internal.classfile.constantpool=ALL-UNNAMED  --add-exports java.base\/jdk.internal.classfile.instruction=ALL-UNNAMED --add-exports java.base\/jdk.internal.classfile.components=ALL-UNNAMED\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/InvalidDefaultInterface\/InvalidDefaultInterface.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,0 +25,3 @@\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.ConstantDescs;\n+import java.lang.constant.MethodTypeDesc;\n@@ -30,0 +33,1 @@\n+import java.lang.reflect.AccessFlag;\n@@ -31,4 +35,1 @@\n-import com.sun.tools.classfile.*;\n-import com.sun.tools.classfile.ConstantPool.CONSTANT_Class_info;\n-import com.sun.tools.classfile.ConstantPool.CONSTANT_Utf8_info;\n-import com.sun.tools.classfile.ConstantPool.CPInfo;\n+import jdk.internal.classfile.Classfile;\n@@ -41,28 +42,8 @@\n-            ConstantPool cp = new ConstantPool(new CPInfo[] {\n-                new CONSTANT_Utf8_info(\"\"),                     \/\/0\n-                new CONSTANT_Utf8_info(\"Test\"),                 \/\/1\n-                new CONSTANT_Class_info(null, 1),               \/\/2\n-                new CONSTANT_Utf8_info(\"java\/lang\/Object\"),     \/\/3\n-                new CONSTANT_Class_info(null, 3),               \/\/4\n-                new CONSTANT_Utf8_info(\"test\"),                 \/\/5\n-                new CONSTANT_Utf8_info(\"()V\"),                  \/\/6\n-            });\n-            ClassFile cf = new ClassFile(0xCAFEBABE,\n-                          0,\n-                          51,\n-                          cp,\n-                          new AccessFlags(AccessFlags.ACC_ABSTRACT |\n-                                          AccessFlags.ACC_INTERFACE |\n-                                          AccessFlags.ACC_PUBLIC),\n-                          2,\n-                          4,\n-                          new int[0],\n-                          new Field[0],\n-                          new Method[] {\n-                              \/\/creating non-abstract method in 51.0 classfile:\n-                              new Method(new AccessFlags(AccessFlags.ACC_PUBLIC),\n-                                         5,\n-                                         new Descriptor(6),\n-                                         new Attributes(cp, new Attribute[0]))\n-                          },\n-                          new Attributes(cp, new Attribute[0]));\n+            byte[] bytes = Classfile.of().build(ClassDesc.of(\"Test\"), classBuilder -> {\n+                classBuilder.withVersion(51, 0);\n+                classBuilder.withFlags(AccessFlag.ABSTRACT ,\n+                                          AccessFlag.INTERFACE ,\n+                                          AccessFlag.PUBLIC);\n+                classBuilder.withMethod(\"test\", MethodTypeDesc.of(ConstantDescs.CD_void), Classfile.ACC_PUBLIC, methodBuilder -> {\n+                    methodBuilder.withFlags(AccessFlag.PUBLIC);});\n+                });\n@@ -72,1 +53,1 @@\n-                    new ClassWriter().write(cf, out);\n+                    out.write(bytes);\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/InvalidDefaultInterface\/processors\/CreateBadClassFile.java","additions":14,"deletions":33,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-\/\/ run: exec --add-exports jdk.jdeps\/com.sun.tools.classfile=ALL-UNNAMED\n+\/\/ run: exec --add-exports java.base\/jdk.internal.classfile=ALL-UNNAMED --add-exports java.base\/jdk.internal.classfile.attribute=ALL-UNNAMED --add-exports java.base\/jdk.internal.classfile.constantpool=ALL-UNNAMED  --add-exports java.base\/jdk.internal.classfile.instruction=ALL-UNNAMED --add-exports java.base\/jdk.internal.classfile.components=ALL-UNNAMED\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/InvalidStaticInterface\/InvalidStaticInterface.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,0 +25,3 @@\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.ConstantDescs;\n+import java.lang.constant.MethodTypeDesc;\n@@ -31,4 +34,2 @@\n-import com.sun.tools.classfile.*;\n-import com.sun.tools.classfile.ConstantPool.CONSTANT_Class_info;\n-import com.sun.tools.classfile.ConstantPool.CONSTANT_Utf8_info;\n-import com.sun.tools.classfile.ConstantPool.CPInfo;\n+import java.lang.reflect.AccessFlag;\n+import jdk.internal.classfile.Classfile;\n@@ -41,8 +42,12 @@\n-            ConstantPool cp = new ConstantPool(new CPInfo[] {\n-                new CONSTANT_Utf8_info(\"\"),                     \/\/0\n-                new CONSTANT_Utf8_info(\"Test\"),                 \/\/1\n-                new CONSTANT_Class_info(null, 1),               \/\/2\n-                new CONSTANT_Utf8_info(\"java\/lang\/Object\"),     \/\/3\n-                new CONSTANT_Class_info(null, 3),               \/\/4\n-                new CONSTANT_Utf8_info(\"test\"),                 \/\/5\n-                new CONSTANT_Utf8_info(\"()V\"),                  \/\/6\n+            byte[] bytes = Classfile.of().build(ClassDesc.of(\"Test\"), classBuilder -> {\n+                classBuilder.withVersion(51, 0);\n+                classBuilder.withFlags(AccessFlag.ABSTRACT,\n+                            AccessFlag.INTERFACE,\n+                            AccessFlag.PUBLIC);\n+                classBuilder.withSuperclass(ConstantDescs.CD_Object);\n+                classBuilder.withMethod(\"test\", ConstantDescs.MTD_void,\n+                        Classfile.ACC_PUBLIC | Classfile.ACC_STATIC, methodBuilder -> {\n+                            methodBuilder.withCode(xb -> {\n+                                xb.return_();\n+                            });\n+                });\n@@ -50,20 +55,0 @@\n-            ClassFile cf = new ClassFile(0xCAFEBABE,\n-                          0,\n-                          51,\n-                          cp,\n-                          new AccessFlags(AccessFlags.ACC_ABSTRACT |\n-                                          AccessFlags.ACC_INTERFACE |\n-                                          AccessFlags.ACC_PUBLIC),\n-                          2,\n-                          4,\n-                          new int[0],\n-                          new Field[0],\n-                          new Method[] {\n-                              \/\/creating static method in 51.0 classfile:\n-                              new Method(new AccessFlags(AccessFlags.ACC_PUBLIC |\n-                                                         AccessFlags.ACC_STATIC),\n-                                         5,\n-                                         new Descriptor(6),\n-                                         new Attributes(cp, new Attribute[0]))\n-                          },\n-                          new Attributes(cp, new Attribute[0]));\n@@ -73,1 +58,1 @@\n-                    new ClassWriter().write(cf, out);\n+                    out.write(bytes);\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/InvalidStaticInterface\/processors\/CreateBadClassFile.java","additions":18,"deletions":33,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -29,1 +29,6 @@\n- * @modules jdk.jdeps\/com.sun.tools.classfile\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.classfile.instruction\n+ *          java.base\/jdk.internal.classfile.components\n+ *          java.base\/jdk.internal.classfile.impl\n@@ -38,7 +43,5 @@\n-import com.sun.tools.classfile.Attribute;\n-import com.sun.tools.classfile.ClassFile;\n-import com.sun.tools.classfile.Code_attribute;\n-import com.sun.tools.classfile.ConstantPool.CPRefInfo;\n-import com.sun.tools.classfile.Instruction;\n-import com.sun.tools.classfile.Method;\n-import com.sun.tools.classfile.Opcode;\n+import jdk.internal.classfile.*;\n+import jdk.internal.classfile.attribute.CodeAttribute;\n+import jdk.internal.classfile.constantpool.MemberRefEntry;\n+import jdk.internal.classfile.instruction.FieldInstruction;\n+import jdk.internal.classfile.instruction.InvokeInstruction;\n@@ -63,10 +66,9 @@\n-            final ClassFile cf = ClassFile.read(clazz);\n-            for (Method m : cf.methods) {\n-                Code_attribute codeAttr = (Code_attribute)m.attributes.get(Attribute.Code);\n-                for (Instruction instr : codeAttr.getInstructions()) {\n-                    if (instr.getOpcode() == Opcode.INVOKESPECIAL ||\n-                        instr.getOpcode() == Opcode.INVOKEVIRTUAL) {\n-                        int pc_index = instr.getShort(1);\n-                        CPRefInfo ref = (CPRefInfo)cf.constant_pool.get(pc_index);\n-                        String className = ref.getClassName();\n-                        String methodName = ref.getNameAndTypeInfo().getName();\n+            final ClassModel cf = Classfile.of().parse(clazz.toPath());\n+            for (MethodModel m : cf.methods()) {\n+                CodeAttribute codeAttr = m.findAttribute(Attributes.CODE).orElseThrow();\n+                for (CodeElement ce : codeAttr.elementList()) {\n+                    if (ce instanceof InvokeInstruction instr && (instr.opcode() == Opcode.INVOKESPECIAL ||\n+                        instr.opcode() == Opcode.INVOKEVIRTUAL)) {\n+                        MemberRefEntry ref = instr.method();\n+                        String className = ref.owner().asInternalName();\n+                        String methodName = ref.name().stringValue();\n@@ -84,6 +86,4 @@\n-                    if (instr.getOpcode() == Opcode.GETFIELD ||\n-                        instr.getOpcode() == Opcode.PUTFIELD) {\n-                        int pc_index = instr.getShort(1);\n-                        CPRefInfo ref = (CPRefInfo)cf.constant_pool.get(pc_index);\n-                        String className = ref.getClassName();\n-                        String fieldName = ref.getNameAndTypeInfo().getName();\n+                    if (ce instanceof FieldInstruction instr && (instr.opcode() == Opcode.GETFIELD ||\n+                        instr.opcode() == Opcode.PUTFIELD)) {\n+                        String className = instr.owner().asInternalName();\n+                        String fieldName = instr.field().name().stringValue();\n","filename":"test\/langtools\/tools\/javac\/expression\/_super\/NonDirectSuper\/NonDirectSuper.java","additions":24,"deletions":24,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -31,1 +31,6 @@\n- *          jdk.jdeps\/com.sun.tools.classfile\n+ *          java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.classfile.instruction\n+ *          java.base\/jdk.internal.classfile.components\n+ *          java.base\/jdk.internal.classfile.impl\n","filename":"test\/langtools\/tools\/javac\/file\/SymLinkArchiveTest.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -31,1 +31,6 @@\n- *          jdk.jdeps\/com.sun.tools.classfile\n+ *          java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.classfile.instruction\n+ *          java.base\/jdk.internal.classfile.components\n+ *          java.base\/jdk.internal.classfile.impl\n","filename":"test\/langtools\/tools\/javac\/file\/SymLinkShortNameTest.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -33,1 +33,6 @@\n- *          jdk.jdeps\/com.sun.tools.classfile\n+ *          java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.classfile.instruction\n+ *          java.base\/jdk.internal.classfile.components\n+ *          java.base\/jdk.internal.classfile.impl\n@@ -43,3 +48,2 @@\n-import com.sun.tools.classfile.Attribute;\n-import com.sun.tools.classfile.ClassFile;\n-import com.sun.tools.classfile.SourceFile_attribute;\n+import jdk.internal.classfile.*;\n+import jdk.internal.classfile.attribute.SourceFileAttribute;\n@@ -97,3 +101,3 @@\n-        ClassFile cf = ClassFile.read(classes.resolve(\"HelloWorld.class\"));\n-        SourceFile_attribute sf = (SourceFile_attribute) cf.attributes.get(Attribute.SourceFile);\n-        String sourceFile = sf.getSourceFile(cf.constant_pool);\n+        ClassModel cf = Classfile.of().parse(classes.resolve(\"HelloWorld.class\"));\n+        SourceFileAttribute sf = cf.findAttribute(Attributes.SOURCE_FILE).orElseThrow();\n+        String sourceFile = sf.sourceFile().stringValue();\n","filename":"test\/langtools\/tools\/javac\/file\/SymLinkTest.java","additions":11,"deletions":7,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -31,1 +31,6 @@\n- * @modules jdk.jdeps\/com.sun.tools.classfile\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.classfile.instruction\n+ *          java.base\/jdk.internal.classfile.components\n+ *          java.base\/jdk.internal.classfile.impl\n@@ -57,10 +62,2 @@\n-import com.sun.tools.classfile.Attribute;\n-import com.sun.tools.classfile.ClassFile;\n-import com.sun.tools.classfile.ConstantPool;\n-import com.sun.tools.classfile.ConstantPoolException;\n-import com.sun.tools.classfile.Code_attribute;\n-import com.sun.tools.classfile.ConstantPool.InvalidIndex;\n-import com.sun.tools.classfile.ConstantPool.UnexpectedEntry;\n-import com.sun.tools.classfile.Descriptor.InvalidDescriptor;\n-import com.sun.tools.classfile.LocalVariableTable_attribute;\n-import com.sun.tools.classfile.Method;\n+import jdk.internal.classfile.*;\n+import jdk.internal.classfile.attribute.*;\n@@ -69,1 +66,0 @@\n-import static com.sun.tools.classfile.LocalVariableTable_attribute.Entry;\n@@ -82,1 +78,1 @@\n-            fm.setLocation(SOURCE_PATH, Arrays.asList(new File(testDir, \"tests\")));\n+            fm.setLocation(SOURCE_PATH, List.of(new File(testDir, \"tests\")));\n@@ -85,1 +81,1 @@\n-            fm.setLocation(CLASS_OUTPUT, Arrays.asList(new File(\".\")));\n+            fm.setLocation(CLASS_OUTPUT, List.of(new File(\".\")));\n@@ -132,4 +128,2 @@\n-    void checkClassFile(File file)\n-            throws IOException, ConstantPoolException, InvalidDescriptor {\n-        ClassFile classFile = ClassFile.read(file);\n-        ConstantPool constantPool = classFile.constant_pool;\n+    void checkClassFile(File file) throws IOException {\n+        ClassModel classFile = Classfile.of().parse(file.toPath());\n@@ -138,1 +132,1 @@\n-        for (Method method : classFile.methods) {\n+        for (MethodModel method : classFile.methods()) {\n@@ -140,2 +134,2 @@\n-                String methodDesc = method.getName(constantPool) +\n-                        method.descriptor.getParameterTypes(constantPool).replace(\" \", \"\");\n+                String methodDesc = method.methodName().stringValue() +\n+                        parse(method.methodTypeSymbol().descriptorString()).replace(\" \", \"\");\n@@ -143,1 +137,1 @@\n-                    checkMethod(constantPool, method, aliveRangeMap.get(elementKey));\n+                    checkMethod(method, aliveRangeMap.get(elementKey));\n@@ -150,5 +144,3 @@\n-    void checkMethod(ConstantPool constantPool, Method method, AliveRanges ranges)\n-            throws InvalidIndex, UnexpectedEntry, ConstantPoolException {\n-        Code_attribute code = (Code_attribute) method.attributes.get(Attribute.Code);\n-        LocalVariableTable_attribute lvt =\n-            (LocalVariableTable_attribute) (code.attributes.get(Attribute.LocalVariableTable));\n+    void checkMethod(MethodModel method, AliveRanges ranges) {\n+        CodeAttribute code = method.findAttribute(Attributes.CODE).orElseThrow();\n+        LocalVariableTableAttribute lvt = code.findAttribute(Attributes.LOCAL_VARIABLE_TABLE).orElseThrow();\n@@ -156,1 +148,1 @@\n-        List<String> infoFromLVT = convertToStringList(constantPool, lvt);\n+        List<String> infoFromLVT = convertToStringList(lvt);\n@@ -173,1 +165,1 @@\n-            error(infoFromLVT, infoFromRanges, method.getName(constantPool).toString());\n+            error(infoFromLVT, infoFromRanges, method.methodName().stringValue());\n@@ -189,2 +181,1 @@\n-    List<String> convertToStringList(ConstantPool constantPool,\n-            LocalVariableTable_attribute lvt) throws InvalidIndex, UnexpectedEntry {\n+    List<String> convertToStringList(LocalVariableTableAttribute lvt) {\n@@ -192,3 +183,3 @@\n-        for (Entry entry : lvt.local_variable_table) {\n-            String str = formatLocalVariableData(constantPool.getUTF8Value(entry.name_index),\n-                    entry.start_pc, entry.length);\n+        for (LocalVariableInfo entry : lvt.localVariables()) {\n+            String str = formatLocalVariableData(entry.name().stringValue(),\n+                    entry.startPc(), entry.length());\n@@ -295,0 +286,52 @@\n+    private String parse(String desc) {\n+        int end = desc.indexOf(\")\");\n+        if (end == -1)\n+            throw new AssertionError();\n+        end ++;\n+        int p = 0;\n+        StringBuilder sb = new StringBuilder();\n+        int dims = 0;\n+\n+        while (p < end) {\n+            String type;\n+            switch (desc.charAt(p++)) {\n+                case '(' -> {\n+                    sb.append('(');\n+                    continue;\n+                }\n+                case ')' -> {\n+                    sb.append(')');\n+                    continue;\n+                }\n+                case '[' -> {\n+                    dims++;\n+                    continue;\n+                }\n+                case 'B' -> type = \"byte\";\n+                case 'C' -> type = \"char\";\n+                case 'D' -> type = \"double\";\n+                case 'F' -> type = \"float\";\n+                case 'I' -> type = \"int\";\n+                case 'J' -> type = \"long\";\n+                case 'L' -> {\n+                    int sep = desc.indexOf(';', p);\n+                    if (sep == -1)\n+                        throw new AssertionError();\n+                    type = desc.substring(p, sep).replace('\/', '.');\n+                    p = sep + 1;\n+                }\n+                case 'S' -> type = \"short\";\n+                case 'Z' -> type = \"boolean\";\n+                case 'V' -> type = \"void\";\n+                default -> throw new AssertionError();\n+            }\n+\n+            if (sb.length() > 1 && sb.charAt(0) == '(')\n+                sb.append(\", \");\n+            sb.append(type);\n+            for ( ; dims > 0; dims-- )\n+                sb.append(\"[]\");\n+        }\n+        return sb.toString();\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/flow\/LVTHarness.java","additions":77,"deletions":34,"binary":false,"changes":111,"status":"modified"},{"patch":"@@ -29,1 +29,6 @@\n- * @modules jdk.jdeps\/com.sun.tools.classfile\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.classfile.instruction\n+ *          java.base\/jdk.internal.classfile.components\n+ *          java.base\/jdk.internal.classfile.impl\n@@ -37,5 +42,1 @@\n-import com.sun.tools.classfile.AccessFlags;\n-import com.sun.tools.classfile.ClassFile;\n-import com.sun.tools.classfile.ConstantPool;\n-import com.sun.tools.classfile.ConstantPoolException;\n-import com.sun.tools.classfile.Method;\n+import jdk.internal.classfile.*;\n@@ -114,2 +115,2 @@\n-    static String descriptor(Method m, ConstantPool cp) throws ConstantPoolException {\n-        return m.getName(cp) + m.descriptor.getValue(cp);\n+    static String descriptor(MethodModel m) {\n+        return m.methodName() + m.methodTypeSymbol().descriptorString();\n@@ -149,2 +150,2 @@\n-            ClassFile cf = ClassFile.read(is);\n-            System.err.println(\"checking: \" + cf.getName());\n+            ClassModel cf = Classfile.of().parse(is.readAllBytes());\n+            System.err.println(\"checking: \" + cf.thisClass().asInternalName());\n@@ -152,1 +153,1 @@\n-            List<Bridge> bridgeList = bridgesMap.get(cf.getName());\n+            List<Bridge> bridgeList = bridgesMap.get(cf.thisClass().asInternalName());\n@@ -158,2 +159,2 @@\n-            for (Method m : cf.methods) {\n-                if (m.access_flags.is(AccessFlags.ACC_SYNTHETIC | AccessFlags.ACC_BRIDGE)) {\n+            for (MethodModel m : cf.methods()) {\n+                if ((m.flags().flagsMask() & (Classfile.ACC_SYNTHETIC | Classfile.ACC_BRIDGE)) != 0) {\n@@ -163,1 +164,1 @@\n-                        if (b.value().equals(descriptor(m, cf.constant_pool))) {\n+                        if (b.value().equals(descriptor(m))) {\n@@ -169,1 +170,1 @@\n-                        error(\"No annotation for bridge method: \" + descriptor(m, cf.constant_pool));\n+                        error(\"No annotation for bridge method: \" + descriptor(m));\n","filename":"test\/langtools\/tools\/javac\/generics\/bridges\/BridgeHarness.java","additions":16,"deletions":15,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -29,1 +29,6 @@\n- * @modules jdk.jdeps\/com.sun.tools.classfile\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.classfile.instruction\n+ *          java.base\/jdk.internal.classfile.components\n+ *          java.base\/jdk.internal.classfile.impl\n@@ -41,0 +46,1 @@\n+import java.lang.constant.ClassDesc;\n@@ -58,11 +64,1 @@\n-import com.sun.tools.classfile.AccessFlags;\n-import com.sun.tools.classfile.Attribute;\n-import com.sun.tools.classfile.Attributes;\n-import com.sun.tools.classfile.ClassFile;\n-import com.sun.tools.classfile.ClassWriter;\n-import com.sun.tools.classfile.ConstantPool;\n-import com.sun.tools.classfile.ConstantPool.CONSTANT_Class_info;\n-import com.sun.tools.classfile.ConstantPool.CONSTANT_Utf8_info;\n-import com.sun.tools.classfile.ConstantPool.CPInfo;\n-import com.sun.tools.classfile.Field;\n-import com.sun.tools.classfile.Method;\n+import jdk.internal.classfile.*;\n@@ -109,6 +105,4 @@\n-        ConstantPool cp = new ConstantPool(new CPInfo[] {\n-            new CONSTANT_Utf8_info(\"\"),                     \/\/0\n-            new CONSTANT_Utf8_info(name.replace(\".\", \"\/\")), \/\/1\n-            new CONSTANT_Class_info(null, 1),               \/\/2\n-            new CONSTANT_Utf8_info(\"java\/lang\/Object\"),     \/\/3\n-            new CONSTANT_Class_info(null, 3),               \/\/4\n+        byte[] bytes = Classfile.of().build(ClassDesc.of(name), classBuilder -> {\n+            classBuilder.withSuperclass(ClassDesc.ofInternalName(\"java\/lang\/Object\"))\n+                    .withVersion(51, 0)\n+                    .withFlags(Classfile.ACC_ABSTRACT | Classfile.ACC_INTERFACE | Classfile.ACC_PUBLIC);\n@@ -116,13 +110,0 @@\n-        ClassFile cf = new ClassFile(0xCAFEBABE,\n-                      0,\n-                      51,\n-                      cp,\n-                      new AccessFlags(AccessFlags.ACC_ABSTRACT |\n-                                      AccessFlags.ACC_INTERFACE |\n-                                      AccessFlags.ACC_PUBLIC),\n-                      2,\n-                      4,\n-                      new int[0],\n-                      new Field[0],\n-                      new Method[0],\n-                      new Attributes(cp, new Attribute[0]));\n@@ -130,1 +111,1 @@\n-        new ClassWriter().write(cf, baos);\n+        baos.write(bytes);\n","filename":"test\/langtools\/tools\/javac\/importscope\/T8193717.java","additions":13,"deletions":32,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -28,1 +28,5 @@\n- * @modules jdk.jdeps\/com.sun.tools.classfile\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.classfile.instruction\n+ *          java.base\/jdk.internal.classfile.components\n@@ -35,2 +39,2 @@\n-import com.sun.tools.classfile.*;\n-import com.sun.tools.classfile.ConstantPool.*;\n+import jdk.internal.classfile.*;\n+import jdk.internal.classfile.constantpool.*;\n@@ -40,3 +44,3 @@\n-        ClassFile cls = ClassFile.read(ClassRefDupInConstantPoolTest.class.\n-                                       getResourceAsStream(\"ClassRefDupInConstantPoolTest$Duplicates.class\"));\n-        ConstantPool pool = cls.constant_pool;\n+        ClassModel cls = Classfile.of().parse(ClassRefDupInConstantPoolTest.class.\n+                                       getResourceAsStream(\"ClassRefDupInConstantPoolTest$Duplicates.class\").readAllBytes());\n+        ConstantPool pool = cls.constantPool();\n@@ -45,5 +49,4 @@\n-        TreeSet<Integer> set = new TreeSet<>();\n-        for (CPInfo i : pool.entries()) {\n-            if (i.getTag() == ConstantPool.CONSTANT_Class) {\n-                CONSTANT_Class_info ci = (CONSTANT_Class_info)i;\n-                if (!set.add(ci.name_index)) {\n+        TreeSet<String> set = new TreeSet<>();\n+        for (int i = 1; i < pool.entryCount(); i += pool.entryByIndex(i).width()) {\n+            if (pool.entryByIndex(i) instanceof ClassEntry ce) {\n+                if (!set.add(ce.asInternalName())) {\n@@ -51,1 +54,1 @@\n-                    System.out.println(\"DUPLICATE CLASS REF \" + ci.getName());\n+                    System.out.println(\"DUPLICATE CLASS REF \" + ce.asInternalName());\n","filename":"test\/langtools\/tools\/javac\/jvm\/ClassRefDupInConstantPoolTest.java","additions":15,"deletions":12,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -29,1 +29,6 @@\n- * @modules jdk.jdeps\/com.sun.tools.classfile\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.classfile.instruction\n+ *          java.base\/jdk.internal.classfile.components\n+ *          java.base\/jdk.internal.classfile.impl\n@@ -33,6 +38,3 @@\n-import com.sun.tools.classfile.Attribute;\n-import com.sun.tools.classfile.BootstrapMethods_attribute;\n-import com.sun.tools.classfile.ClassFile;\n-import com.sun.tools.classfile.ConstantPool;\n-import com.sun.tools.classfile.ConstantPoolException;\n-import com.sun.tools.classfile.ConstantPool.*;\n+import jdk.internal.classfile.*;\n+import jdk.internal.classfile.attribute.BootstrapMethodsAttribute;\n+import jdk.internal.classfile.constantpool.*;\n@@ -45,0 +47,1 @@\n+import java.lang.invoke.MethodHandleInfo;\n@@ -76,1 +79,1 @@\n-        ClassFile c = null;\n+        ClassModel c = null;\n@@ -78,2 +81,2 @@\n-            c = ClassFile.read(classFile);\n-        } catch (IOException | ConstantPoolException e) {\n+            c = Classfile.of().parse(classFile.toPath());\n+        } catch (IOException e) {\n@@ -82,1 +85,2 @@\n-        ConstantPoolVisitor cpv = new ConstantPoolVisitor(c, c.constant_pool.size());\n+        assert c != null;\n+        ConstantPoolVisitor cpv = new ConstantPoolVisitor(c, c.constantPool().entryCount());\n@@ -381,1 +385,1 @@\n-    static class ConstantPoolVisitor implements ConstantPool.Visitor<String, Integer> {\n+    static class ConstantPoolVisitor {\n@@ -383,1 +387,1 @@\n-        final ClassFile cf;\n+        final ClassModel cf;\n@@ -388,1 +392,1 @@\n-        public ConstantPoolVisitor(ClassFile cf, int size) {\n+        public ConstantPoolVisitor(ClassModel cf, int size) {\n@@ -394,1 +398,1 @@\n-            this.cfpool = cf.constant_pool;\n+            this.cfpool = cf.constantPool();\n@@ -402,2 +406,21 @@\n-        public String visit(CPInfo c, int index) {\n-            return c.accept(this, index);\n+        public String visit(PoolEntry c, int index) {\n+            return switch (c) {\n+                case ClassEntry entry -> visitClass(entry, index);\n+                case DoubleEntry entry -> visitDouble(entry, index);\n+                case FieldRefEntry entry -> visitFieldref(entry, index);\n+                case FloatEntry entry -> visitFloat(entry, index);\n+                case IntegerEntry entry -> visitInteger(entry, index);\n+                case InterfaceMethodRefEntry entry -> visitInterfaceMethodref(entry, index);\n+                case InvokeDynamicEntry entry -> visitInvokeDynamic(entry, index);\n+                case ConstantDynamicEntry entry -> visitDynamicConstant(entry, index);\n+                case LongEntry entry -> visitLong(entry, index);\n+                case NameAndTypeEntry entry -> visitNameAndType(entry, index);\n+                case MethodRefEntry entry -> visitMethodref(entry, index);\n+                case MethodHandleEntry entry -> visitMethodHandle(entry, index);\n+                case MethodTypeEntry entry -> visitMethodType(entry, index);\n+                case ModuleEntry entry -> visitModule(entry, index);\n+                case PackageEntry entry -> visitPackage(entry, index);\n+                case StringEntry entry -> visitString(entry, index);\n+                case Utf8Entry entry -> visitUtf8(entry, index);\n+                default -> throw new AssertionError();\n+            };\n@@ -407,2 +430,1 @@\n-            BootstrapMethods_attribute bsmAttr =\n-                    (BootstrapMethods_attribute) cf.getAttribute(Attribute.BootstrapMethods);\n+            BootstrapMethodsAttribute bsmAttr = cf.findAttribute(Attributes.BOOTSTRAP_METHODS).orElse(null);\n@@ -411,4 +433,3 @@\n-                        new HashMap<>(bsmAttr.bootstrap_method_specifiers.length);\n-                for (BootstrapMethods_attribute.BootstrapMethodSpecifier bsms :\n-                        bsmAttr.bootstrap_method_specifiers) {\n-                    int index = bsms.bootstrap_method_ref;\n+                        new HashMap<>(bsmAttr.bootstrapMethodsSize());\n+                for (BootstrapMethodEntry bsms : bsmAttr.bootstrapMethods()) {\n+                    int index = bsms.bootstrapMethod().index();\n@@ -418,1 +439,1 @@\n-                            value = visit(cfpool.get(index), index);\n+                            value = visit(cfpool.entryByIndex(index), index);\n@@ -424,1 +445,2 @@\n-                        for (int idx : bsms.bootstrap_arguments) {\n+                        for (LoadableConstantEntry ce : bsms.arguments()) {\n+                            int idx = ce.index();\n@@ -427,1 +449,1 @@\n-                                value = visit(cfpool.get(idx), idx);\n+                                value = visit(cfpool.entryByIndex(idx), idx);\n@@ -434,1 +456,1 @@\n-                    } catch (InvalidIndex ex) {\n+                    } catch (ConstantPoolException ex) {\n@@ -443,2 +465,1 @@\n-        @Override\n-        public String visitClass(CONSTANT_Class_info c, Integer p) {\n+        public String visitClass(ClassEntry c, Integer p) {\n@@ -449,1 +470,1 @@\n-                    value = visit(cfpool.get(c.name_index), c.name_index);\n+                    value = visit(cfpool.entryByIndex(c.name().index()), c.index());\n@@ -458,2 +479,1 @@\n-        @Override\n-        public String visitDouble(CONSTANT_Double_info c, Integer p) {\n+        public String visitDouble(DoubleEntry c, Integer p) {\n@@ -463,1 +483,1 @@\n-                value = Double.toString(c.value);\n+                value = Double.toString(c.doubleValue());\n@@ -469,2 +489,1 @@\n-        @Override\n-        public String visitFieldref(CONSTANT_Fieldref_info c, Integer p) {\n+        public String visitFieldref(FieldRefEntry c, Integer p) {\n@@ -475,3 +494,3 @@\n-                    value = visit(cfpool.get(c.class_index), c.class_index);\n-                    value = value.concat(\" \" + visit(cfpool.get(c.name_and_type_index),\n-                                         c.name_and_type_index));\n+                    value = visit(cfpool.entryByIndex(c.owner().index()), c.owner().index());\n+                    value = value.concat(\" \" + visit(cfpool.entryByIndex(c.nameAndType().index()),\n+                                         c.nameAndType().index()));\n@@ -486,2 +505,1 @@\n-        @Override\n-        public String visitFloat(CONSTANT_Float_info c, Integer p) {\n+        public String visitFloat(FloatEntry c, Integer p) {\n@@ -491,1 +509,1 @@\n-                value = Float.toString(c.value);\n+                value = Float.toString(c.floatValue());\n@@ -497,2 +515,1 @@\n-        @Override\n-        public String visitInteger(CONSTANT_Integer_info cnstnt, Integer p) {\n+        public String visitInteger(IntegerEntry cnstnt, Integer p) {\n@@ -502,1 +519,1 @@\n-                value = Integer.toString(cnstnt.value);\n+                value = Integer.toString(cnstnt.intValue());\n@@ -508,2 +525,1 @@\n-        @Override\n-        public String visitInterfaceMethodref(CONSTANT_InterfaceMethodref_info c,\n+        public String visitInterfaceMethodref(InterfaceMethodRefEntry c,\n@@ -515,1 +531,1 @@\n-                    value = visit(cfpool.get(c.class_index), c.class_index);\n+                    value = visit(cfpool.entryByIndex(c.owner().index()), c.owner().index());\n@@ -517,2 +533,2 @@\n-                                         visit(cfpool.get(c.name_and_type_index),\n-                                         c.name_and_type_index));\n+                                         visit(cfpool.entryByIndex(c.nameAndType().index()),\n+                                         c.nameAndType().index()));\n@@ -527,2 +543,1 @@\n-        @Override\n-        public String visitInvokeDynamic(CONSTANT_InvokeDynamic_info c, Integer p) {\n+        public String visitInvokeDynamic(InvokeDynamicEntry c, Integer p) {\n@@ -533,2 +548,2 @@\n-                    value = bsmMap.get(c.bootstrap_method_attr_index) + \" \"\n-                            + visit(cfpool.get(c.name_and_type_index), c.name_and_type_index);\n+                    value = bsmMap.get(c.bootstrap().bsmIndex()) + \" \"\n+                            + visit(cfpool.entryByIndex(c.nameAndType().index()), c.nameAndType().index());\n@@ -543,2 +558,1 @@\n-        @Override\n-        public String visitDynamicConstant(CONSTANT_Dynamic_info c, Integer p) {\n+        public String visitDynamicConstant(ConstantDynamicEntry c, Integer p) {\n@@ -549,2 +563,2 @@\n-                    value = bsmMap.get(c.bootstrap_method_attr_index) + \" \"\n-                            + visit(cfpool.get(c.name_and_type_index), c.name_and_type_index);\n+                    value = bsmMap.get(c.bootstrap().bsmIndex()) + \" \"\n+                            + visit(cfpool.entryByIndex(c.nameAndType().index()), c.nameAndType().index());\n@@ -559,2 +573,1 @@\n-        @Override\n-        public String visitLong(CONSTANT_Long_info c, Integer p) {\n+        public String visitLong(LongEntry c, Integer p) {\n@@ -564,1 +577,1 @@\n-                value = Long.toString(c.value);\n+                value = Long.toString(c.longValue());\n@@ -570,2 +583,1 @@\n-        @Override\n-        public String visitNameAndType(CONSTANT_NameAndType_info c, Integer p) {\n+        public String visitNameAndType(NameAndTypeEntry c, Integer p) {\n@@ -576,1 +588,1 @@\n-                    value = visit(cfpool.get(c.name_index), c.name_index);\n+                    value = visit(cfpool.entryByIndex(c.name().index()), c.name().index());\n@@ -578,1 +590,1 @@\n-                            visit(cfpool.get(c.type_index), c.type_index));\n+                            visit(cfpool.entryByIndex(c.type().index()), c.type().index()));\n@@ -580,1 +592,1 @@\n-                } catch (InvalidIndex ex) {\n+                } catch (ConstantPoolException ex) {\n@@ -587,2 +599,1 @@\n-        @Override\n-        public String visitMethodref(CONSTANT_Methodref_info c, Integer p) {\n+        public String visitMethodref(MethodRefEntry c, Integer p) {\n@@ -593,1 +604,1 @@\n-                    value = visit(cfpool.get(c.class_index), c.class_index);\n+                    value = visit(cfpool.entryByIndex(c.owner().index()), c.owner().index());\n@@ -595,2 +606,2 @@\n-                                         visit(cfpool.get(c.name_and_type_index),\n-                                         c.name_and_type_index));\n+                                         visit(cfpool.entryByIndex(c.nameAndType().index()),\n+                                         c.nameAndType().index()));\n@@ -605,2 +616,1 @@\n-        @Override\n-        public String visitMethodHandle(CONSTANT_MethodHandle_info c, Integer p) {\n+        public String visitMethodHandle(MethodHandleEntry c, Integer p) {\n@@ -611,1 +621,1 @@\n-                    value = c.reference_kind.name();\n+                    value = MethodHandleInfo.referenceKindToString(c.kind());\n@@ -613,1 +623,1 @@\n-                            + visit(cfpool.get(c.reference_index), c.reference_index));\n+                            + visit(cfpool.entryByIndex(c.reference().index()), c.reference().index()));\n@@ -622,2 +632,1 @@\n-        @Override\n-        public String visitMethodType(CONSTANT_MethodType_info c, Integer p) {\n+        public String visitMethodType(MethodTypeEntry c, Integer p) {\n@@ -628,1 +637,1 @@\n-                    value = visit(cfpool.get(c.descriptor_index), c.descriptor_index);\n+                    value = visit(cfpool.entryByIndex(c.descriptor().index()), c.descriptor().index());\n@@ -637,2 +646,1 @@\n-        @Override\n-        public String visitModule(CONSTANT_Module_info c, Integer p) {\n+        public String visitModule(ModuleEntry c, Integer p) {\n@@ -643,1 +651,1 @@\n-                    value = visit(cfpool.get(c.name_index), c.name_index);\n+                    value = visit(cfpool.entryByIndex(c.name().index()), c.name().index());\n@@ -652,2 +660,1 @@\n-        @Override\n-        public String visitPackage(CONSTANT_Package_info c, Integer p) {\n+        public String visitPackage(PackageEntry c, Integer p) {\n@@ -658,1 +665,1 @@\n-                    value = visit(cfpool.get(c.name_index), c.name_index);\n+                    value = visit(cfpool.entryByIndex(c.name().index()), c.name().index());\n@@ -667,2 +674,1 @@\n-        @Override\n-        public String visitString(CONSTANT_String_info c, Integer p) {\n+        public String visitString(StringEntry c, Integer p) {\n@@ -673,1 +679,1 @@\n-                    value = c.getString();\n+                    value = c.stringValue();\n@@ -682,2 +688,1 @@\n-        @Override\n-        public String  visitUtf8(CONSTANT_Utf8_info cnstnt, Integer p) {\n+        public String  visitUtf8(Utf8Entry cnstnt, Integer p) {\n@@ -687,1 +692,1 @@\n-                value = cnstnt.value;\n+                value = cnstnt.stringValue();\n","filename":"test\/langtools\/tools\/javac\/lambda\/ByteCodeTest.java","additions":94,"deletions":89,"binary":false,"changes":183,"status":"modified"},{"patch":"@@ -28,1 +28,6 @@\n- * @modules jdk.jdeps\/com.sun.tools.classfile\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.classfile.instruction\n+ *          java.base\/jdk.internal.classfile.components\n+ *          java.base\/jdk.internal.classfile.impl\n@@ -36,1 +41,2 @@\n-import com.sun.tools.classfile.*;\n+import jdk.internal.classfile.*;\n+import jdk.internal.classfile.attribute.*;\n@@ -45,1 +51,1 @@\n- * LocalVariableTable entry: it is assumed that if a entry is present, it\n+ * LocalVariableTable entry: it is assumed that if an entry is present, it\n@@ -50,1 +56,1 @@\n- * that will mapped into a lambda method, and because the test is compiled\n+ * that will map into a lambda method, and because the test is compiled\n@@ -84,2 +90,2 @@\n-        ClassFile cf = ClassFile.read(getClass().getResource(c.getName() + \".class\").openStream());\n-        Method m = getLambdaMethod(cf);\n+        ClassModel cm = Classfile.of().parse(Objects.requireNonNull(getClass().getResource(c.getName() + \".class\")).openStream().readAllBytes());\n+        MethodModel m = getLambdaMethod(cm);\n@@ -91,1 +97,1 @@\n-        Code_attribute code = (Code_attribute) m.attributes.get(Attribute.Code);\n+        CodeAttribute code = m.findAttribute(Attributes.CODE).orElse(null);\n@@ -97,2 +103,1 @@\n-        LocalVariableTable_attribute lvt =\n-                (LocalVariableTable_attribute) code.attributes.get(Attribute.LocalVariableTable);\n+        LocalVariableTableAttribute lvt = code.findAttribute(Attributes.LOCAL_VARIABLE_TABLE).orElse(null);\n@@ -105,2 +110,2 @@\n-        for (LocalVariableTable_attribute.Entry e: lvt.local_variable_table) {\n-            foundNames.add(cf.constant_pool.getUTF8Value(e.name_index));\n+        for (LocalVariableInfo e: lvt.localVariables()) {\n+            foundNames.add(e.name().stringValue());\n@@ -123,3 +128,3 @@\n-    Method getLambdaMethod(ClassFile cf) throws ConstantPoolException {\n-        for (Method m: cf.methods) {\n-            if (m.getName(cf.constant_pool).startsWith(\"lambda$\"))\n+    MethodModel getLambdaMethod(ClassModel cf) {\n+        for (MethodModel m: cf.methods()) {\n+            if (m.methodName().stringValue().startsWith(\"lambda$\"))\n","filename":"test\/langtools\/tools\/javac\/lambda\/LocalVariableTable.java","additions":19,"deletions":14,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -29,1 +29,6 @@\n- * @modules jdk.jdeps\/com.sun.tools.classfile\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.classfile.instruction\n+ *          java.base\/jdk.internal.classfile.components\n+ *          java.base\/jdk.internal.classfile.impl\n@@ -55,3 +60,2 @@\n-import com.sun.tools.classfile.Attribute;\n-import com.sun.tools.classfile.BootstrapMethods_attribute;\n-import com.sun.tools.classfile.ClassFile;\n+import jdk.internal.classfile.*;\n+import jdk.internal.classfile.attribute.BootstrapMethodsAttribute;\n@@ -114,5 +118,3 @@\n-            ClassFile cf = ClassFile.read(compiledTest);\n-            BootstrapMethods_attribute bsm_attr =\n-                    (BootstrapMethods_attribute)cf\n-                            .getAttribute(Attribute.BootstrapMethods);\n-            int length = bsm_attr.bootstrap_method_specifiers.length;\n+            ClassModel cf = Classfile.of().parse(compiledTest.toPath());\n+            BootstrapMethodsAttribute bsm_attr = cf.findAttribute(Attributes.BOOTSTRAP_METHODS).orElseThrow();\n+            int length = bsm_attr.bootstrapMethodsSize();\n","filename":"test\/langtools\/tools\/javac\/lambda\/TestBootstrapMethodsCount.java","additions":11,"deletions":9,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -31,1 +31,6 @@\n- * @modules jdk.jdeps\/com.sun.tools.classfile\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.classfile.instruction\n+ *          java.base\/jdk.internal.classfile.components\n+ *          java.base\/jdk.internal.classfile.impl\n@@ -44,0 +49,1 @@\n+import java.lang.invoke.MethodHandleInfo;\n@@ -53,8 +59,4 @@\n-import com.sun.tools.classfile.Attribute;\n-import com.sun.tools.classfile.BootstrapMethods_attribute;\n-import com.sun.tools.classfile.ClassFile;\n-import com.sun.tools.classfile.Code_attribute;\n-import com.sun.tools.classfile.ConstantPool.*;\n-import com.sun.tools.classfile.Instruction;\n-import com.sun.tools.classfile.LineNumberTable_attribute;\n-import com.sun.tools.classfile.Method;\n+import jdk.internal.classfile.*;\n+import jdk.internal.classfile.attribute.*;\n+import jdk.internal.classfile.constantpool.*;\n+import jdk.internal.classfile.instruction.InvokeDynamicInstruction;\n@@ -84,3 +86,3 @@\n-            boolean check(CPInfo cpInfo) throws Exception {\n-                return (cpInfo instanceof CONSTANT_String_info) &&\n-                        ((CONSTANT_String_info)cpInfo).getString()\n+            boolean check(PoolEntry poolEntry) throws Exception {\n+                return (poolEntry instanceof StringEntry) &&\n+                        ((StringEntry)poolEntry).stringValue()\n@@ -92,4 +94,4 @@\n-            boolean check(CPInfo cpInfo) throws Exception {\n-                return (cpInfo instanceof CONSTANT_Class_info) &&\n-                        ((CONSTANT_Class_info)cpInfo).getName()\n-                        .equals(\"java\/lang\/String\");\n+            boolean check(PoolEntry poolEntry) throws Exception {\n+                return (poolEntry instanceof ClassEntry) &&\n+                        ((ClassEntry)poolEntry).name()\n+                        .equalsString(\"java\/lang\/String\");\n@@ -100,4 +102,4 @@\n-            boolean check(CPInfo cpInfo) throws Exception {\n-                return (cpInfo instanceof CONSTANT_Integer_info) &&\n-                        ((CONSTANT_Integer_info)cpInfo).value ==\n-                        ((Integer)value).intValue();\n+            boolean check( PoolEntry poolEntry) throws Exception {\n+                return (poolEntry instanceof IntegerEntry) &&\n+                        ((IntegerEntry)poolEntry).intValue() ==\n+                                (Integer) value;\n@@ -108,4 +110,4 @@\n-            boolean check(CPInfo cpInfo) throws Exception {\n-                return (cpInfo instanceof CONSTANT_Long_info) &&\n-                        ((CONSTANT_Long_info)cpInfo).value ==\n-                        ((Long)value).longValue();\n+            boolean check( PoolEntry poolEntry) throws Exception {\n+                return (poolEntry instanceof LongEntry) &&\n+                        ((LongEntry)poolEntry).longValue() ==\n+                                (Long) value;\n@@ -116,4 +118,4 @@\n-            boolean check(CPInfo cpInfo) throws Exception {\n-                return (cpInfo instanceof CONSTANT_Float_info) &&\n-                        ((CONSTANT_Float_info)cpInfo).value ==\n-                        ((Float)value).floatValue();\n+            boolean check( PoolEntry poolEntry) throws Exception {\n+                return (poolEntry instanceof FloatEntry) &&\n+                        ((FloatEntry)poolEntry).floatValue() ==\n+                                (Float) value;\n@@ -124,4 +126,4 @@\n-            boolean check(CPInfo cpInfo) throws Exception {\n-                return (cpInfo instanceof CONSTANT_Double_info) &&\n-                        ((CONSTANT_Double_info)cpInfo).value ==\n-                        ((Double)value).doubleValue();\n+            boolean check( PoolEntry poolEntry) throws Exception {\n+                return (poolEntry instanceof DoubleEntry) &&\n+                        ((DoubleEntry)poolEntry).doubleValue() ==\n+                                (Double) value;\n@@ -132,2 +134,2 @@\n-            boolean check(CPInfo cpInfo) throws Exception {\n-                if (!(cpInfo instanceof CONSTANT_MethodHandle_info))\n+            boolean check( PoolEntry poolEntry) throws Exception {\n+                if (!(poolEntry instanceof MethodHandleEntry handleInfo))\n@@ -135,8 +137,4 @@\n-                CONSTANT_MethodHandle_info handleInfo =\n-                        (CONSTANT_MethodHandle_info)cpInfo;\n-                return handleInfo.getCPRefInfo().getClassName().equals(\"Array\") &&\n-                        handleInfo.reference_kind == RefKind.REF_invokeVirtual &&\n-                        handleInfo.getCPRefInfo()\n-                        .getNameAndTypeInfo().getName().equals(\"clone\") &&\n-                        handleInfo.getCPRefInfo()\n-                        .getNameAndTypeInfo().getType().equals(\"()Ljava\/lang\/Object;\");\n+                return handleInfo.reference().owner().name().equalsString(\"Array\") &&\n+                        handleInfo.kind() == MethodHandleInfo.REF_invokeVirtual &&\n+                        handleInfo.reference().name().equalsString(\"clone\") &&\n+                        handleInfo.reference().type().equalsString(\"()Ljava\/lang\/Object;\");\n@@ -147,4 +145,3 @@\n-            boolean check(CPInfo cpInfo) throws Exception {\n-                return (cpInfo instanceof CONSTANT_MethodType_info) &&\n-                        ((CONSTANT_MethodType_info)cpInfo).getType()\n-                        .equals(\"()Ljava\/lang\/Object;\");\n+            boolean check( PoolEntry poolEntry) throws Exception {\n+                return (poolEntry instanceof MethodTypeEntry methodTypeEntry) &&\n+                        methodTypeEntry.asSymbol().descriptorString().equals(\"()Ljava\/lang\/Object;\");\n@@ -165,1 +162,1 @@\n-        abstract boolean check(CPInfo cpInfo) throws Exception;\n+        abstract boolean check( PoolEntry poolEntry) throws Exception;\n@@ -168,20 +165,11 @@\n-            switch (this) {\n-                case STRING:\n-                    return LoadableConstant.String((String)value);\n-                case INTEGER:\n-                    return LoadableConstant.Int((Integer)value);\n-                case LONG:\n-                    return LoadableConstant.Long((Long)value);\n-                case FLOAT:\n-                    return LoadableConstant.Float((Float)value);\n-                case DOUBLE:\n-                    return LoadableConstant.Double((Double)value);\n-                case CLASS:\n-                    return (ClassType)syms.stringType;\n-                case METHOD_HANDLE:\n-                    return syms.arrayCloneMethod.asHandle();\n-                case METHOD_TYPE:\n-                    return ((MethodType)syms.arrayCloneMethod.type);\n-                default:\n-                    throw new AssertionError();\n-            }\n+            return switch (this) {\n+                case STRING -> LoadableConstant.String((String) value);\n+                case INTEGER -> LoadableConstant.Int((Integer) value);\n+                case LONG -> LoadableConstant.Long((Long) value);\n+                case FLOAT -> LoadableConstant.Float((Float) value);\n+                case DOUBLE -> LoadableConstant.Double((Double) value);\n+                case CLASS -> (ClassType) syms.stringType;\n+                case METHOD_HANDLE -> syms.arrayCloneMethod.asHandle();\n+                case METHOD_TYPE -> ((MethodType) syms.arrayCloneMethod.type);\n+                default -> throw new AssertionError();\n+            };\n@@ -272,4 +260,4 @@\n-            ClassFile cf = ClassFile.read(is);\n-            Method testMethod = null;\n-            for (Method m : cf.methods) {\n-                if (m.getName(cf.constant_pool).equals(\"test\")) {\n+            ClassModel cm = Classfile.of().parse(is.readAllBytes());\n+            MethodModel testMethod = null;\n+            for (MethodModel m : cm.methods()) {\n+                if (m.methodName().equalsString(\"test\")) {\n@@ -284,3 +272,2 @@\n-            Code_attribute ea =\n-                    (Code_attribute)testMethod.attributes.get(Attribute.Code);\n-            if (testMethod == null) {\n+            CodeAttribute ea = testMethod.findAttribute(Attributes.CODE).orElse(null);\n+            if (ea == null) {\n@@ -293,7 +280,5 @@\n-            for (Instruction i : ea.getInstructions()) {\n-                if (i.getMnemonic().equals(\"invokedynamic\")) {\n-                    CONSTANT_InvokeDynamic_info indyInfo =\n-                         (CONSTANT_InvokeDynamic_info)cf\n-                            .constant_pool.get(i.getShort(1));\n-                    bsmIdx = indyInfo.bootstrap_method_attr_index;\n-                    if (!indyInfo.getNameAndTypeInfo().getType().equals(\"()V\")) {\n+            for (CodeElement ce : ea.elementList()) {\n+                if (ce instanceof InvokeDynamicInstruction indy) {\n+                    InvokeDynamicEntry indyEntry = indy.invokedynamic();\n+                    bsmIdx = indyEntry.bootstrap().bsmIndex();\n+                    if (!indyEntry.type().equalsString(\"()V\")) {\n@@ -310,4 +295,3 @@\n-            BootstrapMethods_attribute bsm_attr =\n-                    (BootstrapMethods_attribute)cf\n-                    .getAttribute(Attribute.BootstrapMethods);\n-            if (bsm_attr.bootstrap_method_specifiers.length != 1) {\n+            BootstrapMethodsAttribute bsm_attr = cm\n+                    .findAttribute(Attributes.BOOTSTRAP_METHODS).orElseThrow();\n+            if (bsm_attr.bootstrapMethodsSize() != 1) {\n@@ -318,2 +302,2 @@\n-            BootstrapMethods_attribute.BootstrapMethodSpecifier bsm_spec =\n-                    bsm_attr.bootstrap_method_specifiers[0];\n+            BootstrapMethodEntry bsm_spec =\n+                    bsm_attr.bootstrapMethods().getFirst();\n@@ -321,1 +305,1 @@\n-            if (bsm_spec.bootstrap_arguments.length != arity.arity) {\n+            if (bsm_spec.arguments().size() != arity.arity) {\n@@ -328,2 +312,1 @@\n-                if (!saks[i].check(cf.constant_pool\n-                        .get(bsm_spec.bootstrap_arguments[i]))) {\n+                if (!saks[i].check(bsm_spec.arguments().get(i))) {\n@@ -335,3 +318,1 @@\n-            CONSTANT_MethodHandle_info bsm_handle =\n-                    (CONSTANT_MethodHandle_info)cf.constant_pool\n-                    .get(bsm_spec.bootstrap_method_ref);\n+            MethodHandleEntry bsm_handle = bsm_spec.bootstrapMethod();\n@@ -339,1 +320,1 @@\n-            if (bsm_handle.reference_kind != RefKind.REF_invokeStatic) {\n+            if (bsm_handle.kind() != MethodHandleInfo.REF_invokeStatic) {\n@@ -344,3 +325,1 @@\n-            CONSTANT_Methodref_info bsm_ref =\n-                    (CONSTANT_Methodref_info)cf.constant_pool\n-                    .get(bsm_handle.reference_index);\n+            MemberRefEntry bsm_ref =bsm_handle.reference();\n@@ -348,1 +327,1 @@\n-            if (!bsm_ref.getClassInfo().getName().equals(\"Bootstrap\")) {\n+            if (!bsm_ref.owner().name().equalsString(\"Bootstrap\")) {\n@@ -353,1 +332,1 @@\n-            if (!bsm_ref.getNameAndTypeInfo().getName().equals(\"bsm\")) {\n+            if (!bsm_ref.name().equalsString(\"bsm\")) {\n@@ -358,2 +337,1 @@\n-            if (!bsm_ref.getNameAndTypeInfo()\n-                    .getType().equals(asBSMSignatureString())) {\n+            if (!bsm_ref.type().equalsString(asBSMSignatureString())) {\n@@ -361,1 +339,1 @@\n-                        bsm_ref.getNameAndTypeInfo().getType() + \" \" +\n+                        bsm_ref.type().stringValue() + \" \" +\n@@ -366,2 +344,1 @@\n-            LineNumberTable_attribute lnt =\n-                    (LineNumberTable_attribute)ea.attributes.get(Attribute.LineNumberTable);\n+            LineNumberTableAttribute lnt = ea.findAttribute(Attributes.LINE_NUMBER_TABLE).orElse(null);\n@@ -373,1 +350,1 @@\n-            if (lnt.line_number_table_length != 3) {\n+            if (lnt.lineNumbers().size() != 3) {\n","filename":"test\/langtools\/tools\/javac\/lambda\/TestInvokeDynamic.java","additions":82,"deletions":105,"binary":false,"changes":187,"status":"modified"},{"patch":"@@ -30,1 +30,6 @@\n- * @modules jdk.jdeps\/com.sun.tools.classfile\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.classfile.instruction\n+ *          java.base\/jdk.internal.classfile.components\n+ *          java.base\/jdk.internal.classfile.impl\n@@ -38,7 +43,4 @@\n-import com.sun.tools.classfile.Attribute;\n-import com.sun.tools.classfile.BootstrapMethods_attribute;\n-import com.sun.tools.classfile.ClassFile;\n-import com.sun.tools.classfile.Code_attribute;\n-import com.sun.tools.classfile.ConstantPool.*;\n-import com.sun.tools.classfile.Instruction;\n-import com.sun.tools.classfile.Method;\n+import jdk.internal.classfile.*;\n+import jdk.internal.classfile.attribute.*;\n+import jdk.internal.classfile.constantpool.*;\n+import jdk.internal.classfile.instruction.InvokeDynamicInstruction;\n@@ -48,0 +50,1 @@\n+import java.lang.invoke.MethodHandleInfo;\n@@ -210,4 +213,4 @@\n-            ClassFile cf = ClassFile.read(is);\n-            Method testMethod = null;\n-            for (Method m : cf.methods) {\n-                if (m.getName(cf.constant_pool).equals(\"test\")) {\n+            ClassModel cf = Classfile.of().parse(is.readAllBytes());\n+            MethodModel testMethod = null;\n+            for (MethodModel m : cf.methods()) {\n+                if (m.methodName().equalsString(\"test\")) {\n@@ -222,3 +225,2 @@\n-            Code_attribute ea =\n-                    (Code_attribute)testMethod.attributes.get(Attribute.Code);\n-            if (testMethod == null) {\n+            CodeAttribute ea = testMethod.findAttribute(Attributes.CODE).orElse(null);\n+            if (ea == null) {\n@@ -231,7 +233,5 @@\n-            for (Instruction i : ea.getInstructions()) {\n-                if (i.getMnemonic().equals(\"invokedynamic\")) {\n-                    CONSTANT_InvokeDynamic_info indyInfo =\n-                         (CONSTANT_InvokeDynamic_info)cf\n-                            .constant_pool.get(i.getShort(1));\n-                    bsmIdx = indyInfo.bootstrap_method_attr_index;\n-                    if (!indyInfo.getNameAndTypeInfo().getType().equals(makeIndyType())) {\n+            for (CodeElement ce : ea.elementList()) {\n+                if (ce instanceof InvokeDynamicInstruction indy) {\n+                    InvokeDynamicEntry indyInfo = indy.invokedynamic();\n+                    bsmIdx = indyInfo.bootstrap().bsmIndex();\n+                    if (!indyInfo.type().equalsString(makeIndyType())) {\n@@ -239,1 +239,1 @@\n-                                res.compilationInfo() + \"\\n\" + indyInfo.getNameAndTypeInfo().getType() +\n+                                res.compilationInfo() + \"\\n\" + indyInfo.type().stringValue() +\n@@ -250,4 +250,2 @@\n-            BootstrapMethods_attribute bsm_attr =\n-                    (BootstrapMethods_attribute)cf\n-                    .getAttribute(Attribute.BootstrapMethods);\n-            if (bsm_attr.bootstrap_method_specifiers.length != 1) {\n+            BootstrapMethodsAttribute bsm_attr = cf.findAttribute(Attributes.BOOTSTRAP_METHODS).orElseThrow();\n+            if (bsm_attr.bootstrapMethodsSize() != 1) {\n@@ -258,2 +256,1 @@\n-            BootstrapMethods_attribute.BootstrapMethodSpecifier bsm_spec =\n-                    bsm_attr.bootstrap_method_specifiers[0];\n+            BootstrapMethodEntry bsm_spec = bsm_attr.bootstrapMethods().get(0);\n@@ -261,1 +258,1 @@\n-            if (bsm_spec.bootstrap_arguments.length != MF_ARITY) {\n+            if (bsm_spec.arguments().size() != MF_ARITY) {\n@@ -267,2 +264,1 @@\n-            CONSTANT_MethodHandle_info mh =\n-                    (CONSTANT_MethodHandle_info)cf.constant_pool.get(bsm_spec.bootstrap_arguments[1]);\n+            MethodHandleEntry mh = (MethodHandleEntry) bsm_spec.arguments().get(1);\n@@ -270,8 +266,6 @@\n-            boolean kindOK;\n-            switch (mh.reference_kind) {\n-                case REF_invokeStatic: kindOK = mk2.isStatic(); break;\n-                case REF_invokeVirtual: kindOK = !mk2.isStatic() && !mk2.inInterface(); break;\n-                case REF_invokeInterface: kindOK = mk2.inInterface(); break;\n-                default:\n-                    kindOK = false;\n-            }\n+            boolean kindOK = switch (mh.kind()) {\n+                case MethodHandleInfo.REF_invokeStatic -> mk2.isStatic();\n+                case MethodHandleInfo.REF_invokeVirtual -> !mk2.isStatic() && !mk2.inInterface();\n+                case MethodHandleInfo.REF_invokeInterface -> mk2.inInterface();\n+                default -> false;\n+            };\n@@ -280,1 +274,1 @@\n-                fail(\"Bad invoke kind in implementation method handle: \" + mh.reference_kind);\n+                fail(\"Bad invoke kind in implementation method handle: \" + mh.kind());\n@@ -284,1 +278,1 @@\n-            if (!mh.getCPRefInfo().getNameAndTypeInfo().getType().toString().equals(MH_SIG)) {\n+            if (!mh.reference().type().equalsString(MH_SIG)) {\n","filename":"test\/langtools\/tools\/javac\/lambda\/bytecode\/TestLambdaBytecode.java","additions":36,"deletions":42,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -30,1 +30,6 @@\n- * @modules jdk.jdeps\/com.sun.tools.classfile\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.classfile.instruction\n+ *          java.base\/jdk.internal.classfile.components\n+ *          java.base\/jdk.internal.classfile.impl\n@@ -38,7 +43,5 @@\n-import com.sun.tools.classfile.Attribute;\n-import com.sun.tools.classfile.BootstrapMethods_attribute;\n-import com.sun.tools.classfile.ClassFile;\n-import com.sun.tools.classfile.Code_attribute;\n-import com.sun.tools.classfile.ConstantPool.*;\n-import com.sun.tools.classfile.Instruction;\n-import com.sun.tools.classfile.Method;\n+import jdk.internal.classfile.*;\n+import jdk.internal.classfile.attribute.*;\n+import jdk.internal.classfile.constantpool.InvokeDynamicEntry;\n+import jdk.internal.classfile.constantpool.MethodHandleEntry;\n+import jdk.internal.classfile.instruction.InvokeDynamicInstruction;\n@@ -54,0 +57,1 @@\n+import java.lang.invoke.MethodHandleInfo;\n@@ -211,4 +215,4 @@\n-            ClassFile cf = ClassFile.read(is);\n-            Method testMethod = null;\n-            for (Method m : cf.methods) {\n-                if (m.getName(cf.constant_pool).equals(\"test\")) {\n+            ClassModel cm = Classfile.of().parse(is.readAllBytes());\n+            MethodModel testMethod = null;\n+            for (MethodModel m : cm.methods()) {\n+                if (m.methodName().equalsString(\"test\")) {\n@@ -223,3 +227,2 @@\n-            Code_attribute ea =\n-                    (Code_attribute)testMethod.attributes.get(Attribute.Code);\n-            if (testMethod == null) {\n+            CodeAttribute ea = testMethod.findAttribute(Attributes.CODE).orElse(null);\n+            if (ea == null) {\n@@ -232,7 +235,5 @@\n-            for (Instruction i : ea.getInstructions()) {\n-                if (i.getMnemonic().equals(\"invokedynamic\")) {\n-                    CONSTANT_InvokeDynamic_info indyInfo =\n-                         (CONSTANT_InvokeDynamic_info)cf\n-                            .constant_pool.get(i.getShort(1));\n-                    bsmIdx = indyInfo.bootstrap_method_attr_index;\n-                    if (!indyInfo.getNameAndTypeInfo().getType().equals(makeIndyType())) {\n+            for (CodeElement ce : ea.elementList()) {\n+                if (ce instanceof InvokeDynamicInstruction indy) {\n+                    InvokeDynamicEntry indyInfo = indy.invokedynamic();\n+                    bsmIdx = indyInfo.bootstrap().bsmIndex();\n+                    if (!indyInfo.type().equalsString(makeIndyType())) {\n@@ -240,1 +241,1 @@\n-                                res.compilationInfo() + \"\\n\" + indyInfo.getNameAndTypeInfo().getType() +\n+                                res.compilationInfo() + \"\\n\" + indyInfo.type().stringValue() +\n@@ -251,4 +252,2 @@\n-            BootstrapMethods_attribute bsm_attr =\n-                    (BootstrapMethods_attribute)cf\n-                    .getAttribute(Attribute.BootstrapMethods);\n-            if (bsm_attr.bootstrap_method_specifiers.length != 1) {\n+            BootstrapMethodsAttribute bsm_attr = cm.findAttribute(Attributes.BOOTSTRAP_METHODS).orElseThrow();\n+            if (bsm_attr.bootstrapMethodsSize() != 1) {\n@@ -259,2 +258,1 @@\n-            BootstrapMethods_attribute.BootstrapMethodSpecifier bsm_spec =\n-                    bsm_attr.bootstrap_method_specifiers[0];\n+            BootstrapMethodEntry bsm_spec = bsm_attr.bootstrapMethods().get(0);\n@@ -262,1 +260,1 @@\n-            if (bsm_spec.bootstrap_arguments.length != MF_ARITY) {\n+            if (bsm_spec.arguments().size() != MF_ARITY) {\n@@ -268,2 +266,1 @@\n-            CONSTANT_MethodHandle_info mh =\n-                    (CONSTANT_MethodHandle_info)cf.constant_pool.get(bsm_spec.bootstrap_arguments[1]);\n+            MethodHandleEntry mh = (MethodHandleEntry) bsm_spec.arguments().get(1);\n@@ -271,8 +268,6 @@\n-            boolean kindOK;\n-            switch (mh.reference_kind) {\n-                case REF_invokeStatic: kindOK = mk2.isStatic(); break;\n-                case REF_invokeSpecial: kindOK = !mk2.isStatic(); break;\n-                case REF_invokeInterface: kindOK = mk2.inInterface(); break;\n-                default:\n-                    kindOK = false;\n-            }\n+            boolean kindOK = switch (mh.kind()) {\n+                case MethodHandleInfo.REF_invokeStatic -> mk2.isStatic();\n+                case MethodHandleInfo.REF_invokeSpecial -> !mk2.isStatic();\n+                case MethodHandleInfo.REF_invokeInterface -> mk2.inInterface();\n+                default -> false;\n+            };\n@@ -285,1 +280,1 @@\n-            if (!mh.getCPRefInfo().getNameAndTypeInfo().getType().toString().equals(MH_SIG)) {\n+            if (!mh.reference().type().equalsString(MH_SIG)) {\n@@ -287,1 +282,0 @@\n-                return;\n","filename":"test\/langtools\/tools\/javac\/lambda\/bytecode\/TestLambdaBytecodeTargetRelease14.java","additions":36,"deletions":42,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -27,1 +27,7 @@\n- * @modules jdk.jdeps\/com.sun.tools.classfile jdk.compiler\/com.sun.tools.javac.api\n+ * @modules java.base\/jdk.internal.classfile\n+ *     java.base\/jdk.internal.classfile.attribute\n+ *     java.base\/jdk.internal.classfile.constantpool\n+ *     java.base\/jdk.internal.classfile.instruction\n+ *     java.base\/jdk.internal.classfile.components\n+ *     java.base\/jdk.internal.classfile.impl\n+ *     jdk.compiler\/com.sun.tools.javac.api\n@@ -43,5 +49,4 @@\n-import com.sun.tools.classfile.Attribute;\n-import com.sun.tools.classfile.BootstrapMethods_attribute;\n-import com.sun.tools.classfile.BootstrapMethods_attribute.BootstrapMethodSpecifier;\n-import com.sun.tools.classfile.ClassFile;\n-import com.sun.tools.classfile.ConstantPool.CONSTANT_MethodHandle_info;\n+import jdk.internal.classfile.BootstrapMethodEntry;\n+import jdk.internal.classfile.*;\n+import jdk.internal.classfile.attribute.BootstrapMethodsAttribute;\n+import jdk.internal.classfile.constantpool.MethodHandleEntry;\n@@ -139,1 +144,1 @@\n-            ClassFile cf;\n+            ClassModel cm;\n@@ -141,1 +146,1 @@\n-                cf = ClassFile.read(input);\n+                cm = Classfile.of().parse(input.readAllBytes());\n@@ -143,1 +148,1 @@\n-            if (cf.getName().equals(\"com\/sun\/tools\/javac\/comp\/Deduplication$R\")) {\n+            if (cm.thisClass().asInternalName().equals(\"com\/sun\/tools\/javac\/comp\/Deduplication$R\")) {\n@@ -146,3 +151,2 @@\n-            BootstrapMethods_attribute bsm =\n-                    (BootstrapMethods_attribute) cf.getAttribute(Attribute.BootstrapMethods);\n-            for (BootstrapMethodSpecifier b : bsm.bootstrap_method_specifiers) {\n+            BootstrapMethodsAttribute bsm = cm.findAttribute(Attributes.BOOTSTRAP_METHODS).orElseThrow();\n+            for (BootstrapMethodEntry b : bsm.bootstrapMethods()) {\n@@ -150,5 +154,3 @@\n-                        ((CONSTANT_MethodHandle_info)\n-                                        cf.constant_pool.get(b.bootstrap_arguments[1]))\n-                                .getCPRefInfo()\n-                                .getNameAndTypeInfo()\n-                                .getName());\n+                        ((MethodHandleEntry)b.arguments().get(1))\n+                                .reference()\n+                                .name().stringValue());\n","filename":"test\/langtools\/tools\/javac\/lambda\/deduplication\/DeduplicationTest.java","additions":19,"deletions":17,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -29,1 +29,6 @@\n- * @modules jdk.jdeps\/com.sun.tools.classfile\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.classfile.instruction\n+ *          java.base\/jdk.internal.classfile.components\n+ *          java.base\/jdk.internal.classfile.impl\n@@ -43,2 +48,1 @@\n-import com.sun.tools.classfile.ClassFile;\n-import com.sun.tools.classfile.Method;\n+import jdk.internal.classfile.*;\n@@ -86,1 +90,1 @@\n-                    ClassFile cf = ClassFile.read(in);\n+                    ClassModel cf = Classfile.of().parse(in.readAllBytes());\n@@ -89,2 +93,2 @@\n-                    for (Method m : cf.methods) {\n-                        String methodName = m.getName(cf.constant_pool);\n+                    for (MethodModel m : cf.methods()) {\n+                        String methodName = m.methodName().stringValue();\n","filename":"test\/langtools\/tools\/javac\/lambda\/lambdaNaming\/TestNonSerializableLambdaNameStability.java","additions":10,"deletions":6,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n- * @modules jdk.compiler jdk.jdeps\n+ * @modules jdk.compiler\n@@ -56,2 +56,2 @@\n-            .vmOptions(\"--add-modules\", \"jdk.jdeps\",\n-                       \"--add-exports\", \"jdk.jdeps\/com.sun.tools.classfile=ALL-UNNAMED\")\n+            .vmOptions(\"--add-exports\", \"java.base\/jdk.internal.classfile=ALL-UNNAMED\",\n+                    \"--add-exports\", \"java.base\/jdk.internal.classfile.constantpool=ALL-UNNAMED\")\n","filename":"test\/langtools\/tools\/javac\/launcher\/GetResourceTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -32,1 +32,7 @@\n- *          jdk.jdeps\/com.sun.tools.classfile\n+ *          java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.classfile.instruction\n+ *          java.base\/jdk.internal.classfile.components\n+ *          java.base\/jdk.internal.classfile.impl\n+ *          java.base\/jdk.internal.module\n@@ -37,7 +43,2 @@\n-import com.sun.tools.classfile.Attribute;\n-import com.sun.tools.classfile.Attributes;\n-import com.sun.tools.classfile.ClassFile;\n-import com.sun.tools.classfile.ClassWriter;\n-import com.sun.tools.classfile.ConstantPool;\n-import com.sun.tools.classfile.ConstantPool.CPInfo;\n-import com.sun.tools.classfile.ModuleResolution_attribute;\n+import jdk.internal.classfile.*;\n+import jdk.internal.classfile.attribute.ModuleResolutionAttribute;\n@@ -73,0 +74,2 @@\n+import static jdk.internal.module.ClassFileConstants.WARN_INCUBATING;\n+\n@@ -720,21 +723,4 @@\n-            ClassFile cf = ClassFile.read(moduleInfoFile);\n-            List<CPInfo> newPool = new ArrayList<>();\n-            newPool.add(null);\n-            cf.constant_pool.entries().forEach(newPool::add);\n-            int moduleResolutionIndex = newPool.size();\n-            newPool.add(new ConstantPool.CONSTANT_Utf8_info(Attribute.ModuleResolution));\n-            Map<String, Attribute> newAttributes = new HashMap<>(cf.attributes.map);\n-            newAttributes.put(Attribute.ModuleResolution,\n-                              new ModuleResolution_attribute(moduleResolutionIndex,\n-                                                             ModuleResolution_attribute.WARN_INCUBATING));\n-            ClassFile newClassFile = new ClassFile(cf.magic,\n-                                                   cf.minor_version,\n-                                                   cf.major_version,\n-                                                   new ConstantPool(newPool.toArray(new CPInfo[0])),\n-                                                   cf.access_flags,\n-                                                   cf.this_class,\n-                                                   cf.super_class,\n-                                                   cf.interfaces,\n-                                                   cf.fields,\n-                                                   cf.methods,\n-                                                   new Attributes(newAttributes));\n+            ClassModel cf = Classfile.of().parse(moduleInfoFile);\n+            ModuleResolutionAttribute newAttr = ModuleResolutionAttribute.of(WARN_INCUBATING);\n+            byte[] newBytes = Classfile.of().transform(cf, ClassTransform.dropping(ce -> ce instanceof Attributes)\n+                    .andThen(ClassTransform.endHandler(classBuilder -> classBuilder.with(newAttr))));\n@@ -742,1 +728,1 @@\n-                new ClassWriter().write(newClassFile, out);\n+                out.write(newBytes);\n","filename":"test\/langtools\/tools\/javac\/launcher\/SourceLauncherTest.java","additions":16,"deletions":30,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -34,2 +34,1 @@\n- *      --add-modules jdk.jdeps \\\n- *      --add-exports jdk.jdeps\/com.sun.tools.classfile=ALL-UNNAMED\n+ *      --add-exports java.base\/jdk.internal.classfile=ALL-UNNAMED\n@@ -43,1 +42,2 @@\n-import com.sun.tools.classfile.ClassFile;\n+import jdk.internal.classfile.ClassModel;\n+import jdk.internal.classfile.Classfile;\n@@ -155,4 +155,4 @@\n-        ClassFile cf = ClassFile.read(in);\n-        System.err.println(\"    class \" + cf.getName());\n-        if (!name.equals(cf.getName() + \".class\")) {\n-            error(\"unexpected class found: \" + cf.getName());\n+        ClassModel cf = Classfile.of().parse(in.readAllBytes());\n+        System.err.println(\"    class \" + cf.thisClass().asInternalName());\n+        if (!name.equals(cf.thisClass().asInternalName() + \".class\")) {\n+            error(\"unexpected class found: \" + cf.thisClass().asInternalName());\n","filename":"test\/langtools\/tools\/javac\/launcher\/src\/CLTest.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -28,1 +28,5 @@\n- * @modules jdk.jdeps\/com.sun.tools.classfile\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.classfile.instruction\n+ *          java.base\/jdk.internal.classfile.components\n@@ -31,7 +35,2 @@\n-import com.sun.tools.classfile.ClassFile;\n-import com.sun.tools.classfile.ConstantPoolException;\n-import com.sun.tools.classfile.Method;\n-import com.sun.tools.classfile.Attribute;\n-import com.sun.tools.classfile.Code_attribute;\n-import com.sun.tools.classfile.LineNumberTable_attribute;\n-import com.sun.tools.classfile.LineNumberTable_attribute.Entry;\n+import jdk.internal.classfile.*;\n+import jdk.internal.classfile.attribute.*;\n@@ -40,0 +39,1 @@\n+import java.util.List;\n@@ -44,1 +44,1 @@\n-        Entry[] lines = findEntries();\n+        List<LineNumberInfo> lines = findEntries();\n@@ -48,1 +48,1 @@\n-        if (lines.length != 5) {\n+        if (lines.size() != 5) {\n@@ -51,2 +51,2 @@\n-            for (Entry e : lines) {\n-                System.err.println(e.line_number);\n+            for (LineNumberInfo e : lines) {\n+                System.err.println(e.lineNumber());\n@@ -54,1 +54,1 @@\n-            throw new Exception(\"finally line number table incorrect: length=\" + lines.length + \" expected length=5\");\n+            throw new Exception(\"finally line number table incorrect: length=\" + lines.size() + \" expected length=5\");\n@@ -58,1 +58,1 @@\n-        int current = lines[0].line_number;\n+        int current = lines.get(0).lineNumber();\n@@ -62,1 +62,1 @@\n-        current = lines[1].line_number;\n+        current = lines.get(1).lineNumber();\n@@ -68,1 +68,1 @@\n-        current = lines[2].line_number;\n+        current = lines.get(2).lineNumber();\n@@ -74,1 +74,1 @@\n-        current = lines[3].line_number;\n+        current = lines.get(3).lineNumber();\n@@ -80,1 +80,1 @@\n-        current = lines[4].line_number;\n+        current = lines.get(4).lineNumber();\n@@ -86,8 +86,8 @@\n-    static Entry[] findEntries() throws IOException, ConstantPoolException {\n-        ClassFile self = ClassFile.read(FinallyLineNumberTest.class.getResourceAsStream(\"FinallyLineNumberTest.class\"));\n-        for (Method m : self.methods) {\n-            if (\"method\".equals(m.getName(self.constant_pool))) {\n-                Code_attribute code_attribute = (Code_attribute)m.attributes.get(Attribute.Code);\n-                for (Attribute at : code_attribute.attributes) {\n-                    if (Attribute.LineNumberTable.equals(at.getName(self.constant_pool))) {\n-                        return ((LineNumberTable_attribute)at).line_number_table;\n+    static List<LineNumberInfo> findEntries() throws IOException {\n+        ClassModel self = Classfile.of().parse(FinallyLineNumberTest.class.getResourceAsStream(\"FinallyLineNumberTest.class\").readAllBytes());\n+        for (MethodModel m : self.methods()) {\n+            if (m.methodName().equalsString(\"method\")) {\n+                CodeAttribute code_attribute = m.findAttribute(Attributes.CODE).orElseThrow();\n+                for (Attribute<?> at : code_attribute.attributes()) {\n+                    if (at instanceof LineNumberTableAttribute lineAt) {\n+                        return lineAt.lineNumbers();\n","filename":"test\/langtools\/tools\/javac\/linenumbers\/FinallyLineNumberTest.java","additions":26,"deletions":26,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -5,1 +5,5 @@\n- * @modules jdk.jdeps\/com.sun.tools.classfile\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.classfile.instruction\n+ *          java.base\/jdk.internal.classfile.components\n@@ -8,7 +12,3 @@\n-import com.sun.tools.classfile.ClassFile;\n-import com.sun.tools.classfile.ConstantPoolException;\n-import com.sun.tools.classfile.Method;\n-import com.sun.tools.classfile.Attribute;\n-import com.sun.tools.classfile.Code_attribute;\n-import com.sun.tools.classfile.LineNumberTable_attribute;\n-import com.sun.tools.classfile.LineNumberTable_attribute.Entry;\n+import java.util.List;\n+import jdk.internal.classfile.*;\n+import jdk.internal.classfile.attribute.*;\n@@ -21,3 +21,3 @@\n-        Entry[] lines = findEntries();\n-        if (lines == null || lines.length != 1) {\n-            int found = lines == null ? 0 : lines.length;\n+        List<LineNumberInfo> lines = findEntries();\n+        if (lines == null || lines.size() != 1) {\n+            int found = lines == null ? 0 : lines.size();\n@@ -27,1 +27,1 @@\n-        int line = lines[0].line_number;\n+        int line = lines.get(0).lineNumber();\n@@ -33,8 +33,8 @@\n-    static Entry[] findEntries() throws IOException, ConstantPoolException {\n-        ClassFile self = ClassFile.read(NestedLineNumberTest.Test.class.getResourceAsStream(\"NestedLineNumberTest$Test.class\"));\n-        for (Method m : self.methods) {\n-            if (\"<init>\".equals(m.getName(self.constant_pool))) {\n-                Code_attribute code_attribute = (Code_attribute)m.attributes.get(Attribute.Code);\n-                for (Attribute at : code_attribute.attributes) {\n-                    if (Attribute.LineNumberTable.equals(at.getName(self.constant_pool))) {\n-                        return ((LineNumberTable_attribute)at).line_number_table;\n+    static List<LineNumberInfo> findEntries() throws IOException {\n+        ClassModel self = Classfile.of().parse(NestedLineNumberTest.Test.class.getResourceAsStream(\"NestedLineNumberTest$Test.class\").readAllBytes());\n+        for (MethodModel m : self.methods()) {\n+            if (\"<init>\".equals(m.methodName().stringValue())) {\n+                CodeAttribute code_attribute = m.findAttribute(Attributes.CODE).orElseThrow();\n+                for (Attribute<?> at : code_attribute.attributes()) {\n+                    if (at instanceof LineNumberTableAttribute lineAt) {\n+                        return lineAt.lineNumbers();\n","filename":"test\/langtools\/tools\/javac\/linenumbers\/NestedLineNumberTest.java","additions":20,"deletions":20,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -5,1 +5,5 @@\n- * @modules jdk.jdeps\/com.sun.tools.classfile\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.classfile.instruction\n+ *          java.base\/jdk.internal.classfile.components\n@@ -8,6 +12,2 @@\n-import com.sun.tools.classfile.ClassFile;\n-import com.sun.tools.classfile.ConstantPoolException;\n-import com.sun.tools.classfile.Method;\n-import com.sun.tools.classfile.Attribute;\n-import com.sun.tools.classfile.Code_attribute;\n-import com.sun.tools.classfile.LineNumberTable_attribute;\n+import jdk.internal.classfile.*;\n+import jdk.internal.classfile.attribute.*;\n@@ -66,9 +66,9 @@\n-    static List<Entry> findEntries() throws IOException, ConstantPoolException {\n-        ClassFile self = ClassFile.read(NullCheckLineNumberTest.Test.class.getResourceAsStream(\"NullCheckLineNumberTest$Test.class\"));\n-        for (Method m : self.methods) {\n-            if (\"<init>\".equals(m.getName(self.constant_pool))) {\n-                Code_attribute code_attribute = (Code_attribute)m.attributes.get(Attribute.Code);\n-                for (Attribute at : code_attribute.attributes) {\n-                    if (Attribute.LineNumberTable.equals(at.getName(self.constant_pool))) {\n-                        return Arrays.stream(((LineNumberTable_attribute)at).line_number_table)\n-                                     .map(e -> new SimpleEntry<> (e.line_number, e.start_pc))\n+    static List<Entry> findEntries() throws IOException {\n+        ClassModel self = Classfile.of().parse(Objects.requireNonNull(Test.class.getResourceAsStream(\"NullCheckLineNumberTest$Test.class\")).readAllBytes());\n+        for (MethodModel m : self.methods()) {\n+            if (\"<init>\".equals(m.methodName().stringValue())) {\n+                CodeAttribute code_attribute = m.findAttribute(Attributes.CODE).orElseThrow();\n+                for (Attribute<?> at : code_attribute.attributes()) {\n+                    if (at instanceof LineNumberTableAttribute lineAt) {\n+                        return lineAt.lineNumbers().stream()\n+                                     .map(e -> new SimpleEntry<> (e.lineNumber(), e.startPc()))\n","filename":"test\/langtools\/tools\/javac\/linenumbers\/NullCheckLineNumberTest.java","additions":16,"deletions":16,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -28,1 +28,6 @@\n- * @modules jdk.jdeps\/com.sun.tools.classfile\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.classfile.instruction\n+ *          java.base\/jdk.internal.classfile.components\n+ *          java.base\/jdk.internal.classfile.impl\n@@ -32,6 +37,4 @@\n-import com.sun.tools.classfile.Instruction;\n-import com.sun.tools.classfile.Attribute;\n-import com.sun.tools.classfile.ClassFile;\n-import com.sun.tools.classfile.Code_attribute;\n-import com.sun.tools.classfile.ConstantPool.*;\n-import com.sun.tools.classfile.Method;\n+import jdk.internal.classfile.*;\n+import jdk.internal.classfile.attribute.CodeAttribute;\n+import jdk.internal.classfile.constantpool.MemberRefEntry;\n+import jdk.internal.classfile.instruction.InvokeInstruction;\n@@ -128,4 +131,4 @@\n-            ClassFile cf = ClassFile.read(f);\n-            Method testMethod = null;\n-            for (Method m : cf.methods) {\n-                if (m.getName(cf.constant_pool).equals(TEST_METHOD_NAME)) {\n+            ClassModel cf = Classfile.of().parse(f.toPath());\n+            MethodModel testMethod = null;\n+            for (MethodModel m : cf.methods()) {\n+                if (m.methodName().equalsString(TEST_METHOD_NAME)) {\n@@ -139,2 +142,2 @@\n-            Code_attribute ea = (Code_attribute)testMethod.attributes.get(Attribute.Code);\n-            if (testMethod == null) {\n+            CodeAttribute ea = testMethod.findAttribute(Attributes.CODE).orElse(null);\n+            if (ea == null) {\n@@ -144,1 +147,1 @@\n-            int cp_entry = -1;\n+            MemberRefEntry methRef = null;\n@@ -146,2 +149,2 @@\n-            for (Instruction i : ea.getInstructions()) {\n-                if (i.getMnemonic().equals(\"invokevirtual\")) {\n+            for (CodeElement ce : ea.elementList()) {\n+                if (ce instanceof InvokeInstruction ins && ins.opcode() == Opcode.INVOKEVIRTUAL) {\n@@ -149,3 +152,3 @@\n-                    if (cp_entry == -1) {\n-                        cp_entry = i.getUnsignedShort(1);\n-                    } else if (cp_entry != i.getUnsignedShort(1)) {\n+                    if (methRef == null) {\n+                        methRef = ins.method();\n+                    } else if (methRef != ins.method()) {\n@@ -154,3 +157,1 @@\n-                    CONSTANT_Methodref_info methRef =\n-                            (CONSTANT_Methodref_info)cf.constant_pool.get(cp_entry);\n-                    String type = methRef.getNameAndTypeInfo().getType();\n+                    String type = methRef.type().stringValue();\n","filename":"test\/langtools\/tools\/javac\/meth\/TestCP.java","additions":23,"deletions":22,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -31,1 +31,6 @@\n- *          jdk.jdeps\/com.sun.tools.classfile\n+ *          java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.classfile.instruction\n+ *          java.base\/jdk.internal.classfile.components\n+ *          java.base\/jdk.internal.classfile.impl\n@@ -54,5 +59,3 @@\n-import com.sun.tools.classfile.Annotation;\n-import com.sun.tools.classfile.Attribute;\n-import com.sun.tools.classfile.ClassFile;\n-import com.sun.tools.classfile.RuntimeInvisibleAnnotations_attribute;\n-import com.sun.tools.classfile.RuntimeVisibleAnnotations_attribute;\n+import jdk.internal.classfile.*;\n+import jdk.internal.classfile.Classfile;\n+import jdk.internal.classfile.attribute.*;\n@@ -89,2 +92,2 @@\n-        ClassFile cf = ClassFile.read(modulePath.resolve(\"m1x\").resolve(\"module-info.class\"));\n-        RuntimeVisibleAnnotations_attribute annotations = (RuntimeVisibleAnnotations_attribute) cf.attributes.map.get(Attribute.RuntimeVisibleAnnotations);\n+        ClassModel cf = Classfile.of().parse(modulePath.resolve(\"m1x\").resolve(\"module-info.class\"));\n+        RuntimeVisibleAnnotationsAttribute annotations = cf.findAttribute(Attributes.RUNTIME_VISIBLE_ANNOTATIONS).orElse(null);\n@@ -92,1 +95,1 @@\n-        if (annotations == null || annotations.annotations.length != 1) {\n+        if (annotations == null || annotations.annotations().size() != 1) {\n@@ -143,2 +146,2 @@\n-        ClassFile cf = ClassFile.read(modulePath.resolve(\"A\").resolve(\"module-info.class\"));\n-        RuntimeVisibleAnnotations_attribute annotations = (RuntimeVisibleAnnotations_attribute) cf.attributes.map.get(Attribute.RuntimeVisibleAnnotations);\n+        ClassModel cf = Classfile.of().parse(modulePath.resolve(\"A\").resolve(\"module-info.class\"));\n+        RuntimeVisibleAnnotationsAttribute annotations = cf.findAttribute(Attributes.RUNTIME_VISIBLE_ANNOTATIONS).orElse(null);\n@@ -146,1 +149,1 @@\n-        if (annotations != null && annotations.annotations.length > 0) {\n+        if (annotations != null && annotations.annotations().size() > 0) {\n@@ -150,1 +153,1 @@\n-        if (cf.attributes.map.get(Attribute.Deprecated) != null) {\n+        if (cf.findAttribute(Attributes.DEPRECATED).isPresent()) {\n@@ -194,2 +197,2 @@\n-        ClassFile cf = ClassFile.read(modulePath.resolve(\"A\").resolve(\"module-info.class\"));\n-        RuntimeVisibleAnnotations_attribute annotations = (RuntimeVisibleAnnotations_attribute) cf.attributes.map.get(Attribute.RuntimeVisibleAnnotations);\n+        ClassModel cf = Classfile.of().parse(modulePath.resolve(\"A\").resolve(\"module-info.class\"));\n+        RuntimeVisibleAnnotationsAttribute annotations = cf.findAttribute(Attributes.RUNTIME_VISIBLE_ANNOTATIONS).orElse(null);\n@@ -200,1 +203,1 @@\n-        int length = annotations.annotations.length;\n+        int length = annotations.annotations().size();\n@@ -204,1 +207,1 @@\n-        int pairsCount = annotations.annotations[0].num_element_value_pairs;\n+        int pairsCount = annotations.annotations().get(0).elements().size();\n@@ -317,2 +320,2 @@\n-        ClassFile cf = ClassFile.read(modulePath.resolve(\"m1x\").resolve(\"module-info.class\"));\n-        RuntimeInvisibleAnnotations_attribute annotations = (RuntimeInvisibleAnnotations_attribute) cf.attributes.map.get(Attribute.RuntimeInvisibleAnnotations);\n+        ClassModel cf = Classfile.of().parse(modulePath.resolve(\"m1x\").resolve(\"module-info.class\"));\n+        RuntimeInvisibleAnnotationsAttribute annotations = cf.findAttribute(Attributes.RUNTIME_INVISIBLE_ANNOTATIONS).orElse(null);\n@@ -320,1 +323,1 @@\n-        if (annotations == null || annotations.annotations.length != 1) {\n+        if (annotations == null || annotations.annotations().size() != 1) {\n@@ -359,2 +362,2 @@\n-        ClassFile cf = ClassFile.read(modulePath.resolve(\"B\").resolve(\"module-info.class\"));\n-        RuntimeInvisibleAnnotations_attribute annotations = (RuntimeInvisibleAnnotations_attribute) cf.attributes.map.get(Attribute.RuntimeInvisibleAnnotations);\n+        ClassModel cf = Classfile.of().parse(modulePath.resolve(\"B\").resolve(\"module-info.class\"));\n+        RuntimeInvisibleAnnotationsAttribute annotations = cf.findAttribute(Attributes.RUNTIME_INVISIBLE_ANNOTATIONS).orElse(null);\n@@ -365,1 +368,1 @@\n-        int length = annotations.annotations.length;\n+        int length = annotations.annotations().size();\n@@ -434,2 +437,2 @@\n-        ClassFile cf = ClassFile.read(classes.resolve(\"m1x\").resolve(\"module-info.class\"));\n-        var invisibleAnnotations = (RuntimeInvisibleAnnotations_attribute) cf.attributes.map.get(Attribute.RuntimeInvisibleAnnotations);\n+        ClassModel cf = Classfile.of().parse(classes.resolve(\"m1x\").resolve(\"module-info.class\"));\n+        RuntimeInvisibleAnnotationsAttribute invisibleAnnotations = cf.findAttribute(Attributes.RUNTIME_INVISIBLE_ANNOTATIONS).orElse(null);\n@@ -440,1 +443,1 @@\n-        int length = invisibleAnnotations.annotations.length;\n+        int length = invisibleAnnotations.annotations().size();\n@@ -444,2 +447,2 @@\n-        Annotation annotation = invisibleAnnotations.annotations[0];\n-        String annotationName = cf.constant_pool.getUTF8Value(annotation.type_index).toString();\n+        Annotation annotation = invisibleAnnotations.annotations().get(0);\n+        String annotationName = annotation.classSymbol().descriptorString();\n","filename":"test\/langtools\/tools\/javac\/modules\/AnnotationsOnModules.java","additions":31,"deletions":28,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -31,1 +31,7 @@\n- *          jdk.jdeps\/com.sun.tools.classfile\n+ *          java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.classfile.instruction\n+ *          java.base\/jdk.internal.classfile.components\n+ *          java.base\/jdk.internal.classfile.impl\n+ *          java.base\/jdk.internal.module\n@@ -50,8 +56,3 @@\n-import com.sun.tools.classfile.Attribute;\n-import com.sun.tools.classfile.Attributes;\n-import com.sun.tools.classfile.ClassFile;\n-import com.sun.tools.classfile.ClassWriter;\n-import com.sun.tools.classfile.ConstantPool;\n-import com.sun.tools.classfile.ConstantPool.CONSTANT_Utf8_info;\n-import com.sun.tools.classfile.ConstantPool.CPInfo;\n-import com.sun.tools.classfile.ModuleResolution_attribute;\n+import jdk.internal.classfile.*;\n+import jdk.internal.classfile.attribute.ModuleResolutionAttribute;\n+import jdk.internal.classfile.constantpool.*;\n@@ -61,0 +62,2 @@\n+import static jdk.internal.module.ClassFileConstants.DO_NOT_RESOLVE_BY_DEFAULT;\n+import static jdk.internal.module.ClassFileConstants.WARN_INCUBATING;\n@@ -88,1 +91,1 @@\n-        addModuleResolutionAttribute(jdkIModuleInfo, ModuleResolution_attribute.DO_NOT_RESOLVE_BY_DEFAULT);\n+        addModuleResolutionAttribute(jdkIModuleInfo, DO_NOT_RESOLVE_BY_DEFAULT);\n@@ -178,1 +181,1 @@\n-        addModuleResolutionAttribute(jdkIModuleInfo, ModuleResolution_attribute.WARN_INCUBATING);\n+        addModuleResolutionAttribute(jdkIModuleInfo, WARN_INCUBATING);\n@@ -258,26 +261,4 @@\n-        ClassFile cf = ClassFile.read(classfile);\n-        Attributes attrs = cf.attributes;\n-        List<CPInfo> cpData = new ArrayList<>();\n-        cpData.add(null);\n-        for (CPInfo info : cf.constant_pool.entries()) {\n-            cpData.add(info);\n-            if (info.size() == 2)\n-                cpData.add(null);\n-        }\n-        cpData.add(new CONSTANT_Utf8_info(Attribute.ModuleResolution));\n-        ConstantPool newCP = new ConstantPool(cpData.toArray(new CPInfo[0]));\n-        ModuleResolution_attribute res = new ModuleResolution_attribute(newCP, resolution_flags);\n-        Map<String, Attribute> newAttributeMap = new HashMap<>(attrs.map);\n-        newAttributeMap.put(Attribute.ModuleResolution, res);\n-        Attributes newAttrs = new Attributes(newAttributeMap);\n-        ClassFile newCF = new ClassFile(cf.magic,\n-                                        cf.minor_version,\n-                                        cf.major_version,\n-                                        newCP,\n-                                        cf.access_flags,\n-                                        cf.this_class,\n-                                        cf.super_class,\n-                                        cf.interfaces,\n-                                        cf.fields,\n-                                        cf.methods,\n-                                        newAttrs);\n+        ClassModel cm = Classfile.of().parse(classfile);\n+        ModuleResolutionAttribute modRAttr = ModuleResolutionAttribute.of(resolution_flags);\n+        byte[] newBytes = Classfile.of().transform(cm, ClassTransform.dropping(ce -> ce instanceof ModuleResolutionAttribute).\n+                andThen(ClassTransform.endHandler(classBuilder -> classBuilder.with(modRAttr))));\n@@ -285,1 +266,1 @@\n-            new ClassWriter().write(newCF, out);\n+            out.write(newBytes);\n","filename":"test\/langtools\/tools\/javac\/modules\/IncubatingTest.java","additions":19,"deletions":38,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -34,1 +34,6 @@\n- *      jdk.jdeps\/com.sun.tools.classfile\n+ *      java.base\/jdk.internal.classfile\n+ *      java.base\/jdk.internal.classfile.attribute\n+ *      java.base\/jdk.internal.classfile.constantpool\n+ *      java.base\/jdk.internal.classfile.instruction\n+ *      java.base\/jdk.internal.classfile.components\n+ *      java.base\/jdk.internal.classfile.impl\n@@ -39,0 +44,1 @@\n+import java.io.OutputStream;\n@@ -42,5 +48,1 @@\n-import java.util.LinkedHashMap;\n-import java.util.LinkedHashSet;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n+import java.util.*;\n@@ -49,5 +51,2 @@\n-import com.sun.tools.classfile.Attribute;\n-import com.sun.tools.classfile.Attributes;\n-import com.sun.tools.classfile.ClassFile;\n-import com.sun.tools.classfile.ClassWriter;\n-import com.sun.tools.classfile.Module_attribute;\n+import jdk.internal.classfile.*;\n+import jdk.internal.classfile.attribute.*;\n@@ -112,6 +111,2 @@\n-                case SOURCE:\n-                    testSource(base, mods, target);\n-                    break;\n-                case CLASS:\n-                    testClass(base, mods, target);\n-                    break;\n+                case SOURCE -> testSource(base, mods, target);\n+                case CLASS -> testClass(base, mods, target);\n@@ -216,1 +211,1 @@\n-        ClassFile cf1 = ClassFile.read(modules1.resolve(\"module-info.class\"));\n+        ClassModel cm1 = Classfile.of().parse(modules1.resolve(\"module-info.class\"));\n@@ -218,9 +213,7 @@\n-        Map<String,Attribute> attrMap = new LinkedHashMap<>(cf1.attributes.map);\n-        Module_attribute modAttr1 = (Module_attribute) attrMap.get(\"Module\");\n-        Module_attribute.RequiresEntry[] requires =\n-                new Module_attribute.RequiresEntry[modAttr1.requires_count];\n-        for (int i = 0; i < modAttr1.requires_count; i++) {\n-            Module_attribute.RequiresEntry e1 = modAttr1.requires[i];\n-            int flags = e1.requires_flags;\n-            Module_attribute.RequiresEntry e2;\n-            if (e1.getRequires(cf1.constant_pool).equals(\"java.base\")) {\n+        ModuleAttribute modAttr1 = cm1.findAttribute(Attributes.MODULE).orElseThrow();\n+        List<ModuleRequireInfo> requires = Arrays.asList(new ModuleRequireInfo[modAttr1.requires().size()]);\n+        for (int i = 0; i < modAttr1.requires().size(); ++i) {\n+            ModuleRequireInfo e1 = modAttr1.requires().get(i);\n+            int flags = e1.requiresFlagsMask();\n+            ModuleRequireInfo e2;\n+            if (e1.requires().name().equalsString(\"java.base\")) {\n@@ -229,6 +222,2 @@\n-                        case \"static\":\n-                            flags |= Module_attribute.ACC_STATIC_PHASE;\n-                            break;\n-                        case \"transitive\":\n-                            flags |= Module_attribute.ACC_TRANSITIVE;\n-                            break;\n+                        case \"static\" -> flags |= Classfile.ACC_STATIC_PHASE;\n+                        case \"transitive\" -> flags |= Classfile.ACC_TRANSITIVE;\n@@ -237,4 +226,1 @@\n-                e2 = new Module_attribute.RequiresEntry(\n-                        e1.requires_index,\n-                        flags,\n-                        e1.requires_version_index);\n+                e2 = ModuleRequireInfo.of(e1.requires(), flags, e1.requiresVersion().orElse(null));\n@@ -244,1 +230,1 @@\n-            requires[i] = e2;\n+            requires.set(i, e2);\n@@ -246,12 +232,0 @@\n-        Module_attribute modAttr2 = new Module_attribute(\n-                modAttr1.attribute_name_index,\n-                modAttr1.module_name,\n-                modAttr1.module_flags,\n-                modAttr1.module_version_index,\n-                requires,\n-                modAttr1.exports,\n-                modAttr1.opens,\n-                modAttr1.uses_index,\n-                modAttr1.provides);\n-        attrMap.put(\"Module\", modAttr2);\n-        Attributes attributes = new Attributes(attrMap);\n@@ -259,5 +233,9 @@\n-        ClassFile cf2 = new ClassFile(\n-                cf1.magic, cf1.minor_version, cf1.major_version,\n-                cf1.constant_pool, cf1.access_flags,\n-                cf1.this_class, cf1.super_class, cf1.interfaces,\n-                cf1.fields, cf1.methods, attributes);\n+        ModuleAttribute modAttr2 = ModuleAttribute.of(\n+                modAttr1.moduleName(),\n+                modAttr1.moduleFlagsMask(),\n+                modAttr1.moduleVersion().orElse(null),\n+                requires,\n+                modAttr1.exports(),\n+                modAttr1.opens(),\n+                modAttr1.uses(),\n+                modAttr1.provides());\n@@ -266,1 +244,5 @@\n-        new ClassWriter().write(cf2, modInfo.toFile());\n+        byte[] newBytes = Classfile.of().transform(cm1, ClassTransform.dropping(ce -> ce instanceof ModuleAttribute).\n+                andThen(ClassTransform.endHandler(classBuilder -> classBuilder.with(modAttr2))));\n+        try (OutputStream out = Files.newOutputStream(modInfo)) {\n+            out.write(newBytes);\n+        }\n","filename":"test\/langtools\/tools\/javac\/modules\/JavaBaseTest.java","additions":38,"deletions":56,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -30,1 +30,6 @@\n- *          jdk.jdeps\/com.sun.tools.classfile\n+ *          java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.classfile.instruction\n+ *          java.base\/jdk.internal.classfile.components\n+ *          java.base\/jdk.internal.classfile.impl\n@@ -39,4 +44,2 @@\n-import com.sun.tools.classfile.Attribute;\n-import com.sun.tools.classfile.ClassFile;\n-import com.sun.tools.classfile.ConstantPoolException;\n-import com.sun.tools.classfile.Module_attribute;\n+import jdk.internal.classfile.*;\n+import jdk.internal.classfile.attribute.ModuleAttribute;\n@@ -115,2 +118,2 @@\n-    private void checkModuleVersion(Path classfile, String version) throws IOException, ConstantPoolException {\n-        ClassFile cf = ClassFile.read(classfile);\n+    private void checkModuleVersion(Path classfile, String version) throws IOException {\n+        ClassModel cm = Classfile.of().parse(classfile);\n@@ -118,1 +121,1 @@\n-        Module_attribute moduleAttribute = (Module_attribute) cf.attributes.get(Attribute.Module);\n+        ModuleAttribute moduleAttribute = cm.findAttribute(Attributes.MODULE).orElse(null);\n@@ -124,1 +127,1 @@\n-        String actualVersion = cf.constant_pool.getUTF8Value(moduleAttribute.module_version_index);\n+        String actualVersion = moduleAttribute.moduleVersion().orElseThrow().stringValue();\n","filename":"test\/langtools\/tools\/javac\/modules\/ModuleVersion.java","additions":12,"deletions":9,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -30,1 +30,6 @@\n- *          jdk.jdeps\/com.sun.tools.classfile\n+ *          java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.classfile.instruction\n+ *          java.base\/jdk.internal.classfile.components\n+ *          java.base\/jdk.internal.classfile.impl\n@@ -45,5 +50,2 @@\n-import com.sun.tools.classfile.Attribute;\n-import com.sun.tools.classfile.Attributes;\n-import com.sun.tools.classfile.ClassFile;\n-import com.sun.tools.classfile.ClassWriter;\n-import com.sun.tools.classfile.Module_attribute;\n+import jdk.internal.classfile.*;\n+import jdk.internal.classfile.attribute.ModuleAttribute;\n@@ -237,28 +239,13 @@\n-        ClassFile cf = ClassFile.read(miClass);\n-        Module_attribute module = (Module_attribute) cf.attributes.map.get(Attribute.Module);\n-        Module_attribute newModule = new Module_attribute(module.attribute_name_index,\n-                                                          module.module_name,\n-                                                          module.module_flags | Module_attribute.ACC_OPEN,\n-                                                          module.module_version_index,\n-                                                          module.requires,\n-                                                          module.exports,\n-                                                          module.opens,\n-                                                          module.uses_index,\n-                                                          module.provides);\n-        Map<String, Attribute> attrs = new HashMap<>(cf.attributes.map);\n-\n-        attrs.put(Attribute.Module, newModule);\n-\n-        Attributes newAttributes = new Attributes(attrs);\n-        ClassFile newClassFile = new ClassFile(cf.magic,\n-                                               cf.minor_version,\n-                                               cf.major_version,\n-                                               cf.constant_pool,\n-                                               cf.access_flags,\n-                                               cf.this_class,\n-                                               cf.super_class,\n-                                               cf.interfaces,\n-                                               cf.fields,\n-                                               cf.methods,\n-                                               newAttributes);\n-\n+        ClassModel cm = Classfile.of().parse(miClass);\n+        ModuleAttribute module = cm.findAttribute(Attributes.MODULE).orElseThrow();\n+        ModuleAttribute newModule = ModuleAttribute.of(module.moduleName(),\n+                                                          module.moduleFlagsMask() | Classfile.ACC_OPEN,\n+                                                          module.moduleVersion().orElse(null),\n+                                                          module.requires(),\n+                                                          module.exports(),\n+                                                          module.opens(),\n+                                                          module.uses(),\n+                                                          module.provides());\n+\n+        byte[] newBytes = Classfile.of().transform(cm, ClassTransform.dropping(ce -> ce instanceof ModuleAttribute).\n+                andThen(ClassTransform.endHandler(classBuilder -> classBuilder.with(newModule))));\n@@ -266,1 +253,1 @@\n-            new ClassWriter().write(newClassFile, out);\n+            out.write(newBytes);\n","filename":"test\/langtools\/tools\/javac\/modules\/OpenModulesTest.java","additions":22,"deletions":35,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -28,1 +28,6 @@\n- * @modules jdk.jdeps\/com.sun.tools.classfile\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.classfile.instruction\n+ *          java.base\/jdk.internal.classfile.components\n+ *          java.base\/jdk.internal.classfile.impl\n@@ -33,5 +38,3 @@\n-import com.sun.tools.classfile.Attribute;\n-import com.sun.tools.classfile.ClassFile;\n-import com.sun.tools.classfile.Code_attribute;\n-import com.sun.tools.classfile.LocalVariableTypeTable_attribute;\n-import com.sun.tools.classfile.Method;\n+import jdk.internal.classfile.*;\n+import jdk.internal.classfile.attribute.CodeAttribute;\n+import jdk.internal.classfile.attribute.LocalVariableTypeTableAttribute;\n@@ -63,4 +66,4 @@\n-            ClassFile cf = ClassFile.read(f);\n-            Method testMethod = null;\n-            for (Method m : cf.methods) {\n-                if (m.getName(cf.constant_pool).equals(TEST_METHOD_NAME)) {\n+            ClassModel cf = Classfile.of().parse(f.toPath());\n+            MethodModel testMethod = null;\n+            for (MethodModel m : cf.methods()) {\n+                if (m.methodName().equalsString(TEST_METHOD_NAME)) {\n@@ -74,1 +77,1 @@\n-            Code_attribute code = (Code_attribute)testMethod.attributes.get(Attribute.Code);\n+            CodeAttribute code = testMethod.findAttribute(Attributes.CODE).orElse(null);\n@@ -78,2 +81,1 @@\n-            LocalVariableTypeTable_attribute lvt_table =\n-                    (LocalVariableTypeTable_attribute)code.attributes.get(Attribute.LocalVariableTypeTable);\n+            LocalVariableTypeTableAttribute lvt_table = code.findAttribute(Attributes.LOCAL_VARIABLE_TYPE_TABLE).orElse(null);\n@@ -83,1 +85,1 @@\n-            if (lvt_table.local_variable_table_length != LVT_LENGTH) {\n+            if (lvt_table.localVariableTypes().size() != LVT_LENGTH) {\n@@ -85,1 +87,1 @@\n-                        \"\\nfound: \" + lvt_table.local_variable_table_length +\n+                        \"\\nfound: \" + lvt_table.localVariableTypes().size() +\n@@ -88,2 +90,1 @@\n-            String sig =\n-                    cf.constant_pool.getUTF8Value(lvt_table.local_variable_table[0].signature_index);\n+            String sig = lvt_table.localVariableTypes().get(0).signature().stringValue();\n","filename":"test\/langtools\/tools\/javac\/multicatch\/7005371\/T7005371.java","additions":18,"deletions":17,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -28,1 +28,6 @@\n- * @modules jdk.jdeps\/com.sun.tools.classfile\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.classfile.instruction\n+ *          java.base\/jdk.internal.classfile.components\n+ *          java.base\/jdk.internal.classfile.impl\n@@ -32,5 +37,3 @@\n-import com.sun.tools.classfile.Attribute;\n-import com.sun.tools.classfile.ClassFile;\n-import com.sun.tools.classfile.Code_attribute;\n-import com.sun.tools.classfile.Code_attribute.Exception_data;\n-import com.sun.tools.classfile.Method;\n+import jdk.internal.classfile.*;\n+import jdk.internal.classfile.attribute.CodeAttribute;\n+import jdk.internal.classfile.instruction.ExceptionCatch;\n@@ -83,4 +86,4 @@\n-            ClassFile cf = ClassFile.read(f);\n-            Method testMethod = null;\n-            for (Method m : cf.methods) {\n-                if (m.getName(cf.constant_pool).equals(TEST_METHOD_NAME)) {\n+            ClassModel cf = Classfile.of().parse(f.toPath());\n+            MethodModel testMethod = null;\n+            for (MethodModel m : cf.methods()) {\n+                if (m.methodName().equalsString(TEST_METHOD_NAME)) {\n@@ -94,2 +97,2 @@\n-            Code_attribute ea = (Code_attribute)testMethod.attributes.get(Attribute.Code);\n-            if (testMethod == null) {\n+            CodeAttribute ea = testMethod.findAttribute(Attributes.CODE).orElse(null);\n+            if (ea == null) {\n@@ -98,2 +101,2 @@\n-            Exception_data firstExceptionTable = null;\n-            for (int i = 0 ; i < ea.exception_table_length; i++) {\n+            ExceptionCatch firstExceptionTable = null;\n+            for (int i = 0 ; i < ea.exceptionHandlers().size(); i++) {\n@@ -101,1 +104,1 @@\n-                    firstExceptionTable = ea.exception_table[i];\n+                    firstExceptionTable = ea.exceptionHandlers().get(i);\n@@ -103,3 +106,3 @@\n-                if (ea.exception_table[i].handler_pc != firstExceptionTable.handler_pc ||\n-                        ea.exception_table[i].start_pc != firstExceptionTable.start_pc ||\n-                        ea.exception_table[i].end_pc != firstExceptionTable.end_pc) {\n+                if (ea.exceptionHandlers().get(i).handler() != firstExceptionTable.handler() ||\n+                        ea.exceptionHandlers().get(i).tryStart() != firstExceptionTable.tryStart() ||\n+                        ea.exceptionHandlers().get(i).tryEnd() != firstExceptionTable.tryEnd()) {\n","filename":"test\/langtools\/tools\/javac\/multicatch\/Pos05.java","additions":21,"deletions":18,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n- *          jdk.jdeps\/com.sun.tools.classfile\n","filename":"test\/langtools\/tools\/javac\/options\/release\/ReleaseOption9.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n- *          jdk.jdeps\/com.sun.tools.classfile\n","filename":"test\/langtools\/tools\/javac\/options\/release\/ReleaseOptionUnsupported.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,1 +31,6 @@\n- *          jdk.jdeps\/com.sun.tools.classfile\n+ *          java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.classfile.instruction\n+ *          java.base\/jdk.internal.classfile.components\n+ *          java.base\/jdk.internal.classfile.impl\n@@ -52,1 +57,3 @@\n-import com.sun.tools.classfile.*;\n+import jdk.internal.classfile.*;\n+import jdk.internal.classfile.attribute.CodeAttribute;\n+import jdk.internal.classfile.attribute.RuntimeInvisibleTypeAnnotationsAttribute;\n@@ -54,1 +61,0 @@\n-import java.util.Arrays;\n@@ -64,13 +70,16 @@\n-        ClassFile cf = ClassFile.read(annotationsClass);\n-        for (Method m : cf.methods) {\n-            if (\"test\".equals(cf.constant_pool.getUTF8Value(m.name_index))) {\n-                Code_attribute codeAttr =\n-                        (Code_attribute) m.attributes.map.get(Attribute.Code);\n-                Attribute annoAttr =\n-                        codeAttr.attributes.map.get(Attribute.RuntimeInvisibleTypeAnnotations);\n-                RuntimeInvisibleTypeAnnotations_attribute annotations =\n-                        (RuntimeInvisibleTypeAnnotations_attribute) annoAttr;\n-                String expected = \"[@Annotations$DTA; pos: [LOCAL_VARIABLE, {start_pc = 31, length = 7, index = 1}, pos = -1], \" +\n-                                  \"@Annotations$TA; pos: [LOCAL_VARIABLE, {start_pc = 50, length = 7, index = 1}, pos = -1]]\";\n-                String actual = Arrays.toString(annotations.annotations);\n-                if (!expected.equals(actual)) {\n+        assert annotationsClass != null;\n+        ClassModel cf = Classfile.of().parse(annotationsClass.readAllBytes());\n+        for (MethodModel m : cf.methods()) {\n+            if (m.methodName().equalsString(\"test\")) {\n+                CodeAttribute codeAttr = m.findAttribute(Attributes.CODE).orElseThrow();\n+                RuntimeInvisibleTypeAnnotationsAttribute annotations = codeAttr.findAttribute(Attributes.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS).orElseThrow();\n+                String expected = \"LAnnotations$DTA; pos: [LOCAL_VARIABLE, {start_pc=31, end_pc=38, index=1}], \" +\n+                                  \"LAnnotations$TA; pos: [LOCAL_VARIABLE, {start_pc=50, end_pc=57, index=1}], \";\n+                StringBuilder actual = new StringBuilder();\n+                for (TypeAnnotation ta: annotations.annotations()) {\n+                    TypeAnnotation.LocalVarTargetInfo info = ((TypeAnnotation.LocalVarTarget) ta.targetInfo()).table().getFirst();\n+                    actual.append(ta.className().stringValue() + \" pos: [\" + ta.targetInfo().targetType());\n+                    actual.append(\", {start_pc=\" + codeAttr.labelToBci(info.startLabel()) + \", end_pc=\" + codeAttr.labelToBci(info.endLabel()));\n+                    actual.append(\", index=\" + info.index()+ \"}], \");\n+                }\n+                if (!expected.contentEquals(actual)) {\n","filename":"test\/langtools\/tools\/javac\/patterns\/Annotations.java","additions":25,"deletions":16,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -28,1 +28,6 @@\n- * @modules jdk.jdeps\/com.sun.tools.classfile\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.classfile.instruction\n+ *          java.base\/jdk.internal.classfile.components\n+ *          java.base\/jdk.internal.classfile.impl\n@@ -33,0 +38,2 @@\n+import jdk.internal.classfile.*;\n+import jdk.internal.classfile.attribute.*;\n@@ -36,1 +43,0 @@\n-import com.sun.tools.classfile.*;\n@@ -80,2 +86,3 @@\n-        ClassFile cf = ClassFile.read(getClass().getResource(c.getName() + \".class\").openStream());\n-        Method m = getMethodByName(cf, c.getSimpleName().contains(\"Lambda\") ? \"lambda$\" : \"test\");\n+        ClassModel cf = Classfile.of().parse(Objects.requireNonNull(getClass().getResource(c.getName() + \".class\"))\n+                        .openStream().readAllBytes());\n+        MethodModel m = getMethodByName(cf, c.getSimpleName().contains(\"Lambda\") ? \"lambda$\" : \"test\");\n@@ -87,1 +94,1 @@\n-        Code_attribute code = (Code_attribute) m.attributes.get(Attribute.Code);\n+        CodeAttribute code = m.findAttribute(Attributes.CODE).orElse(null);\n@@ -93,2 +100,1 @@\n-        LocalVariableTable_attribute lvt =\n-                (LocalVariableTable_attribute) code.attributes.get(Attribute.LocalVariableTable);\n+        LocalVariableTableAttribute lvt = code.findAttribute(Attributes.LOCAL_VARIABLE_TABLE).orElse(null);\n@@ -101,2 +107,2 @@\n-        for (LocalVariableTable_attribute.Entry e: lvt.local_variable_table) {\n-            foundNames.add(cf.constant_pool.getUTF8Value(e.name_index));\n+        for (LocalVariableInfo e: lvt.localVariables()) {\n+            foundNames.add(e.name().stringValue());\n@@ -118,3 +124,3 @@\n-    Method getMethodByName(ClassFile cf, String name) throws ConstantPoolException {\n-        for (Method m: cf.methods) {\n-            if (m.getName(cf.constant_pool).startsWith(name))\n+    MethodModel getMethodByName(ClassModel cf, String name) {\n+        for (MethodModel m: cf.methods()) {\n+            if (m.methodName().stringValue().startsWith(name))\n","filename":"test\/langtools\/tools\/javac\/patterns\/LocalVariableTable.java","additions":18,"deletions":12,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -31,1 +31,6 @@\n- *          jdk.jdeps\/com.sun.tools.classfile\n+ *          java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.classfile.instruction\n+ *          java.base\/jdk.internal.classfile.components\n+ *          java.base\/jdk.internal.classfile.impl\n@@ -38,4 +43,3 @@\n-import com.sun.tools.classfile.ClassFile;\n-import com.sun.tools.classfile.ConstantPool;\n-import com.sun.tools.classfile.ConstantPool.CONSTANT_Class_info;\n-import com.sun.tools.classfile.ConstantPool.CPInfo;\n+import jdk.internal.classfile.*;\n+import jdk.internal.classfile.constantpool.ClassEntry;\n+import jdk.internal.classfile.constantpool.ConstantPool;\n@@ -53,1 +57,1 @@\n-    ClassFile cf;\n+    ClassModel cf;\n@@ -114,1 +118,1 @@\n-                cf = ClassFile.read(curPath.resolve(\"Test.class\"));\n+                cf = Classfile.of().parse(curPath.resolve(\"Test.class\"));\n@@ -117,6 +121,6 @@\n-                for (CPInfo entry : cf.constant_pool.entries()) {\n-                    if (entry.getTag() == ConstantPool.CONSTANT_Class) {\n-                        CONSTANT_Class_info clazz = (CONSTANT_Class_info) entry;\n-                        incompatibleClassChangeErrror |=\n-                                \"java\/lang\/IncompatibleClassChangeError\".equals(clazz.getName());\n-                        matchException |= \"java\/lang\/MatchException\".equals(clazz.getName());\n+                ConstantPool cp = cf.constantPool();\n+                for (int i = 1; i < cp.entryCount(); i += cp.entryByIndex(i).width()) {\n+                    if (cp.entryByIndex(i) instanceof ClassEntry clazz) {\n+                        incompatibleClassChangeErrror |= clazz.name().equalsString(\n+                                \"java\/lang\/IncompatibleClassChangeError\");\n+                        matchException |= clazz.name().equalsString(\"java\/lang\/MatchException\");\n","filename":"test\/langtools\/tools\/javac\/patterns\/MatchExceptionTest.java","additions":17,"deletions":13,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -31,1 +31,6 @@\n- *          jdk.jdeps\/com.sun.tools.classfile\n+ *          java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.classfile.instruction\n+ *          java.base\/jdk.internal.classfile.components\n+ *          java.base\/jdk.internal.classfile.impl\n@@ -41,6 +46,2 @@\n-import com.sun.tools.classfile.ClassFile;\n-import com.sun.tools.classfile.ConstantPoolException;\n-import com.sun.tools.classfile.Method;\n-import com.sun.tools.classfile.Attribute;\n-import com.sun.tools.classfile.Code_attribute;\n-import com.sun.tools.classfile.Instruction;\n+import jdk.internal.classfile.*;\n+import jdk.internal.classfile.attribute.CodeAttribute;\n@@ -57,1 +58,1 @@\n-    ClassFile cf;\n+    ClassModel cf;\n@@ -86,3 +87,3 @@\n-        cf = ClassFile.read(curPath.resolve(\"NestedPatterVariablesTest.class\"));\n-        Method testMethod = Arrays.stream(cf.methods)\n-                                  .filter(m -> isTestMethod(m))\n+        cf = Classfile.of().parse(curPath.resolve(\"NestedPatterVariablesTest.class\"));\n+        MethodModel testMethod = cf.methods().stream()\n+                                  .filter(this::isTestMethod)\n@@ -90,2 +91,2 @@\n-                                  .get();\n-        Code_attribute code_attribute = (Code_attribute) testMethod.attributes.get(Attribute.Code);\n+                                  .orElseThrow();\n+        CodeAttribute code_attribute = testMethod.findAttribute(Attributes.CODE).orElseThrow();\n@@ -95,2 +96,2 @@\n-                \"aload_1\", \"instanceof\", \"ifeq\", \"aload_1\", \"checkcast\", \"astore_2\", \"aload_2\", \"instanceof\",\n-                \"ifeq\", \"aload_2\", \"checkcast\", \"astore_3\", \"aload_3\", \"areturn\", \"aconst_null\", \"areturn\");\n+                \"ALOAD_1\", \"INSTANCEOF\", \"IFEQ\", \"ALOAD_1\", \"CHECKCAST\", \"ASTORE_2\", \"ALOAD_2\", \"INSTANCEOF\",\n+                \"IFEQ\", \"ALOAD_2\", \"CHECKCAST\", \"ASTORE_3\", \"ALOAD_3\", \"ARETURN\", \"ACONST_NULL\", \"ARETURN\");\n@@ -100,6 +101,2 @@\n-    boolean isTestMethod(Method m) {\n-        try {\n-            return TEST_METHOD.equals(m.getName(cf.constant_pool));\n-        } catch (ConstantPoolException e) {\n-            throw new IllegalStateException(e);\n-        }\n+    boolean isTestMethod(MethodModel m) {\n+        return m.methodName().equalsString(TEST_METHOD);\n@@ -108,3 +105,4 @@\n-    List<String> getCodeInstructions(Code_attribute code) {\n-        return StreamSupport.stream(code.getInstructions().spliterator(), false)\n-                .map(Instruction::getMnemonic)\n+    List<String> getCodeInstructions(CodeAttribute code) {\n+        return code.elementList().stream()\n+                .filter(ce -> ce instanceof Instruction)\n+                .map(ins -> ((Instruction) ins).opcode().name())\n","filename":"test\/langtools\/tools\/javac\/patterns\/NestedPatternVariablesBytecode.java","additions":22,"deletions":24,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -29,1 +29,6 @@\n- * @modules jdk.jdeps\/com.sun.tools.classfile\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.classfile.instruction\n+ *          java.base\/jdk.internal.classfile.components\n+ *          java.base\/jdk.internal.classfile.impl\n@@ -34,0 +39,3 @@\n+import jdk.internal.classfile.*;\n+import jdk.internal.classfile.attribute.CodeAttribute;\n+import jdk.internal.classfile.constantpool.ConstantPool;\n@@ -37,9 +45,0 @@\n-import com.sun.tools.classfile.Attribute;\n-import com.sun.tools.classfile.ClassFile;\n-import com.sun.tools.classfile.Code_attribute;\n-import com.sun.tools.classfile.Code_attribute.InvalidIndex;\n-import com.sun.tools.classfile.ConstantPool;\n-import com.sun.tools.classfile.ConstantPoolException;\n-import com.sun.tools.classfile.Descriptor.InvalidDescriptor;\n-import com.sun.tools.classfile.Instruction;\n-import com.sun.tools.classfile.Method;\n@@ -51,2 +50,1 @@\n-    public static void main(String[] args)\n-            throws IOException, ConstantPoolException, InvalidDescriptor, InvalidIndex {\n+    public static void main(String[] args) throws IOException {\n@@ -58,4 +56,2 @@\n-    void checkClassFile(File file)\n-            throws IOException, ConstantPoolException, InvalidDescriptor, InvalidIndex {\n-        ClassFile classFile = ClassFile.read(file);\n-        ConstantPool constantPool = classFile.constant_pool;\n+    void checkClassFile(File file) throws IOException {\n+        ClassModel classFile = Classfile.of().parse(file.toPath());\n@@ -63,3 +59,2 @@\n-        Method method = Arrays.stream(classFile.methods)\n-                              .filter(m -> getName(m, constantPool)\n-                                               .equals(\"test\"))\n+        MethodModel method = classFile.methods().stream()\n+                              .filter(m -> getName(m).equals(\"test\"))\n@@ -69,13 +64,13 @@\n-                                      aload_1\n-                                      instanceof\n-                                      ifeq\n-                                      aload_1\n-                                      checkcast\n-                                      astore_2\n-                                      aload_2\n-                                      invokevirtual\n-                                      ifeq\n-                                      iconst_1\n-                                      goto\n-                                      iconst_0\n-                                      ireturn\n+                                      ALOAD_1\n+                                      INSTANCEOF\n+                                      IFEQ\n+                                      ALOAD_1\n+                                      CHECKCAST\n+                                      ASTORE_2\n+                                      ALOAD_2\n+                                      INVOKEVIRTUAL\n+                                      IFEQ\n+                                      ICONST_1\n+                                      GOTO\n+                                      ICONST_0\n+                                      IRETURN\n@@ -83,2 +78,1 @@\n-        Code_attribute code = (Code_attribute) method.attributes\n-                .get(Attribute.Code);\n+        CodeAttribute code = method.findAttribute(Attributes.CODE).orElseThrow();\n@@ -92,3 +86,4 @@\n-    String printCode(Code_attribute code) {\n-        return StreamSupport.stream(code.getInstructions().spliterator(), false)\n-                            .map(Instruction::getMnemonic)\n+    String printCode(CodeAttribute code) {\n+        return code.elementList().stream()\n+                            .filter(e -> e instanceof Instruction)\n+                            .map(ins -> ((Instruction) ins).opcode().name())\n@@ -98,6 +93,2 @@\n-    String getName(Method m, ConstantPool constantPool) {\n-        try {\n-            return m.getName(constantPool);\n-        } catch (ConstantPoolException ex) {\n-            throw new IllegalStateException(ex);\n-        }\n+    String getName(MethodModel m) {\n+        return m.methodName().stringValue();\n","filename":"test\/langtools\/tools\/javac\/patterns\/NoUnnecessaryCast.java","additions":34,"deletions":43,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -31,1 +31,6 @@\n- *      jdk.jdeps\/com.sun.tools.classfile\n+ *      java.base\/jdk.internal.classfile\n+ *      java.base\/jdk.internal.classfile.attribute\n+ *      java.base\/jdk.internal.classfile.constantpool\n+ *      java.base\/jdk.internal.classfile.instruction\n+ *      java.base\/jdk.internal.classfile.components\n+ *      java.base\/jdk.internal.classfile.impl\n@@ -35,1 +40,1 @@\n-import com.sun.tools.classfile.ClassFile;\n+import jdk.internal.classfile.*;\n@@ -209,5 +214,5 @@\n-            ClassFile cf = ClassFile.read(in);\n-            if (preview && cf.minor_version != 65535) {\n-                throw new IllegalStateException(\"Expected preview class, but got: \" + cf.minor_version);\n-            } else if (!preview && cf.minor_version != 0) {\n-                throw new IllegalStateException(\"Expected minor version == 0 but got: \" + cf.minor_version);\n+            ClassModel cf = Classfile.of().parse(in.readAllBytes());\n+            if (preview && cf.minorVersion() != 65535) {\n+                throw new IllegalStateException(\"Expected preview class, but got: \" + cf.minorVersion());\n+            } else if (!preview && cf.minorVersion() != 0) {\n+                throw new IllegalStateException(\"Expected minor version == 0 but got: \" + cf.minorVersion());\n","filename":"test\/langtools\/tools\/javac\/preview\/PreviewAutoSuppress.java","additions":12,"deletions":7,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -35,1 +35,6 @@\n- *      jdk.jdeps\/com.sun.tools.classfile\n+ *      java.base\/jdk.internal.classfile\n+ *      java.base\/jdk.internal.classfile.attribute\n+ *      java.base\/jdk.internal.classfile.constantpool\n+ *      java.base\/jdk.internal.classfile.instruction\n+ *      java.base\/jdk.internal.classfile.components\n+ *      java.base\/jdk.internal.classfile.impl\n@@ -58,2 +63,2 @@\n-import com.sun.tools.classfile.ClassFile;\n-import com.sun.tools.classfile.ConstantPoolException;\n+import jdk.internal.classfile.ClassModel;\n+import jdk.internal.classfile.Classfile;\n@@ -397,1 +402,1 @@\n-                    ClassFile cf;\n+                    ClassModel cf;\n@@ -409,1 +414,1 @@\n-                            cf = ClassFile.read(input);\n+                            cf = Classfile.of().parse(input.readAllBytes());\n@@ -411,1 +416,1 @@\n-                    } catch (IOException | ConstantPoolException ex) {\n+                    } catch (IOException ex) {\n@@ -414,4 +419,4 @@\n-                    if (previewClass && cf.minor_version != 65535) {\n-                        throw new IllegalStateException(\"Expected preview class, but got: \" + cf.minor_version);\n-                    } else if (!previewClass && cf.minor_version != 0) {\n-                        throw new IllegalStateException(\"Expected minor version == 0 but got: \" + cf.minor_version);\n+                    if (previewClass && cf.minorVersion() != 65535) {\n+                        throw new IllegalStateException(\"Expected preview class, but got: \" + cf.minorVersion());\n+                    } else if (!previewClass && cf.minorVersion() != 0) {\n+                        throw new IllegalStateException(\"Expected minor version == 0 but got: \" + cf.minorVersion());\n","filename":"test\/langtools\/tools\/javac\/preview\/PreviewErrors.java","additions":15,"deletions":10,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -31,1 +31,6 @@\n- *      jdk.jdeps\/com.sun.tools.classfile\n+ *      java.base\/jdk.internal.classfile\n+ *      java.base\/jdk.internal.classfile.attribute\n+ *      java.base\/jdk.internal.classfile.constantpool\n+ *      java.base\/jdk.internal.classfile.instruction\n+ *      java.base\/jdk.internal.classfile.components\n+ *      java.base\/jdk.internal.classfile.impl\n@@ -35,1 +40,2 @@\n-import com.sun.tools.classfile.ClassFile;\n+import jdk.internal.classfile.ClassModel;\n+import jdk.internal.classfile.Classfile;\n@@ -478,5 +484,5 @@\n-            ClassFile cf = ClassFile.read(in);\n-            if (preview && cf.minor_version != 65535) {\n-                throw new IllegalStateException(\"Expected preview class, but got: \" + cf.minor_version + \" for: \" + p.toString());\n-            } else if (!preview && cf.minor_version != 0) {\n-                throw new IllegalStateException(\"Expected minor version == 0 but got: \" + cf.minor_version + \" for: \" + p.toString());\n+            ClassModel cf = Classfile.of().parse(in.readAllBytes());\n+            if (preview && cf.minorVersion() != 65535) {\n+                throw new IllegalStateException(\"Expected preview class, but got: \" + cf.minorVersion() + \" for: \" + p.toString());\n+            } else if (!preview && cf.minorVersion() != 0) {\n+                throw new IllegalStateException(\"Expected minor version == 0 but got: \" + cf.minorVersion() + \" for: \" + p.toString());\n","filename":"test\/langtools\/tools\/javac\/preview\/PreviewTest.java","additions":13,"deletions":7,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -31,1 +31,6 @@\n- *          jdk.jdeps\/com.sun.tools.classfile\n+ *          java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.classfile.instruction\n+ *          java.base\/jdk.internal.classfile.components\n+ *          java.base\/jdk.internal.classfile.impl\n","filename":"test\/langtools\/tools\/javac\/processing\/model\/element\/TestFileObjectOf.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -31,1 +31,6 @@\n- *          jdk.jdeps\/com.sun.tools.classfile\n+ *          java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.classfile.instruction\n+ *          java.base\/jdk.internal.classfile.components\n+ *          java.base\/jdk.internal.classfile.impl\n@@ -38,0 +43,1 @@\n+import java.lang.instrument.ClassFileTransformer;\n@@ -58,8 +64,2 @@\n-import com.sun.tools.classfile.Attribute;\n-import com.sun.tools.classfile.Attributes;\n-import com.sun.tools.classfile.ClassFile;\n-import com.sun.tools.classfile.ClassWriter;\n-import com.sun.tools.classfile.Module_attribute;\n-import com.sun.tools.classfile.Module_attribute.ExportsEntry;\n-import com.sun.tools.classfile.Module_attribute.OpensEntry;\n-import com.sun.tools.classfile.Module_attribute.RequiresEntry;\n+import jdk.internal.classfile.*;\n+import jdk.internal.classfile.attribute.*;\n@@ -143,2 +143,1 @@\n-            Collections.sort(members,\n-                             (e1, e2) -> e1.getSimpleName().toString().compareTo(e2.getSimpleName().toString()));\n+            members.sort((e1, e2) -> e1.getSimpleName().toString().compareTo(e2.getSimpleName().toString()));\n@@ -187,1 +186,1 @@\n-        expected = Arrays.asList(\"test.Container:MANDATED\");\n+        expected = List.of(\"test.Container:MANDATED\");\n@@ -203,1 +202,1 @@\n-        expected = Arrays.asList(\"test.Container:EXPLICIT\");\n+        expected = List.of(\"test.Container:EXPLICIT\");\n@@ -258,1 +257,1 @@\n-        expected = Arrays.asList(\"REQUIRES:java.base:MANDATED\");\n+        expected = List.of(\"REQUIRES:java.base:MANDATED\");\n@@ -283,34 +282,22 @@\n-        ClassFile cf = ClassFile.read(moduleInfo);\n-        Module_attribute module = (Module_attribute) cf.getAttribute(Attribute.Module);\n-\n-        RequiresEntry[] newRequires = new RequiresEntry[3];\n-        newRequires[0] = new RequiresEntry(module.requires[0].requires_index,\n-                                           Module_attribute.ACC_MANDATED,\n-                                           module.requires[0].requires_version_index);\n-        newRequires[1] = new RequiresEntry(module.requires[1].requires_index,\n-                                           Module_attribute.ACC_SYNTHETIC,\n-                                           module.requires[1].requires_version_index);\n-        newRequires[2] = module.requires[2];\n-\n-        ExportsEntry[] newExports = new ExportsEntry[3];\n-        newExports[0] = new ExportsEntry(module.exports[0].exports_index,\n-                                         Module_attribute.ACC_MANDATED,\n-                                         module.exports[0].exports_to_index);\n-        newExports[1] = new ExportsEntry(module.exports[1].exports_index,\n-                                         Module_attribute.ACC_SYNTHETIC,\n-                                         module.exports[1].exports_to_index);\n-        newExports[2] = module.exports[2];\n-\n-        OpensEntry[] newOpens = new OpensEntry[3];\n-        newOpens[0] = new OpensEntry(module.opens[0].opens_index,\n-                                     Module_attribute.ACC_MANDATED,\n-                                     module.opens[0].opens_to_index);\n-        newOpens[1] = new OpensEntry(module.opens[1].opens_index,\n-                                     Module_attribute.ACC_SYNTHETIC,\n-                                     module.opens[1].opens_to_index);\n-        newOpens[2] = module.opens[2];\n-\n-        Module_attribute newModule = new Module_attribute(module.attribute_name_index,\n-                                                          module.module_name,\n-                                                          module.module_flags,\n-                                                          module.module_version_index,\n+        ClassModel cf = Classfile.of().parse(moduleInfo);\n+        ModuleAttribute module = cf.findAttribute(Attributes.MODULE).orElseThrow();\n+\n+        List<ModuleRequireInfo> newRequires = new ArrayList<>(3);\n+        newRequires.add(ModuleRequireInfo.of(module.requires().get(0).requires(), Classfile.ACC_MANDATED, module.requires().get(0).requiresVersion().orElse(null)));\n+        newRequires.add(ModuleRequireInfo.of(module.requires().get(1).requires(), Classfile.ACC_SYNTHETIC, module.requires().get(1).requiresVersion().orElse(null)));\n+        newRequires.add(module.requires().get(2));\n+\n+        List<ModuleExportInfo> newExports = new ArrayList<>(3);\n+        newExports.add(ModuleExportInfo.of(module.exports().get(0).exportedPackage(), Classfile.ACC_MANDATED, module.exports().get(0).exportsTo()));\n+        newExports.add(ModuleExportInfo.of(module.exports().get(1).exportedPackage(), Classfile.ACC_SYNTHETIC, module.exports().get(1).exportsTo()));\n+        newExports.add(module.exports().get(2));\n+\n+        List<ModuleOpenInfo> newOpens = new ArrayList<>(3);\n+        newOpens.add(ModuleOpenInfo.of(module.opens().get(0).openedPackage(), Classfile.ACC_MANDATED, module.opens().get(0).opensTo()));\n+        newOpens.add(ModuleOpenInfo.of(module.opens().get(1).openedPackage(), Classfile.ACC_SYNTHETIC, module.opens().get(1).opensTo()));\n+        newOpens.add(module.opens().get(2));\n+\n+\n+        ModuleAttribute newModule = ModuleAttribute.of(module.moduleName(),\n+                                                          module.moduleFlagsMask(),\n+                                                          module.moduleVersion().orElse(null),\n@@ -320,19 +307,4 @@\n-                                                          module.uses_index,\n-                                                          module.provides);\n-        Map<String, Attribute> newAttributesMap = new HashMap<>(cf.attributes.map);\n-\n-        newAttributesMap.put(Attribute.Module, newModule);\n-\n-        Attributes newAttributes = new Attributes(newAttributesMap);\n-        ClassFile newClassFile = new ClassFile(cf.magic,\n-                                               cf.minor_version,\n-                                               cf.major_version,\n-                                               cf.constant_pool,\n-                                               cf.access_flags,\n-                                               cf.this_class,\n-                                               cf.super_class,\n-                                               cf.interfaces,\n-                                               cf.fields,\n-                                               cf.methods,\n-                                               newAttributes);\n-\n+                                                          module.uses(),\n+                                                          module.provides());\n+        byte[] newClassFileBytes = Classfile.of().transform(cf, ClassTransform.dropping(ce -> ce instanceof ModuleAttribute)\n+                                                 .andThen(ClassTransform.endHandler(classBuilder -> classBuilder.with(newModule))));\n@@ -340,1 +312,1 @@\n-            new ClassWriter().write(newClassFile, out);\n+            out.write(newClassFileBytes);\n@@ -380,1 +352,1 @@\n-                    case REQUIRES:\n+                    case REQUIRES -> {\n@@ -383,4 +355,4 @@\n-                                           rd.getDependency().getQualifiedName() + \":\" +\n-                                           elements.getOrigin(m, rd));\n-                        break;\n-                    case EXPORTS:\n+                                rd.getDependency().getQualifiedName() + \":\" +\n+                                elements.getOrigin(m, rd));\n+                    }\n+                    case EXPORTS -> {\n@@ -389,4 +361,4 @@\n-                                           ed.getPackage() + \":\" +\n-                                           elements.getOrigin(m, ed));\n-                        break;\n-                    case OPENS:\n+                                ed.getPackage() + \":\" +\n+                                elements.getOrigin(m, ed));\n+                    }\n+                    case OPENS -> {\n@@ -395,3 +367,3 @@\n-                                           od.getPackage() + \":\" +\n-                                           elements.getOrigin(m, od));\n-                        break;\n+                                od.getPackage() + \":\" +\n+                                elements.getOrigin(m, od));\n+                    }\n","filename":"test\/langtools\/tools\/javac\/processing\/model\/element\/TestOrigin.java","additions":52,"deletions":80,"binary":false,"changes":132,"status":"modified"},{"patch":"@@ -35,1 +35,6 @@\n- *      jdk.jdeps\/com.sun.tools.classfile\n+ *      java.base\/jdk.internal.classfile\n+ *      java.base\/jdk.internal.classfile.attribute\n+ *      java.base\/jdk.internal.classfile.constantpool\n+ *      java.base\/jdk.internal.classfile.instruction\n+ *      java.base\/jdk.internal.classfile.components\n+ *      java.base\/jdk.internal.classfile.impl\n@@ -44,7 +49,1 @@\n-import java.util.Arrays;\n-import java.util.EnumMap;\n-import java.util.EnumSet;\n-import java.util.HashSet;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n+import java.util.*;\n@@ -73,20 +72,5 @@\n-import com.sun.tools.classfile.AccessFlags;\n-import com.sun.tools.classfile.Annotation;\n-import com.sun.tools.classfile.Attribute;\n-import com.sun.tools.classfile.Attributes;\n-import com.sun.tools.classfile.ClassFile;\n-import com.sun.tools.classfile.Code_attribute;\n-import com.sun.tools.classfile.ConstantPool;\n-import com.sun.tools.classfile.ConstantPool.CONSTANT_Fieldref_info;\n-import com.sun.tools.classfile.ConstantPool.CPInfo;\n-import com.sun.tools.classfile.Field;\n-import com.sun.tools.classfile.Instruction;\n-import com.sun.tools.classfile.Method;\n-import com.sun.tools.classfile.Record_attribute;\n-import com.sun.tools.classfile.Record_attribute.ComponentInfo;\n-import com.sun.tools.classfile.RuntimeAnnotations_attribute;\n-import com.sun.tools.classfile.RuntimeTypeAnnotations_attribute;\n-import com.sun.tools.classfile.RuntimeVisibleAnnotations_attribute;\n-import com.sun.tools.classfile.RuntimeVisibleParameterAnnotations_attribute;\n-import com.sun.tools.classfile.RuntimeVisibleTypeAnnotations_attribute;\n-import com.sun.tools.classfile.TypeAnnotation;\n+import jdk.internal.classfile.*;\n+import jdk.internal.classfile.attribute.*;\n+import jdk.internal.classfile.Opcode;\n+import jdk.internal.classfile.constantpool.*;\n+import jdk.internal.classfile.instruction.FieldInstruction;\n@@ -1292,1 +1276,1 @@\n-            for (final File fileEntry : dir.listFiles()) {\n+            for (final File fileEntry : Objects.requireNonNull(dir.listFiles())) {\n@@ -1294,3 +1278,3 @@\n-                    ClassFile classFile = ClassFile.read(fileEntry);\n-                    for (CPInfo cpInfo : classFile.constant_pool.entries()) {\n-                        if (cpInfo instanceof ConstantPool.CONSTANT_Fieldref_info) {\n+                    ClassModel classFile = Classfile.of().parse(fileEntry.toPath());\n+                    for (int i = 1; i < classFile.constantPool().entryCount(); ++i) {\n+                        if (classFile.constantPool().entryByIndex(i) instanceof FieldRefEntry fieldRefEntry) {\n@@ -1298,4 +1282,3 @@\n-                            ConstantPool.CONSTANT_NameAndType_info nameAndType =\n-                                    (ConstantPool.CONSTANT_NameAndType_info)classFile.constant_pool\n-                                            .get(((ConstantPool.CONSTANT_Fieldref_info)cpInfo).name_and_type_index);\n-                            Assert.check(nameAndType.getName().equals(\"recordComponent\"));\n+                            NameAndTypeEntry nameAndType = (NameAndTypeEntry) classFile.constantPool()\n+                                            .entryByIndex(fieldRefEntry.nameAndType().index());\n+                            Assert.check(nameAndType.name().equalsString(\"recordComponent\"));\n@@ -1313,2 +1296,2 @@\n-        int putField1 = -1;\n-        int putField2 = -1;\n+        FieldInstruction putField1 = null;\n+        FieldInstruction putField2 = null;\n@@ -1316,1 +1299,1 @@\n-        for (final File fileEntry : dir.listFiles()) {\n+        for (final File fileEntry : Objects.requireNonNull(dir.listFiles())) {\n@@ -1318,7 +1301,7 @@\n-                ClassFile classFile = ClassFile.read(fileEntry);\n-                for (Method method : classFile.methods) {\n-                    if (method.getName(classFile.constant_pool).equals(\"<init>\")) {\n-                        Code_attribute code_attribute = (Code_attribute) method.attributes.get(\"Code\");\n-                        for (Instruction instruction : code_attribute.getInstructions()) {\n-                            if (instruction.getMnemonic().equals(\"putfield\")) {\n-                                if (putField1 != -1 && putField2 != -1) {\n+                ClassModel classFile = Classfile.of().parse(fileEntry.toPath());\n+                for (MethodModel method : classFile.methods()) {\n+                    if (method.methodName().equalsString(\"<init>\")) {\n+                        CodeAttribute code_attribute = method.findAttribute(Attributes.CODE).orElseThrow();\n+                        for (CodeElement ce : code_attribute.elementList()) {\n+                            if (ce instanceof Instruction instruction && instruction.opcode() == Opcode.PUTFIELD) {\n+                                if (putField1 != null && putField2 != null) {\n@@ -1327,4 +1310,4 @@\n-                                if (putField1 == -1) {\n-                                    putField1 = instruction.getShort(1);\n-                                } else if (putField2 == -1) {\n-                                    putField2 = instruction.getShort(1);\n+                                if (putField1 == null) {\n+                                    putField1 = (FieldInstruction) instruction;\n+                                } else {\n+                                    putField2 = (FieldInstruction) instruction;\n@@ -1335,2 +1318,3 @@\n-                        CONSTANT_Fieldref_info fieldref_info1 = (CONSTANT_Fieldref_info)classFile.constant_pool.get(putField1);\n-                        if (!fieldref_info1.getNameAndTypeInfo().getName().equals(\"i\")) {\n+                        assert putField1 != null;\n+                        FieldRefEntry fieldref_info1 = putField1.field();\n+                        if (!fieldref_info1.name().equalsString(\"i\")) {\n@@ -1339,3 +1323,3 @@\n-\n-                        CONSTANT_Fieldref_info fieldref_info2 = (CONSTANT_Fieldref_info)classFile.constant_pool.get(putField2);\n-                        if (!fieldref_info2.getNameAndTypeInfo().getName().equals(\"s\")) {\n+                        assert putField2 != null;\n+                        FieldRefEntry fieldref_info2 = putField2.field();\n+                        if (!fieldref_info2.name().equalsString(\"s\")) {\n@@ -1462,1 +1446,1 @@\n-                ClassFile classFile = ClassFile.read(findClassFileOrFail(dir, \"R.class\"));\n+                ClassModel classFile = Classfile.of().parse(findClassFileOrFail(dir, \"R.class\").toPath());\n@@ -1465,2 +1449,2 @@\n-                Assert.check(classFile.fields.length == 1);\n-                Field field = classFile.fields[0];\n+                Assert.check(classFile.fields().size() == 1);\n+                FieldModel field = classFile.fields().get(0);\n@@ -1470,4 +1454,1 @@\n-                    checkAnno(classFile,\n-                            (RuntimeAnnotations_attribute) findAttributeOrFail(\n-                                    field.attributes,\n-                                    RuntimeVisibleAnnotations_attribute.class),\n+                    checkAnno(findAttributeOrFail(field.attributes(), RuntimeVisibleAnnotationsAttribute.class),\n@@ -1476,1 +1457,1 @@\n-                    assertAttributeNotPresent(field.attributes, RuntimeVisibleAnnotations_attribute.class);\n+                    assertAttributeNotPresent(field.attributes(), RuntimeVisibleAnnotationsAttribute.class);\n@@ -1481,5 +1462,2 @@\n-                    checkTypeAnno(\n-                            classFile,\n-                            (RuntimeVisibleTypeAnnotations_attribute) findAttributeOrFail(field.attributes, RuntimeVisibleTypeAnnotations_attribute.class),\n-                            \"FIELD\",\n-                            \"Anno\");\n+                    checkTypeAnno(findAttributeOrFail(field.attributes(), RuntimeVisibleTypeAnnotationsAttribute.class),\n+                            \"FIELD\", \"Anno\");\n@@ -1487,1 +1465,1 @@\n-                    assertAttributeNotPresent(field.attributes, RuntimeVisibleTypeAnnotations_attribute.class);\n+                    assertAttributeNotPresent(field.attributes(), RuntimeVisibleTypeAnnotationsAttribute.class);\n@@ -1491,1 +1469,1 @@\n-                Method init = findMethodOrFail(classFile, \"<init>\");\n+                MethodModel init = findMethodOrFail(classFile, \"<init>\");\n@@ -1495,4 +1473,4 @@\n-                    checkParameterAnno(classFile,\n-                            (RuntimeVisibleParameterAnnotations_attribute) findAttributeOrFail(\n-                                    init.attributes,\n-                                    RuntimeVisibleParameterAnnotations_attribute.class),\n+                    checkParameterAnno(\n+                            (RuntimeVisibleParameterAnnotationsAttribute) findAttributeOrFail(\n+                                    init.attributes(),\n+                                    RuntimeVisibleParameterAnnotationsAttribute.class),\n@@ -1501,1 +1479,1 @@\n-                    assertAttributeNotPresent(init.attributes, RuntimeVisibleAnnotations_attribute.class);\n+                    assertAttributeNotPresent(init.attributes(), RuntimeVisibleAnnotationsAttribute.class);\n@@ -1505,3 +1483,1 @@\n-                    checkTypeAnno(\n-                            classFile,\n-                            (RuntimeVisibleTypeAnnotations_attribute) findAttributeOrFail(init.attributes, RuntimeVisibleTypeAnnotations_attribute.class),\n+                    checkTypeAnno(findAttributeOrFail(init.attributes(), RuntimeVisibleTypeAnnotationsAttribute.class),\n@@ -1510,1 +1486,1 @@\n-                    assertAttributeNotPresent(init.attributes, RuntimeVisibleTypeAnnotations_attribute.class);\n+                    assertAttributeNotPresent(init.attributes(), RuntimeVisibleTypeAnnotationsAttribute.class);\n@@ -1514,1 +1490,1 @@\n-                Method accessor = findMethodOrFail(classFile, \"s\");\n+                MethodModel accessor = findMethodOrFail(classFile, \"s\");\n@@ -1518,4 +1494,1 @@\n-                    checkAnno(classFile,\n-                            (RuntimeAnnotations_attribute) findAttributeOrFail(\n-                                    accessor.attributes,\n-                                    RuntimeVisibleAnnotations_attribute.class),\n+                    checkAnno(findAttributeOrFail(accessor.attributes(), RuntimeVisibleAnnotationsAttribute.class),\n@@ -1524,1 +1497,1 @@\n-                    assertAttributeNotPresent(accessor.attributes, RuntimeVisibleAnnotations_attribute.class);\n+                    assertAttributeNotPresent(accessor.attributes(), RuntimeVisibleAnnotationsAttribute.class);\n@@ -1528,3 +1501,1 @@\n-                    checkTypeAnno(\n-                            classFile,\n-                            (RuntimeVisibleTypeAnnotations_attribute) findAttributeOrFail(accessor.attributes, RuntimeVisibleTypeAnnotations_attribute.class),\n+                    checkTypeAnno(findAttributeOrFail(accessor.attributes(), RuntimeVisibleTypeAnnotationsAttribute.class),\n@@ -1533,1 +1504,1 @@\n-                    assertAttributeNotPresent(accessor.attributes, RuntimeVisibleTypeAnnotations_attribute.class);\n+                    assertAttributeNotPresent(accessor.attributes(), RuntimeVisibleTypeAnnotationsAttribute.class);\n@@ -1537,2 +1508,2 @@\n-                Record_attribute record = (Record_attribute) findAttributeOrFail(classFile.attributes, Record_attribute.class);\n-                Assert.check(record.component_count == 1);\n+                RecordAttribute record = (RecordAttribute) findAttributeOrFail(classFile.attributes(), RecordAttribute.class);\n+                Assert.check(record.components().size() == 1);\n@@ -1542,4 +1513,1 @@\n-                    checkAnno(classFile,\n-                            (RuntimeAnnotations_attribute) findAttributeOrFail(\n-                                    record.component_info_arr[0].attributes,\n-                                    RuntimeVisibleAnnotations_attribute.class),\n+                    checkAnno(findAttributeOrFail(record.components().get(0).attributes(), RuntimeVisibleAnnotationsAttribute.class),\n@@ -1548,1 +1516,1 @@\n-                    assertAttributeNotPresent(record.component_info_arr[0].attributes, RuntimeVisibleAnnotations_attribute.class);\n+                    assertAttributeNotPresent(record.components().get(0).attributes(), RuntimeVisibleAnnotationsAttribute.class);\n@@ -1552,5 +1520,1 @@\n-                    checkTypeAnno(\n-                            classFile,\n-                            (RuntimeVisibleTypeAnnotations_attribute) findAttributeOrFail(\n-                                    record.component_info_arr[0].attributes,\n-                                    RuntimeVisibleTypeAnnotations_attribute.class),\n+                    checkTypeAnno(findAttributeOrFail(record.components().get(0).attributes(), RuntimeVisibleTypeAnnotationsAttribute.class),\n@@ -1559,1 +1523,1 @@\n-                    assertAttributeNotPresent(record.component_info_arr[0].attributes, RuntimeVisibleTypeAnnotations_attribute.class);\n+                    assertAttributeNotPresent(record.components().get(0).attributes(), RuntimeVisibleTypeAnnotationsAttribute.class);\n@@ -1584,1 +1548,1 @@\n-        ClassFile classFile = ClassFile.read(findClassFileOrFail(dir, \"R.class\"));\n+        ClassModel classFile = Classfile.of().parse(findClassFileOrFail(dir, \"R.class\").toPath());\n@@ -1587,5 +1551,3 @@\n-        Assert.check(classFile.fields.length == 1);\n-        Field field = classFile.fields[0];\n-        checkTypeAnno(\n-                classFile,\n-                (RuntimeVisibleTypeAnnotations_attribute) findAttributeOrFail(field.attributes, RuntimeVisibleTypeAnnotations_attribute.class),\n+        Assert.check(classFile.fields().size() == 1);\n+        FieldModel field = classFile.fields().get(0);\n+        checkTypeAnno(findAttributeOrFail(field.attributes(), RuntimeVisibleTypeAnnotationsAttribute.class),\n@@ -1596,4 +1558,2 @@\n-        Method init = findMethodOrFail(classFile, \"<init>\");\n-        checkTypeAnno(\n-                classFile,\n-                (RuntimeVisibleTypeAnnotations_attribute) findAttributeOrFail(init.attributes, RuntimeVisibleTypeAnnotations_attribute.class),\n+        MethodModel init = findMethodOrFail(classFile, \"<init>\");\n+        checkTypeAnno(findAttributeOrFail(init.attributes(), RuntimeVisibleTypeAnnotationsAttribute.class),\n@@ -1603,4 +1563,2 @@\n-        Method accessor = findMethodOrFail(classFile, \"s\");\n-        checkTypeAnno(\n-                classFile,\n-                (RuntimeVisibleTypeAnnotations_attribute) findAttributeOrFail(accessor.attributes, RuntimeVisibleTypeAnnotations_attribute.class),\n+        MethodModel accessor = findMethodOrFail(classFile, \"s\");\n+        checkTypeAnno(findAttributeOrFail(accessor.attributes(), RuntimeVisibleTypeAnnotationsAttribute.class),\n@@ -1610,7 +1568,4 @@\n-        Record_attribute record = (Record_attribute) findAttributeOrFail(classFile.attributes, Record_attribute.class);\n-        Assert.check(record.component_count == 1);\n-        checkTypeAnno(\n-                classFile,\n-                (RuntimeVisibleTypeAnnotations_attribute) findAttributeOrFail(\n-                            record.component_info_arr[0].attributes,\n-                                RuntimeVisibleTypeAnnotations_attribute.class),\n+        RecordAttribute record = (RecordAttribute) findAttributeOrFail(classFile.attributes(), RecordAttribute.class);\n+        Assert.check(record.components().size() == 1);\n+        checkTypeAnno(findAttributeOrFail(record.components().get(0).attributes(),\n+                                RuntimeVisibleTypeAnnotationsAttribute.class),\n@@ -1620,2 +1575,1 @@\n-    private void checkTypeAnno(ClassFile classFile,\n-                               RuntimeTypeAnnotations_attribute rtAnnos,\n+    private void checkTypeAnno(Attribute<?> rtAnnos,\n@@ -1623,1 +1577,1 @@\n-                               String annoName) throws Exception {\n+                               String annoName) {\n@@ -1625,4 +1579,15 @@\n-        Assert.check(rtAnnos.annotations.length == 1);\n-        TypeAnnotation tAnno = (TypeAnnotation)rtAnnos.annotations[0];\n-        Assert.check(tAnno.position.type.toString().equals(positionType));\n-        String annotationName = classFile.constant_pool.getUTF8Value(tAnno.annotation.type_index).toString().substring(1);\n+        TypeAnnotation tAnno;\n+        switch (rtAnnos) {\n+            case RuntimeVisibleTypeAnnotationsAttribute rtVAnnos -> {\n+                Assert.check(rtVAnnos.annotations().size() == 1);\n+                tAnno = rtVAnnos.annotations().get(0);\n+            }\n+            case RuntimeInvisibleTypeAnnotationsAttribute rtIAnnos -> {\n+                Assert.check(rtIAnnos.annotations().size() == 1);\n+                tAnno = rtIAnnos.annotations().get(0);\n+            }\n+            default -> throw new AssertionError();\n+        }\n+        assert tAnno != null;\n+        Assert.check(tAnno.targetInfo().targetType().name().equals(positionType));\n+        String annotationName = tAnno.classSymbol().displayName();\n@@ -1631,4 +1596,2 @@\n-\n-    private void checkAnno(ClassFile classFile,\n-                           RuntimeAnnotations_attribute rAnnos,\n-                           String annoName) throws Exception {\n+    private void checkAnno(Attribute<?> rAnnos,\n+                           String annoName) {\n@@ -1636,3 +1599,14 @@\n-        Assert.check(rAnnos.annotations.length == 1);\n-        Annotation anno = (Annotation)rAnnos.annotations[0];\n-        String annotationName = classFile.constant_pool.getUTF8Value(anno.type_index).toString().substring(1);\n+        Annotation anno;\n+        switch (rAnnos) {\n+            case RuntimeVisibleAnnotationsAttribute rVAnnos -> {\n+                Assert.check(rVAnnos.annotations().size() == 1);\n+                anno = rVAnnos.annotations().get(0);\n+            }\n+            case RuntimeInvisibleAnnotationsAttribute rIAnnos -> {\n+                Assert.check(rIAnnos.annotations().size() == 1);\n+                anno = rIAnnos.annotations().get(0);\n+            }\n+            default -> throw new AssertionError();\n+        }\n+        assert anno != null;\n+        String annotationName = anno.classSymbol().displayName();\n@@ -1643,3 +1617,2 @@\n-    private void checkParameterAnno(ClassFile classFile,\n-                           RuntimeVisibleParameterAnnotations_attribute rAnnos,\n-                           String annoName) throws Exception {\n+    private void checkParameterAnno(RuntimeVisibleParameterAnnotationsAttribute rAnnos,\n+                           String annoName) {\n@@ -1647,4 +1620,4 @@\n-        Assert.check(rAnnos.parameter_annotations.length == 1);\n-        Assert.check(rAnnos.parameter_annotations[0].length == 1);\n-        Annotation anno = (Annotation)rAnnos.parameter_annotations[0][0];\n-        String annotationName = classFile.constant_pool.getUTF8Value(anno.type_index).toString().substring(1);\n+        Assert.check(rAnnos.parameterAnnotations().size() == 1);\n+        Assert.check(rAnnos.parameterAnnotations().get(0).size() == 1);\n+        Annotation anno = rAnnos.parameterAnnotations().get(0).get(0);\n+        String annotationName = anno.classSymbol().displayName();\n@@ -1656,1 +1629,1 @@\n-            if (fileEntry.getName().equals(\"R.class\")) {\n+            if (fileEntry.getName().equals(name)) {\n@@ -1663,3 +1636,3 @@\n-    private Method findMethodOrFail(ClassFile classFile, String name) throws Exception {\n-        for (Method method : classFile.methods) {\n-            if (method.getName(classFile.constant_pool).equals(name)) {\n+    private MethodModel findMethodOrFail(ClassModel classFile, String name) {\n+        for (MethodModel method : classFile.methods()) {\n+            if (method.methodName().equalsString(name)) {\n@@ -1672,3 +1645,3 @@\n-    private Attribute findAttributeOrFail(Attributes attributes, Class<? extends Attribute> attrClass) {\n-        for (Attribute attribute : attributes) {\n-            if (attribute.getClass() == attrClass) {\n+    private Attribute<?> findAttributeOrFail(List<Attribute<?>> attributes, Class<? extends Attribute<?>> attrClass) {\n+        for (Attribute<?> attribute : attributes) {\n+            if (attrClass.isAssignableFrom(attribute.getClass())) {\n@@ -1678,1 +1651,1 @@\n-        throw new AssertionError(\"attribute not found\");\n+        throw new AssertionError(\"attribute not found\" + attrClass.toString() + \"!!!!\" + attributes.getFirst().getClass().toString());\n@@ -1681,2 +1654,2 @@\n-    private void assertAttributeNotPresent(Attributes attributes, Class<? extends Attribute> attrClass) {\n-        for (Attribute attribute : attributes) {\n+    private void assertAttributeNotPresent(List<Attribute<?>> attributes, Class<? extends Attribute<?>> attrClass) {\n+        for (Attribute<?> attribute : attributes) {\n@@ -1720,1 +1693,1 @@\n-                    case FIELD:\n+                    case FIELD -> {\n@@ -1723,2 +1696,2 @@\n-                        break;\n-                    case METHOD:\n+                    }\n+                    case METHOD -> {\n@@ -1727,2 +1700,2 @@\n-                        break;\n-                    case PARAMETER:\n+                    }\n+                    case PARAMETER -> {\n@@ -1731,2 +1704,2 @@\n-                        break;\n-                    case RECORD_COMPONENT:\n+                    }\n+                    case RECORD_COMPONENT -> {\n@@ -1735,3 +1708,2 @@\n-                        break;\n-                    default:\n-                        throw new AssertionError(\"unexpected element kind\");\n+                    }\n+                    default -> throw new AssertionError(\"unexpected element kind\");\n@@ -1789,1 +1761,1 @@\n-        for (final File fileEntry : dir.listFiles()) {\n+        for (final File fileEntry : Objects.requireNonNull(dir.listFiles())) {\n@@ -1791,3 +1763,3 @@\n-                ClassFile classFile = ClassFile.read(fileEntry);\n-                for (Method method : classFile.methods)\n-                    switch (method.getName(classFile.constant_pool)) {\n+                ClassModel classFile = Classfile.of().parse(fileEntry.toPath());\n+                for (MethodModel method : classFile.methods())\n+                    switch (method.methodName().stringValue()) {\n@@ -1795,1 +1767,1 @@\n-                            Assert.check(method.access_flags.is(AccessFlags.ACC_PUBLIC) && method.access_flags.is(AccessFlags.ACC_FINAL));\n+                            Assert.check(((method.flags().flagsMask() & Classfile.ACC_PUBLIC) != 0) && ((method.flags().flagsMask() & Classfile.ACC_FINAL) != 0));\n@@ -1821,1 +1793,1 @@\n-            for (final File fileEntry : dir.listFiles()) {\n+            for (final File fileEntry : Objects.requireNonNull(dir.listFiles())) {\n@@ -1823,5 +1795,5 @@\n-                    ClassFile classFile = ClassFile.read(fileEntry);\n-                    for (Method method : classFile.methods)\n-                        if (method.getName(classFile.constant_pool).equals(\"<init>\")) {\n-                            Assert.check(method.access_flags.flags == accessFlag(a),\n-                                    \"was expecting access flag \" + accessFlag(a) + \" but found \" + method.access_flags.flags);\n+                    ClassModel classFile = Classfile.of().parse(fileEntry.toPath());\n+                    for (MethodModel method : classFile.methods())\n+                        if (method.methodName().equalsString(\"<init>\")) {\n+                            Assert.check(method.flags().flagsMask() == accessFlag(a),\n+                                    \"was expecting access flag \" + accessFlag(a) + \" but found \" + method.flags().flagsMask());\n@@ -1835,8 +1807,7 @@\n-        switch (access) {\n-            case \"private\": return 3;\n-            case \"protected\": return 1;\n-            case \"public\": return 0;\n-            case \"\": return 2;\n-            default:\n-                throw new AssertionError();\n-        }\n+        return switch (access) {\n+            case \"private\" -> 3;\n+            case \"protected\" -> 1;\n+            case \"public\" -> 0;\n+            case \"\" -> 2;\n+            default -> throw new AssertionError();\n+        };\n@@ -1846,8 +1817,7 @@\n-        switch (access) {\n-            case \"private\": return AccessFlags.ACC_PRIVATE;\n-            case \"protected\": return AccessFlags.ACC_PROTECTED;\n-            case \"public\": return AccessFlags.ACC_PUBLIC;\n-            case \"\": return 0;\n-            default:\n-                throw new AssertionError();\n-        }\n+        return switch (access) {\n+            case \"private\" -> Classfile.ACC_PRIVATE;\n+            case \"protected\" -> Classfile.ACC_PROTECTED;\n+            case \"public\" -> Classfile.ACC_PUBLIC;\n+            case \"\" -> 0;\n+            default -> throw new AssertionError();\n+        };\n@@ -2104,1 +2074,1 @@\n-            \/\/ dont execute this test when the default annotation processor is on as it will fail due to\n+            \/\/ don't execute this test when the default annotation processor is on as it will fail due to\n","filename":"test\/langtools\/tools\/javac\/records\/RecordCompilationTests.java","additions":162,"deletions":192,"binary":false,"changes":354,"status":"modified"},{"patch":"@@ -32,1 +32,6 @@\n- *          jdk.jdeps\/com.sun.tools.classfile\n+ *          java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.classfile.instruction\n+ *          java.base\/jdk.internal.classfile.components\n+ *          java.base\/jdk.internal.classfile.impl\n@@ -45,1 +50,0 @@\n-import com.sun.tools.classfile.*;\n","filename":"test\/langtools\/tools\/javac\/records\/RecordsBinaryCompatibilityTests.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -31,1 +31,6 @@\n- *          jdk.jdeps\/com.sun.tools.classfile\n+ *          java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.classfile.instruction\n+ *          java.base\/jdk.internal.classfile.components\n+ *          java.base\/jdk.internal.classfile.impl\n@@ -36,1 +41,2 @@\n-import com.sun.tools.classfile.*;\n+import jdk.internal.classfile.*;\n+import jdk.internal.classfile.attribute.RuntimeVisibleAnnotationsAttribute;\n@@ -50,1 +56,1 @@\n-    ClassFile cf;\n+    ClassModel cf;\n@@ -140,1 +146,1 @@\n-        cf = ClassFile.read(curPath.resolve(\"RecordComponentUsingGeneratedTypeWithAnnotation.class\"));\n+        cf = Classfile.of().parse(curPath.resolve(\"RecordComponentUsingGeneratedTypeWithAnnotation.class\"));\n@@ -142,3 +148,3 @@\n-        for (Field field : cf.fields) {\n-            if (\"generatedType\".equals(field.getName(cf.constant_pool))) {\n-                checkRuntimeVisibleAnnotation(field.attributes);\n+        for (FieldModel field : cf.fields()) {\n+            if (field.fieldName().equalsString(\"generatedType\")){\n+                checkRuntimeVisibleAnnotation(field);\n@@ -148,3 +154,3 @@\n-        for (Method method : cf.methods) {\n-            if (\"generatedType\".equals(method.getName(cf.constant_pool))) {\n-                checkRuntimeVisibleAnnotation(method.attributes);\n+        for (MethodModel method : cf.methods()) {\n+            if (method.methodName().equalsString(\"generatedType\")) {\n+                checkRuntimeVisibleAnnotation(method);\n@@ -155,3 +161,2 @@\n-    private void checkRuntimeVisibleAnnotation(Attributes attributes) throws Exception {\n-        RuntimeVisibleAnnotations_attribute annotations =\n-                (RuntimeVisibleAnnotations_attribute) attributes.get(Attribute.RuntimeVisibleAnnotations);\n+    private void checkRuntimeVisibleAnnotation(AttributedElement attributedElement) throws Exception {\n+        RuntimeVisibleAnnotationsAttribute annotations = attributedElement.findAttribute(Attributes.RUNTIME_VISIBLE_ANNOTATIONS).orElseThrow();\n@@ -159,2 +164,2 @@\n-        for (Annotation annotation : annotations.annotations) {\n-            if (\"LTestAnnotation;\".equals(cf.constant_pool.getUTF8Value(annotation.type_index))) {\n+        for (Annotation annotation : annotations.annotations()) {\n+            if (annotation.classSymbol().descriptorString().equals(\"LTestAnnotation;\")) {\n","filename":"test\/langtools\/tools\/javac\/records\/recordComponent\/RecordComponentTypeTest.java","additions":20,"deletions":15,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -31,1 +31,6 @@\n- *          jdk.jdeps\/com.sun.tools.classfile\n+ *          java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.classfile.instruction\n+ *          java.base\/jdk.internal.classfile.components\n+ *          java.base\/jdk.internal.classfile.impl\n","filename":"test\/langtools\/tools\/javac\/recovery\/AnnotationRecovery.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -31,1 +31,6 @@\n- *          jdk.jdeps\/com.sun.tools.classfile\n+ *          java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.classfile.instruction\n+ *          java.base\/jdk.internal.classfile.components\n+ *          java.base\/jdk.internal.classfile.impl\n","filename":"test\/langtools\/tools\/javac\/recovery\/AttrRecovery.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -31,1 +31,6 @@\n- *          jdk.jdeps\/com.sun.tools.classfile\n+ *          java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.classfile.instruction\n+ *          java.base\/jdk.internal.classfile.components\n+ *          java.base\/jdk.internal.classfile.impl\n","filename":"test\/langtools\/tools\/javac\/recovery\/LambdaRecovery.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -31,1 +31,6 @@\n- *          jdk.jdeps\/com.sun.tools.classfile\n+ *          java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.classfile.instruction\n+ *          java.base\/jdk.internal.classfile.components\n+ *          java.base\/jdk.internal.classfile.impl\n","filename":"test\/langtools\/tools\/javac\/recovery\/MethodModifiers.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -32,1 +32,6 @@\n- *          jdk.jdeps\/com.sun.tools.classfile\n+ *          java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.classfile.instruction\n+ *          java.base\/jdk.internal.classfile.components\n+ *          java.base\/jdk.internal.classfile.impl\n@@ -45,1 +50,0 @@\n-import com.sun.tools.classfile.*;\n@@ -55,2 +59,0 @@\n-import static com.sun.tools.classfile.ConstantPool.*;\n-\n","filename":"test\/langtools\/tools\/javac\/sealed\/BinaryCompatibilityTests.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -32,1 +32,6 @@\n- *          jdk.jdeps\/com.sun.tools.classfile\n+ *          java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.classfile.instruction\n+ *          java.base\/jdk.internal.classfile.components\n+ *          java.base\/jdk.internal.classfile.impl\n@@ -45,1 +50,4 @@\n-import com.sun.tools.classfile.*;\n+import jdk.internal.classfile.*;\n+import jdk.internal.classfile.attribute.PermittedSubclassesAttribute;\n+import jdk.internal.classfile.constantpool.ClassEntry;\n+import jdk.internal.classfile.constantpool.ConstantPoolException;\n@@ -54,2 +62,0 @@\n-import static com.sun.tools.classfile.ConstantPool.*;\n-\n@@ -132,4 +138,4 @@\n-        ClassFile sealedCF = ClassFile.read(out.resolve(cfName));\n-        Assert.check((sealedCF.access_flags.flags & Flags.FINAL) == 0, String.format(\"class at file %s must not be final\", cfName));\n-        PermittedSubclasses_attribute permittedSubclasses = (PermittedSubclasses_attribute)sealedCF.attributes.get(\"PermittedSubclasses\");\n-        Assert.check(permittedSubclasses.subtypes.length == expectedSubTypeNames.size());\n+        ClassModel sealedCF = Classfile.of().parse(out.resolve(cfName));\n+        Assert.check((sealedCF.flags().flagsMask() & Classfile.ACC_FINAL) == 0, String.format(\"class at file %s must not be final\", cfName));\n+        PermittedSubclassesAttribute permittedSubclasses = sealedCF.findAttribute(Attributes.PERMITTED_SUBCLASSES).orElseThrow();\n+        Assert.check(permittedSubclasses.permittedSubclasses().size() == expectedSubTypeNames.size());\n@@ -137,1 +143,1 @@\n-        IntStream.of(permittedSubclasses.subtypes).forEach(i -> {\n+        permittedSubclasses.permittedSubclasses().forEach(i -> {\n@@ -139,1 +145,1 @@\n-                subtypeNames.add(((CONSTANT_Class_info)sealedCF.constant_pool.get(i)).getName());\n+                subtypeNames.add(i.name().stringValue());\n@@ -150,1 +156,1 @@\n-        ClassFile subCF1 = ClassFile.read(out.resolve(cfName));\n+        ClassModel subCF1 = Classfile.of().parse(out.resolve(cfName));\n@@ -152,1 +158,1 @@\n-            Assert.check((subCF1.access_flags.flags & Flags.FINAL) != 0, String.format(\"class at file %s must be final\", cfName));\n+            Assert.check((subCF1.flags().flagsMask() & Classfile.ACC_FINAL) != 0, String.format(\"class at file %s must be final\", cfName));\n@@ -154,2 +160,2 @@\n-        Assert.checkNull((PermittedSubclasses_attribute)subCF1.attributes.get(\"PermittedSubclasses\"));\n-        Assert.check(((CONSTANT_Class_info)subCF1.constant_pool.get(subCF1.super_class)).getName().equals(superClassName));\n+        Assert.checkNull(subCF1.findAttribute(Attributes.PERMITTED_SUBCLASSES).orElse(null));\n+        Assert.check(subCF1.superclass().orElseThrow().name().equalsString(superClassName));\n","filename":"test\/langtools\/tools\/javac\/sealed\/SealedDiffConfigurationsTest.java","additions":20,"deletions":14,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -34,1 +34,6 @@\n- *          jdk.jdeps\/com.sun.tools.classfile\n+ *          java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.classfile.instruction\n+ *          java.base\/jdk.internal.classfile.components\n+ *          java.base\/jdk.internal.classfile.impl\n@@ -96,2 +101,1 @@\n-import com.sun.tools.classfile.ClassFile;\n-import com.sun.tools.classfile.ConstantPoolException;\n+import jdk.internal.classfile.Classfile;\n@@ -216,8 +220,5 @@\n-                        case '+':\n-                            targetPattern = acceptPattern;\n-                            break;\n-                        case '-':\n-                            targetPattern = rejectPattern;\n-                            break;\n-                        default:\n-                            return ;\n+                        case '+' -> targetPattern = acceptPattern;\n+                        case '-' -> targetPattern = rejectPattern;\n+                        default -> {\n+                            return;\n+                        }\n@@ -259,1 +260,1 @@\n-        List<ToolBox.JavaSource> files = Arrays.asList(new ToolBox.JavaSource(\"Test\", \"\"));\n+        List<ToolBox.JavaSource> files = List.of(new ToolBox.JavaSource(\"Test\", \"\"));\n@@ -291,1 +292,1 @@\n-                    String name = ClassFile.read(in).getName().replace(\"\/\", \".\");\n+                    String name = Classfile.of().parse(in.readAllBytes()).thisClass().name().stringValue();\n@@ -294,1 +295,1 @@\n-                } catch (IOException | ConstantPoolException ex) {\n+                } catch (IOException ex) {\n","filename":"test\/langtools\/tools\/javac\/sym\/ElementStructureTest.java","additions":15,"deletions":14,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -31,1 +31,6 @@\n- * @modules jdk.jdeps\/com.sun.tools.classfile\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.classfile.instruction\n+ *          java.base\/jdk.internal.classfile.components\n+ *          java.base\/jdk.internal.classfile.impl\n@@ -38,6 +43,4 @@\n-import com.sun.tools.classfile.Instruction;\n-import com.sun.tools.classfile.Attribute;\n-import com.sun.tools.classfile.ClassFile;\n-import com.sun.tools.classfile.Code_attribute;\n-import com.sun.tools.classfile.ConstantPool.*;\n-import com.sun.tools.classfile.Method;\n+import jdk.internal.classfile.*;\n+import jdk.internal.classfile.attribute.CodeAttribute;\n+import jdk.internal.classfile.constantpool.MemberRefEntry;\n+import jdk.internal.classfile.instruction.InvokeInstruction;\n@@ -219,4 +222,4 @@\n-            ClassFile cf = ClassFile.read(compiledTest);\n-            Method testMethod = null;\n-            for (Method m : cf.methods) {\n-                if (m.getName(cf.constant_pool).equals(\"test\")) {\n+            ClassModel cf = Classfile.of().parse(compiledTest.toPath());\n+            MethodModel testMethod = null;\n+            for (MethodModel m : cf.methods()) {\n+                if (m.methodName().equalsString(\"test\")) {\n@@ -230,2 +233,2 @@\n-            Code_attribute ea = (Code_attribute)testMethod.attributes.get(Attribute.Code);\n-            if (testMethod == null) {\n+            CodeAttribute ea = testMethod.findAttribute(Attributes.CODE).orElse(null);\n+            if (ea == null) {\n@@ -235,6 +238,4 @@\n-            for (Instruction i : ea.getInstructions()) {\n-                if (i.getMnemonic().equals(\"invokevirtual\")) {\n-                    int cp_entry = i.getUnsignedShort(1);\n-                    CONSTANT_Methodref_info methRef =\n-                            (CONSTANT_Methodref_info)cf.constant_pool.get(cp_entry);\n-                    String type = methRef.getNameAndTypeInfo().getType();\n+            for (CodeElement i : ea.elementList()) {\n+                if (i instanceof InvokeInstruction ins && ins.opcode() == Opcode.INVOKEVIRTUAL) {\n+                    MemberRefEntry methRef = ins.method();\n+                    String type = methRef.type().stringValue();\n","filename":"test\/langtools\/tools\/javac\/varargs\/6199075\/T6199075.java","additions":20,"deletions":19,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -30,1 +30,6 @@\n- * @modules jdk.jdeps\/com.sun.tools.classfile\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.classfile.instruction\n+ *          java.base\/jdk.internal.classfile.components\n+ *          java.base\/jdk.internal.classfile.impl\n@@ -42,6 +47,5 @@\n-import com.sun.tools.classfile.Instruction;\n-import com.sun.tools.classfile.Attribute;\n-import com.sun.tools.classfile.ClassFile;\n-import com.sun.tools.classfile.Code_attribute;\n-import com.sun.tools.classfile.ConstantPool.*;\n-import com.sun.tools.classfile.Method;\n+import jdk.internal.classfile.*;\n+import jdk.internal.classfile.attribute.CodeAttribute;\n+import jdk.internal.classfile.constantpool.MemberRefEntry;\n+import jdk.internal.classfile.constantpool.MethodRefEntry;\n+import jdk.internal.classfile.instruction.InvokeInstruction;\n@@ -273,4 +277,4 @@\n-            ClassFile cf = ClassFile.read(is);\n-            Method testMethod = null;\n-            for (Method m : cf.methods) {\n-                if (m.getName(cf.constant_pool).equals(\"test\")) {\n+            ClassModel cf = Classfile.of().parse(is.readAllBytes());\n+            MethodModel testMethod = null;\n+            for (MethodModel m : cf.methods()) {\n+                if (m.methodName().equalsString(\"test\")) {\n@@ -285,3 +289,2 @@\n-            Code_attribute ea =\n-                (Code_attribute)testMethod.attributes.get(Attribute.Code);\n-            if (testMethod == null) {\n+            CodeAttribute ea = testMethod.findAttribute(Attributes.CODE).orElse(null);\n+            if (ea == null) {\n@@ -291,7 +294,4 @@\n-\n-            for (Instruction i : ea.getInstructions()) {\n-                if (i.getMnemonic().equals(\"invokevirtual\")) {\n-                    int cp_entry = i.getUnsignedShort(1);\n-                    CONSTANT_Methodref_info methRef =\n-                        (CONSTANT_Methodref_info)cf.constant_pool.get(cp_entry);\n-                    String type = methRef.getNameAndTypeInfo().getType();\n+            for (CodeElement i : ea.elementList()) {\n+                if (i instanceof InvokeInstruction ins && ins.opcode() == Opcode.INVOKEVIRTUAL) {\n+                    MemberRefEntry methRef = ins.method();\n+                    String type = methRef.type().stringValue();\n","filename":"test\/langtools\/tools\/javac\/varargs\/7042566\/T7042566.java","additions":21,"deletions":21,"binary":false,"changes":42,"status":"modified"}]}