{"files":[{"patch":"@@ -79,0 +79,1 @@\n+  BUILD_JDK_JTREG_LIBRARIES_LIBS_libCaptureCallState := Ws2_32.lib\n","filename":"make\/test\/JtregNativeJdk.gmk","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -125,1 +125,2 @@\n-                                       bool needs_return_buffer, int ret_buf_size) {\n+                                       bool needs_return_buffer, int ret_buf_size,\n+                                       int captured_state_mask) {\n@@ -176,0 +177,7 @@\n+  int captured_state_offset = -1;\n+  if (captured_state_mask != 0) {\n+    captured_state_offset = frame_bottom_offset;\n+    frame_bottom_offset += (sizeof(int32_t) * 3);\n+    locs.set(StubLocations::CAPTURED_STATE_BUFFER, abi._scratch2);\n+  }\n+\n@@ -185,0 +193,3 @@\n+  \/\/      | captured_state      |\n+  \/\/      |---------------------| = captured_state_offset\n+  \/\/      | (optional)          |\n@@ -232,0 +243,4 @@\n+  if (captured_state_mask != 0) {\n+    assert(captured_state_offset != -1, \"no capture state allocated\");\n+    __ lea(as_Register(locs.get(StubLocations::CAPTURED_STATE_BUFFER)), Address(sp, captured_state_offset));\n+  }\n@@ -295,0 +310,6 @@\n+    if (captured_state_mask != 0) {\n+    __ lea(c_rarg1, Address(sp, captured_state_offset));\n+  } else {\n+    __ mov(c_rarg1, NULL_WORD);\n+  }\n+  __ movw(c_rarg2, captured_state_mask);\n","filename":"src\/hotspot\/cpu\/aarch64\/upcallLinker_aarch64.cpp","additions":22,"deletions":1,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -33,1 +33,2 @@\n-                                       bool needs_return_buffer, int ret_buf_size) {\n+                                       bool needs_return_buffer, int ret_buf_size,\n+                                       int captured_state_mask) {\n","filename":"src\/hotspot\/cpu\/arm\/upcallLinker_arm.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -34,1 +34,2 @@\n-                                       bool needs_return_buffer, int ret_buf_size) {\n+                                       bool needs_return_buffer, int ret_buf_size,\n+                                       int captured_state_mask) {\n","filename":"src\/hotspot\/cpu\/ppc\/upcallLinker_ppc.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -125,1 +125,2 @@\n-                                       bool needs_return_buffer, int ret_buf_size) {\n+                                       bool needs_return_buffer, int ret_buf_size,\n+                                       int captured_state_mask) {\n","filename":"src\/hotspot\/cpu\/riscv\/upcallLinker_riscv.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -33,1 +33,2 @@\n-                                       bool needs_return_buffer, int ret_buf_size) {\n+                                       bool needs_return_buffer, int ret_buf_size,\n+                                       int captured_state_mask) {\n","filename":"src\/hotspot\/cpu\/s390\/upcallLinker_s390.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -32,1 +32,2 @@\n-                                       bool needs_return_buffer, int ret_buf_size) {\n+                                       bool needs_return_buffer, int ret_buf_size,\n+                                       int captured_state_mask) {\n","filename":"src\/hotspot\/cpu\/x86\/upcallLinker_x86_32.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -176,1 +176,2 @@\n-                                       bool needs_return_buffer, int ret_buf_size) {\n+                                       bool needs_return_buffer, int ret_buf_size,\n+                                       int captured_state_mask) {\n@@ -226,0 +227,7 @@\n+  int captured_state_offset = -1;\n+  if (captured_state_mask != 0) {\n+    captured_state_offset = frame_bottom_offset;\n+    frame_bottom_offset += (sizeof(int32_t) * 3);\n+    locs.set(StubLocations::CAPTURED_STATE_BUFFER, abi._scratch2);\n+  }\n+\n@@ -235,0 +243,3 @@\n+  \/\/      | captured_state      |\n+  \/\/      |---------------------| = captured_state_offset\n+  \/\/      | (optional)          |\n@@ -287,0 +298,4 @@\n+  if (captured_state_mask != 0) {\n+    assert(captured_state_offset != -1, \"no capture state allocated\");\n+    __ lea(as_Register(locs.get(StubLocations::CAPTURED_STATE_BUFFER)), Address(rsp, captured_state_offset));\n+  }\n@@ -350,0 +365,6 @@\n+  if (captured_state_mask != 0) {\n+    __ lea(c_rarg1, Address(rsp, captured_state_offset));\n+  } else {\n+    __ movptr(c_rarg1, NULL_WORD);\n+  }\n+  __ movl(c_rarg2, captured_state_mask);\n","filename":"src\/hotspot\/cpu\/x86\/upcallLinker_x86_64.cpp","additions":22,"deletions":1,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -32,1 +32,2 @@\n-                                       bool needs_return_buffer, int ret_buf_size) {\n+                                       bool needs_return_buffer, int ret_buf_size,\n+                                       int captured_state_mask) {\n","filename":"src\/hotspot\/cpu\/zero\/upcallLinker_zero.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"prims\/foreignGlobals.hpp\"\n@@ -34,7 +35,0 @@\n-  \/\/ keep in synch with jdk.internal.foreign.abi.PreservableValues\n-  enum PreservableValues {\n-    NONE = 0,\n-    GET_LAST_ERROR = 1,\n-    WSA_GET_LAST_ERROR = 1 << 1,\n-    ERRNO = 1 << 2\n-  };\n@@ -42,1 +36,1 @@\n-  if (captured_state_mask & GET_LAST_ERROR) {\n+  if (captured_state_mask & CapturableState::LAST_ERROR) {\n@@ -46,1 +40,1 @@\n-  if (captured_state_mask & WSA_GET_LAST_ERROR) {\n+  if (captured_state_mask & CapturableState::WSA_LAST_ERROR) {\n@@ -51,1 +45,1 @@\n-  if (captured_state_mask & ERRNO) {\n+  if (captured_state_mask & CapturableState::ERRNO) {\n","filename":"src\/hotspot\/share\/prims\/downcallLinker.cpp","additions":4,"deletions":10,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -59,0 +59,10 @@\n+\/\/ keep in sync with jdk.internal.foreign.abi.CapturableState\n+struct CapturableState {\n+  enum {\n+    NONE = 0,\n+    LAST_ERROR = 1,\n+    WSA_LAST_ERROR = 1 << 1,\n+    ERRNO = 1 << 2\n+  };\n+};\n+\n","filename":"src\/hotspot\/share\/prims\/foreignGlobals.hpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"prims\/foreignGlobals.hpp\"\n@@ -36,0 +37,6 @@\n+#include <cerrno>\n+#ifdef _WIN64\n+#include <Windows.h>\n+#include <Winsock2.h>\n+#endif\n+\n@@ -115,1 +122,1 @@\n-void UpcallLinker::on_exit(UpcallStub::FrameData* context) {\n+void UpcallLinker::on_exit(UpcallStub::FrameData* context, int32_t* captured_state_ptr, int captured_state_mask) {\n@@ -136,0 +143,3 @@\n+\n+  \/\/ do this last to prevent VM operations from overwriting the values again\n+  capture_state(captured_state_ptr, captured_state_mask);\n@@ -146,0 +156,17 @@\n+void UpcallLinker::capture_state(int32_t* value_ptr, int captured_state_mask) {\n+  assert(value_ptr != nullptr || captured_state_mask == 0, \"value ptr null when capturing state\");\n+#ifdef _WIN64\n+  if (captured_state_mask & CapturableState::LAST_ERROR) {\n+    SetLastError(*value_ptr);\n+  }\n+  value_ptr++;\n+  if (captured_state_mask & CapturableState::WSA_LAST_ERROR) {\n+    WSASetLastError(*value_ptr);\n+  }\n+  value_ptr++;\n+#endif\n+  if (captured_state_mask & CapturableState::ERRNO) {\n+    errno = *value_ptr;\n+  }\n+}\n+\n@@ -147,1 +174,1 @@\n-                                                 jboolean needs_return_buffer, jlong ret_buf_size))\n+                                   jboolean needs_return_buffer, jlong ret_buf_size, jint captured_state_mask))\n@@ -183,1 +210,2 @@\n-    mh_j, entry, in_sig_bt, total_in_args, out_sig_bt, total_out_args, ret_type, abi, conv, needs_return_buffer, checked_cast<int>(ret_buf_size));\n+    mh_j, entry, in_sig_bt, total_in_args, out_sig_bt, total_out_args, ret_type,\n+    abi, conv, needs_return_buffer, checked_cast<int>(ret_buf_size), captured_state_mask);\n@@ -190,1 +218,1 @@\n-  {CC \"makeUpcallStub\", CC \"(\" \"Ljava\/lang\/invoke\/MethodHandle;\" \"L\" FOREIGN_ABI \"ABIDescriptor;\" \"L\" FOREIGN_ABI \"UpcallLinker$CallRegs;\" \"ZJ)J\", FN_PTR(UL_MakeUpcallStub)},\n+  {CC \"makeUpcallStub\", CC \"(\" \"Ljava\/lang\/invoke\/MethodHandle;\" \"L\" FOREIGN_ABI \"ABIDescriptor;\" \"L\" FOREIGN_ABI \"UpcallLinker$CallRegs;\" \"ZJI)J\", FN_PTR(UL_MakeUpcallStub)},\n","filename":"src\/hotspot\/share\/prims\/upcallLinker.cpp","additions":32,"deletions":4,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -39,1 +39,3 @@\n-  static void on_exit(UpcallStub::FrameData* context);\n+  static void on_exit(UpcallStub::FrameData* context,\n+                      int32_t* captured_state_ptr, int captured_state_mask);\n+  static void capture_state(int32_t* value_ptr, int captured_state_mask);\n@@ -46,1 +48,2 @@\n-                                  bool needs_return_buffer, int ret_buf_size);\n+                                  bool needs_return_buffer, int ret_buf_size,\n+                                  int captured_state_mask);\n","filename":"src\/hotspot\/share\/prims\/upcallLinker.hpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -574,2 +574,2 @@\n-         *          calling a foreign function associated with a downcall method handle,\n-         *          before it can be overwritten by the Java runtime, or read through conventional means}\n+         *          calling a foreign function associated with a downcall method handle, or during the\n+         *          execution of an upcall stub, to prevent it from being overwritten by the Java runtime}\n@@ -585,0 +585,5 @@\n+         * For upcall stubs, the target method handle for the upcall should accept an additional leading\n+         * {@link MemorySegment} parameter, which represents the capture state segment. Values that should be\n+         * captured have to be written into this segment. After the upcall completes, the values in the capture\n+         * state segment will be written to their respective execution state.\n+         * <p>\n@@ -588,1 +593,1 @@\n-         * Captured state can be retrieved from the capture state segment by constructing var handles\n+         * Captured state can be written to, or retrieved from the capture state segment by constructing var handles\n@@ -629,2 +634,2 @@\n-         *     <li>GetLastError<\/li>\n-         *     <li>WSAGetLastError<\/li>\n+         *     <li>LastError<\/li>\n+         *     <li>WSALastError<\/li>\n@@ -633,0 +638,5 @@\n+          * The {@code LastError} field corresponds to the value accessed through the Windows API {@code GetLastError} and\n+          * {@code SetLastError} functions, the {@code WSALastError} field corresponds to the {@code WSAGetLastError} and\n+          * {@code WSASetLastError} functions, and the {@code errno} field corresponds to the {@code errno} macro as\n+          * defined in the C standard library.\n+          * <p>\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/Linker.java","additions":15,"deletions":5,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -87,2 +87,6 @@\n-        MethodType type = function.toMethodType();\n-        if (!type.equals(target.type())) {\n+        MethodType nativeType = function.toMethodType();\n+        MethodType expectedJavaType = nativeType;\n+        if (optionSet.hasCapturedCallState()) {\n+            expectedJavaType = expectedJavaType.insertParameterTypes(0, MemorySegment.class); \/\/ capture state segment\n+        }\n+        if (!expectedJavaType.equals(target.type())) {\n@@ -93,1 +97,1 @@\n-            arrangeUpcall(type, linkRequest.descriptor(), linkRequest.options()));\n+            arrangeUpcall(nativeType, linkRequest.descriptor(), linkRequest.options()));\n@@ -97,1 +101,1 @@\n-    protected abstract UpcallStubFactory arrangeUpcall(MethodType targetType, FunctionDescriptor function, LinkerOptions options);\n+    protected abstract UpcallStubFactory arrangeUpcall(MethodType nativeType, FunctionDescriptor function, LinkerOptions options);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/AbstractLinker.java","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+import java.lang.foreign.Linker;\n@@ -124,0 +125,5 @@\n+            if (linkerOptions.hasCapturedCallState()) {\n+                addArgumentBinding(0, MemorySegment.class, ValueLayout.ADDRESS, List.of(\n+                        Binding.vmLoad(abi.capturedStateStorage(), long.class),\n+                        Binding.boxAddress(Linker.Option.captureStateLayout())));\n+            }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/CallingSequenceBuilder.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -39,3 +39,3 @@\n-    GET_LAST_ERROR    (\"GetLastError\",    JAVA_INT, 1 << 0, Utils.IS_WINDOWS),\n-    WSA_GET_LAST_ERROR(\"WSAGetLastError\", JAVA_INT, 1 << 1, Utils.IS_WINDOWS),\n-    ERRNO             (\"errno\",           JAVA_INT, 1 << 2, true);\n+    LAST_ERROR    (\"LastError\",    JAVA_INT, 1 << 0, Utils.IS_WINDOWS),\n+    WSA_LAST_ERROR(\"WSALastError\", JAVA_INT, 1 << 1, Utils.IS_WINDOWS),\n+    ERRNO         (\"errno\",        JAVA_INT, 1 << 2, true);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/CapturableState.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -138,0 +138,4 @@\n+        @Override\n+        public void validateForUpcall(FunctionDescriptor descriptor) {\n+            \/\/ done during construction\n+        }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/LinkerOptions.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -165,1 +165,1 @@\n-    private static MethodHandle adaptUpcallForIMR(MethodHandle target, boolean dropReturn) {\n+    private static MethodHandle adaptUpcallForIMR(MethodHandle target, boolean dropReturn, boolean hasCaptureCallState) {\n@@ -171,0 +171,8 @@\n+        if (hasCaptureCallState) {\n+            assert target.type().parameterType(1) == MemorySegment.class;\n+            \/\/ IMR is an ABI figment, so the capture state segment which\n+            \/\/ is inserted by CallingSequenceBuilder as leading parameter\n+            \/\/ should appear before the IMR segment parameter\n+            target = swapArguments(target, 0, 1);\n+        }\n+\n@@ -182,1 +190,1 @@\n-    public static UpcallStubFactory arrangeUpcallHelper(MethodType targetType, boolean isInMemoryReturn, boolean dropReturn,\n+    public static UpcallStubFactory arrangeUpcallHelper(boolean isInMemoryReturn, boolean dropReturn,\n@@ -184,4 +192,6 @@\n-        if (isInMemoryReturn) {\n-            \/\/ simulate the adaptation to get the type\n-            MethodHandle fakeTarget = MethodHandles.empty(targetType);\n-            targetType = adaptUpcallForIMR(fakeTarget, dropReturn).type();\n+        MethodType targetType = callingSequence.calleeMethodType();\n+        if (callingSequence.needsReturnBuffer()) {\n+            \/\/ return buffer is picked up by the wrapper class\n+            \/\/ so it doesn't go to the target.\n+            assert targetType.parameterType(0) == MemorySegment.class;\n+            targetType = targetType.dropParameterTypes(0, 1);\n@@ -189,1 +199,0 @@\n-\n@@ -194,0 +203,1 @@\n+            boolean hasCaptureCallState = callingSequence.capturedStateMask() != 0;\n@@ -195,1 +205,1 @@\n-                target = adaptUpcallForIMR(target, dropReturn);\n+                target = adaptUpcallForIMR(target, dropReturn, hasCaptureCallState);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/SharedUtils.java","additions":18,"deletions":8,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -108,1 +108,2 @@\n-                    callingSequence.needsReturnBuffer(), callingSequence.returnBufferSize());\n+                    callingSequence.needsReturnBuffer(), callingSequence.returnBufferSize(),\n+                    callingSequence.capturedStateMask());\n@@ -215,1 +216,2 @@\n-                                      boolean needsReturnBuffer, long returnBufferSize);\n+                                      boolean needsReturnBuffer, long returnBufferSize,\n+                                      int capturedStateMask);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/UpcallLinker.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -196,1 +196,1 @@\n-        return SharedUtils.arrangeUpcallHelper(mt, bindings.isInMemoryReturn, dropReturn, abiDescriptor(),\n+        return SharedUtils.arrangeUpcallHelper(bindings.isInMemoryReturn, dropReturn, abiDescriptor(),\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/CallArranger.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -60,2 +60,2 @@\n-    protected UpcallStubFactory arrangeUpcall(MethodType targetType, FunctionDescriptor function, LinkerOptions options) {\n-        return CallArranger.LINUX.arrangeUpcall(targetType, function, options);\n+    protected UpcallStubFactory arrangeUpcall(MethodType nativeType, FunctionDescriptor function, LinkerOptions options) {\n+        return CallArranger.LINUX.arrangeUpcall(nativeType, function, options);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/linux\/LinuxAArch64Linker.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -60,2 +60,2 @@\n-    protected UpcallStubFactory arrangeUpcall(MethodType targetType, FunctionDescriptor function, LinkerOptions options) {\n-        return CallArranger.MACOS.arrangeUpcall(targetType, function, options);\n+    protected UpcallStubFactory arrangeUpcall(MethodType nativeType, FunctionDescriptor function, LinkerOptions options) {\n+        return CallArranger.MACOS.arrangeUpcall(nativeType, function, options);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/macos\/MacOsAArch64Linker.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -57,2 +57,2 @@\n-    protected UpcallStubFactory arrangeUpcall(MethodType targetType, FunctionDescriptor function, LinkerOptions options) {\n-        return CallArranger.WINDOWS.arrangeUpcall(targetType, function, options);\n+    protected UpcallStubFactory arrangeUpcall(MethodType nativeType, FunctionDescriptor function, LinkerOptions options) {\n+        return CallArranger.WINDOWS.arrangeUpcall(nativeType, function, options);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/windows\/WindowsAArch64Linker.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+import java.lang.foreign.Linker;\n@@ -64,1 +65,1 @@\n-                    MethodType.methodType(void.class, MethodHandle.class, MemorySegment.class, MemorySegment.class, UpcallData.class));\n+                    MethodType.methodType(void.class, MethodHandle.class, MemorySegment.class, MemorySegment.class, MemorySegment.class, UpcallData.class));\n@@ -108,2 +109,2 @@\n-    protected UpcallStubFactory arrangeUpcall(MethodType targetType, FunctionDescriptor function, LinkerOptions options) {\n-        MemorySegment cif = makeCif(targetType, function, FFIABI.DEFAULT, Arena.ofAuto());\n+    protected UpcallStubFactory arrangeUpcall(MethodType nativeType, FunctionDescriptor function, LinkerOptions options) {\n+        MemorySegment cif = makeCif(nativeType, function, FFIABI.DEFAULT, Arena.ofAuto());\n@@ -111,2 +112,5 @@\n-        UpcallData invData = new UpcallData(function.returnLayout().orElse(null), function.argumentLayouts(), cif);\n-        MethodHandle doUpcallMH = MethodHandles.insertArguments(MH_DO_UPCALL, 3, invData);\n+        int captureStateMask = options.capturedCallState()\n+                .mapToInt(CapturableState::mask)\n+                .reduce(0, (a, b) -> a | b);\n+        UpcallData invData = new UpcallData(function.returnLayout().orElse(null), function.argumentLayouts(), cif, captureStateMask != 0);\n+        MethodHandle doUpcallMH = MethodHandles.insertArguments(MH_DO_UPCALL, MH_DO_UPCALL.type().parameterCount() - 1, invData);\n@@ -116,1 +120,1 @@\n-            return LibFallback.createClosure(cif, target, scope);\n+            return LibFallback.createClosure(cif, target, captureStateMask, scope);\n@@ -187,1 +191,1 @@\n-    private record UpcallData(MemoryLayout returnLayout, List<MemoryLayout> argLayouts, MemorySegment cif) {}\n+    private record UpcallData(MemoryLayout returnLayout, List<MemoryLayout> argLayouts, MemorySegment cif, boolean hasCapturedState) {}\n@@ -189,1 +193,2 @@\n-    private static void doUpcall(MethodHandle target, MemorySegment retPtr, MemorySegment argPtrs, UpcallData data) throws Throwable {\n+    private static void doUpcall(MethodHandle target, MemorySegment retPtr, MemorySegment argPtrs,\n+                                 MemorySegment ccsPtr, UpcallData data) throws Throwable {\n@@ -198,0 +203,1 @@\n+            MemorySegment ccsSeg = ccsPtr.reinterpret(Linker.Option.captureStateLayout().byteSize(), upcallArena, null);\n@@ -199,1 +205,9 @@\n-            Object[] args = new Object[numArgs];\n+            int outArgs = numArgs;\n+            if (data.hasCapturedState()) {\n+                outArgs++;\n+            }\n+            Object[] args = new Object[outArgs];\n+            int argIdx = 0;\n+            if (data.hasCapturedState()) {\n+                args[argIdx++] = ccsSeg;\n+            }\n@@ -204,1 +218,1 @@\n-                args[i] = readValue(argPtr, argLayout);\n+                args[argIdx++] = readValue(argPtr, argLayout);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/fallback\/FallbackLinker.java","additions":24,"deletions":10,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import java.lang.foreign.Linker;\n@@ -64,1 +65,2 @@\n-    private static final MethodType UPCALL_TARGET_TYPE = MethodType.methodType(void.class, MemorySegment.class, MemorySegment.class);\n+    private static final MethodType UPCALL_TARGET_TYPE = MethodType.methodType(void.class,\n+            MemorySegment.class, MemorySegment.class, MemorySegment.class);\n@@ -111,1 +113,1 @@\n-     * The closure will end up calling into {@link #doUpcall(long, long, MethodHandle)}\n+     * The closure will end up calling into {@link #doUpcall(long, long, MethodHandle, long)}\n@@ -113,1 +115,1 @@\n-     * The target method handle should have the type {@code (MemorySegment, MemorySegment) -> void}. The first\n+     * The target method handle should have the type {@code (MemorySegment, MemorySegment, MemorySegment) -> void}. The first\n@@ -115,1 +117,2 @@\n-     * is a pointer to an array of pointers, which each point to a native argument value.\n+     * is a pointer to an array of pointers, which each point to a native argument value. The third argument is\n+     * a segment into which captured call state should be written (see {@link Linker.Option#captureCallState(String...)}).\n@@ -119,0 +122,1 @@\n+     * @param capturedStateMask mask of call state to capture. See {@link jdk.internal.foreign.abi.CapturableState}\n@@ -125,1 +129,1 @@\n-    static MemorySegment createClosure(MemorySegment cif, MethodHandle target, Arena arena)\n+    static MemorySegment createClosure(MemorySegment cif, MethodHandle target, int capturedStateMask, Arena arena)\n@@ -132,1 +136,1 @@\n-        checkStatus(createClosure(cif.address(), target, ptrs));\n+        checkStatus(createClosure(cif.address(), target, capturedStateMask, ptrs));\n@@ -135,1 +139,1 @@\n-        long globalTarget = ptrs[2];\n+        long upcallData = ptrs[2];\n@@ -137,1 +141,1 @@\n-        return MemorySegment.ofAddress(execPtr).reinterpret(arena, unused -> freeClosure(closurePtr, globalTarget));\n+        return MemorySegment.ofAddress(execPtr).reinterpret(arena, unused -> freeClosure(closurePtr, upcallData));\n@@ -141,1 +145,1 @@\n-    private static void doUpcall(long retPtr, long argPtrs, MethodHandle target) {\n+    private static void doUpcall(long retPtr, long argPtrs, MethodHandle target, long ccsPtr) {\n@@ -143,1 +147,1 @@\n-            target.invokeExact(MemorySegment.ofAddress(retPtr), MemorySegment.ofAddress(argPtrs));\n+            target.invokeExact(MemorySegment.ofAddress(retPtr), MemorySegment.ofAddress(argPtrs), MemorySegment.ofAddress(ccsPtr));\n@@ -175,1 +179,1 @@\n-    private static native int createClosure(long cif, Object userData, long[] ptrs);\n+    private static native int createClosure(long cif, Object userData, int capturedStateMask, long[] ptrs);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/fallback\/LibFallback.java","additions":15,"deletions":11,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -127,1 +127,1 @@\n-        return SharedUtils.arrangeUpcallHelper(mt, bindings.isInMemoryReturn, dropReturn, CLinux,\n+        return SharedUtils.arrangeUpcallHelper(bindings.isInMemoryReturn, dropReturn, CLinux,\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/riscv64\/linux\/LinuxRISCV64CallArranger.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -56,2 +56,2 @@\n-    protected UpcallStubFactory arrangeUpcall(MethodType targetType, FunctionDescriptor function, LinkerOptions options) {\n-        return LinuxRISCV64CallArranger.arrangeUpcall(targetType, function, options);\n+    protected UpcallStubFactory arrangeUpcall(MethodType nativeType, FunctionDescriptor function, LinkerOptions options) {\n+        return LinuxRISCV64CallArranger.arrangeUpcall(nativeType, function, options);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/riscv64\/linux\/LinuxRISCV64Linker.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -144,1 +144,1 @@\n-        return SharedUtils.arrangeUpcallHelper(mt, bindings.isInMemoryReturn, dropReturn, CSysV,\n+        return SharedUtils.arrangeUpcallHelper(bindings.isInMemoryReturn, dropReturn, CSysV,\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/CallArranger.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -58,2 +58,2 @@\n-    protected UpcallStubFactory arrangeUpcall(MethodType targetType, FunctionDescriptor function, LinkerOptions options) {\n-        return CallArranger.arrangeUpcall(targetType, function, options);\n+    protected UpcallStubFactory arrangeUpcall(MethodType nativeType, FunctionDescriptor function, LinkerOptions options) {\n+        return CallArranger.arrangeUpcall(nativeType, function, options);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/SysVx64Linker.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -138,1 +138,1 @@\n-        return SharedUtils.arrangeUpcallHelper(mt, bindings.isInMemoryReturn, dropReturn, CWindows,\n+        return SharedUtils.arrangeUpcallHelper(bindings.isInMemoryReturn, dropReturn, CWindows,\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/CallArranger.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -57,2 +57,2 @@\n-    protected UpcallStubFactory arrangeUpcall(MethodType targetType, FunctionDescriptor function, LinkerOptions options) {\n-        return CallArranger.arrangeUpcall(targetType, function, options);\n+    protected UpcallStubFactory arrangeUpcall(MethodType nativeType, FunctionDescriptor function, LinkerOptions options) {\n+        return CallArranger.arrangeUpcall(nativeType, function, options);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/Windowsx64Linker.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include <malloc.h>\n@@ -41,1 +42,1 @@\n-static const char* LibFallback_doUpcall_sig = \"(JJLjava\/lang\/invoke\/MethodHandle;)V\";\n+static const char* LibFallback_doUpcall_sig = \"(JJLjava\/lang\/invoke\/MethodHandle;J)V\";\n@@ -65,8 +66,10 @@\n-static void do_capture_state(int32_t* value_ptr, int captured_state_mask) {\n-    \/\/ keep in synch with jdk.internal.foreign.abi.CapturableState\n-  enum PreservableValues {\n-    NONE = 0,\n-    GET_LAST_ERROR = 1,\n-    WSA_GET_LAST_ERROR = 1 << 1,\n-    ERRNO = 1 << 2\n-  };\n+\/\/ keep in synch with jdk.internal.foreign.abi.CapturableState\n+enum CapturableState {\n+  CCS_NONE = 0,\n+  CCS_LAST_ERROR = 1,\n+  CCS_WSA_LAST_ERROR = 1 << 1,\n+  CCS_ERRNO = 1 << 2\n+};\n+\n+\/\/ keep in sync with DowncallLinker::capture_state in hotspot\n+static void do_capture_state_downcall(int32_t* value_ptr, int captured_state_mask) {\n@@ -74,1 +77,1 @@\n-  if (captured_state_mask & GET_LAST_ERROR) {\n+  if (captured_state_mask & CCS_LAST_ERROR) {\n@@ -78,1 +81,1 @@\n-  if (captured_state_mask & WSA_GET_LAST_ERROR) {\n+  if (captured_state_mask & CCS_WSA_LAST_ERROR) {\n@@ -83,1 +86,1 @@\n-  if (captured_state_mask & ERRNO) {\n+  if (captured_state_mask & CCS_ERRNO) {\n@@ -94,1 +97,23 @@\n-    do_capture_state(captured_state, captured_state_mask);\n+    do_capture_state_downcall(captured_state, captured_state_mask);\n+  }\n+}\n+\n+struct UpcallUserData {\n+  jobject target;\n+  jint captured_state_mask;\n+};\n+\n+\/\/ keep in sync with UpcallLinker::capture_state in hotspot\n+static void do_capture_state_upcall(int32_t* value_ptr, int captured_state_mask) {\n+#ifdef _WIN64\n+  if (captured_state_mask & CCS_LAST_ERROR) {\n+    SetLastError(*value_ptr);\n+  }\n+  value_ptr++;\n+  if (captured_state_mask & CCS_WSA_LAST_ERROR) {\n+    WSASetLastError(*value_ptr);\n+  }\n+  value_ptr++;\n+#endif\n+  if (captured_state_mask & CCS_ERRNO) {\n+    errno = *value_ptr;\n@@ -103,0 +128,2 @@\n+  int32_t ccs[3];\n+\n@@ -104,1 +131,1 @@\n-  jobject upcall_data = (jobject) user_data;\n+  struct UpcallUserData* upcall_data = (struct UpcallUserData*) user_data;\n@@ -106,1 +133,1 @@\n-    ptr_to_jlong(ret), ptr_to_jlong(args), upcall_data);\n+    ptr_to_jlong(ret), ptr_to_jlong(args), upcall_data->target, ptr_to_jlong(ccs));\n@@ -110,0 +137,2 @@\n+\n+  do_capture_state_upcall(ccs, upcall_data->captured_state_mask);\n@@ -112,1 +141,1 @@\n-static void free_closure(JNIEnv* env, void* closure, jobject upcall_data) {\n+static void free_closure(JNIEnv* env, void* closure, struct UpcallUserData* upcall_data) {\n@@ -114,1 +143,2 @@\n-  (*env)->DeleteGlobalRef(env, upcall_data);\n+  (*env)->DeleteGlobalRef(env, upcall_data->target);\n+  free(upcall_data);\n@@ -118,1 +148,2 @@\n-Java_jdk_internal_foreign_abi_fallback_LibFallback_createClosure(JNIEnv* env, jclass cls, jlong cif, jobject upcall_data, jlongArray jptrs) {\n+Java_jdk_internal_foreign_abi_fallback_LibFallback_createClosure(JNIEnv* env, jclass cls, jlong cif, jobject target,\n+                                                                 jint captured_state_mask, jlongArray jptrs) {\n@@ -122,1 +153,3 @@\n-  jobject global_upcall_data = (*env)->NewGlobalRef(env, upcall_data);\n+  struct UpcallUserData* upcall_data = malloc(sizeof *upcall_data);\n+  upcall_data->target = (*env)->NewGlobalRef(env, target);\n+  upcall_data->captured_state_mask = captured_state_mask;\n@@ -124,1 +157,1 @@\n-  ffi_status status = ffi_prep_closure_loc(closure, jlong_to_ptr(cif), &do_upcall, (void*) global_upcall_data, code);\n+  ffi_status status = ffi_prep_closure_loc(closure, jlong_to_ptr(cif), &do_upcall, (void*) upcall_data, code);\n@@ -127,1 +160,1 @@\n-    free_closure(env,closure, global_upcall_data);\n+    free_closure(env, closure, upcall_data);\n@@ -134,1 +167,1 @@\n-  ptrs[2] = ptr_to_jlong(global_upcall_data);\n+  ptrs[2] = ptr_to_jlong(upcall_data);\n","filename":"src\/java.base\/share\/native\/libfallbackLinker\/fallbackLinker.c","additions":55,"deletions":22,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -86,2 +86,2 @@\n-                { \"GetLastError\" },\n-                { \"WSAGetLastError\" },\n+                { \"LastError\" },\n+                { \"WSALastError\" },\n@@ -97,1 +97,0 @@\n-            { Linker.Option.captureCallState(\"errno\") },\n","filename":"test\/jdk\/java\/foreign\/TestIllegalLink.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+import java.lang.foreign.GroupLayout;\n@@ -41,0 +42,1 @@\n+import java.lang.foreign.ValueLayout;\n@@ -42,0 +44,2 @@\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n@@ -46,0 +50,1 @@\n+import java.util.Optional;\n@@ -49,0 +54,1 @@\n+import static java.lang.foreign.ValueLayout.ADDRESS;\n@@ -56,0 +62,2 @@\n+    static final MethodHandle MH_UPCALL_TARGET;\n+\n@@ -58,4 +66,6 @@\n-        if (IS_WINDOWS) {\n-            String system32 = System.getenv(\"SystemRoot\") + \"\\\\system32\";\n-            System.load(system32 + \"\\\\Kernel32.dll\");\n-            System.load(system32 + \"\\\\Ws2_32.dll\");\n+\n+        try {\n+            MH_UPCALL_TARGET = MethodHandles.lookup().findStatic(TestCaptureCallState.class, \"upcallTarget\",\n+                    MethodType.methodType(Object.class, MemorySegment.class, VarHandle.class, int.class, Object.class));\n+        } catch (ReflectiveOperationException e) {\n+            throw new ExceptionInInitializerError(e);\n@@ -65,1 +75,8 @@\n-    private record SaveValuesCase(String nativeTarget, FunctionDescriptor nativeDesc, String threadLocalName, Consumer<Object> resultCheck) {}\n+    private record SaveValuesCase(String nativeTarget, String threadLocalName, Optional<MemoryLayout> retValueLayout) {\n+        SaveValuesCase(String nativeTarget, String threadLocalName) {\n+            this(nativeTarget, threadLocalName, Optional.empty());\n+        }\n+        SaveValuesCase(String nativeTarget, String threadLocalName, MemoryLayout retValueLayout) {\n+            this(nativeTarget, threadLocalName, Optional.of(retValueLayout));\n+        }\n+    }\n@@ -68,1 +85,1 @@\n-    public void testSavedThreadLocal(SaveValuesCase testCase) throws Throwable {\n+    public void testDowncalls(SaveValuesCase testCase) throws Throwable {\n@@ -70,1 +87,4 @@\n-        MethodHandle handle = downcallHandle(testCase.nativeTarget(), testCase.nativeDesc(), stl);\n+        FunctionDescriptor downcallDesc = testCase.retValueLayout()\n+                .map(rl -> FunctionDescriptor.of(rl, JAVA_INT, rl))\n+                .orElseGet(() -> FunctionDescriptor.ofVoid(JAVA_INT));\n+        MethodHandle handle = downcallHandle(\"set_\" + testCase.nativeTarget(), downcallDesc, stl);\n@@ -77,2 +97,4 @@\n-            int testValue = 42;\n-            boolean needsAllocator = testCase.nativeDesc().returnLayout().map(StructLayout.class::isInstance).orElse(false);\n+            TestValue captureStateValue = genTestValue(JAVA_INT, arena);\n+            TestValue testValue = testCase.retValueLayout().map(rl -> genTestValue(rl, arena)).orElse(null);\n+\n+            boolean needsAllocator = testCase.retValueLayout().map(StructLayout.class::isInstance).orElse(false);\n@@ -80,3 +102,9 @@\n-                ? handle.invoke(arena, saveSeg, testValue)\n-                : handle.invoke(saveSeg, testValue);\n-            testCase.resultCheck().accept(result);\n+                ? handle.invoke(arena, saveSeg, captureStateValue.value(), testValue.value())\n+                : testValue != null\n+                    ? handle.invoke(saveSeg, captureStateValue.value(), testValue.value())\n+                    : handle.invoke(saveSeg, captureStateValue.value());\n+\n+            if (testValue != null) {\n+                testValue.check().accept(result);\n+            }\n+\n@@ -84,1 +112,1 @@\n-            assertEquals(savedErrno, testValue);\n+            captureStateValue.check().accept(savedErrno);\n@@ -88,3 +116,6 @@\n-    @DataProvider\n-    public static Object[][] cases() {\n-        List<SaveValuesCase> cases = new ArrayList<>();\n+    @Test(dataProvider = \"cases\")\n+    public void testUpcalls(SaveValuesCase testCase) throws Throwable {\n+        FunctionDescriptor downcallDesc = testCase.retValueLayout()\n+                .map(rl -> FunctionDescriptor.of(rl, ADDRESS, ADDRESS))\n+                .orElse(FunctionDescriptor.ofVoid(ADDRESS, ADDRESS));\n+        MethodHandle handle = downcallHandle(\"get_\" + testCase.nativeTarget(), downcallDesc);\n@@ -92,16 +123,3 @@\n-        cases.add(new SaveValuesCase(\"set_errno_V\", FunctionDescriptor.ofVoid(JAVA_INT), \"errno\", o -> {}));\n-        cases.add(new SaveValuesCase(\"set_errno_I\", FunctionDescriptor.of(JAVA_INT, JAVA_INT), \"errno\", o -> assertEquals((int) o, 42)));\n-        cases.add(new SaveValuesCase(\"set_errno_D\", FunctionDescriptor.of(JAVA_DOUBLE, JAVA_INT), \"errno\", o -> assertEquals((double) o, 42.0)));\n-\n-        cases.add(structCase(\"SL\",  Map.of(JAVA_LONG.withName(\"x\"), 42L)));\n-        cases.add(structCase(\"SLL\", Map.of(JAVA_LONG.withName(\"x\"), 42L,\n-                                           JAVA_LONG.withName(\"y\"), 42L)));\n-        cases.add(structCase(\"SLLL\", Map.of(JAVA_LONG.withName(\"x\"), 42L,\n-                                            JAVA_LONG.withName(\"y\"), 42L,\n-                                            JAVA_LONG.withName(\"z\"), 42L)));\n-        cases.add(structCase(\"SD\",  Map.of(JAVA_DOUBLE.withName(\"x\"), 42D)));\n-        cases.add(structCase(\"SDD\", Map.of(JAVA_DOUBLE.withName(\"x\"), 42D,\n-                                           JAVA_DOUBLE.withName(\"y\"), 42D)));\n-        cases.add(structCase(\"SDDD\", Map.of(JAVA_DOUBLE.withName(\"x\"), 42D,\n-                                            JAVA_DOUBLE.withName(\"y\"), 42D,\n-                                            JAVA_DOUBLE.withName(\"z\"), 42D)));\n+        try (Arena arena = Arena.ofConfined()) {\n+            TestValue captureStateValue = genTestValue(JAVA_INT, arena);\n+            TestValue testValue = testCase.retValueLayout().map(rl -> genTestValue(rl, arena)).orElse(null);\n@@ -109,3 +127,16 @@\n-        if (IS_WINDOWS) {\n-            cases.add(new SaveValuesCase(\"SetLastError\", FunctionDescriptor.ofVoid(JAVA_INT), \"GetLastError\", o -> {}));\n-            cases.add(new SaveValuesCase(\"WSASetLastError\", FunctionDescriptor.ofVoid(JAVA_INT), \"WSAGetLastError\", o -> {}));\n+            MemorySegment callback = makeCaptureStateCallback(arena, testCase.threadLocalName(),\n+                    testCase.retValueLayout(), (int) captureStateValue.value(),\n+                    testValue == null ? null : testValue.value());\n+\n+            MemorySegment writeBack = arena.allocate(JAVA_INT);\n+            boolean needsAllocator = downcallDesc.returnLayout().map(StructLayout.class::isInstance).orElse(false);\n+            Object result = needsAllocator\n+                ? handle.invoke(arena, writeBack, callback)\n+                : handle.invoke(writeBack, callback);\n+\n+            if (testValue != null) {\n+                testValue.check().accept(result);\n+            }\n+\n+            int savedErrno = writeBack.get(JAVA_INT, 0);\n+            captureStateValue.check().accept(savedErrno);\n@@ -113,0 +144,1 @@\n+    }\n@@ -114,1 +146,15 @@\n-        return cases.stream().map(tc -> new Object[] {tc}).toArray(Object[][]::new);\n+    private MemorySegment makeCaptureStateCallback(Arena arena, String threadLocalName, Optional<MemoryLayout> retLayout,\n+                                                   int captureStateValue, Object testValue) {\n+        FunctionDescriptor upcallDesc = retLayout\n+            .map(FunctionDescriptor::of)\n+            .orElse(FunctionDescriptor.ofVoid());\n+        StructLayout capturedStateLayout = Linker.Option.captureStateLayout();\n+        VarHandle errnoHandle = capturedStateLayout.varHandle(groupElement(threadLocalName));\n+        MethodHandle target = MethodHandles.insertArguments(MH_UPCALL_TARGET, 1, errnoHandle, captureStateValue, testValue);\n+        if (retLayout.isEmpty()) {\n+            target = MethodHandles.dropReturn(target);\n+        } else {\n+            target = target.asType(target.type().changeReturnType(carrierFor(retLayout.get())));\n+        }\n+        return LINKER.upcallStub(target, upcallDesc, arena,\n+                Linker.Option.captureCallState(threadLocalName));\n@@ -117,2 +163,15 @@\n-    static SaveValuesCase structCase(String name, Map<MemoryLayout, Object> fields) {\n-        StructLayout layout = MemoryLayout.structLayout(fields.keySet().toArray(MemoryLayout[]::new));\n+    private Class<?> carrierFor(MemoryLayout layout) {\n+        if (layout instanceof ValueLayout valueLayout) {\n+            return valueLayout.carrier();\n+        } else if (layout instanceof GroupLayout) {\n+            return MemorySegment.class;\n+        } else {\n+            throw new IllegalArgumentException(\"Unsupported layout: \" + layout);\n+        }\n+    }\n+\n+    public static Object upcallTarget(MemorySegment writeback, VarHandle writebackHandle, int captureStateValue,\n+                                      Object returnValue) {\n+        writebackHandle.set(writeback, captureStateValue);\n+        return returnValue;\n+    }\n@@ -120,6 +179,30 @@\n-        Consumer<Object> check = o -> {};\n-        for (var field : fields.entrySet()) {\n-            MemoryLayout fieldLayout = field.getKey();\n-            VarHandle fieldHandle = layout.varHandle(MemoryLayout.PathElement.groupElement(fieldLayout.name().get()));\n-            Object value = field.getValue();\n-            check = check.andThen(o -> assertEquals(fieldHandle.get(o), value));\n+    @DataProvider\n+    public static Object[][] cases() {\n+        List<SaveValuesCase> cases = new ArrayList<>();\n+\n+        cases.add(new SaveValuesCase(\"errno_V\", \"errno\"));\n+        cases.add(new SaveValuesCase(\"errno_I\", \"errno\", JAVA_INT));\n+        cases.add(new SaveValuesCase(\"errno_D\", \"errno\", JAVA_DOUBLE));\n+\n+        cases.add(new SaveValuesCase(\"errno_SL\", \"errno\",\n+                MemoryLayout.structLayout(JAVA_LONG.withName(\"x\")).withName(\"SL\")));\n+        cases.add(new SaveValuesCase(\"errno_SLL\", \"errno\",\n+                MemoryLayout.structLayout(JAVA_LONG.withName(\"x\"),\n+                                          JAVA_LONG.withName(\"y\")).withName(\"SLL\")));\n+        cases.add(new SaveValuesCase(\"errno_SLLL\", \"errno\",\n+                MemoryLayout.structLayout(JAVA_LONG.withName(\"x\"),\n+                                          JAVA_LONG.withName(\"y\"),\n+                                          JAVA_LONG.withName(\"z\")).withName(\"SLLL\")));\n+        cases.add(new SaveValuesCase(\"errno_SD\", \"errno\",\n+                MemoryLayout.structLayout(JAVA_DOUBLE.withName(\"x\")).withName(\"SD\")));\n+        cases.add(new SaveValuesCase(\"errno_SDD\", \"errno\",\n+                MemoryLayout.structLayout(JAVA_DOUBLE.withName(\"x\"),\n+                                          JAVA_DOUBLE.withName(\"y\")).withName(\"SDD\")));\n+        cases.add(new SaveValuesCase(\"errno_SDDD\", \"errno\",\n+                MemoryLayout.structLayout(JAVA_DOUBLE.withName(\"x\"),\n+                                          JAVA_DOUBLE.withName(\"y\"),\n+                                          JAVA_DOUBLE.withName(\"z\")).withName(\"SDDD\")));\n+\n+        if (IS_WINDOWS) {\n+            cases.add(new SaveValuesCase(\"last_error\", \"LastError\"));\n+            cases.add(new SaveValuesCase(\"wsa_last_error\", \"WSALastError\"));\n@@ -128,1 +211,1 @@\n-        return new SaveValuesCase(\"set_errno_\" + name, FunctionDescriptor.of(layout, JAVA_INT), \"errno\", check);\n+        return cases.stream().map(tc -> new Object[] {tc}).toArray(Object[][]::new);\n@@ -132,1 +215,0 @@\n-\n","filename":"test\/jdk\/java\/foreign\/capturecallstate\/TestCaptureCallState.java","additions":128,"deletions":46,"binary":false,"changes":174,"status":"modified"},{"patch":"@@ -27,0 +27,3 @@\n+#include <Windows.h>\n+#include <Winsock2.h>\n+\n@@ -32,2 +35,18 @@\n-EXPORT void set_errno_V(int value) {\n-    errno = value;\n+EXPORT void set_errno_V(int capture_state_value) {\n+    errno = capture_state_value;\n+}\n+\n+EXPORT void get_errno_V(int* value_out, void (*cb)(void)) {\n+    cb();\n+    *value_out = errno;\n+}\n+\n+EXPORT int set_errno_I(int capture_state_value, int test_value) {\n+    errno = capture_state_value;\n+    return test_value;\n+}\n+\n+EXPORT int get_errno_I(int* value_out, int (*cb)(void)) {\n+    int i = cb();\n+    *value_out = errno;\n+    return i;\n@@ -36,3 +55,3 @@\n-EXPORT int set_errno_I(int value) {\n-    errno = value;\n-    return 42;\n+EXPORT double set_errno_D(int capture_state_value, double test_value) {\n+    errno = capture_state_value;\n+    return test_value;\n@@ -41,3 +60,4 @@\n-EXPORT double set_errno_D(int value) {\n-    errno = value;\n-    return 42.0;\n+EXPORT double get_errno_D(int* value_out, double (*cb)(void)) {\n+    double d = cb();\n+    *value_out = errno;\n+    return d;\n@@ -50,4 +70,8 @@\n-EXPORT struct SL set_errno_SL(int value) {\n-    errno = value;\n-    struct SL s;\n-    s.x = 42;\n+EXPORT struct SL set_errno_SL(int capture_state_value, struct SL test_value) {\n+    errno = capture_state_value;\n+    return test_value;\n+}\n+\n+EXPORT struct SL get_errno_SL(int* value_out, struct SL (*cb)(void)) {\n+    struct SL s = cb();\n+    *value_out = errno;\n@@ -62,5 +86,8 @@\n-EXPORT struct SLL set_errno_SLL(int value) {\n-    errno = value;\n-    struct SLL s;\n-    s.x = 42;\n-    s.y = 42;\n+EXPORT struct SLL set_errno_SLL(int capture_state_value, struct SLL test_value) {\n+    errno = capture_state_value;\n+    return test_value;\n+}\n+\n+EXPORT struct SLL get_errno_SLL(int* value_out, struct SLL (*cb)(void)) {\n+    struct SLL s = cb();\n+    *value_out = errno;\n@@ -76,6 +103,8 @@\n-EXPORT struct SLLL set_errno_SLLL(int value) {\n-    errno = value;\n-    struct SLLL s;\n-    s.x = 42;\n-    s.y = 42;\n-    s.z = 42;\n+EXPORT struct SLLL set_errno_SLLL(int capture_state_value, struct SLLL test_value) {\n+    errno = capture_state_value;\n+    return test_value;\n+}\n+\n+EXPORT struct SLLL get_errno_SLLL(int* value_out, struct SLLL (*cb)(void)) {\n+    struct SLLL s = cb();\n+    *value_out = errno;\n@@ -89,4 +118,8 @@\n-EXPORT struct SD set_errno_SD(int value) {\n-    errno = value;\n-    struct SD s;\n-    s.x = 42.0;\n+EXPORT struct SD set_errno_SD(int capture_state_value, struct SD test_value) {\n+    errno = capture_state_value;\n+    return test_value;\n+}\n+\n+EXPORT struct SD get_errno_SD(int* value_out, struct SD (*cb)(void)) {\n+    struct SD s = cb();\n+    *value_out = errno;\n@@ -101,5 +134,8 @@\n-EXPORT struct SDD set_errno_SDD(int value) {\n-    errno = value;\n-    struct SDD s;\n-    s.x = 42.0;\n-    s.y = 42.0;\n+EXPORT struct SDD set_errno_SDD(int capture_state_value, struct SDD test_value) {\n+    errno = capture_state_value;\n+    return test_value;\n+}\n+\n+EXPORT struct SDD get_errno_SDD(int* value_out, struct SDD (*cb)(void)) {\n+    struct SDD s = cb();\n+    *value_out = errno;\n@@ -115,6 +151,8 @@\n-EXPORT struct SDDD set_errno_SDDD(int value) {\n-    errno = value;\n-    struct SDDD s;\n-    s.x = 42.0;\n-    s.y = 42.0;\n-    s.z = 42.0;\n+EXPORT struct SDDD set_errno_SDDD(int capture_state_value, struct SDDD test_value) {\n+    errno = capture_state_value;\n+    return test_value;\n+}\n+\n+EXPORT struct SDDD get_errno_SDDD(int* value_out, struct SDDD (*cb)(void)) {\n+    struct SDDD s = cb();\n+    *value_out = errno;\n@@ -123,0 +161,18 @@\n+\n+#ifdef _WIN64\n+EXPORT void set_last_error(int capture_state_value) {\n+    SetLastError(capture_state_value);\n+}\n+EXPORT void get_last_error(int* value_out, void (*cb)(void)) {\n+    cb();\n+    *value_out = GetLastError();\n+}\n+\n+EXPORT void set_wsa_last_error(int capture_state_value) {\n+    WSASetLastError(capture_state_value);\n+}\n+EXPORT void get_wsa_last_error(int* value_out, void (*cb)(void)) {\n+    cb();\n+    *value_out = WSAGetLastError();\n+}\n+#endif\n","filename":"test\/jdk\/java\/foreign\/capturecallstate\/libCaptureCallState.c","additions":94,"deletions":38,"binary":false,"changes":132,"status":"modified"}]}