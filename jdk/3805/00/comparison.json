{"files":[{"patch":"@@ -115,2 +115,1 @@\n-                               int caller_bci, ciCallProfile& profile,\n-                               WarmCallInfo* wci_result) {\n+                               int caller_bci, ciCallProfile& profile) {\n@@ -119,5 +118,0 @@\n-    *wci_result = *(WarmCallInfo::always_hot());\n-    if (C->print_inlining() && Verbose) {\n-      CompileTask::print_inline_indent(inline_level());\n-      tty->print_cr(\"Inlined method is hot: \");\n-    }\n@@ -130,3 +124,3 @@\n-      set_msg(\"force inline by annotation\");\n-      _forced_inline = true;\n-      return true;\n+    set_msg(\"force inline by annotation\");\n+    _forced_inline = true;\n+    return true;\n@@ -149,1 +143,0 @@\n-    wci_result->set_profit(wci_result->profit() * 100);\n@@ -205,2 +198,1 @@\n-                                   JVMState* jvms,\n-                                   WarmCallInfo* wci_result) {\n+                                   JVMState* jvms) {\n@@ -364,1 +356,1 @@\n-                               WarmCallInfo* wci_result, bool& should_delay) {\n+                               bool& should_delay) {\n@@ -376,2 +368,1 @@\n-  if (!should_inline(callee_method, caller_method, caller_bci, profile,\n-                     wci_result)) {\n+  if (!should_inline(callee_method, caller_method, caller_bci, profile)) {\n@@ -380,1 +371,1 @@\n-  if (should_not_inline(callee_method, caller_method, jvms, wci_result)) {\n+  if (should_not_inline(callee_method, caller_method, jvms)) {\n@@ -563,1 +554,2 @@\n-WarmCallInfo* InlineTree::ok_to_inline(ciMethod* callee_method, JVMState* jvms, ciCallProfile& profile, WarmCallInfo* initial_wci, bool& should_delay) {\n+bool InlineTree::ok_to_inline(ciMethod* callee_method, JVMState* jvms, ciCallProfile& profile,\n+                              bool& should_delay) {\n@@ -583,1 +575,1 @@\n-    return NULL;\n+    return false;\n@@ -590,1 +582,1 @@\n-    return NULL;\n+    return false;\n@@ -594,19 +586,2 @@\n-  WarmCallInfo wci = *(initial_wci);\n-  bool success = try_to_inline(callee_method, caller_method, caller_bci,\n-                               jvms, profile, &wci, should_delay);\n-\n-#ifndef PRODUCT\n-  if (InlineWarmCalls && (PrintOpto || C->print_inlining())) {\n-    bool cold = wci.is_cold();\n-    bool hot  = !cold && wci.is_hot();\n-    bool old_cold = !success;\n-    if (old_cold != cold || (Verbose || WizardMode)) {\n-      if (msg() == NULL) {\n-        set_msg(\"OK\");\n-      }\n-      tty->print(\"   OldInlining= %4s : %s\\n           WCI=\",\n-                 old_cold ? \"cold\" : \"hot\", msg());\n-      wci.print();\n-    }\n-  }\n-#endif\n+  bool success = try_to_inline(callee_method, caller_method, caller_bci, jvms, profile,\n+                               should_delay); \/\/ out\n@@ -614,13 +589,0 @@\n-    wci = *(WarmCallInfo::always_hot());\n-  } else {\n-    wci = *(WarmCallInfo::always_cold());\n-  }\n-\n-  if (!InlineWarmCalls) {\n-    if (!wci.is_cold() && !wci.is_hot()) {\n-      \/\/ Do not inline the warm calls.\n-      wci = *(WarmCallInfo::always_cold());\n-    }\n-  }\n-\n-  if (!wci.is_cold()) {\n@@ -633,2 +595,5 @@\n-    if (InlineWarmCalls && !wci.is_hot()) {\n-      return new (C) WarmCallInfo(wci);  \/\/ copy to heap\n+    return true;\n+  } else {\n+    \/\/ Do not inline\n+    if (msg() == NULL) {\n+      set_msg(\"too cold to inline\");\n@@ -636,6 +601,2 @@\n-    return WarmCallInfo::always_hot();\n-  }\n-\n-  \/\/ Do not inline\n-  if (msg() == NULL) {\n-    set_msg(\"too cold to inline\");\n+    print_inlining(callee_method, caller_bci, caller_method, false \/* !success *\/ );\n+    return false;\n@@ -643,2 +604,0 @@\n-  print_inlining(callee_method, caller_bci, caller_method, false \/* !success *\/ );\n-  return NULL;\n","filename":"src\/hotspot\/share\/opto\/bytecodeInfo.cpp","additions":21,"deletions":62,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -422,40 +422,0 @@\n-  develop(intx, NodeCountInliningStep, 1000,                                \\\n-          \"Target size of warm calls inlined between optimization passes\")  \\\n-          range(0, max_jint)                                                \\\n-                                                                            \\\n-  develop(bool, InlineWarmCalls, false,                                     \\\n-          \"Use a heat-based priority queue to govern inlining\")             \\\n-                                                                            \\\n-  \/* Max values must not exceed WarmCallInfo::MAX_VALUE(). *\/               \\\n-  develop(intx, HotCallCountThreshold, 999999,                              \\\n-          \"large numbers of calls (per method invocation) force hotness\")   \\\n-          range(0, ((intx)MIN2((int64_t)max_intx,(int64_t)(+1.0e10))))      \\\n-                                                                            \\\n-  develop(intx, HotCallProfitThreshold, 999999,                             \\\n-          \"highly profitable inlining opportunities force hotness\")         \\\n-          range(0, ((intx)MIN2((int64_t)max_intx,(int64_t)(+1.0e10))))      \\\n-                                                                            \\\n-  develop(intx, HotCallTrivialWork, -1,                                     \\\n-          \"trivial execution time (no larger than this) forces hotness\")    \\\n-          range(-1, ((intx)MIN2((int64_t)max_intx,(int64_t)(+1.0e10))))     \\\n-                                                                            \\\n-  develop(intx, HotCallTrivialSize, -1,                                     \\\n-          \"trivial methods (no larger than this) force calls to be hot\")    \\\n-          range(-1, ((intx)MIN2((int64_t)max_intx,(int64_t)(+1.0e10))))     \\\n-                                                                            \\\n-  develop(intx, WarmCallMinCount, -1,                                       \\\n-          \"number of calls (per method invocation) to enable inlining\")     \\\n-          range(-1, ((intx)MIN2((int64_t)max_intx,(int64_t)(+1.0e10))))     \\\n-                                                                            \\\n-  develop(intx, WarmCallMinProfit, -1,                                      \\\n-          \"number of calls (per method invocation) to enable inlining\")     \\\n-          range(-1, ((intx)MIN2((int64_t)max_intx,(int64_t)(+1.0e10))))     \\\n-                                                                            \\\n-  develop(intx, WarmCallMaxWork, 999999,                                    \\\n-          \"execution time of the largest inlinable method\")                 \\\n-          range(0, ((intx)MIN2((int64_t)max_intx,(int64_t)(+1.0e10))))      \\\n-                                                                            \\\n-  develop(intx, WarmCallMaxSize, 999999,                                    \\\n-          \"size of the largest inlinable method\")                           \\\n-          range(0, ((intx)MIN2((int64_t)max_intx,(int64_t)(+1.0e10))))      \\\n-                                                                            \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":0,"deletions":40,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -854,75 +854,0 @@\n-\/\/---------------------------WarmCallGenerator--------------------------------\n-\/\/ Internal class which handles initial deferral of inlining decisions.\n-class WarmCallGenerator : public CallGenerator {\n-  WarmCallInfo*   _call_info;\n-  CallGenerator*  _if_cold;\n-  CallGenerator*  _if_hot;\n-  bool            _is_virtual;   \/\/ caches virtuality of if_cold\n-  bool            _is_inline;    \/\/ caches inline-ness of if_hot\n-\n-public:\n-  WarmCallGenerator(WarmCallInfo* ci,\n-                    CallGenerator* if_cold,\n-                    CallGenerator* if_hot)\n-    : CallGenerator(if_cold->method())\n-  {\n-    assert(method() == if_hot->method(), \"consistent choices\");\n-    _call_info  = ci;\n-    _if_cold    = if_cold;\n-    _if_hot     = if_hot;\n-    _is_virtual = if_cold->is_virtual();\n-    _is_inline  = if_hot->is_inline();\n-  }\n-\n-  virtual bool      is_inline() const           { return _is_inline; }\n-  virtual bool      is_virtual() const          { return _is_virtual; }\n-  virtual bool      is_deferred() const         { return true; }\n-\n-  virtual JVMState* generate(JVMState* jvms);\n-};\n-\n-\n-CallGenerator* CallGenerator::for_warm_call(WarmCallInfo* ci,\n-                                            CallGenerator* if_cold,\n-                                            CallGenerator* if_hot) {\n-  return new WarmCallGenerator(ci, if_cold, if_hot);\n-}\n-\n-JVMState* WarmCallGenerator::generate(JVMState* jvms) {\n-  Compile* C = Compile::current();\n-  C->print_inlining_update(this);\n-\n-  if (C->log() != NULL) {\n-    C->log()->elem(\"warm_call bci='%d'\", jvms->bci());\n-  }\n-  jvms = _if_cold->generate(jvms);\n-  if (jvms != NULL) {\n-    Node* m = jvms->map()->control();\n-    if (m->is_CatchProj()) m = m->in(0);  else m = C->top();\n-    if (m->is_Catch())     m = m->in(0);  else m = C->top();\n-    if (m->is_Proj())      m = m->in(0);  else m = C->top();\n-    if (m->is_CallJava()) {\n-      _call_info->set_call(m->as_Call());\n-      _call_info->set_hot_cg(_if_hot);\n-#ifndef PRODUCT\n-      if (PrintOpto || PrintOptoInlining) {\n-        tty->print_cr(\"Queueing for warm inlining at bci %d:\", jvms->bci());\n-        tty->print(\"WCI: \");\n-        _call_info->print();\n-      }\n-#endif\n-      _call_info->set_heat(_call_info->compute_heat());\n-      C->set_warm_calls(_call_info->insert_into(C->warm_calls()));\n-    }\n-  }\n-  return jvms;\n-}\n-\n-void WarmCallInfo::make_hot() {\n-  Unimplemented();\n-}\n-\n-void WarmCallInfo::make_cold() {\n-  \/\/ No action:  Just dequeue.\n-}\n-\n@@ -1563,155 +1488,0 @@\n-\n-#define NODES_OVERHEAD_PER_METHOD (30.0)\n-#define NODES_PER_BYTECODE (9.5)\n-\n-void WarmCallInfo::init(JVMState* call_site, ciMethod* call_method, ciCallProfile& profile, float prof_factor) {\n-  int call_count = profile.count();\n-  int code_size = call_method->code_size();\n-\n-  \/\/ Expected execution count is based on the historical count:\n-  _count = call_count < 0 ? 1 : call_site->method()->scale_count(call_count, prof_factor);\n-\n-  \/\/ Expected profit from inlining, in units of simple call-overheads.\n-  _profit = 1.0;\n-\n-  \/\/ Expected work performed by the call in units of call-overheads.\n-  \/\/ %%% need an empirical curve fit for \"work\" (time in call)\n-  float bytecodes_per_call = 3;\n-  _work = 1.0 + code_size \/ bytecodes_per_call;\n-\n-  \/\/ Expected size of compilation graph:\n-  \/\/ -XX:+PrintParseStatistics once reported:\n-  \/\/  Methods seen: 9184  Methods parsed: 9184  Nodes created: 1582391\n-  \/\/  Histogram of 144298 parsed bytecodes:\n-  \/\/ %%% Need an better predictor for graph size.\n-  _size = NODES_OVERHEAD_PER_METHOD + (NODES_PER_BYTECODE * code_size);\n-}\n-\n-\/\/ is_cold:  Return true if the node should never be inlined.\n-\/\/ This is true if any of the key metrics are extreme.\n-bool WarmCallInfo::is_cold() const {\n-  if (count()  <  WarmCallMinCount)        return true;\n-  if (profit() <  WarmCallMinProfit)       return true;\n-  if (work()   >  WarmCallMaxWork)         return true;\n-  if (size()   >  WarmCallMaxSize)         return true;\n-  return false;\n-}\n-\n-\/\/ is_hot:  Return true if the node should be inlined immediately.\n-\/\/ This is true if any of the key metrics are extreme.\n-bool WarmCallInfo::is_hot() const {\n-  assert(!is_cold(), \"eliminate is_cold cases before testing is_hot\");\n-  if (count()  >= HotCallCountThreshold)   return true;\n-  if (profit() >= HotCallProfitThreshold)  return true;\n-  if (work()   <= HotCallTrivialWork)      return true;\n-  if (size()   <= HotCallTrivialSize)      return true;\n-  return false;\n-}\n-\n-\/\/ compute_heat:\n-float WarmCallInfo::compute_heat() const {\n-  assert(!is_cold(), \"compute heat only on warm nodes\");\n-  assert(!is_hot(),  \"compute heat only on warm nodes\");\n-  int min_size = MAX2(0,   (int)HotCallTrivialSize);\n-  int max_size = MIN2(500, (int)WarmCallMaxSize);\n-  float method_size = (size() - min_size) \/ MAX2(1, max_size - min_size);\n-  float size_factor;\n-  if      (method_size < 0.05)  size_factor = 4;   \/\/ 2 sigmas better than avg.\n-  else if (method_size < 0.15)  size_factor = 2;   \/\/ 1 sigma better than avg.\n-  else if (method_size < 0.5)   size_factor = 1;   \/\/ better than avg.\n-  else                          size_factor = 0.5; \/\/ worse than avg.\n-  return (count() * profit() * size_factor);\n-}\n-\n-bool WarmCallInfo::warmer_than(WarmCallInfo* that) {\n-  assert(this != that, \"compare only different WCIs\");\n-  assert(this->heat() != 0 && that->heat() != 0, \"call compute_heat 1st\");\n-  if (this->heat() > that->heat())   return true;\n-  if (this->heat() < that->heat())   return false;\n-  assert(this->heat() == that->heat(), \"no NaN heat allowed\");\n-  \/\/ Equal heat.  Break the tie some other way.\n-  if (!this->call() || !that->call())  return (address)this > (address)that;\n-  return this->call()->_idx > that->call()->_idx;\n-}\n-\n-\/\/#define UNINIT_NEXT ((WarmCallInfo*)badAddress)\n-#define UNINIT_NEXT ((WarmCallInfo*)NULL)\n-\n-WarmCallInfo* WarmCallInfo::insert_into(WarmCallInfo* head) {\n-  assert(next() == UNINIT_NEXT, \"not yet on any list\");\n-  WarmCallInfo* prev_p = NULL;\n-  WarmCallInfo* next_p = head;\n-  while (next_p != NULL && next_p->warmer_than(this)) {\n-    prev_p = next_p;\n-    next_p = prev_p->next();\n-  }\n-  \/\/ Install this between prev_p and next_p.\n-  this->set_next(next_p);\n-  if (prev_p == NULL)\n-    head = this;\n-  else\n-    prev_p->set_next(this);\n-  return head;\n-}\n-\n-WarmCallInfo* WarmCallInfo::remove_from(WarmCallInfo* head) {\n-  WarmCallInfo* prev_p = NULL;\n-  WarmCallInfo* next_p = head;\n-  while (next_p != this) {\n-    assert(next_p != NULL, \"this must be in the list somewhere\");\n-    prev_p = next_p;\n-    next_p = prev_p->next();\n-  }\n-  next_p = this->next();\n-  debug_only(this->set_next(UNINIT_NEXT));\n-  \/\/ Remove this from between prev_p and next_p.\n-  if (prev_p == NULL)\n-    head = next_p;\n-  else\n-    prev_p->set_next(next_p);\n-  return head;\n-}\n-\n-WarmCallInfo WarmCallInfo::_always_hot(WarmCallInfo::MAX_VALUE(), WarmCallInfo::MAX_VALUE(),\n-                                       WarmCallInfo::MIN_VALUE(), WarmCallInfo::MIN_VALUE());\n-WarmCallInfo WarmCallInfo::_always_cold(WarmCallInfo::MIN_VALUE(), WarmCallInfo::MIN_VALUE(),\n-                                        WarmCallInfo::MAX_VALUE(), WarmCallInfo::MAX_VALUE());\n-\n-WarmCallInfo* WarmCallInfo::always_hot() {\n-  assert(_always_hot.is_hot(), \"must always be hot\");\n-  return &_always_hot;\n-}\n-\n-WarmCallInfo* WarmCallInfo::always_cold() {\n-  assert(_always_cold.is_cold(), \"must always be cold\");\n-  return &_always_cold;\n-}\n-\n-\n-#ifndef PRODUCT\n-\n-void WarmCallInfo::print() const {\n-  tty->print(\"%s : C=%6.1f P=%6.1f W=%6.1f S=%6.1f H=%6.1f -> %p\",\n-             is_cold() ? \"cold\" : is_hot() ? \"hot \" : \"warm\",\n-             count(), profit(), work(), size(), compute_heat(), next());\n-  tty->cr();\n-  if (call() != NULL)  call()->dump();\n-}\n-\n-void print_wci(WarmCallInfo* ci) {\n-  ci->print();\n-}\n-\n-void WarmCallInfo::print_all() const {\n-  for (const WarmCallInfo* p = this; p != NULL; p = p->next())\n-    p->print();\n-}\n-\n-int WarmCallInfo::count_all() const {\n-  int cnt = 0;\n-  for (const WarmCallInfo* p = this; p != NULL; p = p->next())\n-    cnt++;\n-  return cnt;\n-}\n-\n-#endif \/\/PRODUCT\n","filename":"src\/hotspot\/share\/opto\/callGenerator.cpp","additions":0,"deletions":230,"binary":false,"changes":230,"status":"modified"},{"patch":"@@ -145,6 +145,0 @@\n-\n-  \/\/ How to make a call but defer the decision whether to inline or not.\n-  static CallGenerator* for_warm_call(WarmCallInfo* ci,\n-                                      CallGenerator* if_cold,\n-                                      CallGenerator* if_hot);\n-\n@@ -209,154 +203,0 @@\n-\n-\/\/---------------------------WarmCallInfo--------------------------------------\n-\/\/ A struct to collect information about a given call site.\n-\/\/ Helps sort call sites into \"hot\", \"medium\", and \"cold\".\n-\/\/ Participates in the queueing of \"medium\" call sites for possible inlining.\n-class WarmCallInfo : public ResourceObj {\n- private:\n-\n-  CallNode*     _call;   \/\/ The CallNode which may be inlined.\n-  CallGenerator* _hot_cg;\/\/ CG for expanding the call node\n-\n-  \/\/ These are the metrics we use to evaluate call sites:\n-\n-  float         _count;  \/\/ How often do we expect to reach this site?\n-  float         _profit; \/\/ How much time do we expect to save by inlining?\n-  float         _work;   \/\/ How long do we expect the average call to take?\n-  float         _size;   \/\/ How big do we expect the inlined code to be?\n-\n-  float         _heat;   \/\/ Combined score inducing total order on call sites.\n-  WarmCallInfo* _next;   \/\/ Next cooler call info in pending queue.\n-\n-  \/\/ Count is the number of times this call site is expected to be executed.\n-  \/\/ Large count is favorable for inlining, because the extra compilation\n-  \/\/ work will be amortized more completely.\n-\n-  \/\/ Profit is a rough measure of the amount of time we expect to save\n-  \/\/ per execution of this site if we inline it.  (1.0 == call overhead)\n-  \/\/ Large profit favors inlining.  Negative profit disables inlining.\n-\n-  \/\/ Work is a rough measure of the amount of time a typical out-of-line\n-  \/\/ call from this site is expected to take.  (1.0 == call, no-op, return)\n-  \/\/ Small work is somewhat favorable for inlining, since methods with\n-  \/\/ short \"hot\" traces are more likely to inline smoothly.\n-\n-  \/\/ Size is the number of graph nodes we expect this method to produce,\n-  \/\/ not counting the inlining of any further warm calls it may include.\n-  \/\/ Small size favors inlining, since small methods are more likely to\n-  \/\/ inline smoothly.  The size is estimated by examining the native code\n-  \/\/ if available.  The method bytecodes are also examined, assuming\n-  \/\/ empirically observed node counts for each kind of bytecode.\n-\n-  \/\/ Heat is the combined \"goodness\" of a site's inlining.  If we were\n-  \/\/ omniscient, it would be the difference of two sums of future execution\n-  \/\/ times of code emitted for this site (amortized across multiple sites if\n-  \/\/ sharing applies).  The two sums are for versions of this call site with\n-  \/\/ and without inlining.\n-\n-  \/\/ We approximate this mythical quantity by playing with averages,\n-  \/\/ rough estimates, and assumptions that history repeats itself.\n-  \/\/ The basic formula count * profit is heuristically adjusted\n-  \/\/ by looking at the expected compilation and execution times of\n-  \/\/ of the inlined call.\n-\n-  \/\/ Note:  Some of these metrics may not be present in the final product,\n-  \/\/ but exist in development builds to experiment with inline policy tuning.\n-\n-  \/\/ This heuristic framework does not model well the very significant\n-  \/\/ effects of multiple-level inlining.  It is possible to see no immediate\n-  \/\/ profit from inlining X->Y, but to get great profit from a subsequent\n-  \/\/ inlining X->Y->Z.\n-\n-  \/\/ This framework does not take well into account the problem of N**2 code\n-  \/\/ size in a clique of mutually inlinable methods.\n-\n-  WarmCallInfo*  next() const          { return _next; }\n-  void       set_next(WarmCallInfo* n) { _next = n; }\n-\n-  static WarmCallInfo _always_hot;\n-  static WarmCallInfo _always_cold;\n-\n-  \/\/ Constructor intitialization of always_hot and always_cold\n-  WarmCallInfo(float c, float p, float w, float s) {\n-    _call = NULL;\n-    _hot_cg = NULL;\n-    _next = NULL;\n-    _count = c;\n-    _profit = p;\n-    _work = w;\n-    _size = s;\n-    _heat = 0;\n-  }\n-\n- public:\n-  \/\/ Because WarmInfo objects live over the entire lifetime of the\n-  \/\/ Compile object, they are allocated into the comp_arena, which\n-  \/\/ does not get resource marked or reset during the compile process\n-  void *operator new( size_t x, Compile* C ) throw() { return C->comp_arena()->Amalloc(x); }\n-  void operator delete( void * ) { } \/\/ fast deallocation\n-\n-  static WarmCallInfo* always_hot();\n-  static WarmCallInfo* always_cold();\n-\n-  WarmCallInfo() {\n-    _call = NULL;\n-    _hot_cg = NULL;\n-    _next = NULL;\n-    _count = _profit = _work = _size = _heat = 0;\n-  }\n-\n-  CallNode* call() const { return _call; }\n-  float count()    const { return _count; }\n-  float size()     const { return _size; }\n-  float work()     const { return _work; }\n-  float profit()   const { return _profit; }\n-  float heat()     const { return _heat; }\n-\n-  void set_count(float x)     { _count = x; }\n-  void set_size(float x)      { _size = x; }\n-  void set_work(float x)      { _work = x; }\n-  void set_profit(float x)    { _profit = x; }\n-  void set_heat(float x)      { _heat = x; }\n-\n-  \/\/ Load initial heuristics from profiles, etc.\n-  \/\/ The heuristics can be tweaked further by the caller.\n-  void init(JVMState* call_site, ciMethod* call_method, ciCallProfile& profile, float prof_factor);\n-\n-  static float MAX_VALUE() { return +1.0e10; }\n-  static float MIN_VALUE() { return -1.0e10; }\n-\n-  float compute_heat() const;\n-\n-  void set_call(CallNode* call)      { _call = call; }\n-  void set_hot_cg(CallGenerator* cg) { _hot_cg = cg; }\n-\n-  \/\/ Do not queue very hot or very cold calls.\n-  \/\/ Make very cold ones out of line immediately.\n-  \/\/ Inline very hot ones immediately.\n-  \/\/ These queries apply various tunable limits\n-  \/\/ to the above metrics in a systematic way.\n-  \/\/ Test for coldness before testing for hotness.\n-  bool is_cold() const;\n-  bool is_hot() const;\n-\n-  \/\/ Force a warm call to be hot.  This worklists the call node for inlining.\n-  void make_hot();\n-\n-  \/\/ Force a warm call to be cold.  This worklists the call node for out-of-lining.\n-  void make_cold();\n-\n-  \/\/ A reproducible total ordering, in which heat is the major key.\n-  bool warmer_than(WarmCallInfo* that);\n-\n-  \/\/ List management.  These methods are called with the list head,\n-  \/\/ and return the new list head, inserting or removing the receiver.\n-  WarmCallInfo* insert_into(WarmCallInfo* head);\n-  WarmCallInfo* remove_from(WarmCallInfo* head);\n-\n-#ifndef PRODUCT\n-  void print() const;\n-  void print_all() const;\n-  int count_all() const;\n-#endif\n-};\n-\n","filename":"src\/hotspot\/share\/opto\/callGenerator.hpp","additions":0,"deletions":160,"binary":false,"changes":160,"status":"modified"},{"patch":"@@ -578,1 +578,0 @@\n-                  _warm_calls(NULL),\n@@ -751,8 +750,0 @@\n-  for (;;) {\n-    int successes = Inline_Warm();\n-    if (failing())  return;\n-    if (successes == 0)  break;\n-  }\n-\n-  \/\/ Drain the list.\n-  Finish_Warm();\n@@ -879,1 +870,0 @@\n-    _warm_calls(NULL),\n@@ -1755,51 +1745,0 @@\n-\n-\n-\/\/---------------------------pop_warm_call-------------------------------------\n-WarmCallInfo* Compile::pop_warm_call() {\n-  WarmCallInfo* wci = _warm_calls;\n-  if (wci != NULL)  _warm_calls = wci->remove_from(wci);\n-  return wci;\n-}\n-\n-\/\/----------------------------Inline_Warm--------------------------------------\n-int Compile::Inline_Warm() {\n-  \/\/ If there is room, try to inline some more warm call sites.\n-  \/\/ %%% Do a graph index compaction pass when we think we're out of space?\n-  if (!InlineWarmCalls)  return 0;\n-\n-  int calls_made_hot = 0;\n-  int room_to_grow   = NodeCountInliningCutoff - unique();\n-  int amount_to_grow = MIN2(room_to_grow, (int)NodeCountInliningStep);\n-  int amount_grown   = 0;\n-  WarmCallInfo* call;\n-  while (amount_to_grow > 0 && (call = pop_warm_call()) != NULL) {\n-    int est_size = (int)call->size();\n-    if (est_size > (room_to_grow - amount_grown)) {\n-      \/\/ This one won't fit anyway.  Get rid of it.\n-      call->make_cold();\n-      continue;\n-    }\n-    call->make_hot();\n-    calls_made_hot++;\n-    amount_grown   += est_size;\n-    amount_to_grow -= est_size;\n-  }\n-\n-  if (calls_made_hot > 0)  set_major_progress();\n-  return calls_made_hot;\n-}\n-\n-\n-\/\/----------------------------Finish_Warm--------------------------------------\n-void Compile::Finish_Warm() {\n-  if (!InlineWarmCalls)  return;\n-  if (failing())  return;\n-  if (warm_calls() == NULL)  return;\n-\n-  \/\/ Clean up loose ends, if we are out of space for inlining.\n-  WarmCallInfo* call;\n-  while ((call = pop_warm_call()) != NULL) {\n-    call->make_cold();\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":0,"deletions":61,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -91,1 +91,0 @@\n-class WarmCallInfo;\n@@ -381,1 +380,0 @@\n-  WarmCallInfo*         _warm_calls;            \/\/ Sorted work-list for heat-based inlining.\n@@ -930,4 +928,0 @@\n-  WarmCallInfo*     warm_calls() const          { return _warm_calls; }\n-  void          set_warm_calls(WarmCallInfo* l) { _warm_calls = l; }\n-  WarmCallInfo* pop_warm_call();\n-\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -172,1 +172,0 @@\n-      WarmCallInfo scratch_ci;\n@@ -174,6 +173,1 @@\n-      WarmCallInfo* ci = ilt->ok_to_inline(callee, jvms, profile, &scratch_ci, should_delay);\n-      assert(ci != &scratch_ci, \"do not let this pointer escape\");\n-      bool allow_inline   = (ci != NULL && !ci->is_cold());\n-      bool require_inline = (allow_inline && ci->is_hot());\n-\n-      if (allow_inline) {\n+      if (ilt->ok_to_inline(callee, jvms, profile, should_delay)) {\n@@ -181,2 +175,1 @@\n-\n-        if (require_inline && cg != NULL) {\n+        if (cg != NULL) {\n@@ -194,0 +187,2 @@\n+          } else {\n+            return cg;\n@@ -196,8 +191,0 @@\n-        if (cg == NULL || should_delay) {\n-          \/\/ Fall through.\n-        } else if (require_inline || !InlineWarmCalls) {\n-          return cg;\n-        } else {\n-          CallGenerator* cold_cg = call_generator(callee, vtable_index, call_does_dispatch, jvms, false, prof_factor);\n-          return CallGenerator::for_warm_call(ci, cold_cg, cg);\n-        }\n","filename":"src\/hotspot\/share\/opto\/doCall.cpp","additions":4,"deletions":17,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -74,1 +74,0 @@\n-                            WarmCallInfo* wci_result,\n@@ -79,2 +78,1 @@\n-                            ciCallProfile& profile,\n-                            WarmCallInfo* wci_result);\n+                            ciCallProfile& profile);\n@@ -83,2 +81,1 @@\n-                                JVMState* jvms,\n-                                WarmCallInfo* wci_result);\n+                                JVMState* jvms);\n@@ -115,1 +112,1 @@\n-  WarmCallInfo* ok_to_inline(ciMethod *call_method, JVMState* caller_jvms, ciCallProfile& profile, WarmCallInfo* wci, bool& should_delay);\n+  bool ok_to_inline(ciMethod *call_method, JVMState* caller_jvms, ciCallProfile& profile, bool& should_delay);\n","filename":"src\/hotspot\/share\/opto\/parse.hpp","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"}]}