{"files":[{"patch":"@@ -344,0 +344,36 @@\n+static bool resolve_inlining_predicate(enum CompileCommand option, const methodHandle& method) {\n+  assert(option == CompileCommand::Inline || option == CompileCommand::DontInline, \"Sanity\");\n+  bool v1 = false;\n+  bool v2 = false;\n+  bool has_inline = CompilerOracle::has_option_value(method, CompileCommand::Inline, v1);\n+  bool has_dnotinline = CompilerOracle::has_option_value(method, CompileCommand::DontInline, v2);\n+  if (has_inline && has_dnotinline) {\n+    if (v1 && v2) {\n+      \/\/ Conflict options detected\n+      \/\/ Find the last one for that method and return the predicate accordingly\n+      enum CompileCommand last_one = CompileCommand::Unknown;\n+      TypedMethodOptionMatcher* current = option_list;\n+      while (current != NULL) {\n+        last_one = current->option();\n+        if (last_one == CompileCommand::Inline || last_one == CompileCommand::DontInline) {\n+          if (current->matches(method)) {\n+            return last_one == option;\n+          }\n+        }\n+        current = current->next();\n+      }\n+      ShouldNotReachHere();\n+      return false;\n+    } else {\n+      \/\/ No conflicts\n+      return option == CompileCommand::Inline ? v1 : v2;\n+    }\n+  } else {\n+    if (option == CompileCommand::Inline) {\n+      return has_inline ? v1 : false;\n+    } else {\n+      return has_dnotinline ? v2 : false;\n+    }\n+  }\n+}\n+\n@@ -345,0 +381,5 @@\n+  \/\/ Special handling for Inline and DontInline since conflict options may be specified\n+  if (option == CompileCommand::Inline || option == CompileCommand::DontInline) {\n+    return resolve_inlining_predicate(option, method);\n+  }\n+\n@@ -398,1 +439,1 @@\n-  return (check_predicate(CompileCommand::Inline, method) && !check_predicate(CompileCommand::DontInline, method));\n+  return (check_predicate(CompileCommand::Inline, method));\n@@ -402,2 +443,1 @@\n-  return (check_predicate(CompileCommand::DontInline, method) && !check_predicate(CompileCommand::Inline, method))\n-         || check_predicate(CompileCommand::Exclude, method);\n+  return check_predicate(CompileCommand::DontInline, method) || check_predicate(CompileCommand::Exclude, method);\n","filename":"src\/hotspot\/share\/compiler\/compilerOracle.cpp","additions":43,"deletions":3,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @summary Inlining decisions shouldn't be conflict by the C1\/C2 with the same CompileCommand\n+ * @summary the last specified inlining option should overwrite all previous\n@@ -30,0 +30,1 @@\n+ * @requires vm.compiler1.enabled | vm.compiler2.enabled\n@@ -50,0 +51,2 @@\n+        analyzer.shouldContain(\"disallowed by CompileCommand\");\n+        analyzer.shouldNotContain(\"force inline by CompileCommand\");\n@@ -51,4 +54,11 @@\n-        if (analyzer.getStdout().contains(\"disallowed by CompileCommand\") &&\n-            analyzer.getStdout().contains(\"force inline by CompileCommand\")) {\n-            throw new RuntimeException(\"Conflict inlining decisions detected:\\n\" + analyzer.getStdout());\n-        }\n+        pb = ProcessTools.createJavaProcessBuilder(\n+                \"-XX:CompileCommand=dontinline,*TestConflictInlineCommands::*caller\",\n+                \"-XX:CompileCommand=inline,*TestConflictInlineCommands::caller\",\n+                \"-XX:CompileCommand=quiet\", \"-XX:CompileCommand=compileonly,*Launcher::main\",\n+                \"-XX:+PrintCompilation\", \"-XX:+UnlockDiagnosticVMOptions\", \"-XX:+PrintInlining\",\n+                Launcher.class.getName());\n+\n+        analyzer = new OutputAnalyzer(pb.start());\n+        analyzer.shouldHaveExitValue(0);\n+        analyzer.shouldContain(\"force inline by CompileCommand\");\n+        analyzer.shouldNotContain(\"disallowed by CompileCommand\");\n","filename":"test\/hotspot\/jtreg\/compiler\/compilercontrol\/TestConflictInlineCommands.java","additions":15,"deletions":5,"binary":false,"changes":20,"status":"modified"}]}