{"files":[{"patch":"@@ -723,7 +723,7 @@\n-            switch (chronoUnit) {\n-                case NANOS: return plusNanos(amountToAdd);\n-                case MICROS: return plusSeconds((amountToAdd \/ (1000_000L * 1000)) * 1000).plusNanos((amountToAdd % (1000_000L * 1000)) * 1000);\n-                case MILLIS: return plusMillis(amountToAdd);\n-                case SECONDS: return plusSeconds(amountToAdd);\n-            }\n-            return plusSeconds(Math.multiplyExact(unit.getDuration().seconds, amountToAdd));\n+            return switch (chronoUnit) {\n+                case NANOS   -> plusNanos(amountToAdd);\n+                case MICROS  -> plusSeconds((amountToAdd \/ (1000_000L * 1000)) * 1000).plusNanos((amountToAdd % (1000_000L * 1000)) * 1000);\n+                case MILLIS  -> plusMillis(amountToAdd);\n+                case SECONDS -> plusSeconds(amountToAdd);\n+                default -> plusSeconds(Math.multiplyExact(unit.getDuration().seconds, amountToAdd));\n+            };\n","filename":"src\/java.base\/share\/classes\/java\/time\/Duration.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -607,8 +607,8 @@\n-                switch (chronoField) {\n-                    case DAY_OF_MONTH: return ValueRange.of(1, lengthOfMonth());\n-                    case DAY_OF_YEAR: return ValueRange.of(1, lengthOfYear());\n-                    case ALIGNED_WEEK_OF_MONTH: return ValueRange.of(1, getMonth() == Month.FEBRUARY && isLeapYear() == false ? 4 : 5);\n-                    case YEAR_OF_ERA:\n-                        return (getYear() <= 0 ? ValueRange.of(1, Year.MAX_VALUE + 1) : ValueRange.of(1, Year.MAX_VALUE));\n-                }\n-                return field.range();\n+                int n = switch (chronoField) {\n+                    case DAY_OF_MONTH -> lengthOfMonth();\n+                    case DAY_OF_YEAR -> lengthOfYear();\n+                    case ALIGNED_WEEK_OF_MONTH -> getMonth() == Month.FEBRUARY && !isLeapYear() ? 4 : 5;\n+                    case YEAR_OF_ERA -> Year.MAX_VALUE + (getYear() <= 0 ?  1 : 0);\n+                    default -> -1;\n+                };\n+                return (n == -1) ? field.range() : ValueRange.of(1, n);\n@@ -869,11 +869,5 @@\n-        switch (month) {\n-            case 2:\n-                return (isLeapYear() ? 29 : 28);\n-            case 4:\n-            case 6:\n-            case 9:\n-            case 11:\n-                return 30;\n-            default:\n-                return 31;\n-        }\n+        return switch (month) {\n+            case 2 -> (isLeapYear() ? 29 : 28);\n+            case 4, 6, 9, 11 -> 30;\n+            default -> 31;\n+        };\n","filename":"src\/java.base\/share\/classes\/java\/time\/LocalDate.java","additions":13,"deletions":19,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -1180,10 +1180,10 @@\n-            switch (chronoUnit) {\n-                case NANOS: return plusNanos(amountToAdd);\n-                case MICROS: return plusDays(amountToAdd \/ MICROS_PER_DAY).plusNanos((amountToAdd % MICROS_PER_DAY) * 1000);\n-                case MILLIS: return plusDays(amountToAdd \/ MILLIS_PER_DAY).plusNanos((amountToAdd % MILLIS_PER_DAY) * 1000_000);\n-                case SECONDS: return plusSeconds(amountToAdd);\n-                case MINUTES: return plusMinutes(amountToAdd);\n-                case HOURS: return plusHours(amountToAdd);\n-                case HALF_DAYS: return plusDays(amountToAdd \/ 256).plusHours((amountToAdd % 256) * 12);  \/\/ no overflow (256 is multiple of 2)\n-            }\n-            return with(date.plus(amountToAdd, unit), time);\n+            return switch (chronoUnit) {\n+                case NANOS     -> plusNanos(amountToAdd);\n+                case MICROS    -> plusDays(amountToAdd \/ MICROS_PER_DAY).plusNanos((amountToAdd % MICROS_PER_DAY) * 1000);\n+                case MILLIS    -> plusDays(amountToAdd \/ MILLIS_PER_DAY).plusNanos((amountToAdd % MILLIS_PER_DAY) * 1000_000);\n+                case SECONDS   -> plusSeconds(amountToAdd);\n+                case MINUTES   -> plusMinutes(amountToAdd);\n+                case HOURS     -> plusHours(amountToAdd);\n+                case HALF_DAYS -> plusDays(amountToAdd \/ 256).plusHours((amountToAdd % 256) * 12); \/\/ no overflow (256 is multiple of 2)\n+                default -> with(date.plus(amountToAdd, unit), time);\n+            };\n","filename":"src\/java.base\/share\/classes\/java\/time\/LocalDateTime.java","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -426,11 +426,5 @@\n-        switch (this) {\n-            case FEBRUARY:\n-                return (leapYear ? 29 : 28);\n-            case APRIL:\n-            case JUNE:\n-            case SEPTEMBER:\n-            case NOVEMBER:\n-                return 30;\n-            default:\n-                return 31;\n-        }\n+        return switch (this) {\n+            case FEBRUARY -> (leapYear ? 29 : 28);\n+            case APRIL, JUNE, SEPTEMBER, NOVEMBER -> 30;\n+            default -> 31;\n+        };\n@@ -449,11 +443,5 @@\n-        switch (this) {\n-            case FEBRUARY:\n-                return 28;\n-            case APRIL:\n-            case JUNE:\n-            case SEPTEMBER:\n-            case NOVEMBER:\n-                return 30;\n-            default:\n-                return 31;\n-        }\n+        return switch (this) {\n+            case FEBRUARY -> 28;\n+            case APRIL, JUNE, SEPTEMBER, NOVEMBER -> 30;\n+            default -> 31;\n+        };\n@@ -472,11 +460,5 @@\n-        switch (this) {\n-            case FEBRUARY:\n-                return 29;\n-            case APRIL:\n-            case JUNE:\n-            case SEPTEMBER:\n-            case NOVEMBER:\n-                return 30;\n-            default:\n-                return 31;\n-        }\n+        return switch (this) {\n+            case FEBRUARY -> 29;\n+            case APRIL, JUNE, SEPTEMBER, NOVEMBER -> 30;\n+            default -> 31;\n+        };\n@@ -497,27 +479,15 @@\n-        switch (this) {\n-            case JANUARY:\n-                return 1;\n-            case FEBRUARY:\n-                return 32;\n-            case MARCH:\n-                return 60 + leap;\n-            case APRIL:\n-                return 91 + leap;\n-            case MAY:\n-                return 121 + leap;\n-            case JUNE:\n-                return 152 + leap;\n-            case JULY:\n-                return 182 + leap;\n-            case AUGUST:\n-                return 213 + leap;\n-            case SEPTEMBER:\n-                return 244 + leap;\n-            case OCTOBER:\n-                return 274 + leap;\n-            case NOVEMBER:\n-                return 305 + leap;\n-            case DECEMBER:\n-            default:\n-                return 335 + leap;\n-        }\n+        return switch (this) {\n+            case JANUARY   -> 1;\n+            case FEBRUARY  -> 32;\n+            case MARCH     -> 60 + leap;\n+            case APRIL     -> 91 + leap;\n+            case MAY       -> 121 + leap;\n+            case JUNE      -> 152 + leap;\n+            case JULY      -> 182 + leap;\n+            case AUGUST    -> 213 + leap;\n+            case SEPTEMBER -> 244 + leap;\n+            case OCTOBER   -> 274 + leap;\n+            case NOVEMBER  -> 305 + leap;\n+            \/\/ otherwise (DECEMBER)\n+            default -> 335 + leap;\n+        };\n","filename":"src\/java.base\/share\/classes\/java\/time\/Month.java","additions":30,"deletions":60,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -600,7 +600,6 @@\n-            switch (chronoField) {\n-                case INSTANT_SECONDS:\n-                    throw new UnsupportedTemporalTypeException(\"Invalid field 'InstantSeconds' for get() method, use getLong() instead\");\n-                case OFFSET_SECONDS:\n-                    return getOffset().getTotalSeconds();\n-            }\n-            return dateTime.get(field);\n+            return switch (chronoField) {\n+                case INSTANT_SECONDS -> throw new UnsupportedTemporalTypeException(\"Invalid field \" +\n+                                         \"'InstantSeconds' for get() method, use getLong() instead\");\n+                case OFFSET_SECONDS  -> getOffset().getTotalSeconds();\n+                default -> dateTime.get(field);\n+            };\n@@ -637,5 +636,5 @@\n-            switch (chronoField) {\n-                case INSTANT_SECONDS: return toEpochSecond();\n-                case OFFSET_SECONDS: return getOffset().getTotalSeconds();\n-            }\n-            return dateTime.getLong(field);\n+            return switch (chronoField) {\n+                case INSTANT_SECONDS -> toEpochSecond();\n+                case OFFSET_SECONDS  -> getOffset().getTotalSeconds();\n+                default -> dateTime.getLong(field);\n+            };\n","filename":"src\/java.base\/share\/classes\/java\/time\/OffsetDateTime.java","additions":11,"deletions":12,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -273,18 +273,17 @@\n-        switch (type) {\n-            case DURATION_TYPE: return Duration.readExternal(in);\n-            case INSTANT_TYPE: return Instant.readExternal(in);\n-            case LOCAL_DATE_TYPE: return LocalDate.readExternal(in);\n-            case LOCAL_DATE_TIME_TYPE: return LocalDateTime.readExternal(in);\n-            case LOCAL_TIME_TYPE: return LocalTime.readExternal(in);\n-            case ZONE_DATE_TIME_TYPE: return ZonedDateTime.readExternal(in);\n-            case ZONE_OFFSET_TYPE: return ZoneOffset.readExternal(in);\n-            case ZONE_REGION_TYPE: return ZoneRegion.readExternal(in);\n-            case OFFSET_TIME_TYPE: return OffsetTime.readExternal(in);\n-            case OFFSET_DATE_TIME_TYPE: return OffsetDateTime.readExternal(in);\n-            case YEAR_TYPE: return Year.readExternal(in);\n-            case YEAR_MONTH_TYPE: return YearMonth.readExternal(in);\n-            case MONTH_DAY_TYPE: return MonthDay.readExternal(in);\n-            case PERIOD_TYPE: return Period.readExternal(in);\n-            default:\n-                throw new StreamCorruptedException(\"Unknown serialized type\");\n-        }\n+        return switch (type) {\n+            case DURATION_TYPE         -> Duration.readExternal(in);\n+            case INSTANT_TYPE          -> Instant.readExternal(in);\n+            case LOCAL_DATE_TYPE       -> LocalDate.readExternal(in);\n+            case LOCAL_DATE_TIME_TYPE  -> LocalDateTime.readExternal(in);\n+            case LOCAL_TIME_TYPE       -> LocalTime.readExternal(in);\n+            case ZONE_DATE_TIME_TYPE   -> ZonedDateTime.readExternal(in);\n+            case ZONE_OFFSET_TYPE      -> ZoneOffset.readExternal(in);\n+            case ZONE_REGION_TYPE      -> ZoneRegion.readExternal(in);\n+            case OFFSET_TIME_TYPE      -> OffsetTime.readExternal(in);\n+            case OFFSET_DATE_TIME_TYPE -> OffsetDateTime.readExternal(in);\n+            case YEAR_TYPE             -> Year.readExternal(in);\n+            case YEAR_MONTH_TYPE       -> YearMonth.readExternal(in);\n+            case MONTH_DAY_TYPE        -> MonthDay.readExternal(in);\n+            case PERIOD_TYPE           -> Period.readExternal(in);\n+            default -> throw new StreamCorruptedException(\"Unknown serialized type\");\n+        };\n","filename":"src\/java.base\/share\/classes\/java\/time\/Ser.java","additions":17,"deletions":18,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -817,7 +817,6 @@\n-            switch (chronoField) {\n-                case INSTANT_SECONDS:\n-                    throw new UnsupportedTemporalTypeException(\"Invalid field 'InstantSeconds' for get() method, use getLong() instead\");\n-                case OFFSET_SECONDS:\n-                    return getOffset().getTotalSeconds();\n-            }\n-            return dateTime.get(field);\n+            return switch (chronoField) {\n+                case INSTANT_SECONDS -> throw new UnsupportedTemporalTypeException(\"Invalid field \" +\n+                                         \"'InstantSeconds' for get() method, use getLong() instead\");\n+                case OFFSET_SECONDS  -> getOffset().getTotalSeconds();\n+                default -> dateTime.get(field);\n+            };\n@@ -854,5 +853,5 @@\n-            switch (chronoField) {\n-                case INSTANT_SECONDS: return toEpochSecond();\n-                case OFFSET_SECONDS: return getOffset().getTotalSeconds();\n-            }\n-            return dateTime.getLong(field);\n+            return switch (chronoField) {\n+                case INSTANT_SECONDS -> toEpochSecond();\n+                case OFFSET_SECONDS  -> getOffset().getTotalSeconds();\n+                default -> dateTime.getLong(field);\n+            };\n","filename":"src\/java.base\/share\/classes\/java\/time\/ZonedDateTime.java","additions":11,"deletions":12,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -302,10 +302,10 @@\n-            switch (chronoUnit) {\n-                case NANOS: return plusNanos(amountToAdd);\n-                case MICROS: return plusDays(amountToAdd \/ MICROS_PER_DAY).plusNanos((amountToAdd % MICROS_PER_DAY) * 1000);\n-                case MILLIS: return plusDays(amountToAdd \/ MILLIS_PER_DAY).plusNanos((amountToAdd % MILLIS_PER_DAY) * 1000000);\n-                case SECONDS: return plusSeconds(amountToAdd);\n-                case MINUTES: return plusMinutes(amountToAdd);\n-                case HOURS: return plusHours(amountToAdd);\n-                case HALF_DAYS: return plusDays(amountToAdd \/ 256).plusHours((amountToAdd % 256) * 12);  \/\/ no overflow (256 is multiple of 2)\n-            }\n-            return with(date.plus(amountToAdd, unit), time);\n+            return switch (chronoUnit) {\n+                case NANOS     -> plusNanos(amountToAdd);\n+                case MICROS    -> plusDays(amountToAdd \/ MICROS_PER_DAY).plusNanos((amountToAdd % MICROS_PER_DAY) * 1000);\n+                case MILLIS    -> plusDays(amountToAdd \/ MILLIS_PER_DAY).plusNanos((amountToAdd % MILLIS_PER_DAY) * 1000000);\n+                case SECONDS   -> plusSeconds(amountToAdd);\n+                case MINUTES   -> plusMinutes(amountToAdd);\n+                case HOURS     -> plusHours(amountToAdd);\n+                case HALF_DAYS -> plusDays(amountToAdd \/ 256).plusHours((amountToAdd % 256) * 12); \/\/ no overflow (256 is multiple of 2)\n+                default -> with(date.plus(amountToAdd, unit), time);\n+            };\n","filename":"src\/java.base\/share\/classes\/java\/time\/chrono\/ChronoLocalDateTimeImpl.java","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -213,5 +213,5 @@\n-            switch (chronoField) {\n-                case INSTANT_SECONDS: return toEpochSecond();\n-                case OFFSET_SECONDS: return getOffset().getTotalSeconds();\n-            }\n-            return toLocalDateTime().getLong(field);\n+            return switch (chronoField) {\n+                case INSTANT_SECONDS -> toEpochSecond();\n+                case OFFSET_SECONDS  -> getOffset().getTotalSeconds();\n+                default -> toLocalDateTime().getLong(field);\n+            };\n","filename":"src\/java.base\/share\/classes\/java\/time\/chrono\/ChronoZonedDateTime.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -539,15 +539,8 @@\n-            switch (f) {\n-                case DAY_OF_MONTH:\n-                    return ValueRange.of(1, 1, getMinimumMonthLength(), getMaximumMonthLength());\n-                case DAY_OF_YEAR:\n-                    return ValueRange.of(1, getMaximumDayOfYear());\n-                case ALIGNED_WEEK_OF_MONTH:\n-                    return ValueRange.of(1, 5);\n-                case YEAR:\n-                case YEAR_OF_ERA:\n-                    return ValueRange.of(getMinimumYear(), getMaximumYear());\n-                case ERA:\n-                    return ValueRange.of(1, 1);\n-                default:\n-                    return field.range();\n-            }\n+            return switch (f) {\n+                case DAY_OF_MONTH -> ValueRange.of(1, 1, getMinimumMonthLength(), getMaximumMonthLength());\n+                case DAY_OF_YEAR -> ValueRange.of(1, getMaximumDayOfYear());\n+                case ALIGNED_WEEK_OF_MONTH -> ValueRange.of(1, 5);\n+                case YEAR, YEAR_OF_ERA -> ValueRange.of(getMinimumYear(), getMaximumYear());\n+                case ERA -> ValueRange.of(1, 1);\n+                default -> field.range();\n+            };\n","filename":"src\/java.base\/share\/classes\/java\/time\/chrono\/HijrahChronology.java","additions":8,"deletions":15,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -354,4 +354,4 @@\n-                switch (f) {\n-                    case DAY_OF_MONTH: return ValueRange.of(1, lengthOfMonth());\n-                    case DAY_OF_YEAR: return ValueRange.of(1, lengthOfYear());\n-                    case ALIGNED_WEEK_OF_MONTH: return ValueRange.of(1, 5);  \/\/ TODO\n+                return switch (f) {\n+                    case DAY_OF_MONTH          -> ValueRange.of(1, lengthOfMonth());\n+                    case DAY_OF_YEAR           -> ValueRange.of(1, lengthOfYear());\n+                    case ALIGNED_WEEK_OF_MONTH -> ValueRange.of(1, 5); \/\/ TODO\n@@ -360,2 +360,2 @@\n-                }\n-                return getChronology().range(f);\n+                    default -> getChronology().range(f);\n+                };\n@@ -371,16 +371,16 @@\n-            switch ((ChronoField) field) {\n-                case DAY_OF_WEEK: return getDayOfWeek();\n-                case ALIGNED_DAY_OF_WEEK_IN_MONTH: return ((dayOfMonth - 1) % 7) + 1;\n-                case ALIGNED_DAY_OF_WEEK_IN_YEAR: return ((getDayOfYear() - 1) % 7) + 1;\n-                case DAY_OF_MONTH: return this.dayOfMonth;\n-                case DAY_OF_YEAR: return this.getDayOfYear();\n-                case EPOCH_DAY: return toEpochDay();\n-                case ALIGNED_WEEK_OF_MONTH: return ((dayOfMonth - 1) \/ 7) + 1;\n-                case ALIGNED_WEEK_OF_YEAR: return ((getDayOfYear() - 1) \/ 7) + 1;\n-                case MONTH_OF_YEAR: return monthOfYear;\n-                case PROLEPTIC_MONTH: return getProlepticMonth();\n-                case YEAR_OF_ERA: return prolepticYear;\n-                case YEAR: return prolepticYear;\n-                case ERA: return getEraValue();\n-            }\n-            throw new UnsupportedTemporalTypeException(\"Unsupported field: \" + field);\n+            return switch ((ChronoField) field) {\n+                case DAY_OF_WEEK                  ->  getDayOfWeek();\n+                case ALIGNED_DAY_OF_WEEK_IN_MONTH ->  ((dayOfMonth - 1) % 7) + 1;\n+                case ALIGNED_DAY_OF_WEEK_IN_YEAR  ->  ((getDayOfYear() - 1) % 7) + 1;\n+                case DAY_OF_MONTH                 ->  this.dayOfMonth;\n+                case DAY_OF_YEAR                  ->  this.getDayOfYear();\n+                case EPOCH_DAY                    ->  toEpochDay();\n+                case ALIGNED_WEEK_OF_MONTH        ->  ((dayOfMonth - 1) \/ 7) + 1;\n+                case ALIGNED_WEEK_OF_YEAR         ->  ((getDayOfYear() - 1) \/ 7) + 1;\n+                case MONTH_OF_YEAR                ->  monthOfYear;\n+                case PROLEPTIC_MONTH              ->  getProlepticMonth();\n+                case YEAR_OF_ERA                  ->  prolepticYear;\n+                case YEAR                         ->  prolepticYear;\n+                case ERA                          ->  getEraValue();\n+                default -> throw new UnsupportedTemporalTypeException(\"Unsupported field: \" + field);\n+            };\n@@ -401,16 +401,16 @@\n-            switch (chronoField) {\n-                case DAY_OF_WEEK: return plusDays(newValue - getDayOfWeek());\n-                case ALIGNED_DAY_OF_WEEK_IN_MONTH: return plusDays(newValue - getLong(ALIGNED_DAY_OF_WEEK_IN_MONTH));\n-                case ALIGNED_DAY_OF_WEEK_IN_YEAR: return plusDays(newValue - getLong(ALIGNED_DAY_OF_WEEK_IN_YEAR));\n-                case DAY_OF_MONTH: return resolvePreviousValid(prolepticYear, monthOfYear, nvalue);\n-                case DAY_OF_YEAR: return plusDays(Math.min(nvalue, lengthOfYear()) - getDayOfYear());\n-                case EPOCH_DAY: return new HijrahDate(chrono, newValue);\n-                case ALIGNED_WEEK_OF_MONTH: return plusDays((newValue - getLong(ALIGNED_WEEK_OF_MONTH)) * 7);\n-                case ALIGNED_WEEK_OF_YEAR: return plusDays((newValue - getLong(ALIGNED_WEEK_OF_YEAR)) * 7);\n-                case MONTH_OF_YEAR: return resolvePreviousValid(prolepticYear, nvalue, dayOfMonth);\n-                case PROLEPTIC_MONTH: return plusMonths(newValue - getProlepticMonth());\n-                case YEAR_OF_ERA: return resolvePreviousValid(prolepticYear >= 1 ? nvalue : 1 - nvalue, monthOfYear, dayOfMonth);\n-                case YEAR: return resolvePreviousValid(nvalue, monthOfYear, dayOfMonth);\n-                case ERA: return resolvePreviousValid(1 - prolepticYear, monthOfYear, dayOfMonth);\n-            }\n-            throw new UnsupportedTemporalTypeException(\"Unsupported field: \" + field);\n+            return switch (chronoField) {\n+                case DAY_OF_WEEK                  ->  plusDays(newValue - getDayOfWeek());\n+                case ALIGNED_DAY_OF_WEEK_IN_MONTH ->  plusDays(newValue - getLong(ALIGNED_DAY_OF_WEEK_IN_MONTH));\n+                case ALIGNED_DAY_OF_WEEK_IN_YEAR  ->  plusDays(newValue - getLong(ALIGNED_DAY_OF_WEEK_IN_YEAR));\n+                case DAY_OF_MONTH                 ->  resolvePreviousValid(prolepticYear, monthOfYear, nvalue);\n+                case DAY_OF_YEAR                  ->  plusDays(Math.min(nvalue, lengthOfYear()) - getDayOfYear());\n+                case EPOCH_DAY                    ->  new HijrahDate(chrono, newValue);\n+                case ALIGNED_WEEK_OF_MONTH        ->  plusDays((newValue - getLong(ALIGNED_WEEK_OF_MONTH)) * 7);\n+                case ALIGNED_WEEK_OF_YEAR         ->  plusDays((newValue - getLong(ALIGNED_WEEK_OF_YEAR)) * 7);\n+                case MONTH_OF_YEAR                ->  resolvePreviousValid(prolepticYear, nvalue, dayOfMonth);\n+                case PROLEPTIC_MONTH              ->  plusMonths(newValue - getProlepticMonth());\n+                case YEAR_OF_ERA                  ->  resolvePreviousValid(prolepticYear >= 1 ? nvalue : 1 - nvalue, monthOfYear, dayOfMonth);\n+                case YEAR                         ->  resolvePreviousValid(nvalue, monthOfYear, dayOfMonth);\n+                case ERA                          ->  resolvePreviousValid(1 - prolepticYear, monthOfYear, dayOfMonth);\n+                default -> throw new UnsupportedTemporalTypeException(\"Unsupported field: \" + field);\n+            };\n","filename":"src\/java.base\/share\/classes\/java\/time\/chrono\/HijrahDate.java","additions":38,"deletions":38,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -131,8 +131,5 @@\n-        switch (isoEra) {\n-            case 0:\n-                return BCE;\n-            case 1:\n-                return CE;\n-            default:\n-                throw new DateTimeException(\"Invalid era: \" + isoEra);\n-        }\n+        return switch (isoEra) {\n+            case 0  -> BCE;\n+            case 1  -> CE;\n+            default -> throw new DateTimeException(\"Invalid era: \" + isoEra);\n+        };\n","filename":"src\/java.base\/share\/classes\/java\/time\/chrono\/IsoEra.java","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -315,2 +315,2 @@\n-        switch (field) {\n-            case PROLEPTIC_MONTH: {\n+        return switch (field) {\n+            case PROLEPTIC_MONTH -> {\n@@ -318,1 +318,1 @@\n-                return ValueRange.of(range.getMinimum() - YEARS_DIFFERENCE * 12L, range.getMaximum() - YEARS_DIFFERENCE * 12L);\n+                yield ValueRange.of(range.getMinimum() - YEARS_DIFFERENCE * 12L, range.getMaximum() - YEARS_DIFFERENCE * 12L);\n@@ -320,1 +320,1 @@\n-            case YEAR_OF_ERA: {\n+            case YEAR_OF_ERA -> {\n@@ -322,1 +322,1 @@\n-                return ValueRange.of(1, range.getMaximum() - YEARS_DIFFERENCE, -range.getMinimum() + 1 + YEARS_DIFFERENCE);\n+                yield ValueRange.of(1, range.getMaximum() - YEARS_DIFFERENCE, -range.getMinimum() + 1 + YEARS_DIFFERENCE);\n@@ -324,1 +324,1 @@\n-            case YEAR: {\n+            case YEAR -> {\n@@ -326,1 +326,1 @@\n-                return ValueRange.of(range.getMinimum() - YEARS_DIFFERENCE, range.getMaximum() - YEARS_DIFFERENCE);\n+                yield ValueRange.of(range.getMinimum() - YEARS_DIFFERENCE, range.getMaximum() - YEARS_DIFFERENCE);\n@@ -328,2 +328,2 @@\n-        }\n-        return field.range();\n+            default -> field.range();\n+        };\n","filename":"src\/java.base\/share\/classes\/java\/time\/chrono\/MinguoChronology.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -318,2 +318,2 @@\n-            switch (chronoField) {\n-                case PROLEPTIC_MONTH:\n+            return switch (chronoField) {\n+                case PROLEPTIC_MONTH -> {\n@@ -321,4 +321,3 @@\n-                    return plusMonths(newValue - getProlepticMonth());\n-                case YEAR_OF_ERA:\n-                case YEAR:\n-                case ERA: {\n+                    yield plusMonths(newValue - getProlepticMonth());\n+                }\n+                case YEAR_OF_ERA -> {\n@@ -326,8 +325,1 @@\n-                    switch (chronoField) {\n-                        case YEAR_OF_ERA:\n-                            return with(isoDate.withYear(getProlepticYear() >= 1 ? nvalue + YEARS_DIFFERENCE : (1 - nvalue)  + YEARS_DIFFERENCE));\n-                        case YEAR:\n-                            return with(isoDate.withYear(nvalue + YEARS_DIFFERENCE));\n-                        case ERA:\n-                            return with(isoDate.withYear((1 - getProlepticYear()) + YEARS_DIFFERENCE));\n-                    }\n+                    yield with(isoDate.withYear(getProlepticYear() >= 1 ? nvalue + YEARS_DIFFERENCE : (1 - nvalue) + YEARS_DIFFERENCE));\n@@ -335,2 +327,8 @@\n-            }\n-            return with(isoDate.with(field, newValue));\n+                case YEAR -> {\n+                    int nvalue = getChronology().range(chronoField).checkValidIntValue(newValue, chronoField);\n+                    yield with(isoDate.withYear(nvalue + YEARS_DIFFERENCE));\n+                }\n+                case ERA -> with(isoDate.withYear((1 - getProlepticYear()) + YEARS_DIFFERENCE));\n+\n+                default -> with(isoDate.with(field, newValue));\n+            };\n","filename":"src\/java.base\/share\/classes\/java\/time\/chrono\/MinguoDate.java","additions":14,"deletions":16,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -138,8 +138,5 @@\n-        switch (minguoEra) {\n-            case 0:\n-                return BEFORE_ROC;\n-            case 1:\n-                return ROC;\n-            default:\n-                throw new DateTimeException(\"Invalid era: \" + minguoEra);\n-        }\n+        return switch (minguoEra) {\n+            case 0  -> BEFORE_ROC;\n+            case 1  -> ROC;\n+            default -> throw new DateTimeException(\"Invalid era: \" + minguoEra);\n+        };\n","filename":"src\/java.base\/share\/classes\/java\/time\/chrono\/MinguoEra.java","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -248,12 +248,12 @@\n-        switch (type) {\n-            case CHRONO_TYPE: return (Serializable)AbstractChronology.readExternal(in);\n-            case CHRONO_LOCAL_DATE_TIME_TYPE: return (Serializable)ChronoLocalDateTimeImpl.readExternal(in);\n-            case CHRONO_ZONE_DATE_TIME_TYPE: return (Serializable)ChronoZonedDateTimeImpl.readExternal(in);\n-            case JAPANESE_DATE_TYPE:  return JapaneseDate.readExternal(in);\n-            case JAPANESE_ERA_TYPE: return JapaneseEra.readExternal(in);\n-            case HIJRAH_DATE_TYPE: return HijrahDate.readExternal(in);\n-            case MINGUO_DATE_TYPE: return MinguoDate.readExternal(in);\n-            case THAIBUDDHIST_DATE_TYPE: return ThaiBuddhistDate.readExternal(in);\n-            case CHRONO_PERIOD_TYPE: return ChronoPeriodImpl.readExternal(in);\n-            default: throw new StreamCorruptedException(\"Unknown serialized type\");\n-        }\n+        return switch (type) {\n+            case CHRONO_TYPE                 -> (Serializable) AbstractChronology.readExternal(in);\n+            case CHRONO_LOCAL_DATE_TIME_TYPE -> (Serializable) ChronoLocalDateTimeImpl.readExternal(in);\n+            case CHRONO_ZONE_DATE_TIME_TYPE  -> (Serializable) ChronoZonedDateTimeImpl.readExternal(in);\n+            case JAPANESE_DATE_TYPE          -> JapaneseDate.readExternal(in);\n+            case JAPANESE_ERA_TYPE           -> JapaneseEra.readExternal(in);\n+            case HIJRAH_DATE_TYPE            -> HijrahDate.readExternal(in);\n+            case MINGUO_DATE_TYPE            -> MinguoDate.readExternal(in);\n+            case THAIBUDDHIST_DATE_TYPE      -> ThaiBuddhistDate.readExternal(in);\n+            case CHRONO_PERIOD_TYPE          -> ChronoPeriodImpl.readExternal(in);\n+            default -> throw new StreamCorruptedException(\"Unknown serialized type\");\n+        };\n","filename":"src\/java.base\/share\/classes\/java\/time\/chrono\/Ser.java","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -351,2 +351,2 @@\n-        switch (field) {\n-            case PROLEPTIC_MONTH: {\n+        return switch (field) {\n+            case PROLEPTIC_MONTH -> {\n@@ -354,1 +354,1 @@\n-                return ValueRange.of(range.getMinimum() + YEARS_DIFFERENCE * 12L, range.getMaximum() + YEARS_DIFFERENCE * 12L);\n+                yield ValueRange.of(range.getMinimum() + YEARS_DIFFERENCE * 12L, range.getMaximum() + YEARS_DIFFERENCE * 12L);\n@@ -356,1 +356,1 @@\n-            case YEAR_OF_ERA: {\n+            case YEAR_OF_ERA -> {\n@@ -358,1 +358,1 @@\n-                return ValueRange.of(1, -(range.getMinimum() + YEARS_DIFFERENCE) + 1, range.getMaximum() + YEARS_DIFFERENCE);\n+                yield ValueRange.of(1, -(range.getMinimum() + YEARS_DIFFERENCE) + 1, range.getMaximum() + YEARS_DIFFERENCE);\n@@ -360,1 +360,1 @@\n-            case YEAR: {\n+            case YEAR -> {\n@@ -362,1 +362,1 @@\n-                return ValueRange.of(range.getMinimum() + YEARS_DIFFERENCE, range.getMaximum() + YEARS_DIFFERENCE);\n+                yield ValueRange.of(range.getMinimum() + YEARS_DIFFERENCE, range.getMaximum() + YEARS_DIFFERENCE);\n@@ -364,2 +364,2 @@\n-        }\n-        return field.range();\n+            default -> field.range();\n+        };\n","filename":"src\/java.base\/share\/classes\/java\/time\/chrono\/ThaiBuddhistChronology.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -138,8 +138,5 @@\n-        switch (thaiBuddhistEra) {\n-            case 0:\n-                return BEFORE_BE;\n-            case 1:\n-                return BE;\n-            default:\n-                throw new DateTimeException(\"Invalid era: \" + thaiBuddhistEra);\n-        }\n+        return switch (thaiBuddhistEra) {\n+            case 0  -> BEFORE_BE;\n+            case 1  -> BE;\n+            default -> throw new DateTimeException(\"Invalid era: \" + thaiBuddhistEra);\n+        };\n","filename":"src\/java.base\/share\/classes\/java\/time\/chrono\/ThaiBuddhistEra.java","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2549,4 +2549,4 @@\n-                case 0: context.setCaseSensitive(true); break;\n-                case 1: context.setCaseSensitive(false); break;\n-                case 2: context.setStrict(true); break;\n-                case 3: context.setStrict(false); break;\n+                case 0 -> context.setCaseSensitive(true);\n+                case 1 -> context.setCaseSensitive(false);\n+                case 2 -> context.setStrict(true);\n+                case 3 -> context.setStrict(false);\n@@ -2790,9 +2790,4 @@\n-                    case NORMAL:\n-                    case EXCEEDS_PAD:\n-                    case ALWAYS:\n-                        buf.append(decimalStyle.getNegativeSign());\n-                        break;\n-                    case NOT_NEGATIVE:\n-                        throw new DateTimeException(\"Field \" + field +\n-                            \" cannot be printed as the value \" + value +\n-                            \" cannot be negative according to the SignStyle\");\n+                    case NORMAL, EXCEEDS_PAD, ALWAYS -> buf.append(decimalStyle.getNegativeSign());\n+                    case NOT_NEGATIVE                -> throw new DateTimeException(\"Field \" + field +\n+                                                            \" cannot be printed as the value \" + value +\n+                                                            \" cannot be negative according to the SignStyle\");\n@@ -4131,7 +4126,5 @@\n-            switch (type) {\n-            case STD:\n-                return names[textStyle.zoneNameStyleIndex() + 1];\n-            case DST:\n-                return names[textStyle.zoneNameStyleIndex() + 3];\n-            }\n-            return names[textStyle.zoneNameStyleIndex() + 5];\n+            return switch (type) {\n+                case STD -> names[textStyle.zoneNameStyleIndex() + 1];\n+                case DST -> names[textStyle.zoneNameStyleIndex() + 3];\n+                default  -> names[textStyle.zoneNameStyleIndex() + 5];\n+            };\n","filename":"src\/java.base\/share\/classes\/java\/time\/format\/DateTimeFormatterBuilder.java","additions":13,"deletions":20,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -126,11 +126,5 @@\n-        switch (ordinal()) {\n-            case 0: \/\/ NORMAL\n-                \/\/ valid if negative or (positive and lenient)\n-                return !positive || !strict;\n-            case 1: \/\/ ALWAYS\n-            case 4: \/\/ EXCEEDS_PAD\n-                return true;\n-            default:\n-                \/\/ valid if lenient and not fixed width\n-                return !strict && !fixedWidth;\n-        }\n+        return switch (ordinal()) {\n+            case 0    -> !positive || !strict; \/\/ NORMAL - valid if negative or (positive and lenient)\n+            case 1, 4 -> true; \/\/ ALWAYS, EXCEEDS_PAD\n+            default   -> !strict && !fixedWidth; \/\/ valid if lenient and not fixed width\n+        };\n","filename":"src\/java.base\/share\/classes\/java\/time\/format\/SignStyle.java","additions":5,"deletions":11,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -706,10 +706,7 @@\n-            switch (this) {\n-                case WEEK_BASED_YEARS:\n-                    return (R) temporal.with(WEEK_BASED_YEAR,\n-                            Math.addExact(temporal.get(WEEK_BASED_YEAR), amount));\n-                case QUARTER_YEARS:\n-                    return (R) temporal.plus(amount \/ 4, YEARS)\n-                            .plus((amount % 4) * 3, MONTHS);\n-                default:\n-                    throw new IllegalStateException(\"Unreachable\");\n-            }\n+            return switch (this) {\n+                case WEEK_BASED_YEARS -> (R) temporal.with(WEEK_BASED_YEAR,\n+                                          Math.addExact(temporal.get(WEEK_BASED_YEAR), amount));\n+                case QUARTER_YEARS    -> (R) temporal.plus(amount \/ 4, YEARS)\n+                                          .plus((amount % 4) * 3, MONTHS);\n+                default -> throw new IllegalStateException(\"Unreachable\");\n+            };\n@@ -723,9 +720,6 @@\n-            switch(this) {\n-                case WEEK_BASED_YEARS:\n-                    return Math.subtractExact(temporal2Exclusive.getLong(WEEK_BASED_YEAR),\n-                            temporal1Inclusive.getLong(WEEK_BASED_YEAR));\n-                case QUARTER_YEARS:\n-                    return temporal1Inclusive.until(temporal2Exclusive, MONTHS) \/ 3;\n-                default:\n-                    throw new IllegalStateException(\"Unreachable\");\n-            }\n+            return switch (this) {\n+                case WEEK_BASED_YEARS -> Math.subtractExact(temporal2Exclusive.getLong(WEEK_BASED_YEAR),\n+                                          temporal1Inclusive.getLong(WEEK_BASED_YEAR));\n+                case QUARTER_YEARS    -> temporal1Inclusive.until(temporal2Exclusive, MONTHS) \/ 3;\n+                default -> throw new IllegalStateException(\"Unreachable\");\n+            };\n","filename":"src\/java.base\/share\/classes\/java\/time\/temporal\/IsoFields.java","additions":13,"deletions":19,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -194,10 +194,6 @@\n-        switch (type) {\n-            case ZRULES:\n-                return ZoneRules.readExternal(in);\n-            case ZOT:\n-                return ZoneOffsetTransition.readExternal(in);\n-            case ZOTRULE:\n-                return ZoneOffsetTransitionRule.readExternal(in);\n-            default:\n-                throw new StreamCorruptedException(\"Unknown serialized type\");\n-        }\n+        return switch (type) {\n+            case ZRULES  -> ZoneRules.readExternal(in);\n+            case ZOT     -> ZoneOffsetTransition.readExternal(in);\n+            case ZOTRULE -> ZoneOffsetTransitionRule.readExternal(in);\n+            default -> throw new StreamCorruptedException(\"Unknown serialized type\");\n+        };\n","filename":"src\/java.base\/share\/classes\/java\/time\/zone\/Ser.java","additions":6,"deletions":10,"binary":false,"changes":16,"status":"modified"}]}