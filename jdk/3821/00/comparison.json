{"files":[{"patch":"@@ -37,1 +37,0 @@\n-import java.util.Arrays;\n@@ -241,3 +240,3 @@\n-        for (Element m : getMethods(te)) {\n-            if (executableMembersEqual(method, (ExecutableElement) m)) {\n-                return (ExecutableElement) m;\n+        for (ExecutableElement m : getMethods(te)) {\n+            if (executableMembersEqual(method, m)) {\n+                return m;\n@@ -335,1 +334,0 @@\n-    @SuppressWarnings(\"preview\")\n@@ -451,1 +449,0 @@\n-    @SuppressWarnings(\"preview\")\n@@ -456,1 +453,0 @@\n-    @SuppressWarnings(\"preview\")\n@@ -575,1 +571,0 @@\n-            @SuppressWarnings(\"preview\")\n@@ -1601,1 +1596,1 @@\n-            for (Element te : classlist) {\n+            for (TypeElement te : classlist) {\n@@ -1603,1 +1598,1 @@\n-                    filteredOutClasses.add((TypeElement)te);\n+                    filteredOutClasses.add(te);\n@@ -1608,1 +1603,1 @@\n-        for (Element e : classlist) {\n+        for (TypeElement e : classlist) {\n@@ -1612,1 +1607,1 @@\n-            filteredOutClasses.add((TypeElement)e);\n+            filteredOutClasses.add(e);\n@@ -1792,1 +1787,1 @@\n-     * if the entity is not qualifiable then its enclosing entity, it is upto\n+     * if the entity is not qualifiable then its enclosing entity, it is up to\n@@ -1801,1 +1796,0 @@\n-    @SuppressWarnings(\"preview\")\n@@ -1827,0 +1821,6 @@\n+    \/**\n+     * Returns the recursively enclosed documented type elements in a package\n+     *\n+     * @param pkg the package\n+     * @return the elements\n+     *\/\n@@ -1828,6 +1828,1 @@\n-        List<TypeElement> out = getInterfaces(pkg);\n-        out.addAll(getClasses(pkg));\n-        out.addAll(getEnums(pkg));\n-        out.addAll(getAnnotationTypes(pkg));\n-        out.addAll(getRecords(pkg));\n-        return out;\n+        return getItems(pkg, false, this::isTypeElement, TypeElement.class);\n@@ -1837,5 +1832,0 @@\n-    public List<Element> getAnnotationMembers(TypeElement aClass) {\n-        List<Element> members = getAnnotationFields(aClass);\n-        members.addAll(getAnnotationMethods(aClass));\n-        return members;\n-    }\n@@ -1843,15 +1833,13 @@\n-    public List<Element> getAnnotationFields(TypeElement aClass) {\n-        return getItems0(aClass, true, FIELD);\n-    }\n-\n-    List<Element> getAnnotationFieldsUnfiltered(TypeElement aClass) {\n-        return getItems0(aClass, true, FIELD);\n-    }\n-\n-    public List<Element> getAnnotationMethods(TypeElement aClass) {\n-        return getItems0(aClass, true, METHOD);\n-    }\n-\n-    public List<TypeElement> getAnnotationTypes(Element e) {\n-        return convertToTypeElement(getItems(e, true, ANNOTATION_TYPE));\n-    }\n+    \/**\n+     * Returns the fields and methods declared in an annotation interface.\n+     *\n+     * @param te the annotation interface\n+     * @return the fields and methods\n+     *\/\n+    public List<Element> getAnnotationMembers(TypeElement te) {\n+        return getItems(te, false, e_ ->\n+                        switch (e_.getKind()) {\n+                            case FIELD, METHOD -> shouldDocument(e_);\n+                            default -> false;\n+                        },\n+                Element.class);\n@@ -1859,2 +1847,0 @@\n-    public List<TypeElement> getAnnotationTypesUnfiltered(Element e) {\n-        return convertToTypeElement(getItems(e, false, ANNOTATION_TYPE));\n@@ -1863,3 +1849,8 @@\n-    @SuppressWarnings(\"preview\")\n-    public List<TypeElement> getRecords(Element e) {\n-        return convertToTypeElement(getItems(e, true, RECORD));\n+    \/**\n+     * Returns the documented annotation interfaces in a package.\n+     *\n+     * @param pkg the package\n+     * @return the annotation interfaces\n+     *\/\n+    public List<TypeElement> getAnnotationTypes(PackageElement pkg) {\n+        return getDocumentedItems(pkg, ANNOTATION_TYPE, TypeElement.class);\n@@ -1868,3 +1859,8 @@\n-    @SuppressWarnings(\"preview\")\n-    public List<TypeElement> getRecordsUnfiltered(Element e) {\n-        return convertToTypeElement(getItems(e, false, RECORD));\n+    \/**\n+     * Returns the documented record classes in a package.\n+     *\n+     * @param pkg the package\n+     * @return the record classes\n+     *\/\n+    public List<TypeElement> getRecords(PackageElement pkg) {\n+        return getDocumentedItems(pkg, RECORD, TypeElement.class);\n@@ -1873,2 +1869,8 @@\n-    public List<VariableElement> getFields(Element e) {\n-        return convertToVariableElement(getItems(e, true, FIELD));\n+    \/**\n+     * Returns the documented fields in a type element.\n+     *\n+     * @param te the element\n+     * @return the fields\n+     *\/\n+    public List<VariableElement> getFields(TypeElement te) {\n+        return getDocumentedItems(te, FIELD, VariableElement.class);\n@@ -1877,2 +1879,8 @@\n-    public List<VariableElement> getFieldsUnfiltered(Element e) {\n-        return convertToVariableElement(getItems(e, false, FIELD));\n+    \/**\n+     * Returns the fields in a type element.\n+     *\n+     * @param te the element\n+     * @return the fields\n+     *\/\n+    public List<VariableElement> getFieldsUnfiltered(TypeElement te) {\n+        return getAllItems(te, FIELD, VariableElement.class);\n@@ -1881,0 +1889,7 @@\n+    \/**\n+     * Returns the documented classes in an element,\n+     * such as a package element or type element.\n+     *\n+     * @param e the element\n+     * @return the classes\n+     *\/\n@@ -1882,5 +1897,1 @@\n-       return convertToTypeElement(getItems(e, true, CLASS));\n-    }\n-\n-    public List<TypeElement> getClassesUnfiltered(Element e) {\n-       return convertToTypeElement(getItems(e, false, CLASS));\n+        return getDocumentedItems(e, CLASS, TypeElement.class);\n@@ -1889,2 +1900,8 @@\n-    public List<ExecutableElement> getConstructors(Element e) {\n-        return convertToExecutableElement(getItems(e, true, CONSTRUCTOR));\n+    \/**\n+     * Returns the documented constructors in a type element.\n+     *\n+     * @param te the type element\n+     * @return the constructors\n+     *\/\n+    public List<ExecutableElement> getConstructors(TypeElement te) {\n+        return getDocumentedItems(te, CONSTRUCTOR, ExecutableElement.class);\n@@ -1893,3 +1910,0 @@\n-    public List<ExecutableElement> getMethods(Element e) {\n-        return convertToExecutableElement(getItems(e, true, METHOD));\n-    }\n@@ -1897,2 +1911,8 @@\n-    List<ExecutableElement> getMethodsUnfiltered(Element e) {\n-        return convertToExecutableElement(getItems(e, false, METHOD));\n+    \/**\n+     * Returns the documented methods in a type element.\n+     *\n+     * @param te the type element\n+     * @return the methods\n+     *\/\n+    public List<ExecutableElement> getMethods(TypeElement te) {\n+        return getDocumentedItems(te, METHOD, ExecutableElement.class);\n@@ -1979,42 +1999,8 @@\n-    public List<ExecutableElement> convertToExecutableElement(List<Element> list) {\n-        List<ExecutableElement> out = new ArrayList<>(list.size());\n-        for (Element e : list) {\n-            out.add((ExecutableElement)e);\n-        }\n-        return out;\n-    }\n-\n-    public List<TypeElement> convertToTypeElement(List<Element> list) {\n-        List<TypeElement> out = new ArrayList<>(list.size());\n-        for (Element e : list) {\n-            out.add((TypeElement)e);\n-        }\n-        return out;\n-    }\n-\n-    public List<VariableElement> convertToVariableElement(List<Element> list) {\n-        List<VariableElement> out = new ArrayList<>(list.size());\n-        for (Element e : list) {\n-            out.add((VariableElement) e);\n-        }\n-        return out;\n-    }\n-\n-    public List<TypeElement> getInterfaces(Element e)  {\n-        return convertToTypeElement(getItems(e, true, INTERFACE));\n-    }\n-\n-    public List<TypeElement> getInterfacesUnfiltered(Element e)  {\n-        return convertToTypeElement(getItems(e, false, INTERFACE));\n-    }\n-\n-    public List<Element> getEnumConstants(Element e) {\n-        return getItems(e, true, ENUM_CONSTANT);\n-    }\n-\n-    public List<TypeElement> getEnums(Element e) {\n-        return convertToTypeElement(getItems(e, true, ENUM));\n-    }\n-\n-    public List<TypeElement> getEnumsUnfiltered(Element e) {\n-        return convertToTypeElement(getItems(e, false, ENUM));\n+    \/**\n+     * Returns the documented interfaces in a package.\n+     *\n+     * @param pkg the package\n+     * @return the interfaces\n+     *\/\n+    public List<TypeElement> getInterfaces(PackageElement pkg)  {\n+        return getDocumentedItems(pkg, INTERFACE, TypeElement.class);\n@@ -2023,8 +2009,8 @@\n-    public SortedSet<TypeElement> getAllClassesUnfiltered(Element e) {\n-        List<TypeElement> clist = getClassesUnfiltered(e);\n-        clist.addAll(getInterfacesUnfiltered(e));\n-        clist.addAll(getAnnotationTypesUnfiltered(e));\n-        clist.addAll(getRecordsUnfiltered(e));\n-        SortedSet<TypeElement> oset = new TreeSet<>(comparators.makeGeneralPurposeComparator());\n-        oset.addAll(clist);\n-        return oset;\n+    \/**\n+     * Returns the documented enum constants in a type element.\n+     *\n+     * @param te the element\n+     * @return the interfaces\n+     *\/\n+    public List<VariableElement> getEnumConstants(TypeElement te) {\n+        return getDocumentedItems(te, ENUM_CONSTANT, VariableElement.class);\n@@ -2033,1 +2019,0 @@\n-    private final HashMap<Element, SortedSet<TypeElement>> cachedClasses = new HashMap<>();\n@@ -2035,4 +2020,4 @@\n-     * Returns a list containing classes and interfaces,\n-     * including annotation types.\n-     * @param e Element\n-     * @return List\n+     * Returns the documented enum classes in a package.\n+     *\n+     * @param pkg the package\n+     * @return the interfaces\n@@ -2040,13 +2025,2 @@\n-    public SortedSet<TypeElement> getAllClasses(Element e) {\n-        SortedSet<TypeElement> oset = cachedClasses.get(e);\n-        if (oset != null)\n-            return oset;\n-        List<TypeElement> clist = getClasses(e);\n-        clist.addAll(getInterfaces(e));\n-        clist.addAll(getAnnotationTypes(e));\n-        clist.addAll(getEnums(e));\n-        clist.addAll(getRecords(e));\n-        oset = new TreeSet<>(comparators.makeGeneralPurposeComparator());\n-        oset.addAll(clist);\n-        cachedClasses.put(e, oset);\n-        return oset;\n+    public List<TypeElement> getEnums(PackageElement pkg) {\n+        return getDocumentedItems(pkg, ENUM, TypeElement.class);\n@@ -2055,3 +2029,5 @@\n-    \/*\n-     * Get all the elements unfiltered and filter them finally based\n-     * on its visibility, this works differently from the other getters.\n+    \/**\n+     * Returns all the classes in a package.\n+     *\n+     * @param pkg the package\n+     * @return the interfaces\n@@ -2059,23 +2035,4 @@\n-    private List<TypeElement> getInnerClasses(Element e, boolean filter) {\n-        List<TypeElement> olist = new ArrayList<>();\n-        for (TypeElement te : getClassesUnfiltered(e)) {\n-            if (!filter || configuration.docEnv.isSelected(te)) {\n-                olist.add(te);\n-            }\n-        }\n-        for (TypeElement te : getInterfacesUnfiltered(e)) {\n-            if (!filter || configuration.docEnv.isSelected(te)) {\n-                olist.add(te);\n-            }\n-        }\n-        for (TypeElement te : getAnnotationTypesUnfiltered(e)) {\n-            if (!filter || configuration.docEnv.isSelected(te)) {\n-                olist.add(te);\n-            }\n-        }\n-        for (TypeElement te : getEnumsUnfiltered(e)) {\n-            if (!filter || configuration.docEnv.isSelected(te)) {\n-                olist.add(te);\n-            }\n-        }\n-        return olist;\n+    public SortedSet<TypeElement> getAllClassesUnfiltered(PackageElement pkg) {\n+        SortedSet<TypeElement> set = new TreeSet<>(comparators.makeGeneralPurposeComparator());\n+        set.addAll(getItems(pkg, true, this::isTypeElement, TypeElement.class));\n+        return set;\n@@ -2084,3 +2041,1 @@\n-    public List<TypeElement> getInnerClasses(Element e) {\n-        return getInnerClasses(e, true);\n-    }\n+    private final HashMap<Element, SortedSet<TypeElement>> cachedClasses = new HashMap<>();\n@@ -2088,2 +2043,13 @@\n-    public List<TypeElement> getInnerClassesUnfiltered(Element e) {\n-        return getInnerClasses(e, false);\n+    \/**\n+     * Returns a sorted set containing the documented classes and interfaces in a package.\n+     *\n+     * @param pkg the element\n+     * @return the classes and interfaces\n+     *\/\n+    public SortedSet<TypeElement> getAllClasses(PackageElement pkg) {\n+        return cachedClasses.computeIfAbsent(pkg, p_ -> {\n+            List<TypeElement> clist = getItems(pkg, false, this::isTypeElement, TypeElement.class);\n+            SortedSet<TypeElement>oset = new TreeSet<>(comparators.makeGeneralPurposeComparator());\n+            oset.addAll(clist);\n+            return oset;\n+        });\n@@ -2117,15 +2083,14 @@\n-    @SuppressWarnings(\"preview\")\n-    List<Element> getItems(Element e, boolean filter, ElementKind select) {\n-        List<Element> elements = new ArrayList<>();\n-        return new SimpleElementVisitor14<List<Element>, Void>() {\n-\n-            @Override\n-            public List<Element> visitPackage(PackageElement e, Void p) {\n-                recursiveGetItems(elements, e, filter, select);\n-                return elements;\n-            }\n-\n-            @Override\n-            protected List<Element> defaultAction(Element e0, Void p) {\n-                return getItems0(e0, filter, select);\n-            }\n+    \/**\n+     * Returns a list of documented elements of a given type with a given kind.\n+     * If the root of the search is a package, the search is recursive.\n+     *\n+     * @param e      the element, such as a package element or type element\n+     * @param kind   the element kind\n+     * @param clazz  the class of the filtered members\n+     * @param <T>    the class of the filtered members\n+     *\n+     * @return the list of enclosed elements\n+     *\/\n+    private <T extends Element> List<T> getDocumentedItems(Element e, ElementKind kind, Class<T> clazz) {\n+        return getItems(e, false, e_ -> e_.getKind() == kind && shouldDocument(e_), clazz);\n+    }\n@@ -2133,1 +2098,13 @@\n-        }.visit(e);\n+    \/**\n+     * Returns a list of elements of a given type with a given kind.\n+     * If the root of the search is a package, the search is recursive.\n+     *\n+     * @param e      the element, such as a package element or type element\n+     * @param kind   the element kind\n+     * @param clazz  the class of the filtered members\n+     * @param <T>    the class of the filtered members\n+     *\n+     * @return the list of enclosed elements\n+     *\/\n+    private <T extends Element> List<T> getAllItems(Element e, ElementKind kind, Class<T> clazz) {\n+        return getItems(e, true, e_ -> e_.getKind() == kind, clazz);\n@@ -2136,9 +2113,19 @@\n-    Set<ElementKind> nestedKinds = EnumSet.of(ANNOTATION_TYPE, CLASS, ENUM, INTERFACE);\n-    void recursiveGetItems(Collection<Element> list, Element e, boolean filter, ElementKind... select) {\n-        list.addAll(getItems0(e, filter, select));\n-        List<Element> classes = getItems0(e, filter, nestedKinds);\n-        for (Element c : classes) {\n-            list.addAll(getItems0(c, filter, select));\n-            if (isTypeElement(c)) {\n-                recursiveGetItems(list, c, filter, select);\n-            }\n+    \/**\n+     * Returns a list of elements of a given type that match a predicate.\n+     * If the root of the search is a package, the search is recursive through documented packages\n+     * and classes.\n+     *\n+     * @param e      the element, such as a package element or type element\n+     * @param select the predicate to select members\n+     * @param clazz  the class of the filtered members\n+     * @param <T>    the class of the filtered members\n+     *\n+     * @return the list of enclosed elements\n+     *\/\n+    private <T extends Element> List<T> getItems(Element e, boolean all, Predicate<Element> select, Class<T> clazz) {\n+        if (e.getKind() == ElementKind.PACKAGE) {\n+            List<T> elements = new ArrayList<>();\n+            recursiveGetItems(elements, e, all, select, clazz);\n+            return elements;\n+        } else {\n+            return getItems0(e, all, select, clazz);\n@@ -2148,3 +2135,16 @@\n-    private List<Element> getItems0(Element te, boolean filter, ElementKind... select) {\n-        Set<ElementKind> kinds = EnumSet.copyOf(Arrays.asList(select));\n-        return getItems0(te, filter, kinds);\n+    \/**\n+     * Searches for a list of recursively enclosed elements of a given class that match a predicate.\n+     * The recursion is through nested types.\n+     *\n+     * @param e      the element, such as a package element or type element\n+     * @param filter the filter\n+     * @param clazz  the class of the filtered members\n+     * @param <T>    the class of the filtered members\n+     *\/\n+    private <T extends Element> void recursiveGetItems(Collection<T> list, Element e, boolean all, Predicate<Element> filter, Class<T> clazz) {\n+        list.addAll(getItems0(e, all, filter, clazz));\n+        List<TypeElement> classes = getItems0(e, all, this::isTypeElement, TypeElement.class);\n+        for (TypeElement c : classes) {\n+            list.addAll(getItems0(c, all, filter, clazz));\n+            recursiveGetItems(list, c, all, filter, clazz);\n+        }\n@@ -2153,10 +2153,15 @@\n-    private List<Element> getItems0(Element te, boolean filter, Set<ElementKind> kinds) {\n-        List<Element> elements = new ArrayList<>();\n-        for (Element e : te.getEnclosedElements()) {\n-            if (kinds.contains(e.getKind())) {\n-                if (!filter || shouldDocument(e)) {\n-                    elements.add(e);\n-                }\n-            }\n-        }\n-        return elements;\n+    \/**\n+     * Returns a list of immediately enclosed elements of a given class that match a predicate.\n+     *\n+     * @param e      the element, such as a package element or type element\n+     * @param select the predicate for the selected members\n+     * @param clazz  the class of the filtered members\n+     * @param <T>    the class of the filtered members\n+     *\n+     * @return the list of enclosed elements\n+     *\/\n+    private <T extends Element> List<T> getItems0(Element e, boolean all, Predicate<Element> select, Class<T> clazz) {\n+        return e.getEnclosedElements().stream()\n+                .filter(e_ -> select.test(e_) && (all || shouldDocument(e_)))\n+                .map(ee -> clazz.cast(ee))\n+                .toList();\n@@ -2165,1 +2170,0 @@\n-    @SuppressWarnings(\"preview\")\n@@ -2168,1 +2172,0 @@\n-    @SuppressWarnings(\"preview\")\n@@ -2221,1 +2224,0 @@\n-    @SuppressWarnings(\"preview\")\n@@ -2224,1 +2226,0 @@\n-    @SuppressWarnings(\"preview\")\n@@ -2227,1 +2228,1 @@\n-            snvisitor = new SimpleElementVisitor14<String, Void>() {\n+            snvisitor = new SimpleElementVisitor14<>() {\n@@ -2396,1 +2397,0 @@\n-    @SuppressWarnings(\"preview\")\n@@ -2398,1 +2398,0 @@\n-    @SuppressWarnings(\"preview\")\n@@ -2401,1 +2400,1 @@\n-            specifiedVisitor = new SimpleElementVisitor14<Boolean, Void>() {\n+            specifiedVisitor = new SimpleElementVisitor14<>() {\n@@ -2611,1 +2610,1 @@\n-                .map(t -> tClass.cast(t))\n+                .map(tClass::cast)\n@@ -3011,1 +3010,1 @@\n-        private DeclarationPreviewLanguageFeatures(List<String> features) {\n+        DeclarationPreviewLanguageFeatures(List<String> features) {\n@@ -3014,1 +3013,0 @@\n-\n@@ -3030,1 +3028,1 @@\n-                usedInDeclaration.addAll(types2Classes(te.getRecordComponents().stream().map(c -> c.asType()).toList())); \/\/TODO: annotations on record components???\n+                usedInDeclaration.addAll(types2Classes(te.getRecordComponents().stream().map(Element::asType).toList())); \/\/TODO: annotations on record components???\n@@ -3040,1 +3038,1 @@\n-                usedInDeclaration.addAll(types2Classes(ee.getParameters().stream().map(p -> p.asType()).toList()));\n+                usedInDeclaration.addAll(types2Classes(ee.getParameters().stream().map(VariableElement::asType).toList()));\n@@ -3228,1 +3226,1 @@\n-        PREVIEW;\n+        PREVIEW\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/Utils.java","additions":213,"deletions":215,"binary":false,"changes":428,"status":"modified"},{"patch":"@@ -0,0 +1,165 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug      8265042\n+ * @summary  javadoc HTML files not generated for types nested in records\n+ * @library  \/tools\/lib ..\/..\/lib\n+ * @modules jdk.javadoc\/jdk.javadoc.internal.tool\n+ * @build    toolbox.ToolBox javadoc.tester.*\n+ * @run main TestNestedClasses\n+ *\/\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.TreeSet;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import javax.lang.model.element.ElementKind;\n+\n+import javadoc.tester.JavadocTester;\n+import toolbox.ToolBox;\n+\n+public class TestNestedClasses extends JavadocTester {\n+    public static void main(String... args) throws Exception {\n+        TestNestedClasses tester = new TestNestedClasses();\n+        tester.runTests(m -> new Object[] { Path.of(m.getName()) });\n+        tester.runLater();\n+    }\n+\n+    public final ToolBox tb;\n+    public final Set<ElementKind> testedKinds = new TreeSet<>();\n+\n+\n+    public TestNestedClasses() {\n+        tb = new ToolBox();\n+    }\n+\n+    \/\/ This is testing the possibility that new kinds of class or interface may be added in future,\n+    \/\/ in which case, this test will fail until it is updated.\n+    public void runLater() throws Exception {\n+        Set<ElementKind> expectKinds = Arrays.stream(ElementKind.values())\n+                .filter(k -> k.isClass() || k.isInterface())\n+                .collect(Collectors.toCollection(TreeSet::new));\n+        if (!testedKinds.equals(expectKinds)) {\n+            out.println(\"Expected: \" + expectKinds);\n+            out.println(\"  Tested: \" + testedKinds);\n+            throw new Exception(\"tested element kinds do not match expected element kinds\");\n+        }\n+    }\n+\n+    @Test\n+    public void testClass(Path base) throws IOException {\n+        testedKinds.add(ElementKind.CLASS);\n+        test(base, \"C\", \"\"\"\n+                package p;\n+                public class C {\n+                    ##INSERT##\n+                    public void m() { }\n+                }\n+                \"\"\");\n+    }\n+\n+    @Test\n+    public void testEnumClass(Path base) throws IOException {\n+        testedKinds.add(ElementKind.ENUM);\n+        test(base, \"E\", \"\"\"\n+                package p;\n+                public enum E {\n+                    E1, E2, E3;\n+                    ##INSERT##\n+                    public void m() { }\n+                }\n+                \"\"\");\n+    }\n+\n+    @Test\n+    public void testRecordClass(Path base) throws IOException {\n+        testedKinds.add(ElementKind.RECORD);\n+        test(base, \"R\", \"\"\"\n+                package p;\n+                public record R(int x, int y) {\n+                    ##INSERT##\n+                    public void m() { }\n+                }\n+                \"\"\");\n+    }\n+\n+    @Test\n+    public void testInterface(Path base) throws IOException {\n+        testedKinds.add(ElementKind.INTERFACE);\n+        test(base, \"I\", \"\"\"\n+                package p;\n+                public interface I {\n+                    ##INSERT##\n+                    public void m();\n+                }\n+                \"\"\");\n+    }\n+\n+    @Test\n+    public void testAnnotationInterface(Path base) throws IOException {\n+        testedKinds.add(ElementKind.ANNOTATION_TYPE);\n+        test(base, \"A\", \"\"\"\n+                package p;\n+                public @interface A {\n+                ##INSERT##\n+                    public static final int a = 0;\n+                }\n+                \"\"\");\n+    }\n+\n+    void test(Path base, String name, String template) throws IOException {\n+        Path src = base.resolve(\"src\");\n+        String nested = \"\"\"\n+                public class NC { }\n+                public enum NE { NE1, NE2 }\n+                public record NR(float r, float theta) { }\n+                public interface NI { }\n+                public @interface NA { }\n+                public class ND { public class NE { } }\n+            \"\"\";\n+        tb.writeJavaFiles(src, template.replace(\"##INSERT##\", nested));\n+\n+        javadoc(\"-d\", base.resolve(\"out\").toString(),\n+                \"-sourcepath\", src.toString(),\n+                \"-Xdoclint:-missing\",\n+                \"p\");\n+        checkExit(Exit.OK);\n+\n+        List<String> nestedClasses = List.of(\"NC\", \"NE\", \"NR\", \"NI\", \"NA\", \"ND\", \"ND.NE\");\n+\n+        List<String> files = Stream.concat(\n+                List.of(name, \"package-summary\", \"package-tree\").stream()\n+                        .map(n -> String.format(\"p\/%s.html\", n)),\n+                nestedClasses.stream()\n+                        .map(n -> String.format(\"p\/%s.%s.html\", name, n))\n+                ).toList();\n+        checkFiles(true, files);\n+    }\n+}\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testNestedClasses\/TestNestedClasses.java","additions":165,"deletions":0,"binary":false,"changes":165,"status":"added"}]}