{"files":[{"patch":"@@ -1409,1 +1409,1 @@\n-      Node* base = new CheckCastPPNode(ctrl, orig_base, orig_base->bottom_type(), true);\n+      Node* base = new CheckCastPPNode(ctrl, orig_base, orig_base->bottom_type(), ConstraintCastNode::StrongDependency);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahSupport.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-  if (_carry_dependency) {\n+  if (_dependency != RegularDependency) {\n@@ -85,1 +85,1 @@\n-  return TypeNode::cmp(n) && ((ConstraintCastNode&)n)._carry_dependency == _carry_dependency;\n+  return TypeNode::cmp(n) && ((ConstraintCastNode&)n)._dependency == _dependency;\n@@ -92,1 +92,1 @@\n-Node* ConstraintCastNode::make_cast(int opcode, Node* c, Node *n, const Type *t, bool carry_dependency) {\n+Node* ConstraintCastNode::make_cast(int opcode, Node* c, Node *n, const Type *t, DependencyType dependency) {\n@@ -95,1 +95,1 @@\n-    Node* cast = new CastIINode(n, t, carry_dependency);\n+    Node* cast = new CastIINode(n, t, dependency);\n@@ -100,1 +100,1 @@\n-    Node* cast = new CastLLNode(n, t, carry_dependency);\n+    Node* cast = new CastLLNode(n, t, dependency);\n@@ -105,1 +105,1 @@\n-    Node* cast = new CastPPNode(n, t, carry_dependency);\n+    Node* cast = new CastPPNode(n, t, dependency);\n@@ -110,1 +110,1 @@\n-    Node* cast = new CastFFNode(n, t, carry_dependency);\n+    Node* cast = new CastFFNode(n, t, dependency);\n@@ -115,1 +115,1 @@\n-    Node* cast = new CastDDNode(n, t, carry_dependency);\n+    Node* cast = new CastDDNode(n, t, dependency);\n@@ -120,1 +120,1 @@\n-    Node* cast = new CastVVNode(n, t, carry_dependency);\n+    Node* cast = new CastVVNode(n, t, dependency);\n@@ -124,1 +124,1 @@\n-  case Op_CheckCastPP: return new CheckCastPPNode(c, n, t, carry_dependency);\n+  case Op_CheckCastPP: return new CheckCastPPNode(c, n, t, dependency);\n@@ -134,1 +134,1 @@\n-    return make_cast(Op_CastII, c, n, t, false);\n+    return make_cast(Op_CastII, c, n, t, RegularDependency);\n@@ -137,1 +137,1 @@\n-    return make_cast(Op_CastLL, c, n, t, false);\n+    return make_cast(Op_CastLL, c, n, t, RegularDependency);\n@@ -146,0 +146,3 @@\n+  if (_dependency == UnconditionalDependency) {\n+    return NULL;\n+  }\n@@ -186,2 +189,2 @@\n-  if (_carry_dependency) {\n-    st->print(\" carry dependency\");\n+  if (_dependency != RegularDependency) {\n+    st->print(\" %s dependency\", _dependency == StrongDependency ? \"strong\" : \"unconditional\");\n@@ -197,1 +200,1 @@\n-  if (_carry_dependency) {\n+  if (_dependency != RegularDependency) {\n@@ -258,2 +261,2 @@\n-static Node* find_or_make_CastII(PhaseIterGVN* igvn, Node* parent, Node* control, const TypeInt* type, bool carry_dependency) {\n-  Node* n = new CastIINode(parent, type, carry_dependency);\n+static Node* find_or_make_CastII(PhaseIterGVN* igvn, Node* parent, Node* control, const TypeInt* type, ConstraintCastNode::DependencyType dependency) {\n+  Node* n = new CastIINode(parent, type, dependency);\n@@ -292,2 +295,2 @@\n-    Node* cx = find_or_make_CastII(igvn, x, in(0), rx->is_int(), _carry_dependency);\n-    Node* cy = find_or_make_CastII(igvn, y, in(0), ry->is_int(), _carry_dependency);\n+    Node* cx = find_or_make_CastII(igvn, x, in(0), rx->is_int(), _dependency);\n+    Node* cy = find_or_make_CastII(igvn, y, in(0), ry->is_int(), _dependency);\n@@ -380,1 +383,1 @@\n-  if (_carry_dependency) {\n+  if (_dependency != RegularDependency) {\n@@ -576,1 +579,1 @@\n-Node* ConstraintCastNode::make_cast_for_type(Node* c, Node* in, const Type* type) {\n+Node* ConstraintCastNode::make_cast_for_type(Node* c, Node* in, const Type* type, DependencyType dependency) {\n@@ -579,1 +582,1 @@\n-    cast = make_cast(Op_CastII, c, in, type, true);\n+    cast = make_cast(Op_CastII, c, in, type, dependency);\n@@ -581,1 +584,1 @@\n-    cast = make_cast(Op_CastLL, c, in, type, true);\n+    cast = make_cast(Op_CastLL, c, in, type, dependency);\n@@ -583,1 +586,1 @@\n-    cast = make_cast(Op_CastFF, c, in, type, true);\n+    cast = make_cast(Op_CastFF, c, in, type, dependency);\n@@ -585,1 +588,1 @@\n-    cast = make_cast(Op_CastDD, c, in, type, true);\n+    cast = make_cast(Op_CastDD, c, in, type, dependency);\n@@ -587,1 +590,1 @@\n-    cast = make_cast(Op_CastVV, c, in, type, true);\n+    cast = make_cast(Op_CastVV, c, in, type, dependency);\n@@ -589,1 +592,1 @@\n-    cast = make_cast(Op_CastPP, c, in, type, true);\n+    cast = make_cast(Op_CastPP, c, in, type, dependency);\n","filename":"src\/hotspot\/share\/opto\/castnode.cpp","additions":30,"deletions":27,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -35,0 +35,7 @@\n+public:\n+  enum DependencyType {\n+    RegularDependency, \/\/ if cast doesn't improve input type, cast can be removed\n+    StrongDependency,  \/\/ leave cast in even if _type doesn't improve input type, can be replaced by stricter dominating cast if one exist\n+    UnconditionalDependency \/\/ leave cast in unconditionally\n+  };\n+\n@@ -36,2 +43,1 @@\n-  \/\/ Can this node be removed post CCP or does it carry a required dependency?\n-  const bool _carry_dependency;\n+  const DependencyType _dependency;\n@@ -42,2 +48,2 @@\n-  ConstraintCastNode(Node *n, const Type *t, bool carry_dependency)\n-    : TypeNode(t,2), _carry_dependency(carry_dependency) {\n+  ConstraintCastNode(Node *n, const Type *t, DependencyType dependency)\n+    : TypeNode(t,2), _dependency(dependency) {\n@@ -52,2 +58,2 @@\n-  virtual bool depends_only_on_test() const { return !_carry_dependency; }\n-  bool carry_dependency() const { return _carry_dependency; }\n+  virtual bool depends_only_on_test() const { return _dependency == RegularDependency; }\n+  bool carry_dependency() const { return _dependency != RegularDependency; }\n@@ -55,1 +61,1 @@\n-  static Node* make_cast(int opcode,  Node* c, Node *n, const Type *t, bool carry_dependency);\n+  static Node* make_cast(int opcode, Node* c, Node *n, const Type *t, DependencyType dependency);\n@@ -66,1 +72,1 @@\n-  static Node* make_cast_for_type(Node* c, Node* in, const Type* type);\n+  static Node* make_cast_for_type(Node* c, Node* in, const Type* type, DependencyType dependency);\n@@ -79,2 +85,2 @@\n-  CastIINode(Node* n, const Type* t, bool carry_dependency = false, bool range_check_dependency = false)\n-    : ConstraintCastNode(n, t, carry_dependency), _range_check_dependency(range_check_dependency) {\n+  CastIINode(Node* n, const Type* t, DependencyType dependency = RegularDependency, bool range_check_dependency = false)\n+    : ConstraintCastNode(n, t, dependency), _range_check_dependency(range_check_dependency) {\n@@ -83,2 +89,2 @@\n-  CastIINode(Node* ctrl, Node* n, const Type* t, bool carry_dependency = false, bool range_check_dependency = false)\n-    : ConstraintCastNode(n, t, carry_dependency), _range_check_dependency(range_check_dependency) {\n+  CastIINode(Node* ctrl, Node* n, const Type* t, DependencyType dependency = RegularDependency, bool range_check_dependency = false)\n+    : ConstraintCastNode(n, t, dependency), _range_check_dependency(range_check_dependency) {\n@@ -113,2 +119,2 @@\n-  CastLLNode(Node* ctrl, Node* n, const Type* t, bool carry_dependency = false)\n-    : ConstraintCastNode(n, t, carry_dependency) {\n+  CastLLNode(Node* ctrl, Node* n, const Type* t, DependencyType dependency = RegularDependency)\n+    : ConstraintCastNode(n, t, dependency) {\n@@ -118,2 +124,2 @@\n-  CastLLNode(Node* n, const Type* t, bool carry_dependency = false)\n-          : ConstraintCastNode(n, t, carry_dependency){\n+  CastLLNode(Node* n, const Type* t, DependencyType dependency = RegularDependency)\n+          : ConstraintCastNode(n, t, dependency){\n@@ -132,2 +138,2 @@\n-  CastFFNode(Node* n, const Type* t, bool carry_dependency = false)\n-          : ConstraintCastNode(n, t, carry_dependency){\n+  CastFFNode(Node* n, const Type* t, DependencyType dependency = RegularDependency)\n+          : ConstraintCastNode(n, t, dependency){\n@@ -142,2 +148,2 @@\n-  CastDDNode(Node* n, const Type* t, bool carry_dependency = false)\n-          : ConstraintCastNode(n, t, carry_dependency){\n+  CastDDNode(Node* n, const Type* t, DependencyType dependency = RegularDependency)\n+          : ConstraintCastNode(n, t, dependency){\n@@ -152,2 +158,2 @@\n-  CastVVNode(Node* n, const Type* t, bool carry_dependency = false)\n-          : ConstraintCastNode(n, t, carry_dependency){\n+  CastVVNode(Node* n, const Type* t, DependencyType dependency = RegularDependency)\n+          : ConstraintCastNode(n, t, dependency){\n@@ -165,2 +171,2 @@\n-  CastPPNode (Node *n, const Type *t, bool carry_dependency = false)\n-    : ConstraintCastNode(n, t, carry_dependency) {\n+  CastPPNode (Node *n, const Type *t, DependencyType dependency = RegularDependency)\n+    : ConstraintCastNode(n, t, dependency) {\n@@ -176,2 +182,2 @@\n-  CheckCastPPNode(Node *c, Node *n, const Type *t, bool carry_dependency = false)\n-    : ConstraintCastNode(n, t, carry_dependency) {\n+  CheckCastPPNode(Node *c, Node *n, const Type *t, DependencyType dependency = RegularDependency)\n+    : ConstraintCastNode(n, t, dependency) {\n","filename":"src\/hotspot\/share\/opto\/castnode.hpp","additions":32,"deletions":26,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -1978,1 +1978,1 @@\n-          cast = ConstraintCastNode::make_cast(Op_CastPP, r, uin, phi_type, true);\n+          cast = ConstraintCastNode::make_cast(Op_CastPP, r, uin, phi_type, ConstraintCastNode::StrongDependency);\n@@ -1988,1 +1988,1 @@\n-            cast = ConstraintCastNode::make_cast(Op_CastPP, r, uin, TypePtr::NOTNULL, true);\n+            cast = ConstraintCastNode::make_cast(Op_CastPP, r, uin, TypePtr::NOTNULL, ConstraintCastNode::StrongDependency);\n@@ -2000,1 +2000,1 @@\n-            cast = ConstraintCastNode::make_cast(Op_CheckCastPP, r, n, phi_type, true);\n+            cast = ConstraintCastNode::make_cast(Op_CheckCastPP, r, n, phi_type, ConstraintCastNode::StrongDependency);\n@@ -2003,1 +2003,1 @@\n-            cast = ConstraintCastNode::make_cast(Op_CastPP, r, uin, phi_type, true);\n+            cast = ConstraintCastNode::make_cast(Op_CastPP, r, uin, phi_type, ConstraintCastNode::StrongDependency);\n@@ -2007,1 +2007,1 @@\n-        cast = ConstraintCastNode::make_cast_for_type(r, uin, phi_type);\n+        cast = ConstraintCastNode::make_cast_for_type(r, uin, phi_type, ConstraintCastNode::StrongDependency);\n","filename":"src\/hotspot\/share\/opto\/cfgnode.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -4127,1 +4127,1 @@\n-    value = new CastIINode(value, itype, carry_dependency, true \/* range check dependency *\/);\n+    value = new CastIINode(value, itype, carry_dependency ? ConstraintCastNode::StrongDependency : ConstraintCastNode::RegularDependency, true \/* range check dependency *\/);\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1196,1 +1196,1 @@\n-  Node* castii = new CastIINode(incr, TypeInt::INT, true);\n+  Node* castii = new CastIINode(incr, TypeInt::INT, ConstraintCastNode::StrongDependency);\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1506,1 +1506,9 @@\n-          if (x->in(0) == NULL && !x->is_DecodeNarrowPtr()) {\n+          \/\/ Chain of AddP: (AddP base (AddP base )) must keep the same base after sinking so:\n+          \/\/ 1- We don't add a CastPP here when the first one is sunk so if the second one is not, their bases remain\n+          \/\/ the same.\n+          \/\/ (see 2- below)\n+          assert(!x->is_AddP() || !x->in(AddPNode::Address)->is_AddP() ||\n+                 x->in(AddPNode::Address)->in(AddPNode::Base) == x->in(AddPNode::Base) ||\n+                 !x->in(AddPNode::Address)->in(AddPNode::Base)->eqv_uncast(x->in(AddPNode::Base)), \"unexpected AddP shape\");\n+          if (x->in(0) == NULL && !x->is_DecodeNarrowPtr() &&\n+              !(x->is_AddP() && x->in(AddPNode::Address)->is_AddP() && x->in(AddPNode::Address)->in(AddPNode::Base) == x->in(AddPNode::Base))) {\n@@ -1514,1 +1522,1 @@\n-                cast = ConstraintCastNode::make_cast_for_type(x_ctrl, in, in_t);\n+                cast = ConstraintCastNode::make_cast_for_type(x_ctrl, in, in_t, ConstraintCastNode::UnconditionalDependency);\n@@ -1519,0 +1527,11 @@\n+                \/\/ Chain of AddP:\n+                \/\/ 2- A CastPP of the base is only added now that both AddP nodes are sunk\n+                if (x->is_AddP() && k == AddPNode::Base) {\n+                  for (DUIterator_Fast imax, i = x->fast_outs(imax); i < imax; i++) {\n+                    Node* u = x->fast_out(i);\n+                    if (u->is_AddP() && u->in(AddPNode::Base) == n->in(AddPNode::Base)) {\n+                      _igvn.replace_input_of(u, AddPNode::Base, cast);\n+                      assert(u->find_out_with(Op_AddP) == NULL, \"more than 2 chained AddP nodes?\");\n+                    }\n+                  }\n+                }\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":21,"deletions":2,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8267988\n+ * @summary C2: assert(!addp->is_AddP() || addp->in(AddPNode::Base)->is_top() || addp->in(AddPNode::Base) == n->in(AddPNode::Base)) failed: Base pointers must match (addp 1301)\n+ *\n+ * @run main\/othervm -Xcomp -XX:CompileOnly=TestAddPChainWithDifferentBase TestAddPChainWithDifferentBase\n+ *\n+ *\/\n+\n+public class TestAddPChainWithDifferentBase {\n+    static int x;\n+    static int iArrFld[] = new int[400];\n+\n+    public static void main(String[] strArr) {\n+        test();\n+    }\n+\n+    static void test() {\n+        int i6, i7 = 9, i8, i9 = 138;\n+\n+        for (i6 = 7; i6 > 1; i6 -= 3) {\n+            for (i8 = i6; i8 < 4; i8++) {\n+                try {\n+                    iArrFld[i8] = (52691 \/ i8);\n+                    i7 = (iArrFld[i8 + 1] % i9);\n+                    i7 = (412419036 \/ iArrFld[i8]);\n+                } catch (ArithmeticException a_e) {\n+                }\n+                i9 += 13;\n+            }\n+        }\n+        x = i7;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TestAddPChainWithDifferentBase.java","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"}]}