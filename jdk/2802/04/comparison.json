{"files":[{"patch":"@@ -549,1 +549,1 @@\n-void SystemDictionary::double_lock_wait(Thread* thread, Handle lockObject) {\n+void SystemDictionary::double_lock_wait(JavaThread* thread, Handle lockObject) {\n@@ -554,1 +554,1 @@\n-      = ObjectSynchronizer::current_thread_holds_lock(thread->as_Java_thread(), lockObject);\n+      = ObjectSynchronizer::current_thread_holds_lock(thread, lockObject);\n@@ -629,1 +629,1 @@\n-          double_lock_wait(THREAD, lockObject);\n+          double_lock_wait(THREAD->as_Java_thread(), lockObject);\n@@ -696,1 +696,1 @@\n-  ObjectLocker ol(lockObject, THREAD);\n+  ObjectLocker ol(lockObject, THREAD->as_Java_thread());\n@@ -780,1 +780,1 @@\n-              double_lock_wait(THREAD, lockObject);\n+              double_lock_wait(THREAD->as_Java_thread(), lockObject);\n@@ -1052,1 +1052,1 @@\n-  ObjectLocker ol(lockObject, THREAD);\n+  ObjectLocker ol(lockObject, THREAD->as_Java_thread());\n@@ -1343,1 +1343,1 @@\n-    ObjectLocker ol(lockObject, THREAD);\n+    ObjectLocker ol(lockObject, THREAD->as_Java_thread());\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -348,1 +348,1 @@\n-  static void double_lock_wait(Thread* thread, Handle lockObject);\n+  static void double_lock_wait(JavaThread* thread, Handle lockObject);\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -735,1 +735,1 @@\n-  ObjectSynchronizer::enter(h_obj, elem->lock(), CHECK);\n+  ObjectSynchronizer::enter(h_obj, elem->lock(), thread);\n@@ -755,1 +755,1 @@\n-  ObjectSynchronizer::exit(obj, elem->lock(), Thread::current());\n+  ObjectSynchronizer::exit(obj, elem->lock(), JavaThread::current());\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -142,1 +142,1 @@\n-  ObjectSynchronizer::jni_enter(h_obj, THREAD);\n+  ObjectSynchronizer::jni_enter(h_obj, THREAD->as_Java_thread());\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJavaSupport.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -261,1 +261,1 @@\n-  volatile_nonstatic_field(ObjectMonitor,      _succ,                                         Thread*)                               \\\n+  volatile_nonstatic_field(ObjectMonitor,      _succ,                                         JavaThread*)                           \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -377,1 +377,2 @@\n-  objArrayHandle resolved_references(Thread::current(), cpool->resolved_references());\n+  JavaThread* current = JavaThread::current();\n+  objArrayHandle resolved_references(current, cpool->resolved_references());\n@@ -383,1 +384,1 @@\n-  ObjectLocker ol(resolved_references, Thread::current());\n+  ObjectLocker ol(resolved_references, current);\n@@ -485,1 +486,2 @@\n-  objArrayHandle resolved_references(Thread::current(), cpool->resolved_references());\n+  JavaThread* current = THREAD->as_Java_thread();\n+  objArrayHandle resolved_references(current, cpool->resolved_references());\n@@ -488,1 +490,1 @@\n-  ObjectLocker ol(resolved_references, THREAD);\n+  ObjectLocker ol(resolved_references, current);\n","filename":"src\/hotspot\/share\/oops\/cpCache.cpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -810,1 +810,1 @@\n-  ObjectLocker ol(h_init_lock, THREAD);\n+  ObjectLocker ol(h_init_lock, THREAD->as_Java_thread());\n@@ -946,1 +946,1 @@\n-    ObjectLocker ol(h_init_lock, THREAD);\n+    ObjectLocker ol(h_init_lock, jt);\n@@ -1071,1 +1071,1 @@\n-    ObjectLocker ol(h_init_lock, THREAD);\n+    ObjectLocker ol(h_init_lock, jt);\n@@ -1214,1 +1214,1 @@\n-    ObjectLocker ol(h_init_lock, THREAD);\n+    ObjectLocker ol(h_init_lock, THREAD->as_Java_thread());\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2715,1 +2715,1 @@\n-  ObjectSynchronizer::jni_enter(obj, CHECK_(JNI_ERR));\n+  ObjectSynchronizer::jni_enter(obj, thread);\n","filename":"src\/hotspot\/share\/prims\/jni.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -696,1 +696,1 @@\n-    Thread* THREAD = Thread::current();\n+    JavaThread* THREAD = JavaThread::current();\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1082,3 +1082,2 @@\n-          Thread *t = mon->thread_of_waiter(waiter);\n-          if (t != NULL && t->is_Java_thread()) {\n-            JavaThread *wjava_thread = t->as_Java_thread();\n+          JavaThread *w = mon->thread_of_waiter(waiter);\n+          if (w != NULL) {\n@@ -1088,1 +1087,1 @@\n-            Handle th(current_thread, wjava_thread->threadObj());\n+            Handle th(current_thread, w->threadObj());\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.cpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -313,1 +313,1 @@\n-bool ObjectMonitor::enter(TRAPS) {\n+bool ObjectMonitor::enter(JavaThread* current) {\n@@ -316,1 +316,0 @@\n-  Thread * const Self = THREAD;\n@@ -318,1 +317,1 @@\n-  void* cur = try_set_owner_from(NULL, Self);\n+  void* cur = try_set_owner_from(NULL, current);\n@@ -324,1 +323,1 @@\n-  if (cur == Self) {\n+  if (cur == current) {\n@@ -330,1 +329,1 @@\n-  if (Self->is_lock_owned((address)cur)) {\n+  if (current->is_lock_owned((address)cur)) {\n@@ -333,1 +332,1 @@\n-    set_owner_from_BasicLock(cur, Self);  \/\/ Convert from BasicLock* to Thread*.\n+    set_owner_from_BasicLock(cur, current);  \/\/ Convert from BasicLock* to Thread*.\n@@ -338,2 +337,2 @@\n-  assert(Self->_Stalled == 0, \"invariant\");\n-  Self->_Stalled = intptr_t(this);\n+  assert(current->_Stalled == 0, \"invariant\");\n+  current->_Stalled = intptr_t(this);\n@@ -341,1 +340,1 @@\n-  \/\/ Try one round of spinning *before* enqueueing Self\n+  \/\/ Try one round of spinning *before* enqueueing current\n@@ -346,2 +345,2 @@\n-  if (TrySpin(Self) > 0) {\n-    assert(owner_raw() == Self, \"must be Self: owner=\" INTPTR_FORMAT, p2i(owner_raw()));\n+  if (TrySpin(current) > 0) {\n+    assert(owner_raw() == current, \"must be current: owner=\" INTPTR_FORMAT, p2i(owner_raw()));\n@@ -353,1 +352,1 @@\n-    Self->_Stalled = 0;\n+    current->_Stalled = 0;\n@@ -357,3 +356,2 @@\n-  assert(owner_raw() != Self, \"invariant\");\n-  assert(_succ != Self, \"invariant\");\n-  JavaThread * jt = Self->as_Java_thread();\n+  assert(owner_raw() != current, \"invariant\");\n+  assert(_succ != current, \"invariant\");\n@@ -361,1 +359,1 @@\n-  assert(jt->thread_state() != _thread_blocked, \"invariant\");\n+  assert(current->thread_state() != _thread_blocked, \"invariant\");\n@@ -375,1 +373,1 @@\n-    Self->_Stalled = 0;\n+    current->_Stalled = 0;\n@@ -380,1 +378,1 @@\n-  JFR_ONLY(JfrConditionalFlushWithStacktrace<EventJavaMonitorEnter> flush(jt);)\n+  JFR_ONLY(JfrConditionalFlushWithStacktrace<EventJavaMonitorEnter> flush(current);)\n@@ -391,1 +389,1 @@\n-    JavaThreadBlockedOnMonitorEnterState jtbmes(jt, this);\n+    JavaThreadBlockedOnMonitorEnterState jtbmes(current, this);\n@@ -393,1 +391,1 @@\n-    Self->set_current_pending_monitor(this);\n+    current->set_current_pending_monitor(this);\n@@ -395,1 +393,1 @@\n-    DTRACE_MONITOR_PROBE(contended__enter, this, object(), jt);\n+    DTRACE_MONITOR_PROBE(contended__enter, this, object(), current);\n@@ -397,1 +395,1 @@\n-      JvmtiExport::post_monitor_contended_enter(jt, this);\n+      JvmtiExport::post_monitor_contended_enter(current, this);\n@@ -406,2 +404,2 @@\n-    OSThreadContendState osts(Self->osthread());\n-    ThreadBlockInVM tbivm(jt);\n+    OSThreadContendState osts(current->osthread());\n+    ThreadBlockInVM tbivm(current);\n@@ -411,1 +409,1 @@\n-      jt->set_suspend_equivalent();\n+      current->set_suspend_equivalent();\n@@ -415,1 +413,1 @@\n-      EnterI(THREAD);\n+      EnterI(current);\n@@ -417,1 +415,1 @@\n-      if (!ExitSuspendEquivalent(jt)) break;\n+      if (!current->handle_special_suspend_equivalent_condition()) break;\n@@ -426,1 +424,1 @@\n-      exit(false, Self);\n+      exit(false, current);\n@@ -428,1 +426,1 @@\n-      jt->java_suspend_self();\n+      current->java_suspend_self();\n@@ -430,1 +428,1 @@\n-    Self->set_current_pending_monitor(NULL);\n+    current->set_current_pending_monitor(NULL);\n@@ -444,1 +442,1 @@\n-  Self->_Stalled = 0;\n+  current->_Stalled = 0;\n@@ -448,2 +446,2 @@\n-  assert(owner_raw() == Self, \"invariant\");\n-  assert(_succ != Self, \"invariant\");\n+  assert(owner_raw() == current, \"invariant\");\n+  assert(_succ != current, \"invariant\");\n@@ -464,1 +462,1 @@\n-  DTRACE_MONITOR_PROBE(contended__entered, this, object(), jt);\n+  DTRACE_MONITOR_PROBE(contended__entered, this, object(), current);\n@@ -466,1 +464,1 @@\n-    JvmtiExport::post_monitor_contended_entered(jt, this);\n+    JvmtiExport::post_monitor_contended_entered(current, this);\n@@ -485,1 +483,1 @@\n-int ObjectMonitor::TryLock(Thread * Self) {\n+int ObjectMonitor::TryLock(JavaThread* current) {\n@@ -488,1 +486,1 @@\n-  if (try_set_owner_from(NULL, Self) == NULL) {\n+  if (try_set_owner_from(NULL, current) == NULL) {\n@@ -680,3 +678,2 @@\n-void ObjectMonitor::EnterI(TRAPS) {\n-  Thread * const Self = THREAD;\n-  assert(Self->as_Java_thread()->thread_state() == _thread_blocked, \"invariant\");\n+void ObjectMonitor::EnterI(JavaThread* current) {\n+  assert(current->thread_state() == _thread_blocked, \"invariant\");\n@@ -685,4 +682,4 @@\n-  if (TryLock (Self) > 0) {\n-    assert(_succ != Self, \"invariant\");\n-    assert(owner_raw() == Self, \"invariant\");\n-    assert(_Responsible != Self, \"invariant\");\n+  if (TryLock (current) > 0) {\n+    assert(_succ != current, \"invariant\");\n+    assert(owner_raw() == current, \"invariant\");\n+    assert(_Responsible != current, \"invariant\");\n@@ -692,1 +689,1 @@\n-  if (try_set_owner_from(DEFLATER_MARKER, Self) == DEFLATER_MARKER) {\n+  if (try_set_owner_from(DEFLATER_MARKER, current) == DEFLATER_MARKER) {\n@@ -694,1 +691,1 @@\n-    \/\/ DEFLATER_MARKER to Self. As part of the contended enter protocol,\n+    \/\/ DEFLATER_MARKER to current. As part of the contended enter protocol,\n@@ -705,2 +702,2 @@\n-    assert(_succ != Self, \"invariant\");\n-    assert(_Responsible != Self, \"invariant\");\n+    assert(_succ != current, \"invariant\");\n+    assert(_Responsible != current, \"invariant\");\n@@ -712,1 +709,1 @@\n-  \/\/ We try one round of spinning *before* enqueueing Self.\n+  \/\/ We try one round of spinning *before* enqueueing current.\n@@ -719,4 +716,4 @@\n-  if (TrySpin(Self) > 0) {\n-    assert(owner_raw() == Self, \"invariant\");\n-    assert(_succ != Self, \"invariant\");\n-    assert(_Responsible != Self, \"invariant\");\n+  if (TrySpin(current) > 0) {\n+    assert(owner_raw() == current, \"invariant\");\n+    assert(_succ != current, \"invariant\");\n+    assert(_Responsible != current, \"invariant\");\n@@ -727,3 +724,3 @@\n-  assert(_succ != Self, \"invariant\");\n-  assert(owner_raw() != Self, \"invariant\");\n-  assert(_Responsible != Self, \"invariant\");\n+  assert(_succ != current, \"invariant\");\n+  assert(owner_raw() != current, \"invariant\");\n+  assert(_Responsible != current, \"invariant\");\n@@ -731,1 +728,1 @@\n-  \/\/ Enqueue \"Self\" on ObjectMonitor's _cxq.\n+  \/\/ Enqueue \"current\" on ObjectMonitor's _cxq.\n@@ -733,1 +730,1 @@\n-  \/\/ Node acts as a proxy for Self.\n+  \/\/ Node acts as a proxy for current.\n@@ -740,3 +737,3 @@\n-  ObjectWaiter node(Self);\n-  Self->_ParkEvent->reset();\n-  node._prev   = (ObjectWaiter *) 0xBAD;\n+  ObjectWaiter node(current);\n+  current->_ParkEvent->reset();\n+  node._prev   = (ObjectWaiter*) 0xBAD;\n@@ -745,2 +742,2 @@\n-  \/\/ Push \"Self\" onto the front of the _cxq.\n-  \/\/ Once on cxq\/EntryList, Self stays on-queue until it acquires the lock.\n+  \/\/ Push \"current\" onto the front of the _cxq.\n+  \/\/ Once on cxq\/EntryList, current stays on-queue until it acquires the lock.\n@@ -749,1 +746,1 @@\n-  ObjectWaiter * nxt;\n+  ObjectWaiter* nxt;\n@@ -756,4 +753,4 @@\n-    if (TryLock (Self) > 0) {\n-      assert(_succ != Self, \"invariant\");\n-      assert(owner_raw() == Self, \"invariant\");\n-      assert(_Responsible != Self, \"invariant\");\n+    if (TryLock (current) > 0) {\n+      assert(_succ != current, \"invariant\");\n+      assert(owner_raw() == current, \"invariant\");\n+      assert(_Responsible != current, \"invariant\");\n@@ -789,2 +786,2 @@\n-    \/\/ CONSIDER:  ST vs CAS vs { if (Responsible==null) Responsible=Self }\n-    Atomic::replace_if_null(&_Responsible, Self);\n+    \/\/ CONSIDER:  ST vs CAS vs { if (Responsible==null) Responsible=current }\n+    Atomic::replace_if_null(&_Responsible, current);\n@@ -809,2 +806,2 @@\n-    if (TryLock(Self) > 0) break;\n-    assert(owner_raw() != Self, \"invariant\");\n+    if (TryLock(current) > 0) break;\n+    assert(owner_raw() != current, \"invariant\");\n@@ -813,2 +810,2 @@\n-    if (_Responsible == Self) {\n-      Self->_ParkEvent->park((jlong) recheckInterval);\n+    if (_Responsible == current) {\n+      current->_ParkEvent->park((jlong) recheckInterval);\n@@ -821,1 +818,1 @@\n-      Self->_ParkEvent->park();\n+      current->_ParkEvent->park();\n@@ -824,1 +821,1 @@\n-    if (TryLock(Self) > 0) break;\n+    if (TryLock(current) > 0) break;\n@@ -826,1 +823,1 @@\n-    if (try_set_owner_from(DEFLATER_MARKER, Self) == DEFLATER_MARKER) {\n+    if (try_set_owner_from(DEFLATER_MARKER, current) == DEFLATER_MARKER) {\n@@ -828,1 +825,1 @@\n-      \/\/ DEFLATER_MARKER to Self. As part of the contended enter protocol,\n+      \/\/ DEFLATER_MARKER to current. As part of the contended enter protocol,\n@@ -853,1 +850,1 @@\n-    \/\/ Assuming this is not a spurious wakeup we'll normally find _succ == Self.\n+    \/\/ Assuming this is not a spurious wakeup we'll normally find _succ == current.\n@@ -855,1 +852,1 @@\n-    \/\/ TrySpin() must tolerate being called with _succ == Self.\n+    \/\/ TrySpin() must tolerate being called with _succ == current.\n@@ -857,1 +854,1 @@\n-    if (TrySpin(Self) > 0) break;\n+    if (TrySpin(current) > 0) break;\n@@ -865,1 +862,1 @@\n-    if (_succ == Self) _succ = NULL;\n+    if (_succ == current) _succ = NULL;\n@@ -872,2 +869,2 @@\n-  \/\/ Self has acquired the lock -- Unlink Self from the cxq or EntryList.\n-  \/\/ Normally we'll find Self on the EntryList .\n+  \/\/ current has acquired the lock -- Unlink current from the cxq or EntryList.\n+  \/\/ Normally we'll find current on the EntryList .\n@@ -877,1 +874,1 @@\n-  \/\/ In addition, Self.TState is stable.\n+  \/\/ In addition, current.TState is stable.\n@@ -879,1 +876,1 @@\n-  assert(owner_raw() == Self, \"invariant\");\n+  assert(owner_raw() == current, \"invariant\");\n@@ -881,2 +878,2 @@\n-  UnlinkAfterAcquire(Self, &node);\n-  if (_succ == Self) _succ = NULL;\n+  UnlinkAfterAcquire(current, &node);\n+  if (_succ == current) _succ = NULL;\n@@ -884,2 +881,2 @@\n-  assert(_succ != Self, \"invariant\");\n-  if (_Responsible == Self) {\n+  assert(_succ != current, \"invariant\");\n+  if (_Responsible == current) {\n@@ -941,4 +938,4 @@\n-void ObjectMonitor::ReenterI(Thread * Self, ObjectWaiter * SelfNode) {\n-  assert(Self != NULL, \"invariant\");\n-  assert(SelfNode != NULL, \"invariant\");\n-  assert(SelfNode->_thread == Self, \"invariant\");\n+void ObjectMonitor::ReenterI(JavaThread* current, ObjectWaiter* currentNode) {\n+  assert(current != NULL, \"invariant\");\n+  assert(currentNode != NULL, \"invariant\");\n+  assert(currentNode->_thread == current, \"invariant\");\n@@ -948,2 +945,1 @@\n-  JavaThread * jt = Self->as_Java_thread();\n-  assert(jt->thread_state() != _thread_blocked, \"invariant\");\n+  assert(current->thread_state() != _thread_blocked, \"invariant\");\n@@ -953,1 +949,1 @@\n-    ObjectWaiter::TStates v = SelfNode->TState;\n+    ObjectWaiter::TStates v = currentNode->TState;\n@@ -955,1 +951,1 @@\n-    assert(owner_raw() != Self, \"invariant\");\n+    assert(owner_raw() != current, \"invariant\");\n@@ -957,2 +953,2 @@\n-    if (TryLock(Self) > 0) break;\n-    if (TrySpin(Self) > 0) break;\n+    if (TryLock(current) > 0) break;\n+    if (TrySpin(current) > 0) break;\n@@ -964,2 +960,2 @@\n-      OSThreadContendState osts(Self->osthread());\n-      ThreadBlockInVM tbivm(jt);\n+      OSThreadContendState osts(current->osthread());\n+      ThreadBlockInVM tbivm(current);\n@@ -969,2 +965,2 @@\n-      jt->set_suspend_equivalent();\n-      Self->_ParkEvent->park();\n+      current->set_suspend_equivalent();\n+      current->_ParkEvent->park();\n@@ -974,4 +970,4 @@\n-        if (!ExitSuspendEquivalent(jt)) break;\n-        if (_succ == Self) { _succ = NULL; OrderAccess::fence(); }\n-        jt->java_suspend_self();\n-        jt->set_suspend_equivalent();\n+        if (!current->handle_special_suspend_equivalent_condition()) break;\n+        if (_succ == current) { _succ = NULL; OrderAccess::fence(); }\n+        current->java_suspend_self();\n+        current->set_suspend_equivalent();\n@@ -984,1 +980,1 @@\n-    if (TryLock(Self) > 0) break;\n+    if (TryLock(current) > 0) break;\n@@ -994,2 +990,2 @@\n-    \/\/ find that _succ == Self.\n-    if (_succ == Self) _succ = NULL;\n+    \/\/ find that _succ == current.\n+    if (_succ == current) _succ = NULL;\n@@ -1006,2 +1002,2 @@\n-  \/\/ Self has acquired the lock -- Unlink Self from the cxq or EntryList .\n-  \/\/ Normally we'll find Self on the EntryList.\n+  \/\/ current has acquired the lock -- Unlink current from the cxq or EntryList .\n+  \/\/ Normally we'll find current on the EntryList.\n@@ -1012,1 +1008,1 @@\n-  \/\/ In addition, Self.TState is stable.\n+  \/\/ In addition, current.TState is stable.\n@@ -1014,1 +1010,1 @@\n-  assert(owner_raw() == Self, \"invariant\");\n+  assert(owner_raw() == current, \"invariant\");\n@@ -1016,4 +1012,4 @@\n-  UnlinkAfterAcquire(Self, SelfNode);\n-  if (_succ == Self) _succ = NULL;\n-  assert(_succ != Self, \"invariant\");\n-  SelfNode->TState = ObjectWaiter::TS_RUN;\n+  UnlinkAfterAcquire(current, currentNode);\n+  if (_succ == current) _succ = NULL;\n+  assert(_succ != current, \"invariant\");\n+  currentNode->TState = ObjectWaiter::TS_RUN;\n@@ -1027,3 +1023,3 @@\n-void ObjectMonitor::UnlinkAfterAcquire(Thread *Self, ObjectWaiter *SelfNode) {\n-  assert(owner_raw() == Self, \"invariant\");\n-  assert(SelfNode->_thread == Self, \"invariant\");\n+void ObjectMonitor::UnlinkAfterAcquire(JavaThread* current, ObjectWaiter* currentNode) {\n+  assert(owner_raw() == current, \"invariant\");\n+  assert(currentNode->_thread == current, \"invariant\");\n@@ -1031,2 +1027,2 @@\n-  if (SelfNode->TState == ObjectWaiter::TS_ENTER) {\n-    \/\/ Normal case: remove Self from the DLL EntryList .\n+  if (currentNode->TState == ObjectWaiter::TS_ENTER) {\n+    \/\/ Normal case: remove current from the DLL EntryList .\n@@ -1034,2 +1030,2 @@\n-    ObjectWaiter * nxt = SelfNode->_next;\n-    ObjectWaiter * prv = SelfNode->_prev;\n+    ObjectWaiter* nxt = currentNode->_next;\n+    ObjectWaiter* prv = currentNode->_prev;\n@@ -1038,1 +1034,1 @@\n-    if (SelfNode == _EntryList) _EntryList = nxt;\n+    if (currentNode == _EntryList) _EntryList = nxt;\n@@ -1042,2 +1038,2 @@\n-    assert(SelfNode->TState == ObjectWaiter::TS_CXQ, \"invariant\");\n-    \/\/ Inopportune interleaving -- Self is still on the cxq.\n+    assert(currentNode->TState == ObjectWaiter::TS_CXQ, \"invariant\");\n+    \/\/ Inopportune interleaving -- current is still on the cxq.\n@@ -1045,1 +1041,1 @@\n-    \/\/ Normally we'll find Self near the front of the cxq, so\n+    \/\/ Normally we'll find current near the front of the cxq, so\n@@ -1050,1 +1046,1 @@\n-    \/\/ Dequeue Self from either the head (with CAS) or from the interior\n+    \/\/ Dequeue current from either the head (with CAS) or from the interior\n@@ -1052,2 +1048,2 @@\n-    \/\/ CONSIDER: if Self is on the cxq then simply drain cxq into EntryList\n-    \/\/ and then unlink Self from EntryList.  We have to drain eventually,\n+    \/\/ CONSIDER: if current is on the cxq then simply drain cxq into EntryList\n+    \/\/ and then unlink current from EntryList.  We have to drain eventually,\n@@ -1056,1 +1052,1 @@\n-    ObjectWaiter * v = _cxq;\n+    ObjectWaiter* v = _cxq;\n@@ -1058,1 +1054,1 @@\n-    if (v != SelfNode || Atomic::cmpxchg(&_cxq, v, SelfNode->_next) != v) {\n+    if (v != currentNode || Atomic::cmpxchg(&_cxq, v, currentNode->_next) != v) {\n@@ -1060,1 +1056,1 @@\n-      \/\/ In that case Self must be in the interior and can no longer be\n+      \/\/ In that case current must be in the interior and can no longer be\n@@ -1062,1 +1058,1 @@\n-      if (v == SelfNode) {\n+      if (v == currentNode) {\n@@ -1066,3 +1062,3 @@\n-      ObjectWaiter * p;\n-      ObjectWaiter * q = NULL;\n-      for (p = v; p != NULL && p != SelfNode; p = p->_next) {\n+      ObjectWaiter* p;\n+      ObjectWaiter* q = NULL;\n+      for (p = v; p != NULL && p != currentNode; p = p->_next) {\n@@ -1072,2 +1068,2 @@\n-      assert(v != SelfNode, \"invariant\");\n-      assert(p == SelfNode, \"Node not found on cxq\");\n+      assert(v != currentNode, \"invariant\");\n+      assert(p == currentNode, \"Node not found on cxq\");\n@@ -1083,3 +1079,3 @@\n-  SelfNode->_prev  = (ObjectWaiter *) 0xBAD;\n-  SelfNode->_next  = (ObjectWaiter *) 0xBAD;\n-  SelfNode->TState = ObjectWaiter::TS_RUN;\n+  currentNode->_prev  = (ObjectWaiter*) 0xBAD;\n+  currentNode->_next  = (ObjectWaiter*) 0xBAD;\n+  currentNode->TState = ObjectWaiter::TS_RUN;\n@@ -1146,2 +1142,1 @@\n-void ObjectMonitor::exit(bool not_suspended, TRAPS) {\n-  Thread* const Self = THREAD;\n+void ObjectMonitor::exit(bool not_suspended, JavaThread* current) {\n@@ -1149,2 +1144,2 @@\n-  if (THREAD != cur) {\n-    if (THREAD->is_lock_owned((address)cur)) {\n+  if (current != cur) {\n+    if (current->is_lock_owned((address)cur)) {\n@@ -1152,1 +1147,1 @@\n-      set_owner_from_BasicLock(cur, Self);  \/\/ Convert from BasicLock* to Thread*.\n+      set_owner_from_BasicLock(cur, current);  \/\/ Convert from BasicLock* to Thread*.\n@@ -1167,1 +1162,1 @@\n-                    \" is exiting an ObjectMonitor it does not own.\", p2i(THREAD));\n+                    \" is exiting an ObjectMonitor it does not own.\", p2i(current));\n@@ -1189,1 +1184,1 @@\n-    _previous_owner_tid = JFR_THREAD_ID(Self);\n+    _previous_owner_tid = JFR_THREAD_ID(current);\n@@ -1194,1 +1189,1 @@\n-    assert(THREAD == owner_raw(), \"invariant\");\n+    assert(current == owner_raw(), \"invariant\");\n@@ -1202,1 +1197,1 @@\n-    release_clear_owner(Self);\n+    release_clear_owner(current);\n@@ -1246,1 +1241,1 @@\n-    if (try_set_owner_from(NULL, Self) != NULL) {\n+    if (try_set_owner_from(NULL, current) != NULL) {\n@@ -1250,1 +1245,1 @@\n-    guarantee(owner_raw() == THREAD, \"invariant\");\n+    guarantee(owner_raw() == current, \"invariant\");\n@@ -1252,1 +1247,1 @@\n-    ObjectWaiter * w = NULL;\n+    ObjectWaiter* w = NULL;\n@@ -1256,1 +1251,1 @@\n-      \/\/ I'd like to write: guarantee (w->_thread != Self).\n+      \/\/ I'd like to write: guarantee (w->_thread != current).\n@@ -1266,1 +1261,1 @@\n-      \/\/ associated with Self.\n+      \/\/ associated with current.\n@@ -1268,1 +1263,1 @@\n-      ExitEpilog(Self, w);\n+      ExitEpilog(current, w);\n@@ -1282,1 +1277,1 @@\n-      ObjectWaiter * u = Atomic::cmpxchg(&_cxq, w, (ObjectWaiter*)NULL);\n+      ObjectWaiter* u = Atomic::cmpxchg(&_cxq, w, (ObjectWaiter*)NULL);\n@@ -1293,1 +1288,1 @@\n-    \/\/ \"Self\" still holds the outer-lock, restricting parallelism\n+    \/\/ \"current\" still holds the outer-lock, restricting parallelism\n@@ -1300,2 +1295,2 @@\n-    ObjectWaiter * q = NULL;\n-    ObjectWaiter * p;\n+    ObjectWaiter* q = NULL;\n+    ObjectWaiter* p;\n@@ -1320,1 +1315,1 @@\n-      ExitEpilog(Self, w);\n+      ExitEpilog(current, w);\n@@ -1326,37 +1321,2 @@\n-\/\/ ExitSuspendEquivalent:\n-\/\/ A faster alternate to handle_special_suspend_equivalent_condition()\n-\/\/\n-\/\/ handle_special_suspend_equivalent_condition() unconditionally\n-\/\/ acquires the SR_lock.  On some platforms uncontended MutexLocker()\n-\/\/ operations have high latency.  Note that in ::enter() we call HSSEC\n-\/\/ while holding the monitor, so we effectively lengthen the critical sections.\n-\/\/\n-\/\/ There are a number of possible solutions:\n-\/\/\n-\/\/ A.  To ameliorate the problem we might also defer state transitions\n-\/\/     to as late as possible -- just prior to parking.\n-\/\/     Given that, we'd call HSSEC after having returned from park(),\n-\/\/     but before attempting to acquire the monitor.  This is only a\n-\/\/     partial solution.  It avoids calling HSSEC while holding the\n-\/\/     monitor (good), but it still increases successor reacquisition latency --\n-\/\/     the interval between unparking a successor and the time the successor\n-\/\/     resumes and retries the lock.  See ReenterI(), which defers state transitions.\n-\/\/     If we use this technique we can also avoid EnterI()-exit() loop\n-\/\/     in ::enter() where we iteratively drop the lock and then attempt\n-\/\/     to reacquire it after suspending.\n-\/\/\n-\/\/ B.  In the future we might fold all the suspend bits into a\n-\/\/     composite per-thread suspend flag and then update it with CAS().\n-\/\/     Alternately, a Dekker-like mechanism with multiple variables\n-\/\/     would suffice:\n-\/\/       ST Self->_suspend_equivalent = false\n-\/\/       MEMBAR\n-\/\/       LD Self_>_suspend_flags\n-\n-bool ObjectMonitor::ExitSuspendEquivalent(JavaThread * jSelf) {\n-  return jSelf->handle_special_suspend_equivalent_condition();\n-}\n-\n-\n-void ObjectMonitor::ExitEpilog(Thread * Self, ObjectWaiter * Wakee) {\n-  assert(owner_raw() == Self, \"invariant\");\n+void ObjectMonitor::ExitEpilog(JavaThread* current, ObjectWaiter* Wakee) {\n+  assert(owner_raw() == current, \"invariant\");\n@@ -1380,1 +1340,1 @@\n-  release_clear_owner(Self);\n+  release_clear_owner(current);\n@@ -1383,1 +1343,1 @@\n-  DTRACE_MONITOR_PROBE(contended__exit, this, object(), Self);\n+  DTRACE_MONITOR_PROBE(contended__exit, this, object(), current);\n@@ -1400,4 +1360,1 @@\n-intx ObjectMonitor::complete_exit(TRAPS) {\n-  Thread * const Self = THREAD;\n-  JavaThread * jt = Self->as_Java_thread();\n-\n+intx ObjectMonitor::complete_exit(JavaThread* current) {\n@@ -1407,2 +1364,2 @@\n-  if (THREAD != cur) {\n-    if (THREAD->is_lock_owned((address)cur)) {\n+  if (current != cur) {\n+    if (current->is_lock_owned((address)cur)) {\n@@ -1410,1 +1367,1 @@\n-      set_owner_from_BasicLock(cur, Self);  \/\/ Convert from BasicLock* to Thread*.\n+      set_owner_from_BasicLock(cur, current);  \/\/ Convert from BasicLock* to Thread*.\n@@ -1415,1 +1372,1 @@\n-  guarantee(Self == owner_raw(), \"complete_exit not owner\");\n+  guarantee(current == owner_raw(), \"complete_exit not owner\");\n@@ -1417,3 +1374,3 @@\n-  _recursions = 0;        \/\/ set the recursion level to be 0\n-  exit(true, Self);           \/\/ exit the monitor\n-  guarantee(owner_raw() != Self, \"invariant\");\n+  _recursions = 0;         \/\/ set the recursion level to be 0\n+  exit(true, current);     \/\/ exit the monitor\n+  guarantee(owner_raw() != current, \"invariant\");\n@@ -1425,3 +1382,1 @@\n-bool ObjectMonitor::reenter(intx recursions, TRAPS) {\n-  Thread * const Self = THREAD;\n-  JavaThread * jt = Self->as_Java_thread();\n+bool ObjectMonitor::reenter(intx recursions, JavaThread* current) {\n@@ -1429,2 +1384,2 @@\n-  guarantee(owner_raw() != Self, \"reenter already owner\");\n-  if (!enter(THREAD)) {\n+  guarantee(owner_raw() != current, \"reenter already owner\");\n+  if (!enter(current)) {\n@@ -1456,1 +1411,2 @@\n-bool ObjectMonitor::check_owner(Thread* THREAD) {\n+bool ObjectMonitor::check_owner(TRAPS) {\n+  JavaThread* current = THREAD->as_Java_thread();\n@@ -1458,1 +1414,1 @@\n-  if (cur == THREAD) {\n+  if (cur == current) {\n@@ -1461,2 +1417,2 @@\n-  if (THREAD->is_lock_owned((address)cur)) {\n-    set_owner_from_BasicLock(cur, THREAD);  \/\/ Convert from BasicLock* to Thread*.\n+  if (current->is_lock_owned((address)cur)) {\n+    set_owner_from_BasicLock(cur, current);  \/\/ Convert from BasicLock* to Thread*.\n@@ -1494,2 +1450,1 @@\n-  Thread * const Self = THREAD;\n-  JavaThread * jt = Self->as_Java_thread();\n+  JavaThread* current = THREAD->as_Java_thread();\n@@ -1504,1 +1459,1 @@\n-  if (interruptible && jt->is_interrupted(true) && !HAS_PENDING_EXCEPTION) {\n+  if (interruptible && current->is_interrupted(true) && !HAS_PENDING_EXCEPTION) {\n@@ -1509,1 +1464,1 @@\n-      JvmtiExport::post_monitor_waited(jt, this, false);\n+      JvmtiExport::post_monitor_waited(current, this, false);\n@@ -1526,3 +1481,3 @@\n-  assert(Self->_Stalled == 0, \"invariant\");\n-  Self->_Stalled = intptr_t(this);\n-  jt->set_current_waiting_monitor(this);\n+  assert(current->_Stalled == 0, \"invariant\");\n+  current->_Stalled = intptr_t(this);\n+  current->set_current_waiting_monitor(this);\n@@ -1533,1 +1488,1 @@\n-  ObjectWaiter node(Self);\n+  ObjectWaiter node(current);\n@@ -1535,1 +1490,1 @@\n-  Self->_ParkEvent->reset();\n+  current->_ParkEvent->reset();\n@@ -1554,2 +1509,2 @@\n-  exit(true, Self);                    \/\/ exit the monitor\n-  guarantee(owner_raw() != Self, \"invariant\");\n+  exit(true, current);         \/\/ exit the monitor\n+  guarantee(owner_raw() != current, \"invariant\");\n@@ -1568,1 +1523,1 @@\n-  bool interrupted = interruptible && jt->is_interrupted(false);\n+  bool interrupted = interruptible && current->is_interrupted(false);\n@@ -1571,1 +1526,1 @@\n-    OSThread* osthread = Self->osthread();\n+    OSThread* osthread = current->osthread();\n@@ -1574,1 +1529,1 @@\n-      ThreadBlockInVM tbivm(jt);\n+      ThreadBlockInVM tbivm(current);\n@@ -1576,1 +1531,1 @@\n-      jt->set_suspend_equivalent();\n+      current->set_suspend_equivalent();\n@@ -1582,1 +1537,1 @@\n-          Self->_ParkEvent->park();\n+          current->_ParkEvent->park();\n@@ -1584,1 +1539,1 @@\n-          ret = Self->_ParkEvent->park(millis);\n+          ret = current->_ParkEvent->park(millis);\n@@ -1589,3 +1544,3 @@\n-      if (ExitSuspendEquivalent (jt)) {\n-        \/\/ TODO-FIXME: add -- if succ == Self then succ = null.\n-        jt->java_suspend_self();\n+      if (current->handle_special_suspend_equivalent_condition()) {\n+        \/\/ TODO-FIXME: add -- if succ == current then succ = null.\n+        current->java_suspend_self();\n@@ -1627,1 +1582,1 @@\n-    if (_succ == Self) _succ = NULL;\n+    if (_succ == current) _succ = NULL;\n@@ -1639,1 +1594,1 @@\n-      JvmtiExport::post_monitor_waited(jt, this, ret == OS_TIMEOUT);\n+      JvmtiExport::post_monitor_waited(current, this, ret == OS_TIMEOUT);\n@@ -1641,1 +1596,1 @@\n-      if (node._notified != 0 && _succ == Self) {\n+      if (node._notified != 0 && _succ == current) {\n@@ -1667,2 +1622,2 @@\n-    assert(Self->_Stalled != 0, \"invariant\");\n-    Self->_Stalled = 0;\n+    assert(current->_Stalled != 0, \"invariant\");\n+    current->_Stalled = 0;\n@@ -1670,1 +1625,1 @@\n-    assert(owner_raw() != Self, \"invariant\");\n+    assert(owner_raw() != current, \"invariant\");\n@@ -1673,1 +1628,1 @@\n-      enter(Self);\n+      enter(current);\n@@ -1676,1 +1631,1 @@\n-      ReenterI(Self, &node);\n+      ReenterI(current, &node);\n@@ -1680,2 +1635,2 @@\n-    \/\/ Self has reacquired the lock.\n-    \/\/ Lifecycle - the node representing Self must not appear on any queues.\n+    \/\/ current has reacquired the lock.\n+    \/\/ Lifecycle - the node representing current must not appear on any queues.\n@@ -1685,2 +1640,2 @@\n-    assert(owner_raw() == Self, \"invariant\");\n-    assert(_succ != Self, \"invariant\");\n+    assert(owner_raw() == current, \"invariant\");\n+    assert(_succ != current, \"invariant\");\n@@ -1689,1 +1644,1 @@\n-  jt->set_current_waiting_monitor(NULL);\n+  current->set_current_waiting_monitor(NULL);\n@@ -1693,1 +1648,1 @@\n-                + JvmtiDeferredUpdates::get_and_reset_relock_count_after_wait(jt); \/\/  increased by the deferred relock count\n+                + JvmtiDeferredUpdates::get_and_reset_relock_count_after_wait(current); \/\/  increased by the deferred relock count\n@@ -1697,2 +1652,2 @@\n-  assert(owner_raw() == Self, \"invariant\");\n-  assert(_succ != Self, \"invariant\");\n+  assert(owner_raw() == current, \"invariant\");\n+  assert(_succ != current, \"invariant\");\n@@ -1705,1 +1660,1 @@\n-    if (interruptible && jt->is_interrupted(true) && !HAS_PENDING_EXCEPTION) {\n+    if (interruptible && current->is_interrupted(true) && !HAS_PENDING_EXCEPTION) {\n@@ -1720,1 +1675,1 @@\n-void ObjectMonitor::INotify(Thread * Self) {\n+void ObjectMonitor::INotify(JavaThread* current) {\n@@ -1722,1 +1677,1 @@\n-  ObjectWaiter * iterator = DequeueWaiter();\n+  ObjectWaiter* iterator = DequeueWaiter();\n@@ -1735,1 +1690,1 @@\n-    iterator->_notifier_tid = JFR_THREAD_ID(Self);\n+    iterator->_notifier_tid = JFR_THREAD_ID(current);\n@@ -1737,1 +1692,1 @@\n-    ObjectWaiter * list = _EntryList;\n+    ObjectWaiter* list = _EntryList;\n@@ -1751,1 +1706,1 @@\n-        ObjectWaiter * front = _cxq;\n+        ObjectWaiter* front = _cxq;\n@@ -1783,0 +1738,1 @@\n+  JavaThread* current = THREAD->as_Java_thread();\n@@ -1787,2 +1743,2 @@\n-  DTRACE_MONITOR_PROBE(notify, this, object(), THREAD);\n-  INotify(THREAD);\n+  DTRACE_MONITOR_PROBE(notify, this, object(), current);\n+  INotify(current);\n@@ -1801,0 +1757,1 @@\n+  JavaThread* current = THREAD->as_Java_thread();\n@@ -1806,1 +1763,1 @@\n-  DTRACE_MONITOR_PROBE(notifyAll, this, object(), THREAD);\n+  DTRACE_MONITOR_PROBE(notifyAll, this, object(), current);\n@@ -1810,1 +1767,1 @@\n-    INotify(THREAD);\n+    INotify(current);\n@@ -1883,1 +1840,1 @@\n-int ObjectMonitor::TrySpin(Thread * Self) {\n+int ObjectMonitor::TrySpin(JavaThread* current) {\n@@ -1888,1 +1845,1 @@\n-      if (TryLock(Self) > 0) return 1;\n+      if (TryLock(current) > 0) return 1;\n@@ -1895,1 +1852,1 @@\n-    if (TryLock(Self) > 0) {\n+    if (TryLock(current) > 0) {\n@@ -1926,1 +1883,1 @@\n-  if (NotRunnable(Self, (Thread *) owner_raw())) {\n+  if (NotRunnable(current, (JavaThread*) owner_raw())) {\n@@ -1935,1 +1892,1 @@\n-    _succ = Self;\n+    _succ = current;\n@@ -1937,1 +1894,1 @@\n-  Thread * prv = NULL;\n+  Thread* prv = NULL;\n@@ -1956,1 +1913,1 @@\n-      if (SafepointMechanism::should_process(Self)) {\n+      if (SafepointMechanism::should_process(current)) {\n@@ -1972,1 +1929,1 @@\n-    Thread * ox = (Thread *) owner_raw();\n+    JavaThread* ox = (JavaThread*) owner_raw();\n@@ -1974,1 +1931,1 @@\n-      ox = (Thread*)try_set_owner_from(NULL, Self);\n+      ox = (JavaThread*)try_set_owner_from(NULL, current);\n@@ -1978,1 +1935,1 @@\n-        if (_succ == Self) {\n+        if (_succ == current) {\n@@ -2016,1 +1973,1 @@\n-    if (NotRunnable(Self, ox)) {\n+    if (NotRunnable(current, ox)) {\n@@ -2020,1 +1977,1 @@\n-      _succ = Self;\n+      _succ = current;\n@@ -2039,1 +1996,1 @@\n-  if (_succ == Self) {\n+  if (_succ == current) {\n@@ -2046,1 +2003,1 @@\n-    if (TryLock(Self) > 0) return 1;\n+    if (TryLock(current) > 0) return 1;\n@@ -2083,1 +2040,1 @@\n-int ObjectMonitor::NotRunnable(Thread * Self, Thread * ox) {\n+int ObjectMonitor::NotRunnable(JavaThread* current, JavaThread* ox) {\n@@ -2101,2 +2058,2 @@\n-  assert(sizeof(((JavaThread *)ox)->_thread_state == sizeof(int)), \"invariant\");\n-  int jst = SafeFetch32((int *) &((JavaThread *) ox)->_thread_state, -1);;\n+  assert(sizeof(ox->_thread_state == sizeof(int)), \"invariant\");\n+  int jst = SafeFetch32((int *) &ox->_thread_state, -1);;\n@@ -2111,1 +2068,1 @@\n-ObjectWaiter::ObjectWaiter(Thread* thread) {\n+ObjectWaiter::ObjectWaiter(JavaThread* current) {\n@@ -2117,2 +2074,2 @@\n-  _thread   = thread;\n-  _event    = thread->_ParkEvent;\n+  _thread   = current;\n+  _event    = _thread->_ParkEvent;\n@@ -2124,2 +2081,1 @@\n-  JavaThread *jt = this->_thread->as_Java_thread();\n-  _active = JavaThreadBlockedOnMonitorEnterState::wait_reenter_begin(jt, mon);\n+  _active = JavaThreadBlockedOnMonitorEnterState::wait_reenter_begin(_thread, mon);\n@@ -2129,2 +2085,1 @@\n-  JavaThread *jt = this->_thread->as_Java_thread();\n-  JavaThreadBlockedOnMonitorEnterState::wait_reenter_end(jt, _active);\n+  JavaThreadBlockedOnMonitorEnterState::wait_reenter_end(_thread, _active);\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.cpp","additions":249,"deletions":294,"binary":false,"changes":543,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-  Thread*       _thread;\n+  JavaThread*   _thread;\n@@ -56,1 +56,1 @@\n-  ObjectWaiter(Thread* thread);\n+  ObjectWaiter(JavaThread* current);\n@@ -165,2 +165,2 @@\n-  Thread* volatile _succ;           \/\/ Heir presumptive thread - used for futile wakeup throttling\n-  Thread* volatile _Responsible;\n+  JavaThread* volatile _succ;       \/\/ Heir presumptive thread - used for futile wakeup throttling\n+  JavaThread* volatile _Responsible;\n@@ -252,1 +252,1 @@\n-  intptr_t  is_entered(Thread* current) const;\n+  intptr_t  is_entered(JavaThread* current) const;\n@@ -264,2 +264,2 @@\n-  \/\/ Simply set _owner field to self; current value must match basic_lock_p.\n-  void      set_owner_from_BasicLock(void* basic_lock_p, Thread* self);\n+  \/\/ Simply set _owner field to current; current value must match basic_lock_p.\n+  void      set_owner_from_BasicLock(void* basic_lock_p, JavaThread* current);\n@@ -293,1 +293,1 @@\n-  Thread* thread_of_waiter(ObjectWaiter* o)                            { return o->_thread; }\n+  JavaThread* thread_of_waiter(ObjectWaiter* o)                        { return o->_thread; }\n@@ -303,1 +303,1 @@\n-  bool      check_owner(Thread* THREAD);\n+  bool      check_owner(TRAPS);\n@@ -305,3 +305,3 @@\n-  bool      enter(TRAPS);\n-  void      exit(bool not_suspended, TRAPS);\n-  void      wait(jlong millis, bool interruptable, TRAPS);\n+  bool      enter(JavaThread* current);\n+  void      exit(bool not_suspended, JavaThread* current);\n+  void      wait(jlong millis, bool interruptible, TRAPS);\n@@ -317,3 +317,3 @@\n-\/\/ Use the following at your own risk\n-  intx      complete_exit(TRAPS);\n-  bool      reenter(intx recursions, TRAPS);\n+  \/\/ Use the following at your own risk\n+  intx      complete_exit(JavaThread* current);\n+  bool      reenter(intx recursions, JavaThread* current);\n@@ -323,1 +323,1 @@\n-  void      INotify(Thread* self);\n+  void      INotify(JavaThread* current);\n@@ -326,8 +326,7 @@\n-  void      EnterI(TRAPS);\n-  void      ReenterI(Thread* self, ObjectWaiter* self_node);\n-  void      UnlinkAfterAcquire(Thread* self, ObjectWaiter* self_node);\n-  int       TryLock(Thread* self);\n-  int       NotRunnable(Thread* self, Thread* Owner);\n-  int       TrySpin(Thread* self);\n-  void      ExitEpilog(Thread* self, ObjectWaiter* Wakee);\n-  bool      ExitSuspendEquivalent(JavaThread* self);\n+  void      EnterI(JavaThread* current);\n+  void      ReenterI(JavaThread* current, ObjectWaiter* current_node);\n+  void      UnlinkAfterAcquire(JavaThread* current, ObjectWaiter* current_node);\n+  int       TryLock(JavaThread* current);\n+  int       NotRunnable(JavaThread* current, JavaThread* Owner);\n+  int       TrySpin(JavaThread* current);\n+  void      ExitEpilog(JavaThread* current, ObjectWaiter* Wakee);\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.hpp","additions":23,"deletions":24,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-inline intptr_t ObjectMonitor::is_entered(TRAPS) const {\n+inline intptr_t ObjectMonitor::is_entered(JavaThread* current) const {\n@@ -36,1 +36,1 @@\n-  if (THREAD == owner || THREAD->is_lock_owned((address)owner)) {\n+  if (current == owner || current->is_lock_owned((address)owner)) {\n@@ -119,1 +119,1 @@\n-inline void ObjectMonitor::set_owner_from_BasicLock(void* basic_lock_p, Thread* self) {\n+inline void ObjectMonitor::set_owner_from_BasicLock(void* basic_lock_p, JavaThread* current) {\n@@ -127,1 +127,1 @@\n-  Atomic::store(&_owner, self);\n+  Atomic::store(&_owner, current);\n@@ -131,1 +131,1 @@\n-                                     p2i(this), p2i(basic_lock_p), p2i(self));\n+                                     p2i(this), p2i(basic_lock_p), p2i(current));\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.inline.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2125,1 +2125,1 @@\n-  ObjectSynchronizer::enter(h_obj, lock, CHECK);\n+  ObjectSynchronizer::enter(h_obj, lock, thread);\n@@ -2147,1 +2147,1 @@\n-  ObjectSynchronizer::exit(obj, lock, THREAD);\n+  ObjectSynchronizer::exit(obj, lock, thread);\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -83,1 +83,1 @@\n-size_t MonitorList::unlink_deflated(Thread* self, LogStream* ls,\n+size_t MonitorList::unlink_deflated(Thread* current, LogStream* ls,\n@@ -127,1 +127,1 @@\n-    if (self->is_Java_thread()) {\n+    if (current->is_Java_thread()) {\n@@ -129,1 +129,1 @@\n-      ObjectSynchronizer::chk_for_block_req(self->as_Java_thread(), \"unlinking\",\n+      ObjectSynchronizer::chk_for_block_req(current->as_Java_thread(), \"unlinking\",\n@@ -266,3 +266,2 @@\n-bool ObjectSynchronizer::quick_notify(oopDesc* obj, Thread* self, bool all) {\n-  assert(!SafepointSynchronize::is_at_safepoint(), \"invariant\");\n-  assert(self->as_Java_thread()->thread_state() == _thread_in_Java, \"invariant\");\n+bool ObjectSynchronizer::quick_notify(oopDesc* obj, JavaThread* current, bool all) {\n+  assert(current->thread_state() == _thread_in_Java, \"invariant\");\n@@ -273,1 +272,1 @@\n-  if (mark.has_locker() && self->is_lock_owned((address)mark.locker())) {\n+  if (mark.has_locker() && current->is_lock_owned((address)mark.locker())) {\n@@ -282,1 +281,1 @@\n-    if (mon->owner() != self) return false;  \/\/ slow-path for IMS exception\n+    if (mon->owner() != current) return false;  \/\/ slow-path for IMS exception\n@@ -289,1 +288,1 @@\n-        DTRACE_MONITOR_PROBE(notifyAll, mon, obj, self);\n+        DTRACE_MONITOR_PROBE(notifyAll, mon, obj, current);\n@@ -291,1 +290,1 @@\n-        DTRACE_MONITOR_PROBE(notify, mon, obj, self);\n+        DTRACE_MONITOR_PROBE(notify, mon, obj, current);\n@@ -295,1 +294,1 @@\n-        mon->INotify(self);\n+        mon->INotify(current);\n@@ -314,1 +313,1 @@\n-bool ObjectSynchronizer::quick_enter(oop obj, Thread* self,\n+bool ObjectSynchronizer::quick_enter(oop obj, JavaThread* current,\n@@ -316,2 +315,1 @@\n-  assert(!SafepointSynchronize::is_at_safepoint(), \"invariant\");\n-  assert(self->as_Java_thread()->thread_state() == _thread_in_Java, \"invariant\");\n+  assert(current->thread_state() == _thread_in_Java, \"invariant\");\n@@ -335,1 +333,1 @@\n-    Thread* const owner = (Thread *) m->owner_raw();\n+    JavaThread* const owner = (JavaThread*) m->owner_raw();\n@@ -342,1 +340,1 @@\n-    if (owner == self) {\n+    if (owner == current) {\n@@ -359,1 +357,1 @@\n-    if (owner == NULL && m->try_set_owner_from(NULL, self) == NULL) {\n+    if (owner == NULL && m->try_set_owner_from(NULL, current) == NULL) {\n@@ -376,4 +374,2 @@\n-void ObjectSynchronizer::handle_sync_on_value_based_class(Handle obj, Thread* current) {\n-  JavaThread* self = current->as_Java_thread();\n-\n-  frame last_frame = self->last_frame();\n+void ObjectSynchronizer::handle_sync_on_value_based_class(Handle obj, JavaThread* current) {\n+  frame last_frame = current->last_frame();\n@@ -392,1 +388,1 @@\n-    ResourceMark rm(self);\n+    ResourceMark rm(current);\n@@ -394,1 +390,1 @@\n-    self->print_stack_on(&ss);\n+    current->print_stack_on(&ss);\n@@ -403,1 +399,1 @@\n-    ResourceMark rm(self);\n+    ResourceMark rm(current);\n@@ -407,1 +403,1 @@\n-    if (self->has_last_Java_frame()) {\n+    if (current->has_last_Java_frame()) {\n@@ -409,1 +405,1 @@\n-      self->print_stack_on(&info_stream);\n+      current->print_stack_on(&info_stream);\n@@ -432,1 +428,1 @@\n-void ObjectSynchronizer::enter(Handle obj, BasicLock* lock, TRAPS) {\n+void ObjectSynchronizer::enter(Handle obj, BasicLock* lock, JavaThread* current) {\n@@ -434,1 +430,1 @@\n-    handle_sync_on_value_based_class(obj, THREAD);\n+    handle_sync_on_value_based_class(obj, current);\n@@ -438,5 +434,1 @@\n-    if (!SafepointSynchronize::is_at_safepoint()) {\n-      BiasedLocking::revoke(obj, THREAD);\n-    } else {\n-      BiasedLocking::revoke_at_safepoint(obj);\n-    }\n+      BiasedLocking::revoke(obj, current);\n@@ -457,1 +449,1 @@\n-             THREAD->is_lock_owned((address)mark.locker())) {\n+             current->is_lock_owned((address)mark.locker())) {\n@@ -473,2 +465,2 @@\n-    ObjectMonitor* monitor = inflate(THREAD, obj(), inflate_cause_monitor_enter);\n-    if (monitor->enter(THREAD)) {\n+    ObjectMonitor* monitor = inflate(current, obj(), inflate_cause_monitor_enter);\n+    if (monitor->enter(current)) {\n@@ -480,1 +472,1 @@\n-void ObjectSynchronizer::exit(oop object, BasicLock* lock, TRAPS) {\n+void ObjectSynchronizer::exit(oop object, BasicLock* lock, JavaThread* current) {\n@@ -497,1 +489,1 @@\n-             THREAD->is_lock_owned((address)mark.locker()), \"invariant\");\n+             current->is_lock_owned((address)mark.locker()), \"invariant\");\n@@ -509,1 +501,1 @@\n-        assert(m->is_entered(THREAD), \"invariant\");\n+        assert(m->is_entered(current), \"invariant\");\n@@ -528,2 +520,2 @@\n-  ObjectMonitor* monitor = inflate(THREAD, object, inflate_cause_vm_internal);\n-  monitor->exit(true, THREAD);\n+  ObjectMonitor* monitor = inflate(current, object, inflate_cause_vm_internal);\n+  monitor->exit(true, current);\n@@ -544,1 +536,1 @@\n-intx ObjectSynchronizer::complete_exit(Handle obj, TRAPS) {\n+intx ObjectSynchronizer::complete_exit(Handle obj, JavaThread* current) {\n@@ -546,1 +538,1 @@\n-    BiasedLocking::revoke(obj, THREAD);\n+    BiasedLocking::revoke(obj, current);\n@@ -552,2 +544,2 @@\n-  ObjectMonitor* monitor = inflate(THREAD, obj(), inflate_cause_vm_internal);\n-  intptr_t ret_code = monitor->complete_exit(THREAD);\n+  ObjectMonitor* monitor = inflate(current, obj(), inflate_cause_vm_internal);\n+  intptr_t ret_code = monitor->complete_exit(current);\n@@ -558,1 +550,1 @@\n-void ObjectSynchronizer::reenter(Handle obj, intx recursions, TRAPS) {\n+void ObjectSynchronizer::reenter(Handle obj, intx recursions, JavaThread* current) {\n@@ -560,1 +552,1 @@\n-    BiasedLocking::revoke(obj, THREAD);\n+    BiasedLocking::revoke(obj, current);\n@@ -569,2 +561,2 @@\n-    ObjectMonitor* monitor = inflate(THREAD, obj(), inflate_cause_vm_internal);\n-    if (monitor->reenter(recursions, THREAD)) {\n+    ObjectMonitor* monitor = inflate(current, obj(), inflate_cause_vm_internal);\n+    if (monitor->reenter(recursions, current)) {\n@@ -579,1 +571,1 @@\n-void ObjectSynchronizer::jni_enter(Handle obj, TRAPS) {\n+void ObjectSynchronizer::jni_enter(Handle obj, JavaThread* current) {\n@@ -581,1 +573,1 @@\n-    handle_sync_on_value_based_class(obj, THREAD);\n+    handle_sync_on_value_based_class(obj, current);\n@@ -586,1 +578,1 @@\n-    BiasedLocking::revoke(obj, THREAD);\n+    BiasedLocking::revoke(obj, current);\n@@ -589,1 +581,1 @@\n-  THREAD->set_current_pending_monitor_is_from_java(false);\n+  current->set_current_pending_monitor_is_from_java(false);\n@@ -594,2 +586,2 @@\n-    ObjectMonitor* monitor = inflate(THREAD, obj(), inflate_cause_jni_enter);\n-    if (monitor->enter(THREAD)) {\n+    ObjectMonitor* monitor = inflate(current, obj(), inflate_cause_jni_enter);\n+    if (monitor->enter(current)) {\n@@ -599,1 +591,1 @@\n-  THREAD->set_current_pending_monitor_is_from_java(true);\n+  current->set_current_pending_monitor_is_from_java(true);\n@@ -603,1 +595,2 @@\n-void ObjectSynchronizer::jni_exit(oop obj, Thread* THREAD) {\n+void ObjectSynchronizer::jni_exit(oop obj, TRAPS) {\n+  JavaThread* current = THREAD->as_Java_thread();\n@@ -605,2 +598,2 @@\n-    Handle h_obj(THREAD, obj);\n-    BiasedLocking::revoke(h_obj, THREAD);\n+    Handle h_obj(current, obj);\n+    BiasedLocking::revoke(h_obj, current);\n@@ -613,1 +606,1 @@\n-  ObjectMonitor* monitor = inflate(THREAD, obj, inflate_cause_jni_exit);\n+  ObjectMonitor* monitor = inflate(current, obj, inflate_cause_jni_exit);\n@@ -615,2 +608,2 @@\n-  \/\/ intentionally do not use CHECK here because we must exit the\n-  \/\/ monitor even if an exception is pending.\n+  \/\/ intentionally do not use CHECK on check_owner because we must exit the\n+  \/\/ monitor even if an exception was already pending.\n@@ -618,1 +611,1 @@\n-    monitor->exit(true, THREAD);\n+    monitor->exit(true, current);\n@@ -625,1 +618,1 @@\n-ObjectLocker::ObjectLocker(Handle obj, Thread* thread) {\n+ObjectLocker::ObjectLocker(Handle obj, JavaThread* thread) {\n@@ -646,0 +639,1 @@\n+  JavaThread* current = THREAD->as_Java_thread();\n@@ -647,1 +641,1 @@\n-    BiasedLocking::revoke(obj, THREAD);\n+    BiasedLocking::revoke(obj, current);\n@@ -656,1 +650,1 @@\n-  ObjectMonitor* monitor = inflate(THREAD, obj(), inflate_cause_wait);\n+  ObjectMonitor* monitor = inflate(current, obj(), inflate_cause_wait);\n@@ -658,2 +652,2 @@\n-  DTRACE_MONITOR_WAIT_PROBE(monitor, obj(), THREAD, millis);\n-  monitor->wait(millis, true, THREAD);\n+  DTRACE_MONITOR_WAIT_PROBE(monitor, obj(), current, millis);\n+  monitor->wait(millis, true, THREAD); \/\/ Not CHECK as we need following code\n@@ -669,1 +663,3 @@\n-void ObjectSynchronizer::wait_uninterruptibly(Handle obj, jlong millis, TRAPS) {\n+\/\/ No exception are possible in this case as we only use this internally when locking is\n+\/\/ correct and we have to wait until notified - so no interrupts or timeouts.\n+void ObjectSynchronizer::wait_uninterruptibly(Handle obj, JavaThread* current) {\n@@ -671,1 +667,1 @@\n-    BiasedLocking::revoke(obj, THREAD);\n+    BiasedLocking::revoke(obj, current);\n@@ -674,3 +670,0 @@\n-  if (millis < 0) {\n-    THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), \"timeout value is negative\");\n-  }\n@@ -680,2 +673,2 @@\n-  ObjectMonitor* monitor = inflate(THREAD, obj(), inflate_cause_wait);\n-  monitor->wait(millis, false, THREAD);\n+  ObjectMonitor* monitor = inflate(current, obj(), inflate_cause_wait);\n+  monitor->wait(0 \/* wait-forever *\/, false \/* not interruptible *\/, current);\n@@ -685,0 +678,1 @@\n+  JavaThread* current = THREAD->as_Java_thread();\n@@ -686,1 +680,1 @@\n-    BiasedLocking::revoke(obj, THREAD);\n+    BiasedLocking::revoke(obj, current);\n@@ -691,1 +685,2 @@\n-  if (mark.has_locker() && THREAD->is_lock_owned((address)mark.locker())) {\n+  if (mark.has_locker() && current->is_lock_owned((address)mark.locker())) {\n+    \/\/ Not inflated so there can't be any waiters to notify.\n@@ -696,2 +691,2 @@\n-  ObjectMonitor* monitor = inflate(THREAD, obj(), inflate_cause_notify);\n-  monitor->notify(THREAD);\n+  ObjectMonitor* monitor = inflate(current, obj(), inflate_cause_notify);\n+  monitor->notify(CHECK);\n@@ -702,0 +697,1 @@\n+  JavaThread* current = THREAD->as_Java_thread();\n@@ -703,1 +699,1 @@\n-    BiasedLocking::revoke(obj, THREAD);\n+    BiasedLocking::revoke(obj, current);\n@@ -708,1 +704,2 @@\n-  if (mark.has_locker() && THREAD->is_lock_owned((address)mark.locker())) {\n+  if (mark.has_locker() && current->is_lock_owned((address)mark.locker())) {\n+    \/\/ Not inflated so there can't be any waiters to notify.\n@@ -713,2 +710,2 @@\n-  ObjectMonitor* monitor = inflate(THREAD, obj(), inflate_cause_notify);\n-  monitor->notifyAll(THREAD);\n+  ObjectMonitor* monitor = inflate(current, obj(), inflate_cause_notify);\n+  monitor->notifyAll(CHECK);\n@@ -777,1 +774,1 @@\n-          \/\/ so we periodically call self->_ParkEvent->park(1).\n+          \/\/ so we periodically call current->_ParkEvent->park(1).\n@@ -810,1 +807,1 @@\n-static inline intptr_t get_next_hash(Thread* self, oop obj) {\n+static inline intptr_t get_next_hash(Thread* current, oop obj) {\n@@ -833,1 +830,1 @@\n-    unsigned t = self->_hashStateX;\n+    unsigned t = current->_hashStateX;\n@@ -835,4 +832,4 @@\n-    self->_hashStateX = self->_hashStateY;\n-    self->_hashStateY = self->_hashStateZ;\n-    self->_hashStateZ = self->_hashStateW;\n-    unsigned v = self->_hashStateW;\n+    current->_hashStateX = current->_hashStateY;\n+    current->_hashStateY = current->_hashStateZ;\n+    current->_hashStateZ = current->_hashStateW;\n+    unsigned v = current->_hashStateW;\n@@ -840,1 +837,1 @@\n-    self->_hashStateW = v;\n+    current->_hashStateW = v;\n@@ -850,1 +847,1 @@\n-intptr_t ObjectSynchronizer::FastHashCode(Thread* self, oop obj) {\n+intptr_t ObjectSynchronizer::FastHashCode(Thread* current, oop obj) {\n@@ -860,1 +857,1 @@\n-      Handle hobj(self, obj);\n+      Handle hobj(current, obj);\n@@ -864,1 +861,1 @@\n-        BiasedLocking::revoke(hobj, self);\n+        BiasedLocking::revoke(hobj, current);\n@@ -880,1 +877,1 @@\n-    if (mark.is_neutral()) {            \/\/ if this is a normal header\n+    if (mark.is_neutral()) {               \/\/ if this is a normal header\n@@ -882,1 +879,1 @@\n-      if (hash != 0) {                  \/\/ if it has a hash, just return it\n+      if (hash != 0) {                     \/\/ if it has a hash, just return it\n@@ -885,3 +882,3 @@\n-      hash = get_next_hash(self, obj);  \/\/ get a new hash\n-      temp = mark.copy_set_hash(hash);  \/\/ merge the hash into header\n-                                        \/\/ try to install the hash\n+      hash = get_next_hash(current, obj);  \/\/ get a new hash\n+      temp = mark.copy_set_hash(hash);     \/\/ merge the hash into header\n+                                           \/\/ try to install the hash\n@@ -889,1 +886,1 @@\n-      if (test == mark) {               \/\/ if the hash was installed, return it\n+      if (test == mark) {                  \/\/ if the hash was installed, return it\n@@ -923,1 +920,1 @@\n-    } else if (self->is_lock_owned((address)mark.locker())) {\n+    } else if (current->is_lock_owned((address)mark.locker())) {\n@@ -946,1 +943,1 @@\n-    monitor = inflate(self, obj, inflate_cause_hash_code);\n+    monitor = inflate(current, obj, inflate_cause_hash_code);\n@@ -951,3 +948,3 @@\n-    if (hash == 0) {                    \/\/ if it does not have a hash\n-      hash = get_next_hash(self, obj);  \/\/ get a new hash\n-      temp = mark.copy_set_hash(hash);  \/\/ merge the hash into header\n+    if (hash == 0) {                       \/\/ if it does not have a hash\n+      hash = get_next_hash(current, obj);  \/\/ get a new hash\n+      temp = mark.copy_set_hash(hash)   ;  \/\/ merge the hash into header\n@@ -988,1 +985,1 @@\n-bool ObjectSynchronizer::current_thread_holds_lock(JavaThread* thread,\n+bool ObjectSynchronizer::current_thread_holds_lock(JavaThread* current,\n@@ -991,1 +988,1 @@\n-    BiasedLocking::revoke(h_obj, thread);\n+    BiasedLocking::revoke(h_obj, current);\n@@ -995,1 +992,1 @@\n-  assert(thread == JavaThread::current(), \"Can only be called on current thread\");\n+  assert(current == JavaThread::current(), \"Can only be called on current thread\");\n@@ -1002,1 +999,1 @@\n-    return thread->is_lock_owned((address)mark.locker());\n+    return current->is_lock_owned((address)mark.locker());\n@@ -1009,1 +1006,1 @@\n-    return monitor->is_entered(thread) != 0;\n+    return monitor->is_entered(current) != 0;\n@@ -1145,1 +1142,1 @@\n-  Thread* self = Thread::current();\n+  JavaThread* current = JavaThread::current();\n@@ -1161,1 +1158,1 @@\n-    if (self->is_Java_thread()) {\n+    {\n@@ -1163,3 +1160,1 @@\n-      ThreadBlockInVM tbivm(self->as_Java_thread());\n-      os::naked_short_sleep(999);  \/\/ sleep for almost 1 second\n-    } else {\n+      ThreadBlockInVM tbivm(current);\n@@ -1203,1 +1198,1 @@\n-ObjectMonitor* ObjectSynchronizer::inflate(Thread* self, oop object,\n+ObjectMonitor* ObjectSynchronizer::inflate(Thread* current, oop object,\n@@ -1300,1 +1295,1 @@\n-      \/\/ with this thread we could simply set m->_owner = self.\n+      \/\/ with this thread we could simply set m->_owner = current.\n@@ -1321,1 +1316,1 @@\n-        ResourceMark rm(self);\n+        ResourceMark rm(current);\n@@ -1338,1 +1333,1 @@\n-    \/\/ to inflate and then CAS() again to try to swing _owner from NULL to self.\n+    \/\/ to inflate and then CAS() again to try to swing _owner from NULL to current.\n@@ -1365,1 +1360,1 @@\n-      ResourceMark rm(self);\n+      ResourceMark rm(current);\n@@ -1377,1 +1372,1 @@\n-void ObjectSynchronizer::chk_for_block_req(JavaThread* self, const char* op_name,\n+void ObjectSynchronizer::chk_for_block_req(JavaThread* current, const char* op_name,\n@@ -1380,1 +1375,1 @@\n-  if (!SafepointMechanism::should_process(self)) {\n+  if (!SafepointMechanism::should_process(current)) {\n@@ -1395,1 +1390,1 @@\n-    ThreadBlockInVM tbivm(self);\n+    ThreadBlockInVM tbivm(current);\n@@ -1408,1 +1403,1 @@\n-size_t ObjectSynchronizer::deflate_monitor_list(Thread *self, LogStream* ls,\n+size_t ObjectSynchronizer::deflate_monitor_list(Thread* current, LogStream* ls,\n@@ -1422,1 +1417,1 @@\n-    if (self->is_Java_thread()) {\n+    if (current->is_Java_thread()) {\n@@ -1424,1 +1419,1 @@\n-      chk_for_block_req(self->as_Java_thread(), \"deflation\", \"deflated_count\",\n+      chk_for_block_req(current->as_Java_thread(), \"deflation\", \"deflated_count\",\n@@ -1446,2 +1441,2 @@\n-  Thread* self = Thread::current();\n-  if (self->is_Java_thread()) {\n+  Thread* current = Thread::current();\n+  if (current->is_Java_thread()) {\n@@ -1470,1 +1465,1 @@\n-  size_t deflated_count = deflate_monitor_list(self, ls, &timer);\n+  size_t deflated_count = deflate_monitor_list(current, ls, &timer);\n@@ -1480,1 +1475,1 @@\n-    size_t unlinked_count = _in_use_list.unlink_deflated(self, ls, &timer,\n+    size_t unlinked_count = _in_use_list.unlink_deflated(current, ls, &timer,\n@@ -1482,1 +1477,1 @@\n-    if (self->is_Java_thread()) {\n+    if (current->is_Java_thread()) {\n@@ -1512,1 +1507,1 @@\n-      if (self->is_Java_thread()) {\n+      if (current->is_Java_thread()) {\n@@ -1514,1 +1509,1 @@\n-        chk_for_block_req(self->as_Java_thread(), \"deletion\", \"deleted_count\",\n+        chk_for_block_req(current->as_Java_thread(), \"deletion\", \"deleted_count\",\n@@ -1547,2 +1542,0 @@\n-\/\/ Gives up on a particular monitor if an exception occurs, but continues\n-\/\/ the overall iteration, swallowing the exception.\n@@ -1551,1 +1544,1 @@\n-  TRAPS;\n+  JavaThread* _thread;\n@@ -1554,1 +1547,1 @@\n-  ReleaseJavaMonitorsClosure(Thread* thread) : THREAD(thread) {}\n+  ReleaseJavaMonitorsClosure(JavaThread* thread) : _thread(thread) {}\n@@ -1556,2 +1549,2 @@\n-    if (mid->owner() == THREAD) {\n-      (void)mid->complete_exit(CHECK);\n+    if (mid->owner() == _thread) {\n+      (void)mid->complete_exit(_thread);\n@@ -1562,1 +1555,1 @@\n-\/\/ Release all inflated monitors owned by THREAD.  Lightweight monitors are\n+\/\/ Release all inflated monitors owned by current thread.  Lightweight monitors are\n@@ -1577,2 +1570,2 @@\n-void ObjectSynchronizer::release_monitors_owned_by_thread(TRAPS) {\n-  assert(THREAD == JavaThread::current(), \"must be current Java thread\");\n+void ObjectSynchronizer::release_monitors_owned_by_thread(JavaThread* current) {\n+  assert(current == JavaThread::current(), \"must be current Java thread\");\n@@ -1580,1 +1573,1 @@\n-  ReleaseJavaMonitorsClosure rjmc(THREAD);\n+  ReleaseJavaMonitorsClosure rjmc(current);\n@@ -1582,1 +1575,2 @@\n-  THREAD->clear_pending_exception();\n+  assert(!current->has_pending_exception(), \"Should not be possible\");\n+  current->clear_pending_exception();\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":138,"deletions":144,"binary":false,"changes":282,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-  size_t unlink_deflated(Thread* self, LogStream* ls, elapsedTimer* timer_p,\n+  size_t unlink_deflated(Thread* current, LogStream* ls, elapsedTimer* timer_p,\n@@ -91,2 +91,2 @@\n-  static void enter(Handle obj, BasicLock* lock, TRAPS);\n-  static void exit(oop obj, BasicLock* lock, Thread* THREAD);\n+  static void enter(Handle obj, BasicLock* lock, JavaThread* current);\n+  static void exit(oop obj, BasicLock* lock, JavaThread* current);\n@@ -96,2 +96,2 @@\n-  static void jni_enter(Handle obj, TRAPS);\n-  static void jni_exit(oop obj, Thread* THREAD);\n+  static void jni_enter(Handle obj, JavaThread* current);\n+  static void jni_exit(oop obj, TRAPS);\n@@ -104,2 +104,2 @@\n-  static bool quick_notify(oopDesc* obj, Thread* self, bool All);\n-  static bool quick_enter(oop obj, Thread* self, BasicLock* Lock);\n+  static bool quick_notify(oopDesc* obj, JavaThread* current, bool All);\n+  static bool quick_enter(oop obj, JavaThread* current, BasicLock* Lock);\n@@ -108,3 +108,3 @@\n-  \/\/ that needs to wait() on a java-level object but that can't risk\n-  \/\/ throwing unexpected InterruptedExecutionExceptions.\n-  static void wait_uninterruptibly(Handle obj, jlong Millis, Thread* THREAD);\n+  \/\/ that needs to wait() on a java-level object but must not respond\n+  \/\/ to interrupt requests and doesn't timeout.\n+  static void wait_uninterruptibly(Handle obj, JavaThread* current);\n@@ -115,2 +115,2 @@\n-  static intx complete_exit(Handle obj, TRAPS);\n-  static void reenter (Handle obj, intx recursions, TRAPS);\n+  static intx complete_exit(Handle obj, JavaThread* current);\n+  static void reenter (Handle obj, intx recursions, JavaThread* current);\n@@ -119,1 +119,1 @@\n-  static ObjectMonitor* inflate(Thread* self, oop obj, const InflateCause cause);\n+  static ObjectMonitor* inflate(Thread* current, oop obj, const InflateCause cause);\n@@ -127,1 +127,1 @@\n-  static intptr_t FastHashCode(Thread* self, oop obj);\n+  static intptr_t FastHashCode(Thread* current, oop obj);\n@@ -130,1 +130,1 @@\n-  static bool current_thread_holds_lock(JavaThread* thread, Handle h_obj);\n+  static bool current_thread_holds_lock(JavaThread* current, Handle h_obj);\n@@ -135,1 +135,1 @@\n-  static void release_monitors_owned_by_thread(TRAPS);\n+  static void release_monitors_owned_by_thread(JavaThread* current);\n@@ -146,1 +146,1 @@\n-  static void chk_for_block_req(JavaThread* self, const char* op_name,\n+  static void chk_for_block_req(JavaThread* current, const char* op_name,\n@@ -149,1 +149,1 @@\n-  static size_t deflate_monitor_list(Thread* self, LogStream* ls,\n+  static size_t deflate_monitor_list(Thread* current, LogStream* ls,\n@@ -186,1 +186,1 @@\n-  static void handle_sync_on_value_based_class(Handle obj, Thread* current);\n+  static void handle_sync_on_value_based_class(Handle obj, JavaThread* current);\n@@ -196,3 +196,3 @@\n-  Thread*   _thread;\n-  Handle    _obj;\n-  BasicLock _lock;\n+  JavaThread* _thread;\n+  Handle      _obj;\n+  BasicLock   _lock;\n@@ -200,1 +200,1 @@\n-  ObjectLocker(Handle obj, Thread* thread);\n+  ObjectLocker(Handle obj, JavaThread* current);\n@@ -206,1 +206,1 @@\n-  void wait_uninterruptibly(TRAPS) { ObjectSynchronizer::wait_uninterruptibly(_obj, 0, CHECK); }\n+  void wait_uninterruptibly(JavaThread* current) { ObjectSynchronizer::wait_uninterruptibly(_obj, current); }\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.hpp","additions":24,"deletions":24,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -516,1 +516,1 @@\n-    public final int objectMonitorSucc = getFieldOffset(\"ObjectMonitor::_succ\", Integer.class, \"Thread*\", -1, jdk13Backport);\n+    public final int objectMonitorSucc = getFieldOffset(\"ObjectMonitor::_succ\", Integer.class, JDK < 17 ? \"Thread*\" : \"JavaThread*\", -1, jdk13Backport);\n","filename":"src\/jdk.internal.vm.compiler\/share\/classes\/org.graalvm.compiler.hotspot\/src\/org\/graalvm\/compiler\/hotspot\/GraalHotSpotVMConfig.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -67,1 +67,1 @@\n-    Thread* THREAD = Thread::current();\n+    JavaThread* THREAD = JavaThread::current();\n","filename":"test\/hotspot\/gtest\/oops\/test_markWord.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}