{"files":[{"patch":"@@ -191,4 +191,1 @@\n-  \/\/ Request at least one eden region to ensure progress.\n-  bool after_gc = true;\n-                             _analytics->predict_rs_length(for_young_only_phase),\n-                             after_gc);\n+                             _analytics->predict_rs_length(for_young_only_phase));\n@@ -198,1 +195,1 @@\n-void G1Policy::update_young_length_bounds(size_t pending_cards, size_t rs_length, bool after_gc) {\n+void G1Policy::update_young_length_bounds(size_t pending_cards, size_t rs_length) {\n@@ -201,1 +198,1 @@\n-  uint new_young_list_desired_length = calculate_young_desired_length(pending_cards, rs_length, after_gc);\n+  uint new_young_list_desired_length = calculate_young_desired_length(pending_cards, rs_length);\n@@ -240,1 +237,1 @@\n-uint G1Policy::calculate_young_desired_length(size_t pending_cards, size_t rs_length, bool after_gc) const {\n+uint G1Policy::calculate_young_desired_length(size_t pending_cards, size_t rs_length) const {\n@@ -254,3 +251,7 @@\n-  \/\/ don't go below any user-defined minimum bound; but we might have already\n-  \/\/ allocated more than that for various reasons. In this case, use that.\n-  uint absolute_min_young_length = MAX2(allocated_young_length, min_young_length_by_sizer);\n+  \/\/ don't go below any user-defined minimum bound.  Also, we must have at least\n+  \/\/ one eden region, to ensure progress. But when revising during the ensuing\n+  \/\/ mutator phase we might have already allocated more than either of those, in\n+  \/\/ which case use that.\n+  uint absolute_min_young_length = MAX3(min_young_length_by_sizer,\n+                                        survivor_length + 1,\n+                                        allocated_young_length);\n@@ -262,4 +263,0 @@\n-  \/\/ The absolute minimum young gen length (as provided by the young gen sizer) ensures\n-  \/\/ that we desire at least one young gen region.\n-  assert(absolute_min_young_length > 0, \"must be\");\n-\n@@ -294,14 +291,1 @@\n-  \/\/ After a garbage collection, make room for at least one eden region (i.e. in addition to\n-  \/\/ already allocated survivor regions).\n-  \/\/ This may make desired regions go over absolute maximum length by the heap sizer, however\n-  \/\/ the immediate full gcs after that young gc (particularly on small heaps) are worse.\n-  if (after_gc && (allocated_young_length >= desired_young_length)) {\n-   log_trace(gc, ergo, heap)(\"Young desired length: Desired young region length less than already \"\n-                              \"allocated region length, but requesting one eden region minimum. \"\n-                              \"Expanding desired young length from %u to %u.\",\n-                              desired_young_length,\n-                              allocated_young_length + 1);\n-    desired_young_length = allocated_young_length + 1;\n-  }\n-\n-  log_trace(gc, ergo, heap)(\"Young desired length %u (after gc: %s) \"\n+  log_trace(gc, ergo, heap)(\"Young desired length %u \"\n@@ -314,2 +298,1 @@\n-                            desired_young_length, BOOL_TO_STR(after_gc),\n-                            survivor_length,\n+                            desired_young_length, survivor_length,\n@@ -549,4 +532,1 @@\n-  \/\/ We are only revising young gen length to meet pause time goal, so do not request\n-  \/\/ at least one eden region for progress. At this point we actually want to run into\n-  \/\/ a GC soon if young gen is already (too) large.\n-  update_young_length_bounds(pending_cards, rs_length, false \/* need_one_eden_region *\/);\n+  update_young_length_bounds(pending_cards, rs_length);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.cpp","additions":14,"deletions":34,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -208,2 +208,1 @@\n-  \/\/ the prediction model. If after_gc is set, make sure that there is one eden region\n-  \/\/ available (if there is enough space) to guarantee some progress.\n+  \/\/ the prediction model.\n@@ -211,1 +210,1 @@\n-  void update_young_length_bounds(size_t pending_cards, size_t rs_length, bool after_gc);\n+  void update_young_length_bounds(size_t pending_cards, size_t rs_length);\n@@ -239,1 +238,1 @@\n-  uint calculate_young_desired_length(size_t pending_cards, size_t rs_length, bool after_gc) const;\n+  uint calculate_young_desired_length(size_t pending_cards, size_t rs_length) const;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.hpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -81,1 +81,0 @@\n-gc\/g1\/TestVerifyGCType.java 8298215 linux-all,macosx-all\n@@ -153,0 +152,1 @@\n+vmTestbase\/nsk\/jvmti\/InterruptThread\/intrpthrd003\/TestDescription.java 8288911 macosx-x64\n@@ -168,0 +168,2 @@\n+vmTestbase\/nsk\/stress\/strace\/strace002.java 8288912 macosx-x64,windows-x64\n+vmTestbase\/nsk\/stress\/strace\/strace003.java 8297824 macosx-x64,windows-x64\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -192,1 +192,1 @@\n-        verifyType(ci, expectBefore, VERIFY_BEFORE);\n+        verifyType(ci, expectBefore, VERIFY_BEFORE, data);\n@@ -194,1 +194,1 @@\n-        verifyType(ci, expectDuring, VERIFY_DURING);\n+        verifyType(ci, expectDuring, VERIFY_DURING, data);\n@@ -196,1 +196,1 @@\n-        verifyType(ci, expectAfter, VERIFY_AFTER);\n+        verifyType(ci, expectAfter, VERIFY_AFTER, data);\n@@ -199,1 +199,1 @@\n-    private static void verifyType(CollectionInfo ci, boolean shouldExist, String pattern) {\n+    private static void verifyType(CollectionInfo ci, boolean shouldExist, String pattern, String data) {\n@@ -201,1 +201,1 @@\n-            Asserts.assertTrue(ci.containsVerification(pattern), \"Missing expected verification pattern \" + pattern + \" for: \" + ci.getName());\n+            Asserts.assertTrue(ci.containsVerification(pattern), \"Missing expected verification pattern \" + pattern + \" for: \" + ci.getName() + \"\\n\" + data);\n@@ -203,1 +203,1 @@\n-            Asserts.assertFalse(ci.containsVerification(pattern), \"Found unexpected verification pattern \" + pattern + \" for: \" + ci.getName());\n+            Asserts.assertFalse(ci.containsVerification(pattern), \"Found unexpected verification pattern \" + pattern + \" for: \" + ci.getName() + \"\\n\" + data);\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestVerifyGCType.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -190,0 +190,1 @@\n+java\/awt\/event\/KeyEvent\/KeyTyped\/CtrlASCII.java 8298910 linux-all\n@@ -663,2 +664,0 @@\n-javax\/swing\/text\/DefaultCaret\/HidingSelection\/HidingSelectionTest.java 8194048 windows-all\n-javax\/swing\/text\/DefaultCaret\/HidingSelection\/MultiSelectionTest.java 8213562 linux-all\n@@ -724,0 +723,1 @@\n+java\/util\/concurrent\/ExecutorService\/CloseTest.java             8288899 macosx-aarch64\n","filename":"test\/jdk\/ProblemList.txt","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}