{"files":[{"patch":"@@ -74,2 +74,0 @@\n-  _predicted_surviving_bytes_from_survivor(0),\n-  _predicted_surviving_bytes_from_old(0),\n@@ -566,1 +564,0 @@\n-  update_survival_estimates_for_next_collection();\n@@ -881,2 +878,0 @@\n-  update_survival_estimates_for_next_collection();\n-\n@@ -1561,82 +1556,0 @@\n-\/\/ Number of regions required to store the given number of bytes, taking\n-\/\/ into account the target amount of wasted space in PLABs.\n-static size_t get_num_regions_adjust_for_plab_waste(size_t byte_count) {\n-  size_t byte_count_adjusted = byte_count * (size_t)(100 + TargetPLABWastePct) \/ 100.0;\n-\n-  \/\/ Round up the region count\n-  return (byte_count_adjusted + HeapRegion::GrainBytes - 1) \/ HeapRegion::GrainBytes;\n-}\n-\n-bool G1Policy::preventive_collection_required(uint alloc_region_count) {\n-  if (!G1UsePreventiveGC || !Universe::is_fully_initialized()) {\n-    \/\/ Don't attempt any preventive GC's if the feature is disabled,\n-    \/\/ or before initialization is complete.\n-    return false;\n-  }\n-\n-  if (_g1h->young_regions_count() == 0 && !_collection_set->has_candidates()) {\n-    return false;\n-  }\n-\n-  uint eden_count = _g1h->eden_regions_count();\n-  size_t const eden_surv_bytes_pred = _eden_surv_rate_group->accum_surv_rate_pred(eden_count) * HeapRegion::GrainBytes;\n-  size_t const total_young_predicted_surviving_bytes = eden_surv_bytes_pred + _predicted_surviving_bytes_from_survivor;\n-\n-  uint required_regions = (uint)(get_num_regions_adjust_for_plab_waste(total_young_predicted_surviving_bytes) +\n-                                get_num_regions_adjust_for_plab_waste(_predicted_surviving_bytes_from_old));\n-\n-  if (required_regions > _g1h->num_free_or_available_regions() - alloc_region_count) {\n-    log_debug(gc, ergo, cset)(\"Preventive GC, insufficient free or available regions. \"\n-                              \"Predicted need %u. Curr Eden %u (Pred %u). Curr Survivor %u (Pred %u). Curr Old %u (Pred %u) Free or Avail %u (Free %u) Alloc %u\",\n-                              required_regions,\n-                              eden_count,\n-                              (uint)get_num_regions_adjust_for_plab_waste(eden_surv_bytes_pred),\n-                              _g1h->survivor_regions_count(),\n-                              (uint)get_num_regions_adjust_for_plab_waste(_predicted_surviving_bytes_from_survivor),\n-                              _g1h->old_regions_count(),\n-                              (uint)get_num_regions_adjust_for_plab_waste(_predicted_surviving_bytes_from_old),\n-                              _g1h->num_free_or_available_regions(),\n-                              _g1h->num_free_regions(),\n-                              alloc_region_count);\n-\n-    return true;\n-  }\n-\n-  return false;\n-}\n-\n-void G1Policy::update_survival_estimates_for_next_collection() {\n-  \/\/ Predict the number of bytes of surviving objects from survivor and old\n-  \/\/ regions and update the associated members.\n-\n-  \/\/ Survivor regions\n-  size_t survivor_bytes = 0;\n-  const GrowableArray<HeapRegion*>* survivor_regions = _g1h->survivor()->regions();\n-  for (GrowableArrayIterator<HeapRegion*> it = survivor_regions->begin();\n-       it != survivor_regions->end();\n-       ++it) {\n-    survivor_bytes += predict_bytes_to_copy(*it);\n-  }\n-\n-  _predicted_surviving_bytes_from_survivor = survivor_bytes;\n-\n-  \/\/ Old regions\n-  if (!_collection_set->has_candidates()) {\n-    _predicted_surviving_bytes_from_old = 0;\n-    return;\n-  }\n-\n-  \/\/ Use the minimum old gen collection set as conservative estimate for the number\n-  \/\/ of regions to take for this calculation.\n-  G1CollectionSetCandidates *candidates = _collection_set->candidates();\n-  uint iterate_count = MIN2(candidates->num_remaining(), calc_min_old_cset_length(candidates));\n-  uint current_index = candidates->cur_idx();\n-  size_t old_bytes = 0;\n-  for (uint i = 0; i < iterate_count; i++) {\n-    HeapRegion *region = candidates->at(current_index + i);\n-    old_bytes += predict_bytes_to_copy(region);\n-  }\n-\n-  _predicted_surviving_bytes_from_old = old_bytes;\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.cpp","additions":0,"deletions":87,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -104,5 +104,0 @@\n-  \/\/ These values are predictions of how much we think will survive in each\n-  \/\/ section of the heap.\n-  size_t _predicted_surviving_bytes_from_survivor;\n-  size_t _predicted_surviving_bytes_from_old;\n-\n@@ -362,5 +357,0 @@\n-  \/\/ Returns whether a collection should be done proactively, taking into\n-  \/\/ account the current number of free regions and the expected survival\n-  \/\/ rates in each section of the heap.\n-  bool preventive_collection_required(uint region_count);\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.hpp","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -81,1 +81,0 @@\n-gc\/metaspace\/CompressedClassSpaceSizeInJmapHeap.java 8241293,8298073 macosx-x64,macosx-aarch64\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -128,2 +128,1 @@\n-                                                        \"-XX:+UnlockDiagnosticVMOptions\",\n-                                                        \"-XX:-G1UsePreventiveGC\"});\n+                                                        \"-XX:+UnlockDiagnosticVMOptions\"});\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestVerifyGCType.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -430,1 +430,0 @@\n-java\/awt\/Toolkit\/DesktopProperties\/rfe4758438.java 8193547 linux-all\n@@ -591,1 +590,6 @@\n-javax\/net\/ssl\/DTLS\/CipherSuite.java                             8202059 macosx-x64\n+javax\/net\/ssl\/SSLEngine\/TestAllSuites.java                      8298874 generic-all\n+javax\/net\/ssl\/SSLEngine\/IllegalRecordVersion.java               8298873 generic-all\n+javax\/net\/ssl\/SSLEngine\/EngineCloseOnAlert.java                 8298868 generic-all\n+javax\/net\/ssl\/SSLEngine\/ConnectionTest.java                     8298869 generic-all\n+javax\/net\/ssl\/SSLEngine\/CheckStatus.java                        8298872 generic-all\n+javax\/net\/ssl\/SSLEngine\/Basics.java                             8298867 generic-all\n@@ -671,1 +675,1 @@\n-java\/awt\/Mouse\/EnterExitEvents\/DragWindowTest.java 8297296 macosx-all\n+java\/awt\/Mouse\/EnterExitEvents\/DragWindowTest.java 8298823 macosx-all\n","filename":"test\/jdk\/ProblemList.txt","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"}]}