{"files":[{"patch":"@@ -2073,17 +2073,27 @@\n-  MutexLocker ml(THREAD, InvokeMethodTable_lock);\n-  InvokeMethodKey key(signature, iid_as_int);\n-  Method** met = _invoke_method_intrinsic_table.get(key);\n-  if (met != nullptr) {\n-    return *met;\n-  }\n-\n-  methodHandle m = Method::make_method_handle_intrinsic(iid, signature, CHECK_NULL);\n-  if (!Arguments::is_interpreter_only() || iid == vmIntrinsics::_linkToNative) {\n-      \/\/ Generate a compiled form of the MH intrinsic\n-      \/\/ linkToNative doesn't have interpreter-specific implementation, so always has to go through compiled version.\n-      AdapterHandlerLibrary::create_native_wrapper(m);\n-      \/\/ Check if have the compiled code.\n-      if (!m->has_compiled_code()) {\n-        THROW_MSG_NULL(vmSymbols::java_lang_VirtualMachineError(),\n-                       \"Out of space in CodeCache for method handle intrinsic\");\n-      }\n+  {\n+    MutexLocker ml(THREAD, InvokeMethodTable_lock);\n+    InvokeMethodKey key(signature, iid_as_int);\n+    Method** met = _invoke_method_intrinsic_table.get(key);\n+    if (met != nullptr) {\n+      return *met;\n+    }\n+\n+    bool throw_error = false;\n+    methodHandle m = Method::make_method_handle_intrinsic(iid, signature, CHECK_NULL);\n+    if (!Arguments::is_interpreter_only() || iid == vmIntrinsics::_linkToNative) {\n+        \/\/ Generate a compiled form of the MH intrinsic\n+        \/\/ linkToNative doesn't have interpreter-specific implementation, so always has to go through compiled version.\n+        AdapterHandlerLibrary::create_native_wrapper(m);\n+        \/\/ Check if have the compiled code.\n+        throw_error = (!m->has_compiled_code());\n+    }\n+\n+    if (!throw_error) {\n+      signature->make_permanent(); \/\/ The signature is never unloaded.\n+      bool created = _invoke_method_intrinsic_table.put(key, m());\n+      assert(created, \"must be since we still hold the lock\");\n+      assert(Arguments::is_interpreter_only() || (m->has_compiled_code() &&\n+             m->code()->entry_point() == m->from_compiled_entry()),\n+             \"MH intrinsic invariant\");\n+      return m();\n+    }\n@@ -2092,7 +2102,3 @@\n-  signature->make_permanent(); \/\/ The signature is never unloaded.\n-  bool created = _invoke_method_intrinsic_table.put(key, m());\n-  assert(created, \"must be since we still hold the lock\");\n-  assert(Arguments::is_interpreter_only() || (m->has_compiled_code() &&\n-         m->code()->entry_point() == m->from_compiled_entry()),\n-         \"MH intrinsic invariant\");\n-  return m();\n+  \/\/ Throw error outside of the lock.\n+  THROW_MSG_NULL(vmSymbols::java_lang_VirtualMachineError(),\n+                 \"Out of space in CodeCache for method handle intrinsic\");\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":30,"deletions":24,"binary":false,"changes":54,"status":"modified"}]}