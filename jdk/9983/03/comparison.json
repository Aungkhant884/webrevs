{"files":[{"patch":"@@ -2067,1 +2067,0 @@\n-  methodHandle empty;\n@@ -2074,2 +2073,0 @@\n-  Method** met;\n-  InvokeMethodKey key(signature, iid_as_int);\n@@ -2078,1 +2075,2 @@\n-    met = _invoke_method_intrinsic_table.get(key);\n+    InvokeMethodKey key(signature, iid_as_int);\n+    Method** met = _invoke_method_intrinsic_table.get(key);\n@@ -2082,1 +2080,0 @@\n-  }\n@@ -2084,23 +2081,21 @@\n-  methodHandle m = Method::make_method_handle_intrinsic(iid, signature, CHECK_NULL);\n-  if (!Arguments::is_interpreter_only() || iid == vmIntrinsics::_linkToNative) {\n-      \/\/ Generate a compiled form of the MH intrinsic\n-      \/\/ linkToNative doesn't have interpreter-specific implementation, so always has to go through compiled version.\n-      AdapterHandlerLibrary::create_native_wrapper(m);\n-      \/\/ Check if have the compiled code.\n-      if (!m->has_compiled_code()) {\n-        THROW_MSG_NULL(vmSymbols::java_lang_VirtualMachineError(),\n-                       \"Out of space in CodeCache for method handle intrinsic\");\n-      }\n-  }\n-  \/\/ Now grab the lock.  We might have to throw away the new method,\n-  \/\/ if a racing thread has managed to install one at the same time.\n-  {\n-    MutexLocker ml(THREAD, InvokeMethodTable_lock);\n-    signature->make_permanent(); \/\/ The signature is never unloaded.\n-    bool created;\n-    met = _invoke_method_intrinsic_table.put_if_absent(key, m(), &created);\n-    Method* saved_method = *met;\n-    assert(Arguments::is_interpreter_only() || (saved_method->has_compiled_code() &&\n-         saved_method->code()->entry_point() == saved_method->from_compiled_entry()),\n-         \"MH intrinsic invariant\");\n-    return saved_method;\n+    bool throw_error = false;\n+    \/\/ This function could get an OOM but it is safe to call inside of a lock because\n+    \/\/ throwing OutOfMemoryError doesn't call Java code.\n+    methodHandle m = Method::make_method_handle_intrinsic(iid, signature, CHECK_NULL);\n+    if (!Arguments::is_interpreter_only() || iid == vmIntrinsics::_linkToNative) {\n+        \/\/ Generate a compiled form of the MH intrinsic\n+        \/\/ linkToNative doesn't have interpreter-specific implementation, so always has to go through compiled version.\n+        AdapterHandlerLibrary::create_native_wrapper(m);\n+        \/\/ Check if have the compiled code.\n+        throw_error = (!m->has_compiled_code());\n+    }\n+\n+    if (!throw_error) {\n+      signature->make_permanent(); \/\/ The signature is never unloaded.\n+      bool created = _invoke_method_intrinsic_table.put(key, m());\n+      assert(created, \"must be since we still hold the lock\");\n+      assert(Arguments::is_interpreter_only() || (m->has_compiled_code() &&\n+             m->code()->entry_point() == m->from_compiled_entry()),\n+             \"MH intrinsic invariant\");\n+      return m();\n+    }\n@@ -2108,0 +2103,4 @@\n+\n+  \/\/ Throw error outside of the lock.\n+  THROW_MSG_NULL(vmSymbols::java_lang_VirtualMachineError(),\n+                 \"Out of space in CodeCache for method handle intrinsic\");\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":27,"deletions":28,"binary":false,"changes":55,"status":"modified"}]}