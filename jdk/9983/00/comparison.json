{"files":[{"patch":"@@ -2067,1 +2067,0 @@\n-  methodHandle empty;\n@@ -2074,1 +2073,1 @@\n-  Method** met;\n+  MutexLocker ml(THREAD, InvokeMethodTable_lock);\n@@ -2076,6 +2075,3 @@\n-  {\n-    MutexLocker ml(THREAD, InvokeMethodTable_lock);\n-    met = _invoke_method_intrinsic_table.get(key);\n-    if (met != nullptr) {\n-      return *met;\n-    }\n+  Method** met = _invoke_method_intrinsic_table.get(key);\n+  if (met != nullptr) {\n+   return *met;\n@@ -2095,10 +2091,6 @@\n-  \/\/ Now grab the lock.  We might have to throw away the new method,\n-  \/\/ if a racing thread has managed to install one at the same time.\n-  {\n-    MutexLocker ml(THREAD, InvokeMethodTable_lock);\n-    signature->make_permanent(); \/\/ The signature is never unloaded.\n-    bool created;\n-    met = _invoke_method_intrinsic_table.put_if_absent(key, m(), &created);\n-    Method* saved_method = *met;\n-    assert(Arguments::is_interpreter_only() || (saved_method->has_compiled_code() &&\n-         saved_method->code()->entry_point() == saved_method->from_compiled_entry()),\n+\n+  signature->make_permanent(); \/\/ The signature is never unloaded.\n+  bool created = _invoke_method_intrinsic_table.put(key, m());\n+  assert(created, \"must be since we still hold the lock\");\n+  assert(Arguments::is_interpreter_only() || (m->has_compiled_code() &&\n+         m->code()->entry_point() == m->from_compiled_entry()),\n@@ -2106,2 +2098,1 @@\n-    return saved_method;\n-  }\n+  return m();\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":11,"deletions":20,"binary":false,"changes":31,"status":"modified"}]}