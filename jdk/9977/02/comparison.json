{"files":[{"patch":"@@ -2418,0 +2418,48 @@\n+static bool check_all_uses(Node* n, bool (*predicate)(Node*)) {\n+  for (DUIterator i = n->outs(); n->has_out(i); i++) {\n+    Node* use = n->out(i);\n+    if (!predicate(use)) {\n+      return false;\n+    }\n+  }\n+  return true;\n+}\n+\n+static bool is_base_pattern(Node* n, Node* m) {\n+\n+#ifdef _LP64\n+  \/\/ The lea patterns\n+  if (n->Opcode() == Op_AddI) {\n+    if (VM_Version::supports_fast_2op_lea() &&\n+        m->Opcode() == Op_LShiftI && m->in(2)->find_int_con(7) <= 3 &&\n+        check_all_uses(m, [](Node* n){ return n->Opcode() == Op_AddI; })) {\n+      return true;\n+    }\n+    if (VM_Version::supports_fast_3op_lea() && m->Opcode() == Op_AddI &&\n+        check_all_uses(m, [](Node* n){\n+          return n->Opcode() == Op_AddI && n->in(2)->Opcode() == Op_ConI;\n+        })) {\n+      return true;\n+    }\n+  }\n+  if (n->Opcode() == Op_AddL) {\n+    if (VM_Version::supports_fast_2op_lea() &&\n+        m->Opcode() == Op_LShiftL && m->in(2)->find_int_con(7) <= 3 &&\n+        check_all_uses(m, [](Node* n){ return n->Opcode() == Op_AddL; })) {\n+      return true;\n+    }\n+    if (VM_Version::supports_fast_3op_lea() && m->Opcode() == Op_AddL &&\n+        check_all_uses(m, [](Node* n){\n+          return n->Opcode() == Op_AddL && n->in(2)->Opcode() == Op_ConL &&\n+                 AbstractAssembler::is_simm32(n->in(2)->get_long());\n+        })) {\n+      return true;\n+    }\n+  }\n+#endif\n+\n+  return false;\n+}\n+\n+\/\/ This function tries to check the bmi instruction patterns and clone the inputs\n+\/\/ to preserve the matchability\n@@ -2420,11 +2468,26 @@\n-  if (n != NULL && m != NULL) {\n-    if (m->Opcode() == Op_LoadI) {\n-      FusedPatternMatcher<TypeInt> bmii(n, m, Op_ConI);\n-      return bmii.match(Op_AndI, -1, Op_SubI,  1,  0)  ||\n-             bmii.match(Op_AndI, -1, Op_AddI, -1, -1)  ||\n-             bmii.match(Op_XorI, -1, Op_AddI, -1, -1);\n-    } else if (m->Opcode() == Op_LoadL) {\n-      FusedPatternMatcher<TypeLong> bmil(n, m, Op_ConL);\n-      return bmil.match(Op_AndL, -1, Op_SubL,  1,  0) ||\n-             bmil.match(Op_AndL, -1, Op_AddL, -1, -1) ||\n-             bmil.match(Op_XorL, -1, Op_AddL, -1, -1);\n+  if (n == nullptr || m == nullptr) {\n+    return false;\n+  }\n+  if (n->Opcode() == Op_AndI || n->Opcode() == Op_XorI) {\n+    \/\/ If all uses of a not are and's, then clone the not node\n+    if (n->Opcode() == Op_AndI && m->Opcode() == Op_XorI &&\n+        m->in(2)->find_int_con(0) == -1 &&\n+        check_all_uses(m, [](Node* n){ return n->Opcode() == Op_AndI; })) {\n+      return true;\n+    }\n+    \/\/ Normally we want to clone the long arm, but if the short\n+    \/\/ arm is a load we want to clone it, too\n+    if (m->Opcode() != Op_LoadI) {\n+      Node* other = n->in((n->in(1) == m) ? 2 : 1);\n+      m = other;\n+    }\n+    FusedPatternMatcher<TypeInt> bmii(n, m, Op_ConI);\n+    return bmii.match(Op_AndI, -1, Op_SubI,  1,  0)  ||\n+           bmii.match(Op_AndI, -1, Op_AddI, -1, -1)  ||\n+           bmii.match(Op_XorI, -1, Op_AddI, -1, -1);\n+  } else if (n->Opcode() == Op_AndL || n->Opcode() == Op_XorL) {\n+    \/\/ See above\n+    if (n->Opcode() == Op_AndL && m->Opcode() == Op_XorL &&\n+        m->in(2)->find_long_con(0) == -1 &&\n+        check_all_uses(m, [](Node* n){ return n->Opcode() == Op_AndL; })) {\n+      return true;\n@@ -2432,0 +2495,8 @@\n+    if (m->Opcode() != Op_LoadL) {\n+      Node* other = n->in((n->in(1) == m) ? 2 : 1);\n+      m = other;\n+    }\n+    FusedPatternMatcher<TypeLong> bmil(n, m, Op_ConL);\n+    return bmil.match(Op_AndL, -1, Op_SubL,  1,  0) ||\n+           bmil.match(Op_AndL, -1, Op_AddL, -1, -1) ||\n+           bmil.match(Op_XorL, -1, Op_AddL, -1, -1);\n@@ -2438,0 +2509,4 @@\n+  if (is_base_pattern(n, m)) {\n+    mstack.push(m, Visit);\n+    return true;\n+  }\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":86,"deletions":11,"binary":false,"changes":97,"status":"modified"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.vm.compiler.x86;\n+\n+import java.util.concurrent.TimeUnit;\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(3)\n+public class CloneNodes {\n+    static final int[] x = new int[1024];\n+    int y, z;\n+\n+    @Benchmark\n+    public void testLea(Blackhole bh) {\n+        for (int i = 0; i < x.length; i++) {\n+            int temp = x[i] << 2;\n+            bh.consume(temp + 3);\n+            bh.consume(temp + 7);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void testAndn(Blackhole bh) {\n+        int y = this.y; int z = this.z;\n+        for (int i = 0; i < x.length; i++) {\n+            int temp = ~x[i];\n+            bh.consume(temp & y);\n+            bh.consume(temp & z);\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/x86\/CloneNodes.java","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"}]}