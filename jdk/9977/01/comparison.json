{"files":[{"patch":"@@ -2420,0 +2420,48 @@\n+static bool check_all_uses(Node* n, bool (*predicate)(Node*)) {\n+  for (DUIterator i = n->outs(); n->has_out(i); i++) {\n+    Node* use = n->out(i);\n+    if (!predicate(use)) {\n+      return false;\n+    }\n+  }\n+  return true;\n+}\n+\n+static bool is_base_pattern(Node* n, Node* m) {\n+\n+#ifdef _LP64\n+  \/\/ The lea patterns\n+  if (n->Opcode() == Op_AddI) {\n+    if (VM_Version::supports_fast_2op_lea() &&\n+        m->Opcode() == Op_LShiftI && m->in(2)->find_int_con(7) <= 3 &&\n+        check_all_uses(m, [](Node* n){ return n->Opcode() == Op_AddI; })) {\n+      return true;\n+    }\n+    if (VM_Version::supports_fast_3op_lea() && m->Opcode() == Op_AddI &&\n+        check_all_uses(m, [](Node* n){\n+          return n->Opcode() == Op_AddI && n->in(2)->Opcode() == Op_ConI;\n+        })) {\n+      return true;\n+    }\n+  }\n+  if (n->Opcode() == Op_AddL) {\n+    if (VM_Version::supports_fast_2op_lea() &&\n+        m->Opcode() == Op_LShiftL && m->in(2)->find_int_con(7) <= 3 &&\n+        check_all_uses(m, [](Node* n){ return n->Opcode() == Op_AddL; })) {\n+      return true;\n+    }\n+    if (VM_Version::supports_fast_3op_lea() && m->Opcode() == Op_AddL &&\n+        check_all_uses(m, [](Node* n){\n+          return n->Opcode() == Op_AddL && n->in(2)->Opcode() == Op_ConL &&\n+                 AbstractAssembler::is_simm32(n->in(2)->get_long());\n+        })) {\n+      return true;\n+    }\n+  }\n+#endif\n+\n+  return false;\n+}\n+\n+\/\/ This function tries to check the bmi instruction patterns and clone the inputs\n+\/\/ to preserve the matchability\n@@ -2422,11 +2470,26 @@\n-  if (n != NULL && m != NULL) {\n-    if (m->Opcode() == Op_LoadI) {\n-      FusedPatternMatcher<TypeInt> bmii(n, m, Op_ConI);\n-      return bmii.match(Op_AndI, -1, Op_SubI,  1,  0)  ||\n-             bmii.match(Op_AndI, -1, Op_AddI, -1, -1)  ||\n-             bmii.match(Op_XorI, -1, Op_AddI, -1, -1);\n-    } else if (m->Opcode() == Op_LoadL) {\n-      FusedPatternMatcher<TypeLong> bmil(n, m, Op_ConL);\n-      return bmil.match(Op_AndL, -1, Op_SubL,  1,  0) ||\n-             bmil.match(Op_AndL, -1, Op_AddL, -1, -1) ||\n-             bmil.match(Op_XorL, -1, Op_AddL, -1, -1);\n+  if (n == nullptr || m == nullptr) {\n+    return false;\n+  }\n+  if (n->Opcode() == Op_AndI || n->Opcode() == Op_XorI) {\n+    \/\/ If all uses of a not are and's, then clone the not node\n+    if (n->Opcode() == Op_AndI && m->Opcode() == Op_XorI &&\n+        m->in(2)->find_int_con(0) == -1 &&\n+        check_all_uses(m, [](Node* n){ return n->Opcode() == Op_AndI; })) {\n+      return true;\n+    }\n+    \/\/ Normally we want to clone the long arm, but if the short\n+    \/\/ arm is a load we want to clone it, too\n+    if (m->Opcode() != Op_LoadI) {\n+      Node* other = n->in((n->in(1) == m) ? 2 : 1);\n+      m = other;\n+    }\n+    FusedPatternMatcher<TypeInt> bmii(n, m, Op_ConI);\n+    return bmii.match(Op_AndI, -1, Op_SubI,  1,  0)  ||\n+           bmii.match(Op_AndI, -1, Op_AddI, -1, -1)  ||\n+           bmii.match(Op_XorI, -1, Op_AddI, -1, -1);\n+  } else if (n->Opcode() == Op_AndL || n->Opcode() == Op_XorL) {\n+    \/\/ See above\n+    if (n->Opcode() == Op_AndL && m->Opcode() == Op_XorL &&\n+        m->in(2)->find_long_con(0) == -1 &&\n+        check_all_uses(m, [](Node* n){ return n->Opcode() == Op_AndL; })) {\n+      return true;\n@@ -2434,0 +2497,8 @@\n+    if (m->Opcode() != Op_LoadL) {\n+      Node* other = n->in((n->in(1) == m) ? 2 : 1);\n+      m = other;\n+    }\n+    FusedPatternMatcher<TypeLong> bmil(n, m, Op_ConL);\n+    return bmil.match(Op_AndL, -1, Op_SubL,  1,  0) ||\n+           bmil.match(Op_AndL, -1, Op_AddL, -1, -1) ||\n+           bmil.match(Op_XorL, -1, Op_AddL, -1, -1);\n@@ -2440,0 +2511,4 @@\n+  if (is_base_pattern(n, m)) {\n+    mstack.push(m, Visit);\n+    return true;\n+  }\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":86,"deletions":11,"binary":false,"changes":97,"status":"modified"}]}