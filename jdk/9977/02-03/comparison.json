{"files":[{"patch":"@@ -2433,0 +2433,1 @@\n+    \/\/ Match n = a << b + c into lea n, [a << b + c] if all uses of a << b are AddI\n@@ -2438,0 +2439,2 @@\n+    \/\/ Match n = (a + b) + i into lea n, [a + b + i] if all uses of a + b are AddI with\n+    \/\/ a constant\n@@ -2444,2 +2447,2 @@\n-  }\n-  if (n->Opcode() == Op_AddL) {\n+  } else if (n->Opcode() == Op_AddL) {\n+    \/\/ Similar to AddI\n@@ -2468,3 +2471,0 @@\n-  if (n == nullptr || m == nullptr) {\n-    return false;\n-  }\n@@ -2472,1 +2472,1 @@\n-    \/\/ If all uses of a not are and's, then clone the not node\n+    \/\/ Match n = ~a & b into andn n, a, b if all uses of ~a are AndI\n@@ -2478,2 +2478,6 @@\n-    \/\/ Normally we want to clone the long arm, but if the short\n-    \/\/ arm is a load we want to clone it, too\n+    \/\/ Match n = a & (a - 1) into blsr n, a, this may reduce the liverange of a - 1\n+    \/\/ Match n = a & -a into blsi n, a, this may reduce the liverange of -a\n+    \/\/ Match n = a ^ (a - 1) into blsmsk n, a, this may reduce the liverange of a - 1\n+\n+    \/\/ If a is a load, since it appears 2 times in the match, we need to clone it\n+    \/\/ so the rules with memory operands can be matched\n@@ -2489,0 +2493,2 @@\n+\n+#ifdef _LP64\n@@ -2503,0 +2509,2 @@\n+#endif\n+\n@@ -2509,0 +2517,4 @@\n+  if (n == nullptr || m == nullptr) {\n+    return false;\n+  }\n+\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":20,"deletions":8,"binary":false,"changes":28,"status":"modified"}]}