{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,0 +47,1 @@\n+ *  . RSA PublicKey with an PKCS#1 encoding\n@@ -53,0 +54,1 @@\n+ *  . RSA PrivateKey with a PKCS#1 encoding\n@@ -98,2 +100,2 @@\n-    \/\/ Internal utility method for checking key algorithm\n-    private static void checkKeyAlgo(Key key, String expectedAlg)\n+    \/\/ pkg-private utility method for checking key algorithm\n+    static void checkKeyAlgo(Key key, String expectedAlg)\n@@ -268,5 +270,0 @@\n-        } else if (\"X.509\".equals(key.getFormat())) {\n-            RSAPublicKey translated = new RSAPublicKeyImpl(key.getEncoded());\n-            \/\/ ensure the key algorithm matches the current KeyFactory instance\n-            checkKeyAlgo(translated, type.keyAlgo);\n-            return translated;\n@@ -274,2 +271,3 @@\n-            throw new InvalidKeyException(\"Public keys must be instance \"\n-                + \"of RSAPublicKey or have X.509 encoding\");\n+            \/\/ create new key based on the format and encoding of current 'key'\n+            return RSAPublicKeyImpl.newKey(type, key.getFormat(),\n+                key.getEncoded());\n@@ -312,6 +310,0 @@\n-        } else if (\"PKCS#8\".equals(key.getFormat())) {\n-            RSAPrivateKey translated =\n-                RSAPrivateCrtKeyImpl.newKey(key.getEncoded());\n-            \/\/ ensure the key algorithm matches the current KeyFactory instance\n-            checkKeyAlgo(translated, type.keyAlgo);\n-            return translated;\n@@ -319,2 +311,2 @@\n-            throw new InvalidKeyException(\"Private keys must be instance \"\n-                + \"of RSAPrivate(Crt)Key or have PKCS#8 encoding\");\n+            return RSAPrivateCrtKeyImpl.newKey(type, key.getFormat(),\n+                    key.getEncoded());\n@@ -328,5 +320,2 @@\n-            X509EncodedKeySpec x509Spec = (X509EncodedKeySpec)keySpec;\n-            RSAPublicKey generated = new RSAPublicKeyImpl(x509Spec.getEncoded());\n-            \/\/ ensure the key algorithm matches the current KeyFactory instance\n-            checkKeyAlgo(generated, type.keyAlgo);\n-            return generated;\n+            return RSAPublicKeyImpl.newKey(type, \"X.509\",\n+                    ((X509EncodedKeySpec)keySpec).getEncoded());\n@@ -354,5 +343,2 @@\n-            PKCS8EncodedKeySpec pkcsSpec = (PKCS8EncodedKeySpec)keySpec;\n-            RSAPrivateKey generated = RSAPrivateCrtKeyImpl.newKey(pkcsSpec.getEncoded());\n-            \/\/ ensure the key algorithm matches the current KeyFactory instance\n-            checkKeyAlgo(generated, type.keyAlgo);\n-            return generated;\n+            return RSAPrivateCrtKeyImpl.newKey(type, \"PKCS#8\",\n+                    ((PKCS8EncodedKeySpec)keySpec).getEncoded());\n","filename":"src\/java.base\/share\/classes\/sun\/security\/rsa\/RSAKeyFactory.java","additions":14,"deletions":28,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -77,2 +77,4 @@\n-     * Generate a new key from its encoding. Returns a CRT key if possible\n-     * and a non-CRT key otherwise. Used by RSAKeyFactory.\n+     * Generate a new RSAPrivate(Crt)Key from the specified type,\n+     * format and encoding. Returns a CRT key if possible and a non-CRT\n+     * key otherwise.\n+     * Also used by SunPKCS11 provider.\n@@ -80,2 +82,2 @@\n-    public static RSAPrivateKey newKey(byte[] encoded)\n-            throws InvalidKeyException {\n+    public static RSAPrivateKey newKey(KeyType type, String format,\n+            byte[] encoded) throws InvalidKeyException {\n@@ -85,16 +87,34 @@\n-        RSAPrivateCrtKeyImpl key = new RSAPrivateCrtKeyImpl(encoded);\n-        \/\/ check all CRT-specific components are available, if any one\n-        \/\/ missing, return a non-CRT key instead\n-        if ((key.getPublicExponent().signum() == 0) ||\n-            (key.getPrimeExponentP().signum() == 0) ||\n-            (key.getPrimeExponentQ().signum() == 0) ||\n-            (key.getPrimeP().signum() == 0) ||\n-            (key.getPrimeQ().signum() == 0) ||\n-            (key.getCrtCoefficient().signum() == 0)) {\n-            return new RSAPrivateKeyImpl(\n-                key.type, key.keyParams,\n-                key.getModulus(),\n-                key.getPrivateExponent()\n-            );\n-        } else {\n-            return key;\n+        switch (format) {\n+        case \"PKCS#8\":\n+            RSAPrivateCrtKeyImpl key = new RSAPrivateCrtKeyImpl(encoded);\n+            RSAKeyFactory.checkKeyAlgo(key, type.keyAlgo);\n+            \/\/ check all CRT-specific components are available, if any one\n+            \/\/ missing, return a non-CRT key instead\n+            if ((key.getPublicExponent().signum() == 0) ||\n+                (key.getPrimeExponentP().signum() == 0) ||\n+                (key.getPrimeExponentQ().signum() == 0) ||\n+                (key.getPrimeP().signum() == 0) ||\n+                (key.getPrimeQ().signum() == 0) ||\n+                (key.getCrtCoefficient().signum() == 0)) {\n+                return new RSAPrivateKeyImpl(key.type, key.keyParams,\n+                    key.getModulus(), key.getPrivateExponent());\n+            } else return key;\n+        case \"PKCS#1\":\n+            try {\n+                BigInteger[] comps = parseASN1(encoded);\n+                if ((comps[1].signum() == 0) || (comps[3].signum() == 0) ||\n+                    (comps[4].signum() == 0) || (comps[5].signum() == 0) ||\n+                    (comps[6].signum() == 0) || (comps[7].signum() == 0)) {\n+                    return new RSAPrivateKeyImpl(type, null, comps[0],\n+                            comps[2]);\n+                } else {\n+                    return new RSAPrivateCrtKeyImpl(type, null, comps[0],\n+                            comps[1], comps[2], comps[3], comps[4], comps[5],\n+                            comps[6], comps[7]);\n+                }\n+            } catch (IOException ioe) {\n+                throw new InvalidKeyException(\"Invalid PKCS#1 encoding\", ioe);\n+            }\n+        default:\n+            throw new InvalidKeyException(\"Unsupported RSA Private(Crt)Key \"\n+                    + \"format: \" + format);\n@@ -129,1 +149,1 @@\n-    RSAPrivateCrtKeyImpl(byte[] encoded) throws InvalidKeyException {\n+    private RSAPrivateCrtKeyImpl(byte[] encoded) throws InvalidKeyException {\n@@ -261,0 +281,30 @@\n+    \/\/ utility method for parsing DER encoding of RSA private keys in PKCS#1\n+    \/\/ format as defined in RFC 8017 Appendix A.1.2, i.e. SEQ of version, n,\n+    \/\/ e, d, p, q, pe, qe, and coeff, and return the parsed components.\n+    private static BigInteger[] parseASN1(byte[] raw) throws IOException {\n+        DerValue derValue = new DerValue(raw);\n+        if (derValue.tag != DerValue.tag_Sequence) {\n+            throw new IOException(\"Not a SEQUENCE\");\n+        }\n+        int version = derValue.data.getInteger();\n+        if (version != 0) {\n+            throw new IOException(\"Version must be 0\");\n+        }\n+\n+        BigInteger[] result = new BigInteger[8]; \/\/ n, e, d, p, q, pe, qe, coeff\n+        \/*\n+         * Some implementations do not correctly encode ASN.1 INTEGER values\n+         * in 2's complement format, resulting in a negative integer when\n+         * decoded. Correct the error by converting it to a positive integer.\n+         *\n+         * See CR 6255949\n+         *\/\n+        for (int i = 0; i < result.length; i++) {\n+            result[i] = derValue.data.getPositiveBigInteger();\n+        }\n+        if (derValue.data.available() != 0) {\n+            throw new IOException(\"Extra data available\");\n+        }\n+        return result;\n+    }\n+\n@@ -263,29 +313,9 @@\n-            DerInputStream in = new DerInputStream(key);\n-            DerValue derValue = in.getDerValue();\n-            if (derValue.tag != DerValue.tag_Sequence) {\n-                throw new IOException(\"Not a SEQUENCE\");\n-            }\n-            DerInputStream data = derValue.data;\n-            int version = data.getInteger();\n-            if (version != 0) {\n-                throw new IOException(\"Version must be 0\");\n-            }\n-\n-            \/*\n-             * Some implementations do not correctly encode ASN.1 INTEGER values\n-             * in 2's complement format, resulting in a negative integer when\n-             * decoded. Correct the error by converting it to a positive integer.\n-             *\n-             * See CR 6255949\n-             *\/\n-            n = data.getPositiveBigInteger();\n-            e = data.getPositiveBigInteger();\n-            d = data.getPositiveBigInteger();\n-            p = data.getPositiveBigInteger();\n-            q = data.getPositiveBigInteger();\n-            pe = data.getPositiveBigInteger();\n-            qe = data.getPositiveBigInteger();\n-            coeff = data.getPositiveBigInteger();\n-            if (derValue.data.available() != 0) {\n-                throw new IOException(\"Extra data available\");\n-            }\n+            BigInteger[] comps = parseASN1(key);\n+            n = comps[0];\n+            e = comps[1];\n+            d = comps[2];\n+            p = comps[3];\n+            q = comps[4];\n+            pe = comps[5];\n+            qe = comps[6];\n+            coeff = comps[7];\n","filename":"src\/java.base\/share\/classes\/sun\/security\/rsa\/RSAPrivateCrtKeyImpl.java","additions":80,"deletions":50,"binary":false,"changes":130,"status":"modified"},{"patch":"@@ -69,2 +69,3 @@\n-     * Generate a new RSAPublicKey from the specified encoding.\n-     * Used by SunPKCS11 provider.\n+     * Generate a new RSAPublicKey from the specified type, format, and\n+     * encoding.\n+     * Also used by SunPKCS11 provider.\n@@ -72,3 +73,21 @@\n-    public static RSAPublicKey newKey(byte[] encoded)\n-            throws InvalidKeyException {\n-        return new RSAPublicKeyImpl(encoded);\n+    public static RSAPublicKey newKey(KeyType type, String format,\n+            byte[] encoded) throws InvalidKeyException {\n+        RSAPublicKey key;\n+        switch (format) {\n+        case \"X.509\":\n+            key = new RSAPublicKeyImpl(encoded);\n+            RSAKeyFactory.checkKeyAlgo(key, type.keyAlgo);\n+            break;\n+        case \"PKCS#1\":\n+            try {\n+                BigInteger[] comps = parseASN1(encoded);\n+                key = new RSAPublicKeyImpl(type, null, comps[0], comps[1]);\n+            } catch (IOException ioe) {\n+                throw new InvalidKeyException(\"Invalid PKCS#1 encoding\", ioe);\n+            }\n+            break;\n+        default:\n+            throw new InvalidKeyException(\"Unsupported RSA PublicKey format: \" +\n+                    format);\n+        }\n+        return key;\n@@ -79,1 +98,1 @@\n-     * Used by SunPKCS11 provider.\n+     * Also used by SunPKCS11 provider.\n@@ -126,1 +145,1 @@\n-     * Construct a key from its encoding. Used by RSAKeyFactory.\n+     * Construct a key from its encoding.\n@@ -128,1 +147,1 @@\n-    RSAPublicKeyImpl(byte[] encoded) throws InvalidKeyException {\n+    private RSAPublicKeyImpl(byte[] encoded) throws InvalidKeyException {\n@@ -184,0 +203,16 @@\n+    \/\/ utility method for parsing DER encoding of RSA public keys in PKCS#1\n+    \/\/ format as defined in RFC 8017 Appendix A.1.1, i.e. SEQ of n and e.\n+    private static BigInteger[] parseASN1(byte[] raw) throws IOException {\n+        DerValue derValue = new DerValue(raw);\n+        if (derValue.tag != DerValue.tag_Sequence) {\n+            throw new IOException(\"Not a SEQUENCE\");\n+        }\n+        BigInteger[] result = new BigInteger[2]; \/\/ n, e\n+        result[0] = derValue.data.getPositiveBigInteger();\n+        result[1] = derValue.data.getPositiveBigInteger();\n+        if (derValue.data.available() != 0) {\n+            throw new IOException(\"Extra data available\");\n+        }\n+        return result;\n+    }\n+\n@@ -189,11 +224,3 @@\n-            DerInputStream in = new DerInputStream(getKey().toByteArray());\n-            DerValue derValue = in.getDerValue();\n-            if (derValue.tag != DerValue.tag_Sequence) {\n-                throw new IOException(\"Not a SEQUENCE\");\n-            }\n-            DerInputStream data = derValue.data;\n-            n = data.getPositiveBigInteger();\n-            e = data.getPositiveBigInteger();\n-            if (derValue.data.available() != 0) {\n-                throw new IOException(\"Extra data available\");\n-            }\n+            BigInteger[] comps = parseASN1(getKey().toByteArray());\n+            n = comps[0];\n+            e = comps[1];\n","filename":"src\/java.base\/share\/classes\/sun\/security\/rsa\/RSAPublicKeyImpl.java","additions":46,"deletions":19,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,2 @@\n+import sun.security.rsa.RSAPrivateCrtKeyImpl;\n+import sun.security.rsa.RSAUtil.KeyType;\n@@ -61,1 +63,1 @@\n-            } else if (\"X.509\".equals(key.getFormat())) {\n+            } else {\n@@ -63,2 +65,2 @@\n-                byte[] encoded = key.getEncoded();\n-                key = RSAPublicKeyImpl.newKey(encoded);\n+                key = RSAPublicKeyImpl.newKey(KeyType.RSA, key.getFormat(),\n+                        key.getEncoded());\n@@ -66,3 +68,0 @@\n-            } else {\n-                throw new InvalidKeyException(\"PublicKey must be instance \"\n-                        + \"of RSAPublicKey or have X.509 encoding\");\n@@ -96,1 +95,1 @@\n-            } else if (\"PKCS#8\".equals(key.getFormat())) {\n+            } else {\n@@ -98,2 +97,2 @@\n-                byte[] encoded = key.getEncoded();\n-                key = sun.security.rsa.RSAPrivateCrtKeyImpl.newKey(encoded);\n+                key = RSAPrivateCrtKeyImpl.newKey(KeyType.RSA, key.getFormat(),\n+                        key.getEncoded());\n@@ -101,3 +100,0 @@\n-            } else {\n-                throw new InvalidKeyException(\"Private key must be instance \"\n-                        + \"of RSAPrivate(Crt)Key or have PKCS#8 encoding\");\n@@ -116,2 +112,2 @@\n-                byte[] encoded = ((X509EncodedKeySpec)keySpec).getEncoded();\n-                PublicKey key = RSAPublicKeyImpl.newKey(encoded);\n+                PublicKey key = RSAPublicKeyImpl.newKey(KeyType.RSA, \"X.509\",\n+                        ((X509EncodedKeySpec)keySpec).getEncoded());\n@@ -146,3 +142,2 @@\n-                byte[] encoded = ((PKCS8EncodedKeySpec)keySpec).getEncoded();\n-                PrivateKey key =\n-                        sun.security.rsa.RSAPrivateCrtKeyImpl.newKey(encoded);\n+                PrivateKey key = RSAPrivateCrtKeyImpl.newKey(KeyType.RSA,\n+                        \"PKCS#8\", ((PKCS8EncodedKeySpec)keySpec).getEncoded());\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11RSAKeyFactory.java","additions":13,"deletions":18,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 4856966\n+ * @bug 4856966 8023980\n@@ -45,0 +45,78 @@\n+    private static final String PKCS1_PRIV_STR =\n+        \/\/ the BASE64 string between -----BEGIN RSA PRIVATE KEY-----\n+        \/\/ and -----END RSA PRIVATE KEY-----\n+        \"MIIEowIBAAKCAQEA0OIArlYES4X1XMTLDordtN\/XIWFE1wvhl40RsHWM2n99+Stp\" +\n+        \"CCJCcUb5FJ2\/kefj\/XRwB6p5IMpIZrHZqC8XXzlX5fpiFaSu2xnk17oWUKoErW27\" +\n+        \"Stm098pU2RoUxWPKVl+42a8iVp8tijNElBNFALCGi0zXOhcTxMh0q1Wk0UhMJqam\" +\n+        \"v5YnCKmT4THwwGYn\/KeK3M7Qa+o5MoVBHLbeT9LJgEmSluVzIh44Lh6weX0bw72P\" +\n+        \"8X2praOhbzg2B343MqS\/rMLw6On+0i7ccEgp23vX9G5w85q4A5FSIrk4S\/pyv5sO\" +\n+        \"rwjCQKBW1TS0\/2iB9zNkFMj5\/+h7l2oqTT7sSQIDAQABAoIBADn6sXOynoiUC1IP\" +\n+        \"sck8lGOTSjSSujfyrVCSsJlJV6qCfuX9va6rS8QDjjnBu531PtxoSHxoPizy2Pvg\" +\n+        \"W+kKATPGR\/am9DjLuFlKq7GRjoYfWyMEdVtGaKvq9ng4fBF6LHyjHz0VFrPyhQJ6\" +\n+        \"TovHeXzCguYBkzAlnbAeb\/vqzs\/kABbOuSHVi7DsaixCoEX9zOptFYQw\/l8rh68+\" +\n+        \"UF2bpNNH3jOC1uN3vZtuSwCupqtN+2Mpkx2h04Rk75vWIhrnPeMgmcd3yP4LNZMR\" +\n+        \"mfaynb63RRzVkNis7+NVk016SQ1oL79mrBvy5rBg3HeCeArwvqZAmOaWsLSWHzCy\" +\n+        \"zlVlMTECgYEA6JlnMpC956Qi8HX5ye4Hu2ovBdbNGtH\/TMkZmColJz9P7CvNkNIb\" +\n+        \"Od6mvLMydbPHkhdBUDWD4rhiCKHrf5zKju1i24YqWcvuSGotWj4\/KQ3+87mLZM+7\" +\n+        \"daBsJBmSEVB80sgA9ItqSgOyNoNFpiDgFnlszAfb0n9XXEzB\/pwSw1UCgYEA5eXI\" +\n+        \"d+eKugugP+n6CluQfyxfN6WWCzfqWToCTTxPn2i12AiEssXy+kyLjupJVLWSivdo\" +\n+        \"83wD5LuxFRGc9P+aKQERPhb0AFaxf1llUCXla65\/x2So5xjMvtuzgQ0OktPJqJXq\" +\n+        \"hYGunctsr5rje33+7vlx4xWkrL2PrQWzJabn7SUCgYEAqw3FesY\/Ik7u8u+P1xSZ\" +\n+        \"0xXvptek1oiAu7NYgzLbR9WjrQc5kbsyEojPDg6qmSyxI5q+iYIRj3YRgk+xpJNl\" +\n+        \"0154SQCNvKPghJiw6aDFSifkytA01tp9\/a8QWCwF433RjiFPsoekjvHQ6Y34dofO\" +\n+        \"xDhf7lwJKPBFCrfYIqocklECgYAIPI9OHHGP8NKw94UJ0fX\/WGug5sHVbQ9sWvOy\" +\n+        \"KLMBlxLMxqFadlUaOpvVZvdxnX++ktajwpGxJDhX9OWWsYGobm1buB7N1E1Prrg+\" +\n+        \"gt0RWpMhZa3Xeb\/8Jorr2Lfo8sWK0LQyTE8hQCSIthfoWL9FeJJn\/GKF\/dSj8kxU\" +\n+        \"0QIGMQKBgG\/8U\/zZ87DzfXS81P1p+CmH474wmou4KD2\/zXp\/lDR9+dlIUeijlIbU\" +\n+        \"P6Y5xJvT33Y40giW9irShgDHjZgw0ap11K3b2HzLImdPEaBiENo735rpLs8WLK9H\" +\n+        \"+yeRbiP2y9To7sTihm9Jrkctzp6sqFtKyye1+S21X1tMz8NGfXen\";\n+\n+    private static final String PKCS1_PUB_STR =\n+        \/\/ the BASE64 string between -----BEGIN RSA PUBLIC KEY-----\n+        \/\/ and -----END RSA PUBLIC KEY-----\n+        \"MIIBCgKCAQEA0OIArlYES4X1XMTLDordtN\/XIWFE1wvhl40RsHWM2n99+StpCCJC\" +\n+        \"cUb5FJ2\/kefj\/XRwB6p5IMpIZrHZqC8XXzlX5fpiFaSu2xnk17oWUKoErW27Stm0\" +\n+        \"98pU2RoUxWPKVl+42a8iVp8tijNElBNFALCGi0zXOhcTxMh0q1Wk0UhMJqamv5Yn\" +\n+        \"CKmT4THwwGYn\/KeK3M7Qa+o5MoVBHLbeT9LJgEmSluVzIh44Lh6weX0bw72P8X2p\" +\n+        \"raOhbzg2B343MqS\/rMLw6On+0i7ccEgp23vX9G5w85q4A5FSIrk4S\/pyv5sOrwjC\" +\n+        \"QKBW1TS0\/2iB9zNkFMj5\/+h7l2oqTT7sSQIDAQAB\";\n+\n+\n+    private static final PrivateKey CUSTOM_PRIV;\n+    private static final PublicKey CUSTOM_PUB;\n+\n+    static {\n+        byte[] encodedPriv = Base64.getDecoder().decode(PKCS1_PRIV_STR);\n+        CUSTOM_PRIV = new PrivateKey() {\n+            @Override\n+            public String getAlgorithm() {\n+                return \"RSA\";\n+            }\n+            @Override\n+            public String getFormat() {\n+                return \"PKCS#1\";\n+            }\n+            @Override\n+            public byte[] getEncoded() {\n+                \/\/ skip cloning for testing key.\n+                return encodedPriv;\n+            }\n+        };\n+        byte[] encodedPub = Base64.getDecoder().decode(PKCS1_PUB_STR);\n+        CUSTOM_PUB = new PublicKey() {\n+            @Override\n+            public String getAlgorithm() {\n+                return \"RSA\";\n+            }\n+            @Override\n+            public String getFormat() {\n+                return \"PKCS#1\";\n+            }\n+            @Override\n+            public byte[] getEncoded() {\n+                \/\/ skip cloning for testing key.\n+                return encodedPub;\n+            }\n+        };\n+    }\n+\n@@ -71,2 +149,5 @@\n-        if (key1.equals(key2) == false) {\n-            throw new Exception(\"Keys not equal\");\n+        \/\/ skip equals check when key1 is custom key\n+        if (key1 != CUSTOM_PRIV && key1 != CUSTOM_PUB) {\n+            if (!key1.equals(key2)) {\n+                throw new Exception(\"Keys not equal\");\n+            }\n@@ -74,2 +155,5 @@\n-        if (Arrays.equals(key1.getEncoded(), key2.getEncoded()) == false) {\n-            throw new Exception(\"Encodings not equal\");\n+        \/\/ only compare encodings if keys are of the same format\n+        if (key1.getFormat().equals(key2.getFormat())) {\n+            if (!Arrays.equals(key1.getEncoded(), key2.getEncoded())) {\n+                throw new Exception(\"Encodings not equal\");\n+            }\n@@ -79,2 +163,4 @@\n-    private static void testPublic(KeyFactory kf, PublicKey key) throws Exception {\n-        System.out.println(\"Testing public key...\");\n+    private static void testPublic(KeyFactory kf, PublicKey key)\n+            throws Exception {\n+        System.out.println(\"Testing \" + (key == CUSTOM_PUB? \"PKCS#1\" : \"\") +\n+            \" public key...\");\n@@ -86,3 +172,3 @@\n-        KeySpec x509Spec2 = new X509EncodedKeySpec(key.getEncoded());\n-        PublicKey key5 = kf.generatePublic(x509Spec2);\n-        testKey(key, key);\n+        if (key != CUSTOM_PUB) {\n+            testKey(key, key);\n+        }\n@@ -92,1 +178,7 @@\n-        testKey(key, key5);\n+\n+        if (key.getFormat().equalsIgnoreCase(\"X.509\")) {\n+            KeySpec x509Spec2 = new X509EncodedKeySpec(key.getEncoded());\n+            PublicKey key5 = kf.generatePublic(x509Spec2);\n+            testKey(key, key5);\n+        }\n+\n@@ -95,2 +187,4 @@\n-    private static void testPrivate(KeyFactory kf, PrivateKey key) throws Exception {\n-        System.out.println(\"Testing private key...\");\n+    private static void testPrivate(KeyFactory kf, PrivateKey key)\n+            throws Exception {\n+        System.out.println(\"Testing \" + (key == CUSTOM_PRIV? \"PKCS#1\" : \"\") +\n+            \" private key...\");\n@@ -102,3 +196,3 @@\n-        KeySpec pkcs8Spec2 = new PKCS8EncodedKeySpec(key.getEncoded());\n-        PrivateKey key5 = kf.generatePrivate(pkcs8Spec2);\n-        testKey(key, key);\n+        if (key != CUSTOM_PRIV) {\n+            testKey(key, key);\n+        }\n@@ -108,1 +202,6 @@\n-        testKey(key, key5);\n+\n+        if (key.getFormat().equalsIgnoreCase(\"PKCS#8\")) {\n+            KeySpec pkcs8Spec2 = new PKCS8EncodedKeySpec(key.getEncoded());\n+            PrivateKey key5 = kf.generatePrivate(pkcs8Spec2);\n+            testKey(key, key5);\n+        }\n@@ -148,0 +247,4 @@\n+        \/\/ repeat the test w\/ PKCS#1 RSA Private Key\n+        test(kf, CUSTOM_PRIV);\n+        test(kf, CUSTOM_PUB);\n+\n","filename":"test\/jdk\/sun\/security\/pkcs11\/rsa\/TestKeyFactory.java","additions":121,"deletions":18,"binary":false,"changes":139,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 4853305\n+ * @bug 4853305 8023980\n@@ -44,0 +44,78 @@\n+    private static final String PKCS1_PRIV_STR =\n+        \/\/ the BASE64 string between -----BEGIN RSA PRIVATE KEY-----\n+        \/\/ and -----END RSA PRIVATE KEY-----\n+        \"MIIEowIBAAKCAQEA0OIArlYES4X1XMTLDordtN\/XIWFE1wvhl40RsHWM2n99+Stp\" +\n+        \"CCJCcUb5FJ2\/kefj\/XRwB6p5IMpIZrHZqC8XXzlX5fpiFaSu2xnk17oWUKoErW27\" +\n+        \"Stm098pU2RoUxWPKVl+42a8iVp8tijNElBNFALCGi0zXOhcTxMh0q1Wk0UhMJqam\" +\n+        \"v5YnCKmT4THwwGYn\/KeK3M7Qa+o5MoVBHLbeT9LJgEmSluVzIh44Lh6weX0bw72P\" +\n+        \"8X2praOhbzg2B343MqS\/rMLw6On+0i7ccEgp23vX9G5w85q4A5FSIrk4S\/pyv5sO\" +\n+        \"rwjCQKBW1TS0\/2iB9zNkFMj5\/+h7l2oqTT7sSQIDAQABAoIBADn6sXOynoiUC1IP\" +\n+        \"sck8lGOTSjSSujfyrVCSsJlJV6qCfuX9va6rS8QDjjnBu531PtxoSHxoPizy2Pvg\" +\n+        \"W+kKATPGR\/am9DjLuFlKq7GRjoYfWyMEdVtGaKvq9ng4fBF6LHyjHz0VFrPyhQJ6\" +\n+        \"TovHeXzCguYBkzAlnbAeb\/vqzs\/kABbOuSHVi7DsaixCoEX9zOptFYQw\/l8rh68+\" +\n+        \"UF2bpNNH3jOC1uN3vZtuSwCupqtN+2Mpkx2h04Rk75vWIhrnPeMgmcd3yP4LNZMR\" +\n+        \"mfaynb63RRzVkNis7+NVk016SQ1oL79mrBvy5rBg3HeCeArwvqZAmOaWsLSWHzCy\" +\n+        \"zlVlMTECgYEA6JlnMpC956Qi8HX5ye4Hu2ovBdbNGtH\/TMkZmColJz9P7CvNkNIb\" +\n+        \"Od6mvLMydbPHkhdBUDWD4rhiCKHrf5zKju1i24YqWcvuSGotWj4\/KQ3+87mLZM+7\" +\n+        \"daBsJBmSEVB80sgA9ItqSgOyNoNFpiDgFnlszAfb0n9XXEzB\/pwSw1UCgYEA5eXI\" +\n+        \"d+eKugugP+n6CluQfyxfN6WWCzfqWToCTTxPn2i12AiEssXy+kyLjupJVLWSivdo\" +\n+        \"83wD5LuxFRGc9P+aKQERPhb0AFaxf1llUCXla65\/x2So5xjMvtuzgQ0OktPJqJXq\" +\n+        \"hYGunctsr5rje33+7vlx4xWkrL2PrQWzJabn7SUCgYEAqw3FesY\/Ik7u8u+P1xSZ\" +\n+        \"0xXvptek1oiAu7NYgzLbR9WjrQc5kbsyEojPDg6qmSyxI5q+iYIRj3YRgk+xpJNl\" +\n+        \"0154SQCNvKPghJiw6aDFSifkytA01tp9\/a8QWCwF433RjiFPsoekjvHQ6Y34dofO\" +\n+        \"xDhf7lwJKPBFCrfYIqocklECgYAIPI9OHHGP8NKw94UJ0fX\/WGug5sHVbQ9sWvOy\" +\n+        \"KLMBlxLMxqFadlUaOpvVZvdxnX++ktajwpGxJDhX9OWWsYGobm1buB7N1E1Prrg+\" +\n+        \"gt0RWpMhZa3Xeb\/8Jorr2Lfo8sWK0LQyTE8hQCSIthfoWL9FeJJn\/GKF\/dSj8kxU\" +\n+        \"0QIGMQKBgG\/8U\/zZ87DzfXS81P1p+CmH474wmou4KD2\/zXp\/lDR9+dlIUeijlIbU\" +\n+        \"P6Y5xJvT33Y40giW9irShgDHjZgw0ap11K3b2HzLImdPEaBiENo735rpLs8WLK9H\" +\n+        \"+yeRbiP2y9To7sTihm9Jrkctzp6sqFtKyye1+S21X1tMz8NGfXen\";\n+\n+    private static final String PKCS1_PUB_STR =\n+        \/\/ the BASE64 string between -----BEGIN RSA PUBLIC KEY-----\n+        \/\/ and -----END RSA PUBLIC KEY-----\n+        \"MIIBCgKCAQEA0OIArlYES4X1XMTLDordtN\/XIWFE1wvhl40RsHWM2n99+StpCCJC\" +\n+        \"cUb5FJ2\/kefj\/XRwB6p5IMpIZrHZqC8XXzlX5fpiFaSu2xnk17oWUKoErW27Stm0\" +\n+        \"98pU2RoUxWPKVl+42a8iVp8tijNElBNFALCGi0zXOhcTxMh0q1Wk0UhMJqamv5Yn\" +\n+        \"CKmT4THwwGYn\/KeK3M7Qa+o5MoVBHLbeT9LJgEmSluVzIh44Lh6weX0bw72P8X2p\" +\n+        \"raOhbzg2B343MqS\/rMLw6On+0i7ccEgp23vX9G5w85q4A5FSIrk4S\/pyv5sOrwjC\" +\n+        \"QKBW1TS0\/2iB9zNkFMj5\/+h7l2oqTT7sSQIDAQAB\";\n+\n+\n+    private static final PrivateKey CUSTOM_PRIV;\n+    private static final PublicKey CUSTOM_PUB;\n+\n+    static {\n+        byte[] encodedPriv = Base64.getDecoder().decode(PKCS1_PRIV_STR);\n+        CUSTOM_PRIV = new PrivateKey() {\n+            @Override\n+            public String getAlgorithm() {\n+                return \"RSA\";\n+            }\n+            @Override\n+            public String getFormat() {\n+                return \"PKCS#1\";\n+            }\n+            @Override\n+            public byte[] getEncoded() {\n+                \/\/ skip cloning for testing key.\n+                return encodedPriv;\n+            }\n+        };\n+        byte[] encodedPub = Base64.getDecoder().decode(PKCS1_PUB_STR);\n+        CUSTOM_PUB = new PublicKey() {\n+            @Override\n+            public String getAlgorithm() {\n+                return \"RSA\";\n+            }\n+            @Override\n+            public String getFormat() {\n+                return \"PKCS#1\";\n+            }\n+            @Override\n+            public byte[] getEncoded() {\n+                \/\/ skip cloning for testing key.\n+                return encodedPub;\n+            }\n+        };\n+    }\n+\n@@ -66,1 +144,1 @@\n-                throw new Exception(\"Format not PKCS#8\");\n+                throw new Exception(\"Format not PKCS#8: \" + key2.getFormat());\n@@ -69,2 +147,5 @@\n-        if (key1.equals(key2) == false) {\n-            throw new Exception(\"Keys not equal\");\n+        \/\/ skip equals check when key1 is custom key\n+        if (key1 != CUSTOM_PRIV && key1 != CUSTOM_PUB) {\n+            if (!key1.equals(key2)) {\n+                throw new Exception(\"Keys not equal\");\n+            }\n@@ -72,2 +153,6 @@\n-        if (Arrays.equals(key1.getEncoded(), key2.getEncoded()) == false) {\n-            throw new Exception(\"Encodings not equal\");\n+\n+        \/\/ only compare encodings if keys are of the same format\n+        if (key1.getFormat().equals(key2.getFormat())) {\n+            if (!Arrays.equals(key1.getEncoded(), key2.getEncoded())) {\n+                throw new Exception(\"Encodings not equal\");\n+            }\n@@ -77,2 +162,5 @@\n-    private static void testPublic(KeyFactory kf, PublicKey key) throws Exception {\n-        System.out.println(\"Testing public key...\");\n+    private static void testPublic(KeyFactory kf, PublicKey key)\n+            throws Exception {\n+        System.out.println(\"Testing \" + (key == CUSTOM_PUB? \"PKCS#1\" : \"\") +\n+            \" public key...\");\n+\n@@ -84,3 +172,3 @@\n-        KeySpec x509Spec2 = new X509EncodedKeySpec(key.getEncoded());\n-        PublicKey key5 = kf.generatePublic(x509Spec2);\n-        testKey(key, key);\n+        if (key != CUSTOM_PUB) {\n+            testKey(key, key);\n+        }\n@@ -90,1 +178,6 @@\n-        testKey(key, key5);\n+\n+        if (key.getFormat().equalsIgnoreCase(\"X.509\")) {\n+            KeySpec x509Spec2 = new X509EncodedKeySpec(key.getEncoded());\n+            PublicKey key5 = kf.generatePublic(x509Spec2);\n+            testKey(key, key5);\n+        }\n@@ -93,2 +186,4 @@\n-    private static void testPrivate(KeyFactory kf, PrivateKey key) throws Exception {\n-        System.out.println(\"Testing private key...\");\n+    private static void testPrivate(KeyFactory kf, PrivateKey key)\n+            throws Exception {\n+        System.out.println(\"Testing \" + (key == CUSTOM_PRIV? \"PKCS#1\" : \"\") +\n+            \" private key...\");\n@@ -100,3 +195,3 @@\n-        KeySpec pkcs8Spec2 = new PKCS8EncodedKeySpec(key.getEncoded());\n-        PrivateKey key5 = kf.generatePrivate(pkcs8Spec2);\n-        testKey(key, key);\n+        if (key != CUSTOM_PRIV) {\n+            testKey(key, key);\n+        }\n@@ -106,1 +201,5 @@\n-        testKey(key, key5);\n+        if (key.getFormat().equalsIgnoreCase(\"PKCS#8\")) {\n+            KeySpec pkcs8Spec2 = new PKCS8EncodedKeySpec(key.getEncoded());\n+            PrivateKey key5 = kf.generatePrivate(pkcs8Spec2);\n+            testKey(key, key5);\n+        }\n@@ -110,3 +209,0 @@\n-        RSAPrivateKey rsaKey = (RSAPrivateKey)key;\n-        KeySpec rsaSpec3 = new RSAPrivateKeySpec(rsaKey.getModulus(), rsaKey.getPrivateExponent());\n-        PrivateKey key7 = kf.generatePrivate(rsaSpec3);\n@@ -114,1 +210,7 @@\n-        testKey(key6, key7);\n+        if (key instanceof RSAPrivateKey) {\n+            KeySpec rsaSpec3 =\n+                new RSAPrivateKeySpec(((RSAPrivateKey)key).getModulus(),\n+                ((RSAPrivateKey)key).getPrivateExponent());\n+            PrivateKey key7 = kf.generatePrivate(rsaSpec3);\n+            testKey(key6, key7);\n+        }\n@@ -140,0 +242,4 @@\n+        \/\/ repeat the test w\/ PKCS#1 RSA Private Key\n+        test(kf, CUSTOM_PRIV);\n+        test(kf, CUSTOM_PUB);\n+\n","filename":"test\/jdk\/sun\/security\/rsa\/TestKeyFactory.java","additions":129,"deletions":23,"binary":false,"changes":152,"status":"modified"}]}