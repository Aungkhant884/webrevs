{"files":[{"patch":"@@ -84,0 +84,4 @@\n+     * The compressed size field will be recalculated for compressed (i.e.\n+     * {@code ZipEntry.DEFLATED}) entries when {@link ZipEntry#setCompressedSize(long)}\n+     * has not been explicitly called on the {@code ZipEntry}.\n+     *\n","filename":"src\/java.base\/share\/classes\/java\/util\/jar\/JarOutputStream.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -56,0 +56,1 @@\n+    boolean manual_csize = false; \/\/ Only true if csize was explicitely set by a call to setCompressedSize()\n@@ -130,0 +131,1 @@\n+        manual_csize = e.manual_csize;\n@@ -450,0 +452,1 @@\n+        this.manual_csize = true;\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/ZipEntry.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -185,0 +185,5 @@\n+     *\n+     * The compressed size field will be recalculated for compressed (i.e.\n+     * {@code ZipEntry.DEFLATED}) entries when {@link ZipEntry#setCompressedSize(long)}\n+     * has not been explicitly called on the {@code ZipEntry}.\n+     *\n@@ -208,1 +213,1 @@\n-            if (e.size  == -1 || e.csize == -1 || e.crc   == -1)\n+            if (e.size  == -1 || e.csize == -1 || e.crc   == -1) {\n@@ -210,1 +215,7 @@\n-\n+            }\n+            else if (!e.manual_csize) {\n+                \/\/ Ignore compressed size of a ZipEntry if it was implcitely set\n+                \/\/ while reading that ZipEntry from a  ZipFile or ZipInputStream because\n+                \/\/ we can't know the compression level of the source zip file\/stream.\n+                e.flag = 8;\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/ZipOutputStream.java","additions":13,"deletions":2,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -0,0 +1,204 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @summary Test behaviour when copying ZipEntries between zip files.\n+ * @run main\/othervm CopyZipFile\n+ *\/\n+\n+import java.io.File;\n+import java.io.ByteArrayOutputStream;\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.util.Enumeration;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.zip.CRC32;\n+import java.util.zip.Deflater;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipException;\n+import java.util.zip.ZipFile;\n+import java.util.zip.ZipInputStream;\n+import java.util.zip.ZipOutputStream;\n+\n+public class CopyZipFile {\n+    private static final String ZIP_FILE = \"first.zip\";\n+    private static final String TEST_STRING = \"TestTestTest\";\n+\n+    private static void createZip(String zipFile) throws Exception {\n+        File f = new File(zipFile);\n+        f.deleteOnExit();\n+        OutputStream os = new FileOutputStream(f);\n+        ZipOutputStream zos = new ZipOutputStream(os);\n+        \/\/ First file will be compressed with DEFAULT_COMPRESSION (i.e. -1 or 6)\n+        zos.putNextEntry(new ZipEntry(\"test1.txt\"));\n+        zos.write(TEST_STRING.getBytes());\n+        zos.closeEntry();\n+        \/\/ Second file won't be compressed at all (i.e. STORED)\n+        zos.setMethod(ZipOutputStream.STORED);\n+        ZipEntry ze = new ZipEntry(\"test2.txt\");\n+        int length = TEST_STRING.length();\n+        ze.setSize(length);\n+        ze.setCompressedSize(length);\n+        CRC32 crc = new CRC32();\n+        crc.update(TEST_STRING.getBytes(\"utf8\"), 0, length);\n+        ze.setCrc(crc.getValue());\n+        zos.putNextEntry(ze);\n+        zos.write(TEST_STRING.getBytes());\n+        \/\/ Third file will be compressed with NO_COMPRESSION (i.e. 0)\n+        zos.setMethod(ZipOutputStream.DEFLATED);\n+        zos.setLevel(Deflater.NO_COMPRESSION);\n+        zos.putNextEntry(new ZipEntry(\"test3.txt\"));\n+        zos.write(TEST_STRING.getBytes());\n+        \/\/ Fourth file will be compressed with BEST_SPEED (i.e. 1)\n+        zos.setLevel(Deflater.BEST_SPEED);\n+        zos.putNextEntry(new ZipEntry(\"test4.txt\"));\n+        zos.write(TEST_STRING.getBytes());\n+        \/\/ Fifth file will be compressed with BEST_COMPRESSION (i.e. 9)\n+        zos.setLevel(Deflater.BEST_COMPRESSION);\n+        zos.putNextEntry(new ZipEntry(\"test5.txt\"));\n+        zos.write(TEST_STRING.getBytes());\n+        zos.close();\n+    }\n+\n+    public static void main(String args[]) throws Exception {\n+        \/\/ By default, ZipOutputStream creates zip files with Local File Headers\n+        \/\/ without size, compressedSize and crc values and an extra Data\n+        \/\/ Descriptor (see https:\/\/en.wikipedia.org\/wiki\/Zip_(file_format)\n+        \/\/ after the data belonging to that entry with these values if in the\n+        \/\/ corresponding ZipEntry one of the size, compressedSize or crc fields is\n+        \/\/ equal to '-1' (which is the default for newly created ZipEntries).\n+        createZip(ZIP_FILE);\n+\n+        \/\/ Now read all the entries of the newly generated zip file with a ZipInputStream\n+        \/\/ and copy them to a new zip file with the help of a ZipOutputStream.\n+        \/\/ This only works reliably because the generated zip file has no values for the\n+        \/\/ size, compressedSize and crc values of a zip entry in the local file header and\n+        \/\/ therefore the ZipEntry objects created by ZipOutputStream.getNextEntry() will have\n+        \/\/ all these fields set to '-1'.\n+        InputStream is = new FileInputStream(ZIP_FILE);\n+        ZipInputStream zis = new ZipInputStream(is);\n+        ZipEntry entry;\n+        byte[] buf = new byte[512];\n+        OutputStream os = new ByteArrayOutputStream();\n+        ZipOutputStream zos = new ZipOutputStream(os);\n+        while((entry = zis.getNextEntry())!=null) {\n+            \/\/ ZipInputStream.getNextEntry() only reads the Local File Header of a zip entry,\n+            \/\/ so for the zip file we've just generated the ZipEntry fields 'size', 'compressedSize`\n+            \/\/ and 'crc' for deflated entries should be uninitialized (i.e. '-1').\n+            System.out.println(\n+                String.format(\"name=%s, clen=%d, len=%d, crc=%d\",\n+                              entry.getName(), entry.getCompressedSize(), entry.getSize(), entry.getCrc()));\n+            if (entry.getMethod() == ZipEntry.DEFLATED &&\n+                (entry.getCompressedSize() != -1 || entry.getSize() != -1 || entry.getCrc() != -1)) {\n+                throw new Exception(\"'size', 'compressedSize' and 'crc' shouldn't be initialized at this point.\");\n+            }\n+            zos.putNextEntry(entry);\n+            zis.transferTo(zos);\n+            \/\/ After all the data belonging to a zip entry has been inflated (i.e. after ZipInputStream.read()\n+            \/\/ returned '-1'), it is guaranteed that the ZipInputStream will also have consumed the Data\n+            \/\/ Descriptor (if any) after the data and will have updated the 'size', 'compressedSize' and 'crc'\n+            \/\/ fields of the ZipEntry object.\n+            System.out.println(\n+                String.format(\"name=%s, clen=%d, len=%d, crc=%d\\n\",\n+                              entry.getName(), entry.getCompressedSize(), entry.getSize(), entry.getCrc()));\n+            if (entry.getCompressedSize() == -1 || entry.getSize() == -1) {\n+                throw new Exception(\"'size' and 'compressedSize' must be initialized at this point.\");\n+            }\n+        }\n+        zos.close();\n+\n+        \/\/ Now we read all the entries of the initially generated zip file with the help\n+        \/\/ of the ZipFile class. The ZipFile class reads all the zip entries from the Central\n+        \/\/ Directory which must have accurate information for size, compressedSize and crc.\n+        \/\/ This means that all ZipEntry objects returned from ZipFile will have correct\n+        \/\/ settings for these fields.\n+        \/\/ I the compression level was different in the initial zip file (which we can't find\n+        \/\/ out any more now because the zip file format doesn't record this information) the\n+        \/\/ size of the re-compressed entry we are writing to the ZipOutputStream might differ\n+        \/\/ from the original compressed size recorded in the ZipEntry. This would result in an\n+        \/\/ \"invalid entry compressed size\" ZipException if ZipOutputStream wouldn't ignore\n+        \/\/ the implicitely set compressed size attribute of ZipEntries read from a ZipFile\n+        \/\/ or ZipInputStream.\n+        os = new ByteArrayOutputStream();\n+        zos = new ZipOutputStream(os);\n+        ZipFile zf = new ZipFile(ZIP_FILE);\n+        Enumeration<? extends ZipEntry> entries = zf.entries();\n+        while (entries.hasMoreElements()) {\n+            entry = entries.nextElement();\n+            System.out.println(\n+                String.format(\"name=%s, clen=%d, len=%d, crc=%d\\n\",\n+                              entry.getName(), entry.getCompressedSize(),\n+                              entry.getSize(), entry.getCrc()));\n+            if (entry.getCompressedSize() == -1 || entry.getSize() == -1) {\n+                throw new Exception(\"'size' and 'compressedSize' must be initialized at this point.\");\n+            }\n+            is = zf.getInputStream(entry);\n+            zos.putNextEntry(entry);\n+            is.transferTo(zos);\n+            zos.closeEntry();\n+        }\n+        zos.close();\n+\n+        \/\/ The compressed size attribute of a ZipEntry shouldn't be ignored if it was set\n+        \/\/ explicitely by calling ZipEntry.setCpompressedSize()\n+        os = new ByteArrayOutputStream();\n+        zos = new ZipOutputStream(os);\n+        zf = new ZipFile(ZIP_FILE);\n+        entries = zf.entries();\n+        while (entries.hasMoreElements()) {\n+            try {\n+                entry = entries.nextElement();\n+                entry.setCompressedSize(entry.getCompressedSize());\n+                is = zf.getInputStream(entry);\n+                zos.putNextEntry(entry);\n+                is.transferTo(zos);\n+                zos.closeEntry();\n+                if (\"test3.txt\".equals(entry.getName())) {\n+                    throw new Exception(\n+                        \"Should throw a ZipException if ZipEntry.setCpompressedSize() was called.\");\n+                }\n+            } catch (ZipException ze) {\n+                if (\"test1.txt\".equals(entry.getName()) || \"test2.txt\".equals(entry.getName())) {\n+                    throw new Exception(\n+                        \"Should throw for STORED files or files compressed with DEFAULT_COMPRESSION\");\n+                }\n+                \/\/ Hack to fix and close the offending zip entry with the correct compressed size.\n+                \/\/ The exception message is something like:\n+                \/\/   \"invalid entry compressed size (expected 12 but got 7 bytes)\"\n+                \/\/ and we need to extract the second integer.\n+                Pattern cSize = Pattern.compile(\"\\\\d+\");\n+                Matcher m = cSize.matcher(ze.getMessage());\n+                m.find();\n+                m.find();\n+                entry.setCompressedSize(Integer.parseInt(m.group()));\n+            }\n+        }\n+        zos.close();\n+\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/zip\/CopyZipFile.java","additions":204,"deletions":0,"binary":false,"changes":204,"status":"added"}]}