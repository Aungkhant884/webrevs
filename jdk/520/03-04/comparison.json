{"files":[{"patch":"@@ -107,24 +107,25 @@\n-        OutputStream os = new ByteArrayOutputStream();\n-        ZipOutputStream zos = new ZipOutputStream(os);\n-        while((entry = zis.getNextEntry())!=null) {\n-            \/\/ ZipInputStream.getNextEntry() only reads the Local File Header of a zip entry,\n-            \/\/ so for the zip file we've just generated the ZipEntry fields 'size', 'compressedSize`\n-            \/\/ and 'crc' for deflated entries should be uninitialized (i.e. '-1').\n-            System.out.println(\n-                String.format(\"name=%s, clen=%d, len=%d, crc=%d\",\n-                              entry.getName(), entry.getCompressedSize(), entry.getSize(), entry.getCrc()));\n-            if (entry.getMethod() == ZipEntry.DEFLATED &&\n-                (entry.getCompressedSize() != -1 || entry.getSize() != -1 || entry.getCrc() != -1)) {\n-                throw new Exception(\"'size', 'compressedSize' and 'crc' shouldn't be initialized at this point.\");\n-            }\n-            zos.putNextEntry(entry);\n-            zis.transferTo(zos);\n-            \/\/ After all the data belonging to a zip entry has been inflated (i.e. after ZipInputStream.read()\n-            \/\/ returned '-1'), it is guaranteed that the ZipInputStream will also have consumed the Data\n-            \/\/ Descriptor (if any) after the data and will have updated the 'size', 'compressedSize' and 'crc'\n-            \/\/ fields of the ZipEntry object.\n-            System.out.println(\n-                String.format(\"name=%s, clen=%d, len=%d, crc=%d\\n\",\n-                              entry.getName(), entry.getCompressedSize(), entry.getSize(), entry.getCrc()));\n-            if (entry.getCompressedSize() == -1 || entry.getSize() == -1) {\n-                throw new Exception(\"'size' and 'compressedSize' must be initialized at this point.\");\n+        try (OutputStream os = new ByteArrayOutputStream();\n+             ZipOutputStream zos = new ZipOutputStream(os)) {\n+            while((entry = zis.getNextEntry())!=null) {\n+                \/\/ ZipInputStream.getNextEntry() only reads the Local File Header of a zip entry,\n+                \/\/ so for the zip file we've just generated the ZipEntry fields 'size', 'compressedSize`\n+                \/\/ and 'crc' for deflated entries should be uninitialized (i.e. '-1').\n+                System.out.println(\n+                    String.format(\"name=%s, clen=%d, len=%d, crc=%d\",\n+                                  entry.getName(), entry.getCompressedSize(), entry.getSize(), entry.getCrc()));\n+                if (entry.getMethod() == ZipEntry.DEFLATED &&\n+                    (entry.getCompressedSize() != -1 || entry.getSize() != -1 || entry.getCrc() != -1)) {\n+                    throw new Exception(\"'size', 'compressedSize' and 'crc' shouldn't be initialized at this point.\");\n+                }\n+                zos.putNextEntry(entry);\n+                zis.transferTo(zos);\n+                \/\/ After all the data belonging to a zip entry has been inflated (i.e. after ZipInputStream.read()\n+                \/\/ returned '-1'), it is guaranteed that the ZipInputStream will also have consumed the Data\n+                \/\/ Descriptor (if any) after the data and will have updated the 'size', 'compressedSize' and 'crc'\n+                \/\/ fields of the ZipEntry object.\n+                System.out.println(\n+                    String.format(\"name=%s, clen=%d, len=%d, crc=%d\\n\",\n+                                  entry.getName(), entry.getCompressedSize(), entry.getSize(), entry.getCrc()));\n+                if (entry.getCompressedSize() == -1 || entry.getSize() == -1) {\n+                    throw new Exception(\"'size' and 'compressedSize' must be initialized at this point.\");\n+                }\n@@ -133,1 +134,0 @@\n-        zos.close();\n@@ -147,28 +147,5 @@\n-        os = new ByteArrayOutputStream();\n-        zos = new ZipOutputStream(os);\n-        ZipFile zf = new ZipFile(ZIP_FILE);\n-        Enumeration<? extends ZipEntry> entries = zf.entries();\n-        while (entries.hasMoreElements()) {\n-            entry = entries.nextElement();\n-            System.out.println(\n-                String.format(\"name=%s, clen=%d, len=%d, crc=%d\\n\",\n-                              entry.getName(), entry.getCompressedSize(),\n-                              entry.getSize(), entry.getCrc()));\n-            if (entry.getCompressedSize() == -1 || entry.getSize() == -1) {\n-                throw new Exception(\"'size' and 'compressedSize' must be initialized at this point.\");\n-            }\n-            is = zf.getInputStream(entry);\n-            zos.putNextEntry(entry);\n-            is.transferTo(zos);\n-            zos.closeEntry();\n-        }\n-        zos.close();\n-\n-        \/\/ The compressed size attribute of a ZipEntry shouldn't be ignored if it was set\n-        \/\/ explicitely by calling ZipEntry.setCpompressedSize()\n-        os = new ByteArrayOutputStream();\n-        zos = new ZipOutputStream(os);\n-        zf = new ZipFile(ZIP_FILE);\n-        entries = zf.entries();\n-        while (entries.hasMoreElements()) {\n-            try {\n+        try (OutputStream os = new ByteArrayOutputStream();\n+             ZipOutputStream zos = new ZipOutputStream(os)) {\n+            ZipFile zf = new ZipFile(ZIP_FILE);\n+            Enumeration<? extends ZipEntry> entries = zf.entries();\n+            while (entries.hasMoreElements()) {\n@@ -176,1 +153,7 @@\n-                entry.setCompressedSize(entry.getCompressedSize());\n+                System.out.println(\n+                    String.format(\"name=%s, clen=%d, len=%d, crc=%d\\n\",\n+                                  entry.getName(), entry.getCompressedSize(),\n+                                  entry.getSize(), entry.getCrc()));\n+                if (entry.getCompressedSize() == -1 || entry.getSize() == -1) {\n+                    throw new Exception(\"'size' and 'compressedSize' must be initialized at this point.\");\n+                }\n@@ -181,18 +164,0 @@\n-                if (\"test3.txt\".equals(entry.getName())) {\n-                    throw new Exception(\n-                        \"Should throw a ZipException if ZipEntry.setCpompressedSize() was called.\");\n-                }\n-            } catch (ZipException ze) {\n-                if (\"test1.txt\".equals(entry.getName()) || \"test2.txt\".equals(entry.getName())) {\n-                    throw new Exception(\n-                        \"Should throw for STORED files or files compressed with DEFAULT_COMPRESSION\");\n-                }\n-                \/\/ Hack to fix and close the offending zip entry with the correct compressed size.\n-                \/\/ The exception message is something like:\n-                \/\/   \"invalid entry compressed size (expected 12 but got 7 bytes)\"\n-                \/\/ and we need to extract the second integer.\n-                Pattern cSize = Pattern.compile(\"\\\\d+\");\n-                Matcher m = cSize.matcher(ze.getMessage());\n-                m.find();\n-                m.find();\n-                entry.setCompressedSize(Integer.parseInt(m.group()));\n@@ -201,1 +166,0 @@\n-        zos.close();\n@@ -203,0 +167,35 @@\n+        \/\/ The compressed size attribute of a ZipEntry shouldn't be ignored if it was set\n+        \/\/ explicitely by calling ZipEntry.setCpompressedSize()\n+        try (OutputStream os = new ByteArrayOutputStream();\n+             ZipOutputStream zos = new ZipOutputStream(os)) {\n+            ZipFile zf = new ZipFile(ZIP_FILE);\n+            Enumeration<? extends ZipEntry> entries = zf.entries();\n+            while (entries.hasMoreElements()) {\n+                try {\n+                    entry = entries.nextElement();\n+                    entry.setCompressedSize(entry.getCompressedSize());\n+                    is = zf.getInputStream(entry);\n+                    zos.putNextEntry(entry);\n+                    is.transferTo(zos);\n+                    zos.closeEntry();\n+                    if (\"test3.txt\".equals(entry.getName())) {\n+                        throw new Exception(\n+                            \"Should throw a ZipException if ZipEntry.setCpompressedSize() was called.\");\n+                    }\n+                } catch (ZipException ze) {\n+                    if (\"test1.txt\".equals(entry.getName()) || \"test2.txt\".equals(entry.getName())) {\n+                        throw new Exception(\n+                            \"Should throw for STORED files or files compressed with DEFAULT_COMPRESSION\");\n+                    }\n+                    \/\/ Hack to fix and close the offending zip entry with the correct compressed size.\n+                    \/\/ The exception message is something like:\n+                    \/\/   \"invalid entry compressed size (expected 12 but got 7 bytes)\"\n+                    \/\/ and we need to extract the second integer.\n+                    Pattern cSize = Pattern.compile(\"\\\\d+\");\n+                    Matcher m = cSize.matcher(ze.getMessage());\n+                    m.find();\n+                    m.find();\n+                    entry.setCompressedSize(Integer.parseInt(m.group()));\n+                }\n+            }\n+        }\n","filename":"test\/jdk\/java\/util\/zip\/CopyZipFile.java","additions":72,"deletions":73,"binary":false,"changes":145,"status":"modified"}]}