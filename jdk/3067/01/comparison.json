{"files":[{"patch":"@@ -459,0 +459,107 @@\n+class ArgumentPusher : public SignatureIterator {\n+ protected:\n+  JavaCallArguments*  _jca;\n+  jlong _argument;\n+  bool _pushed;\n+\n+  jlong next_arg() {\n+    guarantee(!_pushed, \"one argument\");\n+    _pushed = true;\n+    return _argument;\n+  }\n+\n+  float next_float() {\n+    guarantee(!_pushed, \"one argument\");\n+    _pushed = true;\n+    jvalue v;\n+    v.i = (jint) _argument;\n+    return v.f;\n+  }\n+\n+  double next_double() {\n+    guarantee(!_pushed, \"one argument\");\n+    _pushed = true;\n+    jvalue v;\n+    v.j = _argument;\n+    return v.d;\n+  }\n+\n+  Handle next_object() {\n+    guarantee(!_pushed, \"one argument\");\n+    _pushed = true;\n+    return Handle(Thread::current(), (oop) (address) _argument);\n+  }\n+\n+ public:\n+  ArgumentPusher(Symbol* signature, JavaCallArguments*  jca, jlong argument) : SignatureIterator(signature) {\n+    this->_return_type = T_ILLEGAL;\n+    _jca = jca;\n+    _argument = argument;\n+    _pushed = false;\n+    do_parameters_on(this);\n+  }\n+\n+  void do_type(BasicType type) {\n+    switch (type) {\n+      case T_OBJECT:\n+      case T_ARRAY:   _jca->push_oop(next_object());         break;\n+      case T_BOOLEAN: _jca->push_int((jboolean) next_arg()); break;\n+      case T_CHAR:    _jca->push_int((jchar) next_arg());    break;\n+      case T_SHORT:   _jca->push_int((jint)  next_arg());    break;\n+      case T_BYTE:    _jca->push_int((jbyte) next_arg());    break;\n+      case T_INT:     _jca->push_int((jint)  next_arg());    break;\n+      case T_LONG:    _jca->push_long((jlong) next_arg());   break;\n+      case T_FLOAT:   _jca->push_float(next_float());        break;\n+      case T_DOUBLE:  _jca->push_double(next_double());      break;\n+      default:        fatal(\"Unexpected type %s\", type2name(type));\n+    }\n+  }\n+};\n+\n+\n+JRT_ENTRY(jlong, JVMCIRuntime::invoke_static_method_one_arg(JavaThread* thread, Method* method, jlong argument))\n+  ResourceMark rm;\n+  HandleMark hm(THREAD);\n+\n+  methodHandle mh(thread, method);\n+  if (mh->size_of_parameters() > 1 && !mh->is_static()) {\n+    THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), \"Invoked method must be static and take at most one argument\");\n+  }\n+\n+  Symbol* signature = mh->signature();\n+  JavaCallArguments jca(mh->size_of_parameters());\n+  ArgumentPusher jap(signature, &jca, argument);\n+  BasicType return_type = jap.return_type();\n+  JavaValue result(return_type);\n+  JavaCalls::call(&result, mh, &jca, CHECK_0);\n+\n+  if (return_type == T_VOID) {\n+    return 0;\n+  } else if (return_type == T_OBJECT || return_type == T_ARRAY) {\n+    thread->set_vm_result((oop) result.get_jobject());\n+    return 0;\n+  } else {\n+    jvalue *value = (jvalue *) result.get_value_addr();\n+    \/\/ Narrow the value down if required (Important on big endian machines)\n+    switch (return_type) {\n+      case T_BOOLEAN:\n+        return (jboolean) value->i;\n+      case T_BYTE:\n+        return (jbyte) value->i;\n+      case T_CHAR:\n+        return (jchar) value->i;\n+      case T_SHORT:\n+        return (jshort) value->i;\n+      case T_INT:\n+      case T_FLOAT:\n+        return value->i;\n+      case T_LONG:\n+      case T_DOUBLE:\n+        return value->j;\n+      default:\n+        fatal(\"Unexpected type %s\", type2name(return_type));\n+        return 0;\n+    }\n+  }\n+JRT_END\n+\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.cpp","additions":107,"deletions":0,"binary":false,"changes":107,"status":"modified"},{"patch":"@@ -415,0 +415,5 @@\n+  \/\/ A helper to allow invocation of an arbitrary Java method.  For simplicity the method is\n+  \/\/ restricted to a static method that takes at most one argument.  For calling convention\n+  \/\/ simplicty all types are passed by being converted into a jlong\n+  static jlong invoke_static_method_one_arg(JavaThread* thread, Method* method, jlong argument);\n+\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -687,0 +687,2 @@\n+  declare_function(JVMCIRuntime::invoke_static_method_one_arg) \\\n+  \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"}]}