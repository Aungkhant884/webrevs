{"files":[{"patch":"@@ -515,9 +515,0 @@\n-#ifdef COMPILER2\n-  if (PostLoopMultiversioning && !RangeCheckElimination) {\n-    if (!FLAG_IS_DEFAULT(PostLoopMultiversioning)) {\n-      warning(\"PostLoopMultiversioning disabled because RangeCheckElimination is disabled.\");\n-    }\n-    FLAG_SET_CMDLINE(PostLoopMultiversioning, false);\n-  }\n-#endif \/\/ COMPILER2\n-\n","filename":"src\/hotspot\/share\/compiler\/compilerDefinitions.cpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -185,3 +185,0 @@\n-  product(bool, PostLoopMultiversioning, false, EXPERIMENTAL,               \\\n-           \"Multi versioned post loops to eliminate range checks\")          \\\n-                                                                            \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1891,49 +1891,0 @@\n-\n-\/\/-------------------------insert_scalar_rced_post_loop------------------------\n-\/\/ Insert a copy of the rce'd main loop as a post loop,\n-\/\/ We have not unrolled the main loop, so this is the right time to inject this.\n-\/\/ Later we will examine the partner of this post loop pair which still has range checks\n-\/\/ to see inject code which tests at runtime if the range checks are applicable.\n-void PhaseIdealLoop::insert_scalar_rced_post_loop(IdealLoopTree *loop, Node_List &old_new) {\n-  if (!loop->_head->is_CountedLoop()) return;\n-\n-  CountedLoopNode *cl = loop->_head->as_CountedLoop();\n-\n-  \/\/ only process RCE'd main loops\n-  if (!cl->is_main_loop() || loop->range_checks_present()) return;\n-\n-#ifndef PRODUCT\n-  if (TraceLoopOpts) {\n-    tty->print(\"PostScalarRce  \");\n-    loop->dump_head();\n-  }\n-#endif\n-  C->set_major_progress();\n-\n-  \/\/ Find common pieces of the loop being guarded with pre & post loops\n-  CountedLoopNode *main_head = loop->_head->as_CountedLoop();\n-  CountedLoopEndNode *main_end = main_head->loopexit();\n-  \/\/ diagnostic to show loop end is not properly formed\n-  assert(main_end->outcnt() == 2, \"1 true, 1 false path only\");\n-\n-  Node *incr = main_end->incr();\n-  Node *limit = main_end->limit();\n-\n-  \/\/ In this case we throw away the result as we are not using it to connect anything else.\n-  CountedLoopNode *post_head = nullptr;\n-  insert_post_loop(loop, old_new, main_head, main_end, incr, limit, post_head);\n-  copy_assertion_predicates_to_post_loop(main_head->skip_strip_mined(), post_head, incr, main_head->stride());\n-\n-  \/\/ It's difficult to be precise about the trip-counts\n-  \/\/ for post loops.  They are usually very short,\n-  \/\/ so guess that unit vector trips is a reasonable value.\n-  post_head->set_profile_trip_cnt(4.0);\n-  post_head->set_is_rce_post_loop();\n-\n-  \/\/ Now force out all loop-invariant dominating tests.  The optimizer\n-  \/\/ finds some, but we _know_ they are all useless.\n-  peeled_dom_test_elim(loop, old_new);\n-  loop->record_for_igvn();\n-}\n-\n-\n@@ -3201,137 +3152,0 @@\n-\/\/-------------------------multi_version_post_loops----------------------------\n-\/\/ Check the range checks that remain, if simple, use the bounds to guard\n-\/\/ which version to a post loop we execute, one with range checks or one without\n-bool PhaseIdealLoop::multi_version_post_loops(IdealLoopTree *rce_loop, IdealLoopTree *legacy_loop) {\n-  bool multi_version_succeeded = false;\n-  assert(RangeCheckElimination, \"\");\n-  CountedLoopNode *legacy_cl = legacy_loop->_head->as_CountedLoop();\n-  assert(legacy_cl->is_post_loop(), \"\");\n-\n-  \/\/ Check for existence of range checks using the unique instance to make a guard with\n-  Unique_Node_List worklist;\n-  for (uint i = 0; i < legacy_loop->_body.size(); i++) {\n-    Node *iff = legacy_loop->_body[i];\n-    int iff_opc = iff->Opcode();\n-    if (iff_opc == Op_If || iff_opc == Op_RangeCheck) {\n-      worklist.push(iff);\n-    }\n-  }\n-\n-  \/\/ Find RCE'd post loop so that we can stage its guard.\n-  if (legacy_cl->is_canonical_loop_entry() == nullptr) {\n-    return multi_version_succeeded;\n-  }\n-  Node* ctrl = legacy_cl->in(LoopNode::EntryControl);\n-  Node* iffm = ctrl->in(0);\n-\n-  \/\/ Now we test that both the post loops are connected\n-  Node* post_loop_region = iffm->in(0);\n-  if (post_loop_region == nullptr) return multi_version_succeeded;\n-  if (!post_loop_region->is_Region()) return multi_version_succeeded;\n-  Node* covering_region = post_loop_region->in(RegionNode::Control+1);\n-  if (covering_region == nullptr) return multi_version_succeeded;\n-  if (!covering_region->is_Region()) return multi_version_succeeded;\n-  Node* p_f = covering_region->in(RegionNode::Control);\n-  if (p_f == nullptr) return multi_version_succeeded;\n-  if (!p_f->is_IfFalse()) return multi_version_succeeded;\n-  if (!p_f->in(0)->is_CountedLoopEnd()) return multi_version_succeeded;\n-  CountedLoopEndNode* rce_loop_end = p_f->in(0)->as_CountedLoopEnd();\n-  if (rce_loop_end == nullptr) return multi_version_succeeded;\n-  CountedLoopNode* rce_cl = rce_loop_end->loopnode();\n-  if (rce_cl == nullptr || !rce_cl->is_post_loop()) return multi_version_succeeded;\n-  CountedLoopNode *known_rce_cl = rce_loop->_head->as_CountedLoop();\n-  if (rce_cl != known_rce_cl) return multi_version_succeeded;\n-\n-  \/\/ Then we fetch the cover entry test\n-  ctrl = rce_cl->in(LoopNode::EntryControl);\n-  if (!ctrl->is_IfTrue() && !ctrl->is_IfFalse()) return multi_version_succeeded;\n-\n-#ifndef PRODUCT\n-  if (TraceLoopOpts) {\n-    tty->print(\"PostMultiVersion\\n\");\n-    rce_loop->dump_head();\n-    legacy_loop->dump_head();\n-  }\n-#endif\n-\n-  \/\/ Now fetch the limit we want to compare against\n-  Node *limit = rce_cl->limit();\n-  bool first_time = true;\n-\n-  \/\/ If we got this far, we identified the post loop which has been RCE'd and\n-  \/\/ we have a work list.  Now we will try to transform the if guard to cause\n-  \/\/ the loop pair to be multi version executed with the determination left to runtime\n-  \/\/ or the optimizer if full information is known about the given arrays at compile time.\n-  Node *last_min = nullptr;\n-  multi_version_succeeded = true;\n-  while (worklist.size()) {\n-    Node* rc_iffm = worklist.pop();\n-    if (rc_iffm->is_If()) {\n-      Node *rc_bolzm = rc_iffm->in(1);\n-      if (rc_bolzm->is_Bool()) {\n-        Node *rc_cmpzm = rc_bolzm->in(1);\n-        if (rc_cmpzm->is_Cmp()) {\n-          Node *rc_left = rc_cmpzm->in(2);\n-          if (rc_left->Opcode() != Op_LoadRange) {\n-            multi_version_succeeded = false;\n-            break;\n-          }\n-          if (first_time) {\n-            last_min = rc_left;\n-            first_time = false;\n-          } else {\n-            Node *cur_min = new MinINode(last_min, rc_left);\n-            last_min = cur_min;\n-            _igvn.register_new_node_with_optimizer(last_min);\n-          }\n-        }\n-      }\n-    }\n-  }\n-\n-  \/\/ All we have to do is update the limit of the rce loop\n-  \/\/ with the min of our expression and the current limit.\n-  \/\/ We will use this expression to replace the current limit.\n-  if (last_min && multi_version_succeeded) {\n-    Node *cur_min = new MinINode(last_min, limit);\n-    _igvn.register_new_node_with_optimizer(cur_min);\n-    Node *cmp_node = rce_loop_end->cmp_node();\n-    _igvn.replace_input_of(cmp_node, 2, cur_min);\n-    set_ctrl(cur_min, ctrl);\n-    set_loop(cur_min, rce_loop->_parent);\n-\n-    legacy_cl->mark_is_multiversioned();\n-    rce_cl->mark_is_multiversioned();\n-    multi_version_succeeded = true;\n-\n-    C->set_major_progress();\n-  }\n-\n-  return multi_version_succeeded;\n-}\n-\n-\/\/-------------------------poison_rce_post_loop--------------------------------\n-\/\/ Causes the rce'd post loop to be optimized away if multiversioning fails\n-void PhaseIdealLoop::poison_rce_post_loop(IdealLoopTree *rce_loop) {\n-  CountedLoopNode *rce_cl = rce_loop->_head->as_CountedLoop();\n-  Node* ctrl = rce_cl->in(LoopNode::EntryControl);\n-  if (ctrl->is_IfTrue() || ctrl->is_IfFalse()) {\n-    Node* iffm = ctrl->in(0);\n-    if (iffm->is_If()) {\n-      Node* cur_bool = iffm->in(1);\n-      if (cur_bool->is_Bool()) {\n-        Node* cur_cmp = cur_bool->in(1);\n-        if (cur_cmp->is_Cmp()) {\n-          BoolTest::mask new_test = BoolTest::gt;\n-          BoolNode *new_bool = new BoolNode(cur_cmp, new_test);\n-          _igvn.replace_node(cur_bool, new_bool);\n-          _igvn._worklist.push(new_bool);\n-          Node* left_op = cur_cmp->in(1);\n-          _igvn.replace_input_of(cur_cmp, 2, left_op);\n-          C->set_major_progress();\n-        }\n-      }\n-    }\n-  }\n-}\n-\n@@ -3867,8 +3681,0 @@\n-    if (should_unroll && !should_peel && PostLoopMultiversioning &&\n-        Matcher::has_predicated_vectors()) {\n-      \/\/ Try to setup multiversioning on main loops before they are unrolled\n-      if (cl->is_main_loop() && (cl->unrolled_count() == 1)) {\n-        phase->insert_scalar_rced_post_loop(this, old_new);\n-      }\n-    }\n-\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":0,"deletions":194,"binary":false,"changes":194,"status":"modified"},{"patch":"@@ -4016,1 +4016,0 @@\n-    if (cl->is_multiversioned()) tty->print(\" multi \");\n@@ -4656,23 +4655,1 @@\n-\n-        if (cl->is_rce_post_loop() && !cl->is_vectorized_loop()) {\n-          assert(PostLoopMultiversioning, \"multiversioning must be enabled\");\n-          \/\/ Check that the rce'd post loop is encountered first, multiversion after all\n-          \/\/ major main loop optimization are concluded\n-          if (!C->major_progress()) {\n-            IdealLoopTree *lpt_next = lpt->_next;\n-            if (lpt_next && lpt_next->is_counted()) {\n-              CountedLoopNode *cl = lpt_next->_head->as_CountedLoop();\n-              if (cl->is_post_loop() && lpt_next->range_checks_present()) {\n-                if (!cl->is_multiversioned()) {\n-                  if (multi_version_post_loops(lpt, lpt_next) == false) {\n-                    \/\/ Cause the rce loop to be optimized away if we fail\n-                    cl->mark_is_multiversioned();\n-                    cl->set_slp_max_unroll(0);\n-                    poison_rce_post_loop(lpt);\n-                  }\n-                }\n-              }\n-            }\n-            sw.transform_loop(lpt, true);\n-          }\n-        } else if (cl->is_main_loop()) {\n+        if (cl->is_main_loop()) {\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":1,"deletions":24,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -75,6 +75,5 @@\n-         IsMultiversioned      = 1<<12,\n-         StripMined            = 1<<13,\n-         SubwordLoop           = 1<<14,\n-         ProfileTripFailed     = 1<<15,\n-         LoopNestInnerLoop     = 1<<16,\n-         LoopNestLongOuterLoop = 1<<17};\n+         StripMined            = 1<<12,\n+         SubwordLoop           = 1<<13,\n+         ProfileTripFailed     = 1<<14,\n+         LoopNestInnerLoop     = 1<<15,\n+         LoopNestLongOuterLoop = 1<<16 };\n@@ -83,2 +82,0 @@\n-  char _postloop_flags;\n-  enum { RCEPostLoop = 1 };\n@@ -96,1 +93,0 @@\n-  bool is_multiversioned() const { return _loop_flags & IsMultiversioned; }\n@@ -113,1 +109,0 @@\n-  void mark_is_multiversioned() { _loop_flags |= IsMultiversioned; }\n@@ -124,3 +119,0 @@\n-  int is_rce_post_loop() const { return _postloop_flags & RCEPostLoop; }\n-  void set_is_rce_post_loop() { _postloop_flags |= RCEPostLoop; }\n-\n@@ -137,1 +129,1 @@\n-      _postloop_flags(0), _profile_trip_cnt(COUNT_UNKNOWN)  {\n+      _profile_trip_cnt(COUNT_UNKNOWN) {\n@@ -325,2 +317,0 @@\n-  void set_slp_pack_count(int pack_count)    { _slp_vector_pack_count = pack_count; }\n-  int  slp_pack_count() const                { return _slp_vector_pack_count; }\n@@ -1308,3 +1298,0 @@\n-  \/\/ Add an RCE'd post loop which we will multi-version adapt for run time test path usage\n-  void insert_scalar_rced_post_loop( IdealLoopTree *loop, Node_List &old_new );\n-\n@@ -1405,7 +1392,0 @@\n-  \/\/ Process post loops which have range checks and try to build a multi-version\n-  \/\/ guard to safely determine if we can execute the post loop which was RCE'd.\n-  bool multi_version_post_loops(IdealLoopTree *rce_loop, IdealLoopTree *legacy_loop);\n-\n-  \/\/ Cause the rce'd post loop to optimized away, this happens if we cannot complete multiverioning\n-  void poison_rce_post_loop(IdealLoopTree *rce_loop);\n-\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":6,"deletions":26,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -57,1 +57,0 @@\n-  _post_block(arena(), 8, 0, nullptr),                      \/\/ nodes common to current block which are marked as post loop vectorizable\n@@ -119,5 +118,0 @@\n-  if (cl->is_rce_post_loop() && is_marked_reduction_loop()) {\n-    \/\/ Post loop vectorization doesn't support reductions\n-    return false;\n-  }\n-\n@@ -179,18 +173,0 @@\n-    if (PostLoopMultiversioning) {\n-      if (cl->is_vectorized_loop() && cl->is_main_loop() && !is_marked_reduction_loop()) {\n-        IdealLoopTree *lpt_next = cl->is_strip_mined() ? lpt->_parent->_next : lpt->_next;\n-        CountedLoopNode *cl_next = lpt_next->_head->as_CountedLoop();\n-        \/\/ Main loop SLP works well for manually unrolled loops. But post loop\n-        \/\/ vectorization doesn't work for these. To bail out the optimization\n-        \/\/ earlier, we have range check and loop stride conditions below.\n-        if (cl_next->is_post_loop() && !lpt_next->range_checks_present() &&\n-            cl_next->stride_is_con() && abs(cl_next->stride_con()) == 1) {\n-          if (!cl_next->is_vectorized_loop()) {\n-            \/\/ Propagate some main loop attributes to its corresponding scalar\n-            \/\/ rce'd post loop for vectorization with vector masks\n-            cl_next->set_slp_max_unroll(cl->slp_max_unroll());\n-            cl_next->set_slp_pack_count(cl->slp_pack_count());\n-          }\n-        }\n-      }\n-    }\n@@ -209,3 +185,0 @@\n-  int rpo_idx = _post_block.length();\n-\n-  assert(rpo_idx == 0, \"post loop block is empty\");\n@@ -316,21 +289,0 @@\n-    \/\/ In the main loop, SLP works well if parts of the operations in the loop body\n-    \/\/ are not vectorizable and those non-vectorizable parts will be unrolled only.\n-    \/\/ But in post loops with vector masks, we create singleton packs directly from\n-    \/\/ scalars so all operations should be vectorized together. This compares the\n-    \/\/ number of packs in the post loop with the main loop and bail out if the post\n-    \/\/ loop potentially has more packs.\n-    if (cl->is_rce_post_loop()) {\n-      for (uint i = 0; i < lpt()->_body.size(); i++) {\n-        if (ignored_loop_nodes[i] == -1) {\n-          _post_block.at_put_grow(rpo_idx++, lpt()->_body.at(i));\n-        }\n-      }\n-      if (_post_block.length() > cl->slp_pack_count()) {\n-        \/\/ Clear local_loop_unroll_factor and bail out directly from here\n-        local_loop_unroll_factor = 0;\n-        cl->mark_was_slp();\n-        cl->set_slp_max_unroll(0);\n-        return;\n-      }\n-    }\n-\n@@ -407,1 +359,1 @@\n-    if (cl->is_main_loop() || cl->is_rce_post_loop()) {\n+    if (cl->is_main_loop()) {\n@@ -593,0 +545,4 @@\n+\n+  CountedLoopNode* cl = lpt()->_head->as_CountedLoop();\n+  assert(cl->is_main_loop(), \"SLP should only work on main loops\");\n+\n@@ -598,1 +554,1 @@\n-  \/\/ build    _dg, _disjoint_ptrs\n+  \/\/ build _dg, _disjoint_ptrs\n@@ -604,5 +560,2 @@\n-  CountedLoopNode *cl = lpt()->_head->as_CountedLoop();\n-  if (cl->is_main_loop()) {\n-    compute_vector_element_type();\n-\n-    \/\/ Attempt vectorization\n+  \/\/ Compute vector element types\n+  compute_vector_element_type();\n@@ -610,5 +563,2 @@\n-    find_adjacent_refs();\n-\n-    if (align_to_ref() == nullptr) {\n-      return false; \/\/ Did not find memory reference to align vectors\n-    }\n+  \/\/ Attempt vectorization\n+  find_adjacent_refs();\n@@ -616,3 +566,3 @@\n-    extend_packlist();\n-\n-    combine_packs();\n+  if (align_to_ref() == nullptr) {\n+    return false; \/\/ Did not find memory reference to align vectors\n+  }\n@@ -620,1 +570,1 @@\n-    construct_my_pack_map();\n+  extend_packlist();\n@@ -622,1 +572,1 @@\n-    filter_packs();\n+  combine_packs();\n@@ -624,1 +574,1 @@\n-    DEBUG_ONLY(verify_packs();)\n+  construct_my_pack_map();\n@@ -626,1 +576,1 @@\n-    schedule();\n+  filter_packs();\n@@ -628,27 +578,1 @@\n-    \/\/ Record eventual count of vector packs for checks in post loop vectorization\n-    if (PostLoopMultiversioning) {\n-      cl->set_slp_pack_count(_packset.length());\n-    }\n-  } else {\n-    assert(cl->is_rce_post_loop(), \"Must be an rce'd post loop\");\n-    int saved_mapped_unroll_factor = cl->slp_max_unroll();\n-    if (saved_mapped_unroll_factor) {\n-      int vector_mapped_unroll_factor = saved_mapped_unroll_factor;\n-\n-      \/\/ now reset the slp_unroll_factor so that we can check the analysis mapped\n-      \/\/ what the vector loop was mapped to\n-      cl->set_slp_max_unroll(0);\n-\n-      \/\/ do the analysis on the post loop\n-      unrolling_analysis(vector_mapped_unroll_factor);\n-\n-      \/\/ if our analyzed loop is a canonical fit, start processing it\n-      if (vector_mapped_unroll_factor == saved_mapped_unroll_factor) {\n-        \/\/ now add the vector nodes to packsets\n-        for (int i = 0; i < _post_block.length(); i++) {\n-          Node* n = _post_block.at(i);\n-          Node_List* singleton = new Node_List();\n-          singleton->push(n);\n-          _packset.append(singleton);\n-          set_my_pack(n, singleton);\n-        }\n+  DEBUG_ONLY(verify_packs();)\n@@ -656,10 +580,1 @@\n-        \/\/ map base types for vector usage\n-        compute_vector_element_type();\n-      } else {\n-        return false;\n-      }\n-    } else {\n-      \/\/ for some reason we could not map the slp analysis state of the vectorized loop\n-      return false;\n-    }\n-  }\n+  schedule();\n@@ -1146,0 +1061,2 @@\n+  assert(cl->is_main_loop(), \"SLP should only work on main loops\");\n+\n@@ -1160,3 +1077,1 @@\n-    if (cl->is_main_loop()) {\n-      mem_slice_preds(n_tail, n, _nlist);\n-    }\n+    mem_slice_preds(n_tail, n, _nlist);\n@@ -2594,0 +2509,1 @@\n+  assert(cl->is_main_loop(), \"SLP should only work on main loops\");\n@@ -2606,5 +2522,3 @@\n-  if (cl->is_main_loop()) {\n-    \/\/ MUST ENSURE main loop's initial value is properly aligned:\n-    \/\/  (iv_initial_value + min_iv_offset) % vector_width_in_bytes() == 0\n-\n-    align_initial_loop_index(align_to_ref());\n+  \/\/ Ensure main loop's initial value is properly aligned\n+  \/\/  (iv_initial_value + min_iv_offset) % vector_width_in_bytes() == 0\n+  align_initial_loop_index(align_to_ref());\n@@ -2612,4 +2526,3 @@\n-    \/\/ Insert extract (unpack) operations for scalar uses\n-    for (int i = 0; i < _packset.length(); i++) {\n-      insert_extracts(_packset.at(i));\n-    }\n+  \/\/ Insert extract (unpack) operations for scalar uses\n+  for (int i = 0; i < _packset.length(); i++) {\n+    insert_extracts(_packset.at(i));\n@@ -2632,10 +2545,0 @@\n-  Node* vmask = nullptr;\n-  if (cl->is_rce_post_loop() && do_reserve_copy()) {\n-    \/\/ Create a vector mask node for post loop, bail out if not created\n-    vmask = create_post_loop_vmask();\n-    if (vmask == nullptr) {\n-      \/\/ create_post_loop_vmask checks many conditions, any of them could fail\n-      return false; \/\/ and reverse to backup IG\n-    }\n-  }\n-\n@@ -2653,4 +2556,0 @@\n-      if (cl->is_rce_post_loop()) {\n-        \/\/ override vlen with the main loops vector length\n-        vlen = cl->slp_max_unroll();\n-      }\n@@ -2678,7 +2577,1 @@\n-        if (cl->is_rce_post_loop()) {\n-          assert(vmask != nullptr, \"vector mask should be generated\");\n-          const TypeVect* vt = TypeVect::make(velt_basic_type(n), vlen);\n-          vn = new LoadVectorMaskedNode(ctl, mem, adr, atyp, vt, vmask);\n-        } else {\n-          vn = LoadVectorNode::make(opc, ctl, mem, adr, atyp, vlen, velt_basic_type(n), control_dependency(p));\n-        }\n+        vn = LoadVectorNode::make(opc, ctl, mem, adr, atyp, vlen, velt_basic_type(n), control_dependency(p));\n@@ -2702,7 +2595,1 @@\n-        if (cl->is_rce_post_loop()) {\n-          assert(vmask != nullptr, \"vector mask should be generated\");\n-          const TypeVect* vt = TypeVect::make(velt_basic_type(n), vlen);\n-          vn = new StoreVectorMaskedNode(ctl, mem, adr, val, atyp, vmask);\n-        } else {\n-          vn = StoreVectorNode::make(opc, ctl, mem, adr, atyp, val, vlen);\n-        }\n+        vn = StoreVectorNode::make(opc, ctl, mem, adr, atyp, val, vlen);\n@@ -2964,1 +2851,0 @@\n-\n@@ -2967,11 +2853,4 @@\n-        if (cl->is_main_loop()) {\n-          \/\/ if vector resources are limited, do not allow additional unrolling, also\n-          \/\/ do not unroll more on pure vector loops which were not reduced so that we can\n-          \/\/ program the post loop to single iteration execution.\n-          if (Matcher::float_pressure_limit() > 8) {\n-            C->set_major_progress();\n-            cl->mark_do_unroll_only();\n-          }\n-        }\n-        if (cl->is_rce_post_loop() && do_reserve_copy()) {\n-          cl->mark_is_multiversioned();\n+        \/\/ if vector resources are limited, do not allow additional unrolling\n+        if (Matcher::float_pressure_limit() > 8) {\n+          C->set_major_progress();\n+          cl->mark_do_unroll_only();\n@@ -2991,101 +2870,0 @@\n-\/\/-------------------------create_post_loop_vmask-------------------------\n-\/\/ Check the post loop vectorizability and create a vector mask if yes.\n-\/\/ Return null to bail out if post loop is not vectorizable.\n-Node* SuperWord::create_post_loop_vmask() {\n-  CountedLoopNode *cl = lpt()->_head->as_CountedLoop();\n-  assert(cl->is_rce_post_loop(), \"Must be an rce post loop\");\n-  assert(!is_marked_reduction_loop(), \"no vector reduction in post loop\");\n-  assert(abs(cl->stride_con()) == 1, \"post loop stride can only be +\/-1\");\n-\n-  \/\/ Collect vector element types of all post loop packs. Also collect\n-  \/\/ superword pointers of each memory access operation if the address\n-  \/\/ expression is supported. (Note that vectorizable post loop should\n-  \/\/ only have positive scale in counting-up loop and negative scale in\n-  \/\/ counting-down loop.) Collected SWPointer(s) are also used for data\n-  \/\/ dependence check next.\n-  VectorElementSizeStats stats(_arena);\n-  GrowableArray<SWPointer*> swptrs(_arena, _packset.length(), 0, nullptr);\n-  for (int i = 0; i < _packset.length(); i++) {\n-    Node_List* p = _packset.at(i);\n-    assert(p->size() == 1, \"all post loop packs should be singleton\");\n-    Node* n = p->at(0);\n-    BasicType bt = velt_basic_type(n);\n-    if (!is_java_primitive(bt)) {\n-      return nullptr;\n-    }\n-    if (n->is_Mem()) {\n-      SWPointer* mem_p = new (_arena) SWPointer(n->as_Mem(), this, nullptr, false);\n-      \/\/ For each memory access, we check if the scale (in bytes) in its\n-      \/\/ address expression is equal to the data size times loop stride.\n-      \/\/ With this, Only positive scales exist in counting-up loops and\n-      \/\/ negative scales exist in counting-down loops.\n-      if (mem_p->scale_in_bytes() != type2aelembytes(bt) * cl->stride_con()) {\n-        return nullptr;\n-      }\n-      swptrs.append(mem_p);\n-    }\n-    stats.record_size(type2aelembytes(bt));\n-  }\n-\n-  \/\/ Find the vector data type for generating vector masks. Currently we\n-  \/\/ don't support post loops with mixed vector data sizes\n-  int unique_size = stats.unique_size();\n-  BasicType vmask_bt;\n-  switch (unique_size) {\n-    case 1:  vmask_bt = T_BYTE; break;\n-    case 2:  vmask_bt = T_SHORT; break;\n-    case 4:  vmask_bt = T_INT; break;\n-    case 8:  vmask_bt = T_LONG; break;\n-    default: return nullptr;\n-  }\n-\n-  \/\/ Currently we can't remove this MaxVectorSize constraint. Without it,\n-  \/\/ it's not guaranteed that the RCE'd post loop runs at most \"vlen - 1\"\n-  \/\/ iterations, because the vector drain loop may not be cloned from the\n-  \/\/ vectorized main loop. We should re-engineer PostLoopMultiversioning\n-  \/\/ to fix this problem.\n-  int vlen = cl->slp_max_unroll();\n-  if (unique_size * vlen != MaxVectorSize) {\n-    return nullptr;\n-  }\n-\n-  \/\/ Bail out if target doesn't support mask generator or masked load\/store\n-  if (!Matcher::match_rule_supported_vector(Op_LoadVectorMasked, vlen, vmask_bt)  ||\n-      !Matcher::match_rule_supported_vector(Op_StoreVectorMasked, vlen, vmask_bt) ||\n-      !Matcher::match_rule_supported_vector(Op_VectorMaskGen, vlen, vmask_bt)) {\n-    return nullptr;\n-  }\n-\n-  \/\/ Bail out if potential data dependence exists between memory accesses\n-  if (SWPointer::has_potential_dependence(swptrs)) {\n-    return nullptr;\n-  }\n-\n-  \/\/ Create vector mask with the post loop trip count. Note there's another\n-  \/\/ vector drain loop which is cloned from main loop before super-unrolling\n-  \/\/ so the scalar post loop runs at most vlen-1 trips. Hence, this version\n-  \/\/ only runs at most 1 iteration after vector mask transformation.\n-  Node* trip_cnt;\n-  Node* new_incr;\n-  if (cl->stride_con() > 0) {\n-    trip_cnt = new SubINode(cl->limit(), cl->init_trip());\n-    new_incr = new AddINode(cl->phi(), trip_cnt);\n-  } else {\n-    trip_cnt = new SubINode(cl->init_trip(), cl->limit());\n-    new_incr = new SubINode(cl->phi(), trip_cnt);\n-  }\n-  _igvn.register_new_node_with_optimizer(trip_cnt);\n-  _igvn.register_new_node_with_optimizer(new_incr);\n-  _igvn.replace_node(cl->incr(), new_incr);\n-  Node* length = new ConvI2LNode(trip_cnt);\n-  _igvn.register_new_node_with_optimizer(length);\n-  Node* vmask = VectorMaskGenNode::make(length, vmask_bt);\n-  _igvn.register_new_node_with_optimizer(vmask);\n-\n-  \/\/ Remove exit test to transform 1-iteration loop to straight-line code.\n-  \/\/ This results in redundant cmp+branch instructions been eliminated.\n-  Node *cl_exit = cl->loopexit();\n-  _igvn.replace_input_of(cl_exit, 1, _igvn.intcon(0));\n-  return vmask;\n-}\n-\n@@ -3101,6 +2879,0 @@\n-  if (cl->is_rce_post_loop()) {\n-    \/\/ override vlen with the main loops vector length\n-    assert(p->size() == 1, \"Packs in post loop should have only one node\");\n-    vlen = cl->slp_max_unroll();\n-  }\n-\n@@ -3110,4 +2882,2 @@\n-  \/\/ all inputs are the same iv, so we do a same inputs check here. But\n-  \/\/ in post loops, \"have_same_inputs\" is always true because all packs\n-  \/\/ are singleton. That's why a pack size check is also required.\n-  if (opd == iv() && (!have_same_inputs || p->size() == 1)) {\n+  \/\/ all inputs are the same iv, so we do a same inputs check here.\n+  if (opd == iv() && !have_same_inputs) {\n@@ -4029,1 +3799,0 @@\n-  _post_block.clear();\n@@ -4450,28 +4219,0 @@\n-\/\/-----------------has_potential_dependence-----------------\n-\/\/ Check potential data dependence among all memory accesses.\n-\/\/ We require every two accesses (with at least one store) of\n-\/\/ the same element type has the same address expression.\n-bool SWPointer::has_potential_dependence(GrowableArray<SWPointer*> swptrs) {\n-  for (int i1 = 0; i1 < swptrs.length(); i1++) {\n-    SWPointer* p1 = swptrs.at(i1);\n-    MemNode* n1 = p1->mem();\n-    BasicType bt1 = n1->memory_type();\n-\n-    \/\/ Iterate over remaining SWPointers\n-    for (int i2 = i1 + 1; i2 < swptrs.length(); i2++) {\n-      SWPointer* p2 = swptrs.at(i2);\n-      MemNode* n2 = p2->mem();\n-      BasicType bt2 = n2->memory_type();\n-\n-      \/\/ Data dependence exists between load-store, store-load\n-      \/\/ or store-store with the same element type or subword\n-      \/\/ size (subword load\/store may have inaccurate type)\n-      if ((n1->is_Store() || n2->is_Store()) &&\n-          same_type_or_subword_size(bt1, bt2) && !p1->equal(*p2)) {\n-        return true;\n-      }\n-    }\n-  }\n-  return false;\n-}\n-\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":37,"deletions":296,"binary":false,"changes":333,"status":"modified"},{"patch":"@@ -288,1 +288,0 @@\n-  GrowableArray<Node*> _post_block;      \/\/ Nodes in post loop block\n@@ -582,2 +581,0 @@\n-  \/\/ Create vector mask for post loop vectorization\n-  Node* create_post_loop_vmask();\n@@ -728,2 +725,0 @@\n-  static bool has_potential_dependence(GrowableArray<SWPointer*> swptrs);\n-\n","filename":"src\/hotspot\/share\/opto\/superword.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1,41 +0,0 @@\n-\/*\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test TestRangeCheckEliminationDisabled\n- * @bug 8154763\n- * @summary Tests PostLoopMultiversioning with RangeCheckElimination disabled.\n- * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:+UnlockDiagnosticVMOptions\n- *                   -XX:+UnlockExperimentalVMOptions -XX:+PostLoopMultiversioning -XX:-RangeCheckElimination\n- *                   compiler.rangechecks.TestRangeCheckEliminationDisabled\n- *\/\n-\n-package compiler.rangechecks;\n-\n-public class TestRangeCheckEliminationDisabled {\n-\n-    public static void main(String[] args) {\n-      System.out.println(\"Passed\");\n-    }\n-}\n-\n","filename":"test\/hotspot\/jtreg\/compiler\/rangechecks\/TestRangeCheckEliminationDisabled.java","additions":0,"deletions":41,"binary":false,"changes":41,"status":"deleted"},{"patch":"@@ -64,3 +64,0 @@\n-        \/\/ Add extra VM options to verify experimental auto-vectorization\n-        WB.setBooleanVMFlag(\"UnlockExperimentalVMOptions\", true);\n-        WB.setBooleanVMFlag(\"PostLoopMultiversioning\", true);\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/VectorizationTestRunner.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"}]}