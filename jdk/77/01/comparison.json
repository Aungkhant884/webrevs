{"files":[{"patch":"@@ -609,4 +609,1 @@\n-    \/\/ register serializer, phases will be added later lazily.\n-    GrowableArray<const char*>* jvmci_phase_names = new GrowableArray<const char*>(1);\n-    jvmci_phase_names->append(\"NOT_A_PHASE_NAME\");\n-    CompilerEvent::PhaseEvent::register_phases(jvmci_phase_names);\n+    CompilerEvent::PhaseEvent::get_phase_id(\"NOT_A_PHASE_NAME\", false, false, false);\n@@ -619,1 +616,2 @@\n-      c2_phase_names->append(CompilerPhaseTypeHelper::to_string((CompilerPhaseType)i));\n+      const char* phase_name = CompilerPhaseTypeHelper::to_string((CompilerPhaseType) i);\n+      CompilerEvent::PhaseEvent::get_phase_id(phase_name, false, false, false);\n@@ -621,1 +619,0 @@\n-    CompilerEvent::PhaseEvent::register_phases(c2_phase_names);\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.cpp","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+  bool _enabled;\n@@ -38,2 +39,7 @@\n-  PhaseTypeGuard() {\n-    _mutex_semaphore.wait();\n+  PhaseTypeGuard(bool enabled=true) {\n+    if (enabled) {\n+      _mutex_semaphore.wait();\n+      _enabled = true;\n+    } else {\n+      _enabled = false;\n+    }\n@@ -42,1 +48,3 @@\n-    _mutex_semaphore.signal();\n+    if (_enabled) {\n+      _mutex_semaphore.signal();\n+    }\n@@ -48,11 +56,1 @@\n-static void write_phases(JfrCheckpointWriter& writer, u4 base_idx, GrowableArray<const char*>* phases) {\n-  assert(phases != NULL, \"invariant\");\n-  assert(phases->is_nonempty(), \"invariant\");\n-  const u4 nof_entries = phases->length();\n-  writer.write_count(nof_entries);\n-  for (u4 i = 0; i < nof_entries; i++) {\n-    writer.write_key(base_idx + i);\n-    writer.write(phases->at(i));\n-  }\n-}\n-\n+\/\/ Table for mapping compiler phases names to int identifiers.\n@@ -65,1 +63,8 @@\n-    write_phases(writer, 0, phase_names);\n+    assert(phase_names != NULL, \"invariant\");\n+    assert(phase_names->is_nonempty(), \"invariant\");\n+    const u4 nof_entries = phase_names->length();\n+    writer.write_count(nof_entries);\n+    for (u4 i = 0; i < nof_entries; i++) {\n+      writer.write_key(i);\n+      writer.write(phase_names->at(i));\n+    }\n@@ -69,8 +74,6 @@\n-\/\/ This function provides support for adding dynamic entries to JFR type CompilerPhaseType.\n-\/\/ The mapping for CompilerPhaseType is maintained as growable array phase_names.\n-\/\/ The serializer CompilerPhaseTypeConstant must be registered with JFR at vm init.\n-\/\/ Registration of new phase names creates mapping, serialize it for current chunk and registers its serializer with JFR if it is not already done.\n-int CompilerEvent::PhaseEvent::register_phases(GrowableArray<const char*>* new_phases) {\n-  int idx = -1;\n-  if (new_phases == NULL || new_phases->is_empty()) {\n-    return idx;\n+static int lookup_phase(const char* phase_name) {\n+  for (int i = 0; i < phase_names->length(); i++) {\n+    const char* name = phase_names->at(i);\n+    if (strcmp(name, phase_name) == 0) {\n+      return i;\n+    }\n@@ -78,0 +81,5 @@\n+  return -1;\n+}\n+\n+int CompilerEvent::PhaseEvent::get_phase_id(const char* phase_name, bool may_exist, bool use_strdup, bool sync) {\n+  int index;\n@@ -80,1 +88,1 @@\n-    PhaseTypeGuard guard;\n+    PhaseTypeGuard guard(sync);\n@@ -82,1 +90,1 @@\n-      phase_names = new (ResourceObj::C_HEAP, mtCompiler) GrowableArray<const char*>(100, mtCompiler);\n+      phase_names = new (ResourceObj::C_HEAP, mtInternal) GrowableArray<const char*>(100, mtCompiler);\n@@ -84,0 +92,7 @@\n+    } else if (may_exist) {\n+      index = lookup_phase(phase_name);\n+      if (index != -1) {\n+        return index;\n+      }\n+    } else {\n+      assert((index = lookup_phase(phase_name)) == -1, \"phase name \\\"%s\\\" already registered: %d\", phase_name, index);\n@@ -85,3 +100,3 @@\n-    idx = phase_names->length();\n-    phase_names->appendAll(new_phases);\n-    guarantee(phase_names->length() < 256, \"exceeds maximum supported phases\");\n+\n+    index = phase_names->length();\n+    phase_names->append(use_strdup ? strdup(phase_name) : phase_name);\n@@ -92,1 +107,1 @@\n-    \/\/ serialize new_phases.\n+    \/\/ serialize new phase.\n@@ -95,1 +110,3 @@\n-    write_phases(writer, idx, new_phases);\n+    writer.write_count(1);\n+    writer.write_key(index);\n+    writer.write(phase_name);\n@@ -97,1 +114,1 @@\n-  return idx;\n+  return index;\n","filename":"src\/hotspot\/share\/compiler\/compilerEvent.cpp","additions":48,"deletions":31,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -67,9 +67,7 @@\n-    \/**\n-     * Register compiler phases for JFR type CompilerPhaseType serialization purposes.\n-     * This method is called during compiler creation or during compilation.\n-     * Registration will serialize the passed in phase constants, supporting bulk and\/or incremental registrations.\n-     * This method returns start index of new list that just got appended to phase_names.\n-     * Param new_phases may contain duplicates.\n-     * Return value could be used for mapping purpose at caller site, or caller can assume explicit order of registration.\n-     *\/\n-    static int register_phases(GrowableArray<const char*>* new_phases) NOT_JFR_RETURN_(-1);\n+\n+    \/\/ Gets a unique identifier for `phase_name`, computing and registering it first if necessary.\n+    \/\/ If `may_exist` is true, then current registrations are searched first. If false, then\n+    \/\/ there must not be an existing registration for `phase_name`.\n+    \/\/ If `use_strdup` is true, then `phase_name` is strdup'ed before registration.\n+    \/\/ If `sync` is true, then access to the registration table is synchronized.\n+    static int get_phase_id(const char* phase_name, bool may_exist, bool use_strdup, bool sync) NOT_JFR_RETURN_(-1);\n","filename":"src\/hotspot\/share\/compiler\/compilerEvent.hpp","additions":7,"deletions":9,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2643,1 +2643,1 @@\n-C2V_VMENTRY_0(jint, registerCompilerPhases, (JNIEnv* env, jobject, jobjectArray jphases))\n+C2V_VMENTRY_0(jint, registerCompilerPhase, (JNIEnv* env, jobject, jstring jphase_name))\n@@ -2645,11 +2645,3 @@\n-  if (jphases == NULL) {\n-    return -1;\n-  }\n-  JVMCIObjectArray phases = JVMCIENV->wrap(jphases);\n-  int len = JVMCIENV->get_length(phases);\n-  GrowableArray<const char*>* jvmci_phase_names = new GrowableArray<const char*>(len);\n-  for (int i = 0; i < len; i++) {\n-    JVMCIObject phase = JVMCIENV->get_object_at(phases, i);\n-    jvmci_phase_names->append(strdup(JVMCIENV->as_utf8_string(phase)));\n-  }\n-  return CompilerEvent::PhaseEvent::register_phases(jvmci_phase_names);\n+  JVMCIObject phase_name = JVMCIENV->wrap(jphase_name);\n+  const char *name = JVMCIENV->as_utf8_string(phase_name);\n+  return CompilerEvent::PhaseEvent::get_phase_id(name, true, true, true);\n@@ -2827,1 +2819,1 @@\n-  {CC \"registerCompilerPhases\",                       CC \"([\" STRING \")I\",                                                                  FN_PTR(registerCompilerPhases)},\n+  {CC \"registerCompilerPhase\",                        CC \"(\" STRING \")I\",                                                                   FN_PTR(registerCompilerPhase)},\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":5,"deletions":13,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -1002,1 +1002,1 @@\n-     * @see JFR.CompilerPhaseEvent#registerPhases and JFR.CompilerPhaseEvent#write\n+     * @see JFR.CompilerPhaseEvent#write\n@@ -1004,1 +1004,1 @@\n-    native int registerCompilerPhases(String[] phases);\n+    native int registerCompilerPhase(String phaseName);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/CompilerToVM.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -24,1 +24,0 @@\n-\n@@ -36,2 +35,3 @@\n- * Helper methods for interacting with the Java Flight Recorder (JFR) to register events and notify it when events occur.\n- * The JFR events are defined in {see @code src\/share\/jfr\/metadata\/metadata.xml}.\n+ * Helper methods for interacting with the Java Flight Recorder (JFR) to register events and notify\n+ * it when events occur. The JFR events are defined in {see @code\n+ * src\/share\/jfr\/metadata\/metadata.xml}.\n@@ -63,16 +63,1 @@\n-            String[] phaseNames = { phaseName };\n-            return phaseToId.computeIfAbsent(phaseName, k -> compilerToVM().registerCompilerPhases(phaseNames));\n-        }\n-\n-        \/**\n-         * Registers new compiler phases with JFR. This should be called during compiler initialization.\n-         *\n-         * @param phaseNames compiler phase names\n-         *\/\n-        public static synchronized void registerPhases(String[] phaseNames) {\n-            ArrayList<String> toProcess = new ArrayList<>(Arrays.asList(phaseNames));\n-            toProcess.removeAll(phaseToId.keySet());\n-            int pid = compilerToVM().registerCompilerPhases(toProcess.toArray(new String[toProcess.size()]));\n-            for (String phase : toProcess) {\n-                phaseToId.put(phase, pid++);\n-            }\n+            return phaseToId.computeIfAbsent(phaseName, k -> compilerToVM().registerCompilerPhase(phaseName));\n@@ -95,2 +80,2 @@\n-     * Helper methods for managing JFR CompilerInlining events.\n-     * The events are defined in {see @code src\/share\/jfr\/metadata\/metadata.xml}.\n+     * Helper methods for managing JFR CompilerInlining events. The events are defined in {see @code\n+     * src\/share\/jfr\/metadata\/metadata.xml}.\n@@ -115,1 +100,0 @@\n-\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/JFR.java","additions":6,"deletions":22,"binary":false,"changes":28,"status":"modified"}]}