{"files":[{"patch":"@@ -0,0 +1,173 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @modules java.base\/sun.security.tools.keytool\n+ * @summary JARs with pending signature files (where .RSA comes before .SF) should verify correctly\n+ *\/\n+\n+import jdk.security.jarsigner.JarSigner;\n+\n+import java.io.File;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.security.KeyStore;\n+import java.util.Collections;\n+import java.util.jar.*;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipFile;\n+import java.util.zip.ZipOutputStream;\n+\n+public class PendingBlocksJar {\n+\n+    public static void main(String[] args) throws Exception {\n+        Path jar = createJarFile();\n+        Path signed = signJarFile(jar);\n+        Path pendingBlocks = moveBlockFirst(signed);\n+        Path invalid = invalidate(pendingBlocks);\n+\n+        \/\/ 1: Regular signed JAR with no pending blocks should verify\n+        checkSigned(signed);\n+\n+        \/\/ 2: Signed jar with pending blocks should verify\n+        checkSigned(pendingBlocks);\n+\n+        \/\/ 3: Invalid signed jar with pending blocks should throw SecurityException\n+        try {\n+            checkSigned(invalid);\n+            throw new Exception(\"Expected invalid digest to be detected\");\n+        } catch (SecurityException se) {\n+            \/\/ Ignore\n+        }\n+    }\n+\n+    private static void checkSigned(Path b) throws Exception {\n+        try (JarFile jf = new JarFile(b.toFile(), true)) {\n+\n+            JarEntry je = jf.getJarEntry(\"a.txt\");\n+            try (InputStream in = jf.getInputStream(je)) {\n+                in.transferTo(OutputStream.nullOutputStream());\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Invalidate signed file by modifying the contents of \"a.txt\"\n+     *\/\n+    private static Path invalidate(Path s) throws Exception{\n+        Path invalid = Path.of(\"pending-block-file-invalidated.jar\");\n+\n+        try (ZipFile zip = new ZipFile(s.toFile());\n+            ZipOutputStream out = new ZipOutputStream(Files.newOutputStream(invalid))) {\n+\n+            for (ZipEntry ze : Collections.list(zip.entries())) {\n+                String name = ze.getName();\n+                out.putNextEntry(new ZipEntry(name));\n+\n+                if (name.equals(\"a.txt\")) {\n+                    \/\/ Change the contents of a.txt to trigger SignatureException\n+                    out.write(\"b\".getBytes(StandardCharsets.UTF_8));\n+                } else {\n+                    try (InputStream in = zip.getInputStream(ze)) {\n+                        in.transferTo(out);\n+                    }\n+                }\n+            }\n+        }\n+        return invalid;\n+    }\n+\n+    private static Path moveBlockFirst(Path s) throws Exception {\n+        Path b = Path.of(\"pending-block-file-blockfirst.jar\");\n+        try (ZipFile in = new ZipFile(s.toFile());\n+            ZipOutputStream out = new ZipOutputStream(Files.newOutputStream(b))) {\n+\n+            copy(\"META-INF\/MANIFEST.MF\", in, out);\n+\n+            \/\/ Switch the order of the RSA and SF files\n+            copy(\"META-INF\/SIGNER.RSA\", in, out);\n+            copy(\"META-INF\/SIGNER.SF\", in, out);\n+\n+            copy(\"a.txt\", in, out);\n+        }\n+        return b;\n+    }\n+\n+    \/**\n+     * Copy an entry from a ZipFile to a ZipOutputStream\n+     *\/\n+    private static void copy(String name, ZipFile in, ZipOutputStream out) throws Exception {\n+        out.putNextEntry(new ZipEntry(name));\n+        try (InputStream is = in.getInputStream(in.getEntry(name))) {\n+            is.transferTo(out);\n+        }\n+    }\n+\n+    private static Path signJarFile(Path j) throws Exception {\n+        Path s = Path.of(\"pending-block-file-signed.jar\");\n+\n+        Files.deleteIfExists(Path.of(\"ks\"));\n+\n+        sun.security.tools.keytool.Main.main(\n+                (\"-keystore ks -storepass changeit -keypass changeit -dname\" +\n+                        \" CN=SIGNER\" +\" -alias r -genkeypair -keyalg rsa\").split(\" \"));\n+\n+        char[] pass = \"changeit\".toCharArray();\n+\n+        KeyStore ks = KeyStore.getInstance(new File(\"ks\"), pass);\n+\n+        KeyStore.PrivateKeyEntry pke = (KeyStore.PrivateKeyEntry)\n+                ks.getEntry(\"r\", new KeyStore.PasswordProtection(pass));\n+\n+        JarSigner signer = new JarSigner.Builder(pke)\n+                .digestAlgorithm(\"SHA-256\")\n+                .signatureAlgorithm(\"SHA256withRSA\")\n+                .signerName(\"SIGNER\")\n+                .build();\n+\n+        try (ZipFile in = new ZipFile(j.toFile());\n+            OutputStream out = Files.newOutputStream(s)) {\n+            signer.sign(in, out);\n+        }\n+\n+        return s;\n+    }\n+\n+    \/**\n+     * Create a jar file with single entry \"a.txt\" containing \"a\"\n+     *\/\n+    private static Path createJarFile() throws Exception {\n+        Path jar = Path.of(\"pending-block-file.jar\");\n+        Manifest manifest = new Manifest();\n+        manifest.getMainAttributes().put(Attributes.Name.MANIFEST_VERSION, \"1.0\");\n+        try (JarOutputStream out = new JarOutputStream(Files.newOutputStream(jar),manifest)) {\n+            out.putNextEntry(new JarEntry(\"a.txt\"));\n+            out.write(\"a\".getBytes(StandardCharsets.UTF_8));\n+        }\n+        return jar;\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/jar\/JarFile\/PendingBlocksJar.java","additions":173,"deletions":0,"binary":false,"changes":173,"status":"added"}]}