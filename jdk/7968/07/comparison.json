{"files":[{"patch":"@@ -2459,0 +2459,9 @@\n+void Assembler::lzcntl(Register dst, Address src) {\n+  assert(VM_Version::supports_lzcnt(), \"encoding is treated as BSR\");\n+  InstructionMark im(this);\n+  emit_int8((unsigned char)0xF3);\n+  prefix(src, dst);\n+  emit_int16(0x0F, (unsigned char)0xBD);\n+  emit_operand(dst, src);\n+}\n+\n@@ -5886,0 +5895,9 @@\n+void Assembler::tzcntl(Register dst, Address src) {\n+  assert(VM_Version::supports_bmi1(), \"tzcnt instruction not supported\");\n+  InstructionMark im(this);\n+  emit_int8((unsigned char)0xF3);\n+  prefix(src, dst);\n+  emit_int16(0x0F, (unsigned char)0xBC);\n+  emit_operand(dst, src);\n+}\n+\n@@ -5893,0 +5911,9 @@\n+void Assembler::tzcntq(Register dst, Address src) {\n+  assert(VM_Version::supports_bmi1(), \"tzcnt instruction not supported\");\n+  InstructionMark im(this);\n+  emit_int8((unsigned char)0xF3);\n+  prefixq(src, dst);\n+  emit_int16(0x0F, (unsigned char)0xBC);\n+  emit_operand(dst, src);\n+}\n+\n@@ -11509,0 +11536,32 @@\n+void Assembler::sarxl(Register dst, Register src1, Register src2) {\n+  assert(VM_Version::supports_bmi2(), \"\");\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  int encode = vex_prefix_and_encode(dst->encoding(), src2->encoding(), src1->encoding(), VEX_SIMD_F3, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16((unsigned char)0xF7, (0xC0 | encode));\n+}\n+\n+void Assembler::sarxl(Register dst, Address src1, Register src2) {\n+  assert(VM_Version::supports_bmi2(), \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  vex_prefix(src1, src2->encoding(), dst->encoding(), VEX_SIMD_F3, VEX_OPCODE_0F_38, &attributes);\n+  emit_int8((unsigned char)0xF7);\n+  emit_operand(dst, src1);\n+}\n+\n+void Assembler::sarxq(Register dst, Register src1, Register src2) {\n+  assert(VM_Version::supports_bmi2(), \"\");\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  int encode = vex_prefix_and_encode(dst->encoding(), src2->encoding(), src1->encoding(), VEX_SIMD_F3, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16((unsigned char)0xF7, (0xC0 | encode));\n+}\n+\n+void Assembler::sarxq(Register dst, Address src1, Register src2) {\n+  assert(VM_Version::supports_bmi2(), \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  vex_prefix(src1, src2->encoding(), dst->encoding(), VEX_SIMD_F3, VEX_OPCODE_0F_38, &attributes);\n+  emit_int8((unsigned char)0xF7);\n+  emit_operand(dst, src1);\n+}\n+\n@@ -11516,0 +11575,9 @@\n+void Assembler::shlxl(Register dst, Address src1, Register src2) {\n+  assert(VM_Version::supports_bmi2(), \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  vex_prefix(src1, src2->encoding(), dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int8((unsigned char)0xF7);\n+  emit_operand(dst, src1);\n+}\n+\n@@ -11523,0 +11591,9 @@\n+void Assembler::shlxq(Register dst, Address src1, Register src2) {\n+  assert(VM_Version::supports_bmi2(), \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  vex_prefix(src1, src2->encoding(), dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int8((unsigned char)0xF7);\n+  emit_operand(dst, src1);\n+}\n+\n@@ -11530,0 +11607,9 @@\n+void Assembler::shrxl(Register dst, Address src1, Register src2) {\n+  assert(VM_Version::supports_bmi2(), \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  vex_prefix(src1, src2->encoding(), dst->encoding(), VEX_SIMD_F2, VEX_OPCODE_0F_38, &attributes);\n+  emit_int8((unsigned char)0xF7);\n+  emit_operand(dst, src1);\n+}\n+\n@@ -11537,0 +11623,9 @@\n+void Assembler::shrxq(Register dst, Address src1, Register src2) {\n+  assert(VM_Version::supports_bmi2(), \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  vex_prefix(src1, src2->encoding(), dst->encoding(), VEX_SIMD_F2, VEX_OPCODE_0F_38, &attributes);\n+  emit_int8((unsigned char)0xF7);\n+  emit_operand(dst, src1);\n+}\n+\n@@ -12503,0 +12598,9 @@\n+void Assembler::lzcntq(Register dst, Address src) {\n+  assert(VM_Version::supports_lzcnt(), \"encoding is treated as BSR\");\n+  InstructionMark im(this);\n+  emit_int8((unsigned char)0xF3);\n+  prefixq(src, dst);\n+  emit_int16(0x0F, (unsigned char)0xBD);\n+  emit_operand(dst, src);\n+}\n+\n@@ -12897,2 +13001,1 @@\n-\n-void Assembler::rorxq(Register dst, Register src, int imm8) {\n+void Assembler::rorxl(Register dst, Register src, int imm8) {\n@@ -12900,1 +13003,1 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n@@ -12905,1 +13008,1 @@\n-void Assembler::rorxd(Register dst, Register src, int imm8) {\n+void Assembler::rorxl(Register dst, Address src, int imm8) {\n@@ -12907,0 +13010,1 @@\n+  InstructionMark im(this);\n@@ -12908,0 +13012,9 @@\n+  vex_prefix(src, 0, dst->encoding(), VEX_SIMD_F2, VEX_OPCODE_0F_3A, &attributes);\n+  emit_int8((unsigned char)0xF0);\n+  emit_operand(dst, src);\n+  emit_int8(imm8);\n+}\n+\n+void Assembler::rorxq(Register dst, Register src, int imm8) {\n+  assert(VM_Version::supports_bmi2(), \"bit manipulation instructions not supported\");\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n@@ -12912,0 +13025,10 @@\n+void Assembler::rorxq(Register dst, Address src, int imm8) {\n+  assert(VM_Version::supports_bmi2(), \"bit manipulation instructions not supported\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  vex_prefix(src, 0, dst->encoding(), VEX_SIMD_F2, VEX_OPCODE_0F_3A, &attributes);\n+  emit_int8((unsigned char)0xF0);\n+  emit_operand(dst, src);\n+  emit_int8(imm8);\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":127,"deletions":4,"binary":false,"changes":131,"status":"modified"},{"patch":"@@ -1444,0 +1444,1 @@\n+  void lzcntl(Register dst, Address src);\n@@ -1447,0 +1448,1 @@\n+  void lzcntq(Register dst, Address src);\n@@ -1982,0 +1984,2 @@\n+  void rorxl(Register dst, Register src, int imm8);\n+  void rorxl(Register dst, Address src, int imm8);\n@@ -1983,1 +1987,1 @@\n-  void rorxd(Register dst, Register src, int imm8);\n+  void rorxq(Register dst, Address src, int imm8);\n@@ -2119,0 +2123,1 @@\n+  void tzcntl(Register dst, Address src);\n@@ -2120,0 +2125,1 @@\n+  void tzcntq(Register dst, Address src);\n@@ -2195,0 +2201,4 @@\n+  void sarxl(Register dst, Register src1, Register src2);\n+  void sarxl(Register dst, Address src1, Register src2);\n+  void sarxq(Register dst, Register src1, Register src2);\n+  void sarxq(Register dst, Address src1, Register src2);\n@@ -2196,0 +2206,1 @@\n+  void shlxl(Register dst, Address src1, Register src2);\n@@ -2197,0 +2208,1 @@\n+  void shlxq(Register dst, Address src1, Register src2);\n@@ -2198,0 +2210,1 @@\n+  void shrxl(Register dst, Address src1, Register src2);\n@@ -2199,0 +2212,1 @@\n+  void shrxq(Register dst, Address src1, Register src2);\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":15,"deletions":1,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -702,1 +702,1 @@\n-  Condition negate_condition(Condition cond);\n+  static Condition negate_condition(Condition cond);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -528,2 +528,2 @@\n-  rorxd(reg_y0, reg_e, 25);    \/\/ reg_y0 = reg_e >> 25   ; S1A\n-  rorxd(reg_y1, reg_e, 11);    \/\/ reg_y1 = reg_e >> 11    ; S1B\n+  rorxl(reg_y0, reg_e, 25);    \/\/ reg_y0 = reg_e >> 25   ; S1A\n+  rorxl(reg_y1, reg_e, 11);    \/\/ reg_y1 = reg_e >> 11    ; S1B\n@@ -533,1 +533,1 @@\n-  rorxd(reg_y1, reg_e, 6);     \/\/ reg_y1 = (reg_e >> 6)    ; S1\n+  rorxl(reg_y1, reg_e, 6);     \/\/ reg_y1 = (reg_e >> 6)    ; S1\n@@ -541,1 +541,1 @@\n-  rorxd(reg_T1, reg_a, 13);   \/\/ reg_T1 = reg_a >> 13    ; S0B\n+  rorxl(reg_T1, reg_a, 13);   \/\/ reg_T1 = reg_a >> 13    ; S0B\n@@ -543,1 +543,1 @@\n-  rorxd(reg_y1, reg_a, 22);   \/\/ reg_y1 = reg_a >> 22    ; S0A\n+  rorxl(reg_y1, reg_a, 22);   \/\/ reg_y1 = reg_a >> 22    ; S0A\n@@ -547,1 +547,1 @@\n-  rorxd(reg_T1, reg_a, 2);    \/\/ reg_T1 = (reg_a >> 2)    ; S0\n+  rorxl(reg_T1, reg_a, 2);    \/\/ reg_T1 = (reg_a >> 2)    ; S0\n@@ -601,2 +601,2 @@\n-  rorxd(r13, reg_e, 25);      \/\/ r13 = reg_e >> 25    ; S1A\n-  rorxd(r14, reg_e, 11);      \/\/  r14 = reg_e >> 11    ; S1B\n+  rorxl(r13, reg_e, 25);      \/\/ r13 = reg_e >> 25    ; S1A\n+  rorxl(r14, reg_e, 11);      \/\/  r14 = reg_e >> 11    ; S1B\n@@ -607,1 +607,1 @@\n-  rorxd(r12, reg_a, 13);      \/\/ r12 = reg_a >> 13      ; S0B\n+  rorxl(r12, reg_a, 13);      \/\/ r12 = reg_a >> 13      ; S0B\n@@ -611,1 +611,1 @@\n-  rorxd(r14, reg_e, 6);       \/\/ r14 = (reg_e >> 6)    ; S1\n+  rorxl(r14, reg_e, 6);       \/\/ r14 = (reg_e >> 6)    ; S1\n@@ -615,1 +615,1 @@\n-  rorxd(r14, reg_a, 22);      \/\/ r14 = reg_a >> 22    ; S0A\n+  rorxl(r14, reg_a, 22);      \/\/ r14 = reg_a >> 22    ; S0A\n@@ -621,1 +621,1 @@\n-  rorxd(r12, reg_a, 2);      \/\/ r12 = (reg_a >> 2)    ; S0\n+  rorxl(r12, reg_a, 2);      \/\/ r12 = (reg_a >> 2)    ; S0\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86_sha.cpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -6574,0 +6574,12 @@\n+instruct countLeadingZerosI_mem(rRegI dst, memory src, rFlagsReg cr) %{\n+  predicate(UseCountLeadingZerosInstruction);\n+  match(Set dst (CountLeadingZerosI (LoadI src)));\n+  effect(KILL cr);\n+  ins_cost(175);\n+  format %{ \"lzcntl  $dst, $src\\t# count leading zeros (int)\" %}\n+  ins_encode %{\n+    __ lzcntl($dst$$Register, $src$$Address);\n+  %}\n+  ins_pipe(ialu_reg_mem);\n+%}\n+\n@@ -6611,0 +6623,12 @@\n+instruct countLeadingZerosL_mem(rRegI dst, memory src, rFlagsReg cr) %{\n+  predicate(UseCountLeadingZerosInstruction);\n+  match(Set dst (CountLeadingZerosL (LoadL src)));\n+  effect(KILL cr);\n+  ins_cost(175);\n+  format %{ \"lzcntq  $dst, $src\\t# count leading zeros (long)\" %}\n+  ins_encode %{\n+    __ lzcntq($dst$$Register, $src$$Address);\n+  %}\n+  ins_pipe(ialu_reg_mem);\n+%}\n+\n@@ -6648,0 +6672,12 @@\n+instruct countTrailingZerosI_mem(rRegI dst, memory src, rFlagsReg cr) %{\n+  predicate(UseCountTrailingZerosInstruction);\n+  match(Set dst (CountTrailingZerosI (LoadI src)));\n+  effect(KILL cr);\n+  ins_cost(175);\n+  format %{ \"tzcntl    $dst, $src\\t# count trailing zeros (int)\" %}\n+  ins_encode %{\n+    __ tzcntl($dst$$Register, $src$$Address);\n+  %}\n+  ins_pipe(ialu_reg_mem);\n+%}\n+\n@@ -6680,0 +6716,12 @@\n+instruct countTrailingZerosL_mem(rRegI dst, memory src, rFlagsReg cr) %{\n+  predicate(UseCountTrailingZerosInstruction);\n+  match(Set dst (CountTrailingZerosL (LoadL src)));\n+  effect(KILL cr);\n+  ins_cost(175);\n+  format %{ \"tzcntq    $dst, $src\\t# count trailing zeros (long)\" %}\n+  ins_encode %{\n+    __ tzcntq($dst$$Register, $src$$Address);\n+  %}\n+  ins_pipe(ialu_reg_mem);\n+%}\n+\n@@ -7043,0 +7091,14 @@\n+instruct cmovI_imm_01(rRegI dst, immI_1 src, rFlagsReg cr, cmpOp cop)\n+%{\n+  predicate(n->in(2)->in(2)->is_Con() && n->in(2)->in(2)->get_int() == 0);\n+  match(Set dst (CMoveI (Binary cop cr) (Binary src dst)));\n+\n+  ins_cost(100); \/\/ XXX\n+  format %{ \"setbn$cop $dst\\t# signed, int\" %}\n+  ins_encode %{\n+    Assembler::Condition cond = (Assembler::Condition)($cop$$cmpcode);\n+    __ setb(MacroAssembler::negate_condition(cond), $dst$$Register);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n@@ -7055,0 +7117,14 @@\n+instruct cmovI_imm_01U(rRegI dst, immI_1 src, rFlagsRegU cr, cmpOpU cop)\n+%{\n+  predicate(n->in(2)->in(2)->is_Con() && n->in(2)->in(2)->get_int() == 0);\n+  match(Set dst (CMoveI (Binary cop cr) (Binary src dst)));\n+\n+  ins_cost(100); \/\/ XXX\n+  format %{ \"setbn$cop $dst\\t# unsigned, int\" %}\n+  ins_encode %{\n+    Assembler::Condition cond = (Assembler::Condition)($cop$$cmpcode);\n+    __ setb(MacroAssembler::negate_condition(cond), $dst$$Register);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n@@ -7066,0 +7142,14 @@\n+instruct cmovI_imm_01UCF(rRegI dst, immI_1 src, rFlagsRegUCF cr, cmpOpUCF cop)\n+%{\n+  predicate(n->in(2)->in(2)->is_Con() && n->in(2)->in(2)->get_int() == 0);\n+  match(Set dst (CMoveI (Binary cop cr) (Binary src dst)));\n+\n+  ins_cost(100); \/\/ XXX\n+  format %{ \"setbn$cop $dst\\t# unsigned, int\" %}\n+  ins_encode %{\n+    Assembler::Condition cond = (Assembler::Condition)($cop$$cmpcode);\n+    __ setb(MacroAssembler::negate_condition(cond), $dst$$Register);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n@@ -7202,0 +7292,14 @@\n+instruct cmovL_imm_01(rRegL dst, immI_1 src, rFlagsReg cr, cmpOp cop)\n+%{\n+  predicate(n->in(2)->in(2)->is_Con() && n->in(2)->in(2)->get_long() == 0);\n+  match(Set dst (CMoveL (Binary cop cr) (Binary src dst)));\n+\n+  ins_cost(100); \/\/ XXX\n+  format %{ \"setbn$cop $dst\\t# signed, long\" %}\n+  ins_encode %{\n+    Assembler::Condition cond = (Assembler::Condition)($cop$$cmpcode);\n+    __ setb(MacroAssembler::negate_condition(cond), $dst$$Register);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n@@ -7226,0 +7330,14 @@\n+instruct cmovL_imm_01U(rRegL dst, immI_1 src, rFlagsRegU cr, cmpOpU cop)\n+%{\n+  predicate(n->in(2)->in(2)->is_Con() && n->in(2)->in(2)->get_long() == 0);\n+  match(Set dst (CMoveL (Binary cop cr) (Binary src dst)));\n+\n+  ins_cost(100); \/\/ XXX\n+  format %{ \"setbn$cop $dst\\t# unsigned, long\" %}\n+  ins_encode %{\n+    Assembler::Condition cond = (Assembler::Condition)($cop$$cmpcode);\n+    __ setb(MacroAssembler::negate_condition(cond), $dst$$Register);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n@@ -7238,0 +7356,14 @@\n+instruct cmovL_imm_01UCF(rRegL dst, immI_1 src, rFlagsRegUCF cr, cmpOpUCF cop)\n+%{\n+  predicate(n->in(2)->in(2)->is_Con() && n->in(2)->in(2)->get_long() == 0);\n+  match(Set dst (CMoveL (Binary cop cr) (Binary src dst)));\n+\n+  ins_cost(100); \/\/ XXX\n+  format %{ \"setbn$cop $dst\\t# unsigned, long\" %}\n+  ins_encode %{\n+    Assembler::Condition cond = (Assembler::Condition)($cop$$cmpcode);\n+    __ setb(MacroAssembler::negate_condition(cond), $dst$$Register);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n@@ -8978,0 +9110,1 @@\n+  predicate(!VM_Version::supports_bmi2());\n@@ -8991,0 +9124,1 @@\n+  predicate(!VM_Version::supports_bmi2());\n@@ -9001,0 +9135,24 @@\n+instruct salI_rReg_rReg(rRegI dst, rRegI src, rRegI shift)\n+%{\n+  predicate(VM_Version::supports_bmi2());\n+  match(Set dst (LShiftI src shift));\n+\n+  format %{ \"shlxl   $dst, $src, $shift\" %}\n+  ins_encode %{\n+    __ shlxl($dst$$Register, $src$$Register, $shift$$Register);\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n+instruct salI_mem_rReg(rRegI dst, memory src, rRegI shift)\n+%{\n+  predicate(VM_Version::supports_bmi2());\n+  match(Set dst (LShiftI (LoadI src) shift));\n+  ins_cost(175);\n+  format %{ \"shlxl   $dst, $src, $shift\" %}\n+  ins_encode %{\n+    __ shlxl($dst$$Register, $src$$Address, $shift$$Register);\n+  %}\n+  ins_pipe(ialu_reg_mem);\n+%}\n+\n@@ -9056,0 +9214,1 @@\n+  predicate(!VM_Version::supports_bmi2());\n@@ -9068,0 +9227,1 @@\n+  predicate(!VM_Version::supports_bmi2());\n@@ -9078,0 +9238,24 @@\n+instruct sarI_rReg_rReg(rRegI dst, rRegI src, rRegI shift)\n+%{\n+  predicate(VM_Version::supports_bmi2());\n+  match(Set dst (RShiftI src shift));\n+\n+  format %{ \"sarxl   $dst, $src, $shift\" %}\n+  ins_encode %{\n+    __ sarxl($dst$$Register, $src$$Register, $shift$$Register);\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n+instruct sarI_mem_rReg(rRegI dst, memory src, rRegI shift)\n+%{\n+  predicate(VM_Version::supports_bmi2());\n+  match(Set dst (RShiftI (LoadI src) shift));\n+  ins_cost(175);\n+  format %{ \"sarxl   $dst, $src, $shift\" %}\n+  ins_encode %{\n+    __ sarxl($dst$$Register, $src$$Address, $shift$$Register);\n+  %}\n+  ins_pipe(ialu_reg_mem);\n+%}\n+\n@@ -9133,0 +9317,1 @@\n+  predicate(!VM_Version::supports_bmi2());\n@@ -9146,0 +9331,1 @@\n+  predicate(!VM_Version::supports_bmi2());\n@@ -9156,0 +9342,24 @@\n+instruct shrI_rReg_rReg(rRegI dst, rRegI src, rRegI shift)\n+%{\n+  predicate(VM_Version::supports_bmi2());\n+  match(Set dst (URShiftI src shift));\n+\n+  format %{ \"shrxl   $dst, $src, $shift\" %}\n+  ins_encode %{\n+    __ shrxl($dst$$Register, $src$$Register, $shift$$Register);\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n+instruct shrI_mem_rReg(rRegI dst, memory src, rRegI shift)\n+%{\n+  predicate(VM_Version::supports_bmi2());\n+  match(Set dst (URShiftI (LoadI src) shift));\n+  ins_cost(175);\n+  format %{ \"shrxl   $dst, $src, $shift\" %}\n+  ins_encode %{\n+    __ shrxl($dst$$Register, $src$$Address, $shift$$Register);\n+  %}\n+  ins_pipe(ialu_reg_mem);\n+%}\n+\n@@ -9212,0 +9422,1 @@\n+  predicate(!VM_Version::supports_bmi2());\n@@ -9225,0 +9436,1 @@\n+  predicate(!VM_Version::supports_bmi2());\n@@ -9235,0 +9447,24 @@\n+instruct salL_rReg_rReg(rRegL dst, rRegL src, rRegI shift)\n+%{\n+  predicate(VM_Version::supports_bmi2());\n+  match(Set dst (LShiftL src shift));\n+\n+  format %{ \"shlxq   $dst, $src, $shift\" %}\n+  ins_encode %{\n+    __ shlxq($dst$$Register, $src$$Register, $shift$$Register);\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n+instruct salL_mem_rReg(rRegL dst, memory src, rRegI shift)\n+%{\n+  predicate(VM_Version::supports_bmi2());\n+  match(Set dst (LShiftL (LoadL src) shift));\n+  ins_cost(175);\n+  format %{ \"shlxq   $dst, $src, $shift\" %}\n+  ins_encode %{\n+    __ shlxq($dst$$Register, $src$$Address, $shift$$Register);\n+  %}\n+  ins_pipe(ialu_reg_mem);\n+%}\n+\n@@ -9262,1 +9498,1 @@\n-instruct sarL_rReg_imm(rRegL dst, immI8 shift, rFlagsReg cr)\n+instruct sarL_rReg_imm(rRegL dst, immI shift, rFlagsReg cr)\n@@ -9275,1 +9511,1 @@\n-instruct sarL_mem_imm(memory dst, immI8 shift, rFlagsReg cr)\n+instruct sarL_mem_imm(memory dst, immI shift, rFlagsReg cr)\n@@ -9290,0 +9526,1 @@\n+  predicate(!VM_Version::supports_bmi2());\n@@ -9303,0 +9540,1 @@\n+  predicate(!VM_Version::supports_bmi2());\n@@ -9313,0 +9551,24 @@\n+instruct sarL_rReg_rReg(rRegL dst, rRegL src, rRegI shift)\n+%{\n+  predicate(VM_Version::supports_bmi2());\n+  match(Set dst (RShiftL src shift));\n+\n+  format %{ \"sarxq   $dst, $src, $shift\" %}\n+  ins_encode %{\n+    __ sarxq($dst$$Register, $src$$Register, $shift$$Register);\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n+instruct sarL_mem_rReg(rRegL dst, memory src, rRegI shift)\n+%{\n+  predicate(VM_Version::supports_bmi2());\n+  match(Set dst (RShiftL (LoadL src) shift));\n+  ins_cost(175);\n+  format %{ \"sarxq   $dst, $src, $shift\" %}\n+  ins_encode %{\n+    __ sarxq($dst$$Register, $src$$Address, $shift$$Register);\n+  %}\n+  ins_pipe(ialu_reg_mem);\n+%}\n+\n@@ -9368,0 +9630,1 @@\n+  predicate(!VM_Version::supports_bmi2());\n@@ -9381,0 +9644,1 @@\n+  predicate(!VM_Version::supports_bmi2());\n@@ -9391,0 +9655,24 @@\n+instruct shrL_rReg_rReg(rRegL dst, rRegL src, rRegI shift)\n+%{\n+  predicate(VM_Version::supports_bmi2());\n+  match(Set dst (URShiftL src shift));\n+\n+  format %{ \"shrxq   $dst, $src, $shift\" %}\n+  ins_encode %{\n+    __ shrxq($dst$$Register, $src$$Register, $shift$$Register);\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n+instruct shrL_mem_rReg(rRegL dst, memory src, rRegI shift)\n+%{\n+  predicate(VM_Version::supports_bmi2());\n+  match(Set dst (URShiftL (LoadL src) shift));\n+  ins_cost(175);\n+  format %{ \"shrxq   $dst, $src, $shift\" %}\n+  ins_encode %{\n+    __ shrxq($dst$$Register, $src$$Address, $shift$$Register);\n+  %}\n+  ins_pipe(ialu_reg_mem);\n+%}\n+\n@@ -9420,1 +9708,1 @@\n-instruct rolI_imm(rRegI dst, immI8 shift, rFlagsReg cr)\n+instruct rolI_immI8_legacy(rRegI dst, immI8 shift, rFlagsReg cr)\n@@ -9422,1 +9710,1 @@\n-  predicate(n->bottom_type()->basic_type() == T_INT);\n+  predicate(!VM_Version::supports_bmi2() && n->bottom_type()->basic_type() == T_INT);\n@@ -9432,0 +9720,25 @@\n+instruct rolI_immI8(rRegI dst, rRegI src, immI8 shift)\n+%{\n+  predicate(VM_Version::supports_bmi2() && n->bottom_type()->basic_type() == T_INT);\n+  match(Set dst (RotateLeft src shift));\n+  format %{ \"rolxl   $dst, $src, $shift\" %}\n+  ins_encode %{\n+    int shift = 32 - ($shift$$constant & 31);\n+    __ rorxl($dst$$Register, $src$$Register, shift);\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n+instruct rolI_mem_immI8(rRegI dst, memory src, immI8 shift)\n+%{\n+  predicate(VM_Version::supports_bmi2() && n->bottom_type()->basic_type() == T_INT);\n+  match(Set dst (RotateLeft (LoadI src) shift));\n+  ins_cost(175);\n+  format %{ \"rolxl   $dst, $src, $shift\" %}\n+  ins_encode %{\n+    int shift = 32 - ($shift$$constant & 31);\n+    __ rorxl($dst$$Register, $src$$Address, shift);\n+  %}\n+  ins_pipe(ialu_reg_mem);\n+%}\n+\n@@ -9459,1 +9772,1 @@\n-instruct rorI_immI8(rRegI dst, immI8 shift)\n+instruct rorI_immI8(rRegI dst, rRegI src, immI8 shift)\n@@ -9462,2 +9775,2 @@\n-  match(Set dst (RotateRight dst shift));\n-  format %{ \"rorxd     $dst, $shift\" %}\n+  match(Set dst (RotateRight src shift));\n+  format %{ \"rorxl   $dst, $src, $shift\" %}\n@@ -9465,1 +9778,1 @@\n-    __ rorxd($dst$$Register, $dst$$Register, $shift$$constant);\n+    __ rorxl($dst$$Register, $src$$Register, $shift$$constant);\n@@ -9470,0 +9783,12 @@\n+instruct rorI_mem_immI8(rRegI dst, memory src, immI8 shift)\n+%{\n+  predicate(VM_Version::supports_bmi2() && n->bottom_type()->basic_type() == T_INT);\n+  match(Set dst (RotateRight (LoadI src) shift));\n+  ins_cost(175);\n+  format %{ \"rorxl   $dst, $src, $shift\" %}\n+  ins_encode %{\n+    __ rorxl($dst$$Register, $src$$Address, $shift$$constant);\n+  %}\n+  ins_pipe(ialu_reg_mem);\n+%}\n+\n@@ -9483,1 +9808,0 @@\n-\n@@ -9485,1 +9809,1 @@\n-instruct rolL_immI8(rRegL dst, immI8 shift, rFlagsReg cr)\n+instruct rolL_immI8_legacy(rRegL dst, immI8 shift, rFlagsReg cr)\n@@ -9487,1 +9811,1 @@\n-  predicate(n->bottom_type()->basic_type() == T_LONG);\n+  predicate(!VM_Version::supports_bmi2() && n->bottom_type()->basic_type() == T_LONG);\n@@ -9497,0 +9821,25 @@\n+instruct rolL_immI8(rRegL dst, rRegL src, immI8 shift)\n+%{\n+  predicate(VM_Version::supports_bmi2() && n->bottom_type()->basic_type() == T_LONG);\n+  match(Set dst (RotateLeft src shift));\n+  format %{ \"rolxq   $dst, $src, $shift\" %}\n+  ins_encode %{\n+    int shift = 64 - ($shift$$constant & 63);\n+    __ rorxq($dst$$Register, $src$$Register, shift);\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n+instruct rolL_mem_immI8(rRegL dst, memory src, immI8 shift)\n+%{\n+  predicate(VM_Version::supports_bmi2() && n->bottom_type()->basic_type() == T_LONG);\n+  match(Set dst (RotateLeft (LoadL src) shift));\n+  ins_cost(175);\n+  format %{ \"rolxq   $dst, $src, $shift\" %}\n+  ins_encode %{\n+    int shift = 64 - ($shift$$constant & 63);\n+    __ rorxq($dst$$Register, $src$$Address, shift);\n+  %}\n+  ins_pipe(ialu_reg_mem);\n+%}\n+\n@@ -9510,1 +9859,0 @@\n-\n@@ -9524,1 +9872,0 @@\n-\n@@ -9526,1 +9873,1 @@\n-instruct rorL_immI8(rRegL dst, immI8 shift)\n+instruct rorL_immI8(rRegL dst, rRegL src, immI8 shift)\n@@ -9529,2 +9876,2 @@\n-  match(Set dst (RotateRight dst shift));\n-  format %{ \"rorxq    $dst, $shift\" %}\n+  match(Set dst (RotateRight src shift));\n+  format %{ \"rorxq   $dst, $src, $shift\" %}\n@@ -9532,1 +9879,1 @@\n-    __ rorxq($dst$$Register, $dst$$Register, $shift$$constant);\n+    __ rorxq($dst$$Register, $src$$Register, $shift$$constant);\n@@ -9537,0 +9884,12 @@\n+instruct rorL_mem_immI8(rRegL dst, memory src, immI8 shift)\n+%{\n+  predicate(VM_Version::supports_bmi2() && n->bottom_type()->basic_type() == T_LONG);\n+  match(Set dst (RotateRight (LoadL src) shift));\n+  ins_cost(175);\n+  format %{ \"rorxq   $dst, $src, $shift\" %}\n+  ins_encode %{\n+    __ rorxq($dst$$Register, $src$$Address, $shift$$constant);\n+  %}\n+  ins_pipe(ialu_reg_mem);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":376,"deletions":17,"binary":false,"changes":393,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -128,0 +128,21 @@\n+\n+    @Benchmark\n+    public void shiftRight(Blackhole bh) {\n+        for (int i = 0; i < size; i++) {\n+            bh.consume(intsBig[i] >> intsSmall[i]);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void shiftURight(Blackhole bh) {\n+        for (int i = 0; i < size; i++) {\n+            bh.consume(intsBig[i] >>> intsSmall[i]);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void shiftLeft(Blackhole bh) {\n+        for (int i = 0; i < size; i++) {\n+            bh.consume(intsBig[i] << intsSmall[i]);\n+        }\n+    }\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/Integers.java","additions":22,"deletions":1,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -123,0 +123,21 @@\n+\n+    @Benchmark\n+    public void shiftRight(Blackhole bh) {\n+        for (int i = 0; i < size; i++) {\n+            bh.consume(longArrayBig[i] >> longArraySmall[i]);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void shiftURight(Blackhole bh) {\n+        for (int i = 0; i < size; i++) {\n+            bh.consume(longArrayBig[i] >>> longArraySmall[i]);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void shiftLeft(Blackhole bh) {\n+        for (int i = 0; i < size; i++) {\n+            bh.consume(longArrayBig[i] << longArraySmall[i]);\n+        }\n+    }\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/Longs.java","additions":22,"deletions":1,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-\/\/ Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,0 +42,2 @@\n+  static final int CONSHIFT = 20;\n+\n@@ -86,1 +88,20 @@\n-\n+  @Benchmark\n+  public void testRotateLeftConI() {\n+    for (int i = 0; i < TESTSIZE; i++)\n+      ires[i] = Integer.rotateLeft(iarr[i], CONSHIFT);\n+  }\n+  @Benchmark\n+  public void testRotateRightConI() {\n+    for (int i = 0; i < TESTSIZE; i++)\n+      ires[i] = Integer.rotateRight(iarr[i], CONSHIFT);\n+  }\n+  @Benchmark\n+  public void testRotateLeftConL() {\n+    for (int i = 0; i < TESTSIZE; i++)\n+      lres[i] = Long.rotateLeft(larr[i], CONSHIFT);\n+  }\n+  @Benchmark\n+  public void testRotateRightConL() {\n+    for (int i = 0; i < TESTSIZE; i++)\n+      lres[i] = Long.rotateRight(larr[i], CONSHIFT);\n+  }\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/RotateBenchmark.java","additions":23,"deletions":2,"binary":false,"changes":25,"status":"modified"}]}