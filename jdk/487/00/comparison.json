{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -560,31 +560,18 @@\n-        if (spMethod == null || types.isSameType(spMethod.getReturnType(), syms.objectType)) {\n-            \/\/ The return type of the polymorphic signature is polymorphic,\n-            \/\/ and is computed from the enclosing tree E, as follows:\n-            \/\/ if E is a cast, then use the target type of the cast expression\n-            \/\/ as a return type; if E is an expression statement, the return\n-            \/\/ type is 'void'; otherwise\n-            \/\/ the return type is simply 'Object'. A correctness check ensures\n-            \/\/ that env.next refers to the lexically enclosing environment in\n-            \/\/ which the polymorphic signature call environment is nested.\n-\n-            switch (env.next.tree.getTag()) {\n-                case TYPECAST:\n-                    JCTypeCast castTree = (JCTypeCast)env.next.tree;\n-                    restype = (TreeInfo.skipParens(castTree.expr) == env.tree) ?\n-                              castTree.clazz.type :\n-                              syms.objectType;\n-                    break;\n-                case EXEC:\n-                    JCTree.JCExpressionStatement execTree =\n-                            (JCTree.JCExpressionStatement)env.next.tree;\n-                    restype = (TreeInfo.skipParens(execTree.expr) == env.tree) ?\n-                              syms.voidType :\n-                              syms.objectType;\n-                    break;\n-                default:\n-                    restype = syms.objectType;\n-            }\n-        } else {\n-            \/\/ The return type of the polymorphic signature is fixed\n-            \/\/ (not polymorphic)\n-            restype = spMethod.getReturnType();\n+        Type spType = spMethod == null ? syms.objectType : spMethod.getReturnType();\n+\n+        switch (env.next.tree.getTag()) {\n+            case TYPECAST:\n+                JCTypeCast castTree = (JCTypeCast)env.next.tree;\n+                restype = (TreeInfo.skipParens(castTree.expr) == env.tree) ?\n+                          castTree.clazz.type :\n+                          spType;\n+                break;\n+            case EXEC:\n+                JCTree.JCExpressionStatement execTree =\n+                        (JCTree.JCExpressionStatement)env.next.tree;\n+                restype = (TreeInfo.skipParens(execTree.expr) == env.tree) ?\n+                          syms.voidType :\n+                          spType;\n+                break;\n+            default:\n+                restype = spType;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Infer.java","additions":19,"deletions":32,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -2745,1 +2745,1 @@\n-                spMethod.owner == sym.owner) {\n+                    spMethod.owner == sym.owner) {\n@@ -2750,0 +2750,12 @@\n+        Type spReturnType = spMethod.asType().getReturnType();\n+        if (types.isSameType(spReturnType, syms.objectType)) {\n+            \/\/ Polymorphic return, pass through mtype\n+        } else if (!types.isSameType(spReturnType, mtype.getReturnType())) {\n+            \/\/ Retain the sig poly method's return type, which differs from that of mtype\n+            \/\/ Will result in an incompatible return type error\n+            mtype = new MethodType(mtype.getParameterTypes(),\n+                    spReturnType,\n+                    mtype.getThrownTypes(),\n+                    syms.methodClass);\n+        }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Resolve.java","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -0,0 +1,66 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @summary test for VarHandle signature polymorphic methods\n+ * @run testng MethodReferenceTestVarHandle\n+ *\/\n+\n+import java.lang.invoke.*;\n+import java.util.*;\n+\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.assertEquals;\n+\n+@Test\n+public class MethodReferenceTestVarHandle {\n+\n+  interface Setter {\n+      void apply(int[] arr, int idx, int val);\n+  }\n+\n+  interface Getter {\n+      int apply(int[] arr, int idx);\n+  }\n+\n+  public void testSet() throws Throwable {\n+      VarHandle vh = MethodHandles.arrayElementVarHandle(int[].class);\n+\n+      Setter f = vh::set;\n+\n+      int[] data = {0};\n+      f.apply(data, 0, 42);\n+      assertEquals(42, data[0]);\n+  }\n+\n+  public void testGet() throws Throwable {\n+      VarHandle vh = MethodHandles.arrayElementVarHandle(int[].class);\n+\n+      Getter f = vh::get;\n+\n+      int[] data = {42};\n+      int v = f.apply(data, 0);\n+      assertEquals(42, v);\n+  }\n+}\n","filename":"test\/langtools\/tools\/javac\/lambda\/methodReferenceExecution\/MethodReferenceTestVarHandle.java","additions":66,"deletions":0,"binary":false,"changes":66,"status":"added"},{"patch":"@@ -0,0 +1,45 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @summary test for VarHandle signature polymorphic methods with wrong return type\n+ * @compile\/fail\/ref=MethodReferenceTestVarHandle_neg.out -XDrawDiagnostics MethodReferenceTestVarHandle_neg.java\n+ *\/\n+\n+import java.lang.invoke.*;\n+import java.util.*;\n+\n+public class MethodReferenceTestVarHandle_neg {\n+\n+  interface Setter {\n+      int apply(int[] arr, int idx, int val);\n+  }\n+\n+  public static void main(String[] args) {\n+      VarHandle vh = MethodHandles.arrayElementVarHandle(int[].class);\n+\n+      \/\/ Return type of Setter::apply does not match return type of VarHandle::set\n+      Setter f = vh::set;\n+  }\n+}\n","filename":"test\/langtools\/tools\/javac\/lambda\/methodReferenceExecution\/MethodReferenceTestVarHandle_neg.java","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -0,0 +1,2 @@\n+MethodReferenceTestVarHandle_neg.java:43:18: compiler.err.prob.found.req: (compiler.misc.incompatible.ret.type.in.mref: (compiler.misc.inconvertible.types: void, int))\n+1 error\n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/javac\/lambda\/methodReferenceExecution\/MethodReferenceTestVarHandle_neg.out","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"}]}