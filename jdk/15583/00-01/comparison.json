{"files":[{"patch":"@@ -3046,0 +3046,29 @@\n+\n+\/\/ Simulate the library search algorithm of dlopen() (in os::dll_load)\n+int os::Aix::stat64x_via_LIBPATH(const char* path, struct stat64x* stat) {\n+  if (path[0] == '\/' ||\n+      (path[0] == '.' && (path[1] == '\/' ||\n+                          (path[1] == '.' && path[2] == '\/')))) {\n+    return stat64x(path, stat);\n+  }\n+\n+  const char* env = getenv(\"LIBPATH\");\n+  if (env == nullptr || *env == 0)\n+    return -1;\n+\n+  int ret = -1;\n+  size_t libpathlen = strlen(env);\n+  char* libpath = NEW_C_HEAP_ARRAY(char, libpathlen + 1, mtServiceability);\n+  char* combined = NEW_C_HEAP_ARRAY(char, libpathlen + strlen(path) +1, mtServiceability);\n+  char *saveptr, *token;\n+  strcpy(libpath, env);\n+  for( token = strtok_r(libpath, \":\", &saveptr); token != nullptr; token = strtok_r(nullptr, \":\", &saveptr) ) {\n+    sprintf(combined, \"%s\/%s\", token, path);\n+    if (0 == (ret = stat64x(combined, stat)))\n+      break;\n+  }\n+\n+  FREE_C_HEAP_ARRAY(char*, combined);\n+  FREE_C_HEAP_ARRAY(char*, libpath);\n+  return ret;\n+}\n","filename":"src\/hotspot\/os\/aix\/os_aix.cpp","additions":29,"deletions":0,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -177,0 +177,3 @@\n+\n+  \/\/ Simulate the library search algorithm of dlopen() (in os::dll_load)\n+  static int stat64x_via_LIBPATH(const char* path, struct stat64x* stat);\n","filename":"src\/hotspot\/os\/aix\/os_aix.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -298,7 +298,7 @@\n-static int stat64x_LIBPATH(const char* path, struct stat64x* stat)\n-{\n-  \/\/ Simulate the library search algorithm of dlopen() (in os::dll_load)\n-  if (path[0] == '\/' ||\n-      (path[0] == '.' && (path[1] == '\/' ||\n-                          (path[1] == '.' && path[2] == '\/')))) {\n-    return stat64x(path, stat);\n+\/\/ save the inode and device of the library's file as a signature. This signature can be used\n+\/\/ in the same way as the library handle as a signature on other platforms.\n+static void save_library_signature(JvmtiAgent* agent, const char* name) {\n+  struct stat64x libstat;\n+  if (0 == os::Aix::stat64x_via_LIBPATH(name, &libstat)) {\n+    agent->set_inode(libstat.st_ino);\n+    agent->set_device(libstat.st_dev);\n@@ -306,15 +306,2 @@\n-\n-  const char* env = getenv(\"LIBPATH\");\n-  if (env == nullptr || *env == 0)\n-    return -1;\n-\n-  int ret = -1;\n-  size_t libpathlen = strlen(env);\n-  char* libpath = NEW_C_HEAP_ARRAY(char, libpathlen + 1, mtServiceability);\n-  char* combined = NEW_C_HEAP_ARRAY(char, libpathlen + strlen(path) +1, mtServiceability);\n-  char *saveptr, *token;\n-  strcpy(libpath, env);\n-  for( token = strtok_r(libpath, \":\", &saveptr); token != nullptr; token = strtok_r(nullptr, \":\", &saveptr) ) {\n-    sprintf(combined, \"%s\/%s\", token, path);\n-    if (0 == (ret = stat64x(combined, stat)))\n-      break;\n+  else {\n+    assert(false, \"stat64x failed\");\n@@ -322,4 +309,0 @@\n-\n-  FREE_C_HEAP_ARRAY(char*, combined);\n-  FREE_C_HEAP_ARRAY(char*, libpath);\n-  return ret;\n@@ -338,12 +321,1 @@\n-  #ifdef AIX\n-  if (library != nullptr) {\n-    struct stat64x libstat;\n-    if (0 == stat64x_LIBPATH(agent->name(), &libstat)) {\n-      agent->set_inode(libstat.st_ino);\n-      agent->set_device(libstat.st_dev);\n-    }\n-    else {\n-      assert(false, \"stat64x failed 1\");\n-    }\n-  }\n-  #endif\n+  AIX_ONLY(if (library != nullptr) save_library_signature(agent, agent->name());)\n@@ -362,12 +334,1 @@\n-    #ifdef AIX\n-    if (library != nullptr) {\n-      struct stat64x libstat;\n-      if (0 == stat64x_LIBPATH(&buffer[0], &libstat)) {\n-        agent->set_inode(libstat.st_ino);\n-        agent->set_device(libstat.st_dev);\n-      }\n-      else {\n-        assert(false, \"stat64x failed 3\");\n-      }\n-    }\n-    #endif\n+    AIX_ONLY(if (library != nullptr) save_library_signature(agent, &buffer[0]);)\n@@ -379,10 +340,1 @@\n-      #ifdef AIX\n-      struct stat64x libstat;\n-      if (0 == stat64x_LIBPATH(&buffer[0], &libstat)) {\n-        agent->set_inode(libstat.st_ino);\n-        agent->set_device(libstat.st_dev);\n-      }\n-      else {\n-        assert(false, \"stat64x failed-2\");\n-      }\n-      #endif\n+      AIX_ONLY(save_library_signature(agent, &buffer[0]);)\n","filename":"src\/hotspot\/share\/prims\/jvmtiAgent.cpp","additions":12,"deletions":60,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -251,1 +251,1 @@\n-    if (!agent->is_static_lib() && device && inode &&\n+    if (!agent->is_static_lib() && device != 0 && inode != 0 &&\n","filename":"src\/hotspot\/share\/prims\/jvmtiAgentList.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -126,9 +126,9 @@\n-            \/\/ start loadJvmtiAgent1 via the command line, then dynamically load loadJvmtiAgent1\n-            test().withOpts(\"-agentpath:\" + jvmtiAgentPath1)\n-                    .whenRunning(loadJvmtiAgent1)\n-                    .stderrShouldNotContain(JVMTI_AGENT_WARNING);\n-\n-            \/\/ dynamically load loadJvmtiAgent1 twice, should be one warning\n-            test().whenRunning(loadJvmtiAgent1)\n-                    .whenRunning(loadJvmtiAgent1)\n-                    .stderrShouldContain(JVMTI_AGENT_WARNING, 1);\n+        \/\/ start loadJvmtiAgent1 via the command line, then dynamically load loadJvmtiAgent1\n+        test().withOpts(\"-agentpath:\" + jvmtiAgentPath1)\n+                .whenRunning(loadJvmtiAgent1)\n+                .stderrShouldNotContain(JVMTI_AGENT_WARNING);\n+\n+        \/\/ dynamically load loadJvmtiAgent1 twice, should be one warning\n+        test().whenRunning(loadJvmtiAgent1)\n+                .whenRunning(loadJvmtiAgent1)\n+                .stderrShouldContain(JVMTI_AGENT_WARNING, 1);\n","filename":"test\/jdk\/com\/sun\/tools\/attach\/warnings\/DynamicLoadWarningTest.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"}]}