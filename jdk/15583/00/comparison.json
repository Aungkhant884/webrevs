{"files":[{"patch":"@@ -77,0 +77,4 @@\n+#ifdef AIX\n+  _inode(0),\n+  _device(0),\n+#endif\n@@ -121,0 +125,18 @@\n+#ifdef AIX\n+void JvmtiAgent::set_inode(long inode) {\n+  _inode = inode;\n+}\n+\n+void JvmtiAgent::set_device(long device) {\n+  _device = device;\n+}\n+\n+long JvmtiAgent::inode() const {\n+  return _inode;\n+}\n+\n+long JvmtiAgent::device() const {\n+  return _device;\n+}\n+#endif\n+\n@@ -275,0 +297,32 @@\n+#ifdef AIX\n+static int stat64x_LIBPATH(const char* path, struct stat64x* stat)\n+{\n+  \/\/ Simulate the library search algorithm of dlopen() (in os::dll_load)\n+  if (path[0] == '\/' ||\n+      (path[0] == '.' && (path[1] == '\/' ||\n+                          (path[1] == '.' && path[2] == '\/')))) {\n+    return stat64x(path, stat);\n+  }\n+\n+  const char* env = getenv(\"LIBPATH\");\n+  if (env == nullptr || *env == 0)\n+    return -1;\n+\n+  int ret = -1;\n+  size_t libpathlen = strlen(env);\n+  char* libpath = NEW_C_HEAP_ARRAY(char, libpathlen + 1, mtServiceability);\n+  char* combined = NEW_C_HEAP_ARRAY(char, libpathlen + strlen(path) +1, mtServiceability);\n+  char *saveptr, *token;\n+  strcpy(libpath, env);\n+  for( token = strtok_r(libpath, \":\", &saveptr); token != nullptr; token = strtok_r(nullptr, \":\", &saveptr) ) {\n+    sprintf(combined, \"%s\/%s\", token, path);\n+    if (0 == (ret = stat64x(combined, stat)))\n+      break;\n+  }\n+\n+  FREE_C_HEAP_ARRAY(char*, combined);\n+  FREE_C_HEAP_ARRAY(char*, libpath);\n+  return ret;\n+}\n+#endif\n+\n@@ -284,0 +338,12 @@\n+  #ifdef AIX\n+  if (library != nullptr) {\n+    struct stat64x libstat;\n+    if (0 == stat64x_LIBPATH(agent->name(), &libstat)) {\n+      agent->set_inode(libstat.st_ino);\n+      agent->set_device(libstat.st_dev);\n+    }\n+    else {\n+      assert(false, \"stat64x failed 1\");\n+    }\n+  }\n+  #endif\n@@ -296,0 +362,12 @@\n+    #ifdef AIX\n+    if (library != nullptr) {\n+      struct stat64x libstat;\n+      if (0 == stat64x_LIBPATH(&buffer[0], &libstat)) {\n+        agent->set_inode(libstat.st_ino);\n+        agent->set_device(libstat.st_dev);\n+      }\n+      else {\n+        assert(false, \"stat64x failed 3\");\n+      }\n+    }\n+    #endif\n@@ -301,0 +379,10 @@\n+      #ifdef AIX\n+      struct stat64x libstat;\n+      if (0 == stat64x_LIBPATH(&buffer[0], &libstat)) {\n+        agent->set_inode(libstat.st_ino);\n+        agent->set_device(libstat.st_dev);\n+      }\n+      else {\n+        assert(false, \"stat64x failed-2\");\n+      }\n+      #endif\n@@ -518,0 +606,3 @@\n+  #ifdef AIX\n+    previously_loaded = JvmtiAgentList::is_dynamic_lib_loaded(agent->device(), agent->inode());\n+  #else\n@@ -519,0 +610,1 @@\n+  #endif\n","filename":"src\/hotspot\/share\/prims\/jvmtiAgent.cpp","additions":92,"deletions":0,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -46,0 +46,4 @@\n+#ifdef AIX\n+  long _inode;\n+  long _device;\n+#endif\n@@ -83,0 +87,6 @@\n+#ifdef AIX\n+  void set_inode(long inode);\n+  void set_device(long device);\n+  long inode() const;\n+  long device() const;\n+#endif\n","filename":"src\/hotspot\/share\/prims\/jvmtiAgent.hpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -246,0 +246,13 @@\n+#ifdef AIX\n+bool JvmtiAgentList::is_dynamic_lib_loaded(long device, long inode) {\n+  JvmtiAgentList::Iterator it = JvmtiAgentList::agents();\n+  while (it.has_next()) {\n+    JvmtiAgent* const agent = it.next();\n+    if (!agent->is_static_lib() && device && inode &&\n+        agent->device() == device && agent->inode() == inode) {\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+#endif\n","filename":"src\/hotspot\/share\/prims\/jvmtiAgentList.cpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -81,0 +81,3 @@\n+#ifdef AIX\n+  static bool is_dynamic_lib_loaded(long device, long inode);\n+#endif\n","filename":"src\/hotspot\/share\/prims\/jvmtiAgentList.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -126,2 +126,0 @@\n-        \/\/ test behavior on platforms that can detect if an agent library was previously loaded\n-        if (!Platform.isAix()) {\n@@ -137,1 +135,0 @@\n-        }\n","filename":"test\/jdk\/com\/sun\/tools\/attach\/warnings\/DynamicLoadWarningTest.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"}]}