{"files":[{"patch":"@@ -32,0 +32,1 @@\n+import java.nio.Buffer;\n@@ -65,1 +66,1 @@\n- *     <li>{@linkplain MemorySegment#ofByteBuffer(ByteBuffer) buffer segments}, wrapping an existing {@link ByteBuffer} instance;\n+ *     <li>{@linkplain MemorySegment#ofBuffer(Buffer) buffer segments}, wrapping an existing {@link Buffer} instance;\n@@ -67,1 +68,1 @@\n- * wrapped byte buffer instance. For instance, a buffer memory segment obtained from a byte buffer created with the\n+ * wrapped buffer instance. For instance, a buffer memory segment obtained from a byte buffer created with the\n@@ -87,2 +88,5 @@\n- * Heap and buffer segments are always associated with a <em>global<\/em>, shared memory session. This session cannot be closed,\n- * and segments associated with it can be considered as <em>always alive<\/em>.\n+ * Heap segments are always associated with the {@linkplain MemorySession#global() global} memory session.\n+ * This session cannot be closed, and segments associated with it can be considered as <em>always alive<\/em>.\n+ * Buffer segments are typically associated with the global memory session, with one exception: buffer segments created\n+ * from byte buffer instances obtained calling the {@link #asByteBuffer()} method on a memory segment {@code S}\n+ * are associated with the same memory session as {@code S}.\n@@ -347,1 +351,1 @@\n-     * derived from a {@linkplain ByteBuffer#allocateDirect(int) direct byte buffer} using the {@link #ofByteBuffer(ByteBuffer)} factory,\n+     * derived from a {@linkplain ByteBuffer#allocateDirect(int) direct byte buffer} using the {@link #ofBuffer(Buffer)} factory,\n@@ -356,1 +360,1 @@\n-     * derived from a {@link java.nio.MappedByteBuffer} using the {@link #ofByteBuffer(ByteBuffer)} factory.\n+     * derived from a {@link java.nio.MappedByteBuffer} using the {@link #ofBuffer(Buffer)} factory.\n@@ -710,3 +714,2 @@\n-     * Creates a buffer memory segment that models the memory associated with the given byte\n-     * buffer. The segment starts relative to the buffer's position (inclusive)\n-     * and ends relative to the buffer's limit (exclusive).\n+     * Creates a buffer memory segment that models the memory associated with the given {@link Buffer} instance.\n+     * The segment starts relative to the buffer's position (inclusive) and ends relative to the buffer's limit (exclusive).\n@@ -721,1 +724,1 @@\n-     * @param bb the byte buffer backing the buffer memory segment.\n+     * @param buffer the buffer instance backing the buffer memory segment.\n@@ -724,2 +727,2 @@\n-    static MemorySegment ofByteBuffer(ByteBuffer bb) {\n-        return AbstractMemorySegmentImpl.ofBuffer(bb);\n+    static MemorySegment ofBuffer(Buffer buffer) {\n+        return AbstractMemorySegmentImpl.ofBuffer(buffer);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemorySegment.java","additions":15,"deletions":12,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -807,2 +807,2 @@\n-                public Object getBufferBase(ByteBuffer bb) {\n-                    return bb.base();\n+                public Object getBufferBase(Buffer buffer) {\n+                    return buffer.base();\n@@ -812,2 +812,2 @@\n-                public long getBufferAddress(ByteBuffer bb) {\n-                    return bb.address;\n+                public long getBufferAddress(Buffer buffer) {\n+                    return buffer.address;\n@@ -817,3 +817,3 @@\n-                public UnmapperProxy unmapper(ByteBuffer bb) {\n-                    if (bb instanceof MappedByteBuffer) {\n-                        return ((MappedByteBuffer)bb).unmapper();\n+                public UnmapperProxy unmapper(Buffer buffer) {\n+                    if (buffer instanceof MappedByteBuffer mbb) {\n+                        return mbb.unmapper();\n","filename":"src\/java.base\/share\/classes\/java\/nio\/Buffer.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -71,1 +71,1 @@\n-    Object getBufferBase(ByteBuffer bb);\n+    Object getBufferBase(Buffer bb);\n@@ -76,1 +76,1 @@\n-    long getBufferAddress(ByteBuffer bb);\n+    long getBufferAddress(Buffer buffer);\n@@ -81,1 +81,1 @@\n-    UnmapperProxy unmapper(ByteBuffer bb);\n+    UnmapperProxy unmapper(Buffer buffer);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaNioAccess.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import java.nio.Buffer;\n@@ -36,0 +37,6 @@\n+import java.nio.CharBuffer;\n+import java.nio.DoubleBuffer;\n+import java.nio.FloatBuffer;\n+import java.nio.IntBuffer;\n+import java.nio.LongBuffer;\n+import java.nio.ShortBuffer;\n@@ -520,1 +527,1 @@\n-    public static AbstractMemorySegmentImpl ofBuffer(ByteBuffer bb) {\n+    public static AbstractMemorySegmentImpl ofBuffer(Buffer bb) {\n@@ -543,0 +550,1 @@\n+        int scaleFactor = getScaleFactor(bb);\n@@ -544,1 +552,17 @@\n-            return new HeapMemorySegmentImpl.OfByte(bbAddress + pos, (byte[])base, size, modes);\n+            if (base instanceof byte[]) {\n+                return new HeapMemorySegmentImpl.OfByte(bbAddress + (pos << scaleFactor), base, size << scaleFactor, modes);\n+            } else if (base instanceof short[]) {\n+                return new HeapMemorySegmentImpl.OfShort(bbAddress + (pos << scaleFactor), base, size << scaleFactor, modes);\n+            } else if (base instanceof char[]) {\n+                return new HeapMemorySegmentImpl.OfChar(bbAddress + (pos << scaleFactor), base, size << scaleFactor, modes);\n+            } else if (base instanceof int[]) {\n+                return new HeapMemorySegmentImpl.OfInt(bbAddress + (pos << scaleFactor), base, size << scaleFactor, modes);\n+            } else if (base instanceof float[]) {\n+                return new HeapMemorySegmentImpl.OfFloat(bbAddress + (pos << scaleFactor), base, size << scaleFactor, modes);\n+            } else if (base instanceof long[]) {\n+                return new HeapMemorySegmentImpl.OfLong(bbAddress + (pos << scaleFactor), base, size << scaleFactor, modes);\n+            } else if (base instanceof double[]) {\n+                return new HeapMemorySegmentImpl.OfDouble(bbAddress + (pos << scaleFactor), base, size << scaleFactor, modes);\n+            } else {\n+                throw new AssertionError(\"Cannot get here\");\n+            }\n@@ -546,1 +570,1 @@\n-            return new NativeMemorySegmentImpl(bbAddress + pos, size, modes, bufferSession);\n+            return new NativeMemorySegmentImpl(bbAddress + (pos << scaleFactor), size << scaleFactor, modes, bufferSession);\n@@ -548,0 +572,1 @@\n+            \/\/ we can ignore scale factor here, a mapped buffer is always a byte buffer, so scaleFactor == 0.\n@@ -551,0 +576,20 @@\n+\n+    private static int getScaleFactor(Buffer buffer) {\n+        if (buffer instanceof ByteBuffer) {\n+            return 0;\n+        } else if (buffer instanceof CharBuffer) {\n+            return 1;\n+        } else if (buffer instanceof ShortBuffer) {\n+            return 1;\n+        } else if (buffer instanceof IntBuffer) {\n+            return 2;\n+        } else if (buffer instanceof FloatBuffer) {\n+            return 2;\n+        } else if (buffer instanceof LongBuffer) {\n+            return 3;\n+        } else if (buffer instanceof DoubleBuffer) {\n+            return 3;\n+        } else {\n+            throw new AssertionError(\"Cannot get here\");\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":48,"deletions":3,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -169,0 +169,1 @@\n+            MemorySegment segmentBufferView = MemorySegment.ofBuffer(z);\n@@ -172,0 +173,1 @@\n+                Object handleViewValue = handleExtractor.apply(segmentBufferView, j - i);\n@@ -175,0 +177,1 @@\n+                    assertEquals(((Number)handleViewValue).longValue(), j);\n@@ -178,0 +181,1 @@\n+                    assertEquals((long)(char)handleViewValue, j);\n@@ -213,1 +217,1 @@\n-                MemorySegment segment = MemorySegment.ofByteBuffer(mbb);\n+                MemorySegment segment = MemorySegment.ofBuffer(mbb);\n@@ -222,1 +226,1 @@\n-                MemorySegment segment = MemorySegment.ofByteBuffer(mbb);\n+                MemorySegment segment = MemorySegment.ofBuffer(mbb);\n@@ -453,1 +457,1 @@\n-        MemorySegment base = MemorySegment.ofByteBuffer(ByteBuffer.wrap(new byte[capacity]));\n+        MemorySegment base = MemorySegment.ofBuffer(ByteBuffer.wrap(new byte[capacity]));\n@@ -465,1 +469,1 @@\n-        MemorySegment second = MemorySegment.ofByteBuffer(segment.asByteBuffer());\n+        MemorySegment second = MemorySegment.ofBuffer(segment.asByteBuffer());\n@@ -474,1 +478,1 @@\n-            MemorySegment second = MemorySegment.ofByteBuffer(segment.asByteBuffer());\n+            MemorySegment second = MemorySegment.ofBuffer(segment.asByteBuffer());\n@@ -610,1 +614,1 @@\n-            MemorySegment segment = MemorySegment.ofByteBuffer(rwBuffer);\n+            MemorySegment segment = MemorySegment.ofBuffer(rwBuffer);\n@@ -616,1 +620,1 @@\n-            MemorySegment segment = MemorySegment.ofByteBuffer(roBuffer);\n+            MemorySegment segment = MemorySegment.ofBuffer(roBuffer);\n@@ -624,1 +628,1 @@\n-        MemorySegment segment = MemorySegment.ofByteBuffer(buffer);\n+        MemorySegment segment = MemorySegment.ofBuffer(buffer);\n@@ -645,1 +649,1 @@\n-        MemorySegment segment = MemorySegment.ofByteBuffer(bb);\n+        MemorySegment segment = MemorySegment.ofBuffer(bb);\n@@ -651,1 +655,1 @@\n-        segment = MemorySegment.ofByteBuffer(segment.asByteBuffer());\n+        segment = MemorySegment.ofBuffer(segment.asByteBuffer());\n@@ -660,1 +664,1 @@\n-        MemorySegment segment = MemorySegment.ofByteBuffer(bb);\n+        MemorySegment segment = MemorySegment.ofBuffer(bb);\n@@ -672,1 +676,1 @@\n-            MemorySegment msRoundTrip = MemorySegment.ofByteBuffer(msNoAccess.asByteBuffer());\n+            MemorySegment msRoundTrip = MemorySegment.ofBuffer(msNoAccess.asByteBuffer());\n@@ -680,1 +684,1 @@\n-        MemorySegment s2 = MemorySegment.ofByteBuffer(s1.asByteBuffer());\n+        MemorySegment s2 = MemorySegment.ofBuffer(s1.asByteBuffer());\n","filename":"test\/jdk\/java\/foreign\/TestByteBuffer.java","additions":17,"deletions":13,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+import java.nio.Buffer;\n@@ -148,0 +149,1 @@\n+        addDefaultMapping(Buffer.class, ByteBuffer.wrap(new byte[10]));\n","filename":"test\/jdk\/java\/foreign\/TestNulls.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -308,1 +308,1 @@\n-        MemorySegment.ofByteBuffer(ByteBuffer.allocateDirect(0)).fill((byte) 0xFF);\n+        MemorySegment.ofBuffer(ByteBuffer.allocateDirect(0)).fill((byte) 0xFF);\n","filename":"test\/jdk\/java\/foreign\/TestSegments.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -129,1 +129,1 @@\n-                    MemorySegment s2 = MemorySegment.ofByteBuffer(bb);\n+                    MemorySegment s2 = MemorySegment.ofBuffer(bb);\n","filename":"test\/jdk\/java\/foreign\/TestSharedAccess.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}