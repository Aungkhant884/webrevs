{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -102,2 +102,0 @@\n-\n-OopHandle   SystemDictionary::_system_loader_lock_obj;\n@@ -113,5 +111,0 @@\n-\n-oop SystemDictionary::system_loader_lock() {\n-  return _system_loader_lock_obj.resolve();\n-}\n-\n@@ -194,3 +187,3 @@\n-  \/\/ If class_loader is NULL we synchronize on _system_loader_lock_obj\n-  if (class_loader.is_null()) {\n-    return Handle(thread, _system_loader_lock_obj.resolve());\n+  \/\/ If class_loader is NULL or parallelCapable, the JVM doesn't acquire a lock while loading.\n+  if (is_parallelCapable(class_loader)) {\n+    return Handle();\n@@ -204,1 +197,0 @@\n-\/\/ ClassLoader::_sync_systemLoaderLockContentionRate and\n@@ -211,1 +203,1 @@\n-  assert(!loader_lock.is_null(), \"NULL lock object\");\n+  if (loader_lock.is_null()) return;\n@@ -215,7 +207,1 @@\n-    \/\/ contention will likely happen, so increment the corresponding\n-    \/\/ contention counter.\n-    if (loader_lock() == _system_loader_lock_obj.resolve()) {\n-      ClassLoader::sync_systemLoaderLockContentionRate()->inc();\n-    } else {\n-      ClassLoader::sync_nonSystemLoaderLockContentionRate()->inc();\n-    }\n+    ClassLoader::sync_nonSystemLoaderLockContentionRate()->inc();\n@@ -593,0 +579,1 @@\n+  assert(lockObject() != NULL, \"lockObject must be non-NULL\");\n@@ -595,3 +582,2 @@\n-  assert(calledholdinglock,\"must hold lock for notify\");\n-  assert((lockObject() != _system_loader_lock_obj.resolve() &&\n-         !is_parallelCapable(lockObject)), \"unexpected double_lock_wait\");\n+  assert(calledholdinglock, \"must hold lock for notify\");\n+  assert(!is_parallelCapable(lockObject), \"lockObject must not be parallelCapable\");\n@@ -600,1 +586,1 @@\n-  intx recursions =  ObjectSynchronizer::complete_exit(lockObject, thread);\n+  intx recursions = ObjectSynchronizer::complete_exit(lockObject, thread);\n@@ -747,9 +733,0 @@\n-  bool DoObjectLock = true;\n-  if (is_parallelCapable(class_loader)) {\n-    DoObjectLock = false;\n-  }\n-\n-  assert(placeholders()->compute_hash(name) == name_hash, \"they're the same hashcode\");\n-\n-  \/\/ Class is not in SystemDictionary so we have to do loading.\n-  \/\/ Make sure we are synchronized on the class loader before we proceed\n@@ -758,1 +735,1 @@\n-  ObjectLocker ol(lockObject, THREAD, DoObjectLock);\n+  ObjectLocker ol(lockObject, THREAD);\n@@ -770,0 +747,3 @@\n+\n+  assert(placeholders()->compute_hash(name) == name_hash, \"they're the same hashcode\");\n+\n@@ -1126,7 +1106,0 @@\n-  \/\/ Classloaders that support parallelism, e.g. bootstrap classloader,\n-  \/\/ do not acquire lock here\n-  bool DoObjectLock = true;\n-  if (is_parallelCapable(class_loader)) {\n-    DoObjectLock = false;\n-  }\n-\n@@ -1135,1 +1108,2 @@\n-  \/\/ Make sure we are synchronized on the class loader before we proceed\n+  \/\/ Classloaders that support parallelism, e.g. bootstrap classloader,\n+  \/\/ do not acquire lock here\n@@ -1138,3 +1112,1 @@\n-  ObjectLocker ol(lockObject, THREAD, DoObjectLock);\n-\n-  assert(st != NULL, \"invariant\");\n+  ObjectLocker ol(lockObject, THREAD);\n@@ -1171,1 +1143,1 @@\n-  \/\/ If a class loader supports parallel classloading handle parallel define requests\n+  \/\/ If a class loader supports parallel classloading, handle parallel define requests.\n@@ -1182,1 +1154,1 @@\n-    define_instance_class(k, THREAD);\n+    define_instance_class(k, class_loader, THREAD);\n@@ -1417,3 +1389,0 @@\n-  \/\/ Updating methods must be done under a lock so multiple\n-  \/\/ threads don't update these in parallel\n-  \/\/\n@@ -1423,0 +1392,3 @@\n+  \/\/ Since this class is already locked with parallel capable class\n+  \/\/ loaders, including the bootstrap loader via the placeholder table,\n+  \/\/ this lock is currently a nop.\n@@ -1429,1 +1401,1 @@\n-    ObjectLocker ol(lockObject, THREAD, true);\n+    ObjectLocker ol(lockObject, THREAD);\n@@ -1658,1 +1630,1 @@\n-void SystemDictionary::define_instance_class(InstanceKlass* k, TRAPS) {\n+void SystemDictionary::define_instance_class(InstanceKlass* k, Handle class_loader, TRAPS) {\n@@ -1660,1 +1632,0 @@\n-  HandleMark hm(THREAD);\n@@ -1662,1 +1633,1 @@\n-  Handle class_loader_h(THREAD, loader_data->class_loader());\n+  assert(loader_data->class_loader() == class_loader(), \"they must be the same\");\n@@ -1664,2 +1635,2 @@\n-  \/\/ for bootstrap and other parallel classloaders don't acquire lock,\n-  \/\/ use placeholder token\n+  \/\/ Bootstrap and other parallel classloaders don't acquire lock,\n+  \/\/ they use a placeholder token instead.\n@@ -1669,1 +1640,1 @@\n-  if (!class_loader_h.is_null() && !is_parallelCapable(class_loader_h)) {\n+  if (!is_parallelCapable(class_loader)) {\n@@ -1671,1 +1642,1 @@\n-           compute_loader_lock_object(THREAD, class_loader_h)),\n+           compute_loader_lock_object(THREAD, class_loader)),\n@@ -1687,1 +1658,1 @@\n-  check_constraints(name_hash, k, class_loader_h, true, CHECK);\n+  check_constraints(name_hash, k, class_loader, true, CHECK);\n@@ -1697,1 +1668,1 @@\n-    JavaCallArguments args(class_loader_h);\n+    JavaCallArguments args(class_loader);\n@@ -1704,2 +1675,0 @@\n-    assert(name_hash == placeholders()->compute_hash(name_h), \"they're the same\");\n-\n@@ -1713,1 +1682,1 @@\n-    update_dictionary(name_hash, k, class_loader_h);\n+    update_dictionary(name_hash, k, class_loader);\n@@ -1792,1 +1761,1 @@\n-  define_instance_class(k, THREAD);\n+  define_instance_class(k, class_loader, THREAD);\n@@ -1936,4 +1905,0 @@\n-  \/\/ Allocate private object used as system class loader lock\n-  oop lock_obj = oopFactory::new_intArray(0, CHECK);\n-  _system_loader_lock_obj = OopHandle(Universe::vm_global(), lock_obj);\n-\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":33,"deletions":68,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -541,3 +541,0 @@\n-  \/\/ Lock object for system class loader\n-  static OopHandle               _system_loader_lock_obj;\n-\n@@ -582,1 +579,1 @@\n-  static void define_instance_class(InstanceKlass* k, TRAPS);\n+  static void define_instance_class(InstanceKlass* k, Handle class_loader, TRAPS);\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.hpp","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -1033,1 +1033,0 @@\n-\n@@ -1036,7 +1035,0 @@\n-      bool DoObjectLock = true;\n-      if (is_parallelCapable(class_loader)) {\n-        DoObjectLock = false;\n-      }\n-\n-      \/\/ Make sure we are synchronized on the class loader before we proceed\n-      \/\/\n@@ -1045,5 +1037,2 @@\n-      \/\/ which are parallel-capable loaders, so this lock is NOT taken.\n-      Handle lockObject = compute_loader_lock_object(THREAD, class_loader);\n-      check_loader_lock_contention(THREAD, lockObject);\n-      ObjectLocker ol(lockObject, THREAD, DoObjectLock);\n-\n+      \/\/ which are parallel-capable loaders, so a lock here is NOT taken.\n+      assert(is_parallelCapable(class_loader), \"ObjectLocker not required\");\n@@ -1060,1 +1049,1 @@\n-        define_instance_class(k, CHECK_NULL);\n+        define_instance_class(k, class_loader, CHECK_NULL);\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.cpp","additions":4,"deletions":15,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -819,1 +819,1 @@\n-  ObjectLocker ol(h_init_lock, THREAD, h_init_lock() != NULL);\n+  ObjectLocker ol(h_init_lock, THREAD);\n@@ -955,1 +955,1 @@\n-    ObjectLocker ol(h_init_lock, THREAD, h_init_lock() != NULL);\n+    ObjectLocker ol(h_init_lock, THREAD);\n@@ -1080,1 +1080,1 @@\n-    ObjectLocker ol(h_init_lock, THREAD, h_init_lock() != NULL);\n+    ObjectLocker ol(h_init_lock, THREAD);\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -641,2 +641,1 @@\n-ObjectLocker::ObjectLocker(Handle obj, Thread* thread, bool do_lock) {\n-  _dolock = do_lock;\n+ObjectLocker::ObjectLocker(Handle obj, Thread* thread) {\n@@ -647,1 +646,1 @@\n-  if (_dolock) {\n+  if (_obj() != NULL) {\n@@ -653,1 +652,1 @@\n-  if (_dolock) {\n+  if (_obj() != NULL) {\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -177,1 +177,0 @@\n-  bool      _dolock;   \/\/ default true\n@@ -179,1 +178,1 @@\n-  ObjectLocker(Handle obj, Thread* thread, bool do_lock = true);\n+  ObjectLocker(Handle obj, Thread* thread);\n@@ -186,4 +185,0 @@\n-  \/\/ complete_exit gives up lock completely, returning recursion count\n-  \/\/ reenter reclaims lock with original recursion count\n-  intx complete_exit(TRAPS)  { return ObjectSynchronizer::complete_exit(_obj, THREAD); }\n-  void reenter(intx recursions, TRAPS)  { ObjectSynchronizer::reenter(_obj, recursions, CHECK); }\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.hpp","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"}]}