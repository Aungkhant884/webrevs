{"files":[{"patch":"@@ -222,2 +222,0 @@\n-      $1_JAVAC := $$(INTERIM_LANGTOOLS_ARGS) -cp $(BUILDTOOLS_OUTPUTDIR)\/langtools_javacserver_classes javacserver.Main\n-\n@@ -226,1 +224,6 @@\n-      $1_JAVAC_SERVER_CONFIG := $$($1_BIN)$$($1_MODULE_SUBDIR)\/_the.$$($1_SAFE_NAME)-server.conf\n+      $1_JAVAC_SERVER_CONFIG := $$($1_BIN)$$($1_MODULE_SUBDIR)\/_the.$$($1_SAFE_NAME)-javacserver.conf\n+\n+      # Arguments needed to launch the javacserver client, as well as for the\n+      # client to launch the server.\n+      $1_JAVAC_SERVER_ARGS := $$(INTERIM_LANGTOOLS_ARGS) \\\n+          -cp $(BUILDTOOLS_OUTPUTDIR)\/langtools_javacserver_classes\n@@ -232,3 +235,3 @@\n-      # The servercmd specifies how to launch the server. This will be executed\n-      # by the client, if needed.\n-      $1_JAVAC_SERVER_CMD := $$(call FixPath, $$(JAVA) $$($1_JAVA_FLAGS) $$($1_JAVAC))\n+      # The javacmd tells the client how to run java to launch the server.\n+      $1_JAVAC_SERVER_JAVA_CMD := $$(call FixPath, $$(JAVA) $$($1_JAVA_FLAGS) \\\n+          $$($1_JAVAC_SERVER_ARGS))\n@@ -236,1 +239,1 @@\n-      $1_CONFIG_VARDEPS := $$($1_JAVAC_PORT_FILE) $$($1_JAVAC_SERVER_CMD)\n+      $1_CONFIG_VARDEPS := $$($1_JAVAC_PORT_FILE) $$($1_JAVAC_SERVER_JAVA_CMD)\n@@ -240,0 +243,1 @@\n+      # Write these values to a config file\n@@ -242,1 +246,1 @@\n-\t$(ECHO) servercmd=$$($1_JAVAC_SERVER_CMD) >> $$@\n+\t$(ECHO) javacmd=$$($1_JAVAC_SERVER_JAVA_CMD) >> $$@\n@@ -245,2 +249,2 @@\n-      $1_JAVAC_CMD := $$(JAVA_SMALL) $$($1_JAVA_FLAGS) $$($1_JAVAC) \\\n-          --server:conf=$$($1_JAVAC_SERVER_CONFIG)\n+      $1_JAVAC_CMD := $$(JAVA_SMALL) $$($1_JAVA_FLAGS) $$($1_JAVAC_SERVER_ARGS) \\\n+          javacserver.Main --conf=$$($1_JAVAC_SERVER_CONFIG)\n","filename":"make\/common\/JavaCompilation.gmk","additions":14,"deletions":10,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -1,144 +0,0 @@\n-\/*\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package javacserver;\n-\n-import java.io.PrintWriter;\n-import java.io.StringWriter;\n-import java.io.Writer;\n-import java.util.Locale;\n-\n-\/**\n- * Utility class only for sjavac logging.\n- *\n- * Logging in sjavac has special requirements when running in server\/client\n- * mode. Most of the log messages is generated server-side, but the server\n- * is typically spawned by the client in the background, so the user usually\n- * does not see the server stdout\/stderr. For this reason log messages needs\n- * to relayed back to the client that performed the request that generated the\n- * log message. To support this use case this class maintains a per-thread log\n- * instance so that each connected client can have its own instance that\n- * relays messages back to the requesting client.\n- *\n- * On the client-side (or when running sjavac without server-mode) there will\n- * typically just be one Log instance.\n- *\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-public class Log {\n-\n-    public enum Level {\n-        ERROR,\n-        WARN,\n-        INFO,\n-        DEBUG,\n-        TRACE;\n-    }\n-\n-    private static Log stdOutErr = new Log(new PrintWriter(System.out), new PrintWriter(System.err));\n-    private static ThreadLocal<Log> loggers = new ThreadLocal<>();\n-\n-    protected PrintWriter err; \/\/ Used for error and warning messages\n-    protected PrintWriter out; \/\/ Used for other messages\n-    protected Level level = Level.INFO;\n-\n-    public Log(Writer out, Writer err) {\n-        this.out = out == null ? null : new PrintWriter(out, true);\n-        this.err = err == null ? null : new PrintWriter(err, true);\n-    }\n-\n-    public static void setLogForCurrentThread(Log log) {\n-        loggers.set(log);\n-    }\n-\n-    public static void setLogLevel(String l) {\n-        setLogLevel(Level.valueOf(l.toUpperCase(Locale.US)));\n-    }\n-\n-    public static void setLogLevel(Level l) {\n-        get().level = l;\n-    }\n-\n-    public static void trace(String msg) {\n-        log(Level.TRACE, msg);\n-    }\n-\n-    public static void debug(String msg) {\n-        log(Level.DEBUG, msg);\n-    }\n-\n-    public static void info(String msg) {\n-        log(Level.INFO, msg);\n-    }\n-\n-    public static void warn(String msg) {\n-        log(Level.WARN, msg);\n-    }\n-\n-    public static void error(String msg) {\n-        log(Level.ERROR, msg);\n-    }\n-\n-    public static void error(Throwable t) {\n-        log(Level.ERROR, t);\n-    }\n-\n-    public static void log(Level l, String msg) {\n-        get().printLogMsg(l, msg);\n-    }\n-\n-    public static void debug(Throwable t) {\n-        log(Level.DEBUG, t);\n-    }\n-\n-    public static void log(Level l, Throwable t) {\n-        StringWriter sw = new StringWriter();\n-        t.printStackTrace(new PrintWriter(sw, true));\n-        log(l, sw.toString());\n-    }\n-\n-    public static boolean isDebugging() {\n-        return get().isLevelLogged(Level.DEBUG);\n-    }\n-\n-    protected boolean isLevelLogged(Level l) {\n-        return l.ordinal() <= level.ordinal();\n-    }\n-\n-    public static Log get() {\n-        Log log = loggers.get();\n-        return log != null ? log : stdOutErr;\n-    }\n-\n-    protected void printLogMsg(Level msgLevel, String msg) {\n-        if (isLevelLogged(msgLevel)) {\n-            PrintWriter pw = msgLevel.ordinal() <= Level.WARN.ordinal() ? err : out;\n-            pw.println(msg);\n-        }\n-    }\n-}\n","filename":"make\/langtools\/tools\/javacserver\/Log.java","additions":0,"deletions":144,"binary":false,"changes":144,"status":"deleted"},{"patch":"@@ -28,6 +28,1 @@\n-import java.util.Arrays;\n-\n-import javacserver.client.ClientMain;\n-import javacserver.server.ServerMain;\n-\n-import static javacserver.options.Option.STARTSERVER;\n+import javacserver.client.Client;\n@@ -36,6 +31,1 @@\n- * The application entry point of the smart javac wrapper tool.\n- *\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n+ * The application entry point of the javacserver build tool.\n@@ -44,13 +34,2 @@\n-\n-    public static void main(String... args)  {\n-        System.exit(go(args));\n-    }\n-\n-    public static int go(String[] args) {\n-\n-        \/\/ Server or client mode?\n-        boolean serverMode = Arrays.asList(args)\n-                                   .stream()\n-                                   .anyMatch(arg -> arg.startsWith(STARTSERVER.arg));\n-\n-        return serverMode ? ServerMain.run(args) : ClientMain.run(args);\n+    public static void main(String... args) {\n+        Client.main(args);\n","filename":"make\/langtools\/tools\/javacserver\/Main.java","additions":4,"deletions":25,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -1,56 +0,0 @@\n-\/*\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package javacserver;\n-\n-\/** Result codes.\n- *\/\n-public enum Result {\n-    OK(0),        \/\/ Compilation completed with no errors.\n-    ERROR(1),     \/\/ Completed but reported errors.\n-    CMDERR(2),    \/\/ Bad command-line arguments\n-    SYSERR(3),    \/\/ System error or resource exhaustion.\n-    ABNORMAL(4);  \/\/ Compiler terminated abnormally\n-\n-    Result(int exitCode) {\n-        this.exitCode = exitCode;\n-    }\n-\n-    public static Result of(int exitcode) {\n-        for (Result result : values()) {\n-            if (result.exitCode == exitcode) {\n-                return result;\n-            }\n-        }\n-\n-        return ABNORMAL;\n-    }\n-\n-    public boolean isOK() {\n-        return (exitCode == 0);\n-    }\n-\n-    public final int exitCode;\n-}\n","filename":"make\/langtools\/tools\/javacserver\/Result.java","additions":0,"deletions":56,"binary":false,"changes":56,"status":"deleted"},{"patch":"@@ -1,148 +0,0 @@\n-\/*\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package javacserver;\n-\n-import java.io.PrintWriter;\n-import java.io.StringWriter;\n-import java.util.Arrays;\n-import java.util.Collection;\n-import java.util.HashSet;\n-import java.util.Set;\n-import java.util.regex.Pattern;\n-import java.util.stream.Stream;\n-\n-\/**\n- * Utilities.\n- *\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-public class Util {\n-\n-\n-\n-    public static String extractStringOption(String opName, String s) {\n-        return extractStringOption(opName, s, null);\n-    }\n-\n-    private static String extractStringOptionWithDelimiter(String opName, String s, String deflt, char delimiter) {\n-        int p = s.indexOf(opName+\"=\");\n-        if (p == -1) return deflt;\n-        p+=opName.length()+1;\n-        int pe = s.indexOf(delimiter, p);\n-        if (pe == -1) pe = s.length();\n-        return s.substring(p, pe);\n-    }\n-\n-    public static String extractStringOption(String opName, String s, String deflt) {\n-        return extractStringOptionWithDelimiter(opName, s, deflt, ',');\n-    }\n-\n-    public static String extractStringOptionLine(String opName, String s, String deflt) {\n-        return extractStringOptionWithDelimiter(opName, s, deflt, '\\n').strip();\n-    }\n-\n-    public static int extractIntOption(String opName, String s, int deflt) {\n-        int p = s.indexOf(opName+\"=\");\n-        if (p == -1) return deflt;\n-        p+=opName.length()+1;\n-        int pe = s.indexOf(',', p);\n-        if (pe == -1) pe = s.length();\n-        int v = 0;\n-        try {\n-            v = Integer.parseInt(s.substring(p, pe));\n-        } catch (Exception e) {}\n-        return v;\n-    }\n-\n-\n-    \/**\n-     * Convenience method to create a set with strings.\n-     *\/\n-    public static Set<String> set(String... ss) {\n-        Set<String> set = new HashSet<>();\n-        set.addAll(Arrays.asList(ss));\n-        return set;\n-    }\n-\n-    \/**\n-     * Normalize windows drive letter paths to upper case to enable string\n-     * comparison.\n-     *\n-     * @param file File name to normalize\n-     * @return The normalized string if file has a drive letter at the beginning,\n-     *         otherwise the original string.\n-     *\/\n-    public static String normalizeDriveLetter(String file) {\n-        if (file.length() > 2 && file.charAt(1) == ':') {\n-            return Character.toUpperCase(file.charAt(0)) + file.substring(1);\n-        } else if (file.length() > 3 && file.charAt(0) == '*'\n-                   && file.charAt(2) == ':') {\n-            \/\/ Handle a wildcard * at the beginning of the string.\n-            return file.substring(0, 1) + Character.toUpperCase(file.charAt(1))\n-                   + file.substring(2);\n-        }\n-        return file;\n-    }\n-\n-\n-    public static <E> Set<E> union(Set<? extends E> s1,\n-                                   Set<? extends E> s2) {\n-        Set<E> union = new HashSet<>();\n-        union.addAll(s1);\n-        union.addAll(s2);\n-        return union;\n-    }\n-\n-    public static <E> Set<E> subtract(Set<? extends E> orig,\n-                                      Set<? extends E> toSubtract) {\n-        Set<E> difference = new HashSet<>(orig);\n-        difference.removeAll(toSubtract);\n-        return difference;\n-    }\n-\n-    public static String getStackTrace(Throwable t) {\n-        StringWriter sw = new StringWriter();\n-        t.printStackTrace(new PrintWriter(sw));\n-        return sw.toString();\n-    }\n-\n-    public static <E> Set<E> intersection(Collection<? extends E> c1,\n-                                          Collection<? extends E> c2) {\n-        Set<E> intersection = new HashSet<E>(c1);\n-        intersection.retainAll(c2);\n-        return intersection;\n-    }\n-\n-\n-    public static Stream<String> getLines(String str) {\n-        return str.isEmpty()\n-                ? Stream.empty()\n-                : Stream.of(str.split(Pattern.quote(System.lineSeparator())));\n-    }\n-}\n","filename":"make\/langtools\/tools\/javacserver\/Util.java","additions":0,"deletions":148,"binary":false,"changes":148,"status":"deleted"},{"patch":"@@ -0,0 +1,191 @@\n+\/*\n+ * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package javacserver.client;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStreamWriter;\n+import java.io.PrintWriter;\n+import java.io.Reader;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import javacserver.server.Server;\n+import javacserver.shared.PortFileInaccessibleException;\n+import javacserver.shared.Protocol;\n+import javacserver.shared.Result;\n+import javacserver.util.AutoFlushWriter;\n+import javacserver.util.Log;\n+\n+\/**\n+ * The javacserver client. This is called from the makefiles, and is responsible for passing the command\n+ * line on to a server instance running javac, starting a new server if needed.\n+ *\/\n+public class Client {\n+    private static final Log.Level LOG_LEVEL = Log.Level.INFO;\n+\n+    \/\/ Wait 2 seconds for response, before giving up on javac server.\n+    private static final int CONNECTION_TIMEOUT = 2000;\n+    private static final int MAX_CONNECT_ATTEMPTS = 3;\n+    private static final int WAIT_BETWEEN_CONNECT_ATTEMPTS = 2000;\n+\n+    private final ClientConfiguration conf;\n+\n+    public Client(ClientConfiguration conf) {\n+        this.conf = conf;\n+    }\n+\n+    public static void main(String... args) {\n+        Log.setLogForCurrentThread(new Log(\n+                new AutoFlushWriter(new OutputStreamWriter(System.out)),\n+                new AutoFlushWriter(new OutputStreamWriter(System.err))));\n+        Log.setLogLevel(LOG_LEVEL);\n+\n+        ClientConfiguration conf = ClientConfiguration.fromCommandLineArguments(args);\n+        if (conf == null) {\n+            System.exit(Result.CMDERR.exitCode);\n+        }\n+\n+        Client client = new Client(conf);\n+        int exitCode = client.dispatchToServer();\n+\n+        System.exit(exitCode);\n+    }\n+\n+    private int dispatchToServer() {\n+        try {\n+            \/\/ Check if server seems to be already running\n+            if (!conf.portFile().hasValidValues()) {\n+                \/\/ Fork a new server and wait for it to start\n+                startNewServer();\n+            }\n+\n+            try (Socket socket = tryConnect()) {\n+                BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n+                PrintWriter out = new PrintWriter(new OutputStreamWriter(socket.getOutputStream()));\n+\n+                Protocol.sendCommand(out, conf.javacArgs());\n+                int exitCode = Protocol.readResponse(in);\n+\n+                return exitCode;\n+            }\n+        } catch (PortFileInaccessibleException e) {\n+            Log.error(\"Port file inaccessible.\");\n+            return Result.ERROR.exitCode;\n+        } catch (IOException ioe) {\n+            Log.error(\"IOException caught during compilation: \" + ioe.getMessage());\n+            Log.debug(ioe);\n+            return Result.ERROR.exitCode;\n+        } catch (InterruptedException ie) {\n+            Thread.currentThread().interrupt(); \/\/ Restore interrupt\n+            Log.error(\"Compilation interrupted.\");\n+            Log.debug(ie);\n+            return Result.ERROR.exitCode;\n+        }\n+    }\n+\n+    \/*\n+     * Makes MAX_CONNECT_ATTEMPTS attempts to connect to server.\n+     *\/\n+    private Socket tryConnect() throws IOException, InterruptedException {\n+        int attempt = 0;\n+\n+        while (true) {\n+            Log.debug(\"Trying to connect. Attempt \" + (++attempt) + \" of \" + MAX_CONNECT_ATTEMPTS);\n+            try {\n+                Socket socket = new Socket();\n+                InetAddress localhost = InetAddress.getByName(null);\n+                InetSocketAddress address = new InetSocketAddress(localhost, conf.portFile().getPort());\n+                socket.connect(address, CONNECTION_TIMEOUT);\n+                Log.debug(\"Connected\");\n+                return socket;\n+            } catch (IOException ex) {\n+                Log.error(\"Connection attempt failed: \" + ex.getMessage());\n+                if (attempt >= MAX_CONNECT_ATTEMPTS) {\n+                    Log.error(\"Giving up\");\n+                    throw new IOException(\"Could not connect to server\", ex);\n+                }\n+            }\n+            Thread.sleep(WAIT_BETWEEN_CONNECT_ATTEMPTS);\n+        }\n+    }\n+\n+    \/*\n+     * Fork a server process and wait for server to come around\n+     *\/\n+    private void startNewServer() throws IOException, InterruptedException {\n+        List<String> cmd = new ArrayList<>();\n+        \/\/ conf.javaCommand() is how to start java in the way we want to run\n+        \/\/ the server\n+        cmd.addAll(Arrays.asList(conf.javaCommand().split(\" \")));\n+        \/\/ javacserver.server.Server is the server main class\n+        cmd.add(Server.class.getName());\n+        \/\/ and it expects a port file path\n+        cmd.add(conf.portFile().getFilename());\n+\n+        Process serverProcess;\n+        Log.debug(\"Starting server. Command: \" + String.join(\" \", cmd));\n+        try {\n+            \/\/ If the cmd for some reason can't be executed (file is not found,\n+            \/\/ or is not executable for instance) this will throw an\n+            \/\/ IOException\n+            serverProcess = new ProcessBuilder(cmd).redirectErrorStream(true).start();\n+        } catch (IOException ex) {\n+            \/\/ Message is typically something like:\n+            \/\/ Cannot run program \"xyz\": error=2, No such file or directory\n+            Log.error(\"Failed to create server process: \" + ex.getMessage());\n+            Log.debug(ex);\n+            throw new IOException(ex);\n+        }\n+\n+        \/\/ serverProcess != null at this point.\n+        try {\n+            \/\/ Throws an IOException if no valid values materialize\n+            conf.portFile().waitForValidValues();\n+        } catch (IOException ex) {\n+            \/\/ Process was started, but server failed to initialize. This could\n+            \/\/ for instance be due to the JVM not finding the server class,\n+            \/\/ or the server running in to some exception early on.\n+            Log.error(\"javacserver server process failed to initialize: \" + ex.getMessage());\n+            Log.error(\"Process output:\");\n+            Reader serverStdoutStderr = new InputStreamReader(serverProcess.getInputStream());\n+            try (BufferedReader br = new BufferedReader(serverStdoutStderr)) {\n+                br.lines().forEach(Log::error);\n+            }\n+            Log.error(\"<End of process output>\");\n+            try {\n+                Log.error(\"Process exit code: \" + serverProcess.exitValue());\n+            } catch (IllegalThreadStateException e) {\n+                \/\/ Server is presumably still running.\n+            }\n+            throw new IOException(\"Server failed to initialize: \" + ex.getMessage(), ex);\n+        }\n+    }\n+}\n","filename":"make\/langtools\/tools\/javacserver\/client\/Client.java","additions":191,"deletions":0,"binary":false,"changes":191,"status":"added"},{"patch":"@@ -0,0 +1,131 @@\n+\/*\n+ * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package javacserver.client;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.List;\n+import javacserver.shared.PortFile;\n+import javacserver.util.Log;\n+\n+\/**\n+ * Description of the arguments needed to start a javacserver client, as extracted from\n+ * the command line and configuration file.\n+ *\/\n+public record ClientConfiguration(PortFile portFile, String javaCommand, String[] javacArgs) {\n+    static ClientConfiguration fromCommandLineArguments(String... args) {\n+        String confFileName = getConfFileName(args);\n+        if (confFileName == null) {\n+            return null;\n+        }\n+\n+        String confFileContent = getConfFileContent(confFileName);\n+        if (confFileContent == null) {\n+            return null;\n+        }\n+\n+        String portFileName = getPortFileName(confFileContent);\n+        if (portFileName == null) {\n+            return null;\n+        }\n+        String javaCommand = getJavaCommandString(confFileContent);\n+        if (javaCommand == null) {\n+            return null;\n+        }\n+\n+        PortFile portFile = new PortFile(portFileName);\n+        String[] javacArgs = Arrays.copyOfRange(args, 1, args.length);\n+\n+        ClientConfiguration conf = new ClientConfiguration(portFile, javaCommand, javacArgs);\n+        return conf;\n+    }\n+\n+    private static String getConfFileName(String[] args) {\n+        if (args.length < 1) {\n+            Log.error(\"Error: javacserver client: missing --conf=<conf file> argument\");\n+            return null;\n+        }\n+        String[] conf = args[0].split(\"=\", 2);\n+        if (conf.length != 2 || !conf[0].equalsIgnoreCase(\"--conf\")) {\n+            Log.error(\"Error: javacserver client: first argument must be --conf=<conf file>\");\n+            return null;\n+        }\n+        String confFileName = conf[1];\n+        if (!Files.exists(Path.of(confFileName))) {\n+            Log.error(\"Error: javacserver client: specified conf file does not exist\");\n+            return null;\n+        }\n+        return confFileName;\n+    }\n+\n+    private static String getConfFileContent(String confFile) {\n+        try {\n+            List<String> confFileLines = Files.readAllLines(Path.of(confFile));\n+            String confFileContent = String.join(\"\\n\", confFileLines);\n+            return confFileContent;\n+        } catch (IOException e) {\n+            Log.error(\"Cannot read configuration file \" + confFile);\n+            Log.debug(e);\n+            return null;\n+        }\n+    }\n+\n+    private static String getJavaCommandString(String confFileContent) {\n+        String serverCommandString = getConfValue(\"javacmd\", confFileContent);\n+        if (serverCommandString.isEmpty()) {\n+            Log.error(\"Configuration file missing value for 'javacmd'\");\n+            return null;\n+        } else {\n+            return serverCommandString;\n+        }\n+    }\n+\n+    private static String getPortFileName(String confFileContent) {\n+        String portfileName = getConfValue(\"portfile\", confFileContent);\n+        if (portfileName.isEmpty()) {\n+            Log.error(\"Configuration file missing value for 'portfile'\");\n+            return null;\n+        } else {\n+            return portfileName;\n+        }\n+    }\n+\n+    private static String getConfValue(String optionName, String content) {\n+        String result;\n+        int p = content.indexOf(optionName + \"=\");\n+        if (p == -1) {\n+            result = \"\";\n+        } else {\n+            p += optionName.length() + 1;\n+            int pe = content.indexOf('\\n', p);\n+            if (pe == -1) pe = content.length();\n+            result = content.substring(p, pe);\n+        }\n+        return result.strip();\n+    }\n+}\n\\ No newline at end of file\n","filename":"make\/langtools\/tools\/javacserver\/client\/ClientConfiguration.java","additions":131,"deletions":0,"binary":false,"changes":131,"status":"added"},{"patch":"@@ -1,80 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package javacserver.client;\n-\n-import java.io.OutputStreamWriter;\n-import java.io.Writer;\n-\n-import javacserver.AutoFlushWriter;\n-import javacserver.Log;\n-import javacserver.Result;\n-import javacserver.comp.SjavacImpl;\n-import javacserver.options.Options;\n-import javacserver.server.Sjavac;\n-\n-\/**\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-public class ClientMain {\n-\n-    public static int run(String[] args) {\n-        return run(args,\n-                   new AutoFlushWriter(new OutputStreamWriter(System.out)),\n-                   new AutoFlushWriter(new OutputStreamWriter(System.err)));\n-    }\n-\n-    public static int run(String[] args, Writer out, Writer err) {\n-\n-        Log.setLogForCurrentThread(new Log(out, err));\n-\n-        Options options;\n-        try {\n-            options = Options.parseArgs(args);\n-        } catch (IllegalArgumentException e) {\n-            Log.error(e.getMessage());\n-            return Result.CMDERR.exitCode;\n-        }\n-\n-        Log.setLogLevel(options.getLogLevel());\n-\n-        \/\/ Prepare sjavac object\n-        boolean useServer = options.getServerConf() != null;\n-        Sjavac sjavac = useServer ? new SjavacClient(options) : new SjavacImpl();\n-\n-        \/\/ Perform compilation\n-        Result result = sjavac.compile(args);\n-\n-        \/\/ If sjavac is running in the foreground we should shut it down at this point\n-        if (!useServer) {\n-            sjavac.shutdown();\n-        }\n-\n-        return result.exitCode;\n-    }\n-}\n","filename":"make\/langtools\/tools\/javacserver\/client\/ClientMain.java","additions":0,"deletions":80,"binary":false,"changes":80,"status":"deleted"},{"patch":"@@ -1,280 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package javacserver.client;\n-\n-import java.io.BufferedReader;\n-import java.io.IOException;\n-import java.io.InputStreamReader;\n-import java.io.OutputStreamWriter;\n-import java.io.PrintWriter;\n-import java.io.Reader;\n-import java.net.InetAddress;\n-import java.net.InetSocketAddress;\n-import java.net.Socket;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.List;\n-\n-import javacserver.Log;\n-import javacserver.Result;\n-import javacserver.Util;\n-import javacserver.options.Options;\n-import javacserver.server.PortFile;\n-import javacserver.server.Sjavac;\n-import javacserver.server.SjavacServer;\n-\n-\/**\n- * Sjavac implementation that delegates requests to a SjavacServer.\n- *\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-public class SjavacClient implements Sjavac {\n-\n-    private PortFile portFile;\n-\n-    \/\/ The servercmd option specifies how the server part of sjavac is spawned.\n-    \/\/ It should point to a javacserver.Main that supports --startserver\n-    private String serverCommand;\n-\n-    \/\/ Accept 120 seconds of inactivity before quitting.\n-    private static final int KEEPALIVE = 120;\n-    private static final int POOLSIZE = Runtime.getRuntime().availableProcessors();\n-    \/\/ Wait 2 seconds for response, before giving up on javac server.\n-    private static final int CONNECTION_TIMEOUT = 2000;\n-    private static final int MAX_CONNECT_ATTEMPTS = 3;\n-    private static final int WAIT_BETWEEN_CONNECT_ATTEMPTS = 2000;\n-\n-    public SjavacClient(Options options) {\n-        String serverConf = options.getServerConf();\n-        String configFile = Util.extractStringOption(\"conf\", serverConf, \"\");\n-\n-        try {\n-            List<String> configFileLines = Files.readAllLines(Path.of(configFile));\n-            String configFileContent = String.join(\"\\n\", configFileLines);\n-\n-            String portfileName = Util.extractStringOptionLine(\"portfile\", configFileContent, \"\");\n-            if (portfileName.isEmpty()) {\n-                Log.error(\"Configuration file missing value for 'portfile'\");\n-                portFile = null;\n-            } else  {\n-                portFile = SjavacServer.getPortFile(portfileName);\n-            }\n-\n-            String serverCommandString = Util.extractStringOptionLine(\"servercmd\", configFileContent, \"\");\n-            if (serverCommandString.isEmpty()) {\n-                Log.error(\"Configuration file missing value for 'servercmd'\");\n-                serverCommand = null;\n-            } else  {\n-                serverCommand = serverCommandString;\n-            }\n-        } catch (IOException e) {\n-            Log.error(\"Cannot read configuration file \" + configFile);\n-            Log.debug(e);\n-            portFile = null;\n-            serverCommand = null;\n-        }\n-    }\n-\n-    @Override\n-    public Result compile(String[] args) {\n-        if (portFile == null || serverCommand == null) {\n-            Log.error(\"Incorrect configuration, portfile and\/or servercmd missing\");\n-            return Result.ERROR;\n-        }\n-\n-        Result result = null;\n-        try (Socket socket = tryConnect()) {\n-            PrintWriter out = new PrintWriter(new OutputStreamWriter(socket.getOutputStream()));\n-            BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n-\n-            \/\/ Send args array to server\n-            out.println(args.length);\n-            for (String arg : args)\n-                out.println(arg);\n-            out.flush();\n-\n-            \/\/ Read server response line by line\n-            String line;\n-            while (null != (line = in.readLine())) {\n-                if (!line.contains(\":\")) {\n-                    throw new AssertionError(\"Could not parse protocol line: >>\\\"\" + line + \"\\\"<<\");\n-                }\n-                String[] typeAndContent = line.split(\":\", 2);\n-                String type = typeAndContent[0];\n-                String content = typeAndContent[1];\n-\n-                try {\n-                    if (Log.isDebugging()) {\n-                        \/\/ Distinguish server generated output if debugging.\n-                        content = \"[sjavac-server] \" + content;\n-                    }\n-                    Log.log(Log.Level.valueOf(type), content);\n-                    continue;\n-                } catch (IllegalArgumentException e) {\n-                    \/\/ Parsing of 'type' as log level failed.\n-                }\n-\n-                if (type.equals(SjavacServer.LINE_TYPE_RC)) {\n-                    result = Result.valueOf(content);\n-                }\n-            }\n-        } catch (PortFileInaccessibleException e) {\n-            Log.error(\"Port file inaccessible.\");\n-            result = Result.ERROR;\n-        } catch (IOException ioe) {\n-            Log.error(\"IOException caught during compilation: \" + ioe.getMessage());\n-            Log.debug(ioe);\n-            result = Result.ERROR;\n-        } catch (InterruptedException ie) {\n-            Thread.currentThread().interrupt(); \/\/ Restore interrupt\n-            Log.error(\"Compilation interrupted.\");\n-            Log.debug(ie);\n-            result = Result.ERROR;\n-        }\n-\n-        if (result == null) {\n-            \/\/ No LINE_TYPE_RC was found.\n-            result = Result.ERROR;\n-        }\n-\n-        return result;\n-    }\n-\n-    \/*\n-     * Makes MAX_CONNECT_ATTEMPTS attempts to connect to server.\n-     *\/\n-    private Socket tryConnect() throws IOException, InterruptedException {\n-        makeSureServerIsRunning();\n-        int attempt = 0;\n-        while (true) {\n-            Log.debug(\"Trying to connect. Attempt \" + (++attempt) + \" of \" + MAX_CONNECT_ATTEMPTS);\n-            try {\n-                return makeConnectionAttempt();\n-            } catch (IOException ex) {\n-                Log.error(\"Connection attempt failed: \" + ex.getMessage());\n-                if (attempt >= MAX_CONNECT_ATTEMPTS) {\n-                    Log.error(\"Giving up\");\n-                    throw new IOException(\"Could not connect to server\", ex);\n-                }\n-            }\n-            Thread.sleep(WAIT_BETWEEN_CONNECT_ATTEMPTS);\n-        }\n-    }\n-\n-    private Socket makeConnectionAttempt() throws IOException {\n-        Socket socket = new Socket();\n-        InetAddress localhost = InetAddress.getByName(null);\n-        InetSocketAddress address = new InetSocketAddress(localhost, portFile.getPort());\n-        socket.connect(address, CONNECTION_TIMEOUT);\n-        Log.debug(\"Connected\");\n-        return socket;\n-    }\n-\n-    \/*\n-     * Will return immediately if a server already seems to be running,\n-     * otherwise fork a new server and block until it seems to be running.\n-     *\/\n-    private void makeSureServerIsRunning()\n-            throws IOException, InterruptedException {\n-\n-        if (portFile.exists()) {\n-            portFile.lock();\n-            portFile.getValues();\n-            portFile.unlock();\n-\n-            if (portFile.containsPortInfo()) {\n-                \/\/ Server seems to already be running\n-                return;\n-            }\n-        }\n-\n-        \/\/ Fork a new server and wait for it to start\n-        startNewServer();\n-    }\n-\n-    @Override\n-    public void shutdown() {\n-        \/\/ Nothing to clean up\n-    }\n-\n-    \/*\n-     * Fork a server process process and wait for server to come around\n-     *\/\n-    public void startNewServer()\n-            throws IOException, InterruptedException {\n-        List<String> cmd = new ArrayList<>();\n-        cmd.addAll(Arrays.asList(serverCommand.split(\" \")));\n-        cmd.add(\"--startserver:\"\n-              + \"portfile=\" + portFile.getFilename()\n-              + \",poolsize=\" + POOLSIZE\n-              + \",keepalive=\"+ KEEPALIVE);\n-\n-        Process serverProcess;\n-        Log.debug(\"Starting server. Command: \" + String.join(\" \", cmd));\n-        try {\n-            \/\/ If the cmd for some reason can't be executed (file is not found,\n-            \/\/ or is not executable for instance) this will throw an\n-            \/\/ IOException and p == null.\n-            serverProcess = new ProcessBuilder(cmd)\n-                    .redirectErrorStream(true)\n-                    .start();\n-        } catch (IOException ex) {\n-            \/\/ Message is typically something like:\n-            \/\/ Cannot run program \"xyz\": error=2, No such file or directory\n-            Log.error(\"Failed to create server process: \" + ex.getMessage());\n-            Log.debug(ex);\n-            throw new IOException(ex);\n-        }\n-\n-        \/\/ serverProcess != null at this point.\n-        try {\n-            \/\/ Throws an IOException if no valid values materialize\n-            portFile.waitForValidValues();\n-        } catch (IOException ex) {\n-            \/\/ Process was started, but server failed to initialize. This could\n-            \/\/ for instance be due to the JVM not finding the server class,\n-            \/\/ or the server running in to some exception early on.\n-            Log.error(\"Sjavac server failed to initialize: \" + ex.getMessage());\n-            Log.error(\"Process output:\");\n-            Reader serverStdoutStderr = new InputStreamReader(serverProcess.getInputStream());\n-            try (BufferedReader br = new BufferedReader(serverStdoutStderr)) {\n-                br.lines().forEach(Log::error);\n-            }\n-            Log.error(\"<End of process output>\");\n-            try {\n-                Log.error(\"Process exit code: \" + serverProcess.exitValue());\n-            } catch (IllegalThreadStateException e) {\n-                \/\/ Server is presumably still running.\n-            }\n-            throw new IOException(\"Server failed to initialize: \" + ex.getMessage(), ex);\n-        }\n-    }\n-}\n","filename":"make\/langtools\/tools\/javacserver\/client\/SjavacClient.java","additions":0,"deletions":280,"binary":false,"changes":280,"status":"deleted"},{"patch":"@@ -1,93 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package javacserver.comp;\n-\n-import java.util.Objects;\n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.Executors;\n-import java.util.concurrent.TimeUnit;\n-\n-import javacserver.Log;\n-import javacserver.Result;\n-import javacserver.server.Sjavac;\n-\n-\/**\n- * An sjavac implementation that limits the number of concurrent calls by\n- * wrapping invocations in Callables and delegating them to a FixedThreadPool.\n- *\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-public class PooledSjavac implements Sjavac {\n-\n-    final Sjavac delegate;\n-    final ExecutorService pool;\n-\n-    public PooledSjavac(Sjavac delegate, int poolsize) {\n-        Objects.requireNonNull(delegate);\n-        this.delegate = delegate;\n-        pool = Executors.newFixedThreadPool(poolsize);\n-    }\n-\n-    @Override\n-    public Result compile(String[] args) {\n-        Log log = Log.get();\n-        try {\n-            return pool.submit(() -> {\n-                Log.setLogForCurrentThread(log);\n-                return delegate.compile(args);\n-            }).get();\n-        } catch (Exception e) {\n-            e.printStackTrace();\n-            throw new RuntimeException(\"Error during compile\", e);\n-        }\n-    }\n-\n-    @Override\n-    public void shutdown() {\n-        Log.debug(\"Shutting down PooledSjavac\");\n-        pool.shutdown(); \/\/ Disable new tasks from being submitted\n-        try {\n-            \/\/ Wait a while for existing tasks to terminate\n-            if (!pool.awaitTermination(60, TimeUnit.SECONDS)) {\n-                pool.shutdownNow(); \/\/ Cancel currently executing tasks\n-                \/\/ Wait a while for tasks to respond to being cancelled\n-                if (!pool.awaitTermination(60, TimeUnit.SECONDS))\n-                    Log.error(\"ThreadPool did not terminate\");\n-            }\n-        } catch (InterruptedException ie) {\n-          \/\/ (Re-)Cancel if current thread also interrupted\n-          pool.shutdownNow();\n-          \/\/ Preserve interrupt status\n-          Thread.currentThread().interrupt();\n-        }\n-\n-        delegate.shutdown();\n-    }\n-\n-}\n","filename":"make\/langtools\/tools\/javacserver\/comp\/PooledSjavac.java","additions":0,"deletions":93,"binary":false,"changes":93,"status":"deleted"},{"patch":"@@ -1,78 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package javacserver.comp;\n-\n-import java.io.PrintWriter;\n-import java.io.StringWriter;\n-import java.util.stream.Stream;\n-\n-import com.sun.tools.javac.Main;\n-\n-import javacserver.Log;\n-import javacserver.Result;\n-import javacserver.Util;\n-import javacserver.options.Option;\n-import javacserver.server.Sjavac;\n-\n-\/**\n- * The sjavac implementation that interacts with javac and performs the actual\n- * compilation.\n- *\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-public class SjavacImpl implements Sjavac {\n-\n-    @Override\n-    @SuppressWarnings(\"deprecated\")\n-    public Result compile(String[] args) {\n-        \/\/ Direct logging to our byte array stream.\n-        StringWriter strWriter = new StringWriter();\n-        PrintWriter printWriter = new PrintWriter(strWriter);\n-\n-        \/\/ Prepare arguments\n-        String[] passThroughArgs = Stream.of(args)\n-                                         .filter(arg -> !arg.startsWith(Option.SERVER.arg))\n-                                         .toArray(String[]::new);\n-        \/\/ Compile\n-        int exitcode = Main.compile(passThroughArgs, printWriter);\n-        Result result = Result.of(exitcode);\n-\n-        \/\/ Process compiler output (which is always errors)\n-        printWriter.flush();\n-        Util.getLines(strWriter.toString()).forEach(Log::error);\n-\n-        return result;\n-\n-    }\n-\n-    @Override\n-    public void shutdown() {\n-        \/\/ Nothing to clean up\n-    }\n-}\n","filename":"make\/langtools\/tools\/javacserver\/comp\/SjavacImpl.java","additions":0,"deletions":78,"binary":false,"changes":78,"status":"deleted"},{"patch":"@@ -1,89 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package javacserver.options;\n-\n-import java.util.Iterator;\n-\n-\/**\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-public class ArgumentIterator implements Iterator<String> {\n-\n-    \/** The underlying argument iterator *\/\n-    private Iterator<String> iter;\n-\n-    \/** Extra state used to implement peek and current *\/\n-    private String current;\n-    private String buffered;\n-\n-    public ArgumentIterator(Iterable<String> iter) {\n-        this.iter = iter.iterator();\n-    }\n-\n-    @Override\n-    public boolean hasNext() {\n-        return buffered != null || iter.hasNext();\n-    }\n-\n-    @Override\n-    public String next() {\n-        fillBuffer();\n-        current = buffered;\n-        buffered = null;\n-        return current;\n-    }\n-\n-    \/**\n-     * @return the last element returned by next() (or {@code null} if next has\n-     * never been invoked on this iterator).\n-     *\/\n-    public String current() {\n-        return current;\n-    }\n-\n-    \/** Can't remove current element, since we may have buffered it. *\/\n-    @Override\n-    public void remove() {\n-        throw new UnsupportedOperationException();\n-    }\n-\n-    \/**\n-     * @return Returns the next element without advancing the iterator\n-     *\/\n-    public String peek() {\n-        fillBuffer();\n-        return buffered;\n-    }\n-\n-    private void fillBuffer() {\n-        if (buffered == null && iter.hasNext())\n-            buffered = iter.next();\n-    }\n-\n-}\n","filename":"make\/langtools\/tools\/javacserver\/options\/ArgumentIterator.java","additions":0,"deletions":89,"binary":false,"changes":89,"status":"deleted"},{"patch":"@@ -1,294 +0,0 @@\n-\/*\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package javacserver.options;\n-\n-import java.io.IOException;\n-import java.io.Reader;\n-import java.nio.charset.Charset;\n-import java.nio.file.Files;\n-import java.nio.file.Paths;\n-import java.util.ArrayList;\n-import java.util.List;\n-\n-\/**\n- * Various utility methods for processing Java tool command line arguments.\n- *\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-public class CommandLine {\n-    \/**\n-     * Process Win32-style command files for the specified command line\n-     * arguments and return the resulting arguments. A command file argument\n-     * is of the form '@file' where 'file' is the name of the file whose\n-     * contents are to be parsed for additional arguments. The contents of\n-     * the command file are parsed using StreamTokenizer and the original\n-     * '@file' argument replaced with the resulting tokens. Recursive command\n-     * files are not supported. The '@' character itself can be quoted with\n-     * the sequence '@@'.\n-     * @param args the arguments that may contain @files\n-     * @return the arguments, with @files expanded\n-     * @throws IOException if there is a problem reading any of the @files\n-     *\/\n-    public static List<String> parse(List<String> args) throws IOException {\n-        List<String> newArgs = new ArrayList<>();\n-        appendParsedCommandArgs(newArgs, args);\n-        return newArgs;\n-    }\n-\n-    private static void appendParsedCommandArgs(List<String> newArgs, List<String> args) throws IOException {\n-        for (String arg : args) {\n-            if (arg.length() > 1 && arg.charAt(0) == '@') {\n-                arg = arg.substring(1);\n-                if (arg.charAt(0) == '@') {\n-                    newArgs.add(arg);\n-                } else {\n-                    loadCmdFile(arg, newArgs);\n-                }\n-            } else {\n-                newArgs.add(arg);\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Process the given environment variable and appends any Win32-style\n-     * command files for the specified command line arguments and return\n-     * the resulting arguments. A command file argument\n-     * is of the form '@file' where 'file' is the name of the file whose\n-     * contents are to be parsed for additional arguments. The contents of\n-     * the command file are parsed using StreamTokenizer and the original\n-     * '@file' argument replaced with the resulting tokens. Recursive command\n-     * files are not supported. The '@' character itself can be quoted with\n-     * the sequence '@@'.\n-     * @param envVariable the env variable to process\n-     * @param args the arguments that may contain @files\n-     * @return the arguments, with environment variable's content and expansion of @files\n-     * @throws IOException if there is a problem reading any of the @files\n-     * @throws UnmatchedQuote\n-     *\/\n-    public static List<String> parse(String envVariable, List<String> args)\n-            throws IOException, UnmatchedQuote {\n-\n-        List<String> inArgs = new ArrayList<>();\n-        appendParsedEnvVariables(inArgs, envVariable);\n-        inArgs.addAll(args);\n-        List<String> newArgs = new ArrayList<>();\n-        appendParsedCommandArgs(newArgs, inArgs);\n-        return newArgs;\n-    }\n-\n-    private static void loadCmdFile(String name, List<String> args) throws IOException {\n-        try (Reader r = Files.newBufferedReader(Paths.get(name), Charset.defaultCharset())) {\n-            Tokenizer t = new Tokenizer(r);\n-            String s;\n-            while ((s = t.nextToken()) != null) {\n-                args.add(s);\n-            }\n-        }\n-    }\n-\n-    public static class Tokenizer {\n-        private final Reader in;\n-        private int ch;\n-\n-        public Tokenizer(Reader in) throws IOException {\n-            this.in = in;\n-            ch = in.read();\n-        }\n-\n-        public String nextToken() throws IOException {\n-            skipWhite();\n-            if (ch == -1) {\n-                return null;\n-            }\n-\n-            StringBuilder sb = new StringBuilder();\n-            char quoteChar = 0;\n-\n-            while (ch != -1) {\n-                switch (ch) {\n-                    case ' ':\n-                    case '\\t':\n-                    case '\\f':\n-                        if (quoteChar == 0) {\n-                            return sb.toString();\n-                        }\n-                        sb.append((char) ch);\n-                        break;\n-\n-                    case '\\n':\n-                    case '\\r':\n-                        return sb.toString();\n-\n-                    case '\\'':\n-                    case '\"':\n-                        if (quoteChar == 0) {\n-                            quoteChar = (char) ch;\n-                        } else if (quoteChar == ch) {\n-                            quoteChar = 0;\n-                        } else {\n-                            sb.append((char) ch);\n-                        }\n-                        break;\n-\n-                    case '\\\\':\n-                        if (quoteChar != 0) {\n-                            ch = in.read();\n-                            switch (ch) {\n-                                case '\\n':\n-                                case '\\r':\n-                                    while (ch == ' ' || ch == '\\n' || ch == '\\r' || ch == '\\t' || ch == '\\f') {\n-                                        ch = in.read();\n-                                    }\n-                                    continue;\n-\n-                                case 'n':\n-                                    ch = '\\n';\n-                                    break;\n-                                case 'r':\n-                                    ch = '\\r';\n-                                    break;\n-                                case 't':\n-                                    ch = '\\t';\n-                                    break;\n-                                case 'f':\n-                                    ch = '\\f';\n-                                    break;\n-                            }\n-                        }\n-                        sb.append((char) ch);\n-                        break;\n-\n-                    default:\n-                        sb.append((char) ch);\n-                }\n-\n-                ch = in.read();\n-            }\n-\n-            return sb.toString();\n-        }\n-\n-        void skipWhite() throws IOException {\n-            while (ch != -1) {\n-                switch (ch) {\n-                    case ' ':\n-                    case '\\t':\n-                    case '\\n':\n-                    case '\\r':\n-                    case '\\f':\n-                        break;\n-\n-                    case '#':\n-                        ch = in.read();\n-                        while (ch != '\\n' && ch != '\\r' && ch != -1) {\n-                            ch = in.read();\n-                        }\n-                        break;\n-\n-                    default:\n-                        return;\n-                }\n-\n-                ch = in.read();\n-            }\n-        }\n-    }\n-\n-    @SuppressWarnings(\"fallthrough\")\n-    private static void appendParsedEnvVariables(List<String> newArgs, String envVariable)\n-            throws UnmatchedQuote {\n-\n-        if (envVariable == null) {\n-            return;\n-        }\n-        String in = System.getenv(envVariable);\n-        if (in == null || in.trim().isEmpty()) {\n-            return;\n-        }\n-\n-        final char NUL = (char)0;\n-        final int len = in.length();\n-\n-        int pos = 0;\n-        StringBuilder sb = new StringBuilder();\n-        char quote = NUL;\n-        char ch;\n-\n-        loop:\n-        while (pos < len) {\n-            ch = in.charAt(pos);\n-            switch (ch) {\n-                case '\\\"': case '\\'':\n-                    if (quote == NUL) {\n-                        quote = ch;\n-                    } else if (quote == ch) {\n-                        quote = NUL;\n-                    } else {\n-                        sb.append(ch);\n-                    }\n-                    pos++;\n-                    break;\n-                case '\\f': case '\\n': case '\\r': case '\\t': case ' ':\n-                    if (quote == NUL) {\n-                        newArgs.add(sb.toString());\n-                        sb.setLength(0);\n-                        while (ch == '\\f' || ch == '\\n' || ch == '\\r' || ch == '\\t' || ch == ' ') {\n-                            pos++;\n-                            if (pos >= len) {\n-                                break loop;\n-                            }\n-                            ch = in.charAt(pos);\n-                        }\n-                        break;\n-                    }\n-                    \/\/ fall through\n-                default:\n-                    sb.append(ch);\n-                    pos++;\n-            }\n-        }\n-        if (sb.length() != 0) {\n-            newArgs.add(sb.toString());\n-        }\n-        if (quote != NUL) {\n-            throw new UnmatchedQuote(envVariable);\n-        }\n-    }\n-\n-    public static class UnmatchedQuote extends Exception {\n-        private static final long serialVersionUID = 0;\n-\n-        public final String variableName;\n-\n-        UnmatchedQuote(String variable) {\n-            this.variableName = variable;\n-        }\n-    }\n-}\n","filename":"make\/langtools\/tools\/javacserver\/options\/CommandLine.java","additions":0,"deletions":294,"binary":false,"changes":294,"status":"deleted"},{"patch":"@@ -1,100 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package javacserver.options;\n-\n-\/**\n- * Sjavac options can be classified as:\n- *\n- *  (1) relevant only for sjavac, such as --server\n- *  (2) relevant for sjavac and javac, such as -d, or\n- *  (3) relevant only for javac, such as -g.\n- *\n- * This enum represents all options from (1) and (2). Note that instances of\n- * this enum only entail static information about the option. For storage of\n- * option values, refer to Options.\n- *\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-public enum Option {\n-    SERVER(\"--server:\", \"Specify server configuration file of running server\") {\n-        @Override\n-        protected void processMatching(ArgumentIterator iter, Options.ArgDecoderOptionHelper helper) {\n-            helper.serverConf(iter.current().substring(arg.length()));\n-        }\n-    },\n-    STARTSERVER(\"--startserver:\", \"Start server and use the given configuration file\") {\n-        @Override\n-        protected void processMatching(ArgumentIterator iter, Options.ArgDecoderOptionHelper helper) {\n-            helper.startServerConf(iter.current().substring(arg.length()));\n-        }\n-    };\n-\n-\n-    public final String arg;\n-\n-    final String description;\n-\n-    private Option(String arg, String description) {\n-        this.arg = arg;\n-        this.description = description;\n-    }\n-\n-    \/\/ Future cleanup: Change the \"=\" syntax to \":\" syntax to be consistent and\n-    \/\/ to follow the javac-option style.\n-\n-    public boolean hasOption() {\n-        return arg.endsWith(\":\") || arg.endsWith(\"=\");\n-    }\n-\n-\n-    \/**\n-     * Process current argument of argIter.\n-     *\n-     * It's final, since the option customization is typically done in\n-     * processMatching.\n-     *\n-     * @param argIter Iterator to read current and succeeding arguments from.\n-     * @param helper The helper to report back to.\n-     * @return true iff the argument was processed by this option.\n-     *\/\n-    public final boolean processCurrent(ArgumentIterator argIter,\n-                                        Options.ArgDecoderOptionHelper helper) {\n-        String fullArg = argIter.current(); \/\/ \"-tr\" or \"-log=level\"\n-        if (hasOption() ? fullArg.startsWith(arg) : fullArg.equals(arg)) {\n-            processMatching(argIter, helper);\n-            return true;\n-        }\n-        \/\/ Did not match\n-        return false;\n-    }\n-\n-    \/** Called by process if the current argument matches this option. *\/\n-    protected abstract void processMatching(ArgumentIterator argIter,\n-                                            Options.ArgDecoderOptionHelper helper);\n-}\n","filename":"make\/langtools\/tools\/javacserver\/options\/Option.java","additions":0,"deletions":100,"binary":false,"changes":100,"status":"deleted"},{"patch":"@@ -1,121 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package javacserver.options;\n-\n-import java.util.List;\n-\n-\/**\n- * Instances of this class represent values for sjavac command line options.\n- *\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-public class Options {\n-    private String logLevel = \"info\";\n-\n-    private boolean startServer = false;\n-\n-    \/\/ Server configuration string\n-    private String serverConf;\n-\n-    \/** Get the log level. *\/\n-    public String getLogLevel() {\n-        return logLevel;\n-    }\n-\n-    \/** Return true iff a new server should be started *\/\n-    public boolean startServerFlag() {\n-        return startServer;\n-    }\n-\n-    \/** Return the server configuration string. *\/\n-    public String getServerConf() {\n-        return serverConf;\n-    }\n-\n-    \/**\n-     * Parses the given argument array and returns a corresponding Options\n-     * instance.\n-     *\/\n-    public static Options parseArgs(String... args) {\n-        Options options = new Options();\n-        options.new ArgDecoderOptionHelper().traverse(args);\n-        return options;\n-    }\n-\n-    \/\/ OptionHelper that records the traversed options in this Options instance.\n-    public class ArgDecoderOptionHelper {\n-        public void reportError(String msg) {\n-            throw new IllegalArgumentException(msg);\n-        }\n-\n-        public void serverConf(String conf) {\n-            if (serverConf != null)\n-                reportError(\"Can not specify more than one server configuration.\");\n-            else\n-                serverConf = conf;\n-        }\n-\n-        public void startServerConf(String conf) {\n-            if (serverConf != null)\n-                reportError(\"Can not specify more than one server configuration.\");\n-            else {\n-                startServer = true;\n-                serverConf = conf;\n-            }\n-        }\n-\n-        \/**\n-         * Traverses an array of arguments and performs the appropriate callbacks.\n-         *\n-         * @param args the arguments to traverse.\n-         *\/\n-        void traverse(String[] args) {\n-            Iterable<String> allArgs;\n-            try {\n-                allArgs = CommandLine.parse(List.of(args)); \/\/ Detect @file and load it as a command line.\n-            } catch (java.io.IOException e) {\n-                throw new IllegalArgumentException(\"Problem reading @\"+e.getMessage());\n-            }\n-            ArgumentIterator argIter = new ArgumentIterator(allArgs);\n-\n-            nextArg:\n-            while (argIter.hasNext()) {\n-\n-                String arg = argIter.next();\n-\n-                if (arg.startsWith(\"-\")) {\n-                    for (Option opt : Option.values()) {\n-                        if (opt.processCurrent(argIter, this))\n-                            continue nextArg;\n-                    }\n-                }\n-            }\n-        }\n-    }\n-}\n","filename":"make\/langtools\/tools\/javacserver\/options\/Options.java","additions":0,"deletions":121,"binary":false,"changes":121,"status":"deleted"},{"patch":"@@ -0,0 +1,78 @@\n+\/*\n+ * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package javacserver.server;\n+\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+import javacserver.util.Log;\n+\n+\/**\n+ * Use a fixed thread pool to limit the amount of concurrent javac compilation\n+ * that can happen.\n+ *\/\n+public class CompilerThreadPool {\n+    private static final int POOLSIZE = Runtime.getRuntime().availableProcessors();\n+\n+    private final ExecutorService pool;\n+\n+    public CompilerThreadPool() {\n+        this.pool = Executors.newFixedThreadPool(POOLSIZE);\n+    }\n+\n+    public int dispatchCompilation(String[] args) {\n+        Log log = Log.get();\n+        try {\n+            return pool.submit(() -> Server.runCompiler(log, args)).get();\n+        } catch (Exception e) {\n+            e.printStackTrace();\n+            throw new RuntimeException(\"Error during compile\", e);\n+        }\n+    }\n+\n+    public void shutdown() {\n+        Log.debug(\"Shutting down javacserver thread pool\");\n+        pool.shutdown(); \/\/ Disable new tasks from being submitted\n+        try {\n+            \/\/ Wait a while for existing tasks to terminate\n+            if (!pool.awaitTermination(60, TimeUnit.SECONDS)) {\n+                pool.shutdownNow(); \/\/ Cancel currently executing tasks\n+                \/\/ Wait a while for tasks to respond to being cancelled\n+                if (!pool.awaitTermination(60, TimeUnit.SECONDS))\n+                    Log.error(\"Thread pool did not terminate\");\n+            }\n+        } catch (InterruptedException ie) {\n+            \/\/ (Re-)Cancel if current thread also interrupted\n+            pool.shutdownNow();\n+            \/\/ Preserve interrupt status\n+            Thread.currentThread().interrupt();\n+        }\n+    }\n+\n+    public int poolSize() {\n+        return POOLSIZE;\n+    }\n+}\n","filename":"make\/langtools\/tools\/javacserver\/server\/CompilerThreadPool.java","additions":78,"deletions":0,"binary":false,"changes":78,"status":"added"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package javacserver.server;\n+\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.function.Consumer;\n+import javacserver.util.RunnableTimerTask;\n+\n+\/**\n+ * Monitors the javacserver daemon, shutting it down if it recieves no new requests\n+ * after a certain amount of time.\n+ *\/\n+public class IdleMonitor {\n+    \/\/ Accept 120 seconds of inactivity before quitting.\n+    private static final int KEEPALIVE = 120;\n+\n+    private final Consumer<String> onShutdown;\n+    private final Timer idlenessTimer = new Timer();\n+    private int outstandingCalls = 0;\n+\n+    \/\/ Class invariant: idlenessTimerTask != null <-> idlenessTimerTask is scheduled\n+    private TimerTask idlenessTimerTask;\n+\n+    public IdleMonitor(Consumer<String> onShutdown) {\n+        this.onShutdown = onShutdown;\n+        scheduleTimeout();\n+    }\n+\n+    public synchronized void startCall() {\n+        \/\/ Was there no outstanding calls before this call?\n+        if (++outstandingCalls == 1) {\n+            \/\/ Then the timer task must have been scheduled\n+            if (idlenessTimerTask == null)\n+                throw new IllegalStateException(\"Idle timeout already cancelled\");\n+            \/\/ Cancel timeout task\n+            idlenessTimerTask.cancel();\n+            idlenessTimerTask = null;\n+        }\n+    }\n+\n+    public synchronized void endCall() {\n+        if (--outstandingCalls == 0) {\n+            \/\/ No more outstanding calls. Schedule timeout.\n+            scheduleTimeout();\n+        }\n+    }\n+\n+    private void scheduleTimeout() {\n+        if (idlenessTimerTask != null)\n+            throw new IllegalStateException(\"Idle timeout already scheduled\");\n+        idlenessTimerTask = new RunnableTimerTask(() -> {\n+            Server.restoreServerErrorLog();\n+            onShutdown.accept(\"Server has been idle for \" + KEEPALIVE + \" seconds.\");\n+        });\n+        idlenessTimer.schedule(idlenessTimerTask, KEEPALIVE * 1000);\n+    }\n+\n+    public void shutdown() {\n+        idlenessTimer.cancel();\n+    }\n+}\n","filename":"make\/langtools\/tools\/javacserver\/server\/IdleMonitor.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"@@ -1,113 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package javacserver.server;\n-\n-import java.util.Timer;\n-import java.util.TimerTask;\n-\n-import javacserver.Log;\n-import javacserver.Result;\n-\n-\/**\n- * An sjavac implementation that keeps track of idleness and shuts down the\n- * given Terminable upon idleness timeout.\n- *\n- * An idleness timeout kicks in {@code idleTimeout} milliseconds after the last\n- * request is completed.\n- *\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-public class IdleResetSjavac implements Sjavac {\n-\n-    private final Sjavac delegate;\n-    private final Terminable toShutdown;\n-    private final Timer idlenessTimer = new Timer();\n-    private final long idleTimeout;\n-    private int outstandingCalls = 0;\n-\n-    \/\/ Class invariant: idlenessTimerTask != null <-> idlenessTimerTask is scheduled\n-    private TimerTask idlenessTimerTask;\n-\n-    public IdleResetSjavac(Sjavac delegate,\n-                           Terminable toShutdown,\n-                           long idleTimeout) {\n-        this.delegate = delegate;\n-        this.toShutdown = toShutdown;\n-        this.idleTimeout = idleTimeout;\n-        scheduleTimeout();\n-    }\n-\n-    @Override\n-    public Result compile(String[] args) {\n-        startCall();\n-        try {\n-            return delegate.compile(args);\n-        } finally {\n-            endCall();\n-        }\n-    }\n-\n-    private synchronized void startCall() {\n-        \/\/ Was there no outstanding calls before this call?\n-        if (++outstandingCalls == 1) {\n-            \/\/ Then the timer task must have been scheduled\n-            if (idlenessTimerTask == null)\n-                throw new IllegalStateException(\"Idle timeout already cancelled\");\n-            \/\/ Cancel timeout task\n-            idlenessTimerTask.cancel();\n-            idlenessTimerTask = null;\n-        }\n-    }\n-\n-    private synchronized void endCall() {\n-        if (--outstandingCalls == 0) {\n-            \/\/ No more outstanding calls. Schedule timeout.\n-            scheduleTimeout();\n-        }\n-    }\n-\n-    private void scheduleTimeout() {\n-        if (idlenessTimerTask != null)\n-            throw new IllegalStateException(\"Idle timeout already scheduled\");\n-        idlenessTimerTask = new TimerTask() {\n-            public void run() {\n-                Log.setLogForCurrentThread(ServerMain.getErrorLog());\n-                toShutdown.shutdown(\"Server has been idle for \" + (idleTimeout \/ 1000) + \" seconds.\");\n-            }\n-        };\n-        idlenessTimer.schedule(idlenessTimerTask, idleTimeout);\n-    }\n-\n-    @Override\n-    public void shutdown() {\n-        idlenessTimer.cancel();\n-        delegate.shutdown();\n-    }\n-\n-}\n","filename":"make\/langtools\/tools\/javacserver\/server\/IdleResetSjavac.java","additions":0,"deletions":113,"binary":false,"changes":113,"status":"deleted"},{"patch":"@@ -30,3 +30,4 @@\n-import java.util.TimerTask;\n-\n-import javacserver.Log;\n+import java.util.function.Consumer;\n+import javacserver.shared.PortFile;\n+import javacserver.util.Log;\n+import javacserver.util.RunnableTimerTask;\n@@ -35,1 +36,1 @@\n- * Monitors the presence of a port file and shuts down the given SjavacServer\n+ * Monitors the presence of a port file and shuts down the server\n@@ -39,5 +40,0 @@\n- *\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n@@ -46,1 +42,0 @@\n-\n@@ -52,1 +47,1 @@\n-    private final SjavacServer server;\n+    private final Consumer<String> onShutdown;\n@@ -55,1 +50,1 @@\n-                           SjavacServer server) {\n+                           Consumer<String> onShutdown) {\n@@ -57,1 +52,1 @@\n-        this.server = server;\n+        this.onShutdown = onShutdown;\n@@ -62,28 +57,2 @@\n-        TimerTask shutdownCheck = new TimerTask() {\n-            public void run() {\n-                Log.setLogForCurrentThread(log);\n-                Log.debug(\"Checking port file status...\");\n-                try {\n-                    if (!portFile.exists()) {\n-                        \/\/ Time to quit because the portfile was deleted by another\n-                        \/\/ process, probably by the makefile that is done building.\n-                        server.shutdown(\"Quitting because portfile was deleted!\");\n-                    } else if (portFile.markedForStop()) {\n-                        \/\/ Time to quit because another process touched the file\n-                        \/\/ server.port.stop to signal that the server should stop.\n-                        \/\/ This is necessary on some operating systems that lock\n-                        \/\/ the port file hard!\n-                        server.shutdown(\"Quitting because a portfile.stop file was found!\");\n-                    } else if (!portFile.stillMyValues()) {\n-                        \/\/ Time to quit because another build has started.\n-                        server.shutdown(\"Quitting because portfile is now owned by another javac server!\");\n-                    }\n-                } catch (IOException e) {\n-                    Log.error(\"IOException caught in PortFileMonitor.\");\n-                    Log.debug(e);\n-                } catch (InterruptedException e) {\n-                    Thread.currentThread().interrupt();\n-                    Log.error(e);\n-                }\n-            }\n-        };\n+        timer.schedule(new RunnableTimerTask(() -> checkPortFile(log)), 0, CHECK_PORTFILE_INTERVAL);\n+    }\n@@ -91,1 +60,25 @@\n-        timer.schedule(shutdownCheck, 0, CHECK_PORTFILE_INTERVAL);\n+    private void checkPortFile(Log log) {\n+        Log.setLogForCurrentThread(log);\n+        Log.debug(\"Checking port file status...\");\n+        try {\n+            if (!portFile.exists()) {\n+                \/\/ Time to quit because the portfile was deleted by another\n+                \/\/ process, probably by the makefile that is done building.\n+                onShutdown.accept(\"Quitting because portfile was deleted!\");\n+            } else if (portFile.markedForStop()) {\n+                \/\/ Time to quit because another process touched the file\n+                \/\/ server.port.stop to signal that the server should stop.\n+                \/\/ This is necessary on some operating systems that lock\n+                \/\/ the port file hard!\n+                onShutdown.accept(\"Quitting because a portfile.stop file was found!\");\n+            } else if (!portFile.stillMyValues()) {\n+                \/\/ Time to quit because another build has started.\n+                onShutdown.accept(\"Quitting because portfile is now owned by another javac server!\");\n+            }\n+        } catch (IOException e) {\n+            Log.error(\"IOException caught in PortFileMonitor.\");\n+            Log.debug(e);\n+        } catch (InterruptedException e) {\n+            Thread.currentThread().interrupt();\n+            Log.error(e);\n+        }\n","filename":"make\/langtools\/tools\/javacserver\/server\/PortFileMonitor.java","additions":35,"deletions":42,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -1,128 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package javacserver.server;\n-\n-import java.io.BufferedReader;\n-import java.io.InputStreamReader;\n-import java.io.PrintWriter;\n-import java.net.Socket;\n-import java.nio.file.Path;\n-\n-import javacserver.Log;\n-import javacserver.Result;\n-import javacserver.Util;\n-\n-import static javacserver.server.SjavacServer.LINE_TYPE_RC;\n-\n-\n-\/**\n- * A RequestHandler handles requests performed over a socket. Specifically it\n- *  - Reads the command string specifying which method is to be invoked\n- *  - Reads the appropriate arguments\n- *  - Delegates the actual invocation to the given sjavac implementation\n- *  - Writes the result back to the socket output stream\n- *\n- * None of the work performed by this class is really bound by the CPU. It\n- * should be completely fine to have a large number of RequestHandlers active.\n- * To limit the number of concurrent compilations, use PooledSjavac.\n- *\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-public class RequestHandler extends Thread {\n-\n-    private final Socket socket;\n-    private final Sjavac sjavac;\n-\n-    public RequestHandler(Socket socket, Sjavac sjavac) {\n-        this.socket = socket;\n-        this.sjavac = sjavac;\n-    }\n-\n-    @Override\n-    public void run() {\n-\n-        try (BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n-             PrintWriter out = new PrintWriter(socket.getOutputStream(), true)) {\n-\n-            \/\/ Set up logging for this thread. Stream back logging messages to\n-            \/\/ client on the format format \"level:msg\".\n-            Log.setLogForCurrentThread(new Log(out, out) {\n-                @Override\n-                protected boolean isLevelLogged(Level l) {\n-                    \/\/ Make sure it is up to the client to decide whether or\n-                    \/\/ not this message should be displayed.\n-                    return true;\n-                }\n-\n-                @Override\n-                protected void printLogMsg(Level msgLevel, String msg) {\n-                    \/\/ Follow sjavac server\/client protocol: Send one line\n-                    \/\/ at a time and prefix with message with \"level:\".\n-                    Util.getLines(msg)\n-                        .map(line -> msgLevel + \":\" + line)\n-                        .forEach(line -> super.printLogMsg(msgLevel, line));\n-                }\n-            });\n-\n-            \/\/ Read argument array\n-            int n = Integer.parseInt(in.readLine());\n-            String[] args = new String[n];\n-            for (int i = 0; i < n; i++) {\n-                args[i] = in.readLine();\n-            }\n-\n-            \/\/ If there has been any internal errors, notify client\n-            checkInternalErrorLog();\n-\n-            \/\/ Perform compilation\n-            Result rc = sjavac.compile(args);\n-\n-            \/\/ Send return code back to client\n-            out.println(LINE_TYPE_RC + \":\" + rc.name());\n-\n-            \/\/ Check for internal errors again.\n-            checkInternalErrorLog();\n-        } catch (Exception ex) {\n-            \/\/ Not much to be done at this point. The client side request\n-            \/\/ code will most likely throw an IOException and the\n-            \/\/ compilation will fail.\n-            Log.error(ex);\n-        } finally {\n-            Log.setLogForCurrentThread(null);\n-        }\n-    }\n-\n-    private void checkInternalErrorLog() {\n-        Path errorLog = ServerMain.getErrorLog().getLogDestination();\n-        if (errorLog != null) {\n-            Log.error(\"Server has encountered an internal error. See \" + errorLog.toAbsolutePath()\n-                    + \" for details.\");\n-        }\n-    }\n-}\n","filename":"make\/langtools\/tools\/javacserver\/server\/RequestHandler.java","additions":0,"deletions":128,"binary":false,"changes":128,"status":"deleted"},{"patch":"@@ -0,0 +1,281 @@\n+\/*\n+ * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package javacserver.server;\n+\n+import com.sun.tools.javac.Main;\n+import java.io.BufferedReader;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.PrintStream;\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.ServerSocket;\n+import java.net.Socket;\n+import java.net.SocketException;\n+import java.nio.file.Path;\n+import java.util.Random;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import javacserver.shared.PortFile;\n+import javacserver.shared.Protocol;\n+import javacserver.shared.Result;\n+import javacserver.util.LazyInitFileLog;\n+import javacserver.util.Log;\n+import javacserver.util.LoggingOutputStream;\n+import javacserver.util.Util;\n+\n+\/**\n+ * Start a new server main thread, that will listen to incoming connection requests from the client,\n+ * and dispatch these on to worker threads in a thread pool, running javac.\n+ *\/\n+public class Server {\n+    private ServerSocket serverSocket;\n+    private PortFile portFile;\n+    private PortFileMonitor portFileMonitor;\n+    private IdleMonitor idleMonitor;\n+    private CompilerThreadPool compilerThreadPool;\n+\n+    \/\/ Set to false break accept loop\n+    final AtomicBoolean keepAcceptingRequests = new AtomicBoolean();\n+\n+    \/\/ For logging server internal (non request specific) errors.\n+    private static LazyInitFileLog errorLog;\n+\n+    public static void main(String... args) {\n+        initLogging();\n+\n+        try {\n+            PortFile portFile = getPortFileFromArguments(args);\n+            if (portFile == null) {\n+                System.exit(Result.CMDERR.exitCode);\n+                return;\n+            }\n+\n+            Server server = new Server(portFile);\n+            if (!server.start()) {\n+                System.exit(Result.ERROR.exitCode);\n+            } else {\n+                System.exit(Result.OK.exitCode);\n+            }\n+        } catch (IOException | InterruptedException ex) {\n+            ex.printStackTrace();\n+            System.exit(Result.ERROR.exitCode);\n+        }\n+    }\n+\n+    private static void initLogging() {\n+        \/\/ Under normal operation, all logging messages generated server-side\n+        \/\/ are due to compilation requests. These logging messages should\n+        \/\/ be relayed back to the requesting client rather than written to the\n+        \/\/ server log. The only messages that should be written to the server\n+        \/\/ log (in production mode) should be errors,\n+        errorLog = new LazyInitFileLog(\"server.log\");\n+        Log.setLogForCurrentThread(errorLog);\n+        Log.setLogLevel(Log.Level.ERROR); \/\/ should be set to ERROR.\n+\n+        \/\/ Make sure no exceptions go under the radar\n+        Thread.setDefaultUncaughtExceptionHandler((t, e) -> {\n+            restoreServerErrorLog();\n+            Log.error(e);\n+        });\n+\n+        \/\/ Inevitably someone will try to print messages using System.{out,err}.\n+        \/\/ Make sure this output also ends up in the log.\n+        System.setOut(new PrintStream(new LoggingOutputStream(System.out, Log.Level.INFO, \"[stdout] \")));\n+        System.setErr(new PrintStream(new LoggingOutputStream(System.err, Log.Level.ERROR, \"[stderr] \")));\n+    }\n+\n+    private static PortFile getPortFileFromArguments(String[] args) {\n+        if (args.length != 1) {\n+            Log.error(\"javacserver daemon incorrectly called\");\n+            return null;\n+        }\n+        String portfilename = args[0];\n+        PortFile portFile = new PortFile(portfilename);\n+        return portFile;\n+    }\n+\n+    public Server(PortFile portFile) throws FileNotFoundException {\n+        this.portFile = portFile;\n+    }\n+\n+    \/**\n+     * Start the daemon, unless another one is already running, in which it returns\n+     * false and exits immediately.\n+     *\/\n+    private boolean start() throws IOException, InterruptedException {\n+        \/\/ The port file is locked and the server port and cookie is written into it.\n+        portFile.lock();\n+        portFile.getValues();\n+        if (portFile.containsPortInfo()) {\n+            Log.debug(\"javacserver daemon not started because portfile exists!\");\n+            portFile.unlock();\n+            return false;\n+        }\n+\n+        serverSocket = new ServerSocket();\n+        InetAddress localhost = InetAddress.getByName(null);\n+        serverSocket.bind(new InetSocketAddress(localhost, 0));\n+\n+        \/\/ At this point the server accepts connections, so it is  now safe\n+        \/\/ to publish the port \/ cookie information\n+\n+        \/\/ The secret cookie shared between server and client through the port file.\n+        \/\/ Used to prevent clients from believing that they are communicating with\n+        \/\/ an old server when a new server has started and reused the same port as\n+        \/\/ an old server.\n+        long myCookie = new Random().nextLong();\n+        portFile.setValues(serverSocket.getLocalPort(), myCookie);\n+        portFile.unlock();\n+\n+        portFileMonitor = new PortFileMonitor(portFile, this::shutdownServer);\n+        portFileMonitor.start();\n+        compilerThreadPool = new CompilerThreadPool();\n+        idleMonitor = new IdleMonitor(this::shutdownServer);\n+\n+        Log.debug(\"javacserver daemon started. Accepting connections...\");\n+        Log.debug(\"    port: \" + serverSocket.getLocalPort());\n+        Log.debug(\"    time: \" + new java.util.Date());\n+        Log.debug(\"    poolsize: \" + compilerThreadPool.poolSize());\n+\n+        keepAcceptingRequests.set(true);\n+        do {\n+            try {\n+                Socket socket = serverSocket.accept();\n+                 \/\/ Handle each incoming request in a separate thread. This is just for socket communication,\n+                 \/\/ the actual compilation will be done by the threadpool.\n+                Thread requestHandler = new Thread(() -> handleRequest(socket));\n+                requestHandler.start();\n+            } catch (SocketException se) {\n+                \/\/ Caused by serverSocket.close() and indicates shutdown\n+            }\n+        } while (keepAcceptingRequests.get());\n+\n+        Log.debug(\"Shutting down.\");\n+\n+        \/\/ No more connections accepted. If any client managed to connect after\n+        \/\/ the accept() was interrupted but before the server socket is closed\n+        \/\/ here, any attempt to read or write to the socket will result in an\n+        \/\/ IOException on the client side.\n+\n+        \/\/ Shut down\n+        idleMonitor.shutdown();\n+        compilerThreadPool.shutdown();\n+\n+        return true;\n+    }\n+\n+    private void handleRequest(Socket socket) {\n+        try (BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n+             PrintWriter out = new PrintWriter(socket.getOutputStream(), true)) {\n+            try {\n+                idleMonitor.startCall();\n+\n+                \/\/ Set up logging for this thread. Stream back logging messages to\n+                \/\/ client on the format \"level:msg\".\n+                Log.setLogForCurrentThread(new Protocol.ProtocolLog(out));\n+\n+                String[] args = Protocol.readCommand(in);\n+\n+                \/\/ If there has been any internal errors, notify client\n+                checkInternalErrorLog();\n+\n+                \/\/ Perform compilation. This will call runCompiler() on a\n+                \/\/ thread in the thread pool\n+                int exitCode = compilerThreadPool.dispatchCompilation(args);\n+                Protocol.sendExitCode(out, exitCode);\n+\n+                \/\/ Check for internal errors again.\n+                checkInternalErrorLog();\n+            } finally {\n+                idleMonitor.endCall();\n+            }\n+        } catch (Exception ex) {\n+            \/\/ Not much to be done at this point. The client side request\n+            \/\/ code will most likely throw an IOException and the\n+            \/\/ compilation will fail.\n+            Log.error(ex);\n+        } finally {\n+            Log.setLogForCurrentThread(null);\n+        }\n+    }\n+\n+    @SuppressWarnings(\"deprecated\")\n+    public static int runCompiler(Log log, String[] args) {\n+        Log.setLogForCurrentThread(log);\n+\n+        \/\/ Direct logging to our byte array stream.\n+        StringWriter strWriter = new StringWriter();\n+        PrintWriter printWriter = new PrintWriter(strWriter);\n+\n+        \/\/ Compile\n+        int exitcode = Main.compile(args, printWriter);\n+\n+        \/\/ Process compiler output (which is always errors)\n+        printWriter.flush();\n+        Util.getLines(strWriter.toString()).forEach(Log::error);\n+\n+        return exitcode;\n+    }\n+\n+    private void checkInternalErrorLog() {\n+        Path errorLogPath = errorLog.getLogDestination();\n+        if (errorLogPath != null) {\n+            Log.error(\"Server has encountered an internal error. See \" + errorLogPath.toAbsolutePath()\n+                    + \" for details.\");\n+        }\n+    }\n+\n+    public static void restoreServerErrorLog() {\n+        Log.setLogForCurrentThread(errorLog);\n+    }\n+\n+    public void shutdownServer(String quitMsg) {\n+        if (!keepAcceptingRequests.compareAndSet(true, false)) {\n+            \/\/ Already stopped, no need to shut down again\n+            return;\n+        }\n+\n+        Log.debug(\"Quitting: \" + quitMsg);\n+\n+        portFileMonitor.shutdown(); \/\/ No longer any need to monitor port file\n+\n+        \/\/ Unpublish port before shutting down socket to minimize the number of\n+        \/\/ failed connection attempts\n+        try {\n+            portFile.delete();\n+        } catch (IOException | InterruptedException e) {\n+            Log.error(e);\n+        }\n+        try {\n+            serverSocket.close();\n+        } catch (IOException e) {\n+            Log.error(e);\n+        }\n+    }\n+}\n","filename":"make\/langtools\/tools\/javacserver\/server\/Server.java","additions":281,"deletions":0,"binary":false,"changes":281,"status":"added"},{"patch":"@@ -1,92 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package javacserver.server;\n-\n-import java.io.IOException;\n-import java.io.PrintStream;\n-\n-import javacserver.Log;\n-import javacserver.Result;\n-import javacserver.server.log.LazyInitFileLog;\n-import javacserver.server.log.LoggingOutputStream;\n-\n-import static javacserver.Log.Level.ERROR;\n-import static javacserver.Log.Level.INFO;\n-\n-\/**\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-public class ServerMain {\n-\n-    \/\/ For logging server internal (non request specific) errors.\n-    private static LazyInitFileLog errorLog;\n-\n-    public static int run(String[] args) {\n-\n-        \/\/ Under normal operation, all logging messages generated server-side\n-        \/\/ are due to compilation requests. These logging messages should\n-        \/\/ be relayed back to the requesting client rather than written to the\n-        \/\/ server log. The only messages that should be written to the server\n-        \/\/ log (in production mode) should be errors,\n-        Log.setLogForCurrentThread(errorLog = new LazyInitFileLog(\"server.log\"));\n-        Log.setLogLevel(ERROR); \/\/ should be set to ERROR.\n-\n-        \/\/ Make sure no exceptions go under the radar\n-        Thread.setDefaultUncaughtExceptionHandler((t, e) -> {\n-            Log.setLogForCurrentThread(errorLog);\n-            Log.error(e);\n-        });\n-\n-        \/\/ Inevitably someone will try to print messages using System.{out,err}.\n-        \/\/ Make sure this output also ends up in the log.\n-        System.setOut(new PrintStream(new LoggingOutputStream(System.out, INFO, \"[stdout] \")));\n-        System.setErr(new PrintStream(new LoggingOutputStream(System.err, ERROR, \"[stderr] \")));\n-\n-        \/\/ Any options other than --startserver?\n-        if (args.length > 1) {\n-            Log.error(\"When spawning a background server, only a single --startserver argument is allowed.\");\n-            return Result.CMDERR.exitCode;\n-        }\n-\n-        int exitCode;\n-        try {\n-            SjavacServer server = new SjavacServer(args[0]);\n-            exitCode = server.startServer();\n-        } catch (IOException | InterruptedException ex) {\n-            ex.printStackTrace();\n-            exitCode = Result.ERROR.exitCode;\n-        }\n-\n-        return exitCode;\n-    }\n-\n-    public static LazyInitFileLog getErrorLog() {\n-        return errorLog;\n-    }\n-}\n","filename":"make\/langtools\/tools\/javacserver\/server\/ServerMain.java","additions":0,"deletions":92,"binary":false,"changes":92,"status":"deleted"},{"patch":"@@ -1,42 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package javacserver.server;\n-\n-import javacserver.Result;\n-\n-\/**\n- * Interface of the SjavacImpl, the sjavac client and all wrappers such as\n- * PooledSjavac etc.\n- *\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-public interface Sjavac {\n-    Result compile(String[] args);\n-    void shutdown();\n-}\n","filename":"make\/langtools\/tools\/javacserver\/server\/Sjavac.java","additions":0,"deletions":42,"binary":false,"changes":42,"status":"deleted"},{"patch":"@@ -1,248 +0,0 @@\n-\/*\n- * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package javacserver.server;\n-\n-import java.io.FileNotFoundException;\n-import java.io.IOException;\n-import java.net.InetAddress;\n-import java.net.InetSocketAddress;\n-import java.net.ServerSocket;\n-import java.net.Socket;\n-import java.net.SocketException;\n-import java.util.HashMap;\n-import java.util.Map;\n-import java.util.Random;\n-import java.util.concurrent.atomic.AtomicBoolean;\n-\n-import javacserver.Log;\n-import javacserver.Result;\n-import javacserver.Util;\n-import javacserver.comp.PooledSjavac;\n-import javacserver.comp.SjavacImpl;\n-\n-\/**\n- * The JavacServer class contains methods both to setup a server that responds to requests and methods to connect to this server.\n- *\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-public class SjavacServer implements Terminable {\n-\n-    \/\/ Prefix of line containing return code.\n-    public static final String LINE_TYPE_RC = \"RC\";\n-\n-    private final String portfilename;\n-    private final int poolsize;\n-    private final int keepalive;\n-\n-    \/\/ The secret cookie shared between server and client through the port file.\n-    \/\/ Used to prevent clients from believing that they are communicating with\n-    \/\/ an old server when a new server has started and reused the same port as\n-    \/\/ an old server.\n-    private final long myCookie;\n-\n-    \/\/ Accumulated build time, not counting idle time, used for logging purposes\n-    private long totalBuildTime;\n-\n-    \/\/ The sjavac implementation to delegate requests to\n-    Sjavac sjavac;\n-\n-    private ServerSocket serverSocket;\n-\n-    private PortFile portFile;\n-    private PortFileMonitor portFileMonitor;\n-\n-    \/\/ Set to false break accept loop\n-    final AtomicBoolean keepAcceptingRequests = new AtomicBoolean();\n-\n-    \/\/ For the client, all port files fetched, one per started javac server.\n-    \/\/ Though usually only one javac server is started by a client.\n-    private static Map<String, PortFile> allPortFiles;\n-\n-    public SjavacServer(String settings) throws FileNotFoundException {\n-        this(Util.extractStringOption(\"portfile\", settings),\n-             Util.extractIntOption(\"poolsize\", settings, Runtime.getRuntime().availableProcessors()),\n-             Util.extractIntOption(\"keepalive\", settings, 120));\n-    }\n-\n-    public SjavacServer(String portfilename,\n-                        int poolsize,\n-                        int keepalive)\n-                                throws FileNotFoundException {\n-        this.portfilename = portfilename;\n-        this.poolsize = poolsize;\n-        this.keepalive = keepalive;\n-        this.myCookie = new Random().nextLong();\n-    }\n-\n-\n-    \/**\n-     * Acquire the port file. Synchronized since several threads inside an smart javac wrapper client acquires the same port file at the same time.\n-     *\/\n-    public static synchronized PortFile getPortFile(String filename) {\n-        if (allPortFiles == null) {\n-            allPortFiles = new HashMap<>();\n-        }\n-        PortFile pf = allPortFiles.get(filename);\n-\n-        \/\/ Port file known. Does it still exist?\n-        if (pf != null) {\n-            try {\n-                if (!pf.exists())\n-                    pf = null;\n-            } catch (IOException ioex) {\n-                ioex.printStackTrace();\n-            }\n-        }\n-\n-        if (pf == null) {\n-            pf = new PortFile(filename);\n-            allPortFiles.put(filename, pf);\n-        }\n-        return pf;\n-    }\n-\n-    \/**\n-     * Get the cookie used for this server.\n-     *\/\n-    long getCookie() {\n-        return myCookie;\n-    }\n-\n-    \/**\n-     * Get the port used for this server.\n-     *\/\n-    int getPort() {\n-        return serverSocket.getLocalPort();\n-    }\n-\n-    \/**\n-     * Sum up the total build time for this javac server.\n-     *\/\n-    public void addBuildTime(long inc) {\n-        totalBuildTime += inc;\n-    }\n-\n-    \/**\n-     * Start a server using a settings string. Typically: \"--startserver:portfile=\/tmp\/myserver,poolsize=3\" and the string \"portfile=\/tmp\/myserver,poolsize=3\"\n-     * is sent as the settings parameter. Returns 0 on success, -1 on failure.\n-     *\/\n-    public int startServer() throws IOException, InterruptedException {\n-        long serverStart = System.currentTimeMillis();\n-\n-        \/\/ The port file is locked and the server port and cookie is written into it.\n-        portFile = getPortFile(portfilename);\n-\n-        synchronized (portFile) {\n-            portFile.lock();\n-            portFile.getValues();\n-            if (portFile.containsPortInfo()) {\n-                Log.debug(\"Javac server not started because portfile exists!\");\n-                portFile.unlock();\n-                return Result.ERROR.exitCode;\n-            }\n-\n-            \/\/           .-----------.   .--------.   .------.\n-            \/\/ socket -->| IdleReset |-->| Pooled |-->| Impl |--> javac\n-            \/\/           '-----------'   '--------'   '------'\n-            sjavac = new SjavacImpl();\n-            sjavac = new PooledSjavac(sjavac, poolsize);\n-            sjavac = new IdleResetSjavac(sjavac,\n-                                         this,\n-                                         keepalive * 1000);\n-\n-            serverSocket = new ServerSocket();\n-            InetAddress localhost = InetAddress.getByName(null);\n-            serverSocket.bind(new InetSocketAddress(localhost, 0));\n-\n-            \/\/ At this point the server accepts connections, so it is  now safe\n-            \/\/ to publish the port \/ cookie information\n-            portFile.setValues(getPort(), getCookie());\n-            portFile.unlock();\n-        }\n-\n-        portFileMonitor = new PortFileMonitor(portFile, this);\n-        portFileMonitor.start();\n-\n-        Log.debug(\"Sjavac server started. Accepting connections...\");\n-        Log.debug(\"    port: \" + getPort());\n-        Log.debug(\"    time: \" + new java.util.Date());\n-        Log.debug(\"    poolsize: \" + poolsize);\n-\n-\n-        keepAcceptingRequests.set(true);\n-        do {\n-            try {\n-                Socket socket = serverSocket.accept();\n-                new RequestHandler(socket, sjavac).start();\n-            } catch (SocketException se) {\n-                \/\/ Caused by serverSocket.close() and indicates shutdown\n-            }\n-        } while (keepAcceptingRequests.get());\n-\n-        Log.debug(\"Shutting down.\");\n-\n-        \/\/ No more connections accepted. If any client managed to connect after\n-        \/\/ the accept() was interrupted but before the server socket is closed\n-        \/\/ here, any attempt to read or write to the socket will result in an\n-        \/\/ IOException on the client side.\n-\n-        long realTime = System.currentTimeMillis() - serverStart;\n-        Log.debug(\"Total wall clock time \" + realTime + \"ms build time \" + totalBuildTime + \"ms\");\n-\n-        \/\/ Shut down\n-        sjavac.shutdown();\n-\n-        return Result.OK.exitCode;\n-    }\n-\n-    @Override\n-    public void shutdown(String quitMsg) {\n-        if (!keepAcceptingRequests.compareAndSet(true, false)) {\n-            \/\/ Already stopped, no need to shut down again\n-            return;\n-        }\n-\n-        Log.debug(\"Quitting: \" + quitMsg);\n-\n-        portFileMonitor.shutdown(); \/\/ No longer any need to monitor port file\n-\n-        \/\/ Unpublish port before shutting down socket to minimize the number of\n-        \/\/ failed connection attempts\n-        try {\n-            portFile.delete();\n-        } catch (IOException | InterruptedException e) {\n-            Log.error(e);\n-        }\n-        try {\n-            serverSocket.close();\n-        } catch (IOException e) {\n-            Log.error(e);\n-        }\n-    }\n-}\n","filename":"make\/langtools\/tools\/javacserver\/server\/SjavacServer.java","additions":0,"deletions":248,"binary":false,"changes":248,"status":"deleted"},{"patch":"@@ -1,36 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package javacserver.server;\n-\n-\/**\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-public interface Terminable {\n-    void shutdown(String quitMsg);\n-}\n","filename":"make\/langtools\/tools\/javacserver\/server\/Terminable.java","additions":0,"deletions":36,"binary":false,"changes":36,"status":"deleted"},{"patch":"@@ -26,1 +26,1 @@\n-package javacserver.server;\n+package javacserver.shared;\n@@ -37,3 +37,1 @@\n-\n-import javacserver.Log;\n-import javacserver.client.PortFileInaccessibleException;\n+import javacserver.util.Log;\n@@ -45,6 +43,1 @@\n- * system locking is not always supported on a all operating systems and\/or file systems.\n- *\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n+ * system locking is not always supported on all operating systems and\/or file systems.\n@@ -53,1 +46,0 @@\n-\n@@ -228,0 +220,13 @@\n+    public boolean hasValidValues() throws IOException, InterruptedException {\n+        if (exists()) {\n+            lock();\n+            getValues();\n+            unlock();\n+\n+            if (containsPortInfo()) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n@@ -280,1 +285,1 @@\n-                \/\/ The channel has been closed since sjavac is exiting.\n+                \/\/ The channel has been closed since the server is exiting.\n","filename":"make\/langtools\/tools\/javacserver\/shared\/PortFile.java","additions":17,"deletions":12,"binary":false,"changes":29,"previous_filename":"make\/langtools\/tools\/javacserver\/server\/PortFile.java","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n-package javacserver.client;\n+package javacserver.shared;\n","filename":"make\/langtools\/tools\/javacserver\/shared\/PortFileInaccessibleException.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"make\/langtools\/tools\/javacserver\/client\/PortFileInaccessibleException.java","status":"renamed"},{"patch":"@@ -0,0 +1,144 @@\n+\/*\n+ * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package javacserver.shared;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import javacserver.util.Log;\n+import javacserver.util.Util;\n+\n+\/**\n+ * Implementation of the wire protocol used by the javacserver client and daemon to communicate.\n+ * Basically, the client sends the argument to javac, one line per string. The server responds\n+ * with log lines (if there is any output), and the exit code from javac.\n+ *\/\n+public class Protocol {\n+    \/\/ Prefix of line containing return code.\n+    private static final String LINE_TYPE_RC = \"RC\";\n+\n+    public static void sendCommand(PrintWriter out, String[] args) throws IOException {\n+        \/\/ Send args array to server\n+        out.println(args.length);\n+        for (String arg : args)\n+            out.println(arg);\n+        out.flush();\n+    }\n+\n+    public static String[] readCommand(BufferedReader in) throws IOException {\n+        \/\/ Read argument array\n+        int n = Integer.parseInt(in.readLine());\n+        String[] args = new String[n];\n+        for (int i = 0; i < n; i++) {\n+            args[i] = in.readLine();\n+        }\n+        return args;\n+    }\n+\n+    public static void sendExitCode(PrintWriter out, int exitCode) {\n+        \/\/ Send return code back to client\n+        out.println(LINE_TYPE_RC + \":\" + exitCode);\n+    }\n+\n+    public static int readResponse(BufferedReader in) throws IOException {\n+        \/\/ Read server response line by line\n+        String line;\n+        while (null != (line = in.readLine())) {\n+            Line parsedLine = new Line(line);\n+\n+            try {\n+                String content = parsedLine.getContent();\n+                if (Log.isDebugging()) {\n+                    \/\/ Distinguish server generated output if debugging.\n+                    content = \"[javacserver] \" + content;\n+                }\n+                Log.log(Log.Level.valueOf(parsedLine.getType()), content);\n+                continue;\n+            } catch (IllegalArgumentException e) {\n+                \/\/ Parsing of 'type' as log level failed.\n+            }\n+\n+            if (parsedLine.isExitCode()) {\n+                return parsedLine.getExitCode();\n+            }\n+        }\n+        \/\/ No exit code was found.\n+        return Result.ERROR.exitCode;\n+    }\n+\n+    public static class Line {\n+        private final String type;\n+\n+        public String getType() {\n+            return type;\n+        }\n+\n+        public String getContent() {\n+            return content;\n+        }\n+\n+        public boolean isExitCode() {\n+            return type.equals(LINE_TYPE_RC);\n+        }\n+\n+        public int getExitCode() {\n+            return Integer.parseInt(content);\n+        }\n+\n+        private final String content;\n+\n+        public Line(String line) {\n+            if (!line.contains(\":\")) {\n+                throw new AssertionError(\"Could not parse protocol line: >>\\\"\" + line + \"\\\"<<\");\n+            }\n+            String[] typeAndContent = line.split(\":\", 2);\n+            type = typeAndContent[0];\n+            content = typeAndContent[1];\n+        }\n+    }\n+\n+    public static class ProtocolLog extends Log {\n+        public ProtocolLog(PrintWriter out) {\n+            super(out, out);\n+        }\n+\n+        @Override\n+        protected boolean isLevelLogged(Level l) {\n+            \/\/ Make sure it is up to the client to decide whether or\n+            \/\/ not this message should be displayed.\n+            return true;\n+        }\n+\n+        @Override\n+        protected void printLogMsg(Level msgLevel, String msg) {\n+            \/\/ Follow the server\/client protocol: Send one line\n+            \/\/ at a time and prefix with message with \"level:\".\n+            Util.getLines(msg)\n+                .map(line -> msgLevel + \":\" + line)\n+                .forEach(line -> super.printLogMsg(msgLevel, line));\n+        }\n+    }\n+}\n","filename":"make\/langtools\/tools\/javacserver\/shared\/Protocol.java","additions":144,"deletions":0,"binary":false,"changes":144,"status":"added"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package javacserver.shared;\n+\n+\/**\n+ * Result codes.\n+ *\/\n+public enum Result {\n+    OK(0),        \/\/ Compilation completed with no errors.\n+    ERROR(1),     \/\/ Completed but reported errors.\n+    CMDERR(2);    \/\/ Bad command-line arguments\n+\n+    public final int exitCode;\n+\n+    Result(int exitCode) {\n+        this.exitCode = exitCode;\n+    }\n+}\n","filename":"make\/langtools\/tools\/javacserver\/shared\/Result.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -26,1 +26,1 @@\n-package javacserver;\n+package javacserver.util;\n@@ -33,1 +33,0 @@\n-\n","filename":"make\/langtools\/tools\/javacserver\/util\/AutoFlushWriter.java","additions":1,"deletions":2,"binary":false,"changes":3,"previous_filename":"make\/langtools\/tools\/javacserver\/AutoFlushWriter.java","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n-package javacserver.server.log;\n+package javacserver.util;\n@@ -35,2 +35,0 @@\n-import javacserver.Log;\n-\n@@ -38,1 +36,0 @@\n-\n","filename":"make\/langtools\/tools\/javacserver\/util\/LazyInitFileLog.java","additions":1,"deletions":4,"binary":false,"changes":5,"previous_filename":"make\/langtools\/tools\/javacserver\/server\/log\/LazyInitFileLog.java","status":"renamed"},{"patch":"@@ -0,0 +1,120 @@\n+\/*\n+ * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package javacserver.util;\n+\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.io.Writer;\n+\n+\/**\n+ * Utility class only for javacserver logging.\n+ *\n+ * Logging in javacserver has special requirements when running in server\/client\n+ * mode. Most of the log messages is generated server-side, but the server\n+ * is typically spawned by the client in the background, so the user usually\n+ * does not see the server stdout\/stderr. For this reason log messages needs\n+ * to relayed back to the client that performed the request that generated the\n+ * log message. To support this use case this class maintains a per-thread log\n+ * instance so that each connected client can have its own instance that\n+ * relays messages back to the requesting client.\n+ *\n+ * On the client-side there will typically just be one Log instance.\n+ *\/\n+public class Log {\n+    public enum Level {\n+        ERROR,\n+        WARN,\n+        INFO,\n+        DEBUG,\n+        TRACE;\n+    }\n+\n+    private static Log stdOutErr = new Log(new PrintWriter(System.out), new PrintWriter(System.err));\n+    private static ThreadLocal<Log> logger = new ThreadLocal<>();\n+\n+    protected PrintWriter err; \/\/ Used for error and warning messages\n+    protected PrintWriter out; \/\/ Used for other messages\n+    protected Level level = Level.INFO;\n+\n+    public Log(Writer out, Writer err) {\n+        this.out = out == null ? null : new PrintWriter(out, true);\n+        this.err = err == null ? null : new PrintWriter(err, true);\n+    }\n+\n+    public static void setLogForCurrentThread(Log log) {\n+        logger.set(log);\n+    }\n+\n+    public static void setLogLevel(Level l) {\n+        get().level = l;\n+    }\n+\n+    public static void debug(String msg) {\n+        log(Level.DEBUG, msg);\n+    }\n+\n+    public static void debug(Throwable t) {\n+        log(Level.DEBUG, t);\n+    }\n+\n+    public static void error(String msg) {\n+        log(Level.ERROR, msg);\n+    }\n+\n+    public static void error(Throwable t) {\n+        log(Level.ERROR, t);\n+    }\n+\n+    public static void log(Level l, String msg) {\n+        get().printLogMsg(l, msg);\n+    }\n+\n+    public static void log(Level l, Throwable t) {\n+        StringWriter sw = new StringWriter();\n+        t.printStackTrace(new PrintWriter(sw, true));\n+        log(l, sw.toString());\n+    }\n+\n+    public static boolean isDebugging() {\n+        return get().isLevelLogged(Level.DEBUG);\n+    }\n+\n+    protected boolean isLevelLogged(Level l) {\n+        return l.ordinal() <= level.ordinal();\n+    }\n+\n+    public static Log get() {\n+        Log log = logger.get();\n+        return log != null ? log : stdOutErr;\n+    }\n+\n+    protected void printLogMsg(Level msgLevel, String msg) {\n+        if (isLevelLogged(msgLevel)) {\n+            PrintWriter pw = msgLevel.ordinal() <= Level.WARN.ordinal() ? err : out;\n+            pw.println(msg);\n+        }\n+    }\n+}\n","filename":"make\/langtools\/tools\/javacserver\/util\/Log.java","additions":120,"deletions":0,"binary":false,"changes":120,"status":"added"},{"patch":"@@ -26,1 +26,1 @@\n-package javacserver.server.log;\n+package javacserver.util;\n@@ -33,2 +33,0 @@\n-import javacserver.Log;\n-\n@@ -36,1 +34,0 @@\n-\n","filename":"make\/langtools\/tools\/javacserver\/util\/LoggingOutputStream.java","additions":1,"deletions":4,"binary":false,"changes":5,"previous_filename":"make\/langtools\/tools\/javacserver\/server\/log\/LoggingOutputStream.java","status":"renamed"},{"patch":"@@ -0,0 +1,44 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package javacserver.util;\n+\n+import java.util.TimerTask;\n+\n+\/**\n+ * Wrapper class since TimerTask is not up to modern standards\n+ *\/\n+public class RunnableTimerTask extends TimerTask {\n+    private final Runnable task;\n+\n+    public RunnableTimerTask(Runnable task) {\n+        this.task = task;\n+    }\n+\n+    @Override\n+    public void run() {\n+        task.run();\n+    }\n+}\n","filename":"make\/langtools\/tools\/javacserver\/util\/RunnableTimerTask.java","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"},{"patch":"@@ -0,0 +1,40 @@\n+\/*\n+ * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package javacserver.util;\n+\n+import java.util.regex.Pattern;\n+import java.util.stream.Stream;\n+\n+public class Util {\n+    \/**\n+     * Return a stream of strings, where the input string is split at line separators.\n+     *\/\n+    public static Stream<String> getLines(String str) {\n+        return str.isEmpty()\n+                ? Stream.empty()\n+                : Stream.of(str.split(Pattern.quote(System.lineSeparator())));\n+    }\n+}\n","filename":"make\/langtools\/tools\/javacserver\/util\/Util.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"added"}]}