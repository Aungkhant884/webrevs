{"files":[{"patch":"@@ -168,0 +168,12 @@\n+  \/\/ Notifies this compiler that the current thread (`current`) is about to stop.\n+  \/\/ The current thread currently holds the CompileThread_lock.\n+  virtual void stopping_compiler_thread(CompilerThread* current) {\n+    \/\/ Do nothing\n+  }\n+\n+  \/\/ Notifies this compiler that queue is empty just prior to waiting on\n+  \/\/ MethodCompileQueue_lock which is held by the current thread (`thread`).\n+  virtual void on_empty_queue(CompileQueue* queue, CompilerThread* thread) {\n+    \/\/ Do nothing\n+  }\n+\n","filename":"src\/hotspot\/share\/compiler\/abstractCompiler.hpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -425,1 +425,1 @@\n-CompileTask* CompileQueue::get() {\n+CompileTask* CompileQueue::get(CompilerThread* thread) {\n@@ -443,0 +443,4 @@\n+    AbstractCompiler *compiler = thread->compiler();\n+    guarantee(compiler != nullptr, \"Compiler object must exist\");\n+    compiler->on_empty_queue(this, thread);\n+\n@@ -1935,1 +1939,1 @@\n-    CompileTask* task = queue->get();\n+    CompileTask* task = queue->get(thread);\n@@ -1945,0 +1949,4 @@\n+\n+          \/\/ Notify compiler that the compiler thread is about to stop\n+          thread->compiler()->stopping_compiler_thread(thread);\n+\n@@ -2253,0 +2261,3 @@\n+    if (runtime != nullptr) {\n+      runtime->post_compile(thread);\n+    }\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.cpp","additions":13,"deletions":2,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -111,1 +111,1 @@\n-  CompileTask* get();\n+  CompileTask* get(CompilerThread* thread);\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,2 +40,3 @@\n-JVMCIRuntime* JVMCI::_compiler_runtime = NULL;\n-JVMCIRuntime* JVMCI::_java_runtime = NULL;\n+JVMCIRuntime* JVMCI::_compiler_runtimes = nullptr;\n+JVMCIRuntime* JVMCI::_java_runtime = nullptr;\n+JVMCIRuntime* JVMCI::_shutdown_compiler_runtime = nullptr;\n@@ -44,2 +45,2 @@\n-void* JVMCI::_shared_library_handle = NULL;\n-char* JVMCI::_shared_library_path = NULL;\n+void* JVMCI::_shared_library_handle = nullptr;\n+char* JVMCI::_shared_library_path = nullptr;\n@@ -47,2 +48,2 @@\n-StringEventLog* JVMCI::_events = NULL;\n-StringEventLog* JVMCI::_verbose_events = NULL;\n+StringEventLog* JVMCI::_events = nullptr;\n+StringEventLog* JVMCI::_verbose_events = nullptr;\n@@ -51,1 +52,1 @@\n-const char* JVMCI::_fatal_log_filename = NULL;\n+const char* JVMCI::_fatal_log_filename = nullptr;\n@@ -73,1 +74,1 @@\n-  assert(JVMCI_lock->owner() == Thread::current(), \"must be\");\n+  MutexLocker locker(JVMCI_lock);\n@@ -106,2 +107,7 @@\n-\n-  JVMCI::compiler_runtime()->call_getCompiler(CHECK);\n+  JVMCIRuntime* runtime;\n+  if (UseJVMCINativeLibrary) {\n+      runtime = JVMCI::compiler_runtime((JavaThread*) THREAD);\n+  } else {\n+      runtime = JVMCI::java_runtime();\n+  }\n+  runtime->call_getCompiler(CHECK);\n@@ -125,7 +131,3 @@\n-  if (UseJVMCINativeLibrary) {\n-    \/\/ There are two runtimes.\n-    _compiler_runtime = new JVMCIRuntime(0);\n-    _java_runtime = new JVMCIRuntime(-1);\n-  } else {\n-    \/\/ There is only a single runtime\n-    _java_runtime = _compiler_runtime = new JVMCIRuntime(0);\n+  _java_runtime = new JVMCIRuntime(nullptr, -1, false);\n+  if (using_singleton_shared_library_runtime()) {\n+    JVMCI::_compiler_runtimes = new JVMCIRuntime(nullptr, 0, true);\n@@ -161,0 +163,10 @@\n+JVMCIRuntime* JVMCI::compiler_runtime(JavaThread* thread, bool create) {\n+  assert(thread->is_Java_thread(), \"must be\") ;\n+  assert(UseJVMCINativeLibrary, \"must be\");\n+  JVMCIRuntime* runtime = thread->libjvmci_runtime();\n+  if (runtime == nullptr && create) {\n+    runtime = JVMCIRuntime::for_thread(thread);\n+  }\n+  return runtime;\n+}\n+\n@@ -175,1 +187,1 @@\n-  if (_java_runtime != NULL) {\n+  if (_java_runtime != nullptr) {\n@@ -178,2 +190,5 @@\n-  if (_compiler_runtime != NULL && _compiler_runtime != _java_runtime) {\n-    _compiler_runtime->_metadata_handles->metadata_do(f);\n+  for (JVMCIRuntime* runtime = _compiler_runtimes; runtime != nullptr; runtime = runtime->_next) {\n+    runtime->_metadata_handles->metadata_do(f);\n+  }\n+  if (_shutdown_compiler_runtime != nullptr) {\n+    _shutdown_compiler_runtime->_metadata_handles->metadata_do(f);\n@@ -185,1 +200,1 @@\n-    if (_java_runtime != NULL) {\n+    if (_java_runtime != nullptr) {\n@@ -188,2 +203,5 @@\n-    if (_compiler_runtime != NULL && _compiler_runtime != _java_runtime) {\n-      _compiler_runtime->_metadata_handles->do_unloading();\n+    for (JVMCIRuntime* runtime = _compiler_runtimes; runtime != nullptr; runtime = runtime->_next) {\n+     runtime->_metadata_handles->do_unloading();\n+    }\n+    if (_shutdown_compiler_runtime != nullptr) {\n+      _shutdown_compiler_runtime->_metadata_handles->do_unloading();\n@@ -198,1 +216,38 @@\n-void JVMCI::shutdown() {\n+void JVMCI::vlog(int level, const char* format, va_list ap) {\n+  if (LogEvents && JVMCIEventLogLevel >= level) {\n+    StringEventLog* events = level == 1 ? _events : _verbose_events;\n+    guarantee(events != nullptr, \"JVMCI event log not yet initialized\");\n+    Thread* thread = Thread::current_or_null_safe();\n+    if (thread != nullptr) {\n+      events->logv(thread, format, ap);\n+    }\n+  }\n+}\n+\n+void JVMCI::vtrace(int level, const char* format, va_list ap) {\n+  if (JVMCITraceLevel >= level) {\n+    Thread* thread = Thread::current_or_null_safe();\n+    if (thread != nullptr) {\n+      ResourceMark rm;\n+      tty->print(\"JVMCITrace-%d[%s]:%*c\", level, thread->name(), level, ' ');\n+    } else {\n+      tty->print(\"JVMCITrace-%d[?]:%*c\", level, level, ' ');\n+    }\n+    tty->vprint_cr(format, ap);\n+  }\n+}\n+\n+#define LOG_TRACE(level) { va_list ap; \\\n+  va_start(ap, format); vlog(level, format, ap); va_end(ap); \\\n+  va_start(ap, format); vtrace(level, format, ap); va_end(ap); \\\n+}\n+\n+void JVMCI::event(int level, const char* format, ...) LOG_TRACE(level)\n+void JVMCI::event1(const char* format, ...) LOG_TRACE(1)\n+void JVMCI::event2(const char* format, ...) LOG_TRACE(2)\n+void JVMCI::event3(const char* format, ...) LOG_TRACE(3)\n+void JVMCI::event4(const char* format, ...) LOG_TRACE(4)\n+\n+#undef LOG_TRACE\n+\n+void JVMCI::shutdown(JavaThread* thread) {\n@@ -206,1 +261,1 @@\n-  if (java_runtime != compiler_runtime()) {\n+  if (java_runtime != nullptr) {\n@@ -209,2 +264,20 @@\n-  if (compiler_runtime() != NULL) {\n-    compiler_runtime()->shutdown();\n+  JVMCIRuntime *runtime = thread->libjvmci_runtime();\n+  if (runtime != nullptr) {\n+    runtime->detach_thread(thread, \"JVMCI shutdown\");\n+  }\n+  {\n+    \/\/ Attach to JVMCI initialized runtimes that are not already shutting down\n+    \/\/ and shut them down. This ensures HotSpotJVMCIRuntime.shutdown() is called\n+    \/\/ for each JVMCI runtime.\n+    MutexLocker locker(JVMCI_lock);\n+    for (JVMCIRuntime* rt = JVMCI::_compiler_runtimes; rt != nullptr; rt = rt->_next) {\n+      if (rt->is_HotSpotJVMCIRuntime_initialized() && rt->_num_attached_threads != JVMCIRuntime::cannot_be_attached) {\n+        rt->_num_attached_threads++;\n+        {\n+          MutexUnlocker unlocker(JVMCI_lock);\n+          rt->attach_thread(thread);\n+          rt->shutdown();\n+          rt->detach_thread(thread, \"JVMCI shutdown\");\n+        }\n+      }\n+    }\n@@ -256,37 +329,0 @@\n-\n-void JVMCI::vlog(int level, const char* format, va_list ap) {\n-  if (LogEvents && JVMCIEventLogLevel >= level) {\n-    StringEventLog* events = level == 1 ? _events : _verbose_events;\n-    guarantee(events != NULL, \"JVMCI event log not yet initialized\");\n-    Thread* thread = Thread::current_or_null_safe();\n-    if (thread != NULL) {\n-      events->logv(thread, format, ap);\n-    }\n-  }\n-}\n-\n-void JVMCI::vtrace(int level, const char* format, va_list ap) {\n-  if (JVMCITraceLevel >= level) {\n-    Thread* thread = Thread::current_or_null_safe();\n-    if (thread != NULL) {\n-      ResourceMark rm;\n-      tty->print(\"JVMCITrace-%d[%s]:%*c\", level, thread->name(), level, ' ');\n-    } else {\n-      tty->print(\"JVMCITrace-%d[?]:%*c\", level, level, ' ');\n-    }\n-    tty->vprint_cr(format, ap);\n-  }\n-}\n-\n-#define LOG_TRACE(level) { va_list ap; \\\n-  va_start(ap, format); vlog(level, format, ap); va_end(ap); \\\n-  va_start(ap, format); vtrace(level, format, ap); va_end(ap); \\\n-}\n-\n-void JVMCI::event(int level, const char* format, ...) LOG_TRACE(level)\n-void JVMCI::event1(const char* format, ...) LOG_TRACE(1)\n-void JVMCI::event2(const char* format, ...) LOG_TRACE(2)\n-void JVMCI::event3(const char* format, ...) LOG_TRACE(3)\n-void JVMCI::event4(const char* format, ...) LOG_TRACE(4)\n-\n-#undef LOG_TRACE\n","filename":"src\/hotspot\/share\/jvmci\/jvmci.cpp","additions":100,"deletions":64,"binary":false,"changes":164,"status":"modified"},{"patch":"@@ -54,2 +54,9 @@\n-  \/\/ Access to the HotSpotJVMCIRuntime used by the CompileBroker.\n-  static JVMCIRuntime* _compiler_runtime;\n+  \/\/ List of libjvmci based JVMCIRuntimes.\n+  \/\/ Should only be accessed under JVMCI_lock.\n+  static JVMCIRuntime* _compiler_runtimes;\n+\n+  \/\/ Special libjvmci based JVMCIRuntime reserved for\n+  \/\/ threads trying to attach when in JVMCI shutdown.\n+  \/\/ This preserves the invariant that JVMCIRuntime::for_thread()\n+  \/\/ never returns nullptr.\n+  static JVMCIRuntime* _shutdown_compiler_runtime;\n@@ -98,0 +105,1 @@\n+\n@@ -107,0 +115,10 @@\n+  \/\/ Returns true iff JVMCIThreadsPerNativeLibraryRuntime == 0.\n+  static bool using_singleton_shared_library_runtime() {\n+    return JVMCIThreadsPerNativeLibraryRuntime == 0;\n+  }\n+\n+  \/\/ Returns true iff there is a new shared library JavaVM per compilation.\n+  static bool one_shared_library_javavm_per_compilation() {\n+    return JVMCIThreadsPerNativeLibraryRuntime == 1 && JVMCICompilerIdleDelay == 0;\n+  }\n+\n@@ -109,2 +127,1 @@\n-  \/\/ which the library is loaded is returned in `path`. If\n-  \/\/ `load` is true then JVMCI_lock must be locked.\n+  \/\/ which the library is loaded is returned in `path`.\n@@ -124,1 +141,1 @@\n-  static void shutdown();\n+  static void shutdown(JavaThread* thread);\n@@ -148,1 +165,0 @@\n-  static JVMCIRuntime* compiler_runtime() { return _compiler_runtime; }\n@@ -153,0 +169,6 @@\n+  \/\/ Gets the JVMCI shared library runtime associated with `thread`.\n+  \/\/ This must only be called when UseJVMCINativeLibrary is true.\n+  \/\/ If `create` is true and there is no runtime currently associated with\n+  \/\/ `thread`, this method creates one.\n+  static JVMCIRuntime* compiler_runtime(JavaThread* thread, bool create=true);\n+\n","filename":"src\/hotspot\/share\/jvmci\/jvmci.hpp","additions":28,"deletions":6,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -156,0 +156,30 @@\n+void JVMCICompiler::stopping_compiler_thread(CompilerThread* current) {\n+  if (UseJVMCINativeLibrary) {\n+    JVMCIRuntime* runtime = JVMCI::compiler_runtime(current, false);\n+    if (runtime != nullptr) {\n+      MutexUnlocker unlock(CompileThread_lock);\n+      runtime->detach_thread(current, \"stopping idle compiler thread\");\n+    }\n+  }\n+}\n+\n+void JVMCICompiler::on_empty_queue(CompileQueue* queue, CompilerThread* thread) {\n+  if (UseJVMCINativeLibrary) {\n+    int delay = JVMCICompilerIdleDelay;\n+    JVMCIRuntime* runtime = JVMCI::compiler_runtime(thread, false);\n+    \/\/ Don't detach JVMCI compiler threads from their JVMCI\n+    \/\/ runtime during the VM startup grace period\n+    if (runtime != nullptr && delay > 0 && tty->time_stamp().milliseconds() > DEFAULT_COMPILER_IDLE_DELAY) {\n+      bool timeout = MethodCompileQueue_lock->wait(delay);\n+      \/\/ Unlock as detaching or repacking can result in a JNI call to shutdown a JavaVM\n+      \/\/ and locks cannot be held when making a VM to native transition.\n+      MutexUnlocker unlock(MethodCompileQueue_lock);\n+      if (timeout) {\n+        runtime->detach_thread(thread, \"releasing idle compiler thread\");\n+      } else {\n+        runtime->repack(thread);\n+      }\n+    }\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompiler.cpp","additions":30,"deletions":0,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -97,0 +97,4 @@\n+  virtual void stopping_compiler_thread(CompilerThread* current);\n+\n+  virtual void on_empty_queue(CompileQueue* queue, CompilerThread* thread);\n+\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompiler.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1025,1 +1025,0 @@\n-    \/\/ FIXME: Why was this long before?\n@@ -2074,1 +2073,1 @@\n-  return JVMCIENV->resolve_handle(xHandle) == JVMCIENV->resolve_handle(yHandle);\n+  return JVMCIENV->resolve_oop_handle(xHandle) == JVMCIENV->resolve_oop_handle(yHandle);\n@@ -2164,4 +2163,3 @@\n-C2V_VMENTRY(void, deleteGlobalHandle, (JNIEnv* env, jobject, jlong h))\n-  jobject handle = (jobject)(address)h;\n-  if (handle != NULL) {\n-    JVMCIENV->runtime()->destroy_global(handle);\n+C2V_VMENTRY(void, deleteGlobalHandle, (JNIEnv* env, jobject, jlong handle))\n+  if (handle != 0) {\n+    JVMCIENV->runtime()->destroy_oop_handle(handle);\n@@ -2182,1 +2180,1 @@\n-  JVMCIRuntime* runtime = JVMCI::compiler_runtime();\n+  JVMCIRuntime* runtime;\n@@ -2188,1 +2186,1 @@\n-    JVMCIObject receiver = runtime->get_HotSpotJVMCIRuntime(peerEnv);\n+    runtime = JVMCI::compiler_runtime(thread);\n@@ -2263,1 +2261,1 @@\n-  if (thread == NULL) {\n+  if (thread == nullptr || thread->libjvmci_runtime() == nullptr) {\n@@ -2271,2 +2269,2 @@\n-    JVMCIRuntime* runtime = JVMCI::compiler_runtime();\n-    if (runtime == NULL || !runtime->has_shared_library_javavm()) {\n+    JVMCIRuntime *runtime = thread->libjvmci_runtime();\n+    if (runtime == nullptr || !runtime->has_shared_library_javavm()) {\n@@ -2290,7 +2288,36 @@\n-C2V_VMENTRY_PREFIX(jboolean, attachCurrentThread, (JNIEnv* env, jobject c2vm, jbyteArray name, jboolean as_daemon))\n-  if (thread == NULL) {\n-    \/\/ Called from unattached JVMCI shared library thread\n-    guarantee(name != NULL, \"libjvmci caller must pass non-null name\");\n-\n-    extern struct JavaVM_ main_vm;\n-    JNIEnv* hotspotEnv;\n+\/\/ Attaches a thread started in a JVMCI shared library to a JavaThread and JVMCI runtime.\n+static void attachSharedLibraryThread(JNIEnv* env, jbyteArray name, jboolean as_daemon) {\n+  JavaVM* javaVM = nullptr;\n+  jint res = env->GetJavaVM(&javaVM);\n+  if (res != JNI_OK) {\n+    JNI_THROW(\"attachSharedLibraryThread\", InternalError, err_msg(\"Error getting shared library JavaVM from shared library JNIEnv: %d\", res));\n+  }\n+  extern struct JavaVM_ main_vm;\n+  JNIEnv* hotspotEnv;\n+\n+  int name_len = env->GetArrayLength(name);\n+  char name_buf[64]; \/\/ Cannot use Resource heap as it requires a current thread\n+  int to_copy = MIN2(name_len, (int) sizeof(name_buf) - 1);\n+  env->GetByteArrayRegion(name, 0, to_copy, (jbyte*) name_buf);\n+  name_buf[to_copy] = '\\0';\n+  JavaVMAttachArgs attach_args;\n+  attach_args.version = JNI_VERSION_1_2;\n+  attach_args.name = name_buf;\n+  attach_args.group = nullptr;\n+  res = as_daemon ? main_vm.AttachCurrentThreadAsDaemon((void**)&hotspotEnv, &attach_args) :\n+                    main_vm.AttachCurrentThread((void**)&hotspotEnv, &attach_args);\n+  if (res != JNI_OK) {\n+    JNI_THROW(\"attachSharedLibraryThread\", InternalError, err_msg(\"Trying to attach thread returned %d\", res));\n+  }\n+  JavaThread* thread = get_current_thread(false);\n+  const char* attach_error;\n+  {\n+    \/\/ Transition to VM\n+    JVMCI_VM_ENTRY_MARK\n+    attach_error = JVMCIRuntime::attach_shared_library_thread(thread, javaVM);\n+    \/\/ Transition back to Native\n+  }\n+  if (attach_error != nullptr) {\n+    JNI_THROW(\"attachCurrentThread\", InternalError, attach_error);\n+  }\n+}\n@@ -2298,14 +2325,3 @@\n-    int name_len = env->GetArrayLength(name);\n-    char name_buf[64]; \/\/ Cannot use Resource heap as it requires a current thread\n-    int to_copy = MIN2(name_len, (int) sizeof(name_buf) - 1);\n-    env->GetByteArrayRegion(name, 0, to_copy, (jbyte*) name_buf);\n-    name_buf[to_copy] = '\\0';\n-    JavaVMAttachArgs attach_args;\n-    attach_args.version = JNI_VERSION_1_2;\n-    attach_args.name = name_buf;\n-    attach_args.group = NULL;\n-    jint res = as_daemon ? main_vm.AttachCurrentThreadAsDaemon((void**) &hotspotEnv, &attach_args) :\n-                           main_vm.AttachCurrentThread((void**) &hotspotEnv, &attach_args);\n-    if (res != JNI_OK) {\n-      JNI_THROW_(\"attachCurrentThread\", InternalError, err_msg(\"Trying to attach thread returned %d\", res), false);\n-    }\n+C2V_VMENTRY_PREFIX(jboolean, attachCurrentThread, (JNIEnv* env, jobject c2vm, jbyteArray name, jboolean as_daemon, jlongArray javaVM_info))\n+  if (thread == nullptr) {\n+    attachSharedLibraryThread(env, name, as_daemon);\n@@ -2319,3 +2335,24 @@\n-    JVMCIRuntime* runtime = JVMCI::compiler_runtime();\n-    if (runtime == NULL || !runtime->has_shared_library_javavm()) {\n-        JVMCI_THROW_MSG_0(IllegalStateException, \"Require JVMCI shared library JavaVM to be initialized in attachCurrentThread\");\n+\n+    JVMCIRuntime* runtime = JVMCI::compiler_runtime(thread);\n+    JNIEnv* peerJNIEnv;\n+    if (runtime->has_shared_library_javavm()) {\n+      if (runtime->GetEnv(thread, (void**)&peerJNIEnv, JNI_VERSION_1_2) == JNI_OK) {\n+        \/\/ Already attached\n+        runtime->init_JavaVM_info(javaVM_info, JVMCI_CHECK_0);\n+        return false;\n+      }\n+    }\n+\n+    {\n+      \/\/ Ensure the JVMCI shared library runtime is initialized.\n+      JVMCIEnv __peer_jvmci_env__(thread, false, __FILE__, __LINE__);\n+      JVMCIEnv* peerJVMCIEnv = &__peer_jvmci_env__;\n+      HandleMark hm(thread);\n+      JVMCIObject receiver = runtime->get_HotSpotJVMCIRuntime(peerJVMCIEnv);\n+      if (peerJVMCIEnv->has_pending_exception()) {\n+        peerJVMCIEnv->describe_pending_exception(true);\n+      }\n+      char* sl_path;\n+      if (JVMCI::get_shared_library(sl_path, false) == nullptr) {\n+        JVMCI_THROW_MSG_0(InternalError, \"Error initializing JVMCI runtime\");\n+      }\n@@ -2327,5 +2364,1 @@\n-    attach_args.group = NULL;\n-    JNIEnv* peerJNIEnv;\n-    if (runtime->GetEnv(thread, (void**) &peerJNIEnv, JNI_VERSION_1_2) == JNI_OK) {\n-      return false;\n-    }\n+    attach_args.group = nullptr;\n@@ -2336,2 +2369,3 @@\n-      guarantee(peerJNIEnv != NULL, \"must be\");\n-      JVMCI_event_1(\"attached to JavaVM for JVMCI runtime %d\", runtime->id());\n+      guarantee(peerJNIEnv != nullptr, \"must be\");\n+      runtime->init_JavaVM_info(javaVM_info, JVMCI_CHECK_0);\n+      JVMCI_event_1(\"attached to JavaVM[%d] for JVMCI runtime %d\", runtime->get_shared_library_javavm_id(), runtime->id());\n@@ -2346,2 +2380,2 @@\n-C2V_VMENTRY_PREFIX(void, detachCurrentThread, (JNIEnv* env, jobject c2vm))\n-  if (thread == NULL) {\n+C2V_VMENTRY_PREFIX(jboolean, detachCurrentThread, (JNIEnv* env, jobject c2vm, jboolean release))\n+  if (thread == nullptr) {\n@@ -2349,1 +2383,1 @@\n-    JNI_THROW(\"detachCurrentThread\", IllegalStateException, \"Cannot detach non-attached thread\");\n+    JNI_THROW_(\"detachCurrentThread\", IllegalStateException, \"Cannot detach non-attached thread\", false);\n@@ -2355,5 +2389,5 @@\n-    requireJVMCINativeLibrary(JVMCI_CHECK);\n-    requireInHotSpot(\"detachCurrentThread\", JVMCI_CHECK);\n-    JVMCIRuntime* runtime = JVMCI::compiler_runtime();\n-    if (runtime == NULL || !runtime->has_shared_library_javavm()) {\n-      JVMCI_THROW_MSG(IllegalStateException, \"Require JVMCI shared library JavaVM to be initialized in detachCurrentThread\");\n+    requireJVMCINativeLibrary(JVMCI_CHECK_0);\n+    requireInHotSpot(\"detachCurrentThread\", JVMCI_CHECK_0);\n+    JVMCIRuntime *runtime = thread->libjvmci_runtime();\n+    if (runtime == nullptr || !runtime->has_shared_library_javavm()) {\n+      JVMCI_THROW_MSG_0(IllegalStateException, \"Require JVMCI shared library JavaVM to be initialized in detachCurrentThread\");\n@@ -2361,3 +2395,4 @@\n-    JNIEnv* peerJNIEnv;\n-    if (runtime->GetEnv(thread, (void**) &peerJNIEnv, JNI_VERSION_1_2) != JNI_OK) {\n-      JVMCI_THROW_MSG(IllegalStateException, err_msg(\"Cannot detach non-attached thread: %s\", thread->name()));\n+    JNIEnv* peerEnv;\n+\n+    if (runtime->GetEnv(thread, (void**) &peerEnv, JNI_VERSION_1_2) != JNI_OK) {\n+      JVMCI_THROW_MSG_0(IllegalStateException, err_msg(\"Cannot detach non-attached thread: %s\", thread->name()));\n@@ -2367,1 +2402,6 @@\n-      JVMCI_THROW_MSG(InternalError, err_msg(\"Error %d while attaching %s\", res, thread->name()));\n+      JVMCI_THROW_MSG_0(InternalError, err_msg(\"Error %d while attaching %s\", res, thread->name()));\n+    }\n+    JVMCI_event_1(\"detached from JavaVM[%d] for JVMCI runtime %d\",\n+        runtime->get_shared_library_javavm_id(), runtime->id());\n+    if (release) {\n+      return runtime->detach_thread(thread, \"user thread detach\");\n@@ -2371,0 +2411,15 @@\n+    if (release) {\n+      JNI_THROW_(\"detachCurrentThread\", InternalError, \"JVMCI shared library thread cannot release JVMCI shared library JavaVM\", false);\n+    }\n+    JVMCIRuntime *runtime = thread->libjvmci_runtime();\n+    if (runtime == nullptr) {\n+      JNI_THROW_(\"detachCurrentThread\", InternalError, \"JVMCI shared library thread should have a JVMCI runtime\", false);\n+    }\n+    {\n+      \/\/ Transition to VM\n+      C2V_BLOCK(jboolean, detachCurrentThread, (JNIEnv* env, jobject))\n+      \/\/ Cannot destroy shared library JavaVM as we're about to return to it.\n+      runtime->detach_thread(thread, \"shared library thread detach\", false);\n+      JVMCI_event_1(\"detaching JVMCI shared library thread from HotSpot JavaVM\");\n+      \/\/ Transition back to Native\n+    }\n@@ -2374,1 +2429,1 @@\n-      JNI_THROW(\"detachCurrentThread\", InternalError, \"Cannot detach non-attached thread\");\n+      JNI_THROW_(\"detachCurrentThread\", InternalError, \"Cannot detach non-attached thread\", false);\n@@ -2377,0 +2432,1 @@\n+  return false;\n@@ -2471,1 +2527,1 @@\n-  JVMCIObject global_handle_obj = JVMCIENV->wrap((jobject) obj_handle);\n+  JVMCIObject global_handle_obj = JVMCIENV->wrap(global_handle);\n@@ -2800,2 +2856,2 @@\n-  {CC \"attachCurrentThread\",                          CC \"([BZ)Z\",                                                                          FN_PTR(attachCurrentThread)},\n-  {CC \"detachCurrentThread\",                          CC \"()V\",                                                                             FN_PTR(detachCurrentThread)},\n+  {CC \"attachCurrentThread\",                          CC \"([BZ[J)Z\",                                                                        FN_PTR(attachCurrentThread)},\n+  {CC \"detachCurrentThread\",                          CC \"(Z)Z\",                                                                            FN_PTR(detachCurrentThread)},\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":114,"deletions":58,"binary":false,"changes":172,"status":"modified"},{"patch":"@@ -179,1 +179,1 @@\n-    _runtime = JVMCI::compiler_runtime();\n+    _runtime = thread->libjvmci_runtime();\n@@ -189,1 +189,1 @@\n-  _runtime = JVMCI::compiler_runtime();\n+  _runtime = JVMCI::compiler_runtime(thread);\n@@ -1386,1 +1386,1 @@\n-    jlong handle = make_handle(obj);\n+    jlong handle = make_oop_handle(obj);\n@@ -1410,1 +1410,1 @@\n-    oop result = resolve_handle(object_handle);\n+    oop result = resolve_oop_handle(object_handle);\n@@ -1424,1 +1424,1 @@\n-jlong JVMCIEnv::make_handle(const Handle& obj) {\n+jlong JVMCIEnv::make_oop_handle(const Handle& obj) {\n@@ -1426,2 +1426,1 @@\n-  jobject handle = _runtime->make_global(obj);\n-  return (jlong) handle;\n+  return _runtime->make_oop_handle(obj);\n@@ -1430,3 +1429,3 @@\n-oop JVMCIEnv::resolve_handle(jlong objectHandle) {\n-  assert(objectHandle != 0, \"should be a valid handle\");\n-  oop obj = *((oopDesc**)objectHandle);\n+oop JVMCIEnv::resolve_oop_handle(jlong oopHandle) {\n+  assert(oopHandle != 0, \"should be a valid handle\");\n+  oop obj = *((oopDesc**) oopHandle);\n","filename":"src\/hotspot\/share\/jvmci\/jvmciEnv.cpp","additions":9,"deletions":10,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -395,2 +395,5 @@\n-  jlong make_handle(const Handle& obj);\n-  oop resolve_handle(jlong objectHandle);\n+  \/\/ Makes a handle to a HotSpot heap object. These handles are\n+  \/\/ individually reclaimed by JVMCIRuntime::destroy_oop_handle and\n+  \/\/ bulk reclaimed by JVMCIRuntime::release_and_clear_globals.\n+  jlong make_oop_handle(const Handle& obj);\n+  oop resolve_oop_handle(jlong oopHandle);\n","filename":"src\/hotspot\/share\/jvmci\/jvmciEnv.hpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -83,6 +83,12 @@\n-  dest_offset = fd.offset();\n-  assert(dest_offset != 0, \"must be valid offset\");\n-  if (static_field) {\n-    \/\/ Must ensure classes for static fields are initialized as the\n-    \/\/ accessor itself does not include a class initialization check.\n-    ik->initialize(CHECK);\n+  assert(fd.offset() != 0, \"must be valid offset\");\n+  if (dest_offset != fd.offset()) {\n+    if (dest_offset != 0) {\n+      fatal(\"offset for %s %s.%s re-initialized: %d -> %d\", signature, ik->external_name(), name, dest_offset, fd.offset());\n+    }\n+    dest_offset = fd.offset();\n+    if (static_field) {\n+      \/\/ Must ensure classes for static fields are initialized as the\n+      \/\/ accessor itself does not include a class initialization check.\n+      ik->initialize(CHECK);\n+    }\n+    JVMCI_event_2(\"   field offset for %s %s.%s = %d\", signature, ik->external_name(), name, dest_offset);\n@@ -90,1 +96,0 @@\n-  JVMCI_event_2(\"   field offset for %s %s.%s = %d\", signature, ik->external_name(), name, dest_offset);\n@@ -123,1 +128,1 @@\n-#define START_CLASS(className, fullClassName)                          { \\\n+#define START_CLASS(className, fullClassName)                          {                 \\\n@@ -125,3 +130,10 @@\n-  className::_klass = InstanceKlass::cast(k);                                     \\\n-  JVMCI_event_2(\" klass for %s = \" PTR_FORMAT, k->external_name(), p2i(k));       \\\n-  className::_klass->initialize(CHECK);\n+  InstanceKlass* current = className::_klass;                                            \\\n+  if (current != InstanceKlass::cast(k)) {                                               \\\n+    if (current != nullptr) {                                                            \\\n+      fatal(\"klass for %s re-initialized: \" PTR_FORMAT \" -> \" PTR_FORMAT,                \\\n+          k->external_name(), p2i(current), p2i(k));                                     \\\n+    }                                                                                    \\\n+    JVMCI_event_2(\" klass for %s = \" PTR_FORMAT, k->external_name(), p2i(k));            \\\n+    className::_klass = InstanceKlass::cast(k);                                          \\\n+    className::_klass->initialize(CHECK);                                                \\\n+  }\n@@ -303,1 +315,10 @@\n-  JVMCI_event_2(\"   jfieldID for %s %s.%s = \" PTR_FORMAT, signature, class_name, name, p2i(fieldid));\n+  \/\/ SVM guarantees that jfieldIDs for fields in the native image are also\n+  \/\/ in the image and thus always have the same address.\n+  if (current != fieldid) {\n+    if (current != nullptr) {\n+      fatal(\"jfieldID for %s %s.%s re-initialized: \" PTR_FORMAT \" -> \" PTR_FORMAT,\n+         signature, class_name, name, p2i(current), p2i(fieldid));\n+    }\n+    JVMCI_event_2(\"   jfieldID for %s %s.%s = \" PTR_FORMAT, signature, class_name, name, p2i(fieldid));\n+  }\n+\n@@ -315,1 +336,1 @@\n-  if (JVMCILibDumpJNIConfig != NULL) {                                                      \\\n+  if (JVMCILibDumpJNIConfig != nullptr) {                                                   \\\n@@ -321,1 +342,1 @@\n-    assert(k != NULL, #fullClassName \" not initialized\");                                   \\\n+    assert(k != nullptr, #fullClassName \" not initialized\");                                \\\n@@ -323,2 +344,12 @@\n-    JVMCI_event_2(\" jclass for %s = \" PTR_FORMAT, current_class_name, p2i(k));              \\\n-    className::_class = k;                                                                  \\\n+    jclass current = className::_class;                                                     \\\n+    if (current != k) {                                                                     \\\n+      JVMCI_event_2(\" jclass for %s = \" PTR_FORMAT, current_class_name, p2i(k));            \\\n+      \/* SVM guarantees that jclass handles to classes in a native image are also *\/        \\\n+      \/* in the image. Further calling NewGlobalRef on such a handle returns a stable *\/    \\\n+      \/* values across all JavaVMs executing on the same native image. *\/                   \\\n+      if (current != nullptr) {                                                             \\\n+           fatal(\"jclass for %s re-initialized: \" PTR_FORMAT \" -> \" PTR_FORMAT,             \\\n+           current_class_name, p2i(current), p2i(k));                                       \\\n+      }                                                                                     \\\n+      className::_class = k;                                                                \\\n+    }                                                                                       \\\n@@ -341,1 +372,1 @@\n-    if (JVMCILibDumpJNIConfig != NULL) {                                                       \\\n+    if (JVMCILibDumpJNIConfig != nullptr) {                                                    \\\n@@ -347,5 +378,13 @@\n-      JVMCI_EXCEPTION_CHECK(env, #jniGetMethod \"(%s.%s%s)\",                                    \\\n-                  current_class_name, methodName, signature);                                  \\\n-      assert(dst != NULL, \"uninitialized\");                                                    \\\n-      JVMCI_event_2(\"   jmethodID for %s.%s%s = \" PTR_FORMAT,                                  \\\n-                  current_class_name, methodName, signature, p2i(dst));                        \\\n+      assert(dst != nullptr, \"uninitialized\");                                                 \\\n+      if (current != dst) {                                                                    \\\n+        JVMCI_event_2(\"   jmethodID for %s.%s%s = \" PTR_FORMAT,                                \\\n+                    current_class_name, methodName, signature, p2i(dst));                      \\\n+        \/* SVM guarantees that jmethodIDs for methods in the native image are also *\/          \\\n+        \/* in the image and thus always have the same address. *\/                              \\\n+        if (current != nullptr) {                                                              \\\n+          fatal(\"jmethod for %s.%s%s re-initialized: \" PTR_FORMAT \" -> \" PTR_FORMAT,           \\\n+                        current_class_name, methodName, signature, p2i(current), p2i(dst));    \\\n+        }                                                                                      \\\n+        JVMCI_EXCEPTION_CHECK(env, #jniGetMethod \"(%s.%s%s)\",                                  \\\n+                            current_class_name, methodName, signature);                        \\\n+      }                                                                                        \\\n","filename":"src\/hotspot\/share\/jvmci\/jvmciJavaClasses.cpp","additions":61,"deletions":22,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -53,0 +53,1 @@\n+#include \"runtime\/mutex.hpp\"\n@@ -830,8 +831,0 @@\n-JVMCIRuntime::JVMCIRuntime(int id) {\n-  _init_state = uninitialized;\n-  _shared_library_javavm = NULL;\n-  _id = id;\n-  _metadata_handles = new MetadataHandles();\n-  JVMCI_event_1(\"created new JVMCI runtime %d (\" PTR_FORMAT \")\", id, p2i(this));\n-}\n-\n@@ -843,1 +836,1 @@\n-jobject JVMCIRuntime::make_global(const Handle& obj) {\n+jlong JVMCIRuntime::make_oop_handle(const Handle& obj) {\n@@ -847,3 +840,3 @@\n-  jobject res = NULL;\n-  if (ptr != NULL) {\n-    assert(*ptr == NULL, \"invariant\");\n+  jlong res = 0;\n+  if (ptr != nullptr) {\n+    assert(*ptr == nullptr, \"invariant\");\n@@ -851,1 +844,1 @@\n-    res = reinterpret_cast<jobject>(ptr);\n+    res = (jlong) ptr;\n@@ -856,1 +849,2 @@\n-  MutexLocker ml(JVMCI_lock);\n+  MutexLocker ml(_lock);\n+  _oop_handles.append(ptr);\n@@ -860,1 +854,57 @@\n-void JVMCIRuntime::destroy_global(jobject handle) {\n+bool JVMCIRuntime::probe_oop_handle(jlong handle, int index) {\n+  oop* key = (oop*) handle;\n+  if (key == _oop_handles.at(index)) {\n+    _last_found_oop_handle_index = index;\n+    return true;\n+  }\n+  return false;\n+}\n+\n+int JVMCIRuntime::find_oop_handle(jlong handle) {\n+  int len = _oop_handles.length();\n+  int next = _last_found_oop_handle_index + 1;\n+  int prev = MAX2(_last_found_oop_handle_index, 0) - 1;\n+\n+  \/\/ Search \"outwards\" from the index of the last found\n+  \/\/ entry. Experimentation shows that this significantly\n+  \/\/ reduces the amount of searching performed.\n+  do {\n+    if (next < len) {\n+      if (probe_oop_handle(handle, next)) {\n+        return next;\n+      }\n+      next++;\n+    }\n+    if (prev >= 0) {\n+      if (probe_oop_handle(handle, prev)) {\n+        return prev;\n+      }\n+      prev--;\n+    }\n+  } while (next - (prev + 1) < len);\n+  return -1;\n+}\n+\n+int JVMCIRuntime::release_and_clear_globals() {\n+  int released = 0;\n+  if (_oop_handles.length() != 0) {\n+    \/\/ Collect non-null JNI handles into an array for\n+    \/\/ the bulk release operation\n+    ResourceMark rm;\n+    oop** ptrs = NEW_RESOURCE_ARRAY(oop*, _oop_handles.length());\n+    for (int i = 0; i < _oop_handles.length(); i++) {\n+      oop* oop_ptr = _oop_handles.at(i);\n+      if (oop_ptr != nullptr) {\n+        ptrs[released++] = oop_ptr;\n+        NativeAccess<>::oop_store(oop_ptr, (oop) nullptr);\n+      }\n+    }\n+    \/\/ Do the bulk release\n+    object_handles()->release(ptrs, released);\n+  }\n+  _oop_handles.clear();\n+  _last_found_oop_handle_index = -1;\n+  return released;\n+}\n+\n+void JVMCIRuntime::destroy_oop_handle(jlong handle) {\n@@ -862,3 +912,3 @@\n-  assert(is_global_handle(handle), \"precondition\");\n-  oop* oop_ptr = reinterpret_cast<oop*>(handle);\n-  NativeAccess<>::oop_store(oop_ptr, (oop)NULL);\n+  assert(is_oop_handle(handle), \"precondition\");\n+  oop* oop_ptr = (oop*) handle;\n+  NativeAccess<>::oop_store(oop_ptr, (oop) nullptr);\n@@ -866,1 +916,5 @@\n-  MutexLocker ml(JVMCI_lock);\n+\n+  MutexLocker ml(_lock);\n+  int index = find_oop_handle(handle);\n+  guarantee(index != -1, \"global not allocated in JVMCI runtime %d: \" INTPTR_FORMAT, id(), handle);\n+  _oop_handles.at_put(index, nullptr);\n@@ -869,2 +923,2 @@\n-bool JVMCIRuntime::is_global_handle(jobject handle) {\n-  const oop* ptr = reinterpret_cast<oop*>(handle);\n+bool JVMCIRuntime::is_oop_handle(jlong handle) {\n+  const oop* ptr = (oop*) handle;\n@@ -875,1 +929,1 @@\n-  MutexLocker ml(JVMCI_lock);\n+  MutexLocker ml(_lock);\n@@ -880,1 +934,1 @@\n-  MutexLocker ml(JVMCI_lock);\n+  MutexLocker ml(_lock);\n@@ -885,1 +939,1 @@\n-  MutexLocker ml(JVMCI_lock);\n+  MutexLocker ml(_lock);\n@@ -907,0 +961,9 @@\n+  Thread* thread = Thread::current_or_null_safe();\n+  if (thread != nullptr && thread->is_Java_thread()) {\n+    JavaThread* jthread = (JavaThread*) thread;\n+    JVMCIRuntime* runtime = jthread->libjvmci_runtime();\n+    if (runtime != nullptr) {\n+      int javaVM_id = runtime->get_shared_library_javavm_id();\n+      fatal(\"Fatal error in JVMCI shared library JavaVM[%d] owned by JVMCI runtime %d\", javaVM_id, runtime->id());\n+    }\n+  }\n@@ -911,3 +974,101 @@\n-JNIEnv* JVMCIRuntime::init_shared_library_javavm() {\n-  JavaVM* javaVM = (JavaVM*) _shared_library_javavm;\n-  if (javaVM == NULL) {\n+JVMCIRuntime::JVMCIRuntime(JVMCIRuntime* next, int id, bool for_compile_broker) :\n+  _init_state(uninitialized),\n+  _shared_library_javavm(nullptr),\n+  _shared_library_javavm_id(0),\n+  _id(id),\n+  _next(next),\n+  _metadata_handles(new MetadataHandles()),\n+  _oop_handles(100, mtJVMCI),\n+  _num_attached_threads(0),\n+  _for_compile_broker(for_compile_broker),\n+  _last_found_oop_handle_index(-1)\n+{\n+  if (id == -1) {\n+    _lock = JVMCIRuntime_lock;\n+  } else {\n+    stringStream lock_name;\n+    lock_name.print(\"%s@%d\", JVMCIRuntime_lock->name(), id);\n+    Mutex::Rank lock_rank = DEBUG_ONLY(JVMCIRuntime_lock->rank()) NOT_DEBUG(Mutex::safepoint);\n+    _lock = new PaddedMonitor(lock_rank, lock_name.as_string(\/*c_heap*\/true));\n+  }\n+  JVMCI_event_1(\"created new %s JVMCI runtime %d (\" PTR_FORMAT \")\",\n+      id == -1 ? \"Java\" : for_compile_broker ? \"CompileBroker\" : \"Compiler\", id, p2i(this));\n+}\n+\n+JVMCIRuntime* JVMCIRuntime::select_runtime_in_shutdown(JavaThread* thread) {\n+  assert(JVMCI_lock->owner() == thread, \"must be\");\n+  \/\/ When shutting down, use the first available runtime.\n+  for (JVMCIRuntime* runtime = JVMCI::_compiler_runtimes; runtime != nullptr; runtime = runtime->_next) {\n+    if (runtime->_num_attached_threads != cannot_be_attached) {\n+      runtime->pre_attach_thread(thread);\n+      JVMCI_event_1(\"using pre-existing JVMCI runtime %d in shutdown\", runtime->id());\n+      return runtime;\n+    }\n+  }\n+  \/\/ Lazily initialize JVMCI::_shutdown_compiler_runtime. Safe to\n+  \/\/ do here since JVMCI_lock is locked.\n+  if (JVMCI::_shutdown_compiler_runtime == nullptr) {\n+    JVMCI::_shutdown_compiler_runtime = new JVMCIRuntime(nullptr, -2, true);\n+  }\n+  JVMCIRuntime* runtime = JVMCI::_shutdown_compiler_runtime;\n+  JVMCI_event_1(\"using reserved shutdown JVMCI runtime %d\", runtime->id());\n+  return runtime;\n+}\n+\n+JVMCIRuntime* JVMCIRuntime::select_runtime(JavaThread* thread, JVMCIRuntime* skip, int* count) {\n+  assert(JVMCI_lock->owner() == thread, \"must be\");\n+  bool for_compile_broker = thread->is_Compiler_thread();\n+  for (JVMCIRuntime* runtime = JVMCI::_compiler_runtimes; runtime != nullptr; runtime = runtime->_next) {\n+    if (count != nullptr) {\n+      (*count)++;\n+    }\n+    if (for_compile_broker == runtime->_for_compile_broker) {\n+      int count = runtime->_num_attached_threads;\n+      if (count == cannot_be_attached || runtime == skip) {\n+        \/\/ Cannot attach to rt\n+        continue;\n+      }\n+      \/\/ If selecting for repacking, ignore a runtime without an existing JavaVM\n+      if (skip != nullptr && !runtime->has_shared_library_javavm()) {\n+        continue;\n+      }\n+\n+      \/\/ Select first runtime with sufficient capacity\n+      if (count < (int) JVMCIThreadsPerNativeLibraryRuntime) {\n+        runtime->pre_attach_thread(thread);\n+        return runtime;\n+      }\n+    }\n+  }\n+  return nullptr;\n+}\n+\n+JVMCIRuntime* JVMCIRuntime::select_or_create_runtime(JavaThread* thread) {\n+  assert(JVMCI_lock->owner() == thread, \"must be\");\n+  int id = 0;\n+  JVMCIRuntime* runtime;\n+  if (JVMCI::using_singleton_shared_library_runtime()) {\n+    runtime = JVMCI::_compiler_runtimes;\n+    guarantee(runtime != nullptr, \"must be\");\n+    while (runtime->_num_attached_threads == cannot_be_attached) {\n+      \/\/ Since there is only a singleton JVMCIRuntime, we\n+      \/\/ need to wait for it to be available for attaching.\n+      JVMCI_lock->wait();\n+    }\n+    runtime->pre_attach_thread(thread);\n+  } else {\n+    runtime = select_runtime(thread, nullptr, &id);\n+  }\n+  if (runtime == nullptr) {\n+    runtime = new JVMCIRuntime(JVMCI::_compiler_runtimes, id, thread->is_Compiler_thread());\n+    JVMCI::_compiler_runtimes = runtime;\n+    runtime->pre_attach_thread(thread);\n+  }\n+  return runtime;\n+}\n+\n+JVMCIRuntime* JVMCIRuntime::for_thread(JavaThread* thread) {\n+  assert(thread->libjvmci_runtime() == nullptr, \"must be\");\n+  \/\/ Find the runtime with fewest attached threads\n+  JVMCIRuntime* runtime = nullptr;\n+  {\n@@ -915,4 +1076,16 @@\n-    \/\/ Check again under JVMCI_lock\n-    javaVM = (JavaVM*) _shared_library_javavm;\n-    if (javaVM != NULL) {\n-      return NULL;\n+    runtime = JVMCI::in_shutdown() ? select_runtime_in_shutdown(thread) : select_or_create_runtime(thread);\n+  }\n+  runtime->attach_thread(thread);\n+  return runtime;\n+}\n+\n+const char* JVMCIRuntime::attach_shared_library_thread(JavaThread* thread, JavaVM* javaVM) {\n+  MutexLocker locker(JVMCI_lock);\n+  for (JVMCIRuntime* runtime = JVMCI::_compiler_runtimes; runtime != nullptr; runtime = runtime->_next) {\n+    if (runtime->_shared_library_javavm == javaVM) {\n+      if (runtime->_num_attached_threads == cannot_be_attached) {\n+        return \"Cannot attach to JVMCI runtime that is shutting down\";\n+      }\n+      runtime->pre_attach_thread(thread);\n+      runtime->attach_thread(thread);\n+      return nullptr;\n@@ -920,0 +1093,101 @@\n+  }\n+  return \"Cannot find JVMCI runtime\";\n+}\n+\n+void JVMCIRuntime::pre_attach_thread(JavaThread* thread) {\n+  assert(JVMCI_lock->owner() == thread, \"must be\");\n+  _num_attached_threads++;\n+}\n+\n+void JVMCIRuntime::attach_thread(JavaThread* thread) {\n+  assert(thread->libjvmci_runtime() == nullptr, \"must be\");\n+  thread->set_libjvmci_runtime(this);\n+  guarantee(this == JVMCI::_shutdown_compiler_runtime ||\n+            _num_attached_threads > 0,\n+            \"missing reservation in JVMCI runtime %d: _num_attached_threads=%d\", _id, _num_attached_threads);\n+  JVMCI_event_1(\"attached to JVMCI runtime %d%s\", _id, JVMCI::in_shutdown() ? \" [in JVMCI shutdown]\" : \"\");\n+}\n+\n+void JVMCIRuntime::repack(JavaThread* thread) {\n+  JVMCIRuntime* new_runtime = nullptr;\n+  {\n+    MutexLocker locker(JVMCI_lock);\n+    if (JVMCI::using_singleton_shared_library_runtime() || _num_attached_threads != 1 || JVMCI::in_shutdown()) {\n+      return;\n+    }\n+    new_runtime = select_runtime(thread, this, nullptr);\n+  }\n+  if (new_runtime != nullptr) {\n+    JVMCI_event_1(\"Moving thread from JVMCI runtime %d to JVMCI runtime %d (%d attached)\", _id, new_runtime->_id, new_runtime->_num_attached_threads - 1);\n+    detach_thread(thread, \"moving thread to another JVMCI runtime\");\n+    new_runtime->attach_thread(thread);\n+  }\n+}\n+\n+bool JVMCIRuntime::detach_thread(JavaThread* thread, const char* reason, bool can_destroy_javavm) {\n+  if (this == JVMCI::_shutdown_compiler_runtime || JVMCI::in_shutdown()) {\n+    \/\/ Do minimal work when shutting down JVMCI\n+    thread->set_libjvmci_runtime(nullptr);\n+    return false;\n+  }\n+  bool should_shutdown;\n+  bool destroyed_javavm = false;\n+  {\n+    MutexLocker locker(JVMCI_lock);\n+    _num_attached_threads--;\n+    JVMCI_event_1(\"detaching from JVMCI runtime %d: %s (%d other threads still attached)\", _id, reason, _num_attached_threads);\n+    should_shutdown = _num_attached_threads == 0 && !JVMCI::in_shutdown();\n+    if (should_shutdown && !can_destroy_javavm) {\n+      \/\/ If it's not possible to destroy the JavaVM on this thread then the VM must\n+      \/\/ not be shutdown. This can happen when a shared library thread is the last\n+      \/\/ thread to detach from a shared library JavaVM (e.g. GraalServiceThread).\n+      JVMCI_event_1(\"Cancelled shut down of JVMCI runtime %d\", _id);\n+      should_shutdown = false;\n+    }\n+    if (should_shutdown) {\n+      \/\/ Prevent other threads from attaching to this runtime\n+      \/\/ while it is shutting down and destroying its JavaVM\n+      _num_attached_threads = cannot_be_attached;\n+    }\n+  }\n+  if (should_shutdown) {\n+    \/\/ Release the JavaVM resources associated with this\n+    \/\/ runtime once there are no threads attached to it.\n+    shutdown();\n+    if (can_destroy_javavm) {\n+      destroyed_javavm = destroy_shared_library_javavm();\n+      if (destroyed_javavm) {\n+        \/\/ Can release all handles now that there's no code executing\n+        \/\/ that could be using them. Handles for the Java JVMCI runtime\n+        \/\/ are never released as we cannot guarantee all compiler threads\n+        \/\/ using it have been stopped.\n+        int released = release_and_clear_globals();\n+        JVMCI_event_1(\"releasing handles for JVMCI runtime %d: oop handles=%d, metadata handles={total=%d, live=%d, blocks=%d}\",\n+            _id,\n+            released,\n+            _metadata_handles->num_handles(),\n+            _metadata_handles->num_handles() - _metadata_handles->num_free_handles(),\n+            _metadata_handles->num_blocks());\n+\n+        \/\/ No need to acquire _lock since this is the only thread accessing this runtime\n+        _metadata_handles->clear();\n+      }\n+    }\n+    \/\/ Allow other threads to attach to this runtime now\n+    MutexLocker locker(JVMCI_lock);\n+    _num_attached_threads = 0;\n+    if (JVMCI::using_singleton_shared_library_runtime()) {\n+      \/\/ Notify any thread waiting to attach to the\n+      \/\/ singleton JVMCIRuntime\n+      JVMCI_lock->notify();\n+    }\n+  }\n+  thread->set_libjvmci_runtime(nullptr);\n+  JVMCI_event_1(\"detached from JVMCI runtime %d\", _id);\n+  return destroyed_javavm;\n+}\n+\n+JNIEnv* JVMCIRuntime::init_shared_library_javavm() {\n+  MutexLocker locker(_lock);\n+  JavaVM* javaVM = _shared_library_javavm;\n+  if (javaVM == nullptr) {\n@@ -927,1 +1201,1 @@\n-    if (JNI_CreateJavaVM == NULL) {\n+    if (JNI_CreateJavaVM == nullptr) {\n@@ -957,1 +1231,1 @@\n-    JNIEnv* env = NULL;\n+    JNIEnv* env = nullptr;\n@@ -960,1 +1234,2 @@\n-      guarantee(env != NULL, \"missing env\");\n+      guarantee(env != nullptr, \"missing env\");\n+      _shared_library_javavm_id = javaVM_id;\n@@ -968,1 +1243,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -972,1 +1247,1 @@\n-  if (info != NULL) {\n+  if (info != nullptr) {\n@@ -977,1 +1252,1 @@\n-    JavaVM* javaVM = (JavaVM*) _shared_library_javavm;\n+    JavaVM* javaVM = _shared_library_javavm;\n@@ -986,1 +1261,1 @@\n-  guarantee(thread != NULL && _shared_library_javavm != NULL, \"npe\"); \\\n+  guarantee(thread != nullptr && _shared_library_javavm != nullptr, \"npe\"); \\\n@@ -988,1 +1263,1 @@\n-  JavaVM* javavm = (JavaVM*) _shared_library_javavm;\n+  JavaVM* javavm = _shared_library_javavm;\n@@ -1030,0 +1305,43 @@\n+JVMCIRuntime::InitState JVMCIRuntime::_shared_library_javavm_refs_init_state = JVMCIRuntime::uninitialized;\n+JVMCIRuntime::InitState JVMCIRuntime::_hotspot_javavm_refs_init_state = JVMCIRuntime::uninitialized;\n+\n+class JavaVMRefsInitialization: public StackObj {\n+  JVMCIRuntime::InitState *_state;\n+  int _id;\n+ public:\n+  JavaVMRefsInitialization(JVMCIRuntime::InitState *state, int id) {\n+    _state = state;\n+    _id = id;\n+    \/\/ All classes, methods and fields in the JVMCI shared library\n+    \/\/ are in the read-only part of the image. As such, these\n+    \/\/ values (and any global handle derived from them via NewGlobalRef)\n+    \/\/ are the same for all JavaVM instances created in the\n+    \/\/ shared library which means they only need to be initialized\n+    \/\/ once. In non-product mode, we check this invariant.\n+    \/\/ See com.oracle.svm.jni.JNIImageHeapHandles.\n+    \/\/ The same is true for Klass* and field offsets in HotSpotJVMCI.\n+    if (*state == JVMCIRuntime::uninitialized DEBUG_ONLY( || true)) {\n+      *state = JVMCIRuntime::being_initialized;\n+      JVMCI_event_1(\"initializing JavaVM references in JVMCI runtime %d\", id);\n+    } else {\n+      while (*state != JVMCIRuntime::fully_initialized) {\n+        JVMCI_event_1(\"waiting for JavaVM references initialization in JVMCI runtime %d\", id);\n+        JVMCI_lock->wait();\n+      }\n+      JVMCI_event_1(\"done waiting for JavaVM references initialization in JVMCI runtime %d\", id);\n+    }\n+  }\n+\n+  ~JavaVMRefsInitialization() {\n+    if (*_state == JVMCIRuntime::being_initialized) {\n+      *_state = JVMCIRuntime::fully_initialized;\n+      JVMCI_event_1(\"initialized JavaVM references in JVMCI runtime %d\", _id);\n+      JVMCI_lock->notify_all();\n+    }\n+  }\n+\n+  bool should_init() {\n+    return *_state == JVMCIRuntime::being_initialized;\n+  }\n+};\n+\n@@ -1031,1 +1349,1 @@\n-  \/\/ Check first without JVMCI_lock\n+  \/\/ Check first without _lock\n@@ -1036,2 +1354,2 @@\n-  MutexLocker locker(JVMCI_lock);\n-  \/\/ Check again under JVMCI_lock\n+  MutexLocker locker(_lock);\n+  \/\/ Check again under _lock\n@@ -1044,1 +1362,1 @@\n-    JVMCI_lock->wait();\n+    _lock->wait();\n@@ -1055,1 +1373,1 @@\n-    MutexUnlocker unlock(JVMCI_lock);\n+    MutexUnlocker unlock(_lock);\n@@ -1057,1 +1375,1 @@\n-    JavaThread* THREAD = JavaThread::current(); \/\/ For exception macros.\n+    JavaThread* THREAD = JavaThread::current();\n@@ -1060,9 +1378,21 @@\n-    if (JVMCIENV->is_hotspot()) {\n-      HotSpotJVMCI::compute_offsets(CHECK_EXIT);\n-    } else {\n-      JNIAccessMark jni(JVMCIENV);\n-\n-      JNIJVMCI::initialize_ids(jni.env());\n-      if (jni()->ExceptionCheck()) {\n-        jni()->ExceptionDescribe();\n-        fatal(\"JNI exception during init\");\n+    {\n+      MutexLocker lock_jvmci(JVMCI_lock);\n+      if (JVMCIENV->is_hotspot()) {\n+        JavaVMRefsInitialization initialization(&_hotspot_javavm_refs_init_state, _id);\n+        if (initialization.should_init()) {\n+          MutexUnlocker unlock_jvmci(JVMCI_lock);\n+          HotSpotJVMCI::compute_offsets(CHECK_EXIT);\n+        }\n+      } else {\n+        JavaVMRefsInitialization initialization(&_shared_library_javavm_refs_init_state, _id);\n+        if (initialization.should_init()) {\n+          MutexUnlocker unlock_jvmci(JVMCI_lock);\n+          JNIAccessMark jni(JVMCIENV, THREAD);\n+\n+          JNIJVMCI::initialize_ids(jni.env());\n+          if (jni()->ExceptionCheck()) {\n+            jni()->ExceptionDescribe();\n+            fatal(\"JNI exception during init\");\n+          }\n+          \/\/ _lock is re-locked at this point\n+        }\n@@ -1093,1 +1423,1 @@\n-  JVMCI_lock->notify_all();\n+  _lock->notify_all();\n@@ -1125,0 +1455,1 @@\n+    guarantee(_HotSpotJVMCIRuntime_instance.is_non_null(), \"NPE in JVMCI runtime %d\", _id);\n@@ -1175,1 +1506,38 @@\n-    JVMCI_event_1(\"shut down HotSpotJVMCIRuntime for JVMCI runtime %d\", _id);\n+    if (_num_attached_threads == cannot_be_attached) {\n+      \/\/ Only when no other threads are attached to this runtime\n+      \/\/ is it safe to reset these fields.\n+      _HotSpotJVMCIRuntime_instance = JVMCIObject();\n+      _init_state = uninitialized;\n+      JVMCI_event_1(\"shut down JVMCI runtime %d\", _id);\n+    }\n+  }\n+}\n+\n+bool JVMCIRuntime::destroy_shared_library_javavm() {\n+  guarantee(_num_attached_threads == cannot_be_attached,\n+      \"cannot destroy JavaVM for JVMCI runtime %d with %d attached threads\", _id, _num_attached_threads);\n+  JavaVM* javaVM;\n+  int javaVM_id = _shared_library_javavm_id;\n+  {\n+    \/\/ Exactly one thread can destroy the JavaVM\n+    \/\/ and release the handle to it.\n+    MutexLocker only_one(_lock);\n+    javaVM = _shared_library_javavm;\n+    if (javaVM != nullptr) {\n+      _shared_library_javavm = nullptr;\n+      _shared_library_javavm_id = 0;\n+    }\n+  }\n+  if (javaVM != nullptr) {\n+    int result;\n+    {\n+      \/\/ Must transition into native before calling into libjvmci\n+      ThreadToNativeFromVM ttnfv(JavaThread::current());\n+      result = javaVM->DestroyJavaVM();\n+    }\n+    if (result == JNI_OK) {\n+      JVMCI_event_1(\"destroyed JavaVM[%d]@\" PTR_FORMAT \" for JVMCI runtime %d\", javaVM_id, p2i(javaVM), _id);\n+    } else {\n+      warning(\"Non-zero result (%d) when calling JNI_DestroyJavaVM on JavaVM[%d]@\" PTR_FORMAT, result, javaVM_id, p2i(javaVM));\n+    }\n+    return true;\n@@ -1177,0 +1545,1 @@\n+  return false;\n@@ -1590,0 +1959,6 @@\n+    if (UseJVMCINativeLibrary) {\n+      JVMCIRuntime *runtime = JVMCI::compiler_runtime(thread, false);\n+      if (runtime != nullptr) {\n+        runtime->detach_thread(thread, \"JVMCI shutdown pre-empted compilation\");\n+      }\n+    }\n@@ -1619,1 +1994,1 @@\n-        if (compile_state->task()->code() == NULL) {\n+        if (compile_state->task()->code() == nullptr) {\n@@ -1842,0 +2217,10 @@\n+\n+void JVMCIRuntime::post_compile(JavaThread* thread) {\n+  if (UseJVMCINativeLibrary && JVMCI::one_shared_library_javavm_per_compilation()) {\n+    if (thread->libjvmci_runtime() != nullptr) {\n+      detach_thread(thread, \"single use JavaVM\");\n+    } else {\n+      \/\/ JVMCI shutdown may have already detached the thread\n+    }\n+  }\n+}\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.cpp","additions":442,"deletions":57,"binary":false,"changes":499,"status":"modified"},{"patch":"@@ -106,0 +106,1 @@\n+  friend class JavaVMRefsInitialization;\n@@ -127,0 +128,8 @@\n+  \/\/ Initialization state of the references to classes, methods\n+  \/\/ and fields in the JVMCI shared library.\n+  static InitState _shared_library_javavm_refs_init_state;\n+\n+  \/\/ Initialization state of the references to classes, methods\n+  \/\/ and fields in HotSpot metadata.\n+  static InitState _hotspot_javavm_refs_init_state;\n+\n@@ -134,0 +143,5 @@\n+  \/\/ Lock for operations that may be performed by\n+  \/\/ any thread attached this runtime. To avoid deadlock,\n+  \/\/ this lock must always be acquired before JVMCI_lock.\n+  Monitor* _lock;\n+\n@@ -135,2 +149,2 @@\n-  \/\/ Must only be modified under JVMCI_lock.\n-  volatile JavaVM* _shared_library_javavm;\n+  \/\/ Must only be mutated under _lock.\n+  JavaVM* _shared_library_javavm;\n@@ -138,0 +152,4 @@\n+  \/\/ Id for _shared_library_javavm.\n+  int _shared_library_javavm_id;\n+\n+  \/\/ Position and link in global list of JVMCI shared library runtimes.\n@@ -139,1 +157,2 @@\n-  \/\/ JVMCI shared library runtime will have an id of 0.\n+  \/\/ runtime reserved for threads attaching during JVMCI shutdown\n+  \/\/ will have an id of -2.\n@@ -141,0 +160,1 @@\n+  JVMCIRuntime* _next;\n@@ -145,0 +165,18 @@\n+  \/\/ List of oop handles allocated via make_oop_handle. This is to support\n+  \/\/ destroying remaining oop handles when the JavaVM associated\n+  \/\/ with this runtime is shutdown.\n+  GrowableArray<oop*> _oop_handles;\n+\n+  \/\/ Number of threads attached or about to be attached to this runtime.\n+  \/\/ Must only be mutated under JVMCI_lock to facilitate safely moving\n+  \/\/ threads between JVMCI runtimes. A value of -1 implies this runtime is\n+  \/\/ not available to be attached to another thread because it is in the\n+  \/\/ process of shutting down and destroying its JavaVM.\n+  int _num_attached_threads;\n+  static const int cannot_be_attached = -1;\n+\n+  \/\/ Is this runtime for threads managed by the CompileBroker?\n+  \/\/ Examples of non-CompileBroker threads are CompileTheWorld threads\n+  \/\/ or Truffle compilation threads.\n+  bool _for_compile_broker;\n+\n@@ -171,0 +209,29 @@\n+  \/\/ Helpers for `for_thread`.\n+\n+  \/\/ Selects an existing runtime (except for `skip`) that has\n+  \/\/ fewer than JVMCI::max_threads_per_runtime() attached threads.\n+  \/\/ If such a runtime exists, its _num_attached_threads is incremented\n+  \/\/ and the caller must subsequently attach `thread` to it.\n+  \/\/ JVMCI_lock must be held by current thread.\n+  \/\/ If nullptr is returned, then `*count` contains the number of JVMCIRuntimes\n+  \/\/ currently allocated.\n+  static JVMCIRuntime* select_runtime(JavaThread* thread, JVMCIRuntime* skip, int* count);\n+\n+  \/\/ Selects an existing runtime for `thread` or creates a new one if\n+  \/\/ no applicable runtime exists.\n+  \/\/ JVMCI_lock must be held by current thread\n+  static JVMCIRuntime* select_or_create_runtime(JavaThread* thread);\n+\n+  \/\/ Selects an existing runtime for `thread` when in JVMCI shutdown.\n+  \/\/ JVMCI_lock must be held by current thread\n+  static JVMCIRuntime* select_runtime_in_shutdown(JavaThread* thread);\n+\n+  \/\/ Helpers for destroy_oop_handle\n+  int _last_found_oop_handle_index;\n+  bool probe_oop_handle(jlong handle, int index);\n+  int find_oop_handle(jlong handle);\n+\n+  \/\/ Releases all the non-null entries in _oop_handles and then clears\n+  \/\/ the list. Returns the number of non-null entries prior to clearing.\n+  int release_and_clear_globals();\n+\n@@ -172,1 +239,1 @@\n-  JVMCIRuntime(int id);\n+  JVMCIRuntime(JVMCIRuntime* next, int id, bool for_compile_broker);\n@@ -175,0 +242,1 @@\n+  Monitor* lock() const { return _lock; }\n@@ -178,1 +246,1 @@\n-  \/\/ interface pointer for the JavaVM is returned otherwise NULL is returned.\n+  \/\/ interface pointer for the JavaVM is returned otherwise nullptr is returned.\n@@ -182,1 +250,4 @@\n-  bool has_shared_library_javavm() { return _shared_library_javavm != NULL; }\n+  bool has_shared_library_javavm() { return _shared_library_javavm != nullptr; }\n+\n+  \/\/ Gets an ID for the JVMCI shared library JavaVM associated with this runtime.\n+  int get_shared_library_javavm_id() { return _shared_library_javavm_id; }\n@@ -205,2 +276,2 @@\n-  \/\/ Allocation and management of JNI global object handles\n-  \/\/ whose lifetime is scoped by this JVMCIRuntime. The lifetime\n+  \/\/ Allocation and management of handles to HotSpot heap objects\n+  \/\/ whose lifetime is scoped by this JVMCIRuntime. The max lifetime\n@@ -209,1 +280,1 @@\n-  \/\/ used when creating a IndirectHotSpotObjectConstantImpl in the\n+  \/\/ used when creating an IndirectHotSpotObjectConstantImpl in the\n@@ -211,3 +282,5 @@\n-  jobject make_global(const Handle& obj);\n-  void destroy_global(jobject handle);\n-  bool is_global_handle(jobject handle);\n+  jlong make_oop_handle(const Handle& obj);\n+  bool is_oop_handle(jlong handle);\n+\n+  \/\/ Called from IndirectHotSpotObjectConstantImpl.clear(Object)\n+  void destroy_oop_handle(jlong handle);\n@@ -220,0 +293,30 @@\n+  \/\/ Finds a JVMCI runtime for `thread`. A new JVMCI runtime is created if\n+  \/\/ there are none currently available with JVMCI::max_threads_per_runtime()\n+  \/\/ or fewer attached threads.\n+  static JVMCIRuntime* for_thread(JavaThread* thread);\n+\n+  \/\/ Finds the JVMCI runtime owning `javavm` and attaches `thread` to it.\n+  \/\/ Returns an error message if attaching fails.\n+  static const char* attach_shared_library_thread(JavaThread* thread, JavaVM* javaVM);\n+\n+  \/\/ Reserves a slot in this runtime for `thread` to prevent it being\n+  \/\/ shutdown before `thread` is attached. JVMCI_lock must be held\n+  \/\/ and the caller must call `attach_thread` upon releasing it.\n+  void pre_attach_thread(JavaThread* thread);\n+\n+  \/\/ Attaches `thread` to this runtime.\n+  void attach_thread(JavaThread* thread);\n+\n+  \/\/ Detaches `thread` from this runtime.\n+  \/\/ Returns whether DestroyJavaVM was called on the JavaVM associated\n+  \/\/ with this runtime as a result of detaching.\n+  \/\/ The `can_destroy_javavm` is false when in the scope of\n+  \/\/ a down call from the JVMCI shared library JavaVM. Since the scope\n+  \/\/ will return to the shared library JavaVM, the JavaVM must not be destroyed.\n+  bool detach_thread(JavaThread* thread, const char* reason, bool can_destroy_javavm=true);\n+\n+  \/\/ If `thread` is the last thread attached to this runtime,\n+  \/\/ move it to another runtime with an existing JavaVM and available capacity\n+  \/\/ if possible, thus allowing this runtime to release its JavaVM.\n+  void repack(JavaThread* thread);\n+\n@@ -243,0 +346,3 @@\n+  \/\/ If this is the last thread attached to this runtime, then\n+  \/\/ `_HotSpotJVMCIRuntime_instance` is set to nullptr and `_init_state`\n+  \/\/ to uninitialized.\n@@ -245,0 +351,4 @@\n+  \/\/ Destroys the JVMCI shared library JavaVM attached to this runtime.\n+  \/\/ Return true iff DestroyJavaVM was called on the JavaVM.\n+  bool destroy_shared_library_javavm();\n+\n@@ -314,0 +424,4 @@\n+  \/\/ Detach `thread` from this runtime and destroy this runtime's JavaVM\n+  \/\/ if using one JavaVM per JVMCI compilation .\n+  void post_compile(JavaThread* thread);\n+\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.hpp","additions":126,"deletions":12,"binary":false,"changes":138,"status":"modified"},{"patch":"@@ -115,11 +115,13 @@\n-  CHECK_NOT_SET(JVMCIEventLogLevel,           EnableJVMCI)\n-  CHECK_NOT_SET(JVMCITraceLevel,              EnableJVMCI)\n-  CHECK_NOT_SET(JVMCICounterSize,             EnableJVMCI)\n-  CHECK_NOT_SET(JVMCICountersExcludeCompiler, EnableJVMCI)\n-  CHECK_NOT_SET(JVMCIUseFastLocking,          EnableJVMCI)\n-  CHECK_NOT_SET(JVMCINMethodSizeLimit,        EnableJVMCI)\n-  CHECK_NOT_SET(JVMCIPrintProperties,         EnableJVMCI)\n-  CHECK_NOT_SET(UseJVMCINativeLibrary,        EnableJVMCI)\n-  CHECK_NOT_SET(JVMCILibPath,                 EnableJVMCI)\n-  CHECK_NOT_SET(JVMCINativeLibraryErrorFile,  EnableJVMCI)\n-  CHECK_NOT_SET(JVMCILibDumpJNIConfig,        EnableJVMCI)\n+  CHECK_NOT_SET(JVMCIEventLogLevel,                  EnableJVMCI)\n+  CHECK_NOT_SET(JVMCITraceLevel,                     EnableJVMCI)\n+  CHECK_NOT_SET(JVMCICounterSize,                    EnableJVMCI)\n+  CHECK_NOT_SET(JVMCICountersExcludeCompiler,        EnableJVMCI)\n+  CHECK_NOT_SET(JVMCIUseFastLocking,                 EnableJVMCI)\n+  CHECK_NOT_SET(JVMCINMethodSizeLimit,               EnableJVMCI)\n+  CHECK_NOT_SET(JVMCIPrintProperties,                EnableJVMCI)\n+  CHECK_NOT_SET(JVMCIThreadsPerNativeLibraryRuntime, EnableJVMCI)\n+  CHECK_NOT_SET(JVMCICompilerIdleDelay,              EnableJVMCI)\n+  CHECK_NOT_SET(UseJVMCINativeLibrary,               EnableJVMCI)\n+  CHECK_NOT_SET(JVMCILibPath,                        EnableJVMCI)\n+  CHECK_NOT_SET(JVMCINativeLibraryErrorFile,         EnableJVMCI)\n+  CHECK_NOT_SET(JVMCILibDumpJNIConfig,               EnableJVMCI)\n@@ -169,0 +171,2 @@\n+    \"JVMCIThreadsPerNativeLibraryRuntime\",\n+    \"JVMCICompilerIdleDelay\",\n","filename":"src\/hotspot\/share\/jvmci\/jvmci_globals.cpp","additions":15,"deletions":11,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#define DEFAULT_COMPILER_IDLE_DELAY 1000\n@@ -60,0 +61,13 @@\n+  product(uint, JVMCIThreadsPerNativeLibraryRuntime, 0, EXPERIMENTAL,       \\\n+          \"Max number of threads per JVMCI native runtime. \"                \\\n+          \"Specify 0 to force use of a single JVMCI native runtime. \")      \\\n+          range(0, max_jint)                                                \\\n+                                                                            \\\n+  product(uint, JVMCICompilerIdleDelay, DEFAULT_COMPILER_IDLE_DELAY, EXPERIMENTAL, \\\n+          \"Number of milliseconds a JVMCI compiler queue should wait for \"  \\\n+          \"a compilation task before being considered idle. When a JVMCI \"  \\\n+          \"compiler queue becomes idle, it is detached from its JVMCIRuntime. \"\\\n+          \"Once the last thread is detached from a JVMCIRuntime, all \"      \\\n+          \"all resources associated with the runtime are reclaimed.\")       \\\n+          range(0, max_jint)                                                \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/jvmci\/jvmci_globals.hpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -412,0 +412,1 @@\n+  declare_constant(JVM_ACC_IS_VALUE_BASED_CLASS)                          \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -434,1 +434,1 @@\n-    JVMCI::shutdown();\n+    JVMCI::shutdown(thread);\n","filename":"src\/hotspot\/share\/runtime\/java.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -159,0 +159,1 @@\n+Monitor* JVMCIRuntime_lock            = NULL;\n@@ -339,1 +340,2 @@\n-  def(JVMCI_lock                   , PaddedMonitor, safepoint, true);\n+  \/\/ JVMCIRuntime::_lock must be acquired before JVMCI_lock to avoid deadlock\n+  def(JVMCIRuntime_lock            , PaddedMonitor, safepoint, true);\n@@ -372,0 +374,4 @@\n+#if INCLUDE_JVMCI\n+  \/\/ JVMCIRuntime_lock must be acquired before JVMCI_lock to avoid deadlock\n+  defl(JVMCI_lock                  , PaddedMonitor, JVMCIRuntime_lock);\n+#endif\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.cpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -151,1 +151,2 @@\n-extern Monitor* JVMCI_lock;                      \/\/ Monitor to control initialization of JVMCI\n+extern Monitor* JVMCI_lock;                      \/\/ protects global JVMCI critical sections\n+extern Monitor* JVMCIRuntime_lock;               \/\/ protects critical sections for a specific JVMCIRuntime object\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1037,0 +1037,1 @@\n+  _libjvmci_runtime(nullptr),\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -83,0 +83,2 @@\n+class JVMCIRuntime;\n+\n@@ -943,0 +945,3 @@\n+  \/\/ The JVMCIRuntime in a JVMCI shared library\n+  JVMCIRuntime* _libjvmci_runtime;\n+\n@@ -1222,0 +1227,6 @@\n+\n+  JVMCIRuntime* libjvmci_runtime() const          { return _libjvmci_runtime; }\n+  void set_libjvmci_runtime(JVMCIRuntime* rt) {\n+    assert((_libjvmci_runtime == nullptr && rt != nullptr) || (_libjvmci_runtime != nullptr && rt == nullptr), \"must be\");\n+    _libjvmci_runtime = rt;\n+  }\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -938,1 +938,1 @@\n-    native boolean attachCurrentThread(byte[] name, boolean asDaemon);\n+    native boolean attachCurrentThread(byte[] name, boolean asDaemon, long[] javaVMInfo);\n@@ -941,1 +941,1 @@\n-     * @see HotSpotJVMCIRuntime#detachCurrentThread()\n+     * @see HotSpotJVMCIRuntime#detachCurrentThread\n@@ -943,1 +943,1 @@\n-    native void detachCurrentThread();\n+    native boolean detachCurrentThread(boolean release);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/CompilerToVM.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -251,2 +251,1 @@\n-     * Set of recognized {@code \"jvmci.*\"} system properties. Entries not associated with an\n-     * {@link Option} have this object as their value.\n+     * Set of recognized {@code \"jvmci.*\"} system properties.\n@@ -255,3 +254,0 @@\n-    static {\n-        options.put(\"jvmci.class.path.append\", options);\n-    }\n@@ -1345,0 +1341,2 @@\n+     * @param javaVMInfo if non-null, the JavaVM info as returned by {@link #registerNativeMethods}\n+     *            is returned in this array\n@@ -1354,1 +1352,1 @@\n-    public boolean attachCurrentThread(boolean asDaemon) {\n+    public boolean attachCurrentThread(boolean asDaemon, long[] javaVMInfo) {\n@@ -1356,1 +1354,1 @@\n-        return compilerToVm.attachCurrentThread(name, asDaemon);\n+        return compilerToVm.attachCurrentThread(name, asDaemon, javaVMInfo);\n@@ -1362,0 +1360,4 @@\n+     * @param release if {@code true} and this is the last thread attached to the peer runtime, the\n+     *            {@code JavaVM} associated with the peer runtime is destroyed if possible\n+     * @return {@code true} if the {@code JavaVM} associated with the peer runtime was destroyed as\n+     *         a result of this call\n@@ -1367,2 +1369,2 @@\n-    public void detachCurrentThread() {\n-        compilerToVm.detachCurrentThread();\n+    public boolean detachCurrentThread(boolean release) {\n+        return compilerToVm.detachCurrentThread(release);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HotSpotJVMCIRuntime.java","additions":11,"deletions":9,"binary":false,"changes":20,"status":"modified"}]}