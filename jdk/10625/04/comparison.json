{"files":[{"patch":"@@ -84,0 +84,2 @@\n+#define JLI_Snprintf            snprintf\n+\n@@ -91,1 +93,0 @@\n-int JLI_Snprintf(char *buffer, size_t size, const char *format, ...);\n@@ -101,1 +102,0 @@\n-#define JLI_Snprintf                    snprintf\n","filename":"src\/java.base\/share\/native\/libjli\/jli_util.h","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -478,32 +478,0 @@\n-\/*\n- * windows snprintf does not guarantee a null terminator in the buffer,\n- * if the computed size is equal to or greater than the buffer size,\n- * as well as error conditions. This function guarantees a null terminator\n- * under all these conditions. An unreasonable buffer or size will return\n- * an error value. Under all other conditions this function will return the\n- * size of the bytes actually written minus the null terminator, similar\n- * to ansi snprintf api. Thus when calling this function the caller must\n- * ensure storage for the null terminator.\n- *\/\n-int\n-JLI_Snprintf(char* buffer, size_t size, const char* format, ...) {\n-    int rc;\n-    va_list vl;\n-    if (size == 0 || buffer == NULL)\n-        return -1;\n-    buffer[0] = '\\0';\n-    va_start(vl, format);\n-    rc = vsnprintf(buffer, size, format, vl);\n-    va_end(vl);\n-    \/* force a null terminator, if something is amiss *\/\n-    if (rc < 0) {\n-        \/* apply ansi semantics *\/\n-        buffer[size - 1] = '\\0';\n-        return (int)size;\n-    } else if (rc == size) {\n-        \/* force a null terminator *\/\n-        buffer[size - 1] = '\\0';\n-    }\n-    return rc;\n-}\n-\n","filename":"src\/java.base\/windows\/native\/libjli\/java_md.c","additions":0,"deletions":32,"binary":false,"changes":32,"status":"modified"}]}