{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+import java.util.concurrent.CountDownLatch;\n@@ -76,1 +77,1 @@\n-        Thread thread = new hs201t002Thread();\n+        hs201t002Thread thread = new hs201t002Thread();\n@@ -81,1 +82,0 @@\n-        setThread(thread);\n@@ -84,0 +84,9 @@\n+        \/\/ enable events requires live thread\n+        try {\n+            thread.ready.await();\n+        } catch (InterruptedException e) {\n+        }\n+        setThread(thread);\n+\n+        thread.go.countDown();\n+\n@@ -117,0 +126,4 @@\n+            for (int i = 0; i < stackTrace.length; i++) {\n+                log.display(\"\\t\" + i + \". \" + stackTrace[i]);\n+            }\n+            log.display(\"Retrying...\");\n@@ -139,0 +152,3 @@\n+    CountDownLatch ready = new CountDownLatch(1);\n+    CountDownLatch go = new CountDownLatch(1);\n+\n@@ -145,0 +161,5 @@\n+        ready.countDown();\n+        try {\n+            go.await();\n+        } catch (InterruptedException e) {\n+        }\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/hotswap\/HS201\/hs201t002.java","additions":24,"deletions":3,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -74,2 +74,2 @@\n- *      -agentlib:hs201t002=pathToNewByteCode=.\/bin,-waittime=5\n- *      nsk.jvmti.scenarios.hotswap.HS201.hs201t002\n+ *      -agentlib:hs201t002=pathToNewByteCode=.\/bin,-waittime=5,-verbose\n+ *      nsk.jvmti.scenarios.hotswap.HS201.hs201t002 -verbose\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/hotswap\/HS201\/hs201t002\/TestDescription.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,3 +48,0 @@\n-static int redefineNumber;\n-static jint newClassSize;\n-static unsigned char* newClassBytes;\n@@ -53,1 +50,0 @@\n-char chbuffer[255];\n@@ -55,1 +51,1 @@\n-const char* getThreadName(JNIEnv* jni_env, jthread thread);\n+const char* getThreadName(jvmtiEnv* jvmti_env, JNIEnv* jni_env, jthread thread);\n@@ -57,1 +53,1 @@\n-int readNewBytecode(jvmtiEnv* jvmti);\n+int readNewBytecode(jvmtiEnv* jvmti, jint &newClassSize, unsigned char* &newClassBytes);\n@@ -102,1 +98,0 @@\n-\n@@ -104,0 +99,2 @@\n+    jint newClassSize;\n+    unsigned char* newClassBytes;\n@@ -110,1 +107,1 @@\n-    if (!NSK_VERIFY(readNewBytecode(jvmti_env))) {\n+    if (!NSK_VERIFY(readNewBytecode(jvmti_env, newClassSize, newClassBytes))) {\n@@ -113,0 +110,1 @@\n+        jvmti_env->Deallocate((unsigned char*)className);\n@@ -124,1 +122,0 @@\n-        return;\n@@ -130,0 +127,3 @@\n+    if (!NSK_JVMTI_VERIFY(jvmti_env->Deallocate(newClassBytes))) {\n+        nsk_jvmti_setFailStatus();\n+    }\n@@ -139,1 +139,0 @@\n-    redefineNumber = 1;\n@@ -147,1 +146,1 @@\n-    NSK_DISPLAY0(\"\\n\\n>>>> Debugge started, waiting for class loading \\n\");\n+    NSK_DISPLAY0(\">>>> Debugge started, waiting for class loading \\n\");\n@@ -186,1 +185,0 @@\n-    char *generic;\n@@ -188,1 +186,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti_env->GetClassSignature(klass, &className, &generic))) {\n+    if (!NSK_JVMTI_VERIFY(jvmti_env->GetClassSignature(klass, &className, NULL))) {\n@@ -194,2 +192,1 @@\n-        NSK_DISPLAY1(\"\\n\\n>>>> Class loaded: %s\", className);\n-        NSK_DISPLAY0(\", activating breakpoint\\n\");\n+        NSK_DISPLAY1(\">>>> Class loaded: %s, activating breakpoint\\n\", className);\n@@ -202,5 +199,0 @@\n-\n-    if (generic != NULL)\n-        if (!NSK_JVMTI_VERIFY(jvmti_env->Deallocate((unsigned char*)generic))) {\n-            nsk_jvmti_setFailStatus();\n-        }\n@@ -219,1 +211,1 @@\n-    NSK_DISPLAY0(\"\\n\\n>>>>Breakpoint fired, enabling SINGLE_STEP\\n\");\n+    NSK_DISPLAY0(\">>>>Breakpoint fired, enabling SINGLE_STEP\\n\");\n@@ -269,1 +261,1 @@\n-                NSK_DISPLAY1(\"\\n\\n>>>> Checking if redefined method is not obsolete\\n\", testStep);\n+                NSK_DISPLAY1(\">>>> Checking if redefined method is not obsolete\\n\", testStep);\n@@ -286,1 +278,1 @@\n-                NSK_DISPLAY1(\"\\n\\n>>>> Popping the currently executing frame\\n\", testStep);\n+                NSK_DISPLAY1(\">>>> Popping the currently executing frame\\n\", testStep);\n@@ -295,1 +287,1 @@\n-                    NSK_DISPLAY1(\"\\n\\n>>>> Disabling single step\\n\", testStep);\n+                    NSK_DISPLAY1(\">>>> Disabling single step\\n\", testStep);\n@@ -305,1 +297,1 @@\n-            NSK_COMPLAIN0(\"TEST FAILED: unable to deallocate memory pointed to method name\\n\\n\");\n+            NSK_COMPLAIN0(\"TEST FAILED: unable to deallocate memory pointed to declaringClassName\\n\\n\");\n@@ -331,1 +323,1 @@\n-    if (strcmp(EXPECTED_CLASS_SIGN, className) == 0) {\n+    if (className != NULL && strcmp(EXPECTED_CLASS_SIGN, className) == 0) {\n@@ -334,2 +326,7 @@\n-        NSK_DISPLAY2(\"\\n\\n>>>> Exception %s in thread - %s\\n\",\n-                        className, getThreadName(jni_env, thread));\n+        const char *threadName = getThreadName(jvmti_env, jni_env, thread);\n+        NSK_DISPLAY2(\">>>> Exception %s in thread - %s\\n\",\n+                        className, threadName != NULL ? threadName : \"NULL\");\n+        jvmti->Deallocate((unsigned char*)className);\n+        if (threadName != NULL) {\n+            jvmti->Deallocate((unsigned char*)threadName);\n+        }\n@@ -362,1 +359,1 @@\n-    if (strcmp(EXPECTED_CLASS_SIGN, className) == 0) {\n+    if (className != NULL && strcmp(EXPECTED_CLASS_SIGN, className) == 0) {\n@@ -365,2 +362,7 @@\n-        NSK_DISPLAY2(\"\\n\\n>>>> Caught exception %s in thread - %s\\n\",\n-                        className, getThreadName(jni_env, thread));\n+        const char *threadName = getThreadName(jvmti_env, jni_env, thread);\n+        NSK_DISPLAY2(\">>>> Caught exception %s in thread - %s\\n\",\n+            className, threadName != NULL ? threadName : \"NULL\");\n+        jvmti->Deallocate((unsigned char*)className);\n+        if (threadName != NULL) {\n+            jvmti->Deallocate((unsigned char*)threadName);\n+        }\n@@ -380,1 +382,1 @@\n-int readNewBytecode(jvmtiEnv* jvmti) {\n+int readNewBytecode(jvmtiEnv* jvmti, jint &newClassSize, unsigned char* &newClassBytes) {\n@@ -417,0 +419,2 @@\n+        jvmti->Deallocate(newClassBytes);\n+        newClassBytes = NULL;\n@@ -425,1 +429,1 @@\n-const char* getThreadName(JNIEnv* jni_env, jthread thread) {\n+const char* getThreadName(jvmtiEnv* jvmti_env, JNIEnv* jni_env, jthread thread) {\n@@ -429,0 +433,2 @@\n+    jsize jthreadNameLen;\n+    unsigned char *result = NULL;\n@@ -431,2 +437,0 @@\n-    strcpy(chbuffer, \"\");\n-\n@@ -435,1 +439,1 @@\n-        return chbuffer;\n+        return NULL;\n@@ -441,1 +445,1 @@\n-        return chbuffer;\n+        return NULL;\n@@ -446,0 +450,7 @@\n+    jthreadNameLen = jni_env->GetStringUTFLength(jthreadName);\n+\n+    if (!NSK_JVMTI_VERIFY(jvmti_env->Allocate(jthreadNameLen + 1, &result))) {\n+        NSK_COMPLAIN0(\"buffer couldn't be allocated\\n\");\n+        return NULL;\n+    }\n+\n@@ -448,1 +459,1 @@\n-    strcpy(chbuffer, threadName);\n+    memcpy(result, threadName, jthreadNameLen + 1);\n@@ -452,1 +463,1 @@\n-    return chbuffer;\n+    return (char*)result;\n@@ -460,1 +471,0 @@\n-    char *generic;\n@@ -463,2 +473,0 @@\n-    strcpy(chbuffer, \"\");\n-\n@@ -467,6 +475,1 @@\n-        return chbuffer;\n-    }\n-\n-    if (!NSK_JVMTI_VERIFY(jvmti_env->GetClassSignature(klass, &className, &generic))) {\n-        nsk_jvmti_setFailStatus();\n-        return chbuffer;\n+        return NULL;\n@@ -475,3 +478,1 @@\n-    strcpy(chbuffer, className);\n-\n-    if (!NSK_JVMTI_VERIFY(jvmti_env->Deallocate((unsigned char*)className))) {\n+    if (!NSK_JVMTI_VERIFY(jvmti_env->GetClassSignature(klass, &className, NULL))) {\n@@ -479,0 +480,1 @@\n+        return NULL;\n@@ -481,6 +483,1 @@\n-    if (generic != NULL)\n-        if (!NSK_JVMTI_VERIFY(jvmti_env->Deallocate((unsigned char*)generic))) {\n-            nsk_jvmti_setFailStatus();\n-        }\n-\n-    return chbuffer;\n+    return className;\n@@ -549,0 +546,4 @@\n+    enableEvent(jvmti, JVMTI_EVENT_CLASS_LOAD, testedThread);\n+    enableEvent(jvmti, JVMTI_EVENT_BREAKPOINT, testedThread);\n+    enableEvent(jvmti, JVMTI_EVENT_EXCEPTION, testedThread);\n+    enableEvent(jvmti, JVMTI_EVENT_EXCEPTION_CATCH, testedThread);\n@@ -668,5 +669,0 @@\n-    enableEvent(jvmti, JVMTI_EVENT_CLASS_LOAD, testedThread);\n-    enableEvent(jvmti, JVMTI_EVENT_BREAKPOINT, testedThread);\n-    enableEvent(jvmti, JVMTI_EVENT_EXCEPTION, testedThread);\n-    enableEvent(jvmti, JVMTI_EVENT_EXCEPTION_CATCH, testedThread);\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/hotswap\/HS201\/hs201t002\/hs201t002.cpp","additions":59,"deletions":63,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+        System.out.println(\"Current step: \" + hs201t002.currentStep); \/\/ Avoid calling classloader to find hs201t002 in doInit()\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/hotswap\/HS201\/hs201t002\/newclass\/hs201t002a.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"}]}