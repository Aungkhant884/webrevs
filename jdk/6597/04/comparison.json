{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -361,0 +361,1 @@\n+  fr.set_sp_is_trusted();\n@@ -466,3 +467,11 @@\n-  \/\/ we cannot rely upon the last fp having been saved to the thread\n-  \/\/ in C2 code but it will have been pushed onto the stack. so we\n-  \/\/ have to find it relative to the unextended sp\n+  \/\/ When the sp of a compiled frame is correct, we can get the correct sender sp\n+  \/\/ by unextended sp + frame size.\n+  \/\/ For the following two scenarios, the sp of a compiled frame is correct:\n+  \/\/  a) This compiled frame is built from the anchor.\n+  \/\/  b) This compiled frame is built from a callee frame, and the callee frame can\n+  \/\/    calculate its sp correctly.\n+  \/\/\n+  \/\/ For b), if the callee frame is a native code frame (such as leaf call), the sp of\n+  \/\/ the compiled frame cannot be calculated correctly. There is currently no suitable\n+  \/\/ solution to solve this problem perfectly. But when PreserveFramePointer is enabled,\n+  \/\/ we can get the correct sender sp by fp + 2 (that is sender_sp()).\n@@ -471,1 +480,2 @@\n-  intptr_t* l_sender_sp = unextended_sp() + _cb->frame_size();\n+  intptr_t* l_sender_sp = (!PreserveFramePointer || _sp_is_trusted) ? unextended_sp() + _cb->frame_size()\n+                                                                    : sender_sp();\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.cpp","additions":15,"deletions":5,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -127,0 +127,5 @@\n+  \/\/ true means _sp value is correct and we can use it to get the sender's sp\n+  \/\/ of the compiled frame, otherwise, _sp value may be invalid and we can use\n+  \/\/ _fp to get the sender's sp if PreserveFramePointer is enabled.\n+  bool _sp_is_trusted;\n+\n@@ -168,0 +173,2 @@\n+  void set_sp_is_trusted() { _sp_is_trusted = true; }\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.hpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,0 +44,1 @@\n+  _sp_is_trusted = false;\n@@ -67,0 +68,1 @@\n+  _sp_is_trusted = false;\n@@ -94,0 +96,1 @@\n+  _sp_is_trusted = false;\n@@ -125,0 +128,1 @@\n+  _sp_is_trusted = false;\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.inline.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,3 @@\n-  return frame(_anchor.last_Java_sp(), _anchor.last_Java_fp(), _anchor.last_Java_pc());\n+  frame f = frame(_anchor.last_Java_sp(), _anchor.last_Java_fp(), _anchor.last_Java_pc());\n+  f.set_sp_is_trusted();\n+  return f;\n","filename":"src\/hotspot\/os_cpu\/linux_aarch64\/thread_linux_aarch64.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"}]}