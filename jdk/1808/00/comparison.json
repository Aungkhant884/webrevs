{"files":[{"patch":"@@ -142,1 +142,1 @@\n-    SystemDictionary::add_to_hierarchy(result, THREAD);\n+    SystemDictionary::add_to_hierarchy(result);\n","filename":"src\/hotspot\/share\/classfile\/lambdaFormInvokers.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-                                              bool havesupername,\n@@ -41,1 +40,0 @@\n-  entry->set_havesupername(havesupername);\n@@ -65,1 +63,1 @@\n-                                              bool havesupername, Symbol* supername){\n+                                              Symbol* supername){\n@@ -71,1 +69,1 @@\n-  PlaceholderEntry* entry = new_entry(hash, class_name, loader_data, havesupername, supername);\n+  PlaceholderEntry* entry = new_entry(hash, class_name, loader_data, supername);\n@@ -125,1 +123,1 @@\n-  \/\/ if havesupername: this is used for circularity for instanceklass loading\n+  \/\/ If LOAD_SUPER, this is used for circularity detection for instanceklass loading.\n@@ -132,0 +130,1 @@\n+  assert(action != LOAD_SUPER || supername != NULL, \"must have a super class name\");\n@@ -135,1 +134,1 @@\n-    probe = add_entry(hash, name, loader_data, (action == LOAD_SUPER), supername);\n+    probe = add_entry(hash, name, loader_data, supername);\n@@ -138,1 +137,0 @@\n-      probe->set_havesupername(true);\n","filename":"src\/hotspot\/share\/classfile\/placeholders.cpp","additions":5,"deletions":7,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-  PlaceholderEntry* new_entry(int hash, Symbol* name, ClassLoaderData* loader_data, bool havesupername, Symbol* supername);\n+  PlaceholderEntry* new_entry(int hash, Symbol* name, ClassLoaderData* loader_data, Symbol* supername);\n@@ -55,1 +55,1 @@\n-                              bool havesupername, Symbol* supername);\n+                              Symbol* supername);\n@@ -147,1 +147,0 @@\n-  bool              _havesupername; \/\/ distinguish between null supername, and unknown\n@@ -168,3 +167,0 @@\n-  bool               havesupername()       const { return _havesupername; }\n-  void               set_havesupername(bool havesupername) { _havesupername = havesupername; }\n-\n","filename":"src\/hotspot\/share\/classfile\/placeholders.hpp","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -48,1 +48,0 @@\n-#include \"compiler\/compileBroker.hpp\"\n@@ -50,2 +49,1 @@\n-#include \"interpreter\/bytecodeStream.hpp\"\n-#include \"interpreter\/interpreter.hpp\"\n+#include \"interpreter\/bootstrapInfo.hpp\"\n@@ -55,1 +53,0 @@\n-#include \"memory\/filemap.hpp\"\n@@ -66,1 +63,0 @@\n-#include \"oops\/methodData.hpp\"\n@@ -197,0 +193,32 @@\n+Handle SystemDictionary::compute_loader_lock_object(Thread* thread, Handle class_loader) {\n+  \/\/ If class_loader is NULL we synchronize on _system_loader_lock_obj\n+  if (class_loader.is_null()) {\n+    return Handle(thread, _system_loader_lock_obj.resolve());\n+  } else {\n+    return class_loader;\n+  }\n+}\n+\n+\/\/ This method is added to check how often we have to wait to grab loader\n+\/\/ lock. The results are being recorded in the performance counters defined in\n+\/\/ ClassLoader::_sync_systemLoaderLockContentionRate and\n+\/\/ ClassLoader::_sync_nonSystemLoaderLockConteionRate.\n+void SystemDictionary::check_loader_lock_contention(Thread* thread, Handle loader_lock) {\n+  if (!UsePerfData) {\n+    return;\n+  }\n+\n+  assert(!loader_lock.is_null(), \"NULL lock object\");\n+\n+  if (ObjectSynchronizer::query_lock_ownership(thread->as_Java_thread(), loader_lock)\n+      == ObjectSynchronizer::owner_other) {\n+    \/\/ contention will likely happen, so increment the corresponding\n+    \/\/ contention counter.\n+    if (loader_lock() == _system_loader_lock_obj.resolve()) {\n+      ClassLoader::sync_systemLoaderLockContentionRate()->inc();\n+    } else {\n+      ClassLoader::sync_nonSystemLoaderLockContentionRate()->inc();\n+    }\n+  }\n+}\n+\n@@ -407,1 +435,0 @@\n-  bool child_already_loaded = false;\n@@ -440,1 +467,1 @@\n-\/\/ java.lang.Object should have been found above\n+  \/\/ java.lang.Object should have been found above\n@@ -563,1 +590,1 @@\n-void SystemDictionary::double_lock_wait(Handle lockObject, TRAPS) {\n+void SystemDictionary::double_lock_wait(Thread* thread, Handle lockObject) {\n@@ -567,1 +594,1 @@\n-      = ObjectSynchronizer::current_thread_holds_lock(THREAD->as_Java_thread(), lockObject);\n+      = ObjectSynchronizer::current_thread_holds_lock(thread->as_Java_thread(), lockObject);\n@@ -571,2 +598,3 @@\n-  ObjectSynchronizer::notifyall(lockObject, THREAD);\n-  intx recursions =  ObjectSynchronizer::complete_exit(lockObject, THREAD);\n+  \/\/ These don't throw exceptions.\n+  ObjectSynchronizer::notifyall(lockObject, thread);\n+  intx recursions =  ObjectSynchronizer::complete_exit(lockObject, thread);\n@@ -575,1 +603,1 @@\n-  ObjectSynchronizer::reenter(lockObject, recursions, THREAD);\n+  ObjectSynchronizer::reenter(lockObject, recursions, thread);\n@@ -636,1 +664,1 @@\n-      if (placeholder && placeholder->super_load_in_progress() ){\n+      if (placeholder != NULL && placeholder->super_load_in_progress()) {\n@@ -653,1 +681,1 @@\n-          double_lock_wait(lockObject, THREAD);\n+          double_lock_wait(THREAD, lockObject);\n@@ -656,1 +684,2 @@\n-        \/\/ If not in SD and not in PH, other thread's load must have failed\n+        \/\/ If not in SD and not in PH, the other thread is done loading the super class\n+        \/\/ but not done loading this class. We'll give up the lock and wait for that below.\n@@ -727,2 +756,2 @@\n-  Handle lockObject = compute_loader_lock_object(class_loader, THREAD);\n-  check_loader_lock_contention(lockObject, THREAD);\n+  Handle lockObject = compute_loader_lock_object(THREAD, class_loader);\n+  check_loader_lock_contention(THREAD, lockObject);\n@@ -731,1 +760,1 @@\n-  \/\/ Check again (after locking) if class already exist in SystemDictionary\n+  \/\/ Check again (after locking) if the class already exists in SystemDictionary\n@@ -734,3 +763,1 @@\n-  bool havesupername = false;\n-  InstanceKlass* k = NULL;\n-  PlaceholderEntry* placeholder;\n+  InstanceKlass* loaded_class = NULL;\n@@ -749,1 +776,1 @@\n-      k = check;\n+      loaded_class = check;\n@@ -751,2 +778,2 @@\n-      placeholder = placeholders()->get_entry(name_hash, name, loader_data);\n-      if (placeholder && placeholder->super_load_in_progress()) {\n+      PlaceholderEntry* placeholder = placeholders()->get_entry(name_hash, name, loader_data);\n+      if (placeholder != NULL && placeholder->super_load_in_progress()) {\n@@ -754,4 +781,2 @@\n-         if (placeholder->havesupername() == true) {\n-           superclassname = placeholder->supername();\n-           havesupername = true;\n-         }\n+         superclassname = placeholder->supername();\n+         assert(superclassname != NULL, \"superclass has to have a name\");\n@@ -763,10 +788,7 @@\n-  if (super_load_in_progress && havesupername==true) {\n-    k = handle_parallel_super_load(name,\n-                                   superclassname,\n-                                   class_loader,\n-                                   protection_domain,\n-                                   lockObject, THREAD);\n-    if (HAS_PENDING_EXCEPTION) {\n-      return NULL;\n-    }\n-    if (k != NULL) {\n+  if (super_load_in_progress) {\n+    loaded_class = handle_parallel_super_load(name,\n+                                              superclassname,\n+                                              class_loader,\n+                                              protection_domain,\n+                                              lockObject, CHECK_NULL);\n+    if (loaded_class != NULL) {\n@@ -807,1 +829,1 @@\n-        if (oldprobe) {\n+        if (oldprobe != NULL) {\n@@ -814,1 +836,1 @@\n-            while (!class_has_been_loaded && oldprobe && oldprobe->instance_load_in_progress()) {\n+            while (!class_has_been_loaded && oldprobe != NULL && oldprobe->instance_load_in_progress()) {\n@@ -823,1 +845,1 @@\n-                double_lock_wait(lockObject, THREAD);\n+                double_lock_wait(THREAD, lockObject);\n@@ -829,1 +851,1 @@\n-                k = check;\n+                loaded_class = check;\n@@ -843,1 +865,2 @@\n-        PlaceholderEntry* newprobe = placeholders()->find_and_add(name_hash, name, loader_data, PlaceholderTable::LOAD_INSTANCE, NULL, THREAD);\n+        PlaceholderEntry* newprobe = placeholders()->find_and_add(name_hash, name, loader_data,\n+                                                                  PlaceholderTable::LOAD_INSTANCE, NULL, THREAD);\n@@ -854,1 +877,1 @@\n-          k = check;\n+          loaded_class = check;\n@@ -870,1 +893,1 @@\n-      k = load_instance_class(name, class_loader, THREAD);\n+      loaded_class = load_instance_class(name, class_loader, THREAD);\n@@ -874,2 +897,2 @@\n-      if (!HAS_PENDING_EXCEPTION && k != NULL &&\n-        k->class_loader() != class_loader()) {\n+      if (!HAS_PENDING_EXCEPTION && loaded_class != NULL &&\n+        loaded_class->class_loader() != class_loader()) {\n@@ -877,1 +900,1 @@\n-        check_constraints(name_hash, k, class_loader, false, THREAD);\n+        check_constraints(name_hash, loaded_class, class_loader, false, THREAD);\n@@ -883,1 +906,1 @@\n-          \/\/ This recording keeps the defining class loader of the klass (k) found\n+          \/\/ This recording keeps the defining class loader of the klass (loaded_class) found\n@@ -887,1 +910,1 @@\n-          loader_data->record_dependency(k);\n+          loader_data->record_dependency(loaded_class);\n@@ -892,1 +915,1 @@\n-            update_dictionary(name_hash, k, class_loader, THREAD);\n+            update_dictionary(name_hash, loaded_class, class_loader);\n@@ -896,1 +919,1 @@\n-            JvmtiExport::post_class_load(THREAD->as_Java_thread(), k);\n+            JvmtiExport::post_class_load(THREAD->as_Java_thread(), loaded_class);\n@@ -902,1 +925,1 @@\n-    if (load_instance_added == true) {\n+    if (load_instance_added) {\n@@ -912,1 +935,1 @@\n-  if (HAS_PENDING_EXCEPTION || k == NULL) {\n+  if (HAS_PENDING_EXCEPTION || loaded_class == NULL) {\n@@ -916,1 +939,1 @@\n-    post_class_load_event(&class_load_start_event, k, loader_data);\n+    post_class_load_event(&class_load_start_event, loaded_class, loader_data);\n@@ -920,1 +943,1 @@\n-    ClassLoaderData* loader_data = k->class_loader_data();\n+    ClassLoaderData* loader_data = loaded_class->class_loader_data();\n@@ -923,1 +946,1 @@\n-    assert(kk == k, \"should be present in dictionary\");\n+    assert(kk == loaded_class, \"should be present in dictionary\");\n@@ -928,1 +951,1 @@\n-  if (protection_domain() == NULL) return k;\n+  if (protection_domain() == NULL) return loaded_class;\n@@ -933,1 +956,1 @@\n-    return k;\n+    return loaded_class;\n@@ -937,1 +960,1 @@\n-  validate_protection_domain(k, class_loader, protection_domain, CHECK_NULL);\n+  validate_protection_domain(loaded_class, class_loader, protection_domain, CHECK_NULL);\n@@ -939,1 +962,1 @@\n-  return k;\n+  return loaded_class;\n@@ -946,3 +969,3 @@\n-\/\/ dictionary entries are only removed at a safepoint (when only one\n-\/\/ thread is running), and are added to in a safe way (all links must\n-\/\/ be updated in an MT-safe manner).\n+\/\/ dictionary entries are added to in a safe way (all links must\n+\/\/ be updated in an MT-safe manner). All entries are removed during class\n+\/\/ unloading, when this class loader is no longer referenced.\n@@ -1060,4 +1083,2 @@\n-\n-      \/\/ Add to class hierarchy, initialize vtables, and do possible\n-      \/\/ deoptimizations.\n-      add_to_hierarchy(k, CHECK_NULL); \/\/ No exception, but can block\n+      \/\/ Add to class hierarchy, and do possible deoptimizations.\n+      add_to_hierarchy(k);\n@@ -1115,2 +1136,2 @@\n-  Handle lockObject = compute_loader_lock_object(class_loader, THREAD);\n-  check_loader_lock_contention(lockObject, THREAD);\n+  Handle lockObject = compute_loader_lock_object(THREAD, class_loader);\n+  check_loader_lock_contention(THREAD, lockObject);\n@@ -1406,2 +1427,2 @@\n-    Handle lockObject = compute_loader_lock_object(class_loader, THREAD);\n-    check_loader_lock_contention(lockObject, THREAD);\n+    Handle lockObject = compute_loader_lock_object(THREAD, class_loader);\n+    check_loader_lock_contention(THREAD, lockObject);\n@@ -1474,1 +1495,1 @@\n-  add_to_hierarchy(klass, CHECK);\n+  add_to_hierarchy(klass);\n@@ -1650,1 +1671,1 @@\n-           compute_loader_lock_object(class_loader_h, THREAD)),\n+           compute_loader_lock_object(THREAD, class_loader_h)),\n@@ -1687,3 +1708,2 @@\n-    \/\/ Add to class hierarchy, initialize vtables, and do possible\n-    \/\/ deoptimizations.\n-    add_to_hierarchy(k, CHECK); \/\/ No exception, but can block\n+    \/\/ Add to class hierarchy, and do possible deoptimizations.\n+    add_to_hierarchy(k);\n@@ -1693,1 +1713,1 @@\n-    update_dictionary(name_hash, k, class_loader_h, THREAD);\n+    update_dictionary(name_hash, k, class_loader_h);\n@@ -1723,1 +1743,1 @@\n-\/\/ So be careful to not exit with a CHECK_ macro betweeen these calls.\n+\/\/ So be careful to not exit with a CHECK_ macro between these calls.\n@@ -1734,3 +1754,0 @@\n-  assert(placeholders()->compute_hash(name_h) == name_hash, \"they're the same hashcode\");\n-  PlaceholderEntry* probe;\n-\n@@ -1748,1 +1765,3 @@\n-    probe = placeholders()->find_and_add(name_hash, name_h, loader_data, PlaceholderTable::DEFINE_CLASS, NULL, THREAD);\n+    assert(placeholders()->compute_hash(name_h) == name_hash, \"they're the same hashcode\");\n+    PlaceholderEntry* probe = placeholders()->find_and_add(name_hash, name_h, loader_data,\n+                                                           PlaceholderTable::DEFINE_CLASS, NULL, THREAD);\n@@ -1760,2 +1779,2 @@\n-        placeholders()->find_and_remove(name_hash, name_h, loader_data, PlaceholderTable::DEFINE_CLASS, THREAD);\n-        SystemDictionary_lock->notify_all();\n+      placeholders()->find_and_remove(name_hash, name_h, loader_data, PlaceholderTable::DEFINE_CLASS, THREAD);\n+      SystemDictionary_lock->notify_all();\n@@ -1763,2 +1782,2 @@\n-        InstanceKlass* check = dictionary->find_class(name_hash, name_h);\n-        assert(check != NULL, \"definer missed recording success\");\n+      InstanceKlass* check = dictionary->find_class(name_hash, name_h);\n+      assert(check != NULL, \"definer missed recording success\");\n@@ -1766,1 +1785,1 @@\n-        return probe->instance_klass();\n+      return probe->instance_klass();\n@@ -1775,2 +1794,0 @@\n-  Handle linkage_exception = Handle(); \/\/ null handle\n-\n@@ -1782,10 +1799,2 @@\n-    if (probe != NULL) {\n-      if (HAS_PENDING_EXCEPTION) {\n-        linkage_exception = Handle(THREAD,PENDING_EXCEPTION);\n-        CLEAR_PENDING_EXCEPTION;\n-      } else {\n-        probe->set_instance_klass(k);\n-      }\n-      probe->set_definer(NULL);\n-      placeholders()->find_and_remove(name_hash, name_h, loader_data, PlaceholderTable::DEFINE_CLASS, THREAD);\n-      SystemDictionary_lock->notify_all();\n+    if (!HAS_PENDING_EXCEPTION) {\n+      probe->set_instance_klass(k);\n@@ -1793,5 +1802,3 @@\n-  }\n-\n-  \/\/ Can't throw exception while holding lock due to rank ordering\n-  if (linkage_exception() != NULL) {\n-    THROW_OOP_(linkage_exception(), NULL); \/\/ throws exception and returns\n+    probe->set_definer(NULL);\n+    placeholders()->find_and_remove(name_hash, name_h, loader_data, PlaceholderTable::DEFINE_CLASS, THREAD);\n+    SystemDictionary_lock->notify_all();\n@@ -1803,31 +1810,0 @@\n-Handle SystemDictionary::compute_loader_lock_object(Handle class_loader, TRAPS) {\n-  \/\/ If class_loader is NULL we synchronize on _system_loader_lock_obj\n-  if (class_loader.is_null()) {\n-    return Handle(THREAD, _system_loader_lock_obj.resolve());\n-  } else {\n-    return class_loader;\n-  }\n-}\n-\n-\/\/ This method is added to check how often we have to wait to grab loader\n-\/\/ lock. The results are being recorded in the performance counters defined in\n-\/\/ ClassLoader::_sync_systemLoaderLockContentionRate and\n-\/\/ ClassLoader::_sync_nonSystemLoaderLockConteionRate.\n-void SystemDictionary::check_loader_lock_contention(Handle loader_lock, TRAPS) {\n-  if (!UsePerfData) {\n-    return;\n-  }\n-\n-  assert(!loader_lock.is_null(), \"NULL lock object\");\n-\n-  if (ObjectSynchronizer::query_lock_ownership(THREAD->as_Java_thread(), loader_lock)\n-      == ObjectSynchronizer::owner_other) {\n-    \/\/ contention will likely happen, so increment the corresponding\n-    \/\/ contention counter.\n-    if (loader_lock() == _system_loader_lock_obj.resolve()) {\n-      ClassLoader::sync_systemLoaderLockContentionRate()->inc();\n-    } else {\n-      ClassLoader::sync_nonSystemLoaderLockContentionRate()->inc();\n-    }\n-  }\n-}\n@@ -1867,1 +1843,1 @@\n-\/\/ Update hierachy. This is done before the new klass has been added to the SystemDictionary. The Recompile_lock\n+\/\/ Update hierachy. This is done before the new klass has been added to the SystemDictionary. The Compile_lock\n@@ -1871,1 +1847,1 @@\n-void SystemDictionary::add_to_hierarchy(InstanceKlass* k, TRAPS) {\n+void SystemDictionary::add_to_hierarchy(InstanceKlass* k) {\n@@ -1884,1 +1860,1 @@\n-  k->process_interfaces(THREAD);                  \/\/ handle all \"implements\" declarations\n+  k->process_interfaces();                        \/\/ handle all \"implements\" declarations\n@@ -2226,2 +2202,1 @@\n-                                         Handle class_loader,\n-                                         TRAPS) {\n+                                         Handle class_loader) {\n@@ -2234,1 +2209,1 @@\n-    MutexLocker mu1(THREAD, SystemDictionary_lock);\n+    MutexLocker mu1(SystemDictionary_lock);\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":117,"deletions":142,"binary":false,"changes":259,"status":"modified"},{"patch":"@@ -581,1 +581,1 @@\n-  static void double_lock_wait(Handle lockObject, TRAPS);\n+  static void double_lock_wait(Thread* thread, Handle lockObject);\n@@ -615,2 +615,2 @@\n-  static Handle compute_loader_lock_object(Handle class_loader, TRAPS);\n-  static void check_loader_lock_contention(Handle loader_lock, TRAPS);\n+  static Handle compute_loader_lock_object(Thread* thread, Handle class_loader);\n+  static void check_loader_lock_contention(Thread* thread, Handle loader_lock);\n@@ -636,1 +636,1 @@\n-  static void add_to_hierarchy(InstanceKlass* k, TRAPS);\n+  static void add_to_hierarchy(InstanceKlass* k);\n@@ -655,2 +655,1 @@\n-                                InstanceKlass* k, Handle loader,\n-                                TRAPS);\n+                                InstanceKlass* k, Handle loader);\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.hpp","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1046,2 +1046,2 @@\n-      Handle lockObject = compute_loader_lock_object(class_loader, THREAD);\n-      check_loader_lock_contention(lockObject, THREAD);\n+      Handle lockObject = compute_loader_lock_object(THREAD, class_loader);\n+      check_loader_lock_contention(THREAD, lockObject);\n@@ -1219,1 +1219,1 @@\n-    SystemDictionary::add_to_hierarchy(k, CHECK_false);\n+    SystemDictionary::add_to_hierarchy(k);\n@@ -1722,3 +1722,2 @@\n-    \/\/ Add to class hierarchy, initialize vtables, and do possible\n-    \/\/ deoptimizations.\n-    SystemDictionary::add_to_hierarchy(loaded_lambda, CHECK_NULL); \/\/ No exception, but can block\n+    \/\/ Add to class hierarchy, and do possible deoptimizations.\n+    SystemDictionary::add_to_hierarchy(loaded_lambda);\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.cpp","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1322,1 +1322,1 @@\n-void InstanceKlass::process_interfaces(Thread *thread) {\n+void InstanceKlass::process_interfaces() {\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1027,1 +1027,1 @@\n-  void process_interfaces(Thread *thread);\n+  void process_interfaces();\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}