{"files":[{"patch":"@@ -218,0 +218,3 @@\n+            if (radix < Character.MIN_RADIX || radix > Character.MAX_RADIX) {\n+                radix = 10;\n+            }\n@@ -237,1 +240,5 @@\n-                default -> toUnsignedBigInteger(i).toString(radix);\n+                default -> {\n+                    long leadingDigits = divideUnsigned(i, radix);  \/\/ always positive\n+                    int lastDigit = (int)remainderUnsigned(i, radix);\n+                    yield toString(leadingDigits, radix) + Integer.digits[lastDigit];\n+                }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Long.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -57,0 +57,1 @@\n+    private long[] longArrayNegative;\n@@ -66,0 +67,1 @@\n+        longArrayNegative = new long[size];\n@@ -70,0 +72,1 @@\n+            longArrayNegative[i] = random.nextLong(Long.MIN_VALUE, 0L);\n@@ -112,0 +115,10 @@\n+    \/** Performs toUnsignedString(long, int) on negative values and every radices *\/\n+    @Benchmark\n+    public void toUnsignedStringNegative(Blackhole bh) {\n+        for (long v : longArrayNegative) {\n+            for (int r = Character.MIN_RADIX; r <= Character.MAX_RADIX; r++) {\n+                bh.consume(Long.toUnsignedString(v, r));\n+            }\n+        }\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/Longs.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"}]}