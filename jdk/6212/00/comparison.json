{"files":[{"patch":"@@ -479,0 +479,2 @@\n+        assert(offset_ok_for_immed(_offset, size),\n+               \"must be, was: %ld, %d\", _offset, size);\n@@ -480,9 +482,8 @@\n-        if (_offset < 0 || _offset & mask)\n-          {\n-            i->f(0b00, 25, 24);\n-            i->f(0, 21), i->f(0b00, 11, 10);\n-            i->sf(_offset, 20, 12);\n-          } else {\n-            i->f(0b01, 25, 24);\n-            i->f(_offset >> size, 21, 10);\n-          }\n+        if (_offset < 0 || _offset & mask) {\n+          i->f(0b00, 25, 24);\n+          i->f(0, 21), i->f(0b00, 11, 10);\n+          i->sf(_offset, 20, 12);\n+        } else {\n+          i->f(0b01, 25, 24);\n+          i->f(_offset >> size, 21, 10);\n+        }\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.hpp","additions":10,"deletions":9,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -33,1 +33,6 @@\n-\n+\/\/ Check if an offset is within the encoding range for LDR\/STR instructions\n+\/\/ with an immediate offset, either using unscaled signed 9-bits or, scaled\n+\/\/ unsigned 12-bits. We favour the scaled unsigned encoding for all aligned\n+\/\/ offsets (only using the signed 9-bit encoding for negative and unaligned\n+\/\/ offsets). As a precondition, 0 <= shift <= 4 is the log2(size), for the\n+\/\/ supported data widths, {1, 2, 4, 8, 16} bytes.\n@@ -35,0 +40,1 @@\n+  precond(shift < 5);\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.inline.hpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -190,7 +190,12 @@\n-  } else  {\n-    intptr_t addr_offset = intptr_t(addr->disp());\n-    if (Address::offset_ok_for_immed(addr_offset, addr->scale()))\n-      return Address(base, addr_offset, Address::lsl(addr->scale()));\n-    else {\n-      __ mov(tmp, addr_offset);\n-      return Address(base, tmp, Address::lsl(addr->scale()));\n+  } else {\n+    assert(addr->scale() == 0,\n+           \"expected for immediate operand, was: %d\", addr->scale());\n+    ptrdiff_t offset = ptrdiff_t(addr->disp());\n+    \/\/ NOTE: Does not handle any 16 byte vector access.\n+    const uint type_size = type2aelembytes(addr->type(), true);\n+    const uint log2_size = log2i_exact(type_size);\n+    if (Address::offset_ok_for_immed(offset, log2_size)) {\n+      return Address(base, offset);\n+    } else {\n+      __ mov(tmp, offset);\n+      return Address(base, tmp);\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRAssembler_aarch64.cpp","additions":12,"deletions":7,"binary":false,"changes":19,"status":"modified"}]}