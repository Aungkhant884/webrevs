{"files":[{"patch":"@@ -578,3 +578,0 @@\n-    \/\/ DefNew needs to run with n_threads == 0, to make sure the serial\n-    \/\/ version of the card table scanning code is used.\n-    \/\/ See: CardTableRS::non_clean_card_iterate_possibly_parallel.\n@@ -583,2 +580,1 @@\n-    heap->young_process_roots(&srs,\n-                              &scan_closure,\n+    heap->young_process_roots(&scan_closure,\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.cpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -185,1 +185,1 @@\n-    StrongRootsScope srs(1);\n+    StrongRootsScope srs(0);\n@@ -187,2 +187,1 @@\n-    gch->full_process_roots(&srs,\n-                            false, \/\/ not the adjust phase\n+    gch->full_process_roots(false, \/\/ not the adjust phase\n@@ -275,1 +274,1 @@\n-    StrongRootsScope srs(1);\n+    StrongRootsScope srs(0);\n@@ -277,2 +276,1 @@\n-    gch->full_process_roots(&srs,\n-                            true,  \/\/ this is the adjust phase\n+    gch->full_process_roots(true,  \/\/ this is the adjust phase\n","filename":"src\/hotspot\/share\/gc\/serial\/genMarkSweep.cpp","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -92,2 +92,1 @@\n-void SerialHeap::young_process_roots(StrongRootsScope* scope,\n-                                     OopIterateClosure* root_closure,\n+void SerialHeap::young_process_roots(OopIterateClosure* root_closure,\n@@ -98,1 +97,1 @@\n-  process_roots(scope, SO_ScavengeCodeCache, root_closure,\n+  process_roots(SO_ScavengeCodeCache, root_closure,\n@@ -102,3 +101,1 @@\n-  old_gen()->younger_refs_iterate(old_gen_closure, scope->n_threads());\n-\n-  _process_strong_tasks->all_tasks_completed(scope->n_threads());\n+  old_gen()->younger_refs_iterate(old_gen_closure, 0);\n","filename":"src\/hotspot\/share\/gc\/serial\/serialHeap.cpp","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -80,2 +80,1 @@\n-  void young_process_roots(StrongRootsScope* scope,\n-                           OopIterateClosure* root_closure,\n+  void young_process_roots(OopIterateClosure* root_closure,\n","filename":"src\/hotspot\/share\/gc\/serial\/serialHeap.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -102,1 +102,0 @@\n-  _process_strong_tasks(new SubTasksDone(GCH_PS_NumElements)),\n@@ -549,3 +548,1 @@\n-  assert(my_thread->is_VM_thread() ||\n-         my_thread->is_ConcurrentGC_thread(),\n-         \"incorrect thread type capability\");\n+  assert(my_thread->is_VM_thread(), \"only VM thread\");\n@@ -798,2 +795,1 @@\n-void GenCollectedHeap::process_roots(StrongRootsScope* scope,\n-                                     ScanningOption so,\n+void GenCollectedHeap::process_roots(ScanningOption so,\n@@ -806,4 +802,0 @@\n-  \/\/ _n_termination for _process_strong_tasks should be set up stream\n-  \/\/ in a method not running in a GC worker.  Otherwise the GC worker\n-  \/\/ could be trying to change the termination condition while the task\n-  \/\/ is executing in another GC worker.\n@@ -811,3 +803,1 @@\n-  if (_process_strong_tasks->try_claim_task(GCH_PS_ClassLoaderDataGraph_oops_do)) {\n-    ClassLoaderDataGraph::roots_cld_do(strong_cld_closure, weak_cld_closure);\n-  }\n+  ClassLoaderDataGraph::roots_cld_do(strong_cld_closure, weak_cld_closure);\n@@ -818,2 +808,1 @@\n-  bool is_par = scope->n_threads() > 1;\n-  Threads::possibly_parallel_oops_do(is_par, strong_roots, roots_from_code_p);\n+  Threads::oops_do(strong_roots, roots_from_code_p);\n@@ -822,4 +811,2 @@\n-  if (_process_strong_tasks->try_claim_task(GCH_PS_aot_oops_do)) {\n-    if (UseAOT) {\n-      AOTLoader::oops_do(strong_roots);\n-    }\n+  if (UseAOT) {\n+    AOTLoader::oops_do(strong_roots);\n@@ -828,3 +815,1 @@\n-  if (_process_strong_tasks->try_claim_task(GCH_PS_OopStorageSet_oops_do)) {\n-    OopStorageSet::strong_oops_do(strong_roots);\n-  }\n+  OopStorageSet::strong_oops_do(strong_roots);\n@@ -832,3 +817,2 @@\n-  if (_process_strong_tasks->try_claim_task(GCH_PS_CodeCache_oops_do)) {\n-    if (so & SO_ScavengeCodeCache) {\n-      assert(code_roots != NULL, \"must supply closure for code cache\");\n+  if (so & SO_ScavengeCodeCache) {\n+    assert(code_roots != NULL, \"must supply closure for code cache\");\n@@ -836,5 +820,5 @@\n-      \/\/ We only visit parts of the CodeCache when scavenging.\n-      ScavengableNMethods::nmethods_do(code_roots);\n-    }\n-    if (so & SO_AllCodeCache) {\n-      assert(code_roots != NULL, \"must supply closure for code cache\");\n+    \/\/ We only visit parts of the CodeCache when scavenging.\n+    ScavengableNMethods::nmethods_do(code_roots);\n+  }\n+  if (so & SO_AllCodeCache) {\n+    assert(code_roots != NULL, \"must supply closure for code cache\");\n@@ -842,8 +826,3 @@\n-      \/\/ CMSCollector uses this to do intermediate-strength collections.\n-      \/\/ We scan the entire code cache, since CodeCache::do_unloading is not called.\n-      CodeCache::blobs_do(code_roots);\n-    }\n-    \/\/ Verify that the code cache contents are not subject to\n-    \/\/ movement by a scavenging collection.\n-    DEBUG_ONLY(CodeBlobToOopClosure assert_code_is_non_scavengable(&assert_is_non_scavengable_closure, !CodeBlobToOopClosure::FixRelocations));\n-    DEBUG_ONLY(ScavengableNMethods::asserted_non_scavengable_nmethods_do(&assert_code_is_non_scavengable));\n+    \/\/ CMSCollector uses this to do intermediate-strength collections.\n+    \/\/ We scan the entire code cache, since CodeCache::do_unloading is not called.\n+    CodeCache::blobs_do(code_roots);\n@@ -851,0 +830,4 @@\n+  \/\/ Verify that the code cache contents are not subject to\n+  \/\/ movement by a scavenging collection.\n+  DEBUG_ONLY(CodeBlobToOopClosure assert_code_is_non_scavengable(&assert_is_non_scavengable_closure, !CodeBlobToOopClosure::FixRelocations));\n+  DEBUG_ONLY(ScavengableNMethods::asserted_non_scavengable_nmethods_do(&assert_code_is_non_scavengable));\n@@ -853,2 +836,1 @@\n-void GenCollectedHeap::full_process_roots(StrongRootsScope* scope,\n-                                          bool is_adjust_phase,\n+void GenCollectedHeap::full_process_roots(bool is_adjust_phase,\n@@ -862,2 +844,1 @@\n-  process_roots(scope, so, root_closure, cld_closure, weak_cld_closure, &mark_code_closure);\n-  _process_strong_tasks->all_tasks_completed(scope->n_threads());\n+  process_roots(so, root_closure, cld_closure, weak_cld_closure, &mark_code_closure);\n","filename":"src\/hotspot\/share\/gc\/shared\/genCollectedHeap.cpp","additions":23,"deletions":42,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -106,14 +106,0 @@\n-  \/\/ The set of potentially parallel tasks in root scanning.\n-  enum GCH_strong_roots_tasks {\n-    GCH_PS_OopStorageSet_oops_do,\n-    GCH_PS_ClassLoaderDataGraph_oops_do,\n-    GCH_PS_CodeCache_oops_do,\n-    AOT_ONLY(GCH_PS_aot_oops_do COMMA)\n-    \/\/ Leave this one last.\n-    GCH_PS_NumElements\n-  };\n-\n-  \/\/ Data structure for claiming the (potentially) parallel tasks in\n-  \/\/ (gen-specific) roots processing.\n-  SubTasksDone* _process_strong_tasks;\n-\n@@ -360,2 +346,1 @@\n-  void process_roots(StrongRootsScope* scope,\n-                     ScanningOption so,\n+  void process_roots(ScanningOption so,\n@@ -371,2 +356,1 @@\n-  void full_process_roots(StrongRootsScope* scope,\n-                          bool is_adjust_phase,\n+  void full_process_roots(bool is_adjust_phase,\n","filename":"src\/hotspot\/share\/gc\/shared\/genCollectedHeap.hpp","additions":2,"deletions":18,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -40,1 +40,6 @@\n-  Threads::change_thread_claim_token();\n+  \/\/ No need for thread claim for statically-known sequential case (_n_threads == 0)\n+  \/\/ For positive values, clients of this class often unify sequential\/parallel\n+  \/\/ cases, so they expect the thread claim token to be updated.\n+  if (_n_threads != 0) {\n+    Threads::change_thread_claim_token();\n+  }\n@@ -44,1 +49,3 @@\n-  Threads::assert_all_threads_claimed();\n+  if (_n_threads != 0) {\n+    Threads::assert_all_threads_claimed();\n+  }\n","filename":"src\/hotspot\/share\/gc\/shared\/strongRootsScope.cpp","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -36,2 +36,1 @@\n-\/\/ Sets up and tears down the required state for parallel root processing.\n-\n+\/\/ Sets up and tears down the required state for sequential\/parallel root processing.\n@@ -40,0 +39,1 @@\n+  \/\/ 0 means statically-known sequential root processing; used only by Serial GC\n","filename":"src\/hotspot\/share\/gc\/shared\/strongRootsScope.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}