{"files":[{"patch":"@@ -190,1 +190,1 @@\n-  FileMapInfo* mapinfo = new FileMapInfo(false);\n+  FileMapInfo* mapinfo = new FileMapInfo(_archive_name, false);\n@@ -330,1 +330,1 @@\n-  dynamic_info->open_for_write(_archive_name);\n+  dynamic_info->open_for_write();\n","filename":"src\/hotspot\/share\/cds\/dynamicArchive.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -169,1 +169,1 @@\n-FileMapInfo::FileMapInfo(bool is_static) {\n+FileMapInfo::FileMapInfo(const char* full_path, bool is_static) {\n@@ -171,0 +171,1 @@\n+  _full_path = full_path;\n@@ -191,0 +192,3 @@\n+  if (_file_open) {\n+    os::close(_fd);\n+  }\n@@ -1052,0 +1056,1 @@\n+  bool _is_static;\n@@ -1053,0 +1058,1 @@\n+  const char* _archive_name;\n@@ -1056,1 +1062,8 @@\n-  FileHeaderHelper() : _fd(-1), _is_valid(false), _header(nullptr), _base_archive_name(nullptr) {}\n+  FileHeaderHelper(const char* archive_name, bool is_static) {\n+    _fd = -1;\n+    _is_valid = false;\n+    _header = nullptr;\n+    _base_archive_name = nullptr;\n+    _archive_name = archive_name;\n+    _is_static = is_static;\n+  }\n@@ -1064,3 +1077,3 @@\n-  bool initialize(const char* archive_name) {\n-    log_info(cds)(\"Opening shared archive: %s\", archive_name);\n-    _fd = os::open(archive_name, O_RDONLY | O_BINARY, 0);\n+  bool initialize() {\n+    assert(_archive_name != nullptr, \"Archive name is NULL\");\n+    _fd = os::open(_archive_name, O_RDONLY | O_BINARY, 0);\n@@ -1068,1 +1081,1 @@\n-      FileMapInfo::fail_continue(\"Specified shared archive not found (%s)\", archive_name);\n+      FileMapInfo::fail_continue(\"Specified shared archive not found (%s)\", _archive_name);\n@@ -1076,3 +1089,2 @@\n-    assert(fd != -1, \"Archive should be opened\");\n-\n-\n+    assert(_archive_name != nullptr, \"Archive name is NULL\");\n+    assert(fd != -1, \"Archive must be opened already\");\n@@ -1101,0 +1113,5 @@\n+    if (gen_header._version !=  CURRENT_CDS_ARCHIVE_VERSION) {\n+      FileMapInfo::fail_continue(\"The shared archive file version %d which is not current version %d\",\n+                                    gen_header._version, CURRENT_CDS_ARCHIVE_VERSION);\n+    }\n+\n@@ -1206,22 +1223,0 @@\n-bool FileMapInfo::check_archive(const char* archive_name, bool is_static) {\n-  FileHeaderHelper file_helper;\n-  if (!file_helper.initialize(archive_name)) {\n-    \/\/ Any errors are reported by fail_continue().\n-    return false;\n-  }\n-\n-  GenericCDSFileMapHeader* header = file_helper.get_generic_file_header();\n-  if (is_static) {\n-    if (header->_magic != CDS_ARCHIVE_MAGIC) {\n-      fail_continue(\"Not a base shared archive: %s\", archive_name);\n-      return false;\n-    }\n-  } else {\n-    if (header->_magic != CDS_DYNAMIC_ARCHIVE_MAGIC) {\n-      fail_continue(\"Not a top shared archive: %s\", archive_name);\n-      return false;\n-    }\n-  }\n-  return true;\n-}\n-\n@@ -1237,1 +1232,1 @@\n-  FileHeaderHelper file_helper;\n+  FileHeaderHelper file_helper(archive_name, false);\n@@ -1240,1 +1235,1 @@\n-  if (!file_helper.initialize(archive_name)) {\n+  if (!file_helper.initialize()) {\n@@ -1246,0 +1241,3 @@\n+    if (AutoCreateSharedArchive) {\n+      warning(\"AutoCreateSharedArchive is ignored because %s is a static archive\", archive_name);\n+    }\n@@ -1262,1 +1260,1 @@\n-  FileHeaderHelper file_helper;\n+  FileHeaderHelper file_helper(_full_path, _is_static);\n@@ -1269,6 +1267,10 @@\n-  unsigned int expected_magic = is_static() ? CDS_ARCHIVE_MAGIC : CDS_DYNAMIC_ARCHIVE_MAGIC;\n-  if (gen_header->_magic != expected_magic) {\n-    log_info(cds)(\"_magic expected: 0x%08x\", expected_magic);\n-    log_info(cds)(\"         actual: 0x%08x\", gen_header->_magic);\n-    FileMapInfo::fail_continue(\"The shared archive file has a bad magic number.\");\n-    return false;\n+  if (_is_static) {\n+    if (gen_header->_magic != CDS_ARCHIVE_MAGIC) {\n+      FileMapInfo::fail_continue(\"Not a base shared archive: %s\", _full_path);\n+      return false;\n+    }\n+  } else {\n+    if (gen_header->_magic != CDS_DYNAMIC_ARCHIVE_MAGIC) {\n+      FileMapInfo::fail_continue(\"Not a top shared archive: %s\", _full_path);\n+      return false;\n+    }\n@@ -1351,5 +1353,0 @@\n-  if (is_static()) {\n-    _full_path = Arguments::GetSharedArchivePath();\n-  } else {\n-    _full_path = Arguments::GetSharedDynamicArchivePath();\n-  }\n@@ -1377,6 +1374,1 @@\n-void FileMapInfo::open_for_write(const char* path) {\n-  if (path == NULL) {\n-    _full_path = Arguments::GetSharedArchivePath();\n-  } else {\n-    _full_path = path;\n-  }\n+void FileMapInfo::open_for_write() {\n@@ -2367,8 +2359,12 @@\n-  if (!open_for_read()) {\n-    return false;\n-  }\n-  if (!init_from_file(_fd)) {\n-    return false;\n-  }\n-  if (!validate_header()) {\n-    return false;\n+  if (!open_for_read() || !init_from_file(_fd) || !validate_header()) {\n+    if (_is_static) {\n+      FileMapInfo::fail_continue(\"Initialize static archive failed.\");\n+      return false;\n+    } else {\n+      FileMapInfo::fail_continue(\"Initialize dynamic archive failed.\");\n+      if (AutoCreateSharedArchive) {\n+        DynamicDumpSharedSpaces = true;\n+        ArchiveClassesAtExit = Arguments::GetSharedDynamicArchivePath();\n+      }\n+      return false;\n+    }\n@@ -2376,0 +2372,1 @@\n+\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":56,"deletions":59,"binary":false,"changes":115,"status":"modified"},{"patch":"@@ -359,1 +359,0 @@\n-  static bool check_archive(const char* archive_name, bool is_static);\n@@ -373,1 +372,1 @@\n-  FileMapInfo(bool is_static);\n+  FileMapInfo(const char* full_apth, bool is_static);\n@@ -444,1 +443,1 @@\n-  void  open_for_write(const char* path = NULL);\n+  void  open_for_write();\n","filename":"src\/hotspot\/share\/cds\/filemap.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -559,1 +559,3 @@\n-  FileMapInfo* mapinfo = new FileMapInfo(true);\n+  const char* static_archive = Arguments::GetSharedArchivePath();\n+  assert(static_archive != nullptr, \"SharedArchiveFile not set?\");\n+  FileMapInfo* mapinfo = new FileMapInfo(static_archive, true);\n@@ -949,0 +951,4 @@\n+      \/\/ turn AutoCreateSharedArchive off if successfully mapped\n+      if (AutoCreateSharedArchive) {\n+        AutoCreateSharedArchive = false;\n+      }\n@@ -955,0 +961,6 @@\n+    if (AutoCreateSharedArchive) {\n+      AutoCreateSharedArchive = false;\n+    }\n+    if (DynamicDumpSharedSpaces) {\n+      DynamicDumpSharedSpaces = false;\n+    }\n@@ -970,1 +982,3 @@\n-  FileMapInfo* mapinfo = new FileMapInfo(true);\n+  const char* static_archive = Arguments::GetSharedArchivePath();\n+  assert(static_archive != nullptr, \"SharedArchivePath is NULL\");\n+  FileMapInfo* mapinfo = new FileMapInfo(static_archive, true);\n@@ -982,1 +996,2 @@\n-  if (Arguments::GetSharedDynamicArchivePath() == NULL) {\n+  const char* dynamic_archive = Arguments::GetSharedDynamicArchivePath();\n+  if (dynamic_archive == nullptr) {\n@@ -986,1 +1001,1 @@\n-  FileMapInfo* mapinfo = new FileMapInfo(false);\n+  FileMapInfo* mapinfo = new FileMapInfo(dynamic_archive, false);\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":19,"deletions":4,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -3143,0 +3143,11 @@\n+  if (AutoCreateSharedArchive) {\n+    if (SharedArchiveFile == NULL) {\n+      log_warning(cds)(\"-XX:+AutoCreateSharedArchive requires -XX:SharedArchiveFile\");\n+      return JNI_ERR;\n+    }\n+    if (ArchiveClassesAtExit != NULL) {\n+      log_warning(cds)(\"-XX:+AutoCreateSharedArchive does not work with ArchiveClassesAtExit\");\n+      return JNI_ERR;\n+    }\n+  }\n+\n@@ -3490,3 +3501,0 @@\n-  if (!FileMapInfo::check_archive((const char*)cur_path, true \/*is_static*\/)) {\n-    return;\n-  }\n@@ -3504,3 +3512,0 @@\n-  if (!FileMapInfo::check_archive((const char*)cur_path, false \/*is_static*\/)) {\n-    return;\n-  }\n@@ -3559,1 +3564,10 @@\n-          no_shared_spaces(\"invalid archive\");\n+          \/\/ If +AutoCreateSharedArchive and the specified shared archive does not exist,\n+          \/\/ regenerate the dynamic archive base on default archive.\n+          if (AutoCreateSharedArchive && !os::file_exists(SharedArchiveFile)) {\n+            DynamicDumpSharedSpaces = true;\n+            ArchiveClassesAtExit = const_cast<char *>(SharedArchiveFile);\n+            SharedArchivePath = get_default_shared_archive_path();\n+            SharedArchiveFile = nullptr;\n+          } else {\n+            no_shared_spaces(\"invalid archive\");\n+          }\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":22,"deletions":8,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -1810,0 +1810,3 @@\n+  product(bool, AutoCreateSharedArchive, false,                             \\\n+          \"Create shared archive at exit if cds mapping failed\")            \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,0 +60,1 @@\n+#include \"runtime\/arguments.hpp\"\n@@ -507,1 +508,3 @@\n-    assert(ArchiveClassesAtExit != NULL, \"Must be already set\");\n+    const char* archive_name =\n+       (ArchiveClassesAtExit != nullptr) ? ArchiveClassesAtExit : Arguments::GetSharedDynamicArchivePath();\n+    assert(archive_name != NULL, \"Must be already set\");\n@@ -509,1 +512,1 @@\n-    DynamicArchive::dump(ArchiveClassesAtExit, thread);\n+    DynamicArchive::dump(archive_name, thread);\n","filename":"src\/hotspot\/share\/runtime\/java.cpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -50,0 +50,2 @@\n+        String homeJava = java_home_src + File.separator + \"bin\" + File.separator + \"java\";\n+        String dstJava  = java_home_dst + File.separator + \"bin\" + File.separator + \"java\";\n@@ -55,1 +57,1 @@\n-            ProcessBuilder pb = makeBuilder(java_home_src + \"\/bin\/java\", \"-Xshare:dump\", jsaOpt);\n+            ProcessBuilder pb = CDSTestUtils.makeBuilder(homeJava, \"-Xshare:dump\", jsaOpt);\n@@ -60,5 +62,5 @@\n-            ProcessBuilder pb = makeBuilder(java_home_src + \"\/bin\/java\",\n-                                            \"-Xshare:auto\",\n-                                            jsaOpt,\n-                                            \"-Xlog:class+path=info\",\n-                                            \"-version\");\n+            ProcessBuilder pb = CDSTestUtils.makeBuilder(homeJava,\n+                                                         \"-Xshare:auto\",\n+                                                         jsaOpt,\n+                                                         \"-Xlog:class+path=info\",\n+                                                         \"-version\");\n@@ -71,1 +73,1 @@\n-        clone(new File(java_home_src), new File(java_home_dst));\n+        CDSTestUtils.clone(new File(java_home_src), new File(java_home_dst));\n@@ -76,5 +78,5 @@\n-            ProcessBuilder pb = makeBuilder(java_home_dst + \"\/bin\/java\",\n-                                            \"-Xshare:auto\",\n-                                            jsaOpt,\n-                                            \"-Xlog:class+path=info\",\n-                                            \"-version\");\n+            ProcessBuilder pb = CDSTestUtils.makeBuilder(dstJava,\n+                                                         \"-Xshare:auto\",\n+                                                         jsaOpt,\n+                                                         \"-Xlog:class+path=info\",\n+                                                         \"-version\");\n@@ -92,4 +94,4 @@\n-            ProcessBuilder pb = makeBuilder(java_home_src + \"\/bin\/java\",\n-                                            \"-Xshare:dump\",\n-                                            dumptimeBootAppendOpt,\n-                                            jsaOpt);\n+            ProcessBuilder pb = CDSTestUtils.makeBuilder(homeJava,\n+                                                         \"-Xshare:dump\",\n+                                                         dumptimeBootAppendOpt,\n+                                                         jsaOpt);\n@@ -101,6 +103,6 @@\n-            ProcessBuilder pb = makeBuilder(java_home_dst + \"\/bin\/java\",\n-                                            \"-Xshare:auto\",\n-                                            runtimeBootAppendOpt,\n-                                            jsaOpt,\n-                                            \"-Xlog:class+path=info\",\n-                                            \"-version\");\n+            ProcessBuilder pb = CDSTestUtils.makeBuilder(dstJava,\n+                                                         \"-Xshare:auto\",\n+                                                         runtimeBootAppendOpt,\n+                                                         jsaOpt,\n+                                                         \"-Xlog:class+path=info\",\n+                                                         \"-version\");\n@@ -114,1 +116,1 @@\n-        renameModulesFile(java_home_dst);\n+        CDSTestUtils.renameModulesFile(java_home_dst + File.separator + \"lib\", \"modules\", \"orig-modules\");\n@@ -116,2 +118,1 @@\n-            ProcessBuilder pb = makeBuilder(java_home_dst + \"\/bin\/java\",\n-                                            \"-version\");\n+            ProcessBuilder pb = CDSTestUtils.makeBuilder(dstJava, \"-version\");\n@@ -124,62 +125,0 @@\n-    \/\/ Do a cheap clone of the JDK. Most files can be sym-linked. However, $JAVA_HOME\/bin\/java and $JAVA_HOME\/lib\/...\/libjvm.so\"\n-    \/\/ must be copied, because the java.home property is derived from the canonicalized paths of these 2 files.\n-    static void clone(File src, File dst) throws Exception {\n-        if (dst.exists()) {\n-            if (!dst.isDirectory()) {\n-                throw new RuntimeException(\"Not a directory :\" + dst);\n-            }\n-        } else {\n-            if (!dst.mkdir()) {\n-                throw new RuntimeException(\"Cannot create directory: \" + dst);\n-            }\n-        }\n-        final String jvmLib = System.mapLibraryName(\"jvm\");\n-        for (String child : src.list()) {\n-            if (child.equals(\".\") || child.equals(\"..\")) {\n-                continue;\n-            }\n-\n-            File child_src = new File(src, child);\n-            File child_dst = new File(dst, child);\n-            if (child_dst.exists()) {\n-                throw new RuntimeException(\"Already exists: \" + child_dst);\n-            }\n-            if (child_src.isFile()) {\n-                if (child.equals(jvmLib) || child.equals(\"java\")) {\n-                    Files.copy(child_src.toPath(), \/* copy data to -> *\/ child_dst.toPath());\n-                } else {\n-                    Files.createSymbolicLink(child_dst.toPath(),  \/* link to -> *\/ child_src.toPath());\n-                }\n-            } else {\n-                clone(child_src, child_dst);\n-            }\n-        }\n-    }\n-\n-    static void renameModulesFile(String javaHome) throws Exception {\n-        String modulesDir = javaHome + File.separator + \"lib\";\n-        File origModules = new File(modulesDir, \"modules\");\n-        if (!origModules.exists()) {\n-            throw new RuntimeException(\"modules file not found\");\n-        }\n-\n-        File renamedModules = new File(modulesDir, \"orig_modules\");\n-        if (renamedModules.exists()) {\n-            throw new RuntimeException(\"found orig_modules unexpectedly\");\n-        }\n-\n-        boolean success = origModules.renameTo(renamedModules);\n-        if (!success) {\n-            throw new RuntimeException(\"rename modules file failed\");\n-        }\n-    }\n-\n-    static ProcessBuilder makeBuilder(String... args) throws Exception {\n-        System.out.print(\"[\");\n-        for (String s : args) {\n-            System.out.print(\" \" + s);\n-        }\n-        System.out.println(\" ]\");\n-        return new ProcessBuilder(args);\n-    }\n-\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/MoveJDKTest.java","additions":26,"deletions":87,"binary":false,"changes":113,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -184,3 +184,1 @@\n-        output.shouldContain(\"The shared archive file has the wrong version\")\n-              .shouldContain(\"_version expected: \" + currentCDSArchiveVersion)\n-              .shouldContain(\"actual: \" + version);\n+        output.shouldContain(\"The shared archive file version \" + version + \" which is not current version \" + currentCDSArchiveVersion);\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/SharedArchiveConsistency.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,0 @@\n-\n@@ -99,0 +98,13 @@\n+    \/**\n+     * Excute a JVM to dump a base archive by\n+     *  -Xshare:dump -XX:SharedArchiveFile=baseArchiveName\n+     *\/\n+    public static Result dumpBaseArchive(String baseArchiveName, String... cmdLineSuffix)\n+        throws Exception\n+    {\n+        OutputAnalyzer output = TestCommon.dumpBaseArchive(baseArchiveName, cmdLineSuffix);\n+        CDSOptions opts = new CDSOptions();\n+        opts.setXShareMode(\"dump\");\n+        return new Result(opts, output);\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/DynamicArchiveTestBase.java","additions":14,"deletions":2,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -0,0 +1,693 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8261455\n+ * @summary test -XX:+AutoCreateSharedArchive feature\n+ * @requires vm.cds\n+ * @library \/test\/lib \/test\/hotspot\/jtreg\/runtime\/cds\/appcds \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\/test-classes\n+ * @build Hello\n+ * @build sun.hotspot.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar hello.jar Hello\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar WhiteBox.jar sun.hotspot.WhiteBox\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\/WhiteBox.jar TestAutoCreateSharedArchive verifySharedSpacesOff\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\/WhiteBox.jar TestAutoCreateSharedArchive verifySharedSpacesOn\n+ *\/\n+\n+\/*\n+ * -XX:SharedArchiveFile can be specified in two styles:\n+ *\n+ *  (A) Test with default base archive -XX:+SharedArchiveFile=<archive>\n+ *  (B) Test with the base archive is specified: -XX:SharedArchiveFile=<base>:<file>\n+ *  all the following if not explained explicitly, run with flag -XX:+AutoCreateSharedArchive\n+ *\n+ *  Note VerifySharedSpaces will affect output so the tests run twice: one with -XX:+VerifySharedSpaces and the other with -XX:-VerifySharedSpaces\n+ *\n+ * 10 Case (A)\n+ *\n+ *   10.01 run with non-existing archive should automatically create dynamic archive.\n+ *        If the JDK's default CDS archive cannot be loaded, print out warning, run continue without shared archive and no shared archive created at exit.\n+ *   10.02 run with the created dynamic archive should pass.\n+ *   10.03 run with the created dynamic archive and -XX:+AutoCreateSharedArchive should pass and no shared archive created at exit.\n+ *\n+ * 11 run with static archive.\n+ *    run with static archive should printout warning and continue, share or no share depends on the archive validation at exit,\n+ *    no shared archive (top) will be generated.\n+ *\n+ * 12 run with damaged magic should not regenerate dynamic archive.\n+ *    if magic is not expected, no shared archive will be regenerated at exit.\n+ *\n+ * 13 run with a bad versioned archive.\n+ *   13.01  run with a bad versioned (< CDS_GENERIC_HEADER_SUPPORTED_MIN_VERSION) archive should not create dynamic archive at exit.\n+ *   13.02  run with a bad versioned (> CDS_GENERIC_HEADER_SUPPORTED_MIN_VERSION) archive should create dynamic archive at exit.\n+ *\n+ * 14 run with an archive whose base name is not matched, no shared archive at exit.\n+ *\n+ * 15 run with an archive whose jvm_ident is corrupted should\n+ *     create dynamic archive at exit with -XX:-VerifySharedSpaces\n+ *     not create dynamic archive at exit with -XX:+VerifySharedSpaces\n+ *\n+ * 16 run with an archive of only containing magic in the file (size of 4 bytes)\n+ *    the archive will be created at exit.\n+ *\n+ * 20 (case B)\n+ *\n+ *   20.01 dump base archive which will be used for dumping top archive.\n+ *   20.02 dump top archive based on base archive obtained in 20.1.\n+ *   20.03 run -XX:SharedArchiveFile=<base>:<top> to verify the archives.\n+ *   20.04 run with -XX:SharedArchveFile=base:top (reversed)\n+ *\n+ * 21 Mismatched versions\n+ *   21.01 if version of top archive is higher than CDS_GENERIC_HEADER_SUPPORTED_MIN_VERSION, the archive cannot be shared and will be\n+ *         regenerated at exit.\n+ *   21.02 if version of top archive is lower than CDS_GENERIC_HEADER_SUPPORTED_MIN_VERSION, the archive cannot be shared abd will be\n+ *         created at exit.\n+ *\n+ * 22 create an archive with dynamic magic number only\n+ *    archive will be created at exit if base can be shared.\n+ *\n+ * 23  mismatched jvm_indent in top archive\n+ *     23.01 mismatched jvm_indent in top archive\n+ *     23.02 mismatched jvm_indent in base archive\n+ *\n+ * 24 run with non-existing shared archives\n+ *   24.01 run -Xshare:auto -XX:+AutoCreateSharedArchive -XX:SharedArchiveFile=base.jsa:non-exist-top.jsa\n+ *     The top archive will be regenerated.\n+ *   24.02 run -Xshare:auto -XX:+AutoCreateSharedArchive -XX:SharedArchiveFile=non-exist-base.jsa:top.jsa\n+ *     top archive will not be shared. No shared archive will be generated.\n+ *\/\n+\n+import java.io.IOException;\n+import java.io.File;\n+\n+import java.nio.file.attribute.FileTime;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+\n+import jdk.test.lib.cds.CDSTestUtils;\n+import jdk.test.lib.cds.CDSArchiveUtils;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.helpers.ClassFileInstaller;\n+\n+public class TestAutoCreateSharedArchive extends DynamicArchiveTestBase {\n+    private static final String BASE_NAME = CDSTestUtils.getOutputFileName(\"base.jsa\");\n+    private static final String TOP_NAME  = CDSTestUtils.getOutputFileName(\"top.jsa\");\n+    private static final String mainAppClass = \"Hello\";\n+    private static final String HELLO_SOURCE = \"Hello source: shared objects file (top)\";\n+    private static final String HELLO_WORLD = \"Hello World\";\n+    private static boolean verifyOn = false;\n+\n+    private static int   genericHeaderMinVersion = CDSArchiveUtils.getGenericHeaderMinVersion();\n+    private static int   currentCDSVersion = CDSArchiveUtils.getCurrentCDSArchiveVersion();\n+\n+    public static void main(String[] args) throws Exception {\n+        if (args.length != 1 || (!args[0].equals(\"verifySharedSpacesOff\") && !args[0].equals(\"verifySharedSpacesOn\"))) {\n+            throw new RuntimeException(\"Must run with verifySharedSpacesOff or verifySharedSpacesOn\");\n+        }\n+        verifyOn = args[0].equals(\"verifySharedSpacesOn\");\n+        runTest(TestAutoCreateSharedArchive::testAutoCreateSharedArchive);\n+    }\n+\n+    public static void checkFileExists(String fileName) throws Exception {\n+        File file = new File(fileName);\n+        if (!file.exists()) {\n+             throw new IOException(\"Archive \" + fileName + \" is not automatically created\");\n+        }\n+    }\n+\n+    public static String startNewArchive(String testName) {\n+        String newArchiveName = TestCommon.getNewArchiveName(testName);\n+        TestCommon.setCurrentArchiveName(newArchiveName);\n+        return newArchiveName;\n+    }\n+\n+    public static void print(String message) {\n+        System.out.println(message);\n+    }\n+\n+    private static void testAutoCreateSharedArchive() throws Exception {\n+        String appJar = ClassFileInstaller.getJarPath(\"hello.jar\");\n+        boolean fileModified = false;\n+\n+        String VerifySharedSpaces = verifyOn ? \"-XX:+VerifySharedSpaces\" : \"-XX:-VerifySharedSpaces\";\n+        File archiveFile = new File(TOP_NAME);\n+        if (archiveFile.exists()) {\n+          archiveFile.delete();\n+        }\n+\n+        \/\/ dump a static archive, used later.\n+        \/\/ 0. Dump a static archive\n+        print(\"0. dump a static archive \" + BASE_NAME);\n+        dumpBaseArchive(BASE_NAME,\n+                        \"-Xlog:cds\",\n+                        \"-cp\", appJar,\n+                        mainAppClass)\n+            .assertNormalExit(output -> {\n+                output.shouldHaveExitValue(0);\n+            });\n+        checkFileExists(BASE_NAME);\n+\n+        \/\/ The list numbers try to match JDK-8272331 (CSR for JDK-8261455) test items but not exactly matched.\n+\n+        \/\/ 10 non-existing archive should automatically create dynamic archive based on default shared archive\n+        \/\/ if base archive loaded.\n+        print(\"10 Test with default base shared archive\");\n+        print(\"    10.1 run with non-existing archive should automatically create dynamic archive\");\n+        File fileTop = new File(TOP_NAME);\n+        if (fileTop.exists()) {\n+            fileTop.delete();\n+        }\n+        run(TOP_NAME,\n+            \"-Xshare:auto\",\n+            \"-XX:+AutoCreateSharedArchive\",\n+            \"-Xlog:cds\",\n+            \"-cp\", appJar,\n+            mainAppClass)\n+            .assertNormalExit(output -> {\n+                output.shouldHaveExitValue(0)\n+                      .shouldContain(HELLO_WORLD)\n+                      .shouldContain(\"Dumping shared data to file:\")\n+                      .shouldContain(TOP_NAME);\n+                });\n+        checkFileExists(TOP_NAME);\n+\n+        \/\/ 10.2 run with the created dynamic archive should pass\n+        print(\"    10.2 run with the created dynamic archive should pass\");\n+        run(TOP_NAME,\n+            \"-Xlog:cds\",\n+            \"-Xlog:class+load\",\n+            \"-cp\", appJar,\n+            mainAppClass)\n+            .assertNormalExit(output -> {\n+                output.shouldHaveExitValue(0)\n+                      .shouldContain(HELLO_WORLD)\n+                      .shouldContain(HELLO_SOURCE);\n+                });\n+        \/\/ remember the FileTime\n+        FileTime ft1 = Files.getLastModifiedTime(Paths.get(TOP_NAME));\n+\n+        \/\/ 10.3 run with the created dynamic archive with -XX:+AutoCreateSharedArchive should pass\n+        \/\/      archive should not be created again.\n+        print(\"    10.3 run with the created dynamic archive with -XX:+AutoCreateSharedArchive should pass\");\n+        run(TOP_NAME,\n+            \"-Xlog:cds\",\n+            \"-Xlog:class+load\",\n+            \"-Xlog:cds+dynamic=info\",\n+            \"-XX:+AutoCreateSharedArchive\",\n+            \"-cp\", appJar,\n+            mainAppClass)\n+            .assertNormalExit(output -> {\n+                output.shouldHaveExitValue(0)\n+                      .shouldContain(HELLO_WORLD)\n+                      .shouldContain(HELLO_SOURCE)\n+                      .shouldNotContain(\"Dumping shared data to file\");\n+                });\n+        FileTime ft2 = Files.getLastModifiedTime(Paths.get(TOP_NAME));\n+        fileModified = !ft2.equals(ft1);\n+        if (fileModified) {\n+            throw new RuntimeException(\"Archive file \" + TOP_NAME + \"  should not be updated\");\n+        }\n+\n+        \/\/ 11 run with static archive\n+        print(\"11 run with static archive\");\n+        ft1 = Files.getLastModifiedTime(Paths.get(BASE_NAME));\n+        run(BASE_NAME,\n+            \"-Xlog:cds\",\n+            \"-Xlog:cds+dynamic=info\",\n+            \"-Xshare:auto\",\n+            \"-XX:+AutoCreateSharedArchive\",\n+            VerifySharedSpaces,\n+            \"-cp\", appJar,\n+            mainAppClass)\n+            .assertNormalExit(output -> {\n+                output.shouldHaveExitValue(0)\n+                      .shouldContain(HELLO_WORLD)\n+                      .shouldContain(\"AutoCreateSharedArchive is ignored because \" + BASE_NAME + \" is a static archive\")\n+                      .shouldNotContain(\"Dumping shared data to file\");\n+                });\n+        ft2 = Files.getLastModifiedTime(Paths.get(BASE_NAME));\n+        fileModified = !ft1.equals(ft2);\n+        if (fileModified) {\n+            throw new RuntimeException(\"Run -XX:+AutoCreateSharedArchive on static archive create new archive\");\n+        }\n+\n+        \/\/ 12 run with damaged magic should not regenerate dynamic archive\n+        print(\"12 run with damaged magic should not regenerate dynamic archive\");\n+        String modMagic = startNewArchive(\"modify-magic\");\n+        File copiedJsa = CDSArchiveUtils.copyArchiveFile(archiveFile, modMagic);\n+        CDSArchiveUtils.modifyHeaderIntField(copiedJsa, CDSArchiveUtils.offsetMagic(), 0x1234);\n+        ft1 = Files.getLastModifiedTime(Paths.get(modMagic));\n+\n+        run(modMagic,\n+            \"-Xshare:auto\",\n+            \"-XX:+AutoCreateSharedArchive\",\n+            \"-Xlog:cds\",\n+            \"-Xlog:cds+dynamic=info\",\n+            VerifySharedSpaces,\n+            \"-cp\", appJar,\n+            mainAppClass)\n+            .assertNormalExit(output -> {\n+                output.shouldHaveExitValue(0)\n+                      .shouldContain(HELLO_WORLD)\n+                      .shouldNotContain(\"Dumping shared data to file\");\n+                });\n+        ft2 = Files.getLastModifiedTime(Paths.get(modMagic));\n+        fileModified = !ft1.equals(ft2);\n+        if (fileModified) {\n+            throw new RuntimeException(\"Shared archive \" + modMagic + \" should automatically be generated\");\n+        }\n+\n+        \/\/ 13 run with a bad versioned (< genericHeaderMinVersion) archive\n+        print(\"13 run with a bad versioned archive\");\n+        print(\"    13.01 run with a bad versioned (< genericHeaderMinVersion) archive should not create new archive\");\n+        String modVersion = startNewArchive(\"modify-version-b\");\n+        copiedJsa = CDSArchiveUtils.copyArchiveFile(archiveFile, modVersion);\n+        final int version1 = genericHeaderMinVersion - 1;\n+        CDSArchiveUtils.modifyHeaderIntField(copiedJsa, CDSArchiveUtils.offsetVersion(), version1);\n+        ft1 = Files.getLastModifiedTime(Paths.get(modVersion));\n+\n+        run(modVersion,\n+            \"-Xshare:auto\",\n+            \"-XX:+AutoCreateSharedArchive\",\n+            \"-Xlog:cds\",\n+            \"-Xlog:cds+dynamic=info\",\n+            VerifySharedSpaces,\n+            \"-cp\", appJar,\n+            mainAppClass)\n+            .assertNormalExit(output -> {\n+                output.shouldHaveExitValue(0)\n+                      .shouldContain(HELLO_WORLD)\n+                      .shouldContain(\"Cannot handle shared archive file version \" + version1 + \". Must be at least \" + genericHeaderMinVersion)\n+                      .shouldContain(\"Unable to use shared archive: invalid archive\")\n+                      .shouldNotContain(\"Dumping shared data to file\");\n+            });\n+        ft2 = Files.getLastModifiedTime(Paths.get(modVersion));\n+        fileModified = !ft1.equals(ft2);\n+        if (fileModified) {\n+            throw new RuntimeException(\"Run -XX:+AutoCreateSharedArchive with lower version archive \" + modVersion + \" should not create new archive\");\n+        }\n+        \/\/    13.02 run with a bad versioned (> currentCDSVersion) archive\n+        print(\"    13.02 run with a bad versioned (> currentCDSVersion) archive\");\n+        modVersion = startNewArchive(\"modify-version-d\");\n+        copiedJsa = CDSArchiveUtils.copyArchiveFile(archiveFile, modVersion);\n+        final int version2 = currentCDSVersion + 1;\n+        CDSArchiveUtils.modifyHeaderIntField(copiedJsa, CDSArchiveUtils.offsetVersion(), version2);\n+        ft1 = Files.getLastModifiedTime(Paths.get(modVersion));\n+\n+        run(modVersion,\n+            \"-Xshare:auto\",\n+            \"-XX:+AutoCreateSharedArchive\",\n+            \"-Xlog:cds\",\n+            \"-Xlog:cds+dynamic=info\",\n+            VerifySharedSpaces,\n+            \"-cp\", appJar,\n+            mainAppClass)\n+            .assertNormalExit(output -> {\n+                output.shouldHaveExitValue(0)\n+                      .shouldContain(HELLO_WORLD)\n+                      .shouldContain(\"The shared archive file version \" + version2 + \" which is not current version \" + currentCDSVersion)\n+                      .shouldContain(\"UseSharedSpaces: The shared archive file has the wrong version\")\n+                      .shouldContain(\"UseSharedSpaces: Initialize dynamic archive failed\")\n+                      .shouldContain(\"Dumping shared data to file\");\n+            });\n+        ft2 = Files.getLastModifiedTime(Paths.get(modVersion));\n+        fileModified = !ft1.equals(ft2);\n+        if (!fileModified) {\n+            throw new RuntimeException(\"Run -XX:+AutoCreateSharedArchive with higher version archive \" + modVersion + \" should create new archive\");\n+        }\n+\n+        \/\/ 14 run with an archive whose base name is not matched, no share\n+        print(\"14 run with an archive whose base name is not matched, no share\");\n+        String baseNameMismatch= startNewArchive(\"basename-mismatch\");\n+        copiedJsa = CDSArchiveUtils.copyArchiveFile(archiveFile, baseNameMismatch);\n+        int nameSize = CDSArchiveUtils.baseArchiveNameSize(copiedJsa);\n+        int offset = CDSArchiveUtils.baseArchiveNameOffset(copiedJsa);\n+        StringBuilder sb = new StringBuilder();\n+        for (int i = 0; i < nameSize - 4; i++) {\n+            sb.append('Z');\n+        }\n+        sb.append(\".jsa\");\n+        sb.append('\\0');\n+        String newName = sb.toString();\n+        CDSArchiveUtils.writeData(copiedJsa, offset, newName.getBytes());\n+\n+        ft1 = Files.getLastModifiedTime(Paths.get(baseNameMismatch));\n+        run(baseNameMismatch,\n+            \"-Xshare:auto\",\n+            \"-XX:+AutoCreateSharedArchive\",\n+            \"-Xlog:cds\",\n+            \"-Xlog:cds+dynamic=info\",\n+            VerifySharedSpaces,\n+            \"-cp\", appJar,\n+            mainAppClass)\n+            .assertNormalExit(output -> {\n+                output.shouldHaveExitValue(0)\n+                      .shouldContain(HELLO_WORLD)\n+                      .shouldNotContain(\"Dumping shared data to file\");\n+                });\n+        ft2 = Files.getLastModifiedTime(Paths.get(baseNameMismatch));\n+\n+        fileModified = !ft1.equals(ft2);\n+        if (fileModified) {\n+            throw new RuntimeException(\"Shared archive \" + baseNameMismatch+ \" should not automatically be generated\");\n+        }\n+\n+        \/\/ 15 mismatched jvm_indent in archive, create (-VerifySharedSpaces) or not (-XX:+VerifySharedSpaces) create the new archive\n+        print(\"15 mismatched jvm_indent in archive, \" + (verifyOn ? \"-XX:+VerifySharedSpaces not \" : \"-XX:-VerifySharedSpaces \") + \"create new archive\");\n+        String modJvmIdent = startNewArchive(\"modify-jvmident\");\n+        copiedJsa = CDSArchiveUtils.copyArchiveFile(archiveFile, modJvmIdent);\n+        CDSArchiveUtils.modifyHeaderIntField(copiedJsa, CDSArchiveUtils.offsetJvmIdent(), 0x65656565);\n+        ft1 = Files.getLastModifiedTime(Paths.get(modJvmIdent));\n+\n+        run(modJvmIdent,\n+            \"-Xshare:auto\",\n+            \"-XX:+AutoCreateSharedArchive\",\n+            \"-Xlog:cds\",\n+            \"-Xlog:cds+dynamic=info\",\n+            VerifySharedSpaces,\n+            \"-cp\", appJar,\n+            mainAppClass)\n+            .assertNormalExit(output -> {\n+                output.shouldHaveExitValue(0);\n+                if (verifyOn) {\n+                    output.shouldContain(\"UseSharedSpaces: Header checksum verification failed\")\n+                          .shouldContain(\"Unable to use shared archive: invalid archive\")\n+                          .shouldNotContain(\"Dumping shared data to file\");\n+                } else {\n+                    output.shouldContain(HELLO_WORLD)\n+                          .shouldContain(\"Dumping shared data to file\");\n+                }\n+            });\n+        ft2 = Files.getLastModifiedTime(Paths.get(modJvmIdent));\n+        fileModified = !ft1.equals(ft2);\n+        if (verifyOn) {\n+            if (fileModified) {\n+                throw new RuntimeException(\"Shared archive \" + modJvmIdent + \" should not be generated\");\n+            }\n+\n+        } else {\n+            if (!fileModified) {\n+                throw new RuntimeException(\"Shared archive \" + modJvmIdent + \" should be generated\");\n+            }\n+        }\n+\n+        \/\/ 16 run with an archive of only containing dynamic magic (size of 4) will not create new archive at exit\n+        print(\"16 run with an archive of only containing dynamic magic (size of 4) will not create new archive at exit\");\n+        String magicOnly = startNewArchive(\"magic-only\");\n+        copiedJsa = CDSArchiveUtils.createMagicOnlyFile(magicOnly, false\/*dynamic*\/);\n+        ft1 = Files.getLastModifiedTime(Paths.get(magicOnly));\n+        run(magicOnly,\n+            \"-Xshare:auto\",\n+            \"-XX:+AutoCreateSharedArchive\",\n+            \"-Xlog:cds\",\n+            \"-Xlog:cds+dynamic=info\",\n+            \"-cp\", appJar,\n+            mainAppClass)\n+            .assertNormalExit(output -> {\n+                output.shouldHaveExitValue(0)\n+                      .shouldContain(HELLO_WORLD)\n+                      .shouldContain(\"Unable to read generic CDS file map header from shared archive\")\n+                      .shouldNotContain(\"Dumping shared data to file:\");\n+                });\n+        ft2 = Files.getLastModifiedTime(Paths.get(magicOnly));\n+        fileModified = !ft1.equals(ft2);\n+        if (fileModified) {\n+            throw new RuntimeException(\"Shared archive \" + magicOnly + \" should not automatically be generated\");\n+        }\n+\n+        \/\/ Do some base tests for -XX:SharedArchiveFile=base:top, they should be same as default archive as base.\n+        \/\/ delete top archive\n+        if (archiveFile.exists()) {\n+            archiveFile.delete();\n+        }\n+        \/\/ delete base archive\n+        File baseFile = new File(BASE_NAME);\n+        if (baseFile.exists()) {\n+            baseFile.delete();\n+        }\n+\n+        \/\/ 20 Testing with -XX:SharedArchiveFile=base:top\n+        print(\"20 Testing with -XX:SharedArchiveFile=base:top\");\n+        \/\/ 20.01 dump base archive and top archive\n+        print(\"    20.01 dump base archive \" + BASE_NAME);\n+        dumpBaseArchive(BASE_NAME, \"-Xlog:cds\")\n+            .assertNormalExit(output -> {\n+                output.shouldHaveExitValue(0);\n+            });\n+        checkFileExists(BASE_NAME);\n+\n+        \/\/ 20.02 dump top based on base\n+        print(\"    20.02 dump top based on base\");\n+        dump2(BASE_NAME, TOP_NAME,\n+              \"-Xlog:cds\",\n+              \"-cp\", appJar, mainAppClass)\n+              .assertNormalExit(output -> {\n+                  output.shouldHaveExitValue(0)\n+                        .shouldContain(\"Dumping shared data to file:\")\n+                        .shouldContain(TOP_NAME);\n+              });\n+        checkFileExists(TOP_NAME);\n+\n+        \/\/ 20.03 run with -XX:SharedArchveFile=top:base\n+        print(\"    20.03 run with -XX:SharedArchveFile=top:base\");\n+        run2(BASE_NAME, TOP_NAME,\n+             \"-Xlog:cds\",\n+             \"-Xlog:cds+dynamic=info\",\n+             \"-Xlog:class+load\",\n+             \"-cp\", appJar,\n+             mainAppClass)\n+            .assertNormalExit(output -> {\n+                output.shouldHaveExitValue(0)\n+                      .shouldContain(HELLO_SOURCE);\n+            });\n+\n+        \/\/ 20.04 run with -XX:SharedArchveFile=base:top (reversed)\n+        print(\"    20.04 run with -XX:SharedArchveFile=base:top (reversed)\");\n+        run2(TOP_NAME, BASE_NAME,\n+             \"-Xlog:cds\",\n+             \"-Xlog:cds+dynamic=info\",\n+             \"-Xlog:class+load\",\n+             \"-cp\", appJar,\n+             mainAppClass)\n+            .assertAbnormalExit(output -> {\n+                output.shouldHaveExitValue(1)\n+                      .shouldContain(\"Not a base shared archive: \" + TOP_NAME)\n+                      .shouldContain(\"An error has occurred while processing the shared archive file\")\n+                      .shouldNotContain(HELLO_WORLD);\n+            });\n+\n+        \/\/ 21 Mismatched versions\n+        print(\"21 Mismatched versions\");\n+        \/\/   21.01 top version is lower than CDS_GENERIC_HEADER_SUPPORTED_MIN_VERSION, regenerate top\n+        print(\"  21.01 top version is lower than CDS_GENERIC_HEADER_SUPPORTED_MIN_VERSION, regenerate top\");\n+        String versionB = startNewArchive(\"modify-version-B\");\n+        archiveFile = new File(TOP_NAME);\n+        copiedJsa = CDSArchiveUtils.copyArchiveFile(archiveFile, versionB);\n+        CDSArchiveUtils.modifyHeaderIntField(copiedJsa, CDSArchiveUtils.offsetVersion(), version1);\n+        ft1 = Files.getLastModifiedTime(Paths.get(versionB));\n+\n+        run2(BASE_NAME, versionB,\n+             \"-Xshare:auto\",\n+             \"-XX:+AutoCreateSharedArchive\",\n+             \"-Xlog:cds\",\n+             \"-Xlog:cds+dynamic=info\",\n+             VerifySharedSpaces,\n+             \"-cp\", appJar,\n+             mainAppClass)\n+             .assertNormalExit(output -> {\n+                 output.shouldHaveExitValue(0)\n+                       .shouldContain(HELLO_WORLD)\n+                       .shouldContain(\"Cannot handle shared archive file version \" + version1)\n+                       .shouldContain(versionB)\n+                       .shouldContain(\"Dumping shared data to file:\");\n+             });\n+        ft2 = Files.getLastModifiedTime(Paths.get(versionB));\n+        fileModified = !ft1.equals(ft2);\n+        if (!fileModified) {\n+            throw new RuntimeException(\"Shared archive \" + versionB + \" should automatically be generated\");\n+        }\n+\n+        \/\/   21.02 top version is higher than CDS_GENERIC_HEADER_SUPPORTED_MIN_VERSION, no share for top, create archive at exit\n+        print(\"  21.02 top version is higher than CDS_GENERIC_HEADER_SUPPORTED_MIN_VERSION, no share for top, create archive at exit\");\n+        String versionF = startNewArchive(\"versionF\");\n+        copiedJsa = CDSArchiveUtils.copyArchiveFile(archiveFile, versionF);\n+        CDSArchiveUtils.modifyHeaderIntField(copiedJsa, CDSArchiveUtils.offsetVersion(), version2);\n+        ft1 = Files.getLastModifiedTime(Paths.get(versionF));\n+        run2(BASE_NAME, versionF,\n+             \"-Xshare:auto\",\n+             \"-XX:+AutoCreateSharedArchive\",\n+             \"-Xlog:cds\",\n+             \"-Xlog:cds+dynamic=info\",\n+             VerifySharedSpaces,\n+             \"-cp\", appJar,\n+             mainAppClass)\n+             .assertNormalExit(output -> {\n+                 output.shouldContain(\"The shared archive file version \" + version2 + \" which is not current version \" + currentCDSVersion)\n+                       .shouldContain(HELLO_WORLD)\n+                       .shouldContain(\"Dumping shared data to file:\");\n+             });\n+        ft2 = Files.getLastModifiedTime(Paths.get(versionB));\n+        fileModified = !ft1.equals(ft2);\n+        if (!fileModified) {\n+            throw new RuntimeException(\"Shared archive \" + versionB + \" should be created at exit\");\n+        }\n+\n+        \/\/ 22 create an archive with dynamic magic number only\n+        \/\/    archive will be created at exit if base can be shared.\n+        print(\"22 create an archive with dynamic magic number only\");\n+        copiedJsa = CDSArchiveUtils.createMagicOnlyFile(magicOnly, false \/*dynamic*\/);\n+        ft1 = Files.getLastModifiedTime(Paths.get(magicOnly));\n+        run2(BASE_NAME, magicOnly,\n+             \"-Xshare:auto\",\n+             \"-XX:+AutoCreateSharedArchive\",\n+             \"-Xlog:cds\",\n+             \"-Xlog:cds+dynamic=info\",\n+             VerifySharedSpaces,\n+             \"-cp\", appJar,\n+             mainAppClass)\n+             .assertNormalExit(output -> {\n+                 output.shouldContain(HELLO_WORLD)\n+                       .shouldContain(\"Unable to read generic CDS file map header from shared archive\")\n+                       .shouldContain(\"Dumping shared data to file:\");\n+             });\n+        ft2 = Files.getLastModifiedTime(Paths.get(magicOnly));\n+        fileModified = !ft1.equals(ft2);\n+        if (!fileModified) {\n+            throw new RuntimeException(\"Shared archive \" + magicOnly + \" should not be created at exit\");\n+        }\n+\n+        \/\/ 23  mismatched jvm_indent in top archive\n+        \/\/    23.01 mismatched jvm_indent in top archive\n+        print(\"    23.01  mismatched jvm_indent in archive\");\n+        String modJvmIdentTop = startNewArchive(\"modify-jvmident-top\");\n+        copiedJsa = CDSArchiveUtils.copyArchiveFile(archiveFile, modJvmIdentTop);\n+        CDSArchiveUtils.modifyHeaderIntField(copiedJsa, CDSArchiveUtils.offsetJvmIdent(), 0x65656565);\n+        ft1 = Files.getLastModifiedTime(Paths.get(modJvmIdentTop));\n+\n+        run2(BASE_NAME, modJvmIdentTop,\n+            \"-Xshare:auto\",\n+            \"-XX:+AutoCreateSharedArchive\",\n+            \"-Xlog:cds\",\n+            \"-Xlog:cds+dynamic=info\",\n+            VerifySharedSpaces,\n+            \"-cp\", appJar,\n+            mainAppClass)\n+            .assertNormalExit(output -> {\n+                output.shouldHaveExitValue(0);\n+                if (verifyOn) {\n+                    output.shouldContain(\"UseSharedSpaces: Header checksum verification failed\");\n+                }\n+                output.shouldContain(HELLO_WORLD)\n+                      .shouldContain(\"Dumping shared data to file\");\n+            });\n+        ft2 = Files.getLastModifiedTime(Paths.get(modJvmIdentTop));\n+        fileModified = !ft1.equals(ft2);\n+        if (!fileModified) {\n+            throw new RuntimeException(\"Shared archive \" + modJvmIdentTop + \" should be generated\");\n+        }\n+        \/\/    23.02 mismatched jvm_indent in base archive -Xshare:auto -XX:SahredArchiveFile=base:top\n+        print(\"    23.02  mismatched jvm_indent in base archive, -Xshare:auto -XX:SahredArchiveFile=base:top\");\n+        String modJvmIdentBase = startNewArchive(\"modify-jvmident-base\");\n+        copiedJsa = CDSArchiveUtils.copyArchiveFile(new File(BASE_NAME), modJvmIdentBase);\n+        CDSArchiveUtils.modifyHeaderIntField(copiedJsa, CDSArchiveUtils.offsetJvmIdent(), 0x65656565);\n+        ft1 = Files.getLastModifiedTime(Paths.get(TOP_NAME));\n+\n+        run2(modJvmIdentBase, TOP_NAME,\n+            \"-Xshare:auto\",\n+            \"-XX:+AutoCreateSharedArchive\",\n+            \"-Xlog:cds\",\n+            \"-Xlog:cds+dynamic=info\",\n+            VerifySharedSpaces,\n+            \"-cp\", appJar,\n+            mainAppClass)\n+            .assertNormalExit(output -> {\n+                output.shouldHaveExitValue(0)\n+                      .shouldContain(HELLO_WORLD);\n+                if (verifyOn) {\n+                    output.shouldContain(\"UseSharedSpaces: Header checksum verification failed\");\n+                }\n+                output.shouldContain(\"Unable to map shared spaces\")\n+                      .shouldNotContain(\"Dumping shared data to file\");\n+            });\n+        ft2 = Files.getLastModifiedTime(Paths.get(TOP_NAME));\n+        fileModified = !ft1.equals(ft2);\n+        if (fileModified) {\n+            throw new RuntimeException(\"Shared archive \" + TOP_NAME + \" should not be generated\");\n+        }\n+\n+        \/\/ 24 run with non-existing shared archives\n+        print(\"24 run with non-existing shared archives\");\n+        \/\/   24.01 run -Xshare:auto -XX:+AutoCreateSharedArchive -XX:SharedArchiveFile=base.jsa:non-exist-top.jsa\n+        print(\"    24.01 run -Xshare:auto -XX:+AutoCreateSharedArchive -XX:SharedArchiveFile=base.jsa:non-exist-top.jsa\");\n+        String nonExistTop = \"non-existing-top.jsa\";\n+        File fileNonExist = new File(nonExistTop);\n+        if (fileNonExist.exists()) {\n+            fileNonExist.delete();\n+        }\n+        run2(BASE_NAME, nonExistTop,\n+             \"-Xshare:auto\",\n+             \"-XX:+AutoCreateSharedArchive\",\n+             \"-Xlog:cds\",\n+             \"-Xlog:cds+dynamic=info\",\n+             VerifySharedSpaces,\n+             \"-cp\", appJar,\n+             mainAppClass)\n+             .assertNormalExit(output -> {\n+                 output.shouldContain(\"Specified shared archive not found (\" + nonExistTop + \")\")\n+                       .shouldContain(HELLO_WORLD)\n+                       .shouldContain(\"Dumping shared data to file:\");\n+             });\n+        if (!fileNonExist.exists()) {\n+            throw new RuntimeException(\"Shared archive \" + nonExistTop + \" should be created at exit\");\n+        }\n+\n+        \/\/    24.02 run -Xshare:auto -XX:+AutoCreateSharedArchive -XX:SharedArchiveFile=non-exist-base.jsa:top.jsa\n+        print(\"    24.02 run -Xshare:auto -XX:+AutoCreateSharedArchive -XX:SharedArchiveFile=non-exist-base.jsa:top.jsa\");\n+        String nonExistBase = \"non-existing-base.jsa\";\n+        fileNonExist = new File(nonExistBase);\n+        if (fileNonExist.exists()) {\n+            fileNonExist.delete();\n+        }\n+        ft1 = Files.getLastModifiedTime(Paths.get(TOP_NAME));\n+        run2(nonExistBase, TOP_NAME,\n+             \"-Xshare:auto\",\n+             \"-XX:+AutoCreateSharedArchive\",\n+             \"-Xlog:cds\",\n+             \"-Xlog:cds+dynamic=info\",\n+             VerifySharedSpaces,\n+             \"-cp\", appJar,\n+             mainAppClass)\n+             .assertNormalExit(output -> {\n+                 output.shouldContain(\"Specified shared archive not found (\" + nonExistBase + \")\")\n+                       .shouldContain(HELLO_WORLD)\n+                       .shouldNotContain(\"Dumping shared data to file:\");\n+             });\n+        ft2 = Files.getLastModifiedTime(Paths.get(TOP_NAME));\n+        fileModified = !ft1.equals(ft2);\n+        if (fileModified) {\n+            throw new RuntimeException(\"Shared archive \" + TOP_NAME + \" should be created at exit\");\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/TestAutoCreateSharedArchive.java","additions":693,"deletions":0,"binary":false,"changes":693,"status":"added"},{"patch":"@@ -0,0 +1,146 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Test -XX:+AutoCreateSharedArchive on a copied JDK without default shared archive\n+ * @bug 8261455\n+ * @requires vm.cds\n+ * @requires vm.flagless\n+ * @comment This test doesn't work on Windows because it depends on symlinks\n+ * @requires os.family != \"windows\"\n+ * @library \/test\/lib \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\n+ * @compile ..\/test-classes\/Hello.java\n+ * @run driver TestAutoCreateSharedArchiveNoDefaultArchive\n+ *\/\n+\n+import java.io.File;\n+import jdk.test.lib.cds.CDSTestUtils;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+public class TestAutoCreateSharedArchiveNoDefaultArchive {\n+    public static void main(String[] args) throws Exception {\n+        String mainClass = \"Hello\";\n+        String java_home_src = System.getProperty(\"java.home\");\n+        String java_home_dst = CDSTestUtils.getOutputDir() + File.separator + \"moved_jdk\";\n+        CDSTestUtils.clone(new File(java_home_src), new File(java_home_dst));\n+        System.out.println(\"======== Cloned JDK at \" + java_home_dst);\n+\n+        String homeJava = java_home_src + File.separator + \"bin\" + File.separator + \"java\";\n+        String dstJava  = java_home_dst + File.separator + \"bin\" + File.separator + \"java\";\n+\n+        TestCommon.startNewArchiveName();\n+        String jsaFileName = TestCommon.getCurrentArchiveName();\n+        File jsaFile = new File(jsaFileName);\n+        if (jsaFile.exists()) {\n+            jsaFile.delete();\n+        }\n+\n+        String jsaOpt = \"-XX:SharedArchiveFile=\" + jsaFileName;\n+        String autoCreateArchive = \"-XX:+AutoCreateSharedArchive\";\n+        {\n+            ProcessBuilder pb = CDSTestUtils.makeBuilder(homeJava,\n+                                                         \"-Xshare:dump\",\n+                                                         jsaOpt);\n+            TestCommon.executeAndLog(pb, \"dump\")\n+                      .shouldHaveExitValue(0);\n+        }\n+        {\n+            ProcessBuilder pb = CDSTestUtils.makeBuilder(homeJava,\n+                                                         \"-Xshare:auto\",\n+                                                         jsaOpt,\n+                                                         \"-Xlog:class+path=info\",\n+                                                         \"-version\");\n+            OutputAnalyzer out = TestCommon.executeAndLog(pb, \"exec-src\");\n+            out.shouldHaveExitValue(0);\n+            out.shouldNotContain(\"shared class paths mismatch\");\n+            out.shouldNotContain(\"BOOT classpath mismatch\");\n+        }\n+\n+        String helloJar = JarBuilder.getOrCreateHelloJar();\n+\n+        if (jsaFile.exists()) {\n+            jsaFile.delete();\n+        }\n+        \/\/ Test runtime with cloned JDK\n+        System.out.println(\"======== run with cloned jdk to created dynamic shared archive at exit\");\n+        {\n+            ProcessBuilder pb = CDSTestUtils.makeBuilder(dstJava,\n+                                                         \"-Xshare:auto\",\n+                                                         autoCreateArchive,\n+                                                         jsaOpt,\n+                                                         \"-Xlog:cds\",\n+                                                         \"-Xlog:class+path=info\",\n+                                                         \"-cp\", helloJar,\n+                                                         mainClass);\n+            OutputAnalyzer out = TestCommon.executeAndLog(pb, \"exec-dst\");\n+            out.shouldHaveExitValue(0);\n+            out.shouldContain(\"Dumping shared data to file\");\n+            if (!jsaFile.exists()) {\n+                throw new RuntimeException(\"Shared archive \" + jsaFileName + \" should be created at exit\");\n+            }\n+        }\n+\n+        \/\/ Now rename classes.jsa to old-classes.jsa\n+        String dstDir = java_home_dst + File.separator + \"lib\" + File.separator + \"server\";\n+\tCDSTestUtils.renameModulesFile(dstDir, \"classes.jsa\", \"old-classes.jsa\");\n+\tSystem.out.println(\"======= renamed \" + dstDir + File.separator + \"classes.jsa to old-classes.jsa\");\n+\n+        {\n+            ProcessBuilder pb = CDSTestUtils.makeBuilder(dstJava,\n+                                                         \"-Xlog:cds\",\n+                                                         \"-version\");\n+            TestCommon.executeAndLog(pb, \"show-version\")\n+                      .shouldHaveExitValue(0)\n+                      .shouldContain(\"UseSharedSpaces: Initialize static archive failed\")\n+                      .shouldContain(\"UseSharedSpaces: Unable to map shared spaces\")\n+                      .shouldContain(\"mixed mode\")\n+                      .shouldNotContain(\"sharing\");\n+        }\n+        \/\/ delete existing jsa file\n+        if (jsaFile.exists()) {\n+            jsaFile.delete();\n+        }\n+        System.out.println(\"======= run with no default shared archive should no create shared archive at exit\");\n+        {\n+            ProcessBuilder pb = CDSTestUtils.makeBuilder(dstJava,\n+                                                         \"-Xshare:auto\",\n+                                                         autoCreateArchive,\n+                                                         jsaOpt,\n+                                                         \"-Xlog:cds\",\n+                                                         \"-Xlog:class+path=info\",\n+                                                         \"-cp\", helloJar,\n+                                                         mainClass);\n+            TestCommon.executeAndLog(pb, \"no-default-archive\")\n+                      .shouldHaveExitValue(0)\n+                      .shouldContain(\"UseSharedSpaces: Initialize static archive failed\")\n+                      .shouldContain(\"UseSharedSpaces: Unable to map shared spaces\")\n+                      .shouldNotContain(\"Dumping shared data to file\");\n+            if (jsaFile.exists()) {\n+                throw new RuntimeException(\"Archive file \" + jsaFileName + \" should not be created at exit\");\n+            }\n+        }\n+\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/TestAutoCreateSharedArchiveNoDefaultArchive.java","additions":146,"deletions":0,"binary":false,"changes":146,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -344,0 +344,12 @@\n+    public static File createMagicOnlyFile(String fileName, boolean createStatic) throws Exception {\n+        File file = new File(fileName);\n+        if (file.exists()) {\n+            file.delete();\n+        }\n+        try (FileOutputStream out = new FileOutputStream(file)) {\n+            ByteBuffer buffer = ByteBuffer.allocate(4).putInt(createStatic ? staticMagic: dynamicMagic);\n+            out.write(buffer.array(), 0, 4);\n+        }\n+        return file;\n+    }\n+\n","filename":"test\/lib\/jdk\/test\/lib\/cds\/CDSArchiveUtils.java","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,3 @@\n+import java.nio.file.Files;\n+import java.nio.file.CopyOption;\n+import java.nio.file.StandardCopyOption;\n@@ -687,0 +690,76 @@\n+\n+    \/\/ JDK utility\n+\n+    \/\/ Do a cheap clone of the JDK. Most files can be sym-linked. However, $JAVA_HOME\/bin\/java and $JAVA_HOME\/lib\/...\/libjvm.so\"\n+    \/\/ must be copied, because the java.home property is derived from the canonicalized paths of these 2 files.\n+    \/\/ Set a list of {jvm, \"java\"} which will be physically copied. If a file needs copied physically, add it to the list.\n+    private static String[] phCopied = {System.mapLibraryName(\"jvm\"), \"java\"};\n+    public static void clone(File src, File dst) throws Exception {\n+        if (dst.exists()) {\n+            if (!dst.isDirectory()) {\n+                throw new RuntimeException(\"Not a directory :\" + dst);\n+            }\n+        } else {\n+            if (!dst.mkdir()) {\n+                throw new RuntimeException(\"Cannot create directory: \" + dst);\n+            }\n+        }\n+        \/\/ final String jvmLib = System.mapLibraryName(\"jvm\");\n+        for (String child : src.list()) {\n+            if (child.equals(\".\") || child.equals(\"..\")) {\n+                continue;\n+            }\n+\n+            File child_src = new File(src, child);\n+            File child_dst = new File(dst, child);\n+            if (child_dst.exists()) {\n+                throw new RuntimeException(\"Already exists: \" + child_dst);\n+            }\n+            if (child_src.isFile()) {\n+                boolean needPhCopy = false;\n+                for (String target : phCopied) {\n+                    if (child.equals(target)) {\n+                        needPhCopy = true;\n+                        break;\n+                    }\n+                }\n+                if (needPhCopy) {\n+                    Files.copy(child_src.toPath(), \/* copy data to -> *\/ child_dst.toPath(),\n+                               new CopyOption[] { StandardCopyOption.REPLACE_EXISTING, StandardCopyOption.COPY_ATTRIBUTES});\n+                } else {\n+                    Files.createSymbolicLink(child_dst.toPath(),  \/* link to -> *\/ child_src.toPath());\n+                }\n+            } else {\n+                clone(child_src, child_dst);\n+            }\n+        }\n+    }\n+\n+    \/\/ modulesDir, like $JDK\/lib\n+    \/\/ oldName, module name under modulesDir\n+    \/\/ newName, new name for oldName\n+    public static void renameModulesFile(String modulesDir, String oldName, String newName) throws Exception {\n+        File origModules = new File(modulesDir, oldName);\n+        if (!origModules.exists()) {\n+            throw new RuntimeException(oldName + \" file not found\");\n+        }\n+\n+        File renamedModules = new File(modulesDir, newName);\n+        if (renamedModules.exists()) {\n+            throw new RuntimeException(newName + \" found unexpectedly\");\n+        }\n+\n+        boolean success = origModules.renameTo(renamedModules);\n+        if (!success) {\n+            throw new RuntimeException(\"rename file \" + oldName + \" to \" + newName + \" failed\");\n+        }\n+    }\n+\n+    public static ProcessBuilder makeBuilder(String... args) throws Exception {\n+        System.out.print(\"[\");\n+        for (String s : args) {\n+            System.out.print(\" \" + s);\n+        }\n+        System.out.println(\" ]\");\n+        return new ProcessBuilder(args);\n+    }\n","filename":"test\/lib\/jdk\/test\/lib\/cds\/CDSTestUtils.java","additions":80,"deletions":1,"binary":false,"changes":81,"status":"modified"}]}