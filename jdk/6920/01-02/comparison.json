{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -181,6 +181,0 @@\n-  bool valid = validate_archive();\n-  if (!valid && !_is_static && AutoCreateSharedArchive) {\n-    \/\/ regenerate shared archive at exit\n-    DynamicDumpSharedSpaces = true;\n-    ArchiveClassesAtExit = _full_path;\n-  }\n@@ -204,15 +198,0 @@\n-\/\/ Do preliminary validation on archive. More checks are in initialization.\n-bool FileMapInfo::validate_archive() const {\n-  \/\/ in case file name is NULL, os::file_exists will return false but\n-  \/\/ check_archive will fail due to os::open crash on NULL.\n-  if (!os::file_exists(_full_path)) {\n-    return false;\n-  }\n-  \/\/ validate header info\n-  if (!check_archive(_full_path, _is_static)) {\n-    return false;\n-  }\n-\n-  return true;\n-}\n-\n@@ -1079,0 +1058,1 @@\n+  bool _is_static;\n@@ -1080,0 +1060,1 @@\n+  const char* _archive_name;\n@@ -1083,1 +1064,8 @@\n-  FileHeaderHelper() : _fd(-1), _is_valid(false), _header(nullptr), _base_archive_name(nullptr) {}\n+  FileHeaderHelper(const char* archive_name, bool is_static) {\n+    _fd = -1;\n+    _is_valid = false;\n+    _header = nullptr;\n+    _base_archive_name = nullptr;\n+    _archive_name = archive_name;\n+    _is_static = is_static;\n+  }\n@@ -1091,3 +1079,3 @@\n-  bool initialize(const char* archive_name) {\n-    log_info(cds)(\"Opening shared archive: %s\", archive_name);\n-    _fd = os::open(archive_name, O_RDONLY | O_BINARY, 0);\n+  bool initialize() {\n+    assert(_archive_name != nullptr, \"Archive name is NULL\");\n+    _fd = os::open(_archive_name, O_RDONLY | O_BINARY, 0);\n@@ -1095,1 +1083,1 @@\n-      FileMapInfo::fail_continue(\"Specified shared archive not found (%s)\", archive_name);\n+      FileMapInfo::fail_continue(\"Specified shared archive not found (%s)\", _archive_name);\n@@ -1103,3 +1091,2 @@\n-    assert(fd != -1, \"Archive should be opened\");\n-\n-\n+    assert(_archive_name != nullptr, \"Archive name is NULL\");\n+    assert(fd != -1, \"Archive must be opened already\");\n@@ -1129,2 +1116,1 @@\n-      auto warning_continue = FileMapInfo::fail_continue;\n-      warning_continue(\"The shared archive file version %d which is not current version %d\",\n+      FileMapInfo::fail_continue(\"The shared archive file version %d which is not current version %d\",\n@@ -1239,22 +1225,0 @@\n-bool FileMapInfo::check_archive(const char* archive_name, bool is_static) {\n-  FileHeaderHelper file_helper;\n-  if (!file_helper.initialize(archive_name)) {\n-    \/\/ Any errors are reported by fail_continue().\n-    return false;\n-  }\n-\n-  GenericCDSFileMapHeader* header = file_helper.get_generic_file_header();\n-  if (is_static) {\n-    if (header->_magic != CDS_ARCHIVE_MAGIC) {\n-      fail_continue(\"Not a base shared archive: %s\", archive_name);\n-      return false;\n-    }\n-  } else {\n-    if (header->_magic != CDS_DYNAMIC_ARCHIVE_MAGIC) {\n-      fail_continue(\"Not a top shared archive: %s\", archive_name);\n-      return false;\n-    }\n-  }\n-  return true;\n-}\n-\n@@ -1270,1 +1234,1 @@\n-  FileHeaderHelper file_helper;\n+  FileHeaderHelper file_helper(archive_name, false);\n@@ -1273,1 +1237,1 @@\n-  if (!file_helper.initialize(archive_name)) {\n+  if (!file_helper.initialize()) {\n@@ -1279,0 +1243,3 @@\n+    if (AutoCreateSharedArchive) {\n+      warning(\"AutoCreateSharedArchive is ignored because %s is a static archive\", archive_name);\n+    }\n@@ -1295,1 +1262,1 @@\n-  FileHeaderHelper file_helper;\n+  FileHeaderHelper file_helper(_full_path, _is_static);\n@@ -1302,0 +1269,12 @@\n+  if (_is_static) {\n+    if (gen_header->_magic != CDS_ARCHIVE_MAGIC) {\n+      FileMapInfo::fail_continue(\"Not a base shared archive: %s\", _full_path);\n+      return false;\n+    }\n+  } else {\n+    if (gen_header->_magic != CDS_DYNAMIC_ARCHIVE_MAGIC) {\n+      FileMapInfo::fail_continue(\"Not a top shared archive: %s\", _full_path);\n+      return false;\n+    }\n+  }\n+\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":36,"deletions":57,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -362,1 +362,0 @@\n-  static bool check_archive(const char* archive_name, bool is_static);\n@@ -371,1 +370,0 @@\n-  bool validate_archive() const;\n","filename":"src\/hotspot\/share\/cds\/filemap.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -959,0 +959,6 @@\n+    if (AutoCreateSharedArchive) {\n+      AutoCreateSharedArchive = false;\n+    }\n+    if (DynamicDumpSharedSpaces) {\n+      DynamicDumpSharedSpaces = false;\n+    }\n@@ -1027,4 +1033,0 @@\n-  if (AutoCreateSharedArchive && static_mapinfo != NULL && dynamic_mapinfo == NULL) {\n-    warning(\"AutoCreateSharedArchive will be ignored for static archive\");\n-  }\n-\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -3145,1 +3145,1 @@\n-      log_info(cds)(\"-XX:+AutoCreateSharedArchive must work with a valid SharedArchiveFile\");\n+      log_warning(cds)(\"-XX:+AutoCreateSharedArchive requires -XX:SharedArchiveFile\");\n@@ -3149,1 +3149,1 @@\n-      log_info(cds)(\"-XX:+AutoCreateSharedArchive does not work with ArchiveClassesAtExit\");\n+      log_warning(cds)(\"-XX:+AutoCreateSharedArchive does not work with ArchiveClassesAtExit\");\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/runtime\/java.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -50,0 +50,2 @@\n+        String homeJava = java_home_src + File.separator + \"bin\" + File.separator + \"java\";\n+        String dstJava  = java_home_dst + File.separator + \"bin\" + File.separator + \"java\";\n@@ -55,1 +57,1 @@\n-            ProcessBuilder pb = makeBuilder(java_home_src + \"\/bin\/java\", \"-Xshare:dump\", jsaOpt);\n+            ProcessBuilder pb = CDSTestUtils.makeBuilder(homeJava, \"-Xshare:dump\", jsaOpt);\n@@ -60,5 +62,5 @@\n-            ProcessBuilder pb = makeBuilder(java_home_src + \"\/bin\/java\",\n-                                            \"-Xshare:auto\",\n-                                            jsaOpt,\n-                                            \"-Xlog:class+path=info\",\n-                                            \"-version\");\n+            ProcessBuilder pb = CDSTestUtils.makeBuilder(homeJava,\n+                                                         \"-Xshare:auto\",\n+                                                         jsaOpt,\n+                                                         \"-Xlog:class+path=info\",\n+                                                         \"-version\");\n@@ -71,1 +73,1 @@\n-        clone(new File(java_home_src), new File(java_home_dst));\n+        CDSTestUtils.clone(new File(java_home_src), new File(java_home_dst));\n@@ -76,5 +78,5 @@\n-            ProcessBuilder pb = makeBuilder(java_home_dst + \"\/bin\/java\",\n-                                            \"-Xshare:auto\",\n-                                            jsaOpt,\n-                                            \"-Xlog:class+path=info\",\n-                                            \"-version\");\n+            ProcessBuilder pb = CDSTestUtils.makeBuilder(dstJava,\n+                                                         \"-Xshare:auto\",\n+                                                         jsaOpt,\n+                                                         \"-Xlog:class+path=info\",\n+                                                         \"-version\");\n@@ -92,4 +94,4 @@\n-            ProcessBuilder pb = makeBuilder(java_home_src + \"\/bin\/java\",\n-                                            \"-Xshare:dump\",\n-                                            dumptimeBootAppendOpt,\n-                                            jsaOpt);\n+            ProcessBuilder pb = CDSTestUtils.makeBuilder(homeJava,\n+                                                         \"-Xshare:dump\",\n+                                                         dumptimeBootAppendOpt,\n+                                                         jsaOpt);\n@@ -101,6 +103,6 @@\n-            ProcessBuilder pb = makeBuilder(java_home_dst + \"\/bin\/java\",\n-                                            \"-Xshare:auto\",\n-                                            runtimeBootAppendOpt,\n-                                            jsaOpt,\n-                                            \"-Xlog:class+path=info\",\n-                                            \"-version\");\n+            ProcessBuilder pb = CDSTestUtils.makeBuilder(dstJava,\n+                                                         \"-Xshare:auto\",\n+                                                         runtimeBootAppendOpt,\n+                                                         jsaOpt,\n+                                                         \"-Xlog:class+path=info\",\n+                                                         \"-version\");\n@@ -114,1 +116,1 @@\n-        renameModulesFile(java_home_dst);\n+        CDSTestUtils.renameModulesFile(java_home_dst + File.separator + \"lib\", \"modules\", \"orig-modules\");\n@@ -116,2 +118,1 @@\n-            ProcessBuilder pb = makeBuilder(java_home_dst + \"\/bin\/java\",\n-                                            \"-version\");\n+            ProcessBuilder pb = CDSTestUtils.makeBuilder(dstJava, \"-version\");\n@@ -124,62 +125,0 @@\n-    \/\/ Do a cheap clone of the JDK. Most files can be sym-linked. However, $JAVA_HOME\/bin\/java and $JAVA_HOME\/lib\/...\/libjvm.so\"\n-    \/\/ must be copied, because the java.home property is derived from the canonicalized paths of these 2 files.\n-    static void clone(File src, File dst) throws Exception {\n-        if (dst.exists()) {\n-            if (!dst.isDirectory()) {\n-                throw new RuntimeException(\"Not a directory :\" + dst);\n-            }\n-        } else {\n-            if (!dst.mkdir()) {\n-                throw new RuntimeException(\"Cannot create directory: \" + dst);\n-            }\n-        }\n-        final String jvmLib = System.mapLibraryName(\"jvm\");\n-        for (String child : src.list()) {\n-            if (child.equals(\".\") || child.equals(\"..\")) {\n-                continue;\n-            }\n-\n-            File child_src = new File(src, child);\n-            File child_dst = new File(dst, child);\n-            if (child_dst.exists()) {\n-                throw new RuntimeException(\"Already exists: \" + child_dst);\n-            }\n-            if (child_src.isFile()) {\n-                if (child.equals(jvmLib) || child.equals(\"java\")) {\n-                    Files.copy(child_src.toPath(), \/* copy data to -> *\/ child_dst.toPath());\n-                } else {\n-                    Files.createSymbolicLink(child_dst.toPath(),  \/* link to -> *\/ child_src.toPath());\n-                }\n-            } else {\n-                clone(child_src, child_dst);\n-            }\n-        }\n-    }\n-\n-    static void renameModulesFile(String javaHome) throws Exception {\n-        String modulesDir = javaHome + File.separator + \"lib\";\n-        File origModules = new File(modulesDir, \"modules\");\n-        if (!origModules.exists()) {\n-            throw new RuntimeException(\"modules file not found\");\n-        }\n-\n-        File renamedModules = new File(modulesDir, \"orig_modules\");\n-        if (renamedModules.exists()) {\n-            throw new RuntimeException(\"found orig_modules unexpectedly\");\n-        }\n-\n-        boolean success = origModules.renameTo(renamedModules);\n-        if (!success) {\n-            throw new RuntimeException(\"rename modules file failed\");\n-        }\n-    }\n-\n-    static ProcessBuilder makeBuilder(String... args) throws Exception {\n-        System.out.print(\"[\");\n-        for (String s : args) {\n-            System.out.print(\" \" + s);\n-        }\n-        System.out.println(\" ]\");\n-        return new ProcessBuilder(args);\n-    }\n-\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/MoveJDKTest.java","additions":26,"deletions":87,"binary":false,"changes":113,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/SharedArchiveConsistency.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/DynamicArchiveTestBase.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,1 +50,1 @@\n- *   10.1 run with non-existing archive should automatically create dynamic archive.\n+ *   10.01 run with non-existing archive should automatically create dynamic archive.\n@@ -52,2 +52,2 @@\n- *   10.2 run with the created dynamic archive should pass.\n- *   10.3 run with the created dynamic archive and -XX:+AutoCreateSharedArchive should pass and no shared archive created at exit.\n+ *   10.02 run with the created dynamic archive should pass.\n+ *   10.03 run with the created dynamic archive and -XX:+AutoCreateSharedArchive should pass and no shared archive created at exit.\n@@ -77,6 +77,4 @@\n- *   20.1 dump base archive which will be used for dumping top archive.\n- *   20.2 dump top archive based on base archive obtained in 20.1.\n- *   20.3 run -XX:SharedArchiveFile=<base>:<top> to verify the archives.\n- *\n- *   20.2 dump top archive based on base archive obtained in 20.1.\n- *   20.3 run -XX:SharedArchiveFile=<base>:<top> to verify the archives.\n+ *   20.01 dump base archive which will be used for dumping top archive.\n+ *   20.02 dump top archive based on base archive obtained in 20.1.\n+ *   20.03 run -XX:SharedArchiveFile=<base>:<top> to verify the archives.\n+ *   20.04 run with -XX:SharedArchveFile=base:top (reversed)\n@@ -93,2 +91,3 @@\n- * 23 create an archive with dynamic magic value only like in 15\n- *    Run with the base archive created in step 20.1 will exit abnormal due to fail to read file header.\n+ * 23  mismatched jvm_indent in top archive\n+ *     23.01 mismatched jvm_indent in top archive\n+ *     23.02 mismatched jvm_indent in base archive\n@@ -96,2 +95,5 @@\n- * 24 Run -Xshare:auto -XX:SharedArchiveFile=base (created in 20.1) -XX:+AutoCreateSharedArchive\n- *    Warning for not a dynamic archive, run with static archive. Not dynamic archive is created at exit.\n+ * 24 run with non-existing shared archives\n+ *   24.01 run -Xshare:auto -XX:+AutoCreateSharedArchive -XX:SharedArchiveFile=base.jsa:non-exist-top.jsa\n+ *     The top archive will be regenerated.\n+ *   24.02 run -Xshare:auto -XX:+AutoCreateSharedArchive -XX:SharedArchiveFile=non-exist-base.jsa:top.jsa\n+ *     top archive will not be shared. No shared archive will be generated.\n@@ -124,1 +126,1 @@\n-        if (args.length != 1 ||(!args[0].equals(\"verifySharedSpacesOff\") && !args[0].equals(\"verifySharedSpacesOn\"))) {\n+        if (args.length != 1 || (!args[0].equals(\"verifySharedSpacesOff\") && !args[0].equals(\"verifySharedSpacesOn\"))) {\n@@ -237,0 +239,1 @@\n+            \"-Xshare:auto\",\n@@ -244,1 +247,1 @@\n-                      .shouldContain(\"AutoCreateSharedArchive will be ignored for static archive\")\n+                      .shouldContain(\"AutoCreateSharedArchive is ignored because \" + BASE_NAME + \" is a static archive\")\n@@ -450,2 +453,2 @@\n-        \/\/ 20.1 dump base archive and top archive\n-        print(\"    20.1 dump base archive \" + BASE_NAME);\n+        \/\/ 20.01 dump base archive and top archive\n+        print(\"    20.01 dump base archive \" + BASE_NAME);\n@@ -458,2 +461,2 @@\n-        \/\/ 20.2 dump top based on base\n-        print(\"    20.2 dump top based on base\");\n+        \/\/ 20.02 dump top based on base\n+        print(\"    20.02 dump top based on base\");\n@@ -470,2 +473,2 @@\n-        \/\/ 20.3 run with base and top\n-        print(\"    20.3 run with base and top\");\n+        \/\/ 20.03 run with -XX:SharedArchveFile=top:base\n+        print(\"    20.03 run with -XX:SharedArchveFile=top:base\");\n@@ -483,0 +486,15 @@\n+        \/\/ 20.04 run with -XX:SharedArchveFile=base:top (reversed)\n+        print(\"    20.04 run with -XX:SharedArchveFile=base:top (reversed)\");\n+        run2(TOP_NAME, BASE_NAME,\n+             \"-Xlog:cds\",\n+             \"-Xlog:cds+dynamic=info\",\n+             \"-Xlog:class+load\",\n+             \"-cp\", appJar,\n+             mainAppClass)\n+            .assertAbnormalExit(output -> {\n+                output.shouldHaveExitValue(1)\n+                      .shouldContain(\"Not a base shared archive: \" + TOP_NAME)\n+                      .shouldContain(\"An error has occurred while processing the shared archive file\")\n+                      .shouldNotContain(HELLO_WORLD);\n+            });\n+\n@@ -563,5 +581,9 @@\n-        \/\/ 23 run -Xshare:auto -XX:SharedArchiveFile=<static> -XX:+AutoCreateSharedArchive\n-        \/\/    run with a static archive. No dynamic archive is created at exit.\n-        print(\"23 Run -Xshare:auto -XX:SharedArchiveFile=<static> -XX:+AutoCreateSharedArchive\");\n-        ft1 = Files.getLastModifiedTime(Paths.get(BASE_NAME));\n-        run(BASE_NAME,\n+        \/\/ 23  mismatched jvm_indent in top archive\n+        \/\/    23.01 mismatched jvm_indent in top archive\n+        print(\"    23.01  mismatched jvm_indent in archive\");\n+        String modJvmIdentTop = startNewArchive(\"modify-jvmident-top\");\n+        copiedJsa = CDSArchiveUtils.copyArchiveFile(archiveFile, modJvmIdentTop);\n+        CDSArchiveUtils.modifyHeaderIntField(copiedJsa, CDSArchiveUtils.offsetJvmIdent(), 0x65656565);\n+        ft1 = Files.getLastModifiedTime(Paths.get(modJvmIdentTop));\n+\n+        run2(BASE_NAME, modJvmIdentTop,\n@@ -572,1 +594,29 @@\n-             VerifySharedSpaces,\n+            VerifySharedSpaces,\n+            \"-cp\", appJar,\n+            mainAppClass)\n+            .assertNormalExit(output -> {\n+                output.shouldHaveExitValue(0);\n+                if (verifyOn) {\n+                    output.shouldContain(\"UseSharedSpaces: Header checksum verification failed\");\n+                }\n+                output.shouldContain(HELLO_WORLD)\n+                      .shouldContain(\"Dumping shared data to file\");\n+            });\n+        ft2 = Files.getLastModifiedTime(Paths.get(modJvmIdentTop));\n+        fileModified = !ft1.equals(ft2);\n+        if (!fileModified) {\n+            throw new RuntimeException(\"Shared archive \" + modJvmIdentTop + \" should be generated\");\n+        }\n+        \/\/    23.02 mismatched jvm_indent in base archive -Xshare:auto -XX:SahredArchiveFile=base:top\n+        print(\"    23.02  mismatched jvm_indent in base archive, -Xshare:auto -XX:SahredArchiveFile=base:top\");\n+        String modJvmIdentBase = startNewArchive(\"modify-jvmident-base\");\n+        copiedJsa = CDSArchiveUtils.copyArchiveFile(new File(BASE_NAME), modJvmIdentBase);\n+        CDSArchiveUtils.modifyHeaderIntField(copiedJsa, CDSArchiveUtils.offsetJvmIdent(), 0x65656565);\n+        ft1 = Files.getLastModifiedTime(Paths.get(TOP_NAME));\n+\n+        run2(modJvmIdentBase, TOP_NAME,\n+            \"-Xshare:auto\",\n+            \"-XX:+AutoCreateSharedArchive\",\n+            \"-Xlog:cds\",\n+            \"-Xlog:cds+dynamic=info\",\n+            VerifySharedSpaces,\n@@ -577,2 +627,5 @@\n-                      .shouldContain(\"AutoCreateSharedArchive will be ignored for static archive\")\n-                      .shouldContain(HELLO_WORLD)\n+                      .shouldContain(HELLO_WORLD);\n+                if (verifyOn) {\n+                    output.shouldContain(\"UseSharedSpaces: Header checksum verification failed\");\n+                }\n+                output.shouldContain(\"Unable to map shared spaces\")\n@@ -580,2 +633,2 @@\n-                });\n-        ft2 = Files.getLastModifiedTime(Paths.get(BASE_NAME));\n+            });\n+        ft2 = Files.getLastModifiedTime(Paths.get(TOP_NAME));\n@@ -584,1 +637,1 @@\n-            throw new RuntimeException(\"Shared archive \" + BASE_NAME + \" should not be created at exit\");\n+            throw new RuntimeException(\"Shared archive \" + TOP_NAME + \" should not be generated\");\n@@ -587,2 +640,4 @@\n-        \/\/ 24 run -Xshare:auto -XX:+AutoCreateSharedArchive -XX:SharedArchiveFile=base.jsa:non-exist-top.jsa\n-        print(\"24 run -Xshare:auto -XX:+AutoCreateSharedArchive -XX:SharedArchiveFile=base.jsa:non-exist-top.jsa\");\n+        \/\/ 24 run with non-existing shared archives\n+        print(\"24 run with non-existing shared archives\");\n+        \/\/   24.01 run -Xshare:auto -XX:+AutoCreateSharedArchive -XX:SharedArchiveFile=base.jsa:non-exist-top.jsa\n+        print(\"    24.01 run -Xshare:auto -XX:+AutoCreateSharedArchive -XX:SharedArchiveFile=base.jsa:non-exist-top.jsa\");\n@@ -610,0 +665,27 @@\n+\n+        \/\/    24.02 run -Xshare:auto -XX:+AutoCreateSharedArchive -XX:SharedArchiveFile=non-exist-base.jsa:top.jsa\n+        print(\"    24.02 run -Xshare:auto -XX:+AutoCreateSharedArchive -XX:SharedArchiveFile=non-exist-base.jsa:top.jsa\");\n+        String nonExistBase = \"non-existing-base.jsa\";\n+        fileNonExist = new File(nonExistBase);\n+        if (fileNonExist.exists()) {\n+            fileNonExist.delete();\n+        }\n+        ft1 = Files.getLastModifiedTime(Paths.get(TOP_NAME));\n+        run2(nonExistBase, TOP_NAME,\n+             \"-Xshare:auto\",\n+             \"-XX:+AutoCreateSharedArchive\",\n+             \"-Xlog:cds\",\n+             \"-Xlog:cds+dynamic=info\",\n+             VerifySharedSpaces,\n+             \"-cp\", appJar,\n+             mainAppClass)\n+             .assertNormalExit(output -> {\n+                 output.shouldContain(\"Specified shared archive not found (\" + nonExistBase + \")\")\n+                       .shouldContain(HELLO_WORLD)\n+                       .shouldNotContain(\"Dumping shared data to file:\");\n+             });\n+        ft2 = Files.getLastModifiedTime(Paths.get(TOP_NAME));\n+        fileModified = !ft1.equals(ft2);\n+        if (fileModified) {\n+            throw new RuntimeException(\"Shared archive \" + TOP_NAME + \" should be created at exit\");\n+        }\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/TestAutoCreateSharedArchive.java","additions":117,"deletions":35,"binary":false,"changes":152,"status":"modified"},{"patch":"@@ -0,0 +1,146 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Test -XX:+AutoCreateSharedArchive on a copied JDK without default shared archive\n+ * @bug 8261455\n+ * @requires vm.cds\n+ * @requires vm.flagless\n+ * @comment This test doesn't work on Windows because it depends on symlinks\n+ * @requires os.family != \"windows\"\n+ * @library \/test\/lib \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\n+ * @compile ..\/test-classes\/Hello.java\n+ * @run driver TestAutoCreateSharedArchiveNoDefaultArchive\n+ *\/\n+\n+import java.io.File;\n+import jdk.test.lib.cds.CDSTestUtils;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+public class TestAutoCreateSharedArchiveNoDefaultArchive {\n+    public static void main(String[] args) throws Exception {\n+        String mainClass = \"Hello\";\n+        String java_home_src = System.getProperty(\"java.home\");\n+        String java_home_dst = CDSTestUtils.getOutputDir() + File.separator + \"moved_jdk\";\n+        CDSTestUtils.clone(new File(java_home_src), new File(java_home_dst));\n+        System.out.println(\"======== Cloned JDK at \" + java_home_dst);\n+\n+        String homeJava = java_home_src + File.separator + \"bin\" + File.separator + \"java\";\n+        String dstJava  = java_home_dst + File.separator + \"bin\" + File.separator + \"java\";\n+\n+        TestCommon.startNewArchiveName();\n+        String jsaFileName = TestCommon.getCurrentArchiveName();\n+        File jsaFile = new File(jsaFileName);\n+        if (jsaFile.exists()) {\n+            jsaFile.delete();\n+        }\n+\n+        String jsaOpt = \"-XX:SharedArchiveFile=\" + jsaFileName;\n+        String autoCreateArchive = \"-XX:+AutoCreateSharedArchive\";\n+        {\n+            ProcessBuilder pb = CDSTestUtils.makeBuilder(homeJava,\n+                                                         \"-Xshare:dump\",\n+                                                         jsaOpt);\n+            TestCommon.executeAndLog(pb, \"dump\")\n+                      .shouldHaveExitValue(0);\n+        }\n+        {\n+            ProcessBuilder pb = CDSTestUtils.makeBuilder(homeJava,\n+                                                         \"-Xshare:auto\",\n+                                                         jsaOpt,\n+                                                         \"-Xlog:class+path=info\",\n+                                                         \"-version\");\n+            OutputAnalyzer out = TestCommon.executeAndLog(pb, \"exec-src\");\n+            out.shouldHaveExitValue(0);\n+            out.shouldNotContain(\"shared class paths mismatch\");\n+            out.shouldNotContain(\"BOOT classpath mismatch\");\n+        }\n+\n+        String helloJar = JarBuilder.getOrCreateHelloJar();\n+\n+        if (jsaFile.exists()) {\n+            jsaFile.delete();\n+        }\n+        \/\/ Test runtime with cloned JDK\n+        System.out.println(\"======== run with cloned jdk to created dynamic shared archive at exit\");\n+        {\n+            ProcessBuilder pb = CDSTestUtils.makeBuilder(dstJava,\n+                                                         \"-Xshare:auto\",\n+                                                         autoCreateArchive,\n+                                                         jsaOpt,\n+                                                         \"-Xlog:cds\",\n+                                                         \"-Xlog:class+path=info\",\n+                                                         \"-cp\", helloJar,\n+                                                         mainClass);\n+            OutputAnalyzer out = TestCommon.executeAndLog(pb, \"exec-dst\");\n+            out.shouldHaveExitValue(0);\n+            out.shouldContain(\"Dumping shared data to file\");\n+            if (!jsaFile.exists()) {\n+                throw new RuntimeException(\"Shared archive \" + jsaFileName + \" should be created at exit\");\n+            }\n+        }\n+\n+        \/\/ Now rename classes.jsa to old-classes.jsa\n+        String dstDir = java_home_dst + File.separator + \"lib\" + File.separator + \"server\";\n+\tCDSTestUtils.renameModulesFile(dstDir, \"classes.jsa\", \"old-classes.jsa\");\n+\tSystem.out.println(\"======= renamed \" + dstDir + File.separator + \"classes.jsa to old-classes.jsa\");\n+\n+        {\n+            ProcessBuilder pb = CDSTestUtils.makeBuilder(dstJava,\n+                                                         \"-Xlog:cds\",\n+                                                         \"-version\");\n+            TestCommon.executeAndLog(pb, \"show-version\")\n+                      .shouldHaveExitValue(0)\n+                      .shouldContain(\"UseSharedSpaces: Initialize static archive failed\")\n+                      .shouldContain(\"UseSharedSpaces: Unable to map shared spaces\")\n+                      .shouldContain(\"mixed mode\")\n+                      .shouldNotContain(\"sharing\");\n+        }\n+        \/\/ delete existing jsa file\n+        if (jsaFile.exists()) {\n+            jsaFile.delete();\n+        }\n+        System.out.println(\"======= run with no default shared archive should no create shared archive at exit\");\n+        {\n+            ProcessBuilder pb = CDSTestUtils.makeBuilder(dstJava,\n+                                                         \"-Xshare:auto\",\n+                                                         autoCreateArchive,\n+                                                         jsaOpt,\n+                                                         \"-Xlog:cds\",\n+                                                         \"-Xlog:class+path=info\",\n+                                                         \"-cp\", helloJar,\n+                                                         mainClass);\n+            TestCommon.executeAndLog(pb, \"no-default-archive\")\n+                      .shouldHaveExitValue(0)\n+                      .shouldContain(\"UseSharedSpaces: Initialize static archive failed\")\n+                      .shouldContain(\"UseSharedSpaces: Unable to map shared spaces\")\n+                      .shouldNotContain(\"Dumping shared data to file\");\n+            if (jsaFile.exists()) {\n+                throw new RuntimeException(\"Archive file \" + jsaFileName + \" should not be created at exit\");\n+            }\n+        }\n+\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/TestAutoCreateSharedArchiveNoDefaultArchive.java","additions":146,"deletions":0,"binary":false,"changes":146,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/lib\/jdk\/test\/lib\/cds\/CDSArchiveUtils.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,3 @@\n+import java.nio.file.Files;\n+import java.nio.file.CopyOption;\n+import java.nio.file.StandardCopyOption;\n@@ -687,0 +690,76 @@\n+\n+    \/\/ JDK utility\n+\n+    \/\/ Do a cheap clone of the JDK. Most files can be sym-linked. However, $JAVA_HOME\/bin\/java and $JAVA_HOME\/lib\/...\/libjvm.so\"\n+    \/\/ must be copied, because the java.home property is derived from the canonicalized paths of these 2 files.\n+    \/\/ Set a list of {jvm, \"java\"} which will be physically copied. If a file needs copied physically, add it to the list.\n+    private static String[] phCopied = {System.mapLibraryName(\"jvm\"), \"java\"};\n+    public static void clone(File src, File dst) throws Exception {\n+        if (dst.exists()) {\n+            if (!dst.isDirectory()) {\n+                throw new RuntimeException(\"Not a directory :\" + dst);\n+            }\n+        } else {\n+            if (!dst.mkdir()) {\n+                throw new RuntimeException(\"Cannot create directory: \" + dst);\n+            }\n+        }\n+        \/\/ final String jvmLib = System.mapLibraryName(\"jvm\");\n+        for (String child : src.list()) {\n+            if (child.equals(\".\") || child.equals(\"..\")) {\n+                continue;\n+            }\n+\n+            File child_src = new File(src, child);\n+            File child_dst = new File(dst, child);\n+            if (child_dst.exists()) {\n+                throw new RuntimeException(\"Already exists: \" + child_dst);\n+            }\n+            if (child_src.isFile()) {\n+                boolean needPhCopy = false;\n+                for (String target : phCopied) {\n+                    if (child.equals(target)) {\n+                        needPhCopy = true;\n+                        break;\n+                    }\n+                }\n+                if (needPhCopy) {\n+                    Files.copy(child_src.toPath(), \/* copy data to -> *\/ child_dst.toPath(),\n+                               new CopyOption[] { StandardCopyOption.REPLACE_EXISTING, StandardCopyOption.COPY_ATTRIBUTES});\n+                } else {\n+                    Files.createSymbolicLink(child_dst.toPath(),  \/* link to -> *\/ child_src.toPath());\n+                }\n+            } else {\n+                clone(child_src, child_dst);\n+            }\n+        }\n+    }\n+\n+    \/\/ modulesDir, like $JDK\/lib\n+    \/\/ oldName, module name under modulesDir\n+    \/\/ newName, new name for oldName\n+    public static void renameModulesFile(String modulesDir, String oldName, String newName) throws Exception {\n+        File origModules = new File(modulesDir, oldName);\n+        if (!origModules.exists()) {\n+            throw new RuntimeException(oldName + \" file not found\");\n+        }\n+\n+        File renamedModules = new File(modulesDir, newName);\n+        if (renamedModules.exists()) {\n+            throw new RuntimeException(newName + \" found unexpectedly\");\n+        }\n+\n+        boolean success = origModules.renameTo(renamedModules);\n+        if (!success) {\n+            throw new RuntimeException(\"rename file \" + oldName + \" to \" + newName + \" failed\");\n+        }\n+    }\n+\n+    public static ProcessBuilder makeBuilder(String... args) throws Exception {\n+        System.out.print(\"[\");\n+        for (String s : args) {\n+            System.out.print(\" \" + s);\n+        }\n+        System.out.println(\" ]\");\n+        return new ProcessBuilder(args);\n+    }\n","filename":"test\/lib\/jdk\/test\/lib\/cds\/CDSTestUtils.java","additions":80,"deletions":1,"binary":false,"changes":81,"status":"modified"}]}