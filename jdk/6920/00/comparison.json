{"files":[{"patch":"@@ -413,1 +413,2 @@\n-  return DynamicDumpSharedSpaces && (ArchiveClassesAtExit != nullptr);\n+  return (DynamicDumpSharedSpaces && (ArchiveClassesAtExit != nullptr)) ||\n+         (AutoCreateSharedArchive && Arguments::GetSharedDynamicArchivePath() != nullptr);\n","filename":"src\/hotspot\/share\/cds\/dynamicArchive.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -175,0 +175,1 @@\n+    _full_path = Arguments::GetSharedArchivePath();\n@@ -178,0 +179,6 @@\n+    _full_path = Arguments::GetSharedDynamicArchivePath();\n+  }\n+  bool valid = validate_archive();\n+  if (!valid && !_is_static && AutoCreateSharedArchive) {\n+    \/\/ regenerate shared archive at exit\n+    DynamicDumpSharedSpaces = true;\n@@ -191,0 +198,16 @@\n+  if (_file_open) {\n+    os::close(_fd);\n+  }\n+}\n+\n+\/\/ Do preliminary validation on archive. More checks are in initialization.\n+bool FileMapInfo::validate_archive() const {\n+  if (!os::file_exists(_full_path)) {\n+    return false;\n+  }\n+  \/\/ validate header info\n+  if (!check_archive(_full_path, _is_static)) {\n+    return false;\n+  }\n+\n+  return true;\n@@ -1102,0 +1125,6 @@\n+    if (gen_header._version !=  CURRENT_CDS_ARCHIVE_VERSION) {\n+      auto warning_continue = FileMapInfo::fail_continue;\n+      warning_continue(\"The shared archive file version %d which is not current version %d\",\n+                                    gen_header._version, CURRENT_CDS_ARCHIVE_VERSION);\n+    }\n+\n@@ -2369,8 +2398,11 @@\n-  if (!open_for_read()) {\n-    return false;\n-  }\n-  if (!init_from_file(_fd)) {\n-    return false;\n-  }\n-  if (!validate_header()) {\n-    return false;\n+  if (!open_for_read() || !init_from_file(_fd) || !validate_header()) {\n+    if (_is_static) {\n+      FileMapInfo::fail_continue(\"Initialize static archive failed.\");\n+      return false;\n+    } else {\n+      FileMapInfo::fail_continue(\"Initialize dynamic archive failed.\");\n+      if (AutoCreateSharedArchive) {\n+        DynamicDumpSharedSpaces = true;\n+      }\n+      return false;\n+    }\n@@ -2378,0 +2410,1 @@\n+\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":41,"deletions":8,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -371,0 +371,1 @@\n+  bool validate_archive() const;\n","filename":"src\/hotspot\/share\/cds\/filemap.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -949,0 +949,4 @@\n+      \/\/ turn AutoCreateSharedArchive off if successfully mapped\n+      if (AutoCreateSharedArchive) {\n+        AutoCreateSharedArchive = false;\n+      }\n@@ -979,1 +983,1 @@\n-  if (DynamicDumpSharedSpaces) {\n+  if (DynamicDumpSharedSpaces && !AutoCreateSharedArchive) {\n@@ -1023,0 +1027,4 @@\n+  if (AutoCreateSharedArchive && static_mapinfo != NULL && dynamic_mapinfo == NULL) {\n+    warning(\"AutoCreateSharedArchive will be ignored for static archive\");\n+  }\n+\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -3143,0 +3143,11 @@\n+  if (AutoCreateSharedArchive) {\n+    if (SharedArchiveFile == NULL) {\n+      log_info(cds)(\"-XX:+AutoCreateSharedArchive must work with a valid SharedArchiveFile\");\n+      return JNI_ERR;\n+    }\n+    if (ArchiveClassesAtExit != NULL) {\n+      log_info(cds)(\"-XX:+AutoCreateSharedArchive does not work with ArchiveClassesAtExit\");\n+      return JNI_ERR;\n+    }\n+  }\n+\n@@ -3490,3 +3501,0 @@\n-  if (!FileMapInfo::check_archive((const char*)cur_path, true \/*is_static*\/)) {\n-    return;\n-  }\n@@ -3504,3 +3512,0 @@\n-  if (!FileMapInfo::check_archive((const char*)cur_path, false \/*is_static*\/)) {\n-    return;\n-  }\n@@ -3559,1 +3564,9 @@\n-          no_shared_spaces(\"invalid archive\");\n+          \/\/ If +AutoCreateSharedArchive and the specified shared archive does not exist,\n+          \/\/ regenerate the dynamic archive base on default archive.\n+          if (AutoCreateSharedArchive && !os::file_exists(SharedArchiveFile)) {\n+            SharedDynamicArchivePath = const_cast<char *>(SharedArchiveFile);\n+            SharedArchivePath = get_default_shared_archive_path();\n+            DynamicDumpSharedSpaces = true;\n+          } else {\n+            no_shared_spaces(\"invalid archive\");\n+          }\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":20,"deletions":7,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -1810,0 +1810,3 @@\n+  product(bool, AutoCreateSharedArchive, false,                             \\\n+          \"Create shared archive at exit if cds mapping failed\")            \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -60,0 +60,1 @@\n+#include \"runtime\/arguments.hpp\"\n@@ -507,1 +508,3 @@\n-    assert(ArchiveClassesAtExit != NULL, \"Must be already set\");\n+    const char* archive_name =\n+       (ArchiveClassesAtExit != nullptr) ? ArchiveClassesAtExit : Arguments::GetSharedDynamicArchivePath();\n+    assert(archive_name != NULL, \"Must be already set\");\n@@ -509,1 +512,1 @@\n-    DynamicArchive::dump(ArchiveClassesAtExit, thread);\n+    DynamicArchive::dump(archive_name, thread);\n","filename":"src\/hotspot\/share\/runtime\/java.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -184,3 +184,1 @@\n-        output.shouldContain(\"The shared archive file has the wrong version\")\n-              .shouldContain(\"_version expected: \" + currentCDSArchiveVersion)\n-              .shouldContain(\"actual: \" + version);\n+        output.shouldContain(\"The shared archive file version \" + version + \" which is not current version \" + currentCDSArchiveVersion);\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/SharedArchiveConsistency.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -40,1 +40,0 @@\n-\n@@ -99,0 +98,13 @@\n+    \/**\n+     * Excute a JVM to dump a base archive by\n+     *  -Xshare:dump -XX:SharedArchiveFile=baseArchiveName\n+     *\/\n+    public static Result dumpBaseArchive(String baseArchiveName, String... cmdLineSuffix)\n+        throws Exception\n+    {\n+        OutputAnalyzer output = TestCommon.dumpBaseArchive(baseArchiveName, cmdLineSuffix);\n+        CDSOptions opts = new CDSOptions();\n+        opts.setXShareMode(\"dump\");\n+        return new Result(opts, output);\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/DynamicArchiveTestBase.java","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -0,0 +1,611 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8261455\n+ * @summary test -XX:+AutoCreateSharedArchive feature\n+ * @requires vm.cds\n+ * @library \/test\/lib \/test\/hotspot\/jtreg\/runtime\/cds\/appcds \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\/test-classes\n+ * @build Hello\n+ * @build sun.hotspot.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar hello.jar Hello\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar WhiteBox.jar sun.hotspot.WhiteBox\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\/WhiteBox.jar TestAutoCreateSharedArchive verifySharedSpacesOff\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\/WhiteBox.jar TestAutoCreateSharedArchive verifySharedSpacesOn\n+ *\/\n+\n+\/*\n+ * -XX:SharedArchiveFile can be specified in two styles:\n+ *\n+ *  (A) Test with default base archive -XX:+SharedArchiveFile=<archive>\n+ *  (B) Test with the base archive is specified: -XX:SharedArchiveFile=<base>:<file>\n+ *  all the following if not explained explicitly, run with flag -XX:+AutoCreateSharedArchive\n+ *\n+ *  Note VerifySharedSpaces will affect output so the tests run twice: one with -XX:+VerifySharedSpaces and the other with -XX:-VerifySharedSpaces\n+ *\n+ * 10 Case (A)\n+ *\n+ *   10.1 run with non-existing archive should automatically create dynamic archive.\n+ *        If the JDK's default CDS archive cannot be loaded, print out warning, run continue without shared archive and no shared archive created at exit.\n+ *   10.2 run with the created dynamic archive should pass.\n+ *   10.3 run with the created dynamic archive and -XX:+AutoCreateSharedArchive should pass and no shared archive created at exit.\n+ *\n+ * 11 run with static archive.\n+ *    run with static archive should printout warning and continue, share or no share depends on the archive validation at exit,\n+ *    no shared archive (top) will be generated.\n+ *\n+ * 12 run with damaged magic should not regenerate dynamic archive.\n+ *    if magic is not expected, no shared archive will be regenerated at exit.\n+ *\n+ * 13 run with a bad versioned archive.\n+ *   13.01  run with a bad versioned (< CDS_GENERIC_HEADER_SUPPORTED_MIN_VERSION) archive should not create dynamic archive at exit.\n+ *   13.02  run with a bad versioned (> CDS_GENERIC_HEADER_SUPPORTED_MIN_VERSION) archive should create dynamic archive at exit.\n+ *\n+ * 14 run with an archive whose base name is not matched, no shared archive at exit.\n+ *\n+ * 15 run with an archive whose jvm_ident is corrupted should\n+ *     create dynamic archive at exit with -XX:-VerifySharedSpaces\n+ *     not create dynamic archive at exit with -XX:+VerifySharedSpaces\n+ *\n+ * 16 run with an archive of only containing magic in the file (size of 4 bytes)\n+ *    the archive will be created at exit.\n+ *\n+ * 20 (case B)\n+ *\n+ *   20.1 dump base archive which will be used for dumping top archive.\n+ *   20.2 dump top archive based on base archive obtained in 20.1.\n+ *   20.3 run -XX:SharedArchiveFile=<base>:<top> to verify the archives.\n+ *\n+ *   20.2 dump top archive based on base archive obtained in 20.1.\n+ *   20.3 run -XX:SharedArchiveFile=<base>:<top> to verify the archives.\n+ *\n+ * 21 Mismatched versions\n+ *   21.01 if version of top archive is higher than CDS_GENERIC_HEADER_SUPPORTED_MIN_VERSION, the archive cannot be shared and will be\n+ *         regenerated at exit.\n+ *   21.02 if version of top archive is lower than CDS_GENERIC_HEADER_SUPPORTED_MIN_VERSION, the archive cannot be shared abd will be\n+ *         created at exit.\n+ *\n+ * 22 create an archive with dynamic magic number only\n+ *    archive will be created at exit if base can be shared.\n+ *\n+ * 23 create an archive with dynamic magic value only like in 15\n+ *    Run with the base archive created in step 20.1 will exit abnormal due to fail to read file header.\n+ *\n+ * 24 Run -Xshare:auto -XX:SharedArchiveFile=base (created in 20.1) -XX:+AutoCreateSharedArchive\n+ *    Warning for not a dynamic archive, run with static archive. Not dynamic archive is created at exit.\n+ *\/\n+\n+import java.io.IOException;\n+import java.io.File;\n+\n+import java.nio.file.attribute.FileTime;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+\n+import jdk.test.lib.cds.CDSTestUtils;\n+import jdk.test.lib.cds.CDSArchiveUtils;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.helpers.ClassFileInstaller;\n+\n+public class TestAutoCreateSharedArchive extends DynamicArchiveTestBase {\n+    private static final String BASE_NAME = CDSTestUtils.getOutputFileName(\"base.jsa\");\n+    private static final String TOP_NAME  = CDSTestUtils.getOutputFileName(\"top.jsa\");\n+    private static final String mainAppClass = \"Hello\";\n+    private static final String HELLO_SOURCE = \"Hello source: shared objects file (top)\";\n+    private static final String HELLO_WORLD = \"Hello World\";\n+    private static boolean verifyOn = false;\n+\n+    private static int   genericHeaderMinVersion = CDSArchiveUtils.getGenericHeaderMinVersion();\n+    private static int   currentCDSVersion = CDSArchiveUtils.getCurrentCDSArchiveVersion();\n+\n+    public static void main(String[] args) throws Exception {\n+        if (args.length != 1 ||(!args[0].equals(\"verifySharedSpacesOff\") && !args[0].equals(\"verifySharedSpacesOn\"))) {\n+            throw new RuntimeException(\"Must run with verifySharedSpacesOff or verifySharedSpacesOn\");\n+        }\n+        verifyOn = args[0].equals(\"verifySharedSpacesOn\");\n+        runTest(TestAutoCreateSharedArchive::testAutoCreateSharedArchive);\n+    }\n+\n+    public static void checkFileExists(String fileName) throws Exception {\n+        File file = new File(fileName);\n+        if (!file.exists()) {\n+             throw new IOException(\"Archive \" + fileName + \" is not automatically created\");\n+        }\n+    }\n+\n+    public static String startNewArchive(String testName) {\n+        String newArchiveName = TestCommon.getNewArchiveName(testName);\n+        TestCommon.setCurrentArchiveName(newArchiveName);\n+        return newArchiveName;\n+    }\n+\n+    public static void print(String message) {\n+        System.out.println(message);\n+    }\n+\n+    private static void testAutoCreateSharedArchive() throws Exception {\n+        String appJar = ClassFileInstaller.getJarPath(\"hello.jar\");\n+        boolean fileModified = false;\n+\n+        String VerifySharedSpaces = verifyOn ? \"-XX:+VerifySharedSpaces\" : \"-XX:-VerifySharedSpaces\";\n+        File archiveFile = new File(TOP_NAME);\n+        if (archiveFile.exists()) {\n+          archiveFile.delete();\n+        }\n+\n+        \/\/ dump a static archive, used later.\n+        \/\/ 0. Dump a static archive\n+        print(\"0. dump a static archive \" + BASE_NAME);\n+        dumpBaseArchive(BASE_NAME,\n+                        \"-Xlog:cds\",\n+                        \"-cp\", appJar,\n+                        mainAppClass)\n+            .assertNormalExit(output -> {\n+                output.shouldHaveExitValue(0);\n+            });\n+        checkFileExists(BASE_NAME);\n+\n+        \/\/ The list numbers try to match JDK-8272331 (CSR for JDK-8261455) test items but not exactly matched.\n+\n+        \/\/ 10 non-existing archive should automatically create dynamic archive based on default shared archive\n+        \/\/ if base archive loaded.\n+        print(\"10 Test with default base shared archive\");\n+        print(\"    10.1 run with non-existing archive should automatically create dynamic archive\");\n+        File fileTop = new File(TOP_NAME);\n+        if (fileTop.exists()) {\n+            fileTop.delete();\n+        }\n+        run(TOP_NAME,\n+            \"-Xshare:auto\",\n+            \"-XX:+AutoCreateSharedArchive\",\n+            \"-Xlog:cds\",\n+            \"-cp\", appJar,\n+            mainAppClass)\n+            .assertNormalExit(output -> {\n+                output.shouldHaveExitValue(0)\n+                      .shouldContain(HELLO_WORLD)\n+                      .shouldContain(\"Dumping shared data to file:\")\n+                      .shouldContain(TOP_NAME);\n+                });\n+        checkFileExists(TOP_NAME);\n+\n+        \/\/ 10.2 run with the created dynamic archive should pass\n+        print(\"    10.2 run with the created dynamic archive should pass\");\n+        run(TOP_NAME,\n+            \"-Xlog:cds\",\n+            \"-Xlog:class+load\",\n+            \"-cp\", appJar,\n+            mainAppClass)\n+            .assertNormalExit(output -> {\n+                output.shouldHaveExitValue(0)\n+                      .shouldContain(HELLO_WORLD)\n+                      .shouldContain(HELLO_SOURCE);\n+                });\n+        \/\/ remember the FileTime\n+        FileTime ft1 = Files.getLastModifiedTime(Paths.get(TOP_NAME));\n+\n+        \/\/ 10.3 run with the created dynamic archive with -XX:+AutoCreateSharedArchive should pass\n+        \/\/      archive should not be created again.\n+        print(\"    10.3 run with the created dynamic archive with -XX:+AutoCreateSharedArchive should pass\");\n+        run(TOP_NAME,\n+            \"-Xlog:cds\",\n+            \"-Xlog:class+load\",\n+            \"-Xlog:cds+dynamic=info\",\n+            \"-XX:+AutoCreateSharedArchive\",\n+            \"-cp\", appJar,\n+            mainAppClass)\n+            .assertNormalExit(output -> {\n+                output.shouldHaveExitValue(0)\n+                      .shouldContain(HELLO_WORLD)\n+                      .shouldContain(HELLO_SOURCE)\n+                      .shouldNotContain(\"Dumping shared data to file\");\n+                });\n+        FileTime ft2 = Files.getLastModifiedTime(Paths.get(TOP_NAME));\n+        fileModified = !ft2.equals(ft1);\n+        if (fileModified) {\n+            throw new RuntimeException(\"Archive file \" + TOP_NAME + \"  should not be updated\");\n+        }\n+\n+        \/\/ 11 run with static archive\n+        print(\"11 run with static archive\");\n+        ft1 = Files.getLastModifiedTime(Paths.get(BASE_NAME));\n+        run(BASE_NAME,\n+            \"-Xlog:cds\",\n+            \"-Xlog:cds+dynamic=info\",\n+            \"-XX:+AutoCreateSharedArchive\",\n+            VerifySharedSpaces,\n+            \"-cp\", appJar,\n+            mainAppClass)\n+            .assertNormalExit(output -> {\n+                output.shouldHaveExitValue(0)\n+                      .shouldContain(HELLO_WORLD)\n+                      .shouldContain(\"AutoCreateSharedArchive will be ignored for static archive\")\n+                      .shouldNotContain(\"Dumping shared data to file\");\n+                });\n+        ft2 = Files.getLastModifiedTime(Paths.get(BASE_NAME));\n+        fileModified = !ft1.equals(ft2);\n+        if (fileModified) {\n+            throw new RuntimeException(\"Run -XX:+AutoCreateSharedArchive on static archive create new archive\");\n+        }\n+\n+        \/\/ 12 run with damaged magic should not regenerate dynamic archive\n+        print(\"12 run with damaged magic should not regenerate dynamic archive\");\n+        String modMagic = startNewArchive(\"modify-magic\");\n+        File copiedJsa = CDSArchiveUtils.copyArchiveFile(archiveFile, modMagic);\n+        CDSArchiveUtils.modifyHeaderIntField(copiedJsa, CDSArchiveUtils.offsetMagic(), 0x1234);\n+        ft1 = Files.getLastModifiedTime(Paths.get(modMagic));\n+\n+        run(modMagic,\n+            \"-Xshare:auto\",\n+            \"-XX:+AutoCreateSharedArchive\",\n+            \"-Xlog:cds\",\n+            \"-Xlog:cds+dynamic=info\",\n+            VerifySharedSpaces,\n+            \"-cp\", appJar,\n+            mainAppClass)\n+            .assertNormalExit(output -> {\n+                output.shouldHaveExitValue(0)\n+                      .shouldContain(HELLO_WORLD)\n+                      .shouldNotContain(\"Dumping shared data to file\");\n+                });\n+        ft2 = Files.getLastModifiedTime(Paths.get(modMagic));\n+        fileModified = !ft1.equals(ft2);\n+        if (fileModified) {\n+            throw new RuntimeException(\"Shared archive \" + modMagic + \" should automatically be generated\");\n+        }\n+\n+        \/\/ 13 run with a bad versioned (< genericHeaderMinVersion) archive\n+        print(\"13 run with a bad versioned archive\");\n+        print(\"    13.01 run with a bad versioned (< genericHeaderMinVersion) archive should not create new archive\");\n+        String modVersion = startNewArchive(\"modify-version-b\");\n+        copiedJsa = CDSArchiveUtils.copyArchiveFile(archiveFile, modVersion);\n+        final int version1 = genericHeaderMinVersion - 1;\n+        CDSArchiveUtils.modifyHeaderIntField(copiedJsa, CDSArchiveUtils.offsetVersion(), version1);\n+        ft1 = Files.getLastModifiedTime(Paths.get(modVersion));\n+\n+        run(modVersion,\n+            \"-Xshare:auto\",\n+            \"-XX:+AutoCreateSharedArchive\",\n+            \"-Xlog:cds\",\n+            \"-Xlog:cds+dynamic=info\",\n+            VerifySharedSpaces,\n+            \"-cp\", appJar,\n+            mainAppClass)\n+            .assertNormalExit(output -> {\n+                output.shouldHaveExitValue(0)\n+                      .shouldContain(HELLO_WORLD)\n+                      .shouldContain(\"Cannot handle shared archive file version \" + version1 + \". Must be at least \" + genericHeaderMinVersion)\n+                      .shouldContain(\"Unable to use shared archive: invalid archive\")\n+                      .shouldNotContain(\"Dumping shared data to file\");\n+            });\n+        ft2 = Files.getLastModifiedTime(Paths.get(modVersion));\n+        fileModified = !ft1.equals(ft2);\n+        if (fileModified) {\n+            throw new RuntimeException(\"Run -XX:+AutoCreateSharedArchive with lower version archive \" + modVersion + \" should not create new archive\");\n+        }\n+        \/\/    13.02 run with a bad versioned (> currentCDSVersion) archive\n+        print(\"    13.02 run with a bad versioned (> currentCDSVersion) archive\");\n+        modVersion = startNewArchive(\"modify-version-d\");\n+        copiedJsa = CDSArchiveUtils.copyArchiveFile(archiveFile, modVersion);\n+        final int version2 = currentCDSVersion + 1;\n+        CDSArchiveUtils.modifyHeaderIntField(copiedJsa, CDSArchiveUtils.offsetVersion(), version2);\n+        ft1 = Files.getLastModifiedTime(Paths.get(modVersion));\n+\n+        run(modVersion,\n+            \"-Xshare:auto\",\n+            \"-XX:+AutoCreateSharedArchive\",\n+            \"-Xlog:cds\",\n+            \"-Xlog:cds+dynamic=info\",\n+            VerifySharedSpaces,\n+            \"-cp\", appJar,\n+            mainAppClass)\n+            .assertNormalExit(output -> {\n+                output.shouldHaveExitValue(0)\n+                      .shouldContain(HELLO_WORLD)\n+                      .shouldContain(\"The shared archive file version \" + version2 + \" which is not current version \" + currentCDSVersion)\n+                      .shouldContain(\"UseSharedSpaces: The shared archive file has the wrong version\")\n+                      .shouldContain(\"UseSharedSpaces: Initialize dynamic archive failed\")\n+                      .shouldContain(\"Dumping shared data to file\");\n+            });\n+        ft2 = Files.getLastModifiedTime(Paths.get(modVersion));\n+        fileModified = !ft1.equals(ft2);\n+        if (!fileModified) {\n+            throw new RuntimeException(\"Run -XX:+AutoCreateSharedArchive with higher version archive \" + modVersion + \" should create new archive\");\n+        }\n+\n+        \/\/ 14 run with an archive whose base name is not matched, no share\n+        print(\"14 run with an archive whose base name is not matched, no share\");\n+        String baseNameMismatch= startNewArchive(\"basename-mismatch\");\n+        copiedJsa = CDSArchiveUtils.copyArchiveFile(archiveFile, baseNameMismatch);\n+        int nameSize = CDSArchiveUtils.baseArchiveNameSize(copiedJsa);\n+        int offset = CDSArchiveUtils.baseArchiveNameOffset(copiedJsa);\n+        StringBuilder sb = new StringBuilder();\n+        for (int i = 0; i < nameSize - 4; i++) {\n+            sb.append('Z');\n+        }\n+        sb.append(\".jsa\");\n+        sb.append('\\0');\n+        String newName = sb.toString();\n+        CDSArchiveUtils.writeData(copiedJsa, offset, newName.getBytes());\n+\n+        ft1 = Files.getLastModifiedTime(Paths.get(baseNameMismatch));\n+        run(baseNameMismatch,\n+            \"-Xshare:auto\",\n+            \"-XX:+AutoCreateSharedArchive\",\n+            \"-Xlog:cds\",\n+            \"-Xlog:cds+dynamic=info\",\n+            VerifySharedSpaces,\n+            \"-cp\", appJar,\n+            mainAppClass)\n+            .assertNormalExit(output -> {\n+                output.shouldHaveExitValue(0)\n+                      .shouldContain(HELLO_WORLD)\n+                      .shouldNotContain(\"Dumping shared data to file\");\n+                });\n+        ft2 = Files.getLastModifiedTime(Paths.get(baseNameMismatch));\n+\n+        fileModified = !ft1.equals(ft2);\n+        if (fileModified) {\n+            throw new RuntimeException(\"Shared archive \" + baseNameMismatch+ \" should not automatically be generated\");\n+        }\n+\n+        \/\/ 15 mismatched jvm_indent in archive, create (-VerifySharedSpaces) or not (-XX:+VerifySharedSpaces) create the new archive\n+        print(\"15 mismatched jvm_indent in archive, \" + (verifyOn ? \"-XX:+VerifySharedSpaces not \" : \"-XX:-VerifySharedSpaces \") + \"create new archive\");\n+        String modJvmIdent = startNewArchive(\"modify-jvmident\");\n+        copiedJsa = CDSArchiveUtils.copyArchiveFile(archiveFile, modJvmIdent);\n+        CDSArchiveUtils.modifyHeaderIntField(copiedJsa, CDSArchiveUtils.offsetJvmIdent(), 0x65656565);\n+        ft1 = Files.getLastModifiedTime(Paths.get(modJvmIdent));\n+\n+        run(modJvmIdent,\n+            \"-Xshare:auto\",\n+            \"-XX:+AutoCreateSharedArchive\",\n+            \"-Xlog:cds\",\n+            \"-Xlog:cds+dynamic=info\",\n+            VerifySharedSpaces,\n+            \"-cp\", appJar,\n+            mainAppClass)\n+            .assertNormalExit(output -> {\n+                output.shouldHaveExitValue(0);\n+                if (verifyOn) {\n+                    output.shouldContain(\"UseSharedSpaces: Header checksum verification failed\")\n+                          .shouldContain(\"Unable to use shared archive: invalid archive\")\n+                          .shouldNotContain(\"Dumping shared data to file\");\n+                } else {\n+                    output.shouldContain(HELLO_WORLD)\n+                          .shouldContain(\"Dumping shared data to file\");\n+                }\n+            });\n+        ft2 = Files.getLastModifiedTime(Paths.get(modJvmIdent));\n+        fileModified = !ft1.equals(ft2);\n+        if (verifyOn) {\n+            if (fileModified) {\n+                throw new RuntimeException(\"Shared archive \" + modJvmIdent + \" should not be generated\");\n+            }\n+\n+        } else {\n+            if (!fileModified) {\n+                throw new RuntimeException(\"Shared archive \" + modJvmIdent + \" should be generated\");\n+            }\n+        }\n+\n+        \/\/ 16 run with an archive of only containing dynamic magic (size of 4) will not create new archive at exit\n+        print(\"16 run with an archive of only containing dynamic magic (size of 4) will not create new archive at exit\");\n+        String magicOnly = startNewArchive(\"magic-only\");\n+        copiedJsa = CDSArchiveUtils.createMagicOnlyFile(magicOnly, false\/*dynamic*\/);\n+        ft1 = Files.getLastModifiedTime(Paths.get(magicOnly));\n+        run(magicOnly,\n+            \"-Xshare:auto\",\n+            \"-XX:+AutoCreateSharedArchive\",\n+            \"-Xlog:cds\",\n+            \"-Xlog:cds+dynamic=info\",\n+            \"-cp\", appJar,\n+            mainAppClass)\n+            .assertNormalExit(output -> {\n+                output.shouldHaveExitValue(0)\n+                      .shouldContain(HELLO_WORLD)\n+                      .shouldContain(\"Unable to read generic CDS file map header from shared archive\")\n+                      .shouldNotContain(\"Dumping shared data to file:\");\n+                });\n+        ft2 = Files.getLastModifiedTime(Paths.get(magicOnly));\n+        fileModified = !ft1.equals(ft2);\n+        if (fileModified) {\n+            throw new RuntimeException(\"Shared archive \" + magicOnly + \" should not automatically be generated\");\n+        }\n+\n+        \/\/ Do some base tests for -XX:SharedArchiveFile=base:top, they should be same as default archive as base.\n+        \/\/ delete top archive\n+        if (archiveFile.exists()) {\n+            archiveFile.delete();\n+        }\n+        \/\/ delete base archive\n+        File baseFile = new File(BASE_NAME);\n+        if (baseFile.exists()) {\n+            baseFile.delete();\n+        }\n+\n+        \/\/ 20 Testing with -XX:SharedArchiveFile=base:top\n+        print(\"20 Testing with -XX:SharedArchiveFile=base:top\");\n+        \/\/ 20.1 dump base archive and top archive\n+        print(\"    20.1 dump base archive \" + BASE_NAME);\n+        dumpBaseArchive(BASE_NAME, \"-Xlog:cds\")\n+            .assertNormalExit(output -> {\n+                output.shouldHaveExitValue(0);\n+            });\n+        checkFileExists(BASE_NAME);\n+\n+        \/\/ 20.2 dump top based on base\n+        print(\"    20.2 dump top based on base\");\n+        dump2(BASE_NAME, TOP_NAME,\n+              \"-Xlog:cds\",\n+              \"-cp\", appJar, mainAppClass)\n+              .assertNormalExit(output -> {\n+                  output.shouldHaveExitValue(0)\n+                        .shouldContain(\"Dumping shared data to file:\")\n+                        .shouldContain(TOP_NAME);\n+              });\n+        checkFileExists(TOP_NAME);\n+\n+        \/\/ 20.3 run with base and top\n+        print(\"    20.3 run with base and top\");\n+        run2(BASE_NAME, TOP_NAME,\n+             \"-Xlog:cds\",\n+             \"-Xlog:cds+dynamic=info\",\n+             \"-Xlog:class+load\",\n+             \"-cp\", appJar,\n+             mainAppClass)\n+            .assertNormalExit(output -> {\n+                output.shouldHaveExitValue(0)\n+                      .shouldContain(HELLO_SOURCE);\n+            });\n+\n+        \/\/ 21 Mismatched versions\n+        print(\"21 Mismatched versions\");\n+        \/\/   21.01 top version is lower than CDS_GENERIC_HEADER_SUPPORTED_MIN_VERSION, regenerate top\n+        print(\"  21.01 top version is lower than CDS_GENERIC_HEADER_SUPPORTED_MIN_VERSION, regenerate top\");\n+        String versionB = startNewArchive(\"modify-version-B\");\n+        archiveFile = new File(TOP_NAME);\n+        copiedJsa = CDSArchiveUtils.copyArchiveFile(archiveFile, versionB);\n+        CDSArchiveUtils.modifyHeaderIntField(copiedJsa, CDSArchiveUtils.offsetVersion(), version1);\n+        ft1 = Files.getLastModifiedTime(Paths.get(versionB));\n+\n+        run2(BASE_NAME, versionB,\n+             \"-Xshare:auto\",\n+             \"-XX:+AutoCreateSharedArchive\",\n+             \"-Xlog:cds\",\n+             \"-Xlog:cds+dynamic=info\",\n+             VerifySharedSpaces,\n+             \"-cp\", appJar,\n+             mainAppClass)\n+             .assertNormalExit(output -> {\n+                 output.shouldHaveExitValue(0)\n+                       .shouldContain(HELLO_WORLD)\n+                       .shouldContain(\"Cannot handle shared archive file version \" + version1)\n+                       .shouldContain(versionB)\n+                       .shouldContain(\"Dumping shared data to file:\");\n+             });\n+        ft2 = Files.getLastModifiedTime(Paths.get(versionB));\n+        fileModified = !ft1.equals(ft2);\n+        if (!fileModified) {\n+            throw new RuntimeException(\"Shared archive \" + versionB + \" should automatically be generated\");\n+        }\n+\n+        \/\/   21.02 top version is higher than CDS_GENERIC_HEADER_SUPPORTED_MIN_VERSION, no share for top, create archive at exit\n+        print(\"  21.02 top version is higher than CDS_GENERIC_HEADER_SUPPORTED_MIN_VERSION, no share for top, create archive at exit\");\n+        String versionF = startNewArchive(\"versionF\");\n+        copiedJsa = CDSArchiveUtils.copyArchiveFile(archiveFile, versionF);\n+        CDSArchiveUtils.modifyHeaderIntField(copiedJsa, CDSArchiveUtils.offsetVersion(), version2);\n+        ft1 = Files.getLastModifiedTime(Paths.get(versionF));\n+        run2(BASE_NAME, versionF,\n+             \"-Xshare:auto\",\n+             \"-XX:+AutoCreateSharedArchive\",\n+             \"-Xlog:cds\",\n+             \"-Xlog:cds+dynamic=info\",\n+             VerifySharedSpaces,\n+             \"-cp\", appJar,\n+             mainAppClass)\n+             .assertNormalExit(output -> {\n+                 output.shouldContain(\"The shared archive file version \" + version2 + \" which is not current version \" + currentCDSVersion)\n+                       .shouldContain(HELLO_WORLD)\n+                       .shouldContain(\"Dumping shared data to file:\");\n+             });\n+        ft2 = Files.getLastModifiedTime(Paths.get(versionB));\n+        fileModified = !ft1.equals(ft2);\n+        if (!fileModified) {\n+            throw new RuntimeException(\"Shared archive \" + versionB + \" should be created at exit\");\n+        }\n+\n+        \/\/ 22 create an archive with dynamic magic number only\n+        \/\/    archive will be created at exit if base can be shared.\n+        print(\"22 create an archive with dynamic magic number only\");\n+        copiedJsa = CDSArchiveUtils.createMagicOnlyFile(magicOnly, false \/*dynamic*\/);\n+        ft1 = Files.getLastModifiedTime(Paths.get(magicOnly));\n+        run2(BASE_NAME, magicOnly,\n+             \"-Xshare:auto\",\n+             \"-XX:+AutoCreateSharedArchive\",\n+             \"-Xlog:cds\",\n+             \"-Xlog:cds+dynamic=info\",\n+             VerifySharedSpaces,\n+             \"-cp\", appJar,\n+             mainAppClass)\n+             .assertNormalExit(output -> {\n+                 output.shouldContain(HELLO_WORLD)\n+                       .shouldContain(\"Unable to read generic CDS file map header from shared archive\")\n+                       .shouldContain(\"Dumping shared data to file:\");\n+             });\n+        ft2 = Files.getLastModifiedTime(Paths.get(magicOnly));\n+        fileModified = !ft1.equals(ft2);\n+        if (!fileModified) {\n+            throw new RuntimeException(\"Shared archive \" + magicOnly + \" should not be created at exit\");\n+        }\n+\n+        \/\/ 23 run -Xshare:auto -XX:SharedArchiveFile=<static> -XX:+AutoCreateSharedArchive\n+        \/\/    run with a static archive. No dynamic archive is created at exit.\n+        print(\"23 Run -Xshare:auto -XX:SharedArchiveFile=<static> -XX:+AutoCreateSharedArchive\");\n+        ft1 = Files.getLastModifiedTime(Paths.get(BASE_NAME));\n+        run(BASE_NAME,\n+            \"-Xshare:auto\",\n+            \"-XX:+AutoCreateSharedArchive\",\n+            \"-Xlog:cds\",\n+            \"-Xlog:cds+dynamic=info\",\n+             VerifySharedSpaces,\n+            \"-cp\", appJar,\n+            mainAppClass)\n+            .assertNormalExit(output -> {\n+                output.shouldHaveExitValue(0)\n+                      .shouldContain(\"AutoCreateSharedArchive will be ignored for static archive\")\n+                      .shouldContain(HELLO_WORLD)\n+                      .shouldNotContain(\"Dumping shared data to file\");\n+                });\n+        ft2 = Files.getLastModifiedTime(Paths.get(BASE_NAME));\n+        fileModified = !ft1.equals(ft2);\n+        if (fileModified) {\n+            throw new RuntimeException(\"Shared archive \" + BASE_NAME + \" should not be created at exit\");\n+        }\n+\n+        \/\/ 24 run -Xshare:auto -XX:+AutoCreateSharedArchive -XX:SharedArchiveFile=base.jsa:non-exist-top.jsa\n+        print(\"24 run -Xshare:auto -XX:+AutoCreateSharedArchive -XX:SharedArchiveFile=base.jsa:non-exist-top.jsa\");\n+        String nonExistTop = \"non-existing-top.jsa\";\n+        File fileNonExist = new File(nonExistTop);\n+        if (fileNonExist.exists()) {\n+            fileNonExist.delete();\n+        }\n+        run2(BASE_NAME, nonExistTop,\n+             \"-Xshare:auto\",\n+             \"-XX:+AutoCreateSharedArchive\",\n+             \"-Xlog:cds\",\n+             \"-Xlog:cds+dynamic=info\",\n+             VerifySharedSpaces,\n+             \"-cp\", appJar,\n+             mainAppClass)\n+             .assertNormalExit(output -> {\n+                 output.shouldContain(\"Specified shared archive not found (\" + nonExistTop + \")\")\n+                       .shouldContain(HELLO_WORLD)\n+                       .shouldContain(\"Dumping shared data to file:\");\n+             });\n+        if (!fileNonExist.exists()) {\n+            throw new RuntimeException(\"Shared archive \" + nonExistTop + \" should be created at exit\");\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/TestAutoCreateSharedArchive.java","additions":611,"deletions":0,"binary":false,"changes":611,"status":"added"},{"patch":"@@ -344,0 +344,12 @@\n+    public static File createMagicOnlyFile(String fileName, boolean createStatic) throws Exception {\n+        File file = new File(fileName);\n+        if (file.exists()) {\n+            file.delete();\n+        }\n+        try (FileOutputStream out = new FileOutputStream(file)) {\n+            ByteBuffer buffer = ByteBuffer.allocate(4).putInt(createStatic ? staticMagic: dynamicMagic);\n+            out.write(buffer.array(), 0, 4);\n+        }\n+        return file;\n+    }\n+\n","filename":"test\/lib\/jdk\/test\/lib\/cds\/CDSArchiveUtils.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"}]}