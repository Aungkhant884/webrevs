{"files":[{"patch":"@@ -773,1 +773,2 @@\n-    int hops_expected = (int)(((end-beg-1)+(free_sentinel-2))\/(free_sentinel-1));\n+    int hops_expected\n+      = checked_cast<int>(((end-beg-1)+(free_sentinel-2))\/(free_sentinel-1));\n","filename":"src\/hotspot\/share\/memory\/heap.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -449,0 +449,15 @@\n+\/\/ In many places we've added C-style casts to silence compiler\n+\/\/ warnings, for example when truncating a size_t to an int when we\n+\/\/ know the size_t is a small struct. Such casts are risky because\n+\/\/ they effectively disable useful compiler warnings. We can make our\n+\/\/ lives safer with this function, which ensures that any cast is\n+\/\/ reversible without loss of information. It doesn't check\n+\/\/ everything: it isn't intended to make sure that pointer types are\n+\/\/ compatible, for example.\n+template <typename T2, typename T1>\n+T2 checked_cast(T1 thing) {\n+  T2 result = static_cast<T2>(thing);\n+  assert(static_cast<T1>(result) == thing, \"must be\");\n+  return result;\n+}\n+\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"}]}