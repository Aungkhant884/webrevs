{"files":[{"patch":"@@ -595,1 +595,0 @@\n-javax\/net\/ssl\/SSLEngine\/Basics.java                             8298867 generic-all\n","filename":"test\/jdk\/ProblemList.txt","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,0 +39,1 @@\n+import java.util.Arrays;\n@@ -56,0 +57,3 @@\n+    private static final String TLS13_CIPHER_SUITE = \"TLS_AES_256_GCM_SHA384\";\n+    private static final String TLS13_PROTOCOL = \"TLSv1.3\";\n+\n@@ -80,2 +84,7 @@\n-        String secondSuite = suites[1];\n-        String [] oneSuites = new String [] { secondSuite };\n+        \/\/ sanity check that the ciphersuite we want to use is still supported\n+        Arrays.stream(suites)\n+                .filter(s -> s.equals(TLS13_CIPHER_SUITE))\n+                .findFirst()\n+                .orElseThrow((() ->\n+                        new RuntimeException(TLS13_CIPHER_SUITE +\n+                                \" is not a supported ciphersuite.\")));\n@@ -85,1 +94,1 @@\n-        ssle.setEnabledCipherSuites(oneSuites);\n+        ssle.setEnabledCipherSuites(new String [] { TLS13_CIPHER_SUITE });\n@@ -90,1 +99,1 @@\n-                !(suites[0].equals(secondSuite))) {\n+                !(suites[0].equals(TLS13_CIPHER_SUITE))) {\n@@ -97,2 +106,7 @@\n-        String secondProtocol = protocols[1];\n-        String [] oneProtocols = new String [] { protocols[1] };\n+        \/\/ sanity check that the protocol we want is still supported\n+        Arrays.stream(protocols)\n+                .filter(p -> p.equals(TLS13_PROTOCOL))\n+                .findFirst()\n+                .orElseThrow(() ->\n+                        new RuntimeException(TLS13_PROTOCOL +\n+                                \" is not a supported TLS protocol.\"));\n@@ -102,1 +116,1 @@\n-        ssle.setEnabledProtocols(oneProtocols);\n+        ssle.setEnabledProtocols(new String[]{ TLS13_PROTOCOL });\n@@ -107,1 +121,1 @@\n-                !(protocols[0].equals(secondProtocol))) {\n+                !(protocols[0].equals(TLS13_PROTOCOL))) {\n@@ -180,5 +194,0 @@\n-        \/\/\n-        \/\/if (ssle.unwrap(smallBB, smallBB).getStatus() !=\n-        \/\/      Status.BUFFER_OVERFLOW) {\n-        \/\/    throw new Exception(\"unwrap should have overflowed\");\n-        \/\/}\n@@ -202,5 +211,9 @@\n-        \/* Checking for overflow wrap\/unwrap() *\/\n-\n-        if (ssle.wrap(appBB, netBB).getStatus() !=\n-                Status.BUFFER_OVERFLOW) {\n-            throw new Exception(\"unwrap should have overflowed\");\n+        \/*\n+         * After the first call to wrap(), the handshake status is\n+         * NEED_UNWRAP and we need to receive data before doing anymore\n+         * handshaking.\n+         *\/\n+        SSLEngineResult result = ssle.wrap(appBB, netBB);\n+        if (result.getStatus() != Status.OK\n+            && result.bytesConsumed() != 0 && result.bytesProduced() != 0) {\n+            throw new Exception(\"wrap should have returned without doing anything\");\n@@ -257,0 +270,5 @@\n+            \/*\n+             * Exceptions are thrown when:\n+             *    - the length field is correct but the data can't be decoded.\n+             *    - the length field is larger than max allowed.\n+             *\/\n@@ -258,3 +276,5 @@\n-            throw new Exception(\"Didn't catch the nasty SSLException\");\n-        } catch (SSLException e) {\n-            System.out.println(\"caught the nasty SSLException: \" + e);\n+            throw new Exception(\"Expected SSLProtocolException was not thrown \"\n+                    + \"for bad input\");\n+        } catch (SSLProtocolException e) {\n+            System.out.println(\"caught the SSLProtocolException for bad decoding: \"\n+                    + e);\n@@ -281,2 +301,2 @@\n-        \/\/ \"HELLO HELLO\"\n-        (byte) 0x48, (byte) 0x45, (byte) 0x4C, (byte) 0x4C, (byte) 0x20,\n+        \/\/ bad data but correct record length to cause decryption error\n+        (byte) 0x48, (byte) 0x45, (byte) 0x4C, (byte) 0x00, (byte) 0x04,\n","filename":"test\/jdk\/javax\/net\/ssl\/SSLEngine\/Basics.java","additions":44,"deletions":24,"binary":false,"changes":68,"status":"modified"}]}