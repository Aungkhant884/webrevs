{"files":[{"patch":"@@ -335,0 +335,76 @@\n+    \/**\n+     * Constructs a channel that reads bytes from the given stream into\n+     * a sequence of buffers.\n+     *\n+     * <p> The resulting channel will not be buffered; it will simply redirect\n+     * its I\/O operations to the given stream.  Closing the channel will in\n+     * turn cause the stream to be closed.  <\/p>\n+     *\n+     * @param  in\n+     *         The stream from which bytes are to be read\n+     *\n+     * @return  A new scattering byte channel\n+     *\n+     * @since 18\n+     *\/\n+    public static ScatteringByteChannel newScatteringChannel(InputStream in) {\n+        Objects.requireNonNull(in, \"in\");\n+\n+        if (in.getClass() == FileInputStream.class) {\n+            return ((FileInputStream) in).getChannel();\n+        }\n+\n+        return new ScatteringByteChannelImpl(in);\n+    }\n+\n+    private static class ScatteringByteChannelImpl\n+        extends ReadableByteChannelImpl\n+        implements ScatteringByteChannel\n+    {\n+        ScatteringByteChannelImpl(InputStream in) {\n+            super(in);\n+        }\n+\n+        public long read(ByteBuffer[] dsts, int offset, int length)\n+            throws IOException {\n+            if (!isOpen()) {\n+                throw new ClosedChannelException();\n+            }\n+\n+            Objects.checkFromIndexSize(offset, length, dsts.length);\n+\n+            for (ByteBuffer dst : dsts)\n+                if (dst.isReadOnly())\n+                    throw new IllegalArgumentException();\n+\n+            long totalBytesRead = 0L;\n+            int maxIndex = offset + length;\n+            for (int i = offset; i < maxIndex; i++) {\n+                int rem = dsts[i].remaining();\n+\n+                if (rem == 0) continue;\n+\n+                int n;\n+                long nfree = Long.MAX_VALUE - totalBytesRead;\n+                if (nfree >= rem) {\n+                    n = read(dsts[i]);\n+                } else {\n+                    int lim = dsts[i].limit();\n+                    \/\/ Cast of nfree safe as condition nfree < rem obtains\n+                    dsts[i].limit(dsts[i].position() + (int)nfree);\n+                    n = read(dsts[i]);\n+                    dsts[i].limit(lim);\n+                }\n+\n+                if (n < 0) return totalBytesRead;\n+\n+                totalBytesRead += n;\n+            }\n+\n+            return totalBytesRead;\n+        }\n+\n+        public final long read(ByteBuffer[] dsts) throws IOException {\n+            return read(dsts, 0, dsts.length);\n+        }\n+    }\n@@ -404,0 +480,71 @@\n+    \/**\n+     * Constructs a channel that writes bytes to the given stream from\n+     * a sequence of buffers.\n+     *\n+     * <p> The resulting channel will not be buffered; it will simply redirect\n+     * its I\/O operations to the given stream.  Closing the channel will in\n+     * turn cause the stream to be closed.  <\/p>\n+     *\n+     * @param  out\n+     *         The stream to which bytes are to be written\n+     *\n+     * @return  A new gathering byte channel\n+     *\n+     * @since 18\n+     *\/\n+    public static GatheringByteChannel newGatheringChannel(OutputStream out) {\n+        Objects.requireNonNull(out, \"out\");\n+\n+        if (out.getClass() == FileOutputStream.class) {\n+            return ((FileOutputStream) out).getChannel();\n+        }\n+\n+        return new GatheringByteChannelImpl(out);\n+    }\n+\n+    private static class GatheringByteChannelImpl\n+        extends WritableByteChannelImpl\n+        implements GatheringByteChannel\n+    {\n+        GatheringByteChannelImpl(OutputStream out) {\n+            super(out);\n+        }\n+\n+        public long write(ByteBuffer[] srcs, int offset, int length)\n+            throws IOException {\n+            if (!isOpen()) {\n+                throw new ClosedChannelException();\n+            }\n+\n+            Objects.checkFromIndexSize(offset, length, srcs.length);\n+\n+            long totalBytesWritten = 0L;\n+            final int maxIndex = offset + length;\n+            for (int i = offset; i < maxIndex; i++) {\n+                int rem = srcs[i].remaining();\n+\n+                if (rem == 0) continue;\n+\n+                int n;\n+                long nfree = Long.MAX_VALUE - totalBytesWritten;\n+                if (nfree >= rem) {\n+                    n = write(srcs[i]);\n+                } else {\n+                    int lim = srcs[i].limit();\n+                    \/\/ Cast of nfree safe as condition nfree < rem obtains\n+                    srcs[i].limit(srcs[i].position() + (int)nfree);\n+                    n = write(srcs[i]);\n+                    srcs[i].limit(lim);\n+                }\n+\n+                totalBytesWritten += n;\n+            }\n+\n+            return totalBytesWritten;\n+        }\n+\n+        public final long write(ByteBuffer[] srcs) throws IOException {\n+            return write(srcs, 0, srcs.length);\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/nio\/channels\/Channels.java","additions":147,"deletions":0,"binary":false,"changes":147,"status":"modified"},{"patch":"@@ -0,0 +1,355 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4619075\n+ * @summary Verify gathering and scattering of Channels.newChannel creations\n+ * @library ..\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.RandomFactory\n+ * @run testng\/othervm\/timeout=900 -Xmx8G GatherAndScatter\n+ * @key randomness\n+ *\/\n+import java.io.BufferedInputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.FilterInputStream;\n+import java.io.FilterOutputStream;\n+import java.io.InputStream;\n+import java.io.IOException;\n+import java.io.RandomAccessFile;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.Channels;\n+import java.nio.channels.ClosedChannelException;\n+import java.nio.channels.FileChannel;\n+import java.nio.channels.GatheringByteChannel;\n+import java.nio.channels.ReadableByteChannel;\n+import java.nio.channels.ScatteringByteChannel;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Random;\n+\n+import jdk.test.lib.RandomFactory;\n+\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import static java.nio.file.StandardOpenOption.READ;\n+import static java.nio.file.StandardOpenOption.WRITE;\n+\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertNotNull;\n+import static org.testng.Assert.assertThrows;\n+import static org.testng.Assert.assertFalse;\n+import static org.testng.Assert.assertTrue;\n+\n+public class GatherAndScatter {\n+\n+    private static final Random RAND = RandomFactory.getRandom();\n+\n+    \/\/ Number of different cases per test\n+    private static final int NUM_CASES = 50;\n+\n+    \/\/ Number of buffers per case\n+    private static final int MAX_BUFFERS = 20;\n+\n+    \/\/ List of paths to files populated by the gathering test\n+    \/\/ and read by the scattering test\n+    private List<Path> paths = new ArrayList(NUM_CASES);\n+\n+    \/\/\n+    \/\/ Creates a temporary file which will be deleted on exit\n+    \/\/\n+    private static File createTempFile() throws IOException {\n+        Path path = Files.createTempFile(Path.of(\".\"), \"foo\", \".bar\");\n+        File file = path.toFile();\n+        file.deleteOnExit();\n+        return file;\n+    }\n+\n+    \/\/\n+    \/\/ Interface denoting a lamda with signature (ByteBuffer[],int,int)\n+    \/\/\n+    @FunctionalInterface\n+    private interface GatheringOrScatteringByteChannel {\n+        long writeOrRead(ByteBuffer[] bufs, int offset, int length)\n+            throws IOException;\n+    }\n+\n+    \/\/\n+    \/\/ Tests for NPEs and preconditions on the offset and length\n+    \/\/\n+    private static void testParamExceptions(GatheringOrScatteringByteChannel ch)\n+        throws IOException {\n+        \/\/ null buffer array\n+        assertThrows(NullPointerException.class,\n+            () -> {ch.writeOrRead(null, 0, 1);});\n+\n+        \/\/ array containing one null buffer\n+        int numBufs = 1 + RAND.nextInt(32);\n+        ByteBuffer[] bufs = new ByteBuffer[numBufs];\n+        byte[] b = new byte[0];\n+        int nullIndex = RAND.nextInt(numBufs);\n+        for (int i = 0; i < numBufs; i++)\n+            if (i != nullIndex)\n+                bufs[i] = ByteBuffer.wrap(b);\n+        assertThrows(NullPointerException.class,\n+           () -> {ch.writeOrRead(bufs, 0, numBufs);});\n+\n+        \/\/ preconditions on the offset and length parameters\n+        assertThrows(IndexOutOfBoundsException.class,\n+            () -> {ch.writeOrRead(bufs, -1, bufs.length);});\n+        assertThrows(IndexOutOfBoundsException.class,\n+            () -> {ch.writeOrRead(bufs, 1, bufs.length);});\n+        assertThrows(IndexOutOfBoundsException.class,\n+            () -> {ch.writeOrRead(bufs, 0, bufs.length + 1);});\n+        assertThrows(IndexOutOfBoundsException.class,\n+            () -> {ch.writeOrRead(bufs, bufs.length\/2, bufs.length\/2 + 2);});\n+    }\n+\n+    \/\/\n+    \/\/ Test handling of basic exceptions when gathering\n+    \/\/\n+    @Test(priority = 0)\n+    public void gatheringExceptions() throws IOException {\n+        File file = createTempFile();\n+        try (FileOutputStream fos = new FileOutputStream(file);\n+            FilterOutputStream filfos = new FilterOutputStream(fos)) {\n+            \/\/ Create a Channels$GatheringByteChannelImpl\n+            try (GatheringByteChannel gbc = Channels.newGatheringChannel(filfos)) {\n+                \/\/ test parameters\n+                testParamExceptions((a, b, c) -> gbc.write(a, b, c));\n+\n+                \/\/ channel is closed\n+                gbc.close();\n+                assertThrows(ClosedChannelException.class,\n+                    () -> {gbc.write(null, 0, 1);});\n+            }\n+        }\n+    }\n+\n+    \/\/\n+    \/\/ Test handling of basic exceptions when scattering\n+    \/\/\n+    @Test(priority = 0)\n+    public void scatteringExceptions() throws IOException {\n+        File file = createTempFile();\n+        try (RandomAccessFile raf = new RandomAccessFile(file, \"rw\")) {\n+            raf.setLength(1024);\n+        }\n+        try (FileInputStream fis = new FileInputStream(file);\n+            BufferedInputStream filfis = new BufferedInputStream(fis)) {\n+            \/\/ Create a Channels$ScatteringByteChannelImpl\n+            try (ScatteringByteChannel sbc = Channels.newScatteringChannel(filfis)) {\n+                \/\/ test parameters\n+                testParamExceptions((a, b, c) -> sbc.read(a, b, c));\n+\n+                \/\/ one of buffers is read-only\n+                int numSrcs = 1 + RAND.nextInt(32);\n+                ByteBuffer[] srcs = new ByteBuffer[numSrcs];\n+                byte[] b = new byte[1];\n+                int readOnlyIndex = RAND.nextInt(numSrcs);\n+                for (int i = 0; i < numSrcs; i++) {\n+                    srcs[i] = ByteBuffer.wrap(b);\n+                    if (i == readOnlyIndex)\n+                        srcs[i] = srcs[i].asReadOnlyBuffer();\n+                }\n+                assertThrows(IllegalArgumentException.class,\n+                   () -> {sbc.read(srcs, 0, numSrcs);});\n+\n+                \/\/ channel is closed\n+                sbc.close();\n+                assertThrows(ClosedChannelException.class,\n+                    () -> {sbc.read(null, 0, 1);});\n+            }\n+        }\n+    }\n+\n+    \/\/\n+    \/\/ Returns an array of {{Path, int}, ...} where the Path represents an\n+    \/\/ empty file and the int its future length.\n+    \/\/\n+    @DataProvider\n+    public Object[][] gatheringProvider() throws IOException {\n+        Object[][] result = new Object[NUM_CASES][];\n+\n+        Path dir = Files.createTempDirectory(Path.of(\".\"), \"gatherScatter\");\n+        dir.toFile().deleteOnExit();\n+\n+        for (int i = 0; i < NUM_CASES; i++) {\n+            Path file = Files.createTempFile(dir, \"foo\", \".bar\");\n+            file.toFile().deleteOnExit();\n+            paths.add(file);\n+            int length = 1 + RAND.nextInt(1_000_000);\n+            result[i] = new Object[] {file, length};\n+        }\n+\n+        return result;\n+    }\n+\n+    \/\/\n+    \/\/ Tests gathering buffers into a channel\n+    \/\/\n+    @Test(dataProvider = \"gatheringProvider\", priority = 1)\n+    public void gather(Path f, int len) throws IOException {\n+        \/\/ Create a list of buffers filled with random bytes\n+        \/\/ whose total length is len\n+        int total = 0;\n+        List<ByteBuffer> buffers = new ArrayList();\n+        while (total < len) {\n+            int count = buffers.size() == MAX_BUFFERS || len - total < 64 ?\n+                len - total : RAND.nextInt(len - total);\n+            byte[] b = new byte[count];\n+            RAND.nextBytes(b);\n+            buffers.add(ByteBuffer.wrap(b));\n+            total += count;\n+        }\n+\n+        \/\/ Derive an array of buffers from the list\n+        ByteBuffer[] bufs = buffers.toArray(new ByteBuffer[buffers.size()]);\n+\n+        \/\/ Verify that the total number of remaining bytes is as expected.\n+        int sum = 0;\n+        for (ByteBuffer buf : bufs)\n+            sum += buf.remaining();\n+        assertEquals(len, sum);\n+\n+        \/\/ Determine the range of buffers to use\n+        int offset = RAND.nextInt(bufs.length);\n+        int length = 1 + RAND.nextInt(bufs.length - offset);\n+\n+        \/\/ Write the contents of the range of buffers to the file\n+        try (FileOutputStream fos = new FileOutputStream(f.toFile());\n+             FilterOutputStream filfos = new FilterOutputStream(fos)) {\n+            \/\/ Count the number of bytes which should be written\n+            sum = 0;\n+            for (int i = offset; i < offset + length; i++)\n+                sum += bufs[i].remaining();\n+\n+            try (GatheringByteChannel gbc = Channels.newGatheringChannel(filfos)) {\n+                \/\/ Gather the range of buffers into the file\n+                long written = gbc.write(bufs, offset, length);\n+\n+                \/\/ Verify that the number of bytes written is as expected\n+                assertEquals(written, sum, \"written != sum\");\n+            }\n+        }\n+\n+        \/\/ For each buffer in range, read the same number of bytes as it\n+        \/\/ contains and compare the two results\n+        try (FileChannel fc = FileChannel.open(f, READ)) {\n+            for (int i = offset; i < offset + length; i++) {\n+                ByteBuffer buf = bufs[i];\n+                buf.rewind();\n+                ByteBuffer dst = ByteBuffer.wrap(new byte[buf.remaining()]);\n+                fc.read(dst);\n+                dst.rewind();\n+                int mismatch = dst.mismatch(buf);\n+                assertEquals(mismatch, -1);\n+            }\n+        }\n+    }\n+\n+    \/\/\n+    \/\/ Returns an array of {{Path}, ...} where the Path represents a file\n+    \/\/ populated by data during the gathering test\n+    \/\/\n+    @DataProvider\n+    public Object[][] scatteringProvider() throws IOException {\n+        int numPaths = paths.size();\n+        Object[][] result = new Object[numPaths][];\n+\n+        for (int i = 0; i < numPaths; i++) {\n+            result[i] = new Object[] {paths.get(i)};\n+        }\n+\n+        return result;\n+    }\n+\n+    \/\/\n+    \/\/ Tests scattering buffers from a channel\n+    \/\/\n+    @Test(dataProvider = \"scatteringProvider\", priority = 2)\n+    public void scatter(Path f) throws IOException {\n+        int len = Math.toIntExact(Files.size(f));\n+\n+        \/\/ Create a list of buffers whose total length is len\n+        int total = 0;\n+        List<ByteBuffer> buffers = new ArrayList();\n+        while (total < len) {\n+            int count = buffers.size() == MAX_BUFFERS || len - total < 64 ?\n+                len - total : RAND.nextInt(len - total);\n+            buffers.add(ByteBuffer.allocate(count));\n+            total += count;\n+        }\n+\n+        \/\/ Derive an array of buffers from the list\n+        ByteBuffer[] bufs = buffers.toArray(new ByteBuffer[buffers.size()]);\n+\n+        \/\/ Verify that the total number of remaining bytes is as expected.\n+        int sum = 0;\n+        for (ByteBuffer buf : bufs)\n+            sum += buf.remaining();\n+        assertEquals(len, sum);\n+\n+        \/\/ Determine the range of buffers to use\n+        int offset = RAND.nextInt(bufs.length);\n+        int length = RAND.nextInt(bufs.length - offset);\n+\n+        \/\/ Read the contents of the file into the range of buffers\n+        try (FileInputStream fis = new FileInputStream(f.toFile());\n+             FilterInputStream filfis = new BufferedInputStream(fis)) {\n+            \/\/ Count the number of bytes which should be read\n+            sum = 0;\n+            for (int i = offset; i < offset + length; i++)\n+                sum += bufs[i].remaining();\n+\n+            try (ScatteringByteChannel sbc = Channels.newScatteringChannel(filfis)) {\n+                \/\/ Gather the range of buffers into the file\n+                long read = sbc.read(bufs, offset, length);\n+\n+                \/\/ Verify that the number of bytes read is as expected\n+                assertEquals(read, sum, \"read != sum\");\n+            }\n+        }\n+\n+        \/\/ For each buffer in range, read the same number of bytes as it\n+        \/\/ contains and compare the two results\n+        try (FileChannel fc = FileChannel.open(f, READ)) {\n+            for (int i = offset; i < offset + length; i++) {\n+                ByteBuffer buf = bufs[i];\n+                buf.rewind();\n+                ByteBuffer dst = ByteBuffer.wrap(new byte[buf.remaining()]);\n+                fc.read(dst);\n+                dst.rewind();\n+                int mismatch = dst.mismatch(buf);\n+                assertEquals(mismatch, -1);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/nio\/channels\/Channels\/GatherAndScatter.java","additions":355,"deletions":0,"binary":false,"changes":355,"status":"added"}]}