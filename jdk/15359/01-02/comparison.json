{"files":[{"patch":"@@ -514,16 +514,0 @@\n-void G1ConcurrentMark::old_region_reclaimed(HeapRegion* r) {\n-  assert_at_safepoint();\n-  assert(r->is_old(), \"must be\");\n-\n-  if (!_g1h->collector_state()->mark_or_rebuild_in_progress()) {\n-    return;\n-  }\n-\n-  \/\/ Old regions that would be reclaimed (i.e. were collection set candidates) during\n-  \/\/ the marking process are not marked through, so there are no bits on the mark\n-  \/\/ bitmap to clear.\n-\n-  \/\/ They have their TARS set though which needs to be cleared.\n-  clear_statistics(r);\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.cpp","additions":0,"deletions":16,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -487,2 +487,0 @@\n-  \/\/ Notification for old reclaimed regions to clean up\n-  void old_region_reclaimed(HeapRegion* r);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -91,4 +91,2 @@\n-    \/\/ has been aborted for any reason. Yielded is set if there has been an actual\n-    \/\/ yield for a pause.\n-    bool yield_if_necessary(bool& yielded) {\n-      yielded = false;\n+    \/\/ has been aborted for any reason.\n+    bool yield_if_necessary() {\n@@ -97,1 +95,1 @@\n-        yielded = _cm->do_yield_check();\n+        _cm->do_yield_check();\n@@ -127,2 +125,1 @@\n-        bool yielded;\n-        bool mark_aborted = yield_if_necessary(yielded);\n+        bool mark_aborted = yield_if_necessary();\n@@ -131,1 +128,1 @@\n-        } else if (yielded && !should_rebuild_or_scrub(hr)) {\n+        } else if (!should_rebuild_or_scrub(hr)) {\n@@ -133,1 +130,1 @@\n-          \/\/ have been reclaimed during the yield.\n+          \/\/ have been reclaimed during above yield\/safepoint.\n@@ -196,2 +193,1 @@\n-        bool yielded;\n-        bool mark_aborted = yield_if_necessary(yielded);\n+        bool mark_aborted = yield_if_necessary();\n@@ -200,2 +196,3 @@\n-        } else if (yielded && !should_rebuild_or_scrub(hr)) {\n-          \/\/ Region has been reclaimed while yielding. Exit continuing with the next region.\n+        } else if (!should_rebuild_or_scrub(hr)) {\n+          \/\/ We need to check should_rebuild_or_scrub() again because the region might\n+          \/\/ have been reclaimed during above yield\/safepoint.\n@@ -216,2 +213,1 @@\n-        bool yielded;\n-        bool mark_aborted = yield_if_necessary(yielded);\n+        bool mark_aborted = yield_if_necessary();\n@@ -220,1 +216,3 @@\n-        } else if (yielded && !should_rebuild_or_scrub(hr)) {\n+        } else if (!should_rebuild_or_scrub(hr)) {\n+          \/\/ We need to check should_rebuild_or_scrub() again because the region might\n+          \/\/ have been reclaimed during above yield\/safepoint.\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentRebuildAndScrub.cpp","additions":14,"deletions":16,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -557,3 +557,0 @@\n-    if (r->is_old()) {\n-      _g1h->concurrent_mark()->old_region_reclaimed(r);\n-    }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCPostEvacuateTasks.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"}]}