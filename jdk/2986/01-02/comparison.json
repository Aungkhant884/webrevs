{"files":[{"patch":"@@ -133,0 +133,38 @@\n+\/\/ Thread-safe attempt to remove and return the first buffer from\n+\/\/ the _completed queue, using the LockFreeQueue::try_pop() underneath.\n+\/\/ It has a restriction that it may return NULL when there are objects\n+\/\/ in the queue if there is a concurrent push\/append operation.\n+BufferNode* G1DirtyCardQueueSet::dequeue_completed_buffer() {\n+  using Status = LockFreeQueuePopStatus;\n+  Thread* current_thread = Thread::current();\n+  while (true) {\n+    \/\/ Use GlobalCounter critical section to avoid ABA problem.\n+    \/\/ The release of a buffer to its allocator's free list uses\n+    \/\/ GlobalCounter::write_synchronize() to coordinate with this\n+    \/\/ dequeuing operation.\n+    \/\/ We use a CS per iteration, rather than over the whole loop,\n+    \/\/ because we're not guaranteed to make progress. Lingering in\n+    \/\/ one CS could defer releasing buffer to the free list for reuse,\n+    \/\/ leading to excessive allocations.\n+    GlobalCounter::CriticalSection cs(current_thread);\n+    Pair<Status, BufferNode*> pop_result = _completed.try_pop();\n+    switch (pop_result.first) {\n+      case Status::success:\n+        return pop_result.second;\n+      case Status::operation_in_progress:\n+        \/\/ This could happen when a concurrent operation interferes with\n+        \/\/ this try_pop() taking the only element in the queue, in two cases:\n+        \/\/ (1) A concurrent try_pop() may have won the race to take the\n+        \/\/ element, but has not finished updating the queue. It is fine to\n+        \/\/ return NULL in this case.\n+        \/\/ (2) A concurrent push\/append is ongoing. We cannot take result,\n+        \/\/ and we don't just try again, because we could spin for a long time\n+        \/\/ waiting for the push\/append to finish. We just return NULL, which\n+        \/\/ is OK for a thread getting a buffer to refine.\n+        return NULL;\n+      case Status::lost_race:\n+        break;  \/\/ Try again.\n+    }\n+  }\n+}\n+\n@@ -134,1 +172,1 @@\n-  BufferNode* result = _completed.pop();\n+  BufferNode* result = dequeue_completed_buffer();\n@@ -137,1 +175,1 @@\n-    result = _completed.pop();\n+    result = dequeue_completed_buffer();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1DirtyCardQueue.cpp","additions":40,"deletions":2,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -80,10 +80,0 @@\n-  class CompletedQueue: public LockFreeQueue<BufferNode, &BufferNode::next_ptr> {\n-  public:\n-    BufferNode* pop() {\n-      \/\/ Use GlobalCounter critical section to avoid ABA problem.\n-      \/\/ The release of a BufferNode to its allocator's free list uses\n-      \/\/ GlobalCounter::write_synchronize() to coordinate with the pop().\n-      return LockFreeQueue<BufferNode, &BufferNode::next_ptr>::pop<true \/*use_rcu*\/>();\n-    }\n-  };\n-\n@@ -177,1 +167,2 @@\n-  CompletedQueue _completed;  \/\/ Has inner padding, including trailer.\n+  \/\/ LockFreeQueue has inner padding, including trailer.\n+  LockFreeQueue<BufferNode, &BufferNode::next_ptr> _completed;\n@@ -179,1 +170,2 @@\n-  PausedBuffers _paused;      \/\/ Has inner padding, including trailer.\n+  \/\/ PausedBuffers has inner padding, including trailer.\n+  PausedBuffers _paused;\n@@ -225,0 +217,5 @@\n+  \/\/ Thread-safe attempt to remove and return the first buffer from\n+  \/\/ the _completed queue.\n+  \/\/ Returns NULL if the queue is empty, or if a concurrent push\/append\n+  \/\/ interferes. It uses GlobalCounter critical section to avoid ABA problem.\n+  BufferNode* dequeue_completed_buffer();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1DirtyCardQueue.hpp","additions":9,"deletions":12,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -88,3 +88,0 @@\n-\n-  \/\/ Similar to CriticalSection, but only enabled if \"enable\" is true.\n-  template<bool enable> class ConditionalCriticalSection;\n","filename":"src\/hotspot\/share\/utilities\/globalCounter.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -56,0 +56,1 @@\n+ private:\n@@ -58,1 +59,1 @@\n-public:\n+ public:\n@@ -69,17 +70,0 @@\n-template<bool enable> class GlobalCounter::ConditionalCriticalSection {\n-  Thread* _thread;\n-  CSContext _context;\n-public:\n-  inline ConditionalCriticalSection(Thread* thread) {\n-    if (enable) {\n-      _thread = thread;\n-      _context = GlobalCounter::critical_section_begin(thread);\n-    }\n-  }\n-  inline ~ConditionalCriticalSection() {\n-    if (enable) {\n-      GlobalCounter::critical_section_end(_thread, _context);\n-    }\n-  }\n-};\n-\n","filename":"src\/hotspot\/share\/utilities\/globalCounter.inline.hpp","additions":2,"deletions":18,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -32,0 +32,8 @@\n+\/\/ Return status of a LockFreeQueue::try_pop() call.\n+\/\/ See description for try_pop() below.\n+enum class LockFreeQueuePopStatus {\n+  success,\n+  lost_race,\n+  operation_in_progress\n+};\n+\n@@ -34,4 +42,3 @@\n-\/\/ optionally use GlobalCounter critical section in pop() to address\n-\/\/ the ABA problem. This class has a restriction that pop() may return\n-\/\/ NULL when there are objects in the queue if there is a concurrent\n-\/\/ push\/append operation.\n+\/\/ provides a try_pop() function for the client to implement pop()\n+\/\/ according to its need (e.g., whether or not to retry or prevent\n+\/\/ ABA problem).\n@@ -55,1 +62,1 @@\n-  static T* next(const T& node);\n+  static inline T* next(const T& node);\n@@ -59,1 +66,1 @@\n-  \/\/ concurrently run with push or pop operations that modify this\n+  \/\/ concurrently run with push or try_pop operations that modify this\n@@ -61,1 +68,1 @@\n-  static void set_next(T& node, T* new_next);\n+  static inline void set_next(T& node, T* new_next);\n@@ -64,1 +71,1 @@\n-  LockFreeQueue();\n+  inline LockFreeQueue();\n@@ -69,1 +76,1 @@\n-  T* top() const;\n+  inline T* top() const;\n@@ -72,1 +79,1 @@\n-  bool empty() const { return top() == NULL; }\n+  inline bool empty() const { return top() == NULL; }\n@@ -77,1 +84,1 @@\n-  size_t length() const;\n+  inline size_t length() const;\n@@ -80,1 +87,1 @@\n-  void push(T& node) { append(node, node); }\n+  inline void push(T& node) { append(node, node); }\n@@ -83,1 +90,1 @@\n-  void append(T& first, T& last);\n+  inline void append(T& first, T& last);\n@@ -86,6 +93,16 @@\n-  \/\/ Returns NULL if the queue is empty, or if a concurrent push\/append\n-  \/\/ interferes.\n-  \/\/ If use_rcu is true, it applies GlobalCounter critical sections to\n-  \/\/ address the ABA problem. This requires the object's\n-  \/\/ allocator use GlobalCounter synchronization to defer reusing object.\n-  template<bool use_rcu> T* pop();\n+  \/\/ Returns a <LockFreeQueuePopStatus, T*> pair for the caller to determine\n+  \/\/ further operation. 3 possible cases depending on pair.first:\n+  \/\/ - success:\n+  \/\/   The operation succeeded. If pair.second is NULL, the queue is empty;\n+  \/\/   otherwise caller can assume ownership of the object pointed by\n+  \/\/   pair.second. Note that this case still subjects to ABA behavior;\n+  \/\/   callers must ensure usage is safe.\n+  \/\/ - lost_race:\n+  \/\/   An atomic operation failed. pair.second is NULL.\n+  \/\/   The caller can typically retry in this case.\n+  \/\/ - operation_in_progress:\n+  \/\/   An in-progress concurrent operation interfered with taking the element\n+  \/\/   when it was the only element in the queue. pair.second is NULL.\n+  \/\/   Retrying in this case has a higher chance of waiting for a long time\n+  \/\/   before succeeding, compared to the \"lost_race\" case.\n+  inline Pair<LockFreeQueuePopStatus, T*> try_pop();\n@@ -95,1 +112,1 @@\n-  \/\/ push\/append\/pop operation.\n+  \/\/ push\/append\/try_pop operation.\n@@ -97,1 +114,1 @@\n-  Pair<T*, T*> take_all();\n+  inline Pair<T*, T*> take_all();\n","filename":"src\/hotspot\/share\/utilities\/lockFreeQueue.hpp","additions":38,"deletions":21,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -29,2 +29,0 @@\n-#include \"runtime\/thread.inline.hpp\"\n-#include \"utilities\/globalCounter.inline.hpp\"\n@@ -32,1 +30,0 @@\n-#include \"logging\/log.hpp\"\n@@ -81,1 +78,1 @@\n-\/\/ \"next\" value.  This also means that pop operations must handle an object\n+\/\/ \"next\" value.  This also means that try_pop operation must handle an object\n@@ -99,33 +96,9 @@\n-template<bool use_rcu>\n-T* LockFreeQueue<T, next_ptr>::pop() {\n-  while (true) {\n-    \/\/ Use a critical section per iteration, rather than over the whole\n-    \/\/ operation. We're not guaranteed to make progress. Lingering in one\n-    \/\/ CS could defer the write-side operation of RCU synchronization\n-    \/\/ too long, leading to unwanted effect. E.g., if the write-side\n-    \/\/ returns released objects to a free list for reuse, it could cause\n-    \/\/ excessive allocations.\n-    GlobalCounter::ConditionalCriticalSection<use_rcu> cs(use_rcu ?\n-                                                          Thread::current():\n-                                                          NULL);\n-\n-    \/\/ We only need memory_order_consume. Upgrade it to \"load_acquire\"\n-    \/\/ as the memory_order_consume API is not ready for use yet.\n-    T* result = Atomic::load_acquire(&_head);\n-    if (result == NULL) return NULL; \/\/ Queue is empty.\n-\n-    \/\/ This relaxed load is always followed by a cmpxchg(), thus it\n-    \/\/ is OK as the reader-side of the release-acquire ordering.\n-    T* next_node = Atomic::load(next_ptr(*result));\n-    if (next_node != NULL) {\n-      \/\/ The \"usual\" lock-free pop from the head of a singly linked list.\n-      if (result == Atomic::cmpxchg(&_head, result, next_node)) {\n-        \/\/ Former head successfully taken; it is not the last.\n-        assert(Atomic::load(&_tail) != result, \"invariant\");\n-        assert(next(*result) != NULL, \"invariant\");\n-        set_next(*result, NULL);\n-        return result;\n-      }\n-      \/\/ Lost the race; try again.\n-      continue;\n-    }\n+Pair<LockFreeQueuePopStatus, T*> LockFreeQueue<T, next_ptr>::try_pop() {\n+  typedef Pair<LockFreeQueuePopStatus, T*> StatusPair;\n+  \/\/ We only need memory_order_consume. Upgrade it to \"load_acquire\"\n+  \/\/ as the memory_order_consume API is not ready for use yet.\n+  T* result = Atomic::load_acquire(&_head);\n+  if (result == NULL) {\n+    \/\/ Queue is empty.\n+    return StatusPair(LockFreeQueuePopStatus::success, NULL);\n+  }\n@@ -133,16 +106,11 @@\n-    \/\/ next is NULL.  This case is handled differently from the \"usual\"\n-    \/\/ lock-free pop from the head of a singly linked list.\n-\n-    \/\/ If _tail == result then result is the only element in the list. We can\n-    \/\/ remove it from the list by first setting _tail to NULL and then setting\n-    \/\/ _head to NULL, the order being important.  We set _tail with cmpxchg in\n-    \/\/ case of a concurrent push\/append\/pop also changing _tail.  If we win\n-    \/\/ then we've claimed result.\n-    if (Atomic::cmpxchg(&_tail, result, (T*)NULL) == result) {\n-      assert(next(*result) == NULL, \"invariant\");\n-      \/\/ Now that we've claimed result, also set _head to NULL.  But we must\n-      \/\/ be careful of a concurrent push\/append after we NULLed _tail, since\n-      \/\/ it may have already performed its list-was-empty update of _head,\n-      \/\/ which we must not overwrite.\n-      Atomic::cmpxchg(&_head, result, (T*)NULL);\n-      return result;\n+  \/\/ This relaxed load is always followed by a cmpxchg(), thus it\n+  \/\/ is OK as the reader-side of the release-acquire ordering.\n+  T* next_node = Atomic::load(next_ptr(*result));\n+  if (next_node != NULL) {\n+    \/\/ The \"usual\" lock-free pop from the head of a singly linked list.\n+    if (result == Atomic::cmpxchg(&_head, result, next_node)) {\n+      \/\/ Former head successfully taken; it is not the last.\n+      assert(Atomic::load(&_tail) != result, \"invariant\");\n+      assert(next(*result) != NULL, \"invariant\");\n+      set_next(*result, NULL);\n+      return StatusPair(LockFreeQueuePopStatus::success, result);\n@@ -150,0 +118,3 @@\n+    \/\/ Lost the race; the caller should try again.\n+    return StatusPair(LockFreeQueuePopStatus::lost_race, NULL);\n+  }\n@@ -151,4 +122,17 @@\n-    \/\/ If _head != result then we lost the race to take result; try again.\n-    if (result != Atomic::load_acquire(&_head)) {\n-      continue;\n-    }\n+  \/\/ next is NULL.  This case is handled differently from the \"usual\"\n+  \/\/ lock-free pop from the head of a singly linked list.\n+\n+  \/\/ If _tail == result then result is the only element in the list. We can\n+  \/\/ remove it from the list by first setting _tail to NULL and then setting\n+  \/\/ _head to NULL, the order being important.  We set _tail with cmpxchg in\n+  \/\/ case of a concurrent push\/append\/try_pop also changing _tail.  If we win\n+  \/\/ then we've claimed result.\n+  if (Atomic::cmpxchg(&_tail, result, (T*)NULL) == result) {\n+    assert(next(*result) == NULL, \"invariant\");\n+    \/\/ Now that we've claimed result, also set _head to NULL.  But we must\n+    \/\/ be careful of a concurrent push\/append after we NULLed _tail, since\n+    \/\/ it may have already performed its list-was-empty update of _head,\n+    \/\/ which we must not overwrite.\n+    Atomic::cmpxchg(&_head, result, (T*)NULL);\n+    return StatusPair(LockFreeQueuePopStatus::success, result);\n+  }\n@@ -156,10 +140,4 @@\n-    \/\/ An in-progress concurrent operation interfered with taking the head\n-    \/\/ element when it was the only element.  A concurrent pop may have won\n-    \/\/ the race to clear the tail but not yet cleared the head. Alternatively,\n-    \/\/ a concurrent push\/append may have changed the tail but not yet linked\n-    \/\/ result->next().  We cannot take result in either case.  We don't just\n-    \/\/ try again, because we could spin for a long time waiting for that\n-    \/\/ concurrent operation to finish.  In the first case, returning NULL is\n-    \/\/ fine; we lost the race for the only element to another thread.  We\n-    \/\/ also return NULL for the second case, and let the caller cope.\n-    return NULL;\n+  \/\/ If _head != result then we lost the race to take result;\n+  \/\/ the caller should try again.\n+  if (result != Atomic::load_acquire(&_head)) {\n+    return StatusPair(LockFreeQueuePopStatus::lost_race, NULL);\n@@ -167,0 +145,9 @@\n+\n+  \/\/ An in-progress concurrent operation interfered with taking the head\n+  \/\/ element when it was the only element.  A concurrent try_pop may have won\n+  \/\/ the race to clear the tail but not yet cleared the head. Alternatively,\n+  \/\/ a concurrent push\/append may have changed the tail but not yet linked\n+  \/\/ result->next(). This case slightly differs from the \"lost_race\" case,\n+  \/\/ because the caller could wait for a long time for the other concurrent\n+  \/\/ operation to finish.\n+  return StatusPair(LockFreeQueuePopStatus::operation_in_progress, NULL);\n","filename":"src\/hotspot\/share\/utilities\/lockFreeQueue.inline.hpp","additions":54,"deletions":67,"binary":false,"changes":121,"status":"modified"},{"patch":"@@ -48,4 +48,8 @@\n-      return LockFreeQueue<Element, &entry_ptr>::pop<false>();\n-    }\n-    Element* pop_rcu() {\n-      return LockFreeQueue<Element, &entry_ptr>::pop<true>();\n+      using Status = LockFreeQueuePopStatus;\n+      while (true) {\n+        Pair<Status, Element*> pop_result = try_pop();\n+        if (pop_result.first == Status::success) {\n+          return pop_result.second;\n+        }\n+        \/\/ Retry until success.\n+      }\n@@ -57,1 +61,8 @@\n-      return LockFreeQueue<Element, &entry1_ptr>::pop<false>();\n+      using Status = LockFreeQueuePopStatus;\n+      while (true) {\n+        Pair<Status, Element*> pop_result = try_pop();\n+        if (pop_result.first == Status::success) {\n+          return pop_result.second;\n+        }\n+        \/\/ Retry until success.\n+      }\n@@ -115,19 +126,0 @@\n-  }\n-  ASSERT_TRUE(queue.empty());\n-  ASSERT_EQ(0u, queue.length());\n-  ASSERT_TRUE(queue.pop() == NULL);\n-}\n-\n-TEST_VM(LockFreeQueueTestPopRCU, pop_rcu) {\n-  \/\/ We have to run this test in a JVM, so that Thread::current() can work.\n-  const size_t nelements = 10;\n-  Element elements[nelements];\n-  TestQueue queue;\n-  initialize(elements, nelements, &queue);\n-  for (size_t i = 0; i < nelements; ++i) {\n-    ASSERT_FALSE(queue.empty());\n-    ASSERT_EQ(nelements - i, queue.length());\n-    Element* e = queue.pop_rcu();\n-    ASSERT_TRUE(e != NULL);\n-    ASSERT_EQ(&elements[i], e);\n-    ASSERT_EQ(i, e->id());\n","filename":"test\/hotspot\/gtest\/utilities\/test_lockFreeQueue.cpp","additions":16,"deletions":24,"binary":false,"changes":40,"status":"modified"}]}