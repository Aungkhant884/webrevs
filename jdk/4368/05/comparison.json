{"files":[{"patch":"@@ -19,0 +19,2 @@\n+\/.project\/\n+\/.settings\/\n","filename":".gitignore","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -5686,0 +5686,1 @@\n+   *  c_rarg6   - isMIME\n@@ -5768,6 +5769,7 @@\n-    Register src   = c_rarg0;  \/\/ source array\n-    Register soff  = c_rarg1;  \/\/ source start offset\n-    Register send  = c_rarg2;  \/\/ source end offset\n-    Register dst   = c_rarg3;  \/\/ dest array\n-    Register doff  = c_rarg4;  \/\/ position for writing to dest array\n-    Register isURL = c_rarg5;  \/\/ Base64 or URL character set\n+    Register src    = c_rarg0;  \/\/ source array\n+    Register soff   = c_rarg1;  \/\/ source start offset\n+    Register send   = c_rarg2;  \/\/ source end offset\n+    Register dst    = c_rarg3;  \/\/ dest array\n+    Register doff   = c_rarg4;  \/\/ position for writing to dest array\n+    Register isURL  = c_rarg5;  \/\/ Base64 or URL character set\n+    Register isMIME = c_rarg6;  \/\/ Decoding MIME block - unused in this implementation\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -3760,0 +3760,1 @@\n+    Register isMIME = R9_ARG7; \/\/ boolean, if non-zero indicates use of RFC 2045 MIME encoding - not used\n","filename":"src\/hotspot\/cpu\/ppc\/stubGenerator_ppc.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3826,0 +3826,8 @@\n+void Assembler::evpermt2b(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(VM_Version::supports_avx512_vbmi(), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16(0x7D, (0xC0 | encode));\n+}\n+\n@@ -4545,0 +4553,9 @@\n+void Assembler::vpmaddubsw(XMMRegister dst, XMMRegister src1, XMMRegister src2, int vector_len) {\n+assert(vector_len == AVX_128bit? VM_Version::supports_avx() :\n+       vector_len == AVX_256bit? VM_Version::supports_avx2() :\n+       vector_len == AVX_512bit? VM_Version::supports_avx512bw() : 0, \"\");\n+  InstructionAttr attributes(vector_len, \/* rex_w *\/ false, \/* legacy_mode *\/ _legacy_mode_bw, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  int encode = simd_prefix_and_encode(dst, src1, src2, VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16(0x04, (0xC0 | encode));\n+}\n+\n@@ -4853,0 +4870,9 @@\n+void Assembler::evptestmb(KRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(VM_Version::supports_avx512vlbw(), \"\");\n+  \/\/ Encoding: EVEX.NDS.XXX.66.0F.W0 DB \/r\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16((unsigned char)0x26, (0xC0 | encode));\n+}\n+\n@@ -9400,0 +9426,7 @@\n+void Assembler::shrxl(Register dst, Register src1, Register src2) {\n+  assert(VM_Version::supports_bmi2(), \"\");\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  int encode = vex_prefix_and_encode(dst->encoding(), src2->encoding(), src1->encoding(), VEX_SIMD_F2, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16((unsigned char)0xF7, (0xC0 | encode));\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":33,"deletions":0,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -1701,0 +1701,1 @@\n+  void evpermt2b(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);\n@@ -1814,0 +1815,2 @@\n+  void vpmaddubsw(XMMRegister dst, XMMRegister src1, XMMRegister src2, int vector_len);\n+\n@@ -1881,0 +1884,2 @@\n+  void evptestmb(KRegister dst, XMMRegister nds, XMMRegister src, int vector_len);\n+\n@@ -2142,0 +2147,1 @@\n+  void shrxl(Register dst, Register src1, Register src2);\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -5685,0 +5685,636 @@\n+  \/\/ base64 AVX512vbmi tables\n+  address base64_vbmi_lookup_lo_addr() {\n+    __ align(64, (unsigned long) __ pc());\n+    StubCodeMark mark(this, \"StubRoutines\", \"lookup_lo_base64\");\n+    address start = __ pc();\n+    assert(((unsigned long)start & 0x3f) == 0, \"Alignment problem (0x%08lx)\", (unsigned long)start);\n+    __ emit_data64(0x8080808080808080, relocInfo::none);\n+    __ emit_data64(0x8080808080808080, relocInfo::none);\n+    __ emit_data64(0x8080808080808080, relocInfo::none);\n+    __ emit_data64(0x8080808080808080, relocInfo::none);\n+    __ emit_data64(0x8080808080808080, relocInfo::none);\n+    __ emit_data64(0x3f8080803e808080, relocInfo::none);\n+    __ emit_data64(0x3b3a393837363534, relocInfo::none);\n+    __ emit_data64(0x8080808080803d3c, relocInfo::none);\n+    return start;\n+  }\n+\n+  address base64_vbmi_lookup_hi_addr() {\n+    __ align(64, (unsigned long) __ pc());\n+    StubCodeMark mark(this, \"StubRoutines\", \"lookup_hi_base64\");\n+    address start = __ pc();\n+    assert(((unsigned long)start & 0x3f) == 0, \"Alignment problem (0x%08lx)\", (unsigned long)start);\n+    __ emit_data64(0x0605040302010080, relocInfo::none);\n+    __ emit_data64(0x0e0d0c0b0a090807, relocInfo::none);\n+    __ emit_data64(0x161514131211100f, relocInfo::none);\n+    __ emit_data64(0x8080808080191817, relocInfo::none);\n+    __ emit_data64(0x201f1e1d1c1b1a80, relocInfo::none);\n+    __ emit_data64(0x2827262524232221, relocInfo::none);\n+    __ emit_data64(0x302f2e2d2c2b2a29, relocInfo::none);\n+    __ emit_data64(0x8080808080333231, relocInfo::none);\n+    return start;\n+  }\n+  address base64_vbmi_lookup_lo_url_addr() {\n+    __ align(64, (unsigned long) __ pc());\n+    StubCodeMark mark(this, \"StubRoutines\", \"lookup_lo_base64url\");\n+    address start = __ pc();\n+    assert(((unsigned long)start & 0x3f) == 0, \"Alignment problem (0x%08lx)\", (unsigned long)start);\n+    __ emit_data64(0x8080808080808080, relocInfo::none);\n+    __ emit_data64(0x8080808080808080, relocInfo::none);\n+    __ emit_data64(0x8080808080808080, relocInfo::none);\n+    __ emit_data64(0x8080808080808080, relocInfo::none);\n+    __ emit_data64(0x8080808080808080, relocInfo::none);\n+    __ emit_data64(0x80803e8080808080, relocInfo::none);\n+    __ emit_data64(0x3b3a393837363534, relocInfo::none);\n+    __ emit_data64(0x8080808080803d3c, relocInfo::none);\n+    return start;\n+  }\n+\n+  address base64_vbmi_lookup_hi_url_addr() {\n+    __ align(64, (unsigned long) __ pc());\n+    StubCodeMark mark(this, \"StubRoutines\", \"lookup_hi_base64url\");\n+    address start = __ pc();\n+    assert(((unsigned long)start & 0x3f) == 0, \"Alignment problem (0x%08lx)\", (unsigned long)start);\n+    __ emit_data64(0x0605040302010080, relocInfo::none);\n+    __ emit_data64(0x0e0d0c0b0a090807, relocInfo::none);\n+    __ emit_data64(0x161514131211100f, relocInfo::none);\n+    __ emit_data64(0x3f80808080191817, relocInfo::none);\n+    __ emit_data64(0x201f1e1d1c1b1a80, relocInfo::none);\n+    __ emit_data64(0x2827262524232221, relocInfo::none);\n+    __ emit_data64(0x302f2e2d2c2b2a29, relocInfo::none);\n+    __ emit_data64(0x8080808080333231, relocInfo::none);\n+    return start;\n+  }\n+\n+  address base64_vbmi_pack_vec_addr() {\n+    __ align(64, (unsigned long) __ pc());\n+    StubCodeMark mark(this, \"StubRoutines\", \"pack_vec_base64\");\n+    address start = __ pc();\n+    assert(((unsigned long)start & 0x3f) == 0, \"Alignment problem (0x%08lx)\", (unsigned long)start);\n+    __ emit_data64(0x090a040506000102, relocInfo::none);\n+    __ emit_data64(0x161011120c0d0e08, relocInfo::none);\n+    __ emit_data64(0x1c1d1e18191a1415, relocInfo::none);\n+    __ emit_data64(0x292a242526202122, relocInfo::none);\n+    __ emit_data64(0x363031322c2d2e28, relocInfo::none);\n+    __ emit_data64(0x3c3d3e38393a3435, relocInfo::none);\n+    __ emit_data64(0x0000000000000000, relocInfo::none);\n+    __ emit_data64(0x0000000000000000, relocInfo::none);\n+    return start;\n+  }\n+\n+  address base64_vbmi_join_0_1_addr() {\n+    __ align(64, (unsigned long) __ pc());\n+    StubCodeMark mark(this, \"StubRoutines\", \"join_0_1_base64\");\n+    address start = __ pc();\n+    assert(((unsigned long)start & 0x3f) == 0, \"Alignment problem (0x%08lx)\", (unsigned long)start);\n+    __ emit_data64(0x090a040506000102, relocInfo::none);\n+    __ emit_data64(0x161011120c0d0e08, relocInfo::none);\n+    __ emit_data64(0x1c1d1e18191a1415, relocInfo::none);\n+    __ emit_data64(0x292a242526202122, relocInfo::none);\n+    __ emit_data64(0x363031322c2d2e28, relocInfo::none);\n+    __ emit_data64(0x3c3d3e38393a3435, relocInfo::none);\n+    __ emit_data64(0x494a444546404142, relocInfo::none);\n+    __ emit_data64(0x565051524c4d4e48, relocInfo::none);\n+    return start;\n+  }\n+\n+  address base64_vbmi_join_1_2_addr() {\n+    __ align(64, (unsigned long) __ pc());\n+    StubCodeMark mark(this, \"StubRoutines\", \"join_1_2_base64\");\n+    address start = __ pc();\n+    assert(((unsigned long)start & 0x3f) == 0, \"Alignment problem (0x%08lx)\", (unsigned long)start);\n+    __ emit_data64(0x1c1d1e18191a1415, relocInfo::none);\n+    __ emit_data64(0x292a242526202122, relocInfo::none);\n+    __ emit_data64(0x363031322c2d2e28, relocInfo::none);\n+    __ emit_data64(0x3c3d3e38393a3435, relocInfo::none);\n+    __ emit_data64(0x494a444546404142, relocInfo::none);\n+    __ emit_data64(0x565051524c4d4e48, relocInfo::none);\n+    __ emit_data64(0x5c5d5e58595a5455, relocInfo::none);\n+    __ emit_data64(0x696a646566606162, relocInfo::none);\n+    return start;\n+  }\n+\n+  address base64_vbmi_join_2_3_addr() {\n+    __ align(64, (unsigned long) __ pc());\n+    StubCodeMark mark(this, \"StubRoutines\", \"join_2_3_base64\");\n+    address start = __ pc();\n+    assert(((unsigned long)start & 0x3f) == 0, \"Alignment problem (0x%08lx)\", (unsigned long)start);\n+    __ emit_data64(0x363031322c2d2e28, relocInfo::none);\n+    __ emit_data64(0x3c3d3e38393a3435, relocInfo::none);\n+    __ emit_data64(0x494a444546404142, relocInfo::none);\n+    __ emit_data64(0x565051524c4d4e48, relocInfo::none);\n+    __ emit_data64(0x5c5d5e58595a5455, relocInfo::none);\n+    __ emit_data64(0x696a646566606162, relocInfo::none);\n+    __ emit_data64(0x767071726c6d6e68, relocInfo::none);\n+    __ emit_data64(0x7c7d7e78797a7475, relocInfo::none);\n+    return start;\n+  }\n+\n+  address base64_decoding_table_addr() {\n+    StubCodeMark mark(this, \"StubRoutines\", \"decoding_table_base64\");\n+    address start = __ pc();\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0x3fffffff3effffff, relocInfo::none);\n+    __ emit_data64(0x3b3a393837363534, relocInfo::none);\n+    __ emit_data64(0xffffffffffff3d3c, relocInfo::none);\n+    __ emit_data64(0x06050403020100ff, relocInfo::none);\n+    __ emit_data64(0x0e0d0c0b0a090807, relocInfo::none);\n+    __ emit_data64(0x161514131211100f, relocInfo::none);\n+    __ emit_data64(0xffffffffff191817, relocInfo::none);\n+    __ emit_data64(0x201f1e1d1c1b1aff, relocInfo::none);\n+    __ emit_data64(0x2827262524232221, relocInfo::none);\n+    __ emit_data64(0x302f2e2d2c2b2a29, relocInfo::none);\n+    __ emit_data64(0xffffffffff333231, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+\n+    \/\/ URL table\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffff3effffffffff, relocInfo::none);\n+    __ emit_data64(0x3b3a393837363534, relocInfo::none);\n+    __ emit_data64(0xffffffffffff3d3c, relocInfo::none);\n+    __ emit_data64(0x06050403020100ff, relocInfo::none);\n+    __ emit_data64(0x0e0d0c0b0a090807, relocInfo::none);\n+    __ emit_data64(0x161514131211100f, relocInfo::none);\n+    __ emit_data64(0x3fffffffff191817, relocInfo::none);\n+    __ emit_data64(0x201f1e1d1c1b1aff, relocInfo::none);\n+    __ emit_data64(0x2827262524232221, relocInfo::none);\n+    __ emit_data64(0x302f2e2d2c2b2a29, relocInfo::none);\n+    __ emit_data64(0xffffffffff333231, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    return start;\n+  }\n+\n+\n+\/\/ Code for generating Base64 decoding.\n+\/\/\n+\/\/ Based on the article (and associated code) from https:\/\/arxiv.org\/abs\/1910.05109.\n+\/\/\n+\/\/ Intrinsic function prototype in Base64.java:\n+\/\/ private void decodeBlock(byte[] src, int sp, int sl, byte[] dst, int dp, boolean isURL, isMIME) {\n+  address generate_base64_decodeBlock() {\n+    __ align(CodeEntryAlignment);\n+    StubCodeMark mark(this, \"StubRoutines\", \"implDecode\");\n+    address start = __ pc();\n+    __ enter();\n+\n+    \/\/ Save callee-saved registers before using them\n+    __ push(r12);\n+    __ push(r13);\n+    __ push(r14);\n+    __ push(r15);\n+    __ push(rbx);\n+\n+    \/\/ arguments\n+    const Register source = c_rarg0; \/\/ Source Array\n+    const Register start_offset = c_rarg1; \/\/ start offset\n+    const Register end_offset = c_rarg2; \/\/ end offset\n+    const Register dest = c_rarg3; \/\/ destination array\n+    const Register isMIME = rbx;\n+\n+#ifndef _WIN64\n+    const Register dp = c_rarg4;  \/\/ Position for writing to dest array\n+    const Register isURL = c_rarg5;\/\/ Base64 or URL character set\n+    __ movl(isMIME, Address(rbp, 2 * wordSize));\n+#else\n+    const Address  dp_mem(rbp, 6 * wordSize);  \/\/ length is on stack on Win64\n+    const Address isURL_mem(rbp, 7 * wordSize);\n+    const Register isURL = r10;      \/\/ pick the volatile windows register\n+    const Register dp = r12;\n+    __ movl(dp, dp_mem);\n+    __ movl(isURL, isURL_mem);\n+    __ movl(isMIME, Address(rbp, 8 * wordSize));\n+#endif\n+\n+    const XMMRegister lookup_lo = xmm5;\n+    const XMMRegister lookup_hi = xmm6;\n+    const XMMRegister errorvec = xmm7;\n+    const XMMRegister pack16_op = xmm9;\n+    const XMMRegister pack32_op = xmm8;\n+    const XMMRegister input0 = xmm3;\n+    const XMMRegister input1 = xmm20;\n+    const XMMRegister input2 = xmm21;\n+    const XMMRegister input3 = xmm19;\n+    const XMMRegister join01 = xmm12;\n+    const XMMRegister join12 = xmm11;\n+    const XMMRegister join23 = xmm10;\n+    const XMMRegister translated0 = xmm2;\n+    const XMMRegister translated1 = xmm1;\n+    const XMMRegister translated2 = xmm0;\n+    const XMMRegister translated3 = xmm4;\n+\n+    const XMMRegister merged0 = xmm2;\n+    const XMMRegister merged1 = xmm1;\n+    const XMMRegister merged2 = xmm0;\n+    const XMMRegister merged3 = xmm4;\n+    const XMMRegister merge_ab_bc0 = xmm2;\n+    const XMMRegister merge_ab_bc1 = xmm1;\n+    const XMMRegister merge_ab_bc2 = xmm0;\n+    const XMMRegister merge_ab_bc3 = xmm4;\n+\n+    const XMMRegister pack24bits = xmm4;\n+\n+    const Register length = r14;\n+    const Register output_size = r13;\n+    const Register output_mask = r15;\n+    const KRegister input_mask = k1;\n+\n+    const XMMRegister input_initial_valid_b64 = xmm0;\n+    const XMMRegister tmp = xmm10;\n+    const XMMRegister mask = xmm0;\n+    const XMMRegister invalid_b64 = xmm1;\n+\n+    Label L_process256, L_process64, L_process64Loop, L_exit, L_processdata, L_loadURL;\n+    Label L_continue, L_finalBit, L_padding, L_donePadding, L_bruteForce;\n+    Label L_forceLoop, L_bottomLoop, L_checkMIME, L_exit_no_vzero;\n+\n+    \/\/ calculate length from offsets\n+    __ movl(length, end_offset);\n+    __ subl(length, start_offset);\n+    __ push(dest);          \/\/ Save for return value calc\n+\n+    \/\/ If AVX512 VBMI not supported, just compile non-AVX code\n+    if(VM_Version::supports_avx512_vbmi() &&\n+       VM_Version::supports_avx512bw()) {\n+      __ cmpl(length, 128);     \/\/ 128-bytes is break-even for AVX-512\n+      __ jcc(Assembler::lessEqual, L_bruteForce);\n+\n+      __ cmpl(isMIME, 0);\n+      __ jcc(Assembler::notEqual, L_bruteForce);\n+\n+      \/\/ Load lookup tables based on isURL\n+      __ cmpl(isURL, 0);\n+      __ jcc(Assembler::notZero, L_loadURL);\n+\n+      __ evmovdquq(lookup_lo, ExternalAddress(StubRoutines::x86::base64_vbmi_lookup_lo_addr()), Assembler::AVX_512bit, r13);\n+      __ evmovdquq(lookup_hi, ExternalAddress(StubRoutines::x86::base64_vbmi_lookup_hi_addr()), Assembler::AVX_512bit, r13);\n+\n+      __ BIND(L_continue);\n+\n+      __ movl(r15, 0x01400140);\n+      __ evpbroadcastd(pack16_op, r15, Assembler::AVX_512bit);\n+\n+      __ movl(r15, 0x00011000);\n+      __ evpbroadcastd(pack32_op, r15, Assembler::AVX_512bit);\n+\n+      __ cmpl(length, 0xff);\n+      __ jcc(Assembler::lessEqual, L_process64);\n+\n+      \/\/ load masks required for decoding data\n+      __ BIND(L_processdata);\n+      __ evmovdquq(join01, ExternalAddress(StubRoutines::x86::base64_vbmi_join_0_1_addr()), Assembler::AVX_512bit,r13);\n+      __ evmovdquq(join12, ExternalAddress(StubRoutines::x86::base64_vbmi_join_1_2_addr()), Assembler::AVX_512bit, r13);\n+      __ evmovdquq(join23, ExternalAddress(StubRoutines::x86::base64_vbmi_join_2_3_addr()), Assembler::AVX_512bit, r13);\n+\n+      __ align(32);\n+      __ BIND(L_process256);\n+      \/\/ Grab input data\n+      __ evmovdquq(input0, Address(source, start_offset, Address::times_1, 0x00), Assembler::AVX_512bit);\n+      __ evmovdquq(input1, Address(source, start_offset, Address::times_1, 0x40), Assembler::AVX_512bit);\n+      __ evmovdquq(input2, Address(source, start_offset, Address::times_1, 0x80), Assembler::AVX_512bit);\n+      __ evmovdquq(input3, Address(source, start_offset, Address::times_1, 0xc0), Assembler::AVX_512bit);\n+\n+      \/\/ Copy the low part of the lookup table into the destination of the permutation\n+      __ evmovdquq(translated0, lookup_lo, Assembler::AVX_512bit);\n+      __ evmovdquq(translated1, lookup_lo, Assembler::AVX_512bit);\n+      __ evmovdquq(translated2, lookup_lo, Assembler::AVX_512bit);\n+      __ evmovdquq(translated3, lookup_lo, Assembler::AVX_512bit);\n+\n+      \/\/ Translate the base64 input into \"decoded\" bytes\n+      __ evpermt2b(translated0, input0, lookup_hi, Assembler::AVX_512bit);\n+      __ evpermt2b(translated1, input1, lookup_hi, Assembler::AVX_512bit);\n+      __ evpermt2b(translated2, input2, lookup_hi, Assembler::AVX_512bit);\n+      __ evpermt2b(translated3, input3, lookup_hi, Assembler::AVX_512bit);\n+\n+      \/\/ OR all of the translations together to check for errors (high-order bit of byte set)\n+      __ vpternlogd(input0, 0xfe, input1, input2, Assembler::AVX_512bit);\n+\n+      __ vpternlogd(input3, 0xfe, translated0, translated1, Assembler::AVX_512bit);\n+      __ vpternlogd(input0, 0xfe, translated1, translated2, Assembler::AVX_512bit);\n+      __ vpor(errorvec, input3, input0, Assembler::AVX_512bit);\n+\n+      \/\/ Check if there was an error - if so, try 64-byte chunks\n+      __ evpmovb2m(k3, errorvec, Assembler::AVX_512bit);\n+      __ kortestql(k3, k3);\n+      __ jcc(Assembler::notZero, L_process64);\n+\n+      \/\/ The merging and shuffling happens here\n+      \/\/ We multiply each byte pair [00dddddd | 00cccccc | 00bbbbbb | 00aaaaaa]\n+      \/\/ Multiply [00cccccc] by 2^6 added to [00dddddd] to get [0000cccc | ccdddddd]\n+      \/\/ The pack16_op is a vector of 0x01400140, so multiply D by 1 and C by 0x40\n+      __ vpmaddubsw(merge_ab_bc0, translated0, pack16_op, Assembler::AVX_512bit);\n+      __ vpmaddubsw(merge_ab_bc1, translated1, pack16_op, Assembler::AVX_512bit);\n+      __ vpmaddubsw(merge_ab_bc2, translated2, pack16_op, Assembler::AVX_512bit);\n+      __ vpmaddubsw(merge_ab_bc3, translated3, pack16_op, Assembler::AVX_512bit);\n+\n+      \/\/ Now do the same with packed 16-bit values.\n+      \/\/ We start with [0000cccc | ccdddddd | 0000aaaa | aabbbbbb]\n+      \/\/ pack32_op is 0x00011000 (2^12, 1), so this multiplies [0000aaaa | aabbbbbb] by 2^12\n+      \/\/ and adds [0000cccc | ccdddddd] to yield [00000000 | aaaaaabb | bbbbcccc | ccdddddd]\n+      __ vpmaddwd(merged0, merge_ab_bc0, pack32_op, Assembler::AVX_512bit);\n+      __ vpmaddwd(merged1, merge_ab_bc1, pack32_op, Assembler::AVX_512bit);\n+      __ vpmaddwd(merged2, merge_ab_bc2, pack32_op, Assembler::AVX_512bit);\n+      __ vpmaddwd(merged3, merge_ab_bc3, pack32_op, Assembler::AVX_512bit);\n+\n+      \/\/ The join vectors specify which byte from which vector goes into the outputs\n+      \/\/ One of every 4 bytes in the extended vector is zero, so we pack them into their\n+      \/\/ final positions in the register for storing (256 bytes in, 192 bytes out)\n+      __ evpermt2b(merged0, join01, merged1, Assembler::AVX_512bit);\n+      __ evpermt2b(merged1, join12, merged2, Assembler::AVX_512bit);\n+      __ evpermt2b(merged2, join23, merged3, Assembler::AVX_512bit);\n+\n+      \/\/ Store result\n+      __ evmovdquq(Address(dest, dp, Address::times_1, 0x00), merged0, Assembler::AVX_512bit);\n+      __ evmovdquq(Address(dest, dp, Address::times_1, 0x40), merged1, Assembler::AVX_512bit);\n+      __ evmovdquq(Address(dest, dp, Address::times_1, 0x80), merged2, Assembler::AVX_512bit);\n+\n+      __ addptr(source, 0x100);\n+      __ addptr(dest, 0xc0);\n+      __ subl(length, 0x100);\n+      __ cmpl(length, 64 * 4);\n+      __ jcc(Assembler::greaterEqual, L_process256);\n+\n+      \/\/ At this point, we've decoded 64 * 4 * n bytes.\n+      \/\/ The remaining length will be <= 64 * 4 - 1.\n+      \/\/ UNLESS there was an error decoding the first 256-byte chunk.  In this\n+      \/\/ case, the length will be arbitrarily long.\n+      \/\/\n+      \/\/ Note that this will be the path for MIME-encoded strings.\n+\n+      __ BIND(L_process64);\n+\n+      __ evmovdquq(pack24bits, ExternalAddress(StubRoutines::x86::base64_vbmi_pack_vec_addr()), Assembler::AVX_512bit, r13);\n+\n+      __ cmpl(length, 63);\n+      __ jcc(Assembler::lessEqual, L_finalBit);\n+\n+      __ align(32);\n+      __ BIND(L_process64Loop);\n+\n+      \/\/ Handle first 64-byte block\n+\n+      __ evmovdquq(input0, Address(source, start_offset), Assembler::AVX_512bit);\n+      __ evmovdquq(translated0, lookup_lo, Assembler::AVX_512bit);\n+      __ evpermt2b(translated0, input0, lookup_hi, Assembler::AVX_512bit);\n+\n+      __ vpor(errorvec, translated0, input0, Assembler::AVX_512bit);\n+\n+      \/\/ Check for error and bomb out before updating dest\n+      __ evpmovb2m(k3, errorvec, Assembler::AVX_512bit);\n+      __ kortestql(k3, k3);\n+      __ jcc(Assembler::notZero, L_exit);\n+\n+      \/\/ Pack output register, selecting correct byte ordering\n+      __ vpmaddubsw(merge_ab_bc0, translated0, pack16_op, Assembler::AVX_512bit);\n+      __ vpmaddwd(merged0, merge_ab_bc0, pack32_op, Assembler::AVX_512bit);\n+      __ vpermb(merged0, pack24bits, merged0, Assembler::AVX_512bit);\n+\n+      __ evmovdquq(Address(dest, dp), merged0, Assembler::AVX_512bit);\n+\n+      __ subl(length, 64);\n+      __ addptr(source, 64);\n+      __ addptr(dest, 48);\n+\n+      __ cmpl(length, 64);\n+      __ jcc(Assembler::greaterEqual, L_process64Loop);\n+\n+      __ cmpl(length, 0);\n+      __ jcc(Assembler::lessEqual, L_exit);\n+\n+      __ BIND(L_finalBit);\n+      \/\/ Now have 1 to 63 bytes left to decode\n+\n+      \/\/ I was going to let Java take care of the final fragment\n+      \/\/ however it will repeatedly call this routine for every 4 bytes\n+      \/\/ of input data, so handle the rest here.\n+      __ movq(rax, -1);\n+      __ bzhiq(rax, rax, length);    \/\/ Input mask in rax\n+\n+      __ movl(output_size, length);\n+      __ shrl(output_size, 2);   \/\/ Find (len \/ 4) * 3 (output length)\n+      __ lea(output_size, Address(output_size, output_size, Address::times_2, 0));\n+      \/\/ output_size in r13\n+\n+      \/\/ Strip pad characters, if any, and adjust length and mask\n+      __ cmpb(Address(source, length, Address::times_1, -1), '=');\n+      __ jcc(Assembler::equal, L_padding);\n+\n+      __ BIND(L_donePadding);\n+\n+      \/\/ Output size is (64 - output_size), output mask is (all 1s >> output_size).\n+      __ kmovql(input_mask, rax);\n+      __ movq(output_mask, -1);\n+      __ bzhiq(output_mask, output_mask, output_size);\n+\n+      \/\/ Load initial input with all valid base64 characters.  Will be used\n+      \/\/ in merging source bytes to avoid masking when determining if an error occurred.\n+      __ movl(rax, 0x61616161);\n+      __ evpbroadcastd(input_initial_valid_b64, rax, Assembler::AVX_512bit);\n+\n+      \/\/ A register containing all invalid base64 decoded values\n+      __ movl(rax, 0x80808080);\n+      __ evpbroadcastd(invalid_b64, rax, Assembler::AVX_512bit);\n+\n+      \/\/ input_mask is in k1\n+      \/\/ output_size is in r13\n+      \/\/ output_mask is in r15\n+      \/\/ zmm0 - free\n+      \/\/ zmm1 - 0x00011000\n+      \/\/ zmm2 - 0x01400140\n+      \/\/ zmm3 - errorvec\n+      \/\/ zmm4 - pack vector\n+      \/\/ zmm5 - lookup_lo\n+      \/\/ zmm6 - lookup_hi\n+      \/\/ zmm7 - errorvec\n+      \/\/ zmm8 - 0x61616161\n+      \/\/ zmm9 - 0x80808080\n+\n+      \/\/ Load only the bytes from source, merging into our \"fully-valid\" register\n+      __ evmovdqub(input_initial_valid_b64, input_mask, Address(source, start_offset, Address::times_1, 0x0), true, Assembler::AVX_512bit);\n+\n+      \/\/ Decode all bytes within our merged input\n+      __ evmovdquq(tmp, lookup_lo, Assembler::AVX_512bit);\n+      __ evpermt2b(tmp, input_initial_valid_b64, lookup_hi, Assembler::AVX_512bit);\n+      __ vporq(mask, tmp, input_initial_valid_b64, Assembler::AVX_512bit);\n+\n+      \/\/ Check for error.  Compare (decoded | initial) to all invalid.\n+      \/\/ If any bytes have their high-order bit set, then we have an error.\n+      __ evptestmb(k2, mask, invalid_b64, Assembler::AVX_512bit);\n+      __ kortestql(k2, k2);\n+\n+      \/\/ If we have an error, use the brute force loop to decode what we can (4-byte chunks).\n+      __ jcc(Assembler::notZero, L_bruteForce);\n+\n+      \/\/ Shuffle output bytes\n+      __ vpmaddubsw(tmp, tmp, pack16_op, Assembler::AVX_512bit);\n+      __ vpmaddwd(tmp, tmp, pack32_op, Assembler::AVX_512bit);\n+\n+      __ vpermb(tmp, pack24bits, tmp, Assembler::AVX_512bit);\n+      __ kmovql(k1, output_mask);\n+      __ evmovdqub(Address(dest, dp), k1, tmp, true, Assembler::AVX_512bit);\n+\n+      __ addptr(dest, output_size);\n+\n+      __ BIND(L_exit);\n+      __ vzeroupper();\n+      __ pop(rax);             \/\/ Get original dest value\n+      __ subptr(dest, rax);      \/\/ Number of bytes converted\n+      __ movptr(rax, dest);\n+      __ pop(rbx);\n+      __ pop(r15);\n+      __ pop(r14);\n+      __ pop(r13);\n+      __ pop(r12);\n+      __ leave();\n+      __ ret(0);\n+\n+      __ BIND(L_loadURL);\n+      __ evmovdquq(lookup_lo, ExternalAddress(StubRoutines::x86::base64_vbmi_lookup_lo_url_addr()), Assembler::AVX_512bit, r13);\n+      __ evmovdquq(lookup_hi, ExternalAddress(StubRoutines::x86::base64_vbmi_lookup_hi_url_addr()), Assembler::AVX_512bit, r13);\n+      __ jmp(L_continue);\n+\n+      __ BIND(L_padding);\n+      __ decrementq(output_size, 1);\n+      __ shrq(rax, 1);\n+\n+      __ cmpb(Address(source, length, Address::times_1, -2), '=');\n+      __ jcc(Assembler::notEqual, L_donePadding);\n+\n+      __ decrementq(output_size, 1);\n+      __ shrq(rax, 1);\n+      __ jmp(L_donePadding);\n+\n+      __ align(32);\n+      __ BIND(L_bruteForce);\n+    }   \/\/ End of if(avx512_vbmi)\n+\n+    \/\/ Use non-AVX code to decode 4-byte chunks into 3 bytes of output\n+\n+    \/\/ Register state (Linux):\n+    \/\/ r12-15 - saved on stack\n+    \/\/ rdi - src\n+    \/\/ rsi - sp\n+    \/\/ rdx - sl\n+    \/\/ rcx - dst\n+    \/\/ r8 - dp\n+    \/\/ r9 - isURL\n+\n+    \/\/ Register state (Windows):\n+    \/\/ r12-15 - saved on stack\n+    \/\/ rcx - src\n+    \/\/ rdx - sp\n+    \/\/ r8 - sl\n+    \/\/ r9 - dst\n+    \/\/ r12 - dp\n+    \/\/ r10 - isURL\n+\n+    \/\/ Registers (common):\n+    \/\/ length (r14) - bytes in src\n+\n+    const Register decode_table = r11;\n+    const Register out_byte_count = rbx;\n+    const Register byte1 = r13;\n+    const Register byte2 = r15;\n+    const Register byte3 = WINDOWS_ONLY(r12) NOT_WINDOWS(rdx);\n+    const Register byte4 = WINDOWS_ONLY(rdx) NOT_WINDOWS(r9);\n+\n+    __ shrl(length, 2);    \/\/ Multiple of 4 bytes only - length is # 4-byte chunks\n+    __ cmpl(length, 0);\n+    __ jcc(Assembler::lessEqual, L_exit_no_vzero);\n+\n+    __ shll(isURL, 8);    \/\/ index into decode table based on isURL\n+    __ lea(decode_table, ExternalAddress(StubRoutines::x86::base64_decoding_table_addr()));\n+    __ addptr(decode_table, isURL);\n+\n+    __ jmp(L_bottomLoop);\n+\n+    __ align(32);\n+    __ BIND(L_forceLoop);\n+    __ shll(byte1, 18);\n+    __ shll(byte2, 12);\n+    __ shll(byte3, 6);\n+    __ orl(byte1, byte2);\n+    __ orl(byte1, byte3);\n+    __ orl(byte1, byte4);\n+\n+    __ addptr(source, 4);\n+\n+    __ movb(Address(dest, dp, Address::times_1, 2), byte1);\n+    __ shrl(byte1, 8);\n+    __ movb(Address(dest, dp, Address::times_1, 1), byte1);\n+    __ shrl(byte1, 8);\n+    __ movb(Address(dest, dp, Address::times_1, 0), byte1);\n+\n+    __ addptr(dest, 3);\n+    __ decrementl(length, 1);\n+    __ jcc(Assembler::zero, L_exit_no_vzero);\n+\n+    __ BIND(L_bottomLoop);\n+    __ load_unsigned_byte(byte1, Address(source, start_offset, Address::times_1, 0x00));\n+    __ load_unsigned_byte(byte2, Address(source, start_offset, Address::times_1, 0x01));\n+    __ load_signed_byte(byte1, Address(decode_table, byte1));\n+    __ load_signed_byte(byte2, Address(decode_table, byte2));\n+    __ load_unsigned_byte(byte3, Address(source, start_offset, Address::times_1, 0x02));\n+    __ load_unsigned_byte(byte4, Address(source, start_offset, Address::times_1, 0x03));\n+    __ load_signed_byte(byte3, Address(decode_table, byte3));\n+    __ load_signed_byte(byte4, Address(decode_table, byte4));\n+\n+    __ mov(rax, byte1);\n+    __ orl(rax, byte2);\n+    __ orl(rax, byte3);\n+    __ orl(rax, byte4);\n+    __ jcc(Assembler::positive, L_forceLoop);\n+\n+    __ BIND(L_exit_no_vzero);\n+    __ pop(rax);             \/\/ Get original dest value\n+    __ subptr(dest, rax);      \/\/ Number of bytes converted\n+    __ movptr(rax, dest);\n+    __ pop(rbx);\n+    __ pop(r15);\n+    __ pop(r14);\n+    __ pop(r13);\n+    __ pop(r12);\n+    __ leave();\n+    __ ret(0);\n+\n+    return start;\n+  }\n+\n+\n@@ -6971,0 +7607,13 @@\n+      if(VM_Version::supports_avx512_vbmi() &&\n+         VM_Version::supports_avx512bw()) {\n+        StubRoutines::x86::_lookup_lo_base64 = base64_vbmi_lookup_lo_addr();\n+        StubRoutines::x86::_lookup_hi_base64 = base64_vbmi_lookup_hi_addr();\n+        StubRoutines::x86::_lookup_lo_base64url = base64_vbmi_lookup_lo_url_addr();\n+        StubRoutines::x86::_lookup_hi_base64url = base64_vbmi_lookup_hi_url_addr();\n+        StubRoutines::x86::_pack_vec_base64 = base64_vbmi_pack_vec_addr();\n+        StubRoutines::x86::_join_0_1_base64 = base64_vbmi_join_0_1_addr();\n+        StubRoutines::x86::_join_1_2_base64 = base64_vbmi_join_1_2_addr();\n+        StubRoutines::x86::_join_2_3_base64 = base64_vbmi_join_2_3_addr();\n+      }\n+      StubRoutines::x86::_decoding_table_base64 = base64_decoding_table_addr();\n+      StubRoutines::_base64_decodeBlock = generate_base64_decodeBlock();\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":649,"deletions":0,"binary":false,"changes":649,"status":"modified"},{"patch":"@@ -76,0 +76,9 @@\n+address StubRoutines::x86::_lookup_lo_base64 = NULL;\n+address StubRoutines::x86::_lookup_hi_base64 = NULL;\n+address StubRoutines::x86::_lookup_lo_base64url = NULL;\n+address StubRoutines::x86::_lookup_hi_base64url = NULL;\n+address StubRoutines::x86::_pack_vec_base64 = NULL;\n+address StubRoutines::x86::_join_0_1_base64 = NULL;\n+address StubRoutines::x86::_join_1_2_base64 = NULL;\n+address StubRoutines::x86::_join_2_3_base64 = NULL;\n+address StubRoutines::x86::_decoding_table_base64 = NULL;\n","filename":"src\/hotspot\/cpu\/x86\/stubRoutines_x86.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -194,0 +194,9 @@\n+  static address _lookup_lo_base64;\n+  static address _lookup_hi_base64;\n+  static address _lookup_lo_base64url;\n+  static address _lookup_hi_base64url;\n+  static address _pack_vec_base64;\n+  static address _join_0_1_base64;\n+  static address _join_1_2_base64;\n+  static address _join_2_3_base64;\n+  static address _decoding_table_base64;\n@@ -339,0 +348,9 @@\n+  static address base64_vbmi_lookup_lo_addr() { return _lookup_lo_base64; }\n+  static address base64_vbmi_lookup_hi_addr() { return _lookup_hi_base64; }\n+  static address base64_vbmi_lookup_lo_url_addr() { return _lookup_lo_base64url; }\n+  static address base64_vbmi_lookup_hi_url_addr() { return _lookup_hi_base64url; }\n+  static address base64_vbmi_pack_vec_addr() { return _pack_vec_base64; }\n+  static address base64_vbmi_join_0_1_addr() { return _join_0_1_base64; }\n+  static address base64_vbmi_join_1_2_addr() { return _join_1_2_base64; }\n+  static address base64_vbmi_join_2_3_addr() { return _join_2_3_base64; }\n+  static address base64_decoding_table_addr() { return _decoding_table_base64; }\n","filename":"src\/hotspot\/cpu\/x86\/stubRoutines_x86.hpp","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -460,1 +460,1 @@\n-   do_signature(decodeBlock_signature, \"([BII[BIZ)I\")                                                                   \\\n+   do_signature(decodeBlock_signature, \"([BII[BIZZ)I\")                                                                   \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -6295,1 +6295,1 @@\n-  assert(callee()->signature()->size() == 6, \"base64_decodeBlock has 6 parameters\");\n+  assert(callee()->signature()->size() == 7, \"base64_decodeBlock has 7 parameters\");\n@@ -6307,0 +6307,1 @@\n+  Node* isMIME = argument(7);\n@@ -6319,1 +6320,1 @@\n-                                 src_start, src_offset, len, dest_start, dest_offset, isURL);\n+                                 src_start, src_offset, len, dest_start, dest_offset, isURL, isMIME);\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1196,1 +1196,1 @@\n-  int argcnt = 6;\n+  int argcnt = 7;\n@@ -1206,0 +1206,1 @@\n+  fields[argp++] = TypeInt::BOOL;       \/\/ isMIME\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -756,4 +756,0 @@\n-         * If the intrinsic function does not process all of the bytes in\n-         * src, it must process a multiple of four of them, making the\n-         * returned destination length a multiple of three.\n-         *\n@@ -765,1 +761,4 @@\n-         * containing pad characters.\n+         * containing pad characters.  However, MIME decoding ignores\n+         * illegal characters, so any intrinsic overriding decodeBlock\n+         * can choose how to handle illegal characters based on the isMIME\n+         * parameter.\n@@ -782,0 +781,2 @@\n+         * @param  isMIME\n+         *         boolean, when true decode according to RFC2045 (ignore illegal chars)\n@@ -785,1 +786,1 @@\n-        private int decodeBlock(byte[] src, int sp, int sl, byte[] dst, int dp, boolean isURL) {\n+        private int decodeBlock(byte[] src, int sp, int sl, byte[] dst, int dp, boolean isURL, boolean isMIME) {\n@@ -813,1 +814,1 @@\n-                    int dl = decodeBlock(src, sp, sl, dst, dp, isURL);\n+                    int dl = decodeBlock(src, sp, sl, dst, dp, isURL, isMIME);\n@@ -818,1 +819,1 @@\n-                    int chars_decoded = (dl \/ 3) * 4;\n+                    int chars_decoded = ((dl + 2) \/ 3) * 4;\n","filename":"src\/java.base\/share\/classes\/java\/util\/Base64.java","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"}]}