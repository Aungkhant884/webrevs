{"files":[{"patch":"@@ -567,8 +567,0 @@\n-\n-                    \/\/ m2 is automatic module in parent configuration => m1 reads\n-                    \/\/ all automatic modules that m2 reads.\n-                    if (m2.descriptor().isAutomatic()) {\n-                        m2.reads().stream()\n-                                .filter(d -> d.descriptor().isAutomatic())\n-                                .forEach(reads::add);\n-                    }\n@@ -584,35 +576,0 @@\n-\n-            }\n-\n-            \/\/ automatic modules read all selected modules and all modules\n-            \/\/ in parent configurations\n-            if (descriptor.isAutomatic()) {\n-\n-                \/\/ reads all selected modules\n-                \/\/ `requires transitive` all selected automatic modules\n-                for (ModuleReference mref2 : nameToReference.values()) {\n-                    ModuleDescriptor descriptor2 = mref2.descriptor();\n-                    String name2 = descriptor2.name();\n-\n-                    if (!name.equals(name2)) {\n-                        ResolvedModule m2\n-                            = computeIfAbsent(nameToResolved, name2, cf, mref2);\n-                        reads.add(m2);\n-                        if (descriptor2.isAutomatic())\n-                            requiresTransitive.add(m2);\n-                    }\n-                }\n-\n-                \/\/ reads all modules in parent configurations\n-                \/\/ `requires transitive` all automatic modules in parent\n-                \/\/ configurations\n-                for (Configuration parent : parents) {\n-                    parent.configurations()\n-                            .map(Configuration::modules)\n-                            .flatMap(Set::stream)\n-                            .forEach(m -> {\n-                                reads.add(m);\n-                                if (m.reference().descriptor().isAutomatic())\n-                                    requiresTransitive.add(m);\n-                            });\n-                }\n@@ -652,0 +609,71 @@\n+        \/\/ Handle automatic modules in a separate step\n+\n+        \/\/ automatic modules read all selected modules and all modules\n+        \/\/ in parent configurations\n+        for (Map.Entry<ResolvedModule, Set<ResolvedModule>> entry : g1.entrySet()) {\n+            ResolvedModule m1 = entry.getKey();\n+\n+            if (!m1.descriptor().isAutomatic()) {\n+                continue;\n+            }\n+\n+            String name = m1.name();\n+            Set<ResolvedModule> m1Reads = entry.getValue();\n+\n+            \/\/ reads all selected modules\n+            for (ModuleReference mref2 : nameToReference.values()) {\n+                ModuleDescriptor descriptor2 = mref2.descriptor();\n+                String name2 = descriptor2.name();\n+\n+                if (!name.equals(name2)) {\n+                    ResolvedModule m2 = nameToResolved.get(name2);\n+                    assert m2 != null;\n+                    m1Reads.add(m2);\n+                }\n+            }\n+\n+            \/\/ reads all modules in parent configurations\n+            for (Configuration parent : parents) {\n+                parent.configurations()\n+                        .map(Configuration::modules)\n+                        .flatMap(Set::stream)\n+                        .forEach(m1Reads::add);\n+            }\n+        }\n+\n+        \/\/ m2 is automatic module => m1 reads all automatic modules that m2 reads\n+        for (Map.Entry<ResolvedModule, Set<ResolvedModule>> entry : g1.entrySet()) {\n+            ResolvedModule m1 = entry.getKey();\n+\n+            if (m1.descriptor().isAutomatic()) {\n+                continue;\n+            }\n+\n+            Set<ResolvedModule> m1Reads = entry.getValue();\n+\n+            for (ResolvedModule m2 : m1Reads) {\n+                if (!m2.descriptor().isAutomatic()) {\n+                    continue;\n+                }\n+\n+                Set<ResolvedModule> m2Reads;\n+                if (m2.configuration() == cf) {\n+                    \/\/ this configuration\n+                    m2Reads = g1.get(m2);\n+                } else {\n+                    \/\/ parent configuration, already resolved\n+                    \/\/ TODO: does this allocate a copy of the set every time?\n+                    m2Reads = m2.reads();\n+                }\n+\n+                m2Reads.stream()\n+                        .filter(d -> d.descriptor().isAutomatic())\n+                        .forEach(toAdd::add);\n+            }\n+\n+            if (!toAdd.isEmpty()) {\n+                m1Reads.addAll(toAdd);\n+                toAdd.clear();\n+            }\n+        }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/module\/Resolver.java","additions":71,"deletions":43,"binary":false,"changes":114,"status":"modified"},{"patch":"@@ -587,0 +587,1 @@\n+        assertFalse(a.reads().contains(a));  \/\/ should not read itself\n@@ -591,0 +592,1 @@\n+        assertFalse(b.reads().contains(b));  \/\/ should not read itself\n@@ -596,0 +598,1 @@\n+        assertFalse(c.reads().contains(c));  \/\/ should not read itself\n","filename":"test\/jdk\/java\/lang\/module\/AutomaticModulesTest.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"}]}