{"files":[{"patch":"@@ -1699,1 +1699,7 @@\n-            conContext.teardownTransport(cause, alert, false);\n+            try {\n+                conContext.fatal(alert, cause);\n+            } catch (Exception e) {\n+                \/\/ Just delivering the fatal alert, re-throw the socket exception instead.\n+                throw (SocketException)cause;\n+            }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLSocketImpl.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -83,0 +83,1 @@\n+\n@@ -371,10 +372,0 @@\n-        teardownTransport(closeReason, alert, recvFatalAlert);\n-\n-        if (closeReason instanceof SSLException) {\n-            throw (SSLException)closeReason;\n-        } else {\n-            throw (RuntimeException)closeReason;\n-        }\n-    }\n-\n-    void teardownTransport(Exception closeReason, Alert alert, boolean recvFatalAlert) {\n@@ -448,0 +439,6 @@\n+\n+        if (closeReason instanceof SSLException) {\n+            throw (SSLException)closeReason;\n+        } else {\n+            throw (RuntimeException)closeReason;\n+        }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/TransportContext.java","additions":7,"deletions":10,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+ * @library \/javax\/net\/ssl\/templates\n@@ -38,1 +39,2 @@\n-public class SSLSocketShouldThrowSocketException {\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n@@ -40,5 +42,1 @@\n-    \/*\n-     * =============================================================\n-     * Set the various variables needed for the tests, then\n-     * specify what tests to run on each side.\n-     *\/\n+public class SSLSocketShouldThrowSocketException extends SSLSocketTemplate {\n@@ -46,6 +44,1 @@\n-    \/*\n-     * Should we run the client or server in a separate thread?\n-     * Both sides can throw exceptions, but do you have a preference\n-     * as to which side should be the main thread.\n-     *\/\n-    static boolean separateServerThread = true;\n+    boolean handshake;\n@@ -53,7 +46,1 @@\n-    \/*\n-     * Where do we find the keystores?\n-     *\/\n-    static String pathToStores = \"..\/..\/..\/..\/javax\/net\/ssl\/etc\";\n-    static String keyStoreFile = \"keystore\";\n-    static String trustStoreFile = \"truststore\";\n-    static String passwd = \"passphrase\";\n+    private final CountDownLatch clientTerminatedCondition = new CountDownLatch(1);\n@@ -61,59 +48,2 @@\n-    \/*\n-     * Is the server ready to serve?\n-     *\/\n-    volatile static boolean serverReady = false;\n-\n-    \/*\n-     * Was the client responsible for closing the socket\n-     *\/\n-    volatile static boolean clientClosed = false;\n-\n-    \/*\n-     * Turn on SSL debugging?\n-     *\/\n-    static boolean debug = false;\n-\n-    \/*\n-     * If the client or server is doing some kind of object creation\n-     * that the other side depends on, and that thread prematurely\n-     * exits, you may experience a hang.  The test harness will\n-     * terminate all hung threads after its timeout has expired,\n-     * currently 3 minutes by default, but you might try to be\n-     * smart about it....\n-     *\/\n-\n-    \/*\n-     * Define the server side of the test.\n-     *\n-     * The server accepts 2 requests, The first request does not send\n-     * back a handshake message. The second request sends back a\n-     * handshake message.\n-     *\n-     * If the server prematurely exits, serverReady will be set to true\n-     * to avoid infinite hangs.\n-     *\/\n-    void doServerSide() throws Exception {\n-        SSLServerSocketFactory sslssf =\n-            (SSLServerSocketFactory) SSLServerSocketFactory.getDefault();\n-        SSLServerSocket sslServerSocket =\n-            (SSLServerSocket) sslssf.createServerSocket(serverPort);\n-\n-        serverPort = sslServerSocket.getLocalPort();\n-\n-        \/*\n-         * Signal Client, we're ready for his connect.\n-         *\/\n-        serverReady = true;\n-\n-        System.err.println(\"Server accepting: \" + System.nanoTime());\n-        SSLSocket sslSocket = (SSLSocket) sslServerSocket.accept();\n-        System.err.println(\"Server accepted: \" + System.nanoTime());\n-\n-        System.err.println(\"Server accepting: \" + System.nanoTime());\n-        sslSocket = (SSLSocket) sslServerSocket.accept();\n-        sslSocket.startHandshake();\n-        System.err.println(\"Server accepted: \" + System.nanoTime());\n-\n-        while (!clientClosed) {\n-            Thread.sleep(500);\n-        }\n+    SSLSocketShouldThrowSocketException(boolean handshake) {\n+        this.handshake = handshake;\n@@ -122,10 +52,4 @@\n-    Socket initilizeClientSocket() throws Exception {\n-        \/*\n-         * Wait for server to get started.\n-         *\/\n-        System.out.println(\"waiting on server\");\n-        while (!serverReady) {\n-            Thread.sleep(50);\n-        }\n-        Thread.sleep(500);\n-        System.out.println(\"server ready\");\n+    @Override\n+    protected boolean isCustomizedClientConnection() {\n+        return true;\n+    }\n@@ -133,3 +57,3 @@\n-        Socket baseSocket = new Socket(\"localhost\", serverPort);\n-        baseSocket.setSoTimeout(1000);\n-        return baseSocket;\n+    @Override\n+    protected void runServerApplication(SSLSocket socket) throws Exception {\n+        clientTerminatedCondition.await(30L, TimeUnit.SECONDS);\n@@ -138,1 +62,4 @@\n-    SSLSocket initilizeSSLSocket(Socket baseSocket) throws Exception {\n+    @Override\n+    protected void runClientApplication(int serverPort) throws Exception {\n+        Socket baseSocket = new Socket(\"localhost\", this.serverPort);\n+\n@@ -140,1 +67,1 @@\n-            (SSLSocketFactory) SSLSocketFactory.getDefault();\n+                (SSLSocketFactory) SSLSocketFactory.getDefault();\n@@ -142,3 +69,1 @@\n-            sslsf.createSocket(baseSocket, \"localhost\", serverPort, false);\n-        return sslSocket;\n-    }\n+                sslsf.createSocket(baseSocket, \"localhost\", serverPort, false);\n@@ -146,5 +71,7 @@\n-    \/*\n-     * The client should throw a SocketException without wrapping it\n-     * during the handshake process.\n-     *\/\n-    void doClientSideHandshakeClose() throws Exception {\n+        if (this.handshake) {\n+            testHandshakeClose(baseSocket, sslSocket);\n+        } else {\n+            testDataClose(baseSocket, sslSocket);\n+        }\n+\n+        clientTerminatedCondition.countDown();\n@@ -152,2 +79,1 @@\n-        Socket baseSocket = initilizeClientSocket();\n-        SSLSocket sslSocket = initilizeSSLSocket(baseSocket);\n+    }\n@@ -155,0 +81,1 @@\n+    private void testHandshakeClose(Socket baseSocket, SSLSocket sslSocket) throws Exception {\n@@ -181,1 +108,0 @@\n-\n@@ -184,10 +110,1 @@\n-    volatile static boolean handshakeCompleted = false;\n-\n-    \/*\n-     * The client should throw SocketException without wrapping it\n-     * while waiting to read data from the socket.\n-     *\/\n-    void doClientSideDataClose() throws Exception {\n-\n-        Socket baseSocket = initilizeClientSocket();\n-        SSLSocket sslSocket = initilizeSSLSocket(baseSocket);\n+    private void testDataClose(Socket baseSocket, SSLSocket sslSocket) throws Exception{\n@@ -195,1 +112,1 @@\n-        handshakeCompleted = false;\n+        CountDownLatch handshakeCondition = new CountDownLatch(1);\n@@ -202,3 +119,1 @@\n-                    while (!handshakeCompleted) {\n-                        Thread.sleep(10);\n-                    }\n+                    handshakeCondition.await(10L, TimeUnit.SECONDS);\n@@ -219,1 +134,1 @@\n-            handshakeCompleted = true;\n+            handshakeCondition.countDown();\n@@ -230,1 +145,0 @@\n-\n@@ -233,12 +147,0 @@\n-    \/*\n-     * =============================================================\n-     * The remainder is just support stuff\n-     *\/\n-\n-    \/\/ use any free port by default\n-    volatile int serverPort = 0;\n-\n-    volatile Exception serverException = null;\n-\n-    volatile byte[] serverDigest = null;\n-\n@@ -246,77 +148,4 @@\n-        String keyFilename =\n-            System.getProperty(\"test.src\", \".\/\") + \"\/\" + pathToStores +\n-                \"\/\" + keyStoreFile;\n-        String trustFilename =\n-            System.getProperty(\"test.src\", \".\/\") + \"\/\" + pathToStores +\n-                \"\/\" + trustStoreFile;\n-\n-        System.setProperty(\"javax.net.ssl.keyStore\", keyFilename);\n-        System.setProperty(\"javax.net.ssl.keyStorePassword\", passwd);\n-        System.setProperty(\"javax.net.ssl.trustStore\", trustFilename);\n-        System.setProperty(\"javax.net.ssl.trustStorePassword\", passwd);\n-\n-        if (debug)\n-            System.setProperty(\"javax.net.debug\", \"all\");\n-\n-        \/*\n-         * Start the tests.\n-         *\/\n-        new SSLSocketShouldThrowSocketException();\n-    }\n-\n-    Thread serverThread = null;\n-\n-    \/*\n-     * Primary constructor, used to drive remainder of the test.\n-     *\n-     * Fork off the server side.\n-     *\/\n-    SSLSocketShouldThrowSocketException() throws Exception {\n-        startServer();\n-        startClient();\n-\n-        clientClosed = true;\n-        System.err.println(\"Client closed: \" + System.nanoTime());\n-\n-        \/*\n-         * Wait for other side to close down.\n-         *\/\n-        serverThread.join();\n-\n-        \/*\n-         * When we get here, the test is pretty much over.\n-         *\n-         * If the main thread excepted, that propagates back\n-         * immediately.  If the other thread threw an exception, we\n-         * should report back.\n-         *\/\n-        if (serverException != null) {\n-            System.out.print(\"Server Exception:\");\n-            throw serverException;\n-        }\n-    }\n-\n-    void startServer() throws Exception {\n-        serverThread = new Thread() {\n-            public void run() {\n-                try {\n-                     doServerSide();\n-                } catch (Exception e) {\n-                    \/*\n-                     * Our server thread just died.\n-                     *\n-                     * Release the client, if not active already...\n-                     *\/\n-                    System.err.println(\"Server died...\");\n-                    System.err.println(e);\n-                    serverReady = true;\n-                    serverException = e;\n-                }\n-            }\n-        };\n-        serverThread.start();\n-    }\n-\n-    void startClient() throws Exception {\n-        doClientSideHandshakeClose();\n-        doClientSideDataClose();\n+        \/\/ SocketException should be throws during a handshake phase.\n+        (new SSLSocketShouldThrowSocketException(true)).run();\n+        \/\/ SocketException should be throw during the application data phase.\n+        (new SSLSocketShouldThrowSocketException(false)).run();\n","filename":"test\/jdk\/sun\/security\/ssl\/SSLSocketImpl\/SSLSocketShouldThrowSocketException.java","additions":38,"deletions":209,"binary":false,"changes":247,"status":"modified"}]}