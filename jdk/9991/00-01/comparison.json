{"files":[{"patch":"@@ -377,9 +377,5 @@\n-        \/\/ NOTE: This implementation probably is wrong for most situations\n-        \/\/ because it fails to take into account the possibility that a\n-        \/\/ CharacterIterator passed to setText() may not have a begin offset\n-        \/\/ of 0.  But since the abstract BreakIterator doesn't have that\n-        \/\/ knowledge, it assumes the begin offset is 0.  If you subclass\n-        \/\/ BreakIterator, copy the SimpleTextBoundary implementation of this\n-        \/\/ function into your subclass.  [This should have been abstract at\n-        \/\/ this level, but it's too late to fix that now.]\n-        if (offset == 0) {\n+        var ci = getText();\n+        var begin = ci.getBeginIndex();\n+        if (offset < begin || offset > ci.getEndIndex()) {\n+            throw new IllegalArgumentException(\"offset is out of bounds: \" + offset);\n+        } else if (offset == begin) {\n@@ -387,0 +383,6 @@\n+        } else {\n+            int boundary = following(offset - 1);\n+            if (boundary == DONE) {\n+                throw new IllegalArgumentException();\n+            }\n+            return boundary == offset;\n@@ -388,5 +390,0 @@\n-        int boundary = following(offset - 1);\n-        if (boundary == DONE) {\n-            throw new IllegalArgumentException();\n-        }\n-        return boundary == offset;\n","filename":"src\/java.base\/share\/classes\/java\/text\/BreakIterator.java","additions":11,"deletions":14,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/regex\/EmojiData.java.template","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-        Objects.checkFromToIndex(off, limit, src.length());\n+        Objects.checkFromToIndex(0, limit - off, src.length());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/regex\/Grapheme.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n-import java.util.stream.IntStream;\n@@ -200,4 +199,4 @@\n-        private CharacterIterator ci;\n-        private int offset;\n-        private List<Integer> boundaries;\n-        private int boundaryIndex;\n+        CharacterIterator ci;\n+        int offset;\n+        List<Integer> boundaries;\n+        int boundaryIndex;\n@@ -206,3 +205,1 @@\n-            boundaries = Collections.emptyList();\n-            boundaryIndex = 0;\n-            offset = 0;\n+            setText(\"\");\n@@ -229,4 +226,8 @@\n-            var oldIndex = boundaryIndex;\n-            boundaryIndex = boundaryIndex + n <= 0 ? 0 : Math.min(boundaryIndex + n, boundaries.size() - 1);\n-\n-            if (oldIndex == boundaryIndex && offset == boundaries.get(boundaryIndex)) {\n+            boundaryIndex = boundaryIndex + n;\n+            if (boundaryIndex < 0) {\n+                boundaryIndex = 0;\n+                current();\n+                return DONE;\n+            } else if (boundaryIndex >= boundaries.size()) {\n+                boundaryIndex = boundaries.size() - 1;\n+                current();\n@@ -251,1 +252,5 @@\n-            if (offset >= this.offset && this.offset == boundaries.get(boundaries.size() - 1)) {\n+            var lastBoundary = boundaries.get(boundaries.size() - 1);\n+\n+            if (offset < boundaries.get(0) || offset > lastBoundary) {\n+                throw new IllegalArgumentException(\"offset is out of bounds: \" + offset);\n+            } else if (offset == this.offset && this.offset == lastBoundary) {\n@@ -255,4 +260,4 @@\n-            boundaryIndex = IntStream.range(0, boundaries.size())\n-                    .filter(i -> boundaries.get(i) > offset)\n-                    .findFirst()\n-                    .orElse(boundaries.size() - 1);\n+            boundaryIndex = Collections.binarySearch(boundaries, Math.min(offset + 1, lastBoundary));\n+            if (boundaryIndex < 0) {\n+                boundaryIndex = -boundaryIndex - 1;\n+            }\n@@ -278,1 +283,1 @@\n-            var limit = text.length();\n+            var end = ci.getEndIndex();\n@@ -281,3 +286,3 @@\n-            for (int b = 0; b < limit;) {\n-                boundaries.add(b + ci.getBeginIndex());\n-                b = Grapheme.nextBoundary(text, b - ci.getBeginIndex(), text.length());\n+            for (int b = ci.getBeginIndex(); b < end;) {\n+                boundaries.add(b);\n+                b = Grapheme.nextBoundary(text, b, end);\n@@ -285,1 +290,1 @@\n-            boundaries.add(ci.getEndIndex());\n+            boundaries.add(end);\n@@ -287,1 +292,15 @@\n-            offset = ci.getBeginIndex();\n+            offset = ci.getIndex();\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(ci, offset, boundaries, boundaryIndex);\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            return o instanceof GraphemeBreakIterator that &&\n+                    ci.equals(that.ci) &&\n+                    offset == that.offset &&\n+                    boundaries.equals(that.boundaries) &&\n+                    boundaryIndex == that.boundaryIndex;\n","filename":"src\/java.base\/share\/classes\/sun\/util\/locale\/provider\/BreakIteratorProviderImpl.java","additions":42,"deletions":23,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -29,2 +29,2 @@\n- * @compile --add-exports java.base\/jdk.internal.util.regex=ALL-UNNAMED GraphemeTest.java\n- * @run testng\/othervm --add-exports java.base\/jdk.internal.util.regex=ALL-UNNAMED --add-opens java.base\/jdk.internal.util.regex=ALL-UNNAMED GraphemeTest\n+ * @modules java.base\/jdk.internal.util.regex:+open\n+ * @run testng GraphemeTest\n","filename":"test\/jdk\/java\/util\/regex\/whitebox\/GraphemeTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}