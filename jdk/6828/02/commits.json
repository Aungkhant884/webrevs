[{"commit":{"message":"Update copyright year and rename a function\n\nChange-Id: I15845ebd3982edebd4c151284cc6f2ff727630bb"},"files":[{"filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp"},{"filename":"src\/hotspot\/cpu\/x86\/x86_32.ad"},{"filename":"src\/hotspot\/cpu\/x86\/x86_64.ad"},{"filename":"src\/hotspot\/share\/opto\/classes.hpp"},{"filename":"src\/hotspot\/share\/opto\/loopnode.cpp"},{"filename":"src\/hotspot\/share\/opto\/node.hpp"},{"filename":"src\/hotspot\/share\/opto\/superword.cpp"},{"filename":"src\/hotspot\/share\/opto\/superword.hpp"},{"filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp"},{"filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp"},{"filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/ArrayCopyTest.java"},{"filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/ArrayIndexFillTest.java"},{"filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/ArrayInvariantFillTest.java"},{"filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/ArrayShiftOpTest.java"},{"filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/ArrayTypeConvertTest.java"},{"filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/ArrayUnsafeOpTest.java"},{"filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/BasicBooleanOpTest.java"},{"filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/BasicByteOpTest.java"},{"filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/BasicCharOpTest.java"},{"filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/BasicDoubleOpTest.java"},{"filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/BasicFloatOpTest.java"},{"filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/BasicIntOpTest.java"},{"filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/BasicLongOpTest.java"},{"filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/BasicShortOpTest.java"},{"filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/LoopArrayIndexComputeTest.java"},{"filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/LoopCombinedOpTest.java"},{"filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/LoopControlFlowTest.java"},{"filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/LoopLiveOutNodesTest.java"},{"filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/LoopRangeStrideTest.java"},{"filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/LoopReductionOpTest.java"},{"filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/MultipleLoopsTest.java"},{"filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/StripMinedLoopTest.java"},{"filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/VectorizationTestRunner.java"}],"sha":"5657588634a6f2cf27d55f1d2ed713d2c9c9565f"},{"commit":{"message":"Merge branch 'master' into postloop\n\nChange-Id: Ie639c79c9cf016dc68ebf2c0031b60453b45e9a4"},"files":[{"filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp"},{"filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp"},{"filename":"src\/hotspot\/cpu\/x86\/x86.ad"},{"filename":"src\/hotspot\/cpu\/x86\/x86_32.ad"},{"filename":"src\/hotspot\/cpu\/x86\/x86_64.ad"},{"filename":"src\/hotspot\/share\/opto\/loopTransform.cpp"},{"filename":"src\/hotspot\/share\/opto\/loopnode.cpp"},{"filename":"src\/hotspot\/share\/opto\/loopnode.hpp"},{"filename":"src\/hotspot\/share\/opto\/vectornode.hpp"}],"sha":"426894127389f8dfcad30bb9d84f4b73c24886cf"},{"commit":{"message":"Fix issues in newly added test framework\n\nChange-Id: I6e61abf05e9665325cb3abaf407360b18355c6b1"},"files":[{"filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/ArrayCopyTest.java"},{"filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/ArrayIndexFillTest.java"},{"filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/ArrayInvariantFillTest.java"},{"filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/ArrayShiftOpTest.java"},{"filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/ArrayTypeConvertTest.java"},{"filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/ArrayUnsafeOpTest.java"},{"filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/BasicBooleanOpTest.java"},{"filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/BasicByteOpTest.java"},{"filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/BasicCharOpTest.java"},{"filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/BasicDoubleOpTest.java"},{"filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/BasicFloatOpTest.java"},{"filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/BasicIntOpTest.java"},{"filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/BasicLongOpTest.java"},{"filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/BasicShortOpTest.java"},{"filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/LoopArrayIndexComputeTest.java"},{"filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/LoopCombinedOpTest.java"},{"filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/LoopControlFlowTest.java"},{"filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/LoopLiveOutNodesTest.java"},{"filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/LoopRangeStrideTest.java"},{"filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/LoopReductionOpTest.java"},{"filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/MultipleLoopsTest.java"},{"filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/StripMinedLoopTest.java"},{"filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/VectorizationTestRunner.java"}],"sha":"85ce597dbabe607b64505dcf960401f90ac3563c"},{"commit":{"message":"Merge branch 'master' into postloop\n\nChange-Id: I9bb5a808d7540426dedb141fd198d25eb1f569e6"},"files":[{"filename":"src\/hotspot\/cpu\/x86\/x86.ad"}],"sha":"844e70ba1660936054945b99a0579c8fa8a35546"},{"commit":{"message":"8183390: Fix and re-enable post loop vectorization\n\n** Background\n\nPost loop vectorization is a C2 compiler optimization in an experimental\nVM feature called PostLoopMultiversioning. It transforms the range-check\neliminated post loop to a 1-iteration vectorized loop with vector mask.\nThis optimization was contributed by Intel in 2016 to support x86 AVX512\nmasked vector instructions. However, it was disabled soon after an issue\nwas found. Due to insufficient maintenance in these years, multiple bugs\nhave been accumulated inside. But we (Arm) still think this is a useful\nframework for vector mask support in C2 auto-vectorized loops, for both\nx86 AVX512 and AArch64 SVE. Hence, we propose this to fix and re-enable\npost loop vectorization.\n\n** Changes in this patch\n\nThis patch reworks post loop vectorization. The most significant change\nis removing vector mask support in C2 x86 backend and re-implementing\nit in the mid-end. With this, we can re-enable post loop vectorization\nfor platforms other than x86.\n\nPrevious implementation hard-codes x86 k1 register as a reserved AVX512\nopmask register and defines two routines (setvectmask\/restorevectmask)\nto set and restore the value of k1. But after JDK-8211251 which encodes\nAVX512 instructions as unmasked by default, generated vector masks are\nno longer used in AVX512 vector instructions. To fix incorrect codegen\nand add vector mask support for more platforms, we turn to add a vector\nmask input to C2 mid-end IRs. Specifically, we use a VectorMaskGenNode\nto generate a mask and replace all Load\/Store nodes in the post loop\ninto LoadVectorMasked\/StoreVectorMasked nodes with that mask input. This\nIR form is exactly the same to those which are used in VectorAPI mask\nsupport. For now, we only add mask inputs for Load\/Store nodes because\nwe don't have reduction operations supported in post loop vectorization.\nAfter this change, the x86 k1 register is no longer reserved and can be\nallocated when PostLoopMultiversioning is enabled.\n\nBesides this change, we have fixed a compiler crash and five incorrect\nresult issues with post loop vectorization.\n\n- 1) C2 crashes with segmentation fault in strip-mined loops\n\nPrevious implementation was done before C2 loop strip-mining was merged\ninto JDK master so it didn't take strip-mined loops into consideration.\nIn C2's strip mined loops, post loop is not the sibling of the main loop\nin ideal loop tree. Instead, it's the sibling of the main loop's parent.\nThis patch fixed a SIGSEGV issue caused by NULL pointer when locating\npost loop from strip-mined main loop.\n\n- 2) Incorrect result issues with post loop vectorization\n\nWe have also fixed five incorrect vectorization issues. Some of them are\nhidden deep and can only be reproduced with corner cases. These issues\nhave a common cause that it assumes the post loop can be vectorized if\nthe vectorization in corresponding main loop is successful. But in many\ncases this assumption is wrong. Below are details.\n\n[Issue-1] Incorrect vectorization for partial vectorizable loops\n\nThis issue can be reproduced by below loop where only some operations in\nthe loop body are vectorizable.\n\n  for (int i = 0; i < 10000; i++) {\n    res[i] = a[i] * b[i];\n    k = 3 * k + 1;\n  }\n\nIn the main loop, superword can work well if parts of the operations in\nloop body are not vectorizable since those parts can be unrolled only.\nBut for post loops, we don't create vectors through combining scalar IRs\ngenerated from loop unrolling. Instead, we are doing scalars to vectors\nreplacement for all operations in the loop body. Hence, all operations\nshould be either vectorized together or not vectorized at all. To fix\nthis kind of cases, we add an extra field \"_slp_vector_pack_count\" in\nCountedLoopNode to record the eventual count of vector packs in the main\nloop. This value is then passed to post loop and compared with post loop\npack count. Vectorization will be bailed out in post loop if it creates\nmore vector packs than in the main loop.\n\n[Issue-2] Incorrect result in loops with growing-down vectors\n\nThis issue appears with growing-down vectors, that is, vectors that grow\nto smaller memory address as the loop iterates. It can be reproduced by\nbelow counting-up loop with negative scale value in array index.\n\n  for (int i = 0; i < 10000; i++) {\n    a[MAX - i] = b[MAX - i];\n  }\n\nCause of this issue is that for a growing-down vector, generated vector\nmask value has reversed vector-lane order so it masks incorrect vector\nlanes. Note that if negative scale value appears in counting-down loops,\nthe vector will be growing up. With this rule, we fix the issue by only\nallowing positive array index scales in counting-up loops and negative\narray index scales in counting-down loops. This check is done with the\nhelp of SWPointer by comparing scale values in each memory access in the\nloop with loop stride value.\n\n[Issue-3] Incorrect result in manually unrolled loops\n\nThis issue can be reproduced by below manually unrolled loop.\n\n  for (int i = 0; i < 10000; i += 2) {\n    c[i] = a[i] + b[i];\n    c[i + 1] = a[i + 1] * b[i + 1];\n  }\n\nIn this loop, operations in the 2nd statement duplicate those in the 1st\nstatement with a small memory address offset. Vectorization in the main\nloop works well in this case because C2 does further unrolling and pack\ncombination. But we cannot vectorize the post loop through replacement\nfrom scalars to vectors because it creates duplicated vector operations.\nTo fix this, we restrict post loop vectorization to loops with stride\nvalues of 1 or -1.\n\n[Issue-4] Incorrect result in loops with mixed vector element sizes\n\nThis issue is found after we enable post loop vectorization for AArch64.\nIt's reproducible by multiple array operations with different element\nsizes inside a loop. On x86, there is no issue because the values of x86\nAVX512 opmasks only depend on which vector lanes are active. But AArch64\nis different - the values of SVE predicates also depend on lane size of\nthe vector. Hence, on AArch64 SVE, if a loop has mixed vector element\nsizes, we should use different vector masks. For now, we just support\nloops with only one vector element size, i.e., \"int + float\" vectors in\na single loop is ok but \"int + double\" vectors in a single loop is not\nvectorizable. This fix also enables subword vectors support to make all\nprimitive type array operations vectorizable.\n\n[Issue-5] Incorrect result in loops with potential data dependence\n\nThis issue can be reproduced by below corner case on AArch64 only.\n\n  for (int i = 0; i < 10000; i++) {\n    a[i] = x;\n    a[i + OFFSET] = y;\n  }\n\nIn this case, two stores in the loop have data dependence if the OFFSET\nvalue is smaller than the vector length. So we cannot do vectorization\nthrough replacing scalars to vectors. But the main loop vectorization\nin this case is successful on AArch64 because AArch64 has partial vector\nload\/store support. It splits vector fill with different values in lanes\nto several smaller-sized fills. In this patch, we add additional data\ndependence check for this kind of cases. The check is also done with the\nhelp of SWPointer class. In this check, we require that every two memory\naccesses (with at least one store) of the same element type (or subword\nsize) in the loop has the same array index expression.\n\n** Tests\n\nSo far we have tested full jtreg on both x86 AVX512 and AArch64 SVE with\nexperimental VM option \"PostLoopMultiversioning\" turned on. We found no\nissue in all tests. We notice that those existing cases are not enough\nbecause some of above issues are not spotted by them. We would like to\nadd some new cases but we found existing vectorization tests are a bit\ncumbersome - golden results must be pre-calculated and hard-coded in the\ntest code for correctness verification. Thus, in this patch, we propose\na new vectorization testing framework.\n\nOur new framework brings a simpler way to add new cases. For a new test\ncase, we only need to create a new method annotated with \"@Test\". The\ntest runner will invoke each annotated method twice automatically. First\ntime it runs in the interpreter and second time it's forced compiled by\nC2. Then the two return results are compared. So in this framework each\ntest method should return a primitive value or an array of primitives.\nIn this way, no extra verification code for vectorization correctness is\nrequired. This test runner is still jtreg-based and takes advantages of\nthe jtreg WhiteBox API, which enables test methods running at specific\ncompilation levels. Each test class inside is also jtreg-based. It just\nneed to inherit from the test runner class and run with two additional\noptions \"-Xbootclasspath\/a:.\" and \"-XX:+WhiteBoxAPI\".\n\n** Summary & Future work\n\nIn this patch, we reworked post loop vectorization. We made it platform\nindependent and fixed several issues inside. We also implemented a new\nvectorization testing framework with many test cases inside. Meanwhile,\nwe did some code cleanups.\n\nThis patch only touches C2 code guarded with PostLoopMultiversioning,\nexcept a few data structure changes. So, there's no behavior change when\nexperimental VM option PostLoopMultiversioning is off. Also, to reduce\nrisks, we still propose to keep post loop vectorization experimental for\nnow. But if it receives positive feedback, we would like to change it to\nnon-experimental in the future."},"files":[{"filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp"},{"filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp"},{"filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp"},{"filename":"src\/hotspot\/cpu\/x86\/x86.ad"},{"filename":"src\/hotspot\/cpu\/x86\/x86_32.ad"},{"filename":"src\/hotspot\/cpu\/x86\/x86_64.ad"},{"filename":"src\/hotspot\/share\/opto\/classes.hpp"},{"filename":"src\/hotspot\/share\/opto\/loopTransform.cpp"},{"filename":"src\/hotspot\/share\/opto\/loopnode.cpp"},{"filename":"src\/hotspot\/share\/opto\/loopnode.hpp"},{"filename":"src\/hotspot\/share\/opto\/node.hpp"},{"filename":"src\/hotspot\/share\/opto\/superword.cpp"},{"filename":"src\/hotspot\/share\/opto\/superword.hpp"},{"filename":"src\/hotspot\/share\/opto\/vectornode.hpp"},{"filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp"},{"filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp"},{"filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/ArrayCopyTest.java"},{"filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/ArrayIndexFillTest.java"},{"filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/ArrayInvariantFillTest.java"},{"filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/ArrayShiftOpTest.java"},{"filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/ArrayTypeConvertTest.java"},{"filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/ArrayUnsafeOpTest.java"},{"filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/BasicBooleanOpTest.java"},{"filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/BasicByteOpTest.java"},{"filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/BasicCharOpTest.java"},{"filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/BasicDoubleOpTest.java"},{"filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/BasicFloatOpTest.java"},{"filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/BasicIntOpTest.java"},{"filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/BasicLongOpTest.java"},{"filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/BasicShortOpTest.java"},{"filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/LoopArrayIndexComputeTest.java"},{"filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/LoopCombinedOpTest.java"},{"filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/LoopControlFlowTest.java"},{"filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/LoopLiveOutNodesTest.java"},{"filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/LoopRangeStrideTest.java"},{"filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/LoopReductionOpTest.java"},{"filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/MultipleLoopsTest.java"},{"filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/StripMinedLoopTest.java"},{"filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/VectorizationTestRunner.java"}],"sha":"cae3b16b59ac3648cb847b162ed2a6d64b1aa233"}]