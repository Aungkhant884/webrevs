{"files":[{"patch":"@@ -51,14 +51,0 @@\n-void C2_MacroAssembler::setvectmask(Register dst, Register src, KRegister mask) {\n-  guarantee(PostLoopMultiversioning, \"must be\");\n-  Assembler::movl(dst, 1);\n-  Assembler::shlxl(dst, dst, src);\n-  Assembler::decl(dst);\n-  Assembler::kmovdl(mask, dst);\n-  Assembler::movl(dst, src);\n-}\n-\n-void C2_MacroAssembler::restorevectmask(KRegister mask) {\n-  guarantee(PostLoopMultiversioning, \"must be\");\n-  Assembler::knotwl(mask, k0);\n-}\n-\n@@ -1950,1 +1936,0 @@\n-  assert(ArrayOperationPartialInlineSize > 0 && ArrayOperationPartialInlineSize <= 64, \"invalid\");\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":0,"deletions":15,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -33,4 +33,0 @@\n-  \/\/ special instructions for EVEX\n-  void setvectmask(Register dst, Register src, KRegister mask);\n-  void restorevectmask(KRegister mask);\n-\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -4674,10 +4674,0 @@\n-  \/\/ Reset k1 to 0xffff.\n-\n-#ifdef COMPILER2\n-  if (PostLoopMultiversioning && VM_Version::supports_evex()) {\n-    push(rcx);\n-    movl(rcx, 0xffff);\n-    kmovwl(k1, rcx);\n-    pop(rcx);\n-  }\n-#endif \/\/ COMPILER2\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2828,17 +2828,0 @@\n-\/\/ =================================EVEX special===============================\n-\/\/ Existing partial implementation for post-loop multi-versioning computes\n-\/\/ the mask corresponding to tail loop in K1 opmask register. This may then be\n-\/\/ used for predicating instructions in loop body during last post-loop iteration.\n-\/\/ TODO: Remove hard-coded K1 usage while fixing existing post-loop\n-\/\/ multiversioning support.\n-instruct setMask(rRegI dst, rRegI src, kReg_K1 mask) %{\n-  predicate(PostLoopMultiversioning && Matcher::has_predicated_vectors());\n-  match(Set dst (SetVectMaskI  src));\n-  effect(TEMP dst);\n-  format %{ \"setvectmask   $dst, $src\" %}\n-  ins_encode %{\n-    __ setvectmask($dst$$Register, $src$$Register, $mask$$KRegister);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":0,"deletions":17,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -263,11 +263,1 @@\n-void reg_mask_init() {\n-  if (Matcher::has_predicated_vectors()) {\n-    \/\/ Post-loop multi-versioning expects mask to be present in K1 register, till the time\n-    \/\/ its fixed, RA should not be allocting K1 register, this shall prevent any accidental\n-    \/\/ curruption of value held in K1 register.\n-    if (PostLoopMultiversioning) {\n-      const_cast<RegMask*>(&_VECTMASK_REG_mask)->Remove(OptoReg::as_OptoReg(k1->as_VMReg()));\n-      const_cast<RegMask*>(&_VECTMASK_REG_mask)->Remove(OptoReg::as_OptoReg(k1->as_VMReg()->next()));\n-    }\n-  }\n-}\n+void reg_mask_init() {}\n@@ -12613,1 +12603,0 @@\n-  predicate(!n->has_vector_mask_set());\n@@ -12629,1 +12618,0 @@\n-  predicate(!n->has_vector_mask_set());\n@@ -12644,1 +12632,0 @@\n-  predicate(!n->has_vector_mask_set());\n@@ -12658,60 +12645,0 @@\n-\/\/ mask version\n-\/\/ Jump Direct Conditional - Label defines a relative address from Jcc+1\n-\/\/ Bounded mask operand used in following patten is needed for\n-\/\/ post-loop multiversioning.\n-instruct jmpLoopEnd_and_restoreMask(cmpOp cop, kReg_K1 ktmp, eFlagsReg cr, label labl) %{\n-  predicate(PostLoopMultiversioning && n->has_vector_mask_set());\n-  match(CountedLoopEnd cop cr);\n-  effect(USE labl, TEMP ktmp);\n-\n-  ins_cost(400);\n-  format %{ \"J$cop    $labl\\t# Loop end\\n\\t\"\n-            \"restorevectmask \\t# vector mask restore for loops\" %}\n-  size(10);\n-  ins_encode %{\n-    Label* L = $labl$$label;\n-    __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); \/\/ Always long jump\n-    __ restorevectmask($ktmp$$KRegister);\n-  %}\n-  ins_pipe( pipe_jcc );\n-%}\n-\n-\/\/ Jump Direct Conditional - Label defines a relative address from Jcc+1\n-\/\/ Bounded mask operand used in following patten is needed for\n-\/\/ post-loop multiversioning.\n-instruct jmpLoopEndU_and_restoreMask(cmpOpU cop, kReg_K1 ktmp, eFlagsRegU cmp, label labl) %{\n-  predicate(PostLoopMultiversioning && n->has_vector_mask_set());\n-  match(CountedLoopEnd cop cmp);\n-  effect(USE labl, TEMP ktmp);\n-\n-  ins_cost(400);\n-  format %{ \"J$cop,u  $labl\\t# Loop end\\n\\t\"\n-            \"restorevectmask \\t# vector mask restore for loops\" %}\n-  size(10);\n-  ins_encode %{\n-    Label* L = $labl$$label;\n-    __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); \/\/ Always long jump\n-    __ restorevectmask($ktmp$$KRegister);\n-  %}\n-  ins_pipe( pipe_jcc );\n-%}\n-\n-\/\/ Bounded mask operand used in following patten is needed for\n-\/\/ post-loop multiversioning.\n-instruct jmpLoopEndUCF_and_restoreMask(cmpOpUCF cop, kReg_K1 ktmp, eFlagsRegUCF cmp, label labl) %{\n-  predicate(PostLoopMultiversioning && n->has_vector_mask_set());\n-  match(CountedLoopEnd cop cmp);\n-  effect(USE labl, TEMP ktmp);\n-\n-  ins_cost(300);\n-  format %{ \"J$cop,u  $labl\\t# Loop end\\n\\t\"\n-            \"restorevectmask \\t# vector mask restore for loops\" %}\n-  size(10);\n-  ins_encode %{\n-    Label* L = $labl$$label;\n-    __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); \/\/ Always long jump\n-    __ restorevectmask($ktmp$$KRegister);\n-  %}\n-  ins_pipe( pipe_jcc );\n-%}\n-\n","filename":"src\/hotspot\/cpu\/x86\/x86_32.ad","additions":1,"deletions":74,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -457,10 +457,0 @@\n-\n-  if (Matcher::has_predicated_vectors()) {\n-    \/\/ Post-loop multi-versioning expects mask to be present in K1 register, till the time\n-    \/\/ its fixed, RA should not be allocting K1 register, this shall prevent any accidental\n-    \/\/ curruption of value held in K1 register.\n-    if (PostLoopMultiversioning) {\n-      const_cast<RegMask*>(&_VECTMASK_REG_mask)->Remove(OptoReg::as_OptoReg(k1->as_VMReg()));\n-      const_cast<RegMask*>(&_VECTMASK_REG_mask)->Remove(OptoReg::as_OptoReg(k1->as_VMReg()->next()));\n-    }\n-  }\n@@ -12694,1 +12684,0 @@\n-  predicate(!n->has_vector_mask_set());\n@@ -12710,1 +12699,0 @@\n-  predicate(!n->has_vector_mask_set());\n@@ -12725,1 +12713,0 @@\n-  predicate(!n->has_vector_mask_set());\n@@ -12739,61 +12726,0 @@\n-\/\/ mask version\n-\/\/ Jump Direct Conditional - Label defines a relative address from Jcc+1\n-\/\/ Bounded mask operand used in following patten is needed for\n-\/\/ post-loop multiversioning.\n-instruct jmpLoopEnd_and_restoreMask(cmpOp cop, kReg_K1 ktmp, rFlagsReg cr, label labl)\n-%{\n-  predicate(PostLoopMultiversioning && n->has_vector_mask_set());\n-  match(CountedLoopEnd cop cr);\n-  effect(USE labl, TEMP ktmp);\n-\n-  ins_cost(400);\n-  format %{ \"j$cop     $labl\\t# loop end\\n\\t\"\n-            \"restorevectmask \\t# vector mask restore for loops\" %}\n-  size(10);\n-  ins_encode %{\n-    Label* L = $labl$$label;\n-    __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); \/\/ Always long jump\n-    __ restorevectmask($ktmp$$KRegister);\n-  %}\n-  ins_pipe(pipe_jcc);\n-%}\n-\n-\/\/ Jump Direct Conditional - Label defines a relative address from Jcc+1\n-\/\/ Bounded mask operand used in following patten is needed for\n-\/\/ post-loop multiversioning.\n-instruct jmpLoopEndU_and_restoreMask(cmpOpU cop, kReg_K1 ktmp, rFlagsRegU cmp, label labl) %{\n-  predicate(PostLoopMultiversioning && n->has_vector_mask_set());\n-  match(CountedLoopEnd cop cmp);\n-  effect(USE labl, TEMP ktmp);\n-\n-  ins_cost(400);\n-  format %{ \"j$cop,u   $labl\\t# loop end\\n\\t\"\n-            \"restorevectmask \\t# vector mask restore for loops\" %}\n-  size(10);\n-  ins_encode %{\n-    Label* L = $labl$$label;\n-    __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); \/\/ Always long jump\n-    __ restorevectmask($ktmp$$KRegister);\n-  %}\n-  ins_pipe(pipe_jcc);\n-%}\n-\n-\/\/ Bounded mask operand used in following patten is needed for\n-\/\/ post-loop multiversioning.\n-instruct jmpLoopEndUCF_and_restoreMask(cmpOpUCF cop, kReg_K1 ktmp, rFlagsRegUCF cmp, label labl) %{\n-  predicate(PostLoopMultiversioning && n->has_vector_mask_set());\n-  match(CountedLoopEnd cop cmp);\n-  effect(USE labl, TEMP ktmp);\n-\n-  ins_cost(300);\n-  format %{ \"j$cop,u   $labl\\t# loop end\\n\\t\"\n-            \"restorevectmask \\t# vector mask restore for loops\" %}\n-  size(10);\n-  ins_encode %{\n-    Label* L = $labl$$label;\n-    __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); \/\/ Always long jump\n-    __ restorevectmask($ktmp$$KRegister);\n-  %}\n-  ins_pipe(pipe_jcc);\n-%}\n-\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":0,"deletions":74,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -217,1 +217,0 @@\n-macro(SetVectMaskI)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3670,1 +3670,2 @@\n-    if (should_unroll && !should_peel && PostLoopMultiversioning) {\n+    if (should_unroll && !should_peel && PostLoopMultiversioning &&\n+        Matcher::has_predicated_vectors()) {\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -4549,1 +4549,2 @@\n-        if (PostLoopMultiversioning && cl->is_rce_post_loop() && !cl->is_vectorized_loop()) {\n+        if (cl->is_rce_post_loop() && !cl->is_vectorized_loop()) {\n+          assert(PostLoopMultiversioning, \"multiversioning must be enabled\");\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -249,0 +249,3 @@\n+  \/\/ The eventual count of vectorizable packs in slp\n+  int _slp_vector_pack_count;\n+\n@@ -253,1 +256,1 @@\n-      _slp_maximum_unroll_factor(0) {\n+      _slp_maximum_unroll_factor(0), _slp_vector_pack_count(0) {\n@@ -330,0 +333,2 @@\n+  void set_slp_pack_count(int pack_count)    { _slp_vector_pack_count = pack_count; }\n+  int  slp_pack_count() const                { return _slp_vector_pack_count; }\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -785,5 +785,4 @@\n-    Flag_has_vector_mask_set         = 1 << 13,\n-    Flag_is_expensive                = 1 << 14,\n-    Flag_is_predicated_vector        = 1 << 15,\n-    Flag_for_post_loop_opts_igvn     = 1 << 16,\n-    Flag_is_removed_by_peephole      = 1 << 17,\n+    Flag_is_expensive                = 1 << 13,\n+    Flag_is_predicated_vector        = 1 << 14,\n+    Flag_for_post_loop_opts_igvn     = 1 << 15,\n+    Flag_is_removed_by_peephole      = 1 << 16,\n@@ -1004,3 +1003,0 @@\n-  \/\/ The node is a CountedLoopEnd with a mask annotation so as to emit a restore context\n-  bool has_vector_mask_set() const { return (_flags & Flag_has_vector_mask_set) != 0; }\n-\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -113,20 +113,3 @@\n-  bool post_loop_allowed = (PostLoopMultiversioning && Matcher::has_predicated_vectors() && cl->is_post_loop());\n-  if (post_loop_allowed) {\n-    if (cl->is_reduction_loop()) {\n-      return false; \/\/ no predication mapping\n-    }\n-    Node *limit = cl->limit();\n-    if (limit->is_Con()) {\n-      return false; \/\/ non constant limits only\n-    }\n-    \/\/ Now check the limit for expressions we do not handle\n-    if (limit->is_Add()) {\n-      Node *in2 = limit->in(2);\n-      if (in2->is_Con()) {\n-        int val = in2->get_int();\n-        \/\/ should not try to program these cases\n-        if (val < 0) {\n-          return false;\n-        }\n-      }\n-    }\n+  if (cl->is_rce_post_loop() && cl->is_reduction_loop()) {\n+    \/\/ Post loop vectorization doesn't support reductions\n+    return false;\n@@ -196,1 +179,1 @@\n-    if (PostLoopMultiversioning && Matcher::has_predicated_vectors()) {\n+    if (PostLoopMultiversioning) {\n@@ -198,1 +181,1 @@\n-        IdealLoopTree *lpt_next = lpt->_next;\n+        IdealLoopTree *lpt_next = cl->is_strip_mined() ? lpt->_parent->_next : lpt->_next;\n@@ -201,1 +184,5 @@\n-        if (cl_next->is_post_loop() && !cl_next->range_checks_present()) {\n+        \/\/ Main loop SLP works well for manually unrolled loops. But post loop\n+        \/\/ vectorization doesn't work for these. To bail out the optimization\n+        \/\/ earlier, we have range check and loop stride conditions below.\n+        if (cl_next->is_post_loop() && !cl_next->range_checks_present() &&\n+            cl_next->stride_is_con() && abs(cl_next->stride_con()) == 1) {\n@@ -203,2 +190,4 @@\n-            int slp_max_unroll_factor = cl->slp_max_unroll();\n-            cl_next->set_slp_max_unroll(slp_max_unroll_factor);\n+            \/\/ Propagate some main loop attributes to its corresponding scalar\n+            \/\/ rce'd post loop for vectorization with vector masks\n+            cl_next->set_slp_max_unroll(cl->slp_max_unroll());\n+            cl_next->set_slp_pack_count(cl->slp_pack_count());\n@@ -232,1 +221,0 @@\n-  bool post_loop_allowed = (PostLoopMultiversioning && Matcher::has_predicated_vectors() && cl->is_post_loop());\n@@ -242,0 +230,1 @@\n+      n->is_Bool() ||\n@@ -329,0 +318,21 @@\n+    \/\/ In the main loop, SLP works well if parts of the operations in the loop body\n+    \/\/ are not vectorizable and those non-vectorizable parts will be unrolled only.\n+    \/\/ But in post loops with vector masks, we create singleton packs directly from\n+    \/\/ scalars so all operations should be vectorized together. This compares the\n+    \/\/ number of packs in the post loop with the main loop and bail out if the post\n+    \/\/ loop potentially has more packs.\n+    if (cl->is_rce_post_loop()) {\n+      for (uint i = 0; i < lpt()->_body.size(); i++) {\n+        if (ignored_loop_nodes[i] == -1) {\n+          _post_block.at_put_grow(rpo_idx++, lpt()->_body.at(i));\n+        }\n+      }\n+      if (_post_block.length() > cl->slp_pack_count()) {\n+        \/\/ Clear local_loop_unroll_factor and bail out directly from here\n+        local_loop_unroll_factor = 0;\n+        cl->mark_was_slp();\n+        cl->set_slp_max_unroll(0);\n+        return;\n+      }\n+    }\n+\n@@ -331,1 +341,0 @@\n-    bool small_basic_type = false;\n@@ -344,22 +353,0 @@\n-      if (post_loop_allowed) {\n-        if (!small_basic_type) {\n-          switch (bt) {\n-          case T_CHAR:\n-          case T_BYTE:\n-          case T_SHORT:\n-            small_basic_type = true;\n-            break;\n-\n-          case T_LONG:\n-            \/\/ TODO: Remove when support completed for mask context with LONG.\n-            \/\/       Support needs to be augmented for logical qword operations, currently we map to dword\n-            \/\/       buckets for vectors on logicals as these were legacy.\n-            small_basic_type = true;\n-            break;\n-\n-          default:\n-            break;\n-          }\n-        }\n-      }\n-\n@@ -368,1 +355,1 @@\n-         int cur_max_vector = Matcher::max_vector_size(bt);\n+      int cur_max_vector = Matcher::max_vector_size(bt);\n@@ -413,5 +400,0 @@\n-        \/\/ We only process post loops on predicated targets where we want to\n-        \/\/ mask map the loop to a single iteration\n-        if (post_loop_allowed) {\n-          _post_block.at_put_grow(rpo_idx++, n);\n-        }\n@@ -425,8 +407,1 @@\n-    if (cl->is_main_loop()) {\n-      cl->set_slp_max_unroll(local_loop_unroll_factor);\n-    } else if (post_loop_allowed) {\n-      if (!small_basic_type) {\n-        \/\/ avoid replication context for small basic types in programmable masked loops\n-        cl->set_slp_max_unroll(local_loop_unroll_factor);\n-      }\n-    }\n+    cl->set_slp_max_unroll(local_loop_unroll_factor);\n@@ -495,1 +470,0 @@\n-  bool post_loop_allowed = (PostLoopMultiversioning && Matcher::has_predicated_vectors() && cl->is_post_loop());\n@@ -556,1 +530,7 @@\n-  } else if (post_loop_allowed) {\n+\n+    \/\/ Record eventual count of vector packs for checks in post loop vectorization\n+    if (PostLoopMultiversioning) {\n+      cl->set_slp_pack_count(_packset.length());\n+    }\n+  } else {\n+    assert(cl->is_rce_post_loop(), \"Must be an rce'd post loop\");\n@@ -2432,1 +2412,0 @@\n-  bool can_process_post_loop = (PostLoopMultiversioning && Matcher::has_predicated_vectors() && cl->is_post_loop());\n@@ -2445,0 +2424,9 @@\n+  Node* vmask = NULL;\n+  if (cl->is_rce_post_loop() && do_reserve_copy()) {\n+    \/\/ Create a vector mask node for post loop, bail out if not created\n+    vmask = create_post_loop_vmask();\n+    if (vmask == NULL) {\n+      return false; \/\/ and reverse to backup IG\n+    }\n+  }\n+\n@@ -2454,1 +2442,1 @@\n-      if (can_process_post_loop) {\n+      if (cl->is_rce_post_loop()) {\n@@ -2479,1 +2467,7 @@\n-        vn = LoadVectorNode::make(opc, ctl, mem, adr, atyp, vlen, velt_basic_type(n), control_dependency(p));\n+        if (cl->is_rce_post_loop()) {\n+          assert(vmask != NULL, \"vector mask should be generated\");\n+          const TypeVect* vt = TypeVect::make(velt_basic_type(n), vlen);\n+          vn = new LoadVectorMaskedNode(ctl, mem, adr, atyp, vt, vmask);\n+        } else {\n+          vn = LoadVectorNode::make(opc, ctl, mem, adr, atyp, vlen, velt_basic_type(n), control_dependency(p));\n+        }\n@@ -2496,1 +2490,7 @@\n-        vn = StoreVectorNode::make(opc, ctl, mem, adr, atyp, val, vlen);\n+        if (cl->is_rce_post_loop()) {\n+          assert(vmask != NULL, \"vector mask should be generated\");\n+          const TypeVect* vt = TypeVect::make(velt_basic_type(n), vlen);\n+          vn = new StoreVectorMaskedNode(ctl, mem, adr, val, atyp, vmask);\n+        } else {\n+          vn = StoreVectorNode::make(opc, ctl, mem, adr, atyp, val, vlen);\n+        }\n@@ -2580,1 +2580,1 @@\n-        if (can_process_post_loop) {\n+        if (cl->is_rce_post_loop()) {\n@@ -2670,8 +2670,0 @@\n-      if (can_process_post_loop) {\n-        \/\/ first check if the vector size if the maximum vector which we can use on the machine,\n-        \/\/ other vector size have reduced values for predicated data mapping.\n-        if (vlen_in_bytes != (uint)MaxVectorSize) {\n-          return false;\n-        }\n-      }\n-\n@@ -2719,19 +2711,2 @@\n-\n-        if (do_reserve_copy()) {\n-          if (can_process_post_loop) {\n-            \/\/ Now create the difference of trip and limit and use it as our mask index.\n-            \/\/ Note: We limited the unroll of the vectorized loop so that\n-            \/\/       only vlen-1 size iterations can remain to be mask programmed.\n-            Node *incr = cl->incr();\n-            SubINode *index = new SubINode(cl->limit(), cl->init_trip());\n-            _igvn.register_new_node_with_optimizer(index);\n-            SetVectMaskINode  *mask = new SetVectMaskINode(_phase->get_ctrl(cl->init_trip()), index);\n-            _igvn.register_new_node_with_optimizer(mask);\n-            \/\/ make this a single iteration loop\n-            AddINode *new_incr = new AddINode(incr->in(1), mask);\n-            _igvn.register_new_node_with_optimizer(new_incr);\n-            _phase->set_ctrl(new_incr, _phase->get_ctrl(incr));\n-            _igvn.replace_node(incr, new_incr);\n-            cl->mark_is_multiversioned();\n-            cl->loopexit()->add_flag(Node::Flag_has_vector_mask_set);\n-          }\n+        if (cl->is_rce_post_loop() && do_reserve_copy()) {\n+          cl->mark_is_multiversioned();\n@@ -2750,0 +2725,101 @@\n+\/\/-------------------------create_post_loop_vmask-------------------------\n+\/\/ Check the post loop vectorizability and create a vector mask if yes.\n+\/\/ Return NULL to bail out if post loop is not vectorizable.\n+Node* SuperWord::create_post_loop_vmask() {\n+  CountedLoopNode *cl = lpt()->_head->as_CountedLoop();\n+  assert(cl->is_rce_post_loop(), \"Must be an rce post loop\");\n+  assert(!cl->is_reduction_loop(), \"no vector reduction in post loop\");\n+  assert(abs(cl->stride_con()) == 1, \"post loop stride can only be +\/-1\");\n+\n+  \/\/ Collect vector element types of all post loop packs. Also collect\n+  \/\/ superword pointers of each memory access operation if the address\n+  \/\/ expression is supported. (Note that vectorizable post loop should\n+  \/\/ only have positive scale in counting-up loop and negative scale in\n+  \/\/ counting-down loop.) Collected SWPointer(s) are also used for data\n+  \/\/ dependence check next.\n+  VectorElementSizeStats stats(_arena);\n+  GrowableArray<SWPointer*> swptrs(_arena, _packset.length(), 0, NULL);\n+  for (int i = 0; i < _packset.length(); i++) {\n+    Node_List* p = _packset.at(i);\n+    assert(p->size() == 1, \"all post loop packs should be singleton\");\n+    Node* n = p->at(0);\n+    BasicType bt = velt_basic_type(n);\n+    if (!is_java_primitive(bt)) {\n+      return NULL;\n+    }\n+    if (n->is_Mem()) {\n+      SWPointer* mem_p = new (_arena) SWPointer(n->as_Mem(), this, NULL, false);\n+      \/\/ For each memory access, we check if the scale (in bytes) in its\n+      \/\/ address expression is equal to the data size times loop stride.\n+      \/\/ With this, Only positive scales exist in counting-up loops and\n+      \/\/ negative scales exist in counting-down loops.\n+      if (mem_p->scale_in_bytes() != type2aelembytes(bt) * cl->stride_con()) {\n+        return NULL;\n+      }\n+      swptrs.append(mem_p);\n+    }\n+    stats.record_size(type2aelembytes(bt));\n+  }\n+\n+  \/\/ Find the vector data type for generating vector masks. Currently we\n+  \/\/ don't support post loops with mixed vector data sizes\n+  int unique_size = stats.unique_size();\n+  BasicType vmask_bt;\n+  switch (unique_size) {\n+    case 1:  vmask_bt = T_BYTE; break;\n+    case 2:  vmask_bt = T_SHORT; break;\n+    case 4:  vmask_bt = T_INT; break;\n+    case 8:  vmask_bt = T_LONG; break;\n+    default: return NULL;\n+  }\n+\n+  \/\/ Currently we can't remove this MaxVectorSize constraint. Without it,\n+  \/\/ it's not guaranteed that the RCE'd post loop runs at most \"vlen - 1\"\n+  \/\/ iterations, because the vector drain loop may not be cloned from the\n+  \/\/ vectorized main loop. We should re-engineer PostLoopMultiversioning\n+  \/\/ to fix this problem.\n+  int vlen = cl->slp_max_unroll();\n+  if (unique_size * vlen != MaxVectorSize) {\n+    return NULL;\n+  }\n+\n+  \/\/ Bail out if target doesn't support mask generator or masked load\/store\n+  if (!Matcher::match_rule_supported_vector(Op_LoadVectorMasked, vlen, vmask_bt)  ||\n+      !Matcher::match_rule_supported_vector(Op_StoreVectorMasked, vlen, vmask_bt) ||\n+      !Matcher::match_rule_supported_vector(Op_VectorMaskGen, vlen, vmask_bt)) {\n+    return NULL;\n+  }\n+\n+  \/\/ Bail out if potential data dependence exists between memory accesses\n+  if (SWPointer::has_potential_dependence(swptrs)) {\n+    return NULL;\n+  }\n+\n+  \/\/ Create vector mask with the post loop trip count. Note there's another\n+  \/\/ vector drain loop which is cloned from main loop before super-unrolling\n+  \/\/ so the scalar post loop runs at most vlen-1 trips. Hence, this version\n+  \/\/ only runs at most 1 iteration after vector mask transformation.\n+  Node* trip_cnt;\n+  Node* new_incr;\n+  if (cl->stride_con() > 0) {\n+    trip_cnt = new SubINode(cl->limit(), cl->init_trip());\n+    new_incr = new AddINode(cl->phi(), trip_cnt);\n+  } else {\n+    trip_cnt = new SubINode(cl->init_trip(), cl->limit());\n+    new_incr = new SubINode(cl->phi(), trip_cnt);\n+  }\n+  _igvn.register_new_node_with_optimizer(trip_cnt);\n+  _igvn.register_new_node_with_optimizer(new_incr);\n+  _igvn.replace_node(cl->incr(), new_incr);\n+  Node* length = new ConvI2LNode(trip_cnt);\n+  _igvn.register_new_node_with_optimizer(length);\n+  Node* vmask = VectorMaskGenNode::make(length, vmask_bt);\n+  _igvn.register_new_node_with_optimizer(vmask);\n+\n+  \/\/ Remove exit test to transform 1-iteration loop to straight-line code.\n+  \/\/ This results in redundant cmp+branch instructions been eliminated.\n+  Node *cl_exit = cl->loopexit();\n+  _igvn.replace_input_of(cl_exit, 1, _igvn.intcon(0));\n+  return vmask;\n+}\n+\n@@ -2758,1 +2834,1 @@\n-  if (PostLoopMultiversioning && Matcher::has_predicated_vectors() && cl->is_post_loop()) {\n+  if (cl->is_rce_post_loop()) {\n@@ -3769,1 +3845,1 @@\n-  if (is_main_loop_member(base)) {\n+  if (is_loop_member(base)) {\n@@ -3798,1 +3874,1 @@\n-  if (is_main_loop_member(adr)) {\n+  if (is_loop_member(adr)) {\n@@ -3829,1 +3905,1 @@\n-bool SWPointer::is_main_loop_member(Node* n) const {\n+bool SWPointer::is_loop_member(Node* n) const {\n@@ -3838,1 +3914,1 @@\n-  bool is_not_member = !is_main_loop_member(n);\n+  bool is_not_member = !is_loop_member(n);\n@@ -3908,1 +3984,1 @@\n-  if (_analyze_only && (is_main_loop_member(n))) {\n+  if (_analyze_only && (is_loop_member(n))) {\n@@ -3991,1 +4067,1 @@\n-  if (_analyze_only && is_main_loop_member(n)) {\n+  if (_analyze_only && is_loop_member(n)) {\n@@ -4025,1 +4101,1 @@\n-  if (!is_main_loop_member(n)) {\n+  if (!is_loop_member(n)) {\n@@ -4032,1 +4108,1 @@\n-      assert(!is_main_loop_member(n), \"sanity\");\n+      assert(!is_loop_member(n), \"sanity\");\n@@ -4048,0 +4124,28 @@\n+\/\/-----------------has_potential_dependence-----------------\n+\/\/ Check potential data dependence among all memory accesses.\n+\/\/ We require every two accesses (with at least one store) of\n+\/\/ the same element type has the same address expression.\n+bool SWPointer::has_potential_dependence(GrowableArray<SWPointer*> swptrs) {\n+  for (int i1 = 0; i1 < swptrs.length(); i1++) {\n+    SWPointer* p1 = swptrs.at(i1);\n+    MemNode* n1 = p1->mem();\n+    BasicType bt1 = n1->memory_type();\n+\n+    \/\/ Iterate over remaining SWPointers\n+    for (int i2 = i1 + 1; i2 < swptrs.length(); i2++) {\n+      SWPointer* p2 = swptrs.at(i2);\n+      MemNode* n2 = p2->mem();\n+      BasicType bt2 = n2->memory_type();\n+\n+      \/\/ Data dependence exists between load-store, store-load\n+      \/\/ or store-store with the same element type or subword\n+      \/\/ size (subword load\/store may have inaccurate type)\n+      if ((n1->is_Store() || n2->is_Store()) &&\n+          same_type_or_subword_size(bt1, bt2) && !p1->equal(*p2)) {\n+        return true;\n+      }\n+    }\n+  }\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":210,"deletions":106,"binary":false,"changes":316,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -247,0 +247,39 @@\n+\/\/ -----------------------VectorElementSizeStats-----------------------\n+\/\/ Vector lane size statistics for loop vectorization with vector masks\n+class VectorElementSizeStats {\n+ private:\n+  static const int NO_SIZE = -1;\n+  static const int MIXED_SIZE = -2;\n+  int* _stats;\n+\n+ public:\n+  VectorElementSizeStats(Arena* a) : _stats(NEW_ARENA_ARRAY(a, int, 4)) {\n+    memset(_stats, 0, sizeof(int) * 4);\n+  }\n+\n+  void record_size(int size) {\n+    assert(1 <= size && size <= 8 && is_power_of_2(size), \"Illegal size\");\n+    _stats[exact_log2(size)]++;\n+  }\n+\n+  int smallest_size() {\n+    for (int i = 0; i <= 3; i++) {\n+      if (_stats[i] > 0) return (1 << i);\n+    }\n+    return NO_SIZE;\n+  }\n+\n+  int largest_size() {\n+    for (int i = 3; i >= 0; i--) {\n+      if (_stats[i] > 0) return (1 << i);\n+    }\n+    return NO_SIZE;\n+  }\n+\n+  int unique_size() {\n+    int small = smallest_size();\n+    int large = largest_size();\n+    return (small == large) ? small : MIXED_SIZE;\n+  }\n+};\n+\n@@ -513,0 +552,2 @@\n+  \/\/ Create vector mask for post loop vectorization\n+  Node* create_post_loop_vmask();\n@@ -575,1 +616,1 @@\n-class SWPointer {\n+class SWPointer : public ResourceObj {\n@@ -597,1 +638,1 @@\n-  bool is_main_loop_member(Node* n) const;\n+  bool is_loop_member(Node* n) const;\n@@ -661,0 +702,2 @@\n+  static bool has_potential_dependence(GrowableArray<SWPointer*> swptrs);\n+\n","filename":"src\/hotspot\/share\/opto\/superword.hpp","additions":46,"deletions":3,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -1299,11 +1299,0 @@\n-\/\/------------------------------SetVectMaskINode-------------------------------\n-\/\/ Provide a mask for a vector predicate machine\n-class SetVectMaskINode : public Node {\n-public:\n-  SetVectMaskINode(Node *c, Node *in1) : Node(c, in1) {}\n-  virtual int Opcode() const;\n-  const Type *bottom_type() const { return TypeInt::INT; }\n-  virtual uint ideal_reg() const { return Op_RegI; }\n-  virtual const Type *Value(PhaseGVN *phase) const { return TypeInt::INT; }\n-};\n-\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1561,1 +1561,0 @@\n-  declare_c2_type(SetVectMaskINode, Node)                                 \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -816,0 +816,3 @@\n+inline bool same_type_or_subword_size(BasicType t1, BasicType t2) {\n+  return (t1 == t2) || (is_subword_type(t1) && type2aelembytes(t1) == type2aelembytes(t2));\n+}\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-    @IR(applyIf = { \"UsePopCountInstruction\", \"true\" }, counts = { IRNode.POPCOUNT_L, \"10\" })\n+    @IR(applyIf = { \"UsePopCountInstruction\", \"true\" }, counts = { IRNode.POPCOUNT_L, \">=10\" })\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestSuperwordFailsUnrolling.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,190 @@\n+\/*\n+ * Copyright (c) 2022, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Vectorization test on array copy\n+ * @library \/test\/lib \/\n+ *\n+ * @build sun.hotspot.WhiteBox\n+ *        compiler.vectorization.runner.VectorizationTestRunner\n+ *\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:.\n+ *                   -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:+WhiteBoxAPI\n+ *                   compiler.vectorization.runner.ArrayCopyTest\n+ *\n+ * @requires vm.compiler2.enabled & vm.flagless\n+ *\/\n+\n+package compiler.vectorization.runner;\n+\n+public class ArrayCopyTest extends VectorizationTestRunner {\n+\n+    private static final int SIZE = 2345;\n+\n+    private   byte[] bytes;\n+    private  short[] shorts;\n+    private   char[] chars;\n+    private    int[] ints;\n+    private   long[] longs;\n+    private  float[] floats;\n+    private double[] doubles;\n+\n+    public ArrayCopyTest() {\n+        bytes   = new   byte[SIZE];\n+        shorts  = new  short[SIZE];\n+        chars   = new   char[SIZE];\n+        ints    = new    int[SIZE];\n+        longs   = new   long[SIZE];\n+        floats  = new  float[SIZE];\n+        doubles = new double[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            bytes[i]   = (byte)  (-i \/ 100);\n+            shorts[i]  = (short) (30 * i - 12345);\n+            chars[i]   = (char)  (i * 55);\n+            ints[i]    = -4444 * i;\n+            longs[i]   = -999999999L * i + 99999999999L;\n+            floats[i]  = (float) (i * 2.3e7f);\n+            doubles[i] = -3e30 * i * i;\n+        }\n+    }\n+\n+    \/\/ ---------------- Simple Copy ----------------\n+    @Test\n+    public byte[] copyByteArray() {\n+        byte[] res = new byte[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = bytes[i];\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public short[] copyShortArray() {\n+        short[] res = new short[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = shorts[i];\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public char[] copyCharArray() {\n+        char[] res = new char[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = chars[i];\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public int[] copyIntArray() {\n+        int[] res = new int[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = ints[i];\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public long[] copyLongArray() {\n+        long[] res = new long[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = longs[i];\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public float[] copyFloatArray() {\n+        float[] res = new float[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = floats[i];\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public double[] copyDoubleArray() {\n+        double[] res = new double[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = doubles[i];\n+        }\n+        return res;\n+    }\n+\n+    \/\/ ---------------- Multiple Copies ----------------\n+    @Test\n+    public float[] chainedCopy() {\n+        float[] res1 = new float[SIZE];\n+        float[] res2 = new float[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res2[i] = res1[i] = floats[i];\n+        }\n+        return res2;\n+    }\n+\n+    @Test\n+    public int[] copy2ArraysSameSize() {\n+        int[] res1 = new int[SIZE];\n+        float[] res2 = new float[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res1[i] = ints[i];\n+            res2[i] = floats[i];\n+        }\n+        return res1;\n+    }\n+\n+    @Test\n+    public double[] copy2ArraysDifferentSizes() {\n+        int[] res1 = new int[SIZE];\n+        double[] res2 = new double[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res1[i] = ints[i];\n+            res2[i] = doubles[i];\n+        }\n+        return res2;\n+    }\n+\n+    \/\/ ---------------- Copy Between Signed & Unsigned ----------------\n+    @Test\n+    public char[] copyFromSignedToUnsigned() {\n+        char[] res = new char[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = (char) shorts[i];\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public short[] copyFromUnsignedToSigned() {\n+        short[] res = new short[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = (short) chars[i];\n+        }\n+        return res;\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/ArrayCopyTest.java","additions":190,"deletions":0,"binary":false,"changes":190,"status":"added"},{"patch":"@@ -0,0 +1,142 @@\n+\/*\n+ * Copyright (c) 2022, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Vectorization test on array index fill\n+ * @library \/test\/lib \/\n+ *\n+ * @build sun.hotspot.WhiteBox\n+ *        compiler.vectorization.runner.VectorizationTestRunner\n+ *\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:.\n+ *                   -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:+WhiteBoxAPI\n+ *                   compiler.vectorization.runner.ArrayIndexFillTest\n+ *\n+ * @requires vm.compiler2.enabled & vm.flagless\n+ *\/\n+\n+package compiler.vectorization.runner;\n+\n+public class ArrayIndexFillTest extends VectorizationTestRunner {\n+\n+    private static final int SIZE = 2345;\n+\n+    private int[] a;\n+\n+    public ArrayIndexFillTest() {\n+        a = new int[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            a[i] = -5050 * i;\n+        }\n+    }\n+\n+    @Test\n+    public byte[] fillByteArray() {\n+        byte[] res = new byte[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = (byte) i;\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public short[] fillShortArray() {\n+        short[] res = new short[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = (short) i;\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public char[] fillCharArray() {\n+        char[] res = new char[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = (char) i;\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public int[] fillIntArray() {\n+        int[] res = new int[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = i;\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public long[] fillLongArray() {\n+        long[] res = new long[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = i;\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public short[] fillShortArrayWithShortIndex() {\n+        short[] res = new short[SIZE];\n+        for (short i = 0; i < SIZE; i++) {\n+            res[i] = i;\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public int[] fillMultipleArraysDifferentTypes1() {\n+        int[] res1 = new int[SIZE];\n+        short[] res2 = new short[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res1[i] = i;\n+            res2[i] = (short) i;\n+        }\n+        return res1;\n+    }\n+\n+    @Test\n+    public char[] fillMultipleArraysDifferentTypes2() {\n+        int[] res1 = new int[SIZE];\n+        char[] res2 = new char[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res1[i] = i;\n+            res2[i] = (char) i;\n+        }\n+        return res2;\n+    }\n+\n+    @Test\n+    public int[] fillNonIndexValue() {\n+        int[] res = new int[SIZE];\n+        int val = 10000;\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = val++;\n+        }\n+        return res;\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/ArrayIndexFillTest.java","additions":142,"deletions":0,"binary":false,"changes":142,"status":"added"},{"patch":"@@ -0,0 +1,164 @@\n+\/*\n+ * Copyright (c) 2022, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Vectorization test on array invariant fill\n+ * @library \/test\/lib \/\n+ *\n+ * @build sun.hotspot.WhiteBox\n+ *        compiler.vectorization.runner.VectorizationTestRunner\n+ *\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:.\n+ *                   -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:+WhiteBoxAPI\n+ *                   -XX:-OptimizeFill\n+ *                   compiler.vectorization.runner.ArrayInvariantFillTest\n+ *\n+ * @requires vm.compiler2.enabled & vm.flagless\n+ *\/\n+\n+package compiler.vectorization.runner;\n+\n+import java.util.Random;\n+\n+public class ArrayInvariantFillTest extends VectorizationTestRunner {\n+\n+    private static final int SIZE = 2345;\n+\n+    private int intInv;\n+    private char charInv;\n+    private float floatInv;\n+    private double doubleInv;\n+\n+    public ArrayInvariantFillTest() {\n+        Random ran = new Random(10);\n+        intInv = ran.nextInt();\n+        charInv = (char) ran.nextInt();\n+        floatInv = ran.nextFloat();\n+        doubleInv = ran.nextDouble();\n+    }\n+\n+    \/\/ ---------------- Simple Fill ----------------\n+    @Test\n+    public byte[] fillByteArray() {\n+        byte[] res = new byte[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = (byte) 10;\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public short[] fillShortArray() {\n+        short[] res = new short[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = (short) -3333;\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public char[] fillCharArray() {\n+        char[] res = new char[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = (char) 55555;\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public int[] fillIntArray() {\n+        int[] res = new int[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = 2147483647;\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public long[] fillLongArray() {\n+        long[] res = new long[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = -2222222222222222L;\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public float[] fillFloatArray() {\n+        float[] res = new float[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = 3.234567e8f;\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public double[] fillDoubleArray() {\n+        double[] res = new double[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = -9.87654321e50;\n+        }\n+        return res;\n+    }\n+\n+    \/\/ ---------------- Fill With Type Change ----------------\n+    @Test\n+    public long[] fillLongArrayWithInt() {\n+        long[] res = new long[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = intInv;\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public long[] fillLongArrayWithUnsigned() {\n+        long[] res = new long[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = charInv;\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public long[] fillLongArrayWithFloat() {\n+        long[] res = new long[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = (long) floatInv;\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public int[] fillIntArrayWithDouble() {\n+        int[] res = new int[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = (int) doubleInv;\n+        }\n+        return res;\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/ArrayInvariantFillTest.java","additions":164,"deletions":0,"binary":false,"changes":164,"status":"added"},{"patch":"@@ -0,0 +1,157 @@\n+\/*\n+ * Copyright (c) 2022, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Vectorization test on bug-prone shift operation\n+ * @library \/test\/lib \/\n+ *\n+ * @build sun.hotspot.WhiteBox\n+ *        compiler.vectorization.runner.VectorizationTestRunner\n+ *\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:.\n+ *                   -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:+WhiteBoxAPI\n+ *                   compiler.vectorization.runner.ArrayShiftOpTest\n+ *\n+ * @requires vm.compiler2.enabled & vm.flagless\n+ *\/\n+\n+package compiler.vectorization.runner;\n+\n+import java.util.Random;\n+\n+public class ArrayShiftOpTest extends VectorizationTestRunner {\n+\n+    private static final int SIZE = 2345;\n+\n+    private int[] ints;\n+    private long[] longs;\n+    private short[] shorts1;\n+    private short[] shorts2;\n+    private int largeDist;\n+\n+    public ArrayShiftOpTest() {\n+        ints = new int[SIZE];\n+        longs = new long[SIZE];\n+        shorts1 = new short[SIZE];\n+        shorts2 = new short[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            ints[i] = -888999 * i;\n+            longs[i] = 999998888800000L * i;\n+            shorts1[i] = (short) (4 * i);\n+            shorts2[i] = (short) (-3 * i);\n+        }\n+        Random ran = new Random(999);\n+        largeDist = 123;\n+    }\n+\n+    @Test\n+    public int[] intCombinedRotateShift() {\n+        int[] res = new int[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = (ints[i] << 14) | (ints[i] >>> 18);\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public long[] longCombinedRotateShift() {\n+        long[] res = new long[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = (longs[i] << 55) | (longs[i] >>> 9);\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public int[] intShiftLargeDistConstant() {\n+        int[] res = new int[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = ints[i] >> 35;\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public int[] intShiftLargeDistInvariant() {\n+        int[] res = new int[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = ints[i] >> largeDist;\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public long[] longShiftLargeDistConstant() {\n+        long[] res = new long[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = longs[i] << 77;\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public long[] longShiftLargeDistInvariant() {\n+        long[] res = new long[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = longs[i] >>> largeDist;\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    \/\/ Note that any shift operation with distance value from another array\n+    \/\/ cannot be vectorized since C2 vector shift node doesn't support it.\n+    public long[] variantShiftDistance() {\n+        long[] res = new long[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = longs[i] >> ints[i];\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    \/\/ Note that unsigned shift right on subword signed integer types can't\n+    \/\/ be vectorized since the sign extension bits would be lost.\n+    public short[] vectorUnsignedShiftRight() {\n+        short[] res = new short[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = (short) (shorts2[i] >>> 3);\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    \/\/ Note that right shift operations on subword expressions cannot be\n+    \/\/ vectorized since precise type info about signness is missing.\n+    public short[] subwordExpressionRightShift() {\n+        short[] res = new short[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = (short) ((shorts1[i] + shorts2[i]) >> 4);\n+        }\n+        return res;\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/ArrayShiftOpTest.java","additions":157,"deletions":0,"binary":false,"changes":157,"status":"added"},{"patch":"@@ -0,0 +1,297 @@\n+\/*\n+ * Copyright (c) 2022, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Vectorization test on array type conversions\n+ * @library \/test\/lib \/\n+ *\n+ * @build sun.hotspot.WhiteBox\n+ *        compiler.vectorization.runner.VectorizationTestRunner\n+ *\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:.\n+ *                   -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:+WhiteBoxAPI\n+ *                   compiler.vectorization.runner.ArrayTypeConvertTest\n+ *\n+ * @requires vm.compiler2.enabled & vm.flagless\n+ *\/\n+\n+package compiler.vectorization.runner;\n+\n+public class ArrayTypeConvertTest extends VectorizationTestRunner {\n+\n+    private static final int SIZE = 2345;\n+\n+    private   byte[] bytes;\n+    private  short[] shorts;\n+    private   char[] chars;\n+    private    int[] ints;\n+    private   long[] longs;\n+    private  float[] floats;\n+    private double[] doubles;\n+\n+    public ArrayTypeConvertTest() {\n+        bytes   = new   byte[SIZE];\n+        shorts  = new  short[SIZE];\n+        chars   = new   char[SIZE];\n+        ints    = new    int[SIZE];\n+        longs   = new   long[SIZE];\n+        floats  = new  float[SIZE];\n+        doubles = new double[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            bytes[i]   = (byte)  (-i \/ 128);\n+            shorts[i]  = (short) (i \/ 3 - 12345);\n+            chars[i]   = (char)  (i * 2);\n+            ints[i]    = -22 * i;\n+            longs[i]   = -258L * i + 99L;\n+            floats[i]  = (float) (i * 2.498f);\n+            doubles[i] = -3 * i;\n+        }\n+    }\n+\n+    \/\/ ---------------- Integer Extension ----------------\n+    @Test\n+    public int[] signExtension() {\n+        int[] res = new int[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = shorts[i];\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public int[] zeroExtension() {\n+        int[] res = new int[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = chars[i];\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public int[] signExtensionFromByte() {\n+        int[] res = new int[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = bytes[i];\n+        }\n+        return res;\n+    }\n+\n+    \/\/ ---------------- Integer Narrow ----------------\n+    @Test\n+    public short[] narrowToSigned() {\n+        short[] res = new short[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = (short) ints[i];\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public char[] narrowToUnsigned() {\n+        char[] res = new char[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = (char) ints[i];\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public byte[] NarrowToByte() {\n+        byte[] res = new byte[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = (byte) ints[i];\n+        }\n+        return res;\n+    }\n+\n+    \/\/ ---------------- Convert I\/L to F\/D ----------------\n+    @Test\n+    public float[] convertIntToFloat() {\n+        float[] res = new float[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = (float) ints[i];\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public double[] convertIntToDouble() {\n+        double[] res = new double[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = (double) ints[i];\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public float[] convertLongToFloat() {\n+        float[] res = new float[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = (float) longs[i];\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public double[] convertLongToDouble() {\n+        double[] res = new double[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = (double) longs[i];\n+        }\n+        return res;\n+    }\n+\n+    \/\/ ---------------- Convert Subword-I to F\/D ----------------\n+    @Test\n+    public float[] convertShortToFloat() {\n+        float[] res = new float[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = (float) shorts[i];\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public double[] convertShortToDouble() {\n+        double[] res = new double[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = (double) shorts[i];\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public float[] convertCharToFloat() {\n+        float[] res = new float[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = (float) chars[i];\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public double[] convertCharToDouble() {\n+        double[] res = new double[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = (double) chars[i];\n+        }\n+        return res;\n+    }\n+\n+    \/\/ ---------------- Convert F\/D to I\/L ----------------\n+    @Test\n+    public int[] convertFloatToInt() {\n+        int[] res = new int[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = (int) floats[i];\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public long[] convertFloatToLong() {\n+        long[] res = new long[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = (long) floats[i];\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public int[] convertDoubleToInt() {\n+        int[] res = new int[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = (int) doubles[i];\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public long[] convertDoubleToLong() {\n+        long[] res = new long[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = (long) doubles[i];\n+        }\n+        return res;\n+    }\n+\n+    \/\/ ---------------- Convert F\/D to Subword-I ----------------\n+    @Test\n+    public short[] convertFloatToShort() {\n+        short[] res = new short[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = (short) floats[i];\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public char[] convertFloatToChar() {\n+        char[] res = new char[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = (char) floats[i];\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public short[] convertDoubleToShort() {\n+        short[] res = new short[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = (short) doubles[i];\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public char[] convertDoubleToChar() {\n+        char[] res = new char[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = (char) doubles[i];\n+        }\n+        return res;\n+    }\n+\n+    \/\/ ---------------- Convert Between F & D ----------------\n+    @Test\n+    public double[] convertFloatToDouble() {\n+        double[] res = new double[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = (double) floats[i];\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public float[] convertDoubleToFloat() {\n+        float[] res = new float[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = (float) doubles[i];\n+        }\n+        return res;\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/ArrayTypeConvertTest.java","additions":297,"deletions":0,"binary":false,"changes":297,"status":"added"},{"patch":"@@ -0,0 +1,103 @@\n+\/*\n+ * Copyright (c) 2022, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Vectorization test on array unsafe operations\n+ * @library \/test\/lib \/\n+ *\n+ * @build sun.hotspot.WhiteBox\n+ *        compiler.vectorization.runner.VectorizationTestRunner\n+ *\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:.\n+ *                   -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:+WhiteBoxAPI\n+ *                   compiler.vectorization.runner.ArrayUnsafeOpTest\n+ *\n+ * @requires vm.compiler2.enabled & vm.flagless\n+ *\/\n+\n+package compiler.vectorization.runner;\n+\n+import java.lang.reflect.Field;\n+\n+import sun.misc.Unsafe;\n+\n+public class ArrayUnsafeOpTest extends VectorizationTestRunner {\n+\n+    private static final int SIZE = 2345;\n+\n+    private static Unsafe unsafe;\n+\n+    public ArrayUnsafeOpTest() throws Exception {\n+        Class klass = Unsafe.class;\n+        Field field = klass.getDeclaredField(\"theUnsafe\");\n+        field.setAccessible(true);\n+        unsafe = (Unsafe) field.get(null);\n+    }\n+\n+    @Test\n+    public byte[] arrayUnsafeFill() {\n+        byte[] res = new byte[SIZE];\n+        for (int i = 0; i < 500; i++) {\n+            unsafe.putByte(res, i + 24, (byte) i);\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public byte[] arrayUnsafeFillWithOneAddp() {\n+        byte[] res = new byte[SIZE];\n+        for (int i = 123; i < 500; i++) {\n+            unsafe.putByte(res, i, (byte) i);\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    \/\/ Note that this case cannot be vectorized since data dependence\n+    \/\/ exists between two unsafe stores of different types on the same\n+    \/\/ array reference.\n+    public int[] arrayUnsafeFillTypeMismatch() {\n+        int[] res = new int[SIZE];\n+        for (int i = 0; i < 500; i++) {\n+            unsafe.putByte(res, i + 24, (byte) i);\n+            unsafe.putShort(res, i + 28, (short) 0);\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    \/\/ Note that this case cannot be vectorized since data dependence\n+    \/\/ exists between adjacent iterations. (The memory address storing\n+    \/\/ an int array is not increased by 4 per iteration.)\n+    public int[] arrayUnsafeFillAddrIncrMismatch() {\n+        int[] res = new int[SIZE];\n+        for (int i = 0; i < 500; i++) {\n+            unsafe.putInt(res, i + 24, i);\n+        }\n+        return res;\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/ArrayUnsafeOpTest.java","additions":103,"deletions":0,"binary":false,"changes":103,"status":"added"},{"patch":"@@ -0,0 +1,98 @@\n+\/*\n+ * Copyright (c) 2022, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Vectorization test on basic boolean operations\n+ * @library \/test\/lib \/\n+ *\n+ * @build sun.hotspot.WhiteBox\n+ *        compiler.vectorization.runner.VectorizationTestRunner\n+ *\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:.\n+ *                   -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:+WhiteBoxAPI\n+ *                   compiler.vectorization.runner.BasicBooleanOpTest\n+ *\n+ * @requires vm.compiler2.enabled & vm.flagless\n+ *\/\n+\n+package compiler.vectorization.runner;\n+\n+public class BasicBooleanOpTest extends VectorizationTestRunner {\n+\n+    private static final int SIZE = 2345;\n+\n+    private boolean[] a;\n+    private boolean[] b;\n+    private boolean[] c;\n+\n+    public BasicBooleanOpTest() {\n+        a = new boolean[SIZE];\n+        b = new boolean[SIZE];\n+        c = new boolean[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            a[i] = true;\n+            b[i] = false;\n+        }\n+    }\n+\n+    \/\/ ---------------- Logic ----------------\n+    @Test\n+    public boolean[] vectorNot() {\n+        boolean[] res = new boolean[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = !a[i];\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public boolean[] vectorAnd() {\n+        boolean[] res = new boolean[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = a[i] & b[i];\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public boolean[] vectorOr() {\n+        boolean[] res = new boolean[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = a[i] | b[i];\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public boolean[] vectorXor() {\n+        boolean[] res = new boolean[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = a[i] ^ b[i];\n+        }\n+        return res;\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/BasicBooleanOpTest.java","additions":98,"deletions":0,"binary":false,"changes":98,"status":"added"},{"patch":"@@ -0,0 +1,193 @@\n+\/*\n+ * Copyright (c) 2022, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Vectorization test on basic byte operations\n+ * @library \/test\/lib \/\n+ *\n+ * @build sun.hotspot.WhiteBox\n+ *        compiler.vectorization.runner.VectorizationTestRunner\n+ *\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:.\n+ *                   -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:+WhiteBoxAPI\n+ *                   compiler.vectorization.runner.BasicByteOpTest\n+ *\n+ * @requires vm.compiler2.enabled & vm.flagless\n+ *\/\n+\n+package compiler.vectorization.runner;\n+\n+public class BasicByteOpTest extends VectorizationTestRunner {\n+\n+    private static final int SIZE = 2345;\n+\n+    private byte[] a;\n+    private byte[] b;\n+    private byte[] c;\n+\n+    public BasicByteOpTest() {\n+        a = new byte[SIZE];\n+        b = new byte[SIZE];\n+        c = new byte[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            a[i] = (byte) (-3 * i);\n+            b[i] = (byte) (i + 4);\n+            c[i] = (byte) -90;\n+        }\n+    }\n+\n+    \/\/ ---------------- Arithmetic ----------------\n+    @Test\n+    public byte[] vectorNeg() {\n+        byte[] res = new byte[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = (byte) -a[i];\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public byte[] vectorAbs() {\n+        byte[] res = new byte[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = (byte) Math.abs(a[i]);\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public byte[] vectorAdd() {\n+        byte[] res = new byte[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = (byte) (a[i] + b[i]);\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public byte[] vectorSub() {\n+        byte[] res = new byte[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = (byte) (a[i] - b[i]);\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public byte[] vectorMul() {\n+        byte[] res = new byte[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = (byte) (a[i] * b[i]);\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public byte[] vectorMulAdd() {\n+        byte[] res = new byte[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = (byte) (c[i] + a[i] * b[i]);\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public byte[] vectorMulSub() {\n+        byte[] res = new byte[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = (byte) (c[i] - a[i] * b[i]);\n+        }\n+        return res;\n+    }\n+\n+    \/\/ ---------------- Logic ----------------\n+    @Test\n+    public byte[] vectorNot() {\n+        byte[] res = new byte[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = (byte) ~a[i];\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public byte[] vectorAnd() {\n+        byte[] res = new byte[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = (byte) (a[i] & b[i]);\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public byte[] vectorOr() {\n+        byte[] res = new byte[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = (byte) (a[i] | b[i]);\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public byte[] vectorXor() {\n+        byte[] res = new byte[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = (byte) (a[i] ^ b[i]);\n+        }\n+        return res;\n+    }\n+\n+    \/\/ ---------------- Shift ----------------\n+    @Test\n+    public byte[] vectorShiftLeft() {\n+        byte[] res = new byte[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = (byte) (a[i] << 3);\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public byte[] vectorSignedShiftRight() {\n+        byte[] res = new byte[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = (byte) (a[i] >> 2);\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    \/\/ Note that unsigned shift right on subword signed integer types can\n+    \/\/ not be vectorized since the sign extension bit would be lost.\n+    public byte[] vectorUnsignedShiftRight() {\n+        byte[] res = new byte[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = (byte) (a[i] >>> 5);\n+        }\n+        return res;\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/BasicByteOpTest.java","additions":193,"deletions":0,"binary":false,"changes":193,"status":"added"},{"patch":"@@ -0,0 +1,193 @@\n+\/*\n+ * Copyright (c) 2022, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Vectorization test on basic char operations\n+ * @library \/test\/lib \/\n+ *\n+ * @build sun.hotspot.WhiteBox\n+ *        compiler.vectorization.runner.VectorizationTestRunner\n+ *\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:.\n+ *                   -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:+WhiteBoxAPI\n+ *                   compiler.vectorization.runner.BasicCharOpTest\n+ *\n+ * @requires vm.compiler2.enabled & vm.flagless\n+ *\/\n+\n+package compiler.vectorization.runner;\n+\n+public class BasicCharOpTest extends VectorizationTestRunner {\n+\n+    private static final int SIZE = 2345;\n+\n+    private char[] a;\n+    private char[] b;\n+    private char[] c;\n+\n+    public BasicCharOpTest() {\n+        a = new char[SIZE];\n+        b = new char[SIZE];\n+        c = new char[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            a[i] = (char) (20 * i);\n+            b[i] = (char) (i + 44444);\n+            c[i] = (char) 10000;\n+        }\n+    }\n+\n+    \/\/ ---------------- Arithmetic ----------------\n+    @Test\n+    public char[] vectorNeg() {\n+        char[] res = new char[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = (char) -a[i];\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    \/\/ Note that Math.abs() on unsigned subword types can NOT be vectorized\n+    \/\/ since all the values are non-negative according to the semantics.\n+    public char[] vectorAbs() {\n+        char[] res = new char[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = (char) Math.abs(a[i]);\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public char[] vectorAdd() {\n+        char[] res = new char[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = (char) (a[i] + b[i]);\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public char[] vectorSub() {\n+        char[] res = new char[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = (char) (a[i] - b[i]);\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public char[] vectorMul() {\n+        char[] res = new char[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = (char) (a[i] * b[i]);\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public char[] vectorMulAdd() {\n+        char[] res = new char[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = (char) (c[i] + a[i] * b[i]);\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public char[] vectorMulSub() {\n+        char[] res = new char[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = (char) (c[i] - a[i] * b[i]);\n+        }\n+        return res;\n+    }\n+\n+    \/\/ ---------------- Logic ----------------\n+    @Test\n+    public char[] vectorNot() {\n+        char[] res = new char[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = (char) ~a[i];\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public char[] vectorAnd() {\n+        char[] res = new char[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = (char) (a[i] & b[i]);\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public char[] vectorOr() {\n+        char[] res = new char[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = (char) (a[i] | b[i]);\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public char[] vectorXor() {\n+        char[] res = new char[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = (char) (a[i] ^ b[i]);\n+        }\n+        return res;\n+    }\n+\n+    \/\/ ---------------- Shift ----------------\n+    @Test\n+    public char[] vectorShiftLeft() {\n+        char[] res = new char[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = (char) (a[i] << 3);\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public char[] vectorSignedShiftRight() {\n+        char[] res = new char[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = (char) (a[i] >> 2);\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public char[] vectorUnsignedShiftRight() {\n+        char[] res = new char[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = (char) (a[i] >>> 5);\n+        }\n+        return res;\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/BasicCharOpTest.java","additions":193,"deletions":0,"binary":false,"changes":193,"status":"added"},{"patch":"@@ -0,0 +1,253 @@\n+\/*\n+ * Copyright (c) 2022, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Vectorization test on basic double operations\n+ * @library \/test\/lib \/\n+ *\n+ * @build sun.hotspot.WhiteBox\n+ *        compiler.vectorization.runner.VectorizationTestRunner\n+ *\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:.\n+ *                   -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:+WhiteBoxAPI\n+ *                   compiler.vectorization.runner.BasicDoubleOpTest\n+ *\n+ * @requires vm.compiler2.enabled & vm.flagless\n+ *\/\n+\n+package compiler.vectorization.runner;\n+\n+public class BasicDoubleOpTest extends VectorizationTestRunner {\n+\n+    private static final int SIZE = 2345;\n+\n+    private double[] a;\n+    private double[] b;\n+    private double[] c;\n+\n+    public BasicDoubleOpTest() {\n+        a = new double[SIZE];\n+        b = new double[SIZE];\n+        c = new double[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            a[i] = 850.0 * i + 22222.22;\n+            b[i] = -12345.678;\n+            c[i] = -1.23456e7;\n+        }\n+    }\n+\n+    \/\/ ---------------- Arithmetic ----------------\n+    @Test\n+    public double[] vectorNeg() {\n+        double[] res = new double[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = -a[i];\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public double[] vectorAbs() {\n+        double[] res = new double[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = Math.abs(a[i]);\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public double[] vectorSqrt() {\n+        double[] res = new double[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = Math.sqrt(a[i]);\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public double[] vectorCeil() {\n+        double[] res = new double[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = Math.ceil(a[i]);\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public double[] vectorFloor() {\n+        double[] res = new double[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = Math.floor(a[i]);\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public double[] vectorRint() {\n+        double[] res = new double[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = Math.rint(a[i]);\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public double[] vectorAdd() {\n+        double[] res = new double[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = a[i] + b[i];\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public double[] vectorSub() {\n+        double[] res = new double[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = a[i] - b[i];\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public double[] vectorMul() {\n+        double[] res = new double[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = a[i] * b[i];\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public double[] vectorDiv() {\n+        double[] res = new double[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = a[i] \/ b[i];\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public double[] vectorMax() {\n+        double[] res = new double[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = Math.max(a[i], b[i]);\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public double[] vectorMin() {\n+        double[] res = new double[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = Math.min(a[i], b[i]);\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public double[] vectorMulAdd() {\n+        double[] res = new double[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = Math.fma(a[i], b[i], c[i]);\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public double[] vectorMulSub1() {\n+        double[] res = new double[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = Math.fma(-a[i], b[i], c[i]);\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public double[] vectorMulSub2() {\n+        double[] res = new double[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = Math.fma(a[i], -b[i], c[i]);\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public double[] vectorNegateMulAdd1() {\n+        double[] res = new double[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = Math.fma(-a[i], b[i], -c[i]);\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public double[] vectorNegateMulAdd2() {\n+        double[] res = new double[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = Math.fma(a[i], -b[i], -c[i]);\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public double[] vectorNegateMulSub() {\n+        double[] res = new double[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = Math.fma(a[i], b[i], -c[i]);\n+        }\n+        return res;\n+    }\n+\n+    \/\/ ---------------- Reduction ----------------\n+    @Test\n+    public double reductionAdd() {\n+        double res = 0.0;\n+        for (int i = 0; i < SIZE; i++) {\n+            res += a[i];\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public double reductionMax() {\n+        double res = Double.MIN_VALUE;\n+        for (int i = 0; i < SIZE; i++) {\n+            res = Math.max(res, a[i]);\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public double reductionMin() {\n+        double res = Double.MAX_VALUE;\n+        for (int i = 0; i < SIZE; i++) {\n+            res = Math.min(res, a[i]);\n+        }\n+        return res;\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/BasicDoubleOpTest.java","additions":253,"deletions":0,"binary":false,"changes":253,"status":"added"},{"patch":"@@ -0,0 +1,226 @@\n+\/*\n+ * Copyright (c) 2022, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Vectorization test on basic float operations\n+ * @library \/test\/lib \/\n+ *\n+ * @build sun.hotspot.WhiteBox\n+ *        compiler.vectorization.runner.VectorizationTestRunner\n+ *\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:.\n+ *                   -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:+WhiteBoxAPI\n+ *                   compiler.vectorization.runner.BasicFloatOpTest\n+ *\n+ * @requires vm.compiler2.enabled & vm.flagless\n+ *\/\n+\n+package compiler.vectorization.runner;\n+\n+public class BasicFloatOpTest extends VectorizationTestRunner {\n+\n+    private static final int SIZE = 2345;\n+\n+    private float[] a;\n+    private float[] b;\n+    private float[] c;\n+\n+    public BasicFloatOpTest() {\n+        a = new float[SIZE];\n+        b = new float[SIZE];\n+        c = new float[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            a[i] = 850.0f * i + 22222.22f;\n+            b[i] = -12345.678f;\n+            c[i] = -1.23456e7f;\n+        }\n+    }\n+\n+    \/\/ ---------------- Arithmetic ----------------\n+    @Test\n+    public float[] vectorNeg() {\n+        float[] res = new float[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = -a[i];\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public float[] vectorAbs() {\n+        float[] res = new float[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = Math.abs(a[i]);\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public float[] vectorSqrt() {\n+        float[] res = new float[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = (float) Math.sqrt(a[i]);\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public float[] vectorAdd() {\n+        float[] res = new float[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = a[i] + b[i];\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public float[] vectorSub() {\n+        float[] res = new float[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = a[i] - b[i];\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public float[] vectorMul() {\n+        float[] res = new float[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = a[i] * b[i];\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public float[] vectorDiv() {\n+        float[] res = new float[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = a[i] \/ b[i];\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public float[] vectorMax() {\n+        float[] res = new float[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = Math.max(a[i], b[i]);\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public float[] vectorMin() {\n+        float[] res = new float[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = Math.min(a[i], b[i]);\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public float[] vectorMulAdd() {\n+        float[] res = new float[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = Math.fma(a[i], b[i], c[i]);\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public float[] vectorMulSub1() {\n+        float[] res = new float[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = Math.fma(-a[i], b[i], c[i]);\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public float[] vectorMulSub2() {\n+        float[] res = new float[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = Math.fma(a[i], -b[i], c[i]);\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public float[] vectorNegateMulAdd1() {\n+        float[] res = new float[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = Math.fma(-a[i], b[i], -c[i]);\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public float[] vectorNegateMulAdd2() {\n+        float[] res = new float[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = Math.fma(a[i], -b[i], -c[i]);\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public float[] vectorNegateMulSub() {\n+        float[] res = new float[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = Math.fma(a[i], b[i], -c[i]);\n+        }\n+        return res;\n+    }\n+\n+    \/\/ ---------------- Reduction ----------------\n+    @Test\n+    public float reductionAdd() {\n+        float res = 0.0f;\n+        for (int i = 0; i < SIZE; i++) {\n+            res += a[i];\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public float reductionMax() {\n+        float res = Float.MIN_VALUE;\n+        for (int i = 0; i < SIZE; i++) {\n+            res = Math.max(res, a[i]);\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public float reductionMin() {\n+        float res = Float.MAX_VALUE;\n+        for (int i = 0; i < SIZE; i++) {\n+            res = Math.min(res, a[i]);\n+        }\n+        return res;\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/BasicFloatOpTest.java","additions":226,"deletions":0,"binary":false,"changes":226,"status":"added"},{"patch":"@@ -0,0 +1,255 @@\n+\/*\n+ * Copyright (c) 2022, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Vectorization test on basic int operations\n+ * @library \/test\/lib \/\n+ *\n+ * @build sun.hotspot.WhiteBox\n+ *        compiler.vectorization.runner.VectorizationTestRunner\n+ *\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:.\n+ *                   -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:+WhiteBoxAPI\n+ *                   compiler.vectorization.runner.BasicIntOpTest\n+ *\n+ * @requires vm.compiler2.enabled & vm.flagless\n+ *\/\n+\n+package compiler.vectorization.runner;\n+\n+public class BasicIntOpTest extends VectorizationTestRunner {\n+\n+    private static final int SIZE = 2345;\n+\n+    private int[] a;\n+    private int[] b;\n+    private int[] c;\n+\n+    public BasicIntOpTest() {\n+        a = new int[SIZE];\n+        b = new int[SIZE];\n+        c = new int[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            a[i] = -25 * i;\n+            b[i] = 333 * i + 9999;\n+            c[i] = -987654321;\n+        }\n+    }\n+\n+    \/\/ ---------------- Arithmetic ----------------\n+    @Test\n+    public int[] vectorNeg() {\n+        int[] res = new int[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = -a[i];\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public int[] vectorAbs() {\n+        int[] res = new int[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = Math.abs(a[i]);\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public int[] vectorAdd() {\n+        int[] res = new int[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = a[i] + b[i];\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public int[] vectorSub() {\n+        int[] res = new int[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = a[i] - b[i];\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public int[] vectorMul() {\n+        int[] res = new int[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = a[i] * b[i];\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public int[] vectorMulAdd() {\n+        int[] res = new int[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = c[i] + a[i] * b[i];\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public int[] vectorMulSub() {\n+        int[] res = new int[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = c[i] - a[i] * b[i];\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public int[] vectorPopCount() {\n+        int[] res = new int[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = Integer.bitCount(a[i]);\n+        }\n+        return res;\n+    }\n+\n+    \/\/ ---------------- Logic ----------------\n+    @Test\n+    public int[] vectorNot() {\n+        int[] res = new int[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = ~a[i];\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public int[] vectorAnd() {\n+        int[] res = new int[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = a[i] & b[i];\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public int[] vectorOr() {\n+        int[] res = new int[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = a[i] | b[i];\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public int[] vectorXor() {\n+        int[] res = new int[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = a[i] ^ b[i];\n+        }\n+        return res;\n+    }\n+\n+    \/\/ ---------------- Shift ----------------\n+    @Test\n+    public int[] vectorShiftLeft() {\n+        int[] res = new int[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = a[i] << 3;\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public int[] vectorSignedShiftRight() {\n+        int[] res = new int[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = a[i] >> 2;\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public int[] vectorUnsignedShiftRight() {\n+        int[] res = new int[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = a[i] >>> 5;\n+        }\n+        return res;\n+    }\n+\n+    \/\/ ---------------- Reduction ----------------\n+    @Test\n+    public int reductionAdd() {\n+        int res = 0;\n+        for (int i = 0; i < SIZE; i++) {\n+            res += a[i];\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public int reductionAnd() {\n+        int res = 0xffffffff;\n+        for (int i = 0; i < SIZE; i++) {\n+            res &= a[i];\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public int reductionOr() {\n+        int res = 0;\n+        for (int i = 0; i < SIZE; i++) {\n+            res |= a[i];\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public int reductionXor() {\n+        int res = 0x0f0f0f0f;\n+        for (int i = 0; i < SIZE; i++) {\n+            res ^= a[i];\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public int reductionMax() {\n+        int res = Integer.MIN_VALUE;\n+        for (int i = 0; i < SIZE; i++) {\n+            res = Math.max(res, a[i]);\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public int reductionMin() {\n+        int res = Integer.MAX_VALUE;\n+        for (int i = 0; i < SIZE; i++) {\n+            res = Math.min(res, a[i]);\n+        }\n+        return res;\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/BasicIntOpTest.java","additions":255,"deletions":0,"binary":false,"changes":255,"status":"added"},{"patch":"@@ -0,0 +1,246 @@\n+\/*\n+ * Copyright (c) 2022, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Vectorization test on basic long operations\n+ * @library \/test\/lib \/\n+ *\n+ * @build sun.hotspot.WhiteBox\n+ *        compiler.vectorization.runner.VectorizationTestRunner\n+ *\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:.\n+ *                   -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:+WhiteBoxAPI\n+ *                   compiler.vectorization.runner.BasicLongOpTest\n+ *\n+ * @requires vm.compiler2.enabled & vm.flagless\n+ *\/\n+\n+package compiler.vectorization.runner;\n+\n+public class BasicLongOpTest extends VectorizationTestRunner {\n+\n+    private static final int SIZE = 2345;\n+\n+    private long[] a;\n+    private long[] b;\n+    private long[] c;\n+\n+    public BasicLongOpTest() {\n+        a = new long[SIZE];\n+        b = new long[SIZE];\n+        c = new long[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            a[i] = -123456789L * i;\n+            b[i] = 66666666L * i + 8888888888888888888L;\n+            c[i] = -987654321098765L;\n+        }\n+    }\n+\n+    \/\/ ---------------- Arithmetic ----------------\n+    @Test\n+    public long[] vectorNeg() {\n+        long[] res = new long[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = -a[i];\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public long[] vectorAbs() {\n+        long[] res = new long[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = Math.abs(a[i]);\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public long[] vectorAdd() {\n+        long[] res = new long[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = a[i] + b[i];\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public long[] vectorSub() {\n+        long[] res = new long[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = a[i] - b[i];\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public long[] vectorMul() {\n+        long[] res = new long[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = a[i] * b[i];\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public long[] vectorMulAdd() {\n+        long[] res = new long[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = c[i] + a[i] * b[i];\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public long[] vectorMulSub() {\n+        long[] res = new long[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = c[i] - a[i] * b[i];\n+        }\n+        return res;\n+    }\n+\n+    \/\/ ---------------- Logic ----------------\n+    @Test\n+    public long[] vectorNot() {\n+        long[] res = new long[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = ~a[i];\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public long[] vectorAnd() {\n+        long[] res = new long[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = a[i] & b[i];\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public long[] vectorOr() {\n+        long[] res = new long[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = a[i] | b[i];\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public long[] vectorXor() {\n+        long[] res = new long[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = a[i] ^ b[i];\n+        }\n+        return res;\n+    }\n+\n+    \/\/ ---------------- Shift ----------------\n+    @Test\n+    public long[] vectorShiftLeft() {\n+        long[] res = new long[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = a[i] << 3;\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public long[] vectorSignedShiftRight() {\n+        long[] res = new long[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = a[i] >> 2;\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public long[] vectorUnsignedShiftRight() {\n+        long[] res = new long[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = a[i] >>> 5;\n+        }\n+        return res;\n+    }\n+\n+    \/\/ ---------------- Reduction ----------------\n+    @Test\n+    public long reductionAdd() {\n+        long res = 0L;\n+        for (int i = 0; i < SIZE; i++) {\n+            res += a[i];\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public long reductionAnd() {\n+        long res = 0xffffffffffffffffL;\n+        for (int i = 0; i < SIZE; i++) {\n+            res &= a[i];\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public long reductionOr() {\n+        long res = 0L;\n+        for (int i = 0; i < SIZE; i++) {\n+            res |= a[i];\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public long reductionXor() {\n+        long res = 0xf0f0f0f0f0f0f0f0L;\n+        for (int i = 0; i < SIZE; i++) {\n+            res ^= a[i];\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public long reductionMax() {\n+        long res = Long.MIN_VALUE;\n+        for (int i = 0; i < SIZE; i++) {\n+            res = Math.max(res, a[i]);\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public long reductionMin() {\n+        long res = Long.MAX_VALUE;\n+        for (int i = 0; i < SIZE; i++) {\n+            res = Math.min(res, a[i]);\n+        }\n+        return res;\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/BasicLongOpTest.java","additions":246,"deletions":0,"binary":false,"changes":246,"status":"added"},{"patch":"@@ -0,0 +1,193 @@\n+\/*\n+ * Copyright (c) 2022, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Vectorization test on basic short operations\n+ * @library \/test\/lib \/\n+ *\n+ * @build sun.hotspot.WhiteBox\n+ *        compiler.vectorization.runner.VectorizationTestRunner\n+ *\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:.\n+ *                   -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:+WhiteBoxAPI\n+ *                   compiler.vectorization.runner.BasicShortOpTest\n+ *\n+ * @requires vm.compiler2.enabled & vm.flagless\n+ *\/\n+\n+package compiler.vectorization.runner;\n+\n+public class BasicShortOpTest extends VectorizationTestRunner {\n+\n+    private static final int SIZE = 2345;\n+\n+    private short[] a;\n+    private short[] b;\n+    private short[] c;\n+\n+    public BasicShortOpTest() {\n+        a = new short[SIZE];\n+        b = new short[SIZE];\n+        c = new short[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            a[i] = (short) (-12 * i);\n+            b[i] = (short) (9 * i + 8888);\n+            c[i] = (short) -32323;\n+        }\n+    }\n+\n+    \/\/ ---------------- Arithmetic ----------------\n+    @Test\n+    public short[] vectorNeg() {\n+        short[] res = new short[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = (short) -a[i];\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public short[] vectorAbs() {\n+        short[] res = new short[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = (short) Math.abs(a[i]);\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public short[] vectorAdd() {\n+        short[] res = new short[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = (short) (a[i] + b[i]);\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public short[] vectorSub() {\n+        short[] res = new short[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = (short) (a[i] - b[i]);\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public short[] vectorMul() {\n+        short[] res = new short[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = (short) (a[i] * b[i]);\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public short[] vectorMulAdd() {\n+        short[] res = new short[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = (short) (c[i] + a[i] * b[i]);\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public short[] vectorMulSub() {\n+        short[] res = new short[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = (short) (c[i] - a[i] * b[i]);\n+        }\n+        return res;\n+    }\n+\n+    \/\/ ---------------- Logic ----------------\n+    @Test\n+    public short[] vectorNot() {\n+        short[] res = new short[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = (short) ~a[i];\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public short[] vectorAnd() {\n+        short[] res = new short[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = (short) (a[i] & b[i]);\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public short[] vectorOr() {\n+        short[] res = new short[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = (short) (a[i] | b[i]);\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public short[] vectorXor() {\n+        short[] res = new short[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = (short) (a[i] ^ b[i]);\n+        }\n+        return res;\n+    }\n+\n+    \/\/ ---------------- Shift ----------------\n+    @Test\n+    public short[] vectorShiftLeft() {\n+        short[] res = new short[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = (short) (a[i] << 3);\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public short[] vectorSignedShiftRight() {\n+        short[] res = new short[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = (short) (a[i] >> 2);\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    \/\/ Note that unsigned shift right on subword signed integer types can\n+    \/\/ not be vectorized since the sign extension bits would be lost.\n+    public short[] vectorUnsignedShiftRight() {\n+        short[] res = new short[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = (short) (a[i] >>> 5);\n+        }\n+        return res;\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/BasicShortOpTest.java","additions":193,"deletions":0,"binary":false,"changes":193,"status":"added"},{"patch":"@@ -0,0 +1,287 @@\n+\/*\n+ * Copyright (c) 2022, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Vectorization test on loop array index computation\n+ * @library \/test\/lib \/\n+ *\n+ * @build sun.hotspot.WhiteBox\n+ *        compiler.vectorization.runner.VectorizationTestRunner\n+ *\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:.\n+ *                   -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:+WhiteBoxAPI\n+ *                   compiler.vectorization.runner.LoopArrayIndexComputeTest\n+ *\n+ * @requires vm.compiler2.enabled & vm.flagless\n+ *\/\n+\n+package compiler.vectorization.runner;\n+\n+import java.util.Random;\n+\n+public class LoopArrayIndexComputeTest extends VectorizationTestRunner {\n+\n+    private static final int SIZE = 2345;\n+\n+    private int[] ints;\n+    private short[] shorts;\n+    private char[] chars;\n+    private byte[] bytes;\n+    private boolean[] booleans;\n+\n+    private int inv1;\n+    private int inv2;\n+\n+    public LoopArrayIndexComputeTest() {\n+        ints = new int[SIZE];\n+        shorts = new short[SIZE];\n+        chars = new char[SIZE];\n+        bytes = new byte[SIZE];\n+        booleans = new boolean[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            ints[i] = 499 * i;\n+            shorts[i] = (short) (-13 * i + 5);\n+            chars[i] = (char) (i << 3);\n+            bytes[i] = (byte) (i >> 2 + 3);\n+            booleans[i] = (i % 5 == 0);\n+        }\n+        Random ran = new Random(10);\n+        inv1 = Math.abs(ran.nextInt() % 10) + 1;\n+        inv2 = Math.abs(ran.nextInt() % 10) + 1;\n+    }\n+\n+    \/\/ ---------------- Linear Indexes ----------------\n+    @Test\n+    public int[] indexPlusConstant() {\n+        int[] res = new int[SIZE];\n+        for (int i = 0; i < SIZE \/ 2; i++) {\n+            res[i + 1] = ints[i + 1] + 999;\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public int[] indexMinusConstant() {\n+        int[] res = new int[SIZE];\n+        for (int i = SIZE \/ 2; i < SIZE; i++) {\n+            res[i - 49] = ints[i - 49] * i;\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public int[] indexPlusInvariant() {\n+        int[] res = new int[SIZE];\n+        System.arraycopy(ints, 0, res, 0, SIZE);\n+        for (int i = 0; i < SIZE \/ 4; i++) {\n+            res[i + inv1] *= ints[i + inv1];\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public int[] indexMinusInvariant() {\n+        int[] res = new int[SIZE];\n+        System.arraycopy(ints, 0, res, 0, SIZE);\n+        for (int i = SIZE \/ 3; i < SIZE \/ 2; i++) {\n+            res[i - inv2] *= (ints[i - inv2] + (i >> 2));\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public int[] indexWithInvariantAndConstant() {\n+        int[] res = new int[SIZE];\n+        System.arraycopy(ints, 0, res, 0, SIZE);\n+        for (int i = 10; i < SIZE \/ 4; i++) {\n+            res[i + inv1 - 1] *= (ints[i + inv1 - 1] + 1);\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public int[] indexWithTwoInvariants() {\n+        int[] res = new int[SIZE];\n+        System.arraycopy(ints, 0, res, 0, SIZE);\n+        for (int i = 10; i < SIZE \/ 4; i++) {\n+            res[i + inv1 + inv2] -= ints[i + inv1 + inv2];\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    \/\/ Note that this case cannot be vectorized due to data dependence\n+    public int[] indexWithDifferentConstants() {\n+        int[] res = new int[SIZE];\n+        for (int i = 0; i < SIZE \/ 4; i++) {\n+            res[i] = ints[i + 1];\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    \/\/ Note that this case cannot be vectorized due to data dependence\n+    public int[] indexWithDifferentInvariants() {\n+        int[] res = new int[SIZE];\n+        for (int i = SIZE \/ 4; i < SIZE \/ 2; i++) {\n+            res[i + inv1] = ints[i - inv2];\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public int indexWithDifferentConstantsLoadOnly() {\n+        int res1 = 0;\n+        int res2 = 0;\n+        for (int i = 0; i < SIZE \/ 4; i++) {\n+            res1 += ints[i + 2];\n+            res2 += ints[i + 15];\n+        }\n+        return res1 * res2;\n+    }\n+\n+    @Test\n+    public int indexWithDifferentInvariantsLoadOnly() {\n+        int res1 = 0;\n+        int res2 = 0;\n+        for (int i = SIZE \/ 4; i < SIZE \/ 2; i++) {\n+            res1 += ints[i + inv1];\n+            res2 += ints[i - inv2];\n+        }\n+        return res1 * res2;\n+    }\n+\n+    @Test\n+    public int[] scaledIndex() {\n+        int[] res = new int[SIZE];\n+        for (int i = 0; i < SIZE \/ 3; i++) {\n+            res[2 * i] = ints[2 * i];\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public int[] scaledIndexWithConstantOffset() {\n+        int[] res = new int[SIZE];\n+        System.arraycopy(ints, 0, res, 0, SIZE);\n+        for (int i = 0; i < SIZE \/ 4; i++) {\n+            res[2 * i + 3] *= ints[2 * i + 3];\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public int[] scaledIndexWithInvariantOffset() {\n+        int[] res = new int[SIZE];\n+        System.arraycopy(ints, 0, res, 0, SIZE);\n+        for (int i = 0; i < SIZE \/ 4; i++) {\n+            res[2 * i + inv1] *= ints[2 * i + inv1];\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    \/\/ Note that this case cannot be vectorized due to data dependence\n+    \/\/ between src and dest of the assignment.\n+    public int[] sameArrayWithDifferentIndex() {\n+        int[] res = new int[SIZE];\n+        System.arraycopy(ints, 0, res, 0, SIZE);\n+        for (int i = 1, j = 0; i < 100; i++, j++) {\n+            res[i] += res[j];\n+        }\n+        return res;\n+    }\n+\n+    \/\/ ---------------- Subword Type Arrays ----------------\n+    @Test\n+    \/\/ Note that this case cannot be vectorized due to data dependence\n+    public short[] shortArrayWithDependence() {\n+        short[] res = new short[SIZE];\n+        System.arraycopy(shorts, 0, res, 0, SIZE);\n+        for (int i = 0; i < SIZE \/ 2; i++) {\n+            res[i] *= shorts[i + 1];\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    \/\/ Note that this case cannot be vectorized due to data dependence\n+    public char[] charArrayWithDependence() {\n+        char[] res = new char[SIZE];\n+        System.arraycopy(chars, 0, res, 0, SIZE);\n+        for (int i = 0; i < SIZE \/ 2; i++) {\n+            res[i] *= chars[i + 2];\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    \/\/ Note that this case cannot be vectorized due to data dependence\n+    public byte[] byteArrayWithDependence() {\n+        byte[] res = new byte[SIZE];\n+        System.arraycopy(bytes, 0, res, 0, SIZE);\n+        for (int i = 0; i < SIZE \/ 2; i++) {\n+            res[i] *= bytes[i + 3];\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    \/\/ Note that this case cannot be vectorized due to data dependence\n+    public boolean[] booleanArrayWithDependence() {\n+        boolean[] res = new boolean[SIZE];\n+        System.arraycopy(booleans, 0, res, 0, SIZE);\n+        for (int i = 0; i < SIZE \/ 2; i++) {\n+            res[i] |= booleans[i + 4];\n+        }\n+        return res;\n+    }\n+\n+    \/\/ ---------------- Multiple Operations ----------------\n+    @Test\n+    public int[] differentIndexWithDifferentTypes() {\n+        int[] res1 = new int[SIZE];\n+        short[] res2 = new short[SIZE];\n+        for (int i = 0; i < SIZE \/ 2; i++) {\n+            res1[i + 1] = ints[i + 1];\n+            res2[i + inv2] = shorts[i + inv2];\n+        }\n+        return res1;\n+    }\n+\n+    @Test\n+    \/\/ Note that this case cannot be vectorized due to data dependence\n+    public int[] differentIndexWithSameType() {\n+        int[] res1 = new int[SIZE];\n+        int[] res2 = new int[SIZE];\n+        for (int i = 0; i < SIZE \/ 2; i++) {\n+            res1[i + 3] = ints[i + 3];\n+            res2[i + inv1] = ints[i + inv1];\n+        }\n+        return res2;\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/LoopArrayIndexComputeTest.java","additions":287,"deletions":0,"binary":false,"changes":287,"status":"added"},{"patch":"@@ -0,0 +1,278 @@\n+\/*\n+ * Copyright (c) 2022, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Vectorization test on combined operations\n+ * @library \/test\/lib \/\n+ *\n+ * @build sun.hotspot.WhiteBox\n+ *        compiler.vectorization.runner.VectorizationTestRunner\n+ *\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:.\n+ *                   -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:+WhiteBoxAPI\n+ *                   compiler.vectorization.runner.LoopCombinedOpTest\n+ *\n+ * @requires vm.compiler2.enabled & vm.flagless\n+ *\/\n+\n+package compiler.vectorization.runner;\n+\n+import java.util.Random;\n+\n+public class LoopCombinedOpTest extends VectorizationTestRunner {\n+\n+    private static final int SIZE = 2345;\n+\n+    private int[] a;\n+    private int[] b;\n+    private int[] c;\n+    private int[] d;\n+    private long[] l1;\n+    private long[] l2;\n+    private short[] s1;\n+    private short[] s2;\n+    private int intInv;\n+\n+    public LoopCombinedOpTest() {\n+        a = new int[SIZE];\n+        b = new int[SIZE];\n+        c = new int[SIZE];\n+        d = new int[SIZE];\n+        l1 = new long[SIZE];\n+        l2 = new long[SIZE];\n+        s1 = new short[SIZE];\n+        s2 = new short[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            a[i] = -654321 * i;\n+            b[i] =  123456 * i;\n+            c[i] = -998877 * i;\n+            d[i] =  778899 * i;\n+            l1[i] = 5000000000L * i;\n+            l2[i] = -600000000L * i;\n+            s1[i] = (short) (3 * i);\n+            s2[i] = (short) (-2 * i);\n+        }\n+        Random ran = new Random(999);\n+        intInv = ran.nextInt();\n+    }\n+\n+    @Test\n+    public int[] opWithConstant() {\n+        int[] res = new int[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = a[i] + 1234567890;\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public int[] opWithLoopInvariant() {\n+        int[] res = new int[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = b[i] * intInv;\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public int[] opWithConstantAndLoopInvariant() {\n+        int[] res = new int[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = c[i] * (intInv & 0xfff);\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public int[] multipleOps() {\n+        int[] res = new int[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = a[i] & b[i] + c[i] & d[i];\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public int[] multipleOpsWithMultipleConstants() {\n+        int[] res = new int[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = a[i] * 12345678 + 87654321 + b[i] & 0xffff - c[i] * d[i] * 2;\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public int[] multipleStores() {\n+        int[] res1 = new int[SIZE];\n+        int[] res2 = new int[SIZE];\n+        int[] res3 = new int[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res1[i] = a[i] & b[i];\n+            res2[i] = c[i] | d[i];\n+            res3[i] = res1[i] * res2[i];\n+        }\n+        return res3;\n+    }\n+\n+    @Test\n+    public int[] multipleStoresWithCommonSubExpression() {\n+        int[] res1 = new int[SIZE];\n+        int[] res2 = new int[SIZE];\n+        int[] res3 = new int[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res1[i] = a[i] * b[i];\n+            res2[i] = c[i] * d[i];\n+            res3[i] = res1[i] + res2[i];\n+        }\n+        return res3;\n+    }\n+\n+    @Test\n+    public int[] multipleOpsWith2DifferentTypes() {\n+        short[] res1 = new short[SIZE];\n+        int[] res2 = new int[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res1[i] = (short) (s1[i] + s2[i]);\n+            res2[i] = a[i] + b[i];\n+        }\n+        return res2;\n+    }\n+\n+    @Test\n+    public long[] multipleOpsWith3DifferentTypes() {\n+        short[] res1 = new short[SIZE];\n+        int[] res2 = new int[SIZE];\n+        long[] res3 = new long[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res1[i] = (short) (s1[i] + s2[i]);\n+            res2[i] = a[i] + b[i];\n+            res3[i] = l1[i] + l2[i];\n+        }\n+        return res3;\n+    }\n+\n+    @Test\n+    public long[] multipleOpsWith2NonAdjacentTypes() {\n+        short[] res1 = new short[SIZE];\n+        long[] res2 = new long[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res1[i] = (short) (s1[i] + s2[i]);\n+            res2[i] = l1[i] + l2[i];\n+        }\n+        return res2;\n+    }\n+\n+    @Test\n+    public int[] multipleOpsWith2DifferentTypesAndConstant() {\n+        short[] res1 = new short[SIZE];\n+        int[] res2 = new int[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res1[i] = (short) (s1[i] + s2[i]);\n+            res2[i] = a[i] + 88888888;;\n+        }\n+        return res2;\n+    }\n+\n+    @Test\n+    public int[] multipleOpsWith2DifferentTypesAndInvariant() {\n+        short[] res1 = new short[SIZE];\n+        int[] res2 = new int[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res1[i] = (short) (s1[i] + s2[i]);\n+            res2[i] = a[i] * intInv;\n+        }\n+        return res2;\n+    }\n+\n+    @Test\n+    public int[] multipleOpsWith2DifferentTypesAndComplexExpression() {\n+        short[] res1 = new short[SIZE];\n+        int[] res2 = new int[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res1[i] = (short) (s1[i] + s2[i]);\n+            res2[i] = a[i] * (b[i] + intInv * c[i] & 0xfffffa);\n+        }\n+        return res2;\n+    }\n+\n+    @Test\n+    public int[] fillIndexPlusStride() {\n+        int[] res = new int[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = i + 1;\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public int[] addArrayWithIndex() {\n+        int[] res = new int[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = a[i] + i;\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public short[] multiplyAddShortIndex() {\n+        short[] res = new short[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = (short) (i * i + i);\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public int[] multiplyBySumOfIndexAndInvariant() {\n+        int[] res = new int[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = a[i] * (i + 10 + intInv);\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public int[] manuallyUnrolledStride2() {\n+        int[] res = new int[SIZE];\n+        for (int i = 0; i < SIZE - 1; i += 2) {\n+            res[i] = a[i] * b[i];\n+            res[i + 1] = a[i + 1] * b[i + 1];\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public int partialVectorizableLoop() {\n+        int[] res = new int[SIZE];\n+        int k = 9;\n+        for (int i = 0; i < SIZE \/ 2; i++) {\n+            res[i] = a[i] * b[i];\n+            k = 3 * k + 1;\n+        }\n+        return k;\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/LoopCombinedOpTest.java","additions":278,"deletions":0,"binary":false,"changes":278,"status":"added"},{"patch":"@@ -0,0 +1,90 @@\n+\/*\n+ * Copyright (c) 2022, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Vectorization test on simple control flow in loop\n+ * @library \/test\/lib \/\n+ *\n+ * @build sun.hotspot.WhiteBox\n+ *        compiler.vectorization.runner.VectorizationTestRunner\n+ *\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:.\n+ *                   -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:+WhiteBoxAPI\n+ *                   compiler.vectorization.runner.LoopControlFlowTest\n+ *\n+ * @requires vm.compiler2.enabled & vm.flagless\n+ *\/\n+\n+package compiler.vectorization.runner;\n+\n+import java.util.Random;\n+\n+public class LoopControlFlowTest extends VectorizationTestRunner {\n+\n+    private static final int SIZE = 2345;\n+\n+    private int[] a;\n+    private int[] b;\n+    private boolean invCond;\n+\n+    public LoopControlFlowTest() {\n+        a = new int[SIZE];\n+        b = new int[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            a[i] = i + 80000;;\n+            b[i] = 80 * i;\n+        }\n+        Random ran = new Random(505050);\n+        invCond = (ran.nextInt() % 2 == 0);\n+    }\n+\n+    @Test\n+    public int[] loopInvariantCondition() {\n+        int[] res = new int[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            if (invCond) {\n+                res[i] = a[i] + b[i];\n+            } else {\n+                res[i] = a[i] - b[i];\n+            }\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public int[] arrayElementCondition() {\n+        int[] res = new int[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            if (b[i] > 10000) {\n+                res[i] = a[i] + b[i];\n+            } else {\n+                res[i] = a[i] - b[i];\n+            }\n+        }\n+        return res;\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/LoopControlFlowTest.java","additions":90,"deletions":0,"binary":false,"changes":90,"status":"added"},{"patch":"@@ -0,0 +1,137 @@\n+\/*\n+ * Copyright (c) 2022, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Vectorization test on loops with live out nodes\n+ * @library \/test\/lib \/\n+ *\n+ * @build sun.hotspot.WhiteBox\n+ *        compiler.vectorization.runner.VectorizationTestRunner\n+ *\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:.\n+ *                   -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:+WhiteBoxAPI\n+ *                   compiler.vectorization.runner.LoopLiveOutNodesTest\n+ *\n+ * @requires vm.compiler2.enabled & vm.flagless\n+ *\/\n+\n+package compiler.vectorization.runner;\n+\n+import java.util.Random;\n+\n+public class LoopLiveOutNodesTest extends VectorizationTestRunner {\n+\n+    private static final int SIZE = 3333;\n+\n+    private int[] a;\n+    private int start;\n+    private int limit;\n+\n+    public LoopLiveOutNodesTest() {\n+        a = new int[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            a[i] = -697989 * i;\n+        }\n+        Random ran = new Random(31415926);\n+        start = 999 + ran.nextInt() % 100;\n+        limit = start + 1357;\n+    }\n+\n+    @Test\n+    public int SimpleIvUsed() {\n+        int i = 0;\n+        int[] res = new int[SIZE];\n+        for (i = start; i < limit; i++) {\n+            res[i] = a[i] * 2757;\n+        }\n+        return i;\n+    }\n+\n+    @Test\n+    public int indexedByIvUsed() {\n+        int i = 0;\n+        int[] res = new int[SIZE];\n+        for (i = start; i < limit; i++) {\n+            res[i] = a[i] & 0x77ff77ff;\n+        }\n+        return a[i - 1];\n+    }\n+\n+    @Test\n+    public int ivUsedMultiple() {\n+        int i = 0;\n+        int[] res = new int[SIZE];\n+        for (i = start; i < limit; i++) {\n+            res[i] = a[i] | 65535;\n+        }\n+        return i * i;\n+    }\n+\n+    @Test\n+    public int ivUsedComplexExpr() {\n+        int i = 0;\n+        int[] res = new int[SIZE];\n+        for (i = start; i < limit; i++) {\n+            res[i] = a[i] - 100550;\n+        }\n+        return a[i] + a[i - 2] + i * i;\n+    }\n+\n+    @Test\n+    public int[] ivUsedAnotherLoop() {\n+        int i = 0;\n+        int[] res = new int[SIZE];\n+        for (i = start; i < limit; i++) {\n+            res[i] = a[i] * 100;\n+        }\n+        for (int j = i; j < i + 55; j++) {\n+            res[j] = a[j - 500] + 2323;\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public int ivUsedInParallel() {\n+        int i = 0, j = 0;\n+        int[] res = new int[SIZE];\n+        for (i = start; i < limit; i++, j++) {\n+            res[i] = a[i] + i;\n+        }\n+        return i * j + a[i] * a[j];\n+    }\n+\n+    @Test\n+    public int valueLiveOut() {\n+        int val = 0;\n+        int[] res = new int[SIZE];\n+        for (int i = start; i < limit; i++) {\n+            val = a[i] - 101;\n+            res[i] = val;\n+        }\n+        return val;\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/LoopLiveOutNodesTest.java","additions":137,"deletions":0,"binary":false,"changes":137,"status":"added"},{"patch":"@@ -0,0 +1,201 @@\n+\/*\n+ * Copyright (c) 2022, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Vectorization test on different loop ranges and strides\n+ * @library \/test\/lib \/\n+ *\n+ * @build sun.hotspot.WhiteBox\n+ *        compiler.vectorization.runner.VectorizationTestRunner\n+ *\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:.\n+ *                   -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:+WhiteBoxAPI\n+ *                   compiler.vectorization.runner.LoopRangeStrideTest\n+ *\n+ * @requires vm.compiler2.enabled & vm.flagless\n+ *\/\n+\n+package compiler.vectorization.runner;\n+\n+import java.util.Random;\n+\n+public class LoopRangeStrideTest extends VectorizationTestRunner {\n+\n+    private static final int SIZE = 2345;\n+\n+    private int[] a;\n+    private int[] b;\n+    private int start;\n+    private int end;\n+\n+    public LoopRangeStrideTest() {\n+        a = new int[SIZE];\n+        b = new int[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            a[i] = -i \/ 2;\n+            b[i] = 444 * i - 12345;\n+        }\n+\n+        Random ran = new Random(0);\n+        start = Math.abs(ran.nextInt() % 1000);\n+        end = start + 1315;\n+    }\n+\n+    \/\/ ---------------- Range ----------------\n+    @Test\n+    public int[] smallConstantRange() {\n+        int[] res = new int[SIZE];\n+        for (int i = 20; i < 27; i++) {\n+            res[i] = a[i] + b[i];\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public int[] nonConstantRange() {\n+        int[] res = new int[SIZE];\n+        for (int i = start; i < end; i++) {\n+            res[i] = a[i] - b[i];\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public int[] crossZeroRange() {\n+        int[] res = new int[SIZE];\n+        for (int i = -20; i < 20; i++) {\n+            res[i + 50] = a[i + 50] + b[i + 50];\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public int[] nonEqualTestRange() {\n+        int[] res = new int[SIZE];\n+        for (int i = start; i != end; i++) {\n+            res[i] = a[i] - b[i];\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public int[] shortInductionLoop() {\n+        int[] res = new int[SIZE];\n+        for (short s = 123; s < 789; s++) {\n+            res[s] = a[s] * b[s];\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public int[] whileLoop() {\n+        int[] res = new int[SIZE];\n+        int i = start;\n+        while (i < end) {\n+            res[i] = a[i] & b[i];\n+            i++;\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public int[] doWhileLoop() {\n+        int[] res = new int[SIZE];\n+        int i = start;\n+        do {\n+            res[i] = a[i] | b[i];\n+            i++;\n+        } while (i < end);\n+        return res;\n+    }\n+\n+    \/\/ ---------------- Stride ----------------\n+    @Test\n+    public int[] stride2Loop() {\n+        int[] res = new int[SIZE];\n+        for (int i = 0; i < SIZE; i += 2) {\n+            res[i] = a[i] * b[i];\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public int[] stride3Loop() {\n+        int[] res = new int[SIZE];\n+        for (int i = 0; i < SIZE; i += 3) {\n+            res[i] = a[i] * b[i];\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public int[] stride4Loop() {\n+        int[] res = new int[SIZE];\n+        for (int i = 0; i < SIZE; i += 4) {\n+            res[i] = a[i] * b[i];\n+        }\n+        return res;\n+    }\n+\n+\n+    @Test\n+    public int[] countDownLoop() {\n+        int[] res = new int[SIZE];\n+        for (int i = SIZE - 1; i > 0; i--) {\n+            res[i] = a[i] * b[i];\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public int[] strideMinus2Loop() {\n+        int[] res = new int[SIZE];\n+        for (int i = SIZE - 1; i > 0; i -= 2) {\n+            res[i] = a[i] * b[i];\n+        }\n+        return res;\n+    }\n+\n+    \/\/ ---------- Stride with scale ----------\n+    @Test\n+    public int[] countupLoopWithNegScale() {\n+        int[] res = new int[SIZE];\n+        for (int i = SIZE \/ 2; i < SIZE; i++) {\n+            res[SIZE - i] = a[SIZE - i] * b[SIZE - i];\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public int[] countDownLoopWithNegScale() {\n+        int[] res = new int[SIZE];\n+        for (int i = SIZE \/ 2; i > 0; i--) {\n+            res[SIZE - i] = a[SIZE - i] * b[SIZE - i];\n+        }\n+        return res;\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/LoopRangeStrideTest.java","additions":201,"deletions":0,"binary":false,"changes":201,"status":"added"},{"patch":"@@ -0,0 +1,189 @@\n+\/*\n+ * Copyright (c) 2022, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Vectorization test on reduction operations\n+ * @library \/test\/lib \/\n+ *\n+ * @build sun.hotspot.WhiteBox\n+ *        compiler.vectorization.runner.VectorizationTestRunner\n+ *\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:.\n+ *                   -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:+WhiteBoxAPI\n+ *                   compiler.vectorization.runner.LoopReductionOpTest\n+ *\n+ * @requires vm.compiler2.enabled & vm.flagless\n+ *\/\n+\n+package compiler.vectorization.runner;\n+\n+import java.util.Random;\n+\n+public class LoopReductionOpTest extends VectorizationTestRunner {\n+\n+    private static final int SIZE = 2345;\n+\n+    private int[] a;\n+    private int[] b;\n+    private int[] c;\n+    private double[] d;\n+    private float[] f;\n+    private long[] l;\n+    private int intInv;\n+\n+    public LoopReductionOpTest() {\n+        a = new int[SIZE];\n+        b = new int[SIZE];\n+        c = new int[SIZE];\n+        d = new double[SIZE];\n+        f = new float[SIZE];\n+        l = new long[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            a[i] = -531 * i;\n+            b[i] = 2222 * i + 8;\n+            c[i] = 2147480000;\n+            d[i] = i * 2.5;\n+            f[i] = i * -(333.3f);\n+            l[i] = 444444444L * i;\n+        }\n+        Random ran = new Random(10001);\n+        intInv = ran.nextInt();\n+    }\n+\n+    @Test\n+    public int reductionAddSumOfArray() {\n+        int res = 0;\n+        for (int i = 0; i < SIZE; i++) {\n+            res += (a[i] + b[i]);\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public int reductionAddIndex() {\n+        int res = 0;\n+        for (int i = 0; i < SIZE; i++) {\n+            res += i;\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    \/\/ Note that adding constant in loop would be directly optimized to\n+    \/\/ scalar operations, hence this case is not vectorized.\n+    public int reductionAddConstant() {\n+        int res = 0;\n+        for (int i = 0; i < SIZE; i++) {\n+            res += 222;\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public int reductionAddLoopInv() {\n+        int res = 0;\n+        for (int i = 0; i < SIZE; i++) {\n+            res += intInv;\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public int reductionAddSumOfMultiple() {\n+        int res = 0;\n+        for (int i = 0; i < SIZE; i++) {\n+            res += (a[i] + b[i]) * i << 2;\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public int twoReductions() {\n+        int res1 = 0;\n+        int res2 = 0;\n+        for (int i = 0; i < SIZE; i++) {\n+            res1 += a[i];\n+            res2 += b[i];\n+        }\n+        return res1 * res2;\n+    }\n+\n+    @Test\n+    public float twoReductionsSameElementSize() {\n+        int res1 = 0;\n+        float res2 = 0.0f;\n+        for (int i = 0; i < SIZE; i++) {\n+            res1 += a[i];\n+            res2 += f[i];\n+        }\n+        return res1 * res2;\n+    }\n+\n+    @Test\n+    public double twoReductionsDifferentSizes1() {\n+        int res1 = 0;\n+        double res2 = 0.0;\n+        for (int i = 0; i < SIZE; i++) {\n+            res1 += a[i];\n+            res2 += d[i];\n+        }\n+        return res1 * res2;\n+    }\n+\n+    @Test\n+    public double twoReductionsDifferentSizes2() {\n+        long res1 = 0L;\n+        float res2 = 0.0f;\n+        for (int i = 0; i < SIZE; i++) {\n+            res1 += l[i];\n+            res2 += f[i];\n+        }\n+        return res1 * res2;\n+    }\n+\n+    @Test\n+    public long reductionWithNonReductionDifferentSizes() {\n+        long res = 0L;\n+        int[] arr = new int[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            arr[i] = a[i] + b[i];\n+            res += l[i];\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public long reductionLoopIndexSumDifferentSizes() {\n+        int intSum = 0;\n+        long longSum = 0L;\n+        for (int i = 0; i < SIZE; i++) {\n+            intSum += i;\n+            longSum += i;\n+        }\n+        return intSum + 2 * longSum;\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/LoopReductionOpTest.java","additions":189,"deletions":0,"binary":false,"changes":189,"status":"added"},{"patch":"@@ -0,0 +1,118 @@\n+\/*\n+ * Copyright (c) 2022, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Vectorization test on multiple loops in a method\n+ * @library \/test\/lib \/\n+ *\n+ * @build sun.hotspot.WhiteBox\n+ *        compiler.vectorization.runner.VectorizationTestRunner\n+ *\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:.\n+ *                   -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:+WhiteBoxAPI\n+ *                   compiler.vectorization.runner.MultipleLoopsTest\n+ *\n+ * @requires vm.compiler2.enabled & vm.flagless\n+ *\/\n+\n+package compiler.vectorization.runner;\n+\n+public class MultipleLoopsTest extends VectorizationTestRunner {\n+\n+    private static final int SIZE = 543;\n+\n+    private int[] a;\n+    private int[] b;\n+    private int[] c;\n+\n+    public MultipleLoopsTest() {\n+        a = new int[SIZE];\n+        b = new int[SIZE];\n+        c = new int[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            a[i] = -654321 * i;\n+            b[i] =  123456 * i;\n+            c[i] = -998877 * i;\n+        }\n+    }\n+\n+    @Test\n+    public int[] consecutiveLoops() {\n+        int[] res1 = new int[SIZE];\n+        int[] res2 = new int[SIZE];\n+        int[] res3 = new int[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res1[i] = a[i] + b[i];\n+        }\n+        for (int i = 0; i < SIZE; i++) {\n+            res2[i] = a[i] - b[i];\n+        }\n+        for (int i = 0; i < SIZE; i++) {\n+            res3[i] = res1[i] * res2[i];\n+        }\n+        return res3;\n+    }\n+\n+    @Test\n+    public int[] consecutiveLoopsNested() {\n+        int[] res = new int[SIZE];\n+        for (int outer = 0; outer < 30; outer++) {\n+            for (int i = 0; i < SIZE \/ 2; i++) {\n+                res[i] += a[i];\n+            }\n+            for (int i = SIZE \/ 2; i < SIZE; i++) {\n+                res[i] *= b[i];\n+            }\n+        } \/\/ Outer loop is counted\n+        return res;\n+    }\n+\n+    @Test\n+    public int[] nestedLoopOuterNonCounted() {\n+        int i = 1;\n+        int[] res = new int[SIZE];\n+        while (i < SIZE) {\n+            int val = i * a[i];\n+            for (int j = 0; j < SIZE; j++) {\n+                res[j] = b[j] * val;\n+            }\n+            i *= 2;\n+        } \/\/ Outer loop is non-counted\n+        return res;\n+    }\n+\n+    @Test\n+    public int[] nestedLoopIndexCompute() {\n+        int[] res = new int[SIZE];\n+        for (int i = 50; i < 100; i++) {\n+            for (int j = 0; j < 200 - i; j++) {\n+                res[i + j] = a[i + j] * b[i + j];\n+            }\n+        }\n+        return res;\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/MultipleLoopsTest.java","additions":118,"deletions":0,"binary":false,"changes":118,"status":"added"},{"patch":"@@ -0,0 +1,78 @@\n+\/*\n+ * Copyright (c) 2022, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Vectorization test with small strip mining iterations\n+ * @library \/test\/lib \/\n+ *\n+ * @build sun.hotspot.WhiteBox\n+ *        compiler.vectorization.runner.VectorizationTestRunner\n+ *\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:.\n+ *                   -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:+WhiteBoxAPI\n+ *                   -XX:LoopStripMiningIter=10\n+ *                   compiler.vectorization.runner.StripMinedLoopTest\n+ *\n+ * @requires vm.compiler2.enabled & vm.flagless\n+ *\/\n+\n+package compiler.vectorization.runner;\n+\n+import java.util.Random;\n+\n+public class StripMinedLoopTest extends VectorizationTestRunner {\n+\n+    private static final int SIZE = 2345;\n+\n+    private int[] a = new int[SIZE];\n+    private int[] b = new int[SIZE];\n+\n+    public StripMinedLoopTest() {\n+        for (int i = 0; i < SIZE; i++) {\n+            a[i] = 2;\n+            b[i] = 3;\n+        }\n+    }\n+\n+    @Test\n+    public int[] stripMinedVectorLoop() {\n+        int[] res = new int[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = a[i] + b[i];\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    public int stripMinedReductionLoop() {\n+        int res = 0;\n+        for (int i = 0; i < SIZE; i++) {\n+            res += a[i];\n+        }\n+        return res;\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/StripMinedLoopTest.java","additions":78,"deletions":0,"binary":false,"changes":78,"status":"added"},{"patch":"@@ -0,0 +1,207 @@\n+\/*\n+ * Copyright (c) 2022, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.vectorization.runner;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+import java.lang.reflect.Array;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+\n+import java.io.File;\n+\n+import jdk.test.lib.Utils;\n+\n+import sun.hotspot.WhiteBox;\n+\n+public class VectorizationTestRunner {\n+\n+    private static final WhiteBox WB = WhiteBox.getWhiteBox();\n+\n+    private static final int COMP_LEVEL_INTP = 0;\n+    private static final int COMP_LEVEL_C2 = 4;\n+\n+    private static final int NMETHOD_COMP_LEVEL_IDX = 1;\n+    private static final int NMETHOD_INSTS_IDX = 2;\n+\n+    private static final long COMP_THRES_SECONDS = 30;\n+\n+    @Target(ElementType.METHOD)\n+    @Retention(RetentionPolicy.RUNTIME)\n+    protected @interface Test {}\n+\n+    protected void run() {\n+        \/\/ Add extra VM options to enable post loop vectorization\n+        WB.setBooleanVMFlag(\"UnlockExperimentalVMOptions\", true);\n+        WB.setBooleanVMFlag(\"PostLoopMultiversioning\", true);\n+\n+        \/\/ For each method annotated with @Test in the test method, this test runner\n+        \/\/ invokes it twice - first time in the interpreter and second time compiled\n+        \/\/ by C2. Then this runner compares the two return values. Hence we require\n+        \/\/ each test method returning a primitive value or an array of primitive type.\n+        \/\/ And each test method should not throw any exceptions.\n+        Class klass = getClass();\n+        for (Method method : klass.getDeclaredMethods()) {\n+            try {\n+                if (method.isAnnotationPresent(Test.class)) {\n+                    verifyTestMethod(method);\n+                    runTestOnMethod(method);\n+                }\n+            } catch (Exception e) {\n+                throw new RuntimeException(\"Test failed in \" + klass.getName() +\n+                        \".\" + method.getName() + \": \" + e.getMessage());\n+            }\n+        }\n+    }\n+\n+    private void verifyTestMethod(Method method) {\n+        \/\/ Check method parameter count\n+        if (method.getParameterCount() > 0) {\n+            fail(\"Test method should have no parameter.\");\n+        }\n+\n+        \/\/ Check method modifiers\n+        int modifiers = method.getModifiers();\n+        if (!Modifier.isPublic(modifiers) || Modifier.isStatic(modifiers)) {\n+            fail(\"Test method should be public and non-static.\");\n+        }\n+\n+        \/\/ Check method return type\n+        Class retType = method.getReturnType();\n+        if (retType.isPrimitive()) {\n+            if (retType == Void.TYPE) {\n+                fail(\"Test method should return non-void.\");\n+            }\n+        } else if (retType.isArray()) {\n+            Class elemType = retType.getComponentType();\n+            if (!elemType.isPrimitive()) {\n+                fail(\"Only primitive array types are supported.\");\n+            }\n+        } else {\n+            fail(\"Test method should not return Object type.\");\n+        }\n+    }\n+\n+    private void runTestOnMethod(Method method) throws InterruptedException {\n+        Object expected = null;\n+        Object actual = null;\n+\n+        \/\/ Lock compilation and inovke the method to get reference result from\n+        \/\/ the interpreter\n+        WB.lockCompilation();\n+        try {\n+            expected = method.invoke(this);\n+        } catch (Exception e) {\n+            e.printStackTrace();\n+            fail(\"Exception is thrown in test method invocation (interpreter).\");\n+        }\n+        assert(WB.getMethodCompilationLevel(method) == COMP_LEVEL_INTP);\n+        WB.unlockCompilation();\n+\n+        \/\/ Compile the method and invoke it again\n+        long enqueueTime = System.currentTimeMillis();\n+        WB.enqueueMethodForCompilation(method, COMP_LEVEL_C2);\n+        while (WB.getMethodCompilationLevel(method) != COMP_LEVEL_C2) {\n+            if (System.currentTimeMillis() - enqueueTime > COMP_THRES_SECONDS * 1000) {\n+                fail(\"Method is not compiled after \" + COMP_THRES_SECONDS + \"s.\");\n+            }\n+            Thread.sleep(50 \/*ms*\/);\n+        }\n+        try {\n+            actual = method.invoke(this);\n+        } catch (Exception e) {\n+            e.printStackTrace();\n+            fail(\"Exception is thrown in test method invocation (C2).\");\n+        }\n+        assert(WB.getMethodCompilationLevel(method) == COMP_LEVEL_C2);\n+\n+        \/\/ Check if two invocations return the same\n+        Class retType = method.getReturnType();\n+        if (retType.isArray()) {\n+            \/\/ Method invocations from Java reflection API always return a boxed object.\n+            \/\/ Hence, for methods return primitive array, we can only use reflection API\n+            \/\/ to check the consistency of the elements one by one.\n+            if (expected == null && actual == null) {\n+                return;\n+            }\n+            if (expected == null ^ actual == null) {\n+                fail(\"Inconsistent return value: null\/non-null.\");\n+            }\n+            int length = Array.getLength(expected);\n+            if (Array.getLength(actual) != length) {\n+                fail(\"Inconsistent array length: expected = \" + length + \", actual = \" +\n+                        Array.getLength(actual));\n+            }\n+            for (int idx = 0; idx < length; idx++) {\n+                Object e1 = Array.get(expected, idx);\n+                Object e2 = Array.get(actual, idx);\n+                if (!e1.equals(e2)) {\n+                    fail(\"Inconsistent value at array index [\" + idx + \"], expected = \" +\n+                            e1 + \", actual = \" + e2);\n+                }\n+            }\n+        } else {\n+            \/\/ Method invocations from Java reflection API always return a boxed object.\n+            \/\/ Hence, we should use equals() to check the consistency for methods which\n+            \/\/ return primitive type.\n+            if (!expected.equals(actual)) {\n+                fail(\"Inconsistent return value: expected = \" + expected\n+                        + \", actual = \" + actual);\n+            }\n+        }\n+    }\n+\n+    private static VectorizationTestRunner createTestInstance(String testName) {\n+        if (!testName.toLowerCase().endsWith(\".java\")) {\n+            fail(\"Invalid test file name \" + testName);\n+        }\n+        testName = testName.substring(0, testName.length() - 5);\n+        testName = testName.replace('\/', '.');\n+\n+        VectorizationTestRunner instance = null;\n+        try {\n+            Class klass = Class.forName(testName);\n+            Constructor ctor = klass.getConstructor();\n+            instance = (VectorizationTestRunner) ctor.newInstance();\n+        } catch (Exception e) {\n+            e.printStackTrace();\n+            fail(\"Cannot create test instance for class \" + testName);\n+        }\n+\n+        return instance;\n+    }\n+\n+    private static void fail(String reason) {\n+        throw new RuntimeException(reason);\n+    }\n+\n+    public static void main(String[] args) {\n+        VectorizationTestRunner testObj = createTestInstance(Utils.TEST_NAME);\n+        testObj.run();\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/VectorizationTestRunner.java","additions":207,"deletions":0,"binary":false,"changes":207,"status":"added"}]}