{"files":[{"patch":"@@ -4541,1 +4541,1 @@\n-#if defined(IA32)\n+#ifdef IA32\n@@ -5517,0 +5517,76 @@\n+\/*\n+ * IA32 only: execute code at a high address in case buggy NX emulation is present. I.e. avoid CS limit\n+ * updates (JDK-8023956).\n+ *\/\n+#ifdef IA32\n+void os::workaround_expand_exec_shield_cs_limit() {\n+  assert(Linux::initial_thread_stack_bottom() != NULL, \"sanity\");\n+  size_t page_size = os::vm_page_size();\n+\n+  \/*\n+   * JDK-8197429\n+   *\n+   * Expand the stack mapping to the end of the initial stack before\n+   * attempting to install the codebuf.  This is needed because newer\n+   * Linux kernels impose a distance of a megabyte between stack\n+   * memory and other memory regions.  If we try to install the\n+   * codebuf before expanding the stack the installation will appear\n+   * to succeed but we'll get a segfault later if we expand the stack\n+   * in Java code.\n+   *\n+   *\/\n+  if (os::is_primordial_thread()) {\n+    address limit = Linux::initial_thread_stack_bottom();\n+    if (! DisablePrimordialThreadGuardPages) {\n+      limit += StackOverflow::stack_red_zone_size() +\n+               StackOverflow::stack_yellow_zone_size();\n+    }\n+    os::Linux::expand_stack_to(limit);\n+  }\n+\n+  \/*\n+   * Take the highest VA the OS will give us and exec\n+   *\n+   * Although using -(pagesz) as mmap hint works on newer kernel as you would\n+   * think, older variants affected by this work-around don't (search forward only).\n+   *\n+   * On the affected distributions, we understand the memory layout to be:\n+   *\n+   *   TASK_LIMIT= 3G, main stack base close to TASK_LIMT.\n+   *\n+   * A few pages south main stack will do it.\n+   *\n+   * If we are embedded in an app other than launcher (initial != main stack),\n+   * we don't have much control or understanding of the address space, just let it slide.\n+   *\/\n+  char* hint = (char*)(Linux::initial_thread_stack_bottom() -\n+                       (StackOverflow::stack_guard_zone_size() + page_size));\n+  char* codebuf = os::attempt_reserve_memory_at(hint, page_size);\n+\n+  if (codebuf == NULL) {\n+    \/\/ JDK-8197429: There may be a stack gap of one megabyte between\n+    \/\/ the limit of the stack and the nearest memory region: this is a\n+    \/\/ Linux kernel workaround for CVE-2017-1000364.  If we failed to\n+    \/\/ map our codebuf, try again at an address one megabyte lower.\n+    hint -= 1 * M;\n+    codebuf = os::attempt_reserve_memory_at(hint, page_size);\n+  }\n+\n+  if ((codebuf == NULL) || (!os::commit_memory(codebuf, page_size, true))) {\n+    return; \/\/ No matter, we tried, best effort.\n+  }\n+\n+  MemTracker::record_virtual_memory_type((address)codebuf, mtInternal);\n+\n+  log_info(os)(\"[CS limit NX emulation work-around, exec code at: %p]\", codebuf);\n+\n+  \/\/ Some code to exec: the 'ret' instruction\n+  codebuf[0] = 0xC3;\n+\n+  \/\/ Call the code in the codebuf\n+  __asm__ volatile(\"call *%0\" : : \"r\"(codebuf));\n+\n+  \/\/ keep the page mapped so CS limit isn't reduced.\n+}\n+#endif\n+\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":77,"deletions":1,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -659,77 +659,0 @@\n-\n-\/*\n- * IA32 only: execute code at a high address in case buggy NX emulation is present. I.e. avoid CS limit\n- * updates (JDK-8023956).\n- *\/\n-void os::workaround_expand_exec_shield_cs_limit() {\n-#if defined(IA32)\n-  assert(Linux::initial_thread_stack_bottom() != NULL, \"sanity\");\n-  size_t page_size = os::vm_page_size();\n-\n-  \/*\n-   * JDK-8197429\n-   *\n-   * Expand the stack mapping to the end of the initial stack before\n-   * attempting to install the codebuf.  This is needed because newer\n-   * Linux kernels impose a distance of a megabyte between stack\n-   * memory and other memory regions.  If we try to install the\n-   * codebuf before expanding the stack the installation will appear\n-   * to succeed but we'll get a segfault later if we expand the stack\n-   * in Java code.\n-   *\n-   *\/\n-  if (os::is_primordial_thread()) {\n-    address limit = Linux::initial_thread_stack_bottom();\n-    if (! DisablePrimordialThreadGuardPages) {\n-      limit += StackOverflow::stack_red_zone_size() +\n-               StackOverflow::stack_yellow_zone_size();\n-    }\n-    os::Linux::expand_stack_to(limit);\n-  }\n-\n-  \/*\n-   * Take the highest VA the OS will give us and exec\n-   *\n-   * Although using -(pagesz) as mmap hint works on newer kernel as you would\n-   * think, older variants affected by this work-around don't (search forward only).\n-   *\n-   * On the affected distributions, we understand the memory layout to be:\n-   *\n-   *   TASK_LIMIT= 3G, main stack base close to TASK_LIMT.\n-   *\n-   * A few pages south main stack will do it.\n-   *\n-   * If we are embedded in an app other than launcher (initial != main stack),\n-   * we don't have much control or understanding of the address space, just let it slide.\n-   *\/\n-  char* hint = (char*)(Linux::initial_thread_stack_bottom() -\n-                       (StackOverflow::stack_guard_zone_size() + page_size));\n-  char* codebuf = os::attempt_reserve_memory_at(hint, page_size);\n-\n-  if (codebuf == NULL) {\n-    \/\/ JDK-8197429: There may be a stack gap of one megabyte between\n-    \/\/ the limit of the stack and the nearest memory region: this is a\n-    \/\/ Linux kernel workaround for CVE-2017-1000364.  If we failed to\n-    \/\/ map our codebuf, try again at an address one megabyte lower.\n-    hint -= 1 * M;\n-    codebuf = os::attempt_reserve_memory_at(hint, page_size);\n-  }\n-\n-  if ((codebuf == NULL) || (!os::commit_memory(codebuf, page_size, true))) {\n-    return; \/\/ No matter, we tried, best effort.\n-  }\n-\n-  MemTracker::record_virtual_memory_type((address)codebuf, mtInternal);\n-\n-  log_info(os)(\"[CS limit NX emulation work-around, exec code at: %p]\", codebuf);\n-\n-  \/\/ Some code to exec: the 'ret' instruction\n-  codebuf[0] = 0xC3;\n-\n-  \/\/ Call the code in the codebuf\n-  __asm__ volatile(\"call *%0\" : : \"r\"(codebuf));\n-\n-  \/\/ keep the page mapped so CS limit isn't reduced.\n-#endif\n-}\n-\n","filename":"src\/hotspot\/os_cpu\/linux_x86\/os_linux_x86.cpp","additions":0,"deletions":77,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+#ifdef IA32\n@@ -52,0 +53,1 @@\n+#endif\n","filename":"src\/hotspot\/os_cpu\/linux_x86\/os_linux_x86.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+#ifdef IA32\n@@ -49,0 +50,1 @@\n+#endif\n","filename":"src\/hotspot\/os_cpu\/linux_zero\/os_linux_zero.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"}]}