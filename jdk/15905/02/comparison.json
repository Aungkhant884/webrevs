{"files":[{"patch":"@@ -109,14 +109,0 @@\n-static void enqueue_use(Node* n, Node* use, Unique_Node_List& work) {\n-  if (use->is_Phi()) {\n-    Node* r = use->in(0);\n-    assert(r->is_Region(), \"Phi should have Region\");\n-    for (uint i = 1; i < use->req(); i++) {\n-      if (use->in(i) == n) {\n-        work.push(r->in(i));\n-      }\n-    }\n-  } else {\n-    work.push(use);\n-  }\n-}\n-\n@@ -129,0 +115,2 @@\n+  ResourceMark rm;\n+  Node_Stack stack(0);\n@@ -135,5 +123,14 @@\n-    ResourceMark rm;\n-    Unique_Node_List work;\n-    \/\/ Go over all the uses of the node that is considered for replacement...\n-    for (DUIterator j = initial->outs(); initial->has_out(j); j++) {\n-      Node* use = initial->out(j);\n+    if (initial->outcnt() == 0) {\n+      continue;\n+    }\n+\n+    \/\/ Try to find some use of initial that are dominated by ctl so, initial can be replaced by improved.\n+    \/\/ Proving domination here is not straightforward. To do so, we follow uses of initial, and uses of uses until we\n+    \/\/ encounter a node which is a control node or is pinned at some control. Then, we try to prove this control is\n+    \/\/ dominated by ctl. If that's the case, it's legal to replace initial by improved but for this chain of uses only.\n+    \/\/ It may not be the case for some other chain of uses, so we clone that chain and perform the replacement only for\n+    \/\/ these uses.\n+    assert(stack.is_empty(), \"\");\n+    stack.push(initial, 1);\n+    Node* use = initial->raw_out(0);\n+    stack.push(use, 0);\n@@ -141,16 +138,18 @@\n-      if (use == improved || use->outcnt() == 0) {\n-        continue;\n-      }\n-      work.clear();\n-      enqueue_use(initial, use, work);\n-      bool replace = true;\n-      \/\/ Check that this use is dominated by ctl. Go ahead with the replacement if it is.\n-      while (work.size() != 0 && replace) {\n-        Node* n = work.pop();\n-        if (use->outcnt() == 0) {\n-          continue;\n-        }\n-        if (n->is_CFG() || (n->in(0) != nullptr && !n->in(0)->is_top())) {\n-          \/\/ Skip projections, since some of the multi nodes aren't CFG (e.g., LoadStore and SCMemProj).\n-          if (n->is_Proj()) {\n-            n = n->in(0);\n+    while (!stack.is_empty()) {\n+      assert(stack.size() > 1, \"at least initial + one use\");\n+      Node* n = stack.node();\n+\n+      uint current_size = stack.size();\n+      if (n->outcnt() != 0 && n != improved) {\n+        if (n->is_Phi()) {\n+          Node* region = n->in(0);\n+          Node* prev = stack.node_at(stack.size() - 2);\n+          for (uint j = 1; j < region->req(); ++j) {\n+            if (n->in(j) == prev) {\n+              Node* in = region->in(j);\n+              if (in != nullptr && !in->is_top()) {\n+                if (is_dominator(ctl, in)) {\n+                  clone_stack(C, initial, improved, stack, j);\n+                }\n+              }\n+            }\n@@ -158,2 +157,3 @@\n-          if (!n->is_CFG()) {\n-            n = n->in(0);\n+        } else if (n->is_CFG()) {\n+          if (is_dominator(ctl, n)) {\n+            clone_stack(C, initial, improved, stack, -1);\n@@ -161,10 +161,4 @@\n-          assert(n->is_CFG(), \"should be CFG now\");\n-          int depth = 0;\n-          while(n != ctl) {\n-            n = IfNode::up_one_dom(n);\n-            depth++;\n-            \/\/ limit search depth\n-            if (depth >= 100 || n == nullptr) {\n-              replace = false;\n-              break;\n-            }\n+        } else if (n->in(0) != nullptr && !n->in(0)->is_top()) {\n+          Node* c = n->in(0);\n+          if (is_dominator(ctl, c)) {\n+            clone_stack(C, initial, improved, stack, -1);\n@@ -173,2 +167,4 @@\n-          for (DUIterator k = n->outs(); n->has_out(k); k++) {\n-            enqueue_use(n, n->out(k), work);\n+          uint idx = stack.index();\n+          if (idx < n->outcnt()) {\n+            stack.set_index(idx + 1);\n+            stack.push(n->raw_out(idx), 0);\n@@ -178,5 +174,13 @@\n-      if (replace) {\n-        bool is_in_table = C->initial_gvn()->hash_delete(use);\n-        int replaced = use->replace_edge(initial, improved);\n-        if (is_in_table) {\n-          C->initial_gvn()->hash_find_insert(use);\n+      if (stack.size() == current_size) {\n+        for (;;) {\n+          stack.pop();\n+          if (stack.is_empty()) {\n+            break;\n+          }\n+          n = stack.node();\n+          uint idx = stack.index();\n+          if (idx < n->outcnt()) {\n+            stack.set_index(idx + 1);\n+            stack.push(n->raw_out(idx), 0);\n+            break;\n+          }\n@@ -184,4 +188,0 @@\n-        C->record_for_igvn(use);\n-\n-        assert(replaced > 0, \"inconsistent\");\n-        --j;\n@@ -193,0 +193,51 @@\n+void ReplacedNodes::clone_stack(Compile* C, Node* initial, Node* improved, const Node_Stack& stack, int i) const {\n+  Node* prev = stack.node();\n+  for (uint k = stack.size() - 2; k > 0 ; k--) {\n+    Node* n = stack.node_at(k);\n+    Node* clone = n->clone();\n+    bool is_in_table = C->initial_gvn()->hash_delete(prev);\n+    if (i == -1) {\n+      int replaced = prev->replace_edge(n, clone);\n+      assert(replaced > 0, \"expected some use\");\n+    } else {\n+      assert(k == (stack.size() - 2) && prev->is_Phi(), \"\");\n+      assert(prev->in(i) == n, \"not a use?\");\n+      prev->set_req(i, clone);\n+      i = -1;\n+    }\n+    C->record_for_igvn(prev);\n+    if (is_in_table) {\n+      C->initial_gvn()->hash_find_insert(prev);\n+    }\n+    C->initial_gvn()->set_type_bottom(clone);\n+    prev = clone;\n+  }\n+  bool is_in_table = C->initial_gvn()->hash_delete(prev);\n+  if (i == -1) {\n+    int replaced = prev->replace_edge(initial, improved);\n+    assert(replaced > 0, \"expected some use\");\n+  } else {\n+    assert(prev->is_Phi(), \"only for Phis\");\n+    assert(prev->in(i) == initial, \"not a use?\");\n+    prev->set_req(i, improved);\n+  }\n+  C->record_for_igvn(prev);\n+  if (is_in_table) {\n+    C->initial_gvn()->hash_find_insert(prev);\n+  }\n+}\n+\n+bool ReplacedNodes::is_dominator(const Node* ctl, Node* n) const {\n+  assert(n->is_CFG(), \"should be CFG now\");\n+  int depth = 0;\n+  while (n != ctl) {\n+    n = IfNode::up_one_dom(n);\n+    depth++;\n+    \/\/ limit search depth\n+    if (depth >= 100 || n == nullptr) {\n+      return false;\n+    }\n+  }\n+  return true;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/replacednodes.cpp","additions":109,"deletions":58,"binary":false,"changes":167,"status":"modified"},{"patch":"@@ -79,0 +79,4 @@\n+\n+  bool is_dominator(const Node* ctl, Node* n) const;\n+\n+  void clone_stack(Compile* C, Node* initial, Node* improved, const Node_Stack& stack, int i) const;\n","filename":"src\/hotspot\/share\/opto\/replacednodes.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,80 @@\n+\/*\n+ * Copyright (c) 2023, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * bug 8312980\n+ * @summary C2: \"malformed control flow\" created during incremental inlining\n+ * @requires vm.compiler2.enabled\n+ * @run main\/othervm -XX:-TieredCompilation -XX:-BackgroundCompilation -XX:+IgnoreUnrecognizedVMOptions -XX:+AlwaysIncrementalInline TestReplacedNodesAfterLateInline\n+ *\/\n+\n+public class TestReplacedNodesAfterLateInline {\n+    private static B fieldB = new B();\n+    private static A fieldA = new A();\n+    private static volatile int volatileField;\n+\n+    public static void main(String[] args) {\n+        for (int i = 0; i < 20_000; i++) {\n+            test(false, fieldA, true);\n+            test(false, fieldA, false);\n+            testHelper(fieldB);\n+            testHelper2(fieldB, true, false, true);\n+            testHelper2(fieldA, false, true, true);\n+            continue;\n+        }\n+    }\n+\n+    private static int test(boolean flag, Object o, boolean flag2) {\n+        if (o == null) {\n+        }\n+        if (flag2) {\n+            return testHelper2(o, true, true, flag);\n+        }\n+        return ((A) o).field;\n+    }\n+\n+    private static int testHelper2(Object o, boolean flag, boolean flag2, boolean flag3) {\n+        if (flag3) {\n+            if (flag) {\n+                testHelper(o);\n+            }\n+            if (flag2) {\n+                return ((A) o).field;\n+            }\n+        }\n+        volatileField = 42;\n+        return volatileField;\n+    }\n+\n+    private static void testHelper(Object o) {\n+        B b = (B)o;\n+    }\n+\n+    private static class A {\n+        public int field;\n+    }\n+\n+    private static class B {\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/inlining\/TestReplacedNodesAfterLateInline.java","additions":80,"deletions":0,"binary":false,"changes":80,"status":"added"}]}