{"files":[{"patch":"@@ -109,14 +109,0 @@\n-static void enqueue_use(Node* n, Node* use, Unique_Node_List& work) {\n-  if (use->is_Phi()) {\n-    Node* r = use->in(0);\n-    assert(r->is_Region(), \"Phi should have Region\");\n-    for (uint i = 1; i < use->req(); i++) {\n-      if (use->in(i) == n) {\n-        work.push(r->in(i));\n-      }\n-    }\n-  } else {\n-    work.push(use);\n-  }\n-}\n-\n@@ -129,0 +115,6 @@\n+  ResourceMark rm;\n+  Node_Stack stack(0);\n+  Unique_Node_List to_fix; \/\/ nodes to clone + uses at the end of the chain that need to updated\n+  VectorSet seen;\n+  VectorSet valid_control;\n+\n@@ -135,5 +127,3 @@\n-    ResourceMark rm;\n-    Unique_Node_List work;\n-    \/\/ Go over all the uses of the node that is considered for replacement...\n-    for (DUIterator j = initial->outs(); initial->has_out(j); j++) {\n-      Node* use = initial->out(j);\n+    if (initial->outcnt() == 0) {\n+      continue;\n+    }\n@@ -141,11 +131,20 @@\n-      if (use == improved || use->outcnt() == 0) {\n-        continue;\n-      }\n-      work.clear();\n-      enqueue_use(initial, use, work);\n-      bool replace = true;\n-      \/\/ Check that this use is dominated by ctl. Go ahead with the replacement if it is.\n-      while (work.size() != 0 && replace) {\n-        Node* n = work.pop();\n-        if (use->outcnt() == 0) {\n-          continue;\n+    \/\/ Find uses of initial that are dominated by ctl so, initial can be replaced by improved.\n+    \/\/ Proving domination here is not straightforward. To do so, we follow uses of initial, and uses of uses until we\n+    \/\/ encounter a node which is a control node or is pinned at some control. Then, we try to prove this control is\n+    \/\/ dominated by ctl. If that's the case, it's legal to replace initial by improved but for this chain of uses only.\n+    \/\/ It may not be the case for some other chain of uses, so we clone that chain and perform the replacement only for\n+    \/\/ these uses.\n+    assert(stack.is_empty(), \"\");\n+    stack.push(initial, 1);\n+    Node* use = initial->raw_out(0);\n+    stack.push(use, 0);\n+\n+    while (!stack.is_empty()) {\n+      assert(stack.size() > 1, \"at least initial + one use\");\n+      Node* n = stack.node();\n+\n+      uint current_size = stack.size();\n+\n+      if (seen.test_set(n->_idx)) {\n+        if (to_fix.member(n)) {\n+          collect_nodes_to_clone(stack, to_fix);\n@@ -153,4 +152,14 @@\n-        if (n->is_CFG() || (n->in(0) != nullptr && !n->in(0)->is_top())) {\n-          \/\/ Skip projections, since some of the multi nodes aren't CFG (e.g., LoadStore and SCMemProj).\n-          if (n->is_Proj()) {\n-            n = n->in(0);\n+      } else if (n->outcnt() != 0 && n != improved) {\n+        if (n->is_Phi()) {\n+          Node* region = n->in(0);\n+          Node* prev = stack.node_at(stack.size() - 2);\n+          for (uint j = 1; j < region->req(); ++j) {\n+            if (n->in(j) == prev) {\n+              Node* in = region->in(j);\n+              if (in != nullptr && !in->is_top()) {\n+                if (is_dominator(ctl, in)) {\n+                  valid_control.set(in->_idx);\n+                  collect_nodes_to_clone(stack, to_fix);\n+                }\n+              }\n+            }\n@@ -158,2 +167,3 @@\n-          if (!n->is_CFG()) {\n-            n = n->in(0);\n+        } else if (n->is_CFG()) {\n+          if (is_dominator(ctl, n)) {\n+            collect_nodes_to_clone(stack, to_fix);\n@@ -161,10 +171,4 @@\n-          assert(n->is_CFG(), \"should be CFG now\");\n-          int depth = 0;\n-          while(n != ctl) {\n-            n = IfNode::up_one_dom(n);\n-            depth++;\n-            \/\/ limit search depth\n-            if (depth >= 100 || n == nullptr) {\n-              replace = false;\n-              break;\n-            }\n+        } else if (n->in(0) != nullptr && n->in(0)->is_CFG()) {\n+          Node* c = n->in(0);\n+          if (is_dominator(ctl, c)) {\n+            collect_nodes_to_clone(stack, to_fix);\n@@ -173,2 +177,4 @@\n-          for (DUIterator k = n->outs(); n->has_out(k); k++) {\n-            enqueue_use(n, n->out(k), work);\n+          uint idx = stack.index();\n+          if (idx < n->outcnt()) {\n+            stack.set_index(idx + 1);\n+            stack.push(n->raw_out(idx), 0);\n@@ -178,5 +184,13 @@\n-      if (replace) {\n-        bool is_in_table = C->initial_gvn()->hash_delete(use);\n-        int replaced = use->replace_edge(initial, improved);\n-        if (is_in_table) {\n-          C->initial_gvn()->hash_find_insert(use);\n+      if (stack.size() == current_size) {\n+        for (;;) {\n+          stack.pop();\n+          if (stack.is_empty()) {\n+            break;\n+          }\n+          n = stack.node();\n+          uint idx = stack.index();\n+          if (idx < n->outcnt()) {\n+            stack.set_index(idx + 1);\n+            stack.push(n->raw_out(idx), 0);\n+            break;\n+          }\n@@ -184,1 +198,25 @@\n-        C->record_for_igvn(use);\n+      }\n+    }\n+  }\n+  if (to_fix.size() > 0) {\n+    uint hash_table_size = _replaced_nodes->length();\n+    for (uint i = 0; i < to_fix.size(); ++i) {\n+      Node* n = to_fix.at(i);\n+      if (n->is_CFG() || n->in(0) != nullptr) { \/\/ End of a chain is not cloned\n+        continue;\n+      }\n+      hash_table_size++;\n+    }\n+    \/\/ Map from current node to cloned\/replaced node\n+    ResizeableResourceHashtable<Node*, Node*, AnyObj::RESOURCE_AREA, mtCompiler> clones(hash_table_size, hash_table_size);\n+    \/\/ Record mapping from initial to improved nodes\n+    for (int i = 0; i < _replaced_nodes->length(); i++) {\n+      ReplacedNode replaced = _replaced_nodes->at(i);\n+      Node* initial = replaced.initial();\n+      Node* improved = replaced.improved();\n+      clones.put(initial, improved);\n+      \/\/ If initial needs to be cloned but is also improved then there's no need to clone it.\n+      if (to_fix.member(initial)) {\n+        to_fix.remove(initial);\n+      }\n+    }\n@@ -186,2 +224,5 @@\n-        assert(replaced > 0, \"inconsistent\");\n-        --j;\n+    \/\/ Clone nodes and record mapping from current to cloned nodes\n+    for (uint i = 0; i < to_fix.size(); ++i) {\n+      Node* n = to_fix.at(i);\n+      if (n->is_CFG() || n->in(0) != nullptr) { \/\/ End of a chain\n+        continue;\n@@ -189,0 +230,45 @@\n+      Node* clone = n->clone();\n+      bool added = clones.put(n, clone);\n+      assert(added, \"\");\n+      C->initial_gvn()->set_type_bottom(clone);\n+      to_fix.map(i, clone); \/\/ Update list of nodes with cloned node\n+    }\n+\n+    \/\/ Fix edges in cloned nodes and use at the end of the chain\n+    for (uint i = 0; i < to_fix.size(); ++i) {\n+      Node* n = to_fix.at(i);\n+      bool is_in_table = C->initial_gvn()->hash_delete(n);\n+      uint updates = 0;\n+      for (uint j = 0; j < n->req(); ++j) {\n+        Node* in = n->in(j);\n+        if (in == nullptr || (n->is_Phi() && n->in(0)->in(j) == nullptr)) {\n+          continue;\n+        }\n+        if (n->is_Phi() && !valid_control.test(n->in(0)->in(j)->_idx)) {\n+          continue;\n+        }\n+        Node** clone_ptr = clones.get(in);\n+        if (clone_ptr != nullptr) {\n+          Node* clone = *clone_ptr;\n+          n->set_req(j, clone);\n+          updates++;\n+        }\n+      }\n+      assert(updates > 0, \"\");\n+      C->record_for_igvn(n);\n+      if (is_in_table) {\n+        C->initial_gvn()->hash_find_insert(n);\n+      }\n+    }\n+  }\n+}\n+\n+bool ReplacedNodes::is_dominator(const Node* ctl, Node* n) const {\n+  assert(n->is_CFG(), \"should be CFG now\");\n+  int depth = 0;\n+  while (n != ctl) {\n+    n = IfNode::up_one_dom(n);\n+    depth++;\n+    \/\/ limit search depth\n+    if (depth >= 100 || n == nullptr) {\n+      return false;\n@@ -191,0 +277,1 @@\n+  return true;\n@@ -227,0 +314,7 @@\n+\n+void ReplacedNodes::collect_nodes_to_clone(const Node_Stack& stack, Unique_Node_List& to_fix) {\n+  for (uint i = stack.size() - 1; i >= 1; i--) {\n+    Node* n = stack.node_at(i);\n+    to_fix.push(n);\n+  }\n+}\n","filename":"src\/hotspot\/share\/opto\/replacednodes.cpp","additions":150,"deletions":56,"binary":false,"changes":206,"status":"modified"},{"patch":"@@ -79,0 +79,4 @@\n+\n+  bool is_dominator(const Node* ctl, Node* n) const;\n+\n+  void collect_nodes_to_clone(const Node_Stack& stack, Unique_Node_List& to_fix);\n","filename":"src\/hotspot\/share\/opto\/replacednodes.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,80 @@\n+\/*\n+ * Copyright (c) 2023, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * bug 8312980\n+ * @summary C2: \"malformed control flow\" created during incremental inlining\n+ * @requires vm.compiler2.enabled\n+ * @run main\/othervm -XX:-TieredCompilation -XX:-BackgroundCompilation -XX:+IgnoreUnrecognizedVMOptions -XX:+AlwaysIncrementalInline TestReplacedNodesAfterLateInline\n+ *\/\n+\n+public class TestReplacedNodesAfterLateInline {\n+    private static B fieldB = new B();\n+    private static A fieldA = new A();\n+    private static volatile int volatileField;\n+\n+    public static void main(String[] args) {\n+        for (int i = 0; i < 20_000; i++) {\n+            test(false, fieldA, true);\n+            test(false, fieldA, false);\n+            testHelper(fieldB);\n+            testHelper2(fieldB, true, false, true);\n+            testHelper2(fieldA, false, true, true);\n+            continue;\n+        }\n+    }\n+\n+    private static int test(boolean flag, Object o, boolean flag2) {\n+        if (o == null) {\n+        }\n+        if (flag2) {\n+            return testHelper2(o, true, true, flag);\n+        }\n+        return ((A) o).field;\n+    }\n+\n+    private static int testHelper2(Object o, boolean flag, boolean flag2, boolean flag3) {\n+        if (flag3) {\n+            if (flag) {\n+                testHelper(o);\n+            }\n+            if (flag2) {\n+                return ((A) o).field;\n+            }\n+        }\n+        volatileField = 42;\n+        return volatileField;\n+    }\n+\n+    private static void testHelper(Object o) {\n+        B b = (B)o;\n+    }\n+\n+    private static class A {\n+        public int field;\n+    }\n+\n+    private static class B {\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/inlining\/TestReplacedNodesAfterLateInline.java","additions":80,"deletions":0,"binary":false,"changes":80,"status":"added"},{"patch":"@@ -0,0 +1,72 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * bug 8312980\n+ * @summary C2: \"malformed control flow\" created during incremental inlining\n+ * @requires vm.compiler2.enabled\n+ * @run main\/othervm -XX:+AlwaysIncrementalInline -XX:CompileCommand=compileonly,TestReplacedNodesAfterLateInlineManyPaths::*\n+ *                   -Xbatch TestReplacedNodesAfterLateInlineManyPaths\n+ *\/\n+\n+public class TestReplacedNodesAfterLateInlineManyPaths {\n+    public static void main(String[] args) {\n+        for (int i = 0; i < 20_000; i++) {\n+            test(\"\" + i);\n+        }\n+    }\n+\n+    public static int test(String s) {\n+        int result = 0;\n+        int len = s.length();\n+        int i = 0;\n+        while (i < len) {\n+            \/\/ charAt is inlined late, and i is constrained by CastII(i >= 0)\n+            \/\/ The constraint comes from intrinsic checkIndex\n+            s.charAt(i);\n+            \/\/ Graph below intentionally branches out 4x, and merges again (4-fold diamonds).\n+            \/\/ This creates an exponential explosion in number of paths.\n+            int e = i;\n+            e = (e & 7) + (e & 31) + (e & 1111) + (e & 1000_000);\n+            e = (e & 7) + (e & 31) + (e & 1111) + (e & 1000_000);\n+            e = (e & 7) + (e & 31) + (e & 1111) + (e & 1000_000);\n+            e = (e & 7) + (e & 31) + (e & 1111) + (e & 1000_000);\n+            e = (e & 7) + (e & 31) + (e & 1111) + (e & 1000_000);\n+            \/\/ Comment out lines below to make it not assert\n+            \/\/ assert(C->live_nodes() <= C->max_node_limit()) failed: Live Node limit exceeded limit\n+            e = (e & 7) + (e & 31) + (e & 1111) + (e & 1000_000);\n+            e = (e & 7) + (e & 31) + (e & 1111) + (e & 1000_000);\n+            e = (e & 7) + (e & 31) + (e & 1111) + (e & 1000_000);\n+            e = (e & 7) + (e & 31) + (e & 1111) + (e & 1000_000);\n+            e = (e & 7) + (e & 31) + (e & 1111) + (e & 1000_000);\n+            e = (e & 7) + (e & 31) + (e & 1111) + (e & 1000_000);\n+            e = (e & 7) + (e & 31) + (e & 1111) + (e & 1000_000);\n+            e = (e & 7) + (e & 31) + (e & 1111) + (e & 1000_000);\n+            e = (e & 7) + (e & 31) + (e & 1111) + (e & 1000_000);\n+            result += e;\n+            i++;\n+        }\n+        return result;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/inlining\/TestReplacedNodesAfterLateInlineManyPaths.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"added"}]}