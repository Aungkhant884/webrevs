{"files":[{"patch":"@@ -117,0 +117,4 @@\n+  Unique_Node_List to_fix; \/\/ nodes to clone + uses at the end of the chain that need to updated\n+  VectorSet seen;\n+  VectorSet valid_control;\n+\n@@ -143,1 +147,6 @@\n-      if (n->outcnt() != 0 && n != improved) {\n+\n+      if (seen.test_set(n->_idx)) {\n+        if (to_fix.member(n)) {\n+          collect_nodes_to_clone(stack, to_fix);\n+        }\n+      } else if (n->outcnt() != 0 && n != improved) {\n@@ -152,1 +161,2 @@\n-                  clone_uses_and_replace(C, initial, improved, stack, j);\n+                  valid_control.set(in->_idx);\n+                  collect_nodes_to_clone(stack, to_fix);\n@@ -159,1 +169,1 @@\n-            clone_uses_and_replace(C, initial, improved, stack, -1);\n+            collect_nodes_to_clone(stack, to_fix);\n@@ -161,1 +171,1 @@\n-        } else if (n->in(0) != nullptr && !n->in(0)->is_top()) {\n+        } else if (n->in(0) != nullptr && n->in(0)->is_CFG()) {\n@@ -164,1 +174,1 @@\n-            clone_uses_and_replace(C, initial, improved, stack, -1);\n+            collect_nodes_to_clone(stack, to_fix);\n@@ -191,1 +201,22 @@\n-}\n+  if (to_fix.size() > 0) {\n+    uint hash_table_size = _replaced_nodes->length();\n+    for (uint i = 0; i < to_fix.size(); ++i) {\n+      Node* n = to_fix.at(i);\n+      if (n->is_CFG() || n->in(0) != nullptr) { \/\/ End of a chain is not cloned\n+        continue;\n+      }\n+      hash_table_size++;\n+    }\n+    \/\/ Map from current node to cloned\/replaced node\n+    ResizeableResourceHashtable<Node*, Node*, AnyObj::RESOURCE_AREA, mtCompiler> clones(hash_table_size, hash_table_size);\n+    \/\/ Record mapping from initial to improved nodes\n+    for (int i = 0; i < _replaced_nodes->length(); i++) {\n+      ReplacedNode replaced = _replaced_nodes->at(i);\n+      Node* initial = replaced.initial();\n+      Node* improved = replaced.improved();\n+      clones.put(initial, improved);\n+      \/\/ If initial needs to be cloned but is also improved then there's no need to clone it.\n+      if (to_fix.member(initial)) {\n+        to_fix.remove(initial);\n+      }\n+    }\n@@ -193,15 +224,11 @@\n-\/\/ Clone all nodes on the stack and replace initial by improved for the use at the bottom of the stack\n-void ReplacedNodes::clone_uses_and_replace(Compile* C, Node* initial, Node* improved, const Node_Stack& stack, int i) const {\n-  Node* prev = stack.node();\n-  for (uint k = stack.size() - 2; k > 0 ; k--) {\n-    Node* n = stack.node_at(k);\n-    Node* clone = n->clone();\n-    bool is_in_table = C->initial_gvn()->hash_delete(prev);\n-    if (i == -1) {\n-      int replaced = prev->replace_edge(n, clone);\n-      assert(replaced > 0, \"expected some use\");\n-    } else {\n-      assert(k == (stack.size() - 2) && prev->is_Phi(), \"\");\n-      assert(prev->in(i) == n, \"not a use?\");\n-      prev->set_req(i, clone);\n-      i = -1;\n+    \/\/ Clone nodes and record mapping from current to cloned nodes\n+    for (uint i = 0; i < to_fix.size(); ++i) {\n+      Node* n = to_fix.at(i);\n+      if (n->is_CFG() || n->in(0) != nullptr) { \/\/ End of a chain\n+        continue;\n+      }\n+      Node* clone = n->clone();\n+      bool added = clones.put(n, clone);\n+      assert(added, \"\");\n+      C->initial_gvn()->set_type_bottom(clone);\n+      to_fix.map(i, clone); \/\/ Update list of nodes with cloned node\n@@ -209,3 +236,26 @@\n-    C->record_for_igvn(prev);\n-    if (is_in_table) {\n-      C->initial_gvn()->hash_find_insert(prev);\n+\n+    \/\/ Fix edges in cloned nodes and use at the end of the chain\n+    for (uint i = 0; i < to_fix.size(); ++i) {\n+      Node* n = to_fix.at(i);\n+      bool is_in_table = C->initial_gvn()->hash_delete(n);\n+      uint updates = 0;\n+      for (uint j = 0; j < n->req(); ++j) {\n+        Node* in = n->in(j);\n+        if (in == nullptr || (n->is_Phi() && n->in(0)->in(j) == nullptr)) {\n+          continue;\n+        }\n+        if (n->is_Phi() && !valid_control.test(n->in(0)->in(j)->_idx)) {\n+          continue;\n+        }\n+        Node** clone_ptr = clones.get(in);\n+        if (clone_ptr != nullptr) {\n+          Node* clone = *clone_ptr;\n+          n->set_req(j, clone);\n+          updates++;\n+        }\n+      }\n+      assert(updates > 0, \"\");\n+      C->record_for_igvn(n);\n+      if (is_in_table) {\n+        C->initial_gvn()->hash_find_insert(n);\n+      }\n@@ -213,15 +263,0 @@\n-    C->initial_gvn()->set_type_bottom(clone);\n-    prev = clone;\n-  }\n-  bool is_in_table = C->initial_gvn()->hash_delete(prev);\n-  if (i == -1) {\n-    int replaced = prev->replace_edge(initial, improved);\n-    assert(replaced > 0, \"expected some use\");\n-  } else {\n-    assert(prev->is_Phi(), \"only for Phis\");\n-    assert(prev->in(i) == initial, \"not a use?\");\n-    prev->set_req(i, improved);\n-  }\n-  C->record_for_igvn(prev);\n-  if (is_in_table) {\n-    C->initial_gvn()->hash_find_insert(prev);\n@@ -279,0 +314,7 @@\n+\n+void ReplacedNodes::collect_nodes_to_clone(const Node_Stack& stack, Unique_Node_List& to_fix) {\n+  for (uint i = stack.size() - 1; i >= 1; i--) {\n+    Node* n = stack.node_at(i);\n+    to_fix.push(n);\n+  }\n+}\n","filename":"src\/hotspot\/share\/opto\/replacednodes.cpp","additions":81,"deletions":39,"binary":false,"changes":120,"status":"modified"},{"patch":"@@ -82,1 +82,1 @@\n-  void clone_uses_and_replace(Compile* C, Node* initial, Node* improved, const Node_Stack& stack, int i) const;\n+  void collect_nodes_to_clone(const Node_Stack& stack, Unique_Node_List& to_fix);\n","filename":"src\/hotspot\/share\/opto\/replacednodes.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,72 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * bug 8312980\n+ * @summary C2: \"malformed control flow\" created during incremental inlining\n+ * @requires vm.compiler2.enabled\n+ * @run main\/othervm -XX:+AlwaysIncrementalInline -XX:CompileCommand=compileonly,TestReplacedNodesAfterLateInlineManyPaths::*\n+ *                   -Xbatch TestReplacedNodesAfterLateInlineManyPaths\n+ *\/\n+\n+public class TestReplacedNodesAfterLateInlineManyPaths {\n+    public static void main(String[] args) {\n+        for (int i = 0; i < 20_000; i++) {\n+            test(\"\" + i);\n+        }\n+    }\n+\n+    public static int test(String s) {\n+        int result = 0;\n+        int len = s.length();\n+        int i = 0;\n+        while (i < len) {\n+            \/\/ charAt is inlined late, and i is constrained by CastII(i >= 0)\n+            \/\/ The constraint comes from intrinsic checkIndex\n+            s.charAt(i);\n+            \/\/ Graph below intentionally branches out 4x, and merges again (4-fold diamonds).\n+            \/\/ This creates an exponential explosion in number of paths.\n+            int e = i;\n+            e = (e & 7) + (e & 31) + (e & 1111) + (e & 1000_000);\n+            e = (e & 7) + (e & 31) + (e & 1111) + (e & 1000_000);\n+            e = (e & 7) + (e & 31) + (e & 1111) + (e & 1000_000);\n+            e = (e & 7) + (e & 31) + (e & 1111) + (e & 1000_000);\n+            e = (e & 7) + (e & 31) + (e & 1111) + (e & 1000_000);\n+            \/\/ Comment out lines below to make it not assert\n+            \/\/ assert(C->live_nodes() <= C->max_node_limit()) failed: Live Node limit exceeded limit\n+            e = (e & 7) + (e & 31) + (e & 1111) + (e & 1000_000);\n+            e = (e & 7) + (e & 31) + (e & 1111) + (e & 1000_000);\n+            e = (e & 7) + (e & 31) + (e & 1111) + (e & 1000_000);\n+            e = (e & 7) + (e & 31) + (e & 1111) + (e & 1000_000);\n+            e = (e & 7) + (e & 31) + (e & 1111) + (e & 1000_000);\n+            e = (e & 7) + (e & 31) + (e & 1111) + (e & 1000_000);\n+            e = (e & 7) + (e & 31) + (e & 1111) + (e & 1000_000);\n+            e = (e & 7) + (e & 31) + (e & 1111) + (e & 1000_000);\n+            e = (e & 7) + (e & 31) + (e & 1111) + (e & 1000_000);\n+            result += e;\n+            i++;\n+        }\n+        return result;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/inlining\/TestReplacedNodesAfterLateInlineManyPaths.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"added"}]}