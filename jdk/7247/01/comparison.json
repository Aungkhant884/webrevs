{"files":[{"patch":"@@ -716,1 +716,2 @@\n-  \/\/ Quick & dirty stack overflow checking: bang the stack & handle trap.\n+  \/\/ See more discussion in stackOverflow.hpp.\n+\n@@ -722,1 +723,1 @@\n-  \/\/ method receiever, so do the banging after locking the receiver.)\n+  \/\/ method receiver, so do the banging after locking the receiver.)\n@@ -724,3 +725,1 @@\n-  \/\/ Bang each page in the shadow zone. We can't assume it's been done for\n-  \/\/ an interpreter frame with greater than a page of locals, so each page\n-  \/\/ needs to be checked.  Only true for non-native.\n+  const int shadow_zone_size = checked_cast<int>(StackOverflow::stack_shadow_zone_size());\n@@ -728,5 +727,40 @@\n-  const int n_shadow_pages = ((int)StackOverflow::stack_shadow_zone_size()) \/ page_size;\n-  const int start_page = native_call ? n_shadow_pages : 1;\n-  for (int pages = start_page; pages <= n_shadow_pages; pages++) {\n-    __ bang_stack_with_offset(pages*page_size);\n-  }\n+  const int n_shadow_pages = shadow_zone_size \/ page_size;\n+\n+  const Register thread = NOT_LP64(rsi) LP64_ONLY(r15_thread);\n+#ifndef _LP64\n+  __ push(thread);\n+  __ get_thread(thread);\n+#endif\n+\n+#ifdef ASSERT\n+  Label L_good_limit;\n+  __ cmpptr(Address(thread, JavaThread::shadow_zone_safe_limit()), (int32_t)NULL_WORD);\n+  __ jcc(Assembler::notEqual, L_good_limit);\n+    __ stop(\"shadow zone safe limit is not initialized\");\n+  __ bind(L_good_limit);\n+\n+  Label L_good_watermark;\n+  __ cmpptr(Address(thread, JavaThread::shadow_zone_growth_watermark()), (int32_t)NULL_WORD);\n+  __ jcc(Assembler::notEqual, L_good_watermark);\n+    __ stop(\"shadow zone growth watermark is not initialized\");\n+  __ bind(L_good_watermark);\n+#endif\n+\n+  Label L_done;\n+\n+  __ cmpptr(rsp, Address(thread, JavaThread::shadow_zone_growth_watermark()));\n+  __ jcc(Assembler::above, L_done);\n+\n+    for (int p = 1; p <= n_shadow_pages; p++) {\n+      __ bang_stack_with_offset(p*page_size);\n+    }\n+\n+    __ cmpptr(rsp, Address(thread, JavaThread::shadow_zone_safe_limit()));\n+    __ jccb(Assembler::belowEqual, L_done);\n+      __ movptr(Address(thread, JavaThread::shadow_zone_growth_watermark()), rsp);\n+\n+  __ bind(L_done);\n+\n+#ifndef _LP64\n+  __ pop(thread);\n+#endif\n","filename":"src\/hotspot\/cpu\/x86\/templateInterpreterGenerator_x86.cpp","additions":44,"deletions":10,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -383,1 +383,1 @@\n-  \/\/ stack_shadow_pages_available() and bang_stack_shadow_pages() use the same sp.\n+  \/\/ stack_shadow_pages_available() and map_stack_shadow_pages() use the same sp.\n","filename":"src\/hotspot\/share\/runtime\/javaCalls.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1387,1 +1387,1 @@\n-  \/\/ Check if we have StackShadowPages above the yellow zone.  This parameter\n+  \/\/ Check if we have StackShadowPages above the guard zone. This parameter\n@@ -1395,3 +1395,1 @@\n-  address limit = JavaThread::cast(thread)->stack_end() +\n-                  (StackOverflow::stack_guard_zone_size() + StackOverflow::stack_shadow_zone_size());\n-\n+  address limit = JavaThread::cast(thread)->stack_overflow_state()->shadow_zone_safe_limit();\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -54,0 +54,2 @@\n+    _shadow_zone_safe_limit(nullptr),\n+    _shadow_zone_growth_watermark(nullptr),\n@@ -61,0 +63,1 @@\n+    set_shadow_zone_limits();\n@@ -71,0 +74,2 @@\n+  address          _shadow_zone_safe_limit;\n+  address          _shadow_zone_growth_watermark;\n@@ -80,0 +85,3 @@\n+  \/\/ --------------------------------------------------------------------------------\n+  \/\/\n+  \/\/ The Java thread stack is structured as follows:\n@@ -98,5 +106,8 @@\n-  \/\/  --  <-- stack_reserved_zone_base()    ---      ---\n-  \/\/                                                 \/|\\  shadow     <--  stack_overflow_limit() (somewhere in here)\n-  \/\/                                                  |   zone\n-  \/\/                                                 \\|\/  size\n-  \/\/  some untouched memory                          ---\n+  \/\/  --  <-- stack_reserved_zone_base()    ---   ---\n+  \/\/                                               ^\n+  \/\/                                               |    <--  stack_overflow_limit() [somewhere in here]\n+  \/\/                                               |  shadow\n+  \/\/                                               |   zone\n+  \/\/                                               |   size\n+  \/\/                                               v\n+  \/\/                                              ---   <--  shadow_zone_safe_limit()\n@@ -104,0 +115,1 @@\n+  \/\/ (some usable, but not yet touched memory)\n@@ -109,1 +121,1 @@\n-  \/\/  --\n+  \/\/  --                                          ---   <--  shadow_zone_growth_watermark()\n@@ -123,0 +135,77 @@\n+  \/\/\n+  \/\/ The stack overflow mechanism detects overflows by touching (\"banging\") the stack\n+  \/\/ ahead of current stack pointer (SP). The entirety of guard zone is memory protected,\n+  \/\/ therefore such access would trap when touching the guard zone, and one of the following\n+  \/\/ things would happen.\n+  \/\/\n+  \/\/ Access in the red zone: unrecoverable stack overflow. Crash the VM, generate a report,\n+  \/\/ crash dump, and other diagnostics.\n+  \/\/\n+  \/\/ Access in the yellow zone: recoverable, reportable stack overflow. Create and throw\n+  \/\/ a StackOverflowError, remove the protection of yellow zone temporarily to let exception\n+  \/\/ handlers run. If exception handlers themselves run out of stack, they will crash VM due\n+  \/\/ to access to red zone.\n+  \/\/\n+  \/\/ Access in the reserved zone: recoverable, reportable, transparent for privileged methods\n+  \/\/ stack overflow. Perform a stack walk to check if there's a method annotated with\n+  \/\/ @ReservedStackAccess on the call stack. If such method is found, remove the protection of\n+  \/\/ reserved zone temporarily, and let the method run. If not, handle the access like a yellow\n+  \/\/ zone trap.\n+  \/\/\n+  \/\/ The banging itself happens within the \"shadow zone\" that extends from the current SP.\n+  \/\/\n+  \/\/ The goals for properly implemented shadow zone banging are:\n+  \/\/\n+  \/\/  a) Allow native\/VM methods to run without stack overflow checks within some reasonable\n+  \/\/     headroom. Default shadow zone size should accommodate the largest normally expected\n+  \/\/     native\/VM stack use.\n+  \/\/  b) Guarantee the stack overflow checks work even if SP is dangerously close to guard zone.\n+  \/\/     If SP is very low, banging at the edge of shadow zone (SP+shadow-zone-size) can slip\n+  \/\/     into adjacent thread stack, or even into other readable memory. This would potentially\n+  \/\/     pass the check by accident.\n+  \/\/  c) Allow for incremental stack growth on some OSes. This is enabled by handling traps\n+  \/\/     from not yet committed thread stacks, even outside the guard zone. The banging should\n+  \/\/     not allow uncommitted \"gaps\" on thread stack. See for example the uses of\n+  \/\/     os::map_stack_shadow_pages().\n+  \/\/  d) Make sure the stack overflow trap happens in the code that is known to runtime, so\n+  \/\/     the traps can be reasonably handled: handling a spurious trap from executing Java code\n+  \/\/     is hard, while properly handling the trap from VM\/native code is nearly impossible.\n+  \/\/\n+  \/\/ The simplest code that satisfies all these requirements is banging the shadow zone\n+  \/\/ page by page at every Java\/native method entry.\n+  \/\/\n+  \/\/ While that code is sufficient, it comes with the large performance cost. This performance\n+  \/\/ cost can be reduced by several *optional* techniques:\n+  \/\/\n+  \/\/ 1. Guarantee that stack would not take another page. If so, the current bang was\n+  \/\/ enough to verify we are not near the guard zone. This kind of insight is usually only\n+  \/\/ available for compilers that can know the size of the frame exactly.\n+  \/\/\n+  \/\/ Examples: PhaseOutput::need_stack_bang.\n+  \/\/\n+  \/\/ 2. Check the current SP in relation to shadow zone safe limit.\n+  \/\/\n+  \/\/ Define \"safe limit\" as the highest SP where banging would not touch the guard zone.\n+  \/\/ Then, do the page-by-page bang only if current SP is above that safe limit, OR some\n+  \/\/ OS-es need it to get the stack mapped.\n+  \/\/\n+  \/\/ Examples: AbstractAssembler::generate_stack_overflow_check, JavaCalls::call_helper,\n+  \/\/ os::stack_shadow_pages_available, os::map_stack_shadow_pages and their uses.\n+  \/\/\n+  \/\/ 3. Check the current SP in relation to the shadow zone growth watermark.\n+  \/\/\n+  \/\/ Define \"shadow zone growth watermark\" as the highest SP where we banged already.\n+  \/\/ Note that growth watermark is always above the safe limit.\n+  \/\/\n+  \/\/ Easy and overwhelmingly frequent case: SP is above the growth watermark, and\n+  \/\/ by extension above the safe limit. In this case, we know that the guard zone is far away\n+  \/\/ (safe limit), and that the stack was banged before for stack growth (growth watermark).\n+  \/\/ Therefore, we can skip the banging altogether.\n+  \/\/\n+  \/\/ Harder cases: SP is below the growth watermark. In might be due to two things:\n+  \/\/ we have not banged the stack for growth (below growth watermark only), or we are\n+  \/\/ close to guard zone (also below safe limit). Do the full banging. Once done, we\n+  \/\/ can adjust the growth watermark, thus recording the bang for stack growth had\n+  \/\/ happened.\n+  \/\/\n+  \/\/ Examples: TemplateInterpreterGenerator::bang_stack_shadow_pages on x86 and others.\n@@ -192,0 +281,5 @@\n+  address shadow_zone_safe_limit() const {\n+    assert(_shadow_zone_safe_limit != nullptr, \"Don't call this before the field is initialized.\");\n+    return _shadow_zone_safe_limit;\n+  }\n+\n@@ -245,0 +339,7 @@\n+\n+  void set_shadow_zone_limits() {\n+    _shadow_zone_safe_limit =\n+      stack_end() + stack_guard_zone_size() + stack_shadow_zone_size();\n+    _shadow_zone_growth_watermark =\n+      stack_base();\n+  }\n","filename":"src\/hotspot\/share\/runtime\/stackOverflow.hpp","additions":107,"deletions":6,"binary":false,"changes":113,"status":"modified"},{"patch":"@@ -1302,0 +1302,6 @@\n+  static ByteSize shadow_zone_safe_limit()  {\n+    return byte_offset_of(JavaThread, _stack_overflow_state._shadow_zone_safe_limit);\n+  }\n+  static ByteSize shadow_zone_growth_watermark()  {\n+    return byte_offset_of(JavaThread, _stack_overflow_state._shadow_zone_growth_watermark);\n+  }\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -78,0 +78,28 @@\n+# Temporary group for stack banging changes\n+hotspot_stack = \\\n+  compiler\/interpreter\/TestVerifyStackAfterDeopt.java \\\n+  compiler\/interpreter\/cr7116216\/StackOverflow.java \\\n+  compiler\/osr\/TestOSRWithNonEmptyStack.java \\\n+  compiler\/runtime\/TestFloatsOnStackDeopt.java \\\n+  compiler\/runtime\/StackOverflowBug.java \\\n+  compiler\/uncommontrap\/StackOverflowGuardPagesOff.java \\\n+  compiler\/uncommontrap\/TestStackBangRbp.java \\\n+  compiler\/uncommontrap\/TestStackBangMonitorOwned.java \\\n+  compiler\/uncommontrap\/UncommonTrapStackBang.java \\\n+  runtime\/ErrorHandling\/BadNativeStackInErrorHandlingTest.java \\\n+  runtime\/Locals\/TestLargeLocalVarsStackRegion.java \\\n+  runtime\/ReservedStack \\\n+  runtime\/NMT\/CheckForProperDetailStackTrace.java \\\n+  runtime\/StackGuardPages \\\n+  runtime\/StackTrace \\\n+  runtime\/Thread\/TestThreadStackSizes.java \\\n+  runtime\/Thread\/TooSmallStackSize.java \\\n+  runtime\/Throwable\/TestMaxJavaStackTraceDepth.java \\\n+  runtime\/Throwable\/StackTraceLogging.java \\\n+  runtime\/handshake\/ \\\n+  runtime\/logging\/StackWalkTest.java \\\n+  runtime\/reflect\/ReflectStackOverflow.java \\\n+  runtime\/whitebox\/WBStackSize.java \\\n+  serviceability\/jvmti\/GetLocalVariable\/GetLocalWithoutSuspendTest.java \\\n+  serviceability\/threads\/TestFalseDeadLock.java\n+\n","filename":"test\/hotspot\/jtreg\/TEST.groups","additions":28,"deletions":0,"binary":false,"changes":28,"status":"modified"}]}