{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -72,12 +72,0 @@\n-\/\/ macros for restartable system calls\n-\n-#define RESTARTABLE(_cmd, _result) do { \\\n-    _result = _cmd; \\\n-  } while(((int)_result == OS_ERR) && (errno == EINTR))\n-\n-#define RESTARTABLE_RETURN_INT(_cmd) do { \\\n-  int _result; \\\n-  RESTARTABLE(_cmd, _result); \\\n-  return _result; \\\n-} while(false)\n-\n@@ -94,4 +82,0 @@\n-inline int os::close(int fd) {\n-  return ::close(fd);\n-}\n-\n","filename":"src\/hotspot\/os\/aix\/os_aix.inline.hpp","additions":1,"deletions":17,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -1,1245 +0,0 @@\n-\/*\n- * Copyright (c) 2001, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2012, 2020 SAP SE. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"precompiled.hpp\"\n-#include \"classfile\/vmSymbols.hpp\"\n-#include \"logging\/log.hpp\"\n-#include \"memory\/allocation.inline.hpp\"\n-#include \"memory\/resourceArea.hpp\"\n-#include \"oops\/oop.inline.hpp\"\n-#include \"os_aix.inline.hpp\"\n-#include \"runtime\/handles.inline.hpp\"\n-#include \"runtime\/os.hpp\"\n-#include \"runtime\/perfMemory.hpp\"\n-#include \"services\/memTracker.hpp\"\n-#include \"utilities\/exceptions.hpp\"\n-\n-\/\/ put OS-includes here\n-# include <sys\/types.h>\n-# include <sys\/mman.h>\n-# include <errno.h>\n-# include <stdio.h>\n-# include <unistd.h>\n-# include <sys\/stat.h>\n-# include <signal.h>\n-# include <pwd.h>\n-\n-static char* backing_store_file_name = NULL;  \/\/ name of the backing store\n-                                              \/\/ file, if successfully created.\n-\n-\/\/ Standard Memory Implementation Details\n-\n-\/\/ create the PerfData memory region in standard memory.\n-\/\/\n-static char* create_standard_memory(size_t size) {\n-\n-  \/\/ allocate an aligned chuck of memory\n-  char* mapAddress = os::reserve_memory(size);\n-\n-  if (mapAddress == NULL) {\n-    return NULL;\n-  }\n-\n-  \/\/ commit memory\n-  if (!os::commit_memory(mapAddress, size, !ExecMem)) {\n-    if (PrintMiscellaneous && Verbose) {\n-      warning(\"Could not commit PerfData memory\\n\");\n-    }\n-    os::release_memory(mapAddress, size);\n-    return NULL;\n-  }\n-\n-  return mapAddress;\n-}\n-\n-\/\/ delete the PerfData memory region\n-\/\/\n-static void delete_standard_memory(char* addr, size_t size) {\n-\n-  \/\/ there are no persistent external resources to cleanup for standard\n-  \/\/ memory. since DestroyJavaVM does not support unloading of the JVM,\n-  \/\/ cleanup of the memory resource is not performed. The memory will be\n-  \/\/ reclaimed by the OS upon termination of the process.\n-  \/\/\n-  return;\n-}\n-\n-\/\/ save the specified memory region to the given file\n-\/\/\n-\/\/ Note: this function might be called from signal handler (by os::abort()),\n-\/\/ don't allocate heap memory.\n-\/\/\n-static void save_memory_to_file(char* addr, size_t size) {\n-\n-  const char* destfile = PerfMemory::get_perfdata_file_path();\n-  assert(destfile[0] != '\\0', \"invalid PerfData file path\");\n-\n-  int result;\n-\n-  RESTARTABLE(os::open(destfile, O_CREAT|O_WRONLY|O_TRUNC, S_IREAD|S_IWRITE),\n-              result);\n-  if (result == OS_ERR) {\n-    if (PrintMiscellaneous && Verbose) {\n-      warning(\"Could not create Perfdata save file: %s: %s\\n\",\n-              destfile, os::strerror(errno));\n-    }\n-  } else {\n-    int fd = result;\n-\n-    for (size_t remaining = size; remaining > 0;) {\n-\n-      RESTARTABLE(::write(fd, addr, remaining), result);\n-      if (result == OS_ERR) {\n-        if (PrintMiscellaneous && Verbose) {\n-          warning(\"Could not write Perfdata save file: %s: %s\\n\",\n-                  destfile, os::strerror(errno));\n-        }\n-        break;\n-      }\n-\n-      remaining -= (size_t)result;\n-      addr += result;\n-    }\n-\n-    result = ::close(fd);\n-    if (PrintMiscellaneous && Verbose) {\n-      if (result == OS_ERR) {\n-        warning(\"Could not close %s: %s\\n\", destfile, os::strerror(errno));\n-      }\n-    }\n-  }\n-  FREE_C_HEAP_ARRAY(char, destfile);\n-}\n-\n-\n-\/\/ Shared Memory Implementation Details\n-\n-\/\/ Note: the solaris and linux shared memory implementation uses the mmap\n-\/\/ interface with a backing store file to implement named shared memory.\n-\/\/ Using the file system as the name space for shared memory allows a\n-\/\/ common name space to be supported across a variety of platforms. It\n-\/\/ also provides a name space that Java applications can deal with through\n-\/\/ simple file apis.\n-\/\/\n-\/\/ The solaris and linux implementations store the backing store file in\n-\/\/ a user specific temporary directory located in the \/tmp file system,\n-\/\/ which is always a local file system and is sometimes a RAM based file\n-\/\/ system.\n-\n-\/\/ return the user specific temporary directory name.\n-\/\/\n-\/\/ the caller is expected to free the allocated memory.\n-\/\/\n-static char* get_user_tmp_dir(const char* user) {\n-\n-  const char* tmpdir = os::get_temp_directory();\n-  const char* perfdir = PERFDATA_NAME;\n-  size_t nbytes = strlen(tmpdir) + strlen(perfdir) + strlen(user) + 3;\n-  char* dirname = NEW_C_HEAP_ARRAY(char, nbytes, mtInternal);\n-\n-  \/\/ construct the path name to user specific tmp directory\n-  snprintf(dirname, nbytes, \"%s\/%s_%s\", tmpdir, perfdir, user);\n-\n-  return dirname;\n-}\n-\n-\/\/ convert the given file name into a process id. if the file\n-\/\/ does not meet the file naming constraints, return 0.\n-\/\/\n-static pid_t filename_to_pid(const char* filename) {\n-\n-  \/\/ a filename that doesn't begin with a digit is not a\n-  \/\/ candidate for conversion.\n-  \/\/\n-  if (!isdigit(*filename)) {\n-    return 0;\n-  }\n-\n-  \/\/ check if file name can be converted to an integer without\n-  \/\/ any leftover characters.\n-  \/\/\n-  char* remainder = NULL;\n-  errno = 0;\n-  pid_t pid = (pid_t)strtol(filename, &remainder, 10);\n-\n-  if (errno != 0) {\n-    return 0;\n-  }\n-\n-  \/\/ check for left over characters. If any, then the filename is\n-  \/\/ not a candidate for conversion.\n-  \/\/\n-  if (remainder != NULL && *remainder != '\\0') {\n-    return 0;\n-  }\n-\n-  \/\/ successful conversion, return the pid\n-  return pid;\n-}\n-\n-\/\/ Check if the given statbuf is considered a secure directory for\n-\/\/ the backing store files. Returns true if the directory is considered\n-\/\/ a secure location. Returns false if the statbuf is a symbolic link or\n-\/\/ if an error occurred.\n-\/\/\n-static bool is_statbuf_secure(struct stat *statp) {\n-  if (S_ISLNK(statp->st_mode) || !S_ISDIR(statp->st_mode)) {\n-    \/\/ The path represents a link or some non-directory file type,\n-    \/\/ which is not what we expected. Declare it insecure.\n-    \/\/\n-    return false;\n-  }\n-  \/\/ We have an existing directory, check if the permissions are safe.\n-  \/\/\n-  if ((statp->st_mode & (S_IWGRP|S_IWOTH)) != 0) {\n-    \/\/ The directory is open for writing and could be subjected\n-    \/\/ to a symlink or a hard link attack. Declare it insecure.\n-    \/\/\n-    return false;\n-  }\n-  \/\/ If user is not root then see if the uid of the directory matches the effective uid of the process.\n-  uid_t euid = geteuid();\n-  if ((euid != 0) && (statp->st_uid != euid)) {\n-    \/\/ The directory was not created by this user, declare it insecure.\n-    \/\/\n-    return false;\n-  }\n-  return true;\n-}\n-\n-\n-\/\/ Check if the given path is considered a secure directory for\n-\/\/ the backing store files. Returns true if the directory exists\n-\/\/ and is considered a secure location. Returns false if the path\n-\/\/ is a symbolic link or if an error occurred.\n-\/\/\n-static bool is_directory_secure(const char* path) {\n-  struct stat statbuf;\n-  int result = 0;\n-\n-  RESTARTABLE(::lstat(path, &statbuf), result);\n-  if (result == OS_ERR) {\n-    return false;\n-  }\n-\n-  \/\/ The path exists, see if it is secure.\n-  return is_statbuf_secure(&statbuf);\n-}\n-\n-\/\/ Check if the given directory file descriptor is considered a secure\n-\/\/ directory for the backing store files. Returns true if the directory\n-\/\/ exists and is considered a secure location. Returns false if the path\n-\/\/ is a symbolic link or if an error occurred.\n-static bool is_dirfd_secure(int dir_fd) {\n-  struct stat statbuf;\n-  int result = 0;\n-\n-  RESTARTABLE(::fstat(dir_fd, &statbuf), result);\n-  if (result == OS_ERR) {\n-    return false;\n-  }\n-\n-  \/\/ The path exists, now check its mode.\n-  return is_statbuf_secure(&statbuf);\n-}\n-\n-\n-\/\/ Check to make sure fd1 and fd2 are referencing the same file system object.\n-static bool is_same_fsobject(int fd1, int fd2) {\n-  struct stat statbuf1;\n-  struct stat statbuf2;\n-  int result = 0;\n-\n-  RESTARTABLE(::fstat(fd1, &statbuf1), result);\n-  if (result == OS_ERR) {\n-    return false;\n-  }\n-  RESTARTABLE(::fstat(fd2, &statbuf2), result);\n-  if (result == OS_ERR) {\n-    return false;\n-  }\n-\n-  if ((statbuf1.st_ino == statbuf2.st_ino) &&\n-      (statbuf1.st_dev == statbuf2.st_dev)) {\n-    return true;\n-  } else {\n-    return false;\n-  }\n-}\n-\n-\/\/ Open the directory of the given path and validate it.\n-\/\/ Return a DIR * of the open directory.\n-static DIR *open_directory_secure(const char* dirname) {\n-  \/\/ Open the directory using open() so that it can be verified\n-  \/\/ to be secure by calling is_dirfd_secure(), opendir() and then check\n-  \/\/ to see if they are the same file system object.  This method does not\n-  \/\/ introduce a window of opportunity for the directory to be attacked that\n-  \/\/ calling opendir() and is_directory_secure() does.\n-  int result;\n-  DIR *dirp = NULL;\n-  RESTARTABLE(::open(dirname, O_RDONLY|O_NOFOLLOW), result);\n-\n-  if (result == OS_ERR) {\n-    \/\/ Directory doesn't exist or is a symlink, so there is nothing to cleanup.\n-    if (PrintMiscellaneous && Verbose) {\n-      if (errno == ELOOP) {\n-        warning(\"directory %s is a symlink and is not secure\\n\", dirname);\n-      } else {\n-        warning(\"could not open directory %s: %s\\n\", dirname, os::strerror(errno));\n-      }\n-    }\n-    return dirp;\n-  }\n-  int fd = result;\n-\n-  \/\/ Determine if the open directory is secure.\n-  if (!is_dirfd_secure(fd)) {\n-    \/\/ The directory is not a secure directory.\n-    os::close(fd);\n-    return dirp;\n-  }\n-\n-  \/\/ Open the directory.\n-  dirp = ::opendir(dirname);\n-  if (dirp == NULL) {\n-    \/\/ The directory doesn't exist, close fd and return.\n-    os::close(fd);\n-    return dirp;\n-  }\n-\n-  \/\/ Check to make sure fd and dirp are referencing the same file system object.\n-  if (!is_same_fsobject(fd, dirp->dd_fd)) {\n-    \/\/ The directory is not secure.\n-    os::close(fd);\n-    os::closedir(dirp);\n-    dirp = NULL;\n-    return dirp;\n-  }\n-\n-  \/\/ Close initial open now that we know directory is secure\n-  os::close(fd);\n-\n-  return dirp;\n-}\n-\n-\/\/ NOTE: The code below uses fchdir(), open() and unlink() because\n-\/\/ fdopendir(), openat() and unlinkat() are not supported on all\n-\/\/ versions.  Once the support for fdopendir(), openat() and unlinkat()\n-\/\/ is available on all supported versions the code can be changed\n-\/\/ to use these functions.\n-\n-\/\/ Open the directory of the given path, validate it and set the\n-\/\/ current working directory to it.\n-\/\/ Return a DIR * of the open directory and the saved cwd fd.\n-\/\/\n-static DIR *open_directory_secure_cwd(const char* dirname, int *saved_cwd_fd) {\n-\n-  \/\/ Open the directory.\n-  DIR* dirp = open_directory_secure(dirname);\n-  if (dirp == NULL) {\n-    \/\/ Directory doesn't exist or is insecure, so there is nothing to cleanup.\n-    return dirp;\n-  }\n-  int fd = dirp->dd_fd;\n-\n-  \/\/ Open a fd to the cwd and save it off.\n-  int result;\n-  RESTARTABLE(::open(\".\", O_RDONLY), result);\n-  if (result == OS_ERR) {\n-    *saved_cwd_fd = -1;\n-  } else {\n-    *saved_cwd_fd = result;\n-  }\n-\n-  \/\/ Set the current directory to dirname by using the fd of the directory and\n-  \/\/ handle errors, otherwise shared memory files will be created in cwd.\n-  result = fchdir(fd);\n-  if (result == OS_ERR) {\n-    if (PrintMiscellaneous && Verbose) {\n-      warning(\"could not change to directory %s\", dirname);\n-    }\n-    if (*saved_cwd_fd != -1) {\n-      ::close(*saved_cwd_fd);\n-      *saved_cwd_fd = -1;\n-    }\n-    \/\/ Close the directory.\n-    os::closedir(dirp);\n-    return NULL;\n-  } else {\n-    return dirp;\n-  }\n-}\n-\n-\/\/ Close the directory and restore the current working directory.\n-\/\/\n-static void close_directory_secure_cwd(DIR* dirp, int saved_cwd_fd) {\n-\n-  int result;\n-  \/\/ If we have a saved cwd change back to it and close the fd.\n-  if (saved_cwd_fd != -1) {\n-    result = fchdir(saved_cwd_fd);\n-    ::close(saved_cwd_fd);\n-  }\n-\n-  \/\/ Close the directory.\n-  os::closedir(dirp);\n-}\n-\n-\/\/ Check if the given file descriptor is considered a secure.\n-static bool is_file_secure(int fd, const char *filename) {\n-\n-  int result;\n-  struct stat statbuf;\n-\n-  \/\/ Determine if the file is secure.\n-  RESTARTABLE(::fstat(fd, &statbuf), result);\n-  if (result == OS_ERR) {\n-    if (PrintMiscellaneous && Verbose) {\n-      warning(\"fstat failed on %s: %s\\n\", filename, os::strerror(errno));\n-    }\n-    return false;\n-  }\n-  if (statbuf.st_nlink > 1) {\n-    \/\/ A file with multiple links is not expected.\n-    if (PrintMiscellaneous && Verbose) {\n-      warning(\"file %s has multiple links\\n\", filename);\n-    }\n-    return false;\n-  }\n-  return true;\n-}\n-\n-\/\/ Return the user name for the given user id.\n-\/\/\n-\/\/ The caller is expected to free the allocated memory.\n-static char* get_user_name(uid_t uid) {\n-\n-  struct passwd pwent;\n-\n-  \/\/ Determine the max pwbuf size from sysconf, and hardcode\n-  \/\/ a default if this not available through sysconf.\n-  long bufsize = sysconf(_SC_GETPW_R_SIZE_MAX);\n-  if (bufsize == -1)\n-    bufsize = 1024;\n-\n-  char* pwbuf = NEW_C_HEAP_ARRAY(char, bufsize, mtInternal);\n-\n-  struct passwd* p;\n-  int result = getpwuid_r(uid, &pwent, pwbuf, (size_t)bufsize, &p);\n-\n-  if (result != 0 || p == NULL || p->pw_name == NULL || *(p->pw_name) == '\\0') {\n-    if (PrintMiscellaneous && Verbose) {\n-      if (result != 0) {\n-        warning(\"Could not retrieve passwd entry: %s\\n\",\n-                os::strerror(result));\n-      }\n-      else if (p == NULL) {\n-        \/\/ this check is added to protect against an observed problem\n-        \/\/ with getpwuid_r() on RedHat 9 where getpwuid_r returns 0,\n-        \/\/ indicating success, but has p == NULL. This was observed when\n-        \/\/ inserting a file descriptor exhaustion fault prior to the call\n-        \/\/ getpwuid_r() call. In this case, error is set to the appropriate\n-        \/\/ error condition, but this is undocumented behavior. This check\n-        \/\/ is safe under any condition, but the use of errno in the output\n-        \/\/ message may result in an erroneous message.\n-        \/\/ Bug Id 89052 was opened with RedHat.\n-        \/\/\n-        warning(\"Could not retrieve passwd entry: %s\\n\",\n-                os::strerror(errno));\n-      }\n-      else {\n-        warning(\"Could not determine user name: %s\\n\",\n-                p->pw_name == NULL ? \"pw_name = NULL\" :\n-                                     \"pw_name zero length\");\n-      }\n-    }\n-    FREE_C_HEAP_ARRAY(char, pwbuf);\n-    return NULL;\n-  }\n-\n-  char* user_name = NEW_C_HEAP_ARRAY(char, strlen(p->pw_name) + 1, mtInternal);\n-  strcpy(user_name, p->pw_name);\n-\n-  FREE_C_HEAP_ARRAY(char, pwbuf);\n-  return user_name;\n-}\n-\n-\/\/ return the name of the user that owns the process identified by vmid.\n-\/\/\n-\/\/ This method uses a slow directory search algorithm to find the backing\n-\/\/ store file for the specified vmid and returns the user name, as determined\n-\/\/ by the user name suffix of the hsperfdata_<username> directory name.\n-\/\/\n-\/\/ the caller is expected to free the allocated memory.\n-\/\/\n-static char* get_user_name_slow(int vmid, TRAPS) {\n-\n-  \/\/ short circuit the directory search if the process doesn't even exist.\n-  if (kill(vmid, 0) == OS_ERR) {\n-    if (errno == ESRCH) {\n-      THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),\n-                  \"Process not found\");\n-    }\n-    else \/* EPERM *\/ {\n-      THROW_MSG_0(vmSymbols::java_io_IOException(), os::strerror(errno));\n-    }\n-  }\n-\n-  \/\/ directory search\n-  char* oldest_user = NULL;\n-  time_t oldest_ctime = 0;\n-\n-  const char* tmpdirname = os::get_temp_directory();\n-\n-  DIR* tmpdirp = os::opendir(tmpdirname);\n-\n-  if (tmpdirp == NULL) {\n-    return NULL;\n-  }\n-\n-  \/\/ for each entry in the directory that matches the pattern hsperfdata_*,\n-  \/\/ open the directory and check if the file for the given vmid exists.\n-  \/\/ The file with the expected name and the latest creation date is used\n-  \/\/ to determine the user name for the process id.\n-  \/\/\n-  struct dirent* dentry;\n-  errno = 0;\n-  while ((dentry = os::readdir(tmpdirp)) != NULL) {\n-\n-    \/\/ check if the directory entry is a hsperfdata file\n-    if (strncmp(dentry->d_name, PERFDATA_NAME, strlen(PERFDATA_NAME)) != 0) {\n-      continue;\n-    }\n-\n-    char* usrdir_name = NEW_C_HEAP_ARRAY(char,\n-                              strlen(tmpdirname) + strlen(dentry->d_name) + 2, mtInternal);\n-    strcpy(usrdir_name, tmpdirname);\n-    strcat(usrdir_name, \"\/\");\n-    strcat(usrdir_name, dentry->d_name);\n-\n-    \/\/ Open the user directory.\n-    DIR* subdirp = open_directory_secure(usrdir_name);\n-\n-    if (subdirp == NULL) {\n-      FREE_C_HEAP_ARRAY(char, usrdir_name);\n-      continue;\n-    }\n-\n-    \/\/ Since we don't create the backing store files in directories\n-    \/\/ pointed to by symbolic links, we also don't follow them when\n-    \/\/ looking for the files. We check for a symbolic link after the\n-    \/\/ call to opendir in order to eliminate a small window where the\n-    \/\/ symlink can be exploited.\n-    \/\/\n-    if (!is_directory_secure(usrdir_name)) {\n-      FREE_C_HEAP_ARRAY(char, usrdir_name);\n-      os::closedir(subdirp);\n-      continue;\n-    }\n-\n-    struct dirent* udentry;\n-    errno = 0;\n-    while ((udentry = os::readdir(subdirp)) != NULL) {\n-\n-      if (filename_to_pid(udentry->d_name) == vmid) {\n-        struct stat statbuf;\n-        int result;\n-\n-        char* filename = NEW_C_HEAP_ARRAY(char,\n-                            strlen(usrdir_name) + strlen(udentry->d_name) + 2, mtInternal);\n-\n-        strcpy(filename, usrdir_name);\n-        strcat(filename, \"\/\");\n-        strcat(filename, udentry->d_name);\n-\n-        \/\/ don't follow symbolic links for the file\n-        RESTARTABLE(::lstat(filename, &statbuf), result);\n-        if (result == OS_ERR) {\n-           FREE_C_HEAP_ARRAY(char, filename);\n-           continue;\n-        }\n-\n-        \/\/ skip over files that are not regular files.\n-        if (!S_ISREG(statbuf.st_mode)) {\n-          FREE_C_HEAP_ARRAY(char, filename);\n-          continue;\n-        }\n-\n-        \/\/ compare and save filename with latest creation time\n-        if (statbuf.st_size > 0 && statbuf.st_ctime > oldest_ctime) {\n-\n-          if (statbuf.st_ctime > oldest_ctime) {\n-            char* user = strchr(dentry->d_name, '_') + 1;\n-\n-            FREE_C_HEAP_ARRAY(char, oldest_user);\n-            oldest_user = NEW_C_HEAP_ARRAY(char, strlen(user)+1, mtInternal);\n-\n-            strcpy(oldest_user, user);\n-            oldest_ctime = statbuf.st_ctime;\n-          }\n-        }\n-\n-        FREE_C_HEAP_ARRAY(char, filename);\n-      }\n-    }\n-    os::closedir(subdirp);\n-    FREE_C_HEAP_ARRAY(char, usrdir_name);\n-  }\n-  os::closedir(tmpdirp);\n-\n-  return(oldest_user);\n-}\n-\n-\/\/ return the name of the user that owns the JVM indicated by the given vmid.\n-\/\/\n-static char* get_user_name(int vmid, TRAPS) {\n-  return get_user_name_slow(vmid, THREAD);\n-}\n-\n-\/\/ return the file name of the backing store file for the named\n-\/\/ shared memory region for the given user name and vmid.\n-\/\/\n-\/\/ the caller is expected to free the allocated memory.\n-\/\/\n-static char* get_sharedmem_filename(const char* dirname, int vmid) {\n-\n-  \/\/ add 2 for the file separator and a null terminator.\n-  size_t nbytes = strlen(dirname) + UINT_CHARS + 2;\n-\n-  char* name = NEW_C_HEAP_ARRAY(char, nbytes, mtInternal);\n-  snprintf(name, nbytes, \"%s\/%d\", dirname, vmid);\n-\n-  return name;\n-}\n-\n-\n-\/\/ remove file\n-\/\/\n-\/\/ this method removes the file specified by the given path\n-\/\/\n-static void remove_file(const char* path) {\n-\n-  int result;\n-\n-  \/\/ if the file is a directory, the following unlink will fail. since\n-  \/\/ we don't expect to find directories in the user temp directory, we\n-  \/\/ won't try to handle this situation. even if accidentially or\n-  \/\/ maliciously planted, the directory's presence won't hurt anything.\n-  \/\/\n-  RESTARTABLE(::unlink(path), result);\n-  if (PrintMiscellaneous && Verbose && result == OS_ERR) {\n-    if (errno != ENOENT) {\n-      warning(\"Could not unlink shared memory backing\"\n-              \" store file %s : %s\\n\", path, os::strerror(errno));\n-    }\n-  }\n-}\n-\n-\/\/ Cleanup stale shared memory resources\n-\/\/\n-\/\/ This method attempts to remove all stale shared memory files in\n-\/\/ the named user temporary directory. It scans the named directory\n-\/\/ for files matching the pattern ^$[0-9]*$. For each file found, the\n-\/\/ process id is extracted from the file name and a test is run to\n-\/\/ determine if the process is alive. If the process is not alive,\n-\/\/ any stale file resources are removed.\n-static void cleanup_sharedmem_resources(const char* dirname) {\n-\n-  int saved_cwd_fd;\n-  \/\/ Open the directory.\n-  DIR* dirp = open_directory_secure_cwd(dirname, &saved_cwd_fd);\n-  if (dirp == NULL) {\n-     \/\/ Directory doesn't exist or is insecure, so there is nothing to cleanup.\n-    return;\n-  }\n-\n-  \/\/ For each entry in the directory that matches the expected file\n-  \/\/ name pattern, determine if the file resources are stale and if\n-  \/\/ so, remove the file resources. Note, instrumented HotSpot processes\n-  \/\/ for this user may start and\/or terminate during this search and\n-  \/\/ remove or create new files in this directory. The behavior of this\n-  \/\/ loop under these conditions is dependent upon the implementation of\n-  \/\/ opendir\/readdir.\n-  struct dirent* entry;\n-  errno = 0;\n-  while ((entry = os::readdir(dirp)) != NULL) {\n-\n-    pid_t pid = filename_to_pid(entry->d_name);\n-\n-    if (pid == 0) {\n-\n-      if (strcmp(entry->d_name, \".\") != 0 && strcmp(entry->d_name, \"..\") != 0) {\n-\n-        \/\/ Attempt to remove all unexpected files, except \".\" and \"..\".\n-        unlink(entry->d_name);\n-      }\n-\n-      errno = 0;\n-      continue;\n-    }\n-\n-    \/\/ We now have a file name that converts to a valid integer\n-    \/\/ that could represent a process id . if this process id\n-    \/\/ matches the current process id or the process is not running,\n-    \/\/ then remove the stale file resources.\n-    \/\/\n-    \/\/ Process liveness is detected by sending signal number 0 to\n-    \/\/ the process id (see kill(2)). if kill determines that the\n-    \/\/ process does not exist, then the file resources are removed.\n-    \/\/ if kill determines that that we don't have permission to\n-    \/\/ signal the process, then the file resources are assumed to\n-    \/\/ be stale and are removed because the resources for such a\n-    \/\/ process should be in a different user specific directory.\n-    if ((pid == os::current_process_id()) ||\n-        (kill(pid, 0) == OS_ERR && (errno == ESRCH || errno == EPERM))) {\n-\n-        unlink(entry->d_name);\n-    }\n-    errno = 0;\n-  }\n-\n-  \/\/ Close the directory and reset the current working directory.\n-  close_directory_secure_cwd(dirp, saved_cwd_fd);\n-}\n-\n-\/\/ Make the user specific temporary directory. Returns true if\n-\/\/ the directory exists and is secure upon return. Returns false\n-\/\/ if the directory exists but is either a symlink, is otherwise\n-\/\/ insecure, or if an error occurred.\n-static bool make_user_tmp_dir(const char* dirname) {\n-\n-  \/\/ Create the directory with 0755 permissions. note that the directory\n-  \/\/ will be owned by euid::egid, which may not be the same as uid::gid.\n-  if (mkdir(dirname, S_IRWXU|S_IRGRP|S_IXGRP|S_IROTH|S_IXOTH) == OS_ERR) {\n-    if (errno == EEXIST) {\n-      \/\/ The directory already exists and was probably created by another\n-      \/\/ JVM instance. However, this could also be the result of a\n-      \/\/ deliberate symlink. Verify that the existing directory is safe.\n-      if (!is_directory_secure(dirname)) {\n-        \/\/ Directory is not secure.\n-        if (PrintMiscellaneous && Verbose) {\n-          warning(\"%s directory is insecure\\n\", dirname);\n-        }\n-        return false;\n-      }\n-    }\n-    else {\n-      \/\/ we encountered some other failure while attempting\n-      \/\/ to create the directory\n-      \/\/\n-      if (PrintMiscellaneous && Verbose) {\n-        warning(\"could not create directory %s: %s\\n\",\n-                dirname, os::strerror(errno));\n-      }\n-      return false;\n-    }\n-  }\n-  return true;\n-}\n-\n-\/\/ create the shared memory file resources\n-\/\/\n-\/\/ This method creates the shared memory file with the given size\n-\/\/ This method also creates the user specific temporary directory, if\n-\/\/ it does not yet exist.\n-\/\/\n-static int create_sharedmem_resources(const char* dirname, const char* filename, size_t size) {\n-\n-  \/\/ make the user temporary directory\n-  if (!make_user_tmp_dir(dirname)) {\n-    \/\/ could not make\/find the directory or the found directory\n-    \/\/ was not secure\n-    return -1;\n-  }\n-\n-  int saved_cwd_fd;\n-  \/\/ Open the directory and set the current working directory to it.\n-  DIR* dirp = open_directory_secure_cwd(dirname, &saved_cwd_fd);\n-  if (dirp == NULL) {\n-    \/\/ Directory doesn't exist or is insecure, so cannot create shared\n-    \/\/ memory file.\n-    return -1;\n-  }\n-\n-  \/\/ Open the filename in the current directory.\n-  \/\/ Cannot use O_TRUNC here; truncation of an existing file has to happen\n-  \/\/ after the is_file_secure() check below.\n-  int result;\n-  RESTARTABLE(os::open(filename, O_RDWR|O_CREAT|O_NOFOLLOW, S_IREAD|S_IWRITE), result);\n-\n-  if (result == OS_ERR) {\n-    if (PrintMiscellaneous && Verbose) {\n-      if (errno == ELOOP) {\n-        warning(\"file %s is a symlink and is not secure\\n\", filename);\n-      } else {\n-        warning(\"could not create file %s: %s\\n\", filename, os::strerror(errno));\n-      }\n-    }\n-    \/\/ Close the directory and reset the current working directory.\n-    close_directory_secure_cwd(dirp, saved_cwd_fd);\n-\n-    return -1;\n-  }\n-  \/\/ Close the directory and reset the current working directory.\n-  close_directory_secure_cwd(dirp, saved_cwd_fd);\n-\n-  \/\/ save the file descriptor\n-  int fd = result;\n-\n-  \/\/ Check to see if the file is secure.\n-  if (!is_file_secure(fd, filename)) {\n-    ::close(fd);\n-    return -1;\n-  }\n-\n-  \/\/ Truncate the file to get rid of any existing data.\n-  RESTARTABLE(::ftruncate(fd, (off_t)0), result);\n-  if (result == OS_ERR) {\n-    if (PrintMiscellaneous && Verbose) {\n-      warning(\"could not truncate shared memory file: %s\\n\", os::strerror(errno));\n-    }\n-    ::close(fd);\n-    return -1;\n-  }\n-  \/\/ set the file size\n-  RESTARTABLE(::ftruncate(fd, (off_t)size), result);\n-  if (result == OS_ERR) {\n-    if (PrintMiscellaneous && Verbose) {\n-      warning(\"could not set shared memory file size: %s\\n\", os::strerror(errno));\n-    }\n-    ::close(fd);\n-    return -1;\n-  }\n-\n-  return fd;\n-}\n-\n-\/\/ open the shared memory file for the given user and vmid. returns\n-\/\/ the file descriptor for the open file or -1 if the file could not\n-\/\/ be opened.\n-\/\/\n-static int open_sharedmem_file(const char* filename, int oflags, TRAPS) {\n-\n-  \/\/ open the file\n-  int result;\n-  RESTARTABLE(os::open(filename, oflags, 0), result);\n-\n-  if (result == OS_ERR) {\n-    if (errno == ENOENT) {\n-      THROW_MSG_(vmSymbols::java_lang_IllegalArgumentException(),\n-                 \"Process not found\", OS_ERR);\n-    }\n-    else if (errno == EACCES) {\n-      THROW_MSG_(vmSymbols::java_lang_IllegalArgumentException(),\n-                 \"Permission denied\", OS_ERR);\n-    }\n-    else {\n-      THROW_MSG_(vmSymbols::java_io_IOException(),\n-                 os::strerror(errno), OS_ERR);\n-    }\n-  }\n-  int fd = result;\n-\n-  \/\/ Check to see if the file is secure.\n-  if (!is_file_secure(fd, filename)) {\n-    ::close(fd);\n-    return -1;\n-  }\n-\n-  return fd;\n-}\n-\n-\/\/ create a named shared memory region. returns the address of the\n-\/\/ memory region on success or NULL on failure. A return value of\n-\/\/ NULL will ultimately disable the shared memory feature.\n-\/\/\n-\/\/ On AIX, the name space for shared memory objects\n-\/\/ is the file system name space.\n-\/\/\n-\/\/ A monitoring application attaching to a JVM does not need to know\n-\/\/ the file system name of the shared memory object. However, it may\n-\/\/ be convenient for applications to discover the existence of newly\n-\/\/ created and terminating JVMs by watching the file system name space\n-\/\/ for files being created or removed.\n-\/\/\n-static char* mmap_create_shared(size_t size) {\n-\n-  int result;\n-  int fd;\n-  char* mapAddress;\n-\n-  int vmid = os::current_process_id();\n-\n-  char* user_name = get_user_name(geteuid());\n-\n-  if (user_name == NULL)\n-    return NULL;\n-\n-  char* dirname = get_user_tmp_dir(user_name);\n-  char* filename = get_sharedmem_filename(dirname, vmid);\n-\n-  \/\/ get the short filename.\n-  char* short_filename = strrchr(filename, '\/');\n-  if (short_filename == NULL) {\n-    short_filename = filename;\n-  } else {\n-    short_filename++;\n-  }\n-\n-  \/\/ cleanup any stale shared memory files\n-  cleanup_sharedmem_resources(dirname);\n-\n-  assert(((size > 0) && (size % os::vm_page_size() == 0)),\n-         \"unexpected PerfMemory region size\");\n-\n-  fd = create_sharedmem_resources(dirname, short_filename, size);\n-\n-  FREE_C_HEAP_ARRAY(char, user_name);\n-  FREE_C_HEAP_ARRAY(char, dirname);\n-\n-  if (fd == -1) {\n-    FREE_C_HEAP_ARRAY(char, filename);\n-    return NULL;\n-  }\n-\n-  mapAddress = (char*)::mmap((char*)0, size, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);\n-\n-  result = ::close(fd);\n-  assert(result != OS_ERR, \"could not close file\");\n-\n-  if (mapAddress == MAP_FAILED) {\n-    if (PrintMiscellaneous && Verbose) {\n-      warning(\"mmap failed -  %s\\n\", os::strerror(errno));\n-    }\n-    remove_file(filename);\n-    FREE_C_HEAP_ARRAY(char, filename);\n-    return NULL;\n-  }\n-\n-  \/\/ save the file name for use in delete_shared_memory()\n-  backing_store_file_name = filename;\n-\n-  \/\/ clear the shared memory region\n-  (void)::memset((void*) mapAddress, 0, size);\n-\n-  \/\/ It does not go through os api, the operation has to record from here.\n-  MemTracker::record_virtual_memory_reserve((address)mapAddress, size, CURRENT_PC, mtInternal);\n-\n-  return mapAddress;\n-}\n-\n-\/\/ release a named shared memory region\n-\/\/\n-static void unmap_shared(char* addr, size_t bytes) {\n-  \/\/ Do not rely on os::reserve_memory\/os::release_memory to use mmap.\n-  \/\/ Use os::reserve_memory\/os::release_memory for PerfDisableSharedMem=1, mmap\/munmap for PerfDisableSharedMem=0\n-  if (::munmap(addr, bytes) == -1) {\n-    warning(\"perfmemory: munmap failed (%d)\\n\", errno);\n-  }\n-}\n-\n-\/\/ create the PerfData memory region in shared memory.\n-\/\/\n-static char* create_shared_memory(size_t size) {\n-\n-  \/\/ create the shared memory region.\n-  return mmap_create_shared(size);\n-}\n-\n-\/\/ delete the shared PerfData memory region\n-\/\/\n-static void delete_shared_memory(char* addr, size_t size) {\n-\n-  \/\/ cleanup the persistent shared memory resources. since DestroyJavaVM does\n-  \/\/ not support unloading of the JVM, unmapping of the memory resource is\n-  \/\/ not performed. The memory will be reclaimed by the OS upon termination of\n-  \/\/ the process. The backing store file is deleted from the file system.\n-\n-  assert(!PerfDisableSharedMem, \"shouldn't be here\");\n-\n-  if (backing_store_file_name != NULL) {\n-    remove_file(backing_store_file_name);\n-    \/\/ Don't.. Free heap memory could deadlock os::abort() if it is called\n-    \/\/ from signal handler. OS will reclaim the heap memory.\n-    \/\/ FREE_C_HEAP_ARRAY(char, backing_store_file_name);\n-    backing_store_file_name = NULL;\n-  }\n-}\n-\n-\/\/ return the size of the file for the given file descriptor\n-\/\/ or 0 if it is not a valid size for a shared memory file\n-\/\/\n-static size_t sharedmem_filesize(int fd, TRAPS) {\n-\n-  struct stat statbuf;\n-  int result;\n-\n-  RESTARTABLE(::fstat(fd, &statbuf), result);\n-  if (result == OS_ERR) {\n-    if (PrintMiscellaneous && Verbose) {\n-      warning(\"fstat failed: %s\\n\", os::strerror(errno));\n-    }\n-    THROW_MSG_0(vmSymbols::java_io_IOException(),\n-                \"Could not determine PerfMemory size\");\n-  }\n-\n-  if ((statbuf.st_size == 0) ||\n-     ((size_t)statbuf.st_size % os::vm_page_size() != 0)) {\n-    THROW_MSG_0(vmSymbols::java_io_IOException(),\n-                \"Invalid PerfMemory size\");\n-  }\n-\n-  return (size_t)statbuf.st_size;\n-}\n-\n-\/\/ attach to a named shared memory region.\n-\/\/\n-static void mmap_attach_shared(const char* user, int vmid, PerfMemory::PerfMemoryMode mode, char** addr, size_t* sizep, TRAPS) {\n-\n-  char* mapAddress;\n-  int result;\n-  int fd;\n-  size_t size = 0;\n-  const char* luser = NULL;\n-\n-  int mmap_prot;\n-  int file_flags;\n-\n-  ResourceMark rm;\n-\n-  \/\/ map the high level access mode to the appropriate permission\n-  \/\/ constructs for the file and the shared memory mapping.\n-  if (mode == PerfMemory::PERF_MODE_RO) {\n-    mmap_prot = PROT_READ;\n-    file_flags = O_RDONLY | O_NOFOLLOW;\n-  }\n-  else if (mode == PerfMemory::PERF_MODE_RW) {\n-#ifdef LATER\n-    mmap_prot = PROT_READ | PROT_WRITE;\n-    file_flags = O_RDWR | O_NOFOLLOW;\n-#else\n-    THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(),\n-              \"Unsupported access mode\");\n-#endif\n-  }\n-  else {\n-    THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(),\n-              \"Illegal access mode\");\n-  }\n-\n-  if (user == NULL || strlen(user) == 0) {\n-    luser = get_user_name(vmid, CHECK);\n-  }\n-  else {\n-    luser = user;\n-  }\n-\n-  if (luser == NULL) {\n-    THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(),\n-              \"Could not map vmid to user Name\");\n-  }\n-\n-  char* dirname = get_user_tmp_dir(luser);\n-\n-  \/\/ since we don't follow symbolic links when creating the backing\n-  \/\/ store file, we don't follow them when attaching either.\n-  \/\/\n-  if (!is_directory_secure(dirname)) {\n-    FREE_C_HEAP_ARRAY(char, dirname);\n-    if (luser != user) {\n-      FREE_C_HEAP_ARRAY(char, luser);\n-    }\n-    THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(),\n-              \"Process not found\");\n-  }\n-\n-  char* filename = get_sharedmem_filename(dirname, vmid);\n-\n-  \/\/ copy heap memory to resource memory. the open_sharedmem_file\n-  \/\/ method below need to use the filename, but could throw an\n-  \/\/ exception. using a resource array prevents the leak that\n-  \/\/ would otherwise occur.\n-  char* rfilename = NEW_RESOURCE_ARRAY(char, strlen(filename) + 1);\n-  strcpy(rfilename, filename);\n-\n-  \/\/ free the c heap resources that are no longer needed\n-  if (luser != user) FREE_C_HEAP_ARRAY(char, luser);\n-  FREE_C_HEAP_ARRAY(char, dirname);\n-  FREE_C_HEAP_ARRAY(char, filename);\n-\n-  \/\/ open the shared memory file for the give vmid\n-  fd = open_sharedmem_file(rfilename, file_flags, THREAD);\n-\n-  if (fd == OS_ERR) {\n-    return;\n-  }\n-\n-  if (HAS_PENDING_EXCEPTION) {\n-    ::close(fd);\n-    return;\n-  }\n-\n-  if (*sizep == 0) {\n-    size = sharedmem_filesize(fd, CHECK);\n-  } else {\n-    size = *sizep;\n-  }\n-\n-  assert(size > 0, \"unexpected size <= 0\");\n-\n-  mapAddress = (char*)::mmap((char*)0, size, mmap_prot, MAP_SHARED, fd, 0);\n-\n-  result = ::close(fd);\n-  assert(result != OS_ERR, \"could not close file\");\n-\n-  if (mapAddress == MAP_FAILED) {\n-    if (PrintMiscellaneous && Verbose) {\n-      warning(\"mmap failed: %s\\n\", os::strerror(errno));\n-    }\n-    THROW_MSG(vmSymbols::java_lang_OutOfMemoryError(),\n-              \"Could not map PerfMemory\");\n-  }\n-\n-  \/\/ it does not go through os api, the operation has to record from here.\n-  MemTracker::record_virtual_memory_reserve((address)mapAddress, size, CURRENT_PC, mtInternal);\n-\n-  *addr = mapAddress;\n-  *sizep = size;\n-\n-  log_debug(perf, memops)(\"mapped \" SIZE_FORMAT \" bytes for vmid %d at \"\n-                          INTPTR_FORMAT, size, vmid, p2i((void*)mapAddress));\n-}\n-\n-\/\/ create the PerfData memory region\n-\/\/\n-\/\/ This method creates the memory region used to store performance\n-\/\/ data for the JVM. The memory may be created in standard or\n-\/\/ shared memory.\n-\/\/\n-void PerfMemory::create_memory_region(size_t size) {\n-\n-  if (PerfDisableSharedMem) {\n-    \/\/ do not share the memory for the performance data.\n-    _start = create_standard_memory(size);\n-  }\n-  else {\n-    _start = create_shared_memory(size);\n-    if (_start == NULL) {\n-\n-      \/\/ creation of the shared memory region failed, attempt\n-      \/\/ to create a contiguous, non-shared memory region instead.\n-      \/\/\n-      if (PrintMiscellaneous && Verbose) {\n-        warning(\"Reverting to non-shared PerfMemory region.\\n\");\n-      }\n-      PerfDisableSharedMem = true;\n-      _start = create_standard_memory(size);\n-    }\n-  }\n-\n-  if (_start != NULL) _capacity = size;\n-\n-}\n-\n-\/\/ delete the PerfData memory region\n-\/\/\n-\/\/ This method deletes the memory region used to store performance\n-\/\/ data for the JVM. The memory region indicated by the <address, size>\n-\/\/ tuple will be inaccessible after a call to this method.\n-\/\/\n-void PerfMemory::delete_memory_region() {\n-\n-  assert((start() != NULL && capacity() > 0), \"verify proper state\");\n-\n-  \/\/ If user specifies PerfDataSaveFile, it will save the performance data\n-  \/\/ to the specified file name no matter whether PerfDataSaveToFile is specified\n-  \/\/ or not. In other word, -XX:PerfDataSaveFile=.. overrides flag\n-  \/\/ -XX:+PerfDataSaveToFile.\n-  if (PerfDataSaveToFile || PerfDataSaveFile != NULL) {\n-    save_memory_to_file(start(), capacity());\n-  }\n-\n-  if (PerfDisableSharedMem) {\n-    delete_standard_memory(start(), capacity());\n-  }\n-  else {\n-    delete_shared_memory(start(), capacity());\n-  }\n-}\n-\n-\/\/ attach to the PerfData memory region for another JVM\n-\/\/\n-\/\/ This method returns an <address, size> tuple that points to\n-\/\/ a memory buffer that is kept reasonably synchronized with\n-\/\/ the PerfData memory region for the indicated JVM. This\n-\/\/ buffer may be kept in synchronization via shared memory\n-\/\/ or some other mechanism that keeps the buffer updated.\n-\/\/\n-\/\/ If the JVM chooses not to support the attachability feature,\n-\/\/ this method should throw an UnsupportedOperation exception.\n-\/\/\n-\/\/ This implementation utilizes named shared memory to map\n-\/\/ the indicated process's PerfData memory region into this JVMs\n-\/\/ address space.\n-\/\/\n-void PerfMemory::attach(const char* user, int vmid, PerfMemoryMode mode, char** addrp, size_t* sizep, TRAPS) {\n-\n-  if (vmid == 0 || vmid == os::current_process_id()) {\n-     *addrp = start();\n-     *sizep = capacity();\n-     return;\n-  }\n-\n-  mmap_attach_shared(user, vmid, mode, addrp, sizep, CHECK);\n-}\n-\n-\/\/ detach from the PerfData memory region of another JVM\n-\/\/\n-\/\/ This method detaches the PerfData memory region of another\n-\/\/ JVM, specified as an <address, size> tuple of a buffer\n-\/\/ in this process's address space. This method may perform\n-\/\/ arbitrary actions to accomplish the detachment. The memory\n-\/\/ region specified by <address, size> will be inaccessible after\n-\/\/ a call to this method.\n-\/\/\n-\/\/ If the JVM chooses not to support the attachability feature,\n-\/\/ this method should throw an UnsupportedOperation exception.\n-\/\/\n-\/\/ This implementation utilizes named shared memory to detach\n-\/\/ the indicated process's PerfData memory region from this\n-\/\/ process's address space.\n-\/\/\n-void PerfMemory::detach(char* addr, size_t bytes, TRAPS) {\n-\n-  assert(addr != 0, \"address sanity check\");\n-  assert(bytes > 0, \"capacity sanity check\");\n-\n-  if (PerfMemory::contains(addr) || PerfMemory::contains(addr + bytes - 1)) {\n-    \/\/ prevent accidental detachment of this process's PerfMemory region\n-    return;\n-  }\n-\n-  unmap_shared(addr, bytes);\n-}\n","filename":"src\/hotspot\/os\/aix\/perfMemory_aix.cpp","additions":0,"deletions":1245,"binary":false,"changes":1245,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -75,12 +75,0 @@\n-\/\/ macros for restartable system calls\n-\n-#define RESTARTABLE(_cmd, _result) do { \\\n-    _result = _cmd; \\\n-  } while(((int)_result == OS_ERR) && (errno == EINTR))\n-\n-#define RESTARTABLE_RETURN_INT(_cmd) do { \\\n-  int _result; \\\n-  RESTARTABLE(_cmd, _result); \\\n-  return _result; \\\n-} while(false)\n-\n@@ -96,4 +84,0 @@\n-inline int os::close(int fd) {\n-  return ::close(fd);\n-}\n-\n","filename":"src\/hotspot\/os\/bsd\/os_bsd.inline.hpp","additions":1,"deletions":17,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -1,1260 +0,0 @@\n-\/*\n- * Copyright (c) 2001, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"precompiled.hpp\"\n-#include \"classfile\/vmSymbols.hpp\"\n-#include \"logging\/log.hpp\"\n-#include \"memory\/allocation.inline.hpp\"\n-#include \"memory\/resourceArea.hpp\"\n-#include \"oops\/oop.inline.hpp\"\n-#include \"os_bsd.inline.hpp\"\n-#include \"runtime\/handles.inline.hpp\"\n-#include \"runtime\/os.hpp\"\n-#include \"runtime\/perfMemory.hpp\"\n-#include \"services\/memTracker.hpp\"\n-#include \"utilities\/exceptions.hpp\"\n-\n-\/\/ put OS-includes here\n-# include <sys\/types.h>\n-# include <sys\/mman.h>\n-# include <errno.h>\n-# include <stdio.h>\n-# include <unistd.h>\n-# include <sys\/stat.h>\n-# include <signal.h>\n-# include <pwd.h>\n-\n-static char* backing_store_file_name = NULL;  \/\/ name of the backing store\n-                                              \/\/ file, if successfully created.\n-\n-\/\/ Standard Memory Implementation Details\n-\n-\/\/ create the PerfData memory region in standard memory.\n-\/\/\n-static char* create_standard_memory(size_t size) {\n-\n-  \/\/ allocate an aligned chuck of memory\n-  char* mapAddress = os::reserve_memory(size);\n-\n-  if (mapAddress == NULL) {\n-    return NULL;\n-  }\n-\n-  \/\/ commit memory\n-  if (!os::commit_memory(mapAddress, size, !ExecMem)) {\n-    if (PrintMiscellaneous && Verbose) {\n-      warning(\"Could not commit PerfData memory\\n\");\n-    }\n-    os::release_memory(mapAddress, size);\n-    return NULL;\n-  }\n-\n-  return mapAddress;\n-}\n-\n-\/\/ delete the PerfData memory region\n-\/\/\n-static void delete_standard_memory(char* addr, size_t size) {\n-\n-  \/\/ there are no persistent external resources to cleanup for standard\n-  \/\/ memory. since DestroyJavaVM does not support unloading of the JVM,\n-  \/\/ cleanup of the memory resource is not performed. The memory will be\n-  \/\/ reclaimed by the OS upon termination of the process.\n-  \/\/\n-  return;\n-}\n-\n-\/\/ save the specified memory region to the given file\n-\/\/\n-\/\/ Note: this function might be called from signal handler (by os::abort()),\n-\/\/ don't allocate heap memory.\n-\/\/\n-static void save_memory_to_file(char* addr, size_t size) {\n-\n- const char* destfile = PerfMemory::get_perfdata_file_path();\n- assert(destfile[0] != '\\0', \"invalid PerfData file path\");\n-\n-  int result;\n-\n-  RESTARTABLE(::open(destfile, O_CREAT|O_WRONLY|O_TRUNC, S_IREAD|S_IWRITE),\n-              result);;\n-  if (result == OS_ERR) {\n-    if (PrintMiscellaneous && Verbose) {\n-      warning(\"Could not create Perfdata save file: %s: %s\\n\",\n-              destfile, os::strerror(errno));\n-    }\n-  } else {\n-    int fd = result;\n-\n-    for (size_t remaining = size; remaining > 0;) {\n-\n-      RESTARTABLE(::write(fd, addr, remaining), result);\n-      if (result == OS_ERR) {\n-        if (PrintMiscellaneous && Verbose) {\n-          warning(\"Could not write Perfdata save file: %s: %s\\n\",\n-                  destfile, os::strerror(errno));\n-        }\n-        break;\n-      }\n-\n-      remaining -= (size_t)result;\n-      addr += result;\n-    }\n-\n-    result = ::close(fd);\n-    if (PrintMiscellaneous && Verbose) {\n-      if (result == OS_ERR) {\n-        warning(\"Could not close %s: %s\\n\", destfile, os::strerror(errno));\n-      }\n-    }\n-  }\n-  FREE_C_HEAP_ARRAY(char, destfile);\n-}\n-\n-\n-\/\/ Shared Memory Implementation Details\n-\n-\/\/ Note: the solaris and bsd shared memory implementation uses the mmap\n-\/\/ interface with a backing store file to implement named shared memory.\n-\/\/ Using the file system as the name space for shared memory allows a\n-\/\/ common name space to be supported across a variety of platforms. It\n-\/\/ also provides a name space that Java applications can deal with through\n-\/\/ simple file apis.\n-\/\/\n-\/\/ The solaris and bsd implementations store the backing store file in\n-\/\/ a user specific temporary directory located in the \/tmp file system,\n-\/\/ which is always a local file system and is sometimes a RAM based file\n-\/\/ system.\n-\n-\/\/ return the user specific temporary directory name.\n-\/\/\n-\/\/ the caller is expected to free the allocated memory.\n-\/\/\n-static char* get_user_tmp_dir(const char* user) {\n-\n-  const char* tmpdir = os::get_temp_directory();\n-  const char* perfdir = PERFDATA_NAME;\n-  size_t nbytes = strlen(tmpdir) + strlen(perfdir) + strlen(user) + 3;\n-  char* dirname = NEW_C_HEAP_ARRAY(char, nbytes, mtInternal);\n-\n-  \/\/ construct the path name to user specific tmp directory\n-  snprintf(dirname, nbytes, \"%s\/%s_%s\", tmpdir, perfdir, user);\n-\n-  return dirname;\n-}\n-\n-\/\/ convert the given file name into a process id. if the file\n-\/\/ does not meet the file naming constraints, return 0.\n-\/\/\n-static pid_t filename_to_pid(const char* filename) {\n-\n-  \/\/ a filename that doesn't begin with a digit is not a\n-  \/\/ candidate for conversion.\n-  \/\/\n-  if (!isdigit(*filename)) {\n-    return 0;\n-  }\n-\n-  \/\/ check if file name can be converted to an integer without\n-  \/\/ any leftover characters.\n-  \/\/\n-  char* remainder = NULL;\n-  errno = 0;\n-  pid_t pid = (pid_t)strtol(filename, &remainder, 10);\n-\n-  if (errno != 0) {\n-    return 0;\n-  }\n-\n-  \/\/ check for left over characters. If any, then the filename is\n-  \/\/ not a candidate for conversion.\n-  \/\/\n-  if (remainder != NULL && *remainder != '\\0') {\n-    return 0;\n-  }\n-\n-  \/\/ successful conversion, return the pid\n-  return pid;\n-}\n-\n-\n-\/\/ Check if the given statbuf is considered a secure directory for\n-\/\/ the backing store files. Returns true if the directory is considered\n-\/\/ a secure location. Returns false if the statbuf is a symbolic link or\n-\/\/ if an error occurred.\n-\/\/\n-static bool is_statbuf_secure(struct stat *statp) {\n-  if (S_ISLNK(statp->st_mode) || !S_ISDIR(statp->st_mode)) {\n-    \/\/ The path represents a link or some non-directory file type,\n-    \/\/ which is not what we expected. Declare it insecure.\n-    \/\/\n-    return false;\n-  }\n-  \/\/ We have an existing directory, check if the permissions are safe.\n-  \/\/\n-  if ((statp->st_mode & (S_IWGRP|S_IWOTH)) != 0) {\n-    \/\/ The directory is open for writing and could be subjected\n-    \/\/ to a symlink or a hard link attack. Declare it insecure.\n-    \/\/\n-    return false;\n-  }\n-  \/\/ If user is not root then see if the uid of the directory matches the effective uid of the process.\n-  uid_t euid = geteuid();\n-  if ((euid != 0) && (statp->st_uid != euid)) {\n-    \/\/ The directory was not created by this user, declare it insecure.\n-    \/\/\n-    return false;\n-  }\n-  return true;\n-}\n-\n-\n-\/\/ Check if the given path is considered a secure directory for\n-\/\/ the backing store files. Returns true if the directory exists\n-\/\/ and is considered a secure location. Returns false if the path\n-\/\/ is a symbolic link or if an error occurred.\n-\/\/\n-static bool is_directory_secure(const char* path) {\n-  struct stat statbuf;\n-  int result = 0;\n-\n-  RESTARTABLE(::lstat(path, &statbuf), result);\n-  if (result == OS_ERR) {\n-    return false;\n-  }\n-\n-  \/\/ The path exists, see if it is secure.\n-  return is_statbuf_secure(&statbuf);\n-}\n-\n-\n-\/\/ Check if the given directory file descriptor is considered a secure\n-\/\/ directory for the backing store files. Returns true if the directory\n-\/\/ exists and is considered a secure location. Returns false if the path\n-\/\/ is a symbolic link or if an error occurred.\n-\/\/\n-static bool is_dirfd_secure(int dir_fd) {\n-  struct stat statbuf;\n-  int result = 0;\n-\n-  RESTARTABLE(::fstat(dir_fd, &statbuf), result);\n-  if (result == OS_ERR) {\n-    return false;\n-  }\n-\n-  \/\/ The path exists, now check its mode.\n-  return is_statbuf_secure(&statbuf);\n-}\n-\n-\n-\/\/ Check to make sure fd1 and fd2 are referencing the same file system object.\n-\/\/\n-static bool is_same_fsobject(int fd1, int fd2) {\n-  struct stat statbuf1;\n-  struct stat statbuf2;\n-  int result = 0;\n-\n-  RESTARTABLE(::fstat(fd1, &statbuf1), result);\n-  if (result == OS_ERR) {\n-    return false;\n-  }\n-  RESTARTABLE(::fstat(fd2, &statbuf2), result);\n-  if (result == OS_ERR) {\n-    return false;\n-  }\n-\n-  if ((statbuf1.st_ino == statbuf2.st_ino) &&\n-      (statbuf1.st_dev == statbuf2.st_dev)) {\n-    return true;\n-  } else {\n-    return false;\n-  }\n-}\n-\n-\n-\/\/ Open the directory of the given path and validate it.\n-\/\/ Return a DIR * of the open directory.\n-\/\/\n-static DIR *open_directory_secure(const char* dirname) {\n-  \/\/ Open the directory using open() so that it can be verified\n-  \/\/ to be secure by calling is_dirfd_secure(), opendir() and then check\n-  \/\/ to see if they are the same file system object.  This method does not\n-  \/\/ introduce a window of opportunity for the directory to be attacked that\n-  \/\/ calling opendir() and is_directory_secure() does.\n-  int result;\n-  DIR *dirp = NULL;\n-  RESTARTABLE(::open(dirname, O_RDONLY|O_NOFOLLOW), result);\n-  if (result == OS_ERR) {\n-    \/\/ Directory doesn't exist or is a symlink, so there is nothing to cleanup.\n-    if (PrintMiscellaneous && Verbose) {\n-      if (errno == ELOOP) {\n-        warning(\"directory %s is a symlink and is not secure\\n\", dirname);\n-      } else {\n-        warning(\"could not open directory %s: %s\\n\", dirname, os::strerror(errno));\n-      }\n-    }\n-    return dirp;\n-  }\n-  int fd = result;\n-\n-  \/\/ Determine if the open directory is secure.\n-  if (!is_dirfd_secure(fd)) {\n-    \/\/ The directory is not a secure directory.\n-    os::close(fd);\n-    return dirp;\n-  }\n-\n-  \/\/ Open the directory.\n-  dirp = ::opendir(dirname);\n-  if (dirp == NULL) {\n-    \/\/ The directory doesn't exist, close fd and return.\n-    os::close(fd);\n-    return dirp;\n-  }\n-\n-  \/\/ Check to make sure fd and dirp are referencing the same file system object.\n-  if (!is_same_fsobject(fd, dirfd(dirp))) {\n-    \/\/ The directory is not secure.\n-    os::close(fd);\n-    os::closedir(dirp);\n-    dirp = NULL;\n-    return dirp;\n-  }\n-\n-  \/\/ Close initial open now that we know directory is secure\n-  os::close(fd);\n-\n-  return dirp;\n-}\n-\n-\/\/ NOTE: The code below uses fchdir(), open() and unlink() because\n-\/\/ fdopendir(), openat() and unlinkat() are not supported on all\n-\/\/ versions.  Once the support for fdopendir(), openat() and unlinkat()\n-\/\/ is available on all supported versions the code can be changed\n-\/\/ to use these functions.\n-\n-\/\/ Open the directory of the given path, validate it and set the\n-\/\/ current working directory to it.\n-\/\/ Return a DIR * of the open directory and the saved cwd fd.\n-\/\/\n-static DIR *open_directory_secure_cwd(const char* dirname, int *saved_cwd_fd) {\n-\n-  \/\/ Open the directory.\n-  DIR* dirp = open_directory_secure(dirname);\n-  if (dirp == NULL) {\n-    \/\/ Directory doesn't exist or is insecure, so there is nothing to cleanup.\n-    return dirp;\n-  }\n-  int fd = dirfd(dirp);\n-\n-  \/\/ Open a fd to the cwd and save it off.\n-  int result;\n-  RESTARTABLE(::open(\".\", O_RDONLY), result);\n-  if (result == OS_ERR) {\n-    *saved_cwd_fd = -1;\n-  } else {\n-    *saved_cwd_fd = result;\n-  }\n-\n-  \/\/ Set the current directory to dirname by using the fd of the directory and\n-  \/\/ handle errors, otherwise shared memory files will be created in cwd.\n-  result = fchdir(fd);\n-  if (result == OS_ERR) {\n-    if (PrintMiscellaneous && Verbose) {\n-      warning(\"could not change to directory %s\", dirname);\n-    }\n-    if (*saved_cwd_fd != -1) {\n-      ::close(*saved_cwd_fd);\n-      *saved_cwd_fd = -1;\n-    }\n-    \/\/ Close the directory.\n-    os::closedir(dirp);\n-    return NULL;\n-  } else {\n-    return dirp;\n-  }\n-}\n-\n-\/\/ Close the directory and restore the current working directory.\n-\/\/\n-static void close_directory_secure_cwd(DIR* dirp, int saved_cwd_fd) {\n-\n-  int result;\n-  \/\/ If we have a saved cwd change back to it and close the fd.\n-  if (saved_cwd_fd != -1) {\n-    result = fchdir(saved_cwd_fd);\n-    ::close(saved_cwd_fd);\n-  }\n-\n-  \/\/ Close the directory.\n-  os::closedir(dirp);\n-}\n-\n-\/\/ Check if the given file descriptor is considered a secure.\n-\/\/\n-static bool is_file_secure(int fd, const char *filename) {\n-\n-  int result;\n-  struct stat statbuf;\n-\n-  \/\/ Determine if the file is secure.\n-  RESTARTABLE(::fstat(fd, &statbuf), result);\n-  if (result == OS_ERR) {\n-    if (PrintMiscellaneous && Verbose) {\n-      warning(\"fstat failed on %s: %s\\n\", filename, os::strerror(errno));\n-    }\n-    return false;\n-  }\n-  if (statbuf.st_nlink > 1) {\n-    \/\/ A file with multiple links is not expected.\n-    if (PrintMiscellaneous && Verbose) {\n-      warning(\"file %s has multiple links\\n\", filename);\n-    }\n-    return false;\n-  }\n-  return true;\n-}\n-\n-\/\/ return the user name for the given user id\n-\/\/\n-\/\/ the caller is expected to free the allocated memory.\n-\/\/\n-static char* get_user_name(uid_t uid) {\n-\n-  struct passwd pwent;\n-\n-  \/\/ determine the max pwbuf size from sysconf, and hardcode\n-  \/\/ a default if this not available through sysconf.\n-  \/\/\n-  long bufsize = sysconf(_SC_GETPW_R_SIZE_MAX);\n-  if (bufsize == -1)\n-    bufsize = 1024;\n-\n-  char* pwbuf = NEW_C_HEAP_ARRAY(char, bufsize, mtInternal);\n-\n-  \/\/ POSIX interface to getpwuid_r is used on LINUX\n-  struct passwd* p;\n-  int result = getpwuid_r(uid, &pwent, pwbuf, (size_t)bufsize, &p);\n-\n-  if (result != 0 || p == NULL || p->pw_name == NULL || *(p->pw_name) == '\\0') {\n-    if (PrintMiscellaneous && Verbose) {\n-      if (result != 0) {\n-        warning(\"Could not retrieve passwd entry: %s\\n\",\n-                os::strerror(result));\n-      }\n-      else if (p == NULL) {\n-        \/\/ this check is added to protect against an observed problem\n-        \/\/ with getpwuid_r() on RedHat 9 where getpwuid_r returns 0,\n-        \/\/ indicating success, but has p == NULL. This was observed when\n-        \/\/ inserting a file descriptor exhaustion fault prior to the call\n-        \/\/ getpwuid_r() call. In this case, error is set to the appropriate\n-        \/\/ error condition, but this is undocumented behavior. This check\n-        \/\/ is safe under any condition, but the use of errno in the output\n-        \/\/ message may result in an erroneous message.\n-        \/\/ Bug Id 89052 was opened with RedHat.\n-        \/\/\n-        warning(\"Could not retrieve passwd entry: %s\\n\",\n-                os::strerror(errno));\n-      }\n-      else {\n-        warning(\"Could not determine user name: %s\\n\",\n-                p->pw_name == NULL ? \"pw_name = NULL\" :\n-                                     \"pw_name zero length\");\n-      }\n-    }\n-    FREE_C_HEAP_ARRAY(char, pwbuf);\n-    return NULL;\n-  }\n-\n-  char* user_name = NEW_C_HEAP_ARRAY(char, strlen(p->pw_name) + 1, mtInternal);\n-  strcpy(user_name, p->pw_name);\n-\n-  FREE_C_HEAP_ARRAY(char, pwbuf);\n-  return user_name;\n-}\n-\n-\/\/ return the name of the user that owns the process identified by vmid.\n-\/\/\n-\/\/ This method uses a slow directory search algorithm to find the backing\n-\/\/ store file for the specified vmid and returns the user name, as determined\n-\/\/ by the user name suffix of the hsperfdata_<username> directory name.\n-\/\/\n-\/\/ the caller is expected to free the allocated memory.\n-\/\/\n-static char* get_user_name_slow(int vmid, TRAPS) {\n-\n-  \/\/ short circuit the directory search if the process doesn't even exist.\n-  if (kill(vmid, 0) == OS_ERR) {\n-    if (errno == ESRCH) {\n-      THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),\n-                  \"Process not found\");\n-    }\n-    else \/* EPERM *\/ {\n-      THROW_MSG_0(vmSymbols::java_io_IOException(), os::strerror(errno));\n-    }\n-  }\n-\n-  \/\/ directory search\n-  char* oldest_user = NULL;\n-  time_t oldest_ctime = 0;\n-\n-  const char* tmpdirname = os::get_temp_directory();\n-\n-  \/\/ open the temp directory\n-  DIR* tmpdirp = os::opendir(tmpdirname);\n-\n-  if (tmpdirp == NULL) {\n-    \/\/ Cannot open the directory to get the user name, return.\n-    return NULL;\n-  }\n-\n-  \/\/ for each entry in the directory that matches the pattern hsperfdata_*,\n-  \/\/ open the directory and check if the file for the given vmid exists.\n-  \/\/ The file with the expected name and the latest creation date is used\n-  \/\/ to determine the user name for the process id.\n-  \/\/\n-  struct dirent* dentry;\n-  errno = 0;\n-  while ((dentry = os::readdir(tmpdirp)) != NULL) {\n-\n-    \/\/ check if the directory entry is a hsperfdata file\n-    if (strncmp(dentry->d_name, PERFDATA_NAME, strlen(PERFDATA_NAME)) != 0) {\n-      continue;\n-    }\n-\n-    char* usrdir_name = NEW_C_HEAP_ARRAY(char,\n-                 strlen(tmpdirname) + strlen(dentry->d_name) + 2, mtInternal);\n-    strcpy(usrdir_name, tmpdirname);\n-    strcat(usrdir_name, \"\/\");\n-    strcat(usrdir_name, dentry->d_name);\n-\n-    \/\/ open the user directory\n-    DIR* subdirp = open_directory_secure(usrdir_name);\n-\n-    if (subdirp == NULL) {\n-      FREE_C_HEAP_ARRAY(char, usrdir_name);\n-      continue;\n-    }\n-\n-    struct dirent* udentry;\n-    errno = 0;\n-    while ((udentry = os::readdir(subdirp)) != NULL) {\n-\n-      if (filename_to_pid(udentry->d_name) == vmid) {\n-        struct stat statbuf;\n-        int result;\n-\n-        char* filename = NEW_C_HEAP_ARRAY(char,\n-                 strlen(usrdir_name) + strlen(udentry->d_name) + 2, mtInternal);\n-\n-        strcpy(filename, usrdir_name);\n-        strcat(filename, \"\/\");\n-        strcat(filename, udentry->d_name);\n-\n-        \/\/ don't follow symbolic links for the file\n-        RESTARTABLE(::lstat(filename, &statbuf), result);\n-        if (result == OS_ERR) {\n-           FREE_C_HEAP_ARRAY(char, filename);\n-           continue;\n-        }\n-\n-        \/\/ skip over files that are not regular files.\n-        if (!S_ISREG(statbuf.st_mode)) {\n-          FREE_C_HEAP_ARRAY(char, filename);\n-          continue;\n-        }\n-\n-        \/\/ compare and save filename with latest creation time\n-        if (statbuf.st_size > 0 && statbuf.st_ctime > oldest_ctime) {\n-\n-          if (statbuf.st_ctime > oldest_ctime) {\n-            char* user = strchr(dentry->d_name, '_') + 1;\n-\n-            FREE_C_HEAP_ARRAY(char, oldest_user);\n-            oldest_user = NEW_C_HEAP_ARRAY(char, strlen(user)+1, mtInternal);\n-\n-            strcpy(oldest_user, user);\n-            oldest_ctime = statbuf.st_ctime;\n-          }\n-        }\n-\n-        FREE_C_HEAP_ARRAY(char, filename);\n-      }\n-    }\n-    os::closedir(subdirp);\n-    FREE_C_HEAP_ARRAY(char, usrdir_name);\n-  }\n-  os::closedir(tmpdirp);\n-\n-  return(oldest_user);\n-}\n-\n-\/\/ return the name of the user that owns the JVM indicated by the given vmid.\n-\/\/\n-static char* get_user_name(int vmid, TRAPS) {\n-  return get_user_name_slow(vmid, THREAD);\n-}\n-\n-\/\/ return the file name of the backing store file for the named\n-\/\/ shared memory region for the given user name and vmid.\n-\/\/\n-\/\/ the caller is expected to free the allocated memory.\n-\/\/\n-static char* get_sharedmem_filename(const char* dirname, int vmid) {\n-\n-  \/\/ add 2 for the file separator and a null terminator.\n-  size_t nbytes = strlen(dirname) + UINT_CHARS + 2;\n-\n-  char* name = NEW_C_HEAP_ARRAY(char, nbytes, mtInternal);\n-  snprintf(name, nbytes, \"%s\/%d\", dirname, vmid);\n-\n-  return name;\n-}\n-\n-\n-\/\/ remove file\n-\/\/\n-\/\/ this method removes the file specified by the given path\n-\/\/\n-static void remove_file(const char* path) {\n-\n-  int result;\n-\n-  \/\/ if the file is a directory, the following unlink will fail. since\n-  \/\/ we don't expect to find directories in the user temp directory, we\n-  \/\/ won't try to handle this situation. even if accidentially or\n-  \/\/ maliciously planted, the directory's presence won't hurt anything.\n-  \/\/\n-  RESTARTABLE(::unlink(path), result);\n-  if (PrintMiscellaneous && Verbose && result == OS_ERR) {\n-    if (errno != ENOENT) {\n-      warning(\"Could not unlink shared memory backing\"\n-              \" store file %s : %s\\n\", path, os::strerror(errno));\n-    }\n-  }\n-}\n-\n-\n-\/\/ cleanup stale shared memory resources\n-\/\/\n-\/\/ This method attempts to remove all stale shared memory files in\n-\/\/ the named user temporary directory. It scans the named directory\n-\/\/ for files matching the pattern ^$[0-9]*$. For each file found, the\n-\/\/ process id is extracted from the file name and a test is run to\n-\/\/ determine if the process is alive. If the process is not alive,\n-\/\/ any stale file resources are removed.\n-\/\/\n-static void cleanup_sharedmem_resources(const char* dirname) {\n-\n-  int saved_cwd_fd;\n-  \/\/ open the directory and set the current working directory to it\n-  DIR* dirp = open_directory_secure_cwd(dirname, &saved_cwd_fd);\n-  if (dirp == NULL) {\n-    \/\/ directory doesn't exist or is insecure, so there is nothing to cleanup\n-    return;\n-  }\n-\n-  \/\/ for each entry in the directory that matches the expected file\n-  \/\/ name pattern, determine if the file resources are stale and if\n-  \/\/ so, remove the file resources. Note, instrumented HotSpot processes\n-  \/\/ for this user may start and\/or terminate during this search and\n-  \/\/ remove or create new files in this directory. The behavior of this\n-  \/\/ loop under these conditions is dependent upon the implementation of\n-  \/\/ opendir\/readdir.\n-  \/\/\n-  struct dirent* entry;\n-  errno = 0;\n-  while ((entry = os::readdir(dirp)) != NULL) {\n-\n-    pid_t pid = filename_to_pid(entry->d_name);\n-\n-    if (pid == 0) {\n-\n-      if (strcmp(entry->d_name, \".\") != 0 && strcmp(entry->d_name, \"..\") != 0) {\n-\n-        \/\/ attempt to remove all unexpected files, except \".\" and \"..\"\n-        unlink(entry->d_name);\n-      }\n-\n-      errno = 0;\n-      continue;\n-    }\n-\n-    \/\/ we now have a file name that converts to a valid integer\n-    \/\/ that could represent a process id . if this process id\n-    \/\/ matches the current process id or the process is not running,\n-    \/\/ then remove the stale file resources.\n-    \/\/\n-    \/\/ process liveness is detected by sending signal number 0 to\n-    \/\/ the process id (see kill(2)). if kill determines that the\n-    \/\/ process does not exist, then the file resources are removed.\n-    \/\/ if kill determines that that we don't have permission to\n-    \/\/ signal the process, then the file resources are assumed to\n-    \/\/ be stale and are removed because the resources for such a\n-    \/\/ process should be in a different user specific directory.\n-    \/\/\n-    if ((pid == os::current_process_id()) ||\n-        (kill(pid, 0) == OS_ERR && (errno == ESRCH || errno == EPERM))) {\n-\n-        unlink(entry->d_name);\n-    }\n-    errno = 0;\n-  }\n-\n-  \/\/ close the directory and reset the current working directory\n-  close_directory_secure_cwd(dirp, saved_cwd_fd);\n-}\n-\n-\/\/ make the user specific temporary directory. Returns true if\n-\/\/ the directory exists and is secure upon return. Returns false\n-\/\/ if the directory exists but is either a symlink, is otherwise\n-\/\/ insecure, or if an error occurred.\n-\/\/\n-static bool make_user_tmp_dir(const char* dirname) {\n-\n-  \/\/ create the directory with 0755 permissions. note that the directory\n-  \/\/ will be owned by euid::egid, which may not be the same as uid::gid.\n-  \/\/\n-  if (mkdir(dirname, S_IRWXU|S_IRGRP|S_IXGRP|S_IROTH|S_IXOTH) == OS_ERR) {\n-    if (errno == EEXIST) {\n-      \/\/ The directory already exists and was probably created by another\n-      \/\/ JVM instance. However, this could also be the result of a\n-      \/\/ deliberate symlink. Verify that the existing directory is safe.\n-      \/\/\n-      if (!is_directory_secure(dirname)) {\n-        \/\/ directory is not secure\n-        if (PrintMiscellaneous && Verbose) {\n-          warning(\"%s directory is insecure\\n\", dirname);\n-        }\n-        return false;\n-      }\n-    }\n-    else {\n-      \/\/ we encountered some other failure while attempting\n-      \/\/ to create the directory\n-      \/\/\n-      if (PrintMiscellaneous && Verbose) {\n-        warning(\"could not create directory %s: %s\\n\",\n-                dirname, os::strerror(errno));\n-      }\n-      return false;\n-    }\n-  }\n-  return true;\n-}\n-\n-\/\/ create the shared memory file resources\n-\/\/\n-\/\/ This method creates the shared memory file with the given size\n-\/\/ This method also creates the user specific temporary directory, if\n-\/\/ it does not yet exist.\n-\/\/\n-static int create_sharedmem_resources(const char* dirname, const char* filename, size_t size) {\n-\n-  \/\/ make the user temporary directory\n-  if (!make_user_tmp_dir(dirname)) {\n-    \/\/ could not make\/find the directory or the found directory\n-    \/\/ was not secure\n-    return -1;\n-  }\n-\n-  int saved_cwd_fd;\n-  \/\/ open the directory and set the current working directory to it\n-  DIR* dirp = open_directory_secure_cwd(dirname, &saved_cwd_fd);\n-  if (dirp == NULL) {\n-    \/\/ Directory doesn't exist or is insecure, so cannot create shared\n-    \/\/ memory file.\n-    return -1;\n-  }\n-\n-  \/\/ Open the filename in the current directory.\n-  \/\/ Cannot use O_TRUNC here; truncation of an existing file has to happen\n-  \/\/ after the is_file_secure() check below.\n-  int result;\n-  RESTARTABLE(::open(filename, O_RDWR|O_CREAT|O_NOFOLLOW, S_IREAD|S_IWRITE), result);\n-  if (result == OS_ERR) {\n-    if (PrintMiscellaneous && Verbose) {\n-      if (errno == ELOOP) {\n-        warning(\"file %s is a symlink and is not secure\\n\", filename);\n-      } else {\n-        warning(\"could not create file %s: %s\\n\", filename, os::strerror(errno));\n-      }\n-    }\n-    \/\/ close the directory and reset the current working directory\n-    close_directory_secure_cwd(dirp, saved_cwd_fd);\n-\n-    return -1;\n-  }\n-  \/\/ close the directory and reset the current working directory\n-  close_directory_secure_cwd(dirp, saved_cwd_fd);\n-\n-  \/\/ save the file descriptor\n-  int fd = result;\n-\n-  \/\/ check to see if the file is secure\n-  if (!is_file_secure(fd, filename)) {\n-    ::close(fd);\n-    return -1;\n-  }\n-\n-  \/\/ truncate the file to get rid of any existing data\n-  RESTARTABLE(::ftruncate(fd, (off_t)0), result);\n-  if (result == OS_ERR) {\n-    if (PrintMiscellaneous && Verbose) {\n-      warning(\"could not truncate shared memory file: %s\\n\", os::strerror(errno));\n-    }\n-    ::close(fd);\n-    return -1;\n-  }\n-  \/\/ set the file size\n-  RESTARTABLE(::ftruncate(fd, (off_t)size), result);\n-  if (result == OS_ERR) {\n-    if (PrintMiscellaneous && Verbose) {\n-      warning(\"could not set shared memory file size: %s\\n\", os::strerror(errno));\n-    }\n-    ::close(fd);\n-    return -1;\n-  }\n-\n-  \/\/ Verify that we have enough disk space for this file.\n-  \/\/ We'll get random SIGBUS crashes on memory accesses if\n-  \/\/ we don't.\n-\n-  for (size_t seekpos = 0; seekpos < size; seekpos += os::vm_page_size()) {\n-    int zero_int = 0;\n-    result = (int)os::seek_to_file_offset(fd, (jlong)(seekpos));\n-    if (result == -1 ) break;\n-    RESTARTABLE(::write(fd, &zero_int, 1), result);\n-    if (result != 1) {\n-      if (errno == ENOSPC) {\n-        warning(\"Insufficient space for shared memory file:\\n   %s\\nTry using the -Djava.io.tmpdir= option to select an alternate temp location.\\n\", filename);\n-      }\n-      break;\n-    }\n-  }\n-\n-  if (result != -1) {\n-    return fd;\n-  } else {\n-    ::close(fd);\n-    return -1;\n-  }\n-}\n-\n-\/\/ open the shared memory file for the given user and vmid. returns\n-\/\/ the file descriptor for the open file or -1 if the file could not\n-\/\/ be opened.\n-\/\/\n-static int open_sharedmem_file(const char* filename, int oflags, TRAPS) {\n-\n-  \/\/ open the file\n-  int result;\n-  RESTARTABLE(::open(filename, oflags), result);\n-  if (result == OS_ERR) {\n-    if (errno == ENOENT) {\n-      THROW_MSG_(vmSymbols::java_lang_IllegalArgumentException(),\n-                 \"Process not found\", OS_ERR);\n-    }\n-    else if (errno == EACCES) {\n-      THROW_MSG_(vmSymbols::java_lang_IllegalArgumentException(),\n-                 \"Permission denied\", OS_ERR);\n-    }\n-    else {\n-      THROW_MSG_(vmSymbols::java_io_IOException(),\n-                 os::strerror(errno), OS_ERR);\n-    }\n-  }\n-  int fd = result;\n-\n-  \/\/ check to see if the file is secure\n-  if (!is_file_secure(fd, filename)) {\n-    ::close(fd);\n-    return -1;\n-  }\n-\n-  return fd;\n-}\n-\n-\/\/ create a named shared memory region. returns the address of the\n-\/\/ memory region on success or NULL on failure. A return value of\n-\/\/ NULL will ultimately disable the shared memory feature.\n-\/\/\n-\/\/ On BSD, the name space for shared memory objects\n-\/\/ is the file system name space.\n-\/\/\n-\/\/ A monitoring application attaching to a JVM does not need to know\n-\/\/ the file system name of the shared memory object. However, it may\n-\/\/ be convenient for applications to discover the existence of newly\n-\/\/ created and terminating JVMs by watching the file system name space\n-\/\/ for files being created or removed.\n-\/\/\n-static char* mmap_create_shared(size_t size) {\n-\n-  int result;\n-  int fd;\n-  char* mapAddress;\n-\n-  int vmid = os::current_process_id();\n-\n-  char* user_name = get_user_name(geteuid());\n-\n-  if (user_name == NULL)\n-    return NULL;\n-\n-  char* dirname = get_user_tmp_dir(user_name);\n-  char* filename = get_sharedmem_filename(dirname, vmid);\n-\n-  \/\/ get the short filename\n-  char* short_filename = strrchr(filename, '\/');\n-  if (short_filename == NULL) {\n-    short_filename = filename;\n-  } else {\n-    short_filename++;\n-  }\n-\n-  \/\/ cleanup any stale shared memory files\n-  cleanup_sharedmem_resources(dirname);\n-\n-  assert(((size > 0) && (size % os::vm_page_size() == 0)),\n-         \"unexpected PerfMemory region size\");\n-\n-  fd = create_sharedmem_resources(dirname, short_filename, size);\n-\n-  FREE_C_HEAP_ARRAY(char, user_name);\n-  FREE_C_HEAP_ARRAY(char, dirname);\n-\n-  if (fd == -1) {\n-    FREE_C_HEAP_ARRAY(char, filename);\n-    return NULL;\n-  }\n-\n-  mapAddress = (char*)::mmap((char*)0, size, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);\n-\n-  result = ::close(fd);\n-  assert(result != OS_ERR, \"could not close file\");\n-\n-  if (mapAddress == MAP_FAILED) {\n-    if (PrintMiscellaneous && Verbose) {\n-      warning(\"mmap failed -  %s\\n\", os::strerror(errno));\n-    }\n-    remove_file(filename);\n-    FREE_C_HEAP_ARRAY(char, filename);\n-    return NULL;\n-  }\n-\n-  \/\/ save the file name for use in delete_shared_memory()\n-  backing_store_file_name = filename;\n-\n-  \/\/ clear the shared memory region\n-  (void)::memset((void*) mapAddress, 0, size);\n-\n-  \/\/ it does not go through os api, the operation has to record from here\n-  MemTracker::record_virtual_memory_reserve_and_commit((address)mapAddress, size, CURRENT_PC, mtInternal);\n-\n-  return mapAddress;\n-}\n-\n-\/\/ release a named shared memory region\n-\/\/\n-static void unmap_shared(char* addr, size_t bytes) {\n-  os::release_memory(addr, bytes);\n-}\n-\n-\/\/ create the PerfData memory region in shared memory.\n-\/\/\n-static char* create_shared_memory(size_t size) {\n-\n-  \/\/ create the shared memory region.\n-  return mmap_create_shared(size);\n-}\n-\n-\/\/ delete the shared PerfData memory region\n-\/\/\n-static void delete_shared_memory(char* addr, size_t size) {\n-\n-  \/\/ cleanup the persistent shared memory resources. since DestroyJavaVM does\n-  \/\/ not support unloading of the JVM, unmapping of the memory resource is\n-  \/\/ not performed. The memory will be reclaimed by the OS upon termination of\n-  \/\/ the process. The backing store file is deleted from the file system.\n-\n-  assert(!PerfDisableSharedMem, \"shouldn't be here\");\n-\n-  if (backing_store_file_name != NULL) {\n-    remove_file(backing_store_file_name);\n-    \/\/ Don't.. Free heap memory could deadlock os::abort() if it is called\n-    \/\/ from signal handler. OS will reclaim the heap memory.\n-    \/\/ FREE_C_HEAP_ARRAY(char, backing_store_file_name);\n-    backing_store_file_name = NULL;\n-  }\n-}\n-\n-\/\/ return the size of the file for the given file descriptor\n-\/\/ or 0 if it is not a valid size for a shared memory file\n-\/\/\n-static size_t sharedmem_filesize(int fd, TRAPS) {\n-\n-  struct stat statbuf;\n-  int result;\n-\n-  RESTARTABLE(::fstat(fd, &statbuf), result);\n-  if (result == OS_ERR) {\n-    if (PrintMiscellaneous && Verbose) {\n-      warning(\"fstat failed: %s\\n\", os::strerror(errno));\n-    }\n-    THROW_MSG_0(vmSymbols::java_io_IOException(),\n-                \"Could not determine PerfMemory size\");\n-  }\n-\n-  if ((statbuf.st_size == 0) ||\n-     ((size_t)statbuf.st_size % os::vm_page_size() != 0)) {\n-    THROW_MSG_0(vmSymbols::java_io_IOException(),\n-                \"Invalid PerfMemory size\");\n-  }\n-\n-  return (size_t)statbuf.st_size;\n-}\n-\n-\/\/ attach to a named shared memory region.\n-\/\/\n-static void mmap_attach_shared(const char* user, int vmid, PerfMemory::PerfMemoryMode mode, char** addr, size_t* sizep, TRAPS) {\n-\n-  char* mapAddress;\n-  int result;\n-  int fd;\n-  size_t size = 0;\n-  const char* luser = NULL;\n-\n-  int mmap_prot;\n-  int file_flags;\n-\n-  ResourceMark rm;\n-\n-  \/\/ map the high level access mode to the appropriate permission\n-  \/\/ constructs for the file and the shared memory mapping.\n-  if (mode == PerfMemory::PERF_MODE_RO) {\n-    mmap_prot = PROT_READ;\n-    file_flags = O_RDONLY | O_NOFOLLOW;\n-  }\n-  else if (mode == PerfMemory::PERF_MODE_RW) {\n-#ifdef LATER\n-    mmap_prot = PROT_READ | PROT_WRITE;\n-    file_flags = O_RDWR | O_NOFOLLOW;\n-#else\n-    THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(),\n-              \"Unsupported access mode\");\n-#endif\n-  }\n-  else {\n-    THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(),\n-              \"Illegal access mode\");\n-  }\n-\n-  if (user == NULL || strlen(user) == 0) {\n-    luser = get_user_name(vmid, CHECK);\n-  }\n-  else {\n-    luser = user;\n-  }\n-\n-  if (luser == NULL) {\n-    THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(),\n-              \"Could not map vmid to user Name\");\n-  }\n-\n-  char* dirname = get_user_tmp_dir(luser);\n-\n-  \/\/ since we don't follow symbolic links when creating the backing\n-  \/\/ store file, we don't follow them when attaching either.\n-  \/\/\n-  if (!is_directory_secure(dirname)) {\n-    FREE_C_HEAP_ARRAY(char, dirname);\n-    if (luser != user) {\n-      FREE_C_HEAP_ARRAY(char, luser);\n-    }\n-    THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(),\n-              \"Process not found\");\n-  }\n-\n-  char* filename = get_sharedmem_filename(dirname, vmid);\n-\n-  \/\/ copy heap memory to resource memory. the open_sharedmem_file\n-  \/\/ method below need to use the filename, but could throw an\n-  \/\/ exception. using a resource array prevents the leak that\n-  \/\/ would otherwise occur.\n-  char* rfilename = NEW_RESOURCE_ARRAY(char, strlen(filename) + 1);\n-  strcpy(rfilename, filename);\n-\n-  \/\/ free the c heap resources that are no longer needed\n-  if (luser != user) FREE_C_HEAP_ARRAY(char, luser);\n-  FREE_C_HEAP_ARRAY(char, dirname);\n-  FREE_C_HEAP_ARRAY(char, filename);\n-\n-  \/\/ open the shared memory file for the give vmid\n-  fd = open_sharedmem_file(rfilename, file_flags, CHECK);\n-  assert(fd != OS_ERR, \"unexpected value\");\n-\n-  if (*sizep == 0) {\n-    size = sharedmem_filesize(fd, CHECK);\n-  } else {\n-    size = *sizep;\n-  }\n-\n-  assert(size > 0, \"unexpected size <= 0\");\n-\n-  mapAddress = (char*)::mmap((char*)0, size, mmap_prot, MAP_SHARED, fd, 0);\n-\n-  \/\/ attempt to close the file - restart if it gets interrupted,\n-  \/\/ but ignore other failures\n-  result = ::close(fd);\n-  assert(result != OS_ERR, \"could not close file\");\n-\n-  if (mapAddress == MAP_FAILED) {\n-    if (PrintMiscellaneous && Verbose) {\n-      warning(\"mmap failed: %s\\n\", os::strerror(errno));\n-    }\n-    THROW_MSG(vmSymbols::java_lang_OutOfMemoryError(),\n-              \"Could not map PerfMemory\");\n-  }\n-\n-  \/\/ it does not go through os api, the operation has to record from here\n-  MemTracker::record_virtual_memory_reserve_and_commit((address)mapAddress, size, CURRENT_PC, mtInternal);\n-\n-  *addr = mapAddress;\n-  *sizep = size;\n-\n-  log_debug(perf, memops)(\"mapped \" SIZE_FORMAT \" bytes for vmid %d at \"\n-                          INTPTR_FORMAT, size, vmid, p2i((void*)mapAddress));\n-}\n-\n-\/\/ create the PerfData memory region\n-\/\/\n-\/\/ This method creates the memory region used to store performance\n-\/\/ data for the JVM. The memory may be created in standard or\n-\/\/ shared memory.\n-\/\/\n-void PerfMemory::create_memory_region(size_t size) {\n-\n-  if (PerfDisableSharedMem) {\n-    \/\/ do not share the memory for the performance data.\n-    _start = create_standard_memory(size);\n-  }\n-  else {\n-    _start = create_shared_memory(size);\n-    if (_start == NULL) {\n-\n-      \/\/ creation of the shared memory region failed, attempt\n-      \/\/ to create a contiguous, non-shared memory region instead.\n-      \/\/\n-      if (PrintMiscellaneous && Verbose) {\n-        warning(\"Reverting to non-shared PerfMemory region.\\n\");\n-      }\n-      PerfDisableSharedMem = true;\n-      _start = create_standard_memory(size);\n-    }\n-  }\n-\n-  if (_start != NULL) _capacity = size;\n-\n-}\n-\n-\/\/ delete the PerfData memory region\n-\/\/\n-\/\/ This method deletes the memory region used to store performance\n-\/\/ data for the JVM. The memory region indicated by the <address, size>\n-\/\/ tuple will be inaccessible after a call to this method.\n-\/\/\n-void PerfMemory::delete_memory_region() {\n-\n-  assert((start() != NULL && capacity() > 0), \"verify proper state\");\n-\n-  \/\/ If user specifies PerfDataSaveFile, it will save the performance data\n-  \/\/ to the specified file name no matter whether PerfDataSaveToFile is specified\n-  \/\/ or not. In other word, -XX:PerfDataSaveFile=.. overrides flag\n-  \/\/ -XX:+PerfDataSaveToFile.\n-  if (PerfDataSaveToFile || PerfDataSaveFile != NULL) {\n-    save_memory_to_file(start(), capacity());\n-  }\n-\n-  if (PerfDisableSharedMem) {\n-    delete_standard_memory(start(), capacity());\n-  }\n-  else {\n-    delete_shared_memory(start(), capacity());\n-  }\n-}\n-\n-\/\/ attach to the PerfData memory region for another JVM\n-\/\/\n-\/\/ This method returns an <address, size> tuple that points to\n-\/\/ a memory buffer that is kept reasonably synchronized with\n-\/\/ the PerfData memory region for the indicated JVM. This\n-\/\/ buffer may be kept in synchronization via shared memory\n-\/\/ or some other mechanism that keeps the buffer updated.\n-\/\/\n-\/\/ If the JVM chooses not to support the attachability feature,\n-\/\/ this method should throw an UnsupportedOperation exception.\n-\/\/\n-\/\/ This implementation utilizes named shared memory to map\n-\/\/ the indicated process's PerfData memory region into this JVMs\n-\/\/ address space.\n-\/\/\n-void PerfMemory::attach(const char* user, int vmid, PerfMemoryMode mode, char** addrp, size_t* sizep, TRAPS) {\n-\n-  if (vmid == 0 || vmid == os::current_process_id()) {\n-     *addrp = start();\n-     *sizep = capacity();\n-     return;\n-  }\n-\n-  mmap_attach_shared(user, vmid, mode, addrp, sizep, CHECK);\n-}\n-\n-\/\/ detach from the PerfData memory region of another JVM\n-\/\/\n-\/\/ This method detaches the PerfData memory region of another\n-\/\/ JVM, specified as an <address, size> tuple of a buffer\n-\/\/ in this process's address space. This method may perform\n-\/\/ arbitrary actions to accomplish the detachment. The memory\n-\/\/ region specified by <address, size> will be inaccessible after\n-\/\/ a call to this method.\n-\/\/\n-\/\/ If the JVM chooses not to support the attachability feature,\n-\/\/ this method should throw an UnsupportedOperation exception.\n-\/\/\n-\/\/ This implementation utilizes named shared memory to detach\n-\/\/ the indicated process's PerfData memory region from this\n-\/\/ process's address space.\n-\/\/\n-void PerfMemory::detach(char* addr, size_t bytes, TRAPS) {\n-\n-  assert(addr != 0, \"address sanity check\");\n-  assert(bytes > 0, \"capacity sanity check\");\n-\n-  if (PerfMemory::contains(addr) || PerfMemory::contains(addr + bytes - 1)) {\n-    \/\/ prevent accidental detachment of this process's PerfMemory region\n-    return;\n-  }\n-\n-  unmap_shared(addr, bytes);\n-}\n","filename":"src\/hotspot\/os\/bsd\/perfMemory_bsd.cpp","additions":0,"deletions":1260,"binary":false,"changes":1260,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -4352,0 +4352,31 @@\n+\/\/ Determine if the vmid is the parent pid for a child in a PID namespace.\n+\/\/ Return the namespace pid if so, otherwise -1.\n+int os::Linux::get_namespace_pid(int vmid) {\n+  char fname[24];\n+  int retpid = -1;\n+\n+  snprintf(fname, sizeof(fname), \"\/proc\/%d\/status\", vmid);\n+  FILE *fp = fopen(fname, \"r\");\n+\n+  if (fp) {\n+    int pid, nspid;\n+    int ret;\n+    while (!feof(fp) && !ferror(fp)) {\n+      ret = fscanf(fp, \"NSpid: %d %d\", &pid, &nspid);\n+      if (ret == 1) {\n+        break;\n+      }\n+      if (ret == 2) {\n+        retpid = nspid;\n+        break;\n+      }\n+      for (;;) {\n+        int ch = fgetc(fp);\n+        if (ch == EOF || ch == (int)'\\n') break;\n+      }\n+    }\n+    fclose(fp);\n+  }\n+  return retpid;\n+}\n+\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":32,"deletions":1,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -172,0 +172,4 @@\n+  \/\/ Determine if the vmid is the parent pid for a child in a PID namespace.\n+  \/\/ Return the namespace pid if so, otherwise -1.\n+  static int get_namespace_pid(int vmid);\n+\n","filename":"src\/hotspot\/os\/linux\/os_linux.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -67,12 +67,0 @@\n-\/\/ macros for restartable system calls\n-\n-#define RESTARTABLE(_cmd, _result) do { \\\n-    _result = _cmd; \\\n-  } while(((int)_result == OS_ERR) && (errno == EINTR))\n-\n-#define RESTARTABLE_RETURN_INT(_cmd) do { \\\n-  int _result; \\\n-  RESTARTABLE(_cmd, _result); \\\n-  return _result; \\\n-} while(false)\n-\n@@ -88,4 +76,0 @@\n-inline int os::close(int fd) {\n-  return ::close(fd);\n-}\n-\n","filename":"src\/hotspot\/os\/linux\/os_linux.inline.hpp","additions":1,"deletions":17,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,19 @@\n+#include <unistd.h>\n+\n+\/\/ macros for restartable system calls\n+\n+#define RESTARTABLE(_cmd, _result) do { \\\n+    _result = _cmd; \\\n+  } while(((int)_result == OS_ERR) && (errno == EINTR))\n+\n+#define RESTARTABLE_RETURN_INT(_cmd) do { \\\n+  int _result; \\\n+  RESTARTABLE(_cmd, _result); \\\n+  return _result; \\\n+} while(false)\n+\n+\n+inline int os::close(int fd) {\n+  return ::close(fd);\n+}\n+\n","filename":"src\/hotspot\/os\/posix\/os_posix.inline.hpp","additions":20,"deletions":1,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,2 @@\n- * Copyright (c) 2001, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2020 SAP SE. All rights reserved.\n@@ -31,1 +32,1 @@\n-#include \"os_linux.inline.hpp\"\n+#include \"os_posix.inline.hpp\"\n@@ -95,2 +96,2 @@\n- const char* destfile = PerfMemory::get_perfdata_file_path();\n- assert(destfile[0] != '\\0', \"invalid PerfData file path\");\n+  const char* destfile = PerfMemory::get_perfdata_file_path();\n+  assert(destfile[0] != '\\0', \"invalid PerfData file path\");\n@@ -138,1 +139,1 @@\n-\/\/ Note: the solaris and linux shared memory implementation uses the mmap\n+\/\/ Note: the Posix shared memory implementation uses the mmap\n@@ -145,5 +146,0 @@\n-\/\/ The solaris and linux implementations store the backing store file in\n-\/\/ a user specific temporary directory located in the \/tmp file system,\n-\/\/ which is always a local file system and is sometimes a RAM based file\n-\/\/ system.\n-\n@@ -152,5 +148,0 @@\n-\/\/\n-\/\/ If containerized process, get dirname of\n-\/\/ \/proc\/{vmid}\/root\/tmp\/{PERFDATA_NAME_user}\n-\/\/ otherwise \/tmp\/{PERFDATA_NAME_user}\n-\/\/\n@@ -161,1 +152,0 @@\n-  char buffer[TMP_BUFFER_LEN];\n@@ -163,0 +153,5 @@\n+#if defined(LINUX)\n+  \/\/ On linux, if containerized process, get dirname of\n+  \/\/ \/proc\/{vmid}\/root\/tmp\/{PERFDATA_NAME_user}\n+  \/\/ otherwise \/tmp\/{PERFDATA_NAME_user}\n+  char buffer[TMP_BUFFER_LEN];\n@@ -169,1 +164,1 @@\n-\n+#endif\n@@ -322,0 +317,1 @@\n+    \/\/ Directory doesn't exist or is a symlink, so there is nothing to cleanup.\n@@ -349,1 +345,1 @@\n-  if (!is_same_fsobject(fd, dirfd(dirp))) {\n+  if (!is_same_fsobject(fd, AIX_ONLY(dirp->dd_fd) NOT_AIX(dirfd(dirp)))) {\n@@ -381,1 +377,1 @@\n-  int fd = dirfd(dirp);\n+  int fd = AIX_ONLY(dirp->dd_fd) NOT_AIX(dirfd(dirp));\n@@ -460,1 +456,1 @@\n-  \/\/ determine the max pwbuf size from sysconf, and hardcode\n+  \/\/ Determine the max pwbuf size from sysconf, and hardcode\n@@ -462,1 +458,0 @@\n-  \/\/\n@@ -469,1 +464,0 @@\n-  \/\/ POSIX interface to getpwuid_r is used on LINUX\n@@ -518,2 +512,0 @@\n-\/\/ If nspid != -1, look in \/proc\/{vmid}\/root\/tmp for directories\n-\/\/ containing nspid, otherwise just look for vmid in \/tmp\n@@ -537,1 +529,0 @@\n-  char buffer[MAXPATHLEN + 1];\n@@ -540,0 +531,1 @@\n+#if defined(LINUX)\n@@ -542,0 +534,2 @@\n+  \/\/ On Linux, if nspid != -1, look in \/proc\/{vmid}\/root\/tmp for directories\n+  \/\/ containing nspid, otherwise just look for vmid in \/tmp.\n@@ -545,0 +539,1 @@\n+    char buffer[MAXPATHLEN + 1];\n@@ -549,0 +544,3 @@\n+#else\n+  searchpid = vmid;\n+#endif\n@@ -559,1 +557,1 @@\n-  \/\/ open the directory and check if the file for the given vmid or nspid exists.\n+  \/\/ open the directory and check if the file for the given vmid (or nspid) exists.\n@@ -573,1 +571,2 @@\n-                     strlen(tmpdirname) + strlen(dentry->d_name) + 2, mtInternal);\n+                                         strlen(tmpdirname) + strlen(dentry->d_name) + 2,\n+                                         mtInternal);\n@@ -607,1 +606,2 @@\n-                   strlen(usrdir_name) + strlen(udentry->d_name) + 2, mtInternal);\n+                                          strlen(usrdir_name) + strlen(udentry->d_name) + 2,\n+                                          mtInternal);\n@@ -651,32 +651,0 @@\n-\/\/ Determine if the vmid is the parent pid\n-\/\/ for a child in a PID namespace.\n-\/\/ return the namespace pid if so, otherwise -1\n-static int get_namespace_pid(int vmid) {\n-  char fname[24];\n-  int retpid = -1;\n-\n-  snprintf(fname, sizeof(fname), \"\/proc\/%d\/status\", vmid);\n-  FILE *fp = fopen(fname, \"r\");\n-\n-  if (fp) {\n-    int pid, nspid;\n-    int ret;\n-    while (!feof(fp) && !ferror(fp)) {\n-      ret = fscanf(fp, \"NSpid: %d %d\", &pid, &nspid);\n-      if (ret == 1) {\n-        break;\n-      }\n-      if (ret == 2) {\n-        retpid = nspid;\n-        break;\n-      }\n-      for (;;) {\n-        int ch = fgetc(fp);\n-        if (ch == EOF || ch == (int)'\\n') break;\n-      }\n-    }\n-    fclose(fp);\n-  }\n-  return retpid;\n-}\n-\n@@ -688,0 +656,1 @@\n+#if defined(LINUX)\n@@ -695,0 +664,1 @@\n+#endif\n@@ -705,1 +675,1 @@\n-  int pid = (nspid == -1) ? vmid : nspid;\n+  int pid = LINUX_ONLY((nspid == -1) ? vmid : nspid) NOT_LINUX(vmid);\n@@ -752,1 +722,1 @@\n-  \/\/ open the directory\n+  \/\/ open the directory and set the current working directory to it\n@@ -922,1 +892,0 @@\n-\n@@ -982,2 +951,1 @@\n-\/\/ On Linux, the name space for shared memory objects\n-\/\/ is the file system name space.\n+\/\/ The name space for shared memory objects is the file system name space.\n@@ -1060,0 +1028,7 @@\n+#if defined(_AIX)\n+  \/\/ Do not rely on os::reserve_memory\/os::release_memory to use mmap.\n+  \/\/ Use os::reserve_memory\/os::release_memory for PerfDisableSharedMem=1, mmap\/munmap for PerfDisableSharedMem=0\n+  if (::munmap(addr, bytes) == -1) {\n+    warning(\"perfmemory: munmap failed (%d)\\n\", errno);\n+  }\n+#else\n@@ -1061,0 +1036,1 @@\n+#endif\n@@ -1152,2 +1128,2 @@\n-  \/\/ determine if vmid is for a containerized process\n-  int nspid = get_namespace_pid(vmid);\n+  \/\/ for linux, determine if vmid is for a containerized process\n+  int nspid = LINUX_ONLY(os::Linux::get_namespace_pid(vmid)) NOT_LINUX(-1);\n","filename":"src\/hotspot\/os\/posix\/perfMemory_posix.cpp","additions":43,"deletions":67,"binary":false,"changes":110,"previous_filename":"src\/hotspot\/os\/linux\/perfMemory_linux.cpp","status":"renamed"}]}