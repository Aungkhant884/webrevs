{"files":[{"patch":"@@ -180,0 +180,3 @@\n+\n+  \/\/ Maximum size of the entries of any G1CardSetContainer in bits.\n+  static uint max_card_bits_storable();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSetContainers.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -30,0 +30,6 @@\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+inline uint G1CardSetContainer::max_card_bits_storable() {\n+  \/\/ The only limitation there is is from the G1CardSetArray.\n+  return sizeof(G1CardSetArray::EntryDataType) * BitsPerByte;\n+}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSetContainers.inline.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1675,0 +1675,2 @@\n+  HeapRegionRemSet::initialize(_reserved.start());\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -45,0 +45,4 @@\n+uint HeapRegionRemSet::_split_card_shift = 0;\n+uintptr_t HeapRegionRemSet::_split_card_mask = 0;\n+HeapWord* HeapRegionRemSet::_heap_base_address = nullptr;\n+\n@@ -48,0 +52,10 @@\n+void HeapRegionRemSet::initialize(HeapWord* heap_base_address) {\n+  _split_card_shift = MIN2((uint)HeapRegion::LogCardsPerRegion, per_card_region_card_limit()) + CardTable::card_shift;\n+  _split_card_mask = ((uintptr_t)1 << _split_card_shift) - 1;\n+  _heap_base_address = heap_base_address;\n+}\n+\n+uint HeapRegionRemSet::per_card_region_card_limit() {\n+  return G1CardSetContainer::max_card_bits_storable();\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegionRemSet.cpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -53,0 +53,11 @@\n+  \/\/ When splitting addresses into region and card within that region, the logical\n+  \/\/ shift value to get the region.\n+  static uint _split_card_shift;\n+  \/\/ When splitting addresses into region and card within that region, the mask\n+  \/\/ to get the offset within the region.\n+  static uintptr_t _split_card_mask;\n+  \/\/ Cached value of heap base address.\n+  static HeapWord* _heap_base_address;\n+\n+  \/\/ Split the given address into region of that card and the card within that\n+  \/\/ region.\n@@ -56,0 +67,3 @@\n+  \/\/ Maximum number of cards in a (card) region storable in the remembered set in bits.\n+  static uint per_card_region_card_limit();\n+\n@@ -81,0 +95,2 @@\n+  static void initialize(HeapWord* heap_base_address);\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegionRemSet.hpp","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -65,3 +65,4 @@\n-  HeapRegion* hr = G1CollectedHeap::heap()->heap_region_containing(from);\n-  card_region = hr->hrm_index();\n-  card_within_region = (uint)(pointer_delta((HeapWord*)from, hr->bottom()) >> (CardTable::card_shift - LogHeapWordSize));\n+  uintptr_t offset = pointer_delta(from, _heap_base_address, 1);\n+  card_region = offset >> _split_card_shift;\n+  card_within_region = (offset & _split_card_mask) >> CardTable::card_shift;\n+  assert(card_within_region < ((uint)1 << per_card_region_card_limit()), \"must be\");\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegionRemSet.inline.hpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"}]}