{"files":[{"patch":"@@ -0,0 +1,31 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+\n+#include \"gc\/g1\/g1CardSetContainers.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+\/\/ The only limitation is from the G1CardSetArray.\n+uint G1CardSetContainer::LogCardsPerRegionLimit = sizeof(G1CardSetArray::EntryDataType) * BitsPerByte;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSetContainers.cpp","additions":31,"deletions":0,"binary":false,"changes":31,"status":"added"},{"patch":"@@ -180,0 +180,3 @@\n+\n+  \/\/ Log of largest card index that can be stored in any G1CardSetContainer\n+  static uint LogCardsPerRegionLimit;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSetContainers.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"utilities\/globalDefinitions.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSetContainers.inline.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1675,0 +1675,2 @@\n+  HeapRegionRemSet::initialize(_reserved);\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+#include \"runtime\/java.hpp\"\n@@ -45,0 +46,4 @@\n+uint HeapRegionRemSet::_split_card_shift = 0;\n+size_t HeapRegionRemSet::_split_card_mask = 0;\n+HeapWord* HeapRegionRemSet::_heap_base_address = nullptr;\n+\n@@ -48,0 +53,26 @@\n+void HeapRegionRemSet::initialize(MemRegion reserved) {\n+  const uint BitsInUint = sizeof(uint) * BitsPerByte;\n+  const uint CardBitsWithinCardRegion = MIN2((uint)HeapRegion::LogCardsPerRegion, G1CardSetContainer::LogCardsPerRegionLimit);\n+\n+  \/\/ Check if the number of cards within a region fits an uint.\n+  if (CardBitsWithinCardRegion > BitsInUint) {\n+    vm_exit_during_initialization(\"Can not represent all cards in a card region within uint.\");\n+  }\n+\n+  _split_card_shift = CardBitsWithinCardRegion + CardTable::card_shift;\n+  _split_card_mask = ((size_t)1 << _split_card_shift) - 1;\n+\n+  \/\/ Check if the card region\/region within cards combination can cover the heap.\n+  const uint HeapSizeBits = log2i_exact(round_up_power_of_2(reserved.byte_size()));\n+  if (HeapSizeBits > (BitsInUint + _split_card_shift)) {\n+    FormatBuffer<> fmt(\"Can not represent all cards in the heap with card region\/card within region. \"\n+                       \"Heap %zuB (%u bits) Remembered set covers %u bits.\",\n+                       reserved.byte_size(),\n+                       HeapSizeBits,\n+                       BitsInUint + _split_card_shift);\n+    vm_exit_during_initialization(fmt, \"Decrease heap size.\");\n+  }\n+\n+  _heap_base_address = reserved.start();\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegionRemSet.cpp","additions":31,"deletions":0,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -53,0 +53,11 @@\n+  \/\/ When splitting addresses into region and card within that region, the logical\n+  \/\/ shift value to get the region.\n+  static uint _split_card_shift;\n+  \/\/ When splitting addresses into region and card within that region, the mask\n+  \/\/ to get the offset within the region.\n+  static size_t _split_card_mask;\n+  \/\/ Cached value of heap base address.\n+  static HeapWord* _heap_base_address;\n+\n+  \/\/ Split the given address into region of that card and the card within that\n+  \/\/ region.\n@@ -81,0 +92,2 @@\n+  static void initialize(MemRegion reserved);\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegionRemSet.hpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -65,3 +65,4 @@\n-  HeapRegion* hr = G1CollectedHeap::heap()->heap_region_containing(from);\n-  card_region = hr->hrm_index();\n-  card_within_region = (uint)(pointer_delta((HeapWord*)from, hr->bottom()) >> (CardTable::card_shift - LogHeapWordSize));\n+  size_t offset = pointer_delta(from, _heap_base_address, 1);\n+  card_region = (uint)(offset >> _split_card_shift);\n+  card_within_region = (uint)((offset & _split_card_mask) >> CardTable::card_shift);\n+  assert(card_within_region < ((uint)1 << G1CardSetContainer::LogCardsPerRegionLimit), \"must be\");\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegionRemSet.inline.hpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"}]}