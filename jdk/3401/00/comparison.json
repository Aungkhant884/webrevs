{"files":[{"patch":"@@ -867,0 +867,6 @@\n+                case TABLE_SWITCH:\n+                    assert lambdaForm.isTableSwitch(i);\n+                    int numCases = (Integer) name.function.intrinsicData();\n+                    onStack = emitTableSwitch(i, numCases);\n+                    i += 2; \/\/ jump to the end of the TS idiom\n+                    continue;\n@@ -1396,0 +1402,52 @@\n+    private Name emitTableSwitch(int pos, int numCases) {\n+        Name args    = lambdaForm.names[pos];\n+        Name invoker = lambdaForm.names[pos+1];\n+        Name result  = lambdaForm.names[pos+2];\n+\n+        Class<?> returnType = result.function.resolvedHandle().type().returnType();\n+        MethodType caseType = args.function.resolvedHandle().type()\n+            .dropParameterTypes(0,1) \/\/ drop collector\n+            .changeReturnType(returnType);\n+        String caseDescriptor = caseType.basicType().toMethodDescriptorString();\n+\n+        emitPushArgument(invoker, 2); \/\/ push cases\n+        mv.visitFieldInsn(Opcodes.GETFIELD, \"java\/lang\/invoke\/MethodHandleImpl$CasesHolder\", \"cases\",\n+            \"[Ljava\/lang\/invoke\/MethodHandle;\");\n+        int casesLocal = extendLocalsMap(new Class<?>[] { MethodHandle[].class });\n+        emitStoreInsn(L_TYPE, casesLocal);\n+\n+        Label endLabel = new Label();\n+        Label defaultLabel = new Label();\n+        Label[] caseLabels = new Label[numCases];\n+        for (int i = 0; i < caseLabels.length; i++) {\n+            caseLabels[i] = new Label();\n+        }\n+\n+        emitPushArgument(invoker, 0); \/\/ push switch input\n+        mv.visitTableSwitchInsn(0, numCases - 1, defaultLabel, caseLabels);\n+\n+        mv.visitLabel(defaultLabel);\n+        emitPushArgument(invoker, 1); \/\/ push default handle\n+        emitPushArguments(args, 1); \/\/ again, skip collector\n+        mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, MH, \"invokeBasic\", caseDescriptor, false);\n+        mv.visitJumpInsn(Opcodes.GOTO, endLabel);\n+\n+        for (int i = 0; i < numCases; i++) {\n+            mv.visitLabel(caseLabels[i]);\n+            \/\/ Load the particular case:\n+            emitLoadInsn(L_TYPE, casesLocal);\n+            emitIconstInsn(i);\n+            mv.visitInsn(Opcodes.AALOAD);\n+\n+            \/\/ invoke it:\n+            emitPushArguments(args, 1); \/\/ again, skip collector\n+            mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, MH, \"invokeBasic\", caseDescriptor, false);\n+\n+            mv.visitJumpInsn(Opcodes.GOTO, endLabel);\n+        }\n+\n+        mv.visitLabel(endLabel);\n+\n+        return result;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InvokerBytecodeGenerator.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -317,0 +317,1 @@\n+        TABLE_SWITCH(\"tableSwitch\"),\n@@ -710,0 +711,26 @@\n+    \/**\n+     * Check if i-th name is a start of the tableSwitch idiom.\n+     *\/\n+    boolean isTableSwitch(int pos) {\n+        \/\/ tableSwitch idiom:\n+        \/\/   t_{n}:L=MethodHandle.invokeBasic(...)     \/\/ args\n+        \/\/   t_{n+1}:L=MethodHandleImpl.tableSwitch(*, *, *, t_{n})\n+        \/\/   t_{n+2}:?=MethodHandle.invokeBasic(*, t_{n+1})\n+        if (pos + 2 >= names.length)  return false;\n+\n+        final int POS_COLLECT_ARGS  = pos;\n+        final int POS_TABLE_SWITCH  = pos + 1;\n+        final int POS_UNBOX_RESULT  = pos + 2;\n+\n+        Name collectArgs  = names[POS_COLLECT_ARGS];\n+        Name tableSwitch  = names[POS_TABLE_SWITCH];\n+        Name unboxResult  = names[POS_UNBOX_RESULT];\n+        return tableSwitch.refersTo(MethodHandleImpl.class, \"tableSwitch\") &&\n+                collectArgs.isInvokeBasic() &&\n+                unboxResult.isInvokeBasic() &&\n+                tableSwitch.lastUseIndex(collectArgs)  == 3 &&    \/\/ t_{n+1}:L=MethodHandleImpl.<invoker>(*, *, *, t_{n});\n+                lastUseIndex(collectArgs)  == POS_TABLE_SWITCH && \/\/ t_{n} is local: used only in t_{n+1}\n+                unboxResult.lastUseIndex(tableSwitch) == 1 &&     \/\/ t_{n+2}:?=MethodHandle.invokeBasic(*, t_{n+1})\n+                lastUseIndex(tableSwitch) == POS_UNBOX_RESULT;    \/\/ t_{n+1} is local: used only in t_{n+2}\n+    }\n+\n@@ -1071,0 +1098,1 @@\n+        private final Object intrinsicData;\n@@ -1073,1 +1101,1 @@\n-            this(resolvedHandle.internalMemberName(), resolvedHandle, MethodHandleImpl.Intrinsic.NONE);\n+            this(resolvedHandle.internalMemberName(), resolvedHandle, MethodHandleImpl.Intrinsic.NONE, null);\n@@ -1076,1 +1104,4 @@\n-            this(resolvedHandle.internalMemberName(), resolvedHandle, intrinsic);\n+            this(resolvedHandle.internalMemberName(), resolvedHandle, intrinsic, null);\n+        }\n+        NamedFunction(MethodHandle resolvedHandle, MethodHandleImpl.Intrinsic intrinsic, Object intrinsicData) {\n+            this(resolvedHandle.internalMemberName(), resolvedHandle, intrinsic, intrinsicData);\n@@ -1079,1 +1110,1 @@\n-            this(member, resolvedHandle, MethodHandleImpl.Intrinsic.NONE);\n+            this(member, resolvedHandle, MethodHandleImpl.Intrinsic.NONE, null);\n@@ -1082,0 +1113,3 @@\n+            this(member, resolvedHandle, intrinsic, null);\n+        }\n+        NamedFunction(MemberName member, MethodHandle resolvedHandle, MethodHandleImpl.Intrinsic intrinsic, Object intrinsicData) {\n@@ -1085,0 +1119,1 @@\n+            this.intrinsicData = intrinsicData;\n@@ -1101,0 +1136,1 @@\n+            this.intrinsicData = null;\n@@ -1255,0 +1291,4 @@\n+\n+        public Object intrinsicData() {\n+            return intrinsicData;\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/LambdaForm.java","additions":43,"deletions":3,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -52,0 +52,2 @@\n+import java.util.Objects;\n+import java.util.concurrent.ConcurrentHashMap;\n@@ -1229,0 +1231,1 @@\n+        TABLE_SWITCH,\n@@ -1363,1 +1366,2 @@\n-            NF_LIMIT = 6;\n+            NF_tableSwitch = 6,\n+            NF_LIMIT = 7;\n@@ -1397,0 +1401,3 @@\n+                case NF_tableSwitch:\n+                    return new NamedFunction(MethodHandleImpl.class\n+                            .getDeclaredMethod(\"tableSwitch\", int.class, MethodHandle.class, CasesHolder.class, Object[].class));\n@@ -1955,0 +1962,136 @@\n+    \/\/ use a wrapper because we need this array to be @Stable\n+    static class CasesHolder {\n+        @Stable\n+        final MethodHandle[] cases;\n+\n+        public CasesHolder(MethodHandle[] cases) {\n+            this.cases = cases;\n+        }\n+    }\n+\n+    static MethodHandle makeTableSwitch(MethodType type, MethodHandle defaultCase, MethodHandle[] caseActions) {\n+        MethodType varargsType = type.changeReturnType(Object[].class);\n+        MethodHandle collectArgs = varargsArray(type.parameterCount()).asType(varargsType);\n+\n+        MethodHandle unboxResult = unboxResultHandle(type.returnType());\n+\n+        BoundMethodHandle.SpeciesData data = BoundMethodHandle.speciesData_LLLL();\n+        LambdaForm form = makeTableSwitchForm(type.basicType(), data, caseActions.length);\n+        BoundMethodHandle mh;\n+        CasesHolder caseHolder =  new CasesHolder(caseActions);\n+        try {\n+            mh = (BoundMethodHandle) data.factory().invokeBasic(type, form, (Object) defaultCase, (Object) collectArgs,\n+                                                                (Object) unboxResult, (Object) caseHolder);\n+        } catch (Throwable ex) {\n+            throw uncaughtException(ex);\n+        }\n+        assert(mh.type() == type);\n+        return mh;\n+    }\n+\n+    private static class TableSwitchCacheKey {\n+        private final MethodType basicType;\n+        private final int numberOfCases;\n+\n+        public TableSwitchCacheKey(MethodType basicType, int numberOfCases) {\n+            this.basicType = basicType;\n+            this.numberOfCases = numberOfCases;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+            TableSwitchCacheKey that = (TableSwitchCacheKey) o;\n+            return numberOfCases == that.numberOfCases && Objects.equals(basicType, that.basicType);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(basicType, numberOfCases);\n+        }\n+    }\n+\n+    private static final Map<TableSwitchCacheKey, LambdaForm> TABLE_SWITCH_LAMBDA_FORM_CACHE = new ConcurrentHashMap<>();\n+\n+    private static LambdaForm makeTableSwitchForm(MethodType basicType, BoundMethodHandle.SpeciesData data,\n+                                                  int numCases) {\n+        MethodType lambdaType = basicType.invokerType();\n+\n+        \/\/ We need to cache based on the basic type X number of cases,\n+        \/\/ since the number of cases is used when generating bytecode.\n+        \/\/ This also means that we can't use the cache in MethodTypeForm,\n+        \/\/ which only uses the basic type as a key.\n+        TableSwitchCacheKey key = new TableSwitchCacheKey(basicType, numCases);\n+        LambdaForm lform = TABLE_SWITCH_LAMBDA_FORM_CACHE.get(key);\n+        if (lform != null) {\n+            return lform;\n+        }\n+\n+        final int THIS_MH       = 0;\n+        final int ARG_BASE      = 1;  \/\/ start of incoming arguments\n+        final int ARG_LIMIT     = ARG_BASE + basicType.parameterCount();\n+        final int ARG_SWITCH_ON = ARG_BASE;\n+        assert ARG_SWITCH_ON < ARG_LIMIT;\n+\n+        int nameCursor = ARG_LIMIT;\n+        final int GET_COLLECT_ARGS  = nameCursor++;\n+        final int GET_DEFAULT_CASE  = nameCursor++;\n+        final int GET_UNBOX_RESULT  = nameCursor++;\n+        final int GET_CASES         = nameCursor++;\n+        final int BOXED_ARGS        = nameCursor++;\n+        final int TABLE_SWITCH      = nameCursor++;\n+        final int UNBOXED_RESULT    = nameCursor++;\n+\n+        int fieldCursor = 0;\n+        final int FIELD_DEFAULT_CASE  = fieldCursor++;\n+        final int FIELD_COLLECT_ARGS  = fieldCursor++;\n+        final int FIELD_UNBOX_RESULT  = fieldCursor++;\n+        final int FIELD_CASES         = fieldCursor++;\n+\n+        Name[] names = arguments(nameCursor - ARG_LIMIT, lambdaType);\n+\n+        names[THIS_MH] = names[THIS_MH].withConstraint(data);\n+        names[GET_DEFAULT_CASE] = new Name(data.getterFunction(FIELD_DEFAULT_CASE), names[THIS_MH]);\n+        names[GET_COLLECT_ARGS]  = new Name(data.getterFunction(FIELD_COLLECT_ARGS), names[THIS_MH]);\n+        names[GET_UNBOX_RESULT]  = new Name(data.getterFunction(FIELD_UNBOX_RESULT), names[THIS_MH]);\n+        names[GET_CASES] = new Name(data.getterFunction(FIELD_CASES), names[THIS_MH]);\n+\n+        {\n+            MethodType collectArgsType = basicType.changeReturnType(Object.class);\n+            MethodHandle invokeBasic = MethodHandles.basicInvoker(collectArgsType);\n+            Object[] args = new Object[invokeBasic.type().parameterCount()];\n+            args[0] = names[GET_COLLECT_ARGS];\n+            System.arraycopy(names, ARG_BASE, args, 1, ARG_LIMIT - ARG_BASE);\n+            names[BOXED_ARGS] = new Name(new NamedFunction(invokeBasic, Intrinsic.TABLE_SWITCH, numCases), args);\n+        }\n+\n+        {\n+            Object[] tfArgs = new Object[]{\n+                names[ARG_SWITCH_ON], names[GET_DEFAULT_CASE], names[GET_CASES], names[BOXED_ARGS]};\n+            names[TABLE_SWITCH] = new Name(getFunction(NF_tableSwitch), tfArgs);\n+        }\n+\n+        {\n+            MethodHandle invokeBasic = MethodHandles.basicInvoker(MethodType.methodType(basicType.rtype(), Object.class));\n+            Object[] unboxArgs = new Object[]{names[GET_UNBOX_RESULT], names[TABLE_SWITCH]};\n+            names[UNBOXED_RESULT] = new Name(invokeBasic, unboxArgs);\n+        }\n+\n+        lform = new LambdaForm(lambdaType.parameterCount(), names, Kind.TABLE_SWITCH);\n+        LambdaForm prev = TABLE_SWITCH_LAMBDA_FORM_CACHE.putIfAbsent(key, lform);\n+        return prev != null ? prev : lform;\n+    }\n+\n+    @Hidden\n+    static Object tableSwitch(int input, MethodHandle defaultCase, CasesHolder holder, Object[] args) throws Throwable {\n+        MethodHandle[] caseActions = holder.cases;\n+        MethodHandle selectedCase;\n+        if (input < 0 || input >= caseActions.length) {\n+            selectedCase = defaultCase;\n+        } else {\n+            selectedCase = caseActions[input];\n+        }\n+        return selectedCase.invokeWithArguments(args);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleImpl.java","additions":144,"deletions":1,"binary":false,"changes":145,"status":"modified"},{"patch":"@@ -7753,0 +7753,60 @@\n+    \/**\n+     * Creates a table switch method handle, which can be used to switch over a set of target\n+     * method handles, based on a given target index, called selector.\n+     * <p>\n+     * For a selector value of {@code n}, where {@code n} falls in the range {@code [0, N)},\n+     * and where {@code N} is the number of target method handles, the table switch method\n+     * handle will invoke the n-th target method handle from the list of target method handles.\n+     * <p>\n+     * For a selector value that does not fall in the range {@code [0, N)}, the table switch\n+     * method handle will invoke the given fallback method handle.\n+     * <p>\n+     * All method handles passed to this method must have the same type, with the additional\n+     * requirement that the leading parameter be of type {@code int}. The leading parameter\n+     * represents the selector.\n+     * <p>\n+     * Any trailing parameters present in the type will appear on the returned table switch\n+     * method handle as well. Any arguments assigned to these parameters will be forwarded,\n+     * together with the selector value, to the selected method handle when invoking it.\n+     *\n+     * @param fallback the fallback method handle that is called when the selector is not\n+     *                 within the range {@code [0, N)}.\n+     * @param targets array of target method handles.\n+     * @return the table switch method handle.\n+     * @throws NullPointerException if {@code fallback}, the {@code targets} array, or any\n+     *                              any of the elements of the {@code targets} array are\n+     *                              {@code null}.\n+     * @throws IllegalArgumentException if the {@code targets} array is empty, if the leading\n+     *                                  parameter of the fallback handle or any of the target\n+     *                                  handles is not {@code int}, or if the types of\n+     *                                  the fallback handle and all of target handles are\n+     *                                  not the same.\n+     *\/\n+    public static MethodHandle tableSwitch(MethodHandle fallback, MethodHandle... targets) {\n+        Objects.requireNonNull(fallback);\n+        Objects.requireNonNull(targets);\n+        targets = targets.clone();\n+        MethodType type = tableSwitchChecks(fallback, targets);\n+        return MethodHandleImpl.makeTableSwitch(type, fallback, targets);\n+    }\n+\n+    private static MethodType tableSwitchChecks(MethodHandle defaultCase, MethodHandle[] caseActions) {\n+        if (caseActions.length == 0)\n+            throw new IllegalArgumentException(\"Not enough cases: \" + Arrays.toString(caseActions));\n+\n+        MethodType expectedType = defaultCase.type();\n+\n+        if (!(expectedType.parameterCount() >= 1) || expectedType.parameterType(0) != int.class)\n+            throw new IllegalArgumentException(\n+                \"Case actions must have int as leading parameter: \" + Arrays.toString(caseActions));\n+\n+        for (MethodHandle mh : caseActions) {\n+            Objects.requireNonNull(mh);\n+            if (mh.type() != expectedType)\n+                throw new IllegalArgumentException(\n+                    \"Case actions must have the same type: \" + Arrays.toString(caseActions));\n+        }\n+\n+        return expectedType;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandles.java","additions":60,"deletions":0,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -0,0 +1,234 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @run testng\/othervm -Xverify:all TestTableSwitch\n+ *\/\n+\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import javax.management.ObjectName;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.IntConsumer;\n+import java.util.function.IntFunction;\n+\n+import static org.testng.Assert.assertEquals;\n+\n+public class TestTableSwitch {\n+\n+    static final MethodHandle MH_IntConsumer_accept;\n+    static final MethodHandle MH_check;\n+\n+    static {\n+        try {\n+            MethodHandles.Lookup lookup = MethodHandles.lookup();\n+            MH_IntConsumer_accept = lookup.findVirtual(IntConsumer.class, \"accept\",\n+                    MethodType.methodType(void.class, int.class));\n+            MH_check = lookup.findStatic(TestTableSwitch.class, \"check\",\n+                    MethodType.methodType(void.class, List.class, Object[].class));\n+        } catch (ReflectiveOperationException e) {\n+            throw new ExceptionInInitializerError(e);\n+        }\n+    }\n+\n+    public static MethodHandle simpleTestCase(String value) {\n+        return simpleTestCase(String.class, value);\n+    }\n+\n+    public static MethodHandle simpleTestCase(Class<?> type, Object value) {\n+        return MethodHandles.dropArguments(MethodHandles.constant(type, value), 0, int.class);\n+    }\n+\n+    public static Object testValue(Class<?> type) {\n+        if (type == String.class) {\n+            return \"X\";\n+        } else if (type == byte.class) {\n+            return (byte) 42;\n+        } else if (type == short.class) {\n+            return (short) 84;\n+        } else if (type == char.class) {\n+            return 'Y';\n+        } else if (type == int.class) {\n+            return 168;\n+        } else if (type == long.class) {\n+            return 336L;\n+        } else if (type == float.class) {\n+            return 42F;\n+        } else if (type == double.class) {\n+            return 84D;\n+        } else if (type == boolean.class) {\n+            return true;\n+        }\n+        return null;\n+    }\n+\n+    static final Class<?>[] TEST_TYPES = {\n+        Object.class,\n+        String.class,\n+        byte.class,\n+        short.class,\n+        char.class,\n+        int.class,\n+        long.class,\n+        float.class,\n+        double.class,\n+        boolean.class\n+    };\n+\n+    public static Object[] testArguments(int caseNum, List<Object> testValues) {\n+        Object[] args = new Object[testValues.size() + 1];\n+        args[0] = caseNum;\n+        int insertPos = 1;\n+        for (Object testValue : testValues) {\n+            args[insertPos++] = testValue;\n+        }\n+        return args;\n+    }\n+\n+    @DataProvider\n+    public static Object[][] nonVoidCases() {\n+        List<Object[]> tests = new ArrayList<>();\n+\n+        for (Class<?> returnType : TEST_TYPES) {\n+            for (int numCases = 1; numCases < 5; numCases++) {\n+                tests.add(new Object[] { returnType, numCases, List.of() });\n+                tests.add(new Object[] { returnType, numCases, List.of(TEST_TYPES) });\n+            }\n+        }\n+\n+        return tests.toArray(Object[][]::new);\n+    }\n+\n+    private static void check(List<Object> testValues, Object[] collectedValues) {\n+        assertEquals(collectedValues, testValues.toArray());\n+    }\n+\n+    @Test(dataProvider = \"nonVoidCases\")\n+    public void testNonVoidHandles(Class<?> type, int numCases, List<Class<?>> additionalTypes) throws Throwable {\n+        MethodHandle collector = MH_check;\n+        List<Object> testArguments = new ArrayList<>();\n+        collector = MethodHandles.insertArguments(collector, 0, testArguments);\n+        collector = collector.asCollector(Object[].class, additionalTypes.size());\n+\n+        Object defaultReturnValue = testValue(type);\n+        MethodHandle defaultCase = simpleTestCase(type, defaultReturnValue);\n+        defaultCase = MethodHandles.collectArguments(defaultCase, 1, collector);\n+        Object[] returnValues = new Object[numCases];\n+        MethodHandle[] cases = new MethodHandle[numCases];\n+        for (int i = 0; i < cases.length; i++) {\n+            Object returnValue = testValue(type);\n+            returnValues[i] = returnValue;\n+            MethodHandle theCase = simpleTestCase(type, returnValue);\n+            theCase = MethodHandles.collectArguments(theCase, 1, collector);\n+            cases[i] = theCase;\n+        }\n+\n+        MethodHandle mhSwitch = MethodHandles.tableSwitch(\n+            defaultCase,\n+            cases\n+        );\n+\n+        for (Class<?> additionalType : additionalTypes) {\n+            testArguments.add(testValue(additionalType));\n+        }\n+\n+        assertEquals(mhSwitch.invokeWithArguments(testArguments(-1, testArguments)), defaultReturnValue);\n+\n+        for (int i = 0; i < numCases; i++) {\n+            assertEquals(mhSwitch.invokeWithArguments(testArguments(i, testArguments)), returnValues[i]);\n+        }\n+\n+        assertEquals(mhSwitch.invokeWithArguments(testArguments(numCases, testArguments)), defaultReturnValue);\n+    }\n+\n+    @Test\n+    public void testVoidHandles() throws Throwable {\n+        IntFunction<MethodHandle> makeTestCase = expectedIndex -> {\n+            IntConsumer test = actualIndex -> assertEquals(actualIndex, expectedIndex);\n+            return MH_IntConsumer_accept.bindTo(test);\n+        };\n+\n+        MethodHandle mhSwitch = MethodHandles.tableSwitch(\n+            \/* default: *\/ makeTestCase.apply(-1),\n+            \/* case 0: *\/  makeTestCase.apply(0),\n+            \/* case 1: *\/  makeTestCase.apply(1),\n+            \/* case 2: *\/  makeTestCase.apply(2)\n+        );\n+\n+        mhSwitch.invokeExact((int) -1);\n+        mhSwitch.invokeExact((int) 0);\n+        mhSwitch.invokeExact((int) 1);\n+        mhSwitch.invokeExact((int) 2);\n+    }\n+\n+    @Test(expectedExceptions = NullPointerException.class)\n+    public void testNullDefaultHandle() {\n+        MethodHandles.tableSwitch(null, simpleTestCase(\"test\"));\n+    }\n+\n+    @Test(expectedExceptions = NullPointerException.class)\n+    public void testNullCases() {\n+        MethodHandle[] cases = null;\n+        MethodHandles.tableSwitch(simpleTestCase(\"default\"), cases);\n+    }\n+\n+    @Test(expectedExceptions = NullPointerException.class)\n+    public void testNullCase() {\n+        MethodHandles.tableSwitch(simpleTestCase(\"default\"), simpleTestCase(\"case\"), null);\n+    }\n+\n+    @Test(expectedExceptions = IllegalArgumentException.class,\n+          expectedExceptionsMessageRegExp = \".*Not enough cases.*\")\n+    public void testNotEnoughCases() {\n+        MethodHandles.tableSwitch(simpleTestCase(\"default\"));\n+    }\n+\n+    @Test(expectedExceptions = IllegalArgumentException.class,\n+          expectedExceptionsMessageRegExp = \".*Case actions must have int as leading parameter.*\")\n+    public void testNotEnoughParameters() {\n+        MethodHandle empty = MethodHandles.empty(MethodType.methodType(void.class));\n+        MethodHandles.tableSwitch(empty, empty, empty);\n+    }\n+\n+    @Test(expectedExceptions = IllegalArgumentException.class,\n+          expectedExceptionsMessageRegExp = \".*Case actions must have int as leading parameter.*\")\n+    public void testNoLeadingIntParameter() {\n+        MethodHandle empty = MethodHandles.empty(MethodType.methodType(void.class, double.class));\n+        MethodHandles.tableSwitch(empty, empty, empty);\n+    }\n+\n+    @Test(expectedExceptions = IllegalArgumentException.class,\n+          expectedExceptionsMessageRegExp = \".*Case actions must have the same type.*\")\n+    public void testWrongCaseType() {\n+        \/\/ doesn't return a String\n+        MethodHandle wrongType = MethodHandles.empty(MethodType.methodType(void.class, int.class));\n+        MethodHandles.tableSwitch(simpleTestCase(\"default\"), simpleTestCase(\"case\"), wrongType);\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/lang\/invoke\/MethodHandles\/TestTableSwitch.java","additions":234,"deletions":0,"binary":false,"changes":234,"status":"added"},{"patch":"@@ -0,0 +1,137 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang.invoke;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Level;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.invoke.MutableCallSite;\n+import java.util.Random;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.IntStream;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(org.openjdk.jmh.annotations.Scope.Thread)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@Fork(3)\n+public class MethodHandlesTableSwitchConstant {\n+\n+    \/\/ Switch combinator test for a single constant input index\n+\n+    private static final MethodType callType = MethodType.methodType(int.class, int.class);\n+\n+    private static final MutableCallSite cs = new MutableCallSite(callType);\n+    private static final MethodHandle target = cs.dynamicInvoker();\n+\n+    private static final MutableCallSite csInput = new MutableCallSite(MethodType.methodType(int.class));\n+    private static final MethodHandle targetInput = csInput.dynamicInvoker();\n+\n+    private static final MethodHandle MH_SUBTRACT;\n+    private static final MethodHandle MH_DEFAULT;\n+    private static final MethodHandle MH_PAYLOAD;\n+\n+    static {\n+        try {\n+            MH_SUBTRACT = MethodHandles.lookup().findStatic(MethodHandlesTableSwitchConstant.class, \"subtract\",\n+                    MethodType.methodType(int.class, int.class, int.class));\n+            MH_DEFAULT = MethodHandles.lookup().findStatic(MethodHandlesTableSwitchConstant.class, \"defaultCase\",\n+                    MethodType.methodType(int.class, int.class));\n+            MH_PAYLOAD = MethodHandles.lookup().findStatic(MethodHandlesTableSwitchConstant.class, \"payload\",\n+                    MethodType.methodType(int.class, int.class, int.class));\n+        } catch (ReflectiveOperationException e) {\n+            throw new ExceptionInInitializerError(e);\n+        }\n+    }\n+\n+    \/\/ Using batch size since we really need a per-invocation setup\n+    \/\/ but the measured code is too fast. Using JMH batch size doesn't work\n+    \/\/ since there is no way to do a batch-level setup as well.\n+    private static final int BATCH_SIZE = 1_000_000;\n+\n+    @Param({\n+        \"5\",\n+        \"10\",\n+        \"25\",\n+        \"50\",\n+        \"100\"\n+    })\n+    public int numCases;\n+\n+\n+    @Param({\n+        \"0\",\n+        \"150\"\n+    })\n+    public int offset;\n+\n+    @Setup(Level.Trial)\n+    public void setupTrial() throws Throwable {\n+        MethodHandle[] cases = IntStream.range(0, numCases)\n+                .mapToObj(i -> MethodHandles.insertArguments(MH_PAYLOAD, 1, i))\n+                .toArray(MethodHandle[]::new);\n+        MethodHandle switcher = MethodHandles.tableSwitch(MH_DEFAULT, cases);\n+        if (offset != 0) {\n+            switcher = MethodHandles.filterArguments(switcher, 0, MethodHandles.insertArguments(MH_SUBTRACT, 1, offset));\n+        }\n+        cs.setTarget(switcher);\n+\n+        int input = ThreadLocalRandom.current().nextInt(numCases) + offset;\n+        csInput.setTarget(MethodHandles.constant(int.class, input));\n+    }\n+\n+    private static int payload(int dropped, int constant) {\n+        return constant;\n+    }\n+\n+    private static int subtract(int a, int b) {\n+        return a - b;\n+    }\n+\n+    private static int defaultCase(int x) {\n+        throw new IllegalStateException();\n+    }\n+\n+    @Benchmark\n+    public void testSwitch(Blackhole bh) throws Throwable {\n+        for (int i = 0; i < BATCH_SIZE; i++) {\n+            bh.consume((int) target.invokeExact((int) targetInput.invokeExact()));\n+        }\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/invoke\/MethodHandlesTableSwitchConstant.java","additions":137,"deletions":0,"binary":false,"changes":137,"status":"added"},{"patch":"@@ -0,0 +1,134 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang.invoke;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Level;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.invoke.MutableCallSite;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.IntStream;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(org.openjdk.jmh.annotations.Scope.Thread)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@Fork(3)\n+public class MethodHandlesTableSwitchOpaqueSingle {\n+\n+    \/\/ Switch combinator test for a single input index, but opaquely fed in, so the JIT\n+    \/\/ does not see it as a constant.\n+\n+    private static final MethodType callType = MethodType.methodType(int.class, int.class);\n+\n+    private static final MutableCallSite cs = new MutableCallSite(callType);\n+    private static final MethodHandle target = cs.dynamicInvoker();\n+\n+    private static final MethodHandle MH_SUBTRACT;\n+    private static final MethodHandle MH_DEFAULT;\n+    private static final MethodHandle MH_PAYLOAD;\n+\n+    static {\n+        try {\n+            MH_SUBTRACT = MethodHandles.lookup().findStatic(MethodHandlesTableSwitchOpaqueSingle.class, \"subtract\",\n+                    MethodType.methodType(int.class, int.class, int.class));\n+            MH_DEFAULT = MethodHandles.lookup().findStatic(MethodHandlesTableSwitchOpaqueSingle.class, \"defaultCase\",\n+                    MethodType.methodType(int.class, int.class));\n+            MH_PAYLOAD = MethodHandles.lookup().findStatic(MethodHandlesTableSwitchOpaqueSingle.class, \"payload\",\n+                    MethodType.methodType(int.class, int.class, int.class));\n+        } catch (ReflectiveOperationException e) {\n+            throw new ExceptionInInitializerError(e);\n+        }\n+    }\n+\n+    \/\/ Using batch size since we really need a per-invocation setup\n+    \/\/ but the measured code is too fast. Using JMH batch size doesn't work\n+    \/\/ since there is no way to do a batch-level setup as well.\n+    private static final int BATCH_SIZE = 1_000_000;\n+\n+    @Param({\n+        \"5\",\n+        \"10\",\n+        \"25\",\n+        \"50\",\n+        \"100\"\n+    })\n+    public int numCases;\n+\n+    @Param({\n+        \"0\",\n+        \"150\"\n+    })\n+    public int offset;\n+\n+    public int input;\n+\n+    @Setup(Level.Trial)\n+    public void setupTrial() throws Throwable {\n+        MethodHandle[] cases = IntStream.range(0, numCases)\n+                .mapToObj(i -> MethodHandles.insertArguments(MH_PAYLOAD, 1, i))\n+                .toArray(MethodHandle[]::new);\n+        MethodHandle switcher = MethodHandles.tableSwitch(MH_DEFAULT, cases);\n+        if (offset != 0) {\n+            switcher = MethodHandles.filterArguments(switcher, 0, MethodHandles.insertArguments(MH_SUBTRACT, 1, offset));\n+        }\n+        cs.setTarget(switcher);\n+\n+        input = ThreadLocalRandom.current().nextInt(numCases) + offset;\n+    }\n+\n+    private static int payload(int dropped, int constant) {\n+        return constant;\n+    }\n+\n+    private static int subtract(int a, int b) {\n+        return a - b;\n+    }\n+\n+    private static int defaultCase(int x) {\n+        throw new IllegalStateException();\n+    }\n+\n+    @Benchmark\n+    public void testSwitch(Blackhole bh) throws Throwable {\n+        for (int i = 0; i < BATCH_SIZE; i++) {\n+            bh.consume((int) target.invokeExact(input));\n+        }\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/invoke\/MethodHandlesTableSwitchOpaqueSingle.java","additions":134,"deletions":0,"binary":false,"changes":134,"status":"added"},{"patch":"@@ -0,0 +1,149 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang.invoke;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Level;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.invoke.MutableCallSite;\n+import java.util.Arrays;\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.IntStream;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(org.openjdk.jmh.annotations.Scope.Thread)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@Fork(3)\n+public class MethodHandlesTableSwitchRandom {\n+\n+    \/\/ Switch combinator test for a random input index, testing several switch sizes\n+\n+    private static final MethodType callType = MethodType.methodType(int.class, int.class);\n+\n+    private static final MutableCallSite cs = new MutableCallSite(callType);\n+    private static final MethodHandle target = cs.dynamicInvoker();\n+\n+    private static final MethodHandle MH_SUBTRACT;\n+    private static final MethodHandle MH_DEFAULT;\n+    private static final MethodHandle MH_PAYLOAD;\n+\n+    static {\n+        try {\n+            MH_SUBTRACT = MethodHandles.lookup().findStatic(MethodHandlesTableSwitchRandom.class, \"subtract\",\n+                    MethodType.methodType(int.class, int.class, int.class));\n+            MH_DEFAULT = MethodHandles.lookup().findStatic(MethodHandlesTableSwitchRandom.class, \"defaultCase\",\n+                    MethodType.methodType(int.class, int.class));\n+            MH_PAYLOAD = MethodHandles.lookup().findStatic(MethodHandlesTableSwitchRandom.class, \"payload\",\n+                    MethodType.methodType(int.class, int.class, int.class));\n+        } catch (ReflectiveOperationException e) {\n+            throw new ExceptionInInitializerError(e);\n+        }\n+    }\n+\n+    \/\/ Using batch size since we really need a per-invocation setup\n+    \/\/ but the measured code is too fast. Using JMH batch size doesn't work\n+    \/\/ since there is no way to do a batch-level setup as well.\n+    private static final int BATCH_SIZE = 1_000_000;\n+\n+    @Param({\n+        \"5\",\n+        \"10\",\n+        \"25\",\n+        \"50\",\n+        \"100\"\n+    })\n+    public int numCases;\n+\n+    @Param({\n+        \"0\",\n+        \"150\"\n+    })\n+    public int offset;\n+\n+    @Param({\n+        \"true\",\n+        \"false\"\n+    })\n+    public boolean sorted;\n+\n+    public int[] inputs;\n+\n+    @Setup(Level.Trial)\n+    public void setupTrial() throws Throwable {\n+        MethodHandle[] cases = IntStream.range(0, numCases)\n+                        .mapToObj(i -> MethodHandles.insertArguments(MH_PAYLOAD, 1, i))\n+                        .toArray(MethodHandle[]::new);\n+        MethodHandle switcher = MethodHandles.tableSwitch(MH_DEFAULT, cases);\n+        if (offset != 0) {\n+            switcher = MethodHandles.filterArguments(switcher, 0, MethodHandles.insertArguments(MH_SUBTRACT, 1, offset));\n+        }\n+\n+        cs.setTarget(switcher);\n+\n+        inputs = new int[BATCH_SIZE];\n+        Random rand = new Random(0);\n+        for (int i = 0; i < BATCH_SIZE; i++) {\n+            inputs[i] = rand.nextInt(numCases) + offset;\n+        }\n+\n+        if (sorted) {\n+            Arrays.sort(inputs);\n+        }\n+    }\n+\n+    private static int payload(int dropped, int constant) {\n+        return constant;\n+    }\n+\n+    private static int subtract(int a, int b) {\n+        return a - b;\n+    }\n+\n+    private static int defaultCase(int x) {\n+        throw new IllegalStateException();\n+    }\n+\n+    @Benchmark\n+    public void testSwitch(Blackhole bh) throws Throwable {\n+        for (int i = 0; i < inputs.length; i++) {\n+            bh.consume((int) target.invokeExact(inputs[i]));\n+        }\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/invoke\/MethodHandlesTableSwitchRandom.java","additions":149,"deletions":0,"binary":false,"changes":149,"status":"added"}]}