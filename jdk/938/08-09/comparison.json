{"files":[{"patch":"@@ -5214,0 +5214,4 @@\n+            \/\/ special check for 24:00 for midnight in hour-of-day\n+            if (from == 0 && to == 0 && mod == 1_440) {\n+                return true;\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/time\/format\/DateTimeFormatterBuilder.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -473,34 +473,0 @@\n-        if (dayPeriod != null) {\n-            if (fieldValues.containsKey(HOUR_OF_DAY)) {\n-                long hod = fieldValues.remove(HOUR_OF_DAY);\n-                if (resolverStyle != ResolverStyle.LENIENT) {\n-                    HOUR_OF_DAY.checkValidValue(hod);\n-                }\n-                updateCheckDayPeriodConflict(HOUR_OF_DAY, hod);\n-            } else if (fieldValues.containsKey(HOUR_OF_AMPM)) {\n-                long hoap = fieldValues.remove(HOUR_OF_AMPM);\n-                if (resolverStyle != ResolverStyle.LENIENT) {\n-                    HOUR_OF_AMPM.checkValidValue(hoap);\n-                }\n-                if (dayPeriod.includes((hoap % 24 + 12) * 60)) {\n-                    hoap += 12;\n-                }\n-                updateCheckDayPeriodConflict(HOUR_OF_DAY, hoap);\n-            } else if (resolverStyle != ResolverStyle.STRICT){\n-                long midpoint = dayPeriod.mid();\n-                fieldValues.put(HOUR_OF_DAY, midpoint \/ 60);\n-                fieldValues.put(MINUTE_OF_HOUR, midpoint % 60);\n-            }\n-        } else if (fieldValues.containsKey(AMPM_OF_DAY) && !fieldValues.containsKey(HOUR_OF_DAY) &&\n-                    resolverStyle != ResolverStyle.STRICT) {\n-            \/\/ If no day period exists, ampm-of-day is not resolved yet, and in non-STRICT mode,\n-            \/\/ set the midpoint time 06:00 and 18:00 for am\/pm respectively, unless\n-            \/\/ hour-of-day is resolved at this point.\n-            long ap = fieldValues.remove(AMPM_OF_DAY);\n-            if (resolverStyle == ResolverStyle.LENIENT) {\n-                updateCheckConflict(AMPM_OF_DAY, HOUR_OF_DAY, Math.addExact(Math.multiplyExact(ap, 12), 6));\n-            } else {  \/\/ SMART\n-                AMPM_OF_DAY.checkValidValue(ap);\n-                updateCheckConflict(AMPM_OF_DAY, HOUR_OF_DAY, ap * 12 + 6);\n-            }\n-        }\n@@ -531,0 +497,12 @@\n+        if (dayPeriod != null && fieldValues.containsKey(HOUR_OF_AMPM)) {\n+            long hoap = fieldValues.remove(HOUR_OF_AMPM);\n+            if (resolverStyle != ResolverStyle.LENIENT) {\n+                HOUR_OF_AMPM.checkValidValue(hoap);\n+            }\n+            if (dayPeriod.includes((hoap % 24 + 12) * 60)) {\n+                hoap += 12;\n+            }\n+            updateCheckDayPeriodConflict(HOUR_OF_DAY, hoap);\n+            dayPeriod = null;\n+        }\n+\n@@ -567,0 +545,18 @@\n+            \/\/ Set the hour-of-day, if not exist and not in STRICT, to the mid point of the day period or am\/pm.\n+            if (!fieldValues.containsKey(HOUR_OF_DAY) && resolverStyle != ResolverStyle.STRICT) {\n+                if (dayPeriod != null) {\n+                    long midpoint = dayPeriod.mid();\n+                    fieldValues.put(HOUR_OF_DAY, midpoint \/ 60);\n+                    fieldValues.put(MINUTE_OF_HOUR, midpoint % 60);\n+                } else if (fieldValues.containsKey(AMPM_OF_DAY)) {\n+                    \/\/ Set the midpoint time 06:00 and 18:00 for am\/pm respectively\n+                    long ap = fieldValues.remove(AMPM_OF_DAY);\n+                    if (resolverStyle == ResolverStyle.LENIENT) {\n+                        updateCheckConflict(AMPM_OF_DAY, HOUR_OF_DAY, Math.addExact(Math.multiplyExact(ap, 12), 6));\n+                    } else {  \/\/ SMART\n+                        AMPM_OF_DAY.checkValidValue(ap);\n+                        updateCheckConflict(AMPM_OF_DAY, HOUR_OF_DAY, ap * 12 + 6);\n+                    }\n+                }\n+            }\n+\n@@ -570,0 +566,5 @@\n+                if (dayPeriod != null) {\n+                    \/\/ Check whether the hod is within the day period\n+                    updateCheckDayPeriodConflict(HOUR_OF_DAY, hod);\n+                }\n+\n","filename":"src\/java.base\/share\/classes\/java\/time\/format\/Parsed.java","additions":35,"deletions":34,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -668,0 +668,17 @@\n+    @DataProvider(name=\"dayPeriodParseMidnight\")\n+    Object[][] data_dayPeriodParseMidnight() {\n+        return new Object[][] {\n+            {\"u-M-d H:m B\", \"2020-11-07 00:00 midnight\", 7, 0},\n+            {\"u-M-d H:m B\", \"2020-11-07 24:00 midnight\", 8, 0},\n+        };\n+    }\n+\n+    @Test (dataProvider=\"dayPeriodParseMidnight\")\n+    public void test_dayPeriodParseMidnight(String pattern, String dateTime, long expectedDOM, long expectedHOD) throws Exception {\n+        builder.appendPattern(pattern);\n+        DateTimeFormatter f = builder.toFormatter().withLocale(Locale.US);\n+        var p = f.parse(dateTime);\n+        assertEquals(p.getLong(DAY_OF_MONTH), expectedDOM);\n+        assertEquals(p.getLong(HOUR_OF_DAY), expectedHOD);\n+    }\n+\n","filename":"test\/jdk\/java\/time\/test\/java\/time\/format\/TestDateTimeFormatterBuilder.java","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"}]}