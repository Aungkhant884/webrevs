{"files":[{"patch":"@@ -378,0 +378,10 @@\n+        \/\/ rules\n+        String rule = CLDRConverter.pluralRules.get(id);\n+        if (rule != null) {\n+            myMap.put(\"PluralRules\", rule);\n+        }\n+        rule = CLDRConverter.dayPeriodRules.get(id);\n+        if (rule != null) {\n+            myMap.put(\"DayPeriodRules\", rule);\n+        }\n+\n@@ -525,2 +535,0 @@\n-                        \/\/ For example, character 'B' is mapped with 'a', as 'B' is not\n-                        \/\/ supported in either SimpleDateFormat or j.t.f.DateTimeFormatter\n@@ -656,11 +664,0 @@\n-            case 'B':\n-                \/\/ 'B' character (day period) is not supported by\n-                \/\/ SimpleDateFormat and j.t.f.DateTimeFormatter,\n-                \/\/ this is a workaround in which 'B' character\n-                \/\/ appearing in CLDR date-time pattern is replaced\n-                \/\/ with 'a' character and hence resolved with am\/pm strings.\n-                \/\/ This workaround is based on the the fallback mechanism\n-                \/\/ specified in LDML spec for 'B' character, when a locale\n-                \/\/ does not have data for day period ('B')\n-                appendN('a', count, sb);\n-                break;\n@@ -723,0 +720,11 @@\n+            case 'B':\n+                \/\/ 'B' character (day period) is not supported by SimpleDateFormat,\n+                \/\/ this is a workaround in which 'B' character\n+                \/\/ appearing in CLDR date-time pattern is replaced\n+                \/\/ with 'a' character and hence resolved with am\/pm strings.\n+                \/\/ This workaround is based on the the fallback mechanism\n+                \/\/ specified in LDML spec for 'B' character, when a locale\n+                \/\/ does not have data for day period ('B')\n+                appendN('a', count, sb);\n+                break;\n+\n","filename":"make\/jdk\/src\/classes\/build\/tools\/cldrconverter\/Bundle.java","additions":21,"deletions":13,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -73,0 +73,1 @@\n+    private static String DAYPERIODRULE_SOURCE_FILE;\n@@ -103,0 +104,1 @@\n+    static DayPeriodRuleParseHandler handlerDayPeriodRule;\n@@ -119,0 +121,4 @@\n+    \/\/ rules maps\n+    static Map<String, String> pluralRules;\n+    static Map<String, String> dayPeriodRules;\n+\n@@ -251,0 +257,1 @@\n+        DAYPERIODRULE_SOURCE_FILE = CLDR_BASE + \"\/supplemental\/dayPeriods.xml\";\n@@ -262,0 +269,4 @@\n+        \/\/ rules maps\n+        pluralRules = generateRules(handlerPlurals);\n+        dayPeriodRules = generateRules(handlerDayPeriodRule);\n+\n@@ -271,3 +282,0 @@\n-\n-            \/\/ Generate Plural rules\n-            generatePluralRules();\n@@ -465,0 +473,4 @@\n+\n+        \/\/ Parse day period rules\n+        handlerDayPeriodRule = new DayPeriodRuleParseHandler();\n+        parseLDMLFile(new File(DAYPERIODRULE_SOURCE_FILE), handlerDayPeriodRule);\n@@ -812,1 +824,3 @@\n-        \"DateTimePatternChars\"\n+        \"DateTimePatternChars\",\n+        \"PluralRules\",\n+        \"DayPeriodRules\",\n@@ -1128,9 +1142,5 @@\n-     * Generate ResourceBundle source file for plural rules. The generated\n-     * class is {@code sun.text.resources.PluralRules} which has one public\n-     * two dimensional array {@code rulesArray}. Each array element consists\n-     * of two elements that designate the locale and the locale's plural rules\n-     * string. The latter has the syntax from Unicode Consortium's\n-     * <a href=\"http:\/\/unicode.org\/reports\/tr35\/tr35-numbers.html#Plural_rules_syntax\">\n-     * Plural rules syntax<\/a>. {@code samples} and {@code \"other\"} are being ommited.\n-     *\n-     * @throws Exception\n+     * Generates rules map for Plural rules and DayPeriod rules. The key is the locale id,\n+     * and the value is rules, defined by the LDML spec. Each rule consists of {@code type:rule}\n+     * notation, concatenated with a \";\" as a delimiter.\n+     * @param handler handler containing rules\n+     * @return the map\n@@ -1138,26 +1148,3 @@\n-    private static void generatePluralRules() throws Exception {\n-        Files.createDirectories(Paths.get(DESTINATION_DIR, \"sun\", \"text\", \"resources\"));\n-        Files.write(Paths.get(DESTINATION_DIR, \"sun\", \"text\", \"resources\", \"PluralRules.java\"),\n-            Stream.concat(\n-                Stream.concat(\n-                    Stream.of(\n-                        \"package sun.text.resources;\",\n-                        \"public final class PluralRules {\",\n-                        \"    public static final String[][] rulesArray = {\"\n-                    ),\n-                    pluralRulesStream().sorted()\n-                ),\n-                Stream.of(\n-                    \"    };\",\n-                    \"}\"\n-                )\n-            )\n-            .collect(Collectors.toList()),\n-        StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING);\n-    }\n-\n-    private static Stream<String> pluralRulesStream() {\n-        return handlerPlurals.getData().entrySet().stream()\n-            .filter(e -> !(e.getValue()).isEmpty())\n-            .map(e -> {\n-                String loc = e.getKey();\n+    private static Map<String, String> generateRules(AbstractLDMLHandler<Map<String, String>> handler) {\n+        return handler.getData().entrySet().stream()\n+            .collect(Collectors.toMap(Map.Entry::getKey, e -> {\n@@ -1165,6 +1152,5 @@\n-                return \"        {\\\"\" + loc + \"\\\", \\\"\" +\n-                    rules.entrySet().stream()\n-                        .map(rule -> rule.getKey() + \":\" + rule.getValue().replaceFirst(\"@.*\", \"\"))\n-                        .map(String::trim)\n-                        .collect(Collectors.joining(\";\")) + \"\\\"},\";\n-            });\n+                return rules.entrySet().stream()\n+                    .map(rule -> rule.getKey() + \":\" + rule.getValue().replaceFirst(\"@.*\", \"\"))\n+                    .map(String::trim)\n+                    .collect(Collectors.joining(\";\"));\n+            }));\n@@ -1191,1 +1177,0 @@\n-\n","filename":"make\/jdk\/src\/classes\/build\/tools\/cldrconverter\/CLDRConverter.java","additions":31,"deletions":46,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -0,0 +1,119 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package build.tools.cldrconverter;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.xml.sax.Attributes;\n+import org.xml.sax.InputSource;\n+import org.xml.sax.SAXException;\n+\n+\/**\n+ * Handles parsing of dayPeriods.xml for day period rules.\n+ *\/\n+\n+class DayPeriodRuleParseHandler extends AbstractLDMLHandler<Map<String, String>> {\n+\n+    @Override\n+    public InputSource resolveEntity(String publicID, String systemID) throws IOException, SAXException {\n+        \/\/ avoid HTTP traffic to unicode.org\n+        if (systemID.startsWith(CLDRConverter.SPPL_LDML_DTD_SYSTEM_ID)) {\n+            return new InputSource((new File(CLDRConverter.LOCAL_SPPL_LDML_DTD)).toURI().toString());\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException {\n+        switch (qName) {\n+            case \"dayPeriodRuleSet\":\n+                if (attributes.getValue(\"type\") != null) {\n+                    \/\/ ignore \"selection\"\n+                    pushIgnoredContainer(qName);\n+                } else {\n+                    pushContainer(qName, attributes);\n+                }\n+                break;\n+            case \"dayPeriodRules\":\n+                if (!isIgnored(attributes)) {\n+                    pushKeyContainer(qName, attributes, attributes.getValue(\"locales\"));\n+                } else {\n+                    pushIgnoredContainer(qName);\n+                }\n+                break;\n+        case \"dayPeriodRule\":\n+            if (!isIgnored(attributes) && currentContainer instanceof KeyContainer) {\n+                String at = attributes.getValue(\"at\");\n+                String from = attributes.getValue(\"from\");\n+                String before = attributes.getValue(\"before\");\n+                String output = \"\";\n+                if (at == null || at.isEmpty()) {\n+                    output = from + \"-\" + before;\n+                } else {\n+                    output = at;\n+                }\n+                pushStringEntry(qName, attributes, attributes.getValue(\"type\"), output);\n+            } else {\n+                pushIgnoredContainer(qName);\n+            }\n+            break;\n+        default:\n+            \/\/ treat anything else as a container\n+            pushContainer(qName, attributes);\n+            break;\n+        }\n+    }\n+\n+    @Override\n+        public void endElement(String uri, String localName, String qName) throws SAXException {\n+            assert qName.equals(currentContainer.getqName()) : \"current=\" + currentContainer.getqName() + \", param=\" + qName;\n+            switch (qName) {\n+                case \"dayPeriodRule\":\n+                    if (currentContainer instanceof Entry) {\n+                        Entry<?> entry = (Entry<?>) currentContainer;\n+                        final String type = entry.getKey();\n+                        final String rule = (String) entry.getValue();\n+                        String locales = ((KeyContainer) (currentContainer.getParent())).getKey();\n+                        Arrays.stream(locales.split(\"\\\\s\"))\n+                            .forEach(loc -> {\n+                                Map<String, String> rules = get(loc);\n+                                if (rules == null) {\n+                                    rules = new HashMap<>();\n+                                    put(loc, rules);\n+                                }\n+                                rules.put(type, rule);\n+                            });\n+                    }\n+                    break;\n+            }\n+\n+            currentContainer = currentContainer.getParent();\n+        }\n+}\n","filename":"make\/jdk\/src\/classes\/build\/tools\/cldrconverter\/DayPeriodRuleParseHandler.java","additions":119,"deletions":0,"binary":false,"changes":119,"status":"added"},{"patch":"@@ -303,2 +303,0 @@\n-            \/\/ for FormatData\n-            \/\/ need to keep stand-alone and format, to allow for multiple inheritance in CLDR\n@@ -319,1 +317,1 @@\n-            \/\/ create string array entry for am\/pm. only keeping wide\n+            \/\/ create string array entry for am\/pm.\n@@ -323,1 +321,1 @@\n-                pushStringArrayEntry(qName, attributes, \"AmPmMarkers\/\" + getContainerKey(), 2);\n+                pushStringArrayEntry(qName, attributes, \"AmPmMarkers\/\" + getContainerKey(), 12);\n@@ -326,1 +324,1 @@\n-                pushStringArrayEntry(qName, attributes, \"narrow.AmPmMarkers\/\" + getContainerKey(), 2);\n+                pushStringArrayEntry(qName, attributes, \"narrow.AmPmMarkers\/\" + getContainerKey(), 12);\n@@ -329,1 +327,1 @@\n-                pushStringArrayEntry(qName, attributes, \"abbreviated.AmPmMarkers\/\" + getContainerKey(), 2);\n+                pushStringArrayEntry(qName, attributes, \"abbreviated.AmPmMarkers\/\" + getContainerKey(), 12);\n@@ -347,0 +345,30 @@\n+                case \"midnight\":\n+                    pushStringArrayElement(qName, attributes, 2);\n+                    break;\n+                case \"noon\":\n+                    pushStringArrayElement(qName, attributes, 3);\n+                    break;\n+                case \"morning1\":\n+                    pushStringArrayElement(qName, attributes, 4);\n+                    break;\n+                case \"morning2\":\n+                    pushStringArrayElement(qName, attributes, 5);\n+                    break;\n+                case \"afternoon1\":\n+                    pushStringArrayElement(qName, attributes, 6);\n+                    break;\n+                case \"afternoon2\":\n+                    pushStringArrayElement(qName, attributes, 7);\n+                    break;\n+                case \"evening1\":\n+                    pushStringArrayElement(qName, attributes, 8);\n+                    break;\n+                case \"evening2\":\n+                    pushStringArrayElement(qName, attributes, 9);\n+                    break;\n+                case \"night1\":\n+                    pushStringArrayElement(qName, attributes, 10);\n+                    break;\n+                case \"night2\":\n+                    pushStringArrayElement(qName, attributes, 11);\n+                    break;\n@@ -974,0 +1002,1 @@\n+    @SuppressWarnings(\"fallthrough\")\n","filename":"make\/jdk\/src\/classes\/build\/tools\/cldrconverter\/LDMLParseHandler.java","additions":35,"deletions":6,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -87,3 +87,4 @@\n-                final String rule = (String)entry.getValue();\n-                String locales = ((KeyContainer)(currentContainer.getParent())).getKey();\n-                Arrays.stream(locales.split(\"\\\\s\"))\n+                if (!count.equals(\"other\")) {\n+                    final String rule = (String)entry.getValue();\n+                    String locales = ((KeyContainer)(currentContainer.getParent())).getKey();\n+                    Arrays.stream(locales.split(\"\\\\s\"))\n@@ -96,3 +97,1 @@\n-                            if (!count.equals(\"other\")) {\n-                                rules.put(count, rule);\n-                            }\n+                            rules.put(count, rule);\n@@ -100,0 +99,1 @@\n+                }\n","filename":"make\/jdk\/src\/classes\/build\/tools\/cldrconverter\/PluralsParseHandler.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,1 @@\n+import java.util.List;\n@@ -72,0 +73,1 @@\n+    @SuppressWarnings(\"unchecked\")\n@@ -165,1 +167,7 @@\n-                                for (String s : (String[])val) {\n+                                for (String s : (String[]) val) {\n+                                    fmt.format(\"               \\\"%s\\\",\\n\", CLDRConverter.saveConvert(s, useJava));\n+                                }\n+                                fmt.format(\"            };\\n\");\n+                            } else if (val instanceof List) {\n+                                fmt.format(\"        final String[] %s = new String[] {\\n\", metaVal);\n+                                for (String s : (List<String>) val) {\n","filename":"make\/jdk\/src\/classes\/build\/tools\/cldrconverter\/ResourceBundleGenerator.java","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -761,0 +761,5 @@\n+            \/\/ the array in the resource bundle may contain more elements for day periods.\n+            \/\/ Extract only am\/pm.\n+            if (dfs.ampms.length > 2) {\n+                dfs.ampms = Arrays.copyOf(dfs.ampms, 2);\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/text\/DateFormatSymbols.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -67,0 +67,1 @@\n+import static java.time.temporal.ChronoField.MINUTE_OF_DAY;\n@@ -105,0 +106,1 @@\n+import java.util.Calendar;\n@@ -120,0 +122,2 @@\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n@@ -124,0 +128,1 @@\n+import sun.util.locale.provider.LocaleResources;\n@@ -221,1 +226,1 @@\n-        String pattern = provider.getJavaTimeDateTimePattern(convertStyle(timeStyle),\n+        return provider.getJavaTimeDateTimePattern(convertStyle(timeStyle),\n@@ -224,1 +229,0 @@\n-        return pattern;\n@@ -681,1 +685,1 @@\n-     * {@link appendValue(java.time.temporal.TemporalField, int)}. When parsing in lenient mode,\n+     * {@link #appendValue(java.time.temporal.TemporalField, int)}. When parsing in lenient mode,\n@@ -1450,0 +1454,44 @@\n+    \/**\n+     * Appends the day period text to the formatter.\n+     * <p>\n+     * This appends an instruction to format\/parse the textual name of the day period\n+     * to the builder. Day periods are defined in LDML's\n+     * <a href=\"https:\/\/unicode.org\/reports\/tr35\/tr35-dates.html#dayPeriods\">\"day periods\"\n+     * <\/a> element.\n+     * <p>\n+     * During formatting, the day period is obtained from {@code HOUR_OF_DAY}, and\n+     * optionally {@code MINUTE_OF_HOUR} if exist. It will be mapped to a day period\n+     * type defined in LDML, such as \"morning1\" and then it will be translated into\n+     * text. Mapping to a day period type and its translation both depend on the\n+     * locale in the formatter.\n+     * <p>\n+     * During parsing, the text will be parsed into a day period type first. If\n+     * {@code HOUR_OF_DAY}, and optionally {@code MINUTE_OF_HOUR} exists,\n+     * those values are validated with the parsed day period. If they are within the\n+     * parsed day period, those values remain intact, otherwise {@code DateTimeException}\n+     * is thrown. If {@code HOUR_OF_AMPM} exists and validated with the day period,\n+     * {@code HOUR_OF_DAY} is derived from the parsed day period. If neither\n+     * {@code HOUR_OF_DAY} nor {@code HOUR_OF_AMPM} exists, {@code HOUR_OF_DAY} and\n+     * {@code MINUTE_OF_HOUR} are resolved to the mid-point of the day period.\n+     * For example, if the parsed day period type is \"night1\" and the period defined\n+     * for it in the formatter locale is from 21:00 to 06:00, then {@code HOUR_OF_DAY}\n+     * is set to '1' and {@code MINUTE_OF_HOUR} set to '30'. If any conflict occurs in\n+     * {@link ResolverStyle#LENIENT LENIENT} mode, no exception is thrown and the day\n+     * period is ignored.\n+     *\n+     * @param style the text style to use, not null\n+     * @return this, for chaining, not null\n+     * @since 16\n+     *\/\n+    public DateTimeFormatterBuilder appendDayPeriodText(TextStyle style) {\n+        Objects.requireNonNull(style, \"style\");\n+        switch (style) {\n+            \/\/ Stand-alone is not applicable. Convert to standard text style\n+            case FULL_STANDALONE -> style = TextStyle.FULL;\n+            case SHORT_STANDALONE -> style = TextStyle.SHORT;\n+            case NARROW_STANDALONE -> style = TextStyle.NARROW;\n+        }\n+        appendInternal(new DayPeriodPrinterParser(style));\n+        return this;\n+    }\n+\n@@ -1513,0 +1561,1 @@\n+     *   B       period-of-day               text              in the morning\n@@ -1643,0 +1692,9 @@\n+     * <b>Day periods<\/b>: Pattern letters to output a day period.\n+     * <pre>\n+     *  Pattern  Count  Equivalent builder methods\n+     *  -------  -----  --------------------------\n+     *    B       1      appendDayPeriodText(TextStyle.SHORT)\n+     *    BBBB    4      appendDayPeriodText(TextStyle.FULL)\n+     *    BBBBB   5      appendDayPeriodText(TextStyle.NARROW)\n+     * <\/pre>\n+     * <p>\n@@ -1762,1 +1820,1 @@\n-                        throw new IllegalArgumentException(\"Wrong number of  pattern letters: \" + cur);\n+                        throw new IllegalArgumentException(\"Wrong number of pattern letters: \" + cur);\n@@ -1812,0 +1870,7 @@\n+                } else if (cur == 'B') {\n+                    switch (count) {\n+                        case 1 -> appendDayPeriodText(TextStyle.SHORT);\n+                        case 4 -> appendDayPeriodText(TextStyle.FULL);\n+                        case 5 -> appendDayPeriodText(TextStyle.NARROW);\n+                        default -> throw new IllegalArgumentException(\"Wrong number of pattern letters: \" + cur);\n+                    }\n@@ -1923,13 +1988,4 @@\n-                    case 1:\n-                    case 2:\n-                    case 3:\n-                        appendText(field, TextStyle.SHORT);\n-                        break;\n-                    case 4:\n-                        appendText(field, TextStyle.FULL);\n-                        break;\n-                    case 5:\n-                        appendText(field, TextStyle.NARROW);\n-                        break;\n-                    default:\n-                        throw new IllegalArgumentException(\"Too many pattern letters: \" + cur);\n+                    case 1, 2, 3 -> appendText(field, TextStyle.SHORT);\n+                    case 4 -> appendText(field, TextStyle.FULL);\n+                    case 5 -> appendText(field, TextStyle.NARROW);\n+                    default -> throw new IllegalArgumentException(\"Too many pattern letters: \" + cur);\n@@ -2028,0 +2084,1 @@\n+        \/\/ LDML - B - day periods\n@@ -2163,3 +2220,1 @@\n-            if (pp != null) {\n-                pp = new PadPrinterParserDecorator(pp, active.padNextWidth, active.padNextChar);\n-            }\n+            pp = new PadPrinterParserDecorator(pp, active.padNextWidth, active.padNextChar);\n@@ -2314,1 +2369,1 @@\n-            this(printerParsers.toArray(new DateTimePrinterParser[printerParsers.size()]), optional);\n+            this(printerParsers.toArray(new DateTimePrinterParser[0]), optional);\n@@ -3132,1 +3187,1 @@\n-         * For FractionPrinterPrinterParser, the width is fixed if context is sttrict,\n+         * For FractionPrinterPrinterParser, the width is fixed if context is strict,\n@@ -3136,1 +3191,1 @@\n-         * @see DateTimeFormatterBuilder#appendValueFraction(java.time.temporal.TemporalField, int, int, boolean)\n+         * @see #appendFraction(java.time.temporal.TemporalField, int, int, boolean)\n@@ -4978,1 +5033,2 @@\n-    \/\/-------------------------------------------------------------------------\n+    \/\/-----------------------------------------------------------------------\n+\n@@ -4980,1 +5036,1 @@\n-     * Length comparator.\n+     * Prints or parses day periods.\n@@ -4982,1 +5038,14 @@\n-    static final Comparator<String> LENGTH_SORT = new Comparator<String>() {\n+    static final class DayPeriodPrinterParser implements DateTimePrinterParser {\n+        private final TextStyle textStyle;\n+        private final static ConcurrentMap<Locale, LocaleStore> DAYPERIOD_LOCALESTORE = new ConcurrentHashMap<>();\n+\n+        \/**\n+         * Constructor.\n+         *\n+         * @param textStyle  the text style, not null\n+         *\/\n+        DayPeriodPrinterParser(TextStyle textStyle) {\n+            \/\/ validated by caller\n+            this.textStyle = textStyle;\n+        }\n+\n@@ -4984,2 +5053,17 @@\n-        public int compare(String str1, String str2) {\n-            return str1.length() == str2.length() ? str1.compareTo(str2) : str1.length() - str2.length();\n+        public boolean format(DateTimePrintContext context, StringBuilder buf) {\n+            Long value = context.getValue(MINUTE_OF_DAY);\n+            if (value == null) {\n+                return false;\n+            }\n+            Locale locale = context.getLocale();\n+            LocaleStore store = findDayPeriodStore(locale);\n+            final long val = value;\n+            final var map = DayPeriod.getDayPeriodMap(locale);\n+            value = map.keySet().stream()\n+                    .filter(k -> k.includes(val))\n+                    .min(DayPeriod.DPCOMPARATOR)\n+                    .map(map::get)\n+                    .orElse(val \/ 720); \/\/ fall back to am\/pm\n+            String text = store.getText(value, textStyle);\n+            buf.append(text);\n+            return true;\n@@ -4987,1 +5071,248 @@\n-    };\n+\n+        @Override\n+        public int parse(DateTimeParseContext context, CharSequence parseText, int position) {\n+            int length = parseText.length();\n+            if (position < 0 || position > length) {\n+                throw new IndexOutOfBoundsException();\n+            }\n+            TextStyle style = (context.isStrict() ? textStyle : null);\n+            Iterator<Entry<String, Long>> it;\n+            LocaleStore store = findDayPeriodStore(context.getLocale());\n+            it = store.getTextIterator(style);\n+            if (it != null) {\n+                while (it.hasNext()) {\n+                    Entry<String, Long> entry = it.next();\n+                    String itText = entry.getKey();\n+                    if (context.subSequenceEquals(itText, 0, parseText, position, itText.length())) {\n+                        context.setParsedDayPeriod(DayPeriod.ofLocale(context.getLocale(), entry.getValue()));\n+                        return position + itText.length();\n+                    }\n+                }\n+            }\n+            return ~position;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"DayPeriod(\" + textStyle + \")\";\n+        }\n+\n+        \/**\n+         * Returns the day period locale store for the locale\n+         * @param locale\n+         * @return\n+         *\/\n+        private static LocaleStore findDayPeriodStore(Locale locale) {\n+            return DAYPERIOD_LOCALESTORE.computeIfAbsent(locale, loc -> {\n+                Map<TextStyle, Map<Long, String>> styleMap = new HashMap<>();\n+\n+                for (TextStyle textStyle : TextStyle.values()) {\n+                    if (textStyle.isStandalone()) {\n+                        \/\/ Stand-alone isn't applicable to day period.\n+                        continue;\n+                    }\n+\n+                    Map<Long, String> map = new HashMap<>();\n+                    int calStyle = textStyle.toCalendarStyle();\n+                    var periodMap = DayPeriod.getDayPeriodMap(loc);\n+                    periodMap.forEach((key, value) -> {\n+                        String displayName = CalendarDataUtility.retrieveJavaTimeFieldValueName(\n+                                \"gregory\", Calendar.AM_PM, value.intValue(), calStyle, loc);\n+                        if (displayName != null) {\n+                            map.put(value, displayName);\n+                        } else {\n+                            periodMap.remove(key);\n+                        }\n+                    });\n+                    if (!map.isEmpty()) {\n+                        styleMap.put(textStyle, map);\n+                    }\n+                }\n+                return new LocaleStore(styleMap);\n+            });\n+        }\n+    }\n+\n+    \/**\n+     * DayPeriod class that represents a\n+     * <a href=\"https:\/\/www.unicode.org\/reports\/tr35\/tr35-dates.html#dayPeriods\">DayPeriod<\/a> defined in CLDR.\n+     * This is a value-based class.\n+     *\/\n+    static final class DayPeriod {\n+        \/**\n+         *  DayPeriod cache\n+         *\/\n+        private final static Map<Locale, Map<DayPeriod, Long>> DAYPERIOD_CACHE = new ConcurrentHashMap<>();\n+        \/**\n+         * comparator based on the duration of the day period.\n+         *\/\n+        private final static Comparator<DayPeriod> DPCOMPARATOR = (dp1, dp2) -> (int)(dp1.duration() - dp2.duration());\n+        \/**\n+         * Pattern to parse day period rules\n+         *\/\n+        private final static Pattern RULE = Pattern.compile(\"(?<type>[a-z12]+):(?<from>\\\\d{2}):00(-(?<to>\\\\d{2}))*\");\n+        \/**\n+         * minute-of-day of \"at\" or \"from\" attribute\n+         *\/\n+        private final long from;\n+        \/**\n+         * minute-of-day of \"before\" attribute (exclusive), or if it is\n+         * the same value with \"from\", it indicates this day period\n+         * designates \"fixed\" periods, i.e, \"midnight\" or \"noon\"\n+         *\/\n+        private final long to;\n+        \/**\n+         * day period type index. (cf. {@link #mapToIndex})\n+         *\/\n+        private final long index;\n+\n+        \/**\n+         * Sole constructor\n+         *\n+         * @param from \"from\" in minute-of-day\n+         * @param to \"to\" in minute-of-day\n+         * @param index day period type index\n+         *\/\n+        private DayPeriod(long from, long to, long index) {\n+            this.from = from;\n+            this.to = to;\n+            this.index = index;\n+        }\n+\n+        \/**\n+         * Gets the index of this day period\n+         *\n+         * @return index\n+         *\/\n+        long getIndex() {\n+            return index;\n+        }\n+\n+        \/**\n+         * Returns the midpoint of this day period in minute-of-day\n+         * @return midpoint\n+         *\/\n+        long mid() {\n+            return (from + duration() \/ 2) % 1_440;\n+        }\n+\n+        \/**\n+         * Checks whether the passed minute-of-day is within this\n+         * day period or not.\n+         *\n+         * @param mod minute-of-day to check\n+         * @return true if {@code mod} is within this day period\n+         *\/\n+        boolean includes(long mod) {\n+            return (from == mod && to == mod || \/\/ midnight\/noon\n+                    from <= mod && mod < to || \/\/ contiguous from-to\n+                    from > to && (from <= mod || to > mod)); \/\/ beyond midnight\n+        }\n+\n+        \/**\n+         * Calculates the duration of this day period\n+         * @return the duration in minutes\n+         *\/\n+        private long duration() {\n+            return from > to ? 1_440 - from + to: to - from;\n+        }\n+\n+        \/**\n+         * Maps the day period type defined in LDML to the index to the am\/pm array\n+         * returned from the Calendar resource bundle.\n+         *\n+         * @param type day period type defined in LDML\n+         * @return the array index\n+         *\/\n+        static long mapToIndex(String type) {\n+            return switch (type) {\n+                case \"am\"           -> Calendar.AM;\n+                case \"pm\"           -> Calendar.PM;\n+                case \"midnight\"     -> 2;\n+                case \"noon\"         -> 3;\n+                case \"morning1\"     -> 4;\n+                case \"morning2\"     -> 5;\n+                case \"afternoon1\"   -> 6;\n+                case \"afternoon2\"   -> 7;\n+                case \"evening1\"     -> 8;\n+                case \"evening2\"     -> 9;\n+                case \"night1\"       -> 10;\n+                case \"night2\"       -> 11;\n+                default -> throw new InternalError(\"invalid day period type\");\n+            };\n+        }\n+\n+        \/**\n+         * Returns the DayPeriod to array index map for a locale.\n+         *\n+         * @param locale  the locale, not null\n+         * @return the DayPeriod to type index map\n+         *\/\n+        static Map<DayPeriod, Long> getDayPeriodMap(Locale locale) {\n+            return DAYPERIOD_CACHE.computeIfAbsent(locale, l -> {\n+                LocaleResources lr = LocaleProviderAdapter.getResourceBundleBased()\n+                        .getLocaleResources(CalendarDataUtility.findRegionOverride(l));\n+                String dayPeriodRules = lr.getRules()[1];\n+                final Map<DayPeriod, Long> periodMap = new ConcurrentHashMap<>();\n+                Arrays.stream(dayPeriodRules.split(\";\"))\n+                    .forEach(rule -> {\n+                        Matcher m = RULE.matcher(rule);\n+                        if (m.find()) {\n+                            String from = m.group(\"from\");\n+                            String to = m.group(\"to\");\n+                            long index = DayPeriod.mapToIndex(m.group(\"type\"));\n+                            if (to == null) {\n+                                to = from;\n+                            }\n+                            periodMap.putIfAbsent(\n+                                new DayPeriod(\n+                                    Long.parseLong(from) * 60,\n+                                    Long.parseLong(to) * 60,\n+                                        index),\n+                                index);\n+                        }\n+                    });\n+\n+                \/\/ add am\/pm\n+                periodMap.putIfAbsent(new DayPeriod(0, 720, 0), 0L);\n+                periodMap.putIfAbsent(new DayPeriod(720, 1_440, 1), 1L);\n+                return periodMap;\n+            });\n+        }\n+\n+        \/**\n+         * Returns the DayPeriod singleton for the locale and index.\n+         * @param locale desired locale\n+         * @param index resource bundle array index\n+         * @return a DayPeriod instance\n+         *\/\n+        static DayPeriod ofLocale(Locale locale, long index) {\n+            return getDayPeriodMap(locale).keySet().stream()\n+                .filter(dp -> dp.getIndex() == index)\n+                .findAny()\n+                .orElseThrow(() -> new DateTimeException(\n+                    \"DayPeriod could not be determined for the locale \" +\n+                    locale + \" at type index \" + index));\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+            DayPeriod dayPeriod = (DayPeriod) o;\n+            return from == dayPeriod.from &&\n+                    to == dayPeriod.to &&\n+                    index == dayPeriod.index;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(from, to, index);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"DayPeriod(%02d:%02d\".formatted(from \/ 60, from % 60) +\n+                    (from == to ? \")\" : \"-%02d:%02d)\".formatted(to \/ 60, to % 60));\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/time\/format\/DateTimeFormatterBuilder.java","additions":360,"deletions":29,"binary":false,"changes":389,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -427,0 +427,9 @@\n+    \/**\n+     * Stores the parsed day period.\n+     *\n+     * @param dayPeriod the parsed day period\n+     *\/\n+    void setParsedDayPeriod(DateTimeFormatterBuilder.DayPeriod dayPeriod) {\n+        currentParsed().dayPeriod = dayPeriod;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/time\/format\/DateTimeParseContext.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -64,0 +64,1 @@\n+import static java.time.format.DateTimeFormatterBuilder.DayPeriod;\n@@ -158,0 +159,4 @@\n+    \/**\n+     * The parsed day period.\n+     *\/\n+    DayPeriod dayPeriod;\n@@ -175,0 +180,1 @@\n+        cloned.dayPeriod= this.dayPeriod;\n@@ -335,1 +341,19 @@\n-    \/\/-----------------------------------------------------------------------\n+    private void updateCheckDayPeriodConflict(TemporalField changeField, Long changeValue) {\n+        Long old = fieldValues.put(changeField, changeValue);\n+        if (resolverStyle != ResolverStyle.LENIENT) {\n+            if (old != null && old.longValue() != changeValue.longValue()) {\n+                throw new DateTimeException(\"Conflict found: \" + changeField + \" \" + old +\n+                        \" differs from \" + changeField + \" \" + changeValue +\n+                        \" while resolving \" + dayPeriod);\n+            }\n+            long hod = fieldValues.get(HOUR_OF_DAY);\n+            long moh = fieldValues.containsKey(MINUTE_OF_HOUR) ? fieldValues.get(MINUTE_OF_HOUR) : 0;\n+            long mod =  hod * 60 + moh;\n+            if (!dayPeriod.includes(mod)) {\n+                throw new DateTimeException(\"Conflict found: Resolved time %02d:%02d\".formatted(hod, moh) +\n+                        \" conflicts with \" + dayPeriod);\n+            }\n+        }\n+    }\n+\n+\/\/-----------------------------------------------------------------------\n@@ -449,0 +473,30 @@\n+        if (dayPeriod != null) {\n+            if (fieldValues.containsKey(HOUR_OF_DAY)) {\n+                long hod = fieldValues.remove(HOUR_OF_DAY);\n+                if (resolverStyle != ResolverStyle.LENIENT) {\n+                    HOUR_OF_DAY.checkValidValue(hod);\n+                }\n+                updateCheckDayPeriodConflict(HOUR_OF_DAY, hod);\n+            } else if (fieldValues.containsKey(HOUR_OF_AMPM)) {\n+                long hoap = fieldValues.remove(HOUR_OF_AMPM);\n+                if (resolverStyle != ResolverStyle.LENIENT) {\n+                    HOUR_OF_AMPM.checkValidValue(hoap);\n+                }\n+                if (dayPeriod.includes((hoap + 12) * 60)) {\n+                    hoap += 12;\n+                }\n+                updateCheckDayPeriodConflict(HOUR_OF_DAY, hoap);\n+            } else {\n+                long midpoint = dayPeriod.mid();\n+                fieldValues.put(HOUR_OF_DAY, midpoint \/ 60);\n+                fieldValues.put(MINUTE_OF_HOUR, midpoint % 60);\n+                \/\/ dayPeriod precedes AmPm. Override it if exists.\n+                if (fieldValues.containsKey(AMPM_OF_DAY)) {\n+                    long ap = fieldValues.remove(AMPM_OF_DAY);\n+                    if (resolverStyle != ResolverStyle.LENIENT) {\n+                        AMPM_OF_DAY.checkValidValue(ap);\n+                    }\n+                    updateCheckDayPeriodConflict(AMPM_OF_DAY, midpoint \/ 720);\n+                }\n+            }\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/time\/format\/Parsed.java","additions":56,"deletions":2,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -71,1 +71,1 @@\n-            if (strings == null && key.indexOf(\"standalone.\") != -1) {\n+            if (strings == null && key.contains(\"standalone.\")) {\n@@ -132,1 +132,1 @@\n-    private static int[] REST_OF_STYLES = {\n+    private static final int[] REST_OF_STYLES = {\n@@ -169,1 +169,1 @@\n-            if (strings == null && key.indexOf(\"standalone.\") != -1) {\n+            if (strings == null && key.contains(\"standalone.\")) {\n@@ -175,1 +175,1 @@\n-                if (!hasDuplicates(strings)) {\n+                if (!hasDuplicates(strings) || field == AM_PM) {\n@@ -182,1 +182,4 @@\n-                        for (int i = 0; i < strings.length; i++) {\n+                        \/\/ Duplicates can happen with AM_PM field. In such a case,\n+                        \/\/ am\/pm (index 0 and 1) have precedence over day\n+                        \/\/ periods.\n+                        for (int i = strings.length - 1; i >= 0; i--) {\n@@ -185,1 +188,1 @@\n-                            \/\/ are not defined)\n+                            \/\/ or flexible day periods are not defined)\n","filename":"src\/java.base\/share\/classes\/sun\/util\/locale\/provider\/CalendarNameProviderImpl.java","additions":10,"deletions":7,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,1 +52,0 @@\n-import java.util.Map;\n@@ -94,0 +93,1 @@\n+    private static final String RULES_CACHEKEY = \"RULE\";\n@@ -128,1 +128,0 @@\n-    @SuppressWarnings(\"unchecked\")\n@@ -165,1 +164,1 @@\n-                      new ResourceReference(COLLATION_DATA_CACHEKEY, (Object) coldata, referenceQueue));\n+                      new ResourceReference(COLLATION_DATA_CACHEKEY, coldata, referenceQueue));\n@@ -184,1 +183,1 @@\n-                      new ResourceReference(DECIMAL_FORMAT_SYMBOLS_DATA_CACHEKEY, (Object) dfsdata, referenceQueue));\n+                      new ResourceReference(DECIMAL_FORMAT_SYMBOLS_DATA_CACHEKEY, dfsdata, referenceQueue));\n@@ -317,1 +316,1 @@\n-        Set<String> zoneIDs = null;\n+        Set<String> zoneIDs;\n@@ -325,1 +324,1 @@\n-                      new ResourceReference(ZONE_IDS_CACHEKEY, (Object) zoneIDs, referenceQueue));\n+                      new ResourceReference(ZONE_IDS_CACHEKEY, zoneIDs, referenceQueue));\n@@ -383,1 +382,1 @@\n-                          new ResourceReference(cacheKey, (Object) names, referenceQueue));\n+                          new ResourceReference(cacheKey, names, referenceQueue));\n@@ -402,1 +401,1 @@\n-                          new ResourceReference(cacheKey, (Object) names, referenceQueue));\n+                          new ResourceReference(cacheKey, names, referenceQueue));\n@@ -466,11 +465,5 @@\n-                switch (dateTimePattern) {\n-                case \"{1} {0}\":\n-                    pattern = datePattern + \" \" + timePattern;\n-                    break;\n-                case \"{0} {1}\":\n-                    pattern = timePattern + \" \" + datePattern;\n-                    break;\n-                default:\n-                    pattern = MessageFormat.format(dateTimePattern.replaceAll(\"'\", \"''\"), timePattern, datePattern);\n-                    break;\n-                }\n+                pattern = switch (Objects.requireNonNull(dateTimePattern)) {\n+                    case \"{1} {0}\" -> datePattern + \" \" + timePattern;\n+                    case \"{0} {1}\" -> timePattern + \" \" + datePattern;\n+                    default -> MessageFormat.format(dateTimePattern.replaceAll(\"'\", \"''\"), timePattern, datePattern);\n+                };\n@@ -489,1 +482,1 @@\n-        String[] numberPatterns = null;\n+        String[] numberPatterns;\n@@ -498,1 +491,1 @@\n-                      new ResourceReference(NUMBER_PATTERNS_CACHEKEY, (Object) numberPatterns, referenceQueue));\n+                      new ResourceReference(NUMBER_PATTERNS_CACHEKEY, numberPatterns, referenceQueue));\n@@ -509,1 +502,0 @@\n-    @SuppressWarnings(\"unchecked\")\n@@ -513,1 +505,1 @@\n-        String[] compactNumberPatterns = null;\n+        String[] compactNumberPatterns;\n@@ -523,2 +515,1 @@\n-            cache.put(cacheKey, new ResourceReference(cacheKey,\n-                    (Object) compactNumberPatterns, referenceQueue));\n+            cache.put(cacheKey, new ResourceReference(cacheKey, compactNumberPatterns, referenceQueue));\n@@ -582,0 +573,22 @@\n+    public String[] getRules() {\n+        String[] rules;\n+\n+        removeEmptyReferences();\n+        ResourceReference data = cache.get(RULES_CACHEKEY);\n+\n+        if (data == null || ((rules = (String[]) data.get()) == null)) {\n+            ResourceBundle rb = localeData.getDateFormatData(locale);\n+            rules = new String[2];\n+            rules[0] = rules[1] = \"\";\n+            if (rb.containsKey(\"PluralRules\")) {\n+                rules[0] = rb.getString(\"PluralRules\");\n+            }\n+            if (rb.containsKey(\"DayPeriodRules\")) {\n+                rules[1] = rb.getString(\"DayPeriodRules\");\n+            }\n+            cache.put(RULES_CACHEKEY, new ResourceReference(RULES_CACHEKEY, rules, referenceQueue));\n+        }\n+\n+        return rules;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/util\/locale\/provider\/LocaleResources.java","additions":39,"deletions":26,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,1 +48,0 @@\n-import java.util.Arrays;\n@@ -51,1 +50,0 @@\n-import java.util.Map;\n@@ -54,2 +52,0 @@\n-import java.util.stream.Collectors;\n-import sun.text.resources.PluralRules;\n@@ -76,6 +72,0 @@\n-    private static Map<String, String> rulesMap =\n-            Arrays.stream(PluralRules.rulesArray).collect(Collectors.toMap(\n-                    sa -> sa[0],\n-                    sa -> sa[1])\n-            );\n-\n@@ -285,2 +275,1 @@\n-        String pluralRules = rulesMap.getOrDefault(override.toString(),\n-                rulesMap.getOrDefault(override.getLanguage(), \"\"));\n+        String[] rules = resource.getRules();\n@@ -288,3 +277,2 @@\n-        CompactNumberFormat format = new CompactNumberFormat(numberPatterns[0],\n-                symbols, cnPatterns, pluralRules);\n-        return format;\n+        return new CompactNumberFormat(numberPatterns[0],\n+                symbols, cnPatterns, rules[0]);\n","filename":"src\/java.base\/share\/classes\/sun\/util\/locale\/provider\/NumberFormatProviderImpl.java","additions":4,"deletions":16,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,0 +62,1 @@\n+import static java.time.format.DateTimeFormatter.ISO_LOCAL_TIME;\n@@ -64,0 +65,1 @@\n+import static java.time.temporal.ChronoField.HOUR_OF_DAY;\n@@ -71,0 +73,1 @@\n+import java.time.DateTimeException;\n@@ -72,0 +75,1 @@\n+import java.time.LocalTime;\n@@ -76,2 +80,0 @@\n-import java.time.chrono.JapaneseChronology;\n-import java.time.chrono.MinguoChronology;\n@@ -80,0 +82,1 @@\n+import java.time.format.DateTimeParseException;\n@@ -81,0 +84,1 @@\n+import java.time.format.ResolverStyle;\n@@ -83,0 +87,1 @@\n+import java.time.temporal.ChronoField;\n@@ -529,0 +534,211 @@\n+    \/\/-----------------------------------------------------------------------\n+    \/\/-----------------------------------------------------------------------\n+    \/\/-----------------------------------------------------------------------\n+    @Test\n+    public void test_appendDayPeriodText_1arg() throws Exception {\n+        builder.appendDayPeriodText(TextStyle.FULL);\n+        DateTimeFormatter f = builder.toFormatter();\n+        assertEquals(f.toString(), \"DayPeriod(FULL)\");\n+    }\n+\n+    @Test(expectedExceptions=NullPointerException.class)\n+    public void test_appendDayPeriodText_1arg_nullText() throws Exception {\n+        builder.appendDayPeriodText(null);\n+    }\n+\n+    @DataProvider(name=\"dayPeriodFormat\")\n+    Object[][] data_dayPeriodFormat() {\n+        return new Object[][] {\n+            {0, 0, TextStyle.FULL, Locale.US, \"midnight\"},\n+            {0, 1, TextStyle.FULL, Locale.US, \"at night\"},\n+            {6, 0, TextStyle.FULL, Locale.US, \"in the morning\"},\n+            {12, 0, TextStyle.FULL, Locale.US, \"noon\"},\n+            {12, 1, TextStyle.FULL, Locale.US, \"in the afternoon\"},\n+            {18, 0, TextStyle.FULL, Locale.US, \"in the evening\"},\n+            {22, 0, TextStyle.FULL, Locale.US, \"at night\"},\n+\n+            {0, 0, TextStyle.FULL, Locale.JAPAN, \"\\u771f\\u591c\\u4e2d\"},\n+            {0, 1, TextStyle.FULL, Locale.JAPAN, \"\\u591c\\u4e2d\"},\n+            {6, 0, TextStyle.FULL, Locale.JAPAN, \"\\u671d\"},\n+            {12, 0, TextStyle.FULL, Locale.JAPAN, \"\\u6b63\\u5348\"},\n+            {12, 1, TextStyle.FULL, Locale.JAPAN, \"\\u663c\"},\n+            {18, 0, TextStyle.FULL, Locale.JAPAN, \"\\u5915\\u65b9\"},\n+            {19, 0, TextStyle.FULL, Locale.JAPAN, \"\\u591c\"},\n+            {23, 0, TextStyle.FULL, Locale.JAPAN, \"\\u591c\\u4e2d\"},\n+\n+            {0, 0, TextStyle.NARROW, Locale.US, \"mi\"},\n+            {0, 1, TextStyle.NARROW, Locale.US, \"at night\"},\n+            {6, 0, TextStyle.NARROW, Locale.US, \"in the morning\"},\n+            {12, 0, TextStyle.NARROW, Locale.US, \"n\"},\n+            {12, 1, TextStyle.NARROW, Locale.US, \"in the afternoon\"},\n+            {18, 0, TextStyle.NARROW, Locale.US, \"in the evening\"},\n+            {22, 0, TextStyle.NARROW, Locale.US, \"at night\"},\n+\n+            {0, 0, TextStyle.NARROW, Locale.JAPAN, \"\\u771f\\u591c\\u4e2d\"},\n+            {0, 1, TextStyle.NARROW, Locale.JAPAN, \"\\u591c\\u4e2d\"},\n+            {6, 0, TextStyle.NARROW, Locale.JAPAN, \"\\u671d\"},\n+            {12, 0, TextStyle.NARROW, Locale.JAPAN, \"\\u6b63\\u5348\"},\n+            {12, 1, TextStyle.NARROW, Locale.JAPAN, \"\\u663c\"},\n+            {18, 0, TextStyle.NARROW, Locale.JAPAN, \"\\u5915\\u65b9\"},\n+            {19, 0, TextStyle.NARROW, Locale.JAPAN, \"\\u591c\"},\n+            {23, 0, TextStyle.NARROW, Locale.JAPAN, \"\\u591c\\u4e2d\"},\n+        };\n+    }\n+    @Test (dataProvider=\"dayPeriodFormat\")\n+    public void test_dayPeriodFormat(int hod, int moh, TextStyle ts, Locale l, String expected) throws Exception {\n+        builder.appendDayPeriodText(ts);\n+        LocalTime t = LocalTime.of(hod, moh);\n+        DateTimeFormatter f = builder.toFormatter().withLocale(l);\n+        assertEquals(f.format(t), expected);\n+    }\n+\n+    @DataProvider(name=\"dayPeriodParse\")\n+    Object[][] data_dayPeriodParse() {\n+        return new Object[][] {\n+                {TextStyle.FULL, Locale.US, 0, 0, \"midnight\"},\n+                {TextStyle.FULL, Locale.US, 1, 30, \"at night\"},\n+                {TextStyle.FULL, Locale.US, 6, 0, \"AM\"},\n+                {TextStyle.FULL, Locale.US, 9, 0, \"in the morning\"},\n+                {TextStyle.FULL, Locale.US, 12, 0, \"noon\"},\n+                {TextStyle.FULL, Locale.US, 15, 0, \"in the afternoon\"},\n+                {TextStyle.FULL, Locale.US, 18, 0, \"PM\"},\n+                {TextStyle.FULL, Locale.US, 19, 30, \"in the evening\"},\n+\n+                {TextStyle.FULL, Locale.JAPAN, 0, 0, \"\\u771f\\u591c\\u4e2d\"},\n+                {TextStyle.FULL, Locale.JAPAN, 1, 30, \"\\u591c\\u4e2d\"},\n+                {TextStyle.FULL, Locale.JAPAN, 6, 0, \"\\u5348\\u524d\"},\n+                {TextStyle.FULL, Locale.JAPAN, 8, 0, \"\\u671d\"},\n+                {TextStyle.FULL, Locale.JAPAN, 12, 0, \"\\u6b63\\u5348\"},\n+                {TextStyle.FULL, Locale.JAPAN, 14, 0, \"\\u663c\"},\n+                {TextStyle.FULL, Locale.JAPAN, 17, 30, \"\\u5915\\u65b9\"},\n+                {TextStyle.FULL, Locale.JAPAN, 18, 0, \"\\u5348\\u5f8c\"},\n+                {TextStyle.FULL, Locale.JAPAN, 21, 0, \"\\u591c\"},\n+\n+                {TextStyle.NARROW, Locale.US, 0, 0, \"mi\"},\n+                {TextStyle.NARROW, Locale.US, 1, 30, \"at night\"},\n+                {TextStyle.NARROW, Locale.US, 6, 0, \"a\"},\n+                {TextStyle.NARROW, Locale.US, 9, 0, \"in the morning\"},\n+                {TextStyle.NARROW, Locale.US, 12, 0, \"n\"},\n+                {TextStyle.NARROW, Locale.US, 15, 0, \"in the afternoon\"},\n+                {TextStyle.NARROW, Locale.US, 18, 0, \"p\"},\n+                {TextStyle.NARROW, Locale.US, 19, 30, \"in the evening\"},\n+\n+                {TextStyle.NARROW, Locale.JAPAN, 0, 0, \"\\u771f\\u591c\\u4e2d\"},\n+                {TextStyle.NARROW, Locale.JAPAN, 1, 30, \"\\u591c\\u4e2d\"},\n+                {TextStyle.NARROW, Locale.JAPAN, 6, 0, \"\\u5348\\u524d\"},\n+                {TextStyle.NARROW, Locale.JAPAN, 8, 0, \"\\u671d\"},\n+                {TextStyle.NARROW, Locale.JAPAN, 12, 0, \"\\u6b63\\u5348\"},\n+                {TextStyle.NARROW, Locale.JAPAN, 14, 0, \"\\u663c\"},\n+                {TextStyle.NARROW, Locale.JAPAN, 17, 30, \"\\u5915\\u65b9\"},\n+                {TextStyle.NARROW, Locale.JAPAN, 18, 0, \"\\u5348\\u5f8c\"},\n+                {TextStyle.NARROW, Locale.JAPAN, 21, 0, \"\\u591c\"},\n+        };\n+    }\n+    @Test (dataProvider=\"dayPeriodParse\")\n+    public void test_dayPeriodParse(TextStyle ts, Locale l, long hod, long moh, String dayPeriod) throws Exception {\n+        builder.appendDayPeriodText(ts);\n+        DateTimeFormatter f = builder.toFormatter().withLocale(l);\n+        var p = f.parse(dayPeriod);\n+        assertEquals(p.getLong(HOUR_OF_DAY), hod);\n+        assertEquals(p.getLong(MINUTE_OF_HOUR), moh);\n+    }\n+\n+    @DataProvider(name=\"dayPeriodParsePattern\")\n+    Object[][] data_dayPeriodParsePattern() {\n+        return new Object[][] {\n+            {\"H B\", \"23 at night\", 23},\n+            {\"H B\", \"3 at night\", 3},\n+            {\"K B\", \"11 at night\", 23},\n+            {\"K B\", \"3 at night\", 3},\n+            {\"K B\", \"11 in the morning\", 11},\n+            {\"h B\", \"11 at night\", 23},\n+            {\"h B\", \"3 at night\", 3},\n+            {\"h B\", \"11 in the morning\", 11},\n+        };\n+    }\n+\n+    @Test (dataProvider=\"dayPeriodParsePattern\")\n+    public void test_dayPeriodParsePattern(String pattern, String hourDayPeriod, long expected) throws Exception {\n+        builder.appendPattern(pattern);\n+        DateTimeFormatter f = builder.toFormatter().withLocale(Locale.US);\n+        var p = f.parse(hourDayPeriod);\n+        assertEquals(p.getLong(HOUR_OF_DAY), expected);\n+    }\n+\n+    @DataProvider(name=\"dayPeriodParseInvalid\")\n+    Object[][] data_dayPeriodParseInvalid() {\n+        return new Object[][] {\n+                {TextStyle.FULL, ResolverStyle.SMART, Locale.US, \"00:01 midnight\", \"00:00\"},\n+                {TextStyle.FULL, ResolverStyle.SMART, Locale.US, \"06:01 at night\", \"21:00-06:00\"},\n+                {TextStyle.FULL, ResolverStyle.SMART, Locale.US, \"05:59 in the morning\", \"06:00-12:00\"},\n+                {TextStyle.FULL, ResolverStyle.SMART, Locale.US, \"11:59 noon\", \"12:00\"},\n+                {TextStyle.FULL, ResolverStyle.SMART, Locale.US, \"18:00 in the afternoon\", \"12:00-18:00\"},\n+                {TextStyle.FULL, ResolverStyle.SMART, Locale.US, \"17:59 in the evening\", \"18:00-21:00\"},\n+                {TextStyle.NARROW, ResolverStyle.SMART, Locale.US, \"00:01 mi\", \"00:00\"},\n+                {TextStyle.NARROW, ResolverStyle.SMART, Locale.US, \"06:01 at night\", \"21:00-06:00\"},\n+                {TextStyle.NARROW, ResolverStyle.SMART, Locale.US, \"05:59 in the morning\", \"06:00-12:00\"},\n+                {TextStyle.NARROW, ResolverStyle.SMART, Locale.US, \"11:59 n\", \"12:00\"},\n+                {TextStyle.NARROW, ResolverStyle.SMART, Locale.US, \"18:00 in the afternoon\", \"12:00-18:00\"},\n+                {TextStyle.NARROW, ResolverStyle.SMART, Locale.US, \"17:59 in the evening\", \"18:00-21:00\"},\n+\n+                {TextStyle.FULL, ResolverStyle.SMART, Locale.JAPAN, \"00:01 \\u771f\\u591c\\u4e2d\", \"00:00\"},\n+                {TextStyle.FULL, ResolverStyle.SMART, Locale.JAPAN, \"04:00 \\u591c\\u4e2d\", \"23:00-04:00\"},\n+                {TextStyle.FULL, ResolverStyle.SMART, Locale.JAPAN, \"03:59 \\u671d\", \"04:00-12:00\"},\n+                {TextStyle.FULL, ResolverStyle.SMART, Locale.JAPAN, \"12:01 \\u6b63\\u5348\", \"12:00\"},\n+                {TextStyle.FULL, ResolverStyle.SMART, Locale.JAPAN, \"16:00 \\u663c\", \"12:00-16:00\"},\n+                {TextStyle.FULL, ResolverStyle.SMART, Locale.JAPAN, \"19:01 \\u5915\\u65b9\", \"16:00-19:00\"},\n+                {TextStyle.FULL, ResolverStyle.SMART, Locale.JAPAN, \"23:00 \\u591c\", \"19:00-23:00\"},\n+                {TextStyle.NARROW, ResolverStyle.SMART, Locale.JAPAN, \"00:01 \\u771f\\u591c\\u4e2d\", \"00:00\"},\n+                {TextStyle.NARROW, ResolverStyle.SMART, Locale.JAPAN, \"04:00 \\u591c\\u4e2d\", \"23:00-04:00\"},\n+                {TextStyle.NARROW, ResolverStyle.SMART, Locale.JAPAN, \"03:59 \\u671d\", \"04:00-12:00\"},\n+                {TextStyle.NARROW, ResolverStyle.SMART, Locale.JAPAN, \"12:01 \\u6b63\\u5348\", \"12:00\"},\n+                {TextStyle.NARROW, ResolverStyle.SMART, Locale.JAPAN, \"16:00 \\u663c\", \"12:00-16:00\"},\n+                {TextStyle.NARROW, ResolverStyle.SMART, Locale.JAPAN, \"19:01 \\u5915\\u65b9\", \"16:00-19:00\"},\n+                {TextStyle.NARROW, ResolverStyle.SMART, Locale.JAPAN, \"23:00 \\u591c\", \"19:00-23:00\"},\n+\n+                {TextStyle.FULL, ResolverStyle.LENIENT, Locale.US, \"00:01 midnight\", \"00:00\"},\n+                {TextStyle.FULL, ResolverStyle.LENIENT, Locale.US, \"06:01 at night\", \"21:00-06:00\"},\n+                {TextStyle.FULL, ResolverStyle.LENIENT, Locale.US, \"05:59 in the morning\", \"06:00-12:00\"},\n+                {TextStyle.FULL, ResolverStyle.LENIENT, Locale.US, \"11:59 noon\", \"12:00\"},\n+                {TextStyle.FULL, ResolverStyle.LENIENT, Locale.US, \"18:00 in the afternoon\", \"12:00-18:00\"},\n+                {TextStyle.FULL, ResolverStyle.LENIENT, Locale.US, \"17:59 in the evening\", \"18:00-21:00\"},\n+                {TextStyle.NARROW, ResolverStyle.LENIENT, Locale.US, \"00:01 mi\", \"00:00\"},\n+                {TextStyle.NARROW, ResolverStyle.LENIENT, Locale.US, \"06:01 at night\", \"21:00-06:00\"},\n+                {TextStyle.NARROW, ResolverStyle.LENIENT, Locale.US, \"05:59 in the morning\", \"06:00-12:00\"},\n+                {TextStyle.NARROW, ResolverStyle.LENIENT, Locale.US, \"11:59 n\", \"12:00\"},\n+                {TextStyle.NARROW, ResolverStyle.LENIENT, Locale.US, \"18:00 in the afternoon\", \"12:00-18:00\"},\n+                {TextStyle.NARROW, ResolverStyle.LENIENT, Locale.US, \"17:59 in the evening\", \"18:00-21:00\"},\n+\n+                {TextStyle.FULL, ResolverStyle.LENIENT, Locale.JAPAN, \"00:01 \\u771f\\u591c\\u4e2d\", \"00:00\"},\n+                {TextStyle.FULL, ResolverStyle.LENIENT, Locale.JAPAN, \"04:00 \\u591c\\u4e2d\", \"23:00-04:00\"},\n+                {TextStyle.FULL, ResolverStyle.LENIENT, Locale.JAPAN, \"03:59 \\u671d\", \"04:00-12:00\"},\n+                {TextStyle.FULL, ResolverStyle.LENIENT, Locale.JAPAN, \"12:01 \\u6b63\\u5348\", \"12:00\"},\n+                {TextStyle.FULL, ResolverStyle.LENIENT, Locale.JAPAN, \"16:00 \\u663c\", \"12:00-16:00\"},\n+                {TextStyle.FULL, ResolverStyle.LENIENT, Locale.JAPAN, \"19:01 \\u5915\\u65b9\", \"16:00-19:00\"},\n+                {TextStyle.FULL, ResolverStyle.LENIENT, Locale.JAPAN, \"23:00 \\u591c\", \"19:00-23:00\"},\n+                {TextStyle.NARROW, ResolverStyle.LENIENT, Locale.JAPAN, \"00:01 \\u771f\\u591c\\u4e2d\", \"00:00\"},\n+                {TextStyle.NARROW, ResolverStyle.LENIENT, Locale.JAPAN, \"04:00 \\u591c\\u4e2d\", \"23:00-04:00\"},\n+                {TextStyle.NARROW, ResolverStyle.LENIENT, Locale.JAPAN, \"03:59 \\u671d\", \"04:00-12:00\"},\n+                {TextStyle.NARROW, ResolverStyle.LENIENT, Locale.JAPAN, \"12:01 \\u6b63\\u5348\", \"12:00\"},\n+                {TextStyle.NARROW, ResolverStyle.LENIENT, Locale.JAPAN, \"16:00 \\u663c\", \"12:00-16:00\"},\n+                {TextStyle.NARROW, ResolverStyle.LENIENT, Locale.JAPAN, \"19:01 \\u5915\\u65b9\", \"16:00-19:00\"},\n+                {TextStyle.NARROW, ResolverStyle.LENIENT, Locale.JAPAN, \"23:00 \\u591c\", \"19:00-23:00\"},\n+        };\n+    }\n+    @Test (dataProvider=\"dayPeriodParseInvalid\")\n+    public void test_dayPeriodParseInvalid(TextStyle ts, ResolverStyle rs, Locale l, String dayPeriod, String periodRange) throws Exception {\n+        try {\n+            builder.append(ISO_LOCAL_TIME).appendLiteral(' ').appendDayPeriodText(ts)\n+                    .toFormatter()\n+                    .withLocale(l)\n+                    .parse(dayPeriod);\n+            if (rs != ResolverStyle.LENIENT) {\n+                throw new RuntimeException(\"DateTimeParseException should be thrown\");\n+            }\n+        } catch (DateTimeParseException e) {\n+            assertEquals(e.getCause().getMessage(),\n+                    \"Conflict found: Resolved time \" + dayPeriod.substring(0, 5) + \" conflicts with \" +\n+                    \"DayPeriod(\" + periodRange + \")\");\n+        }\n+    }\n+\n@@ -795,0 +1011,4 @@\n+\n+            {\"B\", \"DayPeriod(SHORT)\"},\n+            {\"BBBB\", \"DayPeriod(FULL)\"},\n+            {\"BBBBB\", \"DayPeriod(NARROW)\"},\n@@ -870,0 +1090,4 @@\n+\n+            {\"BB\"},\n+            {\"BBB\"},\n+            {\"BBBBBB\"},\n","filename":"test\/jdk\/java\/time\/test\/java\/time\/format\/TestDateTimeFormatterBuilder.java","additions":227,"deletions":3,"binary":false,"changes":230,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,2 +25,2 @@\n- * @bug 8209175\n- * @summary Checks the 'B' character added in the CLDR date-time patterns is\n+ * @bug 8209175 8247781\n+ * @summary Checks the 'B' character added in the CLDR date-time patterns is no longer\n@@ -29,2 +29,2 @@\n- *          for burmese locale in the time patterns. Since it is not supported by\n- *          DateTimeFormatter it is replaced with the 'a' while CLDR resource\n+ *          for burmese locale in the time patterns. Since it is supported by\n+ *          DateTimeFormatter it should not be replaced with the 'a' while CLDR resource\n@@ -59,0 +59,1 @@\n+                \/\/ these messages are for day periods in Burmese.\n@@ -60,1 +61,1 @@\n-                {FORMAT_SHORT_BURMESE, LOCAL_TIME_PM, \"\\u100A\\u1014\\u1031 12:12\"},\n+                {FORMAT_SHORT_BURMESE, LOCAL_TIME_PM, \"\\u1014\\u1031\\u1037\\u101c\\u101a\\u103a 12:12\"},\n@@ -62,1 +63,1 @@\n-                {FORMAT_MEDIUM_BURMESE, LOCAL_TIME_PM, \"\\u100A\\u1014\\u1031 12:12:12\"},\n+                {FORMAT_MEDIUM_BURMESE, LOCAL_TIME_PM, \"\\u1014\\u1031\\u1037\\u101c\\u101a\\u103a 12:12:12\"},\n","filename":"test\/jdk\/java\/time\/test\/java\/time\/format\/TestDayPeriodWithDTF.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8007038\n+ * @bug 8007038 8247781\n@@ -30,0 +30,1 @@\n+ * @modules jdk.localedata\n@@ -31,1 +32,2 @@\n- * @run main Bug8007038\n+ * @run main\/othervm -Djava.locale.providers=COMPAT Bug8007038 COMPAT\n+ * @run main\/othervm -Djava.locale.providers=CLDR Bug8007038 CLDR\n@@ -91,1 +93,2 @@\n-                for (int fieldIdx = AM; fieldIdx <= PM; fieldIdx++) {\n+                int lastIndex = args[0].equals(\"CLDR\") ? 11 : PM;\n+                for (int fieldIdx = AM; fieldIdx <= lastIndex; fieldIdx++) {\n@@ -95,1 +98,1 @@\n-                checkValueRange(calTypes[calIdx], AM_PM, PM+1, LONG, testLocs[locIdx], false);\n+                checkValueRange(calTypes[calIdx], AM_PM, lastIndex+1, LONG, testLocs[locIdx], false);\n","filename":"test\/jdk\/java\/util\/Calendar\/Bug8007038.java","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8000983 8008577\n+ * @bug 8000983 8008577 8247781\n@@ -28,1 +28,2 @@\n- *          and assumes that both JRE and CLDR have the same narrow names.\n+ *          and assumes that both COMPAT and CLDR have the same narrow names if not\n+ *          explicitly specified.\n@@ -30,2 +31,2 @@\n- * @comment Locale providers: JRE,SPI\n- * @run main\/othervm -Djava.locale.providers=JRE,SPI NarrowNamesTest JRE,SPI\n+ * @comment Locale providers: COMPAT,SPI\n+ * @run main\/othervm -Djava.locale.providers=COMPAT,SPI NarrowNamesTest COMPAT,SPI\n@@ -53,2 +54,0 @@\n-    private static String providers;\n-\n@@ -57,1 +56,1 @@\n-        providers = args[0];\n+        String providers = args[0];\n@@ -98,4 +97,22 @@\n-        testMap(US, AM_PM, ALL_STYLES,\n-                \"AM\", \"PM\",\n-                RESET_INDEX,\n-                \"a\", \"p\");\n+        if (providers.startsWith(\"CLDR\")) {\n+            testMap(US, AM_PM, ALL_STYLES,\n+                    \"AM\",\n+                    \"PM\",\n+                    \"midnight\",\n+                    \"noon\",\n+                    \"in the morning\",\n+                    \"\",\n+                    \"in the afternoon\",\n+                    \"\",\n+                    \"in the evening\",\n+                    \"\",\n+                    \"at night\",\n+                    \"\",\n+                    RESET_INDEX,\n+                    \"a\", \"p\", \"mi\", \"n\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\");\n+        } else {\n+            testMap(US, AM_PM, ALL_STYLES,\n+                    \"AM\", \"PM\",\n+                    RESET_INDEX,\n+                    \"a\", \"p\");\n+        }\n@@ -179,2 +196,2 @@\n-            for (int i = 0; i < expected.length; i++) {\n-                if (expected[i].isEmpty()) {\n+            for (String s : expected) {\n+                if (s.isEmpty()) {\n@@ -184,1 +201,1 @@\n-                if (expected[i] == RESET_INDEX) {\n+                if (s == RESET_INDEX) {\n@@ -188,1 +205,1 @@\n-                expectedMap.put(expected[i], index++);\n+                expectedMap.put(s, index++);\n","filename":"test\/jdk\/java\/util\/Calendar\/NarrowNamesTest.java","additions":33,"deletions":16,"binary":false,"changes":49,"status":"modified"}]}