{"files":[{"patch":"@@ -243,0 +243,12 @@\n+static Node* find_or_make_CastII(PhaseIterGVN* igvn, Node* parent, Node* control,\n+                                 const TypeInt* type) {\n+  Node* n = new CastIINode(parent, type);\n+  n->set_req(0, control);\n+  Node* existing = igvn->hash_find_insert(n);\n+  if (existing != NULL) {\n+    n->destruct(igvn);\n+    return existing;\n+  }\n+  return igvn->register_new_node_with_optimizer(n);\n+}\n+\n@@ -249,0 +261,26 @@\n+  PhaseIterGVN *igvn = phase->is_IterGVN();\n+  const TypeInt* this_type = this->type()->is_int();\n+  Node* z = in(1);\n+  const TypeInteger* rx = NULL;\n+  const TypeInteger* ry = NULL;\n+  \/\/ Similar to ConvI2LNode::Ideal() for the same reasons\n+  if (!_range_check_dependency && Compile::push_thru_add(phase, z, this_type, rx, ry, T_INT)) {\n+    if (igvn == NULL) {\n+      \/\/ Postpone this optimization to iterative GVN, where we can handle deep\n+      \/\/ AddI chains without an exponential number of recursive Ideal() calls.\n+      phase->record_for_igvn(this);\n+      return NULL;\n+    }\n+    int op = z->Opcode();\n+    Node* x = z->in(1);\n+    Node* y = z->in(2);\n+\n+    Node* cx = find_or_make_CastII(igvn, x, in(0), rx->is_int());\n+    Node* cy = find_or_make_CastII(igvn, y, in(0), ry->is_int());\n+    switch (op) {\n+      case Op_AddI:  return new AddINode(cx, cy);\n+      case Op_SubI:  return new SubINode(cx, cy);\n+      default:       ShouldNotReachHere();\n+    }\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/castnode.cpp","additions":38,"deletions":0,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -83,0 +83,1 @@\n+class TypeInteger;\n@@ -1174,0 +1175,4 @@\n+\n+  static bool\n+  push_thru_add(PhaseGVN* phase, Node* z, const TypeInteger* tz, const TypeInteger*& rx, const TypeInteger*& ry,\n+                BasicType bt);\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"compile.hpp\"\n@@ -255,1 +256,0 @@\n-#ifdef _LP64\n@@ -262,0 +262,1 @@\n+#ifdef _LP64\n@@ -278,0 +279,74 @@\n+bool Compile::push_thru_add(PhaseGVN* phase, Node* z, const TypeInteger* tz, const TypeInteger*& rx, const TypeInteger*& ry,\n+                            BasicType bt) {\n+  int op = z->Opcode();\n+  if (op == Op_AddI || op == Op_SubI) {\n+    Node* x = z->in(1);\n+    Node* y = z->in(2);\n+    assert (x != z && y != z, \"dead loop in ConvI2LNode::Ideal\");\n+    if (phase->type(x) == Type::TOP) {\n+      return false;\n+    }\n+    if (phase->type(y) == Type::TOP) {\n+      return false;\n+    }\n+    const TypeInt*  tx = phase->type(x)->is_int();\n+    const TypeInt*  ty = phase->type(y)->is_int();\n+\n+    jlong xlo = tx->is_int()->_lo;\n+    jlong xhi = tx->is_int()->_hi;\n+    jlong ylo = ty->is_int()->_lo;\n+    jlong yhi = ty->is_int()->_hi;\n+    jlong zlo = tz->lo_as_long();\n+    jlong zhi = tz->hi_as_long();\n+    jlong vbit = CONST64(1) << BitsPerInt;\n+    int widen =  MAX2(tx->_widen, ty->_widen);\n+    if (op == Op_SubI) {\n+      jlong ylo0 = ylo;\n+      ylo = -yhi;\n+      yhi = -ylo0;\n+    }\n+    \/\/ See if x+y can cause positive overflow into z+2**32\n+    if (long_ranges_overlap(xlo+ylo, xhi+yhi, zlo+vbit, zhi+vbit)) {\n+      return false;\n+    }\n+    \/\/ See if x+y can cause negative overflow into z-2**32\n+    if (long_ranges_overlap(xlo+ylo, xhi+yhi, zlo-vbit, zhi-vbit)) {\n+      return false;\n+    }\n+    \/\/ Now it's always safe to assume x+y does not overflow.\n+    \/\/ This is true even if some pairs x,y might cause overflow, as long\n+    \/\/ as that overflow value cannot fall into [zlo,zhi].\n+\n+    \/\/ Confident that the arithmetic is \"as if infinite precision\",\n+    \/\/ we can now use z's range to put constraints on those of x and y.\n+    \/\/ The \"natural\" range of x [xlo,xhi] can perhaps be narrowed to a\n+    \/\/ more \"restricted\" range by intersecting [xlo,xhi] with the\n+    \/\/ range obtained by subtracting y's range from the asserted range\n+    \/\/ of the I2L conversion.  Here's the interval arithmetic algebra:\n+    \/\/    x == z-y == [zlo,zhi]-[ylo,yhi] == [zlo,zhi]+[-yhi,-ylo]\n+    \/\/    => x in [zlo-yhi, zhi-ylo]\n+    \/\/    => x in [zlo-yhi, zhi-ylo] INTERSECT [xlo,xhi]\n+    \/\/    => x in [xlo MAX zlo-yhi, xhi MIN zhi-ylo]\n+    jlong rxlo = MAX2(xlo, zlo - yhi);\n+    jlong rxhi = MIN2(xhi, zhi - ylo);\n+    \/\/ And similarly, x changing place with y:\n+    jlong rylo = MAX2(ylo, zlo - xhi);\n+    jlong ryhi = MIN2(yhi, zhi - xlo);\n+    if (rxlo > rxhi || rylo > ryhi) {\n+      return false;  \/\/ x or y is dying; don't mess w\/ it\n+    }\n+    if (op == Op_SubI) {\n+      jlong rylo0 = rylo;\n+      rylo = -ryhi;\n+      ryhi = -rylo0;\n+    }\n+    assert(rxlo == (int)rxlo && rxhi == (int)rxhi, \"x should not overflow\");\n+    assert(rylo == (int)rylo && ryhi == (int)ryhi, \"y should not overflow\");\n+    rx = TypeInteger::make(rxlo, rxhi, widen, bt);\n+    ry = TypeInteger::make(rylo, ryhi, widen, bt);\n+    return true;\n+  }\n+  return false;\n+}\n+\n+\n@@ -351,2 +426,3 @@\n-  int op = z->Opcode();\n-  if (op == Op_AddI || op == Op_SubI) {\n+  const TypeInteger* rx = NULL;\n+  const TypeInteger* ry = NULL;\n+  if (Compile::push_thru_add(phase, z, this_type, rx, ry, T_LONG)) {\n@@ -359,0 +435,1 @@\n+    int op = z->Opcode();\n@@ -361,30 +438,0 @@\n-    assert (x != z && y != z, \"dead loop in ConvI2LNode::Ideal\");\n-    if (phase->type(x) == Type::TOP)  return this_changed;\n-    if (phase->type(y) == Type::TOP)  return this_changed;\n-    const TypeInt*  tx = phase->type(x)->is_int();\n-    const TypeInt*  ty = phase->type(y)->is_int();\n-    const TypeLong* tz = this_type;\n-    jlong xlo = tx->_lo;\n-    jlong xhi = tx->_hi;\n-    jlong ylo = ty->_lo;\n-    jlong yhi = ty->_hi;\n-    jlong zlo = tz->_lo;\n-    jlong zhi = tz->_hi;\n-    jlong vbit = CONST64(1) << BitsPerInt;\n-    int widen =  MAX2(tx->_widen, ty->_widen);\n-    if (op == Op_SubI) {\n-      jlong ylo0 = ylo;\n-      ylo = -yhi;\n-      yhi = -ylo0;\n-    }\n-    \/\/ See if x+y can cause positive overflow into z+2**32\n-    if (long_ranges_overlap(xlo+ylo, xhi+yhi, zlo+vbit, zhi+vbit)) {\n-      return this_changed;\n-    }\n-    \/\/ See if x+y can cause negative overflow into z-2**32\n-    if (long_ranges_overlap(xlo+ylo, xhi+yhi, zlo-vbit, zhi-vbit)) {\n-      return this_changed;\n-    }\n-    \/\/ Now it's always safe to assume x+y does not overflow.\n-    \/\/ This is true even if some pairs x,y might cause overflow, as long\n-    \/\/ as that overflow value cannot fall into [zlo,zhi].\n@@ -392,27 +439,2 @@\n-    \/\/ Confident that the arithmetic is \"as if infinite precision\",\n-    \/\/ we can now use z's range to put constraints on those of x and y.\n-    \/\/ The \"natural\" range of x [xlo,xhi] can perhaps be narrowed to a\n-    \/\/ more \"restricted\" range by intersecting [xlo,xhi] with the\n-    \/\/ range obtained by subtracting y's range from the asserted range\n-    \/\/ of the I2L conversion.  Here's the interval arithmetic algebra:\n-    \/\/    x == z-y == [zlo,zhi]-[ylo,yhi] == [zlo,zhi]+[-yhi,-ylo]\n-    \/\/    => x in [zlo-yhi, zhi-ylo]\n-    \/\/    => x in [zlo-yhi, zhi-ylo] INTERSECT [xlo,xhi]\n-    \/\/    => x in [xlo MAX zlo-yhi, xhi MIN zhi-ylo]\n-    jlong rxlo = MAX2(xlo, zlo - yhi);\n-    jlong rxhi = MIN2(xhi, zhi - ylo);\n-    \/\/ And similarly, x changing place with y:\n-    jlong rylo = MAX2(ylo, zlo - xhi);\n-    jlong ryhi = MIN2(yhi, zhi - xlo);\n-    if (rxlo > rxhi || rylo > ryhi) {\n-      return this_changed;  \/\/ x or y is dying; don't mess w\/ it\n-    }\n-    if (op == Op_SubI) {\n-      jlong rylo0 = rylo;\n-      rylo = -ryhi;\n-      ryhi = -rylo0;\n-    }\n-    assert(rxlo == (int)rxlo && rxhi == (int)rxhi, \"x should not overflow\");\n-    assert(rylo == (int)rylo && ryhi == (int)ryhi, \"y should not overflow\");\n-    Node* cx = find_or_make_convI2L(igvn, x, TypeLong::make(rxlo, rxhi, widen));\n-    Node* cy = find_or_make_convI2L(igvn, y, TypeLong::make(rylo, ryhi, widen));\n+    Node* cx = find_or_make_convI2L(igvn, x, rx->is_long());\n+    Node* cy = find_or_make_convI2L(igvn, y, ry->is_long());\n","filename":"src\/hotspot\/share\/opto\/convertnode.cpp","additions":82,"deletions":60,"binary":false,"changes":142,"status":"modified"},{"patch":"@@ -2409,0 +2409,1 @@\n+  exp = exp->uncast();\n@@ -2417,1 +2418,1 @@\n-    if (exp->in(1) == iv && exp->in(2)->is_Con()) {\n+    if (exp->in(1)->uncast() == iv && exp->in(2)->is_Con()) {\n@@ -2423,1 +2424,1 @@\n-    if (exp->in(2) == iv && exp->in(1)->is_Con()) {\n+    if (exp->in(2)->uncast() == iv && exp->in(1)->is_Con()) {\n@@ -2430,1 +2431,1 @@\n-    if (exp->in(1) == iv && exp->in(2)->is_Con()) {\n+    if (exp->in(1)->uncast() == iv && exp->in(2)->is_Con()) {\n@@ -2451,0 +2452,1 @@\n+  exp = exp->uncast();\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -59,2 +59,2 @@\n-  if (n->Opcode() == Op_CastII && n->as_CastII()->has_range_check() &&\n-      region->is_CountedLoop() && n->in(1) == region->as_CountedLoop()->phi()) {\n+  if (n->Opcode() == Op_CastII && region->is_CountedLoop() &&\n+      n->in(1) == region->as_CountedLoop()->phi()) {\n@@ -1118,1 +1118,1 @@\n-        if (m->is_CastII() && m->isa_CastII()->has_range_check()) {\n+        if (m->is_CastII()) {\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,202 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.conversions;\n+\n+import java.util.Objects;\n+import java.util.Random;\n+import jdk.test.lib.Asserts;\n+\n+\/*\n+ * @test\n+ * @bug 8254317\n+ * @requires vm.compiler2.enabled\n+ * @summary Exercises the optimization that moves integer-to-long conversions\n+ *          upwards through different shapes of integer addition\n+ *          subgraphs. Contains three small functional tests and two stress\n+ *          tests that resulted in a compilation time and memory explosion\n+ *          before fixing bug 8254317. The stress tests run with -Xbatch to wait\n+ *          for C2, so that a timeout or an out-of-memory error is triggered if\n+ *          there was an explosion. These tests use a timeout of 30s to catch\n+ *          the explosion earlier.\n+ * @library \/test\/lib \/\n+ * @run main\/othervm\n+ *      compiler.conversions.TestMoveConvI2LOrCastIIThruAddIs functional\n+ * @run main\/othervm\/timeout=30 -Xbatch\n+ *      compiler.conversions.TestMoveConvI2LOrCastIIThruAddIs stress1\n+ * @run main\/othervm\/timeout=30 -Xbatch\n+ *      compiler.conversions.TestMoveConvI2LOrCastIIThruAddIs stress2\n+ * @run main\/othervm\/timeout=30 -Xbatch\n+ *      compiler.conversions.TestMoveConvI2LOrCastIIThruAddIs stress3\n+ * @run main\/othervm\/timeout=30 -Xbatch\n+ *      compiler.conversions.TestMoveConvI2LOrCastIIThruAddIs stress4\n+ *\/\n+\n+public class TestMoveConvI2LOrCastIIThruAddIs {\n+\n+    \/\/ Number of repetitions of each test. Should be sufficiently large for the\n+    \/\/ method under test to be compiled with C2.\n+    static final int N = 100_000;\n+\n+    \/\/ Chain-shaped functional test.\n+    static long testChain(boolean cnd) {\n+        int a = cnd ? 1 : 2;\n+        int b = a + a;\n+        int c = b + b;\n+        int d = c + c;\n+        return d;\n+    }\n+\n+    \/\/ Tree-shaped functional test.\n+    static long testTree(boolean cnd) {\n+        int a0 = cnd ? 1 : 2;\n+        int a1 = cnd ? 1 : 2;\n+        int a2 = cnd ? 1 : 2;\n+        int a3 = cnd ? 1 : 2;\n+        int a4 = cnd ? 1 : 2;\n+        int a5 = cnd ? 1 : 2;\n+        int a6 = cnd ? 1 : 2;\n+        int a7 = cnd ? 1 : 2;\n+        int b0 = a0 + a1;\n+        int b1 = a2 + a3;\n+        int b2 = a4 + a5;\n+        int b3 = a6 + a7;\n+        int c0 = b0 + b1;\n+        int c1 = b2 + b3;\n+        int d = c0 + c1;\n+        return d;\n+    }\n+\n+    \/\/ DAG-shaped functional test.\n+    static long testDAG(boolean cnd) {\n+        int a0 = cnd ? 1 : 2;\n+        int a1 = cnd ? 1 : 2;\n+        int a2 = cnd ? 1 : 2;\n+        int a3 = cnd ? 1 : 2;\n+        int b0 = a0 + a1;\n+        int b1 = a1 + a2;\n+        int b2 = a2 + a3;\n+        int c0 = b0 + b1;\n+        int c1 = b1 + b2;\n+        int d = c0 + c1;\n+        return d;\n+    }\n+\n+    \/\/ Chain-shaped stress test. Before fixing bug 8254317, this test would\n+    \/\/ result in an out-of-memory error after minutes running.\n+    static long testStress1(boolean cnd) {\n+        \/\/ C2 infers a finite, small value range for a. Note that there are\n+        \/\/ different ways to achieve this, for example a might take the value of\n+        \/\/ the induction variable in an outer counted loop.\n+        int a = cnd ? 1 : 2;\n+        \/\/ C2 fully unrolls this loop, creating a long chain of AddIs.\n+        for (int i = 0; i < 28; i++) {\n+            a = a + a;\n+        }\n+        \/\/ C2 places a ConvI2L at the end of the AddI chain.\n+        return a;\n+    }\n+\n+    \/\/ DAG-shaped stress test. Before fixing bug 8254317, this test would result\n+    \/\/ in an out-of-memory error after minutes running.\n+    static long testStress2(boolean cnd) {\n+        int a = cnd ? 1 : 2;\n+        int b = a;\n+        int c = a + a;\n+        for (int i = 0; i < 20; i++) {\n+            b = b + c;\n+            c = b + c;\n+        }\n+        int d = b + c;\n+        return d;\n+    }\n+\n+    \/\/ Same as testStress1 for CastII\n+    static long testStress3(int a) {\n+        Objects.checkIndex(a, 2);\n+        for (int i = 0; i < 28; i++) {\n+            a = a + a;\n+        }\n+        return Objects.checkIndex(a, 2);\n+    }\n+\n+    \/\/ Same as testStress2 for CastII\n+    static long testStress4(int a) {\n+        a = Objects.checkIndex(a, 2);\n+        int b = a;\n+        int c = a + a;\n+        for (int i = 0; i < 20; i++) {\n+            b = b + c;\n+            c = b + c;\n+        }\n+        int d = b + c;\n+        return Objects.checkIndex(d, 2);\n+    }\n+\n+    public static void main(String[] args) {\n+        \/\/ We use a random number generator to avoid constant propagation in C2\n+        \/\/ and produce a variable (\"a\" in the different tests) with a finite,\n+        \/\/ small value range.\n+        Random rnd = new Random();\n+        switch(args[0]) {\n+        case \"functional\":\n+            \/\/ Small, functional tests.\n+            for (int i = 0; i < N; i++) {\n+                boolean cnd = rnd.nextBoolean();\n+                Asserts.assertEQ(testChain(cnd), cnd ? 8L : 16L);\n+                Asserts.assertEQ(testTree(cnd), cnd ? 8L : 16L);\n+                Asserts.assertEQ(testDAG(cnd), cnd ? 8L : 16L);\n+            }\n+            break;\n+        case \"stress1\":\n+            \/\/ Chain-shaped stress test.\n+            for (int i = 0; i < N; i++) {\n+                boolean cnd = rnd.nextBoolean();\n+                Asserts.assertEQ(testStress1(cnd),\n+                                 cnd ? 268435456L : 536870912L);\n+            }\n+            break;\n+        case \"stress2\":\n+            \/\/ DAG-shaped stress test.\n+            for (int i = 0; i < N; i++) {\n+                boolean cnd = rnd.nextBoolean();\n+                Asserts.assertEQ(testStress2(cnd),\n+                                 cnd ? 701408733L : 1402817466L);\n+            }\n+            break;\n+        case \"stress3\":\n+            for (int i = 0; i < N; i++) {\n+                testStress3(0);\n+            }\n+            break;\n+        case \"stress4\":\n+            \/\/ DAG-shaped stress test.\n+            for (int i = 0; i < N; i++) {\n+                testStress4(0);\n+            }\n+            break;\n+        default:\n+            System.out.println(\"invalid mode\");\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/conversions\/TestMoveConvI2LOrCastIIThruAddIs.java","additions":202,"deletions":0,"binary":false,"changes":202,"status":"added"},{"patch":"@@ -1,164 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package compiler.conversions;\n-\n-import java.util.Random;\n-import jdk.test.lib.Asserts;\n-\n-\/*\n- * @test\n- * @bug 8254317\n- * @requires vm.compiler2.enabled\n- * @summary Exercises the optimization that moves integer-to-long conversions\n- *          upwards through different shapes of integer addition\n- *          subgraphs. Contains three small functional tests and two stress\n- *          tests that resulted in a compilation time and memory explosion\n- *          before fixing bug 8254317. The stress tests run with -Xbatch to wait\n- *          for C2, so that a timeout or an out-of-memory error is triggered if\n- *          there was an explosion. These tests use a timeout of 30s to catch\n- *          the explosion earlier.\n- * @library \/test\/lib \/\n- * @run main\/othervm\n- *      compiler.conversions.TestMoveConvI2LThroughAddIs functional\n- * @run main\/othervm\/timeout=30 -Xbatch\n- *      compiler.conversions.TestMoveConvI2LThroughAddIs stress1\n- * @run main\/othervm\/timeout=30 -Xbatch\n- *      compiler.conversions.TestMoveConvI2LThroughAddIs stress2\n- *\/\n-\n-public class TestMoveConvI2LThroughAddIs {\n-\n-    \/\/ Number of repetitions of each test. Should be sufficiently large for the\n-    \/\/ method under test to be compiled with C2.\n-    static final int N = 100_000;\n-\n-    \/\/ Chain-shaped functional test.\n-    static long testChain(boolean cnd) {\n-        int a = cnd ? 1 : 2;\n-        int b = a + a;\n-        int c = b + b;\n-        int d = c + c;\n-        return d;\n-    }\n-\n-    \/\/ Tree-shaped functional test.\n-    static long testTree(boolean cnd) {\n-        int a0 = cnd ? 1 : 2;\n-        int a1 = cnd ? 1 : 2;\n-        int a2 = cnd ? 1 : 2;\n-        int a3 = cnd ? 1 : 2;\n-        int a4 = cnd ? 1 : 2;\n-        int a5 = cnd ? 1 : 2;\n-        int a6 = cnd ? 1 : 2;\n-        int a7 = cnd ? 1 : 2;\n-        int b0 = a0 + a1;\n-        int b1 = a2 + a3;\n-        int b2 = a4 + a5;\n-        int b3 = a6 + a7;\n-        int c0 = b0 + b1;\n-        int c1 = b2 + b3;\n-        int d = c0 + c1;\n-        return d;\n-    }\n-\n-    \/\/ DAG-shaped functional test.\n-    static long testDAG(boolean cnd) {\n-        int a0 = cnd ? 1 : 2;\n-        int a1 = cnd ? 1 : 2;\n-        int a2 = cnd ? 1 : 2;\n-        int a3 = cnd ? 1 : 2;\n-        int b0 = a0 + a1;\n-        int b1 = a1 + a2;\n-        int b2 = a2 + a3;\n-        int c0 = b0 + b1;\n-        int c1 = b1 + b2;\n-        int d = c0 + c1;\n-        return d;\n-    }\n-\n-    \/\/ Chain-shaped stress test. Before fixing bug 8254317, this test would\n-    \/\/ result in an out-of-memory error after minutes running.\n-    static long testStress1(boolean cnd) {\n-        \/\/ C2 infers a finite, small value range for a. Note that there are\n-        \/\/ different ways to achieve this, for example a might take the value of\n-        \/\/ the induction variable in an outer counted loop.\n-        int a = cnd ? 1 : 2;\n-        \/\/ C2 fully unrolls this loop, creating a long chain of AddIs.\n-        for (int i = 0; i < 28; i++) {\n-            a = a + a;\n-        }\n-        \/\/ C2 places a ConvI2L at the end of the AddI chain.\n-        return a;\n-    }\n-\n-    \/\/ DAG-shaped stress test. Before fixing bug 8254317, this test would result\n-    \/\/ in an out-of-memory error after minutes running.\n-    static long testStress2(boolean cnd) {\n-        int a = cnd ? 1 : 2;\n-        int b = a;\n-        int c = a + a;\n-        for (int i = 0; i < 20; i++) {\n-            b = b + c;\n-            c = b + c;\n-        }\n-        int d = b + c;\n-        return d;\n-    }\n-\n-    public static void main(String[] args) {\n-        \/\/ We use a random number generator to avoid constant propagation in C2\n-        \/\/ and produce a variable (\"a\" in the different tests) with a finite,\n-        \/\/ small value range.\n-        Random rnd = new Random();\n-        switch(args[0]) {\n-        case \"functional\":\n-            \/\/ Small, functional tests.\n-            for (int i = 0; i < N; i++) {\n-                boolean cnd = rnd.nextBoolean();\n-                Asserts.assertEQ(testChain(cnd), cnd ? 8L : 16L);\n-                Asserts.assertEQ(testTree(cnd), cnd ? 8L : 16L);\n-                Asserts.assertEQ(testDAG(cnd), cnd ? 8L : 16L);\n-            }\n-            break;\n-        case \"stress1\":\n-            \/\/ Chain-shaped stress test.\n-            for (int i = 0; i < N; i++) {\n-                boolean cnd = rnd.nextBoolean();\n-                Asserts.assertEQ(testStress1(cnd),\n-                                 cnd ? 268435456L : 536870912L);\n-            }\n-            break;\n-        case \"stress2\":\n-            \/\/ DAG-shaped stress test.\n-            for (int i = 0; i < N; i++) {\n-                boolean cnd = rnd.nextBoolean();\n-                Asserts.assertEQ(testStress2(cnd),\n-                                 cnd ? 701408733L : 1402817466L);\n-            }\n-            break;\n-        default:\n-            System.out.println(\"invalid mode\");\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/conversions\/TestMoveConvI2LThroughAddIs.java","additions":0,"deletions":164,"binary":false,"changes":164,"status":"deleted"}]}