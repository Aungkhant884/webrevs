{"files":[{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"make\/test\/BuildMicrobenchmark.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"make\/test\/JtregNativeHotspot.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/cpu\/aarch64\/abstractInterpreter_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRGenerator_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/shared\/barrierSetAssembler_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/shared\/barrierSetAssembler_aarch64.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/shared\/barrierSetNMethod_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/z\/zBarrierSetAssembler_aarch64.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/cpu\/aarch64\/javaFrameAnchor_aarch64.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/cpu\/aarch64\/nativeInst_aarch64.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/cpu\/aarch64\/registerMap_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/cpu\/aarch64\/templateTable_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/cpu\/arm\/c1_LIRGenerator_arm.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/cpu\/arm\/nativeInst_arm_32.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/cpu\/arm\/registerMap_arm.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/cpu\/arm\/stubGenerator_arm.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/cpu\/arm\/templateInterpreterGenerator_arm.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/cpu\/ppc\/c1_LIRGenerator_ppc.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/cpu\/ppc\/nativeInst_ppc.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/cpu\/ppc\/registerMap_ppc.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/cpu\/ppc\/templateInterpreterGenerator_ppc.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/cpu\/riscv\/c1_LIRGenerator_riscv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/cpu\/riscv\/frame_riscv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/cpu\/riscv\/frame_riscv.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/cpu\/riscv\/frame_riscv.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/cpu\/riscv\/gc\/shared\/barrierSetNMethod_riscv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/cpu\/riscv\/nativeInst_riscv.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/cpu\/riscv\/registerMap_riscv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/cpu\/riscv\/stubGenerator_riscv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/cpu\/riscv\/templateInterpreterGenerator_riscv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/cpu\/s390\/c1_LIRGenerator_s390.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/cpu\/s390\/nativeInst_s390.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/cpu\/s390\/registerMap_s390.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/cpu\/s390\/templateInterpreterGenerator_s390.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRGenerator_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/cpu\/x86\/gc\/g1\/g1BarrierSetAssembler_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shared\/barrierSetNMethod_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/cpu\/x86\/javaFrameAnchor_x86.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/cpu\/x86\/nativeInst_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/cpu\/x86\/nativeInst_x86.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/cpu\/x86\/registerMap_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_32.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/cpu\/x86\/stubRoutines_x86.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/cpu\/x86\/templateInterpreterGenerator_x86_64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/cpu\/x86\/templateTable_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/cpu\/zero\/nativeInst_zero.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/cpu\/zero\/registerMap_zero.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/cpu\/zero\/stubGenerator_zero.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/c1\/c1_CodeStubs.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/c1\/c1_Compilation.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/cds\/cppVtables.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/ci\/ciEnv.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/ci\/ciMethod.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1174,0 +1174,3 @@\n+  static inline uint8_t flags_acquire(oop chunk);\n+  static inline void release_set_flags(oop chunk, uint8_t value);\n+  static inline bool try_set_flags(oop chunk, uint8_t expected_value, uint8_t new_value);\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -353,0 +353,12 @@\n+inline uint8_t jdk_internal_vm_StackChunk::flags_acquire(oop chunk) {\n+  return Atomic::load_acquire(chunk->field_addr<uint8_t>(_flags_offset));\n+}\n+\n+inline void jdk_internal_vm_StackChunk::release_set_flags(oop chunk, uint8_t value) {\n+  Atomic::release_store(chunk->field_addr<uint8_t>(_flags_offset), value);\n+}\n+\n+inline bool jdk_internal_vm_StackChunk::try_set_flags(oop chunk, uint8_t expected_value, uint8_t new_value) {\n+  return Atomic::cmpxchg(chunk->field_addr<uint8_t>(_flags_offset), expected_value, new_value) == expected_value;\n+}\n+\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.inline.hpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/code\/codeBlob.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/code\/codeBlob.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/code\/codeCache.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/code\/compiledIC.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/code\/compiledMethod.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/code\/compiledMethod.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/code\/relocInfo.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/compiler\/oopMap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/compiler\/oopMap.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/compiler\/oopMap.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BarrierSet.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CodeBlobClosure.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCCompactTask.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCMarkTask.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCOopClosures.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCOopClosures.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelScavengeHeap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelScavengeHeap.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/gc\/parallel\/psScavenge.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/gc\/serial\/markSweep.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/gc\/serial\/markSweep.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/gc\/serial\/serialHeap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/gc\/shared\/barrierSet.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/gc\/shared\/barrierSet.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/gc\/shared\/barrierSetNMethod.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,3 +40,1 @@\n-  if (!chunk->is_gc_mode()) {\n-    chunk->relativize_derived_oops();\n-  }\n+  chunk->relativize_derived_pointers_concurrently();\n","filename":"src\/hotspot\/share\/gc\/shared\/continuationGCSupport.inline.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/gc\/shared\/gcCause.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/gc\/shared\/genCollectedHeap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/gc\/shared\/genCollectedHeap.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/gc\/shared\/genOopClosures.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/gc\/shared\/generation.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/gc\/shared\/memAllocator.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/gc\/shared\/memAllocator.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/gc\/shared\/space.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -181,0 +181,1 @@\n+  assert(ZResurrection::is_blocked(), \"This operation is only valid when resurrection is blocked\");\n@@ -187,0 +188,1 @@\n+  assert(ZResurrection::is_blocked(), \"This operation is only valid when resurrection is blocked\");\n","filename":"src\/hotspot\/share\/gc\/z\/zBarrier.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"code\/codeCache.hpp\"\n@@ -34,0 +35,1 @@\n+#include \"runtime\/continuation.hpp\"\n@@ -333,2 +335,1 @@\n-  \/\/ This operation is only valid when resurrection is blocked.\n-  assert(ZResurrection::is_blocked(), \"Invalid phase\");\n+  assert(ZResurrection::is_blocked(), \"This operation is only valid when resurrection is blocked\");\n@@ -340,2 +341,1 @@\n-  \/\/ This operation is only valid when resurrection is blocked.\n-  assert(ZResurrection::is_blocked(), \"Invalid phase\");\n+  assert(ZResurrection::is_blocked(), \"This operation is only valid when resurrection is blocked\");\n@@ -347,2 +347,8 @@\n-  \/\/ This operation is only valid when resurrection is blocked.\n-  assert(ZResurrection::is_blocked(), \"Invalid phase\");\n+  \/\/ The keep alive operation is only valid when resurrection is blocked.\n+  \/\/\n+  \/\/ Except with Loom, where we intentionally trigger arms nmethods after\n+  \/\/ unlinking, to get a sense of what nmethods are alive. This will trigger\n+  \/\/ the keep alive barriers, but the oops are healed and the slow-paths\n+  \/\/ will not trigger. We have stronger checks in the slow-paths.\n+  assert(ZResurrection::is_blocked() || (Continuations::enabled() && CodeCache::contains((void*)p)),\n+         \"This operation is only valid when resurrection is blocked\");\n","filename":"src\/hotspot\/share\/gc\/z\/zBarrier.inline.hpp","additions":12,"deletions":6,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/gc\/z\/zBarrierSetNMethod.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/gc\/z\/zDriver.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/gc\/z\/zHeap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/gc\/z\/zHeap.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/gc\/z\/zHeapIterator.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/gc\/z\/zMark.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,0 +46,1 @@\n+#include \"runtime\/continuation.hpp\"\n@@ -341,1 +342,8 @@\n-      ZNMethod::arm(nm, 0);\n+\n+      if (Continuations::enabled()) {\n+        \/\/ Loom needs to know about visited nmethods. Arm the nmethods to get\n+        \/\/ mark_as_maybe_on_continuation() callbacks when they are used again.\n+        ZNMethod::arm(nm, 0);\n+      } else {\n+        ZNMethod::disarm(nm);\n+      }\n","filename":"src\/hotspot\/share\/gc\/z\/zNMethod.cpp","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/gc\/z\/zVerify.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/interpreter\/abstractInterpreter.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/interpreter\/abstractInterpreter.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/interpreter\/bytecodeTracer.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -1123,1 +1123,1 @@\n-    JvmtiExport::check_suspend_at_safepoint(current);\n+    JvmtiExport::check_vthread_and_suspend_at_safepoint(current);\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/interpreter\/linkResolver.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/interpreter\/linkResolver.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/interpreter\/oopMapCache.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/interpreter\/templateInterpreterGenerator.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/interpreter\/templateInterpreterGenerator.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJniMethodRegistration.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/checkpoint\/eventEmitter.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/checkpoint\/objectSampleCheckpoint.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/sampling\/objectSample.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/sampling\/objectSample.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/sampling\/objectSampler.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4,1 +4,1 @@\n- Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/jfr\/metadata\/metadata.xml","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/jfr\/periodic\/jfrThreadCPULoadEvent.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-* Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+* Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrEpochSynchronization.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/jfr\/writers\/jfrWriterHost.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCodeInstaller.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCodeInstaller.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/memory\/iterator.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/memory\/iterator.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/memory\/iterator.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/oops\/accessBackend.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/oops\/accessBackend.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/oops\/constMethod.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/oops\/constantPool.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/oops\/cpCache.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/oops\/cpCache.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/oops\/cpCache.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/oops\/instanceClassLoaderKlass.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -148,0 +148,7 @@\n+  if (UseZGC || UseShenandoahGC) {\n+    \/\/ An OopClosure could apply barriers to a stack chunk. The side effects\n+    \/\/ of the load barriers could destroy derived pointers, which must be\n+    \/\/ processed before their base oop is processed. So we force processing\n+    \/\/ of derived pointers before applying the closures.\n+    chunk->relativize_derived_pointers_concurrently();\n+  }\n","filename":"src\/hotspot\/share\/oops\/instanceStackChunkKlass.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/oops\/objArrayOop.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/oops\/oop.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/oops\/oop.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/oops\/oop.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/oops\/oopsHierarchy.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,6 +38,0 @@\n-#if INCLUDE_SHENANDOAHGC\n-#include \"gc\/shenandoah\/shenandoahHeap.inline.hpp\"\n-#endif\n-#if INCLUDE_ZGC\n-#include \"gc\/z\/zAddress.inline.hpp\"\n-#endif\n@@ -113,43 +107,0 @@\n-\/\/ The high-order bit tagging has only been verified to work on these platforms.\n-#if (defined(X86) && defined(_LP64)) || defined(AARCH64)\n-#define HIGH_ORDER_BIT_TAGGING_SUPPORTED\n-#endif\n-\n-\/\/ We use the high-order (sign) bit to tag derived oop offsets.\n-\/\/ However, we cannot rely on simple nagation, as offsets could hypothetically be zero or even negative\n-\n-static inline bool is_derived_oop_offset(intptr_t value) {\n-  return value < 0;\n-}\n-\n-#ifdef HIGH_ORDER_BIT_TAGGING_SUPPORTED\n-static const intptr_t OFFSET_MAX = (intptr_t)((uintptr_t)1 << 35); \/\/ 32 bit offset + 3 for jlong (offset in bytes)\n-static const intptr_t OFFSET_MIN = -OFFSET_MAX - 1;\n-#endif\n-\n-static inline intptr_t tag_derived_oop_offset(intptr_t untagged) {\n-#ifdef HIGH_ORDER_BIT_TAGGING_SUPPORTED\n-  assert(untagged <= OFFSET_MAX, \"\");\n-  assert(untagged >= OFFSET_MIN, \"\");\n-  intptr_t tagged = (intptr_t)((uintptr_t)untagged | ((uintptr_t)1 << (BitsPerWord-1)));\n-  assert(is_derived_oop_offset(tagged), \"\");\n-  return tagged;\n-#else\n-  Unimplemented();\n-  return 0;\n-#endif\n-}\n-\n-static inline intptr_t untag_derived_oop_offset(intptr_t tagged) {\n-#ifdef HIGH_ORDER_BIT_TAGGING_SUPPORTED\n-  assert(is_derived_oop_offset(tagged), \"\");\n-  intptr_t untagged = (intptr_t)((uintptr_t)tagged << 1) >> 1;  \/\/ unsigned left shift; signed right shift\n-  assert(untagged <= OFFSET_MAX, \"\");\n-  assert(untagged >= OFFSET_MIN, \"\");\n-  return untagged;\n-#else\n-  Unimplemented();\n-  return 0;\n-#endif\n-}\n-\n@@ -179,2 +130,1 @@\n-\/\/ We replace derived oops with offsets; the converse is done in DerelativizeDerivedOopClosure\n-class RelativizeDerivedOopClosure : public DerivedOopClosure {\n+class DerivedPointersSupport {\n@@ -182,6 +132,2 @@\n-  virtual void do_derived_oop(oop* base_loc, derived_pointer* derived_loc) override {\n-    \/\/ The ordering in the following is crucial\n-    OrderAccess::loadload();\n-\n-    \/\/ Read the base value once and use it for all calculations below\n-    oop base = Atomic::load((oop*)base_loc);\n+  static void relativize(oop* base_loc, derived_pointer* derived_loc) {\n+    oop base = *base_loc;\n@@ -191,28 +137,4 @@\n-    assert(!CompressedOops::is_base(base), \"\");\n-\n-#if INCLUDE_ZGC\n-    if (UseZGC) {\n-      \/\/ This closure can be concurrently called from both GC marking and from\n-      \/\/ the mutator. For it to work it is important that the old base value is\n-      \/\/ used for the offset calculation below. As soon at the base oop has\n-      \/\/ been updated we must *not* proceed to run the code below this check.\n-      \/\/\n-      \/\/ This code only works if there's only one possible transition from old\n-      \/\/ to good. This isn't necessarily for oops when objects are marked from\n-      \/\/ finalizers. In that case oops can go from old to finalizable_marked\n-      \/\/ to good. This breaks this check, because finalizable_marked are not\n-      \/\/ considered good, but it's also not the old value. To workaround this\n-      \/\/ we upgrade finalizable marking through stack chunks to be strong\n-      \/\/ marking. See: ZMark::follow_object.\n-      if (ZAddress::is_good(cast_from_oop<uintptr_t>(base))) {\n-        return;\n-      }\n-    }\n-#endif\n-#if INCLUDE_SHENANDOAHGC\n-    if (UseShenandoahGC) {\n-      if (!ShenandoahHeap::heap()->in_collection_set(base)) {\n-        return;\n-      }\n-    }\n-#endif\n+    assert(!UseCompressedOops || !CompressedOops::is_base(base), \"\");\n+\n+    \/\/ This is always a full derived pointer\n+    uintptr_t derived_int_val = *(uintptr_t*)derived_loc;\n@@ -220,2 +142,4 @@\n-    OrderAccess::loadload();\n-    intptr_t derived_int_val = Atomic::load((intptr_t*)derived_loc);\n+    \/\/ Make the pointer an offset (relativize) and store it at the same location\n+    uintptr_t offset = derived_int_val - cast_from_oop<uintptr_t>(base);\n+    *(uintptr_t*)derived_loc = offset;\n+  }\n@@ -223,2 +147,3 @@\n-    if (is_derived_oop_offset(derived_int_val)) {\n-      \/\/ The derived oop had already been converted to an offset.\n+  static void derelativize(oop* base_loc, derived_pointer* derived_loc) {\n+    oop base = *base_loc;\n+    if (base == nullptr) {\n@@ -227,0 +152,1 @@\n+    assert(!UseCompressedOops || !CompressedOops::is_base(base), \"\");\n@@ -228,6 +154,2 @@\n-    \/\/ At this point, we've seen a non-offset value *after* we've\n-    \/\/ read the base, but we write the offset *before* fixing the base, so we\n-    \/\/ are guaranteed that the value in derived_loc is consistent with base.\n-    \/\/\n-    \/\/ Note above how ZGC could be writing the base concurrently with the store\n-    \/\/ and how we handle it by checking the state of the read base oop.\n+    \/\/ All derived pointers should have been relativized into offsets\n+    uintptr_t offset = *(uintptr_t*)derived_loc;\n@@ -235,2 +157,2 @@\n-    intptr_t offset = derived_int_val - cast_from_oop<intptr_t>(base);\n-    Atomic::store((intptr_t*)derived_loc, tag_derived_oop_offset(offset));\n+    \/\/ Restore the original derived pointer\n+    *(uintptr_t*)derived_loc = cast_from_oop<uintptr_t>(base) + offset;\n@@ -238,0 +160,12 @@\n+\n+  struct RelativizeClosure : public DerivedOopClosure {\n+    virtual void do_derived_oop(oop* base_loc, derived_pointer* derived_loc) override {\n+      DerivedPointersSupport::relativize(base_loc, derived_loc);\n+    }\n+  };\n+\n+  struct DerelativizeClosure : public DerivedOopClosure {\n+    virtual void do_derived_oop(oop* base_loc, derived_pointer* derived_loc) override {\n+      DerivedPointersSupport::derelativize(base_loc, derived_loc);\n+    }\n+  };\n@@ -240,10 +174,3 @@\n-template <ChunkFrames frame_kind, typename RegisterMapT>\n-static void relativize_derived_oops_in_frame(const StackChunkFrameStream<frame_kind>& f,\n-                                             const RegisterMapT* map) {\n-  assert(!f.is_compiled() || f.oopmap()->has_derived_oops() == f.oopmap()->has_any(OopMapValue::derived_oop_value), \"\");\n-  bool has_derived = f.is_compiled() && f.oopmap()->has_derived_oops();\n-  if (has_derived) {\n-    RelativizeDerivedOopClosure derived_closure;\n-    f.iterate_derived_pointers(&derived_closure, map);\n-  }\n-}\n+template <typename DerivedPointerClosureType>\n+class FrameToDerivedPointerClosure {\n+  DerivedPointerClosureType* _cl;\n@@ -251,1 +178,0 @@\n-class RelativizeDerivedOopsStackChunkFrameClosure {\n@@ -253,0 +179,3 @@\n+  FrameToDerivedPointerClosure(DerivedPointerClosureType* cl)\n+    : _cl(cl) {}\n+\n@@ -255,1 +184,1 @@\n-    relativize_derived_oops_in_frame(f, map);\n+    f.iterate_derived_pointers(_cl, map);\n@@ -260,6 +189,32 @@\n-void stackChunkOopDesc::relativize_derived_oops() {\n-  assert(!is_gc_mode(), \"Should only be called once per chunk\");\n-  set_gc_mode(true);\n-  OrderAccess::storestore();\n-  RelativizeDerivedOopsStackChunkFrameClosure closure;\n-  iterate_stack(&closure);\n+bool stackChunkOopDesc::try_acquire_relativization() {\n+  for (;;) {\n+    \/\/ We use an acquiring load when reading the flags to ensure that if we leave this\n+    \/\/ function thinking that relativization is finished, we know that if another thread\n+    \/\/ did the relativization, we will still be able to observe the relativized derived\n+    \/\/ pointers, which is important as subsequent modifications of derived pointers must\n+    \/\/ happen after relativization.\n+    uint8_t flags_before = flags_acquire();\n+    if ((flags_before & FLAG_GC_MODE) != 0) {\n+      \/\/ Terminal state - relativization is ensured\n+      return false;\n+    }\n+\n+    if ((flags_before & FLAG_CLAIM_RELATIVIZE) != 0) {\n+      \/\/ Someone else has claimed relativization - wait for completion\n+      MonitorLocker ml(ContinuationRelativize_lock, Mutex::_no_safepoint_check_flag);\n+      uint8_t flags_under_lock = flags_acquire();\n+      if ((flags_under_lock & FLAG_GC_MODE) != 0) {\n+        \/\/ Terminal state - relativization is ensured\n+        return false;\n+      }\n+\n+      if ((flags_under_lock & FLAG_NOTIFY_RELATIVIZE) != 0) {\n+        \/\/ Relativization is claimed by another thread, and it knows it needs to notify\n+        ml.wait();\n+      } else if (try_set_flags(flags_under_lock, flags_under_lock | FLAG_NOTIFY_RELATIVIZE)) {\n+        \/\/ Relativization is claimed by another thread, and it knows it needs to notify\n+        ml.wait();\n+      }\n+      \/\/ Retry - rerun the loop\n+      continue;\n+    }\n@@ -267,4 +222,5 @@\n-  \/\/ The store of the derived oops must be ordered with the store of the base.\n-  \/\/ RelativizeDerivedOopsStackChunkFrameClosure stored the derived oops,\n-  \/\/ the GC code calling this function will update the base oop.\n-  OrderAccess::storestore();\n+    if (try_set_flags(flags_before, flags_before | FLAG_CLAIM_RELATIVIZE)) {\n+      \/\/ Claimed relativization - let's do it\n+      return true;\n+    }\n+  }\n@@ -273,8 +229,14 @@\n-#ifdef ASSERT\n-template <ChunkFrames frame_kind, typename RegisterMapT>\n-static void assert_relativized_derived_oops_in_frame(const StackChunkFrameStream<frame_kind>& f,\n-                                                     const RegisterMapT* map) {\n-  class AssertRelativeDerivedOopClosure : public DerivedOopClosure {\n-  public:\n-    virtual void do_derived_oop(oop* base_loc, derived_pointer* derived_loc) override {\n-      assert(*base_loc == nullptr || is_derived_oop_offset(*(intptr_t*)derived_loc), \"\");\n+void stackChunkOopDesc::release_relativization() {\n+  for (;;) {\n+    uint8_t flags_before = flags();\n+    if ((flags_before & FLAG_NOTIFY_RELATIVIZE) != 0) {\n+      MonitorLocker ml(ContinuationRelativize_lock, Mutex::_no_safepoint_check_flag);\n+      \/\/ No need to CAS the terminal state; nobody else can be racingly mutating here\n+      \/\/ as both claim and notify flags are already set (and monotonic)\n+      \/\/ We do however need to use a releasing store on the flags, to ensure that\n+      \/\/ the reader of that value (using load_acquire) will be able to observe\n+      \/\/ the relativization of the derived pointers\n+      uint8_t flags_under_lock = flags();\n+      release_set_flags(flags_under_lock | FLAG_GC_MODE);\n+      ml.notify_all();\n+      return;\n@@ -282,5 +244,12 @@\n-  };\n-  assert(!f.is_compiled() || f.oopmap()->has_derived_oops() == f.oopmap()->has_any(OopMapValue::derived_oop_value), \"\");\n-  if (f.is_compiled() && f.oopmap()->has_derived_oops()) {\n-    AssertRelativeDerivedOopClosure derived_closure;\n-    f.iterate_derived_pointers(&derived_closure, map);\n+\n+    if (try_set_flags(flags_before, flags_before | FLAG_GC_MODE)) {\n+      \/\/ Successfully set the terminal state; we are done\n+      return;\n+    }\n+  }\n+}\n+\n+void stackChunkOopDesc::relativize_derived_pointers_concurrently() {\n+  if (!try_acquire_relativization()) {\n+    \/\/ Already relativized\n+    return;\n@@ -288,0 +257,6 @@\n+\n+  DerivedPointersSupport::RelativizeClosure derived_cl;\n+  FrameToDerivedPointerClosure<decltype(derived_cl)> frame_cl(&derived_cl);\n+  iterate_stack(&frame_cl);\n+\n+  release_relativization();\n@@ -289,1 +264,0 @@\n-#endif\n@@ -339,6 +313,2 @@\n-    relativize_derived_oops_in_frame(f, map);\n-\n-    \/\/ This code is called from the STW collectors and don't have concurrent\n-    \/\/ access to the derived oops. Therefore there's no need to add a\n-    \/\/ storestore barrier here.\n-    assert(SafepointSynchronize::is_at_safepoint(), \"Should only be used by STW collectors\");\n+    DerivedPointersSupport::RelativizeClosure derived_cl;\n+    f.iterate_derived_pointers(&derived_cl, map);\n@@ -409,11 +379,0 @@\n-  if (UseZGC) {\n-    relativize_derived_oops_in_frame(f, map);\n-  } else {\n-    DEBUG_ONLY(assert_relativized_derived_oops_in_frame(f, map));\n-  }\n-\n-  \/\/ The store of the derived oops must be ordered with the store of the base.\n-  \/\/ RelativizeDerivedOopsStackChunkFrameClosure stored the derived oops,\n-  \/\/ the GC code calling this function will update the base oop.\n-  OrderAccess::storestore();\n-\n@@ -438,18 +397,0 @@\n-class DerelativizeDerivedOopClosure : public DerivedOopClosure {\n-public:\n-  virtual void do_derived_oop(oop* base_loc, derived_pointer* derived_loc) override {\n-    oop base = *base_loc;\n-    if (base != nullptr) {\n-      assert(!CompressedOops::is_base(base), \"\");\n-      ZGC_ONLY(assert(ZAddress::is_good(cast_from_oop<uintptr_t>(base)), \"\");)\n-\n-      intptr_t offset = *(intptr_t*)derived_loc;\n-\n-      if (is_derived_oop_offset(offset)) {\n-        offset = untag_derived_oop_offset(offset);\n-        *(intptr_t*)derived_loc = cast_from_oop<intptr_t>(base) + offset;\n-      }\n-    }\n-  }\n-};\n-\n@@ -470,0 +411,4 @@\n+  if (!(is_gc_mode() || requires_barriers())) {\n+    return;\n+  }\n+\n@@ -480,4 +425,3 @@\n-  if ((is_gc_mode() || UseZGC) && f.is_compiled_frame() && f.oop_map()->has_derived_oops()) {\n-    OrderAccess::loadload();\n-    DerelativizeDerivedOopClosure derived_closure;\n-    OopMapDo<OopClosure, DerelativizeDerivedOopClosure, SkipNullValue> visitor(nullptr, &derived_closure);\n+  if (f.is_compiled_frame() && f.oop_map()->has_derived_oops()) {\n+    DerivedPointersSupport::DerelativizeClosure derived_closure;\n+    OopMapDo<OopClosure, DerivedPointersSupport::DerelativizeClosure, SkipNullValue> visitor(nullptr, &derived_closure);\n@@ -533,54 +477,0 @@\n-class StackChunkVerifyDerivedPointersClosure : public DerivedOopClosure {\n-  stackChunkOop _chunk;\n-  const bool    _requires_barriers;\n-\n-public:\n-  StackChunkVerifyDerivedPointersClosure(stackChunkOop chunk)\n-    : _chunk(chunk),\n-      _requires_barriers(chunk->requires_barriers()) {}\n-\n-  virtual void do_derived_oop(oop* base_loc, derived_pointer* derived_loc) override {\n-    oop base = (_chunk->has_bitmap() && UseCompressedOops)\n-                  ? CompressedOops::decode(Atomic::load((narrowOop*)base_loc))\n-                  : Atomic::load((oop*)base_loc);\n-    if (base == nullptr) {\n-      return;\n-    }\n-\n-#if INCLUDE_ZGC\n-    if (UseZGC && !ZAddress::is_good(cast_from_oop<uintptr_t>(base))) {\n-      \/\/ If the base oops has not been fixed, other threads could be fixing\n-      \/\/ the derived oops concurrently with this code. Don't proceed with the\n-      \/\/ verification.\n-      return;\n-    }\n-#endif\n-\n-    assert(!UseCompressedOops || !CompressedOops::is_base(base), \"Should not be the compressed oops base\");\n-    assert(oopDesc::is_oop(base), \"Should be a valid oop\");\n-\n-    \/\/ Order the loads of the base oop and the derived oop\n-    OrderAccess::loadload();\n-\n-    intptr_t value = Atomic::load((intptr_t*)derived_loc);\n-    if (UseZGC && _requires_barriers) {\n-      \/\/ For ZGC when the _chunk has transition to a state where the layout has\n-      \/\/ become stable(requires_barriers()), the earlier is_good check should\n-      \/\/ guarantee that all derived oops have been converted too offsets.\n-      assert(is_derived_oop_offset(value), \"Unexpected non-offset value: \" PTR_FORMAT, value);\n-    } else {\n-      if (is_derived_oop_offset(value)) {\n-        intptr_t offset = untag_derived_oop_offset(value); \/\/ for assertions\n-      } else {\n-        \/\/ The offset was a non-offset derived pointer that\n-        \/\/ had not been converted to an offset yet.\n-        intptr_t offset = value - cast_from_oop<intptr_t>(base);\n-        tag_derived_oop_offset(offset); \/\/ for assertions\n-      }\n-    }\n-\n-    \/\/ There's not much else we can assert about derived pointers. Their offsets are allowed to\n-    \/\/ fall outside of their base object, and even be negative.\n-  }\n-};\n-\n@@ -644,3 +534,0 @@\n-    StackChunkVerifyDerivedPointersClosure derived_oops_closure(_chunk);\n-    f.iterate_derived_pointers(&derived_oops_closure, map);\n-\n","filename":"src\/hotspot\/share\/oops\/stackChunkOop.cpp","additions":116,"deletions":229,"binary":false,"changes":345,"status":"modified"},{"patch":"@@ -54,3 +54,8 @@\n-  static const uint8_t FLAG_HAS_INTERPRETED_FRAMES = 1;\n-  static const uint8_t FLAG_GC_MODE = 1 << 2; \/\/ Once true it and FLAG_HAS_INTERPRETED_FRAMES can't change\n-  static const uint8_t FLAG_HAS_BITMAP = 1 << 3; \/\/ Can only be true if FLAG_GC_MODE is true\n+  static const uint8_t FLAG_HAS_INTERPRETED_FRAMES = 1 << 0;\n+  static const uint8_t FLAG_CLAIM_RELATIVIZE = 1 << 1; \/\/ Only one thread claims relativization of derived pointers\n+  static const uint8_t FLAG_NOTIFY_RELATIVIZE = 1 << 2; \/\/ Someone is waiting for relativization to complete\n+  static const uint8_t FLAG_GC_MODE = 1 << 3; \/\/ Once true it and FLAG_HAS_INTERPRETED_FRAMES can't change\n+  static const uint8_t FLAG_HAS_BITMAP = 1 << 4; \/\/ Can only be true if FLAG_GC_MODE is true\n+\n+  bool try_acquire_relativization();\n+  void release_relativization();\n@@ -80,0 +85,1 @@\n+  inline uint8_t flags_acquire() const;\n@@ -81,0 +87,1 @@\n+  inline void release_set_flags(uint8_t value);\n@@ -109,0 +116,1 @@\n+  inline bool is_flag_acquire(uint8_t flag) const;\n@@ -110,0 +118,1 @@\n+  inline bool try_set_flags(uint8_t prev_flags, uint8_t new_flags);\n@@ -116,0 +125,1 @@\n+  inline bool is_gc_mode_acquire() const;\n@@ -137,2 +147,2 @@\n-  \/\/ Derived oop pointers are relativised, with respect to their oop base.\n-  void relativize_derived_oops();\n+  \/\/ Derived pointers are relativized, with respect to their oop base.\n+  void relativize_derived_pointers_concurrently();\n","filename":"src\/hotspot\/share\/oops\/stackChunkOop.hpp","additions":15,"deletions":5,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -69,0 +69,10 @@\n+inline uint8_t stackChunkOopDesc::flags_acquire() const { return jdk_internal_vm_StackChunk::flags_acquire(as_oop()); }\n+\n+inline void stackChunkOopDesc::release_set_flags(uint8_t value) {\n+  jdk_internal_vm_StackChunk::release_set_flags(this, value);\n+}\n+\n+inline bool stackChunkOopDesc::try_set_flags(uint8_t prev_flags, uint8_t new_flags) {\n+  return jdk_internal_vm_StackChunk::try_set_flags(this, prev_flags, new_flags);\n+}\n+\n@@ -133,0 +143,3 @@\n+inline bool stackChunkOopDesc::is_flag_acquire(uint8_t flag) const {\n+  return (flags_acquire() & flag) != 0;\n+}\n@@ -145,0 +158,1 @@\n+inline bool stackChunkOopDesc::is_gc_mode_acquire() const          { return is_flag_acquire(FLAG_GC_MODE); }\n","filename":"src\/hotspot\/share\/oops\/stackChunkOop.inline.hpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/opto\/buildOopMap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/opto\/bytecodeInfo.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/opto\/locknode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/opto\/runtime.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/prims\/forte.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/prims\/jniCheck.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3944,1 +3944,1 @@\n-  JvmtiVTMTDisabler::start_VTMT(vthread, \/* is_mount *\/ true);\n+  JvmtiVTMSTransitionDisabler::start_VTMS_transition(vthread, \/* is_mount *\/ true);\n@@ -3967,2 +3967,2 @@\n-  assert(thread->is_in_VTMT(), \"VTMT sanity check\");\n-  JvmtiVTMTDisabler::finish_VTMT(vthread, \/* is_mount *\/ true);\n+  assert(thread->is_in_VTMS_transition(), \"sanity check\");\n+  JvmtiVTMSTransitionDisabler::finish_VTMS_transition(vthread, \/* is_mount *\/ true);\n@@ -4017,2 +4017,2 @@\n-  assert(!thread->is_in_VTMT(), \"VTMT sanity check\");\n-  JvmtiVTMTDisabler::start_VTMT(vthread, \/* is_mount *\/ false);\n+  assert(!thread->is_in_VTMS_transition(), \"sanity check\");\n+  JvmtiVTMSTransitionDisabler::start_VTMS_transition(vthread, \/* is_mount *\/ false);\n@@ -4038,2 +4038,2 @@\n-  assert(thread->is_in_VTMT(), \"VTMT sanity check\");\n-  JvmtiVTMTDisabler::finish_VTMT(vthread, \/* is_mount *\/ false);\n+  assert(thread->is_in_VTMS_transition(), \"sanity check\");\n+  JvmtiVTMSTransitionDisabler::finish_VTMS_transition(vthread, \/* is_mount *\/ false);\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -151,1 +151,1 @@\n-  JvmtiVTMTDisabler vtmt_disabler;\n+  JvmtiVTMSTransitionDisabler disabler;\n@@ -204,1 +204,1 @@\n-    JvmtiVTMTDisabler vtmt_disabler;\n+    JvmtiVTMSTransitionDisabler disabler;\n@@ -553,1 +553,1 @@\n-  JvmtiVTMTDisabler vtmt_disabler;\n+  JvmtiVTMSTransitionDisabler disabler;\n@@ -577,1 +577,1 @@\n-  JvmtiVTMTDisabler vtmt_disabler;\n+  JvmtiVTMSTransitionDisabler disabler;\n@@ -860,1 +860,1 @@\n-  JvmtiVTMTDisabler vtmt_disabler;\n+  JvmtiVTMSTransitionDisabler disabler;\n@@ -938,1 +938,1 @@\n-    JvmtiVTMTDisabler vtmt_disabler(true);\n+    JvmtiVTMSTransitionDisabler disabler(true);\n@@ -945,1 +945,1 @@\n-    \/\/ Do not use JvmtiVTMTDisabler in context of self suspend to avoid deadlocks.\n+    \/\/ Do not use JvmtiVTMSTransitionDisabler in context of self suspend to avoid deadlocks.\n@@ -969,1 +969,1 @@\n-    JvmtiVTMTDisabler vtmt_disabler(true);\n+    JvmtiVTMSTransitionDisabler disabler(true);\n@@ -976,0 +976,6 @@\n+\n+      if (thread_oop != NULL &&\n+          java_lang_VirtualThread::is_instance(thread_oop) &&\n+          !JvmtiEnvBase::is_vthread_alive(thread_oop)) {\n+        err = JVMTI_ERROR_THREAD_NOT_ALIVE;\n+      }\n@@ -991,1 +997,1 @@\n-  \/\/ Do not use JvmtiVTMTDisabler in context of self suspend to avoid deadlocks.\n+  \/\/ Do not use JvmtiVTMSTransitionDisabler in context of self suspend to avoid deadlocks.\n@@ -1020,1 +1026,1 @@\n-    JvmtiVTMTDisabler vtmt_disabler(true);\n+    JvmtiVTMSTransitionDisabler disabler(true);\n@@ -1063,1 +1069,1 @@\n-  \/\/ Do not use JvmtiVTMTDisabler in context of self suspend to avoid deadlocks.\n+  \/\/ Do not use JvmtiVTMSTransitionDisabler in context of self suspend to avoid deadlocks.\n@@ -1074,1 +1080,1 @@\n-  JvmtiVTMTDisabler vtmt_disabler(true);\n+  JvmtiVTMSTransitionDisabler disabler(true);\n@@ -1095,1 +1101,1 @@\n-  JvmtiVTMTDisabler vtmt_disabler(true);\n+  JvmtiVTMSTransitionDisabler disabler(true);\n@@ -1101,0 +1107,6 @@\n+\n+    if (thread_oop != NULL &&\n+        java_lang_VirtualThread::is_instance(thread_oop) &&\n+        !JvmtiEnvBase::is_vthread_alive(thread_oop)) {\n+      err = JVMTI_ERROR_THREAD_NOT_ALIVE;\n+    }\n@@ -1127,1 +1139,1 @@\n-  JvmtiVTMTDisabler vtmt_disabler(true);\n+  JvmtiVTMSTransitionDisabler disabler(true);\n@@ -1178,0 +1190,5 @@\n+\n+  if (thread_oop != NULL && java_lang_VirtualThread::is_instance(thread_oop)) {\n+    \/\/ No support for virtual threads (yet).\n+    return JVMTI_ERROR_UNSUPPORTED_OPERATION;\n+  }\n@@ -1181,4 +1198,0 @@\n-  if (java_lang_VirtualThread::is_instance(thread_oop)) {\n-    \/\/ No support for virtual threads.\n-    return JVMTI_ERROR_UNSUPPORTED_OPERATION;\n-  }\n@@ -1201,1 +1214,1 @@\n-  JvmtiVTMTDisabler vtmt_disabler;\n+  JvmtiVTMSTransitionDisabler disabler;\n@@ -1246,1 +1259,1 @@\n-  JvmtiVTMTDisabler vtmt_disabler;\n+  JvmtiVTMSTransitionDisabler disabler;\n@@ -1346,1 +1359,1 @@\n-  JvmtiVTMTDisabler vtmt_disabler;\n+  JvmtiVTMSTransitionDisabler disabler;\n@@ -1419,1 +1432,1 @@\n-  JvmtiVTMTDisabler vtmt_disabler;\n+  JvmtiVTMSTransitionDisabler disabler;\n@@ -1489,1 +1502,1 @@\n-  JvmtiVTMTDisabler vtmt_disabler;\n+  JvmtiVTMSTransitionDisabler disabler;\n@@ -1703,1 +1716,1 @@\n-  JvmtiVTMTDisabler vtmt_disabler;\n+  JvmtiVTMSTransitionDisabler disabler;\n@@ -1771,1 +1784,1 @@\n-    JvmtiVTMTDisabler vtmt_disabler;\n+    JvmtiVTMSTransitionDisabler disabler;\n@@ -1821,1 +1834,1 @@\n-  JvmtiVTMTDisabler vtmt_disabler;\n+  JvmtiVTMSTransitionDisabler disabler;\n@@ -1865,1 +1878,1 @@\n-  JvmtiVTMTDisabler vtmt_disabler;\n+  JvmtiVTMSTransitionDisabler disabler;\n@@ -1871,3 +1884,0 @@\n-  if (err != JVMTI_ERROR_NONE) {\n-    return err;\n-  }\n@@ -1875,1 +1885,1 @@\n-  if (java_lang_VirtualThread::is_instance(thread_obj)) {\n+  if (thread_obj != NULL && java_lang_VirtualThread::is_instance(thread_obj)) {\n@@ -1879,0 +1889,4 @@\n+  if (err != JVMTI_ERROR_NONE) {\n+    return err;\n+  }\n+\n@@ -1912,1 +1926,1 @@\n-  JvmtiVTMTDisabler vtmt_disabler;\n+  JvmtiVTMSTransitionDisabler disabler;\n@@ -1952,1 +1966,1 @@\n-  JvmtiVTMTDisabler vtmt_disabler;\n+  JvmtiVTMSTransitionDisabler disabler;\n@@ -2230,1 +2244,1 @@\n-  JvmtiVTMTDisabler vtmt_disabler;\n+  JvmtiVTMSTransitionDisabler disabler;\n@@ -2270,1 +2284,1 @@\n-  JvmtiVTMTDisabler vtmt_disabler;\n+  JvmtiVTMSTransitionDisabler disabler;\n@@ -2311,1 +2325,1 @@\n-  JvmtiVTMTDisabler vtmt_disabler;\n+  JvmtiVTMSTransitionDisabler disabler;\n@@ -2352,1 +2366,1 @@\n-  JvmtiVTMTDisabler vtmt_disabler;\n+  JvmtiVTMSTransitionDisabler disabler;\n@@ -2393,1 +2407,1 @@\n-  JvmtiVTMTDisabler vtmt_disabler;\n+  JvmtiVTMSTransitionDisabler disabler;\n@@ -2434,1 +2448,1 @@\n-  JvmtiVTMTDisabler vtmt_disabler;\n+  JvmtiVTMSTransitionDisabler disabler;\n@@ -2474,1 +2488,1 @@\n-  JvmtiVTMTDisabler vtmt_disabler;\n+  JvmtiVTMSTransitionDisabler disabler;\n@@ -2510,1 +2524,1 @@\n-  JvmtiVTMTDisabler vtmt_disabler;\n+  JvmtiVTMSTransitionDisabler disabler;\n@@ -2546,1 +2560,1 @@\n-  JvmtiVTMTDisabler vtmt_disabler;\n+  JvmtiVTMSTransitionDisabler disabler;\n@@ -2582,1 +2596,1 @@\n-  JvmtiVTMTDisabler vtmt_disabler;\n+  JvmtiVTMSTransitionDisabler disabler;\n@@ -2618,1 +2632,1 @@\n-  JvmtiVTMTDisabler vtmt_disabler;\n+  JvmtiVTMSTransitionDisabler disabler;\n@@ -3898,0 +3912,5 @@\n+\n+  if (thread_oop != NULL && java_lang_VirtualThread::is_instance(thread_oop)) {\n+    \/\/ No support for virtual threads (yet).\n+    return JVMTI_ERROR_UNSUPPORTED_OPERATION;\n+  }\n@@ -3901,4 +3920,0 @@\n-  if (java_lang_VirtualThread::is_instance(thread_oop)) {\n-    \/\/ No support for virtual threads.\n-    return JVMTI_ERROR_UNSUPPORTED_OPERATION;\n-  }\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnv.cpp","additions":63,"deletions":48,"binary":false,"changes":111,"status":"modified"},{"patch":"@@ -563,2 +563,2 @@\n-vframe*\n-JvmtiEnvBase::vframe_for_no_process(JavaThread* java_thread, jint depth, bool for_cont) {\n+javaVFrame*\n+JvmtiEnvBase::jvf_for_thread_and_depth(JavaThread* java_thread, jint depth) {\n@@ -569,9 +569,6 @@\n-  vframe *vf = for_cont ? get_cthread_last_java_vframe(java_thread, &reg_map)\n-                        : java_thread->last_java_vframe(&reg_map);\n-  if (!for_cont) {\n-    vf = JvmtiEnvBase::check_and_skip_hidden_frames(java_thread, (javaVFrame*)vf);\n-  }\n-  int d = 0;\n-  while ((vf != NULL) && (d < depth)) {\n-    vf = vf->java_sender();\n-    d++;\n+  javaVFrame *jvf = java_thread->last_java_vframe(&reg_map);\n+\n+  jvf = JvmtiEnvBase::check_and_skip_hidden_frames(java_thread, jvf);\n+\n+  for (int d = 0; jvf != NULL && d < depth; d++) {\n+    jvf = jvf->java_sender();\n@@ -579,1 +576,1 @@\n-  return vf;\n+  return jvf;\n@@ -582,1 +579,0 @@\n-\n@@ -618,2 +614,2 @@\n-  assert(java_lang_VirtualThread::state(vt) != java_lang_VirtualThread::NEW, \"sanity check\");\n-  return java_lang_VirtualThread::state(vt) != java_lang_VirtualThread::TERMINATED;\n+  return java_lang_VirtualThread::state(vt) != java_lang_VirtualThread::NEW &&\n+         java_lang_VirtualThread::state(vt) != java_lang_VirtualThread::TERMINATED;\n@@ -637,1 +633,1 @@\n-JvmtiEnvBase::check_and_skip_hidden_frames(bool is_in_VTMT, javaVFrame* jvf) {\n+JvmtiEnvBase::check_and_skip_hidden_frames(bool is_in_VTMS_transition, javaVFrame* jvf) {\n@@ -639,1 +635,1 @@\n-  if (!is_in_VTMT && (jvf == NULL || !jvf->method()->jvmti_mount_transition())) {\n+  if (!is_in_VTMS_transition && (jvf == NULL || !jvf->method()->jvmti_mount_transition())) {\n@@ -658,1 +654,1 @@\n-  jvf = check_and_skip_hidden_frames(jt->is_in_VTMT(), jvf);\n+  jvf = check_and_skip_hidden_frames(jt->is_in_VTMS_transition(), jvf);\n@@ -669,1 +665,1 @@\n-  jvf = check_and_skip_hidden_frames(state->is_in_VTMT(), jvf);\n+  jvf = check_and_skip_hidden_frames(state->is_in_VTMS_transition(), jvf);\n@@ -1210,1 +1206,1 @@\n-JvmtiEnvBase::get_frame_location(JavaThread *java_thread, jint depth,\n+JvmtiEnvBase::get_frame_location(javaVFrame* jvf, jint depth,\n@@ -1212,4 +1208,1 @@\n-  Thread* current_thread = Thread::current();\n-  assert(java_thread->is_handshake_safe_for(current_thread),\n-         \"call by myself or at handshake\");\n-  ResourceMark rm(current_thread);\n+  int cur_depth = 0;\n@@ -1217,3 +1210,3 @@\n-  vframe *vf = vframe_for_no_process(java_thread, depth, true \/* for cont *\/);\n-  if (vf == NULL) {\n-    return JVMTI_ERROR_NO_MORE_FRAMES;\n+  while (jvf != NULL && cur_depth < depth) {\n+    jvf = jvf->java_sender();\n+    cur_depth++;\n@@ -1221,9 +1214,3 @@\n-\n-  \/\/ vframeFor should return a java frame. If it doesn't\n-  \/\/ it means we've got an internal error and we return the\n-  \/\/ error in product mode. In debug mode we will instead\n-  \/\/ attempt to cast the vframe to a javaVFrame and will\n-  \/\/ cause an assertion\/crash to allow further diagnosis.\n-#ifdef PRODUCT\n-  if (!vf->is_java_frame()) {\n-    return JVMTI_ERROR_INTERNAL;\n+  assert(depth >= cur_depth, \"ran out of frames too soon\");\n+  if (jvf == NULL) {\n+    return JVMTI_ERROR_NO_MORE_FRAMES;\n@@ -1231,4 +1218,0 @@\n-#endif\n-\n-  HandleMark hm(current_thread);\n-  javaVFrame *jvf = javaVFrame::cast(vf);\n@@ -1242,1 +1225,0 @@\n-\n@@ -1246,0 +1228,17 @@\n+jvmtiError\n+JvmtiEnvBase::get_frame_location(JavaThread *java_thread, jint depth,\n+                                 jmethodID* method_ptr, jlocation* location_ptr) {\n+  Thread* current = Thread::current();\n+  assert(java_thread->is_handshake_safe_for(current),\n+         \"call by myself or at handshake\");\n+  if (!java_thread->has_last_Java_frame()) {\n+    return JVMTI_ERROR_NO_MORE_FRAMES;\n+  }\n+  ResourceMark rm(current);\n+  HandleMark hm(current);\n+  RegisterMap reg_map(java_thread, true \/* update_map *\/, false \/* process_frames *\/, true \/* walk_cont *\/);\n+  javaVFrame* jvf = JvmtiEnvBase::get_cthread_last_java_vframe(java_thread, &reg_map);\n+\n+  return get_frame_location(jvf, depth, method_ptr, location_ptr);\n+}\n+\n@@ -1252,3 +1251,3 @@\n-  Thread* cur_thread = Thread::current();\n-  ResourceMark rm(cur_thread);\n-  HandleMark hm(cur_thread);\n+  Thread* current = Thread::current();\n+  ResourceMark rm(current);\n+  HandleMark hm(current);\n@@ -1256,18 +1255,0 @@\n-  int cur_depth = 0;\n-\n-  while (jvf != NULL && cur_depth < depth) {\n-    Method* method = jvf->method();\n-    jvf = jvf->java_sender();\n-    cur_depth++;\n-  }\n-  assert(depth >= cur_depth, \"ran out of frames too soon\");\n-  if (jvf == NULL) {\n-    return JVMTI_ERROR_NO_MORE_FRAMES;\n-  }\n-  Method* method = jvf->method();\n-  if (method->is_native()) {\n-    *location_ptr = -1;\n-  } else {\n-    *location_ptr = jvf->bci();\n-  }\n-  *method_ptr = method->jmethod_id();\n@@ -1275,1 +1256,1 @@\n-  return JVMTI_ERROR_NONE;\n+  return get_frame_location(jvf, depth, method_ptr, location_ptr);\n@@ -1342,0 +1323,4 @@\n+  if (java_lang_VirtualThread::is_instance(thread_oop) &&\n+      !JvmtiEnvBase::is_vthread_alive(thread_oop)) {\n+    return JVMTI_ERROR_THREAD_NOT_ALIVE;\n+  }\n@@ -1556,1 +1541,1 @@\n-    \/\/ The java_thread can be still blocked in VTMT transition after a previous JVMTI resume call.\n+    \/\/ The java_thread can be still blocked in VTMS transition after a previous JVMTI resume call.\n@@ -1581,1 +1566,1 @@\n-  assert(!java_thread->is_in_VTMT(), \"sanity check\");\n+  assert(!java_thread->is_in_VTMS_transition(), \"sanity check\");\n@@ -1624,1 +1609,1 @@\n-    \/\/ The java_thread can be still blocked in VTMT transition after a previous JVMTI suspend call.\n+    \/\/ The java_thread can be still blocked in VTMS transition after a previous JVMTI suspend call.\n@@ -1648,1 +1633,1 @@\n-  assert(!java_thread->is_in_VTMT(), \"sanity check\");\n+  assert(!java_thread->is_in_VTMS_transition(), \"sanity check\");\n@@ -1860,2 +1845,2 @@\n-  vframe *vf = vframe_for_no_process(java_thread, 0);\n-  NULL_CHECK(vf, JVMTI_ERROR_NO_MORE_FRAMES);\n+  javaVFrame* jvf = jvf_for_thread_and_depth(java_thread, 0);\n+  NULL_CHECK(jvf, JVMTI_ERROR_NO_MORE_FRAMES);\n@@ -1863,2 +1848,1 @@\n-  javaVFrame *jvf = (javaVFrame*) vf;\n-  if (!vf->is_java_frame() || jvf->method()->is_native()) {\n+  if (jvf->method()->is_native()) {\n@@ -1869,2 +1853,2 @@\n-  if (vf->is_compiled_frame()) {\n-    if (!vf->fr().can_be_deoptimized()) {\n+  if (jvf->is_compiled_frame()) {\n+    if (!jvf->fr().can_be_deoptimized()) {\n@@ -1921,1 +1905,1 @@\n-  JvmtiVTMTDisabler vtmt_disabler;\n+  JvmtiVTMSTransitionDisabler disabler;\n@@ -1927,3 +1911,0 @@\n-  if (err != JVMTI_ERROR_NONE) {\n-    return err;\n-  }\n@@ -1931,1 +1912,1 @@\n-  if (java_lang_VirtualThread::is_instance(thread_obj)) {\n+  if (thread_obj != NULL && java_lang_VirtualThread::is_instance(thread_obj)) {\n@@ -1935,0 +1916,3 @@\n+  if (err != JVMTI_ERROR_NONE) {\n+    return err;\n+  }\n@@ -2148,1 +2132,1 @@\n-    if (JvmtiEnvBase::vframe_for_no_process(java_thread, 1) == NULL) {\n+    if (JvmtiEnvBase::jvf_for_thread_and_depth(java_thread, 1) == NULL) {\n@@ -2265,1 +2249,2 @@\n-  log_error(jvmti)(\"%s(%s) exiting: %d is_susp: %d is_thread_susp: %d is_vthread_susp: %d is_VTMT_disabler: %d, is_in_VTMT = %d\\n\",\n+  log_error(jvmti)(\"%s(%s) exiting: %d is_susp: %d is_thread_susp: %d is_vthread_susp: %d \"\n+                   \"is_VTMS_transition_disabler: %d, is_in_VTMS_transition = %d\\n\",\n@@ -2268,1 +2253,1 @@\n-                   java_thread->is_VTMT_disabler(), java_thread->is_in_VTMT());\n+                   java_thread->is_VTMS_transition_disabler(), java_thread->is_in_VTMS_transition());\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.cpp","additions":66,"deletions":81,"binary":false,"changes":147,"status":"modified"},{"patch":"@@ -329,1 +329,1 @@\n-  static vframe* vframe_for_no_process(JavaThread* java_thread, jint depth, bool for_cont = false);\n+  static javaVFrame* jvf_for_thread_and_depth(JavaThread* java_thread, jint depth);\n@@ -335,1 +335,1 @@\n-  static javaVFrame* check_and_skip_hidden_frames(bool is_in_VTMT, javaVFrame* jvf);\n+  static javaVFrame* check_and_skip_hidden_frames(bool is_in_VTMS_transition, javaVFrame* jvf);\n@@ -368,0 +368,2 @@\n+  jvmtiError get_frame_location(javaVFrame* jvf, jint depth,\n+                                jmethodID* method_ptr, jlocation* location_ptr);\n@@ -373,3 +375,6 @@\n-  jvmtiError get_object_monitor_usage(JavaThread *calling_thread,\n-                                                    jobject object, jvmtiMonitorUsage* info_ptr);\n-  jvmtiError get_stack_trace(javaVFrame *jvf,\n+  jvmtiError get_object_monitor_usage(JavaThread* calling_thread,\n+                                      jobject object, jvmtiMonitorUsage* info_ptr);\n+  jvmtiError get_stack_trace(javaVFrame* jvf,\n+                             jint stack_depth, jint max_count,\n+                             jvmtiFrameInfo* frame_buffer, jint* count_ptr);\n+  jvmtiError get_stack_trace(JavaThread* java_thread,\n@@ -378,5 +383,2 @@\n-  jvmtiError get_stack_trace(JavaThread *java_thread,\n-                                           jint stack_depth, jint max_count,\n-                                           jvmtiFrameInfo* frame_buffer, jint* count_ptr);\n-  jvmtiError get_current_contended_monitor(JavaThread* calling_thread, JavaThread *java_thread,\n-                                           jobject *monitor_ptr, bool is_virtual);\n+  jvmtiError get_current_contended_monitor(JavaThread* calling_thread, JavaThread* java_thread,\n+                                           jobject* monitor_ptr, bool is_virtual);\n@@ -385,1 +387,1 @@\n-  jvmtiError get_owned_monitors(JavaThread *calling_thread, JavaThread* java_thread, javaVFrame* jvf,\n+  jvmtiError get_owned_monitors(JavaThread* calling_thread, JavaThread* java_thread, javaVFrame* jvf,\n@@ -559,1 +561,1 @@\n-\/\/ HandshakeClosure to print stack trace in JvmtiVTMTDisabler error handling\n+\/\/ HandshakeClosure to print stack trace in JvmtiVTMSTransitionDisabler error handling.\n@@ -570,1 +572,1 @@\n-\/\/ forward declaration\n+\/\/ Forward declaration.\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.hpp","additions":15,"deletions":13,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -376,1 +376,1 @@\n-    assert(!jvmti_thread_state()->is_in_VTMT(), \"sanity check\");\n+    assert(!jvmti_thread_state()->is_in_VTMS_transition(), \"sanity check\");\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvThreadState.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -383,1 +383,1 @@\n-    \/\/ Virtual threads support. There is a performance impact when VTMT transitions are enabled.\n+    \/\/ Virtual threads support. There is a performance impact when VTMS transitions are enabled.\n@@ -895,1 +895,1 @@\n-    assert(!_thread->is_in_VTMT(), \"CFLH events are not allowed in VTMT\");\n+    assert(!_thread->is_in_VTMS_transition(), \"CFLH events are not allowed in VTMS transition\");\n@@ -1186,2 +1186,2 @@\n-  if (thread->is_in_VTMT()) {\n-    return; \/\/ no events should be posted if thread is in a VTMT transition\n+  if (thread->is_in_VTMS_transition()) {\n+    return; \/\/ no events should be posted if thread is in a VTMS transition\n@@ -1270,1 +1270,1 @@\n-void JvmtiExport::check_suspend_at_safepoint(JavaThread *thread) {\n+void JvmtiExport::check_vthread_and_suspend_at_safepoint(JavaThread *thread) {\n@@ -1277,1 +1277,1 @@\n-    MonitorLocker ml(JvmtiVTMT_lock, Mutex::_no_safepoint_check_flag);\n+    MonitorLocker ml(JvmtiVTMSTransition_lock, Mutex::_no_safepoint_check_flag);\n@@ -1342,1 +1342,1 @@\n-  assert(!thread->is_in_VTMT(), \"class load events are not allowed in VTMT\");\n+  assert(!thread->is_in_VTMS_transition(), \"class load events are not allowed in VTMS transition\");\n@@ -1377,1 +1377,1 @@\n-  assert(!thread->is_in_VTMT(), \"class prepare events are not allowed in VTMT\");\n+  assert(!thread->is_in_VTMS_transition(), \"class prepare events are not allowed in VTMS transition\");\n@@ -1695,2 +1695,2 @@\n-  if (thread->is_Java_thread() && JavaThread::cast(thread)->is_in_VTMT()) {\n-    return; \/\/ no events should be posted if thread is in a VTMT transition\n+  if (thread->is_Java_thread() && JavaThread::cast(thread)->is_in_VTMS_transition()) {\n+    return; \/\/ no events should be posted if thread is in a VTMS transition\n@@ -1713,2 +1713,2 @@\n-  if (thread->is_in_VTMT()) {\n-    return; \/\/ no events should be posted if thread is in a VTMT transition\n+  if (thread->is_in_VTMS_transition()) {\n+    return; \/\/ no events should be posted if thread is in a VTMS transition\n@@ -1756,2 +1756,2 @@\n-  if (mh->jvmti_mount_transition() || thread->is_in_VTMT()) {\n-    return; \/\/ no events should be posted if thread is in a VTMT transition\n+  if (mh->jvmti_mount_transition() || thread->is_in_VTMS_transition()) {\n+    return; \/\/ no events should be posted if thread is in a VTMS transition\n@@ -1840,2 +1840,2 @@\n-  if (mh->jvmti_mount_transition() || thread->is_in_VTMT()) {\n-    return; \/\/ no events should be posted if thread is in a VTMT transition\n+  if (mh->jvmti_mount_transition() || thread->is_in_VTMS_transition()) {\n+    return; \/\/ no events should be posted if thread is in a VTMS transition\n@@ -1916,2 +1916,2 @@\n-  if (mh->jvmti_mount_transition() || thread->is_in_VTMT()) {\n-    return; \/\/ no events should be posted if thread is in a VTMT transition\n+  if (mh->jvmti_mount_transition() || thread->is_in_VTMS_transition()) {\n+    return; \/\/ no events should be posted if thread is in a VTMS transition\n@@ -1953,2 +1953,2 @@\n-  if (thread->is_in_VTMT()) {\n-    return; \/\/ no events should be posted if thread is in a VTMT transition\n+  if (thread->is_in_VTMS_transition()) {\n+    return; \/\/ no events should be posted if thread is in a VTMS transition\n@@ -2075,2 +2075,2 @@\n-      if (mh->jvmti_mount_transition() || thread->is_in_VTMT()) {\n-        return; \/\/ no events should be posted if thread is in a VTMT transition\n+      if (mh->jvmti_mount_transition() || thread->is_in_VTMS_transition()) {\n+        return; \/\/ no events should be posted if thread is in a VTMS transition\n@@ -2121,2 +2121,2 @@\n-  if (thread->is_in_VTMT()) {\n-    return; \/\/ no events should be posted if thread is in a VTMT transition\n+  if (thread->is_in_VTMS_transition()) {\n+    return; \/\/ no events should be posted if thread is in a VTMS transition\n@@ -2157,2 +2157,2 @@\n-  if (thread->is_in_VTMT()) {\n-    return; \/\/ no events should be posted if thread is in a VTMT transition\n+  if (thread->is_in_VTMS_transition()) {\n+    return; \/\/ no events should be posted if thread is in a VTMS transition\n@@ -2207,2 +2207,2 @@\n-  if (thread->is_in_VTMT()) {\n-    return; \/\/ no events should be posted if thread is in a VTMT transition\n+  if (thread->is_in_VTMS_transition()) {\n+    return; \/\/ no events should be posted if thread is in a VTMS transition\n@@ -2238,2 +2238,2 @@\n-  if (thread->is_in_VTMT()) {\n-    return; \/\/ no events should be posted if thread is in a VTMT transition\n+  if (thread->is_in_VTMS_transition()) {\n+    return; \/\/ no events should be posted if thread is in a VTMS transition\n@@ -2313,2 +2313,2 @@\n-  if (thread->is_in_VTMT()) {\n-    return; \/\/ no events should be posted if thread is in a VTMT transition\n+  if (thread->is_in_VTMS_transition()) {\n+    return; \/\/ no events should be posted if thread is in a VTMS transition\n@@ -2352,2 +2352,2 @@\n-  if (thread->is_in_VTMT()) {\n-    return; \/\/ no events should be posted if thread is in a VTMT transition\n+  if (thread->is_in_VTMS_transition()) {\n+    return; \/\/ no events should be posted if thread is in a VTMS transition\n@@ -2426,1 +2426,1 @@\n-  assert(!thread->is_in_VTMT(), \"compiled method load events are not allowed in VTMT\");\n+  assert(!thread->is_in_VTMS_transition(), \"compiled method load events are not allowed in VTMS transition\");\n@@ -2449,1 +2449,1 @@\n-  assert(!thread->is_in_VTMT(), \"compiled method load events are not allowed in VTMT\");\n+  assert(!thread->is_in_VTMS_transition(), \"compiled method load events are not allowed in VTMS transition\");\n@@ -2475,1 +2475,1 @@\n-  assert(!thread->is_in_VTMT(), \"dynamic code generated events are not allowed in VTMT\");\n+  assert(!thread->is_in_VTMS_transition(), \"dynamic code generated events are not allowed in VTMS transition\");\n@@ -2523,1 +2523,1 @@\n-  assert(!thread->is_in_VTMT(), \"dynamic code generated events are not allowed in VTMT\");\n+  assert(!thread->is_in_VTMS_transition(), \"dynamic code generated events are not allowed in VTMS transition\");\n@@ -2547,1 +2547,1 @@\n-  assert(!thread->is_in_VTMT(), \"dynamic code generated events are not allowed in VTMT\");\n+  assert(!thread->is_in_VTMS_transition(), \"dynamic code generated events are not allowed in VTMS transition\");\n@@ -2677,2 +2677,2 @@\n-  if (thread->is_in_VTMT()) {\n-    return; \/\/ no events should be posted if thread is in a VTMT transition\n+  if (thread->is_in_VTMS_transition()) {\n+    return; \/\/ no events should be posted if thread is in a VTMS transition\n@@ -2710,2 +2710,2 @@\n-  if (thread->is_in_VTMT()) {\n-    return; \/\/ no events should be posted if thread is in a VTMT transition\n+  if (thread->is_in_VTMS_transition()) {\n+    return; \/\/ no events should be posted if thread is in a VTMS transition\n@@ -2744,2 +2744,2 @@\n-  if (thread->is_in_VTMT()) {\n-    return; \/\/ no events should be posted if thread is in a VTMT transition\n+  if (thread->is_in_VTMS_transition()) {\n+    return; \/\/ no events should be posted if thread is in a VTMS transition\n@@ -2778,2 +2778,2 @@\n-  if (thread->is_in_VTMT()) {\n-    return; \/\/ no events should be posted if thread is in a VTMT transition\n+  if (thread->is_in_VTMS_transition()) {\n+    return; \/\/ no events should be posted if thread is in a VTMS transition\n@@ -2810,2 +2810,2 @@\n-  if (thread->is_in_VTMT()) {\n-    return; \/\/ no events should be posted if thread is in a VTMT transition\n+  if (thread->is_in_VTMS_transition()) {\n+    return; \/\/ no events should be posted if thread is in a VTMS transition\n@@ -2844,2 +2844,2 @@\n-  if (thread->is_in_VTMT()) {\n-    return; \/\/ no events should be posted if thread is in a VTMT transition\n+  if (thread->is_in_VTMS_transition()) {\n+    return; \/\/ no events should be posted if thread is in a VTMS transition\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.cpp","additions":51,"deletions":51,"binary":false,"changes":102,"status":"modified"},{"patch":"@@ -301,1 +301,1 @@\n-  static void check_suspend_at_safepoint(JavaThread *thread) NOT_JVMTI_RETURN;\n+  static void check_vthread_and_suspend_at_safepoint(JavaThread *thread) NOT_JVMTI_RETURN;\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -81,1 +81,1 @@\n-  JvmtiVTMTDisabler vtmt_disabler;\n+  JvmtiVTMSTransitionDisabler disabler;\n@@ -134,1 +134,1 @@\n-  JvmtiVTMTDisabler vtmt_disabler;\n+  JvmtiVTMSTransitionDisabler disabler;\n@@ -155,1 +155,1 @@\n-      return JVMTI_ERROR_NULL_POINTER;\n+    return JVMTI_ERROR_NULL_POINTER;\n@@ -181,1 +181,1 @@\n-    { (char*)\"GetVirtualThread\", JVMTI_KIND_IN, JVMTI_TYPE_JTHREAD, JNI_FALSE },\n+    { (char*)\"GetCarrierThread\", JVMTI_KIND_IN, JVMTI_TYPE_JTHREAD, JNI_FALSE },\n","filename":"src\/hotspot\/share\/prims\/jvmtiExtensions.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-#include \"classfile\/javaClasses.hpp\"\n","filename":"src\/hotspot\/share\/prims\/jvmtiManageCapabilities.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1157,1 +1157,2 @@\n-  EscapeBarrier eb(false, JavaThread::current()); \/\/ disable due to virtual threads\n+  \/\/ disabled if vritual threads are enabled with --enable-preview\n+  EscapeBarrier eb(!Continuations::enabled() && !(heap_filter & JVMTI_HEAP_FILTER_UNTAGGED), JavaThread::current());\n","filename":"src\/hotspot\/share\/prims\/jvmtiTagMap.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -86,1 +86,1 @@\n-  _is_in_VTMT = false;\n+  _is_in_VTMS_transition = false;\n@@ -214,1 +214,1 @@\n-\/\/ Virtual Threads Mount Transition (VTMT) mechanism\n+\/\/ Virtual Threads Mount State transition (VTMS transition) mechanism\n@@ -217,2 +217,2 @@\n-\/\/ VTMT cannot be disabled while this counter is positive.\n-volatile int JvmtiVTMTDisabler::_VTMT_count = 0;\n+\/\/ VTMS transitions cannot be disabled while this counter is positive.\n+volatile int JvmtiVTMSTransitionDisabler::_VTMS_transition_count = 0;\n@@ -220,2 +220,2 @@\n-\/\/ VTMT is disabled while this counter is positive\n-volatile int JvmtiVTMTDisabler::_VTMT_disable_count = 0;\n+\/\/ VTMS transitions is disabled while this counter is positive\n+volatile int JvmtiVTMSTransitionDisabler::_VTMS_transition_disable_count = 0;\n@@ -224,1 +224,1 @@\n-volatile bool JvmtiVTMTDisabler::_SR_mode = false;\n+volatile bool JvmtiVTMSTransitionDisabler::_SR_mode = false;\n@@ -229,3 +229,3 @@\n-JvmtiVTMTDisabler::print_info() {\n-  log_error(jvmti)(\"_VTMT_disable_count: %d _VTMT_count: %d\\n\\n\",\n-                   _VTMT_disable_count, _VTMT_count);\n+JvmtiVTMSTransitionDisabler::print_info() {\n+  log_error(jvmti)(\"_VTMS_transition_disable_count: %d _VTMS_transition_count: %d\\n\\n\",\n+                   _VTMS_transition_disable_count, _VTMS_transition_count);\n@@ -242,1 +242,1 @@\n-JvmtiVTMTDisabler::JvmtiVTMTDisabler(bool is_SR) {\n+JvmtiVTMSTransitionDisabler::JvmtiVTMSTransitionDisabler(bool is_SR) {\n@@ -244,1 +244,1 @@\n-    return; \/\/ JvmtiVTMTDisabler is no-op without virtual threads\n+    return; \/\/ JvmtiVTMSTransitionDisabler is no-op without virtual threads\n@@ -250,1 +250,1 @@\n-  disable_VTMT();\n+  disable_VTMS_transitions();\n@@ -253,1 +253,1 @@\n-JvmtiVTMTDisabler::~JvmtiVTMTDisabler() {\n+JvmtiVTMSTransitionDisabler::~JvmtiVTMSTransitionDisabler() {\n@@ -255,1 +255,1 @@\n-    return; \/\/ JvmtiVTMTDisabler is a no-op without virtual threads\n+    return; \/\/ JvmtiVTMSTransitionDisabler is a no-op without virtual threads\n@@ -260,1 +260,1 @@\n-  enable_VTMT();\n+  enable_VTMS_transitions();\n@@ -264,1 +264,1 @@\n-JvmtiVTMTDisabler::disable_VTMT() {\n+JvmtiVTMSTransitionDisabler::disable_VTMS_transitions() {\n@@ -269,1 +269,1 @@\n-    MonitorLocker ml(JvmtiVTMT_lock, Mutex::_no_safepoint_check_flag);\n+    MonitorLocker ml(JvmtiVTMSTransition_lock, Mutex::_no_safepoint_check_flag);\n@@ -271,3 +271,3 @@\n-    assert(!thread->is_in_VTMT(), \"VTMT sanity check\");\n-    while (_SR_mode) {  \/\/ suspender or resumer is a JvmtiVTMTDisabler monopolist\n-      ml.wait(10);  \/\/ Wait while there is an active suspender or resumer.\n+    assert(!thread->is_in_VTMS_transition(), \"VTMS_transition sanity check\");\n+    while (_SR_mode) { \/\/ Suspender or resumer is a JvmtiVTMSTransitionDisabler monopolist.\n+      ml.wait(10);     \/\/ Wait while there is an active suspender or resumer.\n@@ -277,2 +277,2 @@\n-      while (_VTMT_disable_count > 0) {\n-        ml.wait(10);  \/\/ Wait while there is any active jvmtiVTMTDisabler.\n+      while (_VTMS_transition_disable_count > 0) {\n+        ml.wait(10);   \/\/ Wait while there is any active jvmtiVTMSTransitionDisabler.\n@@ -281,1 +281,1 @@\n-    Atomic::inc(&_VTMT_disable_count);\n+    Atomic::inc(&_VTMS_transition_disable_count);\n@@ -285,1 +285,1 @@\n-    while (_VTMT_count > 0) {\n+    while (_VTMS_transition_count > 0) {\n@@ -291,1 +291,1 @@\n-    assert(!thread->is_VTMT_disabler(), \"VTMT sanity check\");\n+    assert(!thread->is_VTMS_transition_disabler(), \"VTMS_transition sanity check\");\n@@ -294,1 +294,1 @@\n-      thread->set_is_VTMT_disabler(true);\n+      thread->set_is_VTMS_transition_disabler(true);\n@@ -301,1 +301,1 @@\n-      fatal(\"stuck in JvmtiVTMTDisabler::disable_VTMT\");\n+      fatal(\"stuck in JvmtiVTMSTransitionDisabler::disable_VTMS_transitions\");\n@@ -307,1 +307,1 @@\n-JvmtiVTMTDisabler::enable_VTMT() {\n+JvmtiVTMSTransitionDisabler::enable_VTMS_transitions() {\n@@ -310,2 +310,2 @@\n-    MonitorLocker ml(JvmtiVTMT_lock, Mutex::_no_safepoint_check_flag);\n-    assert(_VTMT_disable_count > 0, \"VTMT sanity check\");\n+    MonitorLocker ml(JvmtiVTMSTransition_lock, Mutex::_no_safepoint_check_flag);\n+    assert(_VTMS_transition_disable_count > 0, \"VTMS_transition sanity check\");\n@@ -316,2 +316,2 @@\n-    Atomic::dec(&_VTMT_disable_count);\n-    if (_VTMT_disable_count == 0 || _is_SR) {\n+    Atomic::dec(&_VTMS_transition_disable_count);\n+    if (_VTMS_transition_disable_count == 0 || _is_SR) {\n@@ -321,1 +321,1 @@\n-    current->set_is_VTMT_disabler(false);\n+    current->set_is_VTMS_transition_disabler(false);\n@@ -327,1 +327,1 @@\n-JvmtiVTMTDisabler::start_VTMT(jthread vthread, bool is_mount) {\n+JvmtiVTMSTransitionDisabler::start_VTMS_transition(jthread vthread, bool is_mount) {\n@@ -335,1 +335,1 @@\n-  Atomic::inc(&_VTMT_count); \/\/ try to enter VTMT section optmistically\n+  Atomic::inc(&_VTMS_transition_count); \/\/ Try to enter VTMS transition section optmistically.\n@@ -337,1 +337,1 @@\n-  \/\/ Do not allow suspends inside VTMT transitions.\n+  \/\/ Do not allow suspends inside VTMS transitions.\n@@ -340,1 +340,1 @@\n-  if (_VTMT_disable_count > 0 ||\n+  if (_VTMS_transition_disable_count > 0 ||\n@@ -345,2 +345,2 @@\n-    \/\/ It can cause an extra waiting cycle for VTMT disablers.\n-    Atomic::dec(&_VTMT_count);\n+    \/\/ It can cause an extra waiting cycle for VTMS transition disablers.\n+    Atomic::dec(&_VTMS_transition_count);\n@@ -350,1 +350,1 @@\n-      MonitorLocker ml(JvmtiVTMT_lock, Mutex::_no_safepoint_check_flag);\n+      MonitorLocker ml(JvmtiVTMSTransition_lock, Mutex::_no_safepoint_check_flag);\n@@ -352,1 +352,1 @@\n-      \/\/ Do not allow suspends inside VTMT transitions.\n+      \/\/ Do not allow suspends inside VTMS transitions.\n@@ -354,1 +354,1 @@\n-      if (_VTMT_disable_count > 0 ||\n+      if (_VTMS_transition_disable_count > 0 ||\n@@ -365,1 +365,1 @@\n-      Atomic::inc(&_VTMT_count);\n+      Atomic::inc(&_VTMS_transition_count);\n@@ -371,1 +371,1 @@\n-    log_error(jvmti)(\"start_VTMT: thread->is_suspended: %d is_vthread_suspended: %d\\n\\n\",\n+    log_error(jvmti)(\"start_VTMS_transition: thread->is_suspended: %d is_vthread_suspended: %d\\n\\n\",\n@@ -374,1 +374,1 @@\n-    fatal(\"stuck in JvmtiVTMTDisabler::start_VTMT\");\n+    fatal(\"stuck in JvmtiVTMSTransitionDisabler::start_VTMS_transition\");\n@@ -377,3 +377,3 @@\n-  \/\/ Enter VTMT section.\n-  assert(!thread->is_in_VTMT(), \"VTMT sanity check\");\n-  thread->set_is_in_VTMT(true);\n+  \/\/ Enter VTMS transition section.\n+  assert(!thread->is_in_VTMS_transition(), \"VTMS_transition sanity check\");\n+  thread->set_is_in_VTMS_transition(true);\n@@ -382,1 +382,1 @@\n-    vstate->set_is_in_VTMT(true);\n+    vstate->set_is_in_VTMS_transition(true);\n@@ -387,1 +387,1 @@\n-JvmtiVTMTDisabler::finish_VTMT(jthread vthread, bool is_mount) {\n+JvmtiVTMSTransitionDisabler::finish_VTMS_transition(jthread vthread, bool is_mount) {\n@@ -390,2 +390,2 @@\n-  assert(thread->is_in_VTMT(), \"sanity check\");\n-  thread->set_is_in_VTMT(false);\n+  assert(thread->is_in_VTMS_transition(), \"sanity check\");\n+  thread->set_is_in_VTMS_transition(false);\n@@ -396,1 +396,1 @@\n-    vstate->set_is_in_VTMT(false);\n+    vstate->set_is_in_VTMS_transition(false);\n@@ -399,1 +399,1 @@\n-  Atomic::dec(&_VTMT_count);\n+  Atomic::dec(&_VTMS_transition_count);\n@@ -401,3 +401,3 @@\n-  \/\/ Unblock waiting VTMT disablers.\n-  if (_VTMT_disable_count > 0) {\n-    MonitorLocker ml(JvmtiVTMT_lock, Mutex::_no_safepoint_check_flag);\n+  \/\/ Unblock waiting VTMS transition disablers.\n+  if (_VTMS_transition_disable_count > 0) {\n+    MonitorLocker ml(JvmtiVTMSTransition_lock, Mutex::_no_safepoint_check_flag);\n@@ -412,1 +412,1 @@\n-      MonitorLocker ml(JvmtiVTMT_lock, Mutex::_no_safepoint_check_flag);\n+      MonitorLocker ml(JvmtiVTMSTransition_lock, Mutex::_no_safepoint_check_flag);\n@@ -430,1 +430,1 @@\n-    log_error(jvmti)(\"finish_VTMT: thread->is_suspended: %d is_vthread_suspended: %d\\n\\n\",\n+    log_error(jvmti)(\"finish_VTMS_transition: thread->is_suspended: %d is_vthread_suspended: %d\\n\\n\",\n@@ -433,1 +433,1 @@\n-    fatal(\"stuck in JvmtiVTMTDisabler::finish_VTMT\");\n+    fatal(\"stuck in JvmtiVTMSTransitionDisabler::finish_VTMS_transition\");\n@@ -453,1 +453,1 @@\n-  MonitorLocker ml(JvmtiVTMT_lock, Mutex::_no_safepoint_check_flag);\n+  MonitorLocker ml(JvmtiVTMSTransition_lock, Mutex::_no_safepoint_check_flag);\n@@ -462,1 +462,1 @@\n-  MonitorLocker ml(JvmtiVTMT_lock, Mutex::_no_safepoint_check_flag);\n+  MonitorLocker ml(JvmtiVTMSTransition_lock, Mutex::_no_safepoint_check_flag);\n@@ -471,1 +471,1 @@\n-  MonitorLocker ml(JvmtiVTMT_lock, Mutex::_no_safepoint_check_flag);\n+  MonitorLocker ml(JvmtiVTMSTransition_lock, Mutex::_no_safepoint_check_flag);\n@@ -488,1 +488,1 @@\n-  MonitorLocker ml(JvmtiVTMT_lock, Mutex::_no_safepoint_check_flag);\n+  MonitorLocker ml(JvmtiVTMSTransition_lock, Mutex::_no_safepoint_check_flag);\n@@ -799,8 +799,0 @@\n-\n-int JvmtiVTMTDisabler::VTMT_disable_count() {\n-  return _VTMT_disable_count;\n-}\n-\n-int JvmtiVTMTDisabler::VTMT_count() {\n-  return _VTMT_count;\n-}\n","filename":"src\/hotspot\/share\/prims\/jvmtiThreadState.cpp","additions":65,"deletions":73,"binary":false,"changes":138,"status":"modified"},{"patch":"@@ -74,1 +74,1 @@\n-\/\/ class JvmtiVTMTDisabler\n+\/\/ class JvmtiVTMSTransitionDisabler\n@@ -76,1 +76,1 @@\n-\/\/ Virtual Threads Mount Transition (VTMT) mechanism\n+\/\/ Virtual Thread Mount State Transition (VTMS transition) mechanism\n@@ -78,1 +78,1 @@\n-class JvmtiVTMTDisabler {\n+class JvmtiVTMSTransitionDisabler {\n@@ -80,3 +80,3 @@\n-  static volatile bool _SR_mode;             \/\/ there is an active suspender or resumer\n-  static volatile int _VTMT_count;           \/\/ current number of VTMT transitions\n-  static volatile int _VTMT_disable_count;   \/\/ VTMT is disabled while it is non-zero\n+  static volatile bool _SR_mode;                      \/\/ there is an active suspender or resumer\n+  static volatile int _VTMS_transition_count;         \/\/ current number of VTMS transitions\n+  static volatile int _VTMS_transition_disable_count; \/\/ VTMS transitions are disabled while it is non-zero\n@@ -84,1 +84,1 @@\n-  bool _is_SR;                               \/\/ is suspender or resumer\n+  bool _is_SR;                                        \/\/ is suspender or resumer\n@@ -86,2 +86,2 @@\n-  void disable_VTMT();\n-  void enable_VTMT();\n+  void disable_VTMS_transitions();\n+  void enable_VTMS_transitions();\n@@ -92,2 +92,2 @@\n-  JvmtiVTMTDisabler(bool is_SR = false);\n-  ~JvmtiVTMTDisabler();\n+  JvmtiVTMSTransitionDisabler(bool is_SR = false);\n+  ~JvmtiVTMSTransitionDisabler();\n@@ -95,4 +95,2 @@\n-  static void start_VTMT(jthread vthread, bool is_mount);\n-  static void finish_VTMT(jthread vthread, bool is_mount);\n-  static int  VTMT_disable_count();\n-  static int  VTMT_count();\n+  static void start_VTMS_transition(jthread vthread, bool is_mount);\n+  static void finish_VTMS_transition(jthread vthread, bool is_mount);\n@@ -156,2 +154,2 @@\n-  bool              _is_in_VTMT; \/\/ saved JavaThread.is_in_VTMT()\n-  bool              _is_virtual; \/\/ state belongs to a virtual thread\n+  bool              _is_in_VTMS_transition; \/\/ saved JavaThread.is_in_VTMS_transition()\n+  bool              _is_virtual;            \/\/ state belongs to a virtual thread\n@@ -273,3 +271,3 @@\n-  \/\/ The JavaThread is_in_VTMT() bit saved at unmount to restore at mount.\n-  inline bool is_in_VTMT() { return _is_in_VTMT; }\n-  inline void set_is_in_VTMT(bool val) { _is_in_VTMT = val; }\n+  \/\/ The JavaThread is_in_VTMS_transition() bit saved at unmount to restore at mount.\n+  inline bool is_in_VTMS_transition() { return _is_in_VTMS_transition; }\n+  inline void set_is_in_VTMS_transition(bool val) { _is_in_VTMS_transition = val; }\n","filename":"src\/hotspot\/share\/prims\/jvmtiThreadState.hpp","additions":18,"deletions":20,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -75,2 +75,0 @@\n-PRAGMA_DIAG_PUSH\n-PRAGMA_NONNULL_IGNORED\n@@ -105,1 +103,0 @@\n-PRAGMA_DIAG_POP\n","filename":"src\/hotspot\/share\/prims\/jvmtiThreadState.inline.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/prims\/nativeEntryPoint.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"gc\/shared\/continuationGCSupport.inline.hpp\"\n@@ -1153,0 +1154,7 @@\n+    \/\/ ParallelGC can allocate objects directly into the old generation.\n+    \/\/ Then we want to relativize the derived pointers eagerly so that\n+    \/\/ old chunks are all in GC mode.\n+    assert(!UseG1GC, \"G1 can not deal with allocating outside of eden\");\n+    assert(!UseZGC, \"ZGC can not deal with allocating chunks visible to marking\");\n+    assert(!UseShenandoahGC, \"Shenandoah can not deal with allocating chunks visible to marking\");\n+    ContinuationGCSupport::transform_stack_chunk(_cont.tail());\n@@ -1800,0 +1808,6 @@\n+#if INCLUDE_ZGC || INCLUDE_SHENANDOAHGC\n+  if (UseZGC || UseShenandoahGC) {\n+    _cont.tail()->relativize_derived_pointers_concurrently();\n+  }\n+#endif\n+\n","filename":"src\/hotspot\/share\/runtime\/continuationFreezeThaw.cpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlagConstraintsRuntime.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlagConstraintsRuntime.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/runtime\/frame.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/runtime\/handles.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/runtime\/handles.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/runtime\/handles.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -733,1 +733,1 @@\n-  JVMTI_ONLY(assert(!_handshakee->is_in_VTMT(), \"no suspend allowed in VTMT transition\");)\n+  JVMTI_ONLY(assert(!_handshakee->is_in_VTMS_transition(), \"no suspend allowed in VTMS transition\");)\n","filename":"src\/hotspot\/share\/runtime\/handshake.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/runtime\/init.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/runtime\/javaFrameAnchor.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-Monitor* JvmtiVTMT_lock               = NULL;\n+Monitor* JvmtiVTMSTransition_lock     = NULL;\n@@ -136,0 +136,2 @@\n+Monitor* ContinuationRelativize_lock  = NULL;\n+\n@@ -293,1 +295,1 @@\n-  def(JvmtiVTMT_lock               , PaddedMonitor, nosafepoint); \/\/ used for Virtual Thread Mount Transition management\n+  def(JvmtiVTMSTransition_lock     , PaddedMonitor, nosafepoint); \/\/ used for Virtual Thread Mount State transition management\n@@ -320,0 +322,2 @@\n+  def(ContinuationRelativize_lock  , PaddedMonitor, nosafepoint-3);\n+\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.cpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-extern Monitor* JvmtiVTMT_lock;                  \/\/ a lock for Virtual Thread Mount Transition (VTMT) management\n+extern Monitor* JvmtiVTMSTransition_lock;        \/\/ a lock for Virtual Thread Mount State transition (VTMS transition) management\n@@ -151,0 +151,2 @@\n+extern Monitor* ContinuationRelativize_lock;\n+\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/runtime\/registerMap.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/runtime\/signature.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -356,1 +356,7 @@\n-  if (is_interpreted()) {\n+  if (!is_compiled()) {\n+    \/\/ Only compiled frames have derived pointers\n+    return;\n+  }\n+\n+  assert(oopmap()->has_derived_oops() == oopmap()->has_any(OopMapValue::derived_oop_value), \"\");\n+  if (!oopmap()->has_derived_oops()) {\n@@ -378,1 +384,0 @@\n-  OrderAccess::storestore(); \/\/ to preserve that we set the offset *before* fixing the base oop\n","filename":"src\/hotspot\/share\/runtime\/stackChunkFrameStream.inline.hpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/runtime\/stackFrameStream.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/runtime\/stackFrameStream.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/runtime\/stackValue.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/runtime\/stackValue.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1050,1 +1050,1 @@\n-  _is_in_VTMT(false),\n+  _is_in_VTMS_transition(false),\n@@ -1052,1 +1052,1 @@\n-  _is_VTMT_disabler(false),\n+  _is_VTMS_transition_disabler(false),\n@@ -1750,2 +1750,2 @@\n-void JavaThread::set_is_in_VTMT(bool val) {\n-  _is_in_VTMT = val;\n+void JavaThread::set_is_in_VTMS_transition(bool val) {\n+  _is_in_VTMS_transition = val;\n@@ -1755,2 +1755,2 @@\n-void JavaThread::set_is_VTMT_disabler(bool val) {\n-  _is_VTMT_disabler = val;\n+void JavaThread::set_is_VTMS_transition_disabler(bool val) {\n+  _is_VTMS_transition_disabler = val;\n@@ -1769,3 +1769,3 @@\n-  \/\/ Suspending a JavaThread in VTMT or disabling VTMT can cause deadlocks.\n-  assert(!is_in_VTMT(), \"no suspend allowed in VTMT transition\");\n-  assert(!is_VTMT_disabler(), \"no suspend allowed for VTMT disablers\");\n+  \/\/ Suspending a JavaThread in VTMS transition or disabling VTMS transitions can cause deadlocks.\n+  assert(!is_in_VTMS_transition(), \"no suspend allowed in VTMS transition\");\n+  assert(!is_VTMS_transition_disabler(), \"no suspend allowed for VTMS transition disablers\");\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -923,1 +923,1 @@\n-  bool                  _is_in_VTMT;             \/\/ thread is in virtual thread mount transition\n+  bool                  _is_in_VTMS_transition;          \/\/ thread is in virtual thread mount state transition\n@@ -925,1 +925,1 @@\n-  bool                  _is_VTMT_disabler;       \/\/ thread currently disabled VTMT\n+  bool                  _is_VTMS_transition_disabler;    \/\/ thread currently disabled VTMS transitions\n@@ -1244,2 +1244,2 @@\n-  bool is_in_VTMT() const                        { return _is_in_VTMT; }\n-  void set_is_in_VTMT(bool val);\n+  bool is_in_VTMS_transition() const             { return _is_in_VTMS_transition; }\n+  void set_is_in_VTMS_transition(bool val);\n@@ -1247,2 +1247,2 @@\n-  bool is_VTMT_disabler() const                  { return _is_VTMT_disabler; }\n-  void set_is_VTMT_disabler(bool val);\n+  bool is_VTMS_transition_disabler() const       { return _is_VTMS_transition_disabler; }\n+  void set_is_VTMS_transition_disabler(bool val);\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/runtime\/threadSMR.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -295,1 +295,1 @@\n-  assert(stack_chunk() == NULL, \"\"); \/\/ unsupported for now because seems to be unused\n+  assert(stack_chunk() == NULL, \"Not supported for heap frames\"); \/\/ unsupported for now because seems to be unused\n@@ -300,1 +300,1 @@\n-  assert(stack_chunk() == NULL, \"\"); \/\/ unsupported for now because seems to be unused\n+  assert(stack_chunk() == NULL, \"Not supported for heap frames\"); \/\/ unsupported for now because seems to be unused\n@@ -323,1 +323,0 @@\n-  \/\/ assert((stack_chunk() != NULL) == register_map()->in_cont(), \"_in_cont: %d register_map()->in_cont(): %d\", stack_chunk() != NULL, register_map()->in_cont());\n","filename":"src\/hotspot\/share\/runtime\/vframe.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/runtime\/vframeArray.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/runtime\/vframe_hp.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/runtime\/vmOperation.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/runtime\/vmOperations.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n-* Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+* Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/services\/threadIdTable.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/services\/threadService.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/services\/threadService.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/utilities\/bitMap.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/utilities\/bitMap.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/utilities\/debug.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2010, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ApplicationShutdownHooks.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2169,3 +2169,0 @@\n-        \/\/ system properties, java.lang and other core classes are now initialized\n-        VM.initLevel(1);\n-\n@@ -2174,0 +2171,3 @@\n+\n+        \/\/ system properties, java.lang and other core classes are now initialized\n+        VM.initLevel(1);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,3 +42,11 @@\n-    @Override void signal() { lock.notifyAll(); }\n-    @Override void await() throws InterruptedException { lock.wait(); }\n-    @Override void await(long timeoutMillis) throws InterruptedException {\n+    @Override\n+    void signal() {\n+        lock.notifyAll();\n+    }\n+    @Override\n+    void await() throws InterruptedException {\n+        lock.wait();\n+    }\n+\n+    @Override\n+    void await(long timeoutMillis) throws InterruptedException {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ref\/NativeReferenceQueue.java","additions":12,"deletions":4,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -61,2 +61,8 @@\n-    void signal() { notEmpty.signalAll(); }\n-    void await() throws InterruptedException { notEmpty.await(); }\n+    void signal() {\n+        notEmpty.signalAll();\n+    }\n+\n+    void await() throws InterruptedException {\n+        notEmpty.await();\n+    }\n+\n@@ -203,4 +209,5 @@\n-    public Reference<? extends T> remove(long timeout)\n-        throws IllegalArgumentException, InterruptedException {\n-        if (timeout < 0) throw new IllegalArgumentException(\"Negative timeout value\");\n-        if (timeout == 0) return remove();\n+    public Reference<? extends T> remove(long timeout) throws InterruptedException {\n+        if (timeout < 0)\n+            throw new IllegalArgumentException(\"Negative timeout value\");\n+        if (timeout == 0)\n+            return remove();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ref\/ReferenceQueue.java","additions":14,"deletions":7,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -266,1 +266,1 @@\n-      * scope-local bindings are not the same as when the flock was created\n+     * scope-local bindings are not the same as when the flock was created\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/ThreadFlock.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -114,1 +114,1 @@\n-    private Runnable target;\n+    private final Runnable target;\n@@ -263,2 +263,0 @@\n-                StackChunk c = tail;\n-\n@@ -459,5 +457,0 @@\n-    private void clean() {\n-        \/\/ if (!isStackEmpty())\n-        \/\/     clean0();\n-    }\n-\n@@ -469,6 +462,0 @@\n-    private static Map<Long, Integer> liveNmethods = new ConcurrentHashMap<>();\n-\n-    private void processNmethods(int before, int after) {\n-\n-    }\n-\n@@ -481,2 +468,1 @@\n-        mounted = newValue;\n-        \/\/ MOUNTED.setVolatile(this, newValue);\n+        mounted = newValue; \/\/ MOUNTED.setVolatile(this, newValue);\n@@ -490,2 +476,0 @@\n-    \/\/ private native void clean0();\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/Continuation.java","additions":2,"deletions":18,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -180,2 +180,2 @@\n-     * Root container. Contains all platform threads that are not started in a\n-     * container, plus some (or all) virtual threads that are started directly\n+     * Root container that \"contains\" all platform threads not started in a\n+     * container plus some (or all) virtual threads that are started directly\n@@ -184,3 +184,2 @@\n-    private static class RootContainer extends ThreadContainer {\n-        private static final Set<Thread> VTHREADS;\n-        private static final LongAdder VTHREAD_COUNT;\n+    private static abstract class RootContainer extends ThreadContainer {\n+        static final RootContainer INSTANCE;\n@@ -190,2 +189,1 @@\n-                VTHREADS = ConcurrentHashMap.newKeySet();\n-                VTHREAD_COUNT = null; \/\/new LongAdder();\n+                INSTANCE = new TrackingRootContainer();\n@@ -193,2 +191,1 @@\n-                VTHREADS = null;\n-                VTHREAD_COUNT = new LongAdder();\n+                INSTANCE = new CountingRootContainer();\n@@ -197,3 +194,1 @@\n-        static final RootContainer INSTANCE = new RootContainer();\n-\n-        private RootContainer() {\n+        protected RootContainer() {\n@@ -215,11 +210,2 @@\n-        public long threadCount() {\n-            \/\/ platform threads that are not in a container\n-            long platformThreadCount = Stream.of(JLA.getAllThreads())\n-                    .filter(t -> JLA.threadContainer(t) == null)\n-                    .count();\n-            Set<Thread> vthreads = VTHREADS;\n-            if (vthreads != null) {\n-                return platformThreadCount + vthreads.size();\n-            } else {\n-                return platformThreadCount + VTHREAD_COUNT.sum();\n-            }\n+        public String toString() {\n+            return name();\n@@ -227,0 +213,1 @@\n+\n@@ -228,3 +215,10 @@\n-        public Stream<Thread> threads() {\n-            \/\/ platform threads that are not in a container\n-            Stream<Thread> s1 = Stream.of(JLA.getAllThreads())\n+        public StackableScope previous() {\n+            return null;\n+        }\n+\n+        \/**\n+         * Returns the platform threads that are not in the container as these\n+         * threads are considered to be in the root container.\n+         *\/\n+        protected Stream<Thread> platformThreads() {\n+            return Stream.of(JLA.getAllThreads())\n@@ -232,11 +226,0 @@\n-            \/\/ virtual threads in this container, all or only those blocked on I\/O.\n-            Stream<Thread> s2;\n-            Set<Thread> vthreads = VTHREADS;\n-            if (vthreads != null) {\n-                s2 = vthreads.stream();\n-            } else {\n-                s2 = Poller.blockedThreads()\n-                        .filter(t -> t.isVirtual()\n-                                && JLA.threadContainer(t) == this);\n-            }\n-            return Stream.concat(s1, s2);\n@@ -244,3 +227,24 @@\n-        @Override\n-        public String toString() {\n-            return name();\n+\n+        \/**\n+         * Root container that tracks all threads.\n+         *\/\n+        private static class TrackingRootContainer extends RootContainer {\n+            private static final Set<Thread> VTHREADS = ConcurrentHashMap.newKeySet();\n+            @Override\n+            public void onStart(Thread thread) {\n+                assert thread.isVirtual();\n+                VTHREADS.add(thread);\n+            }\n+            @Override\n+            public void onExit(Thread thread) {\n+                assert thread.isVirtual();\n+                VTHREADS.remove(thread);\n+            }\n+            @Override\n+            public long threadCount() {\n+                return platformThreads().count() + VTHREADS.size();\n+            }\n+            @Override\n+            public Stream<Thread> threads() {\n+                return Stream.concat(platformThreads(), VTHREADS.stream());\n+            }\n@@ -248,7 +252,10 @@\n-        @Override\n-        public void onStart(Thread thread) {\n-            assert thread.isVirtual();\n-            Set<Thread> vthreads = VTHREADS;\n-            if (vthreads != null) {\n-                vthreads.add(thread);\n-            } else {\n+\n+        \/**\n+         * Root container that tracks all platform threads and just keeps a\n+         * count of the virtual threads.\n+         *\/\n+        private static class CountingRootContainer extends RootContainer {\n+            private static final LongAdder VTHREAD_COUNT = new LongAdder();\n+            @Override\n+            public void onStart(Thread thread) {\n+                assert thread.isVirtual();\n@@ -257,8 +264,3 @@\n-        }\n-        @Override\n-        public void onExit(Thread thread) {\n-            assert thread.isVirtual();\n-            Set<Thread> vthreads = VTHREADS;\n-            if (vthreads != null) {\n-                vthreads.remove(thread);\n-            } else {\n+            @Override\n+            public void onExit(Thread thread) {\n+                assert thread.isVirtual();\n@@ -267,4 +269,12 @@\n-        }\n-        @Override\n-        public StackableScope previous() {\n-            return null;\n+            @Override\n+            public long threadCount() {\n+                return platformThreads().count() + VTHREAD_COUNT.sum();\n+            }\n+            @Override\n+            public Stream<Thread> threads() {\n+                \/\/ virtual threads in this container that are those blocked on I\/O.\n+                Stream<Thread> blockedVirtualThreads = Poller.blockedThreads()\n+                        .filter(t -> t.isVirtual()\n+                                && JLA.threadContainer(t) == this);\n+                return Stream.concat(platformThreads(), blockedVirtualThreads);\n+            }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/ThreadContainers.java","additions":70,"deletions":60,"binary":false,"changes":130,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n- * or ends virtual thread mount transition (VTMT).\n+ * or ends virtual thread mount state transition (VTMS transition).\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/annotation\/JvmtiMountTransition.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/java.base\/share\/native\/libjava\/Continuation.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/media\/sound\/Printer.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2004, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/java.management\/share\/classes\/com\/sun\/jmx\/remote\/internal\/ServerCommunicatorAdmin.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -600,0 +600,4 @@\n+     * This method returns the IDs of the platform threads that are in\n+     * deadlock. The IDs of virtual threads that are in deadlock are not\n+     * included. The IDs of platform threads that are in a cycle with\n+     * virtual threads may or may not be included.\n@@ -609,2 +613,0 @@\n-     * Its behavior with cycles involving virtual threads is not defined\n-     * in this release.\n@@ -618,1 +620,1 @@\n-     * @return an array of IDs of the threads that are monitor\n+     * @return an array of IDs of the platform threads that are monitor\n@@ -631,1 +633,1 @@\n-     * live threads.\n+     * live platform threads.\n@@ -643,2 +645,2 @@\n-     * Finds cycles of threads that are in deadlock waiting to acquire\n-     * object monitors or\n+     * Finds cycles of platform threads that are in deadlock waiting to\n+     * acquire object monitors or\n@@ -646,1 +648,0 @@\n-     *\n@@ -651,0 +652,4 @@\n+     * This method returns the IDs of the platform threads that are in\n+     * deadlock. The IDs of virtual threads that are in deadlock are not\n+     * included. The IDs of platform threads that are in a cycle with\n+     * virtual threads may or may not be included.\n@@ -654,2 +659,0 @@\n-     * Its behavior with cycles involving virtual threads is not defined\n-     * in this release.\n@@ -657,1 +660,1 @@\n-     * @return an array of IDs of the threads that are\n+     * @return an array of IDs of the platform threads that are\n@@ -840,1 +843,1 @@\n-     * Returns the thread info for all live threads with stack trace\n+     * Returns the thread info for all live platform threads with stack trace\n@@ -853,1 +856,1 @@\n-     * @return an array of {@link ThreadInfo} for all live threads.\n+     * @return an array of {@link ThreadInfo} for all live platform threads.\n@@ -879,1 +882,1 @@\n-     * Returns the thread info for all live threads\n+     * Returns the thread info for all live platform threads\n@@ -902,1 +905,1 @@\n-     * @return an array of {@link ThreadInfo} for all live threads.\n+     * @return an array of {@link ThreadInfo} for all live platform threads.\n","filename":"src\/java.management\/share\/classes\/java\/lang\/management\/ThreadMXBean.java","additions":17,"deletions":14,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import java.util.stream.Stream;\n@@ -438,0 +439,18 @@\n+    \/**\n+     * Returns an array of thread identifiers for the threads in the given\n+     * array. Returns {@code null} if {@code threads} is null or the array\n+     * of threads only includes carrier threads.\n+     *\/\n+    private long[] threadsToIds(Thread[] threads) {\n+        if (threads != null) {\n+            long[] tids = Stream.of(threads)\n+                    .filter(t -> !(t instanceof jdk.internal.misc.CarrierThread))\n+                    .mapToLong(Thread::threadId)\n+                    .toArray();\n+            if (tids.length > 0) {\n+                return tids;\n+            }\n+        }\n+        return null;\n+    }\n+\n@@ -443,10 +462,1 @@\n-        if (threads == null) {\n-            return null;\n-        }\n-\n-        long[] ids = new long[threads.length];\n-        for (int i = 0; i < threads.length; i++) {\n-            Thread t = threads[i];\n-            ids[i] = t.threadId();\n-        }\n-        return ids;\n+        return threadsToIds(threads);\n@@ -465,10 +475,1 @@\n-        if (threads == null) {\n-            return null;\n-        }\n-\n-        long[] ids = new long[threads.length];\n-        for (int i = 0; i < threads.length; i++) {\n-            Thread t = threads[i];\n-            ids[i] = t.threadId();\n-        }\n-        return ids;\n+        return threadsToIds(threads);\n","filename":"src\/java.management\/share\/classes\/sun\/management\/ThreadImpl.java","additions":21,"deletions":20,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/java.rmi\/share\/classes\/sun\/rmi\/transport\/Transport.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/memory\/FileMapInfo.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/InstanceStackChunkKlass.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/Metadata.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/events\/ThreadSleepEvent.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/events\/VirtualThreadEndEvent.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/events\/VirtualThreadPinnedEvent.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/events\/VirtualThreadStartEvent.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/events\/VirtualThreadSubmitFailedEvent.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/JVM.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/instrument\/JDKEvents.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/tool\/PrettyWriter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -123,2 +123,3 @@\n-     * Generate a thread dump to the given file in the given format. The file\n-     * must not exist. The {@code outputFile} parameter must be an absolute path.\n+     * Generate a thread dump to the given file in the given format. The\n+     * {@code outputFile} parameter must be an absolute path to a file that\n+     * does not exist.\n@@ -134,1 +135,1 @@\n-     * accessed remotely from a tool or program with a different current user\n+     * accessed remotely from a tool or program with a different current working\n@@ -138,1 +139,1 @@\n-     * @param  format the format to use (TEXT_PLAIN or JSON)\n+     * @param  format the format to use\n@@ -142,1 +143,1 @@\n-     * @throws NullPointerException if either parameter is {@code null}.\n+     * @throws NullPointerException if either parameter is {@code null}\n@@ -144,1 +145,1 @@\n-     *         If a security manager is set and its {@link\n+     *         if a security manager is set and its {@link\n@@ -147,1 +148,1 @@\n-     *         ManagementPermission(\"control\")} is denied.\n+     *         ManagementPermission(\"control\")} is denied\n","filename":"src\/jdk.management\/share\/classes\/com\/sun\/management\/HotSpotDiagnosticMXBean.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/jdk.management\/share\/classes\/com\/sun\/management\/ThreadMXBean.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,14 +40,1 @@\n-# Loom specific\n-\n-gc\/g1\/mixedgc\/TestOldGenCollectionUsage.java                            8284404 generic-all\n-gc\/whitebox\/TestConcMarkCycleWB.java                                    8284404 generic-all\n-\n-gc\/g1\/plab\/TestPLABPromotion.java                                       8278126 generic-all\n-gc\/g1\/plab\/TestPLABResize.java                                          8278126 generic-all\n-\n-gc\/stringdedup\/TestStringDeduplicationInterned.java#G1                  8278127 generic-all\n-gc\/stringdedup\/TestStringDeduplicationInterned.java#Parallel            8278127 generic-all\n-gc\/stringdedup\/TestStringDeduplicationInterned.java#Serial              8278127 generic-all\n-gc\/stringdedup\/TestStringDeduplicationInterned.java#Z                   8278127 generic-all\n-\n-gc\/z\/TestGarbageCollectorMXBean.java                                    8278129 generic-all\n+# Loom\n@@ -57,2 +44,1 @@\n-serviceability\/dcmd\/vm\/ClassLoaderStatsTest.java                        8278123 generic-all\n-\n+# JVMTI FramePop and stack depth issues using the internal Continuation API directly\n@@ -61,0 +47,3 @@\n+\n+# test issues that don't reproduce in jdk repo\n+serviceability\/dcmd\/vm\/ClassLoaderStatsTest.java                        8278123 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList-Xcomp.txt","additions":5,"deletions":16,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -179,3 +179,1 @@\n-# Loom specific\n-\n-runtime\/Thread\/StopAtExit.java                                               8283610 generic-all\n+# Loom\n@@ -183,0 +181,1 @@\n+# fails with StackOverflowError on Windows\n@@ -184,3 +183,2 @@\n-serviceability\/jvmti\/Heap\/IterateHeapWithEscapeAnalysisEnabled.java          8264699 generic-all\n-serviceability\/jvmti\/HeapMonitor\/MyPackage\/HeapMonitorVMEventsTest.java#id0  8280914 generic-all\n-serviceability\/jvmti\/HeapMonitor\/MyPackage\/HeapMonitorVMEventsTest.java#id1  8280914 generic-all\n+\n+# timeout when testing with virtual threads\n@@ -189,1 +187,1 @@\n-# Stratum mismatch\n+# stratum mismatch\n@@ -193,0 +191,4 @@\n+# obsolete test using Thread.stop\n+runtime\/Thread\/StopAtExit.java                                               8283610 generic-all\n+\n+# test issues that don't reproduce in jdk repo\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -72,1 +72,1 @@\n-        long tid = Thread.currentThread().getId();\n+        long tid = Thread.currentThread().threadId();\n@@ -109,1 +109,1 @@\n-        long tid = Thread.currentThread().getId();\n+        long tid = Thread.currentThread().threadId();\n","filename":"test\/hotspot\/jtreg\/serviceability\/dcmd\/thread\/ThreadDumpToFileTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -199,1 +199,5 @@\n-        check_jvmti_status(jni, jvmti->SuspendThread(vthread), \"Error in SuspendThread\");\n+        err = jvmti->SuspendThread(vthread);\n+        if (err == JVMTI_ERROR_THREAD_NOT_ALIVE) {\n+          continue;\n+        }\n+        check_jvmti_status(jni, err, \"Error in SuspendThread\");\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/stress\/StackTrace\/Suspended\/libGetStackTraceSuspendedStress.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+# Loom\n@@ -35,1 +36,2 @@\n-# Loom specific\n+####\n+## Test problems, not loom regressions but not reproduced in jdk\n","filename":"test\/jdk\/ProblemList-Xcomp.txt","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -43,0 +43,2 @@\n+\n+com\/sun\/jdi\/EATests.java#id0                                    8264699 generic-all\n","filename":"test\/jdk\/ProblemList-svc-vthread.txt","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -872,4 +872,1 @@\n-# Loom specific\n-\n-com\/sun\/jdi\/EATests.java#id0                                    8264699 generic-all\n-\n+# Loom\n","filename":"test\/jdk\/ProblemList.txt","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1904,1 +1904,1 @@\n-            inWait = env.targetMainThread.frame(0).location().method().name().equals(\"wait\");\n+            inWait = env.targetMainThread.frame(0).location().method().name().equals(\"wait0\");\n@@ -1910,1 +1910,1 @@\n-        StackFrame testMethodFrame = env.targetMainThread.frame(4);\n+        StackFrame testMethodFrame = env.targetMainThread.frame(5);\n","filename":"test\/jdk\/com\/sun\/jdi\/EATests.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,0 +29,3 @@\n+ * @run testng\/othervm --enable-preview -Djdk.trackAllThreads DumpThreads\n+ * @run testng\/othervm --enable-preview -Djdk.trackAllThreads=true DumpThreads\n+ * @run testng\/othervm --enable-preview -Djdk.trackAllThreadds=false DumpThreads\n@@ -47,0 +50,5 @@\n+    private static final boolean TRACK_ALL_THREADS;\n+    static {\n+        String s = System.getProperty(\"jdk.trackAllThreads\");\n+        TRACK_ALL_THREADS = (s != null) && (s.isEmpty() || Boolean.parseBoolean(s));\n+    }\n@@ -74,1 +82,1 @@\n-                if (!currentThread.isVirtual()) {\n+                if (!currentThread.isVirtual() || TRACK_ALL_THREADS) {\n@@ -109,1 +117,1 @@\n-                if (!currentThread.isVirtual()) {\n+                if (!currentThread.isVirtual() || TRACK_ALL_THREADS) {\n@@ -179,1 +187,1 @@\n-        String expect = \"#\" + thread.getId();\n+        String expect = \"#\" + thread.threadId();\n@@ -187,1 +195,1 @@\n-        String expect = \"\\\"tid\\\": \" + thread.getId();\n+        String expect = \"\\\"tid\\\": \" + thread.threadId();\n@@ -191,0 +199,3 @@\n+    \/**\n+     * Generate a file path with the given suffix to use as an output file.\n+     *\/\n@@ -198,0 +209,4 @@\n+    \/**\n+     * Return the count of the number of files in the given file that contain\n+     * the given character sequence.\n+     *\/\n@@ -204,1 +219,4 @@\n-    private static void cat(Path file) throws Exception {\n+    \/**\n+     * Return line $n of the given file.\n+     *\/\n+    private String line(Path file, long n) throws Exception {\n@@ -206,1 +224,1 @@\n-            stream.forEach(System.out::println);\n+            return stream.skip(n).findFirst().orElseThrow();\n@@ -210,1 +228,4 @@\n-    private String line(Path file, long n) throws Exception {\n+    \/**\n+     * Print the given file to standard output.\n+     *\/\n+    private static void cat(Path file) throws Exception {\n@@ -212,1 +233,1 @@\n-            return stream.skip(n).findFirst().orElseThrow();\n+            stream.forEach(System.out::println);\n","filename":"test\/jdk\/com\/sun\/management\/HotSpotDiagnosticMXBean\/DumpThreads.java","additions":29,"deletions":8,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @run testng\/othervm\/timeout=300 --enable-native-access=ALL-UNNAMED StdLibTest\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED StdLibTest\n","filename":"test\/jdk\/java\/foreign\/StdLibTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,0 +42,3 @@\n+    \/**\n+     * Test Thread.ofPlatform to create platform threads.\n+     *\/\n@@ -90,0 +93,3 @@\n+    \/**\n+     * Test Thread.ofVirtual to create virtual threads.\n+     *\/\n@@ -134,0 +140,3 @@\n+    \/**\n+     * Test Thread.Builder.name.\n+     *\/\n@@ -204,0 +213,3 @@\n+    \/**\n+     * Test Thread.Builder.OfPlatform.group.\n+     *\/\n@@ -248,0 +260,3 @@\n+    \/**\n+     * Test Thread.Builder.OfPlatform.priority.\n+     *\/\n@@ -295,1 +310,1 @@\n-    @Test(expectedExceptions = { IllegalArgumentException.class })\n+    @Test\n@@ -297,1 +312,3 @@\n-        Thread.ofPlatform().priority(Thread.MIN_PRIORITY - 1);\n+        var builder = Thread.ofPlatform();\n+        assertThrows(IllegalArgumentException.class,\n+                     () -> builder.priority(Thread.MIN_PRIORITY - 1));\n@@ -300,1 +317,1 @@\n-    @Test(expectedExceptions = { IllegalArgumentException.class })\n+    @Test\n@@ -302,1 +319,3 @@\n-        Thread.ofPlatform().priority(Thread.MAX_PRIORITY + 1);\n+        var builder = Thread.ofPlatform();\n+        assertThrows(IllegalArgumentException.class,\n+                     () -> builder.priority(Thread.MAX_PRIORITY + 1));\n@@ -305,0 +324,3 @@\n+    \/**\n+     * Test Thread.Builder.OfPlatform.daemon.\n+     *\/\n@@ -359,0 +381,3 @@\n+    \/**\n+     * Test Thread.ofVirtual creates daemon threads.\n+     *\/\n@@ -373,1 +398,3 @@\n-\n+    \/**\n+     * Test Thread.Builder.OfPlatform.stackSize.\n+     *\/\n@@ -377,1 +404,0 @@\n-\n@@ -386,1 +412,0 @@\n-\n@@ -392,1 +417,1 @@\n-    @Test(expectedExceptions = { IllegalArgumentException.class })\n+    @Test\n@@ -394,1 +419,2 @@\n-        Thread.ofPlatform().stackSize(-1);\n+        var builder = Thread.ofPlatform();\n+        assertThrows(IllegalArgumentException.class, () -> builder.stackSize(-1));\n@@ -397,0 +423,3 @@\n+    \/**\n+     * Test Thread.Builder.uncaughtExceptionHandler.\n+     *\/\n@@ -533,0 +562,3 @@\n+    \/**\n+     * Test Thread.Builder creates threads that allow thread locals.\n+     *\/\n@@ -545,0 +577,4 @@\n+    \/**\n+     * Test Thread.Builder creating threads that disallow or allow\n+     * thread locals.\n+     *\/\n@@ -635,0 +671,4 @@\n+    \/**\n+     * Test Thread.Builder creating threads that inherit or do not inherit\n+     * the initial values of inheritable thread locals.\n+     *\/\n@@ -782,0 +822,4 @@\n+    \/**\n+     * Test Thread.Builder creating threads that inherit or do not inherit\n+     * the thread context class loader.\n+     *\/\n@@ -850,0 +894,3 @@\n+    \/**\n+     * Test NullPointerException.\n+     *\/\n","filename":"test\/jdk\/java\/lang\/Thread\/BuilderTest.java","additions":56,"deletions":9,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -142,1 +142,1 @@\n-            assertTrue(false);\n+            fail();\n","filename":"test\/jdk\/java\/lang\/Thread\/JoinWithDuration.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -63,1 +63,1 @@\n-            assertTrue(false);\n+            fail();\n@@ -71,1 +71,1 @@\n-            assertTrue(false);\n+            fail();\n@@ -95,1 +95,1 @@\n-            assertTrue(false);\n+            fail();\n","filename":"test\/jdk\/java\/lang\/Thread\/SleepWithDuration.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -50,11 +50,0 @@\n-    \/**\n-     * Test that a parked virtual thread can be GC'ed.\n-     *\/\n-    @Test\n-    public void testParkedThread() {\n-        var thread = Thread.ofVirtual().start(LockSupport::park);\n-        var ref = new WeakReference<>(thread);\n-        thread = null;\n-        waitUntilCleared(ref);\n-    }\n-\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/Collectable.java","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -143,1 +143,1 @@\n-                        assertTrue(false);\n+                        fail();\n@@ -149,1 +149,1 @@\n-                assertTrue(false);\n+                fail();\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/CustomScheduler.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -129,1 +129,1 @@\n-}\n\\ No newline at end of file\n+}\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/GetStackTrace.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @run testng\/othervm --enable-preview InterruptHttp\n+ * @run main\/othervm --enable-preview InterruptHttp\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/InterruptHttp.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -153,1 +153,1 @@\n-                    assertTrue(false);\n+                    fail();\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/JfrEvents.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/Locking.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -171,1 +171,1 @@\n-                    assertTrue(false);\n+                    fail();\n@@ -315,1 +315,1 @@\n-                    assertTrue(false);\n+                    fail();\n@@ -525,1 +525,1 @@\n-                    assertTrue(false);\n+                    fail();\n@@ -565,1 +565,1 @@\n-                    assertTrue(false);\n+                    fail();\n@@ -605,1 +605,1 @@\n-                    assertTrue(false);\n+                    fail();\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/NetSockets.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/Parking.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -112,1 +112,1 @@\n-}\n\\ No newline at end of file\n+}\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/PreviewFeaturesNotEnabled.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -65,1 +65,1 @@\n-                assertTrue(false);\n+                fail();\n@@ -104,1 +104,1 @@\n-                assertTrue(false);\n+                fail();\n@@ -188,1 +188,1 @@\n-                assertTrue(false);\n+                fail();\n@@ -239,1 +239,1 @@\n-                assertTrue(false);\n+                fail();\n@@ -278,1 +278,1 @@\n-                assertTrue(false);\n+                fail();\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/Reflection.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/ShutdownHook.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -648,1 +648,1 @@\n-                assertTrue(false);\n+                fail();\n@@ -675,1 +675,1 @@\n-                assertTrue(false);\n+                fail();\n@@ -846,1 +846,1 @@\n-                    assertTrue(false);\n+                    fail();\n@@ -899,1 +899,1 @@\n-                    assertTrue(false);\n+                    fail();\n@@ -1202,1 +1202,1 @@\n-                assertTrue(false);\n+                fail();\n@@ -1214,1 +1214,1 @@\n-                assertTrue(false);\n+                fail();\n@@ -1226,1 +1226,1 @@\n-                assertTrue(false);\n+                fail();\n@@ -1238,1 +1238,1 @@\n-                assertTrue(false);\n+                fail();\n@@ -1257,1 +1257,1 @@\n-                assertTrue(false);\n+                fail();\n@@ -1269,1 +1269,1 @@\n-                assertTrue(false);\n+                fail();\n@@ -1287,1 +1287,1 @@\n-                assertTrue(false);\n+                fail();\n@@ -1299,1 +1299,1 @@\n-                assertTrue(false);\n+                fail();\n@@ -1311,1 +1311,1 @@\n-                assertTrue(false);\n+                fail();\n@@ -1393,1 +1393,1 @@\n-                assertTrue(false);\n+                fail();\n@@ -1413,1 +1413,1 @@\n-                assertTrue(false);\n+                fail();\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/ThreadAPI.java","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/ThreadLocals.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/TracePinnedThreads.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -118,1 +118,1 @@\n-                    assertTrue(false);\n+                    fail();\n@@ -139,1 +139,1 @@\n-                    assertTrue(false);\n+                    fail();\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/WaitNotify.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/stress\/HttpALot.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/stress\/PinALot.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/stress\/PingPong.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,120 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @summary Stress test virtual threads with a variation of the Skynet 1M benchmark\n+ * @compile --enable-preview -source ${jdk.version} Skynet.java\n+ * @run main\/othervm\/timeout=300 --enable-preview Skynet\n+ *\/\n+\n+\/**\n+ * @test\n+ * @requires vm.debug == true\n+ * @requires vm.gc.Z\n+ * @compile --enable-preview -source ${jdk.version} Skynet.java\n+ * @run main\/othervm\/timeout=300 --enable-preview -XX:+UnlockDiagnosticVMOptions\n+ *     -XX:+ZVerifyViews -XX:ZCollectionInterval=0.01 Skynet\n+ *\/\n+\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.SynchronousQueue;\n+import java.util.concurrent.ThreadFactory;\n+\n+public class Skynet {\n+    public static final int ITERATIONS = 10;\n+\n+    public static void main(String[] args) {\n+        for (int i = 0; i < ITERATIONS; i++) {\n+            skynet(1_000_000, 499999500000L);\n+        }\n+    }\n+\n+    static void skynet(int num, long expected) {\n+        long start = System.currentTimeMillis();\n+        var chan = new Channel<Long>();\n+\n+        Thread.startVirtualThread(() -> skynet(chan, 0, num, 10));\n+\n+        long sum = chan.receive();\n+        long end = System.currentTimeMillis();\n+        System.out.format(\"Result: %d in %s ms%n\", sum, (end-start));\n+        if (sum != expected)\n+            throw new AssertionError(\"unexpected result!\");\n+    }\n+\n+    static void skynet(Channel<Long> result, int num, int size, int div) {\n+        if (size == 1) {\n+            result.send((long)num);\n+        } else {\n+            var chan = new Channel<Long>();\n+            for (int i = 0; i < div; i++) {\n+                int subNum = num + i * (size \/ div);\n+                Thread.startVirtualThread(() -> skynet(chan, subNum, size \/ div, div));\n+            }\n+            long sum = 0;\n+            for (int i = 0; i < div; i++) {\n+                sum += chan.receive();\n+            }\n+            result.send(sum);\n+        }\n+    }\n+\n+    static class Channel<T> {\n+        private final BlockingQueue<T> q;\n+\n+        Channel() {\n+            q = new SynchronousQueue<>();\n+        }\n+\n+        void send(T e) {\n+            boolean interrupted = false;\n+            while (true) {\n+                try {\n+                    q.put(e);\n+                    break;\n+                } catch (InterruptedException x) {\n+                    interrupted = true;\n+                }\n+            }\n+            if (interrupted)\n+                Thread.currentThread().interrupt();\n+        }\n+\n+        T receive() {\n+            boolean interrupted = false;\n+            T e;\n+            while (true) {\n+                try {\n+                    e = q.take();\n+                    break;\n+                } catch (InterruptedException x) {\n+                    interrupted = true;\n+                }\n+            }\n+            if (interrupted)\n+                Thread.currentThread().interrupt();\n+            return e;\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/stress\/Skynet.java","additions":120,"deletions":0,"binary":false,"changes":120,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/stress\/SleepALot.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/stress\/TEST.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/stress\/TimedGet.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/stress\/YieldALot.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -735,1 +735,1 @@\n-    @Test(expectedExceptions = { UnsupportedOperationException.class })\n+    @Test\n@@ -738,1 +738,1 @@\n-        group.suspend();\n+        assertThrows(UnsupportedOperationException.class, () -> group.suspend());\n@@ -741,1 +741,1 @@\n-    @Test(expectedExceptions = { UnsupportedOperationException.class })\n+    @Test\n@@ -744,1 +744,1 @@\n-        group.resume();\n+        assertThrows(UnsupportedOperationException.class, () -> group.resume());\n@@ -747,1 +747,1 @@\n-    @Test(expectedExceptions = { UnsupportedOperationException.class })\n+    @Test\n@@ -750,1 +750,1 @@\n-        group.stop();\n+        assertThrows(UnsupportedOperationException.class, () -> group.stop());\n@@ -760,1 +760,1 @@\n-    @Test(expectedExceptions = { NullPointerException.class })\n+    @Test\n@@ -762,1 +762,2 @@\n-        new ThreadGroup(null, \"group\");\n+        assertThrows(NullPointerException.class,\n+                     () -> new ThreadGroup(null, \"group\"));\n@@ -765,1 +766,1 @@\n-    @Test(expectedExceptions = { NullPointerException.class })\n+    @Test\n@@ -768,1 +769,2 @@\n-        group.enumerate((Thread[])null);\n+        assertThrows(NullPointerException.class,\n+                     () -> group.enumerate((Thread[]) null));\n@@ -771,1 +773,1 @@\n-    @Test(expectedExceptions = { NullPointerException.class })\n+    @Test\n@@ -774,1 +776,2 @@\n-        group.enumerate((Thread[])null, false);\n+        assertThrows(NullPointerException.class,\n+                     () -> group.enumerate((Thread[]) null, false));\n@@ -777,1 +780,1 @@\n-    @Test(expectedExceptions = { NullPointerException.class })\n+    @Test\n@@ -780,1 +783,2 @@\n-        group.enumerate((ThreadGroup[])null);\n+        assertThrows(NullPointerException.class,\n+                     () -> group.enumerate((ThreadGroup[]) null));\n@@ -783,1 +787,1 @@\n-    @Test(expectedExceptions = { NullPointerException.class })\n+    @Test\n@@ -786,1 +790,2 @@\n-        group.enumerate((ThreadGroup[])null, false);\n+        assertThrows(NullPointerException.class,\n+                     () -> group.enumerate((ThreadGroup[]) null, false));\n","filename":"test\/jdk\/java\/lang\/ThreadGroup\/BasicTests.java","additions":21,"deletions":16,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/java\/lang\/Throwable\/OverrideFillInStackTrace.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,105 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @summary Test ThredMXBean.findDeadlockedThreads with deadlocked virtual threads\n+ * @compile --enable-preview -source ${jdk.version} VirtualThreadDeadlocks.java\n+ * @run main\/othervm --enable-preview VirtualThreadDeadlocks PP\n+ * @run main\/othervm --enable-preview VirtualThreadDeadlocks PV\n+ * @run main\/othervm --enable-preview VirtualThreadDeadlocks VV\n+ *\/\n+\n+import java.lang.management.ManagementFactory;\n+import java.lang.management.ThreadMXBean;\n+import java.util.Arrays;\n+import java.util.stream.Stream;\n+\n+public class VirtualThreadDeadlocks {\n+    private static final Object LOCK1 = new Object();\n+    private static final Object LOCK2 = new Object();\n+\n+    \/**\n+     * PP = test deadlock with two platform threads\n+     * PV = test deadlock with one platform thread and one virtual thread\n+     * VV = test deadlock with two virtual threads\n+     *\/\n+    public static void main(String[] args) throws Exception {\n+\n+        \/\/ start thread1\n+        Thread.Builder builder1 = (args[0].charAt(0) == 'P')\n+                ? Thread.ofPlatform().daemon()\n+                : Thread.ofVirtual();\n+        Thread thread1 = builder1.start(() -> {\n+            synchronized (LOCK1) {\n+                try { Thread.sleep(1000); } catch (Exception e) { }\n+                synchronized (LOCK2) { }\n+            }\n+        });\n+        System.out.println(\"thread1 => \" + thread1);\n+\n+        \/\/ start thread2\n+        Thread.Builder builder2 = (args[0].charAt(1) == 'P')\n+                ? Thread.ofPlatform().daemon()\n+                : Thread.ofVirtual();\n+        Thread thread2 = builder2.start(() -> {\n+            synchronized (LOCK2) {\n+                try { Thread.sleep(1000); } catch (Exception e) { }\n+                synchronized (LOCK1) { }\n+            }\n+        });\n+        System.out.println(\"thread2 => \" + thread2);\n+\n+        System.out.println(\"Waiting for thread1 and thread2 to deadlock ...\");\n+        Thread.sleep(2000);\n+\n+        ThreadMXBean bean = ManagementFactory.getPlatformMXBean(ThreadMXBean.class);\n+        long[] deadlockedThreads = bean.findDeadlockedThreads();\n+        if (deadlockedThreads != null)\n+            Arrays.sort(deadlockedThreads);\n+        System.out.println(\"findDeadlockedThreads => \" + Arrays.toString(deadlockedThreads));\n+\n+        long[] expectedThreads = platformThreadsToIds(thread1, thread2);\n+        System.out.println(\"expected => \" + Arrays.toString(expectedThreads));\n+\n+        if (!Arrays.equals(deadlockedThreads, expectedThreads))\n+            throw new RuntimeException(\"Unexpected result\");\n+    }\n+\n+    \/**\n+     * Return an array of the thread identifiers of the platform threads in the\n+     * given array. Returns null if there are no platform threads.\n+     *\/\n+    static long[] platformThreadsToIds(Thread... threads) {\n+        long[] tids = Stream.of(threads)\n+                .filter(t -> !t.isVirtual())\n+                .mapToLong(Thread::threadId)\n+                .toArray();\n+        if (tids.length == 0) {\n+            return null;\n+        } else {\n+            Arrays.sort(tids);\n+            return tids;\n+        }\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/java\/lang\/management\/ThreadMXBean\/VirtualThreadDeadlocks.java","additions":105,"deletions":0,"binary":false,"changes":105,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,1 +47,0 @@\n-@Test\n@@ -54,0 +53,1 @@\n+    @Test\n@@ -66,0 +66,1 @@\n+    @Test\n@@ -78,0 +79,1 @@\n+    @Test\n@@ -119,0 +121,1 @@\n+    @Test\n@@ -130,0 +133,1 @@\n+    @Test\n@@ -164,0 +168,1 @@\n+    @Test\n","filename":"test\/jdk\/java\/lang\/management\/ThreadMXBean\/VirtualThreads.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/java\/util\/concurrent\/Future\/DefaultMethods.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -335,1 +335,1 @@\n-    @Test(dataProvider = \"factories\", expectedExceptions = { NullPointerException.class })\n+    @Test(dataProvider = \"factories\")\n@@ -338,1 +338,1 @@\n-        executor.submit((Runnable) null);\n+        assertThrows(NullPointerException.class, () -> executor.submit((Runnable) null));\n@@ -341,1 +341,1 @@\n-    @Test(dataProvider = \"factories\", expectedExceptions = { NullPointerException.class })\n+    @Test(dataProvider = \"factories\")\n@@ -344,1 +344,1 @@\n-        executor.submit((Callable<String>) null);\n+        assertThrows(NullPointerException.class, () -> executor.submit((Callable<String>) null));\n@@ -404,1 +404,1 @@\n-                assertTrue(false);\n+                fail();\n@@ -427,1 +427,1 @@\n-                assertTrue(false);\n+                fail();\n@@ -516,1 +516,1 @@\n-    @Test(dataProvider = \"executors\", expectedExceptions = { TimeoutException.class })\n+    @Test(dataProvider = \"executors\")\n@@ -527,1 +527,2 @@\n-            executor.invokeAny(Set.of(task1, task2), 1, TimeUnit.SECONDS);\n+            assertThrows(TimeoutException.class,\n+                         () -> executor.invokeAny(Set.of(task1, task2), 1, TimeUnit.SECONDS));\n@@ -535,1 +536,1 @@\n-    @Test(dataProvider = \"executors\", expectedExceptions = { TimeoutException.class })\n+    @Test(dataProvider = \"executors\")\n@@ -544,1 +545,2 @@\n-            executor.invokeAny(Set.of(task1, task2), 1, TimeUnit.SECONDS);\n+            assertThrows(TimeoutException.class,\n+                         () -> executor.invokeAny(Set.of(task1, task2), 1, TimeUnit.SECONDS));\n@@ -559,1 +561,1 @@\n-                assertTrue(false);\n+                fail();\n@@ -585,1 +587,1 @@\n-                assertTrue(false);\n+                fail();\n@@ -597,1 +599,1 @@\n-    @Test(dataProvider = \"executors\", expectedExceptions = { RejectedExecutionException.class })\n+    @Test(dataProvider = \"executors\")\n@@ -602,1 +604,2 @@\n-        executor.invokeAny(Set.of(task1, task2));\n+        assertThrows(RejectedExecutionException.class,\n+                     () -> executor.invokeAny(Set.of(task1, task2)));\n@@ -608,1 +611,1 @@\n-    @Test(dataProvider = \"factories\", expectedExceptions = { IllegalArgumentException.class })\n+    @Test(dataProvider = \"factories\")\n@@ -611,1 +614,1 @@\n-            executor.invokeAny(Set.of());\n+            assertThrows(IllegalArgumentException.class, () -> executor.invokeAny(Set.of()));\n@@ -618,1 +621,1 @@\n-    @Test(dataProvider = \"factories\", expectedExceptions = { IllegalArgumentException.class })\n+    @Test(dataProvider = \"factories\")\n@@ -621,1 +624,2 @@\n-            executor.invokeAny(Set.of(), 1, TimeUnit.MINUTES);\n+            assertThrows(IllegalArgumentException.class,\n+                         () -> executor.invokeAny(Set.of(), 1, TimeUnit.MINUTES));\n@@ -628,1 +632,1 @@\n-    @Test(dataProvider = \"factories\", expectedExceptions = { NullPointerException.class })\n+    @Test(dataProvider = \"factories\")\n@@ -631,1 +635,1 @@\n-            executor.invokeAny(null);\n+            assertThrows(NullPointerException.class, () -> executor.invokeAny(null));\n@@ -638,1 +642,1 @@\n-    @Test(dataProvider = \"factories\", expectedExceptions = { NullPointerException.class })\n+    @Test(dataProvider = \"factories\")\n@@ -644,1 +648,1 @@\n-            executor.invokeAny(null);\n+            assertThrows(NullPointerException.class, () -> executor.invokeAny(null));\n@@ -780,1 +784,1 @@\n-                assertTrue(false);\n+                fail();\n@@ -804,1 +808,1 @@\n-                assertTrue(false);\n+                fail();\n@@ -824,1 +828,1 @@\n-                assertTrue(false);\n+                fail();\n@@ -850,1 +854,1 @@\n-                assertTrue(false);\n+                fail();\n@@ -868,1 +872,1 @@\n-    @Test(dataProvider = \"executors\", expectedExceptions = { RejectedExecutionException.class })\n+    @Test(dataProvider = \"executors\")\n@@ -874,1 +878,2 @@\n-        executor.invokeAll(Set.of(task1, task2));\n+        assertThrows(RejectedExecutionException.class,\n+                     () -> executor.invokeAll(Set.of(task1, task2)));\n@@ -877,1 +882,1 @@\n-    @Test(dataProvider = \"executors\", expectedExceptions = { RejectedExecutionException.class })\n+    @Test(dataProvider = \"executors\")\n@@ -883,1 +888,2 @@\n-        executor.invokeAll(Set.of(task1, task2), 1, TimeUnit.SECONDS);\n+        assertThrows(RejectedExecutionException.class,\n+                     () -> executor.invokeAll(Set.of(task1, task2), 1, TimeUnit.SECONDS));\n@@ -905,1 +911,1 @@\n-    @Test(dataProvider = \"factories\", expectedExceptions = { NullPointerException.class })\n+    @Test(dataProvider = \"factories\")\n@@ -908,1 +914,1 @@\n-            executor.invokeAll(null);\n+            assertThrows(NullPointerException.class, () -> executor.invokeAll(null));\n@@ -912,1 +918,1 @@\n-    @Test(dataProvider = \"factories\", expectedExceptions = { NullPointerException.class })\n+    @Test(dataProvider = \"factories\")\n@@ -918,1 +924,1 @@\n-            executor.invokeAll(tasks);\n+            assertThrows(NullPointerException.class, () -> executor.invokeAll(tasks));\n@@ -922,1 +928,1 @@\n-    @Test(dataProvider = \"factories\", expectedExceptions = { NullPointerException.class })\n+    @Test(dataProvider = \"factories\")\n@@ -925,1 +931,2 @@\n-            executor.invokeAll(null, 1, TimeUnit.SECONDS);\n+            assertThrows(NullPointerException.class,\n+                         () -> executor.invokeAll(null, 1, TimeUnit.SECONDS));\n@@ -929,1 +936,1 @@\n-    @Test(dataProvider = \"factories\", expectedExceptions = { NullPointerException.class })\n+    @Test(dataProvider = \"factories\")\n@@ -933,1 +940,2 @@\n-            executor.invokeAll(List.of(task), 1, null);\n+            assertThrows(NullPointerException.class,\n+                         () -> executor.invokeAll(List.of(task), 1, null));\n@@ -937,1 +945,1 @@\n-    @Test(dataProvider = \"factories\", expectedExceptions = { NullPointerException.class })\n+    @Test(dataProvider = \"factories\")\n@@ -943,1 +951,2 @@\n-            executor.invokeAll(tasks, 1, TimeUnit.SECONDS);\n+            assertThrows(NullPointerException.class,\n+                         () -> executor.invokeAll(tasks, 1, TimeUnit.SECONDS));\n@@ -950,1 +959,1 @@\n-    @Test(expectedExceptions = { RejectedExecutionException.class })\n+    @Test\n@@ -953,1 +962,1 @@\n-        executor.execute(() -> { });\n+        assertThrows(RejectedExecutionException.class, () -> executor.execute(() -> { }));\n@@ -956,1 +965,1 @@\n-    @Test(expectedExceptions = { RejectedExecutionException.class })\n+    @Test\n@@ -959,1 +968,1 @@\n-        executor.submit(() -> \"foo\");\n+        assertThrows(RejectedExecutionException.class, () -> executor.submit(() -> \"foo\"));\n@@ -962,1 +971,1 @@\n-    @Test(expectedExceptions = { RejectedExecutionException.class })\n+    @Test\n@@ -965,1 +974,2 @@\n-        executor.invokeAll(List.of(() -> \"foo\"));\n+        assertThrows(RejectedExecutionException.class,\n+                     () -> executor.invokeAll(List.of(() -> \"foo\")));\n@@ -968,1 +978,1 @@\n-    @Test(expectedExceptions = { RejectedExecutionException.class })\n+    @Test\n@@ -971,1 +981,2 @@\n-        executor.invokeAny(List.of(() -> \"foo\"));\n+        assertThrows(RejectedExecutionException.class,\n+                     () -> executor.invokeAny(List.of(() -> \"foo\")));\n@@ -974,1 +985,1 @@\n-    @Test(expectedExceptions = { NullPointerException.class })\n+    @Test\n@@ -976,1 +987,2 @@\n-        Executors.newThreadPerTaskExecutor(null);\n+        assertThrows(NullPointerException.class,\n+                     () -> Executors.newThreadPerTaskExecutor(null));\n","filename":"test\/jdk\/java\/util\/concurrent\/ThreadPerTaskExecutor\/ThreadPerTaskExecutorTest.java","additions":63,"deletions":51,"binary":false,"changes":114,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/java\/util\/concurrent\/lib\/DelegatingExecutorService.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -47,1 +47,0 @@\n-@Test\n@@ -79,0 +78,1 @@\n+    @Test\n@@ -95,0 +95,1 @@\n+    @Test\n@@ -106,0 +107,1 @@\n+    @Test\n@@ -338,0 +340,4 @@\n+    \/**\n+     * Test that a thread created with the given factory cannot start a thread\n+     * in the given flock.\n+     *\/\n@@ -361,0 +367,1 @@\n+    @Test\n@@ -427,1 +434,1 @@\n-                    assertTrue(false);\n+                    fail();\n@@ -455,1 +462,1 @@\n-                        assertTrue(false);\n+                        fail();\n@@ -484,1 +491,1 @@\n-                    assertTrue(false);\n+                    fail();\n@@ -488,1 +495,1 @@\n-                    assertTrue(false);\n+                    fail();\n@@ -523,1 +530,1 @@\n-                assertTrue(false);\n+                fail();\n@@ -533,1 +540,1 @@\n-                assertTrue(false);\n+                fail();\n@@ -535,1 +542,1 @@\n-                assertTrue(false);\n+                fail();\n@@ -575,1 +582,1 @@\n-                assertTrue(false);\n+                fail();\n@@ -584,1 +591,1 @@\n-                assertTrue(false);\n+                fail();\n@@ -586,1 +593,1 @@\n-                assertTrue(false);\n+                fail();\n@@ -606,0 +613,1 @@\n+    @Test\n@@ -634,0 +642,3 @@\n+    \/**\n+     * Test that a thread created with the given factory cannot call awaitAll.\n+     *\/\n@@ -732,0 +743,4 @@\n+    \/**\n+     * Test that a thread created with the given factory cannot wakeup the\n+     * given flock.\n+     *\/\n@@ -754,0 +769,1 @@\n+    @Test\n@@ -789,0 +805,1 @@\n+    @Test\n@@ -818,0 +835,4 @@\n+    \/**\n+     * Test that a thread created with the given factory cannot close the\n+     * given flock.\n+     *\/\n@@ -908,0 +929,4 @@\n+    \/**\n+     * Test that a thread created with the given factory cannot shut down the\n+     * given flock.\n+     *\/\n@@ -930,0 +955,1 @@\n+    @Test\n@@ -935,1 +961,1 @@\n-                    assertTrue(false);\n+                    fail();\n@@ -978,0 +1004,1 @@\n+    @Test\n@@ -987,0 +1014,1 @@\n+    @Test\n","filename":"test\/jdk\/jdk\/internal\/misc\/ThreadFlock\/ThreadFlockTest.java","additions":40,"deletions":12,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-* Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+* Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,0 @@\n-*\n@@ -59,1 +58,0 @@\n-@Test\n@@ -63,0 +61,1 @@\n+    @Test\n@@ -64,1 +63,1 @@\n-        System.out.println(\"test1\");\n+        \/\/ Basic freeze and thaw\n@@ -105,10 +104,0 @@\n-        \/\/ StackWalker walker = StackWalker.getInstance();\n-        \/\/ List<String> frames = walker.walk(fs -> fs.map(StackWalker.StackFrame::getMethodName).collect(Collectors.toList()));\n-\n-        \/\/ assertEquals(frames.subList(0, 7), List.of(\"bar\", \"foo\", \"lambda$test1$0\", \"enter\", \"run\", \"test1\"));\n-\n-        \/\/ walker = StackWalkerHelper.getInstance(FOO);\n-        \/\/ frames = walker.walk(fs -> fs.map(StackWalker.StackFrame::getMethodName).collect(Collectors.toList()));\n-\n-        \/\/ assertEquals(frames, List.of(\"bar\", \"foo\", \"lambda$test1$0\", \"enter\"));\n-\n@@ -181,0 +170,1 @@\n+    @Test\n@@ -182,1 +172,1 @@\n-        System.out.println(\"testException1\");\n+        \/\/ Freeze and thaw with exceptions\n@@ -213,0 +203,1 @@\n+    @Test\n@@ -214,1 +205,1 @@\n-        System.out.println(\"testManyArgs\");\n+        \/\/ Methods with stack-passed arguments\n@@ -274,0 +265,1 @@\n+    @Test\n@@ -275,1 +267,1 @@\n-        System.out.println(\"testPinnedMonitor\");\n+        \/\/ Test pinning due to held monitor\n@@ -304,2 +296,2 @@\n-    private void testNotPinnedMonitor() {\n-        System.out.println(\"testNotPinnedMonitor\");\n+    @Test\n+    public void testNotPinnedMonitor() {\n@@ -334,2 +326,3 @@\n-    private void testPinnedNative() {\n-        System.out.println(\"testPinnedNative\");\n+    \/\/ @Test\n+    public void testPinnedNative() {\n+        \/\/ pinning due to native method\n@@ -355,2 +348,1 @@\n-            String r = (String)Basic.class.getDeclaredMethod(\"nativeBar\", long.class).invoke(null, 1L);\n-            return Integer.parseInt(r)+1;\n+            return Bar.x; \/\/ load the class\n@@ -362,6 +354,5 @@\n-    static String nativeBar(long b) {\n-        double x = 9.99;\n-        String s = \"zzz\";\n-        assert Continuation.isPinned(FOO);\n-        boolean res = Continuation.yield(FOO);\n-        assert res == false;\n+    \/\/ use a class initializer to have a native method on the stack\n+    class Bar {\n+        static {\n+            nativeBar(5);\n+        }\n@@ -369,2 +360,12 @@\n-        long r = b+1;\n-        return \"\" + r;\n+        static String nativeBar(long b) {\n+            double x = 9.99;\n+            String s = \"zzz\";\n+            assert Continuation.isPinned(FOO);\n+            boolean res = Continuation.yield(FOO);\n+            assert res == false;\n+\n+            long r = b+1;\n+            return \"\" + r;\n+        }\n+\n+        static int x = 5;\n@@ -373,2 +374,3 @@\n-    private void testPinnedCriticalSection() {\n-        System.out.println(\"testPinnedCriticalSection\");\n+    @Test\n+    public void testPinnedCriticalSection() {\n+        \/\/ pinning due to critical section\n","filename":"test\/jdk\/jdk\/internal\/vm\/Continuation\/Basic.java","additions":35,"deletions":33,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-* Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+* Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/jdk\/internal\/vm\/Continuation\/ClassUnloading.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/jdk\/internal\/vm\/Continuation\/LiveFramesDriver.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/jdk\/internal\/vm\/Continuation\/java.base\/java\/lang\/LiveFrames.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-* Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+* Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/jdk\/internal\/vm\/Continuation\/java.base\/java\/lang\/StackWalkerHelper.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,1 +56,2 @@\n-        Asserts.assertEquals(jvm.getStackTraceId(Integer.MAX_VALUE), 0L, \"Insane skip level \" + Integer.MAX_VALUE + \" should not return a valid stack trace id\");\n+        Asserts.assertEquals(jvm.getStackTraceId(Integer.MAX_VALUE), 0L, \"Insane skip level \"\n+                + Integer.MAX_VALUE + \" should not return a valid stack trace id\");\n","filename":"test\/jdk\/jdk\/jfr\/jvm\/TestGetStackTraceId.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -85,1 +85,1 @@\n-            Asserts.assertLessThan(size, 100_000_000L, \"Size of recording looks suspicious large\");\n+            Asserts.assertLessThan(size, 100_000_000L, \"Size of recording looks suspiciously large\");\n","filename":"test\/jdk\/jdk\/jfr\/threading\/TestManyVirtualThreads.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}